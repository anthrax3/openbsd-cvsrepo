head	1.56;
access;
symbols
	OPENBSD_6_1_BASE:1.56
	OPENBSD_6_0:1.52.0.4
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.49.0.4
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.43.0.4
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.2
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.36.0.4
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.2
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25;
locks; strict;
comment	@ * @;


1.56
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.55;
commitid	eA8b246voAapPTkX;

1.55
date	2017.01.09.14.04.31;	author krw;	state Exp;
branches;
next	1.54;
commitid	KJkQGNLsnMxWc9MG;

1.54
date	2016.09.26.16.25.16;	author reyk;	state Exp;
branches;
next	1.53;
commitid	VU3xx6ZIlSCM7y2e;

1.53
date	2016.09.02.12.12.51;	author reyk;	state Exp;
branches;
next	1.52;
commitid	tCJ77FP0n8bVYrYP;

1.52
date	2015.12.05.13.13.11;	author claudio;	state Exp;
branches;
next	1.51;
commitid	eFaXCW6lAjqOxsAo;

1.51
date	2015.12.02.13.41.27;	author reyk;	state Exp;
branches;
next	1.50;
commitid	vBNcEM4jmO1KceIa;

1.50
date	2015.11.28.09.52.07;	author reyk;	state Exp;
branches;
next	1.49;
commitid	Xo3TbDi9hUaP9ip0;

1.49
date	2015.05.28.17.08.09;	author florian;	state Exp;
branches;
next	1.48;
commitid	CuYEPULhoEPTPxJv;

1.48
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.47;
commitid	puppem00jmzmdm4f;

1.47
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	tOv8XK6tLyhEfayc;

1.46
date	2014.07.11.16.39.10;	author krw;	state Exp;
branches;
next	1.45;
commitid	hMaeymaqXgBsu7EB;

1.45
date	2013.11.13.20.45.50;	author benno;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2012.04.19.14.48.44;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2012.04.11.08.33.53;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2012.04.11.08.25.26;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2011.05.20.09.43.53;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2011.05.09.12.08.47;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2011.05.05.12.01.43;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.14.11.11.10;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.10.02.00.50;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.11.06.40.14;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2009.12.02.19.10.02;	author mk;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.05.23.39.51;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.05.00.20.50;	author pyr;	state Exp;
branches;
next	1.30;

1.30
date	2009.06.05.00.04.01;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.03.19.59.48;	author eric;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.02.11.33.06;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2009.02.25.17.09.55;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2008.07.19.10.52.32;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2008.01.31.09.33.39;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.29.16.32.29;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.08.20.36.36;	author pyr;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.07.17.17.00;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.19.12.08.55;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.07.08.20.24;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.07.07.19.50;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.29.23.19.18;	author pyr;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.19.10.11.59;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.07.13.39.58;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.01.20.03.39;	author pyr;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.23.17.43.36;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.15.25.40;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@/*	$OpenBSD: control.c,v 1.55 2017/01/09 14:04:31 krw Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/un.h>

#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <imsg.h>

#include "relayd.h"

#define	CONTROL_BACKLOG	5

struct ctl_connlist ctl_conns;

void		 control_accept(int, short, void *);
void		 control_close(int, struct control_sock *);

int
control_init(struct privsep *ps, struct control_sock *cs)
{
	struct relayd		*env = ps->ps_env;
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask, mode;

	if (cs->cs_name == NULL)
		return (0);

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, 0)) == -1) {
		log_warn("%s: socket", __func__);
		return (-1);
	}

	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, cs->cs_name,
	    sizeof(sun.sun_path)) >= sizeof(sun.sun_path)) {
		log_warn("%s: %s name too long", __func__, cs->cs_name);
		close(fd);
		return (-1);
	}

	if (unlink(cs->cs_name) == -1)
		if (errno != ENOENT) {
			log_warn("%s: unlink %s", __func__, cs->cs_name);
			close(fd);
			return (-1);
		}

	if (cs->cs_restricted) {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH;
	} else {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP;
	}

	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("%s: bind: %s", __func__, cs->cs_name);
		close(fd);
		(void)umask(old_umask);
		return (-1);
	}
	(void)umask(old_umask);

	if (chmod(cs->cs_name, mode) == -1) {
		log_warn("%s: chmod", __func__);
		close(fd);
		(void)unlink(cs->cs_name);
		return (-1);
	}

	cs->cs_fd = fd;
	cs->cs_env = env;

	return (0);
}

int
control_listen(struct control_sock *cs)
{
	if (cs->cs_name == NULL)
		return (0);

	if (listen(cs->cs_fd, CONTROL_BACKLOG) == -1) {
		log_warn("%s: listen", __func__);
		return (-1);
	}

	event_set(&cs->cs_ev, cs->cs_fd, EV_READ,
	    control_accept, cs);
	event_add(&cs->cs_ev, NULL);
	evtimer_set(&cs->cs_evt, control_accept, cs);

	return (0);
}

void
control_cleanup(struct control_sock *cs)
{
	if (cs->cs_name == NULL)
		return;
	event_del(&cs->cs_ev);
	event_del(&cs->cs_evt);
}

/* ARGSUSED */
void
control_accept(int listenfd, short event, void *arg)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*c;
	struct control_sock	*cs = arg;

	event_add(&cs->cs_ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	len = sizeof(sun);
	if ((connfd = accept4(listenfd,
	    (struct sockaddr *)&sun, &len, SOCK_NONBLOCK)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&cs->cs_ev);
			evtimer_add(&cs->cs_evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("%s: accept", __func__);
		return;
	}

	if ((c = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		close(connfd);
		log_warn("%s: calloc", __func__);
		return;
	}

	imsg_init(&c->iev.ibuf, connfd);
	c->iev.handler = control_dispatch_imsg;
	c->iev.events = EV_READ;
	c->iev.data = cs;	/* proc.c cheats (reuses the handler) */
	event_set(&c->iev.ev, c->iev.ibuf.fd, c->iev.events,
	    c->iev.handler, cs);
	event_add(&c->iev.ev, NULL);

	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
}

struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.fd == fd)
			break;
	}

	return (c);
}

void
control_close(int fd, struct control_sock *cs)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("%s: fd %d not found", __func__, fd);
		return;
	}

	msgbuf_clear(&c->iev.ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	event_del(&c->iev.ev);
	close(c->iev.ibuf.fd);

	/* Some file descriptors are available again. */
	if (evtimer_pending(&cs->cs_evt, NULL)) {
		evtimer_del(&cs->cs_evt);
		event_add(&cs->cs_ev, NULL);
	}

	free(c);
}

/* ARGSUSED */
void
control_dispatch_imsg(int fd, short event, void *arg)
{
	struct control_sock	*cs = arg;
	struct ctl_conn		*c;
	struct imsg		 imsg;
	struct ctl_id		 id;
	int			 n;
	int			 verbose;
	struct relayd		*env = cs->cs_env;
	struct privsep		*ps = env->sc_ps;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("%s: fd %d not found", __func__, fd);
		return;
	}

	if (event & EV_READ) {
		if (((n = imsg_read(&c->iev.ibuf)) == -1 && errno != EAGAIN) ||
		    n == 0) {
			control_close(fd, cs);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&c->iev.ibuf.w) <= 0 && errno != EAGAIN) {
			control_close(fd, cs);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
			control_close(fd, cs);
			return;
		}

		if (n == 0)
			break;

		if (c->waiting) {
			log_debug("%s: unexpected imsg %d",
			    __func__, imsg.hdr.type);
			imsg_free(&imsg);
			control_close(fd, cs);
			return;
		}

		switch (imsg.hdr.type) {
		case IMSG_CTL_SHOW_SUM:
			show(c);
			break;
		case IMSG_CTL_SESSION:
			show_sessions(c);
			break;
		case IMSG_CTL_RDR_DISABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (disable_rdr(c, &id))
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(ps, &imsg);
				imsg_compose_event(&c->iev, IMSG_CTL_OK,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			}
			break;
		case IMSG_CTL_RDR_ENABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (enable_rdr(c, &id))
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(ps, &imsg);
				imsg_compose_event(&c->iev, IMSG_CTL_OK,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			}
			break;
		case IMSG_CTL_TABLE_DISABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (disable_table(c, &id))
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(ps, &imsg);
				imsg_compose_event(&c->iev, IMSG_CTL_OK,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			}
			break;
		case IMSG_CTL_TABLE_ENABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (enable_table(c, &id))
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(ps, &imsg);
				imsg_compose_event(&c->iev, IMSG_CTL_OK,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			}
			break;
		case IMSG_CTL_HOST_DISABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (disable_host(c, &id, NULL))
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(ps, &imsg);
				imsg_compose_event(&c->iev, IMSG_CTL_OK,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			}
			break;
		case IMSG_CTL_HOST_ENABLE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(id))
				fatalx("invalid imsg header len");
			memcpy(&id, imsg.data, sizeof(id));
			if (enable_host(c, &id, NULL))
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			else {
				memcpy(imsg.data, &id, sizeof(id));
				control_imsg_forward(ps, &imsg);
				imsg_compose_event(&c->iev, IMSG_CTL_OK,
				    0, ps->ps_instance + 1, -1, NULL, 0);
			}
			break;
		case IMSG_CTL_SHUTDOWN:
		case IMSG_CTL_RELOAD:
			proc_forward_imsg(env->sc_ps, &imsg, PROC_PARENT, -1);
			break;
		case IMSG_CTL_POLL:
			proc_compose(env->sc_ps, PROC_HCE,
			    IMSG_CTL_POLL, NULL, 0);
			imsg_compose_event(&c->iev, IMSG_CTL_OK,
			    0, ps->ps_instance + 1, -1, NULL, 0);
			break;
		case IMSG_CTL_NOTIFY:
			if (c->flags & CTL_CONN_NOTIFY) {
				log_debug("%s: "
				    "client requested notify more than once",
				    __func__);
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, ps->ps_instance + 1, -1, NULL, 0);
				break;
			}
			c->flags |= CTL_CONN_NOTIFY;
			break;
		case IMSG_CTL_VERBOSE:
			IMSG_SIZE_CHECK(&imsg, &verbose);

			memcpy(&verbose, imsg.data, sizeof(verbose));

			proc_forward_imsg(env->sc_ps, &imsg, PROC_PARENT, -1);
			proc_forward_imsg(env->sc_ps, &imsg, PROC_HCE, -1);
			proc_forward_imsg(env->sc_ps, &imsg, PROC_RELAY, -1);

			memcpy(imsg.data, &verbose, sizeof(verbose));
			control_imsg_forward(ps, &imsg);
			log_setverbose(verbose);
			break;
		default:
			log_debug("%s: error handling imsg %d",
			    __func__, imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}

	imsg_event_add(&c->iev);
}

void
control_imsg_forward(struct privsep *ps, struct imsg *imsg)
{
	struct ctl_conn *c;

	TAILQ_FOREACH(c, &ctl_conns, entry)
		if (c->flags & CTL_CONN_NOTIFY)
			imsg_compose_event(&c->iev, imsg->hdr.type,
			    0, ps->ps_instance + 1, -1, imsg->data,
			    imsg->hdr.len - IMSG_HEADER_SIZE);
}
@


1.55
log
@Replace hand-rolled for(;;) traversal of ctl_conns TAILQ with
TAILQ_FOREACH().

No intentional functional change.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.54 2016/09/26 16:25:16 reyk Exp $	*/
d390 1
a390 1
			log_verbose(verbose);
@


1.54
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.53 2016/09/02 12:12:51 reyk Exp $	*/
d184 4
a187 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
@


1.53
log
@As done in httpd, remove ps_ninstances and p_instance.

OK benno@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.52 2015/12/05 13:13:11 claudio Exp $	*/
d362 2
a363 1
			proc_compose(env->sc_ps, PROC_HCE, IMSG_CTL_POLL, NULL, 0);
@


1.52
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.51 2015/12/02 13:41:27 reyk Exp $	*/
d227 1
d279 1
a279 1
				    0, 0, -1, NULL, 0);
d282 1
a282 1
				control_imsg_forward(&imsg);
d284 1
a284 1
				    0, 0, -1, NULL, 0);
d293 1
a293 1
				    0, 0, -1, NULL, 0);
d296 1
a296 1
				control_imsg_forward(&imsg);
d298 1
a298 1
				    0, 0, -1, NULL, 0);
d307 1
a307 1
				    0, 0, -1, NULL, 0);
d310 1
a310 1
				control_imsg_forward(&imsg);
d312 1
a312 1
				    0, 0, -1, NULL, 0);
d321 1
a321 1
				    0, 0, -1, NULL, 0);
d324 1
a324 1
				control_imsg_forward(&imsg);
d326 1
a326 1
				    0, 0, -1, NULL, 0);
d335 1
a335 1
				    0, 0, -1, NULL, 0);
d338 1
a338 1
				control_imsg_forward(&imsg);
d340 1
a340 1
				    0, 0, -1, NULL, 0);
d349 1
a349 1
				    0, 0, -1, NULL, 0);
d352 1
a352 1
				control_imsg_forward(&imsg);
d354 1
a354 1
				    0, 0, -1, NULL, 0);
d364 1
a364 1
			    0, 0, -1, NULL, 0);
d372 1
a372 1
				    0, 0, -1, NULL, 0);
d387 1
a387 1
			control_imsg_forward(&imsg);
d402 1
a402 1
control_imsg_forward(struct imsg *imsg)
d409 1
a409 1
			    0, imsg->hdr.pid, -1, imsg->data,
@


1.51
log
@In most cases we don't need all arguments of proc_compose*_imsg(),
so add a shortcut proc_compose*() that skips all of them.  Only use the
full argument list if needed.  The functions with full argument lists can
eventually be replaced with a nicer transaction-based approach later.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.50 2015/11/28 09:52:07 reyk Exp $	*/
d234 2
a235 1
		if ((n = imsg_read(&c->iev.ibuf)) == -1 || n == 0) {
@


1.50
log
@Use SOCK_NONBLOCK in relayd as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.49 2015/05/28 17:08:09 florian Exp $	*/
d360 1
a360 2
			proc_compose_imsg(env->sc_ps, PROC_HCE, -1,
			    IMSG_CTL_POLL, -1, NULL, 0);
@


1.49
log
@Do not try to unlink the control socket in an unprivileged child
process on shutdown.
Found while working on tame(2).
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.48 2015/01/22 17:42:09 reyk Exp $	*/
d53 1
a53 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
a95 1
	socket_set_blockmode(fd, BM_NONBLOCK);
d145 2
a146 2
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
a161 2
	socket_set_blockmode(connfd, BM_NONBLOCK);

a409 17
}

void
socket_set_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
@


1.48
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.47 2015/01/16 15:06:40 deraadt Exp $	*/
a128 1
	(void)unlink(cs->cs_name);
@


1.47
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.46 2014/07/11 16:39:10 krw Exp $	*/
d22 1
a24 2
#include <net/if.h>

d31 1
a31 3
#include <signal.h>

#include <openssl/ssl.h>
@


1.46
log
@Tweak error checking for msgbuf_write() as recommended by the imsg
gurus.

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.45 2013/11/13 20:45:50 benno Exp $	*/
a19 1
#include <sys/param.h>
@


1.45
log
@handle msgbuf_write() returning EAGAIN
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.44 2013/03/11 17:40:11 deraadt Exp $	*/
d249 1
a249 1
		if (msgbuf_write(&c->iev.ibuf.w) < 0 && errno != EAGAIN) {
@


1.44
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.43 2012/04/19 14:48:44 deraadt Exp $	*/
d249 1
a249 1
		if (msgbuf_write(&c->iev.ibuf.w) < 0) {
@


1.43
log
@relayd re-uses the event callbacks and passes the value of iev.data
as the third argument (so that should be a copy of the 5th argument
of event_set().  it boggles the mind.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.42 2012/04/11 08:33:53 deraadt Exp $	*/
d162 2
a163 1
		} else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.42
log
@delete excessive evtimer_pending; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.41 2012/04/11 08:25:26 deraadt Exp $	*/
d178 1
d227 1
a227 1
	struct control_sock	*cs = (struct control_sock *)arg;
@


1.41
log
@Do rate limiting of accept() when under pressure, like in other recent
daemons.  Light testing by some relayd users; let me know if issues
develop.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.40 2011/05/20 09:43:53 reyk Exp $	*/
d132 1
a132 2
	if (evtimer_pending(&cs->cs_evt, NULL))
		event_del(&cs->cs_evt);
@


1.40
log
@Concurrent calls of "relayctl show sessions" could crash relayd.  Fix
the show sessions handler by implementing it in an asynchronous way.

Closes PR 6509
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.39 2011/05/19 08:56:49 reyk Exp $	*/
d44 1
a44 1
void		 control_close(int);
d118 2
a119 2
	event_set(&cs->cs_ev, cs->cs_fd, EV_READ | EV_PERSIST,
	    control_accept, cs->cs_env);
d121 1
d131 3
d145 5
a149 1
	struct relayd		*env = arg;
d154 10
a163 1
		if (errno != EWOULDBLOCK && errno != EINTR)
d180 1
a180 1
	    c->iev.handler, env);
d199 1
a199 1
control_close(int fd)
d213 7
d227 1
d233 1
a233 1
	struct relayd		*env = arg;
d242 1
a242 1
			control_close(fd);
d249 1
a249 1
			control_close(fd);
d256 1
a256 1
			control_close(fd);
d267 1
a267 1
			control_close(fd);
@


1.39
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.38 2011/05/09 12:08:47 reyk Exp $	*/
d237 8
@


1.38
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.37 2011/05/05 12:01:43 reyk Exp $	*/
d330 2
a331 2
			imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
			    0, 0, -1, NULL, 0);
a338 19
		case IMSG_CTL_RELOAD:
			if (env->sc_prefork_relay > 0) {
				imsg_compose_event(&c->iev, IMSG_CTL_FAIL,
				    0, 0, -1, NULL, 0);
				break;
			}
			proc_compose_imsg(env->sc_ps, PROC_PARENT, -1, IMSG_CTL_RELOAD,
			    -1, NULL, 0);
			/*
			 * we unconditionnaly return a CTL_OK imsg because
			 * we have no choice.
			 *
			 * so in this case, the reply relayctl gets means
			 * that the reload command has been set,
			 * it doesn't say whether the command succeeded or not.
			 */
			imsg_compose_event(&c->iev, IMSG_CTL_OK,
			    0, 0, -1, NULL, 0);
			break;
d355 2
a356 2
			proc_forward_imsg(env->sc_ps, &imsg, PROC_PARENT, 0);
			proc_forward_imsg(env->sc_ps, &imsg, PROC_HCE, 0);
@


1.37
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.36 2010/05/14 11:11:10 reyk Exp $	*/
d43 1
a43 1
struct ctl_conn	*control_connbyfd(int);
a45 3
struct imsgev	*iev_main = NULL;
struct imsgev	*iev_hce = NULL;

d47 1
a47 1
control_init(void)
d49 1
d52 4
a55 1
	mode_t			 old_umask;
d63 1
a63 1
	if (strlcpy(sun.sun_path, RELAYD_SOCKET,
d65 1
a65 1
		log_warn("%s: %s name too long", __func__, RELAYD_SOCKET);
d70 1
a70 1
	if (unlink(RELAYD_SOCKET) == -1)
d72 1
a72 1
			log_warn("%s: unlink %s", __func__, RELAYD_SOCKET);
d77 8
a84 1
	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
d86 1
a86 1
		log_warn("%s: bind: %s", __func__, RELAYD_SOCKET);
d93 1
a93 1
	if (chmod(RELAYD_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
d96 1
a96 1
		(void)unlink(RELAYD_SOCKET);
d100 3
a102 3
	session_socket_blockmode(fd, BM_NONBLOCK);
	control_state.fd = fd;
	TAILQ_INIT(&ctl_conns);
d108 1
a108 2
control_listen(struct relayd *env, struct imsgev *i_main,
    struct imsgev *i_hce)
d110 2
d113 1
a113 4
	iev_main = i_main;
	iev_hce = i_hce;

	if (listen(control_state.fd, CONTROL_BACKLOG) == -1) {
d118 3
a120 3
	event_set(&control_state.ev, control_state.fd, EV_READ | EV_PERSIST,
	    control_accept, env);
	event_add(&control_state.ev, NULL);
d126 1
a126 1
control_cleanup(void)
d128 3
a130 1
	(void)unlink(RELAYD_SOCKET);
d151 1
a151 1
	session_socket_blockmode(connfd, BM_NONBLOCK);
d334 2
a335 2
			imsg_compose_event(iev_hce, IMSG_CTL_POLL,
			    0, 0,-1, NULL, 0);
d345 2
a346 2
			imsg_compose_event(iev_main, IMSG_CTL_RELOAD,
			    0, 0, -1, NULL, 0);
d369 2
a370 4
		case IMSG_CTL_LOG_VERBOSE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(verbose))
				break;
d374 4
a377 4
			imsg_compose_event(iev_hce, IMSG_CTL_LOG_VERBOSE,
			    0, 0, -1, &verbose, sizeof(verbose));
			imsg_compose_event(iev_main, IMSG_CTL_LOG_VERBOSE,
			    0, 0, -1, &verbose, sizeof(verbose));
a379 1

d406 1
a406 1
session_socket_blockmode(int fd, enum blockmodes bm)
@


1.36
log
@zero out the allocate memory for a new control connection via calloc()

ok jsg@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.35 2010/05/10 02:00:50 krw Exp $	*/
d57 1
a57 1
		log_warn("control_init: socket");
d64 1
a64 1
		log_warn("control_init: %s name too long", RELAYD_SOCKET);
d71 1
a71 1
			log_warn("control_init: unlink %s", RELAYD_SOCKET);
d78 1
a78 1
		log_warn("control_init: bind: %s", RELAYD_SOCKET);
d86 1
a86 1
		log_warn("control_init: chmod");
d108 1
a108 1
		log_warn("control_listen: listen");
d139 1
a139 1
			log_warn("control_accept: accept");
d147 1
a147 1
		log_warn("control_accept");
d179 1
a179 1
		log_warn("control_close: fd %d: not found", fd);
d203 1
a203 1
		log_warn("control_dispatch_imsg: fd %d: not found", fd);
d352 3
a354 2
				log_debug("control_dispatch_imsg: "
				    "client requested notify more than once");
d378 2
a379 2
			log_debug("control_dispatch_imsg: "
			    "error handling imsg %d", imsg.hdr.type);
@


1.35
log
@Various comment typos. 'wether' -> 'whether' (most popular), 'possiblity' ->
'possibility', 'optins' -> 'options', 'resposne' -> 'response', 'unecessary' -> 'unnecessary', 'desination' -> 'destination'. Collected from various misc@@
and tech@@ postings, many by Brad Tilley.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.34 2010/01/11 06:40:14 jsg Exp $	*/
d145 1
a145 1
	if ((c = malloc(sizeof(struct ctl_conn))) == NULL) {
@


1.34
log
@add "log brief" and "log verbose" to change logging verbosity
like several other things in the tree.

ok reyk@@ looks fine claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.33 2009/12/02 19:10:02 mk Exp $	*/
d345 1
a345 1
			 * it doesn't say wether the command succeeded or not.
@


1.33
log
@log_warn() consistency.

`OK' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.32 2009/06/05 23:39:51 pyr Exp $	*/
d199 1
d359 16
@


1.32
log
@4 handed diff with eric:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in relayctl.

This will make bgpd (and thus henning) happy. Next up are smtpd and ospfd.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.31 2009/06/05 00:20:50 pyr Exp $	*/
d139 1
a139 1
			log_warn("control_accept");
@


1.31
log
@some KNF cleanup following the last sed.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.30 2009/06/05 00:04:01 pyr Exp $	*/
d46 2
a47 2
struct imsgbuf	*ibuf_main = NULL;
struct imsgbuf	*ibuf_hce = NULL;
d100 2
a101 2
control_listen(struct relayd *env, struct imsgbuf *i_main,
    struct imsgbuf *i_hce)
d104 2
a105 2
	ibuf_main = i_main;
	ibuf_hce = i_hce;
d151 6
a156 5
	imsg_init(&c->ibuf, connfd, control_dispatch_imsg);
	c->ibuf.events = EV_READ;
	event_set(&c->ibuf.ev, c->ibuf.fd, c->ibuf.events,
	    c->ibuf.handler, env);
	event_add(&c->ibuf.ev, NULL);
d166 1
a166 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.fd != fd;
d183 1
a183 1
	msgbuf_clear(&c->ibuf.w);
d186 2
a187 2
	event_del(&c->ibuf.ev);
	close(c->ibuf.fd);
d207 1
a207 1
		if ((n = imsg_read(&c->ibuf)) == -1 || n == 0) {
d214 1
a214 1
		if (msgbuf_write(&c->ibuf.w) < 0) {
d221 1
a221 1
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1) {
d241 1
a241 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL,
d246 1
a246 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK,
d255 1
a255 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL,
d260 1
a260 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK,
d269 1
a269 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL,
d274 1
a274 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK,
d283 1
a283 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL,
d288 1
a288 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK,
d297 1
a297 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL,
d302 1
a302 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK,
d311 1
a311 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL,
d316 1
a316 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK,
d321 1
a321 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL,
d325 1
a325 1
			imsg_compose_event(ibuf_hce, IMSG_CTL_POLL,
d327 1
a327 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK,
d332 1
a332 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL,
d336 1
a336 1
			imsg_compose_event(ibuf_main, IMSG_CTL_RELOAD,
d346 1
a346 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK,
d353 1
a353 1
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL,
d367 1
a367 1
	imsg_event_add(&c->ibuf);
d377 1
a377 1
			imsg_compose_event(&c->ibuf, imsg->hdr.type,
@


1.30
log
@Make imsg completely async model agnostic by not requiring an
imsg_event_add function to be provided (which ended up being a named
callback).
Instead provide a wrapper in the daemon and call that everywhere.
Previsously discussed with the usual suspects,
ok eric@@ though not too happy about the function name
(imsg_compose_event).
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.29 2009/06/03 19:59:48 eric Exp $	*/
d240 2
a241 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
d245 2
a246 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
d254 2
a255 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
d259 2
a260 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
d268 2
a269 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
d273 2
a274 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
d282 2
a283 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
d287 2
a288 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
d296 2
a297 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
d301 2
a302 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
d310 2
a311 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
d315 2
a316 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
				    NULL, 0);
d320 2
a321 2
			imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1, NULL,
			    0);
d324 4
a327 2
			imsg_compose_event(ibuf_hce, IMSG_CTL_POLL, 0, 0,-1, NULL, 0);
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d331 2
a332 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
d335 2
a336 2
			imsg_compose_event(ibuf_main, IMSG_CTL_RELOAD, 0, 0, -1, NULL,
			    0);
d345 2
a346 1
			imsg_compose_event(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d352 2
a353 2
				imsg_compose_event(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
				    NULL, 0);
d376 3
a378 2
			imsg_compose_event(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
			    -1, imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE);
@


1.29
log
@initialize queue

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.28 2009/06/02 11:33:06 reyk Exp $	*/
d240 1
a240 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d245 1
a245 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
d254 1
a254 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d259 1
a259 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
d268 1
a268 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d273 1
a273 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
d282 1
a282 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d287 1
a287 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
d296 1
a296 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d301 1
a301 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
d310 1
a310 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d315 1
a315 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1,
d320 1
a320 1
			imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1, NULL,
d324 2
a325 2
			imsg_compose(ibuf_hce, IMSG_CTL_POLL, 0, 0,-1, NULL, 0);
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d329 1
a329 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d333 1
a333 1
			imsg_compose(ibuf_main, IMSG_CTL_RELOAD, 0, 0, -1, NULL,
d343 1
a343 1
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, -1, NULL, 0);
d349 1
a349 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1,
d373 1
a373 1
			imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
@


1.28
log
@Libevent may do an upcall with both EV_READ and EV_WRITE set.
So change the code accordingly to allow that.

Found by claudio@@ in ospfd
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.27 2009/02/25 17:09:55 claudio Exp $	*/
d94 1
@


1.27
log
@Fix an invalid pointer dereference in control_close(). If control_connbyfd()
fails -- which should never happen -- the function does not return and is
accession the NULL set control pointer later on.
Found by Matthew Haub. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.26 2008/07/19 10:52:32 reyk Exp $	*/
d204 1
a204 2
	switch (event) {
	case EV_READ:
d209 3
a211 2
		break;
	case EV_WRITE:
a215 4
		imsg_event_add(&c->ibuf);
		return;
	default:
		fatalx("unknown event");
@


1.26
log
@If the new 'parent' keyword is specified for a host in a table,
inherit the state from another host with the specified Id; no
additional check will be for the inheriting host.  This helps in
scenarios with lots of IP aliases that all point to the same service
on the same host (like web hosting with many SSL domains).

discussed with pyr, tested in different setups
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.25 2008/01/31 09:33:39 reyk Exp $	*/
d176 1
a176 1
	if ((c = control_connbyfd(fd)) == NULL)
d178 2
@


1.25
log
@add prefixes to names of structure elements to make it easier to grep
for code, start with struct relayd.  finally.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.24 2008/01/29 16:32:29 reyk Exp $	*/
d296 1
a296 1
			if (disable_host(c, &id))
d310 1
a310 1
			if (enable_host(c, &id))
@


1.24
log
@When relayd(8) accepts control it creates `connfd' descriptor with accept
function.  Close it when ctl_conn allocation fails.

From Igor Zinovik (zinovik at cs.karelia dot ru)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.23 2007/12/08 20:36:36 pyr Exp $	*/
d329 1
a329 1
			if (env->prefork_relay > 0) {
@


1.23
log
@Rename everything which reffered to services refer to rdr for internals
(for instance: rename struct service to struct rdr), refer to redirects
otherwise (hoststatectl output).
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.22 2007/12/07 17:17:00 reyk Exp $	*/
d145 1
@


1.22
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.21 2007/11/24 17:07:28 reyk Exp $	*/
d235 1
a235 1
		case IMSG_CTL_SERVICE_DISABLE:
d239 1
a239 1
			if (disable_service(c, &id))
d249 1
a249 1
		case IMSG_CTL_SERVICE_ENABLE:
d253 1
a253 1
			if (enable_service(c, &id))
@


1.21
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2007/11/19 15:31:36 reyk Exp $	*/
d37 1
a37 1
#include "hoststated.h"
d62 1
a62 1
	if (strlcpy(sun.sun_path, HOSTSTATED_SOCKET,
d64 1
a64 1
		log_warn("control_init: %s name too long", HOSTSTATED_SOCKET);
d69 1
a69 1
	if (unlink(HOSTSTATED_SOCKET) == -1)
d71 1
a71 1
			log_warn("control_init: unlink %s", HOSTSTATED_SOCKET);
d78 1
a78 1
		log_warn("control_init: bind: %s", HOSTSTATED_SOCKET);
d85 1
a85 1
	if (chmod(HOSTSTATED_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
d88 1
a88 1
		(void)unlink(HOSTSTATED_SOCKET);
d99 1
a99 1
control_listen(struct hoststated *env, struct imsgbuf *i_main,
d121 1
a121 1
	(void)unlink(HOSTSTATED_SOCKET);
d132 1
a132 1
	struct hoststated	*env = arg;
d194 1
a194 1
	struct hoststated	*env = arg;
d339 1
a339 1
			 * so in this case, the reply hoststatectl gets means
@


1.20
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2007/10/19 12:08:55 pyr Exp $	*/
a20 1
#include <sys/types.h>
d24 1
d26 1
@


1.19
log
@Add the ability to schedule an immediate check through hoststatectl.
Especially useful when interval is rather long.
I was supposed to commit this before 4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2007/09/07 08:20:24 reyk Exp $	*/
d319 1
a319 1
			imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, -1, NULL, 
@


1.18
log
@add an interface to dump running relay sessions to the control socket
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.17 2007/06/12 15:16:10 msf Exp $	*/
d46 1
d98 2
a99 1
control_listen(struct hoststated *env, struct imsgbuf *ibuf)
d102 2
a103 1
	ibuf_main = ibuf;
d321 4
@


1.17
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2007/06/07 07:19:50 pyr Exp $	*/
d227 3
@


1.16
log
@(finally) Enable reload support for layer 3 configurations.
Hoststated can be reloaded either by sending SIGHUP to the parent process
or by using ``hoststatectl reload''
discussed and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2007/05/29 23:19:18 pyr Exp $	*/
d233 1
a233 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d238 1
a238 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d247 1
a247 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d252 1
a252 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d261 1
a261 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d266 1
a266 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d275 1
a275 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d280 1
a280 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d289 1
a289 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d294 1
a294 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d303 1
a303 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d308 1
a308 1
				imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0,
d313 2
a314 1
			imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, NULL, 0);
d318 1
a318 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d322 2
a323 1
			imsg_compose(ibuf_main, IMSG_CTL_RELOAD, 0, 0, NULL, 0);
d332 1
a332 1
			imsg_compose(&c->ibuf, IMSG_CTL_OK, 0, 0, NULL, 0);
d338 1
a338 1
				imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0,
d363 1
a363 1
			    imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE);
@


1.15
log
@allow the control handling code to send messages back to the parent.
forward IMSG_CTL_RELOAD which ends up not doing anything for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2007/03/19 10:11:59 henning Exp $	*/
a320 1
			imsg_compose(&c->ibuf, IMSG_CTL_FAIL, 0, 0, NULL, 0);
d322 9
@


1.14
log
@do not signal "connection closed" upstream on EINTR/EAGAIN, from bgpd et al
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2007/02/08 13:32:24 reyk Exp $	*/
d45 2
a58 1
	bzero(&sun, sizeof(sun));
d97 1
a97 1
control_listen(void)
d100 2
d108 1
a108 1
	    control_accept, NULL);
d128 1
d148 1
a148 1
	    c->ibuf.handler, &c->ibuf);
d190 1
d313 2
d316 5
d322 1
@


1.13
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2007/02/07 13:39:58 reyk Exp $	*/
d194 1
a194 1
		if ((n = imsg_read(&c->ibuf)) <= 0) {
@


1.12
log
@remove unused functions and variables which have been copied from
ospfd(8) (can be re-imported later if required).
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2007/02/01 20:03:39 pyr Exp $	*/
d59 6
a64 1
	strlcpy(sun.sun_path, HOSTSTATED_SOCKET, sizeof(sun.sun_path));
d77 1
a77 1
		umask(old_umask);
d80 1
a80 1
	umask(old_umask);
d114 1
a114 2

	unlink(HOSTSTATED_SOCKET);
@


1.11
log
@add a monitor mode to hoststatectl to continuously report changes in
hoststated.
ok reyk@@, "looks nice and clean" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2007/01/29 14:23:31 pyr Exp $	*/
a42 1
struct ctl_conn	*control_connbypid(pid_t);
a157 12
struct ctl_conn *
control_connbypid(pid_t pid)
{
	struct ctl_conn	*c;

	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.pid != pid;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */

	return (c);
}

a325 12
}

int
control_imsg_relay(struct imsg *imsg)
{
	struct ctl_conn	*c;

	if ((c = control_connbypid(imsg->hdr.pid)) == NULL)
		return (0);

	return (imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
	    imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
@


1.10
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2007/01/23 17:43:36 claudio Exp $	*/
a41 2
int control_imsg_relay(struct imsg *imsg);

d239 3
a241 1
			else
d244 1
d253 3
a255 1
			else
d258 1
d267 3
a269 1
			else
d272 1
d281 3
a283 1
			else
d286 1
d295 3
a297 1
			else
d300 1
d309 3
a311 1
			else
d314 1
d320 10
d351 11
@


1.9
log
@Typo in fatal() message found by dunceor @@ gmail dot com
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2007/01/09 13:50:11 pyr Exp $	*/
d33 2
@


1.8
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2007/01/09 00:45:32 deraadt Exp $	*/
d331 1
a331 1
		fatal("fnctl F_GETFL");
d339 1
a339 1
		fatal("fnctl F_SETFL");
@


1.7
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2007/01/08 20:46:18 reyk Exp $	*/
d60 1
a60 1
	strlcpy(sun.sun_path, HOSTATED_SOCKET, sizeof(sun.sun_path));
d62 1
a62 1
	if (unlink(HOSTATED_SOCKET) == -1)
d64 1
a64 1
			log_warn("control_init: unlink %s", HOSTATED_SOCKET);
d71 1
a71 1
		log_warn("control_init: bind: %s", HOSTATED_SOCKET);
d78 1
a78 1
	if (chmod(HOSTATED_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
d81 1
a81 1
		(void)unlink(HOSTATED_SOCKET);
d111 1
a111 1
	unlink(HOSTATED_SOCKET);
@


1.6
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2007/01/08 13:37:26 reyk Exp $	*/
d34 1
a34 1
#include "hostated.h"
@


1.5
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2006/12/16 18:50:33 reyk Exp $	*/
a32 1
#include <regex.h>
@


1.4
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d33 1
@


1.3
log
@spacing
@
text
@d193 1
a193 1
	objid_t			 id;
d236 1
a236 1
			if (disable_service(c, id))
d247 1
a247 1
			if (enable_service(c, id))
d258 1
a258 1
			if (disable_table(c, id))
d269 1
a269 1
			if (enable_table(c, id))
d280 1
a280 1
			if (disable_host(c, id))
d291 1
a291 1
			if (enable_host(c, id))
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d238 1
a238 1
					     NULL, 0);
d241 1
a241 1
					     NULL, 0);
d249 1
a249 1
					     NULL, 0);
d252 1
a252 1
					     NULL, 0);
d260 1
a260 1
					     NULL, 0);
d263 1
a263 1
					     NULL, 0);
d271 1
a271 1
					     NULL, 0);
d274 1
a274 1
					     NULL, 0);
d282 1
a282 1
					     NULL, 0);
d285 1
a285 1
					     NULL, 0);
d293 1
a293 1
					     NULL, 0);
d296 1
a296 1
					     NULL, 0);
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d192 1
a192 1
	struct imsg	 	 imsg;
d194 1
a194 1
	int		 	 n;
@

