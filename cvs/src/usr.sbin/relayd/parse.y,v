head	1.214;
access;
symbols
	OPENBSD_6_1:1.214.0.2
	OPENBSD_6_1_BASE:1.214
	OPENBSD_6_0:1.207.0.2
	OPENBSD_6_0_BASE:1.207
	OPENBSD_5_9:1.206.0.2
	OPENBSD_5_9_BASE:1.206
	OPENBSD_5_8:1.204.0.4
	OPENBSD_5_8_BASE:1.204
	OPENBSD_5_7:1.203.0.2
	OPENBSD_5_7_BASE:1.203
	OPENBSD_5_6:1.187.0.4
	OPENBSD_5_6_BASE:1.187
	OPENBSD_5_5:1.175.0.4
	OPENBSD_5_5_BASE:1.175
	OPENBSD_5_4:1.171.0.2
	OPENBSD_5_4_BASE:1.171
	OPENBSD_5_3:1.168.0.2
	OPENBSD_5_3_BASE:1.168
	OPENBSD_5_2:1.164.0.2
	OPENBSD_5_2_BASE:1.164
	OPENBSD_5_1_BASE:1.161
	OPENBSD_5_1:1.161.0.2
	OPENBSD_5_0:1.158.0.2
	OPENBSD_5_0_BASE:1.158
	OPENBSD_4_9:1.149.0.2
	OPENBSD_4_9_BASE:1.149
	OPENBSD_4_8:1.146.0.2
	OPENBSD_4_8_BASE:1.146
	OPENBSD_4_7:1.143.0.2
	OPENBSD_4_7_BASE:1.143
	OPENBSD_4_6:1.133.0.4
	OPENBSD_4_6_BASE:1.133
	OPENBSD_4_5:1.127.0.2
	OPENBSD_4_5_BASE:1.127
	OPENBSD_4_4:1.122.0.2
	OPENBSD_4_4_BASE:1.122
	OPENBSD_4_3:1.110.0.2
	OPENBSD_4_3_BASE:1.110;
locks; strict;
comment	@ * @;


1.214
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.213;
commitid	3AKCl24jEn0sIt6p;

1.213
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.212;
commitid	uzjOUwLRoN7KbcZI;

1.212
date	2016.09.26.16.25.16;	author reyk;	state Exp;
branches;
next	1.211;
commitid	VU3xx6ZIlSCM7y2e;

1.211
date	2016.09.03.14.44.21;	author reyk;	state Exp;
branches;
next	1.210;
commitid	n0F9VKkYrh9A46uy;

1.210
date	2016.09.02.16.14.09;	author reyk;	state Exp;
branches;
next	1.209;
commitid	PZw2w24xmNM2vbc7;

1.209
date	2016.09.02.14.45.51;	author reyk;	state Exp;
branches;
next	1.208;
commitid	vcV98N2DyJGMwDyQ;

1.208
date	2016.09.01.10.49.48;	author claudio;	state Exp;
branches;
next	1.207;
commitid	kVeSpNYKmzM2uO33;

1.207
date	2016.06.21.21.35.25;	author benno;	state Exp;
branches;
next	1.206;
commitid	AL6SnrmnHkmPOpjv;

1.206
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.205;
commitid	T3JBYxNT0thPuavp;

1.205
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.204;
commitid	z3HrihslRYb4HqW9;

1.204
date	2015.05.02.13.15.24;	author claudio;	state Exp;
branches;
next	1.203;
commitid	KeIVSkhMPmj3B0K2;

1.203
date	2015.02.08.04.50.32;	author reyk;	state Exp;
branches
	1.203.2.1;
next	1.202;
commitid	jVCsun3nRn9HXgv1;

1.202
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.201;
commitid	puppem00jmzmdm4f;

1.201
date	2015.01.21.21.50.33;	author deraadt;	state Exp;
branches;
next	1.200;
commitid	3o2AkhiRPQXvG94X;

1.200
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.199;
commitid	tOv8XK6tLyhEfayc;

1.199
date	2014.12.23.13.18.23;	author reyk;	state Exp;
branches;
next	1.198;
commitid	Nz43jWMMtbJ5k60b;

1.198
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.197;
commitid	XnjIOhurXdX5o1V9;

1.197
date	2014.12.18.20.55.01;	author reyk;	state Exp;
branches;
next	1.196;
commitid	nThpdXmyvXqmRQ4C;

1.196
date	2014.12.12.10.05.09;	author reyk;	state Exp;
branches;
next	1.195;
commitid	J8g0vRzthwLCqf68;

1.195
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.194;
commitid	3Z7yItGpFsmshk0c;

1.194
date	2014.11.19.10.24.40;	author blambert;	state Exp;
branches;
next	1.193;
commitid	EGrSQMGI27r3h8Vf;

1.193
date	2014.11.07.13.48.06;	author jsing;	state Exp;
branches;
next	1.192;
commitid	QL46KAhcJy2F2EDf;

1.192
date	2014.11.02.13.59.40;	author bluhm;	state Exp;
branches;
next	1.191;
commitid	Jb29Z2q3vFfyWUb3;

1.191
date	2014.10.20.14.50.41;	author reyk;	state Exp;
branches;
next	1.190;
commitid	KIC8ch1nwP4BCbnR;

1.190
date	2014.10.15.11.06.16;	author reyk;	state Exp;
branches;
next	1.189;
commitid	VpFBc7l3plkkPKxy;

1.189
date	2014.09.05.10.19.26;	author blambert;	state Exp;
branches;
next	1.188;
commitid	Qc13eOLjGetIgjBs;

1.188
date	2014.08.29.09.03.36;	author blambert;	state Exp;
branches;
next	1.187;
commitid	YgQqK1UkUhNBtyeV;

1.187
date	2014.07.11.17.35.16;	author reyk;	state Exp;
branches;
next	1.186;
commitid	lx8x0hfeAcq4NJ7l;

1.186
date	2014.07.11.16.59.38;	author reyk;	state Exp;
branches;
next	1.185;
commitid	For422J6VfsgvmL6;

1.185
date	2014.07.11.11.48.50;	author reyk;	state Exp;
branches;
next	1.184;
commitid	6F05OKHLwEQdKZuE;

1.184
date	2014.07.09.16.42.05;	author reyk;	state Exp;
branches;
next	1.183;
commitid	YhQvyAop4vC3AmzJ;

1.183
date	2014.06.25.11.05.15;	author reyk;	state Exp;
branches;
next	1.182;
commitid	QSckC3KrSjGNpjr5;

1.182
date	2014.05.12.14.28.22;	author andre;	state Exp;
branches;
next	1.181;

1.181
date	2014.05.08.16.11.06;	author reyk;	state Exp;
branches;
next	1.180;

1.180
date	2014.04.22.08.04.23;	author reyk;	state Exp;
branches;
next	1.179;

1.179
date	2014.04.21.17.33.31;	author reyk;	state Exp;
branches;
next	1.178;

1.178
date	2014.04.20.18.16.11;	author reyk;	state Exp;
branches;
next	1.177;

1.177
date	2014.04.14.14.39.18;	author blambert;	state Exp;
branches;
next	1.176;

1.176
date	2014.04.14.12.58.04;	author blambert;	state Exp;
branches;
next	1.175;

1.175
date	2014.01.22.00.21.16;	author henning;	state Exp;
branches;
next	1.174;

1.174
date	2014.01.21.21.38.40;	author benno;	state Exp;
branches;
next	1.173;

1.173
date	2013.11.25.13.00.07;	author benno;	state Exp;
branches;
next	1.172;

1.172
date	2013.09.09.17.57.44;	author reyk;	state Exp;
branches;
next	1.171;

1.171
date	2013.05.30.20.17.12;	author reyk;	state Exp;
branches;
next	1.170;

1.170
date	2013.04.27.16.39.30;	author benno;	state Exp;
branches;
next	1.169;

1.169
date	2013.03.04.08.41.32;	author sthen;	state Exp;
branches;
next	1.168;

1.168
date	2012.10.19.16.49.50;	author reyk;	state Exp;
branches;
next	1.167;

1.167
date	2012.10.04.20.53.30;	author reyk;	state Exp;
branches;
next	1.166;

1.166
date	2012.10.03.08.40.40;	author reyk;	state Exp;
branches;
next	1.165;

1.165
date	2012.10.03.08.33.31;	author reyk;	state Exp;
branches;
next	1.164;

1.164
date	2012.05.29.23.46.50;	author benno;	state Exp;
branches;
next	1.163;

1.163
date	2012.05.08.15.10.15;	author benno;	state Exp;
branches;
next	1.162;

1.162
date	2012.04.15.03.12.30;	author jsg;	state Exp;
branches;
next	1.161;

1.161
date	2012.01.21.13.40.48;	author camield;	state Exp;
branches;
next	1.160;

1.160
date	2012.01.20.12.16.41;	author camield;	state Exp;
branches;
next	1.159;

1.159
date	2011.09.21.18.45.40;	author bluhm;	state Exp;
branches;
next	1.158;

1.158
date	2011.05.26.14.48.20;	author reyk;	state Exp;
branches;
next	1.157;

1.157
date	2011.05.23.10.44.59;	author reyk;	state Exp;
branches;
next	1.156;

1.156
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.155;

1.155
date	2011.05.09.12.08.47;	author reyk;	state Exp;
branches;
next	1.154;

1.154
date	2011.05.05.12.01.43;	author reyk;	state Exp;
branches;
next	1.153;

1.153
date	2011.05.05.10.20.24;	author phessler;	state Exp;
branches;
next	1.152;

1.152
date	2011.04.12.12.43.13;	author reyk;	state Exp;
branches;
next	1.151;

1.151
date	2011.04.12.12.37.22;	author reyk;	state Exp;
branches;
next	1.150;

1.150
date	2011.04.07.13.22.29;	author reyk;	state Exp;
branches;
next	1.149;

1.149
date	2010.10.26.15.04.37;	author reyk;	state Exp;
branches;
next	1.148;

1.148
date	2010.10.18.11.51.22;	author sthen;	state Exp;
branches;
next	1.147;

1.147
date	2010.09.02.14.03.22;	author sobrado;	state Exp;
branches;
next	1.146;

1.146
date	2010.08.07.17.59.02;	author claudio;	state Exp;
branches;
next	1.145;

1.145
date	2010.08.03.18.42.41;	author henning;	state Exp;
branches;
next	1.144;

1.144
date	2010.08.01.22.18.35;	author sthen;	state Exp;
branches;
next	1.143;

1.143
date	2010.02.24.15.44.18;	author jsg;	state Exp;
branches;
next	1.142;

1.142
date	2009.08.27.09.26.53;	author reyk;	state Exp;
branches;
next	1.141;

1.141
date	2009.08.13.13.51.21;	author reyk;	state Exp;
branches;
next	1.140;

1.140
date	2009.08.07.11.10.23;	author reyk;	state Exp;
branches;
next	1.139;

1.139
date	2009.08.07.09.44.38;	author reyk;	state Exp;
branches;
next	1.138;

1.138
date	2009.08.07.08.45.58;	author reyk;	state Exp;
branches;
next	1.137;

1.137
date	2009.08.07.08.19.37;	author reyk;	state Exp;
branches;
next	1.136;

1.136
date	2009.08.05.13.46.13;	author reyk;	state Exp;
branches;
next	1.135;

1.135
date	2009.08.05.13.37.06;	author reyk;	state Exp;
branches;
next	1.134;

1.134
date	2009.08.05.12.55.43;	author reyk;	state Exp;
branches;
next	1.133;

1.133
date	2009.04.24.14.20.24;	author reyk;	state Exp;
branches;
next	1.132;

1.132
date	2009.04.17.09.37.25;	author reyk;	state Exp;
branches;
next	1.131;

1.131
date	2009.04.02.14.30.51;	author reyk;	state Exp;
branches;
next	1.130;

1.130
date	2009.04.01.15.07.38;	author reyk;	state Exp;
branches;
next	1.129;

1.129
date	2009.04.01.14.56.38;	author reyk;	state Exp;
branches;
next	1.128;

1.128
date	2009.03.31.21.03.49;	author tobias;	state Exp;
branches;
next	1.127;

1.127
date	2008.12.05.16.53.07;	author reyk;	state Exp;
branches;
next	1.126;

1.126
date	2008.10.17.13.02.55;	author henning;	state Exp;
branches;
next	1.125;

1.125
date	2008.09.29.14.53.35;	author reyk;	state Exp;
branches;
next	1.124;

1.124
date	2008.09.29.12.07.59;	author reyk;	state Exp;
branches;
next	1.123;

1.123
date	2008.09.29.09.58.51;	author reyk;	state Exp;
branches;
next	1.122;

1.122
date	2008.07.22.23.17.37;	author reyk;	state Exp;
branches;
next	1.121;

1.121
date	2008.07.19.11.38.54;	author reyk;	state Exp;
branches;
next	1.120;

1.120
date	2008.07.19.10.52.32;	author reyk;	state Exp;
branches;
next	1.119;

1.119
date	2008.07.17.16.41.06;	author reyk;	state Exp;
branches;
next	1.118;

1.118
date	2008.07.17.16.28.07;	author reyk;	state Exp;
branches;
next	1.117;

1.117
date	2008.07.17.16.12.04;	author reyk;	state Exp;
branches;
next	1.116;

1.116
date	2008.07.17.15.10.15;	author reyk;	state Exp;
branches;
next	1.115;

1.115
date	2008.06.11.18.21.19;	author reyk;	state Exp;
branches;
next	1.114;

1.114
date	2008.05.08.02.15.34;	author reyk;	state Exp;
branches;
next	1.113;

1.113
date	2008.05.07.01.49.29;	author reyk;	state Exp;
branches;
next	1.112;

1.112
date	2008.05.06.12.58.00;	author reyk;	state Exp;
branches;
next	1.111;

1.111
date	2008.05.06.06.09.48;	author pyr;	state Exp;
branches;
next	1.110;

1.110
date	2008.03.03.16.47.28;	author reyk;	state Exp;
branches;
next	1.109;

1.109
date	2008.02.27.15.36.42;	author mpf;	state Exp;
branches;
next	1.108;

1.108
date	2008.02.26.10.09.58;	author mpf;	state Exp;
branches;
next	1.107;

1.107
date	2008.02.13.11.32.59;	author reyk;	state Exp;
branches;
next	1.106;

1.106
date	2008.02.13.11.02.37;	author reyk;	state Exp;
branches;
next	1.105;

1.105
date	2008.02.11.10.53.12;	author reyk;	state Exp;
branches;
next	1.104;

1.104
date	2008.02.11.10.42.50;	author reyk;	state Exp;
branches;
next	1.103;

1.103
date	2008.01.31.09.56.28;	author reyk;	state Exp;
branches;
next	1.102;

1.102
date	2008.01.31.09.33.39;	author reyk;	state Exp;
branches;
next	1.101;

1.101
date	2008.01.29.10.30.10;	author pyr;	state Exp;
branches;
next	1.100;

1.100
date	2007.12.08.20.36.36;	author pyr;	state Exp;
branches;
next	1.99;

1.99
date	2007.12.08.17.14.26;	author reyk;	state Exp;
branches;
next	1.98;

1.98
date	2007.12.08.17.07.08;	author reyk;	state Exp;
branches;
next	1.97;

1.97
date	2007.12.07.17.17.00;	author reyk;	state Exp;
branches;
next	1.96;

1.96
date	2007.11.26.09.38.25;	author reyk;	state Exp;
branches;
next	1.95;

1.95
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.23.09.39.42;	author reyk;	state Exp;
branches;
next	1.93;

1.93
date	2007.11.22.10.09.53;	author reyk;	state Exp;
branches;
next	1.92;

1.92
date	2007.11.21.20.31.03;	author reyk;	state Exp;
branches;
next	1.91;

1.91
date	2007.11.21.20.24.28;	author reyk;	state Exp;
branches;
next	1.90;

1.90
date	2007.11.21.20.13.20;	author reyk;	state Exp;
branches;
next	1.89;

1.89
date	2007.11.21.14.12.04;	author reyk;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.21.13.04.42;	author reyk;	state Exp;
branches;
next	1.87;

1.87
date	2007.11.20.17.08.44;	author reyk;	state Exp;
branches;
next	1.86;

1.86
date	2007.11.20.15.54.55;	author reyk;	state Exp;
branches;
next	1.85;

1.85
date	2007.11.20.15.44.21;	author pyr;	state Exp;
branches;
next	1.84;

1.84
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.83;

1.83
date	2007.11.19.15.20.18;	author reyk;	state Exp;
branches;
next	1.82;

1.82
date	2007.11.19.14.48.19;	author reyk;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.19.14.41.05;	author reyk;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.15.17.02.01;	author pyr;	state Exp;
branches;
next	1.79;

1.79
date	2007.11.14.15.58.04;	author pyr;	state Exp;
branches;
next	1.78;

1.78
date	2007.11.14.10.59.01;	author pyr;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.76;

1.76
date	2007.11.04.18.47.17;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2007.10.22.16.53.30;	author pyr;	state Exp;
branches;
next	1.74;

1.74
date	2007.10.22.12.18.15;	author reyk;	state Exp;
branches;
next	1.73;

1.73
date	2007.10.22.08.52.19;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.19.17.33.35;	author pyr;	state Exp;
branches;
next	1.71;

1.71
date	2007.10.19.14.40.51;	author pyr;	state Exp;
branches;
next	1.70;

1.70
date	2007.10.19.14.15.14;	author pyr;	state Exp;
branches;
next	1.69;

1.69
date	2007.10.19.09.08.05;	author pyr;	state Exp;
branches;
next	1.68;

1.68
date	2007.10.18.20.52.12;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.18.20.49.06;	author pyr;	state Exp;
branches;
next	1.66;

1.66
date	2007.10.18.20.32.38;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.16.20.01.23;	author mpf;	state Exp;
branches;
next	1.64;

1.64
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.13.16.35.21;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.11.14.39.17;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.09.22.32.52;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.05.15.50.56;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2007.10.02.21.04.13;	author pyr;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.02.07.21.04;	author pyr;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.01.19.12.33;	author pyr;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.01.12.34.02;	author pyr;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.10.11.59.22;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.07.07.54.58;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.05.08.48.42;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.04.14.15.05;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2007.07.05.09.42.26;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.31.18.58.09;	author pyr;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.31.18.20.03;	author pyr;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.29.18.59.54;	author pyr;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.29.00.48.04;	author pyr;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.29.00.21.10;	author pyr;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.28.17.37.16;	author pyr;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.27.19.21.15;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.26.19.58.49;	author pyr;	state Exp;
branches;
next	1.38;

1.38
date	2007.04.12.14.45.45;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.21.00.08.08;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.13.12.04.52;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.07.17.40.32;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.06.19.26.46;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.27.13.38.58;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.26.20.48.48;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.26.19.58.04;	author pyr;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.26.19.25.05;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.26.13.31.21;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.26.13.03.30;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.24.00.22.32;	author reyk;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.09.17.55.49;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.07.15.17.46;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.07.13.39.58;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.07.13.30.17;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.30.10.12.06;	author pyr;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.25.19.40.08;	author niallo;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.24.06.31.09;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.12.16.43.01;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.08.17.10.23;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.08.16.50.04;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.08.14.30.31;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.03.09.45.29;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.03.09.42.30;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.25.19.05.41;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.25.18.12.14;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.16.18.05.35;	author martin;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.17.48.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;

1.203.2.1
date	2015.09.20.11.20.16;	author benno;	state Exp;
branches;
next	;
commitid	C9WQyjgbN7h0ioOp;


desc
@@


1.214
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@/*	$OpenBSD: parse.y,v 1.213 2017/01/05 12:42:18 krw Exp $	*/

/*
 * Copyright (c) 2007 - 2014 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2008 Gilles Chehade <gilles@@openbsd.org>
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/queue.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/tree.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/pfvar.h>
#include <net/route.h>

#include <stdint.h>
#include <stdarg.h>
#include <stdio.h>
#include <unistd.h>
#include <ctype.h>
#include <err.h>
#include <endian.h>
#include <errno.h>
#include <limits.h>
#include <netdb.h>
#include <string.h>
#include <ifaddrs.h>
#include <syslog.h>
#include <md5.h>

#include "relayd.h"
#include "http.h"
#include "snmp.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...);
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

struct relayd		*conf = NULL;
static int		 errors = 0;
static int		 loadcfg = 0;
objid_t			 last_rdr_id = 0;
objid_t			 last_table_id = 0;
objid_t			 last_host_id = 0;
objid_t			 last_relay_id = 0;
objid_t			 last_proto_id = 0;
objid_t			 last_rt_id = 0;
objid_t			 last_nr_id = 0;
objid_t			 last_key_id = 0;

static struct rdr	*rdr = NULL;
static struct table	*table = NULL;
static struct relay	*rlay = NULL;
static struct host	*hst = NULL;
struct relaylist	 relays;
static struct protocol	*proto = NULL;
static struct relay_rule *rule = NULL;
static struct router	*router = NULL;
static int		 label = 0;
static int		 tagged = 0;
static int		 tag = 0;
static in_port_t	 tableport = 0;
static int		 dstmode;
static enum key_type	 keytype = KEY_TYPE_NONE;
static enum direction	 dir = RELAY_DIR_ANY;
static char		*rulefile = NULL;
static union hashkey	*hashkey = NULL;

struct address	*host_v4(const char *);
struct address	*host_v6(const char *);
int		 host_dns(const char *, struct addresslist *,
		    int, struct portrange *, const char *, int);
int		 host_if(const char *, struct addresslist *,
		    int, struct portrange *, const char *, int);
int		 host(const char *, struct addresslist *,
		    int, struct portrange *, const char *, int);
void		 host_free(struct addresslist *);

struct table	*table_inherit(struct table *);
int		 relay_id(struct relay *);
struct relay	*relay_inherit(struct relay *, struct relay *);
int		 getservice(char *);
int		 is_if_in_group(const char *, const char *);

typedef struct {
	union {
		int64_t			 number;
		char			*string;
		struct host		*host;
		struct timeval		 tv;
		struct table		*table;
		struct portrange	 port;
		struct {
			union hashkey	 key;
			int		 keyset;
		}			 key;
		enum direction		 dir;
		struct {
			struct sockaddr_storage	 ss;
			char			 name[HOST_NAME_MAX+1];
		}			 addr;
		struct {
			enum digest_type type;
			char		*digest;
		}			 digest;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	ALL APPEND BACKLOG BACKUP BUFFER CA CACHE SET CHECK CIPHERS CODE
%token	COOKIE DEMOTE DIGEST DISABLE ERROR EXPECT PASS BLOCK EXTERNAL FILENAME
%token	FORWARD FROM HASH HEADER HOST ICMP INCLUDE INET INET6 INTERFACE
%token	INTERVAL IP LABEL LISTEN VALUE LOADBALANCE LOG LOOKUP METHOD MODE NAT
%token	NO DESTINATION NODELAY NOTHING ON PARENT PATH PFTAG PORT PREFORK
%token	PRIORITY PROTO QUERYSTR REAL REDIRECT RELAY REMOVE REQUEST RESPONSE
%token	RETRY QUICK RETURN ROUNDROBIN ROUTE SACK SCRIPT SEND SESSION SNMP
%token	SOCKET SPLICE SSL STICKYADDR STYLE TABLE TAG TAGGED TCP TIMEOUT TLS TO
%token	ROUTER RTLABEL TRANSPARENT TRAP UPDATES URL VIRTUAL WITH TTL RTABLE
%token	MATCH PARAMS RANDOM LEASTSTATES SRCHASH KEY CERTIFICATE PASSWORD ECDH
%token	EDH CURVE TICKETS
%token	<v.string>	STRING
%token  <v.number>	NUMBER
%type	<v.string>	hostname interface table value optstring
%type	<v.number>	http_type loglevel quick trap
%type	<v.number>	dstmode flag forwardmode retry
%type	<v.number>	opttls opttlsclient
%type	<v.number>	redirect_proto relay_proto match
%type	<v.number>	action ruleaf key_option
%type	<v.number>	tlsdhparams tlsecdhcurve
%type	<v.port>	port
%type	<v.host>	host
%type	<v.addr>	address
%type	<v.tv>		timeout
%type	<v.digest>	digest optdigest
%type	<v.table>	tablespec
%type	<v.dir>		dir
%type	<v.key>		hashkey

%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar varset '\n'
		| grammar main '\n'
		| grammar rdr '\n'
		| grammar tabledef '\n'
		| grammar relay '\n'
		| grammar proto '\n'
		| grammar router '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 0)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

ssltls		: SSL		{
			log_warnx("%s:%d: %s",
			    file->name, yylval.lineno,
			    "please use the \"tls\" keyword"
			    " instead of \"ssl\"");
		}
		| TLS
		;

opttls		: /*empty*/	{ $$ = 0; }
		| ssltls	{ $$ = 1; }
		;

opttlsclient	: /*empty*/	{ $$ = 0; }
		| WITH ssltls	{ $$ = 1; }
		;

http_type	: STRING	{
			if (strcmp("https", $1) == 0) {
				$$ = 1;
			} else if (strcmp("http", $1) == 0) {
				$$ = 0;
			} else {
				yyerror("invalid check type: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

hostname	: /* empty */		{
			$$ = strdup("");
			if ($$ == NULL)
				fatal("calloc");
		}
		| HOST STRING	{
			if (asprintf(&$$, "Host: %s\r\nConnection: close\r\n",
			    $2) == -1)
				fatal("asprintf");
		}
		;

relay_proto	: /* empty */			{ $$ = RELAY_PROTO_TCP; }
		| TCP				{ $$ = RELAY_PROTO_TCP; }
		| STRING			{
			if (strcmp("http", $1) == 0) {
				$$ = RELAY_PROTO_HTTP;
			} else if (strcmp("dns", $1) == 0) {
				$$ = RELAY_PROTO_DNS;
			} else {
				yyerror("invalid protocol type: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

redirect_proto	: /* empty */			{ $$ = IPPROTO_TCP; }
		| TCP				{ $$ = IPPROTO_TCP; }
		| STRING			{
			struct protoent	*p;

			if ((p = getprotobyname($1)) == NULL) {
				yyerror("invalid protocol: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);

			$$ = p->p_proto;
		}
		;

eflags_l	: eflags comma eflags_l
		| eflags
		;

opteflags	: /* nothing */
		| eflags
		;

eflags		: STYLE STRING
		{
			if ((proto->style = strdup($2)) == NULL)
				fatal("out of memory");
			free($2);
		}
		;

port		: PORT STRING {
			char		*a, *b;
			int		 p[2];

			p[0] = p[1] = 0;

			a = $2;
			b = strchr($2, ':');
			if (b == NULL)
				$$.op = PF_OP_EQ;
			else {
				*b++ = '\0';
				if ((p[1] = getservice(b)) == -1) {
					free($2);
					YYERROR;
				}
				$$.op = PF_OP_RRG;
			}
			if ((p[0] = getservice(a)) == -1) {
				free($2);
				YYERROR;
			}
			$$.val[0] = p[0];
			$$.val[1] = p[1];
			free($2);
		}
		| PORT NUMBER {
			if ($2 <= 0 || $2 >= (int)USHRT_MAX) {
				yyerror("invalid port: %d", $2);
				YYERROR;
			}
			$$.val[0] = htons($2);
			$$.op = PF_OP_EQ;
		}
		;

varset		: STRING '=' STRING	{
			char *s = $1;
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

sendbuf		: NOTHING		{
			table->sendbuf = NULL;
		}
		| STRING		{
			table->sendbuf = strdup($1);
			if (table->sendbuf == NULL)
				fatal("out of memory");
			free($1);
		}
		;

main		: INTERVAL NUMBER	{
			if ((conf->sc_conf.interval.tv_sec = $2) < 0) {
				yyerror("invalid interval: %d", $2);
				YYERROR;
			}
		}
		| LOG loglevel		{
			conf->sc_conf.opts |= $2;
		}
		| TIMEOUT timeout	{
			bcopy(&$2, &conf->sc_conf.timeout,
			    sizeof(struct timeval));
		}
		| PREFORK NUMBER	{
			if ($2 <= 0 || $2 > PROC_MAX_INSTANCES) {
				yyerror("invalid number of preforked "
				    "relays: %d", $2);
				YYERROR;
			}
			conf->sc_conf.prefork_relay = $2;
		}
		| SNMP trap optstring	{
			conf->sc_conf.flags |= F_SNMP;
			if ($2)
				conf->sc_conf.flags |= F_SNMP_TRAPONLY;
			if ($3) {
				if (strlcpy(conf->sc_conf.snmp_path,
				    $3, sizeof(conf->sc_conf.snmp_path)) >=
				    sizeof(conf->sc_conf.snmp_path)) {
					yyerror("snmp path truncated");
					free($3);
					YYERROR;
				}
				free($3);
			} else
				(void)strlcpy(conf->sc_conf.snmp_path,
				    AGENTX_SOCKET,
				    sizeof(conf->sc_conf.snmp_path));
		}
		;

trap		: /* nothing */		{ $$ = 0; }
		| TRAP			{ $$ = 1; }

loglevel	: UPDATES		{ $$ = RELAYD_OPT_LOGUPDATE; }
		| ALL			{ $$ = RELAYD_OPT_LOGALL; }
		;

rdr		: REDIRECT STRING	{
			struct rdr *srv;

			conf->sc_conf.flags |= F_NEEDPF;

			if (!loadcfg) {
				free($2);
				YYACCEPT;
			}

			TAILQ_FOREACH(srv, conf->sc_rdrs, entry)
				if (!strcmp(srv->conf.name, $2))
					break;
			if (srv != NULL) {
				yyerror("redirection %s defined twice", $2);
				free($2);
				YYERROR;
			}
			if ((srv = calloc(1, sizeof (*srv))) == NULL)
				fatal("out of memory");

			if (strlcpy(srv->conf.name, $2,
			    sizeof(srv->conf.name)) >=
			    sizeof(srv->conf.name)) {
				yyerror("redirection name truncated");
				free($2);
				free(srv);
				YYERROR;
			}
			free($2);
			srv->conf.id = ++last_rdr_id;
			srv->conf.timeout.tv_sec = RELAY_TIMEOUT;
			if (last_rdr_id == INT_MAX) {
				yyerror("too many redirections defined");
				free(srv);
				YYERROR;
			}
			rdr = srv;
		} '{' optnl rdropts_l '}'	{
			if (rdr->table == NULL) {
				yyerror("redirection %s has no table",
				    rdr->conf.name);
				YYERROR;
			}
			if (TAILQ_EMPTY(&rdr->virts)) {
				yyerror("redirection %s has no virtual ip",
				    rdr->conf.name);
				YYERROR;
			}
			conf->sc_rdrcount++;
			if (rdr->backup == NULL) {
				rdr->conf.backup_id =
				    conf->sc_empty_table.conf.id;
				rdr->backup = &conf->sc_empty_table;
			} else if (rdr->backup->conf.port !=
			    rdr->table->conf.port) {
				yyerror("redirection %s uses two different "
				    "ports for its table and backup table",
				    rdr->conf.name);
				YYERROR;
			}
			if (!(rdr->conf.flags & F_DISABLE))
				rdr->conf.flags |= F_ADD;
			TAILQ_INSERT_TAIL(conf->sc_rdrs, rdr, entry);
			tableport = 0;
			rdr = NULL;
		}
		;

rdropts_l	: rdropts_l rdroptsl nl
		| rdroptsl optnl
		;

rdroptsl	: forwardmode TO tablespec interface	{
			if (hashkey != NULL) {
				memcpy(&rdr->conf.key,
				    hashkey, sizeof(rdr->conf.key));
				rdr->conf.flags |= F_HASHKEY;
				free(hashkey);
				hashkey = NULL;
			}

			switch ($1) {
			case FWD_NORMAL:
				if ($4 == NULL)
					break;
				yyerror("superfluous interface");
				free($4);
				YYERROR;
			case FWD_ROUTE:
				if ($4 != NULL)
					break;
				yyerror("missing interface to route to");
				free($4);
				YYERROR;
			case FWD_TRANS:
				yyerror("no transparent forward here");
				if ($4 != NULL)
					free($4);
				YYERROR;
			}
			if ($4 != NULL) {
				if (strlcpy($3->conf.ifname, $4,
				    sizeof($3->conf.ifname)) >=
				    sizeof($3->conf.ifname)) {
					yyerror("interface name truncated");
					free($4);
					YYERROR;
				}
				free($4);
			}

			if ($3->conf.check == CHECK_NOCHECK) {
				yyerror("table %s has no check", $3->conf.name);
				purge_table(conf, conf->sc_tables, $3);
				YYERROR;
			}
			if (rdr->backup) {
				yyerror("only one backup table is allowed");
				purge_table(conf, conf->sc_tables, $3);
				YYERROR;
			}
			if (rdr->table) {
				rdr->backup = $3;
				rdr->conf.backup_id = $3->conf.id;
				if (dstmode != rdr->conf.mode) {
					yyerror("backup table for %s with "
					    "different mode", rdr->conf.name);
					YYERROR;
				}
			} else {
				rdr->table = $3;
				rdr->conf.table_id = $3->conf.id;
				rdr->conf.mode = dstmode;
			}
			$3->conf.fwdmode = $1;
			$3->conf.rdrid = rdr->conf.id;
			$3->conf.flags |= F_USED;
		}
		| LISTEN ON STRING redirect_proto port interface {
			if (host($3, &rdr->virts,
			    SRV_MAX_VIRTS, &$5, $6, $4) <= 0) {
				yyerror("invalid virtual ip: %s", $3);
				free($3);
				free($6);
				YYERROR;
			}
			free($3);
			free($6);
			if (rdr->conf.port == 0)
				rdr->conf.port = $5.val[0];
			tableport = rdr->conf.port;
		}
		| DISABLE		{ rdr->conf.flags |= F_DISABLE; }
		| STICKYADDR		{ rdr->conf.flags |= F_STICKY; }
		| match PFTAG STRING {
			conf->sc_conf.flags |= F_NEEDPF;
			if (strlcpy(rdr->conf.tag, $3,
			    sizeof(rdr->conf.tag)) >=
			    sizeof(rdr->conf.tag)) {
				yyerror("redirection tag name truncated");
				free($3);
				YYERROR;
			}
			if ($1)
				rdr->conf.flags |= F_MATCH;
			free($3);
		}
		| SESSION TIMEOUT NUMBER		{
			if ((rdr->conf.timeout.tv_sec = $3) < 0) {
				yyerror("invalid timeout: %lld", $3);
				YYERROR;
			}
			if (rdr->conf.timeout.tv_sec > INT_MAX) {
				yyerror("timeout too large: %lld", $3);
				YYERROR;
			}
		}
		| include
		;

match		: /* empty */		{ $$ = 0; }
		| MATCH			{ $$ = 1; }
		;

forwardmode	: FORWARD		{ $$ = FWD_NORMAL; }
		| ROUTE			{ $$ = FWD_ROUTE; }
		| TRANSPARENT FORWARD	{ $$ = FWD_TRANS; }
		;

table		: '<' STRING '>'	{
			if (strlen($2) >= TABLE_NAME_SIZE) {
				yyerror("invalid table name");
				free($2);
				YYERROR;
			}
			$$ = $2;
		}
		;

tabledef	: TABLE table		{
			struct table *tb;

			if (!loadcfg) {
				free($2);
				YYACCEPT;
			}

			TAILQ_FOREACH(tb, conf->sc_tables, entry)
				if (!strcmp(tb->conf.name, $2))
					break;
			if (tb != NULL) {
				yyerror("table %s defined twice", $2);
				free($2);
				YYERROR;
			}

			if ((tb = calloc(1, sizeof (*tb))) == NULL)
				fatal("out of memory");

			if (strlcpy(tb->conf.name, $2,
			    sizeof(tb->conf.name)) >= sizeof(tb->conf.name)) {
				yyerror("table name truncated");
				free($2);
				YYERROR;
			}
			free($2);

			tb->conf.id = 0; /* will be set later */
			bcopy(&conf->sc_conf.timeout, &tb->conf.timeout,
			    sizeof(struct timeval));
			TAILQ_INIT(&tb->hosts);
			table = tb;
			dstmode = RELAY_DSTMODE_DEFAULT;
		} tabledefopts_l	{
			if (TAILQ_EMPTY(&table->hosts)) {
				yyerror("table %s has no hosts",
				    table->conf.name);
				YYERROR;
			}
			conf->sc_tablecount++;
			TAILQ_INSERT_TAIL(conf->sc_tables, table, entry);
		}
		;

tabledefopts_l	: tabledefopts_l tabledefopts
		| tabledefopts
		;

tabledefopts	: DISABLE		{ table->conf.flags |= F_DISABLE; }
		| '{' optnl tablelist_l '}'
		;

tablelist_l	: tablelist comma tablelist_l
		| tablelist optnl
		;

tablelist	: host			{
			$1->conf.tableid = table->conf.id;
			$1->tablename = table->conf.name;
			TAILQ_INSERT_TAIL(&table->hosts, $1, entry);
		}
		| include
		;

tablespec	: table			{
			struct table	*tb;
			if ((tb = calloc(1, sizeof (*tb))) == NULL)
				fatal("out of memory");
			if (strlcpy(tb->conf.name, $1,
			    sizeof(tb->conf.name)) >= sizeof(tb->conf.name)) {
				yyerror("table name truncated");
				free($1);
				YYERROR;
			}
			free($1);
			table = tb;
			dstmode = RELAY_DSTMODE_DEFAULT;
			hashkey = NULL;
		} tableopts_l		{
			struct table	*tb;
			if (table->conf.port == 0)
				table->conf.port = tableport;
			else
				table->conf.flags |= F_PORT;
			if ((tb = table_inherit(table)) == NULL)
				YYERROR;
			$$ = tb;
		}
		;

tableopts_l	: tableopts tableopts_l
		| tableopts
		;

tableopts	: CHECK tablecheck
		| port			{
			if ($1.op != PF_OP_EQ) {
				yyerror("invalid port");
				YYERROR;
			}
			table->conf.port = $1.val[0];
		}
		| TIMEOUT timeout	{
			bcopy(&$2, &table->conf.timeout,
			    sizeof(struct timeval));
		}
		| DEMOTE STRING		{
			table->conf.flags |= F_DEMOTE;
			if (strlcpy(table->conf.demote_group, $2,
			    sizeof(table->conf.demote_group))
			    >= sizeof(table->conf.demote_group)) {
				yyerror("yyparse: demote group name too long");
				free($2);
				YYERROR;
			}
			free($2);
			if (carp_demote_init(table->conf.demote_group, 1)
			    == -1) {
				yyerror("yyparse: error initializing group "
				    "'%s'", table->conf.demote_group);
				YYERROR;
			}
		}
		| INTERVAL NUMBER	{
			if ($2 < conf->sc_conf.interval.tv_sec ||
			    $2 % conf->sc_conf.interval.tv_sec) {
				yyerror("table interval must be "
				    "divisible by global interval");
				YYERROR;
			}
			table->conf.skip_cnt =
			    ($2 / conf->sc_conf.interval.tv_sec) - 1;
		}
		| MODE dstmode hashkey	{
			switch ($2) {
			case RELAY_DSTMODE_LOADBALANCE:
			case RELAY_DSTMODE_HASH:
			case RELAY_DSTMODE_SRCHASH:
				if (hashkey != NULL) {
					yyerror("key already specified");
					free(hashkey);
					YYERROR;
				}
				if ((hashkey = calloc(1,
				    sizeof(*hashkey))) == NULL)
					fatal("out of memory");
				memcpy(hashkey, &$3.key, sizeof(*hashkey));
				break;
			default:
				if ($3.keyset) {
					yyerror("key not supported by mode");
					YYERROR;
				}
				hashkey = NULL;
				break;
			}

			switch ($2) {
			case RELAY_DSTMODE_LOADBALANCE:
			case RELAY_DSTMODE_HASH:
				if (rdr != NULL) {
					yyerror("mode not supported "
					    "for redirections");
					YYERROR;
				}
				/* FALLTHROUGH */
			case RELAY_DSTMODE_RANDOM:
			case RELAY_DSTMODE_ROUNDROBIN:
			case RELAY_DSTMODE_SRCHASH:
				dstmode = $2;
				break;
			case RELAY_DSTMODE_LEASTSTATES:
				if (rdr == NULL) {
					yyerror("mode not supported "
					    "for relays");
					YYERROR;
				}
				dstmode = $2;
				break;
			}
		}
		;

/* should be in sync with sbin/pfctl/parse.y's hashkey */
hashkey		: /* empty */		{
			$$.keyset = 0;
			$$.key.data[0] = arc4random();
			$$.key.data[1] = arc4random();
			$$.key.data[2] = arc4random();
			$$.key.data[3] = arc4random();
		}
		| STRING		{
			/* manual key configuration */
			$$.keyset = 1;

			if (!strncmp($1, "0x", 2)) {
				if (strlen($1) != 34) {
					free($1);
					yyerror("hex key must be 128 bits "
					    "(32 hex digits) long");
					YYERROR;
				}

				if (sscanf($1, "0x%8x%8x%8x%8x",
				    &$$.key.data[0], &$$.key.data[1],
				    &$$.key.data[2], &$$.key.data[3]) != 4) {
					free($1);
					yyerror("invalid hex key");
					YYERROR;
				}
			} else {
				MD5_CTX	context;

				MD5Init(&context);
				MD5Update(&context, (unsigned char *)$1,
				    strlen($1));
				MD5Final((unsigned char *)$$.key.data,
				    &context);
				HTONL($$.key.data[0]);
				HTONL($$.key.data[1]);
				HTONL($$.key.data[2]);
				HTONL($$.key.data[3]);
			}
			free($1);
		}
		;

tablecheck	: ICMP			{ table->conf.check = CHECK_ICMP; }
		| TCP			{ table->conf.check = CHECK_TCP; }
		| ssltls		{
			table->conf.check = CHECK_TCP;
			conf->sc_conf.flags |= F_TLS;
			table->conf.flags |= F_TLS;
		}
		| http_type STRING hostname CODE NUMBER {
			if ($1) {
				conf->sc_conf.flags |= F_TLS;
				table->conf.flags |= F_TLS;
			}
			table->conf.check = CHECK_HTTP_CODE;
			if ((table->conf.retcode = $5) <= 0) {
				yyerror("invalid HTTP code: %d", $5);
				free($2);
				free($3);
				YYERROR;
			}
			if (asprintf(&table->sendbuf,
			    "HEAD %s HTTP/1.%c\r\n%s\r\n",
			    $2, strlen($3) ? '1' : '0', $3) == -1)
				fatal("asprintf");
			free($2);
			free($3);
			if (table->sendbuf == NULL)
				fatal("out of memory");
		}
		| http_type STRING hostname digest {
			if ($1) {
				conf->sc_conf.flags |= F_TLS;
				table->conf.flags |= F_TLS;
			}
			table->conf.check = CHECK_HTTP_DIGEST;
			if (asprintf(&table->sendbuf,
			    "GET %s HTTP/1.%c\r\n%s\r\n",
			    $2, strlen($3) ? '1' : '0', $3) == -1)
				fatal("asprintf");
			free($2);
			free($3);
			if (table->sendbuf == NULL)
				fatal("out of memory");
			if (strlcpy(table->conf.digest, $4.digest,
			    sizeof(table->conf.digest)) >=
			    sizeof(table->conf.digest)) {
				yyerror("digest truncated");
				free($4.digest);
				YYERROR;
			}
			table->conf.digest_type = $4.type;
			free($4.digest);
		}
		| SEND sendbuf EXPECT STRING opttls {
			table->conf.check = CHECK_SEND_EXPECT;
			if ($5) {
				conf->sc_conf.flags |= F_TLS;
				table->conf.flags |= F_TLS;
			}
			if (strlcpy(table->conf.exbuf, $4,
			    sizeof(table->conf.exbuf))
			    >= sizeof(table->conf.exbuf)) {
				yyerror("yyparse: expect buffer truncated");
				free($4);
				YYERROR;
			}
			translate_string(table->conf.exbuf);
			free($4);
		}
		| SCRIPT STRING {
			table->conf.check = CHECK_SCRIPT;
			if (strlcpy(table->conf.path, $2,
			    sizeof(table->conf.path)) >=
			    sizeof(table->conf.path)) {
				yyerror("script path truncated");
				free($2);
				YYERROR;
			}
			conf->sc_conf.flags |= F_SCRIPT;
			free($2);
		}
		;

digest		: DIGEST STRING
		{
			switch (strlen($2)) {
			case 40:
				$$.type = DIGEST_SHA1;
				break;
			case 32:
				$$.type = DIGEST_MD5;
				break;
			default:
				yyerror("invalid http digest");
				free($2);
				YYERROR;
			}
			$$.digest = $2;
		}
		;

optdigest	: digest			{
			$$.digest = $1.digest;
			$$.type = $1.type;
		}
		| STRING			{
			$$.digest = $1;
			$$.type = DIGEST_NONE;
		}
		;

proto		: relay_proto PROTO STRING	{
			struct protocol *p;

			if (!loadcfg) {
				free($3);
				YYACCEPT;
			}

			if (strcmp($3, "default") == 0) {
				p = &conf->sc_proto_default;
			} else {
				TAILQ_FOREACH(p, conf->sc_protos, entry)
					if (!strcmp(p->name, $3))
						break;
			}
			if (p != NULL) {
				yyerror("protocol %s defined twice", $3);
				free($3);
				YYERROR;
			}
			if ((p = calloc(1, sizeof (*p))) == NULL)
				fatal("out of memory");

			if (strlcpy(p->name, $3, sizeof(p->name)) >=
			    sizeof(p->name)) {
				yyerror("protocol name truncated");
				free($3);
				free(p);
				YYERROR;
			}
			free($3);
			p->id = ++last_proto_id;
			p->type = $1;
			p->tcpflags = TCPFLAG_DEFAULT;
			p->tlsflags = TLSFLAG_DEFAULT;
			p->tcpbacklog = RELAY_BACKLOG;
			TAILQ_INIT(&p->rules);
			(void)strlcpy(p->tlsciphers, TLSCIPHERS_DEFAULT,
			    sizeof(p->tlsciphers));
			p->tlsdhparams = TLSDHPARAMS_DEFAULT;
			p->tlsecdhcurve = TLSECDHCURVE_DEFAULT;
			if (last_proto_id == INT_MAX) {
				yyerror("too many protocols defined");
				free(p);
				YYERROR;
			}
			proto = p;
		} protopts_n			{
			conf->sc_protocount++;

			if ((proto->tlsflags & TLSFLAG_VERSION) == 0) {
				yyerror("invalid TLS protocol");
				YYERROR;
			}

			TAILQ_INSERT_TAIL(conf->sc_protos, proto, entry);
		}
		;

protopts_n	: /* empty */
		| '{' '}'
		| '{' optnl protopts_l '}'
		;

protopts_l	: protopts_l protoptsl nl
		| protoptsl optnl
		;

protoptsl	: ssltls tlsflags
		| ssltls '{' tlsflags_l '}'
		| TCP tcpflags
		| TCP '{' tcpflags_l '}'
		| RETURN ERROR opteflags	{ proto->flags |= F_RETURN; }
		| RETURN ERROR '{' eflags_l '}'	{ proto->flags |= F_RETURN; }
		| filterrule
		| include
		;

tcpflags_l	: tcpflags comma tcpflags_l
		| tcpflags
		;

tcpflags	: SACK			{ proto->tcpflags |= TCPFLAG_SACK; }
		| NO SACK		{ proto->tcpflags |= TCPFLAG_NSACK; }
		| NODELAY		{ proto->tcpflags |= TCPFLAG_NODELAY; }
		| NO NODELAY		{ proto->tcpflags |= TCPFLAG_NNODELAY; }
		| SPLICE		{ /* default */ }
		| NO SPLICE		{ proto->tcpflags |= TCPFLAG_NSPLICE; }
		| BACKLOG NUMBER	{
			if ($2 < 0 || $2 > RELAY_MAX_SESSIONS) {
				yyerror("invalid backlog: %d", $2);
				YYERROR;
			}
			proto->tcpbacklog = $2;
		}
		| SOCKET BUFFER NUMBER	{
			proto->tcpflags |= TCPFLAG_BUFSIZ;
			if ((proto->tcpbufsiz = $3) < 0) {
				yyerror("invalid socket buffer size: %d", $3);
				YYERROR;
			}
		}
		| IP STRING NUMBER	{
			if ($3 < 0) {
				yyerror("invalid ttl: %d", $3);
				free($2);
				YYERROR;
			}
			if (strcasecmp("ttl", $2) == 0) {
				proto->tcpflags |= TCPFLAG_IPTTL;
				proto->tcpipttl = $3;
			} else if (strcasecmp("minttl", $2) == 0) {
				proto->tcpflags |= TCPFLAG_IPMINTTL;
				proto->tcpipminttl = $3;
			} else {
				yyerror("invalid TCP/IP flag: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

tlsflags_l	: tlsflags comma tlsflags_l
		| tlsflags
		;

tlsflags	: SESSION TICKETS { proto->tickets = 0; }
		| NO SESSION TICKETS { proto->tickets = -1; }
		| CIPHERS STRING		{
			if (strlcpy(proto->tlsciphers, $2,
			    sizeof(proto->tlsciphers)) >=
			    sizeof(proto->tlsciphers)) {
				yyerror("tlsciphers truncated");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| NO EDH			{
			proto->tlsdhparams = TLSDHPARAMS_NONE;
		}
		| EDH tlsdhparams		{
			proto->tlsdhparams = $2;
		}
		| NO ECDH			{
			proto->tlsecdhcurve = 0;
		}
		| ECDH tlsecdhcurve		{
			proto->tlsecdhcurve = $2;
		}
		| CA FILENAME STRING		{
			if (strlcpy(proto->tlsca, $3,
			    sizeof(proto->tlsca)) >=
			    sizeof(proto->tlsca)) {
				yyerror("tlsca truncated");
				free($3);
				YYERROR;
			}
			free($3);
		}
		| CA KEY STRING PASSWORD STRING	{
			if (strlcpy(proto->tlscakey, $3,
			    sizeof(proto->tlscakey)) >=
			    sizeof(proto->tlscakey)) {
				yyerror("tlscakey truncated");
				free($3);
				free($5);
				YYERROR;
			}
			if ((proto->tlscapass = strdup($5)) == NULL) {
				yyerror("tlscapass");
				free($3);
				free($5);
				YYERROR;
			}
			free($3);
			free($5);
		}
		| CA CERTIFICATE STRING		{
			if (strlcpy(proto->tlscacert, $3,
			    sizeof(proto->tlscacert)) >=
			    sizeof(proto->tlscacert)) {
				yyerror("tlscacert truncated");
				free($3);
				YYERROR;
			}
			free($3);
		}
		| NO flag			{ proto->tlsflags &= ~($2); }
		| flag				{ proto->tlsflags |= $1; }
		;

flag		: STRING			{
			if (strcmp("sslv3", $1) == 0)
				$$ = TLSFLAG_SSLV3;
			else if (strcmp("tlsv1", $1) == 0)
				$$ = TLSFLAG_TLSV1;
			else if (strcmp("tlsv1.0", $1) == 0)
				$$ = TLSFLAG_TLSV1_0;
			else if (strcmp("tlsv1.1", $1) == 0)
				$$ = TLSFLAG_TLSV1_1;
			else if (strcmp("tlsv1.2", $1) == 0)
				$$ = TLSFLAG_TLSV1_2;
			else if (strcmp("cipher-server-preference", $1) == 0)
				$$ = TLSFLAG_CIPHER_SERVER_PREF;
			else if (strcmp("client-renegotiation", $1) == 0)
				$$ = TLSFLAG_CLIENT_RENEG;
			else {
				yyerror("invalid TLS flag: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

filterrule	: action dir quick ruleaf rulesrc ruledst {
			if ((rule = calloc(1, sizeof(*rule))) == NULL)
				fatal("out of memory");

			rule->rule_action = $1;
			rule->rule_proto = proto->type;
			rule->rule_dir = $2;
			rule->rule_flags |= $3;
			rule->rule_af = $4;

			rulefile = NULL;
		} ruleopts_l {
			if (rule_add(proto, rule, rulefile) == -1) {
				if (rulefile == NULL) {
					yyerror("failed to load rule");
				} else {
					yyerror("failed to load rules from %s",
					    rulefile);
					free(rulefile);
				}
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			if (rulefile)
				free(rulefile);
			rulefile = NULL;
			rule = NULL;
			keytype = KEY_TYPE_NONE;
		}
		;

action		: PASS				{ $$ = RULE_ACTION_PASS; }
		| BLOCK				{ $$ = RULE_ACTION_BLOCK; }
		| MATCH				{ $$ = RULE_ACTION_MATCH; }
		;

dir		: /* empty */			{
			$$ = dir = RELAY_DIR_REQUEST;
		}
		| REQUEST			{
			$$ = dir = RELAY_DIR_REQUEST;
		}
		| RESPONSE			{
			$$ = dir = RELAY_DIR_RESPONSE;
		}
		;

quick		: /* empty */			{ $$ = 0; }
		| QUICK				{ $$ = RULE_FLAG_QUICK; }
		;

ruleaf		: /* empty */			{ $$ = AF_UNSPEC; }
		| INET6				{ $$ = AF_INET6; }
		| INET				{ $$ = AF_INET; }
		;

rulesrc		: /* XXX */
		;

ruledst		: /* XXX */
		;

ruleopts_l	: /* empty */
		| ruleopts_t
		;

ruleopts_t	: ruleopts ruleopts_t
		| ruleopts
		;

ruleopts	: METHOD STRING					{
			u_int	id;
			if ((id = relay_httpmethod_byname($2)) ==
			    HTTP_METHOD_NONE) {
				yyerror("unknown HTTP method currently not "
				    "supported");
				free($2);
				YYERROR;
			}
			rule->rule_method = id;
			free($2);
		}
		| COOKIE key_option STRING value		{
			keytype = KEY_TYPE_COOKIE;
			rule->rule_kv[keytype].kv_key = strdup($3);
			rule->rule_kv[keytype].kv_option = $2;
			rule->rule_kv[keytype].kv_value = (($4 != NULL) ?
			    strdup($4) : strdup("*"));
			if (rule->rule_kv[keytype].kv_key == NULL ||
			    rule->rule_kv[keytype].kv_value == NULL)
				fatal("out of memory");
			free($3);
			if ($4)
				free($4);
			rule->rule_kv[keytype].kv_type = keytype;
		}
		| COOKIE key_option				{
			keytype = KEY_TYPE_COOKIE;
			rule->rule_kv[keytype].kv_option = $2;
			rule->rule_kv[keytype].kv_type = keytype;
		}
		| HEADER key_option STRING value		{
			keytype = KEY_TYPE_HEADER;
			memset(&rule->rule_kv[keytype], 0,
			    sizeof(rule->rule_kv[keytype]));
			rule->rule_kv[keytype].kv_option = $2;
			rule->rule_kv[keytype].kv_key = strdup($3);
			rule->rule_kv[keytype].kv_value = (($4 != NULL) ?
			    strdup($4) : strdup("*"));
			if (rule->rule_kv[keytype].kv_key == NULL ||
			    rule->rule_kv[keytype].kv_value == NULL)
				fatal("out of memory");
			free($3);
			if ($4)
				free($4);
			rule->rule_kv[keytype].kv_type = keytype;
		}
		| HEADER key_option				{
			keytype = KEY_TYPE_HEADER;
			rule->rule_kv[keytype].kv_option = $2;
			rule->rule_kv[keytype].kv_type = keytype;
		}
		| PATH key_option STRING value			{
			keytype = KEY_TYPE_PATH;
			rule->rule_kv[keytype].kv_option = $2;
			rule->rule_kv[keytype].kv_key = strdup($3);
			rule->rule_kv[keytype].kv_value = (($4 != NULL) ?
			    strdup($4) : strdup("*"));
			if (rule->rule_kv[keytype].kv_key == NULL ||
			    rule->rule_kv[keytype].kv_value == NULL)
				fatal("out of memory");
			free($3);
			if ($4)
				free($4);
			rule->rule_kv[keytype].kv_type = keytype;
		}
		| PATH key_option				{
			keytype = KEY_TYPE_PATH;
			rule->rule_kv[keytype].kv_option = $2;
			rule->rule_kv[keytype].kv_type = keytype;
		}
		| QUERYSTR key_option STRING value		{
			switch ($2) {
			case KEY_OPTION_APPEND:
			case KEY_OPTION_SET:
			case KEY_OPTION_REMOVE:
				yyerror("combining query type and the given "
				    "option is not supported");
				free($3);
				if ($4)
					free($4);
				YYERROR;
				break;
			}
			keytype = KEY_TYPE_QUERY;
			rule->rule_kv[keytype].kv_option = $2;
			rule->rule_kv[keytype].kv_key = strdup($3);
			rule->rule_kv[keytype].kv_value = (($4 != NULL) ?
			    strdup($4) : strdup("*"));
			if (rule->rule_kv[keytype].kv_key == NULL ||
			    rule->rule_kv[keytype].kv_value == NULL)
				fatal("out of memory");
			free($3);
			if ($4)
				free($4);
			rule->rule_kv[keytype].kv_type = keytype;
		}
		| QUERYSTR key_option				{
			switch ($2) {
			case KEY_OPTION_APPEND:
			case KEY_OPTION_SET:
			case KEY_OPTION_REMOVE:
				yyerror("combining query type and the given "
				    "option is not supported");
				YYERROR;
				break;
			}
			keytype = KEY_TYPE_QUERY;
			rule->rule_kv[keytype].kv_option = $2;
			rule->rule_kv[keytype].kv_type = keytype;
		}
		| URL key_option optdigest value			{
			switch ($2) {
			case KEY_OPTION_APPEND:
			case KEY_OPTION_SET:
			case KEY_OPTION_REMOVE:
				yyerror("combining url type and the given "
				"option is not supported");
				free($3.digest);
				free($4);
				YYERROR;
				break;
			}
			keytype = KEY_TYPE_URL;
			rule->rule_kv[keytype].kv_option = $2;
			rule->rule_kv[keytype].kv_key = strdup($3.digest);
			rule->rule_kv[keytype].kv_digest = $3.type;
			rule->rule_kv[keytype].kv_value = (($4 != NULL) ?
			    strdup($4) : strdup("*"));
			if (rule->rule_kv[keytype].kv_key == NULL ||
			    rule->rule_kv[keytype].kv_value == NULL)
				fatal("out of memory");
			free($3.digest);
			if ($4)
				free($4);
			rule->rule_kv[keytype].kv_type = keytype;
		}
		| URL key_option					{
			switch ($2) {
			case KEY_OPTION_APPEND:
			case KEY_OPTION_SET:
			case KEY_OPTION_REMOVE:
				yyerror("combining url type and the given "
				    "option is not supported");
				YYERROR;
				break;
			}
			keytype = KEY_TYPE_URL;
			rule->rule_kv[keytype].kv_option = $2;
			rule->rule_kv[keytype].kv_type = keytype;
		}
		| FORWARD TO table				{
			if (table_findbyname(conf, $3) == NULL) {
				yyerror("undefined forward table");
				free($3);
				YYERROR;
			}
			if (strlcpy(rule->rule_tablename, $3,
			    sizeof(rule->rule_tablename)) >=
			    sizeof(rule->rule_tablename)) {
				yyerror("invalid forward table name");
				free($3);
				YYERROR;
			}
			free($3);
		}
		| TAG STRING					{
			tag = tag_name2id($2);
			if (rule->rule_tag) {
				yyerror("tag already defined");
				free($2);
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			if (tag == 0) {
				yyerror("invalid tag");
				free($2);
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			rule->rule_tag = tag;
			if (strlcpy(rule->rule_tagname, $2,
			    sizeof(rule->rule_tagname)) >=
			    sizeof(rule->rule_tagname)) {
				yyerror("tag truncated");
				free($2);
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			free($2);
		}
		| NO TAG					{
			if (tag == 0) {
				yyerror("no tag defined");
				YYERROR;
			}
			rule->rule_tag = -1;
			memset(rule->rule_tagname, 0,
			    sizeof(rule->rule_tagname));
		}
		| TAGGED STRING					{
			tagged = tag_name2id($2);
			if (rule->rule_tagged) {
				yyerror("tagged already defined");
				free($2);
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			if (tagged == 0) {
				yyerror("invalid tag");
				free($2);
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			rule->rule_tagged = tagged;
			if (strlcpy(rule->rule_taggedname, $2,
			    sizeof(rule->rule_taggedname)) >=
			    sizeof(rule->rule_taggedname)) {
				yyerror("tagged truncated");
				free($2);
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			free($2);
		}
		| LABEL STRING					{
			label = label_name2id($2);
			if (rule->rule_label) {
				yyerror("label already defined");
				free($2);
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			if (label == 0) {
				yyerror("invalid label");
				free($2);
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			rule->rule_label = label;
			if (strlcpy(rule->rule_labelname, $2,
			    sizeof(rule->rule_labelname)) >=
			    sizeof(rule->rule_labelname)) {
				yyerror("label truncated");
				free($2);
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			free($2);
		}
		| NO LABEL					{
			if (label == 0) {
				yyerror("no label defined");
				YYERROR;
			}
			rule->rule_label = -1;
			memset(rule->rule_labelname, 0,
			    sizeof(rule->rule_labelname));
		}
		| FILENAME STRING value				{
			if (rulefile != NULL) {
				yyerror("only one file per rule supported");
				free($2);
				free($3);
				rule_free(rule);
				free(rule);
				YYERROR;
			}
			if ($3) {
				if ((rule->rule_kv[keytype].kv_value =
				    strdup($3)) == NULL)
					fatal("out of memory");
				free($3);
			} else
				rule->rule_kv[keytype].kv_value = NULL;
			rulefile = $2;
		}
		;

value		: /* empty */		{ $$ = NULL; }
		| VALUE STRING		{ $$ = $2; }
		;

key_option	: /* empty */		{ $$ = KEY_OPTION_NONE; }
		| APPEND		{ $$ = KEY_OPTION_APPEND; }
		| SET			{ $$ = KEY_OPTION_SET; }
		| REMOVE		{ $$ = KEY_OPTION_REMOVE; }
		| HASH			{ $$ = KEY_OPTION_HASH; }
		| LOG			{ $$ = KEY_OPTION_LOG; }
		;

tlsdhparams	: /* empty */		{ $$ = TLSDHPARAMS_MIN; }
		| PARAMS NUMBER		{
			if ($2 < TLSDHPARAMS_MIN) {
				yyerror("EDH params not supported: %d", $2);
				YYERROR;
			}
			$$ = $2;
		}
		;

tlsecdhcurve	: /* empty */		{ $$ = TLSECDHCURVE_DEFAULT; }
		| CURVE STRING		{
			if (strcmp("none", $2) == 0)
				$$ = 0;
			else if ((proto->tlsecdhcurve = OBJ_sn2nid($2)) == 0) {
				yyerror("ECDH curve not supported");
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

relay		: RELAY STRING	{
			struct relay *r;

			if (!loadcfg) {
				free($2);
				YYACCEPT;
			}

			TAILQ_FOREACH(r, conf->sc_relays, rl_entry)
				if (!strcmp(r->rl_conf.name, $2))
					break;
			if (r != NULL) {
				yyerror("relay %s defined twice", $2);
				free($2);
				YYERROR;
			}
			TAILQ_INIT(&relays);

			if ((r = calloc(1, sizeof (*r))) == NULL)
				fatal("out of memory");

			if (strlcpy(r->rl_conf.name, $2,
			    sizeof(r->rl_conf.name)) >=
			    sizeof(r->rl_conf.name)) {
				yyerror("relay name truncated");
				free($2);
				free(r);
				YYERROR;
			}
			free($2);
			if (relay_id(r) == -1) {
				yyerror("too many relays defined");
				free(r);
				YYERROR;
			}
			r->rl_conf.timeout.tv_sec = RELAY_TIMEOUT;
			r->rl_proto = NULL;
			r->rl_conf.proto = EMPTY_ID;
			r->rl_conf.dstretry = 0;
			TAILQ_INIT(&r->rl_tables);
			if (last_relay_id == INT_MAX) {
				yyerror("too many relays defined");
				free(r);
				YYERROR;
			}
			dstmode = RELAY_DSTMODE_DEFAULT;
			rlay = r;
		} '{' optnl relayopts_l '}'	{
			struct relay	*r;

			if (rlay->rl_conf.ss.ss_family == AF_UNSPEC) {
				yyerror("relay %s has no listener",
				    rlay->rl_conf.name);
				YYERROR;
			}
			if ((rlay->rl_conf.flags & (F_NATLOOK|F_DIVERT)) ==
			    (F_NATLOOK|F_DIVERT)) {
				yyerror("relay %s with conflicting nat lookup "
				    "and peer options", rlay->rl_conf.name);
				YYERROR;
			}
			if ((rlay->rl_conf.flags & (F_NATLOOK|F_DIVERT)) == 0 &&
			    rlay->rl_conf.dstss.ss_family == AF_UNSPEC &&
			    TAILQ_EMPTY(&rlay->rl_tables)) {
				yyerror("relay %s has no target, rdr, "
				    "or table", rlay->rl_conf.name);
				YYERROR;
			}
			if (rlay->rl_conf.proto == EMPTY_ID) {
				rlay->rl_proto = &conf->sc_proto_default;
				rlay->rl_conf.proto = conf->sc_proto_default.id;
			}
			if (relay_load_certfiles(rlay) == -1) {
				yyerror("cannot load certificates for relay %s",
				    rlay->rl_conf.name);
				YYERROR;
			}
			conf->sc_relaycount++;
			SPLAY_INIT(&rlay->rl_sessions);
			TAILQ_INSERT_TAIL(conf->sc_relays, rlay, rl_entry);

			tableport = 0;

			while ((r = TAILQ_FIRST(&relays)) != NULL) {
				TAILQ_REMOVE(&relays, r, rl_entry);
				if (relay_inherit(rlay, r) == NULL) {
					YYERROR;
				}
			}
			rlay = NULL;
		}
		;

relayopts_l	: relayopts_l relayoptsl nl
		| relayoptsl optnl
		;

relayoptsl	: LISTEN ON STRING port opttls {
			struct addresslist	 al;
			struct address		*h;
			struct relay		*r;

			if (rlay->rl_conf.ss.ss_family != AF_UNSPEC) {
				if ((r = calloc(1, sizeof (*r))) == NULL)
					fatal("out of memory");
				TAILQ_INSERT_TAIL(&relays, r, rl_entry);
			} else
				r = rlay;
			if ($4.op != PF_OP_EQ) {
				yyerror("invalid port");
				free($3);
				YYERROR;
			}

			TAILQ_INIT(&al);
			if (host($3, &al, 1, &$4, NULL, -1) <= 0) {
				yyerror("invalid listen ip: %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
			h = TAILQ_FIRST(&al);
			bcopy(&h->ss, &r->rl_conf.ss, sizeof(r->rl_conf.ss));
			r->rl_conf.port = h->port.val[0];
			if ($5) {
				r->rl_conf.flags |= F_TLS;
				conf->sc_conf.flags |= F_TLS;
			}
			tableport = h->port.val[0];
			host_free(&al);
		}
		| forwardmode opttlsclient TO forwardspec dstaf {
			rlay->rl_conf.fwdmode = $1;
			if ($1 == FWD_ROUTE) {
				yyerror("no route for relays");
				YYERROR;
			}
			if ($2) {
				rlay->rl_conf.flags |= F_TLSCLIENT;
				conf->sc_conf.flags |= F_TLSCLIENT;
			}
		}
		| SESSION TIMEOUT NUMBER		{
			if ((rlay->rl_conf.timeout.tv_sec = $3) < 0) {
				yyerror("invalid timeout: %lld", $3);
				YYERROR;
			}
			if (rlay->rl_conf.timeout.tv_sec > INT_MAX) {
				yyerror("timeout too large: %lld", $3);
				YYERROR;
			}
		}
		| PROTO STRING			{
			struct protocol *p;

			TAILQ_FOREACH(p, conf->sc_protos, entry)
				if (!strcmp(p->name, $2))
					break;
			if (p == NULL) {
				yyerror("no such protocol: %s", $2);
				free($2);
				YYERROR;
			}
			p->flags |= F_USED;
			rlay->rl_conf.proto = p->id;
			rlay->rl_proto = p;
			free($2);
		}
		| DISABLE		{ rlay->rl_conf.flags |= F_DISABLE; }
		| include
		;

forwardspec	: STRING port retry	{
			struct addresslist	 al;
			struct address		*h;

			if (rlay->rl_conf.dstss.ss_family != AF_UNSPEC) {
				yyerror("relay %s target or redirection "
				    "already specified", rlay->rl_conf.name);
				free($1);
				YYERROR;
			}
			if ($2.op != PF_OP_EQ) {
				yyerror("invalid port");
				free($1);
				YYERROR;
			}

			TAILQ_INIT(&al);
			if (host($1, &al, 1, &$2, NULL, -1) <= 0) {
				yyerror("invalid listen ip: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			h = TAILQ_FIRST(&al);
			bcopy(&h->ss, &rlay->rl_conf.dstss,
			    sizeof(rlay->rl_conf.dstss));
			rlay->rl_conf.dstport = h->port.val[0];
			rlay->rl_conf.dstretry = $3;
			host_free(&al);
		}
		| NAT LOOKUP retry	{
			conf->sc_conf.flags |= F_NEEDPF;
			rlay->rl_conf.flags |= F_NATLOOK;
			rlay->rl_conf.dstretry = $3;
		}
		| DESTINATION retry		{
			conf->sc_conf.flags |= F_NEEDPF;
			rlay->rl_conf.flags |= F_DIVERT;
			rlay->rl_conf.dstretry = $2;
		}
		| tablespec	{
			struct relay_table	*rlt;

			if ((rlt = calloc(1, sizeof(*rlt))) == NULL) {
				yyerror("failed to allocate table reference");
				YYERROR;
			}

			rlt->rlt_table = $1;
			rlt->rlt_table->conf.flags |= F_USED;
			rlt->rlt_mode = dstmode;
			rlt->rlt_flags = F_USED;
			if (!TAILQ_EMPTY(&rlay->rl_tables))
				rlt->rlt_flags |= F_BACKUP;

			if (hashkey != NULL &&
			    (rlay->rl_conf.flags & F_HASHKEY) == 0) {
				memcpy(&rlay->rl_conf.hashkey,
				    hashkey, sizeof(rlay->rl_conf.hashkey));
				rlay->rl_conf.flags |= F_HASHKEY;
			}
			free(hashkey);
			hashkey = NULL;

			TAILQ_INSERT_TAIL(&rlay->rl_tables, rlt, rlt_entry);
		}
		;

dstmode		: /* empty */		{ $$ = RELAY_DSTMODE_DEFAULT; }
		| LOADBALANCE		{ $$ = RELAY_DSTMODE_LOADBALANCE; }
		| ROUNDROBIN		{ $$ = RELAY_DSTMODE_ROUNDROBIN; }
		| HASH			{ $$ = RELAY_DSTMODE_HASH; }
		| LEASTSTATES		{ $$ = RELAY_DSTMODE_LEASTSTATES; }
		| SRCHASH		{ $$ = RELAY_DSTMODE_SRCHASH; }
		| RANDOM		{ $$ = RELAY_DSTMODE_RANDOM; }
		;

router		: ROUTER STRING		{
			struct router *rt = NULL;

			if (!loadcfg) {
				free($2);
				YYACCEPT;
			}

			conf->sc_conf.flags |= F_NEEDRT;
			TAILQ_FOREACH(rt, conf->sc_rts, rt_entry)
				if (!strcmp(rt->rt_conf.name, $2))
					break;
			if (rt != NULL) {
				yyerror("router %s defined twice", $2);
				free($2);
				YYERROR;
			}

			if ((rt = calloc(1, sizeof (*rt))) == NULL)
				fatal("out of memory");

			if (strlcpy(rt->rt_conf.name, $2,
			    sizeof(rt->rt_conf.name)) >=
			    sizeof(rt->rt_conf.name)) {
				yyerror("router name truncated");
				free(rt);
				YYERROR;
			}
			free($2);
			rt->rt_conf.id = ++last_rt_id;
			if (last_rt_id == INT_MAX) {
				yyerror("too many routers defined");
				free(rt);
				YYERROR;
			}
			TAILQ_INIT(&rt->rt_netroutes);
			router = rt;

			tableport = -1;
		} '{' optnl routeopts_l '}'	{
			if (!router->rt_conf.nroutes) {
				yyerror("router %s without routes",
				    router->rt_conf.name);
				free(router);
				router = NULL;
				YYERROR;
			}

			conf->sc_routercount++;
			TAILQ_INSERT_TAIL(conf->sc_rts, router, rt_entry);
			router = NULL;

			tableport = 0;
		}
		;

routeopts_l	: routeopts_l routeoptsl nl
		| routeoptsl optnl
		;

routeoptsl	: ROUTE address '/' NUMBER {
			struct netroute	*nr;

			if (router->rt_conf.af == AF_UNSPEC)
				router->rt_conf.af = $2.ss.ss_family;
			else if (router->rt_conf.af != $2.ss.ss_family) {
				yyerror("router %s address family mismatch",
				    router->rt_conf.name);
				YYERROR;
			}

			if ((router->rt_conf.af == AF_INET &&
			    ($4 > 32 || $4 < 0)) ||
			    (router->rt_conf.af == AF_INET6 &&
			    ($4 > 128 || $4 < 0))) {
				yyerror("invalid prefixlen %d", $4);
				YYERROR;
			}

			if ((nr = calloc(1, sizeof(*nr))) == NULL)
				fatal("out of memory");

			nr->nr_conf.id = ++last_nr_id;
			if (last_nr_id == INT_MAX) {
				yyerror("too many routes defined");
				free(nr);
				YYERROR;
			}
			nr->nr_conf.prefixlen = $4;
			nr->nr_conf.routerid = router->rt_conf.id;
			nr->nr_router = router;
			bcopy(&$2.ss, &nr->nr_conf.ss, sizeof($2.ss));

			router->rt_conf.nroutes++;
			conf->sc_routecount++;
			TAILQ_INSERT_TAIL(&router->rt_netroutes, nr, nr_entry);
			TAILQ_INSERT_TAIL(conf->sc_routes, nr, nr_route);
		}
		| FORWARD TO tablespec {
			free(hashkey);
			hashkey = NULL;

			if (router->rt_gwtable) {
				yyerror("router %s table already specified",
				    router->rt_conf.name);
				purge_table(conf, conf->sc_tables, $3);
				YYERROR;
			}
			router->rt_gwtable = $3;
			router->rt_gwtable->conf.flags |= F_USED;
			router->rt_conf.gwtable = $3->conf.id;
			router->rt_conf.gwport = $3->conf.port;
		}
		| RTABLE NUMBER {
			if (router->rt_conf.rtable) {
				yyerror("router %s rtable already specified",
				    router->rt_conf.name);
				YYERROR;
			}
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("invalid rtable id %d", $2);
				YYERROR;
			}
			router->rt_conf.rtable = $2;
		}
		| RTLABEL STRING {
			if (strlcpy(router->rt_conf.label, $2,
			    sizeof(router->rt_conf.label)) >=
			    sizeof(router->rt_conf.label)) {
				yyerror("route label truncated");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| DISABLE		{ rlay->rl_conf.flags |= F_DISABLE; }
		| include
		;

dstaf		: /* empty */		{
			rlay->rl_conf.dstaf.ss_family = AF_UNSPEC;
		}
		| INET			{
			rlay->rl_conf.dstaf.ss_family = AF_INET;
		}
		| INET6	STRING		{
			struct sockaddr_in6	*sin6;

			sin6 = (struct sockaddr_in6 *)&rlay->rl_conf.dstaf;
			if (inet_pton(AF_INET6, $2, &sin6->sin6_addr) == -1) {
				yyerror("invalid ipv6 address %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			sin6->sin6_family = AF_INET6;
			sin6->sin6_len = sizeof(*sin6);
		}
		;

interface	: /* empty */		{ $$ = NULL; }
		| INTERFACE STRING	{ $$ = $2; }
		;

host		: address	{
			if ((hst = calloc(1, sizeof(*(hst)))) == NULL)
				fatal("out of memory");

			if (strlcpy(hst->conf.name, $1.name,
			    sizeof(hst->conf.name)) >= sizeof(hst->conf.name)) {
				yyerror("host name truncated");
				free(hst);
				YYERROR;
			}
			bcopy(&$1.ss, &hst->conf.ss, sizeof($1.ss));
			hst->conf.id = 0; /* will be set later */
			SLIST_INIT(&hst->children);
		} opthostflags {
			$$ = hst;
			hst = NULL;
		}
		;

opthostflags	: /* empty */
		| hostflags_l
		;

hostflags_l	: hostflags hostflags_l
		| hostflags
		;

hostflags	: RETRY NUMBER		{
			if (hst->conf.retry) {
				yyerror("retry value already set");
				YYERROR;
			}
			if ($2 < 0) {
				yyerror("invalid retry value: %d\n", $2);
				YYERROR;
			}
			hst->conf.retry = $2;
		}
		| PARENT NUMBER		{
			if (hst->conf.parentid) {
				yyerror("parent value already set");
				YYERROR;
			}
			if ($2 < 0) {
				yyerror("invalid parent value: %d\n", $2);
				YYERROR;
			}
			hst->conf.parentid = $2;
		}
		| PRIORITY NUMBER		{
			if (hst->conf.priority) {
				yyerror("priority already set");
				YYERROR;
			}
			if ($2 < 0 || $2 > RTP_MAX) {
				yyerror("invalid priority value: %d\n", $2);
				YYERROR;
			}
			hst->conf.priority = $2;
		}
		| IP TTL NUMBER		{
			if (hst->conf.ttl) {
				yyerror("ttl value already set");
				YYERROR;
			}
			if ($3 < 0) {
				yyerror("invalid ttl value: %d\n", $3);
				YYERROR;
			}
			hst->conf.ttl = $3;
		}
		;

address		: STRING	{
			struct address *h;
			struct addresslist al;

			if (strlcpy($$.name, $1,
			    sizeof($$.name)) >= sizeof($$.name)) {
				yyerror("host name truncated");
				free($1);
				YYERROR;
			}

			TAILQ_INIT(&al);
			if (host($1, &al, 1, NULL, NULL, -1) <= 0) {
				yyerror("invalid host %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			h = TAILQ_FIRST(&al);
			memcpy(&$$.ss, &h->ss, sizeof($$.ss));
			host_free(&al);
		}
		;

retry		: /* empty */		{ $$ = 0; }
		| RETRY NUMBER		{
			if (($$ = $2) < 0) {
				yyerror("invalid retry value: %d\n", $2);
				YYERROR;
			}
		}
		;

timeout		: NUMBER
		{
			if ($1 < 0) {
				yyerror("invalid timeout: %d\n", $1);
				YYERROR;
			}
			$$.tv_sec = $1 / 1000;
			$$.tv_usec = ($1 % 1000) * 1000;
		}
		;

comma		: ','
		| nl
		| /* empty */
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl
		;

optstring	: STRING		{ $$ = $1; }
		| /* nothing */		{ $$ = NULL; }
		;
%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "all",		ALL },
		{ "append",		APPEND },
		{ "backlog",		BACKLOG },
		{ "backup",		BACKUP },
		{ "block",		BLOCK },
		{ "buffer",		BUFFER },
		{ "ca",			CA },
		{ "cache",		CACHE },
		{ "cert",		CERTIFICATE },
		{ "check",		CHECK },
		{ "ciphers",		CIPHERS },
		{ "code",		CODE },
		{ "cookie",		COOKIE },
		{ "curve",		CURVE },
		{ "demote",		DEMOTE },
		{ "destination",	DESTINATION },
		{ "digest",		DIGEST },
		{ "disable",		DISABLE },
		{ "ecdh",		ECDH },
		{ "edh",		EDH },
		{ "error",		ERROR },
		{ "expect",		EXPECT },
		{ "external",		EXTERNAL },
		{ "file",		FILENAME },
		{ "forward",		FORWARD },
		{ "from",		FROM },
		{ "hash",		HASH },
		{ "header",		HEADER },
		{ "host",		HOST },
		{ "icmp",		ICMP },
		{ "include",		INCLUDE },
		{ "inet",		INET },
		{ "inet6",		INET6 },
		{ "interface",		INTERFACE },
		{ "interval",		INTERVAL },
		{ "ip",			IP },
		{ "key",		KEY },
		{ "label",		LABEL },
		{ "least-states",	LEASTSTATES },
		{ "listen",		LISTEN },
		{ "loadbalance",	LOADBALANCE },
		{ "log",		LOG },
		{ "lookup",		LOOKUP },
		{ "match",		MATCH },
		{ "method",		METHOD },
		{ "mode",		MODE },
		{ "nat",		NAT },
		{ "no",			NO },
		{ "nodelay",		NODELAY },
		{ "nothing",		NOTHING },
		{ "on",			ON },
		{ "params",		PARAMS },
		{ "parent",		PARENT },
		{ "pass",		PASS },
		{ "password",		PASSWORD },
		{ "path",		PATH },
		{ "pftag",		PFTAG },
		{ "port",		PORT },
		{ "prefork",		PREFORK },
		{ "priority",		PRIORITY },
		{ "protocol",		PROTO },
		{ "query",		QUERYSTR },
		{ "quick",		QUICK },
		{ "random",		RANDOM },
		{ "real",		REAL },
		{ "redirect",		REDIRECT },
		{ "relay",		RELAY },
		{ "remove",		REMOVE },
		{ "request",		REQUEST },
		{ "response",		RESPONSE },
		{ "retry",		RETRY },
		{ "return",		RETURN },
		{ "roundrobin",		ROUNDROBIN },
		{ "route",		ROUTE },
		{ "router",		ROUTER },
		{ "rtable",		RTABLE },
		{ "rtlabel",		RTLABEL },
		{ "sack",		SACK },
		{ "script",		SCRIPT },
		{ "send",		SEND },
		{ "session",		SESSION },
		{ "set",		SET },
		{ "snmp",		SNMP },
		{ "socket",		SOCKET },
		{ "source-hash",	SRCHASH },
		{ "splice",		SPLICE },
		{ "ssl",		SSL },
		{ "sticky-address",	STICKYADDR },
		{ "style",		STYLE },
		{ "table",		TABLE },
		{ "tag",		TAG },
		{ "tagged",		TAGGED },
		{ "tcp",		TCP },
		{ "tickets",		TICKETS },
		{ "timeout",		TIMEOUT },
		{ "tls",		TLS },
		{ "to",			TO },
		{ "transparent",	TRANSPARENT },
		{ "trap",		TRAP },
		{ "ttl",		TTL },
		{ "updates",		UPDATES },
		{ "url",		URL },
		{ "value",		VALUE },
		{ "virtual",		VIRTUAL },
		{ "with",		WITH }
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '#' && \
	x != ',' && x != '/'))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		log_warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("%s: malloc", __func__);
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("%s: malloc", __func__);
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s: %s", __func__, nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

int
parse_config(const char *filename, struct relayd *x_conf)
{
	struct sym	*sym, *next;

	conf = x_conf;
	if (config_init(conf) == -1) {
		log_warn("%s: cannot initialize configuration", __func__);
		return (-1);
	}

	errors = 0;

	if ((file = pushfile(filename, 0)) == NULL)
		return (-1);

	topfile = file;
	setservent(1);

	yyparse();
	errors = file->errors;
	popfile();

	endservent();
	endprotoent();

	/* Free macros */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	return (errors ? -1 : 0);
}

int
load_config(const char *filename, struct relayd *x_conf)
{
	struct sym		*sym, *next;
	struct table		*nexttb;
	struct host		*h, *ph;
	struct relay_table	*rlt;

	conf = x_conf;
	conf->sc_conf.flags = 0;

	loadcfg = 1;
	errors = 0;
	last_host_id = last_table_id = last_rdr_id = last_proto_id =
	    last_relay_id = last_rt_id = last_nr_id = 0;

	rdr = NULL;
	table = NULL;
	rlay = NULL;
	proto = NULL;
	router = NULL;

	if ((file = pushfile(filename, 0)) == NULL)
		return (-1);

	topfile = file;
	setservent(1);

	yyparse();
	errors = file->errors;
	popfile();

	endservent();
	endprotoent();

	/* Free macros and check which have not been used. */
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
		if ((conf->sc_conf.opts & RELAYD_OPT_VERBOSE) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	if (TAILQ_EMPTY(conf->sc_rdrs) &&
	    TAILQ_EMPTY(conf->sc_relays) &&
	    TAILQ_EMPTY(conf->sc_rts)) {
		log_warnx("no actions, nothing to do");
		errors++;
	}

	/* Cleanup relay list to inherit */
	while ((rlay = TAILQ_FIRST(&relays)) != NULL) {
		TAILQ_REMOVE(&relays, rlay, rl_entry);
		while ((rlt = TAILQ_FIRST(&rlay->rl_tables))) {
			TAILQ_REMOVE(&rlay->rl_tables, rlt, rlt_entry);
			free(rlt);
		}
		free(rlay);
	}

	if (timercmp(&conf->sc_conf.timeout, &conf->sc_conf.interval, >=)) {
		log_warnx("global timeout exceeds interval");
		errors++;
	}

	/* Verify that every table is used */
	for (table = TAILQ_FIRST(conf->sc_tables); table != NULL;
	     table = nexttb) {
		nexttb = TAILQ_NEXT(table, entry);
		if (table->conf.port == 0) {
			TAILQ_REMOVE(conf->sc_tables, table, entry);
			while ((h = TAILQ_FIRST(&table->hosts)) != NULL) {
				TAILQ_REMOVE(&table->hosts, h, entry);
				free(h);
			}
			if (table->sendbuf != NULL)
				free(table->sendbuf);
			free(table);
			continue;
		}

		TAILQ_FOREACH(h, &table->hosts, entry) {
			if (h->conf.parentid) {
				ph = host_find(conf, h->conf.parentid);

				/* Validate the parent id */
				if (h->conf.id == h->conf.parentid ||
				    ph == NULL || ph->conf.parentid)
					ph = NULL;

				if (ph == NULL) {
					log_warnx("host parent id %d invalid",
					    h->conf.parentid);
					errors++;
				} else
					SLIST_INSERT_HEAD(&ph->children,
					    h, child);
			}
		}

		if (!(table->conf.flags & F_USED)) {
			log_warnx("unused table: %s", table->conf.name);
			errors++;
		}
		if (timercmp(&table->conf.timeout,
		    &conf->sc_conf.interval, >=)) {
			log_warnx("table timeout exceeds interval: %s",
			    table->conf.name);
			errors++;
		}
	}

	/* Verify that every non-default protocol is used */
	TAILQ_FOREACH(proto, conf->sc_protos, entry) {
		if (!(proto->flags & F_USED)) {
			log_warnx("unused protocol: %s", proto->name);
		}
	}

	return (errors ? -1 : 0);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	(void)strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

struct address *
host_v4(const char *s)
{
	struct in_addr		 ina;
	struct sockaddr_in	*sain;
	struct address		*h;

	bzero(&ina, sizeof(ina));
	if (inet_pton(AF_INET, s, &ina) != 1)
		return (NULL);

	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(__func__);
	sain = (struct sockaddr_in *)&h->ss;
	sain->sin_len = sizeof(struct sockaddr_in);
	sain->sin_family = AF_INET;
	sain->sin_addr.s_addr = ina.s_addr;

	return (h);
}

struct address *
host_v6(const char *s)
{
	struct addrinfo		 hints, *res;
	struct sockaddr_in6	*sa_in6;
	struct address		*h = NULL;

	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /* dummy */
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, "0", &hints, &res) == 0) {
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal(__func__);
		sa_in6 = (struct sockaddr_in6 *)&h->ss;
		sa_in6->sin6_len = sizeof(struct sockaddr_in6);
		sa_in6->sin6_family = AF_INET6;
		memcpy(&sa_in6->sin6_addr,
		    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
		    sizeof(sa_in6->sin6_addr));
		sa_in6->sin6_scope_id =
		    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;

		freeaddrinfo(res);
	}

	return (h);
}

int
host_dns(const char *s, struct addresslist *al, int max,
    struct portrange *port, const char *ifname, int ipproto)
{
	struct addrinfo		 hints, *res0, *res;
	int			 error, cnt = 0;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sin6;
	struct address		*h;

	if ((cnt = host_if(s, al, max, port, ifname, ipproto)) != 0)
		return (cnt);

	bzero(&hints, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM; /* DUMMY */
	hints.ai_flags = AI_ADDRCONFIG;
	error = getaddrinfo(s, NULL, &hints, &res0);
	if (error == EAI_AGAIN || error == EAI_NODATA || error == EAI_NONAME)
		return (0);
	if (error) {
		log_warnx("%s: could not parse \"%s\": %s", __func__, s,
		    gai_strerror(error));
		return (-1);
	}

	for (res = res0; res && cnt < max; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal(__func__);

		if (port != NULL)
			bcopy(port, &h->port, sizeof(h->port));
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname))
				log_warnx("%s: interface name truncated",
				    __func__);
			freeaddrinfo(res0);
			free(h);
			return (-1);
		}
		if (ipproto != -1)
			h->ipproto = ipproto;
		h->ss.ss_family = res->ai_family;

		if (res->ai_family == AF_INET) {
			sain = (struct sockaddr_in *)&h->ss;
			sain->sin_len = sizeof(struct sockaddr_in);
			sain->sin_addr.s_addr = ((struct sockaddr_in *)
			    res->ai_addr)->sin_addr.s_addr;
		} else {
			sin6 = (struct sockaddr_in6 *)&h->ss;
			sin6->sin6_len = sizeof(struct sockaddr_in6);
			memcpy(&sin6->sin6_addr, &((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_addr, sizeof(struct in6_addr));
		}

		TAILQ_INSERT_HEAD(al, h, entry);
		cnt++;
	}
	if (cnt == max && res) {
		log_warnx("%s: %s resolves to more than %d hosts", __func__,
		    s, max);
	}
	freeaddrinfo(res0);
	return (cnt);
}

int
host_if(const char *s, struct addresslist *al, int max,
    struct portrange *port, const char *ifname, int ipproto)
{
	struct ifaddrs		*ifap, *p;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sin6;
	struct address		*h;
	int			 cnt = 0, af;

	if (getifaddrs(&ifap) == -1)
		fatal("getifaddrs");

	/* First search for IPv4 addresses */
	af = AF_INET;

 nextaf:
	for (p = ifap; p != NULL && cnt < max; p = p->ifa_next) {
		if (p->ifa_addr->sa_family != af ||
		    (strcmp(s, p->ifa_name) != 0 &&
		    !is_if_in_group(p->ifa_name, s)))
			continue;
		if ((h = calloc(1, sizeof(*h))) == NULL)
			fatal("calloc");

		if (port != NULL)
			bcopy(port, &h->port, sizeof(h->port));
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname))
				log_warnx("%s: interface name truncated",
				    __func__);
			freeifaddrs(ifap);
			return (-1);
		}
		if (ipproto != -1)
			h->ipproto = ipproto;
		h->ss.ss_family = af;

		if (af == AF_INET) {
			sain = (struct sockaddr_in *)&h->ss;
			sain->sin_len = sizeof(struct sockaddr_in);
			sain->sin_addr.s_addr = ((struct sockaddr_in *)
			    p->ifa_addr)->sin_addr.s_addr;
		} else {
			sin6 = (struct sockaddr_in6 *)&h->ss;
			sin6->sin6_len = sizeof(struct sockaddr_in6);
			memcpy(&sin6->sin6_addr, &((struct sockaddr_in6 *)
			    p->ifa_addr)->sin6_addr, sizeof(struct in6_addr));
			sin6->sin6_scope_id = ((struct sockaddr_in6 *)
			    p->ifa_addr)->sin6_scope_id;
		}

		TAILQ_INSERT_HEAD(al, h, entry);
		cnt++;
	}
	if (af == AF_INET) {
		/* Next search for IPv6 addresses */
		af = AF_INET6;
		goto nextaf;
	}

	if (cnt > max) {
		log_warnx("%s: %s resolves to more than %d hosts", __func__,
		    s, max);
	}
	freeifaddrs(ifap);
	return (cnt);
}

int
host(const char *s, struct addresslist *al, int max,
    struct portrange *port, const char *ifname, int ipproto)
{
	struct address *h;

	h = host_v4(s);

	/* IPv6 address? */
	if (h == NULL)
		h = host_v6(s);

	if (h != NULL) {
		if (port != NULL)
			bcopy(port, &h->port, sizeof(h->port));
		if (ifname != NULL) {
			if (strlcpy(h->ifname, ifname, sizeof(h->ifname)) >=
			    sizeof(h->ifname)) {
				log_warnx("%s: interface name truncated",
				    __func__);
				free(h);
				return (-1);
			}
		}
		if (ipproto != -1)
			h->ipproto = ipproto;

		TAILQ_INSERT_HEAD(al, h, entry);
		return (1);
	}

	return (host_dns(s, al, max, port, ifname, ipproto));
}

void
host_free(struct addresslist *al)
{
	struct address	 *h;

	while ((h = TAILQ_FIRST(al)) != NULL) {
		TAILQ_REMOVE(al, h, entry);
		free(h);
	}
}

struct table *
table_inherit(struct table *tb)
{
	char		pname[TABLE_NAME_SIZE + 6];
	struct host	*h, *dsth;
	struct table	*dsttb, *oldtb;

	/* Get the table or table template */
	if ((dsttb = table_findbyname(conf, tb->conf.name)) == NULL) {
		yyerror("unknown table %s", tb->conf.name);
		goto fail;
	}
	if (dsttb->conf.port != 0)
		fatal("invalid table");	/* should not happen */

	if (tb->conf.port == 0) {
		yyerror("invalid port");
		goto fail;
	}

	/* Check if a matching table already exists */
	if (snprintf(pname, sizeof(pname), "%s:%u",
	    tb->conf.name, ntohs(tb->conf.port)) >= (int)sizeof(pname)) {
		yyerror("invalid table name");
		goto fail;
	}
	if (strlcpy(tb->conf.name, pname, sizeof(tb->conf.name)) >=
	    sizeof(tb->conf.name)) {
		yyerror("invalid table mame");
		goto fail;
	}
	if ((oldtb = table_findbyconf(conf, tb)) != NULL) {
		purge_table(conf, NULL, tb);
		return (oldtb);
	}

	/* Create a new table */
	tb->conf.id = ++last_table_id;
	if (last_table_id == INT_MAX) {
		yyerror("too many tables defined");
		goto fail;
	}
	tb->conf.flags |= dsttb->conf.flags;

	/* Inherit global table options */
	if (tb->conf.timeout.tv_sec == 0 && tb->conf.timeout.tv_usec == 0)
		bcopy(&dsttb->conf.timeout, &tb->conf.timeout,
		    sizeof(struct timeval));

	/* Copy the associated hosts */
	TAILQ_INIT(&tb->hosts);
	TAILQ_FOREACH(dsth, &dsttb->hosts, entry) {
		if ((h = (struct host *)
		    calloc(1, sizeof (*h))) == NULL)
			fatal("out of memory");
		bcopy(dsth, h, sizeof(*h));
		h->conf.id = ++last_host_id;
		if (last_host_id == INT_MAX) {
			yyerror("too many hosts defined");
			free(h);
			goto fail;
		}
		h->conf.tableid = tb->conf.id;
		h->tablename = tb->conf.name;
		SLIST_INIT(&h->children);
		TAILQ_INSERT_TAIL(&tb->hosts, h, entry);
		TAILQ_INSERT_TAIL(&conf->sc_hosts, h, globalentry);
	}

	conf->sc_tablecount++;
	TAILQ_INSERT_TAIL(conf->sc_tables, tb, entry);

	return (tb);

 fail:
	purge_table(conf, NULL, tb);
	return (NULL);
}

int
relay_id(struct relay *rl)
{
	rl->rl_conf.id = ++last_relay_id;
	rl->rl_conf.tls_keyid = ++last_key_id;
	rl->rl_conf.tls_cakeyid = ++last_key_id;

	if (last_relay_id == INT_MAX || last_key_id == INT_MAX)
		return (-1);

	return (0);
}

struct relay *
relay_inherit(struct relay *ra, struct relay *rb)
{
	struct relay_config	 rc;
	struct relay_table	*rta, *rtb;

	bcopy(&rb->rl_conf, &rc, sizeof(rc));
	bcopy(ra, rb, sizeof(*rb));

	bcopy(&rc.ss, &rb->rl_conf.ss, sizeof(rb->rl_conf.ss));
	rb->rl_conf.port = rc.port;
	rb->rl_conf.flags =
	    (ra->rl_conf.flags & ~F_TLS) | (rc.flags & F_TLS);
	if (!(rb->rl_conf.flags & F_TLS)) {
		rb->rl_tls_cert = NULL;
		rb->rl_conf.tls_cert_len = 0;
		rb->rl_tls_key = NULL;
		rb->rl_conf.tls_key_len = 0;
	}
	TAILQ_INIT(&rb->rl_tables);

	if (relay_id(rb) == -1) {
		yyerror("too many relays defined");
		goto err;
	}

	if (snprintf(rb->rl_conf.name, sizeof(rb->rl_conf.name), "%s%u:%u",
	    ra->rl_conf.name, rb->rl_conf.id, ntohs(rc.port)) >=
	    (int)sizeof(rb->rl_conf.name)) {
		yyerror("invalid relay name");
		goto err;
	}

	if (relay_findbyname(conf, rb->rl_conf.name) != NULL ||
	    relay_findbyaddr(conf, &rb->rl_conf) != NULL) {
		yyerror("relay %s defined twice", rb->rl_conf.name);
		goto err;
	}
	if (relay_load_certfiles(rb) == -1) {
		yyerror("cannot load certificates for relay %s",
		    rb->rl_conf.name);
		goto err;
	}

	TAILQ_FOREACH(rta, &ra->rl_tables, rlt_entry) {
		if ((rtb = calloc(1, sizeof(*rtb))) == NULL) {
			yyerror("cannot allocate relay table");
			goto err;
		}
		rtb->rlt_table = rta->rlt_table;
		rtb->rlt_mode = rta->rlt_mode;
		rtb->rlt_flags = rta->rlt_flags;

		TAILQ_INSERT_TAIL(&rb->rl_tables, rtb, rlt_entry);
	}

	conf->sc_relaycount++;
	SPLAY_INIT(&rlay->rl_sessions);
	TAILQ_INSERT_TAIL(conf->sc_relays, rb, rl_entry);

	return (rb);

 err:
	while ((rtb = TAILQ_FIRST(&rb->rl_tables))) {
		TAILQ_REMOVE(&rb->rl_tables, rtb, rlt_entry);
		free(rtb);
	}
	free(rb);
	return (NULL);
}

int
getservice(char *n)
{
	struct servent	*s;
	const char	*errstr;
	long long	 llval;

	llval = strtonum(n, 0, UINT16_MAX, &errstr);
	if (errstr) {
		s = getservbyname(n, "tcp");
		if (s == NULL)
			s = getservbyname(n, "udp");
		if (s == NULL) {
			yyerror("unknown port %s", n);
			return (-1);
		}
		return (s->s_port);
	}

	return (htons((u_short)llval));
}

int
is_if_in_group(const char *ifname, const char *groupname)
{
	unsigned int		 len;
	struct ifgroupreq	 ifgr;
	struct ifg_req		*ifg;
	int			 s;
	int			 ret = 0;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
		err(1, "socket");

	memset(&ifgr, 0, sizeof(ifgr));
	if (strlcpy(ifgr.ifgr_name, ifname, IFNAMSIZ) >= IFNAMSIZ)
		err(1, "IFNAMSIZ");
	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1) {
		if (errno == EINVAL || errno == ENOTTY)
			goto end;
		err(1, "SIOCGIFGROUP");
	}

	len = ifgr.ifgr_len;
	ifgr.ifgr_groups = calloc(len / sizeof(struct ifg_req),
	    sizeof(struct ifg_req));
	if (ifgr.ifgr_groups == NULL)
		err(1, "getifgroups");
	if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1)
		err(1, "SIOCGIFGROUP");

	ifg = ifgr.ifgr_groups;
	for (; ifg && len >= sizeof(struct ifg_req); ifg++) {
		len -= sizeof(struct ifg_req);
		if (strcmp(ifg->ifgrq_group, groupname) == 0) {
			ret = 1;
			break;
		}
	}
	free(ifgr.ifgr_groups);

end:
	close(s);
	return (ret);
}
@


1.213
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.212 2016/09/26 16:25:16 reyk Exp $	*/
d2609 1
a2609 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.212
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.211 2016/09/03 14:44:21 reyk Exp $	*/
d2755 4
a2758 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d2817 1
a2817 1
	TAILQ_FOREACH(sym, &symhead, entry)
d2822 1
@


1.211
log
@Replace [RELAY|SERVER]_MAXPROC with the new PROC_MAX_INSTANCES
variable and limit it from 128 to 32 instances (the old value).
While here, move a few PROC_ defines around.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.210 2016/09/02 16:14:09 reyk Exp $	*/
d388 2
a389 1
			bcopy(&$2, &conf->sc_conf.timeout, sizeof(struct timeval));
@


1.210
log
@Move snmp options into struct relayd_config and delay start of the
snmp subsystem until the configuration is done.

OK benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.209 2016/09/02 14:45:51 reyk Exp $	*/
d391 1
a391 1
			if ($2 <= 0 || $2 > RELAY_MAXPROC) {
@


1.209
log
@Split "struct relayd" into two structs: "struct relayd" and "struct
relayd_config".  This way we can send all the relevant global
configuration to the children, not just the flags and the opts.

With input from and
OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.208 2016/09/01 10:49:48 claudio Exp $	*/
a378 2
			if (loadcfg)
				break;
a384 2
			if (loadcfg)
				break;
a387 2
			if (loadcfg)
				break;
a390 2
			if (loadcfg)
				break;
a398 2
			if (loadcfg)
				break;
d401 14
a414 7
				conf->sc_snmp_flags |= FSNMP_TRAPONLY;
			if ($3)
				conf->sc_snmp_path = $3;
			else
				conf->sc_snmp_path = strdup(AGENTX_SOCKET);
			if (conf->sc_snmp_path == NULL)
				fatal("out of memory");
@


1.208
log
@Switch from the not really working session cache (because of the multiprocess
nature of relayd) to tls session tickets to do TLS session resumption.
TLS session tickets do not need to store SSL session data in the server but
instead send an encrypted ticket to the clients that allows to resume the
session. This is mostly stateless (apart from the encryption keys).
relayd now ensures that all relay processes use the same key to encrypt
the tickets. Keys are rotated every 2h and there is a primary and backup key.
The tls session timeout is set to 2h to hint to the clients how long the
session tickets is supposed to be alive.
Input and OK benno@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.207 2016/06/21 21:35:25 benno Exp $	*/
d381 1
a381 1
			if ((conf->sc_interval.tv_sec = $2) < 0) {
d389 1
a389 1
			conf->sc_opts |= $2;
d394 1
a394 1
			bcopy(&$2, &conf->sc_timeout, sizeof(struct timeval));
d404 1
a404 1
			conf->sc_prefork_relay = $2;
d409 1
a409 1
			conf->sc_flags |= F_SNMP;
d431 1
a431 1
			conf->sc_flags |= F_NEEDPF;
d584 1
a584 1
			conf->sc_flags |= F_NEEDPF;
d657 1
a657 1
			bcopy(&conf->sc_timeout, &tb->conf.timeout,
d753 2
a754 2
			if ($2 < conf->sc_interval.tv_sec ||
			    $2 % conf->sc_interval.tv_sec) {
d760 1
a760 1
			    ($2 / conf->sc_interval.tv_sec) - 1;
d860 1
a860 1
			conf->sc_flags |= F_TLS;
d865 1
a865 1
				conf->sc_flags |= F_TLS;
d886 1
a886 1
				conf->sc_flags |= F_TLS;
d911 1
a911 1
				conf->sc_flags |= F_TLS;
d933 1
a933 1
			conf->sc_flags |= F_SCRIPT;
d1703 1
a1703 1
				conf->sc_flags |= F_TLS;
d1716 1
a1716 1
				conf->sc_flags |= F_TLSCLIENT;
d1780 1
a1780 1
			conf->sc_flags |= F_NEEDPF;
d1785 1
a1785 1
			conf->sc_flags |= F_NEEDPF;
d1834 1
a1834 1
			conf->sc_flags |= F_NEEDRT;
d2633 1
a2633 1
	conf->sc_flags = 0;
d2662 1
a2662 1
		if ((conf->sc_opts & RELAYD_OPT_VERBOSE) && !sym->used)
d2690 1
a2690 1
	if (timercmp(&conf->sc_timeout, &conf->sc_interval, >=)) {
d2734 2
a2735 1
		if (timercmp(&table->conf.timeout, &conf->sc_interval, >=)) {
@


1.207
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.206 2015/11/22 13:27:13 reyk Exp $	*/
d175 1
a175 1
%token	EDH CURVE
d181 1
a181 1
%type	<v.number>	opttls opttlsclient tlscache
a998 1
			p->cache = RELAY_CACHESIZE;
d1093 2
a1094 1
tlsflags	: SESSION CACHE tlscache	{ proto->cache = $3; }
a1182 10
tlscache	: NUMBER			{
			if ($1 < 0) {
				yyerror("invalid tlscache value: %d", $1);
				YYERROR;
			}
			$$ = $1;
		}
		| DISABLE			{ $$ = -2; }
		;

d2250 1
@


1.206
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.205 2015/08/20 22:39:29 deraadt Exp $	*/
d352 8
@


1.205
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.204 2015/05/02 13:15:24 claudio Exp $	*/
d2838 1
a2838 1
		fatal(NULL);
d2860 1
a2860 1
			fatal(NULL);
d2907 1
a2907 1
			fatal(NULL);
@


1.204
log
@Fix obvious problems with relayd config reload.
- fix a TAILQ corruption because of a use after free
- do not reinit the SSL engine since that fails
OK sthen, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.203 2015/02/08 04:50:32 reyk Exp $	*/
d3269 2
a3270 3
	ifgr.ifgr_groups =
	    (struct ifg_req *)calloc(len / sizeof(struct ifg_req),
		sizeof(struct ifg_req));
@


1.203
log
@Use AI_ADDRCONFIG when resolv hosts on startup.

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.202 2015/01/22 17:42:09 reyk Exp $	*/
d534 1
a534 1
				purge_table(conf->sc_tables, $3);
d539 1
a539 1
				purge_table(conf->sc_tables, $3);
d1933 1
a1933 1
				purge_table(conf->sc_tables, $3);
d3094 1
a3094 1
		purge_table(NULL, tb);
d3137 1
a3137 1
	purge_table(NULL, tb);
@


1.203.2.1
log
@maintainance diff for relayd
MFC the following changes

- Missing free(3) in error path (ssl.c,v 1.29)
- fix a memory leak. (pfe.c,v 1.80)
- allocate se_log evbuffer before loging errors with relay_close()
  (relay.c,v 1.192)
- fix a file descriptor leak in http protocol handling
  (relay.c,v 1.193 and relay_http.c,v 1.44)
- Fix obvious problems with relayd config reload
  (ca.c,v 1.13; config.c,v 1.25; parse.y,v 1.204;
  relayd.c,v 1.139; relayd.h,v 1.209)
- http protocol: you cannot append to the previous key-value before
  line three of a request (relay_http.c,v 1.45)
- fix a crash / use after free (relay.c,v 1.194; relay_http.c,v 1.46)
- fix a non safe use of TAILQ_FOREACH with TAILQ_REMOVE
  (relay_http.c,v 1.47)
- Plug a memory leak by simplifying kv_free() (relayd.c,v 1.141)
- Fix memory leak in error case (relay_http.c,v 1.48)
- track the connection state of a session and stops doing double
  opens in certain situations (relay.c,v 1.195; relay_http.c,v 1.49; relayd.h,v 1.210)
- coding style (relay.c,v 1.196; relay_http.c,v 1.50; relayd.h,v 1.212)

ok claudio@@, sthen@@ and feedback tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.203 2015/02/08 04:50:32 reyk Exp $	*/
d534 1
a534 1
				purge_table(conf, conf->sc_tables, $3);
d539 1
a539 1
				purge_table(conf, conf->sc_tables, $3);
d1933 1
a1933 1
				purge_table(conf, conf->sc_tables, $3);
d3094 1
a3094 1
		purge_table(conf, NULL, tb);
d3137 1
a3137 1
	purge_table(conf, NULL, tb);
@


1.202
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.201 2015/01/21 21:50:33 deraadt Exp $	*/
d2892 1
@


1.201
log
@Include <netinet/in.h> before <net/pfvar.h>.  In a future change when
ports is ready, <net/pfvar.h> will stop including a pile of balony.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.200 2015/01/16 15:06:40 deraadt Exp $	*/
d33 2
d40 1
d42 4
a46 1
#include <unistd.h>
d48 1
a49 1
#include <event.h>
a50 3
#include <stdint.h>
#include <stdarg.h>
#include <stdio.h>
a55 2

#include <openssl/ssl.h>
@


1.200
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.199 2014/12/23 13:18:23 reyk Exp $	*/
d34 2
a37 3
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/route.h>
@


1.199
log
@pf now supports source-hash and random with tables so we can allow it
in redirections.  Thanks for help and input from jsg and yasuoka who
reminded me to dig out and update these old diffs for pf and relayd.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.198 2014/12/21 00:54:49 guenther Exp $	*/
d153 1
a153 1
			char			 name[MAXHOSTNAMELEN];
@


1.198
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.197 2014/12/18 20:55:01 reyk Exp $	*/
d495 3
a780 2
			case RELAY_DSTMODE_RANDOM:
			case RELAY_DSTMODE_SRCHASH:
d787 1
d789 1
@


1.197
log
@Update relayd to use siphash instead of sys/hash.  The source-hash,
loadbalance and hash modes use a random key by default that can be
forced to be a static key with a new configuration argument.

With input from Max Fillinger.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.196 2014/12/12 10:05:09 reyk Exp $	*/
a37 1
#include <arpa/nameser.h>
@


1.196
log
@Change the keyword "ssl" to "tls" to reflect reality since we
effectively disabled support for the SSL protocols.  SSL remains a
common term describing SSL/TLS, there is some controvery about this
change, and the name really doesn't matter, but I feel confident about
it now.

(btw., sthen@@ pointed out some historical context:
http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html)

OK benno@@, with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.195 2014/11/20 05:51:20 jsg Exp $	*/
a32 1
#include <sys/hash.h>
d54 1
d121 1
d147 4
d193 1
d495 5
d696 1
d752 1
a752 1
		| MODE dstmode		{
d757 22
d780 1
d802 44
d1804 9
d1925 3
@


1.195
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.194 2014/11/19 10:24:40 blambert Exp $	*/
d168 1
a168 1
%token	SOCKET SPLICE SSL STICKYADDR STYLE TABLE TAG TAGGED TCP TIMEOUT TO
d177 1
a177 1
%type	<v.number>	optssl optsslclient sslcache
d180 1
a180 1
%type	<v.number>	ssldhparams sslecdhcurve
d219 11
a229 2
optssl		: /*empty*/	{ $$ = 0; }
		| SSL		{ $$ = 1; }
d232 2
a233 2
optsslclient	: /*empty*/	{ $$ = 0; }
		| WITH SSL	{ $$ = 1; }
d769 1
a769 1
		| SSL			{
d771 2
a772 2
			conf->sc_flags |= F_SSL;
			table->conf.flags |= F_SSL;
d776 2
a777 2
				conf->sc_flags |= F_SSL;
				table->conf.flags |= F_SSL;
d797 2
a798 2
				conf->sc_flags |= F_SSL;
				table->conf.flags |= F_SSL;
d819 1
a819 1
		| SEND sendbuf EXPECT STRING optssl {
d822 2
a823 2
				conf->sc_flags |= F_SSL;
				table->conf.flags |= F_SSL;
d912 1
a912 1
			p->sslflags = SSLFLAG_DEFAULT;
d915 4
a918 4
			(void)strlcpy(p->sslciphers, SSLCIPHERS_DEFAULT,
			    sizeof(p->sslciphers));
			p->ssldhparams = SSLDHPARAMS_DEFAULT;
			p->sslecdhcurve = SSLECDHCURVE_DEFAULT;
d928 2
a929 2
			if ((proto->sslflags & SSLFLAG_VERSION) == 0) {
				yyerror("invalid SSL protocol");
d946 2
a947 2
protoptsl	: SSL sslflags
		| SSL '{' sslflags_l '}'
d1001 2
a1002 2
sslflags_l	: sslflags comma sslflags_l
		| sslflags
d1005 1
a1005 1
sslflags	: SESSION CACHE sslcache	{ proto->cache = $3; }
d1007 4
a1010 4
			if (strlcpy(proto->sslciphers, $2,
			    sizeof(proto->sslciphers)) >=
			    sizeof(proto->sslciphers)) {
				yyerror("sslciphers truncated");
d1017 1
a1017 1
			proto->ssldhparams = SSLDHPARAMS_NONE;
d1019 2
a1020 2
		| EDH ssldhparams		{
			proto->ssldhparams = $2;
d1023 1
a1023 1
			proto->sslecdhcurve = 0;
d1025 2
a1026 2
		| ECDH sslecdhcurve		{
			proto->sslecdhcurve = $2;
d1029 4
a1032 4
			if (strlcpy(proto->sslca, $3,
			    sizeof(proto->sslca)) >=
			    sizeof(proto->sslca)) {
				yyerror("sslca truncated");
d1039 4
a1042 4
			if (strlcpy(proto->sslcakey, $3,
			    sizeof(proto->sslcakey)) >=
			    sizeof(proto->sslcakey)) {
				yyerror("sslcakey truncated");
d1047 2
a1048 2
			if ((proto->sslcapass = strdup($5)) == NULL) {
				yyerror("sslcapass");
d1057 4
a1060 4
			if (strlcpy(proto->sslcacert, $3,
			    sizeof(proto->sslcacert)) >=
			    sizeof(proto->sslcacert)) {
				yyerror("sslcacert truncated");
d1066 2
a1067 2
		| NO flag			{ proto->sslflags &= ~($2); }
		| flag				{ proto->sslflags |= $1; }
d1072 1
a1072 1
				$$ = SSLFLAG_SSLV3;
d1074 1
a1074 1
				$$ = SSLFLAG_TLSV1;
d1076 1
a1076 1
				$$ = SSLFLAG_TLSV1_0;
d1078 1
a1078 1
				$$ = SSLFLAG_TLSV1_1;
d1080 1
a1080 1
				$$ = SSLFLAG_TLSV1_2;
d1082 1
a1082 1
				$$ = SSLFLAG_CIPHER_SERVER_PREF;
d1084 1
a1084 1
				$$ = SSLFLAG_CLIENT_RENEG;
d1086 1
a1086 1
				yyerror("invalid SSL flag: %s", $1);
d1094 1
a1094 1
sslcache	: NUMBER			{
d1096 1
a1096 1
				yyerror("invalid sslcache value: %d", $1);
d1475 1
a1475 1
ssldhparams	: /* empty */		{ $$ = SSLDHPARAMS_MIN; }
d1477 1
a1477 1
			if ($2 < SSLDHPARAMS_MIN) {
d1485 1
a1485 1
sslecdhcurve	: /* empty */		{ $$ = SSLECDHCURVE_DEFAULT; }
d1489 1
a1489 1
			else if ((proto->sslecdhcurve = OBJ_sn2nid($2)) == 0) {
d1595 1
a1595 1
relayoptsl	: LISTEN ON STRING port optssl {
d1623 2
a1624 2
				r->rl_conf.flags |= F_SSL;
				conf->sc_flags |= F_SSL;
d1629 1
a1629 1
		| forwardmode optsslclient TO forwardspec dstaf {
d1636 2
a1637 2
				rlay->rl_conf.flags |= F_SSLCLIENT;
				conf->sc_flags |= F_SSLCLIENT;
d2160 1
d3051 2
a3052 2
	rl->rl_conf.ssl_keyid = ++last_key_id;
	rl->rl_conf.ssl_cakeyid = ++last_key_id;
d3072 6
a3077 6
	    (ra->rl_conf.flags & ~F_SSL) | (rc.flags & F_SSL);
	if (!(rb->rl_conf.flags & F_SSL)) {
		rb->rl_ssl_cert = NULL;
		rb->rl_conf.ssl_cert_len = 0;
		rb->rl_ssl_key = NULL;
		rb->rl_conf.ssl_key_len = 0;
@


1.194
log
@Support exporting relayd statistics via AgentX/snmpd

This should be equivalent to the statistics available
via the various relaydctl show commands

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.193 2014/11/07 13:48:06 jsing Exp $	*/
d2333 3
@


1.193
log
@Remove the sslv2 option since LibreSSL has no SSLv2 support (however retain
SSL_OP_NO_SSLv2 in case you happen to be running relayd on another platform
with another SSL library). Also fix the SSLv3 handling so that 'no sslv3'
actually works as intended.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.192 2014/11/02 13:59:40 bluhm Exp $	*/
d3021 1
@


1.192
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.191 2014/10/20 14:50:41 reyk Exp $	*/
d1062 1
a1062 3
			if (strcmp("sslv2", $1) == 0)
				$$ = SSLFLAG_SSLV2;
			else if (strcmp("sslv3", $1) == 0)
@


1.191
log
@Remove the "interface" option from the "transparent forward" directive.
It was mandatory in the grammar but never used in the code.

A fully transparent relay can now be specified with the following
directive in a relay block: "transparent forward to destination".

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.190 2014/10/15 11:06:16 reyk Exp $	*/
d2036 1
a2036 1
	char		*nfmt;
d2040 2
a2041 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d2043 2
a2044 1
	free(nfmt);
@


1.190
log
@Disable SSLv3 by default.

OK sthen@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.189 2014/09/05 10:19:26 blambert Exp $	*/
d1622 1
a1622 1
		| forwardmode optsslclient TO forwardspec interface dstaf {
d1624 2
a1625 13
			switch ($1) {
			case FWD_NORMAL:
				if ($5 == NULL)
					break;
				yyerror("superfluous interface");
				YYERROR;
			case FWD_ROUTE:
				yyerror("no route for redirections");
				YYERROR;
			case FWD_TRANS:
				if ($5 != NULL)
					break;
				yyerror("missing interface");
a1626 10
			}
			if ($5 != NULL) {
				if (strlcpy(rlay->rl_conf.ifname, $5,
				    sizeof(rlay->rl_conf.ifname)) >=
				    sizeof(rlay->rl_conf.ifname)) {
					yyerror("interface name truncated");
					free($5);
					YYERROR;
				}
				free($5);
@


1.189
log
@revert previous; was based on a work-in-progress, as well
as being an incomplete and therefore incorrect adaptation

apologies to anybody who got bitten by this mistake

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.188 2014/08/29 09:03:36 blambert Exp $	*/
d1068 6
@


1.188
log
@Implement consistent host hashing for relayd, based on
work done by andre@@

Re-add a randomized hash seed (which had apparently
gotten inadvertently removed in the past).

Allows for multiple relayd instances to be configured
to forward traffic to the same host, falling back to
the random seed when not explicitly configured to do so.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.187 2014/07/11 17:35:16 reyk Exp $	*/
a121 2
static u_int32_t	 hashseed = 0;

d171 1
a171 1
%token	EDH CURVE SEED
d180 1
a180 1
%type	<v.number>	ssldhparams sslecdhcurve hashseed
d731 1
a731 1
		| MODE dstmode hashseed	{
a741 1
				table->conf.hash_seed = $3;
a757 3
hashseed	: /* nothing */		{ $$ = hashseed; }
		| SEED STRING		{ $$ = hash32_str($2, HASHINIT); }

a1729 1
			rlt->rlt_key = rlt->rlt_table->conf.hash_seed;
a2152 1
		{ "seed",		SEED },
a2545 3

	while (hashseed == 0)
		hashseed = arc4random();
@


1.187
log
@Sometimes I just sort the tokens in parse.y
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.186 2014/07/11 16:59:38 reyk Exp $	*/
d122 2
d173 1
a173 1
%token	EDH CURVE
d182 1
a182 1
%type	<v.number>	ssldhparams sslecdhcurve
d733 1
a733 1
		| MODE dstmode		{
d744 1
d761 3
d1736 1
d2160 1
d2554 3
@


1.186
log
@Add support for EDH to provide perfect forward secrecy for older SSL
clients.  Additionally, add options for disallowing client-initiated
renegotiations and to prefer the server's cipher list over the
client's preferences.

This work is based on a diff by Markus Gebert at hostpoint.ch, and was
discussed with jsing@@ resulting in a few different defaults.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.185 2014/07/11 11:48:50 reyk Exp $	*/
d161 11
a171 11
%token	ALL APPEND BACKLOG BACKUP BUFFER CA CACHE SET CHECK
%token	CIPHERS CODE COOKIE DEMOTE DIGEST DISABLE ERROR EXPECT PASS BLOCK
%token	EXTERNAL FILENAME FORWARD FROM HASH HEADER HOST ICMP
%token	INCLUDE INET INET6 INTERFACE INTERVAL IP LABEL LISTEN VALUE
%token	LOADBALANCE LOG LOOKUP METHOD MODE NAT NO DESTINATION
%token	NODELAY NOTHING ON PARENT PATH PFTAG PORT PREFORK PRIORITY PROTO
%token	QUERYSTR REAL REDIRECT RELAY REMOVE REQUEST RESPONSE RETRY QUICK
%token	RETURN ROUNDROBIN ROUTE SACK SCRIPT SEND SESSION SNMP SOCKET SPLICE
%token	SSL STICKYADDR STYLE TABLE TAG TAGGED TCP TIMEOUT TO ROUTER RTLABEL
%token	TRANSPARENT TRAP UPDATES URL VIRTUAL WITH TTL RTABLE MATCH PARAMS
%token	RANDOM LEASTSTATES SRCHASH KEY CERTIFICATE PASSWORD ECDH EDH CURVE
@


1.185
log
@Simplify the code that handles the HTTP headers by using an RB tree
with associated lists instead of the complicated lookup table and
"others" list.  This might add a little malloc overhead for common
headers but also fixes some issues like the handling of repeated
headers -  for example, handling of multiple "Set-Cookie" headers.

ok bluhm@@ (regress part)
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.184 2014/07/09 16:42:05 reyk Exp $	*/
d170 2
a171 2
%token	TRANSPARENT TRAP UPDATES URL VIRTUAL WITH TTL RTABLE MATCH
%token	RANDOM LEASTSTATES SRCHASH KEY CERTIFICATE PASSWORD ECDH CURVE
d180 1
d908 1
d1007 11
a1017 9
		| ECDH CURVE STRING		{
			if (strcmp("none", $3) == 0)
				proto->sslecdhcurve = 0;
			else if ((proto->sslecdhcurve = OBJ_sn2nid($3)) == 0) {
				yyerror("ECDH curve not supported");
				free($3);
				YYERROR;
			}
			free($3);
d1068 4
d1462 23
d2093 1
d2125 1
@


1.184
log
@Replace the protocol directives for HTTP with a new generic filtering
language.  The grammar is inspired by pf and allows to write versatile
last-matching filter rules in protocol sections starting with the
"pass", "block" or "match" keywords.  This work was started almost two
years ago and replaces large parts of relayd(8)'s HTTP and filtering
code.  The initial version reimplements and extends HTTP filtering,
but will be improved to support generic TCP and other protocols later.

With some testing, feedback, and help from benno@@ and andre@@.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.183 2014/06/25 11:05:15 reyk Exp $	*/
d1157 1
a1157 1
			    HTTP_HEADER_NONE) {
a1188 2
			rule->rule_kv[keytype].kv_header_id =
			    relay_httpheader_byname($3);
@


1.183
log
@sync copyright to reality according to my last changes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.182 2014/05/12 14:28:22 andre Exp $	*/
d59 1
d111 1
a111 1
static struct protonode	 node;
d113 3
a115 1
static u_int16_t	 label = 0;
a116 1
static int		 nodedirection;
d118 3
d146 1
d161 7
a167 7
%token	ALL APPEND BACKLOG BACKUP BUFFER CA CACHE CHANGE CHECK
%token	CIPHERS CODE COOKIE DEMOTE DIGEST DISABLE ERROR EXPECT
%token	EXTERNAL FILENAME FILTER FORWARD FROM HASH HEADER HOST ICMP
%token	INCLUDE INET INET6 INTERFACE INTERVAL IP LABEL LISTEN
%token	LOADBALANCE LOG LOOKUP MARK MARKED MODE NAT NO DESTINATION
%token	NODELAY NOTHING ON PARENT PATH PORT PREFORK PRIORITY PROTO
%token	QUERYSTR REAL REDIRECT RELAY REMOVE REQUEST RESPONSE RETRY
d169 1
a169 1
%token	SSL STICKYADDR STYLE TABLE TAG TCP TIMEOUT TO ROUTER RTLABEL
d174 3
a176 3
%type	<v.string>	hostname interface table optstring
%type	<v.number>	http_type loglevel mark trap
%type	<v.number>	direction dstmode flag forwardmode retry
d179 1
d184 1
a184 1
%type	<v.digest>	digest
d186 1
d552 1
a552 1
		| match TAG STRING {
d674 1
d857 10
d904 1
a912 2
			RB_INIT(&p->request_tree);
			RB_INIT(&p->response_tree);
d941 1
a941 23
		| LABEL STRING			{
			label = pn_name2id($2);
			free($2);
			if (label == 0) {
				yyerror("invalid protocol action label");
				YYERROR;
			}
		}
		| NO LABEL			{
			label = 0;
		}
		| direction			{
			node.label = label;
			node.labelname = NULL;
			nodedirection = $1;
		} protonode {
			if (nodedirection != -1 &&
			    protonode_add(nodedirection, proto, &node) == -1) {
				yyerror("failed to add protocol node");
				YYERROR;
			}
			bzero(&node, sizeof(node));
		}
a944 5
direction	: /* empty */		{ $$ = RELAY_DIR_REQUEST; }
		| REQUEST		{ $$ = RELAY_DIR_REQUEST; }
		| RESPONSE		{ $$ = RELAY_DIR_RESPONSE; }
		;

d1073 3
a1075 5
protonode	: nodetype APPEND STRING TO STRING nodeopts		{
			if (node.type != NODE_TYPE_HEADER) {
				yyerror("action only supported for headers");
				free($5);
				free($3);
d1078 7
a1084 4
			node.action = NODE_ACTION_APPEND;
			node.key = strdup($5);
			node.value = strdup($3);
			if (node.key == NULL || node.value == NULL)
d1086 19
a1104 10
			if (strchr(node.value, '$') != NULL)
				node.flags |= PNFLAG_MACRO;
			free($5);
			free($3);
		}
		| nodetype CHANGE STRING TO STRING nodeopts		{
			if (node.type != NODE_TYPE_HEADER) {
				yyerror("action only supported for headers");
				free($5);
				free($3);
d1107 21
a1127 9
			node.action = NODE_ACTION_CHANGE;
			node.key = strdup($3);
			node.value = strdup($5);
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			if (strchr(node.value, '$') != NULL)
				node.flags |= PNFLAG_MACRO;
			free($5);
			free($3);
d1129 32
a1160 4
		| nodetype REMOVE STRING nodeopts			{
			if (node.type != NODE_TYPE_HEADER) {
				yyerror("action only supported for headers");
				free($3);
d1163 11
a1173 4
			node.action = NODE_ACTION_REMOVE;
			node.key = strdup($3);
			node.value = NULL;
			if (node.key == NULL)
d1176 3
d1180 17
a1196 14
		| nodetype REMOVE					{
			if (node.type != NODE_TYPE_HEADER) {
				yyerror("action only supported for headers");
				YYERROR;
			}
			node.action = NODE_ACTION_REMOVE;
			node.key = NULL;
			node.value = NULL;
		} nodefile
		| nodetype EXPECT STRING FROM STRING nodeopts		{
			node.action = NODE_ACTION_EXPECT;
			node.key = strdup($5);
			node.value = strdup($3);
			if (node.key == NULL || node.value == NULL)
a1197 1
			free($5);
d1199 3
a1201 1
			proto->lateconnect++;
d1203 13
a1215 5
		| nodetype EXPECT STRING nodeopts			{
			node.action = NODE_ACTION_EXPECT;
			node.key = strdup($3);
			node.value = strdup("*");
			if (node.key == NULL || node.value == NULL)
d1218 3
a1220 1
			proto->lateconnect++;
d1222 15
a1236 10
		| nodetype EXPECT					{
			node.action = NODE_ACTION_EXPECT;
			node.key = NULL;
			node.value = "*";
			proto->lateconnect++;
		} nodefile
		| nodetype EXPECT digest nodeopts			{
			if (node.type != NODE_TYPE_URL) {
				yyerror("digest not supported for this type");
				free($3.digest);
d1238 1
d1240 7
a1246 5
			node.action = NODE_ACTION_EXPECT;
			node.key = strdup($3.digest);
			node.flags |= PNFLAG_LOOKUP_DIGEST($3.type);
			node.value = strdup("*");
			if (node.key == NULL || node.value == NULL)
a1247 10
			free($3.digest);
			proto->lateconnect++;
		}
		| nodetype FILTER STRING FROM STRING nodeopts		{
			node.action = NODE_ACTION_FILTER;
			node.key = strdup($5);
			node.value = strdup($3);
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($5);
d1249 3
a1251 1
			proto->lateconnect++;
d1253 13
a1265 8
		| nodetype FILTER STRING nodeopts			{
			node.action = NODE_ACTION_FILTER;
			node.key = strdup($3);
			node.value = strdup("*");
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($3);
			proto->lateconnect++;
d1267 7
a1273 9
		| nodetype FILTER					{
			node.action = NODE_ACTION_FILTER;
			node.key = NULL;
			node.value = "*";
			proto->lateconnect++;
		} nodefile
		| nodetype FILTER digest nodeopts			{
			if (node.type != NODE_TYPE_URL) {
				yyerror("digest not supported for this type");
d1275 1
d1277 1
d1279 8
a1286 5
			node.action = NODE_ACTION_FILTER;
			node.key = strdup($3.digest);
			node.flags |= PNFLAG_LOOKUP_DIGEST($3.type);
			node.value = strdup("*");
			if (node.key == NULL || node.value == NULL)
d1289 3
a1291 1
			proto->lateconnect++;
d1293 27
a1319 6
		| nodetype HASH STRING nodeopts				{
			node.action = NODE_ACTION_HASH;
			node.key = strdup($3);
			node.value = NULL;
			if (node.key == NULL)
				fatal("out of memory");
a1320 1
			proto->lateconnect++;
d1322 27
a1348 8
		| nodetype LOG STRING nodeopts				{
			node.action = NODE_ACTION_LOG;
			node.key = strdup($3);
			node.value = NULL;
			node.flags |= PNFLAG_LOG;
			if (node.key == NULL)
				fatal("out of memory");
			free($3);
d1350 8
a1357 15
		| nodetype LOG						{
			node.action = NODE_ACTION_LOG;
			node.key = NULL;
			node.value = NULL;
			node.flags |= PNFLAG_LOG;
		} nodefile
		| nodetype MARK STRING FROM STRING WITH mark log	{
			node.action = NODE_ACTION_MARK;
			node.key = strdup($5);
			node.value = strdup($3);
			node.mark = $7;
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($3);
			free($5);
d1359 24
a1382 4
		| nodetype MARK STRING WITH mark nodeopts		{
			if (node.mark) {
				yyerror("either mark or marked");
				free($3);
d1385 1
a1385 7
			node.action = NODE_ACTION_MARK;
			node.key = strdup($3);
			node.value = strdup("*");
			node.mark = $5;	/* overwrite */
			if (node.key == NULL || node.value == NULL)
				fatal("out of memory");
			free($3);
d1387 21
a1407 6
		;

nodefile	: FILENAME STRING nodeopts			{
			if (protonode_load(nodedirection,
			    proto, &node, $2) == -1) {
				yyerror("failed to load from file: %s", $2);
d1409 2
a1413 1
			nodedirection = -1;	/* don't add template node */
d1415 16
a1430 16
		;

nodeopts	: marked log
		;

marked		: /* empty */
		| MARKED mark			{ node.mark = $2; }
		;

log		: /* empty */
		| LOG				{ node.flags |= PNFLAG_LOG; }
		;

mark		: NUMBER					{
			if ($1 <= 0 || $1 >= (int)USHRT_MAX) {
				yyerror("invalid mark: %d", $1);
d1433 8
a1440 1
			$$ = $1;
d1444 2
a1445 12
nodetype	: HEADER			{
			node.type = NODE_TYPE_HEADER;
		}
		| QUERYSTR			{ node.type = NODE_TYPE_QUERY; }
		| COOKIE			{
			node.type = NODE_TYPE_COOKIE;
		}
		| PATH				{
			proto->flags |= F_LOOKUP_PATH;
			node.type = NODE_TYPE_PATH;
		}
		| URL				{ node.type = NODE_TYPE_URL; }
d1448 6
a1453 8
sslcache	: NUMBER			{
			if ($1 < 0) {
				yyerror("invalid sslcache value: %d", $1);
				YYERROR;
			}
			$$ = $1;
		}
		| DISABLE			{ $$ = -2; }
d1875 1
a1875 1
interface	: /*empty*/		{ $$ = NULL; }
d2049 1
a2053 1
		{ "change",		CHANGE },
a2067 1
		{ "filter",		FILTER },
a2086 2
		{ "mark",		MARK },
		{ "marked",		MARKED },
d2088 1
d2096 1
d2099 1
d2105 1
d2124 1
d2134 1
d2143 1
@


1.182
log
@Fix a leak from a recent added mark/marked keywords check.

ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.181 2014/05/08 16:11:06 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007-2011 Reyk Floeter <reyk@@openbsd.org>
@


1.181
log
@fail for unsupported node action/type combinations.  Also fail for the
unsupported mark/marked combination in a single rule.

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.180 2014/04/22 08:04:23 reyk Exp $	*/
d1255 1
@


1.180
log
@Support the CA key for SSL inspection in the ca process.  Instead of
looking up the keys by relay id, add all keys to a list and look them
up by key id.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.179 2014/04/21 17:33:31 reyk Exp $	*/
d1083 6
d1100 6
d1117 5
d1130 4
d1253 4
@


1.179
log
@Add a few missing free's in the grammar.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.178 2014/04/20 18:16:11 reyk Exp $	*/
d102 1
d128 1
d1328 5
a1332 1
			r->rl_conf.id = ++last_relay_id;
d2857 13
d2891 1
a2891 2
	rb->rl_conf.id = ++last_relay_id;
	if (last_relay_id == INT_MAX) {
@


1.178
log
@Add a few more overflow checks for strlc* functions in parse.y
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.177 2014/04/14 14:39:18 blambert Exp $	*/
d420 1
d474 1
d480 1
d872 1
d1321 1
@


1.177
log
@remove 'restricted' symbol from yacc parser, overlooked in previous
commit

found by andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.176 2014/04/14 12:58:04 blambert Exp $	*/
d481 2
d486 7
a492 2
				strlcpy($3->conf.ifname, $4,
				    sizeof($3->conf.ifname));
d604 6
a609 1
			(void)strlcpy(tb->conf.name, $2, sizeof(tb->conf.name));
d653 6
a658 1
			(void)strlcpy(tb->conf.name, $1, sizeof(tb->conf.name));
d785 7
a791 2
			(void)strlcpy(table->conf.digest, $4.digest,
			    sizeof(table->conf.digest));
d1436 7
a1442 2
				strlcpy(rlay->rl_conf.ifname, $5,
				    sizeof(rlay->rl_conf.ifname));
d2794 5
a2798 1
	(void)strlcpy(tb->conf.name, pname, sizeof(tb->conf.name));
d2953 2
a2954 1
	strlcpy(ifgr.ifgr_name, ifname, IFNAMSIZ);
@


1.176
log
@Adapt relayd to use AgentX protocol to send traps

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.175 2014/01/22 00:21:16 henning Exp $	*/
d167 1
a167 1
%type	<v.number>	http_type loglevel mark restricted trap
@


1.175
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.173 2013/11/25 13:00:07 benno Exp $	*/
d59 1
d160 1
a160 1
%token	RETURN ROUNDROBIN ROUTE SACK SCRIPT SEND SESSION SOCKET SPLICE
d166 2
a167 2
%type	<v.string>	hostname interface table
%type	<v.number>	http_type loglevel mark
d373 1
a373 1
		| SEND TRAP		{
d376 9
a384 1
			conf->sc_flags |= F_TRAP;
d388 3
d1812 3
d1927 1
@


1.174
log
@fix a a double free caused by a config with two listen on statements
in a relay (the first one with ssl).
found and fixed by Erik Lax <erik AT halon DOT se>
ok phessler
@
text
@d2195 2
a2196 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
@


1.173
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.172 2013/09/09 17:57:44 reyk Exp $	*/
d2812 6
@


1.172
log
@Add support for ECDHE (Elliptic curve Diffie-Hellman) to enable
TLS/SSL Perfect Forward Secrecy (PFS).

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.171 2013/05/30 20:17:12 reyk Exp $	*/
d1944 1
a1944 1
char	*parsebuf;
d1946 1
a1946 1
char	 pushback_buffer[MAXPUSHBACK];
d2039 2
a2040 2
	char	 buf[8096];
	char	*p, *val;
d2063 1
a2063 1
				*p++ = (char)c;
d2108 1
a2108 1
			*p++ = (char)c;
@


1.171
log
@Support SSL inspection, the ability to transparently filter in SSL/TLS
connections (eg. HTTPS) by using a local CA that is accepted by the
clients.  See the "SSL RELAYS" and "EXAMPLES" sections in the
relayd.conf(5) manpage for more details.

ok benno@@, manpage bits jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.170 2013/04/27 16:39:30 benno Exp $	*/
d162 1
a162 1
%token	RANDOM LEASTSTATES SRCHASH KEY CERTIFICATE PASSWORD
d847 1
d974 10
d1847 1
d1852 1
@


1.170
log
@time_t 64bit fixes for relayd and relayctl:
- fix statistics
- set INT_MAX limit on session timeouts
- make sure we dont use to large session timeouts in pf redirects and
  openssl

tested with old and new time_t

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.169 2013/03/04 08:41:32 sthen Exp $	*/
d162 1
a162 1
%token	RANDOM LEASTSTATES SRCHASH
d983 28
d1830 1
d1857 1
d1874 1
@


1.169
log
@sync yyerror() with bgpd; use vlog() to log parser errors so they show in
logs if they occur when reloading. ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.168 2012/10/19 16:49:50 reyk Exp $	*/
d535 5
a539 1
				yyerror("invalid timeout: %d", $3);
d1374 5
a1378 1
				yyerror("invalid timeout: %d", $3);
@


1.168
log
@Support additional scheduling algorithms in the load balancer:
least-states, random, source-hash.  least-states is currently only
supported for redirections and the other ones are currently only
supported by relays.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.167 2012/10/04 20:53:30 reyk Exp $	*/
d54 1
d1764 1
d1768 3
a1770 3
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
d1772 1
@


1.167
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.166 2012/10/03 08:40:40 reyk Exp $	*/
d33 1
d161 1
d489 5
d497 1
d686 2
d697 8
d1456 3
d1818 1
d1839 1
d1858 1
@


1.166
log
@Inherit and pass the relay table flags correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.165 2012/10/03 08:33:31 reyk Exp $	*/
d581 1
a581 1
		} tabledefopts_l 	{
d612 1
a612 1
tablespec	: table 		{
d671 2
a672 1
			table->conf.skip_cnt = ($2 / conf->sc_interval.tv_sec) - 1;
d1217 2
a1218 1
			if (strlcpy(r->rl_conf.name, $2, sizeof(r->rl_conf.name)) >=
d1380 2
a1381 2
				yyerror("relay %s target or redirection already "
				    "specified", rlay->rl_conf.name);
d2811 3
a2813 3
        unsigned int		 len;
        struct ifgroupreq        ifgr;
        struct ifg_req          *ifg;
d2820 4
a2823 4
        memset(&ifgr, 0, sizeof(ifgr));
        strlcpy(ifgr.ifgr_name, ifname, IFNAMSIZ);
        if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1) {
                if (errno == EINVAL || errno == ENOTTY)
d2826 1
a2826 1
        }
d2828 3
a2830 3
        len = ifgr.ifgr_len;
        ifgr.ifgr_groups =
            (struct ifg_req *)calloc(len / sizeof(struct ifg_req),
d2832 8
a2839 8
        if (ifgr.ifgr_groups == NULL)
                err(1, "getifgroups");
        if (ioctl(s, SIOCGIFGROUP, (caddr_t)&ifgr) == -1)
                err(1, "SIOCGIFGROUP");

        ifg = ifgr.ifgr_groups;
        for (; ifg && len >= sizeof(struct ifg_req); ifg++) {
                len -= sizeof(struct ifg_req);
d2844 2
a2845 2
        }
        free(ifgr.ifgr_groups);
@


1.165
log
@Support more than one relay backup table.  Instead of duplicating the
code for main and backup table all over the place, turn the relay
tables into a list attached to the relay.  This improves the code and
allows some other tricks with multiple tables later.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.164 2012/05/29 23:46:50 benno Exp $	*/
d2764 1
@


1.164
log
@do not overwrite the table timeout with the global timeout when a
table timeout is set.
ok sthen@@ giovanni@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.163 2012/05/08 15:10:15 benno Exp $	*/
d111 1
d580 1
d684 1
a684 2
				if (rlay != NULL)
					rlay->rl_conf.dstmode = $2;
a1226 2
			r->rl_conf.dsttable = EMPTY_ID;
			r->rl_conf.dstmode = RELAY_DSTMODE_DEFAULT;
d1228 1
d1234 1
d1252 1
a1252 1
			    rlay->rl_conf.dsttable == EMPTY_ID) {
a1256 5
			if (rlay->rl_backuptable == NULL) {
				rlay->rl_conf.backuptable =
				    conf->sc_empty_table.conf.id;
				rlay->rl_backuptable = &conf->sc_empty_table;
			}
d1414 4
a1417 2
			if (rlay->rl_backuptable) {
				yyerror("only one backup table is allowed");
d1420 9
a1428 10
			if (rlay->rl_dsttable) {
				rlay->rl_backuptable = $1;
				rlay->rl_backuptable->conf.flags |= F_USED;
				rlay->rl_conf.backuptable = $1->conf.id;
			} else {
				rlay->rl_dsttable = $1;
				rlay->rl_dsttable->conf.flags |= F_USED;
				rlay->rl_conf.dsttable = $1->conf.id;
				rlay->rl_conf.dstport = $1->conf.port;
			}
d2211 4
a2214 3
	struct sym	*sym, *next;
	struct table	*nexttb;
	struct host	*h, *ph;
d2267 4
d2722 1
d2731 1
d2757 11
d2775 4
@


1.163
log
@fix "label string" in http protocol. problem found by giovanni.
ok giovanni@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.162 2012/04/15 03:12:30 jsg Exp $	*/
d2683 3
a2685 1
	bcopy(&dsttb->conf.timeout, &tb->conf.timeout, sizeof(struct timeval));
@


1.162
log
@fix some leaks
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.161 2012/01/21 13:40:48 camield Exp $	*/
d870 1
@


1.161
log
@Only start the child processes after all of them reported to have loaded
the config.  Solves a race at startup time where processes can send status
messages about hosts that other processes don't know about yet.
(and have relayd abort with "desynchronized" or "invalid host id")

ok henning pyr deraadt
solves the problem ok from benno todd
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.160 2012/01/20 12:16:41 camield Exp $	*/
d2694 1
@


1.160
log
@Remove global carp demote option.  It is currently broken, but also flawed
by design.

ok henning pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.159 2011/09/21 18:45:40 bluhm Exp $	*/
a2263 3

	if (TAILQ_EMPTY(conf->sc_relays))
		conf->sc_prefork_relay = 0;
@


1.159
log
@During socket splicing the relayd session timeouts could not be
measured exactly in user land.  Use the new idle timeout for socket
splicing in the kernel to make it correct.  Also do splicing with
http if relayd does not check headers.
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.158 2011/05/26 14:48:20 reyk Exp $	*/
a366 18
		}
		| DEMOTE STRING		{
			if (loadcfg)
				break;
			conf->sc_flags |= F_DEMOTE;
			if (strlcpy(conf->sc_demote_group, $2,
			    sizeof(conf->sc_demote_group))
			    >= sizeof(conf->sc_demote_group)) {
				yyerror("yyparse: demote group name too long");
				free($2);
				YYERROR;
			}
			free($2);
			if (carp_demote_init(conf->sc_demote_group, 1) == -1) {
				yyerror("yyparse: error initializing group %s",
				    conf->sc_demote_group);
				YYERROR;
			}
@


1.158
log
@Add additional check to prevent running scripts when not configured.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.157 2011/05/23 10:44:59 reyk Exp $	*/
a835 7
			if (p->type != RELAY_PROTO_TCP) {
				/*
				 * Splicing is currently only supported
				 * for plain TCP relays.
				 */
				p->tcpflags |= TCPFLAG_NSPLICE;
			}
@


1.157
log
@Support interface groups in address specifications for tables or
directives like "listen on egress".

Based on gilles@@' code for smtpd and an idea from Mikolaj Kucharski.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.156 2011/05/19 08:56:49 reyk Exp $	*/
d779 1
d2243 2
@


1.156
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.155 2011/05/09 12:08:47 reyk Exp $	*/
d4 2
a5 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@openbsd.org>
d32 1
a32 1
#include <sys/hash.h>
d125 1
a2560 3
	if (if_nametoindex(s) == 0)
		return (0);

d2570 2
a2571 1
		    strcmp(s, p->ifa_name) != 0)
d2805 44
@


1.155
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.154 2011/05/05 12:01:43 reyk Exp $	*/
d31 1
d90 1
d119 1
a328 1
			table->sendbuf_len = 0;
a333 1
			table->sendbuf_len = strlen(table->sendbuf);
d339 2
d346 5
a350 1
		| LOG loglevel		{ conf->sc_opts |= $2; }
d352 2
d357 2
d367 2
d384 5
a388 1
		| SEND TRAP		{ conf->sc_flags |= F_TRAP; }
d399 6
d570 5
a731 1
			table->sendbuf_len = strlen(table->sendbuf);
a746 1
			table->sendbuf_len = strlen(table->sendbuf);
d802 5
d970 4
a973 2
			if (proto->sslca != NULL) {
				yyerror("sslca already specified");
d977 1
a977 1
			proto->sslca = $3;
d1218 5
d1343 1
d1426 1
a1440 1
				purge_table(conf->sc_tables, $1);
d1465 5
d1525 3
a1527 3
			if (router->rt_af == AF_UNSPEC)
				router->rt_af = $2.ss.ss_family;
			else if (router->rt_af != $2.ss.ss_family) {
d1533 4
a1536 2
			if ((router->rt_af == AF_INET && ($4 > 32 || $4 < 0)) ||
			    (router->rt_af == AF_INET6 && ($4 > 128 || $4 < 0))) {
d1698 1
a1698 1
			struct address *a;
d1715 3
a1717 3
			a = TAILQ_FIRST(&al);
			memcpy(&$$.ss, &a->ss, sizeof($$.ss));
			free(a);
d2192 2
a2193 2
struct relayd *
parse_config(const char *filename, int opts)
a2195 2
	struct table	*nexttb;
	struct host	*h, *ph;
d2197 29
a2225 19
	if ((conf = calloc(1, sizeof(*conf))) == NULL ||
	    (conf->sc_tables = calloc(1, sizeof(*conf->sc_tables))) == NULL ||
	    (conf->sc_relays = calloc(1, sizeof(*conf->sc_relays))) == NULL ||
	    (conf->sc_protos = calloc(1, sizeof(*conf->sc_protos))) == NULL ||
	    (conf->sc_routes = calloc(1, sizeof(*conf->sc_routes))) == NULL ||
	    (conf->sc_rts = calloc(1, sizeof(*conf->sc_rts))) == NULL ||
	    (conf->sc_rdrs = calloc(1, sizeof(*conf->sc_rdrs))) == NULL) {
		if (conf != NULL) {
			if (conf->sc_tables != NULL)
				free(conf->sc_tables);
			if (conf->sc_relays != NULL)
				free(conf->sc_relays);
			if (conf->sc_protos != NULL)
				free(conf->sc_protos);
			if (conf->sc_rdrs != NULL)
				free(conf->sc_rdrs);
			if (conf->sc_rts != NULL)
				free(conf->sc_rts);
			free(conf);
a2226 2
		log_warn("%s: cannot allocate memory", __func__);
		return (NULL);
d2229 12
d2251 2
a2252 35
	TAILQ_INIT(conf->sc_rdrs);
	TAILQ_INIT(conf->sc_tables);
	TAILQ_INIT(conf->sc_protos);
	TAILQ_INIT(conf->sc_relays);
	TAILQ_INIT(conf->sc_rts);
	TAILQ_INIT(conf->sc_routes);

	memset(&conf->sc_empty_table, 0, sizeof(conf->sc_empty_table));
	conf->sc_empty_table.conf.id = EMPTY_TABLE;
	conf->sc_empty_table.conf.flags |= F_DISABLE;
	(void)strlcpy(conf->sc_empty_table.conf.name, "empty",
	    sizeof(conf->sc_empty_table.conf.name));

	bzero(&conf->sc_proto_default, sizeof(conf->sc_proto_default));
	conf->sc_proto_default.flags = F_USED;
	conf->sc_proto_default.cache = RELAY_CACHESIZE;
	conf->sc_proto_default.tcpflags = TCPFLAG_DEFAULT;
	conf->sc_proto_default.tcpbacklog = RELAY_BACKLOG;
	conf->sc_proto_default.sslflags = SSLFLAG_DEFAULT;
	(void)strlcpy(conf->sc_proto_default.sslciphers, SSLCIPHERS_DEFAULT,
	    sizeof(conf->sc_proto_default.sslciphers));
	conf->sc_proto_default.type = RELAY_PROTO_TCP;
	(void)strlcpy(conf->sc_proto_default.name, "default",
	    sizeof(conf->sc_proto_default.name));
	RB_INIT(&conf->sc_proto_default.request_tree);
	RB_INIT(&conf->sc_proto_default.response_tree);

	conf->sc_timeout.tv_sec = CHECK_TIMEOUT / 1000;
	conf->sc_timeout.tv_usec = (CHECK_TIMEOUT % 1000) * 1000;
	conf->sc_interval.tv_sec = CHECK_INTERVAL;
	conf->sc_interval.tv_usec = 0;
	conf->sc_prefork_relay = RELAY_NUMPROC;
	conf->sc_statinterval.tv_sec = RELAY_STATINTERVAL;
	conf->sc_opts = opts;
	conf->sc_confpath = filename;
a2253 4
	if ((file = pushfile(filename, 0)) == NULL) {
		free(conf);
		return (NULL);
	}
d2352 1
a2352 6
	if (errors) {
		free(conf);
		return (NULL);
	}

	return (conf);
d2519 1
d2641 1
d2655 11
d2676 1
a2676 2
		purge_table(NULL, tb);
		return (NULL);
d2683 1
a2683 2
		purge_table(NULL, tb);
		return (NULL);
d2690 1
a2690 1
		return (NULL);
d2702 1
a2702 2
		purge_table(NULL, tb);
		return (NULL);
d2719 1
a2719 2
			purge_table(NULL, tb);
			return (NULL);
d2731 4
@


1.154
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.153 2011/05/05 10:20:24 phessler Exp $	*/
d1256 1
@


1.153
log
@Allow a user to specify the route priority

OK reyk@@ claudio@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.152 2011/04/12 12:43:13 reyk Exp $	*/
d2104 1
a2104 1
		log_warn("malloc");
d2108 1
a2108 1
		log_warn("malloc");
d2113 1
a2113 1
		log_warn("%s", nfile->name);
d2172 1
a2172 1
		log_warn("cannot allocate memory");
d2476 1
a2476 1
		log_warnx("host_dns: could not parse \"%s\": %s", s,
d2493 2
a2494 1
				log_warnx("host_dns: interface name truncated");
d2518 1
a2518 1
		log_warnx("host_dns: %s resolves to more than %d hosts",
d2557 2
a2558 1
				log_warnx("host_if: interface name truncated");
d2590 1
a2590 1
		log_warnx("host_if: %s resolves to more than %d hosts",
d2615 2
a2616 1
				log_warnx("host: interface name truncated");
@


1.152
log
@Splicing is currently only supported for TCP relays, not for HTTP or
others (HTTP will need a more complicated splicing mechanism to switch
between headers and bodies in userland and kernel).  Add the "no
splice" flag for non-TCP relays by default to indicate it in the debug
and status output.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.151 2011/04/12 12:37:22 reyk Exp $	*/
d37 1
d149 1
a149 1
%token	NODELAY NOTHING ON PARENT PATH PORT PREFORK PROTO
d1626 11
d1789 1
@


1.151
log
@update flags and printing of flags in debug mode, handle splicing flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.150 2011/04/07 13:22:29 reyk Exp $	*/
d801 7
@


1.150
log
@Add support for divert-to which provides some benefits over rdr-to.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.149 2010/10/26 15:04:37 reyk Exp $	*/
d150 1
a150 1
%token	RETURN ROUNDROBIN ROUTE SACK SCRIPT SEND SESSION SOCKET
d878 2
d1790 1
@


1.149
log
@redirects are loaded as "pass in quick ... rdr-to" pf rules by default. In
some cases it is desired to load the rules as "match in" without "quick"
to allow additional filtering or applying additional rule/state options,
eg. to add an overload table for DOS mitigation.  Add the optional "match"
keyword for the redirect "tag" option to change the pf rule type accordingly.

ok jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.148 2010/10/18 11:51:22 sthen Exp $	*/
d147 1
a147 1
%token	LOADBALANCE LOG LOOKUP MARK MARKED MODE NAT NO
d1216 7
a1222 1
			if ((rlay->rl_conf.flags & F_NATLOOK) == 0 &&
d1382 5
d1730 1
@


1.148
log
@Missing semicolon, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.147 2010/09/02 14:03:22 sobrado Exp $	*/
d152 1
a152 1
%token	TRANSPARENT TRAP UPDATES URL VIRTUAL WITH TTL RTABLE
d159 1
a159 1
%type	<v.number>	redirect_proto relay_proto
d502 1
a502 1
		| TAG STRING {
d504 1
a504 1
			if (strlcpy(rdr->conf.tag, $2,
d508 1
a508 1
				free($2);
d511 3
a513 1
			free($2);
d524 4
d1745 1
@


1.147
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.146 2010/08/07 17:59:02 claudio Exp $	*/
d195 1
@


1.146
log
@Fix carp demotion on tables. For some reason the default values were
inherited from the table definition even though these values could
not be changed there. While there fix a memory leak in a rather strange
case.
OK phessler, jsg, pyr, sthen, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.145 2010/08/03 18:42:41 henning Exp $	*/
d613 1
a613 1
tableopts	: CHECK tablecheck 
d1042 1
a1042 1
		}		
@


1.145
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.144 2010/08/01 22:18:35 sthen Exp $	*/
d2613 2
a2614 1
	if ((oldtb = table_findbyconf(conf, tb)) != NULL)
d2616 1
a2628 3
	tb->conf.skip_cnt = dsttb->conf.skip_cnt;
	strlcpy(tb->conf.demote_group, dsttb->conf.demote_group,
	    sizeof(tb->conf.demote_group));
@


1.144
log
@Allow fallback tables for relays, not just redirections.
Seems reasonable to jsg, ok phessler, no response from reyk or pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.143 2010/02/24 15:44:18 jsg Exp $	*/
d1948 2
a1949 1
				else if (next == '\n')
d1951 1
a1951 1
				else
@


1.143
log
@Sync the list of initialisation steps done for the default
relay protocol with that done for specified relay protocols.

Makes it possible to use SSL for the default relay protocol.

From boudewijn@@indes.com in pr 6316
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.142 2009/08/27 09:26:53 reyk Exp $	*/
d1216 5
d1370 2
a1371 2
			if (rlay->rl_dsttable) {
				yyerror("table already specified");
d1375 10
a1384 5

			rlay->rl_dsttable = $1;
			rlay->rl_dsttable->conf.flags |= F_USED;
			rlay->rl_conf.dsttable = $1->conf.id;
			rlay->rl_conf.dstport = $1->conf.port;
@


1.142
log
@allow to specify interface names as addresses, for example "listen on
em0".  the implementation will lookup the first IPv4 address of an
interface before any other IPv4 and IPv6 addresses.

ok gilles@@ (i got inspired by smtpd)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.141 2009/08/13 13:51:21 reyk Exp $	*/
d2148 5
@


1.141
log
@add new 'router' functionality to dynamically add or remove routes
based on health check results, using the existing table syntax.  this
allows to maintain multiple (uplink) gateways to implement link
balancing or WAN link failover if no routing protocol or other
keepalive method is available.  works fine with or without
net.inet.ip.multipath enabled.

ok pyr@@, jmc@@ for manpages
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.140 2009/08/07 11:10:23 reyk Exp $	*/
d49 1
d112 2
d2407 3
d2462 71
@


1.140
log
@allow to modify the IP TTL value for host checks.  this can be used to
check if the host is only n hops away and not re-routed over a longer
path.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.139 2009/08/07 09:44:38 reyk Exp $	*/
d92 2
d102 1
d148 2
a149 2
%token	SSL STICKYADDR STYLE TABLE TAG TCP TIMEOUT TO
%token	TRANSPARENT TRAP UPDATES URL VIRTUAL WITH TTL
d175 1
d1381 129
d1747 3
d1995 1
a1995 1
	x != ','))
d2099 2
d2111 2
d2121 1
a2121 1
	    last_relay_id = 0;
d2127 1
d2133 2
d2188 4
a2191 2
	if (TAILQ_EMPTY(conf->sc_rdrs) && TAILQ_EMPTY(conf->sc_relays)) {
		log_warnx("no redirections, nothing to do");
@


1.139
log
@add missing line
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.138 2009/08/07 08:45:58 reyk Exp $	*/
d146 1
a146 1
%token	TRANSPARENT TRAP UPDATES URL VIRTUAL WITH
d1452 11
d1629 1
@


1.138
log
@allow to specify host attributes in an arbitrary order (parent, retry) by
making the grammar a bit more flexible.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.137 2009/08/07 08:19:37 reyk Exp $	*/
d1413 1
@


1.137
log
@cosmetic change - move address into an own element
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.136 2009/08/05 13:46:13 reyk Exp $	*/
d96 1
d150 1
a150 1
%type	<v.number>	http_type loglevel mark parent
d1403 2
a1404 2
host		: address retry parent {
			if (($$ = calloc(1, sizeof(*($$)))) == NULL)
d1407 2
a1408 2
			if (strlcpy($$->conf.name, $1.name,
			    sizeof($$->conf.name)) >= sizeof($$->conf.name)) {
d1410 1
a1410 1
				free($$);
d1413 37
a1449 4
			$$->conf.id = 0; /* will be set later */
			$$->conf.retry = $2;
			$$->conf.parentid = $3;
			SLIST_INIT(&$$->children);
d1477 1
a1477 1
retry		: /* nothing */		{ $$ = 0; }
a1480 9
				YYERROR;
			}
		}
		;

parent		: /* nothing */		{ $$ = 0; }
		| PARENT NUMBER		{
			if (($$ = $2) < 0) {
				yyerror("invalid parent value: %d\n", $2);
@


1.136
log
@prevent configuration of relays listening to a single addr:port tuple twice
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.135 2009/08/05 13:37:06 reyk Exp $	*/
d116 6
a121 6
		int64_t		 number;
		char		*string;
		struct host	*host;
		struct timeval	 tv;
		struct table	*table;
		struct portrange port;
d123 7
a129 3
			enum digest_type	 type;
			char			*digest;
		}		 digest;
d155 1
d1402 1
a1402 4
host		: STRING retry parent	{
			struct address *a;
			struct addresslist al;

d1406 3
a1408 4
			TAILQ_INIT(&al);
			if (host($1, &al, 1, NULL, NULL, -1) <= 0) {
				yyerror("invalid host %s", $2);
				free($1);
d1412 10
a1421 3
			a = TAILQ_FIRST(&al);
			memcpy(&$$->conf.ss, &a->ss, sizeof($$->conf.ss));
			free(a);
d1423 2
a1424 2
			if (strlcpy($$->conf.name, $1, sizeof($$->conf.name)) >=
			    sizeof($$->conf.name)) {
d1427 7
a1433 1
				free($$);
d1437 3
a1439 4
			$$->conf.id = 0; /* will be set later */
			$$->conf.retry = $2;
			$$->conf.parentid = $3;
			SLIST_INIT(&$$->children);
@


1.135
log
@support multiple 'listen on' lines in a single relay block
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.134 2009/08/05 12:55:43 reyk Exp $	*/
d2393 2
a2394 1
	if (relay_findbyname(conf, rb->rl_conf.name) != NULL) {
@


1.134
log
@tables don't need pf if running in "l7" relay mode
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.132 2009/04/17 09:37:25 reyk Exp $	*/
d96 1
d111 1
d1163 2
d1189 2
d1216 7
d1234 1
d1237 5
a1241 5
				yyerror("relay %s listener already specified",
				    rlay->rl_conf.name);
				free($3);
				YYERROR;
			}
d1256 2
a1257 2
			bcopy(&h->ss, &rlay->rl_conf.ss, sizeof(rlay->rl_conf.ss));
			rlay->rl_conf.port = h->port.val[0];
d1259 1
a1259 1
				rlay->rl_conf.flags |= F_SSL;
d2002 6
d2365 47
@


1.133
log
@Allow UDP and/or TCP redirections instead of just TCP.

Thanks to Marek Grzybowski for feedback and testing.

ok jmc@@ (manpage bits)
@
text
@a511 1
			conf->sc_flags |= F_NEEDPF;
@


1.132
log
@add "Connection: close" to HTTP check headers to deconfuse HTTP/1.1
servers claiming keepalive sessions.

From Camiel Dobbelaar
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.131 2009/04/02 14:30:51 reyk Exp $	*/
d105 1
a105 1
		    int, struct portrange *, const char *);
d107 1
a107 1
		    int, struct portrange *, const char *);
d144 1
a144 1
%type	<v.number>	direction dstmode flag forwardmode proto_type retry
d146 1
d215 1
a215 1
proto_type	: /* empty */			{ $$ = RELAY_PROTO_TCP; }
d231 16
d470 1
a470 1
		| LISTEN ON STRING port interface {
d472 1
a472 1
				 SRV_MAX_VIRTS, &$4, $5) <= 0) {
d475 1
a475 1
				free($5);
d479 1
a479 1
			free($5);
d481 1
a481 1
				rdr->conf.port = $4.val[0];
d751 1
a751 1
proto		: proto_type PROTO STRING	{
d1236 1
a1236 1
			if (host($3, &al, 1, &$4, NULL) <= 0) {
d1321 1
a1321 1
			if (host($1, &al, 1, &$2, NULL) <= 0) {
d1392 1
a1392 1
			if (host($1, &al, 1, NULL, NULL) <= 0) {
d1965 1
d2181 1
a2181 1
    struct portrange *port, const char *ifname)
d2217 2
d2220 1
d2246 1
a2246 1
    struct portrange *port, const char *ifname)
d2266 2
d2273 1
a2273 1
	return (host_dns(s, al, max, port, ifname));
@


1.131
log
@add support to specify a ca file (eg. /etc/ssl/cert.pem) to verify ssl
server certificates when connecting as an SSL client from relays.  it
works so far, but needs more testing and is currently lacking support
for certificate revocation (like CRL or OCSP).  the file ssl_privsep.c
is extended to implement more code that should be in openssl to allow
loading the ca from chroot...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.130 2009/04/01 15:07:38 reyk Exp $	*/
d208 2
a209 1
			if (asprintf(&$$, "Host: %s\r\n", $2) == -1)
@


1.130
log
@fix an incorrect flag in route mode.

From Padcal Lalonde, closes PR 6114
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.129 2009/04/01 14:56:38 reyk Exp $	*/
d130 1
a130 1
%token	ALL APPEND BACKLOG BACKUP BUFFER CACHE CHANGE CHECK
d139 1
a139 1
%token	TRANSPARENT TRAP UPDATES URL VIRTUAL WITH 
d889 8
d1477 1
@


1.129
log
@Add support for client-side SSL connections from relays.  relayd can
now sit between two SSL connections (Oitm - OpenBSD-in-the-middle),
accept SSL connections and forward to TCP, accept TCP connections and
forward to SSL, and do TCP to TCP of course.

This was tested by some people a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.128 2009/03/31 21:03:49 tobias Exp $	*/
d450 1
a450 1
			$3->conf.flags |= F_USED | $1;
@


1.128
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.127 2008/12/05 16:53:07 reyk Exp $	*/
d143 1
a143 1
%type	<v.number>	http_type loglevel mark optssl parent sslcache
d145 1
d184 4
d581 1
a581 1
tableopts	: CHECK tablecheck
d1225 1
a1225 1
		| forwardmode TO forwardspec interface dstaf	{
d1229 1
a1229 1
				if ($4 == NULL)
d1237 1
a1237 1
				if ($4 != NULL)
d1242 2
a1243 2
			if ($4 != NULL) {
				strlcpy(rlay->rl_conf.ifname, $4,
d1245 5
a1249 1
				free($4);
d1278 1
a1278 13
forwardspec	: tablespec	{
			if (rlay->rl_dsttable) {
				yyerror("table already specified");
				purge_table(conf->sc_tables, $1);
				YYERROR;
			}

			rlay->rl_dsttable = $1;
			rlay->rl_dsttable->conf.flags |= F_USED;
			rlay->rl_conf.dsttable = $1->conf.id;
			rlay->rl_conf.dstport = $1->conf.port;
		}
		| STRING port retry {
d1307 1
a1307 1
		| NAT LOOKUP retry		{
d1311 12
@


1.127
log
@use HTTP/1.1 instead of HTTP/1.0 if a host header is specified.

spotted by phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.126 2008/10/17 13:02:55 henning Exp $	*/
d1810 1
a1810 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d1814 5
d1864 11
@


1.126
log
@bring in the findeol() fix from pfctl. list of affected parsers by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.125 2008/09/29 14:53:35 reyk Exp $	*/
d652 2
a653 1
			    "HEAD %s HTTP/1.0\r\n%s\r\n", $2, $3) == -1)
d668 2
a669 1
			    "GET %s HTTP/1.0\r\n%s\r\n", $2, $3) == -1)
@


1.125
log
@allow to load expect, filter, log, and remove keys from external files
just containing on key per line.  this allows easier use of URL
white/blacklists from external sources.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.124 2008/09/29 12:07:59 reyk Exp $	*/
a1620 1
	pushback_index = 0;
d1624 4
a1627 1
		c = lgetc(0);
@


1.124
log
@sort tokens for better readability
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.123 2008/09/29 09:58:51 reyk Exp $	*/
d100 1
d132 1
a132 1
%token	EXTERNAL FILTER FORWARD FROM HASH HEADER HOST ICMP
d144 1
a144 1
%type	<v.number>	direction dstmode flag forwardmode log proto_type retry
d805 1
a805 3
		| direction protonode log	{
			if ($3)
				node.flags |= PNFLAG_LOG;
d807 4
a810 1
			if (protonode_add($1, proto, &node) == -1) {
d902 1
a902 1
protonode	: nodetype APPEND STRING TO STRING marked	{
d913 1
a913 1
		| nodetype CHANGE STRING TO STRING marked {
d924 1
a924 1
		| nodetype REMOVE STRING marked			{
d932 6
a937 1
		| nodetype EXPECT STRING FROM STRING marked	{
d947 1
a947 1
		| nodetype EXPECT STRING marked			{
d956 7
a962 1
		| nodetype EXPECT digest marked			{
d977 1
a977 1
		| nodetype FILTER STRING FROM STRING marked	{
d987 1
a987 1
		| nodetype FILTER STRING marked			{
d995 8
a1002 2
		}
		| nodetype FILTER digest marked			{
d1017 1
a1017 1
		| nodetype HASH STRING marked			{
d1026 1
a1026 1
		| nodetype LOG STRING marked			{
d1035 7
a1041 1
		| nodetype MARK STRING FROM STRING WITH mark	{
d1051 1
a1051 1
		| nodetype MARK STRING WITH mark		{
d1055 1
a1055 1
			node.mark = $5;
d1062 15
d1081 4
a1408 4
log		: /* empty */		{ $$ = 0; }
		| LOG			{ $$ = 1; }
		;

d1470 1
@


1.123
log
@allow to listen on a port range for redirections.  this fixes
stickyness with web applications that cannot do the clustering on
their own and require stickyness with HTTP to HTTPS migration.  this
is required in many cases; it is a true fact that we cannot always fix
the backend application in the real world.

Tested and requested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.113 2008/05/07 01:49:29 reyk Exp $	*/
d129 10
a138 8
%token	ALL APPEND BACKLOG BACKUP BUFFER CACHE CHANGE CHECK CIPHERS
%token	CODE COOKIE DEMOTE DIGEST DISABLE EXPECT EXTERNAL FILTER FORWARD
%token	FROM HASH HEADER HOST ICMP INCLUDE INTERFACE INTERVAL IP LABEL
%token	LISTEN LOADBALANCE LOG LOOKUP MARK MARKED MODE NAT NO NODELAY NOTHING
%token	ON PATH PORT PREFORK PROTO QUERYSTR REAL REDIRECT RELAY REMOVE TRAP
%token	REQUEST RESPONSE RETRY RETURN ROUNDROBIN SACK SCRIPT SEND SESSION
%token	SOCKET SSL STICKYADDR STYLE TABLE TAG TCP TIMEOUT TO UPDATES URL
%token	VIRTUAL WITH ERROR ROUTE TRANSPARENT PARENT INET INET6
d141 3
a143 3
%type	<v.string>	interface hostname table
%type	<v.number>	http_type loglevel sslcache optssl mark parent
%type	<v.number>	proto_type dstmode retry log flag direction forwardmode
@


1.122
log
@Add dynamic IPv6-to-IPv4 and IPv4-to-IPv6 translation inspired by
faithd(8) by doing a similar mapping of IPv4/6 addresses with
relayd(8) and pf(4) redirections without the need of the faith(4)
interface.  The trick works in both directions, it can accept IPv6
connections and relay them to IPv4 hosts by extracting the last 4
octets from the IPv6 destination (like faithd(8)), and it can accept
IPv4 connections and relay them to IPv6 hosts by prepending the 4
octets of the original IPv4 destination to a configured IPv6 prefix.
An access list is not needed because the classification is done in
pf.conf(5).  It helps to get more faith in relayd.

manpage bits ok jmc@@
yes, sounds good todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.121 2008/07/19 11:38:54 reyk Exp $	*/
d33 1
d104 1
a104 1
		    int, in_port_t, const char *);
d106 1
a106 1
		    int, in_port_t, const char *);
d109 1
d118 1
d140 1
a140 1
%type	<v.number>	port http_type loglevel sslcache optssl mark parent
d142 1
d238 2
a239 1
			struct servent	*servent;
d241 15
a255 3
			servent = getservbyname($2, "tcp");
			if (servent == NULL) {
				yyerror("port %s is invalid", $2);
d259 2
a260 1
			$$ = servent->s_port;
d268 2
a269 1
			$$ = htons($2);
d446 1
a446 1
				 SRV_MAX_VIRTS, $4, $5) <= 0) {
d455 1
a455 1
				rdr->conf.port = $4;
d561 2
d574 7
a580 1
		| port			{ table->conf.port = $1; }
d1147 6
d1157 1
a1157 1
			if (host($3, &al, 1, $4, NULL) <= 0) {
d1165 1
a1165 1
			rlay->rl_conf.port = h->port;
d1170 1
a1170 1
			tableport = h->port;
d1243 5
d1250 1
a1250 1
			if (host($1, &al, 1, $2, NULL) <= 0) {
d1259 1
a1259 1
			rlay->rl_conf.dstport = h->port;
d1309 1
a1309 1
			if (host($1, &al, 1, 0, NULL) <= 0) {
d2082 1
a2082 1
	 in_port_t port, const char *ifname)
d2109 2
a2110 1
		h->port = port;
d2144 1
a2144 1
    in_port_t port, const char *ifname)
d2155 2
a2156 1
		h->port = port;
d2242 22
@


1.121
log
@no need for using a TAILQ queue for the host children list, use a
singly-linked SLIST instead.  the only noticeable change is the
reversed order to notify the children but it does not really matter
here.  also only walk through the children host list if the host
itself is a potential parent.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.120 2008/07/19 10:52:32 reyk Exp $	*/
d133 1
a133 1
%token	VIRTUAL WITH ERROR ROUTE TRANSPARENT PARENT
d1139 1
a1139 1
		| forwardmode TO forwardspec interface		{
d1237 22
d1398 2
@


1.120
log
@If the new 'parent' keyword is specified for a host in a table,
inherit the state from another host with the specified Id; no
additional check will be for the inheriting host.  This helps in
scenarios with lots of IP aliases that all point to the same service
on the same host (like web hosting with many SSL domains).

discussed with pyr, tested in different setups
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.119 2008/07/17 16:41:06 reyk Exp $	*/
d1270 1
a1270 1
			TAILQ_INIT(&$$->children);
d1863 1
a1863 1
					TAILQ_INSERT_TAIL(&ph->children,
d2170 1
a2170 1
		TAILQ_INIT(&h->children);
@


1.119
log
@final reorder diff to use TAILQ_INSERT_TAIL instead of
TAILQ_INSERT_HEAD.  now tables and relays are also matching the order
in the config file.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.118 2008/07/17 16:28:07 reyk Exp $	*/
d133 1
a133 1
%token	VIRTUAL WITH ERROR ROUTE TRANSPARENT
d137 1
a137 1
%type	<v.number>	port http_type loglevel sslcache optssl mark
d1241 1
a1241 1
host		: STRING retry		{
d1269 2
d1283 9
d1392 1
d1744 1
a1744 1
	struct host	*h;
d1848 20
d2170 1
@


1.118
log
@add the hosts in order to get host ids that match the order in the config file. ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.117 2008/07/17 16:12:04 reyk Exp $	*/
d372 1
a372 1
			TAILQ_INSERT_HEAD(conf->sc_rdrs, rdr, entry);
d745 1
a745 1
			TAILQ_INSERT_HEAD(conf->sc_protos, proto, entry);
d1103 1
a1103 1
			TAILQ_INSERT_HEAD(conf->sc_relays, rlay, rl_entry);
d2142 1
a2142 1
	TAILQ_INSERT_HEAD(conf->sc_tables, tb, entry);
@


1.117
log
@give sane ids to hosts, tables, redirections, relays, etc. - start
counting at 1 and do not assign an id before inheriting a real table.
makes more sense in the relayctl output.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.116 2008/07/17 15:10:15 reyk Exp $	*/
d498 1
d507 1
a507 1
			TAILQ_INSERT_HEAD(conf->sc_tables, table, entry);
d526 1
a526 1
			TAILQ_INSERT_HEAD(&table->hosts, $1, entry);
d2124 1
a2124 1
	bzero(&tb->hosts, sizeof(tb->hosts));
d2138 1
a2138 1
		TAILQ_INSERT_HEAD(&tb->hosts, h, entry);
@


1.116
log
@use getaddrinfo/getnameinfo to parse ipv6 addresses instead of
inet_pton/inet_ntop to allow specifing and printing the IPv6 scope
identifier. synced host_v6() with ntpd's version to use getaddrinfo()
instead of inet_pton() - host_v4, host_v6, and host_dns could all use
getaddrinfo in a single function by specifing different flags but this
would diverge from the other daemons using this common interface so we
keep this little overhead.

discussed with henning@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.115 2008/06/11 18:21:19 reyk Exp $	*/
d339 1
a339 1
			srv->conf.id = last_rdr_id++;
d495 1
a495 1
			tb->conf.id = last_table_id++;
a497 5
			if (last_table_id == INT_MAX) {
				yyerror("too many tables defined");
				free(tb);
				YYERROR;
			}
d720 1
a720 1
			p->id = last_proto_id++;
d1065 1
a1065 1
			r->rl_conf.id = last_relay_id++;
d1266 1
a1266 1
			$$->conf.id = last_host_id++;
a1267 5
			if (last_host_id == INT_MAX) {
				yyerror("too many hosts defined");
				free($$);
				YYERROR;
			}
d2108 1
a2108 1
	tb->conf.id = last_table_id++;
d2129 1
a2129 1
		h->conf.id = last_host_id++;
@


1.115
log
@add support for "transparent" forwarding in relays: normally the l7
relay will connect to the target host with its own ip address, but
this mode will let it use the address of the client that is connecting
from the other side. for example, there is no need to add the
X-Forwarded-For HTTP headers for internal webservers in this mode
anymore since they magically see the remote client ip address in the
connection. it also allows to build fully-transparent ssl
encapsulation for tcp sessions and many other things...

based on an initial idea from dlg@@ and pascoe@@ (dlg's talk at opencon)
using the new BINDANY and divert-reply interfaces from markus@@ (since n2k8)

ok markus@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.114 2008/05/08 02:15:34 reyk Exp $	*/
d1969 19
a1987 3
	struct in6_addr		 ina6;
	struct sockaddr_in6	*sin6;
	struct address		*h;
d1989 2
a1990 10
	bzero(&ina6, sizeof(ina6));
	if (inet_pton(AF_INET6, s, &ina6) != 1)
		return (NULL);

	if ((h = calloc(1, sizeof(*h))) == NULL)
		fatal(NULL);
	sin6 = (struct sockaddr_in6 *)&h->ss;
	sin6->sin6_len = sizeof(struct sockaddr_in6);
	sin6->sin6_family = AF_INET6;
	memcpy(&sin6->sin6_addr, &ina6, sizeof(ina6));
@


1.114
log
@missed to set the default for tables to round-robin, so it was
loadbalance after the grammar change. make it round-robin again.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.113 2008/05/07 01:49:29 reyk Exp $	*/
d133 1
a133 1
%token	VIRTUAL WITH ERROR ROUTE
d383 15
a401 7
				if (($1 & F_ROUTE) == 0) {
					yyerror("superfluous interface");
					YYERROR;
				}
			} else if ($1 & F_ROUTE) {
				yyerror("missing interface to route to");
				YYERROR;
d421 1
d461 3
a463 2
forwardmode	: FORWARD		{ $$ = 0; }
		| ROUTE			{ $$ = F_ROUTE; }
d1143 23
a1165 1
		| FORWARD TO forwardspec
d1418 1
@


1.113
log
@add an alternative "route to" mode to relayd redirections which maps
to pf route-to instead of the default rdr. it is a first steps towards
support for "direct server return" (dsr), an asynchronous mode where
the load balanced servers send the replies to a different gateway like
a l3 switch/router to handle higher amounts of return traffic.
because the state handling in pf isn't optimal for this case yet, it
just sees half of the TCP connection, the sessions are forced to time
out after fixed number of seconds.

discussed with many, thought about in the onsen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.112 2008/05/06 12:58:00 reyk Exp $	*/
d1065 1
@


1.112
log
@the manpage mentioned "timeout" in relay sections, while the grammar
expected the keywords "forward timeout".  rename it to "session
timeout" and sync the documentation with reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.111 2008/05/06 06:09:48 pyr Exp $	*/
d133 1
a133 1
%token	VIRTUAL WITH ERROR
d138 1
a138 1
%type	<v.number>	proto_type dstmode retry log flag direction
d340 1
d382 14
a395 1
rdroptsl	: FORWARD TO tablespec		{
d414 1
a414 1
			$3->conf.flags |= F_USED;
d443 6
d452 4
d1371 1
@


1.111
log
@Do not unconditionnaly load pf. If pf isn't required by the configuration
the initialisation isn't done properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.110 2008/03/03 16:47:28 reyk Exp $	*/
d1109 1
a1109 1
		| FORWARD TIMEOUT NUMBER	{
@


1.110
log
@Inherit global table options.

From Armin Wolfermann

ok pyr@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.109 2008/02/27 15:36:42 mpf Exp $	*/
d319 1
d419 1
d433 1
d1172 1
@


1.109
log
@Unbreak parser by initializing topfile correctly.
I got fooled by patch(1). Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.108 2008/02/26 10:09:58 mpf Exp $	*/
d2054 6
@


1.108
log
@Have popfile() also close the main config file,
but only do the final popfile call after yyparse() is done.
This also fixes config reload on SIGHUP for some daemons.

Spotted by otto@@. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.107 2008/02/13 11:32:59 reyk Exp $	*/
d1731 1
a2071 1
	topfile = file;
@


1.107
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.106 2008/02/13 11:02:37 reyk Exp $	*/
d60 1
a60 1
} *file;
d1403 1
a1403 1
			if (popfile() == EOF)
d1421 1
a1421 1
		if (popfile() == EOF)
d1662 1
a1662 1
	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
d1664 7
a1670 8
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
d2071 1
@


1.106
log
@stylistic change: move code to add protonodes from the BNF into
seperate functions in relayd.c (protonode_add/protonode_header).  this
code got to big to look nice in the BNF statements...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.105 2008/02/11 10:53:12 reyk Exp $	*/
d4 1
@


1.105
log
@unbreak the dns protocol handler, closes pr 5717

Thanks to Nigel Taylor
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.104 2008/02/11 10:42:50 reyk Exp $	*/
a741 20
			struct protonode	*pn, *proot, pk;
			struct proto_tree	*tree;

			if ($1 == RELAY_DIR_RESPONSE)
				tree = &proto->response_tree;
			else
				tree = &proto->request_tree;
			if ((pn = calloc(1, sizeof (*pn))) == NULL)
				fatal("out of memory");

			bcopy(&node, pn, sizeof(*pn));
			pn->key = node.key;
			pn->value = node.value;
			pn->type = node.type;
			pn->label = label;
			SIMPLEQ_INIT(&pn->head);
			if ($1 == RELAY_DIR_RESPONSE)
				pn->id = proto->response_nodes++;
			else
				pn->id = proto->request_nodes++;
d743 5
a747 69
				pn->flags |= PNFLAG_LOG;
			if (pn->id == INT_MAX) {
				yyerror("too many protocol nodes defined");
				free(pn);
				YYERROR;
			}
			if ((proot =
			    RB_INSERT(proto_tree, tree, pn)) != NULL) {
				/*
				 * A protocol node with the same key already
				 * exists, append it to a queue behind the
				 * existing node.
				 */
				if (SIMPLEQ_EMPTY(&proot->head))
					SIMPLEQ_NEXT(proot, entry) = pn;
				SIMPLEQ_INSERT_TAIL(&proot->head, pn, entry);
			}

			if (node.type == NODE_TYPE_COOKIE)
				pk.key = "Cookie";
			else if (node.type == NODE_TYPE_URL)
				pk.key = "Host";
			else
				pk.key = "GET";
			if (node.type != NODE_TYPE_HEADER) {
				pk.type = NODE_TYPE_HEADER;
				pn = RB_FIND(proto_tree, tree, &pk);
				if (pn == NULL) {
					if ((pn = (struct protonode *)
					    calloc(1, sizeof(*pn))) == NULL)
						fatal("out of memory");
					pn->key = strdup(pk.key);
					if (pn->key == NULL)
						fatal("out of memory");
					pn->value = NULL;
					pn->action = NODE_ACTION_NONE;
					pn->type = pk.type;
					SIMPLEQ_INIT(&pn->head);
					if ($1 == RELAY_DIR_RESPONSE)
						pn->id =
						    proto->response_nodes++;
					else
						pn->id = proto->request_nodes++;
					if (pn->id == INT_MAX) {
						yyerror("too many protocol "
						    "nodes defined");
						YYERROR;
					}
					RB_INSERT(proto_tree, tree, pn);
				}
				switch (node.type) {
				case NODE_TYPE_QUERY:
					pn->flags |= PNFLAG_LOOKUP_QUERY;
					break;
				case NODE_TYPE_COOKIE:
					pn->flags |= PNFLAG_LOOKUP_COOKIE;
					break;
				case NODE_TYPE_URL:
					if (node.flags &
					    PNFLAG_LOOKUP_URL_DIGEST)
						pn->flags |= node.flags &
						    PNFLAG_LOOKUP_URL_DIGEST;
					else
						pn->flags |=
						    PNFLAG_LOOKUP_DIGEST(0);
					break;
				default:
					break;
				}
a748 1

@


1.104
log
@Marry relayd with snmpd using new "send trap" option: Request to send
a SNMP trap when the state of a host changes.  relayd(8) will try to
(re-)connect to snmpd(8) and request it to send a trap to the
registered trap receivers, see snmpd.conf(5) for more information
about the configuration.

ok pyr@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.103 2008/01/31 09:56:28 reyk Exp $	*/
a689 1
			p->type = RELAY_PROTO_TCP;
@


1.103
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct relay.  knf long line fixes will follow later.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.102 2008/01/31 09:33:39 reyk Exp $	*/
d129 1
a129 1
%token	ON PATH PORT PREFORK PROTO QUERYSTR REAL REDIRECT RELAY REMOVE
d308 1
d1441 1
@


1.102
log
@add prefixes to names of structure elements to make it easier to grep
for code, start with struct relayd.  finally.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.101 2008/01/29 10:30:10 pyr Exp $	*/
d561 1
a561 1
					rlay->conf.dstmode = $2;
d1099 2
a1100 2
			TAILQ_FOREACH(r, conf->sc_relays, entry)
				if (!strcmp(r->conf.name, $2))
d1110 2
a1111 2
			if (strlcpy(r->conf.name, $2, sizeof(r->conf.name)) >=
			    sizeof(r->conf.name)) {
d1117 6
a1122 6
			r->conf.id = last_relay_id++;
			r->conf.timeout.tv_sec = RELAY_TIMEOUT;
			r->proto = NULL;
			r->conf.proto = EMPTY_ID;
			r->conf.dsttable = EMPTY_ID;
			r->conf.dstretry = 0;
d1130 1
a1130 1
			if (rlay->conf.ss.ss_family == AF_UNSPEC) {
d1132 1
a1132 1
				    rlay->conf.name);
d1135 3
a1137 3
			if ((rlay->conf.flags & F_NATLOOK) == 0 &&
			    rlay->conf.dstss.ss_family == AF_UNSPEC &&
			    rlay->conf.dsttable == EMPTY_ID) {
d1139 1
a1139 1
				    "or table", rlay->conf.name);
d1142 3
a1144 3
			if (rlay->conf.proto == EMPTY_ID) {
				rlay->proto = &conf->sc_proto_default;
				rlay->conf.proto = conf->sc_proto_default.id;
d1148 1
a1148 1
				    rlay->conf.name);
d1152 2
a1153 2
			SPLAY_INIT(&rlay->sessions);
			TAILQ_INSERT_HEAD(conf->sc_relays, rlay, entry);
d1167 1
a1167 1
			if (rlay->conf.ss.ss_family != AF_UNSPEC) {
d1169 1
a1169 1
				    rlay->conf.name);
d1181 2
a1182 2
			bcopy(&h->ss, &rlay->conf.ss, sizeof(rlay->conf.ss));
			rlay->conf.port = h->port;
d1184 1
a1184 1
				rlay->conf.flags |= F_SSL;
d1191 1
a1191 1
			if ((rlay->conf.timeout.tv_sec = $3) < 0) {
d1208 2
a1209 2
			rlay->conf.proto = p->id;
			rlay->proto = p;
d1212 1
a1212 1
		| DISABLE		{ rlay->conf.flags |= F_DISABLE; }
d1217 1
a1217 1
			if (rlay->dsttable) {
d1223 4
a1226 4
			rlay->dsttable = $1;
			rlay->dsttable->conf.flags |= F_USED;
			rlay->conf.dsttable = $1->conf.id;
			rlay->conf.dstport = $1->conf.port;
d1232 1
a1232 1
			if (rlay->conf.dstss.ss_family != AF_UNSPEC) {
d1234 1
a1234 1
				    "specified", rlay->conf.name);
d1247 4
a1250 4
			bcopy(&h->ss, &rlay->conf.dstss,
			    sizeof(rlay->conf.dstss));
			rlay->conf.dstport = h->port;
			rlay->conf.dstretry = $3;
d1253 2
a1254 2
			rlay->conf.flags |= F_NATLOOK;
			rlay->conf.dstretry = $3;
@


1.101
log
@Free resources now that we don't always exit after an unsuccessful
parsing of the configuration.
From Igor Zinovik <zinovik at cs.karelia.ru>
ok thib@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.100 2007/12/08 20:36:36 pyr Exp $	*/
d275 1
a275 1
			if ((conf->interval.tv_sec = $2) < 0) {
d280 1
a280 1
		| LOG loglevel		{ conf->opts |= $2; }
d282 1
a282 1
			bcopy(&$2, &conf->timeout, sizeof(struct timeval));
d290 1
a290 1
			conf->prefork_relay = $2;
d293 4
a296 4
			conf->flags |= F_DEMOTE;
			if (strlcpy(conf->demote_group, $2,
			    sizeof(conf->demote_group))
			    >= sizeof(conf->demote_group)) {
d302 1
a302 1
			if (carp_demote_init(conf->demote_group, 1) == -1) {
d304 1
a304 1
				    conf->demote_group);
d317 1
a317 1
			TAILQ_FOREACH(srv, conf->rdrs, entry)
d354 1
a354 1
			conf->rdrcount++;
d357 2
a358 2
				    conf->empty_table.conf.id;
				rdr->backup = &conf->empty_table;
d368 1
a368 1
			TAILQ_INSERT_HEAD(conf->rdrs, rdr, entry);
d381 1
a381 1
				purge_table(conf->tables, $3);
d386 1
a386 1
				purge_table(conf->tables, $3);
d441 1
a441 1
			TAILQ_FOREACH(tb, conf->tables, entry)
d457 1
a457 1
			bcopy(&conf->timeout, &tb->conf.timeout,
d471 2
a472 2
			conf->tablecount++;
			TAILQ_INSERT_HEAD(conf->tables, table, entry);
d541 2
a542 2
			if ($2 < conf->interval.tv_sec ||
			    $2 % conf->interval.tv_sec) {
d547 1
a547 1
			table->conf.skip_cnt = ($2 / conf->interval.tv_sec) - 1;
d571 1
a571 1
			conf->flags |= F_SSL;
d576 1
a576 1
				conf->flags |= F_SSL;
d597 1
a597 1
				conf->flags |= F_SSL;
d617 1
a617 1
				conf->flags |= F_SSL;
d665 1
a665 1
				p = &conf->proto_default;
d667 1
a667 1
				TAILQ_FOREACH(p, conf->protos, entry)
d704 1
a704 1
			conf->protocount++;
d711 1
a711 1
			TAILQ_INSERT_HEAD(conf->protos, proto, entry);
d1099 1
a1099 1
			TAILQ_FOREACH(r, conf->relays, entry)
d1143 2
a1144 2
				rlay->proto = &conf->proto_default;
				rlay->conf.proto = conf->proto_default.id;
d1151 1
a1151 1
			conf->relaycount++;
d1153 1
a1153 1
			TAILQ_INSERT_HEAD(conf->relays, rlay, entry);
d1185 1
a1185 1
				conf->flags |= F_SSL;
d1199 1
a1199 1
			TAILQ_FOREACH(p, conf->protos, entry)
d1219 1
a1219 1
				purge_table(conf->tables, $1);
d1765 4
a1768 4
	    (conf->tables = calloc(1, sizeof(*conf->tables))) == NULL ||
	    (conf->relays = calloc(1, sizeof(*conf->relays))) == NULL ||
	    (conf->protos = calloc(1, sizeof(*conf->protos))) == NULL ||
	    (conf->rdrs = calloc(1, sizeof(*conf->rdrs))) == NULL) {
d1782 28
a1809 28
	TAILQ_INIT(conf->rdrs);
	TAILQ_INIT(conf->tables);
	TAILQ_INIT(conf->protos);
	TAILQ_INIT(conf->relays);

	memset(&conf->empty_table, 0, sizeof(conf->empty_table));
	conf->empty_table.conf.id = EMPTY_TABLE;
	conf->empty_table.conf.flags |= F_DISABLE;
	(void)strlcpy(conf->empty_table.conf.name, "empty",
	    sizeof(conf->empty_table.conf.name));

	bzero(&conf->proto_default, sizeof(conf->proto_default));
	conf->proto_default.flags = F_USED;
	conf->proto_default.cache = RELAY_CACHESIZE;
	conf->proto_default.type = RELAY_PROTO_TCP;
	(void)strlcpy(conf->proto_default.name, "default",
	    sizeof(conf->proto_default.name));
	RB_INIT(&conf->proto_default.request_tree);
	RB_INIT(&conf->proto_default.response_tree);

	conf->timeout.tv_sec = CHECK_TIMEOUT / 1000;
	conf->timeout.tv_usec = (CHECK_TIMEOUT % 1000) * 1000;
	conf->interval.tv_sec = CHECK_INTERVAL;
	conf->interval.tv_usec = 0;
	conf->prefork_relay = RELAY_NUMPROC;
	conf->statinterval.tv_sec = RELAY_STATINTERVAL;
	conf->opts = opts;
	conf->confpath = filename;
d1826 1
a1826 1
		if ((conf->opts & RELAYD_OPT_VERBOSE) && !sym->used)
d1837 1
a1837 1
	if (TAILQ_EMPTY(conf->rdrs) && TAILQ_EMPTY(conf->relays)) {
d1842 2
a1843 2
	if (TAILQ_EMPTY(conf->relays))
		conf->prefork_relay = 0;
d1845 1
a1845 1
	if (timercmp(&conf->timeout, &conf->interval, >=)) {
d1851 1
a1851 1
	for (table = TAILQ_FIRST(conf->tables); table != NULL;
d1855 1
a1855 1
			TAILQ_REMOVE(conf->tables, table, entry);
d1869 1
a1869 1
		if (timercmp(&table->conf.timeout, &conf->interval, >=)) {
d1877 1
a1877 1
	TAILQ_FOREACH(proto, conf->protos, entry) {
d2156 2
a2157 2
	conf->tablecount++;
	TAILQ_INSERT_HEAD(conf->tables, tb, entry);
@


1.100
log
@Rename everything which reffered to services refer to rdr for internals
(for instance: rename struct service to struct rdr), refer to redirects
otherwise (hoststatectl output).
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.99 2007/12/08 17:14:26 reyk Exp $	*/
d332 1
d339 1
d461 1
d682 1
d697 1
d766 1
d1113 1
d1125 1
d2041 1
@


1.99
log
@make the generic handler for TCP-based protocols the default (allows
to use "protocol foo" without defining a type).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.98 2007/12/08 17:07:08 reyk Exp $	*/
d85 1
a85 1
objid_t			 last_service_id = 0;
d91 1
a91 1
static struct service	*service = NULL;
d150 1
a150 1
		| grammar service '\n'
d314 2
a315 2
service		: REDIRECT STRING	{
			struct service *srv;
d317 1
a317 1
			TAILQ_FOREACH(srv, conf->services, entry)
d335 2
a336 2
			srv->conf.id = last_service_id++;
			if (last_service_id == INT_MAX) {
d340 3
a342 3
			service = srv;
		} '{' optnl serviceopts_l '}'	{
			if (service->table == NULL) {
d344 1
a344 1
				    service->conf.name);
d347 1
a347 1
			if (TAILQ_EMPTY(&service->virts)) {
d349 1
a349 1
				    service->conf.name);
d352 3
a354 3
			conf->servicecount++;
			if (service->backup == NULL) {
				service->conf.backup_id =
d356 3
a358 3
				service->backup = &conf->empty_table;
			} else if (service->backup->conf.port !=
			    service->table->conf.port) {
d361 1
a361 1
				    service->conf.name);
d364 3
a366 3
			if (!(service->conf.flags & F_DISABLE))
				service->conf.flags |= F_ADD;
			TAILQ_INSERT_HEAD(conf->services, service, entry);
d368 1
a368 1
			service = NULL;
d372 2
a373 2
serviceopts_l	: serviceopts_l serviceoptsl nl
		| serviceoptsl optnl
d376 1
a376 1
serviceoptsl	: FORWARD TO tablespec		{
d382 1
a382 1
			if (service->backup) {
d387 3
a389 3
			if (service->table) {
				service->backup = $3;
				service->conf.backup_id = $3->conf.id;
d391 2
a392 2
				service->table = $3;
				service->conf.table_id = $3->conf.id;
d394 1
a394 1
			$3->conf.serviceid = service->conf.id;
d398 1
a398 1
			if (host($3, &service->virts,
d407 3
a409 3
			if (service->conf.port == 0)
				service->conf.port = $4;
			tableport = service->conf.port;
d411 2
a412 2
		| DISABLE		{ service->conf.flags |= F_DISABLE; }
		| STICKYADDR		{ service->conf.flags |= F_STICKY; }
d414 3
a416 3
			if (strlcpy(service->conf.tag, $2,
			    sizeof(service->conf.tag)) >=
			    sizeof(service->conf.tag)) {
d550 1
a550 1
				if (service != NULL) {
d1130 1
a1130 1
				yyerror("relay %s has no target, service, "
d1760 1
a1760 1
	    (conf->services = calloc(1, sizeof(*conf->services))) == NULL) {
d1766 1
a1766 1
	last_host_id = last_table_id = last_service_id = last_proto_id =
d1769 1
a1769 1
	service = NULL;
d1774 1
a1774 1
	TAILQ_INIT(conf->services);
d1829 1
a1829 1
	if (TAILQ_EMPTY(conf->services) && TAILQ_EMPTY(conf->relays)) {
@


1.98
log
@some changes to the relayd.conf configuration language and grammar.

the tables will look more like pf tables, it is easier to re-use
tables with different options, "services" will become "redirections"
(they refer to rdr pf rules), sync configuration directives of
redirect (l3, ex-service) relay (l7) sections (for example "virtual
host" will become "listen on"), all target definitions will start with
"forward to", etc. pp. (see relay.conf(5) and etc/relayd.conf)

discussed with pyr and deraadt
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.97 2007/12/07 17:17:00 reyk Exp $	*/
d200 2
a201 1
proto_type	: TCP				{ $$ = RELAY_PROTO_TCP; }
@


1.97
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.96 2007/11/26 09:38:25 reyk Exp $	*/
d97 1
d106 1
a106 1
struct table	*table_inherit(const char *, in_port_t);
d114 1
d125 8
a132 9
%token	SERVICE TABLE BACKUP HOST REAL INCLUDE
%token  CHECK TCP ICMP EXTERNAL REQUEST RESPONSE
%token  TIMEOUT CODE DIGEST PORT TAG INTERFACE STYLE RETURN LABEL
%token	VIRTUAL INTERVAL DISABLE STICKYADDR BACKLOG PATH SCRIPT WITH
%token	SEND EXPECT NOTHING SSL LOADBALANCE ROUNDROBIN CIPHERS COOKIE
%token	RELAY LISTEN ON FORWARD TO NAT LOOKUP PREFORK NO MARK MARKED URL
%token	PROTO SESSION CACHE APPEND CHANGE REMOVE FROM FILTER HASH HEADER
%token	LOG UPDATES ALL DEMOTE NODELAY SACK SOCKET BUFFER QUERYSTR RETRY IP
%token	ERROR
d135 3
a137 3
%type	<v.string>	interface hostname
%type	<v.number>	port http_type loglevel sslcache optssl dstport mark
%type	<v.number>	proto_type dstmode docheck retry log flag direction
d141 1
d151 1
a151 1
		| grammar table '\n'
d313 1
a313 1
service		: SERVICE STRING	{
d320 1
a320 1
				yyerror("service %s defined twice", $2);
d330 1
a330 1
				yyerror("service name truncated");
d336 1
a336 1
				yyerror("too many services defined");
d342 1
a342 1
				yyerror("service %s has no table",
d347 1
a347 1
				yyerror("service %s has no virtual ip",
d358 2
a359 2
				yyerror("service %s uses two different ports "
				    "for its table and backup table",
a362 1

d366 2
d375 4
a378 9
serviceoptsl	: TABLE STRING dstport	{
			struct table	*tb;
			in_port_t	 port;

			port = $3;
			if (port == 0)
				port = service->conf.port;
			if ((tb = table_inherit($2, port)) == NULL) {
				free($2);
a380 11
			free($2);

			service->table = tb;
			service->conf.table_id = tb->conf.id;
			service->table->conf.serviceid = service->conf.id;
			service->table->conf.flags |= F_USED;
		}
		| BACKUP TABLE STRING dstport	{
			struct table	*tb;
			in_port_t	 port;

d382 2
a383 2
				yyerror("backup already specified");
				free($3);
d386 6
a391 7

			port = $4;
			if (port == 0)
				port = service->conf.port;
			if ((tb = table_inherit($3, port)) == NULL) {
				free($3);
				YYERROR;
d393 2
a394 6
			free($3);

			service->backup = tb;
			service->conf.backup_id = tb->conf.id;
			service->backup->conf.serviceid = service->conf.id;
			service->backup->conf.flags |= (F_USED|F_BACKUP);
d396 1
a396 1
		| VIRTUAL HOST STRING port interface {
d408 1
d416 1
a416 1
				yyerror("service tag name truncated");
d425 11
a435 1
table		: TABLE STRING	{
d450 3
a452 5
			if (strlcpy(tb->conf.name, $2, sizeof(tb->conf.name)) >=
			    sizeof(tb->conf.name)) {
				yyerror("table name truncated");
				YYERROR;
			}
a459 1
			free($2);
d461 1
a461 1
		} '{' optnl tableopts_l '}'	{
a466 5
			if (table->conf.check == CHECK_NOCHECK) {
				yyerror("table %s has no check",
				    table->conf.name);
				YYERROR;
			}
d472 10
a481 2
tableopts_l	: tableopts_l tableoptsl nl
		| tableoptsl optnl
d484 1
a484 1
tableoptsl	: host			{
d489 26
d519 25
a543 2
		| CHECK ICMP		{
			table->conf.check = CHECK_ICMP;
d545 15
a559 2
		| CHECK TCP		{
			table->conf.check = CHECK_TCP;
d561 5
a565 1
		| CHECK SSL		{
d570 2
a571 2
		| CHECK http_type STRING hostname CODE NUMBER {
			if ($2) {
d576 3
a578 2
			if ((table->conf.retcode = $6) <= 0) {
				yyerror("invalid HTTP code: %d", $6);
a579 1
				free($4);
d583 1
a583 1
			    "HEAD %s HTTP/1.0\r\n%s\r\n", $3, $4) == -1)
d585 1
a586 1
			free($4);
d591 2
a592 2
		| CHECK http_type STRING hostname digest {
			if ($2) {
d598 1
a598 1
			    "GET %s HTTP/1.0\r\n%s\r\n", $3, $4) == -1)
d600 1
a601 1
			free($4);
d605 1
a605 1
			(void)strlcpy(table->conf.digest, $5.digest,
d607 2
a608 2
			table->conf.digest_type = $5.type;
			free($5.digest);
d610 1
a610 1
		| CHECK SEND sendbuf EXPECT STRING optssl {
d612 1
a612 1
			if ($6) {
d616 1
a616 1
			if (strlcpy(table->conf.exbuf, $5,
d620 1
a620 1
				free($5);
d624 1
a624 1
			free($5);
d626 1
a626 1
		| CHECK SCRIPT STRING {
d628 1
a628 1
			if (strlcpy(table->conf.path, $3,
a631 14
				free($3);
				YYERROR;
			}
			free($3);
		}
		| REAL port {
			table->conf.port = $2;
		}
		| DEMOTE STRING	{
			table->conf.flags |= F_DEMOTE;
			if (strlcpy(table->conf.demote_group, $2,
			    sizeof(table->conf.demote_group))
			    >= sizeof(table->conf.demote_group)) {
				yyerror("yyparse: demote group name too long");
a635 18
			if (carp_demote_init(table->conf.demote_group, 1)
			    == -1) {
				yyerror("yyparse: error initializing group "
				    "'%s'", table->conf.demote_group);
				YYERROR;
			}
		}
		| DISABLE			{
			table->conf.flags |= F_DISABLE;
		}
		| INTERVAL NUMBER		{
			if ($2 < conf->interval.tv_sec ||
			    $2 % conf->interval.tv_sec) {
				yyerror("table interval must be "
				    "divisible by global interval");
				YYERROR;
			}
			table->conf.skip_cnt = ($2 / conf->interval.tv_sec) - 1;
a636 1
		| include
d657 1
a657 1
proto		: PROTO STRING	{
d660 1
a660 1
			if (strcmp($2, "default") == 0) {
d664 1
a664 1
					if (!strcmp(p->name, $2))
d668 2
a669 2
				yyerror("protocol %s defined twice", $2);
				free($2);
d675 1
a675 1
			if (strlcpy(p->name, $2, sizeof(p->name)) >=
d680 1
a680 1
			free($2);
d682 1
d697 1
a697 1
		} '{' optnl protopts_l '}'	{
d709 5
a721 1
		| PROTO proto_type		{ proto->type = $2; }
d1145 2
d1178 8
d1187 2
a1188 3
		| FORWARD TO STRING port retry {
			struct addresslist	 al;
			struct address		*h;
d1190 6
a1195 4
			if (rlay->conf.dstss.ss_family != AF_UNSPEC) {
				yyerror("relay %s target or service already "
				    "specified", rlay->conf.name);
				free($3);
d1198 8
d1207 4
a1210 4
			TAILQ_INIT(&al);
			if (host($3, &al, 1, $4, NULL) <= 0) {
				yyerror("invalid listen ip: %s", $3);
				free($3);
d1213 5
a1217 6
			free($3);
			h = TAILQ_FIRST(&al);
			bcopy(&h->ss, &rlay->conf.dstss,
			    sizeof(rlay->conf.dstss));
			rlay->conf.dstport = h->port;
			rlay->conf.dstretry = $5;
d1219 3
a1221 3
		| SERVICE STRING retry {
			struct service	*svc;
			struct address	*h;
d1224 1
a1224 1
				yyerror("relay %s target or service already "
d1226 1
a1226 1
				free($2);
d1230 4
a1233 4
			if ((svc = service_findbyname(conf, $2)) == NULL) {
				yyerror("relay %s for unknown service %s",
				    rlay->conf.name, $2);
				free($2);
d1236 2
a1237 2
			free($2);
			h = TAILQ_FIRST(&svc->virts);
d1243 1
a1243 37
		| TABLE STRING dstport dstmode docheck {
			struct table	*tb;

			rlay->conf.dstport = $3;
			if (rlay->conf.dstport == 0)
				rlay->conf.dstport = rlay->conf.port;

			if ((tb = table_inherit($2, rlay->conf.dstport)) ==
			    NULL) {
				free($2);
				YYERROR;
			}
			free($2);
			rlay->conf.dsttable = tb->conf.id;
			rlay->dsttable = tb;
			rlay->conf.dstport = tb->conf.port;
			rlay->conf.dstmode = $4;
			rlay->conf.dstcheck = $5;
			rlay->dsttable->conf.flags |= F_USED;
		}
		| PROTO STRING {
			struct protocol *p;

			TAILQ_FOREACH(p, conf->protos, entry)
				if (!strcmp(p->name, $2))
					break;
			if (p == NULL) {
				yyerror("no such protocol: %s", $2);
				free($2);
				YYERROR;
			}
			p->flags |= F_USED;
			rlay->conf.proto = p->id;
			rlay->proto = p;
			free($2);
		}
		| NAT LOOKUP retry	{
a1246 8
		| TIMEOUT NUMBER	{
			if ((rlay->conf.timeout.tv_sec = $2) < 0) {
				yyerror("invalid timeout: %d", $2);
				YYERROR;
			}
		}
		| DISABLE		{ rlay->conf.flags |= F_DISABLE; }
		| include
a1254 4
docheck		: /* empty */		{ $$ = 1; }
		| NO CHECK		{ $$ = 0; }
		;

d1259 1
a1259 5
dstport		: /* empty */		{ $$ = 0; }
		| port			{ $$ = $1; }
		;

host		: HOST STRING retry {
d1267 1
a1267 1
			if (host($2, &al, 1, 0, NULL) <= 0) {
d1269 1
a1269 1
				free($2);
d1277 1
a1277 1
			if (strlcpy($$->conf.name, $2, sizeof($$->conf.name)) >=
d1280 1
a1280 1
				free($2);
d1284 1
a1284 1
			free($2);
d1286 1
a1286 1
			$$->conf.retry = $3;
d1320 1
d1398 1
d1410 1
a1420 1
		{ "service",		SERVICE },
d1656 1
a1656 1
	x != '{' && x != '}' && \
d1829 1
a1829 1
		log_warnx("no services, nothing to do");
d2088 1
a2088 1
table_inherit(const char *name, in_port_t port)
d2092 1
a2092 1
	struct table	*dsttb, *tb;
d2095 3
a2097 2
	if ((dsttb = table_findbyname(conf, name)) == NULL) {
		yyerror("unknown table or template %s", name);
d2101 1
a2101 1
		return (dsttb);
d2103 1
a2103 1
	if (port == 0) {
d2105 1
d2110 4
a2113 7
	snprintf(pname, sizeof(pname), "%s:%u", name, ntohs(port));
	if ((tb = table_findbyname(conf, pname)) != NULL) {
		if (tb->conf.port == 0) {
			yyerror("invalid table");
			return (NULL);
		}
		return (tb);
d2115 3
a2119 12
	if ((tb = calloc(1, sizeof (*tb))) == NULL)
		fatal("out of memory");
	bcopy(dsttb, tb, sizeof(*tb));
	if (strlcpy(tb->conf.name, pname, sizeof(tb->conf.name))
	    >= sizeof(tb->conf.name)) {
		yyerror("table name truncated");
		return (NULL);
	}
	if (dsttb->sendbuf != NULL &&
	    (tb->sendbuf = strdup(dsttb->sendbuf)) == NULL)
		fatal("out of memory");
	tb->conf.port = port;
d2123 1
d2126 1
d2138 1
@


1.96
log
@allow to add labels to protocol actions, they will be printed in http
error pages and can be used to refer to additional information.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.95 2007/11/24 17:07:28 reyk Exp $	*/
d50 1
a50 1
#include "hoststated.h"
d83 1
a83 1
struct hoststated	*conf = NULL;
d307 2
a308 2
loglevel	: UPDATES		{ $$ = HOSTSTATED_OPT_LOGUPDATE; }
		| ALL			{ $$ = HOSTSTATED_OPT_LOGALL; }
d1749 1
a1749 1
struct hoststated *
d1818 1
a1818 1
		if ((conf->opts & HOSTSTATED_OPT_VERBOSE) && !sym->used)
@


1.95
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.94 2007/11/23 09:39:42 reyk Exp $	*/
d96 1
d125 1
a125 1
%token  TIMEOUT CODE DIGEST PORT TAG INTERFACE STYLE RETURN
d693 11
d719 1
d1393 1
@


1.94
log
@re-implement the "mark" action and document it in the manpage:
it is possible to attach a mark to a session based on matching an
entity (header, url, cookie, ...) and add conditional action for this
mark. it works a bit like the tag/tagged keywords in pf, but i decided
to pick a different name to avoid confusion.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.93 2007/11/22 10:09:53 reyk Exp $	*/
d30 2
a32 1
#include <net/if.h>
@


1.93
log
@add (new) "url" protocol action, this can be used to match/filter URL
suffix/prefix expressions like "example.com/index.html?args". a digest
mode allows to match against anonymized SHA1/MD5 digests of
suffix/prefix expressions.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.92 2007/11/21 20:31:03 reyk Exp $	*/
d124 1
a124 1
%token	VIRTUAL INTERVAL DISABLE STICKYADDR BACKLOG PATH SCRIPT
d133 1
a133 1
%type	<v.number>	port http_type loglevel sslcache optssl dstport
d900 1
a900 1
		| nodetype EXPECT STRING FROM STRING mark	{
d910 1
a910 1
		| nodetype EXPECT STRING mark {
d919 1
a919 1
		| nodetype EXPECT digest mark {
d934 1
a934 1
		| nodetype FILTER STRING FROM STRING mark	{
d944 1
a944 1
		| nodetype FILTER STRING mark {
d953 1
a953 1
		| nodetype FILTER digest mark {
d986 19
d1007 2
a1008 2
mark		: /* empty */
		| MARK				{ node.flags |= PNFLAG_MARK; }
d1011 7
a1017 2
marked		: /* empty */
		| MARKED			{ node.flags |= PNFLAG_MARK; }
d1419 2
a1420 1
		{ "virtual",		VIRTUAL }
@


1.92
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.91 2007/11/21 20:24:28 reyk Exp $	*/
d126 1
a126 1
%token	RELAY LISTEN ON FORWARD TO NAT LOOKUP PREFORK NO MARK MARKED
d731 2
d768 9
d919 15
d953 15
d1007 1
d1394 1
@


1.91
log
@extend action grammar with "filter value" and "expect value" as a
short form for "filter * from value" or "expect * from value".
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.90 2007/11/21 20:13:20 reyk Exp $	*/
d963 2
a964 2
				proto->flags |= F_LOOKUP_PATH;
				node.type = NODE_TYPE_PATH;
@


1.90
log
@move digest string handling into an extra function.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.89 2007/11/21 14:12:04 reyk Exp $	*/
d899 9
d915 9
@


1.89
log
@rename the "url" filter action to "query" to use the correct term.
please update your hoststated.conf configurations. also add more
examples to the manpage.

alright pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.88 2007/11/21 13:04:42 reyk Exp $	*/
d111 4
d137 1
d530 1
a530 3
		| CHECK http_type STRING hostname DIGEST STRING {
			size_t	 digest_len;

d544 1
a544 2

			digest_len = strlcpy(table->conf.digest, $6,
d546 2
a547 13
			switch (digest_len) {
			case 40:
				table->conf.digest_type = DIGEST_SHA1;
				break;
			case 32:
				table->conf.digest_type = DIGEST_MD5;
				break;
			default:
				yyerror("invalid http digest");
				free($6);
				YYERROR;
			}
			free($6);
d611 18
d746 1
d881 1
a881 1
		| nodetype REMOVE STRING marked	{
@


1.88
log
@allow the http digest type to be either SHA1 or MD5 determined by the
digest string length; it is compatible to any existing SHA1-only
configurations.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.87 2007/11/20 17:08:44 reyk Exp $	*/
d124 1
a124 1
%token	LOG UPDATES ALL DEMOTE NODELAY SACK SOCKET BUFFER URL RETRY IP
d750 2
a751 2
				case NODE_TYPE_URL:
					pn->flags |= PNFLAG_LOOKUP_URL;
d930 1
a930 1
		| URL				{ node.type = NODE_TYPE_URL; }
d1300 1
a1323 1
		{ "url",		URL },
@


1.87
log
@allow to use the "include" directive in tables, services, relays, and
protocols.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.86 2007/11/20 15:54:55 reyk Exp $	*/
d526 2
d541 12
a552 4
			if (strlcpy(table->conf.digest, $6,
			    sizeof(table->conf.digest)) >=
			    sizeof(table->conf.digest)) {
				yyerror("http digest truncated");
@


1.86
log
@it may be desirable to send a HTTP error page with error code and a
meaningful message if a HTTP/HTTPS relay closes the connection for
some reason. for example, a "403 Forbidden" if the request was
rejected by a filter. this will be enabled with the "return error"
option and is disabled by default, the standard behaviour is to
silently drop the connection; the browser may display an empty page in
this case. the look+feel of the HTTP error page can be customized with
a CSS style sheet, but we do not intend to allow customization of the
error page contents (hoststated is not a webserver!).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.85 2007/11/20 15:44:21 pyr Exp $	*/
d432 1
d607 1
d753 1
d1123 1
@


1.85
log
@Allow overriding the global interval in a table.
Table specific intervals must be multiples of the global interval.
help and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.84 2007/11/19 15:31:36 reyk Exp $	*/
d119 1
a119 1
%token  TIMEOUT CODE DIGEST PORT TAG INTERFACE
d206 16
d668 2
d1257 1
d1292 1
d1302 1
@


1.84
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.83 2007/11/19 15:20:18 reyk Exp $	*/
d580 9
@


1.83
log
@knf (replace some ';;' with a single ';')
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.82 2007/11/19 14:48:19 reyk Exp $	*/
d189 1
a189 1
		;		
d328 1
a328 1
				service->conf.backup_id = 
d644 1
a644 1
			struct protonode 	*pn, *proot, pk;
d681 1
a681 1
			if (node.type == NODE_TYPE_COOKIE)	
d735 1
a735 1
tcpflags	: SACK 			{ proto->tcpflags |= TCPFLAG_SACK; }
d974 1
a974 1
			struct addresslist 	 al;
d999 1
a999 1
			struct addresslist 	 al;
d1321 2
a1322 1
			yyerror("reached end of file while parsing quoted string");
@


1.82
log
@rework the internal handling of protocol actions a little bit:

- allow to use a key for multiple times by appending a queue of
additional matches to the tree node. for example, this allows to
specify multiple "expect" or "filter" actions to white-/black-list
a list of HTTP-headers, URLs, ..

- prevent specifing an HTTP header for multiple times when using the
expect action.

- minor code shuffling
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.80 2007/11/15 17:02:01 pyr Exp $	*/
d842 1
a842 1
			node.value = strdup($3);;
d852 1
a852 1
			node.value = strdup($3);;
@


1.81
log
@always enable "late connect" relay mode if an "expect" or "filter"
action has been specified for the protocol. late connect mode first
reads the complete request (HTTP header) before opening the inbound
connection instead of relaying it line-by-line.
@
text
@d644 1
a644 1
			struct protonode 	*pn, pk;
a650 6
			pn = RB_FIND(proto_tree, tree, &node);
			if (pn != NULL) {
				yyerror("protocol node %s defined twice",
				    node.key);
				YYERROR;
			}
d658 1
d669 11
a679 1
			RB_INSERT(proto_tree, tree, pn);
@


1.80
log
@Do not insert proto_default inside the dynamically alloced protocol queue.
Handle it as a special case in the one place where it actually matters
instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.79 2007/11/14 15:58:04 pyr Exp $	*/
d842 1
d852 1
@


1.79
log
@reset global variables everytime we enter parse_config.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.78 2007/11/14 10:59:01 pyr Exp $	*/
d586 7
a592 3
			TAILQ_FOREACH(p, conf->protos, entry)
				if (!strcmp(p->name, $2))
					break;
a1629 1
	TAILQ_INSERT_TAIL(conf->protos, &conf->proto_default, entry);
@


1.78
log
@make protos dynamic too
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.77 2007/11/12 23:59:41 mpf Exp $	*/
d1598 1
d1601 5
@


1.77
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.76 2007/11/04 18:47:17 claudio Exp $	*/
d586 1
a586 1
			TAILQ_FOREACH(p, &conf->protos, entry)
d626 1
a626 1
			TAILQ_INSERT_HEAD(&conf->protos, proto, entry);
d1058 1
a1058 1
			TAILQ_FOREACH(p, &conf->protos, entry)
d1592 1
d1603 1
a1603 1
	TAILQ_INIT(&conf->protos);
d1620 1
a1620 1
	TAILQ_INSERT_TAIL(&conf->protos, &conf->proto_default, entry);
d1697 1
a1697 1
	TAILQ_FOREACH(proto, &conf->protos, entry) {
@


1.76
log
@Not using all defined protocols is not a hard error. Just print a warning
but start anyway. OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.75 2007/10/22 16:53:30 pyr Exp $	*/
a1326 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d1383 1
a1383 1
	while ((c = lgetc(0)) == ' ')
@


1.75
log
@load certificates text at parse time. then load them in relay processes.
this separation will ease reload a bit more.

ok reyk@@ who spotted a stupid mistake again...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.74 2007/10/22 12:18:15 reyk Exp $	*/
a1706 1
			errors++;
@


1.74
log
@add support for the include directive to the configuration file parser,
based on the existing hostapd/pfctl code.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.73 2007/10/22 08:52:19 reyk Exp $	*/
d946 5
@


1.73
log
@do not check the file secrecy of hoststated.conf, there is no need to
enforce the file ownership and permissions to root:wheel 0400 because
we have nothing to hide.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.72 2007/10/19 17:33:35 pyr Exp $	*/
d117 1
a117 1
%token	SERVICE TABLE BACKUP HOST REAL
d137 1
d148 14
d1223 1
@


1.72
log
@print system error when fopen fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.71 2007/10/19 14:40:51 pyr Exp $	*/
d1617 1
a1617 1
	if ((file = pushfile(filename, 1)) == NULL) {
@


1.71
log
@Do log initialisation correctly, like bgpd does.
This removes the double warn/log_warn madness i introduced yesterday.
This also keeps messages on stderr at startup and when running with -n.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.70 2007/10/19 14:15:14 pyr Exp $	*/
d1536 1
a1536 1
		log_warnx("%s", nfile->name);
@


1.70
log
@Move relays from static TAILQs to allocated ones.
This syncs it with other hoststated entities and will make reload easier.
This is step 1 out of 7 for reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.69 2007/10/19 09:08:05 pyr Exp $	*/
a1511 1
		warn("cannot stat %s", fname);
a1515 1
		warnx("%s: owner not root or current user", fname);
a1519 1
		warnx("%s: group/world readable/writeable", fname);
a1532 1
		warn("malloc");
a1536 1
		warnx("%s", nfile->name);
a1580 1
		warn("cannot allocate memory");
@


1.69
log
@keep log_warn messages to be informed when a failure occurs during a reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.68 2007/10/18 20:52:12 deraadt Exp $	*/
d887 1
a887 1
			TAILQ_FOREACH(r, &conf->relays, entry)
d934 1
a934 1
			TAILQ_INSERT_HEAD(&conf->relays, rlay, entry);
d1583 1
d1596 1
a1596 1
	TAILQ_INIT(&conf->relays);
d1649 1
a1649 1
	if (TAILQ_EMPTY(conf->services) && TAILQ_EMPTY(&conf->relays)) {
d1654 1
a1654 1
	if (TAILQ_EMPTY(&conf->relays))
@


1.68
log
@unbreak tree
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.66 2007/10/18 20:32:38 deraadt Exp $	*/
d1511 1
d1516 1
d1521 1
d1535 1
d1540 1
d1584 1
@


1.67
log
@extra arg to warn slipped through.
@
text
@d887 1
a887 1
			TAILQ_FOREACH(r, conf->relays, entry)
a931 2
			if (relay_load_certfile(rlay) == -1)
				YYERROR;
d934 1
a934 1
			TAILQ_INSERT_HEAD(conf->relays, rlay, entry);
d1578 1
a1578 2
	    (conf->services = calloc(1, sizeof(*conf->services))) == NULL ||
	    (conf->relays = calloc(1, sizeof(*conf->relays))) == NULL) {
a1587 1
	TAILQ_INIT(conf->relays);
d1589 1
d1642 1
a1642 1
	if (TAILQ_EMPTY(conf->services) && TAILQ_EMPTY(conf->relays)) {
d1647 1
a1647 1
	if (TAILQ_EMPTY(conf->relays))
@


1.66
log
@repair file security warnings; ok pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.65 2007/10/16 20:01:23 mpf Exp $	*/
d887 1
a887 1
			TAILQ_FOREACH(r, &conf->relays, entry)
d932 2
d936 1
a936 1
			TAILQ_INSERT_HEAD(&conf->relays, rlay, entry);
d1534 1
a1534 1
		warn("malloc", nfile->name);
d1580 2
a1581 1
	    (conf->services = calloc(1, sizeof(*conf->services))) == NULL) {
d1591 1
a1592 1
	TAILQ_INIT(&conf->relays);
d1645 1
a1645 1
	if (TAILQ_EMPTY(conf->services) && TAILQ_EMPTY(&conf->relays)) {
d1650 1
a1650 1
	if (TAILQ_EMPTY(&conf->relays))
@


1.65
log
@Allow '=' to end a number in all lexers.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.64 2007/10/16 06:06:49 deraadt Exp $	*/
d1511 1
a1511 1
		log_warn("cannot stat %s", fname);
d1515 1
a1515 1
		log_warnx("%s: owner not root or current user", fname);
d1519 1
a1519 1
		log_warnx("%s: group/world readable/writeable", fname);
d1531 2
a1532 1
	    (nfile->name = strdup(name)) == NULL)
d1534 1
d1536 1
a1616 1
		warn("%s", filename);
@


1.64
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.63 2007/10/13 16:35:21 deraadt Exp $	*/
d1440 1
a1440 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.63
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2007/10/11 14:39:17 deraadt Exp $	*/
d1417 1
a1417 1
				if (next == quotec)
d1419 2
@


1.62
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.61 2007/10/09 22:32:52 deraadt Exp $	*/
d28 1
d36 1
d51 19
a69 25
struct hoststated		*conf = NULL;
static FILE			*fin = NULL;
static int			 lineno = 1;
static int			 errors = 0;
const char			*infile;
objid_t				 last_service_id = 0;
objid_t				 last_table_id = 0;
objid_t				 last_host_id = 0;
objid_t				 last_relay_id = 0;
objid_t				 last_proto_id = 0;

static struct service		*service = NULL;
static struct table		*table = NULL;
static struct relay		*rlay = NULL;
static struct protocol		*proto = NULL;
static struct protonode		 node;

int	 yyerror(const char *, ...);
int	 yyparse(void);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(int);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);
d73 1
a73 1
	TAILQ_ENTRY(sym)	 entries;
a78 1

d82 14
d144 1
a144 1
		| grammar error '\n'		{ errors++; }
d1163 1
a1163 1
	va_list	ap;
d1165 1
a1165 1
	errors = 1;
d1167 1
a1167 1
	fprintf(stderr, "%s:%d: ", infile, yylval.lineno);
a1176 1

d1269 1
a1269 1
lgetc(int inquot)
d1271 1
a1271 2
	int	c, next;
	FILE *f = fin;
d1287 7
a1293 2
	if (inquot) {
		c = getc(f);
d1297 2
a1298 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d1303 2
a1304 2
		yylval.lineno = lineno;
		lineno++;
d1309 1
a1309 1
			c = getc(f);
d1311 1
a1311 1
		ungetc(c, f);
d1315 5
d1351 1
a1351 1
			lineno++;
d1365 1
a1365 1
	int	 endc, next, c;
d1373 1
a1373 1
	yylval.lineno = lineno;
d1407 1
a1407 1
		endc = c;
d1409 1
a1409 1
			if ((c = lgetc(1)) == EOF)
d1412 1
a1412 1
				lineno++;
d1415 1
a1415 1
				if ((next = lgetc(1)) == EOF)
d1417 1
a1417 1
				if (next == endc)
d1421 1
a1421 1
			} else if (c == endc) {
d1495 2
a1496 2
		yylval.lineno = lineno;
		lineno++;
d1503 61
d1611 1
a1611 1
	if ((fin = fopen(filename, "r")) == NULL) {
a1615 1
	infile = filename;
d1617 1
d1619 3
a1622 1
	fclose(fin);
d1626 1
a1626 1
		next = TAILQ_NEXT(sym, entries);
d1633 1
a1633 1
			TAILQ_REMOVE(&symhead, sym, entries);
d1699 1
a1699 1
	    sym = TAILQ_NEXT(sym, entries))
d1708 1
a1708 1
			TAILQ_REMOVE(&symhead, sym, entries);
d1728 1
a1728 1
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d1759 1
a1759 1
	TAILQ_FOREACH(sym, &symhead, entries)
@


1.61
log
@use macro argument
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2007/10/05 15:50:56 reyk Exp $	*/
d70 1
a70 1
int	 lgetc(FILE *, int);
d98 1
a98 1
		int32_t		 number;
d1261 1
a1261 1
lgetc(FILE *f, int inquot)
d1264 1
d1332 1
a1332 1
		c = lgetc(fin, 0);
d1353 1
a1353 1
	while ((c = lgetc(fin, 0)) == ' ')
d1358 1
a1358 1
		while ((c = lgetc(fin, 0)) != '\n' && c != EOF)
d1362 1
a1362 1
			if ((c = lgetc(fin, 0)) == EOF)
d1392 1
a1392 1
			if ((c = lgetc(fin, 1)) == EOF)
d1394 6
a1399 2
			if (c == '\\') {
				next = lgetc(fin, 1);
a1407 4
			if (c == '\n') {
				lineno++;
				continue;
			}
d1416 1
a1416 1
			errx(1, "yylex: strdup");
d1430 1
a1430 1
		} while ((c = lgetc(fin, 0)) != EOF && isdigit(c));
d1438 2
a1439 2
			yylval.v.number = (int)strtonum(buf, -INT_MAX,
			    INT_MAX, &errstr);
d1469 1
a1469 2
		} while ((c = lgetc(fin, 0)) != EOF &&
		    (allowed_in_string(c)));
@


1.60
log
@cast to an int
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2007/10/02 21:04:13 pyr Exp $	*/
d1420 1
a1420 1
	(isspace(x) || c == ')' || c ==',' || c == '/' || c == '}')
@


1.59
log
@stop messing with lgetc to please hoststated's check/expect.
instead move some of the logic in yylex and do hoststated specific
translations into hoststated.c
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2007/10/02 07:21:04 pyr Exp $	*/
d195 1
a195 1
			if ($2 <= 0 || $2 >= USHRT_MAX) {
@


1.58
log
@clean up merged code.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2007/10/01 19:12:33 pyr Exp $	*/
d70 1
a70 1
int	 lgetc(FILE *, int *);
d520 1
d1261 1
a1261 1
lgetc(FILE *f, int *keep)
a1264 1
	*keep = 0;
d1279 5
d1286 1
a1286 9
		if (next == 'n') {
			*keep = 1;
			c = '\n';
			break;
		} else if (next == 'r') {
			*keep = 1;
			c = '\r';
			break;
		} else if (next != '\n') {
a1324 1
	int	k;
d1331 2
a1332 2
		c = lgetc(fin, &k);
		if (c == '\n' && k == 0) {
d1347 1
a1347 1
	int	 endc, c;
a1348 1
	int	 keep;
d1352 1
a1352 1
	while ((c = lgetc(fin, &keep)) == ' ')
d1357 2
a1358 4
		do {
			while ((c = lgetc(fin, &keep)) != '\n' && c != EOF)
				; /* nothing */
		} while (keep == 1);
d1361 1
a1361 1
			if ((c = lgetc(fin, &keep)) == EOF)
d1391 1
a1391 1
			if ((c = lgetc(fin, &keep)) == EOF)
d1393 7
a1399 1
			if (c == endc) {
d1403 1
a1403 1
			if (c == '\n' && keep == 0) {
d1429 1
a1429 1
		} while ((c = lgetc(fin, &keep)) != EOF && isdigit(c));
d1468 1
a1468 1
		} while ((c = lgetc(fin, &keep)) != EOF &&
@


1.57
log
@Add NUMBER to hoststated's lexer, very similar to what has gone in
in the other daemons recently. Prompted and based on work by deraadt@@
proofread and ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2007/10/01 12:34:02 pyr Exp $	*/
d851 3
a853 1
nodetype	: HEADER			{ node.type = NODE_TYPE_HEADER; }
d855 3
a857 1
		| COOKIE			{ node.type = NODE_TYPE_COOKIE; }
d1438 2
a1439 1
			yylval.v.number = (int)strtonum(buf, -INT_MAX, INT_MAX, &errstr);
d1441 2
a1442 1
				yyerror("\"%s\" invalid number: %s", buf, errstr);
@


1.56
log
@keep lines < 80.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2007/09/28 13:29:56 pyr Exp $	*/
d98 1
a98 1
		u_int32_t	 number;
d118 1
d120 1
a120 1
%type	<v.number>	number port http_type loglevel sslcache optssl dstport
a137 14
number		: STRING	{
			const char	*estr;

			$$ = strtonum($1, 0, UINT_MAX, &estr);
			if (estr) {
				yyerror("cannot parse number %s : %s",
				    $1, estr);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

a182 1
			const char	*estr;
d185 7
a191 16
			$$ = strtonum($2, 1, USHRT_MAX, &estr);
                        if (estr) {
				if (errno == ERANGE) {
					yyerror("port %s is out of range", $2);
					free($2);
					YYERROR;
				}
				servent = getservbyname($2, "tcp");
				if (servent == NULL) {
					yyerror("port %s is invalid", $2);
					free($2);
					YYERROR;
				}
				$$ = servent->s_port;
			} else
				$$ = htons($$);
d194 7
d224 6
a229 1
main		: INTERVAL number	{ conf->interval.tv_sec = $2; }
d234 1
a234 1
		| PREFORK number	{
d463 1
a463 1
		| CHECK http_type STRING hostname CODE number {
d469 6
a474 1
			table->conf.retcode = $6;
d705 2
a706 2
		| BACKLOG number	{
			if ($2 > RELAY_MAX_SESSIONS) {
d712 1
a712 1
		| SOCKET BUFFER number	{
d714 4
a717 1
			proto->tcpbufsiz = $3;
d719 6
a724 1
		| IP STRING number	{
d860 7
a866 1
sslcache	: number			{ $$ = $1; }
d1041 6
a1046 1
		| TIMEOUT number	{ rlay->conf.timeout.tv_sec = $2; }
d1105 6
a1110 1
		| RETRY number		{ $$ = $2; }
d1113 1
a1113 1
timeout		: number
d1115 4
d1414 34
@


1.55
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2007/09/10 11:59:22 reyk Exp $	*/
d264 1
a264 1
				yyerror("yyparse: error initializing group '%s'",
@


1.54
log
@add support for relaying DNS traffic (with a little bit of packet
header randomization). this adds an infrastructure to support
UDP-based protocols.

ok gilles@@, tested by some
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2007/09/07 07:54:58 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.53
log
@store the table's port as the relay's dstport
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2007/09/05 08:48:42 reyk Exp $	*/
d184 2
@


1.52
log
@store relay sessions in SPLAY trees instead of TAILQ lists. this will
be used for faster lookups of sessions based on different criteria.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2007/09/04 14:15:05 pyr Exp $	*/
d1006 1
@


1.51
log
@Add the ability to specify a host header when using http(s) check methods.
Prodded by me, done by Gille Chehade <veins@@evilkittens.org>

ok reyk, jmc for the manpage bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2007/07/05 09:42:26 thib Exp $	*/
d909 1
a909 1
			TAILQ_INIT(&rlay->sessions);
@


1.50
log
@use a more traditional while() instead of for() for getopt().
sync usage() to the man page.
format string fixes.
complain about failed calloc()'s instead of exiting silently.

ok pry@@,reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2007/05/31 18:58:09 pyr Exp $	*/
d118 1
a118 1
%type	<v.string>	interface
d169 11
d472 1
a472 1
		| CHECK http_type STRING CODE number {
d478 1
a478 1
			table->conf.retcode = $5;
d480 1
a480 1
			    "HEAD %s HTTP/1.0\r\n\r\n", $3) == -1)
d483 1
d488 1
a488 1
		| CHECK http_type STRING DIGEST STRING {
d495 1
a495 1
			    "GET %s HTTP/1.0\r\n\r\n", $3) == -1)
d498 1
d502 1
a502 1
			if (strlcpy(table->conf.digest, $5,
d506 1
a506 1
				free($5);
d509 1
a509 1
			free($5);
@


1.49
log
@do not forget to store table and backup table ids in the service
configuration struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2007/05/31 18:20:03 pyr Exp $	*/
d161 1
a161 1
				yyerror("invalid check type: $1", $1);
d174 1
a174 1
				yyerror("invalid protocol type: $1", $1);
d399 1
a399 1
				yyerror("table %s defined twice");
d1418 2
a1419 1
	    (conf->services = calloc(1, sizeof(*conf->services))) == NULL)
d1421 1
@


1.48
log
@make sure object ids are reset before parsing the configuration file
again.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2007/05/31 03:24:05 pyr Exp $	*/
d337 1
d361 1
@


1.47
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2007/05/29 18:59:54 pyr Exp $	*/
d1418 3
@


1.46
log
@do not start relay processes when no L7 load balancing is needed.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2007/05/29 17:12:04 reyk Exp $	*/
d265 1
a265 1
			TAILQ_FOREACH(srv, &conf->services, entry)
d315 1
a315 1
			TAILQ_INSERT_HEAD(&conf->services, service, entry);
d393 1
a393 1
			TAILQ_FOREACH(tb, &conf->tables, entry)
d431 1
a431 1
			TAILQ_INSERT_HEAD(&conf->tables, table, entry);
d1414 3
a1416 1
	if ((conf = calloc(1, sizeof(*conf))) == NULL)
d1419 2
a1420 2
	TAILQ_INIT(&conf->services);
	TAILQ_INIT(&conf->tables);
d1474 1
a1474 1
	if (TAILQ_EMPTY(&conf->services) && TAILQ_EMPTY(&conf->relays)) {
d1488 1
a1488 1
	for (table = TAILQ_FIRST(&conf->tables); table != NULL;
d1492 1
a1492 1
			TAILQ_REMOVE(&conf->tables, table, entry);
d1801 1
a1801 1
	TAILQ_INSERT_HEAD(&conf->tables, tb, entry);
@


1.45
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2007/05/29 00:48:04 pyr Exp $	*/
d1476 3
@


1.44
log
@move the ssl cipher suite string to a (small) static charbuf,
this will make it easier to send the struct over the socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2007/05/29 00:21:10 pyr Exp $	*/
d111 1
a111 1
%token	VIRTUAL INTERVAL DISABLE STICKYADDR BACKLOG PATH
d511 11
d1181 1
@


1.43
log
@move struct relay to the runtime + config scheme.
this time around, include hoststatectl changes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2007/05/28 17:37:16 pyr Exp $	*/
a560 1
			p->sslciphers = NULL;
d562 2
d716 7
a722 3
			proto->sslciphers = strdup($2);
			if (proto->sslciphers == NULL)
				fatal("out of memory");
@


1.42
log
@store the configuration file's path, this will be useful when reloading.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2007/05/27 20:53:10 pyr Exp $	*/
d833 1
a833 1
				if (!strcmp(r->name, $2))
d843 2
a844 2
			if (strlcpy(r->name, $2, sizeof(r->name)) >=
			    sizeof(r->name)) {
d849 2
a850 2
			r->id = last_relay_id++;
			r->timeout.tv_sec = RELAY_TIMEOUT;
d852 3
a854 2
			r->dsttable = NULL;
			r->dstretry = 0;
d861 1
a861 1
			if (rlay->ss.ss_family == AF_UNSPEC) {
d863 1
a863 1
				    rlay->name);
d866 3
a868 3
			if ((rlay->flags & F_NATLOOK) == 0 &&
			    rlay->dstss.ss_family == AF_UNSPEC &&
			    rlay->dsttable == NULL) {
d870 1
a870 1
				    "or table", rlay->name);
d873 1
a873 1
			if (rlay->proto == NULL)
d875 2
d891 1
a891 1
			if (rlay->ss.ss_family != AF_UNSPEC) {
d893 1
a893 1
				    rlay->name);
d905 2
a906 2
			bcopy(&h->ss, &rlay->ss, sizeof(rlay->ss));
			rlay->port = h->port;
d908 1
a908 1
				rlay->flags |= F_SSL;
d916 1
a916 1
			if (rlay->dstss.ss_family != AF_UNSPEC) {
d918 1
a918 1
				    "specified", rlay->name);
d931 4
a934 3
			bcopy(&h->ss, &rlay->dstss, sizeof(rlay->dstss));
			rlay->dstport = h->port;
			rlay->dstretry = $5;
d940 1
a940 1
			if (rlay->dstss.ss_family != AF_UNSPEC) {
d942 1
a942 1
				    "specified", rlay->name);
d949 1
a949 1
				    rlay->name, $2);
d955 4
a958 3
			bcopy(&h->ss, &rlay->dstss, sizeof(rlay->dstss));
			rlay->dstport = h->port;
			rlay->dstretry = $3;
d963 3
a965 3
			rlay->dstport = $3;
			if (rlay->dstport == 0)
				rlay->dstport = rlay->port;
d967 2
a968 1
			if ((tb = table_inherit($2, rlay->dstport)) == NULL) {
d973 1
d975 2
a976 2
			rlay->dstmode = $4;
			rlay->dstcheck = $5;
d991 1
d996 2
a997 2
			rlay->flags |= F_NATLOOK;
			rlay->dstretry = $3;
d999 2
a1000 2
		| TIMEOUT number		{ rlay->timeout.tv_sec = $2; }
		| DISABLE			{ rlay->flags |= F_DISABLE; }
@


1.41
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2007/05/27 19:21:15 reyk Exp $	*/
d1420 1
@


1.40
log
@allow to specify table templates in the configuration file and to
inherit them from multiple services or relays. this is useful if you
want to use a table with the same list of hosts but different ports as
specified in the relay or service section.

this makes mcbride more happy
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2007/05/26 19:58:49 pyr Exp $	*/
d216 1
d222 1
d266 1
a266 1
				if (!strcmp(srv->name, $2))
d276 3
a278 2
			if (strlcpy(srv->name, $2, sizeof(srv->name)) >=
			    sizeof(srv->name)) {
d283 1
a283 1
			srv->id = last_service_id++;
d292 1
a292 1
				    service->name);
d297 1
a297 1
				    service->name);
d301 3
a303 1
			if (service->backup == NULL)
d305 2
a306 2
			else if (service->backup->port !=
			    service->table->port) {
d309 1
a309 1
				    service->name);
d313 2
a314 2
			if (!(service->flags & F_DISABLE))
				service->flags |= F_ADD;
d329 1
a329 1
				port = service->port;
d337 2
a338 2
			service->table->serviceid = service->id;
			service->table->flags |= F_USED;
d352 1
a352 1
				port = service->port;
d360 2
a361 2
			service->backup->serviceid = service->id;
			service->backup->flags |= (F_USED|F_BACKUP);
d373 2
a374 2
			if (service->port == 0)
				service->port = $4;
d376 2
a377 2
		| DISABLE			{ service->flags |= F_DISABLE; }
		| STICKYADDR			{ service->flags |= F_STICKY; }
d379 3
a381 2
			if (strlcpy(service->tag, $2, sizeof(service->tag)) >=
			    sizeof(service->tag)) {
d394 1
a394 1
				if (!strcmp(tb->name, $2))
d405 2
a406 2
			if (strlcpy(tb->name, $2, sizeof(tb->name)) >=
			    sizeof(tb->name)) {
d410 2
a411 2
			tb->id = last_table_id++;
			bcopy(&conf->timeout, &tb->timeout,
d421 2
a422 1
				yyerror("table %s has no hosts", table->name);
d425 3
a427 2
			if (table->check == CHECK_NOCHECK) {
				yyerror("table %s has no check", table->name);
d440 2
a441 2
			$1->tableid = table->id;
			$1->tablename = table->name;
d445 2
a446 1
			bcopy(&$2, &table->timeout, sizeof(struct timeval));
d449 1
a449 1
			table->check = CHECK_ICMP;
d452 1
a452 1
			table->check = CHECK_TCP;
d455 1
a455 1
			table->check = CHECK_TCP;
d457 1
a457 1
			table->flags |= F_SSL;
d462 1
a462 1
				table->flags |= F_SSL;
d464 2
a465 2
			table->check = CHECK_HTTP_CODE;
			table->retcode = $5;
d472 1
d477 1
a477 1
				table->flags |= F_SSL;
d479 1
a479 1
			table->check = CHECK_HTTP_DIGEST;
d486 4
a489 2
			if (strlcpy(table->digest, $5,
			    sizeof(table->digest)) >= sizeof(table->digest)) {
d497 1
a497 1
			table->check = CHECK_SEND_EXPECT;
d500 1
a500 1
				table->flags |= F_SSL;
d502 3
a504 2
			if (strlcpy(table->exbuf, $5, sizeof(table->exbuf))
			    >= sizeof(table->exbuf)) {
d512 1
a512 1
			table->port = $2;
d515 4
a518 4
			table->flags |= F_DEMOTE;
			if (strlcpy(table->demote_group, $2,
			    sizeof(table->demote_group))
			    >= sizeof(table->demote_group)) {
d524 2
a525 1
			if (carp_demote_init(table->demote_group, 1) == -1) {
d527 1
a527 1
				    "'%s'", table->demote_group);
d531 3
a533 1
		| DISABLE			{ table->flags |= F_DISABLE; }
d970 1
a970 1
			rlay->dsttable->flags |= F_USED;
d1028 1
a1028 1
			memcpy(&$$->ss, &a->ss, sizeof($$->ss));
d1031 2
a1032 2
			if (strlcpy($$->name, $2, sizeof($$->name)) >=
			    sizeof($$->name)) {
d1039 2
a1040 2
			$$->id = last_host_id++;
			$$->retry = $3;
d1398 4
a1401 4
	conf->empty_table.id = EMPTY_TABLE;
	conf->empty_table.flags |= F_DISABLE;
	(void)strlcpy(conf->empty_table.name, "empty",
	    sizeof(conf->empty_table.name));
d1460 1
a1460 1
		if (table->port == 0) {
d1471 2
a1472 2
		if (!(table->flags & F_USED)) {
			log_warnx("unused table: %s", table->name);
d1475 1
a1475 1
		if (timercmp(&table->timeout, &conf->interval, >=)) {
d1477 1
a1477 1
			    table->name);
d1715 1
a1715 1
	if (dsttb->port != 0)
d1726 1
a1726 1
		if (tb->port == 0) {
d1737 2
a1738 1
	if (strlcpy(tb->name, pname, sizeof(tb->name)) >= sizeof(tb->name)) {
d1745 2
a1746 2
	tb->port = port;
	tb->id = last_table_id++;
d1759 1
a1759 1
		h->id = last_host_id++;
d1764 2
a1765 2
		h->tableid = tb->id;
		h->tablename = tb->name;
@


1.39
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2007/04/12 14:45:45 reyk Exp $	*/
d94 2
d119 1
a119 1
%type	<v.number>	number port http_type loglevel sslcache optssl
d318 8
a325 8
serviceoptsl	: TABLE STRING	{
			struct table *tb;

			TAILQ_FOREACH(tb, &conf->tables, entry)
				if (!strcmp(tb->name, $2))
					break;
			if (tb == NULL) {
				yyerror("no such table: %s", $2);
a327 5
			} else {
				service->table = tb;
				service->table->serviceid = service->id;
				service->table->flags |= F_USED;
				free($2);
d329 9
a337 3
		}
		| BACKUP TABLE STRING	{
			struct table *tb;
d345 4
a348 6
			TAILQ_FOREACH(tb, &conf->tables, entry)
				if (!strcmp(tb->name, $3))
					break;

			if (tb == NULL) {
				yyerror("no such table: %s", $3);
a350 5
			} else {
				service->backup = tb;
				service->backup->serviceid = service->id;
				service->backup->flags |= (F_USED|F_BACKUP);
				free($3);
d352 5
d368 2
a413 4
			if (table->port == 0) {
				yyerror("table %s has no port", table->name);
				YYERROR;
			}
d939 6
a944 2
		| TABLE STRING dstmode docheck {
			struct table	*dsttable;
d946 1
a946 3
			if ((dsttable = table_findbyname(conf, $2)) == NULL) {
				yyerror("relay %d for unknown table %s",
				    rlay->name, $2);
d951 3
a953 3
			rlay->dsttable = dsttable;
			rlay->dstmode = $3;
			rlay->dstcheck = $4;
d993 4
d1370 2
d1441 14
a1454 1
	TAILQ_FOREACH(table, &conf->tables, entry) {
d1685 71
@


1.38
log
@add a new relay 'path' action to filter the URL path and arguments.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2007/03/21 00:08:08 reyk Exp $	*/
d1361 2
a1362 2
int
parse_config(struct hoststated *x_conf, const char *filename, int opts)
d1366 2
a1367 1
	conf = x_conf;
d1400 2
a1401 1
		return (0);
d1455 2
a1456 2
		bzero(&conf, sizeof (*conf));
		return (-1);
d1459 1
a1459 1
	return (0);
@


1.37
log
@in addition to the host retry option in tables, add support for the
optional connection "retry" to the forward to, service, and nat lookup
options. for example, "nat lookup retry 3" is useful when running
hoststated as a transparent proxy when connecting to unreliable
frontend/backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2007/03/13 12:04:52 reyk Exp $	*/
d109 1
a109 1
%token	VIRTUAL INTERVAL DISABLE STICKYADDR BACKLOG
d804 4
d1124 1
@


1.36
log
@allow to specify the IP_TTL and IP_MINTTL options for the relays to
support the Generalized TTL Security Mechanism (GTSM) according to RFC
3682. this is especially useful with inbound connections and a fixed
distance to the backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2007/03/07 17:40:32 reyk Exp $	*/
d834 1
d890 1
a890 1
		| FORWARD TO STRING port {
d911 1
d913 1
a913 1
		| SERVICE STRING {
d934 1
d966 4
a969 1
		| NAT LOOKUP			{ rlay->flags |= F_NATLOOK; }
@


1.35
log
@- fix the hoststatectl host disable/enable commands to work with relay
layer 7 loadbalancing.
- allow to run relays with tables without depending on services
- show hosts and tables assigned to relays in hoststatectl show commands

ok pyr@@ deraadt@@ with some input from mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2007/03/06 19:26:46 reyk Exp $	*/
d113 1
a113 1
%token	LOG UPDATES ALL DEMOTE NODELAY SACK SOCKET BUFFER URL RETRY
d678 14
d1102 1
@


1.34
log
@add support for handling simple HTTP cookies (no per-path/domain
cookies yet), for example: cookie hash "JSESSIONID"

tested by some people
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2007/02/27 13:38:58 reyk Exp $	*/
d932 1
@


1.33
log
@in addition to actions on request headers, allow to define relay
actions on response headers (the reply sent by backend HTTP servers).
the default and slightly faster relay streaming mode will be used if
no actions are defined.

for example:
response change "Server" to "OpenBSD-hoststated/4.1"

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2007/02/26 20:48:48 pyr Exp $	*/
d110 1
a110 1
%token	SEND EXPECT NOTHING SSL LOADBALANCE ROUNDROBIN CIPHERS
d609 4
a613 1
				pk.key = "GET";
d620 1
a620 1
					pn->key = strdup("GET");
d789 1
d1072 1
@


1.32
log
@kill the ``use ssl'' directive for consistency across parser directives.
another heads up for testers: you need to change configuration files.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2007/02/26 19:58:04 pyr Exp $	*/
d107 1
a107 1
%token  CHECK TCP ICMP EXTERNAL
d118 1
a118 1
%type	<v.number>	proto_type dstmode docheck retry log flag
d552 2
a553 1
			RB_INIT(&p->tree);
d576 9
a584 4
		| protonode log			{
			struct protonode *pn, pk;

			pn = RB_FIND(proto_tree, &proto->tree, &node);
d597 5
a601 3
			pn->id = proto->nodecount++;
			if ($2) {
				proto->lateconnect++;
a602 1
			}
d607 1
a607 1
			RB_INSERT(proto_tree, &proto->tree, pn);
d612 1
a612 1
				pn = RB_FIND(proto_tree, &proto->tree, &pk);
d623 5
a627 1
					pn->id = proto->nodecount++;
d633 1
a633 1
					RB_INSERT(proto_tree, &proto->tree, pn);
d651 5
a772 1
			proto->lateconnect++;
d1099 2
d1353 2
a1354 1
	RB_INIT(&conf->proto_default.tree);
@


1.31
log
@remove HTTP and HTTPS tokens, makes for cleaner parser.
reorder other rules as well.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2007/02/26 19:25:05 pyr Exp $	*/
d110 1
a110 1
%token	SEND EXPECT NOTHING USE SSL LOADBALANCE ROUNDROBIN CIPHERS
d117 1
a117 1
%type	<v.number>	number port http_type loglevel sslcache
d149 4
d485 1
a485 1
		| CHECK SEND sendbuf EXPECT STRING {
d487 4
a518 4
		| USE SSL			{
			table->flags |= F_SSL;
			conf->flags |= F_SSL;
		}
d831 1
a831 1
relayoptsl	: LISTEN ON STRING port sslserv {
d851 4
a943 7
sslserv		: /* empty */
		| SSL	{
			rlay->flags |= F_SSL;
			conf->flags |= F_SSL;
		}
		;

a1099 1
		{ "use",		USE },
@


1.30
log
@solve some conflicts in the configuration parser.
configuration will need to be updated as some directives have changed.
manpage and examples bits coming up.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2007/02/26 13:31:21 pyr Exp $	*/
d107 1
a107 1
%token  CHECK HTTP HTTPS TCP ICMP EXTERNAL
d118 1
a118 1
%type	<v.number>	prototype dstmode docheck retry log flag
d149 25
a173 2
http_type	: HTTP		{ $$ = 0; }
		| HTTPS		{ $$ = 1; }
d176 1
a176 1
port		: PORT STRING	{
d179 1
a179 1
			
d181 1
a181 1
			if (estr) {
a197 19
		| PORT http_type {
			struct servent	*servent;
			int		 port;
			const char	*sport;

			if ($2) {
				port = 443;
				sport = "https";
			} else {
				port = 80;
				sport = "http";
			}

			servent = getservbyname(sport, "tcp");
			if (servent == NULL)
				$$ = htons(port);
			else
				$$ = servent->s_port;
		}
d570 1
a570 1
		| PROTO prototype		{ proto->type = $2; }
a772 4
prototype	: TCP				{ $$ = RELAY_PROTO_TCP; }
		| HTTP				{ $$ = RELAY_PROTO_HTTP; }
		;

a1062 2
		{ "http",		HTTP },
		{ "https",		HTTPS },
@


1.29
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2007/02/26 13:03:30 pyr Exp $	*/
d112 1
a112 1
%token	PROTO SESSION CACHE APPEND CHANGE REMOVE FROM FILTER HASH
d118 1
a118 1
%type	<v.number>	prototype dstmode docheck retry no log
d664 17
a680 13
		| no STRING			{
			u_int flags = 0;
			if (strcmp("sslv2", $2) == 0)
				flags = SSLFLAG_SSLV2;
			else if (strcmp("sslv3", $2) == 0)
				flags = SSLFLAG_SSLV3;
			else if (strcmp("tlsv1", $2) == 0)
				flags = SSLFLAG_TLSV1;
			if ($1)
				proto->sslflags &= ~flags;
			else
				proto->sslflags |= flags;
			free($2);
d684 1
a684 1
protonode	: APPEND STRING TO STRING marked	{
d686 2
a687 2
			node.key = strdup($4);
			node.value = strdup($2);
d692 2
a693 2
			free($4);
			free($2);
d695 1
a695 1
		| CHANGE STRING TO STRING marked	{
d697 2
a698 2
			node.key = strdup($2);
			node.value = strdup($4);
d703 2
a704 2
			free($4);
			free($2);
d706 1
a706 1
		| REMOVE STRING	marked	{
d708 1
a708 1
			node.key = strdup($2);
d712 1
a712 1
			free($2);
d714 1
a714 1
		| getvars EXPECT STRING FROM STRING mark	{
d723 1
a723 1
		| getvars FILTER STRING FROM STRING mark	{
d732 1
a732 1
		| getvars HASH STRING marked			{
d741 1
a741 1
		| getvars LOG STRING marked			{
d753 1
a753 1
mark		: /* nothing */
d757 1
a757 1
marked		: /* nothing */
d761 1
a761 1
getvars		: /* nothing */
d765 1
a765 2
sslcache	: /* empty */			{ $$ = RELAY_CACHESIZE; }
		| number			{ $$ = $1; }
a993 4
no		: /* empty */		{ $$ = 0; }
		| NO			{ $$ = 1; }
		;

d1061 1
@


1.28
log
@Change the ``virtual ip'' directive to ``virtual host''.
You will need to update your configuration files accordingly.
"just do it", reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2007/02/24 00:22:32 reyk Exp $	*/
d501 2
a502 2
				yyerror("yyparse: error initializing group '%s'",
				    table->demote_group);
d850 2
a851 2
				yyerror("relay %s target or service already specified",
				    rlay->name);
d872 2
a873 2
				yyerror("relay %s target or service already specified",
				    rlay->name);
@


1.27
log
@- allow to specify the SSL cipher suite and the SSL protocols
  (as required by the PCI DSS)
- increase the default listen backlog to 10, allow to modify the
  backlog as a per-protocol tcp option to improve the performance
  on busy systems (to get less connection failures on heavy load)
- close the connection if SSL_accept returned an error
- instead of logging _new_ relay sessions to syslog, log the
  sessions in relay_close() after they have been _finished_.
  this will allow to collect some additional information
- add a new log keyword to log specified header/url entities (useful
  to track "bad guys" using many session ids or multiple user agents)
- some minor fixes, manpage bits, and bump the copyright (by some
  reason, i didn't realize that we already have 2007...).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2007/02/22 03:32:39 reyk Exp $	*/
d109 1
a109 1
%token	VIRTUAL IP INTERVAL DISABLE STICKYADDR BACKLOG
d349 1
a349 1
		| VIRTUAL IP STRING port interface {
a1067 1
		{ "ip",			IP },
@


1.26
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2007/02/09 17:55:49 reyk Exp $	*/
d109 2
a110 2
%token	VIRTUAL IP INTERVAL DISABLE STICKYADDR
%token	SEND EXPECT NOTHING USE SSL LOADBALANCE ROUNDROBIN
d118 1
a118 1
%type	<v.number>	prototype dstmode docheck retry
d536 4
d548 6
d562 2
a563 2
protoptsl	: SSL SESSION CACHE sslcache	{ proto->cache = $4; }
		| PROTO prototype		{ proto->type = $2; }
d566 2
a567 1
		| protonode			{
d582 1
a582 1
			pn->header = node.getvars ? 0 : 1;
d584 4
d594 1
a594 1
			if (node.getvars) {
d596 1
d598 1
a598 3
				if (pn != NULL) {
					pn->getvars++;
				} else if (pn == NULL) {
d607 1
a607 1
					pn->getvars = 1;
d616 10
d640 7
d653 26
d687 1
a687 1
				node.macro = 1;
d698 1
a698 1
				node.macro = 1;
d737 10
d750 1
a750 1
		| MARK				{ node.mark++; }
d754 1
a754 1
		| MARKED			{ node.mark++; }
d758 1
a758 1
		| URL				{ node.getvars++; }
d991 8
d1045 1
d1051 1
@


1.25
log
@unbreak the symset function
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2007/02/08 13:32:24 reyk Exp $	*/
d39 1
d57 2
d62 3
d110 4
a113 2
%token	SEND EXPECT NOTHING USE SSL
%token	LOG UPDATES ALL
d117 2
a118 1
%type	<v.number>	number port http_type loglevel
d130 2
d220 24
d271 1
a271 1
			if (last_service_id == UINT_MAX) {
d396 1
a396 1
			if (last_table_id == UINT_MAX) {
d490 16
d513 360
d877 1
a877 1
host		: HOST STRING {
d904 2
a905 1
			if (last_host_id == UINT_MAX) {
d913 4
d924 4
d969 1
d971 3
d976 1
d981 4
d992 2
d995 6
d1002 1
d1004 2
d1007 5
d1014 2
d1022 1
d1024 1
d1247 3
d1256 9
d1269 2
d1297 1
a1297 1
	if (TAILQ_EMPTY(&conf->services)) {
d1316 8
@


1.24
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2007/02/07 15:17:46 reyk Exp $	*/
d918 1
a918 2
	if (strlcpy(sym, s, len) >= len)
		errx(1, "cmdline_symset: macro too long");
@


1.23
log
@add new "log (updates|all)" configuration option to log state
notifications after completed host checks.  either only log the
"updates" to new states or log "all" state notifications, even if the
state didn't change. the log messages will be reported to syslog or to
stderr if the daemon is running in foreground mode.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2007/02/07 13:39:58 reyk Exp $	*/
d415 3
a417 2
			asprintf(&table->sendbuf, "HEAD %s HTTP/1.0\r\n\r\n",
			    $3);
d428 3
a430 2
			asprintf(&table->sendbuf, "GET %s HTTP/1.0\r\n\r\n",
			    $3);
d918 2
a919 1
	strlcpy(sym, s, len);
@


1.22
log
@remove unused functions and variables which have been copied from
ospfd(8) (can be re-imported later if required).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2007/02/07 13:30:17 reyk Exp $	*/
d105 1
d109 1
a109 1
%type	<v.number>	number port http_type
d205 1
d211 4
d546 1
d561 1
d573 1
@


1.21
log
@add the -D option to define macros on the command line (as found in
bgpd(8), hostapd(8), ipsecctl(8), pfctl(8), ...).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2007/01/30 10:12:06 pyr Exp $	*/
a52 1
char				*start_state;
@


1.20
log
@small memleak plugged and style changes.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2007/01/29 14:23:31 pyr Exp $	*/
a80 1
int		 cmdline_symset(char *);
@


1.19
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2007/01/25 19:40:08 niallo Exp $	*/
d48 1
a48 1
struct hoststated			*conf = NULL;
a460 1
			struct host *r;
d464 1
a464 1
			if ((r = calloc(1, sizeof(*r))) == NULL)
d471 1
d475 1
a475 1
			memcpy(&r->ss, &a->ss, sizeof(r->ss));
d478 2
a479 2
			if (strlcpy(r->name, $2, sizeof(r->name)) >=
			    sizeof(r->name)) {
d482 8
a490 8
			} else {
				r->id = last_host_id++;
				if (last_host_id == UINT_MAX) {
					yyerror("too many hosts defined");
					YYERROR;
				}
				free($2);
				$$ = r;
@


1.18
log
@return 0, not NULL in a function returning int.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2007/01/24 06:31:09 pyr Exp $	*/
d44 2
d103 1
a103 1
%token  CHECK HTTP TCP ICMP EXTERNAL
d106 1
a106 1
%token	SEND EXPECT NOTHING
d110 1
a110 1
%type	<v.number>	number port
d139 4
d165 1
a165 1
		| PORT HTTP {
d167 10
d178 1
a178 1
			servent = getservbyname("http", "tcp");
d180 1
a180 1
				$$ = htons(80);
d399 10
a408 1
		| CHECK HTTP STRING CODE number {
d417 5
a421 1
		| CHECK HTTP STRING DIGEST STRING {
d450 4
d551 1
d561 1
d567 1
@


1.17
log
@Better handling of escaped CR-LF in the configuration file, commenting
them out was previously broken.  This is needed for send/expect scripts.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2007/01/12 16:43:01 pyr Exp $	*/
d767 1
a767 1
		return (NULL);
@


1.16
log
@eliminate duplicate tcp read/write code.
ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2007/01/09 13:50:11 pyr Exp $	*/
d63 1
a63 1
int	 lgetc(FILE *);
d553 1
a553 1
lgetc(FILE *f)
d557 1
d575 1
d579 1
d621 1
d628 2
a629 2
		c = lgetc(fin);
		if (c == '\n') {
d646 1
d650 1
a650 1
	while ((c = lgetc(fin)) == ' ')
d655 4
a658 2
		while ((c = lgetc(fin)) != '\n' && c != EOF)
			; /* nothing */
d661 1
a661 1
			if ((c = lgetc(fin)) == EOF)
d691 1
a691 1
			if ((c = lgetc(fin)) == EOF)
d697 1
a697 1
			if (c == '\n') {
d726 2
a727 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
@


1.15
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2007/01/09 00:45:32 deraadt Exp $	*/
d179 1
a179 1
			bzero(table->sendbuf, sizeof(table->sendbuf));
d182 3
a184 6
			if (strlcpy(table->sendbuf, $1, sizeof(table->sendbuf))
			    >= sizeof(table->sendbuf)) {
				yyerror("yyparse: send buffer truncated");
				free($1);
				YYERROR;
			}
d386 5
a390 6
			if (strlcpy(table->path, $3, sizeof(table->path)) >=
			    sizeof(table->path)) {
				yyerror("http path truncated");
				free($3);
				YYERROR;
			}
d394 5
a398 7
			if (strlcpy(table->path, $3, sizeof(table->path)) >=
			    sizeof(table->path)) {
				yyerror("http path truncated");
				free($3);
				free($5);
				YYERROR;
			}
a401 1
				free($3);
a404 1
			free($3);
@


1.14
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2007/01/08 20:46:18 reyk Exp $	*/
d46 1
a46 1
struct hostated			*conf = NULL;
d745 1
a745 1
parse_config(struct hostated *x_conf, const char *filename, int opts)
d778 1
a778 1
		if ((conf->opts & HOSTATED_OPT_VERBOSE) && !sym->used)
@


1.13
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2007/01/08 17:10:23 reyk Exp $	*/
d44 1
a44 1
#include "hostated.h"
@


1.12
log
@allow to use service names in addition to numerical port numbers in
the configuration file, eg. "real port http".

> From Pierre-Yves Ritschard (pyr at spootnik dot org)

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2007/01/08 16:50:04 reyk Exp $	*/
a42 1
#include <regex.h>
a415 3
			int	ret;
			char	ebuf[32];

d417 3
a419 5
			ret = regcomp(&table->regx, $5, REG_EXTENDED|REG_NOSUB);
			if (ret != 0) {
				regerror(ret, &table->regx, ebuf, sizeof(ebuf));
				yyerror("cannot compile expect regexp: %s",
				    ebuf);
@


1.11
log
@the timeout values are not allowed to exceed the global interval (i
figured this out while testing hostated against a stottering spamd
where the send/expect timeout needs be > 10 seconds). also use another
struct timeval to store the interval for easier handling in the code.

ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2007/01/08 14:30:31 reyk Exp $	*/
d109 1
a109 1
%type	<v.number>	number
d138 33
d298 1
a298 7
		| VIRTUAL IP STRING PORT number	interface {
			if ($5 < 1 || $5 > USHRT_MAX) {
				yyerror("invalid port number: %d", $5);
				free($3);
				free($6);
				YYERROR;
			}
d300 1
a300 1
				 SRV_MAX_VIRTS, htons($5), $6) <= 0) {
d303 1
a303 1
				free($6);
d307 1
a307 1
			free($6);
d431 2
a432 6
		| REAL PORT number {
			if ($3 < 1 || $3 >= USHRT_MAX) {
				yyerror("invalid port number: %d", $3);
				YYERROR;
			}
			table->port = $3;
d776 1
d778 1
@


1.10
log
@remove unused token.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2007/01/08 13:37:26 reyk Exp $	*/
d160 1
a160 1
main		: INTERVAL number	{ conf->interval = $2; }
d744 2
a745 1
	conf->interval = CHECK_INTERVAL;
d775 5
d781 1
a781 1
	TAILQ_FOREACH(table, &conf->tables, entry)
d786 6
@


1.9
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2007/01/03 09:45:29 reyk Exp $	*/
d102 1
a102 1
%token  CHECK HTTP HTTPS TCP ICMP EXTERNAL
a508 1
		{ "https",		HTTPS },
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2007/01/03 09:42:30 reyk Exp $	*/
d43 1
d105 1
d146 14
d380 1
a380 1
			    sizeof(table->digest)) >= sizeof (table->digest)) {
d389 15
d505 1
d514 1
d517 1
d565 7
a571 1
		if (next != '\n') {
@


1.7
log
@allow the sticky-address option for round-robin pools.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2006/12/25 19:05:41 reyk Exp $	*/
d300 2
a301 1
			bcopy(&conf->timeout, &tb->timeout, sizeof(struct timeval));
d364 1
a364 1
			    sizeof (table->digest)) >= sizeof (table->digest)) {
@


1.6
log
@fix the conversion from milliseconds to struct timeval, which uses
seconds (tv_sec) and microseconds (tv_usec), but the code assumed
seconds and milliseconds...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2006/12/25 18:12:14 reyk Exp $	*/
d103 1
a103 1
%token	VIRTUAL IP INTERVAL DISABLE
d267 1
d484 1
@


1.5
log
@partial rewrite of the check_* routines to use libevent everywhere
instead of nested select() calls and to handle the non-blocking
sockets properly.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
(with a little help by me)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2006/12/16 18:05:35 martin Exp $	*/
d93 1
d109 1
d145 3
a147 1
		| TIMEOUT number	{ conf->timeout = $2; }
d299 1
a299 1
			tb->timeout = conf->timeout;
d333 2
a334 2
		| TIMEOUT number	{
			table->timeout = $2;
d420 7
d700 2
a701 1
	conf->timeout = CHECK_TIMEOUT;
@


1.4
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2006/12/16 17:48:27 deraadt Exp $	*/
d143 1
d295 1
a295 1
			tb->timeout = CONNECT_TIMEOUT;
d689 1
@


1.3
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d475 1
a475 1
		{ "virtual",		VIRTUA L}
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d126 1
a126 1
					$1, estr);
d174 1
a174 1
					service->name);
d179 1
a179 1
					service->name);
d356 2
a357 2
			if (strlcpy(table->digest, $5, sizeof (table->digest))
					>= sizeof (table->digest)) {
d376 1
a376 1
interface	: /*empty*/ 		{ $$ = NULL; }
d455 21
a475 21
		{"backup",		BACKUP},
		{"check",		CHECK},
		{"code",		CODE},
		{"digest",		DIGEST},
		{"disable",		DISABLE},
		{"external",		EXTERNAL},
		{"host",		HOST},
		{"http",		HTTP},
		{"https",		HTTPS},
		{"icmp",		ICMP},
		{"interface",		INTERFACE},
		{"interval",		INTERVAL},
		{"ip",			IP},
		{"port",		PORT},
		{"real",		REAL},
		{"service",		SERVICE},
		{"table",		TABLE},
		{"tag",			TAG},
		{"tcp",			TCP},
		{"timeout",		TIMEOUT},
		{"virtual",		VIRTUAL}
d864 1
a864 1
			return (0);
d903 1
a903 1
			s, max);
a905 1

d911 1
a911 1
     in_port_t port, const char *ifname)
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 3
a79 3
int			 symset(const char *, const char *, int);
char			*symget(const char *);
int			 cmdline_symset(char *);
d84 1
a84 1
			  int, in_port_t, const char *);
d86 1
a86 1
		      int, in_port_t, const char *);
d120 1
a120 1
number		: STRING 		{
d145 1
a145 1
service		: SERVICE STRING 	{
d159 2
a160 2
			if (strlcpy(srv->name, $2, sizeof (srv->name)) >=
					sizeof (srv->name)) {
d164 1
a164 1
			free ($2);
d186 1
a186 1
			         service->table->port) {
d188 2
a189 2
					"for its table and backup table",
					service->name);
d192 1
a192 1
			
d203 1
a203 1
serviceoptsl	: TABLE STRING 			{
d220 1
a220 1
		| BACKUP TABLE STRING 		{
d273 1
a273 1
table		: TABLE STRING 			{
d284 1
a284 1
			
d287 3
a289 3
			
			if (strlcpy(tb->name, $2, sizeof (tb->name)) >=
					sizeof (tb->name)) {
d299 1
a299 1
			free ($2);
d301 1
a301 1
		} '{' optnl tableopts_l '}' 	{
d323 1
a323 1
tableoptsl	: host 				{
d328 1
a328 1
		| TIMEOUT number 		{
d331 1
a331 1
		| CHECK ICMP 			{
d334 1
a334 1
		| CHECK TCP 			{
d340 2
a341 2
			if (strlcpy(table->path, $3, sizeof (table->path)) >=
					sizeof (table->path)) {
d349 2
a350 2
			if (strlcpy(table->path, $3, sizeof (table->path)) >=
					sizeof (table->path)) {
d381 1
a381 1
                        struct host *r;
d385 2
a386 2
                        if ((r = calloc(1, sizeof (*r))) == NULL)
                                fatal("out of memory");
d398 2
a399 2
                        if (strlcpy(r->name, $2, sizeof (r->name)) >=
					sizeof (r->name)) {
d686 1
a686 1
		      sizeof(conf->empty_table.name)); 
d838 1
a838 1
	
d915 1
a915 1
		
d931 1
a931 1
		
@

