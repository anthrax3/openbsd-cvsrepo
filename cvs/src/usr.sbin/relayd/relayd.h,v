head	1.241;
access;
symbols
	OPENBSD_6_1:1.239.0.4
	OPENBSD_6_1_BASE:1.239
	OPENBSD_6_0:1.223.0.2
	OPENBSD_6_0_BASE:1.223
	OPENBSD_5_9:1.222.0.2
	OPENBSD_5_9_BASE:1.222
	OPENBSD_5_8:1.213.0.4
	OPENBSD_5_8_BASE:1.213
	OPENBSD_5_7:1.207.0.2
	OPENBSD_5_7_BASE:1.207
	OPENBSD_5_6:1.189.0.4
	OPENBSD_5_6_BASE:1.189
	OPENBSD_5_5:1.172.0.4
	OPENBSD_5_5_BASE:1.172
	OPENBSD_5_4:1.169.0.2
	OPENBSD_5_4_BASE:1.169
	OPENBSD_5_3:1.164.0.2
	OPENBSD_5_3_BASE:1.164
	OPENBSD_5_2:1.156.0.2
	OPENBSD_5_2_BASE:1.156
	OPENBSD_5_1_BASE:1.152
	OPENBSD_5_1:1.152.0.2
	OPENBSD_5_0:1.150.0.2
	OPENBSD_5_0_BASE:1.150
	OPENBSD_4_9:1.140.0.2
	OPENBSD_4_9_BASE:1.140
	OPENBSD_4_8:1.137.0.2
	OPENBSD_4_8_BASE:1.137
	OPENBSD_4_7:1.133.0.2
	OPENBSD_4_7_BASE:1.133
	OPENBSD_4_6:1.126.0.4
	OPENBSD_4_6_BASE:1.126
	OPENBSD_4_5:1.113.0.2
	OPENBSD_4_5_BASE:1.113
	OPENBSD_4_4:1.109.0.2
	OPENBSD_4_4_BASE:1.109
	OPENBSD_4_3:1.99.0.2
	OPENBSD_4_3_BASE:1.99;
locks; strict;
comment	@ * @;


1.241
date	2017.07.04.19.59.51;	author benno;	state Exp;
branches;
next	1.240;
commitid	ShNRMJEraQPkzmLN;

1.240
date	2017.05.27.08.33.25;	author claudio;	state Exp;
branches;
next	1.239;
commitid	mLnU8nnW1ZLoAWRU;

1.239
date	2017.02.02.08.24.16;	author reyk;	state Exp;
branches;
next	1.238;
commitid	L4E1ZRoEzVaurCmz;

1.238
date	2017.01.24.10.49.14;	author benno;	state Exp;
branches;
next	1.237;
commitid	OlGQrXFnE2t7dYTy;

1.237
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.236;
commitid	eA8b246voAapPTkX;

1.236
date	2016.11.24.21.01.18;	author reyk;	state Exp;
branches;
next	1.235;
commitid	FkVuQgzULddApn9S;

1.235
date	2016.10.05.16.58.19;	author reyk;	state Exp;
branches;
next	1.234;
commitid	UGOrmt0fCkvkKrPU;

1.234
date	2016.09.28.12.16.44;	author reyk;	state Exp;
branches;
next	1.233;
commitid	9yLAl6KjHBmFKV9B;

1.233
date	2016.09.03.14.44.21;	author reyk;	state Exp;
branches;
next	1.232;
commitid	n0F9VKkYrh9A46uy;

1.232
date	2016.09.03.14.09.04;	author reyk;	state Exp;
branches;
next	1.231;
commitid	0kWOwUNycE381inh;

1.231
date	2016.09.02.16.14.09;	author reyk;	state Exp;
branches;
next	1.230;
commitid	PZw2w24xmNM2vbc7;

1.230
date	2016.09.02.14.45.51;	author reyk;	state Exp;
branches;
next	1.229;
commitid	vcV98N2DyJGMwDyQ;

1.229
date	2016.09.02.12.12.51;	author reyk;	state Exp;
branches;
next	1.228;
commitid	tCJ77FP0n8bVYrYP;

1.228
date	2016.09.02.11.51.50;	author reyk;	state Exp;
branches;
next	1.227;
commitid	Scmkna4JViHMcK3U;

1.227
date	2016.09.01.10.49.48;	author claudio;	state Exp;
branches;
next	1.226;
commitid	kVeSpNYKmzM2uO33;

1.226
date	2016.09.01.10.40.38;	author claudio;	state Exp;
branches;
next	1.225;
commitid	z4OduQ4Dp5sgfxQA;

1.225
date	2016.07.29.10.09.27;	author reyk;	state Exp;
branches;
next	1.224;
commitid	cXyFVrZtyIYivR44;

1.224
date	2016.07.27.06.55.44;	author reyk;	state Exp;
branches;
next	1.223;
commitid	7JdoxjTbye4XkUae;

1.223
date	2016.07.22.09.30.36;	author benno;	state Exp;
branches
	1.223.2.1;
next	1.222;
commitid	giZ5PqS1Bh7LYKMb;

1.222
date	2016.01.11.21.31.42;	author benno;	state Exp;
branches
	1.222.2.1;
next	1.221;
commitid	tlLuP4GlMjndgo3c;

1.221
date	2015.12.02.22.12.29;	author benno;	state Exp;
branches;
next	1.220;
commitid	KSrslYc9PdXCr4Hr;

1.220
date	2015.12.02.13.41.27;	author reyk;	state Exp;
branches;
next	1.219;
commitid	vBNcEM4jmO1KceIa;

1.219
date	2015.11.29.01.20.33;	author benno;	state Exp;
branches;
next	1.218;
commitid	u0wLjk4LODsT22tz;

1.218
date	2015.11.28.09.52.07;	author reyk;	state Exp;
branches;
next	1.217;
commitid	Xo3TbDi9hUaP9ip0;

1.217
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.216;
commitid	T3JBYxNT0thPuavp;

1.216
date	2015.11.21.12.37.42;	author reyk;	state Exp;
branches;
next	1.215;
commitid	F0WFvnPckRXIJkcu;

1.215
date	2015.10.27.12.27.54;	author benno;	state Exp;
branches;
next	1.214;
commitid	uWeuMfQD1ylwAreq;

1.214
date	2015.08.21.08.45.51;	author yasuoka;	state Exp;
branches;
next	1.213;
commitid	6XMVUYi6SZ55Zx0G;

1.213
date	2015.07.18.16.01.28;	author benno;	state Exp;
branches
	1.213.4.1;
next	1.212;
commitid	SsEehKey7cEgRJ3z;

1.212
date	2015.06.12.14.40.55;	author reyk;	state Exp;
branches;
next	1.211;
commitid	l9tjrfdeeLzMV6hw;

1.211
date	2015.06.11.18.49.09;	author reyk;	state Exp;
branches;
next	1.210;
commitid	r36j1ZCD0yPK3S9O;

1.210
date	2015.06.08.15.47.51;	author claudio;	state Exp;
branches;
next	1.209;
commitid	qDFFH9Mi796T9cGu;

1.209
date	2015.05.02.13.15.24;	author claudio;	state Exp;
branches;
next	1.208;
commitid	KeIVSkhMPmj3B0K2;

1.208
date	2015.03.09.17.20.38;	author reyk;	state Exp;
branches;
next	1.207;
commitid	ccJcSsJHpwbYBS0r;

1.207
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches
	1.207.2.1;
next	1.206;
commitid	puppem00jmzmdm4f;

1.206
date	2015.01.22.09.26.05;	author reyk;	state Exp;
branches;
next	1.205;
commitid	o3hdD3oPPo4ygHrW;

1.205
date	2015.01.16.15.08.52;	author reyk;	state Exp;
branches;
next	1.204;
commitid	cBAkhi7b4UQjJ650;

1.204
date	2015.01.16.15.06.41;	author deraadt;	state Exp;
branches;
next	1.203;
commitid	tOv8XK6tLyhEfayc;

1.203
date	2015.01.13.09.24.21;	author reyk;	state Exp;
branches;
next	1.202;
commitid	P0wyoMLA4lz5rdAI;

1.202
date	2015.01.01.14.54.06;	author reyk;	state Exp;
branches;
next	1.201;
commitid	B0Gf34206qlx2MJL;

1.201
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.200;
commitid	XnjIOhurXdX5o1V9;

1.200
date	2014.12.18.20.55.01;	author reyk;	state Exp;
branches;
next	1.199;
commitid	nThpdXmyvXqmRQ4C;

1.199
date	2014.12.17.13.54.27;	author reyk;	state Exp;
branches;
next	1.198;
commitid	h9EkWAL1J0qMVMZL;

1.198
date	2014.12.12.10.05.09;	author reyk;	state Exp;
branches;
next	1.197;
commitid	J8g0vRzthwLCqf68;

1.197
date	2014.11.19.10.24.40;	author blambert;	state Exp;
branches;
next	1.196;
commitid	EGrSQMGI27r3h8Vf;

1.196
date	2014.11.07.13.48.06;	author jsing;	state Exp;
branches;
next	1.195;
commitid	QL46KAhcJy2F2EDf;

1.195
date	2014.11.02.13.59.40;	author bluhm;	state Exp;
branches;
next	1.194;
commitid	Jb29Z2q3vFfyWUb3;

1.194
date	2014.10.20.14.50.41;	author reyk;	state Exp;
branches;
next	1.193;
commitid	KIC8ch1nwP4BCbnR;

1.193
date	2014.10.15.11.06.16;	author reyk;	state Exp;
branches;
next	1.192;
commitid	VpFBc7l3plkkPKxy;

1.192
date	2014.09.05.10.19.26;	author blambert;	state Exp;
branches;
next	1.191;
commitid	Qc13eOLjGetIgjBs;

1.191
date	2014.08.29.09.03.36;	author blambert;	state Exp;
branches;
next	1.190;
commitid	YgQqK1UkUhNBtyeV;

1.190
date	2014.08.18.12.59.00;	author reyk;	state Exp;
branches;
next	1.189;
commitid	6CBP61dyg2cJV5hP;

1.189
date	2014.07.14.00.11.12;	author bluhm;	state Exp;
branches;
next	1.188;
commitid	LPQMOcmMS8D0dRAQ;

1.188
date	2014.07.13.00.32.08;	author benno;	state Exp;
branches;
next	1.187;
commitid	ri182Vf5Hw0I7rh1;

1.187
date	2014.07.12.14.34.13;	author reyk;	state Exp;
branches;
next	1.186;
commitid	Rqjr3ecSVr0G8d8h;

1.186
date	2014.07.11.22.28.44;	author reyk;	state Exp;
branches;
next	1.185;
commitid	etE3yRsFWECDBHuh;

1.185
date	2014.07.11.21.09.28;	author reyk;	state Exp;
branches;
next	1.184;
commitid	8FOOifAerUwiwvnX;

1.184
date	2014.07.11.16.59.38;	author reyk;	state Exp;
branches;
next	1.183;
commitid	For422J6VfsgvmL6;

1.183
date	2014.07.11.11.48.50;	author reyk;	state Exp;
branches;
next	1.182;
commitid	6F05OKHLwEQdKZuE;

1.182
date	2014.07.09.16.42.05;	author reyk;	state Exp;
branches;
next	1.181;
commitid	YhQvyAop4vC3AmzJ;

1.181
date	2014.06.27.07.49.08;	author andre;	state Exp;
branches;
next	1.180;
commitid	pPMUb6sAQ5HcQv7b;

1.180
date	2014.05.20.17.33.36;	author reyk;	state Exp;
branches;
next	1.179;

1.179
date	2014.05.08.13.08.48;	author blambert;	state Exp;
branches;
next	1.178;

1.178
date	2014.05.04.16.38.19;	author reyk;	state Exp;
branches;
next	1.177;

1.177
date	2014.04.22.08.04.23;	author reyk;	state Exp;
branches;
next	1.176;

1.176
date	2014.04.20.14.48.29;	author reyk;	state Exp;
branches;
next	1.175;

1.175
date	2014.04.18.13.55.26;	author reyk;	state Exp;
branches;
next	1.174;

1.174
date	2014.04.18.12.02.37;	author reyk;	state Exp;
branches;
next	1.173;

1.173
date	2014.04.14.12.58.04;	author blambert;	state Exp;
branches;
next	1.172;

1.172
date	2014.02.14.10.21.00;	author benno;	state Exp;
branches;
next	1.171;

1.171
date	2013.09.09.17.57.45;	author reyk;	state Exp;
branches;
next	1.170;

1.170
date	2013.09.07.10.46.31;	author fgsch;	state Exp;
branches;
next	1.169;

1.169
date	2013.05.30.20.17.12;	author reyk;	state Exp;
branches;
next	1.168;

1.168
date	2013.04.27.16.39.30;	author benno;	state Exp;
branches;
next	1.167;

1.167
date	2013.03.10.23.32.53;	author reyk;	state Exp;
branches;
next	1.166;

1.166
date	2013.03.09.14.43.06;	author bluhm;	state Exp;
branches;
next	1.165;

1.165
date	2013.03.04.08.41.32;	author sthen;	state Exp;
branches;
next	1.164;

1.164
date	2013.02.05.21.36.33;	author bluhm;	state Exp;
branches;
next	1.163;

1.163
date	2012.11.27.05.00.28;	author guenther;	state Exp;
branches;
next	1.162;

1.162
date	2012.10.19.16.49.50;	author reyk;	state Exp;
branches;
next	1.161;

1.161
date	2012.10.04.20.53.30;	author reyk;	state Exp;
branches;
next	1.160;

1.160
date	2012.10.03.08.40.40;	author reyk;	state Exp;
branches;
next	1.159;

1.159
date	2012.10.03.08.33.31;	author reyk;	state Exp;
branches;
next	1.158;

1.158
date	2012.09.21.09.56.27;	author benno;	state Exp;
branches;
next	1.157;

1.157
date	2012.09.20.12.30.20;	author reyk;	state Exp;
branches;
next	1.156;

1.156
date	2012.07.09.09.52.05;	author deraadt;	state Exp;
branches;
next	1.155;

1.155
date	2012.07.09.08.56.00;	author deraadt;	state Exp;
branches;
next	1.154;

1.154
date	2012.05.08.15.10.15;	author benno;	state Exp;
branches;
next	1.153;

1.153
date	2012.04.11.08.25.26;	author deraadt;	state Exp;
branches;
next	1.152;

1.152
date	2012.01.21.13.40.48;	author camield;	state Exp;
branches;
next	1.151;

1.151
date	2011.09.04.20.26.58;	author bluhm;	state Exp;
branches;
next	1.150;

1.150
date	2011.05.26.14.48.20;	author reyk;	state Exp;
branches;
next	1.149;

1.149
date	2011.05.26.14.38.03;	author reyk;	state Exp;
branches;
next	1.148;

1.148
date	2011.05.20.09.43.53;	author reyk;	state Exp;
branches;
next	1.147;

1.147
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.146;

1.146
date	2011.05.09.12.08.47;	author reyk;	state Exp;
branches;
next	1.145;

1.145
date	2011.05.05.10.20.24;	author phessler;	state Exp;
branches;
next	1.144;

1.144
date	2011.04.24.10.07.43;	author bluhm;	state Exp;
branches;
next	1.143;

1.143
date	2011.04.12.12.37.22;	author reyk;	state Exp;
branches;
next	1.142;

1.142
date	2011.04.12.11.45.18;	author bluhm;	state Exp;
branches;
next	1.141;

1.141
date	2011.04.07.13.22.29;	author reyk;	state Exp;
branches;
next	1.140;

1.140
date	2010.12.31.21.22.42;	author guenther;	state Exp;
branches;
next	1.139;

1.139
date	2010.11.30.14.38.45;	author reyk;	state Exp;
branches;
next	1.138;

1.138
date	2010.10.26.15.04.37;	author reyk;	state Exp;
branches;
next	1.137;

1.137
date	2010.08.01.22.18.35;	author sthen;	state Exp;
branches;
next	1.136;

1.136
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.135;

1.135
date	2010.05.14.11.13.36;	author reyk;	state Exp;
branches;
next	1.134;

1.134
date	2010.05.14.07.57.07;	author reyk;	state Exp;
branches;
next	1.133;

1.133
date	2010.01.11.06.40.14;	author jsg;	state Exp;
branches;
next	1.132;

1.132
date	2009.11.03.21.33.22;	author reyk;	state Exp;
branches;
next	1.131;

1.131
date	2009.08.17.11.36.01;	author reyk;	state Exp;
branches;
next	1.130;

1.130
date	2009.08.13.13.51.21;	author reyk;	state Exp;
branches;
next	1.129;

1.129
date	2009.08.07.11.21.53;	author reyk;	state Exp;
branches;
next	1.128;

1.128
date	2009.08.07.11.10.23;	author reyk;	state Exp;
branches;
next	1.127;

1.127
date	2009.08.05.13.46.13;	author reyk;	state Exp;
branches;
next	1.126;

1.126
date	2009.06.06.18.31.42;	author pyr;	state Exp;
branches;
next	1.125;

1.125
date	2009.06.05.23.39.51;	author pyr;	state Exp;
branches;
next	1.124;

1.124
date	2009.06.05.00.04.01;	author pyr;	state Exp;
branches;
next	1.123;

1.123
date	2009.06.04.23.33.49;	author pyr;	state Exp;
branches;
next	1.122;

1.122
date	2009.06.04.20.31.37;	author eric;	state Exp;
branches;
next	1.121;

1.121
date	2009.06.04.14.12.16;	author reyk;	state Exp;
branches;
next	1.120;

1.120
date	2009.06.04.07.16.38;	author eric;	state Exp;
branches;
next	1.119;

1.119
date	2009.06.03.05.35.06;	author eric;	state Exp;
branches;
next	1.118;

1.118
date	2009.06.02.22.02.01;	author eric;	state Exp;
branches;
next	1.117;

1.117
date	2009.06.02.21.44.22;	author eric;	state Exp;
branches;
next	1.116;

1.116
date	2009.04.24.14.20.24;	author reyk;	state Exp;
branches;
next	1.115;

1.115
date	2009.04.02.14.30.51;	author reyk;	state Exp;
branches;
next	1.114;

1.114
date	2009.04.01.14.56.38;	author reyk;	state Exp;
branches;
next	1.113;

1.113
date	2008.12.05.16.37.56;	author reyk;	state Exp;
branches;
next	1.112;

1.112
date	2008.09.29.14.53.36;	author reyk;	state Exp;
branches;
next	1.111;

1.111
date	2008.09.29.09.58.51;	author reyk;	state Exp;
branches;
next	1.110;

1.110
date	2008.08.11.08.07.14;	author reyk;	state Exp;
branches;
next	1.109;

1.109
date	2008.07.22.23.17.37;	author reyk;	state Exp;
branches;
next	1.108;

1.108
date	2008.07.19.11.38.54;	author reyk;	state Exp;
branches;
next	1.107;

1.107
date	2008.07.19.10.52.32;	author reyk;	state Exp;
branches;
next	1.106;

1.106
date	2008.07.09.17.16.51;	author reyk;	state Exp;
branches;
next	1.105;

1.105
date	2008.07.09.14.57.01;	author reyk;	state Exp;
branches;
next	1.104;

1.104
date	2008.07.09.10.50.34;	author reyk;	state Exp;
branches;
next	1.103;

1.103
date	2008.06.11.18.21.20;	author reyk;	state Exp;
branches;
next	1.102;

1.102
date	2008.05.08.02.27.58;	author reyk;	state Exp;
branches;
next	1.101;

1.101
date	2008.05.07.01.49.29;	author reyk;	state Exp;
branches;
next	1.100;

1.100
date	2008.05.06.06.09.48;	author pyr;	state Exp;
branches;
next	1.99;

1.99
date	2008.02.13.11.32.59;	author reyk;	state Exp;
branches;
next	1.98;

1.98
date	2008.02.13.11.02.37;	author reyk;	state Exp;
branches;
next	1.97;

1.97
date	2008.02.11.10.42.50;	author reyk;	state Exp;
branches;
next	1.96;

1.96
date	2008.02.04.12.12.30;	author thib;	state Exp;
branches;
next	1.95;

1.95
date	2008.02.04.12.05.26;	author thib;	state Exp;
branches;
next	1.94;

1.94
date	2008.02.04.12.01.33;	author thib;	state Exp;
branches;
next	1.93;

1.93
date	2008.01.31.12.12.50;	author thib;	state Exp;
branches;
next	1.92;

1.92
date	2008.01.31.09.56.29;	author reyk;	state Exp;
branches;
next	1.91;

1.91
date	2008.01.31.09.33.39;	author reyk;	state Exp;
branches;
next	1.90;

1.90
date	2007.12.20.20.15.43;	author reyk;	state Exp;
branches;
next	1.89;

1.89
date	2007.12.08.20.36.36;	author pyr;	state Exp;
branches;
next	1.88;

1.88
date	2007.12.08.17.07.09;	author reyk;	state Exp;
branches;
next	1.87;

1.87
date	2007.12.07.17.17.01;	author reyk;	state Exp;
branches;
next	1.86;

1.86
date	2007.11.26.09.38.25;	author reyk;	state Exp;
branches;
next	1.85;

1.85
date	2007.11.24.16.13.50;	author reyk;	state Exp;
branches;
next	1.84;

1.84
date	2007.11.23.09.39.42;	author reyk;	state Exp;
branches;
next	1.83;

1.83
date	2007.11.22.16.38.25;	author reyk;	state Exp;
branches;
next	1.82;

1.82
date	2007.11.22.16.07.03;	author reyk;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.22.10.09.53;	author reyk;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.21.20.28.38;	author reyk;	state Exp;
branches;
next	1.79;

1.79
date	2007.11.21.20.13.20;	author reyk;	state Exp;
branches;
next	1.78;

1.78
date	2007.11.21.14.12.04;	author reyk;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.21.13.04.42;	author reyk;	state Exp;
branches;
next	1.76;

1.76
date	2007.11.20.15.54.55;	author reyk;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.20.15.44.21;	author pyr;	state Exp;
branches;
next	1.74;

1.74
date	2007.11.20.13.01.13;	author pyr;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.19.14.48.19;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2007.11.14.10.59.01;	author pyr;	state Exp;
branches;
next	1.71;

1.71
date	2007.10.22.16.53.30;	author pyr;	state Exp;
branches;
next	1.70;

1.70
date	2007.10.19.14.15.14;	author pyr;	state Exp;
branches;
next	1.69;

1.69
date	2007.10.19.12.08.55;	author pyr;	state Exp;
branches;
next	1.68;

1.68
date	2007.10.12.12.50.59;	author blambert;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.05.17.32.13;	author reyk;	state Exp;
branches;
next	1.66;

1.66
date	2007.10.05.15.50.12;	author reyk;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.02.21.04.13;	author pyr;	state Exp;
branches;
next	1.64;

1.64
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.28.13.05.28;	author pyr;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.27.13.34.21;	author pyr;	state Exp;
branches;
next	1.61;

1.61
date	2007.09.25.08.24.26;	author pyr;	state Exp;
branches;
next	1.60;

1.60
date	2007.09.10.11.59.22;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.07.08.20.24;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.07.07.59.18;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.07.07.52.14;	author reyk;	state Exp;
branches;
next	1.56;

1.56
date	2007.09.06.19.55.45;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.05.08.48.42;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.05.07.32.33;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.18.17.29.38;	author pyr;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.29.23.19.18;	author pyr;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.29.19.05.13;	author pyr;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.29.00.48.04;	author pyr;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.29.00.21.10;	author pyr;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.28.22.11.33;	author pyr;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.28.17.37.16;	author pyr;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.26.19.58.49;	author pyr;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.12.14.45.45;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.10.21.33.52;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.21.00.08.08;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.17.22.28.42;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.13.12.04.52;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.05.11.44.50;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2007.02.27.13.38.58;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.26.12.35.43;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.26.12.09.21;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.26.11.59.48;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2007.02.25.14.57.09;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.24.16.14.02;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.24.15.48.54;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.24.00.22.32;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.23.00.28.06;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.22.05.58.06;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.07.15.17.46;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.07.13.39.58;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.07.13.30.17;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.06.10.26.13;	author pyr;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.06.10.06.55;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.06.08.45.46;	author pyr;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.01.20.03.39;	author pyr;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.12.17.05.18;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.12.16.43.01;	author pyr;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.11.18.05.08;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.09.03.32.56;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.08.16.52.58;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.03.09.45.29;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.03.09.42.30;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2006.12.26.02.51.00;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.25.19.05.41;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.25.18.12.14;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.18.50.33;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;

1.207.2.1
date	2015.09.20.11.20.16;	author benno;	state Exp;
branches;
next	;
commitid	C9WQyjgbN7h0ioOp;

1.213.4.1
date	2016.07.23.20.56.02;	author benno;	state Exp;
branches;
next	1.213.4.2;
commitid	DFhmryrIb8G58WFk;

1.213.4.2
date	2016.08.07.07.54.42;	author benno;	state Exp;
branches;
next	;
commitid	GZ3yh3axbGcu2rco;

1.222.2.1
date	2016.07.23.21.01.33;	author benno;	state Exp;
branches;
next	1.222.2.2;
commitid	SSyx41hKvAvyRLVi;

1.222.2.2
date	2016.08.07.07.54.07;	author benno;	state Exp;
branches;
next	;
commitid	HdLzCX7WKhJK5mAs;

1.223.2.1
date	2016.08.07.07.53.45;	author benno;	state Exp;
branches;
next	;
commitid	uUOVRby9dw3PdeGk;


desc
@@


1.241
log
@make relayd not crash in relay_udp_server() when using a dns relay.
needs revisiting. From Rivo Nurges, thanks.
ok florian@@
@
text
@/*	$OpenBSD: relayd.h,v 1.240 2017/05/27 08:33:25 claudio Exp $	*/

/*
 * Copyright (c) 2006 - 2016 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2006, 2007 Pierre-Yves Ritschard <pyr@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef RELAYD_H
#define RELAYD_H

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/time.h>

#include <net/if.h>
#include <net/pfvar.h>

#include <stdarg.h>
#include <limits.h>
#include <siphash.h>
#include <event.h>
#include <imsg.h>

#include <openssl/ssl.h>
#include <tls.h>

#ifndef nitems
#define	nitems(_a)	(sizeof((_a)) / sizeof((_a)[0]))
#endif

#define CONF_FILE		"/etc/relayd.conf"
#define RELAYD_SOCKET		"/var/run/relayd.sock"
#define PF_SOCKET		"/dev/pf"
#define RELAYD_USER		"_relayd"
#define RELAYD_ANCHOR		"relayd"
#define RELAYD_SERVERNAME	"OpenBSD relayd"
#define CHECK_TIMEOUT		200
#define CHECK_INTERVAL		10
#define EMPTY_TABLE		UINT_MAX
#define EMPTY_ID		UINT_MAX
#define LABEL_NAME_SIZE		1024
#define TAG_NAME_SIZE		64
#define TABLE_NAME_SIZE		64
#define	RD_TAG_NAME_SIZE	64
#define	RT_LABEL_SIZE		32
#define SRV_NAME_SIZE		64
#define MAX_NAME_SIZE		64
#define SRV_MAX_VIRTS		16
#define TLS_NAME_SIZE		512
#define TLS_CERT_HASH_SIZE	128
#define RELAY_MAX_PREFETCH	256
#define RELAY_MIN_PREFETCHED	32

#define FD_RESERVE		5

#define RELAY_MAX_SESSIONS	1024
#define RELAY_TIMEOUT		600
#define RELAY_CACHESIZE		-1	/* use default size */
#define RELAY_NUMPROC		3
#define RELAY_MAXHOSTS		32
#define RELAY_MAXHEADERLENGTH	8192
#define RELAY_STATINTERVAL	60
#define RELAY_BACKLOG		10
#define RELAY_MAXLOOKUPLEVELS	5
#define RELAY_OUTOF_FD_RETRIES	5
#define RELAY_MAX_HASH_RETRIES	5
#define RELAY_TLS_PRIV_TIMEOUT	1000	/* wait 1sec for the ca */

#define CONFIG_RELOAD		0x00
#define CONFIG_TABLES		0x01
#define CONFIG_RDRS		0x02
#define CONFIG_RELAYS		0x04
#define CONFIG_PROTOS		0x08
#define CONFIG_ROUTES		0x10
#define CONFIG_RTS		0x20
#define CONFIG_CA_ENGINE	0x40
#define CONFIG_ALL		0xff

#define SMALL_READ_BUF_SIZE	1024
#define ICMP_BUF_SIZE		64
#define ICMP_RCVBUF_SIZE	262144

#define SNMP_RECONNECT_TIMEOUT	{ 3, 0 }	/* sec, usec */

#define PROC_PARENT_SOCK_FILENO	3
#define PROC_MAX_INSTANCES	32

#if DEBUG > 1
#define DPRINTF		log_debug
#define DEBUG_CERT	1
#else
#define DPRINTF(x...)	do {} while(0)
#endif

/* Used for DNS request ID randomization */
struct shuffle {
	u_int16_t	 id_shuffle[65536];
	int		 isindex;
};

typedef u_int32_t objid_t;

struct ctl_status {
	objid_t		 id;
	int		 up;
	int		 retry_cnt;
	u_long		 check_cnt;
	u_int16_t	 he;
};

struct ctl_id {
	objid_t		 id;
	char		 name[MAX_NAME_SIZE];
};

struct ctl_relaytable {
	objid_t		 id;
	objid_t		 relayid;
	int		 mode;
	u_int32_t	 flags;
};

struct ctl_script {
	objid_t		 host;
	int		 retval;
	struct timeval	 timeout;
	char		 name[HOST_NAME_MAX+1];
	char		 path[PATH_MAX];
};

struct ctl_demote {
	char		 group[IFNAMSIZ];
	int		 level;
};

struct ctl_icmp_event {
	struct relayd		*env;
	int			 s;
	int			 af;
	int			 last_up;
	struct event		 ev;
	struct timeval		 tv_start;
};

struct ctl_tcp_event {
	int			 s;
	char			*req;
	struct ibuf		*buf;
	struct host		*host;
	struct table		*table;
	struct timeval		 tv_start;
	struct event		 ev;
	int			(*validate_read)(struct ctl_tcp_event *);
	int			(*validate_close)(struct ctl_tcp_event *);

	struct tls		*tls;
};

enum direction {
	RELAY_DIR_INVALID	= -1,
	RELAY_DIR_ANY		=  0,
	RELAY_DIR_REQUEST	=  1,
	RELAY_DIR_RESPONSE	=  2
};

enum relay_state {
	STATE_INIT,
	STATE_PENDING,
	STATE_PRECONNECT,
	STATE_CONNECTED
};

struct ctl_relay_event {
	int			 s;
	in_port_t		 port;
	struct sockaddr_storage	 ss;
	struct bufferevent	*bev;
	struct evbuffer		*output;
	struct ctl_relay_event	*dst;
	struct rsession		*con;

	struct tls		*tls;
	struct tls_config	*tls_cfg;

	uint8_t			*tlscert;
	size_t			 tlscert_len;

	off_t			 splicelen;
	off_t			 toread;
	size_t			 headerlen;
	int			 line;
	int			 done;
	int			 timedout;
	enum relay_state	 state;
	enum direction		 dir;

	/* protocol-specific descriptor */
	void			*desc;
};

enum httpchunk {
	TOREAD_UNLIMITED		= -1,
	TOREAD_HTTP_HEADER		= -2,
	TOREAD_HTTP_CHUNK_LENGTH	= -3,
	TOREAD_HTTP_CHUNK_TRAILER	= -4
};

struct ctl_natlook {
	objid_t			 id;
	int			 proc;

	struct sockaddr_storage	 src;
	struct sockaddr_storage	 dst;
	struct sockaddr_storage	 rsrc;
	struct sockaddr_storage	 rdst;
	in_port_t		 rsport;
	in_port_t		 rdport;
	int			 in;
	int			 proto;
};

struct ctl_bindany {
	objid_t			 bnd_id;
	int			 bnd_proc;

	struct sockaddr_storage	 bnd_ss;
	in_port_t		 bnd_port;
	int			 bnd_proto;
};

struct ctl_keyop {
	char			 cko_hash[TLS_CERT_HASH_SIZE];
	int			 cko_proc;
	int			 cko_flen;
	int			 cko_tlen;
	int			 cko_padding;
};

struct ctl_stats {
	objid_t			 id;
	int			 proc;

	u_int64_t		 interval;
	u_int64_t		 cnt;
	u_int32_t		 tick;
	u_int32_t		 avg;
	u_int32_t		 last;
	u_int32_t		 avg_hour;
	u_int32_t		 last_hour;
	u_int32_t		 avg_day;
	u_int32_t		 last_day;
};

enum key_option {
	KEY_OPTION_NONE		= 0,
	KEY_OPTION_APPEND,
	KEY_OPTION_SET,
	KEY_OPTION_REMOVE,
	KEY_OPTION_HASH,
	KEY_OPTION_LOG
};

enum key_type {
	KEY_TYPE_NONE		= 0,
	KEY_TYPE_COOKIE,
	KEY_TYPE_HEADER,
	KEY_TYPE_PATH,
	KEY_TYPE_QUERY,
	KEY_TYPE_URL,
	KEY_TYPE_MAX
};

struct ctl_kvlen {
	ssize_t		 key;
	ssize_t		 value;
};

struct ctl_rule {
	struct ctl_kvlen kvlen[KEY_TYPE_MAX];
};

enum digest_type {
	DIGEST_NONE		= 0,
	DIGEST_SHA1		= 1,
	DIGEST_MD5		= 2
};

TAILQ_HEAD(kvlist, kv);
RB_HEAD(kvtree, kv);

struct kv {
	char			*kv_key;
	char			*kv_value;

	enum key_type		 kv_type;
	enum key_option		 kv_option;
	enum digest_type	 kv_digest;

#define KV_FLAG_MACRO		 0x01
#define KV_FLAG_INVALID		 0x02
#define KV_FLAG_GLOBBING	 0x04
	u_int8_t		 kv_flags;

	struct kvlist		 kv_children;
	struct kv		*kv_parent;
	TAILQ_ENTRY(kv)		 kv_entry;

	RB_ENTRY(kv)		 kv_node;

	/* A few pointers used by the rule actions */
	struct kv		*kv_match;
	struct kvtree		*kv_matchtree;

	TAILQ_ENTRY(kv)		 kv_match_entry;
	TAILQ_ENTRY(kv)		 kv_rule_entry;
	TAILQ_ENTRY(kv)		 kv_action_entry;
};

struct portrange {
	in_port_t		 val[2];
	u_int8_t		 op;
};

struct address {
	objid_t			 rdrid;
	struct sockaddr_storage	 ss;
	int			 ipproto;
	struct portrange	 port;
	char			 ifname[IFNAMSIZ];
	TAILQ_ENTRY(address)	 entry;
};
TAILQ_HEAD(addresslist, address);

union hashkey {
	/* Simplified version of pf_poolhashkey */
	u_int32_t		 data[4];
	SIPHASH_KEY		 siphashkey;
};

#define F_DISABLE		0x00000001
#define F_BACKUP		0x00000002
#define F_USED			0x00000004
#define F_DOWN			0x00000008
#define F_ADD			0x00000010
#define F_DEL			0x00000020
#define F_CHANGED		0x00000040
#define F_STICKY		0x00000080
#define F_CHECK_DONE		0x00000100
#define F_ACTIVE_RULESET	0x00000200
#define F_CHECK_SENT		0x00000400
#define F_TLS			0x00000800
#define F_NATLOOK		0x00001000
#define F_DEMOTE		0x00002000
#define F_LOOKUP_PATH		0x00004000
#define F_DEMOTED		0x00008000
#define F_UDP			0x00010000
#define F_RETURN		0x00020000
#define F_SNMP			0x00040000
#define F_NEEDPF		0x00080000
#define F_PORT			0x00100000
#define F_TLSCLIENT		0x00200000
#define F_NEEDRT		0x00400000
#define F_MATCH			0x00800000
#define F_DIVERT		0x01000000
#define F_SCRIPT		0x02000000
#define F_TLSINSPECT		0x04000000
#define F_HASHKEY		0x08000000
#define	F_SNMP_TRAPONLY		0x10000000

#define F_BITS								\
	"\10\01DISABLE\02BACKUP\03USED\04DOWN\05ADD\06DEL\07CHANGED"	\
	"\10STICKY-ADDRESS\11CHECK_DONE\12ACTIVE_RULESET\13CHECK_SENT"	\
	"\14TLS\15NAT_LOOKUP\16DEMOTE\17LOOKUP_PATH\20DEMOTED\21UDP"	\
	"\22RETURN\23TRAP\24NEEDPF\25PORT\26TLS_CLIENT\27NEEDRT"	\
	"\30MATCH\31DIVERT\32SCRIPT\33TLS_INSPECT\34HASHKEY"		\
	"\35SNMP_TRAPONLY"

enum forwardmode {
	FWD_NORMAL		= 0,
	FWD_ROUTE,
	FWD_TRANS
};

struct host_config {
	objid_t			 id;
	objid_t			 parentid;
	objid_t			 tableid;
	int			 retry;
	char			 name[HOST_NAME_MAX+1];
	struct sockaddr_storage	 ss;
	int			 ttl;
	int			 priority;
};

struct host {
	TAILQ_ENTRY(host)	 entry;
	TAILQ_ENTRY(host)	 globalentry;
	SLIST_ENTRY(host)	 child;
	SLIST_HEAD(,host)	 children;
	struct host_config	 conf;
	u_int32_t		 flags;
	char			*tablename;
	int			 up;
	int			 last_up;
	u_long			 check_cnt;
	u_long			 up_cnt;
	int			 retry_cnt;
	int			 idx;
	u_int16_t		 he;
	int			 code;
	struct ctl_tcp_event	 cte;
};
TAILQ_HEAD(hostlist, host);

enum host_error {
	HCE_NONE		= 0,
	HCE_ABORT,
	HCE_INTERVAL_TIMEOUT,
	HCE_ICMP_OK,
	HCE_ICMP_READ_TIMEOUT,
	HCE_ICMP_WRITE_TIMEOUT,
	HCE_TCP_SOCKET_ERROR,
	HCE_TCP_SOCKET_LIMIT,
	HCE_TCP_SOCKET_OPTION,
	HCE_TCP_CONNECT_FAIL,
	HCE_TCP_CONNECT_TIMEOUT,
	HCE_TCP_CONNECT_OK,
	HCE_TCP_WRITE_TIMEOUT,
	HCE_TCP_WRITE_FAIL,
	HCE_TCP_READ_TIMEOUT,
	HCE_TCP_READ_FAIL,
	HCE_SCRIPT_OK,
	HCE_SCRIPT_FAIL,
	HCE_TLS_CONNECT_ERROR,
	HCE_TLS_CONNECT_FAIL,
	HCE_TLS_CONNECT_OK,
	HCE_TLS_CONNECT_TIMEOUT,
	HCE_TLS_READ_TIMEOUT,
	HCE_TLS_WRITE_TIMEOUT,
	HCE_TLS_READ_ERROR,
	HCE_TLS_WRITE_ERROR,
	HCE_SEND_EXPECT_FAIL,
	HCE_SEND_EXPECT_OK,
	HCE_HTTP_CODE_ERROR,
	HCE_HTTP_CODE_FAIL,
	HCE_HTTP_CODE_OK,
	HCE_HTTP_DIGEST_ERROR,
	HCE_HTTP_DIGEST_FAIL,
	HCE_HTTP_DIGEST_OK,
};

enum host_status {
	HOST_DOWN	= -1,
	HOST_UNKNOWN	= 0,
	HOST_UP		= 1
};
#define HOST_ISUP(x)	(x == HOST_UP)

struct table_config {
	objid_t			 id;
	objid_t			 rdrid;
	u_int32_t		 flags;
	int			 check;
	char			 demote_group[IFNAMSIZ];
	char			 ifname[IFNAMSIZ];
	struct timeval		 timeout;
	in_port_t		 port;
	int			 retcode;
	int			 skip_cnt;
	char			 name[TABLE_NAME_SIZE];
	size_t			 name_len;
	char			 path[PATH_MAX];
	char			 exbuf[64];
	char			 digest[41]; /* length of sha1 digest * 2 */
	u_int8_t		 digest_type;
	enum forwardmode	 fwdmode;
};

struct table {
	TAILQ_ENTRY(table)	 entry;
	struct table_config	 conf;
	int			 up;
	int			 skipped;
	struct hostlist		 hosts;
	struct tls_config	*tls_cfg;
	char			*sendbuf;
};
TAILQ_HEAD(tablelist, table);

enum table_check {
	CHECK_NOCHECK		= 0,
	CHECK_ICMP		= 1,
	CHECK_TCP		= 2,
	CHECK_HTTP_CODE		= 3,
	CHECK_HTTP_DIGEST	= 4,
	CHECK_SEND_EXPECT	= 5,
	CHECK_SCRIPT		= 6
};

struct rdr_config {
	objid_t			 id;
	u_int32_t		 flags;
	in_port_t		 port;
	objid_t			 table_id;
	objid_t			 backup_id;
	int			 mode;
	union hashkey		 key;
	char			 name[SRV_NAME_SIZE];
	char			 tag[RD_TAG_NAME_SIZE];
	struct timeval		 timeout;
};

struct rdr {
	TAILQ_ENTRY(rdr)	 entry;
	struct rdr_config	 conf;
	struct addresslist	 virts;
	struct table		*table;
	struct table		*backup; /* use this if no host up */
	struct ctl_stats	 stats;
};
TAILQ_HEAD(rdrlist, rdr);

struct rsession {
	objid_t				 se_id;
	objid_t				 se_relayid;
	struct ctl_relay_event		 se_in;
	struct ctl_relay_event		 se_out;
	void				*se_priv;
	SIPHASH_CTX			 se_siphashctx;
	struct relay_table		*se_table;
	struct event			 se_ev;
	struct timeval			 se_timeout;
	struct timeval			 se_tv_start;
	struct timeval			 se_tv_last;
	struct event			 se_inflightevt;
	int				 se_done;
	int				 se_retry;
	int				 se_retrycount;
	int				 se_connectcount;
	int				 se_haslog;
	struct evbuffer			*se_log;
	struct relay			*se_relay;
	struct ctl_natlook		*se_cnl;
	int				 se_bnds;
	u_int16_t			 se_tag;
	u_int16_t			 se_label;

	int				 se_cid;
	pid_t				 se_pid;
	SPLAY_ENTRY(rsession)		 se_nodes;
	TAILQ_ENTRY(rsession)		 se_entry;
};
SPLAY_HEAD(session_tree, rsession);
TAILQ_HEAD(sessionlist, rsession);

enum prototype {
	RELAY_PROTO_TCP		= 0,
	RELAY_PROTO_HTTP,
	RELAY_PROTO_DNS
};

enum relay_result {
	RES_DROP		= 0,
	RES_PASS		= 1,
	RES_FAIL		= -1,
	RES_BAD			= -2,
	RES_INTERNAL		= -3
};

enum rule_action {
	RULE_ACTION_MATCH	= 0,
	RULE_ACTION_PASS,
	RULE_ACTION_BLOCK
};

struct rule_addr {
	int				 addr_af;
	struct sockaddr_storage		 addr;
	u_int8_t			 addr_mask;
	int				 addr_net;
	in_port_t			 addr_port;
};

#define RELAY_ADDR_EQ(_a, _b)						\
	((_a)->addr_mask == (_b)->addr_mask &&				\
	sockaddr_cmp((struct sockaddr *)&(_a)->addr,			\
	(struct sockaddr *)&(_b)->addr, (_a)->addr_mask) == 0)

#define RELAY_ADDR_CMP(_a, _b)						\
	sockaddr_cmp((struct sockaddr *)&(_a)->addr,			\
	(struct sockaddr *)(_b), (_a)->addr_mask)

#define RELAY_ADDR_NEQ(_a, _b)						\
	((_a)->addr_mask != (_b)->addr_mask ||				\
	sockaddr_cmp((struct sockaddr *)&(_a)->addr,			\
	(struct sockaddr *)&(_b)->addr, (_a)->addr_mask) != 0)

struct relay_rule {
	objid_t			 rule_id;
	objid_t			 rule_protoid;

	u_int			 rule_action;
#define RULE_SKIP_PROTO		 0
#define RULE_SKIP_DIR		 1
#define RULE_SKIP_AF		 2
#define RULE_SKIP_SRC		 3
#define RULE_SKIP_DST		 4
#define RULE_SKIP_METHOD	 5
#define RULE_SKIP_COUNT		 6
	struct relay_rule	*rule_skip[RULE_SKIP_COUNT];

#define RULE_FLAG_QUICK		0x01
	u_int8_t		 rule_flags;

	int			 rule_label;
	int			 rule_tag;
	int			 rule_tagged;
	enum direction		 rule_dir;
	u_int			 rule_proto;
	int			 rule_af;
	struct rule_addr	 rule_src;
	struct rule_addr	 rule_dst;
	struct relay_table	*rule_table;

	u_int			 rule_method;
	char			 rule_labelname[LABEL_NAME_SIZE];
	char			 rule_tablename[TABLE_NAME_SIZE];
	char			 rule_taggedname[TAG_NAME_SIZE];
	char			 rule_tagname[TAG_NAME_SIZE];

	struct ctl_rule		 rule_ctl;
	struct kv		 rule_kv[KEY_TYPE_MAX];
	struct kvlist		 rule_kvlist;

	TAILQ_ENTRY(relay_rule)	 rule_entry;
};
TAILQ_HEAD(relay_rules, relay_rule);

#define TCPFLAG_NODELAY		0x01
#define TCPFLAG_NNODELAY	0x02
#define TCPFLAG_SACK		0x04
#define TCPFLAG_NSACK		0x08
#define TCPFLAG_BUFSIZ		0x10
#define TCPFLAG_IPTTL		0x20
#define TCPFLAG_IPMINTTL	0x40
#define TCPFLAG_NSPLICE		0x80
#define TCPFLAG_DEFAULT		0x00

#define TCPFLAG_BITS						\
	"\10\01NODELAY\02NO_NODELAY\03SACK\04NO_SACK"		\
	"\05SOCKET_BUFFER_SIZE\06IP_TTL\07IP_MINTTL\10NO_SPLICE"

#define TLSFLAG_SSLV3				0x01
#define TLSFLAG_TLSV1_0				0x02
#define TLSFLAG_TLSV1_1				0x04
#define TLSFLAG_TLSV1_2				0x08
#define TLSFLAG_TLSV1				0x0e
#define TLSFLAG_VERSION				0x1f
#define TLSFLAG_CIPHER_SERVER_PREF		0x20
#define TLSFLAG_CLIENT_RENEG			0x40
#define TLSFLAG_DEFAULT				\
	(TLSFLAG_TLSV1_2|TLSFLAG_CIPHER_SERVER_PREF)

#define TLSFLAG_BITS						\
	"\06\01sslv3\02tlsv1.0\03tlsv1.1\04tlsv1.2"	\
	"\06cipher-server-preference\07client-renegotiation"

#define TLSCIPHERS_DEFAULT	"HIGH:!aNULL"
#define TLSECDHCURVE_DEFAULT	"auto"
#define TLSDHPARAM_DEFAULT	"none"

struct relay_ticket_key {
	uint32_t	tt_keyrev;
	unsigned char	tt_key[TLS_TICKET_KEY_SIZE];
};
#define	TLS_SESSION_LIFETIME	(2 * 3600)

struct protocol {
	objid_t			 id;
	u_int32_t		 flags;
	u_int8_t		 tcpflags;
	int			 tcpbufsiz;
	int			 tcpbacklog;
	u_int8_t		 tcpipttl;
	u_int8_t		 tcpipminttl;
	u_int8_t		 tlsflags;
	char			 tlsciphers[768];
	char			 tlsdhparams[128];
	char			 tlsecdhcurve[128];
	char			 tlsca[PATH_MAX];
	char			 tlscacert[PATH_MAX];
	char			 tlscakey[PATH_MAX];
	char			*tlscapass;
	char			 name[MAX_NAME_SIZE];
	int			 tickets;
	enum prototype		 type;
	char			*style;

	int			(*cmp)(struct rsession *, struct rsession *);
	void			*(*validate)(struct rsession *, struct relay *,
				    struct sockaddr_storage *,
				    u_int8_t *, size_t);
	int			(*request)(struct rsession *);
	void			(*close)(struct rsession *);

	struct relay_rules	 rules;
	int			 rulecount;

	TAILQ_ENTRY(protocol)	 entry;
};
TAILQ_HEAD(protolist, protocol);

struct relay_table {
	struct table		*rlt_table;
	u_int32_t		 rlt_flags;
	int			 rlt_mode;
	u_int32_t		 rlt_index;
	struct host		*rlt_host[RELAY_MAXHOSTS];
	int			 rlt_nhosts;
	TAILQ_ENTRY(relay_table) rlt_entry;
};
TAILQ_HEAD(relaytables, relay_table);

struct ca_pkey {
	char			 pkey_hash[TLS_CERT_HASH_SIZE];
	EVP_PKEY		*pkey;
	TAILQ_ENTRY(ca_pkey)	 pkey_entry;
};
TAILQ_HEAD(ca_pkeylist, ca_pkey);

struct relay_config {
	objid_t			 id;
	u_int32_t		 flags;
	objid_t			 proto;
	char			 name[HOST_NAME_MAX+1];
	in_port_t		 port;
	in_port_t		 dstport;
	int			 dstretry;
	struct sockaddr_storage	 ss;
	struct sockaddr_storage	 dstss;
	struct sockaddr_storage	 dstaf;
	struct timeval		 timeout;
	enum forwardmode	 fwdmode;
	union hashkey		 hashkey;
	off_t			 tls_cert_len;
	off_t			 tls_key_len;
	objid_t			 tls_keyid;
	off_t			 tls_ca_len;
	off_t			 tls_cacert_len;
	off_t			 tls_cakey_len;
	objid_t			 tls_cakeyid;
};

struct relay {
	TAILQ_ENTRY(relay)	 rl_entry;
	struct relay_config	 rl_conf;

	int			 rl_up;
	struct protocol		*rl_proto;
	int			 rl_s;
	struct bufferevent	*rl_bev;

	int			 rl_dsts;
	struct bufferevent	*rl_dstbev;

	struct relaytables	 rl_tables;

	struct event		 rl_ev;
	struct event		 rl_evt;

	struct tls_config	*rl_tls_cfg;
	struct tls_config	*rl_tls_client_cfg;
	struct tls		*rl_tls_ctx;

	char			*rl_tls_cert;
	char			*rl_tls_key;
	EVP_PKEY		*rl_tls_pkey;
	char			*rl_tls_ca;
	char			*rl_tls_cacert;
	X509			*rl_tls_cacertx509;
	char			*rl_tls_cakey;
	EVP_PKEY		*rl_tls_capkey;

	struct ctl_stats	 rl_stats[PROC_MAX_INSTANCES + 1];

	struct session_tree	 rl_sessions;
};
TAILQ_HEAD(relaylist, relay);

enum dstmode {
	RELAY_DSTMODE_LOADBALANCE = 0,
	RELAY_DSTMODE_ROUNDROBIN,
	RELAY_DSTMODE_HASH,
	RELAY_DSTMODE_SRCHASH,
	RELAY_DSTMODE_LEASTSTATES,
	RELAY_DSTMODE_RANDOM
};
#define RELAY_DSTMODE_DEFAULT		RELAY_DSTMODE_ROUNDROBIN

struct netroute_config {
	objid_t			 id;
	struct sockaddr_storage	 ss;
	int			 prefixlen;
	objid_t			 routerid;
};

struct netroute {
	struct netroute_config	 nr_conf;

	TAILQ_ENTRY(netroute)	 nr_entry;
	TAILQ_ENTRY(netroute)	 nr_route;

	struct router		*nr_router;
};
TAILQ_HEAD(netroutelist, netroute);

struct router_config {
	objid_t			 id;
	u_int32_t		 flags;
	char			 name[HOST_NAME_MAX+1];
	char			 label[RT_LABEL_SIZE];
	int			 nroutes;
	objid_t			 gwtable;
	in_port_t		 gwport;
	int			 rtable;
	int			 af;
};

struct router {
	struct router_config	 rt_conf;

	struct table		*rt_gwtable;
	struct netroutelist	 rt_netroutes;

	TAILQ_ENTRY(router)	 rt_entry;
};
TAILQ_HEAD(routerlist, router);

struct ctl_netroute {
	int			up;
	struct host_config	host;
	struct netroute_config	nr;
	struct router_config	rt;
};

/* initially control.h */
struct control_sock {
	const char	*cs_name;
	struct event	 cs_ev;
	struct event	 cs_evt;
	int		 cs_fd;
	int		 cs_restricted;
	void		*cs_env;

	TAILQ_ENTRY(control_sock) cs_entry;
};
TAILQ_HEAD(control_socks, control_sock);

struct {
	struct event	 ev;
	int		 fd;
} control_state;

struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	struct privsep_proc	*proc;
	void			*data;
	short			 events;
};

#define IMSG_SIZE_CHECK(imsg, p) do {				\
	if (IMSG_DATA_SIZE(imsg) < sizeof(*p))			\
		fatalx("bad length imsg received");		\
} while (0)
#define IMSG_DATA_SIZE(imsg)	((imsg)->hdr.len - IMSG_HEADER_SIZE)

struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	 entry;
	u_int8_t		 flags;
	u_int			 waiting;
#define CTL_CONN_NOTIFY		 0x01
	struct imsgev		 iev;

};
TAILQ_HEAD(ctl_connlist, ctl_conn);

enum imsg_type {
	IMSG_NONE,
	IMSG_CTL_OK,		/* answer to relayctl requests */
	IMSG_CTL_FAIL,
	IMSG_CTL_VERBOSE,
	IMSG_CTL_PROCFD,
	IMSG_CTL_END,
	IMSG_CTL_RDR,
	IMSG_CTL_TABLE,
	IMSG_CTL_HOST,
	IMSG_CTL_RELAY,
	IMSG_CTL_SESSION,
	IMSG_CTL_ROUTER,
	IMSG_CTL_NETROUTE,
	IMSG_CTL_TABLE_CHANGED,
	IMSG_CTL_PULL_RULESET,
	IMSG_CTL_PUSH_RULESET,
	IMSG_CTL_SHOW_SUM,	/* relayctl requests */
	IMSG_CTL_RDR_ENABLE,
	IMSG_CTL_RDR_DISABLE,
	IMSG_CTL_TABLE_ENABLE,
	IMSG_CTL_TABLE_DISABLE,
	IMSG_CTL_HOST_ENABLE,
	IMSG_CTL_HOST_DISABLE,
	IMSG_CTL_SHUTDOWN,
	IMSG_CTL_START,
	IMSG_CTL_RELOAD,
	IMSG_CTL_RESET,
	IMSG_CTL_POLL,
	IMSG_CTL_NOTIFY,
	IMSG_CTL_RDR_STATS,
	IMSG_CTL_RELAY_STATS,
	IMSG_RDR_ENABLE,	/* notifies from pfe to hce */
	IMSG_RDR_DISABLE,
	IMSG_TABLE_ENABLE,
	IMSG_TABLE_DISABLE,
	IMSG_HOST_ENABLE,
	IMSG_HOST_DISABLE,
	IMSG_HOST_STATUS,	/* notifies from hce to pfe */
	IMSG_SYNC,
	IMSG_NATLOOK,
	IMSG_DEMOTE,
	IMSG_STATISTICS,
	IMSG_SCRIPT,
	IMSG_SNMPSOCK,
	IMSG_BINDANY,
	IMSG_RTMSG,		/* from pfe to parent */
	IMSG_CFG_TABLE,		/* configuration from parent */
	IMSG_CFG_HOST,
	IMSG_CFG_RDR,
	IMSG_CFG_VIRT,
	IMSG_CFG_ROUTER,
	IMSG_CFG_ROUTE,
	IMSG_CFG_PROTO,
	IMSG_CFG_RULE,
	IMSG_CFG_RELAY,
	IMSG_CFG_RELAY_TABLE,
	IMSG_CFG_DONE,
	IMSG_CA_PRIVENC,
	IMSG_CA_PRIVDEC,
	IMSG_SESS_PUBLISH,	/* from relay to hce */
	IMSG_SESS_UNPUBLISH,
	IMSG_TLSTICKET_REKEY
};

enum privsep_procid {
	PROC_ALL	= -1,
	PROC_PARENT	= 0,
	PROC_HCE,
	PROC_RELAY,
	PROC_PFE,
	PROC_CA,
	PROC_MAX
} privsep_process;

/* Attach the control socket to the following process */
#define PROC_CONTROL	PROC_PFE

struct privsep_pipes {
	int				*pp_pipes[PROC_MAX];
};

struct privsep {
	struct privsep_pipes		*ps_pipes[PROC_MAX];
	struct privsep_pipes		*ps_pp;

	struct imsgev			*ps_ievs[PROC_MAX];
	const char			*ps_title[PROC_MAX];
	u_int8_t			 ps_what[PROC_MAX];

	u_int				 ps_instances[PROC_MAX];
	u_int				 ps_instance;

	struct control_sock		 ps_csock;
	struct control_socks		 ps_rcsocks;

	/* Event and signal handlers */
	struct event			 ps_evsigint;
	struct event			 ps_evsigterm;
	struct event			 ps_evsigchld;
	struct event			 ps_evsighup;
	struct event			 ps_evsigpipe;
	struct event			 ps_evsigusr1;

	int				 ps_noaction;
	struct passwd			*ps_pw;
	struct relayd			*ps_env;
};

struct privsep_proc {
	const char		*p_title;
	enum privsep_procid	 p_id;
	int			(*p_cb)(int, struct privsep_proc *,
				    struct imsg *);
	void			(*p_init)(struct privsep *,
				    struct privsep_proc *);
	const char		*p_chroot;
	struct privsep		*p_ps;
	void			(*p_shutdown)(void);
	struct passwd		*p_pw;
};

struct privsep_fd {
	enum privsep_procid		 pf_procid;
	unsigned int			 pf_instance;
};

struct relayd_config {
	char			 tls_sid[SSL_MAX_SID_CTX_LENGTH];
	char			 snmp_path[PATH_MAX];
	struct timeval		 interval;
	struct timeval		 timeout;
	struct timeval		 statinterval;
	u_int16_t		 prefork_relay;
	u_int16_t		 opts;
	u_int32_t		 flags;
};

struct pfdata {
	int			 dev;
	struct pf_anchor	*anchor;
	struct pfioc_trans	 pft;
	struct pfioc_trans_e	 pfte;
	u_int8_t		 pfused;
};

struct relayd {
	struct relayd_config	 sc_conf;
	const char		*sc_conffile;
	struct pfdata		*sc_pf;
	int			 sc_rtsock;
	int			 sc_rtseq;
	int			 sc_tablecount;
	int			 sc_rdrcount;
	int			 sc_protocount;
	int			 sc_relaycount;
	int			 sc_routercount;
	int			 sc_routecount;
	struct table		 sc_empty_table;
	struct protocol		 sc_proto_default;
	struct event		 sc_ev;
	struct tablelist	*sc_tables;
	struct hostlist		 sc_hosts;
	struct rdrlist		*sc_rdrs;
	struct protolist	*sc_protos;
	struct relaylist	*sc_relays;
	struct routerlist	*sc_rts;
	struct netroutelist	*sc_routes;
	struct ca_pkeylist	*sc_pkeys;
	struct sessionlist	 sc_sessions;
	char			 sc_demote_group[IFNAMSIZ];
	u_int16_t		 sc_id;
	int			 sc_rtable;

	struct event		 sc_statev;

	int			 sc_snmp;
	struct event		 sc_snmpto;
	struct event		 sc_snmpev;

	int			 sc_has_icmp;
	int			 sc_has_icmp6;
	struct ctl_icmp_event	 sc_icmp_send;
	struct ctl_icmp_event	 sc_icmp_recv;
	struct ctl_icmp_event	 sc_icmp6_send;
	struct ctl_icmp_event	 sc_icmp6_recv;

	struct relay_ticket_key	 sc_ticket;

	struct privsep		*sc_ps;
	int			 sc_reload;
};

#define RELAYD_OPT_VERBOSE		0x01
#define RELAYD_OPT_NOACTION		0x04
#define RELAYD_OPT_LOGUPDATE		0x08
#define RELAYD_OPT_LOGNOTIFY		0x10
#define RELAYD_OPT_LOGALL		0x18

/* control.c */
int	 control_init(struct privsep *, struct control_sock *);
int	 control_listen(struct control_sock *);
void	 control_cleanup(struct control_sock *);
void	 control_dispatch_imsg(int, short, void *);
void	 control_imsg_forward(struct privsep *ps, struct imsg *);
struct ctl_conn	*
	 control_connbyfd(int);

extern  struct ctl_connlist ctl_conns;

/* parse.y */
int	 parse_config(const char *, struct relayd *);
int	 load_config(const char *, struct relayd *);
int	 cmdline_symset(char *);

/* util.c */
const char *host_error(enum host_error);
const char *host_status(enum host_status);
const char *table_check(enum table_check);
const char *print_availability(u_long, u_long);
const char *print_host(struct sockaddr_storage *, char *, size_t);
const char *print_time(struct timeval *, struct timeval *, char *, size_t);
const char *printb_flags(const u_int32_t, const char *);
void	 getmonotime(struct timeval *);

/* pfe.c */
void	 pfe(struct privsep *, struct privsep_proc *);
void	 show(struct ctl_conn *);
void	 show_sessions(struct ctl_conn *);
int	 enable_rdr(struct ctl_conn *, struct ctl_id *);
int	 enable_table(struct ctl_conn *, struct ctl_id *);
int	 enable_host(struct ctl_conn *, struct ctl_id *, struct host *);
int	 disable_rdr(struct ctl_conn *, struct ctl_id *);
int	 disable_table(struct ctl_conn *, struct ctl_id *);
int	 disable_host(struct ctl_conn *, struct ctl_id *, struct host *);

/* pfe_filter.c */
void	 init_tables(struct relayd *);
void	 flush_table(struct relayd *, struct rdr *);
void	 sync_table(struct relayd *, struct rdr *, struct table *);
void	 sync_ruleset(struct relayd *, struct rdr *, int);
void	 flush_rulesets(struct relayd *);
int	 natlook(struct relayd *, struct ctl_natlook *);
u_int64_t
	 check_table(struct relayd *, struct rdr *, struct table *);

/* pfe_route.c */
void	 init_routes(struct relayd *);
void	 sync_routes(struct relayd *, struct router *);
int	 pfe_route(struct relayd *, struct ctl_netroute *);

/* hce.c */
void	 hce(struct privsep *, struct privsep_proc *);
void	 hce_notify_done(struct host *, enum host_error);

/* relay.c */
void	 relay(struct privsep *, struct privsep_proc *);
int	 relay_privinit(struct relay *);
void	 relay_notify_done(struct host *, const char *);
int	 relay_session_cmp(struct rsession *, struct rsession *);
int	 relay_load_certfiles(struct relay *);
void	 relay_close(struct rsession *, const char *);
void	 relay_natlook(int, short, void *);
void	 relay_session(struct rsession *);
int	 relay_from_table(struct rsession *);
int	 relay_socket_af(struct sockaddr_storage *, in_port_t);
in_port_t
	 relay_socket_getport(struct sockaddr_storage *);
int	 relay_cmp_af(struct sockaddr_storage *,
	    struct sockaddr_storage *);
void	 relay_write(struct bufferevent *, void *);
void	 relay_read(struct bufferevent *, void *);
int	 relay_splice(struct ctl_relay_event *);
int	 relay_splicelen(struct ctl_relay_event *);
int	 relay_spliceadjust(struct ctl_relay_event *);
void	 relay_error(struct bufferevent *, short, void *);
int	 relay_preconnect(struct rsession *);
int	 relay_connect(struct rsession *);
void	 relay_connected(int, short, void *);
void	 relay_bindanyreq(struct rsession *, in_port_t, int);
void	 relay_bindany(int, short, void *);
void	 relay_dump(struct ctl_relay_event *, const void *, size_t);
int	 relay_bufferevent_add(struct event *, int);
int	 relay_bufferevent_print(struct ctl_relay_event *, const char *);
int	 relay_bufferevent_write_buffer(struct ctl_relay_event *,
	    struct evbuffer *);
int	 relay_bufferevent_write_chunk(struct ctl_relay_event *,
	    struct evbuffer *, size_t);
int	 relay_bufferevent_write(struct ctl_relay_event *,
	    void *, size_t);
int	 relay_test(struct protocol *, struct ctl_relay_event *);
void	 relay_calc_skip_steps(struct relay_rules *);
void	 relay_match(struct kvlist *, struct kv *, struct kv *,
	    struct kvtree *);
void	 relay_session_insert(struct rsession *);
void	 relay_session_remove(struct rsession *);
void	 relay_session_publish(struct rsession *);
void	 relay_session_unpublish(struct rsession *);

SPLAY_PROTOTYPE(session_tree, rsession, se_nodes, relay_session_cmp);

/* relay_http.c */
void	 relay_http(struct relayd *);
void	 relay_http_init(struct relay *);
void	 relay_abort_http(struct rsession *, u_int, const char *,
	    u_int16_t);
void	 relay_read_http(struct bufferevent *, void *);
void	 relay_close_http(struct rsession *);
u_int	 relay_httpmethod_byname(const char *);
const char
	*relay_httpmethod_byid(u_int);
const char
	*relay_httperror_byid(u_int);
int	 relay_httpdesc_init(struct ctl_relay_event *);
ssize_t	 relay_http_time(time_t, char *, size_t);

/* relay_udp.c */
void	 relay_udp_privinit(struct relay *);
void	 relay_udp_init(struct relayd *, struct relay *);
int	 relay_udp_bind(struct sockaddr_storage *, in_port_t,
	    struct protocol *);
void	 relay_udp_server(int, short, void *);

/* check_icmp.c */
void	 icmp_init(struct relayd *);
void	 schedule_icmp(struct relayd *, struct host *);
void	 check_icmp(struct relayd *, struct timeval *);

/* check_tcp.c */
void	 check_tcp(struct ctl_tcp_event *);

/* check_tls.c */
void	 check_tls(struct ctl_tcp_event *);

/* check_script.c */
void	 check_script(struct relayd *, struct host *);
void	 script_done(struct relayd *, struct ctl_script *);
int	 script_exec(struct relayd *, struct ctl_script *);

/* ssl.c */
void	 ssl_init(struct relayd *);
char	*ssl_load_key(struct relayd *, const char *, off_t *, char *);
uint8_t *ssl_update_certificate(const uint8_t *, size_t, EVP_PKEY *,
	    EVP_PKEY *, X509 *, size_t *);
int	 ssl_load_pkey(void *, char *, off_t, X509 **, EVP_PKEY **);
int	 ssl_ctx_fake_private_key(char *, off_t, const char **);

/* ca.c */
void	 ca(struct privsep *, struct privsep_proc *);
void	 ca_engine_init(struct relayd *);

/* relayd.c */
struct host	*host_find(struct relayd *, objid_t);
struct table	*table_find(struct relayd *, objid_t);
struct rdr	*rdr_find(struct relayd *, objid_t);
struct netroute	*route_find(struct relayd *, objid_t);
struct router	*router_find(struct relayd *, objid_t);
struct host	*host_findbyname(struct relayd *, const char *);
struct table	*table_findbyname(struct relayd *, const char *);
struct table	*table_findbyconf(struct relayd *, struct table *);
struct rdr	*rdr_findbyname(struct relayd *, const char *);
void		 event_again(struct event *, int, short,
		    void (*)(int, short, void *),
		    struct timeval *, struct timeval *, void *);
struct relay	*relay_find(struct relayd *, objid_t);
struct protocol	*proto_find(struct relayd *, objid_t);
struct rsession	*session_find(struct relayd *, objid_t);
struct relay	*relay_findbyname(struct relayd *, const char *);
struct relay	*relay_findbyaddr(struct relayd *, struct relay_config *);
EVP_PKEY	*pkey_find(struct relayd *, char *hash);
struct ca_pkey	*pkey_add(struct relayd *, EVP_PKEY *, char *hash);
int		 expand_string(char *, size_t, const char *, const char *);
void		 translate_string(char *);
void		 purge_key(char **, off_t);
void		 purge_table(struct relayd *, struct tablelist *,
		    struct table *);
void		 purge_relay(struct relayd *, struct relay *);
char		*digeststr(enum digest_type, const u_int8_t *, size_t, char *);
const char	*canonicalize_host(const char *, char *, size_t);
int		 parse_url(const char *, char **, char **, char **);
int		 map6to4(struct sockaddr_storage *);
int		 map4to6(struct sockaddr_storage *, struct sockaddr_storage *);
void		 imsg_event_add(struct imsgev *);
int		 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
		    pid_t, int, void *, u_int16_t);
void		 socket_rlimit(int);
char		*get_string(u_int8_t *, size_t);
void		*get_data(u_int8_t *, size_t);
int		 sockaddr_cmp(struct sockaddr *, struct sockaddr *, int);
struct in6_addr *prefixlen2mask6(u_int8_t, u_int32_t *);
u_int32_t	 prefixlen2mask(u_int8_t);
int		 accept_reserve(int, struct sockaddr *, socklen_t *, int,
		     volatile int *);
struct kv	*kv_add(struct kvtree *, char *, char *, int);
int		 kv_set(struct kv *, char *, ...);
int		 kv_setkey(struct kv *, char *, ...);
void		 kv_delete(struct kvtree *, struct kv *);
struct kv	*kv_extend(struct kvtree *, struct kv *, char *);
void		 kv_purge(struct kvtree *);
void		 kv_free(struct kv *);
struct kv	*kv_inherit(struct kv *, struct kv *);
void		 relay_log(struct rsession *, char *);
int		 kv_log(struct rsession *, struct kv *, u_int16_t,
		     enum direction);
struct kv	*kv_find(struct kvtree *, struct kv *);
int		 kv_cmp(struct kv *, struct kv *);
int		 rule_add(struct protocol *, struct relay_rule *, const char
		     *);
void		 rule_delete(struct relay_rules *, struct relay_rule *);
void		 rule_free(struct relay_rule *);
struct relay_rule
		*rule_inherit(struct relay_rule *);
void		 rule_settable(struct relay_rules *, struct relay_table *);
RB_PROTOTYPE(kvtree, kv, kv_node, kv_cmp);

/* carp.c */
int	 carp_demote_init(char *, int);
void	 carp_demote_shutdown(void);
int	 carp_demote_get(char *);
int	 carp_demote_set(char *, int);
int	 carp_demote_reset(char *, int);

/* name2id.c */
u_int16_t	 label_name2id(const char *);
const char	*label_id2name(u_int16_t);
void		 label_unref(u_int16_t);
void		 label_ref(u_int16_t);
u_int16_t	 tag_name2id(const char *);
const char	*tag_id2name(u_int16_t);
void		 tag_unref(u_int16_t);
void		 tag_ref(u_int16_t);

/* snmp.c */
void	 snmp_init(struct relayd *, enum privsep_procid);
void	 snmp_setsock(struct relayd *, enum privsep_procid);
int	 snmp_getsock(struct relayd *, struct imsg *);
void	 snmp_hosttrap(struct relayd *, struct table *, struct host *);

/* shuffle.c */
void		shuffle_init(struct shuffle *);
u_int16_t	shuffle_generate16(struct shuffle *);

/* log.c */
void	log_init(int, int);
void	log_procinit(const char *);
void	log_setverbose(int);
int	log_getverbose(void);
void	log_warn(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list)
	    __attribute__((__format__ (printf, 2, 0)));
__dead void fatal(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));

/* proc.c */
enum privsep_procid
	    proc_getid(struct privsep_proc *, unsigned int, const char *);
int	 proc_flush_imsg(struct privsep *, enum privsep_procid, int);
void	 proc_init(struct privsep *, struct privsep_proc *, unsigned int,
	    int, char **, enum privsep_procid);
void	 proc_kill(struct privsep *);
void	 proc_connect(struct privsep *);
void	 proc_dispatch(int, short event, void *);
void	 proc_run(struct privsep *, struct privsep_proc *,
	    struct privsep_proc *, unsigned int,
	    void (*)(struct privsep *, struct privsep_proc *, void *), void *);
void	 proc_range(struct privsep *, enum privsep_procid, int *, int *);
int	 proc_compose_imsg(struct privsep *, enum privsep_procid, int,
	    u_int16_t, u_int32_t, int, void *, u_int16_t);
int	 proc_compose(struct privsep *, enum privsep_procid,
	    uint16_t, void *, uint16_t);
int	 proc_composev_imsg(struct privsep *, enum privsep_procid, int,
	    u_int16_t, u_int32_t, int, const struct iovec *, int);
int	 proc_composev(struct privsep *, enum privsep_procid,
	    uint16_t, const struct iovec *, int);
int	 proc_forward_imsg(struct privsep *, struct imsg *,
	    enum privsep_procid, int);
struct imsgbuf *
	 proc_ibuf(struct privsep *, enum privsep_procid, int);
struct imsgev *
	 proc_iev(struct privsep *, enum privsep_procid, int);
void	 imsg_event_add(struct imsgev *);
int	 imsg_compose_event(struct imsgev *, uint16_t, uint32_t,
	    pid_t, int, void *, uint16_t);
int	 imsg_composev_event(struct imsgev *, uint16_t, uint32_t,
	    pid_t, int, const struct iovec *, int);

/* config.c */
int	 config_init(struct relayd *);
void	 config_purge(struct relayd *, u_int);
int	 config_setreset(struct relayd *, u_int);
int	 config_getreset(struct relayd *, struct imsg *);
int	 config_getcfg(struct relayd *, struct imsg *);
int	 config_settable(struct relayd *, struct table *);
int	 config_gettable(struct relayd *, struct imsg *);
int	 config_gethost(struct relayd *, struct imsg *);
int	 config_setrdr(struct relayd *, struct rdr *);
int	 config_getrdr(struct relayd *, struct imsg *);
int	 config_getvirt(struct relayd *, struct imsg *);
int	 config_setrt(struct relayd *, struct router *);
int	 config_getrt(struct relayd *, struct imsg *);
int	 config_getroute(struct relayd *, struct imsg *);
int	 config_setproto(struct relayd *, struct protocol *);
int	 config_getproto(struct relayd *, struct imsg *);
int	 config_setrule(struct relayd *, struct protocol *);
int	 config_getrule(struct relayd *, struct imsg *);
int	 config_setrelay(struct relayd *, struct relay *);
int	 config_getrelay(struct relayd *, struct imsg *);
int	 config_getrelaytable(struct relayd *, struct imsg *);

#endif /* RELAYD_H */
@


1.240
log
@Migrate relayd to use libtls for TLS. Still does the TLS privsep via the
engine but at least we can use a sane API for new features.
Going in now so it is possible to work with this in tree.
General agreement at d2k17.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.239 2017/02/02 08:24:16 reyk Exp $	*/
d1221 2
a1222 2
void	 relay_udp_privinit(struct relayd *, struct relay *);
void	 relay_udp_init(struct relay *);
@


1.239
log
@Disable client-initiated TLS renegotiation by default.

It is rarely needed and imposes a light DoS risk.  LibreSSL's libssl
allows to turn it off with a simple SSL_OP_NO_CLIENT_RENEGOTIATION
option instead of the complicated implementation that was used before.
It now turns it off completely instead of allowing one initial
client-initiated renegotiation.

It can still be enabled with "tls client-renegotiation".

ok benno@@ beck@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.238 2017/01/24 10:49:14 benno Exp $	*/
d40 1
d65 1
d171 1
a171 1
	SSL			*ssl;	/* libssl object */
d197 2
a198 1
	SSL			*ssl;	/* libssl object */
d200 2
a201 1
	X509			*tlscert;
a211 3
	u_int8_t		*buf;
	int			 buflen;

d247 1
a247 1
	objid_t			 cko_id;
d500 1
a500 1
	SSL_CTX			*ssl_ctx;	/* libssl context */
d684 2
a685 1
#define TLSECDHCURVE_DEFAULT	NID_X9_62_prime256v1
d687 3
a689 10
#define TLSDHPARAMS_NONE	0
#define TLSDHPARAMS_DEFAULT	0
#define TLSDHPARAMS_MIN		1024

struct tls_ticket {
	/* The key, aes key and hmac key must be 16 bytes / 128bits */
	unsigned char	tt_key_name[16];
	unsigned char	tt_aes_key[16];
	unsigned char	tt_hmac_key[16];
	int		tt_backup;
d691 1
a691 1
#define	TLS_TICKET_REKEY_TIME	(2 * 3600)
d703 2
a704 2
	int			 tlsdhparams;
	int			 tlsecdhcurve;
d740 1
a740 1
	objid_t			 pkey_id;
d786 3
a788 1
	SSL_CTX			*rl_ssl_ctx;	/* libssl context */
a790 1
	X509			*rl_tls_x509;
d1091 2
a1094 3

	struct tls_ticket	 sc_tls_ticket;
	struct tls_ticket	 sc_tls_ticket_bak;
d1235 3
a1244 3
void	 ssl_transaction(struct ctl_tcp_event *);
SSL_CTX	*ssl_ctx_create(struct relayd *);
void	 ssl_error(const char *, const char *);
d1246 4
a1249 5
X509	*ssl_update_certificate(X509 *, EVP_PKEY *, EVP_PKEY *, X509 *);
int	 ssl_load_pkey(const void *, size_t, char *, off_t,
	    X509 **, EVP_PKEY **);
int	 ssl_ctx_fake_private_key(SSL_CTX *, const void *, size_t,
	    char *, off_t, X509 **, EVP_PKEY **);
d1273 2
a1274 2
EVP_PKEY	*pkey_find(struct relayd *, objid_t);
struct ca_pkey	*pkey_add(struct relayd *, EVP_PKEY *, objid_t);
@


1.238
log
@move the opening of /dev/pf from the parent process to the pfe process
where it is used.
Currently pf is opened on every reload, that will no longer be
possible in the future with pledged programms that do ioctls.
This prepares relayd for that change.

ok deraadt@@, meinetwegen reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.237 2017/01/09 14:49:21 reyk Exp $	*/
a178 7
enum tlsreneg_state {
	TLSRENEG_INIT		= 0,	/* first/next negotiation is allowed */
	TLSRENEG_ALLOW		= 1,	/* all (re-)negotiations are allowed */
	TLSRENEG_DENY		= 2,	/* next renegotiation must be denied */
	TLSRENEG_ABORT		= 3	/* the connection should be aborted */
};

a197 1
	enum tlsreneg_state	 tlsreneg_state;
d676 1
a676 1
	(TLSFLAG_TLSV1_2|TLSFLAG_CIPHER_SERVER_PREF|TLSFLAG_CLIENT_RENEG)
@


1.237
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.236 2016/11/24 21:01:18 reyk Exp $	*/
d31 1
d1054 8
a1153 1
void	 init_filter(struct relayd *, int);
@


1.236
log
@The new fork+exec mode used too many fds in the parent process on
startup, for a short time, so we needed a rlimit hack in relayd.c.
Sync the fix from httpd: rzalamena@@ has fixed proc.c and I added the
proc_flush_imsg() mechanism that makes sure that each fd is
immediately closed after forwarding it to a child process instead of
queueing it up.

OK rzalamena@@ jca@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.235 2016/10/05 16:58:19 reyk Exp $	*/
d1355 2
a1356 1
void	log_verbose(int);
@


1.235
log
@sync proc.c with vmd: add p_pw to specify a non-standard user for a process.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.234 2016/09/28 12:16:44 reyk Exp $	*/
d1376 1
@


1.234
log
@sync proc.c incl. the p_env removal
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.233 2016/09/03 14:44:21 reyk Exp $	*/
d1034 1
@


1.233
log
@Replace [RELAY|SERVER]_MAXPROC with the new PROC_MAX_INSTANCES
variable and limit it from 128 to 32 instances (the old value).
While here, move a few PROC_ defines around.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.232 2016/09/03 14:09:04 reyk Exp $	*/
a1030 1
	void			(*p_shutdown)(void);
d1033 1
a1033 1
	struct relayd		*p_env;
@


1.232
log
@Use the fork+exec privsep model in relayd; based on rzalamena@@'s work
for httpd with some (current and previous) changes for relayd.  Once
again, both daemons now share the same proc.c where most of the
privsep "magic" happens.

OK benno@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.231 2016/09/02 16:14:09 reyk Exp $	*/
a71 1
#define RELAY_MAXPROC		32
d97 3
d810 1
a810 1
	struct ctl_stats	 rl_stats[RELAY_MAXPROC + 1];
a991 5

/* Define default parent socket number */
#define PARENT_SOCK_FILENO	3

#define PROC_MAX_INSTANCES	128
@


1.231
log
@Move snmp options into struct relayd_config and delay start of the
snmp subsystem until the configuration is done.

OK benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.230 2016/09/02 14:45:51 reyk Exp $	*/
d918 1
d991 5
d1040 5
d1377 4
a1380 1
void	 proc_init(struct privsep *, struct privsep_proc *, u_int);
d1382 1
a1382 1
void	 proc_listen(struct privsep *, struct privsep_proc *, size_t);
d1385 1
a1385 1
	    struct privsep_proc *, u_int,
d1394 2
a1397 2
int	 proc_composev(struct privsep *, enum privsep_procid,
	    uint16_t, const struct iovec *, int);
d1403 3
a1405 3
int	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, void *, u_int16_t);
int	 imsg_composev_event(struct imsgev *, u_int16_t, u_int32_t,
@


1.230
log
@Split "struct relayd" into two structs: "struct relayd" and "struct
relayd_config".  This way we can send all the relevant global
configuration to the children, not just the flags and the opts.

With input from and
OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.229 2016/09/02 12:12:51 reyk Exp $	*/
d387 1
d394 2
a395 1
	"\30MATCH\31DIVERT\32SCRIPT\33TLS_INSPECT\34HASHKEY"
d1036 1
a1075 2
	const char		*sc_snmp_path;
	int			 sc_snmp_flags;
a1091 2

#define	FSNMP_TRAPONLY			0x01
@


1.229
log
@As done in httpd, remove ps_ninstances and p_instance.

OK benno@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.228 2016/09/02 11:51:50 reyk Exp $	*/
a112 5
struct ctl_flags {
	u_int8_t	 cf_opts;
	u_int32_t	 cf_flags;
};

d1032 10
d1043 1
a1043 2
	u_int8_t		 sc_opts;
	u_int32_t		 sc_flags;
a1053 2
	struct timeval		 sc_interval;
	struct timeval		 sc_timeout;
a1065 1
	u_int16_t		 sc_prefork_relay;
a1070 1
	struct timeval		 sc_statinterval;
a1087 1
	char			 sc_tls_sid[SSL_MAX_SID_CTX_LENGTH];
@


1.228
log
@Terminate relayd using the socket status instead of watching SIGCHLD
or killing child processes. - Based on rzalamena@@'s diff for httpd.

OK deraadt@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.227 2016/09/01 10:49:48 claudio Exp $	*/
a1005 1
	u_int				 ps_ninstances;
a1031 1
	u_int			 p_instance;
d1106 1
a1106 1
void	 control_imsg_forward(struct imsg *);
@


1.227
log
@Switch from the not really working session cache (because of the multiprocess
nature of relayd) to tls session tickets to do TLS session resumption.
TLS session tickets do not need to store SSL session data in the server but
instead send an encrypted ticket to the clients that allows to resume the
session. This is mostly stateless (apart from the encryption keys).
relayd now ensures that all relay processes use the same key to encrypt
the tickets. Keys are rotated every 2h and there is a primary and backup key.
The tls session timeout is set to 2h to hint to the clients how long the
session tickets is supposed to be alive.
Input and OK benno@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.226 2016/09/01 10:40:38 claudio Exp $	*/
a1002 1
	pid_t				 ps_pid[PROC_MAX];
d1030 1
a1030 1
	pid_t			(*p_init)(struct privsep *,
d1130 1
a1130 1
pid_t	 pfe(struct privsep *, struct privsep_proc *);
d1157 1
a1157 1
pid_t	 hce(struct privsep *, struct privsep_proc *);
d1161 1
a1161 1
pid_t	 relay(struct privsep *, struct privsep_proc *);
d1254 1
a1254 1
pid_t	 ca(struct privsep *, struct privsep_proc *);
d1374 1
a1374 1
pid_t	 proc_run(struct privsep *, struct privsep_proc *,
@


1.226
log
@Do not busy loop in the rsa engine callback waiting for the ca. Instead use
poll(2) to wait for up to 1sec for a response. This is not the nicest way to
fix this issue but the smallest. Goal is to reduce the contention on the
kernel big lock on busy relayd systems.
reyk@@ agrees (especially about the nastyness of this)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.225 2016/07/29 10:09:27 reyk Exp $	*/
d697 9
d723 1
a723 1
	int			 cache;
d976 2
a977 1
	IMSG_SESS_UNPUBLISH
d1090 4
@


1.225
log
@Bump copyright in files that I touched last.
(btw. hostated-hoststated-relayd's 10th birthday is on Dec 16.)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.224 2016/07/27 06:55:44 reyk Exp $	*/
d80 1
@


1.224
log
@Improve parsing of the Host by following RFC 7230 Section 5.4 more strictly:

- Respond with a 400 (Bad Request) if there is more than one Host:
header to prevent ambiguities.

- Make sure that the host in the optional absolute form of
request-target (eg. GET http://www.target.com/ HTTP/1.1) matches the
Host: value.  Proxies are supposed to ignore the Host: value if the
request-target exists, but relayd used to ignore the absolute
request-target form instead.  In HTTP terminology, relayd is a gateway
and not a proxy, but it has to make sure that the host is validated
consistently.

OK benno@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.223 2016/07/22 09:30:36 benno Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@@openbsd.org>
@


1.223
log
@fix some cases where we relay_abort_http() the connection too soon.
instead, pass a more specific error back and handle the errors in
relay_test() instead.
reported by Arto Jonsson and Hiltjo Posthuma, thanks!
ok bluhm@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.222 2016/01/11 21:31:42 benno Exp $	*/
d1271 1
d1285 1
a1285 1
struct kv	*kv_add(struct kvtree *, char *, char *);
@


1.223.2.1
log
@Improve parsing of the Host-header by following RFC 7230 Section 5.4 more
strictly. MFC relay_http.c v 1.57, relayd.c v 1.154, relayd.h v 1.224
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.223 2016/07/22 09:30:36 benno Exp $	*/
a1270 1
int		 parse_url(const char *, char **, char **, char **);
d1284 1
a1284 1
struct kv	*kv_add(struct kvtree *, char *, char *, int);
@


1.222
log
@This adds the host_error output and the http code (when available) to the
host-check log.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.221 2015/12/02 22:12:29 benno Exp $	*/
d586 3
a588 1
	RES_FAIL		= -1
@


1.222.2.1
log
@reliability fix: When signaling an error to an HTTP relay client, the
connection can be terminated prematurely, leading to a crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.222 2016/01/11 21:31:42 benno Exp $	*/
d586 1
a586 3
	RES_FAIL		= -1,
	RES_BAD			= -2,
	RES_INTERNAL		= -3
@


1.222.2.2
log
@Improve parsing of the Host-header by following RFC 7230 Section 5.4 more
strictly. MFC relay_http.c v 1.57, relayd.c v 1.154, relayd.h v 1.224
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.222.2.1 2016/07/23 21:01:33 benno Exp $	*/
a1270 1
int		 parse_url(const char *, char **, char **, char **);
d1284 1
a1284 1
struct kv	*kv_add(struct kvtree *, char *, char *, int);
@


1.221
log
@relayd (when running relays) can distribute client sessions over hosts
with a hash generated from different data and calculate modulo
rlt->rlt_nhosts to find the host the session should go to. If this
host is down, the current algorithm simply selects the next host that
is up, obviously not ideal, because this puts heavier load on this
next host.

this changes the algorithm: if the chosen host is not available, the
hash value is recalculated and and retried until a host that is usable
is found or a maximum of retires is reached (in that case the old
method is used).

ok and nice input on my original idea bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.220 2015/12/02 13:41:27 reyk Exp $	*/
d431 1
@


1.220
log
@In most cases we don't need all arguments of proc_compose*_imsg(),
so add a shortcut proc_compose*() that skips all of them.  Only use the
full argument list if needed.  The functions with full argument lists can
eventually be replaced with a nicer transaction-based approach later.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.219 2015/11/29 01:20:33 benno Exp $	*/
d79 1
@


1.219
log
@Use pledge("pf") in pfe.c.
Move getrtable() from pfe to parent process, since its in the way of
pledge.

ok deraadt@@, feedback from reyk@@ on previous version.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.218 2015/11/28 09:52:07 reyk Exp $	*/
d1360 3
a1362 1
	    u_int16_t, int, void *, u_int16_t);
d1364 1
a1364 1
	    u_int16_t, int, const struct iovec *, int);
d1367 2
@


1.218
log
@Use SOCK_NONBLOCK in relayd as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.217 2015/11/22 13:27:13 reyk Exp $	*/
d1055 1
@


1.217
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.216 2015/11/21 12:37:42 reyk Exp $	*/
a876 5
enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK
};

a1091 1
void	 socket_set_blockmode(int, enum blockmodes);
@


1.216
log
@Move local logging functions from log.c to new file util.c (that is
also shared with relayctl).  This allows us to unify common log.c with
other daemons.  It also clarifies the Copyright: log.c is by Henning,
relayd's additions were from me.  No functional or code changes, but
it will make future updates easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.215 2015/10/27 12:27:54 benno Exp $	*/
d1335 2
a1336 1
void	log_init(int);
d1350 4
a1353 2
__dead void fatal(const char *);
__dead void fatalx(const char *);
@


1.215
log
@change cipher-server-preference to be on by default. It can be disabled with
 no cipher-server-preference
this makes more clients select ciphers with pfs.
requested and ok by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.214 2015/08/21 08:45:51 yasuoka Exp $	*/
d1106 1
a1106 1
/* log.c */
d1337 12
a1348 6
void	log_warn(const char *, ...) __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...) __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...) __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...) __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...) __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list) __attribute__((__format__ (printf, 2, 0)));
@


1.214
log
@Increase the input side socket buffer size for "check icmp" not to
drop the reply messages when "check icmp" is used with many hosts.

ok reyk benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.213 2015/07/18 16:01:28 benno Exp $	*/
d679 1
a679 1
	(TLSFLAG_TLSV1_2|TLSFLAG_CLIENT_RENEG)
@


1.213
log
@Fix unbounded buffer growth. In the case of a slow client reading large files,
we would consume large ammounts of memory.
Found by Matthew Martin <matt DOT a DOT martin AT gmail DOT com> in
httpd, fixed in httpd by florian@@
feedback from florian, reyk and bluhm, ok bluhm, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.212 2015/06/12 14:40:55 reyk Exp $	*/
d92 1
@


1.213.4.1
log
@reliability fix: When signaling an error to an HTTP relay client, the
connection can be terminated prematurely, leading to a crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.213 2015/07/18 16:01:28 benno Exp $	*/
d583 1
a583 3
	RES_FAIL		= -1,
	RES_BAD			= -2,
	RES_INTERNAL		= -3
@


1.213.4.2
log
@Improve parsing of the Host-header by following RFC 7230 Section 5.4 more
strictly. MFC relay_http.c v 1.57, relayd.c v 1.154, relayd.h v 1.224
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.213.4.1 2016/07/23 20:56:02 benno Exp $	*/
a1272 1
int		 parse_url(const char *, char **, char **, char **);
d1286 1
a1286 1
struct kv	*kv_add(struct kvtree *, char *, char *, int);
@


1.212
log
@To match relayd's style, use an explicit enum with prefixed names for
the states that Claudio introduced.  No functional change.

OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.211 2015/06/11 18:49:09 reyk Exp $	*/
d63 2
@


1.211
log
@Use "compliant" header guards by avoiding the reserved '_' namespace.

Pointed out by Markus Elfring

OK mikeb@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.210 2015/06/08 15:47:51 claudio Exp $	*/
d183 7
d210 1
a210 1
	enum { INIT, PENDING, PRECONNECT, CONNECTED } state;
@


1.210
log
@Introduce a state on the ctl_relay_event struct. This makes it possible
to better track the connection state of a session and stops doing double
opens in certain situations using http relays. Using a state field to
simplify the logic since relay_connect() is called multiple times.
OK benno@@, bluhm@@ and running in production for more than a week
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.209 2015/05/02 13:15:24 claudio Exp $	*/
d21 2
a22 2
#ifndef _RELAYD_H
#define _RELAYD_H
d1384 1
a1384 1
#endif /* _RELAYD_H */
@


1.209
log
@Fix obvious problems with relayd config reload.
- fix a TAILQ corruption because of a use after free
- do not reinit the SSL engine since that fails
OK sthen, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.208 2015/03/09 17:20:38 reyk Exp $	*/
d203 1
@


1.208
log
@Make relayd TLSv1.2-only by default.

OK krw@@ benno@@

Based on revision 1.66 of usr.sbin/httpd/parse.y:
Make httpd TLSv1.2-only by default.  Some older browsers, like IE 10,
will be incompatible with this change.  We do this early in the
release cycle, so there is a good chance to get more experience with
the impact of it and the upcoming restricted cipher modes.

OK jsing@@ deraadt@@ benno@@ bmercer@@ krw@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.207 2015/01/22 17:42:09 reyk Exp $	*/
d1256 2
a1257 1
void		 purge_table(struct tablelist *, struct table *);
@


1.207
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.206 2015/01/22 09:26:05 reyk Exp $	*/
d668 1
a668 1
	(TLSFLAG_TLSV1|TLSFLAG_CLIENT_RENEG)
@


1.207.2.1
log
@maintainance diff for relayd
MFC the following changes

- Missing free(3) in error path (ssl.c,v 1.29)
- fix a memory leak. (pfe.c,v 1.80)
- allocate se_log evbuffer before loging errors with relay_close()
  (relay.c,v 1.192)
- fix a file descriptor leak in http protocol handling
  (relay.c,v 1.193 and relay_http.c,v 1.44)
- Fix obvious problems with relayd config reload
  (ca.c,v 1.13; config.c,v 1.25; parse.y,v 1.204;
  relayd.c,v 1.139; relayd.h,v 1.209)
- http protocol: you cannot append to the previous key-value before
  line three of a request (relay_http.c,v 1.45)
- fix a crash / use after free (relay.c,v 1.194; relay_http.c,v 1.46)
- fix a non safe use of TAILQ_FOREACH with TAILQ_REMOVE
  (relay_http.c,v 1.47)
- Plug a memory leak by simplifying kv_free() (relayd.c,v 1.141)
- Fix memory leak in error case (relay_http.c,v 1.48)
- track the connection state of a session and stops doing double
  opens in certain situations (relay.c,v 1.195; relay_http.c,v 1.49; relayd.h,v 1.210)
- coding style (relay.c,v 1.196; relay_http.c,v 1.50; relayd.h,v 1.212)

ok claudio@@, sthen@@ and feedback tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.207 2015/01/22 17:42:09 reyk Exp $	*/
a182 7
enum relay_state {
	STATE_INIT,
	STATE_PENDING,
	STATE_PRECONNECT,
	STATE_CONNECTED
};

a202 1
	enum relay_state	 state;
d1256 1
a1256 2
void		 purge_table(struct relayd *, struct tablelist *,
		    struct table *);
@


1.206
log
@LibreSSL now supports loading of CA certificates from memory, replace
the internal and long-serving ssl_ctx_load_verify_memory() function
with a call to the SSL_CTX_load_verify_mem() API function.  The
ssl_privsep.c file with hacks for using OpenSSL in privsep'ed
processes can now go away; portable versions of smtpd and relayd
should start depending on LibreSSL or they have to carry ssl_privsep.c
in openbsd-compat to work with legacy OpenSSL.  No functional change.

Based on previous discussions with gilles@@ bluhm@@ and many others
OK bluhm@@ (as part of the libcrypto/libssl/libtls diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.205 2015/01/16 15:08:52 reyk Exp $	*/
d24 3
d28 1
d30 3
a32 1
#include <netinet/in.h>
d34 2
d37 2
a38 1
#include <siphash.h>
a530 1
struct relay;
a801 1
struct router;
a869 1

@


1.205
log
@SSL_CTX_use_certificate_chain() has been added to LibreSSL and there
is no need to keep a local copy in ssl_privsep.c.  This adds a little
burden on OpenSMTPD-portable because it will have to put it in
openbsd-compat for compatibility with legacy OpenSSL.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.204 2015/01/16 15:06:41 deraadt Exp $	*/
a1221 3

/* ssl_privsep.c */
int	 ssl_ctx_load_verify_memory(SSL_CTX *, char *, off_t);
@


1.204
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.203 2015/01/13 09:24:21 reyk Exp $	*/
a1223 1
int	 ssl_ctx_use_certificate_chain(SSL_CTX *, char *, off_t);
@


1.203
log
@bump copyright year
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.202 2015/01/01 14:54:06 reyk Exp $	*/
a25 1
#include <sys/param.h>		/* MAXHOSTNAMELEN */
d128 2
a129 2
	char		 name[MAXHOSTNAMELEN];
	char		 path[MAXPATHLEN];
d389 1
a389 1
	char			 name[MAXHOSTNAMELEN];
d471 1
a471 1
	char			 path[MAXPATHLEN];
d685 3
a687 3
	char			 tlsca[MAXPATHLEN];
	char			 tlscacert[MAXPATHLEN];
	char			 tlscakey[MAXPATHLEN];
d730 1
a730 1
	char			 name[MAXHOSTNAMELEN];
d815 1
a815 1
	char			 name[MAXHOSTNAMELEN];
@


1.202
log
@Merge error page changes from httpd: send Content-Length:, change
Date: from asctime to the preferred HTTP/1.1 format, and use the
popular "Comic Sans" style (can be changed in the configuration).
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.201 2014/12/21 00:54:49 guenther Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2014 Reyk Floeter <reyk@@openbsd.org>
@


1.201
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.200 2014/12/18 20:55:01 reyk Exp $	*/
d1190 1
@


1.200
log
@Update relayd to use siphash instead of sys/hash.  The source-hash,
loadbalance and hash modes use a random key by default that can be
forced to be a static key with a new configuration argument.

With input from Max Fillinger.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.199 2014/12/17 13:54:27 reyk Exp $	*/
d27 1
@


1.199
log
@Add missing flag in the description field.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.198 2014/12/12 10:05:09 reyk Exp $	*/
d29 1
d336 6
d369 1
d376 1
a376 1
	"\30MATCH\31DIVERT\32SCRIPT\33TLS_INSPECT"
d506 1
d529 1
a529 2
	u_int32_t			 se_hashkey;
	int				 se_hashkeyset;
d712 1
a712 1
	u_int32_t		 rlt_key;
d739 1
@


1.198
log
@Change the keyword "ssl" to "tls" to reflect reality since we
effectively disabled support for the SSL protocols.  SSL remains a
common term describing SSL/TLS, there is some controvery about this
change, and the name really doesn't matter, but I feel confident about
it now.

(btw., sthen@@ pointed out some historical context:
http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html)

OK benno@@, with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.197 2014/11/19 10:24:40 blambert Exp $	*/
d368 1
a368 1
	"\30MATCH\31DIVERT\32SCRIPT"
@


1.197
log
@Support exporting relayd statistics via AgentX/snmpd

This should be equivalent to the statistics available
via the various relaydctl show commands

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.196 2014/11/07 13:48:06 jsing Exp $	*/
d52 1
a52 1
#define SSL_NAME_SIZE		512
d155 2
a156 1
	SSL			*ssl;
d166 5
a170 5
enum sslreneg_state {
	SSLRENEG_INIT		= 0,	/* first/next negotiation is allowed */
	SSLRENEG_ALLOW		= 1,	/* all (re-)negotiations are allowed */
	SSLRENEG_DENY		= 2,	/* next renegotiation must be denied */
	SSLRENEG_ABORT		= 3	/* the connection should be aborted */
d182 4
a185 3
	SSL			*ssl;
	X509			*sslcert;
	enum sslreneg_state	 sslreneg_state;
d346 1
a346 1
#define F_SSL			0x00000800
d356 1
a356 1
#define F_SSLCLIENT		0x00200000
d361 1
a361 1
#define F_SSLINSPECT		0x04000000
d366 2
a367 2
	"\14SSL\15NAT_LOOKUP\16DEMOTE\17LOOKUP_PATH\20DEMOTED\21UDP"	\
	"\22RETURN\23TRAP\24NEEDPF\25PORT\26SSL_CLIENT\27NEEDRT"	\
d425 8
a432 8
	HCE_SSL_CONNECT_ERROR,
	HCE_SSL_CONNECT_FAIL,
	HCE_SSL_CONNECT_OK,
	HCE_SSL_CONNECT_TIMEOUT,
	HCE_SSL_READ_TIMEOUT,
	HCE_SSL_WRITE_TIMEOUT,
	HCE_SSL_READ_ERROR,
	HCE_SSL_WRITE_ERROR,
d476 1
a476 1
	SSL_CTX			*ssl_ctx;
d643 10
a652 10
#define SSLFLAG_SSLV3				0x01
#define SSLFLAG_TLSV1_0				0x02
#define SSLFLAG_TLSV1_1				0x04
#define SSLFLAG_TLSV1_2				0x08
#define SSLFLAG_TLSV1				0x0e
#define SSLFLAG_VERSION				0x1f
#define SSLFLAG_CIPHER_SERVER_PREF		0x20
#define SSLFLAG_CLIENT_RENEG			0x40
#define SSLFLAG_DEFAULT				\
	(SSLFLAG_TLSV1|SSLFLAG_CLIENT_RENEG)
d654 1
a654 1
#define SSLFLAG_BITS						\
d658 2
a659 2
#define SSLCIPHERS_DEFAULT	"HIGH:!aNULL"
#define SSLECDHCURVE_DEFAULT	NID_X9_62_prime256v1
d661 3
a663 3
#define SSLDHPARAMS_NONE	0
#define SSLDHPARAMS_DEFAULT	0
#define SSLDHPARAMS_MIN		1024
d673 8
a680 8
	u_int8_t		 sslflags;
	char			 sslciphers[768];
	int			 ssldhparams;
	int			 sslecdhcurve;
	char			 sslca[MAXPATHLEN];
	char			 sslcacert[MAXPATHLEN];
	char			 sslcakey[MAXPATHLEN];
	char			*sslcapass;
d731 7
a737 7
	off_t			 ssl_cert_len;
	off_t			 ssl_key_len;
	objid_t			 ssl_keyid;
	off_t			 ssl_ca_len;
	off_t			 ssl_cacert_len;
	off_t			 ssl_cakey_len;
	objid_t			 ssl_cakeyid;
d757 1
a757 12
	SSL_CTX			*rl_ssl_ctx;

	char			*rl_ssl_cert;
	X509			*rl_ssl_x509;

	char			*rl_ssl_key;
	EVP_PKEY		*rl_ssl_pkey;

	char			*rl_ssl_ca;

	char			*rl_ssl_cacert;
	X509			*rl_ssl_cacertx509;
d759 9
a767 2
	char			*rl_ssl_cakey;
	EVP_PKEY		*rl_ssl_capkey;
@


1.196
log
@Remove the sslv2 option since LibreSSL has no SSLv2 support (however retain
SSL_OP_NO_SSLv2 in case you happen to be running relayd on another platform
with another SSL library). Also fix the SSLv3 handling so that 'no sslv3'
actually works as intended.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.195 2014/11/02 13:59:40 bluhm Exp $	*/
d387 1
d541 1
d544 1
d941 3
a943 1
	IMSG_CA_PRIVDEC
d1025 1
d1032 1
d1162 4
@


1.195
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.194 2014/10/20 14:50:41 reyk Exp $	*/
d638 5
a642 6
#define SSLFLAG_SSLV2				0x01
#define SSLFLAG_SSLV3				0x02
#define SSLFLAG_TLSV1_0				0x04
#define SSLFLAG_TLSV1_1				0x08
#define SSLFLAG_TLSV1_2				0x10
#define SSLFLAG_TLSV1				0x1c
d650 1
a650 1
	"\10\01sslv2\02sslv3\03tlsv1.0\04tlsv1.1\05tlsv1.2"	\
@


1.194
log
@Remove the "interface" option from the "transparent forward" directive.
It was mandatory in the grammar but never used in the code.

A fully transparent relay can now be specified with the following
directive in a relay block: "transparent forward to destination".

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.193 2014/10/15 11:06:16 reyk Exp $	*/
d1309 1
@


1.193
log
@Disable SSLv3 by default.

OK sthen@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.192 2014/09/05 10:19:26 blambert Exp $	*/
a718 1
	char			 ifname[IFNAMSIZ];
@


1.192
log
@revert previous; was based on a work-in-progress, as well
as being an incomplete and therefore incorrect adaptation

apologies to anybody who got bitten by this mistake

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.191 2014/08/29 09:03:36 blambert Exp $	*/
d640 7
a646 4
#define SSLFLAG_TLSV1				0x04
#define SSLFLAG_VERSION				0x07
#define SSLFLAG_CIPHER_SERVER_PREF		0x08
#define SSLFLAG_CLIENT_RENEG			0x10
d648 1
a648 1
	(SSLFLAG_SSLV3|SSLFLAG_TLSV1|SSLFLAG_CLIENT_RENEG)
d651 2
a652 2
	"\10\01sslv2\02sslv3\03tlsv1"				\
	"\04cipher-server-preference\05client-renegotiation"
@


1.191
log
@Implement consistent host hashing for relayd, based on
work done by andre@@

Re-add a randomized hash seed (which had apparently
gotten inadvertently removed in the past).

Allows for multiple relayd instances to be configured
to forward traffic to the same host, falling back to
the random seed when not explicitly configured to do so.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.190 2014/08/18 12:59:00 reyk Exp $	*/
a397 1
	u_int32_t		 ringkey;
a402 5
struct host_ring {
	struct host		*host;
	u_int32_t		 ringkey;
};

a464 1
	u_int32_t		 hash_seed;
a472 3
	struct host_ring	 host_ring[RELAY_MAXHOSTS];
	int			 nhosts;
	int			 lastup;
@


1.190
log
@Sync proc.c with httpd.  httpd needs SIGUSR1 but relayd will ignore it
now instead of terminating the process.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.189 2014/07/14 00:11:12 bluhm Exp $	*/
d398 1
d404 5
d471 1
d480 3
@


1.189
log
@When a connection was spliced in one direction and in copy mode in
the other direction, the timeouts did not work.  They were longer
than specified.  Link the splicing and non-splicing timeouts.
Found by make run-regress-args-timeout-http.pl
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.188 2014/07/13 00:32:08 benno Exp $	*/
d979 1
@


1.188
log
@improve log output for relays. adjust regress tests
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.187 2014/07/12 14:34:13 reyk Exp $	*/
d186 2
a188 2
	size_t			 headerlen;
	off_t			 toread;
d190 1
@


1.187
log
@Move HTTP error codes into http.h.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.186 2014/07/11 22:28:44 reyk Exp $	*/
d528 1
d1257 3
a1259 1
int		 kv_log(struct evbuffer *, struct kv *, u_int16_t);
@


1.186
log
@Limit HTTP header length to about 8K (based on the default of 4-8K in
common web servers).  Add a related regress test.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.185 2014/07/11 21:09:28 reyk Exp $	*/
a1077 1
const char *print_httperror(u_int);
d1164 2
@


1.185
log
@8 bits is enough for sslflags
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.184 2014/07/11 16:59:38 reyk Exp $	*/
d62 1
d187 1
@


1.184
log
@Add support for EDH to provide perfect forward secrecy for older SSL
clients.  Additionally, add options for disallowing client-initiated
renegotiations and to prefer the server's cipher list over the
client's preferences.

This work is based on a diff by Markus Gebert at hostpoint.ch, and was
discussed with jsing@@ resulting in a few different defaults.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.183 2014/07/11 11:48:50 reyk Exp $	*/
d662 1
a662 1
	u_int16_t		 sslflags;
@


1.183
log
@Simplify the code that handles the HTTP headers by using an RB tree
with associated lists instead of the complicated lookup table and
"others" list.  This might add a little malloc overhead for common
headers but also fixes some issues like the handling of repeated
headers -  for example, handling of multiple "Set-Cookie" headers.

ok bluhm@@ (regress part)
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.182 2014/07/09 16:42:05 reyk Exp $	*/
d164 7
d179 1
d182 1
d634 8
a641 5
#define SSLFLAG_SSLV2		0x01
#define SSLFLAG_SSLV3		0x02
#define SSLFLAG_TLSV1		0x04
#define SSLFLAG_VERSION		0x07
#define SSLFLAG_DEFAULT		(SSLFLAG_SSLV3|SSLFLAG_TLSV1)
d644 2
a645 1
	"\10\01sslv2\02sslv3\03tlsv1\04version"
d650 4
d662 1
a662 1
	u_int8_t		 sslflags;
d664 1
@


1.182
log
@Replace the protocol directives for HTTP with a new generic filtering
language.  The grammar is inspired by pf and allows to write versatile
last-matching filter rules in protocol sections starting with the
"pass", "block" or "match" keywords.  This work was started almost two
years ago and replaces large parts of relayd(8)'s HTTP and filtering
code.  The initial version reimplements and extends HTTP filtering,
but will be improved to support generic TCP and other protocols later.

With some testing, feedback, and help from benno@@ and andre@@.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.181 2014/06/27 07:49:08 andre Exp $	*/
d275 3
a284 1
	u_int			 kv_header_id;
d288 1
d291 6
d299 1
a299 2
	struct kvlist		*kv_matchlist;
	struct kv		**kv_matchptr;
d303 1
a303 1
	TAILQ_ENTRY(kv)		 kv_entry;
a304 1
TAILQ_HEAD(kvlist, kv);
d1131 1
a1131 1
	    struct kvlist *);
a1144 3
u_int	 relay_httpheader_byname(const char *);
const char
	*relay_httpheader_byid(u_int id);
d1227 1
a1227 1
struct kv	*kv_add(struct kvlist *, char *, char *);
d1230 3
a1232 3
void		 kv_delete(struct kvlist *, struct kv *);
struct kv	*kv_extend(struct kvlist *, char *);
void		 kv_purge(struct kvlist *);
d1236 2
d1245 1
@


1.181
log
@knf, no functional change.
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.180 2014/05/20 17:33:36 reyk Exp $	*/
d44 2
d47 1
a47 1
#define	TAG_NAME_SIZE		64
a94 1

a156 13
enum httpmethod {
	HTTP_METHOD_NONE	= 0,
	HTTP_METHOD_GET		= 1,
	HTTP_METHOD_HEAD	= 2,
	HTTP_METHOD_POST	= 3,
	HTTP_METHOD_PUT		= 4,
	HTTP_METHOD_DELETE	= 5,
	HTTP_METHOD_OPTIONS	= 6,
	HTTP_METHOD_TRACE	= 7,
	HTTP_METHOD_CONNECT	= 8,
	HTTP_METHOD_RESPONSE	= 9	/* Server response */
};

d158 4
a161 2
	RELAY_DIR_REQUEST	= 0,
	RELAY_DIR_RESPONSE	= 1
a173 6
	u_int8_t		*nodes;
	struct proto_tree	*tree;

	char			*path;
	char			*args;
	char			*version;
a177 1
	int			 chunked;
a178 1
	enum httpmethod		 method;
d183 3
d241 58
a427 6
enum digest_type {
	DIGEST_NONE		= 0,
	DIGEST_SHA1		= 1,
	DIGEST_MD5		= 2
};

d440 1
d477 1
a477 1
	char			 tag[TAG_NAME_SIZE];
a509 1
	u_int16_t			 se_mark;
d514 2
d523 4
a526 61
enum nodeaction {
	NODE_ACTION_NONE	= 0,
	NODE_ACTION_APPEND	= 1,
	NODE_ACTION_CHANGE	= 2,
	NODE_ACTION_REMOVE	= 3,
	NODE_ACTION_EXPECT	= 4,
	NODE_ACTION_FILTER	= 5,
	NODE_ACTION_HASH	= 6,
	NODE_ACTION_LOG		= 7,
	NODE_ACTION_MARK	= 8
};

enum nodetype {
	NODE_TYPE_HEADER	= 0,
	NODE_TYPE_QUERY		= 1,
	NODE_TYPE_COOKIE	= 2,
	NODE_TYPE_PATH		= 3,
	NODE_TYPE_URL		= 4
};

#define PNFLAG_MACRO			0x01
#define PNFLAG_MARK			0x02
#define PNFLAG_LOG			0x04
#define PNFLAG_LOOKUP_QUERY		0x08
#define PNFLAG_LOOKUP_COOKIE		0x10
#define PNFLAG_LOOKUP_URL		0xe0
#define PNFLAG_LOOKUP_URL_DIGEST	0xc0
#define PNFLAG_LOOKUP_DIGEST(x)		(0x20 << x)

enum noderesult {
	PN_DROP			= 0,
	PN_PASS			= 1,
	PN_FAIL			= -1
};

struct protonode_config {
	objid_t				 protoid;
	size_t				 keylen;
	size_t				 valuelen;
	size_t				 len;
	size_t                           labelnamelen;
	u_int				 dir;
};

struct protonode {
	struct protonode_config		 conf;
	objid_t				 id;
	enum nodeaction			 action;
	u_int8_t			 flags;
	enum nodetype			 type;
	u_int16_t			 mark;
	u_int16_t			 label;

	char                            *labelname;
	char				*key;
	char				*value;

	SIMPLEQ_HEAD(, protonode)	 head;
	SIMPLEQ_ENTRY(protonode)	 entry;

	RB_ENTRY(protonode)		 nodes;
a527 1
RB_HEAD(proto_tree, protonode);
d529 70
a598 2
#define PROTONODE_FOREACH(elm, root, field)				\
	for (elm = root; elm != NULL; elm = SIMPLEQ_NEXT(elm, entry))	\
d600 1
a600 4
enum prototype {
	RELAY_PROTO_TCP		= 0,
	RELAY_PROTO_HTTP	= 1,
	RELAY_PROTO_DNS		= 2
d602 1
a647 1
	int			 lateconnect;
a649 5
	int			 request_nodes;
	struct proto_tree	 request_tree;
	int			 response_nodes;
	struct proto_tree	 response_tree;

d655 4
d903 1
a903 1
	IMSG_CFG_PROTONODE,
a1106 2
int	 relay_lognode(struct rsession *,
	    struct protonode *, struct protonode *, char *, size_t);
d1114 1
a1114 1
int	 relay_bufferevent_print(struct ctl_relay_event *, char *);
d1121 4
a1125 1
RB_PROTOTYPE(proto_tree, protonode, se_nodes, relay_proto_cmp);
d1129 2
d1134 8
a1205 1
void		 purge_tree(struct proto_tree *);
a1209 6
struct protonode *protonode_header(enum direction, struct protocol *,
		    struct protonode *);
int		 protonode_add(enum direction, struct protocol *,
		    struct protonode *);
int		 protonode_load(enum direction, struct protocol *,
		    struct protonode *, const char *);
d1218 3
d1223 16
d1248 8
a1255 4
u_int16_t	 pn_name2id(const char *);
const char	*pn_id2name(u_int16_t);
void		 pn_unref(u_int16_t);
void		 pn_ref(u_int16_t);
d1318 1
a1318 1
int	 config_setproto(struct relayd *env, struct protocol *);
d1320 3
a1322 4
int	 config_setprotonode(struct relayd *, enum privsep_procid,
	    struct protocol *, enum direction);
int	 config_getprotonode(struct relayd *, struct imsg *);
int	 config_setrelay(struct relayd *env, struct relay *);
@


1.180
log
@Unify the SSL privsep key loading functions.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.179 2014/05/08 13:08:48 blambert Exp $	*/
d1169 2
a1170 2
int		 accept_reserve(int sockfd, struct sockaddr *addr,
		    socklen_t *addrlen, int reserve, volatile int *);
@


1.179
log
@match relayd proc.c infrastructure with snmpd

okay reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.178 2014/05/04 16:38:19 reyk Exp $	*/
d1114 1
a1114 3
int	 ssl_ctx_load_pkey(SSL_CTX *, void *, char *, off_t,
	    X509 **, EVP_PKEY **);
int	 ssl_ctx_fake_private_key(SSL_CTX *, void *, char *, off_t,
d1116 2
@


1.178
log
@Create a new default RSA engine instead of patching the existing one
if none is available.  Fixes SSL/TLS and a possible fatalx() on
machines without a default RSA engine.

Thanks to Bjorn Ketelaars for reporting and testing.

ok gilles@@ (for the relayd part)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.177 2014/04/22 08:04:23 reyk Exp $	*/
d764 2
d767 1
d897 1
@


1.177
log
@Support the CA key for SSL inspection in the ca process.  Instead of
looking up the keys by relay id, add all keys to a list and look them
up by key id.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.176 2014/04/20 14:48:29 reyk Exp $	*/
d1121 1
a1121 1
int	 ca_engine_init(struct relayd *);
@


1.176
log
@Reimplement the multi-dimensional arrays that are used to set up the
process to process imsg communication.  It became a maze after we
added support for multiple relay processes and even worse with the ca
processes.  This change makes it easier to understand.  Now it only
opens socketpairs that are needed - the code previously wasted lots of
fds.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.175 2014/04/18 13:55:26 reyk Exp $	*/
d630 7
d653 1
d657 1
d686 1
d688 2
d691 1
d945 1
d1109 3
a1111 2
X509	*ssl_update_certificate(X509 *, EVP_PKEY *,
	    char *, off_t, char *, off_t);
d1141 2
@


1.175
log
@Introduce privsep for private keys:

- Move RSA private keys to a new separate process instead of copying
them to the relays.  A custom RSA engine is used by the SSL/TLS code
of the relay processes to send RSA private key encryption/decryption
(also used for sign/verify) requests to the new "ca" processes instead
of operating on the private key directly.

- Each relay process gets its own related ca process.  Setting
"prefork 5" in the config file will spawn 10 processes (5 relay, 5
ca).  This diff also reduces the default number of relay processes
from 5 to 3 which should be suitable in most installations without a
very heavy load.

- Don't keep text versions of the keys in memory, parse them once and
keep the binary representation.  This might still be the case in
OpenSSL's internals but will be fixed in the library.

This diff doesn't prevent something like "heartbleed" but adds an
additional mitigation to prevent leakage of the private keys from the
processes doing SSL/TLS.

With feedback from many
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.174 2014/04/18 12:02:37 reyk Exp $	*/
d863 4
d868 3
a870 1
	int				*ps_pipes[PROC_MAX][PROC_MAX];
d877 1
d1188 1
a1188 2
void	 proc_clear(struct privsep *, int);
void	 proc_config(struct privsep *, struct privsep_proc *, u_int);
@


1.174
log
@The proc.c code sets up some socketpair for the communication between
different privsep processes.  The implementation is using
multi-dimensional arrays and and some complicated process to process
relations.  This is the first attempt of cleaning it up and to allow
N:N communications for the upcoming "CA" processes.

Discussed with some, but nobody dared to comment on the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.173 2014/04/14 12:58:04 blambert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2012 Reyk Floeter <reyk@@openbsd.org>
d57 1
a57 1
#define RELAY_NUMPROC		5
d72 1
d233 8
d669 1
d671 2
d674 2
d845 3
a847 1
	IMSG_CFG_DONE
d856 1
d1088 1
a1088 1
X509	*ssl_update_certificate(X509 *, char *, off_t,
d1090 2
a1093 1
int	 ssl_ctx_use_private_key(SSL_CTX *, char *, off_t);
d1097 4
d1121 1
@


1.173
log
@Adapt relayd to use AgentX protocol to send traps

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.172 2014/02/14 10:21:00 benno Exp $	*/
d1173 2
@


1.172
log
@remove unused function that distracts from cleaning up the imsg_flush() mess
ok krw, florian, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.171 2013/09/09 17:57:45 reyk Exp $	*/
d280 1
a280 1
#define F_TRAP			0x00040000
d916 2
d932 2
d1136 1
a1136 1
int	 snmp_setsock(struct relayd *, enum privsep_procid);
@


1.171
log
@Add support for ECDHE (Elliptic curve Diffie-Hellman) to enable
TLS/SSL Perfect Forward Secrecy (PFS).

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.170 2013/09/07 10:46:31 fgsch Exp $	*/
a1166 1
void	 proc_flush_imsg(struct privsep *, enum privsep_procid, int);
@


1.170
log
@Change default ciphers to HIGH:!aNULL.
reyk@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.169 2013/05/30 20:17:12 reyk Exp $	*/
d572 1
d584 1
@


1.169
log
@Support SSL inspection, the ability to transparently filter in SSL/TLS
connections (eg. HTTPS) by using a local CA that is accepted by the
clients.  See the "SSL RELAYS" and "EXAMPLES" sections in the
relayd.conf(5) manpage for more details.

ok benno@@, manpage bits jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.168 2013/04/27 16:39:30 benno Exp $	*/
d571 1
a571 1
#define SSLCIPHERS_DEFAULT	"HIGH:!ADH"
@


1.168
log
@time_t 64bit fixes for relayd and relayctl:
- fix statistics
- set INT_MAX limit on session timeouts
- make sure we dont use to large session timeouts in pf redirects and
  openssl

tested with old and new time_t

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.167 2013/03/10 23:32:53 reyk Exp $	*/
d50 1
d81 1
d182 1
d288 1
d462 1
d584 3
d636 2
d661 2
d1016 1
d1064 3
@


1.167
log
@This diff changes relayd to use the monotonic clock instead of
gettimeofday().  It was also bugging me for some time to have all
these checks of gettimeofday()'s return value: it should not fail.  So
this diff introduces a void getmonotime(struct timeval *tv) that calls
clock_gettime(CLOCK_MONOTONIC, &ts) and converts the output to a
struct timeval that can be used with the existing code and the
timeval-specific timer functions (timerclear, timersub, ...).  It does
not return a status but calls fatal() on error-that-should-not-happen.

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.166 2013/03/09 14:43:06 bluhm Exp $	*/
d233 1
a233 1
	u_int			 interval;
@


1.166
log
@Enable TCP socket splicing for HTTP persistent connection and chunked
transfer encoding.  This speeds up relayd for more protocol modes
by zero-copy TCP forwarding.
OK reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.165 2013/03/04 08:41:32 sthen Exp $	*/
d948 1
a948 1

@


1.165
log
@sync yyerror() with bgpd; use vlog() to log parser errors so they show in
logs if they occur when reloading. ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.164 2013/02/05 21:36:33 bluhm Exp $	*/
d998 3
@


1.164
log
@Rework http content and chunk handling in relayd.  Use special
toread values to track the current http header or chunk state.  This
allows to handle an optional chunk trailer properly.  Tracking the
http state is also a prerequisite for splicing persistent http
connections.
OK and test reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.163 2012/11/27 05:00:28 guenther Exp $	*/
d1126 1
@


1.163
log
@Add format attributes to the proper functions and then fix the warnings
that gcc then reports when compiling with -DDEBUG=2

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.162 2012/10/19 16:49:50 reyk Exp $	*/
d197 7
@


1.162
log
@Support additional scheduling algorithms in the load balancer:
least-states, random, source-hash.  least-states is currently only
supported for redirections and the other ones are currently only
supported by relays.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.161 2012/10/04 20:53:30 reyk Exp $	*/
d1115 4
a1118 4
void	log_warn(const char *, ...);
void	log_warnx(const char *, ...);
void	log_info(const char *, ...);
void	log_debug(const char *, ...);
@


1.161
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.160 2012/10/03 08:40:40 reyk Exp $	*/
d417 1
d652 6
a657 3
	RELAY_DSTMODE_LOADBALANCE	= 0,
	RELAY_DSTMODE_ROUNDROBIN	= 1,
	RELAY_DSTMODE_HASH		= 2
@


1.160
log
@Inherit and pass the relay table flags correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.159 2012/10/03 08:33:31 reyk Exp $	*/
d62 1
a62 1
#define RELAY_OUTOF_FD_RETRIES	5 
d1083 1
a1083 1
			socklen_t *addrlen, int reserve, volatile int *);
@


1.159
log
@Support more than one relay backup table.  Instead of duplicating the
code for main and backup table all over the place, turn the relay
tables into a list attached to the relay.  This improves the code and
allows some other tricks with multiple tables later.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.158 2012/09/21 09:56:27 benno Exp $	*/
d115 1
@


1.158
log
@file descriptor accounting for relays: track how many connections to
backend servers are unopened and reserve fds for them.
ok reyk@@, "don't wait" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.157 2012/09/20 12:30:20 reyk Exp $	*/
d111 6
d439 2
d591 11
a609 1
	int			 dstmode;
a610 2
	objid_t			 dsttable;
	objid_t			 backuptable;
d633 1
a633 5
	struct table		*rl_dsttable;
	struct table		*rl_backuptable;
	u_int32_t		 rl_dstkey;
	struct host		*rl_dsthost[RELAY_MAXHOSTS];
	int			 rl_dstnhosts;
d804 1
d1164 1
@


1.157
log
@Move the HTTP code into an extra file to make future changes easier to
follow.  No functional changes, only one function got renamed.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.156 2012/07/09 09:52:05 deraadt Exp $	*/
d51 2
d62 1
d437 1
d440 1
d1068 2
@


1.156
log
@Allow relayd to handle transactions > 2GB in size
tested by snapshot users and benno for a while
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.155 2012/07/09 08:56:00 deraadt Exp $	*/
d4 1
a5 1
 * Copyright (c) 2006, 2007, 2008 Reyk Floeter <reyk@@openbsd.org>
d21 3
d965 19
a983 1
		 struct sockaddr_storage *);
d988 5
d1144 2
@


1.155
log
@need a private copy of nitems()
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.154 2012/05/08 15:10:15 benno Exp $	*/
d176 1
a176 1
	size_t			 toread;
@


1.154
log
@fix "label string" in http protocol. problem found by giovanni.
ok giovanni@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.153 2012/04/11 08:25:26 deraadt Exp $	*/
d26 4
@


1.153
log
@Do rate limiting of accept() when under pressure, like in other recent
daemons.  Light testing by some relayd users; let me know if issues
develop.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.152 2012/01/21 13:40:48 camield Exp $	*/
d481 1
d494 1
@


1.152
log
@Only start the child processes after all of them reported to have loaded
the config.  Solves a race at startup time where processes can send status
messages about hosts that other processes don't know about yet.
(and have relayd abort with "desynchronized" or "invalid host id")

ok henning pyr deraadt
solves the problem ok from benno todd
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.151 2011/09/04 20:26:58 bluhm Exp $	*/
d610 1
d681 1
@


1.151
log
@KNF, fix white spaces in relayd.  No binary change.
ok pyr@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.150 2011/05/26 14:48:20 reyk Exp $	*/
d745 1
@


1.150
log
@Add additional check to prevent running scripts when not configured.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.149 2011/05/26 14:38:03 reyk Exp $	*/
d477 5
a481 5
	objid_t			 	 protoid;
	size_t			 	 keylen;
	size_t			 	 valuelen;
	size_t			 	 len;
	u_int			 	 dir;
d716 1
a716 1
	struct imsgev	 	 iev;
d1023 1
a1023 1
int	 	 imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
@


1.149
log
@fix "check script" by sending all required information to the parent.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.148 2011/05/20 09:43:53 reyk Exp $	*/
d260 1
d267 1
a267 1
	"\30MATCH\31DIVERT"
@


1.148
log
@Concurrent calls of "relayctl show sessions" could crash relayd.  Fix
the show sessions handler by implementing it in an asynchronous way.

Closes PR 6509
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.147 2011/05/19 08:56:49 reyk Exp $	*/
d104 3
@


1.147
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.146 2011/05/09 12:08:47 reyk Exp $	*/
d431 2
d710 1
@


1.146
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.145 2011/05/05 10:20:24 phessler Exp $	*/
d54 9
a65 6
#define PURGE_TABLES		0x01
#define PURGE_RDRS		0x02
#define PURGE_RELAYS		0x04
#define PURGE_PROTOS		0x08
#define PURGE_EVERYTHING	0xff

d83 5
a110 6
struct ctl_netroute {
	objid_t		 id;
	objid_t		 hostid;
	int		 up;
};

d223 1
a375 1
	int			 sendbuf_len;
d470 8
d479 1
a480 1
	char				*key;
a481 1
	char				*value;
d487 3
d541 1
a541 1
	char			*sslca;
d580 3
a606 1
	off_t			 rl_ssl_cert_len;
a607 1
	off_t			 rl_ssl_key_len;
a608 1
	off_t			 rl_ssl_ca_len;
d650 1
a654 1
	int			 rt_af;
d663 6
d739 1
a754 13
	IMSG_RECONF,		/* reconfiguration notifies */
	IMSG_RECONF_TABLE,
	IMSG_RECONF_SENDBUF,
	IMSG_RECONF_HOST,
	IMSG_RECONF_RDR,
	IMSG_RECONF_VIRT,
	IMSG_RECONF_PROTO,
	IMSG_RECONF_REQUEST_TREE,
	IMSG_RECONF_RESPONSE_TREE,
	IMSG_RECONF_PNODE_KEY,
	IMSG_RECONF_PNODE_VAL,
	IMSG_RECONF_RELAY,
	IMSG_RECONF_END,
d758 11
a768 1
	IMSG_RTMSG		/* from pfe to parent */
d772 1
a773 1
	PROC_PFE,
d776 1
d788 1
d802 1
d824 1
a824 1
	const char		*sc_confpath;
d864 1
d886 3
a888 2
struct relayd	*parse_config(const char *, int);
int		 cmdline_symset(char *);
d913 1
a913 1
void	 init_filter(struct relayd *);
d934 1
d987 1
d996 1
d1002 1
a1002 1
void		 purge_config(struct relayd *, u_int8_t);
d1004 1
a1004 1
void		 merge_config(struct relayd *, struct relayd *);
d1019 2
d1037 2
a1038 1
int	 snmp_sendsock(struct relayd *, enum privsep_procid);
d1058 1
d1064 1
d1079 23
@


1.145
log
@Allow a user to specify the route priority

OK reyk@@ claudio@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.144 2011/04/24 10:07:43 bluhm Exp $	*/
a650 6
enum {
	PROC_MAIN,
	PROC_PFE,
	PROC_HCE,
	PROC_RELAY
} relayd_process;
d652 7
a658 48
struct relayd {
	u_int8_t		 sc_opts;
	u_int32_t		 sc_flags;
	const char		*sc_confpath;
	struct pfdata		*sc_pf;
	int			 sc_rtsock;
	int			 sc_rtseq;
	int			 sc_tablecount;
	int			 sc_rdrcount;
	int			 sc_protocount;
	int			 sc_relaycount;
	int			 sc_routercount;
	int			 sc_routecount;
	struct timeval		 sc_interval;
	struct timeval		 sc_timeout;
	struct table		 sc_empty_table;
	struct protocol		 sc_proto_default;
	struct event		 sc_ev;
	struct tablelist	*sc_tables;
	struct rdrlist		*sc_rdrs;
	struct protolist	*sc_protos;
	struct relaylist	*sc_relays;
	struct routerlist	*sc_rts;
	struct netroutelist	*sc_routes;
	u_int16_t		 sc_prefork_relay;
	char			 sc_demote_group[IFNAMSIZ];
	u_int16_t		 sc_id;

	struct event		 sc_statev;
	struct timeval		 sc_statinterval;

	int			 sc_snmp;
	struct event		 sc_snmpto;
	struct event		 sc_snmpev;

	int			 sc_has_icmp;
	int			 sc_has_icmp6;
	struct ctl_icmp_event	 sc_icmp_send;
	struct ctl_icmp_event	 sc_icmp_recv;
	struct ctl_icmp_event	 sc_icmp6_send;
	struct ctl_icmp_event	 sc_icmp6_recv;

	/* Event and signal handlers */
	struct event		 sc_evsigint;
	struct event		 sc_evsigterm;
	struct event		 sc_evsigchld;
	struct event		 sc_evsighup;
	struct event		 sc_evsigpipe;
a660 7
#define RELAYD_OPT_VERBOSE		0x01
#define RELAYD_OPT_NOACTION		0x04
#define RELAYD_OPT_LOGUPDATE		0x08
#define RELAYD_OPT_LOGNOTIFY		0x10
#define RELAYD_OPT_LOGALL		0x18

/* initially control.h */
d671 1
d676 1
d681 6
d700 1
a724 1
	IMSG_CTL_LOG_VERBOSE,
d755 98
d854 8
a861 8
int	control_init(void);
int	control_listen(struct relayd *, struct imsgev *, struct imsgev *);
void    control_accept(int, short, void *);
void    control_dispatch_imsg(int, short, void *);
void	control_imsg_forward(struct imsg *);
void    control_cleanup(void);

void    session_socket_blockmode(int, enum blockmodes);
d881 1
a881 2
pid_t	 pfe(struct relayd *, int [2], int [2], int [RELAY_MAXPROC][2],
	    int [2], int [RELAY_MAXPROC][2]);
d908 1
a908 2
pid_t	 hce(struct relayd *, int [2], int [2], int [RELAY_MAXPROC][2],
	    int [2], int [RELAY_MAXPROC][2]);
d912 1
a912 2
pid_t	 relay(struct relayd *, int [2], int [2], int [RELAY_MAXPROC][2],
	    int [2], int [RELAY_MAXPROC][2]);
d945 1
a945 1
void	 check_script(struct host *);
d1010 3
a1012 3
void	 snmp_init(struct relayd *, struct imsgev *);
int	 snmp_sendsock(struct imsgev *);
void	 snmp_hosttrap(struct table *, struct host *);
d1027 23
@


1.144
log
@Get rid of casts to struct rsession in relayd by not declaring a
void pointer in struct ctl_relay_event.  That way the compiler can
do its job and enforce correct types.
ok pyr@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.143 2011/04/12 12:37:22 reyk Exp $	*/
d276 1
@


1.143
log
@update flags and printing of flags in debug mode, handle splicing flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.142 2011/04/12 11:45:18 bluhm Exp $	*/
d156 1
a156 1
	void			*con;
@


1.142
log
@Enable socket splicing for relayd.  This allows zero-copy data
forwarding for plain tcp connections.
feedback and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.141 2011/04/07 13:22:29 reyk Exp $	*/
d255 7
d500 1
d503 4
d513 3
d824 2
@


1.141
log
@Add support for divert-to which provides some benefits over rdr-to.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.140 2010/12/31 21:22:42 guenther Exp $	*/
d165 1
@


1.140
log
@Add missing #includes instead of assuming that some system header pulls in
the needed bits

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.139 2010/11/30 14:38:45 reyk Exp $	*/
d252 1
d853 2
@


1.139
log
@The relayd processes did already bump up the socket file descriptor
resource limits to the maximum of the daemon class but the host check
process (hce/health checks) didn't and was limited to a fairly low
default of 128 open sockets (openfiles-cur=128 in login.conf). This
was reached fairly quickly with "check tcp" of many hosts. This diff
increases the maximum number of monitored hosts and concurrent health
checks in relayd in a significant way and may fix issues for people
that have around 100 or more hosts (or fewer hosts with multiple checked
ports).

tested by phessler@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.138 2010/10/26 15:04:37 reyk Exp $	*/
d23 2
@


1.138
log
@redirects are loaded as "pass in quick ... rdr-to" pf rules by default. In
some cases it is desired to load the rules as "match in" without "quick"
to allow additional filtering or applying additional rule/state options,
eg. to add an overload table for DOS mitigation.  Add the optional "match"
keyword for the redirect "tag" option to change the pf rule type accordingly.

ok jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.137 2010/08/01 22:18:35 sthen Exp $	*/
d292 3
a294 1
	HCE_TCP_CONNECT_ERROR,
d921 1
@


1.137
log
@Allow fallback tables for relays, not just redirections.
Seems reasonable to jsg, ok phessler, no response from reyk or pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.136 2010/05/26 13:56:08 nicm Exp $	*/
d249 1
@


1.136
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.135 2010/05/14 11:13:36 reyk Exp $	*/
d539 1
d560 1
@


1.135
log
@allocate all struct event's on the heap, it looks cleaner, feels better
and follows a suggestion in event.h.  also don't mix signal() and
signal_set()/signal_add().

ok jsg@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.134 2010/05/14 07:57:07 reyk Exp $	*/
d119 1
a119 1
	struct buf		*buf;
@


1.134
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.133 2010/01/11 06:40:14 jsg Exp $	*/
d674 7
@


1.133
log
@add "log brief" and "log verbose" to change logging verbosity
like several other things in the tree.

ok reyk@@ looks fine claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.132 2009/11/03 21:33:22 reyk Exp $	*/
a839 1

@


1.132
log
@reorder structure elements for struct netroute & router: static config
elements first (this matches all the other structures).  no functional
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.131 2009/08/17 11:36:01 reyk Exp $	*/
d738 1
d935 1
@


1.131
log
@also report routers and their host states in relayctl

ok pyr@@, jmc@@ for man bits
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.130 2009/08/13 13:51:21 reyk Exp $	*/
d595 2
a599 2
	struct netroute_config	 nr_conf;

a615 1
	TAILQ_ENTRY(router)	 rt_entry;
d617 1
d622 1
a622 1
	int			 rt_af;
@


1.130
log
@add new 'router' functionality to dynamically add or remove routes
based on health check results, using the existing table syntax.  this
allows to maintain multiple (uplink) gateways to implement link
balancing or WAN link failover if no routing protocol or other
keepalive method is available.  works fine with or without
net.inet.ip.multipath enabled.

ok pyr@@, jmc@@ for manpages
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.129 2009/08/07 11:21:53 reyk Exp $	*/
d720 2
@


1.129
log
@rename 'struct session' to 'struct rsession' because it conflicts with
another 'struct session' in sys/sysctl.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.128 2009/08/07 11:10:23 reyk Exp $	*/
d37 1
d101 6
d248 1
d586 40
d638 2
d644 2
d655 2
d762 2
a763 1
	IMSG_BINDANY
d814 5
d877 1
@


1.128
log
@allow to modify the IP TTL value for host checks.  this can be used to
check if the host is only n hops away and not re-routed over a longer
path.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.127 2009/08/05 13:46:13 reyk Exp $	*/
d387 1
a387 1
struct session {
d406 1
a406 1
	SPLAY_ENTRY(session)		 se_nodes;
d408 1
a408 1
SPLAY_HEAD(session_tree, session);
d510 2
a511 2
	int			(*cmp)(struct session *, struct session *);
	void			*(*validate)(struct session *, struct relay *,
d514 1
a514 1
	int			(*request)(struct session *);
d768 1
a768 1
int	 relay_session_cmp(struct session *, struct session *);
d770 1
a770 1
void	 relay_close(struct session *, const char *);
d772 2
a773 2
void	 relay_session(struct session *);
int	 relay_from_table(struct session *);
d780 1
a780 1
SPLAY_PROTOTYPE(session_tree, session, se_nodes, relay_session_cmp);
d825 1
a825 1
struct session	*session_find(struct relayd *, objid_t);
@


1.127
log
@prevent configuration of relays listening to a single addr:port tuple twice
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.125 2009/06/05 23:39:51 pyr Exp $	*/
d255 1
@


1.126
log
@Get ready for including imsg.h from a lib, when it comes along.
@
text
@d826 1
@


1.125
log
@4 handed diff with eric:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in relayctl.

This will make bgpd (and thus henning) happy. Next up are smtpd and ospfd.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.124 2009/06/05 00:04:01 pyr Exp $	*/
d23 1
a23 1
#include "imsg.h"
@


1.124
log
@Make imsg completely async model agnostic by not requiring an
imsg_event_add function to be provided (which ended up being a named
callback).
Instead provide a wrapper in the daemon and call that everywhere.
Previsously discussed with the usual suspects,
ok eric@@ though not too happy about the function name
(imsg_compose_event).
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.123 2009/06/04 23:33:49 pyr Exp $	*/
d638 8
d650 1
a650 1
	struct imsgbuf		 ibuf;
d712 1
a712 1
int	control_listen(struct relayd *, struct imsgbuf *, struct imsgbuf *);
d841 2
a842 2
void		 imsg_event_add(struct imsgbuf *);
int	 	 imsg_compose_event(struct imsgbuf *, u_int16_t, u_int32_t,
d859 2
a860 2
void	 snmp_init(struct relayd *, struct imsgbuf *);
int	 snmp_sendsock(struct imsgbuf *);
@


1.123
log
@move logging functions out of imsg.h, make imsg.c more library ready
by not calling log_* or fatal and handle set errno when appropriate.

discussed with a bunch of imsg conscious guys, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.122 2009/06/04 20:31:37 eric Exp $	*/
d833 3
@


1.122
log
@- move message types enum back to relayd.h
- use u_int16_t instead of enum imsg_type in imsg function prototypes

requested by reyk@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.121 2009/06/04 14:12:16 reyk Exp $	*/
d855 9
@


1.121
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.120 2009/06/04 07:16:38 eric Exp $	*/
a24 1

d646 55
@


1.120
log
@Make imsg.c and buffer.c more generic by introducing
imsg.h and a daemon-specific imsg_types.h

discussed with and "yes, please" pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.119 2009/06/03 05:35:06 eric Exp $	*/
a120 1
	char			 rbuf[SMALL_READ_BUF_SIZE];
@


1.119
log
@change buf_close return type to void.
that function is not supposed to report anything remotely useful,
or fail in any meaningful way.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.118 2009/06/02 22:02:01 eric Exp $	*/
d23 3
a52 1
#define READ_BUF_SIZE		65535
a74 108
/* buffer */
struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 max;
	size_t			 wpos;
	size_t			 rpos;
	int			 fd;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

#define IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
#define MAX_IMSGSIZE		8192

struct buf_read {
	u_char			 buf[READ_BUF_SIZE];
	u_char			*rptr;
	size_t			 wpos;
};

struct imsg_fd {
	TAILQ_ENTRY(imsg_fd)	entry;
	int			fd;
};

struct imsgbuf {
	TAILQ_HEAD(, imsg_fd)	 fds;
	struct buf_read		 r;
	struct msgbuf		 w;
	struct event		 ev;
	void			(*handler)(int, short, void *);
	int			 fd;
	pid_t			 pid;
	short			 events;
};

enum imsg_type {
	IMSG_NONE,
	IMSG_CTL_OK,		/* answer to relayctl requests */
	IMSG_CTL_FAIL,
	IMSG_CTL_END,
	IMSG_CTL_RDR,
	IMSG_CTL_TABLE,
	IMSG_CTL_HOST,
	IMSG_CTL_RELAY,
	IMSG_CTL_SESSION,
	IMSG_CTL_TABLE_CHANGED,
	IMSG_CTL_PULL_RULESET,
	IMSG_CTL_PUSH_RULESET,
	IMSG_CTL_SHOW_SUM,	/* relayctl requests */
	IMSG_CTL_RDR_ENABLE,
	IMSG_CTL_RDR_DISABLE,
	IMSG_CTL_TABLE_ENABLE,
	IMSG_CTL_TABLE_DISABLE,
	IMSG_CTL_HOST_ENABLE,
	IMSG_CTL_HOST_DISABLE,
	IMSG_CTL_SHUTDOWN,
	IMSG_CTL_RELOAD,
	IMSG_CTL_POLL,
	IMSG_CTL_NOTIFY,
	IMSG_CTL_RDR_STATS,
	IMSG_CTL_RELAY_STATS,
	IMSG_RDR_ENABLE,	/* notifies from pfe to hce */
	IMSG_RDR_DISABLE,
	IMSG_TABLE_ENABLE,
	IMSG_TABLE_DISABLE,
	IMSG_HOST_ENABLE,
	IMSG_HOST_DISABLE,
	IMSG_HOST_STATUS,	/* notifies from hce to pfe */
	IMSG_SYNC,
	IMSG_NATLOOK,
	IMSG_DEMOTE,
	IMSG_STATISTICS,
	IMSG_RECONF,		/* reconfiguration notifies */
	IMSG_RECONF_TABLE,
	IMSG_RECONF_SENDBUF,
	IMSG_RECONF_HOST,
	IMSG_RECONF_RDR,
	IMSG_RECONF_VIRT,
	IMSG_RECONF_PROTO,
	IMSG_RECONF_REQUEST_TREE,
	IMSG_RECONF_RESPONSE_TREE,
	IMSG_RECONF_PNODE_KEY,
	IMSG_RECONF_PNODE_VAL,
	IMSG_RECONF_RELAY,
	IMSG_RECONF_END,
	IMSG_SCRIPT,
	IMSG_SNMPSOCK,
	IMSG_BINDANY
};

struct imsg_hdr {
	u_int16_t	 type;
	u_int16_t	 len;
	u_int32_t	 peerid;
	pid_t		 pid;
};

struct imsg {
	struct imsg_hdr	 hdr;
	void		*data;
};
a665 7
void	log_init(int);
void	log_warn(const char *, ...);
void	log_warnx(const char *, ...);
void	log_info(const char *, ...);
void	log_debug(const char *, ...);
__dead void fatal(const char *);
__dead void fatalx(const char *);
a673 32
/* buffer.c */
struct buf	*buf_open(size_t);
struct buf	*buf_dynamic(size_t, size_t);
int		 buf_add(struct buf *, const void *, size_t);
void		*buf_reserve(struct buf *, size_t);
void		*buf_seek(struct buf *, size_t, size_t);
size_t		 buf_size(struct buf *);
size_t		 buf_left(struct buf *);
void		 buf_close(struct msgbuf *, struct buf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);

/* imsg.c */
void	 imsg_init(struct imsgbuf *, int, void (*)(int, short, void *));
ssize_t	 imsg_read(struct imsgbuf *);
ssize_t	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    int, void *, u_int16_t);
int	 imsg_composev(struct imsgbuf *, enum imsg_type, u_int32_t,
	    pid_t, int, const struct iovec *, int);
struct buf *imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    u_int16_t);
int	 imsg_add(struct buf *, void *, u_int16_t);
int	 imsg_close(struct imsgbuf *, struct buf *);
void	 imsg_free(struct imsg *);
void	 imsg_event_add(struct imsgbuf *); /* needs to be provided externally */
int	 imsg_get_fd(struct imsgbuf *);
int	 imsg_flush(struct imsgbuf *);
void	 imsg_clear(struct imsgbuf *);

a801 1

@


1.118
log
@bring in buf_seek, buf_size and buf_left from bgpd

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.117 2009/06/02 21:44:22 eric Exp $	*/
d795 1
a795 1
int		 buf_close(struct msgbuf *, struct buf *);
@


1.117
log
@constify argument to buf_add

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.116 2009/04/24 14:20:24 reyk Exp $	*/
d792 3
@


1.116
log
@Allow UDP and/or TCP redirections instead of just TCP.

Thanks to Marek Grzybowski for feedback and testing.

ok jmc@@ (manpage bits)
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.115 2009/04/02 14:30:51 reyk Exp $	*/
d790 1
a790 1
int		 buf_add(struct buf *, void *, size_t);
@


1.115
log
@add support to specify a ca file (eg. /etc/ssl/cert.pem) to verify ssl
server certificates when connecting as an SSL client from relays.  it
works so far, but needs more testing and is currently lacking support
for certificate revocation (like CRL or OCSP).  the file ssl_privsep.c
is extended to implement more code that should be in openssl to allow
loading the ca from chroot...
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.114 2009/04/01 14:56:38 reyk Exp $	*/
d320 1
@


1.114
log
@Add support for client-side SSL connections from relays.  relayd can
now sit between two SSL connections (Oitm - OpenBSD-in-the-middle),
accept SSL connections and forward to TCP, accept TCP connections and
forward to SSL, and do TCP to TCP of course.

This was tested by some people a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.113 2008/12/05 16:37:56 reyk Exp $	*/
d604 1
d668 2
d890 1
@


1.113
log
@change the way relayd reports check results: instead of logging an
arbitrary string in debugging mode, it will store an error code
(HCE_*) for each host.  the error code can be translated to a string
(in log.c) for debugging but it will also be passed to relayctl via
the control socket.

from a user point of view, this will print a human-readable error
message in the "relayctl show hosts" output if a host is down because
the check failed.  the relayctl(8) manpage includes detailed
explanations of the error messages including mitigations for the
most-common problems.

ok jmc@@ (manpages)
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.112 2008/09/29 14:53:36 reyk Exp $	*/
d347 1
@


1.112
log
@allow to load expect, filter, log, and remove keys from external files
just containing on key per line.  this allows easier use of URL
white/blacklists from external sources.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.111 2008/09/29 09:58:51 reyk Exp $	*/
d189 1
d376 1
d381 35
d774 1
d837 1
a837 1
void	 hce_notify_done(struct host *, const char *);
@


1.111
log
@allow to listen on a port range for redirections.  this fixes
stickyness with web applications that cannot do the clustering on
their own and require stickyness with HTTP to HTTPS migration.  this
is required in many cases; it is a true fact that we cannot always fix
the backend application in the real world.

Tested and requested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.101 2008/05/07 01:49:29 reyk Exp $	*/
d874 2
@


1.110
log
@better handling of HTTP POSTs or requests with Content-Length.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.109 2008/07/22 23:17:37 reyk Exp $	*/
d312 5
d319 1
a319 1
	in_port_t		 port;
d345 1
@


1.109
log
@Add dynamic IPv6-to-IPv4 and IPv4-to-IPv6 translation inspired by
faithd(8) by doing a similar mapping of IPv4/6 addresses with
relayd(8) and pf(4) redirections without the need of the faith(4)
interface.  The trick works in both directions, it can accept IPv6
connections and relay them to IPv4 hosts by extracting the last 4
octets from the IPv6 destination (like faithd(8)), and it can accept
IPv4 connections and relay them to IPv6 hosts by prepending the 4
octets of the original IPv4 destination to a configured IPv6 prefix.
An access list is not needed because the classification is done in
pf.conf(5).  It helps to get more faith in relayd.

manpage bits ok jmc@@
yes, sounds good todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.108 2008/07/19 11:38:54 reyk Exp $	*/
d230 10
a239 9
	HTTP_METHOD_GET		= 0,
	HTTP_METHOD_HEAD	= 1,
	HTTP_METHOD_POST	= 2,
	HTTP_METHOD_PUT		= 3,
	HTTP_METHOD_DELETE	= 4,
	HTTP_METHOD_OPTIONS	= 5,
	HTTP_METHOD_TRACE	= 6,
	HTTP_METHOD_CONNECT	= 7,
	HTTP_METHOD_RESPONSE	= 8	/* Server response */
@


1.108
log
@no need for using a TAILQ queue for the host children list, use a
singly-linked SLIST instead.  the only noticeable change is the
reversed order to notify the children but it does not really matter
here.  also only walk through the children host list if the host
itself is a potential parent.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.107 2008/07/19 10:52:32 reyk Exp $	*/
d593 1
d867 2
@


1.107
log
@If the new 'parent' keyword is specified for a host in a table,
inherit the state from another host with the specified Id; no
additional check will be for the inheriting host.  This helps in
scenarios with lots of IP aliases that all point to the same service
on the same host (like web hosting with many SSL domains).

discussed with pyr, tested in different setups
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.106 2008/07/09 17:16:51 reyk Exp $	*/
d357 2
a358 2
	TAILQ_ENTRY(host)	 child;
	TAILQ_HEAD(,host)	 children;
@


1.106
log
@Use OpenBSD's knuth shuffle algorithm of random values from bind to
produce the DNS request ids instead of a simple per-request
arc4random().  This ensure randomness but also satisfies the
non-repeating property we need.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.105 2008/07/09 14:57:01 reyk Exp $	*/
d348 1
d357 2
d772 1
a772 1
int	 enable_host(struct ctl_conn *, struct ctl_id *);
d775 1
a775 1
int	 disable_host(struct ctl_conn *, struct ctl_id *);
@


1.105
log
@also set the protocol, either TCP or UDP, in the NAT lookup.  this
unbreaks NAT lookups with UDP; tested as a transparent DNS relay.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.104 2008/07/09 10:50:34 reyk Exp $	*/
d67 6
d810 1
d881 5
@


1.104
log
@update the relay dns code to open a new udp socket to send the
forwarded dns request to the server instead of sending from the server
socket.  this will fix the limitation the the dns relay had to listen
to the "0.0.0.0" address, and will also enable relayd to use the udp
source port randomization. relayd will know randomize the source port
(on OpenBSD) and DNS request identifier for the clients behind it.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.103 2008/06/11 18:21:20 reyk Exp $	*/
d278 1
@


1.103
log
@add support for "transparent" forwarding in relays: normally the l7
relay will connect to the target host with its own ip address, but
this mode will let it use the address of the client that is connecting
from the other side. for example, there is no need to add the
X-Forwarded-For HTTP headers for internal webservers in this mode
anymore since they magically see the remote client ip address in the
connection. it also allows to build fully-transparent ssl
encapsulation for tcp sessions and many other things...

based on an initial idea from dlg@@ and pascoe@@ (dlg's talk at opencon)
using the new BINDANY and divert-reply interfaces from markus@@ (since n2k8)

ok markus@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.102 2008/05/08 02:27:58 reyk Exp $	*/
d561 1
a561 1
	void			*(*validate)(struct relay *,
@


1.102
log
@move the session keys used by dns in a protocol-specific private ptr.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.101 2008/05/07 01:49:29 reyk Exp $	*/
d160 2
a161 1
	IMSG_SNMPSOCK
d280 9
d332 6
a337 1
#define F_ROUTE			0x00100000
d391 1
d455 1
d575 1
d584 1
@


1.101
log
@add an alternative "route to" mode to relayd redirections which maps
to pf route-to instead of the default rdr. it is a first steps towards
support for "direct server return" (dsr), an asynchronous mode where
the load balanced servers send the replies to a different gateway like
a l3 switch/router to handle higher amounts of return traffic.
because the state handling in pf isn't optimal for this case yet, it
just sees half of the TCP connection, the sessions are forced to time
out after fixed number of seconds.

discussed with many, thought about in the onsen
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.100 2008/05/06 06:09:48 pyr Exp $	*/
a423 1
	u_int32_t			 se_key;
d427 2
a428 1
	u_int32_t			 se_outkey;
d544 1
a544 1
	int			(*validate)(struct relay *,
d546 1
a546 1
				    u_int8_t *, size_t, u_int32_t *);
@


1.100
log
@Do not unconditionnaly load pf. If pf isn't required by the configuration
the initialisation isn't done properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.99 2008/02/13 11:32:59 reyk Exp $	*/
d322 1
d366 1
d408 1
@


1.99
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.98 2008/02/13 11:02:37 reyk Exp $	*/
d321 1
@


1.98
log
@stylistic change: move code to add protonodes from the BNF into
seperate functions in relayd.c (protonode_add/protonode_header).  this
code got to big to look nice in the BNF statements...
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.97 2008/02/11 10:42:50 reyk Exp $	*/
d5 1
a5 1
 * Copyright (c) 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
@


1.97
log
@Marry relayd with snmpd using new "send trap" option: Request to send
a SNMP trap when the state of a host changes.  relayd(8) will try to
(re-)connect to snmpd(8) and request it to send a trap to the
registered trap receivers, see snmpd.conf(5) for more information
about the configuration.

ok pyr@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.96 2008/02/04 12:12:30 thib Exp $	*/
d828 4
@


1.96
log
@Move some prototypes from relay.c to relayd.h and remove there externs
in other places;

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.95 2008/02/04 12:05:26 thib Exp $	*/
d59 2
d159 2
a160 1
	IMSG_SCRIPT
d320 1
d634 4
d720 2
d729 2
d842 4
@


1.95
log
@Move the declaration of DPRINTF from relay.c too relayd.h so it can be
reused;

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.94 2008/02/04 12:01:33 thib Exp $	*/
d754 8
@


1.94
log
@declare se_relay as pointer to a struct relay not as a void pointer;
shuffle the forward decleration of struct relay around too accommodate
this change;

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.93 2008/01/31 12:12:50 thib Exp $	*/
d58 6
@


1.93
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct session;

ok reyk@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.92 2008/01/31 09:56:29 reyk Exp $	*/
d407 1
d423 1
a423 1
	void				*se_relay;
a507 1
struct relay;
@


1.92
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct relay.  knf long line fixes will follow later.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.91 2008/01/31 09:33:39 reyk Exp $	*/
d408 16
a423 16
	objid_t				 id;
	u_int32_t			 key;
	objid_t				 relayid;
	struct ctl_relay_event		 in;
	struct ctl_relay_event		 out;
	u_int32_t			 outkey;
	struct event			 ev;
	struct timeval			 timeout;
	struct timeval			 tv_start;
	struct timeval			 tv_last;
	int				 done;
	int				 retry;
	u_int16_t			 mark;
	struct evbuffer			*log;
	void				*relay;
	struct ctl_natlook		*cnl;
d425 1
a425 1
	SPLAY_ENTRY(session)		 nodes;
d749 2
a750 2
RB_PROTOTYPE(proto_tree, protonode, nodes, relay_proto_cmp);
SPLAY_PROTOTYPE(session_tree, session, nodes, relay_session_cmp);
@


1.91
log
@add prefixes to names of structure elements to make it easier to grep
for code, start with struct relayd.  finally.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.90 2007/12/20 20:15:43 reyk Exp $	*/
d555 2
a556 2
	TAILQ_ENTRY(relay)	 entry;
	struct relay_config	 conf;
d558 4
a561 4
	int			 up;
	struct protocol		*proto;
	int			 s;
	struct bufferevent	*bev;
d563 2
a564 2
	int			 dsts;
	struct bufferevent	*dstbev;
d566 4
a569 4
	struct table		*dsttable;
	u_int32_t		 dstkey;
	struct host		*dsthost[RELAY_MAXHOSTS];
	int			 dstnhosts;
d571 1
a571 1
	struct event		 ev;
d573 5
a577 5
	SSL_CTX			*ssl_ctx;
	char			*ssl_cert;
	off_t			 ssl_cert_len;
	char			*ssl_key;
	off_t			 ssl_key_len;
d579 1
a579 1
	struct ctl_stats	 stats[RELAY_MAXPROC + 1];
d581 1
a581 1
	struct session_tree	 sessions;
@


1.90
log
@implement statistics for redirections, like the existing statistics
for relays.  they can be viewed with the new "relayctl show redirects"
command.

(uses the previous change to pf_table.c to get the statistics)

looks good pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.89 2007/12/08 20:36:36 pyr Exp $	*/
d600 30
a629 30
	u_int8_t		 opts;
	u_int32_t		 flags;
	const char		*confpath;
	struct pfdata		*pf;
	int			 tablecount;
	int			 rdrcount;
	int			 protocount;
	int			 relaycount;
	struct timeval		 interval;
	struct timeval		 timeout;
	struct table		 empty_table;
	struct protocol		 proto_default;
	struct event		 ev;
	struct tablelist	*tables;
	struct rdrlist		*rdrs;
	struct protolist	*protos;
	struct relaylist	*relays;
	u_int16_t		 prefork_relay;
	char			 demote_group[IFNAMSIZ];
	u_int16_t		 id;

	struct event		 statev;
	struct timeval		 statinterval;

	int			 has_icmp;
	int			 has_icmp6;
	struct ctl_icmp_event	 icmp_send;
	struct ctl_icmp_event	 icmp_recv;
	struct ctl_icmp_event	 icmp6_send;
	struct ctl_icmp_event	 icmp6_recv;
@


1.89
log
@Rename everything which reffered to services refer to rdr for internals
(for instance: rename struct service to struct rdr), refer to redirects
otherwise (hoststatectl output).
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.88 2007/12/08 17:07:09 reyk Exp $	*/
d125 2
a126 1
	IMSG_CTL_STATISTICS,
d275 8
a282 8
	u_long			 cnt;
	u_long			 tick;
	u_long			 avg;
	u_long			 last;
	u_long			 avg_hour;
	u_long			 last_hour;
	u_long			 avg_day;
	u_long			 last_day;
d403 1
d734 2
@


1.88
log
@some changes to the relayd.conf configuration language and grammar.

the tables will look more like pf tables, it is easier to re-use
tables with different options, "services" will become "redirections"
(they refer to rdr pf rules), sync configuration directives of
redirect (l3, ex-service) relay (l7) sections (for example "virtual
host" will become "listen on"), all target definitions will start with
"forward to", etc. pp. (see relay.conf(5) and etc/relayd.conf)

discussed with pyr and deraadt
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.87 2007/12/07 17:17:01 reyk Exp $	*/
d54 1
a54 1
#define PURGE_SERVICES		0x02
d106 1
a106 1
	IMSG_CTL_SERVICE,
d115 2
a116 2
	IMSG_CTL_SERVICE_ENABLE,
	IMSG_CTL_SERVICE_DISABLE,
d126 2
a127 2
	IMSG_SERVICE_ENABLE,	/* notifies from pfe to hce */
	IMSG_SERVICE_DISABLE,
d141 1
a141 1
	IMSG_RECONF_SERVICE,
d349 1
a349 1
	objid_t			 serviceid;
d386 1
a386 1
struct service_config {
d396 3
a398 3
struct service {
	TAILQ_ENTRY(service)	 entry;
	struct service_config	 conf;
d403 1
a403 1
TAILQ_HEAD(servicelist, service);
d603 1
a603 1
	int			 servicecount;
d612 1
a612 1
	struct servicelist	*services;
d717 1
a717 1
int	 enable_service(struct ctl_conn *, struct ctl_id *);
d720 1
a720 1
int	 disable_service(struct ctl_conn *, struct ctl_id *);
d727 3
a729 3
void	 flush_table(struct relayd *, struct service *);
void	 sync_table(struct relayd *, struct service *, struct table *);
void	 sync_ruleset(struct relayd *, struct service *, int);
d780 1
a780 1
struct service	*service_find(struct relayd *, objid_t);
d784 1
a784 1
struct service	*service_findbyname(struct relayd *, const char *);
@


1.87
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: relayd.h,v 1.86 2007/11/26 09:38:25 reyk Exp $	*/
a544 1
	int			 dstcheck;
d588 1
a588 1
#define RELAY_DSTMODE_DEFAULT		RELAY_DSTMODE_LOADBALANCE
d783 1
d794 1
@


1.86
log
@allow to add labels to protocol actions, they will be printed in http
error pages and can be used to refer to additional information.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.85 2007/11/24 16:13:50 reyk Exp $	*/
d23 2
a24 2
#define CONF_FILE		"/etc/hoststated.conf"
#define HOSTSTATED_SOCKET	"/var/run/hoststated.sock"
d26 3
a28 3
#define HOSTSTATED_USER		"_hoststated"
#define HOSTSTATED_ANCHOR	"hoststated"
#define HOSTSTATED_SERVERNAME	"OpenBSD hoststated"
d103 1
a103 1
	IMSG_CTL_OK,		/* answer to hoststatectl requests */
d114 1
a114 1
	IMSG_CTL_SHOW_SUM,	/* hoststatectl requests */
d190 1
a190 1
	struct hoststated	*env;
d596 1
a596 1
} hoststated_process;
d598 1
a598 1
struct hoststated {
d631 5
a635 5
#define HOSTSTATED_OPT_VERBOSE		0x01
#define HOSTSTATED_OPT_NOACTION		0x04
#define HOSTSTATED_OPT_LOGUPDATE	0x08
#define HOSTSTATED_OPT_LOGNOTIFY	0x10
#define HOSTSTATED_OPT_LOGALL		0x18
d659 1
a659 1
int	control_listen(struct hoststated *, struct imsgbuf *, struct imsgbuf *);
d670 2
a671 2
struct hoststated	*parse_config(const char *, int);
int			 cmdline_symset(char *);
d714 1
a714 1
pid_t	 pfe(struct hoststated *, int [2], int [2], int [RELAY_MAXPROC][2],
d726 7
a732 7
void	 init_filter(struct hoststated *);
void	 init_tables(struct hoststated *);
void	 flush_table(struct hoststated *, struct service *);
void	 sync_table(struct hoststated *, struct service *, struct table *);
void	 sync_ruleset(struct hoststated *, struct service *, int);
void	 flush_rulesets(struct hoststated *);
int	 natlook(struct hoststated *, struct ctl_natlook *);
d735 1
a735 1
pid_t	 hce(struct hoststated *, int [2], int [2], int [RELAY_MAXPROC][2],
d740 1
a740 1
pid_t	 relay(struct hoststated *, int [2], int [2], int [RELAY_MAXPROC][2],
d750 1
a750 1
void	 relay_udp_privinit(struct hoststated *, struct relay *);
d756 3
a758 3
void	 icmp_init(struct hoststated *);
void	 schedule_icmp(struct hoststated *, struct host *);
void	 check_icmp(struct hoststated *, struct timeval *);
d765 2
a766 2
void	 script_done(struct hoststated *, struct ctl_script *);
int	 script_exec(struct hoststated *, struct ctl_script *);
d769 1
a769 1
void	 ssl_init(struct hoststated *);
d771 1
a771 1
SSL_CTX	*ssl_ctx_create(struct hoststated *);
d778 7
a784 7
/* hoststated.c */
struct host	*host_find(struct hoststated *, objid_t);
struct table	*table_find(struct hoststated *, objid_t);
struct service	*service_find(struct hoststated *, objid_t);
struct host	*host_findbyname(struct hoststated *, const char *);
struct table	*table_findbyname(struct hoststated *, const char *);
struct service	*service_findbyname(struct hoststated *, const char *);
d788 3
a790 3
struct relay	*relay_find(struct hoststated *, objid_t);
struct session	*session_find(struct hoststated *, objid_t);
struct relay	*relay_findbyname(struct hoststated *, const char *);
d793 2
a794 2
void		 purge_config(struct hoststated *, u_int8_t);
void		 merge_config(struct hoststated *, struct hoststated *);
@


1.85
log
@extend the url lookup algorithm to match the full URL and different
possible suffix/prefix combinations by stripping subdomains, path
components, and the query args.

ok and tested by gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.84 2007/11/23 09:39:42 reyk Exp $	*/
d470 1
d804 7
@


1.84
log
@re-implement the "mark" action and document it in the manpage:
it is possible to attach a mark to a session based on matching an
entity (header, url, cookie, ...) and add conditional action for this
mark. it works a bit like the tag/tagged keywords in pf, but i decided
to pick a different name to avoid confusion.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.83 2007/11/22 16:38:25 reyk Exp $	*/
d47 1
d795 1
@


1.83
log
@shuffle some structure elements; avoid using enums in *_config structs.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.82 2007/11/22 16:07:03 reyk Exp $	*/
a243 1
	int			 marked;
d417 1
d434 2
a435 1
	NODE_ACTION_LOG		= 7
d468 1
@


1.82
log
@Fix relay roundrobin mode to work correctly when multiple hosts in a
table are down.

Thanks to Preston Norvell at serialssolutions dot com for reporting
the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.81 2007/11/22 10:09:53 reyk Exp $	*/
d329 1
a330 1
	int			 idx;
d361 1
a361 1
	enum digest_type	 digest_type;
@


1.81
log
@add (new) "url" protocol action, this can be used to match/filter URL
suffix/prefix expressions like "example.com/index.html?args". a digest
mode allows to match against anonymized SHA1/MD5 digests of
suffix/prefix expressions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.80 2007/11/21 20:28:38 reyk Exp $	*/
d330 1
@


1.80
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.79 2007/11/21 20:13:20 reyk Exp $	*/
d440 2
a441 1
	NODE_TYPE_PATH		= 3
d449 3
@


1.79
log
@move digest string handling into an extra function.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.78 2007/11/21 14:12:04 reyk Exp $	*/
d443 5
a447 5
#define PNFLAG_MACRO		0x01
#define PNFLAG_MARK		0x02
#define PNFLAG_LOG		0x04
#define PNFLAG_LOOKUP_QUERY	0x08
#define PNFLAG_LOOKUP_COOKIE	0x10
@


1.78
log
@rename the "url" filter action to "query" to use the correct term.
please update your hoststated.conf configurations. also add more
examples to the manpage.

alright pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.77 2007/11/21 13:04:42 reyk Exp $	*/
d341 3
a343 2
	DIGEST_SHA1		= 0,
	DIGEST_MD5		= 1
d786 1
@


1.77
log
@allow the http digest type to be either SHA1 or MD5 determined by the
digest string length; it is compatible to any existing SHA1-only
configurations.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.76 2007/11/20 15:54:55 reyk Exp $	*/
d437 1
a437 1
	NODE_TYPE_URL		= 1,
d445 1
a445 1
#define PNFLAG_LOOKUP_URL	0x08
@


1.76
log
@it may be desirable to send a HTTP error page with error code and a
meaningful message if a HTTP/HTTPS relay closes the connection for
some reason. for example, a "403 Forbidden" if the request was
rejected by a filter. this will be enabled with the "return error"
option and is disabled by default, the standard behaviour is to
silently drop the connection; the browser may display an empty page in
this case. the look+feel of the HTTP error page can be customized with
a CSS style sheet, but we do not intend to allow customization of the
error page contents (hoststated is not a webserver!).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.75 2007/11/20 15:44:21 pyr Exp $	*/
d340 5
d359 1
@


1.75
log
@Allow overriding the global interval in a table.
Table specific intervals must be multiples of the global interval.
help and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.74 2007/11/20 13:01:13 pyr Exp $	*/
d28 1
d309 1
d504 1
d670 1
@


1.74
log
@bump table name size.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.73 2007/11/19 14:48:19 reyk Exp $	*/
d347 1
d358 1
@


1.73
log
@rework the internal handling of protocol actions a little bit:

- allow to use a key for multiple times by appending a queue of
additional matches to the tree node. for example, this allows to
specify multiple "expect" or "filter" actions to white-/black-list
a list of HTTP-headers, URLs, ..

- prevent specifing an HTTP header for multiple times when using the
expect action.

- minor code shuffling
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.72 2007/11/14 10:59:01 pyr Exp $	*/
d32 1
a32 1
#define TABLE_NAME_SIZE		32
@


1.72
log
@make protos dynamic too
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.71 2007/10/22 16:53:30 pyr Exp $	*/
d445 9
a453 6
	objid_t			 id;
	char			*key;
	enum nodeaction		 action;
	char			*value;
	u_int8_t		 flags;
	enum nodetype		 type;
d455 1
a455 1
	RB_ENTRY(protonode)	 nodes;
d458 3
@


1.71
log
@load certificates text at parse time. then load them in relay processes.
this separation will ease reload a bit more.

ok reyk@@ who spotted a stupid mistake again...
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.70 2007/10/19 14:15:14 pyr Exp $	*/
d587 1
a587 1
	struct protolist	 protos;
@


1.70
log
@Move relays from static TAILQs to allocated ones.
This syncs it with other hoststated entities and will make reload easier.
This is step 1 out of 7 for reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.69 2007/10/19 12:08:55 pyr Exp $	*/
d716 1
@


1.69
log
@Add the ability to schedule an immediate check through hoststatectl.
Especially useful when interval is rather long.
I was supposed to commit this before 4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.68 2007/10/12 12:50:59 blambert Exp $	*/
d588 1
a588 1
	struct relaylist	 relays;
@


1.68
log
@Silence some lint(1) warnings

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.67 2007/10/05 17:32:13 reyk Exp $	*/
d121 1
d632 1
a632 1
int	control_listen(struct hoststated *, struct imsgbuf *);
@


1.67
log
@stylistic changes in the relay/relay_config structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.66 2007/10/05 15:50:12 reyk Exp $	*/
d651 2
a652 2
void	fatal(const char *);
void	fatalx(const char *);
@


1.66
log
@using an enum in the imsg_hdr is gross, use a fixed u_int16_t instead
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.65 2007/10/02 21:04:13 pyr Exp $	*/
d527 1
a527 4
	char			*ssl_cert;
	off_t			 ssl_cert_len;
	char			*ssl_key;
	off_t			 ssl_key_len;
a528 1
	struct relay_config	 conf;
d543 6
a548 1
	SSL_CTX			*ctx;
@


1.65
log
@stop messing with lgetc to please hoststated's check/expect.
instead move some of the logic in yylex and do hoststated specific
translations into hoststated.c
ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.64 2007/09/28 13:29:56 pyr Exp $	*/
d151 1
a151 1
	enum imsg_type	 type;
@


1.64
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.63 2007/09/28 13:05:28 pyr Exp $	*/
d761 1
@


1.63
log
@Change the ssl_privsep code to work on char buffers.
The fd based code introduced weirdness since all children were accessing
the same fd at once. This will also greatly facilitate reloading, no
fd-passing will be involved between the parent and relay children.

While there, cleanup the code diverting from the original ssl_rsa.c code
a bit more.

Weird behavior discovery by pascoe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.62 2007/09/27 13:34:21 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006, 2007 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.62
log
@Simplify ssl_privsep.c, since it won't need to remain synced with the
equivalent openssl functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.61 2007/09/25 08:24:26 pyr Exp $	*/
d527 4
a530 2
	int			 cert_fd;
	int			 key_fd;
d744 2
a745 2
int	 ssl_ctx_use_private_key(SSL_CTX *, int);
int	 ssl_ctx_use_certificate_chain(SSL_CTX *, int);
@


1.61
log
@Introduce two new functions to be able to load certificates while
already chrooted and with privileges dropped.
This is the very first step in being able to reload a
layer 7 configuration.

not ok reyk who's away but should be glad to see this in.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.60 2007/09/10 11:59:22 reyk Exp $	*/
d527 3
d742 1
a742 1
int	 ssl_ctx_use_private_key(SSL_CTX *, int, int);
@


1.60
log
@add support for relaying DNS traffic (with a little bit of packet
header randomization). this adds an infrastructure to support
UDP-based protocols.

ok gilles@@, tested by some
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.59 2007/09/07 08:20:24 reyk Exp $	*/
d737 4
@


1.59
log
@add an interface to dump running relay sessions to the control socket
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.58 2007/09/07 07:59:18 reyk Exp $	*/
d306 1
d394 1
d457 2
a458 1
	RELAY_PROTO_HTTP	= 1
d478 1
d500 4
d712 6
@


1.58
log
@remove unused flags field from the structure
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.57 2007/09/07 07:52:14 reyk Exp $	*/
d108 1
d393 1
d674 1
@


1.57
log
@add a function to print delays in hours, minutes, and seconds
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.56 2007/09/06 19:55:45 reyk Exp $	*/
a250 1
	u_int8_t		 flags;
@


1.56
log
@rename relay_host to print_host in log.c
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.55 2007/09/05 08:48:42 reyk Exp $	*/
d642 1
@


1.55
log
@store relay sessions in SPLAY trees instead of TAILQ lists. this will
be used for faster lookups of sessions based on different criteria.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.54 2007/09/05 07:32:33 reyk Exp $	*/
d641 1
@


1.54
log
@increase th maximum string size for the sslciphers from 32 to 768.
this unbreaks some configurations that worked when sslciphers was a
dynamic charbuf.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.53 2007/06/18 17:29:38 pyr Exp $	*/
d405 2
a406 1
	TAILQ_ENTRY(session)		 entry;
d408 1
a408 1
TAILQ_HEAD(sessionlist, session);
d493 3
d537 1
a537 1
	struct sessionlist	 sessions;
d696 1
d699 1
@


1.53
log
@we're going to need more room for flags (again).
promote the field to u_int32_t.
no impact on hoststatectl.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.52 2007/06/12 15:16:10 msf Exp $	*/
d482 1
a482 1
	char			 sslciphers[32];
@


1.52
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.51 2007/05/31 03:24:05 pyr Exp $	*/
d290 16
a305 16
#define F_DISABLE		0x0001
#define F_BACKUP		0x0002
#define F_USED			0x0004
#define F_DOWN			0x0008
#define F_ADD			0x0010
#define F_DEL			0x0020
#define F_CHANGED		0x0040
#define F_STICKY		0x0080
#define F_CHECK_DONE		0x0100
#define F_ACTIVE_RULESET	0x0200
#define F_CHECK_SENT		0x0400
#define F_SSL			0x0800
#define F_NATLOOK		0x1000
#define F_DEMOTE		0x2000
#define F_LOOKUP_PATH		0x4000
#define F_DEMOTED		0x8000
d318 1
a318 1
	u_int16_t		 flags;
d339 1
a339 1
	u_int16_t		 flags;
d374 1
a374 1
	u_int16_t		 flags;
d475 1
a475 1
	u_int16_t		 flags;
d498 1
a498 1
	u_int16_t		 flags;
d553 1
a553 1
	u_int16_t		 flags;
@


1.51
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.50 2007/05/29 23:19:18 pyr Exp $	*/
d65 1
d83 5
d654 1
a654 1
	    void *, u_int16_t);
d661 1
@


1.50
log
@allow the control handling code to send messages back to the parent.
forward IMSG_CTL_RELOAD which ends up not doing anything for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.49 2007/05/29 19:05:13 pyr Exp $	*/
d559 2
a560 2
	struct tablelist	 tables;
	struct servicelist	 services;
d722 1
@


1.49
log
@put the reload imsg types in right now. it makes my life easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.48 2007/05/29 17:12:04 reyk Exp $	*/
d606 1
a606 1
int	control_listen(void);
@


1.48
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.47 2007/05/29 00:48:04 pyr Exp $	*/
d128 11
@


1.47
log
@move the ssl cipher suite string to a (small) static charbuf,
this will make it easier to send the struct over the socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.46 2007/05/29 00:21:10 pyr Exp $	*/
d128 2
a129 1
	IMSG_RECONF_END
d158 5
d351 2
a352 1
	CHECK_SEND_EXPECT	= 5
d684 5
@


1.46
log
@move struct relay to the runtime + config scheme.
this time around, include hoststatectl changes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.45 2007/05/28 22:11:33 pyr Exp $	*/
d458 1
a458 1
	char			*sslciphers;
@


1.45
log
@another small step towards hoststated reloading.
allow purging of parts of the hoststated environment structure.
start using this function now to only keep vital information in
hoststated children processes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.44 2007/05/28 17:37:16 pyr Exp $	*/
d472 1
a472 1
struct relay {
d475 16
a492 1
	char			 name[MAXHOSTNAMELEN];
a493 2
	in_port_t		 port;
	struct sockaddr_storage	 ss;
a496 2
	in_port_t		 dstport;
	struct sockaddr_storage	 dstss;
a502 3
	int			 dstmode;
	int			 dstcheck;
	int			 dstretry;
a504 1
	struct timeval		 timeout;
a509 1
	TAILQ_ENTRY(relay)	 entry;
@


1.44
log
@store the configuration file's path, this will be useful when reloading.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.43 2007/05/27 20:53:10 pyr Exp $	*/
d51 6
d692 1
@


1.43
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.42 2007/05/26 19:58:49 pyr Exp $	*/
d518 1
@


1.42
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.41 2007/04/12 14:45:45 reyk Exp $	*/
d276 9
d287 2
a289 2
	objid_t			 id;
	objid_t			 tableid;
a290 1
	char			 name[MAXHOSTNAMELEN];
a295 3
	int			 retry;

	struct sockaddr_storage	 ss;
a296 1
	TAILQ_ENTRY(host)	 entry;
d307 1
a307 1
struct table {
a311 2
	int			 up;
	int			 demoted;
d313 1
a315 1
	struct timeval		 timeout;
a317 1
	char			*sendbuf;
d320 7
d328 2
a329 2
	struct hostlist		 hosts;
	TAILQ_ENTRY(table)	 entry;
d342 1
a342 1
struct service {
d346 2
d350 5
a357 1
	TAILQ_ENTRY(service)	 entry;
@


1.41
log
@add a new relay 'path' action to filter the URL path and arguments.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.40 2007/04/10 21:33:52 reyk Exp $	*/
d120 3
a122 1
	IMSG_STATISTICS
d572 2
a573 2
int	parse_config(struct hoststated *, const char *, int);
int	cmdline_symset(char *);
d612 2
a613 2
pid_t	 pfe(struct hoststated *, int [2], int [2], int [2], int [2],
	    int [RELAY_MAXPROC][2]);
d632 2
a633 2
pid_t	 hce(struct hoststated *, int [2], int [2], int [2], int [2],
	    int [RELAY_MAXPROC][2]);
d637 2
a638 2
pid_t	 relay(struct hoststated *, int [2], int [2], int [2], int [2],
	    int [RELAY_MAXPROC][2]);
@


1.40
log
@move the decoding of the URL, independent from the node lookups, we
will need it later.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.39 2007/03/21 00:08:08 reyk Exp $	*/
d273 1
d377 2
a378 1
	NODE_TYPE_COOKIE	= 2
@


1.39
log
@in addition to the host retry option in tables, add support for the
optional connection "retry" to the forward to, service, and nat lookup
options. for example, "nat lookup retry 3" is useful when running
hoststated as a transparent proxy when connecting to unreliable
frontend/backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.38 2007/03/17 22:28:42 reyk Exp $	*/
d205 4
@


1.38
log
@move some elements in the relay imsg ctl structures (just for the style)
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.37 2007/03/13 12:04:52 reyk Exp $	*/
d466 1
@


1.37
log
@allow to specify the IP_TTL and IP_MINTTL options for the relays to
support the Generalized TTL Security Mechanism (GTSM) according to RFC
3682. this is especially useful with inbound connections and a fixed
distance to the backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.36 2007/03/05 11:44:50 reyk Exp $	*/
d221 2
a229 1
	int			 proc;
d235 1
a238 1

a240 1

@


1.36
log
@do not strip the header for expect, hash, and log actions.

since we have a tristate in relay_handle_http(), use nicer return
codes defined to make it better readble (no function change).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.35 2007/02/27 13:38:58 reyk Exp $	*/
d409 2
d427 2
@


1.35
log
@in addition to actions on request headers, allow to define relay
actions on response headers (the reply sent by backend HTTP servers).
the default and slightly faster relay streaming mode will be used if
no actions are defined.

for example:
response change "Server" to "OpenBSD-hoststated/4.1"

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.34 2007/02/26 12:35:43 reyk Exp $	*/
d380 6
@


1.34
log
@handle requests with chunked transfer-encoding.
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.33 2007/02/26 12:09:21 reyk Exp $	*/
d185 7
a191 1
	HTTP_METHOD_CONNECT	= 7
d204 1
d212 1
d426 4
a429 2
	int			 nodecount;
	struct proto_tree	 tree;
@


1.33
log
@improve the relay bufferevent handler if one side closed the connection
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.32 2007/02/26 11:59:48 reyk Exp $	*/
d202 1
@


1.32
log
@re-use the retry value from table host entries for inbound relay
connections. the relay will retry to connect to the hosts for the
specified number of times. this sounds bad, but is a useful
"workaround" for unreliable backend servers...
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.31 2007/02/25 14:57:09 reyk Exp $	*/
d202 1
@


1.31
log
@remove unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.30 2007/02/24 16:14:02 reyk Exp $	*/
d340 1
@


1.30
log
@disable anonymous DH by default (cipher suite HIGH:!ADH instead of HIGH).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.29 2007/02/24 15:48:54 reyk Exp $	*/
a295 1
	int			 retry;
@


1.29
log
@disable SSLv2 and use "HIGH" crypto cipher suites by default.

suggested by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.28 2007/02/24 00:22:32 reyk Exp $	*/
d401 1
a401 1
#define SSLCIPHERS_DEFAULT	"HIGH"
@


1.28
log
@- allow to specify the SSL cipher suite and the SSL protocols
  (as required by the PCI DSS)
- increase the default listen backlog to 10, allow to modify the
  backlog as a per-protocol tcp option to improve the performance
  on busy systems (to get less connection failures on heavy load)
- close the connection if SSL_accept returned an error
- instead of logging _new_ relay sessions to syslog, log the
  sessions in relay_close() after they have been _finished_.
  this will allow to collect some additional information
- add a new log keyword to log specified header/url entities (useful
  to track "bad guys" using many session ids or multiple user agents)
- some minor fixes, manpage bits, and bump the copyright (by some
  reason, i didn't realize that we already have 2007...).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.27 2007/02/23 00:28:06 deraadt Exp $	*/
d399 3
a401 1
#define SSLFLAG_DEFAULT		(SSLFLAG_SSLV2|SSLFLAG_SSLV3|SSLFLAG_TLSV1)
@


1.27
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.26 2007/02/22 05:58:06 reyk Exp $	*/
d4 2
a5 2
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
 * Copyright (c) 2006 Reyk Floeter <reyk@@openbsd.org>
d45 1
d341 1
d355 2
a356 1
	NODE_ACTION_HASH	= 6
d359 12
d376 2
a377 4
	int			 macro;
	int			 getvars;
	int			 header;
	int			 mark;
d393 7
d404 1
a404 1
	u_int16_t		 tcpflags;
d406 3
@


1.26
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.25 2007/02/22 03:32:39 reyk Exp $	*/
d504 2
a505 2
int     control_init(void);
int     control_listen(void);
@


1.25
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.24 2007/02/07 15:17:46 reyk Exp $	*/
d163 1
a163 1
	int		 	 s;
d168 2
a169 2
	struct timeval	 	 tv_start;
	struct event	 	 ev;
d201 1
a201 1
	enum httpmethod		 method;	
d331 3
a333 3
	objid_t			 	 id;
	struct ctl_relay_event	 	 in;
	struct ctl_relay_event	 	 out;
d336 1
a336 1
	struct timeval		 	 timeout;
d339 1
a339 1
	int			 	 done;
d342 1
a342 1
	TAILQ_ENTRY(session)	 	 entry;
@


1.24
log
@add new "log (updates|all)" configuration option to log state
notifications after completed host checks.  either only log the
"updates" to new states or log "all" state notifications, even if the
state didn't change. the log messages will be reported to syslog or to
stderr if the daemon is running in foreground mode.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.23 2007/02/07 13:39:58 reyk Exp $	*/
d5 1
d21 2
d38 8
d94 1
d108 1
d116 4
a119 1
	IMSG_SYNC
d139 2
d148 5
d176 60
d256 2
d267 5
d283 1
d291 2
d295 1
d330 108
d441 2
a442 1
	PROC_HCE
d451 2
d456 1
d460 4
d466 3
d529 1
d556 2
a557 1
pid_t	 pfe(struct hoststated *, int [2], int [2], int [2]);
d573 1
d576 2
a577 1
pid_t	 hce(struct hoststated *, int [2], int [2], int [2]);
d580 7
d611 11
@


1.23
log
@remove unused functions and variables which have been copied from
ospfd(8) (can be re-imported later if required).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.22 2007/02/07 13:30:17 reyk Exp $	*/
d188 5
a192 3
#define HOST_DOWN		-1
#define HOST_UNKNOWN		0
#define HOST_UP			1
d214 8
a221 6
#define CHECK_NOCHECK		0
#define CHECK_ICMP		1
#define CHECK_TCP		2
#define CHECK_HTTP_CODE		3
#define CHECK_HTTP_DIGEST	4
#define CHECK_SEND_EXPECT	5
d264 5
a268 2
#define HOSTSTATED_OPT_VERBOSE	 0x01
#define HOSTSTATED_OPT_NOACTION	 0x04
d314 2
@


1.22
log
@add the -D option to define macros on the command line (as found in
bgpd(8), hostapd(8), ipsecctl(8), pfctl(8), ...).
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.21 2007/02/06 10:26:13 pyr Exp $	*/
a287 1
int     control_imsg_relay(struct imsg *);
a312 1
void		*buf_seek(struct buf *, size_t, size_t);
@


1.21
log
@now that check_http_code, check_http_digest and check_send_expect are
in check_tcp.c, prototype them in check_tcp.c
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.20 2007/02/06 10:06:55 reyk Exp $	*/
d298 1
@


1.20
log
@declare the function ssl_error() globally
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.19 2007/02/06 08:45:46 pyr Exp $	*/
a361 7

/* check_http.c */
int	check_http_code(struct ctl_tcp_event *);
int	check_http_digest(struct ctl_tcp_event *);

/* check_send_expect.c */
int	check_send_expect(struct ctl_tcp_event *);
@


1.19
log
@inform hoststatectl monitor of ruleset changes and table syncs.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.18 2007/02/01 20:03:39 pyr Exp $	*/
d374 1
@


1.18
log
@add a monitor mode to hoststatectl to continuously report changes in
hoststated.
ok reyk@@, "looks nice and clean" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.17 2007/01/29 14:23:31 pyr Exp $	*/
d83 3
@


1.17
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.16 2007/01/12 17:05:18 pyr Exp $	*/
d92 1
d99 1
a99 2
	IMSG_TABLE_STATUS,	/* notifies from hce to pfe */
	IMSG_HOST_STATUS,
d273 2
d286 1
@


1.16
log
@use an u_int16_t for flags, the u_int8_t was getting too small.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.15 2007/01/12 16:43:01 pyr Exp $	*/
d146 2
d169 1
d203 1
d237 1
d363 5
@


1.15
log
@eliminate duplicate tcp read/write code.
ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.14 2007/01/11 18:05:08 reyk Exp $	*/
d156 11
a166 11
#define F_DISABLE		0x01
#define F_BACKUP		0x02
#define F_CHECK_DONE		0x02 /* reused for host */
#define F_USED			0x04
#define F_ACTIVE_RULESET	0x04 /* reused for service */
#define F_CHECK_SENT		0x04 /* reused for host */
#define F_DOWN			0x08
#define F_ADD			0x10
#define F_DEL			0x20
#define F_CHANGED		0x40
#define F_STICKY		0x80
d169 1
a169 1
	u_int8_t		 flags;
d189 1
a189 1
	u_int8_t		 flags;
d214 1
a214 1
	u_int8_t		 flags;
@


1.14
log
@use real async events for checks and improve the non-blocking socket
usage. also modify the check_icmp code to use non-blocking raw sockets
and merge the icmp4 and icmp6 functions. some other minor changes
while i'm here.

as discussed with pyr@@ claudio@@ deraadt@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.13 2007/01/09 13:50:11 pyr Exp $	*/
d138 1
d144 2
d197 1
a197 1
	char			 sendbuf[64];
d353 2
a354 1
void	 send_http_request(int, short, void *);
d357 1
a357 1
void	 start_send_expect(int, short, void *);
@


1.13
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.12 2007/01/09 03:32:56 reyk Exp $	*/
d129 2
a130 4
	int			 icmp_sock;
	int			 icmp6_sock;
	int			 has_icmp4;
	int			 has_icmp6;
d137 6
a142 5
	int		 s;
	struct buf	*buf;
	struct host	*host;
	struct table	*table;
	struct timeval	 tv_start;
d158 1
a230 2
	int			 icmp_sock;
	int			 icmp6_sock;
d239 8
a246 1
	struct ctl_icmp_event	 cie;
d342 3
a344 2
void	 schedule_icmp(struct ctl_icmp_event *, struct table *);
void	 check_icmp(struct ctl_icmp_event *);
d350 1
a350 1
void	 send_http_request(struct ctl_tcp_event *);
d353 1
a353 1
void	 start_send_expect(struct ctl_tcp_event *);
d362 3
@


1.12
log
@use the correct buffer sizes.

(this code needs some more work to implement a better icmp handling,
but this will fix a serious bug for now)
@
text
@d1 1
a1 1
/*	$OpenBSD: hoststated.h,v 1.11 2007/01/08 20:46:18 reyk Exp $	*/
d20 14
a33 14
#define CONF_FILE	"/etc/hostated.conf"
#define HOSTATED_SOCKET	"/var/run/hostated.sock"
#define PF_SOCKET	"/dev/pf"
#define HOSTATED_USER	"_hostated"
#define HOSTATED_ANCHOR	"hostated"
#define CHECK_TIMEOUT	200
#define CHECK_INTERVAL	10
#define EMPTY_TABLE	UINT_MAX
#define EMPTY_ID	UINT_MAX
#define TABLE_NAME_SIZE	32
#define	TAG_NAME_SIZE	64
#define SRV_NAME_SIZE	64
#define MAX_NAME_SIZE	64
#define SRV_MAX_VIRTS	16
d77 1
a77 1
	IMSG_CTL_OK,		/* answer to hostatectl requests */
d83 1
a83 1
	IMSG_CTL_SHOW_SUM,	/* hostatectl requests */
d128 8
a135 8
	struct hostated	*env;
	int		 icmp_sock;
	int		 icmp6_sock;
	int		 has_icmp4;
	int		 has_icmp6;
	int		 last_up;
	struct event	 ev;
	struct timeval	 tv_start;
d226 1
a226 1
} hostated_process;
d228 1
a228 1
struct hostated {
d244 2
a245 2
#define HOSTATED_OPT_VERBOSE	 0x01
#define HOSTATED_OPT_NOACTION	 0x04
d278 1
a278 1
int	parse_config(struct hostated *, const char *, int);
d315 1
a315 1
pid_t	 pfe(struct hostated *, int [2], int [2], int [2]);
d325 6
a330 6
void	 init_filter(struct hostated *);
void	 init_tables(struct hostated *);
void	 flush_table(struct hostated *, struct service *);
void	 sync_table(struct hostated *, struct service *, struct table *);
void	 sync_ruleset(struct hostated *, struct service *, int);
void	 flush_rulesets(struct hostated *);
d333 1
a333 1
pid_t	 hce(struct hostated *, int [2], int [2], int [2]);
d349 7
a355 7
/* hostated.c */
struct host	*host_find(struct hostated *, objid_t);
struct table	*table_find(struct hostated *, objid_t);
struct service	*service_find(struct hostated *, objid_t);
struct host	*host_findbyname(struct hostated *, const char *);
struct table	*table_findbyname(struct hostated *, const char *);
struct service	*service_findbyname(struct hostated *, const char *);
@


1.11
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.h,v 1.10 2007/01/08 16:52:58 reyk Exp $	*/
d37 1
@


1.10
log
@the timeout values are not allowed to exceed the global interval (i
figured this out while testing hostated against a stottering spamd
where the send/expect timeout needs be > 10 seconds). also use another
struct timeval to store the interval for easier handling in the code.

ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.h,v 1.9 2007/01/08 13:37:26 reyk Exp $	*/
a196 1
	regex_t			 regx;
@


1.9
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.h,v 1.8 2007/01/03 09:45:29 reyk Exp $	*/
a230 1
	int			 interval;
d235 1
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.h,v 1.7 2007/01/03 09:42:30 reyk Exp $	*/
d193 2
d197 1
d207 1
d345 3
@


1.7
log
@allow the sticky-address option for round-robin pools.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: hostated.h,v 1.6 2006/12/26 02:51:00 jsg Exp $	*/
d140 1
a140 1
	struct host 	*host;
@


1.6
log
@Add missing $OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d162 1
@


1.5
log
@fix the conversion from milliseconds to struct timeval, which uses
seconds (tv_sec) and microseconds (tv_usec), but the code assumed
seconds and milliseconds...
@
text
@d1 2
@


1.4
log
@partial rewrite of the check_* routines to use libevent everywhere
instead of nested select() calls and to handle the non-blocking
sockets properly.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
(with a little help by me)
@
text
@d187 1
a187 1
	int			 timeout;
d229 1
a229 1
	int			 timeout;
@


1.3
log
@- allow to use host/service/table names instead of Ids in hostatectl.
- minor change of the "hostatectl show" command output
- increase the max service and tag names (max pf tag name size is 64 now!)

thanks to pyr who found a bug in my initial diff
@
text
@d23 1
a23 1
#define CONNECT_TIMEOUT 200
d33 2
a34 1
#define READ_BUF_SIZE	65535
d124 19
d153 1
d155 1
a155 1
#define F_ACTIVE_RULESET	0x04
d168 1
d170 1
d229 1
d234 1
d327 1
d330 2
a331 1
int	 check_icmp(struct host *, int, int, int);
d334 1
a334 2
int	 check_tcp(struct host *, struct table *);
int	 tcp_connect(struct host *, struct table *);
d336 2
a337 3
/* check_tcp.c */
int	 check_http_code(struct host *, struct table *);
int	 check_http_digest(struct host *, struct table *);
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d26 5
a30 3
#define TABLE_NAME_SIZE	16
#define	TAG_NAME_SIZE	16
#define SRV_NAME_SIZE	16
d118 5
d285 6
a290 6
int	 enable_service(struct ctl_conn *, objid_t);
int	 enable_table(struct ctl_conn *, objid_t);
int	 enable_host(struct ctl_conn *, objid_t);
int	 disable_service(struct ctl_conn *, objid_t);
int	 disable_table(struct ctl_conn *, objid_t);
int	 disable_host(struct ctl_conn *, objid_t);
d318 3
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d35 6
a40 6
        TAILQ_ENTRY(buf)         entry;
        u_char                  *buf;
        size_t                   size;
        size_t                   max;
        size_t                   wpos;
        size_t                   rpos;
d44 3
a46 3
        TAILQ_HEAD(, buf)        bufs;
        u_int32_t                queued;
        int                      fd;
d49 7
a55 7
#define IMSG_HEADER_SIZE        sizeof(struct imsg_hdr)
#define MAX_IMSGSIZE            8192

struct buf_read {  
        u_char                   buf[READ_BUF_SIZE];
        u_char                  *rptr;              
        size_t                   wpos;
d59 8
a66 8
        TAILQ_HEAD(, imsg_fd)   fds;
        struct buf_read         r;
        struct msgbuf           w;
        struct event            ev;
        void                    (*handler)(int, short, void *);
        int                     fd;
        pid_t                   pid;
        short                   events;
d98 4
a101 4
        enum imsg_type  type;
        u_int16_t       len;
        u_int32_t       peerid;
        pid_t           pid;
d105 2
a106 2
        struct imsg_hdr  hdr;
        void            *data;
d109 1
a109 1
typedef u_int32_t	 objid_t;
d124 8
a131 8
#define F_DISABLE		 0x01
#define F_BACKUP		 0x02
#define F_USED			 0x04
#define F_ACTIVE_RULESET	 0x04
#define F_DOWN			 0x08
#define F_ADD			 0x10
#define F_DEL		 	 0x20
#define F_CHANGED	 	 0x40
a139 3
#define HOST_DOWN		 -1
#define HOST_UNKNOWN		 0
#define HOST_UP			 1
d145 4
a153 5
#define CHECK_NOCHECK		 0
#define CHECK_ICMP		 1
#define CHECK_TCP		 2
#define CHECK_HTTP_CODE		 3
#define CHECK_HTTP_DIGEST	 4
d156 1
a156 1
	int			 retcode;	
d166 6
d192 1
a192 3
        u_int8_t                 opts;
#define HOSTATED_OPT_VERBOSE	 0x01
#define HOSTATED_OPT_NOACTION	 0x04
d205 3
d210 2
a211 2
        struct event    ev;
        int             fd;
d215 2
a216 2
        BM_NORMAL,
        BM_NONBLOCK
d220 2
a221 2
        TAILQ_ENTRY(ctl_conn)   entry;
        struct imsgbuf          ibuf;
d239 1
a239 1
int		 parse_config(struct hostated *, const char *, int);
d242 7
a248 7
void             log_init(int);
void             log_warn(const char *, ...);
void             log_warnx(const char *, ...);
void             log_info(const char *, ...);
void             log_debug(const char *, ...);
void             fatal(const char *);
void             fatalx(const char *);
d251 10
a260 10
struct buf      *buf_open(size_t);
struct buf      *buf_dynamic(size_t, size_t);
int              buf_add(struct buf *, void *, size_t);
void            *buf_reserve(struct buf *, size_t);
void            *buf_seek(struct buf *, size_t, size_t);
int              buf_close(struct msgbuf *, struct buf *);
void             buf_free(struct buf *);
void             msgbuf_init(struct msgbuf *);
void             msgbuf_clear(struct msgbuf *);
int              msgbuf_write(struct msgbuf *);
d263 11
a273 11
void     imsg_init(struct imsgbuf *, int, void (*)(int, short, void *));
ssize_t  imsg_read(struct imsgbuf *);
ssize_t  imsg_get(struct imsgbuf *, struct imsg *);
int      imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
            void *, u_int16_t);
struct buf      *imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
                    u_int16_t);
int      imsg_add(struct buf *, void *, u_int16_t);
int      imsg_close(struct imsgbuf *, struct buf *);
void     imsg_free(struct imsg *);
void     imsg_event_add(struct imsgbuf *); /* needs to be provided externally */
@

