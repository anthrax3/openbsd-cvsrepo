head	1.35;
access;
symbols
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11;
locks; strict;
comment	@ * @;


1.35
date	2017.03.21.12.06.56;	author bluhm;	state Exp;
branches;
next	1.34;
commitid	6uuBMurt3Uh42fgX;

1.34
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.33;
commitid	eA8b246voAapPTkX;

1.33
date	2017.01.08.20.31.03;	author reyk;	state Exp;
branches;
next	1.32;
commitid	U5QfDMrhDiu5oehf;

1.32
date	2016.10.12.11.57.31;	author reyk;	state Exp;
branches;
next	1.31;
commitid	BzueJHWWTTYcYEmT;

1.31
date	2015.12.07.12.13.51;	author reyk;	state Exp;
branches;
next	1.30;
commitid	se0edNAzUA8O35vt;

1.30
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.29;
commitid	T3JBYxNT0thPuavp;

1.29
date	2015.11.21.13.46.29;	author reyk;	state Exp;
branches;
next	1.28;
commitid	cbop6oorkGDnHgcS;

1.28
date	2015.11.21.12.37.42;	author reyk;	state Exp;
branches;
next	1.27;
commitid	F0WFvnPckRXIJkcu;

1.27
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.26;
commitid	puppem00jmzmdm4f;

1.26
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.25;
commitid	XnjIOhurXdX5o1V9;

1.25
date	2014.12.12.10.05.09;	author reyk;	state Exp;
branches;
next	1.24;
commitid	J8g0vRzthwLCqf68;

1.24
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.23;
commitid	2uw1UTO4k6erpWzK;

1.23
date	2014.07.12.14.34.13;	author reyk;	state Exp;
branches;
next	1.22;
commitid	Rqjr3ecSVr0G8d8h;

1.22
date	2014.04.18.16.13.02;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.18.16.09.07;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2013.11.27.18.38.39;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.10.23.32.53;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.27.05.00.28;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.12.12.37.22;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2010.11.30.14.38.45;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.11.06.40.14;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.05.16.37.55;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.18.12.26.52;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.17.15.10.14;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.07.17.17.00;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.20.15.54.55;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.04.22.09.02;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.07.07.52.14;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.09.06.19.55.45;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.29.17.12.04;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.22.03.32.39;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.07.15.17.46;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.17.48.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.35
log
@From a syslog perspective it does not make sense to log fatal and
warn with the same severity.  Switch log_warn() to LOG_ERR and keep
fatal() at LOG_CRIT.
OK reyk@@ florian@@
@
text
@/*	$OpenBSD: log.c,v 1.34 2017/01/09 14:49:21 reyk Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <syslog.h>
#include <errno.h>
#include <time.h>

static int	 debug;
static int	 verbose;
const char	*log_procname;

void	log_init(int, int);
void	log_procinit(const char *);
void	log_setverbose(int);
int	log_getverbose(void);
void	log_warn(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list)
	    __attribute__((__format__ (printf, 2, 0)));
__dead void fatal(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));

void
log_init(int n_debug, int facility)
{
	extern char	*__progname;

	debug = n_debug;
	verbose = n_debug;
	log_procinit(__progname);

	if (!debug)
		openlog(__progname, LOG_PID | LOG_NDELAY, facility);

	tzset();
}

void
log_procinit(const char *procname)
{
	if (procname != NULL)
		log_procname = procname;
}

void
log_setverbose(int v)
{
	verbose = v;
}

int
log_getverbose(void)
{
	return (verbose);
}

void
logit(int pri, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vlog(pri, fmt, ap);
	va_end(ap);
}

void
vlog(int pri, const char *fmt, va_list ap)
{
	char	*nfmt;
	int	 saved_errno = errno;

	if (debug) {
		/* best effort in out of mem situations */
		if (asprintf(&nfmt, "%s\n", fmt) == -1) {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		} else {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
		}
		fflush(stderr);
	} else
		vsyslog(pri, fmt, ap);

	errno = saved_errno;
}

void
log_warn(const char *emsg, ...)
{
	char		*nfmt;
	va_list		 ap;
	int		 saved_errno = errno;

	/* best effort to even work in out of memory situations */
	if (emsg == NULL)
		logit(LOG_ERR, "%s", strerror(saved_errno));
	else {
		va_start(ap, emsg);

		if (asprintf(&nfmt, "%s: %s", emsg,
		    strerror(saved_errno)) == -1) {
			/* we tried it... */
			vlog(LOG_ERR, emsg, ap);
			logit(LOG_ERR, "%s", strerror(saved_errno));
		} else {
			vlog(LOG_ERR, nfmt, ap);
			free(nfmt);
		}
		va_end(ap);
	}

	errno = saved_errno;
}

void
log_warnx(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_ERR, emsg, ap);
	va_end(ap);
}

void
log_info(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_INFO, emsg, ap);
	va_end(ap);
}

void
log_debug(const char *emsg, ...)
{
	va_list	 ap;

	if (verbose > 1) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

static void
vfatalc(int code, const char *emsg, va_list ap)
{
	static char	s[BUFSIZ];
	const char	*sep;

	if (emsg != NULL) {
		(void)vsnprintf(s, sizeof(s), emsg, ap);
		sep = ": ";
	} else {
		s[0] = '\0';
		sep = "";
	}
	if (code)
		logit(LOG_CRIT, "%s: %s%s%s",
		    log_procname, s, sep, strerror(code));
	else
		logit(LOG_CRIT, "%s%s%s", log_procname, sep, s);
}

void
fatal(const char *emsg, ...)
{
	va_list	ap;

	va_start(ap, emsg);
	vfatalc(errno, emsg, ap);
	va_end(ap);
	exit(1);
}

void
fatalx(const char *emsg, ...)
{
	va_list	ap;

	va_start(ap, emsg);
	vfatalc(0, emsg, ap);
	va_end(ap);
	exit(1);
}
@


1.34
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.33 2017/01/08 20:31:03 reyk Exp $	*/
d127 1
a127 1
		logit(LOG_CRIT, "%s", strerror(saved_errno));
d134 2
a135 2
			vlog(LOG_CRIT, emsg, ap);
			logit(LOG_CRIT, "%s", strerror(saved_errno));
d137 1
a137 1
			vlog(LOG_CRIT, nfmt, ap);
d152 1
a152 1
	vlog(LOG_CRIT, emsg, ap);
@


1.33
log
@Sync log.c with the latest version from vmd/log.c that preserves errno
so it is safe calling log_* after an error without loosing the it.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2016/11/24 21:39:45 reyk Exp $	*/
d27 2
a28 2
int		 debug;
int		 verbose;
d33 2
a34 1
void	log_verbose(int);
d75 1
a75 1
log_verbose(int v)
d78 6
@


1.32
log
@copy updated log.c from vmd: for correctness, save errno when doing
additional actions before printing it.  OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2016/10/12 11:47:34 reyk Exp $	*/
d93 1
d107 2
a110 1

d135 2
d172 1
a172 1
vfatal(const char *emsg, va_list ap)
a175 1
	int		 saved_errno = errno;
d184 1
a184 1
	if (saved_errno)
d186 1
a186 1
		    log_procname, s, sep, strerror(saved_errno));
d197 1
a197 1
	vfatal(emsg, ap);
a206 1
	errno = 0;
d208 1
a208 1
	vfatal(emsg, ap);
@


1.31
log
@sync with vmd
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2015/12/07 12:10:02 reyk Exp $	*/
d112 3
a114 2
	char	*nfmt;
	va_list	 ap;
d118 1
a118 1
		logit(LOG_CRIT, "%s", strerror(errno));
d122 2
a123 1
		if (asprintf(&nfmt, "%s: %s", emsg, strerror(errno)) == -1) {
d126 1
a126 1
			logit(LOG_CRIT, "%s", strerror(errno));
d172 1
d181 1
a181 1
	if (errno)
d183 1
a183 1
		    log_procname, s, sep, strerror(errno));
@


1.30
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.29 2015/11/21 13:46:29 reyk Exp $	*/
d179 1
a179 1
		logit(LOG_CRIT, "fatal in %s: %s%s%s",
d182 1
a182 1
		logit(LOG_CRIT, "fatal in %s%s%s", log_procname, sep, s);
@


1.29
log
@Once again, fix the license text.  After many years, we just cannot
get rid of the "LOSS OF MIND" joke.  Haha.  We keep on removing it and
it shows up again because it accidentally gets synced from somewhere
else.  bgpd and ospfd don't have it anymore, but their offsprings
still carry it. If you see it, remove it, and, in the OpenBSD ISC
case, use the original text from /usr/share/misc/license.template.
All authors agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.28 2015/11/21 12:37:42 reyk Exp $	*/
d27 3
a29 2
int	 debug;
int	 verbose;
d31 2
a32 1
void	log_init(int);
d46 4
a49 2
__dead void fatal(const char *);
__dead void fatalx(const char *);
d52 1
a52 1
log_init(int n_debug)
d58 1
d61 1
a61 1
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);
d67 7
d165 20
d186 1
a186 1
fatal(const char *emsg)
d188 1
a188 8
	if (emsg == NULL)
		logit(LOG_CRIT, "fatal: %s", strerror(errno));
	else
		if (errno)
			logit(LOG_CRIT, "fatal: %s: %s",
			    emsg, strerror(errno));
		else
			logit(LOG_CRIT, "fatal: %s", emsg);
d190 3
d197 1
a197 1
fatalx(const char *emsg)
d199 2
d202 4
a205 1
	fatal(emsg);
@


1.28
log
@Move local logging functions from log.c to new file util.c (that is
also shared with relayctl).  This allows us to unify common log.c with
other daemons.  It also clarifies the Copyright: log.c is by Henning,
relayd's additions were from me.  No functional or code changes, but
it will make future updates easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.27 2015/01/22 17:42:09 reyk Exp $	*/
d14 3
a16 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.27
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.26 2014/12/21 00:54:49 guenther Exp $	*/
a18 6
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/time.h>

#include <errno.h>
#include <stdarg.h>
d21 1
d24 1
a24 2
#include <netdb.h>
#include <ctype.h>
a26 2
#include "relayd.h"

d30 13
a42 1
void	 vlog(int, const char *, va_list)
d44 2
a45 2
void	 logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
a172 234
}

const char *
host_error(enum host_error he)
{
	switch (he) {
	case HCE_NONE:
		return ("none");
		break;
	case HCE_ABORT:
		return ("aborted");
		break;
	case HCE_INTERVAL_TIMEOUT:
		return ("interval timeout");
		break;
	case HCE_ICMP_OK:
		return ("icmp ok");
		break;
	case HCE_ICMP_READ_TIMEOUT:
		return ("icmp read timeout");
		break;
	case HCE_ICMP_WRITE_TIMEOUT:
		return ("icmp write timeout");
		break;
	case HCE_TCP_SOCKET_ERROR:
		return ("tcp socket error");
		break;
	case HCE_TCP_SOCKET_LIMIT:
		return ("tcp socket limit");
		break;
	case HCE_TCP_SOCKET_OPTION:
		return ("tcp socket option");
		break;
	case HCE_TCP_CONNECT_FAIL:
		return ("tcp connect failed");
		break;
	case HCE_TCP_CONNECT_TIMEOUT:
		return ("tcp connect timeout");
		break;
	case HCE_TCP_CONNECT_OK:
		return ("tcp connect ok");
		break;
	case HCE_TCP_WRITE_TIMEOUT:
		return ("tcp write timeout");
		break;
	case HCE_TCP_WRITE_FAIL:
		return ("tcp write failed");
		break;
	case HCE_TCP_READ_TIMEOUT:
		return ("tcp read timeout");
		break;
	case HCE_TCP_READ_FAIL:
		return ("tcp read failed");
		break;
	case HCE_SCRIPT_OK:
		return ("script ok");
		break;
	case HCE_SCRIPT_FAIL:
		return ("script failed");
		break;
	case HCE_TLS_CONNECT_OK:
		return ("tls connect ok");
		break;
	case HCE_TLS_CONNECT_FAIL:
		return ("tls connect failed");
		break;
	case HCE_TLS_CONNECT_TIMEOUT:
		return ("tls connect timeout");
		break;
	case HCE_TLS_CONNECT_ERROR:
		return ("tls connect error");
		break;
	case HCE_TLS_READ_TIMEOUT:
		return ("tls read timeout");
		break;
	case HCE_TLS_WRITE_TIMEOUT:
		return ("tls write timeout");
		break;
	case HCE_TLS_READ_ERROR:
		return ("tls read error");
		break;
	case HCE_TLS_WRITE_ERROR:
		return ("tls write error");
		break;
	case HCE_SEND_EXPECT_FAIL:
		return ("send/expect failed");
		break;
	case HCE_SEND_EXPECT_OK:
		return ("send/expect ok");
		break;
	case HCE_HTTP_CODE_ERROR:
		return ("http code malformed");
		break;
	case HCE_HTTP_CODE_FAIL:
		return ("http code mismatch");
		break;
	case HCE_HTTP_CODE_OK:
		return ("http code ok");
		break;
	case HCE_HTTP_DIGEST_ERROR:
		return ("http digest malformed");
		break;
	case HCE_HTTP_DIGEST_FAIL:
		return ("http digest mismatch");
		break;
	case HCE_HTTP_DIGEST_OK:
		return ("http digest ok");
		break;
	}
	/* NOTREACHED */
	return ("invalid");
}

const char *
host_status(enum host_status status)
{
	switch (status) {
	case HOST_DOWN:
		return ("down");
	case HOST_UNKNOWN:
		return ("unknown");
	case HOST_UP:
		return ("up");
	};
	/* NOTREACHED */
	return ("invalid");
}

const char *
table_check(enum table_check check)
{
	switch (check) {
	case CHECK_NOCHECK:
		return ("none");
	case CHECK_ICMP:
		return ("icmp");
	case CHECK_TCP:
		return ("tcp");
	case CHECK_HTTP_CODE:
		return ("http code");
	case CHECK_HTTP_DIGEST:
		return ("http digest");
	case CHECK_SEND_EXPECT:
		return ("send expect");
	case CHECK_SCRIPT:
		return ("script");
	};
	/* NOTREACHED */
	return ("invalid");
}

const char *
print_availability(u_long cnt, u_long up)
{
	static char buf[BUFSIZ];

	if (cnt == 0)
		return ("");
	bzero(buf, sizeof(buf));
	snprintf(buf, sizeof(buf), "%.2f%%", (double)up / cnt * 100);
	return (buf);
}

const char *
print_host(struct sockaddr_storage *ss, char *buf, size_t len)
{
	if (getnameinfo((struct sockaddr *)ss, ss->ss_len,
	    buf, len, NULL, 0, NI_NUMERICHOST) != 0) {
		buf[0] = '\0';
		return (NULL);
	}
	return (buf);
}

const char *
print_time(struct timeval *a, struct timeval *b, char *buf, size_t len)
{
	struct timeval		tv;
	u_long			h, sec, min;

	timerclear(&tv);
	timersub(a, b, &tv);
	sec = tv.tv_sec % 60;
	min = tv.tv_sec / 60 % 60;
	h = tv.tv_sec / 60 / 60;

	snprintf(buf, len, "%.2lu:%.2lu:%.2lu", h, min, sec);
	return (buf);
}

const char *
printb_flags(const u_int32_t v, const char *bits)
{
	static char	 buf[2][BUFSIZ];
	static int	 idx = 0;
	int		 i, any = 0;
	char		 c, *p, *r;

	p = r = buf[++idx % 2];
	bzero(p, BUFSIZ);

	if (bits) {
		bits++;
		while ((i = *bits++)) {
			if (v & (1 << (i - 1))) {
				if (any) {
					*p++ = ',';
					*p++ = ' ';
				}
				any = 1;
				for (; (c = *bits) > 32; bits++) {
					if (c == '_')
						*p++ = ' ';
					else
						*p++ = tolower((u_char)c);
				}
			} else
				for (; *bits > 32; bits++)
					;
		}
	}

	return (r);
}

void
getmonotime(struct timeval *tv)
{
	struct timespec	 ts;

	if (clock_gettime(CLOCK_MONOTONIC, &ts))
		fatal("clock_gettime");

	TIMESPEC_TO_TIMEVAL(tv, &ts);
@


1.26
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.25 2014/12/12 10:05:09 reyk Exp $	*/
a19 1
#include <sys/queue.h>
d21 1
a21 5
#include <sys/tree.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>
a28 1
#include <event.h>
d31 1
a31 2

#include <openssl/ssl.h>
@


1.25
log
@Change the keyword "ssl" to "tls" to reflect reality since we
effectively disabled support for the SSL protocols.  SSL remains a
common term describing SSL/TLS, there is some controvery about this
change, and the name really doesn't matter, but I feel confident about
it now.

(btw., sthen@@ pointed out some historical context:
http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html)

OK benno@@, with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.24 2014/10/25 03:23:49 lteo Exp $	*/
a26 1
#include <arpa/inet.h>
@


1.24
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.23 2014/07/12 14:34:13 reyk Exp $	*/
d237 2
a238 2
	case HCE_SSL_CONNECT_OK:
		return ("ssl connect ok");
d240 2
a241 2
	case HCE_SSL_CONNECT_FAIL:
		return ("ssl connect failed");
d243 2
a244 2
	case HCE_SSL_CONNECT_TIMEOUT:
		return ("ssl connect timeout");
d246 2
a247 2
	case HCE_SSL_CONNECT_ERROR:
		return ("ssl connect error");
d249 2
a250 2
	case HCE_SSL_READ_TIMEOUT:
		return ("ssl read timeout");
d252 2
a253 2
	case HCE_SSL_WRITE_TIMEOUT:
		return ("ssl write timeout");
d255 2
a256 2
	case HCE_SSL_READ_ERROR:
		return ("ssl read error");
d258 2
a259 2
	case HCE_SSL_WRITE_ERROR:
		return ("ssl write error");
@


1.23
log
@Move HTTP error codes into http.h.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.22 2014/04/18 16:13:02 reyk Exp $	*/
a24 1
#include <netinet/in_systm.h>
@


1.22
log
@fix previous
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.21 2014/04/18 16:09:07 reyk Exp $	*/
a365 56
}

const char *
print_httperror(u_int code)
{
	u_int			 i;
	struct {
		u_int		 ht_code;
		const char	*ht_err;
	}			 httperr[] = {
		{ 100, "Continue" },
		{ 101, "Switching Protocols" },
		{ 200, "OK" },
		{ 201, "Created" },
		{ 202, "Accepted" },
		{ 203, "Non-Authorative Information" },
		{ 204, "No Content" },
		{ 205, "Reset Content" },
		{ 206, "Partial Content" },
		{ 300, "Multiple Choices" },
		{ 301, "Moved Permanently" },
		{ 302, "Moved Temporarily" },
		{ 303, "See Other" },
		{ 304, "Not Modified" },
		{ 307, "Temporary Redirect" },
		{ 400, "Bad Request" },
		{ 401, "Unauthorized" },
		{ 402, "Payment Required" },
		{ 403, "Forbidden" },
		{ 404, "Not Found" },
		{ 405, "Method Not Allowed" },
		{ 406, "Not Acceptable" },
		{ 407, "Proxy Authentication Required" },
		{ 408, "Request Timeout" },
		{ 409, "Conflict" },
		{ 410, "Gone" },
		{ 411, "Length Required" },
		{ 412, "Precondition Failed" },
		{ 413, "Request Entity Too Large" },
		{ 414, "Request-URL Too Long" },
		{ 415, "Unsupported Media Type" },
		{ 416, "Requested Range Not Satisfiable" },
		{ 417, "Expectation Failed" },
		{ 500, "Internal Server Error" },
		{ 501, "Not Implemented" },
		{ 502, "Bad Gateway" },
		{ 503, "Service Unavailable" },
		{ 504, "Gateway Timeout" },
		{ 505, "HTTP Version Not Supported" },
		{ 0 }
	};

	for (i = 0; httperr[i].ht_code != 0; i++)
		if (httperr[i].ht_code == code)
			return (httperr[i].ht_err);
	return ("Unknown Error");
@


1.21
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.20 2013/11/27 18:38:39 deraadt Exp $	*/
d448 1
a448 1
						*p++ = tolower((u_char char)c);
@


1.20
log
@unsigned char for ctype
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.19 2013/03/10 23:32:53 reyk Exp $	*/
d448 1
a448 1
						*p++ = tolower((unsigned char)c);
@


1.19
log
@This diff changes relayd to use the monotonic clock instead of
gettimeofday().  It was also bugging me for some time to have all
these checks of gettimeofday()'s return value: it should not fail.  So
this diff introduces a void getmonotime(struct timeval *tv) that calls
clock_gettime(CLOCK_MONOTONIC, &ts) and converts the output to a
struct timeval that can be used with the existing code and the
timeval-specific timer functions (timerclear, timersub, ...).  It does
not return a status but calls fatal() on error-that-should-not-happen.

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.18 2012/11/27 05:00:28 guenther Exp $	*/
d448 1
a448 1
						*p++ = tolower(c);
@


1.18
log
@Add format attributes to the proper functions and then fix the warnings
that gcc then reports when compiling with -DDEBUG=2

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.17 2011/04/12 12:37:22 reyk Exp $	*/
d457 11
@


1.17
log
@update flags and printing of flags in debug mode, handle splicing flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.16 2010/11/30 14:38:45 reyk Exp $	*/
d47 4
a50 2
void	 vlog(int, const char *, va_list);
void	 logit(int, const char *, ...);
@


1.16
log
@The relayd processes did already bump up the socket file descriptor
resource limits to the maximum of the daemon class but the host check
process (hce/health checks) didn't and was limited to a fairly low
default of 128 open sockets (openfiles-cur=128 in login.conf). This
was reached fairly quickly with "check tcp" of many hosts. This diff
increases the maximum number of monitored hosts and concurrent health
checks in relayd in a significant way and may fix issues for people
that have around 100 or more hosts (or fewer hosts with multiple checked
ports).

tested by phessler@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.15 2010/01/11 06:40:14 jsg Exp $	*/
d38 1
d420 35
@


1.15
log
@add "log brief" and "log verbose" to change logging verbosity
like several other things in the tree.

ok reyk@@ looks fine claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.14 2008/12/05 16:37:55 reyk Exp $	*/
d199 8
a206 2
	case HCE_TCP_CONNECT_ERROR:
		return ("tcp connect error");
@


1.14
log
@change the way relayd reports check results: instead of logging an
arbitrary string in debugging mode, it will store an error code
(HCE_*) for each host.  the error code can be translated to a string
(in log.c) for debugging but it will also be passed to relayctl via
the control socket.

from a user point of view, this will print a human-readable error
message in the "relayctl show hosts" output if a host is down because
the check failed.  the relayctl(8) manpage includes detailed
explanations of the error messages including mitigations for the
most-common problems.

ok jmc@@ (manpages)
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.13 2008/07/18 12:26:52 reyk Exp $	*/
d44 1
d55 1
d64 6
d148 1
a148 1
	if (debug > 1) {
@


1.13
log
@terminate the input buffer on failure in print_host()
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.12 2008/07/17 15:10:14 reyk Exp $	*/
d167 105
@


1.12
log
@use getaddrinfo/getnameinfo to parse ipv6 addresses instead of
inet_pton/inet_ntop to allow specifing and printing the IPv6 scope
identifier. synced host_v6() with ntpd's version to use getaddrinfo()
instead of inet_pton() - host_v4, host_v6, and host_dns could all use
getaddrinfo in a single function by specifing different flags but this
would diverge from the other daemons using this common interface so we
keep this little overhead.

discussed with henning@@
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.11 2007/12/07 17:17:00 reyk Exp $	*/
d223 2
a224 1
	    buf, len, NULL, 0, NI_NUMERICHOST) != 0)
d226 1
@


1.11
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.10 2007/11/24 17:07:28 reyk Exp $	*/
d37 1
d222 4
a225 9
	int af = ss->ss_family;
	void *ptr;

	bzero(buf, len);
	if (af == AF_INET)
		ptr = &((struct sockaddr_in *)ss)->sin_addr;
	else
		ptr = &((struct sockaddr_in6 *)ss)->sin6_addr;
	return (inet_ntop(af, ptr, buf, len));
@


1.10
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.9 2007/11/20 15:54:55 reyk Exp $	*/
d40 1
a40 1
#include "hoststated.h"
@


1.9
log
@it may be desirable to send a HTTP error page with error code and a
meaningful message if a HTTP/HTTPS relay closes the connection for
some reason. for example, a "403 Forbidden" if the request was
rejected by a filter. this will be enabled with the "return error"
option and is disabled by default, the standard behaviour is to
silently drop the connection; the browser may display an empty page in
this case. the look+feel of the HTTP error page can be customized with
a CSS style sheet, but we do not intend to allow customization of the
error page contents (hoststated is not a webserver!).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.8 2007/11/04 22:09:02 reyk Exp $	*/
a19 1
#include <sys/param.h>
d24 1
a27 2
#include <net/if.h>

@


1.8
log
@the last change to enable logging to stderr on startup also enabled
annoying debugging messages on the console by default.  since we do
not want to see debugging messages unless specified by the "-d" flag,
add an extra debugging level "debug > 1" to be checked in log_debug().
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.7 2007/09/07 07:52:14 reyk Exp $	*/
d248 56
@


1.7
log
@add a function to print delays in hours, minutes, and seconds
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2007/09/06 19:55:45 reyk Exp $	*/
d141 1
a141 1
	if (debug) {
@


1.6
log
@rename relay_host to print_host in log.c
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2007/05/29 17:12:04 reyk Exp $	*/
d232 16
@


1.5
log
@add a new check method which allows to run external scripts/programs
for custom evaluations.

pyr agrees to put it in now but to do some improvements of the timeout
handling later.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.4 2007/02/22 03:32:39 reyk Exp $	*/
d30 2
d218 14
@


1.4
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2007/02/07 15:17:46 reyk Exp $	*/
d199 2
@


1.3
log
@add new "log (updates|all)" configuration option to log state
notifications after completed host checks.  either only log the
"updates" to new states or log "all" state notifications, even if the
state didn't change. the log messages will be reported to syslog or to
stderr if the daemon is running in foreground mode.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2006/12/16 17:48:27 deraadt Exp $	*/
d23 1
d202 12
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d19 10
d35 3
d39 1
a39 9
/* prototypes */
void		 log_init(int);
void		 vlog(int, const char *, va_list);
void		 log_warn(const char *, ...);
void		 log_warnx(const char *, ...);
void		 log_info(const char *, ...);
void		 log_debug(const char *, ...);
void		 fatal(const char *);
void		 fatalx(const char *);
d43 1
d165 36
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d27 8
a34 8
void             log_init(int);
void             vlog(int, const char *, va_list);
void             log_warn(const char *, ...);
void             log_warnx(const char *, ...);
void             log_info(const char *, ...);
void             log_debug(const char *, ...);
void             fatal(const char *);
void             fatalx(const char *);
@

