head	1.62;
access;
symbols
	OPENBSD_6_1:1.61.0.4
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.59.0.4
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.58.0.6
	OPENBSD_5_8_BASE:1.58
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.53.0.8
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.6
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.53.0.2
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.52.0.2
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.49.0.2
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.4
	OPENBSD_5_0:1.47.0.2
	OPENBSD_5_0_BASE:1.47
	OPENBSD_4_9:1.45.0.2
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23;
locks; strict;
comment	@ * @;


1.62
date	2017.05.28.10.39.15;	author benno;	state Exp;
branches;
next	1.61;
commitid	IW4LnWyG3CPq6c3r;

1.61
date	2017.01.24.10.49.14;	author benno;	state Exp;
branches;
next	1.60;
commitid	OlGQrXFnE2t7dYTy;

1.60
date	2016.09.02.14.45.51;	author reyk;	state Exp;
branches;
next	1.59;
commitid	vcV98N2DyJGMwDyQ;

1.59
date	2015.11.29.01.20.33;	author benno;	state Exp;
branches;
next	1.58;
commitid	u0wLjk4LODsT22tz;

1.58
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.57;
commitid	puppem00jmzmdm4f;

1.57
date	2015.01.22.15.21.28;	author reyk;	state Exp;
branches;
next	1.56;
commitid	4iTNJ5pZPl4b1HA5;

1.56
date	2015.01.21.21.50.33;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	3o2AkhiRPQXvG94X;

1.55
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	tOv8XK6tLyhEfayc;

1.54
date	2014.12.23.13.18.23;	author reyk;	state Exp;
branches;
next	1.53;
commitid	Nz43jWMMtbJ5k60b;

1.53
date	2013.04.27.16.39.30;	author benno;	state Exp;
branches;
next	1.52;

1.52
date	2012.10.19.16.49.50;	author reyk;	state Exp;
branches;
next	1.51;

1.51
date	2012.10.04.20.53.30;	author reyk;	state Exp;
branches;
next	1.50;

1.50
date	2012.09.18.10.11.53;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2012.07.07.16.24.32;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2012.03.09.13.50.07;	author benno;	state Exp;
branches;
next	1.47;

1.47
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.46;

1.46
date	2011.05.05.12.01.44;	author reyk;	state Exp;
branches;
next	1.45;

1.45
date	2010.10.26.15.04.37;	author reyk;	state Exp;
branches;
next	1.44;

1.44
date	2010.09.02.14.03.22;	author sobrado;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.24.16.29.37;	author pyr;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.12.23.27.23;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.23.00.45.41;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.01.13.43.36;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2009.04.24.14.20.24;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2009.04.01.14.08.53;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.08.10.59.44;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2008.12.04.17.13.20;	author reyk;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.29.15.12.22;	author reyk;	state Exp;
branches;
next	1.33;

1.33
date	2008.09.29.09.58.51;	author reyk;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.16.14.38.33;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.09.14.57.01;	author reyk;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.11.18.21.19;	author reyk;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.10.23.12.36;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.10.22.02.28;	author reyk;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.16.14.47.58;	author pyr;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.07.01.49.29;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.06.11.52.49;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.06.06.09.48;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.31.09.33.39;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.20.20.15.43;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.08.20.36.36;	author pyr;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.07.17.17.00;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.28.13.29.56;	author pyr;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.31.03.24.05;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.22.05.58.06;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.22.03.32.40;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.20.04.06.17;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.08.13.32.24;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.07.14.45.12;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.29.14.23.31;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.13.50.11;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.00.45.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.08.20.46.18;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.08.17.10.23;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.13.37.26;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.05.16.39.23;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.03.09.42.30;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.12.42.14;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.16.11.45.07;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.62
log
@use __func__ in log messages. fix some whitespace while here.
From Hiltjo Posthuma hiltjo -AT codemadness -DOT- org, thanks!
ok florian, claudio
@
text
@/*	$OpenBSD: pfe_filter.c,v 1.61 2017/01/24 10:49:14 benno Exp $	*/

/*
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/ioctl.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <net/pfvar.h>

#include <limits.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

#include "relayd.h"

int	 transaction_init(struct relayd *, const char *);
int	 transaction_commit(struct relayd *);
void	 kill_tables(struct relayd *);
int	 kill_srcnodes(struct relayd *, struct table *);

void
init_tables(struct relayd *env)
{
	int			 i;
	struct rdr		*rdr;
	struct pfr_table	*tables;
	struct pfioc_table	 io;

	if (!(env->sc_conf.flags & F_NEEDPF))
		return;

	if ((tables = calloc(env->sc_rdrcount, sizeof(*tables))) == NULL)
		fatal("calloc");
	i = 0;

	TAILQ_FOREACH(rdr, env->sc_rdrs, entry) {
		if (strlcpy(tables[i].pfrt_anchor, RELAYD_ANCHOR "/",
		    sizeof(tables[i].pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (strlcat(tables[i].pfrt_anchor, rdr->conf.name,
		    sizeof(tables[i].pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (strlcpy(tables[i].pfrt_name, rdr->conf.name,
		    sizeof(tables[i].pfrt_name)) >=
		    sizeof(tables[i].pfrt_name))
			goto toolong;
		tables[i].pfrt_flags |= PFR_TFLAG_PERSIST;
		i++;
	}
	if (i != env->sc_rdrcount)
		fatalx("%s: table count modified", __func__);

	memset(&io, 0, sizeof(io));
	io.pfrio_size = env->sc_rdrcount;
	io.pfrio_esize = sizeof(*tables);
	io.pfrio_buffer = tables;

	if (ioctl(env->sc_pf->dev, DIOCRADDTABLES, &io) == -1)
		fatal("%s: cannot create tables", __func__);
	log_debug("%s: created %d tables", __func__, io.pfrio_nadd);

	free(tables);

	if (io.pfrio_nadd == env->sc_rdrcount)
		return;

	/*
	 * clear all tables, since some already existed
	 */
	TAILQ_FOREACH(rdr, env->sc_rdrs, entry)
		flush_table(env, rdr);

	return;

 toolong:
	fatal("%s: name too long", __func__);
}

void
kill_tables(struct relayd *env)
{
	struct pfioc_table	 io;
	struct rdr		*rdr;
	int			 cnt = 0;

	if (!(env->sc_conf.flags & F_NEEDPF))
		return;

	TAILQ_FOREACH(rdr, env->sc_rdrs, entry) {
		memset(&io, 0, sizeof(io));
		if (strlcpy(io.pfrio_table.pfrt_anchor, RELAYD_ANCHOR "/",
		    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (strlcat(io.pfrio_table.pfrt_anchor, rdr->conf.name,
		    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (ioctl(env->sc_pf->dev, DIOCRCLRTABLES, &io) == -1)
			fatal("%s: ioctl failed", __func__);
		cnt += io.pfrio_ndel;
	}
	log_debug("%s: deleted %d tables", __func__, cnt);
	return;

 toolong:
	fatal("%s: name too long", __func__);
}

void
sync_table(struct relayd *env, struct rdr *rdr, struct table *table)
{
	int			 i, cnt = 0;
	struct pfioc_table	 io;
	struct pfr_addr		*addlist;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sain6;
	struct host		*host;

	if (!(env->sc_conf.flags & F_NEEDPF))
		return;

	if (table == NULL)
		return;

	if (table->up == 0) {
		flush_table(env, rdr);
		return;
	}

	if ((addlist = calloc(table->up, sizeof(*addlist))) == NULL)
		fatal("calloc");

	memset(&io, 0, sizeof(io));
	io.pfrio_esize = sizeof(struct pfr_addr);
	io.pfrio_size = table->up;
	io.pfrio_size2 = 0;
	io.pfrio_buffer = addlist;
	if (strlcpy(io.pfrio_table.pfrt_anchor, RELAYD_ANCHOR "/",
	    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcat(io.pfrio_table.pfrt_anchor, rdr->conf.name,
	    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcpy(io.pfrio_table.pfrt_name, rdr->conf.name,
	    sizeof(io.pfrio_table.pfrt_name)) >=
	    sizeof(io.pfrio_table.pfrt_name))
		goto toolong;

	i = 0;
	TAILQ_FOREACH(host, &table->hosts, entry) {
		if (host->up != HOST_UP)
			continue;
		memset(&(addlist[i]), 0, sizeof(addlist[i]));
		switch (host->conf.ss.ss_family) {
		case AF_INET:
			sain = (struct sockaddr_in *)&host->conf.ss;
			addlist[i].pfra_af = AF_INET;
			memcpy(&(addlist[i].pfra_ip4addr), &sain->sin_addr,
			    sizeof(sain->sin_addr));
			addlist[i].pfra_net = 32;
			break;
		case AF_INET6:
			sain6 = (struct sockaddr_in6 *)&host->conf.ss;
			addlist[i].pfra_af = AF_INET6;
			memcpy(&(addlist[i].pfra_ip6addr), &sain6->sin6_addr,
			    sizeof(sain6->sin6_addr));
			addlist[i].pfra_net = 128;
			break;
		default:
			fatalx("%s: unknown address family", __func__);
			break;
		}
		i++;
	}
	if (i != table->up)
		fatalx("%s: desynchronized", __func__);

	if (ioctl(env->sc_pf->dev, DIOCRSETADDRS, &io) == -1)
		fatal("%s: cannot set address list", __func__);
	if (rdr->conf.flags & F_STICKY)
		cnt = kill_srcnodes(env, table);
	free(addlist);

	if (env->sc_conf.opts & RELAYD_OPT_LOGUPDATE)
		log_info("table %s: %d added, %d deleted, "
		    "%d changed, %d killed", io.pfrio_table.pfrt_name,
		    io.pfrio_nadd, io.pfrio_ndel, io.pfrio_nchange, cnt);
	return;

 toolong:
	fatal("%s: name too long", __func__);
}

int
kill_srcnodes(struct relayd *env, struct table *table)
{
	struct host			*host;
	struct pfioc_src_node_kill	 psnk;
	int				 cnt = 0;
	struct sockaddr_in		*sain;
	struct sockaddr_in6		*sain6;

	bzero(&psnk, sizeof(psnk));

	/* Only match the destination address, source mask will be zero */
	memset(&psnk.psnk_dst.addr.v.a.mask, 0xff,
	    sizeof(psnk.psnk_dst.addr.v.a.mask));

	TAILQ_FOREACH(host, &table->hosts, entry) {
		if (host->up != HOST_DOWN)
			continue;

		switch (host->conf.ss.ss_family) {
		case AF_INET:
		sain = (struct sockaddr_in *)&host->conf.ss;
			bcopy(&sain->sin_addr,
			    &psnk.psnk_dst.addr.v.a.addr.v4,
			    sizeof(psnk.psnk_dst.addr.v.a.addr.v4));
			break;
		case AF_INET6:
			sain6 = (struct sockaddr_in6 *)&host->conf.ss;
			bcopy(&sain6->sin6_addr,
			    &psnk.psnk_dst.addr.v.a.addr.v6,
			    sizeof(psnk.psnk_dst.addr.v.a.addr.v6));
			break;
		default:
			fatalx("%s: unknown address family", __func__);
			break;
		}

		psnk.psnk_af = host->conf.ss.ss_family;
		psnk.psnk_killed = 0;

		if (ioctl(env->sc_pf->dev,
		    DIOCKILLSRCNODES, &psnk) == -1)
			fatal("%s: cannot kill src nodes", __func__);
		cnt += psnk.psnk_killed;
	}

	return (cnt);
}

void
flush_table(struct relayd *env, struct rdr *rdr)
{
	struct pfioc_table	io;

	if (!(env->sc_conf.flags & F_NEEDPF))
		return;

	memset(&io, 0, sizeof(io));
	if (strlcpy(io.pfrio_table.pfrt_anchor, RELAYD_ANCHOR "/",
	    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcat(io.pfrio_table.pfrt_anchor, rdr->conf.name,
	    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcpy(io.pfrio_table.pfrt_name, rdr->conf.name,
	    sizeof(io.pfrio_table.pfrt_name)) >=
	    sizeof(io.pfrio_table.pfrt_name))
		goto toolong;
	if (ioctl(env->sc_pf->dev, DIOCRCLRADDRS, &io) == -1)
		fatal("%s: cannot flush table addresses", __func__);

	io.pfrio_esize = sizeof(io.pfrio_table);
	io.pfrio_size = 1;
	io.pfrio_buffer = &io.pfrio_table;
	if (ioctl(env->sc_pf->dev, DIOCRCLRTSTATS, &io) == -1)
		fatal("%s: cannot flush table stats", __func__);

	log_debug("%s: flushed table %s", __func__, rdr->conf.name);
	return;

 toolong:
	fatal("%s: name too long", __func__);
}

int
transaction_init(struct relayd *env, const char *anchor)
{
	env->sc_pf->pft.size = 1;
	env->sc_pf->pft.esize = sizeof(env->sc_pf->pfte);
	env->sc_pf->pft.array = &env->sc_pf->pfte;

	bzero(&env->sc_pf->pfte, sizeof(env->sc_pf->pfte));
	(void)strlcpy(env->sc_pf->pfte.anchor,
	    anchor, PF_ANCHOR_NAME_SIZE);
	env->sc_pf->pfte.type = PF_TRANS_RULESET;

	if (ioctl(env->sc_pf->dev, DIOCXBEGIN,
	    &env->sc_pf->pft) == -1)
		return (-1);

	return (0);
}

int
transaction_commit(struct relayd *env)
{
	if (ioctl(env->sc_pf->dev, DIOCXCOMMIT,
	    &env->sc_pf->pft) == -1)
		return (-1);

	return (0);
}

void
sync_ruleset(struct relayd *env, struct rdr *rdr, int enable)
{
	struct pfioc_rule	 rio;
	struct sockaddr_in	*sain;
	struct sockaddr_in6	*sain6;
	struct address		*address;
	char			 anchor[PF_ANCHOR_NAME_SIZE];
	struct table		*t = rdr->table;

	if ((env->sc_conf.flags & F_NEEDPF) == 0)
		return;

	bzero(anchor, sizeof(anchor));
	if (strlcpy(anchor, RELAYD_ANCHOR "/", sizeof(anchor)) >=
	    PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcat(anchor, rdr->conf.name, sizeof(anchor)) >=
	    PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (transaction_init(env, anchor) == -1) {
		log_warn("%s: transaction init failed", __func__);
		return;
	}

	if (!enable) {
		if (transaction_commit(env) == -1)
			log_warn("%s: remove rules transaction failed",
			    __func__);
		else
			log_debug("%s: rules removed", __func__);
		return;
	}

	TAILQ_FOREACH(address, &rdr->virts, entry) {
		memset(&rio, 0, sizeof(rio));
		(void)strlcpy(rio.anchor, anchor, sizeof(rio.anchor));

		if (rdr->conf.flags & F_MATCH) {
			rio.rule.action = PF_MATCH;
			rio.rule.quick = 0;
		} else {
			rio.rule.action = PF_PASS;
			rio.rule.quick = 1; /* force first match */
		}
		rio.rule.direction = PF_IN;
		rio.rule.keep_state = PF_STATE_NORMAL;

		switch (t->conf.fwdmode) {
		case FWD_NORMAL:
			/* traditional redirection */
			if (address->ipproto == IPPROTO_TCP) {
				rio.rule.flags = TH_SYN;
				rio.rule.flagset = (TH_SYN|TH_ACK);
			}
			break;
		case FWD_ROUTE:
			/* re-route with pf for DSR (direct server return) */
			rio.rule.rt = PF_ROUTETO;

			/* Use sloppy state handling for half connections */
			rio.rule.rule_flag = PFRULE_STATESLOPPY;
			break;
		default:
			fatalx("%s: invalid forward mode", __func__);
			/* NOTREACHED */
		}

		rio.ticket = env->sc_pf->pfte.ticket;

		rio.rule.af = address->ss.ss_family;
		rio.rule.proto = address->ipproto;
		rio.rule.src.addr.type = PF_ADDR_ADDRMASK;
		rio.rule.dst.addr.type = PF_ADDR_ADDRMASK;
		rio.rule.dst.port_op = address->port.op;
		rio.rule.dst.port[0] = address->port.val[0];
		rio.rule.dst.port[1] = address->port.val[1];
		rio.rule.rtableid = -1; /* stay in the main routing table */
		rio.rule.onrdomain = env->sc_rtable;
		DPRINTF("%s rtable %d",__func__,env->sc_rtable);

		if (rio.rule.proto == IPPROTO_TCP)
			rio.rule.timeout[PFTM_TCP_ESTABLISHED] =
			    (u_int32_t)MINIMUM(rdr->conf.timeout.tv_sec,
			    INT_MAX);

		if (strlen(rdr->conf.tag))
			(void)strlcpy(rio.rule.tagname, rdr->conf.tag,
			    sizeof(rio.rule.tagname));
		if (strlen(address->ifname))
			(void)strlcpy(rio.rule.ifname, address->ifname,
			    sizeof(rio.rule.ifname));

		if (address->ss.ss_family == AF_INET) {
			sain = (struct sockaddr_in *)&address->ss;

			rio.rule.dst.addr.v.a.addr.addr32[0] =
			    sain->sin_addr.s_addr;
			rio.rule.dst.addr.v.a.mask.addr32[0] = 0xffffffff;
		} else {
			sain6 = (struct sockaddr_in6 *)&address->ss;

			memcpy(&rio.rule.dst.addr.v.a.addr.v6,
			    &sain6->sin6_addr.s6_addr,
			    sizeof(sain6->sin6_addr.s6_addr));
			memset(&rio.rule.dst.addr.v.a.mask.addr8, 0xff, 16);
		}

		rio.rule.nat.addr.type = PF_ADDR_NONE;
		rio.rule.rdr.addr.type = PF_ADDR_TABLE;
		if (strlen(t->conf.ifname))
			(void)strlcpy(rio.rule.rdr.ifname, t->conf.ifname,
			    sizeof(rio.rule.rdr.ifname));
		if (strlcpy(rio.rule.rdr.addr.v.tblname, rdr->conf.name,
		    sizeof(rio.rule.rdr.addr.v.tblname)) >=
		    sizeof(rio.rule.rdr.addr.v.tblname))
			fatal("%s: table name too long", __func__);

		if (address->port.op == PF_OP_EQ ||
		    rdr->table->conf.flags & F_PORT) {
			rio.rule.rdr.proxy_port[0] =
			    ntohs(rdr->table->conf.port);
			rio.rule.rdr.port_op = PF_OP_EQ;
		}

		switch (rdr->conf.mode) {
		case RELAY_DSTMODE_RANDOM:
			rio.rule.rdr.opts = PF_POOL_RANDOM;
			break;
		case RELAY_DSTMODE_ROUNDROBIN:
			rio.rule.rdr.opts = PF_POOL_ROUNDROBIN;
			break;
		case RELAY_DSTMODE_SRCHASH:
			rio.rule.rdr.opts = PF_POOL_SRCHASH;
			break;
		case RELAY_DSTMODE_LEASTSTATES:
			rio.rule.rdr.opts = PF_POOL_LEASTSTATES;
			break;
		default:
			fatalx("%s: unsupported mode", __func__);
			/* NOTREACHED */
		}
		if (rdr->conf.flags & F_STICKY)
			rio.rule.rdr.opts |= PF_POOL_STICKYADDR;
		if (rdr->conf.flags & F_HASHKEY)
			memcpy(rio.rule.rdr.key.key32, rdr->conf.key.data,
			    sizeof(rio.rule.rdr.key.key32));

		if (rio.rule.rt == PF_ROUTETO) {
			memcpy(&rio.rule.route, &rio.rule.rdr,
			    sizeof(rio.rule.route));
			rio.rule.rdr.addr.type = PF_ADDR_NONE;
		}

		if (ioctl(env->sc_pf->dev, DIOCADDRULE, &rio) == -1)
			fatal("cannot add rule");
		log_debug("%s: rule added to anchor \"%s\"", __func__, anchor);
	}
	if (transaction_commit(env) == -1)
		log_warn("%s: add rules transaction failed", __func__);
	return;

 toolong:
	fatal("%s: name too long", __func__);
}

void
flush_rulesets(struct relayd *env)
{
	struct rdr	*rdr;
	char		 anchor[PF_ANCHOR_NAME_SIZE];

	if (!(env->sc_conf.flags & F_NEEDPF))
		return;

	kill_tables(env);
	TAILQ_FOREACH(rdr, env->sc_rdrs, entry) {
		if (strlcpy(anchor, RELAYD_ANCHOR "/", sizeof(anchor)) >=
		    PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (strlcat(anchor, rdr->conf.name, sizeof(anchor)) >=
		    PF_ANCHOR_NAME_SIZE)
			goto toolong;
		if (transaction_init(env, anchor) == -1 ||
		    transaction_commit(env) == -1)
			log_warn("%s: transaction for %s/ failed", __func__,
			    RELAYD_ANCHOR);
	}
	if (strlcpy(anchor, RELAYD_ANCHOR, sizeof(anchor)) >=
	    PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (transaction_init(env, anchor) == -1 ||
	    transaction_commit(env) == -1)
		log_warn("%s: transaction for %s failed", __func__,
		    RELAYD_ANCHOR);
	log_debug("%s: flushed rules", __func__);
	return;

 toolong:
	fatal("%s: name too long", __func__);
}

int
natlook(struct relayd *env, struct ctl_natlook *cnl)
{
	struct pfioc_natlook	 pnl;
	struct sockaddr_in	*in, *out;
	struct sockaddr_in6	*in6, *out6;
	char			 ibuf[BUFSIZ], obuf[BUFSIZ];

	if (!(env->sc_conf.flags & F_NEEDPF))
		return (0);

	bzero(&pnl, sizeof(pnl));

	if ((pnl.af = cnl->src.ss_family) != cnl->dst.ss_family)
		fatalx("%s: illegal address families", __func__);
	switch (pnl.af) {
	case AF_INET:
		in = (struct sockaddr_in *)&cnl->src;
		out = (struct sockaddr_in *)&cnl->dst;
		bcopy(&in->sin_addr, &pnl.saddr.v4, sizeof(pnl.saddr.v4));
		pnl.sport = in->sin_port;
		bcopy(&out->sin_addr, &pnl.daddr.v4, sizeof(pnl.daddr.v4));
		pnl.dport = out->sin_port;
		break;
	case AF_INET6:
		in6 = (struct sockaddr_in6 *)&cnl->src;
		out6 = (struct sockaddr_in6 *)&cnl->dst;
		bcopy(&in6->sin6_addr, &pnl.saddr.v6, sizeof(pnl.saddr.v6));
		pnl.sport = in6->sin6_port;
		bcopy(&out6->sin6_addr, &pnl.daddr.v6, sizeof(pnl.daddr.v6));
		pnl.dport = out6->sin6_port;
	}
	pnl.proto = cnl->proto;
	pnl.direction = PF_IN;
	cnl->in = 1;

	if (ioctl(env->sc_pf->dev, DIOCNATLOOK, &pnl) == -1) {
		pnl.direction = PF_OUT;
		cnl->in = 0;
		if (ioctl(env->sc_pf->dev, DIOCNATLOOK, &pnl) == -1) {
			log_debug("%s: ioctl: %s", __func__, strerror(errno));
			return (-1);
		}
	}

	inet_ntop(pnl.af, &pnl.rsaddr, ibuf, sizeof(ibuf));
	inet_ntop(pnl.af, &pnl.rdaddr, obuf, sizeof(obuf));
	log_debug("%s: %s %s:%d -> %s:%d", __func__,
	    pnl.direction == PF_IN ? "in" : "out",
	    ibuf, ntohs(pnl.rsport), obuf, ntohs(pnl.rdport));

	switch (pnl.af) {
	case AF_INET:
		in = (struct sockaddr_in *)&cnl->rsrc;
		out = (struct sockaddr_in *)&cnl->rdst;
		bcopy(&pnl.rsaddr.v4, &in->sin_addr, sizeof(in->sin_addr));
		in->sin_port = pnl.rsport;
		bcopy(&pnl.rdaddr.v4, &out->sin_addr, sizeof(out->sin_addr));
		out->sin_port = pnl.rdport;
		break;
	case AF_INET6:
		in6 = (struct sockaddr_in6 *)&cnl->rsrc;
		out6 = (struct sockaddr_in6 *)&cnl->rdst;
		bcopy(&pnl.rsaddr.v6, &in6->sin6_addr, sizeof(in6->sin6_addr));
		bcopy(&pnl.rdaddr.v6, &out6->sin6_addr,
		    sizeof(out6->sin6_addr));
		break;
	}
	cnl->rsrc.ss_family = pnl.af;
	cnl->rdst.ss_family = pnl.af;
	cnl->rsport = pnl.rsport;
	cnl->rdport = pnl.rdport;

	return (0);
}

u_int64_t
check_table(struct relayd *env, struct rdr *rdr, struct table *table)
{
	struct pfioc_table	 io;
	struct pfr_tstats	 tstats;

	if (table == NULL)
		return (0);

	bzero(&io, sizeof(io));
	io.pfrio_esize = sizeof(struct pfr_tstats);
	io.pfrio_size = 1;
	io.pfrio_buffer = &tstats;
	if (strlcpy(io.pfrio_table.pfrt_anchor, RELAYD_ANCHOR "/",
	    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcat(io.pfrio_table.pfrt_anchor, rdr->conf.name,
	    sizeof(io.pfrio_table.pfrt_anchor)) >= PF_ANCHOR_NAME_SIZE)
		goto toolong;
	if (strlcpy(io.pfrio_table.pfrt_name, rdr->conf.name,
	    sizeof(io.pfrio_table.pfrt_name)) >=
	    sizeof(io.pfrio_table.pfrt_name))
		goto toolong;

	if (ioctl(env->sc_pf->dev, DIOCRGETTSTATS, &io) == -1)
		fatal("%s: cannot get table stats", __func__);

	return (tstats.pfrts_match);

 toolong:
	fatal("%s: name too long", __func__);
	return (0);
}
@


1.61
log
@move the opening of /dev/pf from the parent process to the pfe process
where it is used.
Currently pf is opened on every reload, that will no longer be
possible in the future with pledged programms that do ioctls.
This prepares relayd for that change.

ok deraadt@@, meinetwegen reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.60 2016/09/02 14:45:51 reyk Exp $	*/
d77 1
a77 1
		fatalx("init_tables: table count modified");
d85 1
a85 1
		fatal("init_tables: cannot create tables");
d102 1
a102 1
	fatal("init_tables: name too long");
d124 1
a124 1
			fatal("kill_tables: ioctl failed");
d131 1
a131 1
	fatal("kill_tables: name too long");
d195 1
a195 1
			fatalx("sync_table: unknown address family");
d201 1
a201 1
		fatalx("sync_table: desynchronized");
d204 1
a204 1
		fatal("sync_table: cannot set address list");
d216 1
a216 1
	fatal("sync_table: name too long");
d252 1
a252 1
			fatalx("kill_srcnodes: unknown address family");
d261 1
a261 1
			fatal("kill_srcnodes: cannot kill src nodes");
d288 1
a288 1
		fatal("flush_table: cannot flush table addresses");
d294 1
a294 1
		fatal("flush_table: cannot flush table stats");
d300 1
a300 1
	fatal("flush_table: name too long");
d396 1
a396 1
			fatalx("sync_ruleset: invalid forward mode");
d448 1
a448 1
			fatal("sync_ruleset: table name too long");
d471 1
a471 1
			fatalx("sync_ruleset: unsupported mode");
d495 1
a495 1
	fatal("sync_ruleset: name too long");
d531 1
a531 1
	fatal("flush_rulesets: name too long");
d548 1
a548 1
		fatalx("natlook: illegal address families");
d635 1
a635 1
		fatal("check_table: cannot get table stats");
d640 1
a640 1
	fatal("check_table: name too long");
@


1.60
log
@Split "struct relayd" into two structs: "struct relayd" and "struct
relayd_config".  This way we can send all the relevant global
configuration to the children, not just the flags and the opts.

With input from and
OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.59 2015/11/29 01:20:33 benno Exp $	*/
a41 8
struct pfdata {
	int			 dev;
	struct pf_anchor	*anchor;
	struct pfioc_trans	 pft;
	struct pfioc_trans_e	 pfte;
	u_int8_t		 pfused;
};

a45 23

void
init_filter(struct relayd *env, int s)
{
	struct pf_status	status;

	if (!(env->sc_conf.flags & F_NEEDPF))
		return;

	if (s == -1)
		fatalx("init_filter: invalid socket");
	if (env->sc_pf == NULL) {
		if ((env->sc_pf = calloc(1, sizeof(*(env->sc_pf)))) == NULL)
			fatal("calloc");
	} else
		close(env->sc_pf->dev);
	env->sc_pf->dev = s;
	if (ioctl(env->sc_pf->dev, DIOCGETSTATUS, &status) == -1)
		fatal("init_filter: DIOCGETSTATUS");
	if (!status.running)
		fatalx("init_filter: pf is disabled");
	log_debug("%s: filter init done", __func__);
}
@


1.59
log
@Use pledge("pf") in pfe.c.
Move getrtable() from pfe to parent process, since its in the way of
pledge.

ok deraadt@@, feedback from reyk@@ on previous version.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.58 2015/01/22 17:42:09 reyk Exp $	*/
d60 1
a60 1
	if (!(env->sc_flags & F_NEEDPF))
d86 1
a86 1
	if (!(env->sc_flags & F_NEEDPF))
d143 1
a143 1
	if (!(env->sc_flags & F_NEEDPF))
d175 1
a175 1
	if (!(env->sc_flags & F_NEEDPF))
d240 1
a240 1
	if (env->sc_opts & RELAYD_OPT_LOGUPDATE)
d304 1
a304 1
	if (!(env->sc_flags & F_NEEDPF))
d373 1
a373 1
	if ((env->sc_flags & F_NEEDPF) == 0)
d535 1
a535 1
	if (!(env->sc_flags & F_NEEDPF))
d573 1
a573 1
	if (!(env->sc_flags & F_NEEDPF))
@


1.58
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.57 2015/01/22 15:21:28 reyk Exp $	*/
d441 2
a442 1
		rio.rule.onrdomain = getrtable();
@


1.57
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.56 2015/01/21 21:50:33 deraadt Exp $	*/
d22 1
d25 1
a28 1
#include <net/if.h>
a31 2
#include <fcntl.h>
#include <event.h>
a36 2

#include <openssl/ssl.h>
@


1.56
log
@Include <netinet/in.h> before <net/pfvar.h>.  In a future change when
ports is ready, <net/pfvar.h> will stop including a pile of balony.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.55 2015/01/16 15:06:40 deraadt Exp $	*/
d448 2
a449 1
			    (u_int32_t)MINIMUM(rdr->conf.timeout.tv_sec, INT_MAX);
@


1.55
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.54 2014/12/23 13:18:23 reyk Exp $	*/
a23 2
#include <net/if.h>
#include <net/pfvar.h>
d27 2
@


1.54
log
@pf now supports source-hash and random with tables so we can allow it
in redirections.  Thanks for help and input from jsg and yasuoka who
reminded me to dig out and update these old diffs for pf and relayd.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.53 2013/04/27 16:39:30 benno Exp $	*/
d41 2
d448 1
a448 1
			    (u_int32_t)MIN(rdr->conf.timeout.tv_sec, INT_MAX);
@


1.53
log
@time_t 64bit fixes for relayd and relayctl:
- fix statistics
- set INT_MAX limit on session timeouts
- make sure we dont use to large session timeouts in pf redirects and
  openssl

tested with old and new time_t

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.52 2012/10/19 16:49:50 reyk Exp $	*/
d488 3
d494 3
d506 3
@


1.52
log
@Support additional scheduling algorithms in the load balancer:
least-states, random, source-hash.  least-states is currently only
supported for redirections and the other ones are currently only
supported by relays.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.51 2012/10/04 20:53:30 reyk Exp $	*/
d446 1
a446 1
			    rdr->conf.timeout.tv_sec;
@


1.51
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.50 2012/09/18 10:11:53 henning Exp $	*/
d486 12
a497 1
		rio.rule.rdr.opts = PF_POOL_ROUNDROBIN;
@


1.50
log
@prio 0 is valid, therefore, I chose an "impossible" value for prio meaning
"not set" and used a PF_PRIO_NOTSET define for it. now that means that
everything that creates a struct pf_rule doesn't get away with bzero'ing it,
which turned out to be not so nice. so get rid of PF_PRIO_NOTSET, instead,
make a rule+state flag PFSTATE_SETPRIO which indicates wether the prio
should be set. ok benno claudio mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.49 2012/07/07 16:24:32 henning Exp $	*/
d492 1
a492 1
			   sizeof(rio.rule.route));
@


1.49
log
@rename prio in struct pf_rule and related structs to set_prio so it is
utterly clear this is not a filter criteria but a packet modification thing.
also preparation for upcoming changes, including one to unscrew this mess
(I should not have to touch half the tree for this - ifixitlater)
not user visible, ok gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.47 2011/05/19 08:56:49 reyk Exp $	*/
a442 1
		rio.rule.set_prio[0] = rio.rule.set_prio[1] = PF_PRIO_NOTSET;
@


1.48
log
@set onrdomain and prio when creating pf rules, found by Gabriel Linder.
ok henning@@ phessler@@ camield@@ "looks good to me" mkb@@
@
text
@d443 1
a443 1
		rio.rule.prio[0] = rio.rule.prio[1] = PF_PRIO_NOTSET;
@


1.47
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.46 2011/05/05 12:01:44 reyk Exp $	*/
d442 2
@


1.46
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.45 2010/10/26 15:04:37 reyk Exp $	*/
d36 1
d57 1
a57 1
init_filter(struct relayd *env)
d64 8
a71 4
	if ((env->sc_pf = calloc(1, sizeof(*(env->sc_pf)))) == NULL)
		fatal("calloc");
	if ((env->sc_pf->dev = open(PF_SOCKET, O_RDWR)) == -1)
		fatal("init_filter: cannot open pf socket");
d374 1
a374 1
	if (!(env->sc_flags & F_NEEDPF))
@


1.45
log
@redirects are loaded as "pass in quick ... rdr-to" pf rules by default. In
some cases it is desired to load the rules as "match in" without "quick"
to allow additional filtering or applying additional rule/state options,
eg. to add an overload table for DOS mitigation.  Add the optional "match"
keyword for the redirect "tag" option to change the pf rule type accordingly.

ok jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.44 2010/09/02 14:03:22 sobrado Exp $	*/
d71 1
a71 1
	log_debug("init_filter: filter init done");
d113 1
a113 1
	log_debug("init_tables: created %d tables", io.pfrio_nadd);
d154 1
a154 1
	log_debug("kill_tables: deleted %d tables", cnt);
d323 1
a323 1
	log_debug("flush_table: flushed table %s", rdr->conf.name);
d380 1
a380 1
		log_warn("sync_ruleset: transaction init failed");
d386 2
a387 2
			log_warn("sync_ruleset: "
			    "remove rules transaction failed");
d389 1
a389 1
			log_debug("sync_ruleset: rules removed");
d492 1
a492 2
		log_debug("sync_ruleset: rule added to anchor \"%s\"",
		    anchor);
d495 1
a495 1
		log_warn("sync_ruleset: add rules transaction failed");
d521 1
a521 1
			log_warn("flush_rulesets: transaction for %s/ failed",
d529 1
a529 1
		log_warn("flush_rulesets: transaction for %s failed",
d531 1
a531 1
	log_debug("flush_rulesets: flushed rules");
d578 1
a578 1
			log_debug("natlook: error: %s", strerror(errno));
d585 1
a585 1
	log_debug("natlook: %s %s:%d -> %s:%d",
@


1.44
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.43 2010/03/24 16:29:37 pyr Exp $	*/
d397 7
a403 1
		rio.rule.action = PF_PASS;
a404 1
		rio.rule.quick = 1; /* force first match */
@


1.43
log
@DSR got broken with the move towards the new pf.
This fixes it.

Found out by Laurent Lavaud & myself.

"looks olrite" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.42 2010/01/12 23:27:23 dlg Exp $	*/
d267 1
a267 1
		sain = (struct sockaddr_in *)&host->conf.ss;   
d269 1
a269 1
			    &psnk.psnk_dst.addr.v.a.addr.v4, 
d277 1
a277 1
			break;   
d282 1
a282 1
			
@


1.42
log
@when generating rdr rules, ensure the nat address is PF_ADDR_NONE to avoid
confusing pf.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.40 2009/11/23 00:45:41 claudio Exp $	*/
d478 6
@


1.41
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d459 1
@


1.40
log
@Unbreak tree, rs_num is now type and while there use PF_TRANS_RULESET instead
of the hardcoded 0. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.39 2009/09/01 13:43:36 reyk Exp $	*/
a362 1
	struct pfioc_pooladdr	 pio;
a394 1
		memset(&pio, 0, sizeof(pio));
a422 2
		if (ioctl(env->sc_pf->dev, DIOCBEGINADDRS, &pio) == -1)
			fatal("sync_ruleset: cannot initialise address pool");
a423 1
		rio.pool_ticket = pio.ticket;
d459 1
a459 1
		pio.addr.addr.type = PF_ADDR_TABLE;
d461 5
a465 5
			(void)strlcpy(pio.addr.ifname, t->conf.ifname,
			    sizeof(pio.addr.ifname));
		if (strlcpy(pio.addr.addr.v.tblname, rdr->conf.name,
		    sizeof(pio.addr.addr.v.tblname)) >=
		    sizeof(pio.addr.addr.v.tblname))
a466 3
		pio.which = PF_RDR;
		if (ioctl(env->sc_pf->dev, DIOCADDADDR, &pio) == -1)
			fatal("sync_ruleset: cannot add address to pool");
@


1.39
log
@sync with new pf

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.38 2009/04/24 14:20:24 reyk Exp $	*/
d340 1
a340 1
	env->sc_pf->pfte.rs_num = 0;
@


1.38
log
@Allow UDP and/or TCP redirections instead of just TCP.

Thanks to Marek Grzybowski for feedback and testing.

ok jmc@@ (manpage bits)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.37 2009/04/01 14:08:53 reyk Exp $	*/
d27 1
d45 2
a46 2
	struct pfioc_trans	 pft[PF_RULESET_MAX];
	struct pfioc_trans_e	 pfte[PF_RULESET_MAX];
d333 12
a344 1
	int i;
a345 14
	for (i = 0; i < PF_RULESET_MAX; i++) {
		env->sc_pf->pft[i].size = 1;
		env->sc_pf->pft[i].esize = sizeof(env->sc_pf->pfte[i]);
		env->sc_pf->pft[i].array = &env->sc_pf->pfte[i];

		bzero(&env->sc_pf->pfte[i], sizeof(env->sc_pf->pfte[i]));
		(void)strlcpy(env->sc_pf->pfte[i].anchor,
		    anchor, PF_ANCHOR_NAME_SIZE);
		env->sc_pf->pfte[i].rs_num = i;

		if (ioctl(env->sc_pf->dev, DIOCXBEGIN,
		    &env->sc_pf->pft[i]) == -1)
			return (-1);
	}
d352 3
a354 1
	int i;
a355 5
	for (i = 0; i < PF_RULESET_MAX; i++) {
		if (ioctl(env->sc_pf->dev, DIOCXCOMMIT,
		    &env->sc_pf->pft[i]) == -1)
			return (-1);
	}
a367 1
	int			 rs;
d399 5
d406 5
a410 3
			/* traditional redirection in the rdr-anchor */
			rs = PF_RULESET_RDR;
			rio.rule.action = PF_RDR;
a413 2
			rs = PF_RULESET_FILTER;
			rio.rule.action = PF_PASS;
a414 2
			rio.rule.direction = PF_IN;
			rio.rule.quick = 1; /* force first match */
a416 1
			rio.rule.keep_state = PF_STATE_NORMAL;
d424 1
a424 1
		rio.ticket = env->sc_pf->pfte[rs].ticket;
d472 1
d478 1
a478 1
			rio.rule.rpool.proxy_port[0] =
d480 1
a480 1
			rio.rule.rpool.port_op = PF_OP_EQ;
d482 1
a482 1
		rio.rule.rpool.opts = PF_POOL_ROUNDROBIN;
d484 1
a484 1
			rio.rule.rpool.opts |= PF_POOL_STICKYADDR;
d488 2
a489 3
		log_debug("sync_ruleset: rule added to %sanchor \"%s\"",
		    rdr->table->conf.fwdmode == FWD_ROUTE ?
		    "" : "rdr-", anchor);
@


1.37
log
@terminate and cleanup properly by setting the pf anchor names
correctly (anchor names with characters after the terminating NUL byte
are considered invalid).

Thanks to camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.36 2008/12/08 10:59:44 reyk Exp $	*/
a427 2
		rio.rule.timeout[PFTM_TCP_ESTABLISHED] =
		    rdr->conf.timeout.tv_sec;
d434 1
a434 1
		rio.rule.proto = IPPROTO_TCP;
d441 4
@


1.36
log
@change the handling of redirections with the sticky-address option set:
instead of flushing the complete source tracking table (sticky
addresses) in pf on host state changes, just flush the entries for
hosts that have been marked as down in the relayd table.  this fixes
ugly problems with users loosing their sessions if another host or
redirection was going down.

ok cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.35 2008/12/04 17:13:20 reyk Exp $	*/
d132 2
a133 1
kill_tables(struct relayd *env) {
d136 1
a140 1
	memset(&io, 0, sizeof(io));
d142 1
d150 2
a151 1
			fatal("kill_tables: ioctl faile: ioctl failed");
d153 1
a153 1
	log_debug("kill_tables: deleted %d tables", io.pfrio_ndel);
@


1.35
log
@cosmetic changes:
- log table changes in sync_table() if "log updates" is enabled.
before we only logged these changes in debug mode when running relayd
in foreground.
- type in a log message
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.34 2008/09/29 15:12:22 reyk Exp $	*/
d52 1
d160 1
a160 1
	int			 i;
d228 2
a229 5
	if (rdr->conf.flags & F_STICKY) {
		if (ioctl(env->sc_pf->dev, DIOCCLRSRCNODES, 0) == -1)
			fatal("sync_table: cannot clear the tree of "
			    "source tracking nodes");
	}
d234 2
a235 3
		    "%d changed",
		    io.pfrio_table.pfrt_name,
		    io.pfrio_nadd, io.pfrio_ndel, io.pfrio_nchange);
d240 49
@


1.34
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.33 2008/09/29 09:58:51 reyk Exp $	*/
d234 5
a238 3
	log_debug("sync_table: table %s: %d added, %d deleted, %d changed",
	    io.pfrio_table.pfrt_name,
	    io.pfrio_nadd, io.pfrio_ndel, io.pfrio_nchange);
d589 1
a589 1
		fatal("sync_table: cannot get table stats");
@


1.33
log
@allow to listen on a port range for redirections.  this fixes
stickyness with web applications that cannot do the clustering on
their own and require stickyness with HTTP to HTTPS migration.  this
is required in many cases; it is a true fact that we cannot always fix
the backend application in the real world.

Tested and requested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.32 2008/07/16 14:38:33 reyk Exp $	*/
d287 1
a287 1
	
@


1.32
log
@fix nat lookup to use the correct pf_addr offset.  now it also works
with ipv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.31 2008/07/09 14:57:01 reyk Exp $	*/
d388 3
a390 2
		rio.rule.dst.port_op = PF_OP_EQ;
		rio.rule.dst.port[0] = address->port;
d426 6
a431 2
		rio.rule.rpool.proxy_port[0] = ntohs(rdr->table->conf.port);
		rio.rule.rpool.port_op = PF_OP_EQ;
@


1.31
log
@also set the protocol, either TCP or UDP, in the NAT lookup.  this
unbreaks NAT lookups with UDP; tested as a transparent DNS relay.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.30 2008/06/11 18:21:19 reyk Exp $	*/
d500 1
a500 1
		bcopy(&in->sin_addr, &pnl.saddr.addr8, in->sin_len);
d502 1
a502 1
		bcopy(&out->sin_addr, &pnl.daddr.addr8, out->sin_len);
d508 1
a508 1
		bcopy(&in6->sin6_addr, &pnl.saddr.addr8, in6->sin6_len);
d510 1
a510 1
		bcopy(&out6->sin6_addr, &pnl.daddr.addr8, out6->sin6_len);
d521 1
a521 1
			log_debug("natlook: error");
d536 1
a536 1
		bcopy(&pnl.rsaddr.addr8, &in->sin_addr, sizeof(in->sin_addr));
d538 1
a538 1
		bcopy(&pnl.rdaddr.addr8, &out->sin_addr, sizeof(out->sin_addr));
d544 2
a545 3
		bcopy(&pnl.rsaddr.addr8, &in6->sin6_addr,
		    sizeof(in6->sin6_addr));
		bcopy(&pnl.rdaddr.addr8, &out6->sin6_addr,
@


1.30
log
@add support for "transparent" forwarding in relays: normally the l7
relay will connect to the target host with its own ip address, but
this mode will let it use the address of the client that is connecting
from the other side. for example, there is no need to add the
X-Forwarded-For HTTP headers for internal webservers in this mode
anymore since they magically see the remote client ip address in the
connection. it also allows to build fully-transparent ssl
encapsulation for tcp sessions and many other things...

based on an initial idea from dlg@@ and pascoe@@ (dlg's talk at opencon)
using the new BINDANY and divert-reply interfaces from markus@@ (since n2k8)

ok markus@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.29 2008/06/10 23:12:36 reyk Exp $	*/
d513 1
a513 1
	pnl.proto = IPPROTO_TCP;
@


1.29
log
@set the inactivity timeout of redirections to a shorter timeout of 600
seconds by default (pf's default is 86400s), they can be cranked with
the "session timeout" directive and it is consistent to relay session
timeouts. also remove the hack to modify the closing timeout because
pf's sloppy state handling is taking care about half connection
closing now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.28 2008/06/10 22:02:28 reyk Exp $	*/
d354 2
a355 1
		if ((t->conf.flags & F_ROUTE) == 0) {
d359 2
a360 1
		} else {
d371 4
d434 2
a435 1
		    rdr->table->conf.flags & F_ROUTE ? "" : "rdr-", anchor);
@


1.28
log
@use sloppy pf state keeping for routed sessions (direct server return)
where we only see the client side of the TCP session; this removes the
timeout limitations that we had before. document "route to" in the
manpage since it is fully working now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.27 2008/05/16 14:47:58 pyr Exp $	*/
a368 2
			rio.rule.timeout[PFTM_TCP_CLOSING] =
			    rdr->conf.timeout.tv_sec;
d371 2
@


1.27
log
@Clear source nodes on table changes in sticky mode. This has the
disadvantage of removing valid src nodes, but the advantage of not sending
out traffic to hosts that are not up anymore.

From a diff by <mkoc@@prime.pl>, ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.26 2008/05/07 01:49:29 reyk Exp $	*/
d366 1
a366 1
			/* XXX This should use a loose pf state handling */
d368 2
a369 1
			rio.rule.timeout[PFTM_TCP_OPENING] =
@


1.26
log
@add an alternative "route to" mode to relayd redirections which maps
to pf route-to instead of the default rdr. it is a first steps towards
support for "direct server return" (dsr), an asynchronous mode where
the load balanced servers send the replies to a different gateway like
a l3 switch/router to handle higher amounts of return traffic.
because the state handling in pf isn't optimal for this case yet, it
just sees half of the TCP connection, the sessions are forced to time
out after fixed number of seconds.

discussed with many, thought about in the onsen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.25 2008/05/06 11:52:49 reyk Exp $	*/
d227 5
a231 1

@


1.25
log
@fix the table stats clr ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.24 2008/05/06 06:09:48 pyr Exp $	*/
d44 3
a46 2
	struct pfioc_trans	 pft;
	struct pfioc_trans_e	 pfte;
d277 1
a277 7
	env->sc_pf->pft.size = 1;
	env->sc_pf->pft.esize = sizeof env->sc_pf->pfte;
	env->sc_pf->pft.array = &env->sc_pf->pfte;

	memset(&env->sc_pf->pfte, 0, sizeof env->sc_pf->pfte);
	(void)strlcpy(env->sc_pf->pfte.anchor, anchor, PF_ANCHOR_NAME_SIZE);
	env->sc_pf->pfte.rs_num = PF_RULESET_RDR;
d279 14
a292 2
	if (ioctl(env->sc_pf->dev, DIOCXBEGIN, &env->sc_pf->pft) == -1)
		return (-1);
d299 7
a305 2
	if (ioctl(env->sc_pf->dev, DIOCXCOMMIT, &env->sc_pf->pft) == -1)
		return (-1);
d318 2
d350 19
a368 1
		rio.ticket = env->sc_pf->pfte.ticket;
d380 1
a380 1
		rio.rule.action = PF_RDR;
a393 1

d404 3
d422 2
a423 1
		log_debug("sync_ruleset: rule added");
@


1.24
log
@Do not unconditionnaly load pf. If pf isn't required by the configuration
the initialisation isn't done properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.23 2008/01/31 09:33:39 reyk Exp $	*/
d259 4
d265 1
@


1.23
log
@add prefixes to names of structure elements to make it easier to grep
for code, start with struct relayd.  finally.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.22 2007/12/20 20:15:43 reyk Exp $	*/
d57 3
d79 3
d134 3
d165 3
d243 3
d302 3
d399 3
d436 3
@


1.22
log
@implement statistics for redirections, like the existing statistics
for relays.  they can be viewed with the new "relayctl show redirects"
command.

(uses the previous change to pf_table.c to get the statistics)

looks good pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.21 2007/12/08 20:36:36 pyr Exp $	*/
d57 1
a57 1
	if ((env->pf = calloc(1, sizeof(*(env->pf)))) == NULL)
d59 1
a59 1
	if ((env->pf->dev = open(PF_SOCKET, O_RDWR)) == -1)
d61 1
a61 1
	if (ioctl(env->pf->dev, DIOCGETSTATUS, &status) == -1)
d76 1
a76 1
	if ((tables = calloc(env->rdrcount, sizeof(*tables))) == NULL)
d80 1
a80 1
	TAILQ_FOREACH(rdr, env->rdrs, entry) {
d94 1
a94 1
	if (i != env->rdrcount)
d98 1
a98 1
	io.pfrio_size = env->rdrcount;
d102 1
a102 1
	if (ioctl(env->pf->dev, DIOCRADDTABLES, &io) == -1)
d108 1
a108 1
	if (io.pfrio_nadd == env->rdrcount)
d114 1
a114 1
	TAILQ_FOREACH(rdr, env->rdrs, entry)
d129 1
a129 1
	TAILQ_FOREACH(rdr, env->rdrs, entry) {
d136 1
a136 1
		if (ioctl(env->pf->dev, DIOCRCLRTABLES, &io) == -1)
d212 1
a212 1
	if (ioctl(env->pf->dev, DIOCRSETADDRS, &io) == -1)
d242 1
a242 1
	if (ioctl(env->pf->dev, DIOCRCLRADDRS, &io) == -1)
d244 1
a244 1
	if (ioctl(env->pf->dev, DIOCRCLRTSTATS, &io) == -1)
d256 7
a262 7
	env->pf->pft.size = 1;
	env->pf->pft.esize = sizeof env->pf->pfte;
	env->pf->pft.array = &env->pf->pfte;

	memset(&env->pf->pfte, 0, sizeof env->pf->pfte);
	(void)strlcpy(env->pf->pfte.anchor, anchor, PF_ANCHOR_NAME_SIZE);
	env->pf->pfte.rs_num = PF_RULESET_RDR;
d264 1
a264 1
	if (ioctl(env->pf->dev, DIOCXBEGIN, &env->pf->pft) == -1)
d272 1
a272 1
	if (ioctl(env->pf->dev, DIOCXCOMMIT, &env->pf->pft) == -1)
d313 2
a314 2
		rio.ticket = env->pf->pfte.ticket;
		if (ioctl(env->pf->dev, DIOCBEGINADDRS, &pio) == -1)
d354 1
a354 1
		if (ioctl(env->pf->dev, DIOCADDADDR, &pio) == -1)
d363 1
a363 1
		if (ioctl(env->pf->dev, DIOCADDRULE, &rio) == -1)
d382 1
a382 1
	TAILQ_FOREACH(rdr, env->rdrs, entry) {
d441 1
a441 1
	if (ioctl(env->pf->dev, DIOCNATLOOK, &pnl) == -1) {
d444 1
a444 1
		if (ioctl(env->pf->dev, DIOCNATLOOK, &pnl) == -1) {
d506 1
a506 1
	if (ioctl(env->pf->dev, DIOCRGETTSTATS, &io) == -1)
@


1.21
log
@Rename everything which reffered to services refer to rdr for internals
(for instance: rename struct service to struct rdr), refer to redirects
otherwise (hoststatectl output).
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.20 2007/12/07 17:17:00 reyk Exp $	*/
d243 3
a245 1
		fatal("flush_table: cannot flush table");
d479 34
@


1.20
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.19 2007/11/24 17:07:28 reyk Exp $	*/
d72 1
a72 1
	struct service		*service;
d76 1
a76 1
	if ((tables = calloc(env->servicecount, sizeof(*tables))) == NULL)
d80 1
a80 1
	TAILQ_FOREACH(service, env->services, entry) {
d84 1
a84 1
		if (strlcat(tables[i].pfrt_anchor, service->conf.name,
d87 1
a87 1
		if (strlcpy(tables[i].pfrt_name, service->conf.name,
d94 1
a94 1
	if (i != env->servicecount)
d98 1
a98 1
	io.pfrio_size = env->servicecount;
d108 1
a108 1
	if (io.pfrio_nadd == env->servicecount)
d114 2
a115 2
	TAILQ_FOREACH(service, env->services, entry)
		flush_table(env, service);
d126 1
a126 1
	struct service		*service;
d129 1
a129 1
	TAILQ_FOREACH(service, env->services, entry) {
d133 1
a133 1
		if (strlcat(io.pfrio_table.pfrt_anchor, service->conf.name,
d147 1
a147 1
sync_table(struct relayd *env, struct service *service, struct table *table)
d160 1
a160 1
		flush_table(env, service);
d175 1
a175 1
	if (strlcat(io.pfrio_table.pfrt_anchor, service->conf.name,
d178 1
a178 1
	if (strlcpy(io.pfrio_table.pfrt_name, service->conf.name,
d227 1
a227 1
flush_table(struct relayd *env, struct service *service)
d235 1
a235 1
	if (strlcat(io.pfrio_table.pfrt_anchor, service->conf.name,
d238 1
a238 1
	if (strlcpy(io.pfrio_table.pfrt_name, service->conf.name,
d244 1
a244 1
	log_debug("flush_table: flushed table %s", service->conf.name);
d276 1
a276 1
sync_ruleset(struct relayd *env, struct service *service, int enable)
d289 1
a289 1
	if (strlcat(anchor, service->conf.name, sizeof(anchor)) >=
d306 1
a306 1
	TAILQ_FOREACH(address, &service->virts, entry) {
d324 2
a325 2
		if (strlen(service->conf.tag))
			(void)strlcpy(rio.rule.tagname, service->conf.tag,
d348 1
a348 1
		if (strlcpy(pio.addr.addr.v.tblname, service->conf.name,
d355 1
a355 1
		rio.rule.rpool.proxy_port[0] = ntohs(service->table->conf.port);
d358 1
a358 1
		if (service->conf.flags & F_STICKY)
d376 1
a376 1
	struct service	*service;
d380 1
a380 1
	TAILQ_FOREACH(service, env->services, entry) {
d384 1
a384 1
		if (strlcat(anchor, service->conf.name, sizeof(anchor)) >=
@


1.19
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.18 2007/09/28 13:29:56 pyr Exp $	*/
d39 1
a39 1
#include "hoststated.h"
d48 3
a50 3
int	 transaction_init(struct hoststated *, const char *);
int	 transaction_commit(struct hoststated *);
void	 kill_tables(struct hoststated *);
d53 1
a53 1
init_filter(struct hoststated *env)
d69 1
a69 1
init_tables(struct hoststated *env)
d81 1
a81 1
		if (strlcpy(tables[i].pfrt_anchor, HOSTSTATED_ANCHOR "/",
d124 1
a124 1
kill_tables(struct hoststated *env) {
d130 1
a130 1
		if (strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
d147 1
a147 1
sync_table(struct hoststated *env, struct service *service, struct table *table)
d172 1
a172 1
	if (strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
d227 1
a227 1
flush_table(struct hoststated *env, struct service *service)
d232 1
a232 1
	if (strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
d252 1
a252 1
transaction_init(struct hoststated *env, const char *anchor)
d268 1
a268 1
transaction_commit(struct hoststated *env)
d276 1
a276 1
sync_ruleset(struct hoststated *env, struct service *service, int enable)
d286 1
a286 1
	if (strlcpy(anchor, HOSTSTATED_ANCHOR "/", sizeof(anchor)) >=
d374 1
a374 1
flush_rulesets(struct hoststated *env)
d381 1
a381 1
		if (strlcpy(anchor, HOSTSTATED_ANCHOR "/", sizeof(anchor)) >=
d390 1
a390 1
			    HOSTSTATED_ANCHOR);
d392 1
a392 1
	if (strlcpy(anchor, HOSTSTATED_ANCHOR, sizeof(anchor)) >=
d398 1
a398 1
		    HOSTSTATED_ANCHOR);
d407 1
a407 1
natlook(struct hoststated *env, struct ctl_natlook *cnl)
@


1.18
log
@Correct my mail address.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.17 2007/05/31 03:24:05 pyr Exp $	*/
a22 1
#include <sys/param.h>
@


1.17
log
@allocate table lists and service lists instead of using static structs.
split the code to start the event loop in two functions.
introduce merge_config which will be used later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.16 2007/05/27 20:53:10 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Pierre-Yves Ritschard <pyr@@spootnik.org>
@


1.16
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.15 2007/02/22 05:58:06 reyk Exp $	*/
d81 1
a81 1
	TAILQ_FOREACH(service, &env->services, entry) {
d115 1
a115 1
	TAILQ_FOREACH(service, &env->services, entry)
d130 1
a130 1
	TAILQ_FOREACH(service, &env->services, entry) {
d381 1
a381 1
	TAILQ_FOREACH(service, &env->services, entry) {
@


1.15
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.14 2007/02/22 03:32:40 reyk Exp $	*/
d85 1
a85 1
		if (strlcat(tables[i].pfrt_anchor, service->name,
d88 1
a88 1
		if (strlcpy(tables[i].pfrt_name, service->name,
d134 1
a134 1
		if (strlcat(io.pfrio_table.pfrt_anchor, service->name,
d176 1
a176 1
	if (strlcat(io.pfrio_table.pfrt_anchor, service->name,
d179 1
a179 1
	if (strlcpy(io.pfrio_table.pfrt_name, service->name,
d189 1
a189 1
		switch (host->ss.ss_family) {
d191 1
a191 1
			sain = (struct sockaddr_in *)&host->ss;
d198 1
a198 1
			sain6 = (struct sockaddr_in6 *)&host->ss;
d236 1
a236 1
	if (strlcat(io.pfrio_table.pfrt_anchor, service->name,
d239 1
a239 1
	if (strlcpy(io.pfrio_table.pfrt_name, service->name,
d245 1
a245 1
	log_debug("flush_table: flushed table %s", service->name);
d290 1
a290 1
	if (strlcat(anchor, service->name, sizeof(anchor)) >=
d325 2
a326 2
		if (strlen(service->tag))
			(void)strlcpy(rio.rule.tagname, service->tag,
d349 1
a349 1
		if (strlcpy(pio.addr.addr.v.tblname, service->name,
d356 1
a356 1
		rio.rule.rpool.proxy_port[0] = ntohs(service->table->port);
d359 1
a359 1
		if (service->flags & F_STICKY)
d385 1
a385 1
		if (strlcat(anchor, service->name, sizeof(anchor)) >=
@


1.14
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.13 2007/02/20 04:06:17 reyk Exp $	*/
d241 1
a241 1
    	    sizeof(io.pfrio_table.pfrt_name))
d350 2
a351 1
		    sizeof(pio.addr.addr.v.tblname)) >= sizeof(pio.addr.addr.v.tblname))
d401 1
a401 1
 	return;
d467 4
a470 2
		bcopy(&pnl.rsaddr.addr8, &in6->sin6_addr, sizeof(in6->sin6_addr));
		bcopy(&pnl.rdaddr.addr8, &out6->sin6_addr, sizeof(out6->sin6_addr));
@


1.13
log
@use HOST_UP instead of an hard coded integer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.12 2007/02/08 13:32:24 reyk Exp $	*/
d404 72
@


1.12
log
@carefully check some return values and make lint happier.  never pass
any truncated strings (table names/anchors/tags/...) to pf and the
kernel.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.11 2007/02/07 14:45:12 reyk Exp $	*/
d186 1
a186 1
		if (host->up != 1)
@


1.11
log
@more log_debug() cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.10 2007/01/29 14:23:31 pyr Exp $	*/
d82 10
a91 6
		(void)strlcpy(tables[i].pfrt_anchor, HOSTSTATED_ANCHOR "/",
		    sizeof(tables[i].pfrt_anchor));
		(void)strlcat(tables[i].pfrt_anchor, service->name,
		    sizeof(tables[i].pfrt_anchor));
		(void)strlcpy(tables[i].pfrt_name, service->name,
		    sizeof(tables[i].pfrt_name));
d117 5
d131 6
a136 4
		(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
		    sizeof(io.pfrio_table.pfrt_anchor));
		(void)strlcat(io.pfrio_table.pfrt_anchor, service->name,
		    sizeof(io.pfrio_table.pfrt_anchor));
d141 4
d173 10
a182 6
	(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
	    sizeof(io.pfrio_table.pfrt_anchor));
	(void)strlcat(io.pfrio_table.pfrt_anchor, service->name,
	    sizeof(io.pfrio_table.pfrt_anchor));
	(void)strlcpy(io.pfrio_table.pfrt_name, service->name,
	    sizeof(io.pfrio_table.pfrt_name));
d221 4
d233 10
a242 6
	(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTSTATED_ANCHOR "/",
	    sizeof(io.pfrio_table.pfrt_anchor));
	(void)strlcat(io.pfrio_table.pfrt_anchor, service->name,
	    sizeof(io.pfrio_table.pfrt_anchor));
	(void)strlcpy(io.pfrio_table.pfrt_name, service->name,
	    sizeof(io.pfrio_table.pfrt_name));
d247 3
d260 1
a260 1
	strlcpy(env->pf->pfte.anchor, anchor, PF_ANCHOR_NAME_SIZE);
d287 10
a296 3
	(void)strlcpy(anchor, HOSTSTATED_ANCHOR "/", sizeof(anchor));
	(void)strlcat(anchor, service->name, sizeof(anchor));
	transaction_init(env, anchor);
d299 5
a303 2
		transaction_commit(env);
		log_debug("sync_ruleset: rules removed");
d349 3
a351 2
		(void)strlcpy(pio.addr.addr.v.tblname, service->name,
		    sizeof(pio.addr.addr.v.tblname));
d365 6
a370 1
	transaction_commit(env);
d381 10
a390 4
		strlcpy(anchor, HOSTSTATED_ANCHOR "/", sizeof(anchor));
		strlcat(anchor, service->name, sizeof(anchor));
		transaction_init(env, anchor);
		transaction_commit(env);
d392 7
a398 3
	strlcpy(anchor, HOSTSTATED_ANCHOR, sizeof(anchor));
	transaction_init(env, anchor);
	transaction_commit(env);
d400 4
@


1.10
log
@Add SSL support to hoststated.
with help and OK reyk@@
with help and advice by claudio@@ and Srebrenko Sehic
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.9 2007/01/09 13:50:11 pyr Exp $	*/
d101 1
a101 1
	log_debug("created %d tables", io.pfrio_nadd);
@


1.9
log
@Finish renaming hostated to hoststated.
Note to testers: the user the daemon changes its id to is now _hoststated,
don't forget to update master.passwd.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.8 2007/01/09 00:45:32 deraadt Exp $	*/
d37 2
@


1.8
log
@adapt to rename
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.7 2007/01/08 20:46:18 reyk Exp $	*/
d47 3
a49 3
int	 transaction_init(struct hostated *, const char *);
int	 transaction_commit(struct hostated *);
void	 kill_tables(struct hostated *);
d52 1
a52 1
init_filter(struct hostated *env)
d68 1
a68 1
init_tables(struct hostated *env)
d80 1
a80 1
		(void)strlcpy(tables[i].pfrt_anchor, HOSTATED_ANCHOR "/",
d114 1
a114 1
kill_tables(struct hostated *env) {
d120 1
a120 1
		(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTATED_ANCHOR "/",
d131 1
a131 1
sync_table(struct hostated *env, struct service *service, struct table *table)
d156 1
a156 1
	(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTATED_ANCHOR "/",
d203 1
a203 1
flush_table(struct hostated *env, struct service *service)
d208 1
a208 1
	(void)strlcpy(io.pfrio_table.pfrt_anchor, HOSTATED_ANCHOR "/",
d221 1
a221 1
transaction_init(struct hostated *env, const char *anchor)
d237 1
a237 1
transaction_commit(struct hostated *env)
d245 1
a245 1
sync_ruleset(struct hostated *env, struct service *service, int enable)
d255 1
a255 1
	(void)strlcpy(anchor, HOSTATED_ANCHOR "/", sizeof(anchor));
d326 1
a326 1
flush_rulesets(struct hostated *env)
d333 1
a333 1
		strlcpy(anchor, HOSTATED_ANCHOR "/", sizeof(anchor));
d338 1
a338 1
	strlcpy(anchor, HOSTATED_ANCHOR, sizeof(anchor));
@


1.7
log
@do NOT use the regexp interface. it is way to complicated, error-prone
and we don't know about all the possible security problems.

change the check send/expect code to use the fnmatch(3) interface
using shell globbing rules instead. this allows simple patterns like
"220 * ESMTP*" or "SSH-[12].??-*".

suggested by deraadt@@ and otto@@
ok Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.6 2007/01/08 17:10:23 reyk Exp $	*/
d38 1
a38 1
#include "hostated.h"
@


1.6
log
@allow to use service names in addition to numerical port numbers in
the configuration file, eg. "real port http".

> From Pierre-Yves Ritschard (pyr at spootnik dot org)

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.5 2007/01/08 13:37:26 reyk Exp $	*/
a36 1
#include <regex.h>
@


1.5
log
@add a generic send/expect check using regular expression (see
regex(3)).  this allows to define additional checks for other TCP
protocols.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.4 2007/01/05 16:39:23 reyk Exp $	*/
d313 1
a313 1
		rio.rule.rpool.proxy_port[0] = service->table->port;
@


1.4
log
@Fix two small memleaks

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.3 2007/01/03 09:42:30 reyk Exp $	*/
d37 1
@


1.3
log
@allow the sticky-address option for round-robin pools.

From Pierre-Yves Ritschard (pyr at spootnik dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.2 2006/12/16 12:42:14 reyk Exp $	*/
d101 2
d194 2
@


1.2
log
@knf, spacing

please note that some editors will replace tabs with multiple spaces
if you cut & paste code from other sections.  please try to keep the
tabs ;).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfe_filter.c,v 1.1 2006/12/16 11:45:07 reyk Exp $	*/
d311 2
@


1.1
log
@Import hostated, the host status daemon.  This daemon will monitor
remote hosts and dynamically alter pf(4) tables and redirection rules
for active server load balancing.  The daemon has been written by
Pierre-Yves Ritschard (pyr at spootnik.org) and was formerly known as
"slbd".

The daemon is fully functional but it still needs some work and
cleanup so we don't link it to the build yet.  Some TODOs are a
partial rewrite of the check_* routines (use libevent whenever we
can), improvement of the manpages, and general knf and cleanup.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 1
	
d78 1
a78 1
	
d81 1
a81 1
			      sizeof(tables[i].pfrt_anchor)); 
d83 1
a83 1
			      sizeof(tables[i].pfrt_anchor)); 
d85 1
a85 1
			      sizeof(tables[i].pfrt_name)); 
d119 1
a119 1
			      sizeof(io.pfrio_table.pfrt_anchor));
d121 1
a121 1
			      sizeof(io.pfrio_table.pfrt_anchor));
d155 1
a155 1
		      sizeof(io.pfrio_table.pfrt_anchor));
d157 1
a157 1
		      sizeof(io.pfrio_table.pfrt_anchor));
d159 1
a159 1
		      sizeof(io.pfrio_table.pfrt_name));
d171 1
a171 1
			       sizeof(sain->sin_addr));
d178 1
a178 1
			       sizeof(sain6->sin6_addr));
d194 2
a195 2
		  io.pfrio_table.pfrt_name,
		  io.pfrio_nadd, io.pfrio_ndel, io.pfrio_nchange);
d205 1
a205 1
		      sizeof(io.pfrio_table.pfrt_anchor));
d207 1
a207 1
		      sizeof(io.pfrio_table.pfrt_anchor));
d209 1
a209 1
		      sizeof(io.pfrio_table.pfrt_name));
d219 3
a221 3
        env->pf->pft.size = 1;      
        env->pf->pft.esize = sizeof env->pf->pfte;
        env->pf->pft.array = &env->pf->pfte;
d227 3
a229 3
        if (ioctl(env->pf->dev, DIOCXBEGIN, &env->pf->pft) == -1)
                return (-1);
        return (0);
d281 1
a281 1
				      sizeof(rio.rule.tagname));
d284 1
a284 1
				      sizeof(rio.rule.ifname));
d288 3
a290 3
			
			rio.rule.dst.addr.v.a.addr.addr32[0] = 
				sain->sin_addr.s_addr; 
d295 1
a295 1
			
d297 2
a298 2
			       &sain6->sin6_addr.s6_addr,
			       sizeof(sain6->sin6_addr.s6_addr));
d304 1
a304 1
			      sizeof(pio.addr.addr.v.tblname));
d331 1
a331 1
	}	
@

