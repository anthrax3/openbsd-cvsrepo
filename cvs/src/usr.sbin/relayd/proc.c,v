head	1.38;
access;
symbols
	OPENBSD_6_1:1.38.0.2
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.5.0.4
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.3.0.4
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.38
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.37;
commitid	eA8b246voAapPTkX;

1.37
date	2016.11.24.21.01.18;	author reyk;	state Exp;
branches;
next	1.36;
commitid	FkVuQgzULddApn9S;

1.36
date	2016.10.05.17.31.28;	author rzalamena;	state Exp;
branches;
next	1.35;
commitid	M8VEJrg7exYbjF8Z;

1.35
date	2016.10.05.17.09.59;	author reyk;	state Exp;
branches;
next	1.34;
commitid	4qNEz3rKUopcsuPp;

1.34
date	2016.10.05.16.58.19;	author reyk;	state Exp;
branches;
next	1.33;
commitid	UGOrmt0fCkvkKrPU;

1.33
date	2016.09.28.12.16.44;	author reyk;	state Exp;
branches;
next	1.32;
commitid	9yLAl6KjHBmFKV9B;

1.32
date	2016.09.03.14.44.21;	author reyk;	state Exp;
branches;
next	1.31;
commitid	n0F9VKkYrh9A46uy;

1.31
date	2016.09.03.14.09.04;	author reyk;	state Exp;
branches;
next	1.30;
commitid	0kWOwUNycE381inh;

1.30
date	2016.09.02.12.14.08;	author reyk;	state Exp;
branches;
next	1.29;
commitid	AjKEq2YFQYn13pCu;

1.29
date	2016.09.02.12.12.51;	author reyk;	state Exp;
branches;
next	1.28;
commitid	tCJ77FP0n8bVYrYP;

1.28
date	2016.09.02.11.51.49;	author reyk;	state Exp;
branches;
next	1.27;
commitid	Scmkna4JViHMcK3U;

1.27
date	2015.12.07.16.05.56;	author reyk;	state Exp;
branches;
next	1.26;
commitid	N57bKZPTW9wbXnJY;

1.26
date	2015.12.05.13.13.11;	author claudio;	state Exp;
branches;
next	1.25;
commitid	eFaXCW6lAjqOxsAo;

1.25
date	2015.12.02.13.41.27;	author reyk;	state Exp;
branches;
next	1.24;
commitid	vBNcEM4jmO1KceIa;

1.24
date	2015.11.28.09.52.07;	author reyk;	state Exp;
branches;
next	1.23;
commitid	Xo3TbDi9hUaP9ip0;

1.23
date	2015.11.23.16.41.36;	author reyk;	state Exp;
branches;
next	1.22;
commitid	YDo7pUdfiXvsPesA;

1.22
date	2015.11.22.13.27.13;	author reyk;	state Exp;
branches;
next	1.21;
commitid	T3JBYxNT0thPuavp;

1.21
date	2015.10.01.12.16.21;	author reyk;	state Exp;
branches;
next	1.20;
commitid	YHD2fsYUiSEFRMSY;

1.20
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.19;
commitid	puppem00jmzmdm4f;

1.19
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.18;
commitid	XnjIOhurXdX5o1V9;

1.18
date	2014.12.16.03.35.49;	author millert;	state Exp;
branches;
next	1.17;
commitid	nQ60kcXwyMctmczv;

1.17
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.16;
commitid	2uw1UTO4k6erpWzK;

1.16
date	2014.08.18.12.59.00;	author reyk;	state Exp;
branches;
next	1.15;
commitid	6CBP61dyg2cJV5hP;

1.15
date	2014.07.11.16.39.10;	author krw;	state Exp;
branches;
next	1.14;
commitid	hMaeymaqXgBsu7EB;

1.14
date	2014.05.08.13.08.48;	author blambert;	state Exp;
branches;
next	1.13;

1.13
date	2014.05.06.06.40.03;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2014.05.04.10.32.32;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.20.14.48.29;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.18.21.29.20;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.18.12.02.37;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.14.07.18.05;	author blambert;	state Exp;
branches;
next	1.7;

1.7
date	2014.02.14.10.21.00;	author benno;	state Exp;
branches;
next	1.6;

1.6
date	2013.11.13.20.45.50;	author benno;	state Exp;
branches;
next	1.5;

1.5
date	2013.01.17.20.34.18;	author bluhm;	state Exp;
branches;
next	1.4;

1.4
date	2012.10.04.20.53.30;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2011.09.04.20.26.58;	author bluhm;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.09.12.09.58;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@/*	$OpenBSD: proc.c,v 1.37 2016/11/24 21:01:18 reyk Exp $	*/

/*
 * Copyright (c) 2010 - 2016 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <pwd.h>
#include <event.h>
#include <imsg.h>

#include "relayd.h"

void	 proc_exec(struct privsep *, struct privsep_proc *, unsigned int,
	    int, char **);
void	 proc_setup(struct privsep *, struct privsep_proc *, unsigned int);
void	 proc_open(struct privsep *, int, int);
void	 proc_accept(struct privsep *, int, enum privsep_procid,
	    unsigned int);
void	 proc_close(struct privsep *);
int	 proc_ispeer(struct privsep_proc *, unsigned int, enum privsep_procid);
void	 proc_shutdown(struct privsep_proc *);
void	 proc_sig_handler(int, short, void *);
void	 proc_range(struct privsep *, enum privsep_procid, int *, int *);
int	 proc_dispatch_null(int, struct privsep_proc *, struct imsg *);

int
proc_ispeer(struct privsep_proc *procs, unsigned int nproc,
    enum privsep_procid type)
{
	unsigned int	i;

	for (i = 0; i < nproc; i++)
		if (procs[i].p_id == type)
			return (1);
	return (0);
}

enum privsep_procid
proc_getid(struct privsep_proc *procs, unsigned int nproc,
    const char *proc_name)
{
	struct privsep_proc	*p;
	unsigned int		 proc;

	for (proc = 0; proc < nproc; proc++) {
		p = &procs[proc];
		if (strcmp(p->p_title, proc_name))
			continue;

		return (p->p_id);
	}

	return (PROC_MAX);
}

void
proc_exec(struct privsep *ps, struct privsep_proc *procs, unsigned int nproc,
    int argc, char **argv)
{
	unsigned int		 proc, nargc, i, proc_i;
	char			**nargv;
	struct privsep_proc	*p;
	char			 num[32];
	int			 fd;

	/* Prepare the new process argv. */
	nargv = calloc(argc + 5, sizeof(char *));
	if (nargv == NULL)
		fatal("%s: calloc", __func__);

	/* Copy call argument first. */
	nargc = 0;
	nargv[nargc++] = argv[0];

	/* Set process name argument and save the position. */
	nargv[nargc++] = "-P";
	proc_i = nargc;
	nargc++;

	/* Point process instance arg to stack and copy the original args. */
	nargv[nargc++] = "-I";
	nargv[nargc++] = num;
	for (i = 1; i < (unsigned int) argc; i++)
		nargv[nargc++] = argv[i];

	nargv[nargc] = NULL;

	for (proc = 0; proc < nproc; proc++) {
		p = &procs[proc];

		/* Update args with process title. */
		nargv[proc_i] = (char *)(uintptr_t)p->p_title;

		/* Fire children processes. */
		for (i = 0; i < ps->ps_instances[p->p_id]; i++) {
			/* Update the process instance number. */
			snprintf(num, sizeof(num), "%u", i);

			fd = ps->ps_pipes[p->p_id][i].pp_pipes[PROC_PARENT][0];
			ps->ps_pipes[p->p_id][i].pp_pipes[PROC_PARENT][0] = -1;

			switch (fork()) {
			case -1:
				fatal("%s: fork", __func__);
				break;
			case 0:
				/* First create a new session */
				if (setsid() == -1)
					fatal("setsid");

				/* Prepare parent socket. */
				if (fd != PROC_PARENT_SOCK_FILENO) {
					if (dup2(fd, PROC_PARENT_SOCK_FILENO)
					    == -1)
						fatal("dup2");
				} else if (fcntl(fd, F_SETFD, 0) == -1)
					fatal("fcntl");

				execvp(argv[0], nargv);
				fatal("%s: execvp", __func__);
				break;
			default:
				/* Close child end. */
				close(fd);
				break;
			}
		}
	}
	free(nargv);
}

void
proc_connect(struct privsep *ps)
{
	struct imsgev		*iev;
	unsigned int		 src, dst, inst;

	/* Don't distribute any sockets if we are not really going to run. */
	if (ps->ps_noaction)
		return;

	for (dst = 0; dst < PROC_MAX; dst++) {
		/* We don't communicate with ourselves. */
		if (dst == PROC_PARENT)
			continue;

		for (inst = 0; inst < ps->ps_instances[dst]; inst++) {
			iev = &ps->ps_ievs[dst][inst];
			imsg_init(&iev->ibuf, ps->ps_pp->pp_pipes[dst][inst]);
			event_set(&iev->ev, iev->ibuf.fd, iev->events,
			    iev->handler, iev->data);
			event_add(&iev->ev, NULL);
		}
	}

	/* Distribute the socketpair()s for everyone. */
	for (src = 0; src < PROC_MAX; src++)
		for (dst = src; dst < PROC_MAX; dst++) {
			/* Parent already distributed its fds. */
			if (src == PROC_PARENT || dst == PROC_PARENT)
				continue;

			proc_open(ps, src, dst);
		}
}

void
proc_init(struct privsep *ps, struct privsep_proc *procs, unsigned int nproc,
    int argc, char **argv, enum privsep_procid proc_id)
{
	struct privsep_proc	*p = NULL;
	struct privsep_pipes	*pa, *pb;
	unsigned int		 proc;
	unsigned int		 dst;
	int			 fds[2];

	/* Don't initiate anything if we are not really going to run. */
	if (ps->ps_noaction)
		return;

	if (proc_id == PROC_PARENT) {
		privsep_process = PROC_PARENT;
		proc_setup(ps, procs, nproc);

		/*
		 * Create the children sockets so we can use them 
		 * to distribute the rest of the socketpair()s using
		 * proc_connect() later.
		 */
		for (dst = 0; dst < PROC_MAX; dst++) {
			/* Don't create socket for ourselves. */
			if (dst == PROC_PARENT)
				continue;

			for (proc = 0; proc < ps->ps_instances[dst]; proc++) {
				pa = &ps->ps_pipes[PROC_PARENT][0];
				pb = &ps->ps_pipes[dst][proc];
				if (socketpair(AF_UNIX,
				    SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
				    PF_UNSPEC, fds) == -1)
					fatal("%s: socketpair", __func__);

				pa->pp_pipes[dst][proc] = fds[0];
				pb->pp_pipes[PROC_PARENT][0] = fds[1];
			}
		}

		/* Engage! */
		proc_exec(ps, procs, nproc, argc, argv);
		return;
	}

	/* Initialize a child */
	for (proc = 0; proc < nproc; proc++) {
		if (procs[proc].p_id != proc_id)
			continue;
		p = &procs[proc];
		break;
	}
	if (p == NULL || p->p_init == NULL)
		fatalx("%s: process %d missing process initialization",
		    __func__, proc_id);

	p->p_init(ps, p);

	fatalx("failed to initiate child process");
}

void
proc_accept(struct privsep *ps, int fd, enum privsep_procid dst,
    unsigned int n)
{
	struct privsep_pipes	*pp = ps->ps_pp;
	struct imsgev		*iev;

	if (ps->ps_ievs[dst] == NULL) {
#if DEBUG > 1
		log_debug("%s: %s src %d %d to dst %d %d not connected",
		    __func__, ps->ps_title[privsep_process],
		    privsep_process, ps->ps_instance + 1,
		    dst, n + 1);
#endif
		close(fd);
		return;
	}

	if (pp->pp_pipes[dst][n] != -1) {
		log_warnx("%s: duplicated descriptor", __func__);
		close(fd);
		return;
	} else
		pp->pp_pipes[dst][n] = fd;

	iev = &ps->ps_ievs[dst][n];
	imsg_init(&iev->ibuf, fd);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev->data);
	event_add(&iev->ev, NULL);
}

void
proc_setup(struct privsep *ps, struct privsep_proc *procs, unsigned int nproc)
{
	unsigned int		 i, j, src, dst, id;
	struct privsep_pipes	*pp;

	/* Initialize parent title, ps_instances and procs. */
	ps->ps_title[PROC_PARENT] = "parent";

	for (src = 0; src < PROC_MAX; src++)
		/* Default to 1 process instance */
		if (ps->ps_instances[src] < 1)
			ps->ps_instances[src] = 1;

	for (src = 0; src < nproc; src++) {
		procs[src].p_ps = ps;
		if (procs[src].p_cb == NULL)
			procs[src].p_cb = proc_dispatch_null;

		id = procs[src].p_id;
		ps->ps_title[id] = procs[src].p_title;
		if ((ps->ps_ievs[id] = calloc(ps->ps_instances[id],
		    sizeof(struct imsgev))) == NULL)
			fatal("%s: calloc", __func__);

		/* With this set up, we are ready to call imsg_init(). */
		for (i = 0; i < ps->ps_instances[id]; i++) {
			ps->ps_ievs[id][i].handler = proc_dispatch;
			ps->ps_ievs[id][i].events = EV_READ;
			ps->ps_ievs[id][i].proc = &procs[src];
			ps->ps_ievs[id][i].data = &ps->ps_ievs[id][i];
		}
	}

	/*
	 * Allocate pipes for all process instances (incl. parent)
	 *
	 * - ps->ps_pipes: N:M mapping
	 * N source processes connected to M destination processes:
	 * [src][instances][dst][instances], for example
	 * [PROC_RELAY][3][PROC_CA][3]
	 *
	 * - ps->ps_pp: per-process 1:M part of ps->ps_pipes
	 * Each process instance has a destination array of socketpair fds:
	 * [dst][instances], for example
	 * [PROC_PARENT][0]
	 */
	for (src = 0; src < PROC_MAX; src++) {
		/* Allocate destination array for each process */
		if ((ps->ps_pipes[src] = calloc(ps->ps_instances[src],
		    sizeof(struct privsep_pipes))) == NULL)
			fatal("%s: calloc", __func__);

		for (i = 0; i < ps->ps_instances[src]; i++) {
			pp = &ps->ps_pipes[src][i];

			for (dst = 0; dst < PROC_MAX; dst++) {
				/* Allocate maximum fd integers */
				if ((pp->pp_pipes[dst] =
				    calloc(ps->ps_instances[dst],
				    sizeof(int))) == NULL)
					fatal("%s: calloc", __func__);

				/* Mark fd as unused */
				for (j = 0; j < ps->ps_instances[dst]; j++)
					pp->pp_pipes[dst][j] = -1;
			}
		}
	}

	ps->ps_pp = &ps->ps_pipes[privsep_process][ps->ps_instance];
}

void
proc_kill(struct privsep *ps)
{
	char		*cause;
	pid_t		 pid;
	int		 len, status;

	if (privsep_process != PROC_PARENT)
		return;

	proc_close(ps);

	do {
		pid = waitpid(WAIT_ANY, &status, 0);
		if (pid <= 0)
			continue;

		if (WIFSIGNALED(status)) {
			len = asprintf(&cause, "terminated; signal %d",
			    WTERMSIG(status));
		} else if (WIFEXITED(status)) {
			if (WEXITSTATUS(status) != 0)
				len = asprintf(&cause, "exited abnormally");
			else
				len = 0;
		} else
			len = -1;

		if (len == 0) {
			/* child exited OK, don't print a warning message */
		} else if (len != -1) {
			log_warnx("lost child: pid %u %s", pid, cause);
			free(cause);
		} else
			log_warnx("lost child: pid %u", pid);
	} while (pid != -1 || (pid == -1 && errno == EINTR));
}

void
proc_open(struct privsep *ps, int src, int dst)
{
	struct privsep_pipes	*pa, *pb;
	struct privsep_fd	 pf;
	int			 fds[2];
	unsigned int		 i, j;

	/* Exchange pipes between process. */
	for (i = 0; i < ps->ps_instances[src]; i++) {
		for (j = 0; j < ps->ps_instances[dst]; j++) {
			/* Don't create sockets for ourself. */
			if (src == dst && i == j)
				continue;

			pa = &ps->ps_pipes[src][i];
			pb = &ps->ps_pipes[dst][j];
			if (socketpair(AF_UNIX,
			    SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
			    PF_UNSPEC, fds) == -1)
				fatal("%s: socketpair", __func__);

			pa->pp_pipes[dst][j] = fds[0];
			pb->pp_pipes[src][i] = fds[1];

			pf.pf_procid = src;
			pf.pf_instance = i;
			if (proc_compose_imsg(ps, dst, j, IMSG_CTL_PROCFD,
			    -1, pb->pp_pipes[src][i], &pf, sizeof(pf)) == -1)
				fatal("%s: proc_compose_imsg", __func__);

			pf.pf_procid = dst;
			pf.pf_instance = j;
			if (proc_compose_imsg(ps, src, i, IMSG_CTL_PROCFD,
			    -1, pa->pp_pipes[dst][j], &pf, sizeof(pf)) == -1)
				fatal("%s: proc_compose_imsg", __func__);

			/*
			 * We have to flush to send the descriptors and close
			 * them to avoid the fd ramp on startup.
			 */
			if (proc_flush_imsg(ps, src, i) == -1 ||
			    proc_flush_imsg(ps, dst, j) == -1)
				fatal("%s: imsg_flush", __func__);
		}
	}
}

void
proc_close(struct privsep *ps)
{
	unsigned int		 dst, n;
	struct privsep_pipes	*pp;

	if (ps == NULL)
		return;

	pp = ps->ps_pp;

	for (dst = 0; dst < PROC_MAX; dst++) {
		if (ps->ps_ievs[dst] == NULL)
			continue;

		for (n = 0; n < ps->ps_instances[dst]; n++) {
			if (pp->pp_pipes[dst][n] == -1)
				continue;

			/* Cancel the fd, close and invalidate the fd */
			event_del(&(ps->ps_ievs[dst][n].ev));
			imsg_clear(&(ps->ps_ievs[dst][n].ibuf));
			close(pp->pp_pipes[dst][n]);
			pp->pp_pipes[dst][n] = -1;
		}
		free(ps->ps_ievs[dst]);
	}
}

void
proc_shutdown(struct privsep_proc *p)
{
	struct privsep	*ps = p->p_ps;

	if (p->p_id == PROC_CONTROL && ps)
		control_cleanup(&ps->ps_csock);

	if (p->p_shutdown != NULL)
		(*p->p_shutdown)();

	proc_close(ps);

	log_info("%s exiting, pid %d", p->p_title, getpid());

	exit(0);
}

void
proc_sig_handler(int sig, short event, void *arg)
{
	struct privsep_proc	*p = arg;

	switch (sig) {
	case SIGINT:
	case SIGTERM:
		proc_shutdown(p);
		break;
	case SIGCHLD:
	case SIGHUP:
	case SIGPIPE:
	case SIGUSR1:
		/* ignore */
		break;
	default:
		fatalx("proc_sig_handler: unexpected signal");
		/* NOTREACHED */
	}
}

void
proc_run(struct privsep *ps, struct privsep_proc *p,
    struct privsep_proc *procs, unsigned int nproc,
    void (*run)(struct privsep *, struct privsep_proc *, void *), void *arg)
{
	struct passwd		*pw;
	const char		*root;
	struct control_sock	*rcs;

	log_procinit(p->p_title);

	/* Set the process group of the current process */
	setpgid(0, 0);

	if (p->p_id == PROC_CONTROL && ps->ps_instance == 0) {
		if (control_init(ps, &ps->ps_csock) == -1)
			fatalx("%s: control_init", __func__);
		TAILQ_FOREACH(rcs, &ps->ps_rcsocks, cs_entry)
			if (control_init(ps, rcs) == -1)
				fatalx("%s: control_init", __func__);
	}

	/* Use non-standard user */
	if (p->p_pw != NULL)
		pw = p->p_pw;
	else
		pw = ps->ps_pw;

	/* Change root directory */
	if (p->p_chroot != NULL)
		root = p->p_chroot;
	else
		root = pw->pw_dir;

	if (chroot(root) == -1)
		fatal("proc_run: chroot");
	if (chdir("/") == -1)
		fatal("proc_run: chdir(\"/\")");

	privsep_process = p->p_id;

	setproctitle("%s", p->p_title);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("proc_run: cannot drop privileges");

	event_init();

	signal_set(&ps->ps_evsigint, SIGINT, proc_sig_handler, p);
	signal_set(&ps->ps_evsigterm, SIGTERM, proc_sig_handler, p);
	signal_set(&ps->ps_evsigchld, SIGCHLD, proc_sig_handler, p);
	signal_set(&ps->ps_evsighup, SIGHUP, proc_sig_handler, p);
	signal_set(&ps->ps_evsigpipe, SIGPIPE, proc_sig_handler, p);
	signal_set(&ps->ps_evsigusr1, SIGUSR1, proc_sig_handler, p);

	signal_add(&ps->ps_evsigint, NULL);
	signal_add(&ps->ps_evsigterm, NULL);
	signal_add(&ps->ps_evsigchld, NULL);
	signal_add(&ps->ps_evsighup, NULL);
	signal_add(&ps->ps_evsigpipe, NULL);
	signal_add(&ps->ps_evsigusr1, NULL);

	proc_setup(ps, procs, nproc);
	proc_accept(ps, PROC_PARENT_SOCK_FILENO, PROC_PARENT, 0);
	if (p->p_id == PROC_CONTROL && ps->ps_instance == 0) {
		TAILQ_INIT(&ctl_conns);
		if (control_listen(&ps->ps_csock) == -1)
			fatalx("%s: control_listen", __func__);
		TAILQ_FOREACH(rcs, &ps->ps_rcsocks, cs_entry)
			if (control_listen(rcs) == -1)
				fatalx("%s: control_listen", __func__);
	}

	DPRINTF("%s: %s %d/%d, pid %d", __func__, p->p_title,
	    ps->ps_instance + 1, ps->ps_instances[p->p_id], getpid());

	if (run != NULL)
		run(ps, p, arg);

	event_dispatch();

	proc_shutdown(p);
}

void
proc_dispatch(int fd, short event, void *arg)
{
	struct imsgev		*iev = arg;
	struct privsep_proc	*p = iev->proc;
	struct privsep		*ps = p->p_ps;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
	int			 verbose;
	const char		*title;
	struct privsep_fd	 pf;

	title = ps->ps_title[privsep_process];
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("%s: imsg_read", __func__);
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("%s: msgbuf_write", __func__);
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("%s: imsg_get", __func__);
		if (n == 0)
			break;

#if DEBUG > 1
		log_debug("%s: %s %d got imsg %d peerid %d from %s %d",
		    __func__, title, ps->ps_instance + 1,
		    imsg.hdr.type, imsg.hdr.peerid, p->p_title, imsg.hdr.pid);
#endif

		/*
		 * Check the message with the program callback
		 */
		if ((p->p_cb)(fd, p, &imsg) == 0) {
			/* Message was handled by the callback, continue */
			imsg_free(&imsg);
			continue;
		}

		/*
		 * Generic message handling
		 */
		switch (imsg.hdr.type) {
		case IMSG_CTL_VERBOSE:
			IMSG_SIZE_CHECK(&imsg, &verbose);
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		case IMSG_CTL_PROCFD:
			IMSG_SIZE_CHECK(&imsg, &pf);
			memcpy(&pf, imsg.data, sizeof(pf));
			proc_accept(ps, imsg.fd, pf.pf_procid,
			    pf.pf_instance);
			break;
		default:
			fatalx("%s: %s %d got invalid imsg %d peerid %d "
			    "from %s %d",
			    __func__, title, ps->ps_instance + 1,
			    imsg.hdr.type, imsg.hdr.peerid,
			    p->p_title, imsg.hdr.pid);
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
}

int
proc_dispatch_null(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	return (-1);
}

/*
 * imsg helper functions
 */

void
imsg_event_add(struct imsgev *iev)
{
	if (iev->handler == NULL) {
		imsg_flush(&iev->ibuf);
		return;
	}

	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev->data);
	event_add(&iev->ev, NULL);
}

int
imsg_compose_event(struct imsgev *iev, uint16_t type, uint32_t peerid,
    pid_t pid, int fd, void *data, uint16_t datalen)
{
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) == -1)
		return (ret);
	imsg_event_add(iev);
	return (ret);
}

int
imsg_composev_event(struct imsgev *iev, uint16_t type, uint32_t peerid,
    pid_t pid, int fd, const struct iovec *iov, int iovcnt)
{
	int	ret;

	if ((ret = imsg_composev(&iev->ibuf, type, peerid,
	    pid, fd, iov, iovcnt)) == -1)
		return (ret);
	imsg_event_add(iev);
	return (ret);
}

void
proc_range(struct privsep *ps, enum privsep_procid id, int *n, int *m)
{
	if (*n == -1) {
		/* Use a range of all target instances */
		*n = 0;
		*m = ps->ps_instances[id];
	} else {
		/* Use only a single slot of the specified peer process */
		*m = *n + 1;
	}
}

int
proc_compose_imsg(struct privsep *ps, enum privsep_procid id, int n,
    uint16_t type, uint32_t peerid, int fd, void *data, uint16_t datalen)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	for (; n < m; n++) {
		if (imsg_compose_event(&ps->ps_ievs[id][n],
		    type, peerid, ps->ps_instance + 1, fd, data, datalen) == -1)
			return (-1);
	}

	return (0);
}

int
proc_compose(struct privsep *ps, enum privsep_procid id,
    uint16_t type, void *data, uint16_t datalen)
{
	return (proc_compose_imsg(ps, id, -1, type, -1, -1, data, datalen));
}

int
proc_composev_imsg(struct privsep *ps, enum privsep_procid id, int n,
    uint16_t type, uint32_t peerid, int fd, const struct iovec *iov, int iovcnt)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	for (; n < m; n++)
		if (imsg_composev_event(&ps->ps_ievs[id][n],
		    type, peerid, ps->ps_instance + 1, fd, iov, iovcnt) == -1)
			return (-1);

	return (0);
}

int
proc_composev(struct privsep *ps, enum privsep_procid id,
    uint16_t type, const struct iovec *iov, int iovcnt)
{
	return (proc_composev_imsg(ps, id, -1, type, -1, -1, iov, iovcnt));
}

int
proc_forward_imsg(struct privsep *ps, struct imsg *imsg,
    enum privsep_procid id, int n)
{
	return (proc_compose_imsg(ps, id, n, imsg->hdr.type,
	    imsg->hdr.peerid, imsg->fd, imsg->data, IMSG_DATA_SIZE(imsg)));
}

struct imsgbuf *
proc_ibuf(struct privsep *ps, enum privsep_procid id, int n)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	return (&ps->ps_ievs[id][n].ibuf);
}

struct imsgev *
proc_iev(struct privsep *ps, enum privsep_procid id, int n)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	return (&ps->ps_ievs[id][n]);
}

/* This function should only be called with care as it breaks async I/O */
int
proc_flush_imsg(struct privsep *ps, enum privsep_procid id, int n)
{
	struct imsgbuf	*ibuf;
	int		 m, ret = 0;

	proc_range(ps, id, &n, &m);
	for (; n < m; n++) {
		if ((ibuf = proc_ibuf(ps, id, n)) == NULL)
			return (-1);
		do {
			ret = imsg_flush(ibuf);
		} while (ret == -1 && errno == EAGAIN);
		if (ret == -1)
			break;
		imsg_event_add(&ps->ps_ievs[id][n]);
	}

	return (ret);
}
@


1.37
log
@The new fork+exec mode used too many fds in the parent process on
startup, for a short time, so we needed a rlimit hack in relayd.c.
Sync the fix from httpd: rzalamena@@ has fixed proc.c and I added the
proc_flush_imsg() mechanism that makes sure that each fd is
immediately closed after forwarding it to a child process instead of
queueing it up.

OK rzalamena@@ jca@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.34 2016/10/12 10:57:30 reyk Exp $	*/
d665 1
a665 1
			log_verbose(verbose);
@


1.36
log
@Sync with httpd(8) proc file. Check for dup2() usage to avoid oldd == newd
and remove the CLOEXEC with fcntl() if necessary.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.35 2016/10/05 17:09:59 reyk Exp $	*/
a39 2
void	 proc_connectpeer(struct privsep *, enum privsep_procid, int,
	    struct privsep_pipes *);
a157 30
proc_connectpeer(struct privsep *ps, enum privsep_procid id, int inst,
    struct privsep_pipes *pp)
{
	unsigned int		 i, j;
	struct privsep_fd	 pf;

	for (i = 0; i < PROC_MAX; i++) {
		/* Parent is already connected with everyone. */
		if (i == PROC_PARENT)
			continue;

		for (j = 0; j < ps->ps_instances[i]; j++) {
			/* Don't send socket to child itself. */
			if (i == (unsigned int)id &&
			    j == (unsigned int)inst)
				continue;
			if (pp->pp_pipes[i][j] == -1)
				continue;

			pf.pf_procid = i;
			pf.pf_instance = j;
			proc_compose_imsg(ps, id, inst, IMSG_CTL_PROCFD,
			    -1, pp->pp_pipes[i][j], &pf, sizeof(pf));
			pp->pp_pipes[i][j] = -1;
		}
	}
}

/* Inter-connect all process except with ourself. */
void
a159 2
	unsigned int		 src, i, j;
	struct privsep_pipes	*pp;
d161 5
d167 3
a169 7
	/* Listen on appropriate pipes. */
	src = privsep_process;
	pp = &ps->ps_pipes[src][ps->ps_instance];

	for (i = 0; i < PROC_MAX; i++) {
		/* Don't listen to ourself. */
		if (i == src)
d172 3
a174 6
		for (j = 0; j < ps->ps_instances[i]; j++) {
			if (pp->pp_pipes[i][j] == -1)
				continue;

			iev = &ps->ps_ievs[i][j];
			imsg_init(&iev->ibuf, pp->pp_pipes[i][j]);
d181 6
a186 5
	/* Exchange pipes between process. */
	for (i = 0; i < PROC_MAX; i++) {
		/* Parent is already connected with everyone. */
		if (i == PROC_PARENT)
			continue;
d188 2
a189 3
		for (j = 0; j < ps->ps_instances[i]; j++)
			proc_connectpeer(ps, i, j, &ps->ps_pipes[i][j]);
	}
d197 1
d199 6
a204 1
	unsigned int		 src, dst;
d210 22
a231 4
		/* Open socketpair()s for everyone. */
		for (src = 0; src < PROC_MAX; src++)
			for (dst = 0; dst < PROC_MAX; dst++)
				proc_open(ps, src, dst);
d308 1
a308 1
			fatal(__func__);
d400 1
d404 1
a412 3
			if (pb->pp_pipes[dst][j] != -1)
				continue;

d416 1
a416 1
				fatal(__func__);
d420 20
a521 3
	if (ps->ps_noaction)
		exit(0);

d529 1
a529 1
			fatalx(__func__);
d532 1
a532 1
				fatalx(__func__);
d582 1
a582 1
			fatalx(__func__);
d585 1
a585 1
				fatalx(__func__);
d617 1
a617 1
			fatal(__func__);
d627 8
a634 2
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			fatal(__func__);
d639 1
a639 1
			fatal(__func__);
d674 1
a674 1
			log_warnx("%s: %s %d got invalid imsg %d peerid %d "
a678 1
			fatalx(__func__);
d820 22
@


1.35
log
@Call setsid() to create a new session for the executed processes.

From deraadt@@
OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.34 2016/10/05 16:58:19 reyk Exp $	*/
d25 1
d139 6
a144 1
				dup2(fd, PROC_PARENT_SOCK_FILENO);
@


1.34
log
@sync proc.c with vmd: add p_pw to specify a non-standard user for a process.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.7 2016/10/04 17:17:30 reyk Exp $	*/
d133 4
@


1.33
log
@sync proc.c incl. the p_env removal
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.27 2016/09/28 12:01:04 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 - 2014 Reyk Floeter <reyk@@openbsd.org>
d501 1
a501 1
	struct passwd		*pw = ps->ps_pw;
d520 6
@


1.32
log
@Replace [RELAY|SERVER]_MAXPROC with the new PROC_MAX_INSTANCES
variable and limit it from 128 to 32 instances (the old value).
While here, move a few PROC_ defines around.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.31 2016/09/03 14:09:04 reyk Exp $	*/
d118 1
a118 1
		nargv[proc_i] = (char *) p->p_title;
a302 1
		procs[src].p_env = ps->ps_env;
@


1.31
log
@Use the fork+exec privsep model in relayd; based on rzalamena@@'s work
for httpd with some (current and previous) changes for relayd.  Once
again, both daemons now share the same proc.c where most of the
privsep "magic" happens.

OK benno@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.25 2016/09/03 10:02:11 reyk Exp $	*/
d134 1
a134 1
				dup2(fd, PARENT_SOCK_FILENO);
d559 1
a559 1
	proc_accept(ps, PARENT_SOCK_FILENO, PROC_PARENT, 0);
@


1.30
log
@style nit as done in httpd
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.29 2016/09/02 12:12:51 reyk Exp $	*/
d37 8
a44 2
void	 proc_open(struct privsep *, struct privsep_proc *,
	    struct privsep_proc *, size_t);
d64 223
d288 1
a288 1
proc_init(struct privsep *ps, struct privsep_proc *procs, unsigned int nproc)
d290 1
a290 1
	unsigned int		 i, j, src, dst;
d293 3
d301 21
d339 1
a339 1
			fatal("proc_init: calloc");
d349 1
a349 1
					fatal("proc_init: calloc");
d358 1
a358 16
	/*
	 * Setup and run the parent and its children
	 */
	privsep_process = PROC_PARENT;
	ps->ps_instances[PROC_PARENT] = 1;
	ps->ps_title[PROC_PARENT] = "parent";
	ps->ps_pp = &ps->ps_pipes[privsep_process][0];

	for (i = 0; i < nproc; i++)
		ps->ps_title[procs[i].p_id] = procs[i].p_title;

	proc_open(ps, NULL, procs, nproc);

	/* Engage! */
	for (i = 0; i < nproc; i++)
		(*procs[i].p_init)(ps, &procs[i]);
d400 1
a400 2
proc_open(struct privsep *ps, struct privsep_proc *p,
    struct privsep_proc *procs, size_t nproc)
d404 1
a404 1
	unsigned int		 i, j, src, proc;
d406 5
a410 35
	if (p == NULL)
		src = privsep_process; /* parent */
	else
		src = p->p_id;

	/*
	 * Open socket pairs for our peers
	 */
	for (proc = 0; proc < nproc; proc++) {
		procs[proc].p_ps = ps;
		procs[proc].p_env = ps->ps_env;
		if (procs[proc].p_cb == NULL)
			procs[proc].p_cb = proc_dispatch_null;

		for (i = 0; i < ps->ps_instances[src]; i++) {
			for (j = 0; j < ps->ps_instances[procs[proc].p_id];
			    j++) {
				pa = &ps->ps_pipes[src][i];
				pb = &ps->ps_pipes[procs[proc].p_id][j];

				/* Check if fds are already set by peer */
				if (pa->pp_pipes[procs[proc].p_id][j] != -1)
					continue;

				if (socketpair(AF_UNIX,
				    SOCK_STREAM | SOCK_NONBLOCK,
				    PF_UNSPEC, fds) == -1)
					fatal("socketpair");

				pa->pp_pipes[procs[proc].p_id][j] = fds[0];
				pb->pp_pipes[src][i] = fds[1];
			}
		}
	}
}
d412 3
a414 14
void
proc_listen(struct privsep *ps, struct privsep_proc *procs, size_t nproc)
{
	unsigned int		 i, dst, src, n, m;
	struct privsep_pipes	*pp;

	/*
	 * Close unused pipes
	 */
	for (src = 0; src < PROC_MAX; src++) {
		for (n = 0; n < ps->ps_instances[src]; n++) {
			/* Ingore current process */
			if (src == (unsigned int)privsep_process &&
			    n == ps->ps_instance)
d417 4
a420 36
			pp = &ps->ps_pipes[src][n];

			for (dst = 0; dst < PROC_MAX; dst++) {
				if (src == dst)
					continue;
				for (m = 0; m < ps->ps_instances[dst]; m++) {
					if (pp->pp_pipes[dst][m] == -1)
						continue;

					/* Close and invalidate fd */
					close(pp->pp_pipes[dst][m]);
					pp->pp_pipes[dst][m] = -1;
				}
			}
		}
	}

	src = privsep_process;
	ps->ps_pp = pp = &ps->ps_pipes[src][ps->ps_instance];

	/*
	 * Listen on appropriate pipes
	 */
	for (i = 0; i < nproc; i++) {
		dst = procs[i].p_id;

		if (src == dst)
			fatal("proc_listen: cannot peer with oneself");

		if ((ps->ps_ievs[dst] = calloc(ps->ps_instances[dst],
		    sizeof(struct imsgev))) == NULL)
			fatal("proc_open");

		for (n = 0; n < ps->ps_instances[dst]; n++) {
			if (pp->pp_pipes[dst][n] == -1)
				continue;
d422 2
a423 13
			imsg_init(&(ps->ps_ievs[dst][n].ibuf),
			    pp->pp_pipes[dst][n]);
			ps->ps_ievs[dst][n].handler = proc_dispatch;
			ps->ps_ievs[dst][n].events = EV_READ;
			ps->ps_ievs[dst][n].proc = &procs[i];
			ps->ps_ievs[dst][n].data = &ps->ps_ievs[dst][n];

			event_set(&(ps->ps_ievs[dst][n].ev),
			    ps->ps_ievs[dst][n].ibuf.fd,
			    ps->ps_ievs[dst][n].events,
			    ps->ps_ievs[dst][n].handler,
			    ps->ps_ievs[dst][n].data);
			event_add(&(ps->ps_ievs[dst][n].ev), NULL);
d472 1
a472 1
	_exit(0);
d502 1
a502 2
	pid_t			 pid;
	struct passwd		*pw;
a504 1
	unsigned int		 n;
d507 1
a507 1
		return;
d509 1
a509 1
	proc_open(ps, p, procs, nproc);
d511 2
a512 15
	/* Fork child handlers */
	switch (pid = fork()) {
	case -1:
		fatal("proc_run: cannot fork");
	case 0:
		log_procinit(p->p_title);

		/* Set the process group of the current process */
		setpgid(0, 0);
		break;
	default:
		return;
	}

	pw = ps->ps_pw;
a541 13
	/* Fork child handlers */
	for (n = 1; n < ps->ps_instances[p->p_id]; n++) {
		if (fork() == 0) {
			ps->ps_instance = n;
			break;
		}
	}

#ifdef DEBUG
	log_debug("%s: %s %d/%d, pid %d", __func__, p->p_title,
	    ps->ps_instance + 1, ps->ps_instances[p->p_id], getpid());
#endif

d558 2
a559 2
	proc_listen(ps, procs, nproc);

d569 3
d591 1
d641 6
@


1.29
log
@As done in httpd, remove ps_ninstances and p_instance.

OK benno@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.28 2016/09/02 11:51:49 reyk Exp $	*/
d64 1
a64 1
	for (src = 0; src < PROC_MAX; src++) {
a67 1
	}
@


1.28
log
@Terminate relayd using the socket status instead of watching SIGCHLD
or killing child processes. - Based on rzalamena@@'s diff for httpd.

OK deraadt@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.27 2015/12/07 16:05:56 reyk Exp $	*/
d64 6
d85 1
a85 1
		if ((ps->ps_pipes[src] = calloc(ps->ps_ninstances,
d89 1
a89 1
		for (i = 0; i < ps->ps_ninstances; i++) {
d95 1
a95 1
				    calloc(ps->ps_ninstances,
d100 1
a100 1
				for (j = 0; j < ps->ps_ninstances; j++)
d114 1
a114 4
	for (i = 0; i < nproc; i++) {
		/* Default to 1 process instance */
		if (ps->ps_instances[procs[i].p_id] < 1)
			ps->ps_instances[procs[i].p_id] = 1;
a115 1
	}
a264 1
			procs[i].p_instance = n;
d408 1
a408 1
			ps->ps_instance = p->p_instance = n;
d493 1
a493 1
		    imsg.hdr.type, imsg.hdr.peerid, p->p_title, p->p_instance);
d519 1
a519 1
			    p->p_title, p->p_instance);
d602 1
a602 1
		    type, peerid, 0, fd, data, datalen) == -1)
d625 1
a625 1
		    type, peerid, 0, fd, iov, iovcnt) == -1)
@


1.27
log
@Add imsg "peerid" to debug messages (only within -DDEBUG).
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.4 2015/12/05 17:30:34 claudio Exp $	*/
a105 1
	ps->ps_pid[PROC_PARENT] = getpid();
d119 1
a119 1
		ps->ps_pid[procs[i].p_id] = (*procs[i].p_init)(ps, &procs[i]);
d125 1
d127 1
a127 1
	unsigned int	 i;
d132 5
a136 2
	for (i = 0; i < PROC_MAX; i++) {
		if (ps->ps_pid[i] == 0)
a137 2
		killpg(ps->ps_pid[i], SIGTERM);
	}
d139 18
a156 2
	do {
		pid = waitpid(WAIT_ANY, NULL, 0);
a157 2

	proc_close(ps);
d344 1
a344 1
pid_t
d356 1
a356 1
		return (0);
d371 1
a371 1
		return (pid);
a449 2

	return (0);
@


1.26
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.25 2015/12/02 13:41:27 reyk Exp $	*/
d477 1
a477 1
		log_debug("%s: %s %d got imsg %d from %s %d",
d479 1
a479 1
		    imsg.hdr.type, p->p_title, p->p_instance);
d501 2
a502 1
			log_warnx("%s: %s %d got invalid imsg %d from %s %d",
d504 2
a505 1
			    imsg.hdr.type, p->p_title, p->p_instance);
@


1.25
log
@In most cases we don't need all arguments of proc_compose*_imsg(),
so add a shortcut proc_compose*() that skips all of them.  Only use the
full argument list if needed.  The functions with full argument lists can
eventually be replaced with a nicer transaction-based approach later.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.2 2015/12/02 09:39:41 reyk Exp $	*/
d455 1
a455 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.24
log
@Use SOCK_NONBLOCK in relayd as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.23 2015/11/23 16:41:36 reyk Exp $	*/
d579 1
a579 1
    uint16_t type, int fd, void *data, uint16_t datalen)
d586 1
a586 1
		    type, -1, 0, fd, data, datalen) == -1)
d594 7
d602 1
a602 1
    uint16_t type, int fd, const struct iovec *iov, int iovcnt)
d609 1
a609 1
		    type, -1, 0, fd, iov, iovcnt) == -1)
d616 7
d627 1
a627 1
	    imsg->fd, imsg->data, IMSG_DATA_SIZE(imsg)));
@


1.23
log
@Sync proc.c with iked: the default proc_dispatch_null allows to remove
some empty imsg callback stubs in the privsep processes.

iked's proc.c -r1.24 was OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.22 2015/11/22 13:27:13 reyk Exp $	*/
d177 2
a178 1
				if (socketpair(AF_UNIX, SOCK_STREAM,
a180 3

				socket_set_blockmode(fds[0], BM_NONBLOCK);
				socket_set_blockmode(fds[1], BM_NONBLOCK);
@


1.22
log
@Update log.c: change fatal() and fatalx() into variadic functions,
include the process name, and replace all calls of fatal*(NULL) with
fatal(__func__) for better debugging.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.21 2015/10/01 12:16:21 reyk Exp $	*/
d44 1
d164 2
d334 1
a334 1
    void (*init)(struct privsep *, struct privsep_proc *, void *), void *arg)
d431 2
a432 2
	if (init != NULL)
		init(ps, p, arg);
d511 6
@


1.21
log
@sync proc.c with httpd.  no functional change, only switching to C99 types.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.20 2015/01/22 17:42:09 reyk Exp $	*/
d349 2
d362 1
a362 1
			fatalx(p->p_title);
d365 1
a365 1
				fatalx(p->p_title);
d422 1
a422 1
			fatalx(p->p_title);
d425 1
a425 1
				fatalx(p->p_title);
d455 1
a455 1
			fatal(title);
d466 1
a466 1
			fatal(title);
d471 1
a471 1
			fatal(title);
d503 1
a503 1
			fatalx(title);
@


1.20
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.19 2014/12/21 00:54:49 guenther Exp $	*/
d40 1
a40 1
int	 proc_ispeer(struct privsep_proc *, u_int, enum privsep_procid);
d46 2
a47 1
proc_ispeer(struct privsep_proc *procs, u_int nproc, enum privsep_procid type)
d49 1
a49 1
	u_int	i;
d58 1
a58 1
proc_init(struct privsep *ps, struct privsep_proc *procs, u_int nproc)
d60 1
a60 1
	u_int			 i, j, src, dst;
d126 1
a126 1
	u_int		 i;
d150 1
a150 1
	u_int			 i, j, src, proc;
d191 1
a191 1
	u_int			 i, dst, src, n, m;
d200 1
a200 1
			if (src == (u_int)privsep_process &&
d262 1
a262 1
	u_int			 dst, n;
d330 1
a330 1
    struct privsep_proc *procs, u_int nproc,
d337 1
a337 1
	u_int			 n;
d530 2
a531 2
imsg_compose_event(struct imsgev *iev, u_int16_t type, u_int32_t peerid,
    pid_t pid, int fd, void *data, u_int16_t datalen)
d543 1
a543 1
imsg_composev_event(struct imsgev *iev, u_int16_t type, u_int32_t peerid,
d570 1
a570 1
    u_int16_t type, int fd, void *data, u_int16_t datalen)
d586 1
a586 1
    u_int16_t type, int fd, const struct iovec *iov, int iovcnt)
@


1.19
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.18 2014/12/16 03:35:49 millert Exp $	*/
a23 5
#include <sys/tree.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>
d33 1
a33 2

#include <openssl/ssl.h>
@


1.18
log
@Replace setpgrp(0, getpid()) with setpgid(0, 0).  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.17 2014/10/25 03:23:49 lteo Exp $	*/
a28 1
#include <arpa/inet.h>
@


1.17
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.16 2014/08/18 12:59:00 reyk Exp $	*/
d356 1
a356 1
		setpgrp(0, getpid());
@


1.16
log
@Sync proc.c with httpd.  httpd needs SIGUSR1 but relayd will ignore it
now instead of terminating the process.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.4 2014/08/04 15:49:28 reyk Exp $	*/
a26 1
#include <netinet/in_systm.h>
@


1.15
log
@Tweak error checking for msgbuf_write() as recommended by the imsg
gurus.

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.14 2014/05/08 13:08:48 blambert Exp $	*/
d166 1
a166 1
	 */	
d326 1
d413 1
d420 1
@


1.14
log
@match relayd proc.c infrastructure with snmpd

okay reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.13 2014/05/06 06:40:03 jsg Exp $	*/
d467 1
a467 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
@


1.13
log
@no need to include rand.h now the RAND_seed() calls are gone.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.12 2014/05/04 10:32:32 reyk Exp $	*/
d339 5
a343 4
	pid_t		 pid;
	struct passwd	*pw;
	const char	*root;
	u_int		 n;
d367 3
d425 3
@


1.12
log
@With the recent change by deraadt@@ to introduce kern.nosuidcoredump=3,
we don't need the horrible debug hack anymore that disabled privdrop
and chroot to get core dumps of privsep processes.  No functional
change for the normal binary, only if it is compiled with the
non-default -DDEBUG option.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.11 2014/04/20 14:48:29 reyk Exp $	*/
a40 1
#include <openssl/rand.h>
@


1.11
log
@Reimplement the multi-dimensional arrays that are used to set up the
process to process imsg communication.  It became a maze after we
added support for multiple relay processes and even worse with the ca
processes.  This change makes it easier to understand.  Now it only
opens socketpairs that are needed - the code previously wasted lots of
fds.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.10 2014/04/18 21:29:20 tedu Exp $	*/
a374 1
#ifndef DEBUG
a378 9
#else
#warning disabling privilege revocation and chroot in DEBUG MODE
	if (p->p_chroot != NULL) {
		if (chroot(root) == -1)
			fatal("proc_run: chroot");
		if (chdir("/") == -1)
			fatal("proc_run: chdir(\"/\")");
	}
#endif
a383 1
#ifndef DEBUG
a387 1
#endif
@


1.10
log
@round up some enemy sympathizers found calling RAND_seed().
ok beck reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.9 2014/04/18 12:02:37 reyk Exp $	*/
d46 3
a48 1
void	 proc_setup(struct privsep *);
a52 1
u_int	 proc_instances(struct privsep *, u_int, u_int);
d55 1
a55 1
proc_ispeer(struct privsep_proc *p, u_int nproc, enum privsep_procid type)
d60 1
a60 1
		if (p[i].p_id == type)
d66 1
a66 1
proc_init(struct privsep *ps, struct privsep_proc *p, u_int nproc)
d68 2
a69 1
	u_int	 i;
d72 37
a108 1
	 * Called from parent
d114 1
d118 3
a120 3
		if (ps->ps_instances[p[i].p_id] < 1)
			ps->ps_instances[p[i].p_id] = 1;
		ps->ps_title[p[i].p_id] = p[i].p_title;
d123 1
a123 1
	proc_setup(ps);
d127 1
a127 1
		ps->ps_pid[p[i].p_id] = (*p[i].p_init)(ps, &p[i]);
d149 1
a149 1
	proc_clear(ps, 1);
d153 2
a154 1
proc_setup(struct privsep *ps)
d156 3
a158 1
	int	 i, j, n, count, sockpair[2];
d160 4
a163 4
	for (i = 0; i < PROC_MAX; i++)
		for (j = 0; j < PROC_MAX; j++) {
			if ((count = proc_instances(ps, i, j)) == 0)
				continue;
d165 12
a176 5
			if ((ps->ps_pipes[i][j] =
			    calloc(count, sizeof(int))) == NULL ||
			    (ps->ps_pipes[j][i] =
			    calloc(count, sizeof(int))) == NULL)
				fatal(NULL);
d178 2
a179 2
			for (n = 0; n < count; n++) {
				if (ps->ps_noaction)
d181 3
a183 2
				if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
				    sockpair) == -1)
d185 6
a190 8
				ps->ps_pipes[i][j][n] = sockpair[0];
				ps->ps_pipes[j][i][n] = sockpair[1];
				socket_set_blockmode(
				    ps->ps_pipes[i][j][n],
				    BM_NONBLOCK);
				socket_set_blockmode(
				    ps->ps_pipes[j][i][n],
				    BM_NONBLOCK);
d193 1
d197 1
a197 1
proc_config(struct privsep *ps, struct privsep_proc *p, u_int nproc)
d199 2
a200 3
	u_int	i, j, src, dst, count, n, instance;

	src = privsep_process;
d203 1
a203 1
	 * close unused pipes
d205 5
a209 3
	for (i = 0; i < PROC_MAX; i++) {
		for (j = 0; j < PROC_MAX; j++) {
			if ((count = proc_instances(ps, i, j)) == 0)
d212 4
a215 5
			for (n = 0; n < count; n++) {
				instance = ps->ps_instances[i] > 1 ? n : 0;
				if (i == src &&
				    proc_ispeer(p, nproc, j) &&
				    ps->ps_instance == instance)
d217 8
a224 4

				if (!ps->ps_noaction)
					close(ps->ps_pipes[i][j][n]);
				ps->ps_pipes[i][j][n] = -1;
d229 3
d233 1
a233 1
	 * listen on appropriate pipes
d236 1
a236 3
		dst = p[i].p_id;
		p[i].p_ps = ps;
		p[i].p_env = ps->ps_env;
d239 1
a239 1
			fatal("proc_config: cannot peer with oneself");
d241 1
a241 4
		if ((count = proc_instances(ps, src, dst)) == 0)
			continue;

		if ((ps->ps_ievs[dst] = calloc(count,
d243 1
a243 1
			fatal("proc_config");
d245 2
a246 2
		for (n = 0; n < count; n++) {
			if (ps->ps_pipes[src][dst][n] == -1)
d250 1
a250 1
			    ps->ps_pipes[src][dst][n]);
d253 1
a253 1
			ps->ps_ievs[dst][n].proc = &p[i];
d255 1
a255 1
			p[i].p_instance = n;
d268 1
a268 1
proc_clear(struct privsep *ps, int purge)
d270 2
a271 1
	u_int	 src = privsep_process, dst, n, count;
d276 2
d279 1
a279 2
		if ((count = proc_instances(ps, src, dst)) == 0 ||
		    ps->ps_ievs[dst] == NULL)
d282 2
a283 2
		for (n = 0; n < count; n++) {
			if (ps->ps_pipes[src][dst][n] == -1)
d285 6
a290 6
			if (purge) {
				event_del(&(ps->ps_ievs[dst][n].ev));
				imsg_clear(&(ps->ps_ievs[dst][n].ibuf));
				close(ps->ps_pipes[src][dst][n]);
			} else
				imsg_flush(&(ps->ps_ievs[dst][n].ibuf));
d292 1
a292 2
		if (purge)
			free(ps->ps_ievs[dst]);
a295 20
u_int
proc_instances(struct privsep *ps, u_int src, u_int dst)
{
	u_int	 count;

	if (ps->ps_instances[src] > 1 &&
	    ps->ps_instances[dst] > 1 &&
	    ps->ps_instances[src] != ps->ps_instances[dst])
		fatalx("N:M peering not supported");

	if (src == dst ||
	    ps->ps_instances[src] == 0 ||
	    ps->ps_instances[dst] == 0)
		return (0);

	count = MAX(ps->ps_instances[src], ps->ps_instances[dst]);

	return (count);
}

d307 1
a307 1
	proc_clear(ps, 1);
d348 3
d353 1
a353 1
		fatal("run_proc: cannot fork");
d364 1
a364 1
	if (p->p_id == PROC_CONTROL) {
d377 1
a377 1
		fatal("run_proc: chroot");
d379 1
a379 1
		fatal("run_proc: chdir(\"/\")");
d384 1
a384 1
			fatal("run_proc: chroot");
d386 1
a386 1
			fatal("run_proc: chdir(\"/\")");
d398 1
a398 1
		fatal("run_proc: cannot drop privileges");
d428 1
a428 1
	proc_config(ps, procs, nproc);
d569 3
a571 16
		/*
		 * -1 means that the current process is
		 * N:1 - one of many processes connected to a single peer,
		 *       so find the right slot of the peer.
		 * 1:N - a single process connected to many peers,
		 *       so find the range of slots of all peers.
		 */
		if (ps->ps_instances[privsep_process] <=
		    ps->ps_instances[id]) {
			*n = 0;
			*m = ps->ps_instances[id];
			return;
		}

		*n = ps->ps_instance;
		*m = ps->ps_instance + 1;
d585 1
a585 1
	for (; n < m; n++)
d589 1
@


1.9
log
@The proc.c code sets up some socketpair for the communication between
different privsep processes.  The implementation is using
multi-dimensional arrays and and some complicated process to process
relations.  This is the first attempt of cleaning it up and to allow
N:N communications for the upcoming "CA" processes.

Discussed with some, but nobody dared to comment on the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.8 2014/04/14 07:18:05 blambert Exp $	*/
a310 1
	u_int32_t	 seed[256];
a393 4

	arc4random_buf(seed, sizeof(seed));
	RAND_seed(seed, sizeof(seed));
	explicit_bzero(seed, sizeof(seed));
@


1.8
log
@Fix the following idiom in the following way:

        arc4random_buf(seed, sizeof(seed));
        RAND_seed(seed, sizeof(seed));
+       explicit_bzero(seed, sizeof(seed));

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.7 2014/02/14 10:21:00 benno Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010,2011 Reyk Floeter <reyk@@openbsd.org>
d51 1
d120 1
a120 5
			/*
			 * find out how many instances of this peer there are.
			 */
			if (i >= j || ps->ps_instances[i] == 0 ||
			    ps->ps_instances[j] == 0)
a122 6
			if (ps->ps_instances[i] > 1 &&
			    ps->ps_instances[j] > 1)
				fatalx("N:M peering not supported");

			count = ps->ps_instances[i] * ps->ps_instances[j];

d159 1
a159 3
			if (i == j ||
			    ps->ps_instances[i] == 0 ||
			    ps->ps_instances[j] == 0)
a161 2
			count = ps->ps_instances[i] * ps->ps_instances[j];

d187 2
a188 1
		count = ps->ps_instances[src] * ps->ps_instances[dst];
d225 2
a226 1
		if (src == dst || ps->ps_ievs[dst] == NULL)
a228 2
		count = ps->ps_instances[src] * ps->ps_instances[dst];

d244 20
d606 9
@


1.7
log
@remove unused function that distracts from cleaning up the imsg_flush() mess
ok krw, florian, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.6 2013/11/13 20:45:50 benno Exp $	*/
d391 1
@


1.6
log
@handle msgbuf_write() returning EAGAIN
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.5 2013/01/17 20:34:18 bluhm Exp $	*/
a588 10
}

void
proc_flush_imsg(struct privsep *ps, enum privsep_procid id, int n)
{
	int	 m;

	proc_range(ps, id, &n, &m);
	for (; n < m; n++)
		imsg_flush(&ps->ps_ievs[id][n].ibuf);
@


1.5
log
@Remove unnecessary pointer casts.  No binary diff.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.4 2012/10/04 20:53:30 reyk Exp $	*/
d435 1
a435 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.3 2011/09/04 20:26:58 bluhm Exp $	*/
d411 1
a411 1
	struct imsgev		*iev = (struct imsgev *)arg;
@


1.3
log
@KNF, fix white spaces in relayd.  No binary change.
ok pyr@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.2 2011/05/19 08:56:49 reyk Exp $	*/
d122 2
a123 2
			if (i >= j || ps->ps_instances[i] == 0||
			   ps->ps_instances[j] == 0)
@


1.2
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.1 2011/05/09 12:09:58 reyk Exp $	*/
d201 1
a201 1
		
@


1.1
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.c,v 1.5 2011/05/05 12:59:31 reyk Exp $	*/
d108 2
d139 2
d182 2
a183 1
				close(ps->ps_pipes[i][j][n]);
d229 29
d268 2
d307 3
d445 1
a445 1
#ifdef DEBUG
d564 1
@

