head	1.220;
access;
symbols
	OPENBSD_6_1:1.219.0.4
	OPENBSD_6_1_BASE:1.219
	OPENBSD_6_0:1.206.0.4
	OPENBSD_6_0_BASE:1.206
	OPENBSD_5_9:1.206.0.2
	OPENBSD_5_9_BASE:1.206
	OPENBSD_5_8:1.198.0.4
	OPENBSD_5_8_BASE:1.198
	OPENBSD_5_7:1.191.0.2
	OPENBSD_5_7_BASE:1.191
	OPENBSD_5_6:1.175.0.4
	OPENBSD_5_6_BASE:1.175
	OPENBSD_5_5:1.167.0.4
	OPENBSD_5_5_BASE:1.167
	OPENBSD_5_4:1.166.0.2
	OPENBSD_5_4_BASE:1.166
	OPENBSD_5_3:1.162.0.2
	OPENBSD_5_3_BASE:1.162
	OPENBSD_5_2:1.150.0.2
	OPENBSD_5_2_BASE:1.150
	OPENBSD_5_1_BASE:1.144
	OPENBSD_5_1:1.144.0.2
	OPENBSD_5_0:1.138.0.2
	OPENBSD_5_0_BASE:1.138
	OPENBSD_4_9:1.128.0.2
	OPENBSD_4_9_BASE:1.128
	OPENBSD_4_8:1.122.0.2
	OPENBSD_4_8_BASE:1.122
	OPENBSD_4_7:1.119.0.2
	OPENBSD_4_7_BASE:1.119
	OPENBSD_4_6:1.116.0.4
	OPENBSD_4_6_BASE:1.116
	OPENBSD_4_5:1.107.0.2
	OPENBSD_4_5_BASE:1.107
	OPENBSD_4_4:1.95.0.2
	OPENBSD_4_4_BASE:1.95
	OPENBSD_4_3:1.85.0.2
	OPENBSD_4_3_BASE:1.85;
locks; strict;
comment	@ * @;


1.220
date	2017.05.27.08.33.25;	author claudio;	state Exp;
branches;
next	1.219;
commitid	mLnU8nnW1ZLoAWRU;

1.219
date	2017.02.02.08.24.16;	author reyk;	state Exp;
branches;
next	1.218;
commitid	L4E1ZRoEzVaurCmz;

1.218
date	2017.01.09.14.49.21;	author reyk;	state Exp;
branches;
next	1.217;
commitid	eA8b246voAapPTkX;

1.217
date	2016.11.10.13.21.58;	author jca;	state Exp;
branches;
next	1.216;
commitid	bzuS4pGsUAgOV3uT;

1.216
date	2016.09.29.22.04.28;	author benno;	state Exp;
branches;
next	1.215;
commitid	zZ5v9lWj6WTPxBm0;

1.215
date	2016.09.26.16.25.16;	author reyk;	state Exp;
branches;
next	1.214;
commitid	VU3xx6ZIlSCM7y2e;

1.214
date	2016.09.23.12.06.15;	author jsg;	state Exp;
branches;
next	1.213;
commitid	Xmyju5ymkjmJLLto;

1.213
date	2016.09.22.07.56.48;	author jsg;	state Exp;
branches;
next	1.212;
commitid	VqrMLa2VHG29imDn;

1.212
date	2016.09.22.06.18.58;	author jsg;	state Exp;
branches;
next	1.211;
commitid	bmmJ9BPqwh9x7C0n;

1.211
date	2016.09.02.14.45.51;	author reyk;	state Exp;
branches;
next	1.210;
commitid	vcV98N2DyJGMwDyQ;

1.210
date	2016.09.02.14.31.47;	author reyk;	state Exp;
branches;
next	1.209;
commitid	5rsV42sOU0zqn3cJ;

1.209
date	2016.09.02.12.12.51;	author reyk;	state Exp;
branches;
next	1.208;
commitid	tCJ77FP0n8bVYrYP;

1.208
date	2016.09.02.11.51.49;	author reyk;	state Exp;
branches;
next	1.207;
commitid	Scmkna4JViHMcK3U;

1.207
date	2016.09.01.10.49.48;	author claudio;	state Exp;
branches;
next	1.206;
commitid	kVeSpNYKmzM2uO33;

1.206
date	2015.12.30.16.00.57;	author benno;	state Exp;
branches;
next	1.205;
commitid	O60zRJngKRCToye8;

1.205
date	2015.12.24.05.06.24;	author mmcc;	state Exp;
branches;
next	1.204;
commitid	2SWcu7YEg2Jvp6L2;

1.204
date	2015.12.07.04.03.27;	author mmcc;	state Exp;
branches;
next	1.203;
commitid	vlUffo7boyCTPJEr;

1.203
date	2015.12.05.20.58.32;	author benno;	state Exp;
branches;
next	1.202;
commitid	pva9RwPKSuQWM4MY;

1.202
date	2015.12.04.15.28.55;	author benno;	state Exp;
branches;
next	1.201;
commitid	DUIf5k9GXWfqC5PU;

1.201
date	2015.12.02.22.12.29;	author benno;	state Exp;
branches;
next	1.200;
commitid	KSrslYc9PdXCr4Hr;

1.200
date	2015.12.02.13.41.27;	author reyk;	state Exp;
branches;
next	1.199;
commitid	vBNcEM4jmO1KceIa;

1.199
date	2015.11.28.09.52.07;	author reyk;	state Exp;
branches;
next	1.198;
commitid	Xo3TbDi9hUaP9ip0;

1.198
date	2015.07.28.10.24.26;	author reyk;	state Exp;
branches;
next	1.197;
commitid	OS3OuQQ5xPSosr2v;

1.197
date	2015.07.18.16.01.28;	author benno;	state Exp;
branches;
next	1.196;
commitid	SsEehKey7cEgRJ3z;

1.196
date	2015.06.12.14.40.55;	author reyk;	state Exp;
branches;
next	1.195;
commitid	l9tjrfdeeLzMV6hw;

1.195
date	2015.06.08.15.47.51;	author claudio;	state Exp;
branches;
next	1.194;
commitid	qDFFH9Mi796T9cGu;

1.194
date	2015.05.18.16.57.20;	author bluhm;	state Exp;
branches;
next	1.193;
commitid	rI96X4LxqTzkzCAH;

1.193
date	2015.04.29.08.41.24;	author bluhm;	state Exp;
branches;
next	1.192;
commitid	2jsvd8aoLwc5wzTA;

1.192
date	2015.04.23.17.03.01;	author florian;	state Exp;
branches;
next	1.191;
commitid	KWnS6e6l32sa1TDa;

1.191
date	2015.02.06.01.37.11;	author reyk;	state Exp;
branches
	1.191.2.1;
next	1.190;
commitid	Lv0p59uUkApDv6rT;

1.190
date	2015.01.22.17.42.09;	author reyk;	state Exp;
branches;
next	1.189;
commitid	puppem00jmzmdm4f;

1.189
date	2015.01.22.15.21.28;	author reyk;	state Exp;
branches;
next	1.188;
commitid	4iTNJ5pZPl4b1HA5;

1.188
date	2015.01.22.09.26.05;	author reyk;	state Exp;
branches;
next	1.187;
commitid	o3hdD3oPPo4ygHrW;

1.187
date	2015.01.16.15.08.52;	author reyk;	state Exp;
branches;
next	1.186;
commitid	cBAkhi7b4UQjJ650;

1.186
date	2015.01.16.15.06.40;	author deraadt;	state Exp;
branches;
next	1.185;
commitid	tOv8XK6tLyhEfayc;

1.185
date	2015.01.16.14.34.51;	author reyk;	state Exp;
branches;
next	1.184;
commitid	vhVTw19iFGP02KBT;

1.184
date	2014.12.21.00.54.49;	author guenther;	state Exp;
branches;
next	1.183;
commitid	XnjIOhurXdX5o1V9;

1.183
date	2014.12.18.20.55.01;	author reyk;	state Exp;
branches;
next	1.182;
commitid	nThpdXmyvXqmRQ4C;

1.182
date	2014.12.12.10.05.09;	author reyk;	state Exp;
branches;
next	1.181;
commitid	J8g0vRzthwLCqf68;

1.181
date	2014.11.19.10.24.40;	author blambert;	state Exp;
branches;
next	1.180;
commitid	EGrSQMGI27r3h8Vf;

1.180
date	2014.11.07.13.48.06;	author jsing;	state Exp;
branches;
next	1.179;
commitid	QL46KAhcJy2F2EDf;

1.179
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.178;
commitid	2uw1UTO4k6erpWzK;

1.178
date	2014.10.15.11.06.16;	author reyk;	state Exp;
branches;
next	1.177;
commitid	VpFBc7l3plkkPKxy;

1.177
date	2014.09.05.10.19.26;	author blambert;	state Exp;
branches;
next	1.176;
commitid	Qc13eOLjGetIgjBs;

1.176
date	2014.08.29.09.03.36;	author blambert;	state Exp;
branches;
next	1.175;
commitid	YgQqK1UkUhNBtyeV;

1.175
date	2014.07.14.00.11.12;	author bluhm;	state Exp;
branches;
next	1.174;
commitid	LPQMOcmMS8D0dRAQ;

1.174
date	2014.07.13.00.32.08;	author benno;	state Exp;
branches;
next	1.173;
commitid	ri182Vf5Hw0I7rh1;

1.173
date	2014.07.11.16.59.38;	author reyk;	state Exp;
branches;
next	1.172;
commitid	For422J6VfsgvmL6;

1.172
date	2014.07.09.16.42.05;	author reyk;	state Exp;
branches;
next	1.171;
commitid	YhQvyAop4vC3AmzJ;

1.171
date	2014.06.27.07.49.08;	author andre;	state Exp;
branches;
next	1.170;
commitid	pPMUb6sAQ5HcQv7b;

1.170
date	2014.05.20.17.33.36;	author reyk;	state Exp;
branches;
next	1.169;

1.169
date	2014.04.22.08.04.23;	author reyk;	state Exp;
branches;
next	1.168;

1.168
date	2014.04.18.13.55.26;	author reyk;	state Exp;
branches;
next	1.167;

1.167
date	2013.09.09.17.57.44;	author reyk;	state Exp;
branches;
next	1.166;

1.166
date	2013.05.30.20.17.12;	author reyk;	state Exp;
branches;
next	1.165;

1.165
date	2013.04.20.17.45.02;	author deraadt;	state Exp;
branches;
next	1.164;

1.164
date	2013.03.10.23.32.53;	author reyk;	state Exp;
branches;
next	1.163;

1.163
date	2013.03.09.14.43.06;	author bluhm;	state Exp;
branches;
next	1.162;

1.162
date	2013.02.05.21.36.33;	author bluhm;	state Exp;
branches;
next	1.161;

1.161
date	2013.01.17.20.34.18;	author bluhm;	state Exp;
branches;
next	1.160;

1.160
date	2012.12.18.15.58.25;	author reyk;	state Exp;
branches;
next	1.159;

1.159
date	2012.11.29.01.01.53;	author bluhm;	state Exp;
branches;
next	1.158;

1.158
date	2012.11.27.05.00.28;	author guenther;	state Exp;
branches;
next	1.157;

1.157
date	2012.10.19.16.49.50;	author reyk;	state Exp;
branches;
next	1.156;

1.156
date	2012.10.04.20.53.30;	author reyk;	state Exp;
branches;
next	1.155;

1.155
date	2012.10.03.08.40.40;	author reyk;	state Exp;
branches;
next	1.154;

1.154
date	2012.10.03.08.33.31;	author reyk;	state Exp;
branches;
next	1.153;

1.153
date	2012.09.21.09.56.27;	author benno;	state Exp;
branches;
next	1.152;

1.152
date	2012.09.20.12.30.20;	author reyk;	state Exp;
branches;
next	1.151;

1.151
date	2012.09.17.19.27.38;	author benno;	state Exp;
branches;
next	1.150;

1.150
date	2012.07.13.07.54.14;	author benno;	state Exp;
branches
	1.150.2.1;
next	1.149;

1.149
date	2012.07.09.09.52.04;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2012.04.30.10.49.57;	author benno;	state Exp;
branches;
next	1.147;

1.147
date	2012.04.27.14.01.35;	author giovanni;	state Exp;
branches;
next	1.146;

1.146
date	2012.04.11.08.25.26;	author deraadt;	state Exp;
branches;
next	1.145;

1.145
date	2012.03.24.14.48.18;	author sthen;	state Exp;
branches;
next	1.144;

1.144
date	2012.01.21.13.40.48;	author camield;	state Exp;
branches;
next	1.143;

1.143
date	2011.09.21.18.45.40;	author bluhm;	state Exp;
branches;
next	1.142;

1.142
date	2011.09.16.14.29.26;	author bluhm;	state Exp;
branches;
next	1.141;

1.141
date	2011.09.04.20.26.58;	author bluhm;	state Exp;
branches;
next	1.140;

1.140
date	2011.09.04.10.42.47;	author bluhm;	state Exp;
branches;
next	1.139;

1.139
date	2011.09.04.09.55.10;	author bluhm;	state Exp;
branches;
next	1.138;

1.138
date	2011.05.20.09.43.53;	author reyk;	state Exp;
branches;
next	1.137;

1.137
date	2011.05.19.08.56.49;	author reyk;	state Exp;
branches;
next	1.136;

1.136
date	2011.05.09.12.08.47;	author reyk;	state Exp;
branches;
next	1.135;

1.135
date	2011.05.05.12.01.44;	author reyk;	state Exp;
branches;
next	1.134;

1.134
date	2011.04.24.10.07.43;	author bluhm;	state Exp;
branches;
next	1.133;

1.133
date	2011.04.12.12.37.22;	author reyk;	state Exp;
branches;
next	1.132;

1.132
date	2011.04.12.11.45.18;	author bluhm;	state Exp;
branches;
next	1.131;

1.131
date	2011.04.07.13.22.29;	author reyk;	state Exp;
branches;
next	1.130;

1.130
date	2011.03.12.21.06.40;	author bluhm;	state Exp;
branches;
next	1.129;

1.129
date	2011.03.12.18.18.11;	author bluhm;	state Exp;
branches;
next	1.128;

1.128
date	2010.12.20.12.38.06;	author dhill;	state Exp;
branches;
next	1.127;

1.127
date	2010.11.30.14.49.14;	author reyk;	state Exp;
branches;
next	1.126;

1.126
date	2010.11.30.14.38.45;	author reyk;	state Exp;
branches;
next	1.125;

1.125
date	2010.11.24.13.57.05;	author jsg;	state Exp;
branches;
next	1.124;

1.124
date	2010.11.16.15.31.01;	author jsg;	state Exp;
branches;
next	1.123;

1.123
date	2010.10.12.14.52.21;	author dhill;	state Exp;
branches;
next	1.122;

1.122
date	2010.08.01.22.18.35;	author sthen;	state Exp;
branches
	1.122.2.1;
next	1.121;

1.121
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.120;

1.120
date	2010.05.14.11.13.36;	author reyk;	state Exp;
branches;
next	1.119;

1.119
date	2010.02.18.16.33.25;	author jsg;	state Exp;
branches
	1.119.2.1;
next	1.118;

1.118
date	2010.01.11.06.40.14;	author jsg;	state Exp;
branches;
next	1.117;

1.117
date	2009.08.07.11.21.53;	author reyk;	state Exp;
branches;
next	1.116;

1.116
date	2009.06.07.05.56.25;	author eric;	state Exp;
branches;
next	1.115;

1.115
date	2009.06.05.23.39.51;	author pyr;	state Exp;
branches;
next	1.114;

1.114
date	2009.06.05.00.20.50;	author pyr;	state Exp;
branches;
next	1.113;

1.113
date	2009.06.05.00.04.01;	author pyr;	state Exp;
branches;
next	1.112;

1.112
date	2009.06.02.12.24.16;	author reyk;	state Exp;
branches;
next	1.111;

1.111
date	2009.06.02.11.33.06;	author reyk;	state Exp;
branches;
next	1.110;

1.110
date	2009.04.24.13.22.01;	author pyr;	state Exp;
branches;
next	1.109;

1.109
date	2009.04.02.14.30.51;	author reyk;	state Exp;
branches;
next	1.108;

1.108
date	2009.04.01.14.56.38;	author reyk;	state Exp;
branches;
next	1.107;

1.107
date	2008.09.29.15.50.56;	author reyk;	state Exp;
branches;
next	1.106;

1.106
date	2008.09.29.15.27.20;	author reyk;	state Exp;
branches;
next	1.105;

1.105
date	2008.09.29.15.12.22;	author reyk;	state Exp;
branches;
next	1.104;

1.104
date	2008.08.11.08.24.41;	author reyk;	state Exp;
branches;
next	1.103;

1.103
date	2008.08.11.08.07.14;	author reyk;	state Exp;
branches;
next	1.102;

1.102
date	2008.08.11.06.42.06;	author reyk;	state Exp;
branches;
next	1.101;

1.101
date	2008.08.08.22.49.33;	author reyk;	state Exp;
branches;
next	1.100;

1.100
date	2008.08.08.20.34.30;	author reyk;	state Exp;
branches;
next	1.99;

1.99
date	2008.08.08.19.13.24;	author reyk;	state Exp;
branches;
next	1.98;

1.98
date	2008.08.08.18.56.05;	author reyk;	state Exp;
branches;
next	1.97;

1.97
date	2008.08.08.18.38.14;	author reyk;	state Exp;
branches;
next	1.96;

1.96
date	2008.08.08.08.51.21;	author thib;	state Exp;
branches;
next	1.95;

1.95
date	2008.07.22.23.17.37;	author reyk;	state Exp;
branches;
next	1.94;

1.94
date	2008.07.16.15.02.19;	author reyk;	state Exp;
branches;
next	1.93;

1.93
date	2008.07.16.14.49.44;	author reyk;	state Exp;
branches;
next	1.92;

1.92
date	2008.07.09.17.16.51;	author reyk;	state Exp;
branches;
next	1.91;

1.91
date	2008.07.09.14.57.01;	author reyk;	state Exp;
branches;
next	1.90;

1.90
date	2008.06.11.18.21.19;	author reyk;	state Exp;
branches;
next	1.89;

1.89
date	2008.05.08.02.27.58;	author reyk;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.05.12.33.55;	author pyr;	state Exp;
branches;
next	1.87;

1.87
date	2008.03.21.05.22.11;	author reyk;	state Exp;
branches;
next	1.86;

1.86
date	2008.03.20.22.24.46;	author reyk;	state Exp;
branches;
next	1.85;

1.85
date	2008.03.03.16.41.36;	author reyk;	state Exp;
branches;
next	1.84;

1.84
date	2008.02.13.11.32.59;	author reyk;	state Exp;
branches;
next	1.83;

1.83
date	2008.02.05.14.12.58;	author thib;	state Exp;
branches;
next	1.82;

1.82
date	2008.02.04.12.12.30;	author thib;	state Exp;
branches;
next	1.81;

1.81
date	2008.02.04.12.05.26;	author thib;	state Exp;
branches;
next	1.80;

1.80
date	2008.01.31.12.12.50;	author thib;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.31.09.56.28;	author reyk;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.31.09.33.39;	author reyk;	state Exp;
branches;
next	1.77;

1.77
date	2007.12.08.20.36.36;	author pyr;	state Exp;
branches;
next	1.76;

1.76
date	2007.12.08.17.07.09;	author reyk;	state Exp;
branches;
next	1.75;

1.75
date	2007.12.07.17.17.01;	author reyk;	state Exp;
branches;
next	1.74;

1.74
date	2007.11.28.16.25.12;	author reyk;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.28.14.41.36;	author reyk;	state Exp;
branches;
next	1.72;

1.72
date	2007.11.26.09.38.25;	author reyk;	state Exp;
branches;
next	1.71;

1.71
date	2007.11.24.17.43.47;	author reyk;	state Exp;
branches;
next	1.70;

1.70
date	2007.11.24.17.07.28;	author reyk;	state Exp;
branches;
next	1.69;

1.69
date	2007.11.24.16.13.50;	author reyk;	state Exp;
branches;
next	1.68;

1.68
date	2007.11.24.13.39.24;	author reyk;	state Exp;
branches;
next	1.67;

1.67
date	2007.11.23.09.39.42;	author reyk;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.22.16.07.03;	author reyk;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.22.10.09.53;	author reyk;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.21.20.41.40;	author reyk;	state Exp;
branches;
next	1.63;

1.63
date	2007.11.21.20.01.45;	author reyk;	state Exp;
branches;
next	1.62;

1.62
date	2007.11.21.14.12.04;	author reyk;	state Exp;
branches;
next	1.61;

1.61
date	2007.11.21.11.06.21;	author reyk;	state Exp;
branches;
next	1.60;

1.60
date	2007.11.20.17.11.50;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2007.11.20.15.54.55;	author reyk;	state Exp;
branches;
next	1.58;

1.58
date	2007.11.20.15.10.46;	author reyk;	state Exp;
branches;
next	1.57;

1.57
date	2007.11.20.09.59.09;	author reyk;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.20.09.57.49;	author reyk;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.19.15.31.36;	author reyk;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.19.14.48.19;	author reyk;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.22.17.14.10;	author reyk;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.22.16.53.30;	author pyr;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.19.14.15.14;	author pyr;	state Exp;
branches;
next	1.50;

1.50
date	2007.10.05.17.32.13;	author reyk;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.05.15.46.49;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2007.10.01.13.57.29;	author pyr;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.28.13.05.28;	author pyr;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.27.13.50.40;	author pyr;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.27.13.34.22;	author pyr;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.25.08.24.26;	author pyr;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.10.11.59.22;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.07.08.20.24;	author reyk;	state Exp;
branches;
next	1.41;

1.41
date	2007.09.06.19.55.45;	author reyk;	state Exp;
branches;
next	1.40;

1.40
date	2007.09.05.10.25.13;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.05.08.48.42;	author reyk;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.04.10.58.08;	author reyk;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.04.10.32.54;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.26.23.29.40;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.19.06.29.20;	author pyr;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.12.15.16.10;	author msf;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.07.07.19.50;	author pyr;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.29.00.48.04;	author pyr;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.29.00.21.10;	author pyr;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.28.22.11.33;	author pyr;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.27.20.53.10;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.26.19.58.49;	author pyr;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.02.09.07.28;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.12.14.45.45;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.10.21.33.52;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.10.18.18.26;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.10.18.14.17;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.21.00.08.08;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.17.22.25.08;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.17.22.22.23;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.13.12.04.52;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.07.17.40.32;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.06.19.26.46;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.05.11.44.50;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.02.11.32.40;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.27.13.38.58;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.26.16.10.24;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.26.15.41.44;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.26.12.35.43;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.26.12.16.12;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.26.12.11.19;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.26.12.09.21;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.26.11.59.48;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.26.11.24.26;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.25.18.16.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.24.15.48.54;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.24.00.22.32;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.22.23.07.38;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.22.03.32.40;	author reyk;	state Exp;
branches;
next	;

1.119.2.1
date	2010.10.26.01.49.49;	author william;	state Exp;
branches;
next	;

1.122.2.1
date	2010.10.26.01.50.13;	author william;	state Exp;
branches;
next	;

1.150.2.1
date	2013.06.04.00.57.16;	author sthen;	state Exp;
branches;
next	;

1.191.2.1
date	2015.09.20.11.20.16;	author benno;	state Exp;
branches;
next	;
commitid	C9WQyjgbN7h0ioOp;


desc
@@


1.220
log
@Migrate relayd to use libtls for TLS. Still does the TLS privsep via the
engine but at least we can use a sane API for new features.
Going in now so it is possible to work with this in tree.
General agreement at d2k17.
@
text
@/*	$OpenBSD: relay.c,v 1.219 2017/02/02 08:24:16 reyk Exp $	*/

/*
 * Copyright (c) 2006 - 2014 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>

#include <limits.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <event.h>
#include <siphash.h>
#include <imsg.h>

#include <tls.h>

#include "relayd.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

void		 relay_statistics(int, short, void *);
int		 relay_dispatch_parent(int, struct privsep_proc *,
		    struct imsg *);
int		 relay_dispatch_pfe(int, struct privsep_proc *,
		    struct imsg *);
int		 relay_dispatch_ca(int, struct privsep_proc *,
		    struct imsg *);
int		 relay_dispatch_hce(int, struct privsep_proc *,
		    struct imsg *);
void		 relay_shutdown(void);

void		 relay_protodebug(struct relay *);
void		 relay_ruledebug(struct relay_rule *);
void		 relay_init(struct privsep *, struct privsep_proc *p, void *);
void		 relay_launch(void);
int		 relay_socket(struct sockaddr_storage *, in_port_t,
		    struct protocol *, int, int);
int		 relay_socket_listen(struct sockaddr_storage *, in_port_t,
		    struct protocol *);
int		 relay_socket_connect(struct sockaddr_storage *, in_port_t,
		    struct protocol *, int);

void		 relay_accept(int, short, void *);
void		 relay_input(struct rsession *);

void		 relay_hash_addr(SIPHASH_CTX *, struct sockaddr_storage *, int);

int		 relay_tls_ctx_create(struct relay *);
void		 relay_tls_transaction(struct rsession *,
		    struct ctl_relay_event *);
void		 relay_tls_handshake(int, short, void *);
void		 relay_connect_retry(int, short, void *);
void		 relay_tls_connected(struct ctl_relay_event *);
void		 relay_tls_readcb(int, short, void *);
void		 relay_tls_writecb(int, short, void *);

char		*relay_load_file(const char *, off_t *);
extern void	 bufferevent_read_pressure_cb(struct evbuffer *, size_t,
		    size_t, void *);

volatile int relay_sessions;
volatile int relay_inflight = 0;
objid_t relay_conid;

static struct relayd		*env = NULL;

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	relay_dispatch_parent },
	{ "pfe",	PROC_PFE,	relay_dispatch_pfe },
	{ "ca",		PROC_CA,	relay_dispatch_ca },
	{ "hce",	PROC_HCE,	relay_dispatch_hce },
};

void
relay(struct privsep *ps, struct privsep_proc *p)
{
	env = ps->ps_env;
	proc_run(ps, p, procs, nitems(procs), relay_init, NULL);
	relay_http(env);
}

void
relay_shutdown(void)
{
	config_purge(env, CONFIG_ALL);
	usleep(200);	/* XXX relay needs to shutdown last */
}

void
relay_ruledebug(struct relay_rule *rule)
{
	struct kv	*kv = NULL;
	u_int		 i;

	fprintf(stderr, "\t\t");

	switch (rule->rule_action) {
	case RULE_ACTION_MATCH:
		fprintf(stderr, "match ");
		break;
	case RULE_ACTION_BLOCK:
		fprintf(stderr, "block ");
		break;
	case RULE_ACTION_PASS:
		fprintf(stderr, "pass ");
		break;
	}

	switch (rule->rule_dir) {
	case RELAY_DIR_ANY:
		break;
	case RELAY_DIR_REQUEST:
		fprintf(stderr, "request ");
		break;
	case RELAY_DIR_RESPONSE:
		fprintf(stderr, "response ");
		break;
	default:
		return;
		/* NOTREACHED */
		break;
	}

	if (rule->rule_flags & RULE_FLAG_QUICK)
		fprintf(stderr, "quick ");

	for (i = 1; i < KEY_TYPE_MAX; i++) {
		kv = &rule->rule_kv[i];
		if (kv->kv_type != i)
			continue;

		switch (kv->kv_type) {
		case KEY_TYPE_COOKIE:
			fprintf(stderr, "cookie ");
			break;
		case KEY_TYPE_HEADER:
			fprintf(stderr, "header ");
			break;
		case KEY_TYPE_PATH:
			fprintf(stderr, "path ");
			break;
		case KEY_TYPE_QUERY:
			fprintf(stderr, "query ");
			break;
		case KEY_TYPE_URL:
			fprintf(stderr, "url ");
			break;
		default:
			continue;
		}

		switch (kv->kv_option) {
		case KEY_OPTION_APPEND:
			fprintf(stderr, "append ");
			break;
		case KEY_OPTION_SET:
			fprintf(stderr, "set ");
			break;
		case KEY_OPTION_REMOVE:
			fprintf(stderr, "remove ");
			break;
		case KEY_OPTION_HASH:
			fprintf(stderr, "hash ");
			break;
		case KEY_OPTION_LOG:
			fprintf(stderr, "log ");
			break;
		case KEY_OPTION_NONE:
			break;
		}

		switch (kv->kv_digest) {
		case DIGEST_SHA1:
		case DIGEST_MD5:
			fprintf(stderr, "digest ");
			break;
		default:
			break;
		}

		fprintf(stderr, "%s%s%s%s%s%s ",
		    kv->kv_key == NULL ? "" : "\"",
		    kv->kv_key == NULL ? "" : kv->kv_key,
		    kv->kv_key == NULL ? "" : "\"",
		    kv->kv_value == NULL ? "" : " value \"",
		    kv->kv_value == NULL ? "" : kv->kv_value,
		    kv->kv_value == NULL ? "" : "\"");
	}

	if (rule->rule_tablename[0])
		fprintf(stderr, "forward to <%s> ", rule->rule_tablename);

	if (rule->rule_tag == -1)
		fprintf(stderr, "no tag ");
	else if (rule->rule_tag && rule->rule_tagname[0])
		fprintf(stderr, "tag \"%s\" ",
		    rule->rule_tagname);

	if (rule->rule_tagged && rule->rule_taggedname[0])
		fprintf(stderr, "tagged \"%s\" ",
		    rule->rule_taggedname);

	if (rule->rule_label == -1)
		fprintf(stderr, "no label ");
	else if (rule->rule_label && rule->rule_labelname[0])
		fprintf(stderr, "label \"%s\" ",
		    rule->rule_labelname);

	fprintf(stderr, "\n");
}

void
relay_protodebug(struct relay *rlay)
{
	struct protocol		*proto = rlay->rl_proto;
	struct relay_rule	*rule = NULL;

	fprintf(stderr, "protocol %d: name %s\n",
	    proto->id, proto->name);
	fprintf(stderr, "\tflags: %s, relay flags: %s\n",
	    printb_flags(proto->flags, F_BITS),
	    printb_flags(rlay->rl_conf.flags, F_BITS));
	if (proto->tcpflags)
		fprintf(stderr, "\ttcp flags: %s\n",
		    printb_flags(proto->tcpflags, TCPFLAG_BITS));
	if ((rlay->rl_conf.flags & (F_TLS|F_TLSCLIENT)) && proto->tlsflags)
		fprintf(stderr, "\ttls flags: %s\n",
		    printb_flags(proto->tlsflags, TLSFLAG_BITS));
	fprintf(stderr, "\ttls session tickets: %s\n",
	    (proto->tickets == 1) ? "enabled" : "disabled");
	fprintf(stderr, "\ttype: ");
	switch (proto->type) {
	case RELAY_PROTO_TCP:
		fprintf(stderr, "tcp\n");
		break;
	case RELAY_PROTO_HTTP:
		fprintf(stderr, "http\n");
		break;
	case RELAY_PROTO_DNS:
		fprintf(stderr, "dns\n");
		break;
	}

	rule = TAILQ_FIRST(&proto->rules);
	while (rule != NULL) {
		relay_ruledebug(rule);
		rule = TAILQ_NEXT(rule, rule_entry);
	}
}

int
relay_privinit(struct relay *rlay)
{
	log_debug("%s: adding relay %s", __func__, rlay->rl_conf.name);

	if (log_getverbose() > 1)
		relay_protodebug(rlay);

	switch (rlay->rl_proto->type) {
	case RELAY_PROTO_DNS:
		relay_udp_privinit(env, rlay);
		break;
	case RELAY_PROTO_TCP:
		break;
	case RELAY_PROTO_HTTP:
		break;
	}

	if (rlay->rl_conf.flags & F_UDP)
		rlay->rl_s = relay_udp_bind(&rlay->rl_conf.ss,
		    rlay->rl_conf.port, rlay->rl_proto);
	else
		rlay->rl_s = relay_socket_listen(&rlay->rl_conf.ss,
		    rlay->rl_conf.port, rlay->rl_proto);
	if (rlay->rl_s == -1)
		return (-1);

	return (0);
}

void
relay_init(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	struct timeval	 tv;

	if (config_init(ps->ps_env) == -1)
		fatal("failed to initialize configuration");

	/* We use a custom shutdown callback */
	p->p_shutdown = relay_shutdown;

	/* Unlimited file descriptors (use system limits) */
	socket_rlimit(-1);

	if (pledge("stdio recvfd inet", NULL) == -1)
		fatal("pledge");

	/* Schedule statistics timer */
	evtimer_set(&env->sc_statev, relay_statistics, ps);
	bcopy(&env->sc_conf.statinterval, &tv, sizeof(tv));
	evtimer_add(&env->sc_statev, &tv);
}

void
relay_session_publish(struct rsession *s)
{
	proc_compose(env->sc_ps, PROC_PFE, IMSG_SESS_PUBLISH, s, sizeof(*s));
}

void
relay_session_unpublish(struct rsession *s)
{
	proc_compose(env->sc_ps, PROC_PFE, IMSG_SESS_UNPUBLISH,
	    &s->se_id, sizeof(s->se_id));
}

void
relay_statistics(int fd, short events, void *arg)
{
	struct privsep		*ps = arg;
	struct relay		*rlay;
	struct ctl_stats	 crs, *cur;
	struct timeval		 tv, tv_now;
	int			 resethour = 0, resetday = 0;
	struct rsession		*con, *next_con;

	/*
	 * This is a hack to calculate some average statistics.
	 * It doesn't try to be very accurate, but could be improved...
	 */

	timerclear(&tv);
	getmonotime(&tv_now);

	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry) {
		bzero(&crs, sizeof(crs));
		resethour = resetday = 0;

		cur = &rlay->rl_stats[ps->ps_instance];
		cur->cnt += cur->last;
		cur->tick++;
		cur->avg = (cur->last + cur->avg) / 2;
		cur->last_hour += cur->last;
		if ((cur->tick %
		    (3600 / env->sc_conf.statinterval.tv_sec)) == 0) {
			cur->avg_hour = (cur->last_hour + cur->avg_hour) / 2;
			resethour++;
		}
		cur->last_day += cur->last;
		if ((cur->tick %
		    (86400 / env->sc_conf.statinterval.tv_sec)) == 0) {
			cur->avg_day = (cur->last_day + cur->avg_day) / 2;
			resethour++;
		}
		bcopy(cur, &crs, sizeof(crs));

		cur->last = 0;
		if (resethour)
			cur->last_hour = 0;
		if (resetday)
			cur->last_day = 0;

		crs.id = rlay->rl_conf.id;
		crs.proc = ps->ps_instance;
		proc_compose(env->sc_ps, PROC_PFE, IMSG_STATISTICS,
		    &crs, sizeof(crs));

		for (con = SPLAY_ROOT(&rlay->rl_sessions);
		    con != NULL; con = next_con) {
			next_con = SPLAY_NEXT(session_tree,
			    &rlay->rl_sessions, con);
			timersub(&tv_now, &con->se_tv_last, &tv);
			if (timercmp(&tv, &rlay->rl_conf.timeout, >=))
				relay_close(con, "hard timeout");
		}
	}

	/* Schedule statistics timer */
	evtimer_set(&env->sc_statev, relay_statistics, ps);
	bcopy(&env->sc_conf.statinterval, &tv, sizeof(tv));
	evtimer_add(&env->sc_statev, &tv);
}

void
relay_launch(void)
{
	void			(*callback)(int, short, void *);
	struct relay		*rlay;
	struct host		*host;
	struct relay_table	*rlt;

	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry) {
		if ((rlay->rl_conf.flags & (F_TLS|F_TLSCLIENT)) &&
		    relay_tls_ctx_create(rlay) == -1)
			fatalx("relay_launch: failed to create TLS context");

		TAILQ_FOREACH(rlt, &rlay->rl_tables, rlt_entry) {
			/*
			 * set rule->rule_table in advance and save time
			 * looking up for this later on rule/connection
			 * evalution
			 */
			rule_settable(&rlay->rl_proto->rules, rlt);

			rlt->rlt_index = 0;
			rlt->rlt_nhosts = 0;
			TAILQ_FOREACH(host, &rlt->rlt_table->hosts, entry) {
				if (rlt->rlt_nhosts >= RELAY_MAXHOSTS)
					fatal("relay_init: "
					    "too many hosts in table");
				host->idx = rlt->rlt_nhosts;
				rlt->rlt_host[rlt->rlt_nhosts++] = host;
			}
			log_info("adding %d hosts from table %s%s",
			    rlt->rlt_nhosts, rlt->rlt_table->conf.name,
			    rlt->rlt_table->conf.check ? "" : " (no check)");
		}

		switch (rlay->rl_proto->type) {
		case RELAY_PROTO_DNS:
			relay_udp_init(rlay);
			break;
		case RELAY_PROTO_TCP:
		case RELAY_PROTO_HTTP:
			relay_http_init(rlay);
			/* Use defaults */
			break;
		}

		log_debug("%s: running relay %s", __func__,
		    rlay->rl_conf.name);

		rlay->rl_up = HOST_UP;

		if (rlay->rl_conf.flags & F_UDP)
			callback = relay_udp_server;
		else
			callback = relay_accept;

		event_set(&rlay->rl_ev, rlay->rl_s, EV_READ,
		    callback, rlay);
		event_add(&rlay->rl_ev, NULL);
		evtimer_set(&rlay->rl_evt, callback, rlay);
	}
}

int
relay_socket_af(struct sockaddr_storage *ss, in_port_t port)
{
	switch (ss->ss_family) {
	case AF_INET:
		((struct sockaddr_in *)ss)->sin_port = port;
		((struct sockaddr_in *)ss)->sin_len =
		    sizeof(struct sockaddr_in);
		break;
	case AF_INET6:
		((struct sockaddr_in6 *)ss)->sin6_port = port;
		((struct sockaddr_in6 *)ss)->sin6_len =
		    sizeof(struct sockaddr_in6);
		break;
	default:
		return (-1);
	}

	return (0);
}

in_port_t
relay_socket_getport(struct sockaddr_storage *ss)
{
	switch (ss->ss_family) {
	case AF_INET:
		return (((struct sockaddr_in *)ss)->sin_port);
	case AF_INET6:
		return (((struct sockaddr_in6 *)ss)->sin6_port);
	default:
		return (0);
	}

	/* NOTREACHED */
	return (0);
}

int
relay_socket(struct sockaddr_storage *ss, in_port_t port,
    struct protocol *proto, int fd, int reuseport)
{
	struct linger	lng;
	int		s = -1, val;

	if (relay_socket_af(ss, port) == -1)
		goto bad;

	s = fd == -1 ? socket(ss->ss_family,
	    SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP) : fd;
	if (s == -1)
		goto bad;

	/*
	 * Socket options
	 */
	bzero(&lng, sizeof(lng));
	if (setsockopt(s, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1)
		goto bad;
	if (reuseport) {
		val = 1;
		if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &val,
			sizeof(int)) == -1)
			goto bad;
	}
	if (proto->tcpflags & TCPFLAG_BUFSIZ) {
		val = proto->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
		    &val, sizeof(val)) == -1)
			goto bad;
		val = proto->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
		    &val, sizeof(val)) == -1)
			goto bad;
	}

	/*
	 * IP options
	 */
	if (proto->tcpflags & TCPFLAG_IPTTL) {
		val = (int)proto->tcpipttl;
		switch (ss->ss_family) {
		case AF_INET:
			if (setsockopt(s, IPPROTO_IP, IP_TTL,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		case AF_INET6:
			if (setsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		}
	}
	if (proto->tcpflags & TCPFLAG_IPMINTTL) {
		val = (int)proto->tcpipminttl;
		switch (ss->ss_family) {
		case AF_INET:
			if (setsockopt(s, IPPROTO_IP, IP_MINTTL,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		case AF_INET6:
			if (setsockopt(s, IPPROTO_IPV6, IPV6_MINHOPCOUNT,
			    &val, sizeof(val)) == -1)
				goto bad;
			break;
		}
	}

	/*
	 * TCP options
	 */
	if (proto->tcpflags & (TCPFLAG_NODELAY|TCPFLAG_NNODELAY)) {
		if (proto->tcpflags & TCPFLAG_NNODELAY)
			val = 0;
		else
			val = 1;
		if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY,
		    &val, sizeof(val)) == -1)
			goto bad;
	}
	if (proto->tcpflags & (TCPFLAG_SACK|TCPFLAG_NSACK)) {
		if (proto->tcpflags & TCPFLAG_NSACK)
			val = 0;
		else
			val = 1;
		if (setsockopt(s, IPPROTO_TCP, TCP_SACK_ENABLE,
		    &val, sizeof(val)) == -1)
			goto bad;
	}

	return (s);

 bad:
	if (s != -1)
		close(s);
	return (-1);
}

int
relay_socket_connect(struct sockaddr_storage *ss, in_port_t port,
    struct protocol *proto, int fd)
{
	int	s;

	if ((s = relay_socket(ss, port, proto, fd, 0)) == -1)
		return (-1);

	if (connect(s, (struct sockaddr *)ss, ss->ss_len) == -1) {
		if (errno != EINPROGRESS)
			goto bad;
	}

	return (s);

 bad:
	close(s);
	return (-1);
}

int
relay_socket_listen(struct sockaddr_storage *ss, in_port_t port,
    struct protocol *proto)
{
	int s;

	if ((s = relay_socket(ss, port, proto, -1, 1)) == -1)
		return (-1);

	if (bind(s, (struct sockaddr *)ss, ss->ss_len) == -1)
		goto bad;
	if (listen(s, proto->tcpbacklog) == -1)
		goto bad;

	return (s);

 bad:
	close(s);
	return (-1);
}

void
relay_connected(int fd, short sig, void *arg)
{
	struct rsession		*con = arg;
	struct relay		*rlay = con->se_relay;
	struct protocol		*proto = rlay->rl_proto;
	evbuffercb		 outrd = relay_read;
	evbuffercb		 outwr = relay_write;
	struct bufferevent	*bev;
	struct ctl_relay_event	*out = &con->se_out;
	socklen_t		 len;
	int			 error;

	if (sig == EV_TIMEOUT) {
		relay_abort_http(con, 504, "connect timeout", 0);
		return;
	}

	len = sizeof(error);
	if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &error,
	    &len) == -1 || error) {
		if (error)
			errno = error;
		relay_abort_http(con, 500, "socket error", 0);
		return;
	}

	if ((rlay->rl_conf.flags & F_TLSCLIENT) && (out->tls == NULL)) {
		relay_tls_transaction(con, out);
		return;
	}

	DPRINTF("%s: session %d: successful", __func__, con->se_id);

	switch (rlay->rl_proto->type) {
	case RELAY_PROTO_HTTP:
		if (relay_httpdesc_init(out) == -1) {
			relay_close(con,
			    "failed to allocate http descriptor");
			return;
		}
		con->se_out.toread = TOREAD_HTTP_HEADER;
		outrd = relay_read_http;
		break;
	case RELAY_PROTO_TCP:
		/* Use defaults */
		break;
	default:
		fatalx("relay_connected: unknown protocol");
	}

	/*
	 * Relay <-> Server
	 */
	bev = bufferevent_new(fd, outrd, outwr, relay_error, &con->se_out);
	if (bev == NULL) {
		relay_abort_http(con, 500,
		    "failed to allocate output buffer event", 0);
		return;
	}
	evbuffer_free(bev->output);
	bev->output = con->se_out.output;
	if (bev->output == NULL)
		fatal("relay_connected: invalid output buffer");
	con->se_out.bev = bev;

	/* Initialize the TLS wrapper */
	if ((rlay->rl_conf.flags & F_TLSCLIENT) && (out->tls != NULL))
		relay_tls_connected(out);

	bufferevent_settimeout(bev,
	    rlay->rl_conf.timeout.tv_sec, rlay->rl_conf.timeout.tv_sec);
	bufferevent_setwatermark(bev, EV_WRITE,
		RELAY_MIN_PREFETCHED * proto->tcpbufsiz, 0);
	bufferevent_enable(bev, EV_READ|EV_WRITE);
	if (con->se_in.bev)
		bufferevent_enable(con->se_in.bev, EV_READ);

	if (relay_splice(&con->se_out) == -1)
		relay_close(con, strerror(errno));
}

void
relay_input(struct rsession *con)
{
	struct relay	*rlay = con->se_relay;
	struct protocol	*proto = rlay->rl_proto;
	evbuffercb	 inrd = relay_read;
	evbuffercb	 inwr = relay_write;

	switch (rlay->rl_proto->type) {
	case RELAY_PROTO_HTTP:
		if (relay_httpdesc_init(&con->se_in) == -1) {
			relay_close(con,
			    "failed to allocate http descriptor");
			return;
		}
		con->se_in.toread = TOREAD_HTTP_HEADER;
		inrd = relay_read_http;
		break;
	case RELAY_PROTO_TCP:
		/* Use defaults */
		break;
	default:
		fatalx("relay_input: unknown protocol");
	}

	/*
	 * Client <-> Relay
	 */
	con->se_in.bev = bufferevent_new(con->se_in.s, inrd, inwr,
	    relay_error, &con->se_in);
	if (con->se_in.bev == NULL) {
		relay_close(con, "failed to allocate input buffer event");
		return;
	}

	/* Initialize the TLS wrapper */
	if ((rlay->rl_conf.flags & F_TLS) && con->se_in.tls != NULL)
		relay_tls_connected(&con->se_in);

	bufferevent_settimeout(con->se_in.bev,
	    rlay->rl_conf.timeout.tv_sec, rlay->rl_conf.timeout.tv_sec);
	bufferevent_setwatermark(con->se_in.bev, EV_WRITE,
		RELAY_MIN_PREFETCHED * proto->tcpbufsiz, 0);
	bufferevent_enable(con->se_in.bev, EV_READ|EV_WRITE);

	if (relay_splice(&con->se_in) == -1)
		relay_close(con, strerror(errno));
}

void
relay_write(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = arg;
	struct rsession		*con = cre->con;

	getmonotime(&con->se_tv_last);

	if (con->se_done)
		goto done;
	if (relay_splice(cre->dst) == -1)
		goto fail;
	if (cre->dst->bev)
		bufferevent_enable(cre->dst->bev, EV_READ);

	return;
 done:
	relay_close(con, "last write (done)");
	return;
 fail:
	relay_close(con, strerror(errno));
}

void
relay_dump(struct ctl_relay_event *cre, const void *buf, size_t len)
{
	if (!len)
		return;

	/*
	 * This function will dump the specified message directly
	 * to the underlying session, without waiting for success
	 * of non-blocking events etc. This is useful to print an
	 * error message before gracefully closing the session.
	 */
	if (cre->tls != NULL)
		(void)tls_write(cre->tls, buf, len);
	else
		(void)write(cre->s, buf, len);
}

void
relay_read(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = arg;
	struct rsession		*con = cre->con;
	struct protocol		*proto = con->se_relay->rl_proto;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);

	getmonotime(&con->se_tv_last);
	cre->timedout = 0;

	if (!EVBUFFER_LENGTH(src))
		return;
	if (relay_bufferevent_write_buffer(cre->dst, src) == -1)
		goto fail;
	if (con->se_done)
		goto done;
	if (cre->dst->bev)
		bufferevent_enable(cre->dst->bev, EV_READ);
	if (cre->dst->bev && EVBUFFER_LENGTH(EVBUFFER_OUTPUT(cre->dst->bev)) >
	    (size_t)RELAY_MAX_PREFETCH * proto->tcpbufsiz)
		bufferevent_disable(bev, EV_READ);

	return;
 done:
	relay_close(con, "last read (done)");
	return;
 fail:
	relay_close(con, strerror(errno));
}

/*
 * Splice sockets from cre to cre->dst if applicable.  Returns:
 * -1 socket splicing has failed
 * 0 socket splicing is currently not possible
 * 1 socket splicing was successful
 */
int
relay_splice(struct ctl_relay_event *cre)
{
	struct rsession		*con = cre->con;
	struct relay		*rlay = con->se_relay;
	struct protocol		*proto = rlay->rl_proto;
	struct splice		 sp;

	if ((rlay->rl_conf.flags & (F_TLS|F_TLSCLIENT)) ||
	    (proto->tcpflags & TCPFLAG_NSPLICE))
		return (0);

	if (cre->splicelen >= 0)
		return (0);

	/* still not connected */
	if (cre->bev == NULL || cre->dst->bev == NULL)
		return (0);

	if (!(cre->toread == TOREAD_UNLIMITED || cre->toread > 0)) {
		DPRINTF("%s: session %d: splice dir %d, nothing to read %lld",
		    __func__, con->se_id, cre->dir, cre->toread);
		return (0);
	}

	/* do not splice before buffers have not been completely flushed */
	if (EVBUFFER_LENGTH(cre->bev->input) ||
	    EVBUFFER_LENGTH(cre->dst->bev->output)) {
		DPRINTF("%s: session %d: splice dir %d, dirty buffer",
		    __func__, con->se_id, cre->dir);
		bufferevent_disable(cre->bev, EV_READ);
		return (0);
	}

	bzero(&sp, sizeof(sp));
	sp.sp_fd = cre->dst->s;
	sp.sp_max = cre->toread > 0 ? cre->toread : 0;
	bcopy(&rlay->rl_conf.timeout, &sp.sp_idle, sizeof(sp.sp_idle));
	if (setsockopt(cre->s, SOL_SOCKET, SO_SPLICE, &sp, sizeof(sp)) == -1) {
		log_debug("%s: session %d: splice dir %d failed: %s",
		    __func__, con->se_id, cre->dir, strerror(errno));
		return (-1);
	}
	cre->splicelen = 0;
	bufferevent_enable(cre->bev, EV_READ);

	DPRINTF("%s: session %d: splice dir %d, maximum %lld, successful",
	    __func__, con->se_id, cre->dir, cre->toread);

	return (1);
}

int
relay_splicelen(struct ctl_relay_event *cre)
{
	struct rsession		*con = cre->con;
	off_t			 len;
	socklen_t		 optlen;

	if (cre->splicelen < 0)
		return (0);

	optlen = sizeof(len);
	if (getsockopt(cre->s, SOL_SOCKET, SO_SPLICE, &len, &optlen) == -1) {
		log_debug("%s: session %d: splice dir %d get length failed: %s",
		    __func__, con->se_id, cre->dir, strerror(errno));
		return (-1);
	}

	DPRINTF("%s: session %d: splice dir %d, length %lld",
	    __func__, con->se_id, cre->dir, len);

	if (len > cre->splicelen) {
		getmonotime(&con->se_tv_last);

		cre->splicelen = len;
		return (1);
	}

	return (0);
}

int
relay_spliceadjust(struct ctl_relay_event *cre)
{
	if (cre->splicelen < 0)
		return (0);
	if (relay_splicelen(cre) == -1)
		return (-1);
	if (cre->splicelen > 0 && cre->toread > 0)
		cre->toread -= cre->splicelen;
	cre->splicelen = -1;

	return (0);
}

void
relay_error(struct bufferevent *bev, short error, void *arg)
{
	struct ctl_relay_event	*cre = arg;
	struct rsession		*con = cre->con;
	struct evbuffer		*dst;

	if (error & EVBUFFER_TIMEOUT) {
		if (cre->splicelen >= 0) {
			bufferevent_enable(bev, EV_READ);
		} else if (cre->dst->splicelen >= 0) {
			switch (relay_splicelen(cre->dst)) {
			case -1:
				goto fail;
			case 0:
				relay_close(con, "buffer event timeout");
				break;
			case 1:
				cre->timedout = 1;
				bufferevent_enable(bev, EV_READ);
				break;
			}
		} else {
			relay_close(con, "buffer event timeout");
		}
		return;
	}
	if (error & EVBUFFER_ERROR && errno == ETIMEDOUT) {
		if (cre->dst->splicelen >= 0) {
			switch (relay_splicelen(cre->dst)) {
			case -1:
				goto fail;
			case 0:
				relay_close(con, "splice timeout");
				return;
			case 1:
				bufferevent_enable(bev, EV_READ);
				break;
			}
		} else if (cre->dst->timedout) {
			relay_close(con, "splice timeout");
			return;
		}
		if (relay_spliceadjust(cre) == -1)
			goto fail;
		if (relay_splice(cre) == -1)
			goto fail;
		return;
	}
	if (error & EVBUFFER_ERROR && errno == EFBIG) {
		if (relay_spliceadjust(cre) == -1)
			goto fail;
		bufferevent_enable(cre->bev, EV_READ);
		return;
	}
	if (error & (EVBUFFER_READ|EVBUFFER_WRITE|EVBUFFER_EOF)) {
		bufferevent_disable(bev, EV_READ|EV_WRITE);

		con->se_done = 1;
		if (cre->dst->bev != NULL) {
			dst = EVBUFFER_OUTPUT(cre->dst->bev);
			if (EVBUFFER_LENGTH(dst))
				return;
		} else if (cre->toread == TOREAD_UNLIMITED || cre->toread == 0)
			return;

		relay_close(con, "done");
		return;
	}
	relay_close(con, "buffer event error");
	return;
 fail:
	relay_close(con, strerror(errno));
}

void
relay_accept(int fd, short event, void *arg)
{
	struct privsep		*ps = env->sc_ps;
	struct relay		*rlay = arg;
	struct rsession		*con = NULL;
	struct ctl_natlook	*cnl = NULL;
	socklen_t		 slen;
	struct timeval		 tv;
	struct sockaddr_storage	 ss;
	int			 s = -1;

	event_add(&rlay->rl_ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	slen = sizeof(ss);
	if ((s = accept_reserve(fd, (struct sockaddr *)&ss,
	    &slen, FD_RESERVE, &relay_inflight)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&rlay->rl_ev);
			evtimer_add(&rlay->rl_evt, &evtpause);
			log_debug("%s: deferring connections", __func__);
		}
		return;
	}
	if (relay_sessions >= RELAY_MAX_SESSIONS ||
	    rlay->rl_conf.flags & F_DISABLE)
		goto err;

	if ((con = calloc(1, sizeof(*con))) == NULL)
		goto err;

	/* Pre-allocate log buffer */
	con->se_haslog = 0;
	con->se_log = evbuffer_new();
	if (con->se_log == NULL)
		goto err;

	con->se_in.s = s;
	con->se_in.tls = NULL;
	con->se_out.s = -1;
	con->se_out.tls = NULL;
	con->se_in.dst = &con->se_out;
	con->se_out.dst = &con->se_in;
	con->se_in.con = con;
	con->se_out.con = con;
	con->se_in.splicelen = -1;
	con->se_out.splicelen = -1;
	con->se_in.toread = TOREAD_UNLIMITED;
	con->se_out.toread = TOREAD_UNLIMITED;
	con->se_relay = rlay;
	con->se_id = ++relay_conid;
	con->se_relayid = rlay->rl_conf.id;
	con->se_pid = getpid();
	con->se_in.dir = RELAY_DIR_REQUEST;
	con->se_out.dir = RELAY_DIR_RESPONSE;
	con->se_retry = rlay->rl_conf.dstretry;
	con->se_bnds = -1;
	con->se_out.port = rlay->rl_conf.dstport;
	switch (ss.ss_family) {
	case AF_INET:
		con->se_in.port = ((struct sockaddr_in *)&ss)->sin_port;
		break;
	case AF_INET6:
		con->se_in.port = ((struct sockaddr_in6 *)&ss)->sin6_port;
		break;
	}
	bcopy(&ss, &con->se_in.ss, sizeof(con->se_in.ss));

	getmonotime(&con->se_tv_start);
	bcopy(&con->se_tv_start, &con->se_tv_last, sizeof(con->se_tv_last));

	if (rlay->rl_conf.flags & F_HASHKEY) {
		SipHash24_Init(&con->se_siphashctx,
		    &rlay->rl_conf.hashkey.siphashkey);
	}

	relay_sessions++;
	SPLAY_INSERT(session_tree, &rlay->rl_sessions, con);
	relay_session_publish(con);

	/* Increment the per-relay session counter */
	rlay->rl_stats[ps->ps_instance].last++;

	/* Pre-allocate output buffer */
	con->se_out.output = evbuffer_new();
	if (con->se_out.output == NULL) {
		relay_close(con, "failed to allocate output buffer");
		return;
	}

	if (rlay->rl_conf.flags & F_DIVERT) {
		slen = sizeof(con->se_out.ss);
		if (getsockname(s, (struct sockaddr *)&con->se_out.ss,
		    &slen) == -1) {
			relay_close(con, "peer lookup failed");
			return;
		}
		con->se_out.port = relay_socket_getport(&con->se_out.ss);

		/* Detect loop and fall back to the alternate forward target */
		if (bcmp(&rlay->rl_conf.ss, &con->se_out.ss,
		    sizeof(con->se_out.ss)) == 0 &&
		    con->se_out.port == rlay->rl_conf.port)
			con->se_out.ss.ss_family = AF_UNSPEC;
	} else if (rlay->rl_conf.flags & F_NATLOOK) {
		if ((cnl = calloc(1, sizeof(*cnl))) == NULL) {
			relay_close(con, "failed to allocate nat lookup");
			return;
		}

		con->se_cnl = cnl;
		bzero(cnl, sizeof(*cnl));
		cnl->in = -1;
		cnl->id = con->se_id;
		cnl->proc = ps->ps_instance;
		cnl->proto = IPPROTO_TCP;

		bcopy(&con->se_in.ss, &cnl->src, sizeof(cnl->src));
		slen = sizeof(cnl->dst);
		if (getsockname(s,
		    (struct sockaddr *)&cnl->dst, &slen) == -1) {
			relay_close(con, "failed to get local address");
			return;
		}

		proc_compose(env->sc_ps, PROC_PFE, IMSG_NATLOOK,
		    cnl, sizeof(*cnl));

		/* Schedule timeout */
		evtimer_set(&con->se_ev, relay_natlook, con);
		bcopy(&rlay->rl_conf.timeout, &tv, sizeof(tv));
		evtimer_add(&con->se_ev, &tv);
		return;
	}

	if (rlay->rl_conf.flags & F_TLSINSPECT) {
		relay_preconnect(con);
		return;
	}

	relay_session(con);
	return;
 err:
	if (s != -1) {
		close(s);
		free(con);
		/*
		 * the session struct was not completely set up, but still
		 * counted as an inflight session. account for this.
		 */
		relay_inflight--;
		log_debug("%s: inflight decremented, now %d",
		    __func__, relay_inflight);
	}
}

void
relay_hash_addr(SIPHASH_CTX *ctx, struct sockaddr_storage *ss, int portset)
{
	struct sockaddr_in	*sin4;
	struct sockaddr_in6	*sin6;
	in_port_t		 port;

	if (ss->ss_family == AF_INET) {
		sin4 = (struct sockaddr_in *)ss;
		SipHash24_Update(ctx, &sin4->sin_addr,
		    sizeof(struct in_addr));
	} else {
		sin6 = (struct sockaddr_in6 *)ss;
		SipHash24_Update(ctx, &sin6->sin6_addr,
		    sizeof(struct in6_addr));
	}

	if (portset != -1) {
		port = (in_port_t)portset;
		SipHash24_Update(ctx, &port, sizeof(port));
	}
}

int
relay_from_table(struct rsession *con)
{
	struct relay		*rlay = con->se_relay;
	struct host		*host = NULL;
	struct relay_table	*rlt = NULL;
	struct table		*table = NULL;
	int			 idx = -1;
	int			 cnt = 0;
	int			 maxtries;
	u_int64_t		 p = 0;

	/* the table is already selected */
	if (con->se_table != NULL) {
		rlt = con->se_table;
		table = rlt->rlt_table;
		if (table->conf.check && !table->up)
			table = NULL;
		goto gottable;
	}

	/* otherwise grep the first active table */
	TAILQ_FOREACH(rlt, &rlay->rl_tables, rlt_entry) {
		table = rlt->rlt_table;
		if ((rlt->rlt_flags & F_USED) == 0 ||
		    (table->conf.check && !table->up))
			table = NULL;
		else
			break;
	}

 gottable:
	if (table == NULL) {
		log_debug("%s: session %d: no active hosts",
		    __func__, con->se_id);
		return (-1);
	}

	switch (rlt->rlt_mode) {
	case RELAY_DSTMODE_ROUNDROBIN:
		if ((int)rlt->rlt_index >= rlt->rlt_nhosts)
			rlt->rlt_index = 0;
		idx = (int)rlt->rlt_index;
		break;
	case RELAY_DSTMODE_RANDOM:
		idx = (int)arc4random_uniform(rlt->rlt_nhosts);
		break;
	case RELAY_DSTMODE_SRCHASH:
		/* Source IP address without port */
		relay_hash_addr(&con->se_siphashctx, &con->se_in.ss, -1);
		break;
	case RELAY_DSTMODE_LOADBALANCE:
		/* Source IP address without port */
		relay_hash_addr(&con->se_siphashctx, &con->se_in.ss, -1);
		/* FALLTHROUGH */
	case RELAY_DSTMODE_HASH:
		/* Local "destination" IP address and port */
		relay_hash_addr(&con->se_siphashctx, &rlay->rl_conf.ss,
		    rlay->rl_conf.port);
		break;
	default:
		fatalx("relay_from_table: unsupported mode");
		/* NOTREACHED */
	}
	if (idx == -1) {
		/* handle all hashing algorithms */
		p = SipHash24_End(&con->se_siphashctx);

		/* Reset hash context */
		SipHash24_Init(&con->se_siphashctx,
		    &rlay->rl_conf.hashkey.siphashkey);

		maxtries = (rlt->rlt_nhosts < RELAY_MAX_HASH_RETRIES ?
		    rlt->rlt_nhosts : RELAY_MAX_HASH_RETRIES);
		for (cnt = 0; cnt < maxtries; cnt++) {
			if ((idx = p % rlt->rlt_nhosts) >= RELAY_MAXHOSTS)
				return (-1);

			host = rlt->rlt_host[idx];

			DPRINTF("%s: session %d: table %s host %s, "
			    "p 0x%016llx, idx %d, cnt %d, max %d",
			    __func__, con->se_id, table->conf.name,
			    host->conf.name, p, idx, cnt, maxtries);

			if (!table->conf.check || host->up == HOST_UP)
				goto found;
			p = p >> 1;
		}
	} else {
		/* handle all non-hashing algorithms */
		host = rlt->rlt_host[idx];
		DPRINTF("%s: session %d: table %s host %s, p 0x%016llx, idx %d",
		    __func__, con->se_id, table->conf.name, host->conf.name,
		    p, idx);
	}

	while (host != NULL) {
		DPRINTF("%s: session %d: host %s", __func__,
		    con->se_id, host->conf.name);
		if (!table->conf.check || host->up == HOST_UP)
			goto found;
		host = TAILQ_NEXT(host, entry);
	}
	TAILQ_FOREACH(host, &table->hosts, entry) {
		DPRINTF("%s: session %d: next host %s",
		    __func__, con->se_id, host->conf.name);
		if (!table->conf.check || host->up == HOST_UP)
			goto found;
	}

	/* Should not happen */
	fatalx("relay_from_table: no active hosts, desynchronized");

 found:
	if (rlt->rlt_mode == RELAY_DSTMODE_ROUNDROBIN)
		rlt->rlt_index = host->idx + 1;
	con->se_retry = host->conf.retry;
	con->se_out.port = table->conf.port;
	bcopy(&host->conf.ss, &con->se_out.ss, sizeof(con->se_out.ss));

	return (0);
}

void
relay_natlook(int fd, short event, void *arg)
{
	struct rsession		*con = arg;
	struct relay		*rlay = con->se_relay;
	struct ctl_natlook	*cnl = con->se_cnl;

	if (cnl == NULL)
		fatalx("invalid NAT lookup");

	if (con->se_out.ss.ss_family == AF_UNSPEC && cnl->in == -1 &&
	    rlay->rl_conf.dstss.ss_family == AF_UNSPEC &&
	    TAILQ_EMPTY(&rlay->rl_tables)) {
		relay_close(con, "session NAT lookup failed");
		return;
	}
	if (cnl->in != -1) {
		bcopy(&cnl->rdst, &con->se_out.ss, sizeof(con->se_out.ss));
		con->se_out.port = cnl->rdport;
	}
	free(con->se_cnl);
	con->se_cnl = NULL;

	relay_session(con);
}

void
relay_session(struct rsession *con)
{
	struct relay		*rlay = con->se_relay;
	struct ctl_relay_event	*in = &con->se_in, *out = &con->se_out;

	if (bcmp(&rlay->rl_conf.ss, &out->ss, sizeof(out->ss)) == 0 &&
	    out->port == rlay->rl_conf.port) {
		log_debug("%s: session %d: looping", __func__, con->se_id);
		relay_close(con, "session aborted");
		return;
	}

	if (rlay->rl_conf.flags & F_UDP) {
		/*
		 * Call the UDP protocol-specific handler
		 */
		if (rlay->rl_proto->request == NULL)
			fatalx("invalide UDP session");
		if ((*rlay->rl_proto->request)(con) == -1)
			relay_close(con, "session failed");
		return;
	}

	if ((rlay->rl_conf.flags & F_TLS) && (in->tls == NULL)) {
		relay_tls_transaction(con, in);
		return;
	}

	if (rlay->rl_proto->type != RELAY_PROTO_HTTP) {
		if (rlay->rl_conf.fwdmode == FWD_TRANS)
			relay_bindanyreq(con, 0, IPPROTO_TCP);
		else if (relay_connect(con) == -1) {
			relay_close(con, "session failed");
			return;
		}
	}

	relay_input(con);
}

void
relay_bindanyreq(struct rsession *con, in_port_t port, int proto)
{
	struct privsep		*ps = env->sc_ps;
	struct relay		*rlay = con->se_relay;
	struct ctl_bindany	 bnd;
	struct timeval		 tv;

	bzero(&bnd, sizeof(bnd));
	bnd.bnd_id = con->se_id;
	bnd.bnd_proc = ps->ps_instance;
	bnd.bnd_port = port;
	bnd.bnd_proto = proto;
	bcopy(&con->se_in.ss, &bnd.bnd_ss, sizeof(bnd.bnd_ss));
	proc_compose(env->sc_ps, PROC_PARENT, IMSG_BINDANY,
	    &bnd, sizeof(bnd));

	/* Schedule timeout */
	evtimer_set(&con->se_ev, relay_bindany, con);
	bcopy(&rlay->rl_conf.timeout, &tv, sizeof(tv));
	evtimer_add(&con->se_ev, &tv);
}

void
relay_bindany(int fd, short event, void *arg)
{
	struct rsession	*con = arg;

	if (con->se_bnds == -1) {
		relay_close(con, "bindany failed, invalid socket");
		return;
	}
	if (relay_connect(con) == -1)
		relay_close(con, "session failed");
}

void
relay_connect_retry(int fd, short sig, void *arg)
{
	struct timeval	 evtpause = { 1, 0 };
	struct rsession	*con = arg;
	struct relay	*rlay = con->se_relay;
	int		 bnds = -1;

	if (relay_inflight < 1) {
		log_warnx("relay_connect_retry: no connection in flight");
		relay_inflight = 1;
	}

	DPRINTF("%s: retry %d of %d, inflight: %d",__func__,
	    con->se_retrycount, con->se_retry, relay_inflight);

	if (sig != EV_TIMEOUT)
		fatalx("relay_connect_retry: called without timeout");

	evtimer_del(&con->se_inflightevt);

	/*
	 * XXX we might want to check if the inbound socket is still
	 * available: client could have closed it while we were waiting?
	 */

	DPRINTF("%s: got EV_TIMEOUT", __func__);

	if (getdtablecount() + FD_RESERVE +
	    relay_inflight > getdtablesize()) {
		if (con->se_retrycount < RELAY_OUTOF_FD_RETRIES) {
			evtimer_add(&con->se_inflightevt, &evtpause);
			return;
		}
		/* we waited for RELAY_OUTOF_FD_RETRIES seconds, give up */
		event_add(&rlay->rl_ev, NULL);
		relay_abort_http(con, 504, "connection timed out", 0);
		return;
	}

	if (rlay->rl_conf.fwdmode == FWD_TRANS) {
		/* con->se_bnds cannot be unset */
		bnds = con->se_bnds;
	}

 retry:
	if ((con->se_out.s = relay_socket_connect(&con->se_out.ss,
	    con->se_out.port, rlay->rl_proto, bnds)) == -1) {
		log_debug("%s: session %d: "
		    "forward failed: %s, %s", __func__,
		    con->se_id, strerror(errno),
		    con->se_retry ? "next retry" : "last retry");

		con->se_retrycount++;

		if ((errno == ENFILE || errno == EMFILE) &&
		    (con->se_retrycount < con->se_retry)) {
			event_del(&rlay->rl_ev);
			evtimer_add(&con->se_inflightevt, &evtpause);
			evtimer_add(&rlay->rl_evt, &evtpause);
			return;
		} else if (con->se_retrycount < con->se_retry)
			goto retry;
		event_add(&rlay->rl_ev, NULL);
		relay_abort_http(con, 504, "connect failed", 0);
		return;
	}

	if (rlay->rl_conf.flags & F_TLSINSPECT)
		con->se_out.state = STATE_PRECONNECT;
	else
		con->se_out.state = STATE_CONNECTED;
	relay_inflight--;
	DPRINTF("%s: inflight decremented, now %d",__func__, relay_inflight);

	event_add(&rlay->rl_ev, NULL);

	if (errno == EINPROGRESS)
		event_again(&con->se_ev, con->se_out.s, EV_WRITE|EV_TIMEOUT,
		    relay_connected, &con->se_tv_start, &rlay->rl_conf.timeout,
		    con);
	else
		relay_connected(con->se_out.s, EV_WRITE, con);

	return;
}

int
relay_preconnect(struct rsession *con)
{
	int rv;

	log_debug("%s: session %d: process %d", __func__,
	    con->se_id, privsep_process);
	rv = relay_connect(con);
	if (con->se_out.state == STATE_CONNECTED)
		con->se_out.state = STATE_PRECONNECT;
	return (rv);
}

int
relay_connect(struct rsession *con)
{
	struct relay	*rlay = con->se_relay;
	struct timeval	 evtpause = { 1, 0 };
	int		 bnds = -1, ret;

	/* relay_connect should only be called once per relay */
	if (con->se_out.state == STATE_CONNECTED) {
		log_debug("%s: connect already called once", __func__);
		return (0);
	}

	/* Connection is already established but session not active */
	if ((rlay->rl_conf.flags & F_TLSINSPECT) &&
	    con->se_out.state == STATE_PRECONNECT) {
		if (con->se_out.tls == NULL) {
			log_debug("%s: tls connect failed", __func__);
			return (-1);
		}
		relay_connected(con->se_out.s, EV_WRITE, con);
		con->se_out.state = STATE_CONNECTED;
		return (0);
	}

	if (relay_inflight < 1) {
		log_warnx("relay_connect: no connection in flight");
		relay_inflight = 1;
	}

	getmonotime(&con->se_tv_start);

	if (!TAILQ_EMPTY(&rlay->rl_tables)) {
		if (relay_from_table(con) != 0)
			return (-1);
	} else if (con->se_out.ss.ss_family == AF_UNSPEC) {
		bcopy(&rlay->rl_conf.dstss, &con->se_out.ss,
		    sizeof(con->se_out.ss));
		con->se_out.port = rlay->rl_conf.dstport;
	}

	if (rlay->rl_conf.fwdmode == FWD_TRANS) {
		if (con->se_bnds == -1) {
			log_debug("%s: could not bind any sock", __func__);
			return (-1);
		}
		bnds = con->se_bnds;
	}

	/* Do the IPv4-to-IPv6 or IPv6-to-IPv4 translation if requested */
	if (rlay->rl_conf.dstaf.ss_family != AF_UNSPEC) {
		if (con->se_out.ss.ss_family == AF_INET &&
		    rlay->rl_conf.dstaf.ss_family == AF_INET6)
			ret = map4to6(&con->se_out.ss, &rlay->rl_conf.dstaf);
		else if (con->se_out.ss.ss_family == AF_INET6 &&
		    rlay->rl_conf.dstaf.ss_family == AF_INET)
			ret = map6to4(&con->se_out.ss);
		else
			ret = 0;
		if (ret != 0) {
			log_debug("%s: mapped to invalid address", __func__);
			return (-1);
		}
	}

 retry:
	if ((con->se_out.s = relay_socket_connect(&con->se_out.ss,
	    con->se_out.port, rlay->rl_proto, bnds)) == -1) {
		if (errno == ENFILE || errno == EMFILE) {
			log_debug("%s: session %d: forward failed: %s",
			    __func__, con->se_id, strerror(errno));
			evtimer_set(&con->se_inflightevt, relay_connect_retry,
			    con);
			event_del(&rlay->rl_ev);
			evtimer_add(&con->se_inflightevt, &evtpause);
			evtimer_add(&rlay->rl_evt, &evtpause);

			/* this connect is pending */
			con->se_out.state = STATE_PENDING;
			return (0);
		} else {
			if (con->se_retry) {
				con->se_retry--;
				log_debug("%s: session %d: "
				    "forward failed: %s, %s", __func__,
				    con->se_id, strerror(errno),
				    con->se_retry ?
				    "next retry" : "last retry");
				goto retry;
			}
			log_debug("%s: session %d: forward failed: %s",
			    __func__, con->se_id, strerror(errno));
			return (-1);
		}
	}

	con->se_out.state = STATE_CONNECTED;
	relay_inflight--;
	DPRINTF("%s: inflight decremented, now %d",__func__,
	    relay_inflight);

	if (errno == EINPROGRESS)
		event_again(&con->se_ev, con->se_out.s, EV_WRITE|EV_TIMEOUT,
		    relay_connected, &con->se_tv_start, &rlay->rl_conf.timeout,
		    con);
	else
		relay_connected(con->se_out.s, EV_WRITE, con);

	return (0);
}

void
relay_close(struct rsession *con, const char *msg)
{
	char		 ibuf[128], obuf[128], *ptr = NULL;
	struct relay	*rlay = con->se_relay;
	struct protocol	*proto = rlay->rl_proto;

	SPLAY_REMOVE(session_tree, &rlay->rl_sessions, con);
	relay_session_unpublish(con);

	event_del(&con->se_ev);
	if (con->se_in.bev != NULL)
		bufferevent_disable(con->se_in.bev, EV_READ|EV_WRITE);
	if (con->se_out.bev != NULL)
		bufferevent_disable(con->se_out.bev, EV_READ|EV_WRITE);

	if ((env->sc_conf.opts & RELAYD_OPT_LOGUPDATE) && msg != NULL) {
		bzero(&ibuf, sizeof(ibuf));
		bzero(&obuf, sizeof(obuf));
		(void)print_host(&con->se_in.ss, ibuf, sizeof(ibuf));
		(void)print_host(&con->se_out.ss, obuf, sizeof(obuf));
		if (EVBUFFER_LENGTH(con->se_log) &&
		    evbuffer_add_printf(con->se_log, "\r\n") != -1)
			ptr = evbuffer_readline(con->se_log);
		log_info("relay %s, "
		    "session %d (%d active), %s, %s -> %s:%d, "
		    "%s%s%s", rlay->rl_conf.name, con->se_id, relay_sessions,
		    con->se_tag != 0 ? tag_id2name(con->se_tag) : "0", ibuf,
		    obuf, ntohs(con->se_out.port), msg, ptr == NULL ? "" : ",",
		    ptr == NULL ? "" : ptr);
		free(ptr);
	}

	if (proto->close != NULL)
		(*proto->close)(con);

	free(con->se_priv);
	if (con->se_in.bev != NULL)
		bufferevent_free(con->se_in.bev);
	else if (con->se_in.output != NULL)
		evbuffer_free(con->se_in.output);
	if (con->se_in.tls != NULL)
		tls_close(con->se_in.tls);
	tls_free(con->se_in.tls);
	tls_config_free(con->se_in.tls_cfg);
	free(con->se_in.tlscert);
	if (con->se_in.s != -1) {
		close(con->se_in.s);
		if (con->se_out.s == -1) {
			/*
			 * the output was never connected,
			 * thus this was an inflight session.
			 */
			relay_inflight--;
			log_debug("%s: sessions inflight decremented, now %d",
			    __func__, relay_inflight);
		}
	}

	if (con->se_out.bev != NULL)
		bufferevent_free(con->se_out.bev);
	else if (con->se_out.output != NULL)
		evbuffer_free(con->se_out.output);
	if (con->se_out.tls != NULL)
		tls_close(con->se_out.tls);
	tls_free(con->se_out.tls);
	tls_config_free(con->se_out.tls_cfg);
	free(con->se_out.tlscert);
	if (con->se_out.s != -1) {
		close(con->se_out.s);

		/* Some file descriptors are available again. */
		if (evtimer_pending(&rlay->rl_evt, NULL)) {
			evtimer_del(&rlay->rl_evt);
			event_add(&rlay->rl_ev, NULL);
		}
	}
	con->se_out.state = STATE_INIT;

	if (con->se_log != NULL)
		evbuffer_free(con->se_log);

	if (con->se_cnl != NULL) {
#if 0
		proc_compose_imsg(env->sc_ps, PROC_PFE, -1, IMSG_KILLSTATES, -1,
		    cnl, sizeof(*cnl));
#endif
		free(con->se_cnl);
	}

	free(con);
	relay_sessions--;
}

int
relay_dispatch_pfe(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct relay		*rlay;
	struct rsession		*con, se;
	struct ctl_natlook	 cnl;
	struct timeval		 tv;
	struct host		*host;
	struct table		*table;
	struct ctl_status	 st;
	objid_t			 id;
	int			 cid;

	switch (imsg->hdr.type) {
	case IMSG_HOST_DISABLE:
		memcpy(&id, imsg->data, sizeof(id));
		if ((host = host_find(env, id)) == NULL)
			fatalx("relay_dispatch_pfe: desynchronized");
		if ((table = table_find(env, host->conf.tableid)) ==
		    NULL)
			fatalx("relay_dispatch_pfe: invalid table id");
		if (host->up == HOST_UP)
			table->up--;
		host->flags |= F_DISABLE;
		host->up = HOST_UNKNOWN;
		break;
	case IMSG_HOST_ENABLE:
		memcpy(&id, imsg->data, sizeof(id));
		if ((host = host_find(env, id)) == NULL)
			fatalx("relay_dispatch_pfe: desynchronized");
		host->flags &= ~(F_DISABLE);
		host->up = HOST_UNKNOWN;
		break;
	case IMSG_TABLE_DISABLE:
		memcpy(&id, imsg->data, sizeof(id));
		if ((table = table_find(env, id)) == NULL)
			fatalx("relay_dispatch_pfe: desynchronized");
		table->conf.flags |= F_DISABLE;
		table->up = 0;
		TAILQ_FOREACH(host, &table->hosts, entry)
			host->up = HOST_UNKNOWN;
		break;
	case IMSG_TABLE_ENABLE:
		memcpy(&id, imsg->data, sizeof(id));
		if ((table = table_find(env, id)) == NULL)
			fatalx("relay_dispatch_pfe: desynchronized");
		table->conf.flags &= ~(F_DISABLE);
		table->up = 0;
		TAILQ_FOREACH(host, &table->hosts, entry)
			host->up = HOST_UNKNOWN;
		break;
	case IMSG_HOST_STATUS:
		IMSG_SIZE_CHECK(imsg, &st);
		memcpy(&st, imsg->data, sizeof(st));
		if ((host = host_find(env, st.id)) == NULL)
			fatalx("relay_dispatch_pfe: invalid host id");
		if (host->flags & F_DISABLE)
			break;
		if (host->up == st.up) {
			log_debug("%s: host %d => %d", __func__,
			    host->conf.id, host->up);
			fatalx("relay_dispatch_pfe: desynchronized");
		}

		if ((table = table_find(env, host->conf.tableid))
		    == NULL)
			fatalx("relay_dispatch_pfe: invalid table id");

		DPRINTF("%s: [%d] state %d for "
		    "host %u %s", __func__, p->p_ps->ps_instance, st.up,
		    host->conf.id, host->conf.name);

		if ((st.up == HOST_UNKNOWN && host->up == HOST_DOWN) ||
		    (st.up == HOST_DOWN && host->up == HOST_UNKNOWN)) {
			host->up = st.up;
			break;
		}
		if (st.up == HOST_UP)
			table->up++;
		else
			table->up--;
		host->up = st.up;
		break;
	case IMSG_NATLOOK:
		bcopy(imsg->data, &cnl, sizeof(cnl));
		if ((con = session_find(env, cnl.id)) == NULL ||
		    con->se_cnl == NULL) {
			log_debug("%s: session %d: expired",
			    __func__, cnl.id);
			break;
		}
		bcopy(&cnl, con->se_cnl, sizeof(*con->se_cnl));
		evtimer_del(&con->se_ev);
		evtimer_set(&con->se_ev, relay_natlook, con);
		bzero(&tv, sizeof(tv));
		evtimer_add(&con->se_ev, &tv);
		break;
	case IMSG_CTL_SESSION:
		IMSG_SIZE_CHECK(imsg, &cid);
		memcpy(&cid, imsg->data, sizeof(cid));
		TAILQ_FOREACH(rlay, env->sc_relays, rl_entry) {
			SPLAY_FOREACH(con, session_tree,
			    &rlay->rl_sessions) {
				memcpy(&se, con, sizeof(se));
				se.se_cid = cid;
				proc_compose(env->sc_ps, p->p_id,
				    IMSG_CTL_SESSION, &se, sizeof(se));
			}
		}
		proc_compose(env->sc_ps, p->p_id, IMSG_CTL_END,
		    &cid, sizeof(cid));
		break;
	default:
		return (-1);
	}

	return (0);
}

int
relay_dispatch_ca(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	return (-1);
}

int
relay_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct relay_ticket_key	 ticket;
	struct relay		*rlay;
	struct rsession		*con;
	struct timeval		 tv;
	objid_t			 id;

	switch (imsg->hdr.type) {
	case IMSG_BINDANY:
		bcopy(imsg->data, &id, sizeof(id));
		if ((con = session_find(env, id)) == NULL) {
			log_debug("%s: session %d: expired",
			    __func__, id);
			break;
		}

		/* Will validate the result later */
		con->se_bnds = imsg->fd;

		evtimer_del(&con->se_ev);
		evtimer_set(&con->se_ev, relay_bindany, con);
		bzero(&tv, sizeof(tv));
		evtimer_add(&con->se_ev, &tv);
		break;
	case IMSG_CFG_TABLE:
		config_gettable(env, imsg);
		break;
	case IMSG_CFG_HOST:
		config_gethost(env, imsg);
		break;
	case IMSG_CFG_PROTO:
		config_getproto(env, imsg);
		break;
	case IMSG_CFG_RULE:
		config_getrule(env, imsg);
		break;
	case IMSG_CFG_RELAY:
		config_getrelay(env, imsg);
		break;
	case IMSG_CFG_RELAY_TABLE:
		config_getrelaytable(env, imsg);
		break;
	case IMSG_CFG_DONE:
		config_getcfg(env, imsg);
		break;
	case IMSG_CTL_START:
		relay_launch();
		break;
	case IMSG_CTL_RESET:
		config_getreset(env, imsg);
		break;
	case IMSG_TLSTICKET_REKEY:
		IMSG_SIZE_CHECK(imsg, (&ticket));
		memcpy(&env->sc_ticket, imsg->data, sizeof(env->sc_ticket));
		TAILQ_FOREACH(rlay, env->sc_relays, rl_entry) {
			if (rlay->rl_conf.flags & F_TLS)
				tls_config_add_ticket_key(rlay->rl_tls_cfg,
				    env->sc_ticket.tt_keyrev,
				    env->sc_ticket.tt_key,
				    sizeof(env->sc_ticket.tt_key));
		}
		break;
	default:
		return (-1);
	}

	return (0);
}

int
relay_dispatch_hce(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	switch (imsg->hdr.type) {
	default:
		break;
	}

	return (-1);
}

static int
relay_tls_ctx_create_proto(struct protocol *proto, struct tls_config *tls_cfg)
{
	uint32_t		 protocols = 0;

	/* Set the allowed SSL protocols */
	if (proto->tlsflags & TLSFLAG_TLSV1_0)
		protocols |= TLS_PROTOCOL_TLSv1_0;
	if (proto->tlsflags & TLSFLAG_TLSV1_1)
		protocols |= TLS_PROTOCOL_TLSv1_1;
	if (proto->tlsflags & TLSFLAG_TLSV1_2)
		protocols |= TLS_PROTOCOL_TLSv1_2;
	if (tls_config_set_protocols(tls_cfg, protocols) == -1) {
		log_warnx("could not set the TLS protocol: %s",
		    tls_config_error(tls_cfg));
		return (-1);
	}

	if (tls_config_set_ciphers(tls_cfg, proto->tlsciphers)) {
		log_warnx("could not set the TLS cypers: %s",
		    tls_config_error(tls_cfg));
		return (-1);
	}

	if ((proto->tlsflags & TLSFLAG_CIPHER_SERVER_PREF) == 0)
		tls_config_prefer_ciphers_client(tls_cfg);

	/*
	 * Set session ID context to a random value. It needs to be the
	 * same accross all relay processes or session caching will fail.
	 */
	if (tls_config_set_session_id(tls_cfg, env->sc_conf.tls_sid,
	    sizeof(env->sc_conf.tls_sid)) == -1) {
		log_warnx("could not set the TLS session ID: %s",
		    tls_config_error(tls_cfg));
		return (-1);
	}

	/* Set callback for TLS session tickets if enabled */
	if (proto->tickets == 1) {
		/* set timeout to the ticket rekey time */
		tls_config_set_session_lifetime(tls_cfg, TLS_SESSION_LIFETIME);

		tls_config_add_ticket_key(tls_cfg,
		    env->sc_ticket.tt_keyrev, env->sc_ticket.tt_key,
		    sizeof(env->sc_ticket.tt_key));
	}

	if (tls_config_set_ecdhecurve(tls_cfg, proto->tlsecdhcurve) != 0) {
		log_warnx("failed to set ecdh curve %s: %s",
		    proto->tlsecdhcurve, tls_config_error(tls_cfg));
		return (-1);
	}

	if (tls_config_set_dheparams(tls_cfg, proto->tlsdhparams) != 0) {
		log_warnx("failed to set dh params %s: %s",
		    proto->tlsdhparams, tls_config_error(tls_cfg));
		return (-1);
	}

	return (0);
}

/*
 * This function is not publicy exported because it is a hack until libtls
 * has a proper privsep setup 
 */
void tls_config_skip_private_key_check(struct tls_config *config);

int
relay_tls_ctx_create(struct relay *rlay)
{
	struct tls_config	*tls_cfg, *tls_client_cfg;
	struct tls		*tls = NULL;
	const char		*fake_key;
	int			 fake_keylen;

	if ((tls_cfg = tls_config_new()) == NULL) {
		log_warnx("unable to allocate TLS config");
		return (-1);
	}
	if ((tls_client_cfg = tls_config_new()) == NULL) {
		log_warnx("unable to allocate TLS config");
		return (-1);
	}

	if (relay_tls_ctx_create_proto(rlay->rl_proto, tls_cfg) == -1)
		goto err;
	if (relay_tls_ctx_create_proto(rlay->rl_proto, tls_client_cfg) == -1)
		goto err;

	/* Verify the server certificate if we have a CA chain */
	if (rlay->rl_conf.flags & F_TLSCLIENT) {
		/*
		 * Currently relayd can't verify the name of certs and changing
		 * this is non trivial. For now just disable name verification.
		 */
		tls_config_insecure_noverifyname(tls_client_cfg);

		if (rlay->rl_tls_ca != NULL) {
			if (tls_config_set_ca_mem(tls_client_cfg,
			    rlay->rl_tls_ca, rlay->rl_conf.tls_ca_len) != 0) {
				log_warnx("failed to set root certificates: %s",
				    tls_config_error(tls_client_cfg));
				goto err;
			}
		} else {
			/* No root cert available so disable the checking */
			tls_config_insecure_noverifycert(tls_client_cfg);
		}

		rlay->rl_tls_client_cfg = tls_client_cfg;
	}

	if (rlay->rl_conf.flags & F_TLS) {
		log_debug("%s: loading certificate", __func__);
		/*
		 * Use the public key as the "private" key - the secret key
		 * parameters are hidden in an extra process that will be
		 * contacted by the RSA engine.  The SSL/TLS library needs at
		 * least the public key parameters in the current process.
		 * For this we need to skip the private key check done by
		 * libtls.
		 */
		tls_config_skip_private_key_check(tls_cfg);

		if ((fake_keylen = ssl_ctx_fake_private_key(rlay->rl_tls_cert,
		    rlay->rl_conf.tls_cert_len, &fake_key)) == -1) {
			/* error already printed */
			goto err;
		}

		if (tls_config_set_keypair_ocsp_mem(tls_cfg,
		    rlay->rl_tls_cert, rlay->rl_conf.tls_cert_len,
		    fake_key, fake_keylen, NULL, 0) != 0) {
			log_warnx("failed to set tls certificate: %s",
			    tls_config_error(tls_cfg));
			goto err;
		}

		if (rlay->rl_conf.tls_cacert_len) {
			log_debug("%s: loading CA certificate", __func__);
			if (!ssl_load_pkey(&rlay->rl_conf.tls_cakeyid,
			    rlay->rl_tls_cacert, rlay->rl_conf.tls_cacert_len,
			    &rlay->rl_tls_cacertx509, &rlay->rl_tls_capkey))
				goto err;
			/* loading certificate public key */
			if (!ssl_load_pkey(NULL,
			    rlay->rl_tls_cert, rlay->rl_conf.tls_cert_len,
			    NULL, &rlay->rl_tls_pkey))
				goto err;
		}

		tls = tls_server();
		if (tls == NULL) {
			log_warnx("unable to allocate TLS context");
			goto err;
		}
		if (tls_configure(tls, tls_cfg) == -1) {
			log_warnx("could not configure the TLS context: %s",
			    tls_error(tls));
			tls_free(tls);
			goto err;
		}
		rlay->rl_tls_cfg = tls_cfg;
		rlay->rl_tls_ctx = tls;
	}

	/* The text versions of the keys/certs are not needed anymore */
	purge_key(&rlay->rl_tls_cert, rlay->rl_conf.tls_cert_len);
	purge_key(&rlay->rl_tls_cacert, rlay->rl_conf.tls_cacert_len);

	if (rlay->rl_tls_client_cfg == NULL)
		tls_config_free(tls_client_cfg);
	if (rlay->rl_tls_cfg == NULL)
		tls_config_free(tls_cfg);

	return (0);
 err:
	tls_config_free(tls_client_cfg);
	tls_config_free(tls_cfg);
	return (-1);
}

static struct tls *
relay_tls_inspect_create(struct relay *rlay, struct ctl_relay_event *cre)
{
	struct tls_config	*tls_cfg;
	struct tls		*tls;
	const char		*fake_key;
	int			 fake_keylen;

	/* TLS inspection: use session-specific certificate */
	if ((tls_cfg = tls_config_new()) == NULL) {
		log_warnx("unable to allocate TLS config");
		goto err;
	}
	if (relay_tls_ctx_create_proto(rlay->rl_proto,
	    tls_cfg) == -1) {
		tls_config_free(tls_cfg);
		goto err;
	}

	log_debug("%s: loading intercepted certificate", __func__);
	if ((fake_keylen = ssl_ctx_fake_private_key(cre->tlscert,
	    cre->tlscert_len, &fake_key)) == -1) {
		/* error already printed */
		goto err;
	}
	if (tls_config_set_keypair_ocsp_mem(tls_cfg,
	    cre->tlscert, cre->tlscert_len, fake_key, fake_keylen,
	    NULL, 0) != 0) {
		log_warnx("failed to set tls certificate: %s",
		    tls_config_error(tls_cfg));
		goto err;
	}

	tls = tls_server();
	if (tls == NULL) {
		log_warnx("unable to allocate TLS context");
		goto err;
	}
	if (tls_configure(tls, tls_cfg) == -1) {
		log_warnx("could not configure the TLS context: %s",
		    tls_error(tls));
		tls_free(tls);
		goto err;
	}

	cre->tls_cfg = tls_cfg;
	return (tls);
 err:
	tls_config_free(tls_cfg);
	return (NULL);
}

void
relay_tls_transaction(struct rsession *con, struct ctl_relay_event *cre)
{
	struct relay		*rlay = con->se_relay;
	struct tls		*tls_server;
	const char		*errstr;
	u_int			 flag;

	if (cre->dir == RELAY_DIR_REQUEST) {
		if (cre->tlscert != NULL)
			tls_server = relay_tls_inspect_create(rlay, cre);
		else
			tls_server = rlay->rl_tls_ctx;

		if (tls_accept_socket(tls_server, &cre->tls, cre->s) == -1) {
			errstr = "could not accept the TLS connection";
			goto err;
		}
		if (cre->tlscert != NULL)
			tls_free(tls_server);
		flag = EV_READ;
	} else {
		cre->tls = tls_client();
		if (cre->tls == NULL ||
		    tls_configure(cre->tls, rlay->rl_tls_client_cfg) == -1) {
			errstr = "could not configure the TLS client context";
			goto err;
		}
		if (tls_connect_socket(cre->tls, cre->s, NULL) == -1) {
			errstr = "could not connect the TLS connection";
			goto err;
		}
		flag = EV_WRITE;
	}

	log_debug("%s: session %d: scheduling on %s", __func__, con->se_id,
	    (flag == EV_READ) ? "EV_READ" : "EV_WRITE");
	event_again(&con->se_ev, cre->s, EV_TIMEOUT|flag, relay_tls_handshake,
	    &con->se_tv_start, &rlay->rl_conf.timeout, cre);
	return;

 err:
	relay_close(con, errstr);
}

void
relay_tls_handshake(int fd, short event, void *arg)
{
	struct ctl_relay_event	*cre = arg;
	struct rsession		*con = cre->con;
	struct relay		*rlay = con->se_relay;
	int			 retry_flag = 0;
	int			 ret;

	if (event == EV_TIMEOUT) {
		relay_close(con, "TLS handshake timeout");
		return;
	}

	ret = tls_handshake(cre->tls);
	if (ret == 0) {
#ifdef DEBUG
		log_info(
#else
		log_debug(
#endif
		    "relay %s, tls session %d %s (%d active)",
		    rlay->rl_conf.name, con->se_id,
		    cre->dir == RELAY_DIR_REQUEST ? "established" : "connected",
		    relay_sessions);

		if (cre->dir == RELAY_DIR_REQUEST) {
			relay_session(con);
			return;
		}

		if (rlay->rl_conf.flags & F_TLSINSPECT) {
			const uint8_t	*servercert;
			size_t		 len;

			servercert = tls_peer_cert_chain_pem(con->se_out.tls,
			    &len);
			if (servercert != NULL) {
				con->se_in.tlscert = ssl_update_certificate(
				    servercert, len,
				    rlay->rl_tls_pkey, rlay->rl_tls_capkey,
				    rlay->rl_tls_cacertx509,
				    &con->se_in.tlscert_len);
			} else
				con->se_in.tlscert = NULL;
			if (con->se_in.tlscert == NULL)
				relay_close(con,
				    "could not create certificate");
			else
				relay_session(con);
			return;
		}
		relay_connected(fd, EV_WRITE, con);
		return;
	} else if (ret == TLS_WANT_POLLIN) {
		retry_flag = EV_READ;
	} else if (ret == TLS_WANT_POLLOUT) {
		retry_flag = EV_WRITE;
	} else {
		log_debug("TLS handshake failed: %s: %s: %s",
		    rlay->rl_conf.name, __func__,
		    tls_error(cre->tls));
		relay_close(con, "TLS handshake error");
		return;
	}

	DPRINTF("%s: session %d: scheduling on %s", __func__, con->se_id,
	    (retry_flag == EV_READ) ? "EV_READ" : "EV_WRITE");
	event_again(&con->se_ev, fd, EV_TIMEOUT|retry_flag, relay_tls_handshake,
	    &con->se_tv_start, &rlay->rl_conf.timeout, cre);
}

void
relay_tls_connected(struct ctl_relay_event *cre)
{
	/*
	 * Hack libevent - we overwrite the internal bufferevent I/O
	 * functions to handle the TLS abstraction.
	 */
	event_set(&cre->bev->ev_read, cre->s, EV_READ,
	    relay_tls_readcb, cre->bev);
	event_set(&cre->bev->ev_write, cre->s, EV_WRITE,
	    relay_tls_writecb, cre->bev);
}

void
relay_tls_readcb(int fd, short event, void *arg)
{
	char			 rbuf[IBUF_READ_SIZE];
	struct bufferevent	*bufev = arg;
	struct ctl_relay_event	*cre = bufev->cbarg;
	short			 what = EVBUFFER_READ;
	int			 howmuch = IBUF_READ_SIZE;
	ssize_t			 ret;
	size_t			 len;

	if (event == EV_TIMEOUT) {
		what |= EVBUFFER_TIMEOUT;
		goto err;
	}

	if (bufev->wm_read.high != 0)
		howmuch = MINIMUM(sizeof(rbuf), bufev->wm_read.high);

	ret = tls_read(cre->tls, rbuf, howmuch);
	if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT) {
		goto retry;
	} else if (ret < 0) {
		what |= EVBUFFER_ERROR;
		goto err;
	}
	len = ret;

	if (len == 0) {
		what |= EVBUFFER_EOF;
		goto err;
	}

	if (evbuffer_add(bufev->input, rbuf, ret) == -1) {
		what |= EVBUFFER_ERROR;
		goto err;
	}

	relay_bufferevent_add(&bufev->ev_read, bufev->timeout_read);

	len = EVBUFFER_LENGTH(bufev->input);
	if (bufev->wm_read.low != 0 && len < bufev->wm_read.low)
		return;
	if (bufev->wm_read.high != 0 && len > bufev->wm_read.high) {
		struct evbuffer *buf = bufev->input;
		event_del(&bufev->ev_read);
		evbuffer_setcb(buf, bufferevent_read_pressure_cb, bufev);
		return;
	}

	if (bufev->readcb != NULL)
		(*bufev->readcb)(bufev, bufev->cbarg);
	return;

 retry:
	relay_bufferevent_add(&bufev->ev_read, bufev->timeout_read);
	return;

 err:
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}

void
relay_tls_writecb(int fd, short event, void *arg)
{
	struct bufferevent	*bufev = arg;
	struct ctl_relay_event	*cre = bufev->cbarg;
	ssize_t			 ret;
	size_t			 len;
	short			 what = EVBUFFER_WRITE;

	if (event == EV_TIMEOUT) {
		what |= EVBUFFER_TIMEOUT;
		goto err;
	}

	if (EVBUFFER_LENGTH(bufev->output)) {
		ret = tls_write(cre->tls, EVBUFFER_DATA(bufev->output),
		    EVBUFFER_LENGTH(bufev->output));
		if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT) {
			goto retry;
		} else if (ret < 0) {
			what |= EVBUFFER_ERROR;
			goto err;
		}
		len = ret;
		evbuffer_drain(bufev->output, len);
	}

	if (EVBUFFER_LENGTH(bufev->output) != 0)
		relay_bufferevent_add(&bufev->ev_write, bufev->timeout_write);

	if (bufev->writecb != NULL &&
	    EVBUFFER_LENGTH(bufev->output) <= bufev->wm_write.low)
		(*bufev->writecb)(bufev, bufev->cbarg);
	return;

 retry:
	relay_bufferevent_add(&bufev->ev_write, bufev->timeout_write);
	return;

 err:
	(*bufev->errorcb)(bufev, what, bufev->cbarg);
}

int
relay_bufferevent_add(struct event *ev, int timeout)
{
	struct timeval tv, *ptv = NULL;

	if (timeout) {
		timerclear(&tv);
		tv.tv_sec = timeout;
		ptv = &tv;
	}

	return (event_add(ev, ptv));
}

#ifdef notyet
int
relay_bufferevent_printf(struct ctl_relay_event *cre, const char *fmt, ...)
{
	int	ret;
	va_list	ap;

	va_start(ap, fmt);
	ret = evbuffer_add_vprintf(cre->output, fmt, ap);
	va_end(ap);

	if (cre->bev != NULL &&
	    ret != -1 && EVBUFFER_LENGTH(cre->output) > 0 &&
	    (cre->bev->enabled & EV_WRITE))
		bufferevent_enable(cre->bev, EV_WRITE);

	return (ret);
}
#endif

int
relay_bufferevent_print(struct ctl_relay_event *cre, const char *str)
{
	if (cre->bev == NULL)
		return (evbuffer_add(cre->output, str, strlen(str)));
	return (bufferevent_write(cre->bev, str, strlen(str)));
}

int
relay_bufferevent_write_buffer(struct ctl_relay_event *cre,
    struct evbuffer *buf)
{
	if (cre->bev == NULL)
		return (evbuffer_add_buffer(cre->output, buf));
	return (bufferevent_write_buffer(cre->bev, buf));
}

int
relay_bufferevent_write_chunk(struct ctl_relay_event *cre,
    struct evbuffer *buf, size_t size)
{
	int ret;
	ret = relay_bufferevent_write(cre, buf->buffer, size);
	if (ret != -1)
		evbuffer_drain(buf, size);
	return (ret);
}

int
relay_bufferevent_write(struct ctl_relay_event *cre, void *data, size_t size)
{
	if (cre->bev == NULL)
		return (evbuffer_add(cre->output, data, size));
	return (bufferevent_write(cre->bev, data, size));
}

int
relay_cmp_af(struct sockaddr_storage *a, struct sockaddr_storage *b)
{
	int			ret = -1;
	struct sockaddr_in	ia, ib;
	struct sockaddr_in6	ia6, ib6;

	switch (a->ss_family) {
	case AF_INET:
		bcopy(a, &ia, sizeof(struct sockaddr_in));
		bcopy(b, &ib, sizeof(struct sockaddr_in));

		ret = memcmp(&ia.sin_addr, &ib.sin_addr,
		    sizeof(ia.sin_addr));
		if (ret == 0)
			ret = memcmp(&ia.sin_port, &ib.sin_port,
			    sizeof(ia.sin_port));
		break;
	case AF_INET6:
		bcopy(a, &ia6, sizeof(struct sockaddr_in6));
		bcopy(b, &ib6, sizeof(struct sockaddr_in6));

		ret = memcmp(&ia6.sin6_addr, &ib6.sin6_addr,
		    sizeof(ia6.sin6_addr));
		if (ret == 0)
			ret = memcmp(&ia6.sin6_port, &ib6.sin6_port,
			    sizeof(ia6.sin6_port));
		break;
	default:
		break;
	}

	return (ret);
}

char *
relay_load_file(const char *name, off_t *len)
{
	struct stat	 st;
	off_t		 size;
	u_int8_t	*buf = NULL;
	int		 fd;

	if ((fd = open(name, O_RDONLY)) == -1)
		return (NULL);
	if (fstat(fd, &st) != 0)
		goto fail;
	size = st.st_size;
	if ((buf = calloc(1, size + 1)) == NULL)
		goto fail;
	if (read(fd, buf, size) != size)
		goto fail;

	close(fd);

	*len = size;
	return (buf);

 fail:
	free(buf);
	close(fd);
	return (NULL);
}

int
relay_load_certfiles(struct relay *rlay)
{
	char	 certfile[PATH_MAX];
	char	 hbuf[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];
	struct protocol *proto = rlay->rl_proto;
	int	 useport = htons(rlay->rl_conf.port);

	if (rlay->rl_conf.flags & F_TLSCLIENT) {
		if (strlen(proto->tlsca)) {
			if ((rlay->rl_tls_ca =
			    relay_load_file(proto->tlsca,
			    &rlay->rl_conf.tls_ca_len)) == NULL)
				return (-1);
			log_debug("%s: using ca %s", __func__, proto->tlsca);
		}
		if (strlen(proto->tlscacert)) {
			if ((rlay->rl_tls_cacert =
			    relay_load_file(proto->tlscacert,
			    &rlay->rl_conf.tls_cacert_len)) == NULL)
				return (-1);
			log_debug("%s: using ca certificate %s", __func__,
			    proto->tlscacert);
		}
		if (strlen(proto->tlscakey) && proto->tlscapass != NULL) {
			if ((rlay->rl_tls_cakey =
			    ssl_load_key(env, proto->tlscakey,
			    &rlay->rl_conf.tls_cakey_len,
			    proto->tlscapass)) == NULL)
				return (-1);
			log_debug("%s: using ca key %s", __func__,
			    proto->tlscakey);
		}
	}

	if ((rlay->rl_conf.flags & F_TLS) == 0)
		return (0);

	if (print_host(&rlay->rl_conf.ss, hbuf, sizeof(hbuf)) == NULL)
		return (-1);

	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/%s:%u.crt", hbuf, useport) == -1)
		return (-1);
	if ((rlay->rl_tls_cert = relay_load_file(certfile,
	    &rlay->rl_conf.tls_cert_len)) == NULL) {
		if (snprintf(certfile, sizeof(certfile),
		    "/etc/ssl/%s.crt", hbuf) == -1)
			return (-1);
		if ((rlay->rl_tls_cert = relay_load_file(certfile,
		    &rlay->rl_conf.tls_cert_len)) == NULL)
			return (-1);
		useport = 0;
	}
	log_debug("%s: using certificate %s", __func__, certfile);

	if (useport) {
		if (snprintf(certfile, sizeof(certfile),
		    "/etc/ssl/private/%s:%u.key", hbuf, useport) == -1)
			return -1;
	} else {
		if (snprintf(certfile, sizeof(certfile),
		    "/etc/ssl/private/%s.key", hbuf) == -1)
			return -1;
	}
	if ((rlay->rl_tls_key = ssl_load_key(env, certfile,
	    &rlay->rl_conf.tls_key_len, NULL)) == NULL)
		return (-1);
	log_debug("%s: using private key %s", __func__, certfile);

	return (0);
}

int
relay_session_cmp(struct rsession *a, struct rsession *b)
{
	struct relay	*rlay = b->se_relay;
	struct protocol	*proto = rlay->rl_proto;

	if (proto != NULL && proto->cmp != NULL)
		return ((*proto->cmp)(a, b));

	return ((int)a->se_id - b->se_id);
}

void
relay_log(struct rsession *con, char *msg)
{
	if (con->se_haslog && con->se_log != NULL) {
		evbuffer_add(con->se_log, msg, strlen(msg));
	}
}

SPLAY_GENERATE(session_tree, rsession, se_nodes, relay_session_cmp);
@


1.219
log
@Disable client-initiated TLS renegotiation by default.

It is rarely needed and imposes a light DoS risk.  LibreSSL's libssl
allows to turn it off with a simple SSL_OP_NO_CLIENT_RENEGOTIATION
option instead of the complicated implementation that was used before.
It now turns it off completely instead of allowing one initial
client-initiated renegotiation.

It can still be enabled with "tls client-renegotiation".

ok benno@@ beck@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.218 2017/01/09 14:49:21 reyk Exp $	*/
d42 1
a42 2
#include <openssl/dh.h>
#include <openssl/ssl.h>
d75 1
a75 3
DH *		 relay_tls_get_dhparams(int);
DH		*relay_tls_callback_dh(SSL *, int, int);
SSL_CTX		*relay_tls_ctx_create(struct relay *);
d78 1
a78 1
void		 relay_tls_accept(int, short, void *);
a79 1
void		 relay_tls_connect(int, short, void *);
a83 4
struct tls_ticket	*relay_get_ticket_key(unsigned char *);
int			 relay_tls_session_ticket(SSL *, unsigned char *,
			    unsigned char *, EVP_CIPHER_CTX *, HMAC_CTX *, int);

d257 1
a257 1
	    (proto->tickets > -1) ? "enabled" : "disabled");
d421 2
a422 2
		    (rlay->rl_ssl_ctx = relay_tls_ctx_create(rlay)) == NULL)
			fatal("relay_init: failed to create TLS context");
d682 1
a682 1
	if ((rlay->rl_conf.flags & F_TLSCLIENT) && (out->ssl == NULL)) {
d722 1
a722 1
	if ((rlay->rl_conf.flags & F_TLSCLIENT) && (out->ssl != NULL))
d773 1
a773 1
	if ((rlay->rl_conf.flags & F_TLS) && con->se_in.ssl != NULL)
d821 2
a822 2
	if (cre->ssl != NULL)
		(void)SSL_write(cre->ssl, buf, len);
d1081 1
a1081 1
	con->se_in.ssl = NULL;
d1083 1
a1083 1
	con->se_out.ssl = NULL;
d1396 1
a1396 1
	if ((rlay->rl_conf.flags & F_TLS) && (in->ssl == NULL)) {
d1565 1
a1565 1
		if (con->se_out.ssl == NULL) {
d1701 5
a1705 8
	if (con->se_in.ssl != NULL) {
		/* XXX handle non-blocking shutdown */
		if (SSL_shutdown(con->se_in.ssl) == 0)
			SSL_shutdown(con->se_in.ssl);
		SSL_free(con->se_in.ssl);
	}
	if (con->se_in.tlscert != NULL)
		X509_free(con->se_in.tlscert);
a1717 1
	free(con->se_in.buf);
d1723 5
a1727 8
	if (con->se_out.ssl != NULL) {
		/* XXX handle non-blocking shutdown */
		if (SSL_shutdown(con->se_out.ssl) == 0)
			SSL_shutdown(con->se_out.ssl);
		SSL_free(con->se_out.ssl);
	}
	if (con->se_out.tlscert != NULL)
		X509_free(con->se_out.tlscert);
a1738 2
	free(con->se_out.buf);

d1882 2
d1933 9
a1941 7
		IMSG_SIZE_CHECK(imsg, (&env->sc_tls_ticket));
		/* rotate keys */
		memcpy(&env->sc_tls_ticket_bak, &env->sc_tls_ticket,
		    sizeof(env->sc_tls_ticket));
		env->sc_tls_ticket_bak.tt_backup = 1;
		memcpy(&env->sc_tls_ticket, imsg->data,
		    sizeof(env->sc_tls_ticket));
a1949 63
DH *
relay_tls_get_dhparams(int keylen)
{
	DH		*dh;
	BIGNUM		*(*prime)(BIGNUM *);
	const char	*gen;

	gen = "2";
	if (keylen >= 8192)
		prime = get_rfc3526_prime_8192;
	else if (keylen >= 4096)
		prime = get_rfc3526_prime_4096;
	else if (keylen >= 3072)
		prime = get_rfc3526_prime_3072;
	else if (keylen >= 2048)
		prime = get_rfc3526_prime_2048;
	else if (keylen >= 1536)
		prime = get_rfc3526_prime_1536;
	else
		prime = get_rfc2409_prime_1024;

	if ((dh = DH_new()) == NULL)
		return (NULL);

	dh->p = (*prime)(NULL);
	BN_dec2bn(&dh->g, gen);

	if (dh->p == NULL || dh->g == NULL) {
		DH_free(dh);
		return (NULL);
	}

	return (dh);
}

DH *
relay_tls_callback_dh(SSL *ssl, int export, int keylen)
{
	struct ctl_relay_event	*cre;
	EVP_PKEY		*pkey;
	int			 keytype, maxlen;
	DH			*dh = NULL;

	/* Get maximum key length from config */
	if ((cre = (struct ctl_relay_event *)SSL_get_app_data(ssl)) == NULL)
		return (NULL);
	maxlen = cre->con->se_relay->rl_proto->tlsdhparams;

	/* Get the private key length from the cert */
	if ((pkey = SSL_get_privatekey(ssl))) {
		keytype = EVP_PKEY_type(pkey->type);
		if (keytype == EVP_PKEY_RSA || keytype == EVP_PKEY_DSA)
			keylen = EVP_PKEY_bits(pkey);
		else
			return (NULL);
	}

	/* get built-in params based on the shorter key length */
	dh = relay_tls_get_dhparams(MINIMUM(keylen, maxlen));

	return (dh);
}

d1961 2
a1962 2
SSL_CTX *
relay_tls_ctx_create(struct relay *rlay)
d1964 20
a1983 3
	struct protocol	*proto = rlay->rl_proto;
	SSL_CTX		*ctx;
	EC_KEY		*ecdhkey;
d1985 2
a1986 3
	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL)
		goto err;
d1989 2
a1990 2
	 * Disable the session cache by default.
	 * Everything modern uses tickets
d1992 6
a1997 1
	SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);
d2000 1
a2000 6
	if (proto->tickets == -1)
		SSL_CTX_set_options(ctx, SSL_OP_NO_TICKET);
	else {
		if (!SSL_CTX_set_tlsext_ticket_key_cb(ctx,
		    relay_tls_session_ticket))
			log_warnx("could not set the TLS ticket callback");
d2002 5
a2006 1
		SSL_CTX_set_timeout(ctx, TLS_TICKET_REKEY_TIME);
d2009 5
a2013 8
	/* Enable all workarounds and set SSL options */
	SSL_CTX_set_options(ctx, SSL_OP_ALL);
	SSL_CTX_set_options(ctx,
	    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);
	if (proto->tlsflags & TLSFLAG_CIPHER_SERVER_PREF)
		SSL_CTX_set_options(ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
	if ((proto->tlsflags & TLSFLAG_CLIENT_RENEG) == 0)
		SSL_CTX_set_options(ctx, SSL_OP_NO_CLIENT_RENEGOTIATION);
d2015 4
a2018 23
	/* Set the allowed SSL protocols */
	SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2);
	SSL_CTX_clear_options(ctx, SSL_OP_NO_SSLv3);
	if ((proto->tlsflags & TLSFLAG_SSLV3) == 0)
		SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv3);
	SSL_CTX_clear_options(ctx, SSL_OP_NO_TLSv1);
	if ((proto->tlsflags & TLSFLAG_TLSV1_0) == 0)
		SSL_CTX_set_options(ctx, SSL_OP_NO_TLSv1);
	SSL_CTX_clear_options(ctx, SSL_OP_NO_TLSv1_1);
	if ((proto->tlsflags & TLSFLAG_TLSV1_1) == 0)
		SSL_CTX_set_options(ctx, SSL_OP_NO_TLSv1_1);
	SSL_CTX_clear_options(ctx, SSL_OP_NO_TLSv1_2);
	if ((proto->tlsflags & TLSFLAG_TLSV1_2) == 0)
		SSL_CTX_set_options(ctx, SSL_OP_NO_TLSv1_2);

	if (proto->tlsecdhcurve > 0) {
		/* Enable ECDHE support for TLS perfect forward secrecy */
		if ((ecdhkey =
		    EC_KEY_new_by_curve_name(proto->tlsecdhcurve)) == NULL)
			goto err;
		SSL_CTX_set_tmp_ecdh(ctx, ecdhkey);
		SSL_CTX_set_options(ctx, SSL_OP_SINGLE_ECDH_USE);
		EC_KEY_free(ecdhkey);
d2021 24
a2044 3
	if (proto->tlsdhparams > 0) {
		/* Enable EDH params (forward secrecy for older clients) */
		SSL_CTX_set_tmp_dh_callback(ctx, relay_tls_callback_dh);
d2047 3
a2049 1
	if (!SSL_CTX_set_cipher_list(ctx, proto->tlsciphers))
d2053 20
a2072 6
	if ((rlay->rl_conf.flags & F_TLSCLIENT) &&
	    (rlay->rl_tls_ca != NULL)) {
		if (!SSL_CTX_load_verify_mem(ctx,
		    rlay->rl_tls_ca, rlay->rl_conf.tls_ca_len))
			goto err;
		SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, NULL);
d2075 11
a2085 2
	if ((rlay->rl_conf.flags & F_TLS) == 0)
		return (ctx);
d2087 5
a2091 4
	log_debug("%s: loading certificate", __func__);
	if (!SSL_CTX_use_certificate_chain_mem(ctx,
	    rlay->rl_tls_cert, rlay->rl_conf.tls_cert_len))
		goto err;
d2093 7
a2099 6
	log_debug("%s: loading private key", __func__);
	if (!ssl_ctx_fake_private_key(ctx,
	    &rlay->rl_conf.tls_keyid, sizeof(rlay->rl_conf.tls_keyid),
	    rlay->rl_tls_cert, rlay->rl_conf.tls_cert_len,
	    &rlay->rl_tls_x509, &rlay->rl_tls_pkey))
		goto err;
d2101 12
a2112 2
	if (!SSL_CTX_check_private_key(ctx))
		goto err;
d2114 3
a2116 6
	if (rlay->rl_conf.tls_cacert_len) {
		log_debug("%s: loading CA private key", __func__);
		if (!ssl_load_pkey(&rlay->rl_conf.tls_cakeyid,
		    sizeof(rlay->rl_conf.tls_cakeyid),
		    rlay->rl_tls_cacert, rlay->rl_conf.tls_cacert_len,
		    &rlay->rl_tls_cacertx509, &rlay->rl_tls_capkey))
d2118 9
a2128 8
	/*
	 * Set session ID context to a random value. It needs to be the
	 * same accross all relay processes or session caching will fail.
	 */
	if (!SSL_CTX_set_session_id_context(ctx, env->sc_conf.tls_sid,
	    sizeof(env->sc_conf.tls_sid)))
		goto err;

d2133 56
a2188 1
	return (ctx);
d2190 2
d2193 1
a2193 2
	SSL_CTX_free(ctx);
	ssl_error(rlay->rl_conf.name, "relay_tls_ctx_create");
d2201 2
a2202 3
	SSL			*ssl;
	const SSL_METHOD	*method;
	void			(*cb)(int, short, void *);
a2204 4
	ssl = SSL_new(rlay->rl_ssl_ctx);
	if (ssl == NULL)
		goto err;

d2206 4
a2209 3
		cb = relay_tls_accept;
		method = SSLv23_server_method();
		flag = EV_READ;
d2211 4
a2214 1
		/* Use session-specific certificate for TLS inspection. */
d2216 2
a2217 1
			SSL_use_certificate(ssl, cre->tlscert);
d2219 10
a2228 2
		cb = relay_tls_connect;
		method = SSLv23_client_method();
d2232 1
a2232 14
	if (!SSL_set_ssl_method(ssl, method))
		goto err;
	if (!SSL_set_fd(ssl, cre->s))
		goto err;

	if (cre->dir == RELAY_DIR_REQUEST)
		SSL_set_accept_state(ssl);
	else
		SSL_set_connect_state(ssl);

	SSL_set_app_data(ssl, cre);
	cre->ssl = ssl;

	DPRINTF("%s: session %d: scheduling on %s", __func__, con->se_id,
d2234 2
a2235 2
	event_again(&con->se_ev, cre->s, EV_TIMEOUT|flag, cb,
	    &con->se_tv_start, &rlay->rl_conf.timeout, con);
d2239 1
a2239 3
	SSL_free(ssl);
	ssl_error(rlay->rl_conf.name, "relay_tls_transaction");
	relay_close(con, "session tls failed");
d2243 1
a2243 1
relay_tls_accept(int fd, short event, void *arg)
d2245 5
a2249 5
	struct rsession	*con = arg;
	struct relay	*rlay = con->se_relay;
	int		 retry_flag = 0;
	int		 tls_err = 0;
	int		 ret;
d2252 1
a2252 1
		relay_close(con, "TLS accept timeout");
d2256 2
a2257 26
	ret = SSL_accept(con->se_in.ssl);
	if (ret <= 0) {
		tls_err = SSL_get_error(con->se_in.ssl, ret);

		switch (tls_err) {
		case SSL_ERROR_WANT_READ:
			retry_flag = EV_READ;
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			retry_flag = EV_WRITE;
			goto retry;
		case SSL_ERROR_ZERO_RETURN:
		case SSL_ERROR_SYSCALL:
			if (ret == 0) {
				relay_close(con, "closed");
				return;
			}
			/* FALLTHROUGH */
		default:
			ssl_error(rlay->rl_conf.name, "relay_tls_accept");
			relay_close(con, "TLS accept error");
			return;
		}
	}


d2259 1
a2259 1
	log_info(
d2261 1
a2261 1
	log_debug(
d2263 4
a2266 2
	    "relay %s, session %d established (%d active)",
	    rlay->rl_conf.name, con->se_id, relay_sessions);
d2268 4
a2271 9
	relay_session(con);
	return;

retry:
	DPRINTF("%s: session %d: scheduling on %s", __func__, con->se_id,
	    (retry_flag == EV_READ) ? "EV_READ" : "EV_WRITE");
	event_again(&con->se_ev, fd, EV_TIMEOUT|retry_flag, relay_tls_accept,
	    &con->se_tv_start, &rlay->rl_conf.timeout, con);
}
d2273 19
a2291 36
void
relay_tls_connect(int fd, short event, void *arg)
{
	struct rsession	*con = arg;
	struct relay	*rlay = con->se_relay;
	int		 retry_flag = 0;
	int		 tls_err = 0;
	int		 ret;
	X509		*servercert = NULL;

	if (event == EV_TIMEOUT) {
		relay_close(con, "TLS connect timeout");
		return;
	}

	ret = SSL_connect(con->se_out.ssl);
	if (ret <= 0) {
		tls_err = SSL_get_error(con->se_out.ssl, ret);

		switch (tls_err) {
		case SSL_ERROR_WANT_READ:
			retry_flag = EV_READ;
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			retry_flag = EV_WRITE;
			goto retry;
		case SSL_ERROR_ZERO_RETURN:
		case SSL_ERROR_SYSCALL:
			if (ret == 0) {
				relay_close(con, "closed");
				return;
			}
			/* FALLTHROUGH */
		default:
			ssl_error(rlay->rl_conf.name, "relay_tls_connect");
			relay_close(con, "TLS connect error");
d2294 11
a2304 25
	}

#ifdef DEBUG
	log_info(
#else
	log_debug(
#endif
	    "relay %s, tls session %d connected (%d active)",
	    rlay->rl_conf.name, con->se_id, relay_sessions);

	if (rlay->rl_conf.flags & F_TLSINSPECT) {
		if ((servercert =
		    SSL_get_peer_certificate(con->se_out.ssl)) != NULL) {
			con->se_in.tlscert =
			    ssl_update_certificate(servercert,
			    rlay->rl_tls_pkey, rlay->rl_tls_capkey,
			    rlay->rl_tls_cacertx509);
		} else
			con->se_in.tlscert = NULL;
		if (servercert != NULL)
			X509_free(servercert);
		if (con->se_in.tlscert == NULL)
			relay_close(con, "could not create certificate");
		else
			relay_session(con);
a2307 4
	relay_connected(fd, EV_WRITE, con);
	return;

retry:
d2310 2
a2311 2
	event_again(&con->se_ev, fd, EV_TIMEOUT|retry_flag, relay_tls_connect,
	    &con->se_tv_start, &rlay->rl_conf.timeout, con);
a2332 3
	struct rsession		*con = cre->con;
	struct relay		*rlay = con->se_relay;
	int			 ret = 0, tls_err = 0;
d2335 1
d2346 12
a2357 23
	ret = SSL_read(cre->ssl, rbuf, howmuch);
	if (ret <= 0) {
		tls_err = SSL_get_error(cre->ssl, ret);

		switch (tls_err) {
		case SSL_ERROR_WANT_READ:
			DPRINTF("%s: session %d: want read",
			    __func__, con->se_id);
			goto retry;
		case SSL_ERROR_WANT_WRITE:
			DPRINTF("%s: session %d: want write",
			    __func__, con->se_id);
			goto retry;
		default:
			if (ret == 0)
				what |= EVBUFFER_EOF;
			else {
				ssl_error(rlay->rl_conf.name,
				    "relay_tls_readcb");
				what |= EVBUFFER_ERROR;
			}
			goto err;
		}
d2394 2
a2395 3
	struct rsession		*con = cre->con;
	struct relay		*rlay = con->se_relay;
	int			 ret = 0, tls_err;
d2404 7
a2410 33
		if (cre->buf == NULL) {
			cre->buflen = EVBUFFER_LENGTH(bufev->output);
			if ((cre->buf = malloc(cre->buflen)) == NULL) {
				what |= EVBUFFER_ERROR;
				goto err;
			}
			bcopy(EVBUFFER_DATA(bufev->output),
			    cre->buf, cre->buflen);
		}

		ret = SSL_write(cre->ssl, cre->buf, cre->buflen);
		if (ret <= 0) {
			tls_err = SSL_get_error(cre->ssl, ret);

			switch (tls_err) {
			case SSL_ERROR_WANT_READ:
				DPRINTF("%s: session %d: want read",
				    __func__, con->se_id);
				goto retry;
			case SSL_ERROR_WANT_WRITE:
				DPRINTF("%s: session %d: want write",
				    __func__, con->se_id);
				goto retry;
			default:
				if (ret == 0)
					what |= EVBUFFER_EOF;
				else {
					ssl_error(rlay->rl_conf.name,
					    "relay_tls_writecb");
					what |= EVBUFFER_ERROR;
				}
				goto err;
			}
d2412 2
a2413 6
		evbuffer_drain(bufev->output, ret);
	}
	if (cre->buf != NULL) {
		free(cre->buf);
		cre->buf = NULL;
		cre->buflen = 0;
d2425 1
a2425 2
	if (cre->buflen != 0)
		relay_bufferevent_add(&bufev->ev_write, bufev->timeout_write);
a2428 5
	if (cre->buf != NULL) {
		free(cre->buf);
		cre->buf = NULL;
		cre->buflen = 0;
	}
a2429 52
}

struct tls_ticket *
relay_get_ticket_key(unsigned char *keyname)
{
	if (keyname) {
		if (timingsafe_memcmp(keyname,
		    env->sc_tls_ticket_bak.tt_key_name,
		    sizeof(env->sc_tls_ticket_bak.tt_key_name)) == 0)
			return &env->sc_tls_ticket_bak;
		if (timingsafe_memcmp(keyname,
		    env->sc_tls_ticket.tt_key_name,
		    sizeof(env->sc_tls_ticket.tt_key_name)) == 0)
			return &env->sc_tls_ticket;
		return NULL;
	}
	return &env->sc_tls_ticket;
}

int
relay_tls_session_ticket(SSL *ssl, unsigned char *keyname, unsigned char *iv,
    EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int mode)
{
	struct tls_ticket	*key;

	if (mode == 1) {
		/* create new session */
		key = relay_get_ticket_key(NULL);
		memcpy(keyname, key->tt_key_name, sizeof(key->tt_key_name));
		arc4random_buf(iv, EVP_MAX_IV_LENGTH);
		EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL,
		    key->tt_aes_key, iv);
		HMAC_Init_ex(hctx, key->tt_hmac_key, sizeof(key->tt_hmac_key),
		    EVP_sha256(), NULL);
		return 0;
	} else {
		/* get key by name */
		key = relay_get_ticket_key(keyname);
		if  (!key)
			return 0;

		EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL,
		    key->tt_aes_key, iv);
		HMAC_Init_ex(hctx, key->tt_hmac_key, sizeof(key->tt_hmac_key),
		    EVP_sha256(), NULL);

		/* time to renew the ticket? */
		if (key->tt_backup) {
			return 2;
		}
		return 1;
	}
@


1.218
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.217 2016/11/10 13:21:58 jca Exp $	*/
a76 1
void		 relay_tls_callback_info(const SSL *, int, int);
a1962 34
void
relay_tls_callback_info(const SSL *ssl, int where, int rc)
{
	struct ctl_relay_event *cre;
	int tls_state;

	cre = (struct ctl_relay_event *)SSL_get_app_data(ssl);

	if (cre == NULL || cre->tlsreneg_state == TLSRENEG_ALLOW)
		return;

	tls_state = SSL_get_state(ssl);

	/* Check renegotiations */
	if ((where & SSL_CB_ACCEPT_LOOP) &&
	    (cre->tlsreneg_state == TLSRENEG_DENY)) {
		if ((tls_state == SSL3_ST_SR_CLNT_HELLO_A) ||
		    (tls_state == SSL23_ST_SR_CLNT_HELLO_A)) {
			/*
			 * This is a client initiated renegotiation
			 * that we do not allow
			 */
			cre->tlsreneg_state = TLSRENEG_ABORT;
		}
	} else if ((where & SSL_CB_HANDSHAKE_DONE) &&
	    (cre->tlsreneg_state == TLSRENEG_INIT)) {
		/*
		 * This is right after the first handshake,
		 * disallow any further negotiations.
		 */
		cre->tlsreneg_state = TLSRENEG_DENY;
	}
}

d2071 2
a2088 3
	/* add the SSL info callback */
	SSL_CTX_set_info_callback(ctx, relay_tls_callback_info);

a2166 1
	struct protocol	*proto = rlay->rl_proto;
d2195 1
a2195 7
	if (cre->dir == RELAY_DIR_REQUEST) {
		if ((proto->tlsflags & TLSFLAG_CLIENT_RENEG) == 0)
			/* Only allow negotiation during the first handshake */
			cre->tlsreneg_state = TLSRENEG_INIT;
		else
			/* Allow client initiated renegotiations */
			cre->tlsreneg_state = TLSRENEG_ALLOW;
d2197 1
a2197 3
	} else {
		/* Always allow renegotiations if we're the client */
		cre->tlsreneg_state = TLSRENEG_ALLOW;
a2198 1
	}
a2379 5
	if (cre->tlsreneg_state == TLSRENEG_ABORT) {
		what |= EVBUFFER_ERROR;
		goto err;
	}

a2448 5
		goto err;
	}

	if (cre->tlsreneg_state == TLSRENEG_ABORT) {
		what |= EVBUFFER_ERROR;
@


1.217
log
@Fix tcp ip ttl / minttl on IPv6 sockets.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.216 2016/09/29 22:04:28 benno Exp $	*/
a289 2
	extern int	 debug;

d292 1
a292 1
	if (debug)
@


1.216
log
@fix DEBUG build after ps->ps_instance change
ok reyk@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.215 2016/09/26 16:25:16 reyk Exp $	*/
d565 12
a576 3
		if (setsockopt(s, IPPROTO_IP, IP_TTL,
		    &val, sizeof(val)) == -1)
			goto bad;
d580 12
a591 3
		if (setsockopt(s, IPPROTO_IP, IP_MINTTL,
		    &val, sizeof(val)) == -1)
			goto bad;
@


1.215
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.214 2016/09/23 12:06:15 jsg Exp $	*/
d1825 1
a1825 1
		    "host %u %s", __func__, ps->ps_instance, st.up,
@


1.214
log
@use sizeof instead of constant 16 in function calls
suggested by and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.213 2016/09/22 07:56:48 jsg Exp $	*/
d1308 2
a1309 1
		    __func__, con->se_id, table->conf.name, host->conf.name, p, idx);
a2072 1
	
@


1.213
log
@Change function arguments from "unsigned char keyname[16]" to
"unsigned char *keyname" to make it clear that an array size can not
be inferred.  Suggested by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.212 2016/09/22 06:18:58 jsg Exp $	*/
d2562 2
a2563 1
		    env->sc_tls_ticket_bak.tt_key_name, 16) == 0)
d2566 2
a2567 1
		    env->sc_tls_ticket.tt_key_name, 16) == 0)
d2583 1
a2583 1
		memcpy(keyname, key->tt_key_name, 16);
d2587 2
a2588 1
		HMAC_Init_ex(hctx, key->tt_hmac_key, 16, EVP_sha256(), NULL);
d2598 2
a2599 1
		HMAC_Init_ex(hctx, key->tt_hmac_key, 16, EVP_sha256(), NULL);
@


1.212
log
@correct invalid use of sizeof
ok krw@@ millert@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.211 2016/09/02 14:45:51 reyk Exp $	*/
d89 2
a90 2
struct tls_ticket	*relay_get_ticket_key(unsigned char [16]);
int			 relay_tls_session_ticket(SSL *, unsigned char [16],
d2558 1
a2558 1
relay_get_ticket_key(unsigned char keyname[16])
d2573 1
a2573 1
relay_tls_session_ticket(SSL *ssl, unsigned char keyname[16], unsigned char *iv,
@


1.211
log
@Split "struct relayd" into two structs: "struct relayd" and "struct
relayd_config".  This way we can send all the relevant global
configuration to the children, not just the flags and the opts.

With input from and
OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.210 2016/09/02 14:31:47 reyk Exp $	*/
d2562 1
a2562 1
		    env->sc_tls_ticket_bak.tt_key_name, sizeof(keyname)) == 0)
d2565 1
a2565 1
		    env->sc_tls_ticket.tt_key_name, sizeof(keyname)) == 0)
@


1.210
log
@proc_id has been replaced by ps->ps_instance.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.209 2016/09/02 12:12:51 reyk Exp $	*/
d338 1
a338 1
	bcopy(&env->sc_statinterval, &tv, sizeof(tv));
d382 2
a383 1
		if ((cur->tick % (3600 / env->sc_statinterval.tv_sec)) == 0) {
d388 2
a389 1
		if ((cur->tick % (86400 / env->sc_statinterval.tv_sec)) == 0) {
d418 1
a418 1
	bcopy(&env->sc_statinterval, &tv, sizeof(tv));
d1668 1
a1668 1
	if ((env->sc_opts & RELAYD_OPT_LOGUPDATE) && msg != NULL) {
d2167 2
a2168 2
	if (!SSL_CTX_set_session_id_context(ctx, env->sc_tls_sid,
	    sizeof(env->sc_tls_sid)))
@


1.209
log
@As done in httpd, remove ps_ninstances and p_instance.

OK benno@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.208 2016/09/02 11:51:49 reyk Exp $	*/
a101 1
int				 proc_id;
d337 1
a337 1
	evtimer_set(&env->sc_statev, relay_statistics, NULL);
d358 1
d377 1
a377 1
		cur = &rlay->rl_stats[proc_id];
d400 1
a400 1
		crs.proc = proc_id;
d415 1
a415 1
	evtimer_set(&env->sc_statev, relay_statistics, NULL);
d1029 1
d1115 1
a1115 1
	rlay->rl_stats[proc_id].last++;
d1148 1
a1148 1
		cnl->proc = proc_id;
d1406 1
d1413 1
a1413 1
	bnd.bnd_proc = proc_id;
d1822 1
a1822 1
		    "host %u %s", __func__, proc_id, st.up,
@


1.208
log
@Terminate relayd using the socket status instead of watching SIGCHLD
or killing child processes. - Based on rzalamena@@'s diff for httpd.

OK deraadt@@ rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.207 2016/09/01 10:49:48 claudio Exp $	*/
a326 3

	/* Set to current prefork id */
	proc_id = p->p_instance;
@


1.207
log
@Switch from the not really working session cache (because of the multiprocess
nature of relayd) to tls session tickets to do TLS session resumption.
TLS session tickets do not need to store SSL session data in the server but
instead send an encrypted ticket to the clients that allows to resume the
session. This is mostly stateless (apart from the encryption keys).
relayd now ensures that all relay processes use the same key to encrypt
the tickets. Keys are rotated every 2h and there is a primary and backup key.
The tls session timeout is set to 2h to hint to the clients how long the
session tickets is supposed to be alive.
Input and OK benno@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.206 2015/12/30 16:00:57 benno Exp $	*/
d111 1
a111 1
pid_t
a113 2
	pid_t	 pid;

d115 1
a115 1
	pid = proc_run(ps, p, procs, nitems(procs), relay_init, NULL);
a116 1
	return (pid);
@


1.206
log
@SSL_CTX_free() and SSL_free() check for null so dont do it in relayd
ok jung@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.205 2015/12/24 05:06:24 mmcc Exp $	*/
d31 1
d89 4
d115 1
d269 2
a270 2
	if (proto->cache != -1)
		fprintf(stderr, "\ttls session cache: %d\n", proto->cache);
d1933 9
a2062 1
	u_int8_t	 sid[SSL_MAX_SID_CTX_LENGTH];
d2068 16
a2083 9
	/* Modify session timeout and cache size*/
	SSL_CTX_set_timeout(ctx,
	    (long)MINIMUM(rlay->rl_conf.timeout.tv_sec, LONG_MAX));
	if (proto->cache < -1) {
		SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);
	} else if (proto->cache >= -1) {
		SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_SERVER);
		if (proto->cache >= 0)
			SSL_CTX_sess_set_cache_size(ctx, proto->cache);
d2166 2
a2167 3
	 * Set session ID context to a random value.  We don't support
	 * persistent caching of sessions so it is OK to set a temporary
	 * session ID context that is valid during run time.
d2169 2
a2170 2
	arc4random_buf(sid, sizeof(sid));
	if (!SSL_CTX_set_session_id_context(ctx, sid, sizeof(sid)))
d2557 48
@


1.205
log
@completly -> completely
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.204 2015/12/07 04:03:27 mmcc Exp $	*/
d2160 1
a2160 2
	if (ctx != NULL)
		SSL_CTX_free(ctx);
d2222 1
a2222 2
	if (ssl != NULL)
		SSL_free(ssl);
@


1.204
log
@Remove NULL-checks before free(). No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.203 2015/12/05 20:58:32 benno Exp $	*/
d1180 1
a1180 1
		 * the session struct was not completly set up, but still
@


1.203
log
@initialize host, to get rid of gcc warning, the conditions are correct.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.202 2015/12/04 15:28:55 benno Exp $	*/
d1178 1
a1178 2
		if (con != NULL)
			free(con);
d1678 1
a1678 2
		if (ptr != NULL)
			free(ptr);
d1684 1
a1684 2
	if (con->se_priv != NULL)
		free(con->se_priv);
d1709 1
a1709 2
	if (con->se_in.buf != NULL)
		free(con->se_in.buf);
d1734 1
a1734 2
	if (con->se_out.buf != NULL)
		free(con->se_out.buf);
d2670 1
a2670 2
	if (buf != NULL)
		free(buf);
@


1.202
log
@pledge the relay (layer 7 proxy) children, they can do with "stdio
recvfd inet"
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.201 2015/12/02 22:12:29 benno Exp $	*/
d1217 1
a1217 1
	struct host		*host;
@


1.201
log
@relayd (when running relays) can distribute client sessions over hosts
with a hash generated from different data and calculate modulo
rlt->rlt_nhosts to find the host the session should go to. If this
host is down, the current algorithm simply selects the next host that
is up, obviously not ideal, because this puts heavier load on this
next host.

this changes the algorithm: if the chosen host is not available, the
hash value is recalculated and and retried until a host that is usable
is found or a maximum of retires is reached (in that case the old
method is used).

ok and nice input on my original idea bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.200 2015/12/02 13:41:27 reyk Exp $	*/
d333 3
@


1.200
log
@In most cases we don't need all arguments of proc_compose*_imsg(),
so add a shortcut proc_compose*() that skips all of them.  Only use the
full argument list if needed.  The functions with full argument lists can
eventually be replaced with a nicer transaction-based approach later.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.199 2015/11/28 09:52:07 reyk Exp $	*/
d1218 2
d1275 1
d1282 22
a1303 2
		if ((idx = p % rlt->rlt_nhosts) >= RELAY_MAXHOSTS)
			return (-1);
d1305 1
a1305 3
	host = rlt->rlt_host[idx];
	DPRINTF("%s: session %d: table %s host %s, p 0x%016llx, idx %d",
	    __func__, con->se_id, table->conf.name, host->conf.name, p, idx);
@


1.199
log
@Use SOCK_NONBLOCK in relayd as well.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.198 2015/07/28 10:24:26 reyk Exp $	*/
d343 1
a343 2
	proc_compose_imsg(env->sc_ps, PROC_PFE, -1, IMSG_SESS_PUBLISH, -1,
	    s, sizeof(*s));
d349 1
a349 1
	proc_compose_imsg(env->sc_ps, PROC_PFE, -1, IMSG_SESS_UNPUBLISH, -1,
d398 1
a398 1
		proc_compose_imsg(env->sc_ps, PROC_PFE, -1, IMSG_STATISTICS, -1,
d1155 1
a1155 1
		proc_compose_imsg(env->sc_ps, PROC_PFE, -1, IMSG_NATLOOK, -1,
d1392 2
a1393 2
	proc_compose_imsg(env->sc_ps, PROC_PARENT, -1, IMSG_BINDANY,
	    -1, &bnd, sizeof(bnd));
d1837 2
a1838 3
				proc_compose_imsg(env->sc_ps, p->p_id, -1,
				    IMSG_CTL_SESSION,
				    -1, &se, sizeof(se));
d1841 2
a1842 2
		proc_compose_imsg(env->sc_ps, p->p_id, -1, IMSG_CTL_END,
		    -1, &cid, sizeof(cid));
@


1.198
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.197 2015/07/18 16:01:28 benno Exp $	*/
d528 2
a529 1
	s = fd == -1 ? socket(ss->ss_family, SOCK_STREAM, IPPROTO_TCP) : fd;
a544 2
	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1)
		goto bad;
a1056 3
		goto err;

	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1)
@


1.197
log
@Fix unbounded buffer growth. In the case of a slow client reading large files,
we would consume large ammounts of memory.
Found by Matthew Martin <matt DOT a DOT martin AT gmail DOT com> in
httpd, fixed in httpd by florian@@
feedback from florian, reyk and bluhm, ok bluhm, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.196 2015/06/12 14:40:55 reyk Exp $	*/
d873 1
a873 1
	if (! (cre->toread == TOREAD_UNLIMITED || cre->toread > 0)) {
@


1.196
log
@To match relayd's style, use an explicit enum with prefixed names for
the states that Claudio introduced.  No functional change.

OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.195 2015/06/08 15:47:51 claudio Exp $	*/
d650 1
d717 2
d720 2
d731 1
d768 2
d788 3
d822 1
d836 4
@


1.195
log
@Introduce a state on the ctl_relay_event struct. This makes it possible
to better track the connection state of a session and stops doing double
opens in certain situations using http relays. Using a state field to
simplify the logic since relay_connect() is called multiple times.
OK benno@@, bluhm@@ and running in production for more than a week
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.194 2015/05/18 16:57:20 bluhm Exp $	*/
d1472 1
a1472 1
		con->se_out.state = PRECONNECT;
d1474 1
a1474 1
		con->se_out.state = CONNECTED;
d1498 2
a1499 2
	if (con->se_out.state == CONNECTED)
		con->se_out.state = PRECONNECT;
d1511 1
a1511 1
	if (con->se_out.state == CONNECTED) {
d1518 1
a1518 1
	    con->se_out.state == PRECONNECT) {
d1524 1
a1524 1
		con->se_out.state = CONNECTED;
d1579 1
d1581 1
a1581 1
			con->se_out.state = PENDING;
d1599 1
a1599 1
	con->se_out.state = CONNECTED;
d1701 1
a1701 1
	con->se_out.state = INIT;
@


1.194
log
@Fix a crash reported and analyzed by Bertrand PROVOST.  When a HTTP
client or server writes multiple requests or chunks in a single
transfer, relayd invokes the libevent callback manually for the
next data.  If the callback closes the session, this resulted in
an use after free.
Instead of the more complicated fix suggested by Bertrand PROVOST,
just move the invocation of the callback to the end of the function.
So in case the callback frees any structures, they are not accessed.
OK benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.193 2015/04/29 08:41:24 bluhm Exp $	*/
d1411 4
a1414 2
	if (relay_inflight < 1)
		fatalx("relay_connect_retry: no connection in flight");
d1471 4
d1493 2
d1497 4
a1500 1
	return (relay_connect(con));
d1510 6
d1517 2
a1518 1
	if ((rlay->rl_conf.flags & F_TLSINSPECT) && con->se_out.s != -1) {
d1524 1
d1528 4
a1531 2
	if (relay_inflight < 1)
		fatalx("relay_connect: no connection in flight");
d1579 2
d1598 1
d1700 1
@


1.193
log
@When the HTTP client did close the connection while relayd was still
parsig the HTTP header, the session was never destroyed.  This
resulted in a file descriptor leak.
Add a check wether the protocol knows how much data to expect.  If
relayd is reading unlimited data or is expecting nothing to read,
ignore the end-of-file.  Otherwise it is a protocol violation, so
close the session immediately.
While there, make relayd compile with DEBUG defined.
Based on a diff from claudio@@; tested by claudio@@; OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.192 2015/04/23 17:03:01 florian Exp $	*/
d832 6
d887 1
a887 1
	return (0);
@


1.192
log
@We cannot log errors with relay_close() before allocating
se_log evbuffer.
(Same problem as the one just fixed in httpd(8))
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.191 2015/02/06 01:37:11 reyk Exp $	*/
d991 1
a991 1
		} else
d1266 1
a1266 1
	DPRINTF("%s: session %d: table %s host %s, p 0x%08x, idx %d",
@


1.191
log
@Rename SSL_CTX_use_certificate_chain() to SSL_CTX_use_certificate_chain_mem().

As discussed with beck@@ jsing@@ and others
OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.190 2015/01/22 17:42:09 reyk Exp $	*/
d1044 6
a1099 8
		return;
	}

	/* Pre-allocate log buffer */
	con->se_haslog = 0;
	con->se_log = evbuffer_new();
	if (con->se_log == NULL) {
		relay_close(con, "failed to allocate log buffer");
@


1.191.2.1
log
@maintainance diff for relayd
MFC the following changes

- Missing free(3) in error path (ssl.c,v 1.29)
- fix a memory leak. (pfe.c,v 1.80)
- allocate se_log evbuffer before loging errors with relay_close()
  (relay.c,v 1.192)
- fix a file descriptor leak in http protocol handling
  (relay.c,v 1.193 and relay_http.c,v 1.44)
- Fix obvious problems with relayd config reload
  (ca.c,v 1.13; config.c,v 1.25; parse.y,v 1.204;
  relayd.c,v 1.139; relayd.h,v 1.209)
- http protocol: you cannot append to the previous key-value before
  line three of a request (relay_http.c,v 1.45)
- fix a crash / use after free (relay.c,v 1.194; relay_http.c,v 1.46)
- fix a non safe use of TAILQ_FOREACH with TAILQ_REMOVE
  (relay_http.c,v 1.47)
- Plug a memory leak by simplifying kv_free() (relayd.c,v 1.141)
- Fix memory leak in error case (relay_http.c,v 1.48)
- track the connection state of a session and stops doing double
  opens in certain situations (relay.c,v 1.195; relay_http.c,v 1.49; relayd.h,v 1.210)
- coding style (relay.c,v 1.196; relay_http.c,v 1.50; relayd.h,v 1.212)

ok claudio@@, sthen@@ and feedback tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.191 2015/02/06 01:37:11 reyk Exp $	*/
a831 6
/*
 * Splice sockets from cre to cre->dst if applicable.  Returns:
 * -1 socket splicing has failed
 * 0 socket splicing is currently not possible
 * 1 socket splicing was successful
 */
d881 1
a881 1
	return (1);
d991 1
a991 1
		} else if (cre->toread == TOREAD_UNLIMITED || cre->toread == 0)
a1043 6
	/* Pre-allocate log buffer */
	con->se_haslog = 0;
	con->se_log = evbuffer_new();
	if (con->se_log == NULL)
		goto err;

d1097 8
d1268 1
a1268 1
	DPRINTF("%s: session %d: table %s host %s, p 0x%016llx, idx %d",
d1407 2
a1408 4
	if (relay_inflight < 1) {
		log_warnx("relay_connect_retry: no connection in flight");
		relay_inflight = 1;
	}
a1464 4
	if (rlay->rl_conf.flags & F_TLSINSPECT)
		con->se_out.state = STATE_PRECONNECT;
	else
		con->se_out.state = STATE_CONNECTED;
a1482 2
	int rv;

d1485 1
a1485 4
	rv = relay_connect(con);
	if (con->se_out.state == STATE_CONNECTED)
		con->se_out.state = STATE_PRECONNECT;
	return (rv);
a1494 6
	/* relay_connect should only be called once per relay */
	if (con->se_out.state == STATE_CONNECTED) {
		log_debug("%s: connect already called once", __func__);
		return (0);
	}

d1496 1
a1496 2
	if ((rlay->rl_conf.flags & F_TLSINSPECT) &&
	    con->se_out.state == STATE_PRECONNECT) {
a1501 1
		con->se_out.state = STATE_CONNECTED;
d1505 2
a1506 4
	if (relay_inflight < 1) {
		log_warnx("relay_connect: no connection in flight");
		relay_inflight = 1;
	}
a1553 3

			/* this connect is pending */
			con->se_out.state = STATE_PENDING;
a1570 1
	con->se_out.state = STATE_CONNECTED;
a1671 1
	con->se_out.state = STATE_INIT;
@


1.190
log
@Clean up the relayd headers with help of include-what-you-use and some
manual review.  Based on common practice, relayd.h now includes the
necessary headers for itself.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.189 2015/01/22 15:21:28 reyk Exp $	*/
d2062 1
a2062 1
	if (!SSL_CTX_use_certificate_chain(ctx,
@


1.189
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.188 2015/01/22 09:26:05 reyk Exp $	*/
a23 1
#include <sys/un.h>
a25 1
#include <net/if.h>
a26 1
#include <netinet/ip.h>
d28 1
d30 3
a34 1
#include <stdlib.h>
a36 3
#include <stdio.h>
#include <err.h>
#include <pwd.h>
d38 2
a39 1
#include <fnmatch.h>
@


1.188
log
@LibreSSL now supports loading of CA certificates from memory, replace
the internal and long-serving ssl_ctx_load_verify_memory() function
with a call to the SSL_CTX_load_verify_mem() API function.  The
ssl_privsep.c file with hacks for using OpenSSL in privsep'ed
processes can now go away; portable versions of smtpd and relayd
should start depending on LibreSSL or they have to carry ssl_privsep.c
in openbsd-compat to work with legacy OpenSSL.  No functional change.

Based on previous discussions with gilles@@ bluhm@@ and many others
OK bluhm@@ (as part of the libcrypto/libssl/libtls diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.187 2015/01/16 15:08:52 reyk Exp $	*/
d2414 1
a2414 1
        if (cre->tlsreneg_state == TLSRENEG_ABORT) {
@


1.187
log
@SSL_CTX_use_certificate_chain() has been added to LibreSSL and there
is no need to keep a local copy in ssl_privsep.c.  This adds a little
burden on OpenSMTPD-portable because it will have to put it in
openbsd-compat for compatibility with legacy OpenSSL.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.186 2015/01/16 15:06:40 deraadt Exp $	*/
d2054 1
a2054 1
		if (!ssl_ctx_load_verify_memory(ctx,
@


1.186
log
@Adapt to <limits.h> universe.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.185 2015/01/16 14:34:51 reyk Exp $	*/
d2064 1
a2064 1
	if (!ssl_ctx_use_certificate_chain(ctx,
@


1.185
log
@The SSL/TLS session Id context is limited to 32 bytes.  Instead of
using the name of relayd relay or smtpd pki, use a 32 byte arc4random
buffer that should be unique for the context.  This fixes an issue in
OpenSMTPD when a long pki name could break the configuration.

OK gilles@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.184 2014/12/21 00:54:49 guenther Exp $	*/
d48 2
d1969 1
a1969 1
	dh = relay_tls_get_dhparams(MIN(keylen, maxlen));
d1999 1
a1999 1
	    (long)MIN(rlay->rl_conf.timeout.tv_sec, LONG_MAX));
d2343 1
a2343 1
		howmuch = MIN(sizeof(rbuf), bufev->wm_read.high);
@


1.184
log
@Stop pulling in <arpa/inet.h> or <arpa/nameser.h> when unnecessary.
*Do* pull it in when in_{port,addr}_h is needed and <netinet/in.h> isn't.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.183 2014/12/18 20:55:01 reyk Exp $	*/
d1989 1
d2085 7
a2091 3
	/* Set session context to the local relay name */
	if (!SSL_CTX_set_session_id_context(ctx, rlay->rl_conf.name,
	    strlen(rlay->rl_conf.name)))
@


1.183
log
@Update relayd to use siphash instead of sys/hash.  The source-hash,
loadbalance and hash modes use a random key by default that can be
forced to be a static key with a new configuration argument.

With input from Max Fillinger.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.182 2014/12/12 10:05:09 reyk Exp $	*/
a30 1
#include <arpa/inet.h>
@


1.182
log
@Change the keyword "ssl" to "tls" to reflect reality since we
effectively disabled support for the SSL protocols.  SSL remains a
common term describing SSL/TLS, there is some controvery about this
change, and the name really doesn't matter, but I feel confident about
it now.

(btw., sthen@@ pointed out some historical context:
http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html)

OK benno@@, with input from tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.181 2014/11/19 10:24:40 blambert Exp $	*/
a25 1
#include <sys/hash.h>
d74 1
a74 1
u_int32_t	 relay_hash_addr(struct sockaddr_storage *, u_int32_t);
d440 1
a440 15
			switch (rlt->rlt_mode) {
			case RELAY_DSTMODE_ROUNDROBIN:
			case RELAY_DSTMODE_RANDOM:
				rlt->rlt_key = 0;
				break;
			case RELAY_DSTMODE_LOADBALANCE:
			case RELAY_DSTMODE_HASH:
			case RELAY_DSTMODE_SRCHASH:
				rlt->rlt_key =
				    hash32_str(rlay->rl_conf.name, HASHINIT);
				rlt->rlt_key =
				    hash32_str(rlt->rlt_table->conf.name,
				    rlt->rlt_key);
				break;
			}
d1079 5
d1173 2
a1174 2
u_int32_t
relay_hash_addr(struct sockaddr_storage *ss, u_int32_t p)
d1178 1
d1182 2
a1183 2
		p = hash32_buf(&sin4->sin_addr,
		    sizeof(struct in_addr), p);
d1186 2
a1187 2
		p = hash32_buf(&sin6->sin6_addr,
		    sizeof(struct in6_addr), p);
d1190 4
a1193 1
	return (p);
a1202 1
	u_int32_t		 p = con->se_hashkey;
d1204 1
a1230 4
	if (!con->se_hashkeyset) {
		p = con->se_hashkey = rlt->rlt_key;
		con->se_hashkeyset = 1;
	}
d1234 3
a1236 3
		if ((int)rlt->rlt_key >= rlt->rlt_nhosts)
			rlt->rlt_key = 0;
		idx = (int)rlt->rlt_key;
d1242 3
d1247 1
a1247 3
		p = relay_hash_addr(&con->se_in.ss, p);
		if (rlt->rlt_mode == RELAY_DSTMODE_SRCHASH)
			break;
d1251 2
a1252 3
		p = relay_hash_addr(&rlay->rl_conf.ss, p);
		p = hash32_buf(&rlay->rl_conf.port,
		    sizeof(rlay->rl_conf.port), p);
d1258 10
a1267 2
	if (idx == -1 && (idx = p % rlt->rlt_nhosts) >= RELAY_MAXHOSTS)
		return (-1);
d1290 1
a1290 1
		rlt->rlt_key = host->idx + 1;
@


1.181
log
@Support exporting relayd statistics via AgentX/snmpd

This should be equivalent to the statistics available
via the various relaydctl show commands

okay benno@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.180 2014/11/07 13:48:06 jsing Exp $	*/
d77 5
a81 5
DH *		 relay_ssl_get_dhparams(int);
void		 relay_ssl_callback_info(const SSL *, int, int);
DH		*relay_ssl_callback_dh(SSL *, int, int);
SSL_CTX		*relay_ssl_ctx_create(struct relay *);
void		 relay_ssl_transaction(struct rsession *,
d83 1
a83 1
void		 relay_ssl_accept(int, short, void *);
d85 4
a88 4
void		 relay_ssl_connect(int, short, void *);
void		 relay_ssl_connected(struct ctl_relay_event *);
void		 relay_ssl_readcb(int, short, void *);
void		 relay_ssl_writecb(int, short, void *);
d262 3
a264 3
	if ((rlay->rl_conf.flags & (F_SSL|F_SSLCLIENT)) && proto->sslflags)
		fprintf(stderr, "\tssl flags: %s\n",
		    printb_flags(proto->sslflags, SSLFLAG_BITS));
d266 1
a266 1
		fprintf(stderr, "\tssl session cache: %d\n", proto->cache);
d429 3
a431 3
		if ((rlay->rl_conf.flags & (F_SSL|F_SSLCLIENT)) &&
		    (rlay->rl_ssl_ctx = relay_ssl_ctx_create(rlay)) == NULL)
			fatal("relay_init: failed to create SSL context");
d687 2
a688 2
	if ((rlay->rl_conf.flags & F_SSLCLIENT) && (out->ssl == NULL)) {
		relay_ssl_transaction(con, out);
d726 3
a728 3
	/* Initialize the SSL wrapper */
	if ((rlay->rl_conf.flags & F_SSLCLIENT) && (out->ssl != NULL))
		relay_ssl_connected(out);
d772 3
a774 3
	/* Initialize the SSL wrapper */
	if ((rlay->rl_conf.flags & F_SSL) && con->se_in.ssl != NULL)
		relay_ssl_connected(&con->se_in);
d856 1
a856 1
	if ((rlay->rl_conf.flags & (F_SSL|F_SSLCLIENT)) ||
d1161 1
a1161 1
	if (rlay->rl_conf.flags & F_SSLINSPECT) {
d1350 2
a1351 2
	if ((rlay->rl_conf.flags & F_SSL) && (in->ssl == NULL)) {
		relay_ssl_transaction(con, in);
d1499 1
a1499 1
	if ((rlay->rl_conf.flags & F_SSLINSPECT) && con->se_out.s != -1) {
d1501 1
a1501 1
			log_debug("%s: ssl connect failed", __func__);
d1637 2
a1638 2
	if (con->se_in.sslcert != NULL)
		X509_free(con->se_in.sslcert);
d1664 2
a1665 2
	if (con->se_out.sslcert != NULL)
		X509_free(con->se_out.sslcert);
d1879 1
a1879 1
relay_ssl_callback_info(const SSL *ssl, int where, int rc)
d1882 1
a1882 1
	int ssl_state;
d1886 1
a1886 1
	if (cre == NULL || cre->sslreneg_state == SSLRENEG_ALLOW)
d1889 1
a1889 1
	ssl_state = SSL_get_state(ssl);
d1893 3
a1895 3
	    (cre->sslreneg_state == SSLRENEG_DENY)) {
		if ((ssl_state == SSL3_ST_SR_CLNT_HELLO_A) ||
		    (ssl_state == SSL23_ST_SR_CLNT_HELLO_A)) {
d1900 1
a1900 1
			cre->sslreneg_state = SSLRENEG_ABORT;
d1903 1
a1903 1
	    (cre->sslreneg_state == SSLRENEG_INIT)) {
d1908 1
a1908 1
		cre->sslreneg_state = SSLRENEG_DENY;
d1913 1
a1913 1
relay_ssl_get_dhparams(int keylen)
d1948 1
a1948 1
relay_ssl_callback_dh(SSL *ssl, int export, int keylen)
d1958 1
a1958 1
	maxlen = cre->con->se_relay->rl_proto->ssldhparams;
d1970 1
a1970 1
	dh = relay_ssl_get_dhparams(MIN(keylen, maxlen));
d1987 1
a1987 1
relay_ssl_ctx_create(struct relay *rlay)
d2012 1
a2012 1
	if (proto->sslflags & SSLFLAG_CIPHER_SERVER_PREF)
d2018 1
a2018 1
	if ((proto->sslflags & SSLFLAG_SSLV3) == 0)
d2021 1
a2021 1
	if ((proto->sslflags & SSLFLAG_TLSV1_0) == 0)
d2024 1
a2024 1
	if ((proto->sslflags & SSLFLAG_TLSV1_1) == 0)
d2027 1
a2027 1
	if ((proto->sslflags & SSLFLAG_TLSV1_2) == 0)
d2031 1
a2031 1
	SSL_CTX_set_info_callback(ctx, relay_ssl_callback_info);
d2033 1
a2033 1
	if (proto->sslecdhcurve > 0) {
d2036 1
a2036 1
		    EC_KEY_new_by_curve_name(proto->sslecdhcurve)) == NULL)
d2043 1
a2043 1
	if (proto->ssldhparams > 0) {
d2045 1
a2045 1
		SSL_CTX_set_tmp_dh_callback(ctx, relay_ssl_callback_dh);
d2048 1
a2048 1
	if (!SSL_CTX_set_cipher_list(ctx, proto->sslciphers))
d2052 2
a2053 2
	if ((rlay->rl_conf.flags & F_SSLCLIENT) &&
	    (rlay->rl_ssl_ca != NULL)) {
d2055 1
a2055 1
		    rlay->rl_ssl_ca, rlay->rl_conf.ssl_ca_len))
d2060 1
a2060 1
	if ((rlay->rl_conf.flags & F_SSL) == 0)
d2065 1
a2065 1
	    rlay->rl_ssl_cert, rlay->rl_conf.ssl_cert_len))
d2070 3
a2072 3
	    &rlay->rl_conf.ssl_keyid, sizeof(rlay->rl_conf.ssl_keyid),
	    rlay->rl_ssl_cert, rlay->rl_conf.ssl_cert_len,
	    &rlay->rl_ssl_x509, &rlay->rl_ssl_pkey))
d2078 1
a2078 1
	if (rlay->rl_conf.ssl_cacert_len) {
d2080 4
a2083 4
		if (!ssl_load_pkey(&rlay->rl_conf.ssl_cakeyid,
		    sizeof(rlay->rl_conf.ssl_cakeyid),
		    rlay->rl_ssl_cacert, rlay->rl_conf.ssl_cacert_len,
		    &rlay->rl_ssl_cacertx509, &rlay->rl_ssl_capkey))
d2093 2
a2094 2
	purge_key(&rlay->rl_ssl_cert, rlay->rl_conf.ssl_cert_len);
	purge_key(&rlay->rl_ssl_cacert, rlay->rl_conf.ssl_cacert_len);
d2101 1
a2101 1
	ssl_error(rlay->rl_conf.name, "relay_ssl_ctx_create");
d2106 1
a2106 1
relay_ssl_transaction(struct rsession *con, struct ctl_relay_event *cre)
d2120 1
a2120 1
		cb = relay_ssl_accept;
d2124 3
a2126 3
		/* Use session-specific certificate for SSL inspection. */
		if (cre->sslcert != NULL)
			SSL_use_certificate(ssl, cre->sslcert);
d2128 1
a2128 1
		cb = relay_ssl_connect;
d2139 1
a2139 1
		if ((proto->sslflags & SSLFLAG_CLIENT_RENEG) == 0)
d2141 1
a2141 1
			cre->sslreneg_state = SSLRENEG_INIT;
d2144 1
a2144 1
			cre->sslreneg_state = SSLRENEG_ALLOW;
d2148 1
a2148 1
		cre->sslreneg_state = SSLRENEG_ALLOW;
d2164 2
a2165 2
	ssl_error(rlay->rl_conf.name, "relay_ssl_transaction");
	relay_close(con, "session ssl failed");
d2169 1
a2169 1
relay_ssl_accept(int fd, short event, void *arg)
d2174 1
a2174 1
	int		 ssl_err = 0;
d2178 1
a2178 1
		relay_close(con, "SSL accept timeout");
d2184 1
a2184 1
		ssl_err = SSL_get_error(con->se_in.ssl, ret);
d2186 1
a2186 1
		switch (ssl_err) {
d2201 2
a2202 2
			ssl_error(rlay->rl_conf.name, "relay_ssl_accept");
			relay_close(con, "SSL accept error");
d2222 1
a2222 1
	event_again(&con->se_ev, fd, EV_TIMEOUT|retry_flag, relay_ssl_accept,
d2227 1
a2227 1
relay_ssl_connect(int fd, short event, void *arg)
d2232 1
a2232 1
	int		 ssl_err = 0;
d2237 1
a2237 1
		relay_close(con, "SSL connect timeout");
d2243 1
a2243 1
		ssl_err = SSL_get_error(con->se_out.ssl, ret);
d2245 1
a2245 1
		switch (ssl_err) {
d2260 2
a2261 2
			ssl_error(rlay->rl_conf.name, "relay_ssl_connect");
			relay_close(con, "SSL connect error");
d2271 1
a2271 1
	    "relay %s, ssl session %d connected (%d active)",
d2274 1
a2274 1
	if (rlay->rl_conf.flags & F_SSLINSPECT) {
d2277 1
a2277 1
			con->se_in.sslcert =
d2279 2
a2280 2
			    rlay->rl_ssl_pkey, rlay->rl_ssl_capkey,
			    rlay->rl_ssl_cacertx509);
d2282 1
a2282 1
			con->se_in.sslcert = NULL;
d2285 1
a2285 1
		if (con->se_in.sslcert == NULL)
d2298 1
a2298 1
	event_again(&con->se_ev, fd, EV_TIMEOUT|retry_flag, relay_ssl_connect,
d2303 1
a2303 1
relay_ssl_connected(struct ctl_relay_event *cre)
d2307 1
a2307 1
	 * functions to handle the SSL abstraction.
d2310 1
a2310 1
	    relay_ssl_readcb, cre->bev);
d2312 1
a2312 1
	    relay_ssl_writecb, cre->bev);
d2316 1
a2316 1
relay_ssl_readcb(int fd, short event, void *arg)
d2323 1
a2323 1
	int			 ret = 0, ssl_err = 0;
d2333 1
a2333 1
	if (cre->sslreneg_state == SSLRENEG_ABORT) {
d2343 1
a2343 1
		ssl_err = SSL_get_error(cre->ssl, ret);
d2345 1
a2345 1
		switch (ssl_err) {
d2359 1
a2359 1
				    "relay_ssl_readcb");
d2396 1
a2396 1
relay_ssl_writecb(int fd, short event, void *arg)
d2402 1
a2402 1
	int			 ret = 0, ssl_err;
d2410 1
a2410 1
        if (cre->sslreneg_state == SSLRENEG_ABORT) {
d2428 1
a2428 1
			ssl_err = SSL_get_error(cre->ssl, ret);
d2430 1
a2430 1
			switch (ssl_err) {
d2444 1
a2444 1
					    "relay_ssl_writecb");
d2623 5
a2627 5
	if (rlay->rl_conf.flags & F_SSLCLIENT) {
		if (strlen(proto->sslca)) {
			if ((rlay->rl_ssl_ca =
			    relay_load_file(proto->sslca,
			    &rlay->rl_conf.ssl_ca_len)) == NULL)
d2629 1
a2629 1
			log_debug("%s: using ca %s", __func__, proto->sslca);
d2631 4
a2634 4
		if (strlen(proto->sslcacert)) {
			if ((rlay->rl_ssl_cacert =
			    relay_load_file(proto->sslcacert,
			    &rlay->rl_conf.ssl_cacert_len)) == NULL)
d2637 1
a2637 1
			    proto->sslcacert);
d2639 5
a2643 5
		if (strlen(proto->sslcakey) && proto->sslcapass != NULL) {
			if ((rlay->rl_ssl_cakey =
			    ssl_load_key(env, proto->sslcakey,
			    &rlay->rl_conf.ssl_cakey_len,
			    proto->sslcapass)) == NULL)
d2646 1
a2646 1
			    proto->sslcakey);
d2650 1
a2650 1
	if ((rlay->rl_conf.flags & F_SSL) == 0)
d2659 2
a2660 2
	if ((rlay->rl_ssl_cert = relay_load_file(certfile,
	    &rlay->rl_conf.ssl_cert_len)) == NULL) {
d2664 2
a2665 2
		if ((rlay->rl_ssl_cert = relay_load_file(certfile,
		    &rlay->rl_conf.ssl_cert_len)) == NULL)
d2680 2
a2681 2
	if ((rlay->rl_ssl_key = ssl_load_key(env, certfile,
	    &rlay->rl_conf.ssl_key_len, NULL)) == NULL)
@


1.180
log
@Remove the sslv2 option since LibreSSL has no SSLv2 support (however retain
SSL_OP_NO_SSLv2 in case you happen to be running relayd on another platform
with another SSL library). Also fix the SSLv3 handling so that 'no sslv3'
actually works as intended.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.179 2014/10/25 03:23:49 lteo Exp $	*/
d57 2
d104 2
a105 1
	{ "ca",		PROC_CA,	relay_dispatch_ca }
d343 14
d1096 1
d1596 1
d1973 11
@


1.179
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.178 2014/10/15 11:06:16 reyk Exp $	*/
d1986 2
a1987 2
	if ((proto->sslflags & SSLFLAG_SSLV2) == 0)
		SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2);
d1990 1
d1993 1
d1996 1
@


1.178
log
@Disable SSLv3 by default.

OK sthen@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.177 2014/09/05 10:19:26 blambert Exp $	*/
a28 1
#include <netinet/in_systm.h>
@


1.177
log
@revert previous; was based on a work-in-progress, as well
as being an incomplete and therefore incorrect adaptation

apologies to anybody who got bitten by this mistake

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.176 2014/08/29 09:03:36 blambert Exp $	*/
d1991 1
a1991 1
	if ((proto->sslflags & SSLFLAG_TLSV1) == 0)
d1993 4
@


1.176
log
@Implement consistent host hashing for relayd, based on
work done by andre@@

Re-add a randomized hash seed (which had apparently
gotten inadvertently removed in the past).

Allows for multiple relayd instances to be configured
to forward traffic to the same host, falling back to
the random seed when not explicitly configured to do so.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.175 2014/07/14 00:11:12 bluhm Exp $	*/
a74 5
int		 relay_host_ring_lookup(u_int32_t, struct table *);
void		 relay_host_ring_update(struct table *);
u_int32_t	 relay_host_ring_hash(u_int32_t);
static int	 relay_host_ring_cmp(const void *, const void *);

d434 1
a434 2
				    hash32_str(rlay->rl_conf.name,
				    rlt->rlt_key);
a444 2
				host->ringkey = relay_hash_addr(&host->conf.ss,
				    HASHINIT);
d1235 1
d1238 3
a1240 3
		idx = relay_host_ring_lookup(p, table);
		break;
	case RELAY_DSTMODE_LOADBALANCE:
a1241 2
		/* Source IP address without port */
		p = relay_hash_addr(&con->se_in.ss, p);
a1245 1
		idx = relay_host_ring_lookup(p, table);
d1251 1
a1251 1
	if (idx == -1)
a2649 61
}

static int
relay_host_ring_cmp(const void *aa, const void *bb)
{
	const struct host_ring *a = aa;
	const struct host_ring *b = bb;

	if (a->ringkey < b->ringkey)
		return (-1);
	else if (a->ringkey > b->ringkey)
		return (1);
	else
		return (0);
}

int
relay_host_ring_lookup(u_int32_t dstkey, struct table *table)
{
	struct host_ring	*r;
	int			 n = table->nhosts;

	if (!table->up)
		return (-1);

	do {
		r = &table->host_ring[--n];
		if (dstkey > r->ringkey)
			break;
	} while (n);
	if (n == 0 && dstkey < r->ringkey)
		r = &table->host_ring[table->nhosts - 1];
	return (r->host->idx);
}

void
relay_host_ring_update(struct table *table)
{
	struct host	*host;
	int		 nhosts = 0;

	if (table->up == table->lastup)
		return;

	table->lastup = table->up;
	bzero(&table->host_ring, sizeof(table->host_ring));
	if (!table->up)
		return;

	TAILQ_FOREACH(host, &table->hosts, entry) {
		if (host->up  != HOST_UP)
			continue;
		table->host_ring[nhosts].ringkey = host->ringkey;
		table->host_ring[nhosts].host = host;
		nhosts++;
	}

	if (nhosts)
		qsort(table->host_ring, nhosts, sizeof(struct host_ring),
		    relay_host_ring_cmp);
	table->nhosts = nhosts;
@


1.175
log
@When a connection was spliced in one direction and in copy mode in
the other direction, the timeouts did not work.  They were longer
than specified.  Link the splicing and non-splicing timeouts.
Found by make run-regress-args-timeout-http.pl
OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.174 2014/07/13 00:32:08 benno Exp $	*/
d75 5
d439 2
a440 1
				    hash32_str(rlay->rl_conf.name, HASHINIT);
d451 2
d1243 4
d1248 1
a1250 4
		if (rlt->rlt_mode == RELAY_DSTMODE_SRCHASH)
			break;
		/* FALLTHROUGH */
	case RELAY_DSTMODE_HASH:
d1255 1
d1261 1
a1261 1
	if (idx == -1 && (idx = p % rlt->rlt_nhosts) >= RELAY_MAXHOSTS)
d2660 61
@


1.174
log
@improve log output for relays. adjust regress tests
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.173 2014/07/11 16:59:38 reyk Exp $	*/
d814 1
d946 1
d967 3
@


1.173
log
@Add support for EDH to provide perfect forward secrecy for older SSL
clients.  Additionally, add options for disallowing client-initiated
renegotiations and to prefer the server's cipher list over the
client's preferences.

This work is based on a diff by Markus Gebert at hostpoint.ch, and was
discussed with jsing@@ resulting in a few different defaults.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.172 2014/07/09 16:42:05 reyk Exp $	*/
d1087 1
d2657 8
@


1.172
log
@Replace the protocol directives for HTTP with a new generic filtering
language.  The grammar is inspired by pf and allows to write versatile
last-matching filter rules in protocol sections starting with the
"pass", "block" or "match" keywords.  This work was started almost two
years ago and replaces large parts of relayd(8)'s HTTP and filtering
code.  The initial version reimplements and extends HTTP filtering,
but will be improved to support generic TCP and other protocols later.

With some testing, feedback, and help from benno@@ and andre@@.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.171 2014/06/27 07:49:08 andre Exp $	*/
d46 1
d76 3
d1854 97
d1977 2
d1988 3
d2001 5
d2067 1
d2096 7
a2102 1
	if (cre->dir == RELAY_DIR_REQUEST)
d2104 3
a2106 1
	else
d2108 1
d2110 1
d2291 5
d2365 5
@


1.171
log
@knf, no functional change.
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.170 2014/05/20 17:33:36 reyk Exp $	*/
a58 1
void		 relay_nodedebug(const char *, struct protonode *);
d60 1
a85 2
static __inline int
		 relay_proto_cmp(struct protonode *, struct protonode *);
d105 1
d107 3
a109 1
	return (proc_run(ps, p, procs, nitems(procs), relay_init, NULL));
d120 1
a120 1
relay_nodedebug(const char *name, struct protonode *pn)
d122 2
a123 5
	const char	*s;
	int		 digest;

	if (pn->action == NODE_ACTION_NONE)
		return;
a125 1
	fprintf(stderr, "%s ", name);
d127 3
a129 5
	switch (pn->type) {
	case NODE_TYPE_HEADER:
		break;
	case NODE_TYPE_QUERY:
		fprintf(stderr, "query ");
d131 2
a132 2
	case NODE_TYPE_COOKIE:
		fprintf(stderr, "cookie ");
d134 2
a135 5
	case NODE_TYPE_PATH:
		fprintf(stderr, "path ");
		break;
	case NODE_TYPE_URL:
		fprintf(stderr, "url ");
d139 2
a140 4
	switch (pn->action) {
	case NODE_ACTION_APPEND:
		fprintf(stderr, "append \"%s\" to \"%s\"",
		    pn->value, pn->key);
d142 2
a143 3
	case NODE_ACTION_CHANGE:
		fprintf(stderr, "change \"%s\" to \"%s\"",
		    pn->key, pn->value);
d145 2
a146 3
	case NODE_ACTION_REMOVE:
		fprintf(stderr, "remove \"%s\"",
		    pn->key);
d148 3
a150 25
	case NODE_ACTION_EXPECT:
	case NODE_ACTION_FILTER:
		s = pn->action == NODE_ACTION_EXPECT ? "expect" : "filter";
		digest = pn->flags & PNFLAG_LOOKUP_URL_DIGEST;
		if (strcmp(pn->value, "*") == 0)
			fprintf(stderr, "%s %s\"%s\"", s,
			    digest ? "digest " : "", pn->key);
		else
			fprintf(stderr, "%s \"%s\" from \"%s\"", s,
			    pn->value, pn->key);
		break;
	case NODE_ACTION_HASH:
		fprintf(stderr, "hash \"%s\"", pn->key);
		break;
	case NODE_ACTION_LOG:
		fprintf(stderr, "log \"%s\"", pn->key);
		break;
	case NODE_ACTION_MARK:
		if (strcmp(pn->value, "*") == 0)
			fprintf(stderr, "mark \"%s\"", pn->key);
		else
			fprintf(stderr, "mark \"%s\" from \"%s\"",
			    pn->value, pn->key);
		break;
	case NODE_ACTION_NONE:
d153 86
d246 1
a246 4
	struct protonode	*proot, *pn;
	struct proto_tree	*tree;
	const char		*name;
	int			 i;
d274 4
a277 26
	name = "request";
	tree = &proto->request_tree;
 show:
	i = 0;
	RB_FOREACH(proot, proto_tree, tree) {
#if DEBUG > 1
		i = 0;
#endif
		PROTONODE_FOREACH(pn, proot, entry) {
#if DEBUG > 1
			i = 0;
#endif
			if (++i > 100)
				break;
			relay_nodedebug(name, pn);
		}
		/* Limit the number of displayed lines */
		if (++i > 100) {
			fprintf(stderr, "\t\t...\n");
			break;
		}
	}
	if (tree == &proto->request_tree) {
		name = "response";
		tree = &proto->response_tree;
		goto show;
d296 1
a297 1
		/* Use defaults */
d414 7
d455 1
a645 1
	struct protocol		*proto = rlay->rl_proto;
d672 1
a672 2
	DPRINTF("%s: session %d: %ssuccessful", __func__,
	    con->se_id, rlay->rl_proto->lateconnect ? "late connect " : "");
d676 4
a679 10
		/* Check the servers's HTTP response */
		if (!RB_EMPTY(&rlay->rl_proto->response_tree)) {
			con->se_out.toread = TOREAD_HTTP_HEADER;
			outrd = relay_read_http;
			if ((con->se_out.nodes = calloc(proto->response_nodes,
			    sizeof(u_int8_t))) == NULL) {
				relay_abort_http(con, 500,
				    "failed to allocate nodes", 0);
				return;
			}
d681 2
a721 1
	struct protocol *proto = rlay->rl_proto;
d727 4
a730 10
		/* Check the client's HTTP request */
		if (!RB_EMPTY(&rlay->rl_proto->request_tree) ||
		    proto->lateconnect) {
			con->se_in.toread = TOREAD_HTTP_HEADER;
			inrd = relay_read_http;
			if ((con->se_in.nodes = calloc(proto->request_nodes,
			    sizeof(u_int8_t))) == NULL) {
				relay_close(con, "failed to allocate nodes");
				return;
			}
d732 2
a827 20
relay_lognode(struct rsession *con, struct protonode *pn, struct protonode *pk,
    char *buf, size_t len)
{
	const char		*label = NULL;

	if ((pn->flags & PNFLAG_LOG) == 0)
		return (0);
	bzero(buf, len);
	if (pn->label != 0)
		label = pn_id2name(pn->label);
	if (snprintf(buf, len, " [%s%s%s: %s]",
	    label == NULL ? "" : label,
	    label == NULL ? "" : ", ",
	    pk->key, pk->value) == -1 ||
	    evbuffer_add(con->se_log, buf, strlen(buf)) == -1)
		return (-1);
	return (0);
}

int
d864 1
a864 1
	sp.sp_idle = rlay->rl_conf.timeout;
a997 1
	struct protocol		*proto = rlay->rl_proto;
a1050 2
	con->se_in.tree = &proto->request_tree;
	con->se_out.tree = &proto->response_tree;
d1254 2
a1255 1
		DPRINTF("%s: next host %s", __func__, host->conf.name);
d1328 1
a1328 1
	if (!rlay->rl_proto->lateconnect) {
d1566 1
d1585 1
a1585 1
		    "session %d (%d active), %d, %s -> %s:%d, "
d1587 3
a1589 2
		    con->se_mark, ibuf, obuf, ntohs(con->se_out.port), msg,
		    ptr == NULL ? "" : ",", ptr == NULL ? "" : ptr);
d1594 3
a1622 2
	if (con->se_in.path != NULL)
		free(con->se_in.path);
a1624 2
	if (con->se_in.nodes != NULL)
		free(con->se_in.nodes);
a1647 2
	if (con->se_out.path != NULL)
		free(con->se_out.path);
a1649 2
	if (con->se_out.nodes != NULL)
		free(con->se_out.nodes);
d1825 3
a1827 2
	case IMSG_CFG_PROTONODE:
		return (config_getprotonode(env, imsg));
d2341 1
a2341 1
relay_bufferevent_print(struct ctl_relay_event *cre, char *str)
a2513 10
static __inline int
relay_proto_cmp(struct protonode *a, struct protonode *b)
{
	int ret;
	ret = strcasecmp(a->key, b->key);
	if (ret == 0)
		ret = (int)a->type - b->type;
	return (ret);
}

a2525 1
RB_GENERATE(proto_tree, protonode, nodes, relay_proto_cmp);
@


1.170
log
@Unify the SSL privsep key loading functions.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.169 2014/04/22 08:04:23 reyk Exp $	*/
d483 2
a484 2
	int s = -1, val;
	struct linger lng;
d922 3
a924 3
	struct ctl_relay_event *cre = arg;
	struct rsession *con = cre->con;
	struct evbuffer *dst;
d993 8
a1000 8
	struct relay *rlay = arg;
	struct protocol *proto = rlay->rl_proto;
	struct rsession *con = NULL;
	struct ctl_natlook *cnl = NULL;
	socklen_t slen;
	struct timeval tv;
	struct sockaddr_storage ss;
	int s = -1;
d2154 9
a2162 9
	char rbuf[IBUF_READ_SIZE];
	struct bufferevent *bufev = arg;
	struct ctl_relay_event *cre = bufev->cbarg;
	struct rsession *con = cre->con;
	struct relay *rlay = con->se_relay;
	int ret = 0, ssl_err = 0;
	short what = EVBUFFER_READ;
	int howmuch = IBUF_READ_SIZE;
	size_t len;
d2229 6
a2234 6
	struct bufferevent *bufev = arg;
	struct ctl_relay_event *cre = bufev->cbarg;
	struct rsession *con = cre->con;
	struct relay *rlay = con->se_relay;
	int ret = 0, ssl_err;
	short what = EVBUFFER_WRITE;
d2324 2
a2325 2
	int ret;
	va_list ap;
d2379 3
a2381 3
	int ret = -1;
	struct sockaddr_in ia, ib;
	struct sockaddr_in6 ia6, ib6;
@


1.169
log
@Support the CA key for SSL inspection in the ca process.  Instead of
looking up the keys by relay id, add all keys to a list and look them
up by key id.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.168 2014/04/18 13:55:26 reyk Exp $	*/
d1917 1
a1917 1
	    &rlay->rl_conf.ssl_keyid,
d1927 3
a1929 3
		if (!ssl_ctx_load_pkey(ctx,
		    &rlay->rl_conf.ssl_cakeyid, rlay->rl_ssl_cacert,
		    rlay->rl_conf.ssl_cacert_len,
@


1.168
log
@Introduce privsep for private keys:

- Move RSA private keys to a new separate process instead of copying
them to the relays.  A custom RSA engine is used by the SSL/TLS code
of the relay processes to send RSA private key encryption/decryption
(also used for sign/verify) requests to the new "ca" processes instead
of operating on the private key directly.

- Each relay process gets its own related ca process.  Setting
"prefork 5" in the config file will spawn 10 processes (5 relay, 5
ca).  This diff also reduces the default number of relay processes
from 5 to 3 which should be suitable in most installations without a
very heavy load.

- Don't keep text versions of the keys in memory, parse them once and
keep the binary representation.  This might still be the case in
OpenSSL's internals but will be fixed in the library.

This diff doesn't prevent something like "heartbleed" but adds an
additional mitigation to prevent leakage of the private keys from the
processes doing SSL/TLS.

With feedback from many
ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.167 2013/09/09 17:57:44 reyk Exp $	*/
d1917 2
a1918 1
	    &rlay->rl_conf.id, rlay->rl_ssl_cert, rlay->rl_conf.ssl_cert_len,
d1925 9
d1941 1
d2115 2
a2116 3
			    rlay->rl_ssl_pkey,
			    rlay->rl_ssl_cakey, rlay->rl_conf.ssl_cakey_len,
			    rlay->rl_ssl_cacert, rlay->rl_conf.ssl_cacert_len);
@


1.167
log
@Add support for ECDHE (Elliptic curve Diffie-Hellman) to enable
TLS/SSL Perfect Forward Secrecy (PFS).

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.166 2013/05/30 20:17:12 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2013 Reyk Floeter <reyk@@openbsd.org>
d55 2
d101 1
d1788 6
d1916 3
a1918 2
	if (!ssl_ctx_use_private_key(ctx, rlay->rl_ssl_key,
	    rlay->rl_conf.ssl_key_len))
d1920 1
d1929 3
d2104 1
a2104 1
			    rlay->rl_ssl_key, rlay->rl_conf.ssl_key_len,
@


1.166
log
@Support SSL inspection, the ability to transparently filter in SSL/TLS
connections (eg. HTTPS) by using a local CA that is accepted by the
clients.  See the "SSL RELAYS" and "EXAMPLES" sections in the
relayd.conf(5) manpage for more details.

ok benno@@, manpage bits jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.165 2013/04/20 17:45:02 deraadt Exp $	*/
d1844 3
a1846 2
	struct protocol *proto = rlay->rl_proto;
	SSL_CTX *ctx;
d1875 10
@


1.165
log
@SSL_CTX_set_timeout only handles long for the delta timeval, so constrain
it with MIN and LONG_MAX.  It is only an interval, so it is fine.
suggestion by djm, ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.164 2013/03/10 23:32:53 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 - 2012 Reyk Floeter <reyk@@openbsd.org>
d1130 5
d1452 8
d1466 10
d1599 2
d1630 2
d1933 4
d2034 1
d2071 1
a2071 1
	    "relay %s, session %d connected (%d active)",
d2074 19
d2414 25
a2438 5
	if ((rlay->rl_conf.flags & F_SSLCLIENT) && strlen(proto->sslca)) {
		if ((rlay->rl_ssl_ca = relay_load_file(proto->sslca,
		    &rlay->rl_conf.ssl_ca_len)) == NULL)
			return (-1);
		log_debug("%s: using ca %s", __func__, proto->sslca);
d2471 2
a2472 2
	if ((rlay->rl_ssl_key = relay_load_file(certfile,
	    &rlay->rl_conf.ssl_key_len)) == NULL)
@


1.164
log
@This diff changes relayd to use the monotonic clock instead of
gettimeofday().  It was also bugging me for some time to have all
these checks of gettimeofday()'s return value: it should not fail.  So
this diff introduces a void getmonotime(struct timeval *tv) that calls
clock_gettime(CLOCK_MONOTONIC, &ts) and converts the output to a
struct timeval that can be used with the existing code and the
timeval-specific timer functions (timerclear, timersub, ...).  It does
not return a status but calls fatal() on error-that-should-not-happen.

ok sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.163 2013/03/09 14:43:06 bluhm Exp $	*/
d1825 2
a1826 1
	SSL_CTX_set_timeout(ctx, rlay->rl_conf.timeout.tv_sec);
@


1.163
log
@Enable TCP socket splicing for HTTP persistent connection and chunked
transfer encoding.  This speeds up relayd for more protocol modes
by zero-copy TCP forwarding.
OK reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.162 2013/02/05 21:36:33 bluhm Exp $	*/
d321 1
a321 2
	if (gettimeofday(&tv_now, NULL) == -1)
		fatal("relay_init: gettimeofday");
d743 2
a744 2
	if (gettimeofday(&con->se_tv_last, NULL) == -1)
		goto fail;
d782 2
a783 2
	if (gettimeofday(&con->se_tv_last, NULL) == -1)
		goto fail;
d893 2
a894 2
		if (gettimeofday(&con->se_tv_last, NULL) == -1)
			return (-1);
a1050 4
	if (gettimeofday(&con->se_tv_start, NULL) == -1)
		goto err;
	bcopy(&con->se_tv_start, &con->se_tv_last, sizeof(con->se_tv_last));
	bcopy(&ss, &con->se_in.ss, sizeof(con->se_in.ss));
d1060 4
d1456 1
a1456 2
	if (gettimeofday(&con->se_tv_start, NULL) == -1)
		return (-1);
@


1.162
log
@Rework http content and chunk handling in relayd.  Use special
toread values to track the current http header or chunk state.  This
allows to handle an optional chunk trailer properly.  Tracking the
http state is also a prerequisite for splicing persistent http
connections.
OK and test reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.161 2013/01/17 20:34:18 bluhm Exp $	*/
a72 3
int		 relay_splice(struct ctl_relay_event *);
int		 relay_splicelen(struct ctl_relay_event *);

d743 1
d745 1
a745 1
		con->se_done = 1;
d747 9
a755 1
		relay_close(con, "last write (done)");
d833 1
a833 1
	if (cre->bev->readcb != relay_read)
d836 19
d857 1
d865 6
a870 3
	DPRINTF("%s: session %d: splice dir %d successful",
	    __func__, con->se_id, cre->dir);
	return (1);
d880 3
d889 4
d894 2
d899 15
d956 2
d960 6
@


1.161
log
@Remove unnecessary pointer casts.  No binary diff.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.160 2012/12/18 15:58:25 reyk Exp $	*/
d646 1
d703 1
d979 2
@


1.160
log
@reorder some variables and move large buffers to the top of the stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.159 2012/11/29 01:01:53 bluhm Exp $	*/
d610 2
a611 2
	struct rsession		*con = (struct rsession *)arg;
	struct relay		*rlay = (struct relay *)con->se_relay;
d692 1
a692 1
	struct relay	*rlay = (struct relay *)con->se_relay;
d742 1
a742 1
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
d771 1
a771 1
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
d817 1
a817 1
	struct relay		*rlay = (struct relay *)con->se_relay;
d865 1
a865 1
	struct ctl_relay_event *cre = (struct ctl_relay_event *)arg;
d928 1
a928 1
	struct relay *rlay = (struct relay *)arg;
d1036 1
a1036 2
		if ((cnl = (struct ctl_natlook *)
		    calloc(1, sizeof(struct ctl_natlook))) == NULL) {
d1105 1
a1105 1
	struct relay		*rlay = (struct relay *)con->se_relay;
d1202 2
a1203 2
	struct rsession		*con = (struct rsession *)arg;
	struct relay		*rlay = (struct relay *)con->se_relay;
d1228 1
a1228 1
	struct relay		*rlay = (struct relay *)con->se_relay;
d1269 1
a1269 1
	struct relay		*rlay = (struct relay *)con->se_relay;
d1291 1
a1291 1
	struct rsession	*con = (struct rsession *)arg;
d1305 2
a1306 2
	struct rsession	*con = (struct rsession *)arg;
	struct relay	*rlay = (struct relay *)con->se_relay;
d1385 1
a1385 1
	struct relay	*rlay = (struct relay *)con->se_relay;
d1474 1
a1474 1
	struct relay	*rlay = (struct relay *)con->se_relay;
d1828 1
a1828 1
	struct relay		*rlay = (struct relay *)con->se_relay;
d1876 2
a1877 2
	struct rsession	*con = (struct rsession *)arg;
	struct relay	*rlay = (struct relay *)con->se_relay;
d1934 2
a1935 2
	struct rsession	*con = (struct rsession *)arg;
	struct relay	*rlay = (struct relay *)con->se_relay;
d2006 1
a2006 1
	struct ctl_relay_event *cre = (struct ctl_relay_event *)bufev->cbarg;
d2008 1
a2008 1
	struct relay *rlay = (struct relay *)con->se_relay;
d2080 1
a2080 1
	struct ctl_relay_event *cre = (struct ctl_relay_event *)bufev->cbarg;
d2082 1
a2082 1
	struct relay *rlay = (struct relay *)con->se_relay;
d2274 1
a2274 1
	if ((buf = (char *)calloc(1, size + 1)) == NULL)
d2357 1
a2357 1
	struct relay	*rlay = (struct relay *)b->se_relay;
@


1.159
log
@Fix white spaces in relayd.  No binary diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.158 2012/11/27 05:00:28 guenther Exp $	*/
d1474 1
a1475 1
	char		 ibuf[128], obuf[128], *ptr = NULL;
d1879 2
a1881 2
	int		 ssl_err;
	int		 retry_flag;
a1887 2
	retry_flag = ssl_err = 0;

d1937 2
a1939 2
	int		 ssl_err;
	int		 retry_flag;
a1945 2
	retry_flag = ssl_err = 0;

d2005 1
d2012 1
a2013 2
	char rbuf[IBUF_READ_SIZE];
	int howmuch = IBUF_READ_SIZE;
d2295 2
a2298 2
	char	 certfile[PATH_MAX];
	char	 hbuf[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];
a2354 2
RB_GENERATE(proto_tree, protonode, nodes, relay_proto_cmp);

d2367 1
@


1.158
log
@Add format attributes to the proper functions and then fix the warnings
that gcc then reports when compiling with -DDEBUG=2

ok reyk@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.157 2012/10/19 16:49:50 reyk Exp $	*/
d1074 1
a1074 1
		/* 
d1321 1
a1321 1
        /*
d1517 1
a1517 1
			/* 
@


1.157
log
@Support additional scheduling algorithms in the load balancer:
least-states, random, source-hash.  least-states is currently only
supported for redirections and the other ones are currently only
supported by relays.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.156 2012/10/04 20:53:30 reyk Exp $	*/
d943 1
a943 1
	    (socklen_t *)&slen, FD_RESERVE, &relay_inflight)) == -1) {
d953 1
a953 2
			log_debug("%s: deferring connections",__func__,
			    relay_inflight);
@


1.156
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.155 2012/10/03 08:40:40 reyk Exp $	*/
d390 1
d395 1
d1112 1
a1112 1
	int			 idx = 0;
d1150 4
d1155 1
d1157 2
d1161 1
d1165 4
a1168 2
		if ((idx = p % rlt->rlt_nhosts) >= RELAY_MAXHOSTS)
			return (-1);
d1170 2
@


1.155
log
@Inherit and pass the relay table flags correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.154 2012/10/03 08:33:31 reyk Exp $	*/
d629 1
a629 1
		return;		
d1323 1
a1323 1
		relay_abort_http(con, 504, "connection timed out", 0);		
d1342 1
a1342 1
		if ((errno == ENFILE || errno == EMFILE) && 
d1434 2
a1435 1
				    con->se_retry ? "next retry" : "last retry");
d1438 2
a1439 2
			log_debug("%s: session %d: forward failed: %s", __func__,
			    con->se_id, strerror(errno));
d1442 1
a1442 1
	}	
@


1.154
log
@Support more than one relay backup table.  Instead of duplicating the
code for main and backup table all over the place, turn the relay
tables into a list attached to the relay.  This improves the code and
allows some other tricks with multiple tables later.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.153 2012/09/21 09:56:27 benno Exp $	*/
d1124 1
a1124 1
		if ((rlt->rlt_flags & F_USED == 0) ||
@


1.153
log
@file descriptor accounting for relays: track how many connections to
backend servers are unopened and reserve fds for them.
ok reyk@@, "don't wait" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.152 2012/09/20 12:30:20 reyk Exp $	*/
d377 4
a380 3
	void		(*callback)(int, short, void *);
	struct relay	*rlay;
	struct host	*host;
d387 2
a388 2
		if (rlay->rl_dsttable != NULL) {
			switch (rlay->rl_conf.dstmode) {
d390 1
a390 1
				rlay->rl_dstkey = 0;
d394 1
a394 1
				rlay->rl_dstkey =
d396 3
a398 3
				rlay->rl_dstkey =
				    hash32_str(rlay->rl_dsttable->conf.name,
				    rlay->rl_dstkey);
d401 3
a403 3
			rlay->rl_dstnhosts = 0;
			TAILQ_FOREACH(host, &rlay->rl_dsttable->hosts, entry) {
				if (rlay->rl_dstnhosts >= RELAY_MAXHOSTS)
d406 2
a407 2
				host->idx = rlay->rl_dstnhosts;
				rlay->rl_dsthost[rlay->rl_dstnhosts++] = host;
d410 2
a411 2
			    rlay->rl_dstnhosts, rlay->rl_dsttable->conf.name,
			    rlay->rl_dsttable->conf.check ? "" : " (no check)");
a979 1
	con->se_hashkey = rlay->rl_dstkey;
d1107 2
a1108 1
	struct table		*table = rlay->rl_dsttable;
d1112 23
a1134 2
	if (table->conf.check && !table->up && !rlay->rl_backuptable->up) {
		log_debug("%s: no active hosts", __func__);
d1136 4
a1139 2
	} else if (!table->up && rlay->rl_backuptable->up) {
		table = rlay->rl_backuptable;
d1142 1
a1142 1
	switch (rlay->rl_conf.dstmode) {
d1144 3
a1146 3
		if ((int)rlay->rl_dstkey >= rlay->rl_dstnhosts)
			rlay->rl_dstkey = 0;
		idx = (int)rlay->rl_dstkey;
d1155 1
a1155 1
		if ((idx = p % rlay->rl_dstnhosts) >= RELAY_MAXHOSTS)
d1158 3
a1160 3
	host = rlay->rl_dsthost[idx];
	DPRINTF("%s: host %s, p 0x%08x, idx %d", __func__,
	    host->conf.name, p, idx);
d1162 2
a1163 1
		DPRINTF("%s: host %s", __func__, host->conf.name);
d1178 2
a1179 2
	if (rlay->rl_conf.dstmode == RELAY_DSTMODE_ROUNDROBIN)
		rlay->rl_dstkey = host->idx + 1;
d1199 1
a1199 1
	    rlay->rl_dsttable == NULL) {
d1383 1
a1383 1
	if (rlay->rl_dsttable != NULL) {
d1718 3
@


1.152
log
@Move the HTTP code into an extra file to make future changes easier to
follow.  No functional changes, only one function got renamed.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.151 2012/09/17 19:27:38 benno Exp $	*/
d80 1
d92 2
a93 1
volatile sig_atomic_t relay_sessions;
d939 2
a940 1
	if ((s = accept(fd, (struct sockaddr *)&ss, (socklen_t *)&slen)) == -1) {
d950 2
d1073 7
a1259 1

d1264 81
d1349 1
d1352 3
d1394 21
a1414 7
		if (con->se_retry) {
			con->se_retry--;
			log_debug("%s: session %d: "
			    "forward failed: %s, %s", __func__,
			    con->se_id, strerror(errno),
			    con->se_retry ? "next retry" : "last retry");
			goto retry;
d1416 5
a1420 4
		log_debug("%s: session %d: forward failed: %s", __func__,
		    con->se_id, strerror(errno));
		return (-1);
	}
d1475 1
a1475 1
	if (con->se_in.s != -1)
d1477 10
@


1.151
log
@Fix relay statistics. Found and fix by Erik Lax (erik -at- halon -dot- se)
ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.150 2012/07/13 07:54:14 benno Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006, 2007, 2008 Reyk Floeter <reyk@@openbsd.org>
a70 5
int		 relay_connect(struct rsession *);
void		 relay_connected(int, short, void *);
void		 relay_bindanyreq(struct rsession *, in_port_t, int);
void		 relay_bindany(int, short, void *);

a72 5
void		 relay_write(struct bufferevent *, void *);
void		 relay_read(struct bufferevent *, void *);
void		 relay_error(struct bufferevent *, short, void *);
void		 relay_dump(struct ctl_relay_event *, const void *, size_t);

a75 22
int		 relay_resolve(struct ctl_relay_event *,
		    struct protonode *, struct protonode *);
int		 relay_handle_http(struct ctl_relay_event *,
		    struct protonode *, struct protonode *,
		    struct protonode *, int);
int		 relay_lognode(struct rsession *,
		    struct protonode *, struct protonode *, char *, size_t);
void		 relay_read_http(struct bufferevent *, void *);
static int	_relay_lookup_url(struct ctl_relay_event *, char *, char *,
		    char *, enum digest_type);
int		 relay_lookup_url(struct ctl_relay_event *,
		    const char *, enum digest_type);
int		 relay_lookup_query(struct ctl_relay_event *);
int		 relay_lookup_cookie(struct ctl_relay_event *, const char *);
void		 relay_read_httpcontent(struct bufferevent *, void *);
void		 relay_read_httpchunks(struct bufferevent *, void *);
char		*relay_expand_http(struct ctl_relay_event *, char *,
		    char *, size_t);
void		 relay_close_http(struct rsession *, u_int, const char *,
		    u_int16_t);
void		 relay_http_request_close(struct ctl_relay_event *);

a84 12
int		 relay_bufferevent_add(struct event *, int);
#ifdef notyet
int		 relay_bufferevent_printf(struct ctl_relay_event *,
		    const char *, ...);
#endif
int		 relay_bufferevent_print(struct ctl_relay_event *, char *);
int		 relay_bufferevent_write_buffer(struct ctl_relay_event *,
		    struct evbuffer *);
int		 relay_bufferevent_write_chunk(struct ctl_relay_event *,
		    struct evbuffer *, size_t);
int		 relay_bufferevent_write(struct ctl_relay_event *,
		    void *, size_t);
d616 1
a616 1
		relay_close_http(con, 504, "connect timeout", 0);
d625 1
a625 1
		relay_close_http(con, 500, "socket error", 0);
d644 1
a644 1
				relay_close_http(con, 500,
d662 1
a662 1
		relay_close_http(con, 500,
a788 121
relay_resolve(struct ctl_relay_event *cre,
    struct protonode *proot, struct protonode *pn)
{
	struct rsession		*con = cre->con;
	char			 buf[IBUF_READ_SIZE], *ptr;
	int			 id;

	if (pn->mark && (pn->mark != con->se_mark))
		return (0);

	switch (pn->action) {
	case NODE_ACTION_FILTER:
		id = cre->nodes[proot->id];
		if (SIMPLEQ_NEXT(pn, entry) == NULL)
			cre->nodes[proot->id] = 0;
		if (id <= 1)
			return (0);
		break;
	case NODE_ACTION_EXPECT:
		id = cre->nodes[proot->id];
		if (SIMPLEQ_NEXT(pn, entry) == NULL)
			cre->nodes[proot->id] = 0;
		if (id > 1)
			return (0);
		break;
	default:
		if (cre->nodes[pn->id]) {
			cre->nodes[pn->id] = 0;
			return (0);
		}
		break;
	}
	switch (pn->action) {
	case NODE_ACTION_APPEND:
	case NODE_ACTION_CHANGE:
		ptr = pn->value;
		if ((pn->flags & PNFLAG_MACRO) &&
		    (ptr = relay_expand_http(cre, pn->value,
		    buf, sizeof(buf))) == NULL)
			break;
		if (relay_bufferevent_print(cre->dst, pn->key) == -1 ||
		    relay_bufferevent_print(cre->dst, ": ") == -1 ||
		    relay_bufferevent_print(cre->dst, ptr) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
			relay_close_http(con, 500,
			    "failed to modify header", 0);
			return (-1);
		}
		DPRINTF("%s: add '%s: %s'", __func__, pn->key, ptr);
		break;
	case NODE_ACTION_EXPECT:
		DPRINTF("%s: missing '%s: %s'", __func__, pn->key, pn->value);
		relay_close_http(con, 403, "incomplete request", pn->label);
		return (-1);
	case NODE_ACTION_FILTER:
		DPRINTF("%s: filtered '%s: %s'", __func__, pn->key, pn->value);
		relay_close_http(con, 403, "rejecting request", pn->label);
		return (-1);
	default:
		break;
	}
	return (0);
}

char *
relay_expand_http(struct ctl_relay_event *cre, char *val, char *buf, size_t len)
{
	struct rsession	*con = cre->con;
	struct relay	*rlay = (struct relay *)con->se_relay;
	char		 ibuf[128];

	(void)strlcpy(buf, val, len);

	if (strstr(val, "$REMOTE_") != NULL) {
		if (strstr(val, "$REMOTE_ADDR") != NULL) {
			if (print_host(&cre->ss, ibuf, sizeof(ibuf)) == NULL)
				return (NULL);
			if (expand_string(buf, len,
			    "$REMOTE_ADDR", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$REMOTE_PORT") != NULL) {
			snprintf(ibuf, sizeof(ibuf), "%u", ntohs(cre->port));
			if (expand_string(buf, len,
			    "$REMOTE_PORT", ibuf) != 0)
				return (NULL);
		}
	}
	if (strstr(val, "$SERVER_") != NULL) {
		if (strstr(val, "$SERVER_ADDR") != NULL) {
			if (print_host(&rlay->rl_conf.ss,
			    ibuf, sizeof(ibuf)) == NULL)
				return (NULL);
			if (expand_string(buf, len,
			    "$SERVER_ADDR", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$SERVER_PORT") != NULL) {
			snprintf(ibuf, sizeof(ibuf), "%u",
			    ntohs(rlay->rl_conf.port));
			if (expand_string(buf, len,
			    "$SERVER_PORT", ibuf) != 0)
				return (NULL);
		}
		if (strstr(val, "$SERVER_NAME") != NULL) {
			if (expand_string(buf, len,
			    "$SERVER_NAME", RELAYD_SERVERNAME) != 0)
				return (NULL);
		}
	}
	if (strstr(val, "$TIMEOUT") != NULL) {
		snprintf(ibuf, sizeof(ibuf), "%lu",
		    rlay->rl_conf.timeout.tv_sec);
		if (expand_string(buf, len, "$TIMEOUT", ibuf) != 0)
			return (NULL);
	}

	return (buf);
}

int
a805 893
}

int
relay_handle_http(struct ctl_relay_event *cre, struct protonode *proot,
    struct protonode *pn, struct protonode *pk, int header)
{
	struct rsession		*con = cre->con;
	char			 buf[IBUF_READ_SIZE], *ptr;
	int			 ret = PN_DROP, mark = 0;
	struct protonode	*next;

	/* Check if this action depends on a marked session */
	if (pn->mark != 0)
		mark = pn->mark == con->se_mark ? 1 : -1;

	switch (pn->action) {
	case NODE_ACTION_EXPECT:
	case NODE_ACTION_FILTER:
	case NODE_ACTION_MARK:
		break;
	default:
		if (mark == -1)
			return (PN_PASS);
		break;
	}

	switch (pn->action) {
	case NODE_ACTION_APPEND:
		if (!header)
			return (PN_PASS);
		ptr = pn->value;
		if ((pn->flags & PNFLAG_MACRO) &&
		    (ptr = relay_expand_http(cre, pn->value,
		    buf, sizeof(buf))) == NULL)
			break;
		if (relay_bufferevent_print(cre->dst, pn->key) == -1 ||
		    relay_bufferevent_print(cre->dst, ": ") == -1 ||
		    relay_bufferevent_print(cre->dst, pk->value) == -1 ||
		    relay_bufferevent_print(cre->dst, ", ") == -1 ||
		    relay_bufferevent_print(cre->dst, ptr) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1)
			goto fail;
		cre->nodes[pn->id] = 1;
		DPRINTF("%s: append '%s: %s, %s'", __func__,
		    pk->key, pk->value, ptr);
		break;
	case NODE_ACTION_CHANGE:
	case NODE_ACTION_REMOVE:
		if (!header)
			return (PN_PASS);
		DPRINTF("%s: change/remove '%s: %s'", __func__,
		    pk->key, pk->value);
		break;
	case NODE_ACTION_EXPECT:
		/*
		 * A client may specify the header line for multiple times
		 * trying to circumvent the filter.
		 */
		if (cre->nodes[proot->id] > 1) {
			relay_close_http(con, 400, "repeated header line", 0);
			return (PN_FAIL);
		}
		/* FALLTHROUGH */
	case NODE_ACTION_FILTER:
		DPRINTF("%s: %s '%s: %s'", __func__,
		    (pn->action == NODE_ACTION_EXPECT) ? "expect" : "filter",
		    pn->key, pn->value);

		/* Do not drop the entity */
		ret = PN_PASS;

		if (mark != -1 &&
		    fnmatch(pn->value, pk->value, FNM_CASEFOLD) == 0) {
			cre->nodes[proot->id] = 1;

			/* Fail instantly */
			if (pn->action == NODE_ACTION_FILTER) {
				(void)relay_lognode(con, pn, pk,
				    buf, sizeof(buf));
				relay_close_http(con, 403,
				    "rejecting request", pn->label);
				return (PN_FAIL);
			}
		}
		next = SIMPLEQ_NEXT(pn, entry);
		if (next == NULL || next->action != pn->action)
			cre->nodes[proot->id]++;
		break;
	case NODE_ACTION_HASH:
		DPRINTF("%s: hash '%s: %s'", __func__,
		    pn->key, pk->value);
		con->se_hashkey = hash32_str(pk->value, con->se_hashkey);
		ret = PN_PASS;
		break;
	case NODE_ACTION_LOG:
		log_info("%s: log '%s: %s'", __func__, pn->key, pk->value);
		ret = PN_PASS;
		break;
	case NODE_ACTION_MARK:
		DPRINTF("%s: mark '%s: %s'", __func__,
		    pn->key, pk->value);
		if (fnmatch(pn->value, pk->value, FNM_CASEFOLD) == 0)
			con->se_mark = pn->mark;
		ret = PN_PASS;
		break;
	case NODE_ACTION_NONE:
		return (PN_PASS);
	}
	if (mark != -1 && relay_lognode(con, pn, pk, buf, sizeof(buf)) == -1)
		goto fail;

	return (ret);
 fail:
	relay_close_http(con, 500, strerror(errno), 0);
	return (PN_FAIL);
}

void
relay_read_httpcontent(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
	struct rsession		*con = cre->con;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	size_t			 size;

	if (gettimeofday(&con->se_tv_last, NULL) == -1)
		goto fail;
	size = EVBUFFER_LENGTH(src);
	DPRINTF("%s: size %lu, to read %llu", __func__,
	    size, cre->toread);
	if (!size)
		return;
	if (relay_bufferevent_write_buffer(cre->dst, src) == -1)
		goto fail;
	if ((off_t)size >= cre->toread)
		bev->readcb = relay_read_http;
	cre->toread -= size;
	DPRINTF("%s: done, size %lu, to read %llu", __func__,
	    size, cre->toread);
	if (con->se_done)
		goto done;
	if (bev->readcb != relay_read_httpcontent)
		bev->readcb(bev, arg);
	bufferevent_enable(bev, EV_READ);
	return;
 done:
	relay_close(con, "last http content read");
	return;
 fail:
	relay_close(con, strerror(errno));
}

void
relay_read_httpchunks(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
	struct rsession		*con = cre->con;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	char			*line;
	long			 lval;
	size_t			 size;

	if (gettimeofday(&con->se_tv_last, NULL) == -1)
		goto fail;
	size = EVBUFFER_LENGTH(src);
	DPRINTF("%s: size %lu, to read %llu", __func__,
	    size, cre->toread);
	if (!size)
		return;

	if (!cre->toread) {
		line = evbuffer_readline(src);
		if (line == NULL) {
			/* Ignore empty line, continue */
			bufferevent_enable(bev, EV_READ);
			return;
		}
		if (!strlen(line)) {
			free(line);
			goto next;
		}

		/* Read prepended chunk size in hex, ingore the trailer */
		if (sscanf(line, "%lx", &lval) != 1) {
			free(line);
			relay_close(con, "invalid chunk size");
			return;
		}

		if (relay_bufferevent_print(cre->dst, line) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
			free(line);
			goto fail;
		}
		free(line);

		/* Last chunk is 0 bytes followed by an empty newline */
		if ((cre->toread = lval) == 0) {
			DPRINTF("%s: last chunk", __func__);

			line = evbuffer_readline(src);
			if (line == NULL) {
				relay_close(con, "invalid last chunk");
				return;
			}
			free(line);
			if (relay_bufferevent_print(cre->dst, "\r\n") == -1)
				goto fail;

			/* Switch to HTTP header mode */
			bev->readcb = relay_read_http;
		}
	} else {
		/* Read chunk data */
		if ((off_t)size > cre->toread)
			size = cre->toread;
		if (relay_bufferevent_write_chunk(cre->dst, src, size) == -1)
			goto fail;
		cre->toread -= size;
		DPRINTF("%s: done, size %lu, to read %llu", __func__,
		    size, cre->toread);

		if (cre->toread == 0) {
			/* Chunk is terminated by an empty (empty) newline */
			line = evbuffer_readline(src);
			if (line != NULL)
				free(line);
			if (relay_bufferevent_print(cre->dst, "\r\n\r\n") == -1)
				goto fail;
		}
	}

 next:
	if (con->se_done)
		goto done;
	if (EVBUFFER_LENGTH(src))
		bev->readcb(bev, arg);
	bufferevent_enable(bev, EV_READ);
	return;

 done:
	relay_close(con, "last http chunk read (done)");
	return;
 fail:
	relay_close(con, strerror(errno));
}

void
relay_http_request_close(struct ctl_relay_event *cre)
{
	if (cre->path != NULL) {
		free(cre->path);
		cre->path = NULL;
	}

	cre->args = NULL;
	cre->version = NULL;

	if (cre->buf != NULL) {
		free(cre->buf);
		cre->buf = NULL;
		cre->buflen = 0;
	}

	cre->line = 0;
	cre->method = 0;
	cre->done = 0;
	cre->chunked = 0;
}

void
relay_read_http(struct bufferevent *bev, void *arg)
{
	struct ctl_relay_event	*cre = (struct ctl_relay_event *)arg;
	struct rsession		*con = cre->con;
	struct relay		*rlay = (struct relay *)con->se_relay;
	struct protocol		*proto = rlay->rl_proto;
	struct evbuffer		*src = EVBUFFER_INPUT(bev);
	struct protonode	*pn, pk, *proot, *pnv = NULL, pkv;
	char			*line;
	int			 header = 0, ret, pass = 0;
	const char		*errstr;
	size_t			 size;

	if (gettimeofday(&con->se_tv_last, NULL) == -1)
		goto fail;
	size = EVBUFFER_LENGTH(src);
	DPRINTF("%s: size %lu, to read %llu", __func__, size, cre->toread);
	if (!size) {
		if (cre->dir == RELAY_DIR_RESPONSE)
			return;
		cre->toread = 0;
		goto done;
	}

	pk.type = NODE_TYPE_HEADER;

	while (!cre->done && (line = evbuffer_readline(src)) != NULL) {
		/*
		 * An empty line indicates the end of the request.
		 * libevent already stripped the \r\n for us.
		 */
		if (!strlen(line)) {
			cre->done = 1;
			free(line);
			break;
		}
		pk.key = line;

		/*
		 * The first line is the GET/POST/PUT/... request,
		 * subsequent lines are HTTP headers.
		 */
		if (++cre->line == 1) {
			pk.value = strchr(pk.key, ' ');
		} else
			pk.value = strchr(pk.key, ':');
		if (pk.value == NULL || strlen(pk.value) < 3) {
			if (cre->line == 1) {
				free(line);
				relay_close_http(con, 400, "malformed", 0);
				return;
			}

			DPRINTF("%s: request '%s'", __func__, line);
			/* Append line to the output buffer */
			if (relay_bufferevent_print(cre->dst, line) == -1 ||
			    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
				free(line);
				goto fail;
			}
			free(line);
			continue;
		}
		if (*pk.value == ':') {
			*pk.value++ = '\0';
			pk.value += strspn(pk.value, " \t\r\n");
			header = 1;
		} else {
			*pk.value++ = '\0';
			header = 0;
		}

		DPRINTF("%s: header '%s: %s'", __func__, pk.key, pk.value);

		/*
		 * Identify and handle specific HTTP request methods
		 */
		if (cre->line == 1) {
			if (cre->dir == RELAY_DIR_RESPONSE) {
				cre->method = HTTP_METHOD_RESPONSE;
				goto lookup;
			} else if (strcmp("HEAD", pk.key) == 0)
				cre->method = HTTP_METHOD_HEAD;
			else if (strcmp("POST", pk.key) == 0)
				cre->method = HTTP_METHOD_POST;
			else if (strcmp("PUT", pk.key) == 0)
				cre->method = HTTP_METHOD_PUT;
			else if (strcmp("DELETE", pk.key) == 0)
				cre->method = HTTP_METHOD_DELETE;
			else if (strcmp("OPTIONS", pk.key) == 0)
				cre->method = HTTP_METHOD_OPTIONS;
			else if (strcmp("TRACE", pk.key) == 0)
				cre->method = HTTP_METHOD_TRACE;
			else if (strcmp("CONNECT", pk.key) == 0)
				cre->method = HTTP_METHOD_CONNECT;
			else {
				/* Use GET method as the default */
				cre->method = HTTP_METHOD_GET;
			}

			/*
			 * Decode the path and query
			 */
			cre->path = strdup(pk.value);
			if (cre->path == NULL) {
				free(line);
				goto fail;
			}
			cre->version = strchr(cre->path, ' ');
			if (cre->version != NULL)
				*cre->version++ = '\0';
			cre->args = strchr(cre->path, '?');
			if (cre->args != NULL)
				*cre->args++ = '\0';
#ifdef DEBUG
			char	 buf[BUFSIZ];
			if (snprintf(buf, sizeof(buf), " \"%s\"",
			    cre->path) == -1 ||
			    evbuffer_add(con->se_log, buf, strlen(buf)) == -1) {
				free(line);
				goto fail;
			}
#endif

			/*
			 * Lookup protocol handlers in the URL path
			 */
			if ((proto->flags & F_LOOKUP_PATH) == 0)
				goto lookup;

			pkv.key = cre->path;
			pkv.type = NODE_TYPE_PATH;
			pkv.value = cre->args == NULL ? "" : cre->args;

			DPRINTF("%s: lookup path '%s: %s'",
			    __func__, pkv.key, pkv.value);

			if ((proot = RB_FIND(proto_tree,
			    cre->tree, &pkv)) == NULL)
				goto lookup;

			PROTONODE_FOREACH(pnv, proot, entry) {
				ret = relay_handle_http(cre, proot,
				    pnv, &pkv, 0);
				if (ret == PN_FAIL)
					goto abort;
			}
		} else if ((cre->method == HTTP_METHOD_DELETE ||
		    cre->method == HTTP_METHOD_GET ||
		    cre->method == HTTP_METHOD_HEAD ||
		    cre->method == HTTP_METHOD_OPTIONS ||
		    cre->method == HTTP_METHOD_POST ||
		    cre->method == HTTP_METHOD_PUT ||
		    cre->method == HTTP_METHOD_RESPONSE) &&
		    strcasecmp("Content-Length", pk.key) == 0) {
			/*
			 * Need to read data from the client after the
			 * HTTP header.
			 * XXX What about non-standard clients not using
			 * the carriage return? And some browsers seem to
			 * include the line length in the content-length.
			 */
			cre->toread = strtonum(pk.value, 0, ULLONG_MAX, &errstr);
			if (errstr) {
				relay_close_http(con, 500, errstr, 0);
				goto abort;
			}
		} else if ((cre->method == HTTP_METHOD_TRACE) &&
		    strcasecmp("Content-Length", pk.key) == 0) {
			/*
			 * This method should not have a body and thus no
			 * Content-Length header.
			 */
			relay_close_http(con, 400, "malformed", 0);
			goto abort;
		}
 lookup:
		if (strcasecmp("Transfer-Encoding", pk.key) == 0 &&
		    strcasecmp("chunked", pk.value) == 0)
			cre->chunked = 1;

		/* Match the HTTP header */
		if ((pn = RB_FIND(proto_tree, cre->tree, &pk)) == NULL)
			goto next;

		if (cre->dir == RELAY_DIR_RESPONSE)
			goto handle;

		if (pn->flags & PNFLAG_LOOKUP_URL) {
			/*
			 * Lookup the URL of type example.com/path?args.
			 * Either as a plain string or SHA1/MD5 digest.
			 */
			if ((pn->flags & PNFLAG_LOOKUP_DIGEST(0)) &&
			    relay_lookup_url(cre, pk.value,
			    DIGEST_NONE) == PN_FAIL)
				goto abort;
			if ((pn->flags & PNFLAG_LOOKUP_DIGEST(DIGEST_SHA1)) &&
			    relay_lookup_url(cre, pk.value,
			    DIGEST_SHA1) == PN_FAIL)
				goto abort;
			if ((pn->flags & PNFLAG_LOOKUP_DIGEST(DIGEST_MD5)) &&
			    relay_lookup_url(cre, pk.value,
			    DIGEST_MD5) == PN_FAIL)
				goto abort;
		} else if (pn->flags & PNFLAG_LOOKUP_QUERY) {
			/* Lookup the HTTP query arguments */
			if (relay_lookup_query(cre) == PN_FAIL)
				goto abort;
		} else if (pn->flags & PNFLAG_LOOKUP_COOKIE) {
			/* Lookup the HTTP cookie */
			if (relay_lookup_cookie(cre, pk.value) == PN_FAIL)
				goto abort;
		}

 handle:
		pass = 0;
		PROTONODE_FOREACH(pnv, pn, entry) {
			ret = relay_handle_http(cre, pn, pnv, &pk, header);
			if (ret == PN_PASS)
				pass = 1;
			else if (ret == PN_FAIL)
				goto abort;
		}

		if (pass) {
 next:
			if (relay_bufferevent_print(cre->dst, pk.key) == -1 ||
			    relay_bufferevent_print(cre->dst,
			    header ? ": " : " ") == -1 ||
			    relay_bufferevent_print(cre->dst, pk.value) == -1 ||
			    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
				free(line);
				goto fail;
			}
		}
		free(line);
	}
	if (cre->done) {
		RB_FOREACH(proot, proto_tree, cre->tree) {
			PROTONODE_FOREACH(pn, proot, entry)
				if (relay_resolve(cre, proot, pn) != 0)
					return;
		}

		switch (cre->method) {
		case HTTP_METHOD_NONE:
			relay_close_http(con, 406, "no method", 0);
			return;
		case HTTP_METHOD_CONNECT:
			/* Data stream */
			bev->readcb = relay_read;
			break;
		case HTTP_METHOD_DELETE:
		case HTTP_METHOD_GET:
		case HTTP_METHOD_HEAD:
		case HTTP_METHOD_OPTIONS:
		case HTTP_METHOD_POST:
		case HTTP_METHOD_PUT:
		case HTTP_METHOD_RESPONSE:
			/* HTTP request payload */
			if (cre->toread) {
				bev->readcb = relay_read_httpcontent;
				break;
			}

			/* Single-pass HTTP response */
			bev->readcb = relay_read;
			break;
		default:
			/* HTTP handler */
			bev->readcb = relay_read_http;
			break;
		}
		if (cre->chunked) {
			/* Chunked transfer encoding */
			cre->toread = 0;
			bev->readcb = relay_read_httpchunks;
		}

		/* Write empty newline and switch to relay mode */
		if (relay_bufferevent_print(cre->dst, "\r\n") == -1)
			goto fail;

		relay_http_request_close(cre);

 done:
		if (cre->dir == RELAY_DIR_REQUEST && !cre->toread &&
		    proto->lateconnect && cre->dst->bev == NULL) {
			if (rlay->rl_conf.fwdmode == FWD_TRANS) {
				relay_bindanyreq(con, 0, IPPROTO_TCP);
				return;
			}
			if (relay_connect(con) == -1)
				relay_close_http(con, 502, "session failed", 0);
			return;
		}
	}
	if (con->se_done) {
		relay_close(con, "last http read (done)");
		return;
	}
	if (EVBUFFER_LENGTH(src) && bev->readcb != relay_read_http)
		bev->readcb(bev, arg);
	bufferevent_enable(bev, EV_READ);
	return;
 fail:
	relay_close_http(con, 500, strerror(errno), 0);
	return;
 abort:
	free(line);
}

static int
_relay_lookup_url(struct ctl_relay_event *cre, char *host, char *path,
    char *query, enum digest_type type)
{
	struct rsession		*con = cre->con;
	struct protonode	*proot, *pnv, pkv;
	char			*val, *md = NULL;
	int			 ret = PN_FAIL;

	if (asprintf(&val, "%s%s%s%s",
	    host, path,
	    query == NULL ? "" : "?",
	    query == NULL ? "" : query) == -1) {
		relay_close_http(con, 500, "failed to allocate URL", 0);
		return (PN_FAIL);
	}

	DPRINTF("%s: %s", __func__, val);

	switch (type) {
	case DIGEST_SHA1:
	case DIGEST_MD5:
		if ((md = digeststr(type, val, strlen(val), NULL)) == NULL) {
			relay_close_http(con, 500,
			    "failed to allocate digest", 0);
			goto fail;
		}
		pkv.key = md;
		break;
	case DIGEST_NONE:
		pkv.key = val;
		break;
	}
	pkv.type = NODE_TYPE_URL;
	pkv.value = "";

	if ((proot = RB_FIND(proto_tree, cre->tree, &pkv)) == NULL)
		goto done;

	PROTONODE_FOREACH(pnv, proot, entry) {
		ret = relay_handle_http(cre, proot, pnv, &pkv, 0);
		if (ret == PN_FAIL)
			goto fail;
	}

 done:
	ret = PN_PASS;
 fail:
	if (md != NULL)
		free(md);
	free(val);
	return (ret);
}

int
relay_lookup_url(struct ctl_relay_event *cre, const char *str,
    enum digest_type type)
{
	struct rsession	*con = cre->con;
	int		 i, j, dots;
	char		*hi[RELAY_MAXLOOKUPLEVELS], *p, *pp, *c, ch;
	char		 ph[MAXHOSTNAMELEN];
	int		 ret;

	if (cre->path == NULL)
		return (PN_PASS);

	/*
	 * This is an URL lookup algorithm inspired by
	 * http://code.google.com/apis/safebrowsing/
	 *     developers_guide.html#PerformingLookups
	 */

	DPRINTF("%s: host: '%s', path: '%s', query: '%s'", __func__,
	    str, cre->path, cre->args == NULL ? "" : cre->args);

	if (canonicalize_host(str, ph, sizeof(ph)) == NULL) {
		relay_close_http(con, 400, "invalid host name", 0);
		return (PN_FAIL);
	}

	bzero(hi, sizeof(hi));
	for (dots = -1, i = strlen(ph) - 1; i > 0; i--) {
		if (ph[i] == '.' && ++dots)
			hi[dots - 1] = &ph[i + 1];
		if (dots > (RELAY_MAXLOOKUPLEVELS - 2))
			break;
	}
	if (dots == -1)
		dots = 0;
	hi[dots] = ph;

	if ((pp = strdup(cre->path)) == NULL) {
		relay_close_http(con, 500, "failed to allocate path", 0);
		return (PN_FAIL);
	}
	for (i = (RELAY_MAXLOOKUPLEVELS - 1); i >= 0; i--) {
		if (hi[i] == NULL)
			continue;

		/* 1. complete path with query */
		if (cre->args != NULL)
			if ((ret = _relay_lookup_url(cre, hi[i],
			    pp, cre->args, type)) != PN_PASS)
				goto done;

		/* 2. complete path without query */
		if ((ret = _relay_lookup_url(cre, hi[i],
		    pp, NULL, type)) != PN_PASS)
			goto done;

		/* 3. traverse path */
		for (j = 0, p = strchr(pp, '/');
		    p != NULL; p = strchr(p, '/'), j++) {
			if (j > (RELAY_MAXLOOKUPLEVELS - 2) || ++p == '\0')
				break;
			c = &pp[p - pp];
			ch = *c;
			*c = '\0';
			if ((ret = _relay_lookup_url(cre, hi[i],
			    pp, NULL, type)) != PN_PASS)
				goto done;
			*c = ch;
		}
	}

	ret = PN_PASS;
 done:
	free(pp);
	return (ret);
}

int
relay_lookup_query(struct ctl_relay_event *cre)
{
	struct rsession		*con = cre->con;
	struct protonode	*proot, *pnv, pkv;
	char			*val, *ptr;
	int			 ret;

	if (cre->path == NULL || cre->args == NULL || strlen(cre->args) < 2)
		return (PN_PASS);
	if ((val = strdup(cre->args)) == NULL) {
		relay_close_http(con, 500, "failed to allocate query", 0);
		return (PN_FAIL);
	}

	ptr = val;
	while (ptr != NULL && strlen(ptr)) {
		pkv.key = ptr;
		pkv.type = NODE_TYPE_QUERY;
		if ((ptr = strchr(ptr, '&')) != NULL)
			*ptr++ = '\0';
		if ((pkv.value =
		    strchr(pkv.key, '=')) == NULL ||
		    strlen(pkv.value) < 1)
			continue;
		*pkv.value++ = '\0';

		if ((proot = RB_FIND(proto_tree, cre->tree, &pkv)) == NULL)
			continue;
		PROTONODE_FOREACH(pnv, proot, entry) {
			ret = relay_handle_http(cre, proot,
			    pnv, &pkv, 0);
			if (ret == PN_FAIL)
				goto done;
		}
	}

	ret = PN_PASS;
 done:
	free(val);
	return (ret);
}

int
relay_lookup_cookie(struct ctl_relay_event *cre, const char *str)
{
	struct rsession		*con = cre->con;
	struct protonode	*proot, *pnv, pkv;
	char			*val, *ptr;
	int			 ret;

	if ((val = strdup(str)) == NULL) {
		relay_close_http(con, 500, "failed to allocate cookie", 0);
		return (PN_FAIL);
	}

	for (ptr = val; ptr != NULL && strlen(ptr);) {
		if (*ptr == ' ')
			*ptr++ = '\0';
		pkv.key = ptr;
		pkv.type = NODE_TYPE_COOKIE;
		if ((ptr = strchr(ptr, ';')) != NULL)
			*ptr++ = '\0';
		/*
		 * XXX We do not handle attributes
		 * ($Path, $Domain, or $Port)
		 */
		if (*pkv.key == '$')
			continue;

		if ((pkv.value =
		    strchr(pkv.key, '=')) == NULL ||
		    strlen(pkv.value) < 1)
			continue;
		*pkv.value++ = '\0';
		if (*pkv.value == '"')
			*pkv.value++ = '\0';
		if (pkv.value[strlen(pkv.value) - 1] == '"')
			pkv.value[strlen(pkv.value) - 1] = '\0';
		if ((proot = RB_FIND(proto_tree, cre->tree, &pkv)) == NULL)
			continue;
		PROTONODE_FOREACH(pnv, proot, entry) {
			ret = relay_handle_http(cre, proot, pnv, &pkv, 0);
			if (ret == PN_FAIL)
				goto done;
		}
	}

	ret = PN_PASS;
 done:
	free(val);
	return (ret);
}

void
relay_close_http(struct rsession *con, u_int code, const char *msg,
    u_int16_t labelid)
{
	struct relay		*rlay = (struct relay *)con->se_relay;
	struct bufferevent	*bev = con->se_in.bev;
	const char		*httperr = print_httperror(code), *text = "";
	char			*httpmsg;
	time_t			 t;
	struct tm		*lt;
	char			 tmbuf[32], hbuf[128];
	const char		*style, *label = NULL;

	/* In some cases this function may be called from generic places */
	if (rlay->rl_proto->type != RELAY_PROTO_HTTP ||
	    (rlay->rl_proto->flags & F_RETURN) == 0) {
		relay_close(con, msg);
		return;
	}

	if (bev == NULL)
		goto done;

	/* Some system information */
	if (print_host(&rlay->rl_conf.ss, hbuf, sizeof(hbuf)) == NULL)
		goto done;

	/* RFC 2616 "tolerates" asctime() */
	time(&t);
	lt = localtime(&t);
	tmbuf[0] = '\0';
	if (asctime_r(lt, tmbuf) != NULL)
		tmbuf[strlen(tmbuf) - 1] = '\0';	/* skip final '\n' */

	/* Do not send details of the Internal Server Error */
	if (code != 500)
		text = msg;
	if (labelid != 0)
		label = pn_id2name(labelid);

	/* A CSS stylesheet allows minimal customization by the user */
	if ((style = rlay->rl_proto->style) == NULL)
		style = "body { background-color: #a00000; color: white; }";

	/* Generate simple HTTP+HTML error document */
	if (asprintf(&httpmsg,
	    "HTTP/1.x %03d %s\r\n"
	    "Date: %s\r\n"
	    "Server: %s\r\n"
	    "Connection: close\r\n"
	    "Content-Type: text/html\r\n"
	    "\r\n"
	    "<!DOCTYPE HTML PUBLIC "
	    "\"-//W3C//DTD HTML 4.01 Transitional//EN\">\n"
	    "<html>\n"
	    "<head>\n"
	    "<title>%03d %s</title>\n"
	    "<style type=\"text/css\"><!--\n%s\n--></style>\n"
	    "</head>\n"
	    "<body>\n"
	    "<h1>%s</h1>\n"
	    "<div id='m'>%s</div>\n"
	    "<div id='l'>%s</div>\n"
	    "<hr><address>%s at %s port %d</address>\n"
	    "</body>\n"
	    "</html>\n",
	    code, httperr, tmbuf, RELAYD_SERVERNAME,
	    code, httperr, style, httperr, text,
	    label == NULL ? "" : label,
	    RELAYD_SERVERNAME, hbuf, ntohs(rlay->rl_conf.port)) == -1)
		goto done;

	/* Dump the message without checking for success */
	relay_dump(&con->se_in, httpmsg, strlen(httpmsg));
	free(httpmsg);

 done:
	if (asprintf(&httpmsg, "%s (%03d %s)", msg, code, httperr) == -1)
		relay_close(con, msg);
	else {
		relay_close(con, httpmsg);
		free(httpmsg);
	}
@


1.150
log
@after connect() returns EINPROGRESS the connection can still fail,
so check with getsockopt if the socket is open.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.149 2012/07/09 09:52:04 deraadt Exp $	*/
d335 3
@


1.150.2.1
log
@Fix 5.2 similar to what was done in relay_http.c r1.15 in -current.
From reyk@@

With HTTP keepalive, relayd only filtered the first request and
switched to pass-through mode for subsequent requests from the client.
Make sure to stay in HTTP header mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.150 2012/07/13 07:54:14 benno Exp $	*/
d1506 1
a1506 2
			if (cre->dir == RELAY_DIR_RESPONSE)
				bev->readcb = relay_read;
@


1.149
log
@Allow relayd to handle transactions > 2GB in size
tested by snapshot users and benno for a while
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.148 2012/04/30 10:49:57 benno Exp $	*/
d653 2
d659 9
@


1.148
log
@The message-body should be forwarded for GET,HEAD and OPTIONS methods as well.
ok giovanni@@, phessler@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.147 2012/04/27 14:01:35 giovanni Exp $	*/
d1085 1
a1085 1
	DPRINTF("%s: size %d, to read %d", __func__,
d1091 1
a1091 1
	if (size >= cre->toread)
d1094 1
a1094 1
	DPRINTF("%s: done, size %d, to read %d", __func__,
d1122 1
a1122 1
	DPRINTF("%s: size %d, to read %d", __func__,
d1171 1
a1171 1
		if (size > cre->toread)
d1176 1
a1176 1
		DPRINTF("%s: done, size %d, to read %d", __func__,
d1244 1
a1244 1
	DPRINTF("%s: size %d, to read %d", __func__, size, cre->toread);
d1390 1
a1390 1
			cre->toread = strtonum(pk.value, 0, INT_MAX, &errstr);
@


1.147
log
@
A message-body should be forwarded for DELETE method too.
from Florian Obser
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.146 2012/04/11 08:25:26 deraadt Exp $	*/
d1376 3
d1395 8
d1482 3
@


1.146
log
@Do rate limiting of accept() when under pressure, like in other recent
daemons.  Light testing by some relayd users; let me know if issues
develop.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.145 2012/03/24 14:48:18 sthen Exp $	*/
d1375 2
a1376 1
		} else if ((cre->method == HTTP_METHOD_POST ||
d1470 1
@


1.145
log
@Allow relayd to use a separate SSL certificate for each port
(/etc/ssl/host:port.crt, /etc/ssl/private/host:port.key).
ok benno@@, todd@@ likes it too, doc tweak suggested by jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.144 2012/01/21 13:40:48 camield Exp $	*/
d472 1
a472 1
		event_set(&rlay->rl_ev, rlay->rl_s, EV_READ|EV_PERSIST,
d475 1
d1949 1
a1949 1
relay_accept(int fd, short sig, void *arg)
d1960 4
d1965 11
a1975 1
	if ((s = accept(fd, (struct sockaddr *)&ss, (socklen_t *)&slen)) == -1)
d1977 1
a1977 1

d2411 1
a2411 1
	if (con->se_out.s != -1)
d2413 8
@


1.144
log
@Only start the child processes after all of them reported to have loaded
the config.  Solves a race at startup time where processes can send status
messages about hosts that other processes don't know about yet.
(and have relayd abort with "desynchronized" or "invalid host id")

ok henning pyr deraadt
solves the problem ok from benno todd
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.143 2011/09/21 18:45:40 bluhm Exp $	*/
d3142 1
d3160 1
a3160 1
	    "/etc/ssl/%s.crt", hbuf) == -1)
d3163 9
a3171 2
	    &rlay->rl_conf.ssl_cert_len)) == NULL)
		return (-1);
d3174 9
a3182 3
	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/private/%s.key", hbuf) == -1)
		return -1;
@


1.143
log
@During socket splicing the relayd session timeouts could not be
measured exactly in user land.  Use the new idle timeout for socket
splicing in the kernel to make it correct.  Also do splicing with
http if relayd does not check headers.
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.142 2011/09/16 14:29:26 bluhm Exp $	*/
d2580 2
@


1.142
log
@If a user configures logging explicitly in relayd.conf, do it
regardlessly of debugging mode and compile switch.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.141 2011/09/04 20:26:58 bluhm Exp $	*/
a79 1
int		 relay_splicelen(struct ctl_relay_event *);
d83 3
d680 1
a680 17
		if ((proto->tcpflags & TCPFLAG_NSPLICE) ||
		    (rlay->rl_conf.flags & (F_SSL|F_SSLCLIENT)))
			break;
		if (setsockopt(con->se_in.s, SOL_SOCKET, SO_SPLICE,
		    &con->se_out.s, sizeof(int)) == -1) {
			log_debug("%s: session %d: splice forward failed: %s",
			    __func__, con->se_id, strerror(errno));
			return;
		}
		con->se_in.splicelen = 0;
		if (setsockopt(con->se_out.s, SOL_SOCKET, SO_SPLICE,
		    &con->se_in.s, sizeof(int)) == -1) {
			log_debug("%s: session %d: splice backward failed: %s",
			    __func__, con->se_id, strerror(errno));
			return;
		}
		con->se_out.splicelen = 0;
d683 1
a683 1
		fatalx("relay_input: unknown protocol");
d708 3
d758 3
d1836 29
d1867 3
a1869 3
	struct rsession *con = cre->con;
	off_t len;
	socklen_t optlen;
d1873 3
a1875 2
		relay_close(con, strerror(errno));
		return (0);
a1889 1
	struct timeval tv, tv_now;
d1892 30
a1921 3
		if (gettimeofday(&tv_now, NULL) == -1) {
			relay_close(con, strerror(errno));
			return;
d1923 2
a1924 9
		if (cre->splicelen >= 0 && relay_splicelen(cre))
			con->se_tv_last = tv_now;
		if (cre->dst->splicelen >= 0 && relay_splicelen(cre->dst))
			con->se_tv_last = tv_now;
		timersub(&tv_now, &con->se_tv_last, &tv);
		if (timercmp(&tv, &con->se_relay->rl_conf.timeout, >=))
			relay_close(con, "buffer event timeout");
		else
			bufferevent_enable(cre->bev, EV_READ);
d1942 3
@


1.141
log
@KNF, fix white spaces in relayd.  No binary change.
ok pyr@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.140 2011/09/04 10:42:47 bluhm Exp $	*/
d1059 1
a1059 2
		DPRINTF("%s: log '%s: %s'", __func__,
		    pn->key, pk->value);
@


1.140
log
@Especially with SSL and short data transfers, it could happen that
the client closed before the connection to the server has been
established.  Then the relay closed immediately before transferring
any data.  The solution is to delay the close until the other side
has an event buffer.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.139 2011/09/04 09:55:10 bluhm Exp $	*/
d2021 2
a2022 2
		proc_compose_imsg(env->sc_ps, PROC_PFE, -1, IMSG_NATLOOK, -1, cnl,
		    sizeof(*cnl));
@


1.139
log
@The relayd used the CHECK_TIMEOUT for connect and ssl handshake.
This is 200 milliseconds and too short.  Instead use the 600 seconds
session timeout that is used for accepted sessions everywhere else.
While there, make flag handling in relay_ssl_transaction() consistent
to the other functions.
tested and ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.138 2011/05/20 09:43:53 reyk Exp $	*/
d1895 2
a1896 1
		}
@


1.138
log
@Concurrent calls of "relayctl show sessions" could crash relayd.  Fix
the show sessions handler by implementing it in an asynchronous way.

Closes PR 6509
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.137 2011/05/19 08:56:49 reyk Exp $	*/
d2282 2
a2283 1
		    relay_connected, &con->se_tv_start, &env->sc_timeout, con);
d2629 1
a2629 1
	u_int			 flags = EV_TIMEOUT;
d2638 1
a2638 1
		flags |= EV_READ;
d2642 1
a2642 1
		flags |= EV_WRITE;
d2657 4
a2660 2
	event_again(&con->se_ev, cre->s, EV_TIMEOUT|flags,
	    cb, &con->se_tv_start, &env->sc_timeout, con);
d2727 1
a2727 1
	    &con->se_tv_start, &env->sc_timeout, con);
d2786 1
a2786 1
	    &con->se_tv_start, &env->sc_timeout, con);
@


1.137
log
@Fix reload support in relayd(8) by reimplementing large parts of the
daemon infrastructure. The previous design made it fairly hard to
reload the complex data structures, especially relays and protocols.
One of the reasons was that the privsep'd relayd processes had two
ways of getting their configuration: 1) from memory after forking from
the parent process and 2) and (partially) via imsgs after reload.  The
new implementation first forks the privsep'd children before the
parents loads the configuration and sends it via imsgs to them; so it
is only like 2) before.  It is based on an approach that I first
implemented for iked(8) and I also fixed many bugs in the code.

Thanks to many testers including dlg@@ sthen@@ phessler@@
ok pyr@@ dlg@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.136 2011/05/09 12:08:47 reyk Exp $	*/
d1942 1
d2379 1
a2379 1
	struct rsession		*con;
d2386 1
d2473 2
d2478 2
d2482 1
a2482 1
				    -1, con, sizeof(*con));
d2486 1
a2486 1
		    -1, NULL, 0);
@


1.136
log
@Reorganize the relayd code to use the proc.c privsep API/commodity
functions that are based on work for iked and smtpd.  This simplifies
the setup of privsep processes and moves some redundant and repeated
code to a single place - which is always good from a quality and
security point of view.  The relayd version of proc.c is different to
the current version in iked because it uses 1:N communications between
processes, eg. a single parent process is talking to many forked relay
children while iked only needs 1:1 communications.

ok sthen@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.135 2011/05/05 12:01:44 reyk Exp $	*/
a56 1
void		 relay_privinit(void);
a147 4

	/* Need root privileges for relay initialization */
	relay_privinit();

d154 1
a154 10
	struct rsession	*con;

	struct relay	*rlay;
	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry) {
		if (rlay->rl_conf.flags & F_DISABLE)
			continue;
		close(rlay->rl_s);
		while ((con = SPLAY_ROOT(&rlay->rl_sessions)) != NULL)
			relay_close(con, "shutdown");
	}
d239 2
a240 1
	fprintf(stderr, "protocol %d: name %s\n", proto->id, proto->name);
d294 2
a295 2
void
relay_privinit(void)
a296 1
	struct relay	*rlay;
d299 1
a299 2
	if (env->sc_flags & (F_SSL|F_SSLCLIENT))
		ssl_init(env);
d301 2
a302 2
	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry) {
		log_debug("%s: adding relay %s", __func__, rlay->rl_conf.name);
d304 9
a312 2
		if (debug)
			relay_protodebug(rlay);
d314 8
a321 9
		switch (rlay->rl_proto->type) {
		case RELAY_PROTO_DNS:
			relay_udp_privinit(env, rlay);
			break;
		case RELAY_PROTO_TCP:
		case RELAY_PROTO_HTTP:
			/* Use defaults */
			break;
		}
d323 1
a323 9
		if (rlay->rl_conf.flags & F_UDP)
			rlay->rl_s = relay_udp_bind(&rlay->rl_conf.ss,
			    rlay->rl_conf.port, rlay->rl_proto);
		else
			rlay->rl_s = relay_socket_listen(&rlay->rl_conf.ss,
			    rlay->rl_conf.port, rlay->rl_proto);
		if (rlay->rl_s == -1)
			fatal("relay_privinit: failed to listen");
	}
a328 2
	struct relay	*rlay;
	struct host	*host;
d331 3
a336 2
	purge_config(env, PURGE_RDRS);

a339 43
	TAILQ_FOREACH(rlay, env->sc_relays, rl_entry) {
		if ((rlay->rl_conf.flags & (F_SSL|F_SSLCLIENT)) &&
		    (rlay->rl_ssl_ctx = relay_ssl_ctx_create(rlay)) == NULL)
			fatal("relay_init: failed to create SSL context");

		if (rlay->rl_dsttable != NULL) {
			switch (rlay->rl_conf.dstmode) {
			case RELAY_DSTMODE_ROUNDROBIN:
				rlay->rl_dstkey = 0;
				break;
			case RELAY_DSTMODE_LOADBALANCE:
			case RELAY_DSTMODE_HASH:
				rlay->rl_dstkey =
				    hash32_str(rlay->rl_conf.name, HASHINIT);
				rlay->rl_dstkey =
				    hash32_str(rlay->rl_dsttable->conf.name,
				    rlay->rl_dstkey);
				break;
			}
			rlay->rl_dstnhosts = 0;
			TAILQ_FOREACH(host, &rlay->rl_dsttable->hosts, entry) {
				if (rlay->rl_dstnhosts >= RELAY_MAXHOSTS)
					fatal("relay_init: "
					    "too many hosts in table");
				host->idx = rlay->rl_dstnhosts;
				rlay->rl_dsthost[rlay->rl_dstnhosts++] = host;
			}
			log_info("adding %d hosts from table %s%s",
			    rlay->rl_dstnhosts, rlay->rl_dsttable->conf.name,
			    rlay->rl_dsttable->conf.check ? "" : " (no check)");
		}

		switch (rlay->rl_proto->type) {
		case RELAY_PROTO_DNS:
			relay_udp_init(rlay);
			break;
		case RELAY_PROTO_TCP:
		case RELAY_PROTO_HTTP:
			/* Use defaults */
			break;
		}
	}

a343 2

	relay_launch();
d414 1
d416 1
a416 1
	void		(*callback)(int, short, void *);
d419 41
d2302 1
a2302 1
	if (env->sc_opts & RELAYD_OPT_LOGUPDATE) {
d2513 21
d2581 1
a2581 1
		    rlay->rl_ssl_ca, rlay->rl_ssl_ca_len))
d2591 1
a2591 1
	    rlay->rl_ssl_cert, rlay->rl_ssl_cert_len))
d2596 1
a2596 1
	    rlay->rl_ssl_key_len))
d3073 1
a3073 1
	*len = size + 1;
d3090 1
a3090 1
	if ((rlay->rl_conf.flags & F_SSLCLIENT) && (proto->sslca != NULL)) {
d3092 1
a3092 1
		    &rlay->rl_ssl_ca_len)) == NULL)
d3107 1
a3107 1
	    &rlay->rl_ssl_cert_len)) == NULL)
d3115 1
a3115 1
	    &rlay->rl_ssl_key_len)) == NULL)
@


1.135
log
@Update all logging and debug functions to use the __func__ macro
instead of static function names.  __func__ is C99 and perfectly fine
to use. It also avoids printing errors; for example if a statement
log_debug("foo:"..) was moved or copied from function foo() to bar()
and the log message was not updated...
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.134 2011/04/24 10:07:43 bluhm Exp $	*/
a49 1
void		 relay_sig_handler(int sig, short, void *);
d51 4
a54 2
void		 relay_dispatch_pfe(int, short, void *);
void		 relay_dispatch_parent(int, short, void *);
d60 1
a60 1
void		 relay_init(void);
a137 2
struct imsgev			*iev_pfe;
struct imsgev			*iev_main;
d140 4
a143 17
void
relay_sig_handler(int sig, short event, void *arg)
{
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		(void)event_loopexit(NULL);
		break;
	case SIGCHLD:
	case SIGHUP:
	case SIGPIPE:
		/* ignore */
		break;
	default:
		fatalx("relay_sig_handler: unexpected signal");
	}
}
d146 3
a148 19
relay(struct relayd *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
    int pipe_parent2relay[RELAY_MAXPROC][2], int pipe_pfe2hce[2],
    int pipe_pfe2relay[RELAY_MAXPROC][2])
{
	pid_t		 pid;
	struct passwd	*pw;
	int		 i;

	switch (pid = fork()) {
	case -1:
		fatal("relay: cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	env = x_env;
	purge_config(env, PURGE_RDRS);
d153 1
a153 90
	if ((pw = getpwnam(RELAYD_USER)) == NULL)
		fatal("relay: getpwnam");

#ifndef DEBUG
	if (chroot(pw->pw_dir) == -1)
		fatal("relay: chroot");
	if (chdir("/") == -1)
		fatal("relay: chdir(\"/\")");

#else
#warning disabling privilege revocation and chroot in DEBUG mode
#endif

	setproctitle("socket relay engine");
	relayd_process = PROC_RELAY;

#ifndef DEBUG
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("relay: can't drop privileges");
#endif

	/* Fork child handlers */
	for (i = 1; i < env->sc_prefork_relay; i++) {
		if (fork() == 0) {
			proc_id = i;
			break;
		}
	}

	event_init();

	/* Per-child initialization */
	relay_init();

	signal_set(&env->sc_evsigint, SIGINT, relay_sig_handler, env);
	signal_set(&env->sc_evsigterm, SIGTERM, relay_sig_handler, env);
	signal_set(&env->sc_evsigchld, SIGCHLD, relay_sig_handler, env);
	signal_set(&env->sc_evsighup, SIGHUP, relay_sig_handler, env);
	signal_set(&env->sc_evsigpipe, SIGPIPE, relay_sig_handler, env);

	signal_add(&env->sc_evsigint, NULL);
	signal_add(&env->sc_evsigterm, NULL);
	signal_add(&env->sc_evsigchld, NULL);
	signal_add(&env->sc_evsighup, NULL);
	signal_add(&env->sc_evsigpipe, NULL);

	/* setup pipes */
	close(pipe_pfe2hce[0]);
	close(pipe_pfe2hce[1]);
	close(pipe_parent2hce[0]);
	close(pipe_parent2hce[1]);
	close(pipe_parent2pfe[0]);
	close(pipe_parent2pfe[1]);
	for (i = 0; i < env->sc_prefork_relay; i++) {
		if (i == proc_id)
			continue;
		close(pipe_parent2relay[i][0]);
		close(pipe_parent2relay[i][1]);
		close(pipe_pfe2relay[i][0]);
		close(pipe_pfe2relay[i][1]);
	}
	close(pipe_parent2relay[proc_id][1]);
	close(pipe_pfe2relay[proc_id][1]);

	if ((iev_pfe = calloc(1, sizeof(struct imsgev))) == NULL ||
	    (iev_main = calloc(1, sizeof(struct imsgev))) == NULL)
		fatal("relay");
	imsg_init(&iev_pfe->ibuf, pipe_pfe2relay[proc_id][0]);
	imsg_init(&iev_main->ibuf, pipe_parent2relay[proc_id][0]);
	iev_pfe->handler = relay_dispatch_pfe;
	iev_main->handler = relay_dispatch_parent;

	iev_pfe->events = EV_READ;
	event_set(&iev_pfe->ev, iev_pfe->ibuf.fd, iev_pfe->events,
	    iev_pfe->handler, iev_pfe);
	event_add(&iev_pfe->ev, NULL);

	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	relay_launch();

	event_dispatch();
	relay_shutdown();

	return (0);
a169 2
	log_info("socket relay engine exiting");
	_exit(0);
d344 1
a344 1
relay_init(void)
d350 5
d405 2
d455 1
a455 1
		imsg_compose_event(iev_pfe, IMSG_STATISTICS, 0, 0, -1,
d2040 1
a2040 1
		imsg_compose_event(iev_pfe, IMSG_NATLOOK, 0, 0, -1, cnl,
d2219 2
a2220 2
	imsg_compose_event(iev_main, IMSG_BINDANY,
	    0, 0, -1, &bnd, sizeof(bnd));
d2331 2
a2332 1
		log_info("relay %s, session %d (%d active), %d, %s -> %s:%d, "
d2385 1
a2385 1
		imsg_compose_event(iev_pfe, IMSG_KILLSTATES, 0, 0, -1,
d2395 2
a2396 2
void
relay_dispatch_pfe(int fd, short event, void *ptr)
a2397 4
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
a2405 1
	int			 verbose;
d2407 27
a2433 36
	iev = ptr;
	ibuf = &iev->ibuf;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("relay_dispatch_pfe: imsg_read_error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}

	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("relay_dispatch_pfe: msgbuf_write");
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("relay_dispatch_pfe: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_HOST_DISABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((host = host_find(env, id)) == NULL)
				fatalx("relay_dispatch_pfe: desynchronized");
			if ((table = table_find(env, host->conf.tableid)) ==
			    NULL)
				fatalx("relay_dispatch_pfe: invalid table id");
			if (host->up == HOST_UP)
				table->up--;
			host->flags |= F_DISABLE;
d2435 8
a2442 6
			break;
		case IMSG_HOST_ENABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((host = host_find(env, id)) == NULL)
				fatalx("relay_dispatch_pfe: desynchronized");
			host->flags &= ~(F_DISABLE);
d2444 21
a2464 32
			break;
		case IMSG_TABLE_DISABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((table = table_find(env, id)) == NULL)
				fatalx("relay_dispatch_pfe: desynchronized");
			table->conf.flags |= F_DISABLE;
			table->up = 0;
			TAILQ_FOREACH(host, &table->hosts, entry)
				host->up = HOST_UNKNOWN;
			break;
		case IMSG_TABLE_ENABLE:
			memcpy(&id, imsg.data, sizeof(id));
			if ((table = table_find(env, id)) == NULL)
				fatalx("relay_dispatch_pfe: desynchronized");
			table->conf.flags &= ~(F_DISABLE);
			table->up = 0;
			TAILQ_FOREACH(host, &table->hosts, entry)
				host->up = HOST_UNKNOWN;
			break;
		case IMSG_HOST_STATUS:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(st))
				fatalx("relay_dispatch_pfe: invalid request");
			memcpy(&st, imsg.data, sizeof(st));
			if ((host = host_find(env, st.id)) == NULL)
				fatalx("relay_dispatch_pfe: invalid host id");
			if (host->flags & F_DISABLE)
				break;
			if (host->up == st.up) {
				log_debug("%s: host %d => %d", __func__,
				    host->conf.id, host->up);
				fatalx("relay_dispatch_pfe: desynchronized");
			}
d2466 2
a2467 17
			if ((table = table_find(env, host->conf.tableid))
			    == NULL)
				fatalx("relay_dispatch_pfe: invalid table id");

			DPRINTF("%s: [%d] state %d for "
			    "host %u %s", __func__, proc_id, st.up,
			    host->conf.id, host->conf.name);

			if ((st.up == HOST_UNKNOWN && host->up == HOST_DOWN) ||
			    (st.up == HOST_DOWN && host->up == HOST_UNKNOWN)) {
				host->up = st.up;
				break;
			}
			if (st.up == HOST_UP)
				table->up++;
			else
				table->up--;
d2470 28
a2497 7
		case IMSG_NATLOOK:
			bcopy(imsg.data, &cnl, sizeof(cnl));
			if ((con = session_find(env, cnl.id)) == NULL ||
			    con->se_cnl == NULL) {
				log_debug("%s: session %d: expired",
				    __func__, cnl.id);
				break;
a2498 24
			bcopy(&cnl, con->se_cnl, sizeof(*con->se_cnl));
			evtimer_del(&con->se_ev);
			evtimer_set(&con->se_ev, relay_natlook, con);
			bzero(&tv, sizeof(tv));
			evtimer_add(&con->se_ev, &tv);
			break;
		case IMSG_CTL_SESSION:
			TAILQ_FOREACH(rlay, env->sc_relays, rl_entry)
				SPLAY_FOREACH(con, session_tree,
				    &rlay->rl_sessions)
					imsg_compose_event(iev,
					    IMSG_CTL_SESSION,
					    0, 0, -1, con, sizeof(*con));
			imsg_compose_event(iev, IMSG_CTL_END,
			    0, 0, -1, NULL, 0);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
d2500 5
a2504 1
		imsg_free(&imsg);
d2506 2
a2507 1
	imsg_event_add(iev);
d2510 2
a2511 2
void
relay_dispatch_parent(int fd, short event, void * ptr)
a2513 4
	struct imsgev		*iev;
	struct imsgbuf		*ibuf;
	struct imsg		 imsg;
	ssize_t			 n;
d2517 8
a2524 2
	iev = ptr;
	ibuf = &iev->ibuf;
d2526 2
a2527 10
	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1)
			fatal("relay_dispatch_parent: imsg_read error");
		if (n == 0) {
			/* this pipe is dead, so remove the event handler */
			event_del(&iev->ev);
			event_loopexit(NULL);
			return;
		}
	}
d2529 7
a2535 3
	if (event & EV_WRITE) {
		if (msgbuf_write(&ibuf->w) == -1)
			fatal("relay_dispatch_parent: msgbuf_write");
d2538 1
a2538 31
	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("relay_dispatch_parent: imsg_read error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_BINDANY:
			bcopy(imsg.data, &id, sizeof(id));
			if ((con = session_find(env, id)) == NULL) {
				log_debug("%s: session %d: expired",
				    __func__, id);
				break;
			}

			/* Will validate the result later */
			con->se_bnds = imsg.fd;

			evtimer_del(&con->se_ev);
			evtimer_set(&con->se_ev, relay_bindany, con);
			bzero(&tv, sizeof(tv));
			evtimer_add(&con->se_ev, &tv);
			break;
		default:
			log_debug("%s: unexpected imsg %d", __func__,
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	imsg_event_add(iev);
@


1.134
log
@Get rid of casts to struct rsession in relayd by not declaring a
void pointer in struct ctl_relay_event.  That way the compiler can
do its job and enforce correct types.
ok pyr@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.133 2011/04/12 12:37:22 reyk Exp $	*/
d438 1
a438 2
		log_debug("relay_privinit: adding relay %s",
		    rlay->rl_conf.name);
d595 2
a596 1
		log_debug("relay_launch: running relay %s", rlay->rl_conf.name);
d796 1
a796 1
	DPRINTF("relay_connected: session %d: %ssuccessful",
d818 2
a819 2
			log_debug("relay_connect: session %d: splice forward "
			    "failed: %s", con->se_id, strerror(errno));
d825 2
a826 2
			log_debug("relay_connect: session %d: splice backward "
			    "failed: %s", con->se_id, strerror(errno));
d1009 1
a1009 2
		DPRINTF("relay_resolve: add '%s: %s'",
		    pn->key, ptr);
d1012 1
a1012 2
		DPRINTF("relay_resolve: missing '%s: %s'",
		    pn->key, pn->value);
d1016 1
a1016 2
		DPRINTF("relay_resolve: filtered '%s: %s'",
		    pn->key, pn->value);
d1142 1
a1142 1
		DPRINTF("relay_handle_http: append '%s: %s, %s'",
d1149 1
a1149 1
		DPRINTF("relay_handle_http: change/remove '%s: %s'",
d1163 1
a1163 1
		DPRINTF("relay_handle_http: %s '%s: %s'",
d1188 1
a1188 1
		DPRINTF("relay_handle_http: hash '%s: %s'",
d1194 1
a1194 1
		DPRINTF("relay_handle_http: log '%s: %s'",
d1199 1
a1199 1
		DPRINTF("relay_handle_http: mark '%s: %s'",
d1228 1
a1228 1
	DPRINTF("relay_read_httpcontent: size %d, to read %d",
d1237 1
a1237 1
	DPRINTF("relay_read_httpcontent: done, size %d, to read %d",
d1265 1
a1265 1
	DPRINTF("relay_read_httpchunks: size %d, to read %d",
d1298 1
a1298 1
			DPRINTF("relay_read_httpchunks: last chunk");
d1319 1
a1319 1
		DPRINTF("relay_read_httpchunks: done, size %d, to read %d",
d1387 1
a1387 1
	DPRINTF("relay_read_http: size %d, to read %d", size, cre->toread);
d1424 1
a1424 1
			DPRINTF("relay_read_http: request '%s'", line);
d1443 1
a1443 1
		DPRINTF("relay_read_http: header '%s: %s'", pk.key, pk.value);
d1505 2
a1506 2
			DPRINTF("relay_read_http: "
			    "lookup path '%s: %s'", pkv.key, pkv.value);
d1685 1
a1685 1
	DPRINTF("_relay_lookup_url: %s", val);
d1741 1
a1741 1
	DPRINTF("relay_lookup_url: host: '%s', path: '%s', query: '%s'",
d2203 1
a2203 1
		log_debug("relay_from_table: no active hosts");
d2226 1
a2226 1
	DPRINTF("relay_from_table: host %s, p 0x%08x, idx %d",
d2229 1
a2229 1
		DPRINTF("relay_from_table: host %s", host->conf.name);
d2235 1
a2235 1
		DPRINTF("relay_from_table: next host %s", host->conf.name);
d2287 1
a2287 2
		log_debug("relay_session: session %d: looping",
		    con->se_id);
d2376 1
a2376 1
			log_debug("relay_connect: could not bind any sock");
d2393 1
a2393 1
			log_debug("relay_connect: mapped to invalid address");
d2403 2
a2404 2
			log_debug("relay_connect: session %d: "
			    "forward failed: %s, %s",
d2409 1
a2409 1
		log_debug("relay_connect: session %d: forward failed: %s",
d2597 1
a2597 1
				log_debug("relay_dispatch_pfe: host %d => %d",
d2606 2
a2607 2
			DPRINTF("relay_dispatch_pfe: [%d] state %d for "
			    "host %u %s", proc_id, st.up,
d2625 2
a2626 2
				log_debug("relay_dispatch_pfe: "
				    "session expired");
d2650 1
a2650 1
			log_debug("relay_dispatch_msg: unexpected imsg %d",
d2699 2
a2700 2
				log_debug("relay_dispatch_parent: "
				    "session expired");
d2713 1
a2713 1
			log_debug("relay_dispatch_parent: unexpected imsg %d",
d2770 1
a2770 1
	log_debug("relay_ssl_ctx_create: loading certificate");
d2775 1
a2775 1
	log_debug("relay_ssl_ctx_create: loading private key");
d2885 1
a2885 2
	log_info("relay %s, session %d established (%d active)",
	    rlay->rl_conf.name, con->se_id, relay_sessions);
d2887 3
a2889 1
	log_debug("relay %s, session %d established (%d active)",
d2891 1
a2891 1
#endif
d2896 1
a2896 1
	DPRINTF("relay_ssl_accept: session %d: scheduling on %s", con->se_id,
d2944 1
a2944 2
	log_info("relay %s, session %d connected (%d active)",
	    rlay->rl_conf.name, con->se_id, relay_sessions);
d2946 3
a2948 1
	log_debug("relay %s, session %d connected (%d active)",
d2950 1
a2950 1
#endif
d2955 1
a2955 1
	DPRINTF("relay_ssl_connect: session %d: scheduling on %s", con->se_id,
d3001 2
a3002 2
			DPRINTF("relay_ssl_readcb: session %d: "
			    "want read", con->se_id);
d3005 2
a3006 2
			DPRINTF("relay_ssl_readcb: session %d: "
			    "want write", con->se_id);
d3081 2
a3082 2
				DPRINTF("relay_ssl_writecb: session %d: "
				    "want read", con->se_id);
d3085 2
a3086 2
				DPRINTF("relay_ssl_writecb: session %d: "
				    "want write", con->se_id);
d3275 1
a3275 1
		log_debug("relay_load_certfiles: using ca %s", proto->sslca);
d3290 1
a3290 1
	log_debug("relay_load_certfiles: using certificate %s", certfile);
d3298 1
a3298 1
	log_debug("relay_load_certfiles: using private key %s", certfile);
@


1.133
log
@update flags and printing of flags in debug mode, handle splicing flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.132 2011/04/12 11:45:18 bluhm Exp $	*/
d910 1
a910 1
	struct rsession		*con = (struct rsession *)cre->con;
d939 1
a939 1
	struct rsession		*con = (struct rsession *)cre->con;
d964 1
a964 1
	struct rsession		*con = (struct rsession *)cre->con;
d1031 1
a1031 1
	struct rsession	*con = (struct rsession *)cre->con;
d1108 1
a1108 1
	struct rsession		*con = (struct rsession *)cre->con;
d1224 1
a1224 1
	struct rsession		*con = (struct rsession *)cre->con;
d1259 1
a1259 1
	struct rsession		*con = (struct rsession *)cre->con;
d1377 1
a1377 1
	struct rsession		*con = (struct rsession *)cre->con;
d1675 1
a1675 1
	struct rsession		*con = (struct rsession *)cre->con;
d1729 1
a1729 1
	struct rsession	*con = (struct rsession *)cre->con;
d1806 1
a1806 1
	struct rsession		*con = (struct rsession *)cre->con;
d1849 1
a1849 1
	struct rsession		*con = (struct rsession *)cre->con;
d1985 1
a1985 1
	struct rsession *con = (struct rsession *)cre->con;
d2005 1
a2005 1
	struct rsession *con = (struct rsession *)cre->con;
d2064 1
a2064 2
	if ((con = (struct rsession *)
	    calloc(1, sizeof(struct rsession))) == NULL)
d2356 1
a2356 1
	if (relay_connect((struct rsession *)con) == -1)
d2981 1
a2981 1
	struct rsession *con = (struct rsession *)cre->con;
d3056 1
a3056 1
	struct rsession *con = (struct rsession *)cre->con;
@


1.132
log
@Enable socket splicing for relayd.  This allows zero-copy data
forwarding for plain tcp connections.
feedback and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.131 2011/04/07 13:22:29 reyk Exp $	*/
d375 9
a383 1
	fprintf(stderr, "\tflags: 0x%04x\n", proto->flags);
d813 2
a814 1
		if (rlay->rl_conf.flags & (F_SSL|F_SSLCLIENT))
@


1.131
log
@Add support for divert-to which provides some benefits over rdr-to.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.130 2011/03/12 21:06:40 bluhm Exp $	*/
d80 1
d805 16
a820 1
		/* Use defaults */
d1973 19
d1998 1
d2001 13
a2013 1
		relay_close(con, "buffer event timeout");
d2067 2
@


1.130
log
@Fix previous commit.  When data arrives from the client before the
server connection is set up, do not enable read events for the other
side.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.129 2011/03/12 18:18:11 bluhm Exp $	*/
d623 16
d2063 15
a2077 1
	if (rlay->rl_conf.flags & F_NATLOOK) {
a2082 1
	}
a2083 1
	if (rlay->rl_conf.flags & F_NATLOOK && cnl != NULL) {
@


1.129
log
@A connection that is constantly sending data uni-directionaly from
the client to the server did always trigger the session timeout.
The reason for this behavior was that any read event reset the
client side timeout.  A read event on one side must reset the timeout
for the other side instead.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.128 2010/12/20 12:38:06 dhill Exp $	*/
d909 2
a910 1
	bufferevent_enable(cre->dst->bev, EV_READ);
@


1.128
log
@Only set SO_REUSEPORT for listening ports.

Fixes "Address already in use" errors seen on high load.

OK reyk@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.127 2010/11/30 14:49:14 reyk Exp $	*/
d909 1
a909 1
	bufferevent_enable(con->se_in.bev, EV_READ);
@


1.127
log
@The returned SSL_METHOD of SSLv23_server_method()/SSLv23_client_method()
is const now, adjust the variable and silence a compiler warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.126 2010/11/30 14:38:45 reyk Exp $	*/
d62 1
a62 1
		    struct protocol *, int);
d625 1
a625 1
    struct protocol *proto, int fd)
d643 6
a648 3
	val = 1;
	if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(int)) == -1)
		goto bad;
d714 1
a714 1
	if ((s = relay_socket(ss, port, proto, fd)) == -1)
d735 1
a735 1
	if ((s = relay_socket(ss, port, proto, -1)) == -1)
@


1.126
log
@The relayd processes did already bump up the socket file descriptor
resource limits to the maximum of the daemon class but the host check
process (hce/health checks) didn't and was limited to a fairly low
default of 128 open sockets (openfiles-cur=128 in login.conf). This
was reached fairly quickly with "check tcp" of many hosts. This diff
increases the maximum number of monitored hosts and concurrent health
checks in relayd in a significant way and may fix issues for people
that have around 100 or more hosts (or fewer hosts with multiple checked
ports).

tested by phessler@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.125 2010/11/24 13:57:05 jsg Exp $	*/
d2713 5
a2717 5
	struct relay	*rlay = (struct relay *)con->se_relay;
	SSL		*ssl;
	SSL_METHOD	*method;
	void		(*cb)(int, short, void *);
	u_int		 flags = EV_TIMEOUT;
@


1.125
log
@When disabling and enabling tables set the number of hosts that are up
to zero, consistent with pfe and makes other parts of the code better
behaved.  From Patrik Lundin.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.124 2010/11/16 15:31:01 jsg Exp $	*/
a26 1
#include <sys/resource.h>
a461 1
	struct rlimit	 rl;
d463 2
a464 11
	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("relay_init: failed to get resource limit");
	log_debug("relay_init: max open files %d", rl.rlim_max);

	/*
	 * Allow the maximum number of open file descriptors for this
	 * login class (which should be the class "daemon" by default).
	 */
	rl.rlim_cur = rl.rlim_max;
	if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("relay_init: failed to set resource limit");
@


1.124
log
@Add support for enable/disable table when using relays instead of redirects.
From Patrik Lundin and Linus Widstromer.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.123 2010/10/12 14:52:21 dhill Exp $	*/
d2500 1
d2509 1
@


1.123
log
@Plug a significant memory leak when using SSL.

ok claudio@@, jsg@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.122 2010/08/01 22:18:35 sthen Exp $	*/
d2494 16
@


1.122
log
@Allow fallback tables for relays, not just redirections.
Seems reasonable to jsg, ok phessler, no response from reyk or pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.121 2010/05/26 13:56:08 nicm Exp $	*/
d2403 6
@


1.122.2.1
log
@MFC:

- - -
date: 2010/10/12 14:52:21;  author: dhill;  state: Exp;  lines: +7 -1
Plug a significant memory leak when using SSL.

ok claudio@@, jsg@@, phessler@@
- - -

requested by dhill, ok deraadt pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.122 2010/08/01 22:18:35 sthen Exp $	*/
a2402 6
	if (con->se_out.ssl != NULL) {
		/* XXX handle non-blocking shutdown */
		if (SSL_shutdown(con->se_out.ssl) == 0)
			SSL_shutdown(con->se_out.ssl);
		SSL_free(con->se_out.ssl);
	}
@


1.121
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.120 2010/05/14 11:13:36 reyk Exp $	*/
d2126 1
a2126 1
	if (table->conf.check && !table->up) {
d2129 2
@


1.120
log
@allocate all struct event's on the heap, it looks cleaner, feels better
and follows a suggestion in event.h.  also don't mix signal() and
signal_set()/signal_add().

ok jsg@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.119 2010/02/18 16:33:25 jsg Exp $	*/
d931 1
a931 1
	char			 buf[READ_BUF_SIZE], *ptr;
d1075 1
a1075 1
	char			 buf[READ_BUF_SIZE], *ptr;
d2881 2
a2882 2
	char rbuf[READ_BUF_SIZE];
	int howmuch = READ_BUF_SIZE;
@


1.119
log
@Fix a leak that could happen with multiple requests on the one
connection and while here create a seperate function for handling cleaning
up after a request; with suggestions from reyk and claudio.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.118 2010/01/11 06:40:14 jsg Exp $	*/
d148 8
a165 2
	struct event	 ev_sigint;
	struct event	 ev_sigterm;
d219 11
a229 6
	signal_set(&ev_sigint, SIGINT, relay_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, relay_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGHUP, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
@


1.119.2.1
log
@MFC:

- - -
date: 2010/10/12 14:52:21;  author: dhill;  state: Exp;  lines: +7 -1
Plug a significant memory leak when using SSL.

ok claudio@@, jsg@@, phessler@@
- - -

requested by dhill, ok deraadt pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.119 2010/02/18 16:33:25 jsg Exp $	*/
a2389 6
	if (con->se_out.ssl != NULL) {
		/* XXX handle non-blocking shutdown */
		if (SSL_shutdown(con->se_out.ssl) == 0)
			SSL_shutdown(con->se_out.ssl);
		SSL_free(con->se_out.ssl);
	}
@


1.118
log
@add "log brief" and "log verbose" to change logging verbosity
like several other things in the tree.

ok reyk@@ looks fine claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.117 2009/08/07 11:21:53 reyk Exp $	*/
d104 1
d1306 23
d1597 1
a1597 4
		cre->line = 0;
		cre->method = 0;
		cre->done = 0;
		cre->chunked = 0;
@


1.117
log
@rename 'struct session' to 'struct rsession' because it conflicts with
another 'struct session' in sys/sysctl.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.116 2009/06/07 05:56:25 eric Exp $	*/
d2408 1
d2511 4
@


1.116
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.115 2009/06/05 23:39:51 pyr Exp $	*/
d70 1
a70 1
void		 relay_input(struct session *);
d72 1
a72 1
int		 relay_connect(struct session *);
d74 1
a74 1
void		 relay_bindanyreq(struct session *, in_port_t, int);
d89 1
a89 1
int		 relay_lognode(struct session *,
d102 1
a102 1
void		 relay_close_http(struct session *, u_int, const char *,
d106 1
a106 1
void		 relay_ssl_transaction(struct session *,
d266 1
a266 1
	struct session	*con;
d521 1
a521 1
	struct session		*con, *next_con;
d749 1
a749 1
	struct session		*con = (struct session *)arg;
d815 1
a815 1
relay_input(struct session *con)
d865 1
a865 1
	struct session		*con = (struct session *)cre->con;
d894 1
a894 1
	struct session		*con = (struct session *)cre->con;
d918 1
a918 1
	struct session		*con = (struct session *)cre->con;
d985 1
a985 1
	struct session	*con = (struct session *)cre->con;
d1039 1
a1039 1
relay_lognode(struct session *con, struct protonode *pn, struct protonode *pk,
d1062 1
a1062 1
	struct session		*con = (struct session *)cre->con;
d1178 1
a1178 1
	struct session		*con = (struct session *)cre->con;
d1213 1
a1213 1
	struct session		*con = (struct session *)cre->con;
d1308 1
a1308 1
	struct session		*con = (struct session *)cre->con;
d1609 1
a1609 1
	struct session		*con = (struct session *)cre->con;
d1663 1
a1663 1
	struct session	*con = (struct session *)cre->con;
d1740 1
a1740 1
	struct session		*con = (struct session *)cre->con;
d1783 1
a1783 1
	struct session		*con = (struct session *)cre->con;
d1832 1
a1832 1
relay_close_http(struct session *con, u_int code, const char *msg,
d1920 1
a1920 1
	struct session *con = (struct session *)cre->con;
d1948 1
a1948 1
	struct session *con = NULL;
d1966 2
a1967 2
	if ((con = (struct session *)
	    calloc(1, sizeof(struct session))) == NULL)
d2086 1
a2086 1
relay_from_table(struct session *con)
d2146 1
a2146 1
	struct session		*con = (struct session *)arg;
d2170 1
a2170 1
relay_session(struct session *con)
d2212 1
a2212 1
relay_bindanyreq(struct session *con, in_port_t port, int proto)
d2236 1
a2236 1
	struct session	*con = (struct session *)arg;
d2243 1
a2243 1
	if (relay_connect((struct session *)con) == -1)
d2248 1
a2248 1
relay_connect(struct session *con)
d2315 1
a2315 1
relay_close(struct session *con, const char *msg)
d2401 1
a2401 1
	struct session		*con;
d2524 1
a2524 1
	struct session		*con;
d2659 1
a2659 1
relay_ssl_transaction(struct session *con, struct ctl_relay_event *cre)
d2707 1
a2707 1
	struct session	*con = (struct session *)arg;
d2766 1
a2766 1
	struct session	*con = (struct session *)arg;
d2839 1
a2839 1
	struct session *con = (struct session *)cre->con;
d2914 1
a2914 1
	struct session *con = (struct session *)cre->con;
d3176 1
a3176 1
relay_session_cmp(struct session *a, struct session *b)
d3187 1
a3187 1
SPLAY_GENERATE(session_tree, session, se_nodes, relay_session_cmp);
@


1.115
log
@4 handed diff with eric:
Stop pushing event handling in the imsg framework.
Instead, provide a small glue layer on top of both imsg and libevent.
This finally clearly separates event handling and imsg construction.

Sidetrack bonus: remove the mega-ugly hack of having a dummy imsg_event_add
stub in relayctl.

This will make bgpd (and thus henning) happy. Next up are smtpd and ospfd.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.114 2009/06/05 00:20:50 pyr Exp $	*/
d2567 1
a2567 1
			con->se_bnds = imsg_get_fd(ibuf);
@


1.114
log
@some KNF cleanup following the last sed.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.113 2009/06/05 00:04:01 pyr Exp $	*/
d136 2
a137 2
struct imsgbuf			*ibuf_pfe;
struct imsgbuf			*ibuf_main;
d237 2
a238 2
	if ((ibuf_pfe = calloc(1, sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = calloc(1, sizeof(struct imsgbuf))) == NULL)
d240 14
a253 13
	imsg_init(ibuf_main, pipe_parent2relay[proc_id][0],
	    relay_dispatch_parent);
	imsg_init(ibuf_pfe, pipe_pfe2relay[proc_id][0], relay_dispatch_pfe);

	ibuf_pfe->events = EV_READ;
	event_set(&ibuf_pfe->ev, ibuf_pfe->fd, ibuf_pfe->events,
	    ibuf_pfe->handler, ibuf_pfe);
	event_add(&ibuf_pfe->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d560 1
a560 1
		imsg_compose_event(ibuf_pfe, IMSG_STATISTICS, 0, 0, -1,
d2046 1
a2046 1
		imsg_compose_event(ibuf_pfe, IMSG_NATLOOK, 0, 0, -1, cnl,
d2224 1
a2224 1
	imsg_compose_event(ibuf_main, IMSG_BINDANY,
d2383 1
a2383 1
		imsg_compose_event(ibuf_pfe, IMSG_KILLSTATES, 0, 0, -1,
d2396 1
d2409 2
a2410 1
	ibuf = ptr;
d2417 1
a2417 1
			event_del(&ibuf->ev);
d2505 1
a2505 1
					imsg_compose_event(ibuf,
d2508 1
a2508 1
			imsg_compose_event(ibuf, IMSG_CTL_END,
d2518 1
a2518 1
	imsg_event_add(ibuf);
d2525 1
d2532 2
a2533 1
	ibuf = ptr;
d2540 1
a2540 1
			event_del(&ibuf->ev);
d2581 1
a2581 1
	imsg_event_add(ibuf);
@


1.113
log
@Make imsg completely async model agnostic by not requiring an
imsg_event_add function to be provided (which ended up being a named
callback).
Instead provide a wrapper in the daemon and call that everywhere.
Previsously discussed with the usual suspects,
ok eric@@ though not too happy about the function name
(imsg_compose_event).
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.112 2009/06/02 12:24:16 reyk Exp $	*/
d2223 2
a2224 1
	imsg_compose_event(ibuf_main, IMSG_BINDANY, 0, 0, -1, &bnd, sizeof(bnd));
d2502 2
a2503 1
					imsg_compose_event(ibuf, IMSG_CTL_SESSION,
d2505 2
a2506 1
			imsg_compose_event(ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
@


1.112
log
@remove extra imsg_event_add() after EV_WRITE checks - this is not
required because it is called later and there is no return before.

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.111 2009/06/02 11:33:06 reyk Exp $	*/
d559 1
a559 1
		imsg_compose(ibuf_pfe, IMSG_STATISTICS, 0, 0, -1,
d2045 1
a2045 1
		imsg_compose(ibuf_pfe, IMSG_NATLOOK, 0, 0, -1, cnl,
d2223 1
a2223 1
	imsg_compose(ibuf_main, IMSG_BINDANY, 0, 0, -1, &bnd, sizeof(bnd));
d2381 1
a2381 1
		imsg_compose(ibuf_pfe, IMSG_KILLSTATES, 0, 0, -1,
d2501 1
a2501 1
					imsg_compose(ibuf, IMSG_CTL_SESSION,
d2503 1
a2503 1
			imsg_compose(ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
@


1.111
log
@Libevent may do an upcall with both EV_READ and EV_WRITE set.
So change the code accordingly to allow that.

Found by claudio@@ in ospfd
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.110 2009/04/24 13:22:01 pyr Exp $	*/
a2421 2
		imsg_event_add(ibuf);
		return;
a2540 2
		imsg_event_add(ibuf);
		return;
@


1.110
log
@don't truncate http headers when no separator is given between key and
value.
ok & ``makes sense'' reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.109 2009/04/02 14:30:51 reyk Exp $	*/
d2407 2
a2408 2
	switch (event) {
	case EV_READ:
d2417 3
a2419 2
		break;
	case EV_WRITE:
a2423 2
	default:
		fatalx("relay_dispatch_pfe: unknown event");
d2528 2
a2529 2
	switch (event) {
	case EV_READ:
d2538 3
a2540 2
		break;
	case EV_WRITE:
a2544 2
	default:
		fatalx("relay_dispatch_parent: unknown event");
@


1.109
log
@add support to specify a ca file (eg. /etc/ssl/cert.pem) to verify ssl
server certificates when connecting as an SSL client from relays.  it
works so far, but needs more testing and is currently lacking support
for certificate revocation (like CRL or OCSP).  the file ssl_privsep.c
is extended to implement more code that should be in openssl to allow
loading the ca from chroot...
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.108 2009/04/01 14:56:38 reyk Exp $	*/
d1369 1
a1369 1
			pk.value++;
@


1.108
log
@Add support for client-side SSL connections from relays.  relayd can
now sit between two SSL connections (Oitm - OpenBSD-in-the-middle),
accept SSL connections and forward to TCP, accept TCP connections and
forward to SSL, and do TCP to TCP of course.

This was tested by some people a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.107 2008/09/29 15:50:56 reyk Exp $	*/
d2618 9
d3125 1
d3129 7
d3148 1
a3148 1
	log_debug("relay_load_certfile: using certificate %s", certfile);
d3156 1
a3156 1
	log_debug("relay_load_certfile: using private key %s", certfile);
@


1.107
log
@fix log option with filter rules
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.106 2008/09/29 15:27:20 reyk Exp $	*/
d106 2
a107 1
void		 relay_ssl_transaction(struct session *);
d109 1
d413 1
a413 1
	if (env->sc_flags & F_SSL)
d465 1
a465 1
		if ((rlay->rl_conf.flags & F_SSL) &&
d754 1
d761 5
d802 5
a807 1
	con->se_out.bev = bev;
d2194 1
a2194 1
		relay_ssl_transaction(con);
d2618 3
d2648 1
a2648 1
relay_ssl_transaction(struct session *con)
d2652 3
d2660 11
a2670 1
	if (!SSL_set_ssl_method(ssl, SSLv23_server_method()))
d2672 1
a2672 1
	if (!SSL_set_fd(ssl, con->se_in.s))
a2673 1
	SSL_set_accept_state(ssl);
d2675 4
a2678 1
	con->se_in.ssl = ssl;
d2680 4
a2683 2
	event_again(&con->se_ev, con->se_in.s, EV_TIMEOUT|EV_READ,
	    relay_ssl_accept, &con->se_tv_start, &env->sc_timeout, con);
d2690 1
d2749 58
@


1.106
log
@also log the label if available for the matching rule node (like the
URL filter category etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.105 2008/09/29 15:12:22 reyk Exp $	*/
d89 2
d1026 20
a1051 1
	const char		*label = NULL;
d1120 2
d1152 2
a1153 11
	if (mark != -1 && pn->flags & PNFLAG_LOG) {
		bzero(buf, sizeof(buf));
		if (pn->label != 0)
			label = pn_id2name(pn->label);
		if (snprintf(buf, sizeof(buf), " [%s%s%s: %s]",
		    label == NULL ? "" : label,
		    label == NULL ? "" : ", ",
		    pk->key, pk->value) == -1 ||
		    evbuffer_add(con->se_log, buf, strlen(buf)) == -1)
			goto fail;
	}
@


1.105
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.104 2008/08/11 08:24:41 reyk Exp $	*/
d1030 1
d1131 5
a1135 1
		if (snprintf(buf, sizeof(buf), " [%s: %s]",
@


1.104
log
@more goto fail on gettimeofday error
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.103 2008/08/11 08:07:14 reyk Exp $	*/
d413 2
a414 1
		log_debug("relay_privinit: adding relay %s", rlay->rl_conf.name);
d1014 2
a1015 1
		snprintf(ibuf, sizeof(ibuf), "%lu", rlay->rl_conf.timeout.tv_sec);
d2078 2
a2079 1
		p = hash32_buf(&rlay->rl_conf.port, sizeof(rlay->rl_conf.port), p);
d2122 2
a2123 1
	    rlay->rl_conf.dstss.ss_family == AF_UNSPEC && rlay->rl_dsttable == NULL) {
d2593 2
a2594 1
	if (!ssl_ctx_use_private_key(ctx, rlay->rl_ssl_key, rlay->rl_ssl_key_len))
d2751 2
a2752 1
				ssl_error(rlay->rl_conf.name, "relay_ssl_readcb");
@


1.103
log
@better handling of HTTP POSTs or requests with Content-Length.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.102 2008/08/11 06:42:06 reyk Exp $	*/
d882 1
a882 1
		goto done;
@


1.102
log
@add missing 'break' to read HTTP content correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.101 2008/08/08 22:49:33 reyk Exp $	*/
d1149 1
a1149 1
		goto done;
d1164 1
a1164 1
	if (EVBUFFER_LENGTH(src) && bev->readcb != relay_read_httpcontent)
d1186 1
a1186 1
		goto done;
d1285 1
a1285 1
		goto done;
d1288 6
a1293 2
	if (!size)
		return;
d1352 1
a1352 3
			} else if (strcmp("GET", pk.key) == 0)
				cre->method = HTTP_METHOD_GET;
			else if (strcmp("HEAD", pk.key) == 0)
d1366 4
d1505 3
d1538 1
d1544 2
a1545 1
		if (cre->dir == RELAY_DIR_REQUEST &&
d1556 4
a1559 2
	if (con->se_done)
		goto done;
a1562 3
	return;
 done:
	relay_close(con, "last http read (done)");
@


1.101
log
@add a variable $SERVER_NAME which is "OpenBSD relayd" by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.100 2008/08/08 20:34:30 reyk Exp $	*/
d1507 1
a1507 1
			if (cre->toread)
d1509 2
@


1.100
log
@chunked encoding may include empty lines at random places, do not
abort the session if we get an empty line except of the expected chunk
header.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.99 2008/08/08 19:13:24 reyk Exp $	*/
d1004 5
@


1.99
log
@fix possible memleaks in chunked encoding handler
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.98 2008/08/08 18:56:05 reyk Exp $	*/
d1191 2
a1192 1
			relay_close(con, "invalid chunk");
@


1.98
log
@only dump all protocol nodes with DEBUG > 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.97 2008/08/08 18:38:14 reyk Exp $	*/
d1194 2
a1195 1
		if (!strlen(line))
d1197 1
d1207 2
a1208 1
		    relay_bufferevent_print(cre->dst, "\r\n") == -1)
d1210 1
@


1.97
log
@Support HTTP responses that neither specify a Content-Length header
nor chunked encoding.  We don't know the length of the HTTP body in
this case, so it only works for single-pass HTTP responses without
subsequent HTTP response headers in the stream.  You can still enforce
the Content-Length header with an "expect" rule.

For example, this fixes response handling from undeadly.org (thttpd)
if relayd is running as a transparent HTTP proxy.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.96 2008/08/08 08:51:21 thib Exp $	*/
d379 3
d383 3
a385 1
#ifndef DEBUG
a387 1
#endif
a389 1
#ifndef DEBUG
a394 1
#endif
@


1.96
log
@Check gettimeofday() against -1; Add a missing error check in one place.

OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.95 2008/07/22 23:17:37 reyk Exp $	*/
d1495 1
a1495 1
			if (cre->toread) {
d1497 4
a1500 3
				break;
			}
			/* FALLTHROUGH */
@


1.95
log
@Add dynamic IPv6-to-IPv4 and IPv4-to-IPv6 translation inspired by
faithd(8) by doing a similar mapping of IPv4/6 addresses with
relayd(8) and pf(4) redirections without the need of the faith(4)
interface.  The trick works in both directions, it can accept IPv6
connections and relay them to IPv4 hosts by extracting the last 4
octets from the IPv6 destination (like faithd(8)), and it can accept
IPv4 connections and relay them to IPv6 hosts by prepending the 4
octets of the original IPv4 destination to a configured IPv6 prefix.
An access list is not needed because the classification is done in
pf.conf(5).  It helps to get more faith in relayd.

manpage bits ok jmc@@
yes, sounds good todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.94 2008/07/16 15:02:19 reyk Exp $	*/
d521 1
a521 1
	if (gettimeofday(&tv_now, NULL))
d848 1
a848 1
	if (gettimeofday(&con->se_tv_last, NULL))
d879 1
a879 1
	if (gettimeofday(&con->se_tv_last, NULL))
d1141 1
a1141 1
	if (gettimeofday(&con->se_tv_last, NULL))
d1178 1
a1178 1
	if (gettimeofday(&con->se_tv_last, NULL))
d1272 1
a1272 1
	if (gettimeofday(&con->se_tv_last, NULL))
d1929 1
a1929 1
	if (gettimeofday(&con->se_tv_start, NULL))
d2191 1
a2191 1
	if (gettimeofday(&con->se_tv_start, NULL))
@


1.94
log
@relay_connect() may fail, close the session in the bindany callback
if it does.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.93 2008/07/16 14:49:44 reyk Exp $	*/
d2189 1
a2189 1
	int		 bnds = -1;
d2209 16
@


1.93
log
@use getsockname() to find out the local address of a connection before
doing a nat lookup.  this fixes nat lookups when the relay is
listening to a wildcard IPv4/IPv6 address (like 0.0.0.0 or ::).
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.92 2008/07/09 17:16:51 reyk Exp $	*/
d2181 2
a2182 1
	relay_connect((struct session *)con);
@


1.92
log
@Use OpenBSD's knuth shuffle algorithm of random values from bind to
produce the DNS request ids instead of a simple per-request
arc4random().  This ensure randomness but also satisfies the
non-repeating property we need.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.91 2008/07/09 14:57:01 reyk Exp $	*/
d1978 1
d1980 7
a1986 1
		bcopy(&rlay->rl_conf.ss, &cnl->dst, sizeof(cnl->dst));
@


1.91
log
@also set the protocol, either TCP or UDP, in the NAT lookup.  this
unbreaks NAT lookups with UDP; tested as a transparent DNS relay.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.90 2008/06/11 18:21:19 reyk Exp $	*/
d487 10
@


1.90
log
@add support for "transparent" forwarding in relays: normally the l7
relay will connect to the target host with its own ip address, but
this mode will let it use the address of the client that is connecting
from the other side. for example, there is no need to add the
X-Forwarded-For HTTP headers for internal webservers in this mode
anymore since they magically see the remote client ip address in the
connection. it also allows to build fully-transparent ssl
encapsulation for tcp sessions and many other things...

based on an initial idea from dlg@@ and pascoe@@ (dlg's talk at opencon)
using the new BINDANY and divert-reply interfaces from markus@@ (since n2k8)

ok markus@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.89 2008/05/08 02:27:58 reyk Exp $	*/
d1967 1
@


1.89
log
@move the session keys used by dns in a protocol-specific private ptr.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.88 2008/05/05 12:33:55 pyr Exp $	*/
d63 1
a63 1
		    struct protocol *);
d67 1
a67 1
		    struct protocol *);
d74 2
d606 1
a606 1
    struct protocol *proto)
d614 2
a615 1
	if ((s = socket(ss->ss_family, SOCK_STREAM, IPPROTO_TCP)) == -1)
d688 1
a688 1
    struct protocol *proto)
d690 1
a690 1
	int s;
d692 1
a692 1
	if ((s = relay_socket(ss, port, proto)) == -1)
d713 1
a713 1
	if ((s = relay_socket(ss, port, proto)) == -1)
d1510 7
a1516 3
		    proto->lateconnect && cre->dst->bev == NULL &&
		    relay_connect(con) == -1) {
			relay_close_http(con, 502, "session failed", 0);
d1918 1
d2120 40
a2159 2
	if (!rlay->rl_proto->lateconnect && relay_connect(con) == -1) {
		relay_close(con, "session failed");
d2163 1
a2163 1
	relay_input(con);
d2170 1
d2179 2
a2180 1
		bcopy(&rlay->rl_conf.dstss, &con->se_out.ss, sizeof(con->se_out.ss));
d2184 8
d2193 2
a2194 2
	if ((con->se_out.s = relay_socket_connect(&con->se_out.ss, con->se_out.port,
	    rlay->rl_proto)) == -1) {
d2426 6
a2431 3
	struct imsgbuf	*ibuf;
	struct imsg	 imsg;
	ssize_t		 n;
d2461 16
@


1.88
log
@Put relay sockets in non blocking mode too. This got forgotten along the
way and didn't show since our read buffers are small.
``put it in'' reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.87 2008/03/21 05:22:11 reyk Exp $	*/
d1088 1
a1088 1
		con->se_outkey = hash32_str(pk->value, con->se_outkey);
d1905 1
a1905 1
	con->se_outkey = rlay->rl_dstkey;
d2006 1
a2006 1
	u_int32_t		 p = con->se_outkey;
d2191 2
@


1.87
log
@better handling of chunked encoding, further fixes after extensive testing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.86 2008/03/20 22:24:46 reyk Exp $	*/
d1885 3
@


1.86
log
@handle the case that the Content-Length HTTP header may be 0
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.85 2008/03/03 16:41:36 reyk Exp $	*/
d1161 1
a1161 1
	char			*line, *ep;
d1179 2
d1182 2
a1183 4
		/* Read prepended chunk size in hex */
		errno = 0;
		lval = strtol(line, &ep, 16);
		if (line[0] == '\0' || *ep != '\0') {
d1188 1
a1188 6
		if (errno == ERANGE &&
		    (lval == LONG_MAX || lval == LONG_MIN)) {
			free(line);
			relay_close(con, "chunk size out of range");
			return;
		}
d1200 1
a1200 1
				relay_close(con, "invalid chunk");
d1221 1
a1221 1
			/* Chunk is terminated by an empty newline */
d1223 2
a1224 7
			if (line == NULL || strlen(line)) {
				if (line != NULL)
					free(line);
				relay_close(con, "invalid chunk");
				return;
			}
			free(line);
d1230 1
d1233 1
a1233 1
	if (EVBUFFER_LENGTH(src) && bev->readcb != relay_read_httpchunks)
d1255 1
a1255 1
	int			 header = 0, ret, pass = 0, content = 0;
a1402 1
			content = 1;
d1482 1
a1482 1
			if (cre->toread || content) {
@


1.85
log
@improve the compare function of addresses respecting the ports; this will fix
the tree lookups in some cases.

From Nigel Taylor

ok pyr@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.84 2008/02/13 11:32:59 reyk Exp $	*/
d844 3
d1201 2
d1264 1
a1264 1
	int			 header = 0, ret, pass = 0;
d1407 1
a1407 1
			cre->toread = strtonum(pk.value, 1, INT_MAX, &errstr);
d1412 1
d1492 1
a1492 1
			if (cre->toread) {
@


1.84
log
@bump copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.83 2008/02/05 14:12:58 thib Exp $	*/
d2799 1
d2808 5
a2812 4
		return (memcmp(&ia.sin_addr, &ib.sin_addr,
		    sizeof(ia.sin_addr)) +
		    memcmp(&ia.sin_port, &ib.sin_port,
		    sizeof(ia.sin_port)));
d2818 5
a2822 4
		return (memcmp(&ia6.sin6_addr, &ib6.sin6_addr,
		    sizeof(ia6.sin6_addr)) +
		    memcmp(&ia6.sin6_port, &ib6.sin6_port,
		    sizeof(ia6.sin6_port)));
d2825 1
a2825 1
		return (-1);
d2827 2
@


1.83
log
@Fix a debug printf. After the session members got a se_ prefix this one
was forgotten.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.82 2008/02/04 12:12:30 thib Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006, 2007 Reyk Floeter <reyk@@openbsd.org>
@


1.82
log
@Move some prototypes from relay.c to relayd.h and remove there externs
in other places;

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.81 2008/02/04 12:05:26 thib Exp $	*/
d741 1
a741 1
	    con->id, rlay->rl_proto->lateconnect ? "late connect " : "");
@


1.81
log
@Move the declaration of DPRINTF from relay.c too relayd.h so it can be
reused;

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.80 2008/01/31 12:12:50 thib Exp $	*/
a61 1
int		 relay_socket_af(struct sockaddr_storage *, in_port_t);
a70 3
void		 relay_close(struct session *, const char *);
void		 relay_session(struct session *);
void		 relay_natlook(int, short, void *);
a75 1
int		 relay_from_table(struct session *);
a119 2
int		 relay_cmp_af(struct sockaddr_storage *,
		    struct sockaddr_storage *);
@


1.80
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct session;

ok reyk@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.79 2008/01/31 09:56:28 reyk Exp $	*/
a139 6

#if DEBUG > 1
#define DPRINTF		log_debug
#else
#define DPRINTF(x...)	do { } while(0)
#endif
@


1.79
log
@add prefixes to names of structure elements to make it easier to grep
for code, next struct relay.  knf long line fixes will follow later.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.78 2008/01/31 09:33:39 reyk Exp $	*/
d560 1
a560 1
			timersub(&tv_now, &con->tv_last, &tv);
d742 1
a742 1
	struct relay		*rlay = (struct relay *)con->relay;
d761 1
a761 1
			if ((con->out.nodes = calloc(proto->response_nodes,
d779 1
a779 1
	bev = bufferevent_new(fd, outrd, outwr, relay_error, &con->out);
d786 1
a786 1
	bev->output = con->out.output;
d790 1
a790 1
	con->out.bev = bev;
d799 1
a799 1
	struct relay	*rlay = (struct relay *)con->relay;
d810 1
a810 1
			if ((con->in.nodes = calloc(proto->request_nodes,
d827 3
a829 3
	con->in.bev = bufferevent_new(con->in.s, inrd, inwr,
	    relay_error, &con->in);
	if (con->in.bev == NULL) {
d835 2
a836 2
	if ((rlay->rl_conf.flags & F_SSL) && con->in.ssl != NULL)
		relay_ssl_connected(&con->in);
d838 1
a838 1
	bufferevent_settimeout(con->in.bev,
d840 1
a840 1
	bufferevent_enable(con->in.bev, EV_READ|EV_WRITE);
d848 3
a850 3
	if (gettimeofday(&con->tv_last, NULL))
		con->done = 1;
	if (con->done)
d876 1
a876 1
	if (gettimeofday(&con->tv_last, NULL))
d882 1
a882 1
	if (con->done)
d884 1
a884 1
	bufferevent_enable(con->in.bev, EV_READ);
d901 1
a901 1
	if (pn->mark && (pn->mark != con->mark))
d965 1
a965 1
	struct relay	*rlay = (struct relay *)con->relay;
d1022 1
a1022 1
		mark = pn->mark == con->mark ? 1 : -1;
d1098 1
a1098 1
		con->outkey = hash32_str(pk->value, con->outkey);
d1110 1
a1110 1
			con->mark = pn->mark;
d1120 1
a1120 1
		    evbuffer_add(con->log, buf, strlen(buf)) == -1)
d1138 1
a1138 1
	if (gettimeofday(&con->tv_last, NULL))
d1152 1
a1152 1
	if (con->done)
d1175 1
a1175 1
	if (gettimeofday(&con->tv_last, NULL))
d1248 1
a1248 1
	if (con->done)
d1267 1
a1267 1
	struct relay		*rlay = (struct relay *)con->relay;
d1276 1
a1276 1
	if (gettimeofday(&con->tv_last, NULL))
d1375 1
a1375 1
			    evbuffer_add(con->log, buf, strlen(buf)) == -1) {
d1530 1
a1530 1
	if (con->done)
d1776 2
a1777 2
	struct relay		*rlay = (struct relay *)con->relay;
	struct bufferevent	*bev = con->in.bev;
d1845 1
a1845 1
	relay_dump(&con->in, httpmsg, strlen(httpmsg));
d1871 1
a1871 1
		con->done = 1;
d1908 18
a1925 18
	con->in.s = s;
	con->in.ssl = NULL;
	con->out.s = -1;
	con->out.ssl = NULL;
	con->in.dst = &con->out;
	con->out.dst = &con->in;
	con->in.con = con;
	con->out.con = con;
	con->relay = rlay;
	con->id = ++relay_conid;
	con->relayid = rlay->rl_conf.id;
	con->outkey = rlay->rl_dstkey;
	con->in.tree = &proto->request_tree;
	con->out.tree = &proto->response_tree;
	con->in.dir = RELAY_DIR_REQUEST;
	con->out.dir = RELAY_DIR_RESPONSE;
	con->retry = rlay->rl_conf.dstretry;
	if (gettimeofday(&con->tv_start, NULL))
d1927 3
a1929 3
	bcopy(&con->tv_start, &con->tv_last, sizeof(con->tv_last));
	bcopy(&ss, &con->in.ss, sizeof(con->in.ss));
	con->out.port = rlay->rl_conf.dstport;
d1932 1
a1932 1
		con->in.port = ((struct sockaddr_in *)&ss)->sin_port;
d1935 1
a1935 1
		con->in.port = ((struct sockaddr_in6 *)&ss)->sin6_port;
d1946 2
a1947 2
	con->out.output = evbuffer_new();
	if (con->out.output == NULL) {
d1953 2
a1954 2
	con->log = evbuffer_new();
	if (con->log == NULL) {
d1968 1
a1968 1
		con->cnl = cnl;;
d1971 1
a1971 1
		cnl->id = con->id;
d1973 1
a1973 1
		bcopy(&con->in.ss, &cnl->src, sizeof(cnl->src));
d1979 1
a1979 1
		evtimer_set(&con->ev, relay_natlook, con);
d1981 1
a1981 1
		evtimer_add(&con->ev, &tv);
d2017 1
a2017 1
	struct relay		*rlay = (struct relay *)con->relay;
d2020 1
a2020 1
	u_int32_t		 p = con->outkey;
d2035 1
a2035 1
		p = relay_hash_addr(&con->in.ss, p);
d2064 3
a2066 3
	con->retry = host->conf.retry;
	con->out.port = table->conf.port;
	bcopy(&host->conf.ss, &con->out.ss, sizeof(con->out.ss));
d2075 2
a2076 2
	struct relay		*rlay = (struct relay *)con->relay;
	struct ctl_natlook	*cnl = con->cnl;
d2081 1
a2081 1
	if (con->out.ss.ss_family == AF_UNSPEC && cnl->in == -1 &&
d2087 2
a2088 2
		bcopy(&cnl->rdst, &con->out.ss, sizeof(con->out.ss));
		con->out.port = cnl->rdport;
d2090 2
a2091 2
	free(con->cnl);
	con->cnl = NULL;
d2099 2
a2100 2
	struct relay		*rlay = (struct relay *)con->relay;
	struct ctl_relay_event	*in = &con->in, *out = &con->out;
d2105 1
a2105 1
		    con->id);
d2137 1
a2137 1
	struct relay	*rlay = (struct relay *)con->relay;
d2139 1
a2139 1
	if (gettimeofday(&con->tv_start, NULL))
d2145 3
a2147 3
	} else if (con->out.ss.ss_family == AF_UNSPEC) {
		bcopy(&rlay->rl_conf.dstss, &con->out.ss, sizeof(con->out.ss));
		con->out.port = rlay->rl_conf.dstport;
d2151 1
a2151 1
	if ((con->out.s = relay_socket_connect(&con->out.ss, con->out.port,
d2153 2
a2154 2
		if (con->retry) {
			con->retry--;
d2157 2
a2158 2
			    con->id, strerror(errno),
			    con->retry ? "next retry" : "last retry");
d2162 1
a2162 1
		    con->id, strerror(errno));
d2167 2
a2168 2
		event_again(&con->ev, con->out.s, EV_WRITE|EV_TIMEOUT,
		    relay_connected, &con->tv_start, &env->sc_timeout, con);
d2170 1
a2170 1
		relay_connected(con->out.s, EV_WRITE, con);
d2178 1
a2178 1
	struct relay	*rlay = (struct relay *)con->relay;
d2183 5
a2187 5
	event_del(&con->ev);
	if (con->in.bev != NULL)
		bufferevent_disable(con->in.bev, EV_READ|EV_WRITE);
	if (con->out.bev != NULL)
		bufferevent_disable(con->out.bev, EV_READ|EV_WRITE);
d2192 5
a2196 5
		(void)print_host(&con->in.ss, ibuf, sizeof(ibuf));
		(void)print_host(&con->out.ss, obuf, sizeof(obuf));
		if (EVBUFFER_LENGTH(con->log) &&
		    evbuffer_add_printf(con->log, "\r\n") != -1)
			ptr = evbuffer_readline(con->log);
d2198 2
a2199 2
		    "%s%s%s", rlay->rl_conf.name, con->id, relay_sessions,
		    con->mark, ibuf, obuf, ntohs(con->out.port), msg,
d2205 5
a2209 5
	if (con->in.bev != NULL)
		bufferevent_free(con->in.bev);
	else if (con->in.output != NULL)
		evbuffer_free(con->in.output);
	if (con->in.ssl != NULL) {
d2211 25
a2235 25
		if (SSL_shutdown(con->in.ssl) == 0)
			SSL_shutdown(con->in.ssl);
		SSL_free(con->in.ssl);
	}
	if (con->in.s != -1)
		close(con->in.s);
	if (con->in.path != NULL)
		free(con->in.path);
	if (con->in.buf != NULL)
		free(con->in.buf);
	if (con->in.nodes != NULL)
		free(con->in.nodes);

	if (con->out.bev != NULL)
		bufferevent_free(con->out.bev);
	else if (con->out.output != NULL)
		evbuffer_free(con->out.output);
	if (con->out.s != -1)
		close(con->out.s);
	if (con->out.path != NULL)
		free(con->out.path);
	if (con->out.buf != NULL)
		free(con->out.buf);
	if (con->out.nodes != NULL)
		free(con->out.nodes);
d2237 2
a2238 2
	if (con->log != NULL)
		evbuffer_free(con->log);
d2240 1
a2240 1
	if (con->cnl != NULL) {
d2245 1
a2245 1
		free(con->cnl);
d2350 1
a2350 1
			    con->cnl == NULL) {
d2355 3
a2357 3
			bcopy(&cnl, con->cnl, sizeof(*con->cnl));
			evtimer_del(&con->ev);
			evtimer_set(&con->ev, relay_natlook, con);
d2359 1
a2359 1
			evtimer_add(&con->ev, &tv);
d2488 1
a2488 1
	struct relay	*rlay = (struct relay *)con->relay;
d2497 1
a2497 1
	if (!SSL_set_fd(ssl, con->in.s))
d2501 1
a2501 1
	con->in.ssl = ssl;
d2503 2
a2504 2
	event_again(&con->ev, con->in.s, EV_TIMEOUT|EV_READ,
	    relay_ssl_accept, &con->tv_start, &env->sc_timeout, con);
d2517 1
a2517 1
	struct relay	*rlay = (struct relay *)con->relay;
d2529 1
a2529 1
	ret = SSL_accept(con->in.ssl);
d2531 1
a2531 1
		ssl_err = SSL_get_error(con->in.ssl, ret);
d2557 1
a2557 1
	    rlay->rl_conf.name, con->id, relay_sessions);
d2560 1
a2560 1
	    rlay->rl_conf.name, con->id, relay_sessions);
d2566 1
a2566 1
	DPRINTF("relay_ssl_accept: session %d: scheduling on %s", con->id,
d2568 2
a2569 2
	event_again(&con->ev, fd, EV_TIMEOUT|retry_flag, relay_ssl_accept,
	    &con->tv_start, &env->sc_timeout, con);
d2591 1
a2591 1
	struct relay *rlay = (struct relay *)con->relay;
d2613 1
a2613 1
			    "want read", con->id);
d2617 1
a2617 1
			    "want write", con->id);
d2665 1
a2665 1
	struct relay *rlay = (struct relay *)con->relay;
d2692 1
a2692 1
				    "want read", con->id);
d2696 1
a2696 1
				    "want write", con->id);
d2915 1
a2915 1
	struct relay	*rlay = (struct relay *)b->relay;
d2921 1
a2921 1
	return ((int)a->id - b->id);
d2924 1
a2924 1
SPLAY_GENERATE(session_tree, session, nodes, relay_session_cmp);
@


1.78
log
@add prefixes to names of structure elements to make it easier to grep
for code, start with struct relayd.  finally.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.77 2007/12/08 20:36:36 pyr Exp $	*/
d275 2
a276 2
	TAILQ_FOREACH(rlay, env->sc_relays, entry) {
		if (rlay->conf.flags & F_DISABLE)
d278 2
a279 2
		close(rlay->s);
		while ((con = SPLAY_ROOT(&rlay->sessions)) != NULL)
d362 1
a362 1
	struct protocol		*proto = rlay->proto;
d421 2
a422 2
	TAILQ_FOREACH(rlay, env->sc_relays, entry) {
		log_debug("relay_privinit: adding relay %s", rlay->conf.name);
d427 1
a427 1
		switch (rlay->proto->type) {
d437 3
a439 3
		if (rlay->conf.flags & F_UDP)
			rlay->s = relay_udp_bind(&rlay->conf.ss,
			    rlay->conf.port, rlay->proto);
d441 3
a443 3
			rlay->s = relay_socket_listen(&rlay->conf.ss,
			    rlay->conf.port, rlay->proto);
		if (rlay->s == -1)
d468 3
a470 3
	TAILQ_FOREACH(rlay, env->sc_relays, entry) {
		if ((rlay->conf.flags & F_SSL) &&
		    (rlay->ssl_ctx = relay_ssl_ctx_create(rlay)) == NULL)
d473 2
a474 2
		if (rlay->dsttable != NULL) {
			switch (rlay->conf.dstmode) {
d476 1
a476 1
				rlay->dstkey = 0;
d480 5
a484 5
				rlay->dstkey =
				    hash32_str(rlay->conf.name, HASHINIT);
				rlay->dstkey =
				    hash32_str(rlay->dsttable->conf.name,
				    rlay->dstkey);
d487 3
a489 3
			rlay->dstnhosts = 0;
			TAILQ_FOREACH(host, &rlay->dsttable->hosts, entry) {
				if (rlay->dstnhosts >= RELAY_MAXHOSTS)
d492 2
a493 2
				host->idx = rlay->dstnhosts;
				rlay->dsthost[rlay->dstnhosts++] = host;
d496 2
a497 2
			    rlay->dstnhosts, rlay->dsttable->conf.name,
			    rlay->dsttable->conf.check ? "" : " (no check)");
d525 1
a525 1
	TAILQ_FOREACH(rlay, env->sc_relays, entry) {
d529 1
a529 1
		cur = &rlay->stats[proc_id];
d551 1
a551 1
		crs.id = rlay->conf.id;
d556 1
a556 1
		for (con = SPLAY_ROOT(&rlay->sessions);
d559 1
a559 1
			    &rlay->sessions, con);
d561 1
a561 1
			if (timercmp(&tv, &rlay->conf.timeout, >=))
d578 2
a579 2
	TAILQ_FOREACH(rlay, env->sc_relays, entry) {
		log_debug("relay_launch: running relay %s", rlay->conf.name);
d581 1
a581 1
		rlay->up = HOST_UP;
d583 1
a583 1
		if (rlay->conf.flags & F_UDP)
d588 1
a588 1
		event_set(&rlay->ev, rlay->s, EV_READ|EV_PERSIST,
d590 1
a590 1
		event_add(&rlay->ev, NULL);
d743 1
a743 1
	struct protocol		*proto = rlay->proto;
d754 1
a754 1
	    con->id, rlay->proto->lateconnect ? "late connect " : "");
d756 1
a756 1
	switch (rlay->proto->type) {
d759 1
a759 1
		if (!RB_EMPTY(&rlay->proto->response_tree)) {
d792 1
a792 1
	    rlay->conf.timeout.tv_sec, rlay->conf.timeout.tv_sec);
d800 1
a800 1
	struct protocol *proto = rlay->proto;
d804 1
a804 1
	switch (rlay->proto->type) {
d807 1
a807 1
		if (!RB_EMPTY(&rlay->proto->request_tree) ||
d835 1
a835 1
	if ((rlay->conf.flags & F_SSL) && con->in.ssl != NULL)
d839 1
a839 1
	    rlay->conf.timeout.tv_sec, rlay->conf.timeout.tv_sec);
d987 1
a987 1
			if (print_host(&rlay->conf.ss,
d996 1
a996 1
			    ntohs(rlay->conf.port));
d1003 1
a1003 1
		snprintf(ibuf, sizeof(ibuf), "%lu", rlay->conf.timeout.tv_sec);
d1268 1
a1268 1
	struct protocol		*proto = rlay->proto;
d1786 2
a1787 2
	if (rlay->proto->type != RELAY_PROTO_HTTP ||
	    (rlay->proto->flags & F_RETURN) == 0) {
d1796 1
a1796 1
	if (print_host(&rlay->conf.ss, hbuf, sizeof(hbuf)) == NULL)
d1813 1
a1813 1
	if ((style = rlay->proto->style) == NULL)
d1841 1
a1841 1
	    RELAYD_SERVERNAME, hbuf, ntohs(rlay->conf.port)) == -1)
d1888 1
a1888 1
	struct protocol *proto = rlay->proto;
d1901 1
a1901 1
	    rlay->conf.flags & F_DISABLE)
d1918 2
a1919 2
	con->relayid = rlay->conf.id;
	con->outkey = rlay->dstkey;
d1924 1
a1924 1
	con->retry = rlay->conf.dstretry;
d1929 1
a1929 1
	con->out.port = rlay->conf.dstport;
d1940 1
a1940 1
	SPLAY_INSERT(session_tree, &rlay->sessions, con);
d1943 1
a1943 1
	rlay->stats[proc_id].last++;
d1959 1
a1959 1
	if (rlay->conf.flags & F_NATLOOK) {
d1967 1
a1967 1
	if (rlay->conf.flags & F_NATLOOK && cnl != NULL) {
d1974 1
a1974 1
		bcopy(&rlay->conf.ss, &cnl->dst, sizeof(cnl->dst));
d1980 1
a1980 1
		bcopy(&rlay->conf.timeout, &tv, sizeof(tv));
d2019 1
a2019 1
	struct table		*table = rlay->dsttable;
d2028 1
a2028 1
	switch (rlay->conf.dstmode) {
d2030 3
a2032 3
		if ((int)rlay->dstkey >= rlay->dstnhosts)
			rlay->dstkey = 0;
		idx = (int)rlay->dstkey;
d2038 3
a2040 3
		p = relay_hash_addr(&rlay->conf.ss, p);
		p = hash32_buf(&rlay->conf.port, sizeof(rlay->conf.port), p);
		if ((idx = p % rlay->dstnhosts) >= RELAY_MAXHOSTS)
d2043 1
a2043 1
	host = rlay->dsthost[idx];
d2062 2
a2063 2
	if (rlay->conf.dstmode == RELAY_DSTMODE_ROUNDROBIN)
		rlay->dstkey = host->idx + 1;
d2082 1
a2082 1
	    rlay->conf.dstss.ss_family == AF_UNSPEC && rlay->dsttable == NULL) {
d2102 2
a2103 2
	if (bcmp(&rlay->conf.ss, &out->ss, sizeof(out->ss)) == 0 &&
	    out->port == rlay->conf.port) {
d2110 1
a2110 1
	if (rlay->conf.flags & F_UDP) {
d2114 1
a2114 1
		if (rlay->proto->request == NULL)
d2116 1
a2116 1
		if ((*rlay->proto->request)(con) == -1)
d2121 1
a2121 1
	if ((rlay->conf.flags & F_SSL) && (in->ssl == NULL)) {
d2126 1
a2126 1
	if (!rlay->proto->lateconnect && relay_connect(con) == -1) {
d2142 1
a2142 1
	if (rlay->dsttable != NULL) {
d2146 2
a2147 2
		bcopy(&rlay->conf.dstss, &con->out.ss, sizeof(con->out.ss));
		con->out.port = rlay->conf.dstport;
d2152 1
a2152 1
	    rlay->proto)) == -1) {
d2181 1
a2181 1
	SPLAY_REMOVE(session_tree, &rlay->sessions, con);
d2198 1
a2198 1
		    "%s%s%s", rlay->conf.name, con->id, relay_sessions,
d2362 1
a2362 1
			TAILQ_FOREACH(rlay, env->sc_relays, entry)
d2364 1
a2364 1
				    &rlay->sessions)
d2427 1
a2427 1
	struct protocol *proto = rlay->proto;
d2435 1
a2435 1
	SSL_CTX_set_timeout(ctx, rlay->conf.timeout.tv_sec);
d2462 1
a2462 1
	    rlay->ssl_cert, rlay->ssl_cert_len))
d2466 1
a2466 1
	if (!ssl_ctx_use_private_key(ctx, rlay->ssl_key, rlay->ssl_key_len))
d2472 2
a2473 2
	if (!SSL_CTX_set_session_id_context(ctx, rlay->conf.name,
	    strlen(rlay->conf.name)))
d2481 1
a2481 1
	ssl_error(rlay->conf.name, "relay_ssl_ctx_create");
d2491 1
a2491 1
	ssl = SSL_new(rlay->ssl_ctx);
d2510 1
a2510 1
	ssl_error(rlay->conf.name, "relay_ssl_transaction");
d2548 1
a2548 1
			ssl_error(rlay->conf.name, "relay_ssl_accept");
d2557 1
a2557 1
	    rlay->conf.name, con->id, relay_sessions);
d2560 1
a2560 1
	    rlay->conf.name, con->id, relay_sessions);
d2623 1
a2623 1
				ssl_error(rlay->conf.name, "relay_ssl_readcb");
d2702 1
a2702 1
					ssl_error(rlay->conf.name,
d2875 1
a2875 1
	if ((rlay->conf.flags & F_SSL) == 0)
d2878 1
a2878 1
	if (print_host(&rlay->conf.ss, hbuf, sizeof(hbuf)) == NULL)
d2884 2
a2885 2
	if ((rlay->ssl_cert = relay_load_file(certfile,
	    &rlay->ssl_cert_len)) == NULL)
d2892 2
a2893 2
	if ((rlay->ssl_key = relay_load_file(certfile,
	    &rlay->ssl_key_len)) == NULL)
d2916 1
a2916 1
	struct protocol	*proto = rlay->proto;
@


1.77
log
@Rename everything which reffered to services refer to rdr for internals
(for instance: rename struct service to struct rdr), refer to redirects
otherwise (hoststatectl output).
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.76 2007/12/08 17:07:09 reyk Exp $	*/
d207 1
a207 1
	for (i = 1; i < env->prefork_relay; i++) {
d233 1
a233 1
	for (i = 0; i < env->prefork_relay; i++) {
d275 1
a275 1
	TAILQ_FOREACH(rlay, env->relays, entry) {
d418 1
a418 1
	if (env->flags & F_SSL)
d421 1
a421 1
	TAILQ_FOREACH(rlay, env->relays, entry) {
d468 1
a468 1
	TAILQ_FOREACH(rlay, env->relays, entry) {
d502 3
a504 3
	evtimer_set(&env->statev, relay_statistics, NULL);
	bcopy(&env->statinterval, &tv, sizeof(tv));
	evtimer_add(&env->statev, &tv);
d525 1
a525 1
	TAILQ_FOREACH(rlay, env->relays, entry) {
d534 1
a534 1
		if ((cur->tick % (3600 / env->statinterval.tv_sec)) == 0) {
d539 1
a539 1
		if ((cur->tick % (86400 / env->statinterval.tv_sec)) == 0) {
d567 3
a569 3
	evtimer_set(&env->statev, relay_statistics, NULL);
	bcopy(&env->statinterval, &tv, sizeof(tv));
	evtimer_add(&env->statev, &tv);
d578 1
a578 1
	TAILQ_FOREACH(rlay, env->relays, entry) {
d2168 1
a2168 1
		    relay_connected, &con->tv_start, &env->timeout, con);
d2189 1
a2189 1
	if (env->opts & RELAYD_OPT_LOGUPDATE) {
d2362 1
a2362 1
			TAILQ_FOREACH(rlay, env->relays, entry)
d2504 1
a2504 1
	    relay_ssl_accept, &con->tv_start, &env->timeout, con);
d2569 1
a2569 1
	    &con->tv_start, &env->timeout, con);
@


1.76
log
@some changes to the relayd.conf configuration language and grammar.

the tables will look more like pf tables, it is easier to re-use
tables with different options, "services" will become "redirections"
(they refer to rdr pf rules), sync configuration directives of
redirect (l3, ex-service) relay (l7) sections (for example "virtual
host" will become "listen on"), all target definitions will start with
"forward to", etc. pp. (see relay.conf(5) and etc/relayd.conf)

discussed with pyr and deraadt
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.75 2007/12/07 17:17:01 reyk Exp $	*/
d178 1
a178 1
	purge_config(env, PURGE_SERVICES);
@


1.75
log
@hoststated gets renamed to relayd.  easier to type, and actually says
what the daemon does - it is a relayer that pays attention to the status
of pools of hosts; not a status checkers that happens to do some relaying
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.74 2007/11/28 16:25:12 reyk Exp $	*/
d497 1
a497 1
			    rlay->conf.dstcheck ? "" : " (no check)");
d2023 1
a2023 1
	if (rlay->conf.dstcheck && !table->up) {
d2048 1
a2048 1
		if (!rlay->conf.dstcheck || host->up == HOST_UP)
d2052 1
a2052 1
	TAILQ_FOREACH(host, &rlay->dsttable->hosts, entry) {
d2054 1
a2054 1
		if (!rlay->conf.dstcheck || host->up == HOST_UP)
@


1.74
log
@bump the current file descriptor resource limit (openfiles-cur) to the
maximum number of file descriptors for this login class
(openfiles-max) of the relay child processes. this will allow 1024
instead of just 128 open file descriptors in the default configuration
(class daemon), use the openfiles-max capability and the sysctl
kern.maxfiles to adjust the value.

ok gilles@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.73 2007/11/28 14:41:36 reyk Exp $	*/
d49 1
a49 1
#include "hoststated.h"
d136 1
a136 1
static struct hoststated	*env = NULL;
d158 1
a158 1
relay(struct hoststated *x_env, int pipe_parent2pfe[2], int pipe_parent2hce[2],
d183 1
a183 1
	if ((pw = getpwnam(HOSTSTATED_USER)) == NULL)
d197 1
a197 1
	hoststated_process = PROC_RELAY;
d1838 1
a1838 1
	    code, httperr, tmbuf, HOSTSTATED_SERVERNAME,
d1841 1
a1841 1
	    HOSTSTATED_SERVERNAME, hbuf, ntohs(rlay->conf.port)) == -1)
d2189 1
a2189 1
	if (env->opts & HOSTSTATED_OPT_LOGUPDATE) {
@


1.73
log
@typos
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.72 2007/11/26 09:38:25 reyk Exp $	*/
d27 1
d454 13
@


1.72
log
@allow to add labels to protocol actions, they will be printed in http
error pages and can be used to refer to additional information.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.71 2007/11/24 17:43:47 reyk Exp $	*/
d421 1
a421 1
		log_debug("relay_init: adding relay %s", rlay->conf.name);
d443 1
a443 1
			fatal("relay_launch: failed to listen");
@


1.71
log
@tweak for hostnames without dots (like "localhost")
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.70 2007/11/24 17:07:28 reyk Exp $	*/
d102 2
a103 1
void		 relay_close_http(struct session *, u_int, const char *);
d735 1
a735 1
		relay_close_http(con, 504, "connect timeout");
d750 1
a750 1
				    "failed to allocate nodes");
d768 1
a768 1
		    "failed to allocate output buffer event");
d924 2
a925 1
			relay_close_http(con, 500, "failed to modify header");
d934 1
a934 1
		relay_close_http(con, 403, "incomplete request");
d939 1
a939 1
		relay_close_http(con, 403, "rejecting request");
d1054 1
a1054 1
			relay_close_http(con, 400, "repeated header line");
d1072 2
a1073 1
				relay_close_http(con, 403, "rejecting request");
d1112 1
a1112 1
	relay_close_http(con, 500, strerror(errno));
d1294 1
a1294 1
				relay_close_http(con, 400, "malformed");
d1403 1
a1403 1
				relay_close_http(con, 500, errstr);
d1512 1
a1512 1
			relay_close_http(con, 502, "session failed");
d1526 1
a1526 1
	relay_close_http(con, 500, strerror(errno));
d1545 1
a1545 1
		relay_close_http(con, 500, "failed to allocate URL");
d1555 2
a1556 1
			relay_close_http(con, 500, "failed to allocate digest");
d1609 1
a1609 1
		relay_close_http(con, 400, "invalid host name");
d1625 1
a1625 1
		relay_close_http(con, 500, "failed to allocate path");
d1675 1
a1675 1
		relay_close_http(con, 500, "failed to allocate query");
d1716 1
a1716 1
		relay_close_http(con, 500, "failed to allocate cookie");
d1759 2
a1760 1
relay_close_http(struct session *con, u_int code, const char *msg)
d1769 1
a1769 1
	const char		*style;
d1795 2
d1819 2
a1820 1
	    "<p>%s</p>\n"
d1826 1
@


1.70
log
@sort includes, adjust to style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.69 2007/11/24 16:13:50 reyk Exp $	*/
d1616 2
@


1.69
log
@extend the url lookup algorithm to match the full URL and different
possible suffix/prefix combinations by stripping subdomains, path
components, and the query args.

ok and tested by gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.68 2007/11/24 13:39:24 reyk Exp $	*/
d19 1
a20 3
#include <sys/param.h>
#include <sys/types.h>
#include <sys/mman.h>
d28 1
a32 1
#include <net/if.h>
@


1.68
log
@fix goto to jump to the right place
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.67 2007/11/23 09:39:42 reyk Exp $	*/
d94 2
d388 1
a389 1
		i = 0;
d392 1
a392 3
			/* Limit the number of displayed lines */
			if (++i > 100) {
				fprintf(stderr, "\t\t...\n");
a393 1
			}
d397 7
d1531 3
a1533 3
int
relay_lookup_url(struct ctl_relay_event *cre, const char *str,
    enum digest_type type)
a1539 3
	if (cre->path == NULL)
		return (PN_PASS);

d1541 3
a1543 3
	    str, cre->path,
	    cre->args == NULL ? "" : "?",
	    cre->args == NULL ? "" : cre->args) == -1) {
d1548 2
d1581 76
@


1.67
log
@re-implement the "mark" action and document it in the manpage:
it is possible to attach a mark to a session based on matching an
entity (header, url, cookie, ...) and add conditional action for this
mark. it works a bit like the tag/tagged keywords in pf, but i decided
to pick a different name to avoid confusion.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.66 2007/11/22 16:07:03 reyk Exp $	*/
d1567 1
a1567 1
			goto done;
@


1.66
log
@Fix relay roundrobin mode to work correctly when multiple hosts in a
table are down.

Thanks to Preston Norvell at serialssolutions dot com for reporting
the problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.65 2007/11/22 10:09:53 reyk Exp $	*/
d344 7
d882 3
a910 3
		if ((pn->flags & PNFLAG_MARK) &&
		    cre->marked == 0)
			break;
a925 2
		if (pn->flags & PNFLAG_MARK)
			break;
a930 2
		if (pn->flags & PNFLAG_MARK)
			break;
d997 17
a1013 1
	int			 ret = PN_DROP;
d1017 1
a1017 1
		if (!header || ((pn->flags & PNFLAG_MARK) && cre->marked == 0))
d1037 1
a1037 1
		if (!header || ((pn->flags & PNFLAG_MARK) && cre->marked == 0))
d1060 2
a1061 3
		if (fnmatch(pn->value, pk->value, FNM_CASEFOLD) == 0) {
			if (pn->flags & PNFLAG_MARK)
				cre->marked++;
d1070 2
a1071 1
		if (SIMPLEQ_NEXT(pn, entry) == NULL)
a1074 2
		if ((pn->flags & PNFLAG_MARK) && cre->marked == 0)
			return (PN_PASS);
a1080 2
		if ((pn->flags & PNFLAG_MARK) && cre->marked == 0)
			return (PN_PASS);
d1085 7
d1095 1
a1095 1
	if (pn->flags & PNFLAG_LOG) {
a1498 1
		cre->marked = 0;
d2093 1
a2093 1
		log_info("relay %s, session %d (%d active), %s -> %s:%d, "
d2095 1
a2095 1
		    ibuf, obuf, ntohs(con->out.port), msg,
@


1.65
log
@add (new) "url" protocol action, this can be used to match/filter URL
suffix/prefix expressions like "example.com/index.html?args". a digest
mode allows to match against anonymized SHA1/MD5 digests of
suffix/prefix expressions.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.64 2007/11/21 20:41:40 reyk Exp $	*/
d466 1
d1907 1
a1907 1
		idx = (int)rlay->dstkey++;
d1937 2
@


1.64
log
@move HTTP cookie and query lookup code from the into separate functions
(the if () else if () block was getting very big).
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.63 2007/11/21 20:01:45 reyk Exp $	*/
d94 2
d289 1
d309 3
d330 1
d332 2
a333 1
			fprintf(stderr, "%s \"%s\"", s, pn->key);
d1389 18
a1406 1
		if (pn->flags & PNFLAG_LOOKUP_QUERY) {
d1501 54
@


1.63
log
@fix the tree comparison function. it turned out that it could fail
with large trees of protocol actions.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.62 2007/11/21 14:12:04 reyk Exp $	*/
d94 2
d286 2
a321 3
		fprintf(stderr, "expect \"%s\" from \"%s\"",
		    pn->value, pn->key);
		break;
d323 6
a328 2
		fprintf(stderr, "filter \"%s\" from \"%s\"",
		    pn->value, pn->key);
d1219 1
a1219 1
	char			*line, *ptr, *val;
d1349 2
a1350 4
				if (ret == PN_FAIL) {
					free(line);
					return;
				}
d1366 1
a1366 2
				free(line);
				return;
d1382 3
a1384 30
			if (cre->path == NULL || cre->args == NULL ||
			    strlen(cre->args) < 2 ||
			    (val = strdup(cre->args)) == NULL)
				goto next;
			ptr = val;
			while (ptr != NULL && strlen(ptr)) {
				pkv.key = ptr;
				pkv.type = NODE_TYPE_QUERY;
				if ((ptr = strchr(ptr, '&')) != NULL)
					*ptr++ = '\0';
				if ((pkv.value =
				    strchr(pkv.key, '=')) == NULL ||
				    strlen(pkv.value) < 1)
					continue;
				*pkv.value++ = '\0';

				if ((proot = RB_FIND(proto_tree,
				    cre->tree, &pkv)) == NULL)
					continue;
				PROTONODE_FOREACH(pnv, proot, entry) {
					ret = relay_handle_http(cre, proot,
					    pnv, &pkv, 0);
					if (ret == PN_FAIL) {
						free(val);
						free(line);
						return;
					}
				}
			}
			free(val);
d1386 3
a1388 45
			/*
			 * Decode the HTTP cookies
			 */
			val = strdup(pk.value);
			if (val == NULL)
				goto next;

			for (ptr = val; ptr != NULL && strlen(ptr);) {
				if (*ptr == ' ')
					*ptr++ = '\0';
				pkv.key = ptr;
				pkv.type = NODE_TYPE_COOKIE;
				if ((ptr = strchr(ptr, ';')) != NULL)
					*ptr++ = '\0';
				/*
				 * XXX We do not handle attributes
				 * ($Path, $Domain, or $Port)
				 */
				if (*pkv.key == '$')
					continue;

				if ((pkv.value =
				    strchr(pkv.key, '=')) == NULL ||
				    strlen(pkv.value) < 1)
					continue;
				*pkv.value++ = '\0';
				if (*pkv.value == '"')
					*pkv.value++ = '\0';
				if (pkv.value[strlen(pkv.value) - 1] == '"')
					pkv.value[strlen(pkv.value) - 1] = '\0';

				if ((proot = RB_FIND(proto_tree,
				    cre->tree, &pkv)) == NULL)
					continue;
				PROTONODE_FOREACH(pnv, proot, entry) {
					ret = relay_handle_http(cre, proot,
					    pnv, &pkv, 0);
					if (ret == PN_FAIL) {
						free(val);
						free(line);
						return;
					}
				}
			}
			free(val);
d1397 2
a1398 4
			else if (ret == PN_FAIL) {
				free(line);
				return;
			}
a1412 1
		continue;
d1473 97
@


1.62
log
@rename the "url" filter action to "query" to use the correct term.
please update your hoststated.conf configurations. also add more
examples to the manpage.

alright pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.61 2007/11/21 11:06:21 reyk Exp $	*/
d2669 5
a2673 2
	return (strcasecmp(a->key, b->key) +
	    a->type == b->type ? 0 : (a->type > b->type ? 1 : -1));
@


1.61
log
@more work on the "filter" action: close the connection instantly when
receiving a filtered entity, fix some remaining issues.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.60 2007/11/20 17:11:50 reyk Exp $	*/
d284 3
d293 2
a294 2
	case NODE_TYPE_URL:
		fprintf(stderr, "url ");
a331 1
		fprintf(stderr, "none \"%s\"", pn->key);
d1301 1
a1301 1
			 * Decode the URL
d1379 1
a1379 1
		if (pn->flags & PNFLAG_LOOKUP_URL) {
d1387 1
a1387 1
				pkv.type = NODE_TYPE_URL;
@


1.60
log
@limit the number of displayed lines per node in relay_protodebug().
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.59 2007/11/20 15:54:55 reyk Exp $	*/
d861 4
a864 1
		if (cre->nodes[proot->id] <= 1)
a865 1
		cre->nodes[pn->id] = 0;
a1015 1
		ret = PN_PASS;
d1021 4
d1029 6
@


1.59
log
@it may be desirable to send a HTTP error page with error code and a
meaningful message if a HTTP/HTTPS relay closes the connection for
some reason. for example, a "403 Forbidden" if the request was
rejected by a filter. this will be enabled with the "return error"
option and is disabled by default, the standard behaviour is to
silently drop the connection; the browser may display an empty page in
this case. the look+feel of the HTTP error page can be customized with
a CSS style sheet, but we do not intend to allow customization of the
error page contents (hoststated is not a webserver!).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.58 2007/11/20 15:10:46 reyk Exp $	*/
d342 1
d365 9
a373 1
		PROTONODE_FOREACH(pn, proot, entry)
d375 1
@


1.58
log
@another fix to handle "expect" and "filter" actions in the new style
correctly.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.57 2007/11/20 09:59:09 reyk Exp $	*/
d86 1
d98 1
d697 1
a697 1
		relay_close(con, "connect timeout");
d711 2
a712 1
				relay_close(con, "failed to allocate nodes");
d729 2
a730 1
		relay_close(con, "failed to allocate output buffer event");
d803 15
d884 1
a884 1
			relay_close(con, "failed to modify header");
d895 1
a895 1
		relay_close(con, "incomplete header");
d902 1
a902 1
		relay_close(con, "rejecting header");
d1001 1
a1001 1
			relay_close(con, "repeated header line");
d1046 1
a1046 1
	relay_close(con, strerror(errno));
d1228 2
a1229 1
				goto fail;
a1337 1

d1339 1
a1339 1
				relay_close(con, errstr);
d1505 1
a1505 1
			relay_close(con, "session failed");
d1519 81
a1599 1
	relay_close(con, strerror(errno));
@


1.57
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.56 2007/11/20 09:57:49 reyk Exp $	*/
d828 1
d832 1
a832 1
		if (!cre->nodes[pn->id])
d837 4
a840 5
		if (proot == pn)
			cre->nodes[proot->id]--;
		if (cre->nodes[proot->id]) {
			if (SIMPLEQ_NEXT(pn, entry) == NULL)
				cre->nodes[proot->id] = 0;
a841 1
		}
d981 1
a981 1
		if (cre->nodes[proot->id]) {
@


1.56
log
@minor change to some relay log messages
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.55 2007/11/19 15:31:36 reyk Exp $	*/
a86 1

a940 1

@


1.55
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.54 2007/11/19 14:48:19 reyk Exp $	*/
d867 1
a867 1
			relay_close(con, "failed to modify header (done)");
d878 1
a878 1
		relay_close(con, "incomplete header (done)");
d885 1
a885 1
		relay_close(con, "rejecting header (done)");
d985 1
a985 1
			relay_close(con, "repeated header line (done)");
d1063 1
a1063 1
	relay_close(con, "last http content read (done)");
@


1.54
log
@rework the internal handling of protocol actions a little bit:

- allow to use a key for multiple times by appending a queue of
additional matches to the tree node. for example, this allows to
specify multiple "expect" or "filter" actions to white-/black-list
a list of HTTP-headers, URLs, ..

- prevent specifing an HTTP header for multiple times when using the
expect action.

- minor code shuffling
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.53 2007/10/22 17:14:10 reyk Exp $	*/
d1214 1
a1214 1
				
d1624 1
a1624 1
		imsg_compose(ibuf_pfe, IMSG_NATLOOK, 0, 0, -1, cnl, 
d2492 1
a2492 1
	int	 	 fd;
@


1.53
log
@we don't need mmap/munmap in relay_load_certificates anymore...
just use read() and make the function a little bit nicer.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.52 2007/10/22 16:53:30 pyr Exp $	*/
d59 1
d87 3
d91 2
a92 1
		    struct protonode *, struct protonode *, int);
d281 54
d337 4
a340 4
	struct protocol *proto = rlay->proto;
	struct protonode *pn;
	struct proto_tree *tree;
	const char *name;
d362 3
a364 51
	RB_FOREACH(pn, proto_tree, tree) {
		fprintf(stderr, "\t\t");

		fprintf(stderr, "%s ", name);

		switch (pn->type) {
		case NODE_TYPE_HEADER:
			break;
		case NODE_TYPE_URL:
			fprintf(stderr, "url ");
			break;
		case NODE_TYPE_COOKIE:
			fprintf(stderr, "cookie ");
			break;
		case NODE_TYPE_PATH:
			fprintf(stderr, "path ");
			break;
		}

		switch (pn->action) {
		case NODE_ACTION_APPEND:
			fprintf(stderr, "append \"%s\" to \"%s\"",
			    pn->value, pn->key);
			break;
		case NODE_ACTION_CHANGE:
			fprintf(stderr, "change \"%s\" to \"%s\"",
			    pn->key, pn->value);
			break;
		case NODE_ACTION_REMOVE:
			fprintf(stderr, "remove \"%s\"",
			    pn->key);
			break;
		case NODE_ACTION_EXPECT:
			fprintf(stderr, "expect \"%s\" from \"%s\"",
			    pn->value, pn->key);
			break;
		case NODE_ACTION_FILTER:
			fprintf(stderr, "filter \"%s\" from \"%s\"",
			    pn->value, pn->key);
			break;
		case NODE_ACTION_HASH:
			fprintf(stderr, "hash \"%s\"", pn->key);
			break;
		case NODE_ACTION_LOG:
			fprintf(stderr, "log \"%s\"", pn->key);
			break;
		case NODE_ACTION_NONE:
			fprintf(stderr, "none \"%s\"", pn->key);
			break;
		}
		fprintf(stderr, "\n");
d823 70
d945 2
a946 2
relay_handle_http(struct ctl_relay_event *cre, struct protonode *pn,
    struct protonode *pk, int header)
d980 8
d997 1
a997 1
			cre->nodes[pn->id] = 1;
d999 2
d1174 3
a1176 3
	struct protonode	*pn, pk, *pnv, pkv;
	char			*line, buf[READ_BUF_SIZE], *ptr, *val;
	int			 header = 0, ret;
d1210 5
d1275 1
d1297 1
a1297 1
			if ((pnv = RB_FIND(proto_tree,
d1301 7
a1307 4
			ret = relay_handle_http(cre, pnv, &pkv, 0);
			if (ret == PN_FAIL) {
				free(line);
				goto fail;
d1357 1
a1357 1
				if ((pnv = RB_FIND(proto_tree,
d1360 8
a1367 7
				ret = relay_handle_http(cre, pnv, &pkv, 0);
				if (ret == PN_PASS)
					continue;
				else if (ret == PN_FAIL) {
					free(val);
					free(line);
					return;
d1403 1
a1403 1
				if ((pnv = RB_FIND(proto_tree,
d1406 8
a1413 7
				ret = relay_handle_http(cre, pnv, &pkv, 0);
				if (ret == PN_PASS)
					continue;
				else if (ret == PN_FAIL) {
					free(val);
					free(line);
					return;
d1420 10
a1429 7
		ret = relay_handle_http(cre, pn, &pk, header);
		if (ret == PN_PASS)
			goto next;
		free(line);
		if (ret == PN_FAIL)
			return;
		continue;
d1431 1
d1433 8
a1440 7
		if (relay_bufferevent_print(cre->dst, pk.key) == -1 ||
		    relay_bufferevent_print(cre->dst,
		    header ? ": " : " ") == -1 ||
		    relay_bufferevent_print(cre->dst, pk.value) == -1 ||
		    relay_bufferevent_print(cre->dst, "\r\n") == -1) {
			free(line);
			goto fail;
d1446 4
a1449 54
		RB_FOREACH(pn, proto_tree, cre->tree) {
			switch (pn->action) {
			case NODE_ACTION_FILTER:
				if (!cre->nodes[pn->id])
					continue;
				cre->nodes[pn->id] = 0;
				break;
			default:
				if (cre->nodes[pn->id]) {
					cre->nodes[pn->id] = 0;
					continue;
				}
				break;
			}
			switch (pn->action) {
			case NODE_ACTION_APPEND:
			case NODE_ACTION_CHANGE:
				ptr = pn->value;
				if ((pn->flags & PNFLAG_MARK) &&
				    cre->marked == 0)
					break;
				if ((pn->flags & PNFLAG_MACRO) &&
				    (ptr = relay_expand_http(cre, pn->value,
				    buf, sizeof(buf))) == NULL)
					break;
				if (relay_bufferevent_print(cre->dst,
				    pn->key) == -1 ||
				    relay_bufferevent_print(cre->dst,
				    ": ") == -1 ||
				    relay_bufferevent_print(cre->dst,
				    ptr) == -1 ||
				    relay_bufferevent_print(cre->dst,
				    "\r\n") == -1)
					goto fail;
				DPRINTF("relay_read_http: add '%s: %s'",
				    pn->key, ptr);
				break;
			case NODE_ACTION_EXPECT:
				if (pn->flags & PNFLAG_MARK)
					break;
				DPRINTF("relay_read_http: missing '%s: %s'",
				    pn->key, pn->value);
				relay_close(con, "incomplete header (done)");
				return;
			case NODE_ACTION_FILTER:
				if (pn->flags & PNFLAG_MARK)
					break;
				DPRINTF("relay_read_http: filtered '%s: %s'",
				    pn->key, pn->value);
				relay_close(con, "rejecting header (done)");
				return;
			default:
				break;
			}
@


1.52
log
@load certificates text at parse time. then load them in relay processes.
this separation will ease reload a bit more.

ok reyk@@ who spotted a stupid mistake again...
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.51 2007/10/19 14:15:14 pyr Exp $	*/
d115 1
d2429 30
a2461 2
	int	 fd;
	off_t	 len;
a2463 1
	char	*str;
d2465 2
a2466 2
	if (!(rlay->conf.flags & F_SSL))
		return 0;
d2469 1
a2469 1
		return -1;
d2473 4
a2476 21
		return -1;
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		return -1;
	if ((len = lseek(fd, 0, SEEK_END)) == -1) {
		close(fd);
		return -1;
	}
	rlay->ssl_cert_len = len + 1;
	if ((rlay->ssl_cert = calloc(1, rlay->ssl_cert_len)) == NULL) {
		close(fd);
		return -1;
	}
	if ((str = mmap(NULL, len, PROT_READ, MAP_FILE|MAP_PRIVATE,
	    fd, 0)) == MAP_FAILED)  {
		close(fd);
		return -1;
	}
	close(fd);
	rlay->ssl_cert_len = len;
	(void)strlcpy(rlay->ssl_cert, str, rlay->ssl_cert_len);
	munmap(str, rlay->ssl_cert_len);
d2482 3
a2484 19
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		return -1;
	if ((len = lseek(fd, 0, SEEK_END)) == -1) {
		close(fd);
		return -1;
	}
	rlay->ssl_key_len = len + 1;
	if ((rlay->ssl_key = calloc(1, rlay->ssl_key_len)) == NULL) {
		close(fd);
		return -1;
	}
	if ((str = mmap(NULL, len, PROT_READ, MAP_FILE|MAP_PRIVATE,
	    fd, 0)) == MAP_FAILED) {
		close(fd);
		return -1;
	}
	close(fd);
	(void)strlcpy(rlay->ssl_key, str, rlay->ssl_key_len);
	munmap(str, rlay->ssl_key_len);
@


1.51
log
@Move relays from static TAILQs to allocated ones.
This syncs it with other hoststated entities and will make reload easier.
This is step 1 out of 7 for reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.50 2007/10/05 17:32:13 reyk Exp $	*/
a93 1
int		 relay_ssl_ctx_init(struct relay *);
a385 4
		if ((rlay->conf.flags & F_SSL) &&
		    relay_ssl_ctx_init(rlay) == -1)
			fatal("relay_launch: could not open certificates");

a2012 42
int
relay_ssl_ctx_init(struct relay *rlay)
{
	int	fd;
	off_t	len;
	char	certfile[PATH_MAX];
	char	hbuf[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];

	if (print_host(&rlay->conf.ss, hbuf, sizeof(hbuf)) == NULL)
		return -1;

	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/%s.crt", hbuf) == -1)
		return -1;
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		return -1;
	if ((len = lseek(fd, 0, SEEK_END)) == -1)
		return -1;
	if ((rlay->ssl_cert = mmap(NULL, len, PROT_READ, MAP_FILE|MAP_PRIVATE,
	    fd, 0)) == MAP_FAILED)
		return -1;
	rlay->ssl_cert_len = len;
	close(fd);
	log_debug("relay_ssl_ctx_init: using certificate %s", certfile);

	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/private/%s.key", hbuf) == -1)
		return -1;
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		return -1;
	if ((len = lseek(fd, 0, SEEK_END)) == -1)
		return -1;
	if ((rlay->ssl_key = mmap(NULL, len, PROT_READ, MAP_FILE|MAP_PRIVATE,
	    fd, 0)) == MAP_FAILED)
		return -1;
	rlay->ssl_key_len = len;
	close(fd);
	log_debug("relay_ssl_ctx_init: using private key %s", certfile);

	return (0);
}

a2052 1
	munmap(rlay->ssl_cert, rlay->ssl_cert_len);
a2056 1
	munmap(rlay->ssl_key, rlay->ssl_key_len);
d2426 67
@


1.50
log
@stylistic changes in the relay/relay_config structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.49 2007/10/05 15:46:49 reyk Exp $	*/
d263 1
a263 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
d371 1
a371 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
d409 1
a409 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
d465 1
a465 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
d518 1
a518 1
	TAILQ_FOREACH(rlay, &env->relays, entry) {
d1956 1
a1956 1
			TAILQ_FOREACH(rlay, &env->relays, entry)
@


1.49
log
@unbreak non-SSL relays by calling the ssl context init only if the SSL
flag is present...
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.48 2007/10/01 13:57:29 pyr Exp $	*/
d411 1
a411 1
		    (rlay->ctx = relay_ssl_ctx_create(rlay)) == NULL)
d2129 1
a2129 1
	ssl = SSL_new(rlay->ctx);
@


1.48
log
@kill some remaining debug that snuk in.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.47 2007/09/28 13:05:28 pyr Exp $	*/
d410 2
a411 1
		if ((rlay->ctx = relay_ssl_ctx_create(rlay)) == NULL)
@


1.47
log
@Change the ssl_privsep code to work on char buffers.
The fd based code introduced weirdness since all children were accessing
the same fd at once. This will also greatly facilitate reloading, no
fd-passing will be involved between the parent and relay children.

While there, cleanup the code diverting from the original ssl_rsa.c code
a bit more.

Weird behavior discovery by pascoe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.46 2007/09/27 13:50:40 pyr Exp $	*/
a2063 1
	const char *ssl_action = "NO ACTION";
a2117 1
	log_debug("last SSL action: %s", ssl_action);
@


1.46
log
@Move SSL context creation after privileges are dropped.
This puts the ssl_privsep code to use.
One more step towards graceful L7 reload.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.45 2007/09/27 13:34:22 pyr Exp $	*/
d22 1
d2020 2
d2031 1
a2031 1
	if ((rlay->cert_fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
d2033 7
d2045 6
a2050 1
	if ((rlay->key_fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
d2052 2
d2097 2
a2098 1
	if (!ssl_ctx_use_certificate_chain(ctx, rlay->cert_fd))
d2100 1
d2103 1
a2103 1
	if (!ssl_ctx_use_private_key(ctx, rlay->key_fd))
d2105 1
@


1.45
log
@Simplify ssl_privsep.c, since it won't need to remain synced with the
equivalent openssl functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.44 2007/09/25 08:24:26 pyr Exp $	*/
d93 1
d387 2
a388 2
		    (rlay->ctx = relay_ssl_ctx_create(rlay)) == NULL)
			fatal("relay_launch: failed to create SSL context");
d409 3
d2016 26
a2044 1
	int fd;
d2047 1
a2047 1
	char certfile[PATH_MAX], hbuf[128];
d2079 2
a2080 11
	if (print_host(&rlay->conf.ss, hbuf, sizeof(hbuf)) == NULL)
		goto err;

	/* Load the certificate */
	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/%s.crt", hbuf) == -1)
		goto err;
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		goto err;
	log_debug("relay_ssl_ctx_create: using certificate %s", certfile);
	if (!ssl_ctx_use_certificate_chain(ctx, fd))
d2083 2
a2084 9
	/* Load the private key */
	if (snprintf(certfile, sizeof(certfile),
	    "/etc/ssl/private/%s.key", hbuf) == -1) {
		goto err;
	}
	if ((fd = open(certfile, O_RDONLY|O_NONBLOCK)) == -1)
		goto err;
	log_debug("relay_ssl_ctx_create: using private key %s", certfile);
	if (!ssl_ctx_use_private_key(ctx, fd))
d2099 1
@


1.44
log
@Introduce two new functions to be able to load certificates while
already chrooted and with privileges dropped.
This is the very first step in being able to reload a
layer 7 configuration.

not ok reyk who's away but should be glad to see this in.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.43 2007/09/10 11:59:22 reyk Exp $	*/
d2071 1
a2071 1
	if (!ssl_ctx_use_private_key(ctx, fd,  SSL_FILETYPE_PEM))
@


1.43
log
@add support for relaying DNS traffic (with a little bit of packet
header randomization). this adds an infrastructure to support
UDP-based protocols.

ok gilles@@, tested by some
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.42 2007/09/07 08:20:24 reyk Exp $	*/
d2015 1
d2057 2
d2060 1
a2060 1
	if (!SSL_CTX_use_certificate_chain_file(ctx, certfile))
d2068 2
d2071 1
a2071 1
	if (!SSL_CTX_use_PrivateKey_file(ctx, certfile,  SSL_FILETYPE_PEM))
@


1.42
log
@add an interface to dump running relay sessions to the control socket
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.41 2007/09/06 19:55:45 reyk Exp $	*/
d61 1
d112 2
d293 3
d375 10
d389 7
a395 2
		if ((rlay->s = relay_socket_listen(&rlay->conf.ss,
		    rlay->conf.port, rlay->proto)) == -1)
d510 1
d517 5
d523 1
a523 1
		    relay_accept, rlay);
d529 1
a529 2
relay_socket(struct sockaddr_storage *ss, in_port_t port,
    struct protocol *proto)
a530 3
	int s = -1, val;
	struct linger lng;

d542 2
d546 13
d1687 2
a1688 1
	struct relay	*rlay = (struct relay *)con->relay;
d1690 2
a1691 2
	if (bcmp(&rlay->conf.ss, &con->out.ss, sizeof(con->out.ss)) == 0 &&
	    con->out.port == rlay->conf.port) {
d1698 12
a1709 1
	if ((rlay->conf.flags & F_SSL) && (con->in.ssl == NULL)) {
d2407 30
@


1.41
log
@rename relay_host to print_host in log.c
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.40 2007/09/05 10:25:13 reyk Exp $	*/
d1470 1
d1481 9
d1796 1
d1898 8
@


1.40
log
@be extra careful with pointers in session_cmp
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.39 2007/09/05 08:48:42 reyk Exp $	*/
a76 1
const char	*relay_host(struct sockaddr_storage *, char *, size_t);
d783 1
a783 1
			if (relay_host(&cre->ss, ibuf, sizeof(ibuf)) == NULL)
d798 1
a798 1
			if (relay_host(&rlay->conf.ss,
a1435 14
const char *
relay_host(struct sockaddr_storage *ss, char *buf, size_t len)
{
	int af = ss->ss_family;
	void *ptr;

	bzero(buf, len);
	if (af == AF_INET)
		ptr = &((struct sockaddr_in *)ss)->sin_addr;
	else
		ptr = &((struct sockaddr_in6 *)ss)->sin6_addr;
	return (inet_ntop(af, ptr, buf, len));
}

d1720 2
a1721 2
		(void)relay_host(&con->in.ss, ibuf, sizeof(ibuf));
		(void)relay_host(&con->out.ss, obuf, sizeof(obuf));
d1980 1
a1980 1
	if (relay_host(&rlay->conf.ss, hbuf, sizeof(hbuf)) == NULL)
@


1.39
log
@store relay sessions in SPLAY trees instead of TAILQ lists. this will
be used for faster lookups of sessions based on different criteria.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.38 2007/09/04 10:58:08 reyk Exp $	*/
d2367 1
a2367 1
	struct relay	*rlay = (struct relay *)a->relay;
d2370 1
a2370 1
	if (proto->cmp != NULL)
@


1.38
log
@small fix in the error path when accepting new relay sessions
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.37 2007/09/04 10:32:54 reyk Exp $	*/
d263 1
a263 1
		while ((con = TAILQ_FIRST(&rlay->sessions)) != NULL)
d470 1
a470 1
		for (con = TAILQ_FIRST(&rlay->sessions);
d472 2
a473 1
			next_con = TAILQ_NEXT(con, entry);
d1497 1
a1497 1
	TAILQ_INSERT_HEAD(&rlay->sessions, con, entry);
d1724 1
a1724 1
	TAILQ_REMOVE(&rlay->sessions, con, entry);
d2363 14
@


1.37
log
@support chained ssl certificates; a chain can be added to the
PEM-encoded server cert file (no CA support yet).

makes a chained ssl certificate from Comodo work with hoststated, also
tested with other certs (self-signed, Thawte Premium)

thanks to ben (pr0ncracker at gmail dot com)
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.36 2007/07/26 23:29:40 jsg Exp $	*/
d1495 6
d1517 4
a1520 2
		    calloc(1, sizeof(struct ctl_natlook))) == NULL)
			goto err;
a1521 6

	relay_sessions++;
	TAILQ_INSERT_HEAD(&rlay->sessions, con, entry);

	/* Increment the per-relay session counter */
	rlay->stats[proc_id].last++;
@


1.36
log
@Combine http filter/expect cases to simplify code.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.35 2007/06/19 06:29:20 pyr Exp $	*/
d2000 1
a2000 1
	if (!SSL_CTX_use_certificate_file(ctx, certfile, SSL_FILETYPE_PEM))
@


1.35
log
@Do not fatal out with ``pipe closed'' when a short read occurs on one
of our socket pairs. Instead disable listening on the pipe, terminate the
event loop, and let the parent process's SIGCHLD handler do a clean
shutdown.

from an ospfd diff by claudio, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.34 2007/06/12 15:16:10 msf Exp $	*/
a858 7
		DPRINTF("relay_handle_http: expect '%s: %s'",
		    pn->key, pn->value);
		if (fnmatch(pn->value, pk->value, FNM_CASEFOLD) == 0) {
			if (pn->flags & PNFLAG_MARK)
				cre->marked++;
			cre->nodes[pn->id] = 1;
		}
d860 1
a860 1
		break;
d862 2
a863 1
		DPRINTF("relay_handle_http: filter '%s: %s'",
@


1.34
log
@put the fd passing from bgpd back in to hoststated's version of imsg,
needed for layer 7 reload support.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.33 2007/06/07 07:19:50 pyr Exp $	*/
d1817 6
a1822 2
		if (n == 0)
			fatalx("relay_dispatch_pfe: pipe closed");
d1928 6
a1933 2
		if (n == 0)
			fatalx("relay_dispatch_parent: pipe closed");
@


1.33
log
@(finally) Enable reload support for layer 3 configurations.
Hoststated can be reloaded either by sending SIGHUP to the parent process
or by using ``hoststatectl reload''
discussed and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.32 2007/05/29 00:48:04 pyr Exp $	*/
d467 1
a467 1
		imsg_compose(ibuf_pfe, IMSG_STATISTICS, 0, 0,
d1535 2
a1536 1
		imsg_compose(ibuf_pfe, IMSG_NATLOOK, 0, 0, cnl, sizeof(*cnl));
d1788 1
a1788 1
		imsg_compose(ibuf_pfe, IMSG_KILLSTATES, 0, 0,
@


1.32
log
@move the ssl cipher suite string to a (small) static charbuf,
this will make it easier to send the struct over the socket.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.31 2007/05/29 00:21:10 pyr Exp $	*/
d175 3
@


1.31
log
@move struct relay to the runtime + config scheme.
this time around, include hoststatectl changes too.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.30 2007/05/28 22:11:33 pyr Exp $	*/
d1954 1
a1954 1
	char certfile[PATH_MAX], hbuf[128], *ciphers = NULL;
d1983 1
a1983 4
	/* Change the default SSL cipher suite, if specified */
	if ((ciphers = proto->sslciphers) == NULL)
		ciphers = SSLCIPHERS_DEFAULT;
	if (!SSL_CTX_set_cipher_list(ctx, ciphers))
@


1.30
log
@another small step towards hoststated reloading.
allow purging of parts of the hoststated environment structure.
start using this function now to only keep vital information in
hoststated children processes.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.29 2007/05/27 20:53:10 pyr Exp $	*/
d257 1
a257 1
		if (rlay->flags & F_DISABLE)
d362 1
a362 1
		log_debug("relay_init: adding relay %s", rlay->name);
d367 1
a367 1
		if ((rlay->flags & F_SSL) &&
d371 2
a372 2
		if ((rlay->s = relay_socket_listen(&rlay->ss, rlay->port,
		    rlay->proto)) == -1)
d386 1
a386 1
			switch (rlay->dstmode) {
d393 1
a393 1
				    hash32_str(rlay->name, HASHINIT);
d408 1
a408 1
			    rlay->dstcheck ? "" : " (no check)");
d462 1
a462 1
		crs.id = rlay->id;
d471 1
a471 1
			if (timercmp(&tv, &rlay->timeout, >=))
d488 1
a488 1
		log_debug("relay_launch: running relay %s", rlay->name);
d683 1
a683 1
	    rlay->timeout.tv_sec, rlay->timeout.tv_sec);
d726 1
a726 1
	if ((rlay->flags & F_SSL) && con->in.ssl != NULL)
d730 1
a730 1
	    rlay->timeout.tv_sec, rlay->timeout.tv_sec);
d795 2
a796 1
			if (relay_host(&rlay->ss, ibuf, sizeof(ibuf)) == NULL)
d803 2
a804 1
			snprintf(ibuf, sizeof(ibuf), "%u", ntohs(rlay->port));
d811 1
a811 1
		snprintf(ibuf, sizeof(ibuf), "%lu", rlay->timeout.tv_sec);
d1469 2
a1470 1
	if (relay_sessions >= RELAY_MAX_SESSIONS || rlay->flags & F_DISABLE)
d1492 1
a1492 1
	con->retry = rlay->dstretry;
d1512 1
a1512 1
	if (rlay->flags & F_NATLOOK) {
d1524 1
a1524 1
	if (rlay->flags & F_NATLOOK && cnl != NULL) {
d1531 1
a1531 1
		bcopy(&rlay->ss, &cnl->dst, sizeof(cnl->dst));
d1536 1
a1536 1
		bcopy(&rlay->timeout, &tv, sizeof(tv));
d1579 1
a1579 1
	if (rlay->dstcheck && !table->up) {
d1584 1
a1584 1
	switch (rlay->dstmode) {
d1594 2
a1595 2
		p = relay_hash_addr(&rlay->ss, p);
		p = hash32_buf(&rlay->port, sizeof(rlay->port), p);
d1604 1
a1604 1
		if (!rlay->dstcheck || host->up == HOST_UP)
d1610 1
a1610 1
		if (!rlay->dstcheck || host->up == HOST_UP)
d1636 1
a1636 1
	    rlay->dstss.ss_family == AF_UNSPEC && rlay->dsttable == NULL) {
d1655 2
a1656 2
	if (bcmp(&rlay->ss, &con->out.ss, sizeof(con->out.ss)) == 0 &&
	    con->out.port == rlay->port) {
d1663 1
a1663 1
	if ((rlay->flags & F_SSL) && (con->in.ssl == NULL)) {
d1688 2
a1689 2
		bcopy(&rlay->dstss, &con->out.ss, sizeof(con->out.ss));
		con->out.port = rlay->dstport;
d1740 1
a1740 1
		    "%s%s%s", rlay->name, con->id, relay_sessions,
d1961 1
a1961 1
	SSL_CTX_set_timeout(ctx, rlay->timeout.tv_sec);
d1989 1
a1989 1
	if (relay_host(&rlay->ss, hbuf, sizeof(hbuf)) == NULL)
d2012 2
a2013 2
	if (!SSL_CTX_set_session_id_context(ctx, rlay->name,
	    strlen(rlay->name)))
d2021 1
a2021 1
	ssl_error(rlay->name, "relay_ssl_ctx_create");
d2050 1
a2050 1
	ssl_error(rlay->name, "relay_ssl_transaction");
d2088 1
a2088 1
			ssl_error(rlay->name, "relay_ssl_accept");
d2097 1
a2097 1
	    rlay->name, con->id, relay_sessions);
d2100 1
a2100 1
	    rlay->name, con->id, relay_sessions);
d2163 1
a2163 1
				ssl_error(rlay->name, "relay_ssl_readcb");
d2242 1
a2242 1
					ssl_error(rlay->name,
@


1.29
log
@Second step towards hoststated reload:
First split out hosts, tables and services into to structs, one that
contains the runtime fields and one (inside the runtime) that contains
mostly static fields that will be sent over the socket during reload.

Also move the demoted field of tables inside the flags field as its
just a boolean.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.28 2007/05/26 19:58:49 pyr Exp $	*/
d162 1
@


1.28
log
@first steps for implementing reload:
	* make parse_config allocate the hoststated function by itself
	* make as many sockets as necessary to talk to the relay children
	* add send_all for talking to all children
with advise and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.27 2007/05/02 09:07:28 claudio Exp $	*/
d394 1
a394 1
				    hash32_str(rlay->dsttable->name,
d406 1
a406 1
			    rlay->dstnhosts, rlay->dsttable->name,
d1597 1
a1597 1
	    host->name, p, idx);
d1599 1
a1599 1
		DPRINTF("relay_from_table: host %s", host->name);
d1605 1
a1605 1
		DPRINTF("relay_from_table: next host %s", host->name);
d1614 3
a1616 3
	con->retry = host->retry;
	con->out.port = table->port;
	bcopy(&host->ss, &con->out.ss, sizeof(con->out.ss));
d1832 2
a1833 1
			if ((table = table_find(env, host->tableid)) == NULL)
d1857 1
a1857 1
				    host->id, host->up);
d1861 2
a1862 1
			if ((table = table_find(env, host->tableid)) == NULL)
d1866 2
a1867 1
			    "host %u %s", proc_id, st.up, host->id, host->name);
@


1.27
log
@It is no longer needed to pass a cleared timeval to event_loopexit() NULL
does the job just fine. OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.26 2007/04/12 14:45:45 reyk Exp $	*/
d143 1
a143 1
    int pipe_parent2relay[2], int pipe_pfe2hce[2],
a212 1
	close(pipe_parent2relay[0]);
d216 2
d221 1
d227 2
a229 1
	imsg_init(ibuf_main, pipe_parent2relay[1], relay_dispatch_parent);
d1939 1
@


1.26
log
@add a new relay 'path' action to filter the URL path and arguments.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.25 2007/04/10 21:33:52 reyk Exp $	*/
a133 5
	struct timeval tv;

	tv.tv_sec = 0;
	tv.tv_usec = 0;

a134 1
	case SIGALRM:
a135 1
	case SIGQUIT:
d137 1
a137 1
		event_loopexit(&tv);
@


1.25
log
@move the decoding of the URL, independent from the node lookups, we
will need it later.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.24 2007/04/10 18:18:26 reyk Exp $	*/
d310 3
d1150 23
d1759 2
d1772 2
@


1.24
log
@it is a better idea to handle all enum values in the switch statement
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.23 2007/04/10 18:14:17 reyk Exp $	*/
d1045 1
a1045 1
	char			*line, buf[READ_BUF_SIZE], *ptr, *val, *method;
d1105 1
a1105 1
			if (cre->dir == RELAY_DIR_RESPONSE)
d1107 2
a1108 1
			else if (strcmp("GET", pk.key) == 0)
d1124 23
d1166 1
d1179 3
a1181 5
			/*
			 * Decode the URL
			 */
			val = strdup(pk.value);
			if (val == NULL)
d1183 1
a1183 9
			if ((ptr = strchr(val, '?')) == NULL ||
			    strlen(ptr) < 2) {
				free(val);
				goto next;
			}
			*ptr++ = '\0';
			method = strchr(ptr, ' ');
			if (method != NULL)
				*method++ = '\0';
@


1.23
log
@the relay filter action needs special handling to work correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.22 2007/03/21 00:08:08 reyk Exp $	*/
d1269 1
a1269 3
			case NODE_ACTION_APPEND:
			case NODE_ACTION_CHANGE:
			case NODE_ACTION_EXPECT:
@


1.22
log
@in addition to the host retry option in tables, add support for the
optional connection "retry" to the forward to, service, and nat lookup
options. for example, "nat lookup retry 3" is useful when running
hoststated as a transparent proxy when connecting to unreliable
frontend/backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.21 2007/03/17 22:25:08 reyk Exp $	*/
d866 1
a866 2
		if (fnmatch(pn->value, pk->value, FNM_CASEFOLD) ==
		    FNM_NOMATCH) {
d1263 4
a1266 1
			if (cre->nodes[pn->id]) {
d1268 9
a1276 1
				continue;
@


1.21
log
@close unused relay2pfe privsep sockets correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.20 2007/03/17 22:22:23 reyk Exp $	*/
d1443 1
@


1.20
log
@fix the natlook mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.19 2007/03/13 12:04:52 reyk Exp $	*/
d224 1
a224 1
		close(pipe_pfe2relay[i][1]);
@


1.19
log
@allow to specify the IP_TTL and IP_MINTTL options for the relays to
support the Generalized TTL Security Mechanism (GTSM) according to RFC
3682. this is especially useful with inbound connections and a fixed
distance to the backend servers.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.18 2007/03/07 17:40:32 reyk Exp $	*/
d1479 1
d1579 1
d1585 2
a1586 1
	if (con->out.ss.ss_family == AF_UNSPEC && cnl->in == -1) {
d1637 1
a1637 1
	} else {
@


1.18
log
@- fix the hoststatectl host disable/enable commands to work with relay
layer 7 loadbalancing.
- allow to run relays with tables without depending on services
- show hosts and tables assigned to relays in hoststatectl show commands

ok pyr@@ deraadt@@ with some input from mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.17 2007/03/06 19:26:46 reyk Exp $	*/
d520 4
d532 26
d559 3
a576 10
		    &val, sizeof(val)) == -1)
			goto bad;
	}
	if (proto->tcpflags & TCPFLAG_BUFSIZ) {
		val = proto->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF,
		    &val, sizeof(val)) == -1)
			goto bad;
		val = proto->tcpbufsiz;
		if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
@


1.17
log
@add support for handling simple HTTP cookies (no per-path/domain
cookies yet), for example: cookie hash "JSESSIONID"

tested by some people
ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.16 2007/03/05 11:44:50 reyk Exp $	*/
d1726 1
d1752 18
d1776 2
a1777 1

@


1.16
log
@do not strip the header for expect, hash, and log actions.

since we have a tristate in relay_handle_http(), use nicer return
codes defined to make it better readble (no function change).
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.15 2007/03/02 11:32:40 reyk Exp $	*/
d1023 1
a1023 1
	char			*line, buf[READ_BUF_SIZE], *ptr, *url, *method;
d1128 9
a1136 5
		/* Decode the URL */
		if (pn->flags & PNFLAG_LOOKUP_URL &&
		    cre->dir == RELAY_DIR_REQUEST) {
			url = strdup(pk.value);
			if (url == NULL)
d1138 1
a1138 1
			if ((ptr = strchr(url, '?')) == NULL ||
d1140 1
a1140 1
				free(url);
d1157 46
d1210 1
a1210 1
					free(url);
d1215 1
a1215 1
			free(url);
d1218 1
d1227 1
a1227 1
next:
@


1.15
log
@when the http read callback changes and some data is still left in the
input buffer, we call the new callback to handle the remaining data.
this change makes sure that we only do this after the read callback
was actually changed (read header -> read content, read content ->
read header, read chunks...) to avoid a possible loop which could
happen in some rare cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.14 2007/02/27 13:38:58 reyk Exp $	*/
d801 1
d806 1
a806 1
			return (1);
d826 1
a826 1
			return (1);
d838 1
d852 1
a852 1
			return (1);
d856 1
d860 1
a860 1
			return (1);
d863 1
d866 1
a866 1
		return (1);
d876 1
a876 1
	return (0);
d879 1
a879 1
	return (-1);
d1157 1
a1157 1
				if (ret == 1)
d1159 1
a1159 1
				else if (ret == -1) {
d1169 1
a1169 1
		if (ret == 1)
d1172 1
a1172 1
		if (ret == -1)
@


1.14
log
@in addition to actions on request headers, allow to define relay
actions on response headers (the reply sent by backend HTTP servers).
the default and slightly faster relay streaming mode will be used if
no actions are defined.

for example:
response change "Server" to "OpenBSD-hoststated/4.1"

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.13 2007/02/26 16:10:24 reyk Exp $	*/
d902 2
d998 1
a998 1
	if (EVBUFFER_LENGTH(src))
d1275 1
a1275 1
	if (EVBUFFER_LENGTH(src))
@


1.13
log
@handle strlcpy return values, make lint happy
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.12 2007/02/26 15:41:44 reyk Exp $	*/
d276 2
d292 5
a296 1
	RB_FOREACH(pn, proto_tree, &proto->tree) {
d299 2
d345 5
d613 1
d626 19
d675 8
a682 5
		inrd = relay_read_http;
		if ((con->in.nodes = calloc(proto->nodecount,
		    sizeof(u_int8_t))) == NULL) {
			relay_close(con, "failed to allocate node buffer");
			return;
d1077 3
a1079 1
			if (strcmp("GET", pk.key) == 0)
d1096 2
a1097 1
		    cre->method == HTTP_METHOD_PUT) &&
d1119 1
a1119 1
		if ((pn = RB_FIND(proto_tree, &proto->tree, &pk)) == NULL)
d1123 2
a1124 1
		if (pn->flags & PNFLAG_LOOKUP_URL) {
d1148 1
a1148 1
				    &proto->tree, &pkv)) == NULL)
d1183 1
a1183 1
		RB_FOREACH(pn, proto_tree, &proto->tree) {
d1237 1
d1264 2
a1265 1
		if (proto->lateconnect && cre->dst->bev == NULL &&
d1329 1
d1359 4
@


1.12
log
@better error handling for buffer I/O, fix the log action
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.11 2007/02/26 12:35:43 reyk Exp $	*/
d717 1
a717 1
	strlcpy(buf, val, len);
@


1.11
log
@handle requests with chunked transfer-encoding.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.10 2007/02/26 12:16:12 reyk Exp $	*/
d697 2
a698 1
	relay_bufferevent_write_buffer(cre->dst, src);
d705 3
d721 2
a722 1
			relay_host(&cre->ss, ibuf, sizeof(ibuf));
d736 2
a737 1
			relay_host(&rlay->ss, ibuf, sizeof(ibuf));
d769 1
a769 1
			return (-1);
d775 7
a781 6
		relay_bufferevent_print(cre->dst, pn->key);
		relay_bufferevent_print(cre->dst, ": ");
		relay_bufferevent_print(cre->dst, pk->value);
		relay_bufferevent_print(cre->dst, ", ");
		relay_bufferevent_print(cre->dst, ptr);
		relay_bufferevent_print(cre->dst, "\r\n");
d789 1
a789 1
			return (-1);
d814 1
a814 1
			return (-1);
d821 1
a821 1
			return (-1);
d826 8
a833 1
		return (-1);
d835 1
a835 3
	if (pn->flags & PNFLAG_LOG)
		evbuffer_add_printf(con->log, " [%s: %s]",
		    pn->key, pk->value);
d837 3
d857 2
a858 1
	relay_bufferevent_write_buffer(cre->dst, src);
d870 3
d914 3
a916 2
		relay_bufferevent_print(cre->dst, line);
		relay_bufferevent_print(cre->dst, "\r\n");
d927 2
a928 1
			relay_bufferevent_print(cre->dst, "\r\n");
d937 2
a938 1
		relay_bufferevent_write_chunk(cre->dst, src, size);
d953 2
a954 1
			relay_bufferevent_print(cre->dst, "\r\n\r\n");
d967 3
d982 1
a982 1
	int			 header = 0;
d1018 5
a1022 2
			relay_bufferevent_print(cre->dst, line);
			relay_bufferevent_print(cre->dst, "\r\n");
d1110 2
a1111 1
				if (relay_handle_http(cre, pnv, &pkv, 0) == -1)
d1113 5
d1122 2
a1123 1
		if (relay_handle_http(cre, pn, &pk, header) == -1)
a1124 1

d1126 2
d1131 8
a1138 7
		relay_bufferevent_print(cre->dst, pk.key);
		if (header)
			relay_bufferevent_print(cre->dst, ": ");
		else
			relay_bufferevent_print(cre->dst, " ");
		relay_bufferevent_print(cre->dst, pk.value);
		relay_bufferevent_print(cre->dst, "\r\n");
d1159 9
a1167 4
				relay_bufferevent_print(cre->dst, pn->key);
				relay_bufferevent_print(cre->dst, ": ");
				relay_bufferevent_print(cre->dst, ptr);
				relay_bufferevent_print(cre->dst, "\r\n");
d1215 2
a1216 1
		relay_bufferevent_print(cre->dst, "\r\n");
d1237 3
d1552 6
a1557 4
		relay_host(&con->in.ss, ibuf, sizeof(ibuf));
		relay_host(&con->out.ss, obuf, sizeof(obuf));
		if (EVBUFFER_LENGTH(con->log)) {
			evbuffer_add_printf(con->log, "\r\n");
a1558 1
		}
@


1.10
log
@tweak flushing of unwritten bytes on http mode changes
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.9 2007/02/26 12:11:19 reyk Exp $	*/
d89 1
d108 2
d857 90
d1046 3
d1165 5
d1177 1
d2072 11
@


1.9
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.8 2007/02/26 12:09:21 reyk Exp $	*/
d1086 1
a1086 1
		relay_bufferevent_write_buffer(cre->dst, src);
@


1.8
log
@improve the relay bufferevent handler if one side closed the connection
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.7 2007/02/26 11:59:48 reyk Exp $	*/
d1964 2
a1965 2
relay_bufferevent_write_buffer(struct ctl_relay_event *cre, struct
    evbuffer *buf)
@


1.7
log
@re-use the retry value from table host entries for inbound relay
connections. the relay will retry to connect to the hosts for the
specified number of times. this sounds bad, but is a useful
"workaround" for unreliable backend servers...
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.6 2007/02/26 11:24:26 reyk Exp $	*/
d863 1
a863 1
	int			 done = 0, header = 0;
d876 1
a876 1
	while (!done && (line = evbuffer_readline(src)) != NULL) {
d882 1
a882 1
			done = 1;
d1008 1
a1008 1
	if (done) {
d1075 1
a1097 1
	struct evbuffer *src = EVBUFFER_OUTPUT(bev);
a1103 7
#if 0
	if (error & EVBUFFER_EOF) {
		bufferevent_disable(bev, EV_READ|EV_WRITE);
		relay_close(con, "done");
		return;
	}
#endif
d1110 1
a1110 2
			if (EVBUFFER_LENGTH(dst)) {
				bufferevent_write_buffer(cre->dst->bev, src);
a1111 1
			}
@


1.6
log
@fix small memleaks
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.5 2007/02/25 18:16:16 deraadt Exp $	*/
d1300 1
d1372 1
d1375 8
@


1.5
log
@one example (of two) of tree breaking the "other gcc"
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.4 2007/02/24 15:48:54 reyk Exp $	*/
d949 1
d1412 2
@


1.4
log
@disable SSLv2 and use "HIGH" crypto cipher suites by default.

suggested by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.3 2007/02/24 00:22:32 reyk Exp $	*/
d906 1
a906 1
			*pk.value++;
@


1.3
log
@- allow to specify the SSL cipher suite and the SSL protocols
  (as required by the PCI DSS)
- increase the default listen backlog to 10, allow to modify the
  backlog as a per-protocol tcp option to improve the performance
  on busy systems (to get less connection failures on heavy load)
- close the connection if SSL_accept returned an error
- instead of logging _new_ relay sessions to syslog, log the
  sessions in relay_close() after they have been _finished_.
  this will allow to collect some additional information
- add a new log keyword to log specified header/url entities (useful
  to track "bad guys" using many session ids or multiple user agents)
- some minor fixes, manpage bits, and bump the copyright (by some
  reason, i didn't realize that we already have 2007...).
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.2 2007/02/22 23:07:38 reyk Exp $	*/
d1592 1
a1592 1
	char certfile[PATH_MAX], hbuf[128];
d1622 4
a1625 6
	if (proto->sslciphers != NULL) {
		log_debug("relay_ssl_ctx_create: ciphers '%s'",
		    proto->sslciphers);
		if (!SSL_CTX_set_cipher_list(ctx, proto->sslciphers))
			goto err;
	}
@


1.2
log
@read the exact length for POST requests as specified by the
content-length header.
@
text
@d1 1
a1 1
/*	$OpenBSD: relay.c,v 1.1 2007/02/22 03:32:40 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2006 Reyk Floeter <reyk@@openbsd.org>
d289 12
d315 1
a315 2
			fprintf(stderr, "%sexpect \"%s\" from \"%s\"",
			    pn->header ? "" : "url ",
d319 1
a319 2
			fprintf(stderr, "%sfilter \"%s\" from \"%s\"",
			    pn->header ? "" : "url ",
d323 4
a326 3
			fprintf(stderr, "%shash \"%s\"",
			    pn->header ? "" : "url ",
			    pn->key);
d329 1
a329 3
			fprintf(stderr, "%snone \"%s\"",
			    pn->header ? "" : "url ",
			    pn->key);
d582 1
a582 1
	if (listen(s, 5) == -1)
a599 1
	char			 ibuf[128], obuf[128];
a608 8
	if (env->opts & HOSTSTATED_OPT_LOGUPDATE) {
		relay_host(&con->in.ss, ibuf, sizeof(ibuf));
		relay_host(&con->out.ss, obuf, sizeof(obuf));
		log_info("relay %s, session %d (%d active), %s -> %s:%d",
		    rlay->name, con->id, relay_sessions,
		    ibuf, obuf, ntohs(con->out.port));
	}

d680 1
a680 1
		relay_close(con, "last write, done");
d700 1
a700 1
	relay_close(con, "last read, done");
a756 3
	if (pn->header != header)
		return (0);

d759 1
a759 1
		if (!header || (pn->mark && cre->marked == 0))
d762 3
a764 2
		if (pn->macro && (ptr = relay_expand_http(cre,
		    pn->value, buf, sizeof(buf))) == NULL)
d778 1
a778 1
		if (!header || (pn->mark && cre->marked == 0))
d787 1
a787 1
			if (pn->mark)
d797 1
a797 1
			if (pn->mark)
d803 1
a803 1
		if (pn->mark && !cre->marked)
d809 6
d818 3
a820 1

d850 1
a850 1
	relay_close(con, "last http content read, done");
d874 2
d958 1
a958 1
		if (pn->getvars) {
d973 1
d978 1
a978 1
				    strlen(pkv.value) < 1) {
a979 1
				}
d1017 2
a1018 1
				if (pn->mark && cre->marked == 0)
d1020 3
a1022 2
				if (pn->macro && (ptr = relay_expand_http(cre,
				    pn->value, buf, sizeof(buf))) == NULL)
d1032 1
a1032 1
				if (pn->mark)
d1036 1
a1036 1
				relay_close(con, "incomplete header, done");
d1039 1
a1039 1
				if (pn->mark)
d1043 1
a1043 1
				relay_close(con, "rejecting header, done");
d1075 1
a1075 1
		if (proto->lateconnect && cre->bev == NULL &&
d1088 1
a1088 1
	relay_close(con, "last http read, done");
d1187 7
d1376 1
d1390 1
d1400 13
d1441 3
a1451 6
#ifdef DEBUG
	log_info("relay %s, session %d closed: %s", rlay->name, con->id, msg);
#else
	log_debug("relay %s, session %d closed: %s", rlay->name, con->id, msg);
#endif

d1590 1
d1600 1
a1600 1
	if (rlay->proto->cache < -1) {
d1602 1
a1602 1
	} else if (rlay->proto->cache >= -1) {
d1604 2
a1605 2
		if (rlay->proto->cache >= 0)
			SSL_CTX_sess_set_cache_size(ctx, rlay->proto->cache);
d1608 1
a1608 1
	/* Enable all workarounds */
d1610 18
d1720 7
d1729 1
d1734 8
a1741 2
	DPRINTF("relay_ssl_accept: session %d: connection established",
	    con->id);
d1981 2
a1982 1
	return (strcasecmp(a->key, b->key));
@


1.1
log
@Add layer 7 functionality to hoststated used for layer 7
loadbalancing, SSL acceleration, general-purpose TCP relaying, and
transparent proxying.

see hoststated.conf(5) and my upcoming article on undeadly.org for
details.

ok to commit deraadt@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a932 5
			 */
			cre->toread = strtonum(pk.value, 1, INT_MAX, &errstr);

			/*
			 * \r\n between header and body.
d937 1
a937 1
			cre->toread += 2;
@

