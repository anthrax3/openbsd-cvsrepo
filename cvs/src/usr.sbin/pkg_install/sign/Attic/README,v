head	1.3;
access;
symbols
	OPENBSD_3_5:1.2.0.20
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.18
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.16
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.14
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.12
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.10
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.8
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@# @;


1.3
date	2004.05.28.20.15.48;	author brad;	state dead;
branches;
next	1.2;

1.2
date	99.10.04.21.46.27;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	99.09.27.21.40.03;	author espie;	state Exp;
branches;
next	;


desc
@@


1.3
log
@bye bye old package tools.

ok deraadt@@
@
text
@To sign packages in a transparent way:
gzip files can handle an extra field at the beginning that
stores anything we wish.

So it's just a question to choose a format for the signature, and to
embed it there.

We use the extra field to store signatures.  Each signature consists
of a 6 bytes type marker, a 2 bytes length, followed by the signature
itself.  We can potentially stack signatures: resign a signed archive
by just prepending the new signature to the extra field.

To check the first signature, the checker just needs to extract it, pass it
off to the checking protocol (e.g. PGP), followed by the unsigned archive
(e.g., regenerate the gzip header  without the first signature, then put
the gzip data).

* Signed archives just look like normal .tar.gz files, except for programs
that use the extra field for their own purpose,
* Possibility to grab the files off the net and extract stuff/verify
signatures on the fly (just need to wedge the checker as an intermediate
pipe)
* Pretty simple, small portable code to be able to check signatures
everywhere (the signer itself needs getpass and corresponding functionality)

The scheme should be extensible to any compressed format which allows for
extended headers.


Thanks to Angelos D. Keromytis for pointing out I did not need to
uncompress the archive to sign it, and to other members of the OpenBSD
project for various reasons.

--
	Marc Espie, 1999
	$OpenBSD: README,v 1.2 1999/10/04 21:46:27 espie Exp $
@


1.2
log
@Synch with current development:
* signatures no longer deal with zcat. Instead, we sign the gzip file
itself (stripped of the signature part of the header, of course). Thanks
Angelos.  Niels seems to think passing the header itself to sign is not
a problem, even though no-one cares about checking it ?
* gzip header handling revamped: can write to memory. Will eliminate some
pipes later on. Can stack signatures.
* taken out specific signature schemes (e.g., pgp and sha1).  Code is now
signature scheme independent, mostly, and writes with client data from
memory, e.g., check.c can invoke several checks in parallel without needing
to fork.
* need the full set of popen-like functionalities (keep track of opened
file descriptors to avoid passing them down to children)
* remove simple_check.c, functionality absorbed elsewhere.

To do:
* re-check message output and what to do with unsigned/unchecked/verified
packages,
* check pkg_add implementation and remove extra-pipe in asynchronous
checking,
* control over what to do when several signatures are stacked... Simple
way would be to disable that for now (possibility for release)
* get the code through a linter again.
@
text
@d36 1
a36 1
	$OpenBSD$
@


1.1
log
@Stand-alone package signer.

Requires pgp for now, though the general scheme is generic.
@
text
@d2 1
a2 1
gzip files can handle an EXTRA_FIELD at the beginning that
d8 4
a11 4
We put a specific cookie `S, i, g, P, G, P, length'
at the beginning of the extra-field, so that eventually we can put
more information in that field (like several signatures),
followed by the signature output by PGP.
d13 4
a16 2
The checker just needs to extract the signature, pass it off to PGP,
followed by the uncompressed archive.
d18 2
a19 1
* Signed archives that just look like normal .tar.gz files,
d25 12
@

