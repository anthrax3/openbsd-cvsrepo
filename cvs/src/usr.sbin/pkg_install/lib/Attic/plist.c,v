head	1.18;
access;
symbols
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.18
date	2004.05.28.20.15.48;	author brad;	state dead;
branches;
next	1.17;

1.17
date	2003.08.21.20.24.57;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.01.08.56.01;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.04.17.31.19;	author avsm;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.04.08.56.01;	author avsm;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.07.20.57.24;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.07.20.51.08;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.08.16.45.48;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.02.10.13.40;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.28.22.13.55;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.26.15.28.14;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.05.17.26.47;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.24.00.20.04;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	98.10.13.23.09.54;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	98.09.07.22.30.17;	author marc;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.14.16;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.04.08.43.45;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.04.07.56.14;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.18
log
@bye bye old package tools.

ok deraadt@@
@
text
@/*	$OpenBSD: plist.c,v 1.17 2003/08/21 20:24:57 espie Exp $	*/
#ifndef lint
static const char rcsid[] = "$OpenBSD: plist.c,v 1.17 2003/08/21 20:24:57 espie Exp $";
#endif

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 18 July 1993
 *
 * General packing list routines.
 *
 */

#include "lib.h"
#include <err.h>
#include <md5.h>

/* this struct defines a plist command type */
typedef struct cmd_t {
	char		*c_s;		/* string to recognise */
	pl_ent_t	c_type;		/* type of command */
	int		c_argc;		/* # of arguments */
} cmd_t;

/* commands to recognise */
static cmd_t	cmdv[] = {
	{	"cwd",		PLIST_CWD,		1	},
	{	"src",		PLIST_SRC,		1	},
	{	"cd",		PLIST_CWD,		1	},
	{	"exec",		PLIST_CMD,		1	},
	{	"unexec",	PLIST_UNEXEC,		1	},
	{	"mode",		PLIST_CHMOD,		1	},
	{	"owner",	PLIST_CHOWN,		1	},
	{	"group",	PLIST_CHGRP,		1	},
	{	"comment",	PLIST_COMMENT,		1	},
	{	"ignore",	PLIST_IGNORE,		0	},
	{	"name",		PLIST_NAME,		1	},
	{	"display",	PLIST_DISPLAY,		1	},
	{	"pkgdep",	PLIST_PKGDEP,		1	},
	{	"pkgcfl",	PLIST_PKGCFL,		1	},
	{	"mtree",	PLIST_MTREE,		1	},
	{	"dirrm",	PLIST_DIR_RM,		1	},
	{	"option",	PLIST_OPTION,		1	},
	{	"newdepend",	PLIST_NEWDEP,		1	},
	{	"libdepend",	PLIST_LIBDEP,		1	},
	{	"extra",	PLIST_EXTRA,		1	},
	{	"extraunexec",	PLIST_EXTRAUNEXEC,	1	},
	{	NULL,		FAIL,			0	}
};

static void delete_files(const char *);

/* Add an item to the end of a packing list */
void
add_plist(package_t *p, pl_ent_t type, char *arg)
{
	plist_t *tmp;

	tmp = new_plist_entry();
	tmp->name = copy_string(arg);
	tmp->type = type;
	if (!p->head) {
		p->head = p->tail = tmp;
	} else {
		tmp->prev = p->tail;
		p->tail->next = tmp;
		p->tail = tmp;
	}
}

/* add an item to the start of a packing list */
void
add_plist_top(package_t *p, pl_ent_t type, char *arg)
{
	plist_t *tmp;

	tmp = new_plist_entry();
	tmp->name = copy_string(arg);
	tmp->type = type;
	if (!p->head) {
		p->head = p->tail = tmp;
	} else {
		tmp->next = p->head;
		p->head->prev = tmp;
		p->head = tmp;
	}
}

/* Return the last (most recent) entry in a packing list */
plist_t *
last_plist(package_t *p)
{
	return p->tail;
}

/* Mark all items in a packing list to prevent iteration over them */
void
mark_plist(package_t *pkg)
{
	plist_t	*pp;

	for (pp = pkg->head ; pp ; pp = pp->next) {
		pp->marked = TRUE;
	}
}

/* Find a given item in a packing list and, if so, return it (else NULL) */
plist_t *
find_plist(package_t *pkg, pl_ent_t type)
{
	plist_t	*pp;

	for (pp = pkg->head ; pp && pp->type != type ; pp = pp->next) {
	}
	return pp;
}

/* Look for a specific boolean option argument in the list */
char *
find_plist_option(package_t *pkg, char *name)
{
	plist_t	*p;

	for (p = pkg->head ; p ; p = p->next) {
		if (p->type == PLIST_OPTION && strcmp(p->name, name) == 0) {
			return p->name;
		}
	}
	return (char *) NULL;
}

/*
 * Delete plist item 'type' in the list (if 'name' is non-null, match it
 * too.)  If 'all' is set, delete all items, not just the first occurance.
 */
void
delete_plist(package_t *pkg, Boolean all, pl_ent_t type, char *name)
{
    plist_t *p = pkg->head;

    while (p) {
	plist_t *pnext = p->next;

	if (p->type == type && (!name || !strcmp(name, p->name))) {
	    free(p->name);
	    if (p->prev)
		p->prev->next = pnext;
	    else
		pkg->head = pnext;
	    if (pnext)
		pnext->prev = p->prev;
	    else
		pkg->tail = p->prev;
	    free(p);
	    if (!all)
		return;
	    p = pnext;
	}
	else
	    p = p->next;
    }
}

/* Allocate a new packing list entry */
plist_t *
new_plist_entry(void)
{
	plist_t *ret;

	if ((ret = (plist_t *)malloc(sizeof(plist_t))) == (plist_t *) NULL) {
		err(1, "can't allocate %d bytes", sizeof(plist_t));
	}
	memset(ret, 0, sizeof(plist_t));
	return ret;
}

/* Free an entire packing list */
void
free_plist(package_t *pkg)
{
    plist_t *p = pkg->head;

    while (p) {
	plist_t *p1 = p->next;

	free(p->name);
	free(p);
	p = p1;
    }
    pkg->head = pkg->tail = NULL;
}

/*
 * For an ascii string denoting a plist command, return its code and
 * optionally its argument(s)
 */
int
plist_cmd(char *s, char **arg)
{
	cmd_t	*cmdp;
	char	cmd[FILENAME_MAX + 20];	/* 20 == fudge for max cmd len */
	char	*cp;
	char	*sp;

	(void) strlcpy(cmd, s, sizeof(cmd));
	str_lowercase(cmd);
	for (cp = cmd, sp = s ; *cp ; cp++, sp++) {
		if (isspace(*cp)) {
			for (*cp = '\0'; isspace(*sp) ; sp++) {
			}
			break;
		}
	}
	if (arg) {
		*arg = sp;
	}
	for (cmdp = cmdv ; cmdp->c_s && strcmp(cmdp->c_s, cmd) != 0 ; cmdp++) {
	}
	return cmdp->c_type;
}

/* Read a packing list from a file */
void
read_plist(package_t *pkg, FILE *fp)
{
    char *cp, pline[FILENAME_MAX];
    int cmd;

    while (fgets(pline, FILENAME_MAX, fp)) {
	int len = strlen(pline);

	while (len && isspace(pline[len - 1]))
	    pline[--len] = '\0';
	if (!len)
	    continue;
	cp = pline;
	if (pline[0] == CMD_CHAR) {
	    cmd = plist_cmd(pline + 1, &cp);
	    if (cmd == FAIL) {
		pwarnx("Unrecognised PLIST command `%s'", pline);
		continue;
	    }
	    if (*cp == '\0')
		cp = NULL;
	}
	else
	    cmd = PLIST_FILE;
	add_plist(pkg, cmd, cp);
    }
}

/* Write a packing list to a file, converting commands to ascii equivs */
void
write_plist(package_t *pkg, FILE *fp)
{
	plist_t	*p;
	cmd_t	*cmdp;

	for (p = pkg->head ; p ; p = p->next) {
		if (p->type == PLIST_FILE) {
			/* Fast-track files - these are the most common */
			(void) fprintf(fp, "%s\n", p->name);
			continue;
		}
		for (cmdp = cmdv ; cmdp->c_type != FAIL && cmdp->c_type != p->type ; cmdp++) {
		}
		if (cmdp->c_type == FAIL) {
			pwarnx("Unknown PLIST command type %d (%s)", p->type, p->name);
		} else if (cmdp->c_argc == 0) {
			(void) fprintf(fp, "%c%s\n", CMD_CHAR, cmdp->c_s);
		} else {
			(void) fprintf(fp, "%c%s %s\n", CMD_CHAR, cmdp->c_s,
					(p->name) ? p->name : "");
		}
	}
}

/*
 * Delete the results of a package installation.
 *
 * This is here rather than in the pkg_delete code because pkg_add needs to
 * run it too in cases of failure.
 */
int
delete_package(Boolean ign_err, Boolean nukedirs, Boolean remove_config, 
    Boolean check_md5, package_t *pkg)
{
    plist_t *p;
    char *Where = ".", *last_file = "";
    int fail = SUCCESS;
    char tmp[FILENAME_MAX], *name = NULL;

    for (p = pkg->head; p; p = p->next) {
	switch (p->type)  {
	case PLIST_NAME:
	    name = p->name;
	    break;

	case PLIST_IGNORE:
	    p = p->next;
	    break;

	case PLIST_CWD:
	    Where = p->name;
	    if (Verbose)
		printf("Change working directory to %s\n", Where);
	    break;

	case PLIST_EXTRAUNEXEC:
	    if (!remove_config)
	    	break;
	    /*FALLTHRU*/
	case PLIST_UNEXEC:
	    if (!format_cmd(tmp, sizeof(tmp), p->name, Where, last_file)) {
	    	pwarnx("unexec command `%s' could not expand", p->name);
		fail = FAIL;
	    } else {
		if (Verbose)
		    printf("Execute `%s'\n", tmp);
		if (!Fake && system(tmp)) {
		    pwarnx("unexec command for `%s' failed", tmp);
		    fail = FAIL;
		}
	    }
	    break;

	case PLIST_FILE:
	    last_file = p->name;
	    (void) snprintf(tmp, sizeof(tmp), "%s/%s", Where, p->name);
	    if (isdir(tmp)) {
		pwarnx("attempting to delete directory `%s' as a file\n"
	   "this packing list is incorrect - ignoring delete request", tmp);
	    }
	    else {
		if (check_md5 && p->next && p->next->type == PLIST_COMMENT && !strncmp(p->next->name, "MD5:", 4)) {
		    char *cp, buf[LegibleChecksumLen];

		    if ((cp = MD5File(tmp, buf)) != NULL) {
			/* Mismatch? */
			if (strcmp(cp, p->next->name + 4)) {
			    printf("%s fails original MD5 checksum - %s\n",
				       tmp, Force ? "deleted anyway." : "not deleted.");
			    if (!Force) {
				fail = FAIL;
				continue;
			    }
			}
		    }
		}
		if (Verbose)
		    printf("Delete file %s\n", tmp);
		if (!Fake) {
		    if (delete_hierarchy(tmp, ign_err, nukedirs))
		    fail = FAIL;
		}
	    }
	    break;

	case PLIST_EXTRA:
	    if (!remove_config)
	    	break;
	    if (!p->name)
	    	break;
	    if (p->name[0] == '/')
	    	delete_files(p->name);
	    else {
		(void) snprintf(tmp, sizeof(tmp), "%s/%s", Where, p->name);
		delete_files(tmp);
	    }
	    break;
	case PLIST_DIR_RM:
	    (void) snprintf(tmp, sizeof(tmp), "%s/%s", Where, p->name);
	    if (!isdir(tmp)) {
	    	if (fexists(tmp)) {
			pwarnx("attempting to delete file `%s' as a directory\n"
		"this packing list is incorrect - ignoring delete request", tmp);
		} else {
			pwarnx("attempting to delete non-existent directory `%s'\n"
		"this packing list is incorrect - ignoring delete request", tmp);
		}
	    }
	    else {
		if (Verbose)
		    printf("Delete directory %s\n", tmp);
		if (!Fake && delete_hierarchy(tmp, ign_err, FALSE)) {
		    pwarnx("unable to completely remove directory '%s'", tmp);
		    fail = FAIL;
		}
	    }
	    last_file = p->name;
	    break;
	default:
	    break;
	}
    }
    return fail;
}

#ifdef DEBUG
#define RMDIR(dir) vsystem("%s %s", RMDIR_CMD, dir)
#define REMOVE(dir,ie) vsystem("%s %s%s", REMOVE_CMD, (ie ? "-f " : ""), dir)
#else
#define RMDIR rmdir
#define	REMOVE(file,ie) (remove(file) && !(ie))
#endif

/* Selectively delete a hierarchy */
int
delete_hierarchy(char *dir, Boolean ign_err, Boolean nukedirs)
{
    char *cp1, *cp2;

    cp1 = cp2 = dir;
    if (!fexists(dir)) {
	if (!ign_err)
	    pwarnx("%s `%s' doesn't really exist",
		isdir(dir) ? "directory" : "file", dir);
	return !ign_err;
    }
    else if (nukedirs) {
	if (vsystem("%s -r%s %s", REMOVE_CMD, (ign_err ? "f" : ""), dir))
	    return 1;
    }
    else if (isdir(dir)) {
	if (RMDIR(dir) && !ign_err)
	    return 1;
    }
    else {
	if (REMOVE(dir, ign_err))
	    return 1;
    }

    if (!nukedirs)
	return 0;
    while (cp2) {
	if ((cp2 = strrchr(cp1, '/')) != NULL)
	    *cp2 = '\0';
	if (!isemptydir(dir))
	    return 0;
	if (RMDIR(dir) && !ign_err) {
	    if (!fexists(dir))
		pwarnx("directory `%s' doesn't really exist", dir);
	    else
		return 1;
	}
	/* back up the pathname one component */
	if (cp2) {
	    cp1 = dir;
	}
    }
    return 0;
}

static void
delete_files(const char *fname)
{
	size_t len;
	Boolean b;

	len = strlen(fname);
	if (len == 0) {
		pwarnx("empty extra file");
		return;
	}
	/* don't warn if stuff does not exist */
	if (!fexists(fname))
		return;

	b = isdir(fname);
	if (fname[len-1] == '/') {
		if (b) {
			if (rmdir(fname) == -1)
				pwarn("problem removing directory %s", 
				    fname);
		} else {
			pwarnx("extra directory %s is not a directory", 
			    fname);
		}
	} else {
		if (b) {
			pwarnx("extra file %s is a directory", fname);
		} else {
			if (unlink(fname) == -1)
				pwarn("problem removing %s", fname);
		}
	}
}
@


1.17
log
@New keywords: @@extra and @@extraunexec.
Used to record extra files (configuration) and action, that will only
be taken with pkg_delete -c.
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.16 2003/08/01 08:56:01 espie Exp $	*/
d3 1
a3 1
static const char rcsid[] = "$OpenBSD: plist.c,v 1.16 2003/08/01 08:56:01 espie Exp $";
@


1.16
log
@Add -q flag to pkg_delete: don't check md5 before removing.
Useful for bulk-package builders who want to clean /usr/local quickly.
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.15 2003/07/04 17:31:19 avsm Exp $	*/
d3 1
a3 1
static const char rcsid[] = "$OpenBSD: plist.c,v 1.15 2003/07/04 17:31:19 avsm Exp $";
d58 2
d63 2
d297 1
a297 1
delete_package(Boolean ign_err, Boolean nukedirs,
d321 4
d371 12
d464 35
@


1.15
log
@'static const char rcsid[]' to make it -Wall clean
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.14 2003/04/04 08:56:01 avsm Exp $	*/
d3 1
a3 1
static const char rcsid[] = "$OpenBSD: plist.c,v 1.14 2003/04/04 08:56:01 avsm Exp $";
d293 2
a294 1
delete_package(Boolean ign_err, Boolean nukedirs, package_t *pkg)
d339 1
a339 1
		if (p->next && p->next->type == PLIST_COMMENT && !strncmp(p->next->name, "MD5:", 4)) {
@


1.14
log
@some more strcpy/strcat -> strlcpy/strlcat conversions
ok and tweaks by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.13 2001/11/07 20:57:24 espie Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.13 2001/11/07 20:57:24 espie Exp $";
@


1.13
log
@Say goodbye to @@ignore_inst, we don't use it, and it doesn't even work in
any sane way...
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.12 2001/11/07 20:51:08 espie Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.12 2001/11/07 20:51:08 espie Exp $";
d213 1
a213 1
	(void) strcpy(cmd, s);
@


1.12
log
@Recognize libdepend keyword.
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.11 2001/04/08 16:45:48 espie Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.11 2001/04/08 16:45:48 espie Exp $";
a48 1
	{	"ignore_inst",	PLIST_IGNORE_INST,	0	},
@


1.11
log
@Better error messages: pwarnx function, which works like pwarn, except
it shows a current package name along with the program name, e.g.,
pkg_add(foo-3.0): some error occurred.

A few messages now bear redundant pkgnames, which is much better than
doing pkg_add * and being informed that something went slightly wrong
somewhere...
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.10 2001/04/02 10:13:40 espie Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.10 2001/04/02 10:13:40 espie Exp $";
d58 1
@


1.10
log
@Handle for newdepend.
- recognize the keyword,
- pass all packing lists to `pkg dependencies solve' for rewriting.

pkg dependencies solve is a no-op in the absence of newdepends.

With newdepends, it rewrites @@newdepends -> @@pkgdep on the fly, depending
on what's actually installed on the machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.9 2000/04/28 22:13:55 espie Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.9 2000/04/28 22:13:55 espie Exp $";
d248 1
a248 1
		warnx("Unrecognised PLIST command `%s'", pline);
d276 1
a276 1
			warnx("Unknown PLIST command type %d (%s)", p->type, p->name);
d318 1
a318 1
	    	warnx("unexec command `%s' could not expand", p->name);
d324 1
a324 1
		    warnx("unexec command for `%s' failed", tmp);
d334 1
a334 1
		warnx("attempting to delete directory `%s' as a file\n"
d366 1
a366 1
			warnx("attempting to delete file `%s' as a directory\n"
d369 1
a369 1
			warnx("attempting to delete non-existent directory `%s'\n"
d377 1
a377 1
		    warnx("unable to completely remove directory '%s'", tmp);
d407 1
a407 1
	    warnx("%s `%s' doesn't really exist",
d433 1
a433 1
		warnx("directory `%s' doesn't really exist", dir);
@


1.9
log
@Remove last remnants of @@option preserve and @@option extract-in-place
We don't use these, and they are a bad idea anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.8 2000/04/26 15:28:14 espie Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.8 2000/04/26 15:28:14 espie Exp $";
d57 1
@


1.8
log
@Consistency in error reports.
*always* tell them MD5Sum fails, because later, pkg_delete will
complain about a bad package anyway, and the poor user won't be
able to figure out what went wrong, and it's obviously too late
since the package is gone already...
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.7 2000/04/05 17:26:47 espie Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.7 2000/04/05 17:26:47 espie Exp $";
a296 1
    Boolean preserve;
a298 1
    preserve = find_plist_option(pkg, "preserve") ? TRUE : FALSE;
a356 11
		    if (preserve && name) {
			char tmp2[FILENAME_MAX];
			    
			if (make_preserve_name(tmp2, FILENAME_MAX, name, tmp)) {
			    if (fexists(tmp2)) {
				if (rename(tmp2, tmp))
				   warn("preserve: unable to restore %s as %s",
					tmp2, tmp);
			    }
			}
		    }
@


1.7
log
@Fix bogus error message. Not a dir can mean *nothing* at all.
Reviewed by aaron@@... ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.6 2000/03/24 00:20:04 espie Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.6 2000/03/24 00:20:04 espie Exp $";
d345 1
a345 2
			    if (Verbose)
				printf("%s fails original MD5 checksum - %s\n",
@


1.6
log
@Handle expansion sequences in @@exec better (let the expander decide whether
it needs a file name instead of assuming we always need one).

Sent to *quite a few* people, comments by drahn@@... guys, wake up !!!
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.5 1998/10/13 23:09:54 marc Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.5 1998/10/13 23:09:54 marc Exp $";
d378 7
a384 2
		warnx("attempting to delete file `%s' as a directory\n"
	"this packing list is incorrect - ignoring delete request", tmp);
@


1.5
log
@Sync with recent NetBSD changes:
- use snprintf in place of sprintf
- code cleanup
- Package -> package_t, PackingList -> plist_t
Also: remove files that haven't been linked in a while
Pass -q to mtree so it is quiet in the presence of symlinks
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.4 1998/09/07 22:30:17 marc Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.4 1998/09/07 22:30:17 marc Exp $";
d318 2
a319 5
	    format_cmd(tmp, sizeof(tmp), p->name, Where, last_file);
	    if (Verbose)
		printf("Execute `%s'\n", tmp);
	    if (!Fake && system(tmp)) {
		warnx("unexec command for `%s' failed", tmp);
d321 7
@


1.4
log
@updated pkg_* tools.  Merged in many changes/improvements from NetBSD.
New features include md5 hash so pkg_delete won't remove files that have
changed and the ability to define conflicting packages, e.g. you can't
install both mh and nmh.  The ports tree will have to be updated to take
advantage of this.

Let me know of any problems, real or imagined :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.3 1997/01/17 07:14:16 millert Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.3 1997/01/17 07:14:16 millert Exp $";
d30 31
a60 1
/* Add an item to a packing list */
d62 1
a62 1
add_plist(Package *p, plist_t type, char *arg)
d64 1
a64 1
    PackingList tmp;
d66 10
a75 11
    tmp = new_plist_entry();
    tmp->name = copy_string(arg);
    tmp->type = type;

    if (!p->head)
	p->head = p->tail = tmp;
    else {
	tmp->prev = p->tail;
	p->tail->next = tmp;
	p->tail = tmp;
    }
d78 1
d80 1
a80 1
add_plist_top(Package *p, plist_t type, char *arg)
d82 1
a82 1
    PackingList tmp;
d84 10
a93 11
    tmp = new_plist_entry();
    tmp->name = copy_string(arg);
    tmp->type = type;

    if (!p->head)
	p->head = p->tail = tmp;
    else {
	tmp->next = p->head;
	p->head->prev = tmp;
	p->head = tmp;
    }
d97 2
a98 2
PackingList
last_plist(Package *p)
d100 1
a100 1
    return p->tail;
d105 1
a105 1
mark_plist(Package *pkg)
d107 1
a107 1
    PackingList p = pkg->head;
d109 3
a111 4
    while (p) {
	p->marked = TRUE;
	p = p->next;
    }
d115 2
a116 2
PackingList
find_plist(Package *pkg, plist_t type)
d118 1
a118 1
    PackingList p = pkg->head;
d120 3
a122 6
    while (p) {
	if (p->type == type)
	    return p;
	p = p->next;
    }
    return NULL;
d127 1
a127 1
find_plist_option(Package *pkg, char *name)
d129 1
a129 1
    PackingList p = pkg->head;
d131 6
a136 6
    while (p) {
	if (p->type == PLIST_OPTION && !strcmp(p->name, name))
	    return p->name;
	p = p->next;
    }
    return NULL;
d144 1
a144 1
delete_plist(Package *pkg, Boolean all, plist_t type, char *name)
d146 1
a146 1
    PackingList p = pkg->head;
d149 1
a149 1
	PackingList pnext = p->next;
d172 1
a172 1
PackingList
d175 1
a175 1
    PackingList ret;
d177 5
a181 3
    ret = (PackingList)malloc(sizeof(struct _plist));
    memset(ret, 0, sizeof(struct _plist));
    return ret;
d186 1
a186 1
free_plist(Package *pkg)
d188 1
a188 1
    PackingList p = pkg->head;
d191 1
a191 1
	PackingList p1 = p->next;
d207 18
a224 13
    char cmd[FILENAME_MAX + 20];	/* 20 == fudge for max cmd len */
    char *cp, *sp;

    strcpy(cmd, s);
    str_lowercase(cmd);
    cp = cmd;
    sp = s;
    while (*cp) {
	if (isspace(*cp)) {
	    *cp = '\0';
	    while (isspace(*sp)) /* Never sure if macro, increment later */
		++sp;
	    break;
d226 1
a226 42
	++cp, ++sp;
    }
    if (arg)
	*arg = sp;
    if (!strcmp(cmd, "cwd"))
	return PLIST_CWD;
    else if (!strcmp(cmd, "srcdir"))
	return PLIST_SRC;
    else if (!strcmp(cmd, "cd"))
	return PLIST_CWD;
    else if (!strcmp(cmd, "exec"))
	return PLIST_CMD;
    else if (!strcmp(cmd, "unexec"))
	return PLIST_UNEXEC;
    else if (!strcmp(cmd, "mode"))
	return PLIST_CHMOD;
    else if (!strcmp(cmd, "owner"))
	return PLIST_CHOWN;
    else if (!strcmp(cmd, "group"))
	return PLIST_CHGRP;
    else if (!strcmp(cmd, "comment"))
	return PLIST_COMMENT;
    else if (!strcmp(cmd, "ignore"))
	return PLIST_IGNORE;
    else if (!strcmp(cmd, "ignore_inst"))
	return PLIST_IGNORE_INST;
    else if (!strcmp(cmd, "name"))
	return PLIST_NAME;
    else if (!strcmp(cmd, "display"))
	return PLIST_DISPLAY;
    else if (!strcmp(cmd, "pkgdep"))
	return PLIST_PKGDEP;
    else if (!strcmp(cmd, "pkgcfl"))
	return PLIST_PKGCFL;
    else if (!strcmp(cmd, "mtree"))
	return PLIST_MTREE;
    else if (!strcmp(cmd, "dirrm"))
	return PLIST_DIR_RM;
    else if (!strcmp(cmd, "option"))
	return PLIST_OPTION;
    else
	return FAIL;
d231 1
a231 1
read_plist(Package *pkg, FILE *fp)
d261 1
a261 1
write_plist(Package *pkg, FILE *fp)
d263 2
a264 1
    PackingList plist = pkg->head;
d266 16
a281 75
    while (plist) {
	switch(plist->type) {
	case PLIST_FILE:
	    fprintf(fp, "%s\n", plist->name);
	    break;

	case PLIST_CWD:
	    fprintf(fp, "%ccwd %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_SRC:
	    fprintf(fp, "%csrcdir %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_CMD:
	    fprintf(fp, "%cexec %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_UNEXEC:
	    fprintf(fp, "%cunexec %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_CHMOD:
	    fprintf(fp, "%cmode %s\n", CMD_CHAR, plist->name ? plist->name : "");
	    break;

	case PLIST_CHOWN:
	    fprintf(fp, "%cowner %s\n", CMD_CHAR, plist->name ? plist->name : "");
	    break;

	case PLIST_CHGRP:
	    fprintf(fp, "%cgroup %s\n", CMD_CHAR, plist->name ? plist->name : "");
	    break;

	case PLIST_COMMENT:
	    fprintf(fp, "%ccomment %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_IGNORE:
	case PLIST_IGNORE_INST:		/* a one-time non-ignored file */
	    fprintf(fp, "%cignore\n", CMD_CHAR);
	    break;

	case PLIST_NAME:
	    fprintf(fp, "%cname %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_DISPLAY:
	    fprintf(fp, "%cdisplay %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_PKGDEP:
	    fprintf(fp, "%cpkgdep %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_PKGCFL:
	    fprintf(fp, "%cpkgcfl %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_MTREE:
	    fprintf(fp, "%cmtree %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_DIR_RM:
	    fprintf(fp, "%cdirrm %s\n", CMD_CHAR, plist->name);
	    break;

	case PLIST_OPTION:
	    fprintf(fp, "%coption %s\n", CMD_CHAR, plist->name);
	    break;

	default:
	    cleanup(0);
	    errx(2, "unknown command type %d (%s)", plist->type, plist->name);
	    break;
a282 2
	plist = plist->next;
    }
d292 1
a292 1
delete_package(Boolean ign_err, Boolean nukedirs, Package *pkg)
d294 1
a294 1
    PackingList p;
d296 1
a296 1
    Boolean fail = SUCCESS;
d318 1
a318 1
	    format_cmd(tmp, p->name, Where, last_file);
d329 1
a329 1
	    sprintf(tmp, "%s/%s", Where, p->name);
d336 1
a336 1
		    char *cp, buf[33];
d372 1
a372 1
	    sprintf(tmp, "%s/%s", Where, p->name);
@


1.3
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.2 1996/06/04 08:43:45 niklas Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.2 1996/06/04 08:43:45 niklas Exp $";
d27 2
d153 1
a153 1
    bzero(ret, sizeof(struct _plist));
d226 2
d246 1
a246 1
	int len = strlen(pline) - 1;
d248 3
a250 3
	while (isspace(pline[len]))
	    pline[len--] = '\0';
	if (len <= 0)
d255 4
a258 2
	    if (cmd == FAIL)
		barf("Bad command '%s'", pline);
d329 4
d346 2
a347 1
	    barf("Unknown command type %d (%s)\n", plist->type, plist->name);
d363 1
a363 1
    PackingList p = pkg->head;
d366 13
d380 1
a380 4
    if (!p)
	return FAIL;
    while (p) {
	if (p->type == PLIST_CWD) {
d384 1
a384 3
	}
	else if (p->type == PLIST_UNEXEC) {
	    char cmd[FILENAME_MAX];
d386 2
a387 1
	    format_cmd(cmd, p->name, Where, last_file);
d389 3
a391 3
		printf("Execute `%s'\n", cmd);
	    if (!Fake && system(cmd)) {
		whinge("unexec command for `%s' failed.", cmd);
d394 1
a394 5
	}
	else if (p->type == PLIST_IGNORE)
	    p = p->next;
	else if (p->type == PLIST_FILE || p->type == PLIST_DIR_RM) {
	    char full_name[FILENAME_MAX];
d396 6
a401 4
	    sprintf(full_name, "%s/%s", Where, p->name);
	    if (isdir(full_name) && p->type == PLIST_FILE) {
		warn("Attempting to delete directory `%s' as a file\n"
		     "This packing list is incorrect - ignoring delete request.\n", full_name);
d404 16
d421 18
a438 1
		    printf("Delete %s %s\n", !isdir(full_name) ? "file" : " directory", full_name);
d440 11
a450 2
		if (!Fake && delete_hierarchy(full_name, ign_err, p->type == PLIST_DIR_RM ? FALSE : nukedirs)) {
		    whinge("Unable to completely remove file '%s'", full_name);
d455 3
a458 1
	p = p->next;
d480 5
a484 2
	    whinge("%s `%s' doesn't really exist.", isdir(dir) ? "Directory" : "File", dir);
    } else if (nukedirs) {
d487 2
a488 1
    } else if (isdir(dir)) {
d491 2
a492 1
    } else {
d504 1
a504 1
	if (RMDIR(dir) && !ign_err)
d506 1
a506 1
		whinge("Directory `%s' doesn't really exist.", dir);
d509 1
@


1.2
log
@Oops, screwed up the $OpenBSD$ IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: plist.c,v 1.1 1996/06/04 07:56:14 niklas Exp $	*/
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.1 1996/06/04 07:56:14 niklas Exp $";
d433 1
a433 1
	if ((cp2 = rindex(cp1, '/')) != NULL)
@


1.1
log
@add package tools from FreeBSD
@
text
@d1 1
a1 1
#	$OpenBSD$
d3 1
a3 1
static const char *rcsid = "$OpenBSD: plist.c,v 1.15 1995/11/12 04:55:40 jkh Exp $";
@
