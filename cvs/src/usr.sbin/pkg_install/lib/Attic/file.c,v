head	1.27;
access;
symbols
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.15.0.8
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.6
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.4
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.27
date	2004.05.28.20.15.48;	author brad;	state dead;
branches;
next	1.26;

1.26
date	2003.08.21.20.24.57;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.06.20.46.36;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.06.20.45.47;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.30.17.03.55;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.04.17.31.19;	author avsm;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.04.17.23.16;	author avsm;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.01.15.53.43;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.12.22.03.22;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.25.23.26.17;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.19.10.46.16;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.04.08.56.01;	author avsm;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.09.07.05.03;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.08.16.45.47;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.11.13.22.31;	author wilfried;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.12.06.06.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.28.22.13.55;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.24.00.20.04;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	99.10.09.20.35.46;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	99.09.20.16.54.44;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	98.10.13.23.09.52;	author marc;	state Exp;
branches;
next	1.6;

1.6
date	98.09.07.22.30.16;	author marc;	state Exp;
branches;
next	1.5;

1.5
date	98.04.07.07.11.33;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.17.07.14.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.29.12.19.08;	author graichen;	state Exp;
branches;
next	1.2;

1.2
date	96.06.04.08.43.42;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.04.07.56.11;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.27
log
@bye bye old package tools.

ok deraadt@@
@
text
@/*	$OpenBSD: file.c,v 1.26 2003/08/21 20:24:57 espie Exp $	*/

#ifndef lint
static const char rcsid[] = "$OpenBSD: file.c,v 1.26 2003/08/21 20:24:57 espie Exp $";
#endif

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 18 July 1993
 *
 * Miscellaneous file access utilities.
 *
 */

#include "lib.h"

#include <sys/wait.h>

#include <assert.h>
#include <err.h>
#include <netdb.h>
#include <pwd.h>
#include <time.h>

/* This fixes errant package names so they end up in .tgz.
   XXX returns static storage, so beware ! Consume the result
	before reusing the function.
 */
#define TGZ	".tgz"
char *
ensure_tgz(char *name)
{
	static char buffer[FILENAME_MAX];
	size_t len;

	len = strlen(name);
	if ( (strcmp (name, "-") == 0 ) 
	     || (len >= strlen(TGZ) && strcmp(name+len-strlen(TGZ), TGZ) == 0)
	     || (len >= strlen(".tar.gz") &&  
		 strcmp(name+len-strlen(".tar.gz"), ".tar.gz") == 0)
	     || (len >= strlen(".tar") &&  
		 strcmp(name+len-strlen(".tar"), ".tar") == 0)) 
	  return name;
	else {
		snprintf(buffer, sizeof(buffer), "%s%s", name, TGZ);
		return buffer;
	}
}

/* This is as ftpGetURL from FreeBSD's ftpio.c, except that it uses
 * OpenBSD's ftp command to do all FTP.
 */
static FILE *
ftpGetURL(char *url, int *retcode)
{
	FILE *ftp;
	pid_t pid_ftp;
	int p[2];

	*retcode=0;

	if (pipe(p) < 0) {
		*retcode = 1;
		return NULL;
	}

	pid_ftp = fork();
	if (pid_ftp < 0) {
		*retcode = 1;
		return NULL;
	}
	if (pid_ftp == 0) {
		/* child */
		dup2(p[1],1);
		close(p[1]);

		fprintf(stderr, ">>> ftp -o - %s\n",url); 
		execl("/usr/bin/ftp","ftp","-V","-o","-",url,(char *)NULL);
		exit(1);
	} else {
		/* parent */
		ftp = fdopen(p[0],"r");

		close(p[1]);

		if (ftp == (FILE *) NULL) {
			*retcode = 1;
			return NULL;
		}
	}
	return ftp;
}

/* Quick check to see if a file exists */
Boolean
fexists(const char *fname)
{
    struct stat dummy;
    if (!lstat(fname, &dummy))
	return TRUE;
    return FALSE;
}

/* Quick check to see if something is a directory */
Boolean
isdir(const char *fname)
{
    struct stat sb;

    if (lstat(fname, &sb) != FAIL && S_ISDIR(sb.st_mode))
	return TRUE;
    else
	return FALSE;
}

/* Check if something is a link to a directory */
Boolean
islinktodir(const char *fname)
{
    struct stat sb;

    if (lstat(fname, &sb) != FAIL && S_ISLNK(sb.st_mode))
        if (stat(fname, &sb) != FAIL && S_ISDIR(sb.st_mode))
	    return TRUE; /* link to dir! */
        else
	    return FALSE; /* link to non-dir */
    else
        return FALSE;  /* non-link */
}

/* Check to see if file is a dir, and is empty */
Boolean
isemptydir(const char *fname)
{
    if (isdir(fname) || islinktodir(fname)) {
	DIR *dirp;
	struct dirent *dp;

	dirp = opendir(fname);
	if (!dirp)
	    return FALSE;	/* no perms, leave it alone */
	for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
	    if (strcmp(dp->d_name, ".") && strcmp(dp->d_name, "..")) {
		closedir(dirp);
		return FALSE;
	    }
	}
	(void)closedir(dirp);
	return TRUE;
    }
    return FALSE;
}

Boolean
isfile(const char *fname)
{
    struct stat sb;
    if (stat(fname, &sb) != FAIL && S_ISREG(sb.st_mode))
	return TRUE;
    return FALSE;
}

/* Check to see if file is a file and is empty. If nonexistent or not
   a file, say "it's empty", otherwise return TRUE if zero sized. */
Boolean
isemptyfile(const char *fname)
{
    struct stat sb;
    if (stat(fname, &sb) != FAIL && S_ISREG(sb.st_mode)) {
	if (sb.st_size != 0)
	    return FALSE;
    }
    return TRUE;
}

/* Returns TRUE if file is a URL specification */
Boolean
isURL(const char *fname)
{
    /*
     * Hardcode url types... not perfect, but working.
     */
    if (!fname)
	return FALSE;
    while (isspace(*fname))
	++fname;
    if (!strncmp(fname, "ftp://", 6))
	return TRUE;
    if (!strncmp(fname, "http://", 7))
	return TRUE;
    return FALSE;
}

/* Returns the host part of a URL */
char *
fileURLHost(char *fname, char *where, int max)
{
    char *ret;

    while (isspace(*fname))
	++fname;
    /* Don't ever call this on a bad URL! */
    fname = strchr(fname, ':');
    if (fname)
    	fname+=3;
    else
    	return NULL;
    /* Do we have a place to stick our work? */
    if ((ret = where) != NULL) {
	while (*fname && *fname != '/' && max--)
	    *where++ = *fname++;
	*where = '\0';
	return ret;
    }
    /* If not, they must really want us to stomp the original string */
    ret = fname;
    while (*fname && *fname != '/')
	++fname;
    *fname = '\0';
    return ret;
}

/* Returns the filename part of a URL */
char *
fileURLFilename(char *fname, char *where, int max)
{
    char *ret;

    while (isspace(*fname))
	++fname;
    /* Don't ever call this on a bad URL! */
    fname = strchr(fname, ':');
    if (fname)
    	fname+=3;
    else
    	return NULL;
    /* Do we have a place to stick our work? */
    if ((ret = where) != NULL) {
	while (*fname && *fname != '/')
	    ++fname;
	if (*fname == '/') {
	    while (*fname && max--)
		*where++ = *fname++;
	}
	*where = '\0';
	return ret;
    }
    /* If not, they must really want us to stomp the original string */
    while (*fname && *fname != '/')
	++fname;
    return fname;
}

/*
 * Try and fetch a file by URL, returning the directory name for where
 * it's unpacked, if successful.
 */
char *
fileGetURL(char *base, char *spec)
{
    char host[MAXHOSTNAMELEN], file[FILENAME_MAX];
    char *cp, *rp;
    char fname[FILENAME_MAX];
    char pen[FILENAME_MAX];
    FILE *ftp;
    pid_t tpid;
    int i, status;
    char *hint;

    rp = NULL;
    /* Special tip that sysinstall left for us */
    hint = getenv("PKG_ADD_BASE");
    if (!isURL(spec)) {
	if (!base && !hint)
	    return NULL;
	/* We've been given an existing URL (that's known-good) and now we need
	   to construct a composite one out of that and the basename we were
	   handed as a dependency. */
	if (base) {
	    strlcpy(fname, base, sizeof(fname));
	    /* OpenBSD packages are currently stored in a flat space, so
	       we don't yet need to backup the category and switch to all.
	     */
	    cp = strrchr(fname, '/');
	    if (cp) {
		*(cp + 1) = '\0';
		strlcat(fname, ensure_tgz(spec), sizeof(fname));
	    }
	    else
		return NULL;
	}
	else {
	    /* Otherwise, we've been given an environment variable hinting at the right location from sysinstall */
	    snprintf(fname, sizeof(fname), "%s%s", hint, spec);
	}
    }
    else
	strlcpy(fname, spec, sizeof(fname));
    cp = fileURLHost(fname, host, sizeof(host));
    if (!*cp) {
	pwarnx("URL `%s' has bad host part!", fname);
	return NULL;
    }

    cp = fileURLFilename(fname, file, sizeof(fname));
    if (!*cp) {
	pwarnx("URL `%s' has bad filename part!", fname);
	return NULL;
    }

    if (Verbose)
	printf("Trying to fetch %s.\n", fname);
    ftp = ftpGetURL(fname, &status);
    if (ftp) {
	pen[0] = '\0';
	if ((rp = make_playpen(pen, sizeof(pen), 0)) != NULL) {
            rp=strdup(pen); /* be safe for nested calls */
	    if (Verbose)
		printf("Extracting from FTP connection into %s\n", pen);
	    tpid = fork();
	    if (!tpid) {
		dup2(fileno(ftp), 0);
		i = execl("/bin/tar", "tar", Verbose ? "-xpzvf" : "-xpzf", "-", (char *)NULL);
		exit(i);
	    }
	    else {
		int pstat;

		fclose(ftp);
		tpid = waitpid(tpid, &pstat, 0);
		if (Verbose)
		    printf("tar command returns %d status\n", WEXITSTATUS(pstat));
	    }
	}
	else
	    printf("Error: Unable to construct a new playpen for FTP!\n");
	fclose(ftp);
    }
    else
	printf("Error: FTP Unable to get %s: %s\n",
	       fname,
	       status ? "Error while performing FTP" :
	       hstrerror(h_errno));
    return rp;
}

char *
fileFindByPath(char *base, char *fname)
{
	static char tmp[FILENAME_MAX];
	char *cp;

	if (ispkgpattern(fname)) {
		if ((cp=findbestmatchingname(".",fname)) != NULL) {
			strlcpy(tmp, cp, sizeof(tmp));
			free(cp);
			return tmp;
		}
	} else {
		strlcpy(tmp, ensure_tgz(fname), sizeof(tmp));
		if (fexists(tmp) && isfile(tmp)) {
			return tmp;
		}
	}
    
	if (base) {
		strlcpy(tmp, base, sizeof(tmp));

		cp = strrchr(tmp, '/');
		if (cp) {
			*(cp + 1) = '\0';
			strlcat(tmp, ensure_tgz(fname), sizeof(tmp));
			if (ispkgpattern(tmp)) {
				cp=findbestmatchingname(dirname_of(tmp),
							basename_of(tmp));
				if (cp) {
					char *s;
					s=strrchr(tmp,'/');
					assert(s != NULL);
					strlcpy(s+1, cp,
						tmp + sizeof(tmp) - (s+1));
					free(cp);
					return tmp;
				}
			} else {
				if (fexists(tmp)) {
					return tmp;
				}
			}
		}
	}

	cp = getenv("PKG_PATH");
	/* Check for ftp://... paths */
	if (isURL(cp)) {
		snprintf(tmp, sizeof(tmp), "%s/%s", cp, ensure_tgz(fname));
		return tmp;
	}
	while (cp) {
		char *cp2 = strsep(&cp, ":");

		snprintf(tmp, sizeof(tmp), "%s/%s", cp2, ensure_tgz(fname));
		if (ispkgpattern(tmp)) {
			char *s;
			s = findbestmatchingname(dirname_of(tmp),
						 basename_of(tmp));
			if (s){
				char *t;
				t=strrchr(tmp, '/');
				strlcpy(t+1, s, tmp + sizeof(tmp) - (t+1));
				free(s);
				return tmp;
			}
		} else {
			if (fexists(tmp) && isfile(tmp)) {
				return tmp;
			}
		}
	}
    
	return NULL;
}

char *
fileGetContents(char *fname)
{
    char *contents;
    struct stat sb;
    int fd;

    if (stat(fname, &sb) == FAIL) {
	cleanup(0);
	errx(2, "can't stat '%s'", fname);
    }

    contents = (char *)malloc((size_t)(sb.st_size) + 1);
    fd = open(fname, O_RDONLY, 0);
    if (fd == FAIL) {
	cleanup(0);
	errx(2, "unable to open '%s' for reading", fname);
    }
    if (read(fd, contents, (size_t) sb.st_size) != (size_t) sb.st_size) {
	cleanup(0);
	errx(2, "short read on '%s' - did not get %qd bytes",
			fname, (long long)sb.st_size);
    }
    close(fd);
    contents[(size_t)sb.st_size] = '\0';
    return contents;
}

/* Takes a filename and package name, returning (in "try") the canonical "preserve"
 * name for it.
 */
Boolean
make_preserve_name(char *try, size_t max, char *name, char *file)
{
    char *p;
    int i;

    i = strlcpy(try, file, max);
    if (i == 0 || i >= max)
	return FALSE;

    /* Catch trailing slash early */
    i--;
    if (try[i] == '/')
	try[i] = '\0';

    p = strrchr(try, '/');
    if (p == NULL)
	p = try;
    else
	p++;

    i = p - try;
    if (snprintf(p, max - i, ".%s.%s.backup", file + i, name) >= (max - i))
	return FALSE;

    return TRUE;
}

/* Write the contents of "str" to a file */
void
write_file(char *name, char *str)
{
	FILE	*fp;
	size_t	len;

	if ((fp = fopen(name, "w")) == (FILE *) NULL) {
		cleanup(0);
		errx(2, "cannot fopen '%s' for writing", name);
	}
	len = strlen(str);
	if (fwrite(str, 1, len, fp) != len) {
		cleanup(0);
		errx(2, "short fwrite on '%s', tried to write %d bytes",
			name, len);
	}
	if (fclose(fp)) {
		cleanup(0);
		errx(2, "failure to fclose '%s'", name);
	}
}

void
copy_file(char *dir, char *fname, char *to)
{
    char cmd[FILENAME_MAX];

    if (fname[0] == '/')
	snprintf(cmd, sizeof(cmd), "cp -p -r %s %s", fname, to);
    else
	snprintf(cmd, sizeof(cmd), "cp -p -r %s/%s %s", dir, fname, to);
    if (vsystem("%s", cmd)) {
	cleanup(0);
	errx(2, "could not perform '%s'", cmd);
    }
}

void
move_file(char *dir, char *fname, char *to)
{
    char cmd[FILENAME_MAX];

    if (fname[0] == '/')
	snprintf(cmd, sizeof(cmd), "mv %s %s", fname, to);
    else
	snprintf(cmd, sizeof(cmd), "mv %s/%s %s", dir, fname, to);
    if (vsystem("%s", cmd)) {
	cleanup(0);
	errx(2, "could not perform '%s'", cmd);
    }
}

/*
 * Copy a hierarchy (possibly from dir) to the current directory, or
 * if "to" is TRUE, from the current directory to a location someplace
 * else.
 *
 * Though slower, using tar to copy preserves symlinks and everything
 * without me having to write some big hairy routine to do it.
 */
void
copy_hierarchy(char *dir, char *fname, Boolean to)
{
    char cmd[FILENAME_MAX * 3];

    if (!to) {
	/* If absolute path, use it */
	if (*fname == '/')
	    dir = "/";
	snprintf(cmd, sizeof(cmd), "tar cf - -C %s %s | tar xpf -",
 		 dir, fname);
    }
    else
	snprintf(cmd, sizeof(cmd), "tar cf - %s | tar xpf - -C %s",
 		 fname, dir);
#ifdef DEBUG
    printf("Using '%s' to copy trees.\n", cmd);
#endif
    if (system(cmd)) {
	cleanup(0);
	errx(2, "copy_file: could not perform '%s'", cmd);
    }
}

/* Unpack a tar file */
int
unpack(char *pkg, char *flist)
{
    char args[10], suff[80], *cp;

    args[0] = '\0';
    /*
     * Figure out by a crude heuristic whether this or not this is probably
     * compressed.
     */
    if (strcmp(pkg, "-")) {
	cp = strrchr(pkg, '.');
	if (cp) {
	    strlcpy(suff, cp + 1, sizeof(suff));
	    if (strchr(suff, 'z') || strchr(suff, 'Z'))
		strlcpy(args, "-z", sizeof(args));
	}
    }
    else
	strlcpy(args, "z", sizeof(args));
    strlcat(args, "xpf", sizeof(args));
    if (vsystem("tar %s %s %s", args, pkg, flist ? flist : "")) {
	pwarnx("tar extract of %s failed!", pkg);
	return 1;
    }
    return 0;
}

/*
 * Using fmt, replace all instances of:
 * 
 * %F	With the parameter "name"
 * %D	With the parameter "dir"
 * %B	Return the directory part ("base") of %D/%F
 * %f	Return the filename part of %D/%F
 * 
 */
int
format_cmd(char *buf, size_t size, const char *fmt, 
	const char *dir, const char *name)
{
	char *pos;
	size_t len;

	while (*fmt != 0 && size != 0) {
		if (*fmt == '%') {
			switch(fmt[1]) {
			case 'f':
				if (name == NULL)
					return 0;
				pos = strrchr(name, '/');
				if (pos != NULL) {
					pos++;
					len = strlen(name) - (pos-name);
					if (len >= size)
						return 0;
					memcpy(buf, pos, len);
					buf += len;
					size -= len;
					fmt += 2;
					continue;
				}
				/* FALLTHRU */
			case 'F':
				if (name == NULL)
					return 0;
				len = strlen(name);
				if (len >= size)
					return 0;
				memcpy(buf, name, len);
				buf += len;
				size -= len;
				fmt += 2;
				continue;
			case 'D':
				if (dir == NULL)
					return 0;
				len = strlen(dir);
				if (len >= size)
					return 0;
				memcpy(buf, dir, len);
				buf += len;
				size -= len;
				fmt += 2;
				continue;
			case 'B':
				if (dir == NULL || name == NULL)
					return 0;
				len = strlen(dir);
				if (len >= size)
					return 0;
				memcpy(buf, dir, len);
				buf += len;
				size -= len;
				if ((pos = strrchr(name, '/')) != NULL) {
					*buf++ = '/';
					size--;
					if (pos - name >= size)
						return 0;
					memcpy(buf, name, pos-name);
					buf += pos-name;
					size -= pos-name;
				}
				fmt += 2;
				continue;
			case '%':
				fmt++;	
			default:
				break;
			    
			}
		}
		*buf++ = *fmt++;
		size--;
	}
	if (size == 0)
		return 0;
	else 
	    *buf = '\0';
	return 1;
}
@


1.26
log
@New keywords: @@extra and @@extraunexec.
Used to record extra files (configuration) and action, that will only
be taken with pkg_delete -c.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.25 2003/08/06 20:46:36 millert Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: file.c,v 1.25 2003/08/06 20:46:36 millert Exp $";
@


1.25
log
@Plug some memory leaks; from Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.23 2003/07/30 17:03:55 tedu Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: file.c,v 1.23 2003/07/30 17:03:55 tedu Exp $";
d108 1
a108 1
fexists(char *fname)
d118 1
a118 1
isdir(char *fname)
d130 1
a130 1
islinktodir(char *fname)
d145 1
a145 1
isemptydir(char *fname)
d167 1
a167 1
isfile(char *fname)
d178 1
a178 1
isemptyfile(char *fname)
d190 1
a190 1
isURL(char *fname)
@


1.24
log
@Fix strlcat() args; from Patrick Latifi
@
text
@d368 1
d394 1
d423 1
@


1.23
log
@basic support for ftp:// in PKG_PATH.  ok pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.22 2003/07/04 17:31:19 avsm Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: file.c,v 1.22 2003/07/04 17:31:19 avsm Exp $";
d299 1
a299 1
		strlcat(cp, ensure_tgz(spec), sizeof(fname));
@


1.22
log
@'static const char rcsid[]' to make it -Wall clean
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.21 2003/07/04 17:23:16 avsm Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: file.c,v 1.21 2003/07/04 17:23:16 avsm Exp $";
d404 5
d412 1
a412 2
		snprintf(tmp, sizeof(tmp), "%s/%s", cp2 ? cp2 : cp,
		    ensure_tgz(fname));
@


1.21
log
@- use sizeof(var) instead of hardcoding length in functions that need it
- krw@@ rewrote make_preserve_name() to get rid of some hard to read string code
- some trivial strn{cpy,cat} - > strl{cpy,cat} conversions
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.20 2003/06/01 15:53:43 deraadt Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.20 2003/06/01 15:53:43 deraadt Exp $";
@


1.20
log
@various format string cleanups; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.19 2003/05/12 22:03:22 pvalchev Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.19 2003/05/12 22:03:22 pvalchev Exp $";
d57 1
a57 1
		snprintf(buffer, sizeof buffer, "%s%s", name, TGZ);
d292 1
a292 1
	    strlcpy(fname, base, sizeof fname);
d299 1
a299 1
		strlcat(cp, ensure_tgz(spec), sizeof fname);
d306 1
a306 2
	    strlcpy(fname, hint, sizeof fname);
	    strlcat(fname, spec, sizeof fname);
d310 2
a311 2
	strlcpy(fname, spec, sizeof fname);
    cp = fileURLHost(fname, host, MAXHOSTNAMELEN);
d317 1
a317 1
    cp = fileURLFilename(fname, file, FILENAME_MAX);
d371 1
a371 1
		strlcpy(tmp, ensure_tgz(fname), sizeof tmp);
d383 1
a383 1
			strlcat(tmp, ensure_tgz(fname), sizeof tmp);
d407 1
a407 1
		snprintf(tmp, FILENAME_MAX, "%s/%s", cp2 ? cp2 : cp,
d463 2
a464 1
    int len, i;
d466 2
a467 1
    if ((len = strlen(file)) == 0)
d469 9
d479 6
a484 20
	i = len - 1;
    strncpy(try, file, max);
    if (try[i] == '/') /* Catch trailing slash early and save checking in the loop */
	--i;
    for (; i; i--) {
	if (try[i] == '/') {
	    try[i + 1]= '.';
	    strncpy(&try[i + 2], &file[i + 1], max - i - 2);
	    break;
	}
    }
    if (!i) {
	try[0] = '.';
	strncpy(try + 1, file, max - 1);
    }
    /* I should probably be called rude names for these inline assignments */
    strncat(try, ".",  max -= strlen(try));
    strncat(try, name, max -= strlen(name));
    strncat(try, ".",  max--);
    strncat(try, "backup", max -= 6);
d517 1
a517 1
	snprintf(cmd, FILENAME_MAX, "cp -p -r %s %s", fname, to);
d519 1
a519 1
	snprintf(cmd, FILENAME_MAX, "cp -p -r %s/%s %s", dir, fname, to);
d532 1
a532 1
	snprintf(cmd, FILENAME_MAX, "mv %s %s", fname, to);
d534 1
a534 1
	snprintf(cmd, FILENAME_MAX, "mv %s/%s %s", dir, fname, to);
d558 1
a558 1
	snprintf(cmd, FILENAME_MAX * 3, "tar cf - -C %s %s | tar xpf -",
d562 1
a562 1
	snprintf(cmd, FILENAME_MAX * 3, "tar cf - %s | tar xpf - -C %s",
@


1.19
log
@Fix a bug where pkg_add would fail when dependencies got a few levels deep
in the recursive install by removing the code which looks under All/ for
more packages as this is not used on OpenBSD
From Barry Scott <bscott@@ridgewaysystems.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.18 2003/04/25 23:26:17 henning Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.18 2003/04/25 23:26:17 henning Exp $";
d524 1
a524 1
    if (vsystem(cmd)) {
d539 1
a539 1
    if (vsystem(cmd)) {
@


1.18
log
@kill #if 0 code w/ evil string functions, deraadt/tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.17 2003/04/19 10:46:16 henning Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.17 2003/04/19 10:46:16 henning Exp $";
a382 4
			*cp = '\0';	/* chop name */
			cp = strrchr(tmp, '/');
		}
		if (cp) {
a383 1
			strlcat(tmp, "All/", sizeof tmp);
@


1.17
log
@string stuff, ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.16 2003/04/04 08:56:01 avsm Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.16 2003/04/04 08:56:01 avsm Exp $";
a296 6
#if 0
	    if (cp) {
		*cp = '\0';	/* chop name */
		cp = strrchr(fname, '/');
	    }
#endif
a298 3
#if 0
		strcat(cp, "All/");
#endif
@


1.16
log
@some more strcpy/strcat -> strlcpy/strlcat conversions
ok and tweaks by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.15 2001/07/09 07:05:03 deraadt Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.15 2001/07/09 07:05:03 deraadt Exp $";
d406 2
a407 1
					strcpy(s+1, cp);
d431 1
a431 1
				strcpy(t+1, s);
@


1.15
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.14 2001/04/08 16:45:47 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.14 2001/04/08 16:45:47 espie Exp $";
d377 1
a377 1
			strcpy (tmp, cp);
d388 1
a388 1
		strcpy(tmp, base);
d604 1
a604 1
	    strcpy(suff, cp + 1);
d606 1
a606 1
		strcpy(args, "-z");
d610 2
a611 2
	strcpy(args, "z");
    strcat(args, "xpf");
@


1.14
log
@Better error messages: pwarnx function, which works like pwarn, except
it shows a current package name along with the program name, e.g.,
pkg_add(foo-3.0): some error occurred.

A few messages now bear redundant pkgnames, which is much better than
doing pkg_add * and being informed that something went slightly wrong
somewhere...
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.13 2001/03/11 13:22:31 wilfried Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.13 2001/03/11 13:22:31 wilfried Exp $";
d90 1
a90 1
		execl("/usr/bin/ftp","ftp","-V","-o","-",url,NULL);
d345 1
a345 1
		i = execl("/bin/tar", "tar", Verbose ? "-xpzvf" : "-xpzf", "-", 0);
@


1.13
log
@add p-flag to tar so that uids/gids and
file modes are preserved on ftp/http installs
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.12 2000/05/12 06:06:26 deraadt Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.12 2000/05/12 06:06:26 deraadt Exp $";
d323 1
a323 1
	warnx("URL `%s' has bad host part!", fname);
d329 1
a329 1
	warnx("URL `%s' has bad filename part!", fname);
d613 1
a613 1
	warnx("tar extract of %s failed!", pkg);
@


1.12
log
@nasty bug in %f; espie
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.11 2000/04/28 22:13:55 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.11 2000/04/28 22:13:55 espie Exp $";
d345 1
a345 1
		i = execl("/bin/tar", "tar", Verbose ? "-xzvf" : "-xzf", "-", 0);
@


1.11
log
@Remove last remnants of @@option preserve and @@option extract-in-place
We don't use these, and they are a bad idea anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.10 2000/03/24 00:20:04 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.10 2000/03/24 00:20:04 espie Exp $";
d643 1
@


1.10
log
@Handle expansion sequences in @@exec better (let the expander decide whether
it needs a file name instead of assuming we always need one).

Sent to *quite a few* people, comments by drahn@@... guys, wake up !!!
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.9 1999/10/09 20:35:46 beck Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.9 1999/10/09 20:35:46 beck Exp $";
a710 1
			
@


1.9
log
@Band Aid fixes, polyglot of espies and mine:

  - ensure package files end in .tgz if not suffixed, but allow for .tar.gz and
uncompressed .tar as well.

  - make pkg_add take as many args as you can feed it. - "pkg_add *.tgz"
works now.

  - fix bug where realpath could fail and leave NULL in arg list.
  - fix bug where nonexistent package could fail and leave NULL in arg list.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.8 1999/09/20 16:54:44 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.8 1999/09/20 16:54:44 espie Exp $";
a626 1
 * Check that no overflows can occur.
d628 3
a630 2
void
format_cmd(char *buf, size_t size, char *fmt, char *dir, char *name)
d632 2
a633 3
	char	scratch[FILENAME_MAX * 2];
	char   *bufp;
	char   *cp;
d635 1
a635 1
	for (bufp = buf ; (int)(bufp - buf) < size && *fmt ; ) {
d637 16
a652 1
			switch (*++fmt) {
d654 10
a663 4
				strnncpy(bufp, size - (int)(bufp - buf), name, strlen(name));
				bufp += strlen(bufp);
				break;

d665 10
a674 4
				strnncpy(bufp, size - (int)(bufp - buf), dir, strlen(dir));
				bufp += strlen(bufp);
				break;

d676 16
a691 3
				(void) snprintf(scratch, sizeof(scratch), "%s/%s", dir, name);
				if ((cp = strrchr(scratch, '/')) == (char *) NULL) {
					cp = scratch;
d693 4
a696 15
				strnncpy(bufp, size - (int)(bufp - buf), scratch, (size_t)(cp - scratch));
				bufp += strlen(bufp);
				break;

			case 'f':
				(void) snprintf(scratch, sizeof(scratch), "%s/%s", dir, name);
				if ((cp = strrchr(scratch, '/')) == (char *) NULL) {
					cp = scratch;
				} else {
					cp++;
				}
				strnncpy(bufp, size - (int)(bufp - buf), cp, strlen(cp));
				bufp += strlen(bufp);
				break;

a697 1
				*bufp++ = *fmt;
d699 1
a700 3
			++fmt;
		} else {
			*bufp++ = *fmt++;
d702 2
d705 5
a709 1
	*bufp = '\0';
d711 1
@


1.8
log
@- get http:// and ftp:// treated in a uniform way,
- disable FreeBSD-specific packages organization per category
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.7 1998/10/13 23:09:52 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.7 1998/10/13 23:09:52 marc Exp $";
d37 25
d292 1
a292 1
	    strcpy(fname, base);
d308 1
a308 2
		strcat(cp, spec);
		strcat(cp, ".tgz");
d315 2
a316 2
	    strcpy(fname, hint);
	    strcat(fname, spec);
d320 1
a320 1
	strcpy(fname, spec);
d381 2
a382 2
		if (fexists(fname) && isfile(fname)) {
			strcpy(tmp, fname);
d397 2
a398 3
			strcat(cp, "All/");
			strcat(cp, fname);
			strcat(cp, ".tgz");
d421 2
a422 1
		snprintf(tmp, FILENAME_MAX, "%s/%s.tgz", cp2 ? cp2 : cp, fname);
@


1.7
log
@Sync with recent NetBSD changes:
- use snprintf in place of sprintf
- code cleanup
- Package -> package_t, PackingList -> plist_t
Also: remove files that haven't been linked in a while
Pass -q to mtree so it is quiet in the presence of symlinks
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.6 1998/09/07 22:30:16 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.6 1998/09/07 22:30:16 marc Exp $";
d168 1
a168 3
     * I'm sure there are other types of URL specifications that I could
     * also be looking for here, but for now I'll just be happy to get ftp
     * working.
d176 2
d190 5
a194 1
    fname += strlen("ftp://");
d219 5
a223 1
    fname += strlen("ftp://");
d268 3
a270 1
	    /* Advance back two slashes to get to the root of the package hierarchy */
d272 1
d277 1
d280 1
d282 1
@


1.6
log
@updated pkg_* tools.  Merged in many changes/improvements from NetBSD.
New features include md5 hash so pkg_delete won't remove files that have
changed and the ability to define conflicting packages, e.g. you can't
install both mh and nmh.  The ports tree will have to be updated to take
advantage of this.

Let me know of any problems, real or imagined :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.5 1998/04/07 07:11:33 deraadt Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.5 1998/04/07 07:11:33 deraadt Exp $";
d31 1
d37 43
a79 2
FILE *
ftpGetURL(char *url, char *user, char *passwd, int *retcode);
d241 1
a241 1
    char pword[MAXHOSTNAMELEN + 40], *uname, *cp, *rp;
a243 1
    struct passwd *pw;
a294 16
    /* Maybe change to ftp if this doesn't work */
    uname = "anonymous";

    /* Make up a convincing "password" */
    pw = getpwuid(getuid());
    if (!pw) {
	warnx("can't get user name for ID %d", getuid());
	strcpy(pword, "joe@@");
    }
    else {
	char me[MAXHOSTNAMELEN + 1];

	gethostname(me, sizeof me);
	me[sizeof(me) - 1] = '\0';
	snprintf(pword, sizeof pword, "%s@@%s", pw->pw_name, me);
    }
d297 1
a297 1
    ftp = ftpGetURL(fname, uname, pword, &status);
d300 2
a301 2
	if ((rp = make_playpen(pen, 0)) != NULL) {
            rp=pen; /* XXX - pen is dynamic; make static? */
d334 2
a335 2
    static char tmp[FILENAME_MAX];
    char *cp;
d337 14
a350 6
    if (fexists(fname) && isfile(fname)) {
	strcpy(tmp, fname);
	return tmp;
    }
    if (base) {
	strcpy(tmp, base);
d352 26
a377 4
	cp = strrchr(tmp, '/');
	if (cp) {
	    *cp = '\0';	/* chop name */
	    cp = strrchr(tmp, '/');
d379 21
a399 7
	if (cp) {
	    *(cp + 1) = '\0';
	    strcat(cp, "All/");
	    strcat(cp, fname);
	    strcat(cp, ".tgz");
	    if (fexists(tmp))
		return tmp;
d401 2
a402 11
    }

    cp = getenv("PKG_PATH");
    while (cp) {
	char *cp2 = strsep(&cp, ":");

	snprintf(tmp, FILENAME_MAX, "%s/%s.tgz", cp2 ? cp2 : cp, fname);
	if (fexists(tmp) && isfile(tmp))
	    return tmp;
    }
    return NULL;
d417 1
a417 1
    contents = (char *)malloc(sb.st_size + 1);
d423 1
a423 1
    if (read(fd, contents, sb.st_size) != sb.st_size) {
d429 1
a429 1
    contents[sb.st_size] = '\0';
d437 1
a437 1
make_preserve_name(char *try, int max, char *name, char *file)
d471 2
a472 2
    FILE *fp;
    int len;
d474 8
a481 9
    fp = fopen(name, "w");
    if (!fp) {
	cleanup(0);
	errx(2, "cannot fopen '%s' for writing", name);
    }
    len = strlen(str);
    if (fwrite(str, 1, len, fp) != len) {
	cleanup(0);
	errx(2, "short fwrite on '%s', tried to write %d bytes",
d483 5
a487 5
    }
    if (fclose(fp)) {
	cleanup(0);
	errx(2, "failure to fclose '%s'", name);
    }
d556 1
a556 1
    char args[10], suffix[80], *cp;
d566 2
a567 2
	    strcpy(suffix, cp + 1);
	    if (strchr(suffix, 'z') || strchr(suffix, 'Z'))
d581 3
a583 2
/* Using fmt, replace all instances of:
 *
d588 2
a589 3
 *
 * Does not check for overflow - caution!
 *
d592 1
a592 1
format_cmd(char *buf, char *fmt, char *dir, char *name)
d594 45
a638 39
    char *cp, scratch[FILENAME_MAX * 2];

    while (*fmt) {
	if (*fmt == '%') {
	    switch (*++fmt) {
	    case 'F':
		strcpy(buf, name);
		buf += strlen(name);
		break;

	    case 'D':
		strcpy(buf, dir);
		buf += strlen(dir);
		break;

	    case 'B':
		sprintf(scratch, "%s/%s", dir, name);
		cp = &scratch[strlen(scratch) - 1];
		while (cp != scratch && *cp != '/')
		    --cp;
		*cp = '\0';
		strcpy(buf, scratch);
		buf += strlen(scratch);
		break;

	    case 'f':
		sprintf(scratch, "%s/%s", dir, name);
		cp = &scratch[strlen(scratch) - 1];
		while (cp != scratch && *(cp - 1) != '/')
		    --cp;
		strcpy(buf, cp);
		buf += strlen(cp);
		break;

	    default:
		*buf++ = *fmt;
		break;
	    }
	    ++fmt;
d640 1
a640 50
	else
	    *buf++ = *fmt++;
    }
    *buf = '\0';
}


/* This is as ftpGetURL from FreeBSD's ftpio.c, except that it uses
 * OpenBSD's ftp command to do all FTP, which will DTRT for proxies,
 * etc.
 */
FILE *
ftpGetURL(char *url, char *user, char *passwd, int *retcode)
{
  FILE *ftp;
  pid_t pid_ftp;
  int p[2];

  *retcode=0;

  if( pipe(p) < 0){
    *retcode = 1;
    return NULL;
  }

  pid_ftp = fork();
  if(pid_ftp < 0){
    *retcode = 1;
    return NULL;
  }
  if(pid_ftp == 0){
    /* child */
    dup2(p[1],1);
    close(p[1]);

    execl("/usr/bin/ftp","ftp","-V","-o","-",url,NULL);
    exit(1);
  }else{
    /* parent */
    ftp = fdopen(p[0],"r");

    close(p[1]);
    
    if(ftp < 0){
      *retcode = 1;
      return NULL;
    }
  }
  
  return ftp;
@


1.5
log
@active mode is way busted; default to passive
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.4 1997/01/17 07:14:15 millert Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.4 1997/01/17 07:14:15 millert Exp $";
d28 5
a32 1
#include "ftp.h"
d36 3
d55 1
a55 1
    if (stat(fname, &sb) != FAIL && S_ISDIR(sb.st_mode))
d61 15
d80 1
a80 1
    if (isdir(fname)) {
d150 1
a150 1
    if (ret = where) {
d175 1
a175 1
    if (ret = where) {
a190 1
#define HOSTNAME_MAX	64
d198 2
a199 2
    char host[HOSTNAME_MAX], file[FILENAME_MAX], dir[FILENAME_MAX];
    char pword[HOSTNAME_MAX + 40], *uname, *cp, *rp, *tmp;
d203 1
a203 1
    FTP_t ftp;
d205 1
a205 3
    int fd, fd2, i, len = 0;
    char ch;
    time_t start, stop;
a211 2
	int len;

d229 1
d242 1
a242 2
    ftp = FtpInit();
    cp = fileURLHost(fname, host, HOSTNAME_MAX);
d244 1
a244 1
	whinge("URL `%s' has bad host part!", fname);
d250 1
a250 1
	whinge("URL `%s' has bad filename part!", fname);
d260 1
a260 1
	whinge("Can't get user name for ID %d\n.", getuid());
d263 2
a264 2
    else
	snprintf(pword, HOSTNAME_MAX + 40, "%s@@%s", pw->pw_name, host);
d266 4
d271 3
a273 20
	printf("Trying to log into %s as %s.\n", host, uname);
    FtpOpen(ftp, host, uname, pword);
    if (getenv("FTP_ACTIVE_MODE") == NULL)
	FtpPassive(ftp, TRUE);

    strcpy(dir, file);
    for (i = strlen(dir); i && dir[i] != '/'; i--);
    dir[i] = '\0';

    if (dir[0]) {
	if (Verbose) printf("FTP: chdir to %s\n", dir);
	FtpChdir(ftp, dir);
    }
    FtpBinary(ftp, TRUE);
    if (Verbose) printf("FTP: trying to get %s\n", basename_of(file));
    tmp = basename_of(file);
    if (!strstr(tmp, ".tgz"))
	tmp = strconcat(tmp, ".tgz");
    fd = FtpGet(ftp, tmp);
    if (fd >= 0) {
d275 2
a276 1
	if (rp = make_playpen(pen, 0)) {
d281 1
a281 1
		dup2(fd, 0);
a282 2
		if (Verbose)
		    printf("tar command returns %d status\n", i);
d288 1
a288 1
		close(fd);
d290 2
d296 1
d299 4
a302 3
	printf("Error: FTP Unable to get %s\n", basename_of(file));
    FtpEOF(ftp);
    FtpClose(ftp);
d319 1
a319 1
	cp = strrchr(fname, '/');
d322 1
a322 1
	    cp = strrchr(fname, '/');
d328 1
d352 4
a355 2
    if (stat(fname, &sb) == FAIL)
	barf("Can't stat '%s'.", fname);
d359 9
a367 4
    if (fd == FAIL)
	barf("Unable to open '%s' for reading.", fname);
    if (read(fd, contents, sb.st_size) != sb.st_size)
	barf("Short read on '%s' - did not get %qd bytes.", fname, sb.st_size);
d373 34
d415 4
a418 2
    if (!fp)
	barf("Can't fopen '%s' for writing.", name);
d420 9
a428 4
    if (fwrite(str, 1, len, fp) != len)
	barf("Short fwrite on '%s', tried to write %d bytes.", name, len);
    if (fclose(fp))
	barf("failure to fclose '%s'.", name);
d440 4
a443 2
    if (vsystem(cmd))
	barf("Couldn't perform '%s'", cmd);
d455 4
a458 2
    if (vsystem(cmd))
	barf("Couldn't perform '%s'", cmd);
d487 4
a490 2
    if (system(cmd))
	barf("copy_file: Couldn't perform '%s'", cmd);
d516 1
a516 1
	whinge("Tar extract of %s failed!", pkg);
d579 46
@


1.4
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.3 1996/12/29 12:19:08 graichen Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.3 1996/12/29 12:19:08 graichen Exp $";
d252 1
a252 1
    if (getenv("FTP_PASSIVE_MODE"))
@


1.3
log
@our tar (paxtar) is now in /bin/tar not /usr/bin/tar
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.2 1996/06/04 08:43:42 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.2 1996/06/04 08:43:42 niklas Exp $";
d443 1
a443 1
	cp = rindex(pkg, '.');
d446 1
a446 1
	    if (index(suffix, 'z') || index(suffix, 'Z'))
@


1.2
log
@Oops, screwed up the $OpenBSD$ IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.1 1996/06/04 07:56:11 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.1 1996/06/04 07:56:11 niklas Exp $";
d277 1
a277 1
		i = execl("/usr/bin/tar", "tar", Verbose ? "-xzvf" : "-xzf", "-", 0);
@


1.1
log
@add package tools from FreeBSD
@
text
@d1 2
a2 1
#	$OpenBSD$
d4 1
a4 1
static const char *rcsid = "$OpenBSD: file.c,v 1.21 1996/03/12 06:12:43 jkh Exp $";
@
