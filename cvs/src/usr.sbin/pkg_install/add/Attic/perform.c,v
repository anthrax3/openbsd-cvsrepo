head	1.33;
access;
symbols
	OPENBSD_3_5:1.32.0.4
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	OPENBSD_3_3:1.22.0.6
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.20.0.4
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.33
date	2004.05.28.20.15.48;	author brad;	state dead;
branches;
next	1.32;

1.32
date	2003.08.21.20.24.56;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.16.17.31.56;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.06.20.46.36;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.01.08.56.01;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.09.20.01.43;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.04.17.31.19;	author avsm;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.19.10.46.16;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.05.18.04.00;	author avsm;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.04.08.56.01;	author avsm;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.03.19.42.53;	author avsm;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.26.05.04.33;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.17.10.40.05;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.19.16.54.05;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.08.16.45.46;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.02.10.13.38;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.22.20.42.03;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.16.17.22.18;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.01.19.44.10;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.28.22.13.54;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.16.22.02.26;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.27.17.14.59;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	99.11.03.17.23.48;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	99.10.09.20.35.45;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	99.07.07.06.00.24;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.07.05.09.55.40;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	99.07.04.18.23.51;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	98.10.13.23.09.49;	author marc;	state Exp;
branches;
next	1.5;

1.5
date	98.09.07.22.30.13;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	98.04.07.05.56.13;	author marc;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.04.51.53;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.06.04.08.43.34;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.04.07.56.04;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.33
log
@bye bye old package tools.

ok deraadt@@
@
text
@/*	$OpenBSD: perform.c,v 1.32 2003/08/21 20:24:56 espie Exp $	*/

#ifndef lint
static const char rcsid[] = "$OpenBSD: perform.c,v 1.32 2003/08/21 20:24:56 espie Exp $";
#endif

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 18 July 1993
 *
 * This is the main body of the add module.
 *
 */

#include <err.h>
#include "lib.h"
#include "add.h"

#include <sys/wait.h>
#include <ctype.h>
#include <signal.h>
#include <errno.h>

static int pkg_do(char *);
static int sanity_check(char *);
static char LogDir[FILENAME_MAX];
static int zapLogDir;          /* Should we delete LogDir? */

int
pkg_perform(char **pkgs)
{
    int i, err_cnt = 0;

    signal(SIGINT, cleanup);
    signal(SIGHUP, cleanup);

    if (AddMode == SLAVE)
	err_cnt = pkg_do(NULL);
    else {
	for (i = 0; pkgs[i]; i++)
	    err_cnt += pkg_do(pkgs[i]);
    }
    return err_cnt;
}

static package_t Plist;
static char *Home;

/* called to see if pkg is already installed as some other version */
/* note found version in "note" */
static int
check_if_installed(const char *found, char *note, int len)
{
    strlcpy(note, found, len);
    return 0;
}

/*
 * This is seriously ugly code following.  Written very fast!
 * [And subsequently made even worse..  Sigh!  This code was just born
 * to be hacked, I guess.. :) -jkh]
 */
static int
pkg_do(char *pkg)
{
    char pkg_fullname[FILENAME_MAX];
    char playpen[FILENAME_MAX];
    char extract_contents[FILENAME_MAX];
    char solve_deps[FILENAME_MAX+50];
    char *where_to, *tmp, *extract;
    char *dbdir;
    FILE *cfile;
    int code;
    plist_t *p;
    struct stat sb;

    set_pkg(pkg);
    code = 0;
    zapLogDir = 0;
    LogDir[0] = '\0';
    strlcpy(playpen, FirstPen, sizeof(playpen));
    dbdir = (tmp = getenv(PKG_DBDIR)) ? tmp : DEF_LOG_DIR;

    snprintf(solve_deps, sizeof solve_deps, "pkg%s dependencies solve %s",
	Verbose ? " -v": "", CONTENTS_FNAME);
    if (Prefix)
    	setenv("PKG_PREFIX", Prefix, 1);
    else
    	unsetenv("PKG_PREFIX");
    /* Are we coming in for a second pass, everything already extracted? */
    /* (Slave mode) */
    if (!pkg) {
	fgets(playpen, FILENAME_MAX, stdin);
	playpen[strlen(playpen) - 1] = '\0'; /* pesky newline! */
	if (chdir(playpen) == FAIL) {
	    pwarnx("add in SLAVE mode can't chdir to `%s'", playpen);
	    return 1;
	}
	read_plist(&Plist, stdin);
	where_to = playpen;
    }
    /* Nope - do it now */
    else {
	/* Is it an ftp://foo.bar.baz/file.tgz specification? */
	if (isURL(pkg)) {
	    if (ispkgpattern(pkg)) {
		pwarnx("patterns not allowed in URLs, "
		     "please install manually!");
		/* ... until we come up with a better solution :-/  - HF */
		goto bomb;
	    }

	    if (!(Home = fileGetURL(NULL, pkg))) {
		pwarnx("unable to fetch `%s' by URL", pkg);
		return 1;
	    }
	    where_to = Home;
	    strlcpy(pkg_fullname, pkg, sizeof(pkg_fullname));
	    system(solve_deps);
	    cfile = fopen(CONTENTS_FNAME, "r");
	    if (!cfile) {
		pwarnx(
		"unable to open table of contents file `%s' - not a package?",
		CONTENTS_FNAME);
		goto bomb;
	    }
	    read_plist(&Plist, cfile);
	    fclose(cfile);
	} else {
	    strlcpy(pkg_fullname, ensure_tgz(pkg), sizeof(pkg_fullname));
	    if (strcmp(pkg, "-")) {
		if (!ispkgpattern(pkg_fullname)
		    && stat(pkg_fullname, &sb) == FAIL) {
		    pwarnx("can't stat package file '%s'", pkg_fullname);
		    goto bomb;
		}
		snprintf(extract_contents, sizeof( extract_contents ),
			 "%s", CONTENTS_FNAME);
		extract = extract_contents;
	    }
	    else {
		extract = NULL;
		sb.st_size = 100000;	/* Make up a plausible average size */
	    }
	    Home = make_playpen(playpen, sizeof(playpen), sb.st_size * 4);
	    if (!Home)
		pwarnx("unable to make playpen for %ld bytes",
		    (long)(sb.st_size * 4));
	    where_to = Home;
	    if (unpack(pkg_fullname, extract)) {
		pwarnx(
	"unable to extract table of contents from `%s'\n"
	"Is this a Package, or a simple .tgz archive ?  See tar(1).",
		pkg_fullname);
		goto bomb;
	    }
	    system(solve_deps);
	    cfile = fopen(CONTENTS_FNAME, "r");
	    if (!cfile) {
		pwarnx(
	"unable to open table of contents file `%s'\n"
	"Is this a Package, or a simple .tgz archive ?  See tar(1).",
		CONTENTS_FNAME);
		goto bomb;
	    }
	    read_plist(&Plist, cfile);
	    fclose(cfile);

	    /*
	     * Apply a crude heuristic to see how much space the package will
	     * take up once it's unpacked.  I've noticed that most packages
	     * compress an average of 75%, so multiply by 4 for good
	     * measure.  Ignore if extract is null as we've already
	     * extracted the full file, anyway.
	     */

	    if (!extract && min_free(playpen) < sb.st_size * 4) {
		pwarnx("projected size of %ld exceeds available free space\n"
		       "Please set your PKG_TMPDIR variable to point to a"
		       "location with more\n"
		       "free space and try again", (long)(sb.st_size * 4));
		pwarnx("not extracting `%s'\ninto `%s', sorry!", pkg_fullname,
		       where_to);
		goto bomb;
	    }

	    /* Finally unpack the whole mess.  If extract is null we already
	       did so so don't bother doing it again. */
	    if (extract && unpack(pkg_fullname, NULL)) {
		pwarnx("unable to extract `%s'!", pkg_fullname);
		goto bomb;
	    }
	} /* isURL(pkg) */

	/* Check for sanity and dependencies */
	if (sanity_check(pkg))
	    goto bomb;

	/* If we're running in MASTER mode, just output the plist and return */
	if (AddMode == MASTER) {
	    printf("%s\n", where_playpen());
	    write_plist(&Plist, stdout);
	    return 0;
	}
    }

    /*
     * If we have a prefix, delete the first one we see and add this
     * one in place of it.
     */
    if (Prefix) {
	delete_plist(&Plist, FALSE, PLIST_CWD, NULL);
	add_plist_top(&Plist, PLIST_CWD, Prefix);
    }

    setenv(PKG_PREFIX_VNAME, (p = find_plist(&Plist, PLIST_CWD)) ? p->name : ".", 1);
    /* Protect against old packages with bogus @@name fields */
    PkgName = (p = find_plist(&Plist, PLIST_NAME)) ? p->name : NULL;
    if (PkgName == NULL) {
	pwarnx("package name not set in package file");
	goto bomb;
    }

    /* See if we're already registered */
    (void) snprintf(LogDir, sizeof(LogDir), "%s/%s", dbdir, PkgName);
    if ((isdir(LogDir) || islinktodir(LogDir)) && !Force) {
	pwarnx("package already recorded as installed");
	code = 1;
	goto success;	/* close enough for government work */
    }

    /* See if some other version of us is already installed */
    {	
	char buf[FILENAME_MAX];
	char installed[FILENAME_MAX];
	char *s;

	if ((s=strrchr(PkgName, '-')) != NULL){
	    strlcpy(buf, PkgName, sizeof(buf));
	    /* try to find a better version number */
	    if (!isdigit(s[1])) {
	    	char *t;
		for (t = s-1; t >= PkgName; t--) 
			if (*t == '-' && isdigit(t[1])) {
				s = t;
				break;
			}
	    }
	    strlcpy(buf+(s-PkgName+1), isdigit(s[1]) ? "[0-9]*" : "*", sizeof(buf)-(s-PkgName+1));

            if (findmatchingname(dbdir, buf, check_if_installed, installed, sizeof(installed))) {
		pwarnx("other version '%s' already installed", installed);
	    	if (find_plist_option(&Plist, "no-default-conflict") != NULL) {
		    pwarnx("proceeding with installation anyway");
		} else {
		    code = 1;
		    goto success;	/* close enough for government work */
		}
	    }
	}	
    }

    /* See if there are conflicting packages installed */
    for (p = Plist.head; p ; p = p->next) {
	char installed[FILENAME_MAX];
	
	if (p->type != PLIST_PKGCFL)
	    continue;
	if (Verbose)
	    printf("Package `%s' conflicts with `%s'\n", PkgName, p->name);
	
	/* was: */
        /* if (!vsystem("/usr/sbin/pkg_info -qe '%s'", p->name)) {*/
	if(findmatchingname(dbdir, p->name, check_if_installed, installed, sizeof(installed))){
	    pwarnx("Conflicting package installed, please use\n\t\"pkg_delete %s\" first to remove it!",  installed); 
	    ++code;
	}
    }

    /* Now check the packing list for dependencies */
    for (p = Plist.head; p ; p = p->next) {
	char installed [FILENAME_MAX];
	
	if (p->type != PLIST_PKGDEP)
	    continue;
	if (Verbose)
	    printf("Package `%s' depends on `%s'\n", PkgName, p->name);
	/* if (vsystem("/usr/sbin/pkg_info -qe '%s'", p->name)) { */
	if (!findmatchingname(dbdir, p->name, check_if_installed, installed, sizeof(installed))) {
	    char path[FILENAME_MAX], *cp = NULL;

	    if (!Fake) {
		if (!isURL(pkg) && !getenv("PKG_ADD_BASE")) {
		    /* install depending pkg from local disk */
		    
		    snprintf(path, sizeof(path), "%s/%s", Home, ensure_tgz(p->name));
		    if (fexists(path))
			cp = path;
		    else
			cp = fileFindByPath(pkg, p->name);
		    if (cp) {
			if (Verbose)
			    printf("Loading it from `%s'\n", cp);
		        if (vsystem("/usr/sbin/pkg_add %s%s %s%s",
                                     Prefix ? "-p " : "",
                                     Prefix ? Prefix : "",
				     Verbose ? "-v " : "", cp)) {
			    pwarnx("autoload of dependency `%s' failed%s",
				cp, Force ? " (proceeding anyway)" : "!");
			    if (!Force)
				++code;
			}
		    }
		    else {
			pwarnx("add of dependency `%s' failed%s",
				p->name, Force ? " (proceeding anyway)" : "!");
			     if (!Force)
				++code;
		    }
		} else {
		    /* install depending pkg via FTP */

		    if (ispkgpattern(p->name)){
			pwarnx("can't install dependent pkg '%s' via FTP, "
			     "please install manually!", p->name);
			/* ... until we come up with a better solution - HF */
			goto bomb;
		    }else{
		    char *saved_Current;   /* allocated/set by save_dirs(), */
		    char *saved_Previous;  /* freed by restore_dirs() */
		    
		    save_dirs(&saved_Current, &saved_Previous);
		    
		    if ((cp = fileGetURL(pkg, p->name)) != NULL) {
			if (Verbose)
			    printf("Finished loading `%s' over FTP\n", p->name);
			system(solve_deps);
			if (!fexists(CONTENTS_FNAME)) {
			    pwarnx("autoloaded package `%s' has no %s file?",
				  p->name, CONTENTS_FNAME);
			    if (!Force)
				++code;
			}
			else if (vsystem("(pwd; cat %s) | pkg_add %s%s %s-S",
					 CONTENTS_FNAME, 
					 Prefix ? "-p " : "",
					 Prefix ? Prefix : "",
					 Verbose ? "-v " : "")) {
			    pwarnx("add of dependency `%s' failed%s",
				  p->name, Force ? " (proceeding anyway)" : "!");
			    if (!Force)
				++code;
			}
			else if (Verbose)
			    printf("\t`%s' loaded successfully\n", p->name);
			/* Nuke the temporary playpen */
			leave_playpen(cp);
			free(cp);

			restore_dirs(saved_Current, saved_Previous);
		    }
		}
	    }
	    } else {
		if (Verbose)
		    printf("and was not found%s\n", Force ? " (proceeding anyway)" : "");
		else
		    printf("Package dependency `%s' for `%s' not found%s\n", p->name, pkg,
			   Force ? " (proceeding anyway)" : "!");
		if (!Force)
		    ++code;
	    }
	}
	else if (Verbose)
	    printf(" - `%s' already installed\n", installed);
    }

    if (code != 0)
	goto bomb;

    /* Look for the requirements file */
    if (fexists(REQUIRE_FNAME)) {
	vsystem("chmod +x %s", REQUIRE_FNAME);	/* be sure */
	if (Verbose)
	    printf("Running requirements file first for `%s'\n", PkgName);
	if (!Fake && vsystem("./%s %s INSTALL", REQUIRE_FNAME, PkgName)) {
	    pwarnx("package `%s' fails requirements %s", pkg_fullname,
		   Force ? "installing anyway" : "- not installed");
	    if (!Force) {
		code = 1;
		goto success;	/* close enough for government work */
	    }
	}
    }

    /* If we're really installing, and have an installation file, run it */
    if (!NoInstall && fexists(INSTALL_FNAME)) {
	vsystem("chmod +x %s", INSTALL_FNAME);	/* make sure */
	if (Verbose)
	    printf("Running install with PRE-INSTALL for `%s'\n", PkgName);
	if (!Fake && vsystem("./%s %s PRE-INSTALL", INSTALL_FNAME, PkgName)) {
	    pwarnx("install script returned error status");
	    unlink(INSTALL_FNAME);
	    code = 1;
	    goto success;		/* nothing to uninstall yet */
	}
    }

    extract_plist(".", &Plist);

    if (!Fake && fexists(MTREE_FNAME)) {
	if (Verbose)
	    printf("Running mtree for `%s'\n", PkgName);
	p = find_plist(&Plist, PLIST_CWD);
	if (Verbose)
	    printf("mtree -q -U -f %s -d -e -p %s\n", MTREE_FNAME,
		   p ? p->name : "/");
	if (!Fake) {

	    if (vsystem("/usr/sbin/mtree -q -U -f %s -d -e -p %s", MTREE_FNAME,
			p ? p->name : "/"))
		pwarnx("mtree returned a non-zero status - continuing");
	}
	unlink(MTREE_FNAME);
    }

    /* Run the installation script one last time? */
    if (!NoInstall && fexists(INSTALL_FNAME)) {
	if (Verbose)
	    printf("Running install with POST-INSTALL for `%s'\n", PkgName);
	if (!Fake && vsystem("./%s %s POST-INSTALL", INSTALL_FNAME, PkgName)) {
	    pwarnx("install script returned error status");
	    unlink(INSTALL_FNAME);
	    code = 1;
	    goto fail;
	}
	unlink(INSTALL_FNAME);
    }

    /* Time to record the deed? */
    if (!NoRecord && !Fake) {
	char contents[FILENAME_MAX];
	FILE *cfile;

	umask(022);
	if (getuid() != 0)
	    pwarnx("not running as root - trying to record install anyway");
	if (!PkgName) {
	    pwarnx("no package name! can't record package, sorry");
	    code = 1;
	    goto success;	/* well, partial anyway */
	}
	(void) snprintf(LogDir, sizeof(LogDir), "%s/%s", dbdir, PkgName);
	zapLogDir = 1;
	if (Verbose)
	    printf("Attempting to record package into `%s'\n", LogDir);
	if (make_hierarchy(LogDir)) {
	    pwarnx("can't record package into '%s', you're on your own!",
		   LogDir);
	    memset(LogDir, 0, FILENAME_MAX);
	    code = 1;
	    goto success;	/* close enough for government work */
	}
	/* Make sure pkg_info can read the entry */
	vsystem("chmod a+rx %s", LogDir);
	if (fexists(DEINSTALL_FNAME))
	    move_file(".", DEINSTALL_FNAME, LogDir);
	if (fexists(REQUIRE_FNAME))
	    move_file(".", REQUIRE_FNAME, LogDir);
	(void) snprintf(contents, sizeof(contents), "%s/%s", LogDir, CONTENTS_FNAME);
	cfile = fopen(contents, "w");
	if (!cfile) {
	    pwarnx("can't open new contents file '%s'! can't register pkg",
		contents);
	    goto success; /* can't log, but still keep pkg */
	}
	write_plist(&Plist, cfile);
	fclose(cfile);
	move_file(".", DESC_FNAME, LogDir);
	move_file(".", COMMENT_FNAME, LogDir);
	if (fexists(DISPLAY_FNAME))
	    move_file(".", DISPLAY_FNAME, LogDir);

	/* register dependencies */
	/* we could save some cycles here if we remembered what we installed
	 * above (in case we got a wildcard dependency) */
	/* XXX remembering in p->name would NOT be good! */
	for (p = Plist.head; p ; p = p->next) {
	    if (p->type != PLIST_PKGDEP)
		continue;
	    if (Verbose)
		printf("Attempting to record dependency on package `%s'\n", p->name);
	    (void) snprintf(contents, sizeof(contents), "%s/%s", dbdir,
	    	    basename_of(p->name));
	    if (ispkgpattern(p->name)) {
		char *s;
		s=findbestmatchingname(dirname_of(contents),
				       basename_of(contents));
		if (s != NULL) {
		    char *t;
		    t=strrchr(contents, '/');
		    strlcpy(t+1, s, contents + sizeof(contents) - (t+1));
		    free(s);
		}else{
		    errx(1,"Where did our dependency go?!");
		    /* this shouldn't happen... X-) */
		}
	    }
	    strlcat(contents, "/", sizeof(contents));
	    strlcat(contents, REQUIRED_BY_FNAME, sizeof(contents));
 
	    cfile = fopen(contents, "a");
	    if (!cfile)
		pwarnx("can't open dependency file '%s'!\n"
		       "dependency registration is incomplete", contents);
	    else {
		fprintf(cfile, "%s\n", PkgName);
		if (fclose(cfile) == EOF)
		    pwarnx("cannot properly close file `%s'", contents);
	    }
	}
	if (Verbose)
	    printf("Package `%s' registered in `%s'\n", PkgName, LogDir);
    }

    if ((p = find_plist(&Plist, PLIST_DISPLAY)) != NULL) {
	char *Pager;
	char buf[BUFSIZ];
	struct stat sbuf;

	Pager = getenv("PAGER");
	if (!Pager) 
	    Pager = "/usr/bin/more";

	snprintf(buf, sizeof buf, "%s/%s", LogDir, p->name);
	if (stat(buf,&sbuf) == -1 || vsystem("%s %s", Pager, buf)) 
	    pwarnx("cannot open `%s' as display file", buf);
    }

    goto success;

 bomb:
    code = 1;
    goto success;

 fail:
    /* Nuke the whole (installed) show, XXX but don't clean directories */
    if (!Fake)
	delete_package(FALSE, FALSE, FALSE, FALSE, &Plist);

 success:
    /* delete the packing list contents */
    free_plist(&Plist);
    leave_playpen(Home);
    return code;
}

static int
sanity_check(char *pkg)
{
    int code = 0;

    if (!fexists(CONTENTS_FNAME)) {
	pwarnx("package `%s' has no CONTENTS file!", pkg);
	code = 1;
    }
    else if (!fexists(COMMENT_FNAME)) {
	pwarnx("package `%s' has no COMMENT file!", pkg);
	code = 1;
    }
    else if (!fexists(DESC_FNAME)) {
	pwarnx("package `%s' has no DESC file!", pkg);
	code = 1;
    }
    return code;
}

void
cleanup(int signo)
{
    int save_errno = errno;
    static int	alreadyCleaning;
    void (*oldint)(int);
    void (*oldhup)(int);
    char buf[1024];
    oldint = signal(SIGINT, SIG_IGN);
    oldhup = signal(SIGHUP, SIG_IGN);

    /* XXX big signal race, nearly all of it! */
    if (!alreadyCleaning) {
    	alreadyCleaning = 1;
	if (signo) {
	    snprintf(buf, sizeof buf,
		"Signal %d received, cleaning up\n", signo);
	    write(STDOUT_FILENO, buf, strlen(buf));
	}
	if (!Fake && zapLogDir && LogDir[0])
	    vsystem("%s -rf %s", REMOVE_CMD, LogDir);	/* XXX */
	leave_playpen(Home);				/* XXX */
	if (signo)
	    _exit(1);
    }
    signal(SIGINT, oldint);
    signal(SIGHUP, oldhup);
    errno = save_errno;
}
@


1.32
log
@New keywords: @@extra and @@extraunexec.
Used to record extra files (configuration) and action, that will only
be taken with pkg_delete -c.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.31 2003/08/16 17:31:56 deraadt Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: perform.c,v 1.31 2003/08/16 17:31:56 deraadt Exp $";
@


1.31
log
@more errx/warnx style \n errors; tom.cosgrove@@arches-consulting.com
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.30 2003/08/06 20:46:36 millert Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: perform.c,v 1.30 2003/08/06 20:46:36 millert Exp $";
d561 1
a561 1
	delete_package(FALSE, FALSE, FALSE, &Plist);
@


1.30
log
@Plug some memory leaks; from Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.29 2003/08/01 08:56:01 espie Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: perform.c,v 1.29 2003/08/01 08:56:01 espie Exp $";
d287 1
a287 1
	    pwarnx("Conflicting package installed, please use\n\t\"pkg_delete %s\" first to remove it!\n",  installed); 
@


1.29
log
@Add -q flag to pkg_delete: don't check md5 before removing.
Useful for bulk-package builders who want to clean /usr/local quickly.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.28 2003/07/09 20:01:43 otto Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: perform.c,v 1.28 2003/07/09 20:01:43 otto Exp $";
d370 1
d515 1
@


1.28
log
@AVoid core dump when package name in package is not valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.27 2003/07/04 17:31:19 avsm Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: perform.c,v 1.27 2003/07/04 17:31:19 avsm Exp $";
d559 1
a559 1
	delete_package(FALSE, FALSE, &Plist);
@


1.27
log
@'static const char rcsid[]' to make it -Wall clean
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.26 2003/04/19 10:46:16 henning Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: perform.c,v 1.26 2003/04/19 10:46:16 henning Exp $";
d230 5
a234 1
    PkgName = (p = find_plist(&Plist, PLIST_NAME)) ? p->name : "anonymous";
@


1.26
log
@string stuff, ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.25 2003/04/05 18:04:00 avsm Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.25 2003/04/05 18:04:00 avsm Exp $";
@


1.25
log
@use sizeof for snprintf size arg for static buffers instead of duplicating
the size value; rohee@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.24 2003/04/04 08:56:01 avsm Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.24 2003/04/04 08:56:01 avsm Exp $";
d509 1
a509 1
		    strcpy(t+1, s);
@


1.24
log
@some more strcpy/strcat -> strlcpy/strlcat conversions
ok and tweaks by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.23 2003/04/03 19:42:53 avsm Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.23 2003/04/03 19:42:53 avsm Exp $";
d304 1
a304 1
		    snprintf(path, FILENAME_MAX, "%s/%s", Home, ensure_tgz(p->name));
@


1.23
log
@some strcpy/strcat -> strlcpy/strlcat conversions
ok hin@@, ho@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.22 2001/11/26 05:04:33 deraadt Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.22 2001/11/26 05:04:33 deraadt Exp $";
d64 1
a64 1
check_if_installed(const char *found, char *note)
d66 1
a66 1
    strcpy(note, found);
d259 1
a259 1
            if (findmatchingname(dbdir, buf, check_if_installed, installed)) {
d282 1
a282 1
	if(findmatchingname(dbdir, p->name, check_if_installed, installed)){
d297 1
a297 1
	if (!findmatchingname(dbdir, p->name, check_if_installed, installed)) {
@


1.22
log
@mostly mark signal races
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.21 2001/11/17 10:40:05 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.21 2001/11/17 10:40:05 espie Exp $";
d93 1
a93 1
    strcpy(playpen, FirstPen);
d130 1
a130 1
	    strcpy(pkg_fullname, pkg);
d142 1
a142 1
	    strlcpy(pkg_fullname, ensure_tgz(pkg), sizeof pkg_fullname);
d247 1
a247 1
	    strcpy(buf, PkgName);
d257 1
a257 1
	    strcpy(buf+(s-PkgName+1), isdigit(s[1]) ? "[0-9]*" : "*");
d515 2
a516 2
	    strcat(contents, "/");
	    strcat(contents, REQUIRED_BY_FNAME);
@


1.21
log
@Pass PKG_PREFIX off to pkg thru env
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.20 2001/04/19 16:54:05 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.20 2001/04/19 16:54:05 espie Exp $";
d31 1
d34 1
a34 1
#include <sys/wait.h>
d587 1
d591 1
d595 1
d598 5
a602 2
	if (signo)
	    printf("Signal %d received, cleaning up\n", signo);
d604 2
a605 2
	    vsystem("%s -rf %s", REMOVE_CMD, LogDir);
	leave_playpen(Home);
d607 1
a607 1
	    exit(1);
d611 1
@


1.20
log
@Remove redundant package name.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.19 2001/04/08 16:45:46 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.19 2001/04/08 16:45:46 espie Exp $";
d97 4
@


1.19
log
@Better error messages: pwarnx function, which works like pwarn, except
it shows a current package name along with the program name, e.g.,
pkg_add(foo-3.0): some error occurred.

A few messages now bear redundant pkgnames, which is much better than
doing pkg_add * and being informed that something went slightly wrong
somewhere...
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.18 2001/04/02 10:13:38 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.18 2001/04/02 10:13:38 espie Exp $";
d230 1
a230 1
	pwarnx("package `%s' already recorded as installed", PkgName);
@


1.18
log
@Handle for newdepend.
- recognize the keyword,
- pass all packing lists to `pkg dependencies solve' for rewriting.

pkg dependencies solve is a no-op in the absence of newdepends.

With newdepends, it rewrites @@newdepends -> @@pkgdep on the fly, depending
on what's actually installed on the machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.17 2001/03/22 20:42:03 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.17 2001/03/22 20:42:03 espie Exp $";
d88 1
d103 1
a103 1
	    warnx("add in SLAVE mode can't chdir to `%s'", playpen);
d114 1
a114 1
		warnx("patterns not allowed in URLs, "
d121 1
a121 1
		warnx("unable to fetch `%s' by URL", pkg);
d129 1
a129 1
		warnx(
d141 1
a141 1
		    warnx("can't stat package file '%s'", pkg_fullname);
d154 1
a154 1
		warnx("unable to make playpen for %ld bytes",
d158 1
a158 1
		warnx(
d167 1
a167 1
		warnx(
d185 1
a185 1
		warnx("projected size of %ld exceeds available free space\n"
d189 1
a189 1
		warnx("not extracting `%s'\ninto `%s', sorry!", pkg_fullname,
d197 1
a197 1
		warnx("unable to extract `%s'!", pkg_fullname);
d230 1
a230 1
	warnx("package `%s' already recorded as installed", PkgName);
d255 1
a255 1
		warnx("other version '%s' already installed", installed);
d257 1
a257 1
		    warnx("proceeding with installation anyway");
d278 1
a278 1
	    warnx("Conflicting package installed, please use\n\t\"pkg_delete %s\" first to remove it!\n",  installed); 
d311 1
a311 1
			    warnx("autoload of dependency `%s' failed%s",
d318 1
a318 1
			warnx("add of dependency `%s' failed%s",
d327 1
a327 1
			warnx("can't install dependent pkg '%s' via FTP, "
d342 1
a342 1
			    warnx("autoloaded package `%s' has no %s file?",
d352 1
a352 1
			    warnx("add of dependency `%s' failed%s",
d389 1
a389 1
	    warnx("package `%s' fails requirements %s", pkg_fullname,
d404 1
a404 1
	    warnx("install script returned error status");
d424 1
a424 1
		warnx("mtree returned a non-zero status - continuing");
d434 1
a434 1
	    warnx("install script returned error status");
d449 1
a449 1
	    warnx("not running as root - trying to record install anyway");
d451 1
a451 1
	    warnx("no package name! can't record package, sorry");
d460 1
a460 1
	    warnx("can't record package into '%s', you're on your own!",
d475 1
a475 1
	    warnx("can't open new contents file '%s'! can't register pkg",
d515 1
a515 1
		warnx("can't open dependency file '%s'!\n"
d520 1
a520 1
		    warnx("cannot properly close file `%s'", contents);
d538 1
a538 1
	    warnx("cannot open `%s' as display file", buf);
d565 1
a565 1
	warnx("package `%s' has no CONTENTS file!", pkg);
d569 1
a569 1
	warnx("package `%s' has no COMMENT file!", pkg);
d573 1
a573 1
	warnx("package `%s' has no DESC file!", pkg);
@


1.17
log
@Smarter default conflict, use pkgname-[0-9]* if a version number has been
found, pkgname-*  otherwise.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.16 2000/10/16 17:22:18 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.16 2000/10/16 17:22:18 espie Exp $";
d80 1
d94 2
d125 1
d163 1
d339 1
@


1.16
log
@Let pkg_add be slightly more informative on tar balls that happen not
to be packages.

Partially based on suggestions made on misc@@, thanks guys !
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.15 2000/05/01 19:44:10 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.15 2000/05/01 19:44:10 espie Exp $";
d246 1
a246 2
	    buf[s-PkgName+1]='*';
	    buf[s-PkgName+2]='\0';
@


1.15
log
@- finish removing last pieces of in-place extraction.
- fix long time bug: call extract_plist even if not doing installation for
real, since extract_plist knows how to handle that.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.14 2000/04/28 22:13:54 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.14 2000/04/28 22:13:54 espie Exp $";
d154 2
a155 1
	"unable to extract table of contents file from `%s' - not a package?",
d162 2
a163 1
	"unable to open table of contents file `%s' - not a package?",
@


1.14
log
@Remove last remnants of @@option preserve and @@option extract-in-place
We don't use these, and they are a bad idea anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.13 2000/04/16 22:02:26 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.13 2000/04/16 22:02:26 espie Exp $";
a85 1
    int inPlace;
a90 1
    inPlace = 0;
d176 1
a176 1
	    if (!extract && !inPlace && min_free(playpen) < sb.st_size * 4) {
a185 4
	    /* If this is a direct extract and we didn't want it, stop now */
	    if (inPlace && Fake)
		goto success;

d403 1
a403 3
    /* Now finally extract the entire show if we're not going direct */
    if (!inPlace && !Fake)
	extract_plist(".", &Plist);
@


1.13
log
@Fix package conflict for flavors:
try to find the last dash followed by a digit in word.
If not applicable, then still use the last dash.

e.g., kterm-6.2.0-xaw3d -> kterm-   as a stem, not kterm-6.2.0
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.12 2000/03/27 17:14:59 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.12 2000/03/27 17:14:59 espie Exp $";
a168 26

	    /* Extract directly rather than moving?  Oh goodie! */
	    if (find_plist_option(&Plist, "extract-in-place")) {
		if (Verbose)
		    printf("Doing in-place extraction for `%s'\n", pkg_fullname);
		p = find_plist(&Plist, PLIST_CWD);
		if (p) {
		    if (!(isdir(p->name) || islinktodir(p->name)) && !Fake) {
			if (Verbose)
			    printf("Desired prefix of `%s' does not exist, creating\n", p->name);
			vsystem("mkdir -p %s", p->name);
		    }
		    if (chdir(p->name) == -1) {
			warn("unable to change directory to `%s'", p->name);
			goto bomb;
		    }
		    where_to = p->name;
		    inPlace = 1;
		}
		else {
		    warnx(
		"no prefix specified in `%s' - this is a bad package!",
			pkg_fullname);
		    goto bomb;
		}
	    }
@


1.12
log
@Add and document option no-default-conflict.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.11 1999/11/03 17:23:48 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.11 1999/11/03 17:23:48 espie Exp $";
d31 1
d267 9
@


1.11
log
@Stupid thinko. Let pkg's MESSAGES work again.
Spotted by Ian Darwin.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.10 1999/10/09 20:35:45 beck Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.10 1999/10/09 20:35:45 beck Exp $";
d271 6
a276 2
		code = 1;
		goto success;	/* close enough for government work */
@


1.10
log
@Band Aid fixes, polyglot of espies and mine:

  - ensure package files end in .tgz if not suffixed, but allow for .tar.gz and
uncompressed .tar as well.

  - make pkg_add take as many args as you can feed it. - "pkg_add *.tgz"
works now.

  - fix bug where realpath could fail and leave NULL in arg list.
  - fix bug where nonexistent package could fail and leave NULL in arg list.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.9 1999/07/07 06:00:24 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.9 1999/07/07 06:00:24 espie Exp $";
d549 1
a549 1
	if (!stat(buf,&sbuf) || vsystem("%s %s", Pager, buf)) 
@


1.9
log
@show MESSAGE using PAGER
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.8 1999/07/05 09:55:40 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.8 1999/07/05 09:55:40 espie Exp $";
d100 1
a100 1
	    warnx("add in SLAVE mode can't chdir to %s", playpen);
d133 1
a133 1
	    strcpy(pkg_fullname, pkg);		/* copy for sanity's sake, could remove pkg_fullname */
d141 1
a141 1
			 "-q %s", CONTENTS_FNAME);
d172 1
a172 1
		    printf("Doing in-place extraction for %s\n", pkg_fullname);
d177 1
a177 1
			    printf("Desired prefix of %s does not exist, creating.\n", p->name);
d204 1
a204 1
		warnx("projected size of %ld exceeds available free space.\n"
d208 1
a208 1
		warnx("not extracting %s\ninto %s, sorry!", pkg_fullname,
d284 1
a284 1
	    printf("Package `%s' conflicts with `%s'.\n", PkgName, p->name);
d301 1
a301 1
	    printf("Package `%s' depends on `%s'.\n", PkgName, p->name);
d310 1
a310 1
		    snprintf(path, FILENAME_MAX, "%s/%s.tgz", Home, p->name);
d317 1
a317 1
			    printf("Loading it from %s.\n", cp);
d350 1
a350 1
			    printf("Finished loading %s over FTP.\n", p->name);
d352 1
a352 1
			    warnx("autoloaded package %s has no %s file?",
d368 1
a368 1
			    printf("\t`%s' loaded successfully.\n", p->name);
d378 1
a378 1
		    printf("and was not found%s.\n", Force ? " (proceeding anyway)" : "");
d380 1
a380 1
		    printf("Package dependency %s for %s not found%s\n", p->name, pkg,
d387 1
a387 1
	    printf(" - %s already installed.\n", installed);
d397 1
a397 1
	    printf("Running requirements file first for %s.\n", PkgName);
d399 1
a399 1
	    warnx("package %s fails requirements %s", pkg_fullname,
d412 1
a412 1
	    printf("Running install with PRE-INSTALL for %s.\n", PkgName);
d427 1
a427 1
	    printf("Running mtree for %s.\n", PkgName);
d444 1
a444 1
	    printf("Running install with POST-INSTALL for %s.\n", PkgName);
d470 1
a470 1
	    printf("Attempting to record package into %s.\n", LogDir);
d532 1
a532 1
		    warnx("cannot properly close file %s", contents);
d536 1
a536 1
	    printf("Package %s registered in %s\n", PkgName, LogDir);
d550 1
a550 1
	    warnx("cannot open %s as display file", buf);
d577 1
a577 1
	warnx("package %s has no CONTENTS file!", pkg);
d581 1
a581 1
	warnx("package %s has no COMMENT file!", pkg);
d585 1
a585 1
	warnx("package %s has no DESC file!", pkg);
d603 1
a603 1
	    printf("Signal %d received, cleaning up.\n", signo);
@


1.8
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.7 1999/07/04 18:23:51 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.7 1999/07/04 18:23:51 espie Exp $";
d540 1
a540 1
	FILE *fp;
d542 5
d549 1
a549 8
	fp = fopen(buf, "r");
	if (fp) {
	    putc('\n', stdout);
	    while (fgets(buf, sizeof(buf), fp))
		fputs(buf, stdout);
	    putc('\n', stdout);
	    (void) fclose(fp);
	} else
@


1.7
log
@Let pkg_add use tar -q.

(This could have been done by using pax -n, but since pkg_* is so badly
written, it's harder to hunt down all the code using tar and fix it to
use the right options.
If this code were written properly, there would be one clean entry point
to processing archives, and it would be trivial to switch archivers...)
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.6 1998/10/13 23:09:49 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.6 1998/10/13 23:09:49 marc Exp $";
d140 1
a140 1
		snprintf(extract_contents, sizeof( extract_comments ),
@


1.6
log
@Sync with recent NetBSD changes:
- use snprintf in place of sprintf
- code cleanup
- Package -> package_t, PackingList -> plist_t
Also: remove files that haven't been linked in a while
Pass -q to mtree so it is quiet in the presence of symlinks
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.5 1998/09/07 22:30:13 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.5 1998/09/07 22:30:13 marc Exp $";
a139 1
#if 0
d141 1
a141 5
			 "--fast-read %s", CONTENTS_FNAME);
#else
		snprintf(extract_contents, sizeof( extract_contents ),
			 "%s", CONTENTS_FNAME);
#endif
@


1.5
log
@updated pkg_* tools.  Merged in many changes/improvements from NetBSD.
New features include md5 hash so pkg_delete won't remove files that have
changed and the ability to define conflicting packages, e.g. you can't
install both mh and nmh.  The ports tree will have to be updated to take
advantage of this.

Let me know of any problems, real or imagined :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.4 1998/04/07 05:56:13 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.4 1998/04/07 05:56:13 marc Exp $";
d56 1
a56 1
static Package Plist;
d59 9
d80 1
d83 1
a83 1
    PackingList p;
d92 1
d95 1
d110 7
d132 1
a132 2
	}
	else {
d135 2
a136 1
		if (stat(pkg_fullname, &sb) == FAIL) {
d141 2
a142 1
		sprintf(extract_contents, "--fast-read %s", CONTENTS_FNAME);
d144 2
a145 1
		sprintf(extract_contents, "%s", CONTENTS_FNAME);
d153 1
a153 1
	    Home = make_playpen(playpen, sb.st_size * 4);
d184 4
a187 4
			if (chdir(p->name) == -1) {
			    warn("unable to change directory to `%s'", p->name);
			    goto bomb;
			}
d209 1
a209 1
		warnx("projected size of %d exceeds available free space.\n"
d212 1
a212 1
		       "free space and try again", sb.st_size * 4);
d228 1
a228 1
	}
d256 1
a256 1
    sprintf(LogDir, "%s/%s", (tmp = getenv(PKG_DBDIR)) ? tmp : DEF_LOG_DIR, PkgName);
d263 19
d284 2
d290 5
a294 2
	if (!vsystem("/usr/sbin/pkg_info -qe '%s'", p->name)) {
	    warnx("Conflicting package `%s' installed, please use pkg_delete(1)\n\t first to remove it!\n",  p->name);
d301 2
d307 2
a308 1
	if (vsystem("/usr/sbin/pkg_info -qe '%s'", p->name)) {
d313 2
d333 1
a333 20
		else
		   warnx("add of dependency `%s' failed%s",
			    p->name, Force ? " (proceeding anyway)" : "!");
		   if (!Force)
			++code;
		}
		else if ((cp = fileGetURL(pkg, p->name)) != NULL) {
		    if (Verbose)
			printf("Finished loading %s over FTP.\n", p->name);
		    if (!fexists(CONTENTS_FNAME)) {
			warnx("autoloaded package %s has no %s file?",
				p->name, CONTENTS_FNAME);
			if (!Force)
			    ++code;
		    }
		    else if (vsystem("(pwd; cat %s) | pkg_add %s%s %s-S",
                                     CONTENTS_FNAME, 
                                     Prefix ? "-p " : "",
                                     Prefix ? Prefix : "",
				     Verbose ? "-v " : "")) {
d336 42
a377 2
			if (!Force)
			    ++code;
a378 4
		    else if (Verbose)
			printf("\t`%s' loaded successfully.\n", p->name);
		    /* Nuke the temporary playpen */
		    leave_playpen(cp);
d381 1
a381 1
	    else {
d392 1
a392 1
	    printf(" - already installed.\n");
d435 2
a436 1
	    printf("mtree -U -f %s -d -e -p %s\n", MTREE_FNAME, p ? p->name : "/");
d438 3
a440 1
	    if (vsystem("/usr/sbin/mtree -U -f %s -d -e -p %s", MTREE_FNAME, p ? p->name : "/"))
d472 1
a472 1
	sprintf(LogDir, "%s/%s", (tmp = getenv(PKG_DBDIR)) ? tmp : DEF_LOG_DIR, PkgName);
d489 1
a489 1
	sprintf(contents, "%s/%s", LogDir, CONTENTS_FNAME);
d502 5
d512 18
a529 2
	    sprintf(contents, "%s/%s/%s", (tmp = getenv(PKG_DBDIR)) ? tmp : DEF_LOG_DIR,
	    	    basename_of(p->name), REQUIRED_BY_FNAME);
d557 1
a557 1
	    warn("cannot open %s as display file", buf);
@


1.4
log
@fix package input from standard input -- the program tried to process
stdin twice.  Note: it assumes stdin is a compressed tar file.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.3 1996/06/25 04:51:53 dm Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.3 1996/06/25 04:51:53 dm Exp $";
d27 1
d37 1
a74 2
    char *isTMP = NULL;
    char *cp;
d78 1
d88 1
a88 1
	    whinge("pkg_add in SLAVE mode can't chdir to %s.", playpen);
d99 1
a99 1
		whinge("Unable to fetch `%s' by URL.", pkg);
d106 3
a108 1
		whinge("Unable to open table of contents file `%s' - not a package?", CONTENTS_FNAME);
d118 1
a118 1
		    whinge("Can't stat package file '%s'.", pkg_fullname);
d128 1
a128 1
	    else
d130 2
d134 2
a135 1
		whinge("Unable to make playpen for %d bytes.\n", sb.st_size * 4);
d138 3
a140 1
		whinge("Unable to extract table of contents file from `%s' - not a package?.", pkg_fullname);
d145 3
a147 1
		whinge("Unable to open table of contents file `%s' - not a package?", CONTENTS_FNAME);
d159 1
a159 1
		    if (!isdir(p->name) && !Fake) {
d161 1
a161 1
			    printf("Desired prefix of %s does not exist, creating..\n", p->name);
d164 1
a164 2
			    whinge("Unable to change directory to `%s' - no permission?", p->name);
			    perror("chdir");
d172 3
a174 1
		    whinge("No prefix specified in `%s' - this is a bad package!", pkg_fullname);
d188 1
a188 1
		whinge("Projected size of %d exceeds available free space.\n"
d191 2
a192 2
		       "free space and try again.", sb.st_size * 4);
		whinge("Not extracting %s\ninto %s, sorry!", pkg_fullname,
d204 1
a204 1
		whinge("Unable to extract `%s'!", pkg_fullname);
d236 2
a237 4
    if (isdir(LogDir)) {
	char tmp[FILENAME_MAX];
	
	whinge("Package `%s' already recorded as installed.\n", PkgName);
d242 12
d260 1
a260 1
	if (!Fake && vsystem("pkg_info -e %s", p->name)) {
d263 20
a282 4
	    if (!Fake && !isURL(pkg) && !getenv("PKG_ADD_BASE")) {
		snprintf(path, FILENAME_MAX, "%s/%s.tgz", Home, p->name);
		if (fexists(path))
		    cp = path;
d284 6
a289 2
		    cp = fileFindByPath(pkg, p->name);
		if (cp) {
d291 4
a294 3
			printf("Loading it from %s.\n", cp);
		    if (vsystem("pkg_add %s", cp)) {
			whinge("Autoload of dependency `%s' failed%s", cp, Force ? " (proceeding anyway)" : "!");
d298 14
a313 19
	    else if (!Fake && (cp = fileGetURL(pkg, p->name)) != NULL) {
		if (Verbose)
		    printf("Finished loading %s over FTP.\n", p->name);
		if (!Fake) {
		    if (!fexists("+CONTENTS"))
			whinge("Autoloaded package %s has no +CONTENTS file?", p->name);
		    else
			if (vsystem("(pwd; cat +CONTENTS) | pkg_add %s-S", Verbose ? "-v " : "")) {
			    whinge("pkg_add of dependency `%s' failed%s",
				   p->name, Force ? " (proceeding anyway)" : "!");
			    if (!Force)
				++code;
			}
			else if (Verbose)
			    printf("\t`%s' loaded successfully.\n", p->name);
		}
		/* Nuke the temporary playpen */
		leave_playpen(cp);
	    }
d328 3
d335 1
a335 1
	    printf("Running requirements file first for %s..\n", PkgName);
d337 2
a338 2
	    whinge("Package %s fails requirements %s", pkg_fullname,
		   Force ? "installing anyway" : "- not installed.");
d350 1
a350 1
	    printf("Running install with PRE-INSTALL for %s..\n", PkgName);
d352 1
a352 1
	    whinge("Install script returned error status.");
d365 1
a365 1
	    printf("Running mtree for %s..\n", PkgName);
d371 1
a371 1
		whinge("mtree returned a non-zero status - continuing.");
d379 1
a379 1
	    printf("Running install with POST-INSTALL for %s..\n", PkgName);
d381 1
a381 1
	    whinge("Install script returned error status.");
d396 1
a396 1
	    whinge("Not running as root - trying to record install anyway.");
d398 1
a398 1
	    whinge("No package name!  Can't record package, sorry.");
d403 1
d405 1
a405 1
	    printf("Attempting to record package into %s..\n", LogDir);
d407 1
a407 1
	    whinge("Can't record package into '%s', you're on your own!",
d409 1
a409 1
	    bzero(LogDir, FILENAME_MAX);
d422 2
a423 1
	    whinge("Can't open new contents file '%s'!  Can't register pkg.", contents);
d441 2
a442 2
		whinge("Warning: Can't open dependency file '%s'!\n"
		       "\tDependency registration is incomplete.", contents);
d446 1
a446 1
		    warn("Cannot properly close file %s", contents);
d453 1
a453 1
    if (p = find_plist(&Plist, PLIST_DISPLAY)) {
d456 3
a458 1
	fp = fopen(p->name, "r");
d466 1
a466 1
	    warn("Cannot open display file `%s'.", p->name);
a489 1
    PackingList p;
d493 1
a493 1
	whinge("Package %s has no CONTENTS file!", pkg);
d497 1
a497 1
	whinge("Package %s has no COMMENT file!", pkg);
d501 1
a501 1
	whinge("Package %s has no DESC file!", pkg);
d510 15
a524 6
    if (signo)
	printf("Signal %d received, cleaning up..\n", signo);
    if (Plist.head) {
	if (!Fake)
	    delete_package(FALSE, FALSE, &Plist);
	free_plist(&Plist);
d526 2
a527 3
    if (!Fake && LogDir[0])
	vsystem("%s -rf %s", REMOVE_CMD, LogDir);
    leave_playpen(Home);
@


1.3
log
@our tar has no --fast-read
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.2 1996/06/04 08:43:34 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.2 1996/06/04 08:43:34 niklas Exp $";
d171 3
a173 1
	     * compress an average of 75%, so multiply by 4 for good measure.
d176 1
a176 1
	    if (!inPlace && min_free(playpen) < sb.st_size * 4) {
d178 2
a179 1
		       "Please set your PKG_TMPDIR variable to point to a location with more\n"
d181 2
a182 1
		whinge("Not extracting %s\ninto %s, sorry!", pkg_fullname, where_to);
d190 3
a192 2
	    /* Finally unpack the whole mess */
	    if (unpack(pkg_fullname, NULL)) {
@


1.2
log
@Oops, screwed up the $OpenBSD$ IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.1 1996/06/04 07:56:04 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.1 1996/06/04 07:56:04 niklas Exp $";
d118 1
d120 3
@


1.1
log
@add package tools from FreeBSD
@
text
@d1 2
a2 1
#	$OpenBSD$
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.33 1996/03/12 06:12:37 jkh Exp $";
@
