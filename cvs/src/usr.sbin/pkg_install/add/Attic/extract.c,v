head	1.17;
access;
symbols
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.12.0.10
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.8
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.6
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2004.05.28.20.15.48;	author brad;	state dead;
branches;
next	1.16;

1.16
date	2003.07.04.17.31.19;	author avsm;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.04.17.23.15;	author avsm;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.05.18.04.00;	author avsm;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.03.19.42.53;	author avsm;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.08.16.45.46;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.04.23.22.14;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.26.15.32.28;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.24.00.20.04;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	99.07.26.14.40.07;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	98.10.13.23.09.49;	author marc;	state Exp;
branches;
next	1.6;

1.6
date	98.09.07.22.30.13;	author marc;	state Exp;
branches;
next	1.5;

1.5
date	98.06.23.23.17.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.01.23.01.15.37;	author gene;	state Exp;
branches;
next	1.3;

1.3
date	98.01.14.13.20.50;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.06.04.08.43.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.04.07.56.03;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.17
log
@bye bye old package tools.

ok deraadt@@
@
text
@/*	$OpenBSD: extract.c,v 1.16 2003/07/04 17:31:19 avsm Exp $	*/

#ifndef lint
static const char rcsid[] = "$OpenBSD: extract.c,v 1.16 2003/07/04 17:31:19 avsm Exp $";
#endif

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 18 July 1993
 *
 * This is the package extraction code for the add module.
 *
 */

#include <err.h>
#include "lib.h"
#include "add.h"


#define STARTSTRING "tar cf - "
#define TOOBIG(str) ((strlen(str) + FILENAME_MAX + where_count > maxargs) \
		|| (strlen(str) + FILENAME_MAX + perm_count > maxargs))

#define PUSHOUT(todir) /* push out string */				\
        if (where_count > sizeof(STARTSTRING)-1) {			\
		    strlcat(where_args, "|tar xpf - -C ", maxargs);	\
		    strlcat(where_args, todir, maxargs);		\
		    if (system(where_args)) {				\
			cleanup(0);					\
			errx(2, "can not invoke %lu byte tar pipeline: %s", \
				(u_long)strlen(where_args), where_args); \
		    }							\
		    strlcpy(where_args, STARTSTRING, maxargs);		\
		    where_count = sizeof(STARTSTRING)-1;		\
	}								\
	if (perm_count) {						\
		    apply_perms(todir, perm_args);			\
		    perm_args[0] = 0;					\
		    perm_count = 0;					\
	}

static void
rollback(char *name, char *home, plist_t *start, plist_t *stop)
{
    plist_t *q;
    char try[FILENAME_MAX], bup[FILENAME_MAX], *dir;

    dir = home;
    for (q = start; q != stop; q = q->next) {
	if (q->type == PLIST_FILE) {
	    snprintf(try, sizeof(try), "%s/%s", dir, q->name);
	    if (make_preserve_name(bup, sizeof(bup), name, try) && fexists(bup)) {
		(void)chflags(try, 0);
		(void)unlink(try);
		if (rename(bup, try))
		    pwarnx("rollback: unable to rename %s back to %s", bup, try);
	    }
	}
	else if (q->type == PLIST_CWD) {
	    if (strcmp(q->name, "."))
		dir = q->name;
	    else
		dir = home;
	}
    }
}

static int 
preserve(const char *fname) 
{
    char copy[FILENAME_MAX];
    int i;

    for (i = 0; i < 50; i++) {
    	snprintf(copy, sizeof(copy), "%s-%d", fname, i);
	if (fexists(copy))
		continue;
	if (rename(fname, copy) == 0) {
		pwarnx("conflict: renamed existing %s to %s", fname, copy);
		return 0;
	}
    }
    return -1;
}

void
extract_plist(char *home, package_t *pkg)
{
    plist_t *p = pkg->head;
    char *last_file;
    char *where_args, *perm_args, *last_chdir;
    int maxargs, where_count = 0, perm_count = 0, add_count;

    maxargs = sysconf(_SC_ARG_MAX) / 2;	/* Just use half the argument space */
    where_args = alloca(maxargs);
    if (!where_args) {
	cleanup(0);
	errx(2, "can't get argument list space");
    }
    perm_args = alloca(maxargs);
    if (!perm_args) {
	cleanup(0);
	errx(2, "can't get argument list space");
    }
    strlcpy(where_args, STARTSTRING, maxargs);
    where_count = sizeof(STARTSTRING)-1;
    perm_args[0] = 0;

    last_chdir = 0;

    /* Reset the world */
    Owner = NULL;
    Group = NULL;
    Mode = NULL;
    last_file = NULL;
    Directory = home;

    /* Do it */
    while (p) {
	char cmd[FILENAME_MAX];

	switch(p->type) {
	case PLIST_NAME:
	    PkgName = p->name;
	    if (Verbose)
		printf("extract: Package name is %s\n", p->name);
	    break;

	case PLIST_FILE:
	    last_file = p->name;
	    if (Verbose)
		printf("extract: %s/%s\n", Directory, p->name);
	    if (!Fake) {
		char try[FILENAME_MAX];

		if (strrchr(p->name,'\'')) {
		  cleanup(0);
		  errx(2, "Bogus filename \"%s\"", p->name);
		}
		
		/* first try to rename it into place */
		snprintf(try, sizeof(try), "%s/%s", Directory, p->name);
		if (fexists(try)) {
		    if (preserve(try) == -1) {
		    	pwarnx("unable to back up %s, aborting pkg_add", try);
			rollback(PkgName, home, pkg->head, p);
			return;
		    }
		}
		if (rename(p->name, try) == 0) {
		    /* try to add to list of perms to be changed and run in bulk. */
		    if (p->name[0] == '/' || TOOBIG(p->name)) {
			PUSHOUT(Directory);
		    }
		    add_count = snprintf(&perm_args[perm_count], maxargs - perm_count, "'%s' ", p->name);
		    if (add_count > maxargs - perm_count) {
			cleanup(0);
			errx(2, "oops, miscounted strings!");
		    }
		    perm_count += add_count;
		} else {
		    /* rename failed, try copying with a big tar command */
		    if (last_chdir != Directory) {
			PUSHOUT(last_chdir);
			last_chdir = Directory;
		    }
		    else if (p->name[0] == '/' || TOOBIG(p->name)) {
			PUSHOUT(Directory);
		    }
		    add_count = snprintf(&where_args[where_count], maxargs - where_count, " '%s'", p->name);
		    if (add_count > maxargs - where_count) {
			cleanup(0);
			errx(2, "oops, miscounted strings!");
		    }
		    where_count += add_count;
		    add_count = snprintf(&perm_args[perm_count],
					 maxargs - perm_count,
					 "'%s' ", p->name);
		    if (add_count > maxargs - perm_count) {
			cleanup(0);
			errx(2, "oops, miscounted strings!");
		    }
		    perm_count += add_count;
		}
	    }
	    break;

	case PLIST_CWD:
	    if (Verbose)
		printf("extract: CWD to %s\n", p->name);
	    PUSHOUT(Directory);
	    if (strcmp(p->name, ".")) {
		if (!Fake && make_hierarchy(p->name) == FAIL) {
		    cleanup(0);
		    errx(2, "unable to make directory '%s'", p->name);
		}
		Directory = p->name;
	    } else
		Directory = home;
	    break;

	case PLIST_CMD:
	    if (!format_cmd(cmd, sizeof(cmd), p->name, Directory, last_file)) {
		cleanup(0);
		if (last_file == NULL)
		    errx(2, "no last file specified for '%s' command", p->name);
		else 
		    errx(2, "'%s' command could not expand", p->name);
	    }
	    
	    PUSHOUT(Directory);
	    if (Verbose)
		printf("extract: execute '%s'\n", cmd);
	    if (!Fake && system(cmd))
		pwarnx("command '%s' failed", cmd);
	    break;

	case PLIST_CHMOD:
	    PUSHOUT(Directory);
	    Mode = p->name;
	    break;

	case PLIST_CHOWN:
	    PUSHOUT(Directory);
	    Owner = p->name;
	    break;

	case PLIST_CHGRP:
	    PUSHOUT(Directory);
	    Group = p->name;
	    break;

	case PLIST_COMMENT:
	    break;

	case PLIST_IGNORE:
	    p = p->next;
	    break;

	default:
	    break;
	}
	p = p->next;
    }
    PUSHOUT(Directory);
}
@


1.16
log
@'static const char rcsid[]' to make it -Wall clean
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.15 2003/07/04 17:23:15 avsm Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: extract.c,v 1.15 2003/07/04 17:23:15 avsm Exp $";
@


1.15
log
@- use sizeof(var) instead of hardcoding length in functions that need it
- krw@@ rewrote make_preserve_name() to get rid of some hard to read string code
- some trivial strn{cpy,cat} - > strl{cpy,cat} conversions
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.14 2003/04/05 18:04:00 avsm Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.14 2003/04/05 18:04:00 avsm Exp $";
@


1.14
log
@use sizeof for snprintf size arg for static buffers instead of duplicating
the size value; rohee@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.13 2003/04/03 19:42:53 avsm Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.13 2003/04/03 19:42:53 avsm Exp $";
d64 1
a64 1
	    if (make_preserve_name(bup, FILENAME_MAX, name, try) && fexists(bup)) {
@


1.13
log
@some strcpy/strcat -> strlcpy/strlcat conversions
ok hin@@, ho@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.12 2001/04/08 16:45:46 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.12 2001/04/08 16:45:46 espie Exp $";
d63 1
a63 1
	    snprintf(try, FILENAME_MAX, "%s/%s", dir, q->name);
d154 1
a154 1
		snprintf(try, FILENAME_MAX, "%s/%s", Directory, p->name);
@


1.12
log
@Better error messages: pwarnx function, which works like pwarn, except
it shows a current package name along with the program name, e.g.,
pkg_add(foo-3.0): some error occurred.

A few messages now bear redundant pkgnames, which is much better than
doing pkg_add * and being informed that something went slightly wrong
somewhere...
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.11 2000/07/04 23:22:14 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.11 2000/07/04 23:22:14 espie Exp $";
d38 2
a39 2
		    strcat(where_args, "|tar xpf - -C ");		\
		    strcat(where_args, todir);				\
d45 1
a45 1
		    strcpy(where_args, STARTSTRING);			\
d117 1
a117 1
    strcpy(where_args, STARTSTRING);
@


1.11
log
@Fix stupid bug in extraction through playpen.
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.10 2000/04/26 15:32:28 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.10 2000/04/26 15:32:28 espie Exp $";
d68 1
a68 1
		    warnx("rollback: unable to rename %s back to %s", bup, try);
d91 1
a91 1
		warnx("conflict: renamed existing %s to %s", fname, copy);
d157 1
a157 1
		    	warnx("unable to back up %s, aborting pkg_add", try);
d227 1
a227 1
		warnx("command '%s' failed", cmd);
@


1.10
log
@Don't ever let pkg_add destroy existing files.
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.9 2000/03/24 00:20:04 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.9 2000/03/24 00:20:04 espie Exp $";
d38 1
a38 1
		    strcat(where_args, "|tar xf - -C ");		\
@


1.9
log
@Handle expansion sequences in @@exec better (let the expander decide whether
it needs a file name instead of assuming we always need one).

Sent to *quite a few* people, comments by drahn@@... guys, wake up !!!
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.8 1999/07/26 14:40:07 aaron Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.8 1999/07/26 14:40:07 aaron Exp $";
d80 18
a104 1
    Boolean preserve;
a121 1
    preserve = find_plist_option(pkg, "preserve") ? TRUE : FALSE;
d156 4
a159 13
		    (void)chflags(try, 0);	/* XXX hack - if truly immutable, rename fails */
		    if (preserve && PkgName) {
			char pf[FILENAME_MAX];

			if (make_preserve_name(pf, FILENAME_MAX, PkgName, try)) {
			    if (rename(try, pf)) {
				warnx(
				"unable to back up %s to %s, aborting pkg_add",
				try, pf);
				rollback(PkgName, home, pkg->head, p);
				return;
			    }
			}
@


1.8
log
@buf oflow fix from FreeBSD; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.7 1998/10/13 23:09:49 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.7 1998/10/13 23:09:49 marc Exp $";
d208 1
a208 1
	    if (last_file == NULL) {
d210 4
a213 1
		errx(2, "no last file specified for '%s' command", p->name);
d215 1
a215 1
	    format_cmd(cmd, sizeof(cmd), p->name, Directory, last_file);
@


1.7
log
@Sync with recent NetBSD changes:
- use snprintf in place of sprintf
- code cleanup
- Package -> package_t, PackingList -> plist_t
Also: remove files that haven't been linked in a while
Pass -q to mtree so it is quiet in the presence of symlinks
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.6 1998/09/07 22:30:13 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.6 1998/09/07 22:30:13 marc Exp $";
d33 2
a34 2
#define TOOBIG(str) ((strlen(str) + 22 + strlen(home) + where_count > maxargs) \
		|| (strlen(str) + 6 + strlen(home) + perm_count > maxargs))
@


1.6
log
@updated pkg_* tools.  Merged in many changes/improvements from NetBSD.
New features include md5 hash so pkg_delete won't remove files that have
changed and the ability to define conflicting packages, e.g. you can't
install both mh and nmh.  The ports tree will have to be updated to take
advantage of this.

Let me know of any problems, real or imagined :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.5 1998/06/23 23:17:16 millert Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.5 1998/06/23 23:17:16 millert Exp $";
d36 16
a51 14
#define PUSHOUT(todir) /* push out string */ \
        if (where_count > sizeof(STARTSTRING)-1) { \
		    strcat(where_args, "|tar xf - -C "); \
		    strcat(where_args, todir); \
		    if (system(where_args)) \
	cleanup(0), errx(2, "can not invoke %lu byte tar pipeline: %s", \
			(u_long)strlen(where_args), where_args); \
		    strcpy(where_args, STARTSTRING); \
		    where_count = sizeof(STARTSTRING)-1; \
	} \
	if (perm_count) { \
		    if (!isdir(todir)) apply_perms(todir, perm_args); \
		    perm_args[0] = 0;\
		    perm_count = 0; \
d55 1
a55 1
rollback(char *name, char *home, PackingList start, PackingList stop)
d57 1
a57 1
    PackingList q;
d81 1
a81 1
extract_plist(char *home, Package *pkg)
d83 1
a83 1
    PackingList p = pkg->head;
d91 4
a94 2
    if (!where_args)
	cleanup(0), errx(2, "can't get argument list space");
d96 4
a99 3
    if (!perm_args)
	cleanup(0), errx(2, "can't get argument list space");

d132 4
a135 2
		if (strrchr(p->name,'\''))
		  cleanup(0), errx(2, "Bogus filename \"%s\"", p->name);
d161 4
a164 2
		    if (add_count > maxargs - perm_count)
			cleanup(0), errx(2, "oops, miscounted strings!");
d166 1
a166 2
		}
		else {
d176 4
a179 2
		    if (add_count > maxargs - where_count)
			cleanup(0), errx(2, "oops, miscounted strings!");
d184 4
a187 2
		    if (add_count > maxargs - perm_count)
			cleanup(0), errx(2, "oops, miscounted strings!");
d198 4
a201 3
		if (!Fake && make_hierarchy(p->name) == FAIL)
		    cleanup(0), errx(2, "unable to make directory '%s'",
					p->name);
d203 1
a203 2
	    }
	    else
d208 5
a212 4
	    if (last_file == NULL)
		cleanup(0), errx(2, "no last file specified for '%s' command",
					p->name);
	    format_cmd(cmd, p->name, Directory, last_file);
@


1.5
log
@Fix snprintf return value usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.4 1998/01/23 01:15:37 gene Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.4 1998/01/23 01:15:37 gene Exp $";
d27 1
d32 2
a33 2
#define STARTSTRING "tar cf -"
#define TOOBIG(str) ((strlen(str) + 6 + strlen(home) + where_count > maxargs) \
d37 2
a38 2
	if (strlen(where_args) > sizeof(STARTSTRING)-1) { \
		    strcat(where_args, "|tar xpf - -C "); \
d41 2
a42 1
			barf("can't invoke tar pipeline"); \
d52 26
d85 1
d87 2
a88 4
    maxargs = sysconf(_SC_ARG_MAX);
    maxargs -= 64;			/* some slop for the tar cmd text,
					   and sh -c */
    where_args = malloc(maxargs);
d90 2
a91 2
	barf("can't get argument list space");
    perm_args = malloc(maxargs);
d93 1
a93 1
	barf("can't get argument list space");
d100 1
d127 3
d131 17
a147 1
		sprintf(try, "%s/%s", Directory, p->name);
d149 2
a150 9
		    /* try to add to list of perms to be changed,
		       and run in bulk. */
		    add_count = snprintf(&perm_args[perm_count],
					 maxargs - perm_count,
					 "'%s' ", p->name);
		    if (add_count >= maxargs - perm_count)
			barf("oops, miscounted strings!");
		    perm_count += add_count;
		    if (p->name[0] == '/') {
d153 6
a158 1
		} else {
d160 1
a160 3
		    if (p->name[0] == '/' ||
			TOOBIG(p->name) ||
			last_chdir != Directory) {
d164 6
a169 5
		    add_count = snprintf(&where_args[where_count],
					 maxargs - where_count,
					 " %s", p->name);
		    if (add_count >= maxargs - where_count)
			barf("oops, miscounted strings!");
d174 2
a175 2
		    if (add_count >= maxargs - perm_count)
			barf("oops, miscounted strings!");
a176 3
		    if (p->name[0] == '/') {
			PUSHOUT(Directory);
		    }
d187 2
a188 1
		    barf("Unable make directory '%s'.", p->name);
d196 3
d204 1
a204 1
		whinge("Command '%s' failed.", cmd);
d227 3
@


1.4
log
@Inspired by hubertf@@netbsd:
Quote filenames passed to different extract commands preventing
certain security risks.
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.3 1998/01/14 13:20:50 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.3 1998/01/14 13:20:50 niklas Exp $";
d107 1
a107 1
		    if (add_count > maxargs - perm_count)
d124 1
a124 1
		    if (add_count > maxargs - where_count)
d130 1
a130 1
		    if (add_count > maxargs - perm_count)
@


1.3
log
@feed tar the -p option to retain set[ug]id bits, this was due
to the fact that GNU tar retatins the bits when run as root, but paxtar does
not, and we use the latter.
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.2 1996/06/04 08:43:32 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.2 1996/06/04 08:43:32 niklas Exp $";
d106 1
a106 1
					 "%s ", p->name);
d129 1
a129 1
					 "%s ", p->name);
@


1.2
log
@Oops, screwed up the $OpenBSD$ IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: extract.c,v 1.1 1996/06/04 07:56:03 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.1 1996/06/04 07:56:03 niklas Exp $";
d37 1
a37 1
		    strcat(where_args, "|tar xf - -C "); \
@


1.1
log
@add package tools from FreeBSD
@
text
@d1 2
a2 1
#	$OpenBSD$
d4 1
a4 1
static const char *rcsid = "$OpenBSD: extract.c,v 1.7 1995/05/19 22:40:54 jkh Exp $";
@
