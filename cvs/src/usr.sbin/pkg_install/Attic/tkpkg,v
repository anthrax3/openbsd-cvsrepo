head	1.5;
access;
symbols
	OPENBSD_3_5:1.4.0.14
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.12
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.10
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.10
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.8
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.1.0.8
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.6
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@# @;


1.5
date	2004.05.28.20.18.28;	author brad;	state dead;
branches;
next	1.4;

1.4
date	2001.02.27.17.59.48;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	98.10.13.23.09.48;	author marc;	state Exp;
branches;
next	1.2;

1.2
date	98.09.07.22.30.12;	author marc;	state Exp;
branches;
next	1.1;

1.1
date	96.06.04.07.56.02;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.5
log
@cvs really sucks.
@
text
@#!/usr/local/bin/wish8.3 -f
#$OpenBSD: tkpkg,v 1.4 2001/02/27 17:59:48 todd Exp $
# from FreeBSD Id: tkpkg,v 1.4 1997/02/22 16:09:13 peter Exp
#
set pkgname ""
wm title . "Package Installation"
#--------------------------------------------------------------
# The top level main window, consisting of a bar of buttons and a list
# of packages and a description of the current package.
#--------------------------------------------------------------
frame .menu -relief raised -borderwidth 1
frame .frame -borderwidth 4

scrollbar .frame.scroll -relief sunken -command ".frame.list yview"
listbox .frame.list -yscroll ".frame.scroll set" -relief sunken -setgrid 1
pack append .frame .frame.scroll {right filly} \
        .frame.list {left expand fill}

# build the lower window shoing the complete description of a pacage
frame .f -borderwidth 4
text .f.t -width 80 -height 20 -yscrollcommand ".f.s set" -relief sunken

# Initially display instructions in this window.  Erase the
# instructions and show the package description when the user clicks
# on a package.
# 
.f.t insert end "Double click on a package above to see its
complete description here."
scrollbar .f.s -relief sunken -command ".f.t yview"
pack append .f .f.s {right filly} .f.t {left expand fill}

bind .frame.list <Double-Button-1> \
    { do_description [selection get] }
pack append .  .menu {top fill} \
   .f {bottom expand fill} \
   .frame {bottom expand fill}

#----------------------------------------------------------------
# Make menu bar:
#----------------------------------------------------------------
button .menu.inst -text "Install" \
   -command "apply_to_pkg \"pkg_add -v\""
button .menu.dein -text "Deinstall" \
   -command "apply_to_pkg \"pkg_delete -v\""
button .menu.installed -text "What is Installed?" \
   -command "list_pkgs \"pkg_info -I -a |tr '	' ' '\""
button .menu.available -text "What can I install?" \
   -command "list_pkgs \"pkg_info -I -c [glob -nocomplain *.{tgz,tar.z,tar.gz,tar.Z}] |tr '	' ' '\""
button .menu.cont -text "Contents?" \
   -command "apply_to_pkg \"pkg_info -d -v\""
button .menu.quit -text "Quit" -command "destroy ."
button .menu.help -text "Help" -command "do_help"

pack append .menu \
  .menu.inst left \
  .menu.dein left \
  .menu.installed left \
  .menu.available left \
  .menu.cont left \
  .menu.quit left \
  .menu.help right
#-------------------------------------------------------
# Display the package description.
#-------------------------------------------------------
proc list_pkgs {s} {
  set line ""
  set f [eval "open {| sh -c \"$s\" } r"]
  .frame.list delete 0 end
  while {[gets $f line] > 0} {
    .frame.list insert end $line
  }
  close $f
}

# display the list of available packages
set archives [glob -nocomplain *.{tgz,tar.z,tar.gz,tar.Z}]
if {$archives == ""} {
  .frame.list delete 0 end
 .frame.list insert end "Warning: no compressed tar archives files found."
} else {
  list_pkgs "pkg_info -I -c $archives |tr '	' ' '"
}

#-------------------------------------------------------
# Display the package description.
#-------------------------------------------------------
proc do_description {s} {
  global pkgname
  regexp {[^ 	]*} $s filename
  set pkgname $filename
  .f.t delete 0.0 end
  set cmd "pkg_info -d $filename |tr -d ''"
  set f [eval "open {| csh -c \"$cmd\" } r"]
  while {![eof $f]} {
    .f.t insert end [read $f]
  }
}
#-------------------------------------------------------
# package install window.
#-------------------------------------------------------
proc do_help {{w .help}} {
  catch {destroy $w}
  toplevel $w
  wm title $w "Help"
  wm iconname $w "Help"
  button $w.ok -text OK -command "destroy $w"
  message $w.t -relief raised -bd 2 \
    -text "You can install, deinstall and list info on the available packages.  To select a package and see its complete description, press mouse button 1 over the package name.  To install a selected package, press the Install button.  To exit, press the \"Quit\" button."
  pack append $w $w.ok {bottom fillx} $w.t {expand fill}
}
#-------------------------------------------------------
# Apply a command to a package.
#-------------------------------------------------------
proc apply_to_pkg {s} {
    apply_to_pkg_err $s ""
}
#-------------------------------------------------------
# Apply a command to a package, with error stream redirection instructions.
#-------------------------------------------------------
proc apply_to_pkg_err {s errredir} {
  global pkgname
  .f.t delete 0.0 end
  if {$pkgname == ""} {
    .f.t insert end "You must double click on a package name first!"
  } else {
    apply_to_pkg_int "$s $pkgname" "2>&1"
  }
}
proc apply_to_pkg_int {s errredir} {
    .f.t delete 0.0 end
    .f.t insert end "Running: $s\n"
    set f [eval "open {| sh -c \"$s $errredir\" } r"]
    while {![eof $f]} {
      .f.t insert end [read $f 64]
    }
}
#-------------------------------------------------------
# Invoke an arbitrary command.
#-------------------------------------------------------
proc do_command {s} {
  .f.t delete 0.0 end
  .f.t insert end "Running: $s\n"
  set f [eval "open {| $s} r"]
  while {![eof $f]} {
    .f.t insert end [read $f 64]
  }
}
# local variables:
# mode: csh
# compile-command: ""
# comment-start: "# "
# comment-start-skip: "# "
# end:
@


1.4
log
@tweak for working with wish8.3
@
text
@d2 1
a2 1
#$OpenBSD: tkpkg,v 1.2 1998/09/07 22:30:12 marc Exp $
@


1.3
log
@Sync with recent NetBSD changes:
- use snprintf in place of sprintf
- code cleanup
- Package -> package_t, PackingList -> plist_t
Also: remove files that haven't been linked in a while
Pass -q to mtree so it is quiet in the presence of symlinks
@
text
@d1 1
a1 1
#!/usr/local/bin/wish -f
@


1.2
log
@updated pkg_* tools.  Merged in many changes/improvements from NetBSD.
New features include md5 hash so pkg_delete won't remove files that have
changed and the ability to define conflicting packages, e.g. you can't
install both mh and nmh.  The ports tree will have to be updated to take
advantage of this.

Let me know of any problems, real or imagined :-)
@
text
@d2 1
a2 1
#$OpenBSD: tkpkg,v 1.1 1996/06/04 07:56:02 niklas Exp $
a3 1
#
@


1.1
log
@add package tools from FreeBSD
@
text
@d2 2
a3 25
#$OpenBSD: tkpkg,v 1.2 1994/12/06 00:51:21 jkh Exp $
#
#$Log: tkpkg,v $
#Revision 1.2  1994/12/06 00:51:21  jkh
#Many of John T. Kohl's patches from NetBSD.  Thanks, John!
#Submitted by:	jkohl
#
# Revision 1.1  1994/01/06  08:16:20  jkh
# Cleaning house.
#
# Revision 1.1  1993/09/04  17:06:09  jkh
# Added Rich's wish front-end.
#
# Revision 1.6  1993/09/03  23:37:22  rich
# warn user if no tar archives are found in the current directory.
# removed the revision string from the lower text frame.
#
# Revision 1.5  1993/09/03  15:48:04  rich
# glob for .tar.gz, .tar.z and .tar.Z looking for archives
#
# Revision 1.4  1993/08/28  15:53:59  rich
# added version and date info to lower text window.
#
# Revision 1.3  1993/08/28  15:47:12  rich
# filtered out ^Ls in pkg_* output.
d34 1
a34 1
    {foreach i [selection get] {do_description $i}}
@

