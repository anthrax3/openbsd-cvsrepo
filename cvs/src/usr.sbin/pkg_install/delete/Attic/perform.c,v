head	1.17;
access;
symbols
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2004.05.28.20.15.48;	author brad;	state dead;
branches;
next	1.16;

1.16
date	2003.08.21.20.24.56;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.01.08.56.01;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.04.17.31.19;	author avsm;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.02.00.41.15;	author avsm;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.04.08.56.01;	author avsm;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.26.05.04.33;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.17.21.51.33;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.08.16.45.47;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.28.21.08.16;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.24.00.21.28;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	99.10.09.20.35.45;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	98.10.13.23.09.50;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	98.09.07.22.30.15;	author marc;	state Exp;
branches;
next	1.3;

1.3
date	97.06.17.08.38.03;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.04.08.43.38;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.04.07.56.08;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.17
log
@bye bye old package tools.

ok deraadt@@
@
text
@/*	$OpenBSD: perform.c,v 1.16 2003/08/21 20:24:56 espie Exp $	*/

#ifndef lint
static const char rcsid[] = "$OpenBSD: perform.c,v 1.16 2003/08/21 20:24:56 espie Exp $";
#endif

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 18 July 1993
 *
 * This is the main body of the delete module.
 *
 */

#include <sys/param.h>
#include <sys/mount.h>
#include <err.h>
#include "lib.h"
#include "delete.h"

static int pkg_do(char *);
static void sanity_check(char *);
static int undepend(const char *, char *, int);
static char LogDir[FILENAME_MAX];
extern Boolean CleanConf;


int
pkg_perform(char **pkgs)
{
    int i, err_cnt = 0;

    for (i = 0; pkgs[i]; i++)
	err_cnt += pkg_do(pkgs[i]);
    return err_cnt;
}

static package_t Plist;

static int
trim_end(char *name)
{
   size_t n, m;
   n = strlen(name);
   m = strlen(".tgz");
   if (n > m && strcmp(name+n-m, ".tgz") == 0) {
	name[n-m] = 0;
	return 1;
   }
   m = strlen(".tar.gz");
   if (n > m && strcmp(name+n-m, ".tar.gz") == 0) {
	name[n-m] = 0;
	return 1;
   }
   m = strlen(".tar");
   if (n > m && strcmp(name+n-m, ".tar") == 0) {
	name[n-m] = 0;
	return 1;
   }
   return 0;
}

/* remove all links to the package as well */
static void
delete_pkg_links(const char *dir, const char *pkg)
{
    int base;
    int len;
    DIR *d;
    struct dirent *dp;
    struct stat sb;
    char name[FILENAME_MAX+1];

    base = open(".", O_RDONLY);
    if (base == -1)
    	return;
    if (chdir(dir) == -1) {
    	close(base);
	return;
    }
    d = opendir(".");
    if (d == NULL) {
    	fchdir(base);
	close(base);
	return;
    }
    while ((dp = readdir(d)) != NULL) {
    	if (lstat(dp->d_name, &sb) == -1 || !S_ISLNK(sb.st_mode))
	    continue;
	len = readlink(dp->d_name, name, FILENAME_MAX);
	if (len == -1)
	    continue;
	name[len] = 0;
	if (strcmp(name, pkg))
	    continue;
	unlink(dp->d_name);
    }
    closedir(d);
    fchdir(base);
    close(base);
}

/* This is seriously ugly code following.  Written very fast! */
static int
pkg_do(char *pkg)
{
    FILE *cfile;
    char home[FILENAME_MAX];
    plist_t *p;
    char *dbdir;

    set_pkg(pkg);
    /* Reset some state */
    if (Plist.head)
	free_plist(&Plist);

    dbdir = getenv(PKG_DBDIR);
    if (!dbdir)
	dbdir = DEF_LOG_DIR;
try_again:
    (void) snprintf(LogDir, sizeof(LogDir), "%s/%s", dbdir, pkg);
    if (!fexists(LogDir)) {
	if (trim_end(pkg))
	    goto try_again;
	else {
	    pwarnx("no such package installed");
	    return 1;
	}
    }
    if (!getcwd(home, FILENAME_MAX)) {
	cleanup(0);
	errx(2, "unable to get current working directory!");
    }
    if (chdir(LogDir) == FAIL) {
	pwarnx("unable to change directory to %s! deinstall failed", LogDir);
	return 1;
    }
    if (!isemptyfile(REQUIRED_BY_FNAME)) {
	char buf[512];
	pwarnx("package `%s' is required by these other packages\n"
		"and may not be deinstalled%s:",
		pkg, Force ? " (but I'll delete it anyway)" : "" );
	cfile = fopen(REQUIRED_BY_FNAME, "r");
	if (cfile) {
	    while (fgets(buf, sizeof(buf), cfile))
		fprintf(stderr, "%s", buf);
	    fclose(cfile);
	} else
	    pwarnx("cannot open requirements file `%s'", REQUIRED_BY_FNAME);
	if (!Force)
	    return 1;
    }
    sanity_check(LogDir);
    cfile = fopen(CONTENTS_FNAME, "r");
    if (!cfile) {
	pwarnx("unable to open '%s' file", CONTENTS_FNAME);
	return 1;
    }
    /* If we have a prefix, add it now */
    if (Prefix)
	add_plist(&Plist, PLIST_CWD, Prefix);
    read_plist(&Plist, cfile);
    fclose(cfile);
    p = find_plist(&Plist, PLIST_CWD);
    if (!p) {
	pwarnx("package '%s' doesn't have a prefix", pkg);
	return 1;
    }
    {
	struct statfs buffer;

	if (statfs(p->name, &buffer) == -1) {
	    pwarnx("package '%s' prefix (%s) does not exist", pkg, p->name);
	    return 1;
	}
	if (buffer.f_flags & MNT_RDONLY) {
	    pwarnx("package'%s' mount point %s is read-only", pkg,
		buffer.f_mntonname);
	    return 1;
	}
    }

    setenv(PKG_PREFIX_VNAME, p->name, 1);
    setenv("PKG_DELETE_EXTRA", (CleanConf ? "Yes" : "No"), 1);
    if (fexists(REQUIRE_FNAME)) {
	if (Verbose)
	    printf("Executing 'require' script.\n");
	vsystem("chmod +x %s", REQUIRE_FNAME);	/* be sure */
	if (vsystem("./%s %s DEINSTALL", REQUIRE_FNAME, pkg)) {
	    pwarnx("package %s fails requirements %s", pkg,
		   Force ? "" : "- not deleted");
	    if (!Force)
		return 1;
	}
    }
    if (!NoDeInstall && fexists(DEINSTALL_FNAME)) {
	if (Fake)
	    printf("Would execute de-install script at this point.\n");
	else {
	    vsystem("chmod +x %s", DEINSTALL_FNAME);	/* make sure */
	    if (vsystem("./%s %s DEINSTALL", DEINSTALL_FNAME, pkg)) {
		pwarnx("deinstall script returned error status");
		if (!Force)
		    return 1;
	    }
	}
    }
    if (chdir(home) == FAIL) {
	cleanup(0);
	errx(2, "Toto! This doesn't look like Kansas anymore!");
    }
    if (!Fake) {
	/* Some packages aren't packed right, so we need to just ignore delete_package()'s status.  Ugh! :-( */
	if (delete_package(FALSE, CleanDirs, CleanConf, CheckMD5, &Plist) == FAIL)
	    pwarnx(
	"couldn't entirely delete package (perhaps the packing list is\n"
	"incorrectly specified?)");
	if (vsystem("%s -r %s", REMOVE_CMD, LogDir)) {
	    pwarnx("couldn't remove log entry in %s, deinstall failed", LogDir);
	    if (!Force)
		return 1;
	}
	delete_pkg_links(dbdir, pkg);
    }
    for (p = Plist.head; p ; p = p->next) {
	if (p->type != PLIST_PKGDEP)
	    continue;
	if (Verbose)
	    printf("Attempting to remove dependency on package `%s'\n", p->name);
	if (!Fake)
	    findmatchingname(dbdir, p->name, undepend, pkg, 0);
    }
    return 0;
}

static void
sanity_check(char *pkg)
{
    if (!fexists(CONTENTS_FNAME)) {
	cleanup(0);
	errx(2, "installed package %s has no %s file!", pkg, CONTENTS_FNAME);
    }
}

void
cleanup(int sig)
{
    exit(1);
}

/* deppkgname is the pkg from which's +REQUIRED_BY file we are
 * about to remove pkg2delname. This function is called from
 * findmatchingname(), deppkgname is expanded from a (possible) pattern.
 */
int
undepend(const char *deppkgname, char *pkg2delname, int unused)
{
     char fname[FILENAME_MAX], ftmp[FILENAME_MAX];
     char fbuf[FILENAME_MAX];
     FILE *fp, *fpwr;
     char *tmp;
     int s;

     (void) snprintf(fname, sizeof(fname), "%s/%s/%s",
	     (tmp = getenv(PKG_DBDIR)) ? tmp : DEF_LOG_DIR,
	     deppkgname, REQUIRED_BY_FNAME);
     fp = fopen(fname, "r");
     if (fp == NULL) {
	 pwarnx("couldn't open dependency file `%s'", fname);
	 return 0;
     }
     (void) snprintf(ftmp, sizeof(ftmp), "%s.XXXXXXXXXX", fname);
     s = mkstemp(ftmp);
     if (s == -1) {
	 fclose(fp);
	 pwarnx("couldn't open temp file `%s'", ftmp);
	 return 0;
     }
     fpwr = fdopen(s, "w");
     if (fpwr == NULL) {
	 close(s);
	 fclose(fp);
	 pwarnx("couldn't fdopen temp file `%s'", ftmp);
	 remove(ftmp);
	 return 0;
     }
     while (fgets(fbuf, sizeof(fbuf), fp) != NULL) {
	 if (fbuf[strlen(fbuf)-1] == '\n')
	     fbuf[strlen(fbuf)-1] = '\0';
	 if (strcmp(fbuf, pkg2delname))		/* no match */
	     fputs(fbuf, fpwr), putc('\n', fpwr);
     }
     (void) fclose(fp);
     if (fchmod(s, 0644) == FAIL) {
	 pwarnx("error changing permission of temp file `%s'", ftmp);
	 fclose(fpwr);
	 remove(ftmp);
	 return 0;
     }
     if (fclose(fpwr) == EOF) {
	 pwarnx("error closing temp file `%s'", ftmp);
	 remove(ftmp);
	 return 0;
     }
     if (rename(ftmp, fname) == -1)
	 pwarnx("error renaming `%s' to `%s'", ftmp, fname);
     remove(ftmp);			/* just in case */
     
     return 0;
}
@


1.16
log
@New keywords: @@extra and @@extraunexec.
Used to record extra files (configuration) and action, that will only
be taken with pkg_delete -c.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.15 2003/08/01 08:56:01 espie Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: perform.c,v 1.15 2003/08/01 08:56:01 espie Exp $";
@


1.15
log
@Add -q flag to pkg_delete: don't check md5 before removing.
Useful for bulk-package builders who want to clean /usr/local quickly.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.14 2003/07/04 17:31:19 avsm Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: perform.c,v 1.14 2003/07/04 17:31:19 avsm Exp $";
d37 1
d196 1
d226 1
a226 1
	if (delete_package(FALSE, CleanDirs, CheckMD5, &Plist) == FAIL)
@


1.14
log
@'static const char rcsid[]' to make it -Wall clean
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.13 2003/07/02 00:41:15 avsm Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: perform.c,v 1.13 2003/07/02 00:41:15 avsm Exp $";
d224 1
a224 1
	if (delete_package(FALSE, CleanDirs, &Plist) == FAIL)
@


1.13
log
@bump mktemp randomness from 6 to 10 X's
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.12 2003/04/04 08:56:01 avsm Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.12 2003/04/04 08:56:01 avsm Exp $";
@


1.12
log
@some more strcpy/strcat -> strlcpy/strlcat conversions
ok and tweaks by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.11 2001/11/26 05:04:33 deraadt Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.11 2001/11/26 05:04:33 deraadt Exp $";
d282 1
a282 1
     (void) snprintf(ftmp, sizeof(ftmp), "%s.XXXXXX", fname);
@


1.11
log
@mostly mark signal races
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.10 2001/04/17 21:51:33 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.10 2001/04/17 21:51:33 espie Exp $";
d35 1
a35 1
static int undepend(const char *, char *);
d241 1
a241 1
	    findmatchingname(dbdir, p->name, undepend, pkg);
d266 1
a266 1
undepend(const char *deppkgname, char *pkg2delname)
@


1.10
log
@Redundant package name.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.9 2001/04/08 16:45:47 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.9 2001/04/08 16:45:47 espie Exp $";
d258 1
a258 3
    /* Nothing to do */
    if(sig)	/* in case this is ever used as a signal handler */
	exit(1);
@


1.9
log
@Better error messages: pwarnx function, which works like pwarn, except
it shows a current package name along with the program name, e.g.,
pkg_add(foo-3.0): some error occurred.

A few messages now bear redundant pkgnames, which is much better than
doing pkg_add * and being informed that something went slightly wrong
somewhere...
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.8 2000/04/28 21:08:16 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.8 2000/04/28 21:08:16 espie Exp $";
d137 1
a137 1
	    pwarnx("no such package '%s' installed", pkg);
@


1.8
log
@If symlinks to the package exist, remove them along with the package.
(current fix for flavors not being found as proper dependencies).
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.7 2000/03/24 00:21:28 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.7 2000/03/24 00:21:28 espie Exp $";
d123 1
d137 1
a137 1
	    warnx("no such package '%s' installed", pkg);
d146 1
a146 1
	warnx("unable to change directory to %s! deinstall failed", LogDir);
d151 1
a151 1
	warnx("package `%s' is required by these other packages\n"
d160 1
a160 1
	    warnx("cannot open requirements file `%s'", REQUIRED_BY_FNAME);
d167 1
a167 1
	warnx("unable to open '%s' file", CONTENTS_FNAME);
d177 1
a177 1
	warnx("package '%s' doesn't have a prefix", pkg);
d184 1
a184 1
	    warnx("package '%s' prefix (%s) does not exist", pkg, p->name);
d188 1
a188 1
	    warnx("package'%s' mount point %s is read-only", pkg,
d200 1
a200 1
	    warnx("package %s fails requirements %s", pkg,
d212 1
a212 1
		warnx("deinstall script returned error status");
d225 1
a225 1
	    warnx(
d229 1
a229 1
	    warnx("couldn't remove log entry in %s, deinstall failed", LogDir);
d281 1
a281 1
	 warnx("couldn't open dependency file `%s'", fname);
d288 1
a288 1
	 warnx("couldn't open temp file `%s'", ftmp);
d295 1
a295 1
	 warnx("couldn't fdopen temp file `%s'", ftmp);
d307 1
a307 1
	 warnx("error changing permission of temp file `%s'", ftmp);
d313 1
a313 1
	 warnx("error closing temp file `%s'", ftmp);
d318 1
a318 1
	 warnx("error renaming `%s' to `%s'", ftmp, fname);
@


1.7
log
@Disallow pkg_delete when the pkg_prefix is on a read-only file-system.
This avoids erasing /var/db/info while keeping the package and issuing
hundreds of warnings...
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.6 1999/10/09 20:35:45 beck Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.6 1999/10/09 20:35:45 beck Exp $";
d74 40
d121 1
a121 1
    char *tmp;
d127 3
a129 3
    tmp = getenv(PKG_DBDIR);
    if (!tmp)
	tmp = DEF_LOG_DIR;
d131 1
a131 1
    (void) snprintf(LogDir, sizeof(LogDir), "%s/%s", tmp, pkg);
d232 1
d240 1
a240 2
	    findmatchingname((tmp = getenv(PKG_DBDIR)) ? tmp : DEF_LOG_DIR,
			     p->name, undepend, pkg);
@


1.6
log
@Band Aid fixes, polyglot of espies and mine:

  - ensure package files end in .tgz if not suffixed, but allow for .tar.gz and
uncompressed .tar as well.

  - make pkg_add take as many args as you can feed it. - "pkg_add *.tgz"
works now.

  - fix bug where realpath could fail and leave NULL in arg list.
  - fix bug where nonexistent package could fail and leave NULL in arg list.
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.5 1998/10/13 23:09:50 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.5 1998/10/13 23:09:50 marc Exp $";
d27 2
d139 14
@


1.5
log
@Sync with recent NetBSD changes:
- use snprintf in place of sprintf
- code cleanup
- Package -> package_t, PackingList -> plist_t
Also: remove files that haven't been linked in a while
Pass -q to mtree so it is quiet in the presence of symlinks
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.4 1998/09/07 22:30:15 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.4 1998/09/07 22:30:15 marc Exp $";
d49 23
d85 5
a89 2
    (void) snprintf(LogDir, sizeof(LogDir), "%s/%s", (tmp = getenv(PKG_DBDIR)) ? tmp : DEF_LOG_DIR,
    	    pkg);
d91 6
a96 2
	warnx("no such package '%s' installed", pkg);
	return 1;
@


1.4
log
@updated pkg_* tools.  Merged in many changes/improvements from NetBSD.
New features include md5 hash so pkg_delete won't remove files that have
changed and the ability to define conflicting packages, e.g. you can't
install both mh and nmh.  The ports tree will have to be updated to take
advantage of this.

Let me know of any problems, real or imagined :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.3 1997/06/17 08:38:03 deraadt Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.3 1997/06/17 08:38:03 deraadt Exp $";
d33 1
a33 1
static void undepend(PackingList, char *);
d47 1
a47 1
static Package Plist;
d55 1
a55 1
    PackingList p;
d62 1
a62 1
    sprintf(LogDir, "%s/%s", (tmp = getenv(PKG_DBDIR)) ? tmp : DEF_LOG_DIR,
d68 4
a71 2
    if (!getcwd(home, FILENAME_MAX))
	cleanup(0), errx(2, "unable to get current working directory!");
d131 4
a134 2
    if (chdir(home) == FAIL)
	cleanup(0), errx(2, "Toto! This doesn't look like Kansas anymore!");
d151 1
a151 2
	    printf("Attempting to remove dependency on package `%s'\n",
		   p->name);
d153 2
a154 1
	    undepend(p, pkg);
d162 4
a165 3
    if (!fexists(CONTENTS_FNAME))
	cleanup(0), errx(2, "installed package %s has no %s file!",
			pkg, CONTENTS_FNAME);
d176 6
a181 2
static void
undepend(PackingList p, char *pkgname)
d189 1
a189 1
     sprintf(fname, "%s/%s/%s",
d191 1
a191 1
	     p->name, REQUIRED_BY_FNAME);
d195 1
a195 1
	 return;
d197 1
a197 1
     sprintf(ftmp, "%s.XXXXXXXXXX", fname);
d202 1
a202 1
	 return;
d210 1
a210 1
	 return;
d215 1
a215 1
	 if (strcmp(fbuf, pkgname))		/* no match */
d223 1
a223 1
	 return;
d228 1
a228 1
	 return;
d231 1
a231 1
	 warn("error renaming `%s' to `%s'", ftmp, fname);
d233 2
a234 1
     return;
@


1.3
log
@use mktemp, but use it without guessability or DOS attacks
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.2 1996/06/04 08:43:38 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.2 1996/06/04 08:43:38 niklas Exp $";
d27 1
d65 1
a65 1
	whinge("No such package '%s' installed.", pkg);
d69 1
a69 1
	barf("Unable to get current working directory!");
d71 1
a71 1
	whinge("Unable to change directory to %s!  Deinstall failed.", LogDir);
d76 3
a78 2
	whinge("Package `%s' is required by these other packages", pkg);
	whinge("and may not be deinstalled%s:", Force ? " (but I'll delete it anyway)" : "" );
d85 1
a85 1
	    whinge("cannot open requirements file `%s'", REQUIRED_BY_FNAME);
d92 1
a92 1
	whinge("Unable to open '%s' file.", CONTENTS_FNAME);
d101 5
a105 4
    if (p)
	setenv(PKG_PREFIX_VNAME, p->name, 1);
    else
	unsetenv(PKG_PREFIX_VNAME);
d111 2
a112 2
	    whinge("Package %s fails requirements %s", pkg,
		   Force ? "." : "- not deleted.");
d123 1
a123 1
		whinge("De-Install script returned error status.");
d130 1
a130 1
	barf("Toto!  This doesn't look like Kansas anymore!");
d134 3
a136 2
	    warn("Couldn't entirely delete package (perhaps the packing list is\n"
		 "incorrectly specified?)\n");
d138 3
a140 2
	    whinge("Couldn't remove log entry in %s, de-install failed.", LogDir);
	    return 1;
d159 2
a160 1
	barf("Installed package %s has no %s file!", pkg, CONTENTS_FNAME);
d167 2
d185 1
a185 1
	 whinge("Couldn't open dependency file `%s'", fname);
d192 1
a192 1
	 whinge("Couldn't open temp file `%s'", ftmp);
d199 1
a199 1
	 whinge("Couldn't fdopen temp file `%s'", ftmp);
d211 1
a211 1
	 whinge("Error changing permission of temp file `%s'", ftmp);
d217 1
a217 1
	 whinge("Error closing temp file `%s'", ftmp);
d222 1
a222 1
	 warn("Error renaming `%s' to `%s'", ftmp, fname);
@


1.2
log
@Oops, screwed up the $OpenBSD$ IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: perform.c,v 1.1 1996/06/04 07:56:08 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.1 1996/06/04 07:56:08 niklas Exp $";
d180 1
a180 1
     sprintf(ftmp, "%s.XXXXXX", fname);
@


1.1
log
@add package tools from FreeBSD
@
text
@d1 2
a2 1
#	$OpenBSD$
d4 1
a4 1
static const char *rcsid = "$OpenBSD: perform.c,v 1.8 1995/11/12 04:55:30 jkh Exp $";
@
