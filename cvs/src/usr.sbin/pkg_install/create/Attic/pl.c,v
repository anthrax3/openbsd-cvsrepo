head	1.12;
access;
symbols
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.7.0.8
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.6
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.12
date	2004.05.28.20.15.48;	author brad;	state dead;
branches;
next	1.11;

1.11
date	2003.08.15.00.03.22;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.12.06.54.03;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.04.17.31.19;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.04.08.56.01;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.06.20.03.08;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.26.15.25.29;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	98.10.13.23.09.50;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	98.09.07.22.30.14;	author marc;	state Exp;
branches;
next	1.3;

1.3
date	98.06.23.23.17.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.04.08.43.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.06.04.07.56.06;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.12
log
@bye bye old package tools.

ok deraadt@@
@
text
@/*	$OpenBSD: pl.c,v 1.11 2003/08/15 00:03:22 espie Exp $	*/

#ifndef lint
static const char rcsid[] = "$OpenBSD: pl.c,v 1.11 2003/08/15 00:03:22 espie Exp $";
#endif

/*
 * FreeBSD install - a package for the installation and maintainance
 * of non-core utilities.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Jordan K. Hubbard
 * 18 July 1993
 *
 * Routines for dealing with the packing list.
 *
 */

#include "lib.h"
#include "create.h"
#include <errno.h>
#include <err.h>
#include <md5.h>

/* Check a list for files that require preconversion */
void
check_list(char *home, package_t *pkg)
{
	plist_t	*tmp;
	plist_t	*p;
	char	*cwd = home;
	char	*there = NULL;
	char	*cp;
	char	name[FILENAME_MAX];
	char	buf[LegibleChecksumLen];

	for (p = pkg->head ; p ; p = p->next) {
		switch (p->type) {
		case PLIST_CWD:
			cwd = p->name;
			break;
		case PLIST_IGNORE:
			p = p->next;
			break;
		case PLIST_SRC:
			there = p->name;
			break;
		case PLIST_COMMENT:
			if (p->name != NULL && 
			    strcmp(p->name, "no checksum") == 0)
				p = p->next;
			break;
		case PLIST_FILE:
			if (BaseDir)
				(void) snprintf(name, sizeof(name), 
				    "%s/%s/%s", BaseDir, there ? there : cwd, 
				    p->name);
			else
				(void) snprintf(name, sizeof(name), 
				    "%s/%s", there ? there : cwd, p->name);
			if ((cp = MD5File(name, buf)) != NULL) {
				tmp = new_plist_entry();
				tmp->name = copy_string(strconcat("MD5:", cp));
				tmp->type = PLIST_COMMENT;
				tmp->next = p->next;
				tmp->prev = p;
				p->next = tmp;
				if (pkg->tail == p)
					pkg->tail = tmp;
				p = tmp;
			}
			break;
		default:
			break;
		}
	}
}

static int
trylink(const char *from, const char *to)
{
	char	*cp;

	if (link(from, to) == 0) {
		return 0;
	}
	if (errno == ENOENT) {
		/* try making the container directory */
		if ((cp = strrchr(to, '/')) != (char *) NULL) {
			vsystem("mkdir -p %.*s", (size_t)(cp - to), to);
		}
		return link(from, to);
	}
	return -1;
}

#define STARTSTRING "tar cf -"
#define TOOBIG(str) strlen(str) + 6 + strlen(home) + where_count > maxargs
#define PUSHOUT() /* push out string */					\
	if (where_count > sizeof(STARTSTRING)-1) {			\
		    strlcat(where_args, "|tar xpf -", maxargs);		\
		    if (system(where_args)) {				\
			cleanup(0);					\
			errx(2, "can't invoke tar pipeline");		\
		    }							\
		    memset(where_args, 0, maxargs);			\
 		    last_chdir = NULL;					\
		    strlcpy(where_args, STARTSTRING, maxargs);		\
		    where_count = sizeof(STARTSTRING)-1;		\
	}

/*
 * Copy unmarked files in packing list to playpen - marked files
 * have already been copied in an earlier pass through the list.
 */
void
copy_plist(char *home, package_t *plist)
{
    plist_t *p = plist->head;
    char *where = home;
    char *there = NULL, *mythere;
    char *where_args, *last_chdir, *root = "/";
    int maxargs, where_count = 0, add_count;
    struct stat stb;
    dev_t curdir;

    maxargs = sysconf(_SC_ARG_MAX);
    maxargs -= 64;			/* some slop for the tar cmd text,
					   and sh -c */
    where_args = malloc(maxargs);
    if (!where_args) {
	cleanup(0);
	errx(2, "can't get argument list space");
    }

    memset(where_args, 0, maxargs);
    strlcpy(where_args, STARTSTRING, maxargs);
    where_count = sizeof(STARTSTRING)-1;
    last_chdir = 0;

    if (stat(".", &stb) == 0)
	curdir = stb.st_dev;
    else
	curdir = (dev_t) -1;		/* It's ok if this is a valid dev_t;
					   this is just a hint for an
					   optimization. */

    while (p) {
	if (p->type == PLIST_CWD)
	    where = p->name;
	else if (p->type == PLIST_SRC)
	    there = p->name;
	else if (p->type == PLIST_IGNORE)
	    p = p->next;
	else if (p->type == PLIST_FILE && !p->marked) {
	    char fn[FILENAME_MAX];


	    /* First, look for it in the "home" dir */
	    (void) snprintf(fn, sizeof(fn), "%s/%s", home, p->name);
	    if (fexists(fn)) {
		if (lstat(fn, &stb) == 0 && stb.st_dev == curdir &&
		    S_ISREG(stb.st_mode)) {
		    /* if we can link it to the playpen, that avoids a copy
		       and saves time. */
		    if (p->name[0] != '/') {
			/* don't link abspn stuff--it doesn't come from
			   local dir! */
			if (trylink(fn, p->name) == 0) {
			    p = p->next;
			    continue;
			}
		    }
		}
		if (TOOBIG(fn)) {
		    PUSHOUT();
		}
		if (p->name[0] == '/') {
		    add_count = snprintf(&where_args[where_count],
					 maxargs - where_count,
					 " %s %s",
					 last_chdir == root ? "" : "-C /",
					 p->name);
		    last_chdir = root;
		} else {
		    add_count = snprintf(&where_args[where_count],
					 maxargs - where_count,
					 " %s%s %s",
					 last_chdir == home ? "" : "-C ",
					 last_chdir == home ? "" : home,
					 p->name);
		    last_chdir = home;
		}
		if (add_count > maxargs - where_count) {
		    cleanup(0);
		    errx(2, "oops, miscounted strings!");
		}
		where_count += add_count;
	    }
	    /*
	     * Otherwise, try along the actual extraction path..
	     */
	    else {
		if (p->name[0] == '/')
		    mythere = root;
		else mythere = there;
		(void) snprintf(fn, sizeof(fn), "%s/%s", mythere ? mythere : where, p->name);
		if (lstat(fn, &stb) == 0 && stb.st_dev == curdir &&
		    S_ISREG(stb.st_mode)) {
		    /* if we can link it to the playpen, that avoids a copy
		       and saves time. */
		    if (trylink(fn, p->name) == 0) {
			p = p->next;
			continue;
		    }
		}
		if (TOOBIG(p->name)) {
		    PUSHOUT();
		}
		if (last_chdir == (mythere ? mythere : where))
		    add_count = snprintf(&where_args[where_count],
					 maxargs - where_count,
					 " %s", p->name);
		else
		    add_count = snprintf(&where_args[where_count],
					 maxargs - where_count,
					 " -C %s %s",
					 mythere ? mythere : where,
					 p->name);
		if (add_count > maxargs - where_count) {
		    cleanup(0);
		    errx(2, "oops, miscounted strings!");
		}
		where_count += add_count;
		last_chdir = (mythere ? mythere : where);
	    }
	}
	p = p->next;
    }
    PUSHOUT();
    free(where_args);
}
@


1.11
log
@-S basedir, simpler to use than -s.

Sets prefix logic better, so that it doesn't interfere with existing @@cwd
in packing lists.

tests by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pl.c,v 1.9 2003/07/04 17:31:19 avsm Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pl.c,v 1.9 2003/07/04 17:31:19 avsm Exp $";
@


1.10
log
@fix pkg->tail as needed, so that last md5 in CONTENTS does not get erased.
@
text
@d62 7
a68 1
			(void) snprintf(name, sizeof(name), "%s/%s", there ? there : cwd, p->name);
@


1.9
log
@'static const char rcsid[]' to make it -Wall clean
@
text
@d1 1
a1 1
/*	$OpenBSD: pl.c,v 1.8 2003/04/04 08:56:01 avsm Exp $	*/
d4 1
a4 1
static const char rcsid[] = "$OpenBSD: pl.c,v 1.8 2003/04/04 08:56:01 avsm Exp $";
d70 2
@


1.8
log
@some more strcpy/strcat -> strlcpy/strlcat conversions
ok and tweaks by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pl.c,v 1.7 2001/06/06 20:03:08 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: pl.c,v 1.7 2001/06/06 20:03:08 espie Exp $";
@


1.7
log
@Do not dump core on empty comment
@
text
@d1 1
a1 1
/*	$OpenBSD: pl.c,v 1.6 2000/04/26 15:25:29 espie Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: pl.c,v 1.6 2000/04/26 15:25:29 espie Exp $";
d101 1
a101 1
		    strcat(where_args, "|tar xpf -");			\
d108 1
a108 1
		    strcpy(where_args, STARTSTRING);			\
d137 1
a137 1
    strcpy(where_args, STARTSTRING);
@


1.6
log
@Needed feature: if
@@comment no checksum
is inserted in a packing-list, then the next file will not have
its MD5 checksum stored, and pkg_delete won't complain later if
the file checksum changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pl.c,v 1.5 1998/10/13 23:09:50 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: pl.c,v 1.5 1998/10/13 23:09:50 marc Exp $";
d57 2
a58 1
			if (strcmp(p->name, "no checksum") == 0)
@


1.5
log
@Sync with recent NetBSD changes:
- use snprintf in place of sprintf
- code cleanup
- Package -> package_t, PackingList -> plist_t
Also: remove files that haven't been linked in a while
Pass -q to mtree so it is quiet in the presence of symlinks
@
text
@d1 1
a1 1
/*	$OpenBSD: pl.c,v 1.4 1998/09/07 22:30:14 marc Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: pl.c,v 1.4 1998/09/07 22:30:14 marc Exp $";
d55 4
@


1.4
log
@updated pkg_* tools.  Merged in many changes/improvements from NetBSD.
New features include md5 hash so pkg_delete won't remove files that have
changed and the ability to define conflicting packages, e.g. you can't
install both mh and nmh.  The ports tree will have to be updated to take
advantage of this.

Let me know of any problems, real or imagined :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: pl.c,v 1.3 1998/06/23 23:17:22 millert Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: pl.c,v 1.3 1998/06/23 23:17:22 millert Exp $";
d35 1
a35 1
check_list(char *home, Package *pkg)
d37 34
a70 11
    char *where = home;
    char *there = NULL;
    PackingList p = pkg->head;

    while (p) {
	if (p->type == PLIST_CWD)
	    where = p->name;
	else if (p->type == PLIST_IGNORE)
	    p = p->next;
	else if (p->type == PLIST_SRC) {
	    there = p->name;
a71 17
	else if (p->type == PLIST_FILE) {
	    char *cp, name[FILENAME_MAX], buf[33];

	    sprintf(name, "%s/%s", there ? there : where, p->name);
	    if ((cp = MD5File(name, buf)) != NULL) {
		PackingList tmp = new_plist_entry();

		tmp->name = copy_string(strconcat("MD5:", cp));
		tmp->type = PLIST_COMMENT;
		tmp->next = p->next;
		tmp->prev = p;
		p->next = tmp;
		p = tmp;
	    }
	}
	p = p->next;
    }
d77 13
a89 11
    if (link(from, to) == 0)
	return 0;
    if (errno == ENOENT) {
	/* try making the container directory */
	char *cp = strrchr(to, '/');
	if (cp)
	    vsystem("mkdir -p %.*s", cp - to,
		    to);
	return link(from, to);
    }
    return -1;
d94 11
a104 9
#define PUSHOUT() /* push out string */ \
	if (where_count > sizeof(STARTSTRING)-1) { \
		    strcat(where_args, "|tar xpf -"); \
		    if (system(where_args)) \
			cleanup(0), errx(2, "can't invoke tar pipeline"); \
		    memset(where_args, 0, maxargs); \
 		    last_chdir = NULL; \
		    strcpy(where_args, STARTSTRING); \
		    where_count = sizeof(STARTSTRING)-1; \
d112 1
a112 1
copy_plist(char *home, Package *plist)
d114 1
a114 1
    PackingList p = plist->head;
d126 4
a129 2
    if (!where_args)
	cleanup(0), errx(2, "can't get argument list space");
d155 1
a155 1
	    sprintf(fn, "%s/%s", home, p->name);
d189 4
a192 2
		if (add_count > maxargs - where_count)
		    cleanup(0), errx(2, "oops, miscounted strings!");
d202 1
a202 1
		sprintf(fn, "%s/%s", mythere ? mythere : where, p->name);
d225 4
a228 2
		if (add_count > maxargs - where_count)
		    cleanup(0), errx(2, "oops, miscounted strings!");
@


1.3
log
@Fix snprintf return value usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pl.c,v 1.2 1996/06/04 08:43:36 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: pl.c,v 1.2 1996/06/04 08:43:36 niklas Exp $";
d30 2
a36 2
    char cmd[FILENAME_MAX];
    char name[FILENAME_MAX];
d50 2
a51 1
	    cmd[0] = '\0';
d53 2
d56 6
a61 6
	    if (*cmd) {
		if (Verbose)
		    printf("Uncompressing-> %s\n", cmd);
		if (system(cmd))
		    barf("%s failed!", cmd);
		nuke_suffix(p->name);
d90 1
a90 1
			barf("can't invoke tar pipeline"); \
d117 1
a117 1
	barf("can't get argument list space");
d177 2
a178 2
		if (add_count >= maxargs - where_count)
		    barf("oops, miscounted strings!");
d211 2
a212 2
		if (add_count >= maxargs - where_count)
		    barf("oops, miscounted strings!");
@


1.2
log
@Oops, screwed up the $OpenBSD$ IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: pl.c,v 1.1 1996/06/04 07:56:06 niklas Exp $	*/
d4 1
a4 1
static const char *rcsid = "$OpenBSD: pl.c,v 1.1 1996/06/04 07:56:06 niklas Exp $";
d174 1
a174 1
		if (add_count > maxargs - where_count)
d208 1
a208 1
		if (add_count > maxargs - where_count)
@


1.1
log
@add package tools from FreeBSD
@
text
@d1 2
a2 1
#	$OpenBSD$
d4 1
a4 1
static const char *rcsid = "$OpenBSD: pl.c,v 1.7 1995/05/30 03:49:56 rgrimes Exp $";
@
