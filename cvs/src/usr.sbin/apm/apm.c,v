head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.4
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.32.0.8
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.27.0.12
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.10
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.6
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.4
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.2
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.10
	OPENBSD_5_0:1.24.0.8
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.6
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.16
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.12
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.10
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.8
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.6
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.10
	OPENBSD_2_8:1.3.0.8
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.4
	OPENBSD_2_1_BASE:1.1
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.33
date	2017.07.23.12.51.20;	author anton;	state Exp;
branches;
next	1.32;
commitid	rnRA1movaIwVaLvv;

1.32
date	2015.11.01.14.13.30;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	ytYrdkYegot1PUd6;

1.31
date	2015.10.28.12.25.13;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	esXFOpdFGWiXLquP;

1.30
date	2015.10.11.20.23.49;	author guenther;	state Exp;
branches;
next	1.29;
commitid	i6P7pBlCuLlhNqfW;

1.29
date	2015.01.16.06.40.15;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Uu5nFG3wCl0LACBb;

1.28
date	2014.10.17.07.43.33;	author jmc;	state Exp;
branches;
next	1.27;
commitid	EwKJ8YgKj5cUPsWw;

1.27
date	2012.07.11.13.27.13;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2012.03.30.06.40.36;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2012.03.26.20.17.43;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.30.19.41.10;	author sobrado;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.11.17.45.54;	author sturm;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.10.17.36.12;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.12.19.41.08;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.15.20.30.27;	author sturm;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.06.15.21.05;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.26.17.59.07;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.28.17.08.13;	author sturm;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.19.19.17.10;	author sturm;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.02.04.33.27;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.02.04.27.52;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.23.08.02.58;	author sturm;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.15.01.25.48;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.30.20.00.55;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.29.16.25.20;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.30.21.44.32;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.11.23.33.25;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.06.19.14.47;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.14.22.20.22;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.06.21.08.00;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.05.20.10.32;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.10.29.18.21.44;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.09.12.04.07.14;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.04.29.13.08.40;	author hvozda;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Cleanup apm:

- Zap trailing whitespace in license, noted by tb@@
- Sort and align function prototypes
- Add static and __dead when appropriate in order to compile using `clang -Wall`
- Zap variable names from function prototypes, also noted by tb@@
- Break long lines

ok tb@@
@
text
@/*	$OpenBSD: apm.c,v 1.32 2015/11/01 14:13:30 deraadt Exp $	*/

/*
 *  Copyright (c) 1996 John T. Kohl
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/sysctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/ioctl.h>
#include <machine/apmvar.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <err.h>
#include <string.h>
#include "pathnames.h"
#include "apm-proto.h"

#define FALSE 0
#define TRUE 1

extern char *__progname;

static int		do_zzz(int, enum apm_action);
static int		open_socket(const char *);
static int		send_command(int, struct apm_command *,
			    struct apm_reply *);
static __dead void	usage(void);
static __dead void	zzusage(void);

static __dead void
usage(void)
{
	fprintf(stderr,"usage: %s [-AabHLlmPSvZz] [-f sockname]\n",
	    __progname);
	exit(1);
}

static __dead void
zzusage(void)
{
	fprintf(stderr,"usage: %s [-SZz] [-f sockname]\n",
	    __progname);
	exit(1);
}

static int
send_command(int fd, struct apm_command *cmd, struct apm_reply *reply)
{
	/* send a command to the apm daemon */
	cmd->vno = APMD_VNO;

	if (send(fd, cmd, sizeof(*cmd), 0) == sizeof(*cmd)) {
		if (recv(fd, reply, sizeof(*reply), 0) != sizeof(*reply)) {
			warn("invalid reply from APM daemon");
			return (1);
		}
	} else {
		warn("invalid send to APM daemon");
		return (1);
	}
	return (0);
}

static int
do_zzz(int fd, enum apm_action action)
{
	struct apm_command command;
	struct apm_reply reply;
	char *msg;

	switch (action) {
	case NONE:
	case SUSPEND:
		command.action = SUSPEND;
		msg = "Suspending system";
		break;
	case STANDBY:
		command.action = STANDBY;
		msg = "System standing by";
		break;
	case HIBERNATE:
		command.action = HIBERNATE;
		msg = "Hibernating system";
		break;
	default:
		zzusage();
	}

	printf("%s...\n", msg);
	exit(send_command(fd, &command, &reply));
}

static int
open_socket(const char *sockname)
{
	int sock, errr;
	struct sockaddr_un s_un;

	sock = socket(AF_UNIX, SOCK_STREAM, 0);
	if (sock == -1)
		err(1, "cannot create local socket");

	s_un.sun_family = AF_UNIX;
	strlcpy(s_un.sun_path, sockname, sizeof(s_un.sun_path));
	if (connect(sock, (struct sockaddr *)&s_un, sizeof(s_un)) == -1) {
		errr = errno;
		close(sock);
		errno = errr;
		sock = -1;
	}
	return (sock);
}

int
main(int argc, char *argv[])
{
	const char *sockname = _PATH_APM_SOCKET;
	int doac = FALSE;
	int dopct = FALSE;
	int dobstate = FALSE;
	int domin = FALSE;
	int doperf = FALSE;
	int verbose = FALSE;
	int ch, fd, rval;
	enum apm_action action = NONE;
	struct apm_command command;
	struct apm_reply reply;
	int cpuspeed_mib[] = { CTL_HW, HW_CPUSPEED }, cpuspeed;
	size_t cpuspeed_sz = sizeof(cpuspeed);

	if (sysctl(cpuspeed_mib, 2, &cpuspeed, &cpuspeed_sz, NULL, 0) < 0)
		err(1, "sysctl hw.cpuspeed");

	while ((ch = getopt(argc, argv, "ACHLlmbvaPSzZf:")) != -1) {
		switch (ch) {
		case 'v':
			verbose = TRUE;
			break;
		case 'f':
			sockname = optarg;
			break;
		case 'z':
			if (action != NONE)
				usage();
			action = SUSPEND;
			break;
		case 'S':
			if (action != NONE)
				usage();
			action = STANDBY;
			break;
		case 'Z':
			if (action != NONE)
				usage();
			action = HIBERNATE;
			break;
		case 'A':
			if (action != NONE)
				usage();
			action = SETPERF_AUTO;
			break;
		case 'C':
			if (action != NONE)
				usage();
			action = SETPERF_COOL;
			break;
		case 'H':
			if (action != NONE)
				usage();
			action = SETPERF_HIGH;
			break;
		case 'L':
			if (action != NONE)
				usage();
			action = SETPERF_LOW;
			break;
		case 'b':
			if (action != NONE && action != GETSTATUS)
				usage();
			dobstate = TRUE;
			action = GETSTATUS;
			break;
		case 'l':
			if (action != NONE && action != GETSTATUS)
				usage();
			dopct = TRUE;
			action = GETSTATUS;
			break;
		case 'm':
			if (action != NONE && action != GETSTATUS)
				usage();
			domin = TRUE;
			action = GETSTATUS;
			break;
		case 'a':
			if (action != NONE && action != GETSTATUS)
				usage();
			doac = TRUE;
			action = GETSTATUS;
			break;
		case 'P':
			if (action != NONE && action != GETSTATUS)
				usage();
			doperf = TRUE;
			action = GETSTATUS;
			break;
		default:
			if (!strcmp(__progname, "zzz") ||
			    !strcmp(__progname, "ZZZ"))
				zzusage();
			else
				usage();
		}
	}

	fd = open_socket(sockname);

	if (fd != -1) {
		if (pledge("stdio rpath wpath cpath", NULL) == -1)
			err(1, "pledge");
	}

	if (!strcmp(__progname, "zzz")) {
		if (fd < 0)
			err(1, "cannot connect to apmd");
		else
			return (do_zzz(fd, action));
	} else if (!strcmp(__progname, "ZZZ")) {
		if (fd < 0)
			err(1, "cannot connect to apmd");
		else
			return (do_zzz(fd, HIBERNATE));
	}


	bzero(&reply, sizeof reply);
	reply.batterystate.battery_state = APM_BATT_UNKNOWN;
	reply.batterystate.ac_state = APM_AC_UNKNOWN;
	reply.perfmode = PERF_MANUAL;
	reply.cpuspeed = cpuspeed;

	switch (action) {
	case SETPERF_LOW:
	case SETPERF_HIGH:
	case SETPERF_AUTO:
	case SETPERF_COOL:
		if (fd == -1)
			errx(1, "cannot connect to apmd, "
			    "not changing performance adjustment mode");
		goto balony;
	case NONE:
		action = GETSTATUS;
		verbose = doac = dopct = dobstate = domin = doperf = TRUE;
		/* FALLTHROUGH */
	case GETSTATUS:
		if (fd == -1) {
			/* open the device directly and get status */
			fd = open(_PATH_APM_NORMAL, O_RDONLY);
			if (ioctl(fd, APM_IOC_GETPOWER,
			    &reply.batterystate) == 0)
				goto printval;
		}
		/* FALLTHROUGH */
balony:
	case SUSPEND:
	case STANDBY:
	case HIBERNATE:
		command.action = action;
		break;
	default:
		usage();
	}

	if (fd != -1 && (rval = send_command(fd, &command, &reply)) != 0)
		errx(rval, "cannot get reply from APM daemon");

	switch (action) {
	case GETSTATUS:
	printval:
		if (!verbose) {
			if (dobstate)
				printf("%d\n",
				    reply.batterystate.battery_state);
			if (dopct)
				printf("%d\n",
				    reply.batterystate.battery_life);
			if (domin) {
				if (reply.batterystate.minutes_left ==
				    (u_int)-1)
					printf("unknown\n");
				else
					printf("%d\n",
					    reply.batterystate.minutes_left);
			}
			if (doac)
				printf("%d\n",
				    reply.batterystate.ac_state);
			if (doperf)
				printf("%d\n", reply.perfmode);
			break;
		}

		if (dobstate) {
			printf("Battery state: %s",
			    battstate(reply.batterystate.battery_state));
			if (!dopct && !domin)
				printf("\n");
		}

		if (dopct && !dobstate)
			printf("Battery remaining: %d percent",
			    reply.batterystate.battery_life);
		else if (dopct)
			printf(", %d%% remaining",
			    reply.batterystate.battery_life);
		if (dopct && !domin)
			printf("\n");

		if (domin && !dobstate && !dopct) {
#ifdef __powerpc__
			if (reply.batterystate.battery_state ==
			    APM_BATT_CHARGING)
				printf("Remaining battery recharge "
				    "time estimate: %d minutes\n",
				    reply.batterystate.minutes_left);
			else if (reply.batterystate.minutes_left == 0 &&
			    reply.batterystate.battery_life > 10)
				printf("Battery life estimate: "
				    "not available\n");
			else
#endif
			{
				printf("Battery life estimate: ");
				if (reply.batterystate.minutes_left ==
				    (u_int)-1)
					printf("unknown\n");
				else
					printf("%d minutes\n",
					    reply.batterystate.minutes_left);
			}
		} else if (domin) {
#ifdef __powerpc__
			if (reply.batterystate.battery_state ==
			    APM_BATT_CHARGING)
				printf(", %d minutes recharge time estimate\n",
				    reply.batterystate.minutes_left);
			else if (reply.batterystate.minutes_left == 0 &&
			    reply.batterystate.battery_life > 10)
				printf(", unknown life estimate\n");
			else
#endif
			{
				if (reply.batterystate.minutes_left ==
				    (u_int)-1)
					printf(", unknown");
				else
					printf(", %d minutes",
					    reply.batterystate.minutes_left);
				printf(" life estimate\n");
			}
		}

		if (doac)
			printf("A/C adapter state: %s\n",
			    ac_state(reply.batterystate.ac_state));

		if (doperf)
			printf("Performance adjustment mode: %s (%d MHz)\n",
			    perf_mode(reply.perfmode), reply.cpuspeed);
		break;
	default:
		break;
	}

	switch (reply.newstate) {
	case SUSPEND:
		printf("System will enter suspend mode momentarily.\n");
		break;
	case STANDBY:
		printf("System will enter standby mode momentarily.\n");
		break;
	case HIBERNATE:
		printf("System will enter hibernate mode momentarily.\n");
		break;
	default:
		break;
	}
	return (0);
}
@


1.32
log
@only pledge if in doing-work-via-daemon mode
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.31 2015/10/28 12:25:13 deraadt Exp $	*/
d6 1
a6 1
 * 
d17 1
a17 1
 * 
d29 1
a29 1
 * 
d53 6
a58 5
void usage(void);
void zzusage(void);
int do_zzz(int, enum apm_action action);
int open_socket(const char *pn);
int send_command(int fd, struct apm_command *cmd, struct apm_reply *reply);
d60 1
a60 1
void
d68 1
a68 1
void
d76 1
a76 1
int
d94 1
a94 1
int
d123 1
a123 1
int
d238 2
a239 1
			if (!strcmp(__progname, "zzz") || !strcmp(__progname, "ZZZ"))
@


1.31
log
@By hoisting sysctl hw.cpuspeed towards the top, it is possible to
pledge "stdio rpath wpath cpath unix".  I wonder what we can do in
apmd...
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.30 2015/10/11 20:23:49 guenther Exp $	*/
a162 3
	if (pledge("stdio rpath wpath cpath unix", NULL) == -1)
		err(1, "pledge");

d245 5
@


1.30
log
@Userspace doesn't need to use SUN_LEN(): connect() and bind() must accept
sizeof(struct sockaddr_un), so do the simple, portable thing.
Also convert some strncpy() to strlcpy()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.29 2015/01/16 06:40:15 deraadt Exp $	*/
d160 6
d266 1
a266 4
	if (sysctl(cpuspeed_mib, 2, &cpuspeed, &cpuspeed_sz, NULL, 0) < 0)
		reply.cpuspeed = 0;
	else
		reply.cpuspeed = cpuspeed;
@


1.29
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.28 2014/10/17 07:43:33 jmc Exp $	*/
d133 2
a134 3
	strncpy(s_un.sun_path, sockname, sizeof(s_un.sun_path));
	s_un.sun_len = SUN_LEN(&s_un);
	if (connect(sock, (struct sockaddr *)&s_un, s_un.sun_len) == -1) {
@


1.28
log
@remove -C from usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.27 2012/07/11 13:27:13 deraadt Exp $	*/
d32 1
a32 1
#include <sys/param.h>
@


1.27
log
@improve messages for suspend/hibernate
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.26 2012/03/30 06:40:36 jmc Exp $	*/
d62 1
a62 1
	fprintf(stderr,"usage: %s [-AabCHLlmPSvZz] [-f sockname]\n",
@


1.26
log
@document ZZZ; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.25 2012/03/26 20:17:43 deraadt Exp $	*/
d98 1
d104 1
d108 1
d112 1
d118 1
a118 1
	printf("Suspending system...\n");
@


1.25
log
@Add hibernate request support.  Also installs a ZZZ binary for the
shortcut.
ok mlarkin miod
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.24 2009/10/30 19:41:10 sobrado Exp $	*/
d62 1
a62 1
	fprintf(stderr,"usage: %s [-AabCHLlmPSvz] [-f sockname]\n",
d70 1
a70 1
	fprintf(stderr,"usage: %s [-Sz] [-f sockname]\n",
d231 1
a231 1
			if (!strcmp(__progname, "zzz"))
@


1.24
log
@when used with incorrect flags, zzz(8) should call zzusage(void)
instead of usage(void).

millert@@ suggested checking __progname() against "zzz" to match
existing code.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.23 2006/06/11 17:45:54 sturm Exp $	*/
d107 3
d157 1
a157 1
	while ((ch = getopt(argc, argv, "ACHLlmbvaPSzf:")) != -1) {
d175 5
d245 5
d252 1
d287 1
d401 3
@


1.23
log
@change "apmd not running" to "cannot connect to apmd" in error message
as it could be a permission problem as well, pr 5151

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.22 2006/05/10 17:36:12 mickey Exp $	*/
d223 4
a226 1
			usage();
@


1.22
log
@fail zzz w/ a reasonable error msg if apmd is not running; found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.21 2006/04/12 19:41:08 deraadt Exp $	*/
d251 2
a252 2
			errx(1, "apmd not running; "
			    "cannot change performance adjustment mode");
@


1.21
log
@If /dev/apm does not respond, use a fake (pre-built) response packet
that can be printed.  This makes apm(8) act the same whether talking
to apmd(8) or directly to a (potentially non-functioning) /dev/apm.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.20 2006/03/15 20:30:27 sturm Exp $	*/
d229 6
a234 2
	if (!strcmp(__progname, "zzz"))
		return (do_zzz(fd, action));
@


1.20
log
@consistently use power *states* and performance *modes*

ok beck, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.19 2006/03/06 15:21:05 mickey Exp $	*/
d32 6
a44 5
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/ioctl.h>
#include <machine/apmvar.h>
d151 2
d232 9
d242 8
d263 1
a265 4
	case SETPERF_LOW:
	case SETPERF_HIGH:
	case SETPERF_AUTO:
	case SETPERF_COOL:
d272 1
a272 1
	if ((rval = send_command(fd, &command, &reply)) != 0)
@


1.19
log
@failure to connect to apmd socket -- get status from the /dev/apm directly
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.18 2006/02/26 17:59:07 jmc Exp $	*/
d280 1
a280 1
				printf("%d\n", reply.perfstate);
d349 2
a350 2
			printf("Performance state: %s (%d MHz)\n",
			    perf_state(reply.perfstate), reply.cpuspeed);
@


1.18
log
@spacing; from ray lai
ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.17 2006/01/28 17:08:13 sturm Exp $	*/
d131 1
a131 1
		err(1, "cannot open connection to APM daemon");
@


1.17
log
@be less verbose:
- status does not provide any information, remove it
- print battery status in one line
ok beck, drahn, i386 tested by bernd
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.16 2006/01/19 19:17:10 sturm Exp $	*/
d295 1
a295 1
			printf(", %d %% remaining",
@


1.16
log
@prompted by deraadt:
manual performance mode -> low/high performance mode
show cpuspeed in apm output

ok beck, weingart
man page bits ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.15 2005/12/02 04:33:27 deraadt Exp $	*/
d61 1
a61 1
	fprintf(stderr,"usage: %s [-AabCHLlmPSsvz] [-f sockname]\n",
a139 1
	int dostatus = FALSE;
d151 1
a151 1
	while ((ch = getopt(argc, argv, "ACHLlmbvaPsSzf:")) != -1) {
a188 6
		case 's':
			if (action != NONE && action != GETSTATUS)
				usage();
			dostatus = TRUE;
			action = GETSTATUS;
			break;
d232 1
a232 2
		verbose = doac = dopct = dobstate = dostatus = domin = TRUE;
		doperf = TRUE;
a278 2
			if (dostatus)
				printf("1\n");
d283 3
a285 2
		if (dobstate)
			printf("Battery state: %s\n",
d287 6
a292 2
		if (dopct)
			printf("Battery remaining: %d percent\n",
d294 7
a300 1
		if (domin) {
d322 20
d343 1
d347 1
a350 2
		if (dostatus)
			printf("Power management enabled\n");
@


1.15
log
@sync to usage in man page
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.14 2005/12/02 04:27:52 beck Exp $	*/
d241 1
a241 1
		/* fallthrough */
d250 1
a250 1
		/* fallthrough */
d326 2
a327 2
			printf("Performance state: %s\n",
			    perf_state(reply.perfstate));
@


1.14
log
@Modify automatic performance adjustment mode so that the cpu is set
to go fast if the power is connected and the battery is more than 15%
charged, and when on batteries keeps setperf low unless needed.
add a cool runnings mode option (-C) that does the previous behaviour
of keeping the CPU as low as possible unless needed.
ok deradt@@, sturm@@, "i like it's" djm@@ henning@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.13 2005/11/23 08:02:58 sturm Exp $	*/
d61 2
a62 2
	fprintf(stderr,"usage: %s [-ablmPSsvz] [-f sockname]"
		" [-C | -A | -L | -H]\n", __progname);
d89 1
a89 1
	return 0;
d133 1
a133 1
	return sock;
@


1.13
log
@permit apmd to run on systems without apm support
let apmd control hw.setperf manually or dynamically

tested by Chris Kuethe and beck@@, 'get it in' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.12 2005/11/15 01:25:48 jmc Exp $	*/
d61 2
a62 2
	fprintf(stderr,"usage: %s [-ablmPSsvz] [-f sockname] [-A | -L | -H]\n",
	    __progname);
d152 1
a152 1
	while ((ch = getopt(argc, argv, "AHLlmbvaPsSzf:")) != -1) {
d175 5
d256 1
@


1.12
log
@sync usage() w/ man page;
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.11 2005/03/30 20:00:55 deraadt Exp $	*/
d61 1
a61 1
	fprintf(stderr,"usage: %s [-ablmSsvz] [-f sockname]\n",
d145 1
d152 1
a152 1
	while ((ch = getopt(argc, argv, "lmbvasSzf:")) != -1) {
d170 15
d215 6
d235 1
d248 3
d283 2
d319 3
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.10 2005/03/29 16:25:20 miod Exp $	*/
d61 1
a61 1
	fprintf(stderr,"usage: %s [-v] [-z | -S] [-slbam] [-f socket]\n",
d69 1
a69 1
	fprintf(stderr,"usage: %s [-z | -S] [-f socket]\n",
@


1.10
log
@Allow an apm implementation to return -1 in the minutes_left field of the
apm_power_info struct, if it has no reasonable value to provide.

ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.9 2003/07/30 21:44:32 deraadt Exp $	*/
d83 1
a83 1
		return (1);
a88 1

a132 1

a198 1
		case '?':
@


1.9
log
@indents; jfb ok
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.8 2003/06/11 23:33:25 deraadt Exp $	*/
d247 8
a254 3
			if (domin)
				printf("%d\n",
				    reply.batterystate.minutes_left);
d281 9
a289 2
			printf("Battery life estimate: %d minutes\n",
			    reply.batterystate.minutes_left);
@


1.8
log
@some ansification, some de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.7 2002/09/06 19:14:47 deraadt Exp $	*/
d61 1
a61 1
    fprintf(stderr,"usage: %s [-v] [-z | -S] [-slbam] [-f socket]\n",
d63 1
a63 1
    exit(1);
d69 1
a69 1
    fprintf(stderr,"usage: %s [-z | -S] [-f socket]\n",
d71 1
a71 1
    exit(1);
d83 1
a83 1
		return 1;
d87 1
a87 1
		return 1;
d153 2
a154 2
	while ((ch = getopt(argc, argv, "lmbvasSzf:")) != -1)
		switch(ch) {
d205 6
d212 21
a232 1
		fd = open_socket(sockname);
d234 2
a235 2
		if (!strcmp(__progname, "zzz"))
			return (do_zzz(fd, action));
d237 18
a254 17
		switch (action) {
		case NONE:
			action = GETSTATUS;
			verbose = doac = dopct = dobstate = dostatus = domin =
			    TRUE;
			/* fallthrough */
		case GETSTATUS:
			if (fd == -1) {
				/* open the device directly and get status */
				fd = open(_PATH_APM_NORMAL, O_RDONLY);
				if (ioctl(fd, APM_IOC_GETPOWER,
				    &reply.batterystate) == 0)
					goto printval;
			}
		case SUSPEND:
		case STANDBY:
			command.action = action;
a255 2
		default:
			usage();
d257 7
a263 13

		if ((rval = send_command(fd, &command, &reply)) == 0) {
			switch (action) {
			case GETSTATUS:
			printval:
				if (verbose) {
					if (dobstate)
						printf("Battery state: %s\n",
						    battstate(reply.batterystate.battery_state));
					if (dopct)
						printf("Battery remaining: %d percent\n",
						    reply.batterystate.battery_life);
					if (domin) {
d265 10
a274 7
						if (reply.batterystate.battery_state == APM_BATT_CHARGING)
							printf("Remaining battery recharge time estimate: %d minutes\n",
							    reply.batterystate.minutes_left);
						else if (reply.batterystate.minutes_left == 0 &&
						    reply.batterystate.battery_life > 10)
							printf("Battery life estimate: not available\n");
						else
d276 2
a277 27
						printf("Battery life estimate: %d minutes\n",
						    reply.batterystate.minutes_left);
					}
					if (doac)
						printf("A/C adapter state: %s\n",
						    ac_state(reply.batterystate.ac_state));
					if (dostatus)
						printf("Power management enabled\n");
				} else {
					if (dobstate)
						printf("%d\n",
						    reply.batterystate.battery_state);
					if (dopct)
						printf("%d\n",
						    reply.batterystate.battery_life);
					if (domin)
						printf("%d\n",
						    reply.batterystate.minutes_left);
					if (doac)
						printf("%d\n",
						    reply.batterystate.ac_state);
					if (dostatus)
						printf("1\n");
				}
				break;
			default:
				break;
d279 20
a298 12
		switch (reply.newstate) {
		case SUSPEND:
			printf("System will enter suspend mode momentarily.\n");
			break;
		case STANDBY:
			printf("System will enter standby mode momentarily.\n");
			break;
		default:
			break;
		}
	} else
		errx(rval, "cannot get reply from APM daemon");
@


1.7
log
@put some code after default:
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.6 2001/11/14 22:20:22 miod Exp $	*/
d75 1
a75 3
send_command(int fd,
	     struct apm_command *cmd,
	     struct apm_reply *reply)
@


1.6
log
@On macppc, print the recharge time estimate as a recharge time estimate, not
a battery life estimate, when the battery is charging.
Also, if the ac switched state and the life time, whatever it will be a
life estimate or a recharge estimate, has been reset to zero, print it as
not available.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.5 2001/07/06 21:08:00 mickey Exp $	*/
d282 1
d292 1
@


1.5
log
@cleanup and knf
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.4 2001/07/05 20:10:32 mickey Exp $	*/
d246 10
a255 1
					if (domin)
d258 1
@


1.4
log
@remove -d, fix manual, document -s option; mostly from Kevin Steves <stevesk@@pobox.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.3 1998/10/29 18:21:44 mickey Exp $	*/
a32 1
#include <errno.h>
d36 1
a39 1
#include <sys/time.h>
a50 1
extern char *optarg;
d54 1
a54 1
int do_zzz(const char *pn, enum apm_action action);
d56 1
a56 3
int send_command(int fd,
		 struct apm_command *cmd,
		 struct apm_reply *reply);
d79 2
a80 2
    /* send a command to the apm daemon */
    cmd->vno = APMD_VNO;
d82 8
a89 4
    if (send(fd, cmd, sizeof(*cmd), 0) == sizeof(*cmd)) {
	if (recv(fd, reply, sizeof(*reply), 0) != sizeof(*reply)) {
	    warn("invalid reply from APM daemon");
	    return 1;
d91 2
a92 5
    } else {
	warn("invalid send to APM daemon");
	return 1;
    }
    return 0;
d96 1
a96 1
do_zzz(const char *pn, enum apm_action action)
d98 17
a114 21
    struct apm_command command;
    struct apm_reply reply;
    int fd;

    switch (action) {
    case NONE:
    case SUSPEND:
	command.action = SUSPEND;
	break;
    case STANDBY:
	command.action = STANDBY;
	break;
    default:
	zzusage();
    }
    fd = open_socket(pn);

    if (fd == -1)
	err(1, "cannot open connection to APM daemon");
    printf("Suspending system...\n");
    exit(send_command(fd, &command, &reply));
d120 16
a135 2
    int sock, errr;
    struct sockaddr_un s_un;
d137 1
a137 14
    sock = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sock == -1)
	err(1, "cannot create local socket");

    s_un.sun_family = AF_UNIX;
    strncpy(s_un.sun_path, sockname, sizeof(s_un.sun_path));
    s_un.sun_len = SUN_LEN(&s_un);
    if (connect(sock, (struct sockaddr *)&s_un, s_un.sun_len) == -1) {
	errr = errno;
	close(sock);
	errno = errr;
	return -1;
    }
    return sock;
d143 142
a284 145
    char *sockname = _PATH_APM_SOCKET;
    int ch;
    int dostatus = FALSE;
    int doac = FALSE;
    int dopct = FALSE;
    int dobstate = FALSE;
    int domin = FALSE;
    int fd;
    int rval;
    int verbose = FALSE;
    enum apm_action action = NONE;
    struct apm_command command;
    struct apm_reply reply;

    while ((ch = getopt(argc, argv, "lmbvasSzf:")) != -1)
	switch(ch) {
	case 'v':
	    verbose = TRUE;
	    break;
	case 'f':
	    sockname = optarg;
	    break;
	case 'z':
	    if (action != NONE)
		usage();
	    action = SUSPEND;
	    break;
	case 'S':
	    if (action != NONE)
		usage();
	    action = STANDBY;
	    break;
	case 's':
	    if (action != NONE && action != GETSTATUS)
		usage();
	    dostatus = TRUE;
	    action = GETSTATUS;
	    break;
	case 'b':
	    if (action != NONE && action != GETSTATUS)
		usage();
	    dobstate = TRUE;
	    action = GETSTATUS;
	    break;
	case 'l':
	    if (action != NONE && action != GETSTATUS)
		usage();
	    dopct = TRUE;
	    action = GETSTATUS;
	    break;
	case 'm':
	    if (action != NONE && action != GETSTATUS)
		usage();
	    domin = TRUE;
	    action = GETSTATUS;
	    break;
	case 'a':
	    if (action != NONE && action != GETSTATUS)
		usage();
	    doac = TRUE;
	    action = GETSTATUS;
	    break;
	case '?':
	default:
	    usage();
	}

    if (!strcmp(__progname, "zzz")) {
	return (do_zzz(sockname, action));
    }

    fd = open_socket(sockname);

    switch (action) {
    case NONE:
	verbose = doac = dopct = dobstate = dostatus = domin = TRUE;
	action = GETSTATUS;
	/* fallthrough */
    case GETSTATUS:
	if (fd == -1) {
	    /* open the device directly and get status */
	    fd = open(_PATH_APM_NORMAL, O_RDONLY);
	    if (fd == -1) {
		err(1, "cannot contact APM daemon and cannot open " _PATH_APM_NORMAL);
	    }
	    if (ioctl(fd, APM_IOC_GETPOWER, &reply.batterystate) == 0)
		goto printval;
	}
    case SUSPEND:
    case STANDBY:
	command.action = action;
	break;
    default:
	usage();
    }
    
    if ((rval = send_command(fd, &command, &reply)) == 0) {
	switch (action) {
	case GETSTATUS:
    printval:
	    if (verbose) {
		if (dobstate)
		    printf("Battery state: %s\n",
			   battstate(reply.batterystate.battery_state));
		if (dopct)
		    printf("Battery remaining: %d percent\n",
			   reply.batterystate.battery_life);
		if (domin)
		    printf("Battery life estimate: %d minutes\n",
			   reply.batterystate.minutes_left);
		if (doac)
		    printf("A/C adapter state: %s\n",
			   ac_state(reply.batterystate.ac_state));
		if (dostatus)
		    printf("Power management enabled\n");
	    } else {
		if (dobstate)
		    printf("%d\n", reply.batterystate.battery_state);
		if (dopct)
		    printf("%d\n", reply.batterystate.battery_life);
		if (domin)
		    printf("%d\n", reply.batterystate.minutes_left);
		if (doac)
		    printf("%d\n", reply.batterystate.ac_state);
		if (dostatus)
		    printf("1\n");
	    }
	    break;
	default:
	    break;
	}
	switch (reply.newstate) {
	case SUSPEND:
	    printf("System will enter suspend mode momentarily.\n");
	    break;
	case STANDBY:
	    printf("System will enter standby mode momentarily.\n");
	    break;
	default:
	    break;
	}
    } else
	errx(rval, "cannot get reply from APM daemon");

    return (0);
@


1.3
log
@provide an option to retreive battery life estimate in minutes
from Martin Forseen <maf@@firedoor.se>
some corrections from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: apm.c,v 1.2 1997/09/12 04:07:14 millert Exp $	*/
a52 4
extern int optind;
extern int optopt;
extern int opterr;
extern int optreset;
d163 1
a163 1
    while ((ch = getopt(argc, argv, "lmbvadsSzf:")) != -1)
@


1.2
log
@Kill extra newline in err()/warn().
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
a69 1
    fprintf(stderr,"usage: %s [-v] [-z | -S] [-slba] [-f socket]\n",
d150 1
a150 1
void
d159 1
d167 1
a167 1
    while ((ch = getopt(argc, argv, "lbvadsSzf:")) != -1)
d203 6
d221 1
a221 1
	exit(do_zzz(sockname, action));
d228 1
a228 1
	verbose = doac = dopct = dobstate = dostatus = TRUE;
d255 1
a255 1
		    printf("Battery charge state: %s\n",
d260 3
d264 2
a265 1
		    printf("A/C adapter state: %s\n", ac_state(reply.batterystate.ac_state));
d273 2
d297 1
a297 1
    exit(0);
@


1.1
log
@Pull in John Kohl's most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen).
@
text
@d1 2
d92 1
a92 1
	    warn("invalid reply from APM daemon\n");
d282 1
a282 1
	errx(rval, "cannot get reply from APM daemon\n");
@
