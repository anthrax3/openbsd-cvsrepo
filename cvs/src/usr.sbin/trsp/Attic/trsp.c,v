head	1.11;
access;
symbols
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.14
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.12
	OPENBSD_2_8:1.7.0.10
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2002.09.18.06.06.13;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	2002.06.19.08.45.52;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.17.19.42.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.28.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.07.08.22.13.33;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.09.12.04.07.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.09.08.09.23.17;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.12.22.03.29.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.03.18.06.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.09.10.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.30;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.11
log
@bye bye
@
text
@/*	$OpenBSD: trsp.c,v 1.10 2002/06/19 08:45:52 deraadt Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1985, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1985, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char sccsid[] = "@@(#)trsp.c	8.1 (Berkeley) 6/6/93";
#endif /* not lint */

#include <sys/cdefs.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#define PRUREQUESTS
#include <sys/protosw.h>

#include <net/route.h>
#include <net/if.h>

#define TCPSTATES
#include <netinet/tcp_fsm.h>
#define	TCPTIMERS
#include <netinet/tcp_timer.h>

#include <netns/ns.h>
#include <netns/sp.h>
#include <netns/idp.h>
#include <netns/spidp.h>
#include <netns/spp_timer.h>
#include <netns/spp_var.h>
#include <netns/ns_pcb.h>
#include <netns/idp_var.h>
#define SANAMES
#include <netns/spp_debug.h>

#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <errno.h>
#include <kvm.h>
#include <nlist.h>
#include <paths.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

u_int32_t ntime;
int	sflag;
int	tflag;
int	jflag;
int	aflag;
int	zflag;
struct	nlist nl[] = {
#define	N_SPP_DEBUG	0		/* no sysctl */
	{ "_spp_debug" },
#define	N_SPP_DEBX	1		/* no sysctl */
	{ "_spp_debx" },
	{ NULL },
};

struct	spp_debug spp_debug[SPP_NDEBUG];
caddr_t	spp_pcbs[SPP_NDEBUG];
int	spp_debx;

kvm_t	*kd;

extern	char *__progname;

int	main(int, char *[]);
void	dotrace(caddr_t);
int	numeric(const void *, const void *);
void	spp_trace(short, short, struct sppcb *, struct sppcb *,
	    struct spidp *, int);
void	usage(void);

int
main(argc, argv)
	int argc;
	char *argv[];
{
	int ch, i, npcbs = 0;
	char *system, *core, *cp, errbuf[_POSIX2_LINE_MAX];

	system = core = NULL;

	while ((ch = getopt(argc, argv, "azstjp:N:M:")) != -1) {
		switch (ch) {
		case 'a':
			++aflag;
			break;
		case 'z':
			++zflag;
			break;
		case 's':
			++sflag;
			break;
		case 't':
			++tflag;
			break;
		case 'j':
			++jflag;
			break;
		case 'p':
			if (npcbs >= SPP_NDEBUG)
				errx(1, "too many pcbs specified");
			errno = 0;
			spp_pcbs[npcbs++] = (caddr_t)strtoul(optarg, &cp, 16);
			if (*cp != '\0' || errno == ERANGE)
				errx(1, "invalid address: %s", optarg);
			break;
		case 'N':
			system = optarg;
			break;
		case 'M':
			core = optarg;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc)
		usage();

	/*
	 * Discard setgid privileges if not the running kernel so that bad
	 * guys can't print interesting stuff from kernel memory.
	 */
	if (core != NULL || system != NULL) {
		setegid(getgid());
		setgid(getgid());
	}

	kd = kvm_openfiles(system, core, NULL, zflag ? O_RDWR : O_RDONLY,
	    errbuf);
	if (kd == NULL)
		errx(1, "can't open kmem: %s", errbuf);

	setegid(getgid());
	setgid(getgid());

	if (kvm_nlist(kd, nl))
		errx(2, "%s: no namelist", system ? system : _PATH_UNIX);

	if (kvm_read(kd, nl[N_SPP_DEBX].n_value, &spp_debx,
	    sizeof(spp_debx)) != sizeof(spp_debx))
		errx(3, "spp_debx: %s", kvm_geterr(kd));
	printf("spp_debx=%d\n", spp_debx);

	if (kvm_read(kd, nl[N_SPP_DEBUG].n_value, spp_debug,
	    sizeof(spp_debug)) != sizeof(spp_debug))
		errx(3, "spp_debug: %s", kvm_geterr(kd));

	/*
	 * Here, we just want to clear out the old trace data and start over.
	 */
	if (zflag) {
		spp_debx = 0;
		(void) memset(spp_debug, 0, sizeof(spp_debug));

		if (kvm_write(kd, nl[N_SPP_DEBX].n_value, &spp_debx,
		    sizeof(spp_debx)) != sizeof(spp_debx))
			errx(4, "write spp_debx: %s", kvm_geterr(kd));
		
		if (kvm_write(kd, nl[N_SPP_DEBUG].n_value, spp_debug,
		    sizeof(spp_debug)) != sizeof(spp_debug))
			errx(4, "write spp_debug: %s", kvm_geterr(kd));

		exit(0);
	}

	/*
	 * If no control blocks have been specified, figure
	 * out how many distinct one we have and summarize
	 * them in spp_pcbs for sorting the trace records
	 * below.
	 */
	if (npcbs == 0) {
		for (i = 0; i < SPP_NDEBUG; i++) {
			struct spp_debug *sd = &spp_debug[i];
			int j;

			if (sd->sd_cb == 0)
				continue;
			for (j = 0; j < npcbs; j++)
				if (spp_pcbs[j] == sd->sd_cb)
					break;
			if (j >= npcbs)
				spp_pcbs[npcbs++] = sd->sd_cb;
		}
	}
	qsort(spp_pcbs, npcbs, sizeof (caddr_t), numeric);
	if (jflag) {
		cp = "";

		for (i = 0; i < npcbs; i++) {
			printf("%s%lx", cp, (long)spp_pcbs[i]);
			cp = ", ";
		}
		if (*cp)
			putchar('\n');
	} else {
		for (i = 0; i < npcbs; i++) {
			printf("\n%lx:\n", (long)spp_pcbs[i]);
			dotrace(spp_pcbs[i]);
		}
	}
	exit(0);
}

void
dotrace(sppcb)
	caddr_t sppcb;
{
	struct spp_debug *sd;
	int i;

	for (i = spp_debx % SPP_NDEBUG; i < SPP_NDEBUG; i++) {
		sd = &spp_debug[i];
		if (sppcb && sd->sd_cb != sppcb)
			continue;
		ntime = ntohl(sd->sd_time);
		spp_trace(sd->sd_act, sd->sd_ostate, (struct sppcb *)sd->sd_cb,
		    &sd->sd_sp, &sd->sd_si, sd->sd_req);
	}
	for (i = 0; i < spp_debx % SPP_NDEBUG; i++) {
		sd = &spp_debug[i];
		if (sppcb && sd->sd_cb != sppcb)
			continue;
		ntime = ntohl(sd->sd_time);
		spp_trace(sd->sd_act, sd->sd_ostate, (struct sppcb *)sd->sd_cb,
		    &sd->sd_sp, &sd->sd_si, sd->sd_req);
	}
}

int
numeric(v1, v2)
	const void *v1, *v2;
{
	const caddr_t *c1 = v1;
	const caddr_t *c2 = v2;
	int rv;

	if (*c1 < *c2)
		rv = -1;
	else if (*c1 > *c2)
		rv = 1;
	else
		rv = 0;

	return (rv);
}

void
spp_trace(act, ostate, asp, sp, si, req)
	short act, ostate;
	struct sppcb *asp, *sp;
	struct spidp *si;
	int req;
{
	u_int16_t seq, ack, len, alo;
	int flags;
	char *cp;

	if (ostate >= TCP_NSTATES)
		ostate = 0;
	if (act > SA_DROP)
		act = SA_DROP;
	printf("\n");
	printf("%03d %s:%s", (ntime/10) % 1000, tcpstates[ostate],
	    sanames[act]);

	if (si != 0) {
		seq = si->si_seq;
		ack = si->si_ack;
		alo = si->si_alo;
		len = si->si_len;
		switch (act) {
		case SA_RESPOND:
		case SA_OUTPUT:
				NTOHS(seq);
				NTOHS(ack);
				NTOHS(alo);
				NTOHS(len);
		case SA_INPUT:
		case SA_DROP:
			if (aflag)
				printf("\n\tsna=%s\tdna=%s",
				    ns_ntoa(si->si_sna), ns_ntoa(si->si_dna));
			printf("\n\t");
#define p1(name, f) { \
	printf("%s = %x, ", name, f); \
}
			p1("seq", seq);
			p1("ack", ack);
			p1("alo", alo);
			p1("len", len);
			flags = si->si_cc;
			printf("flags=%x", flags);
#define pf(name, f) { \
	if (flags & f) { \
		printf("%s%s", cp, name); \
		cp = ","; \
	} \
}
			if (flags) {
				cp = "<";
				pf("SP_SP", SP_SP);
				pf("SP_SA", SP_SA);
				pf("SP_OB", SP_OB);
				pf("SP_EM", SP_EM);
				printf(">");
			}
			printf(", ");
#define p2(name, f) { \
	printf("%s = %x, ", name, f); \
}
			p2("sid", si->si_sid);
			p2("did", si->si_did);
			p2("dt", si->si_dt);
			printf("\n\tsna=%s\tdna=%s", ns_ntoa(si->si_sna),
			    ns_ntoa(si->si_dna));
		}
	}
	if(act == SA_USER) {
		printf("\treq=%s", prurequests[req&0xff]);
		if ((req & 0xff) == PRU_SLOWTIMO)
			printf("<%s>", tcptimers[req>>8]);
	}
	printf(" -> %s", tcpstates[sp->s_state]);

	/* print out internal state of sp !?! */
	printf("\n");
	if (sp == 0)
		return;
#define p3(name, f)  { \
	printf("%s = %x, ", name, f); \
}
	if (sflag) {
		printf("\t");
		p3("rack", sp->s_rack);
		p3("ralo", sp->s_ralo);
		p3("smax", sp->s_smax);
		p3("snxt", sp->s_snxt);
		p3("flags", sp->s_flags);
#undef pf
#define pf(name, f) { \
	if (flags & f) { \
		printf("%s%s", cp, name); \
		cp = ","; \
	} \
}
		flags = sp->s_flags;
		if (flags || sp->s_oobflags) {
			cp = "<";
			pf("ACKNOW", SF_ACKNOW);
			pf("DELACK", SF_DELACK);
			pf("HI", SF_HI);
			pf("HO", SF_HO);
			pf("PI", SF_PI);
			pf("WIN", SF_WIN);
			pf("RXT", SF_RXT);
			pf("RVD", SF_RVD);
			flags = sp->s_oobflags;
			pf("SOOB", SF_SOOB);
			pf("IOOB", SF_IOOB);
			printf(">");
		}
	}
	/* print out timers? */
	if (tflag) {
		int i;

		cp = "\t";

		printf("\n\tTIMERS: ");
		p3("idle", sp->s_idle);
		p3("force", sp->s_force);
		p3("rtseq", sp->s_rtseq);
		for (i = 0; i < TCPT_NTIMERS; i++) {
			if (sp->s_timer[i] == 0)
				continue;
			printf("%s%s=%d", cp, tcptimers[i], sp->s_timer[i]);
			if (i == TCPT_REXMT)
				printf(" (s_rxtshft=%d)", sp->s_rxtshift);
			cp = ", ";
		}
		if (*cp != '\t')
			putchar('\n');
	}
}

void
usage()
{

	fprintf(stderr, "usage: %s [-azstj] [-p hex-address]"
	    " [-N system] [-M core]\n", __progname);
	exit(1);
}
@


1.10
log
@mark which nlist[] kmem entries are not needed in the sysctl case, and which are
@
text
@d1 1
a1 1
/*	$OpenBSD: trsp.c,v 1.9 2002/02/17 19:42:40 millert Exp $	*/
@


1.9
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: trsp.c,v 1.8 2002/02/16 21:28:10 millert Exp $	*/
d128 1
a128 1
#define	N_SPP_DEBUG	0
d130 1
a130 1
#define	N_SPP_DEBX	1
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: trsp.c,v 1.7 1998/07/08 22:13:33 deraadt Exp $	*/
d146 2
a147 2
void	spp_trace __P((short, short, struct sppcb *, struct sppcb *,
	    struct spidp *, int));
@


1.7
log
@whack kmem gid after kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: trsp.c,v 1.6 1997/09/12 04:07:23 millert Exp $	*/
d143 3
a145 3
int	main __P((int, char *[]));
void	dotrace __P((caddr_t));
int	numeric __P((const void *, const void *));
d148 1
a148 1
void	usage __P((void));
@


1.6
log
@Kill extra newline in err()/warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: trsp.c,v 1.5 1997/09/08 09:23:17 deraadt Exp $	*/
d214 3
@


1.5
log
@use -lkvm, various other fixes; thorpej
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d236 1
a236 1
			errx(4, "write spp_debx: %s\n", kvm_geterr(kd));
d240 1
a240 1
			errx(4, "write spp_debug: %s\n", kvm_geterr(kd));
@


1.4
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 39
d41 2
a42 2
 * Copyright (c) 1985 Regents of the University of California.
 * All rights reserved.
d75 2
a76 2
"@@(#) Copyright (c) 1985 Regents of the University of California.\n\
 All rights reserved.\n";
d80 1
a80 2
/*static char sccsid[] = "from: @@(#)trsp.c	6.8 (Berkeley) 3/2/91";*/
static char rcsid[] = "$Id: trsp.c,v 1.3 1996/06/03 18:06:23 deraadt Exp $";
d109 2
d113 1
d116 4
d121 1
a121 1
unsigned long	ntime;
a126 1
int	numeric();
d128 1
d130 1
d132 1
a132 1
	0
d134 1
d139 12
d153 1
a153 1
	char **argv;
d155 2
a156 2
	int i, mask = 0, npcbs = 0;
	char *system, *core;
d158 1
a158 2
	system = _PATH_UNIX;
	core = _PATH_KMEM;
d160 33
a192 31
	argc--, argv++;
again:
	if (argc > 0 && !strcmp(*argv, "-a")) {
		aflag++, argc--, argv++;
		goto again;
	}
	if (argc > 0 && !strcmp(*argv, "-z")) {
		zflag++, argc--, argv++;
		goto again;
	}
	if (argc > 0 && !strcmp(*argv, "-s")) {
		sflag++, argc--, argv++;
		goto again;
	}
	if (argc > 0 && !strcmp(*argv, "-t")) {
		tflag++, argc--, argv++;
		goto again;
	}
	if (argc > 0 && !strcmp(*argv, "-j")) {
		jflag++, argc--, argv++;
		goto again;
	}
	if (argc > 0 && !strcmp(*argv, "-p")) {
		argc--, argv++;
		if (argc < 1) {
			fprintf(stderr, "-p: missing sppcb address\n");
			exit(1);
		}
		if (npcbs >= SPP_NDEBUG) {
			fprintf(stderr, "-p: too many pcb's specified\n");
			exit(1);
a193 13
		sscanf(*argv, "%x", &spp_pcbs[npcbs++]);
		argc--, argv++;
		goto again;
	}
	if (argc > 0) {
		system = *argv;
		argc--, argv++;
		mask++;
	}
	if (argc > 0) {
		core = *argv;
		argc--, argv++;
		mask++;
d195 6
d205 1
a205 1
	if (!strcmp(system, _PATH_UNIX) || !strcmp(core, _PATH_KMEM)) {
d210 11
a220 19
	(void) nlist(system, nl);
	if (nl[0].n_value == 0) {
		fprintf(stderr, "trsp: %s: no namelist\n", system);
		exit(1);
	}
	(void) close(0);
	if (open(core, 0) < 0) {
		fprintf(stderr, "trsp: "); perror(core);
		exit(2);
	}
	if (mask) {
		nl[0].n_value &= 0x7fffffff;
		nl[1].n_value &= 0x7fffffff;
	}
	(void) lseek(0, nl[1].n_value, 0);
	if (read(0, &spp_debx, sizeof (spp_debx)) != sizeof (spp_debx)) {
		fprintf(stderr, "trsp: "); perror("spp_debx");
		exit(3);
	}
d222 5
a226 5
	(void) lseek(0, nl[0].n_value, 0);
	if (read(0, spp_debug, sizeof (spp_debug)) != sizeof (spp_debug)) {
		fprintf(stderr, "trsp: "); perror("spp_debug");
		exit(3);
	}
a230 14
		char *cp = (char *) spp_debug,
		     *cplim = cp + sizeof(spp_debug);
		(void) close(0);
		if (open(core, 2) < 0) {
			fprintf(stderr, "trsp: "); perror(core);
			exit(2);
		}
		while(cp < cplim) *cp++ = 0;
		(void) lseek(0, nl[0].n_value, 0);
		if (write(0, spp_debug, sizeof (spp_debug)) != sizeof (spp_debug)) {
			fprintf(stderr, "trsp: "); perror("spp_debug");
			exit(3);
		}
		(void) lseek(0, nl[1].n_value, 0);
d232 10
a241 4
		if (write(0, &spp_debx, sizeof (spp_debx)) != sizeof (spp_debx)) {
			fprintf(stderr, "trsp: "); perror("spp_debx");
			exit(3);
		}
d244 1
d253 2
a254 2
			register int j;
			register struct spp_debug *sd = &spp_debug[i];
d267 1
a267 1
		char *cp = "";
d270 1
a270 1
			printf("%s%x", cp, spp_pcbs[i]);
d275 5
a279 5
		exit(0);
	}
	for (i = 0; i < npcbs; i++) {
		printf("\n%x:\n", spp_pcbs[i]);
		dotrace(spp_pcbs[i]);
d284 1
d286 1
a286 1
	register caddr_t sppcb;
d288 2
a289 2
	register int i;
	register struct spp_debug *sd;
d296 2
a297 2
		spp_trace(sd->sd_act, sd->sd_ostate, sd->sd_cb, &sd->sd_sp,
		    &sd->sd_si, sd->sd_req);
d304 2
a305 2
		spp_trace(sd->sd_act, sd->sd_ostate, sd->sd_cb, &sd->sd_sp,
		    &sd->sd_si, sd->sd_req);
d309 3
a311 2
ptime(ms)
	int ms;
d313 10
d324 1
a324 8
	printf("%03d ", (ms/10) % 1000);
}

numeric(c1, c2)
	caddr_t *c1, *c2;
{
	
	return (*c1 - *c2);
d327 1
d334 2
a335 2
	u_short seq, ack, len, alo;
	int flags, timer;
d338 4
a341 2
	if(ostate >= TCP_NSTATES) ostate = 0;
	if(act > SA_DROP) act = SA_DROP;
d343 2
a344 2
	ptime(ntime);
	printf("%s:%s", tcpstates[ostate], sanames[act]);
d354 4
a357 4
				seq = ntohs(seq);
				ack = ntohs(ack);
				alo = ntohs(alo);
				len = ntohs(len);
d360 3
a362 6
			if (aflag) {
				printf("\n\tsna=");
				ns_printhost(&si->si_sna);
				printf("\tdna=");
				ns_printhost(&si->si_dna);
			}
d366 1
a366 1
 }
d380 1
a380 1
				char *cp = "<";
d394 2
a395 4
			printf("\n\tsna=");
			ns_printhost(&si->si_sna);
			printf("\tdna=");
			ns_printhost(&si->si_dna);
d428 1
a428 1
			char *cp = "<";
d445 3
a447 2
		char *cp = "\t";
		register int i;
d466 2
a467 2
ns_printhost(p)
register struct ns_addr *p;
d470 3
a472 8
	printf("<net:%x%x,host:%4.4x%4.4x%4.4x,port:%x>",
			p->x_net.s_net[0],
			p->x_net.s_net[1],
			p->x_host.s_host[0],
			p->x_host.s_host[1],
			p->x_host.s_host[2],
			p->x_port);

a473 1

@


1.3
log
@do not rely on constant folding equivelance
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: trsp.c,v 1.2 1996/05/30 09:10:46 deraadt Exp $";
d152 2
a153 1
	if (!strcmp(system, _PATH_UNIX) || !strcmp(core, _PATH_KMEM))
d155 2
@


1.2
log
@revoke privs before opening kvm if user has specified mem/kernel paths
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: trsp.c,v 1.1.1.1 1995/10/18 08:48:30 deraadt Exp $";
d152 1
a152 1
	if (system != _PATH_UNIX || core != _PATH_KMEM)
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: trsp.c,v 1.2 1993/08/01 17:54:56 mycroft Exp $";
d148 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
