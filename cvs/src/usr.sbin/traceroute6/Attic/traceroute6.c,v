head	1.100;
access;
symbols
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.49.0.6
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.49.0.4
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.2
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.2
	OPENBSD_5_0:1.46.0.8
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.46.0.6
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.46.0.4
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.45.0.8
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.4
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.43.0.6
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.4
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.43.0.2
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.39.0.4
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.38.0.4
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	OPENBSD_3_3:1.34.0.2
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.15.0.4
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.100
date	2014.04.29.15.03.07;	author florian;	state dead;
branches;
next	1.99;

1.99
date	2014.04.23.09.24.36;	author florian;	state Exp;
branches;
next	1.98;

1.98
date	2014.04.23.09.23.30;	author florian;	state Exp;
branches;
next	1.97;

1.97
date	2014.04.23.09.22.34;	author florian;	state Exp;
branches;
next	1.96;

1.96
date	2014.04.23.09.20.15;	author florian;	state Exp;
branches;
next	1.95;

1.95
date	2014.04.23.09.19.23;	author florian;	state Exp;
branches;
next	1.94;

1.94
date	2014.04.23.09.18.27;	author florian;	state Exp;
branches;
next	1.93;

1.93
date	2014.04.23.09.17.10;	author florian;	state Exp;
branches;
next	1.92;

1.92
date	2014.04.23.09.16.11;	author florian;	state Exp;
branches;
next	1.91;

1.91
date	2014.04.23.09.13.00;	author florian;	state Exp;
branches;
next	1.90;

1.90
date	2014.04.23.09.11.35;	author florian;	state Exp;
branches;
next	1.89;

1.89
date	2014.04.23.09.10.53;	author florian;	state Exp;
branches;
next	1.88;

1.88
date	2014.04.23.09.09.28;	author florian;	state Exp;
branches;
next	1.87;

1.87
date	2014.04.23.08.59.35;	author florian;	state Exp;
branches;
next	1.86;

1.86
date	2014.04.23.08.56.31;	author florian;	state Exp;
branches;
next	1.85;

1.85
date	2014.04.23.08.53.49;	author florian;	state Exp;
branches;
next	1.84;

1.84
date	2014.04.23.08.51.32;	author florian;	state Exp;
branches;
next	1.83;

1.83
date	2014.04.23.08.44.50;	author florian;	state Exp;
branches;
next	1.82;

1.82
date	2014.04.18.16.58.02;	author florian;	state Exp;
branches;
next	1.81;

1.81
date	2014.04.18.16.56.25;	author florian;	state Exp;
branches;
next	1.80;

1.80
date	2014.04.18.16.48.19;	author florian;	state Exp;
branches;
next	1.79;

1.79
date	2014.04.18.16.33.21;	author florian;	state Exp;
branches;
next	1.78;

1.78
date	2014.04.18.16.30.00;	author florian;	state Exp;
branches;
next	1.77;

1.77
date	2014.04.18.16.26.47;	author florian;	state Exp;
branches;
next	1.76;

1.76
date	2014.04.18.16.23.00;	author florian;	state Exp;
branches;
next	1.75;

1.75
date	2014.04.18.16.20.56;	author florian;	state Exp;
branches;
next	1.74;

1.74
date	2014.04.18.16.11.36;	author florian;	state Exp;
branches;
next	1.73;

1.73
date	2014.04.18.16.07.54;	author florian;	state Exp;
branches;
next	1.72;

1.72
date	2014.04.18.16.02.08;	author florian;	state Exp;
branches;
next	1.71;

1.71
date	2014.04.18.16.00.38;	author florian;	state Exp;
branches;
next	1.70;

1.70
date	2014.04.18.15.58.43;	author florian;	state Exp;
branches;
next	1.69;

1.69
date	2014.03.27.09.32.18;	author florian;	state Exp;
branches;
next	1.68;

1.68
date	2014.03.24.11.11.49;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2014.03.18.10.11.36;	author florian;	state Exp;
branches;
next	1.66;

1.66
date	2014.03.18.10.11.00;	author florian;	state Exp;
branches;
next	1.65;

1.65
date	2014.03.18.10.10.17;	author florian;	state Exp;
branches;
next	1.64;

1.64
date	2014.03.18.10.09.37;	author florian;	state Exp;
branches;
next	1.63;

1.63
date	2014.03.18.10.08.24;	author florian;	state Exp;
branches;
next	1.62;

1.62
date	2014.03.18.10.06.39;	author florian;	state Exp;
branches;
next	1.61;

1.61
date	2014.03.10.19.58.43;	author florian;	state Exp;
branches;
next	1.60;

1.60
date	2014.03.10.19.57.24;	author florian;	state Exp;
branches;
next	1.59;

1.59
date	2014.03.10.19.56.58;	author florian;	state Exp;
branches;
next	1.58;

1.58
date	2014.01.24.15.28.03;	author florian;	state Exp;
branches;
next	1.57;

1.57
date	2014.01.24.15.26.32;	author florian;	state Exp;
branches;
next	1.56;

1.56
date	2014.01.24.15.22.10;	author florian;	state Exp;
branches;
next	1.55;

1.55
date	2014.01.24.15.16.13;	author florian;	state Exp;
branches;
next	1.54;

1.54
date	2014.01.24.15.14.31;	author florian;	state Exp;
branches;
next	1.53;

1.53
date	2014.01.24.15.12.29;	author florian;	state Exp;
branches;
next	1.52;

1.52
date	2013.11.12.19.36.30;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2013.10.26.21.21.45;	author sthen;	state Exp;
branches;
next	1.50;

1.50
date	2013.10.21.08.47.10;	author phessler;	state Exp;
branches;
next	1.49;

1.49
date	2012.04.06.17.43.03;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2012.02.15.08.22.02;	author jmc;	state Exp;
branches;
next	1.47;

1.47
date	2012.02.10.22.50.48;	author sthen;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2008.03.24.16.11.06;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2008.03.15.16.43.59;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.19.14.47.45;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2006.12.15.06.00.12;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.16.02.20.50;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.10.20.11.02;	author jmc;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.03.01.01.14;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.01.18.32.21;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.25.03.25.49;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.11.23.33.30;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.02.23.36.55;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.21.08.55.14;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.21.08.51.22;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.21.08.00.08;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2002.10.24.12.58.45;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.23.06.45.13;	author mark;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.08.01.31.46;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.30.07.23.50;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.27.00.39.36;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.08.23.53.21;	author stevesk;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.29.07.46.11;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.09.02.39.17;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.09.02.15.54;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.02.06.42.29;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.26.13.24.54;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.26.13.15.18;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.21.19.11.08;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.19.02.34.10;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.28.10;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.26.06.23.02;	author mpech;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.12.19.10.48;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.22.15.17.25;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.07.21.47.31;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.07.16.05.45;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.30.16.00.29;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.12.16.37.10;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.05.12.58.42;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.20.17.43.46;	author angelos;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.04.20.07.57.41;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.20.07.52.18;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.20.07.50.54;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.20.07.49.47;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.12.03.56.44;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.02.07.44.08;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.16.06.04.27;	author itojun;	state Exp;
branches;
next	;

1.8.2.1
date	2000.10.06.21.24.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.100
log
@Move traceroute6 to the attic, fully merged into traceroute.
@
text
@/*	$OpenBSD: traceroute6.c,v 1.99 2014/04/23 09:24:36 florian Exp $	*/
/*	$KAME: traceroute6.c,v 1.63 2002/10/24 12:53:25 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Van Jacobson.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * traceroute host  - trace the route ip packets follow going to "host".
 *
 * Attempt to trace the route an ip packet would follow to some
 * internet host.  We find out intermediate hops by launching probe
 * packets with a small ttl (time to live) then listening for an
 * icmp "time exceeded" reply from a gateway.  We start our probes
 * with a ttl of one and increase by one until we get an icmp "port
 * unreachable" (which means we got to "host") or hit a max (which
 * defaults to 30 hops & can be changed with the -m flag).  Three
 * probes (change with -q flag) are sent at each ttl setting and a
 * line is printed showing the ttl, address of the gateway and
 * round trip time of each probe.  If the probe answers come from
 * different gateways, the address of each responding system will
 * be printed.  If there is no response within a 5 sec. timeout
 * interval (changed with the -w flag), a "*" is printed for that
 * probe.
 *
 * Probe packets are UDP format.  We don't want the destination
 * host to process them so the destination port is set to an
 * unlikely value (if some clod on the destination is using that
 * value, it can be changed with the -p flag).
 *
 * A sample use might be:
 *
 *     [yak 71]% traceroute nis.nsf.net.
 *     traceroute to nis.nsf.net (35.1.1.48), 30 hops max, 56 byte packet
 *      1  helios.ee.lbl.gov (128.3.112.1)  19 ms  19 ms  0 ms
 *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms
 *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms
 *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  39 ms
 *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  39 ms  39 ms  39 ms
 *      6  128.32.197.4 (128.32.197.4)  40 ms  59 ms  59 ms
 *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  59 ms
 *      8  129.140.70.13 (129.140.70.13)  99 ms  99 ms  80 ms
 *      9  129.140.71.6 (129.140.71.6)  139 ms  239 ms  319 ms
 *     10  129.140.81.7 (129.140.81.7)  220 ms  199 ms  199 ms
 *     11  nic.merit.edu (35.1.1.48)  239 ms  239 ms  239 ms
 *
 * Note that lines 2 & 3 are the same.  This is due to a buggy
 * kernel on the 2nd hop system -- lbl-csam.arpa -- that forwards
 * packets with a zero ttl.
 *
 * A more interesting example is:
 *
 *     [yak 72]% traceroute allspice.lcs.mit.edu.
 *     traceroute to allspice.lcs.mit.edu (18.26.0.115), 30 hops max
 *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms
 *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  19 ms  19 ms
 *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  19 ms
 *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  19 ms  39 ms  39 ms
 *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  20 ms  39 ms  39 ms
 *      6  128.32.197.4 (128.32.197.4)  59 ms  119 ms  39 ms
 *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  39 ms
 *      8  129.140.70.13 (129.140.70.13)  80 ms  79 ms  99 ms
 *      9  129.140.71.6 (129.140.71.6)  139 ms  139 ms  159 ms
 *     10  129.140.81.7 (129.140.81.7)  199 ms  180 ms  300 ms
 *     11  129.140.72.17 (129.140.72.17)  300 ms  239 ms  239 ms
 *     12  * * *
 *     13  128.121.54.72 (128.121.54.72)  259 ms  499 ms  279 ms
 *     14  * * *
 *     15  * * *
 *     16  * * *
 *     17  * * *
 *     18  ALLSPICE.LCS.MIT.EDU (18.26.0.115)  339 ms  279 ms  279 ms
 *
 * (I start to see why I'm having so much trouble with mail to
 * MIT.)  Note that the gateways 12, 14, 15, 16 & 17 hops away
 * either don't send ICMP "time exceeded" messages or send them
 * with a ttl too small to reach us.  14 - 17 are running the
 * MIT C Gateway code that doesn't send "time exceeded"s.  God
 * only knows what's going on with 12.
 *
 * The silent gateway 12 in the above may be the result of a bug in
 * the 4.[23]BSD network code (and its derivatives):  4.x (x <= 3)
 * sends an unreachable message using whatever ttl remains in the
 * original datagram.  Since, for gateways, the remaining ttl is
 * zero, the icmp "time exceeded" is guaranteed to not make it back
 * to us.  The behavior of this bug is slightly more interesting
 * when it appears on the destination system:
 *
 *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms
 *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  39 ms
 *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  39 ms  19 ms
 *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  19 ms
 *      5  ccn-nerif35.Berkeley.EDU (128.32.168.35)  39 ms  39 ms  39 ms
 *      6  csgw.Berkeley.EDU (128.32.133.254)  39 ms  59 ms  39 ms
 *      7  * * *
 *      8  * * *
 *      9  * * *
 *     10  * * *
 *     11  * * *
 *     12  * * *
 *     13  rip.Berkeley.EDU (128.32.131.22)  59 ms !  39 ms !  39 ms !
 *
 * Notice that there are 12 "gateways" (13 is the final
 * destination) and exactly the last half of them are "missing".
 * What's really happening is that rip (a Sun-3 running Sun OS3.5)
 * is using the ttl from our arriving datagram as the ttl in its
 * icmp reply.  So, the reply will time out on the return path
 * (with no notice sent to anyone since icmp's aren't sent for
 * icmp's) until we probe with a ttl that's at least twice the path
 * length.  I.e., rip is really only 7 hops away.  A reply that
 * returns with a ttl of 1 is a clue this problem exists.
 * Traceroute prints a "!" after the time if the ttl is <= 1.
 * Since vendors ship a lot of obsolete (DEC's Ultrix, Sun 3.x) or
 * non-standard (HPUX) software, expect to see this problem
 * frequently and/or take care picking the target host of your
 * probes.
 *
 * Other possible annotations after the time are !H, !N, !P (got a host,
 * network or protocol unreachable, respectively), !S or !F (source
 * route failed or fragmentation needed -- neither of these should
 * ever occur and the associated gateway is busted if you see one).  If
 * almost all the probes result in some kind of unreachable, traceroute
 * will give up and exit.
 *
 * Notes
 * -----
 * This program must be run by root or be setuid.  (I suggest that
 * you *don't* make it setuid -- casual use could result in a lot
 * of unnecessary traffic on our poor, congested nets.)
 *
 * This program requires a kernel mod that does not appear in any
 * system available from Berkeley:  A raw ip socket using proto
 * IPPROTO_RAW must interpret the data sent as an ip datagram (as
 * opposed to data to be wrapped in a ip datagram).  See the README
 * file that came with the source to this program for a description
 * of the mods I made to /sys/netinet/raw_ip.c.  Your mileage may
 * vary.  But, again, ANY 4.x (x < 4) BSD KERNEL WILL HAVE TO BE
 * MODIFIED TO RUN THIS PROGRAM.
 *
 * The udp port usage may appear bizarre (well, ok, it is bizarre).
 * The problem is that an icmp message only contains 8 bytes of
 * data from the original datagram.  8 bytes is the size of a udp
 * header so, if we want to associate replies with the original
 * datagram, the necessary information must be encoded into the
 * udp header (the ip id could be used but there's no way to
 * interlock with the kernel's assignment of ip id's and, anyway,
 * it would have taken a lot more kernel hacking to allow this
 * code to set the ip id).  So, to allow two or more users to
 * use traceroute simultaneously, we use this task's pid as the
 * source port (the high bit is set to move the port number out
 * of the "likely" range).  To keep track of which probe is being
 * replied to (so times and/or hop counts don't get confused by a
 * reply that was delayed in transit), we increment the destination
 * port number before each probe.
 *
 * Don't use this as a coding example.  I was trying to find a
 * routing problem and this code sort-of popped out after 48 hours
 * without sleep.  I was amazed it ever compiled, much less ran.
 *
 * I stole the idea for this program from Steve Deering.  Since
 * the first release, I've learned that had I attended the right
 * IETF working group meetings, I also could have stolen it from Guy
 * Almes or Matt Mathis.  I don't know (or care) who came up with
 * the idea first.  I envy the originators' perspicacity and I'm
 * glad they didn't keep the idea a secret.
 *
 * Tim Seaver, Ken Adelman and C. Philip Wood provided bug fixes and/or
 * enhancements to the original distribution.
 *
 * I've hacked up a round-trip-route version of this that works by
 * sending a loose-source-routed udp datagram through the destination
 * back to yourself.  Unfortunately, SO many gateways botch source
 * routing, the thing is almost worthless.  Maybe one day...
 *
 *  -- Van Jacobson (van@@helios.ee.lbl.gov)
 *     Tue Dec 20 03:50:13 PST 1988
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>

#include <netinet/in.h>

#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <netdb.h>
#include <stdio.h>
#include <err.h>
#include <poll.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#include <netinet/udp.h>

#define DUMMY_PORT 10010

#define	MAXPACKET	65535	/* max ip packet size */

#ifndef HAVE_GETIPNODEBYNAME
#define getipnodebyname(x, y, z, u)	gethostbyname2((x), (y))
#define freehostent(x)
#endif

/*
 * Format of the data in a (udp) probe packet.
 */
struct packetdata {
	u_char seq;		/* sequence number of this packet */
	u_int8_t ttl;		/* hop limit of the packet */
	u_char pad[2];
	u_int32_t sec;		/* time packet left */
	u_int32_t usec;
} __packed;

u_char	packet[512];		/* last inbound (icmp) packet */
u_char	*outpacket;		/* last output (udp) packet */

int	main(int, char *[]);
int	wait_for_reply(int, struct msghdr *);
void	dump_packet(void);
void	build_probe6(int, u_int8_t, int, struct sockaddr *);
void	send_probe(int, u_int8_t, int, struct sockaddr *);
struct udphdr *get_udphdr(struct ip6_hdr *, u_char *);
int	get_hoplim(struct msghdr *);
double	deltaT(struct timeval *, struct timeval *);
char	*pr_type(int);
int	packet_ok(int, struct msghdr *, int, int, int);
int	packet_ok6(struct msghdr *, int, int, int);
void	icmp_code(int, int, int *, int *);
void	icmp6_code(int, int *, int *);
void	print(struct sockaddr *, int, const char *);
const char *inetname(struct sockaddr *);
void	print_asn(struct sockaddr_storage *);
void	usage(void);

int rcvsock;			/* receive (icmp) socket file descriptor */
int sndsock;			/* send (udp) socket file descriptor */

struct msghdr rcvmhdr;
struct iovec rcviov[2];
int rcvhlim;
struct in6_pktinfo *rcvpktinfo;

int datalen;			/* How much data */
#define	ICMP6ECHOLEN	8

char *source = 0;
char *hostname;

int nprobes = 3;
u_int8_t max_hops = IPV6_DEFHLIM;
u_int8_t first_hop = 1;
u_int16_t srcport;
u_int16_t port = 32768+666;	/* start udp dest port # for probe packets */
u_char proto = IPPROTO_UDP;
u_int16_t ident;
int options;			/* socket options */
int verbose;
int waittime = 5;		/* time to wait for response (in seconds) */
int nflag;			/* print addresses numerically */
int dump;
int Aflag;			/* lookup ASN */

extern char *__progname;

int
main(int argc, char *argv[])
{
	int mib[4] = { CTL_NET, PF_INET6, IPPROTO_IPV6, IPV6CTL_DEFHLIM };
	int ttl_flag = 0, incflag = 1, sump = 0;
	char hbuf[NI_MAXHOST], *ep;
	int ch, i, on = 1, seq, probe, rcvcmsglen, error, minlen;
	struct addrinfo hints, *res;
	static u_char *rcvcmsgbuf;
	struct sockaddr_in6 from6, to6;
	struct sockaddr *from, *to;
	size_t size;
	u_int8_t hops;
	long l;
	uid_t uid;
	u_int rtableid;
	const char *errstr;
	socklen_t len;

	/*
	 * Receive ICMP
	 */
	if ((rcvsock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0)
		err(5, "socket(ICMPv6)");
	if ((sndsock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		err(5, "socket(SOCK_DGRAM)");

	/* revoke privs */
	uid = getuid();
	if (setresuid(uid, uid, uid) == -1)
		err(1, "setresuid");

	size = sizeof(i);
	if (sysctl(mib, sizeof(mib)/sizeof(mib[0]), &i, &size, NULL, 0) == -1)
		err(1, "sysctl");
	max_hops = i;

	/* specify to tell receiving interface */
	if (setsockopt(rcvsock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
	    sizeof(on)) < 0)
		err(1, "setsockopt(IPV6_RECVPKTINFO)");

	/* specify to tell value of hoplimit field of received IP6 hdr */
	if (setsockopt(rcvsock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on,
	    sizeof(on)) < 0)
		err(1, "setsockopt(IPV6_RECVHOPLIMIT)");

	seq = 0;

	while ((ch = getopt(argc, argv, "AcDdf:Ilm:np:q:Ss:w:vV:")) != -1)
		switch (ch) {
		case 'A':
			Aflag++;
			break;
		case 'c':
			incflag = 0;
			break;
		case 'd':
			options |= SO_DEBUG;
			break;
		case 'D':
			dump = 1;
			break;
		case 'f':
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l < 1 || l > max_hops)
				errx(1, "firsthop must be 1 to %u.", max_hops);
			first_hop = (u_int8_t)l;
			break;
		case 'I':
			proto = IPPROTO_ICMP;
			ident = htons(getpid() & 0xffff); /* same as ping6 */
			break;
		case 'l':
			ttl_flag++;
			break;
		case 'm':
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l < first_hop ||
			    l > IPV6_MAXHLIM)
				errx(1, "hoplimit must be %u to %u.", first_hop,
				    IPV6_MAXHLIM);
			max_hops = (u_int8_t)l;
			break;
		case 'n':
			nflag++;
			break;
		case 'p':
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l <= 0 || l >= 65536)
				errx(1, "port must be >0, <65536.");
			port = (u_int16_t)l;
			break;
		case 'q':
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l < 1 || l > INT_MAX)
				errx(1, "nprobes must be >0.");
			nprobes = (int)l;
			break;
		case 's':
			/*
			 * set the ip source address of the outbound
			 * probe (e.g., on a multi-homed host).
			 */
			source = optarg;
			break;
		case 'S':
			sump = 1;
			break;
		case 'v':
			verbose++;
			break;
		case 'V':
			rtableid = (unsigned int)strtonum(optarg, 0,
			    RT_TABLEID_MAX, &errstr);
			if (errstr)
				errx(1, "rtable value is %s: %s",
				    errstr, optarg);
			if (setsockopt(rcvsock, SOL_SOCKET, SO_RTABLE,
			    &rtableid, sizeof(rtableid)) == -1)
				err(1, "setsockopt SO_RTABLE");
			if (setsockopt(sndsock, SOL_SOCKET, SO_RTABLE,
			    &rtableid, sizeof(rtableid)) == -1)
				err(1, "setsockopt SO_RTABLE");
			break;
		case 'w':
			errno = 0;
			ep = NULL;
			l = strtol(optarg, &ep, 10);
			if (errno || !*optarg || *ep || l <= 1 || l > INT_MAX)
				errx(1, "wait must be >1 sec.");
			waittime = (int)l;
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc < 1 || argc > 2)
		usage();

	setvbuf(stdout, NULL, _IOLBF, 0);

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_INET6;
	hints.ai_socktype = SOCK_RAW;
	hints.ai_protocol = 0;
	hints.ai_flags = AI_CANONNAME;
	if ((error = getaddrinfo(*argv, NULL, &hints, &res)))
		errx(1, "%s", gai_strerror(error));

	switch (res->ai_family) {
	case AF_INET6:
		if (res->ai_addrlen != sizeof(to6))
			errx(1, "size of sockaddr mismatch");

		to = (struct sockaddr *)&to6;
		from = (struct sockaddr *)&from6;
		break;
	default:
		errx(1, "unsupported AF: %d", res->ai_family);
		break;
	}

	memcpy(to, res->ai_addr, res->ai_addrlen);

	hostname = res->ai_canonname ? strdup(res->ai_canonname) : *argv;
	if (!hostname)
		errx(1, "malloc");
	if (res->ai_next) {
		if (getnameinfo(res->ai_addr, res->ai_addrlen, hbuf,
		    sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
			strlcpy(hbuf, "?", sizeof(hbuf));
		warnx("Warning: %s has multiple "
		    "addresses; using %s\n", hostname, hbuf);
	}

	if (*++argv) {
		errno = 0;
		ep = NULL;
		l = strtol(*argv, &ep, 10);
		if (errno || !*argv || *ep || l < 0 || l > INT_MAX)
			errx(1, "datalen out of range");
		datalen = (int)l;
	}

	switch (to->sa_family) {
	case AF_INET6:
		if (proto == IPPROTO_ICMP)
			minlen = ICMP6ECHOLEN + sizeof(struct packetdata);
		else
			minlen = sizeof(struct packetdata);
		if (datalen < minlen)
			datalen = minlen;
		else if (datalen >= MAXPACKET)
			errx(1, "packet size must be %d <= s < %ld.\n", minlen,
			    (long)MAXPACKET);

		if ((outpacket = calloc(1, datalen)) == NULL)
			err(1, "calloc");

		/* initialize msghdr for receiving packets */
		rcviov[0].iov_base = (caddr_t)packet;
		rcviov[0].iov_len = sizeof(packet);
		rcvmhdr.msg_name = (caddr_t)&from6;
		rcvmhdr.msg_namelen = sizeof(from6);
		rcvmhdr.msg_iov = rcviov;
		rcvmhdr.msg_iovlen = 1;
		rcvcmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo)) +
		    CMSG_SPACE(sizeof(int));
	
		if ((rcvcmsgbuf = malloc(rcvcmsglen)) == NULL)
			errx(1, "malloc");
		rcvmhdr.msg_control = (caddr_t) rcvcmsgbuf;
		rcvmhdr.msg_controllen = rcvcmsglen;

		/*
		 * Send UDP or ICMP
		 */
		if (proto == IPPROTO_ICMP) {
			close(sndsock);
			sndsock = rcvsock;
		}

		/*
		 * Source selection
		 */
		memset(&from6, 0, sizeof(from6));
		if (source) {
			memset(&hints, 0, sizeof(hints));
			hints.ai_family = AF_INET6;
			hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
			hints.ai_flags = AI_NUMERICHOST;
			if ((error = getaddrinfo(source, "0", &hints, &res)))
				errx(1, "%s: %s", source, gai_strerror(error));
			if (res->ai_addrlen != sizeof(from6))
				errx(1, "size of sockaddr mismatch");
			memcpy(&from6, res->ai_addr, res->ai_addrlen);
			freeaddrinfo(res);
		} else {
			struct sockaddr_in6 nxt;
			int dummy;

			nxt = to6;
			nxt.sin6_port = htons(DUMMY_PORT);
			if ((dummy = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
				err(1, "socket");
			if (connect(dummy, (struct sockaddr *)&nxt,
			    nxt.sin6_len) < 0)
				err(1, "connect");
			len = sizeof(from6);
			if (getsockname(dummy, (struct sockaddr *)&from6,
			    &len) < 0)
				err(1, "getsockname");
			close(dummy);
		}

		from6.sin6_port = htons(0);
		if (bind(sndsock, (struct sockaddr *)&from6, from6.sin6_len) <
		    0)
			err(1, "bind sndsock");

		len = sizeof(from6);
		if (getsockname(sndsock, (struct sockaddr *)&from6, &len) < 0)
			err(1, "getsockname");
		srcport = ntohs(from6.sin6_port);
		break;
	default:
		errx(1, "unsupported AF: %d", to->sa_family);
		break;
	}

	if (options & SO_DEBUG) {
		(void) setsockopt(sndsock, SOL_SOCKET, SO_DEBUG,
		    (char *)&on, sizeof(on));
		(void) setsockopt(rcvsock, SOL_SOCKET, SO_DEBUG,
		    (char *)&on, sizeof(on));
	}

	if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *)&datalen,
	    sizeof(datalen)) < 0)
		err(6, "SO_SNDBUF");

	/*
	 * Message to users
	 */
	if (getnameinfo(to, to->sa_len, hbuf, sizeof(hbuf), NULL, 0,
	    NI_NUMERICHOST))
		strlcpy(hbuf, "(invalid)", sizeof(hbuf));
	fprintf(stderr, "traceroute6");
	fprintf(stderr, " to %s (%s)", hostname, hbuf);
	if (source)
		fprintf(stderr, " from %s", source);
	fprintf(stderr, ", %u hops max, %d byte packets\n",
	    max_hops, datalen);
	(void) fflush(stderr);

	if (first_hop > 1)
		printf("Skipping %u intermediate hops\n", first_hop - 1);

	/*
	 * Main loop
	 */
	for (hops = first_hop; hops <= max_hops; ++hops) {
		struct in6_addr lastaddr6;
		int got_there = 0, unreachable = 0, timeout = 0, loss;

		printf("%2u ", hops);
		memset(&lastaddr6, 0, sizeof(lastaddr6));
		for (probe = 0, loss = 0; probe < nprobes; ++probe) {
			int cc;
			struct timeval t1, t2;

			(void) gettimeofday(&t1, NULL);
			send_probe(++seq, hops, incflag, to);
			while ((cc = wait_for_reply(rcvsock, &rcvmhdr))) {
				(void) gettimeofday(&t2, NULL);
				i = packet_ok(to->sa_family, &rcvmhdr, cc, seq,
				    incflag);
				/* Skip short packet */
				if (i == 0)
					continue;
				if (to->sa_family == AF_INET6) {
					if (!IN6_ARE_ADDR_EQUAL(
					    &from6.sin6_addr, &lastaddr6)) {
						print(from, cc, rcvpktinfo ?
						    inet_ntop( AF_INET6,
						    &rcvpktinfo->ipi6_addr,
						    hbuf, sizeof(hbuf)) : "?");
						lastaddr6 = from6.sin6_addr;
					}
				} else
					errx(1, "unsupported AF: %d",
					    to->sa_family);

				printf("  %g ms", deltaT(&t1, &t2));
				if (ttl_flag)
					printf(" (%u)", rcvhlim);

				/* time exceeded in transit */
				if (i == -1)
					break;
				icmp_code(to->sa_family, i - 1, &got_there,
				    &unreachable);
				break;
			}
			if (cc == 0) {
				printf(" *");
				timeout++;
				loss++;
			}
			(void) fflush(stdout);
		}
		if (sump)
			printf(" (%d%% loss)", (loss * 100) / nprobes);
		putchar('\n');
		if (got_there ||
		    (unreachable && (unreachable + timeout) >= nprobes))
			break;
	}
	exit(0);
}

int
wait_for_reply(int sock, struct msghdr *mhdr)
{
	struct pollfd pfd[1];
	int cc = 0;

	pfd[0].fd = sock;
	pfd[0].events = POLLIN;
	pfd[0].revents = 0;

	if (poll(pfd, 1, waittime * 1000) > 0)
		cc = recvmsg(rcvsock, mhdr, 0);

	return(cc);
}

void
dump_packet(void)
{
	u_char *p;
	int i;

	fprintf(stderr, "packet data:");
	for (p = (u_char*)outpacket, i = 0; i < datalen; i++) {
		if ((i % 24) == 0)
			fprintf(stderr, "\n ");
		fprintf(stderr, " %02x", *p++);
	}
	fprintf(stderr, "\n");
}

void
build_probe6(int seq, u_int8_t hops, int iflag, struct sockaddr *to)
{
	struct timeval tv;
	struct packetdata *op;
	int i;

	i = hops;
	if (setsockopt(sndsock, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
	    (char *)&i, sizeof(i)) < 0)
		warn("setsockopt IPV6_UNICAST_HOPS");

	if (iflag)
		((struct sockaddr_in6*)to)->sin6_port = htons(port + seq);
	else
		((struct sockaddr_in6*)to)->sin6_port = htons(port);
	(void) gettimeofday(&tv, NULL);

	if (proto == IPPROTO_ICMP) {
		struct icmp6_hdr *icp = (struct icmp6_hdr *)outpacket;

		icp->icmp6_type = ICMP6_ECHO_REQUEST;
		icp->icmp6_code = 0;
		icp->icmp6_cksum = 0;
		icp->icmp6_id = ident;
		icp->icmp6_seq = htons(seq);
		op = (struct packetdata *)(outpacket + ICMP6ECHOLEN);
	} else
		op = (struct packetdata *)outpacket;
	op->seq = seq;
	op->ttl = hops;
	op->sec = htonl(tv.tv_sec);
	op->usec = htonl(tv.tv_usec);
}

void
send_probe(int seq, u_int8_t hops, int iflag, struct sockaddr *to)
{
	int i;

	switch (to->sa_family) {
	case AF_INET6:
		build_probe6(seq, hops, iflag, to);
		break;
	default:
		errx(1, "unsupported AF: %d", to->sa_family);
		break;
	}

	if (dump)
		dump_packet();

	i = sendto(sndsock, outpacket, datalen, 0, to, to->sa_len);
	if (i < 0 || i != datalen)  {
		if (i < 0)
			warn("sendto");
		printf("%s: wrote %s %d chars, ret=%d\n", __progname, hostname,
		    datalen, i);
		(void) fflush(stdout);
	}
}

int
get_hoplim(struct msghdr *mhdr)
{
	struct cmsghdr *cm;

	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
	    cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_HOPLIMIT &&
		    cm->cmsg_len == CMSG_LEN(sizeof(int)))
			return(*(int *)CMSG_DATA(cm));
	}

	return(-1);
}

double
deltaT(struct timeval *t1p, struct timeval *t2p)
{
	double dt;

	dt = (double)(t2p->tv_sec - t1p->tv_sec) * 1000.0 +
	    (double)(t2p->tv_usec - t1p->tv_usec) / 1000.0;
	return (dt);
}

/*
 * Convert an ICMP "type" field to a printable string.
 */
char *
pr_type(int t0)
{
	u_char t = t0 & 0xff;
	char *cp;

	switch (t) {
	case ICMP6_DST_UNREACH:
		cp = "Destination Unreachable";
		break;
	case ICMP6_PACKET_TOO_BIG:
		cp = "Packet Too Big";
		break;
	case ICMP6_TIME_EXCEEDED:
		cp = "Time Exceeded";
		break;
	case ICMP6_PARAM_PROB:
		cp = "Parameter Problem";
		break;
	case ICMP6_ECHO_REQUEST:
		cp = "Echo Request";
		break;
	case ICMP6_ECHO_REPLY:
		cp = "Echo Reply";
		break;
	case ICMP6_MEMBERSHIP_QUERY:
		cp = "Group Membership Query";
		break;
	case ICMP6_MEMBERSHIP_REPORT:
		cp = "Group Membership Report";
		break;
	case ICMP6_MEMBERSHIP_REDUCTION:
		cp = "Group Membership Reduction";
		break;
	case ND_ROUTER_SOLICIT:
		cp = "Router Solicitation";
		break;
	case ND_ROUTER_ADVERT:
		cp = "Router Advertisement";
		break;
	case ND_NEIGHBOR_SOLICIT:
		cp = "Neighbor Solicitation";
		break;
	case ND_NEIGHBOR_ADVERT:
		cp = "Neighbor Advertisement";
		break;
	case ND_REDIRECT:
		cp = "Redirect";
		break;
	default:
		cp = "Unknown";
		break;
	}
	return cp;
}

int
packet_ok(int af, struct msghdr *mhdr, int cc, int seq, int iflag)
{
	switch (af) {
	case AF_INET6:
		return packet_ok6(mhdr, cc, seq, iflag);
		break;
	default:
		errx(1, "unsupported AF: %d", af);
		break;
	}
}

int
packet_ok6(struct msghdr *mhdr, int cc, int seq, int iflag)
{
	struct icmp6_hdr *icp;
	struct sockaddr_in6 *from = (struct sockaddr_in6 *)mhdr->msg_name;
	u_char type, code;
	char *buf = (char *)mhdr->msg_iov[0].iov_base;
	struct cmsghdr *cm;
	int *hlimp;
	char hbuf[NI_MAXHOST];
	int useicmp = (proto == IPPROTO_ICMP);

	if (cc < sizeof(struct icmp6_hdr)) {
		if (verbose) {
			if (getnameinfo((struct sockaddr *)from, from->sin6_len,
			    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
				strlcpy(hbuf, "invalid", sizeof(hbuf));
			printf("data too short (%d bytes) from %s\n", cc, hbuf);
		}
		return(0);
	}
	icp = (struct icmp6_hdr *)buf;
	/* get optional information via advanced API */
	rcvpktinfo = NULL;
	hlimp = NULL;
	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
	    cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_PKTINFO &&
		    cm->cmsg_len ==
		    CMSG_LEN(sizeof(struct in6_pktinfo)))
			rcvpktinfo = (struct in6_pktinfo *)(CMSG_DATA(cm));

		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_HOPLIMIT &&
		    cm->cmsg_len == CMSG_LEN(sizeof(int)))
			hlimp = (int *)CMSG_DATA(cm);
	}
	if (rcvpktinfo == NULL || hlimp == NULL) {
		warnx("failed to get received hop limit or packet info");
		rcvhlim = 0;	/*XXX*/
	} else
		rcvhlim = *hlimp;

	type = icp->icmp6_type;
	code = icp->icmp6_code;
	if ((type == ICMP6_TIME_EXCEEDED && code == ICMP6_TIME_EXCEED_TRANSIT)
	    || type == ICMP6_DST_UNREACH) {
		struct ip6_hdr *hip;
		struct udphdr *up;

		hip = (struct ip6_hdr *)(icp + 1);
		if ((up = get_udphdr(hip, (u_char *)(buf + cc))) == NULL) {
			if (verbose)
				warnx("failed to get upper layer header");
			return(0);
		}
		if (useicmp &&
		    ((struct icmp6_hdr *)up)->icmp6_id == ident &&
		    ((struct icmp6_hdr *)up)->icmp6_seq == htons(seq))
			return (type == ICMP6_TIME_EXCEEDED ? -1 : code + 1);
		else if (!useicmp &&
		    up->uh_sport == htons(srcport) &&
		    ((iflag && up->uh_dport == htons(port + seq)) ||
		    (!iflag && up->uh_dport == htons(port))))
			return (type == ICMP6_TIME_EXCEEDED ? -1 : code + 1);
	} else if (useicmp && type == ICMP6_ECHO_REPLY) {
		if (icp->icmp6_id == ident &&
		    icp->icmp6_seq == htons(seq))
			return (ICMP6_DST_UNREACH_NOPORT + 1);
	}
	if (verbose) {
		char sbuf[NI_MAXHOST+1], dbuf[INET6_ADDRSTRLEN];
		u_int8_t *p;
		int i;

		if (getnameinfo((struct sockaddr *)from, from->sin6_len,
		    sbuf, sizeof(sbuf), NULL, 0, NI_NUMERICHOST) != 0)
			strlcpy(sbuf, "invalid", sizeof(sbuf));
		printf("\n%d bytes from %s to %s", cc, sbuf,
		    rcvpktinfo ? inet_ntop(AF_INET6, &rcvpktinfo->ipi6_addr,
		    dbuf, sizeof(dbuf)) : "?");
		printf(": icmp type %d (%s) code %d\n", type, pr_type(type),
		    icp->icmp6_code);
		p = (u_int8_t *)(icp + 1);
#define WIDTH	16
		for (i = 0; i < cc; i++) {
			if (i % WIDTH == 0)
				printf("%04x:", i);
			if (i % 4 == 0)
				printf(" ");
			printf("%02x", p[i]);
			if (i % WIDTH == WIDTH - 1)
				printf("\n");
		}
		if (cc % WIDTH != 0)
			printf("\n");
	}
	return(0);
}

/*
 * Increment pointer until find the UDP or ICMP header.
 */
struct udphdr *
get_udphdr(struct ip6_hdr *ip6, u_char *lim)
{
	u_char *cp = (u_char *)ip6, nh;
	int hlen;
	int useicmp = (proto == IPPROTO_ICMP);

	if (cp + sizeof(*ip6) >= lim)
		return(NULL);

	nh = ip6->ip6_nxt;
	cp += sizeof(struct ip6_hdr);

	while (lim - cp >= 8) {
		switch (nh) {
		case IPPROTO_ESP:
		case IPPROTO_TCP:
			return(NULL);
		case IPPROTO_ICMPV6:
			return(useicmp ? (struct udphdr *)cp : NULL);
		case IPPROTO_UDP:
			return(useicmp ? NULL : (struct udphdr *)cp);
		case IPPROTO_FRAGMENT:
			hlen = sizeof(struct ip6_frag);
			nh = ((struct ip6_frag *)cp)->ip6f_nxt;
			break;
		case IPPROTO_AH:
			hlen = (((struct ip6_ext *)cp)->ip6e_len + 2) << 2;
			nh = ((struct ip6_ext *)cp)->ip6e_nxt;
			break;
		default:
			hlen = (((struct ip6_ext *)cp)->ip6e_len + 1) << 3;
			nh = ((struct ip6_ext *)cp)->ip6e_nxt;
			break;
		}

		cp += hlen;
	}

	return(NULL);
}

void
print(struct sockaddr *from, int cc, const char *to)
{
	char hbuf[NI_MAXHOST];
	if (getnameinfo(from, from->sa_len,
	    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
		strlcpy(hbuf, "invalid", sizeof(hbuf));
	if (nflag)
		printf(" %s", hbuf);
	else
		printf(" %s (%s)", inetname(from), hbuf);

	if (Aflag)
		print_asn((struct sockaddr_storage *)from);

	if (verbose)
		printf(" %d bytes to %s", cc, to);
}

void icmp_code(int af, int code, int *got_there, int *unreachable)
{
	switch (af) {
	case AF_INET6:
		return icmp6_code(code, got_there, unreachable);
		break;
	default:
		errx(1, "unsupported AF: %d", af);
		break;
	}
}

void
icmp6_code(int code, int *got_there, int *unreachable)
{
	switch (code) {
	case ICMP6_DST_UNREACH_NOROUTE:
		++(*unreachable);
		printf(" !N");
		break;
	case ICMP6_DST_UNREACH_ADMIN:
		++(*unreachable);
		printf(" !P");
		break;
	case ICMP6_DST_UNREACH_NOTNEIGHBOR:
		++(*unreachable);
		printf(" !S");
		break;
	case ICMP6_DST_UNREACH_ADDR:
		++(*unreachable);
		printf(" !A");
		break;
	case ICMP6_DST_UNREACH_NOPORT:
		if (rcvhlim >= 0 && rcvhlim <= 1)
			printf(" !");
		++(*got_there);
		break;
	default:
		++(*unreachable);
		printf(" !<%d>", code);
		break;
	}
}

/*
 * Construct an Internet address representation.
 */
const char *
inetname(struct sockaddr *sa)
{
	static char line[NI_MAXHOST], domain[MAXHOSTNAMELEN + 1];
	static int first = 1;
	char *cp;

	if (first) {
		first = 0;
		if (gethostname(domain, sizeof(domain)) == 0 &&
		    (cp = strchr(domain, '.')) != NULL)
			(void) strlcpy(domain, cp + 1, sizeof(domain));
		else
			domain[0] = 0;
	}
	if (getnameinfo(sa, sa->sa_len, line, sizeof(line), NULL, 0,
	    NI_NAMEREQD) == 0) {
		if ((cp = strchr(line, '.')) != NULL && strcmp(cp + 1,
		    domain) == 0)
			*cp = '\0';
		return (line);
	}

	if (getnameinfo(sa, sa->sa_len, line, sizeof(line), NULL, 0,
	    NI_NUMERICHOST) != 0)
		return ("invalid");
	return (line);
}

void
print_asn(struct sockaddr_storage *ss)
{
	struct rrsetinfo *answers = NULL;
	int counter;
	const u_char *uaddr;
	char qbuf[MAXDNAME];

	switch (ss->ss_family) {
	case AF_INET:
		uaddr = (const u_char *)&((struct sockaddr_in *) ss)->sin_addr;
		if (snprintf(qbuf, sizeof qbuf, "%u.%u.%u.%u."
		    "origin.asn.cymru.com",
		    (uaddr[3] & 0xff), (uaddr[2] & 0xff),
		    (uaddr[1] & 0xff), (uaddr[0] & 0xff)) >= sizeof (qbuf))
			return;
		break;
	case AF_INET6:
		uaddr = (const u_char *)&((struct sockaddr_in6 *) ss)->sin6_addr;
		if (snprintf(qbuf, sizeof qbuf, 
		    "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x."
		    "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x."
		    "origin6.asn.cymru.com",
		    (uaddr[15] & 0x0f), ((uaddr[15] >>4)& 0x0f),
		    (uaddr[14] & 0x0f), ((uaddr[14] >>4)& 0x0f),
		    (uaddr[13] & 0x0f), ((uaddr[13] >>4)& 0x0f),
		    (uaddr[12] & 0x0f), ((uaddr[12] >>4)& 0x0f),
		    (uaddr[11] & 0x0f), ((uaddr[11] >>4)& 0x0f),
		    (uaddr[10] & 0x0f), ((uaddr[10] >>4)& 0x0f),
		    (uaddr[9] & 0x0f), ((uaddr[9] >>4)& 0x0f),
		    (uaddr[8] & 0x0f), ((uaddr[8] >>4)& 0x0f),
		    (uaddr[7] & 0x0f), ((uaddr[7] >>4)& 0x0f),
		    (uaddr[6] & 0x0f), ((uaddr[6] >>4)& 0x0f),
		    (uaddr[5] & 0x0f), ((uaddr[5] >>4)& 0x0f),
		    (uaddr[4] & 0x0f), ((uaddr[4] >>4)& 0x0f),
		    (uaddr[3] & 0x0f), ((uaddr[3] >>4)& 0x0f),
		    (uaddr[2] & 0x0f), ((uaddr[2] >>4)& 0x0f),
		    (uaddr[1] & 0x0f), ((uaddr[1] >>4)& 0x0f),
		    (uaddr[0] & 0x0f), ((uaddr[0] >>4)& 0x0f)) >= sizeof (qbuf))
			return;
		break;
	default:
		return;
	}

	if (getrrsetbyname(qbuf, C_IN, T_TXT, 0, &answers) != 0)
		return;
	for (counter = 0; counter < answers->rri_nrdatas; counter++) {
		char *p, *as = answers->rri_rdatas[counter].rdi_data;
		as++; /* skip first byte, it contains length */
		if ((p = strchr(as,'|'))) {
			printf(counter ? ", " : " [");
			p[-1] = 0;
			printf("AS%s", as);
		}
	}
	if (counter)
		printf("]");

	freerrset(answers);
}

void
usage(void)
{

	fprintf(stderr,
"usage: traceroute6 [-AcDdIlnSv] [-f firsthop] [-m hoplimit]\n"
"       [-p port] [-q probes] [-s src] [-V rtableid] [-w waittime]\n"
"       host [datalen]\n");
	exit(1);
}
@


1.99
log
@Prepare for merge: s/hops/ttl/ in struct packetdata
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.98 2014/04/23 09:23:30 florian Exp $	*/
@


1.98
log
@Prepare for merge: no more useicmp
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.97 2014/04/23 09:22:34 florian Exp $	*/
d276 1
a276 1
	u_int8_t hops;		/* hop limit of the packet */
d766 1
a766 1
	op->hops = hops;
@


1.97
log
@KNF
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.96 2014/04/23 09:20:15 florian Exp $	*/
d322 1
a328 1
int useicmp;
d405 1
a405 1
			useicmp++;
d530 1
a530 1
		if (useicmp)
d561 1
a561 1
		if (useicmp) {
d754 1
a754 1
	if (useicmp) {
d906 1
d1005 1
@


1.96
log
@bzero -> memset
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.95 2014/04/23 09:19:23 florian Exp $	*/
d493 1
a493 1
	switch(res->ai_family) {
d528 1
a528 1
	switch(to->sa_family) {
d777 6
a782 6
		case AF_INET6:
			build_probe6(seq, hops, iflag, to);
			break;
		default:
			errx(1, "unsupported AF: %d", to->sa_family);
			break;
@


1.95
log
@s/lastaddr/lastaddr6/
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.94 2014/04/23 09:18:27 florian Exp $	*/
d569 1
a569 1
		bzero(&from6, sizeof(from6));
d650 1
a650 1
		bzero(&lastaddr6, sizeof(lastaddr6));
@


1.94
log
@Prepare merge: check AF
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.93 2014/04/23 09:17:10 florian Exp $	*/
d646 1
a646 1
		struct in6_addr lastaddr;
d650 1
a650 1
		bzero(&lastaddr, sizeof(lastaddr));
d666 1
a666 1
					    &from6.sin6_addr, &lastaddr)) {
d671 1
a671 1
						lastaddr = from6.sin6_addr;
@


1.93
log
@missing break; not reachable
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.92 2014/04/23 09:16:11 florian Exp $	*/
a491 2
	if (res->ai_addrlen != sizeof(to6))
		errx(1, "size of sockaddr mismatch");
d493 12
a504 2
	to = (struct sockaddr *)&to6;
	from = (struct sockaddr *)&from6;
d527 25
a551 22
	if (useicmp)
		minlen = ICMP6ECHOLEN + sizeof(struct packetdata);
	else
		minlen = sizeof(struct packetdata);
	if (datalen < minlen)
		datalen = minlen;
	else if (datalen >= MAXPACKET)
		errx(1, "packet size must be %d <= s < %ld.\n", minlen,
		    (long)MAXPACKET);

	if ((outpacket = calloc(1, datalen)) == NULL)
		err(1, "calloc");

	/* initialize msghdr for receiving packets */
	rcviov[0].iov_base = (caddr_t)packet;
	rcviov[0].iov_len = sizeof(packet);
	rcvmhdr.msg_name = (caddr_t)&from6;
	rcvmhdr.msg_namelen = sizeof(from6);
	rcvmhdr.msg_iov = rcviov;
	rcvmhdr.msg_iovlen = 1;
	rcvcmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo)) +
	    CMSG_SPACE(sizeof(int));
d553 45
a597 4
	if ((rcvcmsgbuf = malloc(rcvcmsglen)) == NULL)
		errx(1, "malloc");
	rcvmhdr.msg_control = (caddr_t) rcvcmsgbuf;
	rcvmhdr.msg_controllen = rcvcmsglen;
d599 4
a602 7
	/*
	 * Send UDP or ICMP
	 */
	if (useicmp) {
		close(sndsock);
		sndsock = rcvsock;
	}
a603 25
	/*
	 * Source selection
	 */
	bzero(&from6, sizeof(from6));
	if (source) {
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = AF_INET6;
		hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
		hints.ai_flags = AI_NUMERICHOST;
		if ((error = getaddrinfo(source, "0", &hints, &res)))
			errx(1, "%s: %s", source, gai_strerror(error));
		if (res->ai_addrlen != sizeof(from6))
			errx(1, "size of sockaddr mismatch");
		memcpy(&from6, res->ai_addr, res->ai_addrlen);
		freeaddrinfo(res);
	} else {
		struct sockaddr_in6 nxt;
		int dummy;

		nxt = to6;
		nxt.sin6_port = htons(DUMMY_PORT);
		if ((dummy = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
			err(1, "socket");
		if (connect(dummy, (struct sockaddr *)&nxt, nxt.sin6_len) < 0)
			err(1, "connect");
d605 1
a605 1
		if (getsockname(dummy, (struct sockaddr *)&from6, &len) < 0)
d607 5
a611 1
		close(dummy);
a613 9
	from6.sin6_port = htons(0);
	if (bind(sndsock, (struct sockaddr *)&from6, from6.sin6_len) < 0)
		err(1, "bind sndsock");

	len = sizeof(from6);
	if (getsockname(sndsock, (struct sockaddr *)&from6, &len) < 0)
		err(1, "getsockname");
	srcport = ntohs(from6.sin6_port);

d664 13
a676 7
				if (!IN6_ARE_ADDR_EQUAL(&from6.sin6_addr,
				    &lastaddr)) {
					print(from, cc, rcvpktinfo ? inet_ntop(
					    AF_INET6, &rcvpktinfo->ipi6_addr,
					    hbuf, sizeof(hbuf)) : "?");
					lastaddr = from6.sin6_addr;
				}
@


1.92
log
@No need to set protocol in hints.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.91 2014/04/23 09:13:00 florian Exp $	*/
d757 1
@


1.91
log
@move AF independet setsockopts down
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.90 2014/04/23 09:11:35 florian Exp $	*/
d488 1
a488 1
	hints.ai_protocol = IPPROTO_ICMPV6;
@


1.90
log
@s/Nxt/nxt/
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.89 2014/04/23 09:10:53 florian Exp $	*/
a546 4
	if (options & SO_DEBUG)
		(void) setsockopt(rcvsock, SOL_SOCKET, SO_DEBUG,
		    (char *)&on, sizeof(on));

a553 6
	if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *)&datalen,
	    sizeof(datalen)) < 0)
		err(6, "SO_SNDBUF");
	if (options & SO_DEBUG)
		(void) setsockopt(sndsock, SOL_SOCKET, SO_DEBUG,
		    (char *)&on, sizeof(on));
d594 11
@


1.89
log
@Add error checking to sysctl. While there pass in an int otherwise
it failes with ENOMEM in traceroute.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.88 2014/04/23 09:09:28 florian Exp $	*/
d581 1
a581 1
		struct sockaddr_in6 Nxt;
d584 2
a585 2
		Nxt = to6;
		Nxt.sin6_port = htons(DUMMY_PORT);
d588 1
a588 1
		if (connect(dummy, (struct sockaddr *)&Nxt, Nxt.sin6_len) < 0)
@


1.88
log
@sync to traceroute: move sndsock creation up.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.87 2014/04/23 08:59:35 florian Exp $	*/
d366 2
a367 1
	(void) sysctl(mib, sizeof(mib)/sizeof(mib[0]), &i, &size, NULL, 0);
@


1.87
log
@Prepare for merge: introduce icmp_code for the AF switch.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.86 2014/04/23 08:56:31 florian Exp $	*/
d348 1
a348 1
	int rtableid = -1;
d357 2
d453 1
a453 1
			rtableid = (int)strtonum(optarg, 0,
d461 3
d554 1
a555 6
	} else {
		if ((sndsock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
			err(5, "socket(SOCK_DGRAM)");
		if (rtableid >= 0 && setsockopt(sndsock, SOL_SOCKET, SO_RTABLE,
		    &rtableid, sizeof(rtableid)) == -1)
			err(1, "setsockopt SO_RTABLE");
@


1.86
log
@Prepare for merge: s/packet_ok/packet_ok6/ and use packet_ok
for the AF switch.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.85 2014/04/23 08:53:49 florian Exp $	*/
d296 1
d657 2
a658 1
				icmp6_code(i - 1, &got_there, &unreachable);
d1029 12
@


1.85
log
@Prepare merge: introduce struct sockaddr *from, *to to be used in
AF independet places.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.84 2014/04/23 08:51:32 florian Exp $	*/
d294 2
a295 1
int	packet_ok(struct msghdr *, int, int, int);
d637 2
a638 1
				i = packet_ok(&rcvmhdr, cc, seq, incflag);
d854 14
a867 1
packet_ok(struct msghdr *mhdr, int cc, int seq, int iflag)
@


1.84
log
@Prepare merge: s/to/to6/; s/from/from6/
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.83 2014/04/23 08:44:50 florian Exp $	*/
d341 1
d487 5
a491 1
	memcpy(&to6, res->ai_addr, res->ai_addrlen);
d605 2
a606 2
	if (getnameinfo((struct sockaddr *)&to6, to6.sin6_len, hbuf,
	    sizeof(hbuf), NULL, 0, NI_NUMERICHOST))
d633 1
a633 1
			send_probe(++seq, hops, incflag, (struct sockaddr*)&to6);
d642 3
a644 5
					print((struct sockaddr *)
					    rcvmhdr.msg_name, cc,
					    rcvpktinfo ?  inet_ntop(AF_INET6,
					    &rcvpktinfo->ipi6_addr, hbuf,
					    sizeof(hbuf)) : "?");
@


1.83
log
@Make this compile with -Wall et al.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.82 2014/04/18 16:58:02 florian Exp $	*/
d340 1
a340 1
	struct sockaddr_in6 from, to;
d483 1
a483 1
	if (res->ai_addrlen != sizeof(to))
d486 1
a486 1
	memcpy(&to, res->ai_addr, res->ai_addrlen);
d522 2
a523 2
	rcvmhdr.msg_name = (caddr_t)&from;
	rcvmhdr.msg_namelen = sizeof(from);
d560 1
a560 1
	bzero(&from, sizeof(from));
d568 1
a568 1
		if (res->ai_addrlen != sizeof(from))
d570 1
a570 1
		memcpy(&from, res->ai_addr, res->ai_addrlen);
d576 1
a576 1
		Nxt = to;
d582 2
a583 2
		len = sizeof(from);
		if (getsockname(dummy, (struct sockaddr *)&from, &len) < 0)
d588 2
a589 2
	from.sin6_port = htons(0);
	if (bind(sndsock, (struct sockaddr *)&from, from.sin6_len) < 0)
d592 2
a593 2
	len = sizeof(from);
	if (getsockname(sndsock, (struct sockaddr *)&from, &len) < 0)
d595 1
a595 1
	srcport = ntohs(from.sin6_port);
d600 1
a600 1
	if (getnameinfo((struct sockaddr *)&to, to.sin6_len, hbuf,
d628 1
a628 1
			send_probe(++seq, hops, incflag, (struct sockaddr*)&to);
d635 1
a635 1
				if (!IN6_ARE_ADDR_EQUAL(&from.sin6_addr,
d642 1
a642 1
					lastaddr = from.sin6_addr;
@


1.82
log
@Declare socklen_t len in main, it's used in two places, no need
to declare it twice. We can get rid of a { } block.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.81 2014/04/18 16:56:25 florian Exp $	*/
a340 1
	struct hostent *hp;
d481 1
a481 1
	if (error = getaddrinfo(*argv, NULL, &hints, &res))
a561 3
		struct addrinfo hints, *res;
		int error;

d566 1
a566 1
		if(error = getaddrinfo(source, "0", &hints, &res))
d1081 1
a1081 1
	char qbuf[MAXDNAME], *qp;
@


1.81
log
@Replace fprintf(stderr, ..); exit() with errx() and fprintf(stderr, ...)
with warnx()
OK lteo@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.80 2014/04/18 16:48:19 florian Exp $	*/
d348 1
a578 1
		socklen_t len;
d596 4
a599 8
	{
		socklen_t len;

		len = sizeof(from);
		if (getsockname(sndsock, (struct sockaddr *)&from, &len) < 0)
			err(1, "getsockname");
		srcport = ntohs(from.sin6_port);
	}
@


1.80
log
@Drop rh0 support (-g), it doesn't work anyway.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.79 2014/04/18 16:33:21 florian Exp $	*/
d481 5
a485 11
	error = getaddrinfo(*argv, NULL, &hints, &res);
	if (error) {
		fprintf(stderr,
		    "traceroute6: %s\n", gai_strerror(error));
		exit(1);
	}
	if (res->ai_addrlen != sizeof(to)) {
		fprintf(stderr,
		    "traceroute6: size of sockaddr mismatch\n");
		exit(1);
	}
d488 2
a489 4
	if (!hostname) {
		fprintf(stderr, "traceroute6: not enough core\n");
		exit(1);
	}
d494 1
a494 1
		fprintf(stderr, "traceroute6: Warning: %s has multiple "
d512 3
a514 6
	else if (datalen >= MAXPACKET) {
		fprintf(stderr,
		    "traceroute6: packet size must be %d <= s < %ld.\n",
		    minlen, (long)MAXPACKET);
		exit(1);
	}
d529 2
a530 4
	if ((rcvcmsgbuf = malloc(rcvcmsglen)) == NULL) {
		fprintf(stderr, "traceroute6: malloc failed\n");
		exit(1);
	}
d569 4
a572 11
		error = getaddrinfo(source, "0", &hints, &res);
		if (error) {
			printf("traceroute6: %s: %s\n", source,
			    gai_strerror(error));
			exit(1);
		}
		if (res->ai_addrlen > sizeof(from)) {
			printf("traceroute6: %s: %s\n", source,
			    gai_strerror(error));
			exit(1);
		}
@


1.79
log
@We do have SO_SNDBUF.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.78 2014/04/18 16:30:00 florian Exp $	*/
a310 3
/* XXX: 2064 = 127(max hops in type 0 rthdr) * sizeof(ip6_hdr) + 16(margin) */
char rtbuf[2064];
struct ip6_rthdr *rth;
d376 1
a376 1
	while ((ch = getopt(argc, argv, "AcDdf:g:Ilm:np:q:Ss:w:vV:")) != -1)
a397 29
		case 'g':
			hp = getipnodebyname(optarg, AF_INET6, 0, &h_errno);
			if (hp == NULL) {
				fprintf(stderr,
				    "traceroute6: unknown host %s\n", optarg);
				exit(1);
			}
			if (rth == NULL) {
				/*
				 * XXX: We can't detect the number of
				 * intermediate nodes yet.
				 */
				if ((rth = inet6_rth_init((void *)rtbuf,
				    sizeof(rtbuf), IPV6_RTHDR_TYPE_0,
				    0)) == NULL) {
					fprintf(stderr,
					    "inet6_rth_init failed.\n");
					exit(1);
				}
			}
			if (inet6_rth_add((void *)rth,
			    (struct in6_addr *)hp->h_addr)) {
				fprintf(stderr,
				    "inet6_rth_add failed for %s\n",
				    optarg);
				exit(1);
			}
			freehostent(hp);
			break;
a568 9
	if (rth) {/* XXX: there is no library to finalize the header... */
		rth->ip6r_len = rth->ip6r_segleft * 2;
		if (setsockopt(sndsock, IPPROTO_IPV6, IPV6_RTHDR,
		    (void *)rth, (rth->ip6r_len + 1) << 3)) {
			fprintf(stderr, "setsockopt(IPV6_RTHDR): %s\n",
			    strerror(errno));
			exit(1);
		}
	}
d1170 1
a1170 1
"usage: traceroute6 [-AcDdIlnSv] [-f firsthop] [-g gateway] [-m hoplimit]\n"
@


1.78
log
@replace perror(3) with err(3)/warn(3)
OK lteo@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.77 2014/04/18 16:26:47 florian Exp $	*/
a594 1
#ifdef SO_SNDBUF
a597 1
#endif /* SO_SNDBUF */
@


1.77
log
@Structure wait_for_reply() loop like traceroute, thereby moving the
loop body one indent layer up.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.76 2014/04/18 16:23:00 florian Exp $	*/
d355 2
a356 4
	if ((rcvsock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0) {
		perror("socket(ICMPv6)");
		exit(5);
	}
d589 2
a590 4
		if ((sndsock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
			perror("socket(SOCK_DGRAM)");
			exit(5);
		}
d645 4
a648 8
		if ((dummy = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
			perror("socket");
			exit(1);
		}
		if (connect(dummy, (struct sockaddr *)&Nxt, Nxt.sin6_len) < 0) {
			perror("connect");
			exit(1);
		}
d650 2
a651 4
		if (getsockname(dummy, (struct sockaddr *)&from, &len) < 0) {
			perror("getsockname");
			exit(1);
		}
d656 2
a657 4
	if (bind(sndsock, (struct sockaddr *)&from, from.sin6_len) < 0) {
		perror("bind sndsock");
		exit(1);
	}
d663 2
a664 4
		if (getsockname(sndsock, (struct sockaddr *)&from, &len) < 0) {
			perror("getsockname");
			exit(1);
		}
d782 2
a783 3
	    (char *)&i, sizeof(i)) < 0) {
		perror("setsockopt IPV6_UNICAST_HOPS");
	}
d827 1
a827 1
			perror("sendto");
@


1.76
log
@move ICMP6 code parsing to function
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.75 2014/04/18 16:20:56 florian Exp $	*/
d716 19
a734 21
				if ((i = packet_ok(&rcvmhdr, cc, seq,
				    incflag))) {
					if (!IN6_ARE_ADDR_EQUAL(&from.sin6_addr,
					    &lastaddr)) {
						print((struct sockaddr *)
						    rcvmhdr.msg_name, cc,
						    rcvpktinfo ?  inet_ntop(
						    AF_INET6, &rcvpktinfo->
						    ipi6_addr, hbuf,
						    sizeof(hbuf)) : "?");
						lastaddr = from.sin6_addr;
					}
					printf("  %g ms", deltaT(&t1, &t2));
					if (ttl_flag)
						printf(" (%u)", rcvhlim);

					/* time exceeded in transit */
					if (i == -1)
						break;
					icmp6_code(i - 1, &got_there,
					    &unreachable);
d736 2
a737 1
				}
@


1.75
log
@sync to traceroute:
* s/Dst/to/
* s/Src/from/
* drop Rcv
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.74 2014/04/18 16:11:36 florian Exp $	*/
d295 1
d735 2
a736 28
					switch (i - 1) {
					case ICMP6_DST_UNREACH_NOROUTE:
						++unreachable;
						printf(" !N");
						break;
					case ICMP6_DST_UNREACH_ADMIN:
						++unreachable;
						printf(" !P");
						break;
					case ICMP6_DST_UNREACH_NOTNEIGHBOR:
						++unreachable;
						printf(" !S");
						break;
					case ICMP6_DST_UNREACH_ADDR:
						++unreachable;
						printf(" !A");
						break;
					case ICMP6_DST_UNREACH_NOPORT:
						if (rcvhlim >= 0 &&
						    rcvhlim <= 1)
							printf(" !");
						++got_there;
						break;
					default:
						++unreachable;
						printf(" !<%d>", i - 1);
						break;
					}
d1096 32
@


1.74
log
@Sync to tracroute: don't print source IP if -s is not given
OK benno@@ (who wants it back in some form after the merge)
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.73 2014/04/18 16:07:54 florian Exp $	*/
a307 1
struct sockaddr_in6 Src, Dst, Rcv;
d342 1
d520 1
a520 1
	if (res->ai_addrlen != sizeof(Dst)) {
d525 1
a525 1
	memcpy(&Dst, res->ai_addr, res->ai_addrlen);
d566 2
a567 2
	rcvmhdr.msg_name = (caddr_t)&Rcv;
	rcvmhdr.msg_namelen = sizeof(Rcv);
d619 1
a619 1
	bzero(&Src, sizeof(Src));
d634 1
a634 1
		if (res->ai_addrlen > sizeof(Src)) {
d639 1
a639 1
		memcpy(&Src, res->ai_addr, res->ai_addrlen);
d646 1
a646 1
		Nxt = Dst;
d656 2
a657 2
		len = sizeof(Src);
		if (getsockname(dummy, (struct sockaddr *)&Src, &len) < 0) {
d664 2
a665 2
	Src.sin6_port = htons(0);
	if (bind(sndsock, (struct sockaddr *)&Src, Src.sin6_len) < 0) {
d673 2
a674 2
		len = sizeof(Src);
		if (getsockname(sndsock, (struct sockaddr *)&Src, &len) < 0) {
d678 1
a678 1
		srcport = ntohs(Src.sin6_port);
d684 1
a684 1
	if (getnameinfo((struct sockaddr *)&Dst, Dst.sin6_len, hbuf,
d712 1
a712 2
			send_probe(++seq, hops, incflag, (struct sockaddr*)
			    &Dst);
d717 1
a717 1
					if (!IN6_ARE_ADDR_EQUAL(&Rcv.sin6_addr,
d725 1
a725 1
						lastaddr = Rcv.sin6_addr;
@


1.73
log
@Sync to tracroute: handle "time exceeded in transit" before the
switch and add a default case.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.72 2014/04/18 16:02:08 florian Exp $	*/
d339 1
a339 1
	char hbuf[NI_MAXHOST], src0[NI_MAXHOST], *ep;
a660 6
		if (getnameinfo((struct sockaddr *)&Src, Src.sin6_len,
		    src0, sizeof(src0), NULL, 0, NI_NUMERICHOST)) {
			fprintf(stderr, "getnameinfo failed for source\n");
			exit(1);
		}
		source = src0;
@


1.72
log
@sync to traceroute: s/opacket/packetdata/
OK lteo@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.71 2014/04/18 16:00:38 florian Exp $	*/
d737 4
d763 4
@


1.71
log
@Embed struct tv32 into struct opacket like traceroute.
This changes the data part of an icmp6 paket, before it only
contained the timestamp, now it contains a whole struct opacket.
Shouldn't be an issue as nobody looks at this data anyway.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.70 2014/04/18 15:58:43 florian Exp $	*/
d274 1
a274 1
struct opacket {
d548 1
a548 1
		minlen = ICMP6ECHOLEN + sizeof(struct opacket);
d550 1
a550 1
		minlen = sizeof(struct opacket);
d816 1
a816 1
	struct opacket *op;
d839 1
a839 1
		op = (struct opacket *)(outpacket + ICMP6ECHOLEN);
d841 1
a841 1
		op = (struct opacket *)outpacket;
@


1.70
log
@Factor out build_probe{4,6} from send_probe; now send_probe is
AF independent. While there define outpacket as u_char and
cast as needed in traceroute6.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.69 2014/03/27 09:32:18 florian Exp $	*/
d272 1
a272 1
 * format of a (udp) probe packet.
a273 5
struct tv32 {
	u_int32_t tv32_sec;
	u_int32_t tv32_usec;
};

d276 1
a276 1
	u_char hops;		/* hop limit of the packet */
d278 2
a279 1
	struct tv32 tv;		/* time packet left */
d548 1
a548 1
		minlen = ICMP6ECHOLEN + sizeof(struct tv32);
d816 1
a816 1
	struct tv32 tv32;
a829 2
	tv32.tv32_sec = htonl(tv.tv_sec);
	tv32.tv32_usec = htonl(tv.tv_usec);
d839 7
a845 9
		bcopy(&tv32, ((u_int8_t *)outpacket + ICMP6ECHOLEN),
		    sizeof tv32);
	} else {
		struct opacket *op = (struct opacket *)outpacket;

		op->seq = seq;
		op->hops = hops;
		bcopy(&tv32, &op->tv, sizeof tv32);
	}
@


1.69
log
@zap dead code; OK lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.68 2014/03/24 11:11:49 mpi Exp $	*/
d287 1
a287 1
struct opacket	*outpacket;	/* last output (udp) packet */
d292 2
a293 1
void	send_probe(int, u_int8_t, int);
d336 2
d722 2
a723 1
			send_probe(++seq, hops, incflag);
d817 1
a817 1
send_probe(int seq, u_int8_t hops, int iflag)
d830 1
a830 1
		Dst.sin6_port = htons(port + seq);
d832 1
a832 1
		Dst.sin6_port = htons(port);
d845 2
a846 1
		bcopy(&tv32, ((u_int8_t *)outpacket + ICMP6ECHOLEN), sizeof tv32);
d848 1
a848 1
		struct opacket *op = outpacket;
d854 14
d872 1
a872 2
	i = sendto(sndsock, (char *)outpacket, datalen, 0,
	    (struct sockaddr *)&Dst, Dst.sin6_len);
d876 2
a877 2
		printf("traceroute6: wrote %s %d chars, ret=%d\n",
		    hostname, datalen, i);
@


1.68
log
@Remove "-r" option from ping(8) and traceroute{,6}(8).  You've probably
never heard about it, it was to bypass the routing tables, not available
for IPv6 and we're going to always use the routing tables soon.

ok florian@@, man pages ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.67 2014/03/18 10:11:36 florian Exp $	*/
a316 1
struct cmsghdr *cmsg;
a648 3
		if (cmsg != NULL)
			bcopy(inet6_rthdr_getaddr(cmsg, 1), &Nxt.sin6_addr,
			    sizeof(Nxt.sin6_addr));
@


1.67
log
@Make print AF independet and use it in traceroute and traceroute6.
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.66 2014/03/18 10:11:00 florian Exp $	*/
d382 1
a382 1
	while ((ch = getopt(argc, argv, "AcDdf:g:Ilm:np:q:rSs:w:vV:")) != -1)
a468 3
		case 'r':
			options |= SO_DONTROUTE;
			break;
a584 3
	if (options & SO_DONTROUTE)
		(void) setsockopt(rcvsock, SOL_SOCKET, SO_DONTROUTE,
		    (char *)&on, sizeof(on));
a607 3
	if (options & SO_DONTROUTE)
		(void) setsockopt(sndsock, SOL_SOCKET, SO_DONTROUTE,
		    (char *)&on, sizeof(on));
d1215 1
a1215 1
"usage: traceroute6 [-AcDdIlnrSv] [-f firsthop] [-g gateway] [-m hoplimit]\n"
@


1.66
log
@Sync inetname from traceroute6 and thereby make it AF independent.
While there drop the !nflag check as it's never called with nflag set,
simplify the code a bit and adapt style from traceroute.
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.65 2014/03/18 10:10:17 florian Exp $	*/
d298 1
a298 1
void	print(struct msghdr *, int);
d739 6
a744 1
						print(&rcvmhdr, cc);
d1107 1
a1107 1
print(struct msghdr *mhdr, int cc)
a1108 1
	struct sockaddr_in6 *from = (struct sockaddr_in6 *)mhdr->msg_name;
d1110 1
a1110 2

	if (getnameinfo((struct sockaddr *)from, from->sin6_len,
d1116 1
a1116 1
		printf(" %s (%s)", inetname((struct sockaddr *)from), hbuf);
d1121 2
a1122 5
	if (verbose) {
		printf(" %d bytes of data to %s", cc,
		    rcvpktinfo ?  inet_ntop(AF_INET6, &rcvpktinfo->ipi6_addr,
		    hbuf, sizeof(hbuf)) : "?");
	}
@


1.65
log
@AF independent print_asn
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.64 2014/03/18 10:09:37 florian Exp $	*/
a1126 2
 * If the nflag has been supplied, give
 * numeric value, otherwise try for symbolic name.
d1135 1
a1135 1
	if (first && !nflag) {
d1138 1
a1138 1
		    (cp = strchr(domain, '.')))
d1143 6
a1148 9
	cp = NULL;
	if (!nflag) {
		if (getnameinfo(sa, sa->sa_len, line, sizeof(line), NULL, 0,
		    NI_NAMEREQD) == 0) {
			if ((cp = strchr(line, '.')) &&
			    !strcmp(cp + 1, domain))
				*cp = 0;
			cp = line;
		}
a1149 2
	if (cp)
		return cp;
d1153 2
a1154 2
		strlcpy(line, "invalid", sizeof(line));
	return line;
@


1.64
log
@Stop if the sum of unreachables and timeouts are >= number of probes, but
only if we have at least one unreachable; from traceroute
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.63 2014/03/18 10:08:24 florian Exp $	*/
d300 1
a300 1
void	print_asn(struct sockaddr *);
d1116 1
a1116 1
		print_asn((struct sockaddr *)from);
a1163 5
static char hex_digits[] = {
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};

d1165 1
a1165 1
print_asn(struct sockaddr *sa)
d1167 3
a1169 2
	struct sockaddr_in6 *sa_in6 = (struct sockaddr_in6 *)sa;
	const u_char *uaddr = (const u_char *)&sa_in6->sin6_addr;
a1170 2
	struct rrsetinfo *answers = NULL;
	int n, i, counter;
d1172 34
a1205 10
	qp = qbuf;
	for (i = 15; i >= 0; i--) {
		*qp++ = hex_digits[uaddr[i] & 0x0f];
		*qp++ = '.';
		*qp++ = hex_digits[(uaddr[i] >> 4) & 0x0f];
		*qp++ = '.';
	}
	*qp = 0;
	if (strlcat(qbuf, "origin6.asn.cymru.com",
	    sizeof(qbuf)) >= sizeof(qbuf))
d1207 3
a1209 1
	if ((n = getrrsetbyname(qbuf, C_IN, T_TXT, 0, &answers)))
@


1.63
log
@Remove #if 0; after nearly 14 years it's probably the right thing to
set rcvhlim to zero.
OK lteo, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.62 2014/03/18 10:06:39 florian Exp $	*/
d723 1
a723 1
		int got_there = 0, unreachable = 0, loss;
d774 1
d783 2
a784 3
		    (unreachable > 0 && unreachable >= ((nprobes + 1) / 2))) {
			exit(0);
		}
a785 1

@


1.62
log
@Free -l flag, by default print hostnames and numeric addresses, like
traceroute does.
Immediatly reclaim -l flag to print hop limit of received pkg like
traceroute does.
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.61 2014/03/10 19:58:43 florian Exp $	*/
a996 3
#if 0
		return(0);
#else
d998 1
a998 3
#endif
	}
	else
@


1.61
log
@13_datalen.msg
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.60 2014/03/10 19:57:24 florian Exp $	*/
a333 1
int lflag;			/* print both numerical address & hostname */
d340 1
a340 1
	int incflag = 1, sump = 0;
d438 1
a438 1
			lflag++;
d743 2
d1118 1
a1118 1
	else if (lflag)
d1120 1
a1120 2
	else
		printf(" %s", inetname((struct sockaddr *)from));
@


1.60
log
@11_w_flag.msg
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.59 2014/03/10 19:56:58 florian Exp $	*/
d312 1
a312 1
u_long datalen;			/* How much data */
d546 1
d548 4
a551 7
		errno = 0;
		datalen = strtoul(*argv, &ep, 0);
		if (errno || !*argv || *ep) {
			fprintf(stderr,
			    "traceroute6: invalid packet length.\n");
			exit(1);
		}
d565 3
a567 6
	outpacket = (struct opacket *)malloc((size_t)datalen);
	if (!outpacket) {
		perror("malloc");
		exit(1);
	}
	(void) bzero((char *)outpacket, datalen);
d608 3
a610 6
	i = datalen;
	if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *)&i,
	    sizeof(i)) < 0) {
		perror("setsockopt(SO_SNDBUF)");
		exit(6);
	}
d712 1
a712 1
	fprintf(stderr, ", %u hops max, %lu byte packets\n",
d866 1
a866 1
		printf("traceroute6: wrote %s %lu chars, ret=%d\n",
@


1.59
log
@10_setvbuf.msg
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.58 2014/01/24 15:28:03 florian Exp $	*/
d497 1
d499 4
a502 12
			errno = 0;
			waittime = strtoul(optarg, &ep, 0);
			if (errno || !*optarg || *ep) {
				fprintf(stderr,
				    "traceroute6: invalid wait time.\n");
				exit(1);
			}
			if (waittime <= 1) {
				fprintf(stderr,
				    "traceroute6: wait must be >1 sec.\n");
				exit(1);
			}
@


1.58
log
@Implement -S; from traceroute; reduces diff to traceroute.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.57 2014/01/24 15:26:32 florian Exp $	*/
d520 1
a520 5
#if 1
	setvbuf(stdout, NULL, _IOLBF, BUFSIZ);
#else
	setlinebuf(stdout);
#endif
@


1.57
log
@Implement -D; from traceroute; reduces diff to traceroute.
While here add dump() prototype in traceroute
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.56 2014/01/24 15:22:10 florian Exp $	*/
d341 1
a341 1
	int incflag = 1;
d383 1
a383 1
	while ((ch = getopt(argc, argv, "AcDdf:g:Ilm:np:q:rs:w:vV:")) != -1)
d480 3
d743 1
a743 2
		int got_there = 0;
		int unreachable = 0;
d747 1
a747 1
		for (probe = 0; probe < nprobes; ++probe) {
d790 1
a790 1
			if (cc == 0)
d792 2
d796 2
d1236 1
a1236 1
"usage: traceroute6 [-AcDdIlnrv] [-f firsthop] [-g gateway] [-m hoplimit]\n"
@


1.56
log
@Implement -c flag; from traceroute; reduces diff to traceroute
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.55 2014/01/24 15:16:13 florian Exp $	*/
d291 1
d332 1
d383 1
a383 1
	while ((ch = getopt(argc, argv, "Acdf:g:Ilm:np:q:rs:w:vV:")) != -1)
d394 3
d818 14
d871 3
d1230 1
a1230 1
"usage: traceroute6 [-AcdIlnrv] [-f firsthop] [-g gateway] [-m hoplimit]\n"
@


1.55
log
@Sync "port" handling to traceroute; reduces diff to traceroute
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.54 2014/01/24 15:14:31 florian Exp $	*/
d291 1
a291 1
void	send_probe(int, u_int8_t);
d296 1
a296 1
int	packet_ok(struct msghdr *, int, int);
d339 1
d381 1
a381 1
	while ((ch = getopt(argc, argv, "Adf:g:Ilm:np:q:rs:w:vV:")) != -1)
d386 3
d745 1
a745 1
			send_probe(++seq, hops);
d748 2
a749 1
				if ((i = packet_ok(&rcvmhdr, cc, seq))) {
d815 1
a815 1
send_probe(int seq, u_int8_t hops)
d827 4
a830 1
	Dst.sin6_port = htons(port + seq);
d949 1
a949 1
packet_ok(struct msghdr *mhdr, int cc, int seq)
d1015 2
a1016 1
		    up->uh_dport == htons(port + seq))
d1208 1
a1208 1
"usage: traceroute6 [-AdIlnrv] [-f firsthop] [-g gateway] [-m hoplimit]\n"
@


1.54
log
@Sync "nprobes" handling to traceroute; reduces diff to traceroute
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.53 2014/01/24 15:12:29 florian Exp $	*/
a342 1
	u_long lport;
d446 1
d448 4
a451 12
			errno = 0;
			lport = strtoul(optarg, &ep, 0);
			if (errno || !*optarg || *ep) {
				fprintf(stderr, "traceroute6: invalid port.\n");
				exit(1);
			}
			if (lport == 0 || lport != (lport & 0xffff)) {
				fprintf(stderr,
				    "traceroute6: port out of range.\n");
				exit(1);
			}
			port = lport & 0xffff;
@


1.53
log
@Sync max_hops and first_hop to same type as the corosponding
variables max_ttl / first_ttl in traceroute have.
Also parse -f/-m the same as traceroute.
Does not technically reduce the diff to traceroute, but if/when
we merge we can decide which variable naming wins and search/replace
the other.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.52 2013/11/12 19:36:30 deraadt Exp $	*/
d321 1
a321 1
u_long nprobes = 3;
d340 1
a340 1
	int ch, i, on = 1, seq, rcvcmsglen, error, minlen;
d343 1
a343 1
	u_long probe, lport;
d462 1
d464 4
a467 12
			errno = 0;
			nprobes = strtoul(optarg, &ep, 0);
			if (errno || !*optarg || *ep) {
				fprintf(stderr,
				    "traceroute6: invalid nprobes.\n");
				exit(1);
			}
			if (nprobes < 1) {
				fprintf(stderr,
				    "traceroute6: nprobes must be >0.\n");
				exit(1);
			}
@


1.52
log
@prototypes, some pleasing of gcc, and cleanup an unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.51 2013/10/26 21:21:45 sthen Exp $	*/
d291 1
a291 1
void	send_probe(int, u_long);
d322 2
a323 2
u_long first_hop = 1;
u_long max_hops = 30;
d343 1
a343 1
	u_long probe, hops, lport;
d346 2
d390 1
d392 4
a395 7
			errno = 0;
			first_hop = strtoul(optarg, &ep, 0);
			if (errno || !*optarg || *ep|| first_hop > 255) {
				fprintf(stderr,
				    "traceroute6: invalid min hoplimit.\n");
				exit(1);
			}
d434 1
d436 6
a441 7
			errno = 0;
			max_hops = strtoul(optarg, &ep, 0);
			if (errno || !*optarg || *ep || max_hops > 255) {
				fprintf(stderr,
				    "traceroute6: invalid max hoplimit.\n");
				exit(1);
			}
a519 6
	if (max_hops < first_hop) {
		fprintf(stderr,
		    "traceroute6: max hoplimit must be larger than first hoplimit.\n");
		exit(1);
	}

d734 1
a734 1
	fprintf(stderr, ", %lu hops max, %lu byte packets\n",
d739 1
a739 1
		printf("Skipping %lu intermediate hops\n", first_hop - 1);
d749 1
a749 1
		printf("%2lu ", hops);
d825 1
a825 1
send_probe(int seq, u_long hops)
@


1.51
log
@Only use setsockopt(..SO_RTABLE..) if an alternative rtable is specified
on the command line, this repairs traceroute6 if the -V flag is not given.

ok matthieu@@ deraadt@@

(Note that traceroute6's source address selection is not yet rdomain-aware,
for now to use another domain with "traceroute -V" requires manually setting
the source address with -s.)
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.50 2013/10/21 08:47:10 phessler Exp $	*/
d1198 1
a1198 1
	if (n = getrrsetbyname(qbuf, C_IN, T_TXT, 0, &answers))
d1203 1
a1203 1
		if (p = strchr(as,'|')) {
@


1.50
log
@More rdomain / rtable support for useful diagnostic tools


OK claudio@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.49 2012/04/06 17:43:03 deraadt Exp $	*/
d347 1
a347 1
	u_int rtableid;
d490 1
a490 1
			rtableid = (unsigned int)strtonum(optarg, 0,
d628 1
a628 1
		if (setsockopt(sndsock, SOL_SOCKET, SO_RTABLE,
@


1.49
log
@unlike the previous century, the malloc argument now has an accurate type
rather than just "(unsigned)"
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.48 2012/02/15 08:22:02 jmc Exp $	*/
d347 2
d379 1
a379 1
	while ((ch = getopt(argc, argv, "Adf:g:Ilm:np:q:rs:w:v")) != -1)
d489 10
d628 3
d715 1
a715 1
		perror("bind");
d1221 2
a1222 1
"       [-p port] [-q probes] [-s src] [-w waittime] host [datalen]\n");
@


1.48
log
@add -A to usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.47 2012/02/10 22:50:48 sthen Exp $	*/
d575 1
a575 1
	outpacket = (struct opacket *)malloc((unsigned)datalen);
@


1.47
log
@Add ASN printing support to traceroute6, mostly the same as code in
traceroute with a few string changes. Help/ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.46 2009/10/27 23:59:57 deraadt Exp $	*/
d1205 1
a1205 1
"usage: traceroute6 [-dIlnrv] [-f firsthop] [-g gateway] [-m hoplimit]\n"
@


1.46
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.45 2008/03/24 16:11:06 deraadt Exp $	*/
d247 1
d299 1
d333 1
d377 1
a377 1
	while ((ch = getopt(argc, argv, "df:g:Ilm:np:q:rs:w:v")) != -1)
d379 3
d1109 2
d1156 42
@


1.45
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.44 2008/03/15 16:43:59 deraadt Exp $	*/
a63 10

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static char sccsid[] = "@@(#)traceroute.c	8.1 (Berkeley) 6/6/93";
#endif /* not lint */
@


1.44
log
@space allocated is sum of CMSG_SPACE()'s.  length given to the kernel
is the sum of all the CMSG_SPACE()'s, except for the last element use
CMSG_LEN().  Insane, right?
ok kettenis hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.43 2006/12/19 14:47:45 itojun Exp $	*/
d347 1
a347 1
	int ch, i, on = 1, seq, rcvcmsglen, rcvcmsgspace, error, minlen;
d593 1
a593 1
	rcvcmsgspace = CMSG_SPACE(sizeof(struct in6_pktinfo)) +
a594 2
	rcvcmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo)) +
	    CMSG_LEN(sizeof(int));
d596 1
a596 1
	if ((rcvcmsgbuf = malloc(rcvcmsgspace)) == NULL) {
@


1.43
log
@eliminate #ifdef OLDRAWSOCKET
-DHAVE_POLL is no longer needed
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.42 2006/12/15 06:00:12 itojun Exp $	*/
d347 1
a347 1
	int ch, i, on = 1, seq, rcvcmsglen, error, minlen;
d593 2
d596 3
a598 2
	    CMSG_SPACE(sizeof(int));
	if ((rcvcmsgbuf = malloc(rcvcmsglen)) == NULL) {
@


1.42
log
@reduce RFC2292/3542 #ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.41 2006/11/16 02:20:50 itojun Exp $	*/
a959 21
#ifdef OLDRAWSOCKET
	int hlen;
	struct ip6_hdr *ip;
#endif

#ifdef OLDRAWSOCKET
	ip = (struct ip6_hdr *) buf;
	hlen = sizeof(struct ip6_hdr);
	if (cc < hlen + sizeof(struct icmp6_hdr)) {
		if (verbose) {
			if (getnameinfo((struct sockaddr *)from, from->sin6_len,
			    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST) != 0)
				strlcpy(hbuf, "invalid", sizeof(hbuf));
			printf("packet too short (%d bytes) from %s\n", cc,
			    hbuf);
		}
		return (0);
	}
	cc -= hlen;
	icp = (struct icmp6_hdr *)(buf + hlen);
#else
a969 1
#endif
a1113 5
#ifdef OLDRAWSOCKET
		printf(" %d bytes to %s", cc,
		    rcvpktinfo ? inet_ntop(AF_INET6, &rcvpktinfo->ipi6_addr,
		    hbuf, sizeof(hbuf)) : "?");
#else
a1116 1
#endif
@


1.41
log
@make RFC2292 -> 3542 transition to automagically happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.40 2006/08/10 20:11:02 jmc Exp $	*/
a260 1
#ifdef HAVE_POLL
a261 1
#endif
a270 5
#ifdef IPSEC
#include <net/route.h>
#include <netinet6/ipsec.h>
#endif

a299 5
#ifdef IPSEC
#ifdef IPSEC_POLICY_IPSEC
int	setpolicy(int so, char *policy);
#endif
#endif
a322 1
#ifdef IPV6_RECVPKTINFO
a323 1
#endif
a372 1
#ifdef IPV6_RECVPKTINFO
a375 5
#else
	if (setsockopt(rcvsock, IPPROTO_IPV6, IPV6_PKTINFO, &on,
	    sizeof(on)) < 0)
		err(1, "setsockopt(IPV6_PKTINFO)");
#endif
a377 1
#ifdef IPV6_RECVHOPLIMIT
a380 5
#else  /* old adv. API */
	if (setsockopt(rcvsock, IPPROTO_IPV6, IPV6_HOPLIMIT, &on,
	    sizeof(on)) < 0)
		err(1, "setsockopt(IPV6_HOPLIMIT)");
#endif
a405 1
#ifdef IPV6_RECVPKTINFO
a425 6
#else
			if (cmsg == NULL)
				cmsg = inet6_rthdr_init(rtbuf, IPV6_RTHDR_TYPE_0);
			inet6_rthdr_add(cmsg, (struct in6_addr *)hp->h_addr,
			    IPV6_RTHDR_LOOSE);
#endif
a607 32
#ifdef IPSEC
#ifdef IPSEC_POLICY_IPSEC
	/*
	 * do not raise error even if setsockopt fails, kernel may have ipsec
	 * turned off.
	 */
	if (setpolicy(rcvsock, "in bypass") < 0)
		errx(1, "%s", ipsec_strerror());
	if (setpolicy(rcvsock, "out bypass") < 0)
		errx(1, "%s", ipsec_strerror());
#else
    {
	int level = IPSEC_LEVEL_NONE;

	(void)setsockopt(rcvsock, IPPROTO_IPV6, IPV6_ESP_TRANS_LEVEL, &level,
	    sizeof(level));
	(void)setsockopt(rcvsock, IPPROTO_IPV6, IPV6_ESP_NETWORK_LEVEL, &level,
	    sizeof(level));
#ifdef IP_AUTH_TRANS_LEVEL
	(void)setsockopt(rcvsock, IPPROTO_IPV6, IPV6_AUTH_TRANS_LEVEL, &level,
	    sizeof(level));
#else
	(void)setsockopt(rcvsock, IPPROTO_IPV6, IPV6_AUTH_LEVEL, &level,
	    sizeof(level));
#endif
#ifdef IP_AUTH_NETWORK_LEVEL
	(void)setsockopt(rcvsock, IPPROTO_IPV6, IPV6_AUTH_NETWORK_LEVEL, &level,
	    sizeof(level));
#endif
    }
#endif /*IPSEC_POLICY_IPSEC*/
#endif /*IPSEC*/
a633 1
#ifdef IPV6_RECVPKTINFO
a642 43
#else
	if (cmsg != NULL) {
		inet6_rthdr_lasthop(cmsg, IPV6_RTHDR_LOOSE);
		if (setsockopt(sndsock, IPPROTO_IPV6, IPV6_PKTOPTIONS,
		    rtbuf, cmsg->cmsg_len) < 0) {
			fprintf(stderr, "setsockopt(IPV6_PKTOPTIONS): %s\n",
			    strerror(errno));
			exit(1);
		}
	}
#endif
#ifdef IPSEC
#ifdef IPSEC_POLICY_IPSEC
	/*
	 * do not raise error even if setsockopt fails, kernel may have ipsec
	 * turned off.
	 */
	if (setpolicy(sndsock, "in bypass") < 0)
		errx(1, "%s", ipsec_strerror());
	if (setpolicy(sndsock, "out bypass") < 0)
		errx(1, "%s", ipsec_strerror());
#else
    {
	int level = IPSEC_LEVEL_BYPASS;

	(void)setsockopt(sndsock, IPPROTO_IPV6, IPV6_ESP_TRANS_LEVEL, &level,
	    sizeof(level));
	(void)setsockopt(sndsock, IPPROTO_IPV6, IPV6_ESP_NETWORK_LEVEL, &level,
	    sizeof(level));
#ifdef IP_AUTH_TRANS_LEVEL
	(void)setsockopt(sndsock, IPPROTO_IPV6, IPV6_AUTH_TRANS_LEVEL, &level,
	    sizeof(level));
#else
	(void)setsockopt(sndsock, IPPROTO_IPV6, IPV6_AUTH_LEVEL, &level,
	    sizeof(level));
#endif
#ifdef IP_AUTH_NETWORK_LEVEL
	(void)setsockopt(sndsock, IPPROTO_IPV6, IPV6_AUTH_NETWORK_LEVEL, &level,
	    sizeof(level));
#endif
    }
#endif /*IPSEC_POLICY_IPSEC*/
#endif /*IPSEC*/
a803 1
#ifdef HAVE_POLL
a814 18
#else
	fd_set *fdsp;
	struct timeval wait;
	int cc = 0, fdsn;

	fdsn = howmany(sock + 1, NFDBITS) * sizeof(fd_mask);
	if ((fdsp = (fd_set *)malloc(fdsn)) == NULL)
		err(1, "malloc");
	memset(fdsp, 0, fdsn);
	FD_SET(sock, fdsp);
	wait.tv_sec = waittime; wait.tv_usec = 0;

	if (select(sock+1, fdsp, (fd_set *)0, (fd_set *)0, &wait) > 0)
		cc = recvmsg(rcvsock, mhdr, 0);

	free(fdsp);
	return(cc);
#endif
a816 21
#ifdef IPSEC
#ifdef IPSEC_POLICY_IPSEC
int
setpolicy(int so, char *policy)
{
	char *buf;

	buf = ipsec_set_policy(policy, strlen(policy));
	if (buf == NULL) {
		warnx("%s", ipsec_strerror());
		return -1;
	}
	(void)setsockopt(so, IPPROTO_IPV6, IPV6_IPSEC_POLICY,
	    buf, ipsec_get_policylen(buf));

	free(buf);

	return 0;
}
#endif
#endif
@


1.40
log
@sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.39 2005/05/03 01:01:14 djm Exp $	*/
d335 1
a335 1
#ifdef USE_RFC2292BIS
d391 1
a391 1
#else  /* old adv. API */
d432 1
a432 1
#ifdef USE_RFC2292BIS
d453 1
a453 1
#else  /* old advanced API */
d699 1
a699 1
#ifdef USE_RFC2292BIS
d709 1
a709 1
#else  /* old advanced API */
d719 1
a719 1
#endif /* USE_RFC2292BIS */
@


1.39
log
@more setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.38 2004/08/01 18:32:21 deraadt Exp $	*/
d1342 1
a1342 1
"       [-p port] [-q probes] [-s src] [-w waittime] target [datalen]\n");
@


1.38
log
@ansi cleanup; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.37 2004/01/25 03:25:49 deraadt Exp $	*/
d367 1
d378 3
a380 2
	seteuid(getuid());
	setuid(getuid());
@


1.37
log
@knf and cleanup.  as well avoid sending out packet information which
contains byte-order, alignment, or padding information about the src
host.  while at it, fix unaligned access operations.  ok itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.36 2003/06/11 23:33:30 deraadt Exp $	*/
d909 1
a909 3
wait_for_reply(sock, mhdr)
	int sock;
	struct msghdr *mhdr;
@


1.36
log
@some ansification, some de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.35 2003/06/02 23:36:55 millert Exp $	*/
a289 5
struct opacket {
	u_char seq;		/* sequence number of this packet */
	u_char hops;		/* hop limit of the packet */
	struct timeval tv;	/* time packet left */
};
d295 7
a318 1
void	tvsub(struct timeval *, struct timeval *);
d359 3
a361 2
	struct hostent *hp;
	int error;
a362 2
	int ch, i, on, seq, rcvcmsglen;
	u_long probe, hops;
d364 2
a365 3
	char hbuf[NI_MAXHOST], src0[NI_MAXHOST];
	char *ep;
	int mib[4] = { CTL_NET, PF_INET6, IPPROTO_IPV6, IPV6CTL_DEFHLIM };
a366 2
	u_long lport;
	int minlen;
a383 2
	/* set a minimum set of socket options */
	on = 1;
d407 1
a407 1
	
d555 1
a555 1
	setlinebuf (stdout);
d611 1
a611 1
	if (! outpacket) {
d624 2
a625 2
	rcvcmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo))
		+ CMSG_SPACE(sizeof(int));
d861 1
a861 1
					if (! IN6_ARE_ADDR_EQUAL(&Rcv.sin6_addr,
d970 2
d981 3
a986 2
		struct timeval tv;
		struct tv32 *tv32;
d993 1
a993 4
		(void) gettimeofday(&tv, NULL);
		tv32 = (struct tv32 *)((u_int8_t *)outpacket + ICMP6ECHOLEN);
		tv32->tv32_sec = htonl(tv.tv_sec);
		tv32->tv32_usec = htonl(tv.tv_usec);
d996 1
d999 1
a999 1
		(void) gettimeofday(&op->tv, NULL);
d1002 1
a1002 1
	i = sendto(sndsock, (char *)outpacket, datalen , 0,
d1005 1
a1005 1
		if (i<0)
d1171 1
a1171 1
	 || type == ICMP6_DST_UNREACH) {
d1195 2
a1197 2
		u_int8_t *p;
		char sbuf[NI_MAXHOST+1], dbuf[INET6_ADDRSTRLEN];
a1297 15
 * Subtract 2 timeval structs:  out = out - in.
 * Out is assumed to be >= in.
 */
void
tvsub(struct timeval *out, struct timeval *in)
{

	if ((out->tv_usec -= in->tv_usec) < 0)   {
		out->tv_sec--;
		out->tv_usec += 1000000;
	}
	out->tv_sec -= in->tv_sec;
}

/*
d1305 2
a1307 3
	static char line[NI_MAXHOST];
	static char domain[MAXHOSTNAMELEN + 1];
	static int first = 1;
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.34 2003/01/21 08:55:14 itojun Exp $	*/
d356 1
a356 3
main(argc, argv)
	int argc;
	char *argv[];
d953 1
a953 3
setpolicy(so, policy)
	int so;
	char *policy;
d973 1
a973 3
send_probe(seq, hops)
	int seq;
	u_long hops;
d1018 1
a1018 2
get_hoplim(mhdr)
	struct msghdr *mhdr;
d1034 1
a1034 2
deltaT(t1p, t2p)
	struct timeval *t1p, *t2p;
d1036 1
a1036 1
	register double dt;
d1047 1
a1047 2
pr_type(t0)
	int t0;
d1103 1
a1103 4
packet_ok(mhdr, cc, seq)
	struct msghdr *mhdr;
	int cc;
	int seq;
d1105 1
a1105 1
	register struct icmp6_hdr *icp;
d1232 1
a1232 3
get_udphdr(ip6, lim)
	struct ip6_hdr *ip6;
	u_char *lim;
d1273 1
a1273 3
print(mhdr, cc)
	struct msghdr *mhdr;
	int cc;
d1306 1
a1306 2
tvsub(out, in)
	register struct timeval *out, *in;
d1322 1
a1322 2
inetname(sa)
	struct sockaddr *sa;
d1324 1
a1324 1
	register char *cp;
d1357 1
a1357 1
usage()
@


1.34
log
@SO_SNDBUF needs int, not u_long
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.33 2003/01/21 08:51:22 itojun Exp $	*/
d48 1
a48 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.33
log
@getting sysctl(net.inet6.ip6.def_hlim) need int variable, not u_long
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.32 2003/01/21 08:00:08 itojun Exp $	*/
d695 3
a697 2
	if (setsockopt(sndsock, SOL_SOCKET, SO_SNDBUF, (char *)&datalen,
	    sizeof(datalen)) < 0) {
@


1.32
log
@correct arg size for IPV6_UNICAST_HOPS socket option.  Hiroki Sato
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.31 2002/10/24 12:58:45 itojun Exp $	*/
d373 1
a373 1
	size_t size = sizeof(max_hops);
d389 3
a391 2
	(void) sysctl(mib, sizeof(mib)/sizeof(mib[0]), &max_hops, &size,
	    NULL, 0);
@


1.31
log
@be more picky about arg parsing.  check ERANGE on strtoul.  sync w/kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.30 2002/10/23 06:45:13 mark Exp $	*/
d985 1
d987 1
a987 1
	    (char *)&hops, sizeof(hops)) < 0) {
@


1.30
log
@integer overflow cleanup - convert to u_long so strtoul can handle comparisons

itojun@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: traceroute6.c,v 1.29 2002/09/08 01:31:46 itojun Exp $	*/
/*	$KAME: traceroute6.c,v 1.61 2002/09/08 01:28:05 itojun Exp $	*/
d425 1
d427 1
a427 1
			if (!*argv || *ep) {
a431 6
			if (first_hop > max_hops) {
				fprintf(stderr,
				    "traceroute6: min hoplimit must be <= %lu.\n",
				    max_hops);
				exit(1);
			}
d478 1
d480 1
a480 1
			if (!*argv || *ep) {
a484 6
			if (max_hops < first_hop) {
				fprintf(stderr,
				    "traceroute6: max hoplimit must be >= %lu.\n",
				    first_hop);
				exit(1);
			}
d491 1
d493 2
a494 2
			if (!*argv || *ep) {
				fprintf(stderr, "traceroute6: port.\n");
d506 1
d508 1
a508 1
			if (!*argv || *ep) {
d534 1
d536 1
a536 1
			if (!*argv || *ep) {
d553 6
d600 1
d602 1
a602 1
		if (!*argv || *ep) {
@


1.29
log
@socklen_t audit.  from deraadt, sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.28 2002/08/30 07:23:50 itojun Exp $	*/
d314 1
a314 1
void	send_probe(int, int);
d334 1
a334 1
int datalen;			/* How much data */
d346 3
a348 3
int nprobes = 3;
int first_hop = 1;
int max_hops = 30;
d367 2
a368 1
	int ch, i, on, probe, seq, hops, rcvcmsglen;
d433 1
a433 1
				    "traceroute6: min hoplimit must be <= %d.\n",
d491 1
a491 1
				    "traceroute6: max hoplimit must be >= %d.\n",
d844 1
a844 1
	fprintf(stderr, ", %d hops max, %d byte packets\n",
d849 1
a849 1
		printf("Skipping %d intermediate hops\n", first_hop - 1);
d859 1
a859 1
		printf("%2d ", hops);
d980 2
a981 1
	int seq, hops;
d1018 1
a1018 1
		printf("traceroute6: wrote %s %d chars, ret=%d\n",
@


1.28
log
@have -I option, which causes traceroute6 to use ICMPv6 echo request for probing
(instead of udp).
@
text
@d1 2
a2 2
/*	$OpenBSD: traceroute6.c,v 1.27 2002/08/27 00:39:36 itojun Exp $	*/
/*	$KAME: traceroute6.c,v 1.60 2002/08/30 04:01:58 onoe Exp $	*/
d786 2
a787 1
		int dummy, len;
d823 1
a823 1
		int len;
@


1.27
log
@warn if multiple addresses are returned from DNS (traceroute(8) should do it too)
sync w/kame
@
text
@d1 2
a2 2
/*	$OpenBSD: traceroute6.c,v 1.26 2002/08/08 23:53:21 stevesk Exp $	*/
/*	$KAME: traceroute6.c,v 1.58 2002/08/27 00:33:39 itojun Exp $	*/
d299 4
d335 1
d351 1
d356 1
d374 1
d417 1
a417 1
	while ((ch = getopt(argc, argv, "df:g:lm:np:q:rs:w:v")) != -1)
d473 4
d607 7
a613 1
	if (datalen < 0 || datalen >= MAXPACKET - sizeof(struct opacket)) {
d615 2
a616 2
		    "traceroute6: packet size must be 0 <= s < %ld.\n",
		    (long)(MAXPACKET - sizeof(struct opacket)));
a618 1
	datalen += sizeof(struct opacket);
d682 1
a682 1
	 * Send UDP
d684 7
a690 3
	if ((sndsock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		perror("socket(SOCK_DGRAM)");
		exit(5);
a979 1
	struct opacket *op = outpacket;
d989 20
a1008 3
	op->seq = seq;
	op->hops = hops;
	(void) gettimeofday(&op->tv, NULL);
d1195 6
a1200 1
		if (up->uh_sport == htons(srcport) &&
d1203 4
d1239 1
a1239 1
 * Increment pointer until find the UDP header.
d1259 1
d1261 1
a1261 1
			 return(NULL);
d1263 1
a1263 1
			 return((struct udphdr *)cp);
d1265 3
a1267 3
			 hlen = sizeof(struct ip6_frag);
			 nh = ((struct ip6_frag *)cp)->ip6f_nxt;
			 break;
d1269 3
a1271 3
			 hlen = (((struct ip6_ext *)cp)->ip6e_len + 2) << 2;
			 nh = ((struct ip6_ext *)cp)->ip6e_nxt;
			 break;
d1273 3
a1275 3
			  hlen = (((struct ip6_ext *)cp)->ip6e_len + 1) << 3;
			  nh = ((struct ip6_ext *)cp)->ip6e_nxt;
			  break;
d1377 2
a1378 2
"usage: traceroute6 [-dlnrv] [-f firsthop] [-g gateway] [-m hoplimit] [-p port]\n"
"       [-q probes] [-s src] [-w waittime] target [datalen]\n");
@


1.26
log
@remove unused struct timezone; ok itojun@@
@
text
@d1 2
a2 2
/*	$OpenBSD: traceroute6.c,v 1.25 2002/06/29 07:46:11 itojun Exp $	*/
/*	$KAME: traceroute6.c,v 1.50 2002/05/26 13:12:07 itojun Exp $	*/
d577 7
@


1.25
log
@check -p out of range.  sync w/kame, hint from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.24 2002/06/09 02:39:17 itojun Exp $	*/
a322 1
struct timezone tz;		/* leftover */
a833 1
			struct timezone tz;
d835 1
a835 1
			(void) gettimeofday(&t1, &tz);
d838 1
a838 1
				(void) gettimeofday(&t2, &tz);
d964 1
a964 1
	(void) gettimeofday(&op->tv, &tz);
@


1.24
log
@strlcpy fix, PR 2727
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.23 2002/06/09 02:15:54 deraadt Exp $	*/
d345 2
a346 2
u_short srcport;
u_short port = 32768+666;	/* start udp dest port # for probe packets */
d367 1
d489 1
a489 1
			port = strtoul(optarg, &ep, 0);
d494 1
a494 1
			if (port < 1) {
d496 1
a496 1
				    "traceroute6: port must be >0.\n");
d499 1
@


1.23
log
@strchr() instead of index()
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.22 2002/06/02 06:42:29 deraadt Exp $	*/
d1162 1
a1162 1
			strlcpy(sbuf, "invalid", sizeof(hbuf));
@


1.22
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.21 2002/05/26 13:24:54 deraadt Exp $	*/
d1294 1
a1294 1
		    (cp = index(domain, '.')))
d1303 1
a1303 1
			if ((cp = index(line, '.')) &&
@


1.21
log
@use sysctl to get ttl from the kernel; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.20 2002/05/26 13:15:18 itojun Exp $	*/
d410 1
a410 1
		switch(ch) {
d846 1
a846 1
					switch(i - 1) {
d1203 1
a1203 1
		switch(nh) {
@


1.20
log
@sync with latest kame.  KNF, port number simplification, and such
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.19 2002/05/21 19:11:08 deraadt Exp $	*/
d256 1
d365 2
d379 3
@


1.19
log
@KNF; itojun ok
@
text
@d1 2
a2 2
/*	$OpenBSD: traceroute6.c,v 1.18 2002/02/19 02:34:10 itojun Exp $	*/
/*	$KAME: traceroute6.c,v 1.39 2000/12/22 15:11:05 itojun Exp $	*/
d344 1
a344 1
u_short ident;
a351 6
#ifdef KAME_SCOPEID
const int niflag = NI_WITHSCOPEID;
#else
const int niflag = 0;
#endif

d772 1
a772 2
		    src0, sizeof(src0), NULL, 0,
		    NI_NUMERICHOST | niflag)) {
d780 1
a780 6
#if 1
	ident = (getpid() & 0xffff) | 0x8000;
#else
	ident = 0;	/* let the kernel pick one */
#endif
	Src.sin6_port = htons(ident);
d786 1
a786 1
	if (ident == 0) {
d790 1
a790 1
		if (getsockname(sndsock, (struct sockaddr *)&Src, &i) < 0) {
d794 1
a794 1
		ident = ntohs(Src.sin6_port);
d801 1
a801 1
	    sizeof(hbuf), NULL, 0, NI_NUMERICHOST | niflag))
d903 1
a903 1
	fdsn = howmany(sock+1, NFDBITS) * sizeof(fd_mask);
d1084 1
a1084 2
			    hbuf, sizeof(hbuf), NULL, 0,
			    NI_NUMERICHOST | niflag) != 0)
d1097 1
a1097 2
			    hbuf, sizeof(hbuf), NULL, 0,
			    NI_NUMERICHOST | niflag) != 0)
d1145 2
a1146 2
		if (up->uh_sport == htons(ident) &&
		    up->uh_dport == htons(port+seq))
d1155 1
a1155 1
		    sbuf, sizeof(sbuf), NULL, 0, NI_NUMERICHOST | niflag) != 0)
d1233 1
a1233 1
	    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST | niflag) != 0)
d1263 1
d1307 1
a1307 1
	    NI_NUMERICHOST | niflag) != 0)
d1315 1
@


1.18
log
@sizeof pedant.
From: Mike Pechkin <mpech@@prosoft.org.lv>
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.17 2002/02/16 21:28:10 millert Exp $	*/
a284 13
#ifndef FD_SET
#define NFDBITS         (8*sizeof(fd_set))
#define FD_SETSIZE      NFDBITS
#define FD_SET(n, p)    ((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
#define FD_CLR(n, p)    ((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
#define FD_ISSET(n, p)  ((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
#define FD_ZERO(p)      bzero((char *)(p), sizeof(*(p)))
#endif

#define Fprintf (void)fprintf
#define Sprintf (void)sprintf
#define Printf (void)printf

d388 1
a388 1
		       sizeof(on)) < 0)
d392 1
a392 1
		       sizeof(on)) < 0)
d399 1
a399 1
		       sizeof(on)) < 0)
d403 1
a403 1
		       sizeof(on)) < 0)
d418 1
a418 1
				Fprintf(stderr,
d423 3
a425 2
				Fprintf(stderr,
				    "traceroute6: min hoplimit must be <= %d.\n", max_hops);
d432 1
a432 1
				Fprintf(stderr,
d443 4
a446 5
							 sizeof(rtbuf),
							 IPV6_RTHDR_TYPE_0,
							 0)) == NULL) {
					Fprintf(stderr,
						"inet6_rth_init failed.\n");
d451 4
a454 4
					  (struct in6_addr *)hp->h_addr)) {
				Fprintf(stderr,
					"inet6_rth_add failed for %s\n",
					optarg);
d460 2
a461 1
			inet6_rthdr_add(cmsg, (struct in6_addr *)hp->h_addr, IPV6_RTHDR_LOOSE);
d472 1
a472 1
				Fprintf(stderr,
d477 3
a479 2
				Fprintf(stderr,
				    "traceroute6: max hoplimit must be >= %d.\n", first_hop);
d490 1
a490 2
				Fprintf(stderr,
				    "traceroute6: port.\n");
d494 1
a494 1
				Fprintf(stderr,
d503 1
a503 1
				Fprintf(stderr,
d508 1
a508 1
				Fprintf(stderr,
d530 1
a530 1
				Fprintf(stderr,
d535 1
a535 1
				Fprintf(stderr,
d562 2
a563 2
		(void)fprintf(stderr,
			      "traceroute6: %s\n", gai_strerror(error));
d567 2
a568 2
		(void)fprintf(stderr,
			      "traceroute6: size of sockaddr mismatch\n");
d574 1
a574 1
		(void)fprintf(stderr, "traceroute6: not enough core\n");
d582 1
a582 1
			Fprintf(stderr,
d588 1
a588 1
		Fprintf(stderr,
d611 1
a611 1
		Fprintf(stderr, "traceroute6: malloc failed\n");
d619 1
a619 1
				  (char *)&on, sizeof(on));
d622 1
a622 1
				  (char *)&on, sizeof(on));
d638 1
a638 1
		sizeof(level));
d640 1
a640 1
		sizeof(level));
d643 1
a643 1
		sizeof(level));
d646 1
a646 1
		sizeof(level));
d650 1
a650 1
		sizeof(level));
d665 1
a665 1
		       sizeof(datalen)) < 0) {
d672 1
a672 1
				  (char *)&on, sizeof(on));
d675 1
a675 1
				  (char *)&on, sizeof(on));
d680 3
a682 3
			       (void *)rth, (rth->ip6r_len + 1) << 3)) {
			Fprintf(stderr, "setsockopt(IPV6_RTHDR): %s\n",
				strerror(errno));
d690 3
a692 3
			       rtbuf, cmsg->cmsg_len) < 0) {
			Fprintf(stderr, "setsockopt(IPV6_PKTOPTIONS): %s\n",
				strerror(errno));
d712 1
a712 1
		sizeof(level));
d714 1
a714 1
		sizeof(level));
d717 1
a717 1
		sizeof(level));
d720 1
a720 1
		sizeof(level));
d724 1
a724 1
		sizeof(level));
d744 1
a744 1
			Printf("traceroute6: %s: %s\n", source,
d749 1
a749 1
			Printf("traceroute6: %s: %s\n", source,
d763 1
a763 1
			      sizeof(Nxt.sin6_addr));
d778 3
a780 3
				src0, sizeof(src0), NULL, 0,
				NI_NUMERICHOST | niflag)) {
			Fprintf(stderr, "getnameinfo failed for source\n");
d790 1
a790 1
	ident = 0;	/*let the kernel pick one*/
d813 1
a813 1
			sizeof(hbuf), NULL, 0, NI_NUMERICHOST | niflag))
d815 2
a816 2
	Fprintf(stderr, "traceroute6");
	Fprintf(stderr, " to %s (%s)", hostname, hbuf);
d818 3
a820 4
		Fprintf(stderr, " from %s", source);
	Fprintf(stderr,
		", %d hops max, %d byte packets\n",
		max_hops, datalen);
d824 1
a824 1
		Printf("Skipping %d intermediate hops\n", first_hop - 1);
d834 1
a834 1
		Printf("%2d ", hops);
d847 1
a847 1
							    &lastaddr)) {
d851 1
a851 1
					Printf("  %g ms", deltaT(&t1, &t2));
d855 1
a855 1
						Printf(" !N");
d859 1
a859 1
						Printf(" !P");
d863 1
a863 1
						Printf(" !S");
d867 1
a867 1
						Printf(" !A");
d872 1
a872 1
							Printf(" !");
d880 1
a880 1
				Printf(" *");
d945 1
a945 1
		buf, ipsec_get_policylen(buf));
d961 2
a962 2
	if(setsockopt(sndsock, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
		      (char *)&hops, sizeof(hops)) < 0) {
d973 1
a973 1
		   (struct sockaddr *)&Dst, Dst.sin6_len);
d977 2
a978 2
		Printf("traceroute6: wrote %s %d chars, ret=%d\n", hostname,
		       datalen, i);
d990 1
a990 1
	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
d1007 1
a1007 1
	     (double)(t2p->tv_usec - t1p->tv_usec) / 1000.0;
a1010 1

d1026 1
a1026 1
		cp = "Pakcet Too Big";
a1070 1

d1099 1
a1099 1
			Printf("packet too short (%d bytes) from %s\n", cc,
d1113 1
a1113 1
			Printf("data too short (%d bytes) from %s\n", cc, hbuf);
d1123 1
a1123 1
	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
d1171 1
a1171 1
		Printf("\n%d bytes from %s to %s", cc, sbuf,
d1173 3
a1175 4
					dbuf, sizeof(dbuf))
			       : "?");
		Printf(": icmp type %d (%s) code %d\n", type, pr_type(type),
		       icp->icmp6_code);
d1180 1
a1180 1
				Printf("%04x:", i);
d1182 2
a1183 2
				Printf(" ");
			Printf("%02x", p[i]);
d1185 1
a1185 1
				Printf("\n");
d1188 1
a1188 1
			Printf("\n");
d1210 1
a1210 1
	while(lim - cp >= 8) {
d1212 3
a1214 3
		 case IPPROTO_ESP:
		 case IPPROTO_TCP:
		 case IPPROTO_ICMPV6:
d1216 1
a1216 1
		 case IPPROTO_UDP:
d1218 1
a1218 1
		 case IPPROTO_FRAGMENT:
d1222 1
a1222 1
		 case IPPROTO_AH:
d1226 1
a1226 1
		  default:
d1250 1
a1250 1
		Printf(" %s", hbuf);
d1252 1
a1252 1
		Printf(" %s (%s)", inetname((struct sockaddr *)from), hbuf);
d1254 1
a1254 1
		Printf(" %s", inetname((struct sockaddr *)from));
d1258 1
a1258 1
		Printf(" %d bytes to %s", cc,
d1260 1
a1260 2
					hbuf, sizeof(hbuf))
			       : "?");
d1262 1
a1262 1
		Printf(" %d bytes of data to %s", cc,
d1264 1
a1264 2
					hbuf, sizeof(hbuf))
			       : "?");
a1283 1

d1328 1
a1328 1
	(void)fprintf(stderr,
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.16 2001/10/26 06:23:02 mpech Exp $	*/
d1319 1
a1319 1
		if (gethostname(domain, MAXHOSTNAMELEN) == 0 &&
@


1.16
log
@getopt(3) returns -1 when out of args, not EOF.

itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.15 2001/01/12 19:10:48 brad Exp $	*/
d315 2
a316 2
int	main __P((int, char *[]));
int	wait_for_reply __P((int, struct msghdr *));
d319 1
a319 1
int	setpolicy __P((int so, char *policy));
d322 10
a331 10
void	send_probe __P((int, int));
struct udphdr *get_udphdr __P((struct ip6_hdr *, u_char *));
int	get_hoplim __P((struct msghdr *));
double	deltaT __P((struct timeval *, struct timeval *));
char	*pr_type __P((int));
int	packet_ok __P((struct msghdr *, int, int));
void	print __P((struct msghdr *, int));
void	tvsub __P((struct timeval *, struct timeval *));
const char *inetname __P((struct sockaddr *));
void	usage __P((void));
@


1.15
log
@typo, enhough -> enough
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.14 2000/12/22 15:17:25 itojun Exp $	*/
d422 1
a422 1
	while ((ch = getopt(argc, argv, "df:g:lm:np:q:rs:w:v")) != EOF)
@


1.14
log
@revoke root priv earlier.  use strl*.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.13 2000/10/07 21:47:31 itojun Exp $	*/
d586 1
a586 1
		(void)fprintf(stderr, "traceroute6: not enhough core\n");
@


1.13
log
@sync with kame, to make future upgrade easier
@
text
@d1 2
a2 2
/*	$OpenBSD: traceroute6.c,v 1.12 2000/10/07 16:05:45 deraadt Exp $	*/
/*	$KAME: traceroute6.c,v 1.33 2000/10/07 06:22:55 itojun Exp $	*/
a283 3
#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN	64
#endif
d382 1
d392 4
a419 4
	/* revoke privs */
	seteuid(getuid());
	setuid(getuid());

d428 7
a434 1
			first_hop = atoi(optarg);
d481 7
a487 1
			max_hops = atoi(optarg);
d498 7
a504 1
			port = atoi(optarg);
d512 7
a518 1
			nprobes = atoi(optarg);
d539 7
a545 1
			waittime = atoi(optarg);
d558 1
a558 1
	if (argc < 1)
d585 4
d590 9
a598 2
	if (*++argv)
		datalen = atoi(*argv);
d826 1
a826 1
		strcpy(hbuf, "(invalid)");
d1113 1
a1113 1
				strcpy(hbuf, "invalid");
d1127 1
a1127 1
				strcpy(hbuf, "invalid");
d1185 1
a1185 1
			strcpy(sbuf, "invalid");
d1264 1
a1264 1
		strcpy(hbuf, "invalid");
d1321 1
a1321 1
			(void) strcpy(domain, cp + 1);
d1340 1
a1340 1
		strcpy(line, "invalid");
d1348 2
a1349 2
"usage: traceroute6 [-dlnrv] [-f first_hop] [-m max_hops] [-p port#] \n"
"       [-q nqueries] [-s src_addr] [-g gateway] [-w wait] host [data size]\n");
@


1.12
log
@use poll to avoid fd_set overflow
@
text
@d1 2
a2 2
/*	$OpenBSD: traceroute6.c,v 1.11 2000/06/30 16:00:29 millert Exp $	*/
/*	$KAME: traceroute6.c,v 1.29 2000/06/12 16:29:18 itojun Exp $	*/
d264 1
d266 1
d872 1
d884 18
@


1.11
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.10 2000/06/12 16:37:10 itojun Exp $	*/
d264 1
d870 1
a870 2
	fd_set fds;
	struct timeval wait;
d873 3
a875 3
	FD_ZERO(&fds);
	FD_SET(sock, &fds);
	wait.tv_sec = waittime; wait.tv_usec = 0;
d877 1
a877 1
	if (select(sock+1, &fds, (fd_set *)0, (fd_set *)0, &wait) > 0)
@


1.10
log
@sync with latest kame traceroute6.  print src address.  -g (source route).
dont choke with unexpected icmp6 packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.9 2000/06/05 12:58:42 itojun Exp $	*/
d600 1
a600 1
		errx(1, ipsec_strerror());
d602 1
a602 1
		errx(1, ipsec_strerror());
d674 1
a674 1
		errx(1, ipsec_strerror());
d676 1
a676 1
		errx(1, ipsec_strerror());
d894 1
a894 1
		warnx(ipsec_strerror());
@


1.9
log
@correct option parser typo.  -f, not -b.
@
text
@d1 2
a2 1
/*	$OpenBSD: traceroute6.c,v 1.8 2000/04/20 17:43:46 angelos Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d257 1
a257 1
#include <netinet/in.h> 
d274 1
a274 1
#include <net/route.h> 
a277 2
#define freehostent(x)

d298 5
d348 1
a348 1
#endif 
a378 2
	extern char *optarg;
	extern int optind;
d381 9
a389 1
	char hbuf[NI_MAXHOST];
d391 1
d393 26
d421 1
a421 1
	while ((ch = getopt(argc, argv, "f:dlm:np:q:rs:w:vg:")) != EOF)
d426 7
a432 2
		case 'l':
			lflag++;
a434 1
#if 0
a435 3
#else
			hp = gethostbyname2(optarg, AF_INET6);
#endif
d470 2
a471 7
		case 'f':
			first_hop = atoi(optarg);
			if (first_hop > max_hops) {
				Fprintf(stderr,
				    "traceroute6: min hoplimit must be <= %d.\n", max_hops);
				exit(1);
			}
a570 7
	/*
	 * Receive ICMP
	 */
	if ((rcvsock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0) {
		perror("socket(ICMPv6)");
		exit(5);
	}
a586 22
	/* specify to tell receiving interface */
#ifdef IPV6_RECVPKTINFO
	if (setsockopt(rcvsock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
		       sizeof(on)) < 0)
		err(1, "setsockopt(IPV6_RECVPKTINFO)");
#else  /* old adv. API */
	if (setsockopt(rcvsock, IPPROTO_IPV6, IPV6_PKTINFO, &on,
		       sizeof(on)) < 0)
		err(1, "setsockopt(IPV6_PKTINFO)");
#endif 

	/* specify to tell value of hoplimit field of received IP6 hdr */
#ifdef IPV6_RECVHOPLIMIT
	if (setsockopt(rcvsock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on,
		       sizeof(on)) < 0)
		err(1, "setsockopt(IPV6_RECVHOPLIMIT)");
#else  /* old adv. API */
	if (setsockopt(rcvsock, IPPROTO_IPV6, IPV6_HOPLIMIT, &on,
		       sizeof(on)) < 0)
		err(1, "setsockopt(IPV6_HOPLIMIT)");
#endif 

d747 7
d785 2
a786 1
	Fprintf(stderr, "traceroute to %s (%s)", hostname, hbuf);
d789 3
a791 1
	Fprintf(stderr, ", %d hops max, %d byte packets\n", max_hops, datalen);
d1043 1
a1043 1
#endif 
d1092 1
d1094 3
d1098 3
a1100 2
	rcvhlim = *hlimp;
 
d1127 3
a1129 2
			inet_ntop(AF_INET6, &rcvpktinfo->ipi6_addr,
				   dbuf, sizeof(dbuf)));
d1215 3
a1217 2
		       inet_ntop(AF_INET6, &rcvpktinfo->ipi6_addr,
				 hbuf, sizeof(hbuf)));
d1220 3
a1222 2
		       inet_ntop(AF_INET6, &rcvpktinfo->ipi6_addr,
				 hbuf, sizeof(hbuf)));
d1288 2
a1289 2
"usage: traceroute6 [-dlnrv] [-m max_hops] [-p port#] [-q nqueries]\n\t\
[-s src_addr] [-g gateway] [-w wait] [-f first_hop] host [data size]\n");
@


1.8
log
@Change -b to -f, similar to Solaris.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.7 2000/04/20 07:57:41 angelos Exp $	*/
d432 1
a432 1
		case 'b':
@


1.8.2.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.11 2000/06/30 16:00:29 millert Exp $	*/
d596 1
a596 1
		errx(1, "%s", ipsec_strerror());
d598 1
a598 1
		errx(1, "%s", ipsec_strerror());
d670 1
a670 1
		errx(1, "%s", ipsec_strerror());
d672 1
a672 1
		errx(1, "%s", ipsec_strerror());
d880 1
a880 1
		warnx("%s", ipsec_strerror());
@


1.7
log
@Yet more typos...I should quit while I'm ahead.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.6 2000/04/20 07:52:18 angelos Exp $	*/
d351 1
a351 1
int min_hops = 1;
d384 1
a384 1
	while ((ch = getopt(argc, argv, "b:dlm:np:q:rs:w:vg:")) != EOF)
d433 2
a434 2
			min_hops = atoi(optarg);
			if (min_hops > max_hops) {
d442 1
a442 1
			if (max_hops < min_hops) {
d444 1
a444 1
				    "traceroute6: max hoplimit must be >= %d.\n", min_hops);
d780 2
a781 2
	if (min_hops > 1)
		Printf("Skipping %d intermediate hops\n", min_hops - 1);
d786 1
a786 1
	for (hops = min_hops; hops <= max_hops; ++hops) {
d1267 1
a1267 1
[-s src_addr] [-g gateway] [-w wait] [-b min_hops] host [data size]\n");
@


1.6
log
@Also forgot to update usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.5 2000/04/20 07:50:54 angelos Exp $	*/
d1267 1
a1267 1
[-s src_addr] [-g gateway] [-w wait] [ -b min_hops] host [data size]\n");
@


1.5
log
@Forgot trailing newline in message.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.4 2000/04/20 07:49:47 angelos Exp $	*/
d1267 1
a1267 1
[-s src_addr] [-g gateway] [-w wait] host [data size]\n");
@


1.4
log
@Same as the traceroute commit just now; add an option for skipping
nodes at the beginning of the trace.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.3 2000/03/12 03:56:44 itojun Exp $	*/
d781 1
a781 1
		Printf("Skipping %d intermediate hops", min_hops - 1);
@


1.3
log
@correct use of perror().  improve src addr selection. (sync with kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.2 2000/03/02 07:44:08 itojun Exp $	*/
d351 1
d384 1
a384 1
	while ((ch = getopt(argc, argv, "dlm:np:q:rs:w:vg:")) != EOF)
d432 8
d442 1
a442 1
			if (max_hops <= 1) {
d444 1
a444 1
				    "traceroute6: max hoplimit must be >1.\n");
d780 3
d786 1
a786 1
	for (hops = 1; hops <= max_hops; ++hops) {
@


1.2
log
@typo fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: traceroute6.c,v 1.1 2000/02/16 06:04:27 itojun Exp $	*/
a338 1
struct sockaddr_in6 *src = &Src, *rcv = &Rcv;
d376 2
a377 3
	int ch, i, on, probe, seq, hops;
	static u_char rcvcmsgbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))
				+ CMSG_SPACE(sizeof(int))];
d524 1
a524 1
		perror("traceroute6: malloc");
d533 1
a533 1
		perror("traceroute6: icmp socket");
d539 2
a540 2
	rcvmhdr.msg_name = (caddr_t)rcv;
	rcvmhdr.msg_namelen = sizeof(*rcv);
d543 6
d550 1
a550 1
	rcvmhdr.msg_controllen = sizeof(rcvcmsgbuf);
d617 1
a617 1
		perror("traceroute6: udp socket");
d623 1
a623 1
		perror("traceroute6: SO_SNDBUF");
d690 1
a690 1
	bzero((char *)src, sizeof(Src));
d692 11
a702 2
		if (inet_pton(AF_INET6, source, &Src.sin6_addr) != 1) {
			Printf("traceroute6: unknown host %s\n", source);
d705 7
a715 1
		len = sizeof(Src);
d722 2
a723 1
			perror("socket") ;
d725 1
a725 1
		if(-1 == connect(dummy, (struct sockaddr *)&Nxt, sizeof(Nxt)))
d727 4
a730 1
		if(-1 == getsockname(dummy, (struct sockaddr *)src, &len)) {
d732 1
a732 1
			printf("%d\n", errno);
d734 1
a734 1
		close(dummy) ;
d736 2
d739 3
a741 1
	Src.sin6_family = AF_INET6;
d743 14
a756 3
	if (bind(sndsock, (struct sockaddr *)src, sizeof(Src))  < 0){
		perror ("traceroute6: bind:");
		exit (1);
d1089 1
a1089 1
		u_long *lp = (u_long *)(icp + 1);
d1100 13
a1112 2
		for (i = 4; i < cc ; i += sizeof(long))
			Printf("%2d: %8.8x\n", i, (u_int32_t)ntohl(*lp++));
@


1.1
log
@add traceroute6 (oops, forgot to bring it in)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d952 1
a952 1
		cp = "Ridirect";
@

