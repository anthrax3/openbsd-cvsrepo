head	1.48;
access;
symbols
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.42.0.8
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.16
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.12
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.10
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.8
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.6
	OPENBSD_5_0:1.41.0.4
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.36.0.12
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.10
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.8
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.6
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.4
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.31.0.4
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.4
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.16.0.6
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.16.0.4
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.14.0.6
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.4
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2015.10.14.13.32.44;	author jsg;	state Exp;
branches;
next	1.47;
commitid	ACGeYYHDXfLfUwIh;

1.47
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	sbrB3Q5CNxcwZpfU;

1.46
date	2015.10.08.14.02.09;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	rpDpwBK6ub05RGSl;

1.45
date	2015.09.13.15.44.47;	author guenther;	state Exp;
branches;
next	1.44;
commitid	pjR4xrhVkhrUEI1x;

1.44
date	2015.09.13.14.57.33;	author guenther;	state Exp;
branches;
next	1.43;
commitid	iJLDFT0Zpsuu4Es0;

1.43
date	2015.09.01.17.31.59;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	SnJAcLgw1D72QJ0D;

1.42
date	2014.03.16.18.38.30;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2010.08.22.21.28.32;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.12.05.42.09;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2009.05.20.20.37.43;	author thib;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.18.00.40.14;	author dhill;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.03.18.54.07;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.22.21.19.39;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.03.01.01.15;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2004.09.14.22.28.50;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.16.01.11.09;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.25.04.56.42;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.26.19.47.09;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.01.20.19.51.36;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.26.03.03.27;	author pvalchev;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.15.23.47.57;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.09.22.20.43;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.08.08.52.23;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.28.07;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.27.20.34.36;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.31.17.28.26;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.31.17.27.11;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.01.04.03.00.27;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.04.27.02.02.57;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.04.15.15.18.49;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.01.17.16.07.27;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.01.15.23.44.12;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.10.06.04.13.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.07.31.11.09.15;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.07.29.11.31.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.07.29.09.29.14;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.07.25.22.03.05;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.18.11.40.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.07.20.15.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.01.00.35.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.29.19.03.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.05.16.15.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.57;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.48
log
@include err.h for the err() calls added in rev 1.46
@
text
@/*	$OpenBSD: portmap.c,v 1.47 2015/10/09 01:37:09 deraadt Exp $	*/

/*-
 * Copyright (c) 1996, 1997 Theo de Raadt (OpenBSD). All rights reserved.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * portmap.c, Implements the program,version to port number mapping for
 * rpc.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/resource.h>

#include <rpcsvc/nfs_prot.h>
#include <arpa/inet.h>
#include <rpc/rpc.h>
#include <rpc/pmap_prot.h>

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <netdb.h>
#include <pwd.h>
#include <errno.h>
#include <err.h>

void reg_service(struct svc_req *, SVCXPRT *);
void reap(int);
void callit(struct svc_req *, SVCXPRT *);
int check_callit(struct sockaddr_in *, u_long, u_long);
struct pmaplist *find_service(u_long, u_long, u_long);

struct pmaplist *pmaplist;
int debugging;

SVCXPRT *ludpxprt, *ltcpxprt;

int
main(int argc, char *argv[])
{
	int sock, lsock, c, on = 1;
	socklen_t len = sizeof(struct sockaddr_in);
	struct sockaddr_in addr, laddr;
	struct pmaplist *pml;
	struct passwd *pw;
	SVCXPRT *xprt;

	while ((c = getopt(argc, argv, "d")) != -1) {
		switch (c) {
		case 'd':
			debugging = 1;
			break;
		default:
			(void)fprintf(stderr, "usage: %s [-d]\n", argv[0]);
			exit(1);
		}
	}

	if (!debugging && daemon(0, 0)) {
		(void)fprintf(stderr, "portmap: fork: %s", strerror(errno));
		exit(1);
	}

	openlog("portmap", LOG_NDELAY | (debugging ? LOG_PID | LOG_PERROR :
	    LOG_PID), LOG_DAEMON);

	bzero(&addr, sizeof addr);
	addr.sin_addr.s_addr = 0;
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sin_port = htons(PMAPPORT);

	bzero(&laddr, sizeof laddr);
	laddr.sin_addr.s_addr = 0;
	laddr.sin_family = AF_INET;
	laddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	laddr.sin_port = htons(PMAPPORT);

	if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
		syslog(LOG_ERR, "cannot create udp socket: %m");
		exit(1);
	}
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof on);
	if (bind(sock, (struct sockaddr *)&addr, len) != 0) {
		syslog(LOG_ERR, "cannot bind udp: %m");
		exit(1);
	}

	if ((xprt = svcudp_create(sock)) == NULL) {
		syslog(LOG_ERR, "couldn't do udp_create");
		exit(1);
	}

	if ((lsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
		syslog(LOG_ERR, "cannot create udp socket: %m");
		exit(1);
	}
	setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof on);
	if (bind(lsock, (struct sockaddr *)&laddr, len) != 0) {
		syslog(LOG_ERR, "cannot bind local udp: %m");
		exit(1);
	}

	if ((ludpxprt = svcudp_create(lsock)) == NULL) {
		syslog(LOG_ERR, "couldn't do udp_create");
		exit(1);
	}

	/* make an entry for ourself */
	pml = malloc(sizeof(struct pmaplist));
	if (pml == NULL) {
		syslog(LOG_ERR, "out of memory");
		exit(1);
	}
	pml->pml_next = 0;
	pml->pml_map.pm_prog = PMAPPROG;
	pml->pml_map.pm_vers = PMAPVERS;
	pml->pml_map.pm_prot = IPPROTO_UDP;
	pml->pml_map.pm_port = PMAPPORT;
	pmaplist = pml;

	if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
		syslog(LOG_ERR, "cannot create tcp socket: %m");
		exit(1);
	}
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof on);
	if (bind(sock, (struct sockaddr *)&addr, len) != 0) {
		syslog(LOG_ERR, "cannot bind tcp: %m");
		exit(1);
	}
	if ((xprt = svctcp_create(sock, RPCSMALLMSGSIZE, RPCSMALLMSGSIZE)) ==
	    NULL) {
		syslog(LOG_ERR, "couldn't do tcp_create");
		exit(1);
	}

	if ((lsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
		syslog(LOG_ERR, "cannot create tcp socket: %m");
		exit(1);
	}
	setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof on);
	if (bind(lsock, (struct sockaddr *)&laddr, len) != 0) {
		syslog(LOG_ERR, "cannot bind tcp: %m");
		exit(1);
	}
	if ((ltcpxprt = svctcp_create(lsock, RPCSMALLMSGSIZE,
	    RPCSMALLMSGSIZE)) == NULL) {
		syslog(LOG_ERR, "couldn't do tcp_create");
		exit(1);
	}

	/* make an entry for ourself */
	pml = malloc(sizeof(struct pmaplist));
	if (pml == NULL) {
		syslog(LOG_ERR, "out of memory");
		exit(1);
	}
	pml->pml_map.pm_prog = PMAPPROG;
	pml->pml_map.pm_vers = PMAPVERS;
	pml->pml_map.pm_prot = IPPROTO_TCP;
	pml->pml_map.pm_port = PMAPPORT;
	pml->pml_next = pmaplist;
	pmaplist = pml;

	if ((pw = getpwnam("_portmap")) == NULL) {
		syslog(LOG_ERR, "no such user _portmap");
		exit(1);
	}
	if (chroot("/var/empty") == -1) {
		syslog(LOG_ERR, "cannot chroot to /var/empty.");
		exit(1);
	}
	if (chdir("/") == -1) {
		syslog(LOG_ERR, "cannot chdir to new /.");
		exit(1);
	}

	if (pw) {
		if (setgroups(1, &pw->pw_gid) == -1 ||
		    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1 ||
		    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1) {
			syslog(LOG_ERR, "revoke privs: %s", strerror(errno));
			exit(1);
		}
	}
	endpwent();

	if (pledge("stdio rpath inet proc", NULL) == -1)
		err(1, "pledge");

	if (svc_register(xprt, PMAPPROG, PMAPVERS, reg_service, FALSE) == 0) {
		syslog(LOG_ERR, "svc_register failed.");
		exit(1);
	}

	(void)signal(SIGCHLD, reap);
	svc_run();
	syslog(LOG_ERR, "svc_run returned unexpectedly");
	abort();
}

struct pmaplist *
find_service(u_long prog, u_long vers, u_long prot)
{
	struct pmaplist *hit = NULL;
	struct pmaplist *pml;

	for (pml = pmaplist; pml != NULL; pml = pml->pml_next) {
		if ((pml->pml_map.pm_prog != prog) ||
		    (pml->pml_map.pm_prot != prot))
			continue;
		hit = pml;
		if (pml->pml_map.pm_vers == vers)
			break;
	}
	return (hit);
}

/*
 * 1 OK, 0 not
 */
void
reg_service(struct svc_req *rqstp, SVCXPRT *xprt)
{
	struct pmap reg;
	struct pmaplist *pml, *prevpml, *fnd;
	struct sockaddr_in *fromsin;
	long ans = 0, port;
	void *t;

	fromsin = svc_getcaller(xprt);

	if (debugging)
		(void)fprintf(stderr, "server: about to do a switch\n");
	switch (rqstp->rq_proc) {
	case PMAPPROC_NULL:
		/*
		 * Null proc call
		 */
		if (!svc_sendreply(xprt, xdr_void, NULL) && debugging) {
			abort();
		}
		break;
	case PMAPPROC_SET:
		/*
		 * Set a program,version to port mapping
		 */
		if (xprt != ltcpxprt && xprt != ludpxprt) {
			syslog(LOG_WARNING,
			    "non-local set attempt (might be from %s)",
			    inet_ntoa(fromsin->sin_addr));
			svcerr_noproc(xprt);
			return;
		}
		if (!svc_getargs(xprt, xdr_pmap, (caddr_t)&reg)) {
			svcerr_decode(xprt);
			break;
		}

		/*
		 * check to see if already used
		 * find_service returns a hit even if
		 * the versions don't match, so check for it
		 */
		fnd = find_service(reg.pm_prog, reg.pm_vers, reg.pm_prot);
		if (fnd && fnd->pml_map.pm_vers == reg.pm_vers) {
			if (fnd->pml_map.pm_port == reg.pm_port)
				ans = 1;
			goto done;
		}

		if (debugging)
			printf("set: prog %lu vers %lu port %lu\n",
			    reg.pm_prog, reg.pm_vers, reg.pm_port);

		if (reg.pm_port & ~0xffff)
			goto done;

		/*
		 * only permit localhost root to create
		 * mappings pointing at sensitive ports
		 */
		if ((reg.pm_port < IPPORT_RESERVED ||
		    reg.pm_port == NFS_PORT) &&
		    htons(fromsin->sin_port) >= IPPORT_RESERVED) {
			syslog(LOG_WARNING,
			    "resvport set attempt by non-root");
			goto done;
		}

		/*
		 * add to END of list
		 */
		pml = malloc(sizeof(struct pmaplist));
		if (pml == NULL) {
			syslog(LOG_ERR, "out of memory");
			svcerr_systemerr(xprt);
			return;
		}

		pml->pml_map = reg;
		pml->pml_next = 0;
		if (pmaplist == NULL) {
			pmaplist = pml;
		} else {
			for (fnd = pmaplist; fnd->pml_next != 0;
			    fnd = fnd->pml_next)
				;
			fnd->pml_next = pml;
		}
		ans = 1;
done:
		if ((!svc_sendreply(xprt, xdr_long, (caddr_t)&ans)) &&
		    debugging) {
			(void)fprintf(stderr, "svc_sendreply\n");
			abort();
		}
		break;
	case PMAPPROC_UNSET:
		/*
		 * Remove a program,version to port mapping.
		 */
		if (xprt != ltcpxprt && xprt != ludpxprt) {
			syslog(LOG_WARNING,
			    "non-local unset attempt (might be from %s)",
			    inet_ntoa(fromsin->sin_addr));
			svcerr_noproc(xprt);
			return;
		}
		if (!svc_getargs(xprt, xdr_pmap, (caddr_t)&reg)) {
			svcerr_decode(xprt);
			break;
		}
		for (prevpml = NULL, pml = pmaplist; pml != NULL; ) {
			if ((pml->pml_map.pm_prog != reg.pm_prog) ||
			    (pml->pml_map.pm_vers != reg.pm_vers)) {
				/* both pml & prevpml move forwards */
				prevpml = pml;
				pml = pml->pml_next;
				continue;
			}
			if ((pml->pml_map.pm_port < IPPORT_RESERVED ||
			    pml->pml_map.pm_port == NFS_PORT) &&
			    htons(fromsin->sin_port) >= IPPORT_RESERVED) {
				syslog(LOG_WARNING,
				    "resvport unset attempt by non-root");
				break;
			}

			/* found it; pml moves forward, prevpml stays */
			ans = 1;
			t = pml;
			pml = pml->pml_next;
			if (prevpml == NULL)
				pmaplist = pml;
			else
				prevpml->pml_next = pml;
			free(t);
		}
		if ((!svc_sendreply(xprt, xdr_long, (caddr_t)&ans)) &&
		    debugging) {
			fprintf(stderr, "svc_sendreply\n");
			abort();
		}
		break;
	case PMAPPROC_GETPORT:
		/*
		 * Lookup the mapping for a program,version and return its port
		 */
		if (!svc_getargs(xprt, xdr_pmap, (caddr_t)&reg)) {
			svcerr_decode(xprt);
			break;
		}
		fnd = find_service(reg.pm_prog, reg.pm_vers, reg.pm_prot);
		if (fnd)
			port = fnd->pml_map.pm_port;
		else
			port = 0;
		if ((!svc_sendreply(xprt, xdr_long, (caddr_t)&port)) &&
		    debugging) {
			fprintf(stderr, "svc_sendreply\n");
			abort();
		}
		break;
	case PMAPPROC_DUMP:
		/*
		 * Return the current set of mapped program,version
		 */
		if (!svc_getargs(xprt, xdr_void, NULL)) {
			svcerr_decode(xprt);
			break;
		}
		if (!svc_sendreply(xprt, xdr_pmaplist, (caddr_t)&pmaplist) &&
		    debugging) {
			fprintf(stderr, "svc_sendreply\n");
			abort();
		}
		break;
	case PMAPPROC_CALLIT:
		/*
		 * Calls a procedure on the local machine.  If the requested
		 * procedure is not registered this procedure does not return
		 * error information!!
		 * This procedure is only supported on rpc/udp and calls via
		 * rpc/udp.  It passes null authentication parameters.
		 */
		callit(rqstp, xprt);
		break;
	default:
		svcerr_noproc(xprt);
		break;
	}
}


/*
 * Stuff for the rmtcall service
 */
#define ARGSIZE 9000

struct encap_parms {
	u_int arglen;
	char *args;
};

static bool_t
xdr_encap_parms(XDR *xdrs, struct encap_parms *epp)
{

	return (xdr_bytes(xdrs, &(epp->args), &(epp->arglen), ARGSIZE));
}

struct rmtcallargs {
	u_long	rmt_prog;
	u_long	rmt_vers;
	u_long	rmt_port;
	u_long	rmt_proc;
	struct encap_parms rmt_args;
};

/*
 * Version of xdr_rmtcall_args() that supports both directions
 */
static bool_t
portmap_xdr_rmtcall_args(XDR *xdrs, struct rmtcallargs *cap)
{

	/* does not get a port number */
	if (xdr_u_long(xdrs, &(cap->rmt_prog)) &&
	    xdr_u_long(xdrs, &(cap->rmt_vers)) &&
	    xdr_u_long(xdrs, &(cap->rmt_proc))) {
		return (xdr_encap_parms(xdrs, &(cap->rmt_args)));
	}
	return (FALSE);
}

/*
 * Version of xdr_rmtcallres() that supports both directions
 */
static bool_t
portmap_xdr_rmtcallres(XDR *xdrs, struct rmtcallargs *cap)
{
	if (xdr_u_long(xdrs, &(cap->rmt_port)))
		return (xdr_encap_parms(xdrs, &(cap->rmt_args)));
	return (FALSE);
}

/*
 * only worries about the struct encap_parms part of struct rmtcallargs.
 * The arglen must already be set!!
 */
static bool_t
xdr_opaque_parms(XDR *xdrs, struct rmtcallargs *cap)
{

	return (xdr_opaque(xdrs, cap->rmt_args.args, cap->rmt_args.arglen));
}

/*
 * This routine finds and sets the length of incoming opaque paraters
 * and then calls xdr_opaque_parms.
 */
static bool_t
xdr_len_opaque_parms(XDR *xdrs, struct rmtcallargs *cap)
{
	u_int beginpos, lowpos, highpos, currpos, pos;

	beginpos = lowpos = pos = xdr_getpos(xdrs);
	highpos = lowpos + ARGSIZE;
	while (highpos >= lowpos) {
		currpos = (lowpos + highpos) / 2;
		if (xdr_setpos(xdrs, currpos)) {
			pos = currpos;
			lowpos = currpos + 1;
		} else {
			highpos = currpos - 1;
		}
	}
	xdr_setpos(xdrs, beginpos);
	cap->rmt_args.arglen = pos - beginpos;
	return (xdr_opaque_parms(xdrs, cap));
}

/*
 * Call a remote procedure service
 * This procedure is very quiet when things go wrong.
 * The proc is written to support broadcast rpc.  In the broadcast case,
 * a machine should shut-up instead of complain, less the requestor be
 * overrun with complaints at the expense of not hearing a valid reply ...
 *
 * This now forks so that the program & process that it calls can call
 * back to the portmapper.
 */
void
callit(struct svc_req *rqstp, SVCXPRT *xprt)
{
	struct rmtcallargs a;
	struct pmaplist *pml;
	u_short port;
	struct sockaddr_in me;
	pid_t pid;
	int so = -1;
	CLIENT *client;
	struct authunix_parms *au = (struct authunix_parms *)rqstp->rq_clntcred;
	struct timeval timeout;
	char buf[ARGSIZE];

	timeout.tv_sec = 5;
	timeout.tv_usec = 0;
	a.rmt_args.args = buf;
	if (!svc_getargs(xprt, portmap_xdr_rmtcall_args, (caddr_t)&a))
		return;
	if (!check_callit(svc_getcaller(xprt), a.rmt_prog, a.rmt_proc))
		return;
	if ((pml = find_service(a.rmt_prog, a.rmt_vers,
	    (u_long)IPPROTO_UDP)) == NULL)
		return;

	/*
	 * fork a child to do the work.  Parent immediately returns.
	 * Child exits upon completion.
	 */
	if ((pid = fork()) != 0) {
		if (pid == -1)
			syslog(LOG_ERR, "CALLIT (prog %lu): fork: %m",
			    a.rmt_prog);
		return;
	}

	if (pledge("stdio rpath inet", NULL) == -1)
		err(1, "pledge");

	port = pml->pml_map.pm_port;
	get_myaddress(&me);
	me.sin_port = htons(port);

	/* Avoid implicit binding to reserved port by clntudp_create() */
	so = socket(AF_INET, SOCK_DGRAM | SOCK_NONBLOCK, IPPROTO_UDP);
	if (so == -1)
		exit(1);

	client = clntudp_create(&me, a.rmt_prog, a.rmt_vers, timeout, &so);
	if (client != NULL) {
		if (rqstp->rq_cred.oa_flavor == AUTH_UNIX)
			client->cl_auth = authunix_create(au->aup_machname,
			    au->aup_uid, au->aup_gid, au->aup_len, au->aup_gids);
		a.rmt_port = (u_long)port;
		if (clnt_call(client, a.rmt_proc, xdr_opaque_parms, &a,
		    xdr_len_opaque_parms, &a, timeout) == RPC_SUCCESS)
			svc_sendreply(xprt, portmap_xdr_rmtcallres, (caddr_t)&a);
		AUTH_DESTROY(client->cl_auth);
		clnt_destroy(client);
	}
	(void)close(so);
	exit(0);
}

/* ARGSUSED */
void
reap(int signo)
{
	int save_errno = errno;

	while (wait3(NULL, WNOHANG, NULL) > 0)
		;
	errno = save_errno;
}

#define	NFSPROG			((u_long) 100003)
#define	MOUNTPROG		((u_long) 100005)
#define	YPXPROG			((u_long) 100069)
#define	YPPROG			((u_long) 100004)
#define	YPPROC_DOMAIN_NONACK	((u_long) 2)
#define	MOUNTPROC_MNT		((u_long) 1)
#define XXXPROC_NOP		((u_long) 0)

int
check_callit(struct sockaddr_in *addr, u_long prog, u_long aproc)
{
	if ((prog == PMAPPROG && aproc != XXXPROC_NOP) ||
	    (prog == NFSPROG && aproc != XXXPROC_NOP) ||
	    (prog == YPXPROG && aproc != XXXPROC_NOP) ||
	    (prog == MOUNTPROG && aproc == MOUNTPROC_MNT) ||
	    (prog == YPPROG && aproc != YPPROC_DOMAIN_NONACK)) {
		syslog(LOG_WARNING,
		    "callit prog %ld aproc %ld (might be from %s)",
		    prog, aproc, inet_ntoa(addr->sin_addr));
		return (FALSE);
	}
	return (TRUE);
}
@


1.47
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.46 2015/10/08 14:02:09 deraadt Exp $	*/
d87 1
@


1.46
log
@portmap's main process can be tame "stdio rpath inet proc"; proc is
for the callit interface needing to fork, and parent needing to wait.
that child can drop to "stdio rpath inet".

It is possible some libc/rpc codepath has not yet been figured out, but
commiting it is the best way to get it tested. Tested what I could myself,
but noone answered my call for testing...
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.45 2015/09/13 15:44:47 guenther Exp $	*/
d249 2
a250 2
	if (tame("stdio rpath inet proc", NULL) == -1)
		err(1, "tame");
d611 2
a612 2
	if (tame("stdio rpath inet", NULL) == -1)
		err(1, "tame");
@


1.45
log
@More FNDELAY/FIONBIO --> SOCK_NONBLOCK conversions

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.44 2015/09/13 14:57:33 guenther Exp $	*/
d249 3
d610 4
@


1.44
log
@Rename the routines used for packing/unpacking rmtcall RPCs so they don't
conflict with those in libc.  They're already static, but best to be clear
that they're different in functionality, supporting operations that libc's
don't need or have.

with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.43 2015/09/01 17:31:59 deraadt Exp $	*/
a69 1
#include <sys/ioctl.h>
d580 1
a580 1
	int so = -1, dontblock = 1;
d612 1
a612 1
	so = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
a613 2
		exit(1);
	if (ioctl(so, FIONBIO, &dontblock) == -1)
@


1.43
log
@stop defining a local copy of perror(); libc/rpc no longer uses it.
ok beck millert miod
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.42 2014/03/16 18:38:30 guenther Exp $	*/
d500 3
d504 1
a504 1
xdr_rmtcall_args(XDR *xdrs, struct rmtcallargs *cap)
d516 3
d520 1
a520 1
xdr_rmtcall_result(XDR *xdrs, struct rmtcallargs *cap)
d590 1
a590 1
	if (!svc_getargs(xprt, xdr_rmtcall_args, (caddr_t)&a))
d627 1
a627 1
			svc_sendreply(xprt, xdr_rmtcall_result, (caddr_t)&a);
@


1.42
log
@lint is dead (long live the lint!), so stop using it as a cpp conditional
(namespace pollution!) or talking about its opinion on code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.41 2010/09/01 14:43:34 millert Exp $	*/
a258 8
}

/* need to override perror calls in rpc library */
void
perror(const char *what)
{

	syslog(LOG_ERR, "%s: %m", what);
@


1.41
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.40 2010/08/22 21:28:32 tedu Exp $	*/
a260 1
#ifndef lint
a267 1
#endif
@


1.40
log
@small bits of cleanup.  ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.39 2009/11/12 05:42:09 deraadt Exp $	*/
d32 30
a65 29
 */

/*
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 *
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
@


1.39
log
@a sprinkle of knf
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.38 2009/10/27 23:59:53 deraadt Exp $	*/
d95 1
a95 1
int debugging = 0;
d102 2
a103 1
	int sock, lsock, c, on = 1, len = sizeof(struct sockaddr_in);
a110 1

a113 1

d115 1
a115 1
			(void) fprintf(stderr, "usage: %s [-d]\n", argv[0]);
d121 1
a121 1
		(void) fprintf(stderr, "portmap: fork: %s", strerror(errno));
d125 2
a126 2
	openlog("portmap", LOG_NDELAY | (debugging ? LOG_PID | LOG_PERROR : LOG_PID),
	    LOG_DAEMON);
d128 1
a128 1
	bzero((char *)&addr, sizeof addr);
d134 1
a134 1
	bzero((char *)&laddr, sizeof laddr);
d150 1
a150 1
	if ((xprt = svcudp_create(sock)) == (SVCXPRT *)NULL) {
d165 1
a165 1
	if ((ludpxprt = svcudp_create(lsock)) == (SVCXPRT *)NULL) {
d171 1
a171 1
	pml = (struct pmaplist *)malloc((u_int)sizeof(struct pmaplist));
d192 2
a193 2
	if ((xprt = svctcp_create(sock, RPCSMALLMSGSIZE, RPCSMALLMSGSIZE))
	    == (SVCXPRT *)NULL) {
d208 1
a208 1
	    RPCSMALLMSGSIZE)) == (SVCXPRT *)NULL) {
d214 1
a214 1
	pml = (struct pmaplist *)malloc((u_int)sizeof(struct pmaplist));
a225 1

d231 5
a235 1
		syslog(LOG_ERR, "cannot chdir to /var/empty.");
a238 1
	chdir("/");
d297 1
a297 1
	caddr_t t;
d302 1
a302 1
		(void) fprintf(stderr, "server: about to do a switch\n");
a303 1

d308 1
a308 1
		if (!svc_sendreply(xprt, xdr_void, (caddr_t)0) && debugging) {
a311 1

d362 1
a362 1
		pml = (struct pmaplist *)malloc(sizeof(struct pmaplist));
d380 1
a380 1
	done:
d383 1
a383 1
			(void) fprintf(stderr, "svc_sendreply\n");
a386 1

d420 1
a420 1
			t = (caddr_t)pml;
a433 1

a452 1

a466 1

a476 1

d552 1
a552 1
	while ((int)(highpos - lowpos) >= 0) {
d623 1
a623 1
	if (client != (CLIENT *)NULL) {
d666 2
a667 2
		    "callit prog %d aproc %d (might be from %s)",
		    (int)prog, (int)aproc, inet_ntoa(addr->sin_addr));
@


1.38
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.37 2009/05/20 20:37:43 thib Exp $	*/
d372 1
a372 1
		if (pmaplist == 0) {
d376 2
a377 1
			    fnd = fnd->pml_next);
@


1.37
log
@Do not fall back to using nobody if _user is missing, but
error out.

Add a new user _rwalld for rpc.rwalld, and use that instead
of nobody, also unconditionally drop to _rwalld not only
if rpc.rwalld was started with euid 0 (as root).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.35 2006/01/03 18:54:07 millert Exp $	*/
a31 19

#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1990 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "from: @@(#)portmap.c	5.4 (Berkeley) 4/19/91";
#else
static char rcsid[] = "$OpenBSD: portmap.c,v 1.35 2006/01/03 18:54:07 millert Exp $";
#endif
#endif /* not lint */

/*
@@(#)portmap.c	2.3 88/08/11 4.0 RPCSRC
static char sccsid[] = "@@(#)portmap.c 1.32 87/08/06 Copyr 1984 Sun Micro";
*/
@


1.36
log
@add missing function declaration
remove unused parameter from check_callit()

ok deraadt@@ ray@@
@
text
@d246 5
a250 3
	pw = getpwnam("_portmap");
	if (!pw)
		pw = getpwnam("nobody");
d255 1
@


1.35
log
@include signal.h not sys/signal.h and remove a useless cast; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.34 2005/05/22 21:19:39 henning Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.34 2005/05/22 21:19:39 henning Exp $";
d110 2
a111 1
int check_callit(struct sockaddr_in *, u_long, u_long, u_long);
d616 1
a616 2
	if (!check_callit(svc_getcaller(xprt), rqstp->rq_proc,
	    a.rmt_prog, a.rmt_proc))
d679 1
a679 2
check_callit(struct sockaddr_in *addr, u_long proc, u_long prog,
    u_long aproc)
@


1.34
log
@misisng endpwent(), spotted by Daniel Cid <daniel.cid@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.33 2005/05/03 01:01:15 djm Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.33 2005/05/03 01:01:15 djm Exp $";
d86 8
d96 2
a105 7
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <sys/signal.h>
#include <sys/resource.h>
#include <rpcsvc/nfs_prot.h>
#include <arpa/inet.h>
d268 1
a268 1
	(void)signal(SIGCHLD, (void (*)(int))reap);
@


1.33
log
@more setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.32 2004/09/14 22:28:50 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.32 2004/09/14 22:28:50 deraadt Exp $";
d258 1
@


1.32
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.31 2004/03/16 01:11:09 tedu Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.31 2004/03/16 01:11:09 tedu Exp $";
d251 6
a256 5
		setgroups(1, &pw->pw_gid);
		setegid(pw->pw_gid);
		setgid(pw->pw_gid);
		seteuid(pw->pw_uid);
		setuid(pw->pw_uid);
@


1.31
log
@errno is not specified to be int, but something from errno.h.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.30 2003/08/25 04:56:42 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.30 2003/08/25 04:56:42 deraadt Exp $";
d654 1
@


1.30
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.29 2003/06/26 19:47:09 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.29 2003/06/26 19:47:09 deraadt Exp $";
d95 1
a110 1
extern int errno;
@


1.29
log
@strict proto cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.28 2003/06/02 23:36:54 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.28 2003/06/02 23:36:54 millert Exp $";
d104 1
a104 1
void reap(void);
d655 1
a655 1
reap()
@


1.28
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.27 2003/01/20 19:51:36 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.27 2003/01/20 19:51:36 deraadt Exp $";
d263 1
a263 1
	(void)signal(SIGCHLD, (void (*)())reap);
@


1.27
log
@use LOG_NDELAY in chroot() using daemons
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.26 2002/08/26 03:03:27 pvalchev Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.26 2002/08/26 03:03:27 pvalchev Exp $";
@


1.26
log
@Check svc_register() return value and bomb out on failure; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.25 2002/07/15 23:47:57 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.25 2002/07/15 23:47:57 deraadt Exp $";
d145 1
a145 1
	openlog("portmap", debugging ? LOG_PID | LOG_PERROR : LOG_PID,
@


1.25
log
@5 new uid/gid sets; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.24 2002/07/09 22:20:43 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.24 2002/07/09 22:20:43 deraadt Exp $";
d262 4
a265 1
	(void)svc_register(xprt, PMAPPROG, PMAPVERS, reg_service, FALSE);
@


1.24
log
@detect memory failure; cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.23 2002/07/08 08:52:23 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.23 2002/07/08 08:52:23 deraadt Exp $";
d124 1
d245 16
@


1.23
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.22 2002/05/30 19:09:05 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.22 2002/05/30 19:09:05 deraadt Exp $";
d191 4
d234 4
d358 6
@


1.22
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.21 2002/03/14 16:44:25 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.21 2002/03/14 16:44:25 mpech Exp $";
d98 1
d119 1
a119 3
main(argc, argv)
	int argc;
	char **argv;
d121 1
a121 2
	SVCXPRT *xprt;
	int sock, lsock, c;
a122 2
	int on = 1;
	int len = sizeof(struct sockaddr_in);
d124 1
d248 1
a248 2
perror(what)
	const char *what;
d256 1
a256 2
find_service(prog, vers, prot)
	u_long prog, vers, prot;
d276 1
a276 3
reg_service(rqstp, xprt)
	struct svc_req *rqstp;
	SVCXPRT *xprt;
d480 1
a480 3
xdr_encap_parms(xdrs, epp)
	XDR *xdrs;
	struct encap_parms *epp;
d495 1
a495 3
xdr_rmtcall_args(xdrs, cap)
	XDR *xdrs;
	struct rmtcallargs *cap;
d508 1
a508 3
xdr_rmtcall_result(xdrs, cap)
	XDR *xdrs;
	struct rmtcallargs *cap;
d520 1
a520 3
xdr_opaque_parms(xdrs, cap)
	XDR *xdrs;
	struct rmtcallargs *cap;
d531 1
a531 3
xdr_len_opaque_parms(xdrs, cap)
	XDR *xdrs;
	struct rmtcallargs *cap;
d562 1
a562 3
callit(rqstp, xprt)
	struct svc_req *rqstp;
	SVCXPRT *xprt;
d643 2
a644 5
check_callit(addr, proc, prog, aproc)
	struct sockaddr_in *addr;
	u_long  proc;
	u_long  prog;
	u_long  aproc;
@


1.21
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.20 2002/02/16 21:28:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.20 2002/02/16 21:28:07 millert Exp $";
d68 1
a68 1
 * 
d72 1
a72 1
 * 
d76 1
a76 1
 * 
d80 1
a80 1
 * 
d84 1
a84 1
 * 
d277 1
a277 1
/* 
d290 1
a290 1
	
d353 1
a353 1
		/* 
d463 1
a463 1
		 * This procedure is only supported on rpc/udp and calls via 
d575 1
a575 1
 * This now forks so that the program & process that it calls can call 
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.19 2001/07/27 20:34:36 pvalchev Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.19 2001/07/27 20:34:36 pvalchev Exp $";
d127 1
a127 1
	register struct pmaplist *pml;
d263 2
a264 2
	register struct pmaplist *hit = NULL;
	register struct pmaplist *pml;
d505 2
a506 2
	register XDR *xdrs;
	register struct rmtcallargs *cap;
d520 2
a521 2
	register XDR *xdrs;
	register struct rmtcallargs *cap;
d547 1
a547 1
	register XDR *xdrs;
d550 1
a550 1
	register u_int beginpos, lowpos, highpos, currpos, pos;
@


1.19
log
@Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.18 2000/07/31 17:28:26 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.18 2000/07/31 17:28:26 deraadt Exp $";
d106 4
a109 4
void reg_service __P((struct svc_req *, SVCXPRT *));
void reap	__P((void));
void callit __P((struct svc_req *, SVCXPRT *));
int check_callit __P((struct sockaddr_in *, u_long, u_long, u_long));
@


1.18
log
@before, we blocked non-root from changing mappings pointed at reserved ports.
Now, block non-root from setting them up in the first place.
Also, check that pm_port is not > 65536
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.17 2000/07/31 17:27:11 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.17 2000/07/31 17:27:11 deraadt Exp $";
d335 1
a335 1
			printf("set: prog %u vers %u port %u\n",
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.16 1999/01/04 03:00:27 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.16 1999/01/04 03:00:27 deraadt Exp $";
d334 13
a346 3
		/* check if secure */
		if (fnd && (fnd->pml_map.pm_port < IPPORT_RESERVED ||
		    fnd->pml_map.pm_port == NFS_PORT) &&
d348 2
a349 1
			syslog(LOG_WARNING, "resvport set attempt by non-root");
@


1.16
log
@use pid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.15 1998/04/27 02:02:57 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.15 1998/04/27 02:02:57 mickey Exp $";
d259 1
a259 1
static struct pmaplist *
d268 1
a268 1
			(pml->pml_map.pm_prot != prot))
d272 1
a272 1
		    break;
d321 1
d381 1
a381 1
				(pml->pml_map.pm_vers != reg.pm_vers)) {
@


1.15
log
@make error messages for binds different
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.14 1997/04/15 15:18:49 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.14 1997/04/15 15:18:49 deraadt Exp $";
d575 2
a576 1
	int pid, so = -1, dontblock = 1;
@


1.14
log
@for callit, let nop through. rpcinfo -b, ya know; adam@@math.tau.ac.il
@
text
@d1 1
a1 1
/*	$OpenBSD: portmap.c,v 1.13 1997/01/17 16:07:27 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.13 1997/01/17 16:07:27 millert Exp $";
d183 1
a183 1
		syslog(LOG_ERR, "cannot bind udp: %m");
@


1.13
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d4 1
a4 1
 * Copyright (c) 1996 Theo de Raadt (OpenBSD). All rights reserved.
d47 1
a47 1
static char rcsid[] = "$OpenBSD: portmap.c,v 1.12 1997/01/15 23:44:12 millert Exp $";
d646 1
d655 3
a657 3
	if (prog == PMAPPROG ||
	    prog == NFSPROG ||
	    prog == YPXPROG ||
@


1.12
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 2
d44 5
a48 2
/*static char sccsid[] = "from: @@(#)portmap.c	5.4 (Berkeley) 4/19/91";*/
static char rcsid[] = "$Id: portmap.c,v 1.11 1996/10/06 04:13:12 deraadt Exp $";
@


1.11
log
@fixing a portmap bug i introduced just before release makes me happy
@
text
@d43 1
a43 1
static char rcsid[] = "$Id: portmap.c,v 1.10 1996/07/31 11:09:15 deraadt Exp $";
d124 1
a124 1
	while ((c = getopt(argc, argv, "d")) != EOF) {
@


1.10
log
@inet_ntoa called wrong
@
text
@d43 1
a43 1
static char rcsid[] = "$Id: portmap.c,v 1.9 1996/07/29 11:31:08 deraadt Exp $";
d630 1
a630 1
	while (wait3(NULL, WNOHANG, NULL) != -1)
@


1.9
log
@check callit() stuff like portmap5 does (ugh)
@
text
@d43 1
a43 1
static char rcsid[] = "$Id: portmap.c,v 1.8 1996/07/29 09:29:14 deraadt Exp $";
d99 1
d102 3
a104 2
void reap	__P(());
static void callit __P((struct svc_req *, SVCXPRT *));
d112 1
d237 1
a237 1
	(void)signal(SIGCHLD, reap);
d561 1
a561 1
static void
d656 1
a656 1
		    prog, aproc, inet_ntoa(*addr));
@


1.8
log
@fix a few typos in error messages; from freebsd
@
text
@d43 1
a43 1
static char rcsid[] = "$Id: portmap.c,v 1.7 1996/07/25 22:03:05 deraadt Exp $";
d578 3
d630 27
@


1.7
log
@search proper list, duh
@
text
@d43 1
a43 1
static char rcsid[] = "$Id: portmap.c,v 1.6 1996/07/18 11:40:59 deraadt Exp $";
d199 1
a199 1
		syslog(LOG_ERR, "cannot bind udp: %m");
d214 1
a214 1
		syslog(LOG_ERR, "cannot bind udp: %m");
d236 1
a236 1
	syslog(LOG_ERR, "run_svc returned unexpectedly");
@


1.6
log
@more readable
@
text
@d43 1
a43 1
static char rcsid[] = "$Id: portmap.c,v 1.5 1996/07/07 20:15:10 deraadt Exp $";
d326 2
a327 2
		if ((pml->pml_map.pm_port < IPPORT_RESERVED ||
		    pml->pml_map.pm_port == NFS_PORT) &&
@


1.5
log
@call inet_ntoa correctly, from wietse
@
text
@d43 1
a43 1
static char rcsid[] = "$Id: portmap.c,v 1.4 1996/07/01 00:35:05 deraadt Exp $";
d309 1
a309 1
		if (!svc_getargs(xprt, xdr_pmap, (caddr_t)&reg))
d311 13
a323 12
		else {
			/*
			 * check to see if already used
			 * find_service returns a hit even if
			 * the versions don't match, so check for it
			 */
			fnd = find_service(reg.pm_prog, reg.pm_vers, reg.pm_prot);
			if (fnd && fnd->pml_map.pm_vers == reg.pm_vers) {
				if (fnd->pml_map.pm_port == reg.pm_port)
					ans = 1;
				goto done;
			}
d325 7
a331 8
			/* check if secure */
			if ((pml->pml_map.pm_port < IPPORT_RESERVED ||
			    pml->pml_map.pm_port == NFS_PORT) &&
			    htons(fromsin->sin_port) >= IPPORT_RESERVED) {
				syslog(LOG_WARNING,
				    "resvport set attempt by non-root");
				goto done;
			}
d333 19
a351 21
			/* 
			 * add to END of list
			 */
			pml = (struct pmaplist *)
			    malloc((u_int)sizeof(struct pmaplist));
			pml->pml_map = reg;
			pml->pml_next = 0;
			if (pmaplist == 0) {
				pmaplist = pml;
			} else {
				for (fnd = pmaplist; fnd->pml_next != 0;
				    fnd = fnd->pml_next);
				fnd->pml_next = pml;
			}
			ans = 1;
		done:
			if ((!svc_sendreply(xprt, xdr_long, (caddr_t)&ans)) &&
			    debugging) {
				(void) fprintf(stderr, "svc_sendreply\n");
				abort();
			}
d398 1
a398 1
			(void) fprintf(stderr, "svc_sendreply\n");
d407 1
a407 1
		if (!svc_getargs(xprt, xdr_pmap, (caddr_t)&reg))
d409 11
a419 11
		else {
			fnd = find_service(reg.pm_prog, reg.pm_vers, reg.pm_prot);
			if (fnd)
				port = fnd->pml_map.pm_port;
			else
				port = 0;
			if ((!svc_sendreply(xprt, xdr_long, (caddr_t)&port)) &&
			    debugging) {
				(void) fprintf(stderr, "svc_sendreply\n");
				abort();
			}
d427 1
a427 1
		if (!svc_getargs(xprt, xdr_void, NULL))
d429 5
a433 3
		else if ((!svc_sendreply(xprt, xdr_pmaplist,
		    (caddr_t)&pmaplist)) && debugging) {
			(void) fprintf(stderr, "svc_sendreply\n");
@


1.4
log
@whoops
@
text
@d43 1
a43 1
static char rcsid[] = "$Id: portmap.c,v 1.3 1996/06/29 19:03:50 deraadt Exp $";
d305 1
a305 1
			    inet_ntoa(fromsin));
d364 1
a364 1
			    inet_ntoa(fromsin));
@


1.3
log
@multiple receivers, port checking. testing help from bitblt
@
text
@d43 1
a43 1
static char rcsid[] = "$Id: portmap.c,v 1.2 1996/05/05 16:15:28 deraadt Exp $";
d158 1
a158 1
	setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof on);
d197 1
a197 1
	setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof on);
@


1.2
log
@from netbsd:
second argument to xdr_long must be a "long *", which means that the
'out' arg to svc_sendreply must point to a long if outproc is
xdr_long.  It was pointing to an 'int', and that was crashing on the
alpha, due to bad alignment.
@
text
@d2 1
d43 1
a43 1
static char rcsid[] = "$Id: portmap.c,v 1.1.1.1 1995/10/18 08:47:57 deraadt Exp $";
d98 1
d108 2
d115 3
a117 2
	int sock, c;
	struct sockaddr_in addr;
d142 12
d158 1
a158 5

	bzero((char *)&addr, sizeof addr);
	addr.sin_addr.s_addr = 0;
	addr.sin_family = AF_INET;
	addr.sin_port = htons(PMAPPORT);
d168 16
d197 1
d207 16
d279 2
a280 1
	long ans, port;
d283 2
d302 7
d319 1
a319 1
				if (fnd->pml_map.pm_port == reg.pm_port) {
d321 21
a341 6
					goto done;
				}
				else {
					ans = 0;
					goto done;
				}
d343 3
a345 15
				/* 
				 * add to END of list
				 */
				pml = (struct pmaplist *)
				    malloc((u_int)sizeof(struct pmaplist));
				pml->pml_map = reg;
				pml->pml_next = 0;
				if (pmaplist == 0) {
					pmaplist = pml;
				} else {
					for (fnd= pmaplist; fnd->pml_next != 0;
					    fnd = fnd->pml_next);
					fnd->pml_next = pml;
				}
				ans = 1;
d347 1
d361 8
a368 1
		if (!svc_getargs(xprt, xdr_pmap, (caddr_t)&reg))
d370 7
a376 13
		else {
			ans = 0;
			for (prevpml = NULL, pml = pmaplist; pml != NULL; ) {
				if ((pml->pml_map.pm_prog != reg.pm_prog) ||
					(pml->pml_map.pm_vers != reg.pm_vers)) {
					/* both pml & prevpml move forwards */
					prevpml = pml;
					pml = pml->pml_next;
					continue;
				}
				/* found it; pml moves forward, prevpml stays */
				ans = 1;
				t = (caddr_t)pml;
d378 1
a378 5
				if (prevpml == NULL)
					pmaplist = pml;
				else
					prevpml->pml_next = pml;
				free(t);
d380 6
a385 4
			if ((!svc_sendreply(xprt, xdr_long, (caddr_t)&ans)) &&
			    debugging) {
				(void) fprintf(stderr, "svc_sendreply\n");
				abort();
d387 15
d431 4
a434 6
		else {
			if ((!svc_sendreply(xprt, xdr_pmaplist,
			    (caddr_t)&pmaplist)) && debugging) {
				(void) fprintf(stderr, "svc_sendreply\n");
				abort();
			}
d581 1
d605 1
a605 1
		if (rqstp->rq_cred.oa_flavor == AUTH_UNIX) {
a607 1
		}
d610 1
a610 1
		    xdr_len_opaque_parms, &a, timeout) == RPC_SUCCESS) {
a611 1
		}
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: portmap.c,v 1.6 1994/12/23 16:44:22 cgd Exp $";
d233 1
a233 1
	int ans, port;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
