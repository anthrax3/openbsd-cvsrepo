head	1.82;
access;
symbols
	OPENBSD_6_1:1.82.0.2
	OPENBSD_6_1_BASE:1.82
	OPENBSD_6_0:1.81.0.6
	OPENBSD_6_0_BASE:1.81
	OPENBSD_5_9:1.81.0.2
	OPENBSD_5_9_BASE:1.81
	OPENBSD_5_8:1.77.0.8
	OPENBSD_5_8_BASE:1.77
	OPENBSD_5_7:1.77.0.2
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.77.0.4
	OPENBSD_5_6_BASE:1.77
	OPENBSD_5_5:1.76.0.4
	OPENBSD_5_5_BASE:1.76
	OPENBSD_5_4:1.75.0.2
	OPENBSD_5_4_BASE:1.75
	OPENBSD_5_3:1.73.0.2
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.72.0.4
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.2
	OPENBSD_5_0:1.70.0.4
	OPENBSD_5_0_BASE:1.70
	OPENBSD_4_9:1.70.0.2
	OPENBSD_4_9_BASE:1.70
	OPENBSD_4_8:1.69.0.2
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.66.0.2
	OPENBSD_4_7_BASE:1.66
	OPENBSD_4_6:1.63.0.4
	OPENBSD_4_6_BASE:1.63
	OPENBSD_4_5:1.54.0.2
	OPENBSD_4_5_BASE:1.54
	OPENBSD_4_4:1.53.0.6
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.53.0.4
	OPENBSD_4_3_BASE:1.53
	OPENBSD_4_2:1.53.0.2
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.52.0.2
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.50.0.4
	OPENBSD_4_0_BASE:1.50
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.47.0.4
	OPENBSD_3_8_BASE:1.47
	OPENBSD_3_7:1.47.0.2
	OPENBSD_3_7_BASE:1.47
	OPENBSD_3_6:1.44.0.2
	OPENBSD_3_6_BASE:1.44
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28;
locks; strict;
comment	@ * @;


1.82
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.81;
commitid	airB1W2Kb948lFil;

1.81
date	2015.12.30.12.06.56;	author benno;	state Exp;
branches;
next	1.80;
commitid	y0H0otBnZV24qZ1r;

1.80
date	2015.12.05.18.28.04;	author benno;	state Exp;
branches;
next	1.79;
commitid	yK6UHgEp0AEIXbTZ;

1.79
date	2015.10.27.18.19.33;	author mmcc;	state Exp;
branches;
next	1.78;
commitid	QJqNaKJginL2qSWP;

1.78
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	z3HrihslRYb4HqW9;

1.77
date	2014.04.19.15.43.17;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2013.11.13.20.41.01;	author benno;	state Exp;
branches;
next	1.75;

1.75
date	2013.05.30.20.29.27;	author florian;	state Exp;
branches;
next	1.74;

1.74
date	2013.05.20.11.25.02;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2012.11.15.18.06.36;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2011.11.06.10.29.05;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2011.09.17.16.29.44;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.69;

1.69
date	2010.06.04.10.13.00;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2010.04.22.08.21.18;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2009.10.26.09.27.58;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2009.07.12.15.36.41;	author jsg;	state Exp;
branches;
next	1.63;

1.63
date	2009.06.29.12.22.16;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2009.06.05.17.36.49;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2009.06.04.22.08.19;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2009.05.17.12.25.15;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2009.04.29.20.04.30;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2009.03.19.07.00.06;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.18.19.45.09;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.13.06.25.04;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2009.03.13.05.43.50;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2009.02.19.21.34.40;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.12.19.15.14;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.12.13.12.30;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2006.02.08.14.49.58;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.05.16.00.07;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.29.21.11.07;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.23.16.09.26;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2004.11.11.13.06.44;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2004.09.16.17.36.29;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2004.08.13.14.03.20;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.11.16.48.45;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.11.09.37.11;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.10.13.50.10;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.10.13.46.28;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.06.12.04.08;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.05.16.26.56;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.03.14.00.15;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.28.16.00.02;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.07.21.18.06;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.07.21.15.18;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.03.17.19.59;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.22.20.28.58;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.29.19.56.04;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.28.01.13.36;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.27.20.53.56;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.25.19.48.18;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.19.13.54.58;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.02.21.29.50;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.27.16.49.53;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.22.20.34.56;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.11.21.47.20;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.11.01.00.07;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.10.16.20.29;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.07.12.34.23;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.06.21.48.07;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.06.10.51.14;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.06.10.42.50;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.05.22.57.58;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.01.21.18.13;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.26.18.07.32;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.26.00.34.01;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.25.17.35.53;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.24.13.28.02;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.23.19.14.49;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.21.23.26.37;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.21.16.11.33;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.20.21.43.45;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.20.21.14.55;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.20.20.53.30;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.19.01.15.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;


desc
@@


1.82
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@/*	$OpenBSD: mrt.c,v 1.81 2015/12/30 12:06:56 benno Exp $ */

/*
 * Copyright (c) 2003, 2004 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "bgpd.h"
#include "rde.h"
#include "session.h"

#include "mrt.h"
#include "log.h"

int mrt_attr_dump(struct ibuf *, struct rde_aspath *, struct bgpd_addr *, int);
int mrt_dump_entry_mp(struct mrt *, struct prefix *, u_int16_t,
    struct rde_peer*);
int mrt_dump_entry(struct mrt *, struct prefix *, u_int16_t, struct rde_peer*);
int mrt_dump_entry_v2(struct mrt *, struct rib_entry *, u_int32_t);
int mrt_dump_peer(struct ibuf *, struct rde_peer *);
int mrt_dump_hdr_se(struct ibuf **, struct peer *, u_int16_t, u_int16_t,
    u_int32_t, int);
int mrt_dump_hdr_rde(struct ibuf **, u_int16_t type, u_int16_t, u_int32_t);
int mrt_open(struct mrt *, time_t);

#define DUMP_BYTE(x, b)							\
	do {								\
		u_char		t = (b);				\
		if (ibuf_add((x), &t, sizeof(t)) == -1) {		\
			log_warn("mrt_dump1: ibuf_add error");		\
			goto fail;					\
		}							\
	} while (0)

#define DUMP_SHORT(x, s)						\
	do {								\
		u_int16_t	t;					\
		t = htons((s));						\
		if (ibuf_add((x), &t, sizeof(t)) == -1) {		\
			log_warn("mrt_dump2: ibuf_add error");		\
			goto fail;					\
		}							\
	} while (0)

#define DUMP_LONG(x, l)							\
	do {								\
		u_int32_t	t;					\
		t = htonl((l));						\
		if (ibuf_add((x), &t, sizeof(t)) == -1) {		\
			log_warn("mrt_dump3: ibuf_add error");		\
			goto fail;					\
		}							\
	} while (0)

#define DUMP_NLONG(x, l)						\
	do {								\
		u_int32_t	t = (l);				\
		if (ibuf_add((x), &t, sizeof(t)) == -1) {		\
			log_warn("mrt_dump4: ibuf_add error");		\
			goto fail;					\
		}							\
	} while (0)

#define RDEIDX		0
#define SEIDX		1
#define TYPE2IDX(x)	((x == MRT_TABLE_DUMP ||			\
			    x == MRT_TABLE_DUMP_MP ||			\
			    x == MRT_TABLE_DUMP_V2) ? RDEIDX : SEIDX	\
			)

void
mrt_dump_bgp_msg(struct mrt *mrt, void *pkg, u_int16_t pkglen,
    struct peer *peer)
{
	struct ibuf	*buf;
	int		 incoming = 0;
	u_int16_t	 subtype = BGP4MP_MESSAGE;

	if (peer->capa.neg.as4byte)
		subtype = BGP4MP_MESSAGE_AS4;

	/* get the direction of the message to swap address and AS fields */
	if (mrt->type == MRT_ALL_IN || mrt->type == MRT_UPDATE_IN)
		incoming = 1;

	if (mrt_dump_hdr_se(&buf, peer, MSG_PROTOCOL_BGP4MP, subtype,
	    pkglen, incoming) == -1)
		return;

	if (ibuf_add(buf, pkg, pkglen) == -1) {
		log_warn("mrt_dump_bgp_msg: ibuf_add error");
		ibuf_free(buf);
		return;
	}

	ibuf_close(&mrt->wbuf, buf);
}

void
mrt_dump_state(struct mrt *mrt, u_int16_t old_state, u_int16_t new_state,
    struct peer *peer)
{
	struct ibuf	*buf;
	u_int16_t	 subtype = BGP4MP_STATE_CHANGE;

	if (peer->capa.neg.as4byte)
		subtype = BGP4MP_STATE_CHANGE_AS4;

	if (mrt_dump_hdr_se(&buf, peer, MSG_PROTOCOL_BGP4MP, subtype,
	    2 * sizeof(short), 0) == -1)
		return;

	DUMP_SHORT(buf, old_state);
	DUMP_SHORT(buf, new_state);

	ibuf_close(&mrt->wbuf, buf);
	return;

fail:
	ibuf_free(buf);
}

int
mrt_attr_dump(struct ibuf *buf, struct rde_aspath *a, struct bgpd_addr *nexthop,
    int v2)
{
	struct attr	*oa;
	u_char		*pdata;
	u_int32_t	 tmp;
	int		 neednewpath = 0;
	u_int16_t	 plen, afi;
	u_int8_t	 l, safi;

	/* origin */
	if (attr_writebuf(buf, ATTR_WELL_KNOWN, ATTR_ORIGIN,
	    &a->origin, 1) == -1)
		return (-1);

	/* aspath */
	pdata = aspath_prepend(a->aspath, rde_local_as(), 0, &plen);
	if (!v2)
		pdata = aspath_deflate(pdata, &plen, &neednewpath);
	if (attr_writebuf(buf, ATTR_WELL_KNOWN, ATTR_ASPATH, pdata,
	    plen) == -1) {
		free(pdata);
		return (-1);
	}
	free(pdata);

	if (nexthop && nexthop->aid == AID_INET) {
		/* nexthop, already network byte order */
		if (attr_writebuf(buf, ATTR_WELL_KNOWN, ATTR_NEXTHOP,
		    &nexthop->v4.s_addr, 4) ==	-1)
			return (-1);
	}

	/* MED, non transitive */
	if (a->med != 0) {
		tmp = htonl(a->med);
		if (attr_writebuf(buf, ATTR_OPTIONAL, ATTR_MED, &tmp, 4) == -1)
			return (-1);
	}

	/* local preference */
	tmp = htonl(a->lpref);
	if (attr_writebuf(buf, ATTR_WELL_KNOWN, ATTR_LOCALPREF, &tmp, 4) == -1)
		return (-1);

	/* dump all other path attributes without modification */
	for (l = 0; l < a->others_len; l++) {
		if ((oa = a->others[l]) == NULL)
			break;
		if (attr_writebuf(buf, oa->flags, oa->type,
		    oa->data, oa->len) == -1)
			return (-1);
	}

	if (nexthop && nexthop->aid != AID_INET) {
		struct ibuf *nhbuf;

		if ((nhbuf = ibuf_dynamic(0, UCHAR_MAX)) == NULL)
			return (-1);
		if (!v2) {
			if (aid2afi(nexthop->aid, &afi, &safi))
				return (-1);
			DUMP_SHORT(nhbuf, afi);
			DUMP_BYTE(nhbuf, safi);
		}
		switch (nexthop->aid) {
		case AID_INET6:
			DUMP_BYTE(nhbuf, sizeof(struct in6_addr));
			if (ibuf_add(nhbuf, &nexthop->v6,
			    sizeof(struct in6_addr)) == -1) {
			}
			break;
		case AID_VPN_IPv4:
			DUMP_BYTE(nhbuf, sizeof(u_int64_t) +
			    sizeof(struct in_addr));
			DUMP_NLONG(nhbuf, 0);	/* set RD to 0 */
			DUMP_NLONG(nhbuf, 0);
			DUMP_NLONG(nhbuf, nexthop->v4.s_addr);
			break;
		}
		if (!v2)
			DUMP_BYTE(nhbuf, 0);
		if (attr_writebuf(buf, ATTR_OPTIONAL, ATTR_MP_REACH_NLRI,
		    nhbuf->buf, ibuf_size(nhbuf)) == -1) {
fail:
			ibuf_free(nhbuf);
			return (-1);
		}
		ibuf_free(nhbuf);
	}

	if (neednewpath) {
		pdata = aspath_prepend(a->aspath, rde_local_as(), 0, &plen);
		if (plen != 0)
			if (attr_writebuf(buf, ATTR_OPTIONAL|ATTR_TRANSITIVE,
			    ATTR_AS4_PATH, pdata, plen) == -1) {
				free(pdata);
				return (-1);
			}
		free(pdata);
	}

	return (0);
}

int
mrt_dump_entry_mp(struct mrt *mrt, struct prefix *p, u_int16_t snum,
    struct rde_peer *peer)
{
	struct ibuf	*buf, *hbuf = NULL, *h2buf = NULL;
	struct bgpd_addr addr, nexthop, *nh;
	u_int16_t	 len;
	u_int8_t	 aid;

	if ((buf = ibuf_dynamic(0, MAX_PKTSIZE)) == NULL) {
		log_warn("mrt_dump_entry_mp: ibuf_dynamic");
		return (-1);
	}

	if (mrt_attr_dump(buf, p->aspath, NULL, 0) == -1) {
		log_warnx("mrt_dump_entry_mp: mrt_attr_dump error");
		goto fail;
	}
	len = ibuf_size(buf);

	if ((h2buf = ibuf_dynamic(MRT_BGP4MP_IPv4_HEADER_SIZE +
	    MRT_BGP4MP_IPv4_ENTRY_SIZE, MRT_BGP4MP_IPv6_HEADER_SIZE +
	    MRT_BGP4MP_IPv6_ENTRY_SIZE + MRT_BGP4MP_MAX_PREFIXLEN)) == NULL) {
		log_warn("mrt_dump_entry_mp: ibuf_dynamic");
		goto fail;
	}

	DUMP_SHORT(h2buf, rde_local_as());
	DUMP_SHORT(h2buf, peer->short_as);
	DUMP_SHORT(h2buf, /* ifindex */ 0);

	/* XXX is this for peer self? */
	aid = peer->remote_addr.aid == AID_UNSPEC ? p->prefix->aid :
	     peer->remote_addr.aid;
	switch (aid) {
	case AID_INET:
		DUMP_SHORT(h2buf, AFI_IPv4);
		DUMP_NLONG(h2buf, peer->local_v4_addr.v4.s_addr);
		DUMP_NLONG(h2buf, peer->remote_addr.v4.s_addr);
		break;
	case AID_INET6:
		DUMP_SHORT(h2buf, AFI_IPv6);
		if (ibuf_add(h2buf, &peer->local_v6_addr.v6,
		    sizeof(struct in6_addr)) == -1 ||
		    ibuf_add(h2buf, &peer->remote_addr.v6,
		    sizeof(struct in6_addr)) == -1) {
			log_warn("mrt_dump_entry_mp: ibuf_add error");
			goto fail;
		}
		break;
	default:
		log_warnx("king bula found new AF in mrt_dump_entry_mp");
		goto fail;
	}

	DUMP_SHORT(h2buf, 0);		/* view */
	DUMP_SHORT(h2buf, 1);		/* status */
	DUMP_LONG(h2buf, p->lastchange);	/* originated */

	pt_getaddr(p->prefix, &addr);

	if (p->aspath->nexthop == NULL) {
		bzero(&nexthop, sizeof(struct bgpd_addr));
		nexthop.aid = addr.aid;
		nh = &nexthop;
	} else
		nh = &p->aspath->nexthop->exit_nexthop;

	switch (addr.aid) {
	case AID_INET:
		DUMP_SHORT(h2buf, AFI_IPv4);	/* afi */
		DUMP_BYTE(h2buf, SAFI_UNICAST);	/* safi */
		DUMP_BYTE(h2buf, 4);		/* nhlen */
		DUMP_NLONG(h2buf, nh->v4.s_addr);	/* nexthop */
		break;
	case AID_INET6:
		DUMP_SHORT(h2buf, AFI_IPv6);	/* afi */
		DUMP_BYTE(h2buf, SAFI_UNICAST);	/* safi */
		DUMP_BYTE(h2buf, 16);		/* nhlen */
		if (ibuf_add(h2buf, &nh->v6, sizeof(struct in6_addr)) == -1) {
			log_warn("mrt_dump_entry_mp: ibuf_add error");
			goto fail;
		}
		break;
	default:
		log_warnx("king bula found new AF in mrt_dump_entry_mp");
		goto fail;
	}

	if (prefix_writebuf(h2buf, &addr, p->prefix->prefixlen) == -1) {
		log_warn("mrt_dump_entry_mp: prefix_writebuf error");
		goto fail;
	}

	DUMP_SHORT(h2buf, len);
	len += ibuf_size(h2buf);

	if (mrt_dump_hdr_rde(&hbuf, MSG_PROTOCOL_BGP4MP, BGP4MP_ENTRY,
	    len) == -1)
		goto fail;

	ibuf_close(&mrt->wbuf, hbuf);
	ibuf_close(&mrt->wbuf, h2buf);
	ibuf_close(&mrt->wbuf, buf);

	return (len + MRT_HEADER_SIZE);

fail:
	ibuf_free(hbuf);
	ibuf_free(h2buf);
	ibuf_free(buf);
	return (-1);
}

int
mrt_dump_entry(struct mrt *mrt, struct prefix *p, u_int16_t snum,
    struct rde_peer *peer)
{
	struct ibuf	*buf, *hbuf;
	struct bgpd_addr addr, *nh;
	size_t		 len;
	u_int16_t	 subtype;
	u_int8_t	 dummy;

	if (p->prefix->aid != peer->remote_addr.aid &&
	    p->prefix->aid != AID_INET && p->prefix->aid != AID_INET6)
		/* only able to dump pure IPv4/IPv6 */
		return (0);

	if ((buf = ibuf_dynamic(0, MAX_PKTSIZE)) == NULL) {
		log_warn("mrt_dump_entry: ibuf_dynamic");
		return (-1);
	}

	if (p->aspath->nexthop == NULL) {
		bzero(&addr, sizeof(struct bgpd_addr));
		addr.aid = p->prefix->aid;
		nh = &addr;
	} else
		nh = &p->aspath->nexthop->exit_nexthop;
	if (mrt_attr_dump(buf, p->aspath, nh, 0) == -1) {
		log_warnx("mrt_dump_entry: mrt_attr_dump error");
		ibuf_free(buf);
		return (-1);
	}
	len = ibuf_size(buf);
	aid2afi(p->prefix->aid, &subtype, &dummy);
	if (mrt_dump_hdr_rde(&hbuf, MSG_TABLE_DUMP, subtype, len) == -1) {
		ibuf_free(buf);
		return (-1);
	}

	DUMP_SHORT(hbuf, 0);
	DUMP_SHORT(hbuf, snum);

	pt_getaddr(p->prefix, &addr);
	switch (p->prefix->aid) {
	case AID_INET:
		DUMP_NLONG(hbuf, addr.v4.s_addr);
		break;
	case AID_INET6:
		if (ibuf_add(hbuf, &addr.v6, sizeof(struct in6_addr)) == -1) {
			log_warn("mrt_dump_entry: ibuf_add error");
			goto fail;
		}
		break;
	}
	DUMP_BYTE(hbuf, p->prefix->prefixlen);

	DUMP_BYTE(hbuf, 1);		/* state */
	DUMP_LONG(hbuf, p->lastchange);	/* originated */
	switch (p->prefix->aid) {
	case AID_INET:
		DUMP_NLONG(hbuf, peer->remote_addr.v4.s_addr);
		break;
	case AID_INET6:
		if (ibuf_add(hbuf, &peer->remote_addr.v6,
		    sizeof(struct in6_addr)) == -1) {
			log_warn("mrt_dump_entry: ibuf_add error");
			goto fail;
		}
		break;
	}
	DUMP_SHORT(hbuf, peer->short_as);
	DUMP_SHORT(hbuf, len);

	ibuf_close(&mrt->wbuf, hbuf);
	ibuf_close(&mrt->wbuf, buf);

	return (len + MRT_HEADER_SIZE);

fail:
	ibuf_free(hbuf);
	ibuf_free(buf);
	return (-1);
}

int
mrt_dump_entry_v2(struct mrt *mrt, struct rib_entry *re, u_int32_t snum)
{
	struct ibuf	*buf, *hbuf = NULL;
	struct prefix	*p;
	struct bgpd_addr addr;
	size_t		 len, off;
	u_int16_t	 subtype, nump;

	switch (re->prefix->aid) {
	case AID_INET:
		subtype = MRT_DUMP_V2_RIB_IPV4_UNICAST;
		break;
	case AID_INET6:
		subtype = MRT_DUMP_V2_RIB_IPV6_UNICAST;
		break;
	default:
		subtype = MRT_DUMP_V2_RIB_GENERIC;
		break;
	}

	if ((buf = ibuf_dynamic(0, UINT_MAX)) == NULL) {
		log_warn("%s: ibuf_dynamic", __func__);
		return (-1);
	}

	DUMP_LONG(buf, snum);
	pt_getaddr(re->prefix, &addr);
	if (subtype == MRT_DUMP_V2_RIB_GENERIC) {
		u_int16_t afi;
		u_int8_t safi;

		aid2afi(re->prefix->aid, &afi, &safi);
		DUMP_SHORT(buf, afi);
		DUMP_BYTE(buf, safi);
	}
	if (prefix_writebuf(buf, &addr, re->prefix->prefixlen) == -1) {
		log_warn("%s: prefix_writebuf error", __func__);
		goto fail;
	}

	off = ibuf_size(buf);
	if (ibuf_reserve(buf, sizeof(nump)) == NULL) {
		log_warn("%s: ibuf_reserve error", __func__);
		goto fail;
	}
	nump = 0;
	LIST_FOREACH(p, &re->prefix_h, rib_l) {
		struct bgpd_addr	*nh;
		struct ibuf		*tbuf;

		if (p->aspath->nexthop == NULL) {
			bzero(&addr, sizeof(struct bgpd_addr));
			addr.aid = p->prefix->aid;
			nh = &addr;
		} else
			nh = &p->aspath->nexthop->exit_nexthop;

		DUMP_SHORT(buf, p->aspath->peer->mrt_idx);
		DUMP_LONG(buf, p->lastchange); /* originated */

		if ((tbuf = ibuf_dynamic(0, MAX_PKTSIZE)) == NULL) {
			log_warn("%s: ibuf_dynamic", __func__);
			return (-1);
		}
		if (mrt_attr_dump(tbuf, p->aspath, nh, 1) == -1) {
			log_warnx("%s: mrt_attr_dump error", __func__);
			ibuf_free(buf);
			return (-1);
		}
		len = ibuf_size(tbuf);
		DUMP_SHORT(buf, (u_int16_t)len);
		if (ibuf_add(buf, tbuf->buf, ibuf_size(tbuf)) == -1) {
			log_warn("%s: ibuf_add error", __func__);
			ibuf_free(tbuf);
			return (-1);
		}
		ibuf_free(tbuf);
		nump++;
	}
	nump = htons(nump);
	memcpy(ibuf_seek(buf, off, sizeof(nump)), &nump, sizeof(nump));

	len = ibuf_size(buf);
	if (mrt_dump_hdr_rde(&hbuf, MSG_TABLE_DUMP_V2, subtype, len) == -1) {
		ibuf_free(buf);
		return (-1);
	}

	ibuf_close(&mrt->wbuf, hbuf);
	ibuf_close(&mrt->wbuf, buf);

	return (0);
fail:
	ibuf_free(hbuf);
	ibuf_free(buf);
	return (-1);
}

int
mrt_dump_v2_hdr(struct mrt *mrt, struct bgpd_config *conf,
    struct rde_peer_head *ph)
{
	struct rde_peer	*peer;
	struct ibuf	*buf, *hbuf = NULL;
	size_t		 len, off;
	u_int16_t	 nlen, nump;

	if ((buf = ibuf_dynamic(0, UINT_MAX)) == NULL) {
		log_warn("%s: ibuf_dynamic", __func__);
		return (-1);
	}

	DUMP_NLONG(buf, conf->bgpid);
	nlen = strlen(mrt->rib);
	if (nlen > 0)
		nlen += 1;
	DUMP_SHORT(buf, nlen);
	if (ibuf_add(buf, mrt->rib, nlen) == -1) {
		log_warn("%s: ibuf_add error", __func__);
		goto fail;
	}

	off = ibuf_size(buf);
	if (ibuf_reserve(buf, sizeof(nump)) == NULL) {
		log_warn("%s: ibuf_reserve error", __func__);
		goto fail;
	}
	nump = 0;
	LIST_FOREACH(peer, ph, peer_l) {
		peer->mrt_idx = nump;
		if (mrt_dump_peer(buf, peer) == -1)
			goto fail;
		nump++;
	}
	nump = htons(nump);
	memcpy(ibuf_seek(buf, off, sizeof(nump)), &nump, sizeof(nump));

	len = ibuf_size(buf);
	if (mrt_dump_hdr_rde(&hbuf, MSG_TABLE_DUMP_V2,
	    MRT_DUMP_V2_PEER_INDEX_TABLE, len) == -1)
		goto fail;

	ibuf_close(&mrt->wbuf, hbuf);
	ibuf_close(&mrt->wbuf, buf);

	return (0);
fail:
	ibuf_free(hbuf);
	ibuf_free(buf);
	return (-1);
}

int
mrt_dump_peer(struct ibuf *buf, struct rde_peer *peer)
{
	u_int8_t	type = 0;

	if (peer->capa.as4byte)
		type |= MRT_DUMP_V2_PEER_BIT_A;
	if (peer->remote_addr.aid == AID_INET6)
		type |= MRT_DUMP_V2_PEER_BIT_I;

	DUMP_BYTE(buf, type);
	DUMP_LONG(buf, peer->remote_bgpid);

	switch (peer->remote_addr.aid) {
	case AID_INET:
		DUMP_NLONG(buf, peer->remote_addr.v4.s_addr);
		break;
	case AID_INET6:
		if (ibuf_add(buf, &peer->remote_addr.v6,
		    sizeof(struct in6_addr)) == -1) {
			log_warn("mrt_dump_peer: ibuf_add error");
			goto fail;
		}
		break;
	case AID_UNSPEC: /* XXX special handling for peer_self? */
		DUMP_NLONG(buf, 0);
		break;
	default:
		log_warnx("king bula found new AF in mrt_dump_entry_mp");
		goto fail;
	}

	if (peer->capa.as4byte)
		DUMP_LONG(buf, peer->conf.remote_as);
	else
		DUMP_SHORT(buf, peer->short_as);

	return (0);
fail:
	return (-1);
}

void
mrt_dump_upcall(struct rib_entry *re, void *ptr)
{
	struct mrt		*mrtbuf = ptr;
	struct prefix		*p;

	if (mrtbuf->type == MRT_TABLE_DUMP_V2) {
		mrt_dump_entry_v2(mrtbuf, re, mrtbuf->seqnum++);
		return;
	}

	/*
	 * dump all prefixes even the inactive ones. That is the way zebra
	 * dumps the table so we do the same. If only the active route should
	 * be dumped p should be set to p = pt->active.
	 */
	LIST_FOREACH(p, &re->prefix_h, rib_l) {
		if (mrtbuf->type == MRT_TABLE_DUMP)
			mrt_dump_entry(mrtbuf, p, mrtbuf->seqnum++,
			    p->aspath->peer);
		else
			mrt_dump_entry_mp(mrtbuf, p, mrtbuf->seqnum++,
			    p->aspath->peer);
	}
}

void
mrt_done(void *ptr)
{
	struct mrt		*mrtbuf = ptr;

	mrtbuf->state = MRT_STATE_REMOVE;
}

int
mrt_dump_hdr_se(struct ibuf ** bp, struct peer *peer, u_int16_t type,
    u_int16_t subtype, u_int32_t len, int swap)
{
	time_t		now;

	if ((*bp = ibuf_dynamic(MRT_HEADER_SIZE, MRT_HEADER_SIZE +
	    MRT_BGP4MP_AS4_IPv6_HEADER_SIZE + len)) == NULL) {
		log_warn("mrt_dump_hdr_se: ibuf_dynamic error");
		return (-1);
	}

	now = time(NULL);

	DUMP_LONG(*bp, now);
	DUMP_SHORT(*bp, type);
	DUMP_SHORT(*bp, subtype);

	switch (peer->sa_local.ss_family) {
	case AF_INET:
		if (subtype == BGP4MP_STATE_CHANGE_AS4 ||
		    subtype == BGP4MP_MESSAGE_AS4)
			len += MRT_BGP4MP_AS4_IPv4_HEADER_SIZE;
		else
			len += MRT_BGP4MP_IPv4_HEADER_SIZE;
		break;
	case AF_INET6:
		if (subtype == BGP4MP_STATE_CHANGE_AS4 ||
		    subtype == BGP4MP_MESSAGE_AS4)
			len += MRT_BGP4MP_AS4_IPv6_HEADER_SIZE;
		else
			len += MRT_BGP4MP_IPv6_HEADER_SIZE;
		break;
	case 0:
		goto fail;
	default:
		log_warnx("king bula found new AF in mrt_dump_hdr_se");
		goto fail;
	}

	DUMP_LONG(*bp, len);

	if (subtype == BGP4MP_STATE_CHANGE_AS4 ||
	    subtype == BGP4MP_MESSAGE_AS4) {
		if (!swap)
			DUMP_LONG(*bp, peer->conf.local_as);
		DUMP_LONG(*bp, peer->conf.remote_as);
		if (swap)
			DUMP_LONG(*bp, peer->conf.local_as);
	} else {
		if (!swap)
			DUMP_SHORT(*bp, peer->conf.local_short_as);
		DUMP_SHORT(*bp, peer->short_as);
		if (swap)
			DUMP_SHORT(*bp, peer->conf.local_short_as);
	}

	DUMP_SHORT(*bp, /* ifindex */ 0);

	switch (peer->sa_local.ss_family) {
	case AF_INET:
		DUMP_SHORT(*bp, AFI_IPv4);
		if (!swap)
			DUMP_NLONG(*bp, ((struct sockaddr_in *)
			    &peer->sa_local)->sin_addr.s_addr);
		DUMP_NLONG(*bp,
		    ((struct sockaddr_in *)&peer->sa_remote)->sin_addr.s_addr);
		if (swap)
			DUMP_NLONG(*bp, ((struct sockaddr_in *)
			    &peer->sa_local)->sin_addr.s_addr);
		break;
	case AF_INET6:
		DUMP_SHORT(*bp, AFI_IPv6);
		if (!swap)
			if (ibuf_add(*bp, &((struct sockaddr_in6 *)
			    &peer->sa_local)->sin6_addr,
			    sizeof(struct in6_addr)) == -1) {
				log_warn("mrt_dump_hdr_se: ibuf_add error");
				goto fail;
			}
		if (ibuf_add(*bp,
		    &((struct sockaddr_in6 *)&peer->sa_remote)->sin6_addr,
		    sizeof(struct in6_addr)) == -1) {
			log_warn("mrt_dump_hdr_se: ibuf_add error");
			goto fail;
		}
		if (swap)
			if (ibuf_add(*bp, &((struct sockaddr_in6 *)
			    &peer->sa_local)->sin6_addr,
			    sizeof(struct in6_addr)) == -1) {
				log_warn("mrt_dump_hdr_se: ibuf_add error");
				goto fail;
			}
		break;
	}

	return (0);

fail:
	ibuf_free(*bp);
	return (-1);
}

int
mrt_dump_hdr_rde(struct ibuf **bp, u_int16_t type, u_int16_t subtype,
    u_int32_t len)
{
	time_t		 now;

	if ((*bp = ibuf_dynamic(MRT_HEADER_SIZE, MRT_HEADER_SIZE +
	    MRT_BGP4MP_AS4_IPv6_HEADER_SIZE + MRT_BGP4MP_IPv6_ENTRY_SIZE)) ==
	    NULL) {
		log_warn("mrt_dump_hdr_rde: ibuf_dynamic error");
		return (-1);
	}

	now = time(NULL);
	DUMP_LONG(*bp, now);
	DUMP_SHORT(*bp, type);
	DUMP_SHORT(*bp, subtype);

	switch (type) {
	case MSG_TABLE_DUMP:
		switch (subtype) {
		case AFI_IPv4:
			len += MRT_DUMP_HEADER_SIZE;
			break;
		case AFI_IPv6:
			len += MRT_DUMP_HEADER_SIZE_V6;
			break;
		}
		DUMP_LONG(*bp, len);
		break;
	case MSG_PROTOCOL_BGP4MP:
	case MSG_TABLE_DUMP_V2:
		DUMP_LONG(*bp, len);
		break;
	default:
		log_warnx("mrt_dump_hdr_rde: unsupported type");
		goto fail;
	}
	return (0);

fail:
	ibuf_free(*bp);
	return (-1);
}

void
mrt_write(struct mrt *mrt)
{
	int	r;

	if ((r = ibuf_write(&mrt->wbuf)) < 0 && errno != EAGAIN) {
		log_warn("mrt dump aborted, mrt_write");
		mrt_clean(mrt);
		mrt_done(mrt);
	}
}

void
mrt_clean(struct mrt *mrt)
{
	struct ibuf	*b;

	close(mrt->wbuf.fd);
	while ((b = TAILQ_FIRST(&mrt->wbuf.bufs))) {
		TAILQ_REMOVE(&mrt->wbuf.bufs, b, entry);
		ibuf_free(b);
	}
	mrt->wbuf.queued = 0;
}

static struct imsgbuf	*mrt_imsgbuf[2];

void
mrt_init(struct imsgbuf *rde, struct imsgbuf *se)
{
	mrt_imsgbuf[RDEIDX] = rde;
	mrt_imsgbuf[SEIDX] = se;
}

int
mrt_open(struct mrt *mrt, time_t now)
{
	enum imsg_type	type;
	int		fd;

	if (strftime(MRT2MC(mrt)->file, sizeof(MRT2MC(mrt)->file),
	    MRT2MC(mrt)->name, localtime(&now)) == 0) {
		log_warnx("mrt_open: strftime conversion failed");
		return (-1);
	}

	fd = open(MRT2MC(mrt)->file,
	    O_WRONLY|O_NONBLOCK|O_CREAT|O_TRUNC, 0644);
	if (fd == -1) {
		log_warn("mrt_open %s", MRT2MC(mrt)->file);
		return (1);
	}

	if (mrt->state == MRT_STATE_OPEN)
		type = IMSG_MRT_OPEN;
	else
		type = IMSG_MRT_REOPEN;

	if (imsg_compose(mrt_imsgbuf[TYPE2IDX(mrt->type)], type, 0, 0, fd,
	    mrt, sizeof(struct mrt)) == -1)
		log_warn("mrt_open");

	return (1);
}

int
mrt_timeout(struct mrt_head *mrt)
{
	struct mrt	*m;
	time_t		 now;
	int		 timeout = MRT_MAX_TIMEOUT;

	now = time(NULL);
	LIST_FOREACH(m, mrt, entry) {
		if (m->state == MRT_STATE_RUNNING &&
		    MRT2MC(m)->ReopenTimerInterval != 0) {
			if (MRT2MC(m)->ReopenTimer <= now) {
				mrt_open(m, now);
				MRT2MC(m)->ReopenTimer =
				    now + MRT2MC(m)->ReopenTimerInterval;
			}
			if (MRT2MC(m)->ReopenTimer - now < timeout)
				timeout = MRT2MC(m)->ReopenTimer - now;
		}
	}
	return (timeout > 0 ? timeout : 0);
}

void
mrt_reconfigure(struct mrt_head *mrt)
{
	struct mrt	*m, *xm;
	time_t		 now;

	now = time(NULL);
	for (m = LIST_FIRST(mrt); m != NULL; m = xm) {
		xm = LIST_NEXT(m, entry);
		if (m->state == MRT_STATE_OPEN ||
		    m->state == MRT_STATE_REOPEN) {
			if (mrt_open(m, now) == -1)
				continue;
			if (MRT2MC(m)->ReopenTimerInterval != 0)
				MRT2MC(m)->ReopenTimer =
				    now + MRT2MC(m)->ReopenTimerInterval;
			m->state = MRT_STATE_RUNNING;
		}
		if (m->state == MRT_STATE_REMOVE) {
			if (imsg_compose(mrt_imsgbuf[TYPE2IDX(m->type)],
			    IMSG_MRT_CLOSE, 0, 0, -1, m, sizeof(struct mrt)) ==
			    -1)
				log_warn("mrt_reconfigure");
			LIST_REMOVE(m, entry);
			free(m);
			continue;
		}
	}
}

void
mrt_handler(struct mrt_head *mrt)
{
	struct mrt	*m;
	time_t		 now;

	now = time(NULL);
	LIST_FOREACH(m, mrt, entry) {
		if (m->state == MRT_STATE_RUNNING &&
		    (MRT2MC(m)->ReopenTimerInterval != 0 ||
		     m->type == MRT_TABLE_DUMP ||
		     m->type == MRT_TABLE_DUMP_MP ||
		     m->type == MRT_TABLE_DUMP_V2)) {
			if (mrt_open(m, now) == -1)
				continue;
			MRT2MC(m)->ReopenTimer =
			    now + MRT2MC(m)->ReopenTimerInterval;
		}
	}
}

struct mrt *
mrt_get(struct mrt_head *c, struct mrt *m)
{
	struct mrt	*t;

	LIST_FOREACH(t, c, entry) {
		if (t->type != m->type)
			continue;
		if (strcmp(t->rib, m->rib))
			continue;
		if (t->peer_id == m->peer_id &&
		    t->group_id == m->group_id)
			return (t);
	}
	return (NULL);
}

int
mrt_mergeconfig(struct mrt_head *xconf, struct mrt_head *nconf)
{
	struct mrt	*m, *xm;

	/* both lists here are actually struct mrt_conifg nodes */
	LIST_FOREACH(m, nconf, entry) {
		if ((xm = mrt_get(xconf, m)) == NULL) {
			/* NEW */
			if ((xm = malloc(sizeof(struct mrt_config))) == NULL)
				fatal("mrt_mergeconfig");
			memcpy(xm, m, sizeof(struct mrt_config));
			xm->state = MRT_STATE_OPEN;
			LIST_INSERT_HEAD(xconf, xm, entry);
		} else {
			/* MERGE */
			if (strlcpy(MRT2MC(xm)->name, MRT2MC(m)->name,
			    sizeof(MRT2MC(xm)->name)) >=
			    sizeof(MRT2MC(xm)->name))
				fatalx("mrt_mergeconfig: strlcpy");
			MRT2MC(xm)->ReopenTimerInterval =
			    MRT2MC(m)->ReopenTimerInterval;
			xm->state = MRT_STATE_REOPEN;
		}
	}

	LIST_FOREACH(xm, xconf, entry)
		if (mrt_get(nconf, xm) == NULL)
			/* REMOVE */
			xm->state = MRT_STATE_REMOVE;

	/* free config */
	while ((m = LIST_FIRST(nconf)) != NULL) {
		LIST_REMOVE(m, entry);
		free(m);
	}

	return (0);
}
@


1.81
log
@now that ibuf_free() checks for null, we can remove the check here.
ok mmcc@@ millert@@ tb@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.80 2015/12/05 18:28:04 benno Exp $ */
d35 1
@


1.80
log
@cleanup some log messages with wrong function names etc.
ok henning,claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.79 2015/10/27 18:19:33 mmcc Exp $ */
d358 2
a359 4
	if (hbuf)
		ibuf_free(hbuf);
	if (h2buf)
		ibuf_free(h2buf);
d541 1
a541 2
	if (hbuf)
		ibuf_free(hbuf);
d595 1
a595 2
	if (hbuf)
		ibuf_free(hbuf);
@


1.79
log
@calloc -> malloc when the memory is immediately overwritten with memcpy.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.78 2015/08/20 22:39:29 deraadt Exp $ */
d471 1
a471 1
		log_warn("mrt_dump_entry: ibuf_dynamic");
d486 1
a486 1
		log_warn("mrt_dump_entry_mp: prefix_writebuf error");
d492 1
a492 1
		log_warn("mrt_dump_v2_hdr: ibuf_reserve error");
d511 1
a511 1
			log_warn("mrt_dump_entry_v2: ibuf_dynamic");
d515 1
a515 1
			log_warnx("mrt_dump_entry_v2: mrt_attr_dump error");
d522 1
a522 1
			log_warn("mrt_dump_entry_v2: ibuf_add error");
d559 1
a559 1
		log_warn("mrt_dump_v2_hdr: ibuf_dynamic");
d569 1
a569 1
		log_warn("mrt_dump_v2_hdr: ibuf_add error");
d575 1
a575 1
		log_warn("mrt_dump_v2_hdr: ibuf_reserve error");
d684 1
a684 1
	time_t	 	now;
@


1.78
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.77 2014/04/19 15:43:17 claudio Exp $ */
d993 1
a993 1
			if ((xm = calloc(1, sizeof(struct mrt_config))) == NULL)
@


1.77
log
@Try to be clear why struct mrt_config nodes are allocated and
assigned to struct mrt pointers. I may need to rethink this later
but lets hope this does not confuse more people and analyzers.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.76 2013/11/13 20:41:01 benno Exp $ */
d993 1
a993 2
			if ((xm = (struct mrt *)calloc(1,
			    sizeof(struct mrt_config))) == NULL)
@


1.76
log
@from claudio
"Let msgbuf_write return -1 with errno EAGAIN. The users then must
check if this was the case and readd the event or poll again.  The
current handling in the imsg code is wrong for sure."

ok gilles, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.75 2013/05/30 20:29:27 florian Exp $ */
d989 1
d993 2
a994 1
			if ((xm = calloc(1, sizeof(struct mrt_config))) == NULL)
@


1.75
log
@When removing "dump (all|updates)" from bgpd.conf and reloading, tell
the session engine to actually stop logging.
Found the hard way by benno@@.

with & ok benno@@
input & ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.74 2013/05/20 11:25:02 claudio Exp $ */
d833 1
a833 1
	if ((r = ibuf_write(&mrt->wbuf)) < 0) {
@


1.74
log
@Call pt_getaddr() a bit earlier so that addr.aid is available when first
accessed. Found by magic clang skill of blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.73 2012/11/15 18:06:36 krw Exp $ */
d85 7
d858 2
a859 2
	mrt_imsgbuf[0] = rde;
	mrt_imsgbuf[1] = se;
d866 1
a866 1
	int		i = 1, fd;
d886 1
a886 5
	if (mrt->type == MRT_TABLE_DUMP || mrt->type == MRT_TABLE_DUMP_MP ||
	    mrt->type == MRT_TABLE_DUMP_V2)
		i = 0;

	if (imsg_compose(mrt_imsgbuf[i], type, 0, 0, fd,
d935 4
@


1.73
log
@buf_* -> ibuf_* in various log entries to reflect correct function names.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.72 2011/11/06 10:29:05 guenther Exp $ */
d302 2
a310 1
	pt_getaddr(p->prefix, &addr);
@


1.72
log
@Add a #include that's currently picked up via another header that's
violating namespace rules

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.71 2011/09/17 16:29:44 claudio Exp $ */
d105 1
a105 1
		log_warn("mrt_dump_bgp_msg: buf_add error");
d253 1
a253 1
		log_warn("mrt_dump_entry_mp: buf_dynamic");
d266 1
a266 1
		log_warn("mrt_dump_entry_mp: buf_dynamic");
d289 1
a289 1
			log_warn("mrt_dump_entry_mp: buf_add error");
d322 1
a322 1
			log_warn("mrt_dump_entry_mp: buf_add error");
d374 1
a374 1
		log_warn("mrt_dump_entry: buf_dynamic");
d406 1
a406 1
			log_warn("mrt_dump_entry: buf_add error");
d422 1
a422 1
			log_warn("mrt_dump_entry: buf_add error");
d463 1
a463 1
		log_warn("mrt_dump_entry: buf_dynamic");
d484 1
a484 1
		log_warn("mrt_dump_v2_hdr: buf_reserve error");
d503 1
a503 1
			log_warn("mrt_dump_entry_v2: buf_dynamic");
d551 1
a551 1
		log_warn("mrt_dump_v2_hdr: buf_dynamic");
d561 1
a561 1
		log_warn("mrt_dump_v2_hdr: buf_add error");
d567 1
a567 1
		log_warn("mrt_dump_v2_hdr: buf_reserve error");
d616 1
a616 1
			log_warn("mrt_dump_peer: buf_add error");
d680 1
a680 1
		log_warn("mrt_dump_hdr_se: buf_open error");
d749 1
a749 1
				log_warn("mrt_dump_hdr_se: buf_add error");
d755 1
a755 1
			log_warn("mrt_dump_hdr_se: buf_add error");
d762 1
a762 1
				log_warn("mrt_dump_hdr_se: buf_add error");
d784 1
a784 1
		log_warn("mrt_dump_hdr_rde: buf_dynamic error");
@


1.71
log
@Implement new mrt table dump format as specified in draft-ietf-grow-mrt.
Tested with IP and IPv6 sessions and against the libbgpdump parser.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.70 2010/09/02 14:03:21 sobrado Exp $ */
d24 1
@


1.70
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.69 2010/06/04 10:13:00 claudio Exp $ */
d35 1
a35 1
int mrt_attr_dump(struct ibuf *, struct rde_aspath *, struct bgpd_addr *);
d39 2
d50 1
a50 1
			log_warnx("mrt_dump1: ibuf_add error");		\
d60 1
a60 1
			log_warnx("mrt_dump2: ibuf_add error");		\
d70 1
a70 1
			log_warnx("mrt_dump3: ibuf_add error");		\
d79 1
a79 1
			log_warnx("mrt_dump4: ibuf_add error");		\
d104 1
a104 1
		log_warnx("mrt_dump_bgp_msg: buf_add error");
d137 2
a138 1
mrt_attr_dump(struct ibuf *buf, struct rde_aspath *a, struct bgpd_addr *nexthop)
d145 1
a145 1
	u_int8_t	 l, mpattr[21];
d154 2
a155 1
	pdata = aspath_deflate(pdata, &plen, &neednewpath);
d177 1
a177 1
	/* local preference, only valid for ibgp */
d192 3
a194 1
		if (aid2afi(nexthop->aid, &afi, &mpattr[2]))
d196 23
a218 5
		afi = htons(afi);
		memcpy(mpattr, &afi, sizeof(afi));
		mpattr[3] = sizeof(struct in6_addr);
		memcpy(&mpattr[4], &nexthop->v6, sizeof(struct in6_addr));
		mpattr[20] = 0; /* Reserved must be 0 */
d220 3
a222 1
		    mpattr, sizeof(mpattr)) == -1)
d224 2
a246 1
	void		*bptr;
a248 1
	u_int8_t	 p_len;
d256 1
a256 1
	if (mrt_attr_dump(buf, p->aspath, NULL) == -1) {
d288 1
a288 1
			log_warnx("mrt_dump_entry_mp: buf_add error");
d321 1
a321 1
			log_warnx("mrt_dump_entry_mp: buf_add error");
d330 2
a331 7
	p_len = PREFIX_SIZE(p->prefix->prefixlen);
	if ((bptr = ibuf_reserve(h2buf, p_len)) == NULL) {
		log_warnx("mrt_dump_entry_mp: buf_reserve error");
		goto fail;
	}
	if (prefix_write(bptr, p_len, &addr, p->prefix->prefixlen) == -1) {
		log_warnx("mrt_dump_entry_mp: prefix_write error");
d373 1
a373 1
		log_warnx("mrt_dump_entry: buf_dynamic");
d383 1
a383 1
	if (mrt_attr_dump(buf, p->aspath, nh) == -1) {
d405 1
a405 1
			log_warnx("mrt_dump_entry: buf_add error");
d421 1
a421 1
			log_warnx("mrt_dump_entry: buf_add error");
d440 197
d643 5
d679 1
a679 1
		log_warnx("mrt_dump_hdr_se: buf_open error");
d748 1
a748 1
				log_warnx("mrt_dump_hdr_se: buf_add error");
d754 1
a754 1
			log_warnx("mrt_dump_hdr_se: buf_add error");
d761 1
a761 1
				log_warnx("mrt_dump_hdr_se: buf_add error");
d783 1
a783 1
		log_warnx("mrt_dump_hdr_rde: buf_dynamic error");
d805 1
d877 2
a878 1
	if (mrt->type == MRT_TABLE_DUMP || mrt->type == MRT_TABLE_DUMP_MP)
d947 3
a949 1
		     m->type == MRT_TABLE_DUMP)) {
@


1.69
log
@It is actually possible to dump IPv6 tables with "dump table" and not
"dump table-mp" but this is only possible if the session and the prefixes
are from the same address family. Evil little hackery (especially the
IPv6 nexthop encoding) but seems to work according to libbgpdump.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.68 2010/05/26 13:56:07 nicm Exp $ */
d587 1
a587 1
	}	
@


1.68
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.67 2010/04/22 08:21:18 claudio Exp $ */
d141 2
a142 2
	u_int16_t	 plen;
	u_int8_t	 l;
d152 3
a154 1
	if (attr_writebuf(buf, ATTR_WELL_KNOWN, ATTR_ASPATH, pdata, plen) == -1)
d156 1
d159 1
a159 1
	if (nexthop) {
d187 13
d204 2
a205 1
			    ATTR_AS4_PATH, pdata, plen) == -1)
d207 1
d343 2
d346 3
a348 3
	if (p->prefix->aid != AID_INET &&
	    peer->remote_addr.aid == AID_INET)
		/* only able to dump IPv4 */
d358 1
a358 1
		addr.aid = AID_INET;
d368 2
a369 2

	if (mrt_dump_hdr_rde(&hbuf, MSG_TABLE_DUMP, AFI_IPv4, len) == -1) {
d378 11
a388 1
	DUMP_NLONG(hbuf, addr.v4.s_addr);
d393 12
a404 1
	DUMP_NLONG(hbuf, peer->remote_addr.v4.s_addr);
d571 9
a579 1
		DUMP_LONG(*bp, MRT_DUMP_HEADER_SIZE + len);
@


1.67
log
@Depending on capa.neg.as4byte (bgp session is using 4-byte AS number
extension) we need to switch between _AS4 and non _AS4 types. The
non _AS4 mrt types are totaly confused by 4-byte AS_PATH attributes since
they expect 2-byte ones (and vice versa).
Problem found and fix tested by Xiaoliang Zhao (xzhao at cernet edu cn).
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.66 2009/12/01 14:28:05 claudio Exp $ */
d35 1
a35 1
int mrt_attr_dump(struct buf *, struct rde_aspath *, struct bgpd_addr *);
d39 1
a39 1
int mrt_dump_hdr_se(struct buf **, struct peer *, u_int16_t, u_int16_t,
d41 1
a41 1
int mrt_dump_hdr_rde(struct buf **, u_int16_t type, u_int16_t, u_int32_t);
d47 2
a48 2
		if (buf_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump1: buf_add error");		\
d57 2
a58 2
		if (buf_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump2: buf_add error");		\
d67 2
a68 2
		if (buf_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump3: buf_add error");		\
d76 2
a77 2
		if (buf_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump4: buf_add error");		\
d86 1
a86 1
	struct buf	*buf;
d101 1
a101 1
	if (buf_add(buf, pkg, pkglen) == -1) {
d103 1
a103 1
		buf_free(buf);
d107 1
a107 1
	buf_close(&mrt->wbuf, buf);
d114 1
a114 1
	struct buf	*buf;
d127 1
a127 1
	buf_close(&mrt->wbuf, buf);
d131 1
a131 1
	buf_free(buf);
d135 1
a135 1
mrt_attr_dump(struct buf *buf, struct rde_aspath *a, struct bgpd_addr *nexthop)
d200 1
a200 1
	struct buf	*buf, *hbuf = NULL, *h2buf = NULL;
d207 1
a207 1
	if ((buf = buf_dynamic(0, MAX_PKTSIZE)) == NULL) {
d216 1
a216 1
	len = buf_size(buf);
d218 1
a218 1
	if ((h2buf = buf_dynamic(MRT_BGP4MP_IPv4_HEADER_SIZE +
d240 1
a240 1
		if (buf_add(h2buf, &peer->local_v6_addr.v6,
d242 1
a242 1
		    buf_add(h2buf, &peer->remote_addr.v6,
d276 1
a276 1
		if (buf_add(h2buf, &nh->v6, sizeof(struct in6_addr)) == -1) {
d287 1
a287 1
	if ((bptr = buf_reserve(h2buf, p_len)) == NULL) {
d297 1
a297 1
	len += buf_size(h2buf);
d303 3
a305 3
	buf_close(&mrt->wbuf, hbuf);
	buf_close(&mrt->wbuf, h2buf);
	buf_close(&mrt->wbuf, buf);
d311 1
a311 1
		buf_free(hbuf);
d313 2
a314 2
		buf_free(h2buf);
	buf_free(buf);
d322 1
a322 1
	struct buf	*buf, *hbuf;
d331 1
a331 1
	if ((buf = buf_dynamic(0, MAX_PKTSIZE)) == NULL) {
d344 1
a344 1
		buf_free(buf);
d347 1
a347 1
	len = buf_size(buf);
d350 1
a350 1
		buf_free(buf);
d367 2
a368 2
	buf_close(&mrt->wbuf, hbuf);
	buf_close(&mrt->wbuf, buf);
d373 2
a374 2
	buf_free(hbuf);
	buf_free(buf);
d408 1
a408 1
mrt_dump_hdr_se(struct buf ** bp, struct peer *peer, u_int16_t type,
d413 1
a413 1
	if ((*bp = buf_dynamic(MRT_HEADER_SIZE, MRT_HEADER_SIZE +
d481 1
a481 1
			if (buf_add(*bp, &((struct sockaddr_in6 *)
d487 1
a487 1
		if (buf_add(*bp,
d494 1
a494 1
			if (buf_add(*bp, &((struct sockaddr_in6 *)
d506 1
a506 1
	buf_free(*bp);
d511 1
a511 1
mrt_dump_hdr_rde(struct buf **bp, u_int16_t type, u_int16_t subtype,
d516 1
a516 1
	if ((*bp = buf_dynamic(MRT_HEADER_SIZE, MRT_HEADER_SIZE +
d542 1
a542 1
	buf_free(*bp);
d551 1
a551 1
	if ((r = buf_write(&mrt->wbuf)) < 0) {
d561 1
a561 1
	struct buf	*b;
d566 1
a566 1
		buf_free(b);
@


1.66
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.65 2009/10/26 09:27:58 claudio Exp $ */
d88 4
d97 1
a97 1
	if (mrt_dump_hdr_se(&buf, peer, MSG_PROTOCOL_BGP4MP, BGP4MP_MESSAGE,
d115 4
d120 1
a120 1
	if (mrt_dump_hdr_se(&buf, peer, MSG_PROTOCOL_BGP4MP, BGP4MP_MESSAGE,
@


1.65
log
@Better error handling when doing mrt dumps (e.g. when there is no more space
on the disk). Before the SE spinned and the RDE may even crash in these events.
Found by Elisa Jasinska. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.64 2009/07/12 15:36:41 jsg Exp $ */
d197 1
a197 1
	sa_family_t	 af;
d222 4
a225 3
	af = peer->remote_addr.af == 0 ? p->prefix->af : peer->remote_addr.af;
	switch (af) {
	case AF_INET:
d230 1
a230 1
	case AF_INET6:
d241 1
a241 1
		log_warnx("king bula found new AF %d in mrt_dump_entry_mp", af);
d251 1
a251 1
		nexthop.af = addr.af;
d257 2
a258 2
	switch (addr.af) {
	case AF_INET:
d264 1
a264 1
	case AF_INET6:
d318 2
a319 1
	if (p->prefix->af != AF_INET && peer->remote_addr.af == AF_INET)
d330 1
a330 1
		addr.af = AF_INET;
@


1.64
log
@Remove a semicolon at the end of an if statement so the
test if a buffer isn't NULL before freeing has effect.

This was harmless as it is in a failure case and free(NULL) is
valid in userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.63 2009/06/29 12:22:16 claudio Exp $ */
d390 1
a390 1
mrt_dump_done(void *ptr)
d544 1
@


1.63
log
@Unfuck mrt table dumps and plug a memory leak while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.62 2009/06/05 17:36:49 claudio Exp $ */
d303 1
a303 1
	if (h2buf);
@


1.62
log
@Change the way we do mrt dumps in the rde (from the retarded only one dump
possible to as many as you like). The mrt dumps are now done with the same
tree walking code as the control messages. Makes the RDE respond a bit faster
and use less memory while dumping.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.61 2009/06/04 22:08:19 claudio Exp $ */
d394 1
a394 1
	mrtbuf->type = MRT_STATE_REMOVE;
d588 1
a588 1
	if (MRT2MC(mrt)->state == MRT_STATE_OPEN)
d612 1
a612 1
		if (MRT2MC(m)->state == MRT_STATE_RUNNING &&
d635 2
a636 2
		if (MRT2MC(m)->state == MRT_STATE_OPEN ||
		    MRT2MC(m)->state == MRT_STATE_REOPEN) {
d642 1
a642 1
			MRT2MC(m)->state = MRT_STATE_RUNNING;
d644 1
a644 1
		if (MRT2MC(m)->state == MRT_STATE_REMOVE) {
d660 1
a660 1
		if (MRT2MC(m)->state == MRT_STATE_RUNNING &&
d699 1
a699 1
			MRT2MC(xm)->state = MRT_STATE_OPEN;
d709 1
a709 1
			MRT2MC(xm)->state = MRT_STATE_REOPEN;
d716 1
a716 1
			MRT2MC(xm)->state = MRT_STATE_REMOVE;
@


1.61
log
@Make mrt understand alternate RIB plus remove some other static rib references.
There is still a problem with the mrt dumps because we only allow one in the
RDE. This needs some additional work.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.60 2009/05/17 12:25:15 claudio Exp $ */
a367 8
static u_int16_t sequencenum = 0;

void
mrt_clear_seq(void)
{
	sequencenum = 0;
}

d381 1
a381 1
			mrt_dump_entry(mrtbuf, p, sequencenum++,
d384 1
a384 1
			mrt_dump_entry_mp(mrtbuf, p, sequencenum++,
d387 8
@


1.60
log
@Rework most of the RDE to allow multiple RIBs. This is mostly preparation
work by changing the way the RDE DB is built. struct prefix and struct
pt_entry are simplified and extended with a rib_entry where the decision
tree is run on. From now on a prefix can only reside on one particular RIB
which simplifies the code a bit. Currently there are two fixed ribs
(adj-rib-in and the local-rib) which needs to be made more dynamic in
upcomming commits.
This is work in progress, the RDE seems to work for me and sthen@@ (no flames
comming out of our testrouters but there is still a lot missing)
Move into the tree to simplify developement -- henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.59 2009/04/29 20:04:30 claudio Exp $ */
d679 2
a680 2
		if (t->type == MRT_TABLE_DUMP)
			return (t);
@


1.59
log
@de-static some functions. Helps handling the monster change I'm working on.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.58 2009/03/19 07:00:06 claudio Exp $ */
d377 1
a377 1
mrt_dump_upcall(struct pt_entry *pt, void *ptr)
d387 1
a387 4
	LIST_FOREACH(p, &pt->prefix_h, prefix_l) {
		/* for now dump only stuff from the local-RIB */
		if (!(p->flags & F_LOCAL))
			continue;
@


1.58
log
@First big chunk of mrt rewrite. Simplifies code hopefully and fixes table
dumps that were wrong because of the 4byte AS support. Dumps I took seemed
to work so far. "Put it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.57 2009/03/18 19:45:09 claudio Exp $ */
d35 8
a42 11
static int		mrt_attr_dump(struct buf *, struct rde_aspath *,
			    struct bgpd_addr *);
static int		mrt_dump_entry_mp(struct mrt *, struct prefix *,
			    u_int16_t, struct rde_peer*);
static int		mrt_dump_entry(struct mrt *, struct prefix *,
			    u_int16_t, struct rde_peer*);
static int		mrt_dump_hdr_se(struct buf **, struct peer *,
			    u_int16_t, u_int16_t, u_int32_t, int);
static int		mrt_dump_hdr_rde(struct buf **, u_int16_t type,
			    u_int16_t, u_int32_t);
static int		mrt_open(struct mrt *, time_t);
d126 1
a126 1
static int
d188 1
a188 1
static int
d309 1
a309 1
static int
d400 1
a400 1
static int
d503 1
a503 1
static int
@


1.57
log
@Correctly check for MRT_TABLE_DUMP_MP and don't send the config to the SE.
Make mrt table-mp dumps actually work. Found on the plane from NRT to ZRH.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.56 2009/03/13 06:25:04 claudio Exp $ */
d35 1
a35 2
static u_int16_t	mrt_attr_length(struct rde_aspath *, int);
static int		mrt_attr_dump(void *, u_int16_t, struct rde_aspath *,
d41 4
a44 2
static int		mrt_dump_header(struct buf *, u_int16_t, u_int16_t,
			    u_int32_t);
d52 1
a52 2
			buf_free((x));					\
			return (-1);					\
d62 1
a62 2
			buf_free((x));					\
			return (-1);					\
d72 1
a72 2
			buf_free((x));					\
			return (-1);					\
d81 1
a81 2
			buf_free((x));					\
			return (-1);					\
d85 1
a85 1
int
d87 1
a87 1
    struct peer *peer, struct bgpd_config *bgp)
a89 1
	u_int16_t	 len;
a91 11
	switch (peer->sa_local.ss_family) {
	case AF_INET:
		len = pkglen + MRT_BGP4MP_IPv4_HEADER_SIZE;
		break;
	case AF_INET6:
		len = pkglen + MRT_BGP4MP_IPv6_HEADER_SIZE;
		break;
	default:
		return (-1);
	}

d96 3
a98 56
	if ((buf = buf_open(len + MRT_HEADER_SIZE)) == NULL) {
		log_warnx("mrt_dump_bgp_msg: buf_open error");
		return (-1);
	}

	if (mrt_dump_header(buf, MSG_PROTOCOL_BGP4MP, BGP4MP_MESSAGE,
	    len) == -1) {
		log_warnx("mrt_dump_bgp_msg: buf_add error");
		return (-1);
	}

	if (!incoming)
		DUMP_SHORT(buf, bgp->short_as);
	DUMP_SHORT(buf, peer->short_as);
	if (incoming)
		DUMP_SHORT(buf, bgp->short_as);
	DUMP_SHORT(buf, /* ifindex */ 0);
	switch (peer->sa_local.ss_family) {
	case AF_INET:
		DUMP_SHORT(buf, AFI_IPv4);
		if (!incoming)
			DUMP_NLONG(buf, ((struct sockaddr_in *)
			    &peer->sa_local)->sin_addr.s_addr);
		DUMP_NLONG(buf,
		    ((struct sockaddr_in *)&peer->sa_remote)->sin_addr.s_addr);
		if (incoming)
			DUMP_NLONG(buf, ((struct sockaddr_in *)
			    &peer->sa_local)->sin_addr.s_addr);
		break;
	case AF_INET6:
		DUMP_SHORT(buf, AFI_IPv6);
		if (!incoming)
			if (buf_add(buf, &((struct sockaddr_in6 *)
			    &peer->sa_local)->sin6_addr,
			    sizeof(struct in6_addr)) == -1) {
				log_warnx("mrt_dump_bgp_msg: buf_add error");
				buf_free(buf);
				return (-1);
			}
		if (buf_add(buf,
		    &((struct sockaddr_in6 *)&peer->sa_remote)->sin6_addr,
		    sizeof(struct in6_addr)) == -1) {
			log_warnx("mrt_dump_bgp_msg: buf_add error");
			buf_free(buf);
			return (-1);
		}
		if (incoming)
			if (buf_add(buf, &((struct sockaddr_in6 *)
			    &peer->sa_local)->sin6_addr,
			    sizeof(struct in6_addr)) == -1) {
				log_warnx("mrt_dump_bgp_msg: buf_add error");
				buf_free(buf);
				return (-1);
			}
		break;
	}
d103 1
a103 1
		return (-1);
a106 2

	return (len + MRT_HEADER_SIZE);
d109 1
a109 1
int
d111 1
a111 1
    struct peer *peer, struct bgpd_config *bgp)
a113 12
	u_int16_t	 len;

	switch (peer->sa_local.ss_family) {
	case AF_INET:
		len = 4 + MRT_BGP4MP_IPv4_HEADER_SIZE;
		break;
	case AF_INET6:
		len = 4 + MRT_BGP4MP_IPv6_HEADER_SIZE;
		break;
	default:
		return (-1);
	}
d115 3
a117 36
	if ((buf = buf_open(len + MRT_HEADER_SIZE)) == NULL) {
		log_warnx("mrt_dump_bgp_state: buf_open error");
		return (-1);
	}

	if (mrt_dump_header(buf, MSG_PROTOCOL_BGP4MP, BGP4MP_STATE_CHANGE,
	    len) == -1) {
		log_warnx("mrt_dump_bgp_state: buf_add error");
		return (-1);
	}

	DUMP_SHORT(buf, bgp->short_as);
	DUMP_SHORT(buf, peer->short_as);
	DUMP_SHORT(buf, /* ifindex */ 0);
	switch (peer->sa_local.ss_family) {
	case AF_INET:
		DUMP_SHORT(buf, AFI_IPv4);
		DUMP_NLONG(buf,
		    ((struct sockaddr_in *)&peer->sa_local)->sin_addr.s_addr);
		DUMP_NLONG(buf,
		    ((struct sockaddr_in *)&peer->sa_remote)->sin_addr.s_addr);
		break;
	case AF_INET6:
		DUMP_SHORT(buf, AFI_IPv6);
		if (buf_add(buf,
		    &((struct sockaddr_in6 *)&peer->sa_local)->sin6_addr,
		    sizeof(struct in6_addr)) == -1 ||
		    buf_add(buf,
		    &((struct sockaddr_in6 *)&peer->sa_remote)->sin6_addr,
		    sizeof(struct in6_addr)) == -1) {
			log_warnx("mrt_dump_bgp_msg: buf_add error");
			buf_free(buf);
			return (-1);
		}
		break;
	}
d123 1
d125 2
a126 25
	return (len + MRT_HEADER_SIZE);
}

static u_int16_t
mrt_attr_length(struct rde_aspath *a, int oldform)
{
	u_int16_t	 alen, plen;
	u_int8_t	 l;

	alen = 4 /* origin */ + 7 /* lpref */;
	if (oldform)
		alen += 7 /* nexthop */;
	plen = aspath_length(a->aspath);
	alen += 2 + plen + (plen > 255 ? 2 : 1);
	if (a->med != 0)
		alen += 7;

	for (l = 0; l < a->others_len; l++)
		if (a->others[l] != NULL)
			alen += 2 + a->others[l]->len +
			    (a->others[l]->len > 255 ? 2 : 1);
		else
			break;

	return alen;
d130 1
a130 2
mrt_attr_dump(void *p, u_int16_t len, struct rde_aspath *a,
    struct bgpd_addr *nexthop)
d133 4
a136 4
	u_char		*buf = p;
	u_int32_t	 tmp32;
	int		 r;
	u_int16_t	 aslen, wlen = 0;
d140 2
a141 2
	if ((r = attr_write(buf + wlen, len, ATTR_WELL_KNOWN, ATTR_ORIGIN,
	    &a->origin, 1)) == -1)
a142 1
	wlen += r; len -= r;
d145 3
a147 3
	aslen = aspath_length(a->aspath);
	if ((r = attr_write(buf + wlen, len, ATTR_WELL_KNOWN, ATTR_ASPATH,
	    aspath_dump(a->aspath), aslen)) == -1)
d149 1
a149 1
	wlen += r; len -= r;
d153 2
a154 2
		if ((r = attr_write(buf + wlen, len, ATTR_WELL_KNOWN,
		    ATTR_NEXTHOP, &nexthop->v4.s_addr, 4)) ==	-1)
a155 1
		wlen += r; len -= r;
d160 2
a161 3
		tmp32 = htonl(a->med);
		if ((r = attr_write(buf + wlen, len, ATTR_OPTIONAL, ATTR_MED,
		    &tmp32, 4)) == -1)
a162 1
		wlen += r; len -= r;
d166 2
a167 3
	tmp32 = htonl(a->lpref);
	if ((r = attr_write(buf + wlen, len, ATTR_WELL_KNOWN, ATTR_LOCALPREF,
	    &tmp32, 4)) == -1)
a168 1
	wlen += r; len -= r;
d174 2
a175 2
		if ((r = attr_write(buf + wlen, len, oa->flags, oa->type,
		    oa->data, oa->len)) == -1)
a176 1
		wlen += r; len -= r;
d179 10
a188 1
	return (wlen);
d195 1
a195 1
	struct buf	*buf;
d198 1
a198 1
	u_int16_t	 len, attr_len;
d202 2
a203 13
	attr_len = mrt_attr_length(p->aspath, 0);
	p_len = PREFIX_SIZE(p->prefix->prefixlen);
	pt_getaddr(p->prefix, &addr);

	af = peer->remote_addr.af == 0 ? addr.af : peer->remote_addr.af;
	switch (af) {
	case AF_INET:
		len = MRT_BGP4MP_IPv4_HEADER_SIZE;
		break;
	case AF_INET6:
		len = MRT_BGP4MP_IPv6_HEADER_SIZE;
		break;
	default:
d207 3
a209 9
	switch (addr.af) {
	case AF_INET:
		len += MRT_BGP4MP_IPv4_ENTRY_SIZE + p_len + attr_len;
		break;
	case AF_INET6:
		len += MRT_BGP4MP_IPv6_ENTRY_SIZE + p_len + attr_len;
		break;
	default:
		return (-1);
d211 1
d213 5
a217 9
	if ((buf = buf_open(len + MRT_HEADER_SIZE)) == NULL) {
		log_warnx("mrt_dump_entry_mp: buf_open error");
		return (-1);
	}

	if (mrt_dump_header(buf, MSG_PROTOCOL_BGP4MP, BGP4MP_ENTRY,
	    len) == -1) {
		log_warnx("mrt_dump_entry_mp: buf_add error");
		return (-1);
d220 3
a222 3
	DUMP_SHORT(buf, rde_local_as());
	DUMP_SHORT(buf, peer->short_as);
	DUMP_SHORT(buf, /* ifindex */ 0);
d224 2
d228 3
a230 3
		DUMP_SHORT(buf, AFI_IPv4);
		DUMP_NLONG(buf, peer->local_v4_addr.v4.s_addr);
		DUMP_NLONG(buf, peer->remote_addr.v4.s_addr);
d233 2
a234 2
		DUMP_SHORT(buf, AFI_IPv6);
		if (buf_add(buf, &peer->local_v6_addr.v6,
d236 1
a236 1
		    buf_add(buf, &peer->remote_addr.v6,
d239 1
a239 2
			buf_free(buf);
			return (-1);
d242 3
d247 3
a249 3
	DUMP_SHORT(buf, 0);		/* view */
	DUMP_SHORT(buf, 1);		/* status */
	DUMP_LONG(buf, p->lastchange);	/* originated */
d258 1
d261 4
a264 4
		DUMP_SHORT(buf, AFI_IPv4);	/* afi */
		DUMP_BYTE(buf, SAFI_UNICAST);	/* safi */
		DUMP_BYTE(buf, 4);		/* nhlen */
		DUMP_NLONG(buf, nh->v4.s_addr);	/* nexthop */
d267 4
a270 4
		DUMP_SHORT(buf, AFI_IPv6);	/* afi */
		DUMP_BYTE(buf, SAFI_UNICAST);	/* safi */
		DUMP_BYTE(buf, 16);		/* nhlen */
		if (buf_add(buf, &nh->v6, sizeof(struct in6_addr)) == -1) {
d272 1
a272 2
			buf_free(buf);
			return (-1);
d275 3
d280 2
a281 1
	if ((bptr = buf_reserve(buf, p_len)) == NULL) {
d283 1
a283 2
		buf_free(buf);
		return (-1);
d287 1
a287 2
		buf_free(buf);
		return (-1);
d290 2
a291 6
	DUMP_SHORT(buf, attr_len);
	if ((bptr = buf_reserve(buf, attr_len)) == NULL) {
		log_warnx("mrt_dump_entry_mp: buf_reserve error");
		buf_free(buf);
		return (-1);
	}
d293 3
a295 5
	if (mrt_attr_dump(bptr, attr_len, p->aspath, NULL) == -1) {
		log_warnx("mrt_dump_entry_mp: mrt_attr_dump error");
		buf_free(buf);
		return (-1);
	}
d297 2
d302 8
d316 1
a316 2
	struct buf	*buf;
	void		*bptr;
d318 1
a318 1
	u_int16_t	 len, attr_len;
d321 1
a321 1
		/* only for true IPv4 */
d324 2
a325 27
	attr_len = mrt_attr_length(p->aspath, 1);
	len = MRT_DUMP_HEADER_SIZE + attr_len;
	pt_getaddr(p->prefix, &addr);

	if ((buf = buf_open(len + MRT_HEADER_SIZE)) == NULL) {
		log_warnx("mrt_dump_entry: buf_open error");
		return (-1);
	}

	if (mrt_dump_header(buf, MSG_TABLE_DUMP, AFI_IPv4, len) == -1) {
		log_warnx("mrt_dump_entry: buf_add error");
		return (-1);
	}

	DUMP_SHORT(buf, 0);
	DUMP_SHORT(buf, snum);
	DUMP_NLONG(buf, addr.v4.s_addr);
	DUMP_BYTE(buf, p->prefix->prefixlen);
	DUMP_BYTE(buf, 1);		/* state */
	DUMP_LONG(buf, p->lastchange);	/* originated */
	DUMP_NLONG(buf, peer->remote_addr.v4.s_addr);
	DUMP_SHORT(buf, peer->short_as);

	DUMP_SHORT(buf, attr_len);
	if ((bptr = buf_reserve(buf, attr_len)) == NULL) {
		log_warnx("mrt_dump_entry: buf_reserve error");
		buf_free(buf);
d335 1
a335 1
	if (mrt_attr_dump(bptr, attr_len, p->aspath, nh) == -1) {
d340 1
d342 19
d364 5
d404 2
a405 2
mrt_dump_header(struct buf *buf, u_int16_t type, u_int16_t subtype,
    u_int32_t len)
d407 7
a413 1
	time_t	now;
d417 3
a419 4
	DUMP_LONG(buf, now);
	DUMP_SHORT(buf, type);
	DUMP_SHORT(buf, subtype);
	DUMP_LONG(buf, len);
d421 114
d536 4
@


1.56
log
@Next step in mrt cleanup. Switch buf_write to a smarter version of itself.
Doing more the stuff msgbuf_write does and switch the only user -- mrt --
over to use this simpler way of writing out stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.55 2009/03/13 05:43:50 claudio Exp $ */
d603 1
a603 1
	int		i, fd;
d623 2
a624 1
	i = mrt->type == MRT_TABLE_DUMP ? 0 : 1;
@


1.55
log
@Move mrt code over to use the msgbuf way of queuing buffers instead of rolling
an own version. More cleanup to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.54 2009/02/19 21:34:40 claudio Exp $ */
d554 1
a554 1
	time_t			now;
d566 1
a566 1
int
d569 1
a569 2
	struct buf	*b;
	int		 r = 0;
d571 2
a572 8
	while ((b = TAILQ_FIRST(&mrt->wbuf.bufs)) &&
	    (r = buf_write(mrt->wbuf.fd, b)) == 1) {
		TAILQ_REMOVE(&mrt->wbuf.bufs, b, entry);
		mrt->wbuf.queued--;
		buf_free(b);
	}
	if (r <= -1) {
		log_warn("mrt dump write");
a573 1
		return (-1);
a574 1
	return (0);
@


1.54
log
@Use a bob sized header for IPv6 not the default pedro sized one.
Seems like nobody ever tried to dump IPv6 tables. Found while reworking this
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.53 2007/04/23 13:04:24 claudio Exp $ */
d174 1
a174 2
	TAILQ_INSERT_TAIL(&mrt->bufs, buf, entry);
	mrt->queued++;
d237 1
a237 2
	TAILQ_INSERT_TAIL(&mrt->bufs, buf, entry);
	mrt->queued++;
d453 1
a453 2
	TAILQ_INSERT_TAIL(&mrt->bufs, buf, entry);
	mrt->queued++;
d513 1
a513 2
	TAILQ_INSERT_TAIL(&mrt->bufs, buf, entry);
	mrt->queued++;
d572 4
a575 4
	while ((b = TAILQ_FIRST(&mrt->bufs)) &&
	    (r = buf_write(mrt->fd, b)) == 1) {
		TAILQ_REMOVE(&mrt->bufs, b, entry);
		mrt->queued--;
d591 3
a593 3
	close(mrt->fd);
	while ((b = TAILQ_FIRST(&mrt->bufs))) {
		TAILQ_REMOVE(&mrt->bufs, b, entry);
d596 1
a596 1
	mrt->queued = 0;
d612 1
a612 1
	int		i;
a616 1
		mrt->fd = -1;
d620 1
a620 1
	mrt->fd = open(MRT2MC(mrt)->file,
d622 1
a622 1
	if (mrt->fd == -1) {
d634 1
a634 1
	if (imsg_compose(mrt_imsgbuf[i], type, 0, 0, mrt->fd,
a736 1
			xm->fd = -1;
a763 1

@


1.53
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.52 2007/02/12 19:15:14 claudio Exp $ */
d361 1
a361 1
		len += MRT_BGP4MP_IPv4_ENTRY_SIZE + p_len + attr_len;
@


1.52
log
@Switch address and AS fields in mrt dump messages for incoming traffic so
that source and destination match the actual traffic flow.
Found and initial diff by Adam Chappell (Adam.Chappell at interoute dot com)
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.51 2007/02/12 13:12:30 claudio Exp $ */
d123 2
a124 2
		DUMP_SHORT(buf, bgp->as);
	DUMP_SHORT(buf, peer->conf.remote_as);
d126 1
a126 1
		DUMP_SHORT(buf, bgp->as);
d209 2
a210 2
	DUMP_SHORT(buf, bgp->as);
	DUMP_SHORT(buf, peer->conf.remote_as);
d379 1
a379 1
	DUMP_SHORT(buf, peer->conf.remote_as);
d495 1
a495 1
	DUMP_SHORT(buf, peer->conf.remote_as);
@


1.51
log
@Fix some log_warn() messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.50 2006/02/08 14:49:58 claudio Exp $ */
d94 1
d107 4
d122 2
a123 1
	DUMP_SHORT(buf, bgp->as);
d125 2
d131 3
a133 2
		DUMP_NLONG(buf,
		    ((struct sockaddr_in *)&peer->sa_local)->sin_addr.s_addr);
d136 3
d142 8
a150 3
		    &((struct sockaddr_in6 *)&peer->sa_local)->sin6_addr,
		    sizeof(struct in6_addr)) == -1 ||
		    buf_add(buf,
d157 8
@


1.50
log
@For now dump only stuff from the local-RIB into mrt table dumps.
Issue found by Andre Oppermann.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.49 2006/01/05 16:00:07 claudio Exp $ */
d407 1
a407 1
		log_warnx("mrt_dump_entry_mpbuf_reserve error");
d412 1
a412 1
		log_warnx("mrt_dump_entry_mpprefix_write error");
d419 1
a419 1
		log_warnx("mrt_dump_entry_mpbuf_reserve error");
d425 1
a425 1
		log_warnx("mrt_dump_entry_mpmrt_attr_dump error");
@


1.49
log
@Cache optional BGP attributes (mostly communities) and use a simple
pointer plus a ref counter to link the attributes to the path object.
Saves +/- 10M on 11 full feeds. Looks good Henning
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.48 2005/11/29 21:11:07 claudio Exp $ */
d516 4
a519 1
	LIST_FOREACH(p, &pt->prefix_h, prefix_l)
d526 1
@


1.48
log
@Add a flags field to struct prefix which will be used shortly. Remove the peer
pointer so that the size does not grow. Adding 4 bytes to struct prefix would
result in 64MB more memory usage on one of my systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.47 2004/12/23 16:09:26 henning Exp $ */
a221 1
	struct attr	*oa;
d223 1
d233 6
a238 2
	TAILQ_FOREACH(oa, &a->others, entry)
		alen += 2 + oa->len + (oa->len > 255 ? 2 : 1);
d252 1
d292 3
a294 1
	TAILQ_FOREACH(oa, &a->others, entry) {
@


1.47
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.46 2004/11/11 13:06:44 claudio Exp $ */
d511 2
a512 1
			mrt_dump_entry(mrtbuf, p, sequencenum++, p->peer);
d514 2
a515 1
			mrt_dump_entry_mp(mrtbuf, p, sequencenum++, p->peer);
@


1.46
log
@Store the local v4 and v6 address of a session. For IPv4 sessions the first
IPv6 address with global scope of the interface used by the session is used.
In any case the local endpoint of the session is used for one of the two no
matter what scope.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.45 2004/09/16 17:36:29 henning Exp $ */
d311 1
a311 1
	
@


1.45
log
@imsg API cleanup:
-kill imsg_compose_pid, imsg_compose_fdpass and imsg_create_pid
-extend the original imsg_compose/_create API to take pid & fd too
-make imsg_compose do imsg_create + imsg_add + imsg_close instead of
 duplicating the code
-adjust all callers to the new API
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.44 2004/08/13 14:03:20 claudio Exp $ */
d353 1
a353 1
		DUMP_NLONG(buf, peer->local_addr.v4.s_addr);
d358 1
a358 1
		if (buf_add(buf, &peer->local_addr.v6,
@


1.44
log
@Fix minor issues with IPv6 dumps and add a function for dumping the RIB table
protocol independent. This new dump format is not (yet) supported by the
mrtd route_btoa tool. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.43 2004/08/11 16:48:45 claudio Exp $ */
d601 1
a601 1
	if (imsg_compose_fdpass(mrt_imsgbuf[i], type, mrt->fd,
@


1.43
log
@mrt dumps for cloned sessions did not work because the wrong address was used.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.42 2004/08/11 09:37:11 claudio Exp $ */
d35 1
a35 1
static u_int16_t	mrt_attr_length(struct rde_aspath *);
d38 2
d41 1
a41 1
			    u_int16_t, struct peer_config *);
d95 10
a104 1
	len = pkglen + MRT_BGP4MP_HEADER_SIZE;
d162 10
a171 1
	len = 4 + MRT_BGP4MP_HEADER_SIZE;
d220 1
a220 1
mrt_attr_length(struct rde_aspath *a)
d225 3
a227 1
	alen = 4 /* origin */ + 7 /* nexthop */ + 7 /* lpref */;
d262 7
a268 5
	/* nexthop, already network byte order */
	if ((r = attr_write(buf + wlen, len, ATTR_WELL_KNOWN, ATTR_NEXTHOP,
	    &nexthop->v4.s_addr, 4)) ==	-1)
		return (-1);
	wlen += r; len -= r;
d298 132
d431 1
a431 1
    struct peer_config *peer)
d438 5
a442 1
	attr_len = mrt_attr_length(p->aspath);
d452 1
a452 1
		log_warnx("mrt_dump_bgp_msg: buf_add error");
d463 2
a464 1
	DUMP_SHORT(buf, peer->remote_as);
a465 1

d510 4
a513 2
		mrt_dump_entry(mrtbuf, p, sequencenum++,
		    &p->peer->conf);
@


1.42
log
@buf_write() returns -1 on error and -2 on connection closed. Treat both
as errors for mrt dumps.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.41 2004/08/10 13:50:10 claudio Exp $ */
d88 1
a88 1
    struct peer_config *peer, struct bgpd_config *bgp)
d107 1
a107 1
	DUMP_SHORT(buf, peer->remote_as);
d109 1
a109 1
	switch (peer->local_addr.af) {
d112 4
a115 2
		DUMP_NLONG(buf, peer->local_addr.v4.s_addr);
		DUMP_NLONG(buf, peer->remote_addr.v4.s_addr);
d119 6
a124 4
		if (buf_add(buf, &peer->local_addr.v6,
		    sizeof(peer->local_addr.v6)) == -1 ||
		    buf_add(buf, &peer->remote_addr.v6,
		    sizeof(peer->remote_addr.v6)) == -1) {
d146 1
a146 1
    struct peer_config *peer, struct bgpd_config *bgp)
d165 1
a165 1
	DUMP_SHORT(buf, peer->remote_as);
d167 1
a167 1
	switch (peer->local_addr.af) {
d170 4
a173 2
		DUMP_NLONG(buf, peer->local_addr.v4.s_addr);
		DUMP_NLONG(buf, peer->remote_addr.v4.s_addr);
d177 6
a182 4
		if (buf_add(buf, &peer->local_addr.v6,
		    sizeof(peer->local_addr.v6)) == -1 ||
		    buf_add(buf, &peer->remote_addr.v6,
		    sizeof(peer->remote_addr.v6)) == -1) {
@


1.41
log
@Always free message buffer on error.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.40 2004/08/10 13:46:28 claudio Exp $ */
d374 1
a374 1
	if (r == -1) {
@


1.40
log
@Support IPv6 in message and state transition dumps. Table dumps still
unsupported. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.39 2004/08/06 12:04:08 claudio Exp $ */
d49 1
d60 1
d71 1
d81 1
d122 1
d130 1
d176 1
@


1.39
log
@Monster diff to get one step closer to IPv6 support.
Cleanup path attribute handling. First of all kill struct attr_flags, all
those infos are now in struct rde_aspath. Second move attribute parser
functions into rde.c, rde_attr.c is shared between bgpd and bgpctl.
Third reimplementation of the nexthop handling. Make it IPv6 ready and
fix some major bug relating to "set nexthop".
henning@@ OK if it breaks nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.38 2004/08/05 16:26:56 claudio Exp $ */
d105 17
a121 3
	DUMP_SHORT(buf, AFI_IPv4);
	DUMP_NLONG(buf, peer->local_addr.v4.s_addr);
	DUMP_NLONG(buf, peer->remote_addr.v4.s_addr);
d157 17
a173 3
	DUMP_SHORT(buf, AFI_IPv4);
	DUMP_NLONG(buf, peer->local_addr.v4.s_addr);
	DUMP_NLONG(buf, peer->remote_addr.v4.s_addr);
@


1.38
log
@struct prefix has a pointer to the peer so use it everywhere directly instead
of the detour via aspath.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.37 2004/08/03 14:00:15 claudio Exp $ */
d35 3
a37 2
static u_int16_t	mrt_attr_length(struct attr_flags *);
static int		mrt_attr_dump(void *, u_int16_t, struct attr_flags *);
d157 1
a157 1
mrt_attr_length(struct attr_flags *a)
d175 2
a176 1
mrt_attr_dump(void *p, u_int16_t len, struct attr_flags *a)
d199 1
a199 1
	    &a->nexthop, 4)) ==	-1)
d236 1
a236 1
	struct bgpd_addr addr;
d239 1
a239 1
	attr_len = mrt_attr_length(&p->aspath->flags);
d269 7
a275 1
	if (mrt_attr_dump(bptr, attr_len, &p->aspath->flags) == -1) {
@


1.37
log
@Make mrt dumps mrt compliant. I already fixed one of those but this one
slipped my attention. Now all bgpd dumps can be read with mrt's route_btoa.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.36 2004/07/28 16:00:02 claudio Exp $ */
d300 1
a300 1
		    &p->aspath->peer->conf);
@


1.36
log
@The hole dance to close a mrt file after fd passing in the parent is not
needed as the fd is closed while beeing passed. looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.35 2004/07/07 21:18:06 claudio Exp $ */
d104 1
a104 1
	DUMP_SHORT(buf, 4);
@


1.35
log
@Stupid typo that may cause a lot of pain. Found by Patrick Latifi. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.34 2004/07/07 21:15:18 claudio Exp $ */
a366 1
	mrt_close(mrt);
d390 1
a390 1
		log_warn("mrt_close");
a394 24
void
mrt_close(struct mrt *mrt)
{
	if (mrt == NULL)
		return;
	/*
	 * this function is normaly called twice. First because of a imsg 
	 * form the child to inform the parent to close the fd. The second time
	 * it is called after reconfigure when the mrt file gets removed.
	 * In that case the parent must inform the child to close and remove
	 * this mrt dump descriptor.
	 */
	if (MRT2MC(mrt)->state == MRT_STATE_REMOVE)
		if (imsg_compose(
		    mrt_imsgbuf[mrt->type == MRT_TABLE_DUMP ? 0 : 1],
		    IMSG_MRT_CLOSE, 0, mrt, sizeof(struct mrt)) == -1)
			log_warn("mrt_close");

	if (mrt->fd == -1)
		return;
	close(mrt->fd);
	mrt->fd = -1;
}

a436 1
			mrt_close(m);
@


1.34
log
@Bad interpretation of the oh so well documented mrt spec. Found by
Stefan Wahl.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.33 2004/07/03 17:19:59 claudio Exp $ */
d522 1
a522 1
			if (strlcpy(MRT2MC(xm)->name, MRT2MC(xm)->name,
@


1.33
log
@Switch mrt dumping to fd passing. This gives some speed up when extensive
dumping is done. Acctually mrt dumps were broken because of the fd passing.
The nice side effect is a much cleaner code, especially in the parent process.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.32 2004/06/22 20:28:58 claudio Exp $ */
d142 1
a142 1
	DUMP_SHORT(buf, 4);
@


1.32
log
@Make the RDE IPv6 ready missing is the message handling. The internal
prefix tree changed form a hash table to a per AF RB tree.
OK henning@@ some ideas are from Brent Graveland.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.31 2004/06/20 18:35:12 henning Exp $ */
d37 1
a37 1
static int		mrt_dump_entry(struct mrt_config *, struct prefix *,
d41 1
a41 1
static int		mrt_open(struct mrt *);
d46 2
a47 2
		if (imsg_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump1: imsg_add error");		\
d56 2
a57 2
		if (imsg_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump2: imsg_add error");		\
d66 2
a67 2
		if (imsg_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump3: imsg_add error");		\
d75 2
a76 2
		if (imsg_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump4: imsg_add error");		\
d82 1
a82 1
mrt_dump_bgp_msg(struct mrt_config *mrt, void *pkg, u_int16_t pkglen,
d90 2
a91 3
	if ((buf = imsg_create(mrt->ibuf, IMSG_MRT_MSG, mrt->id,
	    len + MRT_HEADER_SIZE)) == NULL) {
		log_warnx("mrt_dump_bgp_msg: imsg_open error");
d97 1
a97 1
		log_warnx("mrt_dump_bgp_msg: imsg_add error");
d108 2
a109 2
	if (imsg_add(buf, pkg, pkglen) == -1) {
		log_warnx("mrt_dump_bgp_msg: imsg_add error");
d113 2
a114 4
	if ((imsg_close(mrt->ibuf, buf)) == -1) {
		log_warnx("mrt_dump_bgp_msg: imsg_close error");
		return (-1);
	}
d120 1
a120 1
mrt_dump_state(struct mrt_config *mrt, u_int16_t old_state, u_int16_t new_state,
d128 2
a129 3
	if ((buf = imsg_create(mrt->ibuf, IMSG_MRT_MSG, mrt->id,
	    len + MRT_HEADER_SIZE)) == NULL) {
		log_warnx("mrt_dump_bgp_state: imsg_open error");
d135 1
a135 1
		log_warnx("mrt_dump_bgp_state: imsg_add error");
d149 2
a150 4
	if ((imsg_close(mrt->ibuf, buf)) == -1) {
		log_warnx("mrt_dump_bgp_state: imsg_close error");
		return (-1);
	}
d229 1
a229 1
mrt_dump_entry(struct mrt_config *mrt, struct prefix *p, u_int16_t snum,
d241 2
a242 3
	if ((buf = imsg_create(mrt->ibuf, IMSG_MRT_MSG, mrt->id,
	    len + MRT_HEADER_SIZE)) == NULL) {
		log_warnx("mrt_dump_entry: imsg_open error");
d273 2
a274 4
	if ((imsg_close(mrt->ibuf, buf)) == -1) {
		log_warnx("mrt_dump_bgp_state: imsg_close error");
		return (-1);
	}
d290 1
a290 1
	struct mrt_config	*mrtbuf = ptr;
d319 33
d361 2
a362 2
static int
mrt_open(struct mrt *mrt)
d364 2
a365 1
	time_t	now;
d367 3
a369 3
	now = time(NULL);
	if (strftime(mrt->file, sizeof(mrt->file), mrt->name,
		    localtime(&now)) == 0) {
d371 2
a372 2
		mrt->msgbuf.fd = -1;
		return (0);
d375 1
a375 1
	mrt->msgbuf.fd = open(mrt->file,
d377 3
a379 4
	if (mrt->msgbuf.fd == -1) {
		log_warnx("mrt_open %s: %s",
		    mrt->file, strerror(errno));
		return (0);
a380 2
	return (1);
}
d382 6
a387 11
static int
mrt_close(struct mrt *mrt)
{
	/*
	 * close the mrt filedescriptor but first ensure that the last
	 * mrt message was written correctly. If not mrt_write needs to do
	 * that the next time called.
	 * To ensure this we need to fiddle around with internal msgbuf stuff.
	 */
	if (msgbuf_unbounded(&mrt->msgbuf))
		return (0);
d389 3
a391 4
	if (mrt->msgbuf.fd != -1) {
		close(mrt->msgbuf.fd);
		mrt->msgbuf.fd = -1;
	}
d397 1
a397 1
mrt_abort(struct mrt *mrt)
d399 2
d402 5
a406 3
	 * something failed horribly. Stop all dumping and go back to start
	 * position. Retry after MRT_MIN_RETRY or ReopenTimerInterval. Which-
	 * ever is bigger.
d408 10
a417 8
	msgbuf_clear(&mrt->msgbuf);
	mrt_close(mrt);
	mrt->state = MRT_STATE_STOPPED;

	if (MRT_MIN_RETRY > mrt->ReopenTimerInterval)
		mrt->ReopenTimer = MRT_MIN_RETRY + time(NULL);
	else
		mrt->ReopenTimer = mrt->ReopenTimerInterval + time(NULL);
d421 1
a421 1
mrt_queue(struct mrt_head *mrtc, struct imsg *imsg)
a422 1
	struct buf	*wbuf;
d424 2
a425 2
	ssize_t		 len;
	int		 n;
d427 8
a434 53
	if (imsg->hdr.type != IMSG_MRT_MSG && imsg->hdr.type != IMSG_MRT_END)
		return (-1);

	LIST_FOREACH(m, mrtc, list) {
		if (m->conf.id != imsg->hdr.peerid)
			continue;
		if (m->state != MRT_STATE_RUNNING &&
		    m->state != MRT_STATE_REOPEN)
			return (0);

		if (imsg->hdr.type == IMSG_MRT_END) {
			m->state = MRT_STATE_CLOSE;
			return (0);
		}

		len = imsg->hdr.len - IMSG_HEADER_SIZE;
		wbuf = buf_open(len);
		if (wbuf == NULL)
			return (-1);
		if (buf_add(wbuf, imsg->data, len) == -1) {
			buf_free(wbuf);
			return (-1);
		}
		if ((n = buf_close(&m->msgbuf, wbuf)) < 0) {
			buf_free(wbuf);
			return (-1);
		}
		return (n);
	}
	return (0);
}

int
mrt_write(struct mrt *mrt)
{
	int	r;

	if (mrt->state == MRT_STATE_REOPEN ||
	    mrt->state == MRT_STATE_REMOVE)
		r = msgbuf_writebound(&mrt->msgbuf);
	else
		r = msgbuf_write(&mrt->msgbuf);

	switch (r) {
	case 1:
		/* only msgbuf_writebound returns 1 */
		break;
	case 0:
		if (mrt->state == MRT_STATE_CLOSE && mrt->msgbuf.queued == 0) {
			if (mrt_close(mrt) != 1) {
				log_warnx("mrt_write: mrt_close failed");
				mrt_abort(mrt);
				return (0);
d436 2
a437 42
			mrt->state = MRT_STATE_STOPPED;
		}
		return (0);
	case -1:
		log_warnx("mrt_write: msgbuf_write: %s",
		    strerror(errno));
		mrt_abort(mrt);
		return (0);
	case -2:
		log_warnx("mrt_write: msgbuf_write: %s",
		    "connection closed");
		mrt_abort(mrt);
		return (0);
	default:
		fatalx("mrt_write: unexpected retval from msgbuf_write");
	}

	if (mrt_close(mrt) != 1) {
		log_warnx("mrt_write: mrt_close failed");
		mrt_abort(mrt);
		return (0);
	}

	switch (mrt->state) {
	case MRT_STATE_REMOVE:
		/*
		 * Remove request: free all left buffers and
		 * remove the descriptor.
		 */
		msgbuf_clear(&mrt->msgbuf);
		LIST_REMOVE(mrt, list);
		free(mrt);
		return (0);
	case MRT_STATE_REOPEN:
		if (mrt_open(mrt) == 0) {
			mrt_abort(mrt);
			return (0);
		} else {
			if (mrt->ReopenTimerInterval != 0)
				mrt->ReopenTimer = time(NULL) +
				    mrt->ReopenTimerInterval;
			mrt->state = MRT_STATE_RUNNING;
a438 3
		break;
	default:
		break;
d440 1
a440 1
	return (1);
d443 2
a444 3
int
mrt_select(struct mrt_head *mc, struct pollfd *pfd, struct mrt **mrt,
    int start, int size, int *timeout)
a447 1
	int		 t;
d450 5
a454 12
	for (m = LIST_FIRST(mc); m != NULL; m = xm) {
		xm = LIST_NEXT(m, list);
		if (m->state == MRT_STATE_TOREMOVE) {
			imsg_compose(m->ibuf, IMSG_MRT_END, 0,
			    &m->conf, sizeof(m->conf));
			if (mrt_close(m) == 0) {
				m->state = MRT_STATE_REMOVE;
				m->ReopenTimer = 0;
			} else {
				msgbuf_clear(&m->msgbuf);
				LIST_REMOVE(m, list);
				free(m);
d456 10
a465 91
			}
		}
		if (m->state == MRT_STATE_OPEN) {
			switch (m->conf.type) {
			case MRT_TABLE_DUMP:
				m->ibuf = mrt_imsgbuf[0];
				break;
			case MRT_ALL_IN:
			case MRT_ALL_OUT:
			case MRT_UPDATE_IN:
			case MRT_UPDATE_OUT:
				m->ibuf = mrt_imsgbuf[1];
				break;
			default:
				continue;
			}
			if (mrt_open(m) == 0) {
				mrt_abort(m);
				t = m->ReopenTimer - now;
				if (*timeout > t)
					*timeout = t;
				continue;
			}
			if (m->ReopenTimerInterval != 0)
				m->ReopenTimer = now + m->ReopenTimerInterval;
			m->state = MRT_STATE_RUNNING;
			imsg_compose(m->ibuf, IMSG_MRT_REQ, 0,
			    &m->conf, sizeof(m->conf));
		}
		if (m->state == MRT_STATE_REOPEN) {
			if (mrt_close(m) == 0) {
				m->state = MRT_STATE_REOPEN;
				continue;
			}
			if (mrt_open(m) == 0) {
				mrt_abort(m);
				t = m->ReopenTimer - now;
				if (*timeout > t)
					*timeout = t;
				continue;
			}
			if (m->ReopenTimerInterval != 0)
				m->ReopenTimer = now + m->ReopenTimerInterval;
			m->state = MRT_STATE_RUNNING;
		}
		if (m->ReopenTimer != 0) {
			t = m->ReopenTimer - now;
			if (t <= 0 && (m->state == MRT_STATE_RUNNING ||
			    m->state == MRT_STATE_STOPPED)) {
				if (m->state == MRT_STATE_RUNNING) {
					/* reopen file */
					if (mrt_close(m) == 0) {
						m->state = MRT_STATE_REOPEN;
						continue;
					}
				}
				if (mrt_open(m) == 0) {
					mrt_abort(m);
					t = m->ReopenTimer - now;
					if (*timeout > t)
						*timeout = t;
					continue;
				}
				if (m->conf.type == MRT_TABLE_DUMP &&
				    m->state == MRT_STATE_STOPPED) {
					imsg_compose(mrt_imsgbuf[0],
					    IMSG_MRT_REQ, 0,
					    &m->conf, sizeof(m->conf));
				}

				m->state = MRT_STATE_RUNNING;
				if (m->ReopenTimerInterval != 0) {
					m->ReopenTimer = now +
					    m->ReopenTimerInterval;
					if (*timeout > m->ReopenTimerInterval)
						*timeout = t;
				}
			}
		}
		if (m->msgbuf.queued > 0) {
			if (m->msgbuf.fd == -1 ||
			    m->state == MRT_STATE_STOPPED) {
				log_warnx("mrt_select: orphaned buffer");
				mrt_abort(m);
				continue;
			}
			if (start < size) {
				pfd[start].fd = m->msgbuf.fd;
				pfd[start].events = POLLOUT;
				mrt[start++] = m;
			}
a467 1
	return (start);
d470 1
a470 1
int
d477 8
a484 13
	LIST_FOREACH(m, mrt, list) {
		if (m->state == MRT_STATE_RUNNING)
			m->state = MRT_STATE_REOPEN;
		if (m->conf.type == MRT_TABLE_DUMP) {
			if (m->state == MRT_STATE_STOPPED) {
				if (mrt_open(m) == 0) {
					mrt_abort(m);
					break;
				}
				imsg_compose(mrt_imsgbuf[0], IMSG_MRT_REQ, 0,
				    &m->conf, sizeof(m->conf));
				m->state = MRT_STATE_RUNNING;
			}
a485 2
		if (m->ReopenTimerInterval != 0)
			m->ReopenTimer = now + m->ReopenTimerInterval;
a486 1
	return (0);
d489 2
a490 4
static u_int32_t	 max_id = 1;

static struct mrt *
getconf(struct mrt_head *c, struct mrt *m)
d494 2
a495 2
	LIST_FOREACH(t, c, list) {
		if (t->conf.type != m->conf.type)
d497 5
a501 5
		if (t->conf.type == MRT_TABLE_DUMP)
			return t;
		if (t->conf.peer_id == m->conf.peer_id &&
		    t->conf.group_id == m->conf.group_id)
			return t;
d511 2
a512 2
	LIST_FOREACH(m, nconf, list)
		if ((xm = getconf(xconf, m)) == NULL) {
d514 1
a514 1
			if ((xm = calloc(1, sizeof(struct mrt))) == NULL)
d516 4
a519 5
			memcpy(xm, m, sizeof(struct mrt));
			msgbuf_init(&xm->msgbuf);
			xm->conf.id = max_id++;
			xm->state = MRT_STATE_OPEN;
			LIST_INSERT_HEAD(xconf, xm, list);
d522 3
a524 2
			if (strlcpy(xm->name, m->name, sizeof(xm->name)) >=
			    sizeof(xm->name))
d526 3
a528 2
			xm->ReopenTimerInterval = m->ReopenTimerInterval;
			xm->state = MRT_STATE_REOPEN;
d530 1
d532 2
a533 2
	LIST_FOREACH(xm, xconf, list)
		if (getconf(nconf, xm) == NULL)
d535 1
a535 1
			xm->state = MRT_STATE_TOREMOVE;
d539 1
a539 1
		LIST_REMOVE(m, list);
@


1.31
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.30 2004/04/29 19:56:04 deraadt Exp $ */
d240 1
d245 1
d260 1
a260 1
	DUMP_NLONG(buf, p->prefix->prefix.v4.s_addr);
@


1.30
log
@sock -> fd; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.29 2004/04/28 01:13:36 deraadt Exp $ */
d173 1
a173 1
	TAILQ_FOREACH(oa, &a->others, attr_l)
d224 1
a224 1
	TAILQ_FOREACH(oa, &a->others, attr_l) {
@


1.29
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.28 2004/02/27 20:53:56 claudio Exp $ */
d344 1
a344 1
		mrt->msgbuf.sock = -1;
d348 1
a348 1
	mrt->msgbuf.sock = open(mrt->file,
d350 1
a350 1
	if (mrt->msgbuf.sock == -1) {
d370 3
a372 3
	if (mrt->msgbuf.sock != -1) {
		close(mrt->msgbuf.sock);
		mrt->msgbuf.sock = -1;
d610 1
a610 1
			if (m->msgbuf.sock == -1 ||
d617 1
a617 1
				pfd[start].fd = m->msgbuf.sock;
@


1.28
log
@remove unneded peer pointer in struct prefix and change a in_addr_t to
struct in_addr. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.27 2004/02/25 19:48:18 claudio Exp $ */
d521 1
a521 1
					&m->conf, sizeof(m->conf));
d557 1
a557 1
					&m->conf, sizeof(m->conf));
@


1.27
log
@Rewrite some parts of the mrt dump handling. It is no longer possible to
dump the filtered updates but therefore it is now possible to dump per
neighbor and also to dump the outgoing messages. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.26 2004/02/19 13:54:58 claudio Exp $ */
d306 2
a307 1
		mrt_dump_entry(mrtbuf, p, sequencenum++, &p->peer->conf);
@


1.26
log
@Make the code more portable. Add some missing header files and make the use
of the queue(3) makros more portable. OK henning@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.25 2004/02/02 21:29:50 henning Exp $ */
d31 1
a31 1
#include "session.h"	/* needed for MSGSIZE_HEADER et al. */
a34 6
/*
 * XXX These functions break the imsg encapsulation.
 * XXX The imsg API is way to basic, we need something like
 * XXX imsg_create(), imsg_add(), imsg_close() ...
 */

d46 2
a47 3
		if (buf_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump1: buf_add error");		\
			buf_free((x));					\
d56 2
a57 3
		if (buf_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump2: buf_add error");		\
			buf_free((x));					\
d66 2
a67 3
		if (buf_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump3: buf_add error");		\
			buf_free((x));					\
d75 2
a76 3
		if (buf_add((x), &t, sizeof(t)) == -1) {		\
			log_warnx("mrt_dump4: buf_add error");		\
			buf_free((x));					\
d82 1
a82 1
mrt_dump_bgp_msg(struct mrt_config *mrt, void *pkg, u_int16_t pkglen, int type,
a85 2
	struct imsg_hdr	 hdr;
	int		 i, n;
d88 1
a88 1
	len = pkglen + MRT_BGP4MP_HEADER_SIZE + (type > 0 ? MSGSIZE_HEADER : 0);
d90 3
a92 11
	hdr.len = len + IMSG_HEADER_SIZE + MRT_HEADER_SIZE;
	hdr.type = IMSG_MRT_MSG;
	hdr.peerid = mrt->id;
	buf = buf_open(hdr.len);
	if (buf == NULL) {
		log_warnx("mrt_dump_bgp_msg: buf_open error");
		return (-1);
	}
	if (buf_add(buf, &hdr, sizeof(hdr)) == -1) {
		log_warnx("mrt_dump_bgp_msg: buf_add error");
		buf_free(buf);
d96 3
a98 3
	if (mrt_dump_header(buf, MSG_PROTOCOL_BGP4MP, BGP4MP_MESSAGE, len) ==
	    -1) {
		log_warnx("mrt_dump_bgp_msg: buf_add error");
d109 2
a110 11
	/* bgp header was chopped off so glue a new one together. */
	if (type > 0) {
		for (i = 0; i < MSGSIZE_HEADER_MARKER; i++)
			DUMP_BYTE(buf, 0xff);
		DUMP_SHORT(buf, pkglen + MSGSIZE_HEADER);
		DUMP_BYTE(buf, type);
	}

	if (buf_add(buf, pkg, pkglen) == -1) {
		log_warnx("mrt_dump_bgp_msg: buf_add error");
		buf_free(buf);
d114 2
a115 3
	if ((n = buf_close(mrt->msgbuf, buf)) < 0) {
		log_warnx("mrt_dump_bgp_msg: buf_close error");
		buf_free(buf);
d119 1
a119 1
	return (n);
a126 2
	struct imsg_hdr	 hdr;
	int		 n;
d130 4
a133 11
	hdr.len = len + IMSG_HEADER_SIZE + MRT_HEADER_SIZE;
	hdr.type = IMSG_MRT_MSG;
	hdr.peerid = mrt->id;
	buf = buf_open(hdr.len);
	if (buf == NULL) {
		log_warnx("mrt_dump_bgp_msg: buf_open error");
		return (-1);
	}
	if (buf_add(buf, &hdr, sizeof(hdr)) == -1) {
		log_warnx("mrt_dump_bgp_msg: buf_add error");
		buf_free(buf);
d139 1
a139 1
		log_warnx("mrt_dump_bgp_msg: buf_add error");
d153 2
a154 3
	if ((n = buf_close(mrt->msgbuf, buf)) < 0) {
		log_warnx("mrt_dump_bgp_msg: buf_close error");
		buf_free(buf);
d158 1
a158 2
	return (n);

a239 1
	struct imsg_hdr	 hdr;
a240 1
	int		 n;
d245 3
a247 11
	hdr.len = len + IMSG_HEADER_SIZE + MRT_HEADER_SIZE;
	hdr.type = IMSG_MRT_MSG;
	hdr.peerid = mrt->id;
	buf = buf_open(hdr.len);
	if (buf == NULL) {
		log_warnx("mrt_dump_entry: buf_open error");
		return (-1);
	}
	if (buf_add(buf, &hdr, sizeof(hdr)) == -1) {
		log_warnx("mrt_dump_entry: buf_add error");
		buf_free(buf);
d278 2
a279 3
	if ((n = buf_close(mrt->msgbuf, buf)) < 0) {
		log_warnx("mrt_dump_entry: buf_close error");
		buf_free(buf);
d283 1
a283 1
	return (n);
a533 1
			case MRT_FILTERED_IN:
d537 3
d662 1
a662 3
		if (t->conf.type == MRT_TABLE_DUMP ||
		    t->conf.type == MRT_ALL_IN ||
		    t->conf.type == MRT_FILTERED_IN)
d664 2
a665 1
		if (t->conf.peer_id == m->conf.peer_id)
d679 1
a679 2
			if ((xm = calloc(1, sizeof(struct mrt))) ==
			    NULL)
@


1.25
log
@* use macro expansion instead of hardcoding 'buf'.
From: Patrick Latifi <pat@@eyeo.org>, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.24 2004/01/27 16:49:53 henning Exp $ */
d568 1
a568 1
	for (m = LIST_FIRST(mc); m != LIST_END(mc); m = xm) {
d753 2
a754 2
	for (m = LIST_FIRST(nconf); m != LIST_END(nconf); m = xm) {
		xm = LIST_NEXT(m, list);
@


1.24
log
@use a struct bgpd_addr instead of sockaddr_in for peer_config->local_addr and
->remote_addr for easier multiprotocol support

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.23 2004/01/22 20:34:56 henning Exp $ */
d54 1
a54 1
			buf_free(buf);					\
d65 1
a65 1
			buf_free(buf);					\
d76 1
a76 1
			buf_free(buf);					\
d86 1
a86 1
			buf_free(buf);					\
@


1.23
log
@use log_warnx and log_info. reclassify a few messages in the process and fix
a few messages.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.22 2004/01/11 21:47:20 claudio Exp $ */
d126 2
a127 2
	DUMP_NLONG(buf, peer->local_addr.sin_addr.s_addr);
	DUMP_NLONG(buf, peer->remote_addr.sin_addr.s_addr);
d186 2
a187 2
	DUMP_NLONG(buf, peer->local_addr.sin_addr.s_addr);
	DUMP_NLONG(buf, peer->remote_addr.sin_addr.s_addr);
d313 1
a313 1
	DUMP_NLONG(buf, peer->remote_addr.sin_addr.s_addr);
@


1.22
log
@Move all struct in_addr to either struct bgpd_addr or in_addr_t whichever
is more appropriate. The rde uses now in most cases struct bgpd_addr.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.21 2004/01/11 01:00:07 claudio Exp $ */
d53 1
a53 1
			logit(LOG_ERR, "mrt_dump1: buf_add error");	\
d64 1
a64 1
			logit(LOG_ERR, "mrt_dump2: buf_add error");	\
d75 1
a75 1
			logit(LOG_ERR, "mrt_dump3: buf_add error");	\
d85 1
a85 1
			logit(LOG_ERR, "mrt_dump4: buf_add error");	\
d107 1
a107 1
		logit(LOG_ERR, "mrt_dump_bgp_msg: buf_open error");
d111 1
a111 1
		logit(LOG_ERR, "mrt_dump_bgp_msg: buf_add error");
d118 1
a118 1
		logit(LOG_ERR, "mrt_dump_bgp_msg: buf_add error");
d138 1
a138 1
		logit(LOG_ERR, "mrt_dump_bgp_msg: buf_add error");
d144 1
a144 1
		logit(LOG_ERR, "mrt_dump_bgp_msg: buf_close error");
d167 1
a167 1
		logit(LOG_ERR, "mrt_dump_bgp_msg: buf_open error");
d171 1
a171 1
		logit(LOG_ERR, "mrt_dump_bgp_msg: buf_add error");
d178 1
a178 1
		logit(LOG_ERR, "mrt_dump_bgp_msg: buf_add error");
d193 1
a193 1
		logit(LOG_ERR, "mrt_dump_bgp_msg: buf_close error");
d293 1
a293 1
		logit(LOG_ERR, "mrt_dump_entry: buf_open error");
d297 1
a297 1
		logit(LOG_ERR, "mrt_dump_entry: buf_add error");
d303 1
a303 1
		logit(LOG_ERR, "mrt_dump_bgp_msg: buf_add error");
d318 1
a318 1
		logit(LOG_ERR, "mrt_dump_entry: buf_reserve error");
d324 1
a324 1
		logit(LOG_ERR, "mrt_dump_entry: mrt_attr_dump error");
d330 1
a330 1
		logit(LOG_ERR, "mrt_dump_entry: buf_close error");
d394 1
a394 1
		logit(LOG_ERR, "mrt_open: strftime conversion failed");
d402 1
a402 1
		logit(LOG_ERR, "mrt_open %s: %s",
d505 1
a505 1
				logit(LOG_ERR, "mrt_write: mrt_close failed");
d513 1
a513 1
		logit(LOG_ERR, "mrt_write: msgbuf_write: %s",
d518 1
a518 1
		logit(LOG_ERR, "mrt_write: msgbuf_write: %s",
d527 1
a527 1
		logit(LOG_ERR, "mrt_write: mrt_close failed");
d661 1
a661 1
				logit(LOG_ERR, "mrt_select: orphaned buffer");
@


1.21
log
@The buffer changes produced some fallout in the mrt code.
Wait until all data has been written out before closing the file and fix
some obvious misstakes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.20 2004/01/10 16:20:29 claudio Exp $ */
d309 1
a309 1
	DUMP_NLONG(buf, p->prefix->prefix.s_addr);
@


1.20
log
@RDE update generation. First we queue all updates and withdraws on a per
peer basis. A queue runner will dequeue and package those messages to valid
bgp UPDATE messages and send them to the SE.
Not yet done is per peer type attribute handling (like aspath prepends and
nexthop modifications) and the queue runner could be a tad smarter. All in
all this gives us a good starting point for the missing parts.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.19 2004/01/07 12:34:23 claudio Exp $ */
d466 1
a466 6
			if (mrt_close(m) == 0) {
				m->state = MRT_STATE_CLOSE;
			} else {
				msgbuf_clear(&m->msgbuf);
				m->state = MRT_STATE_STOPPED;
			}
a492 1
	    mrt->state == MRT_STATE_CLOSE ||
d503 8
d528 1
a541 5
	case MRT_STATE_CLOSE:
		/* Close request: free all left buffers */
		msgbuf_clear(&mrt->msgbuf);
		mrt->state = MRT_STATE_STOPPED;
		return (0);
d665 1
a665 1
			if (start > size) {
d667 1
a667 1
				pfd[start].events |= POLLOUT;
@


1.19
log
@Duh. Fixing stupid braino. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.18 2004/01/06 21:48:07 claudio Exp $ */
d41 7
a47 4
static int	mrt_dump_entry(struct mrt_config *, struct prefix *, u_int16_t,
		    struct peer_config *);
static int	mrt_dump_header(struct buf *, u_int16_t, u_int16_t, u_int32_t);
static int	mrt_open(struct mrt *);
d202 73
d285 1
a285 1
	attr_len = attr_length(&p->aspath->flags);
d323 2
a324 2
	if (attr_dump(bptr, attr_len, &p->aspath->flags) == -1) {
		logit(LOG_ERR, "mrt_dump_entry: attr_dump error");
@


1.18
log
@Free buf on error and correct of by one in strlcpy.
From Patrick Latifi <pat at eyeo.org> OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.17 2004/01/06 10:51:14 claudio Exp $ */
d345 1
a345 1
	if (mrt->msgbuf.sock == -1) {
@


1.17
log
@2004 OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.16 2004/01/06 10:42:50 claudio Exp $ */
d51 1
d62 1
d73 1
d83 1
d109 1
d136 1
d142 1
d169 1
d191 1
d222 1
d243 1
d249 1
d255 1
d666 1
a666 1
			if (strlcpy(xm->name, m->name, sizeof(xm->name)) >
@


1.16
log
@Fix reopening of dump files.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.15 2004/01/05 22:57:58 claudio Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Claudio Jeker <claudio@@openbsd.org>
@


1.15
log
@Big overhaul of the mrt code.
Dumping of incomming bgp messages is now possible and dumping the (not yet)
filtered updates works too. Per neighbor dumps are still missing.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.14 2004/01/01 21:18:13 henning Exp $ */
d513 1
d515 2
d521 16
d553 1
d555 7
d596 2
d605 1
a605 1
						&m->conf, sizeof(m->conf));
a608 2
		if (m->state == MRT_STATE_RUNNING)
			m->state = MRT_STATE_REOPEN;
@


1.14
log
@conf -> mconf
causes a conflicht with upcoming changes
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.13 2003/12/26 18:07:32 henning Exp $ */
d41 1
a41 1
static int	mrt_dump_entry(struct mrt *, struct prefix *, u_int16_t,
d43 2
a44 2
static void	mrt_dump_header(struct buf *, u_int16_t, u_int16_t, u_int32_t);
static int	mrt_open(struct mrtdump_config *);
d49 4
a52 2
		if (buf_add((x), &t, sizeof(t)) == -1)			\
			fatalx("buf_add error");			\
d59 4
a62 2
		if (buf_add((x), &t, sizeof(t)) == -1)			\
			fatalx("buf_add error");			\
d69 4
a72 2
		if (buf_add((x), &t, sizeof(t)) == -1)			\
			fatalx("buf_add error");			\
d78 4
a81 2
		if (buf_add((x), &t, sizeof(t)) == -1)			\
			fatalx("buf_add error");			\
d85 1
a85 1
mrt_dump_bgp_msg(struct mrt *mrt, void *pkg, u_int16_t pkglen, int type,
d93 1
a93 1
	len = pkglen + MRT_BGP4MP_HEADER_SIZE + type > 0 ? MSGSIZE_HEADER : 0;
d99 8
a106 4
	if (buf == NULL)
		fatal("mrt_dump_bgp_msg");
	if (buf_add(buf, &hdr, sizeof(hdr)) == -1)
		fatalx("buf_add error");
d108 5
a112 1
	mrt_dump_header(buf, MSG_PROTOCOL_BGP4MP, BGP4MP_MESSAGE, len);
d129 51
a179 2
	if (buf_add(buf, pkg, pkglen) == -1)
		fatalx("buf_add error");
d181 4
a184 2
	if ((n = buf_close(mrt->msgbuf, buf)) < 0)
		fatalx("buf_close error");
d187 1
d191 1
a191 1
mrt_dump_entry(struct mrt *mrt, struct prefix *p, u_int16_t snum,
d207 8
a214 4
	if (buf == NULL)
		fatal("mrt_dump_entry");
	if (buf_add(buf, &hdr, sizeof(hdr)) == -1)
		fatalx("buf_add error");
d216 4
a219 1
	mrt_dump_header(buf, MSG_TABLE_DUMP, AFI_IPv4, len);
d225 1
a225 1
	DUMP_BYTE(buf, 1);
d231 4
a234 2
	if ((bptr = buf_reserve(buf, attr_len)) == NULL)
		fatalx("buf_reserve error");
d236 4
a239 2
	if (attr_dump(bptr, attr_len, &p->aspath->flags) == -1)
		fatalx("attr_dump error");
d241 4
a244 2
	if ((n = buf_close(mrt->msgbuf, buf)) < 0)
		fatalx("buf_close error");
d260 2
a261 2
	struct mrt	*mrtbuf = ptr;
	struct prefix	*p;
d272 1
a272 1
static void
a275 1
	struct mrt_header	mrt;
d280 9
a288 4
	mrt.timestamp = htonl(now);
	mrt.type = ntohs(type);
	mrt.subtype = ntohs(subtype);
	mrt.length = htonl(len);
d290 5
a294 2
	if (buf_add(buf, &mrt, sizeof(mrt)) == -1)
		fatalx("buf_add error");
d298 1
a298 1
mrt_open(struct mrtdump_config *mconf)
d303 1
a303 1
	if (strftime(mconf->file, sizeof(mconf->file), mconf->name,
d305 3
a307 3
		logit(LOG_CRIT, "mrt_open strftime failed");
		mconf->msgbuf.sock = -1;
		return -1;
d310 1
a310 1
	mconf->msgbuf.sock = open(mconf->file,
d312 7
a318 3
	if (mconf->msgbuf.sock == -1)
		logit(LOG_CRIT, "mrt_open %s: %s",
		    mconf->file, strerror(errno));
d320 36
a355 1
	return mconf->msgbuf.sock;
d359 1
a359 2
mrt_state(struct mrtdump_config *m, enum imsg_type type,
    struct imsgbuf *buf)
d361 13
a373 9
	switch (m->state) {
	case MRT_STATE_DONE:
		/* no dump expected */
		return (0);
	case MRT_STATE_CLOSE:
		switch (type) {
		case IMSG_NONE:
			if (m->type == MRT_TABLE_DUMP)
				imsg_compose(buf, IMSG_MRT_END, m->id, NULL, 0);
d375 8
a382 5
		case IMSG_MRT_END:
			/* dump no longer valid */
			close(m->msgbuf.sock);
			LIST_REMOVE(m, list);
			free(m);
a383 2
		default:
			break;
d385 33
d419 36
d456 2
a457 4
		switch (type) {
		case IMSG_NONE:
			if (m->type == MRT_TABLE_DUMP)
				imsg_compose(buf, IMSG_MRT_END, m->id, NULL, 0);
d459 5
a463 9
		case IMSG_MRT_END:
			if (m->msgbuf.sock != -1)
				close(m->msgbuf.sock);
			m->state = MRT_STATE_OPEN;
			if (m->type == MRT_TABLE_DUMP)
				imsg_compose(buf, IMSG_MRT_REQ, m->id, NULL, 0);
			return (0);
		default:
			break;
d466 1
a466 22
	case MRT_STATE_OPEN:
		switch (type) {
		case IMSG_NONE:
			if (m->type == MRT_TABLE_DUMP)
				imsg_compose(buf, IMSG_MRT_REQ, m->id, NULL, 0);
			return (0);
		case IMSG_MRT_MSG:
			mrt_open(m);
			m->state = MRT_STATE_RUNNING;
			break;
		default:
			return (0);
		}
		break;
	case MRT_STATE_RUNNING:
		if (type == IMSG_MRT_END) {
			if (m->msgbuf.sock != -1)
				close(m->msgbuf.sock);
			m->msgbuf.sock = -1;
			m->state = MRT_STATE_DONE;
			return (0);
		}
d473 2
a474 1
mrt_usr1(struct mrt_config *mconf, struct imsgbuf *buf)
d476 3
a478 3
	struct mrtdump_config	*m;
	time_t			 now;
	int			 interval = INT_MAX;
d481 20
a500 5
	LIST_FOREACH(m, mconf, list) {
		if (m->type == MRT_TABLE_DUMP) {
			switch (m->state) {
			case MRT_STATE_REOPEN:
			case MRT_STATE_CLOSE:
d502 2
a503 3
			case MRT_STATE_DONE:
				m->state = MRT_STATE_OPEN;
				imsg_compose(buf, IMSG_MRT_REQ, m->id, NULL, 0);
d506 49
a554 3
				m->state = MRT_STATE_REOPEN;
				imsg_compose(buf, IMSG_MRT_END, m->id, NULL, 0);
				break;
a555 2

			m->ReopenTimer = now + m->ReopenTimerInterval;
a556 2
		if (m->ReopenTimer - now < interval)
			interval = m->ReopenTimer - now;
d558 1
a558 5

	if (interval != INT_MAX)
		alarm(interval);

	return (0);
d562 1
a562 1
mrt_alrm(struct mrt_config *mconf, struct imsgbuf *buf)
d564 2
a565 3
	struct mrtdump_config	*m;
	time_t			 now;
	int			 interval = INT_MAX;
d568 10
a577 20
	LIST_FOREACH(m, mconf, list) {
		if (m->ReopenTimerInterval == 0)
			continue;
		if (m->ReopenTimer <= now) {
			switch (m->state) {
			case MRT_STATE_REOPEN:
			case MRT_STATE_CLOSE:
				break;
			case MRT_STATE_DONE:
				m->state = MRT_STATE_OPEN;
				if (m->type == MRT_TABLE_DUMP)
					imsg_compose(buf, IMSG_MRT_REQ, m->id,
					    NULL, 0);
				break;
			default:
				m->state = MRT_STATE_REOPEN;
				if (m->type == MRT_TABLE_DUMP)
					imsg_compose(buf, IMSG_MRT_END, m->id,
					    NULL, 0);
				break;
d579 4
a582 1

a583 3
		}
		if (m->ReopenTimer - now < interval)
			interval = m->ReopenTimer - now;
a584 4

	if (interval != INT_MAX)
		alarm(interval);

d590 2
a591 2
static struct mrtdump_config *
getconf(struct mrt_config *c, struct mrtdump_config *m)
d593 10
a602 3
	struct mrtdump_config	*t;
	LIST_FOREACH(t, c, list)
		if (t->type == m->type)
d604 1
d609 1
a609 1
mrt_mergeconfig(struct mrt_config *xconf, struct mrt_config *nconf)
d611 1
a611 3
	struct mrtdump_config	*m, *xm;
	time_t			 now;
	int			 interval = INT_MAX;
a612 1
	now = time(NULL);
d616 1
a616 1
			if ((xm = calloc(1, sizeof(struct mrtdump_config))) ==
d619 4
a622 8
			memcpy(xm, m, sizeof(struct mrtdump_config));
			xm->id = max_id++;
			if (xm->ReopenTimerInterval != 0) {
				xm->ReopenTimer = now + xm->ReopenTimerInterval;
				interval = xm->ReopenTimerInterval < interval ?
				    xm->ReopenTimerInterval : interval;
			}
			xm->state=MRT_STATE_OPEN;
d630 1
a630 6
			if (xm->ReopenTimerInterval != 0) {
				xm->ReopenTimer = now + xm->ReopenTimerInterval;
				interval = xm->ReopenTimerInterval < interval ?
				    xm->ReopenTimerInterval : interval;
			}
			xm->state=MRT_STATE_REOPEN;
d632 1
d636 1
a636 1
			xm->state = MRT_STATE_CLOSE;
a642 3

	if (interval != INT_MAX)
		alarm(interval);
@


1.13
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.12 2003/12/26 00:34:01 claudio Exp $ */
d210 1
a210 1
mrt_open(struct mrtdump_config *conf)
d215 1
a215 1
	if (strftime(conf->file, sizeof(conf->file), conf->name,
d218 1
a218 1
		conf->msgbuf.sock = -1;
d222 1
a222 1
	conf->msgbuf.sock = open(conf->file,
d224 1
a224 1
	if (conf->msgbuf.sock == -1)
d226 1
a226 1
		    conf->file, strerror(errno));
d228 1
a228 1
	return conf->msgbuf.sock;
d300 1
a300 1
mrt_usr1(struct mrt_config *conf, struct imsgbuf *buf)
d307 1
a307 1
	LIST_FOREACH(m, conf, list) {
d336 1
a336 1
mrt_alrm(struct mrt_config *conf, struct imsgbuf *buf)
d343 1
a343 1
	LIST_FOREACH(m, conf, list) {
d390 1
a390 1
mrt_mergeconfig(struct mrt_config *xconf, struct mrt_config *conf)
d397 1
a397 1
	LIST_FOREACH(m, conf, list)
d426 1
a426 1
		if (getconf(conf, xm) == NULL)
d431 1
a431 1
	for (m = LIST_FIRST(conf); m != LIST_END(conf); m = xm) {
@


1.12
log
@In the mrt state machine one state was forgotten. This caused the parent
process to quit it a fatal buf_close error message.
Noticed and reported by jakob@@
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.11 2003/12/25 17:35:53 henning Exp $ */
d50 1
a50 1
			fatal("buf_add error", 0);			\
d58 1
a58 1
			fatal("buf_add error", 0);			\
d66 1
a66 1
			fatal("buf_add error", 0);			\
d73 1
a73 1
			fatal("buf_add error", 0);			\
d92 1
a92 1
		fatal("mrt_dump_bgp_msg", errno);
d94 1
a94 1
		fatal("buf_add error", 0);
d114 1
a114 1
		fatal("buf_add error", 0);
d117 1
a117 1
		fatal("buf_close error", 0);
d140 1
a140 1
		fatal("mrt_dump_entry", errno);
d142 1
a142 1
		fatal("buf_add error", 0);
d157 1
a157 1
		fatal("buf_reserve error", 0);
d160 1
a160 1
		fatal("attr_dump error", 0);
d163 1
a163 1
		fatal("buf_close error", 0);
d206 1
a206 1
		fatal("buf_add error", 0);
d402 1
a402 1
				fatal("mrt_mergeconfig", errno);
d416 1
a416 1
				fatal("mrt_mergeconfig: strlcpy", 0);
@


1.11
log
@free where it was allocated; much easier to verify
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.10 2003/12/24 13:28:02 henning Exp $ */
d286 8
a293 1
	default:
@


1.10
log
@handle write() returning 0 correctly, adjust the msgbuf API appropriately,
and make all callers cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.9 2003/12/23 19:14:49 deraadt Exp $ */
a427 1
	free(conf);
@


1.9
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.8 2003/12/21 23:26:37 henning Exp $ */
d116 1
a116 1
	if ((n = buf_close(mrt->msgbuf, buf)) == -1)
d162 1
a162 1
	if ((n = buf_close(mrt->msgbuf, buf)) == -1)
@


1.8
log
@wrap read & write buffers for imsgs into a struct.
finally gives us read buffers per pipe instead of per process, eleminating
a possible race.
also gets us a real imsg_init() that does all the boring init work
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.7 2003/12/21 22:16:53 henning Exp $ */
d154 1
a154 1
	DUMP_SHORT(buf,  attr_len);
@


1.7
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.6 2003/12/21 16:11:33 claudio Exp $ */
d233 1
a233 1
    struct msgbuf *rde /*, struct msgbuf *se */)
d243 1
a243 1
				imsg_compose(rde, IMSG_MRT_END, m->id, NULL, 0);
d259 1
a259 1
				imsg_compose(rde, IMSG_MRT_END, m->id, NULL, 0);
d266 1
a266 1
				imsg_compose(rde, IMSG_MRT_REQ, m->id, NULL, 0);
d276 1
a276 1
				imsg_compose(rde, IMSG_MRT_REQ, m->id, NULL, 0);
d293 1
a293 1
mrt_usr1(struct mrt_config *conf, struct msgbuf *rde /*, struct msgbuf *se */)
d308 1
a308 1
				imsg_compose(rde, IMSG_MRT_REQ, m->id, NULL, 0);
d312 1
a312 1
				imsg_compose(rde, IMSG_MRT_END, m->id, NULL, 0);
d329 1
a329 1
mrt_alrm(struct mrt_config *conf, struct msgbuf *rde /*, struct msgbuf *se */)
d347 1
a347 1
					imsg_compose(rde, IMSG_MRT_REQ, m->id,
d353 1
a353 1
					imsg_compose(rde, IMSG_MRT_END, m->id,
@


1.6
log
@yet more from the castathon; most aspath functions where accessing non-
aligned memory (u_int16_t) therefor crashed the RDE on my sparc64. All
buffer specific functions use now void * instead of u_char * so most cast
are now history. Tested on sparc64 and i386. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.5 2003/12/20 21:43:45 claudio Exp $ */
d41 2
a42 2
static int	mrt_dump_entry(int, struct prefix *, u_int16_t,
		    struct peer_config *, u_int32_t);
d77 1
a77 1
mrt_dump_bgp_msg(int fd, u_char *pkg, u_int16_t pkglen, int type,
d89 2
a90 2
	hdr.peerid = peer->id;
	buf = buf_open(NULL, fd, hdr.len);
d116 1
a116 1
	if ((n = buf_close(buf)) == -1)
d123 2
a124 2
mrt_dump_entry(int fd, struct prefix *p, u_int16_t snum,
    struct peer_config *peer, u_int32_t id)
d137 2
a138 2
	hdr.peerid = id;
	buf = buf_open(NULL, fd, hdr.len);
d162 1
a162 1
	if ((n = buf_close(buf)) == -1)
d177 1
a177 1
mrt_dump_upcall(struct pt_entry *pt, int fd, int *wait, void *arg)
d179 1
a180 2
	u_int32_t	*idp = arg;
	u_int32_t	 id = *idp;
d188 1
a188 1
	    *wait += mrt_dump_entry(fd, p, sequencenum++, &p->peer->conf, id);
d218 1
a218 1
		conf->fd = -1;
d222 3
a224 2
	conf->fd = open(conf->file, O_WRONLY|O_NONBLOCK|O_CREAT|O_TRUNC, 0644);
	if (conf->fd == -1)
d228 1
a228 1
	return conf->fd;
d233 1
a233 1
    int rfd, int *rwait /*, int sfd, int *swait */)
d243 1
a243 2
				*rwait += imsg_compose(rfd, IMSG_MRT_END,
				    m->id, NULL, 0);
d247 1
a247 1
			close(m->fd);
d259 1
a259 2
				*rwait += imsg_compose(rfd, IMSG_MRT_END,
				    m->id, NULL, 0);
d262 2
a263 2
			if (m->fd != -1)
				close(m->fd);
d266 1
a266 2
				*rwait += imsg_compose(rfd, IMSG_MRT_REQ,
				    m->id, NULL, 0);
d276 1
a276 2
				*rwait += imsg_compose(rfd, IMSG_MRT_REQ,
				    m->id, NULL, 0);
d293 1
a293 2
mrt_usr1(struct mrt_config *conf, int rfd, int *rwait
    /*, int sfd, int *swait */)
d308 1
a308 2
				*rwait += imsg_compose(rfd, IMSG_MRT_REQ,
				    m->id, NULL, 0);
d312 1
a312 2
				*rwait += imsg_compose(rfd, IMSG_MRT_END,
				    m->id, NULL, 0);
d329 1
a329 2
mrt_alrm(struct mrt_config *conf, int rfd, int *rwait
    /*, int sfd, int *swait */)
d347 2
a348 2
					*rwait += imsg_compose(rfd,
					    IMSG_MRT_REQ, m->id, NULL, 0);
d353 2
a354 2
					*rwait += imsg_compose(rfd,
					    IMSG_MRT_END, m->id, NULL, 0);
@


1.5
log
@knf. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.4 2003/12/20 21:14:55 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Claudio Jeker <cjeker@@diehard.n-r-g.com>
a45 1
/* XXX breaks buf encapsulation */
d47 5
a51 1
	(x)->buf[buf->wpos++] = (b)
d85 1
a85 1
	len = pkglen + MRT_BGP4MP_HEADER_SIZE + type>0?MSGSIZE_HEADER:0;
d127 1
a127 1
	u_char		*s;
d156 1
a156 1
	if ((s = buf_reserve(buf, attr_len)) == NULL)
d159 1
a159 1
	if (attr_dump(s, attr_len, &p->aspath->flags) == -1)
@


1.4
log
@let buf_add take void *data instead of u_char *data and save a zillion
evil casts
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.3 2003/12/20 20:53:30 henning Exp $ */
d310 2
a311 2
				*rwait += imsg_compose(rfd,
				    IMSG_MRT_REQ, m->id, NULL, 0);
d315 2
a316 2
				*rwait += imsg_compose(rfd,
				    IMSG_MRT_END, m->id, NULL, 0);
@


1.3
log
@few missing break; in default: cases in switch; one noticed by tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.2 2003/12/19 01:15:47 deraadt Exp $ */
d54 1
a54 1
		if (buf_add((x), (u_char *)&t, sizeof(t)) == -1)	\
d62 1
a62 1
		if (buf_add((x), (u_char *)&t, sizeof(t)) == -1)	\
d69 1
a69 1
		if (buf_add((x), (u_char *)&t, sizeof(t)) == -1)	\
d90 1
a90 1
	if (buf_add(buf, (u_char *)&hdr, sizeof(hdr)) == -1)
d138 1
a138 1
	if (buf_add(buf, (u_char *)&hdr, sizeof(hdr)) == -1)
d203 1
a203 1
	if (buf_add(buf, (u_char *)&mrt, sizeof(mrt)) == -1)
@


1.2
log
@knf & 64-bit cleanup; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.c,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d250 1
d269 1
d288 1
d360 1
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d177 2
a178 1
	u_int32_t	 id = (u_int32_t)(u_long)arg;
@

