head	1.66;
access;
symbols
	OPENBSD_6_0:1.62.0.20
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.14
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.62.0.16
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.62.0.8
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.62.0.12
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.62.0.10
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.62.0.6
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.62.0.4
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.62.0.2
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.8
	OPENBSD_5_0:1.60.0.6
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.60.0.4
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.60.0.2
	OPENBSD_4_8_BASE:1.60
	OPENBSD_4_7:1.59.0.2
	OPENBSD_4_7_BASE:1.59
	OPENBSD_4_6:1.58.0.4
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.51.0.4
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.51.0.2
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.49.0.2
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.47.0.6
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.47.0.4
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.47.0.2
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33;
locks; strict;
comment	@ * @;


1.66
date	2017.01.25.00.15.38;	author claudio;	state Exp;
branches;
next	1.65;
commitid	njwYsyFBZe4riTmC;

1.65
date	2017.01.24.23.38.12;	author claudio;	state Exp;
branches;
next	1.64;
commitid	o0u4P0zRnQoELo6o;

1.64
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.63;
commitid	airB1W2Kb948lFil;

1.63
date	2017.01.23.22.47.59;	author claudio;	state Exp;
branches;
next	1.62;
commitid	pnGdVXq8GJLI0bC2;

1.62
date	2012.07.04.20.43.26;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2012.04.12.17.31.05;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.06.08.53.11;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.29.14.10.13;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.06.01.07.01;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.06.01.02.51;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.01.21.20.17;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2009.05.21.15.47.03;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2009.05.17.12.25.15;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2009.04.23.19.23.27;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2008.05.08.09.51.46;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2008.05.02.13.53.19;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.27.01.13.54;	author claudio;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2007.05.11.11.27.59;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.24.12.52.11;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2006.01.14.22.39.49;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.13.13.04.33;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.04.12.50.31;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.29.21.11.07;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2005.08.09.20.27.25;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.12.14.32.01;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.11.10.35.15;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2004.09.16.04.29.54;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.06.12.04.08;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.05.18.44.19;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.28.17.10.15;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.22.23.17.01;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.26.00.46.52;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.11.14.22.23;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.01.16.02.01;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.27.20.53.56;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.26.15.46.30;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.26.14.00.33;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.17.14.22.40;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.04.09.07.44;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.01.19.46.05;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.27.16.49.53;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.22.20.34.56;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.18.00.44.44;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.17.19.35.36;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.13.17.11.29;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.13.16.15.37;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.13.13.45.50;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.13.13.18.03;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.13.12.38.50;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.12.13.33.16;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.11.21.47.20;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.11.02.39.05;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.10.22.25.42;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.10.16.20.29;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.07.00.01.17;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.06.10.51.14;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.05.22.33.49;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.26.22.41.01;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.26.19.28.52;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.26.18.07.33;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.24.11.39.43;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.23.18.52.46;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.23.15.59.02;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;

1.49.2.1
date	2008.05.09.08.22.10;	author henning;	state Exp;
branches;
next	;


desc
@@


1.66
log
@Switch rde_generate_update and rde_send_kroute to accept a struct rib instead
of the id. For this we move the rtableid into struct rib. Also move the update
code in rib.c up to where the kroute code is. Makes more senses like that.
@
text
@/*	$OpenBSD: rde_decide.c,v 1.65 2017/01/24 23:38:12 claudio Exp $ */

/*
 * Copyright (c) 2003, 2004 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <string.h>

#include "bgpd.h"
#include "rde.h"
#include "log.h"

int	prefix_cmp(struct prefix *, struct prefix *);
/*
 * Decision Engine RFC implementation:
 *  Phase 1:
 *   - calculate LOCAL_PREF if needed -- EBGP or IGP learnt routes
 *   - IBGP routes may either use LOCAL_PREF or the local system computes
 *     the degree of preference
 *   - If the route is ineligible, the route MAY NOT serve as an input to
 *     the next phase of route selection
 *   - if the route is eligible the computed value MUST be used as the
 *     LOCAL_PREF value in any IBGP readvertisement
 *
 *  Phase 2:
 *   - If the NEXT_HOP attribute of a BGP route depicts an address that is
 *     not resolvable the BGP route MUST be excluded from the Phase 2 decision
 *     function.
 *   - If the AS_PATH attribute of a BGP route contains an AS loop, the BGP
 *     route should be excluded from the Phase 2 decision function.
 *   - The local BGP speaker identifies the route that has:
 *     a) the highest degree of preference of any route to the same set
 *        of destinations
 *     b) is the only route to that destination
 *     c) is selected as a result of the Phase 2 tie breaking rules
 *   - The local speaker MUST determine the immediate next-hop address from
 *     the NEXT_HOP attribute of the selected route.
 *   - If either the immediate next hop or the IGP cost to the NEXT_HOP changes,
 *     Phase 2 Route Selection MUST be performed again.
 *
 *  Route Resolvability Condition
 *   - A route Rte1, referencing only the intermediate network address, is
 *     considered resolvable if the Routing Table contains at least one
 *     resolvable route Rte2 that matches Rte1's intermediate network address
 *     and is not recursively resolved through Rte1.
 *   - Routes referencing interfaces are considered resolvable if the state of
 *     the referenced interface is up and IP processing is enabled.
 *
 *  Breaking Ties (Phase 2)
 *   1. Remove from consideration all routes which are not tied for having the
 *      smallest number of AS numbers present in their AS_PATH attributes.
 *      Note, that when counting this number, an AS_SET counts as 1
 *   2. Remove from consideration all routes which are not tied for having the
 *      lowest Origin number in their Origin attribute.
 *   3. Remove from consideration routes with less-preferred MULTI_EXIT_DISC
 *      attributes. MULTI_EXIT_DISC is only comparable between routes learned
 *      from the same neighboring AS.
 *   4. If at least one of the candidate routes was received via EBGP,
 *      remove from consideration all routes which were received via IBGP.
 *   5. Remove from consideration any routes with less-preferred interior cost.
 *      If the NEXT_HOP hop for a route is reachable, but no cost can be
 *      determined, then this step should be skipped.
 *   6. Remove from consideration all routes other than the route that was
 *      advertised by the BGP speaker whose BGP Identifier has the lowest value.
 *   7. Prefer the route received from the lowest peer address.
 *
 * Phase 3: Route Dissemination
 *   - All routes in the Loc-RIB are processed into Adj-RIBs-Out according
 *     to configured policy. A route SHALL NOT be installed in the Adj-Rib-Out
 *     unless the destination and NEXT_HOP described by this route may be
 *     forwarded appropriately by the Routing Table.
 */

/*
 * Decision Engine OUR implementation:
 * Our implementation has only one RIB. The filtering is done first. The
 * filtering calculates the preference and stores it in LOCAL_PREF (Phase 1).
 * Ineligible routes are flagged as ineligible via nexthop_add().
 * Phase 3 is done together with Phase 2.
 * In following cases a prefix needs to be reevaluated:
 *  - update of a prefix (path_update)
 *  - withdraw of a prefix (prefix_remove)
 *  - state change of the nexthop (nexthop-{in}validate)
 *  - state change of session (session down)
 */

/*
 * Compare two prefixes with equal pt_entry. Returns an integer greater than or
 * less than 0, according to whether the prefix p1 is more or less preferred
 * than the prefix p2. p1 should be used for the new prefix and p2 for a
 * already added prefix.
 */
int
prefix_cmp(struct prefix *p1, struct prefix *p2)
{
	struct rde_aspath	*asp1, *asp2;
	struct attr		*a;
	u_int32_t		 p1id, p2id;
	int			 p1cnt, p2cnt;

	if (p1 == NULL)
		return (-1);
	if (p2 == NULL)
		return (1);

	asp1 = p1->aspath;
	asp2 = p2->aspath;

	/* pathes with errors are not eligible */
	if (asp1->flags & F_ATTR_PARSE_ERR)
		return (-1);
	if (asp2->flags & F_ATTR_PARSE_ERR)
		return (1);

	/* only loop free pathes are eligible */
	if (asp1->flags & F_ATTR_LOOP)
		return (-1);
	if (asp2->flags & F_ATTR_LOOP)
		return (1);

	/* 1. check if prefix is eligible a.k.a reachable */
	if (asp2->nexthop != NULL && asp2->nexthop->state != NEXTHOP_REACH)
		return (1);
	if (asp1->nexthop != NULL && asp1->nexthop->state != NEXTHOP_REACH)
		return (-1);

	/* 2. local preference of prefix, bigger is better */
	if ((asp1->lpref - asp2->lpref) != 0)
		return (asp1->lpref - asp2->lpref);

	/* 3. aspath count, the shorter the better */
	if ((asp2->aspath->ascnt - asp1->aspath->ascnt) != 0)
		return (asp2->aspath->ascnt - asp1->aspath->ascnt);

	/* 4. origin, the lower the better */
	if ((asp2->origin - asp1->origin) != 0)
		return (asp2->origin - asp1->origin);

	/* 5. MED decision, only comparable between the same neighboring AS */
	if (rde_decisionflags() & BGPD_FLAG_DECISION_MED_ALWAYS ||
	    aspath_neighbor(asp1->aspath) == aspath_neighbor(asp2->aspath))
		/* lowest value wins */
		if ((asp2->med - asp1->med) != 0)
			return (asp2->med - asp1->med);

	/*
	 * 6. EBGP is cooler than IBGP
	 * It is absolutely important that the ebgp value in peer_config.ebgp
	 * is bigger than all other ones (IBGP, confederations)
	 */
	if (asp1->peer->conf.ebgp != asp2->peer->conf.ebgp) {
		if (asp1->peer->conf.ebgp) /* p1 is EBGP other is lower */
			return 1;
		else if (asp2->peer->conf.ebgp) /* p2 is EBGP */
			return -1;
	}

	/*
	 * 7. local tie-breaker, this weight is here to tip equal long AS
	 * paths in one or the other direction. It happens more and more
	 * that AS paths are equally long and so traffic engineering needs
	 * a metric that weights a prefix at a very late stage in the
	 * decision process.
	 */
	if ((asp1->weight - asp2->weight) != 0)
		return (asp1->weight - asp2->weight);

	/* 8. nexthop costs. NOT YET -> IGNORE */

	/*
	 * 9. older route (more stable) wins but only if route-age
	 * evaluation is enabled.
	 */
	if (rde_decisionflags() & BGPD_FLAG_DECISION_ROUTEAGE)
		if ((p2->lastchange - p1->lastchange) != 0)
			return (p2->lastchange - p1->lastchange);

	/* 10. lowest BGP Id wins, use ORIGINATOR_ID if present */
	if ((a = attr_optget(asp1, ATTR_ORIGINATOR_ID)) != NULL) {
		memcpy(&p1id, a->data, sizeof(p1id));
		p1id = ntohl(p1id);
	} else
		p1id = asp1->peer->remote_bgpid;
	if ((a = attr_optget(asp2, ATTR_ORIGINATOR_ID)) != NULL) {
		memcpy(&p2id, a->data, sizeof(p2id));
		p2id = ntohl(p2id);
	} else
		p2id = asp2->peer->remote_bgpid;
	if ((p2id - p1id) != 0)
		return (p2id - p1id);

	/* 11. compare CLUSTER_LIST length, shorter is better */
	p1cnt = p2cnt = 0;
	if ((a = attr_optget(asp1, ATTR_CLUSTER_LIST)) != NULL)
		p1cnt = a->len / sizeof(u_int32_t);
	if ((a = attr_optget(asp2, ATTR_CLUSTER_LIST)) != NULL)
		p2cnt = a->len / sizeof(u_int32_t);
	if ((p2cnt - p1cnt) != 0)
		return (p2cnt - p1cnt);

	/* 12. lowest peer address wins (IPv4 is better than IPv6) */
	if (memcmp(&p1->aspath->peer->remote_addr,
	    &p2->aspath->peer->remote_addr,
	    sizeof(p1->aspath->peer->remote_addr)) != 0)
		return (-memcmp(&p1->aspath->peer->remote_addr,
		    &p2->aspath->peer->remote_addr,
		    sizeof(p1->aspath->peer->remote_addr)));

	/* 13. for announced prefixes prefer dynamic routes */
	if ((asp1->flags & F_ANN_DYNAMIC) != (asp2->flags & F_ANN_DYNAMIC)) {
		if (asp1->flags & F_ANN_DYNAMIC)
			return (1);
		else
			return (-1);
	}

	fatalx("Uh, oh a politician in the decision process");
	/* NOTREACHED */
}

/*
 * Find the correct place to insert the prefix in the prefix list.
 * If the active prefix has changed we need to send an update.
 * The to evaluate prefix must not be in the prefix list.
 */
void
prefix_evaluate(struct prefix *p, struct rib_entry *re)
{
	struct prefix	*xp;

	if (re_rib(re)->flags & F_RIB_NOEVALUATE || rde_noevaluate()) {
		/* decision process is turned off */
		if (p != NULL)
			LIST_INSERT_HEAD(&re->prefix_h, p, rib_l);
		if (re->active != NULL) {
			re->active->aspath->active_cnt--;
			re->active = NULL;
		}
		return;
	}

	if (p != NULL) {
		if (LIST_EMPTY(&re->prefix_h))
			LIST_INSERT_HEAD(&re->prefix_h, p, rib_l);
		else {
			LIST_FOREACH(xp, &re->prefix_h, rib_l)
				if (prefix_cmp(p, xp) > 0) {
					LIST_INSERT_BEFORE(xp, p, rib_l);
					break;
				} else if (LIST_NEXT(xp, rib_l) == NULL) {
					/* if xp last element ... */
					LIST_INSERT_AFTER(xp, p, rib_l);
					break;
				}
		}
	}

	xp = LIST_FIRST(&re->prefix_h);
	if (xp == NULL || xp->aspath->flags & (F_ATTR_LOOP|F_ATTR_PARSE_ERR) ||
	    (xp->aspath->nexthop != NULL &&
	    xp->aspath->nexthop->state != NEXTHOP_REACH))
		/* xp is ineligible */
		xp = NULL;

	if (re->active != xp) {
		/* need to generate an update */
		if (re->active != NULL)
			re->active->aspath->active_cnt--;

		/*
		 * Send update with remove for re->active and add for xp
		 * but remember that xp may be NULL aka ineligible.
		 * Additional decision may be made by the called functions.
		 */
		rde_generate_updates(re_rib(re), xp, re->active);
		if ((re_rib(re)->flags & F_RIB_NOFIB) == 0)
			rde_send_kroute(re_rib(re), xp, re->active);

		re->active = xp;
		if (xp != NULL)
			xp->aspath->active_cnt++;
	}
}
@


1.65
log
@Save some space in struct rib_entry so it is back to 64bytes (on 64bit archs).
Doing this by folding the lock flag into a pointer and providing an accessor
function for the rib pointer. This is an acceptable middle path for this
important structure.
OK benno@@ on an earlier version
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.64 2017/01/24 04:22:42 benno Exp $ */
d291 1
a291 1
		rde_generate_updates(re_rib(re)->id, xp, re->active);
d293 1
a293 1
			rde_send_kroute(xp, re->active, re_rib(re)->id);
@


1.64
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.63 2017/01/23 22:47:59 claudio Exp $ */
d247 1
a247 1
	if (re->flags & F_RIB_NOEVALUATE || rde_noevaluate()) {
d291 3
a293 3
		rde_generate_updates(re->rib->id, xp, re->active);
		if ((re->flags & F_RIB_NOFIB) == 0)
			rde_send_kroute(xp, re->active, re->rib->id);
@


1.63
log
@Introduce a struct rib sitting between struct rib_desc and struct rib_tree.
This way the tree becomes a bit better decoupled.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.62 2012/07/04 20:43:26 claudio Exp $ */
d27 1
@


1.62
log
@Seems like I missed to adjust the route decision code to cover the things
that need to be checked because of route reflection. Do this now and reference
the new RR RFC in the man page. OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.61 2012/04/12 17:31:05 claudio Exp $ */
d290 1
a290 1
		rde_generate_updates(re->ribid, xp, re->active);
d292 1
a292 1
			rde_send_kroute(xp, re->active, re->ribid);
@


1.61
log
@The ebgp flags is just a truth value and it is better to not == 1 compares.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.60 2010/05/03 13:09:38 claudio Exp $ */
d112 3
d193 22
a214 5
	/* 10. lowest BGP Id wins */
	if ((p2->aspath->peer->remote_bgpid -
	    p1->aspath->peer->remote_bgpid) != 0)
		return (p2->aspath->peer->remote_bgpid -
		    p1->aspath->peer->remote_bgpid);
d216 1
a216 1
	/* 11. lowest peer address wins (IPv4 is better than IPv6) */
d224 1
a224 1
	/* 12. for announced prefixes prefer dynamic routes */
@


1.60
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.59 2009/08/06 08:53:11 claudio Exp $ */
d139 1
a139 1
	/* 2. preference of prefix, bigger is better */
d163 2
a164 2
	if ((asp1->peer->conf.ebgp - asp2->peer->conf.ebgp) != 0) {
		if (asp1->peer->conf.ebgp == 1) /* p1 is EBGP other is lower */
d166 1
a166 1
		else if (asp2->peer->conf.ebgp == 1) /* p2 is EBGP */
@


1.59
log
@Implement the error handling as proposed in draft-ietf-idr-optional-transitive
for optional transitive attributes. In short if the partial bit is set on
an optional transitive attribute but the attribute fails validation ignore
the attribute or mark the path as ineligible instead of killing the session
with a NOTIFICATION. Tested, input and OK sthen, OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.58 2009/06/29 14:10:13 claudio Exp $ */
d272 1
a272 1
			rde_send_kroute(xp, re->active);
@


1.58
log
@Doh! Fix logic botch that disconnected the FIB from the Loc-RIB instead of
making sure that other RIBs are not injecting routes into the FIB.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.57 2009/06/06 01:07:01 claudio Exp $ */
d121 6
d254 1
a254 1
	if (xp == NULL || xp->aspath->flags & F_ATTR_LOOP ||
@


1.57
log
@Only the main Loc-RIB should update the FIB for now. So introduce a
F_RIB_NOFIB flag and apply it on all RIBs that are not F_RIB_NOEVALUATE.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.56 2009/06/06 01:02:51 claudio Exp $ */
d265 1
a265 1
		if (re->flags & F_RIB_NOFIB)
@


1.56
log
@Only generate updates for peers that are member of the RIB that update is
comming from.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.55 2009/06/01 21:20:17 claudio Exp $ */
d265 2
a266 1
		rde_send_kroute(xp, re->active);
@


1.55
log
@Instead of storing a pointer to the RIB head in the RIB element use that
space for a flags field and the RIB id. In the end bgpd will be able to
lock RIB elements and therefore make it possible to interrupt all tree
walks.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.54 2009/05/21 15:47:03 claudio Exp $ */
d264 1
a264 1
		rde_generate_updates(xp, re->active);
@


1.54
log
@Make it possible to turn off the decision process per RIB. This is mainly
used for the Adj-Rib-In. Also initialize the Adj-Rib-In correctly and mark
it a noevaluate.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.53 2009/05/17 12:25:15 claudio Exp $ */
d220 1
a220 1
	if (re->rib->noevaluate || rde_noevaluate()) {
@


1.53
log
@Rework most of the RDE to allow multiple RIBs. This is mostly preparation
work by changing the way the RDE DB is built. struct prefix and struct
pt_entry are simplified and extended with a rib_entry where the decision
tree is run on. From now on a prefix can only reside on one particular RIB
which simplifies the code a bit. Currently there are two fixed ribs
(adj-rib-in and the local-rib) which needs to be made more dynamic in
upcomming commits.
This is work in progress, the RDE seems to work for me and sthen@@ (no flames
comming out of our testrouters but there is still a lot missing)
Move into the tree to simplify developement -- henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.52 2009/04/23 19:23:27 claudio Exp $ */
d220 1
a220 8
	/* XXX we need to skip the adj-rib-in somehow */
	/* XXX hack for now, no idea why we end up here. */
	if (!re) {
		log_debug("*BOOM*");
		return;
	}

	if (rde_noevaluate()) {
@


1.52
log
@Rework the way we handle announced networks. Instead of two freak rde_peers
use one that is less freaky. Merge bgpctl and config networks into one tree.
First step of a larger change in the RDE and this goes now in to allow to
move forward.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.51 2008/05/08 09:51:46 henning Exp $ */
a117 6
	/* only prefixes in the Local-RIB are eligible */
	if (!(p1->flags & F_LOCAL))
		return (-1);
	if (!(p2->flags & F_LOCAL))
		return (1);

d199 2
a200 2
	if ((p1->flags & F_ANN_DYNAMIC) != (p2->flags & F_ANN_DYNAMIC)) {
		if (p1->flags & F_ANN_DYNAMIC)
d216 1
a216 1
prefix_evaluate(struct prefix *p, struct pt_entry *pte)
d220 7
d230 4
a233 4
			LIST_INSERT_HEAD(&pte->prefix_h, p, prefix_l);
		if (pte->active != NULL) {
			pte->active->aspath->active_cnt--;
			pte->active = NULL;
d239 2
a240 2
		if (LIST_EMPTY(&pte->prefix_h))
			LIST_INSERT_HEAD(&pte->prefix_h, p, prefix_l);
d242 1
a242 1
			LIST_FOREACH(xp, &pte->prefix_h, prefix_l)
d244 1
a244 1
					LIST_INSERT_BEFORE(xp, p, prefix_l);
d246 1
a246 1
				} else if (LIST_NEXT(xp, prefix_l) == NULL) {
d248 1
a248 1
					LIST_INSERT_AFTER(xp, p, prefix_l);
d254 2
a255 3
	xp = LIST_FIRST(&pte->prefix_h);
	if (xp == NULL || !(xp->flags & F_LOCAL) ||
	    xp->aspath->flags & F_ATTR_LOOP ||
d261 1
a261 1
	if (pte->active != xp) {
d263 2
a264 2
		if (pte->active != NULL)
			pte->active->aspath->active_cnt--;
d267 1
a267 1
		 * Send update with remove for pte->active and add for xp
d271 2
a272 2
		rde_generate_updates(xp, pte->active);
		rde_send_kroute(xp, pte->active);
d274 1
a274 1
		pte->active = xp;
@


1.51
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.50 2008/05/02 13:53:19 claudio Exp $ */
d204 8
a213 1
	return (0);
@


1.50
log
@Compare flags against the right flag field or else unexpected things may
happen. The decision process failed to correctly mask looping pathes and
in some szenarios even elected them as best route. *gulp*
Found the hard way and fix tested by Christian, bsd (at) cleondra (dot) ch
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.49 2007/11/27 01:13:54 claudio Exp $ */
d123 1
a123 1
 
@


1.49
log
@Prefixes or actually pathes that would cause a rooting loops should not be
dropped when parsed but instead be added to the RIB marked as not eligible.
So the decision process does not pick them up as a valid route.
Tested and some ideas by Tony Sarendal (tony (at) polarcap (dot) org)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.48 2007/05/11 11:27:59 claudio Exp $ */
d124 3
d128 1
a128 1
	if (p1->flags & F_ATTR_LOOP)
d130 1
a130 1
	if (p2->flags & F_ATTR_LOOP)
a131 3

	asp1 = p1->aspath;
	asp2 = p2->aspath;
@


1.49.2.1
log
@MFC (claudio)
Compare flags against the right flag field or else unexpected things may
happen. The decision process failed to correctly mask looping pathes and
in some szenarios even elected them as best route. *gulp*
Found the hard way and fix tested by Christian, bsd (at) cleondra (dot) ch
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.50 2008/05/02 13:53:19 claudio Exp $ */
a123 3
	asp1 = p1->aspath;
	asp2 = p2->aspath;

d125 1
a125 1
	if (asp1->flags & F_ATTR_LOOP)
d127 1
a127 1
	if (asp2->flags & F_ATTR_LOOP)
d129 3
@


1.48
log
@Various spelling fixes from Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.47 2006/01/24 12:52:11 claudio Exp $ */
d123 6
d248 3
a250 2
	    (xp->aspath->nexthop != NULL && xp->aspath->nexthop->state !=
	    NEXTHOP_REACH))
@


1.47
log
@Update comment to match reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.46 2006/01/14 22:39:49 claudio Exp $ */
d118 1
a118 1
	/* only prefix in the Local-RIB are eligible */
d166 2
a167 2
	 * pathes in one or the other direction. It happens more and more
	 * that AS pathes are equally long and so traffic engineering needs
@


1.46
log
@Small step in supporting the Adj-RIB-In additionaly to the Local-RIB.
First step is to define two flags F_LOCAL and F_ORIGINAL. These flags
are used to distinguish prefix in the Local-RIB and those in the Adj-
RIB-In. Adapt prefix API and add additional checks so that no Adj-RIB-
In prefixes get mistakenly selected. Currently no F_ORIGINAL prefixes
are created but this may change soon. Looks good Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.45 2006/01/13 13:04:33 claudio Exp $ */
d254 2
a255 4
		 * but remember that xp may be ineligible or NULL.
		 * Do not send an update if the only available path
		 * has an unreachable nexthop. This decision has to be made
		 * by the called functions.
@


1.45
log
@Simplify evaluation process. Instead of checking the reachability of a prefix
at many different places do it once. This simplifies the logic and makes it
easier to extend it for upcomming Adj-RIB-In addition. OK Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.44 2006/01/04 12:50:31 claudio Exp $ */
d118 6
d241 3
a243 2
	if (xp == NULL || (xp->aspath->nexthop != NULL &&
	    xp->aspath->nexthop->state != NEXTHOP_REACH))
@


1.44
log
@If the decision process is turned of but a prefix is still active decrease the
active prefix counter.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.43 2005/11/29 21:11:07 claudio Exp $ */
d233 1
d235 5
d255 3
a257 7
		if (xp == NULL || (xp->aspath->nexthop != NULL &&
		    xp->aspath->nexthop->state != NEXTHOP_REACH))
			pte->active = NULL;
		else {
			pte->active = xp;
			pte->active->aspath->active_cnt++;
		}
@


1.43
log
@Add a flags field to struct prefix which will be used shortly. Remove the peer
pointer so that the size does not grow. Adding 4 bytes to struct prefix would
result in 64MB more memory usage on one of my systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.42 2005/08/09 20:27:25 claudio Exp $ */
d211 2
a212 1
		if (pte->active != NULL)
d214 1
@


1.42
log
@Introduce new route decision tunable "rde med compare (always|strict)".
If set to always the med will also be compared between different AS.
The default is strict which is the way the RFC specifies it.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.41 2005/04/12 14:32:01 claudio Exp $ */
d179 4
a182 2
	if ((p2->peer->remote_bgpid - p1->peer->remote_bgpid) != 0)
		return (p2->peer->remote_bgpid - p1->peer->remote_bgpid);
d185 6
a190 4
	if (memcmp(&p1->peer->remote_addr, &p2->peer->remote_addr,
	    sizeof(p1->peer->remote_addr)) != 0)
		return (-memcmp(&p1->peer->remote_addr, &p2->peer->remote_addr,
		    sizeof(p1->peer->remote_addr)));
@


1.41
log
@Introduce a per prefix weight.  The weight is used to tip prefixes with equal
long AS pathes in one or the other direction.  It weights a prefix at a very
late stage in the decision process. This is a nice bgpd feature to traffic
engineer networks where most AS pathes are equally long.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.40 2004/11/11 10:35:15 claudio Exp $ */
d140 2
a141 1
	if (aspath_neighbor(asp1->aspath) == aspath_neighbor(asp2->aspath))
@


1.40
log
@New config statement "rde route-age [evaluate|ignore]". If set to evaluate
the best path selection will not only be based on the path attributes but
also on the age of the prefix. This is an extension to the RFC. The default
is ignore but previously it was implicitly set to evaluate.
OK henning@@ man page OK jaredy@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.39 2004/09/16 04:29:54 henning Exp $ */
d157 11
a167 1
	/* 7. nexthop costs. NOT YET -> IGNORE */
d170 1
a170 1
	 * 8. older route (more stable) wins but only if route-age
d177 1
a177 1
	/* 9. lowest BGP Id wins */
d181 1
a181 1
	/* 10. lowest peer address wins (IPv4 is better than IPv6) */
@


1.39
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.38 2004/08/06 12:04:08 claudio Exp $ */
d159 7
a165 3
	/* 8. older route (more stable) wins */
	if ((p2->lastchange - p1->lastchange) != 0)
		return (p2->lastchange - p1->lastchange);
@


1.38
log
@Monster diff to get one step closer to IPv6 support.
Cleanup path attribute handling. First of all kill struct attr_flags, all
those infos are now in struct rde_aspath. Second move attribute parser
functions into rde.c, rde_attr.c is shared between bgpd and bgpctl.
Third reimplementation of the nexthop handling. Make it IPv6 ready and
fix some major bug relating to "set nexthop".
henning@@ OK if it breaks nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.37 2004/08/05 18:44:19 claudio Exp $ */
a99 1
 *
d175 1
a175 1
	return 0;
@


1.37
log
@Cleanup aspath specific functions and api. Mainly switch to a refcnt based
allocation. This helps to save a bit of RAM. looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.36 2004/07/28 17:10:15 claudio Exp $ */
a115 2

	/* p2 is allowed to be NULL */
d123 1
a123 1
	if (asp2->nexthop->state != NEXTHOP_REACH)
d125 1
a125 1
	if (asp1->nexthop->state != NEXTHOP_REACH)
d129 2
a130 2
	if ((asp1->flags.lpref - asp2->flags.lpref) != 0)
		return (asp1->flags.lpref - asp2->flags.lpref);
d133 2
a134 4
	if ((asp2->flags.aspath->ascnt -
	    asp1->flags.aspath->ascnt) != 0)
		return (asp2->flags.aspath->ascnt -
		    asp1->flags.aspath->ascnt);
d137 2
a138 2
	if ((asp2->flags.origin - asp1->flags.origin) != 0)
		return (asp2->flags.origin - asp1->flags.origin);
d141 1
a141 2
	if (aspath_neighbor(asp1->flags.aspath) ==
	    aspath_neighbor(asp2->flags.aspath))
d143 2
a144 2
		if ((asp2->flags.med - asp1->flags.med) != 0)
			return (asp2->flags.med - asp1->flags.med);
d229 2
a230 2
		if (xp == NULL || xp->aspath->nexthop == NULL ||
		    xp->aspath->nexthop->state != NEXTHOP_REACH)
@


1.36
log
@Prefer the path with the lowest multi-exit discriminator (MED) not the biggest.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.35 2004/06/22 23:17:01 claudio Exp $ */
d135 4
a138 4
	if ((asp2->flags.aspath->hdr.as_cnt -
	    asp1->flags.aspath->hdr.as_cnt) != 0)
		return (asp2->flags.aspath->hdr.as_cnt -
		    asp1->flags.aspath->hdr.as_cnt);
@


1.35
log
@Cleanup. jajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.34 2004/04/26 00:46:52 claudio Exp $ */
d123 1
a124 1

d147 3
a149 3
		/* the bigger, the better */
		if ((asp1->flags.med - asp2->flags.med) != 0)
			return (asp1->flags.med - asp2->flags.med);
@


1.34
log
@Cleanup the decision function and take the age of the entry into account.
Prefer older, more stable entries. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.33 2004/03/11 14:22:23 claudio Exp $ */
a25 1
#include "ensure.h"
d114 2
a115 1
	ENSURE(p1 != NULL);
a123 1
	ENSURE(asp2->nexthop != NULL && asp1->nexthop != NULL);
d221 1
a221 3
		if (pte->active != NULL) {
			ENSURE(pte->active->aspath != NULL);
			ENSURE(pte->active->aspath->active_cnt > 0);
a222 1
		}
a239 2
			ENSURE(pte->active->aspath->active_cnt <=
			    pte->active->aspath->prefix_cnt);
@


1.33
log
@Shutdown the RDE cleanly on exit. Plug some memleaks. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.32 2004/03/01 16:02:01 claudio Exp $ */
d166 13
a178 12
	/* 8. lowest BGP Id wins */
	if ((asp2->peer->remote_bgpid - asp1->peer->remote_bgpid) != 0)
		return (asp2->peer->remote_bgpid - asp1->peer->remote_bgpid);

	/* 9. lowest peer address wins */
	if (memcmp(&asp1->peer->conf.remote_addr,
	    &asp2->peer->conf.remote_addr,
	    sizeof(asp1->peer->conf.remote_addr)) != 0)
		return (memcmp(&asp1->peer->conf.remote_addr,
		    &asp2->peer->conf.remote_addr,
		    sizeof(asp1->peer->conf.remote_addr)));

@


1.32
log
@Make it possible to diable the decision process. This is a feature only useful
for route-collectors. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.31 2004/02/27 20:53:56 claudio Exp $ */
d198 2
a199 1
		ENSURE(pte->active == NULL);
@


1.31
log
@remove unneded peer pointer in struct prefix and change a in_addr_t to
struct in_addr. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.30 2004/02/26 15:46:30 claudio Exp $ */
d193 8
@


1.30
log
@Clean up comments and replace a if with a ENSURE because NULL nexthops are
illegal. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.29 2004/02/26 14:00:33 claudio Exp $ */
d157 2
a158 2
	if ((p1->peer->conf.ebgp - p2->peer->conf.ebgp) != 0) {
		if (p1->peer->conf.ebgp == 1) /* p1 is EBGP other is lower */
d160 1
a160 1
		else if (p2->peer->conf.ebgp == 1) /* p2 is EBGP */
d167 2
a168 2
	if ((p2->peer->remote_bgpid - p1->peer->remote_bgpid) != 0)
		return (p2->peer->remote_bgpid - p1->peer->remote_bgpid);
d171 6
a176 6
	if (memcmp(&p1->peer->conf.remote_addr,
	    &p2->peer->conf.remote_addr,
	    sizeof(p1->peer->conf.remote_addr)) != 0)
		return (memcmp(&p1->peer->conf.remote_addr,
		    &p2->peer->conf.remote_addr,
		    sizeof(p1->peer->conf.remote_addr)));
@


1.29
log
@Implement "enforce neighbor-as yes|no" which is by default on for ebgp
neighbors. While doing that check also that the nexthop is valid (not class D
or E and not in 127/8 range). Kill some TODO and XXX and rename the british
neighbour to neighbor as used everywhere else. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.28 2004/02/17 14:22:40 claudio Exp $ */
d94 2
a95 4
 * Ineligible routes are flagged as ineligible via nexthop_add(). The flags
 * are inherited from the nexthop descriptor.
 * Phase 3 is done together with Phase 2 -- the output filtering is done in
 * the session engine.
d124 2
a125 4
	if (asp2->nexthop == NULL)
		return (1);
	if (asp1->nexthop == NULL)
		return (-1);
@


1.28
log
@Make sure that we add the new prefix to the prefix list or bad things will
happen. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.27 2004/02/04 09:07:44 claudio Exp $ */
d150 2
a151 2
	if (aspath_neighbour(asp1->flags.aspath) ==
	    aspath_neighbour(asp2->flags.aspath))
@


1.27
log
@Move the update generation into a separate file. The update generation has
nothing to do with the decision process. henning@@ "conceptual ok ;-)"
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.26 2004/02/01 19:46:05 claudio Exp $ */
d205 4
@


1.26
log
@Set sane default announce types according to the peer type. For IBGP use
announce all and for EBGP use announce self. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.25 2004/01/27 16:49:53 henning Exp $ */
a22 1
#include <stdlib.h>
a27 1
#include "session.h"
a29 4
int	up_generate_attr(struct rde_peer *, struct update_attr *,
	    struct attr_flags *, struct nexthop *);
int	up_set_prefix(u_char *, int, struct bgpd_addr *, u_int8_t);

a237 498
}


/* update stuff. */
struct update_prefix {
	struct bgpd_addr		 prefix;
	int				 prefixlen;
	struct uplist_prefix		*prefix_h;
	TAILQ_ENTRY(update_prefix)	 prefix_l;
	RB_ENTRY(update_prefix)		 entry;
};

struct update_attr {
	u_long				 attr_hash;
	u_char				*attr;
	u_int16_t			 attr_len;
	struct uplist_prefix		 prefix_h;
	TAILQ_ENTRY(update_attr)	 attr_l;
	RB_ENTRY(update_attr)		 entry;
};

int	up_prefix_cmp(struct update_prefix *, struct update_prefix *);
int	up_attr_cmp(struct update_attr *, struct update_attr *);
int	up_add(struct rde_peer *, struct update_prefix *, struct update_attr *);

RB_PROTOTYPE(uptree_prefix, update_prefix, entry, up_prefix_cmp);
RB_GENERATE(uptree_prefix, update_prefix, entry, up_prefix_cmp);

RB_PROTOTYPE(uptree_attr, update_attr, entry, up_attr_cmp);
RB_GENERATE(uptree_attr, update_attr, entry, up_attr_cmp);

void
up_init(struct rde_peer *peer)
{
	TAILQ_INIT(&peer->updates);
	TAILQ_INIT(&peer->withdraws);
	RB_INIT(&peer->up_prefix);
	RB_INIT(&peer->up_attrs);
	peer->up_pcnt = 0;
	peer->up_acnt = 0;
	peer->up_nlricnt = 0;
	peer->up_wcnt = 0;
}

void
up_down(struct rde_peer *peer)
{
	struct update_attr	*ua, *xua;
	struct update_prefix	*up, *xup;

	for (ua = TAILQ_FIRST(&peer->updates); ua != TAILQ_END(&peer->updates);
	    ua = xua) {
		xua = TAILQ_NEXT(ua, attr_l);
		for (up = TAILQ_FIRST(&ua->prefix_h);
		    up != TAILQ_END(&ua->prefix_h); up = xup) {
			xup = TAILQ_NEXT(up, prefix_l);
			free(up);
		}
		free(ua);
	}

	for (up = TAILQ_FIRST(&peer->withdraws);
	    up != TAILQ_END(&peer->withdraws); up = xup) {
		xup = TAILQ_NEXT(up, prefix_l);
		free(up);
	}

	TAILQ_INIT(&peer->updates);
	TAILQ_INIT(&peer->withdraws);
	RB_INIT(&peer->up_prefix);
	RB_INIT(&peer->up_attrs);

	peer->up_pcnt = 0;
	peer->up_acnt = 0;
	peer->up_nlricnt = 0;
	peer->up_wcnt = 0;
}

int
up_prefix_cmp(struct update_prefix *a, struct update_prefix *b)
{
	ENSURE(a->prefix.af == AF_INET);

	if (a->prefix.v4.s_addr < b->prefix.v4.s_addr)
		return (-1);
	if (a->prefix.v4.s_addr > b->prefix.v4.s_addr)
		return (1);
	if (a->prefixlen < b->prefixlen)
		return (-1);
	if (a->prefixlen > b->prefixlen)
		return (1);
	return (0);
}

int
up_attr_cmp(struct update_attr *a, struct update_attr *b)
{
	if (a->attr_hash < b->attr_hash)
		return (-1);
	if (a->attr_hash > b->attr_hash)
		return (1);
	if (a->attr_len < b->attr_len)
		return (-1);
	if (a->attr_len > b->attr_len)
		return (1);
	return memcmp(a->attr, b->attr, a->attr_len);
}

int
up_add(struct rde_peer *peer, struct update_prefix *p, struct update_attr *a)
{
	struct update_attr	*na;
	struct update_prefix	*np;

	ENSURE(p != NULL);

	/* 1. search for attr */
	if (a != NULL && (na = RB_FIND(uptree_attr, &peer->up_attrs, a)) ==
	    NULL) {
		/* 1.1 if not found -> add */
		TAILQ_INIT(&a->prefix_h);
		if (RB_INSERT(uptree_attr, &peer->up_attrs, a) != NULL) {
			log_warnx("uptree_attr insert failed");
			return (-1);
		}
		TAILQ_INSERT_TAIL(&peer->updates, a, attr_l);
		peer->up_acnt++;
	} else {
		/* 1.2 if found -> use that, free a */
		if (a != NULL) {
			free(a);
			a = na;
			/* move to end of update queue */
			TAILQ_REMOVE(&peer->updates, a, attr_l);
			TAILQ_INSERT_TAIL(&peer->updates, a, attr_l);
		}
	}

	/* 2. search for prefix */
	if ((np = RB_FIND(uptree_prefix, &peer->up_prefix, p)) == NULL) {
		/* 2.1 if not found -> add */
		if (RB_INSERT(uptree_prefix, &peer->up_prefix, p) != NULL) {
			log_warnx("uptree_prefix insert failed");
			return (-1);
		}
		peer->up_pcnt++;
	} else {
		/* 2.2 if found -> use that and free p */
		TAILQ_REMOVE(np->prefix_h, np, prefix_l);
		free(p);
		p = np;
		if (p->prefix_h == &peer->withdraws)
			peer->up_wcnt--;
		else
			peer->up_nlricnt--;
	}
	/* 3. link prefix to attr */
	if (a == NULL) {
		TAILQ_INSERT_TAIL(&peer->withdraws, p, prefix_l);
		p->prefix_h = &peer->withdraws;
		peer->up_wcnt++;
	} else {
		TAILQ_INSERT_TAIL(&a->prefix_h, p, prefix_l);
		p->prefix_h = &a->prefix_h;
		peer->up_nlricnt++;
	}
	return (0);
}

void
up_generate_updates(struct rde_peer *peer,
    struct prefix *new, struct prefix *old)
{
	struct update_attr		*a;
	struct update_prefix		*p;

	ENSURE(peer->state == PEER_UP);
	/*
	 * Filtering should be hooked up here.
	 * With filtering the decision if withdraw, update or nothing
	 * needs to be done on a per peer basis -- acctually per filter
	 * set.
	 */

	if (new == NULL || new->aspath->nexthop == NULL ||
	    new->aspath->nexthop->state != NEXTHOP_REACH) {
		if (peer == old->peer)
			/* Do not send routes back to sender */
			return;

		if (peer->conf.ebgp == 0 && old->peer->conf.ebgp == 0)
			/* Do not redistribute updates to ibgp peers */
			return;

		/* announce type handling */
		switch (peer->conf.announce_type) {
		case ANNOUNCE_UNDEF:
		case ANNOUNCE_NONE:
			return;
		case ANNOUNCE_ALL:
			break;
		case ANNOUNCE_SELF:
			/*
			 * pass only prefix that have a aspath count
			 * of zero this is equal to the ^$ regex.
			 */
			if (old->aspath->flags.aspath->hdr.as_cnt != 0)
				return;
			break;
		}

		/* withdraw prefix */
		p = calloc(1, sizeof(struct update_prefix));
		if (p == NULL)
			fatal("up_queue_update");

		p->prefix = old->prefix->prefix;
		p->prefixlen = old->prefix->prefixlen;
		if (up_add(peer, p, NULL) == -1)
			log_warnx("queuing update failed.");
	} else {
		if (peer == new->peer)
			/* Do not send routes back to sender */
			return;

		if (peer->conf.ebgp == 0 && new->peer->conf.ebgp == 0)
			/* Do not redistribute updates to ibgp peers */
			return;

		/* announce type handling */
		switch (peer->conf.announce_type) {
		case ANNOUNCE_UNDEF:
		case ANNOUNCE_NONE:
			return;
		case ANNOUNCE_ALL:
			break;
		case ANNOUNCE_SELF:
			/*
			 * pass only prefix that have a aspath count
			 * of zero this is equal to the ^$ regex.
			 */
			if (new->aspath->flags.aspath->hdr.as_cnt != 0)
				return;
			break;
		}

		/* generate update */
		p = calloc(1, sizeof(struct update_prefix));
		if (p == NULL)
			fatal("up_queue_update");

		a = calloc(1, sizeof(struct update_attr));
		if (a == NULL)
			fatal("up_queue_update");

		if (up_generate_attr(peer, a, &new->aspath->flags,
		    new->aspath->nexthop) == -1)
			log_warnx("generation of bgp path attributes failed");

		/*
		 * use aspath_hash as attr_hash, this may be unoptimal
		 * but currently I don't care.
		 */
		a->attr_hash = aspath_hash(new->aspath->flags.aspath);
		p->prefix = new->prefix->prefix;
		p->prefixlen = new->prefix->prefixlen;

		if (up_add(peer, p, a) == -1)
			log_warnx("queuing update failed.");
	}
}

u_char	up_attr_buf[4096];

int
up_generate_attr(struct rde_peer *peer, struct update_attr *upa,
    struct attr_flags *a, struct nexthop *nh)
{
	struct attr	*oa;
	u_int32_t	 tmp32;
	in_addr_t	 nexthop, mask;
	int		 r;
	u_int16_t	 len = sizeof(up_attr_buf), wlen = 0;

	/* origin */
	if ((r = attr_write(up_attr_buf + wlen, len, ATTR_WELL_KNOWN,
	    ATTR_ORIGIN, &a->origin, 1)) == -1)
		return (-1);
	wlen += r; len -= r;

	/* aspath */
	if ((r = aspath_write(up_attr_buf + wlen, len, a->aspath,
	    rde_local_as(), peer->conf.ebgp == 0 ? 0 : 1)) == -1)
		return (-1);
	wlen += r; len -= r;

	/* nexthop, already network byte order */
	if (peer->conf.ebgp == 0) {
		/*
		 * if directly connected use peer->local_addr
		 */
		if (nh->flags & NEXTHOP_ANNOUNCE)
			nexthop = peer->local_addr.v4.s_addr;
		else if (a->nexthop == peer->remote_addr.v4.s_addr)
			/*
			 * per rfc: if remote peer address is equal to
			 * the nexthop set the nexthop to our local address.
			 * This reduces the risk of routing loops.
			 */
			nexthop = peer->local_addr.v4.s_addr;
		else
			nexthop = nh->exit_nexthop.v4.s_addr;
	} else if (peer->conf.distance == 1) {
		/* ebgp directly connected */
		if (nh->flags & NEXTHOP_CONNECTED) {
			mask = 0xffffffff << (32 - nh->nexthop_netlen);
			mask = htonl(mask);
			if ((peer->remote_addr.v4.s_addr & mask) ==
			    (nh->nexthop_net.v4.s_addr & mask))
				/* nexthop and peer are in the same net */
				nexthop = nh->exit_nexthop.v4.s_addr;
			else
				nexthop = peer->local_addr.v4.s_addr;
		} else
			nexthop = peer->local_addr.v4.s_addr;
	} else
		/* ebgp multihop */
		/*
		 * XXX for ebgp multihop nh->flags should never have
		 * NEXTHOP_CONNECTED set so it should be possible to unify the
		 * two ebgp cases.
		 */
		nexthop = peer->local_addr.v4.s_addr;

	if ((r = attr_write(up_attr_buf + wlen, len, ATTR_WELL_KNOWN,
	    ATTR_NEXTHOP, &nexthop, 4)) == -1)
		return (-1);
	wlen += r; len -= r;

	/*
	 * The MED of other peers MUST not be announced to others.
	 * Currently we just dump it. Possibilities are setting the MED via
	 * a filter or set it to local-pref. struct attr_flags probably needs
	 * a med_in and a med_out field.
	 */

	if (peer->conf.ebgp == 0) {
		/* local preference, only valid for ibgp */
		tmp32 = htonl(a->lpref);
		if ((r = attr_write(up_attr_buf + wlen, len, ATTR_WELL_KNOWN,
		    ATTR_LOCALPREF, &tmp32, 4)) == -1)
			return (-1);
		wlen += r; len -= r;
	}

	/*
	 * dump all other path attributes. Following rules apply:
	 *  1. well-known attrs: ATTR_ATOMIC_AGGREGATE and ATTR_AGGREGATOR
	 *     pass unmodified (enforce flags to correct values)
	 *  2. non-transitive attrs: don't re-announce
	 *  3. transitive known attrs: announce unmodified
	 *  4. transitive unknown attrs: set partial bit and re-announce
	 */
	TAILQ_FOREACH(oa, &a->others, attr_l) {
		switch (oa->type) {
		case ATTR_ATOMIC_AGGREGATE:
			if ((r = attr_write(up_attr_buf + wlen, len,
			    ATTR_WELL_KNOWN, ATTR_ATOMIC_AGGREGATE,
			    NULL, 0)) == -1)
				return (-1);
			break;
		case ATTR_AGGREGATOR:
			if ((r = attr_write(up_attr_buf + wlen, len,
			    ATTR_OPTIONAL | ATTR_TRANSITIVE, ATTR_AGGREGATOR,
			    oa->data, oa->len)) == -1)
				return (-1);
			break;
		/*
		 * currently there are no non-transitive or transitive known
		 * attributes.
		 */
		default:
			/* unknown attribute */
			if (!(oa->flags & ATTR_OPTIONAL))
				/* somehow a non-transitive slipped through */
				break;
			if ((r = attr_write(up_attr_buf + wlen, len,
			    oa->flags | ATTR_PARTIAL, oa->type,
			    oa->data, oa->len)) == -1)
				return (-1);
			break;
		}
		wlen += r; len -= r;
	}

	/* the bgp path attributes are now stored in the global buf */
	upa->attr = malloc(wlen);
	if (upa->attr == NULL)
		fatal("up_generate_attr");
	memcpy(upa->attr, up_attr_buf, wlen);
	upa->attr_len = wlen;
	return (wlen);
}

int
up_set_prefix(u_char *buf, int len, struct bgpd_addr *prefix, u_int8_t plen)
{
	int	totlen;

	ENSURE(prefix->af == AF_INET);
	ENSURE(plen <= 32);
	totlen = (plen + 7) / 8 + 1;

	if (totlen > len)
		return (-1);
	*buf++ = plen;
	memcpy(buf, &prefix->v4.s_addr, totlen - 1);
	return (totlen);
}

int
up_dump_prefix(u_char *buf, int len, struct uplist_prefix *prefix_head,
    struct rde_peer *peer)
{
	struct update_prefix	*upp, *xupp;
	int			 r, wpos = 0;

	for (upp = TAILQ_FIRST(prefix_head);
	    upp != TAILQ_END(prefix_head); upp = xupp) {
		xupp = TAILQ_NEXT(upp, prefix_l);
		if ((r = up_set_prefix(buf + wpos, len - wpos,
		    &upp->prefix, upp->prefixlen)) == -1)
			break;
		wpos += r;
		if (RB_REMOVE(uptree_prefix, &peer->up_prefix, upp) == NULL)
			log_warnx("dequeuing update failed.");
		TAILQ_REMOVE(upp->prefix_h, upp, prefix_l);
		peer->up_pcnt--;
		if (upp->prefix_h == &peer->withdraws)
			peer->up_wcnt--;
		else
			peer->up_nlricnt--;
		free(upp);
	}
	return (wpos);
}

int
up_dump_attrnlri(u_char *buf, int len, struct rde_peer *peer)
{
	struct update_attr	*upa;
	int			 r, wpos;
	u_int16_t		 attr_len;

	upa = TAILQ_FIRST(&peer->updates);
	if (upa == NULL || upa->attr_len + 5 > len) {
		/*
		 * either no packet or not enough space.
		 * The length field needs to be set to zero else it would be
		 * an invalid bgp update.
		 */
		bzero(buf, 2);
		return (2);
	}

	/* first dump the 2-byte path attribute length */
	attr_len = htons(upa->attr_len);
	memcpy(buf, &attr_len, 2);
	wpos = 2;

	/* then the path attributes them self */
	memcpy(buf + wpos, upa->attr, upa->attr_len);
	wpos += upa->attr_len;

	/* last but not least dump the nlri */
	r = up_dump_prefix(buf + wpos, len - wpos, &upa->prefix_h, peer);
	wpos += r;

	/* now check if all prefixes where written */
	if (TAILQ_EMPTY(&upa->prefix_h)) {
		if (RB_REMOVE(uptree_attr, &peer->up_attrs, upa) == NULL)
			log_warnx("dequeuing update failed.");
		TAILQ_REMOVE(&peer->updates, upa, attr_l);
		free(upa);
		peer->up_acnt--;
	}

	return (wpos);
}

void
up_dump_upcall(struct pt_entry *pt, void *ptr)
{
	struct rde_peer	*peer = ptr;

	if (pt->active == NULL)
		return;
	up_generate_updates(peer, pt->active, NULL);
@


1.25
log
@use a struct bgpd_addr instead of sockaddr_in for peer_config->local_addr and
->remote_addr for easier multiprotocol support

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.24 2004/01/22 20:34:56 henning Exp $ */
d440 1
d475 1
@


1.24
log
@use log_warnx and log_info. reclassify a few messages in the process and fix
a few messages.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.23 2004/01/18 00:44:44 deraadt Exp $ */
d181 7
a187 4
	if ((p2->peer->conf.remote_addr.sin_addr.s_addr -
	    p1->peer->conf.remote_addr.sin_addr.s_addr) != 0)
		return (p2->peer->conf.remote_addr.sin_addr.s_addr -
		    p1->peer->conf.remote_addr.sin_addr.s_addr);
@


1.23
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.22 2004/01/17 19:35:36 claudio Exp $ */
d363 1
a363 1
			logit(LOG_CRIT, "uptree_attr insert failed");
d383 1
a383 1
			logit(LOG_CRIT, "uptree_prefix insert failed");
d459 1
a459 1
			logit(LOG_CRIT, "queuing update failed.");
d496 1
a496 2
			logit(LOG_CRIT,
			    "generation of bgp path attributes failed");
d507 1
a507 1
			logit(LOG_CRIT, "queuing update failed.");
d674 1
a674 1
			logit(LOG_CRIT, "dequeuing update failed.");
d720 1
a720 1
			logit(LOG_CRIT, "dequeuing update failed.");
@


1.22
log
@Make it possible to announce own networks. In the RDE these prefixes are
attached to a pseudo peer and inserted like all other prefixes into the RIB.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.21 2004/01/13 17:11:29 henning Exp $ */
d163 1
a163 1
	 * 6. EBGP is cooler than IBGP 
d602 1
a602 1
	 */ 
@


1.21
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.20 2004/01/13 16:15:37 claudio Exp $ */
a539 4
		 * This is only the case for announcements, which we
		 * currenlty don't handle. It is currently unclear how
		 * to recognize those routes. The connected flag is not
		 * enough.
d541 3
a543 1
		if (a->nexthop == peer->remote_addr.v4.s_addr)
d554 1
a554 1
		if (nh->connected) {
d568 3
a570 2
		 * XXX for ebgp multihop nh->connected should always be false
		 * so it should be possible to unify the two ebgp cases.
@


1.20
log
@Do not redistribute updates to ibgp peers. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.19 2004/01/13 13:45:50 claudio Exp $ */
d567 1
a567 1
	} else 
@


1.19
log
@Implement a max-prefix and a announce none | self | all neighbor statement.
The first limits the number of sent prefixes per peer the latter controls
which prefix we do annouce to the neighbor.
Another looks good from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.18 2004/01/13 13:18:03 claudio Exp $ */
d431 4
d463 4
@


1.18
log
@Dump and send RIB to the neighbor if his session is comming up.
Now bgpctl neighbor <IP> up does work as expected.
Looks good from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.17 2004/01/13 12:38:50 claudio Exp $ */
d431 16
d460 16
@


1.17
log
@Do not send routes back to sender as per rfc. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.16 2004/01/12 13:33:16 claudio Exp $ */
a31 1
void	up_generate_updates(struct prefix *, struct prefix *);
d228 1
a228 1
		up_generate_updates(xp, pte->active);
d411 2
a412 1
up_generate_updates(struct prefix *new, struct prefix *old)
a413 2
	extern struct rde_peer_head	 peerlist;
	struct rde_peer			*peer;
d417 41
a457 5
	if ((old == NULL || old->aspath->nexthop == NULL ||
	    old->aspath->nexthop->state != NEXTHOP_REACH) &&
	    (new == NULL || new->aspath->nexthop == NULL ||
	    new->aspath->nexthop->state != NEXTHOP_REACH))
		return;
a458 3
	LIST_FOREACH(peer, &peerlist, peer_l) {
		if (peer->state != PEER_UP)
			continue;
d460 2
a461 4
		 * Filtering should be hooked up here.
		 * With filtering the decision if withdraw, update or nothing
		 * needs to be done on a per peer basis -- acctually per filter
		 * set.
d463 3
d467 2
a468 45
		if (new == NULL || new->aspath->nexthop == NULL ||
		    new->aspath->nexthop->state != NEXTHOP_REACH) {
			if (peer == old->peer)
				/* Do not send routes back to sender */
				continue;
			
			/* withdraw prefix */
			p = calloc(1, sizeof(struct update_prefix));
			if (p == NULL)
				fatal("up_queue_update");

			p->prefix = old->prefix->prefix;
			p->prefixlen = old->prefix->prefixlen;
			if (up_add(peer, p, NULL) == -1)
				logit(LOG_CRIT, "queuing update failed.");
		} else {
			if (peer == new->peer)
				/* Do not send routes back to sender */
				continue;

			/* generate update */
			p = calloc(1, sizeof(struct update_prefix));
			if (p == NULL)
				fatal("up_queue_update");

			a = calloc(1, sizeof(struct update_attr));
			if (a == NULL)
				fatal("up_queue_update");

			if (up_generate_attr(peer, a, &new->aspath->flags,
			    new->aspath->nexthop) == -1)
				logit(LOG_CRIT,
				    "generation of bgp path attributes failed");

			/*
			 * use aspath_hash as attr_hash, this may be unoptimal
			 * but currently I don't care.
			 */
			a->attr_hash = aspath_hash(new->aspath->flags.aspath);
			p->prefix = new->prefix->prefix;
			p->prefixlen = new->prefix->prefixlen;

			if (up_add(peer, p, a) == -1)
				logit(LOG_CRIT, "queuing update failed.");
		}
d691 9
@


1.16
log
@Nexthop announcement fixup. There are different rules for ibgp and ebgp.
For ibgp the nexthop is normally passed unmodified unless the nexthop is
equal to the remote peer ip. To ebgp peers the nexthop is changed to the
local session ip unless the remote peer ip and the nexthop are on the same
subnet. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.15 2004/01/11 21:47:20 claudio Exp $ */
a434 4
		p = calloc(1, sizeof(struct update_prefix));
		if (p == NULL)
			fatal("up_queue_update");

d437 4
d442 4
d451 4
d456 4
@


1.15
log
@Move all struct in_addr to either struct bgpd_addr or in_addr_t whichever
is more appropriate. The rde uses now in most cases struct bgpd_addr.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.14 2004/01/11 02:39:05 henning Exp $ */
d34 1
a34 1
	    struct attr_flags *);
d223 1
a223 1
		 * XXX send update with remove for pte->active and add for xp
d225 3
a227 2
		 * do not send an update if the only available path
		 * has an unreachable nexthop
a228 1

d452 2
a453 2
			if (up_generate_attr(peer, a, &new->aspath->flags) ==
			    -1)
d475 1
a475 1
    struct attr_flags *a)
d479 1
d496 38
a533 1
	/* XXX XXX nexthop fixup */
d535 1
a535 1
	    ATTR_NEXTHOP, &a->nexthop, 4)) ==	-1)
@


1.14
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.13 2004/01/10 22:25:42 claudio Exp $ */
d35 1
a35 1
int	up_set_prefix(u_char *, int, struct in_addr, u_int8_t);
d247 1
a247 1
	struct in_addr			 prefix;
d323 3
a325 1
	if (a->prefix.s_addr < b->prefix.s_addr)
d327 1
a327 1
	if (a->prefix.s_addr > b->prefix.s_addr)
d567 1
a567 1
up_set_prefix(u_char *buf, int len, struct in_addr prefix, u_int8_t plen)
d571 1
d578 1
a578 1
	memcpy(buf, &prefix.s_addr, totlen - 1);
d593 1
a593 1
		    upp->prefix, upp->prefixlen)) == -1)
@


1.13
log
@Implement as path prepends. At least one prepend is needed for ebgp
neighbors. Fix a bug in the update generation. If no path attributes are
available e.g. a packet with only withdraws we need to set (and write) the
bgp path attribute field to zero. With this change we are able to send
valid updates to our neighbors with one exception: the nexthop field which
needs to be changed for ebgp neighbors.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.12 2004/01/10 16:20:29 claudio Exp $ */
d355 1
a355 1
	
d412 1
a412 1
	extern struct rde_peer_head	 peerlist;	
d590 1
a590 1
		    upp->prefix, upp->prefixlen)) == -1) 
@


1.12
log
@RDE update generation. First we queue all updates and withdraws on a per
peer basis. A queue runner will dequeue and package those messages to valid
bgp UPDATE messages and send them to the SE.
Not yet done is per peer type attribute handling (like aspath prepends and
nexthop modifications) and the queue runner could be a tad smarter. All in
all this gives us a good starting point for the missing parts.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.11 2004/01/07 00:01:17 claudio Exp $ */
d478 1
a478 1
	u_int16_t	 aslen, len = sizeof(up_attr_buf), wlen = 0;
d487 2
a488 4
	/* XXX XXX aspath prepends */
	aslen = aspath_length(a->aspath);
	if ((r = attr_write(up_attr_buf + wlen, len, ATTR_WELL_KNOWN,
	    ATTR_ASPATH, aspath_dump(a->aspath), aslen)) == -1)
d614 9
a622 3
	if (upa == NULL || upa->attr_len + 5 > len) 
		/* either no packet or not enough space */
		return (0);
d624 1
a624 1
	/* first dump the attributes */
d628 2
d633 1
a633 1
	/* now dump the nlri */
@


1.11
log
@Make sure that kroute updates for the FIB are only sent if there is a
change. Until now rde_send_kroute tried to send a IMSG_KROUTE_DELETE if old
and new prefix where ineligible. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.10 2004/01/06 10:51:14 claudio Exp $ */
d23 3
d29 7
d119 1
a119 1
static int
d229 1
d243 400
@


1.10
log
@2004 OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.9 2004/01/06 03:43:50 henning Exp $ */
d219 1
a219 3
		if (!(xp != NULL && xp->aspath->nexthop != NULL &&
		    xp->aspath->nexthop->state != NEXTHOP_REACH))
			rde_send_kroute(xp, pte->active);
@


1.9
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.8 2004/01/05 22:33:49 claudio Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Claudio Jeker <claudio@@openbsd.org>
@


1.8
log
@fix comments
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.7 2003/12/26 22:41:01 henning Exp $ */
d5 1
a5 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.7
log
@"when you try to be very smart, something breaks horribly"
zap aspath->state, which was a copy of aspath->nexthop->state, for a tiny
little bit faster access. tho, it happened what had to happen, they ran
out of sync.
it's just not worth it.

also add a missinf LIST_INIT.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.6 2003/12/26 19:28:52 henning Exp $ */
d104 1
a104 1
 * compare two prefixes with equal pt_entry. Returns an integer greater than or
a152 1
	/* 6. EBGP is cooler than IBGP */
d154 1
@


1.6
log
@o the aspath->state checks should be != NEXTHOP_REACH, not == NEXTHOP_UNREACH
o do not send a kroute_add request when the only aspath for the given
| prefix has an nexthop whihc is not reachable (can be unreachable or
| unchecked - that's why the check for == unreachable is not enough)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.5 2003/12/26 18:07:33 henning Exp $ */
d123 1
a123 1
	if (asp2->state != NEXTHOP_REACH)
d125 5
a129 1
	if (asp1->state != NEXTHOP_REACH)
d218 3
a220 1
		if (!(xp != NULL && xp->aspath->state != NEXTHOP_REACH))
d223 2
a224 1
		if (xp == NULL || xp->aspath->state != NEXTHOP_REACH)
@


1.5
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.4 2003/12/24 11:39:43 henning Exp $ */
d123 1
a123 1
	if (asp2->state == NEXTHOP_UNREACH)
d125 1
a125 1
	if (asp1->state == NEXTHOP_UNREACH)
d211 2
d214 2
a215 1
		rde_send_kroute(xp, pte->active);
d217 1
a217 1
		if (xp == NULL || xp->aspath->state == NEXTHOP_UNREACH)
@


1.4
log
@typos in comments, from jared
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.3 2003/12/23 18:52:46 claudio Exp $ */
d173 1
a173 1
	fatal("Uh, oh a politician in the decision process", 0);
@


1.3
log
@In case of exit the RDE need to tell the parent to remove all still active
prefixes from the kernel routing table. This is done with a simple table
walk. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.2 2003/12/23 15:59:02 claudio Exp $ */
d91 1
a91 1
 * Ineligible routes are flaged as ineligible via nexthop_add(). The flags
d97 1
a97 1
 *  - withdraw of a preifx (prefix_remove)
d105 1
a105 1
 * less than 0, according to whether the prefix p1 is more or less prefered
d151 1
a151 1
	 * It is absolutly important that the ebgp value in peer_config.ebgp
@


1.2
log
@Send updates to the main process so they can be added to the kernel
routing table. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_decide.c,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d214 1
a214 1
		if (xp != NULL || xp->aspath->state == NEXTHOP_UNREACH)
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2003 Claudio Jeker <cjeker@@diehard.n-r-g.com>
d203 1
d212 1
@

