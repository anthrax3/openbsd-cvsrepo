head	1.83;
access;
symbols
	OPENBSD_6_2_BASE:1.83
	OPENBSD_6_1:1.80.0.4
	OPENBSD_6_1_BASE:1.80
	OPENBSD_6_0:1.77.0.4
	OPENBSD_6_0_BASE:1.77
	OPENBSD_5_9:1.76.0.2
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.74.0.4
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.71.0.6
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.71.0.4
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.68.0.4
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.68.0.2
	OPENBSD_5_3_BASE:1.68
	OPENBSD_5_2:1.67.0.4
	OPENBSD_5_2_BASE:1.67
	OPENBSD_5_1_BASE:1.67
	OPENBSD_5_1:1.67.0.2
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.65.0.2
	OPENBSD_4_9_BASE:1.65
	OPENBSD_4_8:1.64.0.2
	OPENBSD_4_8_BASE:1.64
	OPENBSD_4_7:1.62.0.2
	OPENBSD_4_7_BASE:1.62
	OPENBSD_4_6:1.56.0.4
	OPENBSD_4_6_BASE:1.56
	OPENBSD_4_5:1.55.0.2
	OPENBSD_4_5_BASE:1.55
	OPENBSD_4_4:1.54.0.2
	OPENBSD_4_4_BASE:1.54
	OPENBSD_4_3:1.53.0.4
	OPENBSD_4_3_BASE:1.53
	OPENBSD_4_2:1.53.0.2
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.50.0.4
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.50.0.2
	OPENBSD_4_0_BASE:1.50
	OPENBSD_3_9:1.46.0.2
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7;
locks; strict;
comment	@ * @;


1.83
date	2017.08.12.16.47.50;	author phessler;	state Exp;
branches;
next	1.82;
commitid	Yn4Issa4OqsHvnXL;

1.82
date	2017.05.27.10.33.15;	author phessler;	state Exp;
branches;
next	1.81;
commitid	SM4OMu9209fRs2iQ;

1.81
date	2017.05.27.10.24.44;	author phessler;	state Exp;
branches;
next	1.80;
commitid	lmPnpLRIggYi6nnK;

1.80
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.79;
commitid	airB1W2Kb948lFil;

1.79
date	2016.11.10.09.20.51;	author phessler;	state Exp;
branches;
next	1.78;
commitid	sGtsud7gcm2VhGvc;

1.78
date	2016.10.14.16.05.36;	author phessler;	state Exp;
branches;
next	1.77;
commitid	Ai7XVOgXw9ZLovz1;

1.77
date	2016.06.03.17.36.37;	author benno;	state Exp;
branches;
next	1.76;
commitid	utIafqBHH3dRVCSC;

1.76
date	2015.11.06.16.23.26;	author phessler;	state Exp;
branches;
next	1.75;
commitid	gwEx9C0BtWsMUbsG;

1.75
date	2015.10.24.08.02.24;	author claudio;	state Exp;
branches;
next	1.74;
commitid	WUP8rSmv1nyOxe63;

1.74
date	2015.07.16.18.26.04;	author claudio;	state Exp;
branches;
next	1.73;
commitid	LqSO5lx1xfCVcctP;

1.73
date	2015.04.25.15.28.18;	author phessler;	state Exp;
branches;
next	1.72;
commitid	4yPC9ACFnDblFb1s;

1.72
date	2015.03.14.03.52.42;	author claudio;	state Exp;
branches;
next	1.71;
commitid	1OLz8RQEaC2xclFf;

1.71
date	2014.01.24.06.07.13;	author phessler;	state Exp;
branches;
next	1.70;

1.70
date	2013.10.19.15.04.25;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2013.08.14.20.34.27;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2012.11.13.09.47.20;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2011.09.20.21.19.06;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2011.05.01.12.56.04;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2010.11.29.17.02.41;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2010.05.17.16.08.20;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2010.04.28.13.07.48;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2010.03.05.15.25.00;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2009.12.18.15.51.37;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2009.12.16.15.40.55;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2009.11.26.13.40.43;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2009.08.06.08.53.11;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.06.01.10.29;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2008.09.29.14.03.41;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2008.06.15.10.19.21;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.28.17.26.33;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.11.11.27.59;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.28.23.24.15;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.28.22.07.54;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2006.04.26.17.13.14;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.04.12.03.26;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2006.02.09.21.05.09;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2006.02.03.19.33.14;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2006.02.03.16.40.57;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2006.02.02.14.06.05;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.24.14.14.04;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.12.14.05.13;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2006.01.10.16.11.12;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.08.17.17.36;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.29.20.45.21;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.02.13.19.30;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.01.15.21.54;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.01.10.58.29;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.10.08.34.06;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.04.09.37.24;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.01.22.04.37;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.01.13.38.14;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.01.12.10.21;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.01.09.19.24;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2005.06.29.09.43.26;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.12.14.32.01;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.14.17.32.04;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.11.12.54.20;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.24.17.14.53;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.23.16.09.26;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.23.13.07.01;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2004.10.08.16.36.42;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.28.14.08.38;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.28.12.09.31;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.10.13.02.08;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.10.12.57.18;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.06.12.04.08;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.05.18.44.19;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.05.15.58.21;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.10.10.09.41;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.05.16.54.53;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.24.23.15.58;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.17.12.39.32;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.07.10.06.15;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.11.17.12.51;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.02.19.29.01;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.01.23.07.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.27.20.53.56;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.24.15.44.33;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.24.15.43.03;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.19.23.07.00;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.83
log
@allow filter rules to be written that affect ibgp or ebgp neighbors

discussed with henning@@
OK claudio@@, benno@@, job@@
@
text
@/*	$OpenBSD: rde_filter.c,v 1.82 2017/05/27 10:33:15 phessler Exp $ */

/*
 * Copyright (c) 2004 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2016 Job Snijders <job@@instituut.net>
 * Copyright (c) 2016 Peter Hessler <phessler@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/queue.h>

#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include "bgpd.h"
#include "rde.h"
#include "log.h"

int	rde_filter_match(struct filter_rule *, struct rde_aspath *,
	    struct bgpd_addr *, u_int8_t, struct rde_peer *, struct rde_peer *);
int	filterset_equal(struct filter_set_head *, struct filter_set_head *);

void
rde_apply_set(struct rde_aspath *asp, struct filter_set_head *sh,
    u_int8_t aid, struct rde_peer *from, struct rde_peer *peer)
{
	struct filter_set	*set;
	u_char			*np;
	int			 as, type;
	int64_t			 las, ld1, ld2;
	u_int32_t		 prep_as;
	u_int16_t		 nl;
	u_int8_t		 prepend;

	if (asp == NULL)
		return;

	TAILQ_FOREACH(set, sh, entry) {
		switch (set->type) {
		case ACTION_SET_LOCALPREF:
			asp->lpref = set->action.metric;
			break;
		case ACTION_SET_RELATIVE_LOCALPREF:
			if (set->action.relative > 0) {
				if (set->action.relative + asp->lpref <
				    asp->lpref)
					asp->lpref = UINT_MAX;
				else
					asp->lpref += set->action.relative;
			} else {
				if ((u_int32_t)-set->action.relative >
				    asp->lpref)
					asp->lpref = 0;
				else
					asp->lpref += set->action.relative;
			}
			break;
		case ACTION_SET_MED:
			asp->flags |= F_ATTR_MED | F_ATTR_MED_ANNOUNCE;
			asp->med = set->action.metric;
			break;
		case ACTION_SET_RELATIVE_MED:
			asp->flags |= F_ATTR_MED | F_ATTR_MED_ANNOUNCE;
			if (set->action.relative > 0) {
				if (set->action.relative + asp->med <
				    asp->med)
					asp->med = UINT_MAX;
				else
					asp->med += set->action.relative;
			} else {
				if ((u_int32_t)-set->action.relative >
				    asp->med)
					asp->med = 0;
				else
					asp->med += set->action.relative;
			}
			break;
		case ACTION_SET_WEIGHT:
			asp->weight = set->action.metric;
			break;
		case ACTION_SET_RELATIVE_WEIGHT:
			if (set->action.relative > 0) {
				if (set->action.relative + asp->weight <
				    asp->weight)
					asp->weight = UINT_MAX;
				else
					asp->weight += set->action.relative;
			} else {
				if ((u_int32_t)-set->action.relative >
				    asp->weight)
					asp->weight = 0;
				else
					asp->weight += set->action.relative;
			}
			break;
		case ACTION_SET_PREPEND_SELF:
			prep_as = peer->conf.local_as;
			prepend = set->action.prepend;
			np = aspath_prepend(asp->aspath, prep_as, prepend, &nl);
			aspath_put(asp->aspath);
			asp->aspath = aspath_get(np, nl);
			free(np);
			break;
		case ACTION_SET_PREPEND_PEER:
			if (from == NULL)
				break;
			prep_as = from->conf.remote_as;
			prepend = set->action.prepend;
			np = aspath_prepend(asp->aspath, prep_as, prepend, &nl);
			aspath_put(asp->aspath);
			asp->aspath = aspath_get(np, nl);
			free(np);
			break;
		case ACTION_SET_NEXTHOP:
		case ACTION_SET_NEXTHOP_REJECT:
		case ACTION_SET_NEXTHOP_BLACKHOLE:
		case ACTION_SET_NEXTHOP_NOMODIFY:
		case ACTION_SET_NEXTHOP_SELF:
			nexthop_modify(asp, &set->action.nexthop, set->type,
			    aid);
			break;
		case ACTION_SET_COMMUNITY:
			switch (set->action.community.as) {
			case COMMUNITY_ERROR:
			case COMMUNITY_ANY:
				fatalx("rde_apply_set bad community string");
			case COMMUNITY_NEIGHBOR_AS:
				as = peer->conf.remote_as;
				break;
			case COMMUNITY_LOCAL_AS:
				as = peer->conf.local_as;
				break;
			default:
				as = set->action.community.as;
				break;
			}

			switch (set->action.community.type) {
			case COMMUNITY_ERROR:
			case COMMUNITY_ANY:
				fatalx("rde_apply_set bad community string");
			case COMMUNITY_NEIGHBOR_AS:
				type = peer->conf.remote_as;
				break;
			case COMMUNITY_LOCAL_AS:
				type = peer->conf.local_as;
				break;
			default:
				type = set->action.community.type;
				break;
			}

			community_set(asp, as, type);
			break;
		case ACTION_DEL_COMMUNITY:
			switch (set->action.community.as) {
			case COMMUNITY_ERROR:
				fatalx("rde_apply_set bad community string");
			case COMMUNITY_NEIGHBOR_AS:
				as = peer->conf.remote_as;
				break;
			case COMMUNITY_LOCAL_AS:
				as = peer->conf.local_as;
				break;
			case COMMUNITY_ANY:
			default:
				as = set->action.community.as;
				break;
			}

			switch (set->action.community.type) {
			case COMMUNITY_ERROR:
				fatalx("rde_apply_set bad community string");
			case COMMUNITY_NEIGHBOR_AS:
				type = peer->conf.remote_as;
				break;
			case COMMUNITY_LOCAL_AS:
				type = peer->conf.local_as;
				break;
			case COMMUNITY_ANY:
			default:
				type = set->action.community.type;
				break;
			}

			community_delete(asp, as, type);
			break;
		case ACTION_SET_LARGE_COMMUNITY:
			switch (set->action.large_community.as) {
			case COMMUNITY_ERROR:
				fatalx("rde_apply_set bad large community string");
			case COMMUNITY_NEIGHBOR_AS:
				las = peer->conf.remote_as;
				break;
			case COMMUNITY_LOCAL_AS:
				las = peer->conf.local_as;
				break;
			case COMMUNITY_ANY:
			default:
				las = set->action.large_community.as;
				break;
			}

			switch (set->action.large_community.ld1) {
			case COMMUNITY_ERROR:
				fatalx("rde_apply_set bad large community string");
			case COMMUNITY_NEIGHBOR_AS:
				ld1 = peer->conf.remote_as;
				break;
			case COMMUNITY_LOCAL_AS:
				ld1 = peer->conf.local_as;
				break;
			case COMMUNITY_ANY:
			default:
				ld1 = set->action.large_community.ld1;
				break;
			}

			switch (set->action.large_community.ld2) {
			case COMMUNITY_ERROR:
				fatalx("rde_apply_set bad large community string");
			case COMMUNITY_NEIGHBOR_AS:
				ld2 = peer->conf.remote_as;
				break;
			case COMMUNITY_LOCAL_AS:
				ld2 = peer->conf.local_as;
				break;
			case COMMUNITY_ANY:
			default:
				ld2 = set->action.large_community.ld2;
				break;
			}

			community_large_set(asp, las, ld1, ld2);
			break;
		case ACTION_DEL_LARGE_COMMUNITY:
			switch (set->action.large_community.as) {
			case COMMUNITY_ERROR:
				fatalx("rde_apply_set bad large community string");
			case COMMUNITY_NEIGHBOR_AS:
				las = peer->conf.remote_as;
				break;
			case COMMUNITY_LOCAL_AS:
				las = peer->conf.local_as;
				break;
			case COMMUNITY_ANY:
			default:
				las = set->action.large_community.as;
				break;
			}

			switch (set->action.large_community.ld1) {
			case COMMUNITY_ERROR:
				fatalx("rde_apply_set bad large community string");
			case COMMUNITY_NEIGHBOR_AS:
				ld1 = peer->conf.remote_as;
				break;
			case COMMUNITY_LOCAL_AS:
				ld1 = peer->conf.local_as;
				break;
			case COMMUNITY_ANY:
			default:
				ld1 = set->action.large_community.ld1;
				break;
			}

			switch (set->action.large_community.ld2) {
			case COMMUNITY_ERROR:
				fatalx("rde_apply_set bad large community string");
			case COMMUNITY_NEIGHBOR_AS:
				ld2 = peer->conf.remote_as;
				break;
			case COMMUNITY_LOCAL_AS:
				ld2 = peer->conf.local_as;
				break;
			case COMMUNITY_ANY:
			default:
				ld2 = set->action.large_community.ld2;
				break;
			}

			community_large_delete(asp, las, ld1, ld2);
			break;
		case ACTION_PFTABLE:
			/* convert pftable name to an id */
			set->action.id = pftable_name2id(set->action.pftable);
			set->type = ACTION_PFTABLE_ID;
			/* FALLTHROUGH */
		case ACTION_PFTABLE_ID:
			pftable_unref(asp->pftableid);
			asp->pftableid = set->action.id;
			pftable_ref(asp->pftableid);
			break;
		case ACTION_RTLABEL:
			/* convert the route label to an id for faster access */
			set->action.id = rtlabel_name2id(set->action.rtlabel);
			set->type = ACTION_RTLABEL_ID;
			/* FALLTHROUGH */
		case ACTION_RTLABEL_ID:
			rtlabel_unref(asp->rtlabelid);
			asp->rtlabelid = set->action.id;
			rtlabel_ref(asp->rtlabelid);
			break;
		case ACTION_SET_ORIGIN:
			asp->origin = set->action.origin;
			break;
		case ACTION_SET_EXT_COMMUNITY:
			community_ext_set(asp, &set->action.ext_community,
			    peer->conf.remote_as);
			break;
		case ACTION_DEL_EXT_COMMUNITY:
			community_ext_delete(asp, &set->action.ext_community,
			    peer->conf.remote_as);
			break;
		}
	}
}

int
rde_filter_match(struct filter_rule *f, struct rde_aspath *asp,
    struct bgpd_addr *prefix, u_int8_t plen, struct rde_peer *peer,
    struct rde_peer *from)
{
	u_int32_t	pas;
	int		cas, type;
	int64_t		las, ld1, ld2;

	if (asp != NULL && f->match.as.type != AS_NONE) {
		if (f->match.as.flags & AS_FLAG_NEIGHBORAS)
			pas = peer->conf.remote_as;
		else
			pas = f->match.as.as;
		if (aspath_match(asp->aspath->data, asp->aspath->len,
		    &f->match.as, pas) == 0)
			return (0);
	}

	if (asp != NULL && f->peer.ebgp && !peer->conf.ebgp)
			return (0);
	if (asp != NULL && f->peer.ibgp && peer->conf.ebgp)
			return (0);

	if (asp != NULL && f->match.aslen.type != ASLEN_NONE)
		if (aspath_lenmatch(asp->aspath, f->match.aslen.type,
		    f->match.aslen.aslen) == 0)
			return (0);

	if (asp != NULL && f->match.community.as != COMMUNITY_UNSET) {
		switch (f->match.community.as) {
		case COMMUNITY_ERROR:
			fatalx("rde_apply_set bad community string");
		case COMMUNITY_NEIGHBOR_AS:
			cas = peer->conf.remote_as;
			break;
		case COMMUNITY_LOCAL_AS:
			cas = peer->conf.local_as;
			break;
		default:
			cas = f->match.community.as;
			break;
		}

		switch (f->match.community.type) {
		case COMMUNITY_ERROR:
			fatalx("rde_apply_set bad community string");
		case COMMUNITY_NEIGHBOR_AS:
			type = peer->conf.remote_as;
			break;
		case COMMUNITY_LOCAL_AS:
			type = peer->conf.local_as;
			break;
		default:
			type = f->match.community.type;
			break;
		}

		if (community_match(asp, cas, type) == 0)
			return (0);
	}
	if (asp != NULL &&
	    (f->match.ext_community.flags & EXT_COMMUNITY_FLAG_VALID))
		if (community_ext_match(asp, &f->match.ext_community,
		    peer->conf.remote_as) == 0)
			return (0);
	if (asp != NULL && f->match.large_community.as !=
	    COMMUNITY_UNSET) {
		switch (f->match.large_community.as) {
		case COMMUNITY_ERROR:
			fatalx("rde_apply_set bad community string");
		case COMMUNITY_NEIGHBOR_AS:
			las = peer->conf.remote_as;
			break;
		case COMMUNITY_LOCAL_AS:
			las = peer->conf.local_as;
			break;
		default:
			las = f->match.large_community.as;
			break;
		}

		switch (f->match.large_community.ld1) {
		case COMMUNITY_ERROR:
			fatalx("rde_apply_set bad community string");
		case COMMUNITY_NEIGHBOR_AS:
			ld1 = peer->conf.remote_as;
			break;
		case COMMUNITY_LOCAL_AS:
			ld1 = peer->conf.local_as;
			break;
		default:
			ld1 = f->match.large_community.ld1;
			break;
		}

		switch (f->match.large_community.ld2) {
		case COMMUNITY_ERROR:
			fatalx("rde_apply_set bad community string");
		case COMMUNITY_NEIGHBOR_AS:
			ld2 = peer->conf.remote_as;
			break;
		case COMMUNITY_LOCAL_AS:
			ld2 = peer->conf.local_as;
			break;
		default:
			ld2 = f->match.large_community.ld2;
			break;
		}

		if (community_large_match(asp, las, ld1, ld2) == 0)
			return (0);
	}

	if (f->match.prefix.addr.aid != 0) {
		if (f->match.prefix.addr.aid != prefix->aid)
			/* don't use IPv4 rules for IPv6 and vice versa */
			return (0);

		if (prefix_compare(prefix, &f->match.prefix.addr,
		    f->match.prefix.len))
			return (0);

		/* test prefixlen stuff too */
		switch (f->match.prefix.op) {
		case OP_NONE: /* perfect match */
			return (plen == f->match.prefix.len);
		case OP_EQ:
			return (plen == f->match.prefix.len_min);
		case OP_NE:
			return (plen != f->match.prefix.len_min);
		case OP_RANGE:
			return ((plen >= f->match.prefix.len_min) &&
			    (plen <= f->match.prefix.len_max));
		case OP_XRANGE:
			return ((plen < f->match.prefix.len_min) ||
			    (plen > f->match.prefix.len_max));
		case OP_LE:
			return (plen <= f->match.prefix.len_min);
		case OP_LT:
			return (plen < f->match.prefix.len_min);
		case OP_GE:
			return (plen >= f->match.prefix.len_min);
		case OP_GT:
			return (plen > f->match.prefix.len_min);
		}
		/* NOTREACHED */
	}
	if (f->match.nexthop.flags != 0) {
		struct bgpd_addr *nexthop, *cmpaddr;
		if (asp != NULL && asp->nexthop == NULL)
			/* no nexthop, skip */
			return (0);
		nexthop = &asp->nexthop->exit_nexthop;
		if (f->match.nexthop.flags == FILTER_NEXTHOP_ADDR)
			cmpaddr = &f->match.nexthop.addr;
		else
			cmpaddr = &from->remote_addr;
		if (cmpaddr->aid != nexthop->aid)
			/* don't use IPv4 rules for IPv6 and vice versa */
			return (0);

		switch (cmpaddr->aid) {
		case AID_INET:
			if (cmpaddr->v4.s_addr != nexthop->v4.s_addr)
				return (0);
			break;
		case AID_INET6:
			if (memcmp(&cmpaddr->v6, &nexthop->v6,
			    sizeof(struct in6_addr)))
				return (0);
			break;
		default:
			fatalx("King Bula lost in address space");
		}
	}

	/* matched somewhen or is anymatch rule  */
	return (1);
}

int
rde_filter_equal(struct filter_head *a, struct filter_head *b,
    struct rde_peer *peer)
{
	struct filter_rule	*fa, *fb;

	fa = a ? TAILQ_FIRST(a) : NULL;
	fb = b ? TAILQ_FIRST(b) : NULL;

	while (fa != NULL || fb != NULL) {
		/* skip all rules with wrong peer */
		if (peer != NULL && fa != NULL && fa->peer.groupid != 0 &&
		    fa->peer.groupid != peer->conf.groupid) {
			fa = TAILQ_NEXT(fa, entry);
			continue;
		}
		if (peer != NULL && fa != NULL && fa->peer.peerid != 0 &&
		    fa->peer.peerid != peer->conf.id) {
			fa = TAILQ_NEXT(fa, entry);
			continue;
		}

		if (peer != NULL && fb != NULL && fb->peer.groupid != 0 &&
		    fb->peer.groupid != peer->conf.groupid) {
			fb = TAILQ_NEXT(fb, entry);
			continue;
		}
		if (peer != NULL && fb != NULL && fb->peer.peerid != 0 &&
		    fb->peer.peerid != peer->conf.id) {
			fb = TAILQ_NEXT(fb, entry);
			continue;
		}

		if (peer != NULL && fa != NULL && fa->peer.remote_as != 0 &&
		    fa->peer.remote_as != peer->conf.remote_as) {
			fa = TAILQ_NEXT(fa, entry);
			continue;
		}

		if (peer != NULL && fa != NULL && fa->peer.ebgp != 0 &&
		    fa->peer.ebgp != peer->conf.ebgp) {
			fa = TAILQ_NEXT(fa, entry);
			continue;
		}

		if (peer != NULL && fa != NULL && fa->peer.ibgp != 0 &&
		    fa->peer.ibgp != !peer->conf.ebgp) {
			fa = TAILQ_NEXT(fa, entry);
			continue;
		}

		/* compare the two rules */
		if ((fa == NULL && fb != NULL) || (fa != NULL && fb == NULL))
			/* new rule added or removed */
			return (0);

		if (fa->action != fb->action || fa->quick != fb->quick)
			return (0);
		if (memcmp(&fa->peer, &fb->peer, sizeof(fa->peer)))
			return (0);
		if (memcmp(&fa->match, &fb->match, sizeof(fa->match)))
			return (0);
		if (!filterset_equal(&fa->set, &fb->set))
			return (0);

		fa = TAILQ_NEXT(fa, entry);
		fb = TAILQ_NEXT(fb, entry);
	}
	return (1);
}

void
filterlist_free(struct filter_head *fh)
{
	struct filter_rule	*r;

	if (fh == NULL)
		return;

	while ((r = TAILQ_FIRST(fh)) != NULL) {
		TAILQ_REMOVE(fh, r, entry);
		filterset_free(&r->set);
		free(r);
	}
	free(fh);
}

/* free a filterset and take care of possible name2id references */
void
filterset_free(struct filter_set_head *sh)
{
	struct filter_set	*s;
	struct nexthop		*nh;

	if (sh == NULL)
		return;

	while ((s = TAILQ_FIRST(sh)) != NULL) {
		TAILQ_REMOVE(sh, s, entry);
		if (s->type == ACTION_RTLABEL_ID)
			rtlabel_unref(s->action.id);
		else if (s->type == ACTION_PFTABLE_ID)
			pftable_unref(s->action.id);
		else if (s->type == ACTION_SET_NEXTHOP &&
		    bgpd_process == PROC_RDE) {
			nh = nexthop_get(&s->action.nexthop);
			--nh->refcnt;
			(void)nexthop_delete(nh);
		}
		free(s);
	}
}

/*
 * this function is a bit more complicated than a memcmp() because there are
 * types that need to be considered equal e.g. ACTION_SET_MED and
 * ACTION_SET_RELATIVE_MED. Also ACTION_SET_COMMUNITY and ACTION_SET_NEXTHOP
 * need some special care. It only checks the types and not the values so
 * it does not do a real compare.
 */
int
filterset_cmp(struct filter_set *a, struct filter_set *b)
{
	if (strcmp(filterset_name(a->type), filterset_name(b->type)))
		return (a->type - b->type);

	if (a->type == ACTION_SET_COMMUNITY ||
	    a->type == ACTION_DEL_COMMUNITY) {	/* a->type == b->type */
		/* compare community */
		if (a->action.community.as - b->action.community.as != 0)
			return (a->action.community.as -
			    b->action.community.as);
		return (a->action.community.type - b->action.community.type);
	}

	if (a->type == ACTION_SET_EXT_COMMUNITY ||
	    a->type == ACTION_DEL_EXT_COMMUNITY) {	/* a->type == b->type */
		return (memcmp(&a->action.ext_community,
		    &b->action.ext_community, sizeof(a->action.ext_community)));
	}

	if (a->type == ACTION_SET_LARGE_COMMUNITY ||
	    a->type == ACTION_DEL_LARGE_COMMUNITY) {	/* a->type == b->type */
		/* compare community */
		if (a->action.large_community.as -
		    b->action.large_community.as != 0)
			return (a->action.large_community.as -
			    b->action.large_community.as);
		if (a->action.large_community.ld1 -
		    b->action.large_community.ld1 != 0)
			return (a->action.large_community.ld1 -
			    b->action.large_community.ld1);
		return (a->action.large_community.ld2 -
		    b->action.large_community.ld2);
	}

	if (a->type == ACTION_SET_NEXTHOP && b->type == ACTION_SET_NEXTHOP) {
		/*
		 * This is the only interesting case, all others are considered
		 * equal. It does not make sense to e.g. set a nexthop and
		 * reject it at the same time. Allow one IPv4 and one IPv6
		 * per filter set or only one of the other nexthop modifiers.
		 */
		return (a->action.nexthop.aid - b->action.nexthop.aid);
	}

	/* equal */
	return (0);
}

void
filterset_move(struct filter_set_head *source, struct filter_set_head *dest)
{
	struct filter_set	*s;

	TAILQ_INIT(dest);

	if (source == NULL)
		return;

	while ((s = TAILQ_FIRST(source)) != NULL) {
		TAILQ_REMOVE(source, s, entry);
		TAILQ_INSERT_TAIL(dest, s, entry);
	}
}

int
filterset_equal(struct filter_set_head *ah, struct filter_set_head *bh)
{
	struct filter_set	*a, *b;
	const char		*as, *bs;

	for (a = TAILQ_FIRST(ah), b = TAILQ_FIRST(bh);
	    a != NULL && b != NULL;
	    a = TAILQ_NEXT(a, entry), b = TAILQ_NEXT(b, entry)) {
		switch (a->type) {
		case ACTION_SET_PREPEND_SELF:
		case ACTION_SET_PREPEND_PEER:
			if (a->type == b->type &&
			    a->action.prepend == b->action.prepend)
				continue;
			break;
		case ACTION_SET_LOCALPREF:
		case ACTION_SET_MED:
		case ACTION_SET_WEIGHT:
			if (a->type == b->type &&
			    a->action.metric == b->action.metric)
				continue;
			break;
		case ACTION_SET_RELATIVE_LOCALPREF:
		case ACTION_SET_RELATIVE_MED:
		case ACTION_SET_RELATIVE_WEIGHT:
			if (a->type == b->type &&
			    a->action.relative == b->action.relative)
				continue;
			break;
		case ACTION_SET_NEXTHOP:
			if (a->type == b->type &&
			    memcmp(&a->action.nexthop, &b->action.nexthop,
			    sizeof(a->action.nexthop)) == 0)
				continue;
			break;
		case ACTION_SET_NEXTHOP_BLACKHOLE:
		case ACTION_SET_NEXTHOP_REJECT:
		case ACTION_SET_NEXTHOP_NOMODIFY:
		case ACTION_SET_NEXTHOP_SELF:
			if (a->type == b->type)
				continue;
			break;
		case ACTION_DEL_COMMUNITY:
		case ACTION_SET_COMMUNITY:
			if (a->type == b->type &&
			    memcmp(&a->action.community, &b->action.community,
			    sizeof(a->action.community)) == 0)
				continue;
			break;
		case ACTION_DEL_LARGE_COMMUNITY:
		case ACTION_SET_LARGE_COMMUNITY:
			if (a->type == b->type &&
			    memcmp(&a->action.large_community,
			    &b->action.large_community,
			    sizeof(a->action.large_community)) == 0)
				continue;
			break;
		case ACTION_PFTABLE:
		case ACTION_PFTABLE_ID:
			if (b->type == ACTION_PFTABLE)
				bs = b->action.pftable;
			else if (b->type == ACTION_PFTABLE_ID)
				bs = pftable_id2name(b->action.id);
			else
				break;

			if (a->type == ACTION_PFTABLE)
				as = a->action.pftable;
			else
				as = pftable_id2name(a->action.id);

			if (strcmp(as, bs) == 0)
				continue;
			break;
		case ACTION_RTLABEL:
		case ACTION_RTLABEL_ID:
			if (b->type == ACTION_RTLABEL)
				bs = b->action.rtlabel;
			else if (b->type == ACTION_RTLABEL_ID)
				bs = rtlabel_id2name(b->action.id);
			else
				break;

			if (a->type == ACTION_RTLABEL)
				as = a->action.rtlabel;
			else
				as = rtlabel_id2name(a->action.id);

			if (strcmp(as, bs) == 0)
				continue;
			break;
		case ACTION_SET_ORIGIN:
			if (a->type == b->type &&
			    a->action.origin == b->action.origin)
				continue;
			break;
		case ACTION_SET_EXT_COMMUNITY:
		case ACTION_DEL_EXT_COMMUNITY:
			if (a->type == b->type && memcmp(
			    &a->action.ext_community,
			    &b->action.ext_community,
			    sizeof(a->action.ext_community)) == 0)
				continue;
			break;
		}
		/* compare failed */
		return (0);
	}
	if (a != NULL || b != NULL)
		return (0);
	return (1);
}

const char *
filterset_name(enum action_types type)
{
	switch (type) {
	case ACTION_SET_LOCALPREF:
	case ACTION_SET_RELATIVE_LOCALPREF:
		return ("localpref");
	case ACTION_SET_MED:
	case ACTION_SET_RELATIVE_MED:
		return ("metric");
	case ACTION_SET_WEIGHT:
	case ACTION_SET_RELATIVE_WEIGHT:
		return ("weight");
	case ACTION_SET_PREPEND_SELF:
		return ("prepend-self");
	case ACTION_SET_PREPEND_PEER:
		return ("prepend-peer");
	case ACTION_SET_NEXTHOP:
	case ACTION_SET_NEXTHOP_REJECT:
	case ACTION_SET_NEXTHOP_BLACKHOLE:
	case ACTION_SET_NEXTHOP_NOMODIFY:
	case ACTION_SET_NEXTHOP_SELF:
		return ("nexthop");
	case ACTION_SET_COMMUNITY:
		return ("community");
	case ACTION_DEL_COMMUNITY:
		return ("community delete");
	case ACTION_SET_LARGE_COMMUNITY:
		return ("large-community");
	case ACTION_DEL_LARGE_COMMUNITY:
		return ("large-community delete");
	case ACTION_PFTABLE:
	case ACTION_PFTABLE_ID:
		return ("pftable");
	case ACTION_RTLABEL:
	case ACTION_RTLABEL_ID:
		return ("rtlabel");
	case ACTION_SET_ORIGIN:
		return ("origin");
	case ACTION_SET_EXT_COMMUNITY:
		return ("ext-community");
	case ACTION_DEL_EXT_COMMUNITY:
		return ("ext-community delete");
	}

	fatalx("filterset_name: got lost");
}

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#define RDE_FILTER_SET_SKIP_STEPS(i)				\
	do {							\
		while (head[i] != cur) {			\
			head[i]->skip[i].ptr = cur;		\
			head[i] = TAILQ_NEXT(head[i], entry);	\
		}						\
	} while (0)

struct peer;
void print_rule(struct peer *, struct filter_rule *);

void
rde_filter_calc_skip_steps(struct filter_head *rules)
{
	struct filter_rule *cur, *prev, *head[RDE_FILTER_SKIP_COUNT];
	int i;

	if (rules == NULL)
		return;

	cur = TAILQ_FIRST(rules);

	prev = cur;
	for (i = 0; i < RDE_FILTER_SKIP_COUNT; ++i)
		head[i] = cur;
	while (cur != NULL) {
		if (cur->peer.groupid != prev->peer.groupid)
			RDE_FILTER_SET_SKIP_STEPS(RDE_FILTER_SKIP_GROUPID);
		if (cur->peer.remote_as != prev->peer.remote_as)
			RDE_FILTER_SET_SKIP_STEPS(RDE_FILTER_SKIP_REMOTE_AS);
		 if (cur->peer.peerid != prev->peer.peerid)
			RDE_FILTER_SET_SKIP_STEPS(RDE_FILTER_SKIP_PEERID);
		prev = cur;
		cur = TAILQ_NEXT(cur, entry);
	}
	for (i = 0; i < RDE_FILTER_SKIP_COUNT; ++i)
		RDE_FILTER_SET_SKIP_STEPS(i);

}

#define RDE_FILTER_TEST_ATTRIB(t, a)				\
	do {							\
		if (t) {					\
			f = a;					\
			goto nextrule;				\
		}						\
	} while (0)

enum filter_actions
rde_filter(struct filter_head *rules, struct rde_aspath **new,
    struct rde_peer *peer, struct rde_aspath *asp, struct bgpd_addr *prefix,
    u_int8_t prefixlen, struct rde_peer *from)
{
	struct filter_rule	*f;
	enum filter_actions	 action = ACTION_ALLOW; /* default allow */

	if (new != NULL)
		*new = NULL;

	if (asp->flags & F_ATTR_PARSE_ERR)
		/*
	 	 * don't try to filter bad updates just deny them
		 * so they act as implicit withdraws
		 */
		return (ACTION_DENY);

	if (rules == NULL)
		return (action);

	f = TAILQ_FIRST(rules);
	while (f != NULL) {
		RDE_FILTER_TEST_ATTRIB(
		    (f->peer.groupid &&
		     f->peer.groupid != peer->conf.groupid),
		     f->skip[RDE_FILTER_SKIP_GROUPID].ptr);
		RDE_FILTER_TEST_ATTRIB(
		    (f->peer.remote_as &&
		     f->peer.remote_as != peer->conf.remote_as),
		     f->skip[RDE_FILTER_SKIP_REMOTE_AS].ptr);
		RDE_FILTER_TEST_ATTRIB(
		    (f->peer.peerid &&
		     f->peer.peerid != peer->conf.id),
		     f->skip[RDE_FILTER_SKIP_PEERID].ptr);
		if (rde_filter_match(f, asp, prefix, prefixlen, peer, from)) {
			if (asp != NULL && new != NULL) {
				/* asp may get modified so create a copy */
				if (*new == NULL) {
					*new = path_copy(asp);
					/* ... and use the copy from now on */
					asp = *new;
				}
				rde_apply_set(asp, &f->set, prefix->aid,
				    from, peer);
			}
			if (f->action != ACTION_NONE)
				action = f->action;
			if (f->quick)
				return (action);
		}
		f = TAILQ_NEXT(f, entry);
 nextrule: ;
	}
	return (action);
}
@


1.82
log
@Allow OpenBGPD to selectively choose which local ASN to use per-peer.
This is intended to be used for ASN migrations, not for permanent use.

You MUST use filters to protect yourself from receiving your own routes.
There be dragons and grues.

OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.81 2017/05/27 10:24:44 phessler Exp $ */
d350 5
d547 12
@


1.81
log
@allow us to use 'local-as' in the filter language

"match in from any set community local-as:neighbor-as"

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.80 2017/01/24 04:22:42 benno Exp $ */
d109 1
a109 1
			prep_as = rde_local_as();
@


1.80
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.79 2016/11/10 09:20:51 phessler Exp $ */
d142 3
d157 3
d174 3
d189 3
d207 3
d222 3
d237 3
d255 3
d270 3
d285 3
d362 3
d376 3
d400 3
d414 3
d427 3
@


1.79
log
@properly check if large-community was set before

reported by Job Snijders
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.78 2016/10/14 16:05:36 phessler Exp $ */
d29 1
@


1.78
log
@Add support for draft-ietf-idr-large-community

Joint work with Job Snijders, many thanks!
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.77 2016/06/03 17:36:37 benno Exp $ */
d588 15
@


1.77
log
@Add operators =, !=, - (range), >< (exclsive range) to the as-path
filters (AS, peer-as, source-as, transit-as).

Add a use case (block illegal AS numbers) to the bgpd.conf example.

feedback from claudio, sthen, florian,
ok florian@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.76 2015/11/06 16:23:26 phessler Exp $ */
d5 2
d41 1
d187 78
d307 1
d355 38
d670 8
d761 4
@


1.76
log
@Radically improve the performance of bgpd filters.  Based on PF's skip
steps (and uses much of the same code).

In a torture test of ~600k prefix filters and 65k prefixes, convergance
time goes from 35 minutes to 30 seconds.

Many thanks to LONAP for providing a base configuration for torture
testing.

many discussions with claudio@@, benno@@, sthen@@ and the rest of the bgpd crowd

OK sthen@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.75 2015/10/24 08:02:24 claudio Exp $ */
d233 1
a233 1
		    f->match.as.type, pas) == 0)
@


1.75
log
@In all other cases of rde_filter_match() we ensure that asp is valid so
do it here as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.74 2015/07/16 18:26:04 claudio Exp $ */
a31 51
enum filter_actions
rde_filter(struct filter_head *rules, struct rde_aspath **new,
    struct rde_peer *peer, struct rde_aspath *asp, struct bgpd_addr *prefix,
    u_int8_t prefixlen, struct rde_peer *from)
{
	struct filter_rule	*f;
	enum filter_actions	 action = ACTION_ALLOW; /* default allow */

	if (new != NULL)
		*new = NULL;

	if (asp->flags & F_ATTR_PARSE_ERR)
		/*
	 	 * don't try to filter bad updates just deny them
		 * so they act as implicit withdraws
		 */
		return (ACTION_DENY);

	if (rules == NULL)
		return (action);

	TAILQ_FOREACH(f, rules, entry) {
		if (f->peer.groupid != 0 &&
		    f->peer.groupid != peer->conf.groupid)
			continue;
		if (f->peer.peerid != 0 &&
		    f->peer.peerid != peer->conf.id)
			continue;
		if (f->peer.remote_as != 0 &&
		    f->peer.remote_as != peer->conf.remote_as)
			continue;
		if (rde_filter_match(f, asp, prefix, prefixlen, peer, from)) {
			if (asp != NULL && new != NULL) {
				/* asp may get modified so create a copy */
				if (*new == NULL) {
					*new = path_copy(asp);
					/* ... and use the copy from now on */
					asp = *new;
				}
				rde_apply_set(asp, &f->set, prefix->aid,
				    from, peer);
			}
			if (f->action != ACTION_NONE)
				action = f->action;
			if (f->quick)
				return (action);
		}
	}
	return (action);
}

d648 139
@


1.74
log
@Next round of config cleanup. Move various lists into the bgpd_config struct.
This is the next step to better split parsing and merging the config.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.73 2015/04/25 15:28:18 phessler Exp $ */
d361 1
a361 1
		if (asp->nexthop == NULL)
@


1.73
log
@allow us to write rules that match directly on the peer AS

...
allow from AS 1 prefix 192.0.2.0/24
...

Also adjust the IRR ruleset output to include the declared peer AS,
instead of hoping they listed their neighbor IP address!


OK benno@@
older version OK: claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.72 2015/03/14 03:52:42 claudio Exp $ */
d473 3
@


1.72
log
@rename rde_free_filter() to filterlist_free() and start using it outside
of the RDE to free the filterlists. Also refactor common code to merge
filterlists into its own function. Makes the code look nicer.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.71 2014/01/24 06:07:13 phessler Exp $ */
d60 3
d422 6
@


1.71
log
@fix the matching for filter rules of 'prefixlen = XX'

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.70 2013/10/19 15:04:25 claudio Exp $ */
d443 1
a443 1
rde_free_filter(struct filter_head *fh)
@


1.70
log
@Merge the prefix and prefixlen filter bits into one filter. Change the
filter expansion so that rules are grouped by prefixes last. The RDE will
then be able to optimize the rules into table lookups but that is a later
step. As additional goodies it is now possible to use inet and inet6
on their own and or-longer can be used as a shorthand for prefixlen >= len.
OK henning@@ sthen@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.69 2013/08/14 20:34:27 claudio Exp $ */
d334 1
d336 1
a336 1
			return (plen == f->match.prefix.len);
@


1.69
log
@Rewrite the internals of the RDE reload logic.
This is the first step to make bgpd reload non blocking in the RDE.
It also speeds up the reload time a fair bit in some cases (mainly if
you run with multiple RIBs and have larger filtersets) and it should also
fix a few edge cases on reloads.
Testing done by benno@@, florian@@ and sthen@@ OK henning@@ and benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.68 2012/11/13 09:47:20 claudio Exp $ */
d332 3
a334 3
		switch (f->match.prefixlen.op) {
		case OP_NONE:
			/* perfect match */
a335 8
		case OP_RANGE:
			return ((plen >= f->match.prefixlen.len_min) &&
			    (plen <= f->match.prefixlen.len_max));
		case OP_XRANGE:
			return ((plen < f->match.prefixlen.len_min) ||
			    (plen > f->match.prefixlen.len_max));
		case OP_EQ:
			return (plen == f->match.prefixlen.len_min);
d337 1
a337 21
			return (plen != f->match.prefixlen.len_min);
		case OP_LE:
			return (plen <= f->match.prefixlen.len_min);
		case OP_LT:
			return (plen < f->match.prefixlen.len_min);
		case OP_GE:
			return (plen >= f->match.prefixlen.len_min);
		case OP_GT:
			return (plen > f->match.prefixlen.len_min);
		}
		/* NOTREACHED */
	} else if (f->match.prefixlen.op != OP_NONE) {
		/* only prefixlen without a prefix */

		if (f->match.prefixlen.aid != prefix->aid)
			/* don't use IPv4 rules for IPv6 and vice versa */
			return (0);

		switch (f->match.prefixlen.op) {
		case OP_NONE:
			fatalx("internal filter bug");
d339 2
a340 2
			return ((plen >= f->match.prefixlen.len_min) &&
			    (plen <= f->match.prefixlen.len_max));
d342 2
a343 6
			return ((plen < f->match.prefixlen.len_min) ||
			    (plen > f->match.prefixlen.len_max));
		case OP_EQ:
			return (plen == f->match.prefixlen.len_min);
		case OP_NE:
			return (plen != f->match.prefixlen.len_min);
d345 1
a345 1
			return (plen <= f->match.prefixlen.len_min);
d347 1
a347 1
			return (plen < f->match.prefixlen.len_min);
d349 1
a349 1
			return (plen >= f->match.prefixlen.len_min);
d351 1
a351 1
			return (plen > f->match.prefixlen.len_min);
@


1.68
log
@Allow filtering based on the NEXTHOP attribute. This allows to build rules
like: allow from any nexthop neighbor (to allow only prefixes that use the
routers IP address as nexthop). Lots of testing, input and OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.67 2011/09/20 21:19:06 claudio Exp $ */
d33 1
a33 1
rde_filter(u_int16_t ribid, struct rde_aspath **new, struct filter_head *rules,
d35 1
a35 1
    u_int8_t prefixlen, struct rde_peer *from, enum directions dir)
d50 3
a53 4
		if (dir != f->dir)
			continue;
		if (dir == DIR_IN && f->peer.ribid != ribid)
			continue;
d422 1
a422 1
    struct rde_peer *peer, enum directions dir)
d426 2
a427 2
	fa = TAILQ_FIRST(a);
	fb = TAILQ_FIRST(b);
a429 10
		/* skip all rules with wrong direction */
		if (fa != NULL && dir != fa->dir) {
			fa = TAILQ_NEXT(fa, entry);
			continue;
		}
		if (fb != NULL && dir != fb->dir) {
			fb = TAILQ_NEXT(fb, entry);
			continue;
		}

d431 1
a431 1
		if (fa != NULL && fa->peer.groupid != 0 &&
d436 1
a436 1
		if (fa != NULL && fa->peer.peerid != 0 &&
d442 1
a442 1
		if (fb != NULL && fb->peer.groupid != 0 &&
d447 1
a447 1
		if (fb != NULL && fb->peer.peerid != 0 &&
d471 16
@


1.67
log
@Move a few functions into util.c because bgpctl will need them soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.66 2011/05/01 12:56:04 claudio Exp $ */
d29 1
a29 1
	    struct bgpd_addr *, u_int8_t, struct rde_peer *);
d61 1
a61 1
		if (rde_filter_match(f, asp, prefix, prefixlen, peer)) {
d270 2
a271 1
    struct bgpd_addr *prefix, u_int8_t plen, struct rde_peer *peer)
d387 28
@


1.66
log
@On reload the filtersets attached to a network need to be moved to the
existing network element. First free the old filterset and then move
the new on top of it. This solves the reload issue with changing network
statements. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.65 2010/11/29 17:02:41 claudio Exp $ */
d280 2
a281 1
		if (aspath_match(asp->aspath, f->match.as.type, pas) == 0)
@


1.65
log
@Deny prefixes that have F_ATTR_PARSE_ERR set by default. Now they
will not leak into the Loc-RIB or other RIBs but act as withdraws.
The invalid prefixes would not been selected anyway but it is better
to keep them out of all RIBs but the Adj-RIB-In.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.64 2010/05/17 16:08:20 claudio Exp $ */
d517 16
@


1.64
log
@Implement two new filters, max-as-len and max-as-seq. The first is limiting
the length of an AS path (matches if the path is longer then the specified
lenght) the second matches when a sequence of the same AS number is longer
then the specified length).
max-as-len is good to protect crappy comercial bgp boxes from other crappy
comercial bgp boxes. max-as-seq was a feature request from SwissIX and maybe
EuroIX to find and filter prepends.
Additinal testing and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.63 2010/04/28 13:07:48 claudio Exp $ */
d45 1
a45 1
	 	 * don't try to filter bad updates but let them through
d48 1
a48 1
		return (action);
@


1.63
log
@Allow neighbor-as in AS filter statements like:
match from any source-as neighbor-as set localpref 1000
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.62 2010/03/05 15:25:00 claudio Exp $ */
d283 5
@


1.62
log
@Allow to filter for ext-community attributes. Currently only perfect matches
work but that's already better then nothing. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.61 2009/12/18 15:51:37 claudio Exp $ */
d272 2
a273 1
	int	as, type;
d275 6
a280 3
	if (asp != NULL && f->match.as.type != AS_NONE)
		if (aspath_match(asp->aspath, f->match.as.type,
		    f->match.as.as) == 0)
d282 1
d289 1
a289 1
			as = peer->conf.remote_as;
d292 1
a292 1
			as = f->match.community.as;
d307 1
a307 1
		if (community_match(asp, as, type) == 0)
@


1.61
log
@Merge rde_filter_community() with community_match() and kill a useless
indirection.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.60 2009/12/16 15:40:55 claudio Exp $ */
d305 5
@


1.60
log
@Implement "set ext-community [delete] subtype key:value" to set and delete
extended communities as specified in RFC 4360. No matching implemented yet
and stuff like * and neighbor-as are neither supported but will be soon.
Looks good henning & sthen, manpage fixed by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.59 2009/12/01 14:28:05 claudio Exp $ */
d302 1
a302 1
		if (rde_filter_community(asp, as, type) == 0)
a373 13
}

int
rde_filter_community(struct rde_aspath *asp, int as, int type)
{
	struct attr	*a;

	a = attr_optget(asp, ATTR_COMMUNITIES);
	if (a == NULL)
		/* no communities, no match */
		return (0);

	return (community_match(a->data, a->len, as, type));
@


1.59
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.58 2009/11/26 13:40:43 henning Exp $ */
d256 8
d497 6
d606 8
d658 4
@


1.58
log
@support for set origin; based on an initial diff from
Sebastian Benoit <benoit-lists at fb12 dot de> who also tested this version
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.57 2009/08/06 08:53:11 claudio Exp $ */
d69 1
a69 1
				rde_apply_set(asp, &f->set, prefix->af,
d83 1
a83 1
    sa_family_t af, struct rde_peer *from, struct rde_peer *peer)
d177 1
a177 1
			    af);
d298 2
a299 2
	if (f->match.prefix.addr.af != 0) {
		if (f->match.prefix.addr.af != prefix->af)
d335 1
a335 1
		if (f->match.prefixlen.af != prefix->af)
d496 1
a496 1
		return (a->action.nexthop.af - b->action.nexthop.af);
@


1.57
log
@Implement the error handling as proposed in draft-ietf-idr-optional-transitive
for optional transitive attributes. In short if the partial bit is set on
an optional transitive attribute but the attribute fails validation ignore
the attribute or mark the path as ineligible instead of killing the session
with a NOTIFICATION. Tested, input and OK sthen, OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.56 2009/06/06 01:10:29 claudio Exp $ */
d253 3
d587 5
d634 2
@


1.56
log
@Some preliminary filter magic to support multiple RIBs on the filters.
It is ugly but does the trick for now. Filters will be rewritten anyway.
The rib specifier only makes sense on from rules. e.g. deny rib OMG from any
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.55 2008/09/29 14:03:41 claudio Exp $ */
d42 7
@


1.55
log
@Correct the logic when matching prefixes. This solves issues where IPv6
prefixes where matched on a simple deny from any prefix 0.0.0.0/0 rule.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.54 2008/06/15 10:19:21 claudio Exp $ */
d33 1
a33 1
rde_filter(struct rde_aspath **new, struct filter_head *rules,
d45 2
@


1.54
log
@Allow bgpd to delete more then one community per filter rule. Fixes PR5807
tested by Raphael Ho long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.53 2007/05/28 17:26:33 henning Exp $ */
d286 5
a290 2
	if (f->match.prefix.addr.af != 0 &&
	    f->match.prefix.addr.af == prefix->af) {
@


1.53
log
@allow matching on communities using 0 in the AS part, that is in use.
that unfortunately means we cannot use 0 for "unset".
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.52 2007/05/11 11:27:59 claudio Exp $ */
d465 2
a466 1
	if (a->type == ACTION_SET_COMMUNITY) {	/* a->type == b->type */
@


1.52
log
@Various spelling fixes from Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.51 2007/04/23 13:04:24 claudio Exp $ */
d259 1
a259 1
	if (asp != NULL && f->match.community.as != 0) {
@


1.51
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.50 2006/05/28 23:24:15 claudio Exp $ */
d475 1
a475 1
		 * This is the only intresting case, all others are considered
@


1.50
log
@Even better nexthop delete behaviour. Do not delete nexthop if they are used
by filter sets or if the nexthop is currently looked up. With this the
"nexthop_update: non-existent nexthop" warning should be history. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.49 2006/05/28 22:07:54 claudio Exp $ */
d77 1
a77 1
	struct aspath		*new;
d79 2
a80 1
	u_int16_t		 prep_as;
d145 1
a145 1
			as = rde_local_as();
d147 1
a147 1
			new = aspath_prepend(asp->aspath, as, prepend);
d149 2
a150 1
			asp->aspath = new;
d157 1
a157 1
			new = aspath_prepend(asp->aspath, prep_as, prepend);
d159 2
a160 1
			asp->aspath = new;
@


1.49
log
@Preload and pin nexthop used in filtersets so the are validiated when used.
This will fix problems with set nexthop on outgoing filters. Found by
gluk@@ OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.48 2006/04/26 17:13:14 claudio Exp $ */
d442 2
a443 7
			if (--nh->refcnt <= 0 && LIST_EMPTY(&nh->path_h)) {
				LIST_REMOVE(nh, nexthop_l);
				rde_send_nexthop(&nh->exit_nexthop, 0);

				rdemem.nexthop_cnt--;
				free(nh);
			}
@


1.48
log
@Remove filterset_names from bgpd.h and replace it with a function because
the table was already out of sync now. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.47 2006/04/04 12:03:26 henning Exp $ */
d431 1
d439 11
@


1.47
log
@add "set nexthop self", force nexthop to be set to own address even with IBGP
requested & tested Falk Brockerhoff <fb@@smartterra.de>, and tony sarendal
tested this too. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.46 2006/02/09 21:05:09 claudio Exp $ */
d452 1
a452 1
	if (strcmp(filterset_names[a->type], filterset_names[b->type]))
d570 37
@


1.46
log
@Implement "set community delete 65001:*" and friends. This will remove
communities from the path attributes. Useful to make sure that the ones you
set later are set by a (evil) peer.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.45 2006/02/03 19:33:14 claudio Exp $ */
d163 1
d516 1
@


1.45
log
@If the aspath gets copied because it is modified use the copy for filter
matching. With this it is possible to make later filters depend on previous
filter changes -- e.g. via community attributes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.44 2006/02/03 16:40:57 claudio Exp $ */
d193 27
d518 1
@


1.44
log
@Doh! Fix stupid copy paste error. Setting the community type to the AS instead
of the more obvious type produces really funny errors and gives you some happy
hours of debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.43 2006/02/02 14:06:05 claudio Exp $ */
d55 1
a55 1
				if (*new == NULL)
d57 4
a60 1
				rde_apply_set(*new, &f->set, prefix->af,
@


1.43
log
@Implement new special community "neighbor-as". neighbor-as is expanded on
the fly to the remote AS of the current neighbor. This can be used to
simplify rulesets in a dramatic way -- going from a script based nightmare
down to a handfull rules. jajajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.42 2006/01/24 14:14:04 claudio Exp $ */
d184 1
a184 1
				type = set->action.community.as;
d244 1
a244 1
			type = f->match.community.as;
@


1.42
log
@Check if filter changed on a per peer basis. This should speed up the
table run done later as many filter evaluations can be skipped.
From the softreconfig in tree. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.41 2006/01/12 14:05:13 claudio Exp $ */
d29 1
a29 1
	    struct bgpd_addr *, u_int8_t);
d52 1
a52 1
		if (rde_filter_match(f, asp, prefix, prefixlen)) {
d58 1
a58 1
				    from, dir);
d71 1
a71 1
    sa_family_t af, struct rde_peer *from, enum directions dir)
d75 2
a76 1
	u_int16_t		 as;
d150 1
a150 1
			as = from->conf.remote_as;
d152 1
a152 1
			new = aspath_prepend(asp->aspath, as, prepend);
d164 25
a188 2
			community_set(asp, set->action.community.as,
			    set->action.community.type);
d216 1
a216 1
    struct bgpd_addr *prefix, u_int8_t plen)
d218 1
d225 24
a248 3
	if (asp != NULL && f->match.community.as != 0)
		if (rde_filter_community(asp, f->match.community.as,
		    f->match.community.type) == 0)
d250 1
@


1.41
log
@Copy AS path in rde_filter() on demand instead of doing it before calling
rde_filter(). Adapt path_update() to this change too. path_update() does
a path_copy before linking the rde_aspath into the RIB. Looks good Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.40 2006/01/10 16:11:12 claudio Exp $ */
d287 1
a287 1
    enum directions dir)
d301 23
@


1.40
log
@The attributes cache broke the set community filterset because community_set()
modified the attribute data directly and corrupted the cache by doing it.
It is no longer allowed to modify attributes via attr_optget() -> change
attr->data. Instead remove the old attribute from the aspath and then add
a new modifed one again. Included in this change is the removal of a "feature"
that allowed only one community per AS. If you had problems to add multiple
communities via filters then this was the problem. Looks good Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.39 2005/12/08 17:17:36 claudio Exp $ */
d33 3
a35 3
rde_filter(struct filter_head *rules, struct rde_peer *peer,
    struct rde_aspath *asp, struct bgpd_addr *prefix, u_int8_t prefixlen,
    struct rde_peer *from, enum directions dir)
d40 3
d53 5
a57 2
			if (asp != NULL)
				rde_apply_set(asp, &f->set, prefix->af,
d59 1
@


1.39
log
@Missing #include <limits.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.38 2005/11/29 20:45:21 claudio Exp $ */
a67 1
	struct attr		*a;
d156 1
a156 8
			if ((a = attr_optget(asp, ATTR_COMMUNITIES)) == NULL) {
				attr_optadd(asp, ATTR_OPTIONAL|ATTR_TRANSITIVE,
				    ATTR_COMMUNITIES, NULL, 0);
				if ((a = attr_optget(asp,
				    ATTR_COMMUNITIES)) == NULL)
					fatalx("internal community bug");
			}
			community_set(a, set->action.community.as,
@


1.38
log
@even more spaces and tabs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.37 2005/11/02 13:19:30 claudio Exp $ */
d21 1
@


1.37
log
@Implement filterset_equal() and rde_filter_equal(). Both return 1 if
the two passed filter(set)s are equal or 0 otherwise. rde_filter_equal()
has an additional argument dir to specify which direction should be considered.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.36 2005/11/01 15:21:54 claudio Exp $ */
d309 1
a309 1
		
d432 1
a432 1
			
d449 1
a449 1
			
@


1.36
log
@Softreconfig out support. On config reload filter changes of outgoing rules
will propagte directly to the neighbors. There is no need to restart bgpd
in that case. Currently not optimal but a good start. "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.35 2005/11/01 10:58:29 claudio Exp $ */
d29 1
d285 40
d345 2
a346 1
 * need some special care.
d376 90
@


1.35
log
@Switch from the per peer filter set list to a filter-only solution.
The default filter_sets are converted into match filter rules that get
evaluated first. Simplifies code massively -- mainly the config reload
part -- and makes softreconfig out a piece of cake.  "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.34 2005/08/10 08:34:06 claudio Exp $ */
a26 2
extern struct filter_head	*rules_l;	/* XXX ugly */

d31 3
a33 3
rde_filter(struct rde_peer *peer, struct rde_aspath *asp,
    struct bgpd_addr *prefix, u_int8_t prefixlen, struct rde_peer *from,
    enum directions dir)
d38 1
a38 1
	TAILQ_FOREACH(f, rules_l, entry) {
@


1.34
log
@Pass the correct peer to rde_apply_set(). rde_apply_set() needs to know
the peer where the prefix came from so that prepend-neighbor works.
Extend rde_filter() and make sure that the correct peer is passed.
Until now most cases resulted in a NULL peer causing a nasty crash that
was found by David Ulevitch. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.33 2005/07/04 09:37:24 claudio Exp $ */
a75 9
		/*
		 * default outgoing overrides are only allowed to
		 * set prepend-self and set nexthop no-modify
		 */
		if (dir == DIR_DEFAULT_OUT &&
		    set->type != ACTION_SET_PREPEND_SELF &&
		    set->type != ACTION_SET_NEXTHOP_NOMODIFY)
			continue;

a133 3
			/* don't apply if this is a incoming default override */
			if (dir == DIR_DEFAULT_IN)
				break;
a152 3
			if (set->type == ACTION_SET_NEXTHOP_NOMODIFY &&
			    dir == DIR_DEFAULT_IN)
				break;
@


1.33
log
@New function filterset_cmp() used two compare two struct filter_set for
equality. This function is a bit more complicated than a memcmp() because there
are types that need to be considered equal e.g. ACTION_SET_MED and
ACTION_SET_RELATIVE_MED. Also ACTION_SET_COMMUNITY and ACTION_SET_NEXTHOP
need some special care.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.32 2005/07/01 22:04:37 claudio Exp $ */
d34 2
a35 1
    struct bgpd_addr *prefix, u_int8_t prefixlen, enum directions dir)
d52 1
a52 1
				    asp->peer, dir);
d64 1
a64 1
    sa_family_t af, struct rde_peer *peer, enum directions dir)
d153 3
a155 1
			as = peer->conf.remote_as;
@


1.32
log
@More spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.31 2005/07/01 13:38:14 claudio Exp $ */
d298 1
d313 35
@


1.31
log
@Switch filter_sets form SIMPLEQ to TAILQ, needed for upcomming stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.30 2005/07/01 12:10:21 claudio Exp $ */
d306 1
a306 1
		       	rtlabel_unref(s->action.id);
a310 1
	
@


1.30
log
@The newly introduced function filterset_free() existed already as
rde_free_set(), I just missed it when I was looking for it.
Kill rde_free_set() and use the more correct filterset_free() from now on.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.29 2005/07/01 09:19:24 claudio Exp $ */
d74 1
a74 1
	SIMPLEQ_FOREACH(set, sh, entry) {
d303 2
a304 2
	while ((s = SIMPLEQ_FIRST(sh)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(sh, entry);
@


1.29
log
@Make the pftable filter set use the name2id "cache" like the route labels.
This saves 14 bytes per aspath. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.28 2005/06/29 09:43:26 claudio Exp $ */
a58 11
}

void
rde_free_set(struct filter_set_head *sh)
{
	struct filter_set	*set;

	while ((set = SIMPLEQ_FIRST(sh)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(sh, entry);
		free(set);
	}
@


1.28
log
@rtlabel support via filter sets. Just use "set rtlabel foobar" in filters
network and neighbor statements and the routes are labeled accordingly.
While doing that fix some mem-leaks by introducing filterset_free() and
remove the free on send option of send_filterset().
This took a bit longer because we need to carefully track the rtlabel id
refcnts or bad things may happen on reloads.
henning@@ looks fine
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.27 2005/04/12 14:32:01 claudio Exp $ */
d191 8
a198 2
			strlcpy(asp->pftable, set->action.pftable,
			    sizeof(asp->pftable));
d318 2
@


1.27
log
@Introduce a per prefix weight.  The weight is used to tip prefixes with equal
long AS pathes in one or the other direction.  It weights a prefix at a very
late stage in the decision process. This is a nice bgpd feature to traffic
engineer networks where most AS pathes are equally long.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.26 2005/03/14 17:32:04 claudio Exp $ */
d194 10
d302 15
@


1.26
log
@Allow to modify the metrics in a relative way by prepending the number with
a '+' or '-'. e.g. set localpref +20. This is another gem from the FOSDEM
lying around on my HD gathering dust. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.25 2005/03/11 12:54:20 claudio Exp $ */
d132 18
@


1.25
log
@Finally commit the transparent-as and nexthop no-modify stuff I wrote on the
way to FOSDEM. With transparent-as set to ye bgpd will not prepend his own
AS for sent updates. NB the neighbor needs to set "enforce neighbor-as no"
or it will not like the received AS paths. With set nexthop no-modify bgpd
will change the nexthop as done normaly.
OK henning@@ man page update with help of jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.24 2005/02/24 17:14:53 claudio Exp $ */
d99 15
d117 16
@


1.24
log
@Add two missing breaks and suddenly using filter has no strange side effects.
Sometimes it is good to look at the rib output of a test box.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.23 2004/12/23 16:09:26 henning Exp $ */
d88 1
a88 1
		 * set prepend-self
d91 2
a92 1
		    set->type != ACTION_SET_PREPEND_SELF)
d123 4
@


1.23
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.22 2004/11/23 13:07:01 claudio Exp $ */
d97 1
d101 1
@


1.22
log
@Switch from a single filter_set to a linked list of sets. With this change
it is possible to specify multiple communities. This is also the first step
to better bgpd filters. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.21 2004/10/08 16:36:42 claudio Exp $ */
d102 1
a102 1
			if (dir == DIR_DEFAULT_IN) 
@


1.21
log
@Don't access pointers blindly. asp is NULL for withdraws. This fixes a rde
crash noticed by Stefan Wahl and later by henning@@. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.20 2004/09/28 14:08:38 henning Exp $ */
d21 1
d62 1
a62 2
rde_apply_set(struct rde_aspath *asp, struct filter_set *set, sa_family_t af,
    struct rde_peer *peer, enum directions dir)
d64 17
a80 3
	struct aspath	*new;
	u_int16_t	 as;
	u_int8_t	 prepend;
d85 1
a85 10
	if (set->flags & SET_PREPEND_SELF && dir != DIR_DEFAULT_IN) {
		/* don't apply if this is a incoming default override */
		as = rde_local_as();
		prepend = set->prepend_self;
		new = aspath_prepend(asp->aspath, as, prepend);
		aspath_put(asp->aspath);
		asp->aspath = new;
	}

	if (dir == DIR_DEFAULT_OUT)
d90 3
a92 18
		return;

	if (set->flags & SET_PREPEND_PEER) {
		as = peer->conf.remote_as;
		prepend = set->prepend_peer;
		new = aspath_prepend(asp->aspath, as, prepend);
		aspath_put(asp->aspath);
		asp->aspath = new;
	}

	if (set->flags & SET_LOCALPREF)
		asp->lpref = set->localpref;
	if (set->flags & SET_MED) {
		asp->flags |= F_ATTR_MED | F_ATTR_MED_ANNOUNCE;
		asp->med = set->med;
	}

	nexthop_modify(asp, &set->nexthop, set->flags, af);
d94 44
a137 10
	if (set->flags & SET_PFTABLE)
		strlcpy(asp->pftable, set->pftable, sizeof(asp->pftable));
	if (set->flags & SET_COMMUNITY) {
		struct attr *a;

		if ((a = attr_optget(asp, ATTR_COMMUNITIES)) == NULL) {
			attr_optadd(asp, ATTR_OPTIONAL|ATTR_TRANSITIVE,
			    ATTR_COMMUNITIES, NULL, 0);
			if ((a = attr_optget(asp, ATTR_COMMUNITIES)) == NULL)
				fatalx("internal community bug");
a138 1
		community_set(a, set->community.as, set->community.type);
@


1.20
log
@one m is enough in incoming, really ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.19 2004/09/28 12:09:31 claudio Exp $ */
d48 3
a50 1
			rde_apply_set(asp, &f->set, prefix->af, asp->peer, dir);
@


1.19
log
@Add prepend-neighbor feature. Prepend the remote-as n times similar to
prepend-self. Only for incomming UPDATEs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.18 2004/08/10 13:02:08 claudio Exp $ */
d70 1
a70 1
		/* don't apply if this is a incomming default override */
@


1.18
log
@switch nexthop in struct filter_set form struct in_addr to struct bgpd_addr
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.17 2004/08/10 12:57:18 claudio Exp $ */
d48 1
a48 1
			rde_apply_set(asp, &f->set, prefix->af);
d59 2
a60 1
rde_apply_set(struct rde_aspath *asp, struct filter_set *set, sa_family_t af)
d64 1
d69 24
a101 6
	if (set->flags & SET_PREPEND) {
		as = rde_local_as();
		new = aspath_prepend(asp->aspath, as, set->prepend);
		aspath_put(asp->aspath);
		asp->aspath = new;
	}
@


1.17
log
@Correctly set the MED in outgoing UPDATEs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.16 2004/08/06 12:04:08 claudio Exp $ */
d48 1
a48 1
			rde_apply_set(asp, &f->set);
d59 1
a59 1
rde_apply_set(struct rde_aspath *asp, struct filter_set *set)
a60 1
	struct bgpd_addr addr;
d74 1
a74 5
	/* XXX and uglier */
	bzero(&addr, sizeof(addr));
	addr.af = AF_INET;
	addr.v4.s_addr = set->nexthop.s_addr;
	nexthop_modify(asp, &addr, set->flags);
@


1.16
log
@Monster diff to get one step closer to IPv6 support.
Cleanup path attribute handling. First of all kill struct attr_flags, all
those infos are now in struct rde_aspath. Second move attribute parser
functions into rde.c, rde_attr.c is shared between bgpd and bgpctl.
Third reimplementation of the nexthop handling. Make it IPv6 ready and
fix some major bug relating to "set nexthop".
henning@@ OK if it breaks nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.15 2004/08/05 18:44:19 claudio Exp $ */
d70 2
a71 1
	if (set->flags & SET_MED)
d73 1
@


1.15
log
@Cleanup aspath specific functions and api. Mainly switch to a refcnt based
allocation. This helps to save a bit of RAM. looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.14 2004/08/05 15:58:21 claudio Exp $ */
d28 1
a28 1
int	rde_filter_match(struct filter_rule *, struct attr_flags *,
d32 1
a32 1
rde_filter(struct rde_peer *peer, struct attr_flags *attrs,
d47 2
a48 2
		if (rde_filter_match(f, attrs, prefix, prefixlen)) {
			rde_apply_set(attrs, &f->set);
d59 1
a59 1
rde_apply_set(struct attr_flags *attrs, struct filter_set *set)
d61 1
d65 1
a65 1
	if (attrs == NULL)
d69 1
a69 1
		attrs->lpref = set->localpref;
d71 8
a78 7
		attrs->med = set->med;
	if (set->flags & SET_NEXTHOP)
		attrs->nexthop = set->nexthop;
	if (set->flags & SET_NEXTHOP_REJECT)
		attrs->nexthop_reject = 1;
	if (set->flags & SET_NEXTHOP_BLACKHOLE)
		attrs->nexthop_blackhole = 1;
d81 3
a83 3
		new = aspath_prepend(attrs->aspath, as, set->prepend);
		aspath_put(attrs->aspath);
		attrs->aspath = new;
d86 1
a86 1
		strlcpy(attrs->pftable, set->pftable, sizeof(attrs->pftable));
d90 2
a91 2
		if ((a = attr_optget(attrs, ATTR_COMMUNITIES)) == NULL) {
			attr_optadd(attrs, ATTR_OPTIONAL|ATTR_TRANSITIVE,
d93 1
a93 1
			if ((a = attr_optget(attrs, ATTR_COMMUNITIES)) == NULL)
d101 1
a101 1
rde_filter_match(struct filter_rule *f, struct attr_flags *attrs,
d105 2
a106 2
	if (attrs != NULL && f->match.as.type != AS_NONE)
		if (aspath_match(attrs->aspath, f->match.as.type,
d110 2
a111 2
	if (attrs != NULL && f->match.community.as != 0)
		if (rde_filter_community(attrs, f->match.community.as,
d183 1
a183 1
rde_filter_community(struct attr_flags *attr, int as, int type)
d187 1
a187 1
	a = attr_optget(attr, ATTR_COMMUNITIES);
@


1.14
log
@rename and move prefix_equal() to prefix_compare() which returns -1, 0, 1
similar to memcmp() and all other compare functions in bgpd. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.13 2004/07/10 10:09:41 claudio Exp $ */
d61 3
d78 4
a81 7
		/*
		 * The actual prepending is done afterwards because
		 * This could overflow but somebody that uses that many
		 * prepends is loony and needs professional help.
		 */
		attrs->aspath->hdr.prepend += set->prepend;
		attrs->aspath->hdr.as_cnt += set->prepend;
@


1.13
log
@Fix reverse logic bug in the prefix filter.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.12 2004/07/05 16:54:53 henning Exp $ */
d115 1
a115 1
		if (!prefix_equal(prefix, &f->match.prefix.addr,
@


1.12
log
@implement "set nexthop blackhole" and "set nexthop reject"
blackhole/reject routes will be entered to the kernel for matching ones.
this is intended to be used with the Cymru Bogon Route Server Project
(http://www.cymru.com/BGP/bogon-rs.html) and similar services, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.11 2004/06/24 23:15:58 claudio Exp $ */
d115 2
a116 2
		if (prefix_equal(prefix, &f->match.prefix.addr,
		    f->match.prefix.len) != 0)
@


1.11
log
@First step at multiprotocol support, only partially done.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.10 2004/06/20 18:35:12 henning Exp $ */
d70 4
@


1.10
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.9 2004/05/17 12:39:32 djm Exp $ */
a97 1
	in_addr_t	mask;
d111 3
a113 10
		switch (f->match.prefix.addr.af) {
		case AF_INET:
			mask = htonl(0xffffffff << (32 - f->match.prefix.len));
			if ((prefix->v4.s_addr & mask) !=
			    (f->match.prefix.addr.v4.s_addr & mask))
				return (0);
			break;
		default:
			fatalx("rde_filter_match: unsupported address family");
		}
@


1.9
log
@extend filter language to allow basic setting of COMMUNITIES attribute.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.8 2004/05/07 10:06:15 djm Exp $ */
d38 1
a38 1
	TAILQ_FOREACH(f, rules_l, entries) {
@


1.8
log
@add a filter option to dump prefixes learned in UPDATEs into a PF table,
intended for building realtime BGP blacklists (e.g. with spamd);
ok claudio & henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.7 2004/03/11 17:12:51 claudio Exp $ */
d81 11
@


1.7
log
@Add basic support for communities. Currently it is only possible to filter
on communities, e.g match from any community 24640:* set localpref 666
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.6 2004/03/02 19:29:01 claudio Exp $ */
d21 2
d79 2
@


1.6
log
@Framework for rib lookups by prefix. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.5 2004/03/01 23:07:09 deraadt Exp $ */
d90 5
d167 13
@


1.5
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.4 2004/02/27 20:53:56 claudio Exp $ */
d94 1
a94 2
			mask = 0xffffffff << (32 - f->match.prefix.len);
			mask = htonl(mask);
@


1.4
log
@remove unneded peer pointer in struct prefix and change a in_addr_t to
struct in_addr. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.3 2004/02/24 15:44:33 claudio Exp $ */
d70 1
a70 1
		 * The acctual prepending is done afterwards because 
@


1.3
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.2 2004/02/24 15:43:03 claudio Exp $ */
d67 1
a67 2
		/* TODO switch attr->nexthop to struct in_addr */
		attrs->nexthop = set->nexthop.s_addr;
@


1.2
log
@Enhance filters. prefixlen knows now 8-24 and 8><24. It is possible to use
prefix 10.0.0.0/8 prefixlen >= 8 and set localpref 100 can be set on a per
neighbor basis. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_filter.c,v 1.1 2004/02/19 23:07:00 claudio Exp $ */
d35 1
a35 1
	
d104 1
a104 1
		
d161 1
a161 1
	
@


1.1
log
@Add support for basic filters. Nothing optimized and it has some issues but
this is a huge step forward. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d113 3
d132 5
a136 4
		/*
		 * XXX IPv4 and IPv6 will cause trouble here.
		 * XXX need to store the af.
		 */
d143 3
@

