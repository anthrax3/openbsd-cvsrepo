head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.4
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.14.0.8
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.6
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.4
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.1.0.6
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.4
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.2
	OPENBSD_3_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.25
date	2017.05.31.10.44.00;	author claudio;	state Exp;
branches;
next	1.24;
commitid	tiSkyeLqu7f48PM9;

1.24
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.23;
commitid	airB1W2Kb948lFil;

1.23
date	2017.01.23.23.30.43;	author claudio;	state Exp;
branches;
next	1.22;
commitid	uZPjKpz2oUA9XVbA;

1.22
date	2017.01.13.18.59.12;	author phessler;	state Exp;
branches;
next	1.21;
commitid	3Jvf15B19ysa8i2W;

1.21
date	2016.06.03.17.36.37;	author benno;	state Exp;
branches;
next	1.20;
commitid	utIafqBHH3dRVCSC;

1.20
date	2015.10.24.08.00.42;	author claudio;	state Exp;
branches;
next	1.19;
commitid	1yCmxaushtq2mDqP;

1.19
date	2014.11.11.08.02.09;	author claudio;	state Exp;
branches;
next	1.18;
commitid	2mDkYLZu3al6n22m;

1.18
date	2014.11.11.07.15.33;	author phessler;	state Exp;
branches;
next	1.17;
commitid	R92Wuod9ZhSCe9pb;

1.17
date	2013.10.30.17.28.33;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.19.15.04.26;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2013.09.27.08.23.11;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.20.21.19.07;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.18.12.18.31;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.24.17.19.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.29.09.04.43;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.13.06.02.37;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2009.12.16.15.40.55;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2009.12.08.14.03.40;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.12.16.42.53;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.06.21.16.27;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2008.03.17.20.40.04;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.11.11.27.59;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.03.22.19.59;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Rework the way we do extended communities (mainly in the parser) and update
the IANA table to a somewhat more complete list. This includes BGP Prefix
Origin Validation State support via the ext-community ovs keyword.
OK henning@@ benno@@ based on a diff by Job Snijders
@
text
@/*	$OpenBSD: util.c,v 1.24 2017/01/24 04:22:42 benno Exp $ */

/*
 * Copyright (c) 2006 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <vis.h>

#include "bgpd.h"
#include "rde.h"
#include "log.h"

const char	*aspath_delim(u_int8_t, int);

const char *
log_addr(const struct bgpd_addr *addr)
{
	static char	buf[48];
	char		tbuf[16];

	switch (addr->aid) {
	case AID_INET:
	case AID_INET6:
		if (inet_ntop(aid2af(addr->aid), &addr->ba, buf,
		    sizeof(buf)) == NULL)
			return ("?");
		return (buf);
	case AID_VPN_IPv4:
		if (inet_ntop(AF_INET, &addr->vpn4.addr, tbuf,
		    sizeof(tbuf)) == NULL)
			return ("?");
		snprintf(buf, sizeof(buf), "%s %s", log_rd(addr->vpn4.rd),
		   tbuf);
		return (buf);
	}
	return ("???");
}

const char *
log_in6addr(const struct in6_addr *addr)
{
	struct sockaddr_in6	sa_in6;
	u_int16_t		tmp16;

	bzero(&sa_in6, sizeof(sa_in6));
	sa_in6.sin6_len = sizeof(sa_in6);
	sa_in6.sin6_family = AF_INET6;
	memcpy(&sa_in6.sin6_addr, addr, sizeof(sa_in6.sin6_addr));

	/* XXX thanks, KAME, for this ugliness... adopted from route/show.c */
	if (IN6_IS_ADDR_LINKLOCAL(&sa_in6.sin6_addr) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&sa_in6.sin6_addr)) {
		memcpy(&tmp16, &sa_in6.sin6_addr.s6_addr[2], sizeof(tmp16));
		sa_in6.sin6_scope_id = ntohs(tmp16);
		sa_in6.sin6_addr.s6_addr[2] = 0;
		sa_in6.sin6_addr.s6_addr[3] = 0;
	}

	return (log_sockaddr((struct sockaddr *)&sa_in6));
}

const char *
log_sockaddr(struct sockaddr *sa)
{
	static char	buf[NI_MAXHOST];

	if (getnameinfo(sa, sa->sa_len, buf, sizeof(buf), NULL, 0,
	    NI_NUMERICHOST))
		return ("(unknown)");
	else
		return (buf);
}

const char *
log_as(u_int32_t as)
{
	static char	buf[11];	/* "4294967294\0" */

	if (snprintf(buf, sizeof(buf), "%u", as) == -1)
		return ("?");

	return (buf);
}

const char *
log_rd(u_int64_t rd)
{
	static char	buf[32];
	struct in_addr	addr;
	u_int32_t	u32;
	u_int16_t	u16;

	rd = betoh64(rd);
	switch (rd >> 48) {
	case EXT_COMMUNITY_TRANS_TWO_AS:
		u32 = rd & 0xffffffff;
		u16 = (rd >> 32) & 0xffff;
		snprintf(buf, sizeof(buf), "rd %hu:%u", u16, u32);
		break;
	case EXT_COMMUNITY_TRANS_FOUR_AS:
		u32 = (rd >> 16) & 0xffffffff;
		u16 = rd & 0xffff;
		snprintf(buf, sizeof(buf), "rd %s:%hu", log_as(u32), u16);
		break;
	case EXT_COMMUNITY_TRANS_IPV4:
		u32 = (rd >> 16) & 0xffffffff;
		u16 = rd & 0xffff;
		addr.s_addr = htonl(u32);
		snprintf(buf, sizeof(buf), "rd %s:%hu", inet_ntoa(addr), u16);
		break;
	default:
		return ("rd ?");
	}
	return (buf);
}

const struct ext_comm_pairs iana_ext_comms[] = IANA_EXT_COMMUNITIES;

/* NOTE: this function does not check if the type/subtype combo is
 * actually valid. */
const char *
log_ext_subtype(u_int8_t type, u_int8_t subtype)
{
	static char etype[6];
	const struct ext_comm_pairs *cp;

	for (cp = iana_ext_comms; cp->subname != NULL; cp++) {
		if (type == cp->type && subtype == cp->subtype)
			return (cp->subname);
	}
	snprintf(etype, sizeof(etype), "[%u]", subtype);
	return (etype);
}

const char *
log_shutcomm(const char *communication) {
	static char buf[(SHUT_COMM_LEN - 1) * 4 + 1];

	strnvis(buf, communication, sizeof(buf), VIS_NL | VIS_OCTAL);

	return buf;
}

const char *
aspath_delim(u_int8_t seg_type, int closing)
{
	static char db[8];

	switch (seg_type) {
	case AS_SET:
		if (!closing)
			return ("{ ");
		else
			return (" }");
	case AS_SEQUENCE:
		return ("");
	case AS_CONFED_SEQUENCE:
		if (!closing)
			return ("( ");
		else
			return (" )");
	case AS_CONFED_SET:
		if (!closing)
			return ("[ ");
		else
			return (" ]");
	default:
		if (!closing)
			snprintf(db, sizeof(db), "!%u ", seg_type);
		else
			snprintf(db, sizeof(db), " !%u", seg_type);
		return (db);
	}
}

int
aspath_snprint(char *buf, size_t size, void *data, u_int16_t len)
{
#define UPDATE()				\
	do {					\
		if (r == -1)			\
			return (-1);		\
		total_size += r;		\
		if ((unsigned int)r < size) {	\
			size -= r;		\
			buf += r;		\
		} else {			\
			buf += size;		\
			size = 0;		\
		}				\
	} while (0)
	u_int8_t	*seg;
	int		 r, total_size;
	u_int16_t	 seg_size;
	u_int8_t	 i, seg_type, seg_len;

	total_size = 0;
	seg = data;
	for (; len > 0; len -= seg_size, seg += seg_size) {
		seg_type = seg[0];
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;

		r = snprintf(buf, size, "%s%s",
		    total_size != 0 ? " " : "",
		    aspath_delim(seg_type, 0));
		UPDATE();

		for (i = 0; i < seg_len; i++) {
			r = snprintf(buf, size, "%s",
			    log_as(aspath_extract(seg, i)));
			UPDATE();
			if (i + 1 < seg_len) {
				r = snprintf(buf, size, " ");
				UPDATE();
			}
		}
		r = snprintf(buf, size, "%s", aspath_delim(seg_type, 1));
		UPDATE();
	}
	/* ensure that we have a valid C-string especially for empty as path */
	if (size > 0)
		*buf = '\0';

	return (total_size);
#undef UPDATE
}

int
aspath_asprint(char **ret, void *data, u_int16_t len)
{
	size_t	slen;
	int	plen;

	slen = aspath_strlen(data, len) + 1;
	*ret = malloc(slen);
	if (*ret == NULL)
		return (-1);

	plen = aspath_snprint(*ret, slen, data, len);
	if (plen == -1) {
		free(*ret);
		*ret = NULL;
		return (-1);
	}

	return (0);
}

size_t
aspath_strlen(void *data, u_int16_t len)
{
	u_int8_t	*seg;
	int		 total_size;
	u_int32_t	 as;
	u_int16_t	 seg_size;
	u_int8_t	 i, seg_type, seg_len;

	total_size = 0;
	seg = data;
	for (; len > 0; len -= seg_size, seg += seg_size) {
		seg_type = seg[0];
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;

		if (seg_type == AS_SET)
			if (total_size != 0)
				total_size += 3;
			else
				total_size += 2;
		else if (total_size != 0)
			total_size += 1;

		for (i = 0; i < seg_len; i++) {
			as = aspath_extract(seg, i);

			do {
				total_size++;
			} while ((as = as / 10) != 0);

			if (i + 1 < seg_len)
				total_size += 1;
		}

		if (seg_type == AS_SET)
			total_size += 2;
	}
	return (total_size);
}

/* we need to be able to search more than one as */
int
aspath_match(void *data, u_int16_t len, struct filter_as *f, u_int32_t match)
{
	u_int8_t	*seg;
	int		 final;
	u_int16_t	 seg_size;
	u_int8_t	 i, seg_len;
	u_int32_t	 as;

	if (f->type == AS_EMPTY) {
		if (len == 0)
			return (1);
		else
			return (0);
	}

	seg = data;
	for (; len > 0; len -= seg_size, seg += seg_size) {
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;

		final = (len == seg_size);

		/* just check the first (leftmost) AS */
		if (f->type == AS_PEER) {
			as = aspath_extract(seg, 0);
			if (as_compare(f->op, as, match, f->as_min, f->as_max))
				return (1);
			else
				return (0);
		}
		/* just check the final (rightmost) AS */
		if (f->type == AS_SOURCE) {
			/* not yet in the final segment */
			if (!final)
				continue;
			as = aspath_extract(seg, seg_len - 1);
			if (as_compare(f->op, as, match, f->as_min, f->as_max))
				return (1);
			else
				return (0);
		}
		/* AS_TRANSIT or AS_ALL */
		for (i = 0; i < seg_len; i++) {
			/*
			 * the source (rightmost) AS is excluded from
			 * AS_TRANSIT matches.
			 */
			if (final && i == seg_len - 1 && f->type == AS_TRANSIT)
				return (0);
			as = aspath_extract(seg, i);
			if (as_compare(f->op, as, match, f->as_min, f->as_max))
				return (1);
		}
	}
	return (0);
}

int
as_compare(u_int8_t op, u_int32_t as, u_int32_t match, u_int32_t as_min,
    u_int32_t as_max)
{
	if ((op == OP_NONE || op == OP_EQ) && as == match)
		return (1);
	else if (op == OP_NE && as != match)
		return (1);
	else if (op == OP_RANGE && as >= as_min && as <= as_max)
		return (1);
	else if (op == OP_XRANGE && as > as_min && as < as_max)
		return (1);
	return (0);
}

/*
 * Extract the asnum out of the as segment at the specified position.
 * Direct access is not possible because of non-aligned reads.
 * ATTENTION: no bounds checks are done.
 */
u_int32_t
aspath_extract(const void *seg, int pos)
{
	const u_char	*ptr = seg;
	u_int32_t	 as;

	ptr += 2 + sizeof(u_int32_t) * pos;
	memcpy(&as, ptr, sizeof(u_int32_t));
	return (ntohl(as));
}

/*
 * This function will have undefined behaviour if the passed in prefixlen is
 * to large for the respective bgpd_addr address family.
 */
int
prefix_compare(const struct bgpd_addr *a, const struct bgpd_addr *b,
    int prefixlen)
{
	in_addr_t	mask, aa, ba;
	int		i;
	u_int8_t	m;

	if (a->aid != b->aid)
		return (a->aid - b->aid);

	switch (a->aid) {
	case AID_INET:
		if (prefixlen == 0)
			return (0);
		if (prefixlen > 32)
			return (-1);
		mask = htonl(prefixlen2mask(prefixlen));
		aa = ntohl(a->v4.s_addr & mask);
		ba = ntohl(b->v4.s_addr & mask);
		if (aa != ba)
			return (aa - ba);
		return (0);
	case AID_INET6:
		if (prefixlen == 0)
			return (0);
		if (prefixlen > 128)
			return (-1);
		for (i = 0; i < prefixlen / 8; i++)
			if (a->v6.s6_addr[i] != b->v6.s6_addr[i])
				return (a->v6.s6_addr[i] - b->v6.s6_addr[i]);
		i = prefixlen % 8;
		if (i) {
			m = 0xff00 >> i;
			if ((a->v6.s6_addr[prefixlen / 8] & m) !=
			    (b->v6.s6_addr[prefixlen / 8] & m))
				return ((a->v6.s6_addr[prefixlen / 8] & m) -
				    (b->v6.s6_addr[prefixlen / 8] & m));
		}
		return (0);
	case AID_VPN_IPv4:
		if (prefixlen > 32)
			return (-1);
		if (betoh64(a->vpn4.rd) > betoh64(b->vpn4.rd))
			return (1);
		if (betoh64(a->vpn4.rd) < betoh64(b->vpn4.rd))
			return (-1);
		mask = htonl(prefixlen2mask(prefixlen));
		aa = ntohl(a->vpn4.addr.s_addr & mask);
		ba = ntohl(b->vpn4.addr.s_addr & mask);
		if (aa != ba)
			return (aa - ba);
		if (a->vpn4.labellen > b->vpn4.labellen)
			return (1);
		if (a->vpn4.labellen < b->vpn4.labellen)
			return (-1);
		return (memcmp(a->vpn4.labelstack, b->vpn4.labelstack,
		    a->vpn4.labellen));
	}
	return (-1);
}

in_addr_t
prefixlen2mask(u_int8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	return (0xffffffff << (32 - prefixlen));
}

void
inet6applymask(struct in6_addr *dest, const struct in6_addr *src, int prefixlen)
{
	struct in6_addr	mask;
	int		i;

	bzero(&mask, sizeof(mask));
	for (i = 0; i < prefixlen / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

	for (i = 0; i < 16; i++)
		dest->s6_addr[i] = src->s6_addr[i] & mask.s6_addr[i];
}

/* address family translation functions */
const struct aid aid_vals[AID_MAX] = AID_VALS;

const char *
aid2str(u_int8_t aid)
{
	if (aid < AID_MAX)
		return (aid_vals[aid].name);
	return ("unknown AID");
}

int
aid2afi(u_int8_t aid, u_int16_t *afi, u_int8_t *safi)
{
	if (aid < AID_MAX) {
		*afi = aid_vals[aid].afi;
		*safi = aid_vals[aid].safi;
		return (0);
	}
	return (-1);
}

int
afi2aid(u_int16_t afi, u_int8_t safi, u_int8_t *aid)
{
	u_int8_t i;

	for (i = 0; i < AID_MAX; i++)
		if (aid_vals[i].afi == afi && aid_vals[i].safi == safi) {
			*aid = i;
			return (0);
		}

	return (-1);
}

sa_family_t
aid2af(u_int8_t aid)
{
	if (aid < AID_MAX)
		return (aid_vals[aid].af);
	return (AF_UNSPEC);
}

int
af2aid(sa_family_t af, u_int8_t safi, u_int8_t *aid)
{
	u_int8_t i;

	if (safi == 0) /* default to unicast subclass */
		safi = SAFI_UNICAST;

	for (i = 0; i < AID_MAX; i++)
		if (aid_vals[i].af == af && aid_vals[i].safi == safi) {
			*aid = i;
			return (0);
		}

	return (-1);
}

struct sockaddr *
addr2sa(struct bgpd_addr *addr, u_int16_t port)
{
	static struct sockaddr_storage	 ss;
	struct sockaddr_in		*sa_in = (struct sockaddr_in *)&ss;
	struct sockaddr_in6		*sa_in6 = (struct sockaddr_in6 *)&ss;

	if (addr->aid == AID_UNSPEC)
		return (NULL);

	bzero(&ss, sizeof(ss));
	switch (addr->aid) {
	case AID_INET:
		sa_in->sin_family = AF_INET;
		sa_in->sin_len = sizeof(struct sockaddr_in);
		sa_in->sin_addr.s_addr = addr->v4.s_addr;
		sa_in->sin_port = htons(port);
		break;
	case AID_INET6:
		sa_in6->sin6_family = AF_INET6;
		sa_in6->sin6_len = sizeof(struct sockaddr_in6);
		memcpy(&sa_in6->sin6_addr, &addr->v6,
		    sizeof(sa_in6->sin6_addr));
		sa_in6->sin6_port = htons(port);
		sa_in6->sin6_scope_id = addr->scope_id;
		break;
	}

	return ((struct sockaddr *)&ss);
}

void
sa2addr(struct sockaddr *sa, struct bgpd_addr *addr)
{
	struct sockaddr_in		*sa_in = (struct sockaddr_in *)sa;
	struct sockaddr_in6		*sa_in6 = (struct sockaddr_in6 *)sa;

	bzero(addr, sizeof(*addr));
	switch (sa->sa_family) {
	case AF_INET:
		addr->aid = AID_INET;
		memcpy(&addr->v4, &sa_in->sin_addr, sizeof(addr->v4));
		break;
	case AF_INET6:
		addr->aid = AID_INET6;
		memcpy(&addr->v6, &sa_in6->sin6_addr, sizeof(addr->v6));
		addr->scope_id = sa_in6->sin6_scope_id; /* I hate v6 */
		break;
	}
}
@


1.24
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2017/01/23 23:30:43 claudio Exp $ */
d115 1
a115 1
	case EXT_COMMUNITY_TWO_AS:
d120 1
a120 1
	case EXT_COMMUNITY_FOUR_AS:
d125 1
a125 1
	case EXT_COMMUNITY_IPV4:
d137 2
d142 1
a142 1
log_ext_subtype(u_int8_t subtype)
d145 1
d147 3
a149 16
	switch (subtype) {
	case EXT_COMMUNITY_ROUTE_TGT:
		return ("rt");	/* route target */
	case EXT_COMMUNITY_ROUTE_ORIG:
		return ("soo");	/* source of origin */
	case EXT_COMMUNITY_OSPF_DOM_ID:
		return ("odi");	/* ospf domain id */
	case EXT_COMMUNITY_OSPF_RTR_TYPE:
		return ("ort");	/* ospf route type */
	case EXT_COMMUNITY_OSPF_RTR_ID:
		return ("ori");	/* ospf router id */
	case EXT_COMMUNITY_BGP_COLLECT:
		return ("bdc");	/* bgp data collection */
	default:
		snprintf(etype, sizeof(etype), "[%u]", subtype);
		return (etype);
d151 2
@


1.23
log
@Make util.c fatal() free by allowing undefined behaviour in prefix_compare.
If you pass in crap then you will not get gold back.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2017/01/13 18:59:12 phessler Exp $ */
d31 1
@


1.22
log
@Add support for draft-ietf-idr-shutdown

    BGP state = Idle, marked down with shutdown reason "goodbye, we are
    upgrading to openbsd 6.1", down for 00:00:17

developed by Peter van Dijk <peter.van.dijk@@powerdns.com> and Job
Snijders <job@@ntt.net>, thank you!

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2016/06/03 17:36:37 benno Exp $ */
d408 4
d428 1
a428 1
			fatalx("prefix_cmp: bad IPv4 prefixlen");
d439 1
a439 1
			fatalx("prefix_cmp: bad IPv6 prefixlen");
d454 1
a454 1
			fatalx("prefix_cmp: bad IPv4 VPN prefixlen");
a469 2
	default:
		fatalx("prefix_cmp: unknown af");
@


1.21
log
@Add operators =, !=, - (range), >< (exclsive range) to the as-path
filters (AS, peer-as, source-as, transit-as).

Add a use case (block illegal AS numbers) to the bgpd.conf example.

feedback from claudio, sthen, florian,
ok florian@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2015/10/24 08:00:42 claudio Exp $ */
d27 1
d160 9
@


1.20
log
@seg_type is only set but never used. So remove it. Someone reported this
long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2014/11/11 08:02:09 claudio Exp $ */
d310 1
a310 1
aspath_match(void *data, u_int16_t len, enum as_spec type, u_int32_t as)
d316 1
d318 1
a318 1
	if (type == AS_EMPTY) {
d333 3
a335 2
		if (type == AS_PEER) {
			if (as == aspath_extract(seg, 0))
d341 1
a341 1
		if (type == AS_SOURCE) {
d345 2
a346 2

			if (as == aspath_extract(seg, seg_len - 1))
a350 1

d353 8
a360 8
			if (as == aspath_extract(seg, i)) {
				/*
				 * the source (rightmost) AS is excluded from
				 * AS_TRANSIT matches.
				 */
				if (final && i == seg_len - 1 &&
				    type == AS_TRANSIT)
					return (0);
a361 1
			}
d364 15
@


1.19
log
@Adjust aspath_strlen() since the output format changed to ASPLAIN.
This should return the proper length again.
OK phessler, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2014/11/11 07:15:33 phessler Exp $ */
d315 1
a315 1
	u_int8_t	 i, seg_type, seg_len;
a323 1
	final = 0;
a325 1
		seg_type = seg[0];
@


1.18
log
@The default output format for 32bit AS numbers has moved from AS_DOT+
to ASPLAIN.

Of course, you can still input AS numbers in either format.

OK henning@@, claudio@@, benno@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2013/10/30 17:28:33 deraadt Exp $ */
a292 2
			if (as > USHRT_MAX) {
				u_int32_t	a = as >> 16;
d294 3
a296 23
				if (a >= 10000)
					total_size += 5;
				else if (a >= 1000)
					total_size += 4;
				else if (a >= 100)
					total_size += 3;
				else if (a >= 10)
					total_size += 2;
				else
					total_size += 1;
				total_size += 1; /* dot between hi & lo */
				as &= 0xffff;
			}
			if (as >= 10000)
				total_size += 5;
			else if (as >= 1000)
				total_size += 4;
			else if (as >= 100)
				total_size += 3;
			else if (as >= 10)
				total_size += 2;
			else
				total_size += 1;
@


1.17
log
@use more careful format strings to deal with various forms of AS#'s
ok claudio benno
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2013/10/19 15:04:26 claudio Exp $ */
d95 4
a98 1
	static char	buf[12];	/* "65000.65000\0" */
a99 8
	if (as <= USHRT_MAX) {
		if (snprintf(buf, sizeof(buf), "%u", as) == -1)
			return ("?");
	} else {
		if (snprintf(buf, sizeof(buf), "%u.%u", as >> 16,
		    as & 0xffff) == -1)
			return ("?");
	}
@


1.16
log
@Merge the prefix and prefixlen filter bits into one filter. Change the
filter expansion so that rules are grouped by prefixes last. The RDE will
then be able to optimize the rules into table lookups but that is a later
step. As additional goodies it is now possible to use inet and inet6
on their own and or-longer can be used as a shorthand for prefixlen >= len.
OK henning@@ sthen@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2013/09/27 08:23:11 sthen Exp $ */
d121 1
a121 1
		snprintf(buf, sizeof(buf), "rd %i:%i", u16, u32);
d126 1
a126 1
		snprintf(buf, sizeof(buf), "rd %s:%i", log_as(u32), u16);
d132 1
a132 1
		snprintf(buf, sizeof(buf), "rd %s:%i", inet_ntoa(addr), u16);
@


1.15
log
@typo in macro name; no md5 change
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 2011/09/20 21:19:07 claudio Exp $ */
d425 2
d436 2
@


1.14
log
@Move a few functions into util.c because bgpctl will need them soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.13 2010/11/18 12:18:31 claudio Exp $ */
d150 1
a150 1
	case EXT_CUMMUNITY_ROUTE_ORIG:
@


1.13
log
@Accept but ignore (treat as withdraw) updates with AS_CONFED_* path
segments. Bgpd does not support confederations but it is too extreme
to close a session because a path contained such elements.
OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2010/10/24 17:19:35 deraadt Exp $ */
d335 61
d410 60
@


1.12
log
@the subtype should be printed unsigned; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2010/03/29 09:04:43 claudio Exp $ */
d31 2
d166 32
d226 4
a229 10
		if (seg_type == AS_SET) {
			if (total_size != 0)
				r = snprintf(buf, size, " { ");
			else
				r = snprintf(buf, size, "{ ");
			UPDATE();
		} else if (total_size != 0) {
			r = snprintf(buf, size, " ");
			UPDATE();
		}
d240 2
a241 4
		if (seg_type == AS_SET) {
			r = snprintf(buf, size, " }");
			UPDATE();
		}
@


1.11
log
@Implement a log_rd() function to print the route destinguisher in a nice
way. Use it for now in log_addr() to show VPN routes with a prepended RD.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 2010/01/13 06:02:37 claudio Exp $ */
d159 1
a159 1
		snprintf(etype, sizeof(etype), "[%i]", (int)subtype);
@


1.10
log
@Add support for BGP MPLS VPN aka RFC 4364. This is only the RDE part so
that it is possible to use OpenBGPD as a route-reflector for VPNv4.
Some clean up of the BGP MP code so that multiple protocols are easier
supported. kroute/kernel support not yet done but comming.
OK henning@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 2009/12/16 15:40:55 claudio Exp $ */
d35 1
d45 2
a46 2
		if (inet_ntop(AF_INET, &addr->vpn4.addr, buf,
		    sizeof(buf)) == NULL)
d48 2
d106 33
a138 1
/* XXX this function does not check if the type/subtype combo is
@


1.9
log
@Implement "set ext-community [delete] subtype key:value" to set and delete
extended communities as specified in RFC 4360. No matching implemented yet
and stuff like * and neighbor-as are neither supported but will be soon.
Looks good henning & sthen, manpage fixed by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.8 2009/12/08 14:03:40 claudio Exp $ */
d36 6
a41 3
	if (inet_ntop(aid2af(addr->aid), &addr->ba, buf, sizeof(buf)) == NULL)
		return ("?");
	else
d43 7
@


1.8
log
@Big AID change part two. This changes the mp capability into an array of
flags. This makes a lot of code much easier since the comparison is now
trivial. Additionally calculate the negotiated capabilities for a session
in the SE and pass that and only that to the RDE. This makes the decisions
in the RDE a lot easier.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.7 2009/12/01 14:28:05 claudio Exp $ */
d91 26
@


1.7
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.6 2009/06/12 16:42:53 claudio Exp $ */
d282 8
@


1.6
log
@Move prefixlen2mask and inet6applymask to util.c so that we can kill the
copies in bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.5 2008/11/06 21:16:27 claudio Exp $ */
d36 1
a36 1
	if (inet_ntop(addr->af, &addr->ba, buf, sizeof(buf)) == NULL)
d278 104
@


1.5
log
@Mixed up characters found by Gleydson Soares.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.4 2008/03/17 20:40:04 henning Exp $ */
d252 26
@


1.4
log
@two small bugs in printing funcs:
log_as < vs <= confusion, AS 65535 printed like 4 byte AS 0.65535
aspath_strlen: omitted stripping high 16 bits of 32bit AS after dealing
with the upper half
From: Matthew Dempsky <matthew@@dempsky.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.3 2007/05/11 11:27:59 claudio Exp $ */
d146 1
a146 1
	/* ensure that we have a valid C-string especially for emtpy as path */
@


1.3
log
@Various spelling fixes from Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.2 2007/04/23 13:04:24 claudio Exp $ */
d82 1
a82 1
	if (as < USHRT_MAX) {
d215 1
@


1.2
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.1 2006/01/03 22:19:59 claudio Exp $ */
d240 1
a240 1
 * ATTENTION: no bounds check are done.
@


1.1
log
@Move functions shared with bgpctl into new file util.c. Simplifies the
link between bgpctl and bgpd mostly because of rde_attr.c.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d77 16
d119 1
a119 1
		seg_size = 2 + 2 * seg_len;
d133 2
a134 1
			r = snprintf(buf, size, "%hu", aspath_extract(seg, i));
d180 2
a181 1
	u_int16_t	 as, seg_size;
d189 1
a189 1
		seg_size = 2 + 2 * seg_len;
d201 15
d242 1
a242 1
u_int16_t
d246 1
a246 1
	u_int16_t	 as = 0;
d248 3
a250 5
	ptr += 2 + 2 * pos;
	as = *ptr++;
	as <<= 8;
	as |= *ptr;
	return (as);
a251 1

@

