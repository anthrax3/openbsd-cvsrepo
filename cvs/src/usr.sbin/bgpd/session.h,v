head	1.123;
access;
symbols
	OPENBSD_6_1:1.122.0.4
	OPENBSD_6_1_BASE:1.122
	OPENBSD_6_0:1.121.0.6
	OPENBSD_6_0_BASE:1.121
	OPENBSD_5_9:1.121.0.2
	OPENBSD_5_9_BASE:1.121
	OPENBSD_5_8:1.119.0.4
	OPENBSD_5_8_BASE:1.119
	OPENBSD_5_7:1.117.0.2
	OPENBSD_5_7_BASE:1.117
	OPENBSD_5_6:1.116.0.8
	OPENBSD_5_6_BASE:1.116
	OPENBSD_5_5:1.116.0.6
	OPENBSD_5_5_BASE:1.116
	OPENBSD_5_4:1.116.0.2
	OPENBSD_5_4_BASE:1.116
	OPENBSD_5_3:1.114.0.2
	OPENBSD_5_3_BASE:1.114
	OPENBSD_5_2:1.113.0.2
	OPENBSD_5_2_BASE:1.113
	OPENBSD_5_1_BASE:1.112
	OPENBSD_5_1:1.112.0.2
	OPENBSD_5_0:1.111.0.4
	OPENBSD_5_0_BASE:1.111
	OPENBSD_4_9:1.111.0.2
	OPENBSD_4_9_BASE:1.111
	OPENBSD_4_8:1.108.0.2
	OPENBSD_4_8_BASE:1.108
	OPENBSD_4_7:1.104.0.2
	OPENBSD_4_7_BASE:1.104
	OPENBSD_4_6:1.101.0.4
	OPENBSD_4_6_BASE:1.101
	OPENBSD_4_5:1.99.0.2
	OPENBSD_4_5_BASE:1.99
	OPENBSD_4_4:1.98.0.2
	OPENBSD_4_4_BASE:1.98
	OPENBSD_4_3:1.95.0.2
	OPENBSD_4_3_BASE:1.95
	OPENBSD_4_2:1.92.0.2
	OPENBSD_4_2_BASE:1.92
	OPENBSD_4_1:1.90.0.2
	OPENBSD_4_1_BASE:1.90
	OPENBSD_4_0:1.86.0.2
	OPENBSD_4_0_BASE:1.86
	OPENBSD_3_9:1.81.0.2
	OPENBSD_3_9_BASE:1.81
	OPENBSD_3_8:1.77.0.2
	OPENBSD_3_8_BASE:1.77
	OPENBSD_3_7:1.75.0.2
	OPENBSD_3_7_BASE:1.75
	OPENBSD_3_6:1.61.0.2
	OPENBSD_3_6_BASE:1.61
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39;
locks; strict;
comment	@ * @;


1.123
date	2017.05.28.12.21.36;	author claudio;	state Exp;
branches;
next	1.122;
commitid	FWHn2FssuHSixuVj;

1.122
date	2017.01.13.18.59.12;	author phessler;	state Exp;
branches;
next	1.121;
commitid	3Jvf15B19ysa8i2W;

1.121
date	2015.10.25.18.49.01;	author claudio;	state Exp;
branches;
next	1.120;
commitid	CFOjjrz5XQ5AoRFX;

1.120
date	2015.10.11.19.25.06;	author phessler;	state Exp;
branches;
next	1.119;
commitid	hr8Ej7hOjow0btND;

1.119
date	2015.07.20.16.10.38;	author claudio;	state Exp;
branches;
next	1.118;
commitid	JXdI3dG8XAYCUdaO;

1.118
date	2015.07.16.18.26.04;	author claudio;	state Exp;
branches;
next	1.117;
commitid	LqSO5lx1xfCVcctP;

1.117
date	2015.02.09.11.37.31;	author claudio;	state Exp;
branches;
next	1.116;
commitid	IcuyF0sCmFRE7OTK;

1.116
date	2013.05.30.20.29.27;	author florian;	state Exp;
branches;
next	1.115;

1.115
date	2013.03.07.21.26.28;	author claudio;	state Exp;
branches;
next	1.114;

1.114
date	2012.09.12.05.56.22;	author claudio;	state Exp;
branches;
next	1.113;

1.113
date	2012.04.12.17.26.09;	author claudio;	state Exp;
branches;
next	1.112;

1.112
date	2011.09.18.09.31.25;	author claudio;	state Exp;
branches;
next	1.111;

1.111
date	2010.12.09.13.50.41;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2010.11.18.12.51.25;	author claudio;	state Exp;
branches;
next	1.109;

1.109
date	2010.10.15.07.45.32;	author claudio;	state Exp;
branches;
next	1.108;

1.108
date	2010.06.27.19.53.34;	author claudio;	state Exp;
branches;
next	1.107;

1.107
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.106;

1.106
date	2010.05.17.15.49.29;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.104;

1.104
date	2009.12.31.15.34.02;	author claudio;	state Exp;
branches;
next	1.103;

1.103
date	2009.12.08.14.03.40;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2009.09.02.08.06.42;	author claudio;	state Exp;
branches;
next	1.101;

1.101
date	2009.06.05.20.26.38;	author claudio;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.04.04.46.42;	author claudio;	state Exp;
branches;
next	1.99;

1.99
date	2008.09.11.14.49.58;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2008.05.08.09.53.12;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2008.05.08.07.43.03;	author henning;	state Exp;
branches;
next	1.96;

1.96
date	2008.05.08.06.52.13;	author henning;	state Exp;
branches;
next	1.95;

1.95
date	2007.12.23.18.56.17;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2007.12.23.18.26.13;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2007.12.20.17.08.48;	author henning;	state Exp;
branches;
next	1.92;

1.92
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2007.04.06.18.03.51;	author claudio;	state Exp;
branches;
next	1.90;

1.90
date	2007.01.26.17.40.49;	author claudio;	state Exp;
branches;
next	1.89;

1.89
date	2007.01.04.12.43.36;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2006.10.26.14.26.49;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2006.10.26.13.17.00;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2006.08.27.16.11.05;	author henning;	state Exp;
branches
	1.86.2.1;
next	1.85;

1.85
date	2006.07.28.15.04.34;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2006.06.17.14.06.09;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2006.05.27.15.43.13;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2006.05.23.12.11.38;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2006.01.24.10.03.44;	author henning;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2006.01.03.22.19.59;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2005.10.19.10.26.21;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2005.09.19.16.15.54;	author henning;	state Exp;
branches;
next	1.77;

1.77
date	2005.06.04.22.50.20;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2005.04.05.17.37.44;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2004.12.23.17.24.03;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2004.12.23.15.15.55;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2004.12.23.15.08.43;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2004.11.18.17.07.38;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2004.11.18.16.38.05;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2004.11.18.16.30.05;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2004.11.18.15.24.49;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2004.11.18.14.59.50;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2004.11.18.14.30.10;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2004.11.18.14.10.36;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2004.11.02.10.56.48;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2004.10.19.12.02.50;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2004.09.22.08.46.28;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2004.09.16.17.44.36;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2004.08.06.11.51.19;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2004.08.05.21.01.38;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2004.08.04.12.41.48;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2004.07.04.03.51.31;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.20.17.49.46;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2004.06.09.13.01.44;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.06.17.38.10;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.28.18.39.09;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.08.18.21.55;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2004.05.08.11.22.43;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.28.17.42.27;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.28.06.45.37;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.28.02.57.01;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2004.04.27.22.42.13;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.27.03.53.43;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.26.09.35.39;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.26.01.43.13;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.25.17.34.39;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.16.04.52.26;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.16.04.47.19;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.13.22.53.29;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.11.14.22.23;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2004.03.11.13.35.06;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2004.03.10.15.15.48;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.10.14.45.25;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.10.11.38.33;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.05.21.44.26;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.05.20.25.30;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.01.16.49.24;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.26.16.16.41;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.16.12.53.15;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.09.23.16.46;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.09.01.38.55;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.08.23.44.57;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.07.11.42.30;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.06.20.18.18;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.28.17.57.08;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.28.17.27.55;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.22.20.59.17;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.22.19.07.34;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.17.19.35.36;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.11.18.42.25;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.11.01.04.43;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.09.13.47.08;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.06.23.14.58;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.06.19.21.22;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.06.19.19.21;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.06.18.01.27;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.06.03.43.51;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.05.22.57.58;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.04.20.07.30;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.04.19.39.46;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.04.18.51.23;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.03.22.44.29;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.03.22.18.58;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.03.20.37.34;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.03.20.22.07;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.01.23.46.47;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.19.21.07.05;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;

1.81.2.1
date	2006.11.04.19.53.37;	author brad;	state Exp;
branches;
next	;

1.86.2.1
date	2006.11.04.05.19.06;	author brad;	state Exp;
branches;
next	;


desc
@@


1.123
log
@Implement an XON/XOFF protocol between the RDE and the SE to throttle
per control session and peer the generation of imsg in the RDE. This
reduces the memory pressure in the SE substantially and also a bit in
the RDE. Makes the RDE more responsive for bgpctl commands.
Tested by me with 100 peers * 2000 prefixes and by phessler@@ on an AMS-IX
border router with 200+ session. Convergance time got quite a bit better.
OK phessler@@
@
text
@/*	$OpenBSD: session.h,v 1.122 2017/01/13 18:59:12 phessler Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <time.h>

#define	MAX_BACKLOG			5
#define	INTERVAL_CONNECTRETRY		120
#define	INTERVAL_HOLD_INITIAL		240
#define	INTERVAL_HOLD			90
#define	INTERVAL_IDLE_HOLD_INITIAL	30
#define	INTERVAL_HOLD_CLONED		3600
#define	INTERVAL_HOLD_DEMOTED		60
#define	MAX_IDLE_HOLD			3600
#define	MSGSIZE_HEADER			19
#define	MSGSIZE_HEADER_MARKER		16
#define	MSGSIZE_NOTIFICATION_MIN	21	/* 19 hdr + 1 code + 1 sub */
#define	MSGSIZE_OPEN_MIN		29
#define	MSGSIZE_UPDATE_MIN		23
#define	MSGSIZE_KEEPALIVE		MSGSIZE_HEADER
#define	MSGSIZE_RREFRESH		MSGSIZE_HEADER + 4
#define	MSG_PROCESS_LIMIT		25
#define	SESSION_CLEAR_DELAY		5

enum session_state {
	STATE_NONE,
	STATE_IDLE,
	STATE_CONNECT,
	STATE_ACTIVE,
	STATE_OPENSENT,
	STATE_OPENCONFIRM,
	STATE_ESTABLISHED
};

enum session_events {
	EVNT_NONE,
	EVNT_START,
	EVNT_STOP,
	EVNT_CON_OPEN,
	EVNT_CON_CLOSED,
	EVNT_CON_OPENFAIL,
	EVNT_CON_FATAL,
	EVNT_TIMER_CONNRETRY,
	EVNT_TIMER_HOLDTIME,
	EVNT_TIMER_KEEPALIVE,
	EVNT_RCVD_OPEN,
	EVNT_RCVD_KEEPALIVE,
	EVNT_RCVD_UPDATE,
	EVNT_RCVD_NOTIFICATION
};

enum msg_type {
	OPEN = 1,
	UPDATE,
	NOTIFICATION,
	KEEPALIVE,
	RREFRESH
};

enum suberr_header {
	ERR_HDR_SYNC = 1,
	ERR_HDR_LEN,
	ERR_HDR_TYPE
};

enum suberr_open {
	ERR_OPEN_VERSION = 1,
	ERR_OPEN_AS,
	ERR_OPEN_BGPID,
	ERR_OPEN_OPT,
	ERR_OPEN_AUTH,
	ERR_OPEN_HOLDTIME,
	ERR_OPEN_CAPA,
	ERR_OPEN_GROUP_CONFLICT,	/* draft-ietf-idr-bgp-multisession-07 */
	ERR_OPEN_GROUP_REQUIRED		/* draft-ietf-idr-bgp-multisession-07 */
};

enum suberr_fsm {
	ERR_FSM_UNSPECIFIC = 0,
	ERR_FSM_UNEX_OPENSENT,
	ERR_FSM_UNEX_OPENCONFIRM,
	ERR_FSM_UNEX_ESTABLISHED
};

enum opt_params {
	OPT_PARAM_NONE,
	OPT_PARAM_AUTH,
	OPT_PARAM_CAPABILITIES
};

enum capa_codes {
	CAPA_NONE,
	CAPA_MP,
	CAPA_REFRESH,
	CAPA_RESTART = 64,
	CAPA_AS4BYTE = 65
};

struct bgp_msg {
	struct ibuf	*buf;
	enum msg_type	 type;
	u_int16_t	 len;
};

struct msg_header {
	u_char			 marker[MSGSIZE_HEADER_MARKER];
	u_int16_t		 len;
	u_int8_t		 type;
};

struct msg_open {
	struct msg_header	 header;
	u_int32_t		 bgpid;
	u_int16_t		 myas;
	u_int16_t		 holdtime;
	u_int8_t		 version;
	u_int8_t		 optparamlen;
};

struct bgpd_sysdep {
	u_int8_t		no_pfkey;
	u_int8_t		no_md5sig;
};

struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)	entry;
	struct imsgbuf		ibuf;
	int			restricted;
	int			throttled;
};

TAILQ_HEAD(ctl_conns, ctl_conn)	ctl_conns;

struct peer_stats {
	u_int64_t		 msg_rcvd_open;
	u_int64_t		 msg_rcvd_update;
	u_int64_t		 msg_rcvd_notification;
	u_int64_t		 msg_rcvd_keepalive;
	u_int64_t		 msg_rcvd_rrefresh;
	u_int64_t		 msg_sent_open;
	u_int64_t		 msg_sent_update;
	u_int64_t		 msg_sent_notification;
	u_int64_t		 msg_sent_keepalive;
	u_int64_t		 msg_sent_rrefresh;
	u_int64_t		 prefix_rcvd_update;
	u_int64_t		 prefix_rcvd_withdraw;
	u_int64_t		 prefix_rcvd_eor;
	u_int64_t		 prefix_sent_update;
	u_int64_t		 prefix_sent_withdraw;
	u_int64_t		 prefix_sent_eor;
	time_t			 last_updown;
	time_t			 last_read;
	u_int32_t		 prefix_cnt;
	u_int8_t		 last_sent_errcode;
	u_int8_t		 last_sent_suberr;
	char			 last_shutcomm[SHUT_COMM_LEN];
};

enum Timer {
	Timer_None,
	Timer_ConnectRetry,
	Timer_Keepalive,
	Timer_Hold,
	Timer_IdleHold,
	Timer_IdleHoldReset,
	Timer_CarpUndemote,
	Timer_RestartTimeout,
	Timer_Max
};

struct peer_timer {
	TAILQ_ENTRY(peer_timer)	entry;
	enum Timer		type;
	time_t			val;
};

TAILQ_HEAD(peer_timer_head, peer_timer);

struct peer {
	struct peer_config	 conf;
	struct peer_stats	 stats;
	struct {
		struct capabilities	ann;
		struct capabilities	peer;
		struct capabilities	neg;
	}			 capa;
	struct {
		struct bgpd_addr	local_addr;
		u_int32_t		spi_in;
		u_int32_t		spi_out;
		enum auth_method	method;
		u_int8_t		established;
	} auth;
	struct sockaddr_storage	 sa_local;
	struct sockaddr_storage	 sa_remote;
	struct peer_timer_head	 timers;
	struct msgbuf		 wbuf;
	struct ibuf_read	*rbuf;
	struct peer		*next;
	struct peer		*template;
	int			 fd;
	int			 lasterr;
	u_int			 errcnt;
	u_int			 IdleHoldTime;
	u_int32_t		 remote_bgpid;
	enum session_state	 state;
	enum session_state	 prev_state;
	u_int16_t		 short_as;
	u_int16_t		 holdtime;
	u_int8_t		 depend_ok;
	u_int8_t		 demoted;
	u_int8_t		 passive;
	u_int8_t		 throttled;
};

extern struct peer	*peers;
extern time_t		 pauseaccept;

struct ctl_timer {
	enum Timer	type;
	time_t		val;
};

/* carp.c */
int	 carp_demote_init(char *, int);
void	 carp_demote_shutdown(void);
int	 carp_demote_get(char *);
int	 carp_demote_set(char *, int);

/* config.c */
int	 merge_config(struct bgpd_config *, struct bgpd_config *,
	    struct peer *);
void	 prepare_listeners(struct bgpd_config *);
int	 get_mpe_label(struct rdomain *);

/* control.c */
int	control_init(int, char *);
int	control_listen(int);
void	control_shutdown(int);
int	control_dispatch_msg(struct pollfd *, u_int *);
unsigned int	control_accept(int, int);

/* log.c */
char		*log_fmt_peer(const struct peer_config *);
void		 log_statechange(struct peer *, enum session_state,
		    enum session_events);
void		 log_notification(const struct peer *, u_int8_t, u_int8_t,
		    u_char *, u_int16_t, const char *);
void		 log_conn_attempt(const struct peer *, struct sockaddr *);

/* mrt.c */
void		 mrt_dump_bgp_msg(struct mrt *, void *, u_int16_t,
		     struct peer *);
void		 mrt_dump_state(struct mrt *, u_int16_t, u_int16_t,
		     struct peer *);
void		 mrt_done(void *);

/* parse.y */
int	 parse_config(char *, struct bgpd_config *, struct peer **);

/* pfkey.c */
int	pfkey_read(int, struct sadb_msg *);
int	pfkey_establish(struct peer *);
int	pfkey_remove(struct peer *);
int	pfkey_init(struct bgpd_sysdep *);

/* printconf.c */
void	print_config(struct bgpd_config *, struct rib_names *,
	    struct network_head *, struct peer *, struct filter_head *,
	    struct mrt_head *, struct rdomain_head *);

/* rde.c */
void	 rde_main(int, int);

/* session.c */
void		 session_main(int, int);
void		 bgp_fsm(struct peer *, enum session_events);
int		 session_neighbor_rrefresh(struct peer *p);
struct peer	*getpeerbyaddr(struct bgpd_addr *);
struct peer	*getpeerbydesc(const char *);
int		 imsg_ctl_parent(int, u_int32_t, pid_t, void *, u_int16_t);
int		 imsg_ctl_rde(int, pid_t, void *, u_int16_t);
void	 	 session_stop(struct peer *, u_int8_t);

/* timer.c */
time_t			 getmonotime(void);
struct peer_timer	*timer_get(struct peer *, enum Timer);
struct peer_timer	*timer_nextisdue(struct peer *);
time_t			 timer_nextduein(struct peer *);
int			 timer_running(struct peer *, enum Timer, time_t *);
void			 timer_set(struct peer *, enum Timer, u_int);
void			 timer_stop(struct peer *, enum Timer);
void			 timer_remove(struct peer *, enum Timer);
void			 timer_remove_all(struct peer *);
@


1.122
log
@Add support for draft-ietf-idr-shutdown

    BGP state = Idle, marked down with shutdown reason "goodbye, we are
    upgrading to openbsd 6.1", down for 00:00:17

developed by Peter van Dijk <peter.van.dijk@@powerdns.com> and Job
Snijders <job@@ntt.net>, thank you!

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.121 2015/10/25 18:49:01 claudio Exp $ */
d145 1
d229 1
@


1.121
log
@Rename imsg_compose_parent and imsg_compose_rde to imsg_ctl_parent and
imsg_ctl_rde since these function should only be used by the control
code. Also switch ibuf_rde to ibuf_rde_ctl so that the control imsgs
don't need to queue behind all the incoming bgp UPDATES. This speeds
up 'bgpctl show' from taking minutes to a few seconds. The RDE was doing
this since a very long time but it seems the SE was not adjusted. Yikes
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.120 2015/10/11 19:25:06 phessler Exp $ */
d171 1
@


1.120
log
@some peers are following an expired draft RFC and are sending "unknown"
error codes to OPEN messages.  make them "known", and show them.

OK benno@@, claudio@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.119 2015/07/20 16:10:38 claudio Exp $ */
d294 2
a295 2
int		 imsg_compose_parent(int, u_int32_t, pid_t, void *, u_int16_t);
int		 imsg_compose_rde(int, pid_t, void *, u_int16_t);
@


1.119
log
@Make bgpd execute the RDE and session engine process instead of just forking.
This way ASLR and stack cookies are per process.
With input from benno@@ and deraadt@@
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.118 2015/07/16 18:26:04 claudio Exp $ */
d89 3
a91 1
	ERR_OPEN_CAPA
@


1.118
log
@Next round of config cleanup. Move various lists into the bgpd_config struct.
This is the next step to better split parsing and merging the config.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.117 2015/02/09 11:37:31 claudio Exp $ */
d284 1
a284 1
pid_t	 rde_main(int[2], int[2], int[2], int[2], int);
d287 1
a287 1
pid_t		 session_main(int[2], int[2], int[2], int[2]);
@


1.117
log
@Kill session_socket_blockmode() and replace it with SOCK_CLOEXEC or
SOCK_NONBLOCK and accept4(). OK henning@@ tested & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.116 2013/05/30 20:29:27 florian Exp $ */
d243 1
a243 1
	    struct peer *, struct listen_addrs *);
d270 1
a270 3
int	 parse_config(char *, struct bgpd_config *, struct mrt_head *,
	    struct peer **, struct network_head *, struct filter_head *,
	    struct rdomain_head *);
@


1.116
log
@When removing "dump (all|updates)" from bgpd.conf and reloading, tell
the session engine to actually stop logging.
Found the hard way by benno@@.

with & ok benno@@
input & ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.115 2013/03/07 21:26:28 claudio Exp $ */
a67 5
enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK
};

a288 1
void		 session_socket_blockmode(int, enum blockmodes);
@


1.115
log
@Implements a few missing bits for better templates support:
- on config reload also adjust the cloned neighbors so that they get the
  config changes as well.
- clean up sessions that are 1h idle but in state active (instead of down)
- add bits to allow bgpctl to destroy cloned neighbors
Tested by sthen@@ some time ago, OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.114 2012/09/12 05:56:22 claudio Exp $ */
d272 1
@


1.114
log
@Better graceful restart support (implementing more then just the EoR record).
This implements only the "Restarting Client" bits of the RFC -- in other
words bgpd will keep the FIB when the client restarts but it will not do GR
when restarting itself. The capability is still off by default (you need
"announce restart yes" to enable it).
Tested by Anders Berggren. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.113 2012/04/12 17:26:09 claudio Exp $ */
d217 1
@


1.113
log
@accept() pacing for bgpd based on similar work done on other daemons.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.112 2011/09/18 09:31:25 claudio Exp $ */
d165 1
d168 1
d184 1
@


1.112
log
@Reorder the headerfiles a bit. Move the bgpd specific prototypes out of
mrt.h. Now mrt.h includes only protocol specific defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.111 2010/12/09 13:50:41 claudio Exp $ */
d229 1
d300 1
@


1.111
log
@The PF_KEY socket is like the routing socket. It must be polled all the
time to consume broadcasted messages or the socket gets full and own
messages that are needed are lost. This fixes an infinit loop in
pfkey_reply that happens when bgpd tcp md5sum is used on a system that
also runs a larger IPsec setup.
OK henning, lot of patience, debuging and testing by Thomas Boernert
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.110 2010/11/18 12:51:25 claudio Exp $ */
d235 18
a252 10
/* session.c */
void		 session_socket_blockmode(int, enum blockmodes);
pid_t		 session_main(int[2], int[2], int[2], int[2]);
void		 bgp_fsm(struct peer *, enum session_events);
int		 session_neighbor_rrefresh(struct peer *p);
struct peer	*getpeerbyaddr(struct bgpd_addr *);
struct peer	*getpeerbydesc(const char *);
int		 imsg_compose_parent(int, u_int32_t, pid_t, void *, u_int16_t);
int		 imsg_compose_rde(int, pid_t, void *, u_int16_t);
void	 	 session_stop(struct peer *, u_int8_t);
d262 6
a272 16
/* config.c */
int	 merge_config(struct bgpd_config *, struct bgpd_config *,
	    struct peer *, struct listen_addrs *);
void	 prepare_listeners(struct bgpd_config *);
int	 get_mpe_label(struct rdomain *);

/* rde.c */
pid_t	 rde_main(int[2], int[2], int[2], int[2], int);

/* control.c */
int	control_init(int, char *);
int	control_listen(int);
void	control_shutdown(int);
int	control_dispatch_msg(struct pollfd *, u_int *);
unsigned int	control_accept(int, int);

d284 13
a296 5
/* carp.c */
int	 carp_demote_init(char *, int);
void	 carp_demote_shutdown(void);
int	 carp_demote_get(char *);
int	 carp_demote_set(char *, int);
@


1.110
log
@Log sent notification messages as well having them in the log may
help to figure out the cause of flapping session faster.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.109 2010/10/15 07:45:32 claudio Exp $ */
d276 1
@


1.109
log
@Add the FSM suberrors specified in draft-ietf-idr-fsm-subcode. This
should help identifying FSM errors since the state is know known.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.108 2010/06/27 19:53:34 claudio Exp $ */
d251 1
a251 1
		    u_char *, u_int16_t);
@


1.108
log
@Instead of specifying the control sockets on the command line have them
in bgpd.conf. This allows to add/modify restricted control sockets on runtime.
Feature request by a few people how often forgot to add -r path when restarting
bgpd (including myself).
NOTE: this removes the -s and -r arguments from bgpd so pay attention when
updateing.
jajaja sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.107 2010/05/26 13:56:07 nicm Exp $ */
d95 7
@


1.107
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.106 2010/05/17 15:49:29 claudio Exp $ */
d230 1
a230 1
pid_t		 session_main(int[2], int[2], int[2], int[2], char *, char *);
@


1.106
log
@Last bits of MPLS VPN support. Hook kernel routing tables and RIB together.
This adds a bit of new config to specify the mapping between an rdomain and
the BGP MPLS VPN instance, example:
rdomain 1 {
        descr "CUSTOMER1"
	rd 65003:1
	import-target rt 65003:3
	export-target rt 65003:1
	depend on mpe0
	network 192.168.224/24
}
The "depend on mpe0" is a but ugly but for now this is the quickest way to
figure out which interface bgp should use to insert the MPLS routes.

A big side-effect of this diff is that networks are now internally
distributed through kroute.c.
This needs some kernel changes that will follow hopefully soon.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.105 2010/05/03 13:09:38 claudio Exp $ */
d112 1
a112 1
	struct buf	*buf;
d205 1
a205 1
	struct buf_read		*rbuf;
@


1.105
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.104 2009/12/31 15:34:02 claudio Exp $ */
d249 2
a250 1
	    struct peer **, struct network_head *, struct filter_head *);
d256 1
d276 1
a276 1
	    struct mrt_head *);
@


1.104
log
@Instead of passing the config via arguments to the childs on bootup issue
a config reload as first step in bootup. This allows childs to start with
an empty config and a lot of special cleanup code can bite the dust.
Testing by myself and sthen@@ with a few configs (more testing welcome).
Seems like a good idea henning@@ & sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.103 2009/12/08 14:03:40 claudio Exp $ */
d235 1
a235 1
int		 imsg_compose_parent(int, pid_t, void *, u_int16_t);
@


1.103
log
@Big AID change part two. This changes the mp capability into an array of
flags. This makes a lot of code much easier since the comparison is now
trivial. Additionally calculate the negotiated capabilities for a session
in the SE and pass that and only that to the RDE. This makes the decisions
in the RDE a lot easier.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.102 2009/09/02 08:06:42 claudio Exp $ */
d221 1
a221 1
struct peer	*peers;
d230 1
a230 4
pid_t		 session_main(struct bgpd_config *, struct peer *,
		    struct network_head *, struct filter_head *,
		    struct mrt_head *, struct rib_names *,
		    int[2], int[2], int[2], int[2]);
d257 1
a257 3
pid_t	 rde_main(struct bgpd_config *, struct peer *, struct network_head *,
	    struct filter_head *, struct mrt_head *, struct rib_names *,
	    int[2], int[2], int[2], int[2], int);
@


1.102
log
@Implement all of RFC 4486 BGP Cease Notification Message Subcodes.
The other side should now see why a session was dropped. e.g:
bgpd: ... received notification: Cease, administratively down
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.101 2009/06/05 20:26:38 claudio Exp $ */
d192 1
@


1.101
log
@Adjust print_config to all the stuff added in the last days.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.100 2009/06/04 04:46:42 claudio Exp $ */
d239 1
@


1.100
log
@Add "rde rib <name>" to the config and allow the rde to use these other RIBs.
Still a bit hackish, reload is missing and printconf as well. Looks good h@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.99 2008/09/11 14:49:58 henning Exp $ */
d275 3
a277 2
void	print_config(struct bgpd_config *, struct network_head *, struct peer *,
	    struct filter_head *, struct mrt_head *);
@


1.99
log
@remove hackery to un-demote after the session has been established for
a while, we can now just use a timer (since i rewrote the timer code)
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.98 2008/05/08 09:53:12 henning Exp $ */
d231 2
a232 1
		    struct mrt_head *, int[2], int[2], int[2], int[2]);
d259 2
a260 2
	    struct filter_head *, struct mrt_head *, int[2], int[2], int[2],
	    int[2], int);
@


1.98
log
@timer_due is not needed any more
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.97 2008/05/08 07:43:03 henning Exp $ */
d174 1
@


1.97
log
@take advantage of the timewheel: instead of checking each an every
timer, just get the first off the queue and check wether it is due
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.96 2008/05/08 06:52:13 henning Exp $ */
a283 1
int			 timer_due(struct peer *, enum Timer);
@


1.96
log
@change timer internals so that we use a timewheel (tailq, sorted by expiry
so that the timer that will expire first is always the first element,
and so on). will make the checking a bit faster and moreelegant and more
conveniant. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.95 2007/12/23 18:56:17 henning Exp $ */
d285 1
@


1.95
log
@provide timer_nextduein, which provides the number of seconds until the
next timer expires.
use that in the session engine's mainloop, which simplifies it and
removes the last bits of timer internals knowledge from anywhere outside
timer.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.94 2007/12/23 18:26:13 henning Exp $ */
d167 18
d201 1
a204 5
	time_t			 ConnectRetryTimer;
	time_t			 KeepaliveTimer;
	time_t			 HoldTimer;
	time_t			 IdleHoldTimer;
	time_t			 IdleHoldResetTimer;
a220 10
enum Timer {
	Timer_None,
	Timer_ConnectRetry,
	Timer_Keepalive,
	Timer_Hold,
	Timer_IdleHold,
	Timer_IdleHoldReset,
	Timer_Max
};

d283 8
a290 6
time_t		*timer_get(struct peer *, enum Timer);
int		 timer_due(struct peer *, enum Timer);
time_t		 timer_nextduein(struct peer *);
int		 timer_running(struct peer *, enum Timer, time_t *);
void		 timer_set(struct peer *, enum Timer, u_int);
void		 timer_stop(struct peer *, enum Timer);
@


1.94
log
@send timers for bgpctlshow neighbor foo timer in seperate messages after
the peer data. makes bgpctl display code independent from timer
implementation internals. only running timers are displayed now, stopped
ones are skipped.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.93 2007/12/20 17:08:48 henning Exp $ */
d281 1
@


1.93
log
@rework timers.
stop changing tienmr values directly, always use new
timer_(get/set/stop/running) functions. preparation for more to come :)
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.92 2007/04/23 13:04:24 claudio Exp $ */
d213 7
a219 1
	Timer_IdleHoldReset
@


1.92
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.91 2007/04/06 18:03:51 claudio Exp $ */
d207 9
d271 7
@


1.91
log
@Count the updates and withdraws for additional statisic gathering.
Discussed with henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.90 2007/01/26 17:40:49 claudio Exp $ */
d107 2
a108 1
	CAPA_RESTART = 64
d198 1
d220 1
@


1.90
log
@Massiv rework of the control imsg flow. Main changes:
- dedicated pipe between the SE and the RDE for control messages
- restartable RB tree dumps in the RDE
- queuing limits both in the SE and RDE
The result is a dramatic decrease of memory consumption on operations like
bgpctl show rib. Previously all messages where first stored in the RDE
then passed to the SE where they got queued in case bgpctl was not fast enough.
Now only a small number of messages is generated and passed to the SE and
the SE has an additional limit instead of acting like an infinite buffer.
Without this the bgpd on bgpd.networx.ch would not survive a single minute.
looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.89 2007/01/04 12:43:36 claudio Exp $ */
d155 4
@


1.89
log
@Do not run rde_shutdown() unless bgpd is started with -d.
On some of my systems rde_shutdown() takes more than 3min doing nothing more
than calling free(3) over and over again.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.88 2006/10/26 14:26:49 henning Exp $ */
d205 1
a205 1
		    struct mrt_head *, int[2], int[2], int[2]);
d232 1
a232 1
	    int);
@


1.88
log
@        * make sure we keep copies of everything we need to
        * remove SAs and flows later again, even if the
        * configuration info changed due to reload.
        * We need: SPIs, method, local_addr, remote_addr.
        * remote_addr cannot change, so no copy.
with this, I have just migrated a session from tcp md5sig to ipsec esp ike,
just with bgpctl reload (both sides) followed by bgpctl neighbor $foo clear
(just one side)!
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.87 2006/10/26 13:17:00 henning Exp $ */
d231 2
a232 1
	    struct filter_head *, struct mrt_head *, int[2], int[2], int[2]);
@


1.87
log
@storing the dynamically acquired SPIs for tcpmd5 inside the conf struct
is not such a good idea - it gets nulled on config reloads, and thus
we fail to clear the old SAs when the session is restarted after a config
reload occured. obvious solution: store the SPIs outside the config area.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.86 2006/08/27 16:11:05 henning Exp $ */
d170 1
d173 1
@


1.86
log
@add code to announce the restart capability according to
draft-ietf-idr-restart. Do not announce actual restart capabilities,
so that this only serves as indicator that we are capable of sending
and receiving the End-of-RIB marker.
leave disabled for now, since the code to actually send the EoR-marker
is currently ifdef'd out (to be fixed soon) and we wanna play safe for
4.0. and juniper doesn't support that capability (which is not a problem
per se) and at the same time has its capability negotiation code completely
fucked up, if a capability is rejected they don't indicate WHICH capability
they reject (which makes that a problem, tho still a small one and we cope).
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.85 2006/07/28 15:04:34 henning Exp $ */
d169 5
a191 1
	u_int8_t		 auth_established;
@


1.86.2.1
log
@MFC:
Fix by henning@@

rev 1.33
make sure we keep copies of everything we need to
remove SAs and flows later again, even if the
configuration info changed due to reload.

rev 1.34
storing the dynamically acquired SPIs for tcpmd5 inside the conf struct
is not such a good idea - it gets nulled on config reloads, and thus
we fail to clear the old SAs when the session is restarted after a config
reload occured. obvious solution: store the SPIs outside the config
area.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.88 2006/10/26 14:26:49 henning Exp $ */
a168 7
	struct {
		struct bgpd_addr	local_addr;
		u_int32_t		spi_in;
		u_int32_t		spi_out;
		enum auth_method	method;
		u_int8_t		established;
	} auth;
d187 1
@


1.85
log
@factor out the code to build bgp messages, ok claudio a long time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.84 2006/06/17 14:06:09 henning Exp $ */
d106 2
a107 1
	CAPA_REFRESH
@


1.84
log
@implement carp demotion control for bgpd.
sessions can be configured to modify the carp demotion counter for a
given interface group (usually, "carp", which has all carp interfaces)
when the session is not established. once the session is established for
60 seconds, the demotion is cleared.
this, used correctly, can prevent a bgpd-box which lost all sessions (and
thus has no routes) to be carp master, while the backup has sessions.
thought through and partially hacked on a drive from calgary to vancouver
with ryan, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.83 2006/05/27 15:43:13 claudio Exp $ */
d107 6
@


1.83
log
@Cleanup with lint. Make the poll fd indexes unsigned and because of that
control_accept should also return a unsigned int. Remove old prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.82 2006/05/23 12:11:38 henning Exp $ */
d29 1
d182 1
d235 6
@


1.82
log
@allow bgpd to request a route refresh from a neighbor if that neighbor
announced route refresh capabilities
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.81 2006/01/24 10:03:44 henning Exp $ */
d223 1
a223 1
int	control_accept(int, int);
@


1.81
log
@introduce a second control socket, which is restricted to certain messages,
nameley the show ones. needed for looking glass style applications,
monitoring etc. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.80 2006/01/03 22:19:59 claudio Exp $ */
d192 1
@


1.81.2.1
log
@MFC:
Fix by henning@@

rev 1.33
make sure we keep copies of everything we need to
remove SAs and flows later again, even if the
configuration info changed due to reload.

rev 1.34
storing the dynamically acquired SPIs for tcpmd5 inside the conf struct
is not such a good idea - it gets nulled on config reloads, and thus
we fail to clear the old SAs when the session is restarted after a config
reload occured. obvious solution: store the SPIs outside the config
area.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.88 2006/10/26 14:26:49 henning Exp $ */
a160 7
	struct {
		struct bgpd_addr	local_addr;
		u_int32_t		spi_in;
		u_int32_t		spi_out;
		enum auth_method	method;
		u_int8_t		established;
	} auth;
d179 1
@


1.80
log
@Move functions shared with bgpctl into new file util.c. Simplifies the
link between bgpctl and bgpd mostly because of rde_attr.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.79 2005/10/19 10:26:21 henning Exp $ */
d131 1
d218 3
a220 2
int	control_listen(void);
void	control_shutdown(void);
d222 1
a222 1
int	control_accept(int);
@


1.79
log
@on "bgpctl neighbor foo clear", we used to send a STOP event immediately
followed by a START event. Instead of sending START immediately, start the
IdleHoldTimer with a very low value (5 seconds) so that we restart the
session these seconds later. some other implementations deal poorly with
our previously superfast reconnects, namely, that commercial one from
san jose, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.78 2005/09/19 16:15:54 henning Exp $ */
a201 1
const char *	 log_sockaddr(struct sockaddr *);
@


1.78
log
@implement fast reconnects
when a peer drops to IDLE, we have to force him in IDLE for some time to
prevent fast flapping. however, the forced idle time is annoying when the
connection could be re-established immediately, i. e. bgpctl nei $peer clear
or similar.
implement an error counter per peer, increased every time we receive a
notification. when we are in state IDLE and get a connection from the peer
in question, check if the error counter is 1 or smaller. if so, change state
to active and accept the connection, otherwise keep the current behaviour
and reject the connection.
the error counter gets scaled back by the IdleHoldResetTimer that scales the
IdleHoldTime back as well
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.77 2005/06/04 22:50:20 henning Exp $ */
d38 1
@


1.77
log
@when sending out a notification record the error code and suberror code in
the peer stats struct, and clear them as soon as the session leaves IDLE
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.76 2005/04/05 17:37:44 henning Exp $ */
d171 1
d179 1
@


1.76
log
@magic police, Jason Ackley <jason@@ackley.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.75 2004/12/23 17:24:03 henning Exp $ */
d148 2
@


1.75
log
@introduce getpeerbydesc(), find a peer by its description
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.74 2004/12/23 15:15:55 henning Exp $ */
d108 1
a108 1
	u_char			 marker[16];
@


1.74
log
@lower latency by processing no more than 25 messages at once for each peer
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.73 2004/12/23 15:08:43 henning Exp $ */
d187 1
@


1.73
log
@sort structs for most optimal alignment, help mickey, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.72 2004/11/18 17:07:38 henning Exp $ */
d37 1
@


1.72
log
@add an instance of struct capabilities to peer_conf, and inherit
peer->capa.ann from this
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.71 2004/11/18 16:38:05 henning Exp $ */
d114 1
a114 1
	u_int8_t		 version;
d117 1
a117 1
	u_int32_t		 bgpid;
d156 5
a160 4
	u_int32_t		 remote_bgpid;
	u_int16_t		 holdtime;
	enum session_state	 state;
	enum session_state	 prev_state;
d166 2
d169 4
a172 5
	int			 fd;
	struct sockaddr_storage	 sa_local;
	struct sockaddr_storage	 sa_remote;
	struct msgbuf		 wbuf;
	struct buf_read		*rbuf;
a174 2
	int			 lasterr;
	struct peer		*next;
@


1.71
log
@inside struct peer, replace the occurance of the older struct peer_capa
by two instances of the new struct capabilities, one for announcements
and one for the received capabilities
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.70 2004/11/18 16:30:05 henning Exp $ */
a146 6
};

struct capabilities {
	u_int8_t	mp_v4;		/* multiprotocol extensions, RFC 2858 */
	u_int8_t	mp_v6;
	u_int8_t	refresh;	/* route refresh, RFC 2918 */
@


1.70
log
@remove the global 'announce' flag from struct peer_capa, clear
individual capability flags where needed
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.69 2004/11/18 15:24:49 henning Exp $ */
d149 1
a149 4
struct peer_capa {
	u_int8_t	ann_mp_v4;
	u_int8_t	ann_mp_v6;
	u_int8_t	ann_refresh;
d158 4
a161 1
	struct peer_capa	 capa;
@


1.69
log
@struct capa_mp is not needed any more, spotted by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.68 2004/11/18 14:59:50 henning Exp $ */
a149 1
	u_int8_t	announce;
@


1.68
log
@add code to announce support for IPv6 Unicast.
disabled for now, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.67 2004/11/18 14:30:10 henning Exp $ */
a118 6
};

struct capa_mp {
	u_int16_t		afi;
	u_int8_t		pad;
	u_int8_t		safi;
@


1.67
log
@it's oupsa oupsa oupsa time...
writing to a member of a const struct is no good, so un-const struct peer
for log_statechange()
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.66 2004/11/18 14:10:36 henning Exp $ */
d157 2
a158 1
	u_int8_t	ann_mp;
@


1.66
log
@supress logging of subsequent connect() failures as long as:
-the session alternates between Active and Connect. Other states reset logging
-the error is the same as the last connect() error seen
jajajaja claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.65 2004/11/02 10:56:48 henning Exp $ */
d202 1
a202 1
void		 log_statechange(const struct peer *, enum session_state,
@


1.65
log
@save the previous state in struct peer, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.64 2004/10/19 12:02:50 henning Exp $ */
d185 1
@


1.64
log
@allow neighbor definitions to depend on interface state.
with this, if a neighbor is configured as dependent on carp0 for example,
the neighbor will remain in state IDLE as long as carp0 is not master.
once carp0 becomes master the session(s) depending on it immediately
go to CONNECT (or ACTIVE, if they're configured passive), reducing failover
time. claudio ok, with some input from ryan as well
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.63 2004/09/22 08:46:28 henning Exp $ */
d171 1
@


1.63
log
@don't bother shrinking the pfd and index2peer arrays
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.62 2004/09/16 17:44:36 henning Exp $ */
d183 1
@


1.62
log
@when a cloned peer goes back to IDLE state, don't remove him immediately
but keep him around for some more time (an hour here).
fixes an issue Arvid was reporting: when a cloned neighbor rejects our OPEN
message due to capability negotiation (or missing implementation of those),
we set a marker and retry without. However, if we remove the peer immediately,
it gets freshly cloned on the next trial, with default settings, thus including
capability negotiation, and thus failes again.
this will also help with route flap dampening.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.61 2004/08/06 11:51:19 claudio Exp $ */
d36 1
a36 3
#define MSGSIZE_RREFRESH		MSGSIZE_HEADER + 4
#define	PFD_RESERVE			5
#define	PEER_L_RESERVE			2
@


1.61
log
@Forward IMSG_CTL_SHOW_NEIGHBOR messages to the rde so that we can report
the current and max prefix count back to bgpctl. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.60 2004/08/05 21:01:38 claudio Exp $ */
d28 1
@


1.60
log
@The peer_l is not needed in the rde but still allocated, free them and
save 1k per peer. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.59 2004/08/04 12:41:48 henning Exp $ */
d153 1
@


1.59
log
@session_main() and rde_main() return... right, a pid. and a pid is a pid_t
and not an int.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.58 2004/07/04 03:51:31 henning Exp $ */
d216 1
a216 1
pid_t	 rde_main(struct bgpd_config *, struct network_head *,
@


1.58
log
@2 more file descriptors for each RDE and SE inherited from the parent
we should close
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.57 2004/06/20 18:35:12 henning Exp $ */
d190 1
a190 1
int		 session_main(struct bgpd_config *, struct peer *,
d216 1
a216 1
int	 rde_main(struct bgpd_config *, struct network_head *,
@


1.57
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.56 2004/06/20 17:49:46 henning Exp $ */
d192 1
a192 1
		    struct mrt_head *, int[2], int[2]);
d217 1
a217 1
	    struct filter_head *, struct mrt_head *, int[2], int[2]);
@


1.56
log
@implement file descriptor passing in the imsg/msgbuf framework, and use
it to let the main process to prepare new listening sockets (socket() and
bind()) on behalf of the session engine, which of course cannot bind() to
ports < 1024 any more once it dropped privileges. with some help from theo,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.55 2004/06/09 13:01:44 henning Exp $ */
d134 1
a134 1
	TAILQ_ENTRY(ctl_conn)	entries;
@


1.55
log
@move to a dynamically allocated struct pollfd array.
we used a ststic one with OPEN_MAX entries, which is a rather arbitary limit
as OPEN_MAX is _not_ the max # of open fds we can have, but just a default
for that setting.
in the same move we have to allocate the peer_l array, basically there
for pfd-index to peer pointers to prevent peer list scans all time,
dynamiccaly to. we overallocate a little and use that reserve until we
have to realloc again later to prevent reallocs for every single control
connection or a single flapping peer.
help & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.54 2004/06/06 17:38:10 henning Exp $ */
d213 1
@


1.54
log
@rework bgpd's handling of listening sockets. instead of one for each
supported address familiy, keep a tailq of an arbitary number of them.
the new struct listen_addr contains the sockaddr and the fd.
this fixes quite some nasty behaviour which was a consequence of the previous
model.
looks right deraadt@@, and discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.53 2004/05/28 18:39:09 henning Exp $ */
d36 2
d221 2
a222 3
int	control_dispatch_msg(struct pollfd *);
void	control_accept(int);
void	control_close(int);
@


1.53
log
@detect absence of PF_KEY interface and/or the TCP_MD5SIG setsockopts
at runtime and disable said subsystems if so. helps the guys porting bgpd
to $otherBSD, and is actually the right thing to do. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.52 2004/05/08 18:21:55 henning Exp $ */
d210 1
a210 1
	    struct peer *);
@


1.52
log
@provide log_sockaddr, which uses getnameinfo(), and use it in
log_conn_attempt
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.51 2004/05/08 11:22:43 henning Exp $ */
d126 5
d224 3
a226 3
int	pfkey_establish(struct peer *p);
int	pfkey_remove(struct peer *p);
int	pfkey_init(void);
@


1.51
log
@remove unused argument to control_dispatch_msg(), lint
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.50 2004/04/28 17:42:27 deraadt Exp $ */
d197 1
@


1.50
log
@rename sock to fd
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.49 2004/04/28 06:45:37 henning Exp $ */
d213 1
a213 1
int	control_dispatch_msg(struct pollfd *, int);
@


1.49
log
@if a peer follows the extremely misgiuded path that the RFCs just barely allow
to send a NOTIFICATION and thus ternminating the session when it sees a
capability it doesn't support (who would guess: zebra does so), parse the
data section of the notifcication to find out what what capabilties it didn't
like and do not advertise them the next time the session gets up. In case we
get a notification about unsupported capabilities with an empty data part
(don't ask for RFCs... and guess who does that), disable capabilty announcement
alltogether.
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.48 2004/04/28 02:57:01 henning Exp $ */
d170 1
a170 1
	int			 sock;
@


1.48
log
@keep track of which ipsec/md5 SAs we inserted - ESRCH on blind removal
otherwise, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.47 2004/04/27 22:42:13 henning Exp $ */
d150 2
@


1.47
log
@rename the ipsec struct to auth, move all tcpmd5 related fields in there, and
add a generic "method" field that expresses what method
(none/md5sig/ipsec manual/ipsec ike) is in use
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.46 2004/04/27 03:53:43 henning Exp $ */
d173 1
@


1.46
log
@initial route refresh support per RFC2918
process incoming route refresh request and notify the RDE
not advertised via capabilities yet, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.45 2004/04/26 09:35:39 markus Exp $ */
a147 5
struct peer_auth {
	u_int32_t	spi_in;
	u_int32_t	spi_out;
};

a157 1
	struct peer_auth	 auth;
@


1.45
log
@load ipsec SAs into the kernel and enable them.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.44 2004/04/26 01:43:13 henning Exp $ */
d35 1
d73 2
a74 1
	KEEPALIVE
d138 1
d143 1
@


1.44
log
@announce multiprotocol capabilities - IPv4 multicast for now
this implies ourgoing capabilities annoucnement is there and just needs the
values to be filled in for other shitz we'll support soonish
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.43 2004/04/25 17:34:39 claudio Exp $ */
d217 2
a218 2
int	pfkey_auth_establish(struct peer *p);
int	pfkey_auth_remove(struct peer *p);
@


1.43
log
@Remove the no longer needed configure stuff in RDE. The peer list needs no
longer to be synced between parent, SE and RDE. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.42 2004/04/16 04:52:26 henning Exp $ */
d116 6
@


1.42
log
@let getpeerbyip work for both v4 and v6
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.40 2004/04/13 22:53:29 henning Exp $ */
d200 1
a200 1
int	 rde_main(struct bgpd_config *, struct peer *, struct network_head *,
@


1.41
log
@make log_conn_attempt work in an address family independent matter
@
text
@d180 1
a180 1
struct peer	*getpeerbyip(in_addr_t);
@


1.40
log
@parse the BGP Multiprotocol Extensions (RFC 2858) capabilities and store in
the peer struct, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.39 2004/03/11 14:22:23 claudio Exp $ */
d189 1
a189 1
void		 log_conn_attempt(const struct peer *, struct in_addr);
@


1.39
log
@Shutdown the RDE cleanly on exit. Plug some memleaks. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.38 2004/03/11 13:35:06 claudio Exp $ */
d145 3
@


1.38
log
@Free unneeded mrt lists in SE and on exit. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.37 2004/03/10 15:15:48 henning Exp $ */
d198 1
a198 1
	    struct filter_head *, int[2], int[2]);
@


1.37
log
@pass a pointer to the network list as well to session_main so we can free()
the members after fork
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.36 2004/03/10 14:45:25 henning Exp $ */
d175 1
a175 1
		    int[2], int[2]);
@


1.36
log
@pass a pointer to the filter rule list to session_main() so we can free()
the list entries and the head there after forking
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.35 2004/03/10 11:38:33 henning Exp $ */
d174 2
a175 1
		    struct filter_head *, int[2], int[2]);
@


1.35
log
@implement framework to announce capabilities in the open messages we send.
this includes handling "unsupported optional parameter" notifications from the
peer and retrying without capability announcement. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.34 2004/03/05 21:44:26 henning Exp $ */
d172 3
a174 3
void		  session_socket_blockmode(int, enum blockmodes);
int		  session_main(struct bgpd_config *, struct peer *, int[2],
		    int[2]);
@


1.34
log
@new error code "unsupported capability" from RFC 3392
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.33 2004/03/05 20:25:30 henning Exp $ */
d97 6
d143 4
d151 1
@


1.33
log
@add a parser for the capability announcements using the OPEN message as per
RFC 3392. we don't support any capability yet but this at least avoids one
session teardown and reestablishment when talking to peers which do support
capability announcement (as in: basically any) and we'll start supporting
some soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.32 2004/03/01 16:49:24 claudio Exp $ */
d87 2
a88 1
	ERR_OPEN_HOLDTIME
@


1.32
log
@Forgotten in the last commit. Sync printconfig and parser.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.31 2004/02/26 16:16:41 claudio Exp $ */
d88 6
@


1.31
log
@show rib infrastructure. At least full dumps and per as dumps. Per prefix
dump need some more work. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.30 2004/02/16 12:53:15 claudio Exp $ */
d195 1
a195 1
	    struct filter_head *);
@


1.30
log
@Make the path attribute handling more RFC conformant. Also move the
parser to rde_attr.c where it belongs. Still missing: better aspath loop
detection (should be done afterwards) and some basic error checking for
optional attributes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.29 2004/02/09 23:16:46 henning Exp $ */
d160 1
@


1.29
log
@print networks too
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.28 2004/02/09 01:38:55 henning Exp $ */
a72 9
};

enum err_codes {
	ERR_HEADER = 1,
	ERR_OPEN,
	ERR_UPDATE,
	ERR_HOLDTIMEREXPIRED,
	ERR_FSM,
	ERR_CEASE
@


1.28
log
@print more fluff
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.27 2004/02/08 23:44:57 henning Exp $ */
d202 2
a203 1
void	print_config(struct bgpd_config *, struct peer *, struct filter_head *);
@


1.27
log
@factor out functions to print the configuration (rules only for now)
will become more and needed by bgpctl too
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.26 2004/02/07 11:42:30 henning Exp $ */
d202 1
a202 1
void		 print_rule(struct peer *, struct filter_rule *);
@


1.26
log
@send filter rules to the RDE on reloads, help & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.25 2004/02/06 20:18:18 henning Exp $ */
d200 3
@


1.25
log
@initial cut at the filtering language.
structs etc to describe a rule, filter rule list management
parser groks filter defs now.

claudio ok, discussion & help also jakob theo
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.24 2004/01/28 17:57:08 henning Exp $ */
d187 1
a187 1
	    int[2], int[2]);
@


1.24
log
@we need a pfkey_init the gets us a PF_KEY socket before we drop privs
eases other code quite a bit in exchange...
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.23 2004/01/28 17:27:55 henning Exp $ */
d179 1
a179 1
	    struct peer **, struct network_head *);
@


1.23
log
@-struct peer_auth to store the SPIs, linked into struct peer
-add pfkey_auth_establish(), which sets up flows for both directions and
 stores the SPIs in above struct
-add (yet dummy) pfkey_auth_remove()

with markus, ok claudio markus
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.22 2004/01/22 20:59:17 henning Exp $ */
d199 1
@


1.22
log
@make log_peer_* take a struct peer_config instead of the session engine
specific struct peer, and move their prototypes to bgpd.h to make it available
to whole bgpd

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.21 2004/01/22 19:07:34 henning Exp $ */
d134 5
d142 1
d195 4
@


1.21
log
@log_peer_err -> log_peer_warn
log_peer_errx -> log_peer_warnx
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.20 2004/01/17 19:35:36 claudio Exp $ */
a164 2
void		 log_peer_warn(const struct peer *, const char *, ...);
void		 log_peer_warnx(const struct peer *, const char *, ...);
@


1.20
log
@Make it possible to announce own networks. In the RDE these prefixes are
attached to a pseudo peer and inserted like all other prefixes into the RIB.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.19 2004/01/11 18:42:25 henning Exp $ */
d165 2
a166 2
void		 log_peer_err(const struct peer *, const char *, ...);
void		 log_peer_errx(const struct peer *, const char *, ...);
@


1.19
log
@clean up setting the poll events a bit. no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.18 2004/01/11 01:04:43 henning Exp $ */
d175 1
a175 1
	    struct peer **);
d182 2
a183 1
int	 rde_main(struct bgpd_config *, struct peer *, int[2], int[2]);
@


1.18
log
@once the tcp session is established use gettsockname/getpeername to get
local/remote sockaddr and store it in the peer struct

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.17 2004/01/09 13:47:08 henning Exp $ */
a146 1
	int			 events;
@


1.17
log
@get us a stateful imsg relaying framework, and the first receiver,
IMSG_CTL_KROUTE, to have the kroute structs forming the fib sent to a
control socket.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.16 2004/01/06 23:14:58 henning Exp $ */
d20 1
d148 2
@


1.16
log
@two new imsg types, IMSG_CTL_NEIGHBOR_UP and _DOWN, on their receival on the
control socket the given neighbor session is sent a START / STOP signal.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.15 2004/01/06 19:21:22 henning Exp $ */
d160 1
a160 1
int		 imsg_compose_parent(int, u_int32_t, void *, u_int16_t);
@


1.15
log
@lower the initial value for the IdleHold timer from 90 to 30 seconds.
90 is too much, and now that the punishment works as intended oscillating
peers get slowed down by that
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.14 2004/01/06 19:19:21 henning Exp $ */
d158 1
@


1.14
log
@properly punish oscillating neighbors.
previously we were to forgiving so the punishment didn't kick in as
intended
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.13 2004/01/06 18:01:27 henning Exp $ */
d26 1
a26 1
#define	INTERVAL_IDLE_HOLD_INITIAL	90
@


1.13
log
@rename our StartTimer to IdleHoldTimer as per draft-ietf-idr-bgp4-23
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.12 2004/01/06 03:43:51 henning Exp $ */
d26 4
a29 3
#define INTERVAL_IDLE_HOLD_INITIAL	90
#define MSGSIZE_HEADER			19
#define MSGSIZE_HEADER_MARKER		16
d143 1
@


1.12
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.11 2004/01/05 22:57:58 claudio Exp $ */
d26 1
a26 1
#define INTERVAL_START			90
d141 2
a142 2
	time_t			 StartTimer;
	u_int			 StartTimerInterval;
@


1.11
log
@Big overhaul of the mrt code.
Dumping of incomming bgp messages is now possible and dumping the (not yet)
filtered updates works too. Per neighbor dumps are still missing.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.10 2004/01/04 20:07:30 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.10
log
@keep seperate message counters for open/update/keepalive/notification
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.9 2004/01/04 19:39:46 henning Exp $ */
d169 1
a169 1
int	 parse_config(char *, struct bgpd_config *, struct mrt_config *,
@


1.9
log
@-new imsg CTL_RELOAD
-upong receival in the SE forward to parent
-make sending messages from SE to parent work for that (was not required before)
-parent reacts to that just like a SIGHUP, reread config file
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.8 2004/01/04 18:51:23 henning Exp $ */
d120 8
a127 2
	u_int64_t		 msg_rcvd;
	u_int64_t		 msg_send;
@


1.8
log
@allow "show neighbor" to be limited to one specific neighbor
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.7 2004/01/03 22:44:29 henning Exp $ */
d151 1
a151 1

@


1.7
log
@keep track of last session up/down and last successfull read
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.6 2004/01/03 22:18:58 henning Exp $ */
d147 2
a148 2
void		 session_socket_blockmode(int, enum blockmodes);
int		 session_main(struct bgpd_config *, struct peer *, int[2],
d150 2
@


1.6
log
@add message counters
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.5 2004/01/03 20:37:34 henning Exp $ */
d20 1
d122 2
@


1.5
log
@move some session specific stuff to session.h and make the few files
that need it include that
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.4 2004/01/03 20:22:07 henning Exp $ */
d118 5
d125 1
@


1.4
log
@decouple the peer list from bgpd_config.
so many parts of bgpd are not at all interested in the session specific peer
structs... allows for some further cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.3 2004/01/01 23:46:47 henning Exp $ */
d33 32
d118 17
d136 25
@


1.3
log
@listen on a AF_LOCAL socket for imsgs too.
only implemented type yet is IMSG_CTL_SHOW_NEIGHBOR which sends back
the struct peer for all neighbors.
will be used by bgpdctl
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.2 2003/12/19 21:07:05 henning Exp $ */
d86 1
a86 1
struct bgpd_config	*conf;
@


1.2
log
@zap the msg_ struct we don't ever use
@
text
@d1 1
a1 1
/*	$OpenBSD: session.h,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d78 16
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a77 20

struct msg_notification {
	struct msg_header	 header;
	u_int8_t		 errcode;
	u_int8_t		 subcode;
};

struct msg_keepalive {
	struct msg_header	 header;
};

struct msg_update {
	struct msg_header	 header;
	u_int16_t		 withdrawn_len;
	char			*withdrawn_data;
	u_int16_t		 path_len;
	char			*path_data;
	char			*nlri;	/* Network Layer Reachability Info */
};

@

