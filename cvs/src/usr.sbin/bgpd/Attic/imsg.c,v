head	1.51;
access;
symbols
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.47.0.4
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.42.0.4
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.38.0.4
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.38.0.2
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.34.0.2
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24;
locks; strict;
comment	@ * @;


1.51
date	2010.05.26.16.44.32;	author nicm;	state dead;
branches;
next	1.50;

1.50
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2010.04.07.18.09.39;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2009.08.08.18.33.40;	author nicm;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.08.08.30.06;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2009.06.07.05.56.24;	author eric;	state Exp;
branches;
next	1.45;

1.45
date	2009.06.07.00.40.46;	author eric;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.06.22.11.25;	author eric;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.06.06.33.15;	author eric;	state Exp;
branches;
next	1.42;

1.42
date	2008.03.24.16.11.02;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2008.03.15.16.25.00;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2008.03.13.01.49.53;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.19.10.03.25;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.27.19.59.44;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.02.15.34.43;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.26.15.18.22;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.23.10.46.27;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.09.14.08.03;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.17.11.49.19;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2004.09.16.17.58.13;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.09.16.17.36.29;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.19.10.40.14;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.11.10.10.28;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.05.02.13.44;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.20.18.07.06;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.20.17.49.46;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.29.19.56.04;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.12.20.48.09;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.16.14.26.29;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.22.20.34.56;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.22.03.18.03;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.09.13.47.07;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.03.14.06.35;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.01.23.46.47;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.01.23.40.25;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.01.23.09.09;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.30.22.42.31;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.30.20.59.43;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.28.14.34.30;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.26.18.33.11;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.26.18.07.32;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.24.13.28.02;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.21.23.28.39;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.21.23.26.37;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.20.21.19.40;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.20.21.14.55;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.20.18.39.05;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.20.14.33.09;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Move imsg into libutil and add a man page.

Minor bump for libutil.

Previous versions of this diff and man page looked at by various people.

"you should just commit" deraadt
@
text
@/*	$OpenBSD: imsg.c,v 1.50 2010/05/26 13:56:07 nicm Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "imsg.h"

int	 imsg_get_fd(struct imsgbuf *);

void
imsg_init(struct imsgbuf *ibuf, int fd)
{
	msgbuf_init(&ibuf->w);
	bzero(&ibuf->r, sizeof(ibuf->r));
	ibuf->fd = fd;
	ibuf->w.fd = fd;
	ibuf->pid = getpid();
	TAILQ_INIT(&ibuf->fds);
}

ssize_t
imsg_read(struct imsgbuf *ibuf)
{
	struct msghdr		 msg;
	struct cmsghdr		*cmsg;
	union {
		struct cmsghdr hdr;
		char	buf[CMSG_SPACE(sizeof(int) * 16)];
	} cmsgbuf;
	struct iovec		 iov;
	ssize_t			 n;
	int			 fd;
	struct imsg_fd		*ifd;

	bzero(&msg, sizeof(msg));

	iov.iov_base = ibuf->r.buf + ibuf->r.wpos;
	iov.iov_len = sizeof(ibuf->r.buf) - ibuf->r.wpos;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);

	if ((n = recvmsg(ibuf->fd, &msg, 0)) == -1) {
		if (errno != EINTR && errno != EAGAIN) {
			return (-1);
		}
		return (-2);
	}

	ibuf->r.wpos += n;

	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
	    cmsg = CMSG_NXTHDR(&msg, cmsg)) {
		if (cmsg->cmsg_level == SOL_SOCKET &&
		    cmsg->cmsg_type == SCM_RIGHTS) {
			fd = (*(int *)CMSG_DATA(cmsg));
			if ((ifd = calloc(1, sizeof(struct imsg_fd))) == NULL) {
				close(fd);
				return (-1);
			}
			ifd->fd = fd;
			TAILQ_INSERT_TAIL(&ibuf->fds, ifd, entry);
		}
		/* we do not handle other ctl data level */
	}

	return (n);
}

ssize_t
imsg_get(struct imsgbuf *ibuf, struct imsg *imsg)
{
	size_t			 av, left, datalen;

	av = ibuf->r.wpos;

	if (IMSG_HEADER_SIZE > av)
		return (0);

	memcpy(&imsg->hdr, ibuf->r.buf, sizeof(imsg->hdr));
	if (imsg->hdr.len < IMSG_HEADER_SIZE ||
	    imsg->hdr.len > MAX_IMSGSIZE) {
		errno = ERANGE;
		return (-1);
	}
	if (imsg->hdr.len > av)
		return (0);
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;
	ibuf->r.rptr = ibuf->r.buf + IMSG_HEADER_SIZE;
	if ((imsg->data = malloc(datalen)) == NULL)
		return (-1);

	if (imsg->hdr.flags & IMSGF_HASFD)
		imsg->fd = imsg_get_fd(ibuf);
	else
		imsg->fd = -1;

	memcpy(imsg->data, ibuf->r.rptr, datalen);

	if (imsg->hdr.len < av) {
		left = av - imsg->hdr.len;
		memmove(&ibuf->r.buf, ibuf->r.buf + imsg->hdr.len, left);
		ibuf->r.wpos = left;
	} else
		ibuf->r.wpos = 0;

	return (datalen + IMSG_HEADER_SIZE);
}

int
imsg_compose(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,
    pid_t pid, int fd, void *data, u_int16_t datalen)
{
	struct ibuf	*wbuf;

	if ((wbuf = imsg_create(ibuf, type, peerid, pid, datalen)) == NULL)
		return (-1);

	if (imsg_add(wbuf, data, datalen) == -1)
		return (-1);

	wbuf->fd = fd;

	imsg_close(ibuf, wbuf);

	return (1);
}

int
imsg_composev(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,
    pid_t pid, int fd, const struct iovec *iov, int iovcnt)
{
	struct ibuf	*wbuf;
	int		 i, datalen = 0;

	for (i = 0; i < iovcnt; i++)
		datalen += iov[i].iov_len;

	if ((wbuf = imsg_create(ibuf, type, peerid, pid, datalen)) == NULL)
		return (-1);

	for (i = 0; i < iovcnt; i++)
		if (imsg_add(wbuf, iov[i].iov_base, iov[i].iov_len) == -1)
			return (-1);

	wbuf->fd = fd;

	imsg_close(ibuf, wbuf);

	return (1);
}

/* ARGSUSED */
struct ibuf *
imsg_create(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,
    pid_t pid, u_int16_t datalen)
{
	struct ibuf	*wbuf;
	struct imsg_hdr	 hdr;

	datalen += IMSG_HEADER_SIZE;
	if (datalen > MAX_IMSGSIZE) {
		errno = ERANGE;
		return (NULL);
	}

	hdr.type = type;
	hdr.flags = 0;
	hdr.peerid = peerid;
	if ((hdr.pid = pid) == 0)
		hdr.pid = ibuf->pid;
	if ((wbuf = ibuf_dynamic(datalen, MAX_IMSGSIZE)) == NULL) {
		return (NULL);
	}
	if (imsg_add(wbuf, &hdr, sizeof(hdr)) == -1)
		return (NULL);

	return (wbuf);
}

int
imsg_add(struct ibuf *msg, void *data, u_int16_t datalen)
{
	if (datalen)
		if (ibuf_add(msg, data, datalen) == -1) {
			ibuf_free(msg);
			return (-1);
		}
	return (datalen);
}

void
imsg_close(struct imsgbuf *ibuf, struct ibuf *msg)
{
	struct imsg_hdr	*hdr;

	hdr = (struct imsg_hdr *)msg->buf;

	hdr->flags &= ~IMSGF_HASFD;
	if (msg->fd != -1)
		hdr->flags |= IMSGF_HASFD;

	hdr->len = (u_int16_t)msg->wpos;

	ibuf_close(&ibuf->w, msg);
}

void
imsg_free(struct imsg *imsg)
{
	free(imsg->data);
}

int
imsg_get_fd(struct imsgbuf *ibuf)
{
	int		 fd;
	struct imsg_fd	*ifd;

	if ((ifd = TAILQ_FIRST(&ibuf->fds)) == NULL)
		return (-1);

	fd = ifd->fd;
	TAILQ_REMOVE(&ibuf->fds, ifd, entry);
	free(ifd);

	return (fd);
}

int
imsg_flush(struct imsgbuf *ibuf)
{
	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) < 0)
			return (-1);
	return (0);
}

void
imsg_clear(struct imsgbuf *ibuf)
{
	int	fd;

	msgbuf_clear(&ibuf->w);
	while ((fd = imsg_get_fd(ibuf)) != -1)
		close(fd);
}
@


1.50
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.19 2010/04/07 18:09:39 nicm Exp $	*/
@


1.49
log
@Remove XXX comment and just close received fd if calloc() fails.

If this happens the imsg may no longer be usable as there may be queued
messages, but this is a) already the case with the code now, and b)
would be the case if recvmsg() fails anyway, so we can document that -1
from imsg_read() invalidates the struct imsgbuf.

discussed with and ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.1 2009/08/11 17:18:35 nicm Exp $	*/
d138 1
a138 1
	struct buf	*wbuf;
d157 1
a157 1
	struct buf	*wbuf;
d178 1
a178 1
struct buf *
d182 1
a182 1
	struct buf	*wbuf;
d196 1
a196 1
	if ((wbuf = buf_dynamic(datalen, MAX_IMSGSIZE)) == NULL) {
d206 1
a206 1
imsg_add(struct buf *msg, void *data, u_int16_t datalen)
d209 2
a210 2
		if (buf_add(msg, data, datalen) == -1) {
			buf_free(msg);
d217 1
a217 1
imsg_close(struct imsgbuf *ibuf, struct buf *msg)
d229 1
a229 1
	buf_close(&ibuf->w, msg);
@


1.48
log
@Make imsg_clear close and free any fds in the received fd queue as well as
freeing the msgbuf.

While here also remove an unnecessary while loop.

ok eric pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.47 2009/06/08 08:30:06 dlg Exp $	*/
d82 1
a82 1
				/* XXX: this return can leak */
@


1.47
log
@revert this change by eric@@:

Make the imsg protocol network-safe.


it might be network safe, but half the imsg based daemons on my firewalls
dont run anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.46 2009/06/07 05:56:24 eric Exp $	*/
d266 5
a270 2
	while (ibuf->w.queued)
		msgbuf_clear(&ibuf->w);
@


1.46
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.26 2009/06/07 00:40:46 eric Exp $	*/
d110 1
a110 1
	if ((imsg->hdr.len = ntohs(imsg->hdr.len)) > av)
a111 4
	imsg->hdr.type = ntohl(imsg->hdr.type);
	imsg->hdr.flags = ntohs(imsg->hdr.flags);
	imsg->hdr.peerid = ntohl(imsg->hdr.peerid);
	imsg->hdr.pid = ntohl(imsg->hdr.pid);
d227 2
a228 5
	hdr->type = htonl(hdr->type);
	hdr->len = htons(msg->wpos);
	hdr->flags = htons(hdr->flags);
	hdr->peerid = htonl(hdr->peerid);
	hdr->pid = htonl(hdr->pid);
@


1.45
log
@Make the imsg protocol network-safe.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.25 2009/06/06 22:11:25 eric Exp $	*/
d31 2
d118 1
a118 1
	if ((imsg->data = malloc(datalen)) == NULL) {
d120 6
a125 1
	}
d226 5
@


1.44
log
@change the imsg header fields a bit to prepare for upcoming changes.
add a flag field, use u_int32_t for pid_t and extend type to 32 bits
for padding.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.24 2009/06/06 05:04:12 pyr Exp $	*/
d108 1
a108 1
	if (imsg->hdr.len > av)
d110 4
d219 5
a223 1
	hdr->len = (u_int16_t)msg->wpos;
@


1.43
log
@sync bgpd/bgpctl with the common imsg code, making it lib ready as well.

ok claudio@@ pyr@@
@
text
@d128 1
a128 1
imsg_compose(struct imsgbuf *ibuf, u_int16_t type, u_int32_t peerid,
d147 1
a147 1
imsg_composev(struct imsgbuf *ibuf, u_int16_t type, u_int32_t peerid,
d172 1
a172 1
imsg_create(struct imsgbuf *ibuf, u_int16_t type, u_int32_t peerid,
d185 1
@


1.42
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.41 2008/03/15 16:25:00 deraadt Exp $ */
d19 3
a21 1
#include <sys/types.h>
d29 1
a29 1
#include "bgpd.h"
d42 1
a42 1
int
d49 1
a49 1
		char buf[CMSG_SPACE(sizeof(int) * 16)];
d57 1
a66 1
			log_warn("imsg_read: pipe read error");
d79 4
a82 2
			if ((ifd = calloc(1, sizeof(struct imsg_fd))) == NULL)
				fatal("imsg_read calloc");
d85 2
a86 3
		} else
			log_warn("imsg_read: got unexpected ctl data level %d "
			    "type %d", cmsg->cmsg_level, cmsg->cmsg_type);
d92 1
a92 1
int
d105 1
a105 2
		log_warnx("imsg_get: imsg hdr len %u out of bounds, type=%u",
		    imsg->hdr.len, imsg->hdr.type);
a112 1
		log_warn("imsg_get");
d128 2
a129 2
imsg_compose(struct imsgbuf *ibuf, enum imsg_type type, u_int32_t peerid,
    pid_t pid, int fd, const void *data, u_int16_t datalen)
a131 1
	int		 n;
d141 16
a156 1
	if ((n = imsg_close(ibuf, wbuf)) < 0)
d159 9
a167 1
	return (n);
d170 1
d172 1
a172 1
imsg_create(struct imsgbuf *ibuf, enum imsg_type type, u_int32_t peerid,
d178 3
a180 4
	if (datalen > MAX_IMSGSIZE - IMSG_HEADER_SIZE) {
		log_warnx("imsg_create: len %u > MAX_IMSGSIZE; "
		    "type %u peerid %lu", datalen + IMSG_HEADER_SIZE,
		    type, peerid);
a183 1
	hdr.len = datalen + IMSG_HEADER_SIZE;
d188 1
a188 2
	if ((wbuf = buf_open(hdr.len)) == NULL) {
		log_warn("imsg_create: buf_open");
d198 1
a198 1
imsg_add(struct buf *msg, const void *data, u_int16_t datalen)
a201 1
			log_warnx("imsg_add: buf_add error");
d208 1
a208 1
int
d211 1
a211 1
	int	n;
d213 3
a215 6
	if ((n = buf_close(&ibuf->w, msg)) < 0) {
			log_warnx("imsg_close: buf_close error");
			buf_free(msg);
			return (-1);
	}
	return (n);
d238 16
@


1.41
log
@Repair more msg_controllen dealing with structures or arrays of
descriptors; ok hshoexer, also looked at by kettenis and henning
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.40 2008/03/13 01:49:53 deraadt Exp $ */
d60 1
a60 1
	msg.msg_controllen = CMSG_LEN(sizeof(int) * 16);
@


1.40
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.39 2007/03/19 10:03:25 henning Exp $ */
d60 1
a60 1
	msg.msg_controllen = sizeof(cmsgbuf.buf);
@


1.39
log
@when our red/recv/recvmsg in imsg_read gives EINTR or EAGAIN, do not
signal "connection closed" upstream.
spotted by Valentin Kozamernik <tin@@komna.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.38 2006/05/27 19:59:44 henning Exp $ */
d45 4
a48 1
	char			 cmsgbuf[CMSG_SPACE(sizeof(int) * 16)];
d59 2
a60 2
	msg.msg_control = cmsgbuf;
	msg.msg_controllen = sizeof(cmsgbuf);
@


1.38
log
@if the pid given to imsg_create is 0, use the pid sored in the ibuf (which
is the current process' pid). fixes blocking with concurrent bgpctl
instances... oups. surprised we missed that earlier, the pid stuff was only
ever added for that purposed, but we missed to set the pid. gigantic oups.
with & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.37 2005/11/02 15:34:43 claudio Exp $ */
d64 1
a64 1
		return (0);
@


1.37
log
@Mark some additional function arguments as const.
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.36 2005/04/26 15:18:22 henning Exp $ */
d161 2
a162 1
	hdr.pid = pid;
@


1.36
log
@unify shared code a bit again to make future syncs easier
From: Alexander von Gernler <grunk@@pestilenz.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.35 2005/03/23 10:46:27 henning Exp $ */
d125 1
a125 1
    pid_t pid, int fd, void *data, u_int16_t datalen)
d173 1
a173 1
imsg_add(struct buf *msg, void *data, u_int16_t datalen)
@


1.35
log
@ssize_t -> size_t, from ntpd, there from Alexander von Gernler
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.34 2005/03/09 14:08:03 henning Exp $ */
d139 1
a139 1
			return (-1);
d152 1
a152 1
		log_warnx("imsg_create_core: len %u > MAX_IMSGSIZE; "
@


1.34
log
@correctness: memmove instead of memcpy where we might have overlaps
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.33 2004/09/17 11:49:19 claudio Exp $ */
d89 1
a89 2
	ssize_t			 datalen = 0;
	size_t			 av, left;
@


1.33
log
@Fix log message
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.32 2004/09/16 17:58:13 henning Exp $ */
d116 1
a116 1
		memcpy(&ibuf->r.buf, ibuf->r.buf + imsg->hdr.len, left);
@


1.32
log
@imsg type is really an enum imsg_type and not an int
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.31 2004/09/16 17:36:29 henning Exp $ */
d191 1
a191 1
			log_warnx("imsg_close: buf_add error");
@


1.31
log
@imsg API cleanup:
-kill imsg_compose_pid, imsg_compose_fdpass and imsg_create_pid
-extend the original imsg_compose/_create API to take pid & fd too
-make imsg_compose do imsg_create + imsg_add + imsg_close instead of
 duplicating the code
-adjust all callers to the new API
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.30 2004/08/19 10:40:14 henning Exp $ */
d125 2
a126 2
imsg_compose(struct imsgbuf *ibuf, int type, u_int32_t peerid, pid_t pid,
    int fd, void *data, u_int16_t datalen)
d146 1
a146 1
imsg_create(struct imsgbuf *ibuf, int type, u_int32_t peerid,
@


1.30
log
@better diagnostics
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.29 2004/08/11 10:10:28 claudio Exp $ */
a28 5
int		 imsg_compose_core(struct imsgbuf *, int, u_int32_t, void *,
		     u_int16_t, pid_t, int);
struct buf	*imsg_create_core(struct imsgbuf *, int, u_int32_t, u_int16_t,
		     pid_t);

d125 2
a126 24
imsg_compose(struct imsgbuf *ibuf, int type, u_int32_t peerid, void *data,
    u_int16_t datalen)
{
	return (imsg_compose_core(ibuf, type, peerid, data, datalen,
	    ibuf->pid, -1));
}

int
imsg_compose_pid(struct imsgbuf *ibuf, int type, pid_t pid, void *data,
    u_int16_t datalen)
{
	return (imsg_compose_core(ibuf, type, 0, data, datalen, pid, -1));
}

int
imsg_compose_fdpass(struct imsgbuf *ibuf, int type, int fd, void *data,
    u_int16_t datalen)
{
	return (imsg_compose_core(ibuf, type, 0, data, datalen, ibuf->pid, fd));
}

int
imsg_compose_core(struct imsgbuf *ibuf, int type, u_int32_t peerid, void *data,
    u_int16_t datalen, pid_t pid, int fd)
a128 1
	struct imsg_hdr	 hdr;
d131 1
a131 4
	if (datalen + IMSG_HEADER_SIZE > MAX_IMSGSIZE) {
		log_warnx("imsg_compose_core: len %u > MAX_IMSGSIZE; "
		    "type %u peerid %lu", datalen + IMSG_HEADER_SIZE,
		    type, peerid);
a132 1
	}
d134 1
a134 7
	hdr.len = datalen + IMSG_HEADER_SIZE;
	hdr.type = type;
	hdr.peerid = peerid;
	hdr.pid = pid;
	wbuf = buf_open(hdr.len);
	if (wbuf == NULL) {
		log_warn("imsg_compose: buf_open");
a135 12
	}
	if (buf_add(wbuf, &hdr, sizeof(hdr)) == -1) {
		log_warnx("imsg_compose: buf_add error");
		buf_free(wbuf);
		return (-1);
	}
	if (datalen)
		if (buf_add(wbuf, data, datalen) == -1) {
			log_warnx("imsg_compose: buf_add error");
			buf_free(wbuf);
			return (-1);
		}
d139 1
a139 3
	if ((n = buf_close(&ibuf->w, wbuf)) < 0) {
			log_warnx("imsg_compose: buf_add error");
			buf_free(wbuf);
d141 1
a141 1
	}
d146 2
a147 14
imsg_create(struct imsgbuf *ibuf, int type, u_int32_t peerid, u_int16_t dlen)
{
	return (imsg_create_core(ibuf, type, peerid, dlen, ibuf->pid));
}

struct buf *
imsg_create_pid(struct imsgbuf *ibuf, int type, pid_t pid, u_int16_t datalen)
{
	return (imsg_create_core(ibuf, type, 0, datalen, pid));
}

struct buf *
imsg_create_core(struct imsgbuf *ibuf, int type, u_int32_t peerid,
    u_int16_t datalen, pid_t pid)
d152 1
a152 1
	if (datalen + IMSG_HEADER_SIZE > MAX_IMSGSIZE) {
d163 1
a163 2
	wbuf = buf_open(hdr.len);
	if (wbuf == NULL) {
d167 1
a167 3
	if (buf_add(wbuf, &hdr, sizeof(hdr)) == -1) {
		log_warnx("imsg_create: buf_add error");
		buf_free(wbuf);
d169 1
a169 1
	}
@


1.29
log
@Typo. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.28 2004/07/05 02:13:44 henning Exp $ */
d105 2
a106 1
		log_warnx("imsg_get: imsg hdr len out of bounds");
d159 7
d215 7
@


1.28
log
@fix a few KNF fallouts
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.27 2004/06/20 18:07:06 henning Exp $ */
d84 1
a84 1
			log_warn("imsg_read: got unexpected ctl data lvel %d"
@


1.27
log
@allow for receival of up to 16 fds at once; after discussion with theo
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.26 2004/06/20 17:49:46 henning Exp $ */
d269 1
a269 1
	return(fd);
@


1.26
log
@implement file descriptor passing in the imsg/msgbuf framework, and use
it to let the main process to prepare new listening sockets (socket() and
bind()) on behalf of the session engine, which of course cannot bind() to
ports < 1024 any more once it dropped privileges. with some help from theo,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.25 2004/04/29 19:56:04 deraadt Exp $ */
d50 1
a50 1
	char			 cmsgbuf[CMSG_SPACE(sizeof(int))];
d74 2
a75 1
	if ((cmsg = CMSG_FIRSTHDR(&msg)) != NULL) {
@


1.25
log
@sock -> fd; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.24 2004/03/12 20:48:09 henning Exp $ */
d20 1
d30 1
a30 1
		     u_int16_t, pid_t);
d42 1
d48 4
d53 2
d56 9
a64 2
	if ((n = read(ibuf->fd, ibuf->r.buf + ibuf->r.wpos,
	    sizeof(ibuf->r.buf) - ibuf->r.wpos)) == -1) {
d74 13
d129 1
a129 1
    u_int16_t dlen)
d131 2
a132 1
	return (imsg_compose_core(ibuf, type, peerid, data, dlen, ibuf->pid));
d139 8
a146 1
	return (imsg_compose_core(ibuf, type, 0, data, datalen, pid));
d151 1
a151 1
    u_int16_t datalen, pid_t pid)
d178 2
d253 16
@


1.24
log
@tweak err reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.23 2004/02/16 14:26:29 claudio Exp $ */
d34 1
a34 1
imsg_init(struct imsgbuf *ibuf, int sock)
d38 2
a39 2
	ibuf->sock = sock;
	ibuf->w.sock = sock;
d48 1
a48 1
	if ((n = read(ibuf->sock, ibuf->r.buf + ibuf->r.wpos,
@


1.23
log
@Extend imsg API so that messages can be composed on the fly. In the RDE it
happens often, that imsg consists of multiple objects. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.22 2004/01/22 20:34:56 henning Exp $ */
d127 1
a127 1
		log_warnx("imsg_compose: buf_open error");
d175 1
a175 1
		log_warnx("imsg_create: buf_open error");
@


1.22
log
@use log_warnx and log_info. reclassify a few messages in the process and fix
a few messages.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.21 2004/01/22 03:18:03 henning Exp $ */
d28 4
a31 2
int	imsg_compose_core(struct imsgbuf *, int, u_int32_t, void *, u_int16_t,
	    pid_t);
d145 61
@


1.21
log
@s/log_err/log_warn/
it is like warn(3), nor err(3). so use a less confusing name.
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.20 2004/01/09 13:47:07 henning Exp $ */
d74 1
a74 1
		logit(LOG_CRIT, "wrong imsg hdr len");
d125 1
a125 1
		logit(LOG_CRIT, "imsg_compose: buf_open error");
d129 1
a129 1
		logit(LOG_CRIT, "imsg_compose: buf_add error");
d135 1
a135 1
			logit(LOG_CRIT, "imsg_compose: buf_add error");
d141 1
a141 1
			logit(LOG_CRIT, "imsg_compose: buf_add error");
@


1.20
log
@get us a stateful imsg relaying framework, and the first receiver,
IMSG_CTL_KROUTE, to have the kroute structs forming the fib sent to a
control socket.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.19 2004/01/06 03:43:50 henning Exp $ */
d49 1
a49 1
			log_err("imsg_read: pipe read error");
d82 1
a82 1
		log_err("imsg_get");
@


1.19
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.18 2004/01/03 14:06:35 henning Exp $ */
d28 3
d38 1
d99 7
d108 7
d122 1
@


1.18
log
@change imsg_read semantics so that the number of bytes read is returned.
that means that the callers can (and must) coope with closed connections
themselves, what is exactly the desired behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.17 2004/01/01 23:46:47 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.17
log
@listen on a AF_LOCAL socket for imsgs too.
only implemented type yet is IMSG_CTL_SHOW_NEIGHBOR which sends back
the struct peer for all neighbors.
will be used by bgpdctl
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.16 2004/01/01 23:40:25 henning Exp $ */
d45 1
a45 1
			log_err("imsg_get: pipe read error");
a49 4
	if (n == 0) {	/* connection closed */
		logit(LOG_CRIT, "imsg_get: pipe closed");
		return (-1);
	}
d53 1
a53 1
	return (0);
@


1.16
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.15 2004/01/01 23:09:09 henning Exp $ */
d66 1
a66 1
	av = ibuf->r.wpos; 
@


1.15
log
@now that imsg_get uses bigger buffers, one read call can put more than one
imsg into the buffer. since imsg_get by definition only returns one imsg we
missed the next imsg(s) until the next poll event on the socket in question,
building up a queue on that socket. didn't show up as a problem yet...
factor out imsg_read, which reads into the buffer. imsg_get now entirely
operates on the buffers and does not read(2) itself.
make all callers cope by calling imsg_read on poll events and calling
imsg_get in a loop until all imsgs are processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.14 2003/12/30 22:42:31 henning Exp $ */
d51 1
a51 1
		logit(LOG_CRIT, "imsg_get: pipe close");
@


1.14
log
@correctly free after buf_add/_close errs.
From: Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.13 2003/12/30 20:59:43 henning Exp $ */
d38 1
a38 1
imsg_get(struct imsgbuf *ibuf, struct imsg *imsg)
d40 1
a40 2
	ssize_t			 n, datalen = 0;
	size_t			 av, left;
d54 13
a66 1
	av = ibuf->r.wpos + n;
d69 1
a69 1
		return (-1);
d78 1
a78 1
		return (-1);
@


1.13
log
@missing free()s in error cases that (now) lead to program termination
From: Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.12 2003/12/28 14:34:30 henning Exp $ */
d104 1
a104 1
		free(wbuf);
d110 1
a110 1
			free(wbuf);
d116 1
a116 1
			free(wbuf);
@


1.12
log
@redo the imsg readers to use bigger buffers and less read(2)s. should increase
performance even further.
gets rif od struct imsg_readbuf; rename peer_read_buf to read_buf as that
is more appropriate now.
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.11 2003/12/26 18:33:11 henning Exp $ */
d104 1
d110 1
d116 1
@


1.11
log
@let imsg_get and imsg_compose not fatal() but return errors upstream.
make the callers cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.10 2003/12/26 18:07:32 henning Exp $ */
a27 10
void	imsg_init_readbuf(struct imsgbuf *);

void
imsg_init_readbuf(struct imsgbuf *ibuf)
{
	bzero(&ibuf->r, sizeof(ibuf->r));
	ibuf->r.wptr = ibuf->r.buf;
	ibuf->r.pkt_len = IMSG_HEADER_SIZE;
}

a30 1
	imsg_init_readbuf(ibuf);
d32 1
d40 8
a47 12
	struct imsg_hdr		*hdr;
	ssize_t			 n, read_total = 0, datalen = 0;
	u_char			*rptr;

	do {
		if ((n = read(ibuf->sock, ibuf->r.wptr,
		    ibuf->r.pkt_len - ibuf->r.read_len)) == -1) {
			if (errno != EAGAIN && errno != EINTR) {
				log_err("imsg_get pipe read error");
				return (-1);
			}
			return (0);
a48 33
		read_total += n;
		ibuf->r.wptr += n;
		ibuf->r.read_len += n;
		if (ibuf->r.read_len == ibuf->r.pkt_len) {
			if (!ibuf->r.seen_hdr) {	/* got header */
				hdr = (struct imsg_hdr *)&ibuf->r.buf;
				ibuf->r.type = hdr->type;
				ibuf->r.pkt_len = hdr->len;
				ibuf->r.peerid = hdr->peerid;
				if (hdr->len < IMSG_HEADER_SIZE ||
				    hdr->len > MAX_IMSGSIZE) {
					logit(LOG_CRIT, "wrong imsg hdr len");
					return (-1);
				}
				ibuf->r.seen_hdr = 1;
			} else {		/* we got the full packet */
				imsg->hdr.type = ibuf->r.type;
				imsg->hdr.len = ibuf->r.pkt_len;
				imsg->hdr.peerid = ibuf->r.peerid;
				datalen = ibuf->r.pkt_len - IMSG_HEADER_SIZE;
				rptr = ibuf->r.buf + IMSG_HEADER_SIZE;
				if ((imsg->data = malloc(datalen)) == NULL) {
					log_err("imsg_get");
					return (-1);
				}
				memcpy(imsg->data, rptr, datalen);
				n = 0;	/* give others a chance */
				imsg_init_readbuf(ibuf);
			}
		}
	} while (n > 0);

	if (read_total == 0)	/* connection closed */
d50 32
@


1.10
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.9 2003/12/24 13:28:02 henning Exp $ */
d57 4
a60 2
			if (errno != EAGAIN && errno != EINTR)
				fatal("pipe read error");
d73 4
a76 2
				    hdr->len > MAX_IMSGSIZE)
					fatalx("wrong imsg header len");
d84 4
a87 2
				if ((imsg->data = malloc(datalen)) == NULL)
					fatal("get_imsg malloc");
d113 8
a120 4
	if (wbuf == NULL)
		fatalx("imsg_compose: buf_open error");
	if (buf_add(wbuf, &hdr, sizeof(hdr)) == -1)
		fatalx("imsg_compose: buf_add error");
d122 4
a125 4
		if (buf_add(wbuf, data, datalen) == -1)
			fatalx("imsg_compose: buf_add error");
	if ((n = buf_close(&ibuf->w, wbuf)) < 0)
		fatal("imsg_compose: buf_close error");
d127 4
@


1.9
log
@handle write() returning 0 correctly, adjust the msgbuf API appropriately,
and make all callers cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.8 2003/12/21 23:28:39 henning Exp $ */
d58 1
a58 1
				fatal("pipe read error", errno);
d72 1
a72 1
					fatal("wrong imsg header len", 0);
d81 1
a81 1
					fatal("get_imsg malloc", errno);
d108 1
a108 1
		fatal("imsg_compose: buf_open error", 0);
d110 1
a110 1
		fatal("imsg_compose: buf_add error", 0);
d113 1
a113 1
			fatal("imsg_compose: buf_add error", 0);
d115 1
a115 1
		fatal("imsg_compose: buf_close error", errno);
@


1.8
log
@rename get_imsg() to imsg_get(); that's more consistent
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.7 2003/12/21 23:26:37 henning Exp $ */
d114 2
a115 2
	if ((n = buf_close(&ibuf->w, wbuf)) == -1)
		fatal("imsg_compose: buf_close error", 0);
@


1.7
log
@wrap read & write buffers for imsgs into a struct.
finally gives us read buffers per pipe instead of per process, eleminating
a possible race.
also gets us a real imsg_init() that does all the boring init work
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.6 2003/12/21 22:16:53 henning Exp $ */
d48 1
a48 1
get_imsg(struct imsgbuf *ibuf, struct imsg *imsg)
@


1.6
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.5 2003/12/20 21:19:40 claudio Exp $ */
d28 1
a28 1
static struct imsg_buf_read	buf;
d31 1
a31 1
init_imsg_buf(void)
d33 12
a44 3
	bzero(&buf, sizeof(buf));
	buf.wptr = buf.buf;
	buf.pkt_len = IMSG_HEADER_SIZE;
d48 1
a48 1
get_imsg(int fd, struct imsg *imsg)
d55 2
a56 2
		if ((n = read(fd, buf.wptr, buf.pkt_len - buf.read_len)) ==
		    -1) {
d62 8
a69 8
		buf.wptr += n;
		buf.read_len += n;
		if (buf.read_len == buf.pkt_len) {
			if (!buf.seen_hdr) {	/* got header */
				hdr = (struct imsg_hdr *)&buf.buf;
				buf.type = hdr->type;
				buf.pkt_len = hdr->len;
				buf.peerid = hdr->peerid;
d73 1
a73 1
				buf.seen_hdr = 1;
d75 5
a79 5
				imsg->hdr.type = buf.type;
				imsg->hdr.len = buf.pkt_len;
				imsg->hdr.peerid = buf.peerid;
				datalen = buf.pkt_len - IMSG_HEADER_SIZE;
				rptr = buf.buf + IMSG_HEADER_SIZE;
d84 1
a84 1
				init_imsg_buf();
d96 1
a96 1
imsg_compose(struct msgbuf *msgbuf, int type, u_int32_t peerid, void *data,
d114 1
a114 1
	if ((n = buf_close(msgbuf, wbuf)) == -1)
@


1.5
log
@more cast cleanup imsg_compose takes now a void * argument. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.4 2003/12/20 21:14:55 henning Exp $ */
d87 1
a87 1
imsg_compose(int fd, int type, u_int32_t peerid, void *data,
d97 1
a97 1
	wbuf = buf_open(NULL, fd, hdr.len);
d99 1
a99 1
		fatal("buf_open error", 0);
d101 1
a101 1
		fatal("buf_add error", 0);
d104 3
a106 3
			fatal("buf_add error", 0);
	if ((n = buf_close(wbuf)) == -1)
		fatal("buf_close error", 0);
@


1.4
log
@let buf_add take void *data instead of u_char *data and save a zillion
evil casts
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.3 2003/12/20 18:39:05 henning Exp $ */
d87 1
a87 1
imsg_compose(int fd, int type, u_int32_t peerid, u_char *data,
@


1.3
log
@fatal() is a bit too much on 0 bytes read. imsg_get returns 0 in other
cases as well and all receivers cope
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.2 2003/12/20 14:33:09 henning Exp $ */
d100 1
a100 1
	if (buf_add(wbuf, (u_char *)&hdr, sizeof(hdr)) == -1)
@


1.2
log
@read(2)/write(2) return ssize_t, not size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d79 4
a82 2
	if (read_total == 0)	/* connection closed ? */
		fatal("pipe closed", 0);
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d42 1
a42 1
	size_t			 n, read_total = 0, datalen = 0;
@

