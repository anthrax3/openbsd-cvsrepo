head	1.47;
access;
symbols
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.43.0.4
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.39.0.2
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.36.0.6
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.4
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17;
locks; strict;
comment	@ * @;


1.47
date	2010.05.26.16.44.32;	author nicm;	state dead;
branches;
next	1.46;

1.46
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2009.09.15.10.54.59;	author jacekm;	state Exp;
branches;
next	1.44;

1.44
date	2009.07.23.18.58.42;	author eric;	state Exp;
branches;
next	1.43;

1.43
date	2009.06.06.06.33.15;	author eric;	state Exp;
branches;
next	1.42;

1.42
date	2009.03.13.06.25.04;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2009.03.13.04.40.55;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2008.10.03.15.20.29;	author eric;	state Exp;
branches;
next	1.39;

1.39
date	2008.03.24.16.11.02;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2008.03.15.16.19.00;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.03.13.01.49.53;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2006.09.19.13.04.01;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.27.13.40.21;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.21.08.51.46;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.02.15.34.43;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.11.16.24.11;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.26.15.18.22;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.28.14.40.04;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.23.11.36.35;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.17.21.51.26;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.14.11.59.13;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.01.21.36.02;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.16.01.33.53;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.14.22.26.09;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.17.15.59.34;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.03.17.19.59;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.20.18.03.26;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.20.17.49.46;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.29.19.56.04;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.19.13.54.58;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.17.22.41.40;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.17.16.25.16;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.10.23.25.44;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.10.21.02.54;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.05.22.57.59;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.26.17.13.52;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.24.13.28.01;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.23.19.14.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.21.23.48.46;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.21.18.04.08;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.21.16.11.33;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.20.21.14.55;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.20.14.33.09;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Move imsg into libutil and add a man page.

Minor bump for libutil.

Previous versions of this diff and man page looked at by various people.

"you should just commit" deraadt
@
text
@/*	$OpenBSD: buffer.c,v 1.46 2010/05/26 13:56:07 nicm Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "imsg.h"

int	ibuf_realloc(struct ibuf *, size_t);
void	ibuf_enqueue(struct msgbuf *, struct ibuf *);
void	ibuf_dequeue(struct msgbuf *, struct ibuf *);

struct ibuf *
ibuf_open(size_t len)
{
	struct ibuf	*buf;

	if ((buf = calloc(1, sizeof(struct ibuf))) == NULL)
		return (NULL);
	if ((buf->buf = malloc(len)) == NULL) {
		free(buf);
		return (NULL);
	}
	buf->size = buf->max = len;
	buf->fd = -1;

	return (buf);
}

struct ibuf *
ibuf_dynamic(size_t len, size_t max)
{
	struct ibuf	*buf;

	if (max < len)
		return (NULL);

	if ((buf = ibuf_open(len)) == NULL)
		return (NULL);

	if (max > 0)
		buf->max = max;

	return (buf);
}

int
ibuf_realloc(struct ibuf *buf, size_t len)
{
	u_char	*b;

	/* on static buffers max is eq size and so the following fails */
	if (buf->wpos + len > buf->max) {
		errno = ENOMEM;
		return (-1);
	}

	b = realloc(buf->buf, buf->wpos + len);
	if (b == NULL)
		return (-1);
	buf->buf = b;
	buf->size = buf->wpos + len;

	return (0);
}

int
ibuf_add(struct ibuf *buf, const void *data, size_t len)
{
	if (buf->wpos + len > buf->size)
		if (ibuf_realloc(buf, len) == -1)
			return (-1);

	memcpy(buf->buf + buf->wpos, data, len);
	buf->wpos += len;
	return (0);
}

void *
ibuf_reserve(struct ibuf *buf, size_t len)
{
	void	*b;

	if (buf->wpos + len > buf->size)
		if (ibuf_realloc(buf, len) == -1)
			return (NULL);

	b = buf->buf + buf->wpos;
	buf->wpos += len;
	return (b);
}

void *
ibuf_seek(struct ibuf *buf, size_t pos, size_t len)
{
	/* only allowed to seek in already written parts */
	if (pos + len > buf->wpos)
		return (NULL);

	return (buf->buf + pos);
}

size_t
ibuf_size(struct ibuf *buf)
{
	return (buf->wpos);
}

size_t
ibuf_left(struct ibuf *buf)
{
	return (buf->max - buf->wpos);
}

void
ibuf_close(struct msgbuf *msgbuf, struct ibuf *buf)
{
	ibuf_enqueue(msgbuf, buf);
}

int
ibuf_write(struct msgbuf *msgbuf)
{
	struct iovec	 iov[IOV_MAX];
	struct ibuf	*buf;
	unsigned int	 i = 0;
	ssize_t	n;

	bzero(&iov, sizeof(iov));
	TAILQ_FOREACH(buf, &msgbuf->bufs, entry) {
		if (i >= IOV_MAX)
			break;
		iov[i].iov_base = buf->buf + buf->rpos;
		iov[i].iov_len = buf->wpos - buf->rpos;
		i++;
	}

	if ((n = writev(msgbuf->fd, iov, i)) == -1) {
		if (errno == EAGAIN || errno == ENOBUFS ||
		    errno == EINTR)	/* try later */
			return (0);
		else
			return (-1);
	}

	if (n == 0) {			/* connection closed */
		errno = 0;
		return (-2);
	}

	msgbuf_drain(msgbuf, n);

	return (0);
}

void
ibuf_free(struct ibuf *buf)
{
	free(buf->buf);
	free(buf);
}

void
msgbuf_init(struct msgbuf *msgbuf)
{
	msgbuf->queued = 0;
	msgbuf->fd = -1;
	TAILQ_INIT(&msgbuf->bufs);
}

void
msgbuf_drain(struct msgbuf *msgbuf, size_t n)
{
	struct ibuf	*buf, *next;

	for (buf = TAILQ_FIRST(&msgbuf->bufs); buf != NULL && n > 0;
	    buf = next) {
		next = TAILQ_NEXT(buf, entry);
		if (buf->rpos + n >= buf->wpos) {
			n -= buf->wpos - buf->rpos;
			ibuf_dequeue(msgbuf, buf);
		} else {
			buf->rpos += n;
			n = 0;
		}
	}
}

void
msgbuf_clear(struct msgbuf *msgbuf)
{
	struct ibuf	*buf;

	while ((buf = TAILQ_FIRST(&msgbuf->bufs)) != NULL)
		ibuf_dequeue(msgbuf, buf);
}

int
msgbuf_write(struct msgbuf *msgbuf)
{
	struct iovec	 iov[IOV_MAX];
	struct ibuf	*buf;
	unsigned int	 i = 0;
	ssize_t		 n;
	struct msghdr	 msg;
	struct cmsghdr	*cmsg;
	union {
		struct cmsghdr	hdr;
		char		buf[CMSG_SPACE(sizeof(int))];
	} cmsgbuf;

	bzero(&iov, sizeof(iov));
	bzero(&msg, sizeof(msg));
	TAILQ_FOREACH(buf, &msgbuf->bufs, entry) {
		if (i >= IOV_MAX)
			break;
		iov[i].iov_base = buf->buf + buf->rpos;
		iov[i].iov_len = buf->wpos - buf->rpos;
		i++;
		if (buf->fd != -1)
			break;
	}

	msg.msg_iov = iov;
	msg.msg_iovlen = i;

	if (buf != NULL && buf->fd != -1) {
		msg.msg_control = (caddr_t)&cmsgbuf.buf;
		msg.msg_controllen = sizeof(cmsgbuf.buf);
		cmsg = CMSG_FIRSTHDR(&msg);
		cmsg->cmsg_len = CMSG_LEN(sizeof(int));
		cmsg->cmsg_level = SOL_SOCKET;
		cmsg->cmsg_type = SCM_RIGHTS;
		*(int *)CMSG_DATA(cmsg) = buf->fd;
	}

	if ((n = sendmsg(msgbuf->fd, &msg, 0)) == -1) {
		if (errno == EAGAIN || errno == ENOBUFS ||
		    errno == EINTR)	/* try later */
			return (0);
		else
			return (-1);
	}

	if (n == 0) {			/* connection closed */
		errno = 0;
		return (-2);
	}

	/*
	 * assumption: fd got sent if sendmsg sent anything
	 * this works because fds are passed one at a time
	 */
	if (buf != NULL && buf->fd != -1) {
		close(buf->fd);
		buf->fd = -1;
	}

	msgbuf_drain(msgbuf, n);

	return (0);
}

void
ibuf_enqueue(struct msgbuf *msgbuf, struct ibuf *buf)
{
	TAILQ_INSERT_TAIL(&msgbuf->bufs, buf, entry);
	msgbuf->queued++;
}

void
ibuf_dequeue(struct msgbuf *msgbuf, struct ibuf *buf)
{
	TAILQ_REMOVE(&msgbuf->bufs, buf, entry);

	if (buf->fd != -1)
		close(buf->fd);

	msgbuf->queued--;
	ibuf_free(buf);
}
@


1.46
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.12 2009/09/15 10:54:59 jacekm Exp $	*/
@


1.45
log
@Enclose repeated buffer draining code in a new msgbuf_drain()
function, which is additionally exported for use by others.

It will be needed by smtpd's SSL module when the SMTP client code
is changed to replace libevent's evbuffers with our msgbuf_* API.

ok gilles@@ henning@@ guenther@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.44 2009/07/23 18:58:42 eric Exp $	*/
d31 3
a33 3
int	buf_realloc(struct buf *, size_t);
void	buf_enqueue(struct msgbuf *, struct buf *);
void	buf_dequeue(struct msgbuf *, struct buf *);
d35 2
a36 2
struct buf *
buf_open(size_t len)
d38 1
a38 1
	struct buf	*buf;
d40 1
a40 1
	if ((buf = calloc(1, sizeof(struct buf))) == NULL)
d52 2
a53 2
struct buf *
buf_dynamic(size_t len, size_t max)
d55 1
a55 1
	struct buf	*buf;
d60 1
a60 1
	if ((buf = buf_open(len)) == NULL)
d70 1
a70 1
buf_realloc(struct buf *buf, size_t len)
d90 1
a90 1
buf_add(struct buf *buf, const void *data, size_t len)
d93 1
a93 1
		if (buf_realloc(buf, len) == -1)
d102 1
a102 1
buf_reserve(struct buf *buf, size_t len)
d107 1
a107 1
		if (buf_realloc(buf, len) == -1)
d116 1
a116 1
buf_seek(struct buf *buf, size_t pos, size_t len)
d126 1
a126 1
buf_size(struct buf *buf)
d132 1
a132 1
buf_left(struct buf *buf)
d138 1
a138 1
buf_close(struct msgbuf *msgbuf, struct buf *buf)
d140 1
a140 1
	buf_enqueue(msgbuf, buf);
d144 1
a144 1
buf_write(struct msgbuf *msgbuf)
d147 1
a147 1
	struct buf	*buf;
d179 1
a179 1
buf_free(struct buf *buf)
d196 1
a196 1
	struct buf	*buf, *next;
d203 1
a203 1
			buf_dequeue(msgbuf, buf);
d214 1
a214 1
	struct buf	*buf;
d217 1
a217 1
		buf_dequeue(msgbuf, buf);
d224 1
a224 1
	struct buf	*buf;
d287 1
a287 1
buf_enqueue(struct msgbuf *msgbuf, struct buf *buf)
d294 1
a294 1
buf_dequeue(struct msgbuf *msgbuf, struct buf *buf)
d302 1
a302 1
	buf_free(buf);
@


1.44
log
@make buf_write() behave like msgbuf_write(): send out only the
bytes that were filled, not the whole buffer.

ok pyr@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.20 2009/06/05 21:15:47 pyr Exp $	*/
d147 1
a147 1
	struct buf	*buf, *next;
d173 1
a173 11
	for (buf = TAILQ_FIRST(&msgbuf->bufs); buf != NULL && n > 0;
	    buf = next) {
		next = TAILQ_NEXT(buf, entry);
		if (buf->rpos + n >= buf->wpos) {
			n -= buf->wpos - buf->rpos;
			buf_dequeue(msgbuf, buf);
		} else {
			buf->rpos += n;
			n = 0;
		}
	}
d194 18
d224 1
a224 1
	struct buf	*buf, *next;
d281 1
a281 11
	for (buf = TAILQ_FIRST(&msgbuf->bufs); buf != NULL && n > 0;
	    buf = next) {
		next = TAILQ_NEXT(buf, entry);
		if (buf->rpos + n >= buf->wpos) {
			n -= buf->wpos - buf->rpos;
			buf_dequeue(msgbuf, buf);
		} else {
			buf->rpos += n;
			n = 0;
		}
	}
@


1.43
log
@sync bgpd/bgpctl with the common imsg code, making it lib ready as well.

ok claudio@@ pyr@@
@
text
@d156 1
a156 1
		iov[i].iov_len = buf->size - buf->rpos;
d176 2
a177 2
		if (buf->rpos + n >= buf->size) {
			n -= buf->size - buf->rpos;
@


1.42
log
@Next step in mrt cleanup. Switch buf_write to a smarter version of itself.
Doing more the stuff msgbuf_write does and switch the only user -- mrt --
over to use this simpler way of writing out stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.41 2009/03/13 04:40:55 claudio Exp $ */
d19 3
a21 1
#include <sys/types.h>
a24 2
#include <limits.h>
#include <stdio.h>
d29 1
a29 1
#include "bgpd.h"
d137 1
a137 1
int
a139 2
	/* truncate buffer to the correct length before queuing */
	buf->size = buf->wpos;
a140 1
	return (1);
d223 1
a223 1
		char 		buf[CMSG_SPACE(sizeof(int))];
d232 1
a232 1
		iov[i].iov_len = buf->size - buf->rpos;
d276 2
a277 2
		if (buf->rpos + n >= buf->size) {
			n -= buf->size - buf->rpos;
@


1.41
log
@Sync buffer API with the one from ospfd. The dynamic buffers will make other
code much easier to write. OK henning@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.40 2008/10/03 15:20:29 eric Exp $ */
d147 1
a147 1
buf_write(int sock, struct buf *buf)
d149 3
d154 10
a163 2
	if ((n = write(sock, buf->buf + buf->rpos,
	    buf->size - buf->rpos)) == -1) {
d176 13
a188 5
	if (buf->rpos + n < buf->size) {	/* not all data written yet */
		buf->rpos += n;
		return (0);
	} else
		return (1);
@


1.40
log
@Unify code between the various flavors of imsg buffer.c.
Use unsigned int for msg_iovlen.

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.39 2008/03/24 16:11:02 deraadt Exp $ */
d31 1
d46 1
a46 1
	buf->size = len;
d53 1
a53 1
buf_grow(struct buf *buf, size_t len)
d55 4
a58 1
	void	*p;
d60 1
a60 4
	if ((p = realloc(buf->buf, buf->size + len)) == NULL) {
		free(buf->buf);
		buf->buf = NULL;
		buf->size = 0;
d62 16
d80 5
a84 2
	buf->buf = p;
	buf->size += len;
d86 1
a86 1
	return (buf);
d93 2
a94 1
		return (-1);
d107 2
a108 1
		return (NULL);
d115 22
d140 2
@


1.39
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.38 2008/03/15 16:19:00 deraadt Exp $ */
d155 1
a155 1
	int		 i = 0;
d160 2
a161 2
		struct cmsghdr hdr;
		char	buf[CMSG_SPACE(sizeof(int))];
@


1.38
log
@Repair the simple cases for msg_controllen where it should just be
CMSG_SIZE(sizeof(int)), not sizeof(buffer) which may be larger because
of alignment; ok kettenis hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.37 2008/03/13 01:49:53 deraadt Exp $ */
d181 1
a181 1
		msg.msg_controllen = CMSG_LEN(sizeof(int));
d183 1
a183 1
		cmsg->cmsg_len = msg.msg_controllen;
@


1.37
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.36 2006/09/19 13:04:01 henning Exp $ */
d181 1
a181 1
		msg.msg_controllen = sizeof(cmsgbuf.buf);
d183 1
a183 1
		cmsg->cmsg_len = CMSG_LEN(sizeof(int));
@


1.36
log
@make buffer_grow always return a valid struct buf; the contained buffer
might be NULL on realloc failure tho. all users check buffer size before
using the buffer, so this is not a problem.
makes error handling much easier. ease the capabilities code big time.
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.35 2006/08/27 13:40:21 henning Exp $ */
d159 4
a162 1
	char		 cmsgbuf[CMSG_SPACE(sizeof(int))];
d180 2
a181 2
		msg.msg_control = (caddr_t)cmsgbuf;
		msg.msg_controllen = CMSG_LEN(sizeof(int));
@


1.35
log
@add buf_grow() to grow an existing buffer (realloc), claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.34 2006/04/21 08:51:46 claudio Exp $ */
d58 2
a59 1
		free(buf);
@


1.34
log
@msgbuf_writebound() and msgbuf_bounded() are leftovers from some ancient
mrt dump code. These functions are no longer used since we switched to
filedescriptor passing. From deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.33 2005/11/02 15:34:43 claudio Exp $ */
d47 17
@


1.33
log
@Mark some additional function arguments as const.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.32 2005/08/11 16:24:11 henning Exp $ */
a202 33
}

int
msgbuf_writebound(struct msgbuf *msgbuf)
{
	struct buf	*buf;
	int		 n;

	if (!msgbuf_unbounded(msgbuf))
		return (1);

	buf = TAILQ_FIRST(&msgbuf->bufs);
	if ((n = buf_write(msgbuf->fd, buf)) < 0)
		return (n);

	if (n == 1) {	/* everything written out */
		buf_dequeue(msgbuf, buf);
		return (1);
	} else
		return (0);
}

int
msgbuf_unbounded(struct msgbuf *msgbuf)
{
	struct buf	*buf;

	/* return 1 if last buffer was not completely written. */
	buf = TAILQ_FIRST(&msgbuf->bufs);
	if (buf != NULL && buf->rpos != 0)
		return (1);
	else
		return (0);
@


1.32
log
@two missing EINTR here too
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.31 2005/04/26 15:18:22 henning Exp $ */
d52 1
a52 1
buf_add(struct buf *buf, void *data, size_t len)
@


1.31
log
@unify shared code a bit again to make future syncs easier
From: Alexander von Gernler <grunk@@pestilenz.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.30 2005/03/28 14:40:04 henning Exp $ */
d89 2
a90 1
		if (errno == EAGAIN || errno == ENOBUFS)	/* try later */
d169 2
a170 1
		if (errno == EAGAIN || errno == ENOBUFS)	/* try later */
@


1.30
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.29 2005/03/23 11:36:35 henning Exp $ */
d22 2
a25 3
#include <err.h>
#include <errno.h>
#include <limits.h>
@


1.29
log
@remove now osolete comment, from a mail exchange with
Alexander von Gernler <grunk@@pestilenz.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.28 2005/03/17 21:51:26 claudio Exp $ */
d188 1
a188 1
	
@


1.28
log
@Fix fd passing. Bug introduced lately passed the first fd twice and an old
bug passed a fd twice if only part of the buffers where written by sendmsg().
Lot of discussion and help deraadt@@, additional testing norby@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.27 2005/03/14 11:59:13 henning Exp $ */
a134 6
	/*
	 * possible race here
	 * when we cannot write out data completely from a buffer,
	 * we MUST return and NOT try to write out stuff from later buffers -
	 * the socket might have become writeable again
	 */
a206 6
	/*
	 * possible race here
	 * when we cannot write out data completely from a buffer,
	 * we MUST return and NOT try to write out stuff from later buffers -
	 * the socket might have become writeable again
	 */
@


1.27
log
@when a buffer has a file descriptor to pass attached, we tried to send
out all pending buffers up to and including the one with the fd attached.
the fd is sent with the data and closed after all data is sent.
when this amount of data exceeds what we can get rid of with a single
sendmsg() on our nonblocking sockets we might send the fd more than
once, leaving unused fds around.
when we see a buffer with an fd attached, send out everything up to, but
EXcluding that buffer, so that in the next round a seperate message with
just the one buffer and the associated fd is sent. if anything got
written in that sendmsg() call consider the fd sent and close it. from
a debugging session with theo hunting something else, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.26 2005/02/01 21:36:02 henning Exp $ */
a153 2
		if (i != 0 && buf->fd != -1)	/* fds on their own */
			break;
d186 9
a203 5
			/* assumption: fd got sent if sendmsg sent anything */
			if (buf->fd != -1) {
				close(buf->fd);
				buf->fd = -1;
			}
@


1.26
log
@switch the buffer size describing vars from ssize_t to size_t and adjust
the API appropriately. avoid singled-compare warnings by rewriting two
expressions. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.25 2004/09/16 01:33:53 henning Exp $ */
d154 2
d197 5
@


1.25
log
@cope with ENOBUFS in buf_write()
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.24 2004/09/14 22:26:09 henning Exp $ */
d36 1
a36 1
buf_open(ssize_t len)
d53 1
a53 1
buf_add(struct buf *buf, void *data, ssize_t len)
d64 1
a64 1
buf_reserve(struct buf *buf, ssize_t len)
d101 1
a101 1
	if (n < buf->size - buf->rpos) {	/* not all data written yet */
d189 1
a189 1
		if (n >= buf->size - buf->rpos) {
@


1.24
log
@treat ENOBUFS like EAGAIN and try later
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.23 2004/08/17 15:59:34 henning Exp $ */
d90 1
a90 1
		if (errno == EAGAIN)	/* cannot write immediately */
@


1.23
log
@when sending a file descriptor, close it on the receiving side in
buf_dequeue() instead of in msgbuf_write(). as sendmsg() might return
without having written all data (we're on nonblocking sockets), we
might have closed the fd before it actually got send.
tracked down after (completely independent, didn't even look related at all)
bug reports from Shaun O'Neil <shaun@@dma.nl> and
Arvid Grtting <arvidg@@netfonds.no>, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.22 2004/07/03 17:19:59 claudio Exp $ */
d175 1
a175 1
		if (errno == EAGAIN)	/* cannot write immediately */
@


1.22
log
@Switch mrt dumping to fd passing. This gives some speed up when extensive
dumping is done. Acctually mrt dumps were broken because of the fd passing.
The nice side effect is a much cleaner code, especially in the parent process.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.21 2004/06/20 18:35:12 henning Exp $ */
a185 3
	if (buf != NULL && buf->fd != -1)
		close(buf->fd);

d251 4
@


1.21
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.20 2004/06/20 18:03:26 henning Exp $ */
a31 1
int	buf_write(int, struct buf *);
@


1.20
log
@argh, don't want to shutdown the socket in the parent after sending,
just plain close
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.19 2004/06/20 17:49:46 henning Exp $ */
d152 1
a152 1
	TAILQ_FOREACH(buf, &msgbuf->bufs, entries) {
d192 1
a192 1
		next = TAILQ_NEXT(buf, entries);
d247 1
a247 1
	TAILQ_INSERT_TAIL(&msgbuf->bufs, buf, entries);
d254 1
a254 1
	TAILQ_REMOVE(&msgbuf->bufs, buf, entries);
@


1.19
log
@implement file descriptor passing in the imsg/msgbuf framework, and use
it to let the main process to prepare new listening sockets (socket() and
bind()) on behalf of the session engine, which of course cannot bind() to
ports < 1024 any more once it dropped privileges. with some help from theo,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.18 2004/04/29 19:56:04 deraadt Exp $ */
d187 1
a187 2
	if (buf != NULL && buf->fd != -1) {
		shutdown(buf->fd, SHUT_RDWR);
a188 1
	}
@


1.18
log
@sock -> fd; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.17 2004/02/19 13:54:58 claudio Exp $ */
d48 1
d146 3
d151 1
d158 15
d175 1
a175 1
	if ((n = writev(msgbuf->fd, iov, i)) == -1) {
d185 5
@


1.17
log
@Make the code more portable. Add some missing header files and make the use
of the queue(3) makros more portable. OK henning@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.16 2004/02/17 22:41:40 henning Exp $ */
d119 1
a119 1
	msgbuf->sock = -1;
d155 1
a155 1
	if ((n = writev(msgbuf->sock, iov, i)) == -1) {
d198 1
a198 1
	if ((n = buf_write(msgbuf->sock, buf)) < 0)
@


1.16
log
@little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.15 2004/02/17 16:25:16 henning Exp $ */
d26 1
@


1.15
log
@missing bzero() of the iovec
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.14 2004/01/10 23:25:44 henning Exp $ */
d125 1
a125 1
	struct buf	*buf, *next;
d127 1
a127 2
	for (buf = TAILQ_FIRST(&msgbuf->bufs); buf != NULL; buf = next) {
		next = TAILQ_NEXT(buf, entries);
a128 3
	}
	msgbuf->queued = 0;
	msgbuf->sock = -1;
@


1.14
log
@use writev(2) to get as many messages out at once as possible.
should gives us a little exra performance gain

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.13 2004/01/10 21:02:54 henning Exp $ */
d149 1
@


1.13
log
@we may only write after a POLLOUT, and then, we only may write once.
if we don't play by these rules the next write may block.
make us adhere.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.12 2004/01/06 03:43:50 henning Exp $ */
d20 1
d144 19
a162 2
	struct buf	*buf;
	int		 n;
d164 4
a167 3
	buf = TAILQ_FIRST(&msgbuf->bufs);
	if ((n = buf_write(msgbuf->sock, buf)) < 0)
		return (n);
d169 11
a179 2
	if (n == 1)	/* everything written out */
		buf_dequeue(msgbuf, buf);
@


1.12
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.11 2004/01/05 22:57:59 claudio Exp $ */
a76 14
	int	n;

	/* first try to write out directly */
	if (msgbuf->queued == 0) {
		if ((n = buf_write(msgbuf->sock, buf)) < 0)
			return (n);

		if (n == 1) {		/* all data written out */
			buf_free(buf);
			return (0);
		}
	}

	/* we have to queue */
d143 1
a143 1
	struct buf	*buf, *next;
d146 6
a151 4
	for (buf = TAILQ_FIRST(&msgbuf->bufs); buf != NULL; buf = next) {
		next = TAILQ_NEXT(buf, entries);
		if ((n = buf_write(msgbuf->sock, buf)) < 0)
			return (n);
a152 5
		if (n == 1)	/* everything written out */
			buf_dequeue(msgbuf, buf);
		else
			return (0);
	}
@


1.11
log
@Big overhaul of the mrt code.
Dumping of incomming bgp messages is now possible and dumping the (not yet)
filtered updates works too. Per neighbor dumps are still missing.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.10 2003/12/26 17:13:52 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.10
log
@need to clean errno before returning error in the custom case
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.9 2003/12/24 13:28:01 henning Exp $ */
d101 1
a101 1
	    buf->size-buf->rpos)) == -1) {
d171 39
@


1.9
log
@handle write() returning 0 correctly, adjust the msgbuf API appropriately,
and make all callers cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.8 2003/12/23 19:14:49 deraadt Exp $ */
d108 2
a109 1
	if (n == 0)			/* connection closed */
d111 1
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.7 2003/12/21 23:48:46 henning Exp $ */
d81 2
a82 2
		if ((n = buf_write(msgbuf->sock, buf)) == -1)
			return (-1);
d104 1
a104 4
		else {
			/* XXX better let caller log with info which sock etc */
			logit(LOG_CRIT, "buf_write: write error: %s",
			    strerror(errno));
a105 1
		}
d108 3
d160 3
a162 2
		if ((n = buf_write(msgbuf->sock, buf)) == -1)
			return (-1);
@


1.7
log
@sync comments with reality and shorten a bit where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.6 2003/12/21 22:16:53 henning Exp $ */
d79 1
a79 1
	/*  first try to write out directly */
@


1.6
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.5 2003/12/21 18:04:08 claudio Exp $ */
a44 1

a76 5
	/*
	 * we first try to write out directly
	 * if that fails we add the buffer to the queue
	 */

d79 1
a173 1
	/* might want a tailq per peer w/ pointers to the bufs */
@


1.5
log
@don't try to write out data immediately if there are queued writes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.4 2003/12/21 16:11:33 claudio Exp $ */
d30 3
a32 4
TAILQ_HEAD(bufs, buf) bufs = TAILQ_HEAD_INITIALIZER(bufs);

void	buf_enqueue(struct buf *);
void	buf_dequeue(struct buf *);
d35 1
a35 1
buf_open(struct peer *peer, int sock, ssize_t len)
a46 2
	buf->peer = peer;
	buf->sock = sock;
d76 1
a76 1
buf_close(struct buf *buf)
d85 2
a86 2
	if (buf->peer != NULL && buf->peer->queued_writes == 0) {
		if ((n = buf_write(buf)) == -1)
d96 1
a96 1
	buf_enqueue(buf);
d101 1
a101 1
buf_write(struct buf *buf)
d105 1
a105 1
	if ((n = write(buf->sock, buf->buf + buf->rpos,
d110 3
a112 5
			if (buf->peer != NULL)
				log_err(buf->peer, "write error");
			else
				logit(LOG_CRIT, "pipe write error: %s",
				    strerror(errno));
d132 1
a132 1
buf_peer_remove(struct peer *peer)
d134 3
a136 7
	struct buf	*buf, *next;

	for (buf = TAILQ_FIRST(&bufs); buf != NULL; buf = next) {
		next = TAILQ_NEXT(buf, entries);
		if (buf->peer == peer)
			buf_dequeue(buf);
	}
d139 2
a140 2
int
buf_peer_write(struct peer *peer)
a141 6
	/*
	 * possible race here
	 * when we cannot write out data completely from a buffer,
	 * we MUST return and NOT try to write out stuff from later buffers -
	 * the socket might have become writeable again
	 */
a142 1
	int		 n;
d144 1
a144 1
	for (buf = TAILQ_FIRST(&bufs); buf != NULL; buf = next) {
d146 1
a146 8
		if (buf->peer == peer) {
			if ((n = buf_write(buf)) == -1)
				return (-1);
			if (n == 1)	/* everything written out */
				buf_dequeue(buf);
			else
				return (0);
		}
d148 2
a149 1
	return (0);
d153 1
a153 1
buf_sock_write(int sock)
d162 1
a162 1
	int		 n, cleared = 0;
d164 1
a164 1
	for (buf = TAILQ_FIRST(&bufs); buf != NULL; buf = next) {
d166 6
a171 9
		if (buf->sock == sock) {
			if ((n = buf_write(buf)) == -1)
				return (-1);
			if (n == 1) {	/* everything written out */
				buf_dequeue(buf);
				cleared++;
			} else
				return (cleared);
		}
d173 1
a173 1
	return (cleared);
d177 1
a177 1
buf_enqueue(struct buf *buf)
d180 2
a181 3
	TAILQ_INSERT_TAIL(&bufs, buf, entries);
	if (buf->peer != NULL)
		buf->peer->queued_writes++;
d185 1
a185 1
buf_dequeue(struct buf *buf)
d187 2
a188 3
	TAILQ_REMOVE(&bufs, buf, entries);
	if (buf->peer != NULL)
		buf->peer->queued_writes--;
@


1.4
log
@yet more from the castathon; most aspath functions where accessing non-
aligned memory (u_int16_t) therefor crashed the RDE on my sparc64. All
buffer specific functions use now void * instead of u_char * so most cast
are now history. Tested on sparc64 and i386. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.3 2003/12/20 21:14:55 henning Exp $ */
d88 8
a95 6
	if ((n = buf_write(buf)) == -1)
		return (-1);

	if (n == 1) {		/* all data written out */
		buf_free(buf);
		return (0);
@


1.3
log
@let buf_add take void *data instead of u_char *data and save a zillion
evil casts
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.2 2003/12/20 14:33:09 henning Exp $ */
d65 1
a65 1
u_char *
d68 1
a68 1
	u_char	*b;
@


1.2
log
@read(2)/write(2) return ssize_t, not size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: buffer.c,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d55 1
a55 1
buf_add(struct buf *buf, u_char *data, ssize_t len)
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d36 1
a36 1
buf_open(struct peer *peer, int sock, size_t len)
d55 1
a55 1
buf_add(struct buf *buf, u_char *data, size_t len)
d66 1
a66 1
buf_reserve(struct buf *buf, size_t len)
d104 1
a104 1
	size_t	n;
@

