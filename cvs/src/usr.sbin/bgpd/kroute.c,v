head	1.212;
access;
symbols
	OPENBSD_6_0:1.209.0.4
	OPENBSD_6_0_BASE:1.209
	OPENBSD_5_9:1.207.0.2
	OPENBSD_5_9_BASE:1.207
	OPENBSD_5_8:1.204.0.4
	OPENBSD_5_8_BASE:1.204
	OPENBSD_5_7:1.202.0.2
	OPENBSD_5_7_BASE:1.202
	OPENBSD_5_6:1.198.0.4
	OPENBSD_5_6_BASE:1.198
	OPENBSD_5_5:1.197.0.4
	OPENBSD_5_5_BASE:1.197
	OPENBSD_5_4:1.195.0.2
	OPENBSD_5_4_BASE:1.195
	OPENBSD_5_3:1.191.0.2
	OPENBSD_5_3_BASE:1.191
	OPENBSD_5_2:1.190.0.2
	OPENBSD_5_2_BASE:1.190
	OPENBSD_5_1_BASE:1.188
	OPENBSD_5_1:1.188.0.4
	OPENBSD_5_0:1.188.0.2
	OPENBSD_5_0_BASE:1.188
	OPENBSD_4_9:1.186.0.2
	OPENBSD_4_9_BASE:1.186
	OPENBSD_4_8:1.183.0.2
	OPENBSD_4_8_BASE:1.183
	OPENBSD_4_7:1.175.0.2
	OPENBSD_4_7_BASE:1.175
	OPENBSD_4_6:1.169.0.4
	OPENBSD_4_6_BASE:1.169
	OPENBSD_4_5:1.165.0.2
	OPENBSD_4_5_BASE:1.165
	OPENBSD_4_4:1.160.0.2
	OPENBSD_4_4_BASE:1.160
	OPENBSD_4_3:1.157.0.2
	OPENBSD_4_3_BASE:1.157
	OPENBSD_4_2:1.154.0.2
	OPENBSD_4_2_BASE:1.154
	OPENBSD_4_1:1.152.0.2
	OPENBSD_4_1_BASE:1.152
	OPENBSD_4_0:1.147.0.2
	OPENBSD_4_0_BASE:1.147
	OPENBSD_3_9:1.144.0.2
	OPENBSD_3_9_BASE:1.144
	OPENBSD_3_8:1.140.0.2
	OPENBSD_3_8_BASE:1.140
	OPENBSD_3_7:1.117.0.2
	OPENBSD_3_7_BASE:1.117
	OPENBSD_3_6:1.107.0.2
	OPENBSD_3_6_BASE:1.107
	OPENBSD_3_5:1.92.0.2
	OPENBSD_3_5_BASE:1.92;
locks; strict;
comment	@ * @;


1.212
date	2017.03.28.05.04.09;	author claudio;	state Exp;
branches;
next	1.211;
commitid	MPIv0TvEevQ1JKY6;

1.211
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.210;
commitid	airB1W2Kb948lFil;

1.210
date	2016.10.05.07.38.06;	author phessler;	state Exp;
branches;
next	1.209;
commitid	XF7pIhaJDJdwfpZW;

1.209
date	2016.04.08.12.27.05;	author phessler;	state Exp;
branches;
next	1.208;
commitid	pE5vBjlxcErGqx1f;

1.208
date	2016.03.22.15.53.00;	author claudio;	state Exp;
branches;
next	1.207;
commitid	MbpadVZNgcOQRaNN;

1.207
date	2015.12.05.18.28.04;	author benno;	state Exp;
branches
	1.207.2.1;
next	1.206;
commitid	yK6UHgEp0AEIXbTZ;

1.206
date	2015.10.22.11.13.16;	author phessler;	state Exp;
branches;
next	1.205;
commitid	DA1z8ZuITvdk2ZiE;

1.205
date	2015.09.16.20.25.41;	author stsp;	state Exp;
branches;
next	1.204;
commitid	DdIYNjrFkyhcmdeI;

1.204
date	2015.07.17.20.03.54;	author claudio;	state Exp;
branches
	1.204.4.1;
next	1.203;
commitid	b6cgFtgJdvfHQry6;

1.203
date	2015.07.08.08.03.46;	author mpi;	state Exp;
branches;
next	1.202;
commitid	hrVctS3hfj5hCjaL;

1.202
date	2015.02.11.05.48.53;	author claudio;	state Exp;
branches;
next	1.201;
commitid	C1MEItJa3LcoKqiy;

1.201
date	2015.02.10.05.18.39;	author claudio;	state Exp;
branches;
next	1.200;
commitid	onDCg4G9cRuERxug;

1.200
date	2015.02.09.11.37.31;	author claudio;	state Exp;
branches;
next	1.199;
commitid	IcuyF0sCmFRE7OTK;

1.199
date	2014.10.08.16.15.37;	author deraadt;	state Exp;
branches;
next	1.198;
commitid	8hXaK4f2GeAALziF;

1.198
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.197;
commitid	uXnRK9VvnFZsAqfW;

1.197
date	2014.01.23.23.26.56;	author benno;	state Exp;
branches;
next	1.196;

1.196
date	2013.11.13.09.14.48;	author florian;	state Exp;
branches;
next	1.195;

1.195
date	2013.05.22.21.00.36;	author sthen;	state Exp;
branches;
next	1.194;

1.194
date	2013.05.22.20.39.12;	author sthen;	state Exp;
branches;
next	1.193;

1.193
date	2013.03.20.04.01.42;	author deraadt;	state Exp;
branches;
next	1.192;

1.192
date	2013.03.14.14.53.52;	author florian;	state Exp;
branches;
next	1.191;

1.191
date	2012.11.13.22.07.28;	author florian;	state Exp;
branches;
next	1.190;

1.190
date	2012.07.13.16.57.35;	author claudio;	state Exp;
branches;
next	1.189;

1.189
date	2012.05.27.18.52.07;	author claudio;	state Exp;
branches;
next	1.188;

1.188
date	2011.05.01.12.56.04;	author claudio;	state Exp;
branches;
next	1.187;

1.187
date	2011.03.07.07.43.02;	author henning;	state Exp;
branches;
next	1.186;

1.186
date	2010.10.11.11.45.57;	author claudio;	state Exp;
branches;
next	1.185;

1.185
date	2010.09.30.08.57.37;	author claudio;	state Exp;
branches;
next	1.184;

1.184
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.183;

1.183
date	2010.07.12.14.35.13;	author bluhm;	state Exp;
branches;
next	1.182;

1.182
date	2010.06.03.21.19.06;	author claudio;	state Exp;
branches;
next	1.181;

1.181
date	2010.05.19.13.15.08;	author claudio;	state Exp;
branches;
next	1.180;

1.180
date	2010.05.18.12.21.33;	author claudio;	state Exp;
branches;
next	1.179;

1.179
date	2010.05.17.15.49.29;	author claudio;	state Exp;
branches;
next	1.178;

1.178
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.177;

1.177
date	2010.04.13.09.09.48;	author claudio;	state Exp;
branches;
next	1.176;

1.176
date	2010.04.06.13.25.08;	author claudio;	state Exp;
branches;
next	1.175;

1.175
date	2010.02.26.15.50.20;	author claudio;	state Exp;
branches;
next	1.174;

1.174
date	2010.02.23.16.06.04;	author claudio;	state Exp;
branches;
next	1.173;

1.173
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.172;

1.172
date	2009.07.23.14.53.20;	author claudio;	state Exp;
branches;
next	1.171;

1.171
date	2009.07.23.10.20.44;	author claudio;	state Exp;
branches;
next	1.170;

1.170
date	2009.07.20.15.03.16;	author claudio;	state Exp;
branches;
next	1.169;

1.169
date	2009.06.25.15.54.22;	author claudio;	state Exp;
branches;
next	1.168;

1.168
date	2009.06.12.16.42.53;	author claudio;	state Exp;
branches;
next	1.167;

1.167
date	2009.06.05.22.40.24;	author chris;	state Exp;
branches;
next	1.166;

1.166
date	2009.05.25.11.49.47;	author claudio;	state Exp;
branches;
next	1.165;

1.165
date	2009.02.11.20.07.04;	author claudio;	state Exp;
branches;
next	1.164;

1.164
date	2009.02.09.08.20.11;	author claudio;	state Exp;
branches;
next	1.163;

1.163
date	2009.01.01.15.32.35;	author claudio;	state Exp;
branches;
next	1.162;

1.162
date	2008.12.12.23.15.12;	author claudio;	state Exp;
branches;
next	1.161;

1.161
date	2008.11.21.17.41.22;	author claudio;	state Exp;
branches;
next	1.160;

1.160
date	2008.05.09.12.45.25;	author henning;	state Exp;
branches;
next	1.159;

1.159
date	2008.05.08.13.07.22;	author henning;	state Exp;
branches;
next	1.158;

1.158
date	2008.05.08.07.40.03;	author henning;	state Exp;
branches;
next	1.157;

1.157
date	2007.11.24.17.01.04;	author claudio;	state Exp;
branches;
next	1.156;

1.156
date	2007.11.24.12.59.28;	author jmc;	state Exp;
branches;
next	1.155;

1.155
date	2007.10.04.11.43.19;	author henning;	state Exp;
branches;
next	1.154;

1.154
date	2007.05.11.11.27.59;	author claudio;	state Exp;
branches;
next	1.153;

1.153
date	2007.04.19.13.05.48;	author claudio;	state Exp;
branches;
next	1.152;

1.152
date	2007.02.22.08.34.18;	author henning;	state Exp;
branches;
next	1.151;

1.151
date	2007.02.07.13.22.55;	author claudio;	state Exp;
branches;
next	1.150;

1.150
date	2006.11.28.16.39.34;	author henning;	state Exp;
branches;
next	1.149;

1.149
date	2006.11.28.16.36.58;	author henning;	state Exp;
branches;
next	1.148;

1.148
date	2006.11.16.15.54.49;	author henning;	state Exp;
branches;
next	1.147;

1.147
date	2006.08.03.22.40.25;	author claudio;	state Exp;
branches;
next	1.146;

1.146
date	2006.04.12.14.23.46;	author henning;	state Exp;
branches;
next	1.145;

1.145
date	2006.03.22.13.30.35;	author claudio;	state Exp;
branches;
next	1.144;

1.144
date	2006.02.23.15.25.18;	author claudio;	state Exp;
branches
	1.144.2.1;
next	1.143;

1.143
date	2006.01.31.15.22.15;	author claudio;	state Exp;
branches;
next	1.142;

1.142
date	2005.12.14.00.44.39;	author claudio;	state Exp;
branches;
next	1.141;

1.141
date	2005.09.21.12.50.20;	author henning;	state Exp;
branches;
next	1.140;

1.140
date	2005.07.01.22.00.04;	author claudio;	state Exp;
branches;
next	1.139;

1.139
date	2005.06.24.14.01.53;	author claudio;	state Exp;
branches;
next	1.138;

1.138
date	2005.06.14.15.01.51;	author claudio;	state Exp;
branches;
next	1.137;

1.137
date	2005.06.13.21.16.18;	author henning;	state Exp;
branches;
next	1.136;

1.136
date	2005.06.07.18.56.51;	author claudio;	state Exp;
branches;
next	1.135;

1.135
date	2005.06.07.18.43.31;	author claudio;	state Exp;
branches;
next	1.134;

1.134
date	2005.06.06.17.15.07;	author henning;	state Exp;
branches;
next	1.133;

1.133
date	2005.06.05.23.59.28;	author henning;	state Exp;
branches;
next	1.132;

1.132
date	2005.06.05.23.57.33;	author henning;	state Exp;
branches;
next	1.131;

1.131
date	2005.06.02.15.06.08;	author cloder;	state Exp;
branches;
next	1.130;

1.130
date	2005.05.27.20.01.21;	author henning;	state Exp;
branches;
next	1.129;

1.129
date	2005.05.27.20.00.35;	author henning;	state Exp;
branches;
next	1.128;

1.128
date	2005.05.27.17.59.50;	author henning;	state Exp;
branches;
next	1.127;

1.127
date	2005.05.27.17.52.11;	author claudio;	state Exp;
branches;
next	1.126;

1.126
date	2005.05.13.08.34.33;	author claudio;	state Exp;
branches;
next	1.125;

1.125
date	2005.04.28.13.54.45;	author claudio;	state Exp;
branches;
next	1.124;

1.124
date	2005.04.28.13.49.12;	author claudio;	state Exp;
branches;
next	1.123;

1.123
date	2005.04.18.11.07.55;	author claudio;	state Exp;
branches;
next	1.122;

1.122
date	2005.04.08.00.07.18;	author henning;	state Exp;
branches;
next	1.121;

1.121
date	2005.03.30.11.13.05;	author henning;	state Exp;
branches;
next	1.120;

1.120
date	2005.03.29.11.20.01;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2005.03.28.14.40.04;	author henning;	state Exp;
branches;
next	1.118;

1.118
date	2005.03.26.23.04.34;	author claudio;	state Exp;
branches;
next	1.117;

1.117
date	2005.03.15.10.18.39;	author henning;	state Exp;
branches;
next	1.116;

1.116
date	2005.03.14.12.25.50;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2005.03.14.08.44.33;	author henning;	state Exp;
branches;
next	1.114;

1.114
date	2005.03.13.15.52.34;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2005.03.13.15.34.37;	author henning;	state Exp;
branches;
next	1.112;

1.112
date	2004.11.24.22.57.18;	author henning;	state Exp;
branches;
next	1.111;

1.111
date	2004.11.10.14.48.25;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2004.10.19.12.02.50;	author henning;	state Exp;
branches;
next	1.109;

1.109
date	2004.10.16.12.24.23;	author henning;	state Exp;
branches;
next	1.108;

1.108
date	2004.10.16.09.33.03;	author henning;	state Exp;
branches;
next	1.107;

1.107
date	2004.08.19.10.38.34;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2004.08.05.15.58.21;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2004.08.03.13.34.06;	author claudio;	state Exp;
branches;
next	1.104;

1.104
date	2004.07.13.17.57.20;	author jaredy;	state Exp;
branches;
next	1.103;

1.103
date	2004.07.05.16.54.53;	author henning;	state Exp;
branches;
next	1.102;

1.102
date	2004.07.05.02.13.44;	author henning;	state Exp;
branches;
next	1.101;

1.101
date	2004.06.29.20.13.07;	author henning;	state Exp;
branches;
next	1.100;

1.100
date	2004.06.25.20.08.46;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2004.06.25.18.48.18;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2004.06.22.20.28.58;	author claudio;	state Exp;
branches;
next	1.97;

1.97
date	2004.06.22.07.22.31;	author henning;	state Exp;
branches;
next	1.96;

1.96
date	2004.06.20.19.16.53;	author henning;	state Exp;
branches;
next	1.95;

1.95
date	2004.05.08.06.04.57;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2004.04.28.01.13.18;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2004.04.27.04.38.12;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2004.03.10.13.00.42;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2004.03.10.12.59.13;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2004.03.10.12.55.35;	author henning;	state Exp;
branches;
next	1.89;

1.89
date	2004.03.04.11.26.36;	author henning;	state Exp;
branches;
next	1.88;

1.88
date	2004.03.03.17.08.45;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2004.02.29.11.14.19;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2004.02.07.01.50.28;	author henning;	state Exp;
branches;
next	1.85;

1.85
date	2004.02.07.01.41.52;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2004.02.07.01.28.13;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2004.02.07.00.16.14;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2004.01.30.15.44.46;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2004.01.28.01.56.26;	author henning;	state Exp;
branches;
next	1.80;

1.80
date	2004.01.27.22.15.13;	author henning;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.27.21.56.21;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2004.01.23.21.18.12;	author henning;	state Exp;
branches;
next	1.77;

1.77
date	2004.01.22.20.34.56;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2004.01.22.03.18.04;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2004.01.22.03.07.51;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.18.19.15.00;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2004.01.17.21.06.55;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2004.01.17.18.27.19;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.17.18.05.46;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.17.15.35.09;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.17.15.00.29;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.14.12.33.30;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.11.22.08.04;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.11.22.01.13;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.11.19.53.48;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.11.19.42.27;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.11.19.14.43;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.11.02.35.14;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.09.19.08.50;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.09.14.10.06;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.09.13.47.07;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.09.01.23.12;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.08.17.06.50;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.08.16.55.25;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.08.16.52.05;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.08.16.34.39;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.08.16.17.12;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.08.16.07.15;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2004.01.08.11.40.03;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.08.11.39.41;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.07.13.32.53;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.07.12.38.51;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2004.01.05.16.17.22;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.02.01.46.20;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.30.13.03.27;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.28.14.43.18;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.27.18.43.36;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.27.18.41.40;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.27.14.24.42;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.27.01.30.00;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.27.00.53.51;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.27.00.17.26;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.26.23.46.51;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.26.23.22.27;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.26.19.19.25;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.26.17.47.04;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.26.17.35.48;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.26.16.54.10;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.26.16.48.07;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.26.15.42.14;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.26.15.27.31;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.26.00.49.52;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.26.00.27.23;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.26.00.23.48;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.26.00.14.04;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.26.00.12.23;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.25.23.21.36;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.25.23.15.58;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.25.19.24.46;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.25.17.07.24;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.25.16.21.50;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.25.02.51.52;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.25.02.50.01;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.25.02.49.05;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.25.02.09.19;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.25.02.04.46;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.25.01.59.34;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.25.01.49.53;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.25.01.48.07;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.25.01.45.57;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.24.21.14.22;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.24.19.59.24;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.24.19.23.26;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.23.17.38.49;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.23.16.17.15;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.23.16.07.37;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.23.15.50.12;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.22.15.22.13;	author henning;	state Exp;
branches;
next	;

1.144.2.1
date	2006.05.05.03.04.07;	author brad;	state Exp;
branches;
next	;

1.204.4.1
date	2016.03.23.13.43.08;	author phessler;	state Exp;
branches;
next	1.204.4.2;
commitid	SqUaSIEmUrYbTtv5;

1.204.4.2
date	2016.04.12.09.01.05;	author phessler;	state Exp;
branches;
next	;
commitid	93pgipVshReNVtge;

1.207.2.1
date	2016.03.23.13.41.37;	author phessler;	state Exp;
branches;
next	1.207.2.2;
commitid	ODBEv0w1lG7kXlhM;

1.207.2.2
date	2016.04.12.08.58.56;	author phessler;	state Exp;
branches;
next	;
commitid	5Q1euYGqHg466ykC;


desc
@@


1.212
log
@For IPv6 pass prefix not nexthop as network for connected nexthops back to
the RDE so that the code actually works.
Problem found and reported by Pier Carlo Chiodi (pierky at pierky com)
OK deraadt@@
@
text
@/*	$OpenBSD: kroute.c,v 1.211 2017/01/24 04:22:42 benno Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/tree.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <netmpls/mpls.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "bgpd.h"
#include "log.h"

struct ktable		**krt;
u_int			  krt_size;

struct {
	u_int32_t		rtseq;
	pid_t			pid;
	int			fd;
} kr_state;

struct kroute_node {
	RB_ENTRY(kroute_node)	 entry;
	struct kroute		 r;
	struct kroute_node	*next;
};

struct kroute6_node {
	RB_ENTRY(kroute6_node)	 entry;
	struct kroute6		 r;
	struct kroute6_node	*next;
};

struct knexthop_node {
	RB_ENTRY(knexthop_node)	 entry;
	struct bgpd_addr	 nexthop;
	void			*kroute;
};

struct kif_kr {
	LIST_ENTRY(kif_kr)	 entry;
	struct kroute_node	*kr;
};

struct kif_kr6 {
	LIST_ENTRY(kif_kr6)	 entry;
	struct kroute6_node	*kr;
};

LIST_HEAD(kif_kr_head, kif_kr);
LIST_HEAD(kif_kr6_head, kif_kr6);

struct kif_node {
	RB_ENTRY(kif_node)	 entry;
	struct kif		 k;
	struct kif_kr_head	 kroute_l;
	struct kif_kr6_head	 kroute6_l;
};

int	ktable_new(u_int, u_int, char *, char *, int, u_int8_t);
void	ktable_free(u_int, u_int8_t);
void	ktable_destroy(struct ktable *, u_int8_t);
struct ktable	*ktable_get(u_int);

int	kr4_change(struct ktable *, struct kroute_full *, u_int8_t);
int	kr6_change(struct ktable *, struct kroute_full *, u_int8_t);
int	krVPN4_change(struct ktable *, struct kroute_full *, u_int8_t);
int	kr4_delete(struct ktable *, struct kroute_full *, u_int8_t);
int	kr6_delete(struct ktable *, struct kroute_full *, u_int8_t);
int	krVPN4_delete(struct ktable *, struct kroute_full *, u_int8_t);
void	kr_net_delete(struct network *);
struct network *kr_net_match(struct ktable *, struct kroute *);
struct network *kr_net_match6(struct ktable *, struct kroute6 *);
struct network *kr_net_find(struct ktable *, struct network *);
int	kr_redistribute(int, struct ktable *, struct kroute *);
int	kr_redistribute6(int, struct ktable *, struct kroute6 *);
struct kroute_full *kr_tofull(struct kroute *);
struct kroute_full *kr6_tofull(struct kroute6 *);
int	kroute_compare(struct kroute_node *, struct kroute_node *);
int	kroute6_compare(struct kroute6_node *, struct kroute6_node *);
int	knexthop_compare(struct knexthop_node *, struct knexthop_node *);
int	kif_compare(struct kif_node *, struct kif_node *);
void	kr_fib_update_prio(u_int, u_int8_t);

struct kroute_node	*kroute_find(struct ktable *, in_addr_t, u_int8_t,
			    u_int8_t);
struct kroute_node	*kroute_matchgw(struct kroute_node *,
			    struct sockaddr_in *);
int			 kroute_insert(struct ktable *, struct kroute_node *);
int			 kroute_remove(struct ktable *, struct kroute_node *);
void			 kroute_clear(struct ktable *);

struct kroute6_node	*kroute6_find(struct ktable *, const struct in6_addr *,
			    u_int8_t, u_int8_t);
struct kroute6_node	*kroute6_matchgw(struct kroute6_node *,
			    struct sockaddr_in6 *);
int			 kroute6_insert(struct ktable *, struct kroute6_node *);
int			 kroute6_remove(struct ktable *, struct kroute6_node *);
void			 kroute6_clear(struct ktable *);

struct knexthop_node	*knexthop_find(struct ktable *, struct bgpd_addr *);
int			 knexthop_insert(struct ktable *,
			    struct knexthop_node *);
int			 knexthop_remove(struct ktable *,
			    struct knexthop_node *);
void			 knexthop_clear(struct ktable *);

struct kif_node		*kif_find(int);
int			 kif_insert(struct kif_node *);
int			 kif_remove(struct kif_node *);
void			 kif_clear(void);

int			 kif_kr_insert(struct kroute_node *);
int			 kif_kr_remove(struct kroute_node *);

int			 kif_kr6_insert(struct kroute6_node *);
int			 kif_kr6_remove(struct kroute6_node *);

int			 kif_validate(struct kif *);
int			 kroute_validate(struct kroute *);
int			 kroute6_validate(struct kroute6 *);
void			 knexthop_validate(struct ktable *,
			    struct knexthop_node *);
void			 knexthop_track(struct ktable *, void *);
void			 knexthop_send_update(struct knexthop_node *);
struct kroute_node	*kroute_match(struct ktable *, in_addr_t, int);
struct kroute6_node	*kroute6_match(struct ktable *, struct in6_addr *, int);
void			 kroute_detach_nexthop(struct ktable *,
			    struct knexthop_node *);

int		protect_lo(struct ktable *);
u_int8_t	prefixlen_classful(in_addr_t);
u_int8_t	mask2prefixlen(in_addr_t);
u_int8_t	mask2prefixlen6(struct sockaddr_in6 *);
void		get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
void		if_change(u_short, int, struct if_data *);
void		if_announce(void *);

int		send_rtmsg(int, int, struct ktable *, struct kroute *,
		    u_int8_t);
int		send_rt6msg(int, int, struct ktable *, struct kroute6 *,
		    u_int8_t);
int		dispatch_rtmsg(void);
int		fetchtable(struct ktable *, u_int8_t);
int		fetchifs(int);
int		dispatch_rtmsg_addr(struct rt_msghdr *,
		    struct sockaddr *[RTAX_MAX], struct ktable *);

RB_PROTOTYPE(kroute_tree, kroute_node, entry, kroute_compare)
RB_GENERATE(kroute_tree, kroute_node, entry, kroute_compare)

RB_PROTOTYPE(kroute6_tree, kroute6_node, entry, kroute6_compare)
RB_GENERATE(kroute6_tree, kroute6_node, entry, kroute6_compare)

RB_PROTOTYPE(knexthop_tree, knexthop_node, entry, knexthop_compare)
RB_GENERATE(knexthop_tree, knexthop_node, entry, knexthop_compare)

RB_HEAD(kif_tree, kif_node)		kit;
RB_PROTOTYPE(kif_tree, kif_node, entry, kif_compare)
RB_GENERATE(kif_tree, kif_node, entry, kif_compare)

#define KT2KNT(x)	(&(ktable_get((x)->nhtableid)->knt))

/*
 * exported functions
 */

int
kr_init(void)
{
	int		opt = 0, rcvbuf, default_rcvbuf;
	unsigned int	tid = RTABLE_ANY;
	socklen_t	optlen;

	if ((kr_state.fd = socket(AF_ROUTE,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK, 0)) == -1) {
		log_warn("kr_init: socket");
		return (-1);
	}

	/* not interested in my own messages */
	if (setsockopt(kr_state.fd, SOL_SOCKET, SO_USELOOPBACK,
	    &opt, sizeof(opt)) == -1)
		log_warn("kr_init: setsockopt");	/* not fatal */

	/* grow receive buffer, don't wanna miss messages */
	optlen = sizeof(default_rcvbuf);
	if (getsockopt(kr_state.fd, SOL_SOCKET, SO_RCVBUF,
	    &default_rcvbuf, &optlen) == -1)
		log_warn("kr_init getsockopt SOL_SOCKET SO_RCVBUF");
	else
		for (rcvbuf = MAX_RTSOCK_BUF;
		    rcvbuf > default_rcvbuf &&
		    setsockopt(kr_state.fd, SOL_SOCKET, SO_RCVBUF,
		    &rcvbuf, sizeof(rcvbuf)) == -1 && errno == ENOBUFS;
		    rcvbuf /= 2)
			;	/* nothing */

	if (setsockopt(kr_state.fd, AF_ROUTE, ROUTE_TABLEFILTER, &tid,
	    sizeof(tid)) == -1) {
		log_warn("kr_init: setsockopt AF_ROUTE ROUTE_TABLEFILTER");
		return (-1);
	}

	kr_state.pid = getpid();
	kr_state.rtseq = 1;

	RB_INIT(&kit);

	if (fetchifs(0) == -1)
		return (-1);

	return (kr_state.fd);
}

int
ktable_new(u_int rtableid, u_int rdomid, char *name, char *ifname, int fs,
    u_int8_t fib_prio)
{
	struct ktable	**xkrt;
	struct ktable	 *kt;
	size_t		  oldsize;

	/* resize index table if needed */
	if (rtableid >= krt_size) {
		oldsize = sizeof(struct ktable *) * krt_size;
		if ((xkrt = reallocarray(krt, rtableid + 1,
		    sizeof(struct ktable *))) == NULL) {
			log_warn("ktable_new");
			return (-1);
		}
		krt = xkrt;
		krt_size = rtableid + 1;
		bzero((char *)krt + oldsize,
		    krt_size * sizeof(struct ktable *) - oldsize);
	}

	if (krt[rtableid])
		fatalx("ktable_new: table already exists.");

	/* allocate new element */
	kt = krt[rtableid] = calloc(1, sizeof(struct ktable));
	if (kt == NULL) {
		log_warn("ktable_new");
		return (-1);
	}

	/* initialize structure ... */
	strlcpy(kt->descr, name, sizeof(kt->descr));
	RB_INIT(&kt->krt);
	RB_INIT(&kt->krt6);
	RB_INIT(&kt->knt);
	TAILQ_INIT(&kt->krn);
	kt->fib_conf = kt->fib_sync = fs;
	kt->rtableid = rtableid;
	kt->nhtableid = rdomid;
	/* bump refcount of rdomain table for the nexthop lookups */
	ktable_get(kt->nhtableid)->nhrefcnt++;
	if (ifname) {
		strlcpy(kt->ifmpe, ifname, IFNAMSIZ);
		kt->ifindex = if_nametoindex(ifname);
	}

	/* ... and load it */
	if (fetchtable(kt, fib_prio) == -1)
		return (-1);
	if (protect_lo(kt) == -1)
		return (-1);

	/* everything is up and running */
	kt->state = RECONF_REINIT;
	log_debug("new ktable %s for rtableid %d", name, rtableid);
	return (0);
}

void
ktable_free(u_int rtableid, u_int8_t fib_prio)
{
	struct ktable	*kt, *nkt;

	if ((kt = ktable_get(rtableid)) == NULL)
		return;

	/* decouple from kernel, no new routes will be entered from here */
	kr_fib_decouple(kt->rtableid, fib_prio);

	/* first unhook from the nexthop table */
	nkt = ktable_get(kt->nhtableid);
	nkt->nhrefcnt--;

	/*
	 * Evil little details:
	 *   If kt->nhrefcnt > 0 then kt == nkt and nothing needs to be done.
	 *   If kt != nkt then kt->nhrefcnt must be 0 and kt must be killed.
	 *   If nkt is no longer referenced it must be killed (possible double
	 *   free so check that kt != nkt).
	 */
	if (kt != nkt && nkt->nhrefcnt <= 0)
		ktable_destroy(nkt, fib_prio);
	if (kt->nhrefcnt <= 0)
		ktable_destroy(kt, fib_prio);
}

void
ktable_destroy(struct ktable *kt, u_int8_t fib_prio)
{
	/* decouple just to be sure, does not hurt */
	kr_fib_decouple(kt->rtableid, fib_prio);

	log_debug("freeing ktable %s rtableid %u", kt->descr, kt->rtableid);
	knexthop_clear(kt);
	kroute_clear(kt);
	kroute6_clear(kt);

	krt[kt->rtableid] = NULL;
	free(kt);
}

struct ktable *
ktable_get(u_int rtableid)
{
	if (rtableid >= krt_size)
		return (NULL);
	return (krt[rtableid]);
}

int
ktable_update(u_int rtableid, char *name, char *ifname, int flags, u_int8_t
    fib_prio)
{
	struct ktable	*kt, *rkt;
	u_int		 rdomid;

	if (!ktable_exists(rtableid, &rdomid))
		fatalx("King Bula lost a table");	/* may not happen */

	if (rdomid != rtableid || flags & F_RIB_NOFIB) {
		rkt = ktable_get(rdomid);
		if (rkt == NULL) {
			char buf[32];
			snprintf(buf, sizeof(buf), "rdomain_%d", rdomid);
			if (ktable_new(rdomid, rdomid, buf, NULL, 0, fib_prio))
				return (-1);
		} else {
			/* there is no need for full fib synchronisation if
			 * the table is only used for nexthop lookups.
			 */
			if (rkt->state == RECONF_DELETE) {
				rkt->fib_conf = 0;
				rkt->state = RECONF_KEEP;
			}
		}
	}

	if (flags & (F_RIB_NOEVALUATE | F_RIB_NOFIB))
		/* only rdomain table must exist */
		return (0);

	kt = ktable_get(rtableid);
	if (kt == NULL) {
		if (ktable_new(rtableid, rdomid, name, ifname,
		    !(flags & F_RIB_NOFIBSYNC), fib_prio))
			return (-1);
	} else {
		/* fib sync has higher preference then no sync */
		if (kt->state == RECONF_DELETE) {
			kt->fib_conf = !(flags & F_RIB_NOFIBSYNC);
			kt->state = RECONF_KEEP;
		} else if (!kt->fib_conf)
			kt->fib_conf = !(flags & F_RIB_NOFIBSYNC);

		strlcpy(kt->descr, name, sizeof(kt->descr));
	}
	return (0);
}

void
ktable_preload(void)
{
	struct ktable	*kt;
	u_int		 i;

	for (i = 0; i < krt_size; i++) {
		if ((kt = ktable_get(i)) == NULL)
			continue;
		kt->state = RECONF_DELETE;
	}
}

void
ktable_postload(u_int8_t fib_prio)
{
	struct ktable	*kt;
	u_int		 i;

	for (i = krt_size; i > 0; i--) {
		if ((kt = ktable_get(i - 1)) == NULL)
			continue;
		if (kt->state == RECONF_DELETE)
			ktable_free(i - 1, fib_prio);
		else if (kt->state == RECONF_REINIT)
			kt->fib_sync = kt->fib_conf;
	}
}

int
ktable_exists(u_int rtableid, u_int *rdomid)
{
	size_t			 len;
	struct rt_tableinfo	 info;
	int			 mib[6];

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;
	mib[4] = NET_RT_TABLE;
	mib[5] = rtableid;

	len = sizeof(info);
	if (sysctl(mib, 6, &info, &len, NULL, 0) == -1) {
		if (errno == ENOENT)
			/* table nonexistent */
			return (0);
		log_warn("sysctl");
		/* must return 0 so that the table is considered non-existent */
		return (0);
	}
	if (rdomid)
		*rdomid = info.rti_domainid;
	return (1);
}

int
kr_change(u_int rtableid, struct kroute_full *kl, u_int8_t fib_prio)
{
	struct ktable		*kt;

	if ((kt = ktable_get(rtableid)) == NULL)
		/* too noisy during reloads, just ignore */
		return (0);
	switch (kl->prefix.aid) {
	case AID_INET:
		return (kr4_change(kt, kl, fib_prio));
	case AID_INET6:
		return (kr6_change(kt, kl, fib_prio));
	case AID_VPN_IPv4:
		return (krVPN4_change(kt, kl, fib_prio));
	}
	log_warnx("kr_change: not handled AID");
	return (-1);
}

int
kr4_change(struct ktable *kt, struct kroute_full *kl, u_int8_t fib_prio)
{
	struct kroute_node	*kr;
	int			 action = RTM_ADD;
	u_int16_t		 labelid;

	if ((kr = kroute_find(kt, kl->prefix.v4.s_addr, kl->prefixlen,
	    fib_prio)) != NULL)
		action = RTM_CHANGE;

	/* for blackhole and reject routes nexthop needs to be 127.0.0.1 */
	if (kl->flags & (F_BLACKHOLE|F_REJECT))
		kl->nexthop.v4.s_addr = htonl(INADDR_LOOPBACK);
	/* nexthop within 127/8 -> ignore silently */
	else if ((kl->nexthop.v4.s_addr & htonl(IN_CLASSA_NET)) ==
	    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
		return (0);

	labelid = rtlabel_name2id(kl->label);

	if (action == RTM_ADD) {
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("kr_change");
			return (-1);
		}
		kr->r.prefix.s_addr = kl->prefix.v4.s_addr;
		kr->r.prefixlen = kl->prefixlen;
		kr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;
		kr->r.flags = kl->flags | F_BGPD_INSERTED;
		kr->r.priority = fib_prio;
		kr->r.labelid = labelid;

		if (kroute_insert(kt, kr) == -1) {
			free(kr);
			return (-1);
		}
	} else {
		kr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;
		rtlabel_unref(kr->r.labelid);
		kr->r.labelid = labelid;
		if (kl->flags & F_BLACKHOLE)
			kr->r.flags |= F_BLACKHOLE;
		else
			kr->r.flags &= ~F_BLACKHOLE;
		if (kl->flags & F_REJECT)
			kr->r.flags |= F_REJECT;
		else
			kr->r.flags &= ~F_REJECT;
	}

	if (send_rtmsg(kr_state.fd, action, kt, &kr->r, fib_prio) == -1)
		return (-1);

	return (0);
}

int
kr6_change(struct ktable *kt, struct kroute_full *kl, u_int8_t fib_prio)
{
	struct kroute6_node	*kr6;
	struct in6_addr		 lo6 = IN6ADDR_LOOPBACK_INIT;
	int			 action = RTM_ADD;
	u_int16_t		 labelid;

	if ((kr6 = kroute6_find(kt, &kl->prefix.v6, kl->prefixlen, fib_prio)) !=
	    NULL)
		action = RTM_CHANGE;

	/* for blackhole and reject routes nexthop needs to be ::1 */
	if (kl->flags & (F_BLACKHOLE|F_REJECT))
		bcopy(&lo6, &kl->nexthop.v6, sizeof(kl->nexthop.v6));
	/* nexthop to loopback -> ignore silently */
	else if (IN6_IS_ADDR_LOOPBACK(&kl->nexthop.v6))
		return (0);

	labelid = rtlabel_name2id(kl->label);

	if (action == RTM_ADD) {
		if ((kr6 = calloc(1, sizeof(struct kroute6_node))) == NULL) {
			log_warn("kr_change");
			return (-1);
		}
		memcpy(&kr6->r.prefix, &kl->prefix.v6, sizeof(struct in6_addr));
		kr6->r.prefixlen = kl->prefixlen;
		memcpy(&kr6->r.nexthop, &kl->nexthop.v6,
		    sizeof(struct in6_addr));
		kr6->r.flags = kl->flags | F_BGPD_INSERTED;
		kr6->r.priority = fib_prio;
		kr6->r.labelid = labelid;

		if (kroute6_insert(kt, kr6) == -1) {
			free(kr6);
			return (-1);
		}
	} else {
		memcpy(&kr6->r.nexthop, &kl->nexthop.v6,
		    sizeof(struct in6_addr));
		rtlabel_unref(kr6->r.labelid);
		kr6->r.labelid = labelid;
		if (kl->flags & F_BLACKHOLE)
			kr6->r.flags |= F_BLACKHOLE;
		else
			kr6->r.flags &= ~F_BLACKHOLE;
		if (kl->flags & F_REJECT)
			kr6->r.flags |= F_REJECT;
		else
			kr6->r.flags &= ~F_REJECT;
	}

	if (send_rt6msg(kr_state.fd, action, kt, &kr6->r, fib_prio) == -1)
		return (-1);

	return (0);
}

int
krVPN4_change(struct ktable *kt, struct kroute_full *kl, u_int8_t fib_prio)
{
	struct kroute_node	*kr;
	int			 action = RTM_ADD;
	u_int32_t		 mplslabel = 0;
	u_int16_t		 labelid;

	if ((kr = kroute_find(kt, kl->prefix.vpn4.addr.s_addr, kl->prefixlen,
	    fib_prio)) != NULL)
		action = RTM_CHANGE;

	/* nexthop within 127/8 -> ignore silently */
	if ((kl->nexthop.v4.s_addr & htonl(IN_CLASSA_NET)) ==
	    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
		return (0);

	/* only single MPLS label are supported for now */
	if (kl->prefix.vpn4.labellen != 3) {
		log_warnx("krVPN4_change: %s/%u has not a single label",
		    log_addr(&kl->prefix), kl->prefixlen);
		return (0);
	}
	mplslabel = (kl->prefix.vpn4.labelstack[0] << 24) |
	    (kl->prefix.vpn4.labelstack[1] << 16) |
	    (kl->prefix.vpn4.labelstack[2] << 8);
	mplslabel = htonl(mplslabel);

	labelid = rtlabel_name2id(kl->label);

	/* for blackhole and reject routes nexthop needs to be 127.0.0.1 */
	if (kl->flags & (F_BLACKHOLE|F_REJECT))
		kl->nexthop.v4.s_addr = htonl(INADDR_LOOPBACK);

	if (action == RTM_ADD) {
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("krVPN4_change");
			return (-1);
		}
		kr->r.prefix.s_addr = kl->prefix.vpn4.addr.s_addr;
		kr->r.prefixlen = kl->prefixlen;
		kr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;
		kr->r.flags = kl->flags | F_BGPD_INSERTED | F_MPLS;
		kr->r.priority = fib_prio;
		kr->r.labelid = labelid;
		kr->r.mplslabel = mplslabel;

		if (kroute_insert(kt, kr) == -1) {
			free(kr);
			return (-1);
		}
	} else {
		kr->r.mplslabel = mplslabel;
		kr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;
		rtlabel_unref(kr->r.labelid);
		kr->r.labelid = labelid;
		if (kl->flags & F_BLACKHOLE)
			kr->r.flags |= F_BLACKHOLE;
		else
			kr->r.flags &= ~F_BLACKHOLE;
		if (kl->flags & F_REJECT)
			kr->r.flags |= F_REJECT;
		else
			kr->r.flags &= ~F_REJECT;
	}

	if (send_rtmsg(kr_state.fd, action, kt, &kr->r, fib_prio) == -1)
		return (-1);

	return (0);
}

int
kr_delete(u_int rtableid, struct kroute_full *kl, u_int8_t fib_prio)
{
	struct ktable		*kt;

	if ((kt = ktable_get(rtableid)) == NULL)
		/* too noisy during reloads, just ignore */
		return (0);

	switch (kl->prefix.aid) {
	case AID_INET:
		return (kr4_delete(kt, kl, fib_prio));
	case AID_INET6:
		return (kr6_delete(kt, kl, fib_prio));
	case AID_VPN_IPv4:
		return (krVPN4_delete(kt, kl, fib_prio));
	}
	log_warnx("%s: not handled AID", __func__);
	return (-1);
}

int
kr4_delete(struct ktable *kt, struct kroute_full *kl, u_int8_t fib_prio)
{
	struct kroute_node	*kr;

	if ((kr = kroute_find(kt, kl->prefix.v4.s_addr, kl->prefixlen,
	    fib_prio)) == NULL)
		return (0);

	if (!(kr->r.flags & F_BGPD_INSERTED))
		return (0);

	if (send_rtmsg(kr_state.fd, RTM_DELETE, kt, &kr->r, fib_prio) == -1)
		return (-1);

	rtlabel_unref(kr->r.labelid);

	if (kroute_remove(kt, kr) == -1)
		return (-1);

	return (0);
}

int
kr6_delete(struct ktable *kt, struct kroute_full *kl, u_int8_t fib_prio)
{
	struct kroute6_node	*kr6;

	if ((kr6 = kroute6_find(kt, &kl->prefix.v6, kl->prefixlen, fib_prio)) ==
	    NULL)
		return (0);

	if (!(kr6->r.flags & F_BGPD_INSERTED))
		return (0);

	if (send_rt6msg(kr_state.fd, RTM_DELETE, kt, &kr6->r, fib_prio) == -1)
		return (-1);

	rtlabel_unref(kr6->r.labelid);

	if (kroute6_remove(kt, kr6) == -1)
		return (-1);

	return (0);
}

int
krVPN4_delete(struct ktable *kt, struct kroute_full *kl, u_int8_t fib_prio)
{
	struct kroute_node	*kr;

	if ((kr = kroute_find(kt, kl->prefix.vpn4.addr.s_addr, kl->prefixlen,
	    fib_prio)) == NULL)
		return (0);

	if (!(kr->r.flags & F_BGPD_INSERTED))
		return (0);

	if (send_rtmsg(kr_state.fd, RTM_DELETE, kt, &kr->r, fib_prio) == -1)
		return (-1);

	rtlabel_unref(kr->r.labelid);

	if (kroute_remove(kt, kr) == -1)
		return (-1);

	return (0);
}

void
kr_shutdown(u_int8_t fib_prio)
{
	u_int	i;

	for (i = krt_size; i > 0; i--)
		ktable_free(i - 1, fib_prio);
	kif_clear();
}

void
kr_fib_couple(u_int rtableid, u_int8_t fib_prio)
{
	struct ktable		*kt;
	struct kroute_node	*kr;
	struct kroute6_node	*kr6;

	if ((kt = ktable_get(rtableid)) == NULL)  /* table does not exist */
		return;

	if (kt->fib_sync)	/* already coupled */
		return;

	kt->fib_sync = 1;

	RB_FOREACH(kr, kroute_tree, &kt->krt)
		if ((kr->r.flags & F_BGPD_INSERTED))
			send_rtmsg(kr_state.fd, RTM_ADD, kt, &kr->r, fib_prio);
	RB_FOREACH(kr6, kroute6_tree, &kt->krt6)
		if ((kr6->r.flags & F_BGPD_INSERTED))
			send_rt6msg(kr_state.fd, RTM_ADD, kt, &kr6->r,
			    fib_prio);

	log_info("kernel routing table %u (%s) coupled", kt->rtableid,
	    kt->descr);
}

void
kr_fib_couple_all(u_int8_t fib_prio)
{
	u_int	 i;

	for (i = krt_size; i > 0; i--)
		kr_fib_couple(i - 1, fib_prio);
}

void
kr_fib_decouple(u_int rtableid, u_int8_t fib_prio)
{
	struct ktable		*kt;
	struct kroute_node	*kr;
	struct kroute6_node	*kr6;

	if ((kt = ktable_get(rtableid)) == NULL)  /* table does not exist */
		return;

	if (!kt->fib_sync)	/* already decoupled */
		return;

	RB_FOREACH(kr, kroute_tree, &kt->krt)
		if ((kr->r.flags & F_BGPD_INSERTED))
			send_rtmsg(kr_state.fd, RTM_DELETE, kt, &kr->r,
			    fib_prio);
	RB_FOREACH(kr6, kroute6_tree, &kt->krt6)
		if ((kr6->r.flags & F_BGPD_INSERTED))
			send_rt6msg(kr_state.fd, RTM_DELETE, kt, &kr6->r,
			    fib_prio);

	kt->fib_sync = 0;

	log_info("kernel routing table %u (%s) decoupled", kt->rtableid,
	    kt->descr);
}

void
kr_fib_decouple_all(u_int8_t fib_prio)
{
	u_int	 i;

	for (i = krt_size; i > 0; i--)
		kr_fib_decouple(i - 1, fib_prio);
}

void
kr_fib_update_prio(u_int rtableid, u_int8_t fib_prio)
{
	struct ktable		*kt;
	struct kroute_node	*kr;
	struct kroute6_node	*kr6;

	if ((kt = ktable_get(rtableid)) == NULL)  /* table does not exist */
		return;

	RB_FOREACH(kr, kroute_tree, &kt->krt)
		if ((kr->r.flags & F_BGPD_INSERTED))
			kr->r.priority = fib_prio;

	RB_FOREACH(kr6, kroute6_tree, &kt->krt6)
		if ((kr6->r.flags & F_BGPD_INSERTED))
			kr6->r.priority = fib_prio;
}

void
kr_fib_update_prio_all(u_int8_t fib_prio)
{
	u_int	 i;

	for (i = krt_size; i > 0; i--)
		kr_fib_update_prio(i - 1, fib_prio);
}

int
kr_dispatch_msg(void)
{
	return (dispatch_rtmsg());
}

int
kr_nexthop_add(u_int rtableid, struct bgpd_addr *addr)
{
	struct ktable		*kt;
	struct knexthop_node	*h;

	if ((kt = ktable_get(rtableid)) == NULL) {
		log_warnx("kr_nexthop_add: non-existent rtableid %d", rtableid);
		return (0);
	}
	if ((h = knexthop_find(kt, addr)) != NULL) {
		/* should not happen... this is actually an error path */
		knexthop_send_update(h);
	} else {
		if ((h = calloc(1, sizeof(struct knexthop_node))) == NULL) {
			log_warn("kr_nexthop_add");
			return (-1);
		}
		memcpy(&h->nexthop, addr, sizeof(h->nexthop));

		if (knexthop_insert(kt, h) == -1)
			return (-1);
	}

	return (0);
}

void
kr_nexthop_delete(u_int rtableid, struct bgpd_addr *addr)
{
	struct ktable		*kt;
	struct knexthop_node	*kn;

	if ((kt = ktable_get(rtableid)) == NULL) {
		log_warnx("kr_nexthop_delete: non-existent rtableid %d",
		    rtableid);
		return;
	}
	if ((kn = knexthop_find(kt, addr)) == NULL)
		return;

	knexthop_remove(kt, kn);
}

void
kr_show_route(struct imsg *imsg)
{
	struct ktable		*kt;
	struct kroute_node	*kr, *kn;
	struct kroute6_node	*kr6, *kn6;
	struct bgpd_addr	*addr;
	int			 flags;
	sa_family_t		 af;
	struct ctl_show_nexthop	 snh;
	struct knexthop_node	*h;
	struct kif_node		*kif;
	u_int			 i;
	u_short			 ifindex = 0;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(flags) +
		    sizeof(af)) {
			log_warnx("kr_show_route: wrong imsg len");
			break;
		}
		kt = ktable_get(imsg->hdr.peerid);
		if (kt == NULL) {
			log_warnx("kr_show_route: table %u does not exist",
			    imsg->hdr.peerid);
			break;
		}
		memcpy(&flags, imsg->data, sizeof(flags));
		memcpy(&af, (char *)imsg->data + sizeof(flags), sizeof(af));
		if (!af || af == AF_INET)
			RB_FOREACH(kr, kroute_tree, &kt->krt) {
				if (flags && (kr->r.flags & flags) == 0)
					continue;
				kn = kr;
				do {
					send_imsg_session(IMSG_CTL_KROUTE,
					    imsg->hdr.pid, kr_tofull(&kn->r),
					    sizeof(struct kroute_full));
				} while ((kn = kn->next) != NULL);
			}
		if (!af || af == AF_INET6)
			RB_FOREACH(kr6, kroute6_tree, &kt->krt6) {
				if (flags && (kr6->r.flags & flags) == 0)
					continue;
				kn6 = kr6;
				do {
					send_imsg_session(IMSG_CTL_KROUTE,
					    imsg->hdr.pid, kr6_tofull(&kn6->r),
					    sizeof(struct kroute_full));
				} while ((kn6 = kn6->next) != NULL);
			}
		break;
	case IMSG_CTL_KROUTE_ADDR:
		if (imsg->hdr.len != IMSG_HEADER_SIZE +
		    sizeof(struct bgpd_addr)) {
			log_warnx("kr_show_route: wrong imsg len");
			break;
		}
		kt = ktable_get(imsg->hdr.peerid);
		if (kt == NULL) {
			log_warnx("kr_show_route: table %u does not exist",
			    imsg->hdr.peerid);
			break;
		}
		addr = imsg->data;
		kr = NULL;
		switch (addr->aid) {
		case AID_INET:
			kr = kroute_match(kt, addr->v4.s_addr, 1);
			if (kr != NULL)
				send_imsg_session(IMSG_CTL_KROUTE,
				    imsg->hdr.pid, kr_tofull(&kr->r),
				    sizeof(struct kroute_full));
			break;
		case AID_INET6:
			kr6 = kroute6_match(kt, &addr->v6, 1);
			if (kr6 != NULL)
				send_imsg_session(IMSG_CTL_KROUTE,
				    imsg->hdr.pid, kr6_tofull(&kr6->r),
				    sizeof(struct kroute_full));
			break;
		}
		break;
	case IMSG_CTL_SHOW_NEXTHOP:
		kt = ktable_get(imsg->hdr.peerid);
		if (kt == NULL) {
			log_warnx("kr_show_route: table %u does not exist",
			    imsg->hdr.peerid);
			break;
		}
		RB_FOREACH(h, knexthop_tree, KT2KNT(kt)) {
			bzero(&snh, sizeof(snh));
			memcpy(&snh.addr, &h->nexthop, sizeof(snh.addr));
			if (h->kroute != NULL) {
				switch (h->nexthop.aid) {
				case AID_INET:
					kr = h->kroute;
					snh.valid = kroute_validate(&kr->r);
					snh.krvalid = 1;
					memcpy(&snh.kr.kr4, &kr->r,
					    sizeof(snh.kr.kr4));
					ifindex = kr->r.ifindex;
					break;
				case AID_INET6:
					kr6 = h->kroute;
					snh.valid = kroute6_validate(&kr6->r);
					snh.krvalid = 1;
					memcpy(&snh.kr.kr6, &kr6->r,
					    sizeof(snh.kr.kr6));
					ifindex = kr6->r.ifindex;
					break;
				}
				if ((kif = kif_find(ifindex)) != NULL)
					memcpy(&snh.kif, &kif->k,
					    sizeof(snh.kif));
			}
			send_imsg_session(IMSG_CTL_SHOW_NEXTHOP, imsg->hdr.pid,
			    &snh, sizeof(snh));
		}
		break;
	case IMSG_CTL_SHOW_INTERFACE:
		RB_FOREACH(kif, kif_tree, &kit)
			send_imsg_session(IMSG_CTL_SHOW_INTERFACE,
			    imsg->hdr.pid, &kif->k, sizeof(kif->k));
		break;
	case IMSG_CTL_SHOW_FIB_TABLES:
		for (i = 0; i < krt_size; i++) {
			struct ktable	ktab;

			if ((kt = ktable_get(i)) == NULL)
				continue;

			ktab = *kt;
			/* do not leak internal information */
			RB_INIT(&ktab.krt);
			RB_INIT(&ktab.krt6);
			RB_INIT(&ktab.knt);
			TAILQ_INIT(&ktab.krn);

			send_imsg_session(IMSG_CTL_SHOW_FIB_TABLES,
			    imsg->hdr.pid, &ktab, sizeof(ktab));
		}
		break;
	default:	/* nada */
		break;
	}

	send_imsg_session(IMSG_CTL_END, imsg->hdr.pid, NULL, 0);
}

void
kr_ifinfo(char *ifname)
{
	struct kif_node	*kif;

	RB_FOREACH(kif, kif_tree, &kit)
		if (!strcmp(ifname, kif->k.ifname)) {
			send_imsg_session(IMSG_IFINFO, 0,
			    &kif->k, sizeof(kif->k));
			return;
		}
}

void
kr_net_delete(struct network *n)
{
	filterset_free(&n->net.attrset);
	free(n);
}

struct network *
kr_net_match(struct ktable *kt, struct kroute *kr)
{
	struct network		*xn;

	TAILQ_FOREACH(xn, &kt->krn, entry) {
		if (xn->net.prefix.aid != AID_INET)
			continue;
		switch (xn->net.type) {
		case NETWORK_DEFAULT:
			if (xn->net.prefixlen == kr->prefixlen &&
			    xn->net.prefix.v4.s_addr == kr->prefix.s_addr)
				/* static match already redistributed */
				return (NULL);
			break;
		case NETWORK_STATIC:
			if (kr->flags & F_STATIC)
				return (xn);
			break;
		case NETWORK_CONNECTED:
			if (kr->flags & F_CONNECTED)
				return (xn);
			break;
		case NETWORK_RTLABEL:
			if (kr->labelid == xn->net.rtlabel)
				return (xn);
			break;
		case NETWORK_MRTCLONE:
			/* can not happen */
			break;
		}
	}
	return (NULL);
}

struct network *
kr_net_match6(struct ktable *kt, struct kroute6 *kr6)
{
	struct network		*xn;

	TAILQ_FOREACH(xn, &kt->krn, entry) {
		if (xn->net.prefix.aid != AID_INET6)
			continue;
		switch (xn->net.type) {
		case NETWORK_DEFAULT:
			if (xn->net.prefixlen == kr6->prefixlen &&
			    memcmp(&xn->net.prefix.v6, &kr6->prefix,
			    sizeof(struct in6_addr)) == 0)
				/* static match already redistributed */
				return (NULL);
			break;
		case NETWORK_STATIC:
			if (kr6->flags & F_STATIC)
				return (xn);
			break;
		case NETWORK_CONNECTED:
			if (kr6->flags & F_CONNECTED)
				return (xn);
			break;
		case NETWORK_RTLABEL:
			if (kr6->labelid == xn->net.rtlabel)
				return (xn);
			break;
		case NETWORK_MRTCLONE:
			/* can not happen */
			break;
		}
	}
	return (NULL);
}

struct network *
kr_net_find(struct ktable *kt, struct network *n)
{
	struct network		*xn;

	TAILQ_FOREACH(xn, &kt->krn, entry) {
		if (n->net.type != xn->net.type ||
		    n->net.prefixlen != xn->net.prefixlen ||
		    n->net.rtableid != xn->net.rtableid)
			continue;
		if (memcmp(&n->net.prefix, &xn->net.prefix,
		    sizeof(n->net.prefix)) == 0)
			return (xn);
	}
	return (NULL);
}

int
kr_net_reload(u_int rtableid, struct network_head *nh)
{
	struct network		*n, *xn;
	struct ktable		*kt;

	if ((kt = ktable_get(rtableid)) == NULL) {
		log_warnx("kr_net_reload: non-existent rtableid %d", rtableid);
		return (-1);
	}

	TAILQ_FOREACH(n, &kt->krn, entry)
		n->net.old = 1;

	while ((n = TAILQ_FIRST(nh)) != NULL) {
		TAILQ_REMOVE(nh, n, entry);
		n->net.old = 0;
		n->net.rtableid = rtableid;
		xn = kr_net_find(kt, n);
		if (xn) {
			xn->net.old = 0;
			filterset_free(&xn->net.attrset);
			filterset_move(&n->net.attrset, &xn->net.attrset);
			kr_net_delete(n);
		} else
			TAILQ_INSERT_TAIL(&kt->krn, n, entry);
	}

	for (n = TAILQ_FIRST(&kt->krn); n != NULL; n = xn) {
		xn = TAILQ_NEXT(n, entry);
		if (n->net.old) {
			if (n->net.type == NETWORK_DEFAULT)
				if (send_network(IMSG_NETWORK_REMOVE, &n->net,
				    NULL))
					return (-1);
			TAILQ_REMOVE(&kt->krn, n, entry);
			kr_net_delete(n);
		}
	}

	return (0);
}

int
kr_redistribute(int type, struct ktable *kt, struct kroute *kr)
{
	struct network		*match;
	struct network_config	 net;
	u_int32_t		 a;

	/* shortcut for removals */
	if (type == IMSG_NETWORK_REMOVE) {
		if (!(kr->flags & F_REDISTRIBUTED))
			return (0);	/* no match, don't redistribute */
		kr->flags &= ~F_REDISTRIBUTED;
		match = NULL;
		goto sendit;
	}

	if (!(kr->flags & F_KERNEL))
		return (0);

	/* Dynamic routes are not redistributable. */
	if (kr->flags & F_DYNAMIC)
		return (0);

	/*
	 * We consider the loopback net, multicast and experimental addresses
	 * as not redistributable.
	 */
	a = ntohl(kr->prefix.s_addr);
	if (IN_MULTICAST(a) || IN_BADCLASS(a) ||
	    (a >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
		return (0);

	/* Consider networks with nexthop loopback as not redistributable. */
	if (kr->nexthop.s_addr == htonl(INADDR_LOOPBACK))
		return (0);

	/*
	 * never allow 0.0.0.0/0 the default route can only be redistributed
	 * with announce default.
	 */
	if (kr->prefix.s_addr == INADDR_ANY && kr->prefixlen == 0)
		return (0);

	match = kr_net_match(kt, kr);
	if (match == NULL) {
		if (!(kr->flags & F_REDISTRIBUTED))
			return (0);	/* no match, don't redistribute */
		/* route no longer matches but is redistributed, so remove */
		kr->flags &= ~F_REDISTRIBUTED;
		type = IMSG_NETWORK_REMOVE;
	} else
		kr->flags |= F_REDISTRIBUTED;

sendit:
	bzero(&net, sizeof(net));
	net.prefix.aid = AID_INET;
	net.prefix.v4.s_addr = kr->prefix.s_addr;
	net.prefixlen = kr->prefixlen;
	net.rtlabel = kr->labelid;
	net.rtableid = kt->rtableid;

	return (send_network(type, &net, match ? &match->net.attrset : NULL));
}

int
kr_redistribute6(int type, struct ktable *kt, struct kroute6 *kr6)
{
	struct network		*match;
	struct network_config	 net;

	/* shortcut for removals */
	if (type == IMSG_NETWORK_REMOVE) {
		if (!(kr6->flags & F_REDISTRIBUTED))
			return (0);	/* no match, don't redistribute */
		kr6->flags &= ~F_REDISTRIBUTED;
		match = NULL;
		goto sendit;
	}

	if (!(kr6->flags & F_KERNEL))
		return (0);

	/* Dynamic routes are not redistributable. */
	if (kr6->flags & F_DYNAMIC)
		return (0);

	/*
	 * We consider unspecified, loopback, multicast, link- and site-local,
	 * IPv4 mapped and IPv4 compatible addresses as not redistributable.
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&kr6->prefix) ||
	    IN6_IS_ADDR_LOOPBACK(&kr6->prefix) ||
	    IN6_IS_ADDR_MULTICAST(&kr6->prefix) ||
	    IN6_IS_ADDR_LINKLOCAL(&kr6->prefix) ||
	    IN6_IS_ADDR_SITELOCAL(&kr6->prefix) ||
	    IN6_IS_ADDR_V4MAPPED(&kr6->prefix) ||
	    IN6_IS_ADDR_V4COMPAT(&kr6->prefix))
		return (0);

	/*
	 * Consider networks with nexthop loopback as not redistributable.
	 */
	if (IN6_IS_ADDR_LOOPBACK(&kr6->nexthop))
		return (0);

	/*
	 * never allow ::/0 the default route can only be redistributed
	 * with announce default.
	 */
	if (kr6->prefixlen == 0 &&
	    memcmp(&kr6->prefix, &in6addr_any, sizeof(struct in6_addr)) == 0)
		return (0);

	match = kr_net_match6(kt, kr6);
	if (match == NULL) {
		if (!(kr6->flags & F_REDISTRIBUTED))
			return (0);	/* no match, don't redistribute */
		/* route no longer matches but is redistributed, so remove */
		kr6->flags &= ~F_REDISTRIBUTED;
		type = IMSG_NETWORK_REMOVE;
	} else
		kr6->flags |= F_REDISTRIBUTED;
sendit:
	bzero(&net, sizeof(net));
	net.prefix.aid = AID_INET6;
	memcpy(&net.prefix.v6, &kr6->prefix, sizeof(struct in6_addr));
	net.prefixlen = kr6->prefixlen;
	net.rtlabel = kr6->labelid;
	net.rtableid = kt->rtableid;

	return (send_network(type, &net, match ? &match->net.attrset : NULL));
}

int
kr_reload(void)
{
	struct ktable		*kt;
	struct kroute_node	*kr;
	struct kroute6_node	*kr6;
	struct knexthop_node	*nh;
	struct network		*n;
	u_int			 rid;
	int			 hasdyn = 0;

	for (rid = 0; rid < krt_size; rid++) {
		if ((kt = ktable_get(rid)) == NULL)
			continue;

		RB_FOREACH(nh, knexthop_tree, KT2KNT(kt))
			knexthop_validate(kt, nh);

		TAILQ_FOREACH(n, &kt->krn, entry)
			if (n->net.type == NETWORK_DEFAULT) {
				if (send_network(IMSG_NETWORK_ADD, &n->net,
				    &n->net.attrset))
					return (-1);
			} else
				hasdyn = 1;

		if (hasdyn) {
			/* only evaluate the full tree if we need */
			RB_FOREACH(kr, kroute_tree, &kt->krt)
				kr_redistribute(IMSG_NETWORK_ADD, kt, &kr->r);
			RB_FOREACH(kr6, kroute6_tree, &kt->krt6)
				kr_redistribute6(IMSG_NETWORK_ADD, kt, &kr6->r);
		}
	}

	return (0);
}

struct kroute_full *
kr_tofull(struct kroute *kr)
{
	static struct kroute_full	kf;

	bzero(&kf, sizeof(kf));

	kf.prefix.aid = AID_INET;
	kf.prefix.v4.s_addr = kr->prefix.s_addr;
	kf.nexthop.aid = AID_INET;
	kf.nexthop.v4.s_addr = kr->nexthop.s_addr;
	strlcpy(kf.label, rtlabel_id2name(kr->labelid), sizeof(kf.label));
	kf.labelid = kr->labelid;
	kf.flags = kr->flags;
	kf.ifindex = kr->ifindex;
	kf.prefixlen = kr->prefixlen;
	kf.priority = kr->priority;

	return (&kf);
}

struct kroute_full *
kr6_tofull(struct kroute6 *kr6)
{
	static struct kroute_full	kf;

	bzero(&kf, sizeof(kf));

	kf.prefix.aid = AID_INET6;
	memcpy(&kf.prefix.v6, &kr6->prefix, sizeof(struct in6_addr));
	kf.nexthop.aid = AID_INET6;
	memcpy(&kf.nexthop.v6, &kr6->nexthop, sizeof(struct in6_addr));
	strlcpy(kf.label, rtlabel_id2name(kr6->labelid), sizeof(kf.label));
	kf.labelid = kr6->labelid;
	kf.flags = kr6->flags;
	kf.ifindex = kr6->ifindex;
	kf.prefixlen = kr6->prefixlen;
	kf.priority = kr6->priority;

	return (&kf);
}

/*
 * RB-tree compare functions
 */

int
kroute_compare(struct kroute_node *a, struct kroute_node *b)
{
	if (ntohl(a->r.prefix.s_addr) < ntohl(b->r.prefix.s_addr))
		return (-1);
	if (ntohl(a->r.prefix.s_addr) > ntohl(b->r.prefix.s_addr))
		return (1);
	if (a->r.prefixlen < b->r.prefixlen)
		return (-1);
	if (a->r.prefixlen > b->r.prefixlen)
		return (1);

	/* if the priority is RTP_ANY finish on the first address hit */
	if (a->r.priority == RTP_ANY || b->r.priority == RTP_ANY)
		return (0);
	if (a->r.priority < b->r.priority)
		return (-1);
	if (a->r.priority > b->r.priority)
		return (1);
	return (0);
}

int
kroute6_compare(struct kroute6_node *a, struct kroute6_node *b)
{
	int i;

	for (i = 0; i < 16; i++) {
		if (a->r.prefix.s6_addr[i] < b->r.prefix.s6_addr[i])
			return (-1);
		if (a->r.prefix.s6_addr[i] > b->r.prefix.s6_addr[i])
			return (1);
	}

	if (a->r.prefixlen < b->r.prefixlen)
		return (-1);
	if (a->r.prefixlen > b->r.prefixlen)
		return (1);

	/* if the priority is RTP_ANY finish on the first address hit */
	if (a->r.priority == RTP_ANY || b->r.priority == RTP_ANY)
		return (0);
	if (a->r.priority < b->r.priority)
		return (-1);
	if (a->r.priority > b->r.priority)
		return (1);
	return (0);
}

int
knexthop_compare(struct knexthop_node *a, struct knexthop_node *b)
{
	int	i;

	if (a->nexthop.aid != b->nexthop.aid)
		return (b->nexthop.aid - a->nexthop.aid);

	switch (a->nexthop.aid) {
	case AID_INET:
		if (ntohl(a->nexthop.v4.s_addr) < ntohl(b->nexthop.v4.s_addr))
			return (-1);
		if (ntohl(a->nexthop.v4.s_addr) > ntohl(b->nexthop.v4.s_addr))
			return (1);
		break;
	case AID_INET6:
		for (i = 0; i < 16; i++) {
			if (a->nexthop.v6.s6_addr[i] < b->nexthop.v6.s6_addr[i])
				return (-1);
			if (a->nexthop.v6.s6_addr[i] > b->nexthop.v6.s6_addr[i])
				return (1);
		}
		break;
	default:
		fatalx("knexthop_compare: unknown AF");
	}

	return (0);
}

int
kif_compare(struct kif_node *a, struct kif_node *b)
{
	return (b->k.ifindex - a->k.ifindex);
}


/*
 * tree management functions
 */

struct kroute_node *
kroute_find(struct ktable *kt, in_addr_t prefix, u_int8_t prefixlen,
    u_int8_t prio)
{
	struct kroute_node	s;
	struct kroute_node	*kn, *tmp;

	s.r.prefix.s_addr = prefix;
	s.r.prefixlen = prefixlen;
	s.r.priority = prio;

	kn = RB_FIND(kroute_tree, &kt->krt, &s);
	if (kn && prio == RTP_ANY) {
		tmp = RB_PREV(kroute_tree, &kt->krt, kn);
		while (tmp) {
			if (kroute_compare(&s, tmp) == 0)
				kn = tmp;
			else
				break;
			tmp = RB_PREV(kroute_tree, &kt->krt, kn);
		}
	}
	return (kn);
}

struct kroute_node *
kroute_matchgw(struct kroute_node *kr, struct sockaddr_in *sa_in)
{
	in_addr_t	nexthop;

	if (sa_in == NULL) {
		log_warnx("kroute_matchgw: no nexthop defined");
		return (NULL);
	}
	nexthop = sa_in->sin_addr.s_addr;

	while (kr) {
		if (kr->r.nexthop.s_addr == nexthop)
			return (kr);
		kr = kr->next;
	}

	return (NULL);
}

int
kroute_insert(struct ktable *kt, struct kroute_node *kr)
{
	struct kroute_node	*krm;
	struct knexthop_node	*h;
	in_addr_t		 mask, ina;

	if ((krm = RB_INSERT(kroute_tree, &kt->krt, kr)) != NULL) {
		/* multipath route, add at end of list */
		while (krm->next != NULL)
			krm = krm->next;
		krm->next = kr;
		kr->next = NULL; /* to be sure */
	}

	/* XXX this is wrong for nexthop validated via BGP */
	if (kr->r.flags & F_KERNEL) {
		mask = prefixlen2mask(kr->r.prefixlen);
		ina = ntohl(kr->r.prefix.s_addr);
		RB_FOREACH(h, knexthop_tree, KT2KNT(kt))
			if (h->nexthop.aid == AID_INET &&
			    (ntohl(h->nexthop.v4.s_addr) & mask) == ina)
				knexthop_validate(kt, h);

		if (kr->r.flags & F_CONNECTED)
			if (kif_kr_insert(kr) == -1)
				return (-1);

		if (krm == NULL)
			/* redistribute multipath routes only once */
			kr_redistribute(IMSG_NETWORK_ADD, kt, &kr->r);
	}
	return (0);
}


int
kroute_remove(struct ktable *kt, struct kroute_node *kr)
{
	struct kroute_node	*krm;
	struct knexthop_node	*s;

	if ((krm = RB_FIND(kroute_tree, &kt->krt, kr)) == NULL) {
		log_warnx("kroute_remove failed to find %s/%u",
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
		return (-1);
	}

	if (krm == kr) {
		/* head element */
		if (RB_REMOVE(kroute_tree, &kt->krt, kr) == NULL) {
			log_warnx("kroute_remove failed for %s/%u",
			    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
			return (-1);
		}
		if (kr->next != NULL) {
			if (RB_INSERT(kroute_tree, &kt->krt, kr->next) !=
			    NULL) {
				log_warnx("kroute_remove failed to add %s/%u",
				    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
				return (-1);
			}
		}
	} else {
		/* somewhere in the list */
		while (krm->next != kr && krm->next != NULL)
			krm = krm->next;
		if (krm->next == NULL) {
			log_warnx("kroute_remove multipath list corrupted "
			    "for %s/%u", inet_ntoa(kr->r.prefix),
			    kr->r.prefixlen);
			return (-1);
		}
		krm->next = kr->next;
	}

	/* check whether a nexthop depends on this kroute */
	if (kr->r.flags & F_NEXTHOP)
		RB_FOREACH(s, knexthop_tree, KT2KNT(kt))
			if (s->kroute == kr)
				knexthop_validate(kt, s);

	if (kr->r.flags & F_KERNEL && kr == krm && kr->next == NULL)
		/* again remove only once */
		kr_redistribute(IMSG_NETWORK_REMOVE, kt, &kr->r);

	if (kr->r.flags & F_CONNECTED)
		if (kif_kr_remove(kr) == -1) {
			free(kr);
			return (-1);
		}

	free(kr);
	return (0);
}

void
kroute_clear(struct ktable *kt)
{
	struct kroute_node	*kr;

	while ((kr = RB_MIN(kroute_tree, &kt->krt)) != NULL)
		kroute_remove(kt, kr);
}

struct kroute6_node *
kroute6_find(struct ktable *kt, const struct in6_addr *prefix,
    u_int8_t prefixlen, u_int8_t prio)
{
	struct kroute6_node	s;
	struct kroute6_node	*kn6, *tmp;

	memcpy(&s.r.prefix, prefix, sizeof(struct in6_addr));
	s.r.prefixlen = prefixlen;
	s.r.priority = prio;

	kn6 = RB_FIND(kroute6_tree, &kt->krt6, &s);
	if (kn6 && prio == RTP_ANY) {
		tmp = RB_PREV(kroute6_tree, &kt->krt6, kn6);
		while (tmp) {
			if (kroute6_compare(&s, tmp) == 0)
				kn6 = tmp;
			else
				break;
			tmp = RB_PREV(kroute6_tree, &kt->krt6, kn6);
		}
	}
	return (kn6);
}

struct kroute6_node *
kroute6_matchgw(struct kroute6_node *kr, struct sockaddr_in6 *sa_in6)
{
	struct in6_addr	nexthop;

	if (sa_in6 == NULL) {
		log_warnx("kroute6_matchgw: no nexthop defined");
		return (NULL);
	}
	memcpy(&nexthop, &sa_in6->sin6_addr, sizeof(nexthop));

	while (kr) {
		if (memcmp(&kr->r.nexthop, &nexthop, sizeof(nexthop)) == 0)
			return (kr);
		kr = kr->next;
	}

	return (NULL);
}

int
kroute6_insert(struct ktable *kt, struct kroute6_node *kr)
{
	struct kroute6_node	*krm;
	struct knexthop_node	*h;
	struct in6_addr		 ina, inb;

	if ((krm = RB_INSERT(kroute6_tree, &kt->krt6, kr)) != NULL) {
		/* multipath route, add at end of list */
		while (krm->next != NULL)
			krm = krm->next;
		krm->next = kr;
		kr->next = NULL; /* to be sure */
	}

	/* XXX this is wrong for nexthop validated via BGP */
	if (kr->r.flags & F_KERNEL) {
		inet6applymask(&ina, &kr->r.prefix, kr->r.prefixlen);
		RB_FOREACH(h, knexthop_tree, KT2KNT(kt))
			if (h->nexthop.aid == AID_INET6) {
				inet6applymask(&inb, &h->nexthop.v6,
				    kr->r.prefixlen);
				if (memcmp(&ina, &inb, sizeof(ina)) == 0)
					knexthop_validate(kt, h);
			}

		if (kr->r.flags & F_CONNECTED)
			if (kif_kr6_insert(kr) == -1)
				return (-1);

		if (krm == NULL)
			/* redistribute multipath routes only once */
			kr_redistribute6(IMSG_NETWORK_ADD, kt, &kr->r);
	}

	return (0);
}

int
kroute6_remove(struct ktable *kt, struct kroute6_node *kr)
{
	struct kroute6_node	*krm;
	struct knexthop_node	*s;

	if ((krm = RB_FIND(kroute6_tree, &kt->krt6, kr)) == NULL) {
		log_warnx("kroute6_remove failed for %s/%u",
		    log_in6addr(&kr->r.prefix), kr->r.prefixlen);
		return (-1);
	}

	if (krm == kr) {
		/* head element */
		if (RB_REMOVE(kroute6_tree, &kt->krt6, kr) == NULL) {
			log_warnx("kroute6_remove failed for %s/%u",
			    log_in6addr(&kr->r.prefix), kr->r.prefixlen);
			return (-1);
		}
		if (kr->next != NULL) {
			if (RB_INSERT(kroute6_tree, &kt->krt6, kr->next) !=
			    NULL) {
				log_warnx("kroute6_remove failed to add %s/%u",
				    log_in6addr(&kr->r.prefix),
				    kr->r.prefixlen);
				return (-1);
			}
		}
	} else {
		/* somewhere in the list */
		while (krm->next != kr && krm->next != NULL)
			krm = krm->next;
		if (krm->next == NULL) {
			log_warnx("kroute6_remove multipath list corrupted "
			    "for %s/%u", log_in6addr(&kr->r.prefix),
			    kr->r.prefixlen);
			return (-1);
		}
		krm->next = kr->next;
	}

	/* check whether a nexthop depends on this kroute */
	if (kr->r.flags & F_NEXTHOP)
		RB_FOREACH(s, knexthop_tree, KT2KNT(kt))
			if (s->kroute == kr)
				knexthop_validate(kt, s);

	if (kr->r.flags & F_KERNEL && kr == krm && kr->next == NULL)
		/* again remove only once */
		kr_redistribute6(IMSG_NETWORK_REMOVE, kt, &kr->r);

	if (kr->r.flags & F_CONNECTED)
		if (kif_kr6_remove(kr) == -1) {
			free(kr);
			return (-1);
		}

	free(kr);
	return (0);
}

void
kroute6_clear(struct ktable *kt)
{
	struct kroute6_node	*kr;

	while ((kr = RB_MIN(kroute6_tree, &kt->krt6)) != NULL)
		kroute6_remove(kt, kr);
}

struct knexthop_node *
knexthop_find(struct ktable *kt, struct bgpd_addr *addr)
{
	struct knexthop_node	s;

	bzero(&s, sizeof(s));
	memcpy(&s.nexthop, addr, sizeof(s.nexthop));

	return (RB_FIND(knexthop_tree, KT2KNT(kt), &s));
}

int
knexthop_insert(struct ktable *kt, struct knexthop_node *kn)
{
	if (RB_INSERT(knexthop_tree, KT2KNT(kt), kn) != NULL) {
		log_warnx("knexthop_insert failed for %s",
		    log_addr(&kn->nexthop));
		free(kn);
		return (-1);
	}

	knexthop_validate(kt, kn);

	return (0);
}

int
knexthop_remove(struct ktable *kt, struct knexthop_node *kn)
{
	kroute_detach_nexthop(kt, kn);

	if (RB_REMOVE(knexthop_tree, KT2KNT(kt), kn) == NULL) {
		log_warnx("knexthop_remove failed for %s",
		    log_addr(&kn->nexthop));
		return (-1);
	}

	free(kn);
	return (0);
}

void
knexthop_clear(struct ktable *kt)
{
	struct knexthop_node	*kn;

	while ((kn = RB_MIN(knexthop_tree, KT2KNT(kt))) != NULL)
		knexthop_remove(kt, kn);
}

struct kif_node *
kif_find(int ifindex)
{
	struct kif_node	s;

	bzero(&s, sizeof(s));
	s.k.ifindex = ifindex;

	return (RB_FIND(kif_tree, &kit, &s));
}

int
kif_insert(struct kif_node *kif)
{
	LIST_INIT(&kif->kroute_l);
	LIST_INIT(&kif->kroute6_l);

	if (RB_INSERT(kif_tree, &kit, kif) != NULL) {
		log_warnx("RB_INSERT(kif_tree, &kit, kif)");
		free(kif);
		return (-1);
	}

	return (0);
}

int
kif_remove(struct kif_node *kif)
{
	struct ktable	*kt;
	struct kif_kr	*kkr;
	struct kif_kr6	*kkr6;

	if (RB_REMOVE(kif_tree, &kit, kif) == NULL) {
		log_warnx("RB_REMOVE(kif_tree, &kit, kif)");
		return (-1);
	}

	if ((kt = ktable_get(/* XXX */ 0)) == NULL)
		goto done;

	while ((kkr = LIST_FIRST(&kif->kroute_l)) != NULL) {
		LIST_REMOVE(kkr, entry);
		kkr->kr->r.flags &= ~F_NEXTHOP;
		kroute_remove(kt, kkr->kr);
		free(kkr);
	}

	while ((kkr6 = LIST_FIRST(&kif->kroute6_l)) != NULL) {
		LIST_REMOVE(kkr6, entry);
		kkr6->kr->r.flags &= ~F_NEXTHOP;
		kroute6_remove(kt, kkr6->kr);
		free(kkr6);
	}
done:
	free(kif);
	return (0);
}

void
kif_clear(void)
{
	struct kif_node	*kif;

	while ((kif = RB_MIN(kif_tree, &kit)) != NULL)
		kif_remove(kif);
}

int
kif_kr_insert(struct kroute_node *kr)
{
	struct kif_node	*kif;
	struct kif_kr	*kkr;

	if ((kif = kif_find(kr->r.ifindex)) == NULL) {
		if (kr->r.ifindex)
			log_warnx("%s: interface with index %u not found",
			    __func__, kr->r.ifindex);
		return (0);
	}

	if (kif->k.nh_reachable)
		kr->r.flags &= ~F_DOWN;
	else
		kr->r.flags |= F_DOWN;

	if ((kkr = calloc(1, sizeof(struct kif_kr))) == NULL) {
		log_warn("kif_kr_insert");
		return (-1);
	}

	kkr->kr = kr;

	LIST_INSERT_HEAD(&kif->kroute_l, kkr, entry);

	return (0);
}

int
kif_kr_remove(struct kroute_node *kr)
{
	struct kif_node	*kif;
	struct kif_kr	*kkr;

	if ((kif = kif_find(kr->r.ifindex)) == NULL) {
		if (kr->r.ifindex)
			log_warnx("%s: interface with index %u not found",
			    __func__, kr->r.ifindex);
		return (0);
	}

	for (kkr = LIST_FIRST(&kif->kroute_l); kkr != NULL && kkr->kr != kr;
	    kkr = LIST_NEXT(kkr, entry))
		;	/* nothing */

	if (kkr == NULL) {
		log_warnx("can't remove connected route from interface "
		    "with index %u: not found", kr->r.ifindex);
		return (-1);
	}

	LIST_REMOVE(kkr, entry);
	free(kkr);

	return (0);
}

int
kif_kr6_insert(struct kroute6_node *kr)
{
	struct kif_node	*kif;
	struct kif_kr6	*kkr6;

	if ((kif = kif_find(kr->r.ifindex)) == NULL) {
		if (kr->r.ifindex)
			log_warnx("%s: interface with index %u not found",
			    __func__, kr->r.ifindex);
		return (0);
	}

	if (kif->k.nh_reachable)
		kr->r.flags &= ~F_DOWN;
	else
		kr->r.flags |= F_DOWN;

	if ((kkr6 = calloc(1, sizeof(struct kif_kr6))) == NULL) {
		log_warn("kif_kr6_insert");
		return (-1);
	}

	kkr6->kr = kr;

	LIST_INSERT_HEAD(&kif->kroute6_l, kkr6, entry);

	return (0);
}

int
kif_kr6_remove(struct kroute6_node *kr)
{
	struct kif_node	*kif;
	struct kif_kr6	*kkr6;

	if ((kif = kif_find(kr->r.ifindex)) == NULL) {
		if (kr->r.ifindex)
			log_warnx("%s: interface with index %u not found",
			    __func__, kr->r.ifindex);
		return (0);
	}

	for (kkr6 = LIST_FIRST(&kif->kroute6_l); kkr6 != NULL && kkr6->kr != kr;
	    kkr6 = LIST_NEXT(kkr6, entry))
		;	/* nothing */

	if (kkr6 == NULL) {
		log_warnx("can't remove connected route from interface "
		    "with index %u: not found", kr->r.ifindex);
		return (-1);
	}

	LIST_REMOVE(kkr6, entry);
	free(kkr6);

	return (0);
}

/*
 * nexthop validation
 */

int
kif_validate(struct kif *kif)
{
	if (!(kif->flags & IFF_UP))
		return (0);

	/*
	 * we treat link_state == LINK_STATE_UNKNOWN as valid,
	 * not all interfaces have a concept of "link state" and/or
	 * do not report up
	 */

	if (kif->link_state == LINK_STATE_DOWN)
		return (0);

	return (1);
}

int
kroute_validate(struct kroute *kr)
{
	struct kif_node		*kif;

	if (kr->flags & (F_REJECT | F_BLACKHOLE))
		return (0);

	if ((kif = kif_find(kr->ifindex)) == NULL) {
		if (kr->ifindex)
			log_warnx("%s: interface with index %d not found, "
			    "referenced from route for %s/%u", __func__,
			    kr->ifindex, inet_ntoa(kr->prefix),
			    kr->prefixlen);
		return (1);
	}

	return (kif->k.nh_reachable);
}

int
kroute6_validate(struct kroute6 *kr)
{
	struct kif_node		*kif;

	if (kr->flags & (F_REJECT | F_BLACKHOLE))
		return (0);

	if ((kif = kif_find(kr->ifindex)) == NULL) {
		if (kr->ifindex)
			log_warnx("%s: interface with index %d not found, "
			    "referenced from route for %s/%u", __func__,
			    kr->ifindex, log_in6addr(&kr->prefix),
			    kr->prefixlen);
		return (1);
	}

	return (kif->k.nh_reachable);
}

void
knexthop_validate(struct ktable *kt, struct knexthop_node *kn)
{
	void			*oldk;
	struct kroute_node	*kr;
	struct kroute6_node	*kr6;

	oldk = kn->kroute;
	kroute_detach_nexthop(kt, kn);

	switch (kn->nexthop.aid) {
	case AID_INET:
		kr = kroute_match(kt, kn->nexthop.v4.s_addr, 0);

		if (kr) {
			kn->kroute = kr;
			kr->r.flags |= F_NEXTHOP;
		}

		/*
		 * Send update if nexthop route changed under us if
		 * the route remains the same then the NH state has not
		 * changed. State changes are tracked by knexthop_track().
		 */
		if (kr != oldk)
			knexthop_send_update(kn);
		break;
	case AID_INET6:
		kr6 = kroute6_match(kt, &kn->nexthop.v6, 0);

		if (kr6) {
			kn->kroute = kr6;
			kr6->r.flags |= F_NEXTHOP;
		}

		if (kr6 != oldk)
			knexthop_send_update(kn);
		break;
	}
}

void
knexthop_track(struct ktable *kt, void *krp)
{
	struct knexthop_node	*kn;

	RB_FOREACH(kn, knexthop_tree, KT2KNT(kt))
		if (kn->kroute == krp)
			knexthop_send_update(kn);
}

void
knexthop_send_update(struct knexthop_node *kn)
{
	struct kroute_nexthop	 n;
	struct kroute_node	*kr;
	struct kroute6_node	*kr6;

	bzero(&n, sizeof(n));
	memcpy(&n.nexthop, &kn->nexthop, sizeof(n.nexthop));

	if (kn->kroute == NULL) {
		n.valid = 0;	/* NH is not valid */
		send_nexthop_update(&n);
		return;
	}

	switch (kn->nexthop.aid) {
	case AID_INET:
		kr = kn->kroute;
		n.valid = kroute_validate(&kr->r);
		n.connected = kr->r.flags & F_CONNECTED;
		if (kr->r.nexthop.s_addr != 0) {
			n.gateway.aid = AID_INET;
			n.gateway.v4.s_addr = kr->r.nexthop.s_addr;
		}
		if (n.connected) {
			n.net.aid = AID_INET;
			n.net.v4.s_addr = kr->r.prefix.s_addr;
			n.netlen = kr->r.prefixlen;
		}
		break;
	case AID_INET6:
		kr6 = kn->kroute;
		n.valid = kroute6_validate(&kr6->r);
		n.connected = kr6->r.flags & F_CONNECTED;
		if (memcmp(&kr6->r.nexthop, &in6addr_any,
		    sizeof(struct in6_addr)) != 0) {
			n.gateway.aid = AID_INET6;
			memcpy(&n.gateway.v6, &kr6->r.nexthop,
			    sizeof(struct in6_addr));
		}
		if (n.connected) {
			n.net.aid = AID_INET6;
			memcpy(&n.net.v6, &kr6->r.prefix,
			    sizeof(struct in6_addr));
			n.netlen = kr6->r.prefixlen;
		}
		break;
	}
	send_nexthop_update(&n);
}

struct kroute_node *
kroute_match(struct ktable *kt, in_addr_t key, int matchall)
{
	int			 i;
	struct kroute_node	*kr;
	in_addr_t		 ina;

	ina = ntohl(key);

	/* we will never match the default route */
	for (i = 32; i > 0; i--)
		if ((kr = kroute_find(kt, htonl(ina & prefixlen2mask(i)), i,
		    RTP_ANY)) != NULL)
			if (matchall || bgpd_filternexthop(&kr->r, NULL) == 0)
			    return (kr);

	/* if we don't have a match yet, try to find a default route */
	if ((kr = kroute_find(kt, 0, 0, RTP_ANY)) != NULL)
		if (matchall || bgpd_filternexthop(&kr->r, NULL) == 0)
			return (kr);

	return (NULL);
}

struct kroute6_node *
kroute6_match(struct ktable *kt, struct in6_addr *key, int matchall)
{
	int			 i;
	struct kroute6_node	*kr6;
	struct in6_addr		 ina;

	/* we will never match the default route */
	for (i = 128; i > 0; i--) {
		inet6applymask(&ina, key, i);
		if ((kr6 = kroute6_find(kt, &ina, i, RTP_ANY)) != NULL)
			if (matchall || bgpd_filternexthop(NULL, &kr6->r) == 0)
				return (kr6);
	}

	/* if we don't have a match yet, try to find a default route */
	if ((kr6 = kroute6_find(kt, &in6addr_any, 0, RTP_ANY)) != NULL)
		if (matchall || bgpd_filternexthop(NULL, &kr6->r) == 0)
			return (kr6);

	return (NULL);
}

void
kroute_detach_nexthop(struct ktable *kt, struct knexthop_node *kn)
{
	struct knexthop_node	*s;
	struct kroute_node	*k;
	struct kroute6_node	*k6;

	if (kn->kroute == NULL)
		return;

	/*
	 * check whether there's another nexthop depending on this kroute
	 * if not remove the flag
	 */
	RB_FOREACH(s, knexthop_tree, KT2KNT(kt))
		if (s->kroute == kn->kroute && s != kn)
			break;

	if (s == NULL) {
		switch (kn->nexthop.aid) {
		case AID_INET:
			k = kn->kroute;
			k->r.flags &= ~F_NEXTHOP;
			break;
		case AID_INET6:
			k6 = kn->kroute;
			k6->r.flags &= ~F_NEXTHOP;
			break;
		}
	}

	kn->kroute = NULL;
}

/*
 * misc helpers
 */

int
protect_lo(struct ktable *kt)
{
	struct kroute_node	*kr;
	struct kroute6_node	*kr6;

	/* special protection for 127/8 */
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
		log_warn("protect_lo");
		return (-1);
	}
	kr->r.prefix.s_addr = htonl(INADDR_LOOPBACK & IN_CLASSA_NET);
	kr->r.prefixlen = 8;
	kr->r.flags = F_KERNEL|F_CONNECTED;

	if (RB_INSERT(kroute_tree, &kt->krt, kr) != NULL)
		free(kr);	/* kernel route already there, no problem */

	/* special protection for loopback */
	if ((kr6 = calloc(1, sizeof(struct kroute6_node))) == NULL) {
		log_warn("protect_lo");
		return (-1);
	}
	memcpy(&kr6->r.prefix, &in6addr_loopback, sizeof(kr6->r.prefix));
	kr6->r.prefixlen = 128;
	kr6->r.flags = F_KERNEL|F_CONNECTED;

	if (RB_INSERT(kroute6_tree, &kt->krt6, kr6) != NULL)
		free(kr6);	/* kernel route already there, no problem */

	return (0);
}

u_int8_t
prefixlen_classful(in_addr_t ina)
{
	/* it hurt to write this. */

	if (ina >= 0xf0000000U)		/* class E */
		return (32);
	else if (ina >= 0xe0000000U)	/* class D */
		return (4);
	else if (ina >= 0xc0000000U)	/* class C */
		return (24);
	else if (ina >= 0x80000000U)	/* class B */
		return (16);
	else				/* class A */
		return (8);
}

u_int8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

u_int8_t
mask2prefixlen6(struct sockaddr_in6 *sa_in6)
{
	u_int8_t	 l = 0, *ap, *ep;

	/*
	 * sin6_len is the size of the sockaddr so substract the offset of
	 * the possibly truncated sin6_addr struct.
	 */
	ap = (u_int8_t *)&sa_in6->sin6_addr;
	ep = (u_int8_t *)sa_in6 + sa_in6->sin6_len;
	for (; ap < ep; ap++) {
		/* this "beauty" is adopted from sbin/route/show.c ... */
		switch (*ap) {
		case 0xff:
			l += 8;
			break;
		case 0xfe:
			l += 7;
			return (l);
		case 0xfc:
			l += 6;
			return (l);
		case 0xf8:
			l += 5;
			return (l);
		case 0xf0:
			l += 4;
			return (l);
		case 0xe0:
			l += 3;
			return (l);
		case 0xc0:
			l += 2;
			return (l);
		case 0x80:
			l += 1;
			return (l);
		case 0x00:
			return (l);
		default:
			fatalx("non contiguous inet6 netmask");
		}
	}

	return (l);
}

struct in6_addr *
prefixlen2mask6(u_int8_t prefixlen)
{
	static struct in6_addr	mask;
	int			i;

	bzero(&mask, sizeof(mask));
	for (i = 0; i < prefixlen / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

	return (&mask);
}

#define	ROUNDUP(a)	\
    (((a) & (sizeof(long) - 1)) ? (1 + ((a) | (sizeof(long) - 1))) : (a))

void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		} else
			rti_info[i] = NULL;
	}
}

void
if_change(u_short ifindex, int flags, struct if_data *ifd)
{
	struct ktable		*kt;
	struct kif_node		*kif;
	struct kif_kr		*kkr;
	struct kif_kr6		*kkr6;
	u_int8_t		 reachable;

	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("%s: interface with index %u not found",
		    __func__, ifindex);
		return;
	}

	kif->k.flags = flags;
	kif->k.link_state = ifd->ifi_link_state;
	kif->k.if_type = ifd->ifi_type;
	kif->k.baudrate = ifd->ifi_baudrate;

	send_imsg_session(IMSG_IFINFO, 0, &kif->k, sizeof(kif->k));

	if ((reachable = kif_validate(&kif->k)) == kif->k.nh_reachable)
		return;		/* nothing changed wrt nexthop validity */

	kif->k.nh_reachable = reachable;

	kt = ktable_get(/* XXX */ 0);

	LIST_FOREACH(kkr, &kif->kroute_l, entry) {
		if (reachable)
			kkr->kr->r.flags &= ~F_DOWN;
		else
			kkr->kr->r.flags |= F_DOWN;

		if (kt == NULL)
			continue;

		knexthop_track(kt, kkr->kr);
	}
	LIST_FOREACH(kkr6, &kif->kroute6_l, entry) {
		if (reachable)
			kkr6->kr->r.flags &= ~F_DOWN;
		else
			kkr6->kr->r.flags |= F_DOWN;

		if (kt == NULL)
			continue;

		knexthop_track(kt, kkr6->kr);
	}
}

void
if_announce(void *msg)
{
	struct if_announcemsghdr	*ifan;
	struct kif_node			*kif;

	ifan = msg;

	switch (ifan->ifan_what) {
	case IFAN_ARRIVAL:
		if ((kif = calloc(1, sizeof(struct kif_node))) == NULL) {
			log_warn("if_announce");
			return;
		}

		kif->k.ifindex = ifan->ifan_index;
		strlcpy(kif->k.ifname, ifan->ifan_name, sizeof(kif->k.ifname));
		kif_insert(kif);
		break;
	case IFAN_DEPARTURE:
		kif = kif_find(ifan->ifan_index);
		kif_remove(kif);
		break;
	}
}

/*
 * rtsock related functions
 */

int
send_rtmsg(int fd, int action, struct ktable *kt, struct kroute *kroute,
    u_int8_t fib_prio)
{
	struct iovec		iov[7];
	struct rt_msghdr	hdr;
	struct sockaddr_in	prefix;
	struct sockaddr_in	nexthop;
	struct sockaddr_in	mask;
	struct {
		struct sockaddr_dl	dl;
		char			pad[sizeof(long)];
	}			ifp;
	struct sockaddr_mpls	mpls;
	struct sockaddr_rtlabel	label;
	int			iovcnt = 0;

	if (!kt->fib_sync)
		return (0);

	/* initialize header */
	bzero(&hdr, sizeof(hdr));
	hdr.rtm_version = RTM_VERSION;
	hdr.rtm_type = action;
	hdr.rtm_tableid = kt->rtableid;
	hdr.rtm_priority = fib_prio;
	if (kroute->flags & F_BLACKHOLE)
		hdr.rtm_flags |= RTF_BLACKHOLE;
	if (kroute->flags & F_REJECT)
		hdr.rtm_flags |= RTF_REJECT;
	if (action == RTM_CHANGE)	/* reset these flags on change */
		hdr.rtm_fmask = RTF_REJECT|RTF_BLACKHOLE;
	hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	hdr.rtm_msglen = sizeof(hdr);
	/* adjust iovec */
	iov[iovcnt].iov_base = &hdr;
	iov[iovcnt++].iov_len = sizeof(hdr);

	bzero(&prefix, sizeof(prefix));
	prefix.sin_len = sizeof(prefix);
	prefix.sin_family = AF_INET;
	prefix.sin_addr.s_addr = kroute->prefix.s_addr;
	/* adjust header */
	hdr.rtm_addrs |= RTA_DST;
	hdr.rtm_msglen += sizeof(prefix);
	/* adjust iovec */
	iov[iovcnt].iov_base = &prefix;
	iov[iovcnt++].iov_len = sizeof(prefix);

	if (kroute->nexthop.s_addr != 0) {
		bzero(&nexthop, sizeof(nexthop));
		nexthop.sin_len = sizeof(nexthop);
		nexthop.sin_family = AF_INET;
		nexthop.sin_addr.s_addr = kroute->nexthop.s_addr;
		/* adjust header */
		hdr.rtm_flags |= RTF_GATEWAY;
		hdr.rtm_addrs |= RTA_GATEWAY;
		hdr.rtm_msglen += sizeof(nexthop);
		/* adjust iovec */
		iov[iovcnt].iov_base = &nexthop;
		iov[iovcnt++].iov_len = sizeof(nexthop);
	}

	bzero(&mask, sizeof(mask));
	mask.sin_len = sizeof(mask);
	mask.sin_family = AF_INET;
	mask.sin_addr.s_addr = htonl(prefixlen2mask(kroute->prefixlen));
	/* adjust header */
	hdr.rtm_addrs |= RTA_NETMASK;
	hdr.rtm_msglen += sizeof(mask);
	/* adjust iovec */
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = sizeof(mask);

	if (kt->ifindex) {
		bzero(&ifp, sizeof(ifp));
		ifp.dl.sdl_len = sizeof(struct sockaddr_dl);
		ifp.dl.sdl_family = AF_LINK;
		ifp.dl.sdl_index = kt->ifindex;
		/* adjust header */
		hdr.rtm_addrs |= RTA_IFP;
		hdr.rtm_msglen += ROUNDUP(sizeof(struct sockaddr_dl));
		/* adjust iovec */
		iov[iovcnt].iov_base = &ifp;
		iov[iovcnt++].iov_len = ROUNDUP(sizeof(struct sockaddr_dl));
	}

	if (kroute->flags & F_MPLS) {
		bzero(&mpls, sizeof(mpls));
		mpls.smpls_len = sizeof(mpls);
		mpls.smpls_family = AF_MPLS;
		mpls.smpls_label = kroute->mplslabel;
		/* adjust header */
		hdr.rtm_flags |= RTF_MPLS;
		hdr.rtm_mpls = MPLS_OP_PUSH;
		hdr.rtm_addrs |= RTA_SRC;
		hdr.rtm_msglen += sizeof(mpls);
		/* adjust iovec */
		iov[iovcnt].iov_base = &mpls;
		iov[iovcnt++].iov_len = sizeof(mpls);
	}

	if (kroute->labelid) {
		bzero(&label, sizeof(label));
		label.sr_len = sizeof(label);
		strlcpy(label.sr_label, rtlabel_id2name(kroute->labelid),
		    sizeof(label.sr_label));
		/* adjust header */
		hdr.rtm_addrs |= RTA_LABEL;
		hdr.rtm_msglen += sizeof(label);
		/* adjust iovec */
		iov[iovcnt].iov_base = &label;
		iov[iovcnt++].iov_len = sizeof(label);
	}

retry:
	if (writev(fd, iov, iovcnt) == -1) {
		if (errno == ESRCH) {
			if (hdr.rtm_type == RTM_CHANGE) {
				hdr.rtm_type = RTM_ADD;
				goto retry;
			} else if (hdr.rtm_type == RTM_DELETE) {
				log_info("route %s/%u vanished before delete",
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen);
				return (0);
			}
		}
		log_warn("send_rtmsg: action %u, prefix %s/%u", hdr.rtm_type,
		    inet_ntoa(kroute->prefix), kroute->prefixlen);
		return (0);
	}

	return (0);
}

int
send_rt6msg(int fd, int action, struct ktable *kt, struct kroute6 *kroute,
    u_int8_t fib_prio)
{
	struct iovec		iov[5];
	struct rt_msghdr	hdr;
	struct pad {
		struct sockaddr_in6	addr;
		char			pad[sizeof(long)];
	} prefix, nexthop, mask;
	struct sockaddr_rtlabel	label;
	int			iovcnt = 0;

	if (!kt->fib_sync)
		return (0);

	/* initialize header */
	bzero(&hdr, sizeof(hdr));
	hdr.rtm_version = RTM_VERSION;
	hdr.rtm_type = action;
	hdr.rtm_tableid = kt->rtableid;
	hdr.rtm_priority = fib_prio;
	if (kroute->flags & F_BLACKHOLE)
		hdr.rtm_flags |= RTF_BLACKHOLE;
	if (kroute->flags & F_REJECT)
		hdr.rtm_flags |= RTF_REJECT;
	if (action == RTM_CHANGE)	/* reset these flags on change */
		hdr.rtm_fmask = RTF_REJECT|RTF_BLACKHOLE;
	hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	hdr.rtm_msglen = sizeof(hdr);
	/* adjust iovec */
	iov[iovcnt].iov_base = &hdr;
	iov[iovcnt++].iov_len = sizeof(hdr);

	bzero(&prefix, sizeof(prefix));
	prefix.addr.sin6_len = sizeof(struct sockaddr_in6);
	prefix.addr.sin6_family = AF_INET6;
	memcpy(&prefix.addr.sin6_addr, &kroute->prefix,
	    sizeof(struct in6_addr));
	/* XXX scope does not matter or? */
	/* adjust header */
	hdr.rtm_addrs |= RTA_DST;
	hdr.rtm_msglen += ROUNDUP(sizeof(struct sockaddr_in6));
	/* adjust iovec */
	iov[iovcnt].iov_base = &prefix;
	iov[iovcnt++].iov_len = ROUNDUP(sizeof(struct sockaddr_in6));

	if (memcmp(&kroute->nexthop, &in6addr_any, sizeof(struct in6_addr))) {
		bzero(&nexthop, sizeof(nexthop));
		nexthop.addr.sin6_len = sizeof(struct sockaddr_in6);
		nexthop.addr.sin6_family = AF_INET6;
		memcpy(&nexthop.addr.sin6_addr, &kroute->nexthop,
		    sizeof(struct in6_addr));
		/* adjust header */
		hdr.rtm_flags |= RTF_GATEWAY;
		hdr.rtm_addrs |= RTA_GATEWAY;
		hdr.rtm_msglen += ROUNDUP(sizeof(struct sockaddr_in6));
		/* adjust iovec */
		iov[iovcnt].iov_base = &nexthop;
		iov[iovcnt++].iov_len = ROUNDUP(sizeof(struct sockaddr_in6));
	}

	bzero(&mask, sizeof(mask));
	mask.addr.sin6_len = sizeof(struct sockaddr_in6);
	mask.addr.sin6_family = AF_INET6;
	memcpy(&mask.addr.sin6_addr, prefixlen2mask6(kroute->prefixlen),
	    sizeof(struct in6_addr));
	/* adjust header */
	hdr.rtm_addrs |= RTA_NETMASK;
	hdr.rtm_msglen += ROUNDUP(sizeof(struct sockaddr_in6));
	/* adjust iovec */
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = ROUNDUP(sizeof(struct sockaddr_in6));

	if (kroute->labelid) {
		bzero(&label, sizeof(label));
		label.sr_len = sizeof(label);
		strlcpy(label.sr_label, rtlabel_id2name(kroute->labelid),
		    sizeof(label.sr_label));
		/* adjust header */
		hdr.rtm_addrs |= RTA_LABEL;
		hdr.rtm_msglen += sizeof(label);
		/* adjust iovec */
		iov[iovcnt].iov_base = &label;
		iov[iovcnt++].iov_len = sizeof(label);
	}

retry:
	if (writev(fd, iov, iovcnt) == -1) {
		if (errno == ESRCH) {
			if (hdr.rtm_type == RTM_CHANGE) {
				hdr.rtm_type = RTM_ADD;
				goto retry;
			} else if (hdr.rtm_type == RTM_DELETE) {
				log_info("route %s/%u vanished before delete",
				    log_in6addr(&kroute->prefix),
				    kroute->prefixlen);
				return (0);
			}
		}
		log_warn("send_rt6msg: action %u, prefix %s/%u", hdr.rtm_type,
		    log_in6addr(&kroute->prefix), kroute->prefixlen);
		return (0);
	}

	return (0);
}

int
fetchtable(struct ktable *kt, u_int8_t fib_prio)
{
	size_t			 len;
	int			 mib[7];
	char			*buf = NULL, *next, *lim;
	struct rt_msghdr	*rtm;
	struct sockaddr		*sa, *gw, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct sockaddr_in6	*sa_in6;
	struct sockaddr_rtlabel	*label;
	struct kroute_node	*kr = NULL;
	struct kroute6_node	*kr6 = NULL;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
	mib[6] = kt->rtableid;

	if (sysctl(mib, 7, NULL, &len, NULL, 0) == -1) {
		if (kt->rtableid != 0 && errno == EINVAL)
			/* table nonexistent */
			return (0);
		log_warn("sysctl");
		return (-1);
	}
	if (len > 0) {
		if ((buf = malloc(len)) == NULL) {
			log_warn("fetchtable");
			return (-1);
		}
		if (sysctl(mib, 7, buf, &len, NULL, 0) == -1) {
			log_warn("sysctl2");
			free(buf);
			return (-1);
		}
	}

	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		if ((sa = rti_info[RTAX_DST]) == NULL)
			continue;

		/* Skip ARP/ND cache and broadcast routes. */
		if (rtm->rtm_flags & (RTF_LLINFO|RTF_BROADCAST))
			continue;

		switch (sa->sa_family) {
		case AF_INET:
			if ((kr = calloc(1, sizeof(struct kroute_node))) ==
			    NULL) {
				log_warn("fetchtable");
				free(buf);
				return (-1);
			}

			kr->r.flags = F_KERNEL;
			kr->r.priority = rtm->rtm_priority;
			kr->r.ifindex = rtm->rtm_index;
			kr->r.prefix.s_addr =
			    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
			sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
			if (rtm->rtm_flags & RTF_STATIC)
				kr->r.flags |= F_STATIC;
			if (rtm->rtm_flags & RTF_BLACKHOLE)
				kr->r.flags |= F_BLACKHOLE;
			if (rtm->rtm_flags & RTF_REJECT)
				kr->r.flags |= F_REJECT;
			if (rtm->rtm_flags & RTF_DYNAMIC)
				kr->r.flags |= F_DYNAMIC;
			if (sa_in != NULL) {
				if (sa_in->sin_len == 0)
					break;
				kr->r.prefixlen =
				    mask2prefixlen(sa_in->sin_addr.s_addr);
			} else if (rtm->rtm_flags & RTF_HOST)
				kr->r.prefixlen = 32;
			else
				kr->r.prefixlen =
				    prefixlen_classful(kr->r.prefix.s_addr);
			rtlabel_unref(kr->r.labelid);
			kr->r.labelid = 0;
			if ((label = (struct sockaddr_rtlabel *)
			    rti_info[RTAX_LABEL]) != NULL) {
				kr->r.flags |= F_RTLABEL;
				kr->r.labelid =
				    rtlabel_name2id(label->sr_label);
			}
			break;
		case AF_INET6:
			if ((kr6 = calloc(1, sizeof(struct kroute6_node))) ==
			    NULL) {
				log_warn("fetchtable");
				free(buf);
				return (-1);
			}

			kr6->r.flags = F_KERNEL;
			kr6->r.priority = rtm->rtm_priority;
			kr6->r.ifindex = rtm->rtm_index;
			memcpy(&kr6->r.prefix,
			    &((struct sockaddr_in6 *)sa)->sin6_addr,
			    sizeof(kr6->r.prefix));

			sa_in6 = (struct sockaddr_in6 *)rti_info[RTAX_NETMASK];
			if (rtm->rtm_flags & RTF_STATIC)
				kr6->r.flags |= F_STATIC;
			if (rtm->rtm_flags & RTF_BLACKHOLE)
				kr6->r.flags |= F_BLACKHOLE;
			if (rtm->rtm_flags & RTF_REJECT)
				kr6->r.flags |= F_REJECT;
			if (rtm->rtm_flags & RTF_DYNAMIC)
				kr6->r.flags |= F_DYNAMIC;
			if (sa_in6 != NULL) {
				if (sa_in6->sin6_len == 0)
					break;
				kr6->r.prefixlen = mask2prefixlen6(sa_in6);
			} else if (rtm->rtm_flags & RTF_HOST)
				kr6->r.prefixlen = 128;
			else
				fatalx("INET6 route without netmask");
			rtlabel_unref(kr6->r.labelid);
			kr6->r.labelid = 0;
			if ((label = (struct sockaddr_rtlabel *)
			    rti_info[RTAX_LABEL]) != NULL) {
				kr6->r.flags |= F_RTLABEL;
				kr6->r.labelid =
				    rtlabel_name2id(label->sr_label);
			}
			break;
		default:
			continue;
		}

		if ((gw = rti_info[RTAX_GATEWAY]) != NULL)
			switch (gw->sa_family) {
			case AF_INET:
				if (kr == NULL)
					fatalx("v4 gateway for !v4 dst?!");

				if (rtm->rtm_flags & RTF_CONNECTED) {
					kr->r.flags |= F_CONNECTED;
					break;
				}

				kr->r.nexthop.s_addr =
				    ((struct sockaddr_in *)gw)->sin_addr.s_addr;
				break;
			case AF_INET6:
				if (kr6 == NULL)
					fatalx("v6 gateway for !v6 dst?!");

				if (rtm->rtm_flags & RTF_CONNECTED) {
					kr6->r.flags |= F_CONNECTED;
					break;
				}

				memcpy(&kr6->r.nexthop,
				    &((struct sockaddr_in6 *)gw)->sin6_addr,
				    sizeof(kr6->r.nexthop));
				break;
			case AF_LINK:
				/*
				 * Traditional BSD connected routes have
				 * a gateway of type AF_LINK.
				 */
				if (sa->sa_family == AF_INET)
					kr->r.flags |= F_CONNECTED;
				else if (sa->sa_family == AF_INET6)
					kr6->r.flags |= F_CONNECTED;
				break;
			}

		if (sa->sa_family == AF_INET) {
			if (rtm->rtm_priority == fib_prio)  {
				send_rtmsg(kr_state.fd, RTM_DELETE, kt, &kr->r,
				    fib_prio);
				free(kr);
			} else
				kroute_insert(kt, kr);
		} else if (sa->sa_family == AF_INET6) {
			if (rtm->rtm_priority == fib_prio)  {
				send_rt6msg(kr_state.fd, RTM_DELETE, kt,
				    &kr6->r, fib_prio);
				free(kr6);
			} else
				kroute6_insert(kt, kr6);
		}
	}
	free(buf);
	return (0);
}

int
fetchifs(int ifindex)
{
	size_t			 len;
	int			 mib[6];
	char			*buf, *next, *lim;
	struct if_msghdr	 ifm;
	struct kif_node		*kif;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_dl	*sdl;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;	/* AF does not matter but AF_INET is shorter */
	mib[4] = NET_RT_IFLIST;
	mib[5] = ifindex;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchif");
		return (-1);
	}
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	lim = buf + len;
	for (next = buf; next < lim; next += ifm.ifm_msglen) {
		memcpy(&ifm, next, sizeof(ifm));
		if (ifm.ifm_version != RTM_VERSION)
			continue;
		if (ifm.ifm_type != RTM_IFINFO)
			continue;

		sa = (struct sockaddr *)(next + sizeof(ifm));
		get_rtaddrs(ifm.ifm_addrs, sa, rti_info);

		if ((kif = calloc(1, sizeof(struct kif_node))) == NULL) {
			log_warn("fetchifs");
			free(buf);
			return (-1);
		}

		kif->k.ifindex = ifm.ifm_index;
		kif->k.flags = ifm.ifm_flags;
		kif->k.link_state = ifm.ifm_data.ifi_link_state;
		kif->k.if_type = ifm.ifm_data.ifi_type;
		kif->k.baudrate = ifm.ifm_data.ifi_baudrate;
		kif->k.nh_reachable = kif_validate(&kif->k);

		if ((sa = rti_info[RTAX_IFP]) != NULL)
			if (sa->sa_family == AF_LINK) {
				sdl = (struct sockaddr_dl *)sa;
				if (sdl->sdl_nlen >= sizeof(kif->k.ifname))
					memcpy(kif->k.ifname, sdl->sdl_data,
					    sizeof(kif->k.ifname) - 1);
				else if (sdl->sdl_nlen > 0)
					memcpy(kif->k.ifname, sdl->sdl_data,
					    sdl->sdl_nlen);
				/* string already terminated via calloc() */
			}

		kif_insert(kif);
	}
	free(buf);
	return (0);
}

int
dispatch_rtmsg(void)
{
	char			 buf[RT_BUF_SIZE];
	ssize_t			 n;
	char			*next, *lim;
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct ktable		*kt;

	if ((n = read(kr_state.fd, &buf, sizeof(buf))) == -1) {
		if (errno == EAGAIN || errno == EINTR)
			return (0);
		log_warn("dispatch_rtmsg: read error");
		return (-1);
	}

	if (n == 0) {
		log_warnx("routing socket closed");
		return (-1);
	}

	lim = buf + n;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (lim < next + sizeof(u_short) ||
		    lim < next + rtm->rtm_msglen)
			fatalx("dispatch_rtmsg: partial rtm in buffer");
		if (rtm->rtm_version != RTM_VERSION)
			continue;

		switch (rtm->rtm_type) {
		case RTM_ADD:
		case RTM_CHANGE:
		case RTM_DELETE:
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

			if (rtm->rtm_pid == kr_state.pid) /* cause by us */
				continue;

			if (rtm->rtm_errno)		 /* failed attempts */
				continue;

			if (rtm->rtm_flags & RTF_LLINFO) /* arp cache */
				continue;

			if ((kt = ktable_get(rtm->rtm_tableid)) == NULL)
				continue;

			if (dispatch_rtmsg_addr(rtm, rti_info, kt) == -1)
				return (-1);
			break;
		case RTM_IFINFO:
			memcpy(&ifm, next, sizeof(ifm));
			if_change(ifm.ifm_index, ifm.ifm_flags,
			    &ifm.ifm_data);
			break;
		case RTM_IFANNOUNCE:
			if_announce(next);
			break;
		default:
			/* ignore for now */
			break;
		}
	}
	return (0);
}

int
dispatch_rtmsg_addr(struct rt_msghdr *rtm, struct sockaddr *rti_info[RTAX_MAX],
    struct ktable *kt)
{
	struct sockaddr		*sa;
	struct sockaddr_in	*sa_in;
	struct sockaddr_in6	*sa_in6;
	struct kroute_node	*kr;
	struct kroute6_node	*kr6;
	struct bgpd_addr	 prefix;
	int			 flags, oflags, mpath = 0, changed = 0;
	u_int16_t		 ifindex;
	u_int8_t		 prefixlen;
	u_int8_t		 prio;

	flags = F_KERNEL;
	ifindex = 0;
	prefixlen = 0;
	bzero(&prefix, sizeof(prefix));

	if ((sa = rti_info[RTAX_DST]) == NULL) {
		log_warnx("empty route message");
		return (0);
	}

	if (rtm->rtm_flags & RTF_STATIC)
		flags |= F_STATIC;
	if (rtm->rtm_flags & RTF_BLACKHOLE)
		flags |= F_BLACKHOLE;
	if (rtm->rtm_flags & RTF_REJECT)
		flags |= F_REJECT;
	if (rtm->rtm_flags & RTF_DYNAMIC)
		flags |= F_DYNAMIC;
#ifdef RTF_MPATH
	if (rtm->rtm_flags & RTF_MPATH)
		mpath = 1;
#endif

	prio = rtm->rtm_priority;
	switch (sa->sa_family) {
	case AF_INET:
		prefix.aid = AID_INET;
		prefix.v4.s_addr = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
		sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
		if (sa_in != NULL) {
			if (sa_in->sin_len != 0)
				prefixlen = mask2prefixlen(
				    sa_in->sin_addr.s_addr);
		} else if (rtm->rtm_flags & RTF_HOST)
			prefixlen = 32;
		else
			prefixlen =
			    prefixlen_classful(prefix.v4.s_addr);
		break;
	case AF_INET6:
		prefix.aid = AID_INET6;
		memcpy(&prefix.v6, &((struct sockaddr_in6 *)sa)->sin6_addr,
		    sizeof(struct in6_addr));
		sa_in6 = (struct sockaddr_in6 *)rti_info[RTAX_NETMASK];
		if (sa_in6 != NULL) {
			if (sa_in6->sin6_len != 0)
				prefixlen = mask2prefixlen6(sa_in6);
		} else if (rtm->rtm_flags & RTF_HOST)
			prefixlen = 128;
		else
			fatalx("in6 net addr without netmask");
		break;
	default:
		return (0);
	}

	if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
		switch (sa->sa_family) {
		case AF_LINK:
			flags |= F_CONNECTED;
			ifindex = rtm->rtm_index;
			sa = NULL;
			mpath = 0;	/* link local stuff can't be mpath */
			break;
		case AF_INET:
		case AF_INET6:
			if (rtm->rtm_flags & RTF_CONNECTED) {
				flags |= F_CONNECTED;
				ifindex = rtm->rtm_index;
				sa = NULL;
				mpath = 0; /* link local stuff can't be mpath */
			}
			break;
		}

	if (rtm->rtm_type == RTM_DELETE) {
		switch (prefix.aid) {
		case AID_INET:
			sa_in = (struct sockaddr_in *)sa;
			if ((kr = kroute_find(kt, prefix.v4.s_addr,
			    prefixlen, prio)) == NULL)
				return (0);
			if (!(kr->r.flags & F_KERNEL))
				return (0);

			if (mpath)
				/* get the correct route */
				if ((kr = kroute_matchgw(kr, sa_in)) == NULL) {
					log_warnx("dispatch_rtmsg_addr[delete] "
					    "mpath route not found");
					return (0);
				}

			if (kroute_remove(kt, kr) == -1)
				return (-1);
			break;
		case AID_INET6:
			sa_in6 = (struct sockaddr_in6 *)sa;
			if ((kr6 = kroute6_find(kt, &prefix.v6, prefixlen,
			    prio)) == NULL)
				return (0);
			if (!(kr6->r.flags & F_KERNEL))
				return (0);

			if (mpath)
				/* get the correct route */
				if ((kr6 = kroute6_matchgw(kr6, sa_in6)) ==
				    NULL) {
					log_warnx("dispatch_rtmsg_addr[delete] "
					    "IPv6 mpath route not found");
					return (0);
				}

			if (kroute6_remove(kt, kr6) == -1)
				return (-1);
			break;
		}
		return (0);
	}

	if (sa == NULL && !(flags & F_CONNECTED)) {
		log_warnx("%s: no nexthop for %s/%u",
		    __func__, log_addr(&prefix), prefixlen);
		return (0);
	}

	switch (prefix.aid) {
	case AID_INET:
		sa_in = (struct sockaddr_in *)sa;
		if ((kr = kroute_find(kt, prefix.v4.s_addr, prefixlen,
		    prio)) != NULL) {
			if (kr->r.flags & F_KERNEL) {
				/* get the correct route */
				if (mpath && rtm->rtm_type == RTM_CHANGE &&
				    (kr = kroute_matchgw(kr, sa_in)) == NULL) {
					log_warnx("dispatch_rtmsg_addr[change] "
					    "mpath route not found");
					goto add4;
				} else if (mpath && rtm->rtm_type == RTM_ADD)
					goto add4;

				if (sa_in != NULL) {
					if (kr->r.nexthop.s_addr !=
					    sa_in->sin_addr.s_addr)
						changed = 1;
					kr->r.nexthop.s_addr =
					    sa_in->sin_addr.s_addr;
				} else {
					if (kr->r.nexthop.s_addr != 0)
						changed = 1;
					kr->r.nexthop.s_addr = 0;
				}

				if (kr->r.flags & F_NEXTHOP)
					flags |= F_NEXTHOP;
				oflags = kr->r.flags;
				if (flags != oflags)
					changed = 1;
				kr->r.flags = flags;
				if ((oflags & F_CONNECTED) &&
				    !(flags & F_CONNECTED)) {
					kif_kr_remove(kr);
					kr_redistribute(IMSG_NETWORK_REMOVE,
					    kt, &kr->r);
				}
				if ((flags & F_CONNECTED) &&
				    !(oflags & F_CONNECTED)) {
					kif_kr_insert(kr);
					kr_redistribute(IMSG_NETWORK_ADD,
					    kt, &kr->r);
				}
				if (kr->r.flags & F_NEXTHOP && changed)
					knexthop_track(kt, kr);
			}
		} else if (rtm->rtm_type == RTM_CHANGE) {
			log_warnx("change req for %s/%u: not in table",
			    log_addr(&prefix), prefixlen);
			return (0);
		} else {
add4:
			if ((kr = calloc(1,
			    sizeof(struct kroute_node))) == NULL) {
				log_warn("dispatch_rtmsg");
				return (-1);
			}
			kr->r.prefix.s_addr = prefix.v4.s_addr;
			kr->r.prefixlen = prefixlen;
			if (sa_in != NULL)
				kr->r.nexthop.s_addr = sa_in->sin_addr.s_addr;
			else
				kr->r.nexthop.s_addr = 0;
			kr->r.flags = flags;
			kr->r.ifindex = ifindex;
			kr->r.priority = prio;

			kroute_insert(kt, kr);
		}
		break;
	case AID_INET6:
		sa_in6 = (struct sockaddr_in6 *)sa;
		if ((kr6 = kroute6_find(kt, &prefix.v6, prefixlen, prio)) !=
		    NULL) {
			if (kr6->r.flags & F_KERNEL) {
				/* get the correct route */
				if (mpath && rtm->rtm_type == RTM_CHANGE &&
				    (kr6 = kroute6_matchgw(kr6, sa_in6)) ==
				    NULL) {
					log_warnx("dispatch_rtmsg[change] "
					    "IPv6 mpath route not found");
					goto add6;
				} else if (mpath && rtm->rtm_type == RTM_ADD)
					goto add6;

				if (sa_in6 != NULL) {
					if (memcmp(&kr6->r.nexthop,
					    &sa_in6->sin6_addr,
					    sizeof(struct in6_addr)))
						changed = 1;
					memcpy(&kr6->r.nexthop,
					    &sa_in6->sin6_addr,
					    sizeof(struct in6_addr));
				} else {
					if (memcmp(&kr6->r.nexthop,
					    &in6addr_any,
					    sizeof(struct in6_addr)))
						changed = 1;
					memcpy(&kr6->r.nexthop,
					    &in6addr_any,
					    sizeof(struct in6_addr));
				}

				if (kr6->r.flags & F_NEXTHOP)
					flags |= F_NEXTHOP;
				oflags = kr6->r.flags;
				if (flags != oflags)
					changed = 1;
				kr6->r.flags = flags;
				if ((oflags & F_CONNECTED) &&
				    !(flags & F_CONNECTED)) {
					kif_kr6_remove(kr6);
					kr_redistribute6(IMSG_NETWORK_REMOVE,
					    kt, &kr6->r);
				}
				if ((flags & F_CONNECTED) &&
				    !(oflags & F_CONNECTED)) {
					kif_kr6_insert(kr6);
					kr_redistribute6(IMSG_NETWORK_ADD,
					    kt, &kr6->r);
				}
				if (kr6->r.flags & F_NEXTHOP && changed)
					knexthop_track(kt, kr6);
			}
		} else if (rtm->rtm_type == RTM_CHANGE) {
			log_warnx("change req for %s/%u: not in table",
			    log_addr(&prefix), prefixlen);
			return (0);
		} else {
add6:
			if ((kr6 = calloc(1,
			    sizeof(struct kroute6_node))) == NULL) {
				log_warn("dispatch_rtmsg_addr");
				return (-1);
			}
			memcpy(&kr6->r.prefix, &prefix.v6,
			    sizeof(struct in6_addr));
			kr6->r.prefixlen = prefixlen;
			if (sa_in6 != NULL)
				memcpy(&kr6->r.nexthop, &sa_in6->sin6_addr,
				    sizeof(struct in6_addr));
			else
				memcpy(&kr6->r.nexthop, &in6addr_any,
				    sizeof(struct in6_addr));
			kr6->r.flags = flags;
			kr6->r.ifindex = ifindex;
			kr6->r.priority = prio;

			kroute6_insert(kt, kr6);
		}
		break;
	}

	return (0);
}
@


1.211
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.210 2016/10/05 07:38:06 phessler Exp $ */
d2203 1
a2203 2
		if ((n.gateway.v4.s_addr =
		    kr->r.nexthop.s_addr) != 0)
d2205 2
d2225 1
a2225 1
			memcpy(&n.net.v6, &kr6->r.nexthop,
@


1.210
log
@Let bgpd announce routes based on a route-label.

OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.209 2016/04/08 12:27:05 phessler Exp $ */
d39 1
@


1.209
log
@When bgp receives an RTM_CHANGE message for an RTF_MPATH route[1], and
it finds it actually on an interface, bgpd can get confused.  In this
case, just log it and treat it as an RTM_ADD so bgpd doesn't suicide.

[1] includes all ospfd installed routes, btw.

OK benno@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.208 2016/03/22 15:53:00 claudio Exp $ */
d1114 4
d1150 4
d1280 1
d1349 1
d1405 1
d1426 1
d2795 1
d2874 8
d2915 8
@


1.208
log
@Connected routes are no longer identified by a AF_LINK gateway so adjust
dispatch_rtmsg_addr() similar to the way fetchtable() was fixed long ago.
This should fix various issues with bad gateways being picked up by bgpd.
Problem identified and initial fix provided by phessler@@ but commiting
my version which is more conservative. OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.207 2015/12/05 18:28:04 benno Exp $ */
d3254 1
a3254 1
					return (-1);
d3326 1
a3326 1
					return (-1);
@


1.207
log
@cleanup some log messages with wrong function names etc.
ok henning,claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.206 2015/10/22 11:13:16 phessler Exp $ */
d3180 9
@


1.207.2.1
log
@MFC

revision 1.208
Connected routes are no longer identified by a AF_LINK gateway so adjust
dispatch_rtmsg_addr() similar to the way fetchtable() was fixed long ago.
This should fix various issues with bad gateways being picked up by bgpd.
Problem identified and initial fix provided by phessler@@ but commiting
my version which is more conservative. OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.207 2015/12/05 18:28:04 benno Exp $ */
a3179 9
			break;
		case AF_INET:
		case AF_INET6:
			if (rtm->rtm_flags & RTF_CONNECTED) {
				flags |= F_CONNECTED;
				ifindex = rtm->rtm_index;
				sa = NULL;
				mpath = 0; /* link local stuff can't be mpath */
			}
@


1.207.2.2
log
@MFC

revision 1.209 by phessler@@

When bgp receives an RTM_CHANGE message for an RTF_MPATH route[1], and
it finds it actually on an interface, bgpd can get confused.  In this
case, just log it and treat it as an RTM_ADD so bgpd doesn't suicide.

[1] includes all ospfd installed routes, btw.

OK benno@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.209 2016/04/08 12:27:05 phessler Exp $ */
d3254 1
a3254 1
					goto add4;
d3326 1
a3326 1
					goto add6;
@


1.206
log
@If we receive an empty route message, log it and ignore it.  Happens
occasionally on FreeBSD.

from Melissa Jenkins

OK claudio@@, florian@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.205 2015/09/16 20:25:41 stsp Exp $ */
d407 1
a407 1
	struct ktable 	*kt;
d420 1
a420 1
	struct ktable 	*kt;
d633 1
a633 1
			log_warn("kr_change");
d686 1
a686 1
	log_warnx("kr_change: not handled AID");
d1835 2
a1836 2
		log_warnx("knexthop_tree insert failed for %s",
			    log_addr(&kn->nexthop));
d1946 2
a1947 2
			log_warnx("interface with index %u not found",
			    kr->r.ifindex);
d1976 2
a1977 2
			log_warnx("interface with index %u not found",
			    kr->r.ifindex);
d2005 2
a2006 2
			log_warnx("interface with index %u not found",
			    kr->r.ifindex);
d2035 2
a2036 2
			log_warnx("interface with index %u not found",
			    kr->r.ifindex);
d2088 2
a2089 2
			log_warnx("interface with index %d not found, "
			    "referenced from route for %s/%u",
d2108 2
a2109 2
			log_warnx("interface with index %d not found, "
			    "referenced from route for %s/%u",
d2456 2
a2457 2
		log_warnx("interface with index %u not found",
		    ifindex);
d3196 1
a3196 1
					log_warnx("dispatch_rtmsg[delete] "
d3216 1
a3216 1
					log_warnx("dispatch_rtmsg[delete] "
d3229 2
a3230 2
		log_warnx("dispatch_rtmsg no nexthop for %s/%u",
		    log_addr(&prefix), prefixlen);
d3243 1
a3243 1
					log_warnx("dispatch_rtmsg[change] "
d3368 1
a3368 1
				log_warn("dispatch_rtmsg");
@


1.205
log
@Another ifmedia64 fix, this time for bgpd's ift2ifm().
And rename struct kif's media_type to if_type to avoid confusion with
ifmedia's media type. Same rename in other daemons will follow.
ok claudio henning benno
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.204 2015/07/17 20:03:54 claudio Exp $ */
d3122 4
a3125 2
	if ((sa = rti_info[RTAX_DST]) == NULL)
		return (-1);
@


1.204
log
@Only filter RTF_LLINFO or RTF_BROADCAST routes out but not RTF_LOCAL ones
since we need those for loopback and point-to-point interfaces.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.203 2015/07/08 08:03:46 mpi Exp $ */
d2463 1
a2463 1
	kif->k.media_type = ifd->ifi_type;
d3010 1
a3010 1
		kif->k.media_type = ifm.ifm_data.ifi_type;
@


1.204.4.1
log
@MFC

revision 1.208 by claudio@@
Connected routes are no longer identified by a AF_LINK gateway so adjust
dispatch_rtmsg_addr() similar to the way fetchtable() was fixed long ago.
This should fix various issues with bad gateways being picked up by bgpd.
Problem identified and initial fix provided by phessler@@ but commiting
my version which is more conservative. OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.204 2015/07/17 20:03:54 claudio Exp $ */
a3177 9
			break;
		case AF_INET:
		case AF_INET6:
			if (rtm->rtm_flags & RTF_CONNECTED) {
				flags |= F_CONNECTED;
				ifindex = rtm->rtm_index;
				sa = NULL;
				mpath = 0; /* link local stuff can't be mpath */
			}
@


1.204.4.2
log
@MFC

revision 1.209 by phessler@@

When bgp receives an RTM_CHANGE message for an RTF_MPATH route[1], and
it finds it actually on an interface, bgpd can get confused.  In this
case, just log it and treat it as an RTM_ADD so bgpd doesn't suicide.

[1] includes all ospfd installed routes, btw.

OK benno@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.204.4.1 2016/03/23 13:43:08 phessler Exp $ */
d3252 1
a3252 1
					goto add4;
d3324 1
a3324 1
					goto add6;
@


1.203
log
@Check for RTF_CONNECTED to track interface (connected) routes.

Make bgpd(8) properly handle interface routes since they no
longer have a "gateway" sockaddr of type AF_LINK.  Regression
reported by <mxb AT alumni DOT chalmers DOT se> and benno@@

While here document traditional BSD connected route assumption.

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.202 2015/02/11 05:48:53 claudio Exp $ */
d2824 2
a2825 2
		/* Skip ARP/ND cache and local routes. */
		if (rtm->rtm_flags & (RTF_LLINFO|RTF_LOCAL|RTF_BROADCAST))
@


1.202
log
@Use sizeof(u_short) in the first check since there are RT messages that
are less then sizeof(*rtm) bytes long (e.g. interface announcements).
Found the hard way by phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.201 2015/02/10 05:18:39 claudio Exp $ */
d2824 2
a2825 1
		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
d2904 6
d2916 6
d2927 4
@


1.201
log
@Make also the special sockets SOCK_NONBLOCK. For the routing socket add
a trigger for the case that not a full message has been read. Should not
be possible but lets see if this triggers somewhen.
With and OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.200 2015/02/09 11:37:31 claudio Exp $ */
d3041 1
a3041 1
		if (lim < next + sizeof(*rtm) ||
@


1.200
log
@Kill session_socket_blockmode() and replace it with SOCK_CLOEXEC or
SOCK_NONBLOCK and accept4(). OK henning@@ tested & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.199 2014/10/08 16:15:37 deraadt Exp $ */
d202 2
a203 2
	if ((kr_state.fd = socket(AF_ROUTE, SOCK_RAW | SOCK_CLOEXEC,
	    0)) == -1) {
d3027 2
d3041 3
@


1.199
log
@Use reallocarray() throughout to spot multiplicative int overflow.
ok henning benno
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.198 2014/06/23 03:46:17 guenther Exp $ */
d202 2
a203 1
	if ((kr_state.fd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1) {
@


1.198
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.197 2014/01/23 23:26:56 benno Exp $ */
d248 1
a248 1
	size_t		  newsize, oldsize;
d253 2
a254 2
		newsize = sizeof(struct ktable *) * (rtableid + 1);
		if ((xkrt = realloc(krt, newsize)) == NULL) {
d260 2
a261 1
		bzero((char *)krt + oldsize, newsize - oldsize);
@


1.197
log
@allow the somewhat special case
  match ... set nexthop ( 127.0.0.1 | ::1 )
  match ... set nexthop blackhole
to make a route valid before setting the blackhole flag on it.
ok florian, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.196 2013/11/13 09:14:48 florian Exp $ */
d439 1
a439 1
	mib[1] = AF_ROUTE;
d2785 1
a2785 1
	mib[1] = AF_ROUTE;
d2951 1
a2951 1
	mib[1] = AF_ROUTE;
@


1.196
log
@Knob to set priority with which bgpd inserts routes into the kernel
routing table. Need for it in "special" setups pointed out by
Loic Blot (loic.blot _AT_ unix-experience _DOT_ fr) on tech.
OK benno, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.195 2013/05/22 21:00:36 sthen Exp $ */
d490 3
d494 1
a494 1
	if ((kl->nexthop.v4.s_addr & htonl(IN_CLASSA_NET)) ==
a499 4
	/* for blackhole and reject routes nexthop needs to be 127.0.0.1 */
	if (kl->flags & (F_BLACKHOLE|F_REJECT))
		kl->nexthop.v4.s_addr = htonl(INADDR_LOOPBACK);

d548 3
d552 1
a552 1
	if (IN6_IS_ADDR_LOOPBACK(&kl->nexthop.v6))
a555 4

	/* for blackhole and reject routes nexthop needs to be ::1 */
	if (kl->flags & (F_BLACKHOLE|F_REJECT))
		bcopy(&lo6, &kl->nexthop.v6, sizeof(kl->nexthop.v6));
@


1.195
log
@Set the correct route priority in send_rt6msg, as done for send_rtmsg.
Fixes v6 routes being added to the kernel as RTP_DEFAULT.  ok florian@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.194 2013/05/22 20:39:12 sthen Exp $ */
d87 3
a89 3
int	ktable_new(u_int, u_int, char *, char *, int);
void	ktable_free(u_int);
void	ktable_destroy(struct ktable *);
d92 6
a97 6
int	kr4_change(struct ktable *, struct kroute_full *);
int	kr6_change(struct ktable *, struct kroute_full *);
int	krVPN4_change(struct ktable *, struct kroute_full *);
int	kr4_delete(struct ktable *, struct kroute_full *);
int	kr6_delete(struct ktable *, struct kroute_full *);
int	krVPN4_delete(struct ktable *, struct kroute_full *);
d110 1
d166 4
a169 2
int		send_rtmsg(int, int, struct ktable *, struct kroute *);
int		send_rt6msg(int, int, struct ktable *, struct kroute6 *);
d171 1
a171 1
int		fetchtable(struct ktable *);
d243 2
a244 1
ktable_new(u_int rtableid, u_int rdomid, char *name, char *ifname, int fs)
d290 1
a290 1
	if (fetchtable(kt) == -1)
d302 1
a302 1
ktable_free(u_int rtableid)
d310 1
a310 1
	kr_fib_decouple(kt->rtableid);
d324 1
a324 1
		ktable_destroy(nkt);
d326 1
a326 1
		ktable_destroy(kt);
d330 1
a330 1
ktable_destroy(struct ktable *kt)
d333 1
a333 1
	kr_fib_decouple(kt->rtableid);
d353 2
a354 1
ktable_update(u_int rtableid, char *name, char *ifname, int flags)
d367 1
a367 1
			if (ktable_new(rdomid, rdomid, buf, NULL, 0))
d387 1
a387 1
		    !(flags & F_RIB_NOFIBSYNC)))
d416 1
a416 1
ktable_postload(void)
d425 1
a425 1
			ktable_free(i - 1);
d460 1
a460 1
kr_change(u_int rtableid, struct kroute_full *kl)
d469 1
a469 1
		return (kr4_change(kt, kl));
d471 1
a471 1
		return (kr6_change(kt, kl));
d473 1
a473 1
		return (krVPN4_change(kt, kl));
d480 1
a480 1
kr4_change(struct ktable *kt, struct kroute_full *kl)
d487 1
a487 1
	    RTP_BGP)) != NULL)
d510 1
a510 1
		kr->r.priority = RTP_BGP;
d531 1
a531 1
	if (send_rtmsg(kr_state.fd, action, kt, &kr->r) == -1)
d538 1
a538 1
kr6_change(struct ktable *kt, struct kroute_full *kl)
d545 1
a545 1
	if ((kr6 = kroute6_find(kt, &kl->prefix.v6, kl->prefixlen, RTP_BGP)) !=
d569 1
a569 1
		kr6->r.priority = RTP_BGP;
d591 1
a591 1
	if (send_rt6msg(kr_state.fd, action, kt, &kr6->r) == -1)
d598 1
a598 1
krVPN4_change(struct ktable *kt, struct kroute_full *kl)
d606 1
a606 1
	    RTP_BGP)) != NULL)
d640 1
a640 1
		kr->r.priority = RTP_BGP;
d663 1
a663 1
	if (send_rtmsg(kr_state.fd, action, kt, &kr->r) == -1)
d670 1
a670 1
kr_delete(u_int rtableid, struct kroute_full *kl)
d680 1
a680 1
		return (kr4_delete(kt, kl));
d682 1
a682 1
		return (kr6_delete(kt, kl));
d684 1
a684 1
		return (krVPN4_delete(kt, kl));
d691 1
a691 1
kr4_delete(struct ktable *kt, struct kroute_full *kl)
d696 1
a696 1
	    RTP_BGP)) == NULL)
d702 1
a702 1
	if (send_rtmsg(kr_state.fd, RTM_DELETE, kt, &kr->r) == -1)
d714 1
a714 1
kr6_delete(struct ktable *kt, struct kroute_full *kl)
d718 1
a718 1
	if ((kr6 = kroute6_find(kt, &kl->prefix.v6, kl->prefixlen, RTP_BGP)) ==
d725 1
a725 1
	if (send_rt6msg(kr_state.fd, RTM_DELETE, kt, &kr6->r) == -1)
d737 1
a737 1
krVPN4_delete(struct ktable *kt, struct kroute_full *kl)
d742 1
a742 1
	    RTP_BGP)) == NULL)
d748 1
a748 1
	if (send_rtmsg(kr_state.fd, RTM_DELETE, kt, &kr->r) == -1)
d760 1
a760 1
kr_shutdown(void)
d765 1
a765 1
		ktable_free(i - 1);
d770 1
a770 1
kr_fib_couple(u_int rtableid)
d786 1
a786 1
			send_rtmsg(kr_state.fd, RTM_ADD, kt, &kr->r);
d789 2
a790 1
			send_rt6msg(kr_state.fd, RTM_ADD, kt, &kr6->r);
d797 10
a806 1
kr_fib_decouple(u_int rtableid)
d820 2
a821 1
			send_rtmsg(kr_state.fd, RTM_DELETE, kt, &kr->r);
d824 2
a825 1
			send_rt6msg(kr_state.fd, RTM_DELETE, kt, &kr6->r);
d833 37
d2530 2
a2531 1
send_rtmsg(int fd, int action, struct ktable *kt, struct kroute *kroute)
d2554 1
a2554 1
	hdr.rtm_priority = RTP_BGP;
d2666 2
a2667 1
send_rt6msg(int fd, int action, struct ktable *kt, struct kroute6 *kroute)
d2686 1
a2686 1
	hdr.rtm_priority = RTP_BGP;
d2774 1
a2774 1
fetchtable(struct ktable *kt)
d2922 3
a2924 2
			if (rtm->rtm_priority == RTP_BGP)  {
				send_rtmsg(kr_state.fd, RTM_DELETE, kt, &kr->r);
d2929 1
a2929 1
			if (rtm->rtm_priority == RTP_BGP)  {
d2931 1
a2931 1
				    &kr6->r);
@


1.194
log
@whitespace nits
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.193 2013/03/20 04:01:42 deraadt Exp $ */
d2630 1
@


1.193
log
@less includes
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.192 2013/03/14 14:53:52 florian Exp $ */
d1563 1
a1563 1
	       	if (kr->next != NULL) {
d1715 1
a1715 1
	       	if (kr->next != NULL) {
@


1.192
log
@use after free; 33% found by llvm
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.191 2012/11/13 22:07:28 florian Exp $ */
a18 1
#include <sys/param.h>
@


1.191
log
@pasto in log message
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.190 2012/07/13 16:57:35 claudio Exp $ */
d509 1
a509 1
		if (kroute_insert(kt, kr) == -1)
d511 2
d568 1
a568 1
		if (kroute6_insert(kt, kr6) == -1)
d570 2
d640 1
a640 1
		if (kroute_insert(kt, kr) == -1)
d642 2
@


1.190
log
@Cleanup the knexthop mess and make sure we only send an update to the RDE
when there was a change in the nexthop info. Fixes massive memory consumption
crashes when used with ospfd (which sometimes updates route that have not
changed). Tested together with benno@@ and a lot of input from Florian Obser.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.189 2012/05/27 18:52:07 claudio Exp $ */
d3229 1
a3229 1
					    "mpath route not found");
@


1.189
log
@Extend the network code to allow attributes to be passed in with prefixes.
In the end this will allow anyone to use MRT table dumps to load prefixes
into a bgpd instance. For example you can download the RIPE dumps and load
full-feeds onto your laptop until the poor thing dies.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.188 2011/05/01 12:56:04 claudio Exp $ */
d152 1
d829 1
a829 34
		struct kroute_nexthop	 nh;
		struct kroute_node	*k;
		struct kroute6_node	*k6;

		bzero(&nh, sizeof(nh));
		memcpy(&nh.nexthop, addr, sizeof(nh.nexthop));
		nh.valid = 1;
		if (h->kroute != NULL && addr->aid == AID_INET) {
			k = h->kroute;
			nh.connected = k->r.flags & F_CONNECTED;
			if (k->r.nexthop.s_addr != 0) {
				nh.gateway.aid = AID_INET;
				nh.gateway.v4.s_addr =
				    k->r.nexthop.s_addr;
			}
			nh.net.aid = AID_INET;
			nh.net.v4.s_addr = k->r.prefix.s_addr;
			nh.netlen = k->r.prefixlen;
		} else if (h->kroute != NULL && addr->aid == AID_INET6) {
			k6 = h->kroute;
			nh.connected = k6->r.flags & F_CONNECTED;
			if (memcmp(&k6->r.nexthop, &in6addr_any,
			    sizeof(struct in6_addr)) != 0) {
				nh.gateway.aid = AID_INET6;
				memcpy(&nh.gateway.v6, &k6->r.nexthop,
				    sizeof(struct in6_addr));
			}
			nh.net.aid = AID_INET6;
			memcpy(&nh.net.v6, &k6->r.nexthop,
			    sizeof(struct in6_addr));
			nh.netlen = k6->r.prefixlen;
		}

		send_nexthop_update(&nh);
d851 2
a852 1
		log_warnx("kr_nexthop_add: non-existent rtableid %d", rtableid);
d1518 1
d1580 1
a1580 1
	if ((kr->r.flags & F_KERNEL) && (kr->r.flags & F_NEXTHOP))
d1668 1
d1733 1
a1733 1
	if ((kr->r.flags & F_KERNEL) && (kr->r.flags & F_NEXTHOP))
d2062 1
a2064 7
	struct kroute_nexthop	 n;
	int			 was_valid = 0;

	if (kn->nexthop.aid == AID_INET && (kr = kn->kroute) != NULL)
		was_valid = kroute_validate(&kr->r);
	if (kn->nexthop.aid == AID_INET6 && (kr6 = kn->kroute) != NULL)
		was_valid = kroute6_validate(&kr6->r);
d2066 1
a2066 2
	bzero(&n, sizeof(n));
	memcpy(&n.nexthop, &kn->nexthop, sizeof(n.nexthop));
d2071 1
a2071 17
		if ((kr = kroute_match(kt, kn->nexthop.v4.s_addr, 0)) == NULL) {
			if (was_valid)
				send_nexthop_update(&n);
		} else {					/* match */
			if (kroute_validate(&kr->r)) {		/* valid */
				n.valid = 1;
				n.connected = kr->r.flags & F_CONNECTED;
				if ((n.gateway.v4.s_addr =
				    kr->r.nexthop.s_addr) != 0)
					n.gateway.aid = AID_INET;
				n.net.aid = AID_INET;
				n.net.v4.s_addr = kr->r.prefix.s_addr;
				n.netlen = kr->r.prefixlen;
				send_nexthop_update(&n);
			} else					/* down */
				if (was_valid)
					send_nexthop_update(&n);
d2073 1
d2077 8
d2087 1
a2087 21
		if ((kr6 = kroute6_match(kt, &kn->nexthop.v6, 0)) == NULL) {
			if (was_valid)
				send_nexthop_update(&n);
		} else {					/* match */
			if (kroute6_validate(&kr6->r)) {	/* valid */
				n.valid = 1;
				n.connected = kr6->r.flags & F_CONNECTED;
				if (memcmp(&kr6->r.nexthop, &in6addr_any,
				    sizeof(struct in6_addr)) != 0) {
					n.gateway.aid = AID_INET6;
					memcpy(&n.gateway.v6, &kr6->r.nexthop,
					    sizeof(struct in6_addr));
				}
				n.net.aid = AID_INET6;
				memcpy(&n.net.v6, &kr6->r.nexthop,
				    sizeof(struct in6_addr));
				n.netlen = kr6->r.prefixlen;
				send_nexthop_update(&n);
			} else					/* down */
				if (was_valid)
					send_nexthop_update(&n);
d2089 1
d2093 3
d2104 10
a2115 1
	struct kroute_nexthop	 n;
d2117 38
a2154 34
	RB_FOREACH(kn, knexthop_tree, KT2KNT(kt))
		if (kn->kroute == krp) {
			bzero(&n, sizeof(n));
			memcpy(&n.nexthop, &kn->nexthop, sizeof(n.nexthop));

			switch (kn->nexthop.aid) {
			case AID_INET:
				kr = krp;
				n.valid = 1;
				n.connected = kr->r.flags & F_CONNECTED;
				if ((n.gateway.v4.s_addr =
				    kr->r.nexthop.s_addr) != 0)
					n.gateway.aid = AID_INET;
				n.net.aid = AID_INET;
				n.net.v4.s_addr = kr->r.prefix.s_addr;
				n.netlen = kr->r.prefixlen;
				break;
			case AID_INET6:
				kr6 = krp;
				n.valid = 1;
				n.connected = kr6->r.flags & F_CONNECTED;
				if (memcmp(&kr6->r.nexthop, &in6addr_any,
				    sizeof(struct in6_addr)) != 0) {
					n.gateway.aid = AID_INET6;
					memcpy(&n.gateway.v6, &kr6->r.nexthop,
					    sizeof(struct in6_addr));
				}
				n.net.aid = AID_INET6;
				memcpy(&n.net.v6, &kr6->r.nexthop,
				    sizeof(struct in6_addr));
				n.netlen = kr6->r.prefixlen;
				break;
			}
			send_nexthop_update(&n);
d2156 3
d2215 3
d2222 3
a2224 7

	if (kn->kroute == NULL)
		return;

	for (s = RB_MIN(knexthop_tree, KT2KNT(kt)); s != NULL &&
	    s->kroute != kn->kroute; s = RB_NEXT(knexthop_tree, KT2KNT(kt), s))
		;	/* nothing */
a2393 2
	struct kroute_nexthop	 nh;
	struct knexthop_node	*n;
d2425 1
a2425 17
		RB_FOREACH(n, knexthop_tree, KT2KNT(kt))
			if (n->kroute == kkr->kr) {
				bzero(&nh, sizeof(nh));
				memcpy(&nh.nexthop, &n->nexthop,
				    sizeof(nh.nexthop));
				if (kroute_validate(&kkr->kr->r)) {
					nh.valid = 1;
					nh.connected = 1;
					if ((nh.gateway.v4.s_addr =
					    kkr->kr->r.nexthop.s_addr) != 0)
						nh.gateway.aid = AID_INET;
				}
				nh.net.aid = AID_INET;
				nh.net.v4.s_addr = kkr->kr->r.prefix.s_addr;
				nh.netlen = kkr->kr->r.prefixlen;
				send_nexthop_update(&nh);
			}
d2435 2
a2436 23
		RB_FOREACH(n, knexthop_tree, KT2KNT(kt))
			if (n->kroute == kkr6->kr) {
				bzero(&nh, sizeof(nh));
				memcpy(&nh.nexthop, &n->nexthop,
				    sizeof(nh.nexthop));
				if (kroute6_validate(&kkr6->kr->r)) {
					nh.valid = 1;
					nh.connected = 1;
					if (memcmp(&kkr6->kr->r.nexthop,
					    &in6addr_any, sizeof(struct
					    in6_addr))) {
						nh.gateway.aid = AID_INET6;
						memcpy(&nh.gateway.v6,
						    &kkr6->kr->r.nexthop,
						    sizeof(struct in6_addr));
					}
				}
				nh.net.aid = AID_INET6;
				memcpy(&nh.net.v6, &kkr6->kr->r.nexthop,
				    sizeof(struct in6_addr));
				nh.netlen = kkr6->kr->r.prefixlen;
				send_nexthop_update(&nh);
			}
d3027 1
a3027 1
	int			 flags, oflags, mpath = 0;
d3162 4
a3165 1
				if (sa_in != NULL)
d3168 3
a3170 1
				else
d3172 1
d3177 2
d3192 1
a3192 1
				if (kr->r.flags & F_NEXTHOP)
d3234 5
a3238 1
				if (sa_in6 != NULL)
d3242 5
a3246 1
				else
d3250 1
d3255 2
d3270 1
a3270 1
				if (kr6->r.flags & F_NEXTHOP)
@


1.188
log
@On reload the filtersets attached to a network need to be moved to the
existing network element. First free the old filterset and then move
the new on top of it. This solves the reload issue with changing network
statements. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.187 2011/03/07 07:43:02 henning Exp $ */
d1086 3
d1117 3
@


1.187
log
@continguous -> contiguous
From: "Anthony J. Bentley" <anthonyjbentley at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.186 2010/10/11 11:45:57 claudio Exp $ */
d1158 2
@


1.186
log
@bgpd needs to see all routing messages so set the ROUTE_TABLEFILTER to
RTABLE_ANY.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.185 2010/09/30 08:57:37 claudio Exp $ */
d2382 1
a2382 1
			fatalx("non continguous inet6 netmask");
@


1.185
log
@Only 6 elements of mib are used so do allocate 6 not 7.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.184 2010/09/02 14:03:21 sobrado Exp $ */
d196 1
d221 6
@


1.184
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.183 2010/07/12 14:35:13 bluhm Exp $ */
d424 1
a424 1
	int			 mib[7];
@


1.183
log
@Merge duplicate log messages into one log_warn().
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.182 2010/06/03 21:19:06 claudio Exp $ */
d1155 1
a1155 1
	
d1640 1
a1640 1
			else 
@


1.182
log
@Instead of doing a poor mans offsetof() implementation change the code
to use an end pointer to compare against. Looks less scary and makes
gcc4 happy. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.181 2010/05/19 13:15:08 claudio Exp $ */
d2654 1
a2654 2
		switch (errno) {
		case ESRCH:
a2662 6
			} else {
				log_warnx("send_rtmsg: action %u, "
				    "prefix %s/%u: %s", hdr.rtm_type,
				    inet_ntoa(kroute->prefix),
				    kroute->prefixlen, strerror(errno));
				return (0);
a2663 6
			break;
		default:
			log_warnx("send_rtmsg: action %u, prefix %s/%u: %s",
			    hdr.rtm_type, inet_ntoa(kroute->prefix),
			    kroute->prefixlen, strerror(errno));
			return (0);
d2665 3
d2760 1
a2760 2
		switch (errno) {
		case ESRCH:
a2768 6
			} else {
				log_warnx("send_rt6msg: action %u, "
				    "prefix %s/%u: %s", hdr.rtm_type,
				    log_in6addr(&kroute->prefix),
				    kroute->prefixlen, strerror(errno));
				return (0);
a2769 6
			break;
		default:
			log_warnx("send_rt6msg: action %u, prefix %s/%u: %s",
			    hdr.rtm_type, log_in6addr(&kroute->prefix),
			    kroute->prefixlen, strerror(errno));
			return (0);
d2771 3
@


1.181
log
@When installing MPLS VPN routes set the RTF_MPLS bit since those routes
have MPLS information connected to them and the kernel requires the flag now.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.180 2010/05/18 12:21:33 claudio Exp $ */
d2337 1
a2337 1
	u_int8_t	 l = 0, i, len;
d2343 3
a2345 3
	len = sa_in6->sin6_len -
	    (u_int8_t)(&((struct sockaddr_in6 *)NULL)->sin6_addr);
	for (i = 0; i < len; i++) {
d2347 1
a2347 1
		switch (sa_in6->sin6_addr.s6_addr[i]) {
@


1.180
log
@Be more careful in ktable_update() and ktable_new() and the fib sync flag.
Only existing tables should keep their fib sync state, new ones should set
the current fib sync flag to the configured one at the end of the config
load.  Found the hard way by sthen@@, OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.179 2010/05/17 15:49:29 claudio Exp $ */
d2630 1
@


1.179
log
@Last bits of MPLS VPN support. Hook kernel routing tables and RIB together.
This adds a bit of new config to specify the mapping between an rdomain and
the BGP MPLS VPN instance, example:
rdomain 1 {
        descr "CUSTOMER1"
	rd 65003:1
	import-target rt 65003:3
	export-target rt 65003:1
	depend on mpe0
	network 192.168.224/24
}
The "depend on mpe0" is a but ugly but for now this is the quickest way to
figure out which interface bgp should use to insert the MPLS routes.

A big side-effect of this diff is that networks are now internally
distributed through kroute.c.
This needs some kernel changes that will follow hopefully soon.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.178 2010/05/03 13:09:38 claudio Exp $ */
a276 1
	kt->state = RECONF_REINIT;
d285 1
a286 1
	kt->state = RECONF_KEEP;
d361 1
a361 1
			if (rkt->state == RECONF_DELETE)
d363 2
a364 1
			rkt->state = RECONF_KEEP;
d379 1
a379 1
		if (kt->state == RECONF_DELETE)
d381 2
a382 1
		else if (!kt->fib_conf)
d385 1
a385 1
		kt->state = RECONF_KEEP;
d414 2
@


1.178
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.177 2010/04/13 09:09:48 claudio Exp $ */
d30 1
d95 1
d98 1
a267 1
	LIST_INIT(&kt->redistlist);
d343 1
a343 1
ktable_update(struct rde_rib *rr)
d348 1
a348 1
	if (!ktable_exists(rr->rtableid, &rdomid))
d351 1
a351 1
	if (rdomid != rr->rtableid || rr->flags & F_RIB_NOFIB) {
d368 1
a368 1
	if (rr->flags & (F_RIB_NOEVALUATE | F_RIB_NOFIB))
d372 1
a372 1
	kt = ktable_get(rr->rtableid);
d374 2
a375 2
		if (ktable_new(rr->rtableid, rdomid, rr->name, NULL,
		    !(rr->flags & F_RIB_NOFIBSYNC)))
d380 1
a380 1
			kt->fib_conf = !(rr->flags & F_RIB_NOFIBSYNC);
d382 1
a382 1
			kt->fib_conf = !(rr->flags & F_RIB_NOFIBSYNC);
d457 2
d579 70
d662 2
d715 23
a1020 1
			LIST_INIT(&ktab.redistlist);
d1046 118
a1163 5
struct redist_node {
	LIST_ENTRY(redist_node)	 entry;
	struct kroute		*kr;
	struct kroute6		*kr6;
};
d1165 2
d1171 2
a1172 1
	struct redist_node	*rn;
d1175 9
d1211 16
a1226 27
	/* Add or delete kr from list ... */
	LIST_FOREACH(rn, &kt->redistlist, entry)
	    if (rn->kr == kr)
		    break;

	switch (type) {
	case IMSG_NETWORK_ADD:
		if (rn == NULL) {
			if ((rn = calloc(1, sizeof(struct redist_node))) ==
			    NULL) {
				log_warn("kr_redistribute");
				return (-1);
			}
			rn->kr = kr;
			LIST_INSERT_HEAD(&kt->redistlist, rn, entry);
		}
		break;
	case IMSG_NETWORK_REMOVE:
		if (rn != NULL) {
			LIST_REMOVE(rn, entry);
			free(rn);
		}
		break;
	default:
		errno = EINVAL;
		return (-1);
	}
d1228 1
a1228 1
	return (bgpd_redistribute(type, kr, NULL));
d1234 11
a1244 1
	struct redist_node	*rn;
d1276 2
a1277 2
	if (memcmp(&kr6->prefix, &in6addr_any, sizeof(struct in6_addr)) == 0 &&
	    kr6->prefixlen == 0)
d1280 15
a1294 30
	/* Add or delete kr from list ...
	 * using a linear list to store the redistributed networks will hurt
	 * as soon as redistribute ospf comes but until then keep it simple.
	 */
	LIST_FOREACH(rn, &kt->redistlist, entry)
	    if (rn->kr6 == kr6)
		    break;

	switch (type) {
	case IMSG_NETWORK_ADD:
		if (rn == NULL) {
			if ((rn = calloc(1, sizeof(struct redist_node))) ==
			    NULL) {
				log_warn("kr_redistribute");
				return (-1);
			}
			rn->kr6 = kr6;
			LIST_INSERT_HEAD(&kt->redistlist, rn, entry);
		}
		break;
	case IMSG_NETWORK_REMOVE:
		if (rn != NULL) {
			LIST_REMOVE(rn, entry);
			free(rn);
		}
		break;
	default:
		errno = EINVAL;
		return (-1);
	}
d1296 1
a1296 1
	return (bgpd_redistribute(type, NULL, kr6));
d1303 2
a1304 1
	struct redist_node	*rn;
d1306 1
d1308 1
a1313 5
		LIST_FOREACH(rn, &kt->redistlist, entry)
			if (bgpd_redistribute(IMSG_NETWORK_ADD, rn->kr,
			    rn->kr6) == -1)
				return (-1);

d1316 16
d2538 1
a2538 1
	struct iovec		iov[5];
d2543 5
d2607 27
@


1.177
log
@Instead of passing AF specific struct kroutes over imsgs use a struct
kroute_full structure that is AF independent and has all information in
it. Simplifies the communication between processes and reduces the number
of imsg types. This is another step to add FIB support to BGP MPLS VPNs.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.176 2010/04/06 13:25:08 claudio Exp $ */
d40 3
a45 2
	u_int			rtableid;
	int			fib_sync;
d87 15
a101 6
int	kr4_change(struct kroute_full *);
int	kr6_change(struct kroute_full *);
int	kr4_delete(struct kroute_full *);
int	kr6_delete(struct kroute_full *);
int	kr_redistribute(int, struct kroute *);
int	kr_redistribute6(int, struct kroute6 *);
d109 2
a110 1
struct kroute_node	*kroute_find(in_addr_t, u_int8_t, u_int8_t);
d113 3
a115 3
int			 kroute_insert(struct kroute_node *);
int			 kroute_remove(struct kroute_node *);
void			 kroute_clear(void);
d117 2
a118 2
struct kroute6_node	*kroute6_find(const struct in6_addr *, u_int8_t,
			     u_int8_t);
d121 10
a130 8
int			 kroute6_insert(struct kroute6_node *);
int			 kroute6_remove(struct kroute6_node *);
void			 kroute6_clear(void);

struct knexthop_node	*knexthop_find(struct bgpd_addr *);
int			 knexthop_insert(struct knexthop_node *);
int			 knexthop_remove(struct knexthop_node *);
void			 knexthop_clear(void);
d146 7
a152 5
void			 knexthop_validate(struct knexthop_node *);
void			 knexthop_track(void *);
struct kroute_node	*kroute_match(in_addr_t, int);
struct kroute6_node	*kroute6_match(struct in6_addr *, int);
void			 kroute_detach_nexthop(struct knexthop_node *);
d154 1
a154 1
int		protect_lo(void);
d162 2
a163 2
int		send_rtmsg(int, int, struct kroute *);
int		send_rt6msg(int, int, struct kroute6 *);
d165 1
a165 1
int		fetchtable(u_int, int);
d168 1
a168 1
		    struct sockaddr *[RTAX_MAX], int);
a169 1
RB_HEAD(kroute_tree, kroute_node)	krt;
a172 1
RB_HEAD(kroute6_tree, kroute6_node)	krt6;
a175 1
RB_HEAD(knexthop_tree, knexthop_node)	knt;
d183 2
d190 1
a190 1
kr_init(int fs, u_int rtableid)
a194 3
	kr_state.rtableid = rtableid;
	kr_state.fib_sync = fs;

a220 3
	RB_INIT(&krt);
	RB_INIT(&krt6);
	RB_INIT(&knt);
d226 53
a278 1
	if (fetchtable(kr_state.rtableid, 0) == -1)
d280 94
a373 2
	if (kr_state.rtableid != 0)
		if (fetchtable(0, 1) == -1)
d375 45
d421 6
a426 2
	if (protect_lo() == -1)
		return (-1);
d428 12
a439 1
	return (kr_state.fd);
d443 1
a443 1
kr_change(struct kroute_full *kl)
d445 5
d452 1
a452 1
		return (kr4_change(kl));
d454 1
a454 1
		return (kr6_change(kl));
d461 1
a461 1
kr4_change(struct kroute_full *kl)
d467 1
a467 1
	if ((kr = kroute_find(kl->prefix.v4.s_addr, kl->prefixlen,
d494 1
a494 1
		if (kroute_insert(kr) == -1)
d510 1
a510 1
	if (send_rtmsg(kr_state.fd, action, &kr->r) == -1)
d517 1
a517 1
kr6_change(struct kroute_full *kl)
d524 1
a524 1
	if ((kr6 = kroute6_find(&kl->prefix.v6, kl->prefixlen, RTP_BGP)) !=
d551 1
a551 1
		if (kroute6_insert(kr6) == -1)
d568 1
a568 1
	if (send_rt6msg(kr_state.fd, action, &kr6->r) == -1)
d575 1
a575 1
kr_delete(struct kroute_full *kl)
d577 6
d585 1
a585 1
		return (kr4_delete(kl));
d587 1
a587 1
		return (kr6_delete(kl));
d594 1
a594 1
kr4_delete(struct kroute_full *kl)
d598 1
a598 1
	if ((kr = kroute_find(kl->prefix.v4.s_addr, kl->prefixlen,
d605 1
a605 1
	if (send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r) == -1)
d610 1
a610 1
	if (kroute_remove(kr) == -1)
d617 1
a617 1
kr6_delete(struct kroute_full *kl)
d621 1
a621 1
	if ((kr6 = kroute6_find(&kl->prefix.v6, kl->prefixlen, RTP_BGP)) ==
d628 1
a628 1
	if (send_rt6msg(kr_state.fd, RTM_DELETE, &kr6->r) == -1)
d633 1
a633 1
	if (kroute6_remove(kr6) == -1)
d642 4
a645 4
	kr_fib_decouple();
	knexthop_clear();
	kroute_clear();
	kroute6_clear();
d650 1
a650 1
kr_fib_couple(void)
d652 1
d656 4
a659 1
	if (kr_state.fib_sync == 1)	/* already coupled */
d662 1
a662 1
	kr_state.fib_sync = 1;
d664 1
a664 1
	RB_FOREACH(kr, kroute_tree, &krt)
d666 2
a667 2
			send_rtmsg(kr_state.fd, RTM_ADD, &kr->r);
	RB_FOREACH(kr6, kroute6_tree, &krt6)
d669 1
a669 1
			send_rt6msg(kr_state.fd, RTM_ADD, &kr6->r);
d671 2
a672 1
	log_info("kernel routing table coupled");
d676 1
a676 1
kr_fib_decouple(void)
d678 1
d682 1
a682 1
	if (kr_state.fib_sync == 0)	/* already decoupled */
d685 4
a688 1
	RB_FOREACH(kr, kroute_tree, &krt)
d690 2
a691 2
			send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);
	RB_FOREACH(kr6, kroute6_tree, &krt6)
d693 1
a693 1
			send_rt6msg(kr_state.fd, RTM_DELETE, &kr6->r);
d695 1
a695 1
	kr_state.fib_sync = 0;
d697 2
a698 1
	log_info("kernel routing table decoupled");
d708 1
a708 1
kr_nexthop_add(struct bgpd_addr *addr)
d710 1
d713 5
a717 1
	if ((h = knexthop_find(addr)) != NULL) {
d760 1
a760 1
		if (knexthop_insert(h) == -1)
d768 1
a768 1
kr_nexthop_delete(struct bgpd_addr *addr)
d770 1
d773 5
a777 1
	if ((kn = knexthop_find(addr)) == NULL)
d780 1
a780 1
	knexthop_remove(kn);
d786 1
d795 1
d803 7
a809 1
			return;
d814 1
a814 1
			RB_FOREACH(kr, kroute_tree, &krt) {
d825 1
a825 1
			RB_FOREACH(kr6, kroute6_tree, &krt6) {
d840 7
a846 1
			return;
d852 1
a852 1
			kr = kroute_match(addr->v4.s_addr, 1);
d859 1
a859 1
			kr6 = kroute6_match(&addr->v6, 1);
d868 7
a874 1
		RB_FOREACH(h, knexthop_tree, &knt) {
d909 19
a954 2
LIST_HEAD(, redist_node) redistlist;

d956 1
a956 1
kr_redistribute(int type, struct kroute *kr)
d989 1
a989 1
	LIST_FOREACH(rn, &redistlist, entry)
d1002 1
a1002 1
			LIST_INSERT_HEAD(&redistlist, rn, entry);
d1020 1
a1020 1
kr_redistribute6(int type, struct kroute6 *kr6)
d1062 1
a1062 1
	LIST_FOREACH(rn, &redistlist, entry)
d1075 1
a1075 1
			LIST_INSERT_HEAD(&redistlist, rn, entry);
d1095 1
d1098 5
d1104 4
a1107 3
	LIST_FOREACH(rn, &redistlist, entry)
		if (bgpd_redistribute(IMSG_NETWORK_ADD, rn->kr, rn->kr6) == -1)
			return (-1);
d1109 3
a1111 2
	RB_FOREACH(nh, knexthop_tree, &knt)
		knexthop_validate(nh);
d1251 2
a1252 1
kroute_find(in_addr_t prefix, u_int8_t prefixlen, u_int8_t prio)
d1261 1
a1261 1
	kn = RB_FIND(kroute_tree, &krt, &s);
d1263 1
a1263 1
		tmp = RB_PREV(kroute_tree, &krt, kn);
d1269 1
a1269 1
			tmp = RB_PREV(kroute_tree, &krt, kn);
d1296 1
a1296 1
kroute_insert(struct kroute_node *kr)
d1302 1
a1302 1
	if ((krm = RB_INSERT(kroute_tree, &krt, kr)) != NULL) {
d1313 1
a1313 1
		RB_FOREACH(h, knexthop_tree, &knt)
d1316 1
a1316 1
				knexthop_validate(h);
d1324 1
a1324 1
			kr_redistribute(IMSG_NETWORK_ADD, &kr->r);
d1331 1
a1331 1
kroute_remove(struct kroute_node *kr)
d1336 1
a1336 1
	if ((krm = RB_FIND(kroute_tree, &krt, kr)) == NULL) {
d1344 1
a1344 1
		if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
d1350 2
a1351 1
			if (RB_INSERT(kroute_tree, &krt, kr->next) != NULL) {
d1372 1
a1372 1
		RB_FOREACH(s, knexthop_tree, &knt)
d1374 1
a1374 1
				knexthop_validate(s);
d1378 1
a1378 1
		kr_redistribute(IMSG_NETWORK_REMOVE, &kr->r);
d1391 1
a1391 1
kroute_clear(void)
d1395 2
a1396 2
	while ((kr = RB_MIN(kroute_tree, &krt)) != NULL)
		kroute_remove(kr);
d1400 2
a1401 1
kroute6_find(const struct in6_addr *prefix, u_int8_t prefixlen, u_int8_t prio)
d1410 1
a1410 1
	kn6 = RB_FIND(kroute6_tree, &krt6, &s);
d1412 1
a1412 1
		tmp = RB_PREV(kroute6_tree, &krt6, kn6);
d1418 1
a1418 1
			tmp = RB_PREV(kroute6_tree, &krt6, kn6);
d1445 1
a1445 1
kroute6_insert(struct kroute6_node *kr)
d1451 1
a1451 1
	if ((krm = RB_INSERT(kroute6_tree, &krt6, kr)) != NULL) {
d1461 1
a1461 1
		RB_FOREACH(h, knexthop_tree, &knt)
d1466 1
a1466 1
					knexthop_validate(h);
d1475 1
a1475 1
			kr_redistribute6(IMSG_NETWORK_ADD, &kr->r);
d1482 1
a1482 1
kroute6_remove(struct kroute6_node *kr)
d1487 1
a1487 1
	if ((krm = RB_FIND(kroute6_tree, &krt6, kr)) == NULL) {
d1495 1
a1495 1
		if (RB_REMOVE(kroute6_tree, &krt6, kr) == NULL) {
d1501 2
a1502 1
			if (RB_INSERT(kroute6_tree, &krt6, kr->next) != NULL) {
d1524 1
a1524 1
		RB_FOREACH(s, knexthop_tree, &knt)
d1526 1
a1526 1
				knexthop_validate(s);
d1530 1
a1530 1
		kr_redistribute6(IMSG_NETWORK_REMOVE, &kr->r);
d1543 1
a1543 1
kroute6_clear(void)
d1547 2
a1548 2
	while ((kr = RB_MIN(kroute6_tree, &krt6)) != NULL)
		kroute6_remove(kr);
d1552 1
a1552 1
knexthop_find(struct bgpd_addr *addr)
d1559 1
a1559 1
	return (RB_FIND(knexthop_tree, &knt, &s));
d1563 1
a1563 1
knexthop_insert(struct knexthop_node *kn)
d1565 1
a1565 1
	if (RB_INSERT(knexthop_tree, &knt, kn) != NULL) {
d1572 1
a1572 1
	knexthop_validate(kn);
d1578 1
a1578 1
knexthop_remove(struct knexthop_node *kn)
d1580 1
a1580 1
	kroute_detach_nexthop(kn);
d1582 1
a1582 1
	if (RB_REMOVE(knexthop_tree, &knt, kn) == NULL) {
d1593 1
a1593 1
knexthop_clear(void)
d1597 2
a1598 2
	while ((kn = RB_MIN(knexthop_tree, &knt)) != NULL)
		knexthop_remove(kn);
d1630 1
d1639 3
d1645 1
a1645 1
		kroute_remove(kkr->kr);
d1652 1
a1652 1
		kroute6_remove(kkr6->kr);
d1655 1
a1655 1

d1850 1
a1850 1
knexthop_validate(struct knexthop_node *kn)
d1864 1
a1864 1
	kroute_detach_nexthop(kn);
d1868 1
a1868 1
		if ((kr = kroute_match(kn->nexthop.v4.s_addr, 0)) == NULL) {
d1891 1
a1891 1
		if ((kr6 = kroute6_match(&kn->nexthop.v6, 0)) == NULL) {
d1921 1
a1921 1
knexthop_track(void *krn)
d1928 2
a1929 2
	RB_FOREACH(kn, knexthop_tree, &knt)
		if (kn->kroute == krn) {
d1935 1
a1935 1
				kr = krn;
d1946 1
a1946 1
				kr6 = krn;
d1966 1
a1966 1
kroute_match(in_addr_t key, int matchall)
d1976 1
a1976 1
		if ((kr = kroute_find(htonl(ina & prefixlen2mask(i)), i,
d1982 1
a1982 1
	if ((kr = kroute_find(0, 0, RTP_ANY)) != NULL)
d1990 1
a1990 1
kroute6_match(struct in6_addr *key, int matchall)
d1999 1
a1999 1
		if ((kr6 = kroute6_find(&ina, i, RTP_ANY)) != NULL)
d2005 1
a2005 1
	if ((kr6 = kroute6_find(&in6addr_any, 0, RTP_ANY)) != NULL)
d2013 1
a2013 1
kroute_detach_nexthop(struct knexthop_node *kn)
d2027 2
a2028 2
	for (s = RB_MIN(knexthop_tree, &knt); s != NULL &&
	    s->kroute != kn->kroute; s = RB_NEXT(knexthop_tree, &knt, s))
d2052 1
a2052 1
protect_lo(void)
d2066 1
a2066 1
	if (RB_INSERT(kroute_tree, &krt, kr) != NULL)
d2078 1
a2078 1
	if (RB_INSERT(kroute6_tree, &krt6, kr6) != NULL)
d2195 1
d2221 2
d2229 4
a2232 1
		RB_FOREACH(n, knexthop_tree, &knt)
d2256 3
a2258 1
		RB_FOREACH(n, knexthop_tree, &knt)
d2315 1
a2315 1
send_rtmsg(int fd, int action, struct kroute *kroute)
d2325 1
a2325 1
	if (kr_state.fib_sync == 0)
d2332 1
a2332 1
	hdr.rtm_tableid = kr_state.rtableid;
d2427 1
a2427 1
send_rt6msg(int fd, int action, struct kroute6 *kroute)
d2438 1
a2438 1
	if (kr_state.fib_sync == 0)
d2445 1
a2445 1
	hdr.rtm_tableid = kr_state.rtableid;
d2543 1
a2543 1
fetchtable(u_int rtableid, int connected_only)
d2547 1
a2547 1
	char			*buf, *next, *lim;
d2561 1
a2561 1
	mib[6] = rtableid;
d2564 2
a2565 1
		if (rtableid != 0 && errno == EINVAL)	/* table nonexistent */
d2570 10
a2579 8
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchtable");
		return (-1);
	}
	if (sysctl(mib, 7, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
d2692 1
a2692 4
				send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);
				free(kr);
			} else if (connected_only &&
			    !(kr->r.flags & F_CONNECTED))
d2694 2
a2695 2
			else
				kroute_insert(kr);
d2698 2
a2699 4
				send_rt6msg(kr_state.fd, RTM_DELETE, &kr6->r);
				free(kr6);
			} else if (connected_only &&
			    !(kr6->r.flags & F_CONNECTED))
d2701 2
a2702 2
			else
				kroute6_insert(kr6);
d2723 1
a2723 1
	mib[3] = AF_INET;
d2792 1
a2792 1
	int			 connected_only;
d2826 2
a2827 7
			connected_only = 0;
			if (rtm->rtm_tableid != kr_state.rtableid) {
				if (rtm->rtm_tableid == 0)
					connected_only = 1;
				else
					continue;
			}
d2829 1
a2829 2
			if (dispatch_rtmsg_addr(rtm, rti_info,
			    connected_only) == -1)
d2850 1
a2850 1
    int connected_only)
d2931 1
a2931 1
			if ((kr = kroute_find(prefix.v4.s_addr,
d2945 1
a2945 1
			if (kroute_remove(kr) == -1)
d2950 1
a2950 1
			if ((kr6 = kroute6_find(&prefix.v6, prefixlen,
d2965 1
a2965 1
			if (kroute6_remove(kr6) == -1)
a2971 3
	if (connected_only && !(flags & F_CONNECTED))
		return (0);

d2981 1
a2981 1
		if ((kr = kroute_find(prefix.v4.s_addr, prefixlen,
d3007 1
a3007 1
					    &kr->r);
d3013 1
a3013 1
					    &kr->r);
d3016 1
a3016 1
					knexthop_track(kr);
d3039 1
a3039 1
			kroute_insert(kr);
d3044 2
a3045 1
		if ((kr6 = kroute6_find(&prefix.v6, prefixlen, prio)) != NULL) {
d3074 1
a3074 1
					    &kr6->r);
d3080 1
a3080 1
					    &kr6->r);
d3083 1
a3083 1
					knexthop_track(kr6);
d3109 1
a3109 1
			kroute6_insert(kr6);
@


1.176
log
@Switch to a more address family independent nexthop imsg. Instead of passing
struct kroute or kroute6 pack the needed info into a struct bgpd_addr.
No flames comming out of my and sthen@@'s bgpd routers.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.175 2010/02/26 15:50:20 claudio Exp $ */
d86 4
d92 2
d231 14
a244 1
kr_change(struct kroute_label *kl)
d248 1
d250 2
a251 2
	if ((kr = kroute_find(kl->kr.prefix.s_addr, kl->kr.prefixlen, RTP_BGP))
	    != NULL)
d255 1
a255 1
	if ((kl->kr.nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
d259 1
a259 3
	if (kr)
		rtlabel_unref(kr->r.labelid);
	kl->kr.labelid = rtlabel_name2id(kl->label);
d262 2
a263 5
	if (kl->kr.flags & (F_BLACKHOLE|F_REJECT))
		kl->kr.nexthop.s_addr = htonl(INADDR_LOOPBACK);

	if (send_rtmsg(kr_state.fd, action, &kl->kr) == -1)
		return (-1);
d270 4
a273 4
		kr->r.prefix.s_addr = kl->kr.prefix.s_addr;
		kr->r.prefixlen = kl->kr.prefixlen;
		kr->r.nexthop.s_addr = kl->kr.nexthop.s_addr;
		kr->r.flags = kl->kr.flags | F_BGPD_INSERTED;
d275 1
a275 1
		kr->r.labelid = kl->kr.labelid;
d280 4
a283 3
		kr->r.nexthop.s_addr = kl->kr.nexthop.s_addr;
		kr->r.labelid = kl->kr.labelid;
		if (kl->kr.flags & F_BLACKHOLE)
d287 1
a287 1
		if (kl->kr.flags & F_REJECT)
d293 1
a293 26
	return (0);
}

int
kr_delete(struct kroute_label *kl)
{
	struct kroute_node	*kr;

	if ((kr = kroute_find(kl->kr.prefix.s_addr, kl->kr.prefixlen, RTP_BGP))
	    == NULL)
		return (0);

	if (!(kr->r.flags & F_BGPD_INSERTED))
		return (0);

	/* nexthop within 127/8 -> ignore silently */
	if ((kl->kr.nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
	    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
		return (0);

	if (send_rtmsg(kr_state.fd, RTM_DELETE, &kl->kr) == -1)
		return (-1);

	rtlabel_unref(kl->kr.labelid);

	if (kroute_remove(kr) == -1)
d300 1
a300 1
kr6_change(struct kroute6_label *kl)
d303 1
d305 1
a305 1
	struct in6_addr		 lo6 = IN6ADDR_LOOPBACK_INIT;
d307 2
a308 2
	if ((kr6 = kroute6_find(&kl->kr.prefix, kl->kr.prefixlen, RTP_BGP))
	     != NULL)
d312 1
a312 1
	if (IN6_IS_ADDR_LOOPBACK(&kl->kr.nexthop))
d315 1
a315 3
	if (kr6)
		rtlabel_unref(kr6->r.labelid);
	kl->kr.labelid = rtlabel_name2id(kl->label);
d318 2
a319 5
	if (kl->kr.flags & (F_BLACKHOLE|F_REJECT))
		bcopy(&lo6, &kl->kr.nexthop, sizeof(kl->kr.nexthop));

	if (send_rt6msg(kr_state.fd, action, &kl->kr) == -1)
		return (-1);
d326 3
a328 1
		memcpy(&kr6->r.prefix, &kl->kr.prefix,
d330 1
a330 4
		kr6->r.prefixlen = kl->kr.prefixlen;
		memcpy(&kr6->r.nexthop, &kl->kr.nexthop,
		    sizeof(struct in6_addr));
		kr6->r.flags = kl->kr.flags | F_BGPD_INSERTED;
d332 1
a332 1
		kr6->r.labelid = kl->kr.labelid;
d337 1
a337 1
		memcpy(&kr6->r.nexthop, &kl->kr.nexthop,
d339 3
a341 2
		kr6->r.labelid = kl->kr.labelid;
		if (kl->kr.flags & F_BLACKHOLE)
d345 1
a345 1
		if (kl->kr.flags & F_REJECT)
d351 3
d358 37
a394 1
kr6_delete(struct kroute6_label *kl)
d398 2
a399 2
	if ((kr6 = kroute6_find(&kl->kr.prefix, kl->kr.prefixlen, RTP_BGP))
	    == NULL)
d405 1
a405 5
	/* nexthop to loopback -> ignore silently */
	if (IN6_IS_ADDR_LOOPBACK(&kl->kr.nexthop))
		return (0);

	if (send_rt6msg(kr_state.fd, RTM_DELETE, &kl->kr) == -1)
d408 1
a408 1
	rtlabel_unref(kl->kr.labelid);
d563 10
a572 10
			RB_FOREACH(kr, kroute_tree, &krt)
				if (!flags || kr->r.flags & flags) {
					kn = kr;
					do {
						send_imsg_session(
						    IMSG_CTL_KROUTE,
						    imsg->hdr.pid, &kn->r,
						    sizeof(kn->r));
					} while ((kn = kn->next) != NULL);
				}
d574 10
a583 10
			RB_FOREACH(kr6, kroute6_tree, &krt6)
				if (!flags || kr6->r.flags & flags) {
					kn6 = kr6;
					do {
						send_imsg_session(
						    IMSG_CTL_KROUTE6,
						    imsg->hdr.pid, &kn6->r,
						    sizeof(kn6->r));
					} while ((kn6 = kn6->next) != NULL);
				}
d598 2
a599 1
				    imsg->hdr.pid, &kr->r, sizeof(kr->r));
d604 3
a606 2
				send_imsg_session(IMSG_CTL_KROUTE6,
				    imsg->hdr.pid, &kr6->r, sizeof(kr6->r));
d826 40
@


1.175
log
@Fix some minor issues. 0 instead of NULL in one comparison. Set the
right flags when protecting the IPv6 loopback addr (instead of reassigning
the IPv4 ones) and install the IPv4 loopback blocker as 127/8 and not as
127.0.0.1/8. First two found by Hiroki Sato hrs (at) allbsd org and I found
the 127/8 issue all by myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.174 2010/02/23 16:06:04 claudio Exp $ */
d474 3
a476 1
			memcpy(&nh.kr.kr4, &k->r, sizeof(nh.kr.kr4));
d486 4
a489 1
			memcpy(&nh.kr.kr6, &k6->r, sizeof(nh.kr.kr6));
d1518 3
a1520 1
				memcpy(&n.kr.kr4, &kr->r, sizeof(n.kr.kr4));
d1544 4
a1547 1
				memcpy(&n.kr.kr6, &kr6->r, sizeof(n.kr.kr6));
d1581 3
a1583 1
				memcpy(&n.kr.kr4, &kr->r, sizeof(n.kr.kr4));
d1595 4
a1598 1
				memcpy(&n.kr.kr6, &kr6->r, sizeof(n.kr.kr6));
d1878 3
a1880 2
				memcpy(&nh.kr.kr4, &kkr->kr->r,
				    sizeof(nh.kr.kr4));
d1907 4
a1910 2
				memcpy(&nh.kr.kr6, &kkr6->kr->r,
				    sizeof(nh.kr.kr6));
@


1.174
log
@Remove some extra ().
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.173 2009/12/01 14:28:05 claudio Exp $ */
d1076 1
a1076 1
		if (memcmp(&kr->r.nexthop, &nexthop, sizeof(nexthop)) == NULL)
d1687 1
a1687 1
	kr->r.prefix.s_addr = htonl(INADDR_LOOPBACK);
d1701 1
a1701 1
	kr->r.flags = F_KERNEL|F_CONNECTED;
@


1.173
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.172 2009/07/23 14:53:20 claudio Exp $ */
d1800 1
a1800 1
    (((a) & ((sizeof(long)) - 1)) ? (1 + ((a) | ((sizeof(long)) - 1))) : (a))
@


1.172
log
@Send the used kroute along with the nexthop information. This allows us
to show all necessary information in bgpctl show next. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.171 2009/07/23 10:20:44 claudio Exp $ */
d466 1
a466 1
		if (h->kroute != NULL && addr->af == AF_INET) {
d470 1
a470 1
				nh.gateway.af = AF_INET;
d475 1
a475 1
		} else if (h->kroute != NULL && addr->af == AF_INET6) {
d480 1
a480 1
				nh.gateway.af = AF_INET6;
d566 2
a567 2
		switch (addr->af) {
		case AF_INET:
d573 1
a573 1
		case AF_INET6:
d586 2
a587 2
				switch (h->nexthop.af) {
				case AF_INET:
d595 1
a595 1
				case AF_INET6:
d857 2
a858 2
	if (a->nexthop.af != b->nexthop.af)
		return (b->nexthop.af - a->nexthop.af);
d860 2
a861 2
	switch (a->nexthop.af) {
	case AF_INET:
d867 1
a867 1
	case AF_INET6:
d956 1
a956 1
			if (h->nexthop.af == AF_INET &&
d1102 1
a1102 1
			if (h->nexthop.af == AF_INET6) {
d1492 1
a1492 1
	if (kn->nexthop.af == AF_INET && (kr = kn->kroute) != NULL)
d1494 1
a1494 1
	if (kn->nexthop.af == AF_INET6 && (kr6 = kn->kroute) != NULL)
d1501 2
a1502 2
	switch (kn->nexthop.af) {
	case AF_INET:
d1512 1
a1512 1
					n.gateway.af = AF_INET;
d1523 1
a1523 1
	case AF_INET6:
d1533 1
a1533 1
					n.gateway.af = AF_INET6;
d1563 2
a1564 2
			switch (kn->nexthop.af) {
			case AF_INET:
d1570 1
a1570 1
					n.gateway.af = AF_INET;
d1573 1
a1573 1
			case AF_INET6:
d1579 1
a1579 1
					n.gateway.af = AF_INET6;
d1657 2
a1658 2
		switch (kn->nexthop.af) {
		case AF_INET:
d1662 1
a1662 1
		case AF_INET6:
d1861 1
a1861 1
						nh.gateway.af = AF_INET;
d1885 1
a1885 1
						nh.gateway.af = AF_INET6;
d2507 1
a2507 2
	prefix.af = sa->sa_family;
	switch (prefix.af) {
d2509 1
d2523 1
d2550 2
a2551 2
		switch (prefix.af) {
		case AF_INET:
d2570 1
a2570 1
		case AF_INET6:
d2603 2
a2604 2
	switch (prefix.af) {
	case AF_INET:
d2667 1
a2667 1
	case AF_INET6:
@


1.171
log
@knexthop_compare() failed to compare correctly and because of this it was
possible to corrupt the nexthop RB tree. Use the same compare logic used
in the kroute compare functions. Nice side effect is a nicely sorted list
in bgpctl show next. OK sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.170 2009/07/20 15:03:16 claudio Exp $ */
d590 3
a592 5
					snh.connected =
					    kr->r.flags & F_CONNECTED;
					if ((snh.gateway.v4.s_addr =
					    kr->r.nexthop.s_addr) != 0)
						snh.gateway.af = AF_INET;
d598 3
a600 10
					snh.connected =
					    kr6->r.flags & F_CONNECTED;
					if (memcmp(&kr6->r.nexthop,
					    &in6addr_any,
					    sizeof(struct in6_addr)) != 0) {
						snh.gateway.af = AF_INET6;
						memcpy(&snh.gateway.v6,
						    &kr6->r.nexthop,
						    sizeof(struct in6_addr));
					}
@


1.170
log
@Include more info in the bgpctl show nexthop ctl message. Mainly add the
gateway used for non-connected routes. This info was missing all the time
and often resulted in massive confusion when the nexthop selection choosed
a bad nexthop.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.169 2009/06/25 15:54:22 claudio Exp $ */
d864 1
a864 1
	u_int32_t	r;
d871 4
a874 2
		if ((r = b->nexthop.addr32[0] - a->nexthop.addr32[0]) != 0)
			return (r);
d877 6
a882 8
		if ((r = b->nexthop.addr32[3] - a->nexthop.addr32[3]) != 0)
			return (r);
		if ((r = b->nexthop.addr32[2] - a->nexthop.addr32[2]) != 0)
			return (r);
		if ((r = b->nexthop.addr32[1] - a->nexthop.addr32[1]) != 0)
			return (r);
		if ((r = b->nexthop.addr32[0] - a->nexthop.addr32[0]) != 0)
			return (r);
d884 2
d1204 1
@


1.169
log
@Add missing RTM_VERSION checks. Bad me, no cockies.
Tested and OK sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.168 2009/06/12 16:42:53 claudio Exp $ */
d590 5
d600 10
@


1.168
log
@Move prefixlen2mask and inet6applymask to util.c so that we can kill the
copies in bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.167 2009/06/05 22:40:24 chris Exp $ */
d2187 2
d2414 2
@


1.167
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.166 2009/05/25 11:49:47 claudio Exp $ */
a1773 9
in_addr_t
prefixlen2mask(u_int8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	return (0xffffffff << (32 - prefixlen));
}

a1787 17
}

void
inet6applymask(struct in6_addr *dest, const struct in6_addr *src, int prefixlen)
{
	struct in6_addr	mask;
	int		i;

	bzero(&mask, sizeof(mask));
	for (i = 0; i < prefixlen / 8; i++)
		mask.s6_addr[i] = 0xff;
	i = prefixlen % 8;
	if (i)
		mask.s6_addr[prefixlen / 8] = 0xff00 >> i;

	for (i = 0; i < 16; i++)
		dest->s6_addr[i] = src->s6_addr[i] & mask.s6_addr[i];
@


1.166
log
@In dispatch_rtmsg_addr() don't fatal on missing multipath deletes. Not 100%
sure why it happens but it is not a fatal condition. A warning should still
be logged because it is not good to miss updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.165 2009/02/11 20:07:04 claudio Exp $ */
d2213 1
a2213 1
		sa = (struct sockaddr *)(rtm + 1);
d2443 1
a2443 1
			sa = (struct sockaddr *)(rtm + 1);
@


1.165
log
@Because IPv6 fucked up and created a badly sized struct sockaddr_in6 we need
to add some pading on 64bit archs. Use a helper struct plus some ROUNDUP()
magic to get the size correct.
Tested on i386 and amd64 by Graeme Lee "graeme (at) omni (dot) net (dot) au"
Some sort of OK by henning@@ (he ignores the non-v4 code)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.164 2009/02/09 08:20:11 claudio Exp $ */
d2576 1
a2576 1
					return (-1);
d2595 2
a2596 2
					    "mpath route not found");
					return (-1);
@


1.164
log
@Correct function name in warning to avoid confusion. After a discussion on
misc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.163 2009/01/01 15:32:35 claudio Exp $ */
d1816 2
a1817 2
#define	ROUNDUP(a, size)	\
    (((a) & ((size) - 1)) ? (1 + ((a) | ((size) - 1))) : (a))
d1828 1
a1828 1
			    ROUNDUP(sa->sa_len, sizeof(long)));
d2062 4
a2065 3
	struct sockaddr_in6	prefix;
	struct sockaddr_in6	nexthop;
	struct sockaddr_in6	mask;
d2090 4
a2093 3
	prefix.sin6_len = sizeof(prefix);
	prefix.sin6_family = AF_INET6;
	memcpy(&prefix.sin6_addr, &kroute->prefix, sizeof(struct in6_addr));
d2097 1
a2097 1
	hdr.rtm_msglen += sizeof(prefix);
d2100 1
a2100 1
	iov[iovcnt++].iov_len = sizeof(prefix);
d2104 3
a2106 3
		nexthop.sin6_len = sizeof(nexthop);
		nexthop.sin6_family = AF_INET6;
		memcpy(&nexthop.sin6_addr, &kroute->nexthop,
d2111 1
a2111 1
		hdr.rtm_msglen += sizeof(nexthop);
d2114 1
a2114 1
		iov[iovcnt++].iov_len = sizeof(nexthop);
d2118 3
a2120 3
	mask.sin6_len = sizeof(mask);
	mask.sin6_family = AF_INET6;
	memcpy(&mask.sin6_addr, prefixlen2mask6(kroute->prefixlen),
d2124 1
a2124 1
	hdr.rtm_msglen += sizeof(mask);
d2127 1
a2127 1
	iov[iovcnt++].iov_len = sizeof(mask);
@


1.163
log
@Remove unneeded debug messages that made it into the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.162 2008/12/12 23:15:12 claudio Exp $ */
d2153 1
a2153 1
				log_warnx("send_rtmsg: action %u, "
d2161 1
a2161 1
			log_warnx("send_rtmsg: action %u, prefix %s/%u: %s",
@


1.162
log
@Make bgpd route priority aware and while there sync in the basics to correctly
track multipath routes. Code is mostly stolen from similar fixes to ospfd but
a bit different as this kroute.c implementation is more complex because of
additional task (nexthop verification for example).
This change and the similar ospfd change were desperatly needed on larger
complex network setups which tended to end up in situation where the kernel
had a different oppinion about routing than the daemon. Now the situation
should be a lot better.
Tested and OK sthen@@ gollo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.161 2008/11/21 17:41:22 claudio Exp $ */
a918 2
log_debug("kroute_matchgw: prefix %s/%u", inet_ntoa(kr->r.prefix), kr->r.prefixlen);
log_debug("kroute_matchgw: nexthop = %s", inet_ntoa(sa_in->sin_addr));
a920 1
log_debug("kroute_matchgw: kr->r.nexthop = %s", inet_ntoa(kr->r.nexthop));
@


1.161
log
@Track nexthops when the underlying route is changing. Until now true nexthops
were only resolved when they were added. This calls for troubles if something
like ospfd starts to change the underlying routes.
Tested by gollo@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.160 2008/05/09 12:45:25 henning Exp $ */
d51 1
d57 1
d93 3
a95 1
struct kroute_node	*kroute_find(in_addr_t, u_int8_t);
d100 4
a103 1
struct kroute6_node	*kroute6_find(const struct in6_addr *, u_int8_t);
d175 1
a176 1
	kr_state.rtableid = rtableid;
d230 3
a232 7
	if ((kr = kroute_find(kl->kr.prefix.s_addr, kl->kr.prefixlen)) !=
	    NULL) {
		if (kr->r.flags & F_BGPD_INSERTED)
			action = RTM_CHANGE;
		else	/* a non-bgp route already exists. not a problem */
			return (0);
	}
d259 1
d285 2
a286 2
	if ((kr = kroute_find(kl->kr.prefix.s_addr, kl->kr.prefixlen)) ==
	    NULL)
d315 3
a317 6
	if ((kr6 = kroute6_find(&kl->kr.prefix, kl->kr.prefixlen)) != NULL) {
		if (kr6->r.flags & F_BGPD_INSERTED)
			action = RTM_CHANGE;
		else	/* a non-bgp route already exists. not a problem */
			return (0);
	}
d345 1
d372 2
a373 1
	if ((kr6 = kroute6_find(&kl->kr.prefix, kl->kr.prefixlen)) == NULL)
d516 2
a517 2
	struct kroute_node	*kr;
	struct kroute6_node	*kr6;
d537 9
a545 4
				if (!flags || kr->r.flags & flags)
					send_imsg_session(IMSG_CTL_KROUTE,
					    imsg->hdr.pid, &kr->r,
					    sizeof(kr->r));
d548 9
a556 4
				if (!flags || kr6->r.flags & flags)
					send_imsg_session(IMSG_CTL_KROUTE6,
					    imsg->hdr.pid, &kr6->r,
					    sizeof(kr6->r));
d808 8
d835 8
d886 1
a886 1
kroute_find(in_addr_t prefix, u_int8_t prefixlen)
d889 1
d893 28
d922 8
a929 1
	return (RB_FIND(kroute_tree, &krt, &s));
d935 1
d939 6
a944 5
	if (RB_INSERT(kroute_tree, &krt, kr) != NULL) {
		log_warnx("kroute_tree insert failed for %s/%u",
		    inet_ntoa(kr->r.prefix), kr->r.prefixlen);
		free(kr);
		return (-1);
d959 3
a961 1
		kr_redistribute(IMSG_NETWORK_ADD, &kr->r);
d966 1
d970 1
d973 2
a974 2
	if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
		log_warnx("kroute_remove failed for %s/%u",
d979 27
d1012 2
a1013 1
	if (kr->r.flags & F_KERNEL)
d1036 1
a1036 1
kroute6_find(const struct in6_addr *prefix, u_int8_t prefixlen)
d1039 1
d1043 32
d1076 1
a1076 1
	return (RB_FIND(kroute6_tree, &krt6, &s));
d1082 1
d1086 6
a1091 5
	if (RB_INSERT(kroute6_tree, &krt6, kr) != NULL) {
		log_warnx("kroute_tree insert failed for %s/%u",
		    log_in6addr(&kr->r.prefix), kr->r.prefixlen);
		free(kr);
		return (-1);
d1108 3
a1110 1
		kr_redistribute6(IMSG_NETWORK_ADD, &kr->r);
d1119 1
d1122 2
a1123 2
	if (RB_REMOVE(kroute6_tree, &krt6, kr) == NULL) {
		log_warnx("kroute_remove failed for %s/%u",
d1128 28
d1162 2
a1163 1
	if (kr->r.flags & F_KERNEL)
d1595 2
a1596 2
		if ((kr =
		    kroute_find(htonl(ina & prefixlen2mask(i)), i)) != NULL)
d1601 1
a1601 1
	if ((kr = kroute_find(0, 0)) != NULL)
d1618 1
a1618 1
		if ((kr6 = kroute6_find(&ina, i)) != NULL)
d1624 1
a1624 1
	if ((kr6 = kroute6_find(&in6addr_any, 0)) != NULL)
a1966 1
	hdr.rtm_flags = RTF_PROTO1;
a2078 1
	hdr.rtm_flags = RTF_PROTO1;
a2222 4
#ifdef RTF_MPATH
		if (rtm->rtm_flags & RTF_MPATH)		/* multipath */
			continue;
#endif
d2233 1
d2266 1
d2318 1
a2318 1
			if (rtm->rtm_flags & RTF_PROTO1)  {
d2327 1
a2327 1
			if (rtm->rtm_flags & RTF_PROTO1)  {
d2494 1
a2494 1
	int			 flags, oflags;
d2497 1
d2515 4
d2520 1
d2552 10
d2565 1
d2567 1
a2567 1
			    prefixlen)) == NULL)
d2571 9
d2584 3
a2586 1
			if ((kr6 = kroute6_find(&prefix.v6, prefixlen)) == NULL)
d2590 10
a2606 9
	if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
		switch (sa->sa_family) {
		case AF_LINK:
			flags |= F_CONNECTED;
			ifindex = rtm->rtm_index;
			sa = NULL;
			break;
		}

d2619 2
a2620 1
		if ((kr = kroute_find(prefix.v4.s_addr, prefixlen)) != NULL) {
d2622 9
d2661 1
d2675 1
d2682 1
a2682 1
		if ((kr6 = kroute6_find(&prefix.v6, prefixlen)) != NULL) {
d2684 10
d2727 1
d2744 1
@


1.160
log
@insert/delete routes with priority RTP_BGP
this is mostly cosmetical for the moment, there are bigger changes required
to make full use of the route priorities, but this is the first step to do.
discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.159 2008/05/08 13:07:22 henning Exp $ */
d121 1
d1378 40
a1499 1

d2452 2
d2506 2
@


1.159
log
@backout shit committed on accident
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.157 2007/11/24 17:01:04 claudio Exp $ */
d1762 1
@


1.158
log
@in timer_set, when figuring out the right position for the timer,
wemust stop walking the list once werun into a stopped timer, or
eventually all stopped timers will queue up at the very front (instead of
at the tail)
@
text
@a2032 2
			if (rtm->rtm_index)
				kr->r.flags |= F_CONNECTED;
a2064 2
			if (rtm->rtm_index)
				kr6->r.flags |= F_CONNECTED;
d2107 4
@


1.157
log
@Another missing RTM_VERSION check. This will remove the RB_INSERT warnings
seen on startup.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.156 2007/11/24 12:59:28 jmc Exp $ */
d2033 2
d2067 2
a2110 4
				if (sa->sa_family == AF_INET)
					kr->r.flags |= F_CONNECTED;
				else if (sa->sa_family == AF_INET6)
					kr6->r.flags |= F_CONNECTED;
@


1.156
log
@some spelling fixes from Martynas Venckus
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.155 2007/10/04 11:43:19 henning Exp $ */
d2173 2
@


1.155
log
@when inserting blackhole or reject routes, set the gateway address to
127.0.0.1 / ::1 unconditioally, since RTF_BLACKHOLE/REJECT are not
actually checked in the forwarding path and the gw doesn't matter otherwise.
makes them work.. found teh hard way by me. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.154 2007/05/11 11:27:59 claudio Exp $ */
d1991 1
a1991 1
		if (rtableid != 0 && errno == EINVAL)	/* table nonexistant */
@


1.154
log
@Various spelling fixes from Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.153 2007/04/19 13:05:48 claudio Exp $ */
d239 4
d308 1
d324 4
@


1.153
log
@Use vectorized writes to send routing messages into the kernel instead of
using a static message structure. This is more flexible and needed if
multipath comes into play.  looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.152 2007/02/22 08:34:18 henning Exp $ */
d445 1
a445 1
		/* should not happen... this is acctually an error path */
d898 1
a898 1
	/* check wether a nexthop depends on this kroute */
d981 1
a981 1
	/* check wether a nexthop depends on this kroute */
d1423 1
a1423 1
	 * check wether there's another nexthop depending on this kroute
@


1.152
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.151 2007/02/07 13:22:55 claudio Exp $ */
d24 1
d1736 7
a1742 7
	struct {
		struct rt_msghdr	hdr;
		struct sockaddr_in	prefix;
		struct sockaddr_in	nexthop;
		struct sockaddr_in	mask;
		struct sockaddr_rtlabel	label;
	} r;
d1747 6
a1752 6
	bzero(&r, sizeof(r));
	r.hdr.rtm_msglen = sizeof(r);
	r.hdr.rtm_version = RTM_VERSION;
	r.hdr.rtm_type = action;
	r.hdr.rtm_tableid = kr_state.rtableid;
	r.hdr.rtm_flags = RTF_PROTO1;
d1754 1
a1754 1
		r.hdr.rtm_flags |= RTF_BLACKHOLE;
d1756 1
a1756 1
		r.hdr.rtm_flags |= RTF_REJECT;
d1758 55
a1812 20
		r.hdr.rtm_fmask = RTF_REJECT|RTF_BLACKHOLE;
	r.hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	r.hdr.rtm_addrs = RTA_DST|RTA_GATEWAY|RTA_NETMASK|RTA_LABEL;
	r.prefix.sin_len = sizeof(r.prefix);
	r.prefix.sin_family = AF_INET;
	r.prefix.sin_addr.s_addr = kroute->prefix.s_addr;

	r.nexthop.sin_len = sizeof(r.nexthop);
	r.nexthop.sin_family = AF_INET;
	r.nexthop.sin_addr.s_addr = kroute->nexthop.s_addr;
	if (kroute->nexthop.s_addr != 0)
		r.hdr.rtm_flags |= RTF_GATEWAY;

	r.mask.sin_len = sizeof(r.mask);
	r.mask.sin_family = AF_INET;
	r.mask.sin_addr.s_addr = htonl(prefixlen2mask(kroute->prefixlen));

	r.label.sr_len = sizeof(r.label);
	strlcpy(r.label.sr_label, rtlabel_id2name(kroute->labelid),
	    sizeof(r.label.sr_label));
d1815 1
a1815 1
	if (write(fd, &r, sizeof(r)) == -1) {
d1818 2
a1819 2
			if (r.hdr.rtm_type == RTM_CHANGE) {
				r.hdr.rtm_type = RTM_ADD;
d1821 1
a1821 1
			} else if (r.hdr.rtm_type == RTM_DELETE) {
d1828 1
a1828 1
				    "prefix %s/%u: %s", r.hdr.rtm_type,
d1836 1
a1836 1
			    r.hdr.rtm_type, inet_ntoa(kroute->prefix),
d1848 7
a1854 7
	struct {
		struct rt_msghdr	hdr;
		struct sockaddr_in6	prefix;
		struct sockaddr_in6	nexthop;
		struct sockaddr_in6	mask;
		struct sockaddr_rtlabel	label;
	} r;
d1859 6
a1864 6
	bzero(&r, sizeof(r));
	r.hdr.rtm_msglen = sizeof(r);
	r.hdr.rtm_version = RTM_VERSION;
	r.hdr.rtm_type = action;
	r.hdr.rtm_tableid = kr_state.rtableid;
	r.hdr.rtm_flags = RTF_PROTO1;
d1866 1
a1866 1
		r.hdr.rtm_flags |= RTF_BLACKHOLE;
d1868 13
a1880 6
		r.hdr.rtm_flags |= RTF_REJECT;
	r.hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	r.hdr.rtm_addrs = RTA_DST|RTA_GATEWAY|RTA_NETMASK|RTA_LABEL;
	r.prefix.sin6_len = sizeof(r.prefix);
	r.prefix.sin6_family = AF_INET6;
	memcpy(&r.prefix.sin6_addr, &kroute->prefix, sizeof(struct in6_addr));
d1882 21
d1904 4
a1907 9
	r.nexthop.sin6_len = sizeof(r.nexthop);
	r.nexthop.sin6_family = AF_INET6;
	memcpy(&r.nexthop.sin6_addr, &kroute->nexthop, sizeof(struct in6_addr));
	if (memcmp(&kroute->nexthop, &in6addr_any, sizeof(struct in6_addr)))
		r.hdr.rtm_flags |= RTF_GATEWAY;

	r.mask.sin6_len = sizeof(r.mask);
	r.mask.sin6_family = AF_INET6;
	memcpy(&r.mask.sin6_addr, prefixlen2mask6(kroute->prefixlen),
d1909 19
a1927 4

	r.label.sr_len = sizeof(r.label);
	strlcpy(r.label.sr_label, rtlabel_id2name(kroute->labelid),
	    sizeof(r.label.sr_label));
d1930 1
a1930 1
	if (write(fd, &r, sizeof(r)) == -1) {
d1933 2
a1934 2
			if (r.hdr.rtm_type == RTM_CHANGE) {
				r.hdr.rtm_type = RTM_ADD;
d1936 1
a1936 1
			} else if (r.hdr.rtm_type == RTM_DELETE) {
d1943 1
a1943 1
				    "prefix %s/%u: %s", r.hdr.rtm_type,
d1951 1
a1951 1
			    r.hdr.rtm_type, log_in6addr(&kroute->prefix),
@


1.151
log
@remove a log_debug() that is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.150 2006/11/28 16:39:34 henning Exp $ */
d762 1
a762 1
	
d765 1
a765 1
	
d2035 2
a2036 1
			} else if (connected_only && !(kr->r.flags & F_CONNECTED))
d2044 2
a2045 1
			} else if (connected_only && !(kr6->r.flags & F_CONNECTED))
d2159 1
a2159 1
			if (rtm->rtm_pid == kr_state.pid)	/* cause by us */
d2162 1
a2162 1
			if (rtm->rtm_errno)			/* failed attempts... */
d2165 1
a2165 1
			if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
d2176 2
a2177 1
			if (dispatch_rtmsg_addr(rtm, rti_info, connected_only) == -1)
@


1.150
log
@allow bgpd to work on alternate routing tables, claudio ok, jmc manpage help
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.149 2006/11/28 16:36:58 henning Exp $ */
a2031 2
log_debug("fetchtable id %u, %s/%u, %s", rtableid, inet_ntoa(kr->r.prefix), kr->r.prefixlen,
kr->r.flags & F_CONNECTED ? "connected" : "");
@


1.149
log
@mib we pass to sysctl when fetching the routing table has 7 entries now,
not 6 any more (rtableid added). need to tell sysctl so.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.148 2006/11/16 15:54:49 henning Exp $ */
d42 1
d135 1
a135 1
int		fetchtable(void);
d138 1
a138 1
		    struct sockaddr *[RTAX_MAX]);
d161 1
a161 1
kr_init(int fs)
d167 1
d203 1
a203 1
	if (fetchtable() == -1)
d205 3
d1750 1
d1827 1
d1887 1
a1887 1
fetchtable(void)
d1905 1
a1905 1
	mib[6] = 0;	/* rtableid */
d1908 2
d2032 2
d2037 3
a2039 1
			} else
d2045 3
a2047 1
			} else
a2049 1

d2136 1
a2151 3
		if (rtm->rtm_tableid != 0)
			continue;

d2168 9
a2176 1
			if (dispatch_rtmsg_addr(rtm, rti_info) == -1)
d2196 2
a2197 1
dispatch_rtmsg_addr(struct rt_msghdr *rtm, struct sockaddr *rti_info[RTAX_MAX])
d2289 3
a2406 1

@


1.148
log
@for now, make bgpd work with routing table 0 (main one) and ignore routing
messages for any other tables.
real multi-table support is more adventurous (will come tho)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.147 2006/08/03 22:40:25 claudio Exp $ */
d1900 1
a1900 1
	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
d1908 1
a1908 1
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
@


1.147
log
@On startup in fetchtable() clean the routing table of all PROTO1 routes.
These may be leftovers from a crash or so and result in an strange
behaving bgpd parent process additionally it causes huge CPU loads because
of a linear list walk done on every insert. Code stolen from ospfd which
does the same thing since a long time ago. This is a temporary fix until
we have real routing priorities and all this PROTO1 flagging can be removed.
PROTO1 is not exclusive to bgpd but for correct operation we currently need
to enforce it.
OK because it is only temporary henning@@
Found and fix tested by Sylwester S. Biernacki
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.146 2006/04/12 14:23:46 henning Exp $ */
d1883 1
a1883 1
	int			 mib[6];
d1898 1
d2136 3
@


1.146
log
@messages on the routing socket have different headers - rt_msghdr,
if_msghdr, etc. they only share the first 3 fields, and then differ.
this leads to a bug in RTM_IFINFO handling. We did abort on
rtm->rtm_errno != 0,
but if_msghdr has no errno, so we look at something in the data part
instead. Surprising that this didn't bite us before!
So we must only do these checks for RTM_ADD/CHANGE/DELETE that actually
use rt_msghdr.
found whiel checking strange behaviour tony sarendal <dualcyclone@@gmail.com>
saw, and then totally strange behaviour on my amd64 hackbox. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.145 2006/03/22 13:30:35 claudio Exp $ */
d2021 13
a2033 4
		if (sa->sa_family == AF_INET)
			kroute_insert(kr);
		else if (sa->sa_family == AF_INET6)
			kroute6_insert(kr6);
@


1.145
log
@Change the way bgpd selects nexthops. Up until now every route was considered
when calculating the nexthop. Now only non BGP routes and not the default
route are used unless forced with the new config options
 nexthop qualify via bgp
 nexthop qualify via default
This change is required for complex setups e.g. where an additional IGP is
running.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.144 2006/02/23 15:25:18 claudio Exp $ */
a2125 8
		sa = (struct sockaddr *)(rtm + 1);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		if (rtm->rtm_pid == kr_state.pid)	/* cause by us */
			continue;

		if (rtm->rtm_errno)			/* failed attempts... */
			continue;
d2131 9
d2142 1
@


1.144
log
@Use the new rtm_fmask feature to reset blackhole and reject routes on
RTM_CHANGE. Until now it was not possible to get rid of these flags.
Until now a fib decouple, fib couple combo was needed to get rid from
blackholed routes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.143 2006/01/31 15:22:15 claudio Exp $ */
d119 2
a120 2
struct kroute_node	*kroute_match(in_addr_t);
struct kroute6_node	*kroute6_match(struct in6_addr *);
d539 1
a539 1
			kr = kroute_match(addr->v4.s_addr);
d545 1
a545 1
			kr6 = kroute6_match(&addr->v6);
d749 1
a749 1
kr_redist_reload(void)
d752 1
d757 4
d1315 1
a1315 1
		if ((kr = kroute_match(kn->nexthop.v4.s_addr)) == NULL) {
d1336 1
a1336 1
		if ((kr6 = kroute6_match(&kn->nexthop.v6)) == NULL) {
d1363 1
a1363 1
kroute_match(in_addr_t key)
d1375 2
a1376 1
			return (kr);
d1380 1
d1387 1
a1387 1
kroute6_match(struct in6_addr *key)
d1397 2
a1398 1
			return (kr6);
d1403 1
@


1.144.2.1
log
@MFC:
Fix by henning@@

messages on the routing socket have different headers - rt_msghdr,
if_msghdr, etc. they only share the first 3 fields, and then differ.
this leads to a bug in RTM_IFINFO handling. We did abort on
rtm->rtm_errno != 0,
but if_msghdr has no errno, so we look at something in the data part
instead. Surprising that this didn't bite us before!
So we must only do these checks for RTM_ADD/CHANGE/DELETE that actually
use rt_msghdr.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.144 2006/02/23 15:25:18 claudio Exp $ */
d2117 8
a2129 9
			sa = (struct sockaddr *)(rtm + 1);
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

			if (rtm->rtm_pid == kr_state.pid)	/* cause by us */
				continue;

			if (rtm->rtm_errno)			/* failed attempts... */
				continue;

a2131 1

@


1.143
log
@Dynamic routes (PMTU, etc) are not redistributable even for IPv6.
Sure henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.142 2005/12/14 00:44:39 claudio Exp $ */
d1741 2
@


1.142
log
@Replace strlcpy() with memcpy() in the sockaddr_dl handling. sdl_data is
not a C string and strlcpy() only works on C strings -- returns length of
the source.  Found by tedu@@ OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.141 2005/09/21 12:50:20 henning Exp $ */
d681 4
@


1.141
log
@when the route to a nexthop is a reject or blackhole route, the nexthop
is invalid. add check for these flags. shows up with v6, many reject routes
there. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.140 2005/07/01 22:00:04 claudio Exp $ */
d2074 2
a2075 2
					strlcpy(kif->k.ifname, sdl->sdl_data,
					    sizeof(kif->k.ifname));
d2077 3
a2079 2
					strlcpy(kif->k.ifname, sdl->sdl_data,
					    sdl->sdl_nlen + 1);
@


1.140
log
@tab after space
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.139 2005/06/24 14:01:53 claudio Exp $ */
d1252 3
d1271 3
@


1.139
log
@Do not automaticaly announce routes that have RTF_DYNAMIC set. These routes
are e.g. created by the PMTU code and are removed after some time.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.138 2005/06/14 15:01:51 claudio Exp $ */
d369 1
a369 1
 	if (kroute6_remove(kr6) == -1)
@


1.138
log
@Don't unref something that is used later. send_rtmsg() will call
rtlabel_id2name() so call rtlable_unref() after that.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.137 2005/06/13 21:16:18 henning Exp $ */
d620 4
d1928 2
d1962 2
d2165 2
@


1.137
log
@route label support, kroute part and ID allocator as well as the internal
interface changes. support in the filter language and rde to come. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.136 2005/06/07 18:56:51 claudio Exp $ */
a281 2
	rtlabel_unref(kl->kr.labelid);

d284 2
@


1.136
log
@Set the reject and blackhole flags for kernel routes too. This makes the
bgpctl show fib output more logical, especially for INET6 because many
prfixes have the reject flag set.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.135 2005/06/07 18:43:31 claudio Exp $ */
d211 1
a211 1
kr_change(struct kroute *kroute)
d216 1
a216 1
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen)) !=
d225 1
a225 1
	if ((kroute->nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
d229 5
a233 1
	if (send_rtmsg(kr_state.fd, action, kroute) == -1)
d241 5
a245 4
		kr->r.prefix.s_addr = kroute->prefix.s_addr;
		kr->r.prefixlen = kroute->prefixlen;
		kr->r.nexthop.s_addr = kroute->nexthop.s_addr;
		kr->r.flags = kroute->flags | F_BGPD_INSERTED;
d250 3
a252 2
		kr->r.nexthop.s_addr = kroute->nexthop.s_addr;
		if (kroute->flags & F_BLACKHOLE)
d256 1
a256 1
		if (kroute->flags & F_REJECT)
d266 1
a266 1
kr_delete(struct kroute *kroute)
d270 1
a270 1
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->prefixlen)) ==
d278 1
a278 1
	if ((kroute->nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
d282 3
a284 1
	if (send_rtmsg(kr_state.fd, RTM_DELETE, kroute) == -1)
d294 1
a294 1
kr6_change(struct kroute6 *kroute)
d299 1
a299 1
	if ((kr6 = kroute6_find(&kroute->prefix, kroute->prefixlen)) != NULL) {
d307 1
a307 1
	if (IN6_IS_ADDR_LOOPBACK(&kroute->nexthop))
d310 5
a314 1
	if (send_rt6msg(kr_state.fd, action, kroute) == -1)
d322 1
a322 1
		memcpy(&kr6->r.prefix, &kroute->prefix,
d324 2
a325 2
		kr6->r.prefixlen = kroute->prefixlen;
		memcpy(&kr6->r.nexthop, &kroute->nexthop,
d327 2
a328 1
		kr6->r.flags = kroute->flags | F_BGPD_INSERTED;
d333 1
a333 1
		memcpy(&kr6->r.nexthop, &kroute->nexthop,
d335 2
a336 1
		if (kroute->flags & F_BLACKHOLE)
d340 1
a340 1
		if (kroute->flags & F_REJECT)
d350 1
a350 1
kr6_delete(struct kroute6 *kroute)
d354 1
a354 1
	if ((kr6 = kroute6_find(&kroute->prefix, kroute->prefixlen)) == NULL)
d361 1
a361 1
	if (IN6_IS_ADDR_LOOPBACK(&kroute->nexthop))
d364 1
a364 1
	if (send_rt6msg(kr_state.fd, RTM_DELETE, kroute) == -1)
d367 3
a369 1
	if (kroute6_remove(kr6) == -1)
d1712 1
d1728 1
a1728 1
	r.hdr.rtm_addrs = RTA_DST|RTA_GATEWAY|RTA_NETMASK;
d1743 4
d1786 1
d1802 1
a1802 1
	r.hdr.rtm_addrs = RTA_DST|RTA_GATEWAY|RTA_NETMASK;
d1818 4
@


1.135
log
@Fix the mask2prefixlen6() function once and for all. Netmasks are stored in
an own AF independent radix tree. So the passed sockaddrs are often smaller
than the actual AF specific struct, especially sockaddr_in6. So the crap
Henning saw in the mask was acctually the next struct sockaddr that was passed
in the routing message. So pass the struct sockaddr_in6 and compare only the
specified number of bytes (minus the offset of sin6_addr in the struct
sockaddr_in6). Amazing!..
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.134 2005/06/06 17:15:07 henning Exp $ */
d1894 4
d1926 4
d2125 7
a2136 2
		if (rtm->rtm_flags & RTF_STATIC)
			flags |= F_STATIC;
a2150 2
		if (rtm->rtm_flags & RTF_STATIC)
			flags |= F_STATIC;
@


1.134
log
@allow show fib to be limited to inet or inet6 families, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.133 2005/06/05 23:59:28 henning Exp $ */
d126 1
a126 1
u_int8_t	mask2prefixlen6(struct in6_addr *);
d1470 1
a1470 1
mask2prefixlen6(struct in6_addr *in6a)
d1472 1
a1472 2
	u_int8_t	 l = 0, i;
	int		 final = 0;
d1474 7
a1480 1
	for (i = 0; i < 16; i ++) {
d1482 1
a1482 1
		switch (in6a->s6_addr[i]) {
d1488 1
a1488 2
			final++;
			break;
d1491 1
a1491 2
			final++;
			break;
d1494 1
a1494 2
			final++;
			break;
d1497 1
a1497 2
			final++;
			break;
d1500 1
a1500 2
			final++;
			break;
d1503 1
a1503 2
			final++;
			break;
d1506 1
a1506 2
			final++;
			break;
d1508 1
a1508 2
			final++;
			break;
d1510 1
a1510 4
			/* XXX why is there crap in the mask??? */
			in6a->s6_addr[i] = 0x00;
			final++;
			break;
a1511 2
		if (final)
			return (l);
d1925 1
a1925 2
				kr6->r.prefixlen =
				    mask2prefixlen6(&sa_in6->sin6_addr);
d2142 1
a2142 1
				prefixlen = mask2prefixlen6(&sa_in6->sin6_addr);
@


1.133
log
@on CTL_KROUTE requests, send back both v4 and v6 routes
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.132 2005/06/05 23:57:33 henning Exp $ */
d485 1
d493 2
a494 1
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(flags)) {
d499 13
a511 8
		RB_FOREACH(kr, kroute_tree, &krt)
			if (!flags || kr->r.flags & flags)
				send_imsg_session(IMSG_CTL_KROUTE,
				    imsg->hdr.pid, &kr->r, sizeof(kr->r));
		RB_FOREACH(kr6, kroute6_tree, &krt6)
			if (!flags || kr6->r.flags & flags)
				send_imsg_session(IMSG_CTL_KROUTE6,
				    imsg->hdr.pid, &kr6->r, sizeof(kr6->r));
@


1.132
log
@work around another disgusting ugliness in v6: the netmasks we get on
the routing socket have crap in the lower bytes, so instead of
using a straightforward and rather simple algorithm to convert them to prefix
lengths we have to do quite some ugly manual fiddling... disgusting.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.131 2005/06/02 15:06:08 cloder Exp $ */
a500 6
	case IMSG_CTL_KROUTE6:
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(flags)) {
			log_warnx("kr_show_route: wrong imsg len");
			return;
		}
		memcpy(&flags, imsg->data, sizeof(flags));
@


1.131
log
@Cleanup recent kroute6 additions. OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.130 2005/05/27 20:01:21 henning Exp $ */
a500 1
		break;
d1471 2
a1472 1
	u_int8_t	 l, i;
d1474 44
a1517 3
	l = 0;
	for (i = 0; i < 16; i ++)
		if (in6a->s6_addr[i] == 0)
d1519 1
a1519 2
		else
			l += 9 - ffs(in6a->s6_addr[i]);
@


1.130
log
@bah, more kaesefondue (debugging cruft left in)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.129 2005/05/27 20:00:35 henning Exp $ */
d306 1
a306 1
		if ((kr6 = calloc(1, sizeof(struct kroute_node))) == NULL) {
d446 1
a446 1
				memcpy(&nh.gateway.v4, &k6->r.nexthop,
d1311 1
a1311 1
					memcpy(&n.gateway.v4, &kr6->r.nexthop,
@


1.129
log
@don't need to fetch the kernel routing twice, once for v4 and once for v6,
do it once and handle both families. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.128 2005/05/27 17:59:50 henning Exp $ */
a630 2
		log_debug("kr_redistribute: ADD %s/%d fl %x",
		    inet_ntoa(kr->prefix), kr->prefixlen, kr->flags);
a641 2
		log_debug("kr_redistribute: DEL %s/%d fl %x",
		    inet_ntoa(kr->prefix), kr->prefixlen, kr->flags);
a699 2
		log_debug("kr_redistribute: ADD %s/%d fl %x",
		    log_in6addr(&kr6->prefix), kr6->prefixlen, kr6->flags);
a710 2
		log_debug("kr_redistribute: DEL %s/%d fl %x",
		    log_in6addr(&kr6->prefix), kr6->prefixlen, kr6->flags);
@


1.128
log
@will throw claudio in a big pot of kaesefondue for repeated whitespace fuckups
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.127 2005/05/27 17:52:11 claudio Exp $ */
a134 1
int		fetchtable6(void);
a203 3
	if (fetchtable6() == -1)
		return (-1);

d1810 1
a1810 1
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
d1812 3
a1814 1
	struct kroute_node	*kr;
d1819 1
a1819 1
	mib[3] = AF_INET;
a1852 10

		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("fetchtable");
			free(buf);
			return (-1);
		}

		kr->r.flags = F_KERNEL;
		kr->r.ifindex = rtm->rtm_index;

d1855 9
d1880 6
a1885 14
		default:
			free(kr);
			continue;
		}

		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
			case AF_INET:
				kr->r.nexthop.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				break;
			case AF_LINK:
				kr->r.flags |= F_CONNECTED;
				break;
d1888 3
a1890 68
		kroute_insert(kr);

	}
	free(buf);
	return (0);
}

int
fetchtable6(void)
{
	size_t			 len;
	int			 mib[6];
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in6	*sa_in6;
	struct kroute6_node	*kr;

	mib[0] = CTL_NET;
	mib[1] = AF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET6;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchtable");
		return (-1);
	}
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		sa = (struct sockaddr *)(rtm + 1);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		if ((sa = rti_info[RTAX_DST]) == NULL)
			continue;

		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
			continue;

#ifdef RTF_MPATH
		if (rtm->rtm_flags & RTF_MPATH)		/* multipath */
			continue;
#endif

		if ((kr = calloc(1, sizeof(struct kroute6_node))) == NULL) {
			log_warn("fetchtable");
			free(buf);
			return (-1);
		}

		kr->r.flags = F_KERNEL;
		kr->r.ifindex = rtm->rtm_index;

		switch (sa->sa_family) {
		case AF_INET6:
			memcpy(&kr->r.prefix,
d1892 1
a1892 1
			    sizeof(kr->r.prefix));
d1896 1
a1896 1
				kr->r.flags |= F_STATIC;
d1900 1
a1900 1
				kr->r.prefixlen =
d1903 1
a1903 1
				kr->r.prefixlen = 128;
a1907 1
			free(kr);
d1911 8
a1918 2
		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
d1920 5
a1924 3
				memcpy(&kr->r.nexthop,
				    &((struct sockaddr_in6 *)sa)->sin6_addr,
				    sizeof(kr->r.nexthop));
d1927 4
a1930 1
				kr->r.flags |= F_CONNECTED;
d1934 4
a1937 1
		kroute6_insert(kr);
@


1.127
log
@kroute6 support, at least partially. Get it in so that Henning can clean it
up more. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.126 2005/05/13 08:34:33 claudio Exp $ */
d525 1
a525 1
		switch(addr->af) {
d616 2
a617 3
	/*
	 * Consider networks with nexthop loopback as not redistributable.
	 */
d620 1
a620 1
	
d628 1
a628 4
	/* Add or delete kr from list ...
	 * using a linear list to store the redistributed networks will hurt
	 * as soon as redistribute ospf comes but until the keep it simple.
	 */
d659 1
a659 1
	
d683 1
a683 1
	
d689 1
a689 1
	
d732 1
a732 1
	
d932 1
a932 1
			       	    kr->r.prefixlen);
d1969 1
a1969 1
			
@


1.126
log
@The NET_RT_IFLIST sysctl returns RTM_IFINFO and RTM_NEWADDR messages in
the buffer. While RTM_IFINFO starts with a struct if_msghdr RTM_NEWADDR
does not. In other words (struct sockaddr *)(next + sizeof(ifm)) is only
correct for RTM_IFINFO and not for RTM_NEWADDR. So move the ifm_type check
up else get_rtaddrs() would access memory outside of buf.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.125 2005/04/28 13:54:45 claudio Exp $ */
d59 1
a59 1
	struct kroute_node	*kroute;
d67 5
d73 1
d79 1
d83 1
d94 5
d112 3
d117 1
d120 1
a120 2
void			 kroute_attach_nexthop(struct knexthop_node *,
			    struct kroute_node *);
d132 1
d135 1
d137 2
d195 1
d205 3
d289 74
d369 1
d377 1
d387 3
d398 1
d406 3
d427 1
a427 1
		/* should not happen... this is really an error path */
d429 2
d434 5
a438 4
		if (h->kroute != NULL) {
			nh.valid = 1;
			nh.connected = h->kroute->r.flags & F_CONNECTED;
			if (h->kroute->r.nexthop.s_addr != 0) {
d441 1
a441 1
				    h->kroute->r.nexthop.s_addr;
d443 11
a453 1
			memcpy(&nh.kr.kr4, &h->kroute->r, sizeof(nh.kr.kr4));
d455 1
d486 1
d492 1
d506 11
d525 2
a526 1
		if (addr->af == AF_INET)
d528 11
a538 3
		if (kr != NULL)
			send_imsg_session(IMSG_CTL_KROUTE, imsg->hdr.pid,
			    &kr->r, sizeof(kr->r));
d545 13
a557 3
				snh.valid = kroute_validate(&h->kroute->r);
				if ((kif = kif_find(h->kroute->r.ifindex)) !=
				    NULL)
d593 1
d596 1
d664 74
a737 1
	return (bgpd_redistribute(type, kr));
d746 1
a746 1
		if (bgpd_redistribute(IMSG_NETWORK_ADD, rn->kr) == -1)
d907 83
d1054 1
d1069 1
d1083 7
d1162 59
d1260 17
d1281 1
d1285 4
a1288 2
	if (kn->kroute != NULL)
		was_valid = kroute_validate(&kn->kroute->r);
d1306 1
a1306 1
				memcpy(&n.kr, &kr->r, sizeof(n.kr));
d1312 26
a1337 1
			kroute_attach_nexthop(kn, kr);
d1365 2
a1366 2
void
kroute_attach_nexthop(struct knexthop_node *kn, struct kroute_node *kr)
d1368 17
a1384 3
	kn->kroute = kr;
	kr->r.flags |= F_NEXTHOP;
}
d1390 2
d1405 12
a1416 2
	if (s == NULL)
		kn->kroute->r.flags &= ~F_NEXTHOP;
d1430 1
d1444 12
d1565 1
d1599 1
a1599 1
				if (kroute_validate(&n->kroute->r)) {
d1606 30
a1635 1
				memcpy(&nh.kr, &kkr->kr->r, sizeof(nh.kr));
d1741 71
d1911 101
a2090 6
	struct sockaddr_in	*sa_in;
	struct kroute_node	*kr;
	struct in_addr		 prefix, nexthop;
	u_int8_t		 prefixlen;
	int			 flags, oflags;
	u_short			 ifindex;
a2107 6
		prefix.s_addr = 0;
		prefixlen = 0;
		flags = F_KERNEL;
		nexthop.s_addr = 0;
		ifindex = 0;

a2113 39
		if (rtm->rtm_type == RTM_ADD || rtm->rtm_type == RTM_CHANGE ||
		    rtm->rtm_type == RTM_DELETE) {
			if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
				continue;
			switch (sa->sa_family) {
			case AF_INET:
				prefix.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				sa_in = (struct sockaddr_in *)
				    rti_info[RTAX_NETMASK];
				if (rtm->rtm_flags & RTF_STATIC)
					flags |= F_STATIC;
				if (sa_in != NULL) {
					if (sa_in->sin_len != 0)
						prefixlen = mask2prefixlen(
						    sa_in->sin_addr.s_addr);
				} else if (rtm->rtm_flags & RTF_HOST)
					prefixlen = 32;
				else
					prefixlen =
					    prefixlen_classful(prefix.s_addr);
				break;
			default:
				continue;
			}
		}

		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
			case AF_INET:
				nexthop.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				break;
			case AF_LINK:
				flags |= F_CONNECTED;
				ifindex = rtm->rtm_index;
				break;
			}

a2116 49
			if (nexthop.s_addr == 0 && !(flags & F_CONNECTED)) {
				log_warnx("dispatch_rtmsg no nexthop for %s/%u",
				    inet_ntoa(prefix), prefixlen);
				continue;
			}

			if ((kr = kroute_find(prefix.s_addr, prefixlen)) !=
			    NULL) {
				if (kr->r.flags & F_KERNEL) {
					kr->r.nexthop.s_addr = nexthop.s_addr;
					if (kr->r.flags & F_NEXTHOP)
						flags |= F_NEXTHOP;
					oflags = kr->r.flags;
					kr->r.flags = flags;
					if ((oflags & F_CONNECTED) &&
					    !(flags & F_CONNECTED)) {
						kif_kr_remove(kr);
						kr_redistribute(
						    IMSG_NETWORK_REMOVE,
						    &kr->r);
					}
					if ((flags & F_CONNECTED) &&
					    !(oflags & F_CONNECTED)) {
						kif_kr_insert(kr);
						kr_redistribute(
						    IMSG_NETWORK_ADD,
						    &kr->r);
					}
				}
			} else if (rtm->rtm_type == RTM_CHANGE) {
				log_warnx("change req for %s/%u: not "
				    "in table", inet_ntoa(prefix),
				    prefixlen);
				continue;
			} else {
				if ((kr = calloc(1,
				    sizeof(struct kroute_node))) == NULL) {
					log_warn("dispatch_rtmsg");
					return (-1);
				}
				kr->r.prefix.s_addr = prefix.s_addr;
				kr->r.prefixlen = prefixlen;
				kr->r.nexthop.s_addr = nexthop.s_addr;
				kr->r.flags = flags;
				kr->r.ifindex = ifindex;

				kroute_insert(kr);
			}
			break;
d2118 1
a2118 4
			if ((kr = kroute_find(prefix.s_addr, prefixlen)) ==
			    NULL)
				continue;
			if (!(kr->r.flags & F_KERNEL))
d2120 1
a2120 1
			if (kroute_remove(kr) == -1)
d2138 205
@


1.125
log
@Support for "network connected" and "network static" -- announce all
directly connected respectively all static routes. The list is auto-
matically adjusted as soon as a route changes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.124 2005/04/28 13:49:12 claudio Exp $ */
d1381 3
a1385 3

		if (ifm.ifm_type != RTM_IFINFO)
			continue;
@


1.124
log
@Be more careful when copying ifname from the struct sockaddr_dl.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.123 2005/04/18 11:07:55 claudio Exp $ */
d75 1
d437 86
d634 2
d657 3
d1430 1
a1430 1
	int			 flags;
d1515 4
a1518 2
					if ((kr->r.flags & F_CONNECTED) &&
					    !(flags & F_CONNECTED))
d1520 4
d1525 1
a1525 1
					    !(kr->r.flags & F_CONNECTED))
d1527 4
a1530 1
					kr->r.flags = flags;
@


1.123
log
@Set flag F_STATIC based on RTF_STATIC and not just because the route came
from the kernel. That's what F_KERNEL is for. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.122 2005/04/08 00:07:18 henning Exp $ */
d1311 1
a1311 1
				if (sdl->sdl_nlen > 0)
d1314 3
@


1.122
log
@don't whine when we can't find interface with index 0
(that is a rare corner case in that context, but still)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.121 2005/03/30 11:13:05 henning Exp $ */
a536 3
		if (!(kr->r.flags & F_CONNECTED))
			kr->r.flags |= F_STATIC;

d1218 2
d1376 2
@


1.121
log
@interface validation cleanup / fixes
there's some nastiness in the interface validation.
clean up by centralizing the checks in kif_validate().
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.120 2005/03/29 11:20:01 henning Exp $ */
d781 5
a785 4
		log_warnx("interface with index %d not found, "
		    "referenced from route for %s/%u",
		    kr->ifindex, inet_ntoa(kr->prefix),
		    kr->prefixlen);
@


1.120
log
@explicitely check interface flags for IFF_UP in kroute_validate
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.119 2005/03/28 14:40:04 henning Exp $ */
d98 2
a99 1
int			 kroute_validate(struct kroute *kr);
d707 5
d758 18
a779 3
	if (kr->flags & F_DOWN)
		return (0);

d788 1
a788 4
	if (!(kif->k.flags & IFF_UP))
		return (0);

	return (kif->k.link_state != LINK_STATE_DOWN);
d1029 1
a1029 2
	if ((reachable = (flags & IFF_UP) &&
	    (ifd->ifi_link_state != LINK_STATE_DOWN)) == kif->k.nh_reachable)
a1034 5
		/*
		 * we treat link_state == LINK_STATE_UNKNOWN as valid
		 * not all interfaces have a concept of "link state" and/or
		 * do not report up
		 */
d1306 1
a1306 2
		kif->k.nh_reachable = (kif->k.flags & IFF_UP) &&
		    (ifm.ifm_data.ifi_link_state != LINK_STATE_DOWN);
@


1.119
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.118 2005/03/26 23:04:34 claudio Exp $ */
d765 6
a770 2
	} else
		return (kif->k.link_state != LINK_STATE_DOWN);
@


1.118
log
@inet_addr("127.0.0.1") -> htonl(INADDR_LOOPBACK)
Use IN_CLASSA_NET instead of hard coded 0xff000000
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.117 2005/03/15 10:18:39 henning Exp $ */
d401 4
a404 2
				if ((kif = kif_find(h->kroute->r.ifindex)) != NULL)
					memcpy(&snh.kif, &kif->k, sizeof(snh.kif));
@


1.117
log
@grow the receive buffer on the routing socket, pointed out by markus,
ok markus claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.116 2005/03/14 12:25:50 henning Exp $ */
d203 2
a204 2
	if ((kroute->nexthop.s_addr & htonl(0xff000000)) ==
	    inet_addr("127.0.0.0"))
d250 2
a251 2
	if ((kroute->nexthop.s_addr & htonl(0xff000000)) ==
	    inet_addr("127.0.0.0"))
d872 1
a872 1
	kr->r.prefix.s_addr = inet_addr("127.0.0.1");
@


1.116
log
@send a kif structure describing the interface a route relies on along
with the "show nexthop" messages, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.115 2005/03/14 08:44:33 henning Exp $ */
d141 2
a142 1
	int	opt = 0;
d155 13
@


1.115
log
@"we notice when you plug the cable" - yeah, but we didn't notice when it
was unplugged from the beginning on...
correctly take interfaces' link state into account for nexthop verification
in all cases.
add a new function kroute_validate() that looks up the interface for a given
kroute via the ifindex and check its link state. use it in all cases instead
of hand-rolling the test. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.112 2004/11/24 22:57:18 henning Exp $ */
d385 1
a385 1
			if (h->kroute != NULL)
d387 3
@


1.114
log
@when fetching the initial table, inherit the ifindex regardless of af, not
just for AF_LINK
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.113 2005/03/13 15:34:37 henning Exp $ */
d98 1
d386 1
a386 2
				if (!(h->kroute->r.flags & F_DOWN))
					snh.valid = 1;
d732 18
d757 2
a758 2
	if (kn->kroute != NULL && (!(kn->kroute->r.flags & F_DOWN)))
		was_valid = 1;
d770 1
a770 4
			if (kr->r.flags & F_DOWN) {		/* is down */
				if (was_valid)
					send_nexthop_update(&n);
			} else {				/* valid */
d778 4
a781 1
			}
d1010 1
a1010 1
				if (!(kkr->kr->r.flags & F_DOWN)) {
@


1.113
log
@explicitely initialize opt
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.112 2004/11/24 22:57:18 henning Exp $ */
d1160 1
a1190 1
				kr->r.ifindex = rtm->rtm_index;
@


1.112
log
@if I would remember at what I looked when learning how to use our wonderful
RB_* macros I could fix the RB_HEAD calls there too... useless extra define,
nothingthat hurts much. stumbled over while hacking on, eh, something new,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.111 2004/11/10 14:48:25 claudio Exp $ */
d140 1
a140 1
	int opt;
@


1.111
log
@"not reached" does not help LINT use NOTREACHED instead and use it only in
places where needed. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.110 2004/10/19 12:02:50 henning Exp $ */
d117 1
a117 1
RB_HEAD(kroute_tree, kroute_node)	kroute_tree, krt;
d121 1
a121 1
RB_HEAD(kroute6_tree, kroute6_node)	kroute6_tree, krt6;
d125 1
a125 1
RB_HEAD(knexthop_tree, knexthop_node)	knexthop_tree, knt;
d129 1
a129 1
RB_HEAD(kif_tree, kif_node)		kif_tree, kit;
@


1.110
log
@allow neighbor definitions to depend on interface state.
with this, if a neighbor is configured as dependent on carp0 for example,
the neighbor will remain in state IDLE as long as carp0 is not master.
once carp0 becomes master the session(s) depending on it immediately
go to CONNECT (or ACTIVE, if they're configured passive), reducing failover
time. claudio ok, with some input from ryan as well
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.108 2004/10/16 09:33:03 henning Exp $ */
a1179 1
			/* not reached */
a1335 1
				/* not reached */
@


1.109
log
@oups, unrelated changes crept in
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.107 2004/08/19 10:38:34 henning Exp $ */
d403 13
d967 2
@


1.108
log
@prefixlen 0 is a special case for prefixlen2mask() as well, claudio ok
@
text
@a402 13
void
kr_ifinfo(char *ifname)
{
	struct kif_node	*kif;

	RB_FOREACH(kif, kif_tree, &kit)
		if (!strcmp(ifname, kif->k.ifname)) {
			send_imsg_session(IMSG_IFINFO, 0,
			    &kif->k, sizeof(kif->k));
			return;
		}
}

a953 2

	send_imsg_session(IMSG_IFINFO, 0, &kif->k, sizeof(kif->k));
@


1.107
log
@logic error: when there's changes affecting nexthop reachability,
always notify the RDE and not only if the nexthop was previously unreachable,
i.e. its validity changed.
found the hard way by Arvid Grtting <arvidg@@netfonds.no>, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.106 2004/08/05 15:58:21 claudio Exp $ */
d403 13
d891 3
d967 2
@


1.106
log
@rename and move prefix_equal() to prefix_compare() which returns -1, 0, 1
similar to memcmp() and all other compare functions in bgpd. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.105 2004/08/03 13:34:06 claudio Exp $ */
d743 7
a749 9
				if (!was_valid) {
					n.valid = 1;
					n.connected = kr->r.flags & F_CONNECTED;
					if ((n.gateway.v4.s_addr =
					    kr->r.nexthop.s_addr) != 0)
						n.gateway.af = AF_INET;
					memcpy(&n.kr, &kr->r, sizeof(n.kr));
					send_nexthop_update(&n);
				}
@


1.105
log
@Make the code more portable by #ifdef-ing RTF_MPATH. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.104 2004/07/13 17:57:20 jaredy Exp $ */
a896 37
}

int
prefix_equal(const struct bgpd_addr *a, const struct bgpd_addr *b,
    int prefixlen)
{
	in_addr_t	mask;
	int		i;
	u_int8_t	m;

	if (a->af != b->af)
		return 0;
	switch (a->af) {
	case AF_INET:
		if (prefixlen > 32)
			fatalx("prefix_cmp: bad IPv4 prefixlen");
		mask = htonl(prefixlen2mask(prefixlen));
		if ((a->v4.s_addr & mask) == (b->v4.s_addr & mask))
			return (1);
		else
			return (0);
	case AF_INET6:
		for (i = 0; i < prefixlen / 8; i++)
			if (a->v6.s6_addr[i] != b->v6.s6_addr[i])
				return (0);
		i = prefixlen % 8;
		if (i) {
			m = 0xff00 >> i;
			if ((a->v6.s6_addr[prefixlen / 8] & m) !=
			    (b->v6.s6_addr[prefixlen / 8] & m))
				return (0);
		}
		return (1);
	default:
		fatalx("prefix_cmp: unknown af");
	}
	return (0);
@


1.104
log
@fix some typos

ok henning otto
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.103 2004/07/05 16:54:53 henning Exp $ */
d1169 1
d1172 1
@


1.103
log
@implement "set nexthop blackhole" and "set nexthop reject"
blackhole/reject routes will be entered to the kernel for matching ones.
this is intended to be used with the Cymru Bogon Route Server Project
(http://www.cymru.com/BGP/bogon-rs.html) and similar services, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.102 2004/07/05 02:13:44 henning Exp $ */
d1000 1
a1000 1
		 * not all interfaces have a conecpt of "link state" and/or
@


1.102
log
@fix a few KNF fallouts
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.101 2004/06/29 20:13:07 henning Exp $ */
d203 1
a203 1
		kr->r.flags = F_BGPD_INSERTED;
d207 1
a207 1
	} else
d209 9
d1073 5
a1077 1
	r.hdr.rtm_flags = RTF_GATEWAY|RTF_PROTO1;
d1083 1
d1087 3
@


1.101
log
@little extra paranoia, ignore attempts to enter routes with a nexthop
within 127/8. inspired by a very bad example for bogon filters at the
cymru site, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.100 2004/06/25 20:08:46 henning Exp $ */
d866 1
a866 1
} 
d897 1
a897 1
	
d916 1
a916 1
			if ((a->v6.s6_addr[prefixlen / 8] & m) != 
@


1.100
log
@provide mask2prefixlen6() and prefixlen2mask6()
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.99 2004/06/25 18:48:18 henning Exp $ */
d187 5
d223 5
@


1.99
log
@after writing and deleting the kroute6 tree related functions for at least 5
times I am getting this in now sow I don't do it a 7th time...
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.98 2004/06/22 20:28:58 claudio Exp $ */
d107 1
d843 15
d862 16
@


1.98
log
@Make the RDE IPv6 ready missing is the message handling. The internal
prefix tree changed form a hash table to a per AF RB tree.
OK henning@@ some ideas are from Brent Graveland.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.97 2004/06/22 07:22:31 henning Exp $ */
d51 5
d76 1
d120 4
d394 19
@


1.97
log
@introduce kroute6, which will be used to build a seperate v6 table
(smashing them into the v4 table would raise the memory requirements far too
much), and make kroute_nexthop (where we are not under such memory pressure,
you don't have a hundred thousand nexthops) v4/v6. change existing callers
to use the v4 part, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.96 2004/06/20 19:16:53 henning Exp $ */
a100 1
in_addr_t	prefixlen2mask(u_int8_t);
d817 54
@


1.96
log
@skip over multipath routes
maybe one day we come up with a good reason for bgpd to use multipath
routes, but for now it doesn't make any sense - bgpd inserts the "best"
path fr a prefix, there's no point in inserting more than one. one is
always the "best" one by bgp metrics.
with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.95 2004/05/08 06:04:57 henning Exp $ */
d287 1
a287 1
			memcpy(&nh.kr, &h->kroute->r, sizeof(nh.kr));
@


1.95
log
@implement and use prefixlen2mask() instead of doing it by hand 3 times
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.94 2004/04/28 01:13:18 deraadt Exp $ */
d1026 3
@


1.94
log
@remove XXX that is wrong
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.93 2004/04/27 04:38:12 deraadt Exp $ */
d101 1
d459 1
a459 1
		mask = 0xffffffff << (32 - kr->r.prefixlen);
d722 2
a723 2
		if ((kr = kroute_find(
		    htonl(ina & (0xffffffff << (32 - i))), i)) != NULL)
d814 6
d951 1
a951 1
	r.mask.sin_addr.s_addr = htonl(0xffffffff << (32 - kroute->prefixlen));
@


1.93
log
@crud stripping; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.92 2004/03/10 13:00:42 henning Exp $ */
d947 1
a947 1
	if (write(fd, &r, sizeof(r)) == -1) {	/* XXX never partial? */
@


1.92
log
@on shutdown, explicitely clear the knexthop, kroute and kif tables, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.89 2004/03/04 11:26:36 henning Exp $ */
a924 1
	ssize_t	n;
d947 1
a947 1
	if ((n = write(fd, &r, sizeof(r))) == -1) {
@


1.91
log
@in kif_kr_insert and _remove, don't whine when we do not find an interface
whom's index is 0. this means no interface and our faked route that protects
the loopback network uses ifindex 0. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.90 2004/03/10 12:55:35 henning Exp $ */
d77 1
d82 1
d87 1
d222 3
d499 9
d548 9
d601 9
@


1.90
log
@remove an ugly hack from the time when we had no RTM_IFANNOUNCE messages:
if kif_find() did not find a matchnit re-fetched the complete table from the
kernel and retried. this is obsolete now, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.89 2004/03/04 11:26:36 henning Exp $ */
d586 3
a588 2
		log_warnx("interface with index %u not found",
		    kr->r.ifindex);
d611 3
a613 2
		log_warnx("interface with index %u not found",
		    kr->r.ifindex);
@


1.89
log
@no ; after RB_PROTOTYPE / RB_GENERATE
From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.88 2004/03/03 17:08:45 henning Exp $ */
d536 1
a536 1
	struct kif_node	*kif, s;
a540 5
	if ((kif = RB_FIND(kif_tree, &kit, &s)) != NULL)
		return (kif);

	/* check wether the interface showed up now */
	fetchifs(ifindex);
@


1.88
log
@plug a couple of little memory leaks in error paths that we hopefully never
reach - except for one missing free which was not in an error path. oups. at
least in a function that is only called once ever in bgpd's lifetime.
From: Patrick Latifi <pat at eyeo dot org>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.87 2004/02/29 11:14:19 claudio Exp $ */
d108 2
a109 2
RB_PROTOTYPE(kroute_tree, kroute_node, entry, kroute_compare);
RB_GENERATE(kroute_tree, kroute_node, entry, kroute_compare);
d112 2
a113 2
RB_PROTOTYPE(knexthop_tree, knexthop_node, entry, knexthop_compare);
RB_GENERATE(knexthop_tree, knexthop_node, entry, knexthop_compare);
d116 2
a117 2
RB_PROTOTYPE(kif_tree, kif_node, entry, kif_compare);
RB_GENERATE(kif_tree, kif_node, entry, kif_compare);
@


1.87
log
@Make sure that the fib output is nicely sorted. Use ntohl to compare
IP addresses so the tree gets correctly populated. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.86 2004/02/07 01:50:28 henning Exp $ */
d976 1
d994 1
d1017 1
d1069 1
d1084 1
d1106 1
@


1.86
log
@when connected routes show up at runtime we have to set ifindex in struct kif
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.85 2004/02/07 01:41:52 henning Exp $ */
d374 1
a374 1
	if (a->r.prefix.s_addr < b->r.prefix.s_addr)
d376 1
a376 1
	if (a->r.prefix.s_addr > b->r.prefix.s_addr)
@


1.85
log
@houps, fetchtable() had the default route special cased... bad.
sin_len == 0 here too.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.84 2004/02/07 01:28:13 henning Exp $ */
d1224 1
@


1.84
log
@the sockaddr holding the netmask and advertised by rtm_addrs might
mave sa_len == 0 to indicate a mask of /0
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.83 2004/02/07 00:16:14 henning Exp $ */
d1003 3
a1005 3
			if (kr->r.prefix.s_addr == 0)	/* default route */
				kr->r.prefixlen = 0;
			else if (sa_in != NULL)
d1008 1
a1008 1
			else if (rtm->rtm_flags & RTF_HOST)
@


1.83
log
@sin_family in the sockaddr_n representing the netmask we sniffed on the
routing socket is meaningless. so we're better off not checking it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.82 2004/01/30 15:44:46 henning Exp $ */
d1158 5
a1162 4
				if (sa_in != NULL)
					prefixlen = mask2prefixlen(
					    sa_in->sin_addr.s_addr);
				else if (rtm->rtm_flags & RTF_HOST)
@


1.82
log
@please sparc64, with & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.81 2004/01/28 01:56:26 henning Exp $ */
d1158 1
a1158 3
				if (sa_in != NULL) {
					if (sa_in->sin_family != AF_INET)
						continue;
d1161 1
a1161 1
				} else if (rtm->rtm_flags & RTF_HOST)
@


1.81
log
@log & ignore RTM_CHANGE messages for that we don't find an exact match
apparently pppd loves to issue change messages twice, once with and once without
netmask, and in the latter case we have to play the classless game, which
could lead to additional entries with wrong netmask in our internal view
of the routing table.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.80 2004/01/27 22:15:13 henning Exp $ */
d1044 1
a1044 1
	struct if_msghdr	*ifm;
d1070 4
a1073 4
	for (next = buf; next < lim; next += ifm->ifm_msglen) {
		ifm = (struct if_msghdr *)next;
		sa = (struct sockaddr *)(ifm + 1);
		get_rtaddrs(ifm->ifm_addrs, sa, rti_info);
d1075 1
a1075 1
		if (ifm->ifm_type != RTM_IFINFO)
d1083 5
a1087 5
		kif->k.ifindex = ifm->ifm_index;
		kif->k.flags = ifm->ifm_flags;
		kif->k.link_state = ifm->ifm_data.ifi_link_state;
		kif->k.media_type = ifm->ifm_data.ifi_type;
		kif->k.baudrate = ifm->ifm_data.ifi_baudrate;
d1089 1
a1089 1
		    (ifm->ifm_data.ifi_link_state != LINK_STATE_DOWN);
d1111 1
a1111 1
	struct if_msghdr	*ifm;
d1239 3
a1241 3
			ifm = (struct if_msghdr *)next;
			if_change(ifm->ifm_index, ifm->ifm_flags,
			    &ifm->ifm_data);
@


1.80
log
@make rt_sendmsg's local nextop and prefix struct in_addr too and don't use
log_ntoa, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.79 2004/01/27 21:56:21 henning Exp $ */
d1210 5
@


1.79
log
@move strict kroute from in_addr_t for nexthop and prefix to struct in_addr
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.78 2004/01/23 21:18:12 henning Exp $ */
d1115 1
a1115 1
	in_addr_t		 prefix, nexthop;
d1136 1
a1136 1
		prefix = 0;
d1139 1
a1139 1
		nexthop = 0;
d1154 1
a1154 1
				prefix =
d1166 2
a1167 1
					prefixlen = prefixlen_classful(prefix);
d1178 1
a1178 1
				nexthop =
d1190 1
a1190 1
			if (nexthop == 0 && !(flags & F_CONNECTED)) {
d1192 1
a1192 1
				    log_ntoa(prefix), prefixlen);
d1196 1
a1196 1
			if ((kr = kroute_find(prefix, prefixlen)) !=
d1199 1
a1199 1
					kr->r.nexthop.s_addr = nexthop;
d1216 1
a1216 1
				kr->r.prefix.s_addr = prefix;
d1218 1
a1218 1
				kr->r.nexthop.s_addr = nexthop;
d1225 2
a1226 1
			if ((kr = kroute_find(prefix, prefixlen)) == NULL)
@


1.78
log
@use log_addr
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.77 2004/01/22 20:34:56 henning Exp $ */
d165 1
a165 1
	if ((kr = kroute_find(kroute->prefix, kroute->prefixlen)) !=
d181 1
a181 1
		kr->r.prefix = kroute->prefix;
d183 1
a183 1
		kr->r.nexthop = kroute->nexthop;
d189 1
a189 1
		kr->r.nexthop = kroute->nexthop;
d199 2
a200 1
	if ((kr = kroute_find(kroute->prefix, kroute->prefixlen)) == NULL)
d275 1
a275 1
			if (h->kroute->r.nexthop != 0) {
d277 2
a278 1
				nh.gateway.v4.s_addr = h->kroute->r.nexthop;
d374 1
a374 1
	if (a->r.prefix < b->r.prefix)
d376 1
a376 1
	if (a->r.prefix > b->r.prefix)
d429 1
a429 1
	s.r.prefix = prefix;
d443 1
a443 1
		    log_ntoa(kr->r.prefix), kr->r.prefixlen);
d453 1
a453 1
		ina = ntohl(kr->r.prefix);
d473 1
a473 1
		    log_ntoa(kr->r.prefix), kr->r.prefixlen);
d668 1
a668 1
					    kr->r.nexthop) != 0)
d747 1
a747 1
	kr->r.prefix = inet_addr("127.0.0.1");
a748 1
	kr->r.nexthop = 0;
d847 1
a847 1
					    kkr->kr->r.nexthop) != 0)
d909 1
a909 1
	r.prefix.sin_addr.s_addr = kroute->prefix;
d912 1
a912 1
	r.nexthop.sin_addr.s_addr = kroute->nexthop;
d926 1
a926 1
				    log_ntoa(kroute->prefix),
d932 2
a933 2
				    log_ntoa(kroute->prefix), kroute->prefixlen,
				    strerror(errno));
d939 1
a939 1
			    r.hdr.rtm_type, log_ntoa(kroute->prefix),
d1000 1
a1000 1
			kr->r.prefix =
d1003 1
a1003 1
			if (kr->r.prefix == 0)	/* default route */
d1012 1
a1012 1
				    prefixlen_classful(kr->r.prefix);
d1022 1
a1022 1
				kr->r.nexthop =
d1198 1
a1198 1
					kr->r.nexthop = nexthop;
d1215 1
a1215 1
				kr->r.prefix = prefix;
d1217 1
a1217 1
				kr->r.nexthop = nexthop;
@


1.77
log
@use log_warnx and log_info. reclassify a few messages in the process and fix
a few messages.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.76 2004/01/22 03:18:04 henning Exp $ */
d506 1
a506 1
			    log_ntoa(kn->nexthop.v4.s_addr));
d523 1
a523 1
		    log_ntoa(kn->nexthop.v4.s_addr));
@


1.76
log
@s/log_err/log_warn/
it is like warn(3), nor err(3). so use a less confusing name.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.75 2004/01/22 03:07:51 henning Exp $ */
d234 1
a234 1
	logit(LOG_INFO, "kernel routing table coupled");
d251 1
a251 1
	logit(LOG_INFO, "kernel routing table decoupled");
d319 1
a319 1
			logit(LOG_CRIT, "kr_show_route: wrong imsg len");
d331 1
a331 1
			logit(LOG_CRIT, "kr_show_route: wrong imsg len");
d440 1
a440 1
		logit(LOG_CRIT, "kroute_tree insert failed for %s/%u",
d470 1
a470 1
		logit(LOG_CRIT, "kroute_remove failed for %s/%u",
d505 1
a505 1
		logit(LOG_CRIT, "knexthop_tree insert failed for %s",
d522 1
a522 1
		logit(LOG_CRIT, "knexthop_remove failed for %s",
d553 1
a553 1
		logit(LOG_CRIT, "RB_INSERT(kif_tree, &kit, kif)");
d567 1
a567 1
		logit(LOG_CRIT, "RB_REMOVE(kif_tree, &kit, kif)");
d589 1
a589 1
		logit(LOG_CRIT, "interface with index %u not found",
d613 1
a613 1
		logit(LOG_CRIT, "interface with index %u not found",
d623 1
a623 1
		logit(LOG_CRIT, "can't remove connected route from interface "
d810 1
a810 1
		logit(LOG_CRIT, "interface with index %u not found",
d924 1
a924 2
				logit(LOG_INFO,
				    "route %s/%u vanished before delete",
d929 1
a929 2
				logit(LOG_CRIT,
				    "send_rtmsg: action %u, "
d937 1
a937 2
			logit(LOG_CRIT,
			    "send_rtmsg: action %u, prefix %s/%u: %s",
d1125 1
a1125 1
		logit(LOG_CRIT, "routing socket closed");
d1189 1
a1189 2
				logit(LOG_CRIT,
				    "dispatch_rtmsg: no nexthop for %s/%u",
@


1.75
log
@an RTM_IFINFO message can mean a lot. it does not necessarily mean that
the status of the interface in terms of our nexthop validation changed;
it might be something like a speed change that we don't care about.
save the decided state for nexthop verificartion in struct kif, and only
walk through the attached (connected) routes & report upwards if the state
actually changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.74 2004/01/18 19:15:00 henning Exp $ */
d131 1
a131 1
		log_err("kr_init: socket");
d138 1
a138 1
		log_err("kr_init: setsockopt");	/* not fatal */
d178 1
a178 1
			log_err("kr_change");
d283 1
a283 1
			log_err("kr_nexthop_add");
d595 1
a595 1
		log_err("kif_kr_insert");
d742 1
a742 1
		log_err("protect_lo");
d866 1
a866 1
			log_err("if_announce");
d969 1
a969 1
		log_err("sysctl");
d973 1
a973 1
		log_err("fetchtable");
d977 1
a977 1
		log_err("sysctl");
d994 1
a994 1
			log_err("fetchtable");
d1059 1
a1059 1
		log_err("sysctl");
d1063 1
a1063 1
		log_err("fetchif");
d1067 1
a1067 1
		log_err("sysctl");
d1081 1
a1081 1
			log_err("fetchifs");
d1123 1
a1123 1
		log_err("dispatch_rtmsg: read error");
d1215 1
a1215 1
					log_err("dispatch_rtmsg");
@


1.74
log
@track interface type and baudrate as well

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.73 2004/01/17 21:06:55 henning Exp $ */
d807 1
d820 6
d832 1
a832 1
		if ((flags & IFF_UP) && (kif->k.link_state != LINK_STATE_DOWN))
d1090 2
@


1.73
log
@keep track of interface link state and invalidate connected routes depending
on the interface in question if it has no link
now, if you pull the network cable all nexthops beeing in a connected
network on this interface get invalidated nicely.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.72 2004/01/17 18:27:19 henning Exp $ */
d99 1
a99 1
void		if_change(u_short, int, u_int8_t);
d801 1
a801 1
if_change(u_short ifindex, int flags, u_int8_t link_state)
d815 3
a817 1
	kif->k.link_state = link_state;
d825 1
a825 1
		if ((flags & IFF_UP) && (link_state != LINK_STATE_DOWN))
d1081 2
d1228 1
a1228 1
			    ifm->ifm_data.ifi_link_state);
@


1.72
log
@keep & track interface names as well, not only indices
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.71 2004/01/17 18:05:46 henning Exp $ */
d99 1
a99 1
void		if_change(u_short, int);
d801 1
a801 1
if_change(u_short ifindex, int flags)
d815 1
d818 6
a823 1
		if (flags & IFF_UP)
d1078 1
d1223 2
a1224 1
			if_change(ifm->ifm_index, ifm->ifm_flags);
@


1.71
log
@allow the interfaces as bgpd sees 'em to be queried via imsgs
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.69 2004/01/17 15:00:29 henning Exp $ */
d27 1
d856 1
d1033 2
d1059 3
d1072 9
@


1.70
log
@actually update interface flags in if_change()
@
text
@d65 1
a65 2
	u_short			 ifindex;
	int			 flags;
d313 1
d352 5
d360 1
d413 1
a413 1
	return (b->ifindex - a->ifindex);
d536 1
a536 1
	s.ifindex = ifindex;
d813 1
a813 1
	kif->flags = flags;
d854 1
a854 1
		kif->ifindex = ifan->ifan_index;
d1063 2
a1064 2
		kif->ifindex = ifm->ifm_index;
		kif->flags = ifm->ifm_flags;
@


1.69
log
@use the new RTM_IFANNOUNCE messages to track interface (de-)appearance,
especially for cloneable devices like vlan/tun etc

ok markus@@ and claudio@@ a while back
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.67 2004/01/11 22:08:04 henning Exp $ */
d806 2
@


1.68
log
@add soon-needed kif_remove()

ok claudio@@
@
text
@d100 1
d543 2
d831 24
a1054 1
		LIST_INIT(&kif->kroute_l);
a1099 6
		if ((sa = rti_info[RTAX_DST]) == NULL)
			continue;

		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
			continue;

d1106 4
a1109 1
		if (rtm->rtm_type != RTM_IFINFO)
d1130 1
d1193 3
@


1.67
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.66 2004/01/11 22:01:13 henning Exp $ */
d83 2
a84 1
int			 kif_insert(struct kif_node *kif);
d551 20
@


1.66
log
@use bgpd_addr in the nexthop tree; change nexthop_add/_remove accordingly

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.65 2004/01/11 19:53:48 henning Exp $ */
d382 1
a382 1
	switch(a->nexthop.af) {
@


1.65
log
@we need to have the address family set in bgpd_addr structs when they
contain anything worthwile...
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.64 2004/01/11 19:42:27 henning Exp $ */
d52 1
a52 1
	in_addr_t		 nexthop;
d78 1
a78 1
struct knexthop_node	*knexthop_find(in_addr_t);
d259 1
a259 1
kr_nexthop_add(in_addr_t key)
d263 1
a263 1
	if ((h = knexthop_find(key)) != NULL) {
d268 1
a268 2
		nh.nexthop.af = AF_INET;
		nh.nexthop.v4.s_addr = key;
d284 1
a284 1
		h->nexthop = key;
d294 1
a294 1
kr_nexthop_delete(in_addr_t key)
d298 1
a298 1
	if ((kn = knexthop_find(key)) == NULL)
d342 1
a342 3
			snh.addr.v4.s_addr = h->nexthop;
			if (snh.addr.v4.s_addr != 0)
				snh.addr.af = AF_INET;
d377 23
a399 1
	return (b->nexthop - a->nexthop);
d444 2
a445 1
			if ((ntohl(h->nexthop) & mask) == ina)
d483 1
a483 1
knexthop_find(in_addr_t key)
d487 1
a487 2
	bzero(&s, sizeof(s));
	s.nexthop = key;
d497 1
a497 1
			    log_ntoa(kn->nexthop));
d514 1
a514 1
		    log_ntoa(kn->nexthop));
d618 1
a618 2
	if ((n.nexthop.v4.s_addr = kn->nexthop) != 0)
		n.nexthop.af = AF_INET;
d621 3
a623 5
	if ((kr = kroute_match(kn->nexthop)) == NULL) {	/* no match */
		if (was_valid)
			send_nexthop_update(&n);
	} else {					/* found match */
		if (kr->r.flags & F_DOWN) {		/* but is down */
d626 14
a639 8
		} else {				/* valid route */
			if (!was_valid) {
				n.valid = 1;
				n.connected = kr->r.flags & F_CONNECTED;
				if ((n.gateway.v4.s_addr = kr->r.nexthop) != 0)
					n.gateway.af = AF_INET;
				memcpy(&n.kr, &kr->r, sizeof(n.kr));
				send_nexthop_update(&n);
d641 1
d643 1
a643 1
		kroute_attach_nexthop(kn, kr);
d792 2
a793 2
				if ((nh.nexthop.v4.s_addr = n->nexthop) != 0)
					nh.nexthop.af = AF_INET;
@


1.64
log
@when sending the nexthop status message, include the kroute that makes that
nexthop reachable. needed in the RDE for calculating the to-be-announced
nexthop.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.63 2004/01/11 19:14:43 henning Exp $ */
d268 1
d273 4
a276 1
			nh.gateway.v4.s_addr = h->kroute->r.nexthop;
d344 2
d599 2
a600 1
	n.nexthop.v4.s_addr = kn->nexthop;
d614 2
a615 1
				n.gateway.v4.s_addr = kr->r.nexthop;
d769 2
a770 1
				nh.nexthop.v4.s_addr = n->nexthop;
d774 3
a776 2
					nh.gateway.v4.s_addr =
					    kkr->kr->r.nexthop;
@


1.63
log
@use struct bgpd_addr for nexthop and gateway in struct kroute_nexthop
(and thus the nexthop messages between parent and RDE)

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.62 2004/01/11 02:35:14 henning Exp $ */
d273 1
d608 1
d768 1
@


1.62
log
@new message IMSG_CTL_SHOW_NEXTHOP: request/send lost of BGP nexthops and
the result of their validity check
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.61 2004/01/09 19:08:50 henning Exp $ */
d268 1
a268 1
		nh.nexthop = key;
d272 1
a272 1
			nh.gateway = h->kroute->r.nexthop;
d592 1
a592 1
	n.nexthop = kn->nexthop;
d606 1
a606 1
				n.gateway = kr->r.nexthop;
d759 1
a759 1
				nh.nexthop = n->nexthop;
d763 2
a764 1
					nh.gateway = kkr->kr->r.nexthop;
@


1.61
log
@for IMSG_CTL_KROUTEs allow matching based on flags,
add IMGS_CTL_KROUTE_ADDR to match the route for a given address

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.60 2004/01/09 14:10:06 henning Exp $ */
d306 2
d309 2
a310 1
	if (imsg->hdr.type == IMSG_CTL_KROUTE) {
d320 2
a321 1
	} else if (imsg->hdr.type == IMSG_CTL_KROUTE_ADDR) {
d334 14
@


1.60
log
@flag kernel routes whch are not conencted routes as static routes.
that's what they are, and it makes matching on them easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.59 2004/01/09 13:47:07 henning Exp $ */
d301 1
a301 1
kr_show_route(pid_t pid)
d304 2
d307 25
a331 4
	RB_FOREACH(kr, kroute_tree, &krt)
		send_imsg_session(IMSG_CTL_KROUTE, pid, &kr->r, sizeof(kr->r));

	send_imsg_session(IMSG_CTL_END, pid, NULL, 0);
@


1.59
log
@get us a stateful imsg relaying framework, and the first receiver,
IMSG_CTL_KROUTE, to have the kroute structs forming the fib sent to a
control socket.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.57 2004/01/08 17:06:50 henning Exp $ */
d371 3
@


1.58
log
@for RTM_IFINFO messages showing up on the routing socket do not ever
look into the first sockaddr structure after the msg header; does not
contain what we expect there and caused messages to get missed in some cases
@
text
@a47 2
	u_int8_t		 flags;
	u_short			 ifindex;
a116 7
#define	F_BGPD_INSERTED		0x0001
#define	F_KERNEL		0x0002
#define	F_CONNECTED		0x0004
#define	F_NEXTHOP		0x0008
#define	F_DOWN			0x0010


d165 1
a165 1
		if (kr->flags & F_BGPD_INSERTED)
d182 1
a182 1
		kr->flags = F_BGPD_INSERTED;
d200 1
a200 1
	if (!(kr->flags & F_BGPD_INSERTED))
d229 1
a229 1
		if ((kr->flags & F_BGPD_INSERTED))
d244 1
a244 1
		if ((kr->flags & F_BGPD_INSERTED))
d271 1
a271 1
			nh.connected = h->kroute->flags & F_CONNECTED;
d300 10
d370 1
a370 1
	if (kr->flags & F_KERNEL) {
d377 1
a377 1
		if (kr->flags & F_CONNECTED)
d396 1
a396 1
	if ((kr->flags & F_KERNEL) && (kr->flags & F_NEXTHOP))
d401 1
a401 1
	if (kr->flags & F_CONNECTED)
d487 1
a487 1
	if ((kif = kif_find(kr->ifindex)) == NULL) {
d489 1
a489 1
		    kr->ifindex);
d511 1
a511 1
	if ((kif = kif_find(kr->ifindex)) == NULL) {
d513 1
a513 1
		    kr->ifindex);
d523 1
a523 1
		    "with index %u: not found", kr->ifindex);
d544 1
a544 1
	if (kn->kroute != NULL && (!(kn->kroute->flags & F_DOWN)))
d555 1
a555 1
		if (kr->flags & F_DOWN) {		/* but is down */
d561 1
a561 1
				n.connected = kr->flags & F_CONNECTED;
d596 1
a596 1
	kr->flags |= F_NEXTHOP;
d617 1
a617 1
		kn->kroute->flags &= ~F_NEXTHOP;
d640 1
a640 1
	kr->flags = F_KERNEL|F_CONNECTED;
d708 1
a708 1
			kkr->kr->flags &= ~F_DOWN;
d710 1
a710 1
			kkr->kr->flags |= F_DOWN;
d716 1
a716 1
				if (!(kkr->kr->flags & F_DOWN)) {
d844 1
a844 1
		kr->flags = F_KERNEL;
d874 2
a875 2
				kr->flags |= F_CONNECTED;
				kr->ifindex = rtm->rtm_index;
d1030 1
a1030 1
				if (kr->flags & F_KERNEL) {
d1032 1
a1032 1
					if (kr->flags & F_NEXTHOP)
d1034 1
a1034 1
					if ((kr->flags & F_CONNECTED) &&
d1038 1
a1038 1
					    !(kr->flags & F_CONNECTED))
d1040 1
a1040 1
					kr->flags = flags;
d1051 1
a1051 1
				kr->flags = flags;
d1059 1
a1059 1
			if (!(kr->flags & F_KERNEL))
@


1.57
log
@in kroute_insert, use knexthop_validate instead of hand-baking a slightly
optimized version of it
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.56 2004/01/08 16:55:25 henning Exp $ */
d983 18
a1000 16
		switch (sa->sa_family) {
		case AF_INET:
			prefix = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
			sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
			if (sa_in != NULL) {
				if (sa_in->sin_family != AF_INET)
					continue;
				prefixlen =
				    mask2prefixlen(sa_in->sin_addr.s_addr);
			} else if (rtm->rtm_flags & RTF_HOST)
				prefixlen = 32;
			else
				prefixlen = prefixlen_classful(prefix);
			break;
		default:
			if (rtm->rtm_type != RTM_IFINFO)
d1002 2
a1003 2
			break;
		}
@


1.56
log
@in knexthop_validate, always call kroute_detach_nexthop, not
only in the no-match-found case. if we fina a match we are calling
kroute_attach_nexthop anyway; and the match might be (in the common cases:
will be, if existant at all) different for the existing attachment.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.55 2004/01/08 16:52:05 henning Exp $ */
a359 1
	struct kroute_nexthop	 nh;
d372 4
a375 14
		RB_FOREACH(h, knexthop_tree, &knt) {
			if ((ntohl(h->nexthop) & mask) == ina) {
				if (h->kroute != NULL)
					continue;	/* XXX */
				h->kroute = kr;
				kr->flags |= F_NEXTHOP;
				bzero(&nh, sizeof(nh));
				nh.nexthop = h->nexthop;
				nh.valid = 1;
				nh.connected = kr->flags & F_CONNECTED;
				nh.gateway = kr->r.nexthop;
				send_nexthop_update(&nh);
			}
		}
@


1.55
log
@fix kroute_detach_nexthop
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.54 2004/01/08 16:34:39 henning Exp $ */
d559 1
a563 1
		kroute_detach_nexthop(kn);
@


1.54
log
@our own internal route flags should have been an u_int8_t from the beginning
on, not an int.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.53 2004/01/08 16:17:12 henning Exp $ */
d619 3
d623 1
a623 1
	    s->kroute != s->kroute; s = RB_NEXT(knexthop_tree, &knt, s))
@


1.53
log
@rename a few functions to further clarify things
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.52 2004/01/08 16:07:15 henning Exp $ */
d48 1
a48 1
	int			 flags;
@


1.52
log
@big reorganization.
much nicer now.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.51 2004/01/08 11:40:03 henning Exp $ */
d76 7
a82 7
struct kroute_node	*kroute_tree_find(in_addr_t, u_int8_t);
int			 kroute_tree_insert(struct kroute_node *);
int			 kroute_tree_remove(struct kroute_node *);

struct knexthop_node	*knexthop_tree_find(in_addr_t);
int			 knexthop_tree_insert(struct knexthop_node *);
int			 knexthop_tree_remove(struct knexthop_node *);
d84 2
a85 2
struct kif_node		*kif_tree_find(int);
int			 kif_tree_insert(struct kif_node *kif);
d96 1
a96 1
int		kroute_protect_lo(void);
d100 1
a100 1
void		kroute_interface_statuschange(u_short, int);
d102 4
a105 4
int		kroute_send_rtmsg(int, int, struct kroute *);
int		kroute_get_rtmsg(void);
int		kroute_fetchtable(void);
int		kroute_fetchifs(int);
d131 1
a131 1
kroute_init(int fs)
d138 1
a138 1
		log_err("kroute_init: socket");
d145 1
a145 1
		log_err("kroute_init: setsockopt");	/* not fatal */
d154 1
a154 1
	if (kroute_fetchifs(0) == -1)
d157 1
a157 1
	if (kroute_fetchtable() == -1)
d160 1
a160 1
	if (kroute_protect_lo() == -1)
d167 1
a167 1
kroute_change(struct kroute *kroute)
d172 1
a172 1
	if ((kr = kroute_tree_find(kroute->prefix, kroute->prefixlen)) !=
d180 1
a180 1
	if (kroute_send_rtmsg(kr_state.fd, action, kroute) == -1)
d185 1
a185 1
			log_err("kroute_change");
d193 1
a193 1
		if (kroute_tree_insert(kr) == -1)
d202 1
a202 1
kroute_delete(struct kroute *kroute)
d206 1
a206 1
	if ((kr = kroute_tree_find(kroute->prefix, kroute->prefixlen)) == NULL)
d212 1
a212 1
	if (kroute_send_rtmsg(kr_state.fd, RTM_DELETE, kroute) == -1)
d215 1
a215 1
	if (kroute_tree_remove(kr) == -1)
d222 1
a222 1
kroute_shutdown(void)
d224 1
a224 1
	kroute_fib_decouple();
d228 1
a228 1
kroute_fib_couple(void)
d239 1
a239 1
			kroute_send_rtmsg(kr_state.fd, RTM_ADD, &kr->r);
d245 1
a245 1
kroute_fib_decouple(void)
d254 1
a254 1
			kroute_send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);
d262 1
a262 1
kroute_dispatch_msg(void)
d264 1
a264 1
	return (kroute_get_rtmsg());
d268 1
a268 1
kroute_nexthop_add(in_addr_t key)
d272 1
a272 1
	if ((h = knexthop_tree_find(key)) != NULL) {
d286 1
a286 1
			log_err("kroute_nexthop_add");
d291 1
a291 1
		if (knexthop_tree_insert(h) == -1)
d299 1
a299 1
kroute_nexthop_delete(in_addr_t key)
d303 1
a303 1
	if ((kn = knexthop_tree_find(key)) == NULL)
d306 1
a306 1
	knexthop_tree_remove(kn);
d346 1
a346 1
kroute_tree_find(in_addr_t prefix, u_int8_t prefixlen)
d357 1
a357 1
kroute_tree_insert(struct kroute_node *kr)
d395 1
a395 1
kroute_tree_remove(struct kroute_node *kr)
d400 1
a400 1
		logit(LOG_CRIT, "kroute_tree_remove failed for %s/%u",
d422 1
a422 1
knexthop_tree_find(in_addr_t key)
d433 1
a433 1
knexthop_tree_insert(struct knexthop_node *kn)
d448 1
a448 1
knexthop_tree_remove(struct knexthop_node *kn)
d453 1
a453 1
		logit(LOG_CRIT, "knexthop_tree_remove failed for %s",
d463 1
a463 1
kif_tree_find(int ifindex)
d474 1
a474 1
	kroute_fetchifs(ifindex);
d479 1
a479 1
kif_tree_insert(struct kif_node *kif)
d497 1
a497 1
	if ((kif = kif_tree_find(kr->ifindex)) == NULL) {
d521 1
a521 1
	if ((kif = kif_tree_find(kr->ifindex)) == NULL) {
d591 1
a591 1
		if ((kr = kroute_tree_find(
d596 1
a596 1
	if ((kr = kroute_tree_find(0, 0)) != NULL)
d635 1
a635 1
kroute_protect_lo(void)
d641 1
a641 1
		log_err("kroute_protect_lo");
d700 1
a700 1
kroute_interface_statuschange(u_short ifindex, int flags)
d707 1
a707 1
	if ((kif = kif_tree_find(ifindex)) == NULL) {
d739 1
a739 1
kroute_send_rtmsg(int fd, int action, struct kroute *kroute)
d784 1
a784 1
				    "kroute_send_rtmsg: action %u, "
d793 1
a793 1
			    "kroute_send_rtmsg: action %u, prefix %s/%u: %s",
d804 1
a804 1
kroute_fetchtable(void)
d826 1
a826 1
		log_err("kroute_fetchtable");
d847 1
a847 1
			log_err("kroute_fetchtable");
d886 1
a886 1
		kroute_tree_insert(kr);
d894 1
a894 1
kroute_fetchifs(int ifindex)
d914 1
a914 1
		log_err("kroute_fetchif");
d929 1
a929 1
			log_err("kroute_fetchifs");
d936 1
a936 1
		kif_tree_insert(kif);
d942 1
a942 1
kroute_get_rtmsg(void)
d958 1
a958 1
		log_err("kroute_get_rtmsg: read error");
d1028 1
a1028 1
				    "kroute_get_rtmsg: no nexthop for %s/%u",
d1033 1
a1033 1
			if ((kr = kroute_tree_find(prefix, prefixlen)) !=
d1050 1
a1050 1
					log_err("kroute_get_rtmsg");
d1058 1
a1058 1
				kroute_tree_insert(kr);
d1062 1
a1062 1
			if ((kr = kroute_tree_find(prefix, prefixlen)) == NULL)
d1066 1
a1066 1
			if (kroute_tree_remove(kr) == -1)
d1071 1
a1071 2
			kroute_interface_statuschange(ifm->ifm_index,
			    ifm->ifm_flags);
@


1.51
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.50 2004/01/08 11:39:41 henning Exp $ */
d72 24
a96 6
int		kroute_msg(int, int, struct kroute *);
int		kroute_insert(struct kroute_node *);
int		kroute_insert_connected(struct kroute_node *);
int		kroute_remove_connected(struct kroute_node *);
int		kroute_compare(struct kroute_node *, struct kroute_node *);
void		get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
d99 5
a105 9
int		kroute_remove(struct kroute_node *);
int		kroute_nexthop_insert(in_addr_t, struct kroute_nexthop *);
int		kroute_nexthop_checkmatch(in_addr_t, struct knexthop_node *);
int		knexthop_compare(struct knexthop_node *,
		    struct knexthop_node *);
int		kif_compare(struct kif_node *, struct kif_node *);
void		kroute_interface_statuschange(u_short, int);

struct kroute_node	*kroute_match(in_addr_t);
d125 5
d167 1
a167 1
kroute_protect_lo(void)
d170 1
d172 9
a180 3
	/* special protection for 127/8 */
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
		log_err("kroute_protect_lo");
a181 5
	}
	kr->r.prefix = inet_addr("127.0.0.1");
	kr->r.prefixlen = 8;
	kr->r.nexthop = 0;
	kr->flags = F_KERNEL|F_CONNECTED;
d183 14
a196 2
	if (RB_INSERT(kroute_tree, &krt, kr) != NULL)
		free(kr);	/* kernel route already there, no problem */
d202 1
a202 1
kroute_msg(int fd, int action, struct kroute *kroute)
d204 4
a207 7
	struct {
		struct rt_msghdr	hdr;
		struct sockaddr_in	prefix;
		struct sockaddr_in	nexthop;
		struct sockaddr_in	mask;
	} r;
	ssize_t	n;
d209 1
a209 1
	if (kr_state.fib_sync == 0)
d212 63
a274 16
	bzero(&r, sizeof(r));
	r.hdr.rtm_msglen = sizeof(r);
	r.hdr.rtm_version = RTM_VERSION;
	r.hdr.rtm_type = action;
	r.hdr.rtm_flags = RTF_GATEWAY|RTF_PROTO1;
	r.hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	r.hdr.rtm_addrs = RTA_DST|RTA_GATEWAY|RTA_NETMASK;
	r.prefix.sin_len = sizeof(r.prefix);
	r.prefix.sin_family = AF_INET;
	r.prefix.sin_addr.s_addr = kroute->prefix;
	r.nexthop.sin_len = sizeof(r.nexthop);
	r.nexthop.sin_family = AF_INET;
	r.nexthop.sin_addr.s_addr = kroute->nexthop;
	r.mask.sin_len = sizeof(r.mask);
	r.mask.sin_family = AF_INET;
	r.mask.sin_addr.s_addr = htonl(0xffffffff << (32 - kroute->prefixlen));
d276 12
a287 27
retry:
	if ((n = write(fd, &r, sizeof(r))) == -1) {
		switch (errno) {
		case ESRCH:
			if (r.hdr.rtm_type == RTM_CHANGE) {
				r.hdr.rtm_type = RTM_ADD;
				goto retry;
			} else if (r.hdr.rtm_type == RTM_DELETE) {
				logit(LOG_INFO,
				    "route %s/%u vanished before delete",
				    log_ntoa(kroute->prefix),
				    kroute->prefixlen);
				return (0);
			} else {
				logit(LOG_CRIT,
				    "kroute_msg: action %u, prefix %s/%u: %s",
				    r.hdr.rtm_type, log_ntoa(kroute->prefix),
				    kroute->prefixlen, strerror(errno));
				return (0);
			}
			break;
		default:
			logit(LOG_CRIT,
			    "kroute_msg: action %u, prefix %s/%u: %s",
			    r.hdr.rtm_type, log_ntoa(kroute->prefix),
			    kroute->prefixlen, strerror(errno));
			return (0);
d289 4
d298 30
d329 1
a329 1
kroute_change(struct kroute *kroute)
d331 2
a332 2
	struct kroute_node	*kr, s;
	int			 action = RTM_ADD;
d334 5
a338 2
	s.r.prefix = kroute->prefix;
	s.r.prefixlen = kroute->prefixlen;
a339 6
	if ((kr = RB_FIND(kroute_tree, &krt, &s)) != NULL) {
		if (kr->flags & F_BGPD_INSERTED)
			action = RTM_CHANGE;
		else	/* a non-bgp route already exists. not a problem */
			return (0);
	}
d341 3
a343 2
	if (kroute_msg(kr_state.fd, action, kroute) == -1)
		return (-1);
d345 4
a348 9
	if (action == RTM_ADD) {
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_err("kroute_change");
			return (-1);
		}
		kr->r.prefix = kroute->prefix;
		kr->r.prefixlen = kroute->prefixlen;
		kr->r.nexthop = kroute->nexthop;
		kr->flags = F_BGPD_INSERTED;
d350 2
a351 4
		if (kroute_insert(kr) == -1)
			free(kr);
	} else
		kr->r.nexthop = kroute->nexthop;
d353 1
a353 1
	return (0);
d357 1
a357 1
kroute_insert(struct kroute_node *kr)
d366 1
d388 1
a388 1
			if (kroute_insert_connected(kr) == -1)
d395 69
a463 1
kroute_insert_connected(struct kroute_node *kr)
a465 1
	struct kif_kr	*kkr;
d468 9
a476 1
	s.ifindex = kr->ifindex;
d478 20
a497 1
	if ((kif = RB_FIND(kif_tree, &kit, &s)) == NULL) {
d504 1
a504 1
		log_err("kroute_insert_connected");
d516 1
a516 1
kroute_remove_connected(struct kroute_node *kr)
d518 2
a519 5
	struct kif_node	*kif, s;
	struct kif_kr	*a;

	bzero(&s, sizeof(s));
	s.ifindex = kr->ifindex;
d521 1
a521 1
	if ((kif = RB_FIND(kif_tree, &kit, &s)) == NULL) {
d527 2
a528 2
	for (a = LIST_FIRST(&kif->kroute_l); a != NULL && a->kr != kr;
	    a = LIST_NEXT(a, entry))
d531 1
a531 1
	if (a == NULL) {
d537 2
a538 2
	LIST_REMOVE(a, entry);
	free(a);
d543 39
a581 2
int
kroute_delete(struct kroute *kroute)
d583 5
a587 1
	struct kroute_node	*kr, s;
d589 5
a593 2
	s.r.prefix = kroute->prefix;
	s.r.prefixlen = kroute->prefixlen;
d595 18
a612 2
	if ((kr = RB_FIND(kroute_tree, &krt, &s)) == NULL)
		return (0);
d614 4
a617 2
	if (!(kr->flags & F_BGPD_INSERTED))
		return (0);
d619 3
a621 2
	if (kroute_msg(kr_state.fd, RTM_DELETE, kroute) == -1)
		return (-1);
d623 2
a624 2
	RB_REMOVE(kroute_tree, &krt, kr);
	free(kr);
d626 1
a626 1
	return (0);
d629 5
d635 1
a635 1
kroute_compare(struct kroute_node *a, struct kroute_node *b)
d637 5
a641 1
	if (a->r.prefix < b->r.prefix)
d643 9
a651 6
	if (a->r.prefix > b->r.prefix)
		return (1);
	if (a->r.prefixlen < b->r.prefixlen)
		return (-1);
	if (a->r.prefixlen > b->r.prefixlen)
		return (1);
d655 29
d685 1
a685 1
kroute_shutdown(void)
d687 10
a696 1
	kroute_fib_decouple();
d700 1
a700 1
kroute_fib_couple(void)
d702 4
a705 1
	struct kroute_node	*kr;
d707 3
a709 1
	if (kr_state.fib_sync == 1)	/* already coupled */
d711 1
d713 5
a717 1
	kr_state.fib_sync = 1;
d719 12
a730 5
	RB_FOREACH(kr, kroute_tree, &krt)
		if ((kr->flags & F_BGPD_INSERTED))
			kroute_msg(kr_state.fd, RTM_ADD, &kr->r);

	logit(LOG_INFO, "kernel routing table coupled");
a732 7
void
kroute_fib_decouple(void)
{
	struct kroute_node	*kr;

	if (kr_state.fib_sync == 0)	/* already decoupled */
		return;
d734 3
a736 3
	RB_FOREACH(kr, kroute_tree, &krt)
		if ((kr->flags & F_BGPD_INSERTED))
			kroute_msg(kr_state.fd, RTM_DELETE, &kr->r);
d738 10
a747 1
	kr_state.fib_sync = 0;
d749 2
a750 2
	logit(LOG_INFO, "kernel routing table decoupled");
}
d752 16
a767 2
#define	ROUNDUP(a, size)	\
    (((a) & ((size) - 1)) ? (1 + ((a) | ((size) - 1))) : (a))
d769 29
a797 12
void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len, sizeof(long)));
		} else
			rti_info[i] = NULL;
a798 1
}
d800 1
a800 24
u_int8_t
prefixlen_classful(in_addr_t ina)
{
	/* it hurt to write this. */

	if (ina >= 0xf0000000U)		/* class E */
		return (32);
	else if (ina >= 0xe0000000U)	/* class D */
		return (4);
	else if (ina >= 0xc0000000U)	/* class C */
		return (24);
	else if (ina >= 0x80000000U)	/* class B */
		return (16);
	else				/* class A */
		return (8);
}

u_int8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
d886 2
a887 2
		if (kroute_insert(kr) == -1)
			free(kr);
d936 1
a936 4
		if (RB_INSERT(kif_tree, &kit, kif) != NULL) {
			logit(LOG_CRIT, "RB_INSERT(kif_tree, &kit, kif)");
			free(kif);
		}
d942 1
a942 1
kroute_dispatch_msg(void)
d951 3
a953 2
	struct kroute_node	*kr, s;
	in_addr_t		 nexthop;
d958 1
a958 1
		log_err("kroute_dispatch_msg: read error");
d973 2
a974 1
		bzero(&s, sizeof(s));
d993 1
a993 2
			s.r.prefix =
			    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
d998 1
a998 1
				s.r.prefixlen =
d1001 1
a1001 1
				s.r.prefixlen = 32;
d1003 1
a1003 1
				s.r.prefixlen = prefixlen_classful(s.r.prefix);
d1028 2
a1029 2
				    "kroute_dispatch_msg: no nexthop for %s/%u",
				    log_ntoa(s.r.prefix), s.r.prefixlen);
d1033 2
a1034 1
			if ((kr = RB_FIND(kroute_tree, &krt, &s)) != NULL) {
d1037 1
a1037 1
					if (kr->flags & F_NEXTHOP) /* XXX */
d1041 1
a1041 1
						kroute_remove_connected(kr);
d1044 1
a1044 1
						kroute_insert_connected(kr);
d1050 1
a1050 1
					log_err("kroute_dispatch_msg");
d1053 2
a1054 2
				kr->r.prefix = s.r.prefix;
				kr->r.prefixlen = s.r.prefixlen;
d1058 1
a1058 2
				if (kroute_insert(kr) == -1)
					free(kr);
d1062 1
a1062 1
			if ((kr = RB_FIND(kroute_tree, &krt, &s)) == NULL)
d1066 1
a1066 1
			if (kroute_remove(kr) == -1)
a1079 211
}

int
kroute_remove(struct kroute_node *kr)
{
	struct knexthop_node	*s;
	struct kroute_nexthop	 h;

	/*
	 * the foreach is suboptimal, but:
	 * -routes disappering that have nexthops attached should not
	 *  happen often; except for some ibgp and multihop that should
	 *  be connected routes anyway
	 * -maintaining an SLIST per kroute_node is probably worse
	 * -it is easy to change if needed ;-)
	 */

	RB_REMOVE(kroute_tree, &krt, kr);

	if ((kr->flags & F_KERNEL) && (kr->flags & F_NEXTHOP))
		RB_FOREACH(s, knexthop_tree, &knt)
			if (s->kroute == kr) {
				/*
				 * XXX check again wether there's another
				 * non-bgp route. if not, notify RDE
				 * that this nexthop is now invalid
				 */
				if (!kroute_nexthop_checkmatch(s->nexthop,
				    s)) {
					s->kroute = NULL;
					bzero(&h, sizeof(h));
					h.nexthop = s->nexthop;
					send_nexthop_update(&h);
				}
			}

	if (kr->flags & F_CONNECTED)
		if (kroute_remove_connected(kr) == -1) {
			free(kr);
			return (-1);
		}

	free(kr);
	return (0);
}

struct kroute_node *
kroute_match(in_addr_t key)
{
	int			i;
	struct kroute_node	s, *kr;
	in_addr_t		ina;

	ina = ntohl(key);

	/* we will never match the default route */
	for (i = 32; i > 0; i--) {
		s.r.prefix = htonl(ina & (0xffffffff << (32 - i)));
		s.r.prefixlen = i;
		if ((kr = RB_FIND(kroute_tree, &krt, &s)) != NULL)
			return (kr);
	}

	/* if we don't have a match yet, try to find a default route */
	s.r.prefix = 0;
	s.r.prefixlen = 0;
	if ((kr = RB_FIND(kroute_tree, &krt, &s)) != NULL)
		return (kr);

	return (NULL);
}

int
kroute_nexthop_add(in_addr_t key)
{
	struct kroute_nexthop	 nh;
	struct knexthop_node	*h, s;

	s.nexthop = key;

	bzero(&nh, sizeof(nh));
	nh.nexthop = key;

	if ((h = RB_FIND(knexthop_tree, &knt, &s)) != NULL) {
		if (h->kroute != NULL) {
			nh.valid = 1;
			nh.connected = h->kroute->flags & F_CONNECTED;
			nh.gateway = h->kroute->r.nexthop;
		}
	} else
		if (kroute_nexthop_insert(key, &nh) == -1)
			return (-1);

	send_nexthop_update(&nh);

	return (0);
}

void
kroute_nexthop_delete(in_addr_t key)
{
	struct knexthop_node	*a, *b, s;

	s.nexthop = key;

	if ((a = RB_FIND(knexthop_tree, &knt, &s)) == NULL)
		return;

	/*
	 * check wether there's another nexthop depending on this kroute
	 * if not remove the flag
	 */

	for (b = RB_MIN(knexthop_tree, &knt); b != NULL &&
	    b->kroute != a->kroute; b = RB_NEXT(knexthop_tree, &knt, b))
		;	/* nothing */

	if (b == NULL)
		a->kroute->flags &= ~F_NEXTHOP;

	RB_REMOVE(knexthop_tree, &knt, a);
}

int
kroute_nexthop_insert(in_addr_t key, struct kroute_nexthop *nh)
{
	struct knexthop_node	*h;

	if ((h = calloc(1, sizeof(struct knexthop_node))) == NULL) {
		log_err("kroute_nexthop_insert");
		return (-1);
	}

	h->nexthop = nh->nexthop = key;

	if (kroute_nexthop_checkmatch(key, h) == 1) {
		nh->valid = 1;
		nh->connected = h->kroute->flags & F_CONNECTED;
		nh->gateway = h->kroute->r.nexthop;
	}

	if (RB_INSERT(knexthop_tree, &knt, h) != NULL) {
		logit(LOG_CRIT, "knexthop_tree insert failed for %s",
			    log_ntoa(h->nexthop));
		free(h);
	}
	return (0);
}

int
kroute_nexthop_checkmatch(in_addr_t key, struct knexthop_node *h)
{
	struct kroute_node	*kr;

	if ((kr = kroute_match(key)) != NULL)
		if (!(kr->flags & F_DOWN)) {	/* may be bgp, bad idea tho */
			h->kroute = kr;
			kr->flags |= F_NEXTHOP;
			return (1);
		}

	return (0);
}

int
knexthop_compare(struct knexthop_node *a, struct knexthop_node *b)
{
	return (b->nexthop - a->nexthop);
}

int
kif_compare(struct kif_node *a, struct kif_node *b)
{
	return (b->ifindex - a->ifindex);
}

void
kroute_interface_statuschange(u_short ifindex, int flags)
{
	struct kif_node		*kif, s;
	struct kif_kr		*kkr;
	struct kroute_nexthop	 nh;
	struct knexthop_node	*n;

	bzero(&s, sizeof(s));
	s.ifindex = ifindex;

	if ((kif = RB_FIND(kif_tree, &kit, &s)) == NULL) {
		logit(LOG_CRIT, "interface with index %u not found",
		    ifindex);
		return;
	}

	LIST_FOREACH(kkr, &kif->kroute_l, entry) {
		if (flags & IFF_UP)
			kkr->kr->flags &= ~F_DOWN;
		else
			kkr->kr->flags |= F_DOWN;

		RB_FOREACH(n, knexthop_tree, &knt)
			if (n->kroute == kkr->kr) {
				bzero(&nh, sizeof(nh));
				nh.nexthop = n->nexthop;
				if (!(kkr->kr->flags & F_DOWN)) {
					nh.valid = 1;
					nh.connected = 1;
					nh.gateway = kkr->kr->r.nexthop;
				}
				send_nexthop_update(&nh);
			}
	}
@


1.50
log
@keep track of interface status. if an interface goes down mark all connected
routes that belong to it as invalid, and invalidate all nexthops belonging
to it, and vice versa when it goes up

"looks good" claudio@@ on the version from yesterday night '-)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.49 2004/01/07 13:32:53 henning Exp $ */
d535 1
a535 1
		switch(sa->sa_family) {
d674 1
a674 1
		switch(sa->sa_family) {
@


1.49
log
@deal with messages on the AF_ROUTE socket in a multiprotocol friendlier way.
this is also some preparation for v6 support.

"looks good" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.48 2004/01/07 12:38:51 henning Exp $ */
d26 1
d49 1
d58 14
d75 2
d82 1
d88 2
d101 4
d109 1
d133 4
d299 3
d307 58
d564 1
d576 51
d633 1
d639 1
d656 2
d660 1
d690 3
a692 2
			continue;
			/* not reached */
d703 1
d722 6
d753 5
d799 7
d919 1
a919 1
		if (kr->flags & F_KERNEL) {	/* must be non-bgp! */
d934 42
@


1.48
log
@fix a check that catched too much... now connected routes that appear
after startup (due to addition of an ip to an interface) are handled
correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.47 2004/01/06 03:43:50 henning Exp $ */
d431 1
a431 1
		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_DST]) == NULL)
d443 29
a471 15
		kr->r.prefix = sa_in->sin_addr.s_addr;
		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK]) !=
		    NULL) {
			kr->r.prefixlen =
			    mask2prefixlen(sa_in->sin_addr.s_addr);
		} else if (rtm->rtm_flags & RTF_HOST)
			kr->r.prefixlen = 32;
		else
			kr->r.prefixlen = prefixlen_classful(kr->r.prefix);

		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_GATEWAY]) !=
		    NULL) {
			if (sa_in->sin_family == AF_INET)
				kr->r.nexthop = sa_in->sin_addr.s_addr;
			else if (sa_in->sin_family == AF_LINK)
d473 2
a474 1
		}
d514 1
a514 1
		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_DST]) == NULL)
d526 27
a552 15
		s.r.prefix = sa_in->sin_addr.s_addr;
		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK]) !=
		    NULL) {
			s.r.prefixlen =
			    mask2prefixlen(sa_in->sin_addr.s_addr);
		} else if (rtm->rtm_flags & RTF_HOST)
			s.r.prefixlen = 32;
		else
			s.r.prefixlen = prefixlen_classful(s.r.prefix);

		if ((sa_in = (struct sockaddr_in *)rti_info[RTAX_GATEWAY]) !=
		    NULL) {
			if (sa_in->sin_family == AF_INET)
				nexthop = sa_in->sin_addr.s_addr;
			else if (sa_in->sin_family == AF_LINK)
d554 2
a555 1
		}
@


1.47
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.46 2004/01/05 16:17:22 henning Exp $ */
d532 1
a532 1
			if (nexthop == 0) {
@


1.46
log
@protect against trying to couple when we're already coupled to the fib,
and log the coupling. same for decouple.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.45 2004/01/02 01:46:20 deraadt Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.45
log
@mark a few numbers U to please compilers; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.44 2003/12/30 13:03:27 henning Exp $ */
d321 3
d329 2
d338 3
d346 2
@


1.44
log
@typos from david
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.43 2003/12/28 14:43:18 henning Exp $ */
d363 1
a363 1
	if (ina >= 0xf0000000)		/* class E */
d365 1
a365 1
	else if (ina >= 0xe0000000)	/* class D */
d367 1
a367 1
	else if (ina >= 0xc0000000)	/* class C */
d369 1
a369 1
	else if (ina >= 0x80000000)	/* class B */
@


1.43
log
@typo in comment
From: Dries Schellekens <gwyllion@@ace.ulyssis.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.42 2003/12/27 18:43:36 henning Exp $ */
d97 1
a97 1
	/* not intrested in my own messages */
d560 1
a560 1
			/* ingnore for now */
@


1.42
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.41 2003/12/27 18:41:40 henning Exp $ */
d621 1
a621 1
	/* if we don't have a match yet, try to find a defautl route */
@


1.41
log
@consider the defualt route in kroute_match as well. it is a special case.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.40 2003/12/27 14:24:42 henning Exp $ */
a42 1
	
@


1.40
log
@keep a copy of the fd locally instead of passing it around all time
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.39 2003/12/27 01:30:00 henning Exp $ */
d615 1
a615 1
	for (i = 32; i >= 0; i--) {
d621 6
@


1.39
log
@provide kroute_fib_couple and _decouple, pumping all bgp routes from the
internal view to the kernel routing table respectively removing them all from
the kernel routing table
kroute_shutdown is now a simple wrapper to kroute_fib_decouple
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.38 2003/12/27 00:53:51 henning Exp $ */
d37 8
a80 4
u_int32_t		rtseq = 1;
pid_t			pid;
int			fib_sync;

d89 1
a89 1
	int s, opt;
d91 1
a91 1
	fib_sync = fs;
d93 1
a93 1
	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) == -1) {
d99 2
a100 1
	if (setsockopt(s, SOL_SOCKET, SO_USELOOPBACK, &opt, sizeof(opt)) == -1)
d103 2
a104 1
	pid = getpid();
d115 1
a115 1
	return (s);
d150 1
a150 1
	if (fib_sync == 0)
d158 1
a158 1
	r.hdr.rtm_seq = rtseq++;	/* overflow doesn't matter */
d204 1
a204 1
kroute_change(int fd, struct kroute *kroute)
d219 1
a219 1
	if (kroute_msg(fd, action, kroute) == -1)
d275 1
a275 1
kroute_delete(int fd, struct kroute *kroute)
d288 1
a288 1
	if (kroute_msg(fd, RTM_DELETE, kroute) == -1)
d312 1
a312 1
kroute_shutdown(int fd)
d314 1
a314 1
	kroute_fib_decouple(fd);
d318 1
a318 1
kroute_fib_couple(int fd)
d322 1
a322 1
	fib_sync = 1;
d326 1
a326 1
			kroute_msg(fd, RTM_ADD, &kr->r);
d330 1
a330 1
kroute_fib_decouple(int fd)
d336 1
a336 1
			kroute_msg(fd, RTM_DELETE, &kr->r);
d338 1
a338 1
	fib_sync = 0;
d460 1
a460 1
kroute_dispatch_msg(int fd)
d472 1
a472 1
	if ((n = read(fd, &buf, sizeof(buf))) == -1) {
d496 1
a496 1
		if (rtm->rtm_pid == pid)		/* cause by us */
@


1.38
log
@implement "no fib-update" much cooler
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.37 2003/12/27 00:17:26 henning Exp $ */
d144 1
a144 1
	if (!fib_sync)
d308 18
d331 2
@


1.37
log
@when a static route is deleted on that a nexthop depends, we re-check
wether there's another (bigger-prefix) non-bgp route suitable to reach the
prefix, and if that is the case change the references over to the new route.
if not, we need to invalidate the nexthop.
unfortunately, we cannot just call kroute_nexthop_insert (whoch does these
checks) again, as it does too much.
factor out the matching and reference adding code from kroute_nexthop_insert
to a new kroute_nexthop_checkmatch(), and make the surrpounding stuff cope.
the kroute parts of "static route addition/deletion affects nexthop-valifity"
work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.36 2003/12/26 23:46:51 henning Exp $ */
d75 1
d83 1
a83 1
kroute_init(void)
d87 2
d143 3
@


1.36
log
@detect when a newly added kernel route (non-bgp of course) matches a nexthop
that is flagged invalid yet and make it valid, notify RDE etc
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.35 2003/12/26 23:22:27 henning Exp $ */
d59 1
d561 5
a565 4
				bzero(&h, sizeof(h));
				if (kroute_nexthop_insert(s->nexthop, &h) == -1)
					return (-1);
				if (h.valid == 0)	/* no alternate route */
d567 1
a646 1
	struct kroute_node	*kr;
d656 19
d679 1
a679 3
			nh->valid = 1;
			nh->connected = kr->flags & F_CONNECTED;
			nh->gateway = kr->r.nexthop;
a681 5
	if (RB_INSERT(knexthop_tree, &knt, h) != NULL) {
		logit(LOG_CRIT, "knexthop_tree insert failed for %s",
			    log_ntoa(h->nexthop));
		free(h);
	}
@


1.35
log
@factor out common code
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.34 2003/12/26 19:19:25 henning Exp $ */
d230 4
d240 18
@


1.34
log
@20 minutes debugging for a missinf return (0) at the end of a function,
and gcc should have had complained... well.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.33 2003/12/26 17:47:04 henning Exp $ */
d51 1
d219 1
a219 4
		if (RB_INSERT(kroute_tree, &krt, kr) != NULL) {
			logit(LOG_CRIT,
			    "kroute_tree insert failed for %s/%u",
			    log_ntoa(kr->r.prefix), kr->r.prefixlen);
a220 1
		}
d228 12
d397 1
a397 4
		if (RB_INSERT(kroute_tree, &krt, kr) != NULL) {
			logit(LOG_CRIT,
			    "kroute_tree insert failed for %s/%u",
			    log_ntoa(kr->r.prefix), kr->r.prefixlen);
a398 1
		}
d493 1
a493 5
				if (RB_INSERT(kroute_tree, &krt, kr) != NULL) {
					logit(LOG_CRIT, "kroute_tree insert "
					    "failed for %s/%u",
					    log_ntoa(kr->r.prefix),
					    kr->r.prefixlen);
a494 2
					continue;
				}
@


1.33
log
@by making kroute_dispatch_msg() and kroute_nexthop_add() return int instead
of void they can now report errors upstream and do not need to panic any
more. so do that and handle the errors in bgpd.c in the vein that we at least
can clean up before exit.
there are no direct fatal() call in kroute.c now any more, nor any in bgpd.c
after forking.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.32 2003/12/26 17:35:48 henning Exp $ */
d511 1
@


1.32
log
@report as many errors upstream as possible instead of fatal() so they
can be handled better
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.31 2003/12/26 16:54:10 henning Exp $ */
d399 1
a399 1
void
d412 4
a415 2
	if ((n = read(fd, &buf, sizeof(buf))) == -1)
		fatal("read error on routing socket", errno);
d417 4
a420 2
	if (n == 0)
		fatal("routing socket closed", 0);
d479 4
a482 2
				    sizeof(struct kroute_node))) == NULL)
					fatal(NULL, errno);
d504 1
a504 1
				fatal("this fatal will not last long", errno);
d568 1
a568 1
void
d587 1
a587 1
			fatal("this fatal will go away", errno);
d590 2
@


1.31
log
@handle kroute_init failures nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.30 2003/12/26 16:48:07 henning Exp $ */
d49 1
a49 1
void		kroute_protect_lo(void);
d56 2
a57 2
void		kroute_remove(struct kroute_node *);
void		kroute_nexthop_insert(in_addr_t, struct kroute_nexthop *);
d97 6
a102 2
	kroute_fetchtable();
	kroute_protect_lo();
d107 1
a107 1
void
d113 4
a116 2
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL)
		fatal(NULL, errno);
d124 2
d209 4
a212 2
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL)
			fatal(NULL, errno);
d339 12
a350 6
	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1)
		fatal("sysctl", errno);
	if ((buf = malloc(len)) == NULL)
		fatal("kroute_fetchtable", errno);
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1)
		fatal("sysctl", errno);
d364 4
a367 2
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL)
			fatal(NULL, errno);
d497 2
a498 1
			kroute_remove(kr);
a503 1

d507 1
a507 1
void
d511 1
a511 1
	struct kroute_nexthop	 nh;
d532 5
a536 4
				bzero(&nh, sizeof(nh));
				kroute_nexthop_insert(s->nexthop, &nh);
				if (nh.valid == 0)	/* no alternate route */
					send_nexthop_update(&nh);
a537 1

d539 1
d580 2
a581 1
		kroute_nexthop_insert(key, &nh);
d611 1
a611 1
void
d617 4
a620 2
	if ((h = calloc(1, sizeof(struct knexthop_node))) == NULL)
		fatal(NULL, errno);
d638 1
@


1.30
log
@provide a real log_err
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.29 2003/12/26 15:42:14 henning Exp $ */
d84 2
a85 1
	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) == -1)
d87 1
d91 1
a91 1
		return (-1);
@


1.29
log
@127/8 is special, and thus needs special protection.
on startup, insert a fake route for it to our private view of the kernel
routing table, and flag it as kernel and connected route.
we never allow a bgp route to overwrite a kernel route.
prodded by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.28 2003/12/26 15:27:31 henning Exp $ */
d84 2
a85 2
	if ((s = socket(AF_ROUTE, SOCK_RAW, 0)) < 0)
		fatal("route socket", errno);
d89 1
a89 1
		fatal("route setsockopt", errno);
@


1.28
log
@o improve logging dramatically
o handle more errors gracefullt instead of panic
o don't leak mem on RB_INSERT failues (not a common case anyway, but...)
o zap a few unneeded variables
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.27 2003/12/26 00:49:52 henning Exp $ */
d49 1
d82 1
a82 1
	int	s, opt;
d96 1
d99 17
@


1.27
log
@handle IMSG_NEXTHOP_DELETE as well
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.26 2003/12/26 00:27:23 henning Exp $ */
d60 1
a60 1
struct kroute_node * kroute_match(in_addr_t);
d135 4
a138 1
				logit(LOG_INFO, "route vanished before delete");
d140 7
a146 2
			} else			/* nexthop invalid */
				return (-1);
d149 5
a153 2
			logit(LOG_INFO, "kroute_msg: %s", strerror(errno));
			return (-1);
a163 1
	int			 n;
d172 1
a172 1
		else
d176 1
a176 1
	if ((n = kroute_msg(fd, action, kroute)) == -1)
a181 1

d188 4
a191 2
			logit(LOG_CRIT, "RB_INSERT failed!");
			return (-1);
d196 1
a196 1
	return (n);
a202 1
	int			 n;
d213 1
a213 1
	if ((n = kroute_msg(fd, RTM_DELETE, kroute)) == -1)
d267 2
d350 4
a353 2
			logit(LOG_CRIT, "RB_INSERT failed!");
			return (-1);
d375 1
d420 6
a425 2
			if (nexthop == 0)
				fatal("nexthop is 0 in kroute_dispatch!", 0);
d444 5
a448 1
					logit(LOG_CRIT, "RB_INSERT failed!");
d511 1
d590 5
a594 2
	if (RB_INSERT(knexthop_tree, &knt, h) != NULL)
		fatal("RB_INSERT(knexthop_tree, &knt, h) failed!", 0);
@


1.26
log
@kroute_nexthop_check -> kroute_nexthop_add
kroute_validate_nexthop -> kroute_nexthop_insert
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.25 2003/12/26 00:23:48 henning Exp $ */
d517 1
d519 25
@


1.25
log
@kroute_validate_nexthop is a private function
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.24 2003/12/26 00:14:04 henning Exp $ */
d56 1
a56 1
void		kroute_validate_nexthop(in_addr_t, struct kroute_nexthop *);
d471 1
a471 1
				kroute_validate_nexthop(s->nexthop, &nh);
d499 1
a499 1
kroute_nexthop_check(in_addr_t key)
d516 1
a516 1
		kroute_validate_nexthop(key, &nh);
d521 1
a521 1
kroute_validate_nexthop(in_addr_t key, struct kroute_nexthop *nh)
@


1.24
log
@finally marry rde and kroute parts of the nexthop verification:
handle IMSG_NEXTHOP_ADD and send IMSG_NEXTHOP_UPDATE when appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.23 2003/12/26 00:12:23 henning Exp $ */
d55 2
a58 1
void		kroute_remove(struct kroute_node *);
@


1.23
log
@o in struct nexthop_node, we don't need the full kroute_nexthop struct,
| the nexthop address itself is enough
o RB_INIT the nexthop table
o don't forget to set the key field before RB_INSERT...
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.22 2003/12/25 23:21:36 henning Exp $ */
a470 1
#if 0
a472 1
#endif
a515 1
#if 0
a516 1
#endif
@


1.22
log
@nothing uses the special return value kroute_msg used to set for EEXIST any
more, so zap the special treatment for EEXIST
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.21 2003/12/25 23:15:58 henning Exp $ */
d45 1
a45 1
	struct kroute_nexthop	 nh;
d92 1
d470 5
a474 5
				kroute_validate_nexthop(s->nh.nexthop, &nh);
				if (nh.valid == 0) {
					/* no alternate route */
					/* imsg_ invalid blah blah */
				}
d505 1
a505 1
	s.nh.nexthop = key;
d518 3
a520 2

	/* imsg_compose via bgpd.c blah blah blah */
d532 1
a532 1
	nh->nexthop = key;
a544 2

	/* imsg_compose via bgpd.c bla bla bla */
d550 1
a550 1
	return (b->nh.nexthop - a->nh.nexthop);
@


1.21
log
@bring us closer to a complete nexthop verification that does NOT need
periodic scans:
-keep a tree of nexthops with valid/invalid flags
-provide kroute_match, which takes an IP address and gives the kernel route
 for that
-find the kernel route for a given nexthop with that
-keep a marker on the kernel route that a nexthop depends on it
-on removal of the kernel route, re-evaluate the affected nexthops for
 validity.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.20 2003/12/25 19:24:46 henning Exp $ */
d73 1
a73 1
#define F_KERNEL		0x0002
d75 1
a75 1
#define F_NEXTHOP		0x0008
a91 1

a137 2
		case EEXIST:	/* connected route */
			return (-2);
@


1.20
log
@detect connected routes and flag them as such
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.19 2003/12/25 17:07:24 henning Exp $ */
d38 9
a46 3
	RB_ENTRY(kroute_node)	entry;
	struct kroute		r;
	int			flags;
d55 5
d65 4
d75 1
d412 2
d436 1
a436 2
			RB_REMOVE(kroute_tree, &krt, kr);
			free(kr);
d445 111
@


1.19
log
@track routing table changes that are _not_ caused by bgpd itself

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.17 2003/12/25 02:51:52 henning Exp $ */
d59 1
d303 1
d315 6
a320 4
		    NULL)
			kr->r.nexthop = sa_in->sin_addr.s_addr;

		kr->flags = F_KERNEL;
d342 1
d354 2
d380 6
a385 4
		    NULL)
			nexthop = sa_in->sin_addr.s_addr;
		else
			nexthop = 0;
d394 1
a394 1
				if (kr->flags & F_KERNEL)
d396 2
d400 1
a400 1
				   sizeof(struct kroute_node))) == NULL)
d405 1
a405 1
				kr->flags = F_KERNEL;
@


1.18
log
@factor out prefixlen_classful() and mask2prefixlen()
@
text
@d55 1
d72 2
d181 1
a181 3
	if ((kr = RB_FIND(kroute_tree, &krt, &s)) == NULL) {
		/* at the moment this is totally valid... */
		log_kroute(LOG_CRIT, "kroute_delete: no match for", kroute);
a182 1
	}
d325 91
@


1.17
log
@kill an inappropriate XXX
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.16 2003/12/25 02:50:01 henning Exp $ */
d43 6
a48 4
int	kroute_msg(int, int, struct kroute *);
int	kroute_compare(struct kroute_node *, struct kroute_node *);
void	get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
int	kroute_fetchtable(void);
d238 24
a271 1
	in_addr_t		 ina;
d296 1
a296 1
		if (rtm->rtm_flags & RTF_LLINFO)
d306 1
a306 3
			    33 - ffs(ntohl(sa_in->sin_addr.s_addr));
			if (sa_in->sin_addr.s_addr == 0 || kr->r.prefix == 0)
				kr->r.prefixlen = 0;
d309 2
a310 15
		else {
			/* classfull... */
			ina = ntohl(kr->r.prefix);

			if (ina >= 0xf0000000)		/* class E */
				kr->r.prefixlen = 32;
			else if (ina >= 0xe0000000)	/* class D */
				kr->r.prefixlen = 4;
			else if (ina >= 0xc0000000)	/* class C */
				kr->r.prefixlen = 24;
			else if (ina >= 0x80000000)	/* class B */
				kr->r.prefixlen = 16;
			else					/* class A */
				kr->r.prefixlen = 8;
		}
d325 1
a325 1
};
@


1.16
log
@remove a useless check & comment
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.15 2003/12/25 02:49:05 henning Exp $ */
d91 1
a91 1
	r.hdr.rtm_flags = RTF_GATEWAY|RTF_PROTO1; /* XXX */
@


1.15
log
@(more or less) handle ESRCH for RTM_ADD
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.14 2003/12/25 02:09:19 henning Exp $ */
a123 2
	if (n == sizeof(r))
		return (0);
d125 1
a125 2
	/* XXX we could not write everything... bad bad bad. cope. */
	return (n);
@


1.14
log
@it actually makes more sense to call the merged function kroute_change
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.13 2003/12/25 02:04:46 henning Exp $ */
d114 2
a115 1
			}
@


1.13
log
@kroute_change is obsolete, long live kroute_add
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.12 2003/12/25 01:59:34 henning Exp $ */
d131 1
a131 1
kroute_add(int fd, struct kroute *kroute)
@


1.12
log
@check with our local view wether there is already an entry for the to be
added prefix in the kernel routing table. if yes and inserted by us change
action from ADD to CHANGE, if not added by us do not add or change that
prefix.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.11 2003/12/25 01:49:53 henning Exp $ */
d147 1
a147 1
	if ((n = kroute_msg(fd, RTM_ADD, kroute)) == -1)
d150 8
a157 2
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL)
		fatal(NULL, errno);
d159 6
a164 9
	kr->r.prefix = kroute->prefix;
	kr->r.prefixlen = kroute->prefixlen;
	kr->r.nexthop = kroute->nexthop;
	kr->flags = F_BGPD_INSERTED;

	if (RB_INSERT(kroute_tree, &krt, kr) != NULL) {
		logit(LOG_CRIT, "RB_INSERT failed!");
		return (-1);
	}
a166 23
}

int
kroute_change(int fd, struct kroute *kroute)
{
	struct kroute_node	*kr, s;

	s.r.prefix = kroute->prefix;
	s.r.prefixlen = kroute->prefixlen;

	if ((kr = RB_FIND(kroute_tree, &krt, &s)) == NULL) {
		log_kroute(LOG_CRIT, "kroute_change: no match for", kroute);
		return (-1);
	}

	if (!(kr->flags & F_BGPD_INSERTED)) {
		logit(LOG_CRIT, "trying to change route not inserted by bgpd");
		return (0);
	}

	kr->r.nexthop = kroute->nexthop;

	return (kroute_msg(fd, RTM_CHANGE, kroute));
@


1.11
log
@oups, remove debugging cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.10 2003/12/25 01:48:07 henning Exp $ */
d133 1
a133 1
	struct kroute_node	*kr;
d135 1
d137 9
a145 2
	if ((n = kroute_msg(fd, RTM_ADD, kroute)) == -2) /* connected route */
		return (0);
d147 1
a147 1
	if (n == -1)
@


1.10
log
@skip over routing table entires with flag LLINFO (that's arp cache)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.9 2003/12/25 01:45:57 henning Exp $ */
a321 2
		log_kroute(LOG_CRIT, "add from kernel", &kr->r);

a326 1

@


1.9
log
@dump a copy of the kernel routing table into our own view on startup
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.8 2003/12/24 21:14:22 henning Exp $ */
d283 3
@


1.8
log
@no O_NONBLOCK for routing and tcp sockets, theo
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.7 2003/12/24 19:59:24 henning Exp $ */
d19 1
d22 1
d45 2
d55 1
d71 2
d231 99
@


1.7
log
@now that we keep track of the routes we added to the kernel we can remove
them easily on shutdown without the RDE's help
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.6 2003/12/24 19:23:26 henning Exp $ */
a58 3

	if (fcntl(s, F_SETFL, O_NONBLOCK) == -1)
		fatal(NULL, errno);
@


1.6
log
@keep track of the routes we inserted to the kernel
do only ever delete those, and no others
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.5 2003/12/23 17:38:49 henning Exp $ */
d216 10
@


1.5
log
@use RTF_PROTO1 for now
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.4 2003/12/23 16:17:15 henning Exp $ */
d21 1
d35 6
d42 7
d50 1
a50 1
u_int32_t	rtseq = 1;
d67 2
d112 2
a113 2
		case EEXIST:	/* connected route. ignore */
			return (0);
d129 23
a151 1
	return (kroute_msg(fd, RTM_ADD, kroute));
d157 17
d180 36
a215 1
	return (kroute_msg(fd, RTM_DELETE, kroute));
@


1.4
log
@no RTF_MASK
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.3 2003/12/23 16:07:37 henning Exp $ */
d71 1
a71 1
	r.hdr.rtm_flags = RTF_GATEWAY; /* XXX */
@


1.3
log
@don't panic on EEXIST. that's normal for a full-table router to get a route
for its own connected network(s)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.2 2003/12/23 15:50:12 henning Exp $ */
d71 1
a71 1
	r.hdr.rtm_flags = RTF_GATEWAY|RTF_MASK; /* XXX */
@


1.2
log
@bzero, set sin_len, and fix an error message
from debugging session with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.1 2003/12/22 15:22:13 henning Exp $ */
d86 2
a87 1
		if (errno == ESRCH) {
d95 4
a98 1
		} else {
@


1.1
log
@o add low-level functions for adding/chaining/removing kernel routes
o define new imsg types for this
o process these imsgs in the parent process

now "only" debugging and the rde sending these messages is missing.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.2 2003/12/17 19:26:26 henning Exp $ */
d67 1
d74 1
d77 1
d80 1
d95 1
a95 1
			logit(LOG_INFO, "kroute_msg", strerror(errno));
@

