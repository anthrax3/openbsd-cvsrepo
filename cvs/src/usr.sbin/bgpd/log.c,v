head	1.64;
access;
symbols
	OPENBSD_6_2:1.64.0.2
	OPENBSD_6_2_BASE:1.64
	OPENBSD_6_1:1.64.0.4
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.59.0.8
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.59.0.4
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.57.0.10
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.57.0.8
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.57.0.4
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.56.0.2
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.2
	OPENBSD_5_0:1.54.0.4
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.54.0.2
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.53.0.4
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.50.0.12
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.50.0.8
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.50.0.6
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.50.0.4
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.49.0.2
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.48.0.4
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.48.0.2
	OPENBSD_3_9_BASE:1.48
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30;
locks; strict;
comment	@ * @;


1.64
date	2017.03.21.12.06.55;	author bluhm;	state Exp;
branches;
next	1.63;
commitid	6uuBMurt3Uh42fgX;

1.63
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.62;
commitid	airB1W2Kb948lFil;

1.62
date	2017.01.23.08.38.09;	author benno;	state Exp;
branches;
next	1.61;
commitid	EfqGYzWKQHAiShLT;

1.61
date	2016.09.02.14.00.29;	author benno;	state Exp;
branches;
next	1.60;
commitid	cUiKeXOsNjNjPeSK;

1.60
date	2016.08.08.21.44.00;	author renato;	state Exp;
branches;
next	1.59;
commitid	Nu19hjaf9yj2aAQY;

1.59
date	2015.07.18.22.52.39;	author benno;	state Exp;
branches;
next	1.58;
commitid	nZLC4rTYzidfI7tQ;

1.58
date	2014.11.03.16.55.59;	author bluhm;	state Exp;
branches;
next	1.57;
commitid	SvRBB6vjZmF8ZSzf;

1.57
date	2013.01.10.09.56.57;	author sthen;	state Exp;
branches;
next	1.56;

1.56
date	2012.06.10.11.16.08;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2011.08.20.19.02.28;	author sthen;	state Exp;
branches;
next	1.54;

1.54
date	2010.11.18.12.51.24;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2009.12.03.19.20.35;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2009.11.02.20.38.15;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.25.12.02.40;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.05.17.33.40;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.03.22.19.59;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.05.23.54.05;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.27.17.52.11;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.31.12.13.07;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.26.18.49.34;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.18.14.30.10;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.18.14.10.36;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.02.10.57.57;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.09.11.00.28;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.01.20.27.24;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.21.11.58.32;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.08.19.17.20;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.08.18.21.55;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.25.22.02.55;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.25.07.16.24;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.04.25.01.52.11;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.04.16.04.47.19;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.11.12.41.36;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.05.21.44.26;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.25.23.55.40;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.28.22.12.33;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.27.22.18.29;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.27.21.23.39;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.27.21.20.44;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.27.16.49.53;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.23.21.17.51;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.22.21.09.00;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.22.20.59.17;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.22.19.13.56;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.22.19.07.33;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.22.03.18.04;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.19.23.15.08;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.04.02.13.52;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.30.18.47.00;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.30.13.03.27;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.26.20.06.01;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.26.18.07.32;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.26.16.48.07;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.26.16.37.04;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.26.14.27.58;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.26.14.26.02;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.24.19.21.20;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.21.23.17.53;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.20.18.32.22;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.17.18.11.31;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;


desc
@@


1.64
log
@From a syslog perspective it does not make sense to log fatal and
warn with the same severity.  Switch log_warn() to LOG_ERR and keep
fatal() at LOG_CRIT.
OK reyk@@ florian@@
@
text
@/*	$OpenBSD: log.c,v 1.63 2017/01/24 04:22:42 benno Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <syslog.h>
#include <errno.h>
#include <time.h>

#include "log.h"

static int		 debug;
static int		 verbose;
static const char	*log_procname;

void
log_init(int n_debug, int facility)
{
	extern char	*__progname;

	debug = n_debug;
	verbose = n_debug;
	log_procinit(__progname);

	if (!debug)
		openlog(__progname, LOG_PID | LOG_NDELAY, facility);

	tzset();
}

void
log_procinit(const char *procname)
{
	if (procname != NULL)
		log_procname = procname;
}

void
log_setverbose(int v)
{
	verbose = v;
}

int
log_getverbose(void)
{
	return (verbose);
}

void
logit(int pri, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vlog(pri, fmt, ap);
	va_end(ap);
}

void
vlog(int pri, const char *fmt, va_list ap)
{
	char	*nfmt;
	int	 saved_errno = errno;

	if (debug) {
		/* best effort in out of mem situations */
		if (asprintf(&nfmt, "%s\n", fmt) == -1) {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		} else {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
		}
		fflush(stderr);
	} else
		vsyslog(pri, fmt, ap);

	errno = saved_errno;
}

void
log_warn(const char *emsg, ...)
{
	char		*nfmt;
	va_list		 ap;
	int		 saved_errno = errno;

	/* best effort to even work in out of memory situations */
	if (emsg == NULL)
		logit(LOG_ERR, "%s", strerror(saved_errno));
	else {
		va_start(ap, emsg);

		if (asprintf(&nfmt, "%s: %s", emsg,
		    strerror(saved_errno)) == -1) {
			/* we tried it... */
			vlog(LOG_ERR, emsg, ap);
			logit(LOG_ERR, "%s", strerror(saved_errno));
		} else {
			vlog(LOG_ERR, nfmt, ap);
			free(nfmt);
		}
		va_end(ap);
	}

	errno = saved_errno;
}

void
log_warnx(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_ERR, emsg, ap);
	va_end(ap);
}

void
log_info(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_INFO, emsg, ap);
	va_end(ap);
}

void
log_debug(const char *emsg, ...)
{
	va_list	 ap;

	if (verbose) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

static void
vfatalc(int code, const char *emsg, va_list ap)
{
	static char	s[BUFSIZ];
	const char	*sep;

	if (emsg != NULL) {
		(void)vsnprintf(s, sizeof(s), emsg, ap);
		sep = ": ";
	} else {
		s[0] = '\0';
		sep = "";
	}
	if (code)
		logit(LOG_CRIT, "fatal in %s: %s%s%s",
		    log_procname, s, sep, strerror(code));
	else
		logit(LOG_CRIT, "fatal in %s%s%s", log_procname, sep, s);
}

void
fatal(const char *emsg, ...)
{
	va_list	ap;

	va_start(ap, emsg);
	vfatalc(errno, emsg, ap);
	va_end(ap);
	exit(1);
}

void
fatalx(const char *emsg, ...)
{
	va_list	ap;

	va_start(ap, emsg);
	vfatalc(0, emsg, ap);
	va_end(ap);
	exit(1);
}
@


1.63
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.34 2017/01/09 14:49:21 reyk Exp $	*/
d108 1
a108 1
		logit(LOG_CRIT, "%s", strerror(saved_errno));
d115 2
a116 2
			vlog(LOG_CRIT, emsg, ap);
			logit(LOG_CRIT, "%s", strerror(saved_errno));
d118 1
a118 1
			vlog(LOG_CRIT, nfmt, ap);
d133 1
a133 1
	vlog(LOG_CRIT, emsg, ap);
@


1.62
log
@whitespace
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.61 2016/09/02 14:00:29 benno Exp $ */
a18 2
#include <errno.h>
#include <stdarg.h>
d21 1
d24 1
d29 3
a31 3
int		 debug;
int		 verbose;
const char	*log_procname;
d34 1
a34 1
log_init(int n_debug)
d39 2
d43 1
a43 1
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);
d49 8
a56 1
log_verbose(int v)
d61 6
d81 1
d95 2
d102 3
a104 2
	char	*nfmt;
	va_list	 ap;
d108 1
a108 1
		logit(LOG_CRIT, "%s", strerror(errno));
d112 2
a113 1
		if (asprintf(&nfmt, "%s: %s", emsg, strerror(errno)) == -1) {
d116 1
a116 1
			logit(LOG_CRIT, "%s", strerror(errno));
d123 2
d159 20
d182 1
a182 2
	char	 s[1024];
	va_list	 ap;
d185 1
a185 1
	vsnprintf(s, sizeof(s), emsg, ap);
a186 12

	if (emsg == NULL)
		logit(LOG_CRIT, "fatal in %s: %s", log_procname,
		    strerror(errno));
	else
		if (errno)
			logit(LOG_CRIT, "fatal in %s: %s: %s",
			    log_procname, s, strerror(errno));
		else
			logit(LOG_CRIT, "fatal in %s: %s",
			    log_procname, s);

d191 1
a191 1
fatalx(const char *emsg)
d193 6
a198 2
	errno = 0;
	fatal(emsg);
@


1.61
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.60 2016/08/08 21:44:00 renato Exp $ */
d141 1
a141 1
	va_list  ap;
@


1.60
log
@Use exit(3) instead of _exit(2) in the child processes.

Since recently the child processes call exec() after fork(), so they
should stop using _exit(2) and use exit(3) instead when shutting down.

Ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.59 2015/07/18 22:52:39 benno Exp $ */
a18 1
#include <err.h>
a19 1
#include <netdb.h>
a25 1
#include <unistd.h>
a26 2
#include "bgpd.h"
#include "session.h"
d29 3
a31 31
int	debug;
int	verbose;

char *
log_fmt_peer(const struct peer_config *peer)
{
	const char	*ip;
	char		*pfmt, *p;

	ip = log_addr(&peer->remote_addr);
	if ((peer->remote_addr.aid == AID_INET && peer->remote_masklen != 32) ||
	    (peer->remote_addr.aid == AID_INET6 &&
	    peer->remote_masklen != 128)) {
		if (asprintf(&p, "%s/%u", ip, peer->remote_masklen) == -1)
			fatal(NULL);
	} else {
		if ((p = strdup(ip)) == NULL)
			fatal(NULL);
	}

	if (peer->descr[0]) {
		if (asprintf(&pfmt, "neighbor %s (%s)", p, peer->descr) ==
		    -1)
			fatal(NULL);
	} else {
		if (asprintf(&pfmt, "neighbor %s", p) == -1)
			fatal(NULL);
	}
	free(p);
	return (pfmt);
}
a80 39

void
log_peer_warn(const struct peer_config *peer, const char *emsg, ...)
{
	char	*p, *nfmt;
	va_list	 ap;

	p = log_fmt_peer(peer);
	if (emsg == NULL) {
		if (asprintf(&nfmt, "%s: %s", p, strerror(errno)) == -1)
			fatal(NULL);
	} else {
		if (asprintf(&nfmt, "%s: %s: %s", p, emsg, strerror(errno)) ==
		    -1)
			fatal(NULL);
	}
	va_start(ap, emsg);
	vlog(LOG_CRIT, nfmt, ap);
	va_end(ap);
	free(p);
	free(nfmt);
}

void
log_peer_warnx(const struct peer_config *peer, const char *emsg, ...)
{
	char	*p, *nfmt;
	va_list	 ap;

	p = log_fmt_peer(peer);
	if (asprintf(&nfmt, "%s: %s", p, emsg) == -1)
		fatal(NULL);
	va_start(ap, emsg);
	vlog(LOG_CRIT, nfmt, ap);
	va_end(ap);
	free(p);
	free(nfmt);
}

d148 1
a148 1
		logit(LOG_CRIT, "fatal in %s: %s", procnames[bgpd_process],
d153 1
a153 1
			    procnames[bgpd_process], s, strerror(errno));
d156 1
a156 1
			    procnames[bgpd_process], s);
a165 106
}

void
log_statechange(struct peer *peer, enum session_state nstate,
    enum session_events event)
{
	char	*p;

	/* don't clutter the logs with constant Connect -> Active -> Connect */
	if (nstate == STATE_CONNECT && peer->state == STATE_ACTIVE &&
	    peer->prev_state == STATE_CONNECT)
		return;
	if (nstate == STATE_ACTIVE && peer->state == STATE_CONNECT &&
	    peer->prev_state == STATE_ACTIVE)
		return;

	peer->lasterr = 0;
	p = log_fmt_peer(&peer->conf);
	logit(LOG_INFO, "%s: state change %s -> %s, reason: %s",
	    p, statenames[peer->state], statenames[nstate], eventnames[event]);
	free(p);
}

void
log_notification(const struct peer *peer, u_int8_t errcode, u_int8_t subcode,
    u_char *data, u_int16_t datalen, const char *dir)
{
	char		*p;
	const char	*suberrname = NULL;
	int		 uk = 0;

	p = log_fmt_peer(&peer->conf);
	switch (errcode) {
	case ERR_HEADER:
		if (subcode >= sizeof(suberr_header_names)/sizeof(char *))
			uk = 1;
		else
			suberrname = suberr_header_names[subcode];
		break;
	case ERR_OPEN:
		if (subcode >= sizeof(suberr_open_names)/sizeof(char *))
			uk = 1;
		else
			suberrname = suberr_open_names[subcode];
		break;
	case ERR_UPDATE:
		if (subcode >= sizeof(suberr_update_names)/sizeof(char *))
			uk = 1;
		else
			suberrname = suberr_update_names[subcode];
		break;
	case ERR_CEASE:
		if (subcode >= sizeof(suberr_cease_names)/sizeof(char *))
			uk = 1;
		else
			suberrname = suberr_cease_names[subcode];
		break;
	case ERR_HOLDTIMEREXPIRED:
		if (subcode != 0)
			uk = 1;
		break;
	case ERR_FSM:
		if (subcode >= sizeof(suberr_fsm_names)/sizeof(char *))
			uk = 1;
		else
			suberrname = suberr_fsm_names[subcode];
		break;
	default:
		logit(LOG_CRIT, "%s: %s notification, unknown errcode "
		    "%u, subcode %u", p, dir, errcode, subcode);
		free(p);
		return;
	}

	if (uk)
		logit(LOG_CRIT, "%s: %s notification: %s, unknown subcode %u",
		    p, dir, errnames[errcode], subcode);
	else {
		if (suberrname == NULL)
			logit(LOG_CRIT, "%s: %s notification: %s", p,
			    dir, errnames[errcode]);
		else
			logit(LOG_CRIT, "%s: %s notification: %s, %s",
			    p, dir, errnames[errcode], suberrname);
	}
	free(p);
}

void
log_conn_attempt(const struct peer *peer, struct sockaddr *sa)
{
	char		*p;
	const char	*b;

	if (peer == NULL) {	/* connection from non-peer, drop */
		b = log_sockaddr(sa);
		logit(LOG_INFO, "connection from non-peer %s refused", b);
	} else {
		/* only log if there is a chance that the session may come up */
		if (peer->conf.down && peer->state == STATE_IDLE)
			return;
		p = log_fmt_peer(&peer->conf);
		logit(LOG_INFO, "Connection attempt from %s while session is "
		    "in state %s", p, statenames[peer->state]);
		free(p);
	}
@


1.59
log
@give bgpd's fatal() varargs and use it to instrument bgpd fatal()
calls to aid in debugging
henning@@ "makes sense to me", sthen@@ "yes please", ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.58 2014/11/03 16:55:59 bluhm Exp $ */
d230 1
a230 4
	if (bgpd_process == PROC_MAIN)
		exit(1);
	else				/* parent copes via SIGCHLD */
		_exit(1);
@


1.58
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK benno@@ doug@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.57 2013/01/10 09:56:57 sthen Exp $ */
d210 1
a210 1
fatal(const char *emsg)
d212 7
d225 1
a225 1
			    procnames[bgpd_process], emsg, strerror(errno));
d228 1
a228 1
			    procnames[bgpd_process], emsg);
@


1.57
log
@Don't log "unknown subcode" for subcode 0 when the hold timer expires,
this is a normal condition. ok phessler@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.56 2012/06/10 11:16:08 claudio Exp $ */
a35 2

void	 logit(int, const char *, ...);
@


1.56
log
@Add error messages for BGP Finite State Machine Error subcodes as defined
in RFC 6608. OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.55 2011/08/20 19:02:28 sthen Exp $ */
d294 2
a295 1
		uk = 1;
@


1.55
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"-v" (previously only "-vd" worked). Similar to recent ospfd commit.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.54 2010/11/18 12:51:24 claudio Exp $ */
d294 2
d297 4
a300 1
		uk = 1;
@


1.54
log
@Log sent notification messages as well having them in the log may
help to figure out the cause of flapping session faster.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.53 2009/12/03 19:20:35 claudio Exp $ */
a73 1
	verbose = n_debug;
@


1.53
log
@Only log if there is a chance that the session may come up if the neighbor
is administrativly down save the electrons for more important messages.
After a short discussion with Elisa Jasinska from ams-ix. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.52 2009/12/01 14:28:05 claudio Exp $ */
d262 1
a262 1
    u_char *data, u_int16_t datalen)
d299 2
a300 2
		logit(LOG_CRIT, "%s: received notification, unknown errcode "
		    "%u, subcode %u", p, errcode, subcode);
d306 2
a307 3
		logit(LOG_CRIT,
		    "%s: received notification: %s, unknown subcode %u",
		    p, errnames[errcode], subcode);
d310 2
a311 2
			logit(LOG_CRIT, "%s: received notification: %s",
			    p, errnames[errcode]);
d313 2
a314 2
			logit(LOG_CRIT, "%s: received notification: %s, %s",
			    p, errnames[errcode], suberrname);
@


1.52
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.51 2009/11/02 20:38:15 claudio Exp $ */
d330 3
@


1.51
log
@Implement IMSG_CTL_LOG_VERBOSE similar to ospfd. Even though bgpd has almost
no log_debug() it makes more sense to make all routing daemons behave the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.50 2007/04/23 13:04:24 claudio Exp $ */
d46 3
a48 2
	if ((peer->remote_addr.af == AF_INET && peer->remote_masklen != 32) ||
	    (peer->remote_addr.af == AF_INET6 && peer->remote_masklen != 128)) {
@


1.50
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.49 2007/02/25 12:02:40 henning Exp $ */
d35 1
d73 1
d82 6
d204 1
a204 1
	if (debug) {
@


1.49
log
@we do have a table with suberror codes for cease and their meaning;
use it, instead of always telling "unknown suberror code X"
From: Leen Besselink <leen@@consolejunkie.net>
if memory serves, cease didn't have suberror codes defined in the original
RFC 1771 and they were added later
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.48 2006/01/05 17:33:40 claudio Exp $ */
a35 1
char	*log_fmt_peer(const struct peer_config *);
@


1.48
log
@Kill ENSURE(), remove ensure.h, say bye bye to fatal_ensure() and
one hip hip hooray from Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.47 2006/01/03 22:19:59 claudio Exp $ */
d280 6
a287 1
	case ERR_CEASE:
@


1.47
log
@Move functions shared with bgpctl into new file util.c. Simplifies the
link between bgpctl and bgpd mostly because of rde_attr.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.46 2005/06/05 23:54:05 henning Exp $ */
a228 11
}

void
fatal_ensure(const char *file, int line, const char *cond)
{
	logit(LOG_CRIT, "ENSURE (%s) failed in file %s on line %d",
	    cond, file, line);

	/* XXX check which process we are and notify others! */
	sleep(10);
	_exit(1);
@


1.46
log
@make log_in6addr actually work correctly - it is astounding how ugly things
are in the v6 world. the lower 16 bits of the scope ID are embedded in
byte 3 and 4 of the address for link-local addresses... sometimes, at least.
these btes have to be 0 by definition, so we need to fiddle the scope ID out
and reset those bytes to 0. embedding the scopeID like that is the most
disgusting hack I have seen in a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.45 2005/05/27 17:52:11 claudio Exp $ */
a332 46
}

const char *
log_addr(const struct bgpd_addr *addr)
{
	static char	buf[48];

	if (inet_ntop(addr->af, &addr->ba, buf, sizeof(buf)) == NULL)
		return ("?");
	else
		return (buf);
}

const char *
log_in6addr(const struct in6_addr *addr)
{
	struct sockaddr_in6	sa_in6;
	u_int16_t		tmp16;

	bzero(&sa_in6, sizeof(sa_in6));
	sa_in6.sin6_len = sizeof(sa_in6);
	sa_in6.sin6_family = AF_INET6;
	memcpy(&sa_in6.sin6_addr, addr, sizeof(sa_in6.sin6_addr));

	/* XXX thanks, KAME, for this ugliness... adopted from route/show.c */
	if (IN6_IS_ADDR_LINKLOCAL(&sa_in6.sin6_addr) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&sa_in6.sin6_addr)) {
		memcpy(&tmp16, &sa_in6.sin6_addr.s6_addr[2], sizeof(tmp16));
		sa_in6.sin6_scope_id = ntohs(tmp16);
		sa_in6.sin6_addr.s6_addr[2] = 0;
		sa_in6.sin6_addr.s6_addr[3] = 0;
	}

	return (log_sockaddr((struct sockaddr *)&sa_in6));
}

const char *
log_sockaddr(struct sockaddr *sa)
{
	static char	buf[NI_MAXHOST];

	if (getnameinfo(sa, sa->sa_len, buf, sizeof(buf), NULL, 0,
	    NI_NUMERICHOST))
		return ("(unknown)");
	else
		return (buf);
@


1.45
log
@kroute6 support, at least partially. Get it in so that Henning can clean it
up more. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.44 2005/03/31 12:13:07 henning Exp $ */
d349 16
a364 1
	static char	buf[48];
d366 1
a366 4
	if (inet_ntop(AF_INET6, addr, buf, sizeof(buf)) == NULL)
		return ("?");
	else
		return (buf);
@


1.44
log
@zap some includes we don't need, Alexander von Gernler <grunk@@pestilenz.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.43 2005/03/26 18:49:34 tedu Exp $ */
d341 11
@


1.43
log
@proper check on log type.  ok henning claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.42 2004/11/18 14:30:10 henning Exp $ */
a17 5

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
@


1.42
log
@it's oupsa oupsa oupsa time...
writing to a member of a const struct is no good, so un-const struct peer
for log_statechange()
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.41 2004/11/18 14:10:36 henning Exp $ */
d279 1
a279 1
		if (subcode > sizeof(suberr_header_names)/sizeof(char *))
d285 1
a285 1
		if (subcode > sizeof(suberr_open_names)/sizeof(char *))
d291 1
a291 1
		if (subcode > sizeof(suberr_update_names)/sizeof(char *))
@


1.41
log
@supress logging of subsequent connect() failures as long as:
-the session alternates between Active and Connect. Other states reset logging
-the error is the same as the last connect() error seen
jajajaja claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.40 2004/11/02 10:57:57 henning Exp $ */
d248 1
a248 1
log_statechange(const struct peer *peer, enum session_state nstate,
@


1.40
log
@supress logging of the (likely very long) repeated Connect -> Active ->
Connect -> Active state changes, just clutters logs, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.39 2004/07/09 11:00:28 henning Exp $ */
d261 1
@


1.39
log
@let log_debug only log at all when we're in debug mode, from Montreal Airport
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.38 2004/06/01 20:27:24 henning Exp $ */
d252 8
@


1.38
log
@I would have sworn I added tzset() here
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.37 2004/05/21 11:58:32 henning Exp $ */
d202 5
a206 3
	va_start(ap, emsg);
	vlog(LOG_DEBUG, emsg, ap);
	va_end(ap);
@


1.37
log
@move the big name tables to the .h file, makes the .c easier
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.36 2004/05/08 19:17:20 henning Exp $ */
d32 1
d81 2
@


1.36
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.35 2004/05/08 18:21:55 henning Exp $ */
a38 66

static const char *eventnames[] = {
	"None",
	"Start",
	"Stop",
	"Connection opened",
	"Connection closed",
	"Connection open failed",
	"Fatal error",
	"ConnectRetryTimer expired",
	"HoldTimer expired",
	"KeepaliveTimer expired",
	"OPEN message received",
	"KEEPALIVE message received",
	"UPDATE message received",
	"NOTIFICATION received"
};

static const char *errnames[] = {
	"none",
	"Header error",
	"error in OPEN message",
	"error in UPDATE message",
	"HoldTimer expired",
	"Finite State Machine error",
	"Cease"
};

static const char *suberr_header_names[] = {
	"none",
	"synchronization error",
	"wrong length",
	"unknown message type"
};

static const char *suberr_open_names[] = {
	"none",
	"version mismatch",
	"AS unacceptable",
	"BGPID invalid",
	"optional parameter error",
	"Authentication error",
	"unacceptable holdtime",
	"unsupported capability"
};

static const char *suberr_update_names[] = {
	"none",
	"attribute list error",
	"unknown well-known attribute",
	"well-known attribute missing",
	"attribute flags error",
	"attribute length wrong",
	"origin unacceptable",
	"loop detected",
	"nexthop unacceptable",
	"optional attribute error",
	"network unacceptable",
	"AS-Path unacceptable"
};

static const char *procnames[] = {
	"parent",
	"SE",
	"RDE"
};
@


1.35
log
@provide log_sockaddr, which uses getnameinfo(), and use it in
log_conn_attempt
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.34 2004/04/25 22:02:55 henning Exp $ */
d408 2
a409 1
	if (getnameinfo(sa, sa->sa_len, buf, sizeof(buf), NULL, 0, NI_NUMERICHOST))
@


1.34
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.33 2004/04/25 07:16:24 henning Exp $ */
d378 2
a379 1
	char *p,  buf[NI_MAXHOST];
d382 2
a383 4
		if (getnameinfo(sa, sa->sa_len, buf, sizeof(buf), NULL, 0,
		    NI_NUMERICHOST))
			strlcpy(buf, "(unknown)", sizeof(buf));
		logit(LOG_INFO, "connection from non-peer %s refused", buf);
d399 11
@


1.33
log
@add "neighbor cloning", allowing you to specify a prefix and prefixlength
instead of the neighbor's IP address. WHen a connection comes in matching
that mask we clone the neighbor spec.
IPv6 match code by itojun, rde feeding by claudio, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.32 2004/04/25 01:52:11 henning Exp $ */
d121 1
a121 1
		if((p = strdup(ip)) == NULL)
@


1.32
log
@unbreak log_conn_attempt, bah crap crap crap crap crap crap crap crap crap
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.31 2004/04/16 04:47:19 henning Exp $ */
d113 1
a113 1
	char		*pfmt;
d116 9
d126 1
a126 1
		if (asprintf(&pfmt, "neighbor %s (%s)", ip, peer->descr) ==
d130 1
a130 1
		if (asprintf(&pfmt, "neighbor %s", ip) == -1)
d133 1
d378 1
a378 2
	char *p, buf[48];

@


1.31
log
@make log_conn_attempt work in an address family independent matter
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.30 2004/03/11 12:41:36 henning Exp $ */
d26 1
d372 2
a373 1
		if (inet_ntop(sa->sa_family, sa, buf, sizeof(buf)) == NULL)
@


1.30
log
@fflush(stderr) in vlog if in debug mode, from discussion with and ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.29 2004/03/05 21:44:26 henning Exp $ */
d365 1
a365 1
log_conn_attempt(const struct peer *peer, struct in_addr remote)
d367 1
a367 1
	char *p;
d369 6
a374 4
	if (peer == NULL)	/* connection from non-peer, drop */
		logit(LOG_INFO, "connection from non-peer %s refused",
			    inet_ntoa(remote));
	else {
@


1.29
log
@new error code "unsupported capability" from RFC 3392
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.28 2004/02/25 23:55:40 henning Exp $ */
d161 1
@


1.28
log
@use __progname instead of hardcoding bgpd for log_init
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.27 2004/01/28 22:12:33 henning Exp $ */
d80 2
a81 1
	"unacceptable holdtime"
@


1.27
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.26 2004/01/27 22:18:29 henning Exp $ */
d128 2
d133 1
a133 1
		openlog("bgpd", LOG_PID | LOG_NDELAY, LOG_DAEMON);
@


1.26
log
@log_ntoa is herewith condemned to death by claudio and yours truly
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.25 2004/01/27 21:23:39 henning Exp $ */
d381 1
a381 1
	if(inet_ntop(addr->af, &addr->ba, buf, sizeof(buf)) == NULL)
@


1.25
log
@constify log_addr and log_ntoa's returns, reminded by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.24 2004/01/27 21:20:44 henning Exp $ */
a373 9
}

const char *
log_ntoa(in_addr_t ip)
{
	struct in_addr	ina;

	ina.s_addr = ip;
	return (inet_ntoa(ina));
@


1.24
log
@use inet_ntop() for log_addr(), claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.23 2004/01/27 16:49:53 henning Exp $ */
d110 1
a110 1
	char		*ip;
d376 1
a376 1
char *
d385 1
a385 1
char *
@


1.23
log
@use a struct bgpd_addr instead of sockaddr_in for peer_config->local_addr and
->remote_addr for easier multiprotocol support

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.22 2004/01/23 21:17:51 henning Exp $ */
d386 8
a393 7
log_addr(const struct bgpd_addr *addr) {
	switch (addr->af) {
	case AF_INET:
		return (inet_ntoa(addr->v4));
	default:
		return ("(unknown address family)");
	}
@


1.22
log
@provide log_addr, which takes a struct bgpd_addr
intended to replace log_ntoa in most cases becaus that is IPv4 only by design
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.21 2004/01/22 21:09:00 henning Exp $ */
d113 1
a113 1
	ip = inet_ntoa(peer->remote_addr.sin_addr);
d386 1
a386 1
log_addr(struct bgpd_addr *addr) {
@


1.21
log
@provide a log_debug and use it in rde.c.
with this, logit() can be a private function.
we don't need to include syslog.h in bgpd.h any more; log.c and parse.y
who need it include it directly now.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.20 2004/01/22 20:59:17 henning Exp $ */
d383 10
@


1.20
log
@make log_peer_* take a struct peer_config instead of the session engine
specific struct peer, and move their prototypes to bgpd.h to make it available
to whole bgpd

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.19 2004/01/22 19:13:56 henning Exp $ */
d30 1
d105 1
d242 10
@


1.19
log
@provide log_warnx() and log_info()
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.18 2004/01/22 19:07:33 henning Exp $ */
d103 1
a103 1
char	*log_fmt_peer(const struct peer *);
d106 1
a106 1
log_fmt_peer(const struct peer *peer)
d111 3
a113 3
	ip = inet_ntoa(peer->conf.remote_addr.sin_addr);
	if (peer->conf.descr[0]) {
		if (asprintf(&pfmt, "neighbor %s (%s)", ip, peer->conf.descr) ==
d162 1
a162 1
log_peer_warn(const struct peer *peer, const char *emsg, ...)
d184 1
a184 1
log_peer_warnx(const struct peer *peer, const char *emsg, ...)
d287 1
a287 1
	p = log_fmt_peer(peer);
d301 1
a301 1
	p = log_fmt_peer(peer);
d357 1
a357 1
		p = log_fmt_peer(peer);
@


1.18
log
@log_peer_err -> log_peer_warn
log_peer_errx -> log_peer_warnx
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.17 2004/01/22 03:18:04 henning Exp $ */
d221 20
@


1.17
log
@s/log_err/log_warn/
it is like warn(3), nor err(3). so use a less confusing name.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.16 2004/01/19 23:15:08 henning Exp $ */
d162 1
a162 1
log_peer_err(const struct peer *peer, const char *emsg, ...)
d184 1
a184 1
log_peer_errx(const struct peer *peer, const char *emsg, ...)
@


1.16
log
@(v)fprintf atomically in vlog() in debug mode, prodded by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.15 2004/01/06 03:43:50 henning Exp $ */
d200 1
a200 1
log_err(const char *emsg, ...)
@


1.15
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.14 2004/01/04 02:13:52 henning Exp $ */
d145 2
d148 8
a155 2
		vfprintf(stderr, fmt, ap);
		fprintf(stderr, "\n");
@


1.14
log
@share statenames
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.13 2003/12/30 18:47:00 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.13
log
@missing free()s; From: Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.12 2003/12/30 13:03:27 henning Exp $ */
d34 1
d36 1
a36 9
static const char *statenames[] = {
	"None",
	"Idle",
	"Connect",
	"Active",
	"OpenSent",
	"OpenConfirm",
	"Established"
};
a101 2

int	debug;
@


1.12
log
@typos from david
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.11 2003/12/26 20:06:01 jakob Exp $ */
d181 1
d197 1
a206 3

	va_start(ap, emsg);

d210 2
d216 1
a216 1
		} else
d218 3
a221 1
	va_end(ap);
@


1.11
log
@constify; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.10 2003/12/26 18:07:32 henning Exp $ */
d85 1
a85 1
	"Authentification error",
@


1.10
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.9 2003/12/26 16:48:07 henning Exp $ */
d112 1
a112 1
char	*log_fmt_peer(struct peer *);
d115 1
a115 1
log_fmt_peer(struct peer *peer)
d163 1
a163 1
log_peer_err(struct peer *peer, const char *emsg, ...)
d184 1
a184 1
log_peer_errx(struct peer *peer, const char *emsg, ...)
d260 1
a260 1
log_statechange(struct peer *peer, enum session_state nstate,
d272 1
a272 1
log_notification(struct peer *peer, u_int8_t errcode, u_int8_t subcode,
d327 1
a327 1
log_conn_attempt(struct peer *peer, struct in_addr remote)
@


1.9
log
@provide a real log_err
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.8 2003/12/26 16:37:04 henning Exp $ */
d124 1
a124 1
			fatal(NULL, errno);
d127 1
a127 1
			fatal(NULL, errno);
d171 1
a171 1
			fatal(NULL, errno);
d175 1
a175 1
			fatal(NULL, errno);
d191 1
a191 1
		fatal(NULL, errno);
d222 1
a222 1
fatal(const char *emsg, int error)
d226 1
a226 1
		    strerror(error));
d228 1
a228 1
		if (error)
d230 1
a230 1
			    procnames[bgpd_process], emsg, strerror(error));
d239 7
@


1.8
log
@log_err -> log_peer_err
log_errx -> log_peer_errx

because that is what they really are, peer specific.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.7 2003/12/26 14:27:58 henning Exp $ */
d196 23
@


1.7
log
@+ log_ntoa, a simple helper funtion that doesn't require a struct in_addr...
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2003/12/26 14:26:02 henning Exp $ */
d163 1
a163 1
log_err(struct peer *peer, const char *emsg, ...)
d184 1
a184 1
log_errx(struct peer *peer, const char *emsg, ...)
@


1.6
log
@remove he pathetic log_kroute()
not used anywhere anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2003/12/24 19:21:20 henning Exp $ */
d310 9
@


1.5
log
@add log_kroute()
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.4 2003/12/21 23:17:53 henning Exp $ */
a309 12
}

void
log_kroute(int pri, const char *lmsg, struct kroute *kr)
{
	char			*ip;
	struct in_addr		 ina;

	ina.s_addr = kr->prefix;

	ip = inet_ntoa(ina);
	logit(pri, "%s %s/%u", lmsg, ip, kr->prefixlen);
@


1.4
log
@little KNF inbetween
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2003/12/20 18:32:22 henning Exp $ */
d310 12
@


1.3
log
@keep track which process we are so fatal() can log in which proc the
condition happened. fatal()s from subsystems used by all 3 processes like
the imsg subsystem were hard to track down without knowing in which process
the condition happened.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2003/12/17 18:11:31 henning Exp $ */
d275 2
a276 2
		logit(LOG_CRIT, "%s: received notification, unknown errcode %u, "
		    "subcode %u", p, errcode, subcode);
d306 2
a307 2
		logit(LOG_INFO, "Connection attempt from %s while session is in "
		    "state %s", p, statenames[peer->state]);
@


1.2
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d104 6
d202 2
a203 1
		logit(LOG_CRIT, "%s", strerror(error));
d206 2
a207 1
			logit(LOG_CRIT, "%s: %s", emsg, strerror(error));
d209 2
a210 1
			logit(LOG_CRIT, "%s", emsg);
d212 4
a215 3
	/* XXX check which process we are and notify others! */
	sleep(10);
	_exit(1);
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d117 1
a117 1
		     -1)
d174 1
a174 1
	free (p);
d189 1
a189 1
	free (p);
d205 1
a205 1
	_exit (1);
d216 1
a216 1
	_exit (1);
@

