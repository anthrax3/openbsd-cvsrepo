head	1.67;
access;
symbols
	OPENBSD_6_2:1.67.0.2
	OPENBSD_6_2_BASE:1.67
	OPENBSD_6_1:1.65.0.4
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.63.0.6
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.61.0.4
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.57.0.6
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.57.0.4
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.56.0.12
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.56.0.10
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.56.0.8
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.6
	OPENBSD_5_0:1.56.0.4
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.56.0.2
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.54.0.2
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.51.0.6
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.50.0.4
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.50.0.2
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.49.0.4
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.49.0.2
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.47.0.2
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.41.0.2
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33;
locks; strict;
comment	@ * @;


1.67
date	2017.05.29.09.56.33;	author benno;	state Exp;
branches;
next	1.66;
commitid	ieP18OTy3lGXvWYC;

1.66
date	2017.05.28.15.16.33;	author henning;	state Exp;
branches;
next	1.65;
commitid	kb8h0G47giazo9qA;

1.65
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.64;
commitid	airB1W2Kb948lFil;

1.64
date	2017.01.17.22.10.55;	author krw;	state Exp;
branches;
next	1.63;
commitid	nf3UdaW8au6U0a03;

1.63
date	2016.01.26.18.35.01;	author mmcc;	state Exp;
branches;
next	1.62;
commitid	GsRXMVCQnadZuSoJ;

1.62
date	2015.12.01.11.58.31;	author claudio;	state Exp;
branches;
next	1.61;
commitid	PSNVQbXn92Mmo1Gy;

1.61
date	2015.07.16.18.26.04;	author claudio;	state Exp;
branches;
next	1.60;
commitid	LqSO5lx1xfCVcctP;

1.60
date	2015.03.14.02.43.02;	author claudio;	state Exp;
branches;
next	1.59;
commitid	0cBsZXPDxYuXNDWX;

1.59
date	2015.03.14.02.32.35;	author claudio;	state Exp;
branches;
next	1.58;
commitid	aIIJ7KgsYMwjPwU7;

1.58
date	2015.02.09.11.37.31;	author claudio;	state Exp;
branches;
next	1.57;
commitid	IcuyF0sCmFRE7OTK;

1.57
date	2013.11.13.09.14.48;	author florian;	state Exp;
branches;
next	1.56;

1.56
date	2010.10.24.17.20.08;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.54;

1.54
date	2010.06.27.19.53.34;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2010.05.17.15.49.29;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2009.01.26.23.10.02;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2007.10.13.16.35.20;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.31.13.04.21;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.15.11.33.42;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.24.10.03.44;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.14.09.24.38;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.30.11.23.15;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.28.14.19.56;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.26.23.04.34;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.23.22.26.34;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.15.14.40.08;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.10.01.15.11.12;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.20.17.49.46;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.06.17.38.10;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.21.15.36.40;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.04.21.22.39;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.27.04.37.53;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.31.10.26.34;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.17.17.49.53;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.16.18.35.30;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.03.10.13.48;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.02.19.45.04;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.26.14.00.33;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.10.23.10.23;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.03.22.28.05;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.01.19.46.05;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.30.23.24.04;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.28.17.24.38;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.28.11.03.32;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.27.16.49.53;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.27.14.09.36;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.26.14.42.47;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.24.17.38.30;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.22.20.34.55;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.07.01.15.54;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.03.20.37.34;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.03.20.22.07;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.02.22.47.33;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.30.13.03.27;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.27.18.43.36;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.27.14.58.22;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.26.20.52.14;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.26.18.07.32;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.25.17.35.53;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.25.17.27.36;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.24.23.48.06;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.24.13.49.21;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.23.01.06.21;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.19.14.23.28;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;


desc
@@


1.67
log
@change bgpd's control socket from /var/run/bgpd.sock to
/var/run/bgpd.sock.<rdomain> in both bgpd and bgpctl. makes life
easier for admins.
ok phessler, claudio, henning, feedback from Job Snijders
@
text
@/*	$OpenBSD: config.c,v 1.66 2017/05/28 15:16:33 henning Exp $ */

/*
 * Copyright (c) 2003, 2004, 2005 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/ioctl.h>

#include <netmpls/mpls.h>

#include <errno.h>
#include <ifaddrs.h>
#include <netdb.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "bgpd.h"
#include "session.h"
#include "log.h"

u_int32_t	get_bgpid(void);
int		host_v4(const char *, struct bgpd_addr *, u_int8_t *);
int		host_v6(const char *, struct bgpd_addr *);
void		free_networks(struct network_head *);
void		free_rdomains(struct rdomain_head *);

struct bgpd_config *
new_config(void)
{
	struct bgpd_config	*conf;

	if ((conf = calloc(1, sizeof(struct bgpd_config))) == NULL)
		fatal(NULL);

	conf->min_holdtime = MIN_HOLDTIME;
	conf->bgpid = get_bgpid();
	conf->fib_priority = RTP_BGP;
	conf->default_tableid = getrtable();

	if (asprintf(&conf->csock, "%s.%d", SOCKET_NAME,
	    conf->default_tableid) == -1)
		fatal(NULL);

	if ((conf->filters = calloc(1, sizeof(struct filter_head))) == NULL)
		fatal(NULL);
	if ((conf->listen_addrs = calloc(1, sizeof(struct listen_addrs))) ==
	    NULL)
		fatal(NULL);
	if ((conf->mrt = calloc(1, sizeof(struct mrt_head))) == NULL)
		fatal(NULL);

	/* init the various list for later */
	TAILQ_INIT(&conf->networks);
	SIMPLEQ_INIT(&conf->rdomains);

	TAILQ_INIT(conf->filters);
	TAILQ_INIT(conf->listen_addrs);
	LIST_INIT(conf->mrt);

	return (conf);
}

void
free_networks(struct network_head *networks)
{
	struct network		*n;

	while ((n = TAILQ_FIRST(networks)) != NULL) {
		TAILQ_REMOVE(networks, n, entry);
		filterset_free(&n->net.attrset);
		free(n);
	}
}

void
free_rdomains(struct rdomain_head *rdomains)
{
	struct rdomain		*rd;

	while ((rd = SIMPLEQ_FIRST(rdomains)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(rdomains, entry);
		filterset_free(&rd->export);
		filterset_free(&rd->import);
		free_networks(&rd->net_l);
		free(rd);
	}
}

void
free_config(struct bgpd_config *conf)
{
	struct listen_addr	*la;
	struct mrt		*m;

	free_rdomains(&conf->rdomains);
	free_networks(&conf->networks);
	filterlist_free(conf->filters);

	while ((la = TAILQ_FIRST(conf->listen_addrs)) != NULL) {
		TAILQ_REMOVE(conf->listen_addrs, la, entry);
		free(la);
	}
	free(conf->listen_addrs);

	while ((m = LIST_FIRST(conf->mrt)) != NULL) {
		LIST_REMOVE(m, entry);
		free(m);
	}
	free(conf->mrt);

	free(conf->csock);
	free(conf->rcsock);

	free(conf);
}

int
merge_config(struct bgpd_config *xconf, struct bgpd_config *conf,
    struct peer *peer_l)
{
	struct listen_addr	*nla, *ola, *next;
	struct network		*n;
	struct rdomain		*rd;

	/*
	 * merge the freshly parsed conf into the running xconf
	 */
	if (!conf->as) {
		log_warnx("configuration error: AS not given");
		return (1);
	}

	if ((conf->flags & BGPD_FLAG_REFLECTOR) && conf->clusterid == 0)
		conf->clusterid = conf->bgpid;


	/* adjust FIB priority if changed */
	/* if xconf is uninitialized we get RTP_NONE */
	if (xconf->fib_priority != conf->fib_priority) {
		kr_fib_decouple_all(xconf->fib_priority);
		kr_fib_update_prio_all(conf->fib_priority);
		kr_fib_couple_all(conf->fib_priority);
	}

	/* take over the easy config changes */
	xconf->flags = conf->flags;
	xconf->log = conf->log;
	xconf->bgpid = conf->bgpid;
	xconf->clusterid = conf->clusterid;
	xconf->as = conf->as;
	xconf->short_as = conf->short_as;
	xconf->holdtime = conf->holdtime;
	xconf->min_holdtime = conf->min_holdtime;
	xconf->connectretry = conf->connectretry;
	xconf->fib_priority = conf->fib_priority;

	/* clear old control sockets and use new */
	free(xconf->csock);
	free(xconf->rcsock);
	xconf->csock = conf->csock;
	xconf->rcsock = conf->rcsock;
	/* set old one to NULL so we don't double free */
	conf->csock = NULL;
	conf->rcsock = NULL;

	/* clear all current filters and take over the new ones */
	filterlist_free(xconf->filters);
	xconf->filters = conf->filters;
	conf->filters = NULL;

	/* switch the network statements, but first remove the old ones */
	free_networks(&xconf->networks);
	while ((n = TAILQ_FIRST(&conf->networks)) != NULL) {
		TAILQ_REMOVE(&conf->networks, n, entry);
		TAILQ_INSERT_TAIL(&xconf->networks, n, entry);
	}

	/* switch the rdomain configs, first remove the old ones */
	free_rdomains(&xconf->rdomains);
	while ((rd = SIMPLEQ_FIRST(&conf->rdomains)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&conf->rdomains, entry);
		SIMPLEQ_INSERT_TAIL(&xconf->rdomains, rd, entry);
	}

	/*
	 * merge new listeners:
	 * -flag all existing ones as to be deleted
	 * -those that are in both new and old: flag to keep
	 * -new ones get inserted and flagged as to reinit
	 * -remove all that are still flagged for deletion
	 */

	TAILQ_FOREACH(nla, xconf->listen_addrs, entry)
		nla->reconf = RECONF_DELETE;

	/* no new listeners? preserve default ones */
	if (TAILQ_EMPTY(conf->listen_addrs))
		TAILQ_FOREACH(ola, xconf->listen_addrs, entry)
			if (ola->flags & DEFAULT_LISTENER)
				ola->reconf = RECONF_KEEP;
	/* else loop over listeners and merge configs */
	for (nla = TAILQ_FIRST(conf->listen_addrs); nla != NULL; nla = next) {
		next = TAILQ_NEXT(nla, entry);

		TAILQ_FOREACH(ola, xconf->listen_addrs, entry)
			if (!memcmp(&nla->sa, &ola->sa, sizeof(nla->sa)))
				break;

		if (ola == NULL) {
			/* new listener, copy over */
			TAILQ_REMOVE(conf->listen_addrs, nla, entry);
			TAILQ_INSERT_TAIL(xconf->listen_addrs, nla, entry);
			nla->reconf = RECONF_REINIT;
		} else		/* exists, just flag */
			ola->reconf = RECONF_KEEP;
	}
	/* finally clean up the original list and remove all stale entires */
	for (nla = TAILQ_FIRST(xconf->listen_addrs); nla != NULL; nla = next) {
		next = TAILQ_NEXT(nla, entry);
		if (nla->reconf == RECONF_DELETE) {
			TAILQ_REMOVE(xconf->listen_addrs, nla, entry);
			free(nla);
		}
	}

	/* conf is merged so free it */
	free_config(conf);

	return (0);
}

u_int32_t
get_bgpid(void)
{
	struct ifaddrs		*ifap, *ifa;
	u_int32_t		 ip = 0, cur, localnet;

	localnet = htonl(INADDR_LOOPBACK & IN_CLASSA_NET);

	if (getifaddrs(&ifap) == -1)
		fatal("getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;
		cur = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
		if ((cur & localnet) == localnet)	/* skip 127/8 */
			continue;
		if (ntohl(cur) > ntohl(ip))
			ip = cur;
	}
	freeifaddrs(ifap);

	return (ip);
}

int
host(const char *s, struct bgpd_addr *h, u_int8_t *len)
{
	int			 done = 0;
	int			 mask;
	char			*p, *ps;
	const char		*errstr;

	if ((p = strrchr(s, '/')) != NULL) {
		mask = strtonum(p + 1, 0, 128, &errstr);
		if (errstr) {
			log_warnx("prefixlen is %s: %s", errstr, p + 1);
			return (0);
		}
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			fatal("host: malloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
	} else {
		if ((ps = strdup(s)) == NULL)
			fatal("host: strdup");
		mask = 128;
	}

	bzero(h, sizeof(struct bgpd_addr));

	/* IPv4 address? */
	if (!done)
		done = host_v4(s, h, len);

	/* IPv6 address? */
	if (!done) {
		done = host_v6(ps, h);
		*len = mask;
	}

	free(ps);

	return (done);
}

int
host_v4(const char *s, struct bgpd_addr *h, u_int8_t *len)
{
	struct in_addr		 ina;
	int			 bits = 32;

	bzero(&ina, sizeof(struct in_addr));
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (0);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (0);
	}

	h->aid = AID_INET;
	h->v4.s_addr = ina.s_addr;
	*len = bits;

	return (1);
}

int
host_v6(const char *s, struct bgpd_addr *h)
{
	struct addrinfo		 hints, *res;

	bzero(&hints, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, "0", &hints, &res) == 0) {
		sa2addr(res->ai_addr, h);
		freeaddrinfo(res);
		return (1);
	}

	return (0);
}

void
prepare_listeners(struct bgpd_config *conf)
{
	struct listen_addr	*la, *next;
	int			 opt = 1;

	if (TAILQ_EMPTY(conf->listen_addrs)) {
		if ((la = calloc(1, sizeof(struct listen_addr))) == NULL)
			fatal("setup_listeners calloc");
		la->fd = -1;
		la->flags = DEFAULT_LISTENER;
		la->reconf = RECONF_REINIT;
		la->sa.ss_len = sizeof(struct sockaddr_in);
		((struct sockaddr_in *)&la->sa)->sin_family = AF_INET;
		((struct sockaddr_in *)&la->sa)->sin_addr.s_addr =
		    htonl(INADDR_ANY);
		((struct sockaddr_in *)&la->sa)->sin_port = htons(BGP_PORT);
		TAILQ_INSERT_TAIL(conf->listen_addrs, la, entry);

		if ((la = calloc(1, sizeof(struct listen_addr))) == NULL)
			fatal("setup_listeners calloc");
		la->fd = -1;
		la->flags = DEFAULT_LISTENER;
		la->reconf = RECONF_REINIT;
		la->sa.ss_len = sizeof(struct sockaddr_in6);
		((struct sockaddr_in6 *)&la->sa)->sin6_family = AF_INET6;
		((struct sockaddr_in6 *)&la->sa)->sin6_port = htons(BGP_PORT);
		TAILQ_INSERT_TAIL(conf->listen_addrs, la, entry);
	}

	for (la = TAILQ_FIRST(conf->listen_addrs); la != NULL; la = next) {
		next = TAILQ_NEXT(la, entry);
		if (la->reconf != RECONF_REINIT)
			continue;

		if ((la->fd = socket(la->sa.ss_family,
		    SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
		    IPPROTO_TCP)) == -1) {
			if (la->flags & DEFAULT_LISTENER && (errno ==
			    EAFNOSUPPORT || errno == EPROTONOSUPPORT)) {
				TAILQ_REMOVE(conf->listen_addrs, la, entry);
				free(la);
				continue;
			} else
				fatal("socket");
		}

		opt = 1;
		if (setsockopt(la->fd, SOL_SOCKET, SO_REUSEADDR,
		    &opt, sizeof(opt)) == -1)
			fatal("setsockopt SO_REUSEADDR");

		if (bind(la->fd, (struct sockaddr *)&la->sa, la->sa.ss_len) ==
		    -1) {
			switch (la->sa.ss_family) {
			case AF_INET:
				log_warn("cannot bind to %s:%u",
				    log_sockaddr((struct sockaddr *)&la->sa),
				    ntohs(((struct sockaddr_in *)
				    &la->sa)->sin_port));
				break;
			case AF_INET6:
				log_warn("cannot bind to [%s]:%u",
				    log_sockaddr((struct sockaddr *)&la->sa),
				    ntohs(((struct sockaddr_in6 *)
				    &la->sa)->sin6_port));
				break;
			default:
				log_warn("cannot bind to %s",
				    log_sockaddr((struct sockaddr *)&la->sa));
				break;
			}
			close(la->fd);
			TAILQ_REMOVE(conf->listen_addrs, la, entry);
			free(la);
			continue;
		}
	}
}

int
get_mpe_label(struct rdomain *r)
{
	struct  ifreq	ifr;
	struct shim_hdr	shim;
	int		s;

	s = socket(AF_INET, SOCK_DGRAM, 0);
	if (s == -1)
		return (-1);

	bzero(&shim, sizeof(shim));
	bzero(&ifr, sizeof(ifr));
	strlcpy(ifr.ifr_name, r->ifmpe, sizeof(ifr.ifr_name));
	ifr.ifr_data = (caddr_t)&shim;

	if (ioctl(s, SIOCGETLABEL, (caddr_t)&ifr) == -1) {
		close(s);
		return (-1);
	}
	close(s);
	r->label = shim.shim_label;
	return (0);
}
@


1.66
log
@so far, bgpd was hardcoded to use rtable 0 for nexthop verification.
instead, use the rtable bgpd was started in (route -T <n> exec / rc.d
daemon_rtable) for nexthop verification and as default Adj-RIB-In and
Loc-RIB. This allows multiple bgpds in different rdomains on the same
machine - bgp router virtualization if you like buzzwords.
initial version written under contract more than a year ago, it took us
a while to wrap our brains around the bgpd <-> rdomain interactions -
1) RIBs, 2) nexthop verification and 3) tcp sockets.
ok & input phessler claudio benno
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.64 2017/01/17 22:10:55 krw Exp $ */
d31 1
d48 1
a48 1
	struct bgpd_config *conf;
d58 2
a59 1
	if ((conf->csock = strdup(SOCKET_NAME)) == NULL)
@


1.65
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d55 1
@


1.64
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.63 2016/01/26 18:35:01 mmcc Exp $ */
d36 1
@


1.63
log
@typos
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.62 2015/12/01 11:58:31 claudio Exp $ */
d182 1
a182 1
	xconf->filters = conf->filters;	
@


1.62
log
@It is not a network hackathon without a bgpd commit. So here we go.
Fix rdomain setups that got broken some time ago when I refactored
the config loading to exec the rde and se on startup. Works for me
and I think I'm the only user.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.61 2015/07/16 18:26:04 claudio Exp $ */
d152 1
a152 1
	/* if xconf is uninitalized we get RTP_NONE */
@


1.61
log
@Next round of config cleanup. Move various lists into the bgpd_config struct.
This is the next step to better split parsing and merging the config.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.60 2015/03/14 02:43:02 claudio Exp $ */
d40 2
d78 13
a90 1
free_config(struct bgpd_config *conf)
a92 3
	struct network		*n;
	struct listen_addr	*la;
	struct mrt		*m;
d94 2
a95 2
	while ((rd = SIMPLEQ_FIRST(&conf->rdomains)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&conf->rdomains, entry);
d98 1
a98 6

		while ((n = TAILQ_FIRST(&rd->net_l)) != NULL) {
			TAILQ_REMOVE(&rd->net_l, n, entry);
			filterset_free(&n->net.attrset);
			free(n);
		}
d101 1
d103 5
a107 5
	while ((n = TAILQ_FIRST(&conf->networks)) != NULL) {
		TAILQ_REMOVE(&conf->networks, n, entry);
		filterset_free(&n->net.attrset);
		free(n);
	}
d109 2
d137 1
a141 1

a146 1

a150 1

d186 1
a186 5
	while ((n = TAILQ_FIRST(&xconf->networks)) != NULL) {
		TAILQ_REMOVE(&xconf->networks, n, entry);
		filterset_free(&n->net.attrset);
		free(n);
	}
d190 7
@


1.60
log
@Move the command line options (mainly -d and -v) out of struct bgpd_config
into a own flag field since these can't be modified via a config reload.
OK henning@@ benno@@ before lock
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.59 2015/03/14 02:32:35 claudio Exp $ */
d41 81
d124 1
a124 1
    struct peer *peer_l, struct listen_addrs *listen_addrs)
d127 1
a137 5
	if (!conf->min_holdtime)
		conf->min_holdtime = MIN_HOLDTIME;

	if (!conf->bgpid)
		conf->bgpid = get_bgpid();
a141 2
	if (!conf->fib_priority)
		conf->fib_priority = RTP_BGP;
a142 4
	free(xconf->csock);
	free(xconf->rcsock);

	conf->listen_addrs = xconf->listen_addrs;
d146 1
a146 2
	if (xconf->fib_priority != RTP_NONE && xconf->fib_priority !=
	    conf->fib_priority) {
d152 11
a162 1
	memcpy(xconf, conf, sizeof(struct bgpd_config));
d164 24
a187 5
	if (conf->listen_addrs == NULL) {
		/* there is no old conf, just copy new one over */
		xconf->listen_addrs = listen_addrs;
		TAILQ_FOREACH(nla, xconf->listen_addrs, entry)
			nla->reconf = RECONF_REINIT;
d189 7
a195 35
	} else {
		/*
		 * merge new listeners:
		 * -flag all existing ones as to be deleted
		 * -those that are in both new and old: flag to keep
		 * -new ones get inserted and flagged as to reinit
		 * -remove all that are still flagged for deletion
		 */

		TAILQ_FOREACH(nla, xconf->listen_addrs, entry)
			nla->reconf = RECONF_DELETE;

		/* no new listeners? preserve default ones */
		if (TAILQ_EMPTY(listen_addrs))
			TAILQ_FOREACH(ola, xconf->listen_addrs, entry)
				if (ola->flags & DEFAULT_LISTENER)
					ola->reconf = RECONF_KEEP;

		for (nla = TAILQ_FIRST(listen_addrs); nla != NULL; nla = next) {
			next = TAILQ_NEXT(nla, entry);

			TAILQ_FOREACH(ola, xconf->listen_addrs, entry)
				if (!memcmp(&nla->sa, &ola->sa,
				    sizeof(nla->sa)))
					break;

			if (ola == NULL) {
				/* new listener, copy over */
				TAILQ_REMOVE(listen_addrs, nla, entry);
				TAILQ_INSERT_TAIL(xconf->listen_addrs,
				    nla, entry);
				nla->reconf = RECONF_REINIT;
			} else		/* exists, just flag */
				ola->reconf = RECONF_KEEP;
		}
d197 2
a198 8
		for (nla = TAILQ_FIRST(xconf->listen_addrs); nla != NULL;
		    nla = next) {
			next = TAILQ_NEXT(nla, entry);
			if (nla->reconf == RECONF_DELETE) {
				TAILQ_REMOVE(xconf->listen_addrs, nla, entry);
				free(nla);
			}
		}
d200 27
a226 3
		while ((ola = TAILQ_FIRST(listen_addrs)) != NULL) {
			TAILQ_REMOVE(listen_addrs, ola, entry);
			free(ola);
a227 1
		free(listen_addrs);
d229 3
@


1.59
log
@Move the code that adjust FIB priority when changed during a config reload
from the parsing function to the merge_config function where it belongs.
OK henning@@ benno@@ before lock
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.58 2015/02/09 11:37:31 claudio Exp $ */
d45 1
a45 1
	struct listen_addr			*nla, *ola, *next;
a49 3

	/* preserve cmd line opts */
	conf->opts = xconf->opts;
@


1.58
log
@Kill session_socket_blockmode() and replace it with SOCK_CLOEXEC or
SOCK_NONBLOCK and accept4(). OK henning@@ tested & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.57 2013/11/13 09:14:48 florian Exp $ */
d75 10
@


1.57
log
@Knob to set priority with which bgpd inserts routes into the kernel
routing table. Need for it in "special" setups pointed out by
Loic Blot (loic.blot _AT_ unix-experience _DOT_ fr) on tech.
OK benno, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.56 2010/10/24 17:20:08 deraadt Exp $ */
d278 2
a279 1
		if ((la->fd = socket(la->sa.ss_family, SOCK_STREAM,
@


1.56
log
@spacing and irrelevant glitches which disrupt lint
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.55 2010/09/02 14:03:21 sobrado Exp $ */
d67 3
@


1.55
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.54 2010/06/27 19:53:34 claudio Exp $ */
d335 1
a335 1
	if (ioctl(s, SIOCGETLABEL , (caddr_t)&ifr) == -1) {
@


1.54
log
@Instead of specifying the control sockets on the command line have them
in bgpd.conf. This allows to add/modify restricted control sockets on runtime.
Feature request by a few people how often forgot to add -r path when restarting
bgpd (including myself).
NOTE: this removes the -s and -r arguments from bgpd so pay attention when
updateing.
jajaja sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.53 2010/05/17 15:49:29 claudio Exp $ */
d81 1
a81 1
		/* 
@


1.53
log
@Last bits of MPLS VPN support. Hook kernel routing tables and RIB together.
This adds a bit of new config to specify the mapping between an rdomain and
the BGP MPLS VPN instance, example:
rdomain 1 {
        descr "CUSTOMER1"
	rd 65003:1
	import-target rt 65003:3
	export-target rt 65003:1
	depend on mpe0
	network 192.168.224/24
}
The "depend on mpe0" is a but ugly but for now this is the quickest way to
figure out which interface bgp should use to insert the MPLS routes.

A big side-effect of this diff is that networks are now internally
distributed through kroute.c.
This needs some kernel changes that will follow hopefully soon.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.52 2009/12/01 14:28:05 claudio Exp $ */
a52 2
	conf->csock = xconf->csock;
	conf->rcsock = xconf->rcsock;
d67 3
@


1.52
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.51 2009/01/26 23:10:02 claudio Exp $ */
d23 3
d316 25
@


1.51
log
@Getting the higest IP only works if the compare is done in host byte order.
Same bug as in ospfd and ospf6d. *gulp*
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.50 2007/10/13 16:35:20 deraadt Exp $ */
d211 1
a211 1
	h->af = AF_INET;
d228 1
a228 7
		h->af = AF_INET6;
		memcpy(&h->v6,
		    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
		    sizeof(h->v6));
		h->scope_id =
		    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;

@


1.50
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.49 2007/01/31 13:04:21 claudio Exp $ */
d148 1
a148 1
		if (cur > ip)
@


1.49
log
@Replace another strtol() with strtonum() making the error checking easier
to understand. This is modeled after bgpctl's parse_prefix function.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.48 2006/03/15 11:33:42 claudio Exp $ */
a153 23
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}

	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}

	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
		return (-1);
	}

	return (0);
@


1.48
log
@Allow the control socket to be changed on the command line. Useful if you
need to run multiple bgpds on a single box to simulate a IX. This helped
me massivly debugging error reports. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.47 2006/01/24 10:03:44 henning Exp $ */
d184 2
a185 1
	char			*p, *q, *ps;
d188 3
a190 4
		errno = 0;
		mask = strtol(p+1, &q, 0);
		if (errno == ERANGE || !q || *q || mask > 128 || q == (p+1)) {
			log_warnx("invalid netmask");
@


1.47
log
@introduce a second control socket, which is restricted to certain messages,
nameley the show ones. needed for looking glass style applications,
monitoring etc. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.46 2005/07/14 09:24:38 dlg Exp $ */
d50 1
@


1.46
log
@free commitz from pascoes kitchen. fix an error message

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.45 2005/03/30 11:23:15 henning Exp $ */
d50 1
@


1.45
log
@bgpd used to open listeners in advance in the parent and the SE picked
those it needed, closing all the others. this has some nasty races.
so let the parent keep the list of listeners so it knows when it has
to open a new one
claudio ok, also tested by jason ackley
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.44 2005/03/28 14:19:56 henning Exp $ */
d312 1
a312 1
			fatal("setsockopt SO_REUSEPORT");
@


1.44
log
@better diagnostics on bind() failure
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.43 2005/03/26 23:04:34 claudio Exp $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
d42 5
a46 1
	struct listen_addr			*la;
d65 43
a107 4
	if (xconf->listen_addrs != NULL) {
		while ((la = TAILQ_FIRST(xconf->listen_addrs)) != NULL) {
			TAILQ_REMOVE(xconf->listen_addrs, la, entry);
			free(la);
a108 2
		free(xconf->listen_addrs);
	}
d110 8
a117 1
	memcpy(xconf, conf, sizeof(struct bgpd_config));
d119 6
a124 1
	xconf->listen_addrs = listen_addrs;
d274 1
d286 1
d295 3
d310 1
a310 1
		if (setsockopt(la->fd, SOL_SOCKET, SO_REUSEPORT,
@


1.43
log
@inet_addr("127.0.0.1") -> htonl(INADDR_LOOPBACK)
Use IN_CLASSA_NET instead of hard coded 0xff000000
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.42 2005/03/23 22:26:34 claudio Exp $ */
d258 18
a275 2
			log_warn("cannot bind to %s",
			    log_sockaddr((struct sockaddr *)&la->sa));
@


1.42
log
@Move the neighbor checking code from merge_config() to neighbor_consistent()
where it belongs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.41 2005/03/15 14:40:08 henning Exp $ */
d82 1
a82 1
	localnet = inet_addr("127.0.0.0");
@


1.41
log
@remove listener if bind() fails. no point in having a defunct listener
in the list; causes issues with upcoming changes, spotted by
Jason Ackley <jason@@ackley.net>, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.40 2004/10/01 15:11:12 henning Exp $ */
a41 1
	struct peer				*p;
a42 1
	int					 errs = 0;
a60 16
	for (p = peer_l; p != NULL; p = p->next) {
		p->conf.ebgp = (p->conf.remote_as != conf->as);
		if (p->conf.announce_type == ANNOUNCE_UNDEF)
			p->conf.announce_type = p->conf.ebgp == 0 ?
			    ANNOUNCE_ALL : ANNOUNCE_SELF;
		if (p->conf.enforce_as == ENFORCE_AS_UNDEF)
			p->conf.enforce_as = p->conf.ebgp == 0 ?
			    ENFORCE_AS_OFF : ENFORCE_AS_ON;
		if (p->conf.reflector_client && p->conf.ebgp) {
			log_peer_warnx(&p->conf, "configuration error: "
			    "EBGP neighbors are not allowed in route "
			    "reflector clusters");
			return (1);
		}
	}

d73 1
a73 1
	return (errs);
@


1.40
log
@if we're opening a socket for a default listener because no "listen on"
stetements were found in the config file, and one fails with
EPROTONOSUPPORT (this is the case for the default ::1 listener on
machines without INET6), remove that listener and move on instead
of bailing out. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.39 2004/06/20 17:49:46 henning Exp $ */
d279 3
a281 1
			la->fd = -1;
@


1.39
log
@implement file descriptor passing in the imsg/msgbuf framework, and use
it to let the main process to prepare new listening sockets (socket() and
bind()) on behalf of the session engine, which of course cannot bind() to
ports < 1024 any more once it dropped privileges. with some help from theo,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.38 2004/06/06 17:38:10 henning Exp $ */
d231 1
a231 1
	struct listen_addr	*la;
d256 2
a257 1
	TAILQ_FOREACH(la, conf->listen_addrs, entry) {
d259 9
a267 2
		    IPPROTO_TCP)) == -1)
			fatal("socket");
@


1.38
log
@rework bgpd's handling of listening sockets. instead of one for each
supported address familiy, keep a tailq of an arbitary number of them.
the new struct listen_addr contains the sockaddr and the fd.
this fixes quite some nasty behaviour which was a consequence of the previous
model.
looks right deraadt@@, and discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.37 2004/05/21 15:36:40 claudio Exp $ */
d226 48
@


1.37
log
@RFC 2796 bgp route reflector support. This is very useful in conjunction
with templates. looks good, go for it henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.36 2004/05/04 21:22:39 deraadt Exp $ */
d40 1
a40 1
    struct peer *peer_l)
d42 3
a44 2
	struct peer	*p;
	int		 errs = 0;
d79 8
d88 2
@


1.36
log
@remove unused var; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.35 2004/04/27 04:37:53 deraadt Exp $ */
d59 3
d70 6
@


1.35
log
@do the errno ERANGE dance around a strtol; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.34 2004/03/31 10:26:34 henning Exp $ */
a32 2

void			*sconf;
@


1.34
log
@it is no longer required to have local-address set with tcp md5sig,
so remove the check.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.33 2004/03/17 17:49:53 henning Exp $ */
d132 1
d134 1
a134 1
		if (!q || *q || mask > 128 || q == (p+1)) {
@


1.33
log
@consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.32 2004/03/16 18:35:30 henning Exp $ */
a68 5
		if (p->conf.tcp_md5_key[0] && p->conf.local_addr.af == 0) {
			log_peer_warnx(&p->conf, "\"tcp md5sig\" requires "
			    "\"local-address\" to be set");
			errs++;
		}
@


1.32
log
@tcp md5sig requires that local-address is specified as well for now, so
enforce it.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.31 2004/03/03 10:13:48 henning Exp $ */
d174 1
a174 1
	memset(&ina, 0, sizeof(struct in_addr));
d195 1
a195 1
	memset(&hints, 0, sizeof(hints));
@


1.31
log
@missing freeaddrinfo()
From: Patrick Latifi <pat@@eyeo.org>
Patrick is doing an _excellent_ job in finding all these little omissions,
thank you very very much!
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.30 2004/03/02 19:45:04 henning Exp $ */
d44 2
a45 1
	struct peer		*p;
d69 5
d78 1
a78 1
	return (0);
@


1.30
log
@flesh out the address and prefix parsing, include v6 code, but reject v6
upwards, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.29 2004/02/26 14:00:33 claudio Exp $ */
d201 1
@


1.29
log
@Implement "enforce neighbor-as yes|no" which is by default on for ebgp
neighbors. While doing that check also that the nexthop is valid (not class D
or E and not in 127/8 range). Kill some TODO and XXX and rename the british
neighbour to neighbor as used everywhere else. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.28 2004/02/10 23:10:23 henning Exp $ */
d26 1
d37 2
d118 84
@


1.28
log
@enforce config file secrecy (correct owner, no rights for group/world)
help and ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.27 2004/02/03 22:28:05 henning Exp $ */
d62 3
@


1.27
log
@replace the previous hack for the internal peer id allocator (which just used
the peer's ip address as u_int32_t) by a real id allocator that tries to
keep locality high. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.26 2004/02/01 19:46:05 claudio Exp $ */
d21 1
d92 23
@


1.26
log
@Set sane default announce types according to the peer type. For IBGP use
announce all and for EBGP use announce self. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.25 2004/01/30 23:24:04 henning Exp $ */
a34 1
u_int32_t	get_id(struct peer *);
a60 2
		if (!p->conf.id)
			p->conf.id = get_id(p);
a90 9
}

u_int32_t
get_id(struct peer *p)
{
	/*
	 * XXX this collides with multiviews and will need more clue later XXX
	 */
	return (ntohl(p->conf.remote_addr.v4.s_addr));
@


1.25
log
@in the parse_config() -> merge_config() chain, you shall not null
conf->opts that holds some of the command line opts.
repairs -n.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.24 2004/01/28 17:24:38 henning Exp $ */
d59 3
@


1.24
log
@don't pfkey_setkey() from here, claudio markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.23 2004/01/28 11:03:32 markus Exp $ */
d42 3
@


1.23
log
@pfkey_setkey: sockaddr -> bgpd_addr; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.22 2004/01/27 16:49:53 henning Exp $ */
a57 5
		if (p->conf.tcp_sign_key[0] &&
		    pfkey_setkey(&p->conf.local_addr,
		    &p->conf.remote_addr,
		    p->conf.tcp_sign_key) == -1)
			return (1);
@


1.22
log
@use a struct bgpd_addr instead of sockaddr_in for peer_config->local_addr and
->remote_addr for easier multiprotocol support

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.21 2004/01/27 14:09:36 markus Exp $ */
d59 4
a62 4
		    pfkey_setkey((struct sockaddr *)&p->conf.local_addr,
			    (struct sockaddr *)&p->conf.remote_addr,
			    p->conf.tcp_sign_key) == -1)
				return (1);
@


1.21
log
@use SADB_GETSPI/UPDATE for setting tcpmd5 keys; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.21 2004/01/27 14:00:08 markus Exp $ */
d101 1
a101 1
	return (ntohl(p->conf.remote_addr.sin_addr.s_addr));
@


1.20
log
@first cut at tcpmd5 setup seupport from within bgpd. works so far.
with help from hshoexer@@ and markus@@
ok claudio@@ hshoexer@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.19 2004/01/24 17:38:30 henning Exp $ */
d59 1
a59 1
		    pfkey_signature((struct sockaddr *)&p->conf.local_addr,
@


1.19
log
@we can use memcpy for the whole thing in merge_config now instead of
copying each and every thing on its own
yes, there was a reason to do it this way once, but it vanished

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.18 2004/01/22 20:34:55 henning Exp $ */
d58 5
@


1.18
log
@use log_warnx and log_info. reclassify a few messages in the process and fix
a few messages.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.17 2004/01/07 01:15:54 henning Exp $ */
a42 1
	/* merge conf (new) into xconf (old)  */
a46 2
	if (xconf->as != conf->as)
		xconf->as = conf->as;
d48 2
a49 2
	if (conf->bgpid && xconf->bgpid != conf->bgpid)
		xconf->bgpid = conf->bgpid;
d51 2
a52 22
	if (!xconf->bgpid)
		xconf->bgpid = get_bgpid();

	if (conf->holdtime && !xconf->holdtime)
		xconf->holdtime = conf->holdtime;
	if (!conf->holdtime && xconf->holdtime)
		conf->holdtime = xconf->holdtime;

	if (conf->min_holdtime && !xconf->min_holdtime)
		xconf->min_holdtime = conf->min_holdtime;
	if (!conf->min_holdtime && xconf->min_holdtime)
		conf->min_holdtime = xconf->min_holdtime;
	if (!xconf->min_holdtime)
		xconf->min_holdtime = conf->min_holdtime = MIN_HOLDTIME;

	memcpy(&xconf->listen_addr, &conf->listen_addr,
	    sizeof(xconf->listen_addr));

	xconf->flags = conf->flags;
	xconf->log = conf->log;
	xconf->holdtime = conf->holdtime;
	xconf->min_holdtime = conf->min_holdtime;
d55 1
a55 1
		p->conf.ebgp = (p->conf.remote_as != xconf->as);
d59 2
@


1.17
log
@don't try to be smart after config reloads and try to detect wether
a session needs a reinit for the new conf to kick in. the logic is
condemned to fail, and implicitly taking sessions down is BAD.

after discussion with mickey@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.16 2004/01/06 03:43:50 henning Exp $ */
d45 1
a45 1
		logit(LOG_CRIT, "configuration error: AS not given");
@


1.16
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.15 2004/01/03 20:37:34 henning Exp $ */
a40 1
	enum reconf_action	 reconf = RECONF_NONE;
d48 1
a48 1
	if (xconf->as != conf->as) {
d50 2
a51 3
		reconf = RECONF_REINIT;
	}
	if (conf->bgpid && xconf->bgpid != conf->bgpid) {
d53 1
a53 2
		reconf = RECONF_REINIT;
	}
a71 8
	if ((xconf->flags & BGPD_FLAG_NO_FIB_UPDATE) !=
	    (conf->flags & BGPD_FLAG_NO_FIB_UPDATE)) {
		if (!(conf->flags & BGPD_FLAG_NO_FIB_UPDATE))
			kroute_fib_couple();
		else
			kroute_fib_decouple();
	}

a73 7

	/*
	 * as we cannot get the negotiated holdtime in the main process,
	 * the session engine needs to check it against the possibly new values
	 * and decide on session reestablishment.
	 */

a77 1
		p->conf.reconf_action = reconf;
@


1.15
log
@move some session specific stuff to session.h and make the few files
that need it include that
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.14 2004/01/03 20:22:07 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.14
log
@decouple the peer list from bgpd_config.
so many parts of bgpd are not at all interested in the session specific peer
structs... allows for some further cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.13 2004/01/02 22:47:33 itojun Exp $ */
d30 1
d39 1
a39 1
    struct peer *peers)
d95 1
a95 1
	for (p = peers; p != NULL; p = p->next) {
@


1.13
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.12 2003/12/30 13:03:27 henning Exp $ */
d37 2
a38 1
merge_config(struct bgpd_config *xconf, struct bgpd_config *conf)
d41 1
a41 1
	struct peer		*p, *next;
d94 1
a94 1
	for (p = conf->peers; p != NULL; p = p->next) {
a99 8

	for (p = xconf->peers; p != NULL; p = next) {
		next = p->next;
		free(p);
	}

	/* merge peers done by session engine except for initial config */
	xconf->peers = conf->peers;
@


1.12
log
@typos from david
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.11 2003/12/27 18:43:36 henning Exp $ */
d124 1
a124 1
				continue;
@


1.11
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.10 2003/12/27 14:58:22 henning Exp $ */
d105 1
a105 1
	/* merge peers done by session egine except for initial config */
@


1.10
log
@move the fib couple/decouple to the config merge where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.9 2003/12/26 20:52:14 jakob Exp $ */
d80 1
a80 1
	
@


1.9
log
@add option 'log updates' to log updates. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.8 2003/12/26 18:07:32 henning Exp $ */
d73 8
@


1.8
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.7 2003/12/25 17:35:53 henning Exp $ */
d74 1
@


1.7
log
@free where it was allocated; much easier to verify
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.6 2003/12/25 17:27:36 henning Exp $ */
d111 1
a111 1
		fatal("getifaddrs", errno);
@


1.6
log
@don't leak memory THAT obvious on reconfigure
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.5 2003/12/24 23:48:06 henning Exp $ */
a97 1
	free(conf);
@


1.5
log
@syscalls return -1 on err so test for == -1 instead of the < 0 found in very
few places, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.4 2003/12/24 13:49:21 henning Exp $ */
d40 1
a40 1
	struct peer		*p;
d89 5
@


1.4
log
@add option to not touch the kernel routing table
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.3 2003/12/23 01:06:21 henning Exp $ */
d106 1
a106 1
	if (getifaddrs(&ifap) < 0)
@


1.3
log
@allow the listening address to be specified, default to INADDR_ANY
should make jose@@ happy
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.2 2003/12/19 14:23:28 henning Exp $ */
d72 2
@


1.2
log
@for our internal peer ID just use the peer's IP address for now.
this collides with multiviews (which we don't have yet) and will have to
be changed then, but allows us to progress much faster now.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d26 1
d69 3
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a30 1
static u_int32_t	 max_id = 1;	/* reserve 0 */
d120 4
a123 1
	return (max_id++);
@

