head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.32
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.26
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.28
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.20
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.24
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.22
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.18
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.16
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.14
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.12
	OPENBSD_5_0:1.9.0.10
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.8
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.6
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4;
locks; strict;
comment	@ * @;


1.9
date	2009.06.04.04.46.42;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.17.12.25.15;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.02.14.41.26;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.26.20.19.41;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.02.15.34.43;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.01.09.19.24;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2005.06.29.09.43.25;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2005.06.25.16.26.25;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.13.21.16.18;	author henning;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Add "rde rib <name>" to the config and allow the rde to use these other RIBs.
Still a bit hackish, reload is missing and printconf as well. Looks good h@@
@
text
@/*	$OpenBSD: name2id.c,v 1.8 2009/05/17 12:25:15 claudio Exp $ */

/*
 * Copyright (c) 2004, 2005 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <net/route.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include "bgpd.h"

#define	IDVAL_MAX	50000

struct n2id_label {
	TAILQ_ENTRY(n2id_label)	 entry;
	char			*name;
	u_int16_t		 id;
	int			 ref;
};

TAILQ_HEAD(n2id_labels, n2id_label);

u_int16_t	 _name2id(struct n2id_labels *, const char *);
const char	*_id2name(struct n2id_labels *, u_int16_t);
void		 _unref(struct n2id_labels *, u_int16_t);
void		 _ref(struct n2id_labels *, u_int16_t);

struct n2id_labels	rt_labels = TAILQ_HEAD_INITIALIZER(rt_labels);
struct n2id_labels	pftable_labels = TAILQ_HEAD_INITIALIZER(pftable_labels);

u_int16_t
rtlabel_name2id(const char *name)
{
	return (_name2id(&rt_labels, name));
}

const char *
rtlabel_id2name(u_int16_t id)
{
	return (_id2name(&rt_labels, id));
}

void
rtlabel_unref(u_int16_t id)
{
	_unref(&rt_labels, id);
}

void
rtlabel_ref(u_int16_t id)
{
	_ref(&rt_labels, id);
}

u_int16_t
pftable_name2id(const char *name)
{
	return (_name2id(&pftable_labels, name));
}

const char *
pftable_id2name(u_int16_t id)
{
	return (_id2name(&pftable_labels, id));
}

void
pftable_unref(u_int16_t id)
{
	_unref(&pftable_labels, id);
}

void
pftable_ref(u_int16_t id)
{
	_ref(&pftable_labels, id);
}

u_int16_t
_name2id(struct n2id_labels *head, const char *name)
{
	struct n2id_label	*label, *p = NULL;
	u_int16_t		 new_id = 1;

	if (!name[0]) {
		errno = EINVAL;
		return (0);
	}

	TAILQ_FOREACH(label, head, entry)
		if (strcmp(name, label->name) == 0) {
			label->ref++;
			return (label->id);
		}

	/*
	 * to avoid fragmentation, we do a linear search from the beginning
	 * and take the first free slot we find. if there is none or the list
	 * is empty, append a new entry at the end.
	 */

	if (!TAILQ_EMPTY(head))
		for (p = TAILQ_FIRST(head); p != NULL &&
		    p->id == new_id; p = TAILQ_NEXT(p, entry))
			new_id = p->id + 1;

	if (new_id > IDVAL_MAX) {
		errno = ERANGE;
		return (0);
	}

	if ((label = calloc(1, sizeof(struct n2id_label))) == NULL)
		return (0);
	if ((label->name = strdup(name)) == NULL) {
		free(label);
		return (0);
	}
	label->id = new_id;
	label->ref++;

	if (p != NULL)	/* insert new entry before p */
		TAILQ_INSERT_BEFORE(p, label, entry);
	else		/* either list empty or no free slot in between */
		TAILQ_INSERT_TAIL(head, label, entry);

	return (label->id);
}

const char *
_id2name(struct n2id_labels *head, u_int16_t id)
{
	struct n2id_label	*label;

	if (id == 0)
		return ("");

	TAILQ_FOREACH(label, head, entry)
		if (label->id == id)
			return (label->name);

	return ("");
}

void
_unref(struct n2id_labels *head, u_int16_t id)
{
	struct n2id_label	*p, *next;

	if (id == 0)
		return;

	for (p = TAILQ_FIRST(head); p != NULL; p = next) {
		next = TAILQ_NEXT(p, entry);
		if (id == p->id) {
			if (--p->ref == 0) {
				TAILQ_REMOVE(head, p, entry);
				free(p->name);
				free(p);
			}
			break;
		}
	}
}

void
_ref(struct n2id_labels *head, u_int16_t id)
{
	struct n2id_label	*label;

	if (id == 0)
		return;

	TAILQ_FOREACH(label, head, entry)
		if (label->id == id) {
			++label->ref;
			break;
		}
}
@


1.8
log
@Rework most of the RDE to allow multiple RIBs. This is mostly preparation
work by changing the way the RDE DB is built. struct prefix and struct
pt_entry are simplified and extended with a rib_entry where the decision
tree is run on. From now on a prefix can only reside on one particular RIB
which simplifies the code a bit. Currently there are two fixed ribs
(adj-rib-in and the local-rib) which needs to be made more dynamic in
upcomming commits.
This is work in progress, the RDE seems to work for me and sthen@@ (no flames
comming out of our testrouters but there is still a lot missing)
Move into the tree to simplify developement -- henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: name2id.c,v 1.7 2006/05/02 14:41:26 claudio Exp $ */
a45 1
struct n2id_labels	rib_labels = TAILQ_HEAD_INITIALIZER(rib_labels);
a47 24

u_int16_t
rib_name2id(const char *name)
{
	return (_name2id(&rib_labels, name));
}

const char *
rib_id2name(u_int16_t id)
{
	return (_id2name(&rib_labels, id));
}

void
rib_unref(u_int16_t id)
{
	_unref(&rib_labels, id);
}

void
rib_ref(u_int16_t id)
{
	_ref(&rib_labels, id);
}
@


1.7
log
@The pftable name to ID functions should use the pftable_labels list and not
the rt_labels list. Luckily this bug was not visible because of the way the
pftable and rtlabel code works. Found by Thomas E. Spanjaard.
@
text
@d1 1
a1 1
/*	$OpenBSD: name2id.c,v 1.6 2006/04/26 20:19:41 claudio Exp $ */
d46 1
d49 24
@


1.6
log
@Remove unused _exists() function. It is not even used in my evil filter tree
so I doubt I will need it anytime soon. Additionally I think that the interface
is dangerous as it bypasses the ref-counting.
@
text
@d1 1
a1 1
/*	$OpenBSD: name2id.c,v 1.5 2005/11/02 15:34:43 claudio Exp $ */
d76 1
a76 1
	return (_name2id(&rt_labels, name));
d82 1
a82 1
	return (_id2name(&rt_labels, id));
d88 1
a88 1
	_unref(&rt_labels, id);
d94 1
a94 1
	_ref(&rt_labels, id);
@


1.5
log
@Mark some additional function arguments as const.
@
text
@d1 1
a1 1
/*	$OpenBSD: name2id.c,v 1.4 2005/07/01 09:19:24 claudio Exp $ */
a44 1
int		 _exists(struct n2id_labels *, const char *);
a195 15
}

int
_exists(struct n2id_labels *head, const char *name)
{
	struct n2id_label	*label;

	if (!name[0])
		return (0);

	TAILQ_FOREACH(label, head, entry)
		if (strcmp(name, label->name) == 0)
			return (label->id);

	return (0);
@


1.4
log
@Make the pftable filter set use the name2id "cache" like the route labels.
This saves 14 bytes per aspath. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: name2id.c,v 1.3 2005/06/29 09:43:25 claudio Exp $ */
d51 1
a51 1
rtlabel_name2id(char *name)
d75 1
a75 1
pftable_name2id(char *name)
@


1.3
log
@rtlabel support via filter sets. Just use "set rtlabel foobar" in filters
network and neighbor statements and the routes are labeled accordingly.
While doing that fix some mem-leaks by introducing filterset_free() and
remove the free on send option of send_filterset().
This took a bit longer because we need to carefully track the rtlabel id
refcnts or bad things may happen on reloads.
henning@@ looks fine
@
text
@d1 1
a1 1
/*	$OpenBSD: name2id.c,v 1.2 2005/06/25 16:26:25 claudio Exp $ */
d48 1
a48 1
struct n2id_labels	filter_labels = TAILQ_HEAD_INITIALIZER(filter_labels);
d70 24
@


1.2
log
@Make the name2id/id2name code generically usable. This will be needed by
the upcomming filter rewrite.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: name2id.c,v 1.1 2005/06/13 21:16:18 henning Exp $ */
d44 1
d68 6
d129 1
a129 1
	if (!id)
d158 15
@


1.1
log
@route label support, kroute part and ID allocator as well as the internal
interface changes. support in the filter language and rde to come. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d24 1
d32 5
a36 5
struct rt_label {
	TAILQ_ENTRY(rt_label)	entry;
	char			name[RTLABEL_LEN];
	u_int16_t		id;
	int			ref;
d39 1
a39 1
TAILQ_HEAD(rt_labels, rt_label)	rt_labels = TAILQ_HEAD_INITIALIZER(rt_labels);
d41 7
d52 19
a70 1
	struct rt_label		*label, *p = NULL;
d73 2
a74 1
	if (!name[0])
d76 1
d78 1
a78 1
	TAILQ_FOREACH(label, &rt_labels, entry)
d90 2
a91 2
	if (!TAILQ_EMPTY(&rt_labels))
		for (p = TAILQ_FIRST(&rt_labels); p != NULL &&
d95 2
a96 1
	if (new_id > IDVAL_MAX)
d98 1
d100 1
a100 1
	if ((label = calloc(1, sizeof(struct rt_label))) == NULL)
d102 4
a105 1
	strlcpy(label->name, name, sizeof(label->name));
d112 1
a112 1
		TAILQ_INSERT_TAIL(&rt_labels, label, entry);
d118 1
a118 1
rtlabel_id2name(u_int16_t id)
d120 1
a120 1
	struct rt_label	*label;
d123 1
a123 1
		return("");
d125 1
a125 1
	TAILQ_FOREACH(label, &rt_labels, entry)
d133 1
a133 1
rtlabel_unref(u_int16_t id)
d135 1
a135 1
	struct rt_label	*p, *next;
d140 1
a140 1
	for (p = TAILQ_FIRST(&rt_labels); p != NULL; p = next) {
d144 2
a145 1
				TAILQ_REMOVE(&rt_labels, p, entry);
d151 15
@

