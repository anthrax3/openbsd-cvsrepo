head	1.188;
access;
symbols
	OPENBSD_6_1:1.188.0.2
	OPENBSD_6_1_BASE:1.188
	OPENBSD_6_0:1.185.0.4
	OPENBSD_6_0_BASE:1.185
	OPENBSD_5_9:1.184.0.2
	OPENBSD_5_9_BASE:1.184
	OPENBSD_5_8:1.179.0.4
	OPENBSD_5_8_BASE:1.179
	OPENBSD_5_7:1.175.0.2
	OPENBSD_5_7_BASE:1.175
	OPENBSD_5_6:1.174.0.6
	OPENBSD_5_6_BASE:1.174
	OPENBSD_5_5:1.174.0.4
	OPENBSD_5_5_BASE:1.174
	OPENBSD_5_4:1.172.0.2
	OPENBSD_5_4_BASE:1.172
	OPENBSD_5_3:1.170.0.2
	OPENBSD_5_3_BASE:1.170
	OPENBSD_5_2:1.168.0.4
	OPENBSD_5_2_BASE:1.168
	OPENBSD_5_1_BASE:1.168
	OPENBSD_5_1:1.168.0.2
	OPENBSD_5_0:1.167.0.2
	OPENBSD_5_0_BASE:1.167
	OPENBSD_4_9:1.166.0.2
	OPENBSD_4_9_BASE:1.166
	OPENBSD_4_8:1.165.0.2
	OPENBSD_4_8_BASE:1.165
	OPENBSD_4_7:1.155.0.2
	OPENBSD_4_7_BASE:1.155
	OPENBSD_4_6:1.148.0.4
	OPENBSD_4_6_BASE:1.148
	OPENBSD_4_5:1.145.0.4
	OPENBSD_4_5_BASE:1.145
	OPENBSD_4_4:1.145.0.2
	OPENBSD_4_4_BASE:1.145
	OPENBSD_4_3:1.144.0.4
	OPENBSD_4_3_BASE:1.144
	OPENBSD_4_2:1.144.0.2
	OPENBSD_4_2_BASE:1.144
	OPENBSD_4_1:1.143.0.2
	OPENBSD_4_1_BASE:1.143
	OPENBSD_4_0:1.139.0.2
	OPENBSD_4_0_BASE:1.139
	OPENBSD_3_9:1.132.0.2
	OPENBSD_3_9_BASE:1.132
	OPENBSD_3_8:1.123.0.2
	OPENBSD_3_8_BASE:1.123
	OPENBSD_3_7:1.113.0.2
	OPENBSD_3_7_BASE:1.113
	OPENBSD_3_6:1.105.0.2
	OPENBSD_3_6_BASE:1.105
	OPENBSD_3_5:1.88.0.2
	OPENBSD_3_5_BASE:1.88;
locks; strict;
comment	@ * @;


1.188
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.187;
commitid	airB1W2Kb948lFil;

1.187
date	2016.09.03.16.22.17;	author renato;	state Exp;
branches;
next	1.186;
commitid	FeUy6OVH7V8nX42o;

1.186
date	2016.09.02.14.00.29;	author benno;	state Exp;
branches;
next	1.185;
commitid	cUiKeXOsNjNjPeSK;

1.185
date	2016.06.20.20.12.52;	author benno;	state Exp;
branches;
next	1.184;
commitid	XzWSqwMV0V0FBzpJ;

1.184
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.183;
commitid	LQHdRRMF0nq0fugE;

1.183
date	2015.11.27.21.41.30;	author claudio;	state Exp;
branches;
next	1.182;
commitid	U2YoK19fNMhT4yll;

1.182
date	2015.11.20.23.26.08;	author florian;	state Exp;
branches;
next	1.181;
commitid	jqFrsUc2DRemaNMU;

1.181
date	2015.11.17.17.54.01;	author benno;	state Exp;
branches;
next	1.180;
commitid	pj16hS8PJQU6qP9m;

1.180
date	2015.11.12.20.49.46;	author benno;	state Exp;
branches;
next	1.179;
commitid	yf6m22odzkRpGN5g;

1.179
date	2015.08.04.14.46.38;	author phessler;	state Exp;
branches;
next	1.178;
commitid	wJyyJZr2xy2xDvm7;

1.178
date	2015.07.20.16.10.37;	author claudio;	state Exp;
branches;
next	1.177;
commitid	JXdI3dG8XAYCUdaO;

1.177
date	2015.07.16.18.26.04;	author claudio;	state Exp;
branches;
next	1.176;
commitid	LqSO5lx1xfCVcctP;

1.176
date	2015.03.14.02.43.02;	author claudio;	state Exp;
branches;
next	1.175;
commitid	0cBsZXPDxYuXNDWX;

1.175
date	2015.02.09.11.37.31;	author claudio;	state Exp;
branches;
next	1.174;
commitid	IcuyF0sCmFRE7OTK;

1.174
date	2013.11.13.20.41.01;	author benno;	state Exp;
branches;
next	1.173;

1.173
date	2013.11.13.09.14.48;	author florian;	state Exp;
branches;
next	1.172;

1.172
date	2013.05.31.23.10.13;	author claudio;	state Exp;
branches;
next	1.171;

1.171
date	2013.03.07.21.26.28;	author claudio;	state Exp;
branches;
next	1.170;

1.170
date	2012.11.02.18.02.45;	author florian;	state Exp;
branches;
next	1.169;

1.169
date	2012.09.18.09.45.51;	author claudio;	state Exp;
branches;
next	1.168;

1.168
date	2011.08.20.19.02.28;	author sthen;	state Exp;
branches;
next	1.167;

1.167
date	2011.05.01.10.42.28;	author claudio;	state Exp;
branches;
next	1.166;

1.166
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.165;

1.165
date	2010.06.28.19.52.03;	author sobrado;	state Exp;
branches;
next	1.164;

1.164
date	2010.06.27.19.53.34;	author claudio;	state Exp;
branches;
next	1.163;

1.163
date	2010.05.19.12.44.14;	author claudio;	state Exp;
branches;
next	1.162;

1.162
date	2010.05.17.15.49.29;	author claudio;	state Exp;
branches;
next	1.161;

1.161
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.160;

1.160
date	2010.04.26.12.25.06;	author claudio;	state Exp;
branches;
next	1.159;

1.159
date	2010.04.26.08.46.31;	author claudio;	state Exp;
branches;
next	1.158;

1.158
date	2010.04.22.08.24.58;	author claudio;	state Exp;
branches;
next	1.157;

1.157
date	2010.04.13.09.09.48;	author claudio;	state Exp;
branches;
next	1.156;

1.156
date	2010.03.29.09.09.25;	author claudio;	state Exp;
branches;
next	1.155;

1.155
date	2010.03.03.09.40.56;	author claudio;	state Exp;
branches;
next	1.154;

1.154
date	2010.02.11.14.40.06;	author claudio;	state Exp;
branches;
next	1.153;

1.153
date	2010.01.11.05.47.51;	author claudio;	state Exp;
branches;
next	1.152;

1.152
date	2009.12.31.15.34.02;	author claudio;	state Exp;
branches;
next	1.151;

1.151
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.150;

1.150
date	2009.11.02.20.38.15;	author claudio;	state Exp;
branches;
next	1.149;

1.149
date	2009.07.20.15.00.13;	author claudio;	state Exp;
branches;
next	1.148;

1.148
date	2009.06.07.00.30.23;	author claudio;	state Exp;
branches;
next	1.147;

1.147
date	2009.06.05.20.26.38;	author claudio;	state Exp;
branches;
next	1.146;

1.146
date	2009.06.04.04.46.42;	author claudio;	state Exp;
branches;
next	1.145;

1.145
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.144;

1.144
date	2007.05.11.11.27.59;	author claudio;	state Exp;
branches;
next	1.143;

1.143
date	2007.01.26.17.40.48;	author claudio;	state Exp;
branches;
next	1.142;

1.142
date	2007.01.04.18.38.51;	author henning;	state Exp;
branches;
next	1.141;

1.141
date	2007.01.04.12.43.36;	author claudio;	state Exp;
branches;
next	1.140;

1.140
date	2006.11.28.16.39.34;	author henning;	state Exp;
branches;
next	1.139;

1.139
date	2006.06.19.20.48.36;	author jmc;	state Exp;
branches;
next	1.138;

1.138
date	2006.06.17.14.06.09;	author henning;	state Exp;
branches;
next	1.137;

1.137
date	2006.05.27.21.24.36;	author claudio;	state Exp;
branches;
next	1.136;

1.136
date	2006.04.26.20.00.03;	author claudio;	state Exp;
branches;
next	1.135;

1.135
date	2006.03.22.13.30.35;	author claudio;	state Exp;
branches;
next	1.134;

1.134
date	2006.03.15.12.54.01;	author claudio;	state Exp;
branches;
next	1.133;

1.133
date	2006.03.15.11.33.42;	author claudio;	state Exp;
branches;
next	1.132;

1.132
date	2006.01.24.14.26.52;	author claudio;	state Exp;
branches;
next	1.131;

1.131
date	2006.01.24.10.05.24;	author henning;	state Exp;
branches;
next	1.130;

1.130
date	2006.01.24.10.03.44;	author henning;	state Exp;
branches;
next	1.129;

1.129
date	2006.01.03.16.49.23;	author claudio;	state Exp;
branches;
next	1.128;

1.128
date	2006.01.03.13.13.16;	author claudio;	state Exp;
branches;
next	1.127;

1.127
date	2005.12.24.14.11.13;	author claudio;	state Exp;
branches;
next	1.126;

1.126
date	2005.11.02.15.03.02;	author claudio;	state Exp;
branches;
next	1.125;

1.125
date	2005.11.01.10.58.29;	author claudio;	state Exp;
branches;
next	1.124;

1.124
date	2005.10.13.09.09.20;	author claudio;	state Exp;
branches;
next	1.123;

1.123
date	2005.07.01.13.38.14;	author claudio;	state Exp;
branches;
next	1.122;

1.122
date	2005.06.29.09.43.25;	author claudio;	state Exp;
branches;
next	1.121;

1.121
date	2005.06.09.15.32.03;	author claudio;	state Exp;
branches;
next	1.120;

1.120
date	2005.05.27.17.59.50;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2005.05.27.17.52.10;	author claudio;	state Exp;
branches;
next	1.118;

1.118
date	2005.05.23.22.48.53;	author henning;	state Exp;
branches;
next	1.117;

1.117
date	2005.04.28.13.54.45;	author claudio;	state Exp;
branches;
next	1.116;

1.116
date	2005.03.30.11.23.15;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2005.03.28.15.03.33;	author henning;	state Exp;
branches;
next	1.114;

1.114
date	2005.03.24.02.39.16;	author tedu;	state Exp;
branches;
next	1.113;

1.113
date	2005.02.09.10.56.28;	author henning;	state Exp;
branches;
next	1.112;

1.112
date	2005.02.02.18.52.32;	author henning;	state Exp;
branches;
next	1.111;

1.111
date	2004.11.23.13.07.01;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2004.10.19.12.02.49;	author henning;	state Exp;
branches;
next	1.109;

1.109
date	2004.09.23.01.55.05;	author henning;	state Exp;
branches;
next	1.108;

1.108
date	2004.09.16.17.36.29;	author henning;	state Exp;
branches;
next	1.107;

1.107
date	2004.09.16.00.25.12;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2004.09.15.18.30.42;	author otto;	state Exp;
branches;
next	1.105;

1.105
date	2004.08.24.11.43.16;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2004.08.05.21.01.38;	author claudio;	state Exp;
branches;
next	1.103;

1.103
date	2004.08.03.13.43.29;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2004.07.28.16.00.02;	author claudio;	state Exp;
branches;
next	1.101;

1.101
date	2004.07.05.02.13.43;	author henning;	state Exp;
branches;
next	1.100;

1.100
date	2004.07.04.03.51.31;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2004.07.04.03.37.03;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2004.07.03.17.19.59;	author claudio;	state Exp;
branches;
next	1.97;

1.97
date	2004.06.20.18.35.11;	author henning;	state Exp;
branches;
next	1.96;

1.96
date	2004.06.20.17.49.46;	author henning;	state Exp;
branches;
next	1.95;

1.95
date	2004.06.06.17.38.10;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2004.05.21.11.48.56;	author claudio;	state Exp;
branches;
next	1.93;

1.93
date	2004.05.07.10.06.15;	author djm;	state Exp;
branches;
next	1.92;

1.92
date	2004.05.03.04.44.41;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2004.04.29.19.56.04;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2004.04.27.04.38.12;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2004.04.25.17.34.39;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2004.03.16.12.06.43;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2004.03.12.16.21.34;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2004.03.11.14.22.22;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2004.03.11.13.35.05;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2004.03.10.15.15.48;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2004.03.10.14.45.24;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2004.03.10.13.48.45;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2004.03.01.16.53.48;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2004.02.19.13.54.58;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2004.02.09.23.16.46;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2004.02.09.23.10.04;	author henning;	state Exp;
branches;
next	1.77;

1.77
date	2004.02.09.01.38.55;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2004.02.09.00.00.41;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.07.11.42.30;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2004.02.06.20.18.18;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2004.02.03.17.36.30;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2004.01.23.21.18.12;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.22.20.34.55;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.22.03.18.03;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.20.09.44.33;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.17.19.35.35;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.17.18.05.46;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.11.22.01.13;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.11.21.32.56;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.11.19.14.43;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.11.02.35.13;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.11.01.00.07;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.09.19.08.50;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.09.13.47.07;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.08.16.17.12;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.05.22.57.59;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.05.19.10.24;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.05.18.21.51;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.05.16.21.14;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.04.19.39.46;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.03.20.37.34;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2004.01.03.20.22.07;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.03.14.06.35;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.01.23.46.47;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.01.23.09.08;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.30.22.42.31;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.30.20.59.43;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.27.14.58.22;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.27.14.24.42;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.27.01.31.49;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.27.00.53.51;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.26.21.40.40;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.26.20.59.54;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.26.18.33.11;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.26.18.07.32;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.26.17.47.04;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.26.17.15.09;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.26.16.54.10;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.26.14.55.03;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.26.14.38.58;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.26.00.49.52;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.26.00.27.23;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.26.00.14.04;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.25.17.07.24;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.25.02.24.26;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.25.02.09.19;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.25.02.04.46;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.24.20.09.56;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.24.19.59.24;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.24.19.22.00;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.24.13.28.01;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.23.19.14.49;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.23.18.28.05;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.22.21.48.23;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.22.15.22.13;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.22.15.11.45;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.22.15.07.05;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.22.11.11.25;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.22.11.04.12;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.22.11.00.19;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.21.23.28.39;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.21.23.26.37;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.21.18.18.21;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.20.21.26.48;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.20.20.53.30;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.20.19.17.51;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.20.18.50.40;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.20.18.32.22;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.20.14.33.09;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.17.19.26.26;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;


desc
@@


1.188
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@/*	$OpenBSD: bgpd.c,v 1.187 2016/09/03 16:22:17 renato Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "bgpd.h"
#include "mrt.h"
#include "session.h"
#include "log.h"

void		sighdlr(int);
__dead void	usage(void);
int		main(int, char *[]);
pid_t		start_child(enum bgpd_process, char *, int, int, int);
int		send_filterset(struct imsgbuf *, struct filter_set_head *);
int		reconfigure(char *, struct bgpd_config *, struct peer **);
int		dispatch_imsg(struct imsgbuf *, int, struct bgpd_config *);
int		control_setup(struct bgpd_config *);
int		imsg_send_sockets(struct imsgbuf *, struct imsgbuf *);

int			 rfd = -1;
int			 cflags;
volatile sig_atomic_t	 mrtdump;
volatile sig_atomic_t	 quit;
volatile sig_atomic_t	 reconfig;
pid_t			 reconfpid;
int			 reconfpending;
struct imsgbuf		*ibuf_se;
struct imsgbuf		*ibuf_rde;
struct rib_names	 ribnames = SIMPLEQ_HEAD_INITIALIZER(ribnames);
char			*cname;
char			*rcname;

void
sighdlr(int sig)
{
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		quit = 1;
		break;
	case SIGHUP:
		reconfig = 1;
		break;
	case SIGALRM:
	case SIGUSR1:
		mrtdump = 1;
		break;
	}
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-cdnv] [-D macro=value] [-f file]\n",
	    __progname);
	exit(1);
}

#define PFD_PIPE_SESSION	0
#define PFD_PIPE_ROUTE		1
#define PFD_SOCK_ROUTE		2
#define POLL_MAX		3
#define MAX_TIMEOUT		3600

int	 cmd_opts;

int
main(int argc, char *argv[])
{
	struct bgpd_config	*conf;
	struct peer		*peer_l, *p;
	struct pollfd		 pfd[POLL_MAX];
	pid_t			 io_pid = 0, rde_pid = 0, pid;
	char			*conffile;
	char			*saved_argv0;
	int			 debug = 0;
	int			 rflag = 0, sflag = 0;
	int			 ch, timeout, status;
	int			 pipe_m2s[2];
	int			 pipe_m2r[2];

	conffile = CONFFILE;
	bgpd_process = PROC_MAIN;

	log_init(1, LOG_DAEMON);	/* log to stderr until daemonized */
	log_procinit(log_procnames[bgpd_process]);
	log_setverbose(1);

	saved_argv0 = argv[0];
	if (saved_argv0 == NULL)
		saved_argv0 = "bgpd";

	conf = new_config();
	peer_l = NULL;

	while ((ch = getopt(argc, argv, "cdD:f:nRSv")) != -1) {
		switch (ch) {
		case 'c':
			cmd_opts |= BGPD_OPT_FORCE_DEMOTE;
			break;
		case 'd':
			debug = 1;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'n':
			cmd_opts |= BGPD_OPT_NOACTION;
			break;
		case 'v':
			if (cmd_opts & BGPD_OPT_VERBOSE)
				cmd_opts |= BGPD_OPT_VERBOSE2;
			cmd_opts |= BGPD_OPT_VERBOSE;
			break;
		case 'R':
			rflag = 1;
			break;
		case 'S':
			sflag = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0 || (sflag && rflag))
		usage();

	if (cmd_opts & BGPD_OPT_NOACTION) {
		if (parse_config(conffile, conf, &peer_l))
			exit(1);

		if (cmd_opts & BGPD_OPT_VERBOSE)
			print_config(conf, &ribnames, &conf->networks, peer_l,
			    conf->filters, conf->mrt, &conf->rdomains);
		else
			fprintf(stderr, "configuration OK\n");
		exit(0);
	}

	if (rflag)
		rde_main(debug, cmd_opts & BGPD_OPT_VERBOSE);
	else if (sflag)
		session_main(debug, cmd_opts & BGPD_OPT_VERBOSE);

	if (geteuid())
		errx(1, "need root privileges");

	if (getpwnam(BGPD_USER) == NULL)
		errx(1, "unknown user %s", BGPD_USER);

	log_init(debug, LOG_DAEMON);
	log_setverbose(cmd_opts & BGPD_OPT_VERBOSE);

	if (!debug)
		daemon(1, 0);

	log_info("startup");

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_m2s) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_m2r) == -1)
		fatal("socketpair");

	/* fork children */
	rde_pid = start_child(PROC_RDE, saved_argv0, pipe_m2r[1], debug,
	    cmd_opts & BGPD_OPT_VERBOSE);
	io_pid = start_child(PROC_SE, saved_argv0, pipe_m2s[1], debug,
	    cmd_opts & BGPD_OPT_VERBOSE);

	signal(SIGTERM, sighdlr);
	signal(SIGINT, sighdlr);
	signal(SIGHUP, sighdlr);
	signal(SIGALRM, sighdlr);
	signal(SIGUSR1, sighdlr);
	signal(SIGPIPE, SIG_IGN);

	if ((ibuf_se = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_rde = malloc(sizeof(struct imsgbuf))) == NULL)
		fatal(NULL);
	imsg_init(ibuf_se, pipe_m2s[0]);
	imsg_init(ibuf_rde, pipe_m2r[0]);
	mrt_init(ibuf_rde, ibuf_se);
	if ((rfd = kr_init()) == -1)
		quit = 1;

	/*
	 * rpath, read config file
	 * cpath, unlink control socket
	 * fattr, chmod on control socket
	 * wpath, needed if we are doing mrt dumps
	 *
	 * pledge placed here because kr_init() does a setsockopt on the
	 * routing socket thats not allowed at all.
	 */
#if 0
	/*
	 * disabled because we do ioctls on /dev/pf and SIOCSIFGATTR
	 * this needs some redesign of bgpd to be fixed.
	 */
	if (pledge("stdio rpath wpath cpath fattr unix route recvfd sendfd",
	    NULL) == -1)
		fatal("pledge");
#endif

	if (imsg_send_sockets(ibuf_se, ibuf_rde))
		fatal("could not establish imsg links");
	quit = reconfigure(conffile, conf, &peer_l);
	if (pftable_clear_all() != 0)
		quit = 1;

	while (quit == 0) {
		bzero(pfd, sizeof(pfd));

		set_pollfd(&pfd[PFD_PIPE_SESSION], ibuf_se);
		set_pollfd(&pfd[PFD_PIPE_ROUTE], ibuf_rde);

		pfd[PFD_SOCK_ROUTE].fd = rfd;
		pfd[PFD_SOCK_ROUTE].events = POLLIN;

		timeout = mrt_timeout(conf->mrt);
		if (timeout > MAX_TIMEOUT)
			timeout = MAX_TIMEOUT;

		if (poll(pfd, POLL_MAX, timeout * 1000) == -1)
			if (errno != EINTR) {
				log_warn("poll error");
				quit = 1;
			}

		if (handle_pollfd(&pfd[PFD_PIPE_SESSION], ibuf_se) == -1) {
			log_warnx("main: Lost connection to SE");
			msgbuf_clear(&ibuf_se->w);
			free(ibuf_se);
			ibuf_se = NULL;
			quit = 1;
		} else {
			if (dispatch_imsg(ibuf_se, PFD_PIPE_SESSION, conf) ==
			    -1)
				quit = 1;
		}

		if (handle_pollfd(&pfd[PFD_PIPE_ROUTE], ibuf_rde) == -1) {
			log_warnx("main: Lost connection to RDE");
			msgbuf_clear(&ibuf_rde->w);
			free(ibuf_rde);
			ibuf_rde = NULL;
			quit = 1;
		} else {
			if (dispatch_imsg(ibuf_rde, PFD_PIPE_ROUTE, conf) ==
			    -1)
				quit = 1;
		}

		if (pfd[PFD_SOCK_ROUTE].revents & POLLIN) {
			if (kr_dispatch_msg() == -1)
				quit = 1;
		}

		if (reconfig) {
			u_int	error;

			reconfig = 0;
			switch (reconfigure(conffile, conf, &peer_l)) {
			case -1:	/* fatal error */
				quit = 1;
				break;
			case 0:		/* all OK */
				error = 0;
				break;
			case 2:
				error = CTL_RES_PENDING;
				break;
			default:	/* parse error */
				error = CTL_RES_PARSE_ERROR;
				break;
			}
			if (reconfpid != 0) {
				send_imsg_session(IMSG_CTL_RESULT, reconfpid,
				    &error, sizeof(error));
				reconfpid = 0;
			}
		}

		if (mrtdump) {
			mrtdump = 0;
			mrt_handler(conf->mrt);
		}
	}

	/* close pipes */
	if (ibuf_se) {
		msgbuf_clear(&ibuf_se->w);
		close(ibuf_se->fd);
		free(ibuf_se);
	}
	if (ibuf_rde) {
		msgbuf_clear(&ibuf_rde->w);
		close(ibuf_rde->fd);
		free(ibuf_rde);
	}

	while ((p = peer_l) != NULL) {
		peer_l = p->next;
		free(p);
	}

	control_cleanup(conf->csock);
	control_cleanup(conf->rcsock);
	carp_demote_shutdown();
	kr_shutdown(conf->fib_priority);
	pftable_clear_all();

	free_config(conf);

	log_debug("waiting for children to terminate");
	do {
		pid = wait(&status);
		if (pid == -1) {
			if (errno != EINTR && errno != ECHILD)
				fatal("wait");
		} else if (WIFSIGNALED(status))
			log_warnx("%s terminated; signal %d",
			    (pid == rde_pid) ? "route decision engine" :
			    "session engine", WTERMSIG(status));
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	free(rcname);
	free(cname);

	log_info("terminating");
	return (0);
}

pid_t
start_child(enum bgpd_process p, char *argv0, int fd, int debug, int verbose)
{
	char *argv[5];
	int argc = 0;
	pid_t pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		close(fd);
		return (pid);
	}

	if (dup2(fd, 3) == -1)
		fatal("cannot setup imsg fd");

	argv[argc++] = argv0;
	switch (p) {
	case PROC_MAIN:
		fatalx("Can not start main process");
	case PROC_RDE:
		argv[argc++] = "-R";
		break;
	case PROC_SE:
		argv[argc++] = "-S";
		break;
	}
	if (debug)
		argv[argc++] = "-d";
	if (verbose)
		argv[argc++] = "-v";
	argv[argc++] = NULL;

	execvp(argv0, argv);
	fatal("execvp");
}

int
send_filterset(struct imsgbuf *i, struct filter_set_head *set)
{
	struct filter_set	*s;

	TAILQ_FOREACH(s, set, entry)
		if (imsg_compose(i, IMSG_FILTER_SET, 0, 0, -1, s,
		    sizeof(struct filter_set)) == -1)
			return (-1);
	return (0);
}

int
reconfigure(char *conffile, struct bgpd_config *conf, struct peer **peer_l)
{
	struct peer		*p;
	struct filter_rule	*r;
	struct listen_addr	*la;
	struct rde_rib		*rr;
	struct rdomain		*rd;

	if (reconfpending) {
		log_info("previous reload still running");
		return (2);
	}
	reconfpending = 2;	/* one per child */

	log_info("rereading config");
	if (parse_config(conffile, conf, peer_l)) {
		log_warnx("config file %s has errors, not reloading",
		    conffile);
		reconfpending = 0;
		return (1);
	}

	cflags = conf->flags;
	prepare_listeners(conf);

	/* start reconfiguration */
	if (imsg_compose(ibuf_se, IMSG_RECONF_CONF, 0, 0, -1,
	    conf, sizeof(struct bgpd_config)) == -1)
		return (-1);
	if (imsg_compose(ibuf_rde, IMSG_RECONF_CONF, 0, 0, -1,
	    conf, sizeof(struct bgpd_config)) == -1)
		return (-1);

	TAILQ_FOREACH(la, conf->listen_addrs, entry) {
		if (imsg_compose(ibuf_se, IMSG_RECONF_LISTENER, 0, 0, la->fd,
		    la, sizeof(struct listen_addr)) == -1)
			return (-1);
		la->fd = -1;
	}

	if (control_setup(conf) == -1)
		return (-1);

	/* adjust fib syncing on reload */
	ktable_preload();

	/* RIBs for the RDE */
	while ((rr = SIMPLEQ_FIRST(&ribnames))) {
		SIMPLEQ_REMOVE_HEAD(&ribnames, entry);
		if (ktable_update(rr->rtableid, rr->name, NULL,
		    rr->flags, conf->fib_priority) == -1) {
			log_warnx("failed to load rdomain %d",
			    rr->rtableid);
			return (-1);
		}
		if (imsg_compose(ibuf_rde, IMSG_RECONF_RIB, 0, 0, -1,
		    rr, sizeof(struct rde_rib)) == -1)
			return (-1);
		free(rr);
	}

	/* send peer list to the SE */
	for (p = *peer_l; p != NULL; p = p->next) {
		if (imsg_compose(ibuf_se, IMSG_RECONF_PEER, p->conf.id, 0, -1,
		    &p->conf, sizeof(struct peer_config)) == -1)
			return (-1);
	}

	/* networks go via kroute to the RDE */
	if (kr_net_reload(0, &conf->networks))
		return (-1);

	/* filters for the RDE */
	while ((r = TAILQ_FIRST(conf->filters)) != NULL) {
		TAILQ_REMOVE(conf->filters, r, entry);
		if (imsg_compose(ibuf_rde, IMSG_RECONF_FILTER, 0, 0, -1,
		    r, sizeof(struct filter_rule)) == -1)
			return (-1);
		if (send_filterset(ibuf_rde, &r->set) == -1)
			return (-1);
		filterset_free(&r->set);
		free(r);
	}

	while ((rd = SIMPLEQ_FIRST(&conf->rdomains)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&conf->rdomains, entry);
		if (ktable_update(rd->rtableid, rd->descr, rd->ifmpe,
		    rd->flags, conf->fib_priority) == -1) {
			log_warnx("failed to load rdomain %d",
			    rd->rtableid);
			return (-1);
		}
		/* networks go via kroute to the RDE */
		if (kr_net_reload(rd->rtableid, &rd->net_l))
			return (-1);

		if (imsg_compose(ibuf_rde, IMSG_RECONF_RDOMAIN, 0, 0, -1,
		    rd, sizeof(*rd)) == -1)
			return (-1);

		/* export targets */
		if (imsg_compose(ibuf_rde, IMSG_RECONF_RDOMAIN_EXPORT, 0, 0,
		    -1, NULL, 0) == -1)
			return (-1);
		if (send_filterset(ibuf_rde, &rd->export) == -1)
			return (-1);
		filterset_free(&rd->export);

		/* import targets */
		if (imsg_compose(ibuf_rde, IMSG_RECONF_RDOMAIN_IMPORT, 0, 0,
		    -1, NULL, 0) == -1)
			return (-1);
		if (send_filterset(ibuf_rde, &rd->import) == -1)
			return (-1);
		filterset_free(&rd->import);

		if (imsg_compose(ibuf_rde, IMSG_RECONF_RDOMAIN_DONE, 0, 0,
		    -1, NULL, 0) == -1)
			return (-1);

		free(rd);
	}

	/* signal the SE first then the RDE to activate the new config */
	if (imsg_compose(ibuf_se, IMSG_RECONF_DONE, 0, 0, -1, NULL, 0) == -1)
		return (-1);

	/* mrt changes can be sent out of bound */
	mrt_reconfigure(conf->mrt);
	return (0);
}

int
dispatch_imsg(struct imsgbuf *ibuf, int idx, struct bgpd_config *conf)
{
	struct imsg		 imsg;
	ssize_t			 n;
	int			 rv, verbose;

	rv = 0;
	while (ibuf) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			return (-1);

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_KROUTE_CHANGE:
			if (idx != PFD_PIPE_ROUTE)
				log_warnx("route request not from RDE");
			else if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kroute_full))
				log_warnx("wrong imsg len");
			else if (kr_change(imsg.hdr.peerid, imsg.data,
			    conf->fib_priority))
				rv = -1;
			break;
		case IMSG_KROUTE_DELETE:
			if (idx != PFD_PIPE_ROUTE)
				log_warnx("route request not from RDE");
			else if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kroute_full))
				log_warnx("wrong imsg len");
			else if (kr_delete(imsg.hdr.peerid, imsg.data,
			    conf->fib_priority))
				rv = -1;
			break;
		case IMSG_NEXTHOP_ADD:
			if (idx != PFD_PIPE_ROUTE)
				log_warnx("nexthop request not from RDE");
			else if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct bgpd_addr))
				log_warnx("wrong imsg len");
			else if (kr_nexthop_add(imsg.hdr.peerid, imsg.data) ==
			    -1)
				rv = -1;
			break;
		case IMSG_NEXTHOP_REMOVE:
			if (idx != PFD_PIPE_ROUTE)
				log_warnx("nexthop request not from RDE");
			else if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct bgpd_addr))
				log_warnx("wrong imsg len");
			else
				kr_nexthop_delete(imsg.hdr.peerid, imsg.data);
			break;
		case IMSG_PFTABLE_ADD:
			if (idx != PFD_PIPE_ROUTE)
				log_warnx("pftable request not from RDE");
			else
				if (imsg.hdr.len != IMSG_HEADER_SIZE +
				    sizeof(struct pftable_msg))
					log_warnx("wrong imsg len");
				else if (pftable_addr_add(imsg.data) != 0)
					rv = -1;
			break;
		case IMSG_PFTABLE_REMOVE:
			if (idx != PFD_PIPE_ROUTE)
				log_warnx("pftable request not from RDE");
			else
				if (imsg.hdr.len != IMSG_HEADER_SIZE +
				    sizeof(struct pftable_msg))
					log_warnx("wrong imsg len");
				else if (pftable_addr_remove(imsg.data) != 0)
					rv = -1;
			break;
		case IMSG_PFTABLE_COMMIT:
			if (idx != PFD_PIPE_ROUTE)
				log_warnx("pftable request not from RDE");
			else
				if (imsg.hdr.len != IMSG_HEADER_SIZE)
					log_warnx("wrong imsg len");
				else if (pftable_commit() != 0)
					rv = -1;
			break;
		case IMSG_CTL_RELOAD:
			if (idx != PFD_PIPE_SESSION)
				log_warnx("reload request not from SE");
			else {
				reconfig = 1;
				reconfpid = imsg.hdr.pid;
			}
			break;
		case IMSG_CTL_FIB_COUPLE:
			if (idx != PFD_PIPE_SESSION)
				log_warnx("couple request not from SE");
			else
				kr_fib_couple(imsg.hdr.peerid,
				    conf->fib_priority);
			break;
		case IMSG_CTL_FIB_DECOUPLE:
			if (idx != PFD_PIPE_SESSION)
				log_warnx("decouple request not from SE");
			else
				kr_fib_decouple(imsg.hdr.peerid,
				    conf->fib_priority);
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_SHOW_NEXTHOP:
		case IMSG_CTL_SHOW_INTERFACE:
		case IMSG_CTL_SHOW_FIB_TABLES:
			if (idx != PFD_PIPE_SESSION)
				log_warnx("kroute request not from SE");
			else
				kr_show_route(&imsg);
			break;
		case IMSG_IFINFO:
			if (idx != PFD_PIPE_SESSION)
				log_warnx("IFINFO request not from SE");
			else if (imsg.hdr.len != IMSG_HEADER_SIZE + IFNAMSIZ)
				log_warnx("IFINFO request with wrong len");
			else
				kr_ifinfo(imsg.data);
			break;
		case IMSG_DEMOTE:
			if (idx != PFD_PIPE_SESSION)
				log_warnx("demote request not from SE");
			else if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct demote_msg))
				log_warnx("DEMOTE request with wrong len");
			else {
				struct demote_msg	*msg;

				msg = imsg.data;
				carp_demote_set(msg->demote_group, msg->level);
			}
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by SE */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		case IMSG_RECONF_DONE:
			if (reconfpending == 0)
				log_warnx("unexpected RECONF_DONE received");
			else if (reconfpending == 2) {
				imsg_compose(ibuf_rde, IMSG_RECONF_DONE, 0,
				    0, -1, NULL, 0);

				/* finally fix kroute information */
				ktable_postload(conf->fib_priority);

				/* redistribute list needs to be reloaded too */
				kr_reload();
			}
			reconfpending--;
			break;
		default:
			break;
		}
		imsg_free(&imsg);
		if (rv != 0)
			return (rv);
	}
	return (0);
}

void
send_nexthop_update(struct kroute_nexthop *msg)
{
	char	*gw = NULL;

	if (msg->gateway.aid)
		if (asprintf(&gw, ": via %s",
		    log_addr(&msg->gateway)) == -1) {
			log_warn("send_nexthop_update");
			quit = 1;
		}

	log_debug("nexthop %s now %s%s%s", log_addr(&msg->nexthop),
	    msg->valid ? "valid" : "invalid",
	    msg->connected ? ": directly connected" : "",
	    msg->gateway.aid ? gw : "");

	free(gw);

	if (imsg_compose(ibuf_rde, IMSG_NEXTHOP_UPDATE, 0, 0, -1,
	    msg, sizeof(struct kroute_nexthop)) == -1)
		quit = 1;
}

void
send_imsg_session(int type, pid_t pid, void *data, u_int16_t datalen)
{
	imsg_compose(ibuf_se, type, 0, pid, -1, data, datalen);
}

int
send_network(int type, struct network_config *net, struct filter_set_head *h)
{
	if (imsg_compose(ibuf_rde, type, 0, 0, -1, net,
	    sizeof(struct network_config)) == -1)
		return (-1);
	/* networks that get deleted don't need to send the filter set */
	if (type == IMSG_NETWORK_REMOVE)
		return (0);
	if (send_filterset(ibuf_rde, h) == -1)
		return (-1);
	if (imsg_compose(ibuf_rde, IMSG_NETWORK_DONE, 0, 0, -1, NULL, 0) == -1)
		return (-1);

	return (0);
}

int
bgpd_filternexthop(struct kroute *kr, struct kroute6 *kr6)
{
	/* kernel routes are never filtered */
	if (kr && kr->flags & F_KERNEL && kr->prefixlen != 0)
		return (0);
	if (kr6 && kr6->flags & F_KERNEL && kr6->prefixlen != 0)
		return (0);

	if (cflags & BGPD_FLAG_NEXTHOP_BGP) {
		if (kr && kr->flags & F_BGPD_INSERTED)
			return (0);
		if (kr6 && kr6->flags & F_BGPD_INSERTED)
			return (0);
	}

	if (cflags & BGPD_FLAG_NEXTHOP_DEFAULT) {
		if (kr && kr->prefixlen == 0)
			return (0);
		if (kr6 && kr6->prefixlen == 0)
			return (0);
	}

	return (1);
}

int
control_setup(struct bgpd_config *conf)
{
	int fd, restricted;

	/* control socket is outside chroot */
	if (!cname || strcmp(cname, conf->csock)) {
		if (cname) {
			control_cleanup(cname);
			free(cname);
		}
		if ((cname = strdup(conf->csock)) == NULL)
			fatal("strdup");
		if ((fd = control_init(0, cname)) == -1)
			fatalx("control socket setup failed");
		if (control_listen(fd) == -1)
			fatalx("control socket setup failed");
		restricted = 0;
		if (imsg_compose(ibuf_se, IMSG_RECONF_CTRL, 0, 0, fd,
		    &restricted, sizeof(restricted)) == -1)
			return (-1);
	}
	if (!conf->rcsock) {
		/* remove restricted socket */
		control_cleanup(rcname);
		free(rcname);
		rcname = NULL;
	} else if (!rcname || strcmp(rcname, conf->rcsock)) {
		if (rcname) {
			control_cleanup(rcname);
			free(rcname);
		}
		if ((rcname = strdup(conf->rcsock)) == NULL)
			fatal("strdup");
		if ((fd = control_init(1, rcname)) == -1)
			fatalx("control socket setup failed");
		if (control_listen(fd) == -1)
			fatalx("control socket setup failed");
		restricted = 1;
		if (imsg_compose(ibuf_se, IMSG_RECONF_CTRL, 0, 0, fd,
		    &restricted, sizeof(restricted)) == -1)
			return (-1);
	}
	return (0);
}

void
set_pollfd(struct pollfd *pfd, struct imsgbuf *i)
{
	if (i == NULL || i->fd == -1) {
		pfd->fd = -1;
		return;
	}
	pfd->fd = i->fd;
	pfd->events = POLLIN;
	if (i->w.queued > 0)
		pfd->events |= POLLOUT;
}

int
handle_pollfd(struct pollfd *pfd, struct imsgbuf *i)  
{
	ssize_t n;

	if (i == NULL)
		return (0);

	if (pfd->revents & POLLOUT)
		if (msgbuf_write(&i->w) <= 0 && errno != EAGAIN) {
			log_warn("imsg write error");
			close(i->fd);
			i->fd = -1;
			return (-1);
		}

	if (pfd->revents & POLLIN) {
		if ((n = imsg_read(i)) == -1 && errno != EAGAIN) {
			log_warn("imsg read error");
			close(i->fd);
			i->fd = -1;
			return (-1);
		}
		if (n == 0) {
			log_warnx("peer closed imsg connection");
			close(i->fd);
			i->fd = -1;
			return (-1);
		}
	}
	return (0);
}

int
imsg_send_sockets(struct imsgbuf *se, struct imsgbuf *rde)
{
	int pipe_s2r[2];
	int pipe_s2r_ctl[2];

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	     PF_UNSPEC, pipe_s2r) == -1)
		return (-1);
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	     PF_UNSPEC, pipe_s2r_ctl) == -1)
		return (-1);

	if (imsg_compose(se, IMSG_SOCKET_CONN, 0, 0, pipe_s2r[0],
	    NULL, 0) == -1)
		return (-1);
	if (imsg_compose(rde, IMSG_SOCKET_CONN, 0, 0, pipe_s2r[1],
	    NULL, 0) == -1)
		return (-1);

	if (imsg_compose(se, IMSG_SOCKET_CONN_CTL, 0, 0, pipe_s2r_ctl[0],
	    NULL, 0) == -1)
		return (-1);
	if (imsg_compose(rde, IMSG_SOCKET_CONN_CTL, 0, 0, pipe_s2r_ctl[1],
	    NULL, 0) == -1)
		return (-1);

	return (0);
}
@


1.187
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.186 2016/09/02 14:00:29 benno Exp $ */
d33 1
d39 1
a116 1
	log_procname = log_procnames[bgpd_process];
d118 3
a120 2
	log_init(1);		/* log to stderr until daemonized */
	log_verbose(1);
a151 1
			log_verbose(1);
d193 2
a194 2
	log_init(debug);
	log_verbose(cmd_opts & BGPD_OPT_VERBOSE);
d704 1
a704 1
			log_verbose(verbose);
@


1.186
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.185 2016/06/20 20:12:52 benno Exp $ */
a42 1
int		check_child(pid_t, const char *);
a52 1
volatile sig_atomic_t	 sigchld;
a69 3
	case SIGCHLD:
		sigchld = 1;
		break;
d109 1
a109 1
	int			 ch, timeout;
a214 1
	signal(SIGCHLD, sighdlr);
a233 1
	 * proc, for kill() when shutting down
d243 2
a244 2
	if (pledge("stdio rpath wpath cpath fattr unix route recvfd sendfd "
	    "proc", NULL) == -1)
a326 12
		if (sigchld) {
			sigchld = 0;
			if (check_child(io_pid, "session engine")) {
				quit = 1;
				io_pid = 0;
			}
			if (check_child(rde_pid, "route decision engine")) {
				quit = 1;
				rde_pid = 0;
			}
		}

d333 11
a343 7
	signal(SIGCHLD, SIG_IGN);

	if (io_pid)
		kill(io_pid, SIGTERM);

	if (rde_pid)
		kill(rde_pid, SIGTERM);
d358 1
d360 8
a367 3
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
a369 4
	msgbuf_clear(&ibuf_se->w);
	free(ibuf_se);
	msgbuf_clear(&ibuf_rde->w);
	free(ibuf_rde);
d373 1
a373 1
	log_info("Terminating");
a415 20
}

int
check_child(pid_t pid, const char *pname)
{
	int	status;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("Lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("Lost child: %s terminated; signal %d",
			    pname, WTERMSIG(status));
			return (1);
		}
	}

	return (0);
@


1.185
log
@change the "nexthop 1.2.3.4 now valid: via 192.168.0.1" message to log_debug()
ok deraadt@@ florian@@ stsp@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.184 2016/02/02 17:51:11 sthen Exp $ */
d120 1
@


1.184
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.183 2015/11/27 21:41:30 claudio Exp $ */
d774 1
a774 1
	log_info("nexthop %s now %s%s%s", log_addr(&msg->nexthop),
@


1.183
log
@Imporve error messages for the imsg handler code. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.182 2015/11/20 23:26:08 florian Exp $ */
a215 2

	setproctitle("parent");
@


1.182
log
@bgpd has been naughty. It tries to play with AF_UNIX sockets without
pledging "unix".
Move control_listen up to the main process which already has
pledge("unix"). accept(2) was already allowed.

(Technically no longer necessary since listen(2) is now allowed, too,
but this moves it to the right place.)

OK claudio@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.181 2015/11/17 17:54:01 benno Exp $ */
d906 1
a906 1
			log_warn("handle_pollfd: msgbuf_write error");
d913 2
a914 2
		if ((n = imsg_read(i)) == -1) {
			log_warn("handle_pollfd: imsg_read error");
d919 2
a920 2
		if (n == 0) { /* connection closed */
			log_warn("handle_pollfd: poll fd");
@


1.181
log
@pledge() esposes a design issue in bgpd that will take a moment to
get right, so disable the pledge() call in bgpd (parent process) for now.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.180 2015/11/12 20:49:46 benno Exp $ */
d852 2
d872 2
@


1.180
log
@pledge the bgpd main process. Some of the promises can be improved upon
with a bit of rework, so comment why they are needed.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.179 2015/08/04 14:46:38 phessler Exp $ */
d246 5
d254 1
@


1.179
log
@Give more precise errors, to help track when bgpd quits

OK florian@@ benno@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.178 2015/07/20 16:10:37 claudio Exp $ */
d235 15
@


1.178
log
@Make bgpd execute the RDE and session engine process instead of just forking.
This way ASLR and stack cookies are per process.
With input from benno@@ and deraadt@@
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.177 2015/07/16 18:26:04 claudio Exp $ */
d261 1
a261 1
			log_warnx("Lost connection to SE");
d273 1
a273 1
			log_warnx("Lost connection to RDE");
@


1.177
log
@Next round of config cleanup. Move various lists into the bgpd_config struct.
This is the next step to better split parsing and merging the config.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.176 2015/03/14 02:43:02 claudio Exp $ */
d42 1
d48 1
d101 1
a101 1
int	cmd_opts;
d111 1
d113 2
a114 1
	int			 ch, timeout, nfds;
a116 2
	int			 pipe_s2r[2];
	int			 pipe_s2r_c[2];
d124 4
d131 1
a131 1
	while ((ch = getopt(argc, argv, "cdD:f:nv")) != -1) {
d156 6
d170 1
a170 1
	if (argc > 0)
d185 5
a209 6
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	     PF_UNSPEC, pipe_s2r) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	     PF_UNSPEC, pipe_s2r_c) == -1)
		fatal("socketpair");
d212 4
a215 2
	rde_pid = rde_main(pipe_m2r, pipe_s2r, pipe_m2s, pipe_s2r_c, debug);
	io_pid = session_main(pipe_m2s, pipe_s2r, pipe_m2r, pipe_s2r_c);
a226 5
	close(pipe_m2s[1]);
	close(pipe_m2r[1]);
	close(pipe_s2r[0]);
	close(pipe_s2r[1]);

d235 2
d243 4
a246 8
		pfd[PFD_PIPE_SESSION].fd = ibuf_se->fd;
		pfd[PFD_PIPE_SESSION].events = POLLIN;
		if (ibuf_se->w.queued)
			pfd[PFD_PIPE_SESSION].events |= POLLOUT;
		pfd[PFD_PIPE_ROUTE].fd = ibuf_rde->fd;
		pfd[PFD_PIPE_ROUTE].events = POLLIN;
		if (ibuf_rde->w.queued)
			pfd[PFD_PIPE_ROUTE].events |= POLLOUT;
d254 1
a254 1
		if ((nfds = poll(pfd, POLL_MAX, timeout * 1000)) == -1)
d260 7
a266 14
		if (nfds > 0 && pfd[PFD_PIPE_SESSION].revents & POLLOUT)
			if (msgbuf_write(&ibuf_se->w) <= 0 && errno != EAGAIN) {
				log_warn("pipe write error (to SE)");
				quit = 1;
			}

		if (nfds > 0 && pfd[PFD_PIPE_ROUTE].revents & POLLOUT)
			if (msgbuf_write(&ibuf_rde->w) <= 0 &&
			    errno != EAGAIN) {
				log_warn("pipe write error (to RDE)");
				quit = 1;
			}

		if (nfds > 0 && pfd[PFD_PIPE_SESSION].revents & POLLIN) {
d272 7
a278 1
		if (nfds > 0 && pfd[PFD_PIPE_ROUTE].revents & POLLIN) {
d284 1
a284 1
		if (nfds > 0 && pfd[PFD_SOCK_ROUTE].revents & POLLIN) {
d370 41
a582 8
	if ((n = imsg_read(ibuf)) == -1)
		return (-1);

	if (n == 0) {	/* connection closed */
		log_warnx("dispatch_imsg in main: pipe closed");
		return (-1);
	}

d584 1
a584 1
	for (;;) {
d855 76
@


1.176
log
@Move the command line options (mainly -d and -v) out of struct bgpd_config
into a own flag field since these can't be modified via a config reload.
OK henning@@ benno@@ before lock
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.175 2015/02/09 11:37:31 claudio Exp $ */
d44 1
a44 2
int		reconfigure(char *, struct bgpd_config *, struct mrt_head *,
		    struct peer **);
d104 1
a104 2
	struct bgpd_config	 conf;
	struct mrt_head		 mrt_l;
a105 2
	struct mrt		*m;
	struct listen_addr	*la;
d122 1
a122 2
	bzero(&conf, sizeof(conf));
	LIST_INIT(&mrt_l);
d162 1
a162 6
		struct network_head	net_l;
		struct rdomain_head	rdom_l;
		struct filter_head	rules_l;

		if (parse_config(conffile, &conf, &mrt_l, &peer_l, &net_l,
		    &rules_l, &rdom_l))
d166 2
a167 2
			print_config(&conf, &ribnames, &net_l, peer_l, &rules_l,
			    &mrt_l, &rdom_l);
d227 1
a227 1
	quit = reconfigure(conffile, &conf, &mrt_l, &peer_l);
d244 1
a244 1
		timeout = mrt_timeout(&mrt_l);
d268 1
a268 1
			if (dispatch_imsg(ibuf_se, PFD_PIPE_SESSION, &conf) ==
d274 1
a274 1
			if (dispatch_imsg(ibuf_rde, PFD_PIPE_ROUTE, &conf) ==
d288 1
a288 1
			switch (reconfigure(conffile, &conf, &mrt_l, &peer_l)) {
d323 1
a323 1
			mrt_handler(&mrt_l);
a338 10
	while ((m = LIST_FIRST(&mrt_l)) != NULL) {
		LIST_REMOVE(m, entry);
		free(m);
	}
	if (conf.listen_addrs)
		while ((la = TAILQ_FIRST(conf.listen_addrs)) != NULL) {
			TAILQ_REMOVE(conf.listen_addrs, la, entry);
			close(la->fd);
			free(la);
		}
d340 2
a341 2
	control_cleanup(conf.csock);
	control_cleanup(conf.rcsock);
d343 1
a343 1
	kr_shutdown(conf.fib_priority);
d345 2
a346 1
	free(conf.listen_addrs);
d398 1
a398 2
reconfigure(char *conffile, struct bgpd_config *conf, struct mrt_head *mrt_l,
    struct peer **peer_l)
a399 3
	struct network_head	 net_l;
	struct rdomain_head	 rdom_l;
	struct filter_head	 rules_l;
d413 1
a413 2
	if (parse_config(conffile, conf, mrt_l, peer_l, &net_l, &rules_l,
	    &rdom_l)) {
d467 1
a467 1
	if (kr_net_reload(0, &net_l))
d471 2
a472 2
	while ((r = TAILQ_FIRST(&rules_l)) != NULL) {
		TAILQ_REMOVE(&rules_l, r, entry);
d482 2
a483 2
	while ((rd = SIMPLEQ_FIRST(&rdom_l)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&rdom_l, entry);
d526 1
a526 1
	mrt_reconfigure(mrt_l);
@


1.175
log
@Kill session_socket_blockmode() and replace it with SOCK_CLOEXEC or
SOCK_NONBLOCK and accept4(). OK henning@@ tested & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.174 2013/11/13 20:41:01 benno Exp $ */
d100 2
d133 1
a133 1
			conf.opts |= BGPD_OPT_FORCE_DEMOTE;
d147 1
a147 1
			conf.opts |= BGPD_OPT_NOACTION;
d150 3
a152 3
			if (conf.opts & BGPD_OPT_VERBOSE)
				conf.opts |= BGPD_OPT_VERBOSE2;
			conf.opts |= BGPD_OPT_VERBOSE;
d166 1
a166 1
	if (conf.opts & BGPD_OPT_NOACTION) {
d175 1
a175 1
		if (conf.opts & BGPD_OPT_VERBOSE)
d190 1
a190 1
	log_verbose(conf.opts & BGPD_OPT_VERBOSE);
@


1.174
log
@from claudio
"Let msgbuf_write return -1 with errno EAGAIN. The users then must
check if this was the case and readd the event or poll again.  The
current handling in the imsg code is wrong for sure."

ok gilles, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.173 2013/11/13 09:14:48 florian Exp $ */
d195 2
a196 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_m2s) == -1)
d198 2
a199 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_m2r) == -1)
d201 2
a202 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_s2r) == -1)
d204 2
a205 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_s2r_c) == -1)
a206 8
	session_socket_blockmode(pipe_m2s[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_m2s[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_m2r[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_m2r[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_s2r[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_s2r[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_s2r_c[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_s2r_c[1], BM_NONBLOCK);
@


1.173
log
@Knob to set priority with which bgpd inserts routes into the kernel
routing table. Need for it in "special" setups pointed out by
Loic Blot (loic.blot _AT_ unix-experience _DOT_ fr) on tech.
OK benno, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.172 2013/05/31 23:10:13 claudio Exp $ */
d267 1
a267 1
			if (msgbuf_write(&ibuf_se->w) < 0) {
d273 2
a274 1
			if (msgbuf_write(&ibuf_rde->w) < 0) {
@


1.172
log
@Unfuck BGP MPLS VPNs that got broken by the last few reload related commits.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.171 2013/03/07 21:26:28 claudio Exp $ */
d46 1
a46 1
int		dispatch_imsg(struct imsgbuf *, int);
d279 2
a280 1
			if (dispatch_imsg(ibuf_se, PFD_PIPE_SESSION) == -1)
d285 2
a286 1
			if (dispatch_imsg(ibuf_rde, PFD_PIPE_ROUTE) == -1)
d364 1
a364 1
	kr_shutdown();
d473 1
a473 1
		    rr->flags) == -1) {
d510 1
a510 1
		    rd->flags) == -1) {
d556 1
a556 1
dispatch_imsg(struct imsgbuf *ibuf, int idx)
d585 2
a586 1
			else if (kr_change(imsg.hdr.peerid, imsg.data))
d595 2
a596 1
			else if (kr_delete(imsg.hdr.peerid, imsg.data))
d659 2
a660 1
				kr_fib_couple(imsg.hdr.peerid);
d666 2
a667 1
				kr_fib_decouple(imsg.hdr.peerid);
d713 1
a713 1
				ktable_postload();
@


1.171
log
@Implements a few missing bits for better templates support:
- on config reload also adjust the cloned neighbors so that they get the
  config changes as well.
- clean up sessions that are 1h idle but in state active (instead of down)
- add bits to allow bgpctl to destroy cloned neighbors
Tested by sthen@@ some time ago, OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.170 2012/11/02 18:02:45 florian Exp $ */
a547 7
	/* fix kroute information */
	ktable_postload();

	/* redistribute list needs to be reloaded too */
	if (kr_reload() == -1)
		return (-1);

d702 1
a702 1
			else if (reconfpending == 2)
d705 7
@


1.170
log
@Unstick bgpctl reload after reloading a bgpd.conf with errors.

ok claudio, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.169 2012/09/18 09:45:51 claudio Exp $ */
d482 1
a482 1
	/* send peer list and listeners to the SE and RDE */
a486 3
		if (imsg_compose(ibuf_rde, IMSG_RECONF_PEER, p->conf.id, 0, -1,
		    &p->conf, sizeof(struct peer_config)) == -1)
			return (-1);
d544 2
a545 3
	/* signal both childs to replace their config */
	if (imsg_compose(ibuf_se, IMSG_RECONF_DONE, 0, 0, -1, NULL, 0) == -1 ||
	    imsg_compose(ibuf_rde, IMSG_RECONF_DONE, 0, 0, -1, NULL, 0) == -1)
d709 3
@


1.169
log
@Only allow one reload request at a time in bgpd. Needed for further work.
OK sthen@@, benno@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.168 2011/08/20 19:02:28 sthen Exp $ */
d439 1
@


1.168
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"-v" (previously only "-vd" worked). Similar to recent ospfd commit.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.167 2011/05/01 10:42:28 claudio Exp $ */
d56 1
a296 1
			log_info("rereading config");
d304 3
d428 7
d656 1
a656 1
			else
d659 1
d708 5
@


1.167
log
@Free cname and rcname on exit. Found by Milosz Jakubowski
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.166 2010/09/02 14:03:21 sobrado Exp $ */
d121 1
d187 1
@


1.166
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.165 2010/06/28 19:52:03 sobrado Exp $ */
d371 2
@


1.165
log
@remove -r and -s from usage, these options were dropped on a previous
change to bgpd; while here, rewrite usage() in a more usual way.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.164 2010/06/27 19:53:34 claudio Exp $ */
d508 1
a508 1
		
@


1.164
log
@Instead of specifying the control sockets on the command line have them
in bgpd.conf. This allows to add/modify restricted control sockets on runtime.
Feature request by a few people how often forgot to add -r path when restarting
bgpd (including myself).
NOTE: this removes the -s and -r arguments from bgpd so pay attention when
updateing.
jajaja sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.163 2010/05/19 12:44:14 claudio Exp $ */
d88 2
a89 2
	fprintf(stderr, "usage: %s [-cdnv] ", __progname);
	fprintf(stderr, "[-D macro=value] [-f file] [-r path] [-s path]\n");
@


1.163
log
@Add softreconfig support for peers changing the RIB. Done by first unloading
the old RIB and then via softreconfig in and a special softreconfig out loading
the new RIB.
Feature requested and testeded by Elisa Jasinska.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.162 2010/05/17 15:49:29 claudio Exp $ */
d47 1
d59 2
a124 1
	conf.csock = SOCKET_NAME;
d126 1
a126 1
	while ((ch = getopt(argc, argv, "cdD:f:nr:s:v")) != -1) {
a150 6
		case 'r':
			conf.rcsock = optarg;
			break;
		case 's':
			conf.csock = optarg;
			break;
d211 1
a211 2
	io_pid = session_main(pipe_m2s, pipe_s2r, pipe_m2r, pipe_s2r_c,
	    conf.csock, conf.rcsock);
d446 3
d775 42
@


1.162
log
@Last bits of MPLS VPN support. Hook kernel routing tables and RIB together.
This adds a bit of new config to specify the mapping between an rdomain and
the BGP MPLS VPN instance, example:
rdomain 1 {
        descr "CUSTOMER1"
	rd 65003:1
	import-target rt 65003:3
	export-target rt 65003:1
	depend on mpe0
	network 192.168.224/24
}
The "depend on mpe0" is a but ugly but for now this is the quickest way to
figure out which interface bgp should use to insert the MPLS routes.

A big side-effect of this diff is that networks are now internally
distributed through kroute.c.
This needs some kernel changes that will follow hopefully soon.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.161 2010/05/03 13:09:38 claudio Exp $ */
a443 7
	/* send peer list and listeners to the SE */
	for (p = *peer_l; p != NULL; p = p->next) {
		if (imsg_compose(ibuf_se, IMSG_RECONF_PEER, p->conf.id, 0, -1,
		    &p->conf, sizeof(struct peer_config)) == -1)
			return (-1);
	}

d467 10
@


1.161
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.160 2010/04/26 12:25:06 claudio Exp $ */
d49 6
a54 10
int			 cflags = 0;
struct filter_set_head	*connectset;
struct filter_set_head	*connectset6;
struct filter_set_head	*staticset;
struct filter_set_head	*staticset6;
volatile sig_atomic_t	 mrtdump = 0;
volatile sig_atomic_t	 quit = 0;
volatile sig_atomic_t	 sigchld = 0;
volatile sig_atomic_t	 reconfig = 0;
pid_t			 reconfpid = 0;
d168 1
d172 1
a172 1
		    &rules_l))
d177 1
a177 1
			    &mrt_l);
a181 5
	cflags = conf.flags;
	connectset = &conf.connectset;
	staticset = &conf.staticset;
	connectset6 = &conf.connectset6;
	staticset6 = &conf.staticset6;
d418 1
a419 1
	struct network		*n;
d424 1
d426 2
a427 1
	if (parse_config(conffile, conf, mrt_l, peer_l, &net_l, &rules_l)) {
a433 5
	connectset = &conf->connectset;
	staticset = &conf->staticset;
	connectset6 = &conf->connectset6;
	staticset6 = &conf->staticset6;

d464 2
a465 1
		if (ktable_update(rr) == -1) {
d476 3
a478 14
	/* networks for the RDE */
	while ((n = TAILQ_FIRST(&net_l)) != NULL) {
		if (imsg_compose(ibuf_rde, IMSG_NETWORK_ADD, 0, 0, -1,
		    &n->net, sizeof(struct network_config)) == -1)
			return (-1);
		if (send_filterset(ibuf_rde, &n->net.attrset) == -1)
			return (-1);
		if (imsg_compose(ibuf_rde, IMSG_NETWORK_DONE, 0, 0, -1,
		    NULL, 0) == -1)
			return (-1);
		TAILQ_REMOVE(&net_l, n, entry);
		filterset_free(&n->net.attrset);
		free(n);
	}
d482 1
a487 1
		TAILQ_REMOVE(&rules_l, r, entry);
d492 39
d734 1
a734 1
bgpd_redistribute(int type, struct kroute *kr, struct kroute6 *kr6)
d736 1
a736 34
	struct network_config	 net;
	struct filter_set_head	*h;

	if ((cflags & BGPD_FLAG_REDIST_CONNECTED) && kr &&
	    (kr->flags & F_CONNECTED))
		h = connectset;
	else if ((cflags & BGPD_FLAG_REDIST_STATIC) && kr &&
	    (kr->flags & F_STATIC))
		h = staticset;
	else if ((cflags & BGPD_FLAG_REDIST6_CONNECTED) && kr6 &&
	    (kr6->flags & F_CONNECTED))
		h = connectset6;
	else if ((cflags & BGPD_FLAG_REDIST6_STATIC) && kr6 &&
	    (kr6->flags & F_STATIC))
		h = staticset6;
	else
		return (0);

	bzero(&net, sizeof(net));
	if (kr && kr6)
		fatalx("bgpd_redistribute: unable to redistribute v4 and v6"
		    "together");
	if (kr != NULL) {
		net.prefix.aid = AID_INET;
		net.prefix.v4.s_addr = kr->prefix.s_addr;
		net.prefixlen = kr->prefixlen;
	}
	if (kr6 != NULL) {
		net.prefix.aid = AID_INET6;
		memcpy(&net.prefix.v6, &kr6->prefix, sizeof(struct in6_addr));
		net.prefixlen = kr6->prefixlen;
	}

	if (imsg_compose(ibuf_rde, type, 0, 0, -1, &net,
a738 1

d741 1
a741 2
		return (1);

d747 1
a747 1
	return (1);
@


1.160
log
@Add some { } for better readability and to make the code look like the
other blocks in this function.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.159 2010/04/26 08:46:31 claudio Exp $ */
d247 2
a249 3
	if ((rfd = kr_init(!(conf.flags & BGPD_FLAG_NO_FIB_UPDATE),
	    conf.rtableid)) == -1)
		quit = 1;
d469 3
d475 5
a500 4
	/* redistribute list needs to be reloaded too */
	if (kr_reload() == -1)
		return (-1);

d518 7
d560 1
a560 1
			else if (kr_change(imsg.data))
d569 1
a569 1
			else if (kr_delete(imsg.data))
d578 2
a579 1
			else if (kr_nexthop_add(imsg.data) == -1)
d589 1
a589 1
				kr_nexthop_delete(imsg.data);
d631 1
a631 1
				kr_fib_couple();
d637 1
a637 1
				kr_fib_decouple();
d643 1
@


1.159
log
@Fix some memory leaks on config reload failure and move one particular
cleanup loop to parse.y where it belongs.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.158 2010/04/22 08:24:58 claudio Exp $ */
d457 1
a457 1
	for (p = *peer_l; p != NULL; p = p->next)
d461 1
@


1.158
log
@Including bgpd.h in mrt.h is dumb.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.157 2010/04/13 09:09:48 claudio Exp $ */
a436 4
		while ((rr = SIMPLEQ_FIRST(&ribnames))) {
			SIMPLEQ_REMOVE_HEAD(&ribnames, entry);
			free(rr);
		}
@


1.157
log
@Instead of passing AF specific struct kroutes over imsgs use a struct
kroute_full structure that is AF independent and has all information in
it. Simplifies the communication between processes and reduces the number
of imsg types. This is another step to add FIB support to BGP MPLS VPNs.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.156 2010/03/29 09:09:25 claudio Exp $ */
d35 1
a36 1
#include "bgpd.h"
@


1.156
log
@Since we always reload the config now there is no need to allocate the
filter list head. It is only used temporary in reconfigure().
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.155 2010/03/03 09:40:56 claudio Exp $ */
d550 3
d559 3
a564 12
		case IMSG_KROUTE6_CHANGE:
			if (idx != PFD_PIPE_ROUTE)
				log_warnx("route request not from RDE");
			else if (kr6_change(imsg.data))
				rv = -1;
			break;
		case IMSG_KROUTE6_DELETE:
			if (idx != PFD_PIPE_ROUTE)
				log_warnx("route request not from RDE");
			else if (kr6_delete(imsg.data))
				rv = -1;
			break;
d568 5
a572 6
			else
				if (imsg.hdr.len != IMSG_HEADER_SIZE +
				    sizeof(struct bgpd_addr))
					log_warnx("wrong imsg len");
				else if (kr_nexthop_add(imsg.data) == -1)
					rv = -1;
d577 3
d581 1
a581 5
				if (imsg.hdr.len != IMSG_HEADER_SIZE +
				    sizeof(struct bgpd_addr))
					log_warnx("wrong imsg len");
				else
					kr_nexthop_delete(imsg.data);
@


1.155
log
@Remove superfluous newline
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.154 2010/02/11 14:40:06 claudio Exp $ */
d45 1
a45 1
		    struct peer **, struct filter_head *);
a105 1
	struct filter_head	*rules_l;
a122 3
	if ((rules_l = calloc(1, sizeof(struct filter_head))) == NULL)
		err(1, NULL);

a123 1
	TAILQ_INIT(rules_l);
d171 3
a173 2
		struct network_head	 net_l;
		TAILQ_INIT(&net_l);
d175 1
a175 2
		    rules_l)) {
			free(rules_l);
a176 1
		}
d179 1
a179 1
			print_config(&conf, &ribnames, &net_l, peer_l, rules_l,
d247 1
a247 1
	quit = reconfigure(conffile, &conf, &mrt_l, &peer_l, rules_l);
d309 1
a309 2
			switch (reconfigure(conffile, &conf, &mrt_l, &peer_l,
			    rules_l)) {
a367 1
	free(rules_l);
d424 1
a424 1
    struct peer **peer_l, struct filter_head *rules_l)
d427 1
d434 1
a434 1
	if (parse_config(conffile, conf, mrt_l, peer_l, &net_l, rules_l)) {
d502 1
a502 1
	while ((r = TAILQ_FIRST(rules_l)) != NULL) {
d508 1
a508 1
		TAILQ_REMOVE(rules_l, r, entry);
@


1.154
log
@We need to load the config before kr_init() is called or fib-update is
ignored. Found and fix tested by Elisa Jasinska.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.153 2010/01/11 05:47:51 claudio Exp $ */
a755 1

@


1.153
log
@Do not crash when starting up with a bad config file. Check that
conf.listen_addr is actually valid before deref.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.152 2009/12/31 15:34:02 claudio Exp $ */
d253 1
a258 1
	quit = reconfigure(conffile, &conf, &mrt_l, &peer_l, rules_l);
@


1.152
log
@Instead of passing the config via arguments to the childs on bootup issue
a config reload as first step in bootup. This allows childs to start with
an empty config and a lot of special cleanup code can bite the dust.
Testing by myself and sthen@@ with a few configs (more testing welcome).
Seems like a good idea henning@@ & sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.151 2009/12/01 14:28:05 claudio Exp $ */
d368 6
a373 5
	while ((la = TAILQ_FIRST(conf.listen_addrs)) != NULL) {
		TAILQ_REMOVE(conf.listen_addrs, la, entry);
		close(la->fd);
		free(la);
	}
@


1.151
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.150 2009/11/02 20:38:15 claudio Exp $ */
d104 1
a105 2
	struct mrt_head		 mrt_l;
	struct network_head	 net_l;
a106 2
	struct network		*net;
	struct filter_rule	*r;
a108 1
	struct rde_rib		*rr;
d128 1
a129 2
	TAILQ_INIT(&net_l);
	TAILQ_INIT(rules_l);
d175 8
a182 4
	if (parse_config(conffile, &conf, &mrt_l, &peer_l, &net_l, rules_l)) {
		free(rules_l);
		exit(1);
	}
a183 1
	if (conf.opts & BGPD_OPT_NOACTION) {
a226 2
	prepare_listeners(&conf);

d228 3
a230 4
	rde_pid = rde_main(&conf, peer_l, &net_l, rules_l, &mrt_l, &ribnames,
	    pipe_m2r, pipe_s2r, pipe_m2s, pipe_s2r_c, debug);
	io_pid = session_main(&conf, peer_l, &net_l, rules_l, &mrt_l, &ribnames,
	    pipe_m2s, pipe_s2r, pipe_m2r, pipe_s2r_c);
d258 1
a258 21

	while ((net = TAILQ_FIRST(&net_l)) != NULL) {
		TAILQ_REMOVE(&net_l, net, entry);
		filterset_free(&net->net.attrset);
		free(net);
	}

	while ((r = TAILQ_FIRST(rules_l)) != NULL) {
		TAILQ_REMOVE(rules_l, r, entry);
		free(r);
	}
	TAILQ_FOREACH(la, conf.listen_addrs, entry) {
		close(la->fd);
		la->fd = -1;
	}
	while ((rr = SIMPLEQ_FIRST(&ribnames))) {
		SIMPLEQ_REMOVE_HEAD(&ribnames, entry);
		free(rr);
	}

	mrt_reconfigure(&mrt_l);
@


1.150
log
@Implement IMSG_CTL_LOG_VERBOSE similar to ospfd. Even though bgpd has almost
no log_debug() it makes more sense to make all routing daemons behave the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.149 2009/07/20 15:00:13 claudio Exp $ */
d720 1
a720 1
	if (msg->gateway.af)
d730 1
a730 1
	    msg->gateway.af ? gw : "");
d771 1
a771 1
		net.prefix.af = AF_INET;
d776 1
a776 1
		net.prefix.af = AF_INET6;
@


1.149
log
@On config reload errors free the list of ribs so that following reloads
don't fail because of redefinition conflicts. This problem was reported
by some people.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.148 2009/06/07 00:30:23 claudio Exp $ */
d161 1
d558 2
a559 2
	int			 n;
	int			 rv;
d699 5
@


1.148
log
@First attempt at reload support for RIBs. There is some magic that I do
not fully understand but at least no flames are comming out of my test
box anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.147 2009/06/05 20:26:38 claudio Exp $ */
d467 4
@


1.147
log
@Adjust print_config to all the stuff added in the last days.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.146 2009/06/04 04:46:42 claudio Exp $ */
d462 1
d497 9
@


1.146
log
@Add "rde rib <name>" to the config and allow the rde to use these other RIBs.
Still a bit hackish, reload is missing and printconf as well. Looks good h@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.145 2008/05/12 19:15:02 pyr Exp $ */
d186 2
a187 1
			print_config(&conf, &net_l, peer_l, rules_l, &mrt_l);
@


1.145
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.144 2007/05/11 11:27:59 claudio Exp $ */
d61 1
d112 1
d230 1
a230 1
	rde_pid = rde_main(&conf, peer_l, &net_l, rules_l, &mrt_l,
d232 1
a232 1
	io_pid = session_main(&conf, peer_l, &net_l, rules_l, &mrt_l,
d275 4
@


1.144
log
@Various spelling fixes from Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.143 2007/01/26 17:40:48 claudio Exp $ */
d171 5
@


1.143
log
@Massiv rework of the control imsg flow. Main changes:
- dedicated pipe between the SE and the RDE for control messages
- restartable RB tree dumps in the RDE
- queuing limits both in the SE and RDE
The result is a dramatic decrease of memory consumption on operations like
bgpctl show rib. Previously all messages where first stored in the RDE
then passed to the SE where they got queued in case bgpctl was not fast enough.
Now only a small number of messages is generated and passed to the SE and
the SE has an additional limit instead of acting like an infinite buffer.
Without this the bgpd on bgpd.networx.ch would not survive a single minute.
looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.142 2007/01/04 18:38:51 henning Exp $ */
d517 1
a517 1
	/* singal both childs to replace their config */
@


1.142
log
@ignore SIGPIPE, like the other 2 processes already do. we detect broken
pipes without the signal just fine. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.141 2007/01/04 12:43:36 claudio Exp $ */
d119 1
d209 2
d217 2
d224 1
a224 1
	    pipe_m2r, pipe_s2r, pipe_m2s, debug);
d226 1
a226 1
	    pipe_m2s, pipe_s2r, pipe_m2r);
@


1.141
log
@Do not run rde_shutdown() unless bgpd is started with -d.
On some of my systems rde_shutdown() takes more than 3min doing nothing more
than calling free(3) over and over again.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.140 2006/11/28 16:39:34 henning Exp $ */
d231 1
@


1.140
log
@allow bgpd to work on alternate routing tables, claudio ok, jmc manpage help
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.139 2006/06/19 20:48:36 jmc Exp $ */
d219 1
a219 1
	    pipe_m2r, pipe_s2r, pipe_m2s);
@


1.139
log
@add -c to usage() and synopsis;
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.138 2006/06/17 14:06:09 henning Exp $ */
d243 2
a244 1
	if ((rfd = kr_init(!(conf.flags & BGPD_FLAG_NO_FIB_UPDATE))) == -1)
@


1.138
log
@implement carp demotion control for bgpd.
sessions can be configured to modify the carp demotion counter for a
given interface group (usually, "carp", which has all carp interfaces)
when the session is not established. once the session is established for
60 seconds, the demotion is cleared.
this, used correctly, can prevent a bgpd-box which lost all sessions (and
thus has no routes) to be carp master, while the backup has sessions.
thought through and partially hacked on a drive from calgary to vancouver
with ryan, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.137 2006/05/27 21:24:36 claudio Exp $ */
d88 1
a88 1
	fprintf(stderr, "usage: %s [-dnv] ", __progname);
@


1.137
log
@Pass a IMSG_CTL_RESULT messgae back to bgpctl on reloads to indicate if
the reload was successful or not. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.136 2006/04/26 20:00:03 claudio Exp $ */
d135 1
a135 1
	while ((ch = getopt(argc, argv, "dD:f:nr:s:v")) != -1) {
d137 3
d382 1
d652 13
@


1.136
log
@Last argument to send_filterset() is a left-over from one of my not so clever
ideas that will never be included and always set to 0. Kill it.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.135 2006/03/22 13:30:35 claudio Exp $ */
d56 1
d58 1
a58 1
volatile sig_atomic_t	 sigchld = 0;
d313 2
d317 17
a333 1
			reconfigure(conffile, &conf, &mrt_l, &peer_l, rules_l);
d443 1
a443 1
		return (-1);
d618 1
@


1.135
log
@Change the way bgpd selects nexthops. Up until now every route was considered
when calculating the nexthop. Now only non BGP routes and not the default
route are used unless forced with the new config options
 nexthop qualify via bgp
 nexthop qualify via default
This change is required for complex setups e.g. where an additional IGP is
running.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.134 2006/03/15 12:54:01 claudio Exp $ */
d43 1
a43 2
int		send_filterset(struct imsgbuf *, struct filter_set_head *,
		    int);
d400 1
a400 1
send_filterset(struct imsgbuf *i, struct filter_set_head *set, int id)
d405 1
a405 1
		if (imsg_compose(i, IMSG_FILTER_SET, id, 0, -1, s,
d461 1
a461 1
		if (send_filterset(ibuf_rde, &n->net.attrset, 0) == -1)
d480 1
a480 1
		if (send_filterset(ibuf_rde, &r->set, 0) == -1)
d714 1
a714 1
	if (send_filterset(ibuf_rde, h, 0) == -1)
@


1.134
log
@Sync usage with man page (sort arguments).
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.133 2006/03/15 11:33:42 claudio Exp $ */
d473 1
a473 1
	if (kr_redist_reload() == -1)
d723 25
@


1.133
log
@Allow the control socket to be changed on the command line. Useful if you
need to run multiple bgpds on a single box to simulate a IX. This helped
me massivly debugging error reports. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.132 2006/01/24 14:26:52 claudio Exp $ */
d89 1
a89 1
	fprintf(stderr, "[-D macro=value] [-f file] [-s path] [-r path]\n");
@


1.132
log
@Functions in the poll() loop should only be moved around if there are no
side-effects. Revert last changes and make bgpctl reload work again.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.131 2006/01/24 10:05:24 henning Exp $ */
d89 1
a89 1
	fprintf(stderr, "[-D macro=value] [-f file] [-r path]\n");
d133 1
d135 1
a135 1
	while ((ch = getopt(argc, argv, "dD:f:nr:v")) != -1) {
d159 3
d359 1
a359 1
	control_cleanup(SOCKET_NAME);
@


1.131
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.130 2006/01/24 10:03:44 henning Exp $ */
d281 27
d326 1
a326 1
		if (mrtdump == 1) {
a328 30
		}

		if (nfds == -1 || nfds == 0)
			continue;

		if (pfd[PFD_PIPE_SESSION].revents & POLLOUT)
			if (msgbuf_write(&ibuf_se->w) < 0) {
				log_warn("pipe write error (to SE)");
				quit = 1;
			}

		if (pfd[PFD_PIPE_ROUTE].revents & POLLOUT)
			if (msgbuf_write(&ibuf_rde->w) < 0) {
				log_warn("pipe write error (to RDE)");
				quit = 1;
			}

		if (pfd[PFD_PIPE_SESSION].revents & POLLIN) {
			if (dispatch_imsg(ibuf_se, PFD_PIPE_SESSION) == -1)
				quit = 1;
		}

		if (pfd[PFD_PIPE_ROUTE].revents & POLLIN) {
			if (dispatch_imsg(ibuf_rde, PFD_PIPE_ROUTE) == -1)
				quit = 1;
		}

		if (pfd[PFD_SOCK_ROUTE].revents & POLLIN) {
			if (kr_dispatch_msg() == -1)
				quit = 1;
@


1.130
log
@introduce a second control socket, which is restricted to certain messages,
nameley the show ones. needed for looking glass style applications,
monitoring etc. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.129 2006/01/03 16:49:23 claudio Exp $ */
d306 1
a306 1
	
@


1.129
log
@Plug some mem leaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.128 2006/01/03 13:13:16 claudio Exp $ */
d89 1
a89 1
	fprintf(stderr, "[-D macro=value] [-f file]\n");
d134 1
a134 1
	while ((ch = getopt(argc, argv, "dD:f:nv")) != -1) {
d155 3
d358 2
a359 1
	control_cleanup();
@


1.128
log
@Move the signal handler flags check between the poll() call and the poll
fd handling. Do not access poll fd in case of an error or timeout.
With and OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.127 2005/12/24 14:11:13 claudio Exp $ */
d240 1
@


1.127
log
@bzero the pfd array before setting it up and calling poll because on error
(e.g. EINTR) poll() will not update the pfd array (copyout) and so the old
revents are used and results in a blocking parent process. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.126 2005/11/02 15:03:02 claudio Exp $ */
d115 1
a115 1
	int			 ch, timeout;
d271 1
a271 1
		if (poll(pfd, POLL_MAX, timeout * 1000) == -1)
d277 26
a327 23
		}

		if (reconfig) {
			reconfig = 0;
			log_info("rereading config");
			reconfigure(conffile, &conf, &mrt_l, &peer_l, rules_l);
		}

		if (sigchld) {
			sigchld = 0;
			if (check_child(io_pid, "session engine")) {
				quit = 1;
				io_pid = 0;
			}
			if (check_child(rde_pid, "route decision engine")) {
				quit = 1;
				rde_pid = 0;
			}
		}

		if (mrtdump == 1) {
			mrtdump = 0;
			mrt_handler(&mrt_l);
@


1.126
log
@Reorder and comment reconfigure(). Makes more sense so.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.125 2005/11/01 10:58:29 claudio Exp $ */
d255 1
@


1.125
log
@Switch from the per peer filter set list to a filter-only solution.
The default filter_sets are converted into match filter rules that get
evaluated first. Simplifies code massively -- mainly the config reload
part -- and makes softreconfig out a piece of cake.  "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.124 2005/10/13 09:09:20 claudio Exp $ */
d426 1
d433 3
a435 1
	for (p = *peer_l; p != NULL; p = p->next) {
d439 6
d446 2
d461 1
d466 1
a476 6
	TAILQ_FOREACH(la, conf->listen_addrs, entry) {
		if (imsg_compose(ibuf_se, IMSG_RECONF_LISTENER, 0, 0, la->fd,
		    la, sizeof(struct listen_addr)) == -1)
			return (-1);
		la->fd = -1;
	}
d478 1
@


1.124
log
@Simplify poll loop as well. "grrr, OK" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.123 2005/07/01 13:38:14 claudio Exp $ */
a434 3
			return (-1);
		if (send_filterset(ibuf_se, &p->conf.attrset,
		    p->conf.id) == -1)
@


1.123
log
@Switch filter_sets form SIMPLEQ to TAILQ, needed for upcomming stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.122 2005/06/29 09:43:25 claudio Exp $ */
d115 1
a115 1
	int			 ch, nfds, timeout;
d270 1
a270 1
		if ((nfds = poll(pfd, POLL_MAX, timeout * 1000)) == -1)
d276 1
a276 1
		if (nfds > 0 && (pfd[PFD_PIPE_SESSION].revents & POLLOUT))
d282 1
a282 1
		if (nfds > 0 && (pfd[PFD_PIPE_ROUTE].revents & POLLOUT))
d288 1
a288 2
		if (nfds > 0 && pfd[PFD_PIPE_SESSION].revents & POLLIN) {
			nfds--;
d293 1
a293 2
		if (nfds > 0 && pfd[PFD_PIPE_ROUTE].revents & POLLIN) {
			nfds--;
d298 1
a298 2
		if (nfds > 0 && pfd[PFD_SOCK_ROUTE].revents & POLLIN) {
			nfds--;
@


1.122
log
@rtlabel support via filter sets. Just use "set rtlabel foobar" in filters
network and neighbor statements and the routes are labeled accordingly.
While doing that fix some mem-leaks by introducing filterset_free() and
remove the free on send option of send_filterset().
This took a bit longer because we need to carefully track the rtlabel id
refcnts or bad things may happen on reloads.
henning@@ looks fine
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.121 2005/06/09 15:32:03 claudio Exp $ */
d398 1
a398 1
	SIMPLEQ_FOREACH(s, set, entry)
@


1.121
log
@Change the "network connected|static" statements to "network inet|inet6
connected|static" so that it is possible to distinguish between IPv4 and IPv6
addresses. "network connected|static" is considered deprecated but will be
supported as an alias for "network inet connected|static" for some time (one
release) to simplify upgrades. This also solve a nasty crash when using
"network connected".  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.120 2005/05/27 17:59:50 henning Exp $ */
d44 1
a44 1
		    int, int);
d394 1
a394 1
send_filterset(struct imsgbuf *i, struct filter_set_head *set, int id, int f)
d398 1
a398 1
	for (s = SIMPLEQ_FIRST(set); s != NULL; ) {
a401 7
		if (f) {
			SIMPLEQ_REMOVE_HEAD(set, entry);
			free(s);
			s = SIMPLEQ_FIRST(set);
		} else
			s = SIMPLEQ_NEXT(s, entry);
	}
d440 1
a440 1
		    p->conf.id, 0) == -1)
d447 1
a447 1
		if (send_filterset(ibuf_rde, &n->net.attrset, 0, 1) == -1)
d453 1
d464 1
a464 1
		if (send_filterset(ibuf_rde, &r->set, 0, 1) == -1)
d467 1
d703 1
a703 1
	if (send_filterset(ibuf_rde, h, 0, 0) == -1)
@


1.120
log
@will throw claudio in a big pot of kaesefondue for repeated whitespace fuckups
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.119 2005/05/27 17:52:10 claudio Exp $ */
d52 1
d54 1
d176 2
d431 2
d669 2
a670 1
	if ((cflags & BGPD_FLAG_REDIST_CONNECTED) && (kr->flags & F_CONNECTED))
d672 2
a673 1
	else if ((cflags & BGPD_FLAG_REDIST_STATIC) && (kr->flags & F_STATIC))
d675 6
@


1.119
log
@kroute6 support, at least partially. Get it in so that Henning can clean it
up more. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.118 2005/05/23 22:48:53 henning Exp $ */
d693 1
a693 1
	
@


1.118
log
@one more endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.117 2005/04/28 13:54:45 claudio Exp $ */
d521 12
d658 1
a658 1
bgpd_redistribute(int type, struct kroute *kr)
d671 14
a684 3
	net.prefix.af = AF_INET;
	net.prefix.v4.s_addr = kr->prefix.s_addr;
	net.prefixlen = kr->prefixlen;
@


1.117
log
@Support for "network connected" and "network static" -- announce all
directly connected respectively all static routes. The list is auto-
matically adjusted as soon as a route changes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.116 2005/03/30 11:23:15 henning Exp $ */
a179 1
	endpwent();
@


1.116
log
@bgpd used to open listeners in advance in the parent and the SE picked
those it needed, closing all the others. this has some nasty races.
so let the parent keep the list of listeners so it knows when it has
to open a new one
claudio ok, also tested by jason ackley
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.115 2005/03/28 15:03:33 henning Exp $ */
d50 3
d171 3
d425 4
d457 4
d645 35
@


1.115
log
@free rules_l if the initial config file parse fails
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.114 2005/03/24 02:39:16 tedu Exp $ */
d238 1
a238 3

	while ((la = TAILQ_FIRST(conf.listen_addrs)) != NULL) {
		TAILQ_REMOVE(conf.listen_addrs, la, entry);
d240 1
a240 1
		free(la);
d337 5
d456 1
a456 1
	while ((la = TAILQ_FIRST(conf->listen_addrs)) != NULL) {
d460 1
a460 2
		TAILQ_REMOVE(conf->listen_addrs, la, entry);
		free(la);
a461 2
	free(conf->listen_addrs);
	conf->listen_addrs = NULL;
@


1.114
log
@fix memory leak in error paths.  found with coverity prevent.
ok claudio henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.113 2005/02/09 10:56:28 henning Exp $ */
d156 2
a157 1
	if (parse_config(conffile, &conf, &mrt_l, &peer_l, &net_l, rules_l))
d159 1
@


1.113
log
@need to send IMSG_NETWORK_DONE after sending networks and associated filter
sets, otherwise local netyworks get withdrawn after config reload;
misbehaviour noticed by peter.galbavy@@knowtion.net, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.112 2005/02/02 18:52:32 henning Exp $ */
d475 1
d485 1
d498 1
a498 1
				return (-1);
d504 1
a504 1
				return (-1);
d514 1
a514 1
					return (-1);
d534 1
a534 1
					return (-1);
d544 1
a544 1
					return (-1);
d553 1
a553 1
					return (-1);
d594 2
@


1.112
log
@usage() is __dead
pt out by Alexander v Gernler
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.111 2004/11/23 13:07:01 claudio Exp $ */
d435 3
@


1.111
log
@Switch from a single filter_set to a linked list of sets. With this change
it is possible to specify multiple communities. This is also the first step
to better bgpd filters. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.110 2004/10/19 12:02:49 henning Exp $ */
d39 9
a47 8
void	sighdlr(int);
void	usage(void);
int	main(int, char *[]);
int	check_child(pid_t, const char *);
int	send_filterset(struct imsgbuf *, struct filter_set_head *, int, int);
int	reconfigure(char *, struct bgpd_config *, struct mrt_head *,
	    struct peer **, struct filter_head *);
int	dispatch_imsg(struct imsgbuf *, int);
d78 1
a78 1
void
@


1.110
log
@allow neighbor definitions to depend on interface state.
with this, if a neighbor is configured as dependent on carp0 for example,
the neighbor will remain in state IDLE as long as carp0 is not master.
once carp0 becomes master the session(s) depending on it immediately
go to CONNECT (or ACTIVE, if they're configured passive), reducing failover
time. claudio ok, with some input from ryan as well
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.109 2004/09/23 01:55:05 henning Exp $ */
d43 1
d379 19
d421 1
a421 1
	for (p = *peer_l; p != NULL; p = p->next)
d425 4
d433 2
d441 2
@


1.109
log
@after receival of a SIGCHLD reset io_pid or rde_pid, respectively, dependent
on which child went away.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.108 2004/09/16 17:36:29 henning Exp $ */
d547 8
@


1.108
log
@imsg API cleanup:
-kill imsg_compose_pid, imsg_compose_fdpass and imsg_create_pid
-extend the original imsg_compose/_create API to take pid & fd too
-make imsg_compose do imsg_create + imsg_add + imsg_close instead of
 duplicating the code
-adjust all callers to the new API
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.107 2004/09/16 00:25:12 henning Exp $ */
d303 1
a303 1
			if (check_child(io_pid, "session engine"))
d305 3
a307 1
			if (check_child(rde_pid, "route decision engine"))
d309 2
@


1.107
log
@malloc the imsg buffers instead of having them staticly, suggested by
micskye some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.106 2004/09/15 18:30:42 otto Exp $ */
d391 1
a391 1
	if (imsg_compose(ibuf_se, IMSG_RECONF_CONF, 0,
d394 1
a394 1
	if (imsg_compose(ibuf_rde, IMSG_RECONF_CONF, 0,
d398 1
a398 1
		if (imsg_compose(ibuf_se, IMSG_RECONF_PEER, p->conf.id,
d402 1
a402 1
		if (imsg_compose(ibuf_rde, IMSG_NETWORK_ADD, 0,
d409 1
a409 1
		if (imsg_compose(ibuf_rde, IMSG_RECONF_FILTER, 0,
d416 1
a416 1
		if (imsg_compose_fdpass(ibuf_se, IMSG_RECONF_LISTENER, la->fd,
d425 2
a426 2
	if (imsg_compose(ibuf_se, IMSG_RECONF_DONE, 0, NULL, 0) == -1 ||
	    imsg_compose(ibuf_rde, IMSG_RECONF_DONE, 0, NULL, 0) == -1)
d571 1
a571 1
	if (imsg_compose(ibuf_rde, IMSG_NEXTHOP_UPDATE, 0,
d579 1
a579 1
	imsg_compose_pid(ibuf_se, type, pid, data, datalen);
@


1.106
log
@if (signalflag) { dowork(); signalflag = 0; } is a race. First clear flag,
then call work(). ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.105 2004/08/24 11:43:16 henning Exp $ */
d47 7
a53 7
int			rfd = -1;
volatile sig_atomic_t	mrtdump = 0;
volatile sig_atomic_t	quit = 0;
volatile sig_atomic_t	reconfig = 0;
volatile sig_atomic_t	sigchld = 0;
struct imsgbuf		ibuf_se;
struct imsgbuf		ibuf_rde;
d214 6
a219 3
	imsg_init(&ibuf_se, pipe_m2s[0]);
	imsg_init(&ibuf_rde, pipe_m2r[0]);
	mrt_init(&ibuf_rde, &ibuf_se);
d244 1
a244 1
		pfd[PFD_PIPE_SESSION].fd = ibuf_se.fd;
d246 1
a246 1
		if (ibuf_se.w.queued)
d248 1
a248 1
		pfd[PFD_PIPE_ROUTE].fd = ibuf_rde.fd;
d250 1
a250 1
		if (ibuf_rde.w.queued)
d266 1
a266 1
			if (msgbuf_write(&ibuf_se.w) < 0) {
d272 1
a272 1
			if (msgbuf_write(&ibuf_rde.w) < 0) {
d279 1
a279 1
			if (dispatch_imsg(&ibuf_se, PFD_PIPE_SESSION) == -1)
d285 1
a285 1
			if (dispatch_imsg(&ibuf_rde, PFD_PIPE_ROUTE) == -1)
d344 5
d391 1
a391 1
	if (imsg_compose(&ibuf_se, IMSG_RECONF_CONF, 0,
d394 1
a394 1
	if (imsg_compose(&ibuf_rde, IMSG_RECONF_CONF, 0,
d398 1
a398 1
		if (imsg_compose(&ibuf_se, IMSG_RECONF_PEER, p->conf.id,
d402 1
a402 1
		if (imsg_compose(&ibuf_rde, IMSG_NETWORK_ADD, 0,
d409 1
a409 1
		if (imsg_compose(&ibuf_rde, IMSG_RECONF_FILTER, 0,
d416 1
a416 1
		if (imsg_compose_fdpass(&ibuf_se, IMSG_RECONF_LISTENER, la->fd,
d425 2
a426 2
	if (imsg_compose(&ibuf_se, IMSG_RECONF_DONE, 0, NULL, 0) == -1 ||
	    imsg_compose(&ibuf_rde, IMSG_RECONF_DONE, 0, NULL, 0) == -1)
d571 1
a571 1
	if (imsg_compose(&ibuf_rde, IMSG_NEXTHOP_UPDATE, 0,
d579 1
a579 1
	imsg_compose_pid(&ibuf_se, type, pid, data, datalen);
@


1.105
log
@use session_socket_blockmode() instead of hand-rolling roughly the same
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.104 2004/08/05 21:01:38 claudio Exp $ */
d293 1
a295 1
			reconfig = 0;
d299 1
a303 1
			sigchld = 0;
d307 1
a308 1
			mrtdump = 0;
@


1.104
log
@The peer_l is not needed in the rde but still allocated, free them and
save 1k per peer. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.103 2004/08/03 13:43:29 claudio Exp $ */
a180 3
	if (fcntl(pipe_m2s[0], F_SETFL, O_NONBLOCK) == -1 ||
	    fcntl(pipe_m2s[1], F_SETFL, O_NONBLOCK) == -1)
		fatal("fcntl");
a182 3
	if (fcntl(pipe_m2r[0], F_SETFL, O_NONBLOCK) == -1 ||
	    fcntl(pipe_m2r[1], F_SETFL, O_NONBLOCK) == -1)
		fatal("fcntl");
d185 6
a190 3
	if (fcntl(pipe_s2r[0], F_SETFL, O_NONBLOCK) == -1 ||
	    fcntl(pipe_s2r[1], F_SETFL, O_NONBLOCK) == -1)
		fatal("fcntl");
@


1.103
log
@Fix mem-leak on exit. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.102 2004/07/28 16:00:02 claudio Exp $ */
d198 2
a199 2
	rde_pid = rde_main(&conf, &net_l, rules_l, &mrt_l, pipe_m2r, pipe_s2r,
	    pipe_m2s);
@


1.102
log
@The hole dance to close a mrt file after fd passing in the parent is not
needed as the fd is closed while beeing passed. looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.101 2004/07/05 02:13:43 henning Exp $ */
d336 1
@


1.101
log
@fix a few KNF fallouts
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.100 2004/07/04 03:51:31 henning Exp $ */
d45 1
a45 1
int	dispatch_imsg(struct imsgbuf *, int, struct mrt_head *);
d279 1
a279 2
			if (dispatch_imsg(&ibuf_se, PFD_PIPE_SESSION,
			    &mrt_l) == -1)
d285 1
a285 2
			if (dispatch_imsg(&ibuf_rde, PFD_PIPE_ROUTE,
			    &mrt_l) == -1)
d429 1
a429 1
dispatch_imsg(struct imsgbuf *ibuf, int idx, struct mrt_head *mrt_l)
a431 1
	struct mrt		 mrt;
a449 9
		case IMSG_MRT_CLOSE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct mrt)) {
				log_warnx("wrong imsg len");
				break;
			}
			memcpy(&mrt, imsg.data, sizeof(struct mrt));
			mrt_close(mrt_get(mrt_l, &mrt));
			break;
@


1.100
log
@2 more file descriptors for each RDE and SE inherited from the parent
we should close
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.99 2004/07/04 03:37:03 henning Exp $ */
d258 1
a258 1
		
@


1.99
log
@when getting rid of the listen_addr TAILQ after forking actually close
the file descriptors in RDE and parent process, not needed or used there
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.98 2004/07/03 17:19:59 claudio Exp $ */
d198 2
a199 1
	rde_pid = rde_main(&conf, &net_l, rules_l, &mrt_l, pipe_m2r, pipe_s2r);
d201 1
a201 1
	    pipe_m2s, pipe_s2r);
@


1.98
log
@Switch mrt dumping to fd passing. This gives some speed up when extensive
dumping is done. Acctually mrt dumps were broken because of the fd passing.
The nice side effect is a much cleaner code, especially in the parent process.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.97 2004/06/20 18:35:11 henning Exp $ */
d236 1
@


1.97
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.96 2004/06/20 17:49:46 henning Exp $ */
a85 1
#define POLL_MAX		8
d89 2
a90 1
#define PFD_MRT_START		3
d102 1
a102 1
	struct mrt		*(mrt[POLL_MAX]), *m;
d108 1
a108 1
	int			 ch, i, j, nfds, timeout;
d239 2
a251 2
		i = PFD_MRT_START;
		i = mrt_select(&mrt_l, pfd, mrt, i, POLL_MAX, &timeout);
d253 5
a257 1
		if ((nfds = poll(pfd, i, INFTIM)) == -1)
a294 8
		for (j = PFD_MRT_START; j < i && nfds > 0 ; j++) {
			if (pfd[j].revents & POLLOUT) {
				if (mrt_write(mrt[j]) < 0) {
					log_warn("mrt write error");
				}
			}
		}

d328 1
a328 1
		LIST_REMOVE(m, list);
d423 2
d432 1
d451 8
a458 4
		case IMSG_MRT_MSG:
		case IMSG_MRT_END:
			if (mrt_queue(mrt_l, &imsg) == -1)
				log_warnx("mrt_queue failed.");
@


1.96
log
@implement file descriptor passing in the imsg/msgbuf framework, and use
it to let the main process to prepare new listening sockets (socket() and
bind()) on behalf of the session engine, which of course cannot bind() to
ports < 1024 any more once it dropped privileges. with some help from theo,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.95 2004/06/06 17:38:10 henning Exp $ */
d225 1
a225 1
		TAILQ_REMOVE(&net_l, net, network_l);
d230 1
a230 1
		TAILQ_REMOVE(rules_l, r, entries);
d403 1
a403 1
		TAILQ_REMOVE(&net_l, n, network_l);
d410 1
a410 1
		TAILQ_REMOVE(rules_l, r, entries);
@


1.95
log
@rework bgpd's handling of listening sockets. instead of one for each
supported address familiy, keep a tailq of an arbitary number of them.
the new struct listen_addr contains the sockaddr and the fd.
this fixes quite some nasty behaviour which was a consequence of the previous
model.
looks right deraadt@@, and discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.94 2004/05/21 11:48:56 claudio Exp $ */
d179 2
a180 2
	if (pipe(pipe_m2s) == -1)
		fatal("pipe");
d184 2
a185 2
	if (pipe(pipe_m2r) == -1)
		fatal("pipe");
d189 2
a190 2
	if (pipe(pipe_s2r) == -1)
		fatal("pipe");
d195 2
d387 2
d414 1
a414 1
		if (imsg_compose(&ibuf_se, IMSG_RECONF_LISTENER, 0,
@


1.94
log
@Add support for dynamic announcements. Usefule to annouce temporary
blackhole routes or to make network announcements dependent on a external
state (e.g. for carp setups) OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.93 2004/05/07 10:06:15 djm Exp $ */
d103 1
d232 5
d377 1
d409 10
@


1.93
log
@add a filter option to dump prefixes learned in UPDATEs into a PF table,
intended for building realtime BGP blacklists (e.g. with spamd);
ok claudio & henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.92 2004/05/03 04:44:41 henning Exp $ */
d389 1
a389 1
		if (imsg_compose(&ibuf_rde, IMSG_RECONF_NETWORK, 0,
@


1.92
log
@little KNF issue
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.91 2004/04/29 19:56:04 deraadt Exp $ */
d218 2
d331 1
d467 29
@


1.91
log
@sock -> fd; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.90 2004/04/27 04:38:12 deraadt Exp $ */
d462 2
a463 1
				else kr_nexthop_delete(imsg.data);
@


1.90
log
@crud stripping; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.89 2004/04/25 17:34:39 claudio Exp $ */
d230 1
a230 1
		pfd[PFD_PIPE_SESSION].fd = ibuf_se.sock;
d234 1
a234 1
		pfd[PFD_PIPE_ROUTE].fd = ibuf_rde.sock;
@


1.89
log
@Remove the no longer needed configure stuff in RDE. The peer list needs no
longer to be synced between parent, SE and RDE. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.88 2004/03/16 12:06:43 henning Exp $ */
d107 1
a107 1
	int			 ch, i, j, n, nfds, timeout;
d250 1
a250 1
			if ((n = msgbuf_write(&ibuf_se.w)) < 0) {
d256 1
a256 1
			if ((n = msgbuf_write(&ibuf_rde.w)) < 0) {
d283 1
a283 1
				if ((n = mrt_write(mrt[j])) < 0) {
@


1.88
log
@delay creating the control socket until after forking, but before chroot
(lives in /var/run, i. e. outside chroot) and privdrop.
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.87 2004/03/12 16:21:34 henning Exp $ */
d195 1
a195 2
	rde_pid = rde_main(&conf, peer_l, &net_l, rules_l, &mrt_l,
	    pipe_m2r, pipe_s2r);
d381 1
a381 1
	for (p = *peer_l; p != NULL; p = p->next) {
a384 4
		if (imsg_compose(&ibuf_rde, IMSG_RECONF_PEER, p->conf.id,
		    &p->conf, sizeof(struct peer_config)) == -1)
			return (-1);
	}
@


1.87
log
@fix the "wait for child processes to terminate" code, and move it down a bit
millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.86 2004/03/11 14:22:22 claudio Exp $ */
d107 1
a107 1
	int			 ch, csock, i, j, n, nfds, timeout;
a193 3
	if ((csock = control_init()) == -1)
		fatalx("control socket setup failed");

a212 1
	close(csock);
@


1.86
log
@Shutdown the RDE cleanly on exit. Plug some memleaks. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.85 2004/03/11 13:35:05 claudio Exp $ */
a321 4
	do {
		pid = waitpid(-1, NULL, WNOHANG);
	} while (pid > 0 || (pid == -1 && errno == EINTR));

d334 6
@


1.85
log
@Free unneeded mrt lists in SE and on exit. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.84 2004/03/10 15:15:48 henning Exp $ */
d198 2
a199 1
	rde_pid = rde_main(&conf, peer_l, &net_l, rules_l, pipe_m2r, pipe_s2r);
@


1.84
log
@pass a pointer to the network list as well to session_main so we can free()
the members after fork
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.83 2004/03/10 14:45:24 henning Exp $ */
d102 1
a102 1
	struct mrt		*(mrt[POLL_MAX]);
d199 2
a200 2
	io_pid = session_main(&conf, peer_l, &net_l, rules_l, pipe_m2s,
	    pipe_s2r);
d328 4
@


1.83
log
@pass a pointer to the filter rule list to session_main() so we can free()
the list entries and the head there after forking
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.82 2004/03/10 13:48:45 henning Exp $ */
d199 2
a200 1
	io_pid = session_main(&conf, peer_l, rules_l, pipe_m2s, pipe_s2r);
@


1.82
log
@free peer list on exit, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.81 2004/03/01 16:53:48 claudio Exp $ */
d199 1
a199 1
	io_pid = session_main(&conf, peer_l, pipe_m2s, pipe_s2r);
@


1.81
log
@Arrrg. Not my day. Sync printconfig with parser here too.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.80 2004/02/19 13:54:58 claudio Exp $ */
d96 1
a96 1
	struct peer		*peer_l;
d323 5
@


1.80
log
@Make the code more portable. Add some missing header files and make the use
of the queue(3) makros more portable. OK henning@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.79 2004/02/09 23:16:46 henning Exp $ */
d158 1
a158 1
			print_config(&conf, &net_l, peer_l, rules_l);
@


1.79
log
@print networks too
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.78 2004/02/09 23:10:04 henning Exp $ */
d381 1
a381 2
	for (n = TAILQ_FIRST(&net_l); n != TAILQ_END(&net_l);
	    n = TAILQ_FIRST(&net_l)) {
d388 1
a388 1
	for (r = TAILQ_FIRST(rules_l); r != NULL; r = TAILQ_FIRST(rules_l)) {
@


1.78
log
@drain the list fluffier
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.77 2004/02/09 01:38:55 henning Exp $ */
d158 1
a158 1
			print_config(&conf, peer_l, rules_l);
a524 2


@


1.77
log
@print more fluff
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.76 2004/02/09 00:00:41 henning Exp $ */
d222 1
a222 2
	for (net = TAILQ_FIRST(&net_l); net != TAILQ_END(&net_l);
	    net = TAILQ_FIRST(&net_l)) {
@


1.76
log
@move printing the config to where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.75 2004/02/07 11:42:30 henning Exp $ */
d158 1
a158 2
			TAILQ_FOREACH(r, rules_l, entries)
				print_rule(peer_l, r);
@


1.75
log
@send filter rules to the RDE on reloads, help & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.74 2004/02/06 20:18:18 henning Exp $ */
d157 5
a161 1
		fprintf(stderr, "configuration OK\n");
@


1.74
log
@initial cut at the filtering language.
structs etc to describe a rule, filter rule list management
parser groks filter defs now.

claudio ok, discussion & help also jakob theo
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.73 2004/02/03 17:36:30 henning Exp $ */
d99 1
a99 1
	struct filter_head	 rules_l;
d117 3
d123 1
a123 1
	TAILQ_INIT(&rules_l);
d153 1
a153 1
	if (parse_config(conffile, &conf, &mrt_l, &peer_l, &net_l, &rules_l))
d195 1
a195 1
	rde_pid = rde_main(&conf, peer_l, &net_l, pipe_m2r, pipe_s2r);
d225 2
a226 2
	for (r = TAILQ_FIRST(&rules_l); r != NULL; r = TAILQ_FIRST(&rules_l)) {
		TAILQ_REMOVE(&rules_l, r, entries);
d292 1
a292 1
			reconfigure(conffile, &conf, &mrt_l, &peer_l, &rules_l);
d322 1
d388 3
a390 1
		/* XXX imsg_compose... */
@


1.73
log
@defer free()ing the previous peer list until after parsing the config file
so in the parser we can access it. will be needed soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.72 2004/01/23 21:18:12 henning Exp $ */
d44 1
a44 1
	    struct peer **);
d99 1
d101 1
d120 1
d150 1
a150 1
	if (parse_config(conffile, &conf, &mrt_l, &peer_l, &net_l))
d222 5
d289 1
a289 1
			reconfigure(conffile, &conf, &mrt_l, &peer_l);
d348 1
a348 1
    struct peer **peer_l)
d353 1
d355 1
a355 1
	if (parse_config(conffile, conf, mrt_l, peer_l, &net_l)) {
d382 5
@


1.72
log
@use log_addr
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.71 2004/01/22 20:34:55 henning Exp $ */
d44 1
a44 1
	    struct peer *);
d96 1
a96 1
	struct peer		*peer_l, *p, *next;
a212 4
	for (p = peer_l; p != NULL; p = next) {
		next = p->next;
		free(p);
	}
d281 1
a281 1
			reconfigure(conffile, &conf, &mrt_l, peer_l);
d340 1
a340 1
    struct peer *peer_l)
d344 1
a344 1
	struct peer		*p, *next;
d346 1
a346 1
	if (parse_config(conffile, conf, mrt_l, &peer_l, &net_l)) {
d358 1
a358 2
	for (p = peer_l; p != NULL; p = next) {
		next = p->next;
a364 1
		free(p);
@


1.71
log
@use log_warnx and log_info. reclassify a few messages in the process and fix
a few messages.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.70 2004/01/22 03:18:03 henning Exp $ */
d483 1
a483 1
	char	*gw = NULL, *nh = NULL;
d485 1
a485 1
	if (msg->gateway.af == AF_INET)
d487 1
a487 1
		    log_ntoa(msg->gateway.v4.s_addr)) == -1) {
d492 1
a492 4
	if (msg->nexthop.af == AF_INET)
		nh = log_ntoa(msg->nexthop.v4.s_addr);

	log_info("nexthop %s now %s%s%s", nh,
@


1.70
log
@s/log_err/log_warn/
it is like warn(3), nor err(3). so use a less confusing name.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.69 2004/01/20 09:44:33 henning Exp $ */
d127 1
a127 2
				logit(LOG_CRIT,
				    "could not parse macro definition %s",
d167 1
a167 1
	logit(LOG_INFO, "startup");
d284 1
a284 1
			logit(LOG_CRIT, "rereading config");
d318 1
a318 1
	logit(LOG_CRIT, "Terminating");
d329 1
a329 1
			logit(LOG_CRIT, "Lost child: %s exited", pname);
d333 1
a333 1
			logit(LOG_CRIT, "Lost child: %s terminated; signal %d",
d351 1
a351 1
		logit(LOG_CRIT, "config file %s has errors, not reloading",
d397 1
a397 1
		logit(LOG_CRIT, "dispatch_imsg in main: pipe closed");
d412 1
a412 1
				logit(LOG_CRIT, "mrt_queue failed.");
d416 1
a416 1
				logit(LOG_CRIT, "route request not from RDE");
d422 1
a422 1
				logit(LOG_CRIT, "route request not from RDE");
d428 1
a428 1
				logit(LOG_CRIT, "nexthop request not from RDE");
d432 1
a432 1
					logit(LOG_CRIT, "wrong imsg len");
d438 1
a438 1
				logit(LOG_CRIT, "nexthop request not from RDE");
d442 1
a442 1
					logit(LOG_CRIT, "wrong imsg len");
d447 1
a447 1
				logit(LOG_CRIT, "reload request not from SE");
d453 1
a453 1
				logit(LOG_CRIT, "couple request not from SE");
d459 1
a459 1
				logit(LOG_CRIT, "decouple request not from SE");
d468 1
a468 1
				logit(LOG_CRIT, "kroute request not from SE");
d495 1
a495 1
	logit(LOG_INFO, "nexthop %s now %s%s%s", nh,
@


1.69
log
@check early wether user _bgpd exists so we can bail out early and nicely
prodded by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.68 2004/01/17 19:35:35 claudio Exp $ */
d240 1
a240 1
				log_err("poll error");
d246 1
a246 1
				log_err("pipe write error (to SE)");
d252 1
a252 1
				log_err("pipe write error (to RDE)");
d279 1
a279 1
					log_err("mrt write error");
d489 1
a489 1
			log_err("send_nexthop_update");
@


1.68
log
@Make it possible to announce own networks. In the RDE these prefixes are
attached to a pseudo peer and inserted like all other prefixes into the RIB.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.67 2004/01/17 18:05:46 henning Exp $ */
d28 1
d158 4
@


1.67
log
@allow the interfaces as bgpd sees 'em to be queried via imsgs
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.66 2004/01/11 22:01:13 henning Exp $ */
d96 3
a98 1
	struct mrt_head		 mrtconf;
d115 2
a116 1
	LIST_INIT(&mrtconf);
d147 1
a147 1
	if (parse_config(conffile, &conf, &mrtconf, &peer_l))
d185 1
a185 1
	rde_pid = rde_main(&conf, peer_l, pipe_m2r, pipe_s2r);
d213 5
d231 1
a231 1
		i = mrt_select(&mrtconf, pfd, mrt, i, POLL_MAX, &timeout);
d254 1
a254 1
			    &mrtconf) == -1)
d261 1
a261 1
			    &mrtconf) == -1)
d281 1
a281 1
			reconfigure(conffile, &conf, &mrtconf, peer_l);
d294 1
a294 1
			mrt_handler(&mrtconf);
d339 1
a339 1
reconfigure(char *conffile, struct bgpd_config *conf, struct mrt_head *mrtc,
d342 2
d346 1
a346 1
	if (parse_config(conffile, conf, mrtc, &peer_l)) {
d368 8
d384 1
a384 1
dispatch_imsg(struct imsgbuf *ibuf, int idx, struct mrt_head *mrtc)
d407 1
a407 1
			if (mrt_queue(mrtc, &imsg) == -1)
@


1.66
log
@use bgpd_addr in the nexthop tree; change nexthop_add/_remove accordingly

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.64 2004/01/11 19:14:43 henning Exp $ */
d444 1
@


1.65
log
@in the nexthop imsgs use struct bgpd_addr for the data part instead of
in_addr_t

ok claudio@@
@
text
@d411 1
a411 3
				else if (kr_nexthop_add(
				    ((struct bgpd_addr *)imsg.data)->v4.s_addr)
				    == -1)
d421 1
a421 2
				else kr_nexthop_delete(
				    ((struct bgpd_addr *)imsg.data)->v4.s_addr);
@


1.64
log
@use struct bgpd_addr for nexthop and gateway in struct kroute_nexthop
(and thus the nexthop messages between parent and RDE)

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.63 2004/01/11 02:35:13 henning Exp $ */
d368 2
a369 3
	struct imsg	 imsg;
	int		 n;
	in_addr_t	 ina;
d407 7
a413 3
			else {
				memcpy(&ina, imsg.data, sizeof(ina));
				if (kr_nexthop_add(ina) == -1)
a414 1
			}
d419 6
a424 4
			else {
				memcpy(&ina, imsg.data, sizeof(ina));
				kr_nexthop_delete(ina);
			}
@


1.63
log
@new message IMSG_CTL_SHOW_NEXTHOP: request/send lost of BGP nexthops and
the result of their validity check
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.62 2004/01/11 01:00:07 claudio Exp $ */
d459 1
a459 1
	char	*gw = NULL;
d461 3
a463 2
	if (msg->gateway)
		if (asprintf(&gw, ": via %s", log_ntoa(msg->gateway)) == -1) {
d468 4
a471 1
	logit(LOG_INFO, "nexthop %s now %s%s%s", log_ntoa(msg->nexthop),
d474 1
a474 1
	    msg->gateway ? gw : "");
@


1.62
log
@The buffer changes produced some fallout in the mrt code.
Wait until all data has been written out before closing the file and fix
some obvious misstakes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.61 2004/01/09 19:08:50 henning Exp $ */
d442 1
@


1.61
log
@for IMSG_CTL_KROUTEs allow matching based on flags,
add IMGS_CTL_KROUTE_ADDR to match the route for a given address

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.60 2004/01/09 13:47:07 henning Exp $ */
d265 1
a265 1
				if ((n = mrt_write(mrt[i])) < 0) {
@


1.60
log
@get us a stateful imsg relaying framework, and the first receiver,
IMSG_CTL_KROUTE, to have the kroute structs forming the fib sent to a
control socket.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.59 2004/01/08 16:17:12 henning Exp $ */
d441 1
d445 1
a445 1
				kr_show_route(imsg.hdr.pid);
@


1.59
log
@rename a few functions to further clarify things
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.58 2004/01/06 03:43:50 henning Exp $ */
d440 6
d476 8
@


1.58
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.57 2004/01/05 22:57:59 claudio Exp $ */
d203 1
a203 1
	if ((rfd = kroute_init(!(conf.flags & BGPD_FLAG_NO_FIB_UPDATE))) == -1)
d259 1
a259 1
			if (kroute_dispatch_msg() == -1)
d304 1
a304 1
	kroute_shutdown();
d396 1
a396 1
			else if (kroute_change(imsg.data))
d402 1
a402 1
			else if (kroute_delete(imsg.data))
d410 1
a410 1
				if (kroute_nexthop_add(ina) == -1)
d419 1
a419 1
				kroute_nexthop_delete(ina);
d432 1
a432 1
				kroute_fib_couple();
d438 1
a438 1
				kroute_fib_decouple();
@


1.57
log
@Big overhaul of the mrt code.
Dumping of incomming bgp messages is now possible and dumping the (not yet)
filtered updates works too. Per neighbor dumps are still missing.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.56 2004/01/05 19:10:24 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.56
log
@correctly handle SIGCHLD.
SIGCHLD does _not_ translate to "a child process went kaboom".
waitpid() and check status; if the child exited or terminated log & quit

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.55 2004/01/05 18:21:51 henning Exp $ */
d42 1
a42 1
int	reconfigure(char *, struct bgpd_config *, struct mrt_config *,
d44 1
a44 1
int	dispatch_imsg(struct imsgbuf *, int, struct mrt_config *);
a45 1
int			mrtfd = -1;
d69 1
a71 3
	case SIGUSR1:
		mrtdump = 2;
		break;
d96 2
a97 2
	struct mrt_config	 mrtconf;
	struct mrtdump_config	*mconf, *(mrt[POLL_MAX]);
d102 1
a102 1
	int			 ch, i, j, n, nfds, csock;
a112 1
	bzero(&mrtconf, sizeof(mrtconf));
d202 1
d223 1
a223 6
		LIST_FOREACH(mconf, &mrtconf, list)
			if (mconf->msgbuf.queued > 0) {
				pfd[i].fd = mconf->msgbuf.sock;
				pfd[i].events |= POLLOUT;
				mrt[i++] = mconf;
			}
d265 2
a266 3
				if ((n = msgbuf_write(&mrt[i]->msgbuf)) < 0) {
					log_err("pipe write error (MRT)");
					quit = 1;
a273 2
			LIST_FOREACH(mconf, &mrtconf, list)
				mrt_state(mconf, IMSG_NONE, &ibuf_rde);
d286 1
a286 4
			mrt_alrm(&mrtconf, &ibuf_rde);
			mrtdump = 0;
		} else if (mrtdump == 2) {
			mrt_usr1(&mrtconf, &ibuf_rde);
d331 1
a331 1
reconfigure(char *conffile, struct bgpd_config *conf, struct mrt_config *mrtc,
a364 3
/*
 * XXX currently messages are only buffered for mrt files.
 */
d366 1
a366 1
dispatch_imsg(struct imsgbuf *ibuf, int idx, struct mrt_config *conf)
d368 3
a370 6
	struct imsg		 imsg;
	struct buf		*wbuf;
	struct mrtdump_config	*m;
	ssize_t			 len;
	int			 n;
	in_addr_t		 ina;
d390 2
a391 21
			LIST_FOREACH(m, conf, list) {
				if (m->id != imsg.hdr.peerid)
					continue;
				if (mrt_state(m, imsg.hdr.type, ibuf) == 0)
					break;
				if (m->msgbuf.sock == -1)
					break;
				len = imsg.hdr.len - IMSG_HEADER_SIZE;
				wbuf = buf_open(len);
				if (wbuf == NULL)
					return (-1);
				if (buf_add(wbuf, imsg.data, len) == -1) {
					buf_free(wbuf);
					return (-1);
				}
				if ((n = buf_close(&m->msgbuf, wbuf)) < 0) {
					buf_free(wbuf);
					return (-1);
				}
				break;
			}
@


1.55
log
@waitpid's return is a pid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.54 2004/01/05 16:21:14 henning Exp $ */
d41 1
d51 1
d61 2
d64 1
a64 1
		quit = 1;
d288 8
d321 20
@


1.54
log
@allow fib couple/decouple based on an imsg received on the control socket
by the SE and passed on to the main process
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.53 2004/01/04 19:39:46 henning Exp $ */
d98 1
a98 1
	pid_t			 io_pid = 0, rde_pid = 0;
d302 2
a303 2
		i = waitpid(-1, NULL, WNOHANG);
	} while (i > 0 || (i == -1 && errno == EINTR));
@


1.53
log
@-new imsg CTL_RELOAD
-upong receival in the SE forward to parent
-make sending messages from SE to parent work for that (was not required before)
-parent reacts to that just like a SIGHUP, reread config file
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.52 2004/01/03 20:37:34 henning Exp $ */
d434 12
@


1.52
log
@move some session specific stuff to session.h and make the few files
that need it include that
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.51 2004/01/03 20:22:07 henning Exp $ */
d428 6
@


1.51
log
@decouple the peer list from bgpd_config.
so many parts of bgpd are not at all interested in the session specific peer
structs... allows for some further cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.50 2004/01/03 14:06:35 henning Exp $ */
d36 1
d94 1
a94 1
	struct peer		*peers, *p, *next;
d114 1
a114 1
	peers = NULL;
d144 1
a144 1
	if (parse_config(conffile, &conf, &mrtconf, &peers))
d182 2
a183 2
	rde_pid = rde_main(&conf, peers, pipe_m2r, pipe_s2r);
	io_pid = session_main(&conf, peers, pipe_m2s, pipe_s2r);
d205 1
a205 1
	for (p = peers; p != NULL; p = next) {
d278 1
a278 1
			reconfigure(conffile, &conf, &mrtconf, peers);
d314 1
a314 1
    struct peer *peers)
d318 1
a318 1
	if (parse_config(conffile, conf, mrtc, &peers)) {
d330 1
a330 1
	for (p = peers; p != NULL; p = next) {
@


1.50
log
@change imsg_read semantics so that the number of bytes read is returned.
that means that the callers can (and must) coope with closed connections
themselves, what is exactly the desired behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.49 2004/01/01 23:46:47 henning Exp $ */
d40 2
a41 1
int	reconfigure(char *, struct bgpd_config *, struct mrt_config *);
d93 1
d113 1
d143 1
a143 1
	if (parse_config(conffile, &conf, &mrtconf))
d181 2
a182 2
	rde_pid = rde_main(&conf, pipe_m2r, pipe_s2r);
	io_pid = session_main(&conf, pipe_m2s, pipe_s2r);
d204 5
d277 1
a277 1
			reconfigure(conffile, &conf, &mrtconf);
d312 2
a313 1
reconfigure(char *conffile, struct bgpd_config *conf, struct mrt_config *mrtc)
d315 1
a315 1
	struct peer		*p;
d317 1
a317 1
	if (parse_config(conffile, conf, mrtc)) {
d329 2
a330 1
	for (p = conf->peers; p != NULL; p = p->next) {
d337 1
@


1.49
log
@listen on a AF_LOCAL socket for imsgs too.
only implemented type yet is IMSG_CTL_SHOW_NEIGHBOR which sends back
the struct peer for all neighbors.
will be used by bgpdctl
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.48 2004/01/01 23:09:08 henning Exp $ */
d348 1
a348 1
	if (imsg_read(ibuf) == -1)
d350 5
@


1.48
log
@now that imsg_get uses bigger buffers, one read call can put more than one
imsg into the buffer. since imsg_get by definition only returns one imsg we
missed the next imsg(s) until the next poll event on the socket in question,
building up a queue on that socket. didn't show up as a problem yet...
factor out imsg_read, which reads into the buffer. imsg_get now entirely
operates on the buffers and does not read(2) itself.
make all callers cope by calling imsg_read on poll events and calling
imsg_get in a loop until all imsgs are processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.47 2003/12/30 22:42:31 henning Exp $ */
d98 1
a98 1
	int			 ch, i, j, n, nfds;
d174 3
d194 1
d296 1
@


1.47
log
@correctly free after buf_add/_close errs.
From: Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.46 2003/12/30 20:59:43 henning Exp $ */
d343 1
a343 1
	if ((n = imsg_get(ibuf, &imsg)) == -1)
d346 7
a352 1
	if (n > 0) {
@


1.46
log
@missing free()s in error cases that (now) lead to program termination
From: Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.45 2003/12/27 14:58:22 henning Exp $ */
d362 1
a362 1
					free(wbuf);
d366 1
a366 1
					free(wbuf);
@


1.45
log
@move the fib couple/decouple to the config merge where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.44 2003/12/27 14:24:42 henning Exp $ */
d361 2
a362 1
				if (buf_add(wbuf, imsg.data, len) == -1)
d364 3
a366 1
				if ((n = buf_close(&m->msgbuf, wbuf)) < 0)
d368 1
@


1.44
log
@keep a copy of the fd locally instead of passing it around all time
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.43 2003/12/27 01:31:49 henning Exp $ */
a301 1
	int			 fib_synced;
a302 1
	fib_synced = ! (conf->flags & BGPD_FLAG_NO_FIB_UPDATE);
a306 6
	}
	if (fib_synced != !(conf->flags & BGPD_FLAG_NO_FIB_UPDATE)) {
		if (!(conf->flags & BGPD_FLAG_NO_FIB_UPDATE))
			kroute_fib_couple();
		else
			kroute_fib_decouple();
@


1.43
log
@on reconfigure, check wether the "no fib-update" statement presence/absence
changed.
if it is absent but was present before, call kroute_fib_couple
if it is present but was absent before, call kroute_fib_decouple
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.42 2003/12/27 00:53:51 henning Exp $ */
d250 1
a250 1
			if (kroute_dispatch_msg(rfd) == -1)
d292 1
a292 1
	kroute_shutdown(rfd);
d312 1
a312 1
			kroute_fib_couple(rfd);
d314 1
a314 1
			kroute_fib_decouple(rfd);
d379 1
a379 1
			else if (kroute_change(rfd, imsg.data))
d385 1
a385 1
			else if (kroute_delete(rfd, imsg.data))
@


1.42
log
@implement "no fib-update" much cooler
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.41 2003/12/26 21:40:40 henning Exp $ */
d302 1
d304 1
d310 7
@


1.41
log
@erm, oups, well, put back rde_pid and io_pid assignments that got lost
somehow...
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.40 2003/12/26 20:59:54 henning Exp $ */
d194 1
a194 1
	if ((rfd = kroute_init()) == -1)
@


1.40
log
@fix logging in send_nexthop_update
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.39 2003/12/26 18:33:11 henning Exp $ */
d175 2
a176 2
	rde_main(&conf, pipe_m2r, pipe_s2r);
	session_main(&conf, pipe_m2s, pipe_s2r);
@


1.39
log
@let imsg_get and imsg_compose not fatal() but return errors upstream.
make the callers cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.38 2003/12/26 18:07:32 henning Exp $ */
d407 9
a415 1
	logit(LOG_INFO, "nexthop %s now %s%s%s%s", log_ntoa(msg->nexthop),
d418 3
a420 2
	    msg->gateway ? ": via " : "",
	    msg->gateway ? log_ntoa(msg->gateway) : "");
@


1.38
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.37 2003/12/26 17:47:04 henning Exp $ */
d308 6
a313 4
	imsg_compose(&ibuf_se, IMSG_RECONF_CONF, 0,
	    conf, sizeof(struct bgpd_config));
	imsg_compose(&ibuf_rde, IMSG_RECONF_CONF, 0,
	    conf, sizeof(struct bgpd_config));
d315 6
a320 4
		imsg_compose(&ibuf_se, IMSG_RECONF_PEER, p->conf.id,
		    &p->conf, sizeof(struct peer_config));
		imsg_compose(&ibuf_rde, IMSG_RECONF_PEER, p->conf.id,
		    &p->conf, sizeof(struct peer_config));
d322 3
a324 2
	imsg_compose(&ibuf_se, IMSG_RECONF_DONE, 0, NULL, 0);
	imsg_compose(&ibuf_rde, IMSG_RECONF_DONE, 0, NULL, 0);
d342 4
a345 1
	if (imsg_get(ibuf, &imsg) > 0) {
d413 3
a415 2
	imsg_compose(&ibuf_rde, IMSG_NEXTHOP_UPDATE, 0,
	    msg, sizeof(struct kroute_nexthop));
@


1.37
log
@by making kroute_dispatch_msg() and kroute_nexthop_add() return int instead
of void they can now report errors upstream and do not need to panic any
more. so do that and handle the errors in bgpd.c in the vein that we at least
can clean up before exit.
there are no direct fatal() call in kroute.c now any more, nor any in bgpd.c
after forking.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.36 2003/12/26 17:15:09 henning Exp $ */
d159 1
a159 1
		fatal("pipe", errno);
d162 1
a162 1
		fatal("fcntl", errno);
d164 1
a164 1
		fatal("pipe", errno);
d167 1
a167 1
		fatal("fcntl", errno);
d169 1
a169 1
		fatal("pipe", errno);
d172 1
a172 1
		fatal("fcntl", errno);
@


1.36
log
@overhaul error handling
try to handle as much as possbile in a graceful way so taht we don't leave
the kernel routing table full of our routes, for example.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.35 2003/12/26 16:54:10 henning Exp $ */
d250 2
a251 1
			kroute_dispatch_msg(rfd);
d376 2
a377 1
				kroute_nexthop_add(ina);
@


1.35
log
@handle kroute_init failures nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.34 2003/12/26 14:55:03 henning Exp $ */
d174 3
a176 5
	if ((rde_pid = rde_main(&conf, pipe_m2r, pipe_s2r)) < 0)
		fatal("could not start route decision engine", 0);

	if ((io_pid = session_main(&conf, pipe_m2s, pipe_s2r)) < 0)
		fatal("could not start session engine", 0);
d217 4
a220 2
			if (errno != EINTR)
				fatal("poll error", errno);
d223 4
a226 2
			if ((n = msgbuf_write(&ibuf_se.w)) < 0)
				fatal("pipe write error", errno);
d229 4
a232 2
			if ((n = msgbuf_write(&ibuf_rde.w)) < 0)
				fatal("pipe write error", errno);
d236 3
a238 1
			dispatch_imsg(&ibuf_se, PFD_PIPE_SESSION, &mrtconf);
d243 3
a245 1
			dispatch_imsg(&ibuf_rde, PFD_PIPE_ROUTE, &mrtconf);
d255 4
a258 2
				if ((n = msgbuf_write(&mrt[i]->msgbuf)) < 0)
					fatal("pipe write error", errno);
d350 1
a350 1
					fatal("buf_open error", 0);
d352 1
a352 1
					fatal("buf_add error", 0);
d354 1
a354 1
					fatal("buf_close error", 0);
d360 3
a362 3
				fatal("route request not from RDE", 0);
			if (kroute_change(rfd, imsg.data))
				fatal("kroute_change error", errno);
d366 3
a368 3
				fatal("route request not from RDE", 0);
			if (kroute_delete(rfd, imsg.data))
				fatal("kroute_delete error", errno);
d372 5
a376 3
				fatal("nexthop request not from RDE", 0);
			memcpy(&ina, imsg.data, sizeof(ina));
			kroute_nexthop_add(ina);
d380 5
a384 3
				fatal("nexthop request not from RDE", 0);
			memcpy(&ina, imsg.data, sizeof(ina));
			kroute_nexthop_delete(ina);
@


1.34
log
@improve log message
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.33 2003/12/26 14:38:58 henning Exp $ */
d196 2
a197 1
	rfd = kroute_init();
@


1.33
log
@log nexthop status changes
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.32 2003/12/26 00:49:52 henning Exp $ */
d384 2
a385 2
	    msg->connected ? ", connected" : "",
	    msg->gateway ? ", via " : "",
@


1.32
log
@handle IMSG_NEXTHOP_DELETE as well
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.31 2003/12/26 00:27:23 henning Exp $ */
d382 6
@


1.31
log
@kroute_nexthop_check -> kroute_nexthop_add
kroute_validate_nexthop -> kroute_nexthop_insert
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.30 2003/12/26 00:14:04 henning Exp $ */
d369 1
a369 2
			/* XXX */
			/* kroute_nexthop_delete(ina); */
@


1.30
log
@finally marry rde and kroute parts of the nexthop verification:
handle IMSG_NEXTHOP_ADD and send IMSG_NEXTHOP_UPDATE when appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.29 2003/12/25 17:07:24 henning Exp $ */
d363 1
a363 1
			kroute_nexthop_check(ina);
@


1.29
log
@track routing table changes that are _not_ caused by bgpd itself

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.28 2003/12/25 02:24:26 henning Exp $ */
d323 1
d359 13
d380 6
@


1.28
log
@kill IMSG_KROUTE_ADD as well. just send KROUTE_CHANGE requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.27 2003/12/25 02:09:19 henning Exp $ */
d85 2
a86 1
#define PFD_MRT_START		2
d207 2
d217 1
a217 1
		if ((nfds = poll(pfd, 2, INFTIM)) == -1)
d237 5
@


1.27
log
@it actually makes more sense to call the merged function kroute_change
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.26 2003/12/25 02:04:46 henning Exp $ */
a337 6
		case IMSG_KROUTE_ADD:
			if (idx != PFD_PIPE_ROUTE)
				fatal("route request not from RDE", 0);
			if (kroute_change(rfd, imsg.data))
				fatal("kroute_add error", errno);
			break;
d343 1
@


1.26
log
@kroute_change is obsolete, long live kroute_add
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.25 2003/12/24 20:09:56 henning Exp $ */
d341 1
a341 1
			if (kroute_add(rfd, imsg.data))
d347 1
a347 1
			if (kroute_add(rfd, imsg.data))
@


1.25
log
@now that the main process can cleanup without RDE's help, we do not need the
somewhat fragile IMSG_SHUTDOWN_* stuff any more. speeds shutdown up
enourmously.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.24 2003/12/24 19:59:24 henning Exp $ */
d347 1
a347 1
			if (kroute_change(rfd, imsg.data))
@


1.24
log
@now that we keep track of the routes we added to the kernel we can remove
them easily on shutdown without the RDE's help
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.23 2003/12/24 19:22:00 henning Exp $ */
a49 5
int			se_done = 0;
int			rde_done = 0;

#define QUIT_REQUESTED		1
#define QUIT_INPROGRESS		2
d58 1
a58 1
		quit = QUIT_REQUESTED;
d197 1
a197 1
	while (quit != QUIT_INPROGRESS || se_done == 0 || rde_done == 0) {
a250 8
		if (quit == QUIT_REQUESTED) {
			imsg_compose(&ibuf_se, IMSG_SHUTDOWN_REQUEST, 0,
			    NULL, 0);
			imsg_compose(&ibuf_rde, IMSG_SHUTDOWN_REQUEST, 0,
			    NULL, 0);
			quit = QUIT_INPROGRESS;
		}

a353 6
			break;
		case IMSG_SHUTDOWN_DONE:
			if (idx == PFD_PIPE_ROUTE)
				rde_done = 1;
			else
				se_done = 1;
@


1.23
log
@slightly more helpfull error msgs
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.22 2003/12/24 13:28:01 henning Exp $ */
d284 2
@


1.22
log
@handle write() returning 0 correctly, adjust the msgbuf API appropriately,
and make all callers cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.21 2003/12/23 19:14:49 deraadt Exp $ */
d353 1
a353 1
				fatal("kroute bytes left", 0);
d359 1
a359 1
				fatal("kroute bytes left", 0);
d364 1
a364 1
				fatal("kroute bytes left", 0);
@


1.21
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.20 2003/12/23 18:28:05 henning Exp $ */
d224 1
a224 1
			if ((n = msgbuf_write(&ibuf_se.w)) == -1)
d228 1
a228 1
			if ((n = msgbuf_write(&ibuf_rde.w)) == -1)
d243 1
a243 1
				if ((n = msgbuf_write(&mrt[i]->msgbuf)) == -1)
d344 1
a344 1
				if ((n = buf_close(&m->msgbuf, wbuf)) == -1)
@


1.20
log
@send shutdown requests to the child processes and wait for a ackmessage from
them when shutting down.
the rde needs the main process to clean up the routing table on exit so the
parent process needs to be in service until the RDE is done.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.19 2003/12/22 21:48:23 henning Exp $ */
d241 1
a241 1
		for (j =  PFD_MRT_START; j < i && nfds > 0 ; j++) {
@


1.19
log
@delay setting up the signal handlers in the main process until after fork(),
pointed out by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.18 2003/12/22 15:22:13 henning Exp $ */
d50 5
d63 1
a63 1
		quit = 1;
d202 1
a202 1
	while (quit == 0) {
d256 8
d365 6
@


1.18
log
@o add low-level functions for adding/chaining/removing kernel routes
o define new imsg types for this
o process these imsgs in the parent process

now "only" debugging and the rde sending these messages is missing.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.17 2003/12/22 15:11:45 henning Exp $ */
a149 7
	signal(SIGTERM, sighdlr);
	signal(SIGINT, sighdlr);
	signal(SIGCHLD, sighdlr);
	signal(SIGHUP, sighdlr);
	signal(SIGALRM, sighdlr);
	signal(SIGUSR1, sighdlr);

d180 7
@


1.17
log
@uid check later; configtest is useful as non-root
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.16 2003/12/22 15:07:05 henning Exp $ */
d44 1
d195 1
d335 17
@


1.16
log
@add a configtest mode
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.15 2003/12/22 11:11:25 miod Exp $ */
a105 3
	if (geteuid())
		errx(1, "need root privileges");

d139 1
a139 1
		exit (1);
d145 3
@


1.15
log
@No need to setup a signal handler for SIGKILL as you can't catch it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.14 2003/12/22 11:04:12 henning Exp $ */
d76 1
a76 1
	fprintf(stderr, "usage: %s [-dv] ", __progname);
d113 1
a113 1
	while ((ch = getopt(argc, argv, "dD:f:v")) != -1) {
d127 3
d143 5
@


1.14
log
@in the same vein we can plain errx() if the geteuid check fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.13 2003/12/22 11:00:19 henning Exp $ */
a54 1
	case SIGKILL:
a141 1
	signal(SIGKILL, sighdlr);
@


1.13
log
@when starting up and the configuration has errors, do not call fatal().
plain exit() is enough. we have not yet forked and an error message is already
printed by the parser.
inspired by a theo request
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.12 2003/12/21 23:28:39 henning Exp $ */
d108 1
a108 1
		fatal("need root privileges", 0);
@


1.12
log
@rename get_imsg() to imsg_get(); that's more consistent
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.11 2003/12/21 23:26:37 henning Exp $ */
d140 1
a140 1
		fatal("config file has errors", 0);
@


1.11
log
@wrap read & write buffers for imsgs into a struct.
finally gives us read buffers per pipe instead of per process, eleminating
a possible race.
also gets us a real imsg_init() that does all the boring init work
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.10 2003/12/21 22:16:53 henning Exp $ */
d306 1
a306 1
	if (get_imsg(ibuf, &imsg) > 0) {
@


1.10
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.9 2003/12/21 18:18:21 henning Exp $ */
d41 1
a41 1
int	dispatch_imsg(int, int, struct mrt_config *, struct msgbuf *);
d47 2
a48 2
struct msgbuf		msgbuf_se;
struct msgbuf		msgbuf_rde;
d186 2
a187 5
	msgbuf_init(&msgbuf_se);
	msgbuf_se.sock = pipe_m2s[0];
	msgbuf_init(&msgbuf_rde);
	msgbuf_rde.sock = pipe_m2r[0];
	init_imsg_buf();
d190 1
a190 1
		pfd[PFD_PIPE_SESSION].fd = msgbuf_se.sock;
d192 1
a192 1
		if (msgbuf_se.queued)
d194 1
a194 1
		pfd[PFD_PIPE_ROUTE].fd = msgbuf_rde.sock;
d196 1
a196 1
		if (msgbuf_rde.queued)
d211 1
a211 1
			if ((n = msgbuf_write(&msgbuf_se)) == -1)
d215 1
a215 1
			if ((n = msgbuf_write(&msgbuf_rde)) == -1)
d220 1
a220 2
			dispatch_imsg(pfd[PFD_PIPE_SESSION].fd,
			    PFD_PIPE_SESSION, &mrtconf, &msgbuf_rde);
d225 1
a225 2
			dispatch_imsg(pfd[PFD_PIPE_ROUTE].fd, PFD_PIPE_ROUTE,
			    &mrtconf, &msgbuf_rde);
d239 1
a239 1
				mrt_state(mconf, IMSG_NONE, &msgbuf_rde);
d244 1
a244 1
			mrt_alrm(&mrtconf, &msgbuf_rde);
d247 1
a247 1
			mrt_usr1(&mrtconf, &msgbuf_rde);
d278 1
a278 1
	imsg_compose(&msgbuf_se, IMSG_RECONF_CONF, 0,
d280 1
a280 1
	imsg_compose(&msgbuf_rde, IMSG_RECONF_CONF, 0,
d283 1
a283 1
		imsg_compose(&msgbuf_se, IMSG_RECONF_PEER, p->conf.id,
d285 1
a285 1
		imsg_compose(&msgbuf_rde, IMSG_RECONF_PEER, p->conf.id,
d288 2
a289 2
	imsg_compose(&msgbuf_se, IMSG_RECONF_DONE, 0, NULL, 0);
	imsg_compose(&msgbuf_rde, IMSG_RECONF_DONE, 0, NULL, 0);
d298 1
a298 1
dispatch_imsg(int fd, int idx, struct mrt_config *conf, struct msgbuf *rde)
d306 1
a306 1
	if (get_imsg(fd, &imsg) > 0) {
d313 1
a313 1
				if (mrt_state(m, imsg.hdr.type, rde) == 0)
@


1.9
log
@use pipe(2)s instead of socketpair(2)s.
suggested by tedu@@ for a performance gain, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.8 2003/12/20 21:26:48 henning Exp $ */
d40 2
a41 3
int	reconfigure(char *, int, int *, int, int *, struct bgpd_config *,
	    struct mrt_config *);
int	dispatch_imsg(int, int, struct mrt_config *, int, int *);
d47 2
a100 2
	int			 m2s_writes_queued = 0;
	int			 m2r_writes_queued = 0;
d186 4
d193 1
a193 1
		pfd[PFD_PIPE_SESSION].fd = pipe_m2s[0];
d195 1
a195 1
		if (m2s_writes_queued)
d197 1
a197 1
		pfd[PFD_PIPE_ROUTE].fd = pipe_m2r[0];
d199 1
a199 1
		if (m2r_writes_queued)
d203 2
a204 2
			if (mconf->queued_writes) {
				pfd[i].fd = mconf->fd;
d213 2
a214 4
		if (nfds > 0 && (pfd[PFD_PIPE_SESSION].revents & POLLOUT) &&
		    m2s_writes_queued) {
			if ((n = buf_sock_write(pfd[PFD_PIPE_SESSION].fd)) ==
			    -1)
a215 2
			m2s_writes_queued -= n;
		}
d217 2
a218 3
		if (nfds > 0 && (pfd[PFD_PIPE_ROUTE].revents & POLLOUT) &&
		    m2r_writes_queued) {
			if ((n = buf_sock_write(pfd[PFD_PIPE_ROUTE].fd)) == -1)
a219 2
			m2r_writes_queued -= n;
		}
d223 2
a224 2
			dispatch_imsg(pfd[PFD_PIPE_SESSION].fd, pipe_m2s[0],
			    &mrtconf, pipe_m2r[0], &m2r_writes_queued);
d229 2
a230 2
			dispatch_imsg(pfd[PFD_PIPE_ROUTE].fd, pipe_m2r[0],
			    &mrtconf, pipe_m2r[0], &m2r_writes_queued);
d234 2
a235 3
			if ((pfd[j].revents & POLLOUT) &&
			    mrt[i]->queued_writes) {
				if ((n = buf_sock_write(pfd[i].fd)) == -1)
a236 1
				mrt[i]->queued_writes -= n;
d242 1
a242 2
			reconfigure(conffile, pipe_m2s[0], &m2s_writes_queued,
			    pipe_m2r[0], &m2r_writes_queued, &conf, &mrtconf);
d244 1
a244 2
				mrt_state(mconf, IMSG_NONE, pipe_m2r[0],
					    &m2r_writes_queued);
d247 1
d249 1
a249 1
			mrt_alrm(&mrtconf, pipe_m2r[0], &m2r_writes_queued);
d252 1
a252 1
			mrt_usr1(&mrtconf, pipe_m2r[0], &m2r_writes_queued);
d274 1
a274 2
reconfigure(char *conffile, int se_fd, int *se_waiting, int rde_fd,
    int *rde_waiting, struct bgpd_config *conf, struct mrt_config *mrtc)
d283 1
a283 1
	*se_waiting += imsg_compose(se_fd, IMSG_RECONF_CONF, 0,
d285 1
a285 1
	*rde_waiting += imsg_compose(rde_fd, IMSG_RECONF_CONF, 0,
d288 4
a291 4
		*se_waiting += imsg_compose(se_fd, IMSG_RECONF_PEER,
		    p->conf.id, &p->conf, sizeof(struct peer_config));
		*rde_waiting += imsg_compose(rde_fd, IMSG_RECONF_PEER,
		    p->conf.id, &p->conf, sizeof(struct peer_config));
d293 2
a294 2
	*se_waiting += imsg_compose(se_fd, IMSG_RECONF_DONE, 0, NULL, 0);
	*rde_waiting += imsg_compose(rde_fd, IMSG_RECONF_DONE, 0, NULL, 0);
d303 1
a303 2
dispatch_imsg(int fd, int idx, struct mrt_config *conf,
    int rfd, int *rwait /*, int sfd, int *swait */)
d305 1
a307 1
	struct imsg		 imsg;
d318 1
a318 2
				if (mrt_state(m, imsg.hdr.type,
					    rfd, rwait) == 0)
d320 1
a320 1
				if (m->fd == -1)
d323 1
a323 1
				wbuf = buf_open(NULL, m->fd, len);
d328 1
a328 1
				if ((n = buf_close(wbuf)) == -1)
a329 1
				m->queued_writes += n;
@


1.8
log
@more from the castathon; imsg_compose takes void * now so get rid of the casts
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.7 2003/12/20 20:53:30 henning Exp $ */
d158 2
a159 2
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_m2s) == -1)
		fatal("socketpair", errno);
d163 2
a164 2
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_m2r) == -1)
		fatal("socketpair", errno);
d168 2
a169 2
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_s2r) == -1)
		fatal("socketpair", errno);
@


1.7
log
@few missing break; in default: cases in switch; one noticed by tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.6 2003/12/20 19:17:51 deraadt Exp $ */
d292 1
a292 1
	    (u_char *)conf, sizeof(struct bgpd_config));
d294 1
a294 1
	    (u_char *)conf, sizeof(struct bgpd_config));
d297 1
a297 1
		    p->conf.id, (u_char *)&p->conf, sizeof(struct peer_config));
d299 1
a299 1
		    p->conf.id, (u_char *)&p->conf, sizeof(struct peer_config));
@


1.6
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.5 2003/12/20 18:50:40 henning Exp $ */
d345 1
@


1.5
log
@parent: waitpid() for the child processes on exit
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.4 2003/12/20 18:32:22 henning Exp $ */
d272 3
a274 3
        do {
                i = waitpid(-1, NULL, WNOHANG);
        } while (i > 0 || (i == -1 && errno == EINTR));
@


1.4
log
@keep track which process we are so fatal() can log in which proc the
condition happened. fatal()s from subsystems used by all 3 processes like
the imsg subsystem were hard to track down without knowing in which process
the condition happened.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.3 2003/12/20 14:33:09 henning Exp $ */
d21 1
d271 4
@


1.3
log
@read(2)/write(2) return ssize_t, not size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.2 2003/12/17 19:26:26 henning Exp $ */
d103 1
@


1.2
log
@send reconf requests to the RDE as well and handle them there; syncing peer
data with RIB missing
use same message in RDE and SE for consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.c,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d311 1
a311 1
	size_t			 len;
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d39 1
a39 1
int	reconfigure(char *, int, int *, struct bgpd_config *,
d247 1
a247 1
			    &conf, &mrtconf);
d275 2
a276 2
reconfigure(char *conffile, int fd, int *waiting, struct bgpd_config *conf,
    struct mrt_config *mrtc)
d285 12
a296 6
	*waiting += imsg_compose(fd, IMSG_RECONF_CONF, 0, (u_char *)conf,
	    sizeof(struct bgpd_config));
	for (p = conf->peers; p != NULL; p = p->next)
		*waiting += imsg_compose(fd, IMSG_RECONF_PEER, p->conf.id,
		    (u_char *)&p->conf, sizeof(struct peer_config));
	*waiting += imsg_compose(fd, IMSG_RECONF_DONE, 0, NULL, 0);
@

