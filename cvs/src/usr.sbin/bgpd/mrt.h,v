head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.20
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.24
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.22
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.16
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.18
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.10
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.14
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.12
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.8
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.6
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.4
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.12
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.10
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10;
locks; strict;
comment	@ * @;


1.31
date	2011.09.19.11.19.32;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2011.09.18.09.31.25;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2011.09.17.16.29.44;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2011.09.16.15.44.42;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.04.10.13.00;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.22.08.24.58;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.22.08.18.00;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.26.09.27.58;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2009.06.29.12.22.16;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.05.17.36.49;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.04.22.08.19;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2009.05.17.12.25.15;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.19.07.00.07;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.13.06.25.04;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.13.05.43.51;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.30.04.28.27;	author msf;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.13.14.03.20;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.11.16.48.45;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.28.16.00.02;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.13.17.57.20;	author jaredy;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.03.17.19.59;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.25.19.48.18;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.18.00.44.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.06.10.51.14;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.05.22.57.58;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.02.00.13.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.30.13.03.27;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.21.23.26.37;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.17.18.11.31;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Make it more clear what are subtypes and some more cleanup of the
mrt definitions.
@
text
@/*	$OpenBSD: mrt.h,v 1.30 2011/09/18 09:31:25 claudio Exp $ */

/*
 * Copyright (c) 2003, 2004 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef __MRT_H__
#define __MRT_H__

/*
 * MRT binary packet format
 * For more info see:
 * draft-ietf-grow-mrt-11.txt, "MRT routing information export format"
 * http://www.quagga.net/docs/docs-multi/Packet-Binary-Dump-Format.html
 */

/*
 * MRT header:
 * +--------+--------+--------+--------+
 * |             timestamp             |
 * +--------+--------+--------+--------+
 * |      type       |     subtype     |
 * +--------+--------+--------+--------+
 * |               length              | length of packet excluding this header
 * +--------+--------+--------+--------+
 *
 * ET types include an additional 32bit microsecond field coming after the
 * length field. Which is accounted in the length field.
 */
#define MRT_HEADER_SIZE		12

struct mrt_hdr {
	u_int32_t	timestamp;
	u_int16_t	type;
	u_int16_t	subtype;
	u_int32_t	length;
} __packed;

enum MRT_MSG_TYPES {
	MSG_NULL,		/*  0 empty msg (deprecated) */
	MSG_START,		/*  1 sender is starting up */
	MSG_DIE,		/*  2 receiver should shut down (deprecated) */
	MSG_I_AM_DEAD,		/*  3 sender is shutting down */
	MSG_PEER_DOWN,		/*  4 sender's peer is down (deprecated) */
	MSG_PROTOCOL_BGP,	/*  5 msg is a BGP packet (deprecated) */
	MSG_PROTOCOL_RIP,	/*  6 msg is a RIP packet */
	MSG_PROTOCOL_IDRP,	/*  7 msg is an IDRP packet (deprecated) */
	MSG_PROTOCOL_RIPNG,	/*  8 msg is a RIPNG packet */
	MSG_PROTOCOL_BGP4PLUS,	/*  9 msg is a BGP4+ packet (deprecated) */
	MSG_PROTOCOL_BGP4PLUS1,	/* 10 msg is a BGP4+ (draft 01) (deprecated) */
	MSG_PROTOCOL_OSPF,	/* 11 msg is an OSPF packet */
	MSG_TABLE_DUMP,		/* 12 routing table dump */
	MSG_TABLE_DUMP_V2,	/* 13 routing table dump */
	MSG_PROTOCOL_BGP4MP=16,	/* 16 zebras own packet format */
	MSG_PROTOCOL_BGP4MP_ET=17,
	MSG_PROTOCOL_ISIS=32,	/* 32 msg is a ISIS package */
	MSG_PROTOCOL_ISIS_ET=33,
	MSG_PROTOCOL_OSPFV3=48,	/* 48 msg is a OSPFv3 package */
	MSG_PROTOCOL_OSPFV3_ET=49
};

/*
 * Main zebra dump format is in MSG_PROTOCOL_BGP4MP exceptions are table dumps
 * that are normaly saved as MSG_TABLE_DUMP.
 * In most cases this is the format to choose to dump updates et al.
 */
enum MRT_BGP4MP_SUBTYPES {
	BGP4MP_STATE_CHANGE,	/* state change */
	BGP4MP_MESSAGE,		/* bgp message */
	BGP4MP_ENTRY,		/* table dumps (deprecated) */
	BGP4MP_SNAPSHOT,	/* file name for dump (deprecated) */
	BGP4MP_MESSAGE_AS4,	/* same as BGP4MP_MESSAGE with 4byte AS */
	BGP4MP_STATE_CHANGE_AS4,
	BGP4MP_MESSAGE_LOCAL,	  /* same as BGP4MP_MESSAGE but for self */
	BGP4MP_MESSAGE_AS4_LOCAL  /* originated updates. Not implemented */
};

/* size of the BGP4MP headers without payload */
#define MRT_BGP4MP_IPv4_HEADER_SIZE	16
#define MRT_BGP4MP_IPv6_HEADER_SIZE	40
/* 4-byte AS variants of the previous */
#define MRT_BGP4MP_AS4_IPv4_HEADER_SIZE	20
#define MRT_BGP4MP_AS4_IPv6_HEADER_SIZE	44

/* If the type is PROTOCOL_BGP4MP and the subtype is either BGP4MP_STATE_CHANGE
 * or BGP4MP_MESSAGE the message consists of a common header plus the payload.
 * Header format:
 *
 * +--------+--------+--------+--------+
 * |    source_as    |     dest_as     |
 * +--------+--------+--------+--------+
 * |    if_index     |       afi       |
 * +--------+--------+--------+--------+
 * |             source_ip             |
 * +--------+--------+--------+--------+
 * |              dest_ip              |
 * +--------+--------+--------+--------+
 * |      message specific payload ...
 * +--------+--------+--------+--------+
 *
 * The source_ip and dest_ip are dependant of the afi type. For IPv6 source_ip
 * and dest_ip are both 16 bytes long.
 * For the AS4 types the source_as and dest_as numbers are both 4 bytes long.
 *
 * Payload of a BGP4MP_STATE_CHANGE packet:
 *
 * +--------+--------+--------+--------+
 * |    old_state    |    new_state    |
 * +--------+--------+--------+--------+
 *
 * The state values are the same as in RFC 1771.
 *
 * The payload of a BGP4MP_MESSAGE is the full bgp message with header.
 */

/*
 * size of the BGP4MP entries without variable stuff.
 * All until nexthop plus attr_len, not included plen, prefix and bgp attrs.
 */
#define MRT_BGP4MP_IPv4_ENTRY_SIZE	18
#define MRT_BGP4MP_IPv6_ENTRY_SIZE	30
#define MRT_BGP4MP_MAX_PREFIXLEN	17
/*
 * The "new" table dump format consists of messages of type PROTOCOL_BGP4MP
 * and subtype BGP4MP_ENTRY.
 *
 * +--------+--------+--------+--------+
 * |      view       |     status      |
 * +--------+--------+--------+--------+
 * |            originated             |
 * +--------+--------+--------+--------+
 * |       afi       |  safi  | nhlen  |
 * +--------+--------+--------+--------+
 * |              nexthop              |
 * +--------+--------+--------+--------+
 * |  plen  |  prefix variable  ...    |
 * +--------+--------+--------+--------+
 * |    attr_len     | bgp attributes
 * +--------+--------+--------+--------+
 *  bgp attributes, attr_len bytes long
 * +--------+--------+--------+--------+
 *   ...                      |
 * +--------+--------+--------+
 *
 * View is normaly 0 and originated the time of last change.
 * The status seems to be 1 by default but probably something to indicate
 * the status of a prefix would be more useful.
 * The format of the nexthop address is defined via the afi value. For IPv6
 * the nexthop field is 16 bytes long.
 * The prefix field is as in the bgp update message variable length. It is
 * plen bits long but rounded to the next octet.
 */

/*
 * New MRT dump format MSG_TABLE_DUMP_V2, the dump is implemented with
 * sub-tables for peers and NLRI entries just use the index into the peer
 * table.
 */
enum MRT_DUMP_V2_SUBTYPES {
	MRT_DUMP_V2_PEER_INDEX_TABLE=1,
	MRT_DUMP_V2_RIB_IPV4_UNICAST=2,
	MRT_DUMP_V2_RIB_IPV4_MULTICAST=3,
	MRT_DUMP_V2_RIB_IPV6_UNICAST=4,
	MRT_DUMP_V2_RIB_IPV6_MULTICAST=5,
	MRT_DUMP_V2_RIB_GENERIC=6
};

/*
 * Format of the MRT_DUMP_V2_PEER_INDEX_TABLE:
 * If there is no view_name, view_name_len must be set to 0
 *
 * +--------+--------+--------+--------+
 * |         collector_bgp_id          |
 * +--------+--------+--------+--------+
 * |  view_name_len  |    view_name
 * +--------+--------+--------+--------+
 *        view_name (variable) ...     |
 * +--------+--------+--------+--------+
 * |   peer_count    |   peer_entries
 * +--------+--------+--------+--------+
 *       peer_entries (variable) ...
 * +--------+--------+--------+--------+
 *
 * The format of a peer_entry is the following:
 *
 * +--------+
 * |  type  |    
 * +--------+--------+--------+--------+
 * |            peer_bgp_id            |
 * +--------+--------+--------+--------+
 * |       peer_ip_addr (variable)     |
 * +--------+--------+--------+--------+
 * |            peer_as (variable)     |
 * +--------+--------+--------+--------+
 *
 * The message is packed a bit strangely. The type byte defines what size
 * the peer addr and peer AS have.
 * The position of a peer in the PEER_INDEX_TABLE is used as the index for
 * the other messages.
 */
#define MRT_DUMP_V2_PEER_BIT_I	0x1	/* set for IPv6 addrs */
#define MRT_DUMP_V2_PEER_BIT_A	0x2	/* set for 32 bits AS number */

/*
 * AFI/SAFI specific RIB Subtypes are special to save a few bytes.
 * 
 * +--------+--------+--------+--------+
 * |              seq_num              |
 * +--------+--------+--------+--------+
 * |  plen  |  prefix (variable)
 * +--------+--------+--------+--------+
 * |     #entry      | rib entries (variable)
 * +--------+--------+--------+--------+
 *
 * The RIB_GENERIC subtype is needed for the less common AFI/SAFI pairs
 *
 * +--------+--------+--------+--------+
 * |              seq_num              |
 * +--------+--------+--------+--------+
 * |       AFI       |  SAFI  |  NLRI
 * +--------+--------+--------+--------+
 *     NLRI (variable) ...
 * +--------+--------+--------+--------+
 * |     #entry      | rib entries (variable)
 * +--------+--------+--------+--------+
 */

/*
 * The RIB entries have the following form.
 *
 * +--------+--------+
 * |   peer index    |
 * +--------+--------+--------+--------+
 * |          originated_time          |
 * +--------+--------+--------+--------+
 * |    attr_len     |   bgp_attrs
 * +--------+--------+--------+--------+
 *      bgp_attrs (variable) ...
 * +--------+--------+--------+--------+
 *
 * Some BGP path attributes need special encoding:
 *  - the AS_PATH attribute MUST be encoded as 4-Byte AS
 *  - the MP_REACH_NLRI only consists of the nexthop len and nexthop address
 */

/*
 * Format for routing table dumps in "old" mrt format.
 * Type MSG_TABLE_DUMP and subtype is AFI_IPv4 (1) for IPv4 and AFI_IPv6 (2)
 * for IPv6. In the IPv6 case prefix and peer_ip are both 16 bytes long.
 *
 * +--------+--------+--------+--------+
 * |      view       |      seqnum     |
 * +--------+--------+--------+--------+
 * |               prefix              |
 * +--------+--------+--------+--------+
 * |  plen  | status | originated time
 * +--------+--------+--------+--------+
 *   originated time |     peer_ip
 * +--------+--------+--------+--------+
 *       peer_ip     |     peer_as     |
 * +--------+--------+--------+--------+
 * |    attr_len     | bgp attributes
 * +--------+--------+--------+--------+
 *  bgp attributes, attr_len bytes long
 * +--------+--------+--------+--------+
 *   ...                      |
 * +--------+--------+--------+
 *
 *
 * View is normaly 0 and seqnum just a simple counter for this dump.
 * The status field is unused and should be set to 1.
 */

enum MRT_DUMP_SUBTYPES {
	MRT_DUMP_AFI_IP=1,
	MRT_DUMP_AFI_IPv6=2
};

/* size of the dump header until attr_len */
#define MRT_DUMP_HEADER_SIZE	22
#define MRT_DUMP_HEADER_SIZE_V6	46

/*
 * OLD MRT message headers. These structs are here for completion but
 * will not be used to generate dumps. It seems that nobody uses those.
 *
 * Only for bgp messages (type 5, 9 and 10)
 * Nota bene for bgp dumps MSG_PROTOCOL_BGP4MP should be used.
 */
enum MRT_BGP_SUBTYPES {
	MSG_BGP_NULL,
	MSG_BGP_UPDATE,		/* raw update packet (contains both withdraws
				   and announcements) */
	MSG_BGP_PREF_UPDATE,	/* tlv preferences followed by raw update */
	MSG_BGP_STATE_CHANGE,	/* state change */
	MSG_BGP_SYNC,		/* file name for a table dump */
	MSG_BGP_OPEN,		/* BGP open messages */
	MSG_BGP_NOTIFY,		/* BGP notify messages */
	MSG_BGP_KEEPALIVE	/* BGP keepalives */
};

/* if type MSG_PROTOCOL_BGP and subtype MSG_BGP_UPDATE, MSG_BGP_OPEN,
 * MSG_BGP_NOTIFY or MSG_BGP_KEEPALIVE
 *
 * +--------+--------+--------+--------+
 * |    source_as    |    source_ip
 * +--------+--------+--------+--------+
 *      source_ip    |    dest_as      |
 * +--------+--------+--------+--------+
 * |               dest_ip             |
 * +--------+--------+--------+--------+
 * | bgp update packet with header et
 * +--------+--------+--------+--------+
 *   al. (variable length) ...
 * +--------+--------+--------+--------+
 *
 * For IPv6 the type is MSG_PROTOCOL_BGP4PLUS and the subtype remains
 * MSG_BGP_UPDATE. The source_ip and dest_ip are again extended to 16 bytes.
 *
 * For subtype MSG_BGP_STATE_CHANGE (for all BGP types or just for the
 * MSG_PROTOCOL_BGP4PLUS case? Unclear.)
 *
 * +--------+--------+--------+--------+
 * |    source_as    |    source_ip
 * +--------+--------+--------+--------+
 *      source_ip    |    old_state    |
 * +--------+--------+--------+--------+
 * |    new_state    |
 * +--------+--------+
 *
 * States are defined in RFC 1771/4271.
 */

/*
 * if type MSG_PROTOCOL_BGP and subtype MSG_BGP_SYNC OR
 * if type MSG_PROTOCOL_BGP4MP and subtype BGP4MP_SNAPSHOT
 * *DEPRECATED*
 *
 * +--------+--------+--------+--------+
 * |      view       |    filename
 * +--------+--------+--------+--------+
 *    filename variable length zero
 * +--------+--------+--------+--------+
 *    terminated ... |   0    |
 * +--------+--------+--------+
 */
#endif
@


1.30
log
@Reorder the headerfiles a bit. Move the bgpd specific prototypes out of
mrt.h. Now mrt.h includes only protocol specific defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.29 2011/09/17 16:29:44 claudio Exp $ */
d39 1
a39 1
 * length field.
d78 1
a78 1
enum MRT_BGP4MP_TYPES {
d170 1
a170 1
enum MRT_DUMP_V2_TYPES {
d223 1
a223 1
 * | #entry |  rib entries (variable)
d235 1
a235 1
 * | #entry |  rib entries (variable)
d274 1
a274 1
 
d285 5
d301 1
a301 1
enum MRT_BGP_TYPES {
d330 1
a330 3
 */

/*
@


1.29
log
@Implement new mrt table dump format as specified in draft-ietf-grow-mrt.
Tested with IP and IPv6 sessions and against the libbgpdump parser.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.28 2011/09/16 15:44:42 claudio Exp $ */
d43 7
a354 67

#define	MRT_FILE_LEN	512
enum mrt_type {
	MRT_NONE,
	MRT_TABLE_DUMP,
	MRT_TABLE_DUMP_MP,
	MRT_TABLE_DUMP_V2,
	MRT_ALL_IN,
	MRT_ALL_OUT,
	MRT_UPDATE_IN,
	MRT_UPDATE_OUT
};

enum mrt_state {
	MRT_STATE_RUNNING,
	MRT_STATE_OPEN,
	MRT_STATE_REOPEN,
	MRT_STATE_REMOVE
};

struct mrt {
	char			rib[PEER_DESCR_LEN];
	struct msgbuf		wbuf;
	LIST_ENTRY(mrt)		entry;
	u_int32_t		peer_id;
	u_int32_t		group_id;
	enum mrt_type		type;
	enum mrt_state		state;
	u_int16_t		seqnum;
};

struct mrt_config {
	struct mrt		conf;
	char			name[MRT_FILE_LEN];	/* base file name */
	char			file[MRT_FILE_LEN];	/* actual file name */
	time_t			ReopenTimer;
	time_t			ReopenTimerInterval;
};

#define	MRT2MC(x)	((struct mrt_config *)(x))
#define	MRT_MAX_TIMEOUT	7200

struct bgpd_config;
struct rde_peer_head;
struct peer;
struct prefix;
struct rib_entry;

/* prototypes */
void		 mrt_dump_bgp_msg(struct mrt *, void *, u_int16_t,
		     struct peer *);
void		 mrt_dump_state(struct mrt *, u_int16_t, u_int16_t,
		     struct peer *);
int		 mrt_dump_v2_hdr(struct mrt *, struct bgpd_config *,
		    struct rde_peer_head *);
void		 mrt_clear_seq(void);
void		 mrt_dump_upcall(struct rib_entry *, void *);
void		 mrt_done(void *);
void		 mrt_write(struct mrt *);
void		 mrt_clean(struct mrt *);
void		 mrt_init(struct imsgbuf *, struct imsgbuf *);
int		 mrt_timeout(struct mrt_head *);
void		 mrt_reconfigure(struct mrt_head *);
void		 mrt_handler(struct mrt_head *);
struct mrt	*mrt_get(struct mrt_head *, struct mrt *);
int		 mrt_mergeconfig(struct mrt_head *, struct mrt_head *);

@


1.28
log
@Fix my usual typo
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.27 2010/06/04 10:13:00 claudio Exp $ */
d107 1
d159 92
d267 1
a267 1
 * +--------+--------+--------+--------+
d321 1
a321 1
 * For subtype MSG_BGP_STATECHANGE (for all BGP types or just for the
d332 1
a332 1
 * State are defined in RFC 1771/4271.
d354 1
d390 2
d401 2
@


1.27
log
@It is actually possible to dump IPv6 tables with "dump table" and not
"dump table-mp" but this is only possible if the session and the prefixes
are from the same address family. Evil little hackery (especially the
IPv6 nexthop encoding) but seems to work according to libbgpdump.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.26 2010/04/22 08:24:58 claudio Exp $ */
d38 1
a38 1
 * ET types include an additional 32bit microsecond field comming after the
@


1.26
log
@Including bgpd.h in mrt.h is dumb.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.25 2010/04/22 08:18:00 claudio Exp $ */
d24 1
a24 1
 * draft-ietf-grow-mrt-04.txt, "MRT routing information export format"
d187 1
d239 1
a239 1
 * State are defined in RFC 1771.
@


1.25
log
@Correct the BGP4MP subtypes according to draft-ietf-grow-mrt-11.
The _AS4 types where reversed and the local types are missing even though
I'm not sure if bgpd will ever support them.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.24 2009/10/26 09:27:58 claudio Exp $ */
a19 2

#include "bgpd.h"
@


1.24
log
@Better error handling when doing mrt dumps (e.g. when there is no more space
on the disk). Before the SE spinned and the RDE may even crash in these events.
Found by Elisa Jasinska. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.23 2009/06/29 12:22:16 claudio Exp $ */
d78 1
d80 2
a81 1
	BGP4MP_MESSAGE_AS4	/* same as BGP4MP_MESSAGE with 4byte AS */
@


1.23
log
@Unfuck mrt table dumps and plug a memory leak while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.22 2009/06/05 17:36:49 claudio Exp $ */
d306 1
a306 1
void		 mrt_dump_done(void *);
@


1.22
log
@Change the way we do mrt dumps in the rde (from the retarded only one dump
possible to as many as you like). The mrt dumps are now done with the same
tree walking code as the control messages. Makes the RDE respond a bit faster
and use less memory while dumping.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.21 2009/06/04 22:08:19 claudio Exp $ */
d280 1
d286 2
a289 3
	enum mrt_state		state;
	char			name[MRT_FILE_LEN];	/* base file name */
	char			file[MRT_FILE_LEN];	/* actual file name */
@


1.21
log
@Make mrt understand alternate RIB plus remove some other static rib references.
There is still a problem with the mrt dumps because we only allow one in the
RDE. This needs some additional work.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.20 2009/05/17 12:25:15 claudio Exp $ */
d280 1
d306 1
@


1.20
log
@Rework most of the RDE to allow multiple RIBs. This is mostly preparation
work by changing the way the RDE DB is built. struct prefix and struct
pt_entry are simplified and extended with a rib_entry where the decision
tree is run on. From now on a prefix can only reside on one particular RIB
which simplifies the code a bit. Currently there are two fixed ribs
(adj-rib-in and the local-rib) which needs to be made more dynamic in
upcomming commits.
This is work in progress, the RDE seems to work for me and sthen@@ (no flames
comming out of our testrouters but there is still a lot missing)
Move into the tree to simplify developement -- henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.19 2009/03/19 07:00:07 claudio Exp $ */
d274 1
@


1.19
log
@First big chunk of mrt rewrite. Simplifies code hopefully and fixes table
dumps that were wrong because of the 4byte AS support. Dumps I took seemed
to work so far. "Put it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.18 2009/03/13 06:25:04 claudio Exp $ */
d295 1
a295 1
struct pt_entry;
d303 1
a303 1
void		 mrt_dump_upcall(struct pt_entry *, void *);
@


1.18
log
@Next step in mrt cleanup. Switch buf_write to a smarter version of itself.
Doing more the stuff msgbuf_write does and switch the only user -- mrt --
over to use this simpler way of writing out stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.17 2009/03/13 05:43:51 claudio Exp $ */
a22 3
/* In cases of failure wait at least MRT_MIN_RETRY. */
#define MRT_MIN_RETRY	300

d24 1
a24 1
 * MRT binary packet format as used by zebra.
d26 1
d39 3
d46 1
a46 1
	MSG_NULL,
d48 1
a48 1
	MSG_DIE,		/*  2 receiver should shut down */
d50 2
a51 2
	MSG_PEER_DOWN,		/*  4 sender's peer is down */
	MSG_PROTOCOL_BGP,	/*  5 msg is a BGP packet */
d53 1
a53 1
	MSG_PROTOCOL_IDRP,	/*  7 msg is an IDRP packet */
d55 2
a56 2
	MSG_PROTOCOL_BGP4PLUS,	/*  9 msg is a BGP4+ packet */
	MSG_PROTOCOL_BGP4PLUS1,	/* 10 msg is a BGP4+ (draft 01) packet */
d59 7
a65 1
	MSG_PROTOCOL_BGP4MP=16	/* 16 zebras own packet format */
d74 6
a79 4
	BGP4MP_STATE_CHANGE=0,	/* state change */
	BGP4MP_MESSAGE=1,	/* bgp message */
	BGP4MP_ENTRY=2,		/* table dumps */
	BGP4MP_SNAPSHOT=3
d85 3
d125 1
d167 1
a167 1
 * |  plen  | status |    originated
d169 1
a169 1
 *      originated   |     peer_ip
d182 1
a182 2
 * The status seems to be 1 by default but probably something to indicate
 * the status of a prefix would be more useful.
d201 4
a204 1
	MSG_BGP_SYNC
d207 2
a208 1
/* if type MSG_PROTOCOL_BGP and subtype MSG_BGP_UPDATE
d244 1
a244 1
 * What is this for?
d298 4
a301 4
int		 mrt_dump_bgp_msg(struct mrt *, void *, u_int16_t,
		     struct peer *, struct bgpd_config *);
int		 mrt_dump_state(struct mrt *, u_int16_t, u_int16_t,
		     struct peer *, struct bgpd_config *);
@


1.17
log
@Move mrt code over to use the msgbuf way of queuing buffers instead of rolling
an own version. More cleanup to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.16 2007/05/30 04:28:27 msf Exp $ */
d288 1
a288 1
int		 mrt_write(struct mrt *);
@


1.16
log
@mrtd.net is no longer, prune

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.15 2004/08/13 14:03:20 claudio Exp $ */
d258 2
a259 1
	enum mrt_type		type;
d262 1
a262 4
	u_int32_t		queued;
	int			fd;
	TAILQ_HEAD(, buf)	bufs;
	LIST_ENTRY(mrt)		entry;
@


1.15
log
@Fix minor issues with IPv6 dumps and add a function for dumping the RIB table
protocol independent. This new dump format is not (yet) supported by the
mrtd route_btoa tool. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.14 2004/08/11 16:48:45 claudio Exp $ */
a28 4
 * http://www.mrtd.net/mrt_doc/html/mrtprogrammer.html#_Toc412283890
 * or
 * http://www.mrtd.net/mrt_doc/PDF/mrtprogrammer.pdf (Chapter 12)
 * and
@


1.14
log
@mrt dumps for cloned sessions did not work because the wrong address was used.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.13 2004/07/28 16:00:02 claudio Exp $ */
d43 1
a43 1
 * |               length              | length of packet including header
d78 2
a79 1
#define MRT_BGP4MP_HEADER_SIZE	16
d112 6
d247 1
@


1.13
log
@The hole dance to close a mrt file after fd passing in the parent is not
needed as the fd is closed while beeing passed. looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.12 2004/07/13 17:57:20 jaredy Exp $ */
d275 1
d281 1
a281 1
		     struct peer_config *, struct bgpd_config *);
d283 1
a283 1
		     struct peer_config *, struct bgpd_config *);
@


1.12
log
@fix some typos

ok henning otto
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.11 2004/07/03 17:19:59 claudio Exp $ */
a287 1
void		 mrt_close(struct mrt *);
@


1.11
log
@Switch mrt dumping to fd passing. This gives some speed up when extensive
dumping is done. Acctually mrt dumps were broken because of the fd passing.
The nice side effect is a much cleaner code, especially in the parent process.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.10 2004/02/25 19:48:18 claudio Exp $ */
d204 1
a204 1
 * MSG_BGP_UPDATE. The sourec_ip and dest_ip are again extended to 16 bytes.
@


1.10
log
@Rewrite some parts of the mrt dump handling. It is no longer possible to
dump the filtered updates but therefore it is now possible to dump per
neighbor and also to dump the outgoing messages. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.9 2004/01/18 00:44:44 deraadt Exp $ */
a246 1
	MRT_STATE_STOPPED,
a248 1
	MRT_STATE_CLOSE,
a249 1
	MRT_STATE_TOREMOVE,
d253 9
a261 1
LIST_HEAD(mrt_config_head, mrt_config);
d264 6
a269 18
	enum mrt_type		 type;
	u_int32_t		 id;
	u_int32_t		 peer_id;
	u_int32_t		 group_id;
	struct imsgbuf		*ibuf;
	LIST_ENTRY(mrt_config)	 list;			/* used in the SE */
};

struct mrt {
	struct mrt_config	 conf;
	time_t			 ReopenTimer;
	time_t			 ReopenTimerInterval;
	enum mrt_state		 state;
	struct msgbuf		 msgbuf;
	struct imsgbuf		*ibuf;
	char			 name[MRT_FILE_LEN];	/* base file name */
	char			 file[MRT_FILE_LEN];	/* actual file name */
	LIST_ENTRY(mrt)		 list;			/* used in the parent */
d272 2
d279 15
a293 14
int	mrt_dump_bgp_msg(struct mrt_config *, void *, u_int16_t,
	    struct peer_config *, struct bgpd_config *);
int	mrt_dump_state(struct mrt_config *, u_int16_t, u_int16_t,
	    struct peer_config *, struct bgpd_config *);
void	mrt_clear_seq(void);
void	mrt_dump_upcall(struct pt_entry *, void *);
void	mrt_init(struct imsgbuf *, struct imsgbuf *);
void	mrt_abort(struct mrt *);
int	mrt_queue(struct mrt_head *, struct imsg *);
int	mrt_write(struct mrt *);
int	mrt_select(struct mrt_head *, struct pollfd *, struct mrt **,
	    int, int, int *);
int	mrt_handler(struct mrt_head *);
int	mrt_mergeconfig(struct mrt_head *, struct mrt_head *);
@


1.9
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.8 2004/01/06 10:51:14 claudio Exp $ */
a239 1
	MRT_FILTERED_IN,
d241 3
a243 2
	MRT_SESSION_IN,
	MRT_SESSION_OUT
d256 2
d262 3
a264 1
	struct msgbuf		*msgbuf;
d276 1
a276 1
	LIST_ENTRY(mrt)		 list;
d284 1
a284 1
int	mrt_dump_bgp_msg(struct mrt_config *, void *, u_int16_t, int,
@


1.8
log
@2004 OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.7 2004/01/05 22:57:58 claudio Exp $ */
d83 1
a83 1
 * 
@


1.7
log
@Big overhaul of the mrt code.
Dumping of incomming bgp messages is now possible and dumping the (not yet)
filtered updates works too. Per neighbor dumps are still missing.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.6 2004/01/02 00:13:32 deraadt Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Claudio Jeker <claudio@@openbsd.org>
@


1.6
log
@do not , after last element in an enum
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.5 2003/12/30 13:03:27 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Claudio Jeker <cjeker@@diehard.n-r-g.com>
d23 3
d36 11
a46 6
struct mrt_header {
	u_int32_t	timestamp;
	u_int16_t	type;
	u_int16_t	subtype;
	u_int32_t	length;		/* length of packet including header */
};
a64 41
#define MRT_HEADER_SIZE		sizeof(struct mrt_header)
#define MRT_DUMP_HEADER_SIZE	22	/* sizeof(struct mrt_dump_v4_header) */
#define MRT_BGP4MP_HEADER_SIZE	\
	sizeof(struct mrt_bgp4mp_header) + \
	sizeof(struct mrt_bgp4mp_IPv4)
/*
 * format for routing table dumps in mrt format.
 * Type MSG_TABLE_DUMP and subtype is address family (IPv4)
 */
struct mrt_dump_v4_header {
	u_int16_t	view;	/* normally 0 */
	u_int16_t	seqnum;	/* simple counter for this dump */
	u_int32_t	prefix;
	u_int8_t	prefixlen;
	u_int8_t	status;	/* default seems to be 1 */
	u_int32_t	originated; /* seems to be time of last update */
	u_int32_t	peer_ip;
	u_int16_t	peer_as;
	u_int16_t	attr_len;
	/* bgp attributes attr_len bytes long */
};

/*
 * format for routing table dumps in mrt format.
 * Type MSG_TABLE_DUMP and subtype is address family (IPv6)
 */
struct mrt_dump_v6_header {
	u_int16_t	view;	/* normally 0 */
	u_int16_t	seqnum;	/* simple counter for this dump */
	u_int32_t	prefix[4];
	u_int8_t	prefixlen;
	u_int8_t	status;	/* default seems to be 1 */
	u_int32_t	originated; /* seems to be time of last update */
	u_int32_t	peer_ip[4];
	u_int16_t	peer_as;
	u_int16_t	attr_len;
	/* bgp attributes attr_len bytes long */
};



d77 2
a78 26
/* if type PROTOCOL_BGP4MP and
 * subtype BGP4MP_STATE_CHANGE or BGP4MP_MESSAGE  */
struct mrt_bgp4mp_header {
	u_int16_t	source_as;
	u_int16_t	dest_as;
	u_int16_t	if_index;
	u_int16_t	afi;
	/*
	 * Next comes either a struct mrt_bgp4mp_IPv4 or a
	 * struct mrt_bgp4mp_IPv6 dependent on afi type.
	 *
	 * Last but not least the payload.
	 */
};

/* if afi = 4 */
struct mrt_bgp4mp_IPv4 {
	u_int32_t	source_ip;
	u_int32_t	dest_ip;
};

/* if afi = 6 */
struct mrt_bgp4mp_IPv6 {
	u_int32_t	source_ip[4];
	u_int32_t	dest_ip[4];
};
d80 29
a108 7
/*
 * payload of a BGP4MP_STATE_CHANGE packet
 */
struct mrt_bgp4mp_state_data {
	u_int16_t	old_state;	/* as in RFC 1771 */
	u_int16_t	new_state;
};
d111 28
a138 1
 * The payload of a BGP4MP_MESSAGE is the full bgp message with header.
a140 18
/* if type PROTOCOL_BGP4MP, subtype BGP4MP_ENTRY */
struct mrt_bgp4mp_entry_header {
	u_int16_t	view;
	u_int16_t	status;
	u_int32_t	originated;	/* time last change */
	u_int16_t	afi;
	u_int8_t	safi;
	u_int8_t	nexthop_len;
	/*
	 * u_int32_t nexthop    for IPv4 or
	 * u_int32_t nexthop[4] for IPv6
	 * u_int8_t  prefixlen
	 * variable prefix (prefixlen bits long rounded to the next octet)
	 * u_int16_t attrlen
	 * variable length bgp attributes attrlen bytes long
	 */
};

d142 26
a167 3
 * What is this for?
 * if type MSG_PROTOCOL_BGP and subtype MSG_BGP_SYNC OR
 * if type MSG_PROTOCOL_BGP4MP and subtype BGP4MP_SNAPSHOT
d169 3
a171 4
struct mrt_bgp_sync_header {
	u_int16_t	view;
	char		filename[2]; /* variable */
};
d176 1
a176 3
 */

/*
d189 84
a272 24
/* if type MSG_PROTOCOL_BGP and subtype MSG_BGP_UPDATE */
struct mrt_bgp_update_header {
	u_int16_t	source_as;
	u_int32_t	source_ip;
	u_int16_t	dest_as;
	u_int32_t	dest_ip;
	/* bgp update packet */
};

/* if type MSG_PROTOCOL_BGP4PLUS and subtype MSG_BGP_UPDATE */
struct mrt_bgp_update_plus_header {
	u_int16_t	source_as;
	u_int32_t	source_ip[4];
	u_int16_t	dest_as;
	u_int32_t	dest_ip[4];
	/* bgp update packet */
};

/* for subtype MSG_BGP_STATECHANGE (for all BGP types ???) */
struct mrt_bgp_state_header {
	u_int16_t	source_as;
	u_int32_t	source_ip[4];
	u_int16_t	old_state;	/* as in RFC 1771 ??? */
	u_int16_t	new_state;
d275 1
a275 1
/* pseudo predeclarations */
a277 4
struct mrt {
	struct msgbuf	*msgbuf;
	u_int32_t	 id;
};
d280 4
a283 2
int	mrt_dump_bgp_msg(struct mrt *, void *, u_int16_t, int,
    struct peer_config *, struct bgpd_config *);
d286 8
a293 3
int	mrt_state(struct mrtdump_config *, enum imsg_type, struct imsgbuf *);
int	mrt_alrm(struct mrt_config *, struct imsgbuf *);
int	mrt_usr1(struct mrt_config *, struct imsgbuf *);
@


1.5
log
@typos from david
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.4 2003/12/21 23:26:37 henning Exp $ */
d54 1
a54 1
	MSG_PROTOCOL_BGP4MP=16,	/* 16 zebras own packet format */
@


1.4
log
@wrap read & write buffers for imsgs into a struct.
finally gives us read buffers per pipe instead of per process, eleminating
a possible race.
also gets us a real imsg_init() that does all the boring init work
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.3 2003/12/21 22:16:53 henning Exp $ */
d99 1
a99 1
 * Main zebra dump format is in MSG_PROTOCOL_BGP4MP exptions are table dumps
d119 1
a119 1
	 * struct mrt_bgp4mp_IPv6 dependant on afi type.
d163 1
a163 1
	 * variable lenght bgp attributes attrlen bytes long
d178 1
a178 1
 * OLD MRT message headers. These structs are here for completition but
@


1.3
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.2 2003/12/17 18:11:31 henning Exp $ */
d234 3
a236 3
int	mrt_state(struct mrtdump_config *, enum imsg_type, struct msgbuf *);
int	mrt_alrm(struct mrt_config *, struct msgbuf *);
int	mrt_usr1(struct mrt_config *, struct msgbuf *);
@


1.2
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: mrt.h,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d224 4
d230 2
a231 2
int	mrt_dump_bgp_msg(int, u_char *, u_int16_t, int, struct peer_config *,
	    struct bgpd_config *);
d233 4
a236 4
void	mrt_dump_upcall(struct pt_entry *, int, int *, void *);
int	mrt_state(struct mrtdump_config *, enum imsg_type, int, int *);
int	mrt_alrm(struct mrt_config *, int, int *);
int	mrt_usr1(struct mrt_config *, int, int *);
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d58 1
a58 2
#define MRT_DUMP_HEADER_SIZE	\
	/* sizeof(struct mrt_dump_v4_header) */ 22
@

