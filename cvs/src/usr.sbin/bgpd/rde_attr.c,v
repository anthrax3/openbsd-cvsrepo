head	1.97;
access;
symbols
	OPENBSD_6_1:1.97.0.2
	OPENBSD_6_1_BASE:1.97
	OPENBSD_6_0:1.95.0.6
	OPENBSD_6_0_BASE:1.95
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.93.0.6
	OPENBSD_5_8_BASE:1.93
	OPENBSD_5_7:1.93.0.2
	OPENBSD_5_7_BASE:1.93
	OPENBSD_5_6:1.91.0.10
	OPENBSD_5_6_BASE:1.91
	OPENBSD_5_5:1.91.0.8
	OPENBSD_5_5_BASE:1.91
	OPENBSD_5_4:1.91.0.4
	OPENBSD_5_4_BASE:1.91
	OPENBSD_5_3:1.91.0.2
	OPENBSD_5_3_BASE:1.91
	OPENBSD_5_2:1.90.0.2
	OPENBSD_5_2_BASE:1.90
	OPENBSD_5_1_BASE:1.89
	OPENBSD_5_1:1.89.0.2
	OPENBSD_5_0:1.88.0.4
	OPENBSD_5_0_BASE:1.88
	OPENBSD_4_9:1.88.0.2
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.85.0.2
	OPENBSD_4_8_BASE:1.85
	OPENBSD_4_7:1.82.0.2
	OPENBSD_4_7_BASE:1.82
	OPENBSD_4_6:1.79.0.4
	OPENBSD_4_6_BASE:1.79
	OPENBSD_4_5:1.78.0.2
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.76.0.2
	OPENBSD_4_4_BASE:1.76
	OPENBSD_4_3:1.75.0.4
	OPENBSD_4_3_BASE:1.75
	OPENBSD_4_2:1.75.0.2
	OPENBSD_4_2_BASE:1.75
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.66.0.2
	OPENBSD_4_0_BASE:1.66
	OPENBSD_3_9:1.63.0.2
	OPENBSD_3_9_BASE:1.63
	OPENBSD_3_8:1.49.0.2
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.44.0.2
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.43.0.2
	OPENBSD_3_6_BASE:1.43
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26;
locks; strict;
comment	@ * @;


1.97
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.96;
commitid	airB1W2Kb948lFil;

1.96
date	2016.10.14.16.05.36;	author phessler;	state Exp;
branches;
next	1.95;
commitid	Ai7XVOgXw9ZLovz1;

1.95
date	2015.10.24.08.00.42;	author claudio;	state Exp;
branches;
next	1.94;
commitid	1yCmxaushtq2mDqP;

1.94
date	2015.08.30.23.20.43;	author deraadt;	state Exp;
branches;
next	1.93;
commitid	I8OZ98xpe7zz0YGw;

1.93
date	2014.12.12.18.15.51;	author tedu;	state Exp;
branches;
next	1.92;
commitid	IULaxH7yDKF4X5ok;

1.92
date	2014.10.08.16.15.37;	author deraadt;	state Exp;
branches;
next	1.91;
commitid	8hXaK4f2GeAALziF;

1.91
date	2012.08.12.14.24.56;	author claudio;	state Exp;
branches;
next	1.90;

1.90
date	2012.04.12.17.27.20;	author claudio;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2011.09.20.21.19.06;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2010.12.31.21.22.42;	author guenther;	state Exp;
branches;
next	1.87;

1.87
date	2010.11.18.12.18.31;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2010.10.22.12.37.32;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.84;

1.84
date	2010.05.17.16.08.20;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2010.03.29.09.24.07;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2010.03.05.15.25.00;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2009.12.18.15.51.37;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2009.12.16.15.40.55;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2009.03.19.06.52.59;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2009.02.17.14.10.48;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2009.01.13.21.35.16;	author sthen;	state Exp;
branches;
next	1.76;

1.76
date	2008.05.08.09.51.46;	author henning;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2007.05.22.14.03.31;	author claudio;	state Exp;
branches
	1.75.4.1;
next	1.74;

1.74
date	2007.05.11.11.27.59;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.30.11.41.53;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.30.11.37.15;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2007.03.06.16.52.48;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2007.02.22.08.34.18;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2006.12.21.15.25.19;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2006.12.18.19.16.59;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.27.15.39.56;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.12.14.05.46;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.15.11.26.45;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2006.02.09.21.05.09;	author claudio;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2006.02.09.20.54.56;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2006.02.09.20.50.09;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2006.01.20.15.34.55;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2006.01.20.15.14.40;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2006.01.10.16.11.12;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2006.01.10.16.03.11;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2006.01.05.16.00.07;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2006.01.04.12.45.53;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.03.22.49.17;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.03.22.19.59;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2005.12.30.16.40.15;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2005.12.30.14.07.40;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.19.20.10.55;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.13.15.16.50;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2005.06.10.10.02.21;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2005.06.10.09.58.09;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.16.19.56.31;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.15.16.19.34;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2004.11.10.15.18.11;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.10.13.08.13;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.06.12.04.08;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.05.20.56.12;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.05.18.44.19;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.28.16.02.14;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2004.07.13.17.57.20;	author jaredy;	state Exp;
branches;
next	1.37;

1.37
date	2004.07.05.17.27.32;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.05.02.13.44;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.24.23.15.58;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.24.22.01.54;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.22.23.17.01;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.21.15.36.40;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.17.12.39.32;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.07.10.06.15;	author djm;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.30.05.47.50;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.08.16.08.21;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.20.23.17.35;	author david;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.12.21.53.07;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.12.21.21.39;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.12.21.14.35;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2004.03.12.18.09.23;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.12.10.52.34;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.11.17.12.51;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.11.16.38.23;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.05.22.21.32;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.01.17.04.07;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.27.20.53.56;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.26.14.00.33;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.24.15.44.33;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.23.16.46.24;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.19.23.07.00;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.19.13.54.58;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.19.10.55.41;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.18.23.18.16;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.18.16.36.09;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.18.11.11.06;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.16.18.02.12;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.16.13.21.46;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.16.12.58.45;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.16.12.53.15;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.09.01.56.18;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.04.09.18.03;	author claudio;	state Exp;
branches;
next	;

1.63.2.1
date	2006.05.04.22.22.33;	author brad;	state Exp;
branches;
next	;

1.75.4.1
date	2009.02.18.20.32.08;	author claudio;	state Exp;
branches;
next	;

1.76.2.1
date	2009.02.18.20.30.36;	author claudio;	state Exp;
branches;
next	;

1.90.2.1
date	2012.11.29.20.06.16;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.97
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@/*	$OpenBSD: rde_attr.c,v 1.96 2016/10/14 16:05:36 phessler Exp $ */

/*
 * Copyright (c) 2004 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2016 Job Snijders <job@@instituut.net>
 * Copyright (c) 2016 Peter Hessler <phessler@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <netinet/in.h>

#include <limits.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <siphash.h>

#include "bgpd.h"
#include "rde.h"
#include "log.h"

int
attr_write(void *p, u_int16_t p_len, u_int8_t flags, u_int8_t type,
    void *data, u_int16_t data_len)
{
	u_char		*b = p;
	u_int16_t	 tmp, tot_len = 2; /* attribute header (without len) */

	flags &= ~ATTR_DEFMASK;
	if (data_len > 255) {
		tot_len += 2 + data_len;
		flags |= ATTR_EXTLEN;
	} else {
		tot_len += 1 + data_len;
	}

	if (tot_len > p_len)
		return (-1);

	*b++ = flags;
	*b++ = type;
	if (data_len > 255) {
		tmp = htons(data_len);
		memcpy(b, &tmp, sizeof(tmp));
		b += 2;
	} else
		*b++ = (u_char)data_len;

	if (data_len != 0)
		memcpy(b, data, data_len);

	return (tot_len);
}

int
attr_writebuf(struct ibuf *buf, u_int8_t flags, u_int8_t type, void *data,
    u_int16_t data_len)
{
	u_char	hdr[4];

	flags &= ~ATTR_DEFMASK;
	if (data_len > 255) {
		flags |= ATTR_EXTLEN;
		hdr[2] = (data_len >> 8) & 0xff;
		hdr[3] = data_len & 0xff;
	} else {
		hdr[2] = data_len & 0xff;
	}

	hdr[0] = flags;
	hdr[1] = type;

	if (ibuf_add(buf, hdr, flags & ATTR_EXTLEN ? 4 : 3) == -1)
		return (-1);
	if (ibuf_add(buf, data, data_len) == -1)
		return (-1);
	return (0);
}

/* optional attribute specific functions */
int		 attr_diff(struct attr *, struct attr *);
struct attr	*attr_alloc(u_int8_t, u_int8_t, const void *, u_int16_t);
struct attr	*attr_lookup(u_int8_t, u_int8_t, const void *, u_int16_t);
void		 attr_put(struct attr *);

struct attr_table {
	struct attr_list	*hashtbl;
	u_int32_t		 hashmask;
} attrtable;

SIPHASH_KEY attrtablekey;

#define ATTR_HASH(x)				\
	&attrtable.hashtbl[(x) & attrtable.hashmask]

void
attr_init(u_int32_t hashsize)
{
	u_int32_t	hs, i;

	arc4random_buf(&attrtablekey, sizeof(attrtablekey));
	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	attrtable.hashtbl = calloc(hs, sizeof(struct attr_list));
	if (attrtable.hashtbl == NULL)
		fatal("attr_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&attrtable.hashtbl[i]);

	attrtable.hashmask = hs - 1;
}

void
attr_shutdown(void)
{
	u_int32_t	i;

	for (i = 0; i <= attrtable.hashmask; i++)
		if (!LIST_EMPTY(&attrtable.hashtbl[i]))
			log_warnx("attr_shutdown: free non-free table");

	free(attrtable.hashtbl);
}

int
attr_optadd(struct rde_aspath *asp, u_int8_t flags, u_int8_t type,
    void *data, u_int16_t len)
{
	u_int8_t	 l;
	struct attr	*a, *t;
	void		*p;

	/* known optional attributes were validated previously */
	if ((a = attr_lookup(flags, type, data, len)) == NULL)
		a = attr_alloc(flags, type, data, len);

	/* attribute allowed only once */
	for (l = 0; l < asp->others_len; l++) {
		if (asp->others[l] == NULL)
			break;
		if (type == asp->others[l]->type) {
			if (a->refcnt == 0)
				attr_put(a);
			return (-1);
		}
	}

	/* add attribute to the table but first bump refcnt */
	a->refcnt++;
	rdemem.attr_refs++;

	for (l = 0; l < asp->others_len; l++) {
		if (asp->others[l] == NULL) {
			asp->others[l] = a;
			return (0);
		}
		/* list is sorted */
		if (a->type < asp->others[l]->type) {
			t = asp->others[l];
			asp->others[l] = a;
			a = t;
		}
	}

	/* no empty slot found, need to realloc */
	if (asp->others_len == UCHAR_MAX)
		fatalx("attr_optadd: others_len overflow");

	asp->others_len++;
	if ((p = reallocarray(asp->others,
	    asp->others_len, sizeof(struct attr *))) == NULL)
		fatal("attr_optadd");
	asp->others = p;

	/* l stores the size of others before resize */
	asp->others[l] = a;
	return (0);
}

struct attr *
attr_optget(const struct rde_aspath *asp, u_int8_t type)
{
	u_int8_t	 l;

	for (l = 0; l < asp->others_len; l++) {
		if (asp->others[l] == NULL)
			break;
		if (type == asp->others[l]->type)
			return (asp->others[l]);
		if (type < asp->others[l]->type)
			break;
	}
	return (NULL);
}

void
attr_copy(struct rde_aspath *t, struct rde_aspath *s)
{
	u_int8_t	l;

	if (t->others != NULL)
		attr_freeall(t);

	t->others_len = s->others_len;
	if (t->others_len == 0) {
		t->others = NULL;
		return;
	}

	if ((t->others = calloc(s->others_len, sizeof(struct attr *))) == 0)
		fatal("attr_copy");

	for (l = 0; l < t->others_len; l++) {
		if (s->others[l] == NULL)
			break;
		s->others[l]->refcnt++;
		rdemem.attr_refs++;
		t->others[l] = s->others[l];
	}
}

int
attr_diff(struct attr *oa, struct attr *ob)
{
	int	r;

	if (ob == NULL)
		return (1);
	if (oa == NULL)
		return (-1);
	if (oa->flags > ob->flags)
		return (1);
	if (oa->flags < ob->flags)
		return (-1);
	if (oa->type > ob->type)
		return (1);
	if (oa->type < ob->type)
		return (-1);
	if (oa->len > ob->len)
		return (1);
	if (oa->len < ob->len)
		return (-1);
	r = memcmp(oa->data, ob->data, oa->len);
	if (r > 0)
		return (1);
	if (r < 0)
		return (-1);

	fatalx("attr_diff: equal attributes encountered");
	return (0);
}

int
attr_compare(struct rde_aspath *a, struct rde_aspath *b)
{
	u_int8_t	l, min;

	min = a->others_len < b->others_len ? a->others_len : b->others_len;
	for (l = 0; l < min; l++)
		if (a->others[l] != b->others[l])
			return (attr_diff(a->others[l], b->others[l]));

	if (a->others_len < b->others_len) {
		for (; l < b->others_len; l++)
			if (b->others[l] != NULL)
				return (-1);
	} else if (a->others_len > b->others_len) {
		for (; l < a->others_len; l++)
			if (a->others[l] != NULL)
				return (1);
	}

	return (0);
}

void
attr_free(struct rde_aspath *asp, struct attr *attr)
{
	u_int8_t	l;

	for (l = 0; l < asp->others_len; l++)
		if (asp->others[l] == attr) {
			attr_put(asp->others[l]);
			for (++l; l < asp->others_len; l++)
				asp->others[l - 1] = asp->others[l];
			asp->others[asp->others_len - 1] = NULL;
			return;
		}

	/* no realloc() because the slot may be reused soon */
}

void
attr_freeall(struct rde_aspath *asp)
{
	u_int8_t	l;

	for (l = 0; l < asp->others_len; l++)
		attr_put(asp->others[l]);

	free(asp->others);
	asp->others = NULL;
	asp->others_len = 0;
}

struct attr *
attr_alloc(u_int8_t flags, u_int8_t type, const void *data, u_int16_t len)
{
	struct attr	*a;
	SIPHASH_CTX	ctx;

	a = calloc(1, sizeof(struct attr));
	if (a == NULL)
		fatal("attr_optadd");
	rdemem.attr_cnt++;

	flags &= ~ATTR_DEFMASK;	/* normalize mask */
	a->flags = flags;
	a->type = type;
	a->len = len;
	if (len != 0) {
		if ((a->data = malloc(len)) == NULL)
			fatal("attr_optadd");

		rdemem.attr_dcnt++;
		rdemem.attr_data += len;
		memcpy(a->data, data, len);
	} else
		a->data = NULL;

	SipHash24_Init(&ctx, &attrtablekey);
	SipHash24_Update(&ctx, &flags, sizeof(flags));
	SipHash24_Update(&ctx, &type, sizeof(type));
	SipHash24_Update(&ctx, &len, sizeof(len));
	SipHash24_Update(&ctx, a->data, a->len);
	a->hash = SipHash24_End(&ctx);
	LIST_INSERT_HEAD(ATTR_HASH(a->hash), a, entry);

	return (a);
}

struct attr *
attr_lookup(u_int8_t flags, u_int8_t type, const void *data, u_int16_t len)
{
	struct attr_list	*head;
	struct attr		*a;
	u_int32_t		 hash;
	SIPHASH_CTX		ctx;

	flags &= ~ATTR_DEFMASK;	/* normalize mask */

	SipHash24_Init(&ctx, &attrtablekey);
	SipHash24_Update(&ctx, &flags, sizeof(flags));
	SipHash24_Update(&ctx, &type, sizeof(type));
	SipHash24_Update(&ctx, &len, sizeof(len));
	SipHash24_Update(&ctx, data, len);
	hash = SipHash24_End(&ctx);
	head = ATTR_HASH(hash);

	LIST_FOREACH(a, head, entry) {
		if (hash == a->hash && type == a->type &&
		    flags == a->flags && len == a->len &&
		    memcmp(data, a->data, len) == 0)
			return (a);
	}
	return (NULL);
}

void
attr_put(struct attr *a)
{
	if (a == NULL)
		return;

	rdemem.attr_refs--;
	if (--a->refcnt > 0)
		/* somebody still holds a reference */
		return;

	/* unlink */
	LIST_REMOVE(a, entry);

	if (a->len != 0)
		rdemem.attr_dcnt--;
	rdemem.attr_data -= a->len;
	rdemem.attr_cnt--;
	free(a->data);
	free(a);
}

/* aspath specific functions */

u_int16_t	 aspath_countlength(struct aspath *, u_int16_t, int);
void		 aspath_countcopy(struct aspath *, u_int16_t, u_int8_t *,
		     u_int16_t, int);
struct aspath	*aspath_lookup(const void *, u_int16_t);

struct aspath_table {
	struct aspath_list	*hashtbl;
	u_int32_t		 hashmask;
} astable;

SIPHASH_KEY astablekey;

#define ASPATH_HASH(x)				\
	&astable.hashtbl[(x) & astable.hashmask]

int
aspath_verify(void *data, u_int16_t len, int as4byte)
{
	u_int8_t	*seg = data;
	u_int16_t	 seg_size, as_size = 2;
	u_int8_t	 seg_len, seg_type;
	int		 error = 0;

	if (len & 1)
		/* odd length aspath are invalid */
		return (AS_ERR_BAD);

	if (as4byte)
		as_size = 4;

	for (; len > 0; len -= seg_size, seg += seg_size) {
		if (len < 2)	/* header length check */
			return (AS_ERR_BAD);
		seg_type = seg[0];
		seg_len = seg[1];

		/*
		 * BGP confederations should not show up but consider them
		 * as a soft error which invalidates the path but keeps the
		 * bgp session running.
		 */
		if (seg_type == AS_CONFED_SEQUENCE || seg_type == AS_CONFED_SET)
			error = AS_ERR_SOFT;
		if (seg_type != AS_SET && seg_type != AS_SEQUENCE &&
		    seg_type != AS_CONFED_SEQUENCE && seg_type != AS_CONFED_SET)
			return (AS_ERR_TYPE);

		seg_size = 2 + as_size * seg_len;

		if (seg_size > len)
			return (AS_ERR_LEN);

		if (seg_size == 0)
			/* empty aspath segments are not allowed */
			return (AS_ERR_BAD);
	}
	return (error);	/* aspath is valid but probably not loop free */
}

void
aspath_init(u_int32_t hashsize)
{
	u_int32_t	hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	astable.hashtbl = calloc(hs, sizeof(struct aspath_list));
	if (astable.hashtbl == NULL)
		fatal("aspath_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&astable.hashtbl[i]);

	astable.hashmask = hs - 1;
	arc4random_buf(&astablekey, sizeof(astablekey));
}

void
aspath_shutdown(void)
{
	u_int32_t	i;

	for (i = 0; i <= astable.hashmask; i++)
		if (!LIST_EMPTY(&astable.hashtbl[i]))
			log_warnx("aspath_shutdown: free non-free table");

	free(astable.hashtbl);
}

struct aspath *
aspath_get(void *data, u_int16_t len)
{
	struct aspath_list	*head;
	struct aspath		*aspath;

	/* The aspath must already have been checked for correctness. */
	aspath = aspath_lookup(data, len);
	if (aspath == NULL) {
		aspath = malloc(ASPATH_HEADER_SIZE + len);
		if (aspath == NULL)
			fatal("aspath_get");

		rdemem.aspath_cnt++;
		rdemem.aspath_size += ASPATH_HEADER_SIZE + len;

		aspath->refcnt = 0;
		aspath->len = len;
		aspath->ascnt = aspath_count(data, len);
		memcpy(aspath->data, data, len);

		/* link */
		head = ASPATH_HASH(SipHash24(&astablekey, aspath->data,
		    aspath->len));
		LIST_INSERT_HEAD(head, aspath, entry);
	}
	aspath->refcnt++;
	rdemem.aspath_refs++;

	return (aspath);
}

void
aspath_put(struct aspath *aspath)
{
	if (aspath == NULL)
		return;

	rdemem.aspath_refs--;
	if (--aspath->refcnt > 0) {
		/* somebody still holds a reference */
		return;
	}

	/* unlink */
	LIST_REMOVE(aspath, entry);

	rdemem.aspath_cnt--;
	rdemem.aspath_size -= ASPATH_HEADER_SIZE + aspath->len;
	free(aspath);
}

u_char *
aspath_inflate(void *data, u_int16_t len, u_int16_t *newlen)
{
	u_int8_t	*seg, *nseg, *ndata;
	u_int16_t	 seg_size, olen, nlen;
	u_int8_t	 seg_len;

	/* first calculate the length of the aspath */
	seg = data;
	nlen = 0;
	for (olen = len; olen > 0; olen -= seg_size, seg += seg_size) {
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int16_t) * seg_len;
		nlen += 2 + sizeof(u_int32_t) * seg_len;

		if (seg_size > olen)
			fatalx("aspath_inflate: would overflow");
	}

	*newlen = nlen;
	if ((ndata = malloc(nlen)) == NULL)
		fatal("aspath_inflate");

	/* then copy the aspath */
	seg = data;
	for (nseg = ndata; nseg < ndata + nlen; ) {
		*nseg++ = *seg++;
		*nseg++ = seg_len = *seg++;
		for (; seg_len > 0; seg_len--) {
			*nseg++ = 0;
			*nseg++ = 0;
			*nseg++ = *seg++;
			*nseg++ = *seg++;
		}
	}

	return (ndata);
}

/* convert a 4 byte aspath to a 2byte one. data is freed by aspath_deflate */
u_char *
aspath_deflate(u_char *data, u_int16_t *len, int *flagnew)
{
	u_int8_t	*seg, *nseg, *ndata;
	u_int32_t	 as;
	int		 i;
	u_int16_t	 seg_size, olen, nlen;
	u_int8_t	 seg_len;

	/* first calculate the length of the aspath */
	nlen = 0;
	seg = data;
	olen = *len;
	for (; olen > 0; olen -= seg_size, seg += seg_size) {
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;
		nlen += 2 + sizeof(u_int16_t) * seg_len;

		if (seg_size > olen)
			fatalx("aspath_deflate: would overflow");
	}

	if ((ndata = malloc(nlen)) == NULL)
		fatal("aspath_deflate");

	/* then copy the aspath */
	seg = data;
	olen = *len;
	for (nseg = ndata; seg < data + olen; seg += seg_size) {
		*nseg++ = seg[0];
		*nseg++ = seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;

		for (i = 0; i < seg_len; i++) {
			as = aspath_extract(seg, i);
			if (as > USHRT_MAX) {
				as = AS_TRANS;
				*flagnew = 1;
			}
			*nseg++ = (as >> 8) & 0xff;
			*nseg++ = as & 0xff;
		}
	}

	free(data);
	*len = nlen;
	return (ndata);
}

void
aspath_merge(struct rde_aspath *a, struct attr *attr)
{
	u_int8_t	*np;
	u_int16_t	 ascnt, diff, nlen, difflen;
	int		 hroom = 0;

	ascnt = aspath_count(attr->data, attr->len);
	if (ascnt > a->aspath->ascnt) {
		/* ASPATH is shorter then AS4_PATH no way to merge */
		attr_free(a, attr);
		return;
	}

	diff = a->aspath->ascnt - ascnt;
	if (diff && attr->len > 2 && attr->data[0] == AS_SEQUENCE)
		hroom = attr->data[1];
	difflen = aspath_countlength(a->aspath, diff, hroom);
	nlen = attr->len + difflen;

	if ((np = malloc(nlen)) == NULL)
		fatal("aspath_merge");

	/* copy head from old aspath */
	aspath_countcopy(a->aspath, diff, np, difflen, hroom);

	/* copy tail from new aspath */
	if (hroom > 0)
		memcpy(np + nlen - attr->len + 2, attr->data + 2,
		    attr->len - 2);
	else
		memcpy(np + nlen - attr->len, attr->data, attr->len);

	aspath_put(a->aspath);
	a->aspath = aspath_get(np, nlen);
	free(np);
	attr_free(a, attr);
}

u_char *
aspath_dump(struct aspath *aspath)
{
	return (aspath->data);
}

u_int16_t
aspath_length(struct aspath *aspath)
{
	return (aspath->len);
}

u_int16_t
aspath_count(const void *data, u_int16_t len)
{
	const u_int8_t	*seg;
	u_int16_t	 cnt, seg_size;
	u_int8_t	 seg_type, seg_len;

	cnt = 0;
	seg = data;
	for (; len > 0; len -= seg_size, seg += seg_size) {
		seg_type = seg[0];
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;

		if (seg_type == AS_SET)
			cnt += 1;
		else
			cnt += seg_len;

		if (seg_size > len)
			fatalx("aspath_count: would overflow");
	}
	return (cnt);
}

u_int16_t
aspath_countlength(struct aspath *aspath, u_int16_t cnt, int headcnt)
{
	const u_int8_t	*seg;
	u_int16_t	 seg_size, len, clen;
	u_int8_t	 seg_type = 0, seg_len = 0;

	seg = aspath->data;
	clen = 0;
	for (len = aspath->len; len > 0 && cnt > 0;
	    len -= seg_size, seg += seg_size) {
		seg_type = seg[0];
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;

		if (seg_type == AS_SET)
			cnt -= 1;
		else if (seg_len > cnt) {
			seg_len = cnt;
			clen += 2 + sizeof(u_int32_t) * cnt;
			break;
		} else
			cnt -= seg_len;

		clen += seg_size;

		if (seg_size > len)
			fatalx("aspath_countlength: would overflow");
	}
	if (headcnt > 0 && seg_type == AS_SEQUENCE && headcnt + seg_len < 256)
		/* no need for additional header from the new aspath. */
		clen -= 2;

	return (clen);
}

void
aspath_countcopy(struct aspath *aspath, u_int16_t cnt, u_int8_t *buf,
    u_int16_t size, int headcnt)
{
	const u_int8_t	*seg;
	u_int16_t	 seg_size, len;
	u_int8_t	 seg_type, seg_len;

	if (headcnt > 0)
		/*
		 * additional room because we steal the segment header
		 * from the other aspath
		 */
		size += 2;
	seg = aspath->data;
	for (len = aspath->len; len > 0 && cnt > 0;
	    len -= seg_size, seg += seg_size) {
		seg_type = seg[0];
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;

		if (seg_type == AS_SET)
			cnt -= 1;
		else if (seg_len > cnt) {
			seg_len = cnt + headcnt;
			seg_size = 2 + sizeof(u_int32_t) * cnt;
			cnt = 0;
		} else {
			cnt -= seg_len;
			if (cnt == 0)
				seg_len += headcnt;
		}

		memcpy(buf, seg, seg_size);
		buf[0] = seg_type;
		buf[1] = seg_len;
		buf += seg_size;
		if (size < seg_size)
			fatalx("aspath_countlength: would overflow");
		size -= seg_size;
	}
}

u_int32_t
aspath_neighbor(struct aspath *aspath)
{
	/* Empty aspath is OK -- internal AS route. */
	if (aspath->len == 0)
		return (rde_local_as());
	return (aspath_extract(aspath->data, 0));
}

int
aspath_loopfree(struct aspath *aspath, u_int32_t myAS)
{
	u_int8_t	*seg;
	u_int16_t	 len, seg_size;
	u_int8_t	 i, seg_len;

	seg = aspath->data;
	for (len = aspath->len; len > 0; len -= seg_size, seg += seg_size) {
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;

		for (i = 0; i < seg_len; i++) {
			if (myAS == aspath_extract(seg, i))
				return (0);
		}

		if (seg_size > len)
			fatalx("aspath_loopfree: would overflow");
	}
	return (1);
}

int
aspath_compare(struct aspath *a1, struct aspath *a2)
{
	int r;

	if (a1->len > a2->len)
		return (1);
	if (a1->len < a2->len)
		return (-1);
	r = memcmp(a1->data, a2->data, a1->len);
	if (r > 0)
		return (1);
	if (r < 0)
		return (-1);
	return (0);
}

struct aspath *
aspath_lookup(const void *data, u_int16_t len)
{
	struct aspath_list	*head;
	struct aspath		*aspath;
	u_int32_t		 hash;

	hash = SipHash24(&astablekey, data, len);
	head = ASPATH_HASH(hash);

	LIST_FOREACH(aspath, head, entry) {
		if (len == aspath->len && memcmp(data, aspath->data, len) == 0)
			return (aspath);
	}
	return (NULL);
}


/*
 * Returns a new prepended aspath. Old needs to be freed by caller.
 */
u_char *
aspath_prepend(struct aspath *asp, u_int32_t as, int quantum, u_int16_t *len)
{
	u_char		*p;
	int		 l, overflow = 0, shift = 0, size, wpos = 0;
	u_int8_t	 type;

	/* lunatic prepends are blocked in the parser and limited */

	/* first calculate new size */
	if (asp->len > 0) {
		if (asp->len < 2)
			fatalx("aspath_prepend: bad aspath length");
		type = asp->data[0];
		size = asp->data[1];
	} else {
		/* empty as path */
		type = AS_SET;
		size = 0;
	}

	if (quantum > 255)
		fatalx("aspath_prepend: preposterous prepend");
	if (quantum == 0) {
		/* no change needed but return a copy */
		p = malloc(asp->len);
		if (p == NULL)
			fatal("aspath_prepend");
		memcpy(p, asp->data, asp->len);
		*len = asp->len;
		return (p);
	} else if (type == AS_SET || size + quantum > 255) {
		/* need to attach a new AS_SEQUENCE */
		l = 2 + quantum * sizeof(u_int32_t) + asp->len;
		if (type == AS_SET)
			overflow = quantum;
		else
			overflow = size + quantum - 255;
	} else
		l = quantum * sizeof(u_int32_t) + asp->len;

	quantum -= overflow;

	p = malloc(l);
	if (p == NULL)
		fatal("aspath_prepend");

	/* first prepends */
	as = htonl(as);
	if (overflow > 0) {
		p[wpos++] = AS_SEQUENCE;
		p[wpos++] = overflow;

		for (; overflow > 0; overflow--) {
			memcpy(p + wpos, &as, sizeof(u_int32_t));
			wpos += sizeof(u_int32_t);
		}
	}
	if (quantum > 0) {
		shift = 2;
		p[wpos++] = AS_SEQUENCE;
		p[wpos++] = quantum + size;

		for (; quantum > 0; quantum--) {
			memcpy(p + wpos, &as, sizeof(u_int32_t));
			wpos += sizeof(u_int32_t);
		}
	}
	memcpy(p + wpos, asp->data + shift, asp->len - shift);

	*len = l;
	return (p);
}

int
aspath_lenmatch(struct aspath *a, enum aslen_spec type, u_int aslen)
{
	u_int8_t	*seg;
	u_int32_t	 as, lastas = 0;
	u_int		 count = 0;
	u_int16_t	 len, seg_size;
	u_int8_t	 i, seg_len;

	if (type == ASLEN_MAX) {
		if (aslen < aspath_count(a->data, a->len))
			return (1);
		else
			return (0);
	}

	/* type == ASLEN_SEQ */
	seg = a->data;
	for (len = a->len; len > 0; len -= seg_size, seg += seg_size) {
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;

		for (i = 0; i < seg_len; i++) {
			/* what should we do with AS_SET? */
			as = aspath_extract(seg, i);
			if (as == lastas) {
				if (aslen < ++count)
					return (1);
			} else
				count = 1;
			lastas = as;
		}
	}
	return (0);
}

/*
 * Functions handling communities and extended communities.
 */

int community_ext_matchone(struct filter_extcommunity *, u_int16_t, u_int64_t);

int
community_match(struct rde_aspath *asp, int as, int type)
{
	struct attr	*a;
	u_int8_t	*p;
	u_int16_t	 eas, etype, len;

	a = attr_optget(asp, ATTR_COMMUNITIES);
	if (a == NULL)
		/* no communities, no match */
		return (0);

	p = a->data;
	for (len = a->len / 4; len > 0; len--) {
		eas = *p++;
		eas <<= 8;
		eas |= *p++;
		etype = *p++;
		etype <<= 8;
		etype |= *p++;
		if ((as == COMMUNITY_ANY || (u_int16_t)as == eas) &&
		    (type == COMMUNITY_ANY || (u_int16_t)type == etype))
			return (1);
	}
	return (0);
}

int
community_set(struct rde_aspath *asp, int as, int type)
{
	struct attr	*attr;
	u_int8_t	*p = NULL;
	unsigned int	 i, ncommunities = 0;
	u_int8_t	 f = ATTR_OPTIONAL|ATTR_TRANSITIVE;

	attr = attr_optget(asp, ATTR_COMMUNITIES);
	if (attr != NULL) {
		p = attr->data;
		ncommunities = attr->len / 4;
	}

	/* first check if the community is not already set */
	for (i = 0; i < ncommunities; i++) {
		if (as >> 8 == p[0] && (as & 0xff) == p[1] &&
		    type >> 8 == p[2] && (type & 0xff) == p[3])
			/* already present, nothing todo */
			return (1);
		p += 4;
	}

	if (ncommunities++ >= USHRT_MAX / 4)
		/* overflow */
		return (0);

	if ((p = reallocarray(NULL, ncommunities, 4)) == NULL)
		fatal("community_set");

	p[0] = as >> 8;
	p[1] = as & 0xff;
	p[2] = type >> 8;
	p[3] = type & 0xff;

	if (attr != NULL) {
		memcpy(p + 4, attr->data, attr->len);
		f = attr->flags;
		attr_free(asp, attr);
	}

	attr_optadd(asp, f, ATTR_COMMUNITIES, p, ncommunities * 4);

	free(p);
	return (1);
}

void
community_delete(struct rde_aspath *asp, int as, int type)
{
	struct attr	*attr;
	u_int8_t	*p, *n;
	u_int16_t	 l, len = 0;
	u_int16_t	 eas, etype;
	u_int8_t	 f;

	attr = attr_optget(asp, ATTR_COMMUNITIES);
	if (attr == NULL)
		/* no attr nothing to do */
		return;

	p = attr->data;
	for (l = 0; l < attr->len; l += 4) {
		eas = *p++;
		eas <<= 8;
		eas |= *p++;
		etype = *p++;
		etype <<= 8;
		etype |= *p++;

		if ((as == COMMUNITY_ANY || (u_int16_t)as == eas) &&
		    (type == COMMUNITY_ANY || (u_int16_t)type == etype))
			/* match */
			continue;
		len += 4;
	}

	if (len == 0) {
		attr_free(asp, attr);
		return;
	}

	if ((n = malloc(len)) == NULL)
		fatal("community_delete");

	p = attr->data;
	for (l = 0; l < len && p < attr->data + attr->len; ) {
		eas = *p++;
		eas <<= 8;
		eas |= *p++;
		etype = *p++;
		etype <<= 8;
		etype |= *p++;

		if ((as == COMMUNITY_ANY || (u_int16_t)as == eas) &&
		    (type == COMMUNITY_ANY || (u_int16_t)type == etype))
			/* match */
			continue;
		n[l++] = eas >> 8;
		n[l++] = eas & 0xff;
		n[l++] = etype >> 8;
		n[l++] = etype & 0xff;
	}

	f = attr->flags;

	attr_free(asp, attr);
	attr_optadd(asp, f, ATTR_COMMUNITIES, n, len);
	free(n);
}

int
community_ext_match(struct rde_aspath *asp, struct filter_extcommunity *c,
    u_int16_t neighas)
{
	struct attr	*attr;
	u_int8_t	*p;
	u_int64_t	 ec;
	u_int16_t	 len;

	attr = attr_optget(asp, ATTR_EXT_COMMUNITIES);
	if (attr == NULL)
		/* no communities, no match */
		return (0);

	p = attr->data;
	for (len = attr->len / sizeof(ec); len > 0; len--) {
		memcpy(&ec, p, sizeof(ec));
		if (community_ext_matchone(c, neighas, ec))
			return (1);
		p += sizeof(ec);
	}

	return (0);
}

int
community_ext_set(struct rde_aspath *asp, struct filter_extcommunity *c,
    u_int16_t neighas)
{
	struct attr	*attr;
	u_int8_t	*p = NULL;
	u_int64_t	 community;
	unsigned int	 i, ncommunities = 0;
	u_int8_t	 f = ATTR_OPTIONAL|ATTR_TRANSITIVE;

	if (community_ext_conv(c, neighas, &community))
		return (0);

	attr = attr_optget(asp, ATTR_EXT_COMMUNITIES);
	if (attr != NULL) {
		p = attr->data;
		ncommunities = attr->len / sizeof(community);
	}

	/* first check if the community is not already set */
	for (i = 0; i < ncommunities; i++) {
		if (memcmp(&community, p, sizeof(community)) == 0)
			/* already present, nothing todo */
			return (1);
		p += sizeof(community);
	}

	if (ncommunities++ >= USHRT_MAX / sizeof(community))
		/* overflow */
		return (0);

	if ((p = reallocarray(NULL, ncommunities, sizeof(community))) == NULL)
		fatal("community_ext_set");

	memcpy(p, &community, sizeof(community));
	if (attr != NULL) {
		memcpy(p + sizeof(community), attr->data, attr->len);
		f = attr->flags;
		attr_free(asp, attr);
	}

	attr_optadd(asp, f, ATTR_EXT_COMMUNITIES, p,
	    ncommunities * sizeof(community));

	free(p);
	return (1);
}

void
community_ext_delete(struct rde_aspath *asp, struct filter_extcommunity *c,
    u_int16_t neighas)
{
	struct attr	*attr;
	u_int8_t	*p, *n;
	u_int64_t	 community;
	u_int16_t	 l, len = 0;
	u_int8_t	 f;

	if (community_ext_conv(c, neighas, &community))
		return;

	attr = attr_optget(asp, ATTR_EXT_COMMUNITIES);
	if (attr == NULL)
		/* no attr nothing to do */
		return;

	p = attr->data;
	for (l = 0; l < attr->len; l += sizeof(community)) {
		if (memcmp(&community, p + l, sizeof(community)) == 0)
			/* match */
			continue;
		len += sizeof(community);
	}

	if (len == 0) {
		attr_free(asp, attr);
		return;
	}

	if ((n = malloc(len)) == NULL)
		fatal("community_delete");

	p = attr->data;
	for (l = 0; l < len && p < attr->data + attr->len;
	    p += sizeof(community)) {
		if (memcmp(&community, p, sizeof(community)) == 0)
			/* match */
			continue;
		memcpy(n + l, p, sizeof(community));
		l += sizeof(community);
	}

	f = attr->flags;

	attr_free(asp, attr);
	attr_optadd(asp, f, ATTR_EXT_COMMUNITIES, n, len);
	free(n);
}

int
community_ext_conv(struct filter_extcommunity *c, u_int16_t neighas,
    u_int64_t *community)
{
	u_int64_t	com;
	u_int32_t	ip;

	com = (u_int64_t)c->type << 56;
	switch (c->type & EXT_COMMUNITY_VALUE) {
	case EXT_COMMUNITY_TWO_AS:
		com |= (u_int64_t)c->subtype << 48;
		com |= (u_int64_t)c->data.ext_as.as << 32;
		com |= c->data.ext_as.val;
		break;
	case EXT_COMMUNITY_IPV4:
		com |= (u_int64_t)c->subtype << 48;
		ip = ntohl(c->data.ext_ip.addr.s_addr);
		com |= (u_int64_t)ip << 16;
		com |= c->data.ext_ip.val;
		break;
	case EXT_COMMUNITY_FOUR_AS:
		com |= (u_int64_t)c->subtype << 48;
		com |= (u_int64_t)c->data.ext_as4.as4 << 16;
		com |= c->data.ext_as4.val;
		break;
	case EXT_COMMUNITY_OPAQUE:
		com |= (u_int64_t)c->subtype << 48;
		com |= c->data.ext_opaq & EXT_COMMUNITY_OPAQUE_MAX;
		break;
	default:
		com |= c->data.ext_opaq & 0xffffffffffffffULL;
		break;
	}

	*community = htobe64(com);

	return (0);
}

int
community_ext_matchone(struct filter_extcommunity *c, u_int16_t neighas,
    u_int64_t community)
{
	u_int64_t	com, mask;
	u_int32_t	ip;

	community = betoh64(community);

	com = (u_int64_t)c->type << 56;
	mask = 0xffULL << 56;
	if ((com & mask) != (community & mask))
		return (0);

	switch (c->type & EXT_COMMUNITY_VALUE) {
	case EXT_COMMUNITY_TWO_AS:
	case EXT_COMMUNITY_IPV4:
	case EXT_COMMUNITY_FOUR_AS:
	case EXT_COMMUNITY_OPAQUE:
		com = (u_int64_t)c->subtype << 48;
		mask = 0xffULL << 48;
		if ((com & mask) != (community & mask))
			return (0);
		break;
	default:
		com = c->data.ext_opaq & 0xffffffffffffffULL;
		mask = 0xffffffffffffffULL;
		if ((com & mask) == (community & mask))
			return (1);
		return (0);
	}


	switch (c->type & EXT_COMMUNITY_VALUE) {
	case EXT_COMMUNITY_TWO_AS:
		com = (u_int64_t)c->data.ext_as.as << 32;
		mask = 0xffffULL << 32;
		if ((com & mask) != (community & mask))
			return (0);

		com = c->data.ext_as.val;
		mask = 0xffffffffULL;
		if ((com & mask) == (community & mask))
			return (1);
		break;
	case EXT_COMMUNITY_IPV4:
		ip = ntohl(c->data.ext_ip.addr.s_addr);
		com = (u_int64_t)ip << 16;
		mask = 0xffffffff0000ULL;
		if ((com & mask) != (community & mask))
			return (0);

		com = c->data.ext_ip.val;
		mask = 0xffff;
		if ((com & mask) == (community & mask))
			return (1);
		break;
	case EXT_COMMUNITY_FOUR_AS:
		com = (u_int64_t)c->data.ext_as4.as4 << 16;
		mask = 0xffffffffULL << 16;
		if ((com & mask) != (community & mask))
			return (0);

		com = c->data.ext_as4.val;
		mask = 0xffff;
		if ((com & mask) == (community & mask))
			return (1);
		break;
	case EXT_COMMUNITY_OPAQUE:
		com = c->data.ext_opaq & EXT_COMMUNITY_OPAQUE_MAX;
		mask = EXT_COMMUNITY_OPAQUE_MAX;
		if ((com & mask) == (community & mask))
			return (1);
		break;
	}

	return (0);
}

int
community_large_match(struct rde_aspath *asp, int64_t as, int64_t ld1,
    int64_t ld2)
{
	struct wire_largecommunity	*bar;
	struct attr	*a;
	u_int8_t	*p;
	u_int16_t	 len;
	u_int32_t	 eas, eld1, eld2;

	a = attr_optget(asp, ATTR_LARGE_COMMUNITIES);
	if (a == NULL)
		/* no communities, no match */
		return (0);

	p = a->data;
	for (len = a->len / 12; len > 0; len--) {
		bar = (struct wire_largecommunity *)p;
		p += 12;
		eas = betoh32(bar->as);
		eld1 = betoh32(bar->ld1);
		eld2 = betoh32(bar->ld2);

		if ((as == COMMUNITY_ANY || as == eas) &&
		    (ld1 == COMMUNITY_ANY || ld1 == eld1) &&
		    (ld2 == COMMUNITY_ANY || ld2 == eld2))
			return (1);
	}
	return (0);
}

int
community_large_set(struct rde_aspath *asp, int64_t as, int64_t ld1,
    int64_t ld2)
{
	struct wire_largecommunity	*bar;
	struct attr	*attr;
	u_int8_t	*p = NULL;
	unsigned int	 i, ncommunities = 0;
	u_int8_t	 f = ATTR_OPTIONAL|ATTR_TRANSITIVE;

	attr = attr_optget(asp, ATTR_LARGE_COMMUNITIES);
	if (attr != NULL) {
		p = attr->data;
		ncommunities = attr->len / 12;
	}

	/* first check if the community is not already set */
	for (i = 0; i < ncommunities; i++) {
		bar = (struct wire_largecommunity *)p;
		if (bar->as == as && bar->ld1 == ld1 && bar->ld2 == ld2)
			/* already present, nothing todo */
			return (1);
		p += 12;
	}

	if (ncommunities++ >= USHRT_MAX / 12)
		/* overflow */
		return (0);

	if ((p = reallocarray(NULL, ncommunities, 12)) == NULL)
		fatal("community_set");

	bar = (struct wire_largecommunity *)p;
	bar->as = htobe32(as);
	bar->ld1 = htobe32(ld1);
	bar->ld2 = htobe32(ld2);

	if (attr != NULL) {
		memcpy(p + 12, attr->data, attr->len);
		f = attr->flags;
		attr_free(asp, attr);
	}

	attr_optadd(asp, f, ATTR_LARGE_COMMUNITIES, p, ncommunities * 12);

	free(p);
	return (1);
}

void
community_large_delete(struct rde_aspath *asp, int64_t as, int64_t ld1,
    int64_t ld2)
{
	struct wire_largecommunity	*bar;
	struct attr	*attr;
	u_int8_t	*p, *n;
	u_int16_t	 l = 0, len = 0;
	u_int32_t	 eas, eld1, eld2;
	u_int8_t	 f;

	attr = attr_optget(asp, ATTR_LARGE_COMMUNITIES);
	if (attr == NULL)
		/* no attr nothing to do */
		return;

	p = attr->data;
	for (len = 0; l < attr->len; l += 12) {
		bar = (struct wire_largecommunity *)p;
		p += 12;
		eas = betoh32(bar->as);
		eld1 = betoh32(bar->ld1);
		eld2 = betoh32(bar->ld2);

		if ((as == COMMUNITY_ANY || as == eas) &&
		    (ld1 == COMMUNITY_ANY || ld1 == eld1) &&
		    (ld2 == COMMUNITY_ANY || ld2 == eld2))
			/* match */
			continue;
		len += 12;
	}

	if (len == 0) {
		attr_free(asp, attr);
		return;
	}

	if ((n = malloc(len)) == NULL)
		fatal("community_delete");

	p = attr->data;
	for (l = 0; l < len && p < attr->data + attr->len; ) {
		bar = (struct wire_largecommunity *)p;
		p += 12;
		eas = betoh32(bar->as);
		eld1 = betoh32(bar->ld1);
		eld2 = betoh32(bar->ld2);

		if ((as == COMMUNITY_ANY || as == eas) &&
		    (ld1 == COMMUNITY_ANY || ld1 == eld1) &&
		    (ld2 == COMMUNITY_ANY || ld2 == eld2))
			/* match */
			continue;
		memcpy(n + l, bar, sizeof(*bar));
		l += 12;
	}

	f = attr->flags;

	attr_free(asp, attr);
	attr_optadd(asp, f, ATTR_LARGE_COMMUNITIES, n, len);
	free(n);
}
@


1.96
log
@Add support for draft-ietf-idr-large-community

Joint work with Job Snijders, many thanks!
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.95 2015/10/24 08:00:42 claudio Exp $ */
d34 1
@


1.95
log
@seg_type is only set but never used. So remove it. Someone reported this
long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.94 2015/08/30 23:20:43 deraadt Exp $ */
d5 2
d1356 144
@


1.94
log
@rename a variable "err" to "error"
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.93 2014/12/12 18:15:51 tedu Exp $ */
d804 1
a804 1
	u_int8_t	 i, seg_len, seg_type;
a807 1
		seg_type = seg[0];
d941 1
a941 1
	u_int8_t	 i, seg_type, seg_len;
a952 1
		seg_type = seg[0];
@


1.93
log
@convert some hash tables (the easy ones) to siphash. ok benno.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.92 2014/10/08 16:15:37 deraadt Exp $ */
d426 1
a426 1
	int		 err = 0;
d447 1
a447 1
			err = AS_ERR_SOFT;
d461 1
a461 1
	return (err);	/* aspath is valid but probably not loop free */
@


1.92
log
@Use reallocarray() throughout to spot multiplicative int overflow.
ok henning benno
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.91 2012/08/12 14:24:56 claudio Exp $ */
a19 1
#include <sys/hash.h>
d28 1
d102 2
d112 1
d322 1
a330 1
	a->hash = hash32_buf(&flags, sizeof(flags), HASHINIT);
a331 1
	a->hash = hash32_buf(&type, sizeof(type), a->hash);
d343 6
a348 2
	a->hash = hash32_buf(&len, sizeof(len), a->hash);
	a->hash = hash32_buf(a->data, a->len, a->hash);
d360 1
d363 7
a369 4
	hash = hash32_buf(&flags, sizeof(flags), HASHINIT);
	hash = hash32_buf(&type, sizeof(type), hash);
	hash = hash32_buf(&len, sizeof(len), hash);
	hash = hash32_buf(data, len, hash);
d415 2
d479 1
d516 2
a517 2
		head = ASPATH_HASH(hash32_buf(aspath->data, aspath->len,
		    HASHINIT));
d847 1
a847 1
	hash = hash32_buf(data, len, HASHINIT);
@


1.91
log
@By default mask the reserved bits and the ext len bit in the attribute
flags field. Some systems seem to start sending bad flags around which
cause session failures in bgpd. Make sure that bgpd ignores the must be
zero flags correctly and ensure that they are always reset to zero when
sending updates out.
Reported and patch tested by Laurent CARON, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.90 2012/04/12 17:27:20 claudio Exp $ */
d179 2
a180 2
	if ((p = realloc(asp->others,
	    asp->others_len * sizeof(struct attr *))) == NULL)
d1003 1
a1003 1
		ncommunities = attr->len >> 2; /* divide by four */
d1019 1
a1019 1
	if ((p = malloc(ncommunities << 2)) == NULL)
d1033 1
a1033 1
	attr_optadd(asp, f, ATTR_COMMUNITIES, p, ncommunities << 2);
d1159 1
a1159 1
	if ((p = malloc(ncommunities * sizeof(community))) == NULL)
@


1.90
log
@aspath_neighbor() should return the local AS number for empty AS pathes.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.89 2011/09/20 21:19:06 claudio Exp $ */
d40 1
a45 1
		flags &= ~ATTR_EXTLEN;
d72 1
a77 1
		flags &= ~ATTR_EXTLEN;
d325 1
d355 1
@


1.90.2.1
log
@MFC fix for interoperability problem with some newer Junipers which don't
clear reserved bits:

-- -- --
By default mask the reserved bits and the ext len bit in the attribute
flags field. Some systems seem to start sending bad flags around which
cause session failures in bgpd. Make sure that bgpd ignores the must be
zero flags correctly and ensure that they are always reset to zero when
sending updates out.
Reported and patch tested by Laurent CARON, OK henning@@

Members:
        rde.c:1.316->1.317
        rde.h:1.142->1.143
        rde_attr.c:1.90->1.91
-- -- --
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.91 2012/08/12 14:24:56 claudio Exp $ */
a39 1
	flags &= ~ATTR_DEFMASK;
d45 1
a71 1
	flags &= ~ATTR_DEFMASK;
d77 1
a324 1
	flags &= ~ATTR_DEFMASK;	/* normalize mask */
a353 1
	flags &= ~ATTR_DEFMASK;	/* normalize mask */
@


1.89
log
@Move a few functions into util.c because bgpctl will need them soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.88 2010/12/31 21:22:42 guenther Exp $ */
d778 1
a778 6
	/*
	 * Empty aspath is OK -- internal as route.
	 * But what is the neighbor? For now let's return 0.
	 * That should not break anything.
	 */

d780 1
a780 2
		return (0);

@


1.88
log
@Add missing #includes instead of assuming that some system header pulls in
the needed bits

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.87 2010/11/18 12:18:31 claudio Exp $ */
a923 61
}

/* we need to be able to search more than one as */
int
aspath_match(struct aspath *a, enum as_spec type, u_int32_t as)
{
	u_int8_t	*seg;
	int		 final;
	u_int16_t	 len, seg_size;
	u_int8_t	 i, seg_type, seg_len;

	if (type == AS_EMPTY) {
		if (a->len == 0)
			return (1);
		else
			return (0);
	}

	final = 0;
	seg = a->data;
	for (len = a->len; len > 0; len -= seg_size, seg += seg_size) {
		seg_type = seg[0];
		seg_len = seg[1];
		seg_size = 2 + sizeof(u_int32_t) * seg_len;

		final = (len == seg_size);

		/* just check the first (leftmost) AS */
		if (type == AS_PEER) {
			if (as == aspath_extract(seg, 0))
				return (1);
			else
				return (0);
		}
		/* just check the final (rightmost) AS */
		if (type == AS_SOURCE) {
			/* not yet in the final segment */
			if (!final)
				continue;

			if (as == aspath_extract(seg, seg_len - 1))
				return (1);
			else
				return (0);
		}

		/* AS_TRANSIT or AS_ALL */
		for (i = 0; i < seg_len; i++) {
			if (as == aspath_extract(seg, i)) {
				/*
				 * the source (rightmost) AS is excluded from
				 * AS_TRANSIT matches.
				 */
				if (final && i == seg_len - 1 &&
				    type == AS_TRANSIT)
					return (0);
				return (1);
			}
		}
	}
	return (0);
@


1.87
log
@Accept but ignore (treat as withdraw) updates with AS_CONFED_* path
segments. Bgpd does not support confederations but it is too extreme
to close a session because a path contained such elements.
OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.86 2010/10/22 12:37:32 claudio Exp $ */
d25 1
@


1.86
log
@Free attributes that just got allocated beforehands and do not hold any
reference in case attr_optadd() errors out.
Found by and diff provided by Igor Zinovik, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.85 2010/05/26 13:56:07 nicm Exp $ */
d411 1
d426 9
a434 1
		if (seg_type != AS_SET && seg_type != AS_SEQUENCE)
d446 1
a446 1
	return (0);	/* aspath is valid but probably not loop free */
@


1.85
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.84 2010/05/17 16:08:20 claudio Exp $ */
d149 3
a151 1
		if (type == asp->others[l]->type)
d153 1
@


1.84
log
@Implement two new filters, max-as-len and max-as-seq. The first is limiting
the length of an AS path (matches if the path is longer then the specified
lenght) the second matches when a sequence of the same AS number is longer
then the specified length).
max-as-len is good to protect crappy comercial bgp boxes from other crappy
comercial bgp boxes. max-as-seq was a feature request from SwissIX and maybe
EuroIX to find and filter prepends.
Additinal testing and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.83 2010/03/29 09:24:07 claudio Exp $ */
d66 1
a66 1
attr_writebuf(struct buf *buf, u_int8_t flags, u_int8_t type, void *data,
d83 1
a83 1
	if (buf_add(buf, hdr, flags & ATTR_EXTLEN ? 4 : 3) == -1)
d85 1
a85 1
	if (buf_add(buf, data, data_len) == -1)
@


1.83
log
@I'm going to need community_ext_conv() outside of rde_attr.c soon, so move
the prototype to rde.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.82 2010/03/05 15:25:00 claudio Exp $ */
d969 37
@


1.82
log
@Allow to filter for ext-community attributes. Currently only perfect matches
work but that's already better then nothing. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.81 2009/12/18 15:51:37 claudio Exp $ */
a977 1
int community_ext_conv(struct filter_extcommunity *, u_int16_t, u_int64_t *);
@


1.81
log
@Merge rde_filter_community() with community_match() and kill a useless
indirection.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.80 2009/12/16 15:40:55 claudio Exp $ */
d979 1
a992 1
	len = a->len / 4;
d994 1
a994 2

	for (; len > 0; len--) {
d1120 25
d1160 1
a1160 1
		ncommunities = attr->len / 8; /* 64bit per ext-community */
d1278 79
@


1.80
log
@Implement "set ext-community [delete] subtype key:value" to set and delete
extended communities as specified in RFC 4360. No matching implemented yet
and stuff like * and neighbor-as are neither supported but will be soon.
Looks good henning & sthen, manpage fixed by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.79 2009/03/19 06:52:59 claudio Exp $ */
d981 1
a981 1
community_match(void *data, u_int16_t len, int as, int type)
d983 8
a990 2
	u_int8_t	*p = data;
	u_int16_t	 eas, etype;
d992 2
a993 1
	len >>= 2; /* divide by four */
@


1.79
log
@Implement a attr_writebuf() function that works on a struct buf instead of
a pre allocated piece of memory. Will be used by newer mrt code.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.78 2009/02/17 14:10:48 claudio Exp $ */
d974 6
a1008 1
	u_int8_t	 t = ATTR_COMMUNITIES;
d1025 1
a1025 1
	if (ncommunities++ >= 0x3fff)
a1039 1
		t = attr->type;
d1043 1
a1043 1
	attr_optadd(asp, f, t, p, ncommunities << 2);
d1056 1
a1056 1
	u_int8_t	 f, t;
a1106 1
	t = attr->type;
d1109 1
a1109 1
	attr_optadd(asp, f, t, n, len);
d1113 137
@


1.78
log
@Fix aspath_prepend() in the case a AS-PATH has a sequence of 255 elements
and we try to prepend. The result was a corrupt AS-PATH and a RDE fatal
later on when some other operation was run on that path.
Found the hard way by henning@@ and sthen@@. OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.77 2009/01/13 21:35:16 sthen Exp $ */
d63 25
@


1.77
log
@Replace NEW_ASPATH/NEW_AGGREGATOR with the naming from RFC4893,
AS4_PATH/AS4_AGGREGATOR. No binary change.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.76 2008/05/08 09:51:46 henning Exp $ */
d835 2
d848 4
a851 1
		overflow = type == AS_SET ? quantum : (size + quantum) & 0xff;
@


1.76
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.75 2007/05/22 14:03:31 claudio Exp $ */
d591 1
a591 1
		/* ASPATH is shorter then NEW_ASPATH no way to merge */
@


1.76.2.1
log
@MFC rev 1.78
Fix aspath_prepend() in the case a AS-PATH has a sequence of 255 elements
and we try to prepend. The result was a corrupt AS-PATH and a RDE fatal
later on when some other operation was run on that path.
Found the hard way by henning@@ and sthen@@. OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.76 2008/05/08 09:51:46 henning Exp $ */
a834 2
	if (quantum > 255)
		fatalx("aspath_prepend: preposterous prepend");
d846 1
a846 4
		if (type == AS_SET)
			overflow = quantum;
		else
			overflow = size + quantum - 255;
@


1.75
log
@Only try to merge a AS_SEQUENCE if there is a difference between the 4-byte
AS path and the 2-byte version. If both pathes have the same length don't
try to merge them instead use the new path.
Issue reported by Jon Morby and further analysed by Stuart Henderson.
Tested by Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.74 2007/05/11 11:27:59 claudio Exp $ */
d918 1
a918 1
		       	if (!final)
@


1.75.4.1
log
@MFC rev 1.78
Fix aspath_prepend() in the case a AS-PATH has a sequence of 255 elements
and we try to prepend. The result was a corrupt AS-PATH and a RDE fatal
later on when some other operation was run on that path.
Found the hard way by henning@@ and sthen@@. OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.75 2007/05/22 14:03:31 claudio Exp $ */
a834 2
	if (quantum > 255)
		fatalx("aspath_prepend: preposterous prepend");
d846 1
a846 4
		if (type == AS_SET)
			overflow = quantum;
		else
			overflow = size + quantum - 255;
@


1.74
log
@Various spelling fixes from Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.73 2007/04/30 11:41:53 claudio Exp $ */
d597 1
a597 1
	if (attr->len > 2 && attr->data[0] == AS_SEQUENCE)
@


1.73
log
@Better error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.72 2007/04/30 11:37:15 claudio Exp $ */
d406 1
a406 1
			/* empty aspath segment are not allowed */
d685 1
a685 1
			fatalx("aspath_countlenght: would overflow");
@


1.72
log
@Fix a bad check in aspath_inflate() -- compare with the correct loop value.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.71 2007/04/23 13:04:24 claudio Exp $ */
d509 1
a509 1
			fatalx("aspath_inflate: bula bula");
d552 1
a552 1
			fatalx("aspath_deflate: bula bula");
d653 1
a653 1
			fatalx("aspath_count: bula bula");
d685 1
a685 1
			fatalx("aspath_countlenght: bula bula");
d771 1
a771 1
			fatalx("aspath_loopfree: bula bula");
d826 1
a826 1
			fatalx("aspath_prepend: bula bula");
@


1.71
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.70 2007/03/06 16:52:48 henning Exp $ */
d508 1
a508 1
		if (seg_size > len)
@


1.70
log
@allow filtering on peer-as (leftmost AS in path), ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.69 2007/02/22 08:34:18 henning Exp $ */
d364 3
d378 1
a378 1
aspath_verify(void *data, u_int16_t len)
d381 1
a381 1
	u_int16_t	 seg_size;
d388 3
d392 1
a392 1
		if (len < 2)
d400 1
a400 1
		seg_size = 2 + 2 * seg_len;
d494 128
d645 1
a645 1
		seg_size = 2 + 2 * seg_len;
d659 79
d753 1
a753 1
aspath_loopfree(struct aspath *aspath, u_int16_t myAS)
d763 1
a763 1
		seg_size = 2 + 2 * seg_len;
d814 2
a815 2
struct aspath *
aspath_prepend(struct aspath *asp, u_int16_t as, int quantum)
d818 1
a818 1
	int		 len, overflow = 0, shift = 0, size, wpos = 0;
d836 7
a842 4
		/* no change needed but increase refcnt as we return a copy */
		asp->refcnt++;
		rdemem.aspath_refs++;
		return (asp);
d845 1
a845 1
		len = 2 + quantum * 2 + asp->len;
d848 1
a848 1
		len = quantum * 2 + asp->len;
d852 1
a852 1
	p = malloc(len);
d857 1
a857 1
	as = htons(as);
d863 2
a864 2
			memcpy(p + wpos, &as, 2);
			wpos += 2;
d873 2
a874 2
			memcpy(p + wpos, &as, 2);
			wpos += 2;
d879 2
a880 4
	asp = aspath_get(p, len);
	free(p);

	return (asp);
d885 1
a885 1
aspath_match(struct aspath *a, enum as_spec type, u_int16_t as)
d888 1
a888 1
	int		 final, first;
a899 1
	first = 1;
d904 1
a904 1
		seg_size = 2 + 2 * seg_len;
d908 9
a916 1
		if (type == AS_SOURCE && !final)
d918 2
a919 1
			continue;
d921 7
d930 8
a937 13
				if (type == AS_PEER) {
					if (first)
						return (1);
					else
						return (0);
				} else if (final && i + 1 >= seg_len)
					/* the final (rightmost) as */
					if (type == AS_TRANSIT)
						return (0);
					else
						return (1);
				else if (type != AS_SOURCE)
					return (1);
a938 1
			first = 0;
@


1.69
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.68 2006/12/21 15:25:19 claudio Exp $ */
d674 1
a674 1
	int		 final;
d686 1
d699 1
a699 1
		for (i = 0; i < seg_len; i++)
d701 6
a706 1
				if (final && i + 1 >= seg_len)
d715 2
@


1.68
log
@Check for overflow of others_len. This can not happen at the moment because
less than 255 attributes can be allocated at max. OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.67 2006/12/18 19:16:59 henning Exp $ */
d797 1
a797 1
	
@


1.67
log
@avoid p = realloc(p idiom, ok claudio, spotted deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.66 2006/05/27 15:39:56 claudio Exp $ */
d146 3
@


1.66
log
@Unfuck community delete. The if () statement to match communities was FUBAR
instead reverse logic and use the same if statement as in the match function.
Issue found and debugged by Leen Besselink. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.65 2006/04/12 14:05:46 claudio Exp $ */
d114 1
d147 1
a147 1
	if ((asp->others = realloc(asp->others,
d150 1
@


1.65
log
@It is no longer allowed to change attributes in place. This corrupts the
attribute cache. Instead remove attribute and readd it after beeing changed.
This should fix the "att_diff: equal attributes encountered" error seen by
Tony Sarendal. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.64 2006/03/15 11:26:45 claudio Exp $ */
d802 5
a806 3
		if (as != COMMUNITY_ANY && (u_int16_t)as != eas &&
		    type != COMMUNITY_ANY && (u_int16_t)type != etype)
			len += 4;
d826 8
a833 7
		if (as != COMMUNITY_ANY && (u_int16_t)as != eas &&
		    type != COMMUNITY_ANY && (u_int16_t)type != etype) {
			n[l++] = eas >> 8;
			n[l++] = eas & 0xff;
			n[l++] = etype >> 8;
			n[l++] = etype & 0xff;
		}
@


1.64
log
@Fix a memory leak when communities are set or deleted. This seems to fix
Sylvain Coutant memory issues. A lot of patience and testing by Sylvain.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.63 2006/02/09 21:05:09 claudio Exp $ */
a30 2

void	attr_free(struct rde_aspath *, struct attr *);
@


1.63
log
@Implement "set community delete 65001:*" and friends. This will remove
communities from the path attributes. Useful to make sure that the ones you
set later are set by a (evil) peer.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.62 2006/02/09 20:54:56 claudio Exp $ */
d777 1
d840 1
@


1.63.2.1
log
@MFC:
Fix by claudio@@

Fix a memory leak when communities are set or deleted. This seems to fix
Sylvain Coutant memory issues. A lot of patience and testing by Sylvain.

ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.64 2006/03/15 11:26:45 claudio Exp $ */
a776 1
	free(p);
a838 1
	free(n);
@


1.62
log
@When comparing community type, cast to u_int16_t. The same is done for the
AS. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.61 2006/02/09 20:50:09 claudio Exp $ */
a741 1

d778 61
@


1.61
log
@attr_free() should not modify others_len as it does not resize the others
array. It just clears on entry by setting it to NULL and moving that NULL
to the end of the array. With this it will be possible to remove attributes
without readding them right afterwards. Because of this attr_diff() needs to
be more careful because of passed NULL pointers. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.60 2006/01/20 15:34:55 claudio Exp $ */
d726 1
a726 1
		    (type == COMMUNITY_ANY || type == etype))
@


1.60
log
@No need to calloc() others if others_len is 0. The 0 malloc() does not hurt
(we do not access it) but does not help either. Finally it reduces head
scratching when debugging the RIB. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.59 2006/01/20 15:14:40 claudio Exp $ */
d204 4
d261 3
a263 4
			asp->others[l] = NULL;
			--asp->others_len;
			for (; l < asp->others_len; l++)
				asp->others[l] = asp->others[l + 1];
d267 1
a267 1
	/* no realloc() others because the slot will be reused soon */
@


1.59
log
@Doh. > not < and attr_compare() starts to work correctly. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.58 2006/01/10 16:11:12 claudio Exp $ */
d181 6
a188 1
	t->others_len = s->others_len;
@


1.58
log
@The attributes cache broke the set community filterset because community_set()
modified the attribute data directly and corrupted the cache by doing it.
It is no longer allowed to modify attributes via attr_optget() -> change
attr->data. Instead remove the old attribute from the aspath and then add
a new modifed one again. Included in this change is the removal of a "feature"
that allowed only one community per AS. If you had problems to add multiple
communities via filters then this was the problem. Looks good Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.57 2006/01/10 16:03:11 claudio Exp $ */
d235 1
a235 1
	} else if (a->others_len < b->others_len) {
@


1.57
log
@In attr_diff() compare the attributes flags too. They may be different and
especially they are accounted in the hash. While there change a 0 to NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.56 2006/01/05 16:00:07 claudio Exp $ */
d32 2
d245 18
d725 1
a725 1
community_set(struct attr *attr, int as, int type)
d727 7
a733 2
	u_int8_t *p = attr->data;
	unsigned int i, ncommunities = attr->len;
d735 4
a738 1
	ncommunities >>= 2; /* divide by four */
d740 1
d742 4
a745 2
		if (as >> 8 == p[0] && (as & 0xff) == p[1])
			break;
d749 6
a754 6
	if (i >= ncommunities) {
		if (attr->len > 0xffff - 4) /* overflow */
			return (0);
		i = attr->len + 4;
		if ((p = realloc(attr->data, i)) == NULL)
			return (0);
a755 4
		attr->data = p;
		attr->len = i;
		p = attr->data + attr->len - 4;
	}
d760 9
@


1.56
log
@Cache optional BGP attributes (mostly communities) and use a simple
pointer plus a ref counter to link the attributes to the path object.
Saves +/- 10M on 11 full feeds. Looks good Henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.55 2006/01/04 12:45:53 claudio Exp $ */
d116 1
a116 1
	if ((a = attr_lookup(flags, type, data, len)) == 0)
d197 4
@


1.55
log
@Correctly count the number of allocated BGP attributes. Needs a own counter.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.54 2006/01/03 22:49:17 claudio Exp $ */
a31 2
/* attribute specific functions */

d65 43
d112 2
a113 1
	struct attr	*a, *p;
d116 140
d262 1
d264 1
d267 1
a267 2
		a->data = malloc(len);
		if (a->data == NULL)
d276 5
a280 19
	/* keep a sorted list */
	TAILQ_FOREACH_REVERSE(p, &asp->others, attr_list, entry) {
		if (type == p->type) {
			/* attribute allowed only once */
			if (len != 0)
				rdemem.attr_dcnt--;
			rdemem.attr_data -= len;
			rdemem.attr_cnt--;
			free(a->data);
			free(a);
			return (-1);
		}
		if (type > p->type) {
			TAILQ_INSERT_AFTER(&asp->others, p, a, entry);
			return (0);
		}
	}
	TAILQ_INSERT_HEAD(&asp->others, a, entry);
	return (0);
d284 1
a284 1
attr_optget(const struct rde_aspath *asp, u_int8_t type)
d286 14
a299 4
	struct attr	*a;

	TAILQ_FOREACH(a, &asp->others, entry) {
		if (type == a->type)
a300 3
		if (type < a->type)
			/* list is sorted */
			break;
d306 1
a306 1
attr_optcopy(struct rde_aspath *t, struct rde_aspath *s)
d308 2
a309 1
	struct attr	*os;
d311 14
a324 18
	TAILQ_FOREACH(os, &s->others, entry)
		attr_optadd(t, os->flags, os->type, os->data, os->len);
}

void
attr_optfree(struct rde_aspath *asp)
{
	struct attr	*a;

	while ((a = TAILQ_FIRST(&asp->others)) != NULL) {
		TAILQ_REMOVE(&asp->others, a, entry);
		if (a->len != 0)
			rdemem.attr_dcnt--;
		rdemem.attr_data -= a->len;
		rdemem.attr_cnt--;
		free(a->data);
		free(a);
	}
d395 1
a395 1
			log_warnx("path_free: free non-free table");
@


1.54
log
@Track some (memory) statistics in the RDE. Accessible via bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.53 2006/01/03 22:19:59 claudio Exp $ */
d87 1
d97 2
d145 2
@


1.53
log
@Move functions shared with bgpctl into new file util.c. Simplifies the
link between bgpctl and bgpd mostly because of rde_attr.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.52 2005/12/30 16:40:15 claudio Exp $ */
d77 1
d87 1
d96 2
d142 2
d235 3
d249 1
d260 2
a261 1
	if (--aspath->refcnt > 0)
d264 1
d269 2
d412 1
@


1.52
log
@Remove unused attr_optlen()
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.51 2005/12/30 14:07:40 claudio Exp $ */
a144 1
u_int16_t	 aspath_extract(const void *, int);
a352 18
/*
 * Extract the asnum out of the as segment at the specified position.
 * Direct access is not possible because of non-aligned reads.
 * ATTENTION: no bounds check are done.
 */
u_int16_t
aspath_extract(const void *seg, int pos)
{
	const u_char	*ptr = seg;
	u_int16_t	 as = 0;

	ptr += 2 + 2 * pos;
	as = *ptr++;
	as <<= 8;
	as |= *ptr;
	return (as);
}

a438 127
}

int
aspath_snprint(char *buf, size_t size, void *data, u_int16_t len)
{
#define UPDATE()				\
	do {					\
		if (r == -1)			\
			return (-1);		\
		total_size += r;		\
		if ((unsigned int)r < size) {	\
			size -= r;		\
			buf += r;		\
		} else {			\
			buf += size;		\
			size = 0;		\
		}				\
	} while (0)
	u_int8_t	*seg;
	int		 r, total_size;
	u_int16_t	 seg_size;
	u_int8_t	 i, seg_type, seg_len;

	total_size = 0;
	seg = data;
	for (; len > 0; len -= seg_size, seg += seg_size) {
		seg_type = seg[0];
		seg_len = seg[1];
		seg_size = 2 + 2 * seg_len;

		if (seg_type == AS_SET) {
			if (total_size != 0)
				r = snprintf(buf, size, " { ");
			else
				r = snprintf(buf, size, "{ ");
			UPDATE();
		} else if (total_size != 0) {
			r = snprintf(buf, size, " ");
			UPDATE();
		}

		for (i = 0; i < seg_len; i++) {
			r = snprintf(buf, size, "%hu", aspath_extract(seg, i));
			UPDATE();
			if (i + 1 < seg_len) {
				r = snprintf(buf, size, " ");
				UPDATE();
			}
		}
		if (seg_type == AS_SET) {
			r = snprintf(buf, size, " }");
			UPDATE();
		}
	}
	/* ensure that we have a valid C-string especially for emtpy as path */
	if (size > 0)
		*buf = '\0';

	return (total_size);
#undef UPDATE
}

int
aspath_asprint(char **ret, void *data, u_int16_t len)
{
	size_t	slen;
	int	plen;

	slen = aspath_strlen(data, len) + 1;
	*ret = malloc(slen);
	if (*ret == NULL)
		return (-1);

	plen = aspath_snprint(*ret, slen, data, len);
	if (plen == -1) {
		free(*ret);
		*ret = NULL;
		return (-1);
	}

	return (0);
}

size_t
aspath_strlen(void *data, u_int16_t len)
{
	u_int8_t	*seg;
	int		 total_size;
	u_int16_t	 as, seg_size;
	u_int8_t	 i, seg_type, seg_len;

	total_size = 0;
	seg = data;
	for (; len > 0; len -= seg_size, seg += seg_size) {
		seg_type = seg[0];
		seg_len = seg[1];
		seg_size = 2 + 2 * seg_len;

		if (seg_type == AS_SET)
			if (total_size != 0)
				total_size += 3;
			else
				total_size += 2;
		else if (total_size != 0)
			total_size += 1;

		for (i = 0; i < seg_len; i++) {
			as = aspath_extract(seg, i);
			if (as >= 10000)
				total_size += 5;
			else if (as >= 1000)
				total_size += 4;
			else if (as >= 100)
				total_size += 3;
			else if (as >= 10)
				total_size += 2;
			else
				total_size += 1;

			if (i + 1 < seg_len)
				total_size += 1;
		}

		if (seg_type == AS_SET)
			total_size += 2;
	}
	return (total_size);
@


1.51
log
@Use sys/hash.h instead of own built functions that work similar.
While there reorder some structs to help with alignment.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.50 2005/12/19 20:10:55 claudio Exp $ */
a64 9
}

int
attr_optlen(struct attr *a)
{
	if (a->len > 255)
		return (4 + a->len);
	else
		return (3 + a->len);
@


1.50
log
@Better English in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.49 2005/06/13 15:16:50 claudio Exp $ */
d20 1
a153 1
u_int32_t	 aspath_hash(const void *, u_int16_t);
d245 2
a246 1
		head = ASPATH_HASH(aspath_hash(aspath->data, aspath->len));
a362 28
#define AS_HASH_INITIAL 8271

u_int32_t
aspath_hash(const void *data, u_int16_t len)
{
	const u_int8_t	*seg;
	u_int32_t	 hash;
	u_int16_t	 seg_size;
	u_int8_t	 i, seg_len, seg_type;

	hash = AS_HASH_INITIAL;
	seg = data;
	for (; len > 0; len -= seg_size, seg += seg_size) {
		seg_type = seg[0];
		seg_len = seg[1];
		seg_size = 2 + 2 * seg_len;

		for (i = 0; i < seg_len; i++) {
			hash += (hash << 5);
			hash ^= aspath_extract(seg, i);
		}

		if (seg_size > len)
			fatalx("aspath_hash: bula bula");
	}
	return (hash);
}

d388 1
a388 1
	hash = aspath_hash(data, len);
@


1.49
log
@realloc(3) correctly. Do not adjust the variable describing how much memory
has been allocated until one knows the allocation has been successful.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.48 2005/06/10 10:02:21 claudio Exp $ */
d101 1
a101 1
			/* attribute only once allowed */
@


1.48
log
@Make sure that the ATTR_EXTLEN flag is unset if the attribute length is
smaller than 255 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.47 2005/06/10 09:58:09 claudio Exp $ */
d706 2
a707 2
		attr->len += 4;
		if ((p = realloc(attr->data, attr->len)) == NULL)
d711 1
@


1.47
log
@Introduce attr_optlen() to get the total lenght of an optional attribute
plus header. Soon needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.46 2005/04/16 19:56:31 claudio Exp $ */
d43 1
a43 1
	} else
d45 2
@


1.46
log
@Simplify return codes of aspath_asprint().
Return -1 on error 0 on success and make sure that in case of an error
*ret is set to NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.45 2005/04/15 16:19:34 claudio Exp $ */
d62 9
@


1.45
log
@Fix memory leak in case aspath_snprint() returns an error (-1).
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.44 2004/11/10 15:18:11 claudio Exp $ */
d557 1
a557 1
	if (plen == -1)
d559 3
d563 1
a563 1
	return (plen);
@


1.44
log
@It is not needed to mask the value wit 0xff as it is < 255. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.43 2004/08/10 13:08:13 claudio Exp $ */
d537 1
a537 1
	/* ensure that we have a valid C-string */
d548 2
a549 1
	size_t	slen, plen;
d555 1
d557 2
@


1.43
log
@style, use sizeof() instead of a hardcoded value.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.42 2004/08/06 12:04:08 claudio Exp $ */
d56 1
a56 1
		*b++ = (u_char)(data_len & 0xff);
@


1.42
log
@Monster diff to get one step closer to IPv6 support.
Cleanup path attribute handling. First of all kill struct attr_flags, all
those infos are now in struct rde_aspath. Second move attribute parser
functions into rde.c, rde_attr.c is shared between bgpd and bgpctl.
Third reimplementation of the nexthop handling. Make it IPv6 ready and
fix some major bug relating to "set nexthop".
henning@@ OK if it breaks nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.41 2004/08/05 20:56:12 claudio Exp $ */
d53 1
a53 1
		memcpy(b, &tmp, 2);
@


1.41
log
@As usual cleanup on exit. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.40 2004/08/05 18:44:19 claudio Exp $ */
a31 451
#define UPD_READ(t, p, plen, n) \
	do { \
		memcpy(t, p, n); \
		p += n; \
		plen += n; \
	} while (0)

#define CHECK_FLAGS(s, t, m)	\
	(((s) & ~(ATTR_EXTLEN | (m))) == (t))

#define F_ATTR_ORIGIN		0x01
#define F_ATTR_ASPATH		0x02
#define F_ATTR_NEXTHOP		0x04
#define F_ATTR_LOCALPREF	0x08
#define F_ATTR_MED		0x10
#define F_ATTR_MP_REACH		0x20
#define F_ATTR_MP_UNREACH	0x40

#define WFLAG(s, t)			\
	do {				\
		if ((s) & (t))		\
			return (-1);	\
		(s) |= (t);		\
	} while (0)
void
attr_init(struct attr_flags *a)
{
	bzero(a, sizeof(struct attr_flags));
	a->origin = ORIGIN_INCOMPLETE;
	a->lpref = DEFAULT_LPREF;
	TAILQ_INIT(&a->others);
}

int
attr_parse(u_char *p, u_int16_t len, struct attr_flags *a, int ebgp,
    enum enforce_as enforce_as, u_int16_t remote_as)
{
	u_int32_t	 tmp32;
	u_int16_t	 attr_len;
	u_int16_t	 plen = 0;
	u_int8_t	 flags;
	u_int8_t	 type;
	u_int8_t	 tmp8;

	if (len < 3)
		return (-1);

	UPD_READ(&flags, p, plen, 1);
	UPD_READ(&type, p, plen, 1);

	if (flags & ATTR_EXTLEN) {
		if (len - plen < 2)
			return (-1);
		UPD_READ(&attr_len, p, plen, 2);
		attr_len = ntohs(attr_len);
	} else {
		UPD_READ(&tmp8, p, plen, 1);
		attr_len = tmp8;
	}

	if (len - plen < attr_len)
		return (-1);

	switch (type) {
	case ATTR_UNDEF:
		/* error! */
		return (-1);
	case ATTR_ORIGIN:
		if (attr_len != 1)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0))
			return (-1);
		UPD_READ(&a->origin, p, plen, 1);
		if (a->origin > ORIGIN_INCOMPLETE)
			return (-1);
		WFLAG(a->wflags, F_ATTR_ORIGIN);
		break;
	case ATTR_ASPATH:
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0))
			return (-1);
		if (aspath_verify(p, attr_len) != 0)
			return (-1);
		WFLAG(a->wflags, F_ATTR_ASPATH);
		a->aspath = aspath_get(p, attr_len);
		if (enforce_as == ENFORCE_AS_ON &&
		    remote_as != aspath_neighbor(a->aspath))
			return (-1);

		plen += attr_len;
		break;
	case ATTR_NEXTHOP:
		if (attr_len != 4)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0))
			return (-1);
		WFLAG(a->wflags, F_ATTR_NEXTHOP);
		UPD_READ(&a->nexthop, p, plen, 4);	/* network byte order */
		/*
		 * Check if the nexthop is a valid IP address. We consider
		 * multicast and experimental addresses as invalid.
		 */
		tmp32 = ntohl(a->nexthop.s_addr);
		if (IN_MULTICAST(tmp32) || IN_BADCLASS(tmp32))
			return (-1);
		break;
	case ATTR_MED:
		if (attr_len != 4)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, 0))
			return (-1);
		WFLAG(a->wflags, F_ATTR_MED);
		UPD_READ(&tmp32, p, plen, 4);
		a->med = ntohl(tmp32);
		break;
	case ATTR_LOCALPREF:
		if (attr_len != 4)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0))
			return (-1);
		if (ebgp) {
			/* ignore local-pref attr for non ibgp peers */
			a->lpref = 0;	/* set a default value ... */
			plen += 4;	/* and ignore the real value */
			break;
		}
		WFLAG(a->wflags, F_ATTR_LOCALPREF);
		UPD_READ(&tmp32, p, plen, 4);
		a->lpref = ntohl(tmp32);
		break;
	case ATTR_ATOMIC_AGGREGATE:
		if (attr_len != 0)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0))
			return (-1);
		goto optattr;
	case ATTR_AGGREGATOR:
		if (attr_len != 6)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE, 0))
			return (-1);
		goto optattr;
	case ATTR_COMMUNITIES:
		if ((attr_len & 0x3) != 0)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE,
		    ATTR_PARTIAL))
			return (-1);
		goto optattr;
	case ATTR_ORIGINATOR_ID:
		if (attr_len != 4)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, 0))
			return (-1);
		goto optattr;
	case ATTR_CLUSTER_LIST:
		if ((attr_len & 0x3) != 0)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, 0))
			return (-1);
		goto optattr;
	case ATTR_MP_REACH_NLRI:
		if (attr_len < 4)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, 0))
			return (-1);
		/* the actually validity is checked in rde_update_dispatch() */
		WFLAG(a->wflags, F_ATTR_MP_REACH);
		goto optattr;
	case ATTR_MP_UNREACH_NLRI:
		if (attr_len < 3)
			return (-1);
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, 0))
			return (-1);
		/* the actually validity is checked in rde_update_dispatch() */
		WFLAG(a->wflags, F_ATTR_MP_UNREACH);
		goto optattr;
	default:
optattr:
		if (attr_optadd(a, flags, type, p, attr_len) == -1)
			return (-1);
		plen += attr_len;
		break;
	}

	return (plen);
}

u_char *
attr_error(u_char *p, u_int16_t len, struct attr_flags *attr,
    u_int8_t *suberr, u_int16_t *size)
{
	struct attr	*a;
	u_char		*op;
	u_int16_t	 attr_len;
	u_int16_t	 plen = 0;
	u_int8_t	 flags;
	u_int8_t	 type;
	u_int8_t	 tmp8;

	*suberr = ERR_UPD_ATTRLEN;
	*size = len;
	op = p;
	if (len < 3)
		return (op);

	UPD_READ(&flags, p, plen, 1);
	UPD_READ(&type, p, plen, 1);

	if (flags & ATTR_EXTLEN) {
		if (len - plen < 2)
			return (op);
		UPD_READ(&attr_len, p, plen, 2);
	} else {
		UPD_READ(&tmp8, p, plen, 1);
		attr_len = tmp8;
	}

	if (len - plen < attr_len)
		return (op);
	*size = attr_len;

	switch (type) {
	case ATTR_UNDEF:
		/* error! */
		*suberr = ERR_UPD_UNSPECIFIC;
		*size = 0;
		return (NULL);
	case ATTR_ORIGIN:
		if (attr_len != 1)
			return (op);
		if (attr->wflags & F_ATTR_ORIGIN) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		UPD_READ(&tmp8, p, plen, 1);
		if (tmp8 > ORIGIN_INCOMPLETE) {
			*suberr = ERR_UPD_ORIGIN;
			return (op);
		}
		break;
	case ATTR_ASPATH:
		if (attr->wflags & F_ATTR_ASPATH) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		if (CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0)) {
			/* malformed aspath detected by exclusion method */
			*size = 0;
			*suberr = ERR_UPD_ASPATH;
			return (NULL);
		}
		break;
	case ATTR_NEXTHOP:
		if (attr_len != 4)
			return (op);
		if (attr->wflags & F_ATTR_NEXTHOP) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		if (CHECK_FLAGS(flags, ATTR_WELL_KNOWN, 0)) {
			/* malformed nexthop detected by exclusion method */
			*suberr = ERR_UPD_NETWORK;
			return (op);
		}
		break;
	case ATTR_MED:
		if (attr_len != 4)
			return (op);
		if (attr->wflags & F_ATTR_MED) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		break;
	case ATTR_LOCALPREF:
		if (attr_len != 4)
			return (op);
		if (attr->wflags & F_ATTR_LOCALPREF) {
			*suberr = ERR_UPD_ATTRLIST;
			*size = 0;
			return (NULL);
		}
		break;
	case ATTR_ATOMIC_AGGREGATE:
		if (attr_len != 0)
			return (op);
		break;
	case ATTR_AGGREGATOR:
		if (attr_len != 6)
			return (op);
		break;
	case ATTR_COMMUNITIES:
		if ((attr_len & 0x3) != 0)
			return (op);
		goto optattr;
	case ATTR_ORIGINATOR_ID:
		if (attr_len != 4)
			return (op);
		goto optattr;
	case ATTR_CLUSTER_LIST:
		if ((attr_len & 0x3) != 0)
			return (op);
		goto optattr;
	case ATTR_MP_REACH_NLRI:
		if (attr_len < 4)
			return (op);
		goto optattr;
	case ATTR_MP_UNREACH_NLRI:
		if (attr_len < 3)
			return (op);
		goto optattr;
	default:
optattr:
		if ((flags & ATTR_OPTIONAL) == 0) {
			*suberr = ERR_UPD_UNKNWN_WK_ATTR;
			return (op);
		}
		TAILQ_FOREACH(a, &attr->others, entry)
			if (type == a->type) {
				*size = 0;
				*suberr = ERR_UPD_ATTRLIST;
				return (NULL);
			}
		*suberr = ERR_UPD_OPTATTR;
		return (op);
	}
	/* can only be a attribute flag error */
	*suberr = ERR_UPD_ATTRFLAGS;
	return (op);
}
#undef UPD_READ
#undef WFLAG

u_int8_t
attr_missing(struct attr_flags *a, int ebgp)
{
	if ((a->wflags & F_ATTR_ORIGIN) == 0)
		return (ATTR_ORIGIN);
	if ((a->wflags & F_ATTR_ASPATH) == 0)
		return (ATTR_ASPATH);
	if ((a->wflags & F_ATTR_MP_REACH) == 0 &&
	    (a->wflags & F_ATTR_NEXTHOP) == 0)
		return (ATTR_NEXTHOP);
	if (!ebgp)
		if ((a->wflags & F_ATTR_LOCALPREF) == 0)
			return (ATTR_LOCALPREF);
	return (0);
}

int
attr_compare(struct attr_flags *a, struct attr_flags *b)
{
	struct attr	*oa, *ob;
	int		 r;

	if (a->origin > b->origin)
		return (1);
	if (a->origin < b->origin)
		return (-1);
	if ((a->wflags & F_ATTR_NEXTHOP) && (b->wflags & F_ATTR_NEXTHOP) == 0)
		return (1);
	if ((b->wflags & F_ATTR_NEXTHOP) && (a->wflags & F_ATTR_NEXTHOP) == 0)
		return (-1);
	if (a->nexthop.s_addr > b->nexthop.s_addr)
		return (1);
	if (a->nexthop.s_addr < b->nexthop.s_addr)
		return (-1);
	if (a->med > b->med)
		return (1);
	if (a->med < b->med)
		return (-1);
	if (a->lpref > b->lpref)
		return (1);
	if (a->lpref < b->lpref)
		return (-1);
	r = strcmp(a->pftable, b->pftable);
	if (r == 0)
		r = aspath_compare(a->aspath, b->aspath);
	if (r > 0)
		return (1);
	if (r < 0)
		return (-1);

	for (oa = TAILQ_FIRST(&a->others), ob = TAILQ_FIRST(&b->others);
	    oa != NULL && ob != NULL;
	    oa = TAILQ_NEXT(oa, entry), ob = TAILQ_NEXT(ob, entry)) {
		if (oa->type > ob->type)
			return (1);
		if (oa->type < ob->type)
			return (-1);
		if (oa->len > ob->len)
			return (1);
		if (oa->len < ob->len)
			return (-1);
		r = memcmp(oa->data, ob->data, oa->len);
		if (r > 0)
			return (1);
		if (r < 0)
			return (-1);
	}
	if (oa != NULL)
		return (1);
	if (ob != NULL)
		return (-1);
	return (0);
}

void
attr_copy(struct attr_flags *t, struct attr_flags *s)
{
	struct attr	*os;
	/*
	 * first copy the full struct, then replace the path and tags with
	 * a own copy.
	 */
	memcpy(t, s, sizeof(struct attr_flags));
	t->aspath = aspath_get(s->aspath->data, s->aspath->len);
	TAILQ_INIT(&t->others);
	TAILQ_FOREACH(os, &s->others, entry)
		attr_optadd(t, os->flags, os->type, os->data, os->len);
}

void
attr_move(struct attr_flags *t, struct attr_flags *s)
{
	struct attr	*os;
	/*
	 * first copy the full struct, then move the optional attributes.
	 */
	memcpy(t, s, sizeof(struct attr_flags));
	TAILQ_INIT(&t->others);
	while ((os = TAILQ_FIRST(&s->others)) != NULL) {
		TAILQ_REMOVE(&s->others, os, entry);
		TAILQ_INSERT_TAIL(&t->others, os, entry);
	}
}

void
attr_free(struct attr_flags *a)
{
	/*
	 * free the aspath and all optional path attributes
	 * but not the attr_flags struct.
	 */
	aspath_put(a->aspath);
	a->aspath = NULL;
	attr_optfree(a);
}
d65 1
a65 1
attr_optadd(struct attr_flags *attr, u_int8_t flags, u_int8_t type,
d74 1
d82 1
d88 1
a88 1
	TAILQ_FOREACH_REVERSE(p, &attr->others, attr_list, entry) {
d96 1
a96 1
			TAILQ_INSERT_AFTER(&attr->others, p, a, entry);
d100 1
a100 1
	TAILQ_INSERT_HEAD(&attr->others, a, entry);
d105 1
a105 1
attr_optget(const struct attr_flags *attr, u_int8_t type)
d109 1
a109 1
	TAILQ_FOREACH(a, &attr->others, entry) {
d120 1
a120 1
attr_optfree(struct attr_flags *attr)
d122 1
a122 1
	struct attr	*a;
d124 2
a125 5
	while ((a = TAILQ_FIRST(&attr->others)) != NULL) {
		TAILQ_REMOVE(&attr->others, a, entry);
		free(a->data);
		free(a);
	}
d128 2
a129 2
int
attr_ismp(const struct attr_flags *attr)
d131 1
a131 2
	return (attr->wflags & F_ATTR_MP_REACH);
}
d133 4
a136 24
int
attr_mp_nexthop_check(u_char *data, u_int16_t len, u_int16_t afi)
{
	u_int8_t	nh_len;

	if (len == 0)
		return (-1);

	nh_len = *data++;
	len--;

	if (nh_len > len)
		return (-1);

	switch (afi) {
	case AFI_IPv6:
		if (nh_len != 16 && nh_len != 32) {
			log_warnx("bad multiprotocol nexthop, bad size");
			return (-1);
		}
		return (nh_len + 1);
	default:
		log_warnx("bad multiprotocol nexthop, bad AF");
		break;
a137 55

	return (-1);
}

/*
 * this function may only be called after attr_mp_nexthop_check()
 */
struct bgpd_addr *
attr_mp_nexthop(const struct attr_flags *attrs)
{
	static struct bgpd_addr	 address;
	struct attr		*mpattr;
	u_int8_t		*p;
	u_int16_t		 afi;
	u_int8_t		 nhlen;

	if ((mpattr = attr_optget(attrs, ATTR_MP_REACH_NLRI)) == NULL) {
		log_warnx("attr_mp_nexthop: no MP_REACH_NLRI available");
		return (NULL);
	}
	p = mpattr->data;
	if (mpattr->len < 4)
		fatalx("Who fucked up the code? King Bula?");

	memcpy(&afi, p, 2);
	afi = ntohs(afi);
	p += 3;

	nhlen = *p++;
	if (nhlen > mpattr->len)
		fatalx("Who fucked up the code? King Bula?");

	bzero(&address, sizeof(address));
	switch (afi) {
	case AFI_IPv6:
		address.af = AF_INET6;
		if (nhlen == 16)  {
			memcpy(&address.v6.s6_addr, p, 16);
			return (&address);
		}
		if (nhlen == 32) {
			/*
			 * XXX acctually the link lokal address should be used
			 * for kroute and the global one updates.
			 */
			memcpy(&address.v6.s6_addr, p, 16);
			return (&address);
		}
		fatalx("Who fucked up the code? King Bula?");
	default:
		fatalx("attr_mp_nexthop: unsupported AF");
	}

	/* NOTREACHED */
	return (NULL);
@


1.40
log
@Cleanup aspath specific functions and api. Mainly switch to a refcnt based
allocation. This helps to save a bit of RAM. looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.39 2004/07/28 16:02:14 claudio Exp $ */
d723 1
a723 1
		fatal("path_init");
d729 12
@


1.39
log
@The default localpreference is 100 and not 0. Found and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.38 2004/07/13 17:57:20 jaredy Exp $ */
d115 1
a115 1
		a->aspath = aspath_create(p, attr_len);
d451 1
a451 1
	t->aspath = aspath_create(s->aspath->data, s->aspath->hdr.len);
d479 1
a479 1
	aspath_destroy(a->aspath);
d670 8
a677 1
static u_int16_t	aspath_extract(void *, int);
d679 2
a680 17
/*
 * Extract the asnum out of the as segment at the specified position.
 * Direct access is not possible because of non-aligned reads.
 * ATTENTION: no bounds check are done.
 */
static u_int16_t
aspath_extract(void *seg, int pos)
{
	u_char		*ptr = seg;
	u_int16_t	 as = 0;

	ptr += 2 + 2 * pos;
	as = *ptr++;
	as <<= 8;
	as |= *ptr;
	return (as);
}
d714 2
a715 2
struct aspath *
aspath_create(void *data, u_int16_t len)
d717 1
a717 1
	struct aspath	*aspath;
d719 5
a723 6
	/* The aspath must already have been checked for correctness. */
	aspath = malloc(ASPATH_HEADER_SIZE + len);
	if (aspath == NULL)
		fatal("aspath_create");
	aspath->hdr.len = len;
	memcpy(aspath->data, data, len);
d725 2
a726 2
	aspath->hdr.as_cnt = aspath_count(aspath);
	aspath->hdr.prepend = 0;
d728 1
a728 1
	return (aspath);
d731 2
a732 3
int
aspath_write(void *p, u_int16_t len, struct aspath *aspath, u_int16_t myAS,
    int ebgp)
d734 2
a735 4
	u_char		*b = p;
	int		 tot_len, as_len, prepend, size, wpos = 0;
	u_int16_t	 tmp;
	u_int8_t	 type, attr_flag = ATTR_WELL_KNOWN;
d737 15
a751 16
	prepend = aspath->hdr.prepend + (ebgp ? 1 : 0);

	if (prepend > 255)
		/* lunatic prepends need to be blocked in the parser */
		return (-1);

	/* first calculate new size */
	if (aspath->hdr.len > 0) {
		if (aspath->hdr.len < 2)
			return (-1);
		type = aspath->data[0];
		size = aspath->data[1];
	} else {
		/* empty as path */
		type = AS_SET;
		size = 0;
d753 1
a753 15
	if (prepend == 0)
		as_len = aspath->hdr.len;
	else if (type == AS_SET || size + prepend > 255)
		/* need to attach a new AS_SEQUENCE */
		as_len = 2 + prepend * 2 + aspath->hdr.len;
	else
		as_len = prepend * 2 + aspath->hdr.len;

	/* check buffer size */
	tot_len = 2 + as_len;
	if (as_len > 255) {
		attr_flag |= ATTR_EXTLEN;
		tot_len += 2;
	} else
		tot_len += 1;
d755 1
a755 42
	if (tot_len > len)
		return (-1);

	/* header */
	b[wpos++] = attr_flag;
	b[wpos++] = ATTR_ASPATH;
	if (as_len > 255) {
		tmp = as_len;
		tmp = htons(tmp);
		memcpy(b, &tmp, 2);
		wpos += 2;
	} else
		b[wpos++] = (u_char)(as_len & 0xff);

	/* first prepends */
	myAS = htons(myAS);
	if (type == AS_SET) {
		b[wpos++] = AS_SEQUENCE;
		b[wpos++] = prepend;
		for (; prepend > 0; prepend--) {
			memcpy(b + wpos, &myAS, 2);
			wpos += 2;
		}
		memcpy(b + wpos, aspath->data, aspath->hdr.len);
	} else {
		if (size + prepend > 255) {
			b[wpos++] = AS_SEQUENCE;
			b[wpos++] = size + prepend - 255;
			for (; prepend + size > 255; prepend--) {
				memcpy(b + wpos, &myAS, 2);
				wpos += 2;
			}
		}
		b[wpos++] = AS_SEQUENCE;
		b[wpos++] = size + prepend;
		for (; prepend > 0; prepend--) {
			memcpy(b + wpos, &myAS, 2);
			wpos += 2;
		}
		memcpy(b + wpos, aspath->data + 2, aspath->hdr.len - 2);
	}
	return (tot_len);
d759 1
a759 1
aspath_destroy(struct aspath *aspath)
d761 10
a770 2
	/* only the aspath needs to be freed */
	if (aspath == NULL) return;
d783 1
a783 1
	return (aspath->hdr.len);
d787 1
a787 1
aspath_count(struct aspath *aspath)
d789 2
a790 2
	u_int8_t	*seg;
	u_int16_t	 cnt, len, seg_size;
d794 2
a795 2
	seg = aspath->data;
	for (len = aspath->hdr.len; len > 0; len -= seg_size, seg += seg_size) {
d804 3
d820 1
a820 1
	if (aspath->hdr.len == 0)
d834 1
a834 1
	for (len = aspath->hdr.len; len > 0; len -= seg_size, seg += seg_size) {
d843 3
d850 17
d870 1
a870 1
aspath_hash(struct aspath *aspath)
d872 1
a872 1
	u_int8_t	*seg;
d874 1
a874 1
	u_int16_t	 len, seg_size;
d878 2
a879 2
	seg = aspath->data;
	for (len = aspath->hdr.len; len > 0; len -= seg_size, seg += seg_size) {
d888 3
d895 41
a935 2
int
aspath_compare(struct aspath *a1, struct aspath *a2)
d937 60
a996 1
	int r;
d998 1
a998 10
	if (a1->hdr.len > a2->hdr.len)
		return (1);
	if (a1->hdr.len < a2->hdr.len)
		return (-1);
	r = memcmp(a1->data, a2->data, a1->hdr.len);
	if (r > 0)
		return (1);
	if (r < 0)
		return (-1);
	return (0);
d1131 1
a1131 1
		if (a->hdr.len == 0)
d1139 1
a1139 1
	for (len = a->hdr.len; len > 0; len -= seg_size, seg += seg_size) {
d1207 1
@


1.38
log
@fix some typos

ok henning otto
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.37 2004/07/05 17:27:32 claudio Exp $ */
d61 1
@


1.37
log
@The rde no longer needs to check if the nexthop is the loopback address.
This is now down in the parent. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.36 2004/07/05 02:13:44 henning Exp $ */
d872 2
a873 2
	 * But what is the neighbor? For now let's return 0 that
	 * should not break anything.
@


1.36
log
@fix a few KNF fallouts
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.35 2004/06/24 23:15:58 claudio Exp $ */
d130 1
a130 1
		 * multicast, experimental and loopback addresses as invalid.
d133 1
a133 2
		if (IN_MULTICAST(tmp32) || IN_BADCLASS(tmp32) ||
		    (tmp32 & 0x7f000000) == 0x7f000000)
@


1.35
log
@First step at multiprotocol support, only partially done.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.34 2004/06/24 22:01:54 claudio Exp $ */
d596 1
a596 1
	
d599 1
a599 1
	
@


1.34
log
@Make community set strict aligenment save, remove unneeded ENSUREs
OK henning@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.33 2004/06/22 23:17:01 claudio Exp $ */
d47 2
d183 1
a183 1
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, ATTR_PARTIAL))
d189 15
a203 1
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL, ATTR_PARTIAL))
d205 2
d224 1
d233 1
d235 1
a235 1
		return (p);
d242 1
a242 1
			return (p);
d250 1
a250 1
		return (p);
d261 1
a261 1
			return (p);
d270 1
a270 1
			return (p);
d288 1
a288 1
			return (p);
d297 1
a297 1
			return (p);
d302 1
a302 1
			return (p);
d311 1
a311 1
			return (p);
d320 1
a320 1
			return (p);
d324 1
a324 1
			return (p);
d328 1
a328 1
			return (p);
d332 1
a332 1
			return (p);
d336 9
a344 1
			return (p);
d350 1
a350 1
			return (p);
d359 1
a359 1
		return (p);
d363 1
a363 1
	return (p);
d375 2
a376 1
	if ((a->wflags & F_ATTR_NEXTHOP) == 0)
d394 4
d554 1
a554 1
attr_optget(struct attr_flags *attr, u_int8_t type)
d578 88
@


1.33
log
@Cleanup. jajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.32 2004/06/20 18:35:12 henning Exp $ */
a28 1
#include "ensure.h"
d1014 1
a1014 1
	u_int32_t *cdata = (u_int32_t*)attr->data;
a1016 3
	ENSURE((as & ~0xffff) == 0);
	ENSURE((type & ~0xffff) == 0);
	ENSURE((ncommunities & 0x3) == 0);
d1020 1
a1020 1
		if ((ntohl(cdata[i]) & 0xffff0000) == (unsigned)as << 16)
d1022 1
d1026 1
a1026 1
		if (attr->len + 4 > 0xffff) /* overflow */
d1029 1
a1029 1
		if ((cdata = realloc(attr->data, attr->len)) == NULL)
d1031 2
a1032 1
		attr->data = (void*)cdata;
d1034 4
a1037 1
	cdata[i] = htonl(as << 16 | type);
@


1.32
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.31 2004/05/21 15:36:40 claudio Exp $ */
d345 1
a345 1
		return ATTR_ORIGIN;
d347 1
a347 1
		return ATTR_ASPATH;
d349 1
a349 1
		return ATTR_NEXTHOP;
d352 2
a353 2
			return ATTR_LOCALPREF;
	return 0;
a562 2
	ENSURE(0 <= pos && pos < 255);

d567 1
a567 1
	return as;
d579 1
a579 1
		return AS_ERR_BAD;
d582 2
d586 4
a589 3
		if (seg_type != AS_SET && seg_type != AS_SEQUENCE) {
			return AS_ERR_TYPE;
		}
d593 1
a593 1
			return AS_ERR_LEN;
d597 1
a597 1
			return AS_ERR_BAD;
d599 1
a599 1
	return 0;	/* aspath is valid but probably not loop free */
d617 1
a617 1
	return aspath;
d637 2
a638 1
		ENSURE(aspath->hdr.len > 2);
d717 1
a717 1
	return aspath->data;
d723 1
a723 1
	return aspath->hdr.len;
a737 1
		ENSURE(seg_type == AS_SET || seg_type == AS_SEQUENCE);
d745 1
a745 1
	return cnt;
d758 1
a758 1
		return 0;
d760 1
a760 2
	ENSURE(aspath->hdr.len > 2);
	return aspath_extract(aspath->data, 0);
a773 1
		ENSURE(seg_type == AS_SET || seg_type == AS_SEQUENCE);
a775 1
		ENSURE(seg_size <= len);
d778 1
a778 1
				return 0;
d781 1
a781 1
	return 1;
a798 1
		ENSURE(seg_type == AS_SET || seg_type == AS_SEQUENCE);
a800 1
		ENSURE(seg_size <= len);
d806 1
a806 1
	return hash;
d823 1
a823 1
	return 0;
a851 1
		ENSURE(seg_type == AS_SET || seg_type == AS_SEQUENCE);
a864 1
		ENSURE(seg_size <= len);
d882 1
a882 1
	return total_size;
a895 1
	ENSURE(plen < slen);
a912 1
		ENSURE(seg_type == AS_SET || seg_type == AS_SEQUENCE);
a922 1
		ENSURE(seg_size <= len);
d943 1
a943 1
	return total_size;
a966 1
		ENSURE(seg_type == AS_SET || seg_type == AS_SEQUENCE);
a974 1
		ENSURE(seg_size <= len);
a995 1
	ENSURE((len & 0x3) == 0);
d1007 1
a1007 1
			return 1;
d1009 1
a1009 1
	return 0;
@


1.31
log
@RFC 2796 bgp route reflector support. This is very useful in conjunction
with templates. looks good, go for it henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.30 2004/05/17 12:39:32 djm Exp $ */
d325 1
a325 1
		TAILQ_FOREACH(a, &attr->others, attr_l)
d388 1
a388 1
	    oa = TAILQ_NEXT(oa, attr_l), ob = TAILQ_NEXT(ob, attr_l)) {
d421 1
a421 1
	TAILQ_FOREACH(os, &s->others, attr_l)
d435 2
a436 2
		TAILQ_REMOVE(&s->others, os, attr_l);
		TAILQ_INSERT_TAIL(&t->others, os, attr_l);
d505 1
a505 1
	TAILQ_FOREACH_REVERSE(p, &attr->others, attr_list, attr_l) {
d513 1
a513 1
			TAILQ_INSERT_AFTER(&attr->others, p, a, attr_l);
d517 1
a517 1
	TAILQ_INSERT_HEAD(&attr->others, a, attr_l);
d526 1
a526 1
	TAILQ_FOREACH(a, &attr->others, attr_l) {
d542 1
a542 1
		TAILQ_REMOVE(&attr->others, a, attr_l);
@


1.30
log
@extend filter language to allow basic setting of COMMUNITIES attribute.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.29 2004/05/07 10:06:15 djm Exp $ */
d179 12
d310 9
a318 1
		/* FALLTHROUGH */
d320 1
d485 1
a485 1
    u_char *data, u_int16_t len)
d489 1
a489 10
	/* we need validate known optional attributes */

	if (flags & ATTR_OPTIONAL && ! flags & ATTR_TRANSITIVE)
		/*
		 * We already know that we're not interested in this attribute.
		 * Currently only the MED is optional and non-transitive but
		 * MED is directly stored in struct attr_flags.
		 */
		return (0);

@


1.29
log
@add a filter option to dump prefixes learned in UPDATEs into a PF table,
intended for building realtime BGP blacklists (e.g. with spamd);
ok claudio & henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.28 2004/04/30 05:47:50 deraadt Exp $ */
d996 1
a996 1
	len >>= 2; /* devide by four */
d1010 29
@


1.28
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.27 2004/04/08 16:08:21 henning Exp $ */
d357 3
a359 1
	r = aspath_compare(a->aspath, b->aspath);
@


1.27
log
@swap the last two parameters to TAILQ_FOREACH_REVERSE. matches what FreeBSD
and NetBSD do.
ok millert@@ mcbride@@ markus@@ ho@@, checked to not affect ports by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.26 2004/03/20 23:17:35 david Exp $ */
d566 1
a566 1
		/* odd lenght aspath are invalid */
@


1.26
log
@comment spelling fixes; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.25 2004/03/12 21:53:07 claudio Exp $ */
d491 1
a491 1
	TAILQ_FOREACH_REVERSE(p, &attr->others, attr_l, attr_list) {
@


1.25
log
@*size is a u_int16_t not a pointer so use 0 instead of NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.24 2004/03/12 21:21:39 claudio Exp $ */
d470 1
a470 1
		 * We already know that we're not intrested in this attribute.
@


1.24
log
@bgpctl has a empty-as keyword so make this actually work. Handle AS_EMPTY
in aspath_match().
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.23 2004/03/12 21:14:35 claudio Exp $ */
d306 1
a306 1
				*size = NULL;
@


1.23
log
@I modified the print format for AS_SET so keep the aspath_strlen() function
in sync.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.22 2004/03/12 18:09:23 claudio Exp $ */
d949 7
@


1.22
log
@tab at EOL
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.21 2004/03/12 10:52:34 claudio Exp $ */
d910 4
a913 1
			total_size += 2;
@


1.21
log
@Rewrite community_match() for loop. yaya henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.20 2004/03/11 17:12:51 claudio Exp $ */
d511 1
a511 1
	
@


1.20
log
@Add basic support for communities. Currently it is only possible to filter
on communities, e.g match from any community 24640:* set localpref 666
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.19 2004/03/11 16:38:23 claudio Exp $ */
d981 1
a981 1
	u_int16_t	 eas, etype, l;
d983 4
a986 1
	for (l = 0; l + 3 < len; len +=4) {
@


1.19
log
@Ensure that aspath_snprint() returns a zero terminated string also if the
aspath is "". Found, OK and tsc tsc tsc henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.18 2004/03/05 22:21:32 claudio Exp $ */
d40 2
a41 2
#define CHECK_FLAGS(s, t)	\
	(((s) & ~ATTR_EXTLEN) == (t))
d100 1
a100 1
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN))
d108 1
a108 1
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN))
d123 1
a123 1
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN))
d139 1
a139 1
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL))
d148 1
a148 1
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN))
d163 1
a163 1
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN))
d169 8
a176 1
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE))
d248 1
a248 1
		if (CHECK_FLAGS(flags, ATTR_WELL_KNOWN)) {
d263 1
a263 1
		if (CHECK_FLAGS(flags, ATTR_WELL_KNOWN)) {
d295 4
d300 1
a300 1
		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN)) {
a303 4
		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL)) {
			*suberr = ERR_UPD_ATTRFLAGS;
			return (p);
		}
d507 15
d846 4
a849 1
			r = snprintf(buf, size, "{ ");
d976 21
@


1.18
log
@Plug some memory leaks in rde. Based on a patch by Patrick Latifi.
Added attr_move() so that we can copy the attribute before calling the filter.
path_update() will now use the passed attribute so it can't be simply reused.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.17 2004/03/01 17:04:07 henning Exp $ */
d800 1
a800 1
			return (1);		\
d845 4
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.16 2004/02/27 20:53:56 claudio Exp $ */
d396 15
d485 1
a485 1
		if (type == p->type)
d487 2
d490 1
@


1.16
log
@remove unneded peer pointer in struct prefix and change a in_addr_t to
struct in_addr. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.15 2004/02/26 14:00:33 claudio Exp $ */
d133 1
a133 1
		    (tmp32 & 0x7f000000) == 0x7f000000) 
@


1.15
log
@Implement "enforce neighbor-as yes|no" which is by default on for ebgp
neighbors. While doing that check also that the nexthop is valid (not class D
or E and not in 127/8 range). Kill some TODO and XXX and rename the british
neighbour to neighbor as used everywhere else. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.14 2004/02/24 15:44:33 claudio Exp $ */
d131 1
a131 1
		tmp32 = ntohl(a->nexthop);
d338 1
a338 1
	if (a->nexthop > b->nexthop)
d340 1
a340 1
	if (a->nexthop < b->nexthop)
@


1.14
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.13 2004/02/23 16:46:24 claudio Exp $ */
d22 2
d64 2
a65 1
attr_parse(u_char *p, u_int16_t len, struct attr_flags *a, int ebgp)
d114 4
a117 1
		/* XXX enforce remote-as == left most AS if not disabled */
d127 8
a134 1
		/* XXX check if the nexthop is a valid IP address */
a495 4
/* TODO
 * aspath regexp search,
 * aspath to string converter
 */
d654 1
d694 1
a694 1
aspath_neighbour(struct aspath *aspath)
d698 1
a698 1
	 * But what is the neighbour? For now let's return 0 that
@


1.13
log
@While searching a different bug found those two gems. The ntohs is obvious
the plen adjusting is needed to jump over the value that we ignore.
yaya henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.12 2004/02/19 23:07:00 claudio Exp $ */
d566 1
a566 1
	
@


1.12
log
@Add support for basic filters. Nothing optimized and it has some issues but
this is a huge step forward. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.11 2004/02/19 13:54:58 claudio Exp $ */
d81 1
d139 2
a140 1
			a->lpref = 0;	/* set a default value */
@


1.11
log
@Make the code more portable. Add some missing header files and make the use
of the queue(3) makros more portable. OK henning@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.10 2004/02/19 10:55:41 claudio Exp $ */
d380 12
d549 1
d556 1
a556 1
    int prepend)
d559 1
a559 1
	int		 tot_len, as_len, size, wpos = 0;
d563 2
@


1.10
log
@Doh. Copy pasto. The if is always false and bogus.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.9 2004/02/18 23:18:16 claudio Exp $ */
d342 1
a342 1
	    oa != TAILQ_END(&a->others) && ob != TAILQ_END(&a->others);
d358 1
a358 1
	if (oa != TAILQ_END(&a->others))
d360 1
a360 1
	if (ob != TAILQ_END(&a->others))
@


1.9
log
@Correctly handle parse errors in aspath and prefixes. Also do input aspath
loop detection. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.8 2004/02/18 16:36:09 claudio Exp $ */
a687 4

	if (len & 1)
		/* odd lenght aspath are invalid */
		return AS_ERR_BAD;
@


1.8
log
@Bring the path attribute parsing on big step closer to the RFC.
Check that evry attribut is only allowed once and ensure that the
mandatory attributes are present.
no objections henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.7 2004/02/18 11:11:06 claudio Exp $ */
d62 1
a62 2
attr_parse(u_char *p, u_int16_t len, struct attr_flags *a, int ebgp,
    u_int16_t as)
a69 1
	int		 r; /* XXX */
d106 1
a106 6
		if ((r = aspath_verify(p, attr_len, as)) != 0) {
			/* XXX could also be a aspath loop but this
			 * check should be moved to the filtering. */
			/* XXX loop detection should be done afterwards
			 * because this is not an error */
			log_warnx("XXX aspath_verify failed: error %i", r);
a107 1
		}
a469 1
 * aspath loop detection (partially done I think),
d496 1
a496 1
aspath_verify(void *data, u_int16_t len, u_int16_t myAS)
a498 1
	int		 error = 0;
d500 1
a500 1
	u_int8_t	 i, seg_len, seg_type;
a519 6

		/* XXX not needed */
		for (i = 0; i < seg_len; i++) {
			if (myAS == aspath_extract(seg, i))
				error = AS_ERR_LOOP;
		}
d521 1
a521 1
	return (error);	/* aspath is valid but probably not loop free */
d682 27
d806 15
@


1.7
log
@Check for optional path attributes error. This kills some XXX in the code.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.6 2004/02/16 18:02:12 henning Exp $ */
d41 12
d103 1
d116 1
d126 1
d135 1
d149 1
d177 2
a178 1
attr_error(u_char *p, u_int16_t len, u_int8_t *suberr, u_int16_t *size)
d180 1
d217 5
d229 5
d244 5
d258 5
d267 5
d290 6
d304 16
@


1.6
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.5 2004/02/16 13:21:46 claudio Exp $ */
d150 2
a151 2
		/* XXX error checking */
		attr_optadd(a, flags, type, p, attr_len);
d359 2
a360 1
	/* XXX we need to do some basic checks (flags, len if known,...) */
d385 3
a391 1
		ENSURE(type != p->type);
d445 4
@


1.5
log
@Basic aspath match function needed for filters and the "show rib" bgpctl
command. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.4 2004/02/16 12:58:45 claudio Exp $ */
d777 1
a777 1
	
@


1.4
log
@Add basic functions to print aspath in human readable format. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.3 2004/02/16 12:53:15 claudio Exp $ */
d767 39
@


1.3
log
@Make the path attribute handling more RFC conformant. Also move the
parser to rde_attr.c where it belongs. Still missing: better aspath loop
detection (should be done afterwards) and some basic error checking for
optional attributes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.2 2004/02/09 01:56:18 henning Exp $ */
d23 1
d397 1
a397 1
	struct attr	*a, *xa;
d669 99
@


1.2
log
@replace a bunch of u_long by u_int32_t
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_attr.c,v 1.1 2004/02/04 09:18:03 claudio Exp $ */
d30 224
d352 1
a352 1
void
d358 1
d365 1
a365 1
		return;
d378 3
a380 1
	}
d385 1
a385 1
			return;
d389 2
d398 2
a399 3
	for (a = TAILQ_FIRST(&attr->others); a != TAILQ_END(&attr->others);
	    a = xa) {
		xa = TAILQ_NEXT(a, attr_l);
d438 1
d457 1
d460 1
a460 1
				return AS_ERR_LOOP;
d463 1
a463 1
	return 0;	/* all OK */
@


1.1
log
@Move BGP path attribute handling functions in a own file. henning@@ conceptual ok
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d396 1
a396 1
u_long
d400 1
a400 1
	u_long		 hash;
@

