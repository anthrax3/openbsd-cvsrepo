head	1.300;
access;
symbols
	OPENBSD_6_1_BASE:1.300
	OPENBSD_6_0:1.294.0.4
	OPENBSD_6_0_BASE:1.294
	OPENBSD_5_9:1.292.0.2
	OPENBSD_5_9_BASE:1.292
	OPENBSD_5_8:1.288.0.4
	OPENBSD_5_8_BASE:1.288
	OPENBSD_5_7:1.282.0.2
	OPENBSD_5_7_BASE:1.282
	OPENBSD_5_6:1.281.0.6
	OPENBSD_5_6_BASE:1.281
	OPENBSD_5_5:1.281.0.4
	OPENBSD_5_5_BASE:1.281
	OPENBSD_5_4:1.277.0.2
	OPENBSD_5_4_BASE:1.277
	OPENBSD_5_3:1.275.0.2
	OPENBSD_5_3_BASE:1.275
	OPENBSD_5_2:1.270.0.2
	OPENBSD_5_2_BASE:1.270
	OPENBSD_5_1_BASE:1.267
	OPENBSD_5_1:1.267.0.2
	OPENBSD_5_0:1.264.0.2
	OPENBSD_5_0_BASE:1.264
	OPENBSD_4_9:1.263.0.2
	OPENBSD_4_9_BASE:1.263
	OPENBSD_4_8:1.262.0.2
	OPENBSD_4_8_BASE:1.262
	OPENBSD_4_7:1.253.0.2
	OPENBSD_4_7_BASE:1.253
	OPENBSD_4_6:1.241.0.4
	OPENBSD_4_6_BASE:1.241
	OPENBSD_4_5:1.223.0.2
	OPENBSD_4_5_BASE:1.223
	OPENBSD_4_4:1.222.0.4
	OPENBSD_4_4_BASE:1.222
	OPENBSD_4_3:1.222.0.2
	OPENBSD_4_3_BASE:1.222
	OPENBSD_4_2:1.218.0.2
	OPENBSD_4_2_BASE:1.218
	OPENBSD_4_1:1.212.0.2
	OPENBSD_4_1_BASE:1.212
	OPENBSD_4_0:1.208.0.2
	OPENBSD_4_0_BASE:1.208
	OPENBSD_3_9:1.192.0.2
	OPENBSD_3_9_BASE:1.192
	OPENBSD_3_8:1.176.0.2
	OPENBSD_3_8_BASE:1.176
	OPENBSD_3_7:1.159.0.2
	OPENBSD_3_7_BASE:1.159
	OPENBSD_3_6:1.141.0.2
	OPENBSD_3_6_BASE:1.141
	OPENBSD_3_5:1.106.0.2
	OPENBSD_3_5_BASE:1.106;
locks; strict;
comment	@ * @;


1.300
date	2017.01.25.00.11.07;	author claudio;	state Exp;
branches;
next	1.299;
commitid	osRuMDRl3xarqyZN;

1.299
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.298;
commitid	airB1W2Kb948lFil;

1.298
date	2017.01.13.18.59.12;	author phessler;	state Exp;
branches;
next	1.297;
commitid	3Jvf15B19ysa8i2W;

1.297
date	2016.10.14.16.05.35;	author phessler;	state Exp;
branches;
next	1.296;
commitid	Ai7XVOgXw9ZLovz1;

1.296
date	2016.10.05.07.38.06;	author phessler;	state Exp;
branches;
next	1.295;
commitid	XF7pIhaJDJdwfpZW;

1.295
date	2016.09.02.14.00.29;	author benno;	state Exp;
branches;
next	1.294;
commitid	cUiKeXOsNjNjPeSK;

1.294
date	2016.06.06.15.59.10;	author benno;	state Exp;
branches;
next	1.293;
commitid	vloEJNNQZltwPJV4;

1.293
date	2016.06.03.17.36.37;	author benno;	state Exp;
branches;
next	1.292;
commitid	utIafqBHH3dRVCSC;

1.292
date	2015.11.06.16.23.26;	author phessler;	state Exp;
branches;
next	1.291;
commitid	gwEx9C0BtWsMUbsG;

1.291
date	2015.10.11.19.30.12;	author phessler;	state Exp;
branches;
next	1.290;
commitid	2KBZGXKaVqa0PMnV;

1.290
date	2015.09.21.09.47.15;	author phessler;	state Exp;
branches;
next	1.289;
commitid	0iY3tr4GQ1eTlhDV;

1.289
date	2015.09.16.20.25.41;	author stsp;	state Exp;
branches;
next	1.288;
commitid	DdIYNjrFkyhcmdeI;

1.288
date	2015.07.20.16.10.38;	author claudio;	state Exp;
branches;
next	1.287;
commitid	JXdI3dG8XAYCUdaO;

1.287
date	2015.07.18.22.52.39;	author benno;	state Exp;
branches;
next	1.286;
commitid	nZLC4rTYzidfI7tQ;

1.286
date	2015.07.16.18.26.04;	author claudio;	state Exp;
branches;
next	1.285;
commitid	LqSO5lx1xfCVcctP;

1.285
date	2015.04.25.15.28.18;	author phessler;	state Exp;
branches;
next	1.284;
commitid	4yPC9ACFnDblFb1s;

1.284
date	2015.03.14.03.52.42;	author claudio;	state Exp;
branches;
next	1.283;
commitid	1OLz8RQEaC2xclFf;

1.283
date	2015.03.14.02.43.02;	author claudio;	state Exp;
branches;
next	1.282;
commitid	0cBsZXPDxYuXNDWX;

1.282
date	2014.11.03.16.55.59;	author bluhm;	state Exp;
branches;
next	1.281;
commitid	SvRBB6vjZmF8ZSzf;

1.281
date	2013.11.13.09.14.48;	author florian;	state Exp;
branches;
next	1.280;

1.280
date	2013.10.19.15.04.25;	author claudio;	state Exp;
branches;
next	1.279;

1.279
date	2013.09.27.08.23.10;	author sthen;	state Exp;
branches;
next	1.278;

1.278
date	2013.08.14.20.34.25;	author claudio;	state Exp;
branches;
next	1.277;

1.277
date	2013.05.11.14.42.28;	author benno;	state Exp;
branches;
next	1.276;

1.276
date	2013.03.07.21.26.28;	author claudio;	state Exp;
branches;
next	1.275;

1.275
date	2013.01.09.08.04.25;	author phessler;	state Exp;
branches;
next	1.274;

1.274
date	2012.11.13.09.47.20;	author claudio;	state Exp;
branches;
next	1.273;

1.273
date	2012.09.18.10.10.00;	author claudio;	state Exp;
branches;
next	1.272;

1.272
date	2012.09.18.09.45.51;	author claudio;	state Exp;
branches;
next	1.271;

1.271
date	2012.09.12.05.56.22;	author claudio;	state Exp;
branches;
next	1.270;

1.270
date	2012.05.27.18.52.07;	author claudio;	state Exp;
branches;
next	1.269;

1.269
date	2012.04.12.17.31.05;	author claudio;	state Exp;
branches;
next	1.268;

1.268
date	2012.03.27.18.22.07;	author claudio;	state Exp;
branches;
next	1.267;

1.267
date	2011.09.20.21.19.06;	author claudio;	state Exp;
branches;
next	1.266;

1.266
date	2011.09.19.11.18.11;	author claudio;	state Exp;
branches;
next	1.265;

1.265
date	2011.09.18.09.31.25;	author claudio;	state Exp;
branches;
next	1.264;

1.264
date	2011.05.01.12.56.04;	author claudio;	state Exp;
branches;
next	1.263;

1.263
date	2010.10.24.17.20.08;	author deraadt;	state Exp;
branches;
next	1.262;

1.262
date	2010.06.27.19.53.34;	author claudio;	state Exp;
branches;
next	1.261;

1.261
date	2010.05.19.12.44.14;	author claudio;	state Exp;
branches;
next	1.260;

1.260
date	2010.05.17.16.08.20;	author claudio;	state Exp;
branches;
next	1.259;

1.259
date	2010.05.17.15.49.29;	author claudio;	state Exp;
branches;
next	1.258;

1.258
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.257;

1.257
date	2010.04.28.13.07.48;	author claudio;	state Exp;
branches;
next	1.256;

1.256
date	2010.04.13.09.09.48;	author claudio;	state Exp;
branches;
next	1.255;

1.255
date	2010.04.06.13.25.08;	author claudio;	state Exp;
branches;
next	1.254;

1.254
date	2010.03.29.09.04.43;	author claudio;	state Exp;
branches;
next	1.253;

1.253
date	2010.03.05.15.25.00;	author claudio;	state Exp;
branches;
next	1.252;

1.252
date	2010.01.13.06.02.37;	author claudio;	state Exp;
branches;
next	1.251;

1.251
date	2010.01.10.00.15.09;	author claudio;	state Exp;
branches;
next	1.250;

1.250
date	2009.12.16.15.40.55;	author claudio;	state Exp;
branches;
next	1.249;

1.249
date	2009.12.08.14.03.40;	author claudio;	state Exp;
branches;
next	1.248;

1.248
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.247;

1.247
date	2009.11.26.13.40.43;	author henning;	state Exp;
branches;
next	1.246;

1.246
date	2009.11.02.20.38.15;	author claudio;	state Exp;
branches;
next	1.245;

1.245
date	2009.09.04.11.50.28;	author claudio;	state Exp;
branches;
next	1.244;

1.244
date	2009.08.31.13.03.31;	author claudio;	state Exp;
branches;
next	1.243;

1.243
date	2009.07.23.14.53.18;	author claudio;	state Exp;
branches;
next	1.242;

1.242
date	2009.07.20.15.03.16;	author claudio;	state Exp;
branches;
next	1.241;

1.241
date	2009.06.12.16.42.53;	author claudio;	state Exp;
branches;
next	1.240;

1.240
date	2009.06.07.00.30.23;	author claudio;	state Exp;
branches;
next	1.239;

1.239
date	2009.06.06.21.35.32;	author claudio;	state Exp;
branches;
next	1.238;

1.238
date	2009.06.06.18.31.42;	author pyr;	state Exp;
branches;
next	1.237;

1.237
date	2009.06.06.06.33.15;	author eric;	state Exp;
branches;
next	1.236;

1.236
date	2009.06.06.06.04.10;	author claudio;	state Exp;
branches;
next	1.235;

1.235
date	2009.06.06.01.10.29;	author claudio;	state Exp;
branches;
next	1.234;

1.234
date	2009.06.05.19.52.32;	author claudio;	state Exp;
branches;
next	1.233;

1.233
date	2009.06.04.04.46.42;	author claudio;	state Exp;
branches;
next	1.232;

1.232
date	2009.05.27.04.18.21;	author reyk;	state Exp;
branches;
next	1.231;

1.231
date	2009.05.17.12.25.15;	author claudio;	state Exp;
branches;
next	1.230;

1.230
date	2009.05.05.20.12.04;	author sthen;	state Exp;
branches;
next	1.229;

1.229
date	2009.04.23.16.20.39;	author sthen;	state Exp;
branches;
next	1.228;

1.228
date	2009.03.26.13.59.30;	author henning;	state Exp;
branches;
next	1.227;

1.227
date	2009.03.22.22.34.59;	author henning;	state Exp;
branches;
next	1.226;

1.226
date	2009.03.18.19.41.41;	author claudio;	state Exp;
branches;
next	1.225;

1.225
date	2009.03.13.06.25.04;	author claudio;	state Exp;
branches;
next	1.224;

1.224
date	2009.03.13.04.40.55;	author claudio;	state Exp;
branches;
next	1.223;

1.223
date	2008.12.12.23.15.12;	author claudio;	state Exp;
branches;
next	1.222;

1.222
date	2008.01.23.08.11.32;	author claudio;	state Exp;
branches;
next	1.221;

1.221
date	2007.12.23.18.26.13;	author henning;	state Exp;
branches;
next	1.220;

1.220
date	2007.10.13.16.35.19;	author deraadt;	state Exp;
branches;
next	1.219;

1.219
date	2007.09.11.17.07.59;	author henning;	state Exp;
branches;
next	1.218;

1.218
date	2007.05.28.17.26.33;	author henning;	state Exp;
branches;
next	1.217;

1.217
date	2007.05.15.14.35.30;	author claudio;	state Exp;
branches;
next	1.216;

1.216
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.215;

1.215
date	2007.03.28.12.33.32;	author henning;	state Exp;
branches;
next	1.214;

1.214
date	2007.03.16.14.06.57;	author claudio;	state Exp;
branches;
next	1.213;

1.213
date	2007.03.16.13.52.30;	author claudio;	state Exp;
branches;
next	1.212;

1.212
date	2007.03.06.16.52.48;	author henning;	state Exp;
branches;
next	1.211;

1.211
date	2007.01.26.17.40.49;	author claudio;	state Exp;
branches;
next	1.210;

1.210
date	2006.12.05.12.08.13;	author henning;	state Exp;
branches;
next	1.209;

1.209
date	2006.11.28.16.39.34;	author henning;	state Exp;
branches;
next	1.208;

1.208
date	2006.08.27.16.11.04;	author henning;	state Exp;
branches;
next	1.207;

1.207
date	2006.08.27.13.40.21;	author henning;	state Exp;
branches;
next	1.206;

1.206
date	2006.08.23.08.13.04;	author claudio;	state Exp;
branches;
next	1.205;

1.205
date	2006.08.04.12.01.48;	author henning;	state Exp;
branches;
next	1.204;

1.204
date	2006.06.17.14.06.09;	author henning;	state Exp;
branches;
next	1.203;

1.203
date	2006.06.15.10.04.40;	author claudio;	state Exp;
branches;
next	1.202;

1.202
date	2006.06.14.17.08.56;	author claudio;	state Exp;
branches;
next	1.201;

1.201
date	2006.05.27.21.24.36;	author claudio;	state Exp;
branches;
next	1.200;

1.200
date	2006.05.23.12.11.38;	author henning;	state Exp;
branches;
next	1.199;

1.199
date	2006.04.26.17.13.14;	author claudio;	state Exp;
branches;
next	1.198;

1.198
date	2006.04.25.08.44.08;	author claudio;	state Exp;
branches;
next	1.197;

1.197
date	2006.04.21.08.51.46;	author claudio;	state Exp;
branches;
next	1.196;

1.196
date	2006.04.04.12.03.26;	author henning;	state Exp;
branches;
next	1.195;

1.195
date	2006.03.22.13.30.35;	author claudio;	state Exp;
branches;
next	1.194;

1.194
date	2006.03.22.10.18.49;	author claudio;	state Exp;
branches;
next	1.193;

1.193
date	2006.03.15.11.33.42;	author claudio;	state Exp;
branches;
next	1.192;

1.192
date	2006.02.10.14.34.40;	author claudio;	state Exp;
branches;
next	1.191;

1.191
date	2006.02.09.21.05.09;	author claudio;	state Exp;
branches;
next	1.190;

1.190
date	2006.02.02.14.06.05;	author claudio;	state Exp;
branches;
next	1.189;

1.189
date	2006.01.24.15.28.02;	author henning;	state Exp;
branches;
next	1.188;

1.188
date	2006.01.24.10.03.44;	author henning;	state Exp;
branches;
next	1.187;

1.187
date	2006.01.20.16.40.17;	author claudio;	state Exp;
branches;
next	1.186;

1.186
date	2006.01.05.17.33.39;	author claudio;	state Exp;
branches;
next	1.185;

1.185
date	2006.01.05.16.00.07;	author claudio;	state Exp;
branches;
next	1.184;

1.184
date	2006.01.04.12.45.53;	author claudio;	state Exp;
branches;
next	1.183;

1.183
date	2006.01.03.22.49.17;	author claudio;	state Exp;
branches;
next	1.182;

1.182
date	2006.01.03.22.19.59;	author claudio;	state Exp;
branches;
next	1.181;

1.181
date	2005.11.02.15.34.43;	author claudio;	state Exp;
branches;
next	1.180;

1.180
date	2005.11.01.10.58.29;	author claudio;	state Exp;
branches;
next	1.179;

1.179
date	2005.10.19.12.32.16;	author henning;	state Exp;
branches;
next	1.178;

1.178
date	2005.10.19.10.42.06;	author henning;	state Exp;
branches;
next	1.177;

1.177
date	2005.09.20.13.31.53;	author henning;	state Exp;
branches;
next	1.176;

1.176
date	2005.08.09.20.27.25;	author claudio;	state Exp;
branches;
next	1.175;

1.175
date	2005.07.04.09.37.24;	author claudio;	state Exp;
branches;
next	1.174;

1.174
date	2005.07.01.13.38.14;	author claudio;	state Exp;
branches;
next	1.173;

1.173
date	2005.07.01.09.19.24;	author claudio;	state Exp;
branches;
next	1.172;

1.172
date	2005.06.29.09.43.25;	author claudio;	state Exp;
branches;
next	1.171;

1.171
date	2005.06.28.12.12.34;	author claudio;	state Exp;
branches;
next	1.170;

1.170
date	2005.06.25.19.24.37;	author henning;	state Exp;
branches;
next	1.169;

1.169
date	2005.06.24.14.01.52;	author claudio;	state Exp;
branches;
next	1.168;

1.168
date	2005.06.13.21.16.18;	author henning;	state Exp;
branches;
next	1.167;

1.167
date	2005.06.09.15.32.03;	author claudio;	state Exp;
branches;
next	1.166;

1.166
date	2005.05.27.17.52.11;	author claudio;	state Exp;
branches;
next	1.165;

1.165
date	2005.04.28.13.54.45;	author claudio;	state Exp;
branches;
next	1.164;

1.164
date	2005.04.26.15.18.22;	author henning;	state Exp;
branches;
next	1.163;

1.163
date	2005.04.12.14.32.00;	author claudio;	state Exp;
branches;
next	1.162;

1.162
date	2005.03.28.15.16.46;	author henning;	state Exp;
branches;
next	1.161;

1.161
date	2005.03.28.15.03.33;	author henning;	state Exp;
branches;
next	1.160;

1.160
date	2005.03.23.10.46.26;	author henning;	state Exp;
branches;
next	1.159;

1.159
date	2005.03.15.10.18.39;	author henning;	state Exp;
branches;
next	1.158;

1.158
date	2005.03.14.17.32.04;	author claudio;	state Exp;
branches;
next	1.157;

1.157
date	2005.03.14.12.25.50;	author henning;	state Exp;
branches;
next	1.156;

1.156
date	2005.03.11.12.54.19;	author claudio;	state Exp;
branches;
next	1.155;

1.155
date	2005.02.01.21.36.01;	author henning;	state Exp;
branches;
next	1.154;

1.154
date	2004.12.23.17.26.51;	author henning;	state Exp;
branches;
next	1.153;

1.153
date	2004.12.23.15.39.22;	author henning;	state Exp;
branches;
next	1.152;

1.152
date	2004.12.23.15.08.43;	author henning;	state Exp;
branches;
next	1.151;

1.151
date	2004.11.23.13.07.01;	author claudio;	state Exp;
branches;
next	1.150;

1.150
date	2004.11.19.14.43.56;	author claudio;	state Exp;
branches;
next	1.149;

1.149
date	2004.11.18.17.17.56;	author henning;	state Exp;
branches;
next	1.148;

1.148
date	2004.11.18.17.07.38;	author henning;	state Exp;
branches;
next	1.147;

1.147
date	2004.11.18.15.40.58;	author henning;	state Exp;
branches;
next	1.146;

1.146
date	2004.11.11.10.35.15;	author claudio;	state Exp;
branches;
next	1.145;

1.145
date	2004.10.19.12.02.50;	author henning;	state Exp;
branches;
next	1.144;

1.144
date	2004.09.28.12.09.31;	author claudio;	state Exp;
branches;
next	1.143;

1.143
date	2004.09.16.17.58.13;	author henning;	state Exp;
branches;
next	1.142;

1.142
date	2004.09.16.17.36.29;	author henning;	state Exp;
branches;
next	1.141;

1.141
date	2004.08.20.15.49.02;	author henning;	state Exp;
branches;
next	1.140;

1.140
date	2004.08.10.13.02.07;	author claudio;	state Exp;
branches;
next	1.139;

1.139
date	2004.08.06.12.04.08;	author claudio;	state Exp;
branches;
next	1.138;

1.138
date	2004.08.05.15.58.21;	author claudio;	state Exp;
branches;
next	1.137;

1.137
date	2004.07.30.14.44.30;	author claudio;	state Exp;
branches;
next	1.136;

1.136
date	2004.07.27.15.26.45;	author henning;	state Exp;
branches;
next	1.135;

1.135
date	2004.07.05.16.54.53;	author henning;	state Exp;
branches;
next	1.134;

1.134
date	2004.07.05.02.13.44;	author henning;	state Exp;
branches;
next	1.133;

1.133
date	2004.07.03.17.19.59;	author claudio;	state Exp;
branches;
next	1.132;

1.132
date	2004.06.25.20.08.46;	author henning;	state Exp;
branches;
next	1.131;

1.131
date	2004.06.23.00.11.27;	author claudio;	state Exp;
branches;
next	1.130;

1.130
date	2004.06.22.20.28.58;	author claudio;	state Exp;
branches;
next	1.129;

1.129
date	2004.06.22.07.22.31;	author henning;	state Exp;
branches;
next	1.128;

1.128
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.127;

1.127
date	2004.06.20.17.49.46;	author henning;	state Exp;
branches;
next	1.126;

1.126
date	2004.06.06.17.38.10;	author henning;	state Exp;
branches;
next	1.125;

1.125
date	2004.05.21.15.36.40;	author claudio;	state Exp;
branches;
next	1.124;

1.124
date	2004.05.21.11.48.56;	author claudio;	state Exp;
branches;
next	1.123;

1.123
date	2004.05.17.12.39.32;	author djm;	state Exp;
branches;
next	1.122;

1.122
date	2004.05.07.10.06.15;	author djm;	state Exp;
branches;
next	1.121;

1.121
date	2004.05.06.14.41.47;	author henning;	state Exp;
branches;
next	1.120;

1.120
date	2004.05.06.11.57.55;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2004.04.29.19.56.04;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2004.04.28.04.34.46;	author henning;	state Exp;
branches;
next	1.117;

1.117
date	2004.04.28.02.57.27;	author claudio;	state Exp;
branches;
next	1.116;

1.116
date	2004.04.28.01.08.38;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2004.04.28.00.38.39;	author henning;	state Exp;
branches;
next	1.114;

1.114
date	2004.04.27.22.42.13;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2004.04.27.22.06.54;	author henning;	state Exp;
branches;
next	1.112;

1.112
date	2004.04.27.03.53.42;	author henning;	state Exp;
branches;
next	1.111;

1.111
date	2004.04.26.04.13.59;	author henning;	state Exp;
branches;
next	1.110;

1.110
date	2004.04.26.01.59.26;	author henning;	state Exp;
branches;
next	1.109;

1.109
date	2004.04.25.07.16.24;	author henning;	state Exp;
branches;
next	1.108;

1.108
date	2004.04.24.19.36.19;	author henning;	state Exp;
branches;
next	1.107;

1.107
date	2004.04.10.17.27.28;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2004.03.11.17.12.51;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2004.03.10.11.38.32;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2004.03.02.19.45.04;	author henning;	state Exp;
branches;
next	1.103;

1.103
date	2004.03.02.19.29.01;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2004.03.01.16.02.01;	author claudio;	state Exp;
branches;
next	1.101;

1.101
date	2004.02.26.16.16.41;	author claudio;	state Exp;
branches;
next	1.100;

1.100
date	2004.02.26.14.00.33;	author claudio;	state Exp;
branches;
next	1.99;

1.99
date	2004.02.26.09.53.58;	author claudio;	state Exp;
branches;
next	1.98;

1.98
date	2004.02.24.15.43.03;	author claudio;	state Exp;
branches;
next	1.97;

1.97
date	2004.02.16.17.24.04;	author henning;	state Exp;
branches;
next	1.96;

1.96
date	2004.02.16.14.26.29;	author claudio;	state Exp;
branches;
next	1.95;

1.95
date	2004.02.16.12.53.15;	author claudio;	state Exp;
branches;
next	1.94;

1.94
date	2004.02.10.23.10.23;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2004.02.09.01.46.34;	author henning;	state Exp;
branches;
next	1.92;

1.92
date	2004.02.07.11.42.30;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2004.02.06.20.18.18;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2004.02.05.14.29.09;	author henning;	state Exp;
branches;
next	1.89;

1.89
date	2004.02.01.19.46.05;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2004.01.28.23.31.28;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2004.01.28.17.27.55;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2004.01.28.11.03.32;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2004.01.27.22.18.28;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2004.01.27.21.56.21;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2004.01.27.21.23.39;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2004.01.27.16.49.53;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2004.01.27.14.09.36;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2004.01.26.14.42.47;	author henning;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.23.21.17.51;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2004.01.22.21.08.59;	author henning;	state Exp;
branches;
next	1.77;

1.77
date	2004.01.22.20.59.16;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2004.01.22.19.13.56;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2004.01.22.03.18.03;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.22.03.07.51;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2004.01.18.19.15.00;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2004.01.17.21.06.55;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.17.19.35.36;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.17.18.27.19;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.17.18.05.46;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.13.13.45.49;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.13.13.34.56;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.11.22.01.13;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.11.20.13.00;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.11.19.42.27;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.11.19.14.43;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.11.02.35.14;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.09.19.08.50;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.09.14.10.06;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.09.13.47.07;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.08.16.17.12;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.06.23.14.58;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.06.20.41.55;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.05.22.57.59;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.05.16.21.14;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.04.19.39.46;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2004.01.04.18.51.23;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.03.20.37.34;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.03.20.22.07;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.03.13.54.27;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.02.02.27.57;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2004.01.01.23.46.47;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.01.23.09.08;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.28.14.34.30;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.27.14.24.42;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.27.01.30.00;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.27.00.53.51;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.26.20.52.14;	author jakob;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.26.20.06.01;	author jakob;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.26.18.07.32;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.26.17.47.04;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.26.16.48.07;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.26.16.37.04;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.26.14.38.58;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.26.14.27.58;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.26.14.26.02;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.26.00.49.52;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.26.00.27.23;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.26.00.23.48;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.26.00.14.04;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.25.23.22.13;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.25.23.15.58;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.25.17.07.24;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.25.14.28.49;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.25.02.24.26;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.25.02.09.19;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.25.02.04.46;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.24.23.14.23;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.24.20.09.57;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.24.19.59.24;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.24.19.21.20;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.24.13.49.21;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.23.18.28.05;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.23.01.06.21;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.22.15.22.13;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.22.15.07.05;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.21.23.28.39;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.21.23.26.37;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.21.18.21.24;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.21.16.11.33;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.20.21.19.40;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.20.21.14.55;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.20.20.25.20;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.20.18.32.22;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.20.14.33.09;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;


desc
@@


1.300
log
@Flag the Loc-RIB with F_RIB_LOCAL so we can remove one ugly hack somewhere else
@
text
@/*	$OpenBSD: bgpd.h,v 1.299 2017/01/24 04:22:42 benno Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef __BGPD_H__
#define	__BGPD_H__

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <net/route.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/pfkeyv2.h>

#include <poll.h>
#include <stdarg.h>

#include <imsg.h>

#define	BGP_VERSION			4
#define	BGP_PORT			179
#define	CONFFILE			"/etc/bgpd.conf"
#define	BGPD_USER			"_bgpd"
#define	PEER_DESCR_LEN			32
#define	SHUT_COMM_LEN			129
#define	PFTABLE_LEN			32
#define	TCP_MD5_KEY_LEN			80
#define	IPSEC_ENC_KEY_LEN		32
#define	IPSEC_AUTH_KEY_LEN		20

#define	MAX_PKTSIZE			4096
#define	MIN_HOLDTIME			3
#define	READ_BUF_SIZE			65535
#define	RT_BUF_SIZE			16384
#define	MAX_RTSOCK_BUF			128 * 1024

#define	BGPD_OPT_VERBOSE		0x0001
#define	BGPD_OPT_VERBOSE2		0x0002
#define	BGPD_OPT_NOACTION		0x0004
#define	BGPD_OPT_FORCE_DEMOTE		0x0008

#define	BGPD_FLAG_NO_EVALUATE		0x0002
#define	BGPD_FLAG_REFLECTOR		0x0004
#define	BGPD_FLAG_NEXTHOP_BGP		0x0080
#define	BGPD_FLAG_NEXTHOP_DEFAULT	0x1000
#define	BGPD_FLAG_DECISION_MASK		0x0f00
#define	BGPD_FLAG_DECISION_ROUTEAGE	0x0100
#define	BGPD_FLAG_DECISION_TRANS_AS	0x0200
#define	BGPD_FLAG_DECISION_MED_ALWAYS	0x0400

#define	BGPD_LOG_UPDATES		0x0001

#define	SOCKET_NAME			"/var/run/bgpd.sock"

#define	F_BGPD_INSERTED		0x0001
#define	F_KERNEL		0x0002
#define	F_CONNECTED		0x0004
#define	F_NEXTHOP		0x0008
#define	F_DOWN			0x0010
#define	F_STATIC		0x0020
#define	F_DYNAMIC		0x0040
#define	F_REJECT		0x0080
#define	F_BLACKHOLE		0x0100
#define	F_LONGER		0x0200
#define	F_MPLS			0x0400
#define	F_REDISTRIBUTED		0x0800
#define	F_CTL_DETAIL		0x1000	/* only used by bgpctl */
#define	F_CTL_ADJ_IN		0x2000
#define	F_CTL_ADJ_OUT		0x4000
#define	F_CTL_ACTIVE		0x8000
#define	F_RTLABEL		0x10000

/*
 * Limit the number of control messages generated by the RDE and queued in
 * session engine. The RDE limit defines how many imsg are generated in
 * one poll round. Then if the SE limit is hit the RDE control socket will no
 * longer be polled.
 */
#define RDE_RUNNER_ROUNDS	100
#define SESSION_CTL_QUEUE_MAX	10000

enum bgpd_process {
	PROC_MAIN,
	PROC_SE,
	PROC_RDE
} bgpd_process;

enum reconf_action {
	RECONF_NONE,
	RECONF_KEEP,
	RECONF_REINIT,
	RECONF_RELOAD,
	RECONF_DELETE
};

/* Address Family Numbers as per RFC 1700 */
#define	AFI_UNSPEC	0
#define	AFI_IPv4	1
#define	AFI_IPv6	2

/* Subsequent Address Family Identifier as per RFC 4760 */
#define	SAFI_NONE	0
#define	SAFI_UNICAST	1
#define	SAFI_MULTICAST	2
#define	SAFI_MPLS	4
#define	SAFI_MPLSVPN	128

struct aid {
	u_int16_t	 afi;
	sa_family_t	 af;
	u_int8_t	 safi;
	char		*name;
};

extern const struct aid aid_vals[];

#define	AID_UNSPEC	0
#define	AID_INET	1
#define	AID_INET6	2
#define	AID_VPN_IPv4	3
#define	AID_MAX		4
#define	AID_MIN		1	/* skip AID_UNSPEC since that is a dummy */

#define AID_VALS	{					\
	/* afi, af, safii, name */				\
	{ AFI_UNSPEC, AF_UNSPEC, SAFI_NONE, "unspec"},		\
	{ AFI_IPv4, AF_INET, SAFI_UNICAST, "IPv4 unicast" },	\
	{ AFI_IPv6, AF_INET6, SAFI_UNICAST, "IPv6 unicast" },	\
	{ AFI_IPv4, AF_INET, SAFI_MPLSVPN, "IPv4 vpn" }		\
}

#define AID_PTSIZE	{				\
	0,						\
	sizeof(struct pt_entry4), 			\
	sizeof(struct pt_entry6),			\
	sizeof(struct pt_entry_vpn4)			\
}

struct vpn4_addr {
	u_int64_t	rd;
	struct in_addr	addr;
	u_int8_t	labelstack[21];	/* max that makes sense */
	u_int8_t	labellen;
	u_int8_t	pad1;
	u_int8_t	pad2;
};

#define BGP_MPLS_BOS	0x01

struct bgpd_addr {
	union {
		struct in_addr		v4;
		struct in6_addr		v6;
		struct vpn4_addr	vpn4;
		/* maximum size for a prefix is 256 bits */
		u_int8_t		addr8[32];
		u_int16_t		addr16[16];
		u_int32_t		addr32[8];
	} ba;		    /* 128-bit address */
	u_int32_t	scope_id;	/* iface scope id for v6 */
	u_int8_t	aid;
#define	v4	ba.v4
#define	v6	ba.v6
#define	vpn4	ba.vpn4
#define	addr8	ba.addr8
#define	addr16	ba.addr16
#define	addr32	ba.addr32
};

#define	DEFAULT_LISTENER	0x01
#define	LISTENER_LISTENING	0x02

struct listen_addr {
	TAILQ_ENTRY(listen_addr)	 entry;
	struct sockaddr_storage		 sa;
	int				 fd;
	enum reconf_action		 reconf;
	u_int8_t			 flags;
};

TAILQ_HEAD(listen_addrs, listen_addr);
TAILQ_HEAD(filter_set_head, filter_set);

struct rdomain;
SIMPLEQ_HEAD(rdomain_head, rdomain);

struct network;
TAILQ_HEAD(network_head, network);

struct filter_rule;
TAILQ_HEAD(filter_head, filter_rule);

struct bgpd_config {
	struct rdomain_head			 rdomains;
	struct network_head			 networks;
	struct filter_head			*filters;
	struct listen_addrs			*listen_addrs;
	struct mrt_head				*mrt;
	char					*csock;
	char					*rcsock;
	int					 flags;
	int					 log;
	u_int32_t				 bgpid;
	u_int32_t				 clusterid;
	u_int32_t				 as;
	u_int16_t				 short_as;
	u_int16_t				 holdtime;
	u_int16_t				 min_holdtime;
	u_int16_t				 connectretry;
	u_int8_t				 fib_priority;
};

extern int cmd_opts;

enum announce_type {
	ANNOUNCE_UNDEF,
	ANNOUNCE_SELF,
	ANNOUNCE_NONE,
	ANNOUNCE_DEFAULT_ROUTE,
	ANNOUNCE_ALL
};

enum enforce_as {
	ENFORCE_AS_UNDEF,
	ENFORCE_AS_OFF,
	ENFORCE_AS_ON
};

enum auth_method {
	AUTH_NONE,
	AUTH_MD5SIG,
	AUTH_IPSEC_MANUAL_ESP,
	AUTH_IPSEC_MANUAL_AH,
	AUTH_IPSEC_IKE_ESP,
	AUTH_IPSEC_IKE_AH
};

struct peer_auth {
	char			md5key[TCP_MD5_KEY_LEN];
	char			auth_key_in[IPSEC_AUTH_KEY_LEN];
	char			auth_key_out[IPSEC_AUTH_KEY_LEN];
	char			enc_key_in[IPSEC_ENC_KEY_LEN];
	char			enc_key_out[IPSEC_ENC_KEY_LEN];
	u_int32_t		spi_in;
	u_int32_t		spi_out;
	enum auth_method	method;
	u_int8_t		md5key_len;
	u_int8_t		auth_alg_in;
	u_int8_t		auth_alg_out;
	u_int8_t		auth_keylen_in;
	u_int8_t		auth_keylen_out;
	u_int8_t		enc_alg_in;
	u_int8_t		enc_alg_out;
	u_int8_t		enc_keylen_in;
	u_int8_t		enc_keylen_out;
};

struct capabilities {
	struct {
		int16_t	timeout;	/* graceful restart timeout */
		int8_t	flags[AID_MAX];	/* graceful restart per AID flags */
		int8_t	restart;	/* graceful restart, RFC 4724 */
	}	grestart;
	int8_t	mp[AID_MAX];		/* multiprotocol extensions, RFC 4760 */
	int8_t	refresh;		/* route refresh, RFC 2918 */
	int8_t	as4byte;		/* 4-byte ASnum, RFC 4893 */
};

#define	CAPA_GR_PRESENT		0x01
#define	CAPA_GR_RESTART		0x02
#define	CAPA_GR_FORWARD		0x04
#define	CAPA_GR_RESTARTING	0x08

#define	CAPA_GR_TIMEMASK	0x0fff
#define	CAPA_GR_R_FLAG		0x8000
#define	CAPA_GR_F_FLAG		0x80

struct peer_config {
	struct bgpd_addr	 remote_addr;
	struct bgpd_addr	 local_addr;
	struct peer_auth	 auth;
	struct capabilities	 capabilities;
	char			 group[PEER_DESCR_LEN];
	char			 descr[PEER_DESCR_LEN];
	char			 shutcomm[SHUT_COMM_LEN];
	char			 rib[PEER_DESCR_LEN];
	char			 if_depend[IFNAMSIZ];
	char			 demote_group[IFNAMSIZ];
	u_int32_t		 id;
	u_int32_t		 groupid;
	u_int32_t		 remote_as;
	u_int32_t		 local_as;
	u_int32_t		 max_prefix;
	enum announce_type	 announce_type;
	enum enforce_as		 enforce_as;
	enum reconf_action	 reconf_action;
	u_int16_t		 max_prefix_restart;
	u_int16_t		 holdtime;
	u_int16_t		 min_holdtime;
	u_int16_t		 local_short_as;
	u_int8_t		 template;
	u_int8_t		 remote_masklen;
	u_int8_t		 ebgp;		/* 0 = ibgp else ebgp */
	u_int8_t		 distance;	/* 1 = direct, >1 = multihop */
	u_int8_t		 passive;
	u_int8_t		 down;
	u_int8_t		 announce_capa;
	u_int8_t		 reflector_client;
	u_int8_t		 softreconfig_in;
	u_int8_t		 softreconfig_out;
	u_int8_t		 ttlsec;	/* TTL security hack */
	u_int8_t		 flags;
};

#define PEERFLAG_TRANS_AS	0x01
#define PEERFLAG_LOG_UPDATES	0x02

enum network_type {
	NETWORK_DEFAULT,
	NETWORK_STATIC,
	NETWORK_CONNECTED,
	NETWORK_RTLABEL,
	NETWORK_MRTCLONE
};

struct network_config {
	struct bgpd_addr	 prefix;
	struct filter_set_head	 attrset;
	struct rde_aspath	*asp;
	u_int			 rtableid;
	u_int16_t		 rtlabel;
	enum network_type	 type;
	u_int8_t		 prefixlen;
	u_int8_t		 old;	/* used for reloading */
};

struct network {
	struct network_config		net;
	TAILQ_ENTRY(network)		entry;
};

enum imsg_type {
	IMSG_NONE,
	IMSG_CTL_END,
	IMSG_CTL_RELOAD,
	IMSG_CTL_FIB_COUPLE,
	IMSG_CTL_FIB_DECOUPLE,
	IMSG_CTL_NEIGHBOR_UP,
	IMSG_CTL_NEIGHBOR_DOWN,
	IMSG_CTL_NEIGHBOR_CLEAR,
	IMSG_CTL_NEIGHBOR_RREFRESH,
	IMSG_CTL_NEIGHBOR_DESTROY,
	IMSG_CTL_KROUTE,
	IMSG_CTL_KROUTE_ADDR,
	IMSG_CTL_RESULT,
	IMSG_CTL_SHOW_NEIGHBOR,
	IMSG_CTL_SHOW_NEXTHOP,
	IMSG_CTL_SHOW_INTERFACE,
	IMSG_CTL_SHOW_RIB,
	IMSG_CTL_SHOW_RIB_AS,
	IMSG_CTL_SHOW_RIB_PREFIX,
	IMSG_CTL_SHOW_RIB_ATTR,
	IMSG_CTL_SHOW_RIB_COMMUNITY,
	IMSG_CTL_SHOW_RIB_LARGECOMMUNITY,
	IMSG_CTL_SHOW_NETWORK,
	IMSG_CTL_SHOW_RIB_MEM,
	IMSG_CTL_SHOW_TERSE,
	IMSG_CTL_SHOW_TIMER,
	IMSG_CTL_LOG_VERBOSE,
	IMSG_CTL_SHOW_FIB_TABLES,
	IMSG_NETWORK_ADD,
	IMSG_NETWORK_ASPATH,
	IMSG_NETWORK_ATTR,
	IMSG_NETWORK_REMOVE,
	IMSG_NETWORK_FLUSH,
	IMSG_NETWORK_DONE,
	IMSG_FILTER_SET,
	IMSG_SOCKET_CONN,
	IMSG_SOCKET_CONN_CTL,
	IMSG_RECONF_CONF,
	IMSG_RECONF_RIB,
	IMSG_RECONF_PEER,
	IMSG_RECONF_FILTER,
	IMSG_RECONF_LISTENER,
	IMSG_RECONF_CTRL,
	IMSG_RECONF_RDOMAIN,
	IMSG_RECONF_RDOMAIN_EXPORT,
	IMSG_RECONF_RDOMAIN_IMPORT,
	IMSG_RECONF_RDOMAIN_DONE,
	IMSG_RECONF_DONE,
	IMSG_UPDATE,
	IMSG_UPDATE_ERR,
	IMSG_SESSION_ADD,
	IMSG_SESSION_UP,
	IMSG_SESSION_DOWN,
	IMSG_SESSION_STALE,
	IMSG_SESSION_FLUSH,
	IMSG_SESSION_RESTARTED,
	IMSG_MRT_OPEN,
	IMSG_MRT_REOPEN,
	IMSG_MRT_CLOSE,
	IMSG_KROUTE_CHANGE,
	IMSG_KROUTE_DELETE,
	IMSG_NEXTHOP_ADD,
	IMSG_NEXTHOP_REMOVE,
	IMSG_NEXTHOP_UPDATE,
	IMSG_PFTABLE_ADD,
	IMSG_PFTABLE_REMOVE,
	IMSG_PFTABLE_COMMIT,
	IMSG_REFRESH,
	IMSG_IFINFO,
	IMSG_DEMOTE
};

struct demote_msg {
	char		 demote_group[IFNAMSIZ];
	int		 level;
};

enum ctl_results {
	CTL_RES_OK,
	CTL_RES_NOSUCHPEER,
	CTL_RES_DENIED,
	CTL_RES_NOCAP,
	CTL_RES_PARSE_ERROR,
	CTL_RES_PENDING,
	CTL_RES_NOMEM,
	CTL_RES_BADPEER,
	CTL_RES_BADSTATE
};

/* needed for session.h parse prototype */
LIST_HEAD(mrt_head, mrt);

/* error codes and subcodes needed in SE and RDE */
enum err_codes {
	ERR_HEADER = 1,
	ERR_OPEN,
	ERR_UPDATE,
	ERR_HOLDTIMEREXPIRED,
	ERR_FSM,
	ERR_CEASE
};

enum suberr_update {
	ERR_UPD_UNSPECIFIC,
	ERR_UPD_ATTRLIST,
	ERR_UPD_UNKNWN_WK_ATTR,
	ERR_UPD_MISSNG_WK_ATTR,
	ERR_UPD_ATTRFLAGS,
	ERR_UPD_ATTRLEN,
	ERR_UPD_ORIGIN,
	ERR_UPD_LOOP,
	ERR_UPD_NEXTHOP,
	ERR_UPD_OPTATTR,
	ERR_UPD_NETWORK,
	ERR_UPD_ASPATH
};

enum suberr_cease {
	ERR_CEASE_MAX_PREFIX = 1,
	ERR_CEASE_ADMIN_DOWN,
	ERR_CEASE_PEER_UNCONF,
	ERR_CEASE_ADMIN_RESET,
	ERR_CEASE_CONN_REJECT,
	ERR_CEASE_OTHER_CHANGE,
	ERR_CEASE_COLLISION,
	ERR_CEASE_RSRC_EXHAUST
};

struct kroute_node;
struct kroute6_node;
struct knexthop_node;
RB_HEAD(kroute_tree, kroute_node);
RB_HEAD(kroute6_tree, kroute6_node);
RB_HEAD(knexthop_tree, knexthop_node);

struct ktable {
	char			 descr[PEER_DESCR_LEN];
	char			 ifmpe[IFNAMSIZ];
	struct kroute_tree	 krt;
	struct kroute6_tree	 krt6;
	struct knexthop_tree	 knt;
	struct network_head	 krn;
	u_int			 rtableid;
	u_int			 nhtableid; /* rdomain id for nexthop lookup */
	u_int			 ifindex;   /* ifindex of ifmpe */
	int			 nhrefcnt;  /* refcnt for nexthop table */
	enum reconf_action	 state;
	u_int8_t		 fib_conf;  /* configured FIB sync flag */
	u_int8_t		 fib_sync;  /* is FIB synced with kernel? */
};

struct kroute_full {
	struct bgpd_addr	prefix;
	struct bgpd_addr	nexthop;
	char			label[RTLABEL_LEN];
	u_int16_t		labelid;
	u_int16_t		flags;
	u_short			ifindex;
	u_int8_t		prefixlen;
	u_int8_t		priority;
};

struct kroute {
	struct in_addr	prefix;
	struct in_addr	nexthop;
	u_int32_t	mplslabel;
	u_int16_t	flags;
	u_int16_t	labelid;
	u_short		ifindex;
	u_int8_t	prefixlen;
	u_int8_t	priority;
};

struct kroute6 {
	struct in6_addr	prefix;
	struct in6_addr	nexthop;
	u_int16_t	flags;
	u_int16_t	labelid;
	u_short		ifindex;
	u_int8_t	prefixlen;
	u_int8_t	priority;
};

struct kroute_nexthop {
	struct bgpd_addr	nexthop;
	struct bgpd_addr	gateway;
	struct bgpd_addr	net;
	u_int8_t		valid;
	u_int8_t		connected;
	u_int8_t		netlen;
};

struct kif {
	char			 ifname[IFNAMSIZ];
	u_int64_t		 baudrate;
	int			 flags;
	u_short			 ifindex;
	u_int8_t		 if_type;
	u_int8_t		 link_state;
	u_int8_t		 nh_reachable;	/* for nexthop verification */
};

struct session_up {
	struct bgpd_addr	local_addr;
	struct bgpd_addr	remote_addr;
	struct capabilities	capa;
	u_int32_t		remote_bgpid;
	u_int16_t		short_as;
};

struct pftable_msg {
	struct bgpd_addr	addr;
	char			pftable[PFTABLE_LEN];
	u_int8_t		len;
};

struct ctl_show_nexthop {
	struct bgpd_addr	addr;
	struct kif		kif;
	union {
		struct kroute		kr4;
		struct kroute6		kr6;
	} kr;
	u_int8_t		valid;
	u_int8_t		krvalid;
};

struct ctl_neighbor {
	struct bgpd_addr	addr;
	char			descr[PEER_DESCR_LEN];
	char			shutcomm[SHUT_COMM_LEN];
	int			show_timers;
};

#define	F_PREF_ELIGIBLE	0x01
#define	F_PREF_ACTIVE	0x02
#define	F_PREF_INTERNAL	0x04
#define	F_PREF_ANNOUNCE	0x08
#define	F_PREF_STALE	0x10

struct ctl_show_rib {
	struct bgpd_addr	true_nexthop;
	struct bgpd_addr	exit_nexthop;
	struct bgpd_addr	prefix;
	struct bgpd_addr	remote_addr;
	char			descr[PEER_DESCR_LEN];
	time_t			lastchange;
	u_int32_t		remote_id;
	u_int32_t		local_pref;
	u_int32_t		med;
	u_int32_t		weight;
	u_int16_t		aspath_len;
	u_int16_t		flags;
	u_int8_t		prefixlen;
	u_int8_t		origin;
	/* plus a aspath_len bytes long aspath */
};

enum as_spec {
	AS_NONE,
	AS_ALL,
	AS_SOURCE,
	AS_TRANSIT,
	AS_PEER,
	AS_EMPTY
};

enum aslen_spec {
	ASLEN_NONE,
	ASLEN_MAX,
	ASLEN_SEQ
};

struct filter_as {
	u_int32_t	as;
	u_int16_t	flags;
	enum as_spec	type;
	u_int8_t	op;
	u_int32_t	as_min;
	u_int32_t	as_max;
};

struct filter_aslen {
	u_int		aslen;
	enum aslen_spec	type;
};

#define AS_FLAG_NEIGHBORAS	0x01

struct filter_community {
	int		as;
	int		type;
};

struct filter_largecommunity {
	int64_t		as;
	int64_t		ld1;
	int64_t		ld2;
};

struct wire_largecommunity {
	uint32_t	as;
	uint32_t	ld1;
	uint32_t	ld2;
};

struct filter_extcommunity {
	u_int16_t	flags;
	u_int8_t	type;
	u_int8_t	subtype;	/* if extended type */
	union {
		struct ext_as {
			u_int16_t	as;
			u_int32_t	val;
		}		ext_as;
		struct ext_as4 {
			u_int32_t	as4;
			u_int16_t	val;
		}		ext_as4;
		struct ext_ip {
			struct in_addr	addr;
			u_int16_t	val;
		}		ext_ip;
		u_int64_t	ext_opaq;	/* only 48 bits */
	}		data;
};

struct ctl_show_rib_request {
	char			rib[PEER_DESCR_LEN];
	struct ctl_neighbor	neighbor;
	struct bgpd_addr	prefix;
	struct filter_as	as;
	struct filter_community community;
	struct filter_largecommunity large_community;
	u_int32_t		peerid;
	pid_t			pid;
	u_int16_t		flags;
	enum imsg_type		type;
	u_int8_t		prefixlen;
	u_int8_t		aid;
};

enum filter_actions {
	ACTION_NONE,
	ACTION_ALLOW,
	ACTION_DENY
};

enum directions {
	DIR_IN = 1,
	DIR_OUT
};

enum from_spec {
	FROM_ALL,
	FROM_ADDRESS,
	FROM_DESCR,
	FROM_GROUP
};

enum comp_ops {
	OP_NONE,
	OP_RANGE,
	OP_XRANGE,
	OP_EQ,
	OP_NE,
	OP_LE,
	OP_LT,
	OP_GE,
	OP_GT
};

struct filter_peers {
	u_int32_t	peerid;
	u_int32_t	groupid;
	u_int32_t	remote_as;
	u_int16_t	ribid;
};

/* special community type */
#define	COMMUNITY_ERROR			-1
#define	COMMUNITY_ANY			-2
#define	COMMUNITY_NEIGHBOR_AS		-3
#define	COMMUNITY_UNSET			-4
#define	COMMUNITY_WELLKNOWN		0xffff
#define	COMMUNITY_BLACKHOLE		0x029A	/* draft-ymbk-grow-blackholing-01 */
#define	COMMUNITY_NO_EXPORT		0xff01
#define	COMMUNITY_NO_ADVERTISE		0xff02
#define	COMMUNITY_NO_EXPSUBCONFED	0xff03
#define	COMMUNITY_NO_PEER		0xff04	/* RFC 3765 */

/* extended community definitions */
#define EXT_COMMUNITY_IANA		0x80
#define EXT_COMMUNITY_TRANSITIVE	0x40
#define EXT_COMMUNITY_VALUE		0x3f
/* extended types */
#define EXT_COMMUNITY_TWO_AS		0	/* 2 octet AS specific */
#define EXT_COMMUNITY_IPV4		1	/* IPv4 specific */
#define EXT_COMMUNITY_FOUR_AS		2	/* 4 octet AS specific */
#define EXT_COMMUNITY_OPAQUE		3	/* opaque ext community */
/* sub types */
#define EXT_COMMUNITY_ROUTE_TGT		2	/* RFC 4360 & RFC4364 */
#define EXT_COMMUNITY_ROUTE_ORIG	3	/* RFC 4360 & RFC4364 */
#define EXT_COMMUNITY_OSPF_DOM_ID	5	/* RFC 4577 */
#define EXT_COMMUNITY_OSPF_RTR_TYPE	6	/* RFC 4577 */
#define EXT_COMMUNITY_OSPF_RTR_ID	7	/* RFC 4577 */
#define EXT_COMMUNITY_BGP_COLLECT	8	/* RFC 4384 */
/* other handy defines */
#define EXT_COMMUNITY_OPAQUE_MAX	0xffffffffffffULL
#define EXT_COMMUNITY_FLAG_VALID	0x01

struct ext_comm_pairs {
	u_int8_t	type;
	u_int8_t	subtype;
	u_int8_t	transitive;	/* transitive bit needs to be set */
};

#define IANA_EXT_COMMUNITIES	{					\
	{ EXT_COMMUNITY_TWO_AS, EXT_COMMUNITY_ROUTE_TGT, 0 },		\
	{ EXT_COMMUNITY_TWO_AS, EXT_COMMUNITY_ROUTE_ORIG, 0 },		\
	{ EXT_COMMUNITY_TWO_AS, EXT_COMMUNITY_OSPF_DOM_ID, 0 },		\
	{ EXT_COMMUNITY_TWO_AS, EXT_COMMUNITY_BGP_COLLECT, 0 },		\
	{ EXT_COMMUNITY_FOUR_AS, EXT_COMMUNITY_ROUTE_TGT, 0 },		\
	{ EXT_COMMUNITY_FOUR_AS, EXT_COMMUNITY_ROUTE_ORIG, 0 },		\
	{ EXT_COMMUNITY_IPV4, EXT_COMMUNITY_ROUTE_TGT, 0 },		\
	{ EXT_COMMUNITY_IPV4, EXT_COMMUNITY_ROUTE_ORIG, 0 },		\
	{ EXT_COMMUNITY_IPV4, EXT_COMMUNITY_OSPF_RTR_ID, 0 },		\
	{ EXT_COMMUNITY_OPAQUE, EXT_COMMUNITY_OSPF_RTR_TYPE, 0 }	\
}


struct filter_prefix {
	struct bgpd_addr	addr;
	u_int8_t		op;
	u_int8_t		len;
	u_int8_t		len_min;
	u_int8_t		len_max;
};

struct filter_nexthop {
	struct bgpd_addr	addr;
	u_int8_t		flags;
#define FILTER_NEXTHOP_ADDR	1
#define FILTER_NEXTHOP_NEIGHBOR	2
};

struct filter_match {
	struct filter_prefix		prefix;
	struct filter_nexthop		nexthop;
	struct filter_as		as;
	struct filter_aslen		aslen;
	struct filter_community		community;
	struct filter_largecommunity	large_community;
	struct filter_extcommunity	ext_community;
};

union filter_rule_ptr {
	struct filter_rule		*ptr;
	u_int32_t			 nr;
};

struct filter_rule {
	TAILQ_ENTRY(filter_rule)	entry;
	char				rib[PEER_DESCR_LEN];
	struct filter_peers		peer;
	struct filter_match		match;
	struct filter_set_head		set;
#define RDE_FILTER_SKIP_DIR		0
#define RDE_FILTER_SKIP_GROUPID		1
#define RDE_FILTER_SKIP_REMOTE_AS	2
#define RDE_FILTER_SKIP_PEERID		3
#define RDE_FILTER_SKIP_COUNT		4
	union filter_rule_ptr		skip[RDE_FILTER_SKIP_COUNT];
	enum filter_actions		action;
	enum directions			dir;
	u_int8_t			quick;
};

enum action_types {
	ACTION_SET_LOCALPREF,
	ACTION_SET_RELATIVE_LOCALPREF,
	ACTION_SET_MED,
	ACTION_SET_RELATIVE_MED,
	ACTION_SET_WEIGHT,
	ACTION_SET_RELATIVE_WEIGHT,
	ACTION_SET_PREPEND_SELF,
	ACTION_SET_PREPEND_PEER,
	ACTION_SET_NEXTHOP,
	ACTION_SET_NEXTHOP_REJECT,
	ACTION_SET_NEXTHOP_BLACKHOLE,
	ACTION_SET_NEXTHOP_NOMODIFY,
	ACTION_SET_NEXTHOP_SELF,
	ACTION_SET_COMMUNITY,
	ACTION_DEL_COMMUNITY,
	ACTION_DEL_LARGE_COMMUNITY,
	ACTION_SET_LARGE_COMMUNITY,
	ACTION_SET_EXT_COMMUNITY,
	ACTION_DEL_EXT_COMMUNITY,
	ACTION_PFTABLE,
	ACTION_PFTABLE_ID,
	ACTION_RTLABEL,
	ACTION_RTLABEL_ID,
	ACTION_SET_ORIGIN
};

struct filter_set {
	TAILQ_ENTRY(filter_set)		entry;
	union {
		u_int8_t		prepend;
		u_int16_t		id;
		u_int32_t		metric;
		int32_t			relative;
		struct bgpd_addr	nexthop;
		struct filter_community	community;
		struct filter_largecommunity	large_community;
		struct filter_extcommunity	ext_community;
		char			pftable[PFTABLE_LEN];
		char			rtlabel[RTLABEL_LEN];
		u_int8_t		origin;
	} action;
	enum action_types		type;
};

struct rdomain {
	SIMPLEQ_ENTRY(rdomain)		entry;
	char				descr[PEER_DESCR_LEN];
	char				ifmpe[IFNAMSIZ];
	struct filter_set_head		import;
	struct filter_set_head		export;
	struct network_head		net_l;
	u_int64_t			rd;
	u_int				rtableid;
	u_int				label;
	int				flags;
};

struct rde_rib {
	SIMPLEQ_ENTRY(rde_rib)	entry;
	char			name[PEER_DESCR_LEN];
	u_int			rtableid;
	u_int16_t		id;
	u_int16_t		flags;
};
SIMPLEQ_HEAD(rib_names, rde_rib);
extern struct rib_names ribnames;

/* rde_rib flags */
#define F_RIB_LOCAL		0x0001
#define F_RIB_NOEVALUATE	0x0002
#define F_RIB_NOFIB		0x0004
#define F_RIB_NOFIBSYNC		0x0008
#define F_RIB_HASNOFIB		(F_RIB_NOFIB | F_RIB_NOEVALUATE)

/* 4-byte magic AS number */
#define AS_TRANS	23456

struct rde_memstats {
	int64_t		path_cnt;
	int64_t		prefix_cnt;
	int64_t		rib_cnt;
	int64_t		pt_cnt[AID_MAX];
	int64_t		nexthop_cnt;
	int64_t		aspath_cnt;
	int64_t		aspath_size;
	int64_t		aspath_refs;
	int64_t		attr_cnt;
	int64_t		attr_refs;
	int64_t		attr_data;
	int64_t		attr_dcnt;
};

#define	MRT_FILE_LEN	512
#define	MRT2MC(x)	((struct mrt_config *)(x))
#define	MRT_MAX_TIMEOUT	7200

enum mrt_type {
	MRT_NONE,
	MRT_TABLE_DUMP,
	MRT_TABLE_DUMP_MP,
	MRT_TABLE_DUMP_V2,
	MRT_ALL_IN,
	MRT_ALL_OUT,
	MRT_UPDATE_IN,
	MRT_UPDATE_OUT
};

enum mrt_state {
	MRT_STATE_RUNNING,
	MRT_STATE_OPEN,
	MRT_STATE_REOPEN,
	MRT_STATE_REMOVE
};

struct mrt {
	char			rib[PEER_DESCR_LEN];
	struct msgbuf		wbuf;
	LIST_ENTRY(mrt)		entry;
	u_int32_t		peer_id;
	u_int32_t		group_id;
	enum mrt_type		type;
	enum mrt_state		state;
	u_int16_t		seqnum;
};

struct mrt_config {
	struct mrt		conf;
	char			name[MRT_FILE_LEN];	/* base file name */
	char			file[MRT_FILE_LEN];	/* actual file name */
	time_t			ReopenTimer;
	int			ReopenTimerInterval;
};

/* prototypes */
/* bgpd.c */
void		 send_nexthop_update(struct kroute_nexthop *);
void		 send_imsg_session(int, pid_t, void *, u_int16_t);
int		 send_network(int, struct network_config *,
		     struct filter_set_head *);
int		 bgpd_filternexthop(struct kroute *, struct kroute6 *);
void		 set_pollfd(struct pollfd *, struct imsgbuf *);
int		 handle_pollfd(struct pollfd *, struct imsgbuf *);

/* control.c */
void	control_cleanup(const char *);
int	control_imsg_relay(struct imsg *);

/* config.c */
struct bgpd_config	*new_config(void);
void			free_config(struct bgpd_config *);
void	filterlist_free(struct filter_head *);
int	host(const char *, struct bgpd_addr *, u_int8_t *);

/* kroute.c */
int		 kr_init(void);
int		 ktable_update(u_int, char *, char *, int, u_int8_t);
void		 ktable_preload(void);
void		 ktable_postload(u_int8_t);
int		 ktable_exists(u_int, u_int *);
int		 kr_change(u_int, struct kroute_full *,  u_int8_t);
int		 kr_delete(u_int, struct kroute_full *, u_int8_t);
void		 kr_shutdown(u_int8_t);
void		 kr_fib_couple(u_int, u_int8_t);
void		 kr_fib_couple_all(u_int8_t);
void		 kr_fib_decouple(u_int, u_int8_t);
void		 kr_fib_decouple_all(u_int8_t);
void		 kr_fib_update_prio_all(u_int8_t);
int		 kr_dispatch_msg(void);
int		 kr_nexthop_add(u_int32_t, struct bgpd_addr *);
void		 kr_nexthop_delete(u_int32_t, struct bgpd_addr *);
void		 kr_show_route(struct imsg *);
void		 kr_ifinfo(char *);
int		 kr_net_reload(u_int, struct network_head *);
int		 kr_reload(void);
struct in6_addr	*prefixlen2mask6(u_int8_t prefixlen);

/* log.c */
void		 log_peer_warn(const struct peer_config *, const char *, ...)
			__attribute__((__format__ (printf, 2, 3)));
void		 log_peer_warnx(const struct peer_config *, const char *, ...)
			__attribute__((__format__ (printf, 2, 3)));

/* mrt.c */
void		 mrt_clear_seq(void);
void		 mrt_write(struct mrt *);
void		 mrt_clean(struct mrt *);
void		 mrt_init(struct imsgbuf *, struct imsgbuf *);
int		 mrt_timeout(struct mrt_head *);
void		 mrt_reconfigure(struct mrt_head *);
void		 mrt_handler(struct mrt_head *);
struct mrt	*mrt_get(struct mrt_head *, struct mrt *);
int		 mrt_mergeconfig(struct mrt_head *, struct mrt_head *);

/* name2id.c */
u_int16_t	 rib_name2id(const char *);
const char	*rib_id2name(u_int16_t);
void		 rib_unref(u_int16_t);
void		 rib_ref(u_int16_t);
u_int16_t	 rtlabel_name2id(const char *);
const char	*rtlabel_id2name(u_int16_t);
void		 rtlabel_unref(u_int16_t);
void		 rtlabel_ref(u_int16_t);
u_int16_t	 pftable_name2id(const char *);
const char	*pftable_id2name(u_int16_t);
void		 pftable_unref(u_int16_t);
void		 pftable_ref(u_int16_t);

/* parse.y */
int	 cmdline_symset(char *);

/* pftable.c */
int	pftable_exists(const char *);
int	pftable_add(const char *);
int	pftable_clear_all(void);
int	pftable_addr_add(struct pftable_msg *);
int	pftable_addr_remove(struct pftable_msg *);
int	pftable_commit(void);

/* rde_filter.c */
void		 filterset_free(struct filter_set_head *);
int		 filterset_cmp(struct filter_set *, struct filter_set *);
void		 filterset_move(struct filter_set_head *,
		    struct filter_set_head *);
const char	*filterset_name(enum action_types);

/* util.c */
const char	*log_addr(const struct bgpd_addr *);
const char	*log_in6addr(const struct in6_addr *);
const char	*log_sockaddr(struct sockaddr *);
const char	*log_as(u_int32_t);
const char	*log_rd(u_int64_t);
const char	*log_ext_subtype(u_int8_t);
const char	*log_shutcomm(const char *);
int		 aspath_snprint(char *, size_t, void *, u_int16_t);
int		 aspath_asprint(char **, void *, u_int16_t);
size_t		 aspath_strlen(void *, u_int16_t);
int		 aspath_match(void *, u_int16_t, struct filter_as *, u_int32_t);
int		 as_compare(u_int8_t, u_int32_t, u_int32_t, u_int32_t, u_int32_t);
u_int32_t	 aspath_extract(const void *, int);
int		 prefix_compare(const struct bgpd_addr *,
		    const struct bgpd_addr *, int);
in_addr_t	 prefixlen2mask(u_int8_t);
void		 inet6applymask(struct in6_addr *, const struct in6_addr *,
		    int);
const char	*aid2str(u_int8_t);
int		 aid2afi(u_int8_t, u_int16_t *, u_int8_t *);
int		 afi2aid(u_int16_t, u_int8_t, u_int8_t *);
sa_family_t	 aid2af(u_int8_t);
int		 af2aid(sa_family_t, u_int8_t, u_int8_t *);
struct sockaddr	*addr2sa(struct bgpd_addr *, u_int16_t);
void		 sa2addr(struct sockaddr *, struct bgpd_addr *);

static const char * const log_procnames[] = {
	"parent",
	"SE",
	"RDE"
};

/* logmsg.c and needed by bgpctl */
static const char * const statenames[] = {
	"None",
	"Idle",
	"Connect",
	"Active",
	"OpenSent",
	"OpenConfirm",
	"Established"
};

static const char * const msgtypenames[] = {
	"NONE",
	"OPEN",
	"UPDATE",
	"NOTIFICATION",
	"KEEPALIVE",
	"RREFRESH"
};

static const char * const eventnames[] = {
	"None",
	"Start",
	"Stop",
	"Connection opened",
	"Connection closed",
	"Connection open failed",
	"Fatal error",
	"ConnectRetryTimer expired",
	"HoldTimer expired",
	"KeepaliveTimer expired",
	"OPEN message received",
	"KEEPALIVE message received",
	"UPDATE message received",
	"NOTIFICATION received"
};

static const char * const errnames[] = {
	"none",
	"Header error",
	"error in OPEN message",
	"error in UPDATE message",
	"HoldTimer expired",
	"Finite State Machine error",
	"Cease"
};

static const char * const suberr_header_names[] = {
	"none",
	"synchronization error",
	"wrong length",
	"unknown message type"
};

static const char * const suberr_open_names[] = {
	"none",
	"version mismatch",
	"AS unacceptable",
	"BGPID invalid",
	"optional parameter error",
	"authentication error",
	"unacceptable holdtime",
	"unsupported capability",
	"group membership conflict",	/* draft-ietf-idr-bgp-multisession-07 */
	"group membership required"	/* draft-ietf-idr-bgp-multisession-07 */
};

static const char * const suberr_fsm_names[] = {
	"unspecified error",
	"received unexpected message in OpenSent",
	"received unexpected message in OpenConfirm",
	"received unexpected message in Established"
};

static const char * const suberr_update_names[] = {
	"none",
	"attribute list error",
	"unknown well-known attribute",
	"well-known attribute missing",
	"attribute flags error",
	"attribute length wrong",
	"origin unacceptable",
	"loop detected",
	"nexthop unacceptable",
	"optional attribute error",
	"network unacceptable",
	"AS-Path unacceptable"
};

static const char * const suberr_cease_names[] = {
	"none",
	"max-prefix exceeded",
	"administratively down",
	"peer unconfigured",
	"administrative reset",
	"connection rejected",
	"other config change",
	"collision",
	"resource exhaustion"
};

static const char * const ctl_res_strerror[] = {
	"no error",
	"no such neighbor",
	"permission denied",
	"neighbor does not have this capability",
	"config file has errors, reload failed",
	"previous reload still running",
	"out of memory",
	"not a cloned peer",
	"peer still active, down peer first"
};

static const char * const timernames[] = {
	"None",
	"ConnectRetryTimer",
	"KeepaliveTimer",
	"HoldTimer",
	"IdleHoldTimer",
	"IdleHoldResetTimer",
	"CarpUndemoteTimer",
	""
};

#endif /* __BGPD_H__ */
@


1.299
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.298 2017/01/13 18:59:12 phessler Exp $ */
d906 1
a906 1
#define F_RIB_ENTRYLOCK		0x0001
@


1.298
log
@Add support for draft-ietf-idr-shutdown

    BGP state = Idle, marked down with shutdown reason "goodbye, we are
    upgrading to openbsd 6.1", down for 00:00:17

developed by Peter van Dijk <peter.van.dijk@@powerdns.com> and Job
Snijders <job@@ntt.net>, thank you!

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.297 2016/10/14 16:05:35 phessler Exp $ */
a35 2
#include "log.h"

a1014 6
void		 log_init(int);
void		 log_verbose(int);
void		 logit(int, const char *, ...)
			__attribute__((__format__ (printf, 2, 3)));
void		 vlog(int, const char *, va_list)
			__attribute__((__format__ (printf, 2, 0)));
a1018 12
void		 log_warn(const char *, ...)
			__attribute__((__format__ (printf, 1, 2)));
void		 log_warnx(const char *, ...)
			__attribute__((__format__ (printf, 1, 2)));
void		 log_info(const char *, ...)
			__attribute__((__format__ (printf, 1, 2)));
void		 log_debug(const char *, ...)
			__attribute__((__format__ (printf, 1, 2)));
void		 fatal(const char *, ...) __dead
			__attribute__((__format__ (printf, 1, 2)));
void		 fatalx(const char *) __dead
			__attribute__((__format__ (printf, 1, 0)));
@


1.297
log
@Add support for draft-ietf-idr-large-community

Joint work with Job Snijders, many thanks!
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.296 2016/10/05 07:38:06 phessler Exp $ */
d43 1
d303 1
d591 1
d1090 1
@


1.296
log
@Let bgpd announce routes based on a route-label.

OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.295 2016/09/02 14:00:29 benno Exp $ */
d380 1
d652 12
d691 1
d810 1
d852 2
d872 1
@


1.295
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.294 2016/06/06 15:59:10 benno Exp $ */
d88 1
d338 1
d347 1
d513 1
@


1.294
log
@Add format attributes to the proper functions and then fix the warning in
session.c
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.293 2016/06/03 17:36:37 benno Exp $ */
d36 2
d1083 130
@


1.293
log
@Add operators =, !=, - (range), >< (exclsive range) to the as-path
filters (AS, peer-as, source-as, transit-as).

Add a use case (block illegal AS numbers) to the bgpd.conf example.

feedback from claudio, sthen, florian,
ok florian@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.292 2015/11/06 16:23:26 phessler Exp $ */
d992 20
a1011 10
void		 logit(int, const char *, ...);
void		 vlog(int, const char *, va_list);
void		 log_peer_warn(const struct peer_config *, const char *, ...);
void		 log_peer_warnx(const struct peer_config *, const char *, ...);
void		 log_warn(const char *, ...);
void		 log_warnx(const char *, ...);
void		 log_info(const char *, ...);
void		 log_debug(const char *, ...);
void		 fatal(const char *, ...) __dead;
void		 fatalx(const char *) __dead;
@


1.292
log
@Radically improve the performance of bgpd filters.  Based on PF's skip
steps (and uses much of the same code).

In a torture test of ~600k prefix filters and 65k prefixes, convergance
time goes from 35 minutes to 30 seconds.

Many thanks to LONAP for providing a base configuration for torture
testing.

many discussions with claudio@@, benno@@, sthen@@ and the rest of the bgpd crowd

OK sthen@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.291 2015/10/11 19:30:12 phessler Exp $ */
d628 3
a665 1

d1056 2
a1057 1
int		 aspath_match(void *, u_int16_t, enum as_spec, u_int32_t);
@


1.291
log
@standardize a community that has been independently created by nearly
every single AS on the planet: the blackhole

OK benno@@, claudio@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.290 2015/09/21 09:47:15 phessler Exp $ */
d791 5
d802 6
@


1.290
log
@Let us log all updates sent from an individual peer.  Since this can be
applied to a group, also let us disable logging on a sub-member of the
group.  Very handy for debugging naughty peers on a router with multiple
peers.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.289 2015/09/16 20:25:41 stsp Exp $ */
d721 1
@


1.289
log
@Another ifmedia64 fix, this time for bgpd's ift2ifm().
And rename struct kif's media_type to if_type to avoid confusion with
ifmedia's media type. Same rename in other daemons will follow.
ok claudio henning benno
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.288 2015/07/20 16:10:38 claudio Exp $ */
d329 1
@


1.288
log
@Make bgpd execute the RDE and session engine process instead of just forking.
This way ASLR and stack cookies are per process.
With input from benno@@ and deraadt@@
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.287 2015/07/18 22:52:39 benno Exp $ */
d548 1
a548 1
	u_int8_t		 media_type;
@


1.287
log
@give bgpd's fatal() varargs and use it to instrument bgpd fatal()
calls to aid in debugging
henning@@ "makes sense to me", sthen@@ "yes please", ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.286 2015/07/16 18:26:04 claudio Exp $ */
d96 1
a96 1
enum {
d387 2
d938 2
@


1.286
log
@Next round of config cleanup. Move various lists into the bgpd_config struct.
This is the next step to better split parsing and merging the config.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.285 2015/04/25 15:28:18 phessler Exp $ */
d981 1
a981 1
void		 fatal(const char *) __dead;
@


1.285
log
@allow us to write rules that match directly on the peer AS

...
allow from AS 1 prefix 192.0.2.0/24
...

Also adjust the IRR ruleset output to include the declared peer AS,
instead of hoping they listed their neighbor IP address!


OK benno@@
older version OK: claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.284 2015/03/14 03:52:42 claudio Exp $ */
d198 9
d208 3
d212 1
a346 2
TAILQ_HEAD(network_head, network);

a786 2
TAILQ_HEAD(filter_head, filter_rule);

a851 1
SIMPLEQ_HEAD(rdomain_head, rdomain);
d942 2
@


1.284
log
@rename rde_free_filter() to filterlist_free() and start using it outside
of the RDE to free the filterlists. Also refactor common code to merge
filterlists into its own function. Makes the code look nicer.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.283 2015/03/14 02:43:02 claudio Exp $ */
d697 1
@


1.283
log
@Move the command line options (mainly -d and -v) out of struct bgpd_config
into a own flag field since these can't be modified via a config reload.
OK henning@@ benno@@ before lock
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.282 2014/11/03 16:55:59 bluhm Exp $ */
d933 2
a934 1
int	 host(const char *, struct bgpd_addr *, u_int8_t *);
@


1.282
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK benno@@ doug@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.281 2013/11/13 09:14:48 florian Exp $ */
a201 1
	int					 opts;
d213 2
@


1.281
log
@Knob to set priority with which bgpd inserts routes into the kernel
routing table. Need for it in "special" setups pointed out by
Loic Blot (loic.blot _AT_ unix-experience _DOT_ fr) on tech.
OK benno, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.280 2013/10/19 15:04:25 claudio Exp $ */
d960 1
@


1.280
log
@Merge the prefix and prefixlen filter bits into one filter. Change the
filter expansion so that rules are grouped by prefixes last. The RDE will
then be able to optimize the rules into table lookups but that is a later
step. As additional goodies it is now possible to use inet and inet6
on their own and or-longer can be used as a shorthand for prefixlen >= len.
OK henning@@ sthen@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.279 2013/09/27 08:23:10 sthen Exp $ */
d212 1
d936 1
a936 1
int		 ktable_update(u_int, char *, char *, int);
d938 1
a938 1
void		 ktable_postload(void);
d940 8
a947 5
int		 kr_change(u_int, struct kroute_full *);
int		 kr_delete(u_int, struct kroute_full *);
void		 kr_shutdown(void);
void		 kr_fib_couple(u_int);
void		 kr_fib_decouple(u_int);
@


1.279
log
@typo in macro name; no md5 change
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.278 2013/08/14 20:34:25 claudio Exp $ */
d751 1
d753 2
a763 7
struct filter_prefixlen {
	enum comp_ops		op;
	u_int8_t		aid;
	u_int8_t		len_min;
	u_int8_t		len_max;
};

a765 1
	struct filter_prefixlen		prefixlen;
@


1.278
log
@Rewrite the internals of the RDE reload logic.
This is the first step to make bgpd reload non blocking in the RDE.
It also speeds up the reload time a fair bit in some cases (mainly if
you run with multiple RIBs and have larger filtersets) and it should also
fix a few edge cases on reloads.
Testing done by benno@@, florian@@ and sthen@@ OK henning@@ and benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.277 2013/05/11 14:42:28 benno Exp $ */
d720 1
a720 1
#define EXT_CUMMUNITY_ROUTE_ORIG	3	/* RFC 4360 & RFC4364 */
d737 1
a737 1
	{ EXT_COMMUNITY_TWO_AS, EXT_CUMMUNITY_ROUTE_ORIG, 0 },		\
d741 1
a741 1
	{ EXT_COMMUNITY_FOUR_AS, EXT_CUMMUNITY_ROUTE_ORIG, 0 },		\
d743 1
a743 1
	{ EXT_COMMUNITY_IPV4, EXT_CUMMUNITY_ROUTE_ORIG, 0 },		\
@


1.277
log
@change mrt rib dump ReopenTimerInterval from time_t to int. Intervalls
don't need to scale to 64 bits in this universe.
ok claudio@@ & florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.276 2013/03/07 21:26:28 claudio Exp $ */
d106 1
@


1.276
log
@Implements a few missing bits for better templates support:
- on config reload also adjust the cloned neighbors so that they get the
  config changes as well.
- clean up sessions that are 1h idle but in state active (instead of down)
- add bits to allow bgpctl to destroy cloned neighbors
Tested by sthen@@ some time ago, OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.275 2013/01/09 08:04:25 phessler Exp $ */
d919 1
a919 1
	time_t			ReopenTimerInterval;
@


1.275
log
@Almost exactly 10 years ago, we changed the length of PF table names to
32 chars.  Allow bgpd to use these newfangled longer names.

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.274 2012/11/13 09:47:20 claudio Exp $ */
a299 1
	u_int8_t		 cloned;
a309 1
	u_int8_t		 pad[3];
d348 1
d420 3
a422 1
	CTL_RES_NOMEM
@


1.274
log
@Allow filtering based on the NEXTHOP attribute. This allows to build rules
like: allow from any nexthop neighbor (to allow only prefixes that use the
routers IP address as nexthop). Lots of testing, input and OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.273 2012/09/18 10:10:00 claudio Exp $ */
d41 1
a41 1
#define	PFTABLE_LEN			16
@


1.273
log
@Expose the local weight in the ctl_show_rib struct so bgpctl can print it.
OK sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.272 2012/09/18 09:45:51 claudio Exp $ */
d752 7
d769 1
@


1.272
log
@Only allow one reload request at a time in bgpd. Needed for further work.
OK sthen@@, benno@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.271 2012/09/12 05:56:22 claudio Exp $ */
d583 1
@


1.271
log
@Better graceful restart support (implementing more then just the EoR record).
This implements only the "Restarting Client" bits of the RFC -- in other
words bgpd will keep the FIB when the client restarts but it will not do GR
when restarting itself. The capability is still off by default (you need
"announce restart yes" to enable it).
Tested by Anders Berggren. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.270 2012/05/27 18:52:07 claudio Exp $ */
d420 1
@


1.270
log
@Extend the network code to allow attributes to be passed in with prefixes.
In the end this will allow anyone to use MRT table dumps to load prefixes
into a bgpd instance. For example you can download the RIPE dumps and load
full-feeds onto your laptop until the poor thing dies.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.269 2012/04/12 17:31:05 claudio Exp $ */
d135 1
d257 18
a274 5
	int8_t	mp[AID_MAX];	/* multiprotocol extensions, RFC 4760 */
	int8_t	refresh;	/* route refresh, RFC 2918 */
	int8_t	restart;	/* graceful restart, RFC 4724 */
	int8_t	as4byte;	/* draft-ietf-idr-as4bytes-13 */
};
d390 3
d570 1
@


1.269
log
@The ebgp flags is just a truth value and it is better to not == 1 compares.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.268 2012/03/27 18:22:07 claudio Exp $ */
d305 2
a306 1
	NETWORK_CONNECTED
d310 7
a316 6
	struct bgpd_addr	prefix;
	struct filter_set_head	attrset;
	u_int			rtableid;
	enum network_type	type;
	u_int8_t		prefixlen;
	u_int8_t		old;	/* used for reloading */
d354 2
@


1.268
log
@Introduce F_CTL_ACTIVE a flag to only show selected pathes.
Requested and OK deraadt@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.267 2011/09/20 21:19:06 claudio Exp $ */
d287 1
a287 1
	u_int8_t		 ebgp;		/* 1 = ebgp, 0 = ibgp */
@


1.267
log
@Move a few functions into util.c because bgpctl will need them soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.266 2011/09/19 11:18:11 claudio Exp $ */
d85 1
@


1.266
log
@remove an unused ctl struct and remove some unneeded values from
struct ctl_show_rib since bgpctl does not look at them at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.265 2011/09/18 09:31:25 claudio Exp $ */
d989 4
@


1.265
log
@Reorder the headerfiles a bit. Move the bgpd specific prototypes out of
mrt.h. Now mrt.h includes only protocol specific defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.264 2011/05/01 12:56:04 claudio Exp $ */
a558 3
	u_int32_t		prefix_cnt;
	u_int32_t		active_cnt;
	u_int32_t		rib_cnt;
a563 7
};

struct ctl_show_rib_prefix {
	struct bgpd_addr	prefix;
	time_t			lastchange;
	u_int16_t		flags;
	u_int8_t		prefixlen;
@


1.264
log
@On reload the filtersets attached to a network need to be moved to the
existing network element. First free the old filterset and then move
the new on top of it. This solves the reload issue with changing network
statements. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.263 2010/10/24 17:20:08 deraadt Exp $ */
d857 41
d906 3
a908 15
/* log.c */
void		 log_init(int);
void		 log_verbose(int);
void		 vlog(int, const char *, va_list);
void		 log_peer_warn(const struct peer_config *, const char *, ...);
void		 log_peer_warnx(const struct peer_config *, const char *, ...);
void		 log_warn(const char *, ...);
void		 log_warnx(const char *, ...);
void		 log_info(const char *, ...);
void		 log_debug(const char *, ...);
void		 fatal(const char *) __dead;
void		 fatalx(const char *) __dead;

/* parse.y */
int	 cmdline_symset(char *);
d933 12
a944 3
/* control.c */
void	control_cleanup(const char *);
int	control_imsg_relay(struct imsg *);
d946 10
a955 7
/* pftable.c */
int	pftable_exists(const char *);
int	pftable_add(const char *);
int	pftable_clear_all(void);
int	pftable_addr_add(struct pftable_msg *);
int	pftable_addr_remove(struct pftable_msg *);
int	pftable_commit(void);
d971 10
@


1.263
log
@spacing and irrelevant glitches which disrupt lint
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.262 2010/06/27 19:53:34 claudio Exp $ */
d934 2
@


1.262
log
@Instead of specifying the control sockets on the command line have them
in bgpd.conf. This allows to add/modify restricted control sockets on runtime.
Feature request by a few people how often forgot to add -r path when restarting
bgpd (including myself).
NOTE: this removes the -s and -r arguments from bgpd so pay attention when
updateing.
jajaja sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.261 2010/05/19 12:44:14 claudio Exp $ */
d535 1
a535 1
	u_int8_t		krvalid;;
@


1.261
log
@Add softreconfig support for peers changing the RIB. Done by first unloading
the old RIB and then via softreconfig in and a special softreconfig out loading
the new RIB.
Feature requested and testeded by Elisa Jasinska.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.260 2010/05/17 16:08:20 claudio Exp $ */
d360 1
@


1.260
log
@Implement two new filters, max-as-len and max-as-seq. The first is limiting
the length of an AS path (matches if the path is longer then the specified
lenght) the second matches when a sequence of the same AS number is longer
then the specified length).
max-as-len is good to protect crappy comercial bgp boxes from other crappy
comercial bgp boxes. max-as-seq was a feature request from SwissIX and maybe
EuroIX to find and filter prepends.
Additinal testing and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.259 2010/05/17 15:49:29 claudio Exp $ */
d24 1
@


1.259
log
@Last bits of MPLS VPN support. Hook kernel routing tables and RIB together.
This adds a bit of new config to specify the mapping between an rdomain and
the BGP MPLS VPN instance, example:
rdomain 1 {
        descr "CUSTOMER1"
	rd 65003:1
	import-target rt 65003:3
	export-target rt 65003:1
	depend on mpe0
	network 192.168.224/24
}
The "depend on mpe0" is a but ugly but for now this is the quickest way to
figure out which interface bgp should use to insert the MPLS routes.

A big side-effect of this diff is that networks are now internally
distributed through kroute.c.
This needs some kernel changes that will follow hopefully soon.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.258 2010/05/03 13:09:38 claudio Exp $ */
d583 6
d595 5
d603 2
a604 2
	int			as;
	int			type;
d746 1
@


1.258
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.257 2010/04/28 13:07:48 claudio Exp $ */
a57 4
#define	BGPD_FLAG_REDIST_STATIC		0x0008
#define	BGPD_FLAG_REDIST_CONNECTED	0x0010
#define	BGPD_FLAG_REDIST6_STATIC	0x0020
#define	BGPD_FLAG_REDIST6_CONNECTED	0x0040
d79 2
a194 4
	struct filter_set_head			 connectset;
	struct filter_set_head			 connectset6;
	struct filter_set_head			 staticset;
	struct filter_set_head			 staticset6;
a200 1
	u_int					 rtableid;
d300 6
d309 2
d312 1
d318 2
a319 2
	struct network_config	net;
	TAILQ_ENTRY(network)	entry;
d359 4
a440 1
struct redist_node;
a451 1
	LIST_HEAD(, redist_node) redistlist;
d474 1
d794 14
d847 2
a848 1
int		 bgpd_redistribute(int, struct kroute *, struct kroute6 *);
d872 1
a872 1
int		 ktable_update(struct rde_rib *);
@


1.257
log
@Allow neighbor-as in AS filter statements like:
match from any source-as neighbor-as set localpref 1000
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.256 2010/04/13 09:09:48 claudio Exp $ */
a55 1
#define	BGPD_FLAG_NO_FIB_UPDATE		0x0001
d346 1
d432 25
d537 4
a540 4
#define	F_RIB_ELIGIBLE	0x01
#define	F_RIB_ACTIVE	0x02
#define	F_RIB_INTERNAL	0x04
#define	F_RIB_ANNOUNCE	0x08
d792 1
d799 7
d851 7
a857 3
int		 kr_init(int, u_int);
int		 kr_change(struct kroute_full *);
int		 kr_delete(struct kroute_full *);
d859 2
a860 2
void		 kr_fib_couple(void);
void		 kr_fib_decouple(void);
d862 2
a863 2
int		 kr_nexthop_add(struct bgpd_addr *);
void		 kr_nexthop_delete(struct bgpd_addr *);
d866 1
@


1.256
log
@Instead of passing AF specific struct kroutes over imsgs use a struct
kroute_full structure that is AF independent and has all information in
it. Simplifies the communication between processes and reduces the number
of imsg types. This is another step to add FIB support to BGP MPLS VPNs.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.255 2010/04/06 13:25:08 claudio Exp $ */
d554 2
a556 1
	u_int32_t	as;
d558 2
@


1.255
log
@Switch to a more address family independent nexthop imsg. Instead of passing
struct kroute or kroute6 pack the needed info into a struct bgpd_addr.
No flames comming out of my and sthen@@'s bgpd routers.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.254 2010/03/29 09:04:43 claudio Exp $ */
a331 1
	IMSG_CTL_KROUTE6,
a342 1
	IMSG_CTL_SHOW_NETWORK6,
a367 2
	IMSG_KROUTE6_CHANGE,
	IMSG_KROUTE6_DELETE,
d432 10
a511 10
struct kroute_label {
	struct kroute	kr;
	char		label[RTLABEL_LEN];
};

struct kroute6_label {
	struct kroute6	kr;
	char		label[RTLABEL_LEN];
};

d816 2
a817 4
int		 kr_change(struct kroute_label *);
int		 kr_delete(struct kroute_label *);
int		 kr6_change(struct kroute6_label *);
int		 kr6_delete(struct kroute6_label *);
@


1.254
log
@Implement a log_rd() function to print the route destinguisher in a nice
way. Use it for now in log_addr() to show VPN routes with a prepended RD.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.253 2010/03/05 15:25:00 claudio Exp $ */
a456 4
	union {
		struct kroute		kr4;
		struct kroute6		kr6;
	} kr;
d459 1
d462 1
@


1.253
log
@Allow to filter for ext-community attributes. Currently only perfect matches
work but that's already better then nothing. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.252 2010/01/13 06:02:37 claudio Exp $ */
d874 1
@


1.252
log
@Add support for BGP MPLS VPN aka RFC 4364. This is only the RDE part so
that it is possible to use OpenBGPD as a route-reflector for VPNv4.
Some clean up of the BGP MP code so that multiple protocols are easier
supported. kroute/kernel support not yet done but comming.
OK henning@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.251 2010/01/10 00:15:09 claudio Exp $ */
d570 1
d670 1
d705 5
a709 4
	struct filter_prefix	prefix;
	struct filter_prefixlen	prefixlen;
	struct filter_as	as;
	struct filter_community	community;
@


1.251
log
@Switch rib_dump() to use AID instead of AFs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.250 2009/12/16 15:40:55 claudio Exp $ */
d116 5
a120 4
#define	SAFI_NONE	0x00
#define	SAFI_UNICAST	0x01
#define	SAFI_MULTICAST	0x02
#define	SAFI_MPLS	0x04
d134 2
a135 1
#define	AID_MAX		3
d141 2
a142 1
	{ AFI_IPv6, AF_INET6, SAFI_UNICAST, "IPv6 unicast" }	\
d148 2
a149 1
	sizeof(struct pt_entry6)			\
d152 11
a163 1
	u_int8_t	aid;
d167 5
a171 3
		u_int8_t		addr8[16];
		u_int16_t		addr16[8];
		u_int32_t		addr32[4];
d174 1
d177 1
@


1.250
log
@Implement "set ext-community [delete] subtype key:value" to set and delete
extended communities as specified in RFC 4360. No matching implemented yet
and stuff like * and neighbor-as are neither supported but will be soon.
Looks good henning & sthen, manpage fixed by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.249 2009/12/08 14:03:40 claudio Exp $ */
a581 1
	sa_family_t		af;
d583 1
a743 5
};

struct rrefresh {
	u_int16_t	afi;
	u_int8_t	safi;
@


1.249
log
@Big AID change part two. This changes the mp capability into an array of
flags. This makes a lot of code much easier since the comparison is now
trivial. Additionally calculate the negotiated capabilities for a session
in the SE and pass that and only that to the RDE. This makes the decisions
in the RDE a lot easier.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.248 2009/12/01 14:28:05 claudio Exp $ */
d551 21
d649 21
d720 2
d738 1
d858 1
@


1.248
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.247 2009/11/26 13:40:43 henning Exp $ */
d110 38
d244 4
a247 5
	u_int8_t	mp_v4;		/* multiprotocol extensions, RFC 4760 */
	u_int8_t	mp_v6;
	u_int8_t	refresh;	/* route refresh, RFC 2918 */
	u_int8_t	restart;	/* graceful restart, RFC 4724 */
	u_int8_t	as4byte;	/* draft-ietf-idr-as4bytes-13 */
d462 1
a462 2
	struct capabilities	capa_announced;
	struct capabilities	capa_received;
a714 40
/* Address Family Numbers as per RFC 1700 */
#define	AFI_UNSPEC	0
#define	AFI_IPv4	1
#define	AFI_IPv6	2
#define	AFI_ALL		0xffff

/* Subsequent Address Family Identifier as per RFC 4760 */
#define	SAFI_NONE	0x00
#define	SAFI_UNICAST	0x01
#define	SAFI_MULTICAST	0x02
#define	SAFI_MPLS	0x04
#define	SAFI_ALL	0xff

struct aid {
	u_int16_t	 afi;
	sa_family_t	 af;
	u_int8_t	 safi;
	char		*name;
};

extern const struct aid aid_vals[];

#define	AID_UNSPEC	0
#define	AID_INET	1
#define	AID_INET6	2
#define	AID_MAX		3

#define AID_VALS	{				\
	/* afi, af, safii, name */			\
	{ AFI_UNSPEC, AF_UNSPEC, SAFI_NONE, "unspec"},	\
	{ AFI_IPv4, AF_INET, SAFI_UNICAST, "IPv4" },	\
	{ AFI_IPv6, AF_INET6, SAFI_UNICAST, "IPv6" }	\
}

#define AID_PTSIZE	{				\
	0,						\
	sizeof(struct pt_entry4), 			\
	sizeof(struct pt_entry6)			\
}

d819 1
@


1.247
log
@support for set origin; based on an initial diff from
Sebastian Benoit <benoit-lists at fb12 dot de> who also tested this version
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.246 2009/11/02 20:38:15 claudio Exp $ */
d111 1
a111 1
	sa_family_t	af;
d601 1
a601 1
	sa_family_t		af;
a669 16
struct rde_memstats {
	int64_t		path_cnt;
	int64_t		prefix_cnt;
	int64_t		rib_cnt;
	int64_t		pt4_cnt;
	int64_t		pt6_cnt;
	int64_t		nexthop_cnt;
	int64_t		aspath_cnt;
	int64_t		aspath_size;
	int64_t		aspath_refs;
	int64_t		attr_cnt;
	int64_t		attr_refs;
	int64_t		attr_data;
	int64_t		attr_dcnt;
};

d680 1
d692 27
d722 15
d823 6
@


1.246
log
@Implement IMSG_CTL_LOG_VERBOSE similar to ospfd. Even though bgpd has almost
no log_debug() it makes more sense to make all routing daemons behave the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.245 2009/09/04 11:50:28 claudio Exp $ */
d645 2
a646 1
	ACTION_RTLABEL_ID
d660 1
@


1.245
log
@Use the address familiy of the neighbor IP to decide which MP type to use.
IPv4 session will still default to only announce inet unicast but now
IPv6 session will by default use announce inet6 unicast. The defaults
can be overridden on groups and in the neighbor itself but this new
behaviour is way more sane then the old one. OK henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.244 2009/08/31 13:03:31 claudio Exp $ */
d293 1
d717 1
@


1.244
log
@Use UINT_MAX instead of ASNUM_MAX and get rid of this mostly useless define.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.243 2009/07/23 14:53:18 claudio Exp $ */
d701 1
@


1.243
log
@Send the used kroute along with the nexthop information. This allows us
to show all necessary information in bgpctl show next. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.242 2009/07/20 15:03:16 claudio Exp $ */
a43 2

#define	ASNUM_MAX			0xffffffff
@


1.242
log
@Include more info in the bgpctl show nexthop ctl message. Mainly add the
gateway used for non-connected routes. This info was missing all the time
and often resulted in massive confusion when the nexthop selection choosed
a bad nexthop.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.241 2009/06/12 16:42:53 claudio Exp $ */
a439 1
	struct bgpd_addr	gateway;
d441 4
d446 1
a446 1
	u_int8_t		connected;
@


1.241
log
@Move prefixlen2mask and inet6applymask to util.c so that we can kill the
copies in bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.240 2009/06/07 00:30:23 claudio Exp $ */
d440 2
d443 1
a443 1
	struct kif		kif;
@


1.240
log
@First attempt at reload support for RIBs. There is some magic that I do
not fully understand but at least no flames are comming out of my test
box anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.239 2009/06/06 21:35:32 claudio Exp $ */
a742 1
in_addr_t	 prefixlen2mask(u_int8_t);
a743 2
void		 inet6applymask(struct in6_addr *, const struct in6_addr *,
		    int);
d785 3
@


1.239
log
@Reorder IMSG types to put the "exported" ones further down so they do not
change that often anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.238 2009/06/06 18:31:42 pyr Exp $ */
d301 1
@


1.238
log
@Get ready for including imsg.h from a lib, when it comes along.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.237 2009/06/06 06:33:15 eric Exp $ */
a269 28
	IMSG_RECONF_CONF,
	IMSG_RECONF_PEER,
	IMSG_RECONF_FILTER,
	IMSG_RECONF_LISTENER,
	IMSG_RECONF_DONE,
	IMSG_UPDATE,
	IMSG_UPDATE_ERR,
	IMSG_SESSION_ADD,
	IMSG_SESSION_UP,
	IMSG_SESSION_DOWN,
	IMSG_MRT_OPEN,
	IMSG_MRT_REOPEN,
	IMSG_MRT_CLOSE,
	IMSG_KROUTE_CHANGE,
	IMSG_KROUTE_DELETE,
	IMSG_KROUTE6_CHANGE,
	IMSG_KROUTE6_DELETE,
	IMSG_NEXTHOP_ADD,
	IMSG_NEXTHOP_REMOVE,
	IMSG_NEXTHOP_UPDATE,
	IMSG_PFTABLE_ADD,
	IMSG_PFTABLE_REMOVE,
	IMSG_PFTABLE_COMMIT,
	IMSG_NETWORK_ADD,
	IMSG_NETWORK_REMOVE,
	IMSG_NETWORK_FLUSH,
	IMSG_NETWORK_DONE,
	IMSG_FILTER_SET,
d295 28
@


1.237
log
@sync bgpd/bgpctl with the common imsg code, making it lib ready as well.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.236 2009/06/06 06:04:10 claudio Exp $ */
d33 1
a33 1
#include "imsg.h"
@


1.236
log
@Make it possible to select the RIB that a show command should show.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.235 2009/06/06 01:10:29 claudio Exp $ */
d33 2
a111 16
struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 max;
	size_t			 wpos;
	size_t			 rpos;
	int			 fd;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

a163 6
struct buf_read {
	u_char			 buf[READ_BUF_SIZE];
	u_char			*rptr;
	size_t			 wpos;
};

a267 18
/* ipc messages */

#define	IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
#define	MAX_IMSGSIZE		8192

struct imsg_fd {
	TAILQ_ENTRY(imsg_fd)	entry;
	int			fd;
};

struct imsgbuf {
	TAILQ_HEAD(fds, imsg_fd)	fds;
	struct buf_read			r;
	struct msgbuf			w;
	int				fd;
	pid_t				pid;
};

a327 12
struct imsg_hdr {
	u_int32_t	peerid;
	pid_t		pid;
	enum imsg_type	type;
	u_int16_t	len;
};

struct imsg {
	struct imsg_hdr	 hdr;
	void		*data;
};

a708 15
/* buffer.c */
struct buf	*buf_open(size_t);
struct buf	*buf_dynamic(size_t, size_t);
int		 buf_add(struct buf *, const void *, size_t);
void		*buf_reserve(struct buf *, size_t);
void		*buf_seek(struct buf *, size_t, size_t);
size_t		 buf_size(struct buf *);
size_t		 buf_left(struct buf *);
int		 buf_close(struct msgbuf *, struct buf *);
int		 buf_write(struct msgbuf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);

a725 13

/* imsg.c */
void	 imsg_init(struct imsgbuf *, int);
int	 imsg_read(struct imsgbuf *);
int	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t, int,
	    const void *, u_int16_t);
struct buf	*imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
		    u_int16_t);
int	 imsg_add(struct buf *, const void *, u_int16_t);
int	 imsg_close(struct imsgbuf *, struct buf *);
void	 imsg_free(struct imsg *);
int	 imsg_get_fd(struct imsgbuf *);
@


1.235
log
@Some preliminary filter magic to support multiple RIBs on the filters.
It is ugly but does the trick for now. Filters will be rewritten anyway.
The rib specifier only makes sense on from rules. e.g. deny rib OMG from any
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.234 2009/06/05 19:52:32 claudio Exp $ */
d561 1
@


1.234
log
@Make it possible to bind peers to a specified RIB. Now only filters and
bgpctl are missing to have full support of multiple RIBs.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.233 2009/06/04 04:46:42 claudio Exp $ */
d606 1
d661 1
@


1.233
log
@Add "rde rib <name>" to the config and allow the rde to use these other RIBs.
Still a bit hackish, reload is missing and printconf as well. Looks good h@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.232 2009/05/27 04:18:21 reyk Exp $ */
d242 1
@


1.232
log
@add an option to change the "connect-retry" timer which defaults to 120s.
this can be used to decrease the failover time in specific carp'ed
IBGP setups.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.231 2009/05/17 12:25:15 claudio Exp $ */
d724 9
@


1.231
log
@Rework most of the RDE to allow multiple RIBs. This is mostly preparation
work by changing the way the RDE DB is built. struct prefix and struct
pt_entry are simplified and extended with a rib_entry where the decision
tree is run on. From now on a prefix can only reside on one particular RIB
which simplifies the code a bit. Currently there are two fixed ribs
(adj-rib-in and the local-rib) which needs to be made more dynamic in
upcomming commits.
This is work in progress, the RDE seems to work for me and sthen@@ (no flames
comming out of our testrouters but there is still a lot missing)
Move into the tree to simplify developement -- henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.230 2009/05/05 20:12:04 sthen Exp $ */
d175 1
@


1.230
log
@fix a couple of comment typos
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.229 2009/04/23 16:20:39 sthen Exp $ */
d524 1
a524 1
	u_int32_t		adjrib_cnt;
d711 1
d824 4
@


1.229
log
@allow bgpctl and bgpd.conf to contain 32-bit ASN written in ASPLAIN
format (RFC5396). ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.228 2009/03/26 13:59:30 henning Exp $ */
d90 2
a91 2
 * session enigine. The RDE limit defines how many imsg are generated in
 * on poll round. The if the SE limit is hit the RDE control socket will no
@


1.228
log
@argh, do not reuse the global trans_as flag to be applied to the peer
specific or we had to widen the peer specific flags without need.
defien PERRFLAG_TRANS_AS instead and use that
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.227 2009/03/22 22:34:59 henning Exp $ */
d42 2
@


1.227
log
@make transparent-as yes|no settable peer neighbor with the global setting
acting as default.
per-neighbor requested by arnold nipper @@ decix, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.226 2009/03/18 19:41:41 claudio Exp $ */
d268 2
@


1.226
log
@Introduce local_as in the peer config. This allows per peer local AS and
simplifies some code because it is possible to get the local AS from the
peer struct. Local AS needs more patching to work correctly though.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.225 2009/03/13 06:25:04 claudio Exp $ */
d265 2
@


1.225
log
@Next step in mrt cleanup. Switch buf_write to a smarter version of itself.
Doing more the stuff msgbuf_write does and switch the only user -- mrt --
over to use this simpler way of writing out stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.224 2009/03/13 04:40:55 claudio Exp $ */
d244 1
d252 1
@


1.224
log
@Sync buffer API with the one from ospfd. The dynamic buffers will make other
code much easier to write. OK henning@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.223 2008/12/12 23:15:12 claudio Exp $ */
d745 1
a745 1
int		 buf_write(int, struct buf *);
@


1.223
log
@Make bgpd route priority aware and while there sync in the basics to correctly
track multipath routes. Code is mostly stolen from similar fixes to ospfd but
a bit different as this kroute.c implementation is more complex because of
additional task (nexthop verification for example).
This change and the similar ospfd change were desperatly needed on larger
complex network setups which tended to end up in situation where the kernel
had a different oppinion about routing than the daemon. Now the situation
should be a lot better.
Tested and OK sthen@@ gollo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.222 2008/01/23 08:11:32 claudio Exp $ */
d112 1
d738 1
a738 1
struct buf	*buf_grow(struct buf *, size_t);
d741 3
@


1.222
log
@Add defines for extended communities. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.221 2007/12/23 18:26:13 henning Exp $ */
d427 1
d437 1
@


1.221
log
@send timers for bgpctlshow neighbor foo timer in seperate messages after
the peer data. makes bgpctl display code independent from timer
implementation internals. only running timers are displayed now, stopped
ones are skipped.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.220 2007/10/13 16:35:19 deraadt Exp $ */
d605 18
@


1.220
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.219 2007/09/11 17:07:59 henning Exp $ */
d349 1
d483 1
@


1.219
log
@baudrate u_long -> u_int64_t
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.218 2007/05/28 17:26:33 henning Exp $ */
a740 1
int	 check_file_secrecy(int, const char *);
@


1.218
log
@allow matching on communities using 0 in the AS part, that is in use.
that unfortunately means we cannot use 0 for "unset".
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.217 2007/05/15 14:35:30 claudio Exp $ */
d450 1
a450 1
	u_long			 baudrate;
@


1.217
log
@Graceful restart is no longer a draft so point it to the right RFC 4724.
Additionally our as4byte support is based on draft-ietf-idr-as4bytes-13.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.216 2007/04/23 13:04:24 claudio Exp $ */
d597 1
@


1.216
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.215 2007/03/28 12:33:32 henning Exp $ */
d227 2
a228 2
	u_int8_t	restart;	/* draft-ietf-idr-restart */
	u_int8_t	as4byte;
@


1.215
log
@add IMSG_CTL_SHOW_RIB_COMMUNITY, rib by given community
mostly from rivo nurges <rix@@estpak.ee>, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.214 2007/03/16 14:06:57 claudio Exp $ */
d168 2
a169 1
	u_int16_t				 as;
d228 1
d242 1
a247 1
	u_int16_t		 remote_as;
d464 1
d537 1
a537 1
	u_int16_t	as;
d702 3
d807 2
a808 1
const char *	 log_sockaddr(struct sockaddr *);
@


1.214
log
@A few more s/2858/4760/ and use RFC <number> everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.213 2007/03/16 13:52:30 claudio Exp $ */
d342 1
d537 5
d546 1
a609 5
};

struct filter_community {
	int			as;
	int			type;
@


1.213
log
@Update multiprotocol extension code to RFC 4760. This actually removes
a few things we actually never realy cared about.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.212 2007/03/06 16:52:48 henning Exp $ */
d223 1
a223 1
	u_int8_t	mp_v4;		/* multiprotocol extensions, RFC 2858 */
d591 1
a591 1
#define	COMMUNITY_NO_PEER		0xff04	/* rfc3765 */
d686 1
a686 1
/* Address Family Numbers as per rfc1700 */
d691 1
a691 1
/* Subsequent Address Family Identifier as per rfc4760 */
@


1.212
log
@allow filtering on peer-as (leftmost AS in path), ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.211 2007/01/26 17:40:49 claudio Exp $ */
d691 1
a691 1
/* Subsequent Address Family Identifier as per rfc2858 */
a694 1
#define	SAFI_BOTH	0x03
@


1.211
log
@Massiv rework of the control imsg flow. Main changes:
- dedicated pipe between the SE and the RDE for control messages
- restartable RB tree dumps in the RDE
- queuing limits both in the SE and RDE
The result is a dramatic decrease of memory consumption on operations like
bgpctl show rib. Previously all messages where first stored in the RDE
then passed to the SE where they got queued in case bgpctl was not fast enough.
Now only a small number of messages is generated and passed to the SE and
the SE has an additional limit instead of acting like an infinite buffer.
Without this the bgpd on bgpd.networx.ch would not survive a single minute.
looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.210 2006/12/05 12:08:13 henning Exp $ */
d527 1
@


1.210
log
@implement the ttl security hack. since the pc slaves fear the word hack,
they call it "Generalized TTL Security Mechanism" officially, RFC 3682.
manpage with help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.209 2006/11/28 16:39:34 henning Exp $ */
d86 9
d373 2
a374 1
	CTL_RES_PARSE_ERROR
d542 1
@


1.209
log
@allow bgpd to work on alternate routing tables, claudio ok, jmc manpage help
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.208 2006/08/27 16:11:04 henning Exp $ */
d250 1
@


1.208
log
@add code to announce the restart capability according to
draft-ietf-idr-restart. Do not announce actual restart capabilities,
so that this only serves as indicator that we are capable of sending
and receiving the End-of-RIB marker.
leave disabled for now, since the code to actually send the EoR-marker
is currently ifdef'd out (to be fixed soon) and we wanna play safe for
4.0. and juniper doesn't support that capability (which is not a problem
per se) and at the same time has its capability negotiation code completely
fucked up, if a capability is rejected they don't indicate WHICH capability
they reject (which makes that a problem, tho still a small one and we cope).
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.207 2006/08/27 13:40:21 henning Exp $ */
d156 1
d737 1
a737 1
int		 kr_init(int);
@


1.207
log
@add buf_grow() to grow an existing buffer (realloc), claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.206 2006/08/23 08:13:04 claudio Exp $ */
d216 1
@


1.206
log
@Extend show rib interface code so that it is possible to show the adj-rib-in
and adj-rib-out. Additionally it is now possible to limit the output to a
specified peer. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.205 2006/08/04 12:01:48 henning Exp $ */
d692 1
@


1.205
log
@add "restart" to max-prefix, allows sessions suspended due to reaching
max-prefix to be restarted automagically after a given number of minutes
requested by "Sylwester S. Biernacki" <obeer@@obeer.com>, manpage help jmc,
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.204 2006/06/17 14:06:09 henning Exp $ */
d83 2
d523 1
d526 1
@


1.204
log
@implement carp demotion control for bgpd.
sessions can be configured to modify the carp demotion counter for a
given interface group (usually, "carp", which has all carp interfaces)
when the session is not established. once the session is established for
60 seconds, the demotion is cleared.
this, used correctly, can prevent a bgpd-box which lost all sessions (and
thus has no routes) to be carp master, while the backup has sessions.
thought through and partially hacked on a drive from calgary to vancouver
with ryan, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.203 2006/06/15 10:04:40 claudio Exp $ */
d231 1
@


1.203
log
@Instead of passing three different kinds of arguments in show rib control
request use one struct ctl_show_rib_request where all the info is encoded.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.202 2006/06/14 17:08:56 claudio Exp $ */
d52 1
d224 1
d332 2
a333 1
	IMSG_IFINFO
d346 5
@


1.202
log
@Send bot nexthops (exit and true) in the bgpctl show rib cases. bgpctl
can than select which nexthop should be printed. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.201 2006/05/27 21:24:36 claudio Exp $ */
d509 9
@


1.201
log
@Pass a IMSG_CTL_RESULT messgae back to bgpctl on reloads to indicate if
the reload was successful or not. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.200 2006/05/23 12:11:38 henning Exp $ */
d472 2
a473 1
	struct bgpd_addr	nexthop;
@


1.200
log
@allow bgpd to request a route refresh from a neighbor if that neighbor
announced route refresh capabilities
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.199 2006/04/26 17:13:14 claudio Exp $ */
d349 2
a350 1
	CTL_RES_NOCAP
@


1.199
log
@Remove filterset_names from bgpd.h and replace it with a function because
the table was already out of sync now. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.198 2006/04/25 08:44:08 claudio Exp $ */
d313 1
d348 2
a349 1
	CTL_RES_DENIED
@


1.198
log
@Mark fatal and fatalx as __dead from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.197 2006/04/21 08:51:46 claudio Exp $ */
a609 21
static const char * const filterset_names[] = {
	"localpref",
	"localpref",
	"metric",
	"metric",
	"weight",
	"weight",
	"prepend-self",
	"prepend-peer",
	"nexthop",
	"nexthop",
	"nexthop",
	"nexthop",
	"community",
	"community delete",
	"pftable",
	"pftable",
	"rtlabel",
	"rtlabel"
};

d753 1
@


1.197
log
@msgbuf_writebound() and msgbuf_bounded() are leftovers from some ancient
mrt dump code. These functions are no longer used since we switched to
filedescriptor passing. From deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.196 2006/04/04 12:03:26 henning Exp $ */
d705 2
a706 2
void		 fatal(const char *);
void		 fatalx(const char *);
@


1.196
log
@add "set nexthop self", force nexthop to be set to own address even with IBGP
requested & tested Falk Brockerhoff <fb@@smartterra.de>, and tony sarendal
tested this too. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.195 2006/03/22 13:30:35 claudio Exp $ */
a694 2
int		 msgbuf_writebound(struct msgbuf *);
int		 msgbuf_unbounded(struct msgbuf *msgbuf);
@


1.195
log
@Change the way bgpd selects nexthops. Up until now every route was considered
when calculating the nexthop. Now only non BGP routes and not the default
route are used unless forced with the new config options
 nexthop qualify via bgp
 nexthop qualify via default
This change is required for complex setups e.g. where an additional IGP is
running.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.194 2006/03/22 10:18:49 claudio Exp $ */
d601 1
@


1.194
log
@Add a new SHOW imsg to send optional attributes to bgpctl. This can be used
to show communites in bgpctl output. Only send these messages if it they are
requested to reduce the overhead for simple listings. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.193 2006/03/15 11:33:42 claudio Exp $ */
d60 2
d682 1
d743 1
a743 1
int		 kr_redist_reload(void);
@


1.193
log
@Allow the control socket to be changed on the command line. Useful if you
need to run multiple bgpds on a single box to simulate a IX. This helped
me massivly debugging error reports. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.192 2006/02/10 14:34:40 claudio Exp $ */
d79 1
d321 1
d469 2
d472 1
@


1.192
log
@Make it possible to turn suftreconfig in/out on or off. Default is on for
both directions. Manpage update follows. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.191 2006/02/09 21:05:09 claudio Exp $ */
d145 1
@


1.191
log
@Implement "set community delete 65001:*" and friends. This will remove
communities from the path attributes. Useful to make sure that the ones you
set later are set by a (evil) peer.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.190 2006/02/02 14:06:05 claudio Exp $ */
d237 2
@


1.190
log
@Implement new special community "neighbor-as". neighbor-as is expanded on
the fly to the remote AS of the current neighbor. This can be used to
simplify rulesets in a dramatic way -- going from a script based nightmare
down to a handfull rules. jajajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.189 2006/01/24 15:28:02 henning Exp $ */
d592 1
d613 1
@


1.189
log
@introduce "bgpctl show summary terse", shows summary in an easy to parse
format, intended for monitoring puposes. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.188 2006/01/24 10:03:44 henning Exp $ */
d535 1
@


1.188
log
@introduce a second control socket, which is restricted to certain messages,
nameley the show ones. needed for looking glass style applications,
monitoring etc. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.187 2006/01/20 16:40:17 claudio Exp $ */
d320 1
@


1.187
log
@Proactively fix prefix counters. Currently only F_LOCAL prefixes exist but
as soon as F_ORIGINAL come the counters would no longer be correct and in the
end max-prefix would no longer work. Add additinal counters for F_ORIGINAL
prefixes and bump the correct conter depending on the prefix flags.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.186 2006/01/05 17:33:39 claudio Exp $ */
d145 1
d338 2
a339 1
	CTL_RES_NOSUCHPEER
d735 1
a735 2
int	control_init(void);
void	control_cleanup(void);
@


1.186
log
@Kill ENSURE(), remove ensure.h, say bye bye to fatal_ensure() and
one hip hip hooray from Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.185 2006/01/05 16:00:07 claudio Exp $ */
d464 3
a466 2
	u_int16_t		prefix_cnt;
	u_int16_t		active_cnt;
@


1.185
log
@Cache optional BGP attributes (mostly communities) and use a simple
pointer plus a ref counter to link the attributes to the path object.
Saves +/- 10M on 11 full feeds. Looks good Henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.184 2006/01/04 12:45:53 claudio Exp $ */
a689 1
void		 fatal_ensure(const char *, int, const char *);
@


1.184
log
@Correctly count the number of allocated BGP attributes. Needs a own counter.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.183 2006/01/03 22:49:17 claudio Exp $ */
d643 1
@


1.183
log
@Track some (memory) statistics in the RDE. Accessible via bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.182 2006/01/03 22:19:59 claudio Exp $ */
d644 1
@


1.182
log
@Move functions shared with bgpctl into new file util.c. Simplifies the
link between bgpctl and bgpd mostly because of rde_attr.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.181 2005/11/02 15:34:43 claudio Exp $ */
d318 1
d631 13
@


1.181
log
@Mark some additional function arguments as const.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.180 2005/11/01 10:58:29 claudio Exp $ */
a674 2
const char	*log_addr(const struct bgpd_addr *);
const char	*log_in6addr(const struct in6_addr *);
d744 7
@


1.180
log
@Switch from the per peer filter set list to a filter-only solution.
The default filter_sets are converted into match filter rules that get
evaluated first. Simplifies code massively -- mainly the config reload
part -- and makes softreconfig out a piece of cake.  "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.179 2005/10/19 12:32:16 henning Exp $ */
d652 1
a652 1
int		 buf_add(struct buf *, void *, size_t);
d690 1
a690 1
	    void *, u_int16_t);
d693 1
a693 1
int	 imsg_add(struct buf *, void *, u_int16_t);
d732 1
a732 1
u_int16_t	 rtlabel_name2id(char *);
d736 1
a736 1
u_int16_t	 pftable_name2id(char *);
@


1.179
log
@for "bgpctl neighbor foo up/down/clear", make bgpctl not exit after sending
the request, but wait for the new IMSG_CTL_RESULT message, which contains
a status code to indicate wether the request was processed successfully
or wether an error occured and if so what kind of error.
no more "IMSG_CTL_NEIGHBOR_ with unknown neighbor foobaz" in the log
when you mistyped foobar - no bgpctl itself complains
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.178 2005/10/19 10:42:06 henning Exp $ */
a214 1
	struct filter_set_head	 attrset;
d500 1
a500 3
	DIR_OUT,
	DIR_DEFAULT_IN,		/* only needed to apply default set */
	DIR_DEFAULT_OUT
@


1.178
log
@new keyword "down" in neighbor spec, when givenm, the session is not
started on bgpd startup but stays in IDLE. requested by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.177 2005/09/20 13:31:53 henning Exp $ */
a299 1
	IMSG_CTL_SHOW_NEIGHBOR,
d310 2
d333 5
@


1.177
log
@let "bgpctl network show" print v6 addresses correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.176 2005/08/09 20:27:25 claudio Exp $ */
d234 1
@


1.176
log
@Introduce new route decision tunable "rde med compare (always|strict)".
If set to always the med will also be compared between different AS.
The default is strict which is the way the RFC specifies it.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.175 2005/07/04 09:37:24 claudio Exp $ */
d316 1
@


1.175
log
@New function filterset_cmp() used two compare two struct filter_set for
equality. This function is a bit more complicated than a memcmp() because there
are types that need to be considered equal e.g. ACTION_SET_MED and
ACTION_SET_RELATIVE_MED. Also ACTION_SET_COMMUNITY and ACTION_SET_NEXTHOP
need some special care.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.174 2005/07/01 13:38:14 claudio Exp $ */
d63 1
@


1.174
log
@Switch filter_sets form SIMPLEQ to TAILQ, needed for upcomming stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.173 2005/07/01 09:19:24 claudio Exp $ */
a579 1
/*	ACTION_SCRUB_COMMUNITY, */
d586 20
d737 2
a738 1
void			 filterset_free(struct filter_set_head *);
@


1.173
log
@Make the pftable filter set use the name2id "cache" like the route labels.
This saves 14 bytes per aspath. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.172 2005/06/29 09:43:25 claudio Exp $ */
d136 1
a136 1
SIMPLEQ_HEAD(filter_set_head, filter_set);
d588 1
a588 1
	SIMPLEQ_ENTRY(filter_set)	entry;
@


1.172
log
@rtlabel support via filter sets. Just use "set rtlabel foobar" in filters
network and neighbor statements and the routes are labeled accordingly.
While doing that fix some mem-leaks by introducing filterset_free() and
remove the free on send option of send_filterset().
This took a bit longer because we need to carefully track the rtlabel id
refcnts or bad things may happen on reloads.
henning@@ looks fine
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.171 2005/06/28 12:12:34 claudio Exp $ */
d582 1
d711 5
@


1.171
log
@Try to fit 0x200 into an u_int8_t is not so clever. Pass the flags as
u_int16_t so that "bgpctl show rib 4/8 all" works again.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.170 2005/06/25 19:24:37 henning Exp $ */
d581 3
a583 1
	ACTION_PFTABLE
d590 1
d596 1
d709 4
@


1.170
log
@name2id prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.169 2005/06/24 14:01:52 claudio Exp $ */
d458 1
a460 1
	u_int8_t		flags;
d467 1
a468 1
	u_int8_t		flags;
@


1.169
log
@Do not automaticaly announce routes that have RTF_DYNAMIC set. These routes
are e.g. created by the PMTU code and are removed after some time.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.168 2005/06/13 21:16:18 henning Exp $ */
d700 6
@


1.168
log
@route label support, kroute part and ID allocator as well as the internal
interface changes. support in the filter language and rde to come. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.167 2005/06/09 15:32:03 claudio Exp $ */
d74 1
a74 1
#define	F_LONGER		0x0040
d77 1
@


1.167
log
@Change the "network connected|static" statements to "network inet|inet6
connected|static" so that it is possible to distinguish between IPv4 and IPv6
addresses. "network connected|static" is considered deprecated but will be
supported as an alias for "network inet connected|static" for some time (one
release) to simplify upgrades. This also solve a nasty crash when using
"network connected".  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.166 2005/05/27 17:52:11 claudio Exp $ */
d24 1
d373 1
d382 1
d433 10
d669 4
a672 4
int		 kr_change(struct kroute *);
int		 kr_delete(struct kroute *);
int		 kr6_change(struct kroute6 *);
int		 kr6_delete(struct kroute6 *);
@


1.166
log
@kroute6 support, at least partially. Get it in so that Henning can clean it
up more. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.165 2005/04/28 13:54:45 claudio Exp $ */
d57 2
d138 1
d140 1
@


1.165
log
@Support for "network connected" and "network static" -- announce all
directly connected respectively all static routes. The list is auto-
matically adjusted as soon as a route changes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.164 2005/04/26 15:18:22 henning Exp $ */
d279 2
d301 1
d600 1
a600 1
int		 bgpd_redistribute(int, struct kroute *);
d628 1
d654 2
@


1.164
log
@unify shared code a bit again to make future syncs easier
From: Alexander von Gernler <grunk@@pestilenz.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.163 2005/04/12 14:32:00 claudio Exp $ */
d55 2
d132 1
d135 2
a202 2
SIMPLEQ_HEAD(filter_set_head, filter_set);

d597 1
d658 1
@


1.163
log
@Introduce a per prefix weight.  The weight is used to tip prefixes with equal
long AS pathes in one or the other direction.  It weights a prefix at a very
late stage in the decision process. This is a nice bgpd feature to traffic
engineer networks where most AS pathes are equally long.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.162 2005/03/28 15:16:46 henning Exp $ */
d96 1
a96 1
	TAILQ_HEAD(bufs, buf)	 bufs;
@


1.162
log
@ewps, this was not supposed to creep in
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.161 2005/03/28 15:03:33 henning Exp $ */
d547 2
@


1.161
log
@free rules_l if the initial config file parse fails
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.160 2005/03/23 10:46:26 henning Exp $ */
a30 2

#include <leak.h>
@


1.160
log
@ssize_t -> size_t, from ntpd, there from Alexander von Gernler
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.159 2005/03/15 10:18:39 henning Exp $ */
d31 2
@


1.159
log
@grow the receive buffer on the routing socket, pointed out by markus,
ok markus claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.158 2005/03/14 17:32:04 claudio Exp $ */
d146 1
a146 1
	ssize_t			 wpos;
@


1.158
log
@Allow to modify the metrics in a relative way by prepending the number with
a '+' or '-'. e.g. set localpref +20. This is another gem from the FOSDEM
lying around on my HD gathering dust. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.157 2005/03/14 12:25:50 henning Exp $ */
d46 1
@


1.157
log
@send a kif structure describing the interface a route relies on along
with the "show nexthop" messages, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.156 2005/03/11 12:54:19 claudio Exp $ */
d543 1
d545 1
d562 1
@


1.156
log
@Finally commit the transparent-as and nexthop no-modify stuff I wrote on the
way to FOSDEM. With transparent-as set to ye bgpd will not prepend his own
AS for sent updates. NB the neighbor needs to set "enforce neighbor-as no"
or it will not like the received AS paths. With set nexthop no-modify bgpd
will change the nexthop as done normaly.
OK henning@@ man page update with help of jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.155 2005/02/01 21:36:01 henning Exp $ */
d411 1
@


1.155
log
@switch the buffer size describing vars from ssize_t to size_t and adjust
the API appropriately. avoid singled-compare warnings by rewriting two
expressions. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.154 2004/12/23 17:26:51 henning Exp $ */
d56 1
d548 1
@


1.154
log
@allow "bgpctl neighbor" to take the peer's descr as argument as well
as its address
so "bgpctl neighbor upstream1 clear" now works and you don't have to
remember IPs
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.153 2004/12/23 15:39:22 henning Exp $ */
d87 3
a89 3
	ssize_t			 size;
	ssize_t			 wpos;
	ssize_t			 rpos;
d587 3
a589 3
struct buf	*buf_open(ssize_t);
int		 buf_add(struct buf *, void *, ssize_t);
void		*buf_reserve(struct buf *, ssize_t);
@


1.153
log
@even more excellent alignment, with mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.152 2004/12/23 15:08:43 henning Exp $ */
d410 5
@


1.152
log
@sort structs for most optimal alignment, help mickey, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.151 2004/11/23 13:07:01 claudio Exp $ */
d210 3
a215 3
	enum announce_type	 announce_type;
	enum enforce_as		 enforce_as;
	enum reconf_action	 reconf_action;
d360 1
a361 1
	u_short		ifindex;
d368 1
a369 1
	u_short		ifindex;
a393 1
	u_int32_t		remote_bgpid;
d398 1
d448 1
a449 1
	enum as_spec	type;
d459 1
a459 1
	DIR_IN=1,
@


1.151
log
@Switch from a single filter_set to a linked list of sets. With this change
it is possible to specify multiple communities. This is also the first step
to better bgpd filters. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.150 2004/11/19 14:43:56 claudio Exp $ */
d94 1
a96 1
	TAILQ_HEAD(bufs, buf)	 bufs;
d130 1
d132 2
a133 1
	u_int16_t				 as;
d136 1
a138 3
	int					 flags;
	int					 log;
	struct listen_addrs			*listen_addrs;
a170 1
	enum auth_method	method;
d172 4
a175 1
	u_int8_t		md5key_len;
d178 2
a181 2
	char			auth_key_in[IPSEC_AUTH_KEY_LEN];
	char			auth_key_out[IPSEC_AUTH_KEY_LEN];
a185 2
	char			enc_key_in[IPSEC_ENC_KEY_LEN];
	char			enc_key_out[IPSEC_ENC_KEY_LEN];
d199 8
d209 7
a215 4
	char			 group[PEER_DESCR_LEN];
	char			 descr[PEER_DESCR_LEN];
	struct bgpd_addr	 remote_addr;
	struct bgpd_addr	 local_addr;
a218 2
	u_int32_t		 max_prefix;
	u_int16_t		 remote_as;
a221 6
	u_int16_t		 holdtime;
	u_int16_t		 min_holdtime;
	struct filter_set_head	 attrset;
	enum announce_type	 announce_type;
	enum enforce_as		 enforce_as;
	struct peer_auth	 auth;
a222 1
	struct capabilities	 capabilities;
a223 2
	char			 if_depend[IFNAMSIZ];
	enum reconf_action	 reconf_action;
d228 1
a229 1
	struct filter_set_head	attrset;
a249 2
	int				fd;
	pid_t				pid;
d253 2
d306 2
a309 2
	u_int32_t	peerid;
	pid_t		pid;
a357 1
	u_int8_t	prefixlen;
d360 1
a365 1
	u_int8_t	prefixlen;
d368 1
a372 4
	struct bgpd_addr	nexthop;
	u_int8_t		valid;
	u_int8_t		connected;
	struct bgpd_addr	gateway;
d377 4
d384 3
a387 2
	int			 flags;
	char			 ifname[IFNAMSIZ];
a389 1
	u_long			 baudrate;
d402 1
a403 1
	struct bgpd_addr	addr;
d418 2
d425 1
a425 2
	struct bgpd_addr	nexthop;
	struct bgpd_addr	prefix;
a428 1
	u_int16_t		aspath_len;
d433 1
a434 1
	struct bgpd_addr	prefix;
d504 1
a505 1
	enum comp_ops		op;
d526 3
a531 3
	struct filter_peers		peer;
	struct filter_match		match;
	struct filter_set_head		set;
a548 1
	enum action_types		type;
d556 1
@


1.150
log
@For consistency reasons rename struct as_filter to struct filter_as.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.149 2004/11/18 17:17:56 henning Exp $ */
a160 14
struct filter_set {
	u_int16_t		flags;
	u_int8_t		prepend_self;
	u_int8_t		prepend_peer;
	u_int32_t		localpref;
	u_int32_t		med;
	struct bgpd_addr	nexthop;
	struct {
		int		as;
		int		type;
	} community;
	char			pftable[PFTABLE_LEN];
};

d196 2
d215 1
a215 1
	struct filter_set	 attrset;
d229 1
a229 1
	struct filter_set	attrset;
d266 1
d283 2
a396 1
	struct peer_config	conf;
a483 11
/* set flags */
#define	SET_LOCALPREF		0x0001
#define	SET_MED			0x0002
#define	SET_NEXTHOP		0x0004
#define	SET_PREPEND_SELF	0x0008
#define	SET_PREPEND_PEER	0x0010
#define	SET_PFTABLE		0x0020
#define	SET_COMMUNITY		0x0040
#define	SET_NEXTHOP_REJECT	0x0080
#define	SET_NEXTHOP_BLACKHOLE	0x0100

d531 26
a556 1
	struct filter_set		set;
@


1.149
log
@embed two struct capabilities, one for the capas announced by the peer and
one for the capas we announced him, into the session_up imsg to the RDE
after brainstorming with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.148 2004/11/18 17:07:38 henning Exp $ */
d457 1
a457 1
struct as_filter {
d539 1
a539 1
	struct as_filter	as;
@


1.148
log
@add an instance of struct capabilities to peer_conf, and inherit
peer->capa.ann from this
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.147 2004/11/18 15:40:58 henning Exp $ */
d407 2
@


1.147
log
@Subsequent Address Family Indicators (SAFI) in hex and add SAFI_NONE
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.146 2004/11/11 10:35:15 claudio Exp $ */
d204 6
d231 2
a232 1
	u_int8_t		 capabilities;
@


1.146
log
@New config statement "rde route-age [evaluate|ignore]". If set to evaluate
the best path selection will not only be based on the path attributes but
also on the age of the prefix. This is an extension to the RFC. The default
is ignore but previously it was implicitly set to evaluate.
OK henning@@ man page OK jaredy@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.145 2004/10/19 12:02:50 henning Exp $ */
d557 4
a560 3
#define	SAFI_UNICAST	1
#define	SAFI_MULTICAST	2
#define	SAFI_BOTH	3
@


1.145
log
@allow neighbor definitions to depend on interface state.
with this, if a neighbor is configured as dependent on carp0 for example,
the neighbor will remain in state IDLE as long as carp0 is not master.
once carp0 becomes master the session(s) depending on it immediately
go to CONNECT (or ACTIVE, if they're configured passive), reducing failover
time. claudio ok, with some input from ryan as well
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.144 2004/09/28 12:09:31 claudio Exp $ */
d54 2
@


1.144
log
@Add prepend-neighbor feature. Prepend the remote-as n times similar to
prepend-self. Only for incomming UPDATEs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.143 2004/09/16 17:58:13 henning Exp $ */
d225 1
d301 2
a302 1
	IMSG_REFRESH
d623 1
a627 1

@


1.143
log
@imsg type is really an enum imsg_type and not an int
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.142 2004/09/16 17:36:29 henning Exp $ */
d161 2
a165 2
	u_int8_t		prepend;
	char			pftable[PFTABLE_LEN];
d170 1
d457 3
a459 1
	DIR_OUT
d485 2
a486 2
#define	SET_NEXTHOP6		0x0008
#define	SET_PREPEND		0x0010
@


1.142
log
@imsg API cleanup:
-kill imsg_compose_pid, imsg_compose_fdpass and imsg_create_pid
-extend the original imsg_compose/_create API to take pid & fd too
-make imsg_compose do imsg_create + imsg_add + imsg_close instead of
 duplicating the code
-adjust all callers to the new API
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.141 2004/08/20 15:49:02 henning Exp $ */
d598 1
a598 1
int	 imsg_compose(struct imsgbuf *, int, u_int32_t, pid_t, int,
d600 1
a600 1
struct buf	*imsg_create(struct imsgbuf *, int, u_int32_t, pid_t,
@


1.141
log
@add IMSG_CTL_NEIGHBOR_CLEAR, takes a session down and restarts it,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.140 2004/08/10 13:02:07 claudio Exp $ */
d598 4
a601 5
int	 imsg_compose(struct imsgbuf *, int, u_int32_t, void *, u_int16_t);
int	 imsg_compose_pid(struct imsgbuf *, int, pid_t, void *, u_int16_t);
int	 imsg_compose_fdpass(struct imsgbuf *, int, int, void *, u_int16_t);
struct buf *imsg_create(struct imsgbuf *, int, u_int32_t, u_int16_t);
struct buf *imsg_create_pid(struct imsgbuf *, int, pid_t, u_int16_t);
@


1.140
log
@switch nexthop in struct filter_set form struct in_addr to struct bgpd_addr
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.139 2004/08/06 12:04:08 claudio Exp $ */
d290 1
@


1.139
log
@Monster diff to get one step closer to IPv6 support.
Cleanup path attribute handling. First of all kill struct attr_flags, all
those infos are now in struct rde_aspath. Second move attribute parser
functions into rde.c, rde_attr.c is shared between bgpd and bgpctl.
Third reimplementation of the nexthop handling. Make it IPv6 ready and
fix some major bug relating to "set nexthop".
henning@@ OK if it breaks nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.138 2004/08/05 15:58:21 claudio Exp $ */
d160 6
a165 8
	u_int16_t	flags;
	u_int32_t	localpref;
	u_int32_t	med;
	/*XXX this nexthop thing should be changed to one bgpd_addr */
	struct in_addr	nexthop;
	struct in6_addr	nexthop6;
	u_int8_t	prepend;
	char		pftable[PFTABLE_LEN];
d167 2
a168 2
		int	as;
		int	type;
@


1.138
log
@rename and move prefix_equal() to prefix_compare() which returns -1, 0, 1
similar to memcmp() and all other compare functions in bgpd. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.137 2004/07/30 14:44:30 claudio Exp $ */
d163 1
@


1.137
log
@Add new announce type "default-route" which will only announce the default
route to the specified neighbor. Idea and OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.136 2004/07/27 15:26:45 henning Exp $ */
a620 2
int		 prefix_equal(const struct bgpd_addr *,
		    const struct bgpd_addr *, int);
@


1.136
log
@do not define the prefix, prefixlen and community structs used for
the filters from within struct filter_match but explicit; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.135 2004/07/05 16:54:53 henning Exp $ */
d149 1
@


1.135
log
@implement "set nexthop blackhole" and "set nexthop reject"
blackhole/reject routes will be entered to the kernel for matching ones.
this is intended to be used with the Cymru Bogon Route Server Project
(http://www.cymru.com/BGP/bogon-rs.html) and similar services, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.134 2004/07/05 02:13:44 henning Exp $ */
d502 17
d520 4
a523 15
	struct {
		struct bgpd_addr	addr;
		u_int8_t		len;
	} prefix;
	struct {
		sa_family_t		af;
		enum comp_ops		op;
		u_int8_t		len_min;
		u_int8_t		len_max;
	} prefixlen;
	struct as_filter		as;
	struct {
		int			as;
		int			type;
	} community;
@


1.134
log
@fix a few KNF fallouts
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.133 2004/07/03 17:19:59 claudio Exp $ */
d40 1
a40 1
#define IPSEC_AUTH_KEY_LEN		20
d55 1
a55 1
#define BGPD_LOG_UPDATES		0x0001
d59 9
a67 7
#define	F_BGPD_INSERTED		0x01
#define	F_KERNEL		0x02
#define	F_CONNECTED		0x04
#define	F_NEXTHOP		0x08
#define	F_DOWN			0x10
#define	F_STATIC		0x20
#define	F_LONGER		0x40
d107 5
a111 5
#define v4	ba.v4
#define v6	ba.v6
#define addr8	ba.addr8
#define addr16	ba.addr16
#define addr32	ba.addr32
d114 2
a115 2
#define DEFAULT_LISTENER	0x01
#define LISTENER_LISTENING	0x02
d159 1
a159 1
	u_int8_t	flags;
d356 1
a356 1
	u_int8_t	flags;
d364 1
a364 1
	u_int8_t	flags;
d407 4
a410 4
#define F_RIB_ELIGIBLE	0x01
#define F_RIB_ACTIVE	0x02
#define F_RIB_INTERNAL	0x04
#define F_RIB_ANNOUNCE	0x08
d478 9
a486 7
#define	SET_LOCALPREF	0x01
#define	SET_MED		0x02
#define	SET_NEXTHOP	0x04
#define	SET_NEXTHOP6	0x08
#define	SET_PREPEND	0x10
#define	SET_PFTABLE	0x20
#define	SET_COMMUNITY	0x40
d494 7
a500 7
#define COMMUNITY_ERROR			-1
#define COMMUNITY_ANY			-2
#define COMMUNITY_WELLKNOWN		0xffff
#define COMMUNITY_NO_EXPORT		0xff01
#define COMMUNITY_NO_ADVERTISE		0xff02
#define COMMUNITY_NO_EXPSUBCONFED	0xff03
#define COMMUNITY_NO_PEER		0xff04	/* rfc3765 */
d538 3
a540 3
#define AFI_IPv4	1
#define AFI_IPv6	2
#define AFI_ALL		0xffff
d543 4
a546 4
#define SAFI_UNICAST	1
#define SAFI_MULTICAST	2
#define SAFI_BOTH	3
#define SAFI_ALL	0xff
@


1.133
log
@Switch mrt dumping to fd passing. This gives some speed up when extensive
dumping is done. Acctually mrt dumps were broken because of the fd passing.
The nice side effect is a much cleaner code, especially in the parent process.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.132 2004/06/25 20:08:46 henning Exp $ */
d251 1
a251 1
	TAILQ_HEAD(fds, imsg_fd)	fds;	
@


1.132
log
@provide mask2prefixlen6() and prefixlen2mask6()
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.131 2004/06/23 00:11:27 claudio Exp $ */
d267 3
a269 3
	IMSG_MRT_REQ,
	IMSG_MRT_MSG,
	IMSG_MRT_END,
d554 1
@


1.131
log
@Support rfc 3765 which adds a new well known community NOPEER. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.130 2004/06/22 20:28:58 claudio Exp $ */
d597 15
a611 12
int		kr_init(int);
int		kr_change(struct kroute *);
int		kr_delete(struct kroute *);
void		kr_shutdown(void);
void		kr_fib_couple(void);
void		kr_fib_decouple(void);
int		kr_dispatch_msg(void);
int		kr_nexthop_add(struct bgpd_addr *);
void		kr_nexthop_delete(struct bgpd_addr *);
void		kr_show_route(struct imsg *);
in_addr_t	prefixlen2mask(u_int8_t);
int		prefix_equal(const struct bgpd_addr *, const struct bgpd_addr *,
a612 1
void		inet6applymask(struct in6_addr *, const struct in6_addr *, int);
@


1.130
log
@Make the RDE IPv6 ready missing is the message handling. The internal
prefix tree changed form a hash table to a per AF RB tree.
OK henning@@ some ideas are from Brent Graveland.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.129 2004/06/22 07:22:31 henning Exp $ */
d496 1
@


1.129
log
@introduce kroute6, which will be used to build a seperate v6 table
(smashing them into the v4 table would raise the memory requirements far too
much), and make kroute_nexthop (where we are not under such memory pressure,
you don't have a hundred thousand nexthops) v4/v6. change existing callers
to use the v4 part, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.128 2004/06/20 18:35:12 henning Exp $ */
d596 15
a610 10
int	kr_init(int);
int	kr_change(struct kroute *);
int	kr_delete(struct kroute *);
void	kr_shutdown(void);
void	kr_fib_couple(void);
void	kr_fib_decouple(void);
int	kr_dispatch_msg(void);
int	kr_nexthop_add(struct bgpd_addr *);
void	kr_nexthop_delete(struct bgpd_addr *);
void	kr_show_route(struct imsg *);
@


1.128
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.127 2004/06/20 17:49:46 henning Exp $ */
d358 8
d371 4
a374 1
	struct kroute		kr;
@


1.127
log
@implement file descriptor passing in the imsg/msgbuf framework, and use
it to let the main process to prepare new listening sockets (socket() and
bind()) on behalf of the session engine, which of course cannot bind() to
ports < 1024 any more once it dropped privileges. with some help from theo,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.126 2004/06/06 17:38:10 henning Exp $ */
d81 1
a81 1
	TAILQ_ENTRY(buf)	 entries;
d235 1
a235 1
	TAILQ_ENTRY(network)	network_l;
d507 1
a507 1
	TAILQ_ENTRY(filter_rule)	entries;
@


1.126
log
@rework bgpd's handling of listening sockets. instead of one for each
supported address familiy, keep a tailq of an arbitary number of them.
the new struct listen_addr contains the sockaddr and the fd.
this fixes quite some nasty behaviour which was a consequence of the previous
model.
looks right deraadt@@, and discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.125 2004/05/21 15:36:40 claudio Exp $ */
d86 1
d113 1
d243 5
d249 5
a253 4
	int			fd;
	pid_t			pid;
	struct buf_read		r;
	struct msgbuf		w;
d576 1
d582 1
@


1.125
log
@RFC 2796 bgp route reflector support. This is very useful in conjunction
with templates. looks good, go for it henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.124 2004/05/21 11:48:56 claudio Exp $ */
d111 12
d124 9
a132 10
	int			 opts;
	u_int16_t		 as;
	u_int32_t		 bgpid;
	u_int32_t		 clusterid;
	u_int16_t		 holdtime;
	u_int16_t		 min_holdtime;
	int			 flags;
	int			 log;
	struct sockaddr_in	 listen_addr;
	struct sockaddr_in6	 listen6_addr;
d253 1
@


1.124
log
@Add support for dynamic announcements. Usefule to annouce temporary
blackhole routes or to make network announcements dependent on a external
state (e.g. for carp setups) OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.123 2004/05/17 12:39:32 djm Exp $ */
d53 1
d115 1
d208 1
@


1.123
log
@extend filter language to allow basic setting of COMMUNITIES attribute.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.122 2004/05/07 10:06:15 djm Exp $ */
a237 1
	IMSG_RECONF_NETWORK,
d255 3
d272 1
@


1.122
log
@add a filter option to dump prefixes learned in UPDATEs into a PF table,
intended for building realtime BGP blacklists (e.g. with spamd);
ok claudio & henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.121 2004/05/06 14:41:47 henning Exp $ */
d149 4
d445 1
@


1.121
log
@we need a seperate field for the md5 key len, can't use strlen, noticed
by markus some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.120 2004/05/06 11:57:55 henning Exp $ */
d37 1
d148 1
d249 3
d353 6
d440 1
d567 8
@


1.120
log
@scale socket buffer sizes (and thus window size) up to up to 64k,
but only of tcp md5sig or ipsec is in use. excellent idea by ryan some time
ago, claudio and theo agree
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.119 2004/04/29 19:56:04 deraadt Exp $ */
d161 1
@


1.119
log
@sock -> fd; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.118 2004/04/28 04:34:46 henning Exp $ */
d150 2
a151 1
	AUTH_MD5SIG = 1,
@


1.118
log
@allow ah/esp spec with IKE, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.117 2004/04/28 02:57:27 claudio Exp $ */
d88 1
a88 1
	int			 sock;
d220 1
a220 1
	int			sock;
@


1.117
log
@Enable route refresh in the RDE. Now peer can request route refreshes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.116 2004/04/28 01:08:38 henning Exp $ */
d153 2
a154 1
	AUTH_IPSEC_IKE
@


1.116
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.115 2004/04/28 00:38:39 henning Exp $ */
d478 1
d484 1
@


1.115
log
@prefix the auth related defines by AUTH_, we had a name clash, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.114 2004/04/27 22:42:13 henning Exp $ */
d155 1
a155 1
	
@


1.114
log
@rename the ipsec struct to auth, move all tcpmd5 related fields in there, and
add a generic "method" field that expresses what method
(none/md5sig/ipsec manual/ipsec ike) is in use
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.113 2004/04/27 22:06:54 henning Exp $ */
d150 4
a153 4
	MD5SIG = 1,
	IPSEC_MANUAL_ESP,
	IPSEC_MANUAL_AH,
	IPSEC_IKE
@


1.113
log
@parser parts for ipsec ike, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.112 2004/04/27 03:53:42 henning Exp $ */
d156 1
a156 1
struct peer_ipsec {
d158 1
d195 1
a195 2
	char			 tcp_md5_key[TCP_MD5_KEY_LEN];
	struct peer_ipsec	 ipsec;
@


1.112
log
@initial route refresh support per RFC2918
process incoming route refresh request and notify the RDE
not advertised via capabilities yet, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.111 2004/04/26 04:13:59 henning Exp $ */
d149 7
d157 15
a171 14
	u_int32_t	spi_in;
	u_int32_t	spi_out;
	u_int8_t	auth_alg_in;
	u_int8_t	auth_alg_out;
	char		auth_key_in[IPSEC_AUTH_KEY_LEN];
	char		auth_key_out[IPSEC_AUTH_KEY_LEN];
	u_int8_t	auth_keylen_in;
	u_int8_t	auth_keylen_out;
	u_int8_t	enc_alg_in;
	u_int8_t	enc_alg_out;
	char		enc_key_in[IPSEC_ENC_KEY_LEN];
	char		enc_key_out[IPSEC_ENC_KEY_LEN];
	u_int8_t	enc_keylen_in;
	u_int8_t	enc_keylen_out;
@


1.111
log
@need keylen too, markus
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.110 2004/04/26 01:59:26 henning Exp $ */
d249 2
a250 1
	IMSG_CTL_SHOW_RIB_PREFIX
d460 5
@


1.110
log
@structs for ipsec, with markus
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.109 2004/04/25 07:16:24 henning Exp $ */
d156 2
d162 2
@


1.109
log
@add "neighbor cloning", allowing you to specify a prefix and prefixlength
instead of the neighbor's IP address. WHen a connection comes in matching
that mask we clone the neighbor spec.
IPv6 match code by itojun, rde feeding by claudio, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.108 2004/04/24 19:36:19 henning Exp $ */
d27 1
d38 2
d149 13
d183 1
@


1.108
log
@some rather boring windows talk at cansecwest made me hack initial support
for IPv6 transport
parts based on a diff from Brent Graveland
ok itojun@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.107 2004/04/10 17:27:28 henning Exp $ */
d153 3
d312 1
@


1.107
log
@move the API_* and SAFI_* defines to where they belong
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.106 2004/03/11 17:12:51 claudio Exp $ */
d115 1
@


1.106
log
@Add basic support for communities. Currently it is only possible to filter
on communities, e.g match from any community 24640:* set localpref 666
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.105 2004/03/10 11:38:32 henning Exp $ */
d434 9
@


1.105
log
@implement framework to announce capabilities in the open messages we send.
this includes handling "unsupported optional parameter" notifications from the
peer and retrying without capability announcement. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.104 2004/03/02 19:45:04 henning Exp $ */
d397 8
d417 4
@


1.104
log
@flesh out the address and prefix parsing, include v6 code, but reject v6
upwards, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.103 2004/03/02 19:29:01 claudio Exp $ */
d163 1
@


1.103
log
@Framework for rib lookups by prefix. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.102 2004/03/01 16:02:01 claudio Exp $ */
d457 2
a458 1
int	 check_file_secrecy(int fd, const char *fname);
@


1.102
log
@Make it possible to diable the decision process. This is a feature only useful
for route-collectors. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.101 2004/02/26 16:16:41 claudio Exp $ */
d60 1
@


1.101
log
@show rib infrastructure. At least full dumps and per as dumps. Per prefix
dump need some more work. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.100 2004/02/26 14:00:33 claudio Exp $ */
d48 1
@


1.100
log
@Implement "enforce neighbor-as yes|no" which is by default on for ebgp
neighbors. While doing that check also that the nexthop is valid (not class D
or E and not in 127/8 range). Kill some TODO and XXX and rename the british
neighbour to neighbor as used everywhere else. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.99 2004/02/26 09:53:58 claudio Exp $ */
d218 4
a221 1
	IMSG_CTL_SHOW_INTERFACE
d312 40
a369 7
enum as_spec {
	AS_NONE,
	AS_ALL,
	AS_SOURCE,
	AS_TRANSIT
};

d405 1
a405 4
	struct {
		u_int16_t		as;
		enum as_spec		type;
	} as;
@


1.99
log
@Add per netwok definition filter sets. So you can now use
network 10.0.0.0/8 set localpref 100
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.98 2004/02/24 15:43:03 claudio Exp $ */
d128 6
d159 1
@


1.98
log
@Enhance filters. prefixlen knows now 8-24 and 8><24. It is possible to use
prefix 10.0.0.0/8 prefixlen >= 8 and set localpref 100 can be set on a per
neighbor basis. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.97 2004/02/16 17:24:04 henning Exp $ */
d160 1
@


1.97
log
@add scope_id for v6 to struct bgpd_addr
ok itojun, grumbling ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.96 2004/02/16 14:26:29 claudio Exp $ */
d128 9
d151 1
d329 1
d356 1
a364 9
};

struct filter_set {
	u_int8_t	flags;
	u_int32_t	localpref;
	u_int32_t	med;
	struct in_addr	nexthop;
	struct in6_addr	nexthop6;
	u_int8_t	prepend;
@


1.96
log
@Extend imsg API so that messages can be composed on the fly. In the RDE it
happens often, that imsg consists of multiple objects. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.95 2004/02/16 12:53:15 claudio Exp $ */
d96 1
@


1.95
log
@Make the path attribute handling more RFC conformant. Also move the
parser to rde_attr.c where it belongs. Still missing: better aspath loop
detection (should be done afterwards) and some basic error checking for
optional attributes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.94 2004/02/10 23:10:23 henning Exp $ */
d418 4
@


1.94
log
@enforce config file secrecy (correct owner, no rights for group/world)
help and ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.93 2004/02/09 01:46:34 henning Exp $ */
d217 10
a226 1
/* error subcode for UPDATE; needed in SE and RDE */
d240 11
@


1.93
log
@make max_prefix an u_int32_t instead of an u_long and change its
meaning as in 0 means no limit insytead of setting it to ULONG_MAX for
no limit
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.92 2004/02/07 11:42:30 henning Exp $ */
d388 3
@


1.92
log
@send filter rules to the RDE on reloads, help & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.91 2004/02/06 20:18:18 henning Exp $ */
d134 1
a134 1
	u_long			 max_prefix;
@


1.91
log
@initial cut at the filtering language.
structs etc to describe a rule, filter rule list management
parser groks filter defs now.

claudio ok, discussion & help also jakob theo
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.89 2004/02/01 19:46:05 claudio Exp $ */
d175 1
@


1.90
log
@introduce group IDs. will be needed for filtering (or rather, ease things
there)
just assign them from the neighbor ID pool - fortunately, that is rather
simple, we just have to make sure that all members of the group and (later)
all filter rules pointing to the group agree on the ID, but it does not need
to stay the same across config reloads.

ok claudio@@
@
text
@d269 85
@


1.89
log
@Set sane default announce types according to the peer type. For IBGP use
announce all and for EBGP use announce self. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.88 2004/01/28 23:31:28 henning Exp $ */
d129 1
@


1.88
log
@implement
  tcp md5sig password
so that the key can be given in ascii, what unfortunately limits the key space
(cisco/juniper compat...)
we keep the ability to specify the key in hex whithout these limits.

help & ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.87 2004/01/28 17:27:55 henning Exp $ */
d121 1
@


1.87
log
@-struct peer_auth to store the SPIs, linked into struct peer
-add pfkey_auth_establish(), which sets up flows for both directions and
 stores the SPIs in above struct
-add (yet dummy) pfkey_auth_remove()

with markus, ok claudio markus
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.86 2004/01/28 11:03:32 markus Exp $ */
d36 1
a36 1
#define	TCP_SIGN_KEY_LEN		32
d140 1
a140 1
	char			 tcp_sign_key[TCP_SIGN_KEY_LEN];
@


1.86
log
@pfkey_setkey: sockaddr -> bgpd_addr; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.85 2004/01/27 22:18:28 henning Exp $ */
a324 3

/* pfkey.c */
int	pfkey_setkey(struct bgpd_addr *, struct bgpd_addr *, char *);
@


1.85
log
@log_ntoa is herewith condemned to death by claudio and yours truly
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.84 2004/01/27 21:56:21 henning Exp $ */
d327 1
a327 1
int	pfkey_setkey(struct sockaddr *, struct sockaddr *, char *);
@


1.84
log
@move strict kroute from in_addr_t for nexthop and prefix to struct in_addr
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.83 2004/01/27 21:23:39 henning Exp $ */
a295 1
const char	*log_ntoa(in_addr_t);
@


1.83
log
@constify log_addr and log_ntoa's returns, reminded by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.82 2004/01/27 16:49:53 henning Exp $ */
d231 1
a231 1
	in_addr_t	prefix;
d233 1
a233 1
	in_addr_t	nexthop;
@


1.82
log
@use a struct bgpd_addr instead of sockaddr_in for peer_config->local_addr and
->remote_addr for easier multiprotocol support

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.81 2004/01/27 14:09:36 markus Exp $ */
d296 2
a297 2
char		*log_ntoa(in_addr_t);
char		*log_addr(const struct bgpd_addr *);
@


1.81
log
@use SADB_GETSPI/UPDATE for setting tcpmd5 keys; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.81 2004/01/27 14:00:08 markus Exp $ */
d130 2
a131 2
	struct sockaddr_in	 remote_addr;
	struct sockaddr_in	 local_addr;
d297 1
a297 1
char		*log_addr(struct bgpd_addr *);
@


1.80
log
@first cut at tcpmd5 setup seupport from within bgpd. works so far.
with help from hshoexer@@ and markus@@
ok claudio@@ hshoexer@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.79 2004/01/23 21:17:51 henning Exp $ */
d328 1
a328 1
int	pfkey_signature(struct sockaddr *, struct sockaddr *, char *);
@


1.79
log
@provide log_addr, which takes a struct bgpd_addr
intended to replace log_ntoa in most cases becaus that is IPv4 only by design
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.78 2004/01/22 21:08:59 henning Exp $ */
d36 1
d140 1
d326 3
@


1.78
log
@provide a log_debug and use it in rde.c.
with this, logit() can be a private function.
we don't need to include syslog.h in bgpd.h any more; log.c and parse.y
who need it include it directly now.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.77 2004/01/22 20:59:16 henning Exp $ */
d295 1
@


1.77
log
@make log_peer_* take a struct peer_config instead of the session engine
specific struct peer, and move their prototypes to bgpd.h to make it available
to whole bgpd

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.76 2004/01/22 19:13:56 henning Exp $ */
a29 1
#include <syslog.h>
a283 1
void		 logit(int, const char *, ...);
d290 1
@


1.76
log
@provide log_warnx() and log_info()
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.75 2004/01/22 03:18:03 henning Exp $ */
d287 2
@


1.75
log
@s/log_err/log_warn/
it is like warn(3), nor err(3). so use a less confusing name.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.74 2004/01/22 03:07:51 henning Exp $ */
d288 2
@


1.74
log
@an RTM_IFINFO message can mean a lot. it does not necessarily mean that
the status of the interface in terms of our nexthop validation changed;
it might be something like a speed change that we don't care about.
save the decided state for nexthop verificartion in struct kif, and only
walk through the attached (connected) routes & report upwards if the state
actually changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.73 2004/01/18 19:15:00 henning Exp $ */
d287 1
a287 1
void		 log_err(const char *, ...);
@


1.73
log
@track interface type and baudrate as well

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.72 2004/01/17 21:06:55 henning Exp $ */
d252 1
@


1.72
log
@keep track of interface link state and invalidate connected routes depending
on the interface in question if it has no link
now, if you pull the network cable all nexthops beeing in a connected
network on this interface get invalidated nicely.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.71 2004/01/17 19:35:36 claudio Exp $ */
d249 1
d251 1
@


1.71
log
@Make it possible to announce own networks. In the RDE these prefixes are
attached to a pseudo peer and inserted like all other prefixes into the RIB.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.70 2004/01/17 18:27:19 henning Exp $ */
d249 1
@


1.70
log
@keep & track interface names as well, not only indices
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.69 2004/01/17 18:05:46 henning Exp $ */
d143 12
d171 1
@


1.69
log
@allow the interfaces as bgpd sees 'em to be queried via imsgs
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.68 2004/01/13 13:45:49 claudio Exp $ */
d22 1
d26 1
d235 1
@


1.68
log
@Implement a max-prefix and a announce none | self | all neighbor statement.
The first limits the number of sent prefixes per peer the latter controls
which prefix we do annouce to the neighbor.
Another looks good from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.67 2004/01/13 13:34:56 claudio Exp $ */
d179 2
a180 1
	IMSG_CTL_SHOW_NEXTHOP
d228 5
@


1.67
log
@Better update error handling. Ensure that the session goes down and
ignore all queued updates after an error. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.66 2004/01/11 22:01:13 henning Exp $ */
d118 6
d130 1
d137 1
@


1.66
log
@use bgpd_addr in the nexthop tree; change nexthop_add/_remove accordingly

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.65 2004/01/11 20:13:00 claudio Exp $ */
d191 2
a192 1
	ERR_UPD_ATTRLIST = 1,
@


1.65
log
@Add to the IMSG_SESSION_UP message the local and remote address of the
peer session. This is needed to set the correct nexthop address in outgoing
bgp UPDATES. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.64 2004/01/11 19:42:27 henning Exp $ */
d90 3
d96 3
d277 2
a278 2
int	kr_nexthop_add(in_addr_t);
void	kr_nexthop_delete(in_addr_t);
@


1.64
log
@when sending the nexthop status message, include the kroute that makes that
nexthop reachable. needed in the RDE for calculating the to-be-announced
nexthop.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.63 2004/01/11 19:14:43 henning Exp $ */
d212 6
@


1.63
log
@use struct bgpd_addr for nexthop and gateway in struct kroute_nexthop
(and thus the nexthop messages between parent and RDE)

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.62 2004/01/11 02:35:14 henning Exp $ */
d211 1
@


1.62
log
@new message IMSG_CTL_SHOW_NEXTHOP: request/send lost of BGP nexthops and
the result of their validity check
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.61 2004/01/09 19:08:50 henning Exp $ */
d207 4
a210 4
	in_addr_t	nexthop;
	u_int8_t	valid;
	u_int8_t	connected;
	in_addr_t	gateway;
@


1.61
log
@for IMSG_CTL_KROUTEs allow matching based on flags,
add IMGS_CTL_KROUTE_ADDR to match the route for a given address

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.60 2004/01/09 14:10:06 henning Exp $ */
d164 2
a165 1
	IMSG_CTL_KROUTE_ADDR
d211 5
@


1.60
log
@flag kernel routes whch are not conencted routes as static routes.
that's what they are, and it makes matching on them easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.59 2004/01/09 13:47:07 henning Exp $ */
d163 2
a164 1
	IMSG_CTL_KROUTE
d260 1
a260 1
void	kr_show_route(pid_t);
@


1.59
log
@get us a stateful imsg relaying framework, and the first receiver,
IMSG_CTL_KROUTE, to have the kroute structs forming the fib sent to a
control socket.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.58 2004/01/08 16:17:12 henning Exp $ */
d51 6
a56 5
#define	F_BGPD_INSERTED		0x0001
#define	F_KERNEL		0x0002
#define	F_CONNECTED		0x0004
#define	F_NEXTHOP		0x0008
#define	F_DOWN			0x0010
@


1.58
log
@rename a few functions to further clarify things
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.57 2004/01/06 23:14:58 henning Exp $ */
d51 6
d133 1
d161 2
a162 1
	IMSG_CTL_NEIGHBOR_DOWN
d169 1
d199 2
d213 1
d245 1
d258 1
d263 1
@


1.57
log
@two new imsg types, IMSG_CTL_NEIGHBOR_UP and _DOWN, on their receival on the
control socket the given neighbor session is sent a START / STOP signal.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.56 2004/01/06 20:41:55 henning Exp $ */
d236 9
a244 9
int	kroute_init(int);
int	kroute_change(struct kroute *);
int	kroute_delete(struct kroute *);
void	kroute_shutdown(void);
void	kroute_fib_couple(void);
void	kroute_fib_decouple(void);
int	kroute_dispatch_msg(void);
int	kroute_nexthop_add(in_addr_t);
void	kroute_nexthop_delete(in_addr_t);
@


1.56
log
@allow holdtime and holdtime min to be configuered per peer

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.55 2004/01/06 03:43:50 henning Exp $ */
d152 3
a154 1
	IMSG_CTL_FIB_DECOUPLE
@


1.55
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.54 2004/01/05 22:57:59 claudio Exp $ */
d115 2
@


1.54
log
@Big overhaul of the mrt code.
Dumping of incomming bgp messages is now possible and dumping the (not yet)
filtered updates works too. Per neighbor dumps are still missing.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.53 2004/01/05 16:21:14 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.53
log
@allow fib couple/decouple based on an imsg received on the control socket
by the SE and passed on to the main process
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.52 2004/01/04 19:39:46 henning Exp $ */
a117 35
#define	MRT_FILE_LEN	512
enum mrtdump_type {
	MRT_NONE,
	MRT_TABLE_DUMP
/*
 *	MRT_UPDATE_START,
 *	MRT_SESSION_START,
 *	MRT_UPDATE_STOP,
 *	MRT_SESSION_STOP,
 */
};

enum mrtdump_state {
	MRT_STATE_OPEN,
	MRT_STATE_RUNNING,
	MRT_STATE_DONE,
	MRT_STATE_CLOSE,
	MRT_STATE_REOPEN
};

LIST_HEAD(mrt_config, mrtdump_config);

struct mrtdump_config {
	enum mrtdump_type	 type;
	u_int32_t		 id;
	struct msgbuf		 msgbuf;
	char			 name[MRT_FILE_LEN];	/* base file name */
	char			 file[MRT_FILE_LEN];	/* actual file name */
	time_t			 ReopenTimer;
	time_t			 ReopenTimerInterval;
	enum mrtdump_state	 state;
	LIST_ENTRY(mrtdump_config)
				 list;
};

d164 3
d208 2
a229 3

/* mrt.c */
int	 mrt_mergeconfig(struct mrt_config *, struct mrt_config *);
@


1.52
log
@-new imsg CTL_RELOAD
-upong receival in the SE forward to parent
-make sending messages from SE to parent work for that (was not required before)
-parent reacts to that just like a SIGHUP, reread config file
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.51 2004/01/04 18:51:23 henning Exp $ */
d183 3
a185 1
	IMSG_CTL_RELOAD
@


1.51
log
@allow "show neighbor" to be limited to one specific neighbor
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.50 2004/01/03 20:37:34 henning Exp $ */
d182 2
a183 1
	IMSG_CTL_END
@


1.50
log
@move some session specific stuff to session.h and make the few files
that need it include that
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.49 2004/01/03 20:22:07 henning Exp $ */
d76 10
@


1.49
log
@decouple the peer list from bgpd_config.
so many parts of bgpd are not at all interested in the session specific peer
structs... allows for some further cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.48 2004/01/03 13:54:27 henning Exp $ */
a56 27
enum session_state {
	STATE_NONE,
	STATE_IDLE,
	STATE_CONNECT,
	STATE_ACTIVE,
	STATE_OPENSENT,
	STATE_OPENCONFIRM,
	STATE_ESTABLISHED
};

enum session_events {
	EVNT_NONE,
	EVNT_START,
	EVNT_STOP,
	EVNT_CON_OPEN,
	EVNT_CON_CLOSED,
	EVNT_CON_OPENFAIL,
	EVNT_CON_FATAL,
	EVNT_TIMER_CONNRETRY,
	EVNT_TIMER_HOLDTIME,
	EVNT_TIMER_KEEPALIVE,
	EVNT_RCVD_OPEN,
	EVNT_RCVD_KEEPALIVE,
	EVNT_RCVD_UPDATE,
	EVNT_RCVD_NOTIFICATION
};

a63 5
enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK
};

a107 17
struct peer {
	struct peer_config	 conf;
	u_int32_t		 remote_bgpid;
	u_int16_t		 holdtime;
	enum session_state	 state;
	time_t			 ConnectRetryTimer;
	time_t			 KeepaliveTimer;
	time_t			 HoldTimer;
	time_t			 StartTimer;
	u_int			 StartTimerInterval;
	int			 sock;
	int			 events;
	struct msgbuf		 wbuf;
	struct buf_read		*rbuf;
	struct peer		*next;
};

a217 5
/* session.c */
void		 session_socket_blockmode(int, enum blockmodes);
int		 session_main(struct bgpd_config *, struct peer *, int[2],
		    int[2]);

a231 2
void		 log_peer_err(const struct peer *, const char *, ...);
void		 log_peer_errx(const struct peer *, const char *, ...);
a235 5
void		 log_statechange(const struct peer *, enum session_state,
		    enum session_events);
void		 log_notification(const struct peer *, u_int8_t, u_int8_t,
		    u_char *, u_int16_t);
void		 log_conn_attempt(const struct peer *, struct in_addr);
a239 6
int	 parse_config(char *, struct bgpd_config *, struct mrt_config *,
	    struct peer **);

/* config.c */
int	 merge_config(struct bgpd_config *, struct bgpd_config *,
	    struct peer *);
a246 3

/* rde.c */
int	 rde_main(struct bgpd_config *, struct peer *, int[2], int[2]);
@


1.48
log
@send an imsg as list end indicator
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.47 2004/01/02 02:27:57 henning Exp $ */
a118 1
	struct peer		*peers;
d269 2
a270 1
int		 session_main(struct bgpd_config *, int[2], int[2]);
d301 2
a302 1
int	 parse_config(char *, struct bgpd_config *, struct mrt_config *);
d305 2
a306 1
int	 merge_config(struct bgpd_config *, struct bgpd_config *);
d316 1
a316 1
int	 rde_main(struct bgpd_config *, int[2], int[2]);
@


1.47
log
@move the socket name #define to bgpd.h and get rid of bgpdctl*
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.46 2004/01/01 23:46:47 henning Exp $ */
d221 2
a222 1
	IMSG_CTL_SHOW_NEIGHBOR
@


1.46
log
@listen on a AF_LOCAL socket for imsgs too.
only implemented type yet is IMSG_CTL_SHOW_NEIGHBOR which sends back
the struct peer for all neighbors.
will be used by bgpdctl
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.45 2004/01/01 23:09:08 henning Exp $ */
d48 2
@


1.45
log
@now that imsg_get uses bigger buffers, one read call can put more than one
imsg into the buffer. since imsg_get by definition only returns one imsg we
missed the next imsg(s) until the next poll event on the socket in question,
building up a queue on that socket. didn't show up as a problem yet...
factor out imsg_read, which reads into the buffer. imsg_get now entirely
operates on the buffers and does not read(2) itself.
make all callers cope by calling imsg_read on poll events and calling
imsg_get in a loop until all imsgs are processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.44 2003/12/28 14:34:30 henning Exp $ */
d26 1
d89 5
d218 2
a219 1
	IMSG_NEXTHOP_UPDATE
d266 1
d326 4
@


1.44
log
@redo the imsg readers to use bigger buffers and less read(2)s. should increase
performance even further.
gets rif od struct imsg_readbuf; rename peer_read_buf to read_buf as that
is more appropriate now.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.43 2003/12/27 14:24:42 henning Exp $ */
d297 1
@


1.43
log
@keep a copy of the fd locally instead of passing it around all time
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.42 2003/12/27 01:30:00 henning Exp $ */
d114 1
a114 1
struct peer_buf_read {
d146 1
a146 1
	struct peer_buf_read	*rbuf;
a189 10
struct imsg_readbuf {
	u_char			 buf[MAX_IMSGSIZE];
	ssize_t			 read_len;
	u_int32_t		 peerid;
	u_int16_t		 pkt_len;
	u_int8_t		 type;
	u_char			*wptr;
	u_int8_t		 seen_hdr;
};

d192 1
a192 1
	struct imsg_readbuf	r;
@


1.42
log
@provide kroute_fib_couple and _decouple, pumping all bgp routes from the
internal view to the kernel routing table respectively removing them all from
the kernel routing table
kroute_shutdown is now a simple wrapper to kroute_fib_decouple
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.41 2003/12/27 00:53:51 henning Exp $ */
d319 6
a324 6
int	kroute_change(int, struct kroute *);
int	kroute_delete(int, struct kroute *);
void	kroute_shutdown(int);
void	kroute_fib_couple(int);
void	kroute_fib_decouple(int);
int	kroute_dispatch_msg(int);
@


1.41
log
@implement "no fib-update" much cooler
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.40 2003/12/26 20:52:14 jakob Exp $ */
d322 2
@


1.40
log
@add option 'log updates' to log updates. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.39 2003/12/26 20:06:01 jakob Exp $ */
d318 1
a318 1
int	kroute_init(void);
@


1.39
log
@constify; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.38 2003/12/26 18:07:32 henning Exp $ */
d46 2
d109 1
@


1.38
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.37 2003/12/26 17:47:04 henning Exp $ */
d282 2
a283 2
void		 log_peer_err(struct peer *, const char *, ...);
void		 log_peer_errx(struct peer *, const char *, ...);
d288 1
a288 1
void		 log_statechange(struct peer *, enum session_state,
d290 1
a290 1
void		 log_notification(struct peer *, u_int8_t, u_int8_t,
d292 1
a292 1
void		 log_conn_attempt(struct peer *, struct in_addr);
@


1.37
log
@by making kroute_dispatch_msg() and kroute_nexthop_add() return int instead
of void they can now report errors upstream and do not need to panic any
more. so do that and handle the errors in bgpd.c in the vein that we at least
can clean up before exit.
there are no direct fatal() call in kroute.c now any more, nor any in bgpd.c
after forking.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.36 2003/12/26 16:48:07 henning Exp $ */
d285 2
a286 1
void		 fatal(const char *, int);
@


1.36
log
@provide a real log_err
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.35 2003/12/26 16:37:04 henning Exp $ */
d318 2
a319 2
void	kroute_dispatch_msg(int);
void	kroute_nexthop_add(in_addr_t);
@


1.35
log
@log_err -> log_peer_err
log_errx -> log_peer_errx

because that is what they really are, peer specific.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.34 2003/12/26 14:38:58 henning Exp $ */
d284 1
@


1.34
log
@log nexthop status changes
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.33 2003/12/26 14:27:58 henning Exp $ */
d282 2
a283 2
void		 log_err(struct peer *, const char *, ...);
void		 log_errx(struct peer *, const char *, ...);
@


1.33
log
@+ log_ntoa, a simple helper funtion that doesn't require a struct in_addr...
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.32 2003/12/26 14:26:02 henning Exp $ */
d291 1
a291 1
char 		*log_ntoa(in_addr_t);
@


1.32
log
@remove he pathetic log_kroute()
not used anywhere anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.31 2003/12/26 00:49:52 henning Exp $ */
d291 1
@


1.31
log
@handle IMSG_NEXTHOP_DELETE as well
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.30 2003/12/26 00:27:23 henning Exp $ */
a277 1

a290 1
void		 log_kroute(int, const char *, struct kroute *);
@


1.30
log
@kroute_nexthop_check -> kroute_nexthop_add
kroute_validate_nexthop -> kroute_nexthop_insert
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.29 2003/12/26 00:23:48 henning Exp $ */
d320 1
@


1.29
log
@kroute_validate_nexthop is a private function
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.28 2003/12/26 00:14:04 henning Exp $ */
d319 1
a319 1
void	kroute_nexthop_check(in_addr_t);
@


1.28
log
@finally marry rde and kroute parts of the nexthop verification:
handle IMSG_NEXTHOP_ADD and send IMSG_NEXTHOP_UPDATE when appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.27 2003/12/25 23:22:13 claudio Exp $ */
a318 1
void	kroute_validate_nexthop(in_addr_t, struct kroute_nexthop *);
@


1.27
log
@RDE part of the nexthop verification puzzle.
The RDE just tracks the nexthop IPs and reacts on nexthop messages
from the parent.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.26 2003/12/25 23:15:58 henning Exp $ */
d262 3
@


1.26
log
@bring us closer to a complete nexthop verification that does NOT need
periodic scans:
-keep a tree of nexthops with valid/invalid flags
-provide kroute_match, which takes an IP address and gives the kernel route
 for that
-find the kernel route for a given nexthop with that
-keep a marker on the kernel route that a nexthop depends on it
-on removal of the kernel route, re-evaluate the affected nexthops for
 validity.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.25 2003/12/25 17:07:24 henning Exp $ */
d216 4
a219 1
	IMSG_KROUTE_DELETE
@


1.25
log
@track routing table changes that are _not_ caused by bgpd itself

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.24 2003/12/25 14:28:49 henning Exp $ */
d251 7
d313 2
@


1.24
log
@implement "passive": do not attempt to open a tcp connection to the
neighbor system
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.23 2003/12/25 02:24:26 henning Exp $ */
d19 1
a19 1
#define __BGPD_H__
d31 1
a31 1
#define CONFFILE			"/etc/bgpd.conf"
d33 1
a33 1
#define PEER_DESCR_LEN			32
d38 1
d40 3
a42 3
#define BGPD_OPT_VERBOSE		0x0001
#define BGPD_OPT_VERBOSE2		0x0002
#define BGPD_OPT_NOACTION		0x0004
d44 1
a44 1
#define BGPD_FLAG_NO_FIB_UPDATE		0x0001
d147 1
a147 1
#define MRT_FILE_LEN	512
d185 1
a185 1
#define MAX_IMSGSIZE		8192
d305 1
@


1.23
log
@kill IMSG_KROUTE_ADD as well. just send KROUTE_CHANGE requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.22 2003/12/25 02:09:19 henning Exp $ */
d125 1
@


1.22
log
@it actually makes more sense to call the merged function kroute_change
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.21 2003/12/25 02:04:46 henning Exp $ */
a212 1
	IMSG_KROUTE_ADD,
@


1.21
log
@kroute_change is obsolete, long live kroute_add
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.20 2003/12/24 23:14:23 henning Exp $ */
d301 1
a301 1
int	kroute_add(int, struct kroute *);
@


1.20
log
@following up on a discussion with theo, read(2) as much as possible at once
and process the bgp messages after each other out of that big buffer.
gives a nice speedup, easier code and earlier connection close detection.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.19 2003/12/24 20:09:57 henning Exp $ */
a301 1
int	kroute_change(int, struct kroute *);
@


1.19
log
@now that the main process can cleanup without RDE's help, we do not need the
somewhat fragile IMSG_SHUTDOWN_* stuff any more. speeds shutdown up
enourmously.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.18 2003/12/24 19:59:24 henning Exp $ */
d37 1
d111 3
a113 6
	u_char			 buf[MAX_PKTSIZE];
	ssize_t			 read_len;
	u_int16_t		 pkt_len;
	u_int8_t		 type;
	u_char			*wptr;
	u_int8_t		 seen_hdr;
@


1.18
log
@now that we keep track of the routes we added to the kernel we can remove
them easily on shutdown without the RDE's help
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.17 2003/12/24 19:21:20 henning Exp $ */
d217 1
a217 3
	IMSG_KROUTE_DELETE,
	IMSG_SHUTDOWN_REQUEST,
	IMSG_SHUTDOWN_DONE
@


1.17
log
@add log_kroute()
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.16 2003/12/24 13:49:21 henning Exp $ */
d308 1
@


1.16
log
@add option to not touch the kernel routing table
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.15 2003/12/23 18:28:05 henning Exp $ */
d282 1
@


1.15
log
@send shutdown requests to the child processes and wait for a ackmessage from
them when shutting down.
the rde needs the main process to clean up the routing table on exit so the
parent process needs to be in service until the RDE is done.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.14 2003/12/23 01:06:21 henning Exp $ */
d42 2
d104 1
@


1.14
log
@allow the listening address to be specified, default to INADDR_ANY
should make jose@@ happy
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.13 2003/12/22 15:22:13 henning Exp $ */
d214 3
a216 1
	IMSG_KROUTE_DELETE
@


1.13
log
@o add low-level functions for adding/chaining/removing kernel routes
o define new imsg types for this
o process these imsgs in the parent process

now "only" debugging and the rde sending these messages is missing.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.12 2003/12/22 15:07:05 henning Exp $ */
d102 1
@


1.12
log
@add a configtest mode
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.11 2003/12/21 23:28:39 henning Exp $ */
d210 4
a213 1
	IMSG_MRT_END
d242 6
d295 6
@


1.11
log
@rename get_imsg() to imsg_get(); that's more consistent
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.10 2003/12/21 23:26:37 henning Exp $ */
d40 1
@


1.10
log
@wrap read & write buffers for imsgs into a struct.
finally gives us read buffers per pipe instead of per process, eleminating
a possible race.
also gets us a real imsg_init() that does all the boring init work
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.9 2003/12/21 22:16:53 henning Exp $ */
d276 1
a276 1
int	 get_imsg(struct imsgbuf *, struct imsg *);
@


1.9
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.7 2003/12/21 16:11:33 claudio Exp $ */
d182 1
a182 1
struct imsg_buf_read {
d192 6
d275 3
a277 3
void	 init_imsg_buf(void);
int	 get_imsg(int, struct imsg *);
int	 imsg_compose(struct msgbuf *, int, u_int32_t, void *, u_int16_t);
@


1.8
log
@queued_reads in struct peer was not ever used exept for an initialization to 0
@
text
@d81 14
d137 1
a137 2
	int			 queued_writes;
	int			 queued_imsg_writes;
d167 1
a167 1
	int			 fd;
a171 1
	int			 queued_writes;
a176 10
struct buf {
	TAILQ_ENTRY(buf)	 entries;
	struct peer		*peer;
	int			 sock;
	u_char			*buf;
	ssize_t			 size;
	ssize_t			 wpos;
	ssize_t			 rpos;
};

d237 1
a237 1
struct buf	*buf_open(struct peer *, int, ssize_t);
d240 6
a245 6
int		 buf_close(struct buf *);
int		 buf_write(struct buf *);
void		 buf_free(struct buf *buf);
void		 buf_peer_remove(struct peer *);
int		 buf_peer_write(struct peer *);
int		 buf_sock_write(int);
d271 1
a271 1
int	 imsg_compose(int, int, u_int32_t, void *, u_int16_t);
@


1.7
log
@yet more from the castathon; most aspath functions where accessing non-
aligned memory (u_int16_t) therefor crashed the RDE on my sparc64. All
buffer specific functions use now void * instead of u_char * so most cast
are now history. Tested on sparc64 and i386. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.6 2003/12/20 21:19:40 claudio Exp $ */
a123 1
	int			 queued_reads;
@


1.6
log
@more cast cleanup imsg_compose takes now a void * argument. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.5 2003/12/20 21:14:55 henning Exp $ */
d238 1
a238 1
u_char		*buf_reserve(struct buf *, ssize_t);
@


1.5
log
@let buf_add take void *data instead of u_char *data and save a zillion
evil casts
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.4 2003/12/20 20:25:20 henning Exp $ */
d270 1
a270 1
int	 imsg_compose(int, int, u_int32_t, u_char *, u_int16_t);
@


1.4
log
@make imsg.data void *, theo
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.3 2003/12/20 18:32:22 henning Exp $ */
d237 1
a237 1
int		 buf_add(struct buf *, u_char *, ssize_t);
@


1.3
log
@keep track which process we are so fatal() can log in which proc the
condition happened. fatal()s from subsystems used by all 3 processes like
the imsg subsystem were hard to track down without knowing in which process
the condition happened.
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.2 2003/12/20 14:33:09 henning Exp $ */
d213 1
a213 1
	u_char		*data;
@


1.2
log
@read(2)/write(2) return ssize_t, not size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: bgpd.h,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d40 6
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d86 1
a86 1
	size_t			 read_len;
d165 3
a167 3
	size_t			 size;
	size_t			 wpos;
	size_t			 rpos;
d177 1
a177 1
	size_t			 read_len;
d230 3
a232 3
struct buf	*buf_open(struct peer *, int, size_t);
int		 buf_add(struct buf *, u_char *, size_t);
u_char		*buf_reserve(struct buf *, size_t);
@

