head	1.160;
access;
symbols
	OPENBSD_6_0:1.149.0.6
	OPENBSD_6_0_BASE:1.149
	OPENBSD_5_9:1.149.0.2
	OPENBSD_5_9_BASE:1.149
	OPENBSD_5_8:1.148.0.4
	OPENBSD_5_8_BASE:1.148
	OPENBSD_5_7:1.147.0.2
	OPENBSD_5_7_BASE:1.147
	OPENBSD_5_6:1.147.0.6
	OPENBSD_5_6_BASE:1.147
	OPENBSD_5_5:1.147.0.4
	OPENBSD_5_5_BASE:1.147
	OPENBSD_5_4:1.146.0.2
	OPENBSD_5_4_BASE:1.146
	OPENBSD_5_3:1.145.0.2
	OPENBSD_5_3_BASE:1.145
	OPENBSD_5_2:1.142.0.4
	OPENBSD_5_2_BASE:1.142
	OPENBSD_5_1_BASE:1.142
	OPENBSD_5_1:1.142.0.2
	OPENBSD_5_0:1.138.0.4
	OPENBSD_5_0_BASE:1.138
	OPENBSD_4_9:1.138.0.2
	OPENBSD_4_9_BASE:1.138
	OPENBSD_4_8:1.137.0.2
	OPENBSD_4_8_BASE:1.137
	OPENBSD_4_7:1.131.0.2
	OPENBSD_4_7_BASE:1.131
	OPENBSD_4_6:1.120.0.4
	OPENBSD_4_6_BASE:1.120
	OPENBSD_4_5:1.104.0.2
	OPENBSD_4_5_BASE:1.104
	OPENBSD_4_4:1.102.0.4
	OPENBSD_4_4_BASE:1.102
	OPENBSD_4_3:1.102.0.2
	OPENBSD_4_3_BASE:1.102
	OPENBSD_4_2:1.100.0.2
	OPENBSD_4_2_BASE:1.100
	OPENBSD_4_1:1.97.0.2
	OPENBSD_4_1_BASE:1.97
	OPENBSD_4_0:1.95.0.2
	OPENBSD_4_0_BASE:1.95
	OPENBSD_3_9:1.89.0.2
	OPENBSD_3_9_BASE:1.89
	OPENBSD_3_8:1.70.0.2
	OPENBSD_3_8_BASE:1.70
	OPENBSD_3_7:1.63.0.2
	OPENBSD_3_7_BASE:1.63
	OPENBSD_3_6:1.55.0.2
	OPENBSD_3_6_BASE:1.55
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36;
locks; strict;
comment	@ * @;


1.160
date	2017.01.25.03.21.55;	author claudio;	state Exp;
branches;
next	1.159;
commitid	cao2hEetneZRFuIU;

1.159
date	2017.01.25.00.15.38;	author claudio;	state Exp;
branches;
next	1.158;
commitid	njwYsyFBZe4riTmC;

1.158
date	2017.01.24.23.38.12;	author claudio;	state Exp;
branches;
next	1.157;
commitid	o0u4P0zRnQoELo6o;

1.157
date	2017.01.23.22.53.52;	author claudio;	state Exp;
branches;
next	1.156;
commitid	GENNLgd0FzEuXHQN;

1.156
date	2017.01.23.22.47.59;	author claudio;	state Exp;
branches;
next	1.155;
commitid	pnGdVXq8GJLI0bC2;

1.155
date	2017.01.23.13.08.47;	author claudio;	state Exp;
branches;
next	1.154;
commitid	izU373N4GYVWJmcj;

1.154
date	2017.01.23.12.25.19;	author claudio;	state Exp;
branches;
next	1.153;
commitid	v3CPPZ2rgYxYsA45;

1.153
date	2017.01.23.11.46.02;	author claudio;	state Exp;
branches;
next	1.152;
commitid	K8zZdDB6ll7r7YIl;

1.152
date	2017.01.23.11.43.40;	author claudio;	state Exp;
branches;
next	1.151;
commitid	zHIgxV97QgdmH5L2;

1.151
date	2016.10.27.08.21.58;	author phessler;	state Exp;
branches;
next	1.150;
commitid	zdFHk6zNsrChhL9l;

1.150
date	2016.10.14.16.05.36;	author phessler;	state Exp;
branches;
next	1.149;
commitid	Ai7XVOgXw9ZLovz1;

1.149
date	2015.11.06.16.23.26;	author phessler;	state Exp;
branches;
next	1.148;
commitid	gwEx9C0BtWsMUbsG;

1.148
date	2015.03.14.03.52.42;	author claudio;	state Exp;
branches;
next	1.147;
commitid	1OLz8RQEaC2xclFf;

1.147
date	2013.08.14.20.34.26;	author claudio;	state Exp;
branches;
next	1.146;

1.146
date	2013.07.17.14.09.13;	author benno;	state Exp;
branches;
next	1.145;

1.145
date	2012.10.28.13.16.11;	author claudio;	state Exp;
branches;
next	1.144;

1.144
date	2012.09.12.05.56.22;	author claudio;	state Exp;
branches;
next	1.143;

1.143
date	2012.08.12.14.24.56;	author claudio;	state Exp;
branches;
next	1.142;

1.142
date	2011.09.21.08.59.01;	author claudio;	state Exp;
branches
	1.142.4.1;
next	1.141;

1.141
date	2011.09.20.21.19.06;	author claudio;	state Exp;
branches;
next	1.140;

1.140
date	2011.09.18.09.31.25;	author claudio;	state Exp;
branches;
next	1.139;

1.139
date	2011.09.17.16.29.44;	author claudio;	state Exp;
branches;
next	1.138;

1.138
date	2010.11.18.12.18.31;	author claudio;	state Exp;
branches;
next	1.137;

1.137
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.136;

1.136
date	2010.05.19.12.44.15;	author claudio;	state Exp;
branches;
next	1.135;

1.135
date	2010.05.17.16.08.20;	author claudio;	state Exp;
branches;
next	1.134;

1.134
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.133;

1.133
date	2010.03.29.09.24.07;	author claudio;	state Exp;
branches;
next	1.132;

1.132
date	2010.03.29.09.06.56;	author claudio;	state Exp;
branches;
next	1.131;

1.131
date	2010.03.05.15.25.00;	author claudio;	state Exp;
branches;
next	1.130;

1.130
date	2010.03.03.13.52.39;	author claudio;	state Exp;
branches;
next	1.129;

1.129
date	2010.01.13.06.02.37;	author claudio;	state Exp;
branches;
next	1.128;

1.128
date	2010.01.10.08.32.08;	author claudio;	state Exp;
branches;
next	1.127;

1.127
date	2010.01.10.00.15.09;	author claudio;	state Exp;
branches;
next	1.126;

1.126
date	2009.12.18.15.51.37;	author claudio;	state Exp;
branches;
next	1.125;

1.125
date	2009.12.16.15.40.55;	author claudio;	state Exp;
branches;
next	1.124;

1.124
date	2009.12.08.14.03.40;	author claudio;	state Exp;
branches;
next	1.123;

1.123
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.122;

1.122
date	2009.10.05.12.03.45;	author claudio;	state Exp;
branches;
next	1.121;

1.121
date	2009.08.06.08.53.11;	author claudio;	state Exp;
branches;
next	1.120;

1.120
date	2009.06.06.01.10.29;	author claudio;	state Exp;
branches;
next	1.119;

1.119
date	2009.06.06.01.07.01;	author claudio;	state Exp;
branches;
next	1.118;

1.118
date	2009.06.06.01.02.51;	author claudio;	state Exp;
branches;
next	1.117;

1.117
date	2009.06.04.21.53.43;	author claudio;	state Exp;
branches;
next	1.116;

1.116
date	2009.06.04.04.46.42;	author claudio;	state Exp;
branches;
next	1.115;

1.115
date	2009.06.03.20.17.59;	author claudio;	state Exp;
branches;
next	1.114;

1.114
date	2009.06.02.00.09.02;	author claudio;	state Exp;
branches;
next	1.113;

1.113
date	2009.06.01.23.54.50;	author claudio;	state Exp;
branches;
next	1.112;

1.112
date	2009.06.01.22.49.06;	author claudio;	state Exp;
branches;
next	1.111;

1.111
date	2009.06.01.21.20.17;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2009.05.27.06.58.15;	author claudio;	state Exp;
branches;
next	1.109;

1.109
date	2009.05.21.15.47.03;	author claudio;	state Exp;
branches;
next	1.108;

1.108
date	2009.05.17.14.45.25;	author claudio;	state Exp;
branches;
next	1.107;

1.107
date	2009.05.17.12.25.15;	author claudio;	state Exp;
branches;
next	1.106;

1.106
date	2009.04.23.19.23.27;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2009.03.19.06.52.59;	author claudio;	state Exp;
branches;
next	1.104;

1.104
date	2009.01.13.21.35.16;	author sthen;	state Exp;
branches;
next	1.103;

1.103
date	2008.11.21.17.41.22;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2008.01.23.08.11.32;	author claudio;	state Exp;
branches;
next	1.101;

1.101
date	2007.11.27.01.13.54;	author claudio;	state Exp;
branches;
next	1.100;

1.100
date	2007.06.01.04.17.30;	author claudio;	state Exp;
branches;
next	1.99;

1.99
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.98;

1.98
date	2007.04.06.18.03.51;	author claudio;	state Exp;
branches;
next	1.97;

1.97
date	2007.01.26.17.40.49;	author claudio;	state Exp;
branches;
next	1.96;

1.96
date	2006.11.10.14.47.32;	author henning;	state Exp;
branches;
next	1.95;

1.95
date	2006.05.28.23.24.15;	author claudio;	state Exp;
branches;
next	1.94;

1.94
date	2006.05.28.22.07.54;	author claudio;	state Exp;
branches;
next	1.93;

1.93
date	2006.04.12.14.05.46;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2006.04.05.13.24.29;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2006.04.04.12.03.26;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2006.03.22.10.18.49;	author claudio;	state Exp;
branches;
next	1.89;

1.89
date	2006.02.09.21.05.09;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2006.02.02.14.06.05;	author claudio;	state Exp;
branches;
next	1.87;

1.87
date	2006.01.24.14.14.04;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2006.01.24.13.34.33;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2006.01.20.16.40.17;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2006.01.20.16.06.12;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2006.01.14.22.39.49;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2006.01.12.14.05.13;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2006.01.10.16.11.12;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2006.01.05.16.00.07;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2006.01.03.22.49.17;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2006.01.03.22.19.59;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2005.12.30.17.20.21;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2005.12.30.16.40.15;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2005.12.30.14.07.40;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2005.11.29.21.11.07;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.02.13.19.30;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2005.11.01.15.21.54;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2005.11.01.14.37.16;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2005.08.10.08.34.06;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2005.07.29.12.38.40;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2005.07.01.12.10.21;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2005.07.01.09.19.24;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2005.06.29.09.43.26;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2005.06.10.09.58.09;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2005.04.12.14.32.00;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.11.12.54.20;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2004.12.23.15.08.43;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2004.11.23.13.07.01;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2004.11.11.13.06.45;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2004.11.11.10.35.15;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2004.11.10.12.41.58;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2004.09.28.15.48.52;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2004.09.28.12.09.31;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2004.08.13.14.03.20;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2004.08.12.10.24.16;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2004.08.10.13.02.08;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2004.08.10.12.57.18;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2004.08.06.12.04.08;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.05.20.56.12;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.05.18.44.19;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2004.08.05.15.58.21;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.30.14.44.30;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.28.16.02.14;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2004.07.13.17.57.20;	author jaredy;	state Exp;
branches;
next	1.44;

1.44
date	2004.07.05.16.54.53;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.24.23.15.58;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.22.20.28.58;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.21.15.36.40;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.17.12.39.32;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.07.10.06.15;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.10.17.27.28;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2004.03.11.17.12.51;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2004.03.11.14.22.23;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.05.22.21.32;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.01.16.02.01;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.27.20.53.56;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.26.16.16.41;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.26.14.00.33;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.19.23.07.00;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.18.23.18.16;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.18.16.36.09;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.16.13.21.46;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.16.12.58.45;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.16.12.53.15;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.09.01.56.18;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.02.18.06.32;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.17.19.35.36;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.13.16.08.04;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.13.13.45.50;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.13.13.34.56;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.13.13.18.03;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.12.13.33.16;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.11.21.47.20;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.11.20.13.00;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.10.22.25.42;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.10.16.20.29;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.06.10.51.14;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.30.13.03.27;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.26.22.41.01;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.26.21.30.20;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.25.23.22.13;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.23.15.59.02;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.21.16.11.34;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.19.01.15.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.18.22.22.22;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;

1.142.4.1
date	2012.11.29.20.06.16;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.160
log
@Hopefully the last of the struct rib rototilling. Peer just points to a
struct rib and not rib_desc since the full descriptor is almost never needed.
This should now allow the update code to be changed.
@
text
@/*	$OpenBSD: rde.h,v 1.159 2017/01/25 00:15:38 claudio Exp $ */

/*
 * Copyright (c) 2003, 2004 Claudio Jeker <claudio@@openbsd.org> and
 *                          Andre Oppermann <oppermann@@networx.ch>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifndef __RDE_H__
#define __RDE_H__

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <stdint.h>

#include "bgpd.h"

/* rde internal structures */

enum peer_state {
	PEER_NONE,
	PEER_DOWN,
	PEER_UP,
	PEER_ERR	/* error occurred going to PEER_DOWN state */
};

/*
 * How do we identify peers between the session handler and the rde?
 * Currently I assume that we can do that with the neighbor_ip...
 */
LIST_HEAD(rde_peer_head, rde_peer);
LIST_HEAD(aspath_head, rde_aspath);
RB_HEAD(uptree_prefix, update_prefix);
RB_HEAD(uptree_attr, update_attr);
struct rib_desc;
struct rib;
RB_HEAD(rib_tree, rib_entry);
TAILQ_HEAD(uplist_prefix, update_prefix);
TAILQ_HEAD(uplist_attr, update_attr);

struct rde_peer {
	LIST_ENTRY(rde_peer)		 hash_l; /* hash list over all peers */
	LIST_ENTRY(rde_peer)		 peer_l; /* list of all peers */
	struct aspath_head		 path_h; /* list of all as paths */
	struct peer_config		 conf;
	struct bgpd_addr		 remote_addr;
	struct bgpd_addr		 local_v4_addr;
	struct bgpd_addr		 local_v6_addr;
	struct uptree_prefix		 up_prefix;
	struct uptree_attr		 up_attrs;
	struct uplist_attr		 updates[AID_MAX];
	struct uplist_prefix		 withdraws[AID_MAX];
	struct capabilities		 capa;
	time_t				 staletime[AID_MAX];
	u_int64_t			 prefix_rcvd_update;
	u_int64_t			 prefix_rcvd_withdraw;
	u_int64_t			 prefix_rcvd_eor;
	u_int64_t			 prefix_sent_update;
	u_int64_t			 prefix_sent_withdraw;
	u_int64_t			 prefix_sent_eor;
	u_int32_t			 prefix_cnt; /* # of prefixes */
	u_int32_t			 remote_bgpid; /* host byte order! */
	u_int32_t			 up_pcnt;
	u_int32_t			 up_acnt;
	u_int32_t			 up_nlricnt;
	u_int32_t			 up_wcnt;
	enum peer_state			 state;
	struct rib			*rib;
	u_int16_t			 short_as;
	u_int16_t			 mrt_idx;
	u_int8_t			 reconf_out;	/* out filter changed */
	u_int8_t			 reconf_rib;	/* rib changed */
};

#define AS_SET			1
#define AS_SEQUENCE		2
#define AS_CONFED_SEQUENCE	3
#define AS_CONFED_SET		4
#define ASPATH_HEADER_SIZE	(sizeof(struct aspath) - sizeof(u_char))

LIST_HEAD(aspath_list, aspath);

struct aspath {
	LIST_ENTRY(aspath)	entry;
	int			refcnt;	/* reference count */
	u_int16_t		len;	/* total length of aspath in octets */
	u_int16_t		ascnt;	/* number of AS hops in data */
	u_char			data[1]; /* placeholder for actual data */
};

enum attrtypes {
	ATTR_UNDEF,
	ATTR_ORIGIN,
	ATTR_ASPATH,
	ATTR_NEXTHOP,
	ATTR_MED,
	ATTR_LOCALPREF,
	ATTR_ATOMIC_AGGREGATE,
	ATTR_AGGREGATOR,
	ATTR_COMMUNITIES,
	ATTR_ORIGINATOR_ID,
	ATTR_CLUSTER_LIST,
	ATTR_MP_REACH_NLRI=14,
	ATTR_MP_UNREACH_NLRI=15,
	ATTR_EXT_COMMUNITIES=16,
	ATTR_AS4_PATH=17,
	ATTR_AS4_AGGREGATOR=18,
	ATTR_LARGE_COMMUNITIES=32,
};

/* attribute flags. 4 low order bits reserved */
#define	ATTR_EXTLEN		0x10
#define ATTR_PARTIAL		0x20
#define ATTR_TRANSITIVE		0x40
#define ATTR_OPTIONAL		0x80
#define ATTR_RESERVED		0x0f
/* by default mask the reserved bits and the ext len bit */
#define ATTR_DEFMASK		(ATTR_RESERVED | ATTR_EXTLEN)

/* default attribute flags for well known attributes */
#define ATTR_WELL_KNOWN		ATTR_TRANSITIVE

struct attr {
	LIST_ENTRY(attr)		 entry;
	u_char				*data;
	int				 refcnt;
	u_int32_t			 hash;
	u_int16_t			 len;
	u_int8_t			 flags;
	u_int8_t			 type;
};

struct mpattr {
	void		*reach;
	void		*unreach;
	u_int16_t	 reach_len;
	u_int16_t	 unreach_len;
};

LIST_HEAD(attr_list, attr);

struct path_table {
	struct aspath_head	*path_hashtbl;
	u_int32_t		 path_hashmask;
};

LIST_HEAD(prefix_head, prefix);

#define	F_ATTR_ORIGIN		0x00001
#define	F_ATTR_ASPATH		0x00002
#define	F_ATTR_NEXTHOP		0x00004
#define	F_ATTR_LOCALPREF	0x00008
#define	F_ATTR_MED		0x00010
#define	F_ATTR_MED_ANNOUNCE	0x00020
#define	F_ATTR_MP_REACH		0x00040
#define	F_ATTR_MP_UNREACH	0x00080
#define	F_ATTR_AS4BYTE_NEW	0x00100	/* AS4_PATH or AS4_AGGREGATOR */
#define	F_ATTR_LOOP		0x00200 /* path would cause a route loop */
#define	F_PREFIX_ANNOUNCED	0x00400
#define	F_ANN_DYNAMIC		0x00800
#define	F_NEXTHOP_SELF		0x01000
#define	F_NEXTHOP_REJECT	0x02000
#define	F_NEXTHOP_BLACKHOLE	0x04000
#define	F_NEXTHOP_NOMODIFY	0x08000
#define	F_NEXTHOP_MASK		0x0f000
#define	F_ATTR_PARSE_ERR	0x10000
#define	F_ATTR_LINKED		0x20000


#define ORIGIN_IGP		0
#define ORIGIN_EGP		1
#define ORIGIN_INCOMPLETE	2

#define DEFAULT_LPREF		100

struct rde_aspath {
	LIST_ENTRY(rde_aspath)		 path_l, peer_l, nexthop_l;
	struct prefix_head		 prefix_h;
	struct attr			**others;
	struct rde_peer			*peer;
	struct aspath			*aspath;
	struct nexthop			*nexthop;	/* may be NULL */
	u_int32_t			 med;		/* multi exit disc */
	u_int32_t			 lpref;		/* local pref */
	u_int32_t			 weight;	/* low prio lpref */
	u_int32_t			 prefix_cnt; /* # of prefixes */
	u_int32_t			 active_cnt; /* # of active prefixes */
	u_int32_t			 flags;		/* internally used */
	u_int16_t			 rtlabelid;	/* route label id */
	u_int16_t			 pftableid;	/* pf table id */
	u_int8_t			 origin;
	u_int8_t			 others_len;
};

enum nexthop_state {
	NEXTHOP_LOOKUP,
	NEXTHOP_UNREACH,
	NEXTHOP_REACH
};

struct nexthop {
	LIST_ENTRY(nexthop)	nexthop_l;
	struct aspath_head	path_h;
	struct bgpd_addr	exit_nexthop;
	struct bgpd_addr	true_nexthop;
	struct bgpd_addr	nexthop_net;
#if 0
	/*
	 * currently we use the boolean nexthop state, this could be exchanged
	 * with a variable cost with a max for unreachable.
	 */
	u_int32_t		costs;
#endif
	int			refcnt;	/* filterset reference counter */
	enum nexthop_state	state;
	u_int8_t		nexthop_netlen;
	u_int8_t		flags;
#define NEXTHOP_CONNECTED	0x01
};

/* generic entry without address specific part */
struct pt_entry {
	RB_ENTRY(pt_entry)		 pt_e;
	u_int8_t			 aid;
	u_int8_t			 prefixlen;
	u_int16_t			 refcnt;
};

struct pt_entry4 {
	RB_ENTRY(pt_entry)		 pt_e;
	u_int8_t			 aid;
	u_int8_t			 prefixlen;
	u_int16_t			 refcnt;
	struct in_addr			 prefix4;
};

struct pt_entry6 {
	RB_ENTRY(pt_entry)		 pt_e;
	u_int8_t			 aid;
	u_int8_t			 prefixlen;
	u_int16_t			 refcnt;
	struct in6_addr			 prefix6;
};

struct pt_entry_vpn4 {
	RB_ENTRY(pt_entry)		 pt_e;
	u_int8_t			 aid;
	u_int8_t			 prefixlen;
	u_int16_t			 refcnt;
	struct in_addr			 prefix4;
	u_int64_t			 rd;
	u_int8_t			 labelstack[21];
	u_int8_t			 labellen;
	u_int8_t			 pad1;
	u_int8_t			 pad2;
};

struct rib_context {
	LIST_ENTRY(rib_context)		 entry;
	struct rib_entry		*ctx_re;
	struct rib			*ctx_rib;
	void		(*ctx_upcall)(struct rib_entry *, void *);
	void		(*ctx_done)(void *);
	void		(*ctx_wait)(void *);
	void				*ctx_arg;
	unsigned int			 ctx_count;
	u_int8_t			 ctx_aid;
};

struct rib_entry {
	RB_ENTRY(rib_entry)	 rib_e;
	struct prefix_head	 prefix_h;
	struct prefix		*active;	/* for fast access */
	struct pt_entry		*prefix;
	struct rib		*__rib;		/* mangled pointer with flags */
};

struct rib {
	struct rib_tree		tree;
	u_int			rtableid;
	u_int16_t		flags;
	u_int16_t		id;
};

struct rib_desc {
	char			name[PEER_DESCR_LEN];
	struct rib		rib;
	struct filter_head	*in_rules;
	struct filter_head	*in_rules_tmp;
	enum reconf_action 	state;
};

struct prefix {
	LIST_ENTRY(prefix)		 rib_l, path_l;
	struct rde_aspath		*aspath;
	struct pt_entry			*prefix;
	struct rib_entry		*re;
	time_t				 lastchange;
};

extern struct rde_memstats rdemem;

/* prototypes */
/* mrt.c */
int		mrt_dump_v2_hdr(struct mrt *, struct bgpd_config *,
		    struct rde_peer_head *);
void		mrt_dump_upcall(struct rib_entry *, void *);
void		mrt_done(void *);

/* rde.c */
void		rde_send_kroute(struct rib *, struct prefix *, struct prefix *);
void		rde_send_nexthop(struct bgpd_addr *, int);
void		rde_send_pftable(u_int16_t, struct bgpd_addr *,
		    u_int8_t, int);
void		rde_send_pftable_commit(void);

void		rde_generate_updates(struct rib *, struct prefix *,
		    struct prefix *);
u_int32_t	rde_local_as(void);
int		rde_noevaluate(void);
int		rde_decisionflags(void);
int		rde_as4byte(struct rde_peer *);

/* rde_attr.c */
int		 attr_write(void *, u_int16_t, u_int8_t, u_int8_t, void *,
		     u_int16_t);
int		 attr_writebuf(struct ibuf *, u_int8_t, u_int8_t, void *,
		     u_int16_t);
void		 attr_init(u_int32_t);
void		 attr_shutdown(void);
int		 attr_optadd(struct rde_aspath *, u_int8_t, u_int8_t,
		     void *, u_int16_t);
struct attr	*attr_optget(const struct rde_aspath *, u_int8_t);
void		 attr_copy(struct rde_aspath *, struct rde_aspath *);
int		 attr_compare(struct rde_aspath *, struct rde_aspath *);
void		 attr_freeall(struct rde_aspath *);
void		 attr_free(struct rde_aspath *, struct attr *);
#define		 attr_optlen(x)	\
    ((x)->len > 255 ? (x)->len + 4 : (x)->len + 3)

int		 aspath_verify(void *, u_int16_t, int);
#define		 AS_ERR_LEN	-1
#define		 AS_ERR_TYPE	-2
#define		 AS_ERR_BAD	-3
#define		 AS_ERR_SOFT	-4
void		 aspath_init(u_int32_t);
void		 aspath_shutdown(void);
struct aspath	*aspath_get(void *, u_int16_t);
void		 aspath_put(struct aspath *);
u_char		*aspath_inflate(void *, u_int16_t, u_int16_t *);
u_char		*aspath_deflate(u_char *, u_int16_t *, int *);
void		 aspath_merge(struct rde_aspath *, struct attr *);
u_char		*aspath_dump(struct aspath *);
u_int16_t	 aspath_length(struct aspath *);
u_int16_t	 aspath_count(const void *, u_int16_t);
u_int32_t	 aspath_neighbor(struct aspath *);
int		 aspath_loopfree(struct aspath *, u_int32_t);
int		 aspath_compare(struct aspath *, struct aspath *);
u_char		*aspath_prepend(struct aspath *, u_int32_t, int, u_int16_t *);
int		 aspath_lenmatch(struct aspath *, enum aslen_spec, u_int);
int		 community_match(struct rde_aspath *, int, int);
int		 community_set(struct rde_aspath *, int, int);
void		 community_delete(struct rde_aspath *, int, int);
int		 community_large_match(struct rde_aspath *, int64_t, int64_t,
		    int64_t);
int		 community_large_set(struct rde_aspath *, int64_t, int64_t,
		    int64_t);
void		 community_large_delete(struct rde_aspath *, int64_t,
		    int64_t, int64_t);
int		 community_ext_match(struct rde_aspath *,
		    struct filter_extcommunity *, u_int16_t);
int		 community_ext_set(struct rde_aspath *,
		    struct filter_extcommunity *, u_int16_t);
void		 community_ext_delete(struct rde_aspath *,
		    struct filter_extcommunity *, u_int16_t);
int		 community_ext_conv(struct filter_extcommunity *, u_int16_t,
		    u_int64_t *);

/* rde_decide.c */
void		 prefix_evaluate(struct prefix *, struct rib_entry *);

/* rde_filter.c */
enum filter_actions rde_filter(struct filter_head *, struct rde_aspath **,
		     struct rde_peer *, struct rde_aspath *,
		     struct bgpd_addr *, u_int8_t, struct rde_peer *);
void		 rde_apply_set(struct rde_aspath *, struct filter_set_head *,
		     u_int8_t, struct rde_peer *, struct rde_peer *);
int		 rde_filter_equal(struct filter_head *, struct filter_head *,
		     struct rde_peer *);
void		 rde_filter_calc_skip_steps(struct filter_head *);

/* rde_prefix.c */
#define pt_empty(pt)	((pt)->refcnt == 0)
#define pt_ref(pt)	do {				\
	++(pt)->refcnt;					\
	if ((pt)->refcnt == 0)				\
		fatalx("pt_ref: overflow");		\
} while(0)
#define pt_unref(pt)	do {				\
	if ((pt)->refcnt == 0)				\
		fatalx("pt_unref: underflow");		\
	--(pt)->refcnt;					\
} while(0)

void	 pt_init(void);
void	 pt_shutdown(void);
void	 pt_getaddr(struct pt_entry *, struct bgpd_addr *);
struct pt_entry	*pt_fill(struct bgpd_addr *, int);
struct pt_entry	*pt_get(struct bgpd_addr *, int);
struct pt_entry *pt_add(struct bgpd_addr *, int);
void	 pt_remove(struct pt_entry *);
struct pt_entry	*pt_lookup(struct bgpd_addr *);
int	 pt_prefix_cmp(const struct pt_entry *, const struct pt_entry *);

/* rde_rib.c */
extern u_int16_t	 rib_size;
extern struct rib_desc	*ribs;

struct rib	*rib_new(char *, u_int, u_int16_t);
struct rib	*rib_find(char *);
struct rib_desc	*rib_desc(struct rib *);
void		 rib_free(struct rib *);
struct rib_entry *rib_get(struct rib *, struct bgpd_addr *, int);
struct rib_entry *rib_lookup(struct rib *, struct bgpd_addr *);
void		 rib_dump(struct rib *, void (*)(struct rib_entry *, void *),
		     void *, u_int8_t);
void		 rib_dump_r(struct rib_context *);
void		 rib_dump_runner(void);
int		 rib_dump_pending(void);

static inline struct rib *
re_rib(struct rib_entry *re)
{
	return (struct rib *)((intptr_t)re->__rib & ~1);
}

void		 path_init(u_int32_t);
void		 path_init(u_int32_t);
void		 path_shutdown(void);
int		 path_update(struct rib *, struct rde_peer *,
		     struct rde_aspath *, struct bgpd_addr *, int);
int		 path_compare(struct rde_aspath *, struct rde_aspath *);
struct rde_aspath *path_lookup(struct rde_aspath *, struct rde_peer *);
void		 path_remove(struct rde_aspath *);
u_int32_t	 path_remove_stale(struct rde_aspath *, u_int8_t);
void		 path_destroy(struct rde_aspath *);
int		 path_empty(struct rde_aspath *);
struct rde_aspath *path_copy(struct rde_aspath *);
struct rde_aspath *path_get(void);
void		 path_put(struct rde_aspath *);

#define	PREFIX_SIZE(x)	(((x) + 7) / 8 + 1)
struct prefix	*prefix_get(struct rib *, struct rde_peer *,
		    struct bgpd_addr *, int, u_int32_t);
int		 prefix_add(struct rib *, struct rde_aspath *,
		    struct bgpd_addr *, int);
void		 prefix_move(struct rde_aspath *, struct prefix *);
int		 prefix_remove(struct rib *, struct rde_peer *,
		    struct bgpd_addr *, int, u_int32_t);
int		 prefix_write(u_char *, int, struct bgpd_addr *, u_int8_t);
int		 prefix_writebuf(struct ibuf *, struct bgpd_addr *, u_int8_t);
struct prefix	*prefix_bypeer(struct rib_entry *, struct rde_peer *,
		     u_int32_t);
void		 prefix_updateall(struct rde_aspath *, enum nexthop_state,
		     enum nexthop_state);
void		 prefix_destroy(struct prefix *);
void		 prefix_network_clean(struct rde_peer *, time_t, u_int32_t);

void		 nexthop_init(u_int32_t);
void		 nexthop_shutdown(void);
void		 nexthop_modify(struct rde_aspath *, struct bgpd_addr *,
		     enum action_types, u_int8_t);
void		 nexthop_link(struct rde_aspath *);
void		 nexthop_unlink(struct rde_aspath *);
int		 nexthop_delete(struct nexthop *);
void		 nexthop_update(struct kroute_nexthop *);
struct nexthop	*nexthop_get(struct bgpd_addr *);
int		 nexthop_compare(struct nexthop *, struct nexthop *);

/* rde_update.c */
void		 up_init(struct rde_peer *);
void		 up_down(struct rde_peer *);
int		 up_test_update(struct rde_peer *, struct prefix *);
int		 up_generate(struct rde_peer *, struct rde_aspath *,
		     struct bgpd_addr *, u_int8_t);
void		 up_generate_updates(struct filter_head *, struct rde_peer *,
		     struct prefix *, struct prefix *);
void		 up_generate_default(struct filter_head *, struct rde_peer *,
		     u_int8_t);
int		 up_generate_marker(struct rde_peer *, u_int8_t);
int		 up_dump_prefix(u_char *, int, struct uplist_prefix *,
		     struct rde_peer *);
int		 up_dump_attrnlri(u_char *, int, struct rde_peer *);
u_char		*up_dump_mp_unreach(u_char *, u_int16_t *, struct rde_peer *,
		     u_int8_t);
int		 up_dump_mp_reach(u_char *, u_int16_t *, struct rde_peer *,
		     u_int8_t);

#endif /* __RDE_H__ */
@


1.159
log
@Switch rde_generate_update and rde_send_kroute to accept a struct rib instead
of the id. For this we move the rtableid into struct rib. Also move the update
code in rib.c up to where the kroute code is. Makes more senses like that.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.158 2017/01/24 23:38:12 claudio Exp $ */
d79 1
a79 1
	struct rib_desc			*rib;
d430 4
a433 3
struct rib_desc	 *rib_new(char *, u_int, u_int16_t);
struct rib_desc	 *rib_find(char *);
void		 rib_free(struct rib_desc *);
@


1.158
log
@Save some space in struct rib_entry so it is back to 64bytes (on 64bit archs).
Doing this by folding the lock flag into a pointer and providing an accessor
function for the rib pointer. This is an acceptable middle path for this
important structure.
OK benno@@ on an earlier version
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.157 2017/01/23 22:53:52 claudio Exp $ */
d291 1
a300 1
	u_int			rtableid;
d316 1
a316 1
int		 mrt_dump_v2_hdr(struct mrt *, struct bgpd_config *,
d318 2
a319 2
void		 mrt_dump_upcall(struct rib_entry *, void *);
void		 mrt_done(void *);
d322 12
a333 12
void		 rde_send_kroute(struct prefix *, struct prefix *, u_int16_t);
void		 rde_send_nexthop(struct bgpd_addr *, int);
void		 rde_send_pftable(u_int16_t, struct bgpd_addr *,
		     u_int8_t, int);
void		 rde_send_pftable_commit(void);

void		 rde_generate_updates(u_int16_t, struct prefix *,
		     struct prefix *);
u_int32_t	 rde_local_as(void);
int		 rde_noevaluate(void);
int		 rde_decisionflags(void);
int		 rde_as4byte(struct rde_peer *);
@


1.157
log
@Rename rib pointer in struct prefix to re since it points to a rib_entry.
While there also remove a comment that is since a few years at least.
OK gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.156 2017/01/23 22:47:59 claudio Exp $ */
d25 1
d284 1
a284 1
	struct prefix		*active; /* for fast access */
d286 1
a286 2
	struct rib		*rib;
	u_int16_t		 flags;
d441 7
@


1.156
log
@Introduce a struct rib sitting between struct rib_desc and struct rib_tree.
This way the tree becomes a bit better decoupled.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.155 2017/01/23 13:08:47 claudio Exp $ */
d308 1
a308 1
	struct rib_entry		*rib;	/* NULL for Adj-RIB-In */
@


1.155
log
@Revert the struct rib_tree rename. I need a struct in between because of
how struct rib_entry is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.154 2017/01/23 12:25:19 claudio Exp $ */
a40 1
struct rib_desc;
d45 2
d271 1
a271 1
	struct rib_desc			*ctx_rib;
d285 1
a285 1
	u_int16_t		 ribid;
d289 6
d297 1
a297 1
	struct rib_tree		rib;
a300 2
	u_int16_t		flags;
	u_int16_t		id;
d433 3
a435 3
struct rib_entry *rib_get(struct rib_desc *, struct bgpd_addr *, int);
struct rib_entry *rib_lookup(struct rib_desc *, struct bgpd_addr *);
void		 rib_dump(struct rib_desc *, void (*)(struct rib_entry *, void *),
d443 1
a443 1
int		 path_update(struct rib_desc *, struct rde_peer *,
d456 1
a456 1
struct prefix	*prefix_get(struct rib_desc *, struct rde_peer *,
d458 1
a458 1
int		 prefix_add(struct rib_desc *, struct rde_aspath *,
d461 1
a461 1
int		 prefix_remove(struct rib_desc *, struct rde_peer *,
@


1.154
log
@More rototilling, make rib_new and rib_find return a point to struct rib_desc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.153 2017/01/23 11:46:02 claudio Exp $ */
d46 1
a46 1
RB_HEAD(rib, rib_entry);
d290 1
a290 1
	struct rib		rib;
@


1.153
log
@Now rename struct rib_tree to struct rib. Again OK gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.152 2017/01/23 11:43:40 claudio Exp $ */
d41 1
d77 1
a77 1
	u_int16_t			 ribid;
a298 2
#define RIB_FAILED		0xffff

d425 2
a426 2
u_int16_t	 rib_new(char *, u_int, u_int16_t);
u_int16_t	 rib_find(char *);
@


1.152
log
@Rename struct rib to struct rib_desc. Mechanical change, OK gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.151 2016/10/27 08:21:58 phessler Exp $ */
d45 1
a45 1
RB_HEAD(rib_tree, rib_entry);
d289 1
a289 1
	struct rib_tree		rib;
@


1.151
log
@Huawei squatted on BGP Path Attribute 30, and Cisco squatted on 31.  So,
IANA moved the Large Communities attribute to 32, which is a nice pun on
the problem it is solving.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.150 2016/10/14 16:05:36 phessler Exp $ */
d269 1
a269 1
	struct rib			*ctx_rib;
d287 1
a287 1
struct rib {
d424 1
a424 1
extern struct rib	*ribs;
d428 4
a431 4
void		 rib_free(struct rib *);
struct rib_entry *rib_get(struct rib *, struct bgpd_addr *, int);
struct rib_entry *rib_lookup(struct rib *, struct bgpd_addr *);
void		 rib_dump(struct rib *, void (*)(struct rib_entry *, void *),
d439 1
a439 1
int		 path_update(struct rib *, struct rde_peer *,
d452 1
a452 1
struct prefix	*prefix_get(struct rib *, struct rde_peer *,
d454 1
a454 1
int		 prefix_add(struct rib *, struct rde_aspath *,
d457 1
a457 1
int		 prefix_remove(struct rib *, struct rde_peer *,
@


1.150
log
@Add support for draft-ietf-idr-large-community

Joint work with Job Snijders, many thanks!
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.149 2015/11/06 16:23:26 phessler Exp $ */
d116 1
a116 1
	ATTR_LARGE_COMMUNITIES=30,
@


1.149
log
@Radically improve the performance of bgpd filters.  Based on PF's skip
steps (and uses much of the same code).

In a torture test of ~600k prefix filters and 65k prefixes, convergance
time goes from 35 minutes to 30 seconds.

Many thanks to LONAP for providing a base configuration for torture
testing.

many discussions with claudio@@, benno@@, sthen@@ and the rest of the bgpd crowd

OK sthen@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.148 2015/03/14 03:52:42 claudio Exp $ */
d115 2
a116 1
	ATTR_AS4_AGGREGATOR=18
d371 6
@


1.148
log
@rename rde_free_filter() to filterlist_free() and start using it outside
of the RDE to free the filterlists. Also refactor common code to merge
filterlists into its own function. Makes the code look nicer.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.147 2013/08/14 20:34:26 claudio Exp $ */
d390 1
@


1.147
log
@Rewrite the internals of the RDE reload logic.
This is the first step to make bgpd reload non blocking in the RDE.
It also speeds up the reload time a fair bit in some cases (mainly if
you run with multiple RIBs and have larger filtersets) and it should also
fix a few edge cases on reloads.
Testing done by benno@@, florian@@ and sthen@@ OK henning@@ and benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.146 2013/07/17 14:09:13 benno Exp $ */
a328 1
void		 rde_free_filter(struct filter_head *);
@


1.146
log
@on graceful restart, the number of prefixes could be counted wrong,
triping max-prefix.  fix it this way, at least until prefix accounting
is done better.
diff from florian@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.145 2012/10/28 13:16:11 claudio Exp $ */
a78 1
	u_int8_t			 reconf_in;	/* in filter changed */
d289 2
d329 1
d384 3
a386 4
enum filter_actions rde_filter(u_int16_t, struct rde_aspath **,
		     struct filter_head *, struct rde_peer *,
		     struct rde_aspath *, struct bgpd_addr *, u_int8_t,
		     struct rde_peer *, enum directions);
d390 1
a390 1
		     struct rde_peer *, enum directions);
@


1.145
log
@Change email address in copyright to one that is valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.144 2012/09/12 05:56:22 claudio Exp $ */
d436 1
a436 1
void		 path_remove_stale(struct rde_aspath *, u_int8_t);
@


1.144
log
@Better graceful restart support (implementing more then just the EoR record).
This implements only the "Restarting Client" bits of the RFC -- in other
words bgpd will keep the FIB when the client restarts but it will not do GR
when restarting itself. The capability is still off by default (you need
"announce restart yes" to enable it).
Tested by Anders Berggren. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.143 2012/08/12 14:24:56 claudio Exp $ */
d5 1
a5 1
 *                          Andre Oppermann <oppermann@@pipeline.ch>
@


1.143
log
@By default mask the reserved bits and the ext len bit in the attribute
flags field. Some systems seem to start sending bad flags around which
cause session failures in bgpd. Make sure that bgpd ignores the must be
zero flags correctly and ensure that they are always reset to zero when
sending updates out.
Reported and patch tested by Laurent CARON, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.142 2011/09/21 08:59:01 claudio Exp $ */
d62 1
d65 1
d68 1
d436 1
@


1.142
log
@Fix nexthop_modify() to reset the flags when called. Until now
set nexthop-self was sticky and so later set nexthop <IP> were
not applied.
Problem found and fix tested by Tony Sarendal. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.141 2011/09/20 21:19:06 claudio Exp $ */
d121 3
@


1.142.4.1
log
@MFC fix for interoperability problem with some newer Junipers which don't
clear reserved bits:

-- -- --
By default mask the reserved bits and the ext len bit in the attribute
flags field. Some systems seem to start sending bad flags around which
cause session failures in bgpd. Make sure that bgpd ignores the must be
zero flags correctly and ensure that they are always reset to zero when
sending updates out.
Reported and patch tested by Laurent CARON, OK henning@@

Members:
        rde.c:1.316->1.317
        rde.h:1.142->1.143
        rde_attr.c:1.90->1.91
-- -- --
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.143 2012/08/12 14:24:56 claudio Exp $ */
a120 3
#define ATTR_RESERVED		0x0f
/* by default mask the reserved bits and the ext len bit */
#define ATTR_DEFMASK		(ATTR_RESERVED | ATTR_EXTLEN)
@


1.141
log
@Move a few functions into util.c because bgpctl will need them soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.140 2011/09/18 09:31:25 claudio Exp $ */
d167 1
@


1.140
log
@Reorder the headerfiles a bit. Move the bgpd specific prototypes out of
mrt.h. Now mrt.h includes only protocol specific defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.139 2011/09/17 16:29:44 claudio Exp $ */
a357 1
int		 aspath_match(struct aspath *, enum as_spec, u_int32_t);
a435 2
int		 prefix_compare(const struct bgpd_addr *,
		    const struct bgpd_addr *, int);
a480 3

/* util.c */
u_int32_t	 aspath_extract(const void *, int);
@


1.139
log
@Implement new mrt table dump format as specified in draft-ietf-grow-mrt.
Tested with IP and IPv6 sessions and against the libbgpdump parser.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.138 2010/11/18 12:18:31 claudio Exp $ */
d302 6
d372 36
a465 3
/* rde_decide.c */
void		 prefix_evaluate(struct prefix *, struct rib_entry *);

a483 34

/* rde_prefix.c */
#define pt_empty(pt)	((pt)->refcnt == 0)
#define pt_ref(pt)	do {				\
	++(pt)->refcnt;					\
	if ((pt)->refcnt == 0)				\
		fatalx("pt_ref: overflow");		\
} while(0)
#define pt_unref(pt)	do {				\
	if ((pt)->refcnt == 0)				\
		fatalx("pt_unref: underflow");		\
	--(pt)->refcnt;					\
} while(0)

void	 pt_init(void);
void	 pt_shutdown(void);
void	 pt_getaddr(struct pt_entry *, struct bgpd_addr *);
struct pt_entry	*pt_fill(struct bgpd_addr *, int);
struct pt_entry	*pt_get(struct bgpd_addr *, int);
struct pt_entry *pt_add(struct bgpd_addr *, int);
void	 pt_remove(struct pt_entry *);
struct pt_entry	*pt_lookup(struct bgpd_addr *);
int	 pt_prefix_cmp(const struct pt_entry *, const struct pt_entry *);


/* rde_filter.c */
enum filter_actions rde_filter(u_int16_t, struct rde_aspath **,
		     struct filter_head *, struct rde_peer *,
		     struct rde_aspath *, struct bgpd_addr *, u_int8_t,
		     struct rde_peer *, enum directions);
void		 rde_apply_set(struct rde_aspath *, struct filter_set_head *,
		     u_int8_t, struct rde_peer *, struct rde_peer *);
int		 rde_filter_equal(struct filter_head *, struct filter_head *,
		     struct rde_peer *, enum directions);
@


1.138
log
@Accept but ignore (treat as withdraw) updates with AS_CONFED_* path
segments. Bgpd does not support confederations but it is too extreme
to close a session because a path contained such elements.
OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.137 2010/05/26 13:56:07 nicm Exp $ */
d75 1
d405 1
@


1.137
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.136 2010/05/19 12:44:15 claudio Exp $ */
d82 2
d336 1
@


1.136
log
@Add softreconfig support for peers changing the RIB. Done by first unloading
the old RIB and then via softreconfig in and a special softreconfig out loading
the new RIB.
Feature requested and testeded by Elisa Jasinska.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.135 2010/05/17 16:08:20 claudio Exp $ */
d316 1
a316 1
int		 attr_writebuf(struct buf *, u_int8_t, u_int8_t, void *,
@


1.135
log
@Implement two new filters, max-as-len and max-as-seq. The first is limiting
the length of an AS path (matches if the path is longer then the specified
lenght) the second matches when a sequence of the same AS number is longer
then the specified length).
max-as-len is good to protect crappy comercial bgp boxes from other crappy
comercial bgp boxes. max-as-seq was a feature request from SwissIX and maybe
EuroIX to find and filter prepends.
Additinal testing and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.134 2010/05/03 13:09:38 claudio Exp $ */
d77 1
@


1.134
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.133 2010/03/29 09:24:07 claudio Exp $ */
d348 1
@


1.133
log
@I'm going to need community_ext_conv() outside of rde_attr.c soon, so move
the prototype to rde.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.132 2010/03/29 09:06:56 claudio Exp $ */
d279 1
a279 1
	enum reconf_action 	state;
d282 1
a284 3
#define F_RIB_ENTRYLOCK		0x0001
#define F_RIB_NOEVALUATE	0x0002
#define F_RIB_NOFIB		0x0004
d299 1
a299 1
void		 rde_send_kroute(struct prefix *, struct prefix *);
d364 1
a364 1
u_int16_t	 rib_new(char *, u_int16_t);
@


1.132
log
@We always allocate rib ids dynamicaly so there is no need for allowing
fixed id allocation. Makes code simpler.
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.131 2010/03/05 15:25:00 claudio Exp $ */
d359 2
@


1.131
log
@Allow to filter for ext-community attributes. Currently only perfect matches
work but that's already better then nothing. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.130 2010/03/03 13:52:39 claudio Exp $ */
d364 1
a364 1
u_int16_t	 rib_new(int, char *, u_int16_t);
@


1.130
log
@Replace enum rib_state with enum reconf_action since their doing the same.
NEW is now REINIT, ACTIVE is KEEP and DELETE and NONE stay the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.129 2010/01/13 06:02:37 claudio Exp $ */
d353 2
@


1.129
log
@Add support for BGP MPLS VPN aka RFC 4364. This is only the RDE part so
that it is possible to use OpenBGPD as a route-reflector for VPNv4.
Some clean up of the BGP MP code so that multiple protocols are easier
supported. kroute/kernel support not yet done but comming.
OK henning@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.128 2010/01/10 08:32:08 claudio Exp $ */
a275 7
enum rib_state {
	RIB_NONE,
	RIB_NEW,
	RIB_ACTIVE,
	RIB_DELETE
};

d279 1
a279 1
	enum rib_state		state;
@


1.128
log
@Generate a EoR marker in the update list instead of sending it independent
of the actual update dump. This will get us the right barrier and the EoR
is no longer sent way before the actual dump. Currently a nop since graceful
restart is turned off (unless you have announce restart yes in the config).
put it in henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.127 2010/01/10 00:15:09 claudio Exp $ */
d59 2
a60 4
	struct uplist_attr		 updates;
	struct uplist_prefix		 withdraws;
	struct uplist_attr		 updates6;
	struct uplist_prefix		 withdraws6;
d242 13
d439 4
a442 2
u_char		*up_dump_mp_unreach(u_char *, u_int16_t *, struct rde_peer *);
int		 up_dump_mp_reach(u_char *, u_int16_t *, struct rde_peer *);
@


1.127
log
@Switch rib_dump() to use AID instead of AFs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.126 2009/12/18 15:51:37 claudio Exp $ */
d424 1
d429 1
a429 1
u_char		*up_dump_mp_reach(u_char *, u_int16_t *, struct rde_peer *);
@


1.126
log
@Merge rde_filter_community() with community_match() and kill a useless
indirection.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.125 2009/12/16 15:40:55 claudio Exp $ */
d253 1
a253 1
	sa_family_t			 ctx_af;
d364 1
a364 1
		     void *, sa_family_t);
@


1.125
log
@Implement "set ext-community [delete] subtype key:value" to set and delete
extended communities as specified in RFC 4360. No matching implemented yet
and stuff like * and neighbor-as are neither supported but will be soon.
Looks good henning & sthen, manpage fixed by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.124 2009/12/08 14:03:40 claudio Exp $ */
d346 1
a346 1
int		 community_match(void *, u_int16_t, int, int);
a460 1
int		 rde_filter_community(struct rde_aspath *, int, int);
@


1.124
log
@Big AID change part two. This changes the mp capability into an array of
flags. This makes a lot of code much easier since the comparison is now
trivial. Additionally calculate the negotiated capabilities for a session
in the SE and pass that and only that to the RDE. This makes the decisions
in the RDE a lot easier.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.123 2009/12/01 14:28:05 claudio Exp $ */
d349 4
@


1.123
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.122 2009/10/05 12:03:45 claudio Exp $ */
d63 1
a63 2
	struct capabilities		 capa_announced;
	struct capabilities		 capa_received;
d419 1
a419 1
		     sa_family_t);
@


1.122
log
@Load prefixes into new created RIBs at reload time by walking over the
Adj-RIB-In. This only works correctly when softreconfig in is enabled
(which is the default). This is needed to allow dynamic creation of
additional RIBs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.121 2009/08/06 08:53:11 claudio Exp $ */
d224 1
a224 1
	sa_family_t			 af;
d231 1
a231 1
	sa_family_t			 af;
d239 1
a239 1
	sa_family_t			 af;
d400 1
a400 1
		     enum action_types, sa_family_t);
d457 1
a457 1
		     sa_family_t, struct rde_peer *, struct rde_peer *);
@


1.121
log
@Implement the error handling as proposed in draft-ietf-idr-optional-transitive
for optional transitive attributes. In short if the partial bit is set on
an optional transitive attribute but the attribute fails validation ignore
the attribute or mark the path as ineligible instead of killing the session
with a NOTIFICATION. Tested, input and OK sthen, OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.120 2009/06/06 01:10:29 claudio Exp $ */
d268 1
@


1.120
log
@Some preliminary filter magic to support multiple RIBs on the filters.
It is ugly but does the trick for now. Filters will be rewritten anyway.
The rib specifier only makes sense on from rules. e.g. deny rib OMG from any
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.119 2009/06/06 01:07:01 claudio Exp $ */
d166 1
@


1.119
log
@Only the main Loc-RIB should update the FIB for now. So introduce a
F_RIB_NOFIB flag and apply it on all RIBs that are not F_RIB_NOEVALUATE.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.118 2009/06/06 01:02:51 claudio Exp $ */
d450 4
a453 4
enum filter_actions rde_filter(struct rde_aspath **, struct filter_head *,
		     struct rde_peer *, struct rde_aspath *,
		     struct bgpd_addr *, u_int8_t, struct rde_peer *,
		     enum directions);
@


1.118
log
@Only generate updates for peers that are member of the RIB that update is
comming from.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.117 2009/06/04 21:53:43 claudio Exp $ */
d281 1
@


1.117
log
@Implement rib_find and add a rib id to struct rde_peer.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.116 2009/06/04 04:46:42 claudio Exp $ */
d301 2
a302 1
void		 rde_generate_updates(struct prefix *, struct prefix *);
@


1.116
log
@Add "rde rib <name>" to the config and allow the rde to use these other RIBs.
Still a bit hackish, reload is missing and printconf as well. Looks good h@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.115 2009/06/03 20:17:59 claudio Exp $ */
d76 1
d281 1
d352 1
@


1.115
log
@Better way to allocate new RIBs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.114 2009/06/02 00:09:02 claudio Exp $ */
d249 1
d349 1
a349 2
void		 rib_init(void);
u_int16_t	 rib_new(u_int16_t, char *, u_int16_t);
@


1.114
log
@Move the rest of the rib dump functions into rde_rib.c where it belongs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.113 2009/06/01 23:54:50 claudio Exp $ */
d349 1
a349 1
u_int16_t	 rib_new(char *);
@


1.113
log
@Use only one list to queue the dump contextes on. Use the list in struct
rib_context instead of the ctl specific rde_dump_ctx to make it more general.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.112 2009/06/01 22:49:06 claudio Exp $ */
d356 2
@


1.112
log
@Holy simplification batman. Use the per rib entry flags to lock entries
when interrupting rib dumps and now we no longer need evil RB magic to find
the next entry on restart.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.111 2009/06/01 21:20:17 claudio Exp $ */
d244 3
a246 3
	LIST_ENTRY(rib_context)	 entry;
	struct rib_entry	*ctx_re;
	struct rib		*ctx_rib;
d249 3
a251 3
	void			*ctx_arg;
	unsigned int		 ctx_count;
	sa_family_t		 ctx_af;
a271 1
	LIST_HEAD(, rib_context)	ctxts;
@


1.111
log
@Instead of storing a pointer to the RIB head in the RIB element use that
space for a flags field and the RIB id. In the end bgpd will be able to
lock RIB elements and therefore make it possible to interrupt all tree
walks.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.110 2009/05/27 06:58:15 claudio Exp $ */
d245 1
a245 1
	struct pt_entry		*ctx_p;
@


1.110
log
@Move update and withdraw code into own functions to simplify the necessary
changes to make multiple RIB functional. Also change the way we account the
prefixes per peer (for maxprefix check). Every prefix that was added to any
RIB is counted. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.109 2009/05/21 15:47:03 claudio Exp $ */
d259 2
a260 1
	struct rib		*rib;
d274 1
a275 1
	u_char			noevaluate;
d277 3
@


1.109
log
@Make it possible to turn off the decision process per RIB. This is mainly
used for the Adj-Rib-In. Also initialize the Adj-Rib-In correctly and mark
it a noevaluate.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.108 2009/05/17 14:45:25 claudio Exp $ */
a69 1
	u_int32_t			 rib_cnt;    /* # of p. in Adj-RIB-In */
a185 1
	u_int32_t			 rib_cnt;    /* # of p. in Adj-RIB-In */
d356 1
a356 1
void		 path_update(struct rib *, struct rde_peer *,
d372 1
a372 1
void		 prefix_add(struct rib *, struct rde_aspath *,
d375 1
a375 1
void		 prefix_remove(struct rib *, struct rde_peer *,
@


1.108
log
@F_LOCAL and F_ORIGINAL are gone. The Adj-Rib-In is now a distinct tree.
Fix pf table code by checking if the aspath has a pftableid set or not
instead of doing the F_LOCAL dance. This works because the in the
Adj-Rib-In it is impossible to set pftableid.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.107 2009/05/17 12:25:15 claudio Exp $ */
d276 1
@


1.107
log
@Rework most of the RDE to allow multiple RIBs. This is mostly preparation
work by changing the way the RDE DB is built. struct prefix and struct
pt_entry are simplified and extended with a rib_entry where the decision
tree is run on. From now on a prefix can only reside on one particular RIB
which simplifies the code a bit. Currently there are two fixed ribs
(adj-rib-in and the local-rib) which needs to be made more dynamic in
upcomming commits.
This is work in progress, the RDE seems to work for me and sthen@@ (no flames
comming out of our testrouters but there is still a lot missing)
Move into the tree to simplify developement -- henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.106 2009/04/23 19:23:27 claudio Exp $ */
d160 3
a162 1
#define	F_PREFIX_ANNOUNCED	0x01000
a165 1
#define	F_NEXTHOP_SELF		0x10000
a166 4
#define	F_LOCAL			0x40000	/* Local-RIB */
#define	F_ORIGINAL		0x80000	/* Adj-RIB-In */
#define	F_RIB_MASK		(F_LOCAL | F_ORIGINAL)
#define	F_ANN_DYNAMIC		0x100000
@


1.106
log
@Rework the way we handle announced networks. Instead of two freak rde_peers
use one that is less freaky. Merge bgpctl and config networks into one tree.
First step of a larger change in the RDE and this goes now in to allow to
move forward.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.105 2009/03/19 06:52:59 claudio Exp $ */
d45 1
d70 1
a70 1
	u_int32_t			 adjrib_cnt; /* # of p. in Adj-RIB-In */
d190 1
a190 1
	u_int32_t			 adjrib_cnt; /* # of p. in Adj-RIB-In */
d229 1
a229 2
	struct prefix_head		 prefix_h;
	struct prefix			*active; /* for fast access */
d236 1
a236 2
	struct prefix_head		 prefix_h;
	struct prefix			*active; /* for fast access */
a237 5
	/*
	 * Route Flap Damping structures
	 * Currently I think they belong into the prefix but for the moment
	 * we just ignore the dampening at all.
	 */
d244 1
a244 2
	struct prefix_head		 prefix_h;
	struct prefix			*active; /* for fast access */
d248 31
a278 12
struct pt_context {
	union {
		struct pt_entry		p;
		struct pt_entry4	p4;
		struct pt_entry6	p6;
	}			pu;
#define ctx_p			pu.p
#define ctx_p4			pu.p4
#define ctx_p6			pu.p6
	/* only count and done should be accessed by callers */
	unsigned int		count;
	int			done;
d282 1
a282 1
	LIST_ENTRY(prefix)		 prefix_l, path_l;
d285 1
a286 1
	u_int32_t			 flags;
d346 12
d360 2
a361 2
void		 path_update(struct rde_peer *, struct rde_aspath *,
		     struct bgpd_addr *, int, u_int32_t);
d374 7
a380 7
struct prefix	*prefix_get(struct rde_peer *, struct bgpd_addr *, int,
		    u_int32_t);
struct pt_entry	*prefix_add(struct rde_aspath *, struct bgpd_addr *, int,
		    u_int32_t);
struct pt_entry	*prefix_move(struct rde_aspath *, struct prefix *, u_int32_t);
void		 prefix_remove(struct rde_peer *, struct bgpd_addr *, int,
		    u_int32_t);
d382 2
a383 1
struct prefix	*prefix_bypeer(struct pt_entry *, struct rde_peer *, u_int32_t);
d401 1
a401 1
void		 prefix_evaluate(struct prefix *, struct pt_entry *);
d420 16
a435 4
void		 pt_init(void);
void		 pt_shutdown(void);
int		 pt_empty(struct pt_entry *);
void		 pt_getaddr(struct pt_entry *, struct bgpd_addr *);
d438 1
a438 1
void		 pt_remove(struct pt_entry *);
d440 2
a441 4
void		 pt_dump(void (*)(struct pt_entry *, void *), void *,
		     sa_family_t);
void		 pt_dump_r(void (*)(struct pt_entry *, void *), void *,
		     sa_family_t, struct pt_context *);
@


1.105
log
@Implement a attr_writebuf() function that works on a struct buf instead of
a pre allocated piece of memory. Will be used by newer mrt code.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.104 2009/01/13 21:35:16 sthen Exp $ */
d167 2
d362 1
a362 1
void		 prefix_network_clean(struct rde_peer *, time_t);
@


1.104
log
@Replace NEW_ASPATH/NEW_AGGREGATOR with the naming from RFC4893,
AS4_PATH/AS4_AGGREGATOR. No binary change.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.103 2008/11/21 17:41:22 claudio Exp $ */
d293 2
@


1.103
log
@Track nexthops when the underlying route is changing. Until now true nexthops
were only resolved when they were added. This calls for troubles if something
like ospfd starts to change the underlying routes.
Tested by gollo@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.102 2008/01/23 08:11:32 claudio Exp $ */
d110 2
a111 2
	ATTR_NEW_ASPATH=17,
	ATTR_NEW_AGGREGATOR=18
d157 1
a157 1
#define	F_ATTR_AS4BYTE_NEW	0x00100	/* NEW_ASPATH or NEW_AGGREGATOR */
@


1.102
log
@Add defines for extended communities. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.101 2007/11/27 01:13:54 claudio Exp $ */
d355 2
a356 1
void		 prefix_updateall(struct rde_aspath *, enum nexthop_state);
@


1.101
log
@Prefixes or actually pathes that would cause a rooting loops should not be
dropped when parsed but instead be added to the RIB marked as not eligible.
So the decision process does not pick them up as a valid route.
Tested and some ideas by Tony Sarendal (tony (at) polarcap (dot) org)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.100 2007/06/01 04:17:30 claudio Exp $ */
d109 1
@


1.100
log
@Remove a stupid wrapper function that does nothing more then calling another
function with the same arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.99 2007/04/23 13:04:24 claudio Exp $ */
d157 1
@


1.99
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.98 2007/04/06 18:03:51 claudio Exp $ */
a334 1
void		 path_updateall(struct rde_aspath *, enum nexthop_state);
@


1.98
log
@Count the updates and withdraws for additional statisic gathering.
Discussed with henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.97 2007/01/26 17:40:49 claudio Exp $ */
d76 1
d108 3
a110 1
	ATTR_MP_UNREACH_NLRI=15
d148 17
a164 16
#define	F_ATTR_ORIGIN		0x0001
#define	F_ATTR_ASPATH		0x0002
#define	F_ATTR_NEXTHOP		0x0004
#define	F_ATTR_LOCALPREF	0x0008
#define	F_ATTR_MED		0x0010
#define	F_ATTR_MED_ANNOUNCE	0x0020
#define	F_ATTR_MP_REACH		0x0040
#define	F_ATTR_MP_UNREACH	0x0080
#define	F_PREFIX_ANNOUNCED	0x0100
#define	F_NEXTHOP_REJECT	0x0200
#define	F_NEXTHOP_BLACKHOLE	0x0400
#define	F_NEXTHOP_NOMODIFY	0x0800
#define	F_NEXTHOP_SELF		0x1000
#define	F_ATTR_LINKED		0x2000
#define	F_LOCAL			0x4000	/* Local-RIB */
#define	F_ORIGINAL		0x8000	/* Adj-RIB-In */
d186 1
a188 1
	u_int16_t			 flags;		/* internally used */
d284 1
a284 1
u_int16_t	 rde_local_as(void);
d287 1
d304 1
a304 1
int		 aspath_verify(void *, u_int16_t);
d312 3
d318 2
a319 2
u_int16_t	 aspath_neighbor(struct aspath *);
int		 aspath_loopfree(struct aspath *, u_int16_t);
d321 2
a322 2
struct aspath	*aspath_prepend(struct aspath *, u_int16_t, int);
int		 aspath_match(struct aspath *, enum as_spec, u_int16_t);
d414 1
a414 1
u_int16_t	 aspath_extract(const void *, int);
@


1.97
log
@Massiv rework of the control imsg flow. Main changes:
- dedicated pipe between the SE and the RDE for control messages
- restartable RB tree dumps in the RDE
- queuing limits both in the SE and RDE
The result is a dramatic decrease of memory consumption on operations like
bgpctl show rib. Previously all messages where first stored in the RDE
then passed to the SE where they got queued in case bgpctl was not fast enough.
Now only a small number of messages is generated and passed to the SE and
the SE has an additional limit instead of acting like an infinite buffer.
Without this the bgpd on bgpd.networx.ch would not survive a single minute.
looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.96 2006/11/10 14:47:32 henning Exp $ */
d64 4
@


1.96
log
@char -> u_char in a few places
apparently from Jeff Rizzo <riz@@NetBSD.org> via "Thomas E. Spanjaard"
<tgen@@netphreax.net>, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.95 2006/05/28 23:24:15 claudio Exp $ */
d243 14
d387 2
@


1.95
log
@Even better nexthop delete behaviour. Do not delete nexthop if they are used
by filter sets or if the nexthop is currently looked up. With this the
"nexthop_update: non-existent nexthop" warning should be history. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.94 2006/05/28 22:07:54 claudio Exp $ */
d359 2
a360 2
char		*up_dump_mp_unreach(u_char *, u_int16_t *, struct rde_peer *);
char		*up_dump_mp_reach(u_char *, u_int16_t *, struct rde_peer *);
@


1.94
log
@Preload and pin nexthop used in filtersets so the are validiated when used.
This will fix problems with set nexthop on outgoing filters. Found by
gluk@@ OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.93 2006/04/12 14:05:46 claudio Exp $ */
d338 1
@


1.93
log
@It is no longer allowed to change attributes in place. This corrupts the
attribute cache. Instead remove attribute and readd it after beeing changed.
This should fix the "att_diff: equal attributes encountered" error seen by
Tony Sarendal. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.92 2006/04/05 13:24:29 claudio Exp $ */
d204 1
@


1.92
log
@remote_bgpid is stored in host byte order so a htonl() is needed when putting
the value on the wire. This solves the backward originator-ids seend by
Tony Sarendal. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.91 2006/04/04 12:03:26 henning Exp $ */
d276 1
@


1.91
log
@add "set nexthop self", force nexthop to be set to own address even with IBGP
requested & tested Falk Brockerhoff <fb@@smartterra.de>, and tony sarendal
tested this too. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.90 2006/03/22 10:18:49 claudio Exp $ */
d66 1
a66 1
	u_int32_t			 remote_bgpid;
@


1.90
log
@Add a new SHOW imsg to send optional attributes to bgpctl. This can be used
to show communites in bgpctl output. Only send these messages if it they are
requested to reduce the overhead for simple listings. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.89 2006/02/09 21:05:09 claudio Exp $ */
d153 4
a156 3
#define	F_ATTR_LINKED		0x1000
#define	F_LOCAL			0x2000	/* Local-RIB */
#define	F_ORIGINAL		0x4000	/* Adj-RIB-In */
@


1.89
log
@Implement "set community delete 65001:*" and friends. This will remove
communities from the path attributes. Useful to make sure that the ones you
set later are set by a (evil) peer.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.88 2006/02/02 14:06:05 claudio Exp $ */
d275 2
@


1.88
log
@Implement new special community "neighbor-as". neighbor-as is expanded on
the fly to the remote AS of the current neighbor. This can be used to
simplify rulesets in a dramatic way -- going from a script based nightmare
down to a handfull rules. jajajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.87 2006/01/24 14:14:04 claudio Exp $ */
d294 1
@


1.87
log
@Check if filter changed on a per peer basis. This should speed up the
table run done later as many filter evaluations can be skipped.
From the softreconfig in tree. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.86 2006/01/24 13:34:33 claudio Exp $ */
d373 1
a373 1
		     sa_family_t, struct rde_peer *, enum directions);
@


1.86
log
@Finally start using the Adj-RIB-In. The most complex part is the modification
of path_update(). There are about 10 different ways how to update a path and
some of them are tricky. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.85 2006/01/20 16:40:17 claudio Exp $ */
d72 2
d376 1
a376 1
		     enum directions);
@


1.85
log
@Proactively fix prefix counters. Currently only F_LOCAL prefixes exist but
as soon as F_ORIGINAL come the counters would no longer be correct and in the
end max-prefix would no longer work. Add additinal counters for F_ORIGINAL
prefixes and bump the correct conter depending on the prefix flags.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.84 2006/01/20 16:06:12 claudio Exp $ */
d297 1
a297 1
		     struct bgpd_addr *, int);
@


1.84
log
@Pass flags to prefix_move() so that a prefix that has both F_ORIGINAL and
F_LOCAL set can be moved correctly. This is more like a add as we have one
prefix more afterwards. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.83 2006/01/14 22:39:49 claudio Exp $ */
d64 2
a65 1
	u_int32_t			 prefix_cnt;
d172 3
a177 2
	u_int16_t			 prefix_cnt; /* # of prefixes */
	u_int16_t			 active_cnt; /* # of active prefixes */
@


1.83
log
@Small step in supporting the Adj-RIB-In additionaly to the Local-RIB.
First step is to define two flags F_LOCAL and F_ORIGINAL. These flags
are used to distinguish prefix in the Local-RIB and those in the Adj-
RIB-In. Adapt prefix API and add additional checks so that no Adj-RIB-
In prefixes get mistakenly selected. Currently no F_ORIGINAL prefixes
are created but this may change soon. Looks good Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.82 2006/01/12 14:05:13 claudio Exp $ */
d313 1
a313 1
struct pt_entry	*prefix_move(struct rde_aspath *, struct prefix *);
@


1.82
log
@Copy AS path in rde_filter() on demand instead of doing it before calling
rde_filter(). Adapt path_update() to this change too. path_update() does
a path_copy before linking the rde_aspath into the RIB. Looks good Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.81 2006/01/10 16:11:12 claudio Exp $ */
d151 3
d309 4
a312 2
struct prefix	*prefix_get(struct rde_peer *, struct bgpd_addr *, int);
struct pt_entry	*prefix_add(struct rde_aspath *, struct bgpd_addr *, int);
d314 2
a315 1
void		 prefix_remove(struct rde_peer *, struct bgpd_addr *, int);
d317 1
a317 1
struct prefix	*prefix_bypeer(struct pt_entry *, struct rde_peer *);
@


1.81
log
@The attributes cache broke the set community filterset because community_set()
modified the attribute data directly and corrupted the cache by doing it.
It is no longer allowed to modify attributes via attr_optget() -> change
attr->data. Instead remove the old attribute from the aspath and then add
a new modifed one again. Included in this change is the removal of a "feature"
that allowed only one community per AS. If you had problems to add multiple
communities via filters then this was the problem. Looks good Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.80 2006/01/05 16:00:07 claudio Exp $ */
d358 4
a361 3
enum filter_actions rde_filter(struct filter_head *, struct rde_peer *,
		     struct rde_aspath *, struct bgpd_addr *, u_int8_t,
		     struct rde_peer *, enum directions);
@


1.80
log
@Cache optional BGP attributes (mostly communities) and use a simple
pointer plus a ref counter to link the attributes to the path object.
Saves +/- 10M on 11 full feeds. Looks good Henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.79 2006/01/03 22:49:17 claudio Exp $ */
d286 1
a286 1
int		 community_set(struct attr *, int, int);
@


1.79
log
@Track some (memory) statistics in the RDE. Accessible via bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.78 2006/01/03 22:19:59 claudio Exp $ */
d113 1
a113 1
	TAILQ_ENTRY(attr)		 entry;
d115 2
d129 1
a129 1
TAILQ_HEAD(attr_list, attr);
d161 1
a161 1
	struct attr_list		 others;
d174 1
d260 2
a261 1
void		 attr_optcopy(struct rde_aspath *, struct rde_aspath *);
d265 3
a267 1
void		 attr_optfree(struct rde_aspath *);
@


1.78
log
@Move functions shared with bgpctl into new file util.c. Simplifies the
link between bgpctl and bgpd mostly because of rde_attr.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.77 2005/12/30 17:20:21 claudio Exp $ */
d238 2
@


1.77
log
@There is no attr_mp_nexthop() function, remove the prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.76 2005/12/30 16:40:15 claudio Exp $ */
a275 3
int		 aspath_snprint(char *, size_t, void *, u_int16_t);
int		 aspath_asprint(char **, void *, u_int16_t);
size_t		 aspath_strlen(void *, u_int16_t);
d358 3
@


1.76
log
@Remove unused attr_optlen()
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.75 2005/12/30 14:07:40 claudio Exp $ */
a259 2
int		 attr_mp_nexthop(u_char *, u_int16_t, u_int16_t,
		     struct rde_aspath *);
@


1.75
log
@Use sys/hash.h instead of own built functions that work similar.
While there reorder some structs to help with alignment.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.74 2005/11/29 21:11:07 claudio Exp $ */
a254 1
int		 attr_optlen(struct attr *);
@


1.74
log
@Add a flags field to struct prefix which will be used shortly. Remove the peer
pointer so that the size does not grow. Adding 4 bytes to struct prefix would
result in 64MB more memory usage on one of my systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.73 2005/11/02 13:19:30 claudio Exp $ */
a277 1
u_int32_t	 aspath_hash(const void *, u_int16_t);
@


1.73
log
@Implement filterset_equal() and rde_filter_equal(). Both return 1 if
the two passed filter(set)s are equal or 0 otherwise. rde_filter_equal()
has an additional argument dir to specify which direction should be considered.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.72 2005/11/01 15:21:54 claudio Exp $ */
a234 1
	struct rde_peer			*peer;
d236 1
@


1.72
log
@Softreconfig out support. On config reload filter changes of outgoing rules
will propagte directly to the neighbors. There is no need to restart bgpd
in that case. Currently not optimal but a good start. "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.71 2005/11/01 14:37:16 claudio Exp $ */
d363 2
@


1.71
log
@Major cleanup in rde_update.c. Merge equal code used in different places
into own functions. Move up_dump_upcall() into rde.c and rename it
rde_up_dump_upcall(). This is needed for the next step.
up_test_update() tests if an update or withdraw is needed and up_generate()
creates the updates.  "get it in" henning@@ (he is eager on softreconfig out)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.70 2005/08/10 08:34:06 claudio Exp $ */
d334 1
a334 1
void		 up_generate_updates(struct rde_peer *,
d336 2
a337 1
void		 up_generate_default(struct rde_peer *, sa_family_t);
d357 3
a359 2
enum filter_actions rde_filter(struct rde_peer *, struct rde_aspath *,
    struct bgpd_addr *, u_int8_t, struct rde_peer *, enum directions);
@


1.70
log
@Pass the correct peer to rde_apply_set(). rde_apply_set() needs to know
the peer where the prefix came from so that prepend-neighbor works.
Extend rde_filter() and make sure that the correct peer is passed.
Until now most cases resulted in a NULL peer causing a nasty crash that
was found by David Ulevitch. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.69 2005/07/29 12:38:40 claudio Exp $ */
d327 2
d331 3
a333 1
void		 up_dump_upcall(struct pt_entry *, void *);
@


1.69
log
@Add another piece to the IPv6 puzzle. This time code to generate MP updates.
Does not affect IPv4 minimaly tested for IPv6 because we still don't have an
IPv6 capable neighbor. henning@@ ya
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.68 2005/07/01 12:10:21 claudio Exp $ */
d353 1
a353 1
    struct bgpd_addr *, u_int8_t, enum directions);
@


1.68
log
@The newly introduced function filterset_free() existed already as
rde_free_set(), I just missed it when I was looking for it.
Kill rde_free_set() and use the more correct filterset_free() from now on.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.67 2005/07/01 09:19:24 claudio Exp $ */
d62 2
d329 1
d336 2
a337 1
void		 up_dump_upcall(struct pt_entry *, void *);
@


1.67
log
@Make the pftable filter set use the name2id "cache" like the route labels.
This saves 14 bytes per aspath. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.66 2005/06/29 09:43:26 claudio Exp $ */
a349 1
void		 rde_free_set(struct filter_set_head *);
@


1.66
log
@rtlabel support via filter sets. Just use "set rtlabel foobar" in filters
network and neighbor statements and the routes are labeled accordingly.
While doing that fix some mem-leaks by introducing filterset_free() and
remove the free on send option of send_filterset().
This took a bit longer because we need to carefully track the rtlabel id
refcnts or bad things may happen on reloads.
henning@@ looks fine
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.65 2005/06/10 09:58:09 claudio Exp $ */
a160 1
	char				 pftable[PFTABLE_LEN];
d165 1
d241 1
a241 1
void		 rde_send_pftable(const char *, struct bgpd_addr *,
@


1.65
log
@Introduce attr_optlen() to get the total lenght of an optional attribute
plus header. Soon needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.64 2005/04/12 14:32:00 claudio Exp $ */
d165 2
a166 1
	u_int16_t			 flags;	/* internally used */
@


1.64
log
@Introduce a per prefix weight.  The weight is used to tip prefixes with equal
long AS pathes in one or the other direction.  It weights a prefix at a very
late stage in the decision process. This is a nice bgpd feature to traffic
engineer networks where most AS pathes are equally long.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.63 2005/03/11 12:54:20 claudio Exp $ */
d252 1
@


1.63
log
@Finally commit the transparent-as and nexthop no-modify stuff I wrote on the
way to FOSDEM. With transparent-as set to ye bgpd will not prepend his own
AS for sent updates. NB the neighbor needs to set "enforce neighbor-as no"
or it will not like the received AS paths. With set nexthop no-modify bgpd
will change the nexthop as done normaly.
OK henning@@ man page update with help of jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.62 2004/12/23 15:08:43 henning Exp $ */
d164 1
@


1.62
log
@sort structs for most optimal alignment, help mickey, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.61 2004/11/23 13:07:01 claudio Exp $ */
d134 13
a146 12
#define	F_ATTR_ORIGIN		0x001
#define	F_ATTR_ASPATH		0x002
#define	F_ATTR_NEXTHOP		0x004
#define	F_ATTR_LOCALPREF	0x008
#define	F_ATTR_MED		0x010
#define	F_ATTR_MED_ANNOUNCE	0x020
#define	F_ATTR_MP_REACH		0x040
#define	F_ATTR_MP_UNREACH	0x080
#define	F_PREFIX_ANNOUNCED	0x100
#define	F_NEXTHOP_REJECT	0x200
#define	F_NEXTHOP_BLACKHOLE	0x400
#define	F_ATTR_LINKED		0x800
@


1.61
log
@Switch from a single filter_set to a linked list of sets. With this change
it is possible to specify multiple communities. This is also the first step
to better bgpd filters. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.60 2004/11/11 13:06:45 claudio Exp $ */
a52 3
	enum peer_state			 state;
	u_int32_t			 prefix_cnt;
	u_int32_t			 remote_bgpid;
a55 4
	u_int32_t			 up_pcnt;
	u_int32_t			 up_acnt;
	u_int32_t			 up_nlricnt;
	u_int32_t			 up_wcnt;
d62 7
d112 2
a115 2
	u_int16_t			 len;
	u_char				*data;
d120 1
a121 1
	void		*unreach;
d156 1
a157 2

	/* path attributes */
d160 1
a160 1
	struct attr_list		 others;
a162 2
	u_int8_t			 origin;

d166 1
a166 1
	char				 pftable[PFTABLE_LEN];
d178 3
a188 3
	struct bgpd_addr	exit_nexthop;
	struct bgpd_addr	true_nexthop;
	struct bgpd_addr	nexthop_net;
@


1.60
log
@Store the local v4 and v6 address of a session. For IPv4 sessions the first
IPv6 address with global scope of the interface used by the session is used.
In any case the local endpoint of the session is used for one of the two no
matter what scope.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.59 2004/11/11 10:35:15 claudio Exp $ */
d314 2
a315 2
void		 nexthop_modify(struct rde_aspath *, struct bgpd_addr *, int,
		     sa_family_t);
d349 2
a350 1
void		 rde_apply_set(struct rde_aspath *, struct filter_set *,
@


1.59
log
@New config statement "rde route-age [evaluate|ignore]". If set to evaluate
the best path selection will not only be based on the path attributes but
also on the age of the prefix. This is an extension to the RFC. The default
is ignore but previously it was implicitly set to evaluate.
OK henning@@ man page OK jaredy@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.58 2004/11/10 12:41:58 claudio Exp $ */
d57 2
a58 1
	struct bgpd_addr		 local_addr;
@


1.58
log
@Remove no longer needed code. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.57 2004/09/28 15:48:52 claudio Exp $ */
d247 1
@


1.57
log
@gcc-ism.  We don't want it, we don't need it.
OK henning@@ noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.56 2004/09/28 12:09:31 claudio Exp $ */
a193 1
#define NEXTHOP_LINKLOCAL	0x02
@


1.56
log
@Add prepend-neighbor feature. Prepend the remote-as n times similar to
prepend-self. Only for incomming UPDATEs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.55 2004/08/13 14:03:20 claudio Exp $ */
d72 1
a72 1
#define ASPATH_HEADER_SIZE	sizeof(struct aspath)
d81 1
a81 1
	u_char			data[0]; /* placeholder for actual data */
@


1.55
log
@Fix minor issues with IPv6 dumps and add a function for dumping the RIB table
protocol independent. This new dump format is not (yet) supported by the
mrtd route_btoa tool. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.54 2004/08/12 10:24:16 claudio Exp $ */
d349 1
a349 1
		     sa_family_t);
@


1.54
log
@Just ignore RFC2545 and the silly idea of using link local addresses as
nexthop. This makes the code a lot simpler. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.53 2004/08/10 13:02:08 claudio Exp $ */
d298 1
d305 1
@


1.53
log
@switch nexthop in struct filter_set form struct in_addr to struct bgpd_addr
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.52 2004/08/10 12:57:18 claudio Exp $ */
d240 1
a240 1
void		 rde_send_nexthop(struct bgpd_addr *, struct bgpd_addr *, int);
d316 1
a316 1
struct nexthop	*nexthop_get(struct bgpd_addr *, struct bgpd_addr *);
@


1.52
log
@Correctly set the MED in outgoing UPDATEs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.51 2004/08/06 12:04:08 claudio Exp $ */
d311 2
a312 1
void		 nexthop_modify(struct rde_aspath *, struct bgpd_addr *, int);
d346 2
a347 1
void		 rde_apply_set(struct rde_aspath *, struct filter_set *);
@


1.51
log
@Monster diff to get one step closer to IPv6 support.
Cleanup path attribute handling. First of all kill struct attr_flags, all
those infos are now in struct rde_aspath. Second move attribute parser
functions into rde.c, rde_attr.c is shared between bgpd and bgpctl.
Third reimplementation of the nexthop handling. Make it IPv6 ready and
fix some major bug relating to "set nexthop".
henning@@ OK if it breaks nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.50 2004/08/05 20:56:12 claudio Exp $ */
d138 7
a144 6
#define	F_ATTR_MP_REACH		0x020
#define	F_ATTR_MP_UNREACH	0x040
#define	F_PREFIX_ANNOUNCED	0x080
#define	F_NEXTHOP_REJECT	0x100
#define	F_NEXTHOP_BLACKHOLE	0x200
#define	F_ATTR_LINKED		0x400
@


1.50
log
@As usual cleanup on exit. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.49 2004/08/05 18:44:19 claudio Exp $ */
d66 2
d110 1
d115 7
a121 1
	TAILQ_ENTRY(attr)		 entry;
d126 19
d151 6
a156 1
struct attr_flags {
d158 2
a159 4
	struct in_addr			 nexthop;	/* exit nexthop */
	u_int8_t			 nexthop_reject;
	u_int8_t			 nexthop_blackhole;
	char				 pftable[PFTABLE_LEN];
d163 5
a167 2
	u_int8_t			 wflags;	/* internally used */
	struct attr_list		 others;
d178 1
a178 1
	enum nexthop_state	state;
d186 1
a186 1
	struct aspath_head	path_h;
d192 2
a193 19
#define NEXTHOP_CONNECTED	0x1
#define NEXTHOP_ANNOUNCE	0x2
};

struct path_table {
	struct aspath_head	*path_hashtbl;
	u_int32_t		 path_hashmask;
};

LIST_HEAD(prefix_head, prefix);

struct rde_aspath {
	LIST_ENTRY(rde_aspath)		 peer_l, path_l, nexthop_l;
	struct prefix_head		 prefix_h;
	struct rde_peer			*peer;
	struct nexthop			*nexthop;
	u_int16_t			 prefix_cnt; /* # of prefixes */
	u_int16_t			 active_cnt; /* # of active prefixes */
	struct attr_flags		 flags;
a233 2
/* currently I can't think of additional prefix flags.
 * NOTE: the selected route is stored in prefix->active */
d239 1
a239 1
void		 rde_send_nexthop(struct bgpd_addr *, int);
a248 10
void		 attr_init(struct attr_flags *);
int		 attr_parse(u_char *, u_int16_t, struct attr_flags *, int,
		     enum enforce_as, u_int16_t);
u_char		*attr_error(u_char *, u_int16_t, struct attr_flags *,
		     u_int8_t *, u_int16_t *);
u_int8_t	 attr_missing(struct attr_flags *, int);
int		 attr_compare(struct attr_flags *, struct attr_flags *);
void		 attr_copy(struct attr_flags *, struct attr_flags *);
void		 attr_move(struct attr_flags *, struct attr_flags *);
void		 attr_free(struct attr_flags *);
d251 2
a252 1
int		 attr_optadd(struct attr_flags *, u_int8_t, u_int8_t,
d254 4
a257 5
struct attr	*attr_optget(const struct attr_flags *, u_int8_t);
void		 attr_optfree(struct attr_flags *);
int		 attr_ismp(const struct attr_flags *);
int		 attr_mp_nexthop_check(u_char *, u_int16_t, u_int16_t);
struct bgpd_addr	*attr_mp_nexthop(const struct attr_flags *);
d285 1
a285 1
void		 path_update(struct rde_peer *, struct attr_flags *,
d287 2
a288 2
struct rde_aspath *path_get(struct aspath *, struct rde_peer *);
struct rde_aspath *path_add(struct rde_peer *, struct attr_flags *);
d293 3
d299 1
a299 1
struct prefix	*prefix_get(struct rde_aspath *, struct bgpd_addr *, int);
d310 3
a312 2
void		 nexthop_add(struct rde_aspath *);
void		 nexthop_remove(struct rde_aspath *);
d314 2
d342 1
a342 1
enum filter_actions rde_filter(struct rde_peer *, struct attr_flags *,
d344 2
a345 2
void		 rde_apply_set(struct attr_flags *, struct filter_set *);
int		 rde_filter_community(struct attr_flags *, int, int);
@


1.49
log
@Cleanup aspath specific functions and api. Mainly switch to a refcnt based
allocation. This helps to save a bit of RAM. looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.48 2004/08/05 15:58:21 claudio Exp $ */
d259 1
@


1.48
log
@rename and move prefix_equal() to prefix_compare() which returns -1, 0, 1
similar to memcmp() and all other compare functions in bgpd. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.47 2004/07/30 14:44:30 claudio Exp $ */
d70 1
a70 1
#define ASPATH_HEADER_SIZE	sizeof(struct aspath_hdr)
d72 1
a72 6
struct aspath_hdr {
	u_int16_t			len;	/* total length of aspath
						   in octets */
	u_int16_t			as_cnt;	/* number of AS's in data */
	u_int16_t			prepend;
};
d75 5
a79 9
	struct aspath_hdr		hdr;
	u_char				data[1];
	/*
	 * data consists of multiple struct aspath_segment with a length of
	 * len octets. In zebra data is a pointer to some memory location with
	 * the aspath segments. We could do it like this but then we should
	 * remove the pointer from rde_aspath and store the aspath header
	 * directly there.
	 */
d258 3
a260 4
struct aspath	*aspath_create(void *, u_int16_t);
void		 aspath_destroy(struct aspath *);
int		 aspath_write(void *, u_int16_t, struct aspath *, u_int16_t,
		     int);
d263 1
a263 1
u_int16_t	 aspath_count(struct aspath *);
a264 1
u_int32_t	 aspath_hash(struct aspath *);
d267 2
@


1.47
log
@Add new announce type "default-route" which will only announce the default
route to the specified neighbor. Idea and OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.46 2004/07/28 16:02:14 claudio Exp $ */
d297 2
@


1.46
log
@The default localpreference is 100 and not 0. Found and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.45 2004/07/13 17:57:20 jaredy Exp $ */
d318 1
@


1.45
log
@fix some typos

ok henning otto
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.44 2004/07/05 16:54:53 henning Exp $ */
d129 2
@


1.44
log
@implement "set nexthop blackhole" and "set nexthop reject"
blackhole/reject routes will be entered to the kernel for matching ones.
this is intended to be used with the Cymru Bogon Route Server Project
(http://www.cymru.com/BGP/bogon-rs.html) and similar services, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.43 2004/06/24 23:15:58 claudio Exp $ */
d34 1
a34 1
	PEER_ERR	/* error occured going to PEER_DOWN state */
@


1.43
log
@First step at multiprotocol support, only partially done.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.42 2004/06/22 20:28:58 claudio Exp $ */
d133 2
@


1.42
log
@Make the RDE IPv6 ready missing is the message handling. The internal
prefix tree changed form a hash table to a per AF RB tree.
OK henning@@ some ideas are from Brent Graveland.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.41 2004/06/20 18:35:12 henning Exp $ */
d102 3
a104 1
	ATTR_CLUSTER_LIST
d153 1
a153 1
	 * with a variable coast with a max for unreachable.
d253 1
a253 1
struct attr	*attr_optget(struct attr_flags *, u_int8_t);
d255 3
@


1.41
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.40 2004/05/21 15:36:40 claudio Exp $ */
d182 1
d184 2
a185 3
	LIST_ENTRY(pt_entry)		 pt_l;	/* currently we are using a
						   hash list for prefixes */
	struct bgpd_addr		 prefix;
d189 9
d205 9
d318 1
d323 2
a324 1
void		 pt_dump(void (*)(struct pt_entry *, void *), void *);
@


1.40
log
@RFC 2796 bgp route reflector support. This is very useful in conjunction
with templates. looks good, go for it henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.39 2004/05/17 12:39:32 djm Exp $ */
d119 1
a119 1
	TAILQ_ENTRY(attr)		 attr_l;
@


1.39
log
@extend filter language to allow basic setting of COMMUNITIES attribute.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.38 2004/05/07 10:06:15 djm Exp $ */
d100 3
a102 1
	ATTR_COMMUNITIES
d232 1
a232 1
		     u_char *, u_int16_t);
@


1.38
log
@add a filter option to dump prefixes learned in UPDATEs into a PF table,
intended for building realtime BGP blacklists (e.g. with spamd);
ok claudio & henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.37 2004/04/10 17:27:28 henning Exp $ */
d254 1
@


1.37
log
@move the API_* and SAFI_* defines to where they belong
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.36 2004/03/11 17:12:51 claudio Exp $ */
d129 1
d208 4
@


1.36
log
@Add basic support for communities. Currently it is only possible to filter
on communities, e.g match from any community 24640:* set localpref 666
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.35 2004/03/11 14:22:23 claudio Exp $ */
a26 10

/* XXX generic stuff, should be somewhere else */
/* Address Family Numbers as per rfc1700 */
#define AFI_IPv4	1
#define AFI_IPv6	2

/* Subsequent Address Family Identifier as per rfc2858 */
#define SAFI_UNICAST	1
#define SAFI_MULTICAST	2
#define SAFI_BOTH	3
@


1.35
log
@Shutdown the RDE cleanly on exit. Plug some memleaks. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.34 2004/03/05 22:21:32 claudio Exp $ */
d109 2
a110 1
	ATTR_AGGREGATOR
d236 1
d258 1
d312 1
@


1.34
log
@Plug some memory leaks in rde. Based on a patch by Patrick Latifi.
Added attr_move() so that we can copy the attribute before calling the filter.
path_update() will now use the passed attribute so it can't be simply reused.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.33 2004/03/01 16:02:01 claudio Exp $ */
d259 1
d279 1
d297 1
@


1.33
log
@Make it possible to diable the decision process. This is a feature only useful
for route-collectors. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.32 2004/02/27 20:53:56 claudio Exp $ */
d229 1
@


1.32
log
@remove unneded peer pointer in struct prefix and change a in_addr_t to
struct in_addr. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.31 2004/02/26 16:16:41 claudio Exp $ */
d218 1
@


1.31
log
@show rib infrastructure. At least full dumps and per as dumps. Per prefix
dump need some more work. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.30 2004/02/26 14:00:33 claudio Exp $ */
d137 1
a137 1
	in_addr_t			 nexthop;	/* exit nexthop */
d192 1
a192 1
	int				 prefixlen;
@


1.30
log
@Implement "enforce neighbor-as yes|no" which is by default on for ebgp
neighbors. While doing that check also that the nexthop is valid (not class D
or E and not in 127/8 range). Kill some TODO and XXX and rename the british
neighbour to neighbor as used everywhere else. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.29 2004/02/19 23:07:00 claudio Exp $ */
d169 5
@


1.29
log
@Add support for basic filters. Nothing optimized and it has some issues but
this is a huge step forward. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.28 2004/02/18 23:18:16 claudio Exp $ */
d216 2
a217 1
int		 attr_parse(u_char *, u_int16_t, struct attr_flags *, int);
d241 1
a241 1
u_int16_t	 aspath_neighbour(struct aspath *);
@


1.28
log
@Correctly handle parse errors in aspath and prefixes. Also do input aspath
loop detection. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.27 2004/02/18 16:36:09 claudio Exp $ */
d85 2
a86 3
	u_int16_t			as_cnt;	/* total number of AS's */
	/* probably we should switch these to int or something similar */
	/* char	*str; string representation of aspath for regex search. */
d222 1
d294 4
@


1.27
log
@Bring the path attribute parsing on big step closer to the RFC.
Check that evry attribut is only allowed once and ensure that the
mandatory attributes are present.
no objections henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.26 2004/02/16 13:21:46 claudio Exp $ */
d217 1
a217 2
int		 attr_parse(u_char *, u_int16_t, struct attr_flags *, int,
		     u_int16_t);
d229 4
a232 5
int		 aspath_verify(void *, u_int16_t, u_int16_t);
#define		 AS_ERR_LOOP	-1
#define		 AS_ERR_LEN	-2
#define		 AS_ERR_TYPE	-3
#define		 AS_ERR_BAD	-4
d242 1
d245 1
@


1.26
log
@Basic aspath match function needed for filters and the "show rib" bgpctl
command. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.25 2004/02/16 12:58:45 claudio Exp $ */
d142 1
d219 3
a221 1
u_char		*attr_error(u_char *, u_int16_t, u_int8_t *, u_int16_t *);
@


1.25
log
@Add basic functions to print aspath in human readable format. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.24 2004/02/16 12:53:15 claudio Exp $ */
d244 1
@


1.24
log
@Make the path attribute handling more RFC conformant. Also move the
parser to rde_attr.c where it belongs. Still missing: better aspath loop
detection (should be done afterwards) and some basic error checking for
optional attributes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.23 2004/02/09 01:56:18 henning Exp $ */
d214 1
a214 1
/* rde_rib.c */
d242 2
d245 1
@


1.23
log
@replace a bunch of u_long by u_int32_t
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.22 2004/02/02 18:06:32 claudio Exp $ */
d215 4
d223 1
a223 1
void		 attr_optadd(struct attr_flags *, u_int8_t, u_int8_t,
@


1.22
log
@Somehow I missed this peace in one of my last commits. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.21 2004/01/17 19:35:36 claudio Exp $ */
d64 1
a64 1
	u_long				 prefix_cnt;
d236 1
a236 1
u_long		 aspath_hash(struct aspath *);
d239 1
a239 1
void		 path_init(u_long);
d258 1
a258 1
void		 nexthop_init(u_long);
@


1.21
log
@Make it possible to announce own networks. In the RDE these prefixes are
attached to a pseudo peer and inserted like all other prefixes into the RIB.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.20 2004/01/13 16:08:04 claudio Exp $ */
d221 1
@


1.20
log
@Fix the aspath_* functions to allow empty aspath. A empty aspath is one
with len 0. Needed vor ibgp and local network announcements.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.19 2004/01/13 13:45:50 claudio Exp $ */
d155 4
d166 3
a168 1
	u_int8_t		connected;
a179 7
	/*
	 * currently we use the boolean nexthop state, this could be exchanged
	 * with a variable coast with a max for unreachable.
	 */
#if 0
	u_int32_t			 nexthop_costs;
#endif
d255 1
@


1.19
log
@Implement a max-prefix and a announce none | self | all neighbor statement.
The first limits the number of sent prefixes per peer the latter controls
which prefix we do annouce to the neighbor.
Another looks good from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.18 2004/01/13 13:34:56 claudio Exp $ */
d224 4
a227 3
#define		 AS_ERR_LEN	-1
#define		 AS_ERR_TYPE	-2
#define		 AS_ERR_LOOP	-3
@


1.18
log
@Better update error handling. Ensure that the session goes down and
ignore all queued updates after an error. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.17 2004/01/13 13:18:03 claudio Exp $ */
d64 1
@


1.17
log
@Dump and send RIB to the neighbor if his session is comming up.
Now bgpctl neighbor <IP> up does work as expected.
Looks good from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.16 2004/01/12 13:33:16 claudio Exp $ */
d43 2
a44 1
	PEER_UP
@


1.16
log
@Nexthop announcement fixup. There are different rules for ibgp and ebgp.
For ibgp the nexthop is normally passed unmodified unless the nexthop is
equal to the remote peer ip. To ebgp peers the nexthop is changed to the
local session ip unless the remote peer ip and the nexthop are on the same
subnet. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.15 2004/01/11 21:47:20 claudio Exp $ */
d210 1
d263 2
d268 1
@


1.15
log
@Move all struct in_addr to either struct bgpd_addr or in_addr_t whichever
is more appropriate. The rde uses now in most cases struct bgpd_addr.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.14 2004/01/11 20:13:00 claudio Exp $ */
d158 2
@


1.14
log
@Add to the IMSG_SESSION_UP message the local and remote address of the
peer session. This is needed to set the correct nexthop address in outgoing
bgp UPDATES. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.13 2004/01/10 22:25:42 claudio Exp $ */
a99 14
struct astags {
	u_int16_t			len;
	u_int16_t			size;
	struct community {
		u_int16_t		as_num;
		u_int16_t		value;
	}				astag[1];
	/* this beast is variable sized */
	/*
	 * XXX does not work. Because of possible unaligned access to
	 * u_int16_t. This needs to be solved somewhat differently.
	 */
};

d136 1
a136 1
	struct in_addr			 nexthop;	/* exit nexthop */
d156 2
a157 2
	struct in_addr		exit_nexthop;
	struct in_addr		true_nexthop;
d183 1
a183 1
	struct in_addr			 prefix;
d207 1
a207 1
void		 rde_send_nexthop(in_addr_t, int);
d235 1
a235 1
		     struct in_addr , int);
d243 2
a244 2
struct prefix	*prefix_get(struct rde_aspath *, struct in_addr, int);
struct pt_entry	*prefix_add(struct rde_aspath *, struct in_addr, int);
d246 1
a246 1
void		 prefix_remove(struct rde_peer *, struct in_addr, int);
d267 2
a268 2
struct pt_entry	*pt_get(struct in_addr, int);
struct pt_entry *pt_add(struct in_addr, int);
d270 1
a270 1
struct pt_entry	*pt_lookup(struct in_addr);
@


1.13
log
@Implement as path prepends. At least one prepend is needed for ebgp
neighbors. Fix a bug in the update generation. If no path attributes are
available e.g. a packet with only withdraws we need to set (and write) the
bgp path attribute field to zero. With this change we are able to send
valid updates to our neighbors with one exception: the nexthop field which
needs to be changed for ebgp neighbors.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.12 2004/01/10 16:20:29 claudio Exp $ */
d62 1
d64 2
a65 2
	enum peer_state			 state;
	struct in_addr			 if_ip; /* nexthop for announcements*/
@


1.12
log
@RDE update generation. First we queue all updates and withdraws on a per
peer basis. A queue runner will dequeue and package those messages to valid
bgp UPDATE messages and send them to the SE.
Not yet done is per peer type attribute handling (like aspath prepends and
nexthop modifications) and the queue runner could be a tad smarter. All in
all this gives us a good starting point for the missing parts.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.11 2004/01/06 10:51:14 claudio Exp $ */
d221 1
d237 2
@


1.11
log
@2004 OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.10 2003/12/30 13:03:27 henning Exp $ */
d24 1
d52 4
d58 15
a72 6
	LIST_ENTRY(rde_peer)		hash_l;	/* hash list over all peers */
	LIST_ENTRY(rde_peer)		peer_l; /* list of all peers */
	struct aspath_head		path_h; /* list of all as paths */
	struct peer_config		conf;
	u_int32_t			remote_bgpid;
	enum peer_state			state;
d131 8
a138 11
#define ATTR_ORIGIN_FLAGS	ATTR_TRANSITIVE
#define ATTR_NEXTHOP_FLAGS	ATTR_TRANSITIVE
#define ATTR_MED_FLAGS		ATTR_OPTIONAL
#define ATTR_LOCALPREF_FLAGS	ATTR_TRANSITIVE
#define ATTR_ATOMIC_AGGREGATE_FLAGS	ATTR_TRANSITIVE
#define ATTR_AGGREGATOR_FLAGS	(ATTR_OPTIONAL | ATTR_TRANSITIVE)

enum origins {
	ORIGIN_IGP,
	ORIGIN_EGP,
	ORIGIN_INCOMPLETE
d141 6
a147 1
	enum origins			 origin;
a148 1
	struct astags			*astags;
d152 2
a153 3
	u_int8_t			 aggr_atm;	/* atomic aggregate */
	u_int16_t			 aggr_as;	/* aggregator as */
	struct in_addr			 aggr_ip;	/* aggregator ip */
d223 1
a223 1
int		 attr_equal(struct attr_flags *, struct attr_flags *);
d225 4
a228 2
u_int16_t	 attr_length(struct attr_flags *);
int		 attr_dump(void *, u_int16_t, struct attr_flags *);
d241 1
a241 1
int		 aspath_equal(struct aspath *, struct aspath *);
d245 1
a245 1
			    struct in_addr , int);
d268 5
@


1.10
log
@typos from david
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.9 2003/12/26 22:41:01 henning Exp $ */
d4 2
a5 2
 * Copyright (c) 2003 Claudio Jeker <claudio@@openbsd.org> and
 *                    Andre Oppermann <oppermann@@pipeline.ch>
@


1.9
log
@"when you try to be very smart, something breaks horribly"
zap aspath->state, which was a copy of aspath->nexthop->state, for a tiny
little bit faster access. tho, it happened what had to happen, they ran
out of sync.
it's just not worth it.

also add a missinf LIST_INIT.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.8 2003/12/26 21:30:20 henning Exp $ */
d55 1
a55 1
	struct aspath_head		path_h; /* list of all as pathes */
d94 1
a94 1
	 * XXX does not work. Because of possible unalignd access to
d189 1
a189 1
	 * we just ignore the dumpening at all.
@


1.8
log
@move struct nexthop definition to rde.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.7 2003/12/25 23:22:13 claudio Exp $ */
a172 1
	enum nexthop_state		 state;
@


1.7
log
@RDE part of the nexthop verification puzzle.
The RDE just tracks the nexthop IPs and reacts on nexthop messages
from the parent.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.6 2003/12/23 15:59:02 claudio Exp $ */
d148 11
a158 1
struct nexthop;
@


1.6
log
@Send updates to the main process so they can be added to the kernel
routing table. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.5 2003/12/21 22:16:53 henning Exp $ */
d134 1
a134 1
	struct in_addr			 nexthop;
d143 1
d197 1
d239 1
a239 2
void		 nexthop_invalidate(struct in_addr, int);
void		 nexthop_validate(struct in_addr, int);
@


1.5
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.4 2003/12/21 16:11:34 claudio Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Claudio Jeker <cjeker@@diehard.n-r-g.com> and
d194 3
d240 1
a240 1
/* rde_de.c */
d243 1
a243 1
/* rde_pt.c */
@


1.4
log
@yet more from the castathon; most aspath functions where accessing non-
aligned memory (u_int16_t) therefor crashed the RDE on my sparc64. All
buffer specific functions use now void * instead of u_char * so most cast
are now history. Tested on sparc64 and i386. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.3 2003/12/19 01:15:47 deraadt Exp $ */
d247 1
a247 2
void		 pt_dump(void (*)(struct pt_entry *, int, int *, void *),
			    int, int *, void *);
@


1.3
log
@knf & 64-bit cleanup; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.2 2003/12/18 22:22:22 claudio Exp $ */
d55 1
a55 1
	struct aspath_head		path_h;  /* list of all as pathes */
a60 2
struct as_segment {
	u_int8_t			type;	/* type of as path segment */
a62 5
	u_int8_t			len;	/* size in u_int16_t of object*/
	u_int16_t			as_num[1]; /* in network byte order */
	/* this beast is variable sized */
};

d93 4
d198 1
a198 1
int		 attr_dump(u_char *, u_int16_t, struct attr_flags *);
d200 1
a200 1
int		 aspath_verify(u_char *, u_int16_t, u_int16_t);
d204 1
a204 1
struct aspath	*aspath_create(u_char *, u_int16_t);
@


1.2
log
@First step for configuration merges in the RDE. Currently this will not
work correctly because the peer id changes on config reload. The code in
the RDE per se should be OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d138 5
a142 5
	u_int32_t			 med;	/* multi exit disc */
	u_int32_t			 lpref;	/* local pref */
	u_int8_t			 aggr_atm; /* atomic aggregate */
	u_int16_t			 aggr_as;  /* aggregator as */
	struct in_addr			 aggr_ip;  /* aggregator ip */
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d49 1
d53 2
a54 1
	LIST_ENTRY(rde_peer)		peer_l;	/* hash list over all peers */
@

