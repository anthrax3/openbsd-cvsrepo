head	1.51;
access;
symbols
	OPENBSD_6_2:1.51.0.4
	OPENBSD_6_2_BASE:1.51
	OPENBSD_6_1:1.48.0.4
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.45.0.6
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.41.0.18
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.16
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.12
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.10
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.8
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.6
	OPENBSD_5_0:1.41.0.4
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.40.0.4
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.37.0.4
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.34.0.8
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.6
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.4
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.31.0.6
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.4
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14;
locks; strict;
comment	@ * @;


1.51
date	2017.08.21.14.43.33;	author phessler;	state Exp;
branches;
next	1.50;
commitid	w8HmSxD2kSqL3Ase;

1.50
date	2017.08.21.14.41.22;	author phessler;	state Exp;
branches;
next	1.49;
commitid	GKJPovOeNtV6hnQq;

1.49
date	2017.04.18.02.29.56;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	0b2VaK4OUJUaWS29;

1.48
date	2017.03.02.19.54.22;	author renato;	state Exp;
branches;
next	1.47;
commitid	ICicaMzABaoSDD9u;

1.47
date	2017.02.22.13.55.14;	author renato;	state Exp;
branches;
next	1.46;
commitid	jJ2W5Hz3cjuR3IvT;

1.46
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.45;
commitid	airB1W2Kb948lFil;

1.45
date	2015.09.13.10.22.16;	author florian;	state Exp;
branches;
next	1.44;
commitid	HzH0J9MKFddBLcZs;

1.44
date	2015.02.10.05.18.39;	author claudio;	state Exp;
branches;
next	1.43;
commitid	onDCg4G9cRuERxug;

1.43
date	2015.02.09.11.37.31;	author claudio;	state Exp;
branches;
next	1.42;
commitid	IcuyF0sCmFRE7OTK;

1.42
date	2014.10.08.16.15.37;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	8hXaK4f2GeAALziF;

1.41
date	2010.12.09.13.50.41;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2009.12.14.17.38.18;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.06.11.42.22;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2009.04.21.15.25.52;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2009.04.21.13.57.14;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2009.02.25.19.18.04;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.26.14.26.49;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.26.13.17.00;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.30.17.58.40;	author henning;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2004.11.10.14.48.25;	author claudio;	state Exp;
branches
	1.31.6.1;
next	1.30;

1.30
date	2004.05.28.18.39.09;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.06.14.51.11;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.06.14.41.47;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.28.04.59.32;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.28.03.53.35;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.28.03.34.38;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.28.03.19.52;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.28.02.57.00;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.28.00.59.09;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.28.00.38.39;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.27.22.42.13;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.27.18.35.48;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.27.17.56.57;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.27.04.38.12;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.26.09.35.39;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.31.10.25.35;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.15.16.00.59;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.30.23.12.51;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.28.23.31.28;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.28.20.03.30;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.28.20.00.29;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.28.19.04.55;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.28.17.57.08;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.28.17.27.55;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.28.14.24.29;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.28.11.03.32;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.27.14.12.28;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.27.14.09.36;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.26.17.50.53;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.26.14.42.47;	author henning;	state Exp;
branches;
next	;

1.31.6.1
date	2006.11.04.19.53.37;	author brad;	state Exp;
branches;
next	;

1.32.2.1
date	2006.11.04.05.19.06;	author brad;	state Exp;
branches;
next	;


desc
@@


1.51
log
@undo unintentional commits
@
text
@/*	$OpenBSD: pfkey.c,v 1.50 2017/08/21 14:41:22 phessler Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2003, 2004 Markus Friedl <markus@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <net/pfkeyv2.h>
#include <netinet/ip_ipsp.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "bgpd.h"
#include "session.h"
#include "log.h"

#define	PFKEY2_CHUNK sizeof(u_int64_t)
#define	ROUNDUP(x) (((x) + (PFKEY2_CHUNK - 1)) & ~(PFKEY2_CHUNK - 1))
#define	IOV_CNT	20

static u_int32_t	sadb_msg_seq = 0;
static u_int32_t	pid = 0; /* should pid_t but pfkey needs u_int32_t */
static int		fd;

int	pfkey_reply(int, u_int32_t *);
int	pfkey_send(int, uint8_t, uint8_t, uint8_t,
	    struct bgpd_addr *, struct bgpd_addr *,
	    u_int32_t, uint8_t, int, char *, uint8_t, int, char *,
	    uint16_t, uint16_t);
int	pfkey_sa_add(struct bgpd_addr *, struct bgpd_addr *, u_int8_t, char *,
	    u_int32_t *);
int	pfkey_sa_remove(struct bgpd_addr *, struct bgpd_addr *, u_int32_t *);
int	pfkey_md5sig_establish(struct peer *);
int	pfkey_md5sig_remove(struct peer *);
int	pfkey_ipsec_establish(struct peer *);
int	pfkey_ipsec_remove(struct peer *);

#define pfkey_flow(fd, satype, cmd, dir, from, to, sport, dport) \
	pfkey_send(fd, satype, cmd, dir, from, to, \
	    0, 0, 0, NULL, 0, 0, NULL, sport, dport)

int
pfkey_send(int sd, uint8_t satype, uint8_t mtype, uint8_t dir,
    struct bgpd_addr *src, struct bgpd_addr *dst, u_int32_t spi,
    uint8_t aalg, int alen, char *akey, uint8_t ealg, int elen, char *ekey,
    uint16_t sport, uint16_t dport)
{
	struct sadb_msg		smsg;
	struct sadb_sa		sa;
	struct sadb_address	sa_src, sa_dst, sa_peer, sa_smask, sa_dmask;
	struct sadb_key		sa_akey, sa_ekey;
	struct sadb_spirange	sa_spirange;
	struct sadb_protocol	sa_flowtype, sa_protocol;
	struct iovec		iov[IOV_CNT];
	ssize_t			n;
	int			len = 0;
	int			iov_cnt;
	struct sockaddr_storage	ssrc, sdst, speer, smask, dmask;
	struct sockaddr		*saptr;

	if (!pid)
		pid = getpid();

	/* we need clean sockaddr... no ports set */
	bzero(&ssrc, sizeof(ssrc));
	bzero(&smask, sizeof(smask));
	if ((saptr = addr2sa(src, 0)))
		memcpy(&ssrc, saptr, sizeof(ssrc));
	switch (src->aid) {
	case AID_INET:
		memset(&((struct sockaddr_in *)&smask)->sin_addr, 0xff, 32/8);
		break;
	case AID_INET6:
		memset(&((struct sockaddr_in6 *)&smask)->sin6_addr, 0xff,
		    128/8);
		break;
	case AID_UNSPEC:
		ssrc.ss_len = sizeof(struct sockaddr);
		break;
	default:
		return (-1);
	}
	smask.ss_family = ssrc.ss_family;
	smask.ss_len = ssrc.ss_len;

	bzero(&sdst, sizeof(sdst));
	bzero(&dmask, sizeof(dmask));
	if ((saptr = addr2sa(dst, 0)))
		memcpy(&sdst, saptr, sizeof(sdst));
	switch (dst->aid) {
	case AID_INET:
		memset(&((struct sockaddr_in *)&dmask)->sin_addr, 0xff, 32/8);
		break;
	case AID_INET6:
		memset(&((struct sockaddr_in6 *)&dmask)->sin6_addr, 0xff,
		    128/8);
		break;
	case AID_UNSPEC:
		sdst.ss_len = sizeof(struct sockaddr);
		break;
	default:
		return (-1);
	}
	dmask.ss_family = sdst.ss_family;
	dmask.ss_len = sdst.ss_len;

	bzero(&smsg, sizeof(smsg));
	smsg.sadb_msg_version = PF_KEY_V2;
	smsg.sadb_msg_seq = ++sadb_msg_seq;
	smsg.sadb_msg_pid = pid;
	smsg.sadb_msg_len = sizeof(smsg) / 8;
	smsg.sadb_msg_type = mtype;
	smsg.sadb_msg_satype = satype;

	switch (mtype) {
	case SADB_GETSPI:
		bzero(&sa_spirange, sizeof(sa_spirange));
		sa_spirange.sadb_spirange_exttype = SADB_EXT_SPIRANGE;
		sa_spirange.sadb_spirange_len = sizeof(sa_spirange) / 8;
		sa_spirange.sadb_spirange_min = 0x100;
		sa_spirange.sadb_spirange_max = 0xffffffff;
		sa_spirange.sadb_spirange_reserved = 0;
		break;
	case SADB_ADD:
	case SADB_UPDATE:
	case SADB_DELETE:
		bzero(&sa, sizeof(sa));
		sa.sadb_sa_exttype = SADB_EXT_SA;
		sa.sadb_sa_len = sizeof(sa) / 8;
		sa.sadb_sa_replay = 0;
		sa.sadb_sa_spi = htonl(spi);
		sa.sadb_sa_state = SADB_SASTATE_MATURE;
		break;
	case SADB_X_ADDFLOW:
	case SADB_X_DELFLOW:
		bzero(&sa_flowtype, sizeof(sa_flowtype));
		sa_flowtype.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
		sa_flowtype.sadb_protocol_len = sizeof(sa_flowtype) / 8;
		sa_flowtype.sadb_protocol_direction = dir;
		sa_flowtype.sadb_protocol_proto = SADB_X_FLOW_TYPE_REQUIRE;

		bzero(&sa_protocol, sizeof(sa_protocol));
		sa_protocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
		sa_protocol.sadb_protocol_len = sizeof(sa_protocol) / 8;
		sa_protocol.sadb_protocol_direction = 0;
		sa_protocol.sadb_protocol_proto = 6;
		break;
	}

	bzero(&sa_src, sizeof(sa_src));
	sa_src.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
	sa_src.sadb_address_len = (sizeof(sa_src) + ROUNDUP(ssrc.ss_len)) / 8;

	bzero(&sa_dst, sizeof(sa_dst));
	sa_dst.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;

	sa.sadb_sa_auth = aalg;
	sa.sadb_sa_encrypt = SADB_X_EALG_AES; /* XXX */

	switch (mtype) {
	case SADB_ADD:
	case SADB_UPDATE:
		bzero(&sa_akey, sizeof(sa_akey));
		sa_akey.sadb_key_exttype = SADB_EXT_KEY_AUTH;
		sa_akey.sadb_key_len = (sizeof(sa_akey) +
		    ((alen + 7) / 8) * 8) / 8;
		sa_akey.sadb_key_bits = 8 * alen;

		bzero(&sa_ekey, sizeof(sa_ekey));
		sa_ekey.sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
		sa_ekey.sadb_key_len = (sizeof(sa_ekey) +
		    ((elen + 7) / 8) * 8) / 8;
		sa_ekey.sadb_key_bits = 8 * elen;

		break;
	case SADB_X_ADDFLOW:
	case SADB_X_DELFLOW:
		/* sa_peer always points to the remote machine */
		if (dir == IPSP_DIRECTION_IN) {
			speer = ssrc;
			sa_peer = sa_src;
		} else {
			speer = sdst;
			sa_peer = sa_dst;
		}
		sa_peer.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
		sa_peer.sadb_address_len =
		    (sizeof(sa_peer) + ROUNDUP(speer.ss_len)) / 8;

		/* for addflow we also use src/dst as the flow destination */
		sa_src.sadb_address_exttype = SADB_X_EXT_SRC_FLOW;
		sa_dst.sadb_address_exttype = SADB_X_EXT_DST_FLOW;

		bzero(&smask, sizeof(smask));
		switch (src->aid) {
		case AID_INET:
			smask.ss_len = sizeof(struct sockaddr_in);
			smask.ss_family = AF_INET;
			memset(&((struct sockaddr_in *)&smask)->sin_addr,
			    0xff, 32/8);
			if (sport) {
				((struct sockaddr_in *)&ssrc)->sin_port =
				    htons(sport);
				((struct sockaddr_in *)&smask)->sin_port =
				    htons(0xffff);
			}
			break;
		case AID_INET6:
			smask.ss_len = sizeof(struct sockaddr_in6);
			smask.ss_family = AF_INET6;
			memset(&((struct sockaddr_in6 *)&smask)->sin6_addr,
			    0xff, 128/8);
			if (sport) {
				((struct sockaddr_in6 *)&ssrc)->sin6_port =
				    htons(sport);
				((struct sockaddr_in6 *)&smask)->sin6_port =
				    htons(0xffff);
			}
			break;
		}
		bzero(&dmask, sizeof(dmask));
		switch (dst->aid) {
		case AID_INET:
			dmask.ss_len = sizeof(struct sockaddr_in);
			dmask.ss_family = AF_INET;
			memset(&((struct sockaddr_in *)&dmask)->sin_addr,
			    0xff, 32/8);
			if (dport) {
				((struct sockaddr_in *)&sdst)->sin_port =
				    htons(dport);
				((struct sockaddr_in *)&dmask)->sin_port =
				    htons(0xffff);
			}
			break;
		case AID_INET6:
			dmask.ss_len = sizeof(struct sockaddr_in6);
			dmask.ss_family = AF_INET6;
			memset(&((struct sockaddr_in6 *)&dmask)->sin6_addr,
			    0xff, 128/8);
			if (dport) {
				((struct sockaddr_in6 *)&sdst)->sin6_port =
				    htons(dport);
				((struct sockaddr_in6 *)&dmask)->sin6_port =
				    htons(0xffff);
			}
			break;
		}

		bzero(&sa_smask, sizeof(sa_smask));
		sa_smask.sadb_address_exttype = SADB_X_EXT_SRC_MASK;
		sa_smask.sadb_address_len =
		    (sizeof(sa_smask) + ROUNDUP(smask.ss_len)) / 8;

		bzero(&sa_dmask, sizeof(sa_dmask));
		sa_dmask.sadb_address_exttype = SADB_X_EXT_DST_MASK;
		sa_dmask.sadb_address_len =
		    (sizeof(sa_dmask) + ROUNDUP(dmask.ss_len)) / 8;
		break;
	}

	iov_cnt = 0;

	/* msghdr */
	iov[iov_cnt].iov_base = &smsg;
	iov[iov_cnt].iov_len = sizeof(smsg);
	iov_cnt++;

	switch (mtype) {
	case SADB_ADD:
	case SADB_UPDATE:
	case SADB_DELETE:
		/* SA hdr */
		iov[iov_cnt].iov_base = &sa;
		iov[iov_cnt].iov_len = sizeof(sa);
		smsg.sadb_msg_len += sa.sadb_sa_len;
		iov_cnt++;
		break;
	case SADB_GETSPI:
		/* SPI range */
		iov[iov_cnt].iov_base = &sa_spirange;
		iov[iov_cnt].iov_len = sizeof(sa_spirange);
		smsg.sadb_msg_len += sa_spirange.sadb_spirange_len;
		iov_cnt++;
		break;
	case SADB_X_ADDFLOW:
		/* sa_peer always points to the remote machine */
		iov[iov_cnt].iov_base = &sa_peer;
		iov[iov_cnt].iov_len = sizeof(sa_peer);
		iov_cnt++;
		iov[iov_cnt].iov_base = &speer;
		iov[iov_cnt].iov_len = ROUNDUP(speer.ss_len);
		smsg.sadb_msg_len += sa_peer.sadb_address_len;
		iov_cnt++;

		/* FALLTHROUGH */
	case SADB_X_DELFLOW:
		/* add flow type */
		iov[iov_cnt].iov_base = &sa_flowtype;
		iov[iov_cnt].iov_len = sizeof(sa_flowtype);
		smsg.sadb_msg_len += sa_flowtype.sadb_protocol_len;
		iov_cnt++;

		/* add protocol */
		iov[iov_cnt].iov_base = &sa_protocol;
		iov[iov_cnt].iov_len = sizeof(sa_protocol);
		smsg.sadb_msg_len += sa_protocol.sadb_protocol_len;
		iov_cnt++;

		/* add flow masks */
		iov[iov_cnt].iov_base = &sa_smask;
		iov[iov_cnt].iov_len = sizeof(sa_smask);
		iov_cnt++;
		iov[iov_cnt].iov_base = &smask;
		iov[iov_cnt].iov_len = ROUNDUP(smask.ss_len);
		smsg.sadb_msg_len += sa_smask.sadb_address_len;
		iov_cnt++;

		iov[iov_cnt].iov_base = &sa_dmask;
		iov[iov_cnt].iov_len = sizeof(sa_dmask);
		iov_cnt++;
		iov[iov_cnt].iov_base = &dmask;
		iov[iov_cnt].iov_len = ROUNDUP(dmask.ss_len);
		smsg.sadb_msg_len += sa_dmask.sadb_address_len;
		iov_cnt++;
		break;
	}

	/* dest addr */
	iov[iov_cnt].iov_base = &sa_dst;
	iov[iov_cnt].iov_len = sizeof(sa_dst);
	iov_cnt++;
	iov[iov_cnt].iov_base = &sdst;
	iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
	smsg.sadb_msg_len += sa_dst.sadb_address_len;
	iov_cnt++;

	/* src addr */
	iov[iov_cnt].iov_base = &sa_src;
	iov[iov_cnt].iov_len = sizeof(sa_src);
	iov_cnt++;
	iov[iov_cnt].iov_base = &ssrc;
	iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
	smsg.sadb_msg_len += sa_src.sadb_address_len;
	iov_cnt++;

	switch (mtype) {
	case SADB_ADD:
	case SADB_UPDATE:
		if (alen) {
			/* auth key */
			iov[iov_cnt].iov_base = &sa_akey;
			iov[iov_cnt].iov_len = sizeof(sa_akey);
			iov_cnt++;
			iov[iov_cnt].iov_base = akey;
			iov[iov_cnt].iov_len = ((alen + 7) / 8) * 8;
			smsg.sadb_msg_len += sa_akey.sadb_key_len;
			iov_cnt++;
		}
		if (elen) {
			/* encryption key */
			iov[iov_cnt].iov_base = &sa_ekey;
			iov[iov_cnt].iov_len = sizeof(sa_ekey);
			iov_cnt++;
			iov[iov_cnt].iov_base = ekey;
			iov[iov_cnt].iov_len = ((elen + 7) / 8) * 8;
			smsg.sadb_msg_len += sa_ekey.sadb_key_len;
			iov_cnt++;
		}
		break;
	}

	len = smsg.sadb_msg_len * 8;
	do {
		n = writev(sd, iov, iov_cnt);
	} while (n == -1 && (errno == EAGAIN || errno == EINTR));

	if (n == -1) {
		log_warn("writev (%d/%d)", iov_cnt, len);
		return (-1);
	}

	return (0);
}

int
pfkey_read(int sd, struct sadb_msg *h)
{
	struct sadb_msg hdr;

	if (recv(sd, &hdr, sizeof(hdr), MSG_PEEK) != sizeof(hdr)) {
		if (errno == EAGAIN || errno == EINTR)
			return (0);
		log_warn("pfkey peek");
		return (-1);
	}

	/* XXX: Only one message can be outstanding. */
	if (hdr.sadb_msg_seq == sadb_msg_seq &&
	    hdr.sadb_msg_pid == pid) {
		if (h)
			bcopy(&hdr, h, sizeof(hdr));
		return (0);
	}

	/* not ours, discard */
	if (read(sd, &hdr, sizeof(hdr)) == -1) {
		if (errno == EAGAIN || errno == EINTR)
			return (0);
		log_warn("pfkey read");
		return (-1);
	}

	return (1);
}

int
pfkey_reply(int sd, u_int32_t *spi)
{
	struct sadb_msg hdr, *msg;
	struct sadb_ext *ext;
	struct sadb_sa *sa;
	u_int8_t *data;
	ssize_t len;
	int rv;

	do {
		rv = pfkey_read(sd, &hdr);
		if (rv == -1)
			return (-1);
	} while (rv);

	if (hdr.sadb_msg_errno != 0) {
		errno = hdr.sadb_msg_errno;
		if (errno == ESRCH)
			return (0);
		else {
			log_warn("pfkey");
			return (-1);
		}
	}
	if ((data = reallocarray(NULL, hdr.sadb_msg_len, PFKEY2_CHUNK)) == NULL) {
		log_warn("pfkey malloc");
		return (-1);
	}
	len = hdr.sadb_msg_len * PFKEY2_CHUNK;
	if (read(sd, data, len) != len) {
		log_warn("pfkey read");
		freezero(data, len);
		return (-1);
	}

	if (hdr.sadb_msg_type == SADB_GETSPI) {
		if (spi == NULL) {
			freezero(data, len);
			return (0);
		}

		msg = (struct sadb_msg *)data;
		for (ext = (struct sadb_ext *)(msg + 1);
		    (size_t)((u_int8_t *)ext - (u_int8_t *)msg) <
		    msg->sadb_msg_len * PFKEY2_CHUNK;
		    ext = (struct sadb_ext *)((u_int8_t *)ext +
		    ext->sadb_ext_len * PFKEY2_CHUNK)) {
			if (ext->sadb_ext_type == SADB_EXT_SA) {
				sa = (struct sadb_sa *) ext;
				*spi = ntohl(sa->sadb_sa_spi);
				break;
			}
		}
	}
	freezero(data, len);
	return (0);
}

int
pfkey_sa_add(struct bgpd_addr *src, struct bgpd_addr *dst, u_int8_t keylen,
    char *key, u_int32_t *spi)
{
	if (pfkey_send(fd, SADB_X_SATYPE_TCPSIGNATURE, SADB_GETSPI, 0,
	    src, dst, 0, 0, 0, NULL, 0, 0, NULL, 0, 0) < 0)
		return (-1);
	if (pfkey_reply(fd, spi) < 0)
		return (-1);
	if (pfkey_send(fd, SADB_X_SATYPE_TCPSIGNATURE, SADB_UPDATE, 0,
		src, dst, *spi, 0, keylen, key, 0, 0, NULL, 0, 0) < 0)
		return (-1);
	if (pfkey_reply(fd, NULL) < 0)
		return (-1);
	return (0);
}

int
pfkey_sa_remove(struct bgpd_addr *src, struct bgpd_addr *dst, u_int32_t *spi)
{
	if (pfkey_send(fd, SADB_X_SATYPE_TCPSIGNATURE, SADB_DELETE, 0,
	    src, dst, *spi, 0, 0, NULL, 0, 0, NULL, 0, 0) < 0)
		return (-1);
	if (pfkey_reply(fd, NULL) < 0)
		return (-1);
	*spi = 0;
	return (0);
}

int
pfkey_md5sig_establish(struct peer *p)
{
	sleep(1);

	if (!p->auth.spi_out)
		if (pfkey_sa_add(&p->auth.local_addr, &p->conf.remote_addr,
		    p->conf.auth.md5key_len, p->conf.auth.md5key,
		    &p->auth.spi_out) == -1)
			return (-1);
	if (!p->auth.spi_in)
		if (pfkey_sa_add(&p->conf.remote_addr, &p->auth.local_addr,
		    p->conf.auth.md5key_len, p->conf.auth.md5key,
		    &p->auth.spi_in) == -1)
			return (-1);

	p->auth.established = 1;
	return (0);
}

int
pfkey_md5sig_remove(struct peer *p)
{
	if (p->auth.spi_out)
		if (pfkey_sa_remove(&p->auth.local_addr, &p->conf.remote_addr,
		    &p->auth.spi_out) == -1)
			return (-1);
	if (p->auth.spi_in)
		if (pfkey_sa_remove(&p->conf.remote_addr, &p->auth.local_addr,
		    &p->auth.spi_in) == -1)
			return (-1);

	p->auth.established = 0;
	return (0);
}

int
pfkey_ipsec_establish(struct peer *p)
{
	uint8_t satype = SADB_SATYPE_ESP;

	switch (p->auth.method) {
	case AUTH_IPSEC_IKE_ESP:
		satype = SADB_SATYPE_ESP;
		break;
	case AUTH_IPSEC_IKE_AH:
		satype = SADB_SATYPE_AH;
		break;
	case AUTH_IPSEC_MANUAL_ESP:
	case AUTH_IPSEC_MANUAL_AH:
		satype = p->auth.method == AUTH_IPSEC_MANUAL_ESP ?
		    SADB_SATYPE_ESP : SADB_SATYPE_AH;
		if (pfkey_send(fd, satype, SADB_ADD, 0,
		    &p->auth.local_addr, &p->conf.remote_addr,
		    p->auth.spi_out,
		    p->conf.auth.auth_alg_out,
		    p->conf.auth.auth_keylen_out,
		    p->conf.auth.auth_key_out,
		    p->conf.auth.enc_alg_out,
		    p->conf.auth.enc_keylen_out,
		    p->conf.auth.enc_key_out,
		    0, 0) < 0)
			return (-1);
		if (pfkey_reply(fd, NULL) < 0)
			return (-1);
		if (pfkey_send(fd, satype, SADB_ADD, 0,
		    &p->conf.remote_addr, &p->auth.local_addr,
		    p->auth.spi_in,
		    p->conf.auth.auth_alg_in,
		    p->conf.auth.auth_keylen_in,
		    p->conf.auth.auth_key_in,
		    p->conf.auth.enc_alg_in,
		    p->conf.auth.enc_keylen_in,
		    p->conf.auth.enc_key_in,
		    0, 0) < 0)
			return (-1);
		if (pfkey_reply(fd, NULL) < 0)
			return (-1);
		break;
	default:
		return (-1);
		break;
	}

	if (pfkey_flow(fd, satype, SADB_X_ADDFLOW, IPSP_DIRECTION_OUT,
	    &p->auth.local_addr, &p->conf.remote_addr, 0, BGP_PORT) < 0)
		return (-1);
	if (pfkey_reply(fd, NULL) < 0)
		return (-1);

	if (pfkey_flow(fd, satype, SADB_X_ADDFLOW, IPSP_DIRECTION_OUT,
	    &p->auth.local_addr, &p->conf.remote_addr, BGP_PORT, 0) < 0)
		return (-1);
	if (pfkey_reply(fd, NULL) < 0)
		return (-1);

	if (pfkey_flow(fd, satype, SADB_X_ADDFLOW, IPSP_DIRECTION_IN,
	    &p->conf.remote_addr, &p->auth.local_addr, 0, BGP_PORT) < 0)
		return (-1);
	if (pfkey_reply(fd, NULL) < 0)
		return (-1);

	if (pfkey_flow(fd, satype, SADB_X_ADDFLOW, IPSP_DIRECTION_IN,
	    &p->conf.remote_addr, &p->auth.local_addr, BGP_PORT, 0) < 0)
		return (-1);
	if (pfkey_reply(fd, NULL) < 0)
		return (-1);

	p->auth.established = 1;
	return (0);
}

int
pfkey_ipsec_remove(struct peer *p)
{
	uint8_t satype;

	switch (p->auth.method) {
	case AUTH_IPSEC_IKE_ESP:
		satype = SADB_SATYPE_ESP;
		break;
	case AUTH_IPSEC_IKE_AH:
		satype = SADB_SATYPE_AH;
		break;
	case AUTH_IPSEC_MANUAL_ESP:
	case AUTH_IPSEC_MANUAL_AH:
		satype = p->auth.method == AUTH_IPSEC_MANUAL_ESP ?
		    SADB_SATYPE_ESP : SADB_SATYPE_AH;
		if (pfkey_send(fd, satype, SADB_DELETE, 0,
		    &p->auth.local_addr, &p->conf.remote_addr,
		    p->auth.spi_out, 0, 0, NULL, 0, 0, NULL,
		    0, 0) < 0)
			return (-1);
		if (pfkey_reply(fd, NULL) < 0)
			return (-1);

		if (pfkey_send(fd, satype, SADB_DELETE, 0,
		    &p->conf.remote_addr, &p->auth.local_addr,
		    p->auth.spi_in, 0, 0, NULL, 0, 0, NULL,
		    0, 0) < 0)
			return (-1);
		if (pfkey_reply(fd, NULL) < 0)
			return (-1);
		break;
	default:
		return (-1);
		break;
	}

	if (pfkey_flow(fd, satype, SADB_X_DELFLOW, IPSP_DIRECTION_OUT,
	    &p->auth.local_addr, &p->conf.remote_addr, 0, BGP_PORT) < 0)
		return (-1);
	if (pfkey_reply(fd, NULL) < 0)
		return (-1);

	if (pfkey_flow(fd, satype, SADB_X_DELFLOW, IPSP_DIRECTION_OUT,
	    &p->auth.local_addr, &p->conf.remote_addr, BGP_PORT, 0) < 0)
		return (-1);
	if (pfkey_reply(fd, NULL) < 0)
		return (-1);

	if (pfkey_flow(fd, satype, SADB_X_DELFLOW, IPSP_DIRECTION_IN,
	    &p->conf.remote_addr, &p->auth.local_addr, 0, BGP_PORT) < 0)
		return (-1);
	if (pfkey_reply(fd, NULL) < 0)
		return (-1);

	if (pfkey_flow(fd, satype, SADB_X_DELFLOW, IPSP_DIRECTION_IN,
	    &p->conf.remote_addr, &p->auth.local_addr, BGP_PORT, 0) < 0)
		return (-1);
	if (pfkey_reply(fd, NULL) < 0)
		return (-1);

	p->auth.established = 0;
	return (0);
}

int
pfkey_establish(struct peer *p)
{
	/*
	 * make sure we keep copies of everything we need to
	 * remove SAs and flows later again, even if the
	 * info in p->conf changed due to reload.
	 * We need: SPIs, method, local_addr, remote_addr.
	 * remote_addr cannot change, so no copy.
	 */
	memcpy(&p->auth.local_addr, &p->conf.local_addr,
	    sizeof(p->auth.local_addr));
	p->auth.method = p->conf.auth.method;
	p->auth.spi_in = p->conf.auth.spi_in;
	p->auth.spi_out = p->conf.auth.spi_out;

	if (!p->auth.method)
		return (0);
	else if (p->auth.method == AUTH_MD5SIG)
		return (pfkey_md5sig_establish(p));
	else
		return (pfkey_ipsec_establish(p));
}

int
pfkey_remove(struct peer *p)
{
	if (!p->auth.established)
		return (0);
	else if (p->auth.method == AUTH_MD5SIG)
		return (pfkey_md5sig_remove(p));
	else
		return (pfkey_ipsec_remove(p));
}

int
pfkey_init(struct bgpd_sysdep *sysdep)
{
	if ((fd = socket(PF_KEY, SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_KEY_V2)) == -1) {
		if (errno == EPROTONOSUPPORT) {
			log_warnx("PF_KEY not available, disabling ipsec");
			sysdep->no_pfkey = 1;
			return (-1);
		} else
			fatal("pfkey setup failed");
	}
	return (fd);
}
@


1.50
log
@When 'enforce neighbor-as no' is set, don't do a config-time check for the neighbor-as, as it is dynamic.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.49 2017/04/18 02:29:56 deraadt Exp $ */
d527 2
@


1.49
log
@use freezero()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.48 2017/03/02 19:54:22 renato Exp $ */
a526 2
	sleep(1);

@


1.48
log
@Fix breakage of md5 authentication.

The previous commit (rev 1.47) added a missing htonl in pfkey_send() but
didn't add a corresponding ntohl in pfkey_reply(). This patch fixes this.

Found the hard way by benno@@, who also suggested the rename of spip
to spi.

OK benno@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.47 2017/02/22 13:55:14 renato Exp $ */
d468 1
a468 2
		explicit_bzero(data, len);
		free(data);
d474 1
a474 2
			explicit_bzero(data, len);
			free(data);
d491 1
a491 2
	explicit_bzero(data, len);
	free(data);
@


1.47
log
@Add missing htonl for IPsec SPI.

Also, do not allow to configure SPI values in the 0..255 range. RFC 4302
and RFC 4303 say the following:
"The set of SPI values in the range 1 through 255 are reserved by the
Internet Assigned Numbers Authority (IANA) for future use; a reserved
SPI value will not normally be assigned by IANA unless the use of the
assigned SPI value is specified in an RFC.  The SPI value of zero (0)
is reserved for local, implementation-specific use and MUST NOT be
sent on the wire".

ok and tweak benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.46 2017/01/24 04:22:42 benno Exp $ */
d437 1
a437 1
pfkey_reply(int sd, u_int32_t *spip)
d474 1
a474 1
		if (spip == NULL) {
d488 1
a488 1
				*spip = sa->sadb_sa_spi;
@


1.46
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.45 2015/09/13 10:22:16 florian Exp $ */
d150 1
a150 1
		sa.sadb_sa_spi = spi;
@


1.45
log
@explicit_bzero() from  Michael McConville, thanks!
OK claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.44 2015/02/10 05:18:39 claudio Exp $ */
d34 1
@


1.44
log
@Make also the special sockets SOCK_NONBLOCK. For the routing socket add
a trigger for the case that not a full message has been read. Should not
be possible but lets see if this triggers somewhen.
With and OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.43 2015/02/09 11:37:31 claudio Exp $ */
d467 1
a467 1
		bzero(data, len);
d474 1
a474 1
			bzero(data, len);
d492 1
a492 1
	bzero(data, len);
@


1.43
log
@Kill session_socket_blockmode() and replace it with SOCK_CLOEXEC or
SOCK_NONBLOCK and accept4(). OK henning@@ tested & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.42 2014/10/08 16:15:37 deraadt Exp $ */
d410 2
d426 2
d741 2
a742 1
	if ((fd = socket(PF_KEY, SOCK_RAW | SOCK_CLOEXEC, PF_KEY_V2)) == -1) {
@


1.42
log
@Use reallocarray() throughout to spot multiplicative int overflow.
ok henning benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.41 2010/12/09 13:50:41 claudio Exp $ */
d737 1
a737 1
	if ((fd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1) {
@


1.41
log
@The PF_KEY socket is like the routing socket. It must be polled all the
time to consume broadcasted messages or the socket gets full and own
messages that are needed are lost. This fixes an infinit loop in
pfkey_reply that happens when bgpd tcp md5sum is used on a system that
also runs a larger IPsec setup.
OK henning, lot of patience, debuging and testing by Thomas Boernert
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.40 2009/12/14 17:38:18 claudio Exp $ */
d456 1
a456 2
	len = hdr.sadb_msg_len * PFKEY2_CHUNK;
	if ((data = malloc(len)) == NULL) {
d460 1
@


1.40
log
@addr2sa() will return NULL for AID_UNSPEC and pfkey_send() may end up with
one of the src/dst addrs as AID_UNSPEC. So we need to check for NULL before
copying. Fixes a crash seen with tcp-md5 enabled peers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.39 2009/12/06 11:42:22 claudio Exp $ */
d405 27
d439 1
d441 3
a443 3
	for (;;) {
		if (recv(sd, &hdr, sizeof(hdr), MSG_PEEK) != sizeof(hdr)) {
			log_warn("pfkey peek");
d445 1
a445 12
		}

		if (hdr.sadb_msg_seq == sadb_msg_seq &&
		    hdr.sadb_msg_pid == pid)
			break;

		/* not ours, discard */
		if (read(sd, &hdr, sizeof(hdr)) == -1) {
			log_warn("pfkey read");
			return (-1);
		}
	}
a740 3
			return (0);
		} else {
			log_warn("PF_KEY socket");
d742 2
a743 1
		}
d745 1
a745 1
	return (0);
@


1.39
log
@Doh, switch src and dst in memcpy calls or the wrong thing gets copied.
For some reasons memcpy has the argument reversed - grmbl.
Found the hard way by Insan Praja.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.38 2009/12/01 14:28:05 claudio Exp $ */
d77 1
d85 2
a86 1
	memcpy(&ssrc, addr2sa(src, 0), sizeof(ssrc));
d106 2
a107 1
	memcpy(&sdst, addr2sa(dst, 0), sizeof(sdst));
@


1.38
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.37 2009/04/21 15:25:52 henning Exp $ */
d84 1
a84 1
	memcpy(addr2sa(src, 0), &ssrc, sizeof(ssrc));
d104 1
a104 1
	memcpy(addr2sa(dst, 0), &sdst, sizeof(sdst));
@


1.37
log
@instead of calling getpid() all over the place do it once, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.36 2009/04/21 13:57:14 henning Exp $ */
d84 3
a86 5
	switch (src->af) {
	case AF_INET:
		((struct sockaddr_in *)&ssrc)->sin_addr = src->v4;
		ssrc.ss_len = sizeof(struct sockaddr_in);
		ssrc.ss_family = AF_INET;
d89 1
a89 5
	case AF_INET6:
		memcpy(&((struct sockaddr_in6 *)&ssrc)->sin6_addr,
		    &src->v6, sizeof(struct in6_addr));
		ssrc.ss_len = sizeof(struct sockaddr_in6);
		ssrc.ss_family = AF_INET6;
d93 1
a93 1
	case 0:
d104 3
a106 5
	switch (dst->af) {
	case AF_INET:
		((struct sockaddr_in *)&sdst)->sin_addr = dst->v4;
		sdst.ss_len = sizeof(struct sockaddr_in);
		sdst.ss_family = AF_INET;
d109 1
a109 5
	case AF_INET6:
		memcpy(&((struct sockaddr_in6 *)&sdst)->sin6_addr,
		    &dst->v6, sizeof(struct in6_addr));
		sdst.ss_len = sizeof(struct sockaddr_in6);
		sdst.ss_family = AF_INET6;
d113 1
a113 1
	case 0:
d211 2
a212 2
		switch (src->af) {
		case AF_INET:
d224 1
a224 1
		case AF_INET6:
d238 2
a239 2
		switch (dst->af) {
		case AF_INET:
d251 1
a251 1
		case AF_INET6:
@


1.36
log
@ignore pfkey replies not for us and discard them
From: Matthew Dempsky <matthew@@dempsky.org>
markus and hshoexer and claudio agree
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.35 2009/02/25 19:18:04 henning Exp $ */
d40 1
d78 3
d137 1
a137 1
	smsg.sadb_msg_pid = getpid();
d429 1
a429 1
		    hdr.sadb_msg_pid == getpid())
@


1.35
log
@add a stupid workaround for a race somewhere in the crypto code in the
kernel. a one second sleep has made it go away in all my tests. ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.34 2006/10/26 14:26:49 henning Exp $ */
d39 1
a39 1
static u_int32_t	sadb_msg_seq = 1;
d132 1
a132 1
	smsg.sadb_msg_seq = sadb_msg_seq++;
d418 15
a432 3
	if (recv(sd, &hdr, sizeof(hdr), MSG_PEEK) != sizeof(hdr)) {
		log_warn("pfkey peek");
		return (-1);
d434 1
@


1.34
log
@        * make sure we keep copies of everything we need to
        * remove SAs and flows later again, even if the
        * configuration info changed due to reload.
        * We need: SPIs, method, local_addr, remote_addr.
        * remote_addr cannot change, so no copy.
with this, I have just migrated a session from tcp md5sig to ipsec esp ike,
just with bgpctl reload (both sides) followed by bgpctl neighbor $foo clear
(just one side)!
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.33 2006/10/26 13:17:00 henning Exp $ */
d500 2
@


1.33
log
@storing the dynamically acquired SPIs for tcpmd5 inside the conf struct
is not such a good idea - it gets nulled on config reloads, and thus
we fail to clear the old SAs when the session is restarted after a config
reload occured. obvious solution: store the SPIs outside the config area.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.32 2006/08/30 17:58:40 henning Exp $ */
d501 1
a501 1
		if (pfkey_sa_add(&p->conf.local_addr, &p->conf.remote_addr,
d506 1
a506 1
		if (pfkey_sa_add(&p->conf.remote_addr, &p->conf.local_addr,
d519 1
a519 1
		if (pfkey_sa_remove(&p->conf.local_addr, &p->conf.remote_addr,
d523 1
a523 1
		if (pfkey_sa_remove(&p->conf.remote_addr, &p->conf.local_addr,
a533 1
	struct peer_auth *auth = &p->conf.auth;
d536 1
a536 1
	switch (p->conf.auth.method) {
d545 1
a545 1
		satype = p->conf.auth.method == AUTH_IPSEC_MANUAL_ESP ?
d548 8
a555 6
		    &p->conf.local_addr, &p->conf.remote_addr,
		    auth->spi_out,
		    auth->auth_alg_out, auth->auth_keylen_out,
		    auth->auth_key_out,
		    auth->enc_alg_out, auth->enc_keylen_out,
		    auth->enc_key_out,
d561 8
a568 6
		    &p->conf.remote_addr, &p->conf.local_addr,
		    auth->spi_in,
		    auth->auth_alg_in, auth->auth_keylen_in,
		    auth->auth_key_in,
		    auth->enc_alg_in, auth->enc_keylen_in,
		    auth->enc_key_in,
d580 1
a580 1
	    &p->conf.local_addr, &p->conf.remote_addr, 0, BGP_PORT) < 0)
d586 1
a586 1
	    &p->conf.local_addr, &p->conf.remote_addr, BGP_PORT, 0) < 0)
d592 1
a592 1
	    &p->conf.remote_addr, &p->conf.local_addr, 0, BGP_PORT) < 0)
d598 1
a598 1
	    &p->conf.remote_addr, &p->conf.local_addr, BGP_PORT, 0) < 0)
d612 1
a612 1
	switch (p->conf.auth.method) {
d621 1
a621 1
		satype = p->conf.auth.method == AUTH_IPSEC_MANUAL_ESP ?
d624 2
a625 2
		    &p->conf.local_addr, &p->conf.remote_addr,
		    p->conf.auth.spi_out, 0, 0, NULL, 0, 0, NULL,
d632 2
a633 2
		    &p->conf.remote_addr, &p->conf.local_addr,
		    p->conf.auth.spi_in, 0, 0, NULL, 0, 0, NULL,
d645 1
a645 1
	    &p->conf.local_addr, &p->conf.remote_addr, 0, BGP_PORT) < 0)
d651 1
a651 1
	    &p->conf.local_addr, &p->conf.remote_addr, BGP_PORT, 0) < 0)
d657 1
a657 1
	    &p->conf.remote_addr, &p->conf.local_addr, 0, BGP_PORT) < 0)
d663 1
a663 1
	    &p->conf.remote_addr, &p->conf.local_addr, BGP_PORT, 0) < 0)
d675 14
a688 1
	if (!p->conf.auth.method)
d690 1
a690 1
	else if (p->conf.auth.method == AUTH_MD5SIG)
d701 1
a701 1
	else if (p->conf.auth.method == AUTH_MD5SIG)
@


1.32
log
@writing to the pfkey socket can give EAGAIN and we must retry.
ok claudio hshoexer deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.31 2004/11/10 14:48:25 claudio Exp $ */
d500 1
a500 1
	if (!p->conf.auth.spi_out)
d503 1
a503 1
		    &p->conf.auth.spi_out) == -1)
d505 1
a505 1
	if (!p->conf.auth.spi_in)
d508 1
a508 1
		    &p->conf.auth.spi_in) == -1)
d511 1
a511 1
	p->auth_established = 1;
d518 1
a518 1
	if (p->conf.auth.spi_out)
d520 1
a520 1
		    &p->conf.auth.spi_out) == -1)
d522 1
a522 1
	if (p->conf.auth.spi_in)
d524 1
a524 1
		    &p->conf.auth.spi_in) == -1)
d527 1
a527 1
	p->auth_established = 0;
d600 1
a600 1
	p->auth_established = 1;
d665 1
a665 1
	p->auth_established = 0;
d683 1
a683 1
	if (!p->auth_established)
@


1.32.2.1
log
@MFC:
Fix by henning@@

rev 1.33
make sure we keep copies of everything we need to
remove SAs and flows later again, even if the
configuration info changed due to reload.

rev 1.34
storing the dynamically acquired SPIs for tcpmd5 inside the conf struct
is not such a good idea - it gets nulled on config reloads, and thus
we fail to clear the old SAs when the session is restarted after a config
reload occured. obvious solution: store the SPIs outside the config
area.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.34 2006/10/26 14:26:49 henning Exp $ */
d500 2
a501 2
	if (!p->auth.spi_out)
		if (pfkey_sa_add(&p->auth.local_addr, &p->conf.remote_addr,
d503 1
a503 1
		    &p->auth.spi_out) == -1)
d505 2
a506 2
	if (!p->auth.spi_in)
		if (pfkey_sa_add(&p->conf.remote_addr, &p->auth.local_addr,
d508 1
a508 1
		    &p->auth.spi_in) == -1)
d511 1
a511 1
	p->auth.established = 1;
d518 3
a520 3
	if (p->auth.spi_out)
		if (pfkey_sa_remove(&p->auth.local_addr, &p->conf.remote_addr,
		    &p->auth.spi_out) == -1)
d522 3
a524 3
	if (p->auth.spi_in)
		if (pfkey_sa_remove(&p->conf.remote_addr, &p->auth.local_addr,
		    &p->auth.spi_in) == -1)
d527 1
a527 1
	p->auth.established = 0;
d534 1
d537 1
a537 1
	switch (p->auth.method) {
d546 1
a546 1
		satype = p->auth.method == AUTH_IPSEC_MANUAL_ESP ?
d549 6
a554 8
		    &p->auth.local_addr, &p->conf.remote_addr,
		    p->auth.spi_out,
		    p->conf.auth.auth_alg_out,
		    p->conf.auth.auth_keylen_out,
		    p->conf.auth.auth_key_out,
		    p->conf.auth.enc_alg_out,
		    p->conf.auth.enc_keylen_out,
		    p->conf.auth.enc_key_out,
d560 6
a565 8
		    &p->conf.remote_addr, &p->auth.local_addr,
		    p->auth.spi_in,
		    p->conf.auth.auth_alg_in,
		    p->conf.auth.auth_keylen_in,
		    p->conf.auth.auth_key_in,
		    p->conf.auth.enc_alg_in,
		    p->conf.auth.enc_keylen_in,
		    p->conf.auth.enc_key_in,
d577 1
a577 1
	    &p->auth.local_addr, &p->conf.remote_addr, 0, BGP_PORT) < 0)
d583 1
a583 1
	    &p->auth.local_addr, &p->conf.remote_addr, BGP_PORT, 0) < 0)
d589 1
a589 1
	    &p->conf.remote_addr, &p->auth.local_addr, 0, BGP_PORT) < 0)
d595 1
a595 1
	    &p->conf.remote_addr, &p->auth.local_addr, BGP_PORT, 0) < 0)
d600 1
a600 1
	p->auth.established = 1;
d609 1
a609 1
	switch (p->auth.method) {
d618 1
a618 1
		satype = p->auth.method == AUTH_IPSEC_MANUAL_ESP ?
d621 2
a622 2
		    &p->auth.local_addr, &p->conf.remote_addr,
		    p->auth.spi_out, 0, 0, NULL, 0, 0, NULL,
d629 2
a630 2
		    &p->conf.remote_addr, &p->auth.local_addr,
		    p->auth.spi_in, 0, 0, NULL, 0, 0, NULL,
d642 1
a642 1
	    &p->auth.local_addr, &p->conf.remote_addr, 0, BGP_PORT) < 0)
d648 1
a648 1
	    &p->auth.local_addr, &p->conf.remote_addr, BGP_PORT, 0) < 0)
d654 1
a654 1
	    &p->conf.remote_addr, &p->auth.local_addr, 0, BGP_PORT) < 0)
d660 1
a660 1
	    &p->conf.remote_addr, &p->auth.local_addr, BGP_PORT, 0) < 0)
d665 1
a665 1
	p->auth.established = 0;
d672 1
a672 14
	/*
	 * make sure we keep copies of everything we need to
	 * remove SAs and flows later again, even if the
	 * info in p->conf changed due to reload.
	 * We need: SPIs, method, local_addr, remote_addr.
	 * remote_addr cannot change, so no copy.
	 */
	memcpy(&p->auth.local_addr, &p->conf.local_addr,
	    sizeof(p->auth.local_addr));
	p->auth.method = p->conf.auth.method;
	p->auth.spi_in = p->conf.auth.spi_in;
	p->auth.spi_out = p->conf.auth.spi_out;

	if (!p->auth.method)
d674 1
a674 1
	else if (p->auth.method == AUTH_MD5SIG)
d683 1
a683 1
	if (!p->auth.established)
d685 1
a685 1
	else if (p->auth.method == AUTH_MD5SIG)
@


1.31
log
@"not reached" does not help LINT use NOTREACHED instead and use it only in
places where needed. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.30 2004/05/28 18:39:09 henning Exp $ */
d44 3
a46 3
    struct bgpd_addr *, struct bgpd_addr *,
    u_int32_t, uint8_t, int, char *, uint8_t, int, char *,
    uint16_t, uint16_t);
d397 5
a401 1
	if ((n = writev(sd, iov, iov_cnt)) == -1) {
a402 5
		return (-1);
	}

	if (n != len) {
		log_warn("writev: should=%d has=%d", len, n);
@


1.31.6.1
log
@MFC:
Fix by henning@@

rev 1.33
make sure we keep copies of everything we need to
remove SAs and flows later again, even if the
configuration info changed due to reload.

rev 1.34
storing the dynamically acquired SPIs for tcpmd5 inside the conf struct
is not such a good idea - it gets nulled on config reloads, and thus
we fail to clear the old SAs when the session is restarted after a config
reload occured. obvious solution: store the SPIs outside the config
area.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.34 2006/10/26 14:26:49 henning Exp $ */
d501 2
a502 2
	if (!p->auth.spi_out)
		if (pfkey_sa_add(&p->auth.local_addr, &p->conf.remote_addr,
d504 1
a504 1
		    &p->auth.spi_out) == -1)
d506 2
a507 2
	if (!p->auth.spi_in)
		if (pfkey_sa_add(&p->conf.remote_addr, &p->auth.local_addr,
d509 1
a509 1
		    &p->auth.spi_in) == -1)
d512 1
a512 1
	p->auth.established = 1;
d519 3
a521 3
	if (p->auth.spi_out)
		if (pfkey_sa_remove(&p->auth.local_addr, &p->conf.remote_addr,
		    &p->auth.spi_out) == -1)
d523 3
a525 3
	if (p->auth.spi_in)
		if (pfkey_sa_remove(&p->conf.remote_addr, &p->auth.local_addr,
		    &p->auth.spi_in) == -1)
d528 1
a528 1
	p->auth.established = 0;
d535 1
d538 1
a538 1
	switch (p->auth.method) {
d547 1
a547 1
		satype = p->auth.method == AUTH_IPSEC_MANUAL_ESP ?
d550 6
a555 8
		    &p->auth.local_addr, &p->conf.remote_addr,
		    p->auth.spi_out,
		    p->conf.auth.auth_alg_out,
		    p->conf.auth.auth_keylen_out,
		    p->conf.auth.auth_key_out,
		    p->conf.auth.enc_alg_out,
		    p->conf.auth.enc_keylen_out,
		    p->conf.auth.enc_key_out,
d561 6
a566 8
		    &p->conf.remote_addr, &p->auth.local_addr,
		    p->auth.spi_in,
		    p->conf.auth.auth_alg_in,
		    p->conf.auth.auth_keylen_in,
		    p->conf.auth.auth_key_in,
		    p->conf.auth.enc_alg_in,
		    p->conf.auth.enc_keylen_in,
		    p->conf.auth.enc_key_in,
d578 1
a578 1
	    &p->auth.local_addr, &p->conf.remote_addr, 0, BGP_PORT) < 0)
d584 1
a584 1
	    &p->auth.local_addr, &p->conf.remote_addr, BGP_PORT, 0) < 0)
d590 1
a590 1
	    &p->conf.remote_addr, &p->auth.local_addr, 0, BGP_PORT) < 0)
d596 1
a596 1
	    &p->conf.remote_addr, &p->auth.local_addr, BGP_PORT, 0) < 0)
d601 1
a601 1
	p->auth.established = 1;
d610 1
a610 1
	switch (p->auth.method) {
d619 1
a619 1
		satype = p->auth.method == AUTH_IPSEC_MANUAL_ESP ?
d622 2
a623 2
		    &p->auth.local_addr, &p->conf.remote_addr,
		    p->auth.spi_out, 0, 0, NULL, 0, 0, NULL,
d630 2
a631 2
		    &p->conf.remote_addr, &p->auth.local_addr,
		    p->auth.spi_in, 0, 0, NULL, 0, 0, NULL,
d643 1
a643 1
	    &p->auth.local_addr, &p->conf.remote_addr, 0, BGP_PORT) < 0)
d649 1
a649 1
	    &p->auth.local_addr, &p->conf.remote_addr, BGP_PORT, 0) < 0)
d655 1
a655 1
	    &p->conf.remote_addr, &p->auth.local_addr, 0, BGP_PORT) < 0)
d661 1
a661 1
	    &p->conf.remote_addr, &p->auth.local_addr, BGP_PORT, 0) < 0)
d666 1
a666 1
	p->auth.established = 0;
d673 1
a673 14
	/*
	 * make sure we keep copies of everything we need to
	 * remove SAs and flows later again, even if the
	 * info in p->conf changed due to reload.
	 * We need: SPIs, method, local_addr, remote_addr.
	 * remote_addr cannot change, so no copy.
	 */
	memcpy(&p->auth.local_addr, &p->conf.local_addr,
	    sizeof(p->auth.local_addr));
	p->auth.method = p->conf.auth.method;
	p->auth.spi_in = p->conf.auth.spi_in;
	p->auth.spi_out = p->conf.auth.spi_out;

	if (!p->auth.method)
d675 1
a675 1
	else if (p->auth.method == AUTH_MD5SIG)
d684 1
a684 1
	if (!p->auth.established)
d686 1
a686 1
	else if (p->auth.method == AUTH_MD5SIG)
@


1.30
log
@detect absence of PF_KEY interface and/or the TCP_MD5SIG setsockopts
at runtime and disable said subsystems if so. helps the guys porting bgpd
to $otherBSD, and is actually the right thing to do. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.29 2004/05/06 14:51:11 henning Exp $ */
a99 1
		/* not reached */
a125 1
		/* not reached */
@


1.29
log
@actually reset p->auth_established to 0 in pfkey_[md5sig|ipsec]_remove
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.28 2004/05/06 14:41:47 henning Exp $ */
d695 1
a695 1
pfkey_init(void)
d698 5
a702 3
		if (errno == EPROTONOSUPPORT)
			log_warnx("no kernel support for PF_KEY");
		else
d704 2
a705 1
		return (-1);
@


1.28
log
@we need a seperate field for the md5 key len, can't use strlen, noticed
by markus some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.27 2004/04/28 04:59:32 markus Exp $ */
d529 2
d668 1
@


1.27
log
@support for AH flows and SAs
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.26 2004/04/28 03:53:35 henning Exp $ */
d47 1
a47 1
int	pfkey_sa_add(struct bgpd_addr *, struct bgpd_addr *, char *,
d472 2
a473 2
pfkey_sa_add(struct bgpd_addr *src, struct bgpd_addr *dst, char *key,
    u_int32_t *spi)
d481 1
a481 1
		src, dst, *spi, 0, strlen(key), key, 0, 0, NULL, 0, 0) < 0)
d505 2
a506 1
		    p->conf.auth.md5key, &p->conf.auth.spi_out) == -1)
d510 2
a511 1
		    p->conf.auth.md5key, &p->conf.auth.spi_in) == -1)
@


1.26
log
@do not give up on ESRCH, someone might have mucked with ipsecadm behind
our back, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.25 2004/04/28 03:34:38 henning Exp $ */
d55 2
a56 2
#define pfkey_flow(fd, cmd, dir, from, to, sport, dport) \
	pfkey_send(fd, SADB_SATYPE_ESP, cmd, dir, from, to, \
d534 1
d536 12
a547 2
	if (p->conf.auth.method == AUTH_IPSEC_MANUAL_ESP) {
		if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_ADD, 0,
d558 1
a558 1
		if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_ADD, 0,
d569 4
d575 1
a575 1
	if (pfkey_flow(fd, SADB_X_ADDFLOW, IPSP_DIRECTION_OUT,
d581 1
a581 1
	if (pfkey_flow(fd, SADB_X_ADDFLOW, IPSP_DIRECTION_OUT,
d587 1
a587 1
	if (pfkey_flow(fd, SADB_X_ADDFLOW, IPSP_DIRECTION_IN,
d593 1
a593 1
	if (pfkey_flow(fd, SADB_X_ADDFLOW, IPSP_DIRECTION_IN,
d606 14
a619 2
	if (p->conf.auth.method == AUTH_IPSEC_MANUAL_ESP) {
		if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_DELETE, 0,
d627 1
a627 1
		if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_DELETE, 0,
d634 4
d640 1
a640 1
	if (pfkey_flow(fd, SADB_X_DELFLOW, IPSP_DIRECTION_OUT,
d646 1
a646 1
	if (pfkey_flow(fd, SADB_X_DELFLOW, IPSP_DIRECTION_OUT,
d652 1
a652 1
	if (pfkey_flow(fd, SADB_X_DELFLOW, IPSP_DIRECTION_IN,
d658 1
a658 1
	if (pfkey_flow(fd, SADB_X_DELFLOW, IPSP_DIRECTION_IN,
@


1.25
log
@make this at least compile
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.24 2004/04/28 03:19:52 markus Exp $ */
@


1.24
log
@make sure send and reply are in sync; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.23 2004/04/28 02:57:00 henning Exp $ */
d427 6
a432 2
		log_warn("pfkey");
		return (-1);
@


1.23
log
@keep track of which ipsec/md5 SAs we inserted - ESRCH on blind removal
otherwise, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.22 2004/04/28 00:59:09 markus Exp $ */
d541 2
d552 2
d559 2
d565 2
d571 2
d577 2
d593 2
d601 2
d608 2
d614 2
d620 2
d625 2
@


1.22
log
@don't load SAs into the kernel if IKE is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.21 2004/04/28 00:38:39 henning Exp $ */
d507 2
d568 1
d622 1
a622 1
	if (!p->conf.auth.method)
@


1.21
log
@prefix the auth related defines by AUTH_, we had a name clash, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.20 2004/04/27 22:42:13 henning Exp $ */
d50 2
a51 2
int	pfkey_auth_establish(struct peer *);
int	pfkey_auth_remove(struct peer *);
d497 1
a497 1
pfkey_auth_establish(struct peer *p)
a498 3
	if (p->conf.auth.method != AUTH_MD5SIG)
		return (0);

a502 1

a506 1

d511 1
a511 1
pfkey_auth_remove(struct peer *p)
a512 3
	if (p->conf.auth.method != AUTH_MD5SIG)
		return (0);

a516 1

a520 1

a521 1

d529 20
a548 18
	if (!auth->spi_in || !auth->spi_out)
		return (0);

	if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_ADD, 0,
	    &p->conf.local_addr, &p->conf.remote_addr,
	    auth->spi_out,
	    auth->auth_alg_out, auth->auth_keylen_out, auth->auth_key_out,
	    auth->enc_alg_out, auth->enc_keylen_out, auth->enc_key_out,
	    0, 0) < 0)
		return (-1);

	if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_ADD, 0,
	    &p->conf.remote_addr, &p->conf.local_addr,
	    auth->spi_in,
	    auth->auth_alg_in, auth->auth_keylen_in, auth->auth_key_in,
	    auth->enc_alg_in, auth->enc_keylen_in, auth->enc_key_in,
	    0, 0) < 0)
		return (-1);
d572 6
a577 4
	if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_DELETE, 0,
	    &p->conf.local_addr, &p->conf.remote_addr,
	    p->conf.auth.spi_out, 0, 0, NULL, 0, 0, NULL, 0, 0) < 0)
		return (-1);
d579 6
a584 4
	if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_DELETE, 0,
	    &p->conf.remote_addr, &p->conf.local_addr,
	    p->conf.auth.spi_in, 0, 0, NULL, 0, 0, NULL, 0, 0) < 0)
		return (-1);
d608 5
a612 1
	if (p->conf.auth.spi_in)
a613 2
	else
		return (pfkey_auth_establish(p));
d619 5
a623 1
	if (p->conf.auth.spi_in)
a624 3
	else
		return (pfkey_auth_remove(p));

a636 1

@


1.20
log
@rename the ipsec struct to auth, move all tcpmd5 related fields in there, and
add a generic "method" field that expresses what method
(none/md5sig/ipsec manual/ipsec ike) is in use
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.19 2004/04/27 18:35:48 henning Exp $ */
d499 1
a499 1
	if (p->conf.auth.method != MD5SIG)
d518 1
a518 1
	if (p->conf.auth.method != MD5SIG)
@


1.19
log
@two missing breaks, repairs tcpmd5, with markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.18 2004/04/27 17:56:57 markus Exp $ */
d499 1
a499 1
	if (!p->conf.tcp_md5_key[0])
d502 1
a502 1
	if (!p->auth.spi_out)
d504 1
a504 1
		    p->conf.tcp_md5_key, &p->auth.spi_out) == -1)
d507 1
a507 1
	if (!p->auth.spi_in)
d509 1
a509 1
		    p->conf.tcp_md5_key, &p->auth.spi_in) == -1)
d518 4
a521 1
	if (p->auth.spi_out)
d523 1
a523 1
		    &p->auth.spi_out) == -1)
d526 1
a526 1
	if (p->auth.spi_in)
d528 1
a528 1
		    &p->auth.spi_in) == -1)
d538 1
a538 1
	struct peer_ipsec *ipsec = &p->conf.ipsec;
d540 1
a540 1
	if (!ipsec->spi_in || !ipsec->spi_out)
d545 3
a547 3
	    ipsec->spi_out,
	    ipsec->auth_alg_out, ipsec->auth_keylen_out, ipsec->auth_key_out,
	    ipsec->enc_alg_out, ipsec->enc_keylen_out, ipsec->enc_key_out,
d553 3
a555 3
	    ipsec->spi_in,
	    ipsec->auth_alg_in, ipsec->auth_keylen_in, ipsec->auth_key_in,
	    ipsec->enc_alg_in, ipsec->enc_keylen_in, ipsec->enc_key_in,
d583 1
a583 1
	    p->conf.ipsec.spi_out, 0, 0, NULL, 0, 0, NULL, 0, 0) < 0)
d588 1
a588 1
	    p->conf.ipsec.spi_in, 0, 0, NULL, 0, 0, NULL, 0, 0) < 0)
d613 1
a613 1
	if (p->conf.ipsec.spi_in)
d622 1
a622 1
	if (p->conf.ipsec.spi_in)
@


1.18
log
@restrict the ipsec flows to BGP only; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.17 2004/04/27 04:38:12 deraadt Exp $ */
d158 1
d310 1
@


1.17
log
@crud stripping; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.16 2004/04/26 09:35:39 markus Exp $ */
d45 2
a46 1
    u_int32_t, uint8_t, int, char *, uint8_t, int, char *);
d55 4
d62 2
a63 1
    uint8_t aalg, int alen, char *akey, uint8_t ealg, int elen, char *ekey)
d70 1
a70 1
	struct sadb_protocol	sa_protocol;
d75 1
a75 1
	struct sockaddr_storage	ssrc, sdst, smask, dmask;
d92 2
a93 1
		memset(&((struct sockaddr_in6 *)&smask)->sin6_addr, 0xff, 128/8);
d119 2
a120 1
		memset(&((struct sockaddr_in6 *)&dmask)->sin6_addr, 0xff, 128/8);
d160 6
d167 1
a167 1
		sa_protocol.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
d169 2
a170 2
		sa_protocol.sadb_protocol_direction = dir;
		sa_protocol.sadb_protocol_proto = SADB_X_FLOW_TYPE_REQUIRE;
d204 3
a206 4
		if (dir == IPSP_DIRECTION_OUT) {
			bcopy(&sa_src, &sa_peer, sizeof(sa_src));
			sa_peer.sadb_address_len =
			    (sizeof(sa_peer) + ROUNDUP(sdst.ss_len)) / 8;
d208 2
a209 3
			bcopy(&sa_dst, &sa_peer, sizeof(sa_dst));
			sa_peer.sadb_address_len =
			    (sizeof(sa_peer) + ROUNDUP(ssrc.ss_len)) / 8;
d212 2
d219 55
d314 2
a315 7
		if (dir == IPSP_DIRECTION_OUT) {
			iov[iov_cnt].iov_base = &sdst;
			iov[iov_cnt].iov_len = ROUNDUP(sdst.ss_len);
		} else {
			iov[iov_cnt].iov_base = &ssrc;
			iov[iov_cnt].iov_len = ROUNDUP(ssrc.ss_len);
		}
d322 6
d470 1
a470 1
	    src, dst, 0, 0, 0, NULL, 0, 0, NULL) < 0)
d475 1
a475 1
		src, dst, *spi, 0, strlen(key), key, 0, 0, NULL) < 0)
d486 1
a486 1
	    src, dst, *spi, 0, 0, NULL, 0, 0, NULL) < 0)
d542 2
a543 1
	    ipsec->enc_alg_out, ipsec->enc_keylen_out, ipsec->enc_key_out) < 0)
d550 2
a551 1
	    ipsec->enc_alg_in, ipsec->enc_keylen_in, ipsec->enc_key_in) < 0)
d554 10
a563 3
	if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_X_ADDFLOW, IPSP_DIRECTION_OUT,
	    &p->conf.local_addr, &p->conf.remote_addr,
	    0, 0, 0, NULL, 0, 0, NULL) < 0)
d566 2
a567 3
	if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_X_ADDFLOW, IPSP_DIRECTION_IN,
	    &p->conf.remote_addr, &p->conf.local_addr,
	    0, 0, 0, NULL, 0, 0, NULL) < 0)
d578 1
a578 1
	    p->conf.ipsec.spi_out, 0, 0, NULL, 0, 0, NULL) < 0)
d583 1
a583 1
	    p->conf.ipsec.spi_in, 0, 0, NULL, 0, 0, NULL) < 0)
d586 10
a595 3
	if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_X_DELFLOW, IPSP_DIRECTION_OUT,
	    &p->conf.local_addr, &p->conf.remote_addr,
	    0, 0, 0, NULL, 0, 0, NULL) < 0)
d598 2
a599 3
	if (pfkey_send(fd, SADB_SATYPE_ESP, SADB_X_DELFLOW, IPSP_DIRECTION_IN,
	    &p->conf.remote_addr, &p->conf.local_addr,
	    0, 0, 0, NULL, 0, 0, NULL) < 0)
@


1.16
log
@load ipsec SAs into the kernel and enable them.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.15 2004/03/31 10:25:35 henning Exp $ */
d64 1
a64 1
        struct sadb_protocol	sa_protocol;
@


1.15
log
@allow empty (wildcard) sockaddr for src or dst
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.14 2004/03/15 16:00:59 henning Exp $ */
d24 1
d37 1
a37 1
#define	IOV_CNT	8
d43 3
a45 2
int	pfkey_send(int, uint8_t, struct bgpd_addr *, struct bgpd_addr *,
    u_int32_t, char *);
d49 4
d55 3
a57 2
pfkey_send(int sd, uint8_t mtype, struct bgpd_addr *src,
    struct bgpd_addr *dst, u_int32_t spi, char *key)
d61 2
a62 2
	struct sadb_address	sa_src, sa_dst;
	struct sadb_key		sa_key;
d64 1
a66 1
	int			klen = 0;
d69 1
a69 1
	struct sockaddr_storage	ssrc, sdst;
d73 1
d79 1
d86 1
d95 2
d99 1
d105 1
d112 1
d121 2
d130 1
a130 1
	smsg.sadb_msg_satype = SADB_X_SATYPE_TCPSIGNATURE;
d150 7
d168 3
d174 40
a213 6
		bzero(&sa_key, sizeof(sa_key));
		klen = strlen(key);
		sa_key.sadb_key_exttype = SADB_EXT_KEY_AUTH;
		sa_key.sadb_key_len = (sizeof(sa_key) +
		    ((klen + 7) / 8) * 8) / 8;
		sa_key.sadb_key_bits = 8 * klen;
d240 39
d303 20
a322 8
		/* auth key */
		iov[iov_cnt].iov_base = &sa_key;
		iov[iov_cnt].iov_len = sizeof(sa_key);
		iov_cnt++;
		iov[iov_cnt].iov_base = key;
		iov[iov_cnt].iov_len = ((klen + 7) / 8) * 8;
		smsg.sadb_msg_len += sa_key.sadb_key_len;
		iov_cnt++;
d399 2
a400 1
	if (pfkey_send(fd, SADB_GETSPI, src, dst, 0, NULL) < 0)
d404 2
a405 1
	if (pfkey_send(fd, SADB_UPDATE, src, dst, *spi, key) < 0)
d415 2
a416 1
	if (pfkey_send(fd, SADB_DELETE, src, dst, *spi, NULL) < 0)
d457 81
@


1.14
log
@use switch instead of if { } else if { } else { }
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.13 2004/01/30 23:12:51 henning Exp $ */
d78 3
d98 3
@


1.13
log
@missing free() in an error path that should be unreachable
From: Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.12 2004/01/28 23:31:28 henning Exp $ */
d66 2
a67 1
	if (src->af == AF_INET) {
d71 2
a72 1
	} else if (src->af == AF_INET6) {
d77 2
a78 1
	} else {
d80 1
d84 2
a85 1
	if (dst->af == AF_INET) {
d89 2
a90 1
	} else if (dst->af == AF_INET6) {
d95 2
a96 1
	} else {
d98 1
@


1.12
log
@implement
  tcp md5sig password
so that the key can be given in ascii, what unfortunately limits the key space
(cisco/juniper compat...)
we keep the ability to specify the key in hex whithout these limits.

help & ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.11 2004/01/28 20:03:30 henning Exp $ */
d245 3
a247 1
		if (spip == NULL)
d249 1
@


1.11
log
@-rename pfkey_setkey to pfkey_sa_add
-implement pfkey_sa_remove
-use it in pfkey_auth_remove
we now properly remove the SAs we added on bgpd shutdown

ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.7 2004/01/28 17:27:55 henning Exp $ */
a60 1
	int			i;
a61 2
	char			realkey[TCP_SIGN_KEY_LEN];
	char			s[3];
d134 1
a134 1
		klen = strlen(key) / 2;
a138 11

		for (i = 0; i < klen; i++) {
			s[0] = key[2*i];
			s[1] = key[2*i + 1];
			s[2] = 0;
			if (!isxdigit(s[0]) || !isxdigit(s[1])) {
				log_warnx("tcpmd5 must be specified in hex");
				return (-1);
			}
			realkey[i] = strtoul(s, NULL, 16);
		}
d193 1
a193 1
		iov[iov_cnt].iov_base = realkey;
d295 1
a295 1
	if (!p->conf.tcp_sign_key[0])
d300 1
a300 1
		    p->conf.tcp_sign_key, &p->auth.spi_out) == -1)
d305 1
a305 1
		    p->conf.tcp_sign_key, &p->auth.spi_in) == -1)
@


1.10
log
@fix pfkey_reply() logic:
we always need to read the full message or we find old crap next time
much more difficult to find than it sounds here...
with & ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.9 2004/01/28 19:04:55 henning Exp $ */
d44 1
a44 1
int	pfkey_setkey(struct bgpd_addr *, struct bgpd_addr *, char *,
d46 1
d281 1
a281 1
pfkey_setkey(struct bgpd_addr *src, struct bgpd_addr *dst, char *key,
d296 11
d313 1
a313 1
		if (pfkey_setkey(&p->conf.local_addr, &p->conf.remote_addr,
d318 1
a318 1
		if (pfkey_setkey(&p->conf.remote_addr, &p->conf.local_addr,
d328 10
@


1.9
log
@missing free and fix memset misuse; From: Patrick Latifi <pat@@eyeo.org>
tho i fixed that using bzero instead
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.8 2004/01/28 17:57:08 henning Exp $ */
a244 4
	if (spip == NULL)
		return (0);
	if (hdr.sadb_msg_type != SADB_GETSPI)
		return (-1);
d256 16
a271 10
	msg = (struct sadb_msg *)data;
	for (ext = (struct sadb_ext *)(msg + 1);
	    (size_t)((u_int8_t *)ext - (u_int8_t *)msg) <
	    msg->sadb_msg_len * PFKEY2_CHUNK;
	    ext = (struct sadb_ext *)((u_int8_t *)ext +
	    ext->sadb_ext_len * PFKEY2_CHUNK)) {
		if (ext->sadb_ext_type == SADB_EXT_SA) {
			sa = (struct sadb_sa *) ext;
			*spip = sa->sadb_sa_spi;
			break;
@


1.8
log
@we need a pfkey_init the gets us a PF_KEY socket before we drop privs
eases other code quite a bit in exchange...
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.7 2004/01/28 17:27:55 henning Exp $ */
d256 2
d272 1
a272 1
	memset(data, len, 0);
@


1.7
log
@-struct peer_auth to store the SPIs, linked into struct peer
-add pfkey_auth_establish(), which sets up flows for both directions and
 stores the SPIs in above struct
-add (yet dummy) pfkey_auth_remove()

with markus, ok claudio markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.6 2004/01/28 14:24:29 markus Exp $ */
d39 1
d279 7
a285 8
	int		sd;
	int		ret = -1;

	if ((sd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1) {
		if (errno == EPROTONOSUPPORT)
			log_warnx("no kernel support for PF_KEY");
		else
			log_warn("socket");
d287 1
a287 13
	}
	if (pfkey_send(sd, SADB_GETSPI, src, dst, 0, NULL) < 0)
		goto done;
	if (pfkey_reply(sd, spi) < 0)
		goto done;
	if (pfkey_send(sd, SADB_UPDATE, src, dst, *spi, key) < 0)
		goto done;
	if (pfkey_reply(sd, NULL) < 0)
		goto done;
	ret = 0;
done:
	close(sd);
	return (ret);
d312 14
@


1.6
log
@initial support for SADB_DELETE; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.5 2004/01/28 11:03:32 markus Exp $ */
d32 1
d43 2
d275 2
a276 1
pfkey_setkey(struct bgpd_addr *src, struct bgpd_addr *dst, char *key)
a277 1
	u_int32_t	spi = 0;
d290 1
a290 1
	if (pfkey_reply(sd, &spi) < 0)
d292 1
a292 1
	if (pfkey_send(sd, SADB_UPDATE, src, dst, spi, key) < 0)
d300 25
@


1.5
log
@pfkey_setkey: sockaddr -> bgpd_addr; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.4 2004/01/27 14:12:28 henning Exp $ */
d110 1
d117 6
d124 7
a150 8
	bzero(&sa_src, sizeof(sa_src));
	sa_src.sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
	sa_src.sadb_address_len = (sizeof(sa_src) + ROUNDUP(ssrc.ss_len)) / 8;

	bzero(&sa_dst, sizeof(sa_dst));
	sa_dst.sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	sa_dst.sadb_address_len = (sizeof(sa_dst) + ROUNDUP(sdst.ss_len)) / 8;

d161 1
@


1.4
log
@missing return()
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.3 2004/01/27 14:09:36 markus Exp $ */
d40 1
a40 1
int	pfkey_send(int, uint8_t, struct sockaddr *, struct sockaddr *,
d44 2
a45 2
pfkey_send(int sd, uint8_t mtype, struct sockaddr *src, struct sockaddr *dst,
    u_int32_t spi, char *key)
d64 2
a65 3
	if (src->sa_family == AF_INET) {
		((struct sockaddr_in *)&ssrc)->sin_addr.s_addr =
		    ((struct sockaddr_in *)src)->sin_addr.s_addr;
d68 1
a68 1
	} else if (src->sa_family == AF_INET6) {
d70 1
a70 2
		    &((struct sockaddr_in6 *)src)->sin6_addr,
		    sizeof(struct in6_addr));
d73 2
d78 2
a79 3
	if (dst->sa_family == AF_INET) {
		((struct sockaddr_in *)&sdst)->sin_addr.s_addr =
		    ((struct sockaddr_in *)dst)->sin_addr.s_addr;
d82 1
a82 1
	} else if (dst->sa_family == AF_INET6) {
d84 1
a84 2
		    &((struct sockaddr_in6 *)dst)->sin6_addr,
		    sizeof(struct in6_addr));
d87 2
d265 1
a265 1
pfkey_setkey(struct sockaddr *src, struct sockaddr *dst, char *key)
@


1.3
log
@use SADB_GETSPI/UPDATE for setting tcpmd5 keys; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.3 2004/01/27 14:00:08 markus Exp $ */
d212 2
@


1.2
log
@when we error out in send_sa_msg() close the file descriptor.
from Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfkey.c,v 1.1 2004/01/26 14:42:47 henning Exp $ */
d5 1
d33 2
a34 1
#define	ROUNDUP(x) (((x) + sizeof(u_int64_t) - 1) & ~(sizeof(u_int64_t) - 1))
d39 3
a41 1
int	send_sa_msg(struct iovec *, int, int);
d44 2
a45 43
send_sa_msg(struct iovec *iov, int cnt, int len)
{
	struct sadb_msg	sm;
	int		sd;
	ssize_t		n;

	if ((sd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2)) == -1) {
		if (errno == EPROTONOSUPPORT)
			log_warnx("no kernel support for PF_KEY");
		else
			log_warn("socket");
		return (-1);
	}

	if ((n = writev(sd, iov, cnt)) == -1) {
		log_warn("write");
		close(sd);
		return (-1);
	}

	if (n != len) {
		log_warn("writev: should=%d has=%d", len, n);
		close(sd);
		return (-1);
	}

	if (read(sd, &sm, sizeof(sm)) != sizeof(sm)) {
		log_warn("read");
		close(sd);
		return (-1);
	}
	close(sd);

	if (sm.sadb_msg_errno != 0) {
		errno = sm.sadb_msg_errno;
		log_warn("pfkey");
		return (-1);
	}
	return (0);
}

int
pfkey_signature(struct sockaddr *src, struct sockaddr *dst, char *key)
d51 1
d53 1
d55 1
d57 1
d96 1
a96 1
	smsg.sadb_msg_type = SADB_ADD;
d99 37
a135 6
	bzero(&sa, sizeof(sa));
	sa.sadb_sa_exttype = SADB_EXT_SA;
	sa.sadb_sa_len = sizeof(sa) / 8;
	sa.sadb_sa_replay = 0;
	sa.sadb_sa_spi = 0;
	sa.sadb_sa_state = SADB_SASTATE_MATURE;
d145 1
a145 16
	bzero(&sa_key, sizeof(sa_key));
	klen = strlen(key) / 2;
	sa_key.sadb_key_exttype = SADB_EXT_KEY_AUTH;
	sa_key.sadb_key_len = (sizeof(sa_key) + ((klen + 7) / 8) * 8) / 8;
	sa_key.sadb_key_bits = 8 * klen;

	for (i = 0; i < klen; i++) {
		s[0] = key[2*i];
		s[1] = key[2*i + 1];
		s[2] = 0;
		if (!isxdigit(s[0]) || !isxdigit(s[1])) {
			log_warnx("espkey must be specified in hex");
			return (-1);
		}
		realkey[i] = strtoul(s, NULL, 16);
	}
d148 21
a168 7
	iov[0].iov_base = &smsg;
	iov[0].iov_len = sizeof(smsg);

	/* SA hdr */
	iov[1].iov_base = &sa;
	iov[1].iov_len = sizeof(sa);
	smsg.sadb_msg_len += sa.sadb_sa_len;
d171 5
a175 4
	iov[2].iov_base = &sa_dst;
	iov[2].iov_len = sizeof(sa_dst);
	iov[3].iov_base = &sdst;
	iov[3].iov_len = ROUNDUP(sdst.ss_len);
d177 1
d180 5
a184 4
	iov[4].iov_base = &sa_src;
	iov[4].iov_len = sizeof(sa_src);
	iov[5].iov_base = &ssrc;
	iov[5].iov_len = ROUNDUP(ssrc.ss_len);
d186 15
d202 59
a260 6
	/* auth key */
	iov[6].iov_base = &sa_key;
	iov[6].iov_len = sizeof(sa_key);
	iov[7].iov_base = realkey;
	iov[7].iov_len = ((klen + 7) / 8) * 8;
	smsg.sadb_msg_len += sa_key.sadb_key_len;
d262 26
a287 1
	return (send_sa_msg(iov, IOV_CNT, smsg.sadb_msg_len * 8));
@


1.1
log
@first cut at tcpmd5 setup seupport from within bgpd. works so far.
with help from hshoexer@@ and markus@@
ok claudio@@ hshoexer@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d56 1
d62 1
d68 1
d71 2
a77 1
	close(sd);
@

