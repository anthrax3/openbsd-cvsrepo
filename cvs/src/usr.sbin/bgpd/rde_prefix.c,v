head	1.33;
access;
symbols
	OPENBSD_6_0:1.32.0.28
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.22
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.24
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.16
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.20
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.18
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.14
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.12
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.10
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.8
	OPENBSD_5_0:1.32.0.6
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.4
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.25.0.8
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.6
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.4
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13;
locks; strict;
comment	@ * @;


1.33
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.32;
commitid	airB1W2Kb948lFil;

1.32
date	2010.03.26.15.41.04;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.13.06.02.37;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2009.05.30.18.27.17;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2009.05.17.12.25.15;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2009.04.26.14.40.03;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2009.04.19.21.24.55;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.11.11.27.59;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.22.08.34.18;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2007.01.26.17.40.49;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.03.22.49.17;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.11.16.53.01;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.05.21.28.50;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.05.19.23.10;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2004.08.05.18.44.19;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.03.14.46.23;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.05.02.13.44;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.22.23.17.01;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.22.20.28.58;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.11.17.34.01;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.11.14.22.23;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.02.19.29.01;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.09.01.56.18;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.17.19.15.07;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.16.11.14.43;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.11.21.47.20;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.06.10.51.14;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.26.18.07.33;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.24.11.39.43;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.19.19.24.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;


desc
@@


1.33
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@/*	$OpenBSD: rde_prefix.c,v 1.32 2010/03/26 15:41:04 claudio Exp $ */

/*
 * Copyright (c) 2003, 2004 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>

#include "bgpd.h"
#include "rde.h"
#include "log.h"

/*
 * Prefix Table functions:
 * pt_add:    create new prefix and link it into the prefix table
 * pt_remove: Checks if there is no bgp prefix linked to the prefix,
 *            unlinks from the prefix table and frees the pt_entry.
 * pt_get:    get a prefix/prefixlen entry. While pt_lookup searches for the
 *            best matching prefix pt_get only finds the prefix/prefixlen
 *            entry. The speed of pt_get is important for the bgp updates.
 * pt_getaddr: convert the address into a struct bgpd_addr.
 * pt_lookup: lookup a IP in the prefix table. Mainly for "show ip bgp".
 * pt_empty:  returns true if there is no bgp prefix linked to the pt_entry.
 * pt_init:   initialize prefix table.
 * pt_alloc: allocate a AF specific pt_entry. Internal function.
 * pt_free:   free a pt_entry. Internal function.
 */

/* internal prototypes */
static struct pt_entry	*pt_alloc(struct pt_entry *);
static void		 pt_free(struct pt_entry *);

size_t	pt_sizes[AID_MAX] = AID_PTSIZE;

RB_HEAD(pt_tree, pt_entry);
RB_PROTOTYPE(pt_tree, pt_entry, pt_e, pt_prefix_cmp);
RB_GENERATE(pt_tree, pt_entry, pt_e, pt_prefix_cmp);

struct pt_tree	pttable;

void
pt_init(void)
{
	RB_INIT(&pttable);
}

void
pt_shutdown(void)
{
	if (!RB_EMPTY(&pttable))
		log_debug("pt_shutdown: tree is not empty.");
}

void
pt_getaddr(struct pt_entry *pte, struct bgpd_addr *addr)
{
	bzero(addr, sizeof(struct bgpd_addr));
	addr->aid = pte->aid;
	switch (addr->aid) {
	case AID_INET:
		addr->v4 = ((struct pt_entry4 *)pte)->prefix4;
		break;
	case AID_INET6:
		memcpy(&addr->v6, &((struct pt_entry6 *)pte)->prefix6,
		    sizeof(addr->v6));
		/* XXX scope_id ??? */
		break;
	case AID_VPN_IPv4:
		addr->vpn4.addr = ((struct pt_entry_vpn4 *)pte)->prefix4;
		addr->vpn4.rd = ((struct pt_entry_vpn4 *)pte)->rd;
		addr->vpn4.labellen = ((struct pt_entry_vpn4 *)pte)->labellen;
		memcpy(addr->vpn4.labelstack,
		    ((struct pt_entry_vpn4 *)pte)->labelstack,
		    addr->vpn4.labellen);
		break;
	default:
		fatalx("pt_getaddr: unknown af");
	}
}

struct pt_entry *
pt_fill(struct bgpd_addr *prefix, int prefixlen)
{
	static struct pt_entry4		pte4;
	static struct pt_entry6		pte6;
	static struct pt_entry_vpn4	pte_vpn4;
	in_addr_t			addr_hbo;

	switch (prefix->aid) {
	case AID_INET:
		bzero(&pte4, sizeof(pte4));
		pte4.aid = prefix->aid;
		if (prefixlen > 32)
			fatalx("pt_fill: bad IPv4 prefixlen");
		addr_hbo = ntohl(prefix->v4.s_addr);
		pte4.prefix4.s_addr = htonl(addr_hbo &
		    prefixlen2mask(prefixlen));
		pte4.prefixlen = prefixlen;
		return ((struct pt_entry *)&pte4);
	case AID_INET6:
		bzero(&pte6, sizeof(pte6));
		pte6.aid = prefix->aid;
		if (prefixlen > 128)
			fatalx("pt_get: bad IPv6 prefixlen");
		pte6.prefixlen = prefixlen;
		inet6applymask(&pte6.prefix6, &prefix->v6, prefixlen);
		return ((struct pt_entry *)&pte6);
	case AID_VPN_IPv4:
		bzero(&pte_vpn4, sizeof(pte_vpn4));
		pte_vpn4.aid = prefix->aid;
		if (prefixlen > 32)
			fatalx("pt_fill: bad IPv4 prefixlen");
		addr_hbo = ntohl(prefix->vpn4.addr.s_addr);
		pte_vpn4.prefix4.s_addr = htonl(addr_hbo &
		    prefixlen2mask(prefixlen));
		pte_vpn4.prefixlen = prefixlen;
		pte_vpn4.rd = prefix->vpn4.rd;
		pte_vpn4.labellen = prefix->vpn4.labellen;
		memcpy(pte_vpn4.labelstack, prefix->vpn4.labelstack,
		    prefix->vpn4.labellen);
		return ((struct pt_entry *)&pte_vpn4);
	default:
		fatalx("pt_fill: unknown af");
	}
}

struct pt_entry *
pt_get(struct bgpd_addr *prefix, int prefixlen)
{
	struct pt_entry	*pte;

	pte = pt_fill(prefix, prefixlen);
	return RB_FIND(pt_tree, &pttable, pte);
}

struct pt_entry *
pt_add(struct bgpd_addr *prefix, int prefixlen)
{
	struct pt_entry		*p = NULL;

	p = pt_fill(prefix, prefixlen);
	p = pt_alloc(p);

	if (RB_INSERT(pt_tree, &pttable, p) != NULL)
		fatalx("pt_add: insert failed");

	return (p);
}

void
pt_remove(struct pt_entry *pte)
{
	if (!pt_empty(pte))
		fatalx("pt_remove: entry still holds references");

	if (RB_REMOVE(pt_tree, &pttable, pte) == NULL)
		log_warnx("pt_remove: remove failed.");
	pt_free(pte);
}

struct pt_entry *
pt_lookup(struct bgpd_addr *addr)
{
	struct pt_entry	*p;
	int		 i;

	switch (addr->aid) {
	case AID_INET:
	case AID_VPN_IPv4:
		i = 32;
		break;
	case AID_INET6:
		i = 128;
		break;
	default:
		fatalx("pt_lookup: unknown af");
	}
	for (; i >= 0; i--) {
		p = pt_get(addr, i);
		if (p != NULL)
			return (p);
	}
	return (NULL);
}

int
pt_prefix_cmp(const struct pt_entry *a, const struct pt_entry *b)
{
	const struct pt_entry4		*a4, *b4;
	const struct pt_entry6		*a6, *b6;
	const struct pt_entry_vpn4	*va4, *vb4;
	int				 i;

	if (a->aid > b->aid)
		return (1);
	if (a->aid < b->aid)
		return (-1);

	switch (a->aid) {
	case AID_INET:
		a4 = (const struct pt_entry4 *)a;
		b4 = (const struct pt_entry4 *)b;
		if (ntohl(a4->prefix4.s_addr) > ntohl(b4->prefix4.s_addr))
			return (1);
		if (ntohl(a4->prefix4.s_addr) < ntohl(b4->prefix4.s_addr))
			return (-1);
		if (a4->prefixlen > b4->prefixlen)
			return (1);
		if (a4->prefixlen < b4->prefixlen)
			return (-1);
		return (0);
	case AID_INET6:
		a6 = (const struct pt_entry6 *)a;
		b6 = (const struct pt_entry6 *)b;

		i = memcmp(&a6->prefix6, &b6->prefix6, sizeof(struct in6_addr));
		if (i > 0)
			return (1);
		if (i < 0)
			return (-1);
		if (a6->prefixlen < b6->prefixlen)
			return (-1);
		if (a6->prefixlen > b6->prefixlen)
			return (1);
		return (0);
	case AID_VPN_IPv4:
		va4 = (const struct pt_entry_vpn4 *)a;
		vb4 = (const struct pt_entry_vpn4 *)b;
		if (ntohl(va4->prefix4.s_addr) > ntohl(vb4->prefix4.s_addr))
			return (1);
		if (ntohl(va4->prefix4.s_addr) < ntohl(vb4->prefix4.s_addr))
			return (-1);
		if (va4->prefixlen > vb4->prefixlen)
			return (1);
		if (va4->prefixlen < vb4->prefixlen)
			return (-1);
		if (betoh64(va4->rd) > betoh64(vb4->rd))
			return (1);
		if (betoh64(va4->rd) < betoh64(vb4->rd))
			return (-1);
		return (0);
	default:
		fatalx("pt_prefix_cmp: unknown af");
	}
	return (-1);
}

/*
 * Returns a pt_entry cloned from the one passed in.
 * Function may not return on failure.
 */
static struct pt_entry *
pt_alloc(struct pt_entry *op)
{
	struct pt_entry		*p;

	p = malloc(pt_sizes[op->aid]);
	if (p == NULL)
		fatal("pt_alloc");
	rdemem.pt_cnt[op->aid]++;
	memcpy(p, op, pt_sizes[op->aid]);

	return (p);
}

static void
pt_free(struct pt_entry *pte)
{
	rdemem.pt_cnt[pte->aid]--;
	free(pte);
}
@


1.32
log
@pt_add() is not allowed to fail, caller expects this behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.31 2010/01/13 06:02:37 claudio Exp $ */
d28 1
@


1.31
log
@Add support for BGP MPLS VPN aka RFC 4364. This is only the RDE part so
that it is possible to use OpenBGPD as a route-reflector for VPNv4.
Some clean up of the BGP MP code so that multiple protocols are easier
supported. kroute/kernel support not yet done but comming.
OK henning@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.30 2009/12/01 14:28:05 claudio Exp $ */
d160 2
a161 4
	if (RB_INSERT(pt_tree, &pttable, p) != NULL) {
		log_warnx("pt_add: insert failed");
		return (NULL);
	}
@


1.30
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.29 2009/05/30 18:27:17 claudio Exp $ */
d84 8
d100 4
a103 3
	static struct pt_entry4	pte4;
	static struct pt_entry6	pte6;
	in_addr_t		addr_hbo;
d108 1
a108 2
		if (af2aid(AF_INET, 0, &pte4.aid))
			fatalx("pt_fill: unknown aid");
d118 1
a118 2
		if (af2aid(AF_INET6, 0, &pte6.aid))
			fatalx("pt_fill: unknown aid");
d124 14
d139 1
a139 2
		log_warnx("pt_fill: unknown af");
		return (NULL);
d187 1
d207 4
a210 3
	const struct pt_entry4	*a4, *b4;
	const struct pt_entry6	*a6, *b6;
	int			 i;
d243 16
@


1.29
log
@Only use a single tree for all address families. There is no need for multiple
trees and the rib trees are also not split.
Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.28 2009/05/17 12:25:15 claudio Exp $ */
d41 1
a41 1
 * pt_alloc?: allocate a AF specific pt_entry. Internal function.
d46 1
a46 2
static struct pt_entry4	*pt_alloc4(void);
static struct pt_entry6	*pt_alloc6(void);
d49 2
d74 3
a76 3
	switch (pte->af) {
	case AF_INET:
		addr->af = pte->af;
d79 1
a79 2
	case AF_INET6:
		addr->af = pte->af;
d96 2
a97 2
	switch (prefix->af) {
	case AF_INET:
d99 2
d102 1
a102 2
			fatalx("pt_get: bad IPv4 prefixlen");
		pte4.af = AF_INET;
d108 1
a108 1
	case AF_INET6:
d110 2
a113 1
		pte6.af = AF_INET6;
d118 1
a118 1
		log_warnx("pt_get: unknown af");
d136 3
a138 28
	struct pt_entry4	*p4;
	struct pt_entry6	*p6;
	in_addr_t		 addr_hbo;

	switch (prefix->af) {
	case AF_INET:
		p4 = pt_alloc4();
		if (prefixlen > 32)
			fatalx("pt_add: bad IPv4 prefixlen");
		p4->af = AF_INET;
		p4->prefixlen = prefixlen;
		addr_hbo = ntohl(prefix->v4.s_addr);
		p4->prefix4.s_addr = htonl(addr_hbo &
		    prefixlen2mask(prefixlen));
		p = (struct pt_entry *)p4;
		break;
	case AF_INET6:
		p6 = pt_alloc6();
		if (prefixlen > 128)
			fatalx("pt_add: bad IPv6 prefixlen");
		p6->af = AF_INET6;
		p6->prefixlen = prefixlen;
		inet6applymask(&p6->prefix6, &prefix->v6, prefixlen);
		p = (struct pt_entry *)p6;
		break;
	default:
		fatalx("pt_add: unknown af");
	}
d165 2
a166 2
	switch (addr->af) {
	case AF_INET:
d169 1
a169 1
	case AF_INET6:
d190 1
a190 1
	if (a->af > b->af)
d192 1
a192 1
	if (a->af < b->af)
d195 2
a196 2
	switch (a->af) {
	case AF_INET:
d208 1
a208 1
	case AF_INET6:
d228 6
a233 3
/* returns a zeroed pt_entry function may not return on fail */
static struct pt_entry4 *
pt_alloc4(void)
d235 1
a235 1
	struct pt_entry4	*p;
d237 1
a237 1
	p = calloc(1, sizeof(*p));
d240 2
a241 8
	rdemem.pt4_cnt++;
	return (p);
}

static struct pt_entry6 *
pt_alloc6(void)
{
	struct pt_entry6	*p;
a242 4
	p = calloc(1, sizeof(*p));
	if (p == NULL)
		fatal("pt_alloc");
	rdemem.pt6_cnt++;
d249 1
a249 10
	switch (pte->af) {
	case AF_INET:
		rdemem.pt4_cnt--;
		break;
	case AF_INET6:
		rdemem.pt6_cnt--;
		break;
	default:
		break;
	}
@


1.28
log
@Rework most of the RDE to allow multiple RIBs. This is mostly preparation
work by changing the way the RDE DB is built. struct prefix and struct
pt_entry are simplified and extended with a rib_entry where the decision
tree is run on. From now on a prefix can only reside on one particular RIB
which simplifies the code a bit. Currently there are two fixed ribs
(adj-rib-in and the local-rib) which needs to be made more dynamic in
upcomming commits.
This is work in progress, the RDE seems to work for me and sthen@@ (no flames
comming out of our testrouters but there is still a lot missing)
Move into the tree to simplify developement -- henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.27 2009/04/26 14:40:03 claudio Exp $ */
d54 1
a54 2
struct pt_tree	pttable4;
struct pt_tree	pttable6;
d59 1
a59 2
	RB_INIT(&pttable4);
	RB_INIT(&pttable6);
d65 2
a66 4
	if (!RB_EMPTY(&pttable4))
		log_debug("pt_shutdown: IPv4 tree is not empty.");
	if (!RB_EMPTY(&pttable6))
		log_debug("pt_shutdown: IPv6 tree is not empty.");
d127 1
a127 9
	switch (prefix->af) {
	case AF_INET:
		return RB_FIND(pt_tree, &pttable4, pte);
	case AF_INET6:
		return RB_FIND(pt_tree, &pttable6, pte);
	default:
		log_warnx("pt_get: unknown af");
	}
	return (NULL);
a132 1
	struct pt_tree		*tree = NULL;
a148 1
		tree = &pttable4;
a157 1
		tree = &pttable6;
d163 1
a163 1
	if (RB_INSERT(pt_tree, tree, p) != NULL) {
d177 2
a178 13
	switch (pte->af) {
	case AF_INET:
		if (RB_REMOVE(pt_tree, &pttable4, pte) == NULL)
			log_warnx("pt_remove: remove failed.");
		break;
	case AF_INET6:
		if (RB_REMOVE(pt_tree, &pttable6, pte) == NULL)
			log_warnx("pt_remove: remove failed.");
		break;
	default:
		fatalx("pt_remove: unknown af");
	}

d190 1
a190 5
		for (i = 32; i >= 0; i--) {
			p = pt_get(addr, i);
			if (p != NULL)
				return (p);
		}
d193 1
a193 5
		for (i = 128; i >= 0; i--) {
			p = pt_get(addr, i);
			if (p != NULL)
				return (p);
		}
d197 5
@


1.27
log
@Unused defines from a time long long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.26 2009/04/19 21:24:55 claudio Exp $ */
a42 1
 * pt_restart used to restart a tree walk at the spot it was aborted earlier.
a48 3
static struct pt_entry	*pt_restart(struct pt_context *);

int	pt_prefix_cmp(const struct pt_entry *, const struct pt_entry *);
a72 6
int
pt_empty(struct pt_entry *pte)
{
	return LIST_EMPTY(&pte->prefix_h);
}

d94 1
a94 1
pt_get(struct bgpd_addr *prefix, int prefixlen)
d96 2
a97 2
	struct pt_entry4	pte4;
	struct pt_entry6	pte6;
d102 1
d110 1
a110 1
		return RB_FIND(pt_tree, &pttable4, (struct pt_entry *)&pte4);
d112 1
d118 18
a135 1
		return RB_FIND(pt_tree, &pttable6, (struct pt_entry *)&pte6);
a176 1
	LIST_INIT(&p->prefix_h);
d190 1
a190 1
		fatalx("pt_remove: entry not empty");
d209 1
a209 1
pt_lookup(struct bgpd_addr *prefix)
d214 1
a214 1
	switch (prefix->af) {
d217 1
a217 1
			p = pt_get(prefix, i);
d224 1
a224 1
			p = pt_get(prefix, i);
a234 52
void
pt_dump(void (*upcall)(struct pt_entry *, void *), void *arg, sa_family_t af)
{
	if (af == AF_INET || af == AF_UNSPEC)
		pt_dump_r(upcall, arg, AF_INET, NULL);
	if (af == AF_INET6 || af == AF_UNSPEC)
		pt_dump_r(upcall, arg, AF_INET6, NULL);
}

void
pt_dump_r(void (*upcall)(struct pt_entry *, void *), void *arg,
    sa_family_t af, struct pt_context *ctx)
{
	struct pt_entry	*p;
	unsigned int	 i;

	if (ctx == NULL || ctx->ctx_p.af != af) {
		switch (af) {
		case AF_INET:
			p = RB_MIN(pt_tree, &pttable4);
			break;
		case AF_INET6:
			p = RB_MIN(pt_tree, &pttable6);
			break;
		default:
			return;
		}
	} else
		p = pt_restart(ctx);

	for (i = 0; p != NULL; p = RB_NEXT(pt_tree, unused, p)) {
		if (ctx && i++ >= ctx->count) {
			/* store next start point */
			switch (p->af) {
			case AF_INET:
				ctx->ctx_p4 = *(struct pt_entry4 *)p;
				break;
			case AF_INET6:
				ctx->ctx_p6 = *(struct pt_entry6 *)p;
				break;
			default:
				fatalx("pt_dump_r: unknown af");
			}
			return;
		}
		upcall(p, arg);
	}

	if (ctx)
		ctx->done = 1;
}

d242 4
a245 2
	if (a->af != b->af)
		fatalx("king bula sez: comparing pears with apples");
a318 53
}

static struct pt_entry *
pt_restart(struct pt_context *ctx)
{
	struct pt_entry *tmp, *prev = NULL;
	int comp;

	/* first select correct tree */
	switch (ctx->ctx_p.af) {
	case AF_INET:
		tmp = RB_ROOT(&pttable4);
		break;
	case AF_INET6:
		tmp = RB_ROOT(&pttable6);
		break;
	default:
		fatalx("pt_restart: unknown af");
	}

	/* then try to find the element */
	while (tmp) {
		prev = tmp;
		comp = pt_prefix_cmp(&ctx->ctx_p, tmp);
		if (comp < 0)
			tmp = RB_LEFT(tmp, pt_e);
		else if (comp > 0)
			tmp = RB_RIGHT(tmp, pt_e);
		else
			return (tmp);
	}

	/* no match, empty tree */
	if (prev == NULL)
		return (NULL);

	/*
	 * no perfect match
	 * if last element was bigger use that as new start point
	 */
	if (comp < 0)
		return (prev);

	/* backtrack until parent is bigger */
	do {
		prev = RB_PARENT(prev, pt_e);
		if (prev == NULL)
			/* all elements in the tree are smaler */
			return (NULL);
		comp = pt_prefix_cmp(&ctx->ctx_p, prev);
	} while (comp > 0);

	return (prev);
@


1.26
log
@Correct function name in log_warnx().
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.25 2007/05/11 11:27:59 claudio Exp $ */
a53 2
#define MIN_PREFIX 0
#define MAX_PREFIX 32
@


1.25
log
@Various spelling fixes from Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.24 2007/02/22 08:34:18 henning Exp $ */
d173 1
a173 1
		log_warnx("prefix_add: insert failed");
@


1.24
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.23 2007/01/26 17:40:49 claudio Exp $ */
d33 1
a33 1
 *            unlinks form the prefix table and frees the pt_entry.
d38 1
a38 1
 * pt_lookup: lookup a IP in the prefix table. Manly for "show ip bgp".
@


1.23
log
@Massiv rework of the control imsg flow. Main changes:
- dedicated pipe between the SE and the RDE for control messages
- restartable RB tree dumps in the RDE
- queuing limits both in the SE and RDE
The result is a dramatic decrease of memory consumption on operations like
bgpctl show rib. Previously all messages where first stored in the RDE
then passed to the SE where they got queued in case bgpctl was not fast enough.
Now only a small number of messages is generated and passed to the SE and
the SE has an additional limit instead of acting like an infinite buffer.
Without this the bgpd on bgpd.networx.ch would not survive a single minute.
looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.22 2006/01/03 22:49:17 claudio Exp $ */
d405 1
a405 1
	
@


1.22
log
@Track some (memory) statistics in the RDE. Accessible via bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.21 2004/11/11 16:53:01 claudio Exp $ */
d43 1
d50 1
a231 2
	struct pt_entry *p;

d233 1
a233 2
		RB_FOREACH(p, pt_tree, &pttable4)
		    upcall(p, arg);
d235 44
a278 2
		RB_FOREACH(p, pt_tree, &pttable6)
		    upcall(p, arg);
d365 52
@


1.21
log
@Don't hardcode the prefix table to the IPv4 one, especially if there is
already code to select the correct tree by AF.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.20 2004/08/05 21:28:50 claudio Exp $ */
d292 1
d304 1
d311 10
@


1.20
log
@comapring -> comparing noticed by brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.19 2004/08/05 19:23:10 claudio Exp $ */
d170 1
a170 1
	if (RB_INSERT(pt_tree, &pttable4, p) != NULL) {
@


1.19
log
@Get rid of some statistics stuff that is no longer needed but helped in the
beginning. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.18 2004/08/05 18:44:19 claudio Exp $ */
d248 1
a248 1
		fatalx("king bula sez: comapring pears with apples");
@


1.18
log
@Cleanup aspath specific functions and api. Mainly switch to a refcnt based
allocation. This helps to save a bit of RAM. looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.17 2004/08/03 14:46:23 claudio Exp $ */
a60 18
/*
 * Statistics collector.
 * Collected to tune the prefix table. Currently only a few counters were
 * added. More to come as soon as we see where we are going.
 * TODO: add a function that dumps the stats after a specified period of time.
 */
struct pt_stats {
	u_int64_t		 pt_alloc;
	u_int64_t		 pt_free;
	u_int64_t		 pt_add;
	u_int64_t		 pt_get;
	u_int64_t		 pt_remove;
	u_int64_t		 pt_lookup;
	u_int64_t		 pt_dump;
} ptstats;
/* simple macros to update statistics */
#define PT_STAT(x)	(ptstats.x++)

a109 2
	PT_STAT(pt_get);

a141 2
	PT_STAT(pt_add);

a180 2
	PT_STAT(pt_remove);

a205 1
	PT_STAT(pt_lookup);
a288 1
	PT_STAT(pt_alloc);
a299 1
	PT_STAT(pt_alloc);
a308 1
	PT_STAT(pt_free);
@


1.17
log
@Cleanup and remove some ENSURE. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.16 2004/07/05 02:13:44 henning Exp $ */
d273 1
a273 1
		fatalx("king bula sez: comapring pears with apples"); 
@


1.16
log
@fix a few KNF fallouts
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.15 2004/06/22 23:17:01 claudio Exp $ */
a26 1
#include "ensure.h"
d37 1
d41 1
a41 1
 * pt_alloc:  allocate a pt_entry. Internal function.
a161 1
	ENSURE(pt_get(prefix, prefixlen) == NULL);
a202 1
	ENSURE(pt_empty(pte));
d205 3
d272 2
a273 1
	ENSURE(a->af == b->af);
@


1.15
log
@Cleanup. jajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.14 2004/06/22 20:28:58 claudio Exp $ */
d136 1
a136 1
		pte4.prefix4.s_addr = htonl(addr_hbo & 
d173 1
a173 1
		p4->prefix4.s_addr = htonl(addr_hbo & 
@


1.14
log
@Make the RDE IPv6 ready missing is the message handling. The internal
prefix tree changed form a hash table to a per AF RB tree.
OK henning@@ some ideas are from Brent Graveland.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.13 2004/03/11 17:34:01 henning Exp $ */
a97 1
	ENSURE(pte != NULL);
a270 7
	if (a == NULL)
		return (1);
	if (b == NULL)
		return (-1);

	if (a->af != b->af)
		log_debug("af non equal a %d b %d\n", a->af, b->af);
a299 1

@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.12 2004/03/11 14:22:23 claudio Exp $ */
d46 2
a47 1
static struct pt_entry	*pt_alloc(void);
d50 1
a50 10
/*
 * currently we are using a hash list to store the prefixes. This may be
 * replaced with a red-black trie if necessary.
 */
LIST_HEAD(pt_entryhead, pt_entry);

struct pt_table {
	struct pt_entryhead	*pt_hashtbl;
	u_int32_t		 pt_hashmask;
};
d54 3
d58 2
a59 17
/*
 * size of the hashtable per prefixlen. The sizes were chosen from a bgp
 * dump done on Nov 4. 2003.
 */
u_int32_t pthashsize[MAX_PREFIX + 1 - MIN_PREFIX] = {
	/* need to be power of 2 */
	1, 1, 1, 1, 1, 1, 1, 1,
	16, 8, 8, 16, 32, 64, 256, 256,
	4096, 1024, 2048, 8192, 8192, 4096, 8192, 8192,
	32768, 1, 1, 1, 1, 1, 1, 1, 1
};

struct pt_table	pttable[MAX_PREFIX + 1 - MIN_PREFIX];

#define PT_HASH(p, plen)				\
	&pttable[plen].pt_hashtbl[((p >> plen) ^ (p >> (plen + 5))) & \
	    pttable[plen].pt_hashmask]
d70 3
a72 3
	u_int64_t		 pt_add[MAX_PREFIX + 1 - MIN_PREFIX];
	u_int64_t		 pt_get[MAX_PREFIX + 1 - MIN_PREFIX];
	u_int64_t		 pt_remove[MAX_PREFIX + 1 - MIN_PREFIX];
a77 1
#define PT_STAT2(x, p)	(ptstats.x[p]++)
d82 2
a83 14
	int		i;
	u_int32_t	j;

	for (i = MIN_PREFIX; i <= MAX_PREFIX; i++) {
		pttable[i].pt_hashtbl = calloc(pthashsize[i],
		    sizeof(struct pt_entryhead));
		if (pttable[i].pt_hashtbl == NULL)
			fatal("pt_init");

		for (j = 0; j < pthashsize[i]; j++)
			LIST_INIT(&pttable[i].pt_hashtbl[j]);

		pttable[i].pt_hashmask = pthashsize[i] - 1;
	}
d89 4
a92 10
	int		i;
	u_int32_t	j;

	for (i = MIN_PREFIX; i <= MAX_PREFIX; i++) {
		for (j = 0; j < pthashsize[i]; j++)
			if (!LIST_EMPTY(&pttable[i].pt_hashtbl[j]))
				log_warnx("pt_free: free non-free table "
				    "[%d][%d]", i, j);
		free(pttable[i].pt_hashtbl);
	}
d102 20
d125 25
a149 14
	struct pt_entryhead	*head;
	struct pt_entry		*p;
	u_int32_t		 p_hbo;

	ENSURE(MIN_PREFIX <= prefixlen && prefixlen <= MAX_PREFIX);
	PT_STAT2(pt_get, prefixlen);

	p_hbo = ntohl(prefix->v4.s_addr);
	head = PT_HASH(p_hbo, prefixlen);
	ENSURE(head != NULL);

	LIST_FOREACH(p, head, pt_l) {
		if (prefix->v4.s_addr == p->prefix.v4.s_addr)
			return p;
d151 1
a151 1
	return NULL;
d157 5
a161 3
	struct pt_entryhead	*head;
	struct pt_entry		*p;
	u_int32_t		 p_hbo;
a162 1
	ENSURE(MIN_PREFIX <= prefixlen && prefixlen <= MAX_PREFIX);
d164 1
a164 1
	PT_STAT2(pt_add, prefixlen);
d166 26
a191 7
	p_hbo = ntohl(prefix->v4.s_addr);
	head = PT_HASH(p_hbo, prefixlen);
	ENSURE(head != NULL);

	p = pt_alloc();
	memcpy(&p->prefix, prefix, sizeof(p->prefix));
	p->prefixlen = prefixlen;
d194 4
a197 1
	LIST_INSERT_HEAD(head, p, pt_l);
d199 1
a199 1
	return p;
d206 14
a219 1
	PT_STAT2(pt_remove, pte->prefixlen);
a220 1
	LIST_REMOVE(pte, pt_l);
a226 1
	struct bgpd_addr pmasked;
a227 1
	u_int32_t	 addr_hbo;
d231 17
a247 8
	bzero(&pmasked, sizeof(pmasked));
	pmasked.af = AF_INET;
	addr_hbo = ntohl(prefix->v4.s_addr);
	for (i = MAX_PREFIX; i >= MIN_PREFIX; i--) {
		pmasked.v4.s_addr = htonl(addr_hbo & (0xffffffff << (32 - i)));
		p = pt_get(&pmasked, i);
		if (p != NULL)
			return (p);
d253 1
a253 1
pt_dump(void (*upcall)(struct pt_entry *, void *), void *arg)
d255 53
a307 3
	struct pt_entry	*p;
	int		 i;
	u_int32_t	 j;
d309 2
a310 5
	PT_STAT(pt_dump);
	for (i = MAX_PREFIX; i >= MIN_PREFIX; i--) {
		for (j = 0; j < pthashsize[i]; j++)
			LIST_FOREACH(p, &pttable[i].pt_hashtbl[j], pt_l)
				upcall(p, arg);
d312 1
d316 2
a317 2
static struct pt_entry *
pt_alloc(void)
d319 13
a331 1
	struct pt_entry	*p;
d337 1
a337 1
	return p;
@


1.12
log
@Shutdown the RDE cleanly on exit. Plug some memleaks. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.11 2004/03/02 19:29:01 claudio Exp $ */
d128 2
a129 1
				log_warnx("pt_free: free non-free table [%d][%d]", i, j);
@


1.11
log
@Framework for rib lookups by prefix. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.10 2004/02/09 01:56:18 henning Exp $ */
d116 14
@


1.10
log
@replace a bunch of u_long by u_int32_t
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.9 2004/01/17 19:15:07 henning Exp $ */
d185 1
d187 1
d191 3
d195 2
a196 1
		p = pt_get(prefix, i);
d198 1
a198 1
			return p;
d200 1
a200 1
	return NULL;
a202 4
/*
 * XXX We need a redblack tree to get an ordered output.
 * XXX A nicer upcall interface wouldn't be luxus too.
 */
@


1.9
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.8 2004/01/16 11:14:43 henning Exp $ */
d57 1
a57 1
	u_long			 pt_hashmask;
d67 1
a67 1
u_long pthashsize[MAX_PREFIX + 1 - MIN_PREFIX] = {
d103 2
a104 2
	int	i;
	u_long	j;
d206 1
a206 1
	u_long		 j;
@


1.8
log
@missing #include
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.7 2004/01/11 21:47:20 claudio Exp $ */
d78 2
a79 1
	&pttable[plen].pt_hashtbl[((p >> plen) ^ (p >> (plen + 5))) & pttable[plen].pt_hashmask]
@


1.7
log
@Move all struct in_addr to either struct bgpd_addr or in_addr_t whichever
is more appropriate. The rde uses now in most cases struct bgpd_addr.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.6 2004/01/06 10:51:14 claudio Exp $ */
d24 1
@


1.6
log
@2004 OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.5 2003/12/26 18:07:33 henning Exp $ */
d125 1
a125 1
pt_get(struct in_addr prefix, int prefixlen)
d134 1
a134 1
	p_hbo = ntohl(prefix.s_addr);
d139 1
a139 1
		if (prefix.s_addr == p->prefix.s_addr)
d146 1
a146 1
pt_add(struct in_addr prefix, int prefixlen)
d156 1
a156 1
	p_hbo = ntohl(prefix.s_addr);
d161 1
a161 1
	p->prefix = prefix;
a176 1
	/* XXX we could bzero it for debugging reasons */
d181 1
a181 1
pt_lookup(struct in_addr prefix)
@


1.5
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.4 2003/12/24 11:39:43 henning Exp $ */
d4 1
a4 2
 * Copyright (c) 2003 Claudio Jeker <cjeker@@diehard.n-r-g.com>
 *
@


1.4
log
@typos in comments, from jared
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.3 2003/12/21 22:16:53 henning Exp $ */
d109 1
a109 1
			fatal("pt_init", errno);
d225 1
a225 1
		fatal("pt_alloc", errno);
@


1.3
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.2 2003/12/19 19:24:08 deraadt Exp $ */
d42 1
a42 1
 * pt_free:   free a pt_entry. Internal funktion.
d51 1
a51 1
 * replaced with a red-black trie if neccesary.
d64 1
a64 1
 * size of the hashtable per prefixlen. The sizes where choosen from a bgp
d82 1
a82 1
 * Collected to tune the preifx table. Currently only a few counters where
d95 1
a95 1
/* simple macros to update statisic */
d198 1
a198 1
 * XXX We need a redblack tree to get a ordered output.
@


1.2
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_prefix.c,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d202 1
a202 2
pt_dump(void (*upcall)(struct pt_entry *, int, int *, void *),
    int fd, int *w, void *arg)
d212 1
a212 1
				upcall(p, fd, w, arg);
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d191 2
a192 1
		if (p != NULL) return p;
@

