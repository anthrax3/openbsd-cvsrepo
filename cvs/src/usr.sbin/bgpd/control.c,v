head	1.87;
access;
symbols
	OPENBSD_6_1:1.87.0.4
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.82.0.6
	OPENBSD_6_0_BASE:1.82
	OPENBSD_5_9:1.82.0.2
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.77.0.4
	OPENBSD_5_8_BASE:1.77
	OPENBSD_5_7:1.76.0.2
	OPENBSD_5_7_BASE:1.76
	OPENBSD_5_6:1.75.0.6
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.75.0.4
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.74.0.2
	OPENBSD_5_4_BASE:1.74
	OPENBSD_5_3:1.72.0.4
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.72.0.2
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.6
	OPENBSD_5_0:1.70.0.4
	OPENBSD_5_0_BASE:1.70
	OPENBSD_4_9:1.70.0.2
	OPENBSD_4_9_BASE:1.70
	OPENBSD_4_8:1.69.0.2
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.61.0.4
	OPENBSD_4_6_BASE:1.61
	OPENBSD_4_5:1.60.0.4
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.60.0.2
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.58.0.2
	OPENBSD_4_3_BASE:1.58
	OPENBSD_4_2:1.55.0.2
	OPENBSD_4_2_BASE:1.55
	OPENBSD_4_1:1.53.0.4
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.53.0.2
	OPENBSD_4_0_BASE:1.53
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.43.0.4
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.37.0.2
	OPENBSD_3_6_BASE:1.37
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26;
locks; strict;
comment	@ * @;


1.87
date	2017.02.13.14.48.44;	author phessler;	state Exp;
branches;
next	1.86;
commitid	UAS1mKyHLGdFBKFJ;

1.86
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.85;
commitid	airB1W2Kb948lFil;

1.85
date	2017.01.13.18.59.12;	author phessler;	state Exp;
branches;
next	1.84;
commitid	3Jvf15B19ysa8i2W;

1.84
date	2017.01.08.23.04.42;	author krw;	state Exp;
branches;
next	1.83;
commitid	T1ZdV0xhVeBLIhr0;

1.83
date	2016.10.14.16.05.35;	author phessler;	state Exp;
branches;
next	1.82;
commitid	Ai7XVOgXw9ZLovz1;

1.82
date	2015.12.05.18.28.04;	author benno;	state Exp;
branches;
next	1.81;
commitid	yK6UHgEp0AEIXbTZ;

1.81
date	2015.12.05.13.10.32;	author claudio;	state Exp;
branches;
next	1.80;
commitid	edwx3TpFzQsXVwf7;

1.80
date	2015.10.25.18.49.01;	author claudio;	state Exp;
branches;
next	1.79;
commitid	CFOjjrz5XQ5AoRFX;

1.79
date	2015.10.24.15.15.55;	author benno;	state Exp;
branches;
next	1.78;
commitid	1zw9VgAgiW49ygBg;

1.78
date	2015.10.17.13.07.07;	author reyk;	state Exp;
branches;
next	1.77;
commitid	FaDWedZDiKMjNMPO;

1.77
date	2015.04.26.20.12.03;	author benno;	state Exp;
branches;
next	1.76;
commitid	YKLP9qAJ8pARDutu;

1.76
date	2015.02.09.11.37.31;	author claudio;	state Exp;
branches;
next	1.75;
commitid	IcuyF0sCmFRE7OTK;

1.75
date	2013.11.13.20.41.01;	author benno;	state Exp;
branches;
next	1.74;

1.74
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2013.03.07.21.26.28;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2012.05.27.18.52.07;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2012.04.12.17.26.09;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2010.10.29.12.51.53;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.13.06.02.37;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2009.12.08.15.54.50;	author jsg;	state Exp;
branches;
next	1.66;

1.66
date	2009.12.03.19.22.53;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2009.12.02.19.10.02;	author mk;	state Exp;
branches;
next	1.64;

1.64
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2009.11.02.20.38.15;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2009.09.02.08.06.42;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2009.05.05.20.09.19;	author sthen;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.11.01.08.05;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2008.05.08.04.05.37;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2008.01.31.12.17.35;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2007.12.23.18.26.13;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.20.17.08.48;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2007.03.28.12.33.32;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2007.03.19.10.03.25;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2006.08.23.08.13.04;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.27.21.24.36;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.27.15.43.13;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.23.12.11.38;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.24.15.28.03;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.24.10.04.36;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.24.10.03.44;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2006.01.03.22.49.17;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.19.12.32.16;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.19.10.26.21;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.11.15.48.58;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.25.23.00.23;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.23.17.55.58;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.23.17.26.51;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.23.13.07.01;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2004.09.16.17.36.29;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.24.12.43.34;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.20.15.49.02;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.20.15.47.38;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2004.08.06.11.51.19;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.09.13.01.44;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.21.11.48.56;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.08.11.22.43;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.29.19.56.04;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.04.25.03.13.42;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.04.16.04.51.09;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.17.14.39.45;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.03.02.19.29.01;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.29.22.48.01;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.29.21.49.36;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.26.16.16.41;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.02.23.17.34;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.22.20.34.55;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.22.03.18.03;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.20.12.50.25;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.17.18.05.46;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.11.02.35.14;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.09.19.08.50;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.09.13.47.07;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.09.13.14.25;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.06.23.14.58;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.05.16.21.14;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.04.19.39.46;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.04.18.51.23;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.03.20.22.07;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.03.14.06.35;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.03.13.54.27;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.03.13.28.02;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.02.09.02.50;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.02.02.27.57;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.01.23.46.47;	author henning;	state Exp;
branches;
next	;


desc
@@


1.87
log
@draft-ietf-idr-shutdown extends to support a message on either of
"Administrative Shutdown" or "Administrative Reset"

patch submitted by Job Snijders, thanks!
@
text
@/*	$OpenBSD: control.c,v 1.86 2017/01/24 04:22:42 benno Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "bgpd.h"
#include "session.h"
#include "log.h"

#define	CONTROL_BACKLOG	5

struct ctl_conn	*control_connbyfd(int);
struct ctl_conn	*control_connbypid(pid_t);
int		 control_close(int);
void		 control_result(struct ctl_conn *, u_int);
ssize_t		 imsg_read_nofd(struct imsgbuf *);

int
control_init(int restricted, char *path)
{
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask, mode;

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	     0)) == -1) {
		log_warn("control_init: socket");
		return (-1);
	}

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, path, sizeof(sun.sun_path)) >=
	    sizeof(sun.sun_path)) {
		log_warn("control_init: socket name too long");
		close(fd);
		return (-1);
	}

	if (unlink(path) == -1)
		if (errno != ENOENT) {
			log_warn("control_init: unlink %s", path);
			close(fd);
			return (-1);
		}

	if (restricted) {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH;
	} else {
		old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
		mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP;
	}

	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("control_init: bind: %s", path);
		close(fd);
		umask(old_umask);
		return (-1);
	}

	umask(old_umask);

	if (chmod(path, mode) == -1) {
		log_warn("control_init: chmod: %s", path);
		close(fd);
		unlink(path);
		return (-1);
	}

	return (fd);
}

int
control_listen(int fd)
{
	if (fd != -1 && listen(fd, CONTROL_BACKLOG) == -1) {
		log_warn("control_listen: listen");
		return (-1);
	}

	return (0);
}

void
control_shutdown(int fd)
{
	close(fd);
}

void
control_cleanup(const char *path)
{
	if (path)
		unlink(path);
}

unsigned int
control_accept(int listenfd, int restricted)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*ctl_conn;

	len = sizeof(sun);
	if ((connfd = accept4(listenfd,
	    (struct sockaddr *)&sun, &len,
	    SOCK_NONBLOCK | SOCK_CLOEXEC)) == -1) {
		if (errno == ENFILE || errno == EMFILE) {
			pauseaccept = getmonotime();
			return (0);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("control_accept: accept");
		return (0);
	}

	if ((ctl_conn = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		log_warn("control_accept");
		close(connfd);
		return (0);
	}

	imsg_init(&ctl_conn->ibuf, connfd);
	ctl_conn->restricted = restricted;

	TAILQ_INSERT_TAIL(&ctl_conns, ctl_conn, entry);

	return (1);
}

struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->ibuf.fd == fd)
			break;
	}

	return (c);
}

struct ctl_conn *
control_connbypid(pid_t pid)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->ibuf.pid == pid)
			break;
	}

	return (c);
}

int
control_close(int fd)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("control_close: fd %d: not found", fd);
		return (0);
	}

	msgbuf_clear(&c->ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	close(c->ibuf.fd);
	free(c);
	pauseaccept = 0;
	return (1);
}

int
control_dispatch_msg(struct pollfd *pfd, u_int *ctl_cnt)
{
	struct imsg		 imsg;
	struct ctl_conn		*c;
	ssize_t			 n;
	int			 verbose;
	struct peer		*p;
	struct ctl_neighbor	*neighbor;
	struct ctl_show_rib_request	*ribreq;

	if ((c = control_connbyfd(pfd->fd)) == NULL) {
		log_warn("control_dispatch_msg: fd %d: not found", pfd->fd);
		return (0);
	}

	if (pfd->revents & POLLOUT)
		if (msgbuf_write(&c->ibuf.w) <= 0 && errno != EAGAIN) {
			*ctl_cnt -= control_close(pfd->fd);
			return (1);
		}

	if (!(pfd->revents & POLLIN))
		return (0);

	if (((n = imsg_read_nofd(&c->ibuf)) == -1 && errno != EAGAIN) ||
	    n == 0) {
		*ctl_cnt -= control_close(pfd->fd);
		return (1);
	}

	for (;;) {
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1) {
			*ctl_cnt -= control_close(pfd->fd);
			return (1);
		}

		if (n == 0)
			break;

		if (c->restricted) {
			switch (imsg.hdr.type) {
			case IMSG_CTL_SHOW_NEIGHBOR:
			case IMSG_CTL_SHOW_NEXTHOP:
			case IMSG_CTL_SHOW_INTERFACE:
			case IMSG_CTL_SHOW_RIB:
			case IMSG_CTL_SHOW_RIB_AS:
			case IMSG_CTL_SHOW_RIB_PREFIX:
			case IMSG_CTL_SHOW_RIB_MEM:
			case IMSG_CTL_SHOW_RIB_COMMUNITY:
			case IMSG_CTL_SHOW_RIB_LARGECOMMUNITY:
			case IMSG_CTL_SHOW_NETWORK:
			case IMSG_CTL_SHOW_TERSE:
			case IMSG_CTL_SHOW_TIMER:
				break;
			default:
				/* clear imsg type to prevent processing */
				imsg.hdr.type = IMSG_NONE;
				control_result(c, CTL_RES_DENIED);
				break;
			}
		}

		switch (imsg.hdr.type) {
		case IMSG_NONE:
			/* message was filtered out, nothing to do */
			break;
		case IMSG_CTL_SHOW_NEIGHBOR:
			c->ibuf.pid = imsg.hdr.pid;
			if (imsg.hdr.len == IMSG_HEADER_SIZE +
			    sizeof(struct ctl_neighbor)) {
				neighbor = imsg.data;
				p = getpeerbyaddr(&neighbor->addr);
				if (p == NULL)
					p = getpeerbydesc(neighbor->descr);
				if (p == NULL) {
					control_result(c, CTL_RES_NOSUCHPEER);
					break;
				}
				if (!neighbor->show_timers) {
					imsg_ctl_rde(imsg.hdr.type,
					    imsg.hdr.pid,
					    p, sizeof(struct peer));
					imsg_ctl_rde(IMSG_CTL_END,
					    imsg.hdr.pid, NULL, 0);
				} else {
					u_int			 i;
					time_t			 d;
					struct ctl_timer	 ct;

					imsg_compose(&c->ibuf,
					    IMSG_CTL_SHOW_NEIGHBOR,
					    0, 0, -1, p, sizeof(*p));
					for (i = 1; i < Timer_Max; i++) {
						if (!timer_running(p, i, &d))
							continue;
						ct.type = i;
						ct.val = d;
						imsg_compose(&c->ibuf,
						    IMSG_CTL_SHOW_TIMER,
						    0, 0, -1, &ct, sizeof(ct));
					}
					imsg_compose(&c->ibuf, IMSG_CTL_END,
					    0, 0, -1, NULL, 0);
				}
			} else {
				for (p = peers; p != NULL; p = p->next)
					imsg_ctl_rde(imsg.hdr.type,
					    imsg.hdr.pid,
					    p, sizeof(struct peer));
				imsg_ctl_rde(IMSG_CTL_END, imsg.hdr.pid,
					NULL, 0);
			}
			break;
		case IMSG_CTL_SHOW_TERSE:
			for (p = peers; p != NULL; p = p->next)
				imsg_compose(&c->ibuf, IMSG_CTL_SHOW_NEIGHBOR,
				    0, 0, -1, p, sizeof(struct peer));
			imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, -1, NULL, 0);
			break;
		case IMSG_CTL_FIB_COUPLE:
		case IMSG_CTL_FIB_DECOUPLE:
			imsg_ctl_parent(imsg.hdr.type, imsg.hdr.peerid,
			    0, NULL, 0);
			break;
		case IMSG_CTL_NEIGHBOR_UP:
		case IMSG_CTL_NEIGHBOR_DOWN:
		case IMSG_CTL_NEIGHBOR_CLEAR:
		case IMSG_CTL_NEIGHBOR_RREFRESH:
		case IMSG_CTL_NEIGHBOR_DESTROY:
			if (imsg.hdr.len == IMSG_HEADER_SIZE +
			    sizeof(struct ctl_neighbor)) {
				neighbor = imsg.data;
				neighbor->descr[PEER_DESCR_LEN - 1] = 0;
				p = getpeerbyaddr(&neighbor->addr);
				if (p == NULL)
					p = getpeerbydesc(neighbor->descr);
				if (p == NULL) {
					control_result(c, CTL_RES_NOSUCHPEER);
					break;
				}
				switch (imsg.hdr.type) {
				case IMSG_CTL_NEIGHBOR_UP:
					bgp_fsm(p, EVNT_START);
					p->conf.down = 0;
					p->conf.shutcomm[0] = '\0';
					control_result(c, CTL_RES_OK);
					break;
				case IMSG_CTL_NEIGHBOR_DOWN:
					p->conf.down = 1;
					strlcpy(p->conf.shutcomm,
					    neighbor->shutcomm,
					    sizeof(neighbor->shutcomm));
					session_stop(p, ERR_CEASE_ADMIN_DOWN);
					control_result(c, CTL_RES_OK);
					break;
				case IMSG_CTL_NEIGHBOR_CLEAR:
					strlcpy(p->conf.shutcomm,
					    neighbor->shutcomm,
					    sizeof(neighbor->shutcomm));
					if (!p->conf.down) {
						session_stop(p,
						    ERR_CEASE_ADMIN_RESET);
						timer_set(p, Timer_IdleHold,
						    SESSION_CLEAR_DELAY);
					} else {
						session_stop(p,
						    ERR_CEASE_ADMIN_DOWN);
					}
					control_result(c, CTL_RES_OK);
					break;
				case IMSG_CTL_NEIGHBOR_RREFRESH:
					if (session_neighbor_rrefresh(p))
						control_result(c,
						    CTL_RES_NOCAP);
					else
						control_result(c, CTL_RES_OK);
					break;
				case IMSG_CTL_NEIGHBOR_DESTROY:
					if (!p->template)
						control_result(c,
						    CTL_RES_BADPEER);
					else if (p->state != STATE_IDLE)
						control_result(c,
						    CTL_RES_BADSTATE);
					else {
						/*
						 * Mark as deleted, will be
						 * collected on next poll loop.
						 */
						p->conf.reconf_action =
						    RECONF_DELETE;
						control_result(c, CTL_RES_OK);
					}
					break;
				default:
					fatal("king bula wants more humppa");
				}
			} else
				log_warnx("got IMSG_CTL_NEIGHBOR_ with "
				    "wrong length");
			break;
		case IMSG_CTL_RELOAD:
		case IMSG_CTL_SHOW_INTERFACE:
		case IMSG_CTL_SHOW_FIB_TABLES:
			c->ibuf.pid = imsg.hdr.pid;
			imsg_ctl_parent(imsg.hdr.type, 0, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_SHOW_NEXTHOP:
			c->ibuf.pid = imsg.hdr.pid;
			imsg_ctl_parent(imsg.hdr.type, imsg.hdr.peerid,
			    imsg.hdr.pid, imsg.data, imsg.hdr.len -
			    IMSG_HEADER_SIZE);
			break;
		case IMSG_CTL_SHOW_RIB:
		case IMSG_CTL_SHOW_RIB_AS:
		case IMSG_CTL_SHOW_RIB_PREFIX:
			if (imsg.hdr.len == IMSG_HEADER_SIZE +
			    sizeof(struct ctl_show_rib_request)) {
				ribreq = imsg.data;
				neighbor = &ribreq->neighbor;
				neighbor->descr[PEER_DESCR_LEN - 1] = 0;
				ribreq->peerid = 0;
				p = NULL;
				if (neighbor->addr.aid) {
					p = getpeerbyaddr(&neighbor->addr);
					if (p == NULL) {
						control_result(c,
						    CTL_RES_NOSUCHPEER);
						break;
					}
					ribreq->peerid = p->conf.id;
				} else if (neighbor->descr[0]) {
					p = getpeerbydesc(neighbor->descr);
					if (p == NULL) {
						control_result(c,
						    CTL_RES_NOSUCHPEER);
						break;
					}
					ribreq->peerid = p->conf.id;
				}
				if ((ribreq->flags &
				     (F_CTL_ADJ_OUT | F_CTL_ADJ_IN)) && !p) {
					/*
					 * both in and out tables are only
					 * meaningful if used on a single
					 * peer.
					 */
					control_result(c, CTL_RES_NOSUCHPEER);
					break;
				}
				if ((ribreq->flags & F_CTL_ADJ_IN) && p &&
				    !p->conf.softreconfig_in) {
					/*
					 * without softreconfig_in we do not
					 * have an Adj-RIB-In table
					 */
					control_result(c, CTL_RES_NOCAP);
					break;
				}
				if ((imsg.hdr.type == IMSG_CTL_SHOW_RIB_PREFIX)
				    && (ribreq->prefix.aid == AID_UNSPEC)) {
					/* malformed request, must specify af */
					control_result(c, CTL_RES_PARSE_ERROR);
					break;
				}
				c->ibuf.pid = imsg.hdr.pid;
				imsg_ctl_rde(imsg.hdr.type, imsg.hdr.pid,
				    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			} else
				log_warnx("got IMSG_CTL_SHOW_RIB with "
				    "wrong length");
			break;
		case IMSG_CTL_SHOW_RIB_MEM:
		case IMSG_CTL_SHOW_RIB_COMMUNITY:
		case IMSG_CTL_SHOW_RIB_LARGECOMMUNITY:
		case IMSG_CTL_SHOW_NETWORK:
			c->ibuf.pid = imsg.hdr.pid;
			imsg_ctl_rde(imsg.hdr.type, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_NETWORK_ADD:
		case IMSG_NETWORK_ASPATH:
		case IMSG_NETWORK_ATTR:
		case IMSG_NETWORK_REMOVE:
		case IMSG_NETWORK_FLUSH:
		case IMSG_NETWORK_DONE:
		case IMSG_FILTER_SET:
			imsg_ctl_rde(imsg.hdr.type, 0,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(verbose))
				break;

			/* forward to other processes */
			imsg_ctl_parent(imsg.hdr.type, 0, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			imsg_ctl_rde(imsg.hdr.type, 0,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}

	return (0);
}

int
control_imsg_relay(struct imsg *imsg)
{
	struct ctl_conn	*c;

	if ((c = control_connbypid(imsg->hdr.pid)) == NULL)
		return (0);

	return (imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid, -1,
	    imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
}

void
control_result(struct ctl_conn *c, u_int code)
{
	imsg_compose(&c->ibuf, IMSG_CTL_RESULT, 0, c->ibuf.pid, -1,
	    &code, sizeof(code));
}

/* This should go into libutil, from smtpd/mproc.c */
ssize_t
imsg_read_nofd(struct imsgbuf *ibuf)
{
	ssize_t	 n;
	char	*buf;
	size_t	 len;

	buf = ibuf->r.buf + ibuf->r.wpos;
	len = sizeof(ibuf->r.buf) - ibuf->r.wpos;

	while ((n = recv(ibuf->fd, buf, len, 0)) == -1) {
		if (errno != EINTR)
			return (n);
	}

	ibuf->r.wpos += n;
	return (n);
}
@


1.86
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.85 2017/01/13 18:59:12 phessler Exp $ */
d357 3
@


1.85
log
@Add support for draft-ietf-idr-shutdown

    BGP state = Idle, marked down with shutdown reason "goodbye, we are
    upgrading to openbsd 6.1", down for 00:00:17

developed by Peter van Dijk <peter.van.dijk@@powerdns.com> and Job
Snijders <job@@ntt.net>, thank you!

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.84 2017/01/08 23:04:42 krw Exp $ */
d30 1
d503 1
a503 1
			log_verbose(verbose);
@


1.84
log
@Replace hand-rolled for(;;) traversal of ctl_conns TAILQ with
TAILQ_FOREACH().

No intentional functional change.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.83 2016/10/14 16:05:35 phessler Exp $ */
d343 2
d348 4
@


1.83
log
@Add support for draft-ietf-idr-large-community

Joint work with Job Snijders, many thanks!
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.82 2015/12/05 18:28:04 benno Exp $ */
d159 4
a162 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
d172 4
a175 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.pid != pid;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
@


1.82
log
@cleanup some log messages with wrong function names etc.
ok henning,claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.81 2015/12/05 13:10:32 claudio Exp $ */
d247 1
d466 1
@


1.81
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.80 2015/10/25 18:49:01 claudio Exp $ */
d374 1
a374 1
					 	 * Mark as deleted, will be
d431 1
a431 1
				if ((ribreq->flags & 
d436 1
a436 1
                                         * peer.
d538 2
a539 2
        ibuf->r.wpos += n;
        return (n);
@


1.80
log
@Rename imsg_compose_parent and imsg_compose_rde to imsg_ctl_parent and
imsg_ctl_rde since these function should only be used by the control
code. Also switch ibuf_rde to ibuf_rde_ctl so that the control imsgs
don't need to queue behind all the incoming bgp UPDATES. This speeds
up 'bgpctl show' from taking minutes to a few seconds. The RDE was doing
this since a very long time but it seems the SE was not adjusted. Yikes
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.79 2015/10/24 15:15:55 benno Exp $ */
d222 2
a223 1
	if ((n = imsg_read_nofd(&c->ibuf)) == -1 || n == 0) {
d533 3
a535 5
 again:
	if ((n = recv(ibuf->fd, buf, len, 0)) == -1) {
		if (errno != EINTR && errno != EAGAIN)
			goto fail;
		goto again;
a538 1
 fail:
@


1.79
log
@"bgpctl sh rib in" and "bgpctl sh rib out" require a neighbor argument
to work. send an error if none is given.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.78 2015/10/17 13:07:07 reyk Exp $ */
d275 1
a275 1
					imsg_compose_rde(imsg.hdr.type,
d278 1
a278 1
					imsg_compose_rde(IMSG_CTL_END,
d302 1
a302 1
					imsg_compose_rde(imsg.hdr.type,
d305 1
a305 1
				imsg_compose_rde(IMSG_CTL_END, imsg.hdr.pid,
d317 1
a317 1
			imsg_compose_parent(imsg.hdr.type, imsg.hdr.peerid,
d392 1
a392 1
			imsg_compose_parent(imsg.hdr.type, 0, imsg.hdr.pid,
d399 1
a399 1
			imsg_compose_parent(imsg.hdr.type, imsg.hdr.peerid,
d456 1
a456 1
				imsg_compose_rde(imsg.hdr.type, imsg.hdr.pid,
d466 1
a466 1
			imsg_compose_rde(imsg.hdr.type, imsg.hdr.pid,
d476 1
a476 1
			imsg_compose_rde(imsg.hdr.type, 0,
d485 1
a485 1
			imsg_compose_parent(imsg.hdr.type, 0, imsg.hdr.pid,
d487 1
a487 1
			imsg_compose_rde(imsg.hdr.type, 0,
@


1.78
log
@Do no accept fds on the control socket; including the restricted socket.

OK gilles@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.77 2015/04/26 20:12:03 benno Exp $ */
d430 10
d443 2
a444 2
					 * if no neighbor was specified we
					 * try our best.
@


1.77
log
@mlarkin asks "bgpctl checks the length of the control socket path to
make sure it fits. When browsing around last night I saw that bgpd
does not. Any reason it shouldn't? Please commit"

Add a check in parse.y to check this when reading the configuration.
ok phessler@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.76 2015/02/09 11:37:31 claudio Exp $ */
d37 1
d222 1
a222 1
	if ((n = imsg_read(&c->ibuf)) == -1 || n == 0) {
d509 23
@


1.76
log
@Kill session_socket_blockmode() and replace it with SOCK_CLOEXEC or
SOCK_NONBLOCK and accept4(). OK henning@@ tested & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.75 2013/11/13 20:41:01 benno Exp $ */
d53 6
a58 1
	strlcpy(sun.sun_path, path, sizeof(sun.sun_path));
@


1.75
log
@from claudio
"Let msgbuf_write return -1 with errno EAGAIN. The users then must
check if this was the case and readd the event or poll again.  The
current handling in the imsg code is wrong for sure."

ok gilles, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.74 2013/03/11 17:40:11 deraadt Exp $ */
d45 2
a46 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
a85 2
	session_socket_blockmode(fd, BM_NONBLOCK);

d122 3
a124 2
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
a132 2

	session_socket_blockmode(connfd, BM_NONBLOCK);
@


1.74
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.73 2013/03/07 21:26:28 claudio Exp $ */
d210 1
a210 1
		if (msgbuf_write(&c->ibuf.w) < 0) {
@


1.73
log
@Implements a few missing bits for better templates support:
- on config reload also adjust the cloned neighbors so that they get the
  config changes as well.
- clean up sessions that are 1h idle but in state active (instead of down)
- add bits to allow bgpctl to destroy cloned neighbors
Tested by sthen@@ some time ago, OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.72 2012/05/27 18:52:07 claudio Exp $ */
d128 2
a129 1
		} else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.72
log
@Extend the network code to allow attributes to be passed in with prefixes.
In the end this will allow anyone to use MRT table dumps to load prefixes
into a bgpd instance. For example you can download the RIPE dumps and load
full-feeds onto your laptop until the poor thing dies.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.71 2012/04/12 17:26:09 claudio Exp $ */
d319 1
d358 17
@


1.71
log
@accept() pacing for bgpd based on similar work done on other daemons.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.70 2010/10/29 12:51:53 henning Exp $ */
d437 2
@


1.70
log
@malloc -> calloc for ctl_conn
pt out by cppcheck/jasper, ok sthen claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.69 2010/05/03 13:09:38 claudio Exp $ */
d125 4
a128 1
		if (errno != EWOULDBLOCK && errno != EINTR)
d188 1
a188 1

@


1.69
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.68 2010/01/13 06:02:37 claudio Exp $ */
d132 1
a132 1
	if ((ctl_conn = malloc(sizeof(struct ctl_conn))) == NULL) {
@


1.68
log
@Add support for BGP MPLS VPN aka RFC 4364. This is only the RDE part so
that it is possible to use OpenBGPD as a route-reflector for VPNv4.
Some clean up of the BGP MP code so that multiple protocols are easier
supported. kroute/kernel support not yet done but comming.
OK henning@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.67 2009/12/08 15:54:50 jsg Exp $ */
d309 2
a310 1
			imsg_compose_parent(imsg.hdr.type, 0, NULL, 0);
d363 6
a371 1
		case IMSG_CTL_SHOW_INTERFACE:
d373 3
a375 2
			imsg_compose_parent(imsg.hdr.type, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
d447 1
a447 1
			imsg_compose_parent(imsg.hdr.type, imsg.hdr.pid,
@


1.67
log
@porcesses -> processes
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.66 2009/12/03 19:22:53 claudio Exp $ */
d407 1
a407 2
				    && (ribreq->prefix.aid != AID_INET)
				    && (ribreq->prefix.aid != AID_INET6)) {
@


1.66
log
@A bgpctl nei XY clear should not restart neighbors that are administrativly
down. So after a bgpctl reload clearing a neighbor will bring that neighbor
into the configured state (in this case down). OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.65 2009/12/02 19:10:02 mk Exp $ */
d440 1
a440 1
			/* forward to other porcesses */
@


1.65
log
@log_warn() consistency.

`OK' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.64 2009/12/01 14:28:05 claudio Exp $ */
d336 9
a344 3
					session_stop(p, ERR_CEASE_ADMIN_RESET);
					timer_set(p, Timer_IdleHold,
					    SESSION_CLEAR_DELAY);
@


1.64
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.63 2009/11/02 20:38:15 claudio Exp $ */
d56 1
a56 1
			log_warn("unlink %s", path);
d126 1
a126 1
			log_warn("session_control_accept");
d133 1
a133 1
		log_warn("session_control_accept");
@


1.63
log
@Implement IMSG_CTL_LOG_VERBOSE similar to ospfd. Even though bgpd has almost
no log_debug() it makes more sense to make all routing daemons behave the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.62 2009/09/02 08:06:42 claudio Exp $ */
d374 1
a374 1
				if (neighbor->addr.af) {
d401 2
a402 2
				    && (ribreq->prefix.af != AF_INET)
				    && (ribreq->prefix.af != AF_INET6)) {
@


1.62
log
@Implement all of RFC 4486 BGP Cease Notification Message Subcodes.
The other side should now see why a session was dropped. e.g:
bgpd: ... received notification: Cease, administratively down
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.61 2009/05/05 20:09:19 sthen Exp $ */
d194 2
a195 1
	int			 n;
d428 14
@


1.61
log
@check that an IMSG_CTL_SHOW_RIB_PREFIX request has a valid
address family before passing it to the RDE.

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.60 2008/05/11 01:08:05 henning Exp $ */
d331 1
a331 1
					bgp_fsm(p, EVNT_STOP);
d335 1
a335 1
					bgp_fsm(p, EVNT_STOP);
@


1.60
log
@allow IMSG_CONTROL_SHOW_TIMER on restricted sockets
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.59 2008/05/08 04:05:37 henning Exp $ */
d397 7
@


1.59
log
@make sure we always send back something on IMSG_CTL_SHOW_NEIGHBOR
namely, the "no such neighbor" case was missing.
problem spotted by martin,ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.58 2008/01/31 12:17:35 henning Exp $ */
d239 1
@


1.58
log
@do not leak confd on malloc failure in control_accept()
found by Igor Zinovik <zinovik@@cs.karelia.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.57 2007/12/23 18:26:13 henning Exp $ */
d260 5
a264 1
				if (p != NULL && !neighbor->show_timers) {
d270 1
a270 2
				}
				if (p != NULL && neighbor->show_timers) {
@


1.57
log
@send timers for bgpctlshow neighbor foo timer in seperate messages after
the peer data. makes bgpctl display code independent from timer
implementation internals. only running timers are displayed now, stopped
ones are skipped.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.56 2007/12/20 17:08:48 henning Exp $ */
d134 1
@


1.56
log
@rework timers.
stop changing tienmr values directly, always use new
timer_(get/set/stop/running) functions. preparation for more to come :)
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.55 2007/03/28 12:33:32 henning Exp $ */
d259 1
a259 1
				if (p != NULL)
d263 24
a286 1
			} else
d291 3
a293 1
			imsg_compose_rde(IMSG_CTL_END, imsg.hdr.pid, NULL, 0);
@


1.55
log
@add IMSG_CTL_SHOW_RIB_COMMUNITY, rib by given community
mostly from rivo nurges <rix@@estpak.ee>, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.54 2007/03/19 10:03:25 henning Exp $ */
d306 2
a307 2
					p->IdleHoldTimer = time(NULL) +
					    SESSION_CLEAR_DELAY;
@


1.54
log
@when our red/recv/recvmsg in imsg_read gives EINTR or EAGAIN, do not
signal "connection closed" upstream.
spotted by Valentin Kozamernik <tin@@komna.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.53 2006/08/23 08:13:04 claudio Exp $ */
d235 1
d377 1
@


1.53
log
@Extend show rib interface code so that it is possible to show the adj-rib-in
and adj-rib-out. Additionally it is now possible to limit the output to a
specified peer. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.52 2006/05/27 21:24:36 claudio Exp $ */
d212 1
a212 1
	if (imsg_read(&c->ibuf) <= 0) {
@


1.52
log
@Pass a IMSG_CTL_RESULT messgae back to bgpctl on reloads to indicate if
the reload was successful or not. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.51 2006/05/27 15:43:13 claudio Exp $ */
d196 1
d335 40
@


1.51
log
@Cleanup with lint. Make the poll fd indexes unsigned and because of that
control_accept should also return a unsigned int. Remove old prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.50 2006/05/23 12:11:38 henning Exp $ */
a273 1
		case IMSG_CTL_RELOAD:
d322 1
@


1.50
log
@allow bgpd to request a route refresh from a neighbor if that neighbor
announced route refresh capabilities
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.49 2006/01/24 15:28:03 henning Exp $ */
d114 1
a114 1
int
@


1.49
log
@introduce "bgpctl show summary terse", shows summary in an easy to parse
format, intended for monitoring puposes. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.48 2006/01/24 10:04:36 henning Exp $ */
d282 1
d297 1
d301 1
d307 8
a318 1
				control_result(c, CTL_RES_OK);
@


1.48
log
@zap now unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.47 2006/01/24 10:03:44 henning Exp $ */
d235 1
d267 6
@


1.47
log
@introduce a second control socket, which is restricted to certain messages,
nameley the show ones. needed for looking glass style applications,
monitoring etc. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.46 2006/01/03 22:49:17 claudio Exp $ */
a31 5

struct {
	int	fd;
	int	restricted_fd;
} control_state;
@


1.46
log
@Track some (memory) statistics in the RDE. Accessible via bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.45 2005/10/19 12:32:16 henning Exp $ */
d35 1
d44 1
a44 1
control_init(void)
d48 1
a48 1
	mode_t			 old_umask;
d57 1
a57 1
	strlcpy(sun.sun_path, SOCKET_NAME, sizeof(sun.sun_path));
d59 1
a59 1
	if (unlink(SOCKET_NAME) == -1)
d61 1
a61 1
			log_warn("unlink %s", SOCKET_NAME);
d66 8
a73 1
	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
d75 1
a75 1
		log_warn("control_init: bind: %s", SOCKET_NAME);
d83 2
a84 2
	if (chmod(SOCKET_NAME, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
		log_warn("control_init chmod");
d86 1
a86 1
		(void)unlink(SOCKET_NAME);
a90 1
	control_state.fd = fd;
d96 1
a96 1
control_listen(void)
d98 1
a98 1
	if (listen(control_state.fd, CONTROL_BACKLOG) == -1) {
d103 1
a103 1
	return (control_state.fd);
d107 1
a107 1
control_shutdown(void)
d109 1
a109 1
	close(control_state.fd);
d113 1
a113 1
control_cleanup(void)
d115 2
a116 1
	unlink(SOCKET_NAME);
d120 1
a120 1
control_accept(int listenfd)
d143 1
d230 19
d250 3
@


1.45
log
@for "bgpctl neighbor foo up/down/clear", make bgpctl not exit after sending
the request, but wait for the new IMSG_CTL_RESULT message, which contains
a status code to indicate wether the request was processed successfully
or wether an error occured and if so what kind of error.
no more "IMSG_CTL_NEIGHBOR_ with unknown neighbor foobaz" in the log
when you mistyped foobar - no bgpctl itself complains
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.44 2005/10/19 10:26:21 henning Exp $ */
d291 1
@


1.44
log
@on "bgpctl neighbor foo clear", we used to send a STOP event immediately
followed by a START event. Instead of sending START immediately, start the
IdleHoldTimer with a very low value (5 seconds) so that we restart the
session these seconds later. some other implementations deal poorly with
our previously superfast reconnects, namely, that commercial one from
san jose, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.43 2005/03/11 15:48:58 deraadt Exp $ */
d40 1
d257 1
a257 2
					log_warnx("IMSG_CTL_NEIGHBOR_ "
					    "with unknown neighbor");
d275 1
d323 7
@


1.43
log
@move umask() song and dance closer around the bind, being more careful about errors; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.42 2005/02/25 23:00:23 claudio Exp $ */
d269 2
a270 1
					bgp_fsm(p, EVNT_START);
@


1.42
log
@unlink() control socket in error path. Spotted by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.41 2004/12/23 17:55:58 henning Exp $ */
a52 1
	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
d64 1
d68 1
d72 2
a79 2

	umask(old_umask);
@


1.41
log
@allo the "bgpctl show neighbor " commands to take the neighbor descr
too, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.40 2004/12/23 17:26:51 henning Exp $ */
d74 1
@


1.40
log
@allow "bgpctl neighbor" to take the peer's descr as argument as well
as its address
so "bgpctl neighbor upstream1 clear" now works and you don't have to
remember IPs
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.39 2004/11/23 13:07:01 claudio Exp $ */
a187 1
	struct bgpd_addr	*addr;
d222 5
a226 3
			    sizeof(struct bgpd_addr)) {
				addr = imsg.data;
				p = getpeerbyaddr(addr);
@


1.39
log
@Switch from a single filter_set to a linked list of sets. With this change
it is possible to specify multiple communities. This is also the first step
to better bgpd filters. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.38 2004/09/16 17:36:29 henning Exp $ */
d189 1
d246 6
a251 3
			    sizeof(struct bgpd_addr)) {
				addr = imsg.data;
				p = getpeerbyaddr(addr);
@


1.38
log
@imsg API cleanup:
-kill imsg_compose_pid, imsg_compose_fdpass and imsg_create_pid
-extend the original imsg_compose/_create API to take pid & fd too
-make imsg_compose do imsg_create + imsg_add + imsg_close instead of
 duplicating the code
-adjust all callers to the new API
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.37 2004/08/24 12:43:34 claudio Exp $ */
d290 2
@


1.37
log
@missing space in log message.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.36 2004/08/20 15:49:02 henning Exp $ */
d310 1
a310 1
	return (imsg_compose_pid(&c->ibuf, imsg->hdr.type, imsg->hdr.pid,
@


1.36
log
@add IMSG_CTL_NEIGHBOR_CLEAR, takes a session down and restarts it,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.34 2004/08/06 11:51:19 claudio Exp $ */
d249 1
a249 1
					log_warnx("IMSG_CTL_NEIGHBOR_"
@


1.35
log
@merge IMSG_CTL_NEIGHBOR_UP and _DOWN handling, kills some duplicate code,
claudio ok
@
text
@d243 1
d259 4
@


1.34
log
@Forward IMSG_CTL_SHOW_NEIGHBOR messages to the rde so that we can report
the current and max prefix count back to bgpctl. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.33 2004/06/20 18:35:12 henning Exp $ */
d242 1
d247 7
a253 1
				if (p != NULL)
d255 7
a261 3
				else
					log_warnx("IMSG_CTL_NEIGHBOR_UP "
					    "with unknown neighbor");
d263 1
a263 1
				log_warnx("got IMSG_CTL_NEIGHBOR_UP with "
a264 14
			break;
		case IMSG_CTL_NEIGHBOR_DOWN:
			if (imsg.hdr.len == IMSG_HEADER_SIZE +
			    sizeof(struct bgpd_addr)) {
				addr = imsg.data;
				p = getpeerbyaddr(addr);
				if (p != NULL)
					bgp_fsm(p, EVNT_STOP);
				else
					log_warnx("IMSG_CTL_NEIGHBOR_DOWN"
					    " with unknown neighbor");
			} else
				log_warnx("got IMSG_CTL_NEIGHBOR_DOWN "
				    "with wrong length");
@


1.33
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.32 2004/06/09 13:01:44 henning Exp $ */
d220 1
d226 3
a228 3
					imsg_compose(&c->ibuf,
					    IMSG_CTL_SHOW_NEIGHBOR,
					    0, p, sizeof(struct peer));
d231 4
a234 4
					imsg_compose(&c->ibuf,
					    IMSG_CTL_SHOW_NEIGHBOR,
					    0, p, sizeof(struct peer));
			imsg_compose(&c->ibuf, IMSG_CTL_END, 0, NULL, 0);
@


1.32
log
@move to a dynamically allocated struct pollfd array.
we used a ststic one with OPEN_MAX entries, which is a rather arbitary limit
as OPEN_MAX is _not_ the max # of open fds we can have, but just a default
for that setting.
in the same move we have to allocate the peer_l array, basically there
for pfd-index to peer pointers to prevent peer list scans all time,
dynamiccaly to. we overallocate a little and use that reserve until we
have to realloc again later to prevent reallocs for every single control
connection or a single flapping peer.
help & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.31 2004/05/21 11:48:56 claudio Exp $ */
d133 1
a133 1
	TAILQ_INSERT_TAIL(&ctl_conns, ctl_conn, entries);
d144 1
a144 1
	    c = TAILQ_NEXT(c, entries))
d156 1
a156 1
	    c = TAILQ_NEXT(c, entries))
d173 1
a173 1
	TAILQ_REMOVE(&ctl_conns, c, entries);
@


1.31
log
@Add support for dynamic announcements. Usefule to annouce temporary
blackhole routes or to make network announcements dependent on a external
state (e.g. for carp setups) OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.30 2004/05/08 11:22:43 henning Exp $ */
d39 1
d108 1
a108 1
void
d121 1
a121 1
		return;
d128 1
a128 1
		return;
d134 2
d162 1
a162 1
void
d169 1
a169 1
		return;
d177 2
d182 1
a182 1
control_dispatch_msg(struct pollfd *pfd)
d197 1
a197 1
			control_close(pfd->fd);
d205 1
a205 1
		control_close(pfd->fd);
d211 1
a211 1
			control_close(pfd->fd);
@


1.30
log
@remove unused argument to control_dispatch_msg(), lint
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.29 2004/04/29 19:56:04 deraadt Exp $ */
d274 1
d277 6
@


1.29
log
@sock -> fd; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.28 2004/04/25 03:13:42 henning Exp $ */
d177 1
a177 1
control_dispatch_msg(struct pollfd *pfd, int i)
@


1.28
log
@missing return; noticed by Joris Vink <amni@@pandora.be> but I fixed in
another way
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.27 2004/04/16 04:51:09 henning Exp $ */
d140 1
a140 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.sock != fd;
d172 1
a172 1
	close(c->ibuf.sock);
@


1.27
log
@use getpeerbyaddr() instead of using the v4 part of the af independent
struct manually
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.26 2004/03/17 14:39:45 henning Exp $ */
d118 1
a118 3
		if (errno == EWOULDBLOCK || errno == EINTR)
			return;
		else
d120 1
@


1.26
log
@remove getpeereid() call so that those who have write access to the socket
(root:wheel 0640) can send queries, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.25 2004/03/02 19:29:01 claudio Exp $ */
d219 1
a219 1
				p = getpeerbyip(addr->v4.s_addr);
d240 1
a240 1
				p = getpeerbyip(addr->v4.s_addr);
d254 1
a254 1
				p = getpeerbyip(addr->v4.s_addr);
@


1.25
log
@Framework for rib lookups by prefix. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.24 2004/02/29 22:48:01 henning Exp $ */
a112 2
	uid_t			 uid;
	gid_t			 gid;
a124 10

	if (getpeereid(connfd, &uid, &gid) == -1) {
		log_warn("session_control_accept");
		return;
	}

	if (uid) {
		log_info("Control connection attempt from uid %ld", uid);
		return;
	}
@


1.24
log
@plug memory leak: when a control connection is closed we need to clear
its write buffers, noticed by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.23 2004/02/29 21:49:36 henning Exp $ */
d286 1
@


1.23
log
@of course the control socket needs to be nonblocking as well, i could have
sworn it was... noticed by & fixed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.22 2004/02/26 16:16:41 claudio Exp $ */
d182 1
@


1.22
log
@show rib infrastructure. At least full dumps and per as dumps. Per prefix
dump need some more work. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.21 2004/02/02 23:17:34 henning Exp $ */
d78 1
d125 2
@


1.21
log
@close socket on error in control_init
From: Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2004/01/22 20:34:55 henning Exp $ */
d278 6
@


1.20
log
@use log_warnx and log_info. reclassify a few messages in the process and fix
a few messages.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2004/01/22 03:18:03 henning Exp $ */
d60 1
d66 1
d72 1
@


1.19
log
@s/log_err/log_warn/
it is like warn(3), nor err(3). so use a less confusing name.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2004/01/20 12:50:25 henning Exp $ */
d128 1
a128 1
		logit(LOG_INFO, "Control connection attempt from uid %ld", uid);
d249 1
a249 1
					logit(LOG_CRIT, "IMSG_CTL_NEIGHBOR_UP "
d252 1
a252 1
				logit(LOG_CRIT, "got IMSG_CTL_NEIGHBOR_UP with "
d263 1
a263 1
					logit(LOG_CRIT, "IMSG_CTL_NEIGHBOR_DOWN"
d266 1
a266 1
				logit(LOG_CRIT, "got IMSG_CTL_NEIGHBOR_DOWN "
@


1.18
log
@fix error logging on connection attempts from !root user
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.17 2004/01/17 18:05:46 henning Exp $ */
d48 1
a48 1
		log_err("control_init: socket");
d59 1
a59 1
			log_err("unlink %s", SOCKET_NAME);
d64 1
a64 1
		log_err("control_init: bind: %s", SOCKET_NAME);
d69 1
a69 1
		log_err("control_init chmod");
d84 1
a84 1
		log_err("control_listen: listen");
d119 1
a119 1
			log_err("session_control_accept");
d123 1
a123 1
		log_err("session_control_accept");
d133 1
a133 1
		log_err("session_control_accept");
d172 1
a172 1
		log_err("control_close: fd %d: not found", fd);
d192 1
a192 1
		log_err("control_dispatch_msg: fd %d: not found", pfd->fd);
@


1.17
log
@allow the interfaces as bgpd sees 'em to be queried via imsgs
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2004/01/11 02:35:14 henning Exp $ */
d128 1
a128 1
		log_err("Connection to control socket with uid %ld", uid);
@


1.16
log
@new message IMSG_CTL_SHOW_NEXTHOP: request/send lost of BGP nexthops and
the result of their validity check
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2004/01/09 19:08:50 henning Exp $ */
d272 1
@


1.15
log
@for IMSG_CTL_KROUTEs allow matching based on flags,
add IMGS_CTL_KROUTE_ADDR to match the route for a given address

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2004/01/09 13:47:07 henning Exp $ */
d271 1
@


1.14
log
@get us a stateful imsg relaying framework, and the first receiver,
IMSG_CTL_KROUTE, to have the kroute structs forming the fib sent to a
control socket.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2004/01/06 23:14:58 henning Exp $ */
d270 1
d272 1
a272 1
			imsg_compose_parent(IMSG_CTL_KROUTE, imsg.hdr.pid,
@


1.13
log
@you must not try to read(2) without checking (pfd->revents & POLLIN)
you must not try to read(2) without checking (pfd->revents & POLLIN)
you must not try to read(2) without checking (pfd->revents & POLLIN)
[...]
you must not try to read(2) without checking (pfd->revents & POLLIN)
@
text
@d38 1
d154 12
d269 5
d281 12
@


1.12
log
@two new imsg types, IMSG_CTL_NEIGHBOR_UP and _DOWN, on their receival on the
control socket the given neighbor session is sent a START / STOP signal.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2004/01/06 03:43:50 henning Exp $ */
d182 9
@


1.11
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2004/01/05 16:21:14 henning Exp $ */
d218 28
@


1.10
log
@allow fib couple/decouple based on an imsg received on the control socket
by the SE and passed on to the main process
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2004/01/04 19:39:46 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.9
log
@-new imsg CTL_RELOAD
-upong receival in the SE forward to parent
-make sending messages from SE to parent work for that (was not required before)
-parent reacts to that just like a SIGHUP, reread config file
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2004/01/04 18:51:23 henning Exp $ */
d215 3
a217 1
			imsg_compose_parent(IMSG_CTL_RELOAD, 0, NULL, 0);
@


1.8
log
@allow "show neighbor" to be limited to one specific neighbor
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2004/01/03 20:22:07 henning Exp $ */
d213 3
@


1.7
log
@decouple the peer list from bgpd_config.
so many parts of bgpd are not at all interested in the session specific peer
structs... allows for some further cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2004/01/03 14:06:35 henning Exp $ */
d176 1
d199 13
a211 3
			for (p = peers; p != NULL; p = p->next)
				imsg_compose(&c->ibuf, IMSG_CTL_SHOW_NEIGHBOR,
				    0, p, sizeof(struct peer));
@


1.6
log
@change imsg_read semantics so that the number of bytes read is returned.
that means that the callers can (and must) coope with closed connections
themselves, what is exactly the desired behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2004/01/03 13:54:27 henning Exp $ */
d198 1
a198 1
			for (p = conf->peers; p != NULL; p = p->next)
@


1.5
log
@send an imsg as list end indicator
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2004/01/03 13:28:02 henning Exp $ */
d182 1
a182 1
	if (imsg_read(&c->ibuf) == -1) {
@


1.4
log
@fix umask, noticed by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2004/01/02 09:02:50 henning Exp $ */
d201 1
@


1.3
log
@umask setting and unlink before bind() the unix socket, chmod and umask
restore afterwards
help & ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2004/01/02 02:27:57 henning Exp $ */
d51 1
a51 1
	old_umask = umask(S_IWGRP|S_IWOTH|S_IROTH|S_IXOTH);
@


1.2
log
@move the socket name #define to bgpd.h and get rid of bgpdctl*
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2004/01/01 23:46:47 henning Exp $ */
d20 1
d42 3
a44 2
	struct sockaddr_un	sun;
	int			fd;
d51 1
d55 7
d66 7
@


1.1
log
@listen on a AF_LOCAL socket for imsgs too.
only implemented type yet is IMSG_CTL_SHOW_NEIGHBOR which sends back
the struct peer for all neighbors.
will be used by bgpdctl
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a27 1
#include "bgpdctl.h"
@

