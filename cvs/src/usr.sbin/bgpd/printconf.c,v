head	1.106;
access;
symbols
	OPENBSD_6_2_BASE:1.106
	OPENBSD_6_1:1.100.0.4
	OPENBSD_6_1_BASE:1.100
	OPENBSD_6_0:1.97.0.4
	OPENBSD_6_0_BASE:1.97
	OPENBSD_5_9:1.96.0.2
	OPENBSD_5_9_BASE:1.96
	OPENBSD_5_8:1.95.0.4
	OPENBSD_5_8_BASE:1.95
	OPENBSD_5_7:1.93.0.2
	OPENBSD_5_7_BASE:1.93
	OPENBSD_5_6:1.93.0.6
	OPENBSD_5_6_BASE:1.93
	OPENBSD_5_5:1.93.0.4
	OPENBSD_5_5_BASE:1.93
	OPENBSD_5_4:1.90.0.4
	OPENBSD_5_4_BASE:1.90
	OPENBSD_5_3:1.90.0.2
	OPENBSD_5_3_BASE:1.90
	OPENBSD_5_2:1.86.0.4
	OPENBSD_5_2_BASE:1.86
	OPENBSD_5_1_BASE:1.86
	OPENBSD_5_1:1.86.0.2
	OPENBSD_5_0:1.85.0.4
	OPENBSD_5_0_BASE:1.85
	OPENBSD_4_9:1.85.0.2
	OPENBSD_4_9_BASE:1.85
	OPENBSD_4_8:1.84.0.2
	OPENBSD_4_8_BASE:1.84
	OPENBSD_4_7:1.79.0.2
	OPENBSD_4_7_BASE:1.79
	OPENBSD_4_6:1.70.0.4
	OPENBSD_4_6_BASE:1.70
	OPENBSD_4_5:1.65.0.6
	OPENBSD_4_5_BASE:1.65
	OPENBSD_4_4:1.65.0.4
	OPENBSD_4_4_BASE:1.65
	OPENBSD_4_3:1.65.0.2
	OPENBSD_4_3_BASE:1.65
	OPENBSD_4_2:1.64.0.2
	OPENBSD_4_2_BASE:1.64
	OPENBSD_4_1:1.60.0.2
	OPENBSD_4_1_BASE:1.60
	OPENBSD_4_0:1.57.0.2
	OPENBSD_4_0_BASE:1.57
	OPENBSD_3_9:1.53.0.2
	OPENBSD_3_9_BASE:1.53
	OPENBSD_3_8:1.47.0.2
	OPENBSD_3_8_BASE:1.47
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12;
locks; strict;
comment	@ * @;


1.106
date	2017.08.12.16.47.50;	author phessler;	state Exp;
branches;
next	1.105;
commitid	Yn4Issa4OqsHvnXL;

1.105
date	2017.08.11.16.02.53;	author claudio;	state Exp;
branches;
next	1.104;
commitid	TArqhzl9aciTsGlE;

1.104
date	2017.05.31.10.44.00;	author claudio;	state Exp;
branches;
next	1.103;
commitid	tiSkyeLqu7f48PM9;

1.103
date	2017.05.27.18.12.23;	author phessler;	state Exp;
branches;
next	1.102;
commitid	DuFAjaquQFZWoSIc;

1.102
date	2017.05.27.10.33.15;	author phessler;	state Exp;
branches;
next	1.101;
commitid	SM4OMu9209fRs2iQ;

1.101
date	2017.05.27.10.24.44;	author phessler;	state Exp;
branches;
next	1.100;
commitid	lmPnpLRIggYi6nnK;

1.100
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.99;
commitid	airB1W2Kb948lFil;

1.99
date	2016.10.14.16.05.36;	author phessler;	state Exp;
branches;
next	1.98;
commitid	Ai7XVOgXw9ZLovz1;

1.98
date	2016.10.05.07.38.06;	author phessler;	state Exp;
branches;
next	1.97;
commitid	XF7pIhaJDJdwfpZW;

1.97
date	2016.07.13.20.07.38;	author benno;	state Exp;
branches;
next	1.96;
commitid	T20mHUaD55SUxpN1;

1.96
date	2015.09.21.09.47.15;	author phessler;	state Exp;
branches;
next	1.95;
commitid	0iY3tr4GQ1eTlhDV;

1.95
date	2015.07.16.18.26.04;	author claudio;	state Exp;
branches;
next	1.94;
commitid	LqSO5lx1xfCVcctP;

1.94
date	2015.04.25.15.28.18;	author phessler;	state Exp;
branches;
next	1.93;
commitid	4yPC9ACFnDblFb1s;

1.93
date	2013.11.13.09.14.48;	author florian;	state Exp;
branches;
next	1.92;

1.92
date	2013.10.30.17.28.33;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2013.10.19.15.04.25;	author claudio;	state Exp;
branches;
next	1.90;

1.90
date	2013.01.17.02.00.33;	author claudio;	state Exp;
branches;
next	1.89;

1.89
date	2012.11.13.09.47.20;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2012.09.23.09.39.18;	author claudio;	state Exp;
branches;
next	1.87;

1.87
date	2012.09.12.05.56.22;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2011.09.17.16.29.44;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2010.12.31.21.22.42;	author guenther;	state Exp;
branches;
next	1.84;

1.84
date	2010.08.06.14.32.13;	author jsg;	state Exp;
branches;
next	1.83;

1.83
date	2010.06.27.19.53.34;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2010.05.17.16.08.20;	author claudio;	state Exp;
branches;
next	1.81;

1.81
date	2010.05.17.15.49.29;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2010.03.05.15.25.00;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2010.03.03.22.09.08;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2009.12.17.09.32.59;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2009.12.16.15.40.55;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2009.12.08.14.03.40;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.26.13.40.43;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.13.11.41.32;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2009.10.06.09.44.13;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.06.01.10.29;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.05.20.26.38;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2009.05.27.04.18.21;	author reyk;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.26.13.59.30;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2009.03.22.22.35.00;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.22.11.37.25;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.28.17.26.33;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.15.11.07.46;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2007.03.29.13.09.26;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2007.03.06.16.52.48;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2006.12.05.12.08.13;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2006.11.28.16.39.34;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2006.08.04.12.01.48;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.27.15.37.29;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2006.04.04.12.03.26;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.22.13.30.35;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2006.02.10.14.34.40;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2006.02.09.21.05.09;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2006.02.02.14.06.05;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2005.11.01.10.58.29;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2005.10.31.17.00.05;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.31.16.31.39;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2005.08.09.20.27.25;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.28.20.14.29;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.01.13.38.14;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.01.09.19.24;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2005.06.29.09.43.25;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2005.06.09.15.32.03;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2005.04.28.13.54.45;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.18.11.00.42;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2005.04.12.14.32.00;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.07.23.45.21;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.14.17.32.04;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.11.12.54.19;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.23.13.07.01;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.18.17.07.38;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2004.11.11.10.35.15;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.19.14.53.14;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.10.19.12.02.50;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.28.12.09.31;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.24.15.50.16;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.24.12.42.55;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2004.08.13.14.03.20;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2004.08.10.13.02.08;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2004.08.02.12.30.15;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.05.16.54.53;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.03.17.19.59;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.06.17.38.10;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.08.19.17.20;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.08.18.23.24;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.08.17.40.53;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.28.04.34.46;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.28.00.38.39;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.27.23.20.42;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.27.22.42.13;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.26.04.40.11;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.17.12.40.38;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.12.20.57.22;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.11.17.34.01;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.11.17.12.51;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.01.23.00.03;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.01.17.04.07;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.01.16.47.06;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.24.15.43.03;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.09.23.16.46;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.09.01.46.34;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.09.01.38.55;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.08.23.44.57;	author henning;	state Exp;
branches;
next	;


desc
@@


1.106
log
@allow filter rules to be written that affect ibgp or ebgp neighbors

discussed with henning@@
OK claudio@@, benno@@, job@@
@
text
@/*	$OpenBSD: printconf.c,v 1.105 2017/08/11 16:02:53 claudio Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2016 Job Snijders <job@@instituut.net>
 * Copyright (c) 2016 Peter Hessler <phessler@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA, PROFITS OR MIND, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "bgpd.h"
#include "mrt.h"
#include "session.h"
#include "rde.h"
#include "log.h"

void		 print_op(enum comp_ops);
void		 print_community(int, int);
void		 print_largecommunity(int64_t, int64_t, int64_t);
void		 print_extcommunity(struct filter_extcommunity *);
void		 print_origin(u_int8_t);
void		 print_set(struct filter_set_head *);
void		 print_mainconf(struct bgpd_config *);
void		 print_rdomain_targets(struct filter_set_head *, const char *);
void		 print_rdomain(struct rdomain *);
const char	*print_af(u_int8_t);
void		 print_network(struct network_config *, const char *);
void		 print_peer(struct peer_config *, struct bgpd_config *,
		    const char *);
const char	*print_auth_alg(u_int8_t);
const char	*print_enc_alg(u_int8_t);
void		 print_announce(struct peer_config *, const char *);
void		 print_as(struct filter_rule *);
void		 print_rule(struct peer *, struct filter_rule *);
const char	*mrt_type(enum mrt_type);
void		 print_mrt(struct bgpd_config *, u_int32_t, u_int32_t,
		    const char *, const char *);
void		 print_groups(struct bgpd_config *, struct peer *);
int		 peer_compare(const void *, const void *);

void
print_op(enum comp_ops op)
{
	switch (op) {
	case OP_RANGE:
		printf("-");
		break;
	case OP_XRANGE:
		printf("><");
		break;
	case OP_EQ:
		printf("=");
		break;
	case OP_NE:
		printf("!=");
		break;
	case OP_LE:
		printf("<=");
		break;
	case OP_LT:
		printf("<");
		break;
	case OP_GE:
		printf(">=");
		break;
	case OP_GT:
		printf(">");
		break;
	default:
		printf("?");
		break;
	}
}

void
print_community(int as, int type)
{
	if (as == COMMUNITY_ANY)
		printf("*:");
	else if (as == COMMUNITY_NEIGHBOR_AS)
		printf("neighbor-as:");
	else if (as == COMMUNITY_LOCAL_AS)
		printf("local-as:");
	else
		printf("%u:", (unsigned int)as);

	if (type == COMMUNITY_ANY)
		printf("* ");
	else if (type == COMMUNITY_NEIGHBOR_AS)
		printf("neighbor-as ");
	else if (type == COMMUNITY_LOCAL_AS)
		printf("local-as");
	else
		printf("%d ", type);
}

void
print_largecommunity(int64_t as, int64_t ld1, int64_t ld2)
{
	if (as == COMMUNITY_ANY)
		printf("*:");
	else if (as == COMMUNITY_NEIGHBOR_AS)
		printf("neighbor-as:");
	else if (as == COMMUNITY_LOCAL_AS)
		printf("local-as:");
	else
		printf("%lld:", as);

	if (ld1 == COMMUNITY_ANY)
		printf("*:");
	else if (ld1 == COMMUNITY_NEIGHBOR_AS)
		printf("neighbor-as:");
	else if (ld1 == COMMUNITY_LOCAL_AS)
		printf("local-as:");
	else
		printf("%lld:", ld1);

	if (ld2 == COMMUNITY_ANY)
		printf("* ");
	else if (ld2 == COMMUNITY_NEIGHBOR_AS)
		printf("neighbor-as ");
	else if (ld2 == COMMUNITY_LOCAL_AS)
		printf("local-as ");
	else
		printf("%lld ", ld2);

}


void
print_extcommunity(struct filter_extcommunity *c)
{
	printf("%s ", log_ext_subtype(c->type, c->subtype));

	switch (c->type) {
	case EXT_COMMUNITY_TRANS_TWO_AS:
		printf("%hu:%u ", c->data.ext_as.as, c->data.ext_as.val);
		break;
	case EXT_COMMUNITY_TRANS_IPV4:
		printf("%s:%u ", inet_ntoa(c->data.ext_ip.addr),
		    c->data.ext_ip.val);
		break;
	case EXT_COMMUNITY_TRANS_FOUR_AS:
		printf("%s:%u ", log_as(c->data.ext_as4.as4),
		    c->data.ext_as.val);
		break;
	case EXT_COMMUNITY_TRANS_OPAQUE:
	case EXT_COMMUNITY_TRANS_EVPN:
		printf("0x%llx ", c->data.ext_opaq);
		break;
	case EXT_COMMUNITY_NON_TRANS_OPAQUE:
		switch (c->data.ext_opaq) {
		case EXT_COMMUNITY_OVS_VALID:
			printf("valid ");
			break;
		case EXT_COMMUNITY_OVS_NOTFOUND:
			printf("not-found ");
			break;
		case EXT_COMMUNITY_OVS_INVALID:
			printf("invalid ");
			break;
		}
		break;
	default:
		printf("0x%llx ", c->data.ext_opaq);
		break;
	}
}

void
print_origin(u_int8_t o)
{
	if (o == ORIGIN_IGP)
		printf("igp ");
	else if (o == ORIGIN_EGP)
		printf("egp ");
	else if (o == ORIGIN_INCOMPLETE)
		printf("incomplete ");
	else
		printf("%u ", o);
}

void
print_set(struct filter_set_head *set)
{
	struct filter_set	*s;

	if (TAILQ_EMPTY(set))
		return;

	printf("set { ");
	TAILQ_FOREACH(s, set, entry) {
		switch (s->type) {
		case ACTION_SET_LOCALPREF:
			printf("localpref %u ", s->action.metric);
			break;
		case ACTION_SET_RELATIVE_LOCALPREF:
			printf("localpref %+d ", s->action.relative);
			break;
		case ACTION_SET_MED:
			printf("metric %u ", s->action.metric);
			break;
		case ACTION_SET_RELATIVE_MED:
			printf("metric %+d ", s->action.relative);
			break;
		case ACTION_SET_WEIGHT:
			printf("weight %u ", s->action.metric);
			break;
		case ACTION_SET_RELATIVE_WEIGHT:
			printf("weight %+d ", s->action.relative);
			break;
		case ACTION_SET_NEXTHOP:
			printf("nexthop %s ", log_addr(&s->action.nexthop));
			break;
		case ACTION_SET_NEXTHOP_REJECT:
			printf("nexthop reject ");
			break;
		case ACTION_SET_NEXTHOP_BLACKHOLE:
			printf("nexthop blackhole ");
			break;
		case ACTION_SET_NEXTHOP_NOMODIFY:
			printf("nexthop no-modify ");
			break;
		case ACTION_SET_NEXTHOP_SELF:
			printf("nexthop self ");
			break;
		case ACTION_SET_PREPEND_SELF:
			printf("prepend-self %u ", s->action.prepend);
			break;
		case ACTION_SET_PREPEND_PEER:
			printf("prepend-neighbor %u ", s->action.prepend);
			break;
		case ACTION_DEL_COMMUNITY:
			printf("community delete ");
			print_community(s->action.community.as,
			    s->action.community.type);
			printf(" ");
			break;
		case ACTION_SET_COMMUNITY:
			printf("community ");
			print_community(s->action.community.as,
			    s->action.community.type);
			printf(" ");
			break;
		case ACTION_DEL_LARGE_COMMUNITY:
			printf("large-community delete ");
			print_largecommunity(s->action.large_community.as,
			    s->action.large_community.ld1,
			    s->action.large_community.ld2);
			printf(" ");
			break;
		case ACTION_SET_LARGE_COMMUNITY:
			printf("large-community ");
			print_largecommunity(s->action.large_community.as,
			    s->action.large_community.ld1,
			    s->action.large_community.ld2);
			printf(" ");
			break;
		case ACTION_PFTABLE:
			printf("pftable %s ", s->action.pftable);
			break;
		case ACTION_RTLABEL:
			printf("rtlabel %s ", s->action.rtlabel);
			break;
		case ACTION_SET_ORIGIN:
			printf("origin ");
			print_origin(s->action.origin);
			break;
		case ACTION_RTLABEL_ID:
		case ACTION_PFTABLE_ID:
			/* not possible */
			printf("king bula saiz: config broken");
			break;
		case ACTION_SET_EXT_COMMUNITY:
			printf("ext-community ");
			print_extcommunity(&s->action.ext_community);
			break;
		case ACTION_DEL_EXT_COMMUNITY:
			printf("ext-community delete ");
			print_extcommunity(&s->action.ext_community);
			break;
		}
	}
	printf("}");
}

void
print_mainconf(struct bgpd_config *conf)
{
	struct in_addr		 ina;
	struct listen_addr	*la;

	printf("AS %s", log_as(conf->as));
	if (conf->as > USHRT_MAX && conf->short_as != AS_TRANS)
		printf(" %u", conf->short_as);
	ina.s_addr = conf->bgpid;
	printf("\nrouter-id %s\n", inet_ntoa(ina));

	printf("socket \"%s\"\n", conf->csock);
	if (conf->rcsock)
		printf("socket \"%s\" restricted\n", conf->rcsock);
	if (conf->holdtime)
		printf("holdtime %u\n", conf->holdtime);
	if (conf->min_holdtime)
		printf("holdtime min %u\n", conf->min_holdtime);
	if (conf->connectretry)
		printf("connect-retry %u\n", conf->connectretry);

	if (conf->flags & BGPD_FLAG_NO_EVALUATE)
		printf("route-collector yes\n");

	if (conf->flags & BGPD_FLAG_DECISION_ROUTEAGE)
		printf("rde route-age evaluate\n");

	if (conf->flags & BGPD_FLAG_DECISION_MED_ALWAYS)
		printf("rde med compare always\n");

	if (conf->log & BGPD_LOG_UPDATES)
		printf("log updates\n");

	TAILQ_FOREACH(la, conf->listen_addrs, entry)
		printf("listen on %s\n",
		    log_sockaddr((struct sockaddr *)&la->sa));

	if (conf->flags & BGPD_FLAG_NEXTHOP_BGP)
		printf("nexthop qualify via bgp\n");
	if (conf->flags & BGPD_FLAG_NEXTHOP_DEFAULT)
		printf("nexthop qualify via default\n");
	printf("fib-priority %hhu", conf->fib_priority);
}

void
print_rdomain_targets(struct filter_set_head *set, const char *tgt)
{
	struct filter_set	*s;
	TAILQ_FOREACH(s, set, entry) {
		printf("\t%s ", tgt);
		print_extcommunity(&s->action.ext_community);
		printf("\n");
	}
}

void
print_rdomain(struct rdomain *r)
{
	struct network *n;

	printf("rdomain %u {\n", r->rtableid);
	if (*r->descr)
		printf("\tdescr \"%s\"\n", r->descr);
	if (r->flags & F_RIB_NOFIBSYNC)
		printf("\tfib-update no\n");
	else
		printf("\tfib-update yes\n");
	printf("\tdepend on %s\n", r->ifmpe);

	TAILQ_FOREACH(n, &r->net_l, entry)
		print_network(&n->net, "\t");

	printf("\n\t%s\n", log_rd(r->rd));

	print_rdomain_targets(&r->export, "export-target");
	print_rdomain_targets(&r->import, "import-target");

	printf("}\n");
}

const char *
print_af(u_int8_t aid)
{
	/*
	 * Hack around the fact that aid2str() will return "IPv4 unicast"
	 * for AID_INET. AID_INET and AID_INET6 need special handling and
	 * the other AID should never end up here (at least for now).
	 */
	if (aid == AID_INET)
		return ("inet");
	if (aid == AID_INET6)
		return ("inet6");
	return (aid2str(aid));
}

void
print_network(struct network_config *n, const char *c)
{
	switch (n->type) {
	case NETWORK_STATIC:
		printf("%snetwork %s static", c, print_af(n->prefix.aid));
		break;
	case NETWORK_CONNECTED:
		printf("%snetwork %s connected", c, print_af(n->prefix.aid));
		break;
	case NETWORK_RTLABEL:
		printf("%snetwork %s rtlabel \"%s\"", c,
		    print_af(n->prefix.aid), rtlabel_id2name(n->rtlabel));
		break;
	default:
		printf("%snetwork %s/%u", c, log_addr(&n->prefix),
		    n->prefixlen);
		break;
	}
	if (!TAILQ_EMPTY(&n->attrset))
		printf(" ");
	print_set(&n->attrset);
	printf("\n");
}

void
print_peer(struct peer_config *p, struct bgpd_config *conf, const char *c)
{
	char		*method;
	struct in_addr	 ina;

	if ((p->remote_addr.aid == AID_INET && p->remote_masklen != 32) ||
	    (p->remote_addr.aid == AID_INET6 && p->remote_masklen != 128))
		printf("%sneighbor %s/%u {\n", c, log_addr(&p->remote_addr),
		    p->remote_masklen);
	else
		printf("%sneighbor %s {\n", c, log_addr(&p->remote_addr));
	if (p->descr[0])
		printf("%s\tdescr \"%s\"\n", c, p->descr);
	if (p->rib[0])
		printf("%s\trib \"%s\"\n", c, p->rib);
	if (p->remote_as)
		printf("%s\tremote-as %s\n", c, log_as(p->remote_as));
	if (p->local_as != conf->as) {
		printf("%s\tlocal-as %s", c, log_as(p->local_as));
		if (p->local_as > USHRT_MAX && p->local_short_as != AS_TRANS)
			printf(" %u", p->local_short_as);
		printf("\n");
	}
	if (p->down)
		printf("%s\tdown\n", c);
	if (p->distance > 1)
		printf("%s\tmultihop %u\n", c, p->distance);
	if (p->passive)
		printf("%s\tpassive\n", c);
	if (p->local_addr.aid)
		printf("%s\tlocal-address %s\n", c, log_addr(&p->local_addr));
	if (p->max_prefix) {
		printf("%s\tmax-prefix %u", c, p->max_prefix);
		if (p->max_prefix_restart)
			printf(" restart %u", p->max_prefix_restart);
		printf("\n");
	}
	if (p->holdtime)
		printf("%s\tholdtime %u\n", c, p->holdtime);
	if (p->min_holdtime)
		printf("%s\tholdtime min %u\n", c, p->min_holdtime);
	if (p->announce_capa == 0)
		printf("%s\tannounce capabilities no\n", c);
	if (p->capabilities.refresh == 0)
		printf("%s\tannounce refresh no\n", c);
	if (p->capabilities.grestart.restart == 0)
		printf("%s\tannounce restart no\n", c);
	if (p->capabilities.as4byte == 0)
		printf("%s\tannounce as4byte no\n", c);
	if (p->announce_type == ANNOUNCE_SELF)
		printf("%s\tannounce self\n", c);
	else if (p->announce_type == ANNOUNCE_NONE)
		printf("%s\tannounce none\n", c);
	else if (p->announce_type == ANNOUNCE_ALL)
		printf("%s\tannounce all\n", c);
	else if (p->announce_type == ANNOUNCE_DEFAULT_ROUTE)
		printf("%s\tannounce default-route\n", c);
	else
		printf("%s\tannounce ???\n", c);
	if (p->enforce_as == ENFORCE_AS_ON)
		printf("%s\tenforce neighbor-as yes\n", c);
	else
		printf("%s\tenforce neighbor-as no\n", c);
	if (p->enforce_local_as == ENFORCE_AS_ON)
		printf("%s\tenforce local-as yes\n", c);
	else
		printf("%s\tenforce local-as no\n", c);
	if (p->reflector_client) {
		if (conf->clusterid == 0)
			printf("%s\troute-reflector\n", c);
		else {
			ina.s_addr = conf->clusterid;
			printf("%s\troute-reflector %s\n", c,
			    inet_ntoa(ina));
		}
	}
	if (p->demote_group[0])
		printf("%s\tdemote %s\n", c, p->demote_group);
	if (p->if_depend[0])
		printf("%s\tdepend on \"%s\"\n", c, p->if_depend);
	if (p->flags & PEERFLAG_TRANS_AS)
		printf("%s\ttransparent-as yes\n", c);

	if (p->flags & PEERFLAG_LOG_UPDATES)
		printf("%s\tlog updates\n", c);

	if (p->auth.method == AUTH_MD5SIG)
		printf("%s\ttcp md5sig\n", c);
	else if (p->auth.method == AUTH_IPSEC_MANUAL_ESP ||
	    p->auth.method == AUTH_IPSEC_MANUAL_AH) {
		if (p->auth.method == AUTH_IPSEC_MANUAL_ESP)
			method = "esp";
		else
			method = "ah";

		printf("%s\tipsec %s in spi %u %s XXXXXX", c, method,
		    p->auth.spi_in, print_auth_alg(p->auth.auth_alg_in));
		if (p->auth.enc_alg_in)
			printf(" %s XXXXXX", print_enc_alg(p->auth.enc_alg_in));
		printf("\n");

		printf("%s\tipsec %s out spi %u %s XXXXXX", c, method,
		    p->auth.spi_out, print_auth_alg(p->auth.auth_alg_out));
		if (p->auth.enc_alg_out)
			printf(" %s XXXXXX",
			    print_enc_alg(p->auth.enc_alg_out));
		printf("\n");
	} else if (p->auth.method == AUTH_IPSEC_IKE_AH)
		printf("%s\tipsec ah ike\n", c);
	else if (p->auth.method == AUTH_IPSEC_IKE_ESP)
		printf("%s\tipsec esp ike\n", c);

	if (p->ttlsec)
		printf("%s\tttl-security yes\n", c);

	print_announce(p, c);

	print_mrt(conf, p->id, p->groupid, c, "\t");

	printf("%s}\n", c);
}

const char *
print_auth_alg(u_int8_t alg)
{
	switch (alg) {
	case SADB_AALG_SHA1HMAC:
		return ("sha1");
	case SADB_AALG_MD5HMAC:
		return ("md5");
	default:
		return ("???");
	}
}

const char *
print_enc_alg(u_int8_t alg)
{
	switch (alg) {
	case SADB_EALG_3DESCBC:
		return ("3des");
	case SADB_X_EALG_AES:
		return ("aes");
	default:
		return ("???");
	}
}

void
print_announce(struct peer_config *p, const char *c)
{
	u_int8_t	aid;

	for (aid = 0; aid < AID_MAX; aid++)
		if (p->capabilities.mp[aid])
			printf("%s\tannounce %s\n", c, aid2str(aid));
}

void print_as(struct filter_rule *r)
{
	switch(r->match.as.op) {
	case OP_RANGE:
		printf("%s - ", log_as(r->match.as.as_min));
		printf("%s ", log_as(r->match.as.as_max));
		break;
	case OP_XRANGE:
		printf("%s >< ", log_as(r->match.as.as_min));
		printf("%s ", log_as(r->match.as.as_max));
		break;
	case OP_NE:
		printf("!= %s ", log_as(r->match.as.as));
		break;
	default:
		printf("%s ", log_as(r->match.as.as));
		break;
	}
}

void
print_rule(struct peer *peer_l, struct filter_rule *r)
{
	struct peer	*p;

	if (r->action == ACTION_ALLOW)
		printf("allow ");
	else if (r->action == ACTION_DENY)
		printf("deny ");
	else
		printf("match ");
	if (r->quick)
		printf("quick ");

	if (r->rib[0])
		printf("rib %s ", r->rib);

	if (r->dir == DIR_IN)
		printf("from ");
	else if (r->dir == DIR_OUT)
		printf("to ");
	else
		printf("eeeeeeeps. ");

	if (r->peer.peerid) {
		for (p = peer_l; p != NULL && p->conf.id != r->peer.peerid;
		    p = p->next)
			;	/* nothing */
		if (p == NULL)
			printf("? ");
		else
			printf("%s ", log_addr(&p->conf.remote_addr));
	} else if (r->peer.groupid) {
		for (p = peer_l; p != NULL &&
		    p->conf.groupid != r->peer.groupid; p = p->next)
			;	/* nothing */
		if (p == NULL)
			printf("group ? ");
		else
			printf("group \"%s\" ", p->conf.group);
	} else if (r->peer.remote_as) {
		printf("AS %s ", log_as(r->peer.remote_as));
	} else if (r->peer.ebgp) {
		printf("ebgp ");
	} else if (r->peer.ibgp) {
		printf("ibgp ");
	} else
		printf("any ");

	if (r->match.prefix.addr.aid)
		printf("prefix %s/%u ", log_addr(&r->match.prefix.addr),
		    r->match.prefix.len);

	if (r->match.prefix.op) {
		if (r->match.prefix.op == OP_RANGE ||
		    r->match.prefix.op == OP_XRANGE) {
			printf("prefixlen %u ", r->match.prefix.len_min);
			print_op(r->match.prefix.op);
			printf(" %u ", r->match.prefix.len_max);
		} else {
			printf("prefixlen ");
			print_op(r->match.prefix.op);
			printf(" %u ", r->match.prefix.len_min);
		}
	}

	if (r->match.nexthop.flags) {
		if (r->match.nexthop.flags == FILTER_NEXTHOP_NEIGHBOR)
			printf("nexthop neighbor ");
		else
			printf("nexthop %s ", log_addr(&r->match.nexthop.addr));
	}

	if (r->match.as.type) {
		if (r->match.as.type == AS_ALL)
			printf("AS ");
		else if (r->match.as.type == AS_SOURCE)
			printf("source-as ");
		else if (r->match.as.type == AS_TRANSIT)
			printf("transit-as ");
		else if (r->match.as.type == AS_PEER)
			printf("peer-as ");
		else
			printf("unfluffy-as ");
		print_as(r);
	}

	if (r->match.aslen.type) {
		printf("%s %u ", r->match.aslen.type == ASLEN_MAX ?
		    "max-as-len" : "max-as-seq", r->match.aslen.aslen);
	}

	if (r->match.community.as != COMMUNITY_UNSET) {
		printf("community ");
		print_community(r->match.community.as,
		    r->match.community.type);
	}
	if (r->match.ext_community.flags & EXT_COMMUNITY_FLAG_VALID) {
		printf("ext-community ");
		print_extcommunity(&r->match.ext_community);
	}
	if (r->match.large_community.as != COMMUNITY_UNSET) {
		printf("large-community ");
		print_largecommunity(r->match.large_community.as,
		    r->match.large_community.ld1,
		    r->match.large_community.ld2);
	}

	print_set(&r->set);

	printf("\n");
}

const char *
mrt_type(enum mrt_type t)
{
	switch (t) {
	case MRT_NONE:
		break;
	case MRT_TABLE_DUMP:
		return "table";
	case MRT_TABLE_DUMP_MP:
		return "table-mp";
	case MRT_TABLE_DUMP_V2:
		return "table-v2";
	case MRT_ALL_IN:
		return "all in";
	case MRT_ALL_OUT:
		return "all out";
	case MRT_UPDATE_IN:
		return "updates in";
	case MRT_UPDATE_OUT:
		return "updates out";
	}
	return "unfluffy MRT";
}

void
print_mrt(struct bgpd_config *conf, u_int32_t pid, u_int32_t gid,
    const char *prep, const char *prep2)
{
	struct mrt	*m;

	if (conf->mrt == NULL)
		return;

	LIST_FOREACH(m, conf->mrt, entry)
		if ((gid != 0 && m->group_id == gid) ||
		    (m->peer_id == pid && m->group_id == gid)) {
			printf("%s%sdump ", prep, prep2);
			if (m->rib[0])
				printf("rib %s ", m->rib);
			printf("%s \"%s\"", mrt_type(m->type),
			    MRT2MC(m)->name);
			if (MRT2MC(m)->ReopenTimerInterval == 0)
				printf("\n");
			else
				printf(" %d\n", MRT2MC(m)->ReopenTimerInterval);
		}
}

void
print_groups(struct bgpd_config *conf, struct peer *peer_l)
{
	struct peer_config	**peerlist;
	struct peer		 *p;
	u_int			  peer_cnt, i;
	u_int32_t		  prev_groupid;
	const char		 *tab	= "\t";
	const char		 *nada	= "";
	const char		 *c;

	peer_cnt = 0;
	for (p = peer_l; p != NULL; p = p->next)
		peer_cnt++;

	if ((peerlist = calloc(peer_cnt, sizeof(struct peer_config *))) == NULL)
		fatal("print_groups calloc");

	i = 0;
	for (p = peer_l; p != NULL; p = p->next)
		peerlist[i++] = &p->conf;

	qsort(peerlist, peer_cnt, sizeof(struct peer_config *), peer_compare);

	prev_groupid = 0;
	for (i = 0; i < peer_cnt; i++) {
		if (peerlist[i]->groupid) {
			c = tab;
			if (peerlist[i]->groupid != prev_groupid) {
				if (prev_groupid)
					printf("}\n\n");
				printf("group \"%s\" {\n", peerlist[i]->group);
				prev_groupid = peerlist[i]->groupid;
			}
		} else
			c = nada;

		print_peer(peerlist[i], conf, c);
	}

	if (prev_groupid)
		printf("}\n\n");

	free(peerlist);
}

int
peer_compare(const void *aa, const void *bb)
{
	const struct peer_config * const *a;
	const struct peer_config * const *b;

	a = aa;
	b = bb;

	return ((*a)->groupid - (*b)->groupid);
}

void
print_config(struct bgpd_config *conf, struct rib_names *rib_l,
    struct network_head *net_l, struct peer *peer_l,
    struct filter_head *rules_l, struct mrt_head *mrt_l,
    struct rdomain_head *rdom_l)
{
	struct filter_rule	*r;
	struct network		*n;
	struct rde_rib		*rr;
	struct rdomain		*rd;

	print_mainconf(conf);
	printf("\n");
	TAILQ_FOREACH(n, net_l, entry)
		print_network(&n->net, "");
	printf("\n");
	SIMPLEQ_FOREACH(rd, rdom_l, entry)
		print_rdomain(rd);
	printf("\n");
	SIMPLEQ_FOREACH(rr, rib_l, entry) {
		if (rr->flags & F_RIB_NOEVALUATE)
			printf("rde rib %s no evaluate\n", rr->name);
		else if (rr->flags & F_RIB_NOFIB)
			printf("rde rib %s\n", rr->name);
		else
			printf("rde rib %s rtable %u fib-update %s\n", rr->name,
			    rr->rtableid, rr->flags & F_RIB_NOFIBSYNC ?
			    "no" : "yes");
	}
	printf("\n");
	print_mrt(conf, 0, 0, "", "");
	printf("\n");
	print_groups(conf, peer_l);
	printf("\n");
	TAILQ_FOREACH(r, rules_l, entry)
		print_rule(peer_l, r);
}
@


1.105
log
@softreconfig in and out are on by default for ever and machines now have
enough memory that it does not make sense to provide these knobs anymore.
They just make the code more complex for no much gain.
OK phessler@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.104 2017/05/31 10:44:00 claudio Exp $	*/
d644 4
@


1.104
log
@Rework the way we do extended communities (mainly in the parser) and update
the IANA table to a somewhat more complete list. This includes BGP Prefix
Origin Validation State support via the ext-community ovs keyword.
OK henning@@ benno@@ based on a diff by Job Snijders
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.103 2017/05/27 18:12:23 phessler Exp $	*/
a539 11

	if (p->softreconfig_in == 1)
		printf("%s\tsoftreconfig in yes\n", c);
	else
		printf("%s\tsoftreconfig in no\n", c);

	if (p->softreconfig_out == 1)
		printf("%s\tsoftreconfig out yes\n", c);
	else
		printf("%s\tsoftreconfig out no\n", c);

@


1.103
log
@Allow an administrator to disable the bgp loop detection algorithm,
which is useful in very limited situations.

Angry dragons and grues will hunt for you, if you use it.

OK claudio@@ sthen@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.102 2017/05/27 10:33:15 phessler Exp $	*/
d148 30
a177 16
	switch (c->type & EXT_COMMUNITY_VALUE) {
	case EXT_COMMUNITY_TWO_AS:
		printf("%s %hu:%u ", log_ext_subtype(c->subtype),
		    c->data.ext_as.as, c->data.ext_as.val);
		break;
	case EXT_COMMUNITY_IPV4:
		printf("%s %s:%u ", log_ext_subtype(c->subtype),
		    inet_ntoa(c->data.ext_ip.addr), c->data.ext_ip.val);
		break;
	case EXT_COMMUNITY_FOUR_AS:
		printf("%s %s:%u ", log_ext_subtype(c->subtype),
		    log_as(c->data.ext_as4.as4), c->data.ext_as.val);
		break;
	case EXT_COMMUNITY_OPAQUE:
		printf("%s 0x%llx ", log_ext_subtype(c->subtype),
		    c->data.ext_opaq);
d180 1
a180 1
		printf("0x%x 0x%llx ", c->type, c->data.ext_opaq);
@


1.102
log
@Allow OpenBGPD to selectively choose which local ASN to use per-peer.
This is intended to be used for ASN migrations, not for permanent use.

You MUST use filters to protect yourself from receiving your own routes.
There be dragons and grues.

OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.101 2017/05/27 10:24:44 phessler Exp $	*/
d473 4
@


1.101
log
@allow us to use 'local-as' in the filter language

"match in from any set community local-as:neighbor-as"

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.100 2017/01/24 04:22:42 benno Exp $	*/
d427 6
@


1.100
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.99 2016/10/14 16:05:36 phessler Exp $	*/
d97 2
d106 2
d119 2
d128 2
d137 2
@


1.99
log
@Add support for draft-ietf-idr-large-community

Joint work with Job Snijders, many thanks!
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.98 2016/10/05 07:38:06 phessler Exp $	*/
d30 1
@


1.98
log
@Let bgpd announce routes based on a route-label.

OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.97 2016/07/13 20:07:38 benno Exp $	*/
d5 2
d33 1
d108 27
d235 14
d674 6
@


1.97
log
@output the no-longer-so-new AS operators when printing the
configuration
noticed by and diff from Denis Fondras, thanks!

ok phessler@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.96 2015/09/21 09:47:15 phessler Exp $	*/
d338 4
@


1.96
log
@Let us log all updates sent from an individual peer.  Since this can be
applied to a group, also let us disable logging on a sub-member of the
group.  Very handy for debugging naughty peers on a router with multiple
peers.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.95 2015/07/16 18:26:04 claudio Exp $	*/
d44 1
d46 1
a46 1
const char *	 mrt_type(enum mrt_type);
d510 20
d601 1
a601 1
			printf("AS %s ", log_as(r->match.as.as));
d603 1
a603 1
			printf("source-as %s ", log_as(r->match.as.as));
d605 1
a605 1
			printf("transit-as %s ", log_as(r->match.as.as));
d607 1
a607 1
			printf("peer-as %s ", log_as(r->match.as.as));
d609 2
a610 1
			printf("unfluffy-as %s ", log_as(r->match.as.as));
@


1.95
log
@Next round of config cleanup. Move various lists into the bgpd_config struct.
This is the next step to better split parsing and merging the config.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.94 2015/04/25 15:28:18 phessler Exp $	*/
d422 3
@


1.94
log
@allow us to write rules that match directly on the peer AS

...
allow from AS 1 prefix 192.0.2.0/24
...

Also adjust the IRR ruleset output to include the declared peer AS,
instead of hoping they listed their neighbor IP address!


OK benno@@
older version OK: claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.93 2013/11/13 09:14:48 florian Exp $	*/
d46 2
a47 1
void		 print_mrt(u_int32_t, u_int32_t, const char *, const char *);
d465 1
a465 1
	print_mrt(p->id, p->groupid, c, "\t");
a631 2
struct mrt_head	*xmrt_l = NULL;

d633 2
a634 1
print_mrt(u_int32_t pid, u_int32_t gid, const char *prep, const char *prep2)
d638 1
a638 1
	if (xmrt_l == NULL)
d641 1
a641 1
	LIST_FOREACH(m, xmrt_l, entry)
a724 1
	xmrt_l = mrt_l;
d744 1
a744 1
	print_mrt(0, 0, "", "");
@


1.93
log
@Knob to set priority with which bgpd inserts routes into the kernel
routing table. Need for it in "special" setups pointed out by
Loic Blot (loic.blot _AT_ unix-experience _DOT_ fr) on tech.
OK benno, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.92 2013/10/30 17:28:33 deraadt Exp $	*/
d545 2
@


1.92
log
@use more careful format strings to deal with various forms of AS#'s
ok claudio benno
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.91 2013/10/19 15:04:25 claudio Exp $	*/
d273 1
@


1.91
log
@Merge the prefix and prefixlen filter bits into one filter. Change the
filter expansion so that rules are grouped by prefixes last. The RDE will
then be able to optimize the rules into table lookups but that is a later
step. As additional goodies it is now possible to use inet and inet6
on their own and or-longer can be used as a shorthand for prefixlen >= len.
OK henning@@ sthen@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.90 2013/01/17 02:00:33 claudio Exp $	*/
d92 1
a92 1
		printf("%d:", as);
d107 1
a107 1
		printf("%s %i:%i ", log_ext_subtype(c->subtype),
d111 1
a111 1
		printf("%s %s:%i ", log_ext_subtype(c->subtype),
d115 1
a115 1
		printf("%s %s:%i ", log_ext_subtype(c->subtype),
@


1.90
log
@Fixup printing of rdomain configs -- add network statements and only print
the description if it is set.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.89 2012/11/13 09:47:20 claudio Exp $	*/
d551 6
a556 13
	if (r->match.prefix.addr.aid == 0 && r->match.prefixlen.aid) {
		if (r->match.prefixlen.aid == AID_INET)
			printf("inet ");
		if (r->match.prefixlen.aid == AID_INET6)
			printf("inet6 ");
	}

	if (r->match.prefixlen.op) {
		if (r->match.prefixlen.op == OP_RANGE ||
		    r->match.prefixlen.op == OP_XRANGE) {
			printf("prefixlen %u ", r->match.prefixlen.len_min);
			print_op(r->match.prefixlen.op);
			printf(" %u ", r->match.prefixlen.len_max);
d559 2
a560 2
			print_op(r->match.prefixlen.op);
			printf(" %u ", r->match.prefixlen.len_min);
@


1.89
log
@Allow filtering based on the NEXTHOP attribute. This allows to build rules
like: allow from any nexthop neighbor (to allow only prefixes that use the
routers IP address as nexthop). Lots of testing, input and OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.88 2012/09/23 09:39:18 claudio Exp $	*/
d38 1
a38 1
void		 print_network(struct network_config *);
d289 2
d292 2
a293 1
	printf("\tdescr \"%s\"\n", r->descr);
d300 3
d327 1
a327 1
print_network(struct network_config *n)
d331 1
a331 1
		printf("network %s static", print_af(n->prefix.aid));
d334 1
a334 1
		printf("network %s connected", print_af(n->prefix.aid));
d337 2
a338 1
		printf("network %s/%u", log_addr(&n->prefix), n->prefixlen);
d733 1
a733 1
		print_network(&n->net);
@


1.88
log
@Enable graceful restart by default. The only way to find out if it works for
real. After discussion with sthen@@, henning@@ and deraadt@@.
It can be disabled per neighbor with "announce restart no".
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.87 2012/09/12 05:56:22 claudio Exp $	*/
d562 7
@


1.87
log
@Better graceful restart support (implementing more then just the EoR record).
This implements only the "Restarting Client" bits of the RFC -- in other
words bgpd will keep the FIB when the client restarts but it will not do GR
when restarting itself. The capability is still off by default (you need
"announce restart yes" to enable it).
Tested by Anders Berggren. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.86 2011/09/17 16:29:44 claudio Exp $	*/
d380 2
a381 2
	if (p->capabilities.grestart.restart == 1)
		printf("%s\tannounce restart yes\n", c);
@


1.86
log
@Implement new mrt table dump format as specified in draft-ietf-grow-mrt.
Tested with IP and IPv6 sessions and against the libbgpdump parser.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.85 2010/12/31 21:22:42 guenther Exp $	*/
d380 1
a380 1
	if (p->capabilities.restart == 1)
@


1.85
log
@Add missing #includes instead of assuming that some system header pulls in
the needed bits

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.84 2010/08/06 14:32:13 jsg Exp $	*/
d607 2
d637 2
d640 1
a640 2
				printf("%s %s\n", mrt_type(m->type),
				    MRT2MC(m)->name);
d642 1
a642 3
				printf("%s %s %d\n", mrt_type(m->type),
				    MRT2MC(m)->name,
				    MRT2MC(m)->ReopenTimerInterval);
@


1.84
log
@Correct a problem which could cause the wrong af to be displayed.
Found via the clang static analyser.
ok henning@@ claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.83 2010/06/27 19:53:34 claudio Exp $	*/
d19 1
@


1.83
log
@Instead of specifying the control sockets on the command line have them
in bgpd.conf. This allows to add/modify restricted control sockets on runtime.
Feature request by a few people how often forgot to add -r path when restarting
bgpd (including myself).
NOTE: this removes the -s and -r arguments from bgpd so pay attention when
updateing.
jajaja sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.82 2010/05/17 16:08:20 claudio Exp $	*/
d314 1
a314 1
	if (aid == AID_INET6);
@


1.82
log
@Implement two new filters, max-as-len and max-as-seq. The first is limiting
the length of an AS path (matches if the path is longer then the specified
lenght) the second matches when a sequence of the same AS number is longer
then the specified length).
max-as-len is good to protect crappy comercial bgp boxes from other crappy
comercial bgp boxes. max-as-seq was a feature request from SwissIX and maybe
EuroIX to find and filter prepends.
Additinal testing and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.81 2010/05/17 15:49:29 claudio Exp $	*/
d241 4
@


1.81
log
@Last bits of MPLS VPN support. Hook kernel routing tables and RIB together.
This adds a bit of new config to specify the mapping between an rdomain and
the BGP MPLS VPN instance, example:
rdomain 1 {
        descr "CUSTOMER1"
	rd 65003:1
	import-target rt 65003:3
	export-target rt 65003:1
	depend on mpe0
	network 192.168.224/24
}
The "depend on mpe0" is a but ugly but for now this is the quickest way to
figure out which interface bgp should use to insert the MPLS routes.

A big side-effect of this diff is that networks are now internally
distributed through kroute.c.
This needs some kernel changes that will follow hopefully soon.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.80 2010/05/03 13:09:38 claudio Exp $	*/
d570 5
@


1.80
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.79 2010/03/05 15:25:00 claudio Exp $	*/
d34 3
d268 1
d270 7
a276 5
	if (conf->flags & BGPD_FLAG_REDIST_CONNECTED) {
		printf("network inet connected");
		if (!TAILQ_EMPTY(&conf->connectset))
			printf(" ");
		print_set(&conf->connectset);
d279 34
a312 23
	if (conf->flags & BGPD_FLAG_REDIST_STATIC) {
		printf("network inet static");
		if (!TAILQ_EMPTY(&conf->staticset))
			printf(" ");
		print_set(&conf->staticset);
		printf("\n");
	}
	if (conf->flags & BGPD_FLAG_REDIST6_CONNECTED) {
		printf("network inet6 connected");
		if (!TAILQ_EMPTY(&conf->connectset6))
			printf(" ");
		print_set(&conf->connectset6);
		printf("\n");
	}
	if (conf->flags & BGPD_FLAG_REDIST6_STATIC) {
		printf("network inet6 static");
		if (!TAILQ_EMPTY(&conf->staticset6))
			printf(" ");
		print_set(&conf->staticset6);
		printf("\n");
	}
	if (conf->rtableid)
		printf("rtable %u\n", conf->rtableid);
d318 11
a328 1
	printf("network %s/%u", log_addr(&n->prefix), n->prefixlen);
d696 2
a697 1
    struct filter_head *rules_l, struct mrt_head *mrt_l)
d702 1
d705 4
d710 2
a711 1
	print_mainconf(conf);
a722 3
	printf("\n");
	TAILQ_FOREACH(n, net_l, entry)
		print_network(&n->net);
@


1.79
log
@Allow to filter for ext-community attributes. Currently only perfect matches
work but that's already better then nothing. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.78 2010/03/03 22:09:08 claudio Exp $	*/
a244 5
	if (conf->flags & BGPD_FLAG_NO_FIB_UPDATE)
		printf("fib-update no\n");
	else
		printf("fib-update yes\n");

d682 2
d685 3
a687 1
			printf("rde rib %s\n", rr->name);
@


1.78
log
@Compare against correct flag when printing "network inet6 static"
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.77 2009/12/17 09:32:59 claudio Exp $	*/
d103 1
a103 1
		printf("%s %i:%i", log_ext_subtype(c->subtype),
d107 1
a107 1
		printf("%s %s:%i", log_ext_subtype(c->subtype),
d111 1
a111 1
		printf("%s %s:%i", log_ext_subtype(c->subtype),
d115 1
a115 1
		printf("%s 0x%llx", log_ext_subtype(c->subtype),
d119 1
a119 1
		printf("0x%x 0x%llx", c->type, c->data.ext_opaq);
a216 1
			printf(" ");
a220 1
			printf(" ");
d554 4
@


1.77
log
@Fix formatstring in printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.76 2009/12/16 15:40:55 claudio Exp $	*/
d294 1
a294 1
	if (conf->flags & BGPD_FLAG_REDIST_STATIC) {
@


1.76
log
@Implement "set ext-community [delete] subtype key:value" to set and delete
extended communities as specified in RFC 4360. No matching implemented yet
and stuff like * and neighbor-as are neither supported but will be soon.
Looks good henning & sthen, manpage fixed by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.75 2009/12/08 14:03:40 claudio Exp $	*/
d115 1
a115 1
		printf("%s 0x%x", log_ext_subtype(c->subtype),
@


1.75
log
@Big AID change part two. This changes the mp capability into an array of
flags. This makes a lot of code much easier since the comparison is now
trivial. Additionally calculate the negotiated capabilities for a session
in the SE and pass that and only that to the RDE. This makes the decisions
in the RDE a lot easier.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.74 2009/12/01 14:28:05 claudio Exp $	*/
d30 1
d99 26
d213 10
@


1.74
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.73 2009/11/26 13:40:43 henning Exp $	*/
d38 1
a38 1
const char	*print_safi(u_int8_t);
d381 1
a381 2
	printf("%s\tannounce IPv4 %s\n", c, print_safi(p->capabilities.mp_v4));
	printf("%s\tannounce IPv6 %s\n", c, print_safi(p->capabilities.mp_v6));
d425 2
a426 2
const char *
print_safi(u_int8_t safi)
d428 5
a432 8
	switch (safi) {
	case SAFI_NONE:
		return ("none");
	case SAFI_UNICAST:
		return ("unicast");
	default:
		return ("?");
	}
@


1.73
log
@support for set origin; based on an initial diff from
Sebastian Benoit <benoit-lists at fb12 dot de> who also tested this version
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.72 2009/10/13 11:41:32 claudio Exp $	*/
d284 2
a285 2
	if ((p->remote_addr.af == AF_INET && p->remote_masklen != 32) ||
	    (p->remote_addr.af == AF_INET6 && p->remote_masklen != 128))
d302 1
a302 1
	if (p->local_addr.af)
d482 1
a482 1
	if (r->match.prefix.addr.af)
d486 2
a487 2
	if (r->match.prefix.addr.af == 0 && r->match.prefixlen.af) {
		if (r->match.prefixlen.af == AF_INET)
d489 1
a489 1
		if (r->match.prefixlen.af == AF_INET6)
@


1.72
log
@Forgot this bit when disableing restart capability.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.71 2009/10/06 09:44:13 claudio Exp $	*/
d30 1
d98 13
d177 4
@


1.71
log
@Add config knobs to enable/disable individual BGP capabilities per neighbor.
e.g. announce refresh no. With this be more aggressive when announcing our
capabilities and enable all of them by default. If there are troubles with
some neighbors adding the following config lines should bring you back
to the old behaviour:
announce refresh yes # was already on by default
announce restart no
announce as-4byte no # was only set on sessions to peers with 4byte AS nums
OK henning and sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.70 2009/06/06 01:10:29 claudio Exp $	*/
d300 2
a301 2
	if (p->capabilities.restart == 0)
		printf("%s\tannounce restart no\n", c);
@


1.70
log
@Some preliminary filter magic to support multiple RIBs on the filters.
It is ugly but does the trick for now. Filters will be rewritten anyway.
The rib specifier only makes sense on from rules. e.g. deny rib OMG from any
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.69 2009/06/05 20:26:38 claudio Exp $	*/
d298 6
@


1.69
log
@Adjust print_config to all the stuff added in the last days.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.68 2009/05/27 04:18:21 reyk Exp $	*/
a425 1

d428 3
@


1.68
log
@add an option to change the "connect-retry" timer which defaults to 120s.
this can be used to decrease the failover time in specific carp'ed
IBGP setups.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.67 2009/03/26 13:59:30 henning Exp $	*/
d26 1
d274 2
d539 3
d543 2
a544 2
				printf("%s%sdump %s %s\n", prep, prep2,
				    mrt_type(m->type), MRT2MC(m)->name);
d546 1
a546 2
				printf("%s%sdump %s %s %d\n", prep, prep2,
				    mrt_type(m->type),
d611 3
a613 2
print_config(struct bgpd_config *conf, struct network_head *net_l,
    struct peer *peer_l, struct filter_head *rules_l, struct mrt_head *mrt_l)
d617 1
d622 7
@


1.67
log
@argh, do not reuse the global trans_as flag to be applied to the peer
specific or we had to widen the peer specific flags without need.
defien PERRFLAG_TRANS_AS instead and use that
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.66 2009/03/22 22:35:00 henning Exp $	*/
d188 2
@


1.66
log
@make transparent-as yes|no settable peer neighbor with the global setting
acting as default.
per-neighbor requested by arnold nipper @@ decix, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.65 2007/11/22 11:37:25 henning Exp $	*/
d320 1
a320 1
	if (p->flags & BGPD_FLAG_DECISION_TRANS_AS)
@


1.65
log
@add "demote", was missing. noticed by camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.64 2007/05/28 17:26:33 henning Exp $	*/
a202 3
	if (conf->flags & BGPD_FLAG_DECISION_TRANS_AS)
		printf("transparent-as yes\n");

d320 2
@


1.64
log
@allow matching on communities using 0 in the AS part, that is in use.
that unfortunately means we cannot use 0 for "unset".
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.63 2007/05/15 11:07:46 henning Exp $	*/
d319 2
@


1.63
log
@printconf didn't handle the 'down' flag for peers
From: Stuart Henderson <stu@@spacehopper.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.62 2007/04/23 13:04:24 claudio Exp $	*/
d487 1
a487 1
	if (r->match.community.as != 0) {
@


1.62
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.61 2007/03/29 13:09:26 claudio Exp $	*/
d276 2
@


1.61
log
@Until now prefixlen defaulted to AF_INET if it was used without a prefix.
This makes prefixlen filtering for AF_INET6 unnecessary complex. From now
on if prefixlen is used alone the address family needs to be specified
beforehands via the new inet or inet6 keywords.
Remove an old check so that it is finally possible to filter IPv6 prefixes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.60 2007/03/06 16:52:48 henning Exp $	*/
d179 3
a181 1
	printf("AS %u\n", conf->as);
d183 1
a183 1
	printf("router-id %s\n", inet_ntoa(ina));
d275 1
a275 1
		printf("%s\tremote-as %u\n", c, p->remote_as);
d474 1
a474 1
			printf("AS %u ", r->match.as.as);
d476 1
a476 1
			printf("source-as %u ", r->match.as.as);
d478 1
a478 1
			printf("transit-as %u ", r->match.as.as);
d480 1
a480 1
			printf("peer-as %u ", r->match.as.as);
d482 1
a482 1
			printf("unfluffy-as %u ", r->match.as.as);
@


1.60
log
@allow filtering on peer-as (leftmost AS in path), ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.59 2006/12/05 12:08:13 henning Exp $	*/
d449 7
@


1.59
log
@implement the ttl security hack. since the pc slaves fear the word hack,
they call it "Generalized TTL Security Mechanism" officially, RFC 3682.
manpage with help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.58 2006/11/28 16:39:34 henning Exp $	*/
d470 2
@


1.58
log
@allow bgpd to work on alternate routing tables, claudio ok, jmc manpage help
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.57 2006/08/04 12:01:48 henning Exp $	*/
d343 3
@


1.57
log
@add "restart" to max-prefix, allows sessions suspended due to reaching
max-prefix to be restarted automagically after a given number of minutes
requested by "Sylwester S. Biernacki" <obeer@@obeer.com>, manpage help jmc,
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.56 2006/05/27 15:37:29 claudio Exp $	*/
d244 2
@


1.56
log
@Move prinitng of communities into own function so that special communities
like "*" or "neighbor-as" is printed correctly. Issue noticed by Leen Besselink.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.55 2006/04/04 12:03:26 henning Exp $	*/
d278 6
a283 2
	if (p->max_prefix)
		printf("%s\tmax-prefix %u\n", c, p->max_prefix);
@


1.55
log
@add "set nexthop self", force nexthop to be set to own address even with IBGP
requested & tested Falk Brockerhoff <fb@@smartterra.de>, and tony sarendal
tested this too. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.54 2006/03/22 13:30:35 claudio Exp $	*/
d28 1
d78 18
d146 4
a149 2
			printf("community delete %u:%u ",
			    s->action.community.as, s->action.community.type);
d152 2
a153 1
			printf("community %u:%u ", s->action.community.as,
d155 1
d467 2
a468 13
		if (r->match.community.as == COMMUNITY_ANY)
			printf("*:");
		else if (r->match.community.as == COMMUNITY_NEIGHBOR_AS)
			printf("neighbor-as:");
		else
			printf("%d:", r->match.community.as);

		if (r->match.community.type == COMMUNITY_ANY)
			printf("* ");
		else if (r->match.community.type == COMMUNITY_NEIGHBOR_AS)
			printf("neighbor-as ");
		else
			printf("%d ", r->match.community.type);
@


1.54
log
@Change the way bgpd selects nexthops. Up until now every route was considered
when calculating the nexthop. Now only non BGP routes and not the default
route are used unless forced with the new config options
 nexthop qualify via bgp
 nexthop qualify via default
This change is required for complex setups e.g. where an additional IGP is
running.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.53 2006/02/10 14:34:40 claudio Exp $	*/
d116 3
@


1.53
log
@Make it possible to turn suftreconfig in/out on or off. Default is on for
both directions. Manpage update follows. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.52 2006/02/09 21:05:09 claudio Exp $	*/
d184 5
@


1.52
log
@Implement "set community delete 65001:*" and friends. This will remove
communities from the path attributes. Useful to make sure that the ones you
set later are set by a (evil) peer.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.51 2006/02/02 14:06:05 claudio Exp $	*/
d309 11
@


1.51
log
@Implement new special community "neighbor-as". neighbor-as is expanded on
the fly to the remote AS of the current neighbor. This can be used to
simplify rulesets in a dramatic way -- going from a script based nightmare
down to a handfull rules. jajajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.50 2005/11/01 10:58:29 claudio Exp $	*/
d122 4
@


1.50
log
@Switch from the per peer filter set list to a filter-only solution.
The default filter_sets are converted into match filter rules that get
evaluated first. Simplifies code massively -- mainly the config reload
part -- and makes softreconfig out a piece of cake.  "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.49 2005/10/31 17:00:05 claudio Exp $	*/
d420 1
d423 2
d430 2
@


1.49
log
@Missing space in printf for unknown peers.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.48 2005/10/31 16:31:39 claudio Exp $	*/
a304 6

	if (!TAILQ_EMPTY(&p->attrset))
		printf("%s\t", c);
	print_set(&p->attrset);
	if (!TAILQ_EMPTY(&p->attrset))
		printf("\n");
@


1.48
log
@Print group names in rules in double quotes. Makes the output more parsable.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.47 2005/08/09 20:27:25 claudio Exp $	*/
d383 1
a383 1
			printf("?");
@


1.47
log
@Introduce new route decision tunable "rde med compare (always|strict)".
If set to always the med will also be compared between different AS.
The default is strict which is the way the RFC specifies it.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.46 2005/07/28 20:14:29 henning Exp $	*/
d393 1
a393 1
			printf("group %s ", p->conf.group);
@


1.46
log
@print the v4/v6 safi announce stuff, from wth
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.45 2005/07/01 13:38:14 claudio Exp $	*/
d167 3
@


1.45
log
@Switch filter_sets form SIMPLEQ to TAILQ, needed for upcomming stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.44 2005/07/01 09:19:24 claudio Exp $	*/
d35 1
d300 3
d337 13
@


1.44
log
@Make the pftable filter set use the name2id "cache" like the route labels.
This saves 14 bytes per aspath. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.43 2005/06/29 09:43:25 claudio Exp $	*/
d80 1
a80 1
	if (SIMPLEQ_EMPTY(set))
d84 1
a84 1
	SIMPLEQ_FOREACH(s, set, entry) {
d179 1
a179 1
		if (!SIMPLEQ_EMPTY(&conf->connectset))
d186 1
a186 1
		if (!SIMPLEQ_EMPTY(&conf->staticset))
d193 1
a193 1
		if (!SIMPLEQ_EMPTY(&conf->connectset6))
d200 1
a200 1
		if (!SIMPLEQ_EMPTY(&conf->staticset6))
d211 1
a211 1
	if (!SIMPLEQ_EMPTY(&n->attrset))
d299 1
a299 1
	if (!SIMPLEQ_EMPTY(&p->attrset))
d302 1
a302 1
	if (!SIMPLEQ_EMPTY(&p->attrset))
@


1.43
log
@rtlabel support via filter sets. Just use "set rtlabel foobar" in filters
network and neighbor statements and the routes are labeled accordingly.
While doing that fix some mem-leaks by introducing filterset_free() and
remove the free on send option of send_filterset().
This took a bit longer because we need to carefully track the rtlabel id
refcnts or bad things may happen on reloads.
henning@@ looks fine
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.42 2005/06/09 15:32:03 claudio Exp $	*/
d133 1
d135 1
a135 1
			printf("rtlabel id %d ", s->action.id);
@


1.42
log
@Change the "network connected|static" statements to "network inet|inet6
connected|static" so that it is possible to distinguish between IPv4 and IPv6
addresses. "network connected|static" is considered deprecated but will be
supported as an alias for "network inet connected|static" for some time (one
release) to simplify upgrades. This also solve a nasty crash when using
"network connected".  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.41 2005/04/28 13:54:45 claudio Exp $	*/
d128 7
@


1.41
log
@Support for "network connected" and "network static" -- announce all
directly connected respectively all static routes. The list is auto-
matically adjusted as soon as a route changes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.40 2005/04/18 11:00:42 claudio Exp $	*/
d170 1
a170 1
		printf("network connected");
d177 1
a177 1
		printf("network static");
d181 14
@


1.40
log
@Print mrt config after the main and network config. Main and network config
belong together. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.39 2005/04/12 14:32:00 claudio Exp $	*/
d168 15
@


1.39
log
@Introduce a per prefix weight.  The weight is used to tip prefixes with equal
long AS pathes in one or the other direction.  It weights a prefix at a very
late stage in the decision process. This is a nice bgpd feature to traffic
engineer networks where most AS pathes are equally long.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.38 2005/04/07 23:45:21 henning Exp $	*/
a499 2
	print_mrt(0, 0, "", "");
	printf("\n");
d502 2
@


1.38
log
@nicer output
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.37 2005/03/14 17:32:04 claudio Exp $	*/
d97 6
@


1.37
log
@Allow to modify the metrics in a relative way by prepending the number with
a '+' or '-'. e.g. set localpref +20. This is another gem from the FOSDEM
lying around on my HD gathering dust. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.36 2005/03/11 12:54:19 claudio Exp $	*/
d491 1
@


1.36
log
@Finally commit the transparent-as and nexthop no-modify stuff I wrote on the
way to FOSDEM. With transparent-as set to ye bgpd will not prepend his own
AS for sent updates. NB the neighbor needs to set "enforce neighbor-as no"
or it will not like the received AS paths. With set nexthop no-modify bgpd
will change the nexthop as done normaly.
OK henning@@ man page update with help of jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.35 2004/11/23 13:07:01 claudio Exp $	*/
d89 3
d94 3
@


1.35
log
@Switch from a single filter_set to a linked list of sets. With this change
it is possible to specify multiple communities. This is also the first step
to better bgpd filters. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.34 2004/11/18 17:07:38 henning Exp $	*/
d101 3
d146 3
@


1.34
log
@add an instance of struct capabilities to peer_conf, and inherit
peer->capa.ann from this
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.33 2004/11/11 10:35:15 claudio Exp $	*/
d28 1
a28 1
void		 print_set(struct filter_set *);
d76 1
a76 1
print_set(struct filter_set *set)
d78 18
a95 9
	if (set->flags) {
		printf("set { ");
		if (set->flags & SET_LOCALPREF)
			printf("localpref %u ", set->localpref);
		if (set->flags & SET_MED)
			printf("med %u ", set->med);
		if (set->flags & SET_NEXTHOP)
			printf("nexthop %s ", log_addr(&set->nexthop));
		if (set->flags & SET_NEXTHOP_REJECT)
d97 2
a98 1
		if (set->flags & SET_NEXTHOP_BLACKHOLE)
d100 15
a114 5
		if (set->flags & SET_PREPEND_SELF)
			printf("prepend-self %u ", set->prepend_self);
		if (set->flags & SET_PREPEND_PEER)
			printf("prepend-neighbor %u ", set->prepend_peer);
		printf("}");
d116 1
d156 1
a156 1
	if (n->attrset.flags)
d244 1
a244 1
	if (p->attrset.flags)
d247 1
a247 1
	if (p->attrset.flags)
@


1.33
log
@New config statement "rde route-age [evaluate|ignore]". If set to evaluate
the best path selection will not only be based on the path attributes but
also on the age of the prefix. This is an extension to the RFC. The default
is ignore but previously it was implicitly set to evaluate.
OK henning@@ man page OK jaredy@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.32 2004/10/19 14:53:14 henning Exp $	*/
d169 1
a169 1
	if (p->capabilities == 0)
@


1.32
log
@fix printing of groups - instead of surrounding each neighbor statement
which is part of a group by "group blah { .. }", so that each group decl
occurs multiple times (that is valid, but confusing and ugly), stuff
pointers to each peer into an a array and sort it based on group id.
then print all neighbors whoch are not part of a group followed
by each group with all its members.
annoyed me for quite some time, now finally enough to sit down and fix it
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.31 2004/10/19 12:02:50 henning Exp $	*/
d119 3
@


1.31
log
@allow neighbor definitions to depend on interface state.
with this, if a neighbor is configured as dependent on carp0 for example,
the neighbor will remain in state IDLE as long as carp0 is not master.
once carp0 becomes master the session(s) depending on it immediately
go to CONNECT (or ACTIVE, if they're configured passive), reducing failover
time. claudio ok, with some input from ryan as well
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.30 2004/09/28 12:09:31 claudio Exp $	*/
d20 1
d31 2
a32 1
void		 print_peer(struct peer_config *, struct bgpd_config *);
d37 3
a39 1
void		 print_mrt(u_int32_t, u_int32_t, const char *);
d139 1
a139 1
print_peer(struct peer_config *p, struct bgpd_config *conf)
a140 3
	const char	*tab	= "\t";
	const char	*nada	= "";
	const char	*c;
a143 6
	if (p->group[0]) {
		printf("group \"%s\" {\n", p->group);
		c = tab;
	} else
		c = nada;

d226 1
a226 1
	print_mrt(p->id, p->groupid, c == nada ? "\t" : "\t\t");
a228 2
	if (p->group[0])
		printf("}\n");
d368 1
a368 1
print_mrt(u_int32_t pid, u_int32_t gid, const char *prep)
d379 1
a379 1
				printf("%sdump %s %s\n", prep,
d382 1
a382 1
				printf("%sdump %s %s %d\n", prep,
d390 58
a450 1
	struct peer		*p;
d457 1
a457 1
	print_mrt(0, 0, "");
d462 1
a462 2
	for (p = peer_l; p != NULL; p = p->next)
		print_peer(&p->conf, conf);
@


1.30
log
@Add prepend-neighbor feature. Prepend the remote-as n times similar to
prepend-self. Only for incomming UPDATEs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.29 2004/08/24 15:50:16 claudio Exp $	*/
d196 2
@


1.29
log
@Add missing config statements -- route-reflector and enforce neighbor-as.
Now printconf is in sync with the man page. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.28 2004/08/24 12:42:55 claudio Exp $	*/
d86 4
a89 2
		if (set->flags & SET_PREPEND)
			printf("prepend-self %u ", set->prepend);
@


1.28
log
@Forgot to update printconf.c once again. foobar-AS is now foobar-as.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.27 2004/08/13 14:03:20 claudio Exp $	*/
d30 1
a30 1
void		 print_peer(struct peer_config *);
d133 1
a133 1
print_peer(struct peer_config *p)
d139 1
d181 13
d409 1
a409 1
		print_peer(&p->conf);
@


1.27
log
@Fix minor issues with IPv6 dumps and add a function for dumping the RIB table
protocol independent. This new dump format is not (yet) supported by the
mrtd route_btoa tool. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.26 2004/08/10 13:02:08 claudio Exp $	*/
d308 1
a308 1
			printf("source-AS %u ", r->match.as.as);
d310 1
a310 1
			printf("transit-AS %u ", r->match.as.as);
d312 1
a312 1
			printf("unfluffy-AS %u ", r->match.as.as);
@


1.26
log
@switch nexthop in struct filter_set form struct in_addr to struct bgpd_addr
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.25 2004/08/02 12:30:15 claudio Exp $	*/
d337 1
a337 1
		return "unfluffy MRT";
d340 2
@


1.25
log
@Forgot to add "anounce default-route" here. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.24 2004/07/05 16:54:53 henning Exp $	*/
d81 1
a81 1
			printf("nexthop %s ", inet_ntoa(set->nexthop));
@


1.24
log
@implement "set nexthop blackhole" and "set nexthop reject"
blackhole/reject routes will be entered to the kernel for matching ones.
this is intended to be used with the Cymru Bogon Route Server Project
(http://www.cymru.com/BGP/bogon-rs.html) and similar services, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.23 2004/07/03 17:19:59 claudio Exp $	*/
d176 2
@


1.23
log
@Switch mrt dumping to fd passing. This gives some speed up when extensive
dumping is done. Acctually mrt dumps were broken because of the fd passing.
The nice side effect is a much cleaner code, especially in the parent process.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.22 2004/06/20 18:35:12 henning Exp $	*/
d82 4
@


1.22
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.21 2004/06/06 17:38:10 henning Exp $	*/
d356 4
a359 4
	LIST_FOREACH(m, xmrt_l, list)
		if ((gid != 0 && m->conf.group_id == gid) ||
		    (m->conf.peer_id == pid && m->conf.group_id == gid)) {
			if (m->ReopenTimerInterval == 0)
d361 1
a361 1
				    mrt_type(m->conf.type), m->name);
d364 3
a366 2
				    mrt_type(m->conf.type),
				    m->name, m->ReopenTimerInterval);
@


1.21
log
@rework bgpd's handling of listening sockets. instead of one for each
supported address familiy, keep a tailq of an arbitary number of them.
the new struct listen_addr contains the sockaddr and the fd.
this fixes quite some nasty behaviour which was a consequence of the previous
model.
looks right deraadt@@, and discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.20 2004/05/08 19:17:20 henning Exp $	*/
d382 1
a382 1
	TAILQ_FOREACH(n, net_l, network_l)
d388 1
a388 1
	TAILQ_FOREACH(r, rules_l, entries)
@


1.20
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.19 2004/05/08 18:23:24 henning Exp $	*/
d91 2
a92 2
	struct in_addr	ina;
	struct in6_addr	ina6;
d113 1
a113 5
	if (conf->listen_addr.sin_addr.s_addr != INADDR_ANY)
		printf("listen on %s\n", inet_ntoa(conf->listen_addr.sin_addr));

	bzero(&ina6, sizeof(ina6));
	if (bcmp(&ina6, &conf->listen6_addr.sin6_addr, sizeof(ina6)))
d115 1
a115 1
		    log_sockaddr((struct sockaddr *)&conf->listen6_addr));
@


1.19
log
@do not omit the IPv6 listening address
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.18 2004/05/08 17:40:53 henning Exp $	*/
d118 2
a119 1
		printf("listen on %s\n", log_sockaddr((struct sockaddr *)&conf->listen6_addr));
d181 2
a182 1
	else if (p->auth.method == AUTH_IPSEC_MANUAL_ESP || p->auth.method == AUTH_IPSEC_MANUAL_AH) {
d188 2
a189 2
		printf("%s\tipsec %s in spi %u %s XXXXXX", c, method, p->auth.spi_in,
		    print_auth_alg(p->auth.auth_alg_in));
d194 2
a195 2
		printf("%s\tipsec %s out spi %u %s XXXXXX", c, method, p->auth.spi_out,
		    print_auth_alg(p->auth.auth_alg_out));
@


1.18
log
@add support for ipsec ah with manual keys, pfkey part already does so, and
flesh parser out a bit. also add support for printing ipsec ah with manual
keys in printconf
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.17 2004/04/28 04:34:46 henning Exp $	*/
d20 1
d92 1
d114 5
a118 1
		printf("listen-on %s\n", inet_ntoa(conf->listen_addr.sin_addr));
@


1.17
log
@allow ah/esp spec with IKE, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.16 2004/04/28 00:38:39 henning Exp $	*/
d131 1
d174 7
a180 2
	else if (p->auth.method == AUTH_IPSEC_MANUAL_ESP) {
		printf("%s\tipsec esp in spi %u %s XXXXXX", c, p->auth.spi_in,
d186 1
a186 1
		printf("%s\tipsec esp out spi %u %s XXXXXX", c, p->auth.spi_out,
@


1.16
log
@prefix the auth related defines by AUTH_, we had a name clash, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.15 2004/04/27 23:20:42 henning Exp $	*/
d186 4
a189 2
	} else if (p->auth.method == AUTH_IPSEC_IKE)
		printf("%s\tipsec ike\n", c);
@


1.15
log
@teach printconf about all this shiny new ipsec stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.14 2004/04/27 22:42:13 henning Exp $	*/
d171 1
a171 1
	if (p->auth.method == MD5SIG)
d173 1
a173 1
	else if (p->auth.method == IPSEC_MANUAL_ESP) {
d186 1
a186 1
	} else if (p->auth.method == IPSEC_IKE)
@


1.14
log
@rename the ipsec struct to auth, move all tcpmd5 related fields in there, and
add a generic "method" field that expresses what method
(none/md5sig/ipsec manual/ipsec ike) is in use
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.13 2004/04/26 04:40:11 henning Exp $	*/
d30 2
d170 1
d173 15
d200 26
@


1.13
log
@fix printing template neighbors
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.12 2004/03/17 12:40:38 claudio Exp $	*/
d168 1
a168 1
	if (p->tcp_md5_key[0])
@


1.12
log
@Add missing space for sets in network statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.11 2004/03/12 20:57:22 henning Exp $	*/
d136 6
a141 1
	printf("%sneighbor %s {\n", c, log_addr(&p->remote_addr));
d144 2
a145 1
	printf("%s\tremote-as %u\n", c, p->remote_as);
@


1.11
log
@print that capabilities stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.10 2004/03/11 17:34:01 henning Exp $	*/
d117 2
@


1.10
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.9 2004/03/11 17:12:51 claudio Exp $	*/
d150 2
@


1.9
log
@Add basic support for communities. Currently it is only possible to filter
on communities, e.g match from any community 24640:* set localpref 666
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.8 2004/03/01 23:00:03 henning Exp $	*/
d253 1
a253 1
	} 
@


1.8
log
@don't print empty descr
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.7 2004/03/01 17:04:07 henning Exp $	*/
d242 12
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.6 2004/03/01 16:47:06 claudio Exp $	*/
d135 2
a136 1
	printf("%s\tdescr \"%s\"\n", c, p->descr);
@


1.6
log
@Sync printconfig.c with parse.y. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.5 2004/02/24 15:43:03 claudio Exp $	*/
d167 1
a167 1
	
@


1.5
log
@Enhance filters. prefixlen knows now 8-24 and 8><24. It is possible to use
prefix 10.0.0.0/8 prefixlen >= 8 and set localpref 100 can be set on a per
neighbor basis. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.4 2004/02/09 23:16:46 henning Exp $	*/
d22 1
d26 1
d31 2
d69 17
d103 3
d116 3
a118 1
	printf("network %s/%u\n", log_addr(&n->prefix), n->prefixlen);
d159 9
a167 14
	if (p->attrset.flags) {
		printf("%s\tset {\n", c);
		if (p->attrset.flags & SET_LOCALPREF)
			printf("%s\t\tlocalpref %u\n", c, p->attrset.localpref);
		if (p->attrset.flags & SET_MED)
			printf("%s\t\tmed %u\n", c, p->attrset.med);
		if (p->attrset.flags & SET_NEXTHOP)
			printf("%s\t\tnexthop %s\n",
			    c, inet_ntoa(p->attrset.nexthop));
		if (p->attrset.flags & SET_PREPEND)
			printf("%s\t\tprepend-self %u\n",
			    c, p->attrset.prepend);
		printf("%s\t}\n", c);
	}
d242 1
a242 10
	if (r->set.flags) {
		printf("set { ");
		if (r->set.flags & SET_LOCALPREF)
			printf("localpref %u ", r->set.localpref);
		if (r->set.flags & SET_MED)
			printf("med %u ", r->set.med);
		if (r->set.flags & SET_NEXTHOP)
			printf("nexthop %s ", inet_ntoa(r->set.nexthop));
		if (r->set.flags & SET_PREPEND)
			printf("prepend-self %u ", r->set.prepend);
d244 2
d247 16
a262 1
		printf("}");
d264 4
d269 19
a287 1
	printf("\n");
d292 1
a292 1
    struct peer *peer_l, struct filter_head *rules_l)
d298 1
d300 2
@


1.4
log
@print networks too
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.3 2004/02/09 01:46:34 henning Exp $	*/
d34 6
d133 14
d198 6
a203 4
		if (r->match.prefixlen.op == OP_RANGE)
			printf("prefixlen %u - %u ", r->match.prefixlen.len_min,
			    r->match.prefixlen.len_max);
		else {
@


1.3
log
@make max_prefix an u_int32_t instead of an u_long and change its
meaning as in 0 means no limit insytead of setting it to ULONG_MAX for
no limit
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.2 2004/02/09 01:38:55 henning Exp $	*/
d26 1
d84 6
d218 2
a219 2
print_config(struct bgpd_config *conf, struct peer *peer_l,
    struct filter_head *rules_l)
d223 1
d226 3
@


1.2
log
@print more fluff
@
text
@d1 1
a1 1
/*	$OpenBSD: printconf.c,v 1.1 2004/02/08 23:44:57 henning Exp $	*/
d104 2
a105 2
	if (p->max_prefix != ULONG_MAX)
		printf("%s\tmax-prefix %lu\n", c, p->max_prefix);
@


1.1
log
@factor out functions to print the configuration (rules only for now)
will become more and needed by bgpctl too
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d25 3
d58 68
d208 16
@

