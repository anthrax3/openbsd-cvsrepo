head	1.364;
access;
symbols
	OPENBSD_6_2:1.364.0.2
	OPENBSD_6_2_BASE:1.364
	OPENBSD_6_1:1.359.0.4
	OPENBSD_6_1_BASE:1.359
	OPENBSD_6_0:1.351.0.4
	OPENBSD_6_0_BASE:1.351
	OPENBSD_5_9:1.347.0.2
	OPENBSD_5_9_BASE:1.347
	OPENBSD_5_8:1.340.0.4
	OPENBSD_5_8_BASE:1.340
	OPENBSD_5_7:1.338.0.2
	OPENBSD_5_7_BASE:1.338
	OPENBSD_5_6:1.334.0.6
	OPENBSD_5_6_BASE:1.334
	OPENBSD_5_5:1.334.0.4
	OPENBSD_5_5_BASE:1.334
	OPENBSD_5_4:1.332.0.2
	OPENBSD_5_4_BASE:1.332
	OPENBSD_5_3:1.326.0.2
	OPENBSD_5_3_BASE:1.326
	OPENBSD_5_2:1.323.0.2
	OPENBSD_5_2_BASE:1.323
	OPENBSD_5_1_BASE:1.320
	OPENBSD_5_1:1.320.0.2
	OPENBSD_5_0:1.319.0.2
	OPENBSD_5_0_BASE:1.319
	OPENBSD_4_9:1.316.0.2
	OPENBSD_4_9_BASE:1.316
	OPENBSD_4_8:1.310.0.2
	OPENBSD_4_8_BASE:1.310
	OPENBSD_4_7:1.305.0.2
	OPENBSD_4_7_BASE:1.305
	OPENBSD_4_6:1.293.0.4
	OPENBSD_4_6_BASE:1.293
	OPENBSD_4_5:1.284.0.2
	OPENBSD_4_5_BASE:1.284
	OPENBSD_4_4:1.282.0.2
	OPENBSD_4_4_BASE:1.282
	OPENBSD_4_3:1.279.0.2
	OPENBSD_4_3_BASE:1.279
	OPENBSD_4_2:1.276.0.2
	OPENBSD_4_2_BASE:1.276
	OPENBSD_4_1:1.270.0.2
	OPENBSD_4_1_BASE:1.270
	OPENBSD_4_0:1.262.0.2
	OPENBSD_4_0_BASE:1.262
	OPENBSD_3_9:1.244.0.2
	OPENBSD_3_9_BASE:1.244
	OPENBSD_3_8:1.232.0.2
	OPENBSD_3_8_BASE:1.232
	OPENBSD_3_7:1.213.0.2
	OPENBSD_3_7_BASE:1.213
	OPENBSD_3_6:1.189.0.2
	OPENBSD_3_6_BASE:1.189
	OPENBSD_3_5:1.139.0.2
	OPENBSD_3_5_BASE:1.139;
locks; strict;
comment	@ * @;


1.364
date	2017.05.29.14.22.51;	author benno;	state Exp;
branches;
next	1.363;
commitid	Nh8TfpUdxcIAlRWD;

1.363
date	2017.05.28.20.10.59;	author claudio;	state Exp;
branches;
next	1.362;
commitid	dYFaZPECpMm7qqN4;

1.362
date	2017.05.28.12.21.36;	author claudio;	state Exp;
branches;
next	1.361;
commitid	FWHn2FssuHSixuVj;

1.361
date	2017.05.27.10.33.15;	author phessler;	state Exp;
branches;
next	1.360;
commitid	SM4OMu9209fRs2iQ;

1.360
date	2017.05.26.20.55.30;	author phessler;	state Exp;
branches;
next	1.359;
commitid	p82SYNnm0pVdbRCn;

1.359
date	2017.02.13.14.48.44;	author phessler;	state Exp;
branches;
next	1.358;
commitid	UAS1mKyHLGdFBKFJ;

1.358
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.357;
commitid	airB1W2Kb948lFil;

1.357
date	2017.01.13.18.59.12;	author phessler;	state Exp;
branches;
next	1.356;
commitid	3Jvf15B19ysa8i2W;

1.356
date	2016.12.19.07.19.55;	author claudio;	state Exp;
branches;
next	1.355;
commitid	wmGXLwsfGKtf5QaN;

1.355
date	2016.12.18.17.15.07;	author claudio;	state Exp;
branches;
next	1.354;
commitid	mbqZQYg563Av4mi5;

1.354
date	2016.09.03.16.22.17;	author renato;	state Exp;
branches;
next	1.353;
commitid	FeUy6OVH7V8nX42o;

1.353
date	2016.09.02.14.00.29;	author benno;	state Exp;
branches;
next	1.352;
commitid	cUiKeXOsNjNjPeSK;

1.352
date	2016.08.08.21.44.00;	author renato;	state Exp;
branches;
next	1.351;
commitid	Nu19hjaf9yj2aAQY;

1.351
date	2016.07.25.14.29.28;	author claudio;	state Exp;
branches;
next	1.350;
commitid	wRLwfBnRKZRu8NRl;

1.350
date	2016.07.21.10.13.58;	author claudio;	state Exp;
branches;
next	1.349;
commitid	JBhXdMVuhYdAttq1;

1.349
date	2016.06.28.16.59.14;	author jca;	state Exp;
branches;
next	1.348;
commitid	PdUNFhKkQf3LiGM0;

1.348
date	2016.06.06.15.59.10;	author benno;	state Exp;
branches;
next	1.347;
commitid	vloEJNNQZltwPJV4;

1.347
date	2015.11.20.23.26.08;	author florian;	state Exp;
branches;
next	1.346;
commitid	jqFrsUc2DRemaNMU;

1.346
date	2015.11.17.09.15.21;	author benno;	state Exp;
branches;
next	1.345;
commitid	6XhydQORopnraDrR;

1.345
date	2015.10.25.18.49.01;	author claudio;	state Exp;
branches;
next	1.344;
commitid	CFOjjrz5XQ5AoRFX;

1.344
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.343;
commitid	sbrB3Q5CNxcwZpfU;

1.343
date	2015.10.07.20.25.22;	author deraadt;	state Exp;
branches;
next	1.342;
commitid	vbXeHK9XlOfkZbR1;

1.342
date	2015.10.06.15.39.44;	author deraadt;	state Exp;
branches;
next	1.341;
commitid	Ytytyuwcp2O4NL3A;

1.341
date	2015.10.05.16.16.41;	author deraadt;	state Exp;
branches;
next	1.340;
commitid	mYaQC74Ehz12VEV8;

1.340
date	2015.08.04.14.46.38;	author phessler;	state Exp;
branches;
next	1.339;
commitid	wJyyJZr2xy2xDvm7;

1.339
date	2015.07.20.16.10.38;	author claudio;	state Exp;
branches;
next	1.338;
commitid	JXdI3dG8XAYCUdaO;

1.338
date	2015.02.09.11.37.31;	author claudio;	state Exp;
branches;
next	1.337;
commitid	IcuyF0sCmFRE7OTK;

1.337
date	2014.12.04.19.55.49;	author sthen;	state Exp;
branches;
next	1.336;
commitid	5NtIdIvCCAPsSbzw;

1.336
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.335;
commitid	2uw1UTO4k6erpWzK;

1.335
date	2014.10.08.16.15.37;	author deraadt;	state Exp;
branches;
next	1.334;
commitid	8hXaK4f2GeAALziF;

1.334
date	2014.01.22.04.08.08;	author claudio;	state Exp;
branches;
next	1.333;

1.333
date	2013.11.13.20.41.01;	author benno;	state Exp;
branches;
next	1.332;

1.332
date	2013.07.10.15.56.06;	author claudio;	state Exp;
branches;
next	1.331;

1.331
date	2013.05.30.20.29.27;	author florian;	state Exp;
branches;
next	1.330;

1.330
date	2013.05.30.10.13.58;	author sthen;	state Exp;
branches;
next	1.329;

1.329
date	2013.03.20.04.01.42;	author deraadt;	state Exp;
branches;
next	1.328;

1.328
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.327;

1.327
date	2013.03.07.21.26.28;	author claudio;	state Exp;
branches;
next	1.326;

1.326
date	2012.12.01.10.35.17;	author claudio;	state Exp;
branches
	1.326.2.1;
next	1.325;

1.325
date	2012.09.18.09.45.50;	author claudio;	state Exp;
branches;
next	1.324;

1.324
date	2012.09.12.05.56.22;	author claudio;	state Exp;
branches;
next	1.323;

1.323
date	2012.07.11.09.43.10;	author sthen;	state Exp;
branches
	1.323.2.1;
next	1.322;

1.322
date	2012.07.09.11.11.07;	author claudio;	state Exp;
branches;
next	1.321;

1.321
date	2012.04.12.17.26.09;	author claudio;	state Exp;
branches;
next	1.320;

1.320
date	2012.01.06.17.33.11;	author sthen;	state Exp;
branches;
next	1.319;

1.319
date	2011.07.09.02.51.18;	author henning;	state Exp;
branches;
next	1.318;

1.318
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.317;

1.317
date	2011.05.05.06.21.44;	author henning;	state Exp;
branches;
next	1.316;

1.316
date	2010.12.23.17.41.40;	author claudio;	state Exp;
branches;
next	1.315;

1.315
date	2010.12.09.13.50.41;	author claudio;	state Exp;
branches;
next	1.314;

1.314
date	2010.11.18.12.51.24;	author claudio;	state Exp;
branches;
next	1.313;

1.313
date	2010.11.10.15.14.36;	author claudio;	state Exp;
branches;
next	1.312;

1.312
date	2010.10.15.07.45.32;	author claudio;	state Exp;
branches;
next	1.311;

1.311
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.310;

1.310
date	2010.06.27.19.53.34;	author claudio;	state Exp;
branches
	1.310.2.1;
next	1.309;

1.309
date	2010.05.26.13.56.07;	author nicm;	state Exp;
branches;
next	1.308;

1.308
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.307;

1.307
date	2010.04.16.12.24.25;	author claudio;	state Exp;
branches;
next	1.306;

1.306
date	2010.04.13.09.09.48;	author claudio;	state Exp;
branches;
next	1.305;

1.305
date	2010.02.11.22.05.59;	author claudio;	state Exp;
branches;
next	1.304;

1.304
date	2010.01.05.08.49.57;	author claudio;	state Exp;
branches;
next	1.303;

1.303
date	2009.12.31.15.34.02;	author claudio;	state Exp;
branches;
next	1.302;

1.302
date	2009.12.08.14.03.40;	author claudio;	state Exp;
branches;
next	1.301;

1.301
date	2009.12.03.19.27.20;	author claudio;	state Exp;
branches;
next	1.300;

1.300
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.299;

1.299
date	2009.10.26.09.27.58;	author claudio;	state Exp;
branches;
next	1.298;

1.298
date	2009.09.22.14.07.53;	author claudio;	state Exp;
branches;
next	1.297;

1.297
date	2009.09.03.09.06.20;	author claudio;	state Exp;
branches;
next	1.296;

1.296
date	2009.09.02.08.06.42;	author claudio;	state Exp;
branches;
next	1.295;

1.295
date	2009.08.21.15.43.27;	author claudio;	state Exp;
branches;
next	1.294;

1.294
date	2009.07.24.13.09.29;	author claudio;	state Exp;
branches;
next	1.293;

1.293
date	2009.06.07.05.56.24;	author eric;	state Exp;
branches;
next	1.292;

1.292
date	2009.06.06.06.33.15;	author eric;	state Exp;
branches;
next	1.291;

1.291
date	2009.06.04.04.46.42;	author claudio;	state Exp;
branches;
next	1.290;

1.290
date	2009.05.27.04.18.21;	author reyk;	state Exp;
branches;
next	1.289;

1.289
date	2009.03.19.07.00.07;	author claudio;	state Exp;
branches;
next	1.288;

1.288
date	2009.03.18.19.49.31;	author claudio;	state Exp;
branches;
next	1.287;

1.287
date	2009.03.18.19.39.27;	author claudio;	state Exp;
branches;
next	1.286;

1.286
date	2009.03.13.05.43.51;	author claudio;	state Exp;
branches;
next	1.285;

1.285
date	2009.03.13.04.40.55;	author claudio;	state Exp;
branches;
next	1.284;

1.284
date	2008.09.11.14.49.58;	author henning;	state Exp;
branches;
next	1.283;

1.283
date	2008.09.05.10.38.12;	author henning;	state Exp;
branches;
next	1.282;

1.282
date	2008.06.26.00.01.51;	author claudio;	state Exp;
branches;
next	1.281;

1.281
date	2008.05.08.07.43.02;	author henning;	state Exp;
branches;
next	1.280;

1.280
date	2008.05.08.06.52.13;	author henning;	state Exp;
branches;
next	1.279;

1.279
date	2007.12.23.18.56.17;	author henning;	state Exp;
branches;
next	1.278;

1.278
date	2007.12.23.16.42.45;	author henning;	state Exp;
branches;
next	1.277;

1.277
date	2007.12.20.17.08.48;	author henning;	state Exp;
branches;
next	1.276;

1.276
date	2007.06.19.09.44.55;	author pyr;	state Exp;
branches;
next	1.275;

1.275
date	2007.05.29.02.27.05;	author claudio;	state Exp;
branches;
next	1.274;

1.274
date	2007.05.15.14.47.36;	author claudio;	state Exp;
branches;
next	1.273;

1.273
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.272;

1.272
date	2007.03.28.11.53.48;	author claudio;	state Exp;
branches;
next	1.271;

1.271
date	2007.03.16.14.06.57;	author claudio;	state Exp;
branches;
next	1.270;

1.270
date	2007.02.22.08.34.18;	author henning;	state Exp;
branches;
next	1.269;

1.269
date	2007.02.22.08.26.45;	author henning;	state Exp;
branches;
next	1.268;

1.268
date	2007.01.26.17.40.49;	author claudio;	state Exp;
branches;
next	1.267;

1.267
date	2007.01.23.17.41.22;	author claudio;	state Exp;
branches;
next	1.266;

1.266
date	2006.12.05.12.08.13;	author henning;	state Exp;
branches;
next	1.265;

1.265
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.264;

1.264
date	2006.11.06.14.07.35;	author henning;	state Exp;
branches;
next	1.263;

1.263
date	2006.09.19.13.04.01;	author henning;	state Exp;
branches;
next	1.262;

1.262
date	2006.08.27.16.57.19;	author henning;	state Exp;
branches;
next	1.261;

1.261
date	2006.08.27.16.19.18;	author henning;	state Exp;
branches;
next	1.260;

1.260
date	2006.08.27.16.11.05;	author henning;	state Exp;
branches;
next	1.259;

1.259
date	2006.08.27.14.00.15;	author henning;	state Exp;
branches;
next	1.258;

1.258
date	2006.08.27.13.44.03;	author henning;	state Exp;
branches;
next	1.257;

1.257
date	2006.08.04.12.01.48;	author henning;	state Exp;
branches;
next	1.256;

1.256
date	2006.07.30.16.27.28;	author henning;	state Exp;
branches;
next	1.255;

1.255
date	2006.07.28.15.04.34;	author henning;	state Exp;
branches;
next	1.254;

1.254
date	2006.06.18.13.54.34;	author henning;	state Exp;
branches;
next	1.253;

1.253
date	2006.06.18.13.54.01;	author henning;	state Exp;
branches;
next	1.252;

1.252
date	2006.06.17.14.06.09;	author henning;	state Exp;
branches;
next	1.251;

1.251
date	2006.06.12.12.45.14;	author henning;	state Exp;
branches;
next	1.250;

1.250
date	2006.06.10.16.32.38;	author henning;	state Exp;
branches;
next	1.249;

1.249
date	2006.05.27.21.24.36;	author claudio;	state Exp;
branches;
next	1.248;

1.248
date	2006.05.27.15.43.13;	author claudio;	state Exp;
branches;
next	1.247;

1.247
date	2006.05.23.12.11.38;	author henning;	state Exp;
branches;
next	1.246;

1.246
date	2006.03.22.10.18.49;	author claudio;	state Exp;
branches;
next	1.245;

1.245
date	2006.03.15.11.33.42;	author claudio;	state Exp;
branches;
next	1.244;

1.244
date	2006.02.08.12.36.29;	author henning;	state Exp;
branches;
next	1.243;

1.243
date	2006.01.24.10.08.16;	author henning;	state Exp;
branches;
next	1.242;

1.242
date	2006.01.24.10.03.44;	author henning;	state Exp;
branches;
next	1.241;

1.241
date	2006.01.03.22.49.17;	author claudio;	state Exp;
branches;
next	1.240;

1.240
date	2006.01.03.16.49.24;	author claudio;	state Exp;
branches;
next	1.239;

1.239
date	2005.12.08.15.55.26;	author claudio;	state Exp;
branches;
next	1.238;

1.238
date	2005.11.01.10.58.29;	author claudio;	state Exp;
branches;
next	1.237;

1.237
date	2005.10.19.10.42.06;	author henning;	state Exp;
branches;
next	1.236;

1.236
date	2005.10.19.09.36.51;	author henning;	state Exp;
branches;
next	1.235;

1.235
date	2005.09.20.13.31.53;	author henning;	state Exp;
branches;
next	1.234;

1.234
date	2005.09.19.16.15.54;	author henning;	state Exp;
branches;
next	1.233;

1.233
date	2005.09.08.10.46.40;	author henning;	state Exp;
branches;
next	1.232;

1.232
date	2005.07.24.11.56.37;	author henning;	state Exp;
branches;
next	1.231;

1.231
date	2005.07.18.11.51.54;	author dlg;	state Exp;
branches;
next	1.230;

1.230
date	2005.07.18.11.41.15;	author claudio;	state Exp;
branches;
next	1.229;

1.229
date	2005.07.01.13.38.14;	author claudio;	state Exp;
branches;
next	1.228;

1.228
date	2005.06.16.18.43.07;	author henning;	state Exp;
branches;
next	1.227;

1.227
date	2005.06.09.12.31.38;	author claudio;	state Exp;
branches;
next	1.226;

1.226
date	2005.06.04.23.31.21;	author henning;	state Exp;
branches;
next	1.225;

1.225
date	2005.06.04.23.14.32;	author henning;	state Exp;
branches;
next	1.224;

1.224
date	2005.06.04.22.58.03;	author henning;	state Exp;
branches;
next	1.223;

1.223
date	2005.06.04.22.54.22;	author henning;	state Exp;
branches;
next	1.222;

1.222
date	2005.06.04.22.50.20;	author henning;	state Exp;
branches;
next	1.221;

1.221
date	2005.06.04.07.07.34;	author henning;	state Exp;
branches;
next	1.220;

1.220
date	2005.06.02.15.07.02;	author cloder;	state Exp;
branches;
next	1.219;

1.219
date	2005.05.24.17.30.37;	author claudio;	state Exp;
branches;
next	1.218;

1.218
date	2005.05.23.22.45.02;	author henning;	state Exp;
branches;
next	1.217;

1.217
date	2005.05.03.07.01.23;	author djm;	state Exp;
branches;
next	1.216;

1.216
date	2005.03.30.11.23.15;	author henning;	state Exp;
branches;
next	1.215;

1.215
date	2005.03.28.15.16.46;	author henning;	state Exp;
branches;
next	1.214;

1.214
date	2005.03.28.15.03.33;	author henning;	state Exp;
branches;
next	1.213;

1.213
date	2005.03.11.17.46.11;	author henning;	state Exp;
branches;
next	1.212;

1.212
date	2004.12.23.17.34.04;	author henning;	state Exp;
branches;
next	1.211;

1.211
date	2004.12.23.17.24.03;	author henning;	state Exp;
branches;
next	1.210;

1.210
date	2004.12.23.15.15.55;	author henning;	state Exp;
branches;
next	1.209;

1.209
date	2004.12.07.17.19.09;	author henning;	state Exp;
branches;
next	1.208;

1.208
date	2004.11.23.13.07.01;	author claudio;	state Exp;
branches;
next	1.207;

1.207
date	2004.11.18.17.17.56;	author henning;	state Exp;
branches;
next	1.206;

1.206
date	2004.11.18.17.07.38;	author henning;	state Exp;
branches;
next	1.205;

1.205
date	2004.11.18.16.38.05;	author henning;	state Exp;
branches;
next	1.204;

1.204
date	2004.11.18.16.30.05;	author henning;	state Exp;
branches;
next	1.203;

1.203
date	2004.11.18.15.42.59;	author henning;	state Exp;
branches;
next	1.202;

1.202
date	2004.11.18.15.24.24;	author henning;	state Exp;
branches;
next	1.201;

1.201
date	2004.11.18.14.59.50;	author henning;	state Exp;
branches;
next	1.200;

1.200
date	2004.11.18.14.10.36;	author henning;	state Exp;
branches;
next	1.199;

1.199
date	2004.11.11.16.56.08;	author claudio;	state Exp;
branches;
next	1.198;

1.198
date	2004.11.10.14.48.25;	author claudio;	state Exp;
branches;
next	1.197;

1.197
date	2004.11.02.10.56.48;	author henning;	state Exp;
branches;
next	1.196;

1.196
date	2004.10.19.12.02.50;	author henning;	state Exp;
branches;
next	1.195;

1.195
date	2004.10.07.13.39.14;	author henning;	state Exp;
branches;
next	1.194;

1.194
date	2004.10.05.11.47.41;	author henning;	state Exp;
branches;
next	1.193;

1.193
date	2004.09.22.08.46.28;	author henning;	state Exp;
branches;
next	1.192;

1.192
date	2004.09.16.17.44.36;	author henning;	state Exp;
branches;
next	1.191;

1.191
date	2004.09.16.17.36.29;	author henning;	state Exp;
branches;
next	1.190;

1.190
date	2004.09.16.00.25.12;	author henning;	state Exp;
branches;
next	1.189;

1.189
date	2004.09.09.21.53.57;	author henning;	state Exp;
branches;
next	1.188;

1.188
date	2004.08.11.16.48.45;	author claudio;	state Exp;
branches;
next	1.187;

1.187
date	2004.08.11.10.09.30;	author claudio;	state Exp;
branches;
next	1.186;

1.186
date	2004.08.10.14.06.53;	author claudio;	state Exp;
branches;
next	1.185;

1.185
date	2004.08.06.11.51.19;	author claudio;	state Exp;
branches;
next	1.184;

1.184
date	2004.08.04.12.41.48;	author henning;	state Exp;
branches;
next	1.183;

1.183
date	2004.07.13.17.57.20;	author jaredy;	state Exp;
branches;
next	1.182;

1.182
date	2004.07.04.03.51.31;	author henning;	state Exp;
branches;
next	1.181;

1.181
date	2004.07.03.17.19.59;	author claudio;	state Exp;
branches;
next	1.180;

1.180
date	2004.06.22.07.58.19;	author alexander;	state Exp;
branches;
next	1.179;

1.179
date	2004.06.22.07.42.41;	author henning;	state Exp;
branches;
next	1.178;

1.178
date	2004.06.22.03.44.26;	author claudio;	state Exp;
branches;
next	1.177;

1.177
date	2004.06.22.03.17.01;	author henning;	state Exp;
branches;
next	1.176;

1.176
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.175;

1.175
date	2004.06.20.17.49.46;	author henning;	state Exp;
branches;
next	1.174;

1.174
date	2004.06.09.13.01.44;	author henning;	state Exp;
branches;
next	1.173;

1.173
date	2004.06.06.17.38.10;	author henning;	state Exp;
branches;
next	1.172;

1.172
date	2004.05.28.18.39.09;	author henning;	state Exp;
branches;
next	1.171;

1.171
date	2004.05.28.16.33.40;	author henning;	state Exp;
branches;
next	1.170;

1.170
date	2004.05.21.11.48.56;	author claudio;	state Exp;
branches;
next	1.169;

1.169
date	2004.05.08.11.22.43;	author henning;	state Exp;
branches;
next	1.168;

1.168
date	2004.05.06.14.41.05;	author henning;	state Exp;
branches;
next	1.167;

1.167
date	2004.05.06.14.07.43;	author henning;	state Exp;
branches;
next	1.166;

1.166
date	2004.05.06.12.18.02;	author henning;	state Exp;
branches;
next	1.165;

1.165
date	2004.05.06.12.09.25;	author henning;	state Exp;
branches;
next	1.164;

1.164
date	2004.05.06.11.57.55;	author henning;	state Exp;
branches;
next	1.163;

1.163
date	2004.05.06.09.11.18;	author henning;	state Exp;
branches;
next	1.162;

1.162
date	2004.04.29.19.56.04;	author deraadt;	state Exp;
branches;
next	1.161;

1.161
date	2004.04.28.17.42.27;	author deraadt;	state Exp;
branches;
next	1.160;

1.160
date	2004.04.28.06.45.37;	author henning;	state Exp;
branches;
next	1.159;

1.159
date	2004.04.28.00.38.39;	author henning;	state Exp;
branches;
next	1.158;

1.158
date	2004.04.27.22.42.13;	author henning;	state Exp;
branches;
next	1.157;

1.157
date	2004.04.27.17.41.34;	author henning;	state Exp;
branches;
next	1.156;

1.156
date	2004.04.27.17.25.52;	author henning;	state Exp;
branches;
next	1.155;

1.155
date	2004.04.27.04.38.12;	author deraadt;	state Exp;
branches;
next	1.154;

1.154
date	2004.04.27.04.06.58;	author henning;	state Exp;
branches;
next	1.153;

1.153
date	2004.04.27.03.53.43;	author henning;	state Exp;
branches;
next	1.152;

1.152
date	2004.04.26.09.35.39;	author markus;	state Exp;
branches;
next	1.151;

1.151
date	2004.04.26.01.43.13;	author henning;	state Exp;
branches;
next	1.150;

1.150
date	2004.04.25.23.36.15;	author henning;	state Exp;
branches;
next	1.149;

1.149
date	2004.04.25.22.31.03;	author henning;	state Exp;
branches;
next	1.148;

1.148
date	2004.04.25.19.12.57;	author henning;	state Exp;
branches;
next	1.147;

1.147
date	2004.04.25.18.21.18;	author henning;	state Exp;
branches;
next	1.146;

1.146
date	2004.04.25.08.06.00;	author henning;	state Exp;
branches;
next	1.145;

1.145
date	2004.04.25.07.16.24;	author henning;	state Exp;
branches;
next	1.144;

1.144
date	2004.04.24.20.15.49;	author henning;	state Exp;
branches;
next	1.143;

1.143
date	2004.04.24.19.36.19;	author henning;	state Exp;
branches;
next	1.142;

1.142
date	2004.04.16.04.52.26;	author henning;	state Exp;
branches;
next	1.141;

1.141
date	2004.04.16.04.47.19;	author henning;	state Exp;
branches;
next	1.140;

1.140
date	2004.04.13.22.53.29;	author henning;	state Exp;
branches;
next	1.139;

1.139
date	2004.03.20.23.17.35;	author david;	state Exp;
branches;
next	1.138;

1.138
date	2004.03.18.15.09.31;	author henning;	state Exp;
branches;
next	1.137;

1.137
date	2004.03.16.12.06.42;	author henning;	state Exp;
branches;
next	1.136;

1.136
date	2004.03.15.11.48.04;	author henning;	state Exp;
branches;
next	1.135;

1.135
date	2004.03.12.19.33.30;	author henning;	state Exp;
branches;
next	1.134;

1.134
date	2004.03.11.13.35.05;	author claudio;	state Exp;
branches;
next	1.133;

1.133
date	2004.03.10.15.15.48;	author henning;	state Exp;
branches;
next	1.132;

1.132
date	2004.03.10.14.54.11;	author henning;	state Exp;
branches;
next	1.131;

1.131
date	2004.03.10.14.45.25;	author henning;	state Exp;
branches;
next	1.130;

1.130
date	2004.03.10.14.29.37;	author henning;	state Exp;
branches;
next	1.129;

1.129
date	2004.03.10.13.45.16;	author henning;	state Exp;
branches;
next	1.128;

1.128
date	2004.03.10.11.38.33;	author henning;	state Exp;
branches;
next	1.127;

1.127
date	2004.03.05.21.48.28;	author henning;	state Exp;
branches;
next	1.126;

1.126
date	2004.03.05.20.25.30;	author henning;	state Exp;
branches;
next	1.125;

1.125
date	2004.03.05.14.09.55;	author henning;	state Exp;
branches;
next	1.124;

1.124
date	2004.03.05.13.30.01;	author henning;	state Exp;
branches;
next	1.123;

1.123
date	2004.03.05.13.19.00;	author henning;	state Exp;
branches;
next	1.122;

1.122
date	2004.03.05.13.17.14;	author henning;	state Exp;
branches;
next	1.121;

1.121
date	2004.02.26.16.16.41;	author claudio;	state Exp;
branches;
next	1.120;

1.120
date	2004.02.25.19.48.18;	author claudio;	state Exp;
branches;
next	1.119;

1.119
date	2004.02.21.15.45.14;	author henning;	state Exp;
branches;
next	1.118;

1.118
date	2004.02.18.00.30.09;	author henning;	state Exp;
branches;
next	1.117;

1.117
date	2004.02.17.23.55.11;	author henning;	state Exp;
branches;
next	1.116;

1.116
date	2004.02.17.23.21.21;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2004.02.17.21.59.09;	author henning;	state Exp;
branches;
next	1.114;

1.114
date	2004.02.17.20.48.05;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2004.02.17.15.53.17;	author henning;	state Exp;
branches;
next	1.112;

1.112
date	2004.02.17.15.47.24;	author claudio;	state Exp;
branches;
next	1.111;

1.111
date	2004.02.17.14.40.16;	author henning;	state Exp;
branches;
next	1.110;

1.110
date	2004.02.16.13.17.31;	author claudio;	state Exp;
branches;
next	1.109;

1.109
date	2004.02.16.12.53.15;	author claudio;	state Exp;
branches;
next	1.108;

1.108
date	2004.02.02.23.15.00;	author henning;	state Exp;
branches;
next	1.107;

1.107
date	2004.02.01.18.20.59;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2004.01.31.21.09.15;	author henning;	state Exp;
branches;
next	1.105;

1.105
date	2004.01.30.11.40.41;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2004.01.29.20.38.22;	author henning;	state Exp;
branches;
next	1.103;

1.103
date	2004.01.28.23.14.21;	author henning;	state Exp;
branches;
next	1.102;

1.102
date	2004.01.28.22.12.33;	author henning;	state Exp;
branches;
next	1.101;

1.101
date	2004.01.28.19.24.06;	author henning;	state Exp;
branches;
next	1.100;

1.100
date	2004.01.28.19.18.38;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2004.01.28.18.24.25;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2004.01.28.18.19.32;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2004.01.28.17.57.08;	author henning;	state Exp;
branches;
next	1.96;

1.96
date	2004.01.28.17.29.46;	author henning;	state Exp;
branches;
next	1.95;

1.95
date	2004.01.27.16.49.53;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2004.01.23.18.06.01;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2004.01.23.17.59.28;	author henning;	state Exp;
branches;
next	1.92;

1.92
date	2004.01.22.20.59.17;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2004.01.22.20.34.56;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2004.01.22.19.07.34;	author henning;	state Exp;
branches;
next	1.89;

1.89
date	2004.01.22.03.18.04;	author henning;	state Exp;
branches;
next	1.88;

1.88
date	2004.01.17.18.05.46;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2004.01.13.13.34.56;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2004.01.11.20.13.00;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2004.01.11.18.42.25;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2004.01.11.02.35.14;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2004.01.11.01.04.43;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2004.01.10.22.25.58;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2004.01.10.20.28.48;	author henning;	state Exp;
branches;
next	1.80;

1.80
date	2004.01.10.17.50.45;	author henning;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.10.17.10.22;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2004.01.10.17.04.07;	author henning;	state Exp;
branches;
next	1.77;

1.77
date	2004.01.09.19.08.50;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2004.01.09.13.47.08;	author henning;	state Exp;
branches;
next	1.75;

1.75
date	2004.01.09.13.38.39;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.07.01.41.49;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2004.01.07.01.15.54;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2004.01.06.23.14.58;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.06.21.48.19;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.06.20.44.15;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.06.20.41.55;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.06.19.19.21;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.06.18.01.26;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.05.22.57.58;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.04.23.08.09;	author henning;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.04.20.21.07;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.04.20.07.30;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.04.19.39.46;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.04.18.51.23;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.04.17.19.41;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.03.22.44.28;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.03.22.18.58;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2004.01.03.20.22.07;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.03.14.06.35;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.01.23.46.47;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.01.23.09.09;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.30.21.05.09;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2003.12.30.19.54.23;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2003.12.30.13.06.00;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2003.12.30.13.03.27;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.28.14.34.30;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.27.14.28.41;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.26.18.33.11;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.26.18.07.33;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.26.16.37.04;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.25.14.28.49;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.25.13.39.00;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.25.13.17.27;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.25.13.13.18;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.24.23.48.05;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.24.23.14.23;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.24.21.19.48;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.24.21.14.22;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.24.20.09.57;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.24.13.28.02;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.24.11.39.43;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.23.19.14.49;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.12.23.18.41.32;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.23.18.28.05;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.23.16.11.06;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.23.01.06.21;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.21.23.28.39;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.21.23.26.38;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.21.18.21.24;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.20.21.43.45;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.20.21.31.37;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.20.21.26.48;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.20.21.16.04;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.20.21.14.55;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.20.20.24.57;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.20.20.09.34;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.20.18.32.22;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.20.15.06.31;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.20.14.33.09;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.19.21.41.04;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.19.21.26.47;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.19.21.06.46;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.19.20.34.53;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.19.20.20.58;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.19.16.46.07;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.19.11.25.18;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.19.11.19.02;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.19.01.15.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.18.18.56.23;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.17.19.26.26;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.17.18.11.31;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;

1.310.2.1
date	2010.11.15.14.15.47;	author stephan;	state Exp;
branches;
next	;

1.323.2.1
date	2013.03.23.15.43.47;	author deraadt;	state Exp;
branches;
next	;

1.326.2.1
date	2013.05.01.09.39.02;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.364
log
@fix "depend on" when carp interface goes from MASTER into state INIT
aka UNKNOWN.
ok claudio@@ phessler@@ and henning helped along too
@
text
@/*	$OpenBSD: session.c,v 1.363 2017/05/28 20:10:59 claudio Exp $ */

/*
 * Copyright (c) 2003, 2004, 2005 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2017 Peter van Dijk <peter.van.dijk@@powerdns.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/un.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <limits.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "bgpd.h"
#include "mrt.h"
#include "session.h"
#include "log.h"

#define PFD_PIPE_MAIN		0
#define PFD_PIPE_ROUTE		1
#define PFD_PIPE_ROUTE_CTL	2
#define PFD_SOCK_CTL		3
#define PFD_SOCK_RCTL		4
#define PFD_SOCK_PFKEY		5
#define PFD_LISTENERS_START	6

void	session_sighdlr(int);
int	setup_listeners(u_int *);
void	init_conf(struct bgpd_config *);
void	init_peer(struct peer *);
void	start_timer_holdtime(struct peer *);
void	start_timer_keepalive(struct peer *);
void	session_close_connection(struct peer *);
void	change_state(struct peer *, enum session_state, enum session_events);
int	session_setup_socket(struct peer *);
void	session_accept(int);
int	session_connect(struct peer *);
void	session_tcp_established(struct peer *);
void	session_capa_ann_none(struct peer *);
int	session_capa_add(struct ibuf *, u_int8_t, u_int8_t);
int	session_capa_add_mp(struct ibuf *, u_int8_t);
int	session_capa_add_gr(struct peer *, struct ibuf *, u_int8_t);
struct bgp_msg	*session_newmsg(enum msg_type, u_int16_t);
int	session_sendmsg(struct bgp_msg *, struct peer *);
void	session_open(struct peer *);
void	session_keepalive(struct peer *);
void	session_update(u_int32_t, void *, size_t);
void	session_notification(struct peer *, u_int8_t, u_int8_t, void *,
	    ssize_t);
void	session_rrefresh(struct peer *, u_int8_t);
int	session_graceful_restart(struct peer *);
int	session_graceful_stop(struct peer *);
int	session_dispatch_msg(struct pollfd *, struct peer *);
int	session_process_msg(struct peer *);
int	parse_header(struct peer *, u_char *, u_int16_t *, u_int8_t *);
int	parse_open(struct peer *);
int	parse_update(struct peer *);
int	parse_refresh(struct peer *);
int	parse_notification(struct peer *);
int	parse_capabilities(struct peer *, u_char *, u_int16_t, u_int32_t *);
int	capa_neg_calc(struct peer *);
void	session_dispatch_imsg(struct imsgbuf *, int, u_int *);
void	session_up(struct peer *);
void	session_down(struct peer *);
void	session_demote(struct peer *, int);
int	session_link_state_is_up(int, int, int);

int		 la_cmp(struct listen_addr *, struct listen_addr *);
struct peer	*getpeerbyip(struct sockaddr *);
void		 session_template_clone(struct peer *, struct sockaddr *,
		    u_int32_t, u_int32_t);
int		 session_match_mask(struct peer *, struct bgpd_addr *);
struct peer	*getpeerbyid(u_int32_t);

struct bgpd_config	*conf, *nconf;
struct bgpd_sysdep	 sysdep;
struct peer		*peers, *npeers;
volatile sig_atomic_t	 session_quit;
int			 pending_reconf;
int			 csock = -1, rcsock = -1;
u_int			 peer_cnt;
struct imsgbuf		*ibuf_rde;
struct imsgbuf		*ibuf_rde_ctl;
struct imsgbuf		*ibuf_main;

struct mrt_head		 mrthead;
time_t			 pauseaccept;

void
session_sighdlr(int sig)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		session_quit = 1;
		break;
	}
}

int
setup_listeners(u_int *la_cnt)
{
	int			 ttl = 255;
	int			 opt;
	struct listen_addr	*la;
	u_int			 cnt = 0;

	TAILQ_FOREACH(la, conf->listen_addrs, entry) {
		la->reconf = RECONF_NONE;
		cnt++;

		if (la->flags & LISTENER_LISTENING)
			continue;

		if (la->fd == -1) {
			log_warn("cannot establish listener on %s: invalid fd",
			    log_sockaddr((struct sockaddr *)&la->sa));
			continue;
		}

		opt = 1;
		if (setsockopt(la->fd, IPPROTO_TCP, TCP_MD5SIG,
		    &opt, sizeof(opt)) == -1) {
			if (errno == ENOPROTOOPT) {	/* system w/o md5sig */
				log_warnx("md5sig not available, disabling");
				sysdep.no_md5sig = 1;
			} else
				fatal("setsockopt TCP_MD5SIG");
		}

		/* set ttl to 255 so that ttl-security works */
		if (la->sa.ss_family == AF_INET && setsockopt(la->fd,
		    IPPROTO_IP, IP_TTL, &ttl, sizeof(ttl)) == -1) {
			log_warn("setup_listeners setsockopt TTL");
			continue;
		}
		if (la->sa.ss_family == AF_INET6 && setsockopt(la->fd,
		    IPPROTO_IPV6, IPV6_UNICAST_HOPS, &ttl, sizeof(ttl)) == -1) {
			log_warn("setup_listeners setsockopt hoplimit");
			continue;
		}

		if (listen(la->fd, MAX_BACKLOG)) {
			close(la->fd);
			fatal("listen");
		}

		la->flags |= LISTENER_LISTENING;

		log_info("listening on %s",
		    log_sockaddr((struct sockaddr *)&la->sa));
	}

	*la_cnt = cnt;

	return (0);
}

void
session_main(int debug, int verbose)
{
	int			 timeout, pfkeysock;
	unsigned int		 i, j, idx_peers, idx_listeners, idx_mrts;
	u_int			 pfd_elms = 0, peer_l_elms = 0, mrt_l_elms = 0;
	u_int			 listener_cnt, ctl_cnt, mrt_cnt;
	u_int			 new_cnt;
	struct passwd		*pw;
	struct peer		*p, **peer_l = NULL, *last, *next;
	struct mrt		*m, *xm, **mrt_l = NULL;
	struct pollfd		*pfd = NULL;
	struct ctl_conn		*ctl_conn;
	struct listen_addr	*la;
	void			*newp;
	short			 events;

	log_init(debug, LOG_DAEMON);
	log_setverbose(verbose);

	bgpd_process = PROC_SE;
	log_procinit(log_procnames[bgpd_process]);

	if ((pw = getpwnam(BGPD_USER)) == NULL)
		fatal(NULL);

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("session engine");
	pfkeysock = pfkey_init(&sysdep);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	if (pledge("stdio inet recvfd", NULL) == -1)
		fatal("pledge");

	signal(SIGTERM, session_sighdlr);
	signal(SIGINT, session_sighdlr);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
	signal(SIGALRM, SIG_IGN);
	signal(SIGUSR1, SIG_IGN);

	if ((ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
		fatal(NULL);
	imsg_init(ibuf_main, 3);

	TAILQ_INIT(&ctl_conns);
	LIST_INIT(&mrthead);
	listener_cnt = 0;
	peer_cnt = 0;
	ctl_cnt = 0;

	if ((conf = calloc(1, sizeof(struct bgpd_config))) == NULL)
		fatal(NULL);
	if ((conf->listen_addrs = calloc(1, sizeof(struct listen_addrs))) ==
	    NULL)
		fatal(NULL);
	TAILQ_INIT(conf->listen_addrs);

	log_info("session engine ready");

	while (session_quit == 0) {
		/* check for peers to be initialized or deleted */
		last = NULL;
		if (!pending_reconf) {
			for (p = peers; p != NULL; p = next) {
				next = p->next;
				/* cloned peer that idled out? */
				if (p->template && (p->state == STATE_IDLE ||
				    p->state == STATE_ACTIVE) &&
				    time(NULL) - p->stats.last_updown >=
				    INTERVAL_HOLD_CLONED)
					p->conf.reconf_action = RECONF_DELETE;

				/* new peer that needs init? */
				if (p->state == STATE_NONE)
					init_peer(p);

				/* reinit due? */
				if (p->conf.reconf_action == RECONF_REINIT) {
					session_stop(p, ERR_CEASE_ADMIN_RESET);
					if (!p->conf.down)
						timer_set(p, Timer_IdleHold, 0);
				}

				/* deletion due? */
				if (p->conf.reconf_action == RECONF_DELETE) {
					if (p->demoted)
						session_demote(p, -1);
					p->conf.demote_group[0] = 0;
					session_stop(p, ERR_CEASE_PEER_UNCONF);
					log_peer_warnx(&p->conf, "removed");
					if (last != NULL)
						last->next = next;
					else
						peers = next;
					timer_remove_all(p);
					free(p);
					peer_cnt--;
					continue;
				}
				p->conf.reconf_action = RECONF_NONE;
				last = p;
			}
		}

		if (peer_cnt > peer_l_elms) {
			if ((newp = reallocarray(peer_l, peer_cnt,
			    sizeof(struct peer *))) == NULL) {
				/* panic for now  */
				log_warn("could not resize peer_l from %u -> %u"
				    " entries", peer_l_elms, peer_cnt);
				fatalx("exiting");
			}
			peer_l = newp;
			peer_l_elms = peer_cnt;
		}

		mrt_cnt = 0;
		for (m = LIST_FIRST(&mrthead); m != NULL; m = xm) {
			xm = LIST_NEXT(m, entry);
			if (m->state == MRT_STATE_REMOVE) {
				mrt_clean(m);
				LIST_REMOVE(m, entry);
				free(m);
				continue;
			}
			if (m->wbuf.queued)
				mrt_cnt++;
		}

		if (mrt_cnt > mrt_l_elms) {
			if ((newp = reallocarray(mrt_l, mrt_cnt,
			    sizeof(struct mrt *))) == NULL) {
				/* panic for now  */
				log_warn("could not resize mrt_l from %u -> %u"
				    " entries", mrt_l_elms, mrt_cnt);
				fatalx("exiting");
			}
			mrt_l = newp;
			mrt_l_elms = mrt_cnt;
		}

		new_cnt = PFD_LISTENERS_START + listener_cnt + peer_cnt +
		    ctl_cnt + mrt_cnt;
		if (new_cnt > pfd_elms) {
			if ((newp = reallocarray(pfd, new_cnt,
			    sizeof(struct pollfd))) == NULL) {
				/* panic for now  */
				log_warn("could not resize pfd from %u -> %u"
				    " entries", pfd_elms, new_cnt);
				fatalx("exiting");
			}
			pfd = newp;
			pfd_elms = new_cnt;
		}

		bzero(pfd, sizeof(struct pollfd) * pfd_elms);

		set_pollfd(&pfd[PFD_PIPE_MAIN], ibuf_main);
		set_pollfd(&pfd[PFD_PIPE_ROUTE], ibuf_rde);
		set_pollfd(&pfd[PFD_PIPE_ROUTE_CTL], ibuf_rde_ctl);

		if (pauseaccept == 0) {
			pfd[PFD_SOCK_CTL].fd = csock;
			pfd[PFD_SOCK_CTL].events = POLLIN;
			pfd[PFD_SOCK_RCTL].fd = rcsock;
			pfd[PFD_SOCK_RCTL].events = POLLIN;
		} else {
			pfd[PFD_SOCK_CTL].fd = -1;
			pfd[PFD_SOCK_RCTL].fd = -1;
		}
		pfd[PFD_SOCK_PFKEY].fd = pfkeysock;
		pfd[PFD_SOCK_PFKEY].events = POLLIN;

		i = PFD_LISTENERS_START;
		TAILQ_FOREACH(la, conf->listen_addrs, entry) {
			if (pauseaccept == 0) {
				pfd[i].fd = la->fd;
				pfd[i].events = POLLIN;
			} else
				pfd[i].fd = -1;
			i++;
		}
		idx_listeners = i;
		timeout = 240;	/* loop every 240s at least */

		for (p = peers; p != NULL; p = p->next) {
			time_t	nextaction;
			struct peer_timer *pt;

			/* check timers */
			if ((pt = timer_nextisdue(p)) != NULL) {
				switch (pt->type) {
				case Timer_Hold:
					bgp_fsm(p, EVNT_TIMER_HOLDTIME);
					break;
				case Timer_ConnectRetry:
					bgp_fsm(p, EVNT_TIMER_CONNRETRY);
					break;
				case Timer_Keepalive:
					bgp_fsm(p, EVNT_TIMER_KEEPALIVE);
					break;
				case Timer_IdleHold:
					bgp_fsm(p, EVNT_START);
					break;
				case Timer_IdleHoldReset:
					p->IdleHoldTime /= 2;
					if (p->IdleHoldTime <=
					    INTERVAL_IDLE_HOLD_INITIAL) {
						p->IdleHoldTime =
						    INTERVAL_IDLE_HOLD_INITIAL;
						timer_stop(p,
						    Timer_IdleHoldReset);
						p->errcnt = 0;
					} else
						timer_set(p,
						    Timer_IdleHoldReset,
						    p->IdleHoldTime);
					break;
				case Timer_CarpUndemote:
					timer_stop(p, Timer_CarpUndemote);
					if (p->demoted &&
					    p->state == STATE_ESTABLISHED)
						session_demote(p, -1);
					break;
				case Timer_RestartTimeout:
					timer_stop(p, Timer_RestartTimeout);
					session_graceful_stop(p);
					break;
				default:
					fatalx("King Bula lost in time");
				}
			}
			if ((nextaction = timer_nextduein(p)) != -1 &&
			    nextaction < timeout)
				timeout = nextaction;

			/* are we waiting for a write? */
			events = POLLIN;
			if (p->wbuf.queued > 0 || p->state == STATE_CONNECT)
				events |= POLLOUT;
			/* is there still work to do? */
			if (p->rbuf && p->rbuf->wpos)
				timeout = 0;

			/* poll events */
			if (p->fd != -1 && events != 0) {
				pfd[i].fd = p->fd;
				pfd[i].events = events;
				peer_l[i - idx_listeners] = p;
				i++;
			}
		}

		idx_peers = i;

		LIST_FOREACH(m, &mrthead, entry)
			if (m->wbuf.queued) {
				pfd[i].fd = m->wbuf.fd;
				pfd[i].events = POLLOUT;
				mrt_l[i - idx_peers] = m;
				i++;
			}

		idx_mrts = i;

		TAILQ_FOREACH(ctl_conn, &ctl_conns, entry) {
			pfd[i].fd = ctl_conn->ibuf.fd;
			pfd[i].events = POLLIN;
			if (ctl_conn->ibuf.w.queued > 0)
				pfd[i].events |= POLLOUT;
			i++;
		}

		if (pauseaccept && timeout > 1)
			timeout = 1;
		if (timeout < 0)
			timeout = 0;
		if (poll(pfd, i, timeout * 1000) == -1)
			if (errno != EINTR)
				fatal("poll error");

		/*
		 * If we previously saw fd exhaustion, we stop accept()
		 * for 1 second to throttle the accept() loop.
		 */
		if (pauseaccept && getmonotime() > pauseaccept + 1)
			pauseaccept = 0;

		if (handle_pollfd(&pfd[PFD_PIPE_MAIN], ibuf_main) == -1) {
			log_warnx("SE: Lost connection to parent");
			session_quit = 1;
			continue;
		} else
			session_dispatch_imsg(ibuf_main, PFD_PIPE_MAIN,
			    &listener_cnt);

		if (handle_pollfd(&pfd[PFD_PIPE_ROUTE], ibuf_rde) == -1) {
			log_warnx("SE: Lost connection to RDE");
			msgbuf_clear(&ibuf_rde->w);
			free(ibuf_rde);
			ibuf_rde = NULL;
		} else
			session_dispatch_imsg(ibuf_rde, PFD_PIPE_ROUTE,
			    &listener_cnt);

		if (handle_pollfd(&pfd[PFD_PIPE_ROUTE_CTL], ibuf_rde_ctl) ==
		    -1) {
			log_warnx("SE: Lost connection to RDE control");
			msgbuf_clear(&ibuf_rde_ctl->w);
			free(ibuf_rde_ctl);
			ibuf_rde_ctl = NULL;
		} else
			session_dispatch_imsg(ibuf_rde_ctl, PFD_PIPE_ROUTE_CTL,
			    &listener_cnt);

		if (pfd[PFD_SOCK_CTL].revents & POLLIN)
			ctl_cnt += control_accept(csock, 0);

		if (pfd[PFD_SOCK_RCTL].revents & POLLIN)
			ctl_cnt += control_accept(rcsock, 1);

		if (pfd[PFD_SOCK_PFKEY].revents & POLLIN) {
			if (pfkey_read(pfkeysock, NULL) == -1) {
				log_warnx("pfkey_read failed, exiting...");
				session_quit = 1;
			}
		}

		for (j = PFD_LISTENERS_START; j < idx_listeners; j++)
			if (pfd[j].revents & POLLIN)
				session_accept(pfd[j].fd);

		for (; j < idx_peers; j++)
			session_dispatch_msg(&pfd[j],
			    peer_l[j - idx_listeners]);

		for (p = peers; p != NULL; p = p->next)
			if (p->rbuf && p->rbuf->wpos)
				session_process_msg(p);

		for (; j < idx_mrts; j++)
			if (pfd[j].revents & POLLOUT)
				mrt_write(mrt_l[j - idx_peers]);

		for (; j < i; j++)
			control_dispatch_msg(&pfd[j], &ctl_cnt);
	}

	while ((p = peers) != NULL) {
		peers = p->next;
		strlcpy(p->conf.shutcomm,
		    "bgpd shutting down",
		    sizeof(p->conf.shutcomm));
		session_stop(p, ERR_CEASE_ADMIN_DOWN);
		pfkey_remove(p);
		free(p);
	}

	while ((m = LIST_FIRST(&mrthead)) != NULL) {
		mrt_clean(m);
		LIST_REMOVE(m, entry);
		free(m);
	}

	while ((la = TAILQ_FIRST(conf->listen_addrs)) != NULL) {
		TAILQ_REMOVE(conf->listen_addrs, la, entry);
		free(la);
	}
	free(conf->listen_addrs);
	free(peer_l);
	free(mrt_l);
	free(pfd);

	/* close pipes */
	if (ibuf_rde) {
		msgbuf_write(&ibuf_rde->w);
		msgbuf_clear(&ibuf_rde->w);
		close(ibuf_rde->fd);
		free(ibuf_rde);
	}
	if (ibuf_rde_ctl) {
		msgbuf_clear(&ibuf_rde_ctl->w);
		close(ibuf_rde_ctl->fd);
		free(ibuf_rde_ctl);
	}
	msgbuf_write(&ibuf_main->w);
	msgbuf_clear(&ibuf_main->w);
	close(ibuf_main->fd);
	free(ibuf_main);

	control_shutdown(csock);
	control_shutdown(rcsock);
	log_info("session engine exiting");
	exit(0);
}

void
init_conf(struct bgpd_config *c)
{
	if (!c->holdtime)
		c->holdtime = INTERVAL_HOLD;
	if (!c->connectretry)
		c->connectretry = INTERVAL_CONNECTRETRY;
}

void
init_peer(struct peer *p)
{
	TAILQ_INIT(&p->timers);
	p->fd = p->wbuf.fd = -1;

	if (p->conf.if_depend[0])
		imsg_compose(ibuf_main, IMSG_IFINFO, 0, 0, -1,
		    p->conf.if_depend, sizeof(p->conf.if_depend));
	else
		p->depend_ok = 1;

	peer_cnt++;

	change_state(p, STATE_IDLE, EVNT_NONE);
	if (p->conf.down)
		timer_stop(p, Timer_IdleHold);		/* no autostart */
	else
		timer_set(p, Timer_IdleHold, 0);	/* start ASAP */

	/*
	 * on startup, demote if requested.
	 * do not handle new peers. they must reach ESTABLISHED beforehands.
	 * peers added at runtime have reconf_action set to RECONF_REINIT.
	 */
	if (p->conf.reconf_action != RECONF_REINIT && p->conf.demote_group[0])
		session_demote(p, +1);
}

void
bgp_fsm(struct peer *peer, enum session_events event)
{
	switch (peer->state) {
	case STATE_NONE:
		/* nothing */
		break;
	case STATE_IDLE:
		switch (event) {
		case EVNT_START:
			timer_stop(peer, Timer_Hold);
			timer_stop(peer, Timer_Keepalive);
			timer_stop(peer, Timer_IdleHold);

			/* allocate read buffer */
			peer->rbuf = calloc(1, sizeof(struct ibuf_read));
			if (peer->rbuf == NULL)
				fatal(NULL);

			/* init write buffer */
			msgbuf_init(&peer->wbuf);

			/* init pfkey - remove old if any, load new ones */
			pfkey_remove(peer);
			if (pfkey_establish(peer) == -1) {
				log_peer_warnx(&peer->conf,
				    "pfkey setup failed");
				return;
			}

			peer->stats.last_sent_errcode = 0;
			peer->stats.last_sent_suberr = 0;

			if (!peer->depend_ok)
				timer_stop(peer, Timer_ConnectRetry);
			else if (peer->passive || peer->conf.passive ||
			    peer->conf.template) {
				change_state(peer, STATE_ACTIVE, event);
				timer_stop(peer, Timer_ConnectRetry);
			} else {
				change_state(peer, STATE_CONNECT, event);
				timer_set(peer, Timer_ConnectRetry,
				    conf->connectretry);
				session_connect(peer);
			}
			peer->passive = 0;
			break;
		default:
			/* ignore */
			break;
		}
		break;
	case STATE_CONNECT:
		switch (event) {
		case EVNT_START:
			/* ignore */
			break;
		case EVNT_CON_OPEN:
			session_tcp_established(peer);
			session_open(peer);
			timer_stop(peer, Timer_ConnectRetry);
			peer->holdtime = INTERVAL_HOLD_INITIAL;
			start_timer_holdtime(peer);
			change_state(peer, STATE_OPENSENT, event);
			break;
		case EVNT_CON_OPENFAIL:
			timer_set(peer, Timer_ConnectRetry,
			    conf->connectretry);
			session_close_connection(peer);
			change_state(peer, STATE_ACTIVE, event);
			break;
		case EVNT_TIMER_CONNRETRY:
			timer_set(peer, Timer_ConnectRetry,
			    conf->connectretry);
			session_connect(peer);
			break;
		default:
			change_state(peer, STATE_IDLE, event);
			break;
		}
		break;
	case STATE_ACTIVE:
		switch (event) {
		case EVNT_START:
			/* ignore */
			break;
		case EVNT_CON_OPEN:
			session_tcp_established(peer);
			session_open(peer);
			timer_stop(peer, Timer_ConnectRetry);
			peer->holdtime = INTERVAL_HOLD_INITIAL;
			start_timer_holdtime(peer);
			change_state(peer, STATE_OPENSENT, event);
			break;
		case EVNT_CON_OPENFAIL:
			timer_set(peer, Timer_ConnectRetry,
			    conf->connectretry);
			session_close_connection(peer);
			change_state(peer, STATE_ACTIVE, event);
			break;
		case EVNT_TIMER_CONNRETRY:
			timer_set(peer, Timer_ConnectRetry,
			    peer->holdtime);
			change_state(peer, STATE_CONNECT, event);
			session_connect(peer);
			break;
		default:
			change_state(peer, STATE_IDLE, event);
			break;
		}
		break;
	case STATE_OPENSENT:
		switch (event) {
		case EVNT_START:
			/* ignore */
			break;
		case EVNT_STOP:
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_CON_CLOSED:
			session_close_connection(peer);
			timer_set(peer, Timer_ConnectRetry,
			    conf->connectretry);
			change_state(peer, STATE_ACTIVE, event);
			break;
		case EVNT_CON_FATAL:
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_TIMER_HOLDTIME:
			session_notification(peer, ERR_HOLDTIMEREXPIRED,
			    0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_RCVD_OPEN:
			/* parse_open calls change_state itself on failure */
			if (parse_open(peer))
				break;
			session_keepalive(peer);
			change_state(peer, STATE_OPENCONFIRM, event);
			break;
		case EVNT_RCVD_NOTIFICATION:
			if (parse_notification(peer)) {
				change_state(peer, STATE_IDLE, event);
				/* don't punish, capa negotiation */
				timer_set(peer, Timer_IdleHold, 0);
				peer->IdleHoldTime /= 2;
			} else
				change_state(peer, STATE_IDLE, event);
			break;
		default:
			session_notification(peer,
			    ERR_FSM, ERR_FSM_UNEX_OPENSENT, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		}
		break;
	case STATE_OPENCONFIRM:
		switch (event) {
		case EVNT_START:
			/* ignore */
			break;
		case EVNT_STOP:
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_CON_CLOSED:
		case EVNT_CON_FATAL:
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_TIMER_HOLDTIME:
			session_notification(peer, ERR_HOLDTIMEREXPIRED,
			    0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_TIMER_KEEPALIVE:
			session_keepalive(peer);
			break;
		case EVNT_RCVD_KEEPALIVE:
			start_timer_holdtime(peer);
			change_state(peer, STATE_ESTABLISHED, event);
			break;
		case EVNT_RCVD_NOTIFICATION:
			parse_notification(peer);
			change_state(peer, STATE_IDLE, event);
			break;
		default:
			session_notification(peer,
			    ERR_FSM, ERR_FSM_UNEX_OPENCONFIRM, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		}
		break;
	case STATE_ESTABLISHED:
		switch (event) {
		case EVNT_START:
			/* ignore */
			break;
		case EVNT_STOP:
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_CON_CLOSED:
		case EVNT_CON_FATAL:
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_TIMER_HOLDTIME:
			session_notification(peer, ERR_HOLDTIMEREXPIRED,
			    0, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		case EVNT_TIMER_KEEPALIVE:
			session_keepalive(peer);
			break;
		case EVNT_RCVD_KEEPALIVE:
			start_timer_holdtime(peer);
			break;
		case EVNT_RCVD_UPDATE:
			start_timer_holdtime(peer);
			if (parse_update(peer))
				change_state(peer, STATE_IDLE, event);
			else
				start_timer_holdtime(peer);
			break;
		case EVNT_RCVD_NOTIFICATION:
			parse_notification(peer);
			change_state(peer, STATE_IDLE, event);
			break;
		default:
			session_notification(peer,
			    ERR_FSM, ERR_FSM_UNEX_ESTABLISHED, NULL, 0);
			change_state(peer, STATE_IDLE, event);
			break;
		}
		break;
	}
}

void
start_timer_holdtime(struct peer *peer)
{
	if (peer->holdtime > 0)
		timer_set(peer, Timer_Hold, peer->holdtime);
	else
		timer_stop(peer, Timer_Hold);
}

void
start_timer_keepalive(struct peer *peer)
{
	if (peer->holdtime > 0)
		timer_set(peer, Timer_Keepalive, peer->holdtime / 3);
	else
		timer_stop(peer, Timer_Keepalive);
}

void
session_close_connection(struct peer *peer)
{
	if (peer->fd != -1) {
		close(peer->fd);
		pauseaccept = 0;
	}
	peer->fd = peer->wbuf.fd = -1;
}

void
change_state(struct peer *peer, enum session_state state,
    enum session_events event)
{
	struct mrt	*mrt;

	switch (state) {
	case STATE_IDLE:
		/* carp demotion first. new peers handled in init_peer */
		if (peer->state == STATE_ESTABLISHED &&
		    peer->conf.demote_group[0] && !peer->demoted)
			session_demote(peer, +1);

		/*
		 * try to write out what's buffered (maybe a notification),
		 * don't bother if it fails
		 */
		if (peer->state >= STATE_OPENSENT && peer->wbuf.queued)
			msgbuf_write(&peer->wbuf);

		/*
		 * we must start the timer for the next EVNT_START
		 * if we are coming here due to an error and the
		 * session was not established successfully before, the
		 * starttimerinterval needs to be exponentially increased
		 */
		if (peer->IdleHoldTime == 0)
			peer->IdleHoldTime = INTERVAL_IDLE_HOLD_INITIAL;
		peer->holdtime = INTERVAL_HOLD_INITIAL;
		timer_stop(peer, Timer_ConnectRetry);
		timer_stop(peer, Timer_Keepalive);
		timer_stop(peer, Timer_Hold);
		timer_stop(peer, Timer_IdleHold);
		timer_stop(peer, Timer_IdleHoldReset);
		session_close_connection(peer);
		msgbuf_clear(&peer->wbuf);
		free(peer->rbuf);
		peer->rbuf = NULL;
		bzero(&peer->capa.peer, sizeof(peer->capa.peer));

		if (event != EVNT_STOP) {
			timer_set(peer, Timer_IdleHold, peer->IdleHoldTime);
			if (event != EVNT_NONE &&
			    peer->IdleHoldTime < MAX_IDLE_HOLD/2)
				peer->IdleHoldTime *= 2;
		}
		if (peer->state == STATE_ESTABLISHED) {
			if (peer->capa.neg.grestart.restart == 2 &&
			    (event == EVNT_CON_CLOSED ||
			    event == EVNT_CON_FATAL)) {
				/* don't punish graceful restart */
				timer_set(peer, Timer_IdleHold, 0);
				peer->IdleHoldTime /= 2;
				session_graceful_restart(peer);
			} else
				session_down(peer);
		}
		if (peer->state == STATE_NONE ||
		    peer->state == STATE_ESTABLISHED) {
			/* initialize capability negotiation structures */
			memcpy(&peer->capa.ann, &peer->conf.capabilities,
			    sizeof(peer->capa.ann));
			if (!peer->conf.announce_capa)
				session_capa_ann_none(peer);
		}
		break;
	case STATE_CONNECT:
		if (peer->state == STATE_ESTABLISHED &&
		    peer->capa.neg.grestart.restart == 2) {
			/* do the graceful restart dance */
			session_graceful_restart(peer);
			peer->holdtime = INTERVAL_HOLD_INITIAL;
			timer_stop(peer, Timer_ConnectRetry);
			timer_stop(peer, Timer_Keepalive);
			timer_stop(peer, Timer_Hold);
			timer_stop(peer, Timer_IdleHold);
			timer_stop(peer, Timer_IdleHoldReset);
			session_close_connection(peer);
			msgbuf_clear(&peer->wbuf);
			bzero(&peer->capa.peer, sizeof(peer->capa.peer));
		}
		break;
	case STATE_ACTIVE:
		break;
	case STATE_OPENSENT:
		break;
	case STATE_OPENCONFIRM:
		break;
	case STATE_ESTABLISHED:
		timer_set(peer, Timer_IdleHoldReset, peer->IdleHoldTime);
		if (peer->demoted)
			timer_set(peer, Timer_CarpUndemote,
			    INTERVAL_HOLD_DEMOTED);
		session_up(peer);
		break;
	default:		/* something seriously fucked */
		break;
	}

	log_statechange(peer, state, event);
	LIST_FOREACH(mrt, &mrthead, entry) {
		if (!(mrt->type == MRT_ALL_IN || mrt->type == MRT_ALL_OUT))
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == peer->conf.id || (mrt->group_id != 0 &&
		    mrt->group_id == peer->conf.groupid))
			mrt_dump_state(mrt, peer->state, state, peer);
	}
	peer->prev_state = peer->state;
	peer->state = state;
}

void
session_accept(int listenfd)
{
	int			 connfd;
	int			 opt;
	socklen_t		 len;
	struct sockaddr_storage	 cliaddr;
	struct peer		*p = NULL;

	len = sizeof(cliaddr);
	if ((connfd = accept4(listenfd,
	    (struct sockaddr *)&cliaddr, &len,
	    SOCK_CLOEXEC | SOCK_NONBLOCK)) == -1) {
		if (errno == ENFILE || errno == EMFILE)
			pauseaccept = getmonotime();
		else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("accept");
		return;
	}

	p = getpeerbyip((struct sockaddr *)&cliaddr);

	if (p != NULL && p->state == STATE_IDLE && p->errcnt < 2) {
		if (timer_running(p, Timer_IdleHold, NULL)) {
			/* fast reconnect after clear */
			p->passive = 1;
			bgp_fsm(p, EVNT_START);
		}
	}

	if (p != NULL &&
	    (p->state == STATE_CONNECT || p->state == STATE_ACTIVE)) {
		if (p->fd != -1) {
			if (p->state == STATE_CONNECT)
				session_close_connection(p);
			else {
				close(connfd);
				return;
			}
		}

open:
		if (p->conf.auth.method != AUTH_NONE && sysdep.no_pfkey) {
			log_peer_warnx(&p->conf,
			    "ipsec or md5sig configured but not available");
			close(connfd);
			return;
		}

		if (p->conf.auth.method == AUTH_MD5SIG) {
			if (sysdep.no_md5sig) {
				log_peer_warnx(&p->conf,
				    "md5sig configured but not available");
				close(connfd);
				return;
			}
			len = sizeof(opt);
			if (getsockopt(connfd, IPPROTO_TCP, TCP_MD5SIG,
			    &opt, &len) == -1)
				fatal("getsockopt TCP_MD5SIG");
			if (!opt) {	/* non-md5'd connection! */
				log_peer_warnx(&p->conf,
				    "connection attempt without md5 signature");
				close(connfd);
				return;
			}
		}
		p->fd = p->wbuf.fd = connfd;
		if (session_setup_socket(p)) {
			close(connfd);
			return;
		}
		bgp_fsm(p, EVNT_CON_OPEN);
		return;
	} else if (p != NULL && p->state == STATE_ESTABLISHED &&
	    p->capa.neg.grestart.restart == 2) {
		/* first do the graceful restart dance */
		change_state(p, STATE_CONNECT, EVNT_CON_CLOSED);
		/* then do part of the open dance */
		goto open;
	} else {
		log_conn_attempt(p, (struct sockaddr *)&cliaddr);
		close(connfd);
	}
}

int
session_connect(struct peer *peer)
{
	int			 opt = 1;
	struct sockaddr		*sa;

	/*
	 * we do not need the overcomplicated collision detection RFC 1771
	 * describes; we simply make sure there is only ever one concurrent
	 * tcp connection per peer.
	 */
	if (peer->fd != -1)
		return (-1);

	if ((peer->fd = socket(aid2af(peer->conf.remote_addr.aid),
	    SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, IPPROTO_TCP)) == -1) {
		log_peer_warn(&peer->conf, "session_connect socket");
		bgp_fsm(peer, EVNT_CON_OPENFAIL);
		return (-1);
	}

	if (peer->conf.auth.method != AUTH_NONE && sysdep.no_pfkey) {
		log_peer_warnx(&peer->conf,
		    "ipsec or md5sig configured but not available");
		bgp_fsm(peer, EVNT_CON_OPENFAIL);
		return (-1);
	}

	if (peer->conf.auth.method == AUTH_MD5SIG) {
		if (sysdep.no_md5sig) {
			log_peer_warnx(&peer->conf,
			    "md5sig configured but not available");
			bgp_fsm(peer, EVNT_CON_OPENFAIL);
			return (-1);
		}
		if (setsockopt(peer->fd, IPPROTO_TCP, TCP_MD5SIG,
		    &opt, sizeof(opt)) == -1) {
			log_peer_warn(&peer->conf, "setsockopt md5sig");
			bgp_fsm(peer, EVNT_CON_OPENFAIL);
			return (-1);
		}
	}
	peer->wbuf.fd = peer->fd;

	/* if update source is set we need to bind() */
	if ((sa = addr2sa(&peer->conf.local_addr, 0)) != NULL) {
		if (bind(peer->fd, sa, sa->sa_len) == -1) {
			log_peer_warn(&peer->conf, "session_connect bind");
			bgp_fsm(peer, EVNT_CON_OPENFAIL);
			return (-1);
		}
	}

	if (session_setup_socket(peer)) {
		bgp_fsm(peer, EVNT_CON_OPENFAIL);
		return (-1);
	}

	sa = addr2sa(&peer->conf.remote_addr, BGP_PORT);
	if (connect(peer->fd, sa, sa->sa_len) == -1) {
		if (errno != EINPROGRESS) {
			if (errno != peer->lasterr)
				log_peer_warn(&peer->conf, "connect");
			peer->lasterr = errno;
			bgp_fsm(peer, EVNT_CON_OPENFAIL);
			return (-1);
		}
	} else
		bgp_fsm(peer, EVNT_CON_OPEN);

	return (0);
}

int
session_setup_socket(struct peer *p)
{
	int	ttl = p->conf.distance;
	int	pre = IPTOS_PREC_INTERNETCONTROL;
	int	nodelay = 1;
	int	bsize;

	switch (p->conf.remote_addr.aid) {
	case AID_INET:
		/* set precedence, see RFC 1771 appendix 5 */
		if (setsockopt(p->fd, IPPROTO_IP, IP_TOS, &pre, sizeof(pre)) ==
		    -1) {
			log_peer_warn(&p->conf,
			    "session_setup_socket setsockopt TOS");
			return (-1);
		}

		if (p->conf.ebgp) {
			/* set TTL to foreign router's distance
			   1=direct n=multihop with ttlsec, we always use 255 */
			if (p->conf.ttlsec) {
				ttl = 256 - p->conf.distance;
				if (setsockopt(p->fd, IPPROTO_IP, IP_MINTTL,
				    &ttl, sizeof(ttl)) == -1) {
					log_peer_warn(&p->conf,
					    "session_setup_socket: "
					    "setsockopt MINTTL");
					return (-1);
				}
				ttl = 255;
			}

			if (setsockopt(p->fd, IPPROTO_IP, IP_TTL, &ttl,
			    sizeof(ttl)) == -1) {
				log_peer_warn(&p->conf,
				    "session_setup_socket setsockopt TTL");
				return (-1);
			}
		}
		break;
	case AID_INET6:
		if (p->conf.ebgp) {
			/* set hoplimit to foreign router's distance
			   1=direct n=multihop with ttlsec, we always use 255 */
			if (p->conf.ttlsec) {
				ttl = 256 - p->conf.distance;
				if (setsockopt(p->fd, IPPROTO_IPV6,
				    IPV6_MINHOPCOUNT, &ttl, sizeof(ttl))
				    == -1) {
					log_peer_warn(&p->conf,
					    "session_setup_socket: "
					    "setsockopt MINHOPCOUNT");
					return (-1);
				}
				ttl = 255;
			}
			if (setsockopt(p->fd, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
			    &ttl, sizeof(ttl)) == -1) {
				log_peer_warn(&p->conf,
				    "session_setup_socket setsockopt hoplimit");
				return (-1);
			}
		}
		break;
	}

	/* set TCP_NODELAY */
	if (setsockopt(p->fd, IPPROTO_TCP, TCP_NODELAY, &nodelay,
	    sizeof(nodelay)) == -1) {
		log_peer_warn(&p->conf,
		    "session_setup_socket setsockopt TCP_NODELAY");
		return (-1);
	}

	/* only increase bufsize (and thus window) if md5 or ipsec is in use */
	if (p->conf.auth.method != AUTH_NONE) {
		/* try to increase bufsize. no biggie if it fails */
		bsize = 65535;
		while (bsize > 8192 &&
		    setsockopt(p->fd, SOL_SOCKET, SO_RCVBUF, &bsize,
		    sizeof(bsize)) == -1 && errno != EINVAL)
			bsize /= 2;
		bsize = 65535;
		while (bsize > 8192 &&
		    setsockopt(p->fd, SOL_SOCKET, SO_SNDBUF, &bsize,
		    sizeof(bsize)) == -1 && errno != EINVAL)
			bsize /= 2;
	}

	return (0);
}

void
session_tcp_established(struct peer *peer)
{
	socklen_t	len;

	len = sizeof(peer->sa_local);
	if (getsockname(peer->fd, (struct sockaddr *)&peer->sa_local,
	    &len) == -1)
		log_warn("getsockname");
	len = sizeof(peer->sa_remote);
	if (getpeername(peer->fd, (struct sockaddr *)&peer->sa_remote,
	    &len) == -1)
		log_warn("getpeername");
}

void
session_capa_ann_none(struct peer *peer)
{
	bzero(&peer->capa.ann, sizeof(peer->capa.ann));
}

int
session_capa_add(struct ibuf *opb, u_int8_t capa_code, u_int8_t capa_len)
{
	int errs = 0;

	errs += ibuf_add(opb, &capa_code, sizeof(capa_code));
	errs += ibuf_add(opb, &capa_len, sizeof(capa_len));
	return (errs);
}

int
session_capa_add_mp(struct ibuf *buf, u_int8_t aid)
{
	u_int8_t		 safi, pad = 0;
	u_int16_t		 afi;
	int			 errs = 0;

	if (aid2afi(aid, &afi, &safi) == -1)
		fatalx("session_capa_add_mp: bad afi/safi pair");
	afi = htons(afi);
	errs += ibuf_add(buf, &afi, sizeof(afi));
	errs += ibuf_add(buf, &pad, sizeof(pad));
	errs += ibuf_add(buf, &safi, sizeof(safi));

	return (errs);
}

int
session_capa_add_gr(struct peer *p, struct ibuf *b, u_int8_t aid)
{
	u_int		errs = 0;
	u_int16_t	afi;
	u_int8_t	flags, safi;

	if (aid2afi(aid, &afi, &safi)) {
		log_warn("session_capa_add_gr: bad AID");
		return (1);
	}
	if (p->capa.neg.grestart.flags[aid] & CAPA_GR_RESTARTING)
		flags = CAPA_GR_F_FLAG;
	else
		flags = 0;

	afi = htons(afi);
	errs += ibuf_add(b, &afi, sizeof(afi));
	errs += ibuf_add(b, &safi, sizeof(safi));
	errs += ibuf_add(b, &flags, sizeof(flags));

	return (errs);
}

struct bgp_msg *
session_newmsg(enum msg_type msgtype, u_int16_t len)
{
	struct bgp_msg		*msg;
	struct msg_header	 hdr;
	struct ibuf		*buf;
	int			 errs = 0;

	memset(&hdr.marker, 0xff, sizeof(hdr.marker));
	hdr.len = htons(len);
	hdr.type = msgtype;

	if ((buf = ibuf_open(len)) == NULL)
		return (NULL);

	errs += ibuf_add(buf, &hdr.marker, sizeof(hdr.marker));
	errs += ibuf_add(buf, &hdr.len, sizeof(hdr.len));
	errs += ibuf_add(buf, &hdr.type, sizeof(hdr.type));

	if (errs || (msg = calloc(1, sizeof(*msg))) == NULL) {
		ibuf_free(buf);
		return (NULL);
	}

	msg->buf = buf;
	msg->type = msgtype;
	msg->len = len;

	return (msg);
}

int
session_sendmsg(struct bgp_msg *msg, struct peer *p)
{
	struct mrt		*mrt;

	LIST_FOREACH(mrt, &mrthead, entry) {
		if (!(mrt->type == MRT_ALL_OUT || (msg->type == UPDATE &&
		    mrt->type == MRT_UPDATE_OUT)))
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == p->conf.id || (mrt->group_id != 0 &&
		    mrt->group_id == p->conf.groupid))
			mrt_dump_bgp_msg(mrt, msg->buf->buf, msg->len, p);
	}

	ibuf_close(&p->wbuf, msg->buf);
	if (!p->throttled && p->wbuf.queued > SESS_MSG_HIGH_MARK) {
		if (imsg_compose(ibuf_rde, IMSG_XOFF, p->conf.id, 0, -1,
		    NULL, 0) == -1)
			log_peer_warn(&p->conf, "imsg_compose XOFF");
		p->throttled = 1;
	}

	free(msg);
	return (0);
}

void
session_open(struct peer *p)
{
	struct bgp_msg		*buf;
	struct ibuf		*opb;
	struct msg_open		 msg;
	u_int16_t		 len;
	u_int8_t		 i, op_type, optparamlen = 0;
	int			 errs = 0;
	int			 mpcapa = 0;


	if ((opb = ibuf_dynamic(0, UCHAR_MAX - sizeof(op_type) -
	    sizeof(optparamlen))) == NULL) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	/* multiprotocol extensions, RFC 4760 */
	for (i = 0; i < AID_MAX; i++)
		if (p->capa.ann.mp[i]) {	/* 4 bytes data */
			errs += session_capa_add(opb, CAPA_MP, 4);
			errs += session_capa_add_mp(opb, i);
			mpcapa++;
		}

	/* route refresh, RFC 2918 */
	if (p->capa.ann.refresh)	/* no data */
		errs += session_capa_add(opb, CAPA_REFRESH, 0);

	/* graceful restart and End-of-RIB marker, RFC 4724 */
	if (p->capa.ann.grestart.restart) {
		int		rst = 0;
		u_int16_t	hdr;
		u_int8_t	grlen;

		if (mpcapa) {
			grlen = 2 + 4 * mpcapa;
			for (i = 0; i < AID_MAX; i++) {
				if (p->capa.neg.grestart.flags[i] &
				    CAPA_GR_RESTARTING)
					rst++;
			}
		} else {	/* AID_INET */
			grlen = 2 + 4;
			if (p->capa.neg.grestart.flags[AID_INET] &
			    CAPA_GR_RESTARTING)
				rst++;
		}

		hdr = conf->holdtime;		/* default timeout */
		/* if client does graceful restart don't set R flag */
		if (!rst)
			hdr |= CAPA_GR_R_FLAG;
		hdr = htons(hdr);

		errs += session_capa_add(opb, CAPA_RESTART, grlen);
		errs += ibuf_add(opb, &hdr, sizeof(hdr));

		if (mpcapa) {
			for (i = 0; i < AID_MAX; i++) {
				if (p->capa.ann.mp[i]) {
					errs += session_capa_add_gr(p, opb, i);
				}
			}
		} else {	/* AID_INET */
			errs += session_capa_add_gr(p, opb, AID_INET);
		}
	}

	/* 4-bytes AS numbers, draft-ietf-idr-as4bytes-13 */
	if (p->capa.ann.as4byte) {	/* 4 bytes data */
		u_int32_t	nas;

		nas = htonl(p->conf.local_as);
		errs += session_capa_add(opb, CAPA_AS4BYTE, sizeof(nas));
		errs += ibuf_add(opb, &nas, sizeof(nas));
	}

	if (ibuf_size(opb))
		optparamlen = ibuf_size(opb) + sizeof(op_type) +
		    sizeof(optparamlen);

	len = MSGSIZE_OPEN_MIN + optparamlen;
	if (errs || (buf = session_newmsg(OPEN, len)) == NULL) {
		ibuf_free(opb);
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	msg.version = 4;
	msg.myas = htons(p->conf.local_short_as);
	if (p->conf.holdtime)
		msg.holdtime = htons(p->conf.holdtime);
	else
		msg.holdtime = htons(conf->holdtime);
	msg.bgpid = conf->bgpid;	/* is already in network byte order */
	msg.optparamlen = optparamlen;

	errs += ibuf_add(buf->buf, &msg.version, sizeof(msg.version));
	errs += ibuf_add(buf->buf, &msg.myas, sizeof(msg.myas));
	errs += ibuf_add(buf->buf, &msg.holdtime, sizeof(msg.holdtime));
	errs += ibuf_add(buf->buf, &msg.bgpid, sizeof(msg.bgpid));
	errs += ibuf_add(buf->buf, &msg.optparamlen, sizeof(msg.optparamlen));

	if (optparamlen) {
		op_type = OPT_PARAM_CAPABILITIES;
		optparamlen = ibuf_size(opb);
		errs += ibuf_add(buf->buf, &op_type, sizeof(op_type));
		errs += ibuf_add(buf->buf, &optparamlen, sizeof(optparamlen));
		errs += ibuf_add(buf->buf, opb->buf, ibuf_size(opb));
	}

	ibuf_free(opb);

	if (errs) {
		ibuf_free(buf->buf);
		free(buf);
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	if (session_sendmsg(buf, p) == -1) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	p->stats.msg_sent_open++;
}

void
session_keepalive(struct peer *p)
{
	struct bgp_msg		*buf;

	if ((buf = session_newmsg(KEEPALIVE, MSGSIZE_KEEPALIVE)) == NULL ||
	    session_sendmsg(buf, p) == -1) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	start_timer_keepalive(p);
	p->stats.msg_sent_keepalive++;
}

void
session_update(u_int32_t peerid, void *data, size_t datalen)
{
	struct peer		*p;
	struct bgp_msg		*buf;

	if ((p = getpeerbyid(peerid)) == NULL) {
		log_warnx("no such peer: id=%u", peerid);
		return;
	}

	if (p->state != STATE_ESTABLISHED)
		return;

	if ((buf = session_newmsg(UPDATE, MSGSIZE_HEADER + datalen)) == NULL) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	if (ibuf_add(buf->buf, data, datalen)) {
		ibuf_free(buf->buf);
		free(buf);
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	if (session_sendmsg(buf, p) == -1) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	start_timer_keepalive(p);
	p->stats.msg_sent_update++;
}

void
session_notification(struct peer *p, u_int8_t errcode, u_int8_t subcode,
    void *data, ssize_t datalen)
{
	struct bgp_msg		*buf;
	int			 errs = 0;

	if (p->stats.last_sent_errcode)	/* some notification already sent */
		return;

	log_notification(p, errcode, subcode, data, datalen, "sending");

	if ((buf = session_newmsg(NOTIFICATION,
	    MSGSIZE_NOTIFICATION_MIN + datalen)) == NULL) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	errs += ibuf_add(buf->buf, &errcode, sizeof(errcode));
	errs += ibuf_add(buf->buf, &subcode, sizeof(subcode));

	if (datalen > 0)
		errs += ibuf_add(buf->buf, data, datalen);

	if (errs) {
		ibuf_free(buf->buf);
		free(buf);
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	if (session_sendmsg(buf, p) == -1) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	p->stats.msg_sent_notification++;
	p->stats.last_sent_errcode = errcode;
	p->stats.last_sent_suberr = subcode;
}

int
session_neighbor_rrefresh(struct peer *p)
{
	u_int8_t	i;

	if (!p->capa.peer.refresh)
		return (-1);

	for (i = 0; i < AID_MAX; i++) {
		if (p->capa.peer.mp[i] != 0)
			session_rrefresh(p, i);
	}

	return (0);
}

void
session_rrefresh(struct peer *p, u_int8_t aid)
{
	struct bgp_msg		*buf;
	int			 errs = 0;
	u_int16_t		 afi;
	u_int8_t		 safi, null8 = 0;

	if (aid2afi(aid, &afi, &safi) == -1)
		fatalx("session_rrefresh: bad afi/safi pair");

	if ((buf = session_newmsg(RREFRESH, MSGSIZE_RREFRESH)) == NULL) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	afi = htons(afi);
	errs += ibuf_add(buf->buf, &afi, sizeof(afi));
	errs += ibuf_add(buf->buf, &null8, sizeof(null8));
	errs += ibuf_add(buf->buf, &safi, sizeof(safi));

	if (errs) {
		ibuf_free(buf->buf);
		free(buf);
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	if (session_sendmsg(buf, p) == -1) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}

	p->stats.msg_sent_rrefresh++;
}

int
session_graceful_restart(struct peer *p)
{
	u_int8_t	i;

	timer_set(p, Timer_RestartTimeout, p->capa.neg.grestart.timeout);

	for (i = 0; i < AID_MAX; i++) {
		if (p->capa.neg.grestart.flags[i] & CAPA_GR_PRESENT) {
			if (imsg_compose(ibuf_rde, IMSG_SESSION_STALE,
			    p->conf.id, 0, -1, &i, sizeof(i)) == -1)
				return (-1);
			log_peer_warnx(&p->conf,
			    "graceful restart of %s, keeping routes",
			    aid2str(i));
			p->capa.neg.grestart.flags[i] |= CAPA_GR_RESTARTING;
		} else if (p->capa.neg.mp[i]) {
			if (imsg_compose(ibuf_rde, IMSG_SESSION_FLUSH,
			    p->conf.id, 0, -1, &i, sizeof(i)) == -1)
				return (-1);
			log_peer_warnx(&p->conf,
			    "graceful restart of %s, flushing routes",
			    aid2str(i));
		}
	}
	return (0);
}

int
session_graceful_stop(struct peer *p)
{
	u_int8_t	i;

	for (i = 0; i < AID_MAX; i++) {
		/*
		 * Only flush if the peer is restarting and the timeout fired.
		 * In all other cases the session was already flushed when the
		 * session went down or when the new open message was parsed.
		 */
		if (p->capa.neg.grestart.flags[i] & CAPA_GR_RESTARTING) {
			log_peer_warnx(&p->conf, "graceful restart of %s, "
			    "time-out, flushing", aid2str(i));
			if (imsg_compose(ibuf_rde, IMSG_SESSION_FLUSH,
			    p->conf.id, 0, -1, &i, sizeof(i)) == -1)
				return (-1);
		}
		p->capa.neg.grestart.flags[i] &= ~CAPA_GR_RESTARTING;
	}
	return (0);
}

int
session_dispatch_msg(struct pollfd *pfd, struct peer *p)
{
	ssize_t		n;
	socklen_t	len;
	int		error;

	if (p->state == STATE_CONNECT) {
		if (pfd->revents & POLLOUT) {
			if (pfd->revents & POLLIN) {
				/* error occurred */
				len = sizeof(error);
				if (getsockopt(pfd->fd, SOL_SOCKET, SO_ERROR,
				    &error, &len) == -1 || error) {
					if (error)
						errno = error;
					if (errno != p->lasterr) {
						log_peer_warn(&p->conf,
						    "socket error");
						p->lasterr = errno;
					}
					bgp_fsm(p, EVNT_CON_OPENFAIL);
					return (1);
				}
			}
			bgp_fsm(p, EVNT_CON_OPEN);
			return (1);
		}
		if (pfd->revents & POLLHUP) {
			bgp_fsm(p, EVNT_CON_OPENFAIL);
			return (1);
		}
		if (pfd->revents & (POLLERR|POLLNVAL)) {
			bgp_fsm(p, EVNT_CON_FATAL);
			return (1);
		}
		return (0);
	}

	if (pfd->revents & POLLHUP) {
		bgp_fsm(p, EVNT_CON_CLOSED);
		return (1);
	}
	if (pfd->revents & (POLLERR|POLLNVAL)) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return (1);
	}

	if (pfd->revents & POLLOUT && p->wbuf.queued) {
		if ((error = msgbuf_write(&p->wbuf)) <= 0 && errno != EAGAIN) {
			if (error == 0)
				log_peer_warnx(&p->conf, "Connection closed");
			else if (error == -1)
				log_peer_warn(&p->conf, "write error");
			bgp_fsm(p, EVNT_CON_FATAL);
			return (1);
		}
		if (p->throttled && p->wbuf.queued < SESS_MSG_LOW_MARK) {
			if (imsg_compose(ibuf_rde, IMSG_XON, p->conf.id, 0, -1,
			    NULL, 0) == -1)
				log_peer_warn(&p->conf, "imsg_compose XON");
			p->throttled = 0;
		}
		if (!(pfd->revents & POLLIN))
			return (1);
	}

	if (p->rbuf && pfd->revents & POLLIN) {
		if ((n = read(p->fd, p->rbuf->buf + p->rbuf->wpos,
		    sizeof(p->rbuf->buf) - p->rbuf->wpos)) == -1) {
			if (errno != EINTR && errno != EAGAIN) {
				log_peer_warn(&p->conf, "read error");
				bgp_fsm(p, EVNT_CON_FATAL);
			}
			return (1);
		}
		if (n == 0) {	/* connection closed */
			bgp_fsm(p, EVNT_CON_CLOSED);
			return (1);
		}

		p->rbuf->wpos += n;
		p->stats.last_read = time(NULL);
		return (1);
	}
	return (0);
}

int
session_process_msg(struct peer *p)
{
	struct mrt	*mrt;
	ssize_t		rpos, av, left;
	int		processed = 0;
	u_int16_t	msglen;
	u_int8_t	msgtype;

	rpos = 0;
	av = p->rbuf->wpos;

	/*
	 * session might drop to IDLE -> buffers deallocated
	 * we MUST check rbuf != NULL before use
	 */
	for (;;) {
		if (rpos + MSGSIZE_HEADER > av)
			break;
		if (p->rbuf == NULL)
			break;
		if (parse_header(p, p->rbuf->buf + rpos, &msglen,
		    &msgtype) == -1)
			return (0);
		if (rpos + msglen > av)
			break;
		p->rbuf->rptr = p->rbuf->buf + rpos;

		/* dump to MRT as soon as we have a full packet */
		LIST_FOREACH(mrt, &mrthead, entry) {
			if (!(mrt->type == MRT_ALL_IN || (msgtype == UPDATE &&
			    mrt->type == MRT_UPDATE_IN)))
				continue;
			if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
			    mrt->peer_id == p->conf.id || (mrt->group_id != 0 &&
			    mrt->group_id == p->conf.groupid))
				mrt_dump_bgp_msg(mrt, p->rbuf->rptr, msglen, p);
		}

		switch (msgtype) {
		case OPEN:
			bgp_fsm(p, EVNT_RCVD_OPEN);
			p->stats.msg_rcvd_open++;
			break;
		case UPDATE:
			bgp_fsm(p, EVNT_RCVD_UPDATE);
			p->stats.msg_rcvd_update++;
			break;
		case NOTIFICATION:
			bgp_fsm(p, EVNT_RCVD_NOTIFICATION);
			p->stats.msg_rcvd_notification++;
			break;
		case KEEPALIVE:
			bgp_fsm(p, EVNT_RCVD_KEEPALIVE);
			p->stats.msg_rcvd_keepalive++;
			break;
		case RREFRESH:
			parse_refresh(p);
			p->stats.msg_rcvd_rrefresh++;
			break;
		default:	/* cannot happen */
			session_notification(p, ERR_HEADER, ERR_HDR_TYPE,
			    &msgtype, 1);
			log_warnx("received message with unknown type %u",
			    msgtype);
			bgp_fsm(p, EVNT_CON_FATAL);
		}
		rpos += msglen;
		if (++processed > MSG_PROCESS_LIMIT)
			break;
	}
	if (p->rbuf == NULL)
		return (1);

	if (rpos < av) {
		left = av - rpos;
		memmove(&p->rbuf->buf, p->rbuf->buf + rpos, left);
		p->rbuf->wpos = left;
	} else
		p->rbuf->wpos = 0;

	return (1);
}

int
parse_header(struct peer *peer, u_char *data, u_int16_t *len, u_int8_t *type)
{
	u_char			*p;
	u_int16_t		 olen;
	static const u_int8_t	 marker[MSGSIZE_HEADER_MARKER] = { 0xff, 0xff,
				    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

	/* caller MUST make sure we are getting 19 bytes! */
	p = data;
	if (memcmp(p, marker, sizeof(marker))) {
		log_peer_warnx(&peer->conf, "sync error");
		session_notification(peer, ERR_HEADER, ERR_HDR_SYNC, NULL, 0);
		bgp_fsm(peer, EVNT_CON_FATAL);
		return (-1);
	}
	p += MSGSIZE_HEADER_MARKER;

	memcpy(&olen, p, 2);
	*len = ntohs(olen);
	p += 2;
	memcpy(type, p, 1);

	if (*len < MSGSIZE_HEADER || *len > MAX_PKTSIZE) {
		log_peer_warnx(&peer->conf,
		    "received message: illegal length: %u byte", *len);
		session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
		    &olen, sizeof(olen));
		bgp_fsm(peer, EVNT_CON_FATAL);
		return (-1);
	}

	switch (*type) {
	case OPEN:
		if (*len < MSGSIZE_OPEN_MIN) {
			log_peer_warnx(&peer->conf,
			    "received OPEN: illegal len: %u byte", *len);
			session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
			    &olen, sizeof(olen));
			bgp_fsm(peer, EVNT_CON_FATAL);
			return (-1);
		}
		break;
	case NOTIFICATION:
		if (*len < MSGSIZE_NOTIFICATION_MIN) {
			log_peer_warnx(&peer->conf,
			    "received NOTIFICATION: illegal len: %u byte",
			    *len);
			session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
			    &olen, sizeof(olen));
			bgp_fsm(peer, EVNT_CON_FATAL);
			return (-1);
		}
		break;
	case UPDATE:
		if (*len < MSGSIZE_UPDATE_MIN) {
			log_peer_warnx(&peer->conf,
			    "received UPDATE: illegal len: %u byte", *len);
			session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
			    &olen, sizeof(olen));
			bgp_fsm(peer, EVNT_CON_FATAL);
			return (-1);
		}
		break;
	case KEEPALIVE:
		if (*len != MSGSIZE_KEEPALIVE) {
			log_peer_warnx(&peer->conf,
			    "received KEEPALIVE: illegal len: %u byte", *len);
			session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
			    &olen, sizeof(olen));
			bgp_fsm(peer, EVNT_CON_FATAL);
			return (-1);
		}
		break;
	case RREFRESH:
		if (*len != MSGSIZE_RREFRESH) {
			log_peer_warnx(&peer->conf,
			    "received RREFRESH: illegal len: %u byte", *len);
			session_notification(peer, ERR_HEADER, ERR_HDR_LEN,
			    &olen, sizeof(olen));
			bgp_fsm(peer, EVNT_CON_FATAL);
			return (-1);
		}
		break;
	default:
		log_peer_warnx(&peer->conf,
		    "received msg with unknown type %u", *type);
		session_notification(peer, ERR_HEADER, ERR_HDR_TYPE,
		    type, 1);
		bgp_fsm(peer, EVNT_CON_FATAL);
		return (-1);
	}
	return (0);
}

int
parse_open(struct peer *peer)
{
	u_char		*p, *op_val;
	u_int8_t	 version, rversion;
	u_int16_t	 short_as, msglen;
	u_int16_t	 holdtime, oholdtime, myholdtime;
	u_int32_t	 as, bgpid;
	u_int8_t	 optparamlen, plen;
	u_int8_t	 op_type, op_len;

	p = peer->rbuf->rptr;
	p += MSGSIZE_HEADER_MARKER;
	memcpy(&msglen, p, sizeof(msglen));
	msglen = ntohs(msglen);

	p = peer->rbuf->rptr;
	p += MSGSIZE_HEADER;	/* header is already checked */

	memcpy(&version, p, sizeof(version));
	p += sizeof(version);

	if (version != BGP_VERSION) {
		log_peer_warnx(&peer->conf,
		    "peer wants unrecognized version %u", version);
		if (version > BGP_VERSION)
			rversion = version - BGP_VERSION;
		else
			rversion = BGP_VERSION;
		session_notification(peer, ERR_OPEN, ERR_OPEN_VERSION,
		    &rversion, sizeof(rversion));
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
		return (-1);
	}

	memcpy(&short_as, p, sizeof(short_as));
	p += sizeof(short_as);
	as = peer->short_as = ntohs(short_as);
	if (as == 0) {
		log_peer_warnx(&peer->conf,
		    "peer requests unacceptable AS %u", as);
		session_notification(peer, ERR_OPEN, ERR_OPEN_AS,
		    NULL, 0);
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
		return (-1);
	}

	memcpy(&oholdtime, p, sizeof(oholdtime));
	p += sizeof(oholdtime);

	holdtime = ntohs(oholdtime);
	if (holdtime && holdtime < peer->conf.min_holdtime) {
		log_peer_warnx(&peer->conf,
		    "peer requests unacceptable holdtime %u", holdtime);
		session_notification(peer, ERR_OPEN, ERR_OPEN_HOLDTIME,
		    NULL, 0);
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
		return (-1);
	}

	myholdtime = peer->conf.holdtime;
	if (!myholdtime)
		myholdtime = conf->holdtime;
	if (holdtime < myholdtime)
		peer->holdtime = holdtime;
	else
		peer->holdtime = myholdtime;

	memcpy(&bgpid, p, sizeof(bgpid));
	p += sizeof(bgpid);

	/* check bgpid for validity - just disallow 0 */
	if (ntohl(bgpid) == 0) {
		log_peer_warnx(&peer->conf, "peer BGPID %u unacceptable",
		    ntohl(bgpid));
		session_notification(peer, ERR_OPEN, ERR_OPEN_BGPID,
		    NULL, 0);
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
		return (-1);
	}
	peer->remote_bgpid = bgpid;

	memcpy(&optparamlen, p, sizeof(optparamlen));
	p += sizeof(optparamlen);

	if (optparamlen != msglen - MSGSIZE_OPEN_MIN) {
			log_peer_warnx(&peer->conf,
			    "corrupt OPEN message received: length mismatch");
			session_notification(peer, ERR_OPEN, 0, NULL, 0);
			change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
			return (-1);
	}

	plen = optparamlen;
	while (plen > 0) {
		if (plen < 2) {
			log_peer_warnx(&peer->conf,
			    "corrupt OPEN message received, len wrong");
			session_notification(peer, ERR_OPEN, 0, NULL, 0);
			change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
			return (-1);
		}
		memcpy(&op_type, p, sizeof(op_type));
		p += sizeof(op_type);
		plen -= sizeof(op_type);
		memcpy(&op_len, p, sizeof(op_len));
		p += sizeof(op_len);
		plen -= sizeof(op_len);
		if (op_len > 0) {
			if (plen < op_len) {
				log_peer_warnx(&peer->conf,
				    "corrupt OPEN message received, len wrong");
				session_notification(peer, ERR_OPEN, 0,
				    NULL, 0);
				change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
				return (-1);
			}
			op_val = p;
			p += op_len;
			plen -= op_len;
		} else
			op_val = NULL;

		switch (op_type) {
		case OPT_PARAM_CAPABILITIES:		/* RFC 3392 */
			if (parse_capabilities(peer, op_val, op_len,
			    &as) == -1) {
				session_notification(peer, ERR_OPEN, 0,
				    NULL, 0);
				change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
				return (-1);
			}
			break;
		case OPT_PARAM_AUTH:			/* deprecated */
		default:
			/*
			 * unsupported type
			 * the RFCs tell us to leave the data section empty
			 * and notify the peer with ERR_OPEN, ERR_OPEN_OPT.
			 * How the peer should know _which_ optional parameter
			 * we don't support is beyond me.
			 */
			log_peer_warnx(&peer->conf,
			    "received OPEN message with unsupported optional "
			    "parameter: type %u", op_type);
			session_notification(peer, ERR_OPEN, ERR_OPEN_OPT,
				NULL, 0);
			change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
			timer_set(peer, Timer_IdleHold, 0);	/* no punish */
			peer->IdleHoldTime /= 2;
			return (-1);
		}
	}

	/* if remote-as is zero and it's a cloned neighbor, accept any */
	if (peer->template && !peer->conf.remote_as && as != AS_TRANS) {
		peer->conf.remote_as = as;
		peer->conf.ebgp = (peer->conf.remote_as != peer->conf.local_as);
		if (!peer->conf.ebgp)
			/* force enforce_as off for iBGP sessions */
			peer->conf.enforce_as = ENFORCE_AS_OFF;
	}

	if (peer->conf.remote_as != as) {
		log_peer_warnx(&peer->conf, "peer sent wrong AS %s",
		    log_as(as));
		session_notification(peer, ERR_OPEN, ERR_OPEN_AS, NULL, 0);
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
		return (-1);
	}

	if (capa_neg_calc(peer) == -1) {
		log_peer_warnx(&peer->conf,
		    "capability negotiation calculation failed");
		session_notification(peer, ERR_OPEN, 0, NULL, 0);
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
		return (-1);
	}

	return (0);
}

int
parse_update(struct peer *peer)
{
	u_char		*p;
	u_int16_t	 datalen;

	/*
	 * we pass the message verbatim to the rde.
	 * in case of errors the whole session is reset with a
	 * notification anyway, we only need to know the peer
	 */
	p = peer->rbuf->rptr;
	p += MSGSIZE_HEADER_MARKER;
	memcpy(&datalen, p, sizeof(datalen));
	datalen = ntohs(datalen);

	p = peer->rbuf->rptr;
	p += MSGSIZE_HEADER;	/* header is already checked */
	datalen -= MSGSIZE_HEADER;

	if (imsg_compose(ibuf_rde, IMSG_UPDATE, peer->conf.id, 0, -1, p,
	    datalen) == -1)
		return (-1);

	return (0);
}

int
parse_refresh(struct peer *peer)
{
	u_char		*p;
	u_int16_t	 afi;
	u_int8_t	 aid, safi;

	p = peer->rbuf->rptr;
	p += MSGSIZE_HEADER;	/* header is already checked */

	/*
	 * We could check if we actually announced the capability but
	 * as long as the message is correctly encoded we don't care.
	 */

	/* afi, 2 byte */
	memcpy(&afi, p, sizeof(afi));
	afi = ntohs(afi);
	p += 2;
	/* reserved, 1 byte */
	p += 1;
	/* safi, 1 byte */
	memcpy(&safi, p, sizeof(safi));

	/* afi/safi unchecked -	unrecognized values will be ignored anyway */
	if (afi2aid(afi, safi, &aid) == -1) {
		log_peer_warnx(&peer->conf, "peer sent bad refresh, "
		    "invalid afi/safi pair");
		return (0);
	}

	if (imsg_compose(ibuf_rde, IMSG_REFRESH, peer->conf.id, 0, -1, &aid,
	    sizeof(aid)) == -1)
		return (-1);

	return (0);
}

int
parse_notification(struct peer *peer)
{
	u_char		*p;
	u_int16_t	 datalen;
	u_int8_t	 errcode;
	u_int8_t	 subcode;
	u_int8_t	 capa_code;
	u_int8_t	 capa_len;
	u_int8_t	 shutcomm_len;
	u_int8_t	 i;

	/* just log */
	p = peer->rbuf->rptr;
	p += MSGSIZE_HEADER_MARKER;
	memcpy(&datalen, p, sizeof(datalen));
	datalen = ntohs(datalen);

	p = peer->rbuf->rptr;
	p += MSGSIZE_HEADER;	/* header is already checked */
	datalen -= MSGSIZE_HEADER;

	memcpy(&errcode, p, sizeof(errcode));
	p += sizeof(errcode);
	datalen -= sizeof(errcode);

	memcpy(&subcode, p, sizeof(subcode));
	p += sizeof(subcode);
	datalen -= sizeof(subcode);

	log_notification(peer, errcode, subcode, p, datalen, "received");
	peer->errcnt++;

	if (errcode == ERR_OPEN && subcode == ERR_OPEN_CAPA) {
		if (datalen == 0) {	/* zebra likes to send those.. humbug */
			log_peer_warnx(&peer->conf, "received \"unsupported "
			    "capability\" notification without data part, "
			    "disabling capability announcements altogether");
			session_capa_ann_none(peer);
		}

		while (datalen > 0) {
			if (datalen < 2) {
				log_peer_warnx(&peer->conf,
				    "parse_notification: "
				    "expect len >= 2, len is %u", datalen);
				return (-1);
			}
			memcpy(&capa_code, p, sizeof(capa_code));
			p += sizeof(capa_code);
			datalen -= sizeof(capa_code);
			memcpy(&capa_len, p, sizeof(capa_len));
			p += sizeof(capa_len);
			datalen -= sizeof(capa_len);
			if (datalen < capa_len) {
				log_peer_warnx(&peer->conf,
				    "parse_notification: capa_len %u exceeds "
				    "remaining msg length %u", capa_len,
				    datalen);
				return (-1);
			}
			p += capa_len;
			datalen -= capa_len;
			switch (capa_code) {
			case CAPA_MP:
				for (i = 0; i < AID_MAX; i++)
					peer->capa.ann.mp[i] = 0;
				log_peer_warnx(&peer->conf,
				    "disabling multiprotocol capability");
				break;
			case CAPA_REFRESH:
				peer->capa.ann.refresh = 0;
				log_peer_warnx(&peer->conf,
				    "disabling route refresh capability");
				break;
			case CAPA_RESTART:
				peer->capa.ann.grestart.restart = 0;
				log_peer_warnx(&peer->conf,
				    "disabling restart capability");
				break;
			case CAPA_AS4BYTE:
				peer->capa.ann.as4byte = 0;
				log_peer_warnx(&peer->conf,
				    "disabling 4-byte AS num capability");
				break;
			default:	/* should not happen... */
				log_peer_warnx(&peer->conf, "received "
				    "\"unsupported capability\" notification "
				    "for unknown capability %u, disabling "
				    "capability announcements altogether",
				    capa_code);
				session_capa_ann_none(peer);
				break;
			}
		}

		return (1);
	}

	if (errcode == ERR_OPEN && subcode == ERR_OPEN_OPT) {
		session_capa_ann_none(peer);
		return (1);
	}

	if (errcode == ERR_CEASE &&
	    (subcode == ERR_CEASE_ADMIN_DOWN ||
	     subcode == ERR_CEASE_ADMIN_RESET)) {
		if (datalen >= sizeof(shutcomm_len)) {
			memcpy(&shutcomm_len, p, sizeof(shutcomm_len));
			p += sizeof(shutcomm_len);
			datalen -= sizeof(shutcomm_len);
			if(datalen < shutcomm_len) {
			    log_peer_warnx(&peer->conf,
				"received truncated shutdown reason");
			    return (0);
			}
			if (shutcomm_len > (SHUT_COMM_LEN-1)) {
			    log_peer_warnx(&peer->conf,
				"received overly long shutdown reason");
			    return (0);
			}
			memcpy(peer->stats.last_shutcomm, p, shutcomm_len);
			peer->stats.last_shutcomm[shutcomm_len] = '\0';
			log_peer_warnx(&peer->conf,
			    "received shutdown reason: \"%s\"",
			    log_shutcomm(peer->stats.last_shutcomm));
			p += shutcomm_len;
			datalen -= shutcomm_len;
		}
	}

	return (0);
}

int
parse_capabilities(struct peer *peer, u_char *d, u_int16_t dlen, u_int32_t *as)
{
	u_char		*capa_val;
	u_int32_t	 remote_as;
	u_int16_t	 len;
	u_int16_t	 afi;
	u_int16_t	 gr_header;
	u_int8_t	 safi;
	u_int8_t	 aid;
	u_int8_t	 gr_flags;
	u_int8_t	 capa_code;
	u_int8_t	 capa_len;
	u_int8_t	 i;

	len = dlen;
	while (len > 0) {
		if (len < 2) {
			log_peer_warnx(&peer->conf, "Bad capabilities attr "
			    "length: %u, too short", len);
			return (-1);
		}
		memcpy(&capa_code, d, sizeof(capa_code));
		d += sizeof(capa_code);
		len -= sizeof(capa_code);
		memcpy(&capa_len, d, sizeof(capa_len));
		d += sizeof(capa_len);
		len -= sizeof(capa_len);
		if (capa_len > 0) {
			if (len < capa_len) {
				log_peer_warnx(&peer->conf,
				    "Bad capabilities attr length: "
				    "len %u smaller than capa_len %u",
				    len, capa_len);
				return (-1);
			}
			capa_val = d;
			d += capa_len;
			len -= capa_len;
		} else
			capa_val = NULL;

		switch (capa_code) {
		case CAPA_MP:			/* RFC 4760 */
			if (capa_len != 4) {
				log_peer_warnx(&peer->conf,
				    "Bad multi protocol capability length: "
				    "%u", capa_len);
				break;
			}
			memcpy(&afi, capa_val, sizeof(afi));
			afi = ntohs(afi);
			memcpy(&safi, capa_val + 3, sizeof(safi));
			if (afi2aid(afi, safi, &aid) == -1) {
				log_peer_warnx(&peer->conf,
				    "Received multi protocol capability: "
				    " unknown AFI %u, safi %u pair",
				    afi, safi);
				break;
			}
			peer->capa.peer.mp[aid] = 1;
			break;
		case CAPA_REFRESH:
			peer->capa.peer.refresh = 1;
			break;
		case CAPA_RESTART:
			if (capa_len == 2) {
				/* peer only supports EoR marker */
				peer->capa.peer.grestart.restart = 1;
				peer->capa.peer.grestart.timeout = 0;
				break;
			} else if (capa_len % 4 != 2) {
				log_peer_warnx(&peer->conf,
				    "Bad graceful restart capability length: "
				    "%u", capa_len);
				peer->capa.peer.grestart.restart = 0;
				peer->capa.peer.grestart.timeout = 0;
				break;
			}

			memcpy(&gr_header, capa_val, sizeof(gr_header));
			gr_header = ntohs(gr_header);
			peer->capa.peer.grestart.timeout =
			    gr_header & CAPA_GR_TIMEMASK;
			if (peer->capa.peer.grestart.timeout == 0) {
				log_peer_warnx(&peer->conf, "Received "
				    "graceful restart timeout is zero");
				peer->capa.peer.grestart.restart = 0;
				break;
			}

			for (i = 2; i <= capa_len - 4; i += 4) {
				memcpy(&afi, capa_val + i, sizeof(afi));
				afi = ntohs(afi);
				memcpy(&safi, capa_val + i + 2, sizeof(safi));
				if (afi2aid(afi, safi, &aid) == -1) {
					log_peer_warnx(&peer->conf,
					    "Received graceful restart capa: "
					    " unknown AFI %u, safi %u pair",
					    afi, safi);
					continue;
				}
				memcpy(&gr_flags, capa_val + i + 3,
				    sizeof(gr_flags));
				peer->capa.peer.grestart.flags[aid] |=
				    CAPA_GR_PRESENT;
				if (gr_flags & CAPA_GR_F_FLAG)
					peer->capa.peer.grestart.flags[aid] |=
					    CAPA_GR_FORWARD;
				if (gr_header & CAPA_GR_R_FLAG)
					peer->capa.peer.grestart.flags[aid] |=
					    CAPA_GR_RESTART;
				peer->capa.peer.grestart.restart = 2;
			}
			break;
		case CAPA_AS4BYTE:
			if (capa_len != 4) {
				log_peer_warnx(&peer->conf,
				    "Bad AS4BYTE capability length: "
				    "%u", capa_len);
				peer->capa.peer.as4byte = 0;
				break;
			}
			memcpy(&remote_as, capa_val, sizeof(remote_as));
			*as = ntohl(remote_as);
			if (*as == 0) {
				log_peer_warnx(&peer->conf,
				    "peer requests unacceptable AS %u", *as);
				session_notification(peer, ERR_OPEN, ERR_OPEN_AS,
				    NULL, 0);
				change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
				return (-1);
			}
			peer->capa.peer.as4byte = 1;
			break;
		default:
			break;
		}
	}

	return (0);
}

int
capa_neg_calc(struct peer *p)
{
	u_int8_t	i, hasmp = 0;

	/* refresh: does not realy matter here, use peer setting */
	p->capa.neg.refresh = p->capa.peer.refresh;

	/* as4byte: both side must announce capability */
	if (p->capa.ann.as4byte && p->capa.peer.as4byte)
		p->capa.neg.as4byte = 1;
	else
		p->capa.neg.as4byte = 0;

	/* MP: both side must announce capability */
	for (i = 0; i < AID_MAX; i++) {
		if (p->capa.ann.mp[i] && p->capa.peer.mp[i]) {
			p->capa.neg.mp[i] = 1;
			hasmp = 1;
		} else
			p->capa.neg.mp[i] = 0;
	}
	/* if no MP capability present default to IPv4 unicast mode */
	if (!hasmp)
		p->capa.neg.mp[AID_INET] = 1;

	/*
	 * graceful restart: only the peer capabilities are of interest here.
	 * It is necessary to compare the new values with the previous ones
	 * and act acordingly. AFI/SAFI that are not part in the MP capability
	 * are treated as not being present.
	 */

	for (i = 0; i < AID_MAX; i++) {
		int8_t	negflags;

		/* disable GR if the AFI/SAFI is not present */
		if (p->capa.peer.grestart.flags[i] & CAPA_GR_PRESENT &&
		    p->capa.neg.mp[i] == 0)
			p->capa.peer.grestart.flags[i] = 0;	/* disable */
		/* look at current GR state and decide what to do */
		negflags = p->capa.neg.grestart.flags[i];
		p->capa.neg.grestart.flags[i] = p->capa.peer.grestart.flags[i];
		if (negflags & CAPA_GR_RESTARTING) {
			if (!(p->capa.peer.grestart.flags[i] &
			    CAPA_GR_FORWARD)) {
				if (imsg_compose(ibuf_rde, IMSG_SESSION_FLUSH,
				    p->conf.id, 0, -1, &i, sizeof(i)) == -1)
					return (-1);
				log_peer_warnx(&p->conf, "graceful restart of "
				    "%s, not restarted, flushing", aid2str(i));
			} else
				p->capa.neg.grestart.flags[i] |=
				    CAPA_GR_RESTARTING;
		}
	}
	p->capa.neg.grestart.timeout = p->capa.peer.grestart.timeout;
	p->capa.neg.grestart.restart = p->capa.peer.grestart.restart;

	return (0);
}

void
session_dispatch_imsg(struct imsgbuf *ibuf, int idx, u_int *listener_cnt)
{
	struct imsg		 imsg;
	struct mrt		 xmrt;
	struct mrt		*mrt;
	struct imsgbuf		*i;
	struct peer_config	*pconf;
	struct peer		*p, *next;
	struct listen_addr	*la, *nla;
	struct kif		*kif;
	u_char			*data;
	enum reconf_action	 reconf;
	int			 n, fd, depend_ok, restricted;
	u_int8_t		 aid, errcode, subcode;

	while (ibuf) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("session_dispatch_imsg: imsg_get error");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_SOCKET_CONN:
		case IMSG_SOCKET_CONN_CTL:
			if (idx != PFD_PIPE_MAIN)
				fatalx("reconf request not from parent");
			if ((fd = imsg.fd) == -1) {
				log_warnx("expected to receive imsg fd to "
				    "RDE but didn't receive any");
				break;
			}
			if ((i = malloc(sizeof(struct imsgbuf))) == NULL)
				fatal(NULL);
			imsg_init(i, fd);
			if (imsg.hdr.type == IMSG_SOCKET_CONN) {
				if (ibuf_rde) {
					log_warnx("Unexpected imsg connection "
					    "to RDE received");
					msgbuf_clear(&ibuf_rde->w);
					free(ibuf_rde);
				}
				ibuf_rde = i;
			} else {
				if (ibuf_rde_ctl) {
					log_warnx("Unexpected imsg ctl "
					    "connection to RDE received");
					msgbuf_clear(&ibuf_rde_ctl->w);
					free(ibuf_rde_ctl);
				}
				ibuf_rde_ctl = i;
			}
			break;
		case IMSG_RECONF_CONF:
			if (idx != PFD_PIPE_MAIN)
				fatalx("reconf request not from parent");
			if ((nconf = malloc(sizeof(struct bgpd_config))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct bgpd_config));
			if ((nconf->listen_addrs = calloc(1,
			    sizeof(struct listen_addrs))) == NULL)
				fatal(NULL);
			TAILQ_INIT(nconf->listen_addrs);
			npeers = NULL;
			init_conf(nconf);
			pending_reconf = 1;
			break;
		case IMSG_RECONF_PEER:
			if (idx != PFD_PIPE_MAIN)
				fatalx("reconf request not from parent");
			pconf = imsg.data;
			p = getpeerbyaddr(&pconf->remote_addr);
			if (p == NULL) {
				if ((p = calloc(1, sizeof(struct peer))) ==
				    NULL)
					fatal("new_peer");
				p->state = p->prev_state = STATE_NONE;
				p->next = npeers;
				npeers = p;
				reconf = RECONF_REINIT;
			} else
				reconf = RECONF_KEEP;

			memcpy(&p->conf, pconf, sizeof(struct peer_config));
			p->conf.reconf_action = reconf;

			/* sync the RDE in case we keep the peer */
			if (reconf == RECONF_KEEP) {
				if (imsg_compose(ibuf_rde, IMSG_SESSION_ADD,
				    p->conf.id, 0, -1, &p->conf,
				    sizeof(struct peer_config)) == -1)
					fatalx("imsg_compose error");
				if (p->conf.template) {
					/* apply the conf to all clones */
					struct peer *np;
					for (np = peers; np; np = np->next) {
						if (np->template != p)
							continue;
						session_template_clone(np,
						    NULL, np->conf.id,
						    np->conf.remote_as);
						if (imsg_compose(ibuf_rde,
						    IMSG_SESSION_ADD,
						    np->conf.id, 0, -1,
						    &np->conf,
						    sizeof(struct peer_config))
						    == -1)
							fatalx("imsg_compose error");
					}
				}
			}
			break;
		case IMSG_RECONF_LISTENER:
			if (idx != PFD_PIPE_MAIN)
				fatalx("reconf request not from parent");
			if (nconf == NULL)
				fatalx("IMSG_RECONF_LISTENER but no config");
			nla = imsg.data;
			TAILQ_FOREACH(la, conf->listen_addrs, entry)
				if (!la_cmp(la, nla))
					break;

			if (la == NULL) {
				if (nla->reconf != RECONF_REINIT)
					fatalx("king bula sez: "
					    "expected REINIT");

				if ((nla->fd = imsg.fd) == -1)
					log_warnx("expected to receive fd for "
					    "%s but didn't receive any",
					    log_sockaddr((struct sockaddr *)
					    &nla->sa));

				la = calloc(1, sizeof(struct listen_addr));
				if (la == NULL)
					fatal(NULL);
				memcpy(&la->sa, &nla->sa, sizeof(la->sa));
				la->flags = nla->flags;
				la->fd = nla->fd;
				la->reconf = RECONF_REINIT;
				TAILQ_INSERT_TAIL(nconf->listen_addrs, la,
				    entry);
			} else {
				if (nla->reconf != RECONF_KEEP)
					fatalx("king bula sez: expected KEEP");
				la->reconf = RECONF_KEEP;
			}

			break;
		case IMSG_RECONF_CTRL:
			if (idx != PFD_PIPE_MAIN)
				fatalx("reconf request not from parent");
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(restricted))
				fatalx("IFINFO imsg with wrong len");
			memcpy(&restricted, imsg.data, sizeof(restricted));
			if (imsg.fd == -1) {
				log_warnx("expected to receive fd for control "
				    "socket but didn't receive any");
				break;
			}
			if (restricted) {
				control_shutdown(rcsock);
				rcsock = imsg.fd;
			} else {
				control_shutdown(csock);
				csock = imsg.fd;
			}
			break;
		case IMSG_RECONF_DONE:
			if (idx != PFD_PIPE_MAIN)
				fatalx("reconf request not from parent");
			if (nconf == NULL)
				fatalx("got IMSG_RECONF_DONE but no config");
			conf->flags = nconf->flags;
			conf->log = nconf->log;
			conf->bgpid = nconf->bgpid;
			conf->clusterid = nconf->clusterid;
			conf->as = nconf->as;
			conf->short_as = nconf->short_as;
			conf->holdtime = nconf->holdtime;
			conf->min_holdtime = nconf->min_holdtime;
			conf->connectretry = nconf->connectretry;

			/* add new peers */
			for (p = npeers; p != NULL; p = next) {
				next = p->next;
				p->next = peers;
				peers = p;
			}
			/* find ones that need attention */
			for (p = peers; p != NULL; p = p->next) {
				/* needs to be deleted? */
				if (p->conf.reconf_action == RECONF_NONE &&
				    !p->template)
					p->conf.reconf_action = RECONF_DELETE;
				/* had demotion, is demoted, demote removed? */
				if (p->demoted && !p->conf.demote_group[0])
						session_demote(p, -1);
			}

			/* delete old listeners */
			for (la = TAILQ_FIRST(conf->listen_addrs); la != NULL;
			    la = nla) {
				nla = TAILQ_NEXT(la, entry);
				if (la->reconf == RECONF_NONE) {
					log_info("not listening on %s any more",
					    log_sockaddr(
					    (struct sockaddr *)&la->sa));
					TAILQ_REMOVE(conf->listen_addrs, la,
					    entry);
					close(la->fd);
					free(la);
				}
			}

			/* add new listeners */
			while ((la = TAILQ_FIRST(nconf->listen_addrs)) !=
			    NULL) {
				TAILQ_REMOVE(nconf->listen_addrs, la, entry);
				TAILQ_INSERT_TAIL(conf->listen_addrs, la,
				    entry);
			}

			setup_listeners(listener_cnt);
			free(nconf->listen_addrs);
			free(nconf);
			nconf = NULL;
			pending_reconf = 0;
			log_info("SE reconfigured");
			imsg_compose(ibuf_main, IMSG_RECONF_DONE, 0, 0,
			    -1, NULL, 0);
			break;
		case IMSG_IFINFO:
			if (idx != PFD_PIPE_MAIN)
				fatalx("IFINFO message not from parent");
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct kif))
				fatalx("IFINFO imsg with wrong len");
			kif = imsg.data;
			depend_ok = session_link_state_is_up(kif->flags,
			    kif->if_type, kif->link_state);

			for (p = peers; p != NULL; p = p->next)
				if (!strcmp(p->conf.if_depend, kif->ifname)) {
					if (depend_ok && !p->depend_ok) {
						p->depend_ok = depend_ok;
						bgp_fsm(p, EVNT_START);
					} else if (!depend_ok && p->depend_ok) {
						p->depend_ok = depend_ok;
						session_stop(p,
						    ERR_CEASE_OTHER_CHANGE);
					}
				}
			break;
		case IMSG_MRT_OPEN:
		case IMSG_MRT_REOPEN:
			if (imsg.hdr.len > IMSG_HEADER_SIZE +
			    sizeof(struct mrt)) {
				log_warnx("wrong imsg len");
				break;
			}

			memcpy(&xmrt, imsg.data, sizeof(struct mrt));
			if ((xmrt.wbuf.fd = imsg.fd) == -1)
				log_warnx("expected to receive fd for mrt dump "
				    "but didn't receive any");

			mrt = mrt_get(&mrthead, &xmrt);
			if (mrt == NULL) {
				/* new dump */
				mrt = calloc(1, sizeof(struct mrt));
				if (mrt == NULL)
					fatal("session_dispatch_imsg");
				memcpy(mrt, &xmrt, sizeof(struct mrt));
				TAILQ_INIT(&mrt->wbuf.bufs);
				LIST_INSERT_HEAD(&mrthead, mrt, entry);
			} else {
				/* old dump reopened */
				close(mrt->wbuf.fd);
				mrt->wbuf.fd = xmrt.wbuf.fd;
			}
			break;
		case IMSG_MRT_CLOSE:
			if (imsg.hdr.len > IMSG_HEADER_SIZE +
			    sizeof(struct mrt)) {
				log_warnx("wrong imsg len");
				break;
			}

			memcpy(&xmrt, imsg.data, sizeof(struct mrt));
			mrt = mrt_get(&mrthead, &xmrt);
			if (mrt != NULL)
				mrt_done(mrt);
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_SHOW_NEXTHOP:
		case IMSG_CTL_SHOW_INTERFACE:
		case IMSG_CTL_SHOW_FIB_TABLES:
			if (idx != PFD_PIPE_MAIN)
				fatalx("ctl kroute request not from parent");
			control_imsg_relay(&imsg);
			break;
		case IMSG_CTL_SHOW_RIB:
		case IMSG_CTL_SHOW_RIB_PREFIX:
		case IMSG_CTL_SHOW_RIB_ATTR:
		case IMSG_CTL_SHOW_RIB_MEM:
		case IMSG_CTL_SHOW_NETWORK:
		case IMSG_CTL_SHOW_NEIGHBOR:
			if (idx != PFD_PIPE_ROUTE_CTL)
				fatalx("ctl rib request not from RDE");
			control_imsg_relay(&imsg);
			break;
		case IMSG_CTL_END:
		case IMSG_CTL_RESULT:
			control_imsg_relay(&imsg);
			break;
		case IMSG_UPDATE:
			if (idx != PFD_PIPE_ROUTE)
				fatalx("update request not from RDE");
			if (imsg.hdr.len > IMSG_HEADER_SIZE +
			    MAX_PKTSIZE - MSGSIZE_HEADER ||
			    imsg.hdr.len < IMSG_HEADER_SIZE +
			    MSGSIZE_UPDATE_MIN - MSGSIZE_HEADER)
				log_warnx("RDE sent invalid update");
			else
				session_update(imsg.hdr.peerid, imsg.data,
				    imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_UPDATE_ERR:
			if (idx != PFD_PIPE_ROUTE)
				fatalx("update request not from RDE");
			if (imsg.hdr.len < IMSG_HEADER_SIZE + 2) {
				log_warnx("RDE sent invalid notification");
				break;
			}
			if ((p = getpeerbyid(imsg.hdr.peerid)) == NULL) {
				log_warnx("no such peer: id=%u",
				    imsg.hdr.peerid);
				break;
			}
			data = imsg.data;
			errcode = *data++;
			subcode = *data++;

			if (imsg.hdr.len == IMSG_HEADER_SIZE + 2)
				data = NULL;

			session_notification(p, errcode, subcode,
			    data, imsg.hdr.len - IMSG_HEADER_SIZE - 2);
			switch (errcode) {
			case ERR_CEASE:
				switch (subcode) {
				case ERR_CEASE_MAX_PREFIX:
					bgp_fsm(p, EVNT_STOP);
					if (p->conf.max_prefix_restart)
						timer_set(p, Timer_IdleHold, 60 *
						    p->conf.max_prefix_restart);
					break;
				default:
					bgp_fsm(p, EVNT_CON_FATAL);
					break;
				}
				break;
			default:
				bgp_fsm(p, EVNT_CON_FATAL);
				break;
			}
			break;
		case IMSG_SESSION_RESTARTED:
			if (idx != PFD_PIPE_ROUTE)
				fatalx("update request not from RDE");
			if (imsg.hdr.len < IMSG_HEADER_SIZE + sizeof(aid)) {
				log_warnx("RDE sent invalid restart msg");
				break;
			}
			if ((p = getpeerbyid(imsg.hdr.peerid)) == NULL) {
				log_warnx("no such peer: id=%u",
				    imsg.hdr.peerid);
				break;
			}
			memcpy(&aid, imsg.data, sizeof(aid));
			if (aid >= AID_MAX)
				fatalx("IMSG_SESSION_RESTARTED: bad AID");
			if (p->capa.neg.grestart.flags[aid] &
			    CAPA_GR_RESTARTING) {
				log_peer_warnx(&p->conf,
				    "graceful restart of %s finished",
				    aid2str(aid));
				p->capa.neg.grestart.flags[aid] &=
				    ~CAPA_GR_RESTARTING;
				timer_stop(p, Timer_RestartTimeout);

				/* signal back to RDE to cleanup stale routes */
				if (imsg_compose(ibuf_rde,
				    IMSG_SESSION_RESTARTED, imsg.hdr.peerid, 0,
				    -1, &aid, sizeof(aid)) == -1)
					fatal("imsg_compose: "
					    "IMSG_SESSION_RESTARTED");
			}
			break;
		case IMSG_SESSION_DOWN:
			if (idx != PFD_PIPE_ROUTE)
				fatalx("update request not from RDE");
			if ((p = getpeerbyid(imsg.hdr.peerid)) == NULL) {
				log_warnx("no such peer: id=%u",
				    imsg.hdr.peerid);
				break;
			}
			session_stop(p, ERR_CEASE_ADMIN_DOWN);
			break;
		default:
			break;
		}
		imsg_free(&imsg);
	}
}

int
la_cmp(struct listen_addr *a, struct listen_addr *b)
{
	struct sockaddr_in	*in_a, *in_b;
	struct sockaddr_in6	*in6_a, *in6_b;

	if (a->sa.ss_family != b->sa.ss_family)
		return (1);

	switch (a->sa.ss_family) {
	case AF_INET:
		in_a = (struct sockaddr_in *)&a->sa;
		in_b = (struct sockaddr_in *)&b->sa;
		if (in_a->sin_addr.s_addr != in_b->sin_addr.s_addr)
			return (1);
		if (in_a->sin_port != in_b->sin_port)
			return (1);
		break;
	case AF_INET6:
		in6_a = (struct sockaddr_in6 *)&a->sa;
		in6_b = (struct sockaddr_in6 *)&b->sa;
		if (bcmp(&in6_a->sin6_addr, &in6_b->sin6_addr,
		    sizeof(struct in6_addr)))
			return (1);
		if (in6_a->sin6_port != in6_b->sin6_port)
			return (1);
		break;
	default:
		fatal("king bula sez: unknown address family");
		/* NOTREACHED */
	}

	return (0);
}

struct peer *
getpeerbyaddr(struct bgpd_addr *addr)
{
	struct peer *p;

	/* we might want a more effective way to find peers by IP */
	for (p = peers; p != NULL &&
	    memcmp(&p->conf.remote_addr, addr, sizeof(p->conf.remote_addr));
	    p = p->next)
		;	/* nothing */

	return (p);
}

struct peer *
getpeerbydesc(const char *descr)
{
	struct peer	*p, *res = NULL;
	int		 match = 0;

	for (p = peers; p != NULL; p = p->next)
		if (!strcmp(p->conf.descr, descr)) {
			res = p;
			match++;
		}

	if (match > 1)
		log_info("neighbor description \"%s\" not unique, request "
		    "aborted", descr);

	if (match == 1)
		return (res);
	else
		return (NULL);
}

struct peer *
getpeerbyip(struct sockaddr *ip)
{
	struct bgpd_addr addr;
	struct peer	*p, *newpeer, *loose = NULL;
	u_int32_t	 id;

	sa2addr(ip, &addr);

	/* we might want a more effective way to find peers by IP */
	for (p = peers; p != NULL; p = p->next)
		if (!p->conf.template &&
		    !memcmp(&addr, &p->conf.remote_addr, sizeof(addr)))
			return (p);

	/* try template matching */
	for (p = peers; p != NULL; p = p->next)
		if (p->conf.template &&
		    p->conf.remote_addr.aid == addr.aid &&
		    session_match_mask(p, &addr))
			if (loose == NULL || loose->conf.remote_masklen <
			    p->conf.remote_masklen)
				loose = p;

	if (loose != NULL) {
		/* clone */
		if ((newpeer = malloc(sizeof(struct peer))) == NULL)
			fatal(NULL);
		memcpy(newpeer, loose, sizeof(struct peer));
		for (id = UINT_MAX; id > UINT_MAX / 2; id--) {
			for (p = peers; p != NULL && p->conf.id != id;
			    p = p->next)
				;	/* nothing */
			if (p == NULL) {	/* we found a free id */
				break;
			}
		}
		newpeer->template = loose;
		session_template_clone(newpeer, ip, id, 0);
		newpeer->state = newpeer->prev_state = STATE_NONE;
		newpeer->conf.reconf_action = RECONF_KEEP;
		newpeer->rbuf = NULL;
		init_peer(newpeer);
		bgp_fsm(newpeer, EVNT_START);
		newpeer->next = peers;
		peers = newpeer;
		return (newpeer);
	}

	return (NULL);
}

void
session_template_clone(struct peer *p, struct sockaddr *ip, u_int32_t id,
    u_int32_t as)
{
	struct bgpd_addr	remote_addr;

	if (ip)
		sa2addr(ip, &remote_addr);
	else
		memcpy(&remote_addr, &p->conf.remote_addr, sizeof(remote_addr));

	memcpy(&p->conf, &p->template->conf, sizeof(struct peer_config));

	p->conf.id = id;

	if (as) {
		p->conf.remote_as = as;
		p->conf.ebgp = (p->conf.remote_as != p->conf.local_as);
		if (!p->conf.ebgp)
			/* force enforce_as off for iBGP sessions */
			p->conf.enforce_as = ENFORCE_AS_OFF;
	}

	memcpy(&p->conf.remote_addr, &remote_addr, sizeof(remote_addr));
	switch (p->conf.remote_addr.aid) {
	case AID_INET:
		p->conf.remote_masklen = 32;
		break;
	case AID_INET6:
		p->conf.remote_masklen = 128;
		break;
	}
	p->conf.template = 0;
}

int
session_match_mask(struct peer *p, struct bgpd_addr *a)
{
	in_addr_t	 v4mask;
	struct in6_addr	 masked;

	switch (p->conf.remote_addr.aid) {
	case AID_INET:
		v4mask = htonl(prefixlen2mask(p->conf.remote_masklen));
		if (p->conf.remote_addr.v4.s_addr == (a->v4.s_addr & v4mask))
			return (1);
		return (0);
	case AID_INET6:
		inet6applymask(&masked, &a->v6, p->conf.remote_masklen);

		if (!memcmp(&masked, &p->conf.remote_addr.v6, sizeof(masked)))
			return (1);
		return (0);
	}
	return (0);
}

struct peer *
getpeerbyid(u_int32_t peerid)
{
	struct peer *p;

	/* we might want a more effective way to find peers by IP */
	for (p = peers; p != NULL &&
	    p->conf.id != peerid; p = p->next)
		;	/* nothing */

	return (p);
}

void
session_down(struct peer *peer)
{
	bzero(&peer->capa.neg, sizeof(peer->capa.neg));
	peer->stats.last_updown = time(NULL);
	if (imsg_compose(ibuf_rde, IMSG_SESSION_DOWN, peer->conf.id, 0, -1,
	    NULL, 0) == -1)
		fatalx("imsg_compose error");
}

void
session_up(struct peer *p)
{
	struct session_up	 sup;

	if (imsg_compose(ibuf_rde, IMSG_SESSION_ADD, p->conf.id, 0, -1,
	    &p->conf, sizeof(p->conf)) == -1)
		fatalx("imsg_compose error");

	sa2addr((struct sockaddr *)&p->sa_local, &sup.local_addr);
	sa2addr((struct sockaddr *)&p->sa_remote, &sup.remote_addr);

	sup.remote_bgpid = p->remote_bgpid;
	sup.short_as = p->short_as;
	memcpy(&sup.capa, &p->capa.neg, sizeof(sup.capa));
	p->stats.last_updown = time(NULL);
	if (imsg_compose(ibuf_rde, IMSG_SESSION_UP, p->conf.id, 0, -1,
	    &sup, sizeof(sup)) == -1)
		fatalx("imsg_compose error");
}

int
imsg_ctl_parent(int type, u_int32_t peerid, pid_t pid, void *data,
    u_int16_t datalen)
{
	return (imsg_compose(ibuf_main, type, peerid, pid, -1, data, datalen));
}

int
imsg_ctl_rde(int type, pid_t pid, void *data, u_int16_t datalen)
{
	/*
	 * Use control socket to talk to RDE to bypass the queue of the
	 * regular imsg socket.
	 */
	return (imsg_compose(ibuf_rde_ctl, type, 0, pid, -1, data, datalen));
}

void
session_demote(struct peer *p, int level)
{
	struct demote_msg	msg;

	strlcpy(msg.demote_group, p->conf.demote_group,
	    sizeof(msg.demote_group));
	msg.level = level;
	if (imsg_compose(ibuf_main, IMSG_DEMOTE, p->conf.id, 0, -1,
	    &msg, sizeof(msg)) == -1)
		fatalx("imsg_compose error");

	p->demoted += level;
}

void
session_stop(struct peer *peer, u_int8_t subcode)
{
	char data[SHUT_COMM_LEN];
	uint8_t datalen;
	uint8_t shutcomm_len;
	char *communication;

	datalen = 0;

	communication = peer->conf.shutcomm;

	if ((subcode == ERR_CEASE_ADMIN_DOWN || subcode == ERR_CEASE_ADMIN_RESET)
	    && communication && *communication) {
		shutcomm_len = strlen(communication);
		if(shutcomm_len < SHUT_COMM_LEN) {
			data[0] = shutcomm_len;
			datalen = shutcomm_len + sizeof(data[0]);
			memcpy(data + 1, communication, shutcomm_len);
		}
	}
	switch (peer->state) {
	case STATE_OPENSENT:
	case STATE_OPENCONFIRM:
	case STATE_ESTABLISHED:
		session_notification(peer, ERR_CEASE, subcode, data, datalen);
		break;
	default:
		/* session not open, no need to send notification */
		break;
	}
	bgp_fsm(peer, EVNT_STOP);
}

/*
 * return 1 when the interface is up
 * and the link state is up or unknwown
 * except when this is a carp interface, then
 * return 1 only when link state is up
 */
int
session_link_state_is_up(int flags, int type, int link_state)
{
	if (!(flags & IFF_UP))
		return (0);

	if (type == IFT_CARP &&
	    link_state == LINK_STATE_UNKNOWN)
		return (0);

	return LINK_STATE_IS_UP(link_state);
}
@


1.363
log
@Close imsg pipes later in the process. The shutdown code still tires to
send imsgs and so the SE and RDE crashed because of this late in shutdown.
OK benno@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.362 2017/05/28 12:21:36 claudio Exp $ */
d98 1
d2812 2
a2813 2
			depend_ok = (kif->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(kif->link_state);
d3279 19
@


1.362
log
@Implement an XON/XOFF protocol between the RDE and the SE to throttle
per control session and peer the generation of imsg in the RDE. This
reduces the memory pressure in the SE substantially and also a bit in
the RDE. Makes the RDE more responsive for bgpctl commands.
Tested by me with 100 peers * 2000 prefixes and by phessler@@ on an AMS-IX
border router with 200+ session. Convergance time got quite a bit better.
OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.361 2017/05/27 10:33:15 phessler Exp $ */
a546 17
	/* close pipes */
	if (ibuf_rde) {
		msgbuf_write(&ibuf_rde->w);
		msgbuf_clear(&ibuf_rde->w);
		close(ibuf_rde->fd);
		free(ibuf_rde);
	}
	if (ibuf_rde_ctl) {
		msgbuf_clear(&ibuf_rde_ctl->w);
		close(ibuf_rde_ctl->fd);
		free(ibuf_rde_ctl);
	}
	msgbuf_write(&ibuf_main->w);
	msgbuf_clear(&ibuf_main->w);
	close(ibuf_main->fd);
	free(ibuf_main);

d572 16
@


1.361
log
@Allow OpenBGPD to selectively choose which local ASN to use per-peer.
This is intended to be used for ASN migrations, not for permanent use.

You MUST use filters to protect yourself from receiving your own routes.
There be dragons and grues.

OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.360 2017/05/26 20:55:30 phessler Exp $ */
a197 1
	u_int32_t		 ctl_queued;
d358 1
a358 11

		ctl_queued = 0;
		TAILQ_FOREACH(ctl_conn, &ctl_conns, entry)
			ctl_queued += ctl_conn->ibuf.w.queued;

		/*
		 * Do not act as unlimited buffer. Don't read in more
		 * messages if the ctl sockets are getting full.
		 */
		if (ctl_queued < SESSION_CTL_QUEUE_MAX)
			set_pollfd(&pfd[PFD_PIPE_ROUTE_CTL], ibuf_rde_ctl);
d1381 7
d1772 6
@


1.360
log
@AS 0 is special and should be considered an error.

Drop the session if it shows during OPEN or CAPA, or mark as invalid if
it is part of an Update.

required by RFC 7607

man page OK jmc@@
OK florian@@ benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.359 2017/02/13 14:48:44 phessler Exp $ */
d1470 1
a1470 1
		nas = htonl(conf->as);
d1487 1
a1487 1
	msg.myas = htons(conf->short_as);
d2139 1
a2139 1
		peer->conf.ebgp = (peer->conf.remote_as != conf->as);
d3129 1
a3129 1
		p->conf.ebgp = (p->conf.remote_as != conf->as);
@


1.359
log
@draft-ietf-idr-shutdown extends to support a message on either of
"Administrative Shutdown" or "Administrative Reset"

patch submitted by Job Snijders, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.358 2017/01/24 04:22:42 benno Exp $ */
d2020 8
d2488 8
@


1.358
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.357 2017/01/13 18:59:12 phessler Exp $ */
d2325 3
a2327 1
	if (errcode == ERR_CEASE && subcode == ERR_CEASE_ADMIN_DOWN) {
d3241 2
a3242 2
	if (subcode == ERR_CEASE_ADMIN_DOWN && communication &&
	    *communication) {
@


1.357
log
@Add support for draft-ietf-idr-shutdown

    BGP state = Idle, marked down with shutdown reason "goodbye, we are
    upgrading to openbsd 6.1", down for 00:00:17

developed by Peter van Dijk <peter.van.dijk@@powerdns.com> and Job
Snijders <job@@ntt.net>, thank you!

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.356 2016/12/19 07:19:55 claudio Exp $ */
d43 1
d49 1
d208 3
d212 1
a212 4
	log_procname = log_procnames[bgpd_process];

	log_init(debug);
	log_verbose(verbose);
@


1.356
log
@In parse_header() not all of the bgp message may be in the buffer yet so
move the MRT msg dump to session_process_msg() after the point the full
message is in the read buffer.
Bug found and fix tested by Ian Bobbitt
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.355 2016/12/18 17:15:07 claudio Exp $ */
d5 1
d575 3
d2228 1
d2323 25
d3228 18
d3250 1
a3250 1
		session_notification(peer, ERR_CEASE, subcode, NULL, 0);
@


1.355
log
@Correct logic, make it the same as in the other mrt_dump_bgp_msg case.
Found while looking for something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.354 2016/09/03 16:22:17 renato Exp $ */
d1799 1
d1824 11
a1882 1
	struct mrt		*mrt;
a1971 9
	}
	LIST_FOREACH(mrt, &mrthead, entry) {
		if (!(mrt->type == MRT_ALL_IN || (*type == UPDATE &&
		    mrt->type == MRT_UPDATE_IN)))
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == peer->conf.id || (mrt->group_id != 0 &&
		    mrt->group_id == peer->conf.groupid))
			mrt_dump_bgp_msg(mrt, data, *len, peer);
@


1.354
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.353 2016/09/02 14:00:29 benno Exp $ */
d1380 1
a1380 1
		    mrt->peer_id == p->conf.id || (mrt->group_id == 0 &&
@


1.353
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.352 2016/08/08 21:44:00 renato Exp $ */
d555 17
a593 6
	msgbuf_write(&ibuf_rde->w);
	msgbuf_clear(&ibuf_rde->w);
	free(ibuf_rde);
	msgbuf_write(&ibuf_main->w);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
@


1.352
log
@Use exit(3) instead of _exit(2) in the child processes.

Since recently the child processes call exec() after fork(), so they
should stop using _exit(2) and use exit(3) instead when shutting down.

Ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.351 2016/07/25 14:29:28 claudio Exp $ */
d205 3
a219 1
	bgpd_process = PROC_SE;
@


1.351
log
@Initialize the log subsytem in the SE like it is done in the RDE. Without
this all logging is going via stderr to /dev/null which is not helpful.
OK deraadt@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.350 2016/07/21 10:13:58 claudio Exp $ */
d585 1
a585 1
	_exit(0);
@


1.350
log
@Remove a fatal() in peer_up when the local addrs of a peer can't be figured out.
Instead bring the session down and wait for admin help.
OK henning@@, benno@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.349 2016/06/28 16:59:14 jca Exp $ */
d204 3
@


1.349
log
@Use IPV6_MINHOPCOUNT to finish implementing ttl-security for IPv6.

ok renato@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.348 2016/06/06 15:59:10 benno Exp $ */
d2903 10
@


1.348
log
@Add format attributes to the proper functions and then fix the warning in
session.c
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.347 2015/11/20 23:26:08 florian Exp $ */
d1204 9
a1212 6
			/*
			 * XXX Kernel has no ip6 equivalent of MINTTL yet so
			 * we can't check incoming packets, but we can at least
			 * set the outgoing TTL to allow sessions configured
			 * with ttl-security to come up.
			 */
@


1.347
log
@bgpd has been naughty. It tries to play with AF_UNIX sockets without
pledging "unix".
Move control_listen up to the main process which already has
pledge("unix"). accept(2) was already allowed.

(Technically no longer necessary since listen(2) is now allowed, too,
but this moves it to the right place.)

OK claudio@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.346 2015/11/17 09:15:21 benno Exp $ */
d2020 1
a2020 1
		log_peer_warnx(&peer->conf, "peer BGPID %lu unacceptable",
@


1.346
log
@in the SE, loosing the pipe to the main process can be handled with a
normal shutdown of sessions and exit. no need for fatal().

ok henning@@ phessler@@ florian@@ happy deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.345 2015/10/25 18:49:01 claudio Exp $ */
a2662 1
				control_listen(rcsock);
a2665 1
				control_listen(csock);
@


1.345
log
@Rename imsg_compose_parent and imsg_compose_rde to imsg_ctl_parent and
imsg_ctl_rde since these function should only be used by the control
code. Also switch ibuf_rde to ibuf_rde_ctl so that the control imsgs
don't need to queue behind all the incoming bgp UPDATES. This speeds
up 'bgpctl show' from taking minutes to a few seconds. The RDE was doing
this since a very long time but it seems the SE was not adjusted. Yikes
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.344 2015/10/09 01:37:09 deraadt Exp $ */
d490 5
a494 3
		if (handle_pollfd(&pfd[PFD_PIPE_MAIN], ibuf_main) == -1)
			fatalx("SE: Lost connection to parent");
		else
@


1.344
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.343 2015/10/07 20:25:22 deraadt Exp $ */
d3133 1
a3133 1
imsg_compose_parent(int type, u_int32_t peerid, pid_t pid, void *data,
d3140 1
a3140 1
imsg_compose_rde(int type, pid_t pid, void *data, u_int16_t datalen)
d3142 5
a3146 1
	return (imsg_compose(ibuf_rde, type, 0, pid, -1, data, datalen));
@


1.343
log
@use fatal() instead of err(); from benno
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.342 2015/10/06 15:39:44 deraadt Exp $ */
d222 2
a223 2
	if (tame("stdio inet recvfd", NULL) == -1)
		fatal("tame");
@


1.342
log
@Move from tame "cmsg" to tame "sendfd" or "recvfd", depending on which
way the process moves fd's.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.342 2015/10/06 15:36:21 deraadt Exp $ */
d223 1
a223 1
		err(1, "tame");
@


1.341
log
@tame "stdio inet cmsg" should work well in the session engine.
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.340 2015/08/04 14:46:38 phessler Exp $ */
d222 1
a222 1
	if (tame("stdio inet cmsg", NULL) == -1)
@


1.340
log
@Give more precise errors, to help track when bgpd quits

OK florian@@ benno@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.339 2015/07/20 16:10:38 claudio Exp $ */
d221 3
@


1.339
log
@Make bgpd execute the RDE and session engine process instead of just forking.
This way ASLR and stack cookies are per process.
With input from benno@@ and deraadt@@
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.338 2015/02/09 11:37:31 claudio Exp $ */
d488 1
a488 1
			fatalx("Lost connection to parent");
d494 1
a494 1
			log_warnx("Lost connection to RDE");
d504 1
a504 1
			log_warnx("Lost connection to RDE");
@


1.338
log
@Kill session_socket_blockmode() and replace it with SOCK_CLOEXEC or
SOCK_NONBLOCK and accept4(). OK henning@@ tested & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.337 2014/12/04 19:55:49 sthen Exp $ */
d187 2
a188 3
pid_t
session_main(int pipe_m2s[2], int pipe_s2r[2], int pipe_m2r[2],
    int pipe_s2rctl[2])
d190 1
a190 1
	int			 nfds, timeout, pfkeysock;
a191 1
	pid_t			 pid;
a204 9
	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

d229 1
a229 8
	close(pipe_m2s[0]);
	close(pipe_s2r[1]);
	close(pipe_s2rctl[1]);
	close(pipe_m2r[0]);
	close(pipe_m2r[1]);
	if ((ibuf_rde = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_rde_ctl = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d231 1
a231 3
	imsg_init(ibuf_rde, pipe_s2r[0]);
	imsg_init(ibuf_rde_ctl, pipe_s2rctl[0]);
	imsg_init(ibuf_main, pipe_m2s[1]);
d345 3
a347 8
		pfd[PFD_PIPE_MAIN].fd = ibuf_main->fd;
		pfd[PFD_PIPE_MAIN].events = POLLIN;
		if (ibuf_main->w.queued > 0)
			pfd[PFD_PIPE_MAIN].events |= POLLOUT;
		pfd[PFD_PIPE_ROUTE].fd = ibuf_rde->fd;
		pfd[PFD_PIPE_ROUTE].events = POLLIN;
		if (ibuf_rde->w.queued > 0)
			pfd[PFD_PIPE_ROUTE].events |= POLLOUT;
d353 4
a356 1
		pfd[PFD_PIPE_ROUTE_CTL].fd = ibuf_rde_ctl->fd;
d358 2
a359 5
			/*
			 * Do not act as unlimited buffer. Don't read in more
			 * messages if the ctl sockets are getting full.
			 */
			pfd[PFD_PIPE_ROUTE_CTL].events = POLLIN;
d476 1
a476 1
		if ((nfds = poll(pfd, i, timeout * 1000)) == -1)
d487 3
a489 6
		if (nfds > 0 && pfd[PFD_PIPE_MAIN].revents & POLLOUT)
			if (msgbuf_write(&ibuf_main->w) <= 0 && errno != EAGAIN)
				fatal("pipe write error");

		if (nfds > 0 && pfd[PFD_PIPE_MAIN].revents & POLLIN) {
			nfds--;
a491 1
		}
d493 6
a498 6
		if (nfds > 0 && pfd[PFD_PIPE_ROUTE].revents & POLLOUT)
			if (msgbuf_write(&ibuf_rde->w) <= 0 && errno != EAGAIN)
				fatal("pipe write error");

		if (nfds > 0 && pfd[PFD_PIPE_ROUTE].revents & POLLIN) {
			nfds--;
a500 1
		}
d502 7
a508 2
		if (nfds > 0 && pfd[PFD_PIPE_ROUTE_CTL].revents & POLLIN) {
			nfds--;
a510 1
		}
d512 1
a512 2
		if (nfds > 0 && pfd[PFD_SOCK_CTL].revents & POLLIN) {
			nfds--;
a513 1
		}
d515 1
a515 2
		if (nfds > 0 && pfd[PFD_SOCK_RCTL].revents & POLLIN) {
			nfds--;
a516 1
		}
d518 1
a518 2
		if (nfds > 0 && pfd[PFD_SOCK_PFKEY].revents & POLLIN) {
			nfds--;
d525 2
a526 4
		for (j = PFD_LISTENERS_START; nfds > 0 && j < idx_listeners;
		    j++)
			if (pfd[j].revents & POLLIN) {
				nfds--;
a527 1
			}
d529 2
a530 2
		for (; nfds > 0 && j < idx_peers; j++)
			nfds -= session_dispatch_msg(&pfd[j],
d537 2
a538 3
		for (; nfds > 0 && j < idx_mrts; j++)
			if (pfd[j].revents & POLLOUT) {
				nfds--;
a539 1
			}
d541 2
a542 2
		for (; nfds > 0 && j < i; j++)
			nfds -= control_dispatch_msg(&pfd[j], &ctl_cnt);
d2498 1
d2505 1
a2505 1
	int			 n, depend_ok, restricted;
d2508 1
a2508 7
	if ((n = imsg_read(ibuf)) == -1)
		fatal("session_dispatch_imsg: imsg_read error");

	if (n == 0)	/* connection closed */
		fatalx("session_dispatch_imsg: pipe closed");

	for (;;) {
d2516 30
@


1.337
log
@replace an overlapping memcpy with memmove, ok deraadt tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.336 2014/10/25 03:23:49 lteo Exp $ */
a170 2
		session_socket_blockmode(la->fd, BM_NONBLOCK);

d1039 3
a1041 2
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&cliaddr, &len)) == -1) {
a1101 1
		session_socket_blockmode(connfd, BM_NONBLOCK);
d1130 2
a1131 2
	if ((peer->fd = socket(aid2af(peer->conf.remote_addr.aid), SOCK_STREAM,
	    IPPROTO_TCP)) == -1) {
a1173 2
	session_socket_blockmode(peer->fd, BM_NONBLOCK);

a1276 17
}

void
session_socket_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
@


1.336
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.335 2014/10/08 16:15:37 deraadt Exp $ */
d1893 1
a1893 1
		memcpy(&p->rbuf->buf, p->rbuf->buf + rpos, left);
@


1.335
log
@Use reallocarray() throughout to spot multiplicative int overflow.
ok henning benno
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.334 2014/01/22 04:08:08 claudio Exp $ */
a27 1
#include <netinet/in_systm.h>
@


1.334
log
@Fix a bug where stale routes were not properly flushed on sessions announcing
the graceful restart capability.  The bug is triggered when a router does not
reconnect before the graceful restart timeout fires.
This removes the checks for the CAPA_GR_FORWARD flag in the timeout and
IMSG_SESSION_RESTARTED handler.
CAPA_GR_RESTARTING is indicating that bgpd is currently doing a graceful
restart for this neighbor and therefore the SE must issue a flush of stale
routes in some way.
CAPA_GR_FORWARD on the other hand is only indicating that the neighbor
actually preserved the forwarding state which is too strict for the timeout
handler.
Tested by sthen@@, florian@@ and benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.333 2013/11/13 20:41:01 benno Exp $ */
d317 2
a318 2
			if ((newp = realloc(peer_l, sizeof(struct peer *) *
			    peer_cnt)) == NULL) {
d342 2
a343 2
			if ((newp = realloc(mrt_l, sizeof(struct mrt *) *
			    mrt_cnt)) == NULL) {
d356 2
a357 2
			if ((newp = realloc(pfd, sizeof(struct pollfd) *
			    new_cnt)) == NULL) {
@


1.333
log
@from claudio
"Let msgbuf_write return -1 with errno EAGAIN. The users then must
check if this was the case and readd the event or poll again.  The
current handling in the imsg code is wrong for sure."

ok gilles, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.332 2013/07/10 15:56:06 claudio Exp $ */
d1732 3
a1734 3
		 * Only flush if the peer is restarting and the peer indicated
		 * it hold the forwarding state. In all other cases the
		 * session was already flushed when the session came up.
d1736 1
a1736 2
		if (p->capa.neg.grestart.flags[i] & CAPA_GR_RESTARTING &&
		    p->capa.neg.grestart.flags[i] & CAPA_GR_FORWARD) {
d2522 2
d2529 3
a2531 1
		if (p->capa.neg.grestart.flags[i] & CAPA_GR_RESTARTING) {
d2539 4
a2542 6
			}
			p->capa.neg.grestart.flags[i] =
			    p->capa.peer.grestart.flags[i] | CAPA_GR_RESTARTING;
		} else
			p->capa.neg.grestart.flags[i] =
			    p->capa.peer.grestart.flags[i];
d2915 1
a2915 3
			    CAPA_GR_RESTARTING &&
			    p->capa.neg.grestart.flags[aid] &
			    CAPA_GR_FORWARD) {
@


1.332
log
@Change the way the RDE updates its peer list. The SE is now always sending
a IMSG_SESSION_ADD message to the RDE when a peer comes up or when a reload
happens. The IMSG_SESSION_ADD has the full current config of the peer and
so the RDE should end up with correct values. This affects mostly maxprefix
and the RIB settings. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.331 2013/05/30 20:29:27 florian Exp $ */
d516 1
a516 1
			if (msgbuf_write(&ibuf_main->w) < 0)
d526 1
a526 1
			if (msgbuf_write(&ibuf_rde->w) < 0)
d1798 2
a1799 2
		if ((error = msgbuf_write(&p->wbuf)) < 0) {
			if (error == -2)
d1801 1
a1801 1
			else
@


1.331
log
@When removing "dump (all|updates)" from bgpd.conf and reloading, tell
the session engine to actually stop logging.
Found the hard way by benno@@.

with & ok benno@@
input & ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.330 2013/05/30 10:13:58 sthen Exp $ */
a81 1
int	session_graceful_is_restarting(struct peer *);
a1725 11
session_graceful_is_restarting(struct peer *p)
{
	u_int8_t	i;

	for (i = 0; i < AID_MAX; i++)
		if (p->capa.neg.grestart.flags[i] & CAPA_GR_RESTARTING)
			return (1);
	return (0);
}

int
d2614 1
a2614 1
				if (imsg_compose(ibuf_rde, IMSG_RECONF_PEER,
d2628 1
a2628 1
						    IMSG_RECONF_PEER,
d3147 3
a3149 4
	if (!session_graceful_is_restarting(p))
		if (imsg_compose(ibuf_rde, IMSG_SESSION_ADD, p->conf.id, 0, -1,
		    &p->conf, sizeof(p->conf)) == -1)
			fatalx("imsg_compose error");
@


1.330
log
@Add partial support to bgpd for the ttl hack with ipv6. This sends the correct
ttl on outgoing packets so peer sessions can come up correctly if both sides
use ttl-security, but the kernel side is not yet implemented so incoming
packets aren't verified (note added to manual for this). ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.329 2013/03/20 04:01:42 deraadt Exp $ */
d2832 2
a2833 5
			if (mrt != NULL) {
				mrt_clean(mrt);
				LIST_REMOVE(mrt, entry);
				free(mrt);
			}
@


1.329
log
@less includes
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.328 2013/03/11 17:40:11 deraadt Exp $ */
d167 5
d1238 11
a1248 1
			/* set hoplimit to foreign router's distance */
@


1.328
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.327 2013/03/07 21:26:28 claudio Exp $ */
a18 1
#include <sys/param.h>
d32 1
@


1.327
log
@Implements a few missing bits for better templates support:
- on config reload also adjust the cloned neighbors so that they get the
  config changes as well.
- clean up sessions that are 1h idle but in state active (instead of down)
- add bits to allow bgpctl to destroy cloned neighbors
Tested by sthen@@ some time ago, OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.326 2012/12/01 10:35:17 claudio Exp $ */
d1040 1
a1040 1
		if (errno == ENFILE || errno == EMFILE) {
d1042 2
a1043 4
			return;
		} else if (errno == EWOULDBLOCK || errno == EINTR)
			return;
		else
d1045 1
@


1.326
log
@The capability parser should only return an error in extreme cases. If a
particular capability is bad, log the fact and ignore it. This may give us
a chance to bring up session that have e.g. unexpected AFI,SAFI pairs in them.
Also make the error messages more user friendly.
OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.325 2012/09/18 09:45:50 claudio Exp $ */
d100 2
d270 3
a272 3
		for (p = peers; p != NULL; p = next) {
			next = p->next;
			if (!pending_reconf) {
d274 2
a275 1
				if (p->state == STATE_IDLE && p->conf.cloned &&
d308 1
a309 1
			last = p;
d2154 1
a2154 1
	if (peer->conf.cloned && !peer->conf.remote_as && as != AS_TRANS) {
d2609 26
d2720 1
a2720 1
				    !p->conf.cloned)
a3044 1
				newpeer->conf.id = id;
d3048 2
a3049 11
		sa2addr(ip, &newpeer->conf.remote_addr);
		switch (ip->sa_family) {
		case AF_INET:
			newpeer->conf.remote_masklen = 32;
			break;
		case AF_INET6:
			newpeer->conf.remote_masklen = 128;
			break;
		}
		newpeer->conf.template = 0;
		newpeer->conf.cloned = 1;
d3061 35
@


1.326.2.1
log
@MFC: handle ECONNABORTED errors from accept().  In many code blocks they
can be ignored silently and without aborting, much like EINTR and EWOULDBLOCK
are.

This is http://ftp.openbsd.org/pub/OpenBSD/patches/5.3/common/001_bgpd.patch:
"A rare condition during session startup may cause bgpd to replace an
active session leading to unknown consequences. Bug found by inspection
(we do not know how to reproduce it, consider that a challenge)."
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.326 2012/12/01 10:35:17 claudio Exp $ */
d1037 1
a1037 1
		if (errno == ENFILE || errno == EMFILE)
d1039 4
a1042 2
		else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
a1043 1
		return;
@


1.325
log
@Only allow one reload request at a time in bgpd. Needed for further work.
OK sthen@@, benno@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.324 2012/09/12 05:56:22 claudio Exp $ */
d2367 2
a2368 2
			log_peer_warnx(&peer->conf, "parse_capabilities: "
			    "expect len >= 2, len is %u", len);
d2380 1
a2380 1
				    "parse_capabilities: "
d2395 3
a2397 3
				    "parse_capabilities: "
				    "expect len 4, len is %u", capa_len);
				return (-1);
d2404 3
a2406 2
				    "parse_capabilities: AFI %u, "
				    "safi %u unknown", afi, safi);
d2422 5
a2426 3
				    "parse_capabilities: "
				    "expect len 2 + x*4, len is %u", capa_len);
				return (-1);
d2434 1
a2434 1
				log_peer_warnx(&peer->conf,
d2436 2
a2437 1
				return (-1);
d2446 4
a2449 3
					    "parse_capabilities: restart: AFI "
					    "%u, safi %u unknown", afi, safi);
					return (-1);
d2467 4
a2470 3
				    "parse_capabilities: "
				    "expect len 4, len is %u", capa_len);
				return (-1);
@


1.324
log
@Better graceful restart support (implementing more then just the EoR record).
This implements only the "Restarting Client" bits of the RFC -- in other
words bgpd will keep the FIB when the client restarts but it will not do GR
when restarting itself. The capability is still off by default (you need
"announce restart yes" to enable it).
Tested by Anders Berggren. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.323 2012/07/11 09:43:10 sthen Exp $ */
d2721 2
@


1.323
log
@Limit "while(setsockopt(..SO_RCVBUF/SO_SNDBUF..))" loops to prevent them
running away if the setsockopt call fails, as may happen if a peer bounces
at the wrong time.

OK claudio@@ after tweaks to an earlier version which was OK phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.322 2012/07/09 11:11:07 claudio Exp $ */
d72 1
d81 3
d444 4
d952 1
a952 2
		if (peer->state == STATE_ESTABLISHED)
			session_down(peer);
d959 11
d980 14
d1067 1
d1100 7
d1333 24
d1417 1
d1431 1
d1438 38
a1475 8
	/* End-of-RIB marker, RFC 4724 */
	if (p->capa.ann.restart) {	/* 2 bytes data */
		u_char		c[2];

		c[0] = 0x80; /* we're always restarting */
		c[1] = 0;
		errs += session_capa_add(opb, CAPA_RESTART, 2);
		errs += ibuf_add(opb, &c, 2);
d1682 63
d2318 1
a2318 1
				peer->capa.ann.restart = 0;
d2356 1
d2359 1
d2362 1
d2414 44
a2457 2
			peer->capa.peer.restart = 1;
			/* we don't care about the further restart capas yet */
d2500 1
a2500 1
	/* if no MP capability present for default IPv4 unicast mode */
d2504 30
a2533 1
	p->capa.neg.restart = p->capa.peer.restart;
d2551 1
a2551 1
	u_int8_t		 errcode, subcode;
d2862 34
d3086 4
a3089 3
	if (imsg_compose(ibuf_rde, IMSG_SESSION_ADD, p->conf.id, 0, -1,
	    &p->conf, sizeof(p->conf)) == -1)
		fatalx("imsg_compose error");
@


1.323.2.1
log
@from HEAD:
handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...  as well, bgpd had
a more serious error -- it proceeded on certain accept() errors..
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.323 2012/07/11 09:43:10 sthen Exp $ */
d1005 1
a1005 1
		if (errno == ENFILE || errno == EMFILE)
d1007 4
a1010 2
		else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
a1011 1
		return;
@


1.322
log
@Fix the handling of the message read buf with regard to MSG_PROCESS_LIMIT.
The read buffer was only processed when new data came in. So on quiet
sessions it could take minutes until the read buffer was processed at the
end of a load. Nobody realized this in the last 7.5 years.
Tested by sthen@@ OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.321 2012/04/12 17:26:09 claudio Exp $ */
d1214 3
a1216 2
		while (setsockopt(p->fd, SOL_SOCKET, SO_RCVBUF, &bsize,
		    sizeof(bsize)) == -1)
d1219 3
a1221 2
		while (setsockopt(p->fd, SOL_SOCKET, SO_SNDBUF, &bsize,
		    sizeof(bsize)) == -1)
@


1.321
log
@accept() pacing for bgpd based on similar work done on other daemons.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.320 2012/01/06 17:33:11 sthen Exp $ */
d81 1
d452 3
d555 4
d1586 1
a1586 1
	ssize_t		n, rpos, av, left;
d1588 1
a1588 3
	int		error, processed = 0;
	u_int16_t	msglen;
	u_int8_t	msgtype;
d1658 1
a1658 2
		rpos = 0;
		av = p->rbuf->wpos + n;
d1660 12
d1673 2
a1674 15
		/*
		 * session might drop to IDLE -> buffers deallocated
		 * we MUST check rbuf != NULL before use
		 */
		for (;;) {
			if (rpos + MSGSIZE_HEADER > av)
				break;
			if (p->rbuf == NULL)
				break;
			if (parse_header(p, p->rbuf->buf + rpos, &msglen,
			    &msgtype) == -1)
				return (0);
			if (rpos + msglen > av)
				break;
			p->rbuf->rptr = p->rbuf->buf + rpos;
d1676 43
a1718 31
			switch (msgtype) {
			case OPEN:
				bgp_fsm(p, EVNT_RCVD_OPEN);
				p->stats.msg_rcvd_open++;
				break;
			case UPDATE:
				bgp_fsm(p, EVNT_RCVD_UPDATE);
				p->stats.msg_rcvd_update++;
				break;
			case NOTIFICATION:
				bgp_fsm(p, EVNT_RCVD_NOTIFICATION);
				p->stats.msg_rcvd_notification++;
				break;
			case KEEPALIVE:
				bgp_fsm(p, EVNT_RCVD_KEEPALIVE);
				p->stats.msg_rcvd_keepalive++;
				break;
			case RREFRESH:
				parse_refresh(p);
				p->stats.msg_rcvd_rrefresh++;
				break;
			default:	/* cannot happen */
				session_notification(p, ERR_HEADER,
				    ERR_HDR_TYPE, &msgtype, 1);
				log_warnx("received message with "
				    "unknown type %u", msgtype);
				bgp_fsm(p, EVNT_CON_FATAL);
			}
			rpos += msglen;
			if (++processed > MSG_PROCESS_LIMIT)
				break;
d1720 6
a1725 2
		if (p->rbuf == NULL)
			return (1);
d1727 6
a1732 6
		if (rpos < av) {
			left = av - rpos;
			memcpy(&p->rbuf->buf, p->rbuf->buf + rpos, left);
			p->rbuf->wpos = left;
		} else
			p->rbuf->wpos = 0;
d1734 1
a1734 3
		return (1);
	}
	return (0);
@


1.320
log
@typo in log_peer_warnx message
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.319 2011/07/09 02:51:18 henning Exp $ */
d110 1
d376 9
a384 4
		pfd[PFD_SOCK_CTL].fd = csock;
		pfd[PFD_SOCK_CTL].events = POLLIN;
		pfd[PFD_SOCK_RCTL].fd = rcsock;
		pfd[PFD_SOCK_RCTL].events = POLLIN;
d390 5
a394 2
			pfd[i].fd = la->fd;
			pfd[i].events = POLLIN;
d481 2
d489 7
d890 1
a890 1
	if (peer->fd != -1)
d892 2
a893 1

d997 4
a1000 1
		if (errno == EWOULDBLOCK || errno == EINTR)
@


1.319
log
@remove that rlimit code, rc.d and login classes do it much betterer these
days. screaming bob ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.318 2011/07/04 04:34:14 claudio Exp $ */
d1968 1
a1968 1
		    "capabilitiy negotiation calculation failed");
@


1.318
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.317 2011/05/05 06:21:44 henning Exp $ */
a36 1
#include <limits.h>
a181 1
	struct rlimit		 rl;
a216 7

	if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("getrlimit");
	rl.rlim_cur = rl.rlim_max;
	if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
		fatal("setrlimit");

@


1.317
log
@ibuf_add returns 0 or -1. adding up the return values in errs and then
checking errs > 0 is not going to work... also make errs signed in 2 cases
triggered by Milosz Jakubowski <milosz.jakubowski at gmail.com> pointing out
a few cases, diff written from scratch to cover all of them. unsigned errs
noticed by sthen. ok claudio sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.316 2010/12/23 17:41:40 claudio Exp $ */
d2464 1
a2464 3
			    (LINK_STATE_IS_UP(kif->link_state) ||
			    (kif->link_state == LINK_STATE_UNKNOWN &&
			    kif->media_type != IFT_CARP));
@


1.316
log
@Increase the DATA limit in the RDE to the max value and do the same
for NOFILE in the session engine.
OK henning, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.315 2010/12/09 13:50:41 claudio Exp $ */
d1289 1
a1289 2
	if (errs > 0 ||
	    (msg = calloc(1, sizeof(*msg))) == NULL) {
d1329 1
a1329 1
	u_int			 errs = 0;
d1404 1
a1404 1
	if (errs > 0) {
d1474 1
a1474 1
	u_int			 errs = 0;
d1493 1
a1493 1
	if (errs > 0) {
d1547 1
a1547 1
	if (errs > 0) {
@


1.315
log
@The PF_KEY socket is like the routing socket. It must be polled all the
time to consume broadcasted messages or the socket gets full and own
messages that are needed are lost. This fixes an infinit loop in
pfkey_reply that happens when bgpd tcp md5sum is used on a system that
also runs a larger IPsec setup.
OK henning, lot of patience, debuging and testing by Thomas Boernert
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.314 2010/11/18 12:51:24 claudio Exp $ */
d24 2
d183 1
d219 6
@


1.314
log
@Log sent notification messages as well having them in the log may
help to figure out the cause of flapping session faster.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.313 2010/11/10 15:14:36 claudio Exp $ */
d53 2
a54 1
#define PFD_LISTENERS_START	5
d181 1
a181 1
	int			 nfds, timeout;
d217 1
a217 2
	if (pfkey_init(&sysdep) == -1)
		fatalx("pfkey setup failed");
d379 2
d512 8
@


1.313
log
@Make sure that the initial configuration of the child is zeroed out
by using calloc(). This fixes an issue where the RDE would start up
as route-collector because uninitialized memory made the RDE switch
to that mode.
OK henning@@, sthen@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.312 2010/10/15 07:45:32 claudio Exp $ */
d1461 2
d2062 1
a2062 1
	log_notification(peer, errcode, subcode, p, datalen);
@


1.312
log
@Add the FSM suberrors specified in draft-ietf-idr-fsm-subcode. This
should help identifying FSM errors since the state is know known.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.311 2010/09/02 14:03:21 sobrado Exp $ */
d250 1
a250 1
	if ((conf = malloc(sizeof(struct bgpd_config))) == NULL)
@


1.311
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.310 2010/06/27 19:53:34 claudio Exp $ */
d756 2
a757 1
			session_notification(peer, ERR_FSM, 0, NULL, 0);
d791 2
a792 1
			session_notification(peer, ERR_FSM, 0, NULL, 0);
d832 2
a833 1
			session_notification(peer, ERR_FSM, 0, NULL, 0);
@


1.310
log
@Instead of specifying the control sockets on the command line have them
in bgpd.conf. This allows to add/modify restricted control sockets on runtime.
Feature request by a few people how often forgot to add -r path when restarting
bgpd (including myself).
NOTE: this removes the -s and -r arguments from bgpd so pay attention when
updateing.
jajaja sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.309 2010/05/26 13:56:07 nicm Exp $ */
d177 1
a177 1
session_main(int pipe_m2s[2], int pipe_s2r[2], int pipe_m2r[2], 
d372 1
a372 1
			 * messages if the ctl sockets are getting full. 
@


1.310.2.1
log
@MFC, original commit from claudio@@
(r1.300 of rde.c and r1.313 of session.c):
- - - - - - - - - - - - - -
Make sure that the initial configuration of the child is zeroed out
by using calloc(). This fixes an issue where the RDE would start up
as route-collector because uninitialized memory made the RDE switch
to that mode.
OK henning@@, sthen@@, phessler@@
- - - - - - - - - - - - - -

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.310 2010/06/27 19:53:34 claudio Exp $ */
d250 1
a250 1
	if ((conf = calloc(1, sizeof(struct bgpd_config))) == NULL)
@


1.309
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.308 2010/05/03 13:09:38 claudio Exp $ */
d178 1
a178 1
    int pipe_s2rctl[2], char *cname, char *rcname)
a204 6
	/* control socket is outside chroot */
	if ((csock = control_init(0, cname)) == -1)
		fatalx("control socket setup failed");
	if (rcname != NULL && (rcsock = control_init(1, rcname)) == -1)
		fatalx("control socket setup failed");

a244 2
	control_listen(csock);
	control_listen(rcsock);
d2261 1
a2261 1
	int			 n, depend_ok;
d2348 22
@


1.308
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.307 2010/04/16 12:24:25 claudio Exp $ */
d68 2
a69 2
int	session_capa_add(struct buf *, u_int8_t, u_int8_t);
int	session_capa_add_mp(struct buf *, u_int8_t);
d629 1
a629 1
			peer->rbuf = calloc(1, sizeof(struct buf_read));
d1230 1
a1230 1
session_capa_add(struct buf *opb, u_int8_t capa_code, u_int8_t capa_len)
d1234 2
a1235 2
	errs += buf_add(opb, &capa_code, sizeof(capa_code));
	errs += buf_add(opb, &capa_len, sizeof(capa_len));
d1240 1
a1240 1
session_capa_add_mp(struct buf *buf, u_int8_t aid)
d1249 3
a1251 3
	errs += buf_add(buf, &afi, sizeof(afi));
	errs += buf_add(buf, &pad, sizeof(pad));
	errs += buf_add(buf, &safi, sizeof(safi));
d1261 1
a1261 1
	struct buf		*buf;
d1268 1
a1268 1
	if ((buf = buf_open(len)) == NULL)
d1271 3
a1273 3
	errs += buf_add(buf, &hdr.marker, sizeof(hdr.marker));
	errs += buf_add(buf, &hdr.len, sizeof(hdr.len));
	errs += buf_add(buf, &hdr.type, sizeof(hdr.type));
d1277 1
a1277 1
		buf_free(buf);
d1303 1
a1303 1
	buf_close(&p->wbuf, msg->buf);
d1312 1
a1312 1
	struct buf		*opb;
d1319 1
a1319 1
	if ((opb = buf_dynamic(0, UCHAR_MAX - sizeof(op_type) -
d1343 1
a1343 1
		errs += buf_add(opb, &c, 2);
d1352 1
a1352 1
		errs += buf_add(opb, &nas, sizeof(nas));
d1355 2
a1356 2
	if (buf_size(opb))
		optparamlen = buf_size(opb) + sizeof(op_type) +
d1361 1
a1361 1
		buf_free(opb);
d1375 5
a1379 5
	errs += buf_add(buf->buf, &msg.version, sizeof(msg.version));
	errs += buf_add(buf->buf, &msg.myas, sizeof(msg.myas));
	errs += buf_add(buf->buf, &msg.holdtime, sizeof(msg.holdtime));
	errs += buf_add(buf->buf, &msg.bgpid, sizeof(msg.bgpid));
	errs += buf_add(buf->buf, &msg.optparamlen, sizeof(msg.optparamlen));
d1383 4
a1386 4
		optparamlen = buf_size(opb);
		errs += buf_add(buf->buf, &op_type, sizeof(op_type));
		errs += buf_add(buf->buf, &optparamlen, sizeof(optparamlen));
		errs += buf_add(buf->buf, opb->buf, buf_size(opb));
d1389 1
a1389 1
	buf_free(opb);
d1392 1
a1392 1
		buf_free(buf->buf);
d1440 2
a1441 2
	if (buf_add(buf->buf, data, datalen)) {
		buf_free(buf->buf);
d1472 2
a1473 2
	errs += buf_add(buf->buf, &errcode, sizeof(errcode));
	errs += buf_add(buf->buf, &subcode, sizeof(subcode));
d1476 1
a1476 1
		errs += buf_add(buf->buf, data, datalen);
d1479 1
a1479 1
		buf_free(buf->buf);
d1528 3
a1530 3
	errs += buf_add(buf->buf, &afi, sizeof(afi));
	errs += buf_add(buf->buf, &null8, sizeof(null8));
	errs += buf_add(buf->buf, &safi, sizeof(safi));
d1533 1
a1533 1
		buf_free(buf->buf);
@


1.307
log
@Memory allocated with calloc() is initialized to zero, no need to do that
explicitly.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.306 2010/04/13 09:09:48 claudio Exp $ */
a2363 1
			conf->rtableid = nconf->rtableid;
d2490 1
d2768 2
a2769 1
imsg_compose_parent(int type, pid_t pid, void *data, u_int16_t datalen)
d2771 1
a2771 1
	return (imsg_compose(ibuf_main, type, 0, pid, -1, data, datalen));
@


1.306
log
@Instead of passing AF specific struct kroutes over imsgs use a struct
kroute_full structure that is AF independent and has all information in
it. Simplifies the communication between processes and reduces the number
of imsg types. This is another step to add FIB support to BGP MPLS VPNs.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.305 2010/02/11 22:05:59 claudio Exp $ */
a631 1
			peer->rbuf->wpos = 0;
@


1.305
log
@Not knowing a AFI/SAFI pair in the MP capability is no reason to fail
a session. Just print a warning and move on since both side need to
announce a pair to use it. Found and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.304 2010/01/05 08:49:57 claudio Exp $ */
a2488 1
		case IMSG_CTL_KROUTE6:
a2500 1
		case IMSG_CTL_SHOW_NETWORK6:
@


1.304
log
@Make sure that all important config variables are synced on a reload in
the SE. This got more important since we use the reload all the time now.
Found out the hard way and fix tested by Laurent CARON
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.303 2009/12/31 15:34:02 claudio Exp $ */
d2197 1
a2197 1
				return (-1);
@


1.303
log
@Instead of passing the config via arguments to the childs on bootup issue
a config reload as first step in bootup. This allows childs to start with
an empty config and a lot of special cleanup code can bite the dust.
Testing by myself and sthen@@ with a few configs (more testing welcome).
Seems like a good idea henning@@ & sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.302 2009/12/08 14:03:40 claudio Exp $ */
d2363 5
d2369 1
a2370 1
			conf->bgpid = nconf->bgpid;
d2372 1
@


1.302
log
@Big AID change part two. This changes the mp capability into an array of
flags. This makes a lot of code much easier since the comparison is now
trivial. Additionally calculate the negotiated capabilities for a session
in the SE and pass that and only that to the RDE. This makes the decisions
in the RDE a lot easier.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.301 2009/12/03 19:27:20 claudio Exp $ */
d96 1
a96 1
struct bgpd_config	*conf, *nconf = NULL;
d98 3
a100 3
struct peer		*npeers;
volatile sig_atomic_t	 session_quit = 0;
int			 pending_reconf = 0;
d177 2
a178 4
session_main(struct bgpd_config *config, struct peer *cpeers,
    struct network_head *net_l, struct filter_head *rules,
    struct mrt_head *m_l, struct rib_names *rib_l, int pipe_m2s[2],
    int pipe_s2r[2], int pipe_m2r[2], int pipe_s2rctl[2])
a188 1
	struct network		*net;
a189 1
	struct filter_rule	*r;
a192 1
	struct rde_rib		*rr;
a195 3
	conf = config;
	peers = cpeers;

d206 1
a206 1
	if ((csock = control_init(0, conf->csock)) == -1)
d208 1
a208 2
	if (conf->rcsock != NULL &&
	    (rcsock = control_init(1, conf->rcsock)) == -1)
a229 3
	listener_cnt = 0;
	setup_listeners(&listener_cnt);

d234 3
a236 1
	log_info("session engine ready");
a241 1
	init_conf(conf);
d249 1
d254 1
d258 6
a263 6
	/* filter rules are not used in the SE */
	while ((r = TAILQ_FIRST(rules)) != NULL) {
		TAILQ_REMOVE(rules, r, entry);
		free(r);
	}
	free(rules);
d265 1
a265 17
	/* network list is not used in the SE */
	while ((net = TAILQ_FIRST(net_l)) != NULL) {
		TAILQ_REMOVE(net_l, net, entry);
		filterset_free(&net->net.attrset);
		free(net);
	}

	/* main mrt list is not used in the SE */
	while ((m = LIST_FIRST(m_l)) != NULL) {
		LIST_REMOVE(m, entry);
		free(m);
	}
	/* rib names not used in the SE */
	while ((rr = SIMPLEQ_FIRST(&ribnames))) {
		SIMPLEQ_REMOVE_HEAD(&ribnames, entry);
		free(rr);
	}
d286 2
a287 1
					timer_set(p, Timer_IdleHold, 0);
@


1.301
log
@Stop the IdleHold timer when going to idle state. This makes it a bit
more clear that going to idle state will stop everything and it is
necessary to start the IdleHold timer to restart sessions. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.300 2009/12/01 14:28:05 claudio Exp $ */
d69 1
a69 1
int	session_capa_add_mp(struct buf *, u_int16_t, u_int8_t);
d77 1
a77 1
void	session_rrefresh(struct peer *, u_int16_t, u_int8_t);
d85 1
d1251 1
a1251 5
	peer->capa.ann.mp_v4 = SAFI_NONE;
	peer->capa.ann.mp_v4 = SAFI_NONE;
	peer->capa.ann.refresh = 0;
	peer->capa.ann.restart = 0;
	peer->capa.ann.as4byte = 0;
d1265 1
a1265 1
session_capa_add_mp(struct buf *buf, u_int16_t afi, u_int8_t safi)
d1267 2
a1268 1
	u_int8_t		 pad = 0;
d1271 2
d1340 1
a1340 1
	u_int8_t		 op_type, optparamlen = 0;
d1351 5
a1355 8
	if (p->capa.ann.mp_v4) {	/* 4 bytes data */
		errs += session_capa_add(opb, CAPA_MP, 4);
		errs += session_capa_add_mp(opb, AFI_IPv4, p->capa.ann.mp_v4);
	}
	if (p->capa.ann.mp_v6) {	/* 4 bytes data */
		errs += session_capa_add(opb, CAPA_MP, 4);
		errs += session_capa_add_mp(opb, AFI_IPv6, p->capa.ann.mp_v6);
	}
d1523 2
d1528 4
a1531 4
	if (p->capa.peer.mp_v4 != SAFI_NONE)
		session_rrefresh(p, AFI_IPv4, p->capa.peer.mp_v4);
	if (p->capa.peer.mp_v6 != SAFI_NONE)
		session_rrefresh(p, AFI_IPv6, p->capa.peer.mp_v6);
d1537 1
a1537 1
session_rrefresh(struct peer *p, u_int16_t afi, u_int8_t safi)
d1541 5
a1545 1
	u_int8_t		 null8 = 0;
d1985 8
d2027 2
a2028 1
	struct rrefresh	 r;
d2033 5
d2039 2
a2040 2
	memcpy(&r.afi, p, sizeof(r.afi));
	r.afi = ntohs(r.afi);
d2045 1
a2045 1
	memcpy(&r.safi, p, sizeof(r.safi));
d2048 5
d2054 2
a2055 2
	if (imsg_compose(ibuf_rde, IMSG_REFRESH, peer->conf.id, 0, -1, &r,
	    sizeof(r)) == -1)
d2065 1
a2067 1
	u_int16_t	 datalen;
d2070 1
d2125 2
a2126 2
				peer->capa.ann.mp_v4 = SAFI_NONE;
				peer->capa.ann.mp_v6 = SAFI_NONE;
d2170 2
d2173 3
a2177 4
	u_char		*capa_val;
	u_int16_t	 mp_afi;
	u_int8_t	 mp_safi;
	u_int32_t	 remote_as;
d2214 8
a2221 22
			memcpy(&mp_afi, capa_val, sizeof(mp_afi));
			mp_afi = ntohs(mp_afi);
			memcpy(&mp_safi, capa_val + 3, sizeof(mp_safi));
			switch (mp_afi) {
			case AFI_IPv4:
				if (mp_safi < 1 || mp_safi > 3)
					log_peer_warnx(&peer->conf,
					    "parse_capabilities: AFI IPv4, "
					    "mp_safi %u unknown", mp_safi);
				else
					peer->capa.peer.mp_v4 = mp_safi;
				break;
			case AFI_IPv6:
				if (mp_safi < 1 || mp_safi > 3)
					log_peer_warnx(&peer->conf,
					    "parse_capabilities: AFI IPv6, "
					    "mp_safi %u unknown", mp_safi);
				else
					peer->capa.peer.mp_v6 = mp_safi;
				break;
			default:			/* ignore */
				break;
d2223 1
d2251 31
d2760 1
d2781 1
a2781 2
	memcpy(&sup.capa_announced, &p->capa.ann, sizeof(sup.capa_announced));
	memcpy(&sup.capa_received, &p->capa.peer, sizeof(sup.capa_received));
@


1.300
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.299 2009/10/26 09:27:58 claudio Exp $ */
d929 1
@


1.299
log
@Better error handling when doing mrt dumps (e.g. when there is no more space
on the disk). Before the SE spinned and the RDE may even crash in these events.
Found by Elisa Jasinska. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.298 2009/09/22 14:07:53 claudio Exp $ */
d90 4
a93 5
int			 la_cmp(struct listen_addr *, struct listen_addr *);
struct peer		*getpeerbyip(struct sockaddr *);
int			 session_match_mask(struct peer *, struct sockaddr *);
struct peer		*getpeerbyid(u_int32_t);
static struct sockaddr	*addr2sa(struct bgpd_addr *, u_int16_t);
d1075 1
a1075 1
	if ((peer->fd = socket(peer->conf.remote_addr.af, SOCK_STREAM,
d1106 1
a1106 2
	if (peer->conf.local_addr.af) {
		sa = addr2sa(&peer->conf.local_addr, 0);
d1144 26
a1169 6
	if (p->conf.ebgp && p->conf.remote_addr.af == AF_INET) {
		/* set TTL to foreign router's distance - 1=direct n=multihop
		   with ttlsec, we always use 255 */
		if (p->conf.ttlsec) {
			ttl = 256 - p->conf.distance;
			if (setsockopt(p->fd, IPPROTO_IP, IP_MINTTL, &ttl,
d1172 1
a1172 1
				    "session_setup_socket setsockopt MINTTL");
a1174 1
			ttl = 255;
d1176 10
a1185 6

		if (setsockopt(p->fd, IPPROTO_IP, IP_TTL, &ttl,
		    sizeof(ttl)) == -1) {
			log_peer_warn(&p->conf,
			    "session_setup_socket setsockopt TTL");
			return (-1);
d1187 1
a1187 16
	}

	if (p->conf.ebgp && p->conf.remote_addr.af == AF_INET6)
		/* set hoplimit to foreign router's distance */
		if (setsockopt(p->fd, IPPROTO_IPV6, IPV6_UNICAST_HOPS, &ttl,
		    sizeof(ttl)) == -1) {
			log_peer_warn(&p->conf,
			    "session_setup_socket setsockopt hoplimit");
			return (-1);
		}

	/* if ttlsec is in use, set minttl */
	if (p->conf.ttlsec) {
		ttl = 256 - p->conf.distance;
		setsockopt(p->fd, IPPROTO_IP, IP_MINTTL, &ttl, sizeof(ttl));

a1197 8
	/* set precedence, see RFC 1771 appendix 5 */
	if (p->conf.remote_addr.af == AF_INET &&
	    setsockopt(p->fd, IPPROTO_IP, IP_TOS, &pre, sizeof(pre)) == -1) {
		log_peer_warn(&p->conf,
		    "session_setup_socket setsockopt TOS");
		return (-1);
	}

d2620 1
d2624 2
d2629 2
a2630 11
		    p->conf.remote_addr.af == ip->sa_family) {
			if (p->conf.remote_addr.af == AF_INET &&
			    p->conf.remote_addr.v4.s_addr ==
			    ((struct sockaddr_in *)ip)->sin_addr.s_addr)
				return (p);
			if (p->conf.remote_addr.af == AF_INET6 &&
			    !bcmp(&p->conf.remote_addr.v6,
			    &((struct sockaddr_in6 *)ip)->sin6_addr,
			    sizeof(p->conf.remote_addr.v6)))
				return (p);
		}
d2635 2
a2636 2
		    p->conf.remote_addr.af == ip->sa_family &&
		    session_match_mask(p, ip))
d2655 3
a2657 3
		if (newpeer->conf.remote_addr.af == AF_INET) {
			newpeer->conf.remote_addr.v4.s_addr =
			    ((struct sockaddr_in *)ip)->sin_addr.s_addr;
d2659 2
a2660 5
		}
		if (newpeer->conf.remote_addr.af == AF_INET6) {
			memcpy(&newpeer->conf.remote_addr.v6,
			    &((struct sockaddr_in6 *)ip)->sin6_addr,
			    sizeof(newpeer->conf.remote_addr.v6));
d2662 1
d2680 1
a2680 1
session_match_mask(struct peer *p, struct sockaddr *ip)
a2681 1
	int		 i;
d2683 1
a2683 2
	struct in6_addr	*in;
	struct in6_addr	 mask;
d2685 2
a2686 1
	if (p->conf.remote_addr.af == AF_INET) {
d2688 1
a2688 2
		if (p->conf.remote_addr.v4.s_addr ==
		    ((((struct sockaddr_in *)ip)->sin_addr.s_addr) & v4mask))
d2690 3
a2692 3
		else
			return (0);
	}
d2694 3
a2696 16
	if (p->conf.remote_addr.af == AF_INET6) {
		bzero(&mask, sizeof(mask));
		for (i = 0; i < p->conf.remote_masklen / 8; i++)
			mask.s6_addr[i] = 0xff;
		i = p->conf.remote_masklen % 8;
		if (i)
			mask.s6_addr[p->conf.remote_masklen / 8] = 0xff00 >> i;

		in = &((struct sockaddr_in6 *)ip)->sin6_addr;

		for (i = 0; i < 16; i++)
			if ((in->s6_addr[i] & mask.s6_addr[i]) !=
			    p->conf.remote_addr.addr8[i])
				return (0);

		return (1);
a2697 1

d2732 2
a2733 24
	switch (p->sa_local.ss_family) {
	case AF_INET:
		sup.local_addr.af = AF_INET;
		memcpy(&sup.local_addr.v4,
		    &((struct sockaddr_in *)&p->sa_local)->sin_addr,
		    sizeof(sup.local_addr.v4));
		sup.remote_addr.af = AF_INET;
		memcpy(&sup.remote_addr.v4,
		    &((struct sockaddr_in *)&p->sa_remote)->sin_addr,
		    sizeof(sup.remote_addr.v4));
		break;
	case AF_INET6:
		sup.local_addr.af = AF_INET6;
		memcpy(&sup.local_addr.v6,
		    &((struct sockaddr_in6 *)&p->sa_local)->sin6_addr,
		    sizeof(sup.local_addr.v6));
		sup.remote_addr.af = AF_INET6;
		memcpy(&sup.remote_addr.v6,
		    &((struct sockaddr_in6 *)&p->sa_remote)->sin6_addr,
		    sizeof(sup.remote_addr.v6));
		break;
	default:
		fatalx("session_up: unsupported address family");
	}
a2754 28
}

static struct sockaddr *
addr2sa(struct bgpd_addr *addr, u_int16_t port)
{
	static struct sockaddr_storage	 ss;
	struct sockaddr_in		*sa_in = (struct sockaddr_in *)&ss;
	struct sockaddr_in6		*sa_in6 = (struct sockaddr_in6 *)&ss;

	bzero(&ss, sizeof(ss));
	switch (addr->af) {
	case AF_INET:
		sa_in->sin_family = AF_INET;
		sa_in->sin_len = sizeof(struct sockaddr_in);
		sa_in->sin_addr.s_addr = addr->v4.s_addr;
		sa_in->sin_port = htons(port);
		break;
	case AF_INET6:
		sa_in6->sin6_family = AF_INET6;
		sa_in6->sin6_len = sizeof(struct sockaddr_in6);
		memcpy(&sa_in6->sin6_addr, &addr->v6,
		    sizeof(sa_in6->sin6_addr));
		sa_in6->sin6_port = htons(port);
		sa_in6->sin6_scope_id = addr->scope_id;
		break;
	}

	return ((struct sockaddr *)&ss);
@


1.298
log
@Update capability code to follow RFC 5492. Unlike before multiple
capabilities are now encoded in a single capability option.
RFC conforming BGP implementations must be able to parse both the old
and the new way of the encoding (most still seem to use the old one).
bgpd still accepts both ways on reception. OK henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.297 2009/09/03 09:06:20 claudio Exp $ */
d192 1
a192 1
	struct mrt		*m, **mrt_l = NULL;
d348 8
a355 1
		LIST_FOREACH(m, &mrthead, entry)
d358 1
@


1.297
log
@Use correct destination in memcpy(). Fixes PR6218, OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.296 2009/09/02 08:06:42 claudio Exp $ */
d68 1
a68 2
int	session_capa_add(struct peer *, struct buf *, u_int8_t, u_int8_t,
	    u_int8_t *);
d1251 1
a1251 2
session_capa_add(struct peer *p, struct buf *opb, u_int8_t capa_code,
    u_int8_t capa_len, u_int8_t *optparamlen)
d1253 1
a1253 1
	u_int8_t	op_type, op_len, tot_len, errs = 0;
a1254 5
	op_type = OPT_PARAM_CAPABILITIES;
	op_len = sizeof(capa_code) + sizeof(capa_len) + capa_len;
	tot_len = sizeof(op_type) + sizeof(op_len) + op_len;
	errs += buf_add(opb, &op_type, sizeof(op_type));
	errs += buf_add(opb, &op_len, sizeof(op_len));
a1256 1
	*optparamlen += tot_len;
d1333 1
a1333 1
	u_int8_t		 optparamlen = 0;
d1337 2
a1338 1
	if ((opb = buf_dynamic(0, MAX_PKTSIZE - MSGSIZE_OPEN_MIN)) == NULL) {
d1345 1
a1345 1
		errs += session_capa_add(p, opb, CAPA_MP, 4, &optparamlen);
d1349 1
a1349 1
		errs += session_capa_add(p, opb, CAPA_MP, 4, &optparamlen);
d1355 1
a1355 1
		errs += session_capa_add(p, opb, CAPA_REFRESH, 0, &optparamlen);
a1360 1
		bzero(&c, 2);
d1362 2
a1363 1
		errs += session_capa_add(p, opb, CAPA_RESTART, 2, &optparamlen);
d1372 2
a1373 2
		errs += session_capa_add(p, opb, CAPA_AS4BYTE, 4, &optparamlen);
		errs += buf_add(opb, &nas, 4);
d1376 4
d1402 7
a1408 2
	if (optparamlen)
		errs += buf_add(buf->buf, opb->buf, optparamlen);
@


1.296
log
@Implement all of RFC 4486 BGP Cease Notification Message Subcodes.
The other side should now see why a session was dropped. e.g:
bgpd: ... received notification: Cease, administratively down
OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.295 2009/08/21 15:43:27 claudio Exp $ */
d2659 1
a2659 1
			memcpy(&p->conf.remote_addr.v6,
@


1.295
log
@Fix for PR6213, peers with 4-byte AS numbers were unable to connect to a
template neighbor because the AS was set before the 4-byte one was parsed.
While there force enforce neighbor-as to no for iBGP peers.
Found and fix tested by Matthias Cramer (cramer (at) swissix.ch)
OK henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.294 2009/07/24 13:09:29 claudio Exp $ */
d311 1
a311 1
					bgp_fsm(p, EVNT_STOP);
d320 1
a320 1
					bgp_fsm(p, EVNT_STOP);
d560 1
a560 1
		bgp_fsm(p, EVNT_STOP);
a748 1
			session_notification(peer, ERR_CEASE, 0, NULL, 0);
a792 1
			session_notification(peer, ERR_CEASE, 0, NULL, 0);
a826 1
			session_notification(peer, ERR_CEASE, 0, NULL, 0);
a1480 1
	u_int8_t		 null8 = 0;
d1492 1
a1492 4
	if (errcode == ERR_CEASE)
		errs += buf_add(buf->buf, &null8, sizeof(null8));
	else
		errs += buf_add(buf->buf, &subcode, sizeof(subcode));
d2407 2
a2408 1
						bgp_fsm(p, EVNT_STOP);
d2836 16
@


1.294
log
@RECONF_REINIT is a bad initial reconf_action state for templates.
getpeerbyip() initializes the full peer and so there is no need to
do the work a second time -- especially since there it was already
in the wrong state resulting in strange behaviour. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.293 2009/06/07 05:56:24 eric Exp $ */
a1855 6
	/* if remote-as is zero and it's a cloned neighbor, accept any */
	if (peer->conf.cloned && !peer->conf.remote_as && as != AS_TRANS) {
		peer->conf.remote_as = as;
		peer->conf.ebgp = (peer->conf.remote_as != conf->as);
	}

d1961 9
@


1.293
log
@Change the way fds passed over a socket are retreived on the receiving side.

Currently the receiver fetches an imsg via imsg_get() and if he expects
an fd, he then calls imsg_get_fd() to fetch the next fd queued on the
imsgbuf from which the imsg came.

This changes hides the fd queueing mechanism to the API user.  When closing
an imsg with an fd, the message is flagged so that the receiving end knows
it must dequeue the fd in imsg_get() and return it with the imsg structure.
This way there is no (less) possible screw up from imsg_get_fd() not being
called directly after imsg_get() by the user. The retreived imsg is
self-contained.

ok pyr@@, "I like that" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.292 2009/06/06 06:33:15 eric Exp $ */
d2670 1
a2670 1
		newpeer->conf.reconf_action = RECONF_REINIT;
@


1.292
log
@sync bgpd/bgpctl with the common imsg code, making it lib ready as well.

ok claudio@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.291 2009/06/04 04:46:42 claudio Exp $ */
d2313 1
a2313 1
				if ((nla->fd = imsg_get_fd(ibuf)) == -1)
d2424 1
a2424 1
			if ((xmrt.wbuf.fd = imsg_get_fd(ibuf)) == -1)
@


1.291
log
@Add "rde rib <name>" to the config and allow the rde to use these other RIBs.
Still a bit hackish, reload is missing and printconf as well. Looks good h@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.290 2009/05/27 04:18:21 reyk Exp $ */
d1332 1
a1332 7
	if (buf_close(&p->wbuf, msg->buf) == -1) {
		log_peer_warn(&p->conf, "session_sendmsg buf_close");
		buf_free(msg->buf);
		free(msg);
		return (-1);
	}

@


1.290
log
@add an option to change the "connect-retry" timer which defaults to 120s.
this can be used to decrease the failover time in specific carp'ed
IBGP setups.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.289 2009/03/19 07:00:07 claudio Exp $ */
d180 2
a181 2
    struct mrt_head *m_l, int pipe_m2s[2], int pipe_s2r[2], int pipe_m2r[2],
    int pipe_s2rctl[2])
d198 1
d286 5
@


1.289
log
@First big chunk of mrt rewrite. Simplifies code hopefully and fixes table
dumps that were wrong because of the 4byte AS support. Dumps I took seemed
to work so far. "Put it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.288 2009/03/18 19:49:31 claudio Exp $ */
d592 2
d668 1
a668 1
				    INTERVAL_CONNECTRETRY);
d693 1
a693 1
			    INTERVAL_CONNECTRETRY);
d699 1
a699 1
			    INTERVAL_CONNECTRETRY);
d722 1
a722 1
			    INTERVAL_CONNECTRETRY);
d749 1
a749 1
			    INTERVAL_CONNECTRETRY);
@


1.288
log
@Correctly check the peer group for mrt dumps. Without this all non-grouped
peers ended up in most mrt dumps. Also switch the if-statements to a hopefully
easier to read version. Another mrt fix from my flight home.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.287 2009/03/18 19:39:27 claudio Exp $ */
d967 1
a967 1
			mrt_dump_state(mrt, peer->state, state, peer, conf);
d1321 1
a1321 1
			mrt_dump_bgp_msg(mrt, msg->buf->buf, msg->len, p, conf);
d1810 1
a1810 1
			mrt_dump_bgp_msg(mrt, data, *len, peer, conf);
@


1.287
log
@short_as is always initialised to the 16bit AS that is used. So no need
use conf->as as source for > 16bit AS numbers. OK henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.286 2009/03/13 05:43:51 claudio Exp $ */
d962 1
a962 1
		if (mrt->type != MRT_ALL_IN && mrt->type != MRT_ALL_OUT)
d965 3
a967 4
		    mrt->peer_id == peer->conf.id ||
		    mrt->group_id == peer->conf.groupid)
			mrt_dump_state(mrt, peer->state, state,
			    peer, conf);
d1315 2
a1316 2
		if (mrt->type != MRT_ALL_OUT &&
		    msg->type == UPDATE && mrt->type != MRT_UPDATE_OUT)
d1319 2
a1320 2
		    mrt->peer_id == p->conf.id ||
		    mrt->group_id == p->conf.groupid)
d1804 2
a1805 2
		if (mrt->type != MRT_ALL_IN && (mrt->type != MRT_UPDATE_IN ||
		    *type != UPDATE))
d1808 2
a1809 2
		    mrt->peer_id == peer->conf.id ||
		    mrt->group_id == peer->conf.groupid)
@


1.286
log
@Move mrt code over to use the msgbuf way of queuing buffers instead of rolling
an own version. More cleanup to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.285 2009/03/13 04:40:55 claudio Exp $ */
d1393 1
a1393 4
	if (conf->as > USHRT_MAX)
		msg.myas = htons(conf->short_as);
	else
		msg.myas = htons(conf->as);
@


1.285
log
@Sync buffer API with the one from ospfd. The dynamic buffers will make other
code much easier to write. OK henning@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.284 2008/09/11 14:49:58 henning Exp $ */
d344 1
a344 1
			if (m->queued)
d472 2
a473 2
			if (m->queued) {
				pfd[i].fd = m->fd;
d2426 1
a2426 1
			if ((xmrt.fd = imsg_get_fd(ibuf)) == -1)
d2437 1
a2437 1
				TAILQ_INIT(&mrt->bufs);
d2441 2
a2442 2
				close(mrt->fd);
				mrt->fd = xmrt.fd;
@


1.284
log
@remove hackery to un-demote after the session has been established for
a while, we can now just use a timer (since i rewrote the timer code)
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.283 2008/09/05 10:38:12 henning Exp $ */
a1255 2
	if (buf_grow(opb, tot_len) == NULL)
		return (1);
d1347 1
a1347 1
	if ((opb = buf_open(0)) == NULL) {
@


1.283
log
@ignore unknown SAFIs in the MP capabilities. used by some to distribute
some kind of VPN stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.282 2008/06/26 00:01:51 claudio Exp $ */
d441 6
a454 11
			/* XXX carp demotion */
			if (p->demoted && p->state == STATE_ESTABLISHED) {
				if (time(NULL) - p->stats.last_updown >=
				    INTERVAL_HOLD_DEMOTED)
					session_demote(p, -1);
				if (p->stats.last_updown + INTERVAL_HOLD_DEMOTED
				    - time(NULL) < timeout)
					timeout = p->stats.last_updown +
					    INTERVAL_HOLD_DEMOTED - time(NULL);
			}

d951 3
@


1.282
log
@fatalx instead of fatal because errno is not set of pipe is closed. OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.281 2008/05/08 07:43:02 henning Exp $ */
d2196 1
a2196 1
				if (mp_safi < 1 || mp_safi > 3) {
d2199 3
a2201 4
					    "mp_safi %u illegal", mp_safi);
					return (-1);
				}
				peer->capa.peer.mp_v4 = mp_safi;
d2204 1
a2204 1
				if (mp_safi < 1 || mp_safi > 3) {
d2207 3
a2209 4
					    "mp_safi %u illegal", mp_safi);
					return (-1);
				}
				peer->capa.peer.mp_v6 = mp_safi;
@


1.281
log
@take advantage of the timewheel: instead of checking each an every
timer, just get the first off the queue and check wether it is due
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.280 2008/05/08 06:52:13 henning Exp $ */
d2262 1
a2262 1
		fatal("session_dispatch_imsg: pipe closed");
@


1.280
log
@change timer internals so that we use a timewheel (tailq, sorted by expiry
so that the timer that will expire first is always the first element,
and so on). will make the checking a bit faster and moreelegant and more
conveniant. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.279 2007/12/23 18:56:17 henning Exp $ */
d410 1
d413 31
a443 19
			if (timer_due(p, Timer_Hold))
				bgp_fsm(p, EVNT_TIMER_HOLDTIME);
			if (timer_due(p, Timer_ConnectRetry))
				bgp_fsm(p, EVNT_TIMER_CONNRETRY);
			if (timer_due(p, Timer_Keepalive))
				bgp_fsm(p, EVNT_TIMER_KEEPALIVE);
			if (timer_due(p, Timer_IdleHold))
				bgp_fsm(p, EVNT_START);
			if (timer_due(p, Timer_IdleHoldReset)) {
				p->IdleHoldTime /= 2;
				if (p->IdleHoldTime <=
				    INTERVAL_IDLE_HOLD_INITIAL) {
					p->IdleHoldTime =
					    INTERVAL_IDLE_HOLD_INITIAL;
					timer_stop(p, Timer_IdleHoldReset);
					p->errcnt = 0;
				} else
					timer_set(p, Timer_IdleHoldReset,
					    p->IdleHoldTime);
a444 1

@


1.279
log
@provide timer_nextduein, which provides the number of seconds until the
next timer expires.
use that in the session engine's mainloop, which simplifies it and
removes the last bits of timer internals knowledge from anywhere outside
timer.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.278 2007/12/23 16:42:45 henning Exp $ */
d320 1
d590 1
@


1.278
log
@use timer_running (with left = NULL, which the last commit made possible)
instead of timer_get and checking manually
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.277 2007/12/20 17:08:48 henning Exp $ */
a185 1
	time_t			 nextaction;
a397 1
		nextaction = time(NULL) + 240;	/* loop every 240s at least */
a398 1

a403 1

d405 1
d408 2
d432 3
a434 13
			/* XXX set nextaction to the first expiring timer */
			if (p->ConnectRetryTimer &&
			    p->ConnectRetryTimer < nextaction)
				nextaction = p->ConnectRetryTimer;
			if (p->HoldTimer && p->HoldTimer < nextaction)
				nextaction = p->HoldTimer;
			if (p->KeepaliveTimer && p->KeepaliveTimer < nextaction)
				nextaction = p->KeepaliveTimer;
			if (p->IdleHoldTimer && p->IdleHoldTimer < nextaction)
				nextaction = p->IdleHoldTimer;
			if (p->IdleHoldResetTimer &&
			    p->IdleHoldResetTimer < nextaction)
				nextaction = p->IdleHoldResetTimer;
d441 4
a444 4
				if (p->stats.last_updown +
				    INTERVAL_HOLD_DEMOTED < nextaction)
					nextaction = p->stats.last_updown +
					    INTERVAL_HOLD_DEMOTED;
a480 1
		timeout = nextaction - time(NULL);
@


1.277
log
@rework timers.
stop changing tienmr values directly, always use new
timer_(get/set/stop/running) functions. preparation for more to come :)
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.276 2007/06/19 09:44:55 pyr Exp $ */
d995 1
a995 2
		time_t	*t = timer_get(p, Timer_IdleHold);
		if (*t > 0) {
@


1.276
log
@Ignore SIGHUP in bgpd's children to allow the use of pkill -1 bgpd for
reloading.

``yeah that is good'' henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.275 2007/05/29 02:27:05 claudio Exp $ */
a58 1
int	timer_due(time_t);
d307 1
a307 1
					p->IdleHoldTimer = time(NULL);
d412 1
a412 1
			if (timer_due(p->HoldTimer))
d414 1
a414 1
			if (timer_due(p->ConnectRetryTimer))
d416 1
a416 1
			if (timer_due(p->KeepaliveTimer))
d418 1
a418 1
			if (timer_due(p->IdleHoldTimer))
d420 1
a420 1
			if (timer_due(p->IdleHoldResetTimer)) {
d426 1
a426 1
					p->IdleHoldResetTimer = 0;
d429 2
a430 2
					p->IdleHoldResetTimer =
					    time(NULL) + p->IdleHoldTime;
d433 1
a433 1
			/* set nextaction to the first expiring timer */
d447 1
a447 1
			/* carp demotion */
d613 1
a613 1
		p->IdleHoldTimer = 0;		/* no autostart */
d615 1
a615 1
		p->IdleHoldTimer = time(NULL);	/* start ASAP */
d636 3
a638 3
			peer->HoldTimer = 0;
			peer->KeepaliveTimer = 0;
			peer->IdleHoldTimer = 0;
d661 1
a661 1
				peer->ConnectRetryTimer = 0;
d665 1
a665 1
				peer->ConnectRetryTimer = 0;
d668 2
a669 2
				peer->ConnectRetryTimer =
				    time(NULL) + INTERVAL_CONNECTRETRY;
d687 1
a687 1
			peer->ConnectRetryTimer = 0;
d693 2
a694 2
			peer->ConnectRetryTimer =
			    time(NULL) + INTERVAL_CONNECTRETRY;
d699 2
a700 2
			peer->ConnectRetryTimer =
			    time(NULL) + INTERVAL_CONNECTRETRY;
d716 1
a716 1
			peer->ConnectRetryTimer = 0;
d722 2
a723 2
			peer->ConnectRetryTimer =
			    time(NULL) + INTERVAL_CONNECTRETRY;
d728 2
a729 2
			peer->ConnectRetryTimer =
			    time(NULL) + peer->holdtime;
d749 2
a750 2
			peer->ConnectRetryTimer =
			    time(NULL) + INTERVAL_CONNECTRETRY;
d772 1
a772 1
				peer->IdleHoldTimer = time(NULL);
a861 8
int
timer_due(time_t timer)
{
	if (timer > 0 && timer <= time(NULL))
		return (1);
	return (0);
}

d866 1
a866 1
		peer->HoldTimer = time(NULL) + peer->holdtime;
d868 1
a868 1
		peer->HoldTimer = 0;
d875 1
a875 1
		peer->KeepaliveTimer = time(NULL) + peer->holdtime / 3;
d877 1
a877 1
		peer->KeepaliveTimer = 0;
d918 4
a921 4
		peer->ConnectRetryTimer = 0;
		peer->KeepaliveTimer = 0;
		peer->HoldTimer = 0;
		peer->IdleHoldResetTimer = 0;
d930 1
a930 1
			peer->IdleHoldTimer = time(NULL) + peer->IdleHoldTime;
d953 1
a953 1
		peer->IdleHoldResetTimer = time(NULL) + peer->IdleHoldTime;
d994 7
a1000 5
	if (p != NULL && p->state == STATE_IDLE && p->errcnt < 2 &&
	    p->IdleHoldTimer > 0) {
		/* fast reconnect after clear */
		p->passive = 1;
		bgp_fsm(p, EVNT_START);
d1968 1
a1968 1
			peer->IdleHoldTimer = time(NULL);	/* no punish */
d2528 2
a2529 3
						p->IdleHoldTimer =
						    time(NULL) + 60 *
						    p->conf.max_prefix_restart;
@


1.275
log
@Correctly encode the End-of-RIB marker capability. It is just 2 bytes not
4. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.274 2007/05/15 14:47:36 claudio Exp $ */
d247 1
@


1.274
log
@draft-ietf-idr-restart -> RFC 4724 and bump draft-ietf-idr-as4bytes to
version 13.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.273 2007/04/23 13:04:24 claudio Exp $ */
d1376 2
a1377 2
	if (p->capa.ann.restart) {	/* 4 bytes data */
		u_char	c[4];
d1379 4
a1382 4
		bzero(&c, 4);
		c[0] = 0x80;
		errs += session_capa_add(p, opb, CAPA_RESTART, 4, &optparamlen);
		errs += buf_add(opb, &c, 4);
@


1.273
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.272 2007/03/28 11:53:48 claudio Exp $ */
d1375 1
a1375 1
	/* End-of-RIB marker, draft-ietf-idr-restart */
d1385 1
a1385 1
	/* 4-bytes AS numbers, draft-ietf-idr-as4bytes-12 */
@


1.272
log
@IPv6 ttl setting via IPV6_HOPLIMIT no longer works. Switch to
IPV6_UNICAST_HOPS which does the same thing and does not fail.
OK henning@@ found by Jon Morby
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.271 2007/03/16 14:06:57 claudio Exp $ */
d35 1
d86 1
a86 1
int	parse_capabilities(struct peer *, u_char *, u_int16_t);
d1251 1
d1385 9
d1402 4
a1405 1
	msg.myas = htons(conf->as);
d1833 1
a1833 1
	u_int16_t	 as, msglen;
d1835 1
a1835 1
	u_int32_t	 bgpid;
d1863 3
a1865 2
	memcpy(&as, p, sizeof(as));
	p += sizeof(as);
d1868 2
a1869 2
	if (peer->conf.cloned && !peer->conf.remote_as) {
		peer->conf.remote_as = ntohs(as);
a1872 7
	if (peer->conf.remote_as != ntohs(as)) {
		log_peer_warnx(&peer->conf, "peer sent wrong AS %u", ntohs(as));
		session_notification(peer, ERR_OPEN, ERR_OPEN_AS, NULL, 0);
		change_state(peer, STATE_IDLE, EVNT_RCVD_OPEN);
		return (-1);
	}

d1951 2
a1952 1
			if (parse_capabilities(peer, op_val, op_len) == -1) {
d1980 8
d2123 5
d2151 1
a2151 1
parse_capabilities(struct peer *peer, u_char *d, u_int16_t dlen)
d2159 1
d2229 11
d2791 1
@


1.271
log
@A few more s/2858/4760/ and use RFC <number> everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.270 2007/02/22 08:34:18 henning Exp $ */
d1165 1
a1165 1
		if (setsockopt(p->fd, IPPROTO_IPV6, IPV6_HOPLIMIT, &ttl,
@


1.270
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.269 2007/02/22 08:26:45 henning Exp $ */
d1064 1
a1064 1
	 * we do not need the overcomplicated collision detection rfc1771
d1187 1
a1187 1
	/* set precedence, see rfc1771 appendix 5 */
d1359 1
a1359 1
	/* multiprotocol extensions, RFC 2858 */
d2166 1
a2166 1
		case CAPA_MP:			/* RFC 2858 */
@


1.269
log
@do not try to set IP_TTL on non-INET listening sockets, it's not going
to work on INET6...
non-fatal error, so in pratice this just avoids a misleading error msg
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.268 2007/01/26 17:40:49 claudio Exp $ */
d942 2
a943 1
		if (peer->state == STATE_NONE || peer->state == STATE_ESTABLISHED) {
d1357 1
a1357 1
	}	
d1388 1
a1388 1
	}	
@


1.268
log
@Massiv rework of the control imsg flow. Main changes:
- dedicated pipe between the SE and the RDE for control messages
- restartable RB tree dumps in the RDE
- queuing limits both in the SE and RDE
The result is a dramatic decrease of memory consumption on operations like
bgpctl show rib. Previously all messages where first stored in the RDE
then passed to the SE where they got queued in case bgpctl was not fast enough.
Now only a small number of messages is generated and passed to the SE and
the SE has an additional limit instead of acting like an infinite buffer.
Without this the bgpd on bgpd.networx.ch would not survive a single minute.
looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.267 2007/01/23 17:41:22 claudio Exp $ */
d153 2
a154 2
		if (setsockopt(la->fd, IPPROTO_IP, IP_TTL, &ttl,
		    sizeof(ttl)) == -1) {
@


1.267
log
@Typo in fatal() message found by dunceor @@ gmail dot com
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.266 2006/12/05 12:08:13 henning Exp $ */
d49 4
a52 3
#define	PFD_SOCK_CTL		2
#define	PFD_SOCK_RCTL		3
#define PFD_LISTENERS_START	4
d105 1
d180 2
a181 1
    struct mrt_head *m_l, int pipe_m2s[2], int pipe_s2r[2], int pipe_m2r[2])
d190 1
d249 1
d254 1
d258 1
d381 12
d518 6
d2452 1
a2452 1
			if (idx != PFD_PIPE_ROUTE)
@


1.266
log
@implement the ttl security hack. since the pc slaves fear the word hack,
they call it "Generalized TTL Security Mechanism" officially, RFC 3682.
manpage with help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.265 2006/11/28 19:21:15 reyk Exp $ */
d1191 1
a1191 1
		fatal("fnctl F_GETFL");
d1199 1
a1199 1
		fatal("fnctl F_SETFL");
@


1.265
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.264 2006/11/06 14:07:35 henning Exp $ */
d122 1
d150 7
d1115 14
a1128 2
	if (p->conf.ebgp && p->conf.remote_addr.af == AF_INET)
		/* set TTL to foreign router's distance - 1=direct n=multihop */
d1135 1
d1145 7
@


1.264
log
@fix pasto; only announce restart capability when announcing the restart
capability is enabled, not when annoucing the refresh capability is
enabled...
Alex Hunsaker <badalex@@gmail.com> ran into that issue
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.263 2006/09/19 13:04:01 henning Exp $ */
d2325 1
a2325 1
			    (kif->link_state == LINK_STATE_UP ||
@


1.263
log
@make buffer_grow always return a valid struct buf; the contained buffer
might be NULL on realloc failure tho. all users check buffer size before
using the buffer, so this is not a problem.
makes error handling much easier. ease the capabilities code big time.
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.262 2006/08/27 16:57:19 henning Exp $ */
d1320 1
a1320 1
	if (p->capa.ann.refresh) {	/* 4 bytes data */
@


1.262
log
@in the restart capability (that we do not actually send yet), set the
MSB in the first byte, not the LSB to indicate the peer must not wait
before sending us updates
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.261 2006/08/27 16:19:18 henning Exp $ */
d67 2
a68 2
u_int8_t	 session_capa_add(struct peer *, struct buf *, u_int8_t,
		    u_int8_t);
d1198 1
a1198 1
u_int8_t
d1200 1
a1200 1
    u_int8_t capa_len)
d1208 1
a1208 1
		return (0);
d1213 2
a1214 4
	if (errs)
		return (0);
	else
		return (tot_len);
d1296 1
a1296 1
	u_int8_t		 optparamlen = 0, op_len;
d1307 2
a1308 7
		if ((op_len = session_capa_add(p, opb, CAPA_MP, 4)) == 0)
			errs++;
		else {
			optparamlen += op_len;
			errs += session_capa_add_mp(opb, AFI_IPv4,
			    p->capa.ann.mp_v4);
		}
d1311 2
a1312 7
		if ((op_len = session_capa_add(p, opb, CAPA_MP, 4)) == 0)
			errs++;
		else {
			optparamlen += op_len;
			errs += session_capa_add_mp(opb, AFI_IPv6,
			    p->capa.ann.mp_v6);
		}
a1314 1

d1316 2
a1317 6
	if (p->capa.ann.refresh) {	/* no data */
		if ((op_len = session_capa_add(p, opb, CAPA_REFRESH, 0)) == 0)
			errs++;
		else
			optparamlen += op_len;
	}
d1321 1
a1321 11
		if ((op_len = session_capa_add(p, opb, CAPA_RESTART, 4)) == 0)
			errs++;
		else {
			u_char	c[4];

			bzero(&c, 4);
			c[0] = 0x80;
			errs += buf_add(opb, &c, 4);
			optparamlen += op_len;
		}
	}		
d1323 4
a1326 4
	if (errs > 0) {
		buf_free(opb);
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
d1330 2
a1331 2

	if ((buf = session_newmsg(OPEN, len)) == NULL) {
@


1.261
log
@fix a small logic botch in session_accept() in the fast reconnect logic,
to check wether a session was put in IDLE manually by the operator or
by bgpd itself as result of a fatal session error we were looking at the
wrong timer, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.260 2006/08/27 16:11:05 henning Exp $ */
d1344 1
a1344 1
			c[0] = 0x01;
@


1.260
log
@add code to announce the restart capability according to
draft-ietf-idr-restart. Do not announce actual restart capabilities,
so that this only serves as indicator that we are capable of sending
and receiving the End-of-RIB marker.
leave disabled for now, since the code to actually send the EoR-marker
is currently ifdef'd out (to be fixed soon) and we wanna play safe for
4.0. and juniper doesn't support that capability (which is not a problem
per se) and at the same time has its capability negotiation code completely
fucked up, if a capability is rejected they don't indicate WHICH capability
they reject (which makes that a problem, tho still a small one and we cope).
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.259 2006/08/27 14:00:15 henning Exp $ */
d968 1
a968 1
	    p->ConnectRetryTimer > 0) {
@


1.259
log
@missing htons() in session_rrefresh()
no surprise sending route refresh requests didn't work on my i386 routers,
i think I originally hacked & tested this on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.258 2006/08/27 13:44:03 henning Exp $ */
d1195 1
d1336 14
d2074 5
d2174 4
@


1.258
log
@change how we advertise capabilities.
we used to put all capability attributes into one optional attribute. this
is legal.
I recentlu observed that basically all other implementations use one
optional attribute per capability attribute. this difference might explain
why we - in some cases - saw "unsupoorted capabiliy" notifications from
neighbors without the capability in question in the data part. of course
that makes capability negotiation a little hard...
so switch us to use one optional attribute per capability as well, and
ease the code a bit while there, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.257 2006/08/04 12:01:48 henning Exp $ */
d1502 1
@


1.257
log
@add "restart" to max-prefix, allows sessions suspended due to reaching
max-prefix to be restarted automagically after a given number of minutes
requested by "Sylwester S. Biernacki" <obeer@@obeer.com>, manpage help jmc,
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.256 2006/07/30 16:27:28 henning Exp $ */
d67 3
a69 1
int	session_capa_mp_add(struct buf *, u_int16_t, u_int8_t);
d1197 21
d1219 1
a1219 1
session_capa_mp_add(struct buf *buf, u_int16_t afi, u_int8_t safi)
d1221 1
a1221 1
	u_int8_t		 capa_code, capa_len, pad = 0;
a1224 4
	capa_code = CAPA_MP;
	capa_len = 4;
	errs += buf_add(buf, &capa_code, sizeof(capa_code));
	errs += buf_add(buf, &capa_len, sizeof(capa_len));
d1294 1
d1297 1
a1297 2
	u_int8_t		 op_type, op_len = 0, optparamlen = 0;
	u_int8_t		 capa_code, capa_len;
d1300 6
d1307 19
a1325 4
	if (p->capa.ann.mp_v4)
		op_len += 2 + 4;	/* 1 code + 1 len + 4 data */
	if (p->capa.ann.mp_v6)
		op_len += 2 + 4;	/* 1 code + 1 len + 4 data */
d1328 12
a1339 2
	if (p->capa.ann.refresh)
		op_len += 2 + 0;	/* 1 code + 1 len, no data */
a1340 2
	if (op_len > 0)
		optparamlen = sizeof(op_type) + sizeof(op_len) + op_len;
d1363 2
a1364 12
	if (optparamlen) {
		op_type = OPT_PARAM_CAPABILITIES;
		errs += buf_add(buf->buf, &op_type, sizeof(op_type));
		errs += buf_add(buf->buf, &op_len, sizeof(op_len));

		/* multiprotocol extensions, RFC 2858 */
		if (p->capa.ann.mp_v4)
			errs += session_capa_mp_add(buf->buf, AFI_IPv4,
			    p->capa.ann.mp_v4);
		if (p->capa.ann.mp_v6)
			errs += session_capa_mp_add(buf->buf, AFI_IPv6,
			    p->capa.ann.mp_v6);
d1366 1
a1366 8
		/* route refresh, RFC 2918 */
		if (p->capa.ann.refresh) {
			capa_code = CAPA_REFRESH;
			capa_len = 0;
			errs += buf_add(buf->buf, &capa_code, sizeof(capa_code));
			errs += buf_add(buf->buf, &capa_len, sizeof(capa_len));
		}
	}
@


1.256
log
@there's a nasty little race condition when the neigbor reached max-prefix
and at the same time there is messages from him in the socket buffer,
because we process the imsgs from the RDE (which tells us max-prefix was
reached) first, and put the session to IDLE, close connection and
deallocate buffers. if we then try to read from the socket and write to the
deallocated buffer we crash, of course. so check wether we have a buffer
before reading.
crash seen and fix tested by "Sylwester S. Biernacki" <obeer@@obeer.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.255 2006/07/28 15:04:34 henning Exp $ */
d2416 4
@


1.255
log
@factor out the code to build bgp messages, ok claudio a long time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.254 2006/06/18 13:54:34 henning Exp $ */
d1553 1
a1553 1
	if (pfd->revents & POLLIN) {
@


1.254
log
@fix a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.253 2006/06/18 13:54:01 henning Exp $ */
d68 2
d1213 58
d1274 1
a1275 2
	struct buf		*buf;
	struct mrt		*mrt;
a1276 1
	int			 errs = 0;
d1279 1
d1295 5
a1299 3
	memset(&msg.header.marker, 0xff, sizeof(msg.header.marker));
	msg.header.len = htons(len);
	msg.header.type = OPEN;
d1309 5
a1313 12
	if ((buf = buf_open(len)) == NULL) {
		bgp_fsm(p, EVNT_CON_FATAL);
		return;
	}
	errs += buf_add(buf, &msg.header.marker, sizeof(msg.header.marker));
	errs += buf_add(buf, &msg.header.len, sizeof(msg.header.len));
	errs += buf_add(buf, &msg.header.type, sizeof(msg.header.type));
	errs += buf_add(buf, &msg.version, sizeof(msg.version));
	errs += buf_add(buf, &msg.myas, sizeof(msg.myas));
	errs += buf_add(buf, &msg.holdtime, sizeof(msg.holdtime));
	errs += buf_add(buf, &msg.bgpid, sizeof(msg.bgpid));
	errs += buf_add(buf, &msg.optparamlen, sizeof(msg.optparamlen));
d1317 2
a1318 2
		errs += buf_add(buf, &op_type, sizeof(op_type));
		errs += buf_add(buf, &op_len, sizeof(op_len));
d1322 1
a1322 1
			errs += session_capa_mp_add(buf, AFI_IPv4,
d1325 1
a1325 1
			errs += session_capa_mp_add(buf, AFI_IPv6,
d1332 2
a1333 2
			errs += buf_add(buf, &capa_code, sizeof(capa_code));
			errs += buf_add(buf, &capa_len, sizeof(capa_len));
d1337 8
a1344 19
	if (errs == 0) {
		LIST_FOREACH(mrt, &mrthead, entry) {
			if (mrt->type != MRT_ALL_OUT)
				continue;
			if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
			    mrt->peer_id == p->conf.id ||
			    mrt->group_id == p->conf.groupid)
				mrt_dump_bgp_msg(mrt, buf->buf, len,
				    p, conf);
		}

		if (buf_close(&p->wbuf, buf) == -1) {
			log_peer_warn(&p->conf, "session_open buf_close");
			buf_free(buf);
			bgp_fsm(p, EVNT_CON_FATAL);
			return;
		}
	} else {
		buf_free(buf);
d1353 1
a1353 1
session_keepalive(struct peer *peer)
d1355 1
a1355 5
	struct msg_header	 msg;
	struct buf		*buf;
	struct mrt		*mrt;
	ssize_t			 len;
	int			 errs = 0;
d1357 3
a1359 8
	len = MSGSIZE_KEEPALIVE;

	memset(&msg.marker, 0xff, sizeof(msg.marker));
	msg.len = htons(len);
	msg.type = KEEPALIVE;

	if ((buf = buf_open(len)) == NULL) {
		bgp_fsm(peer, EVNT_CON_FATAL);
a1361 3
	errs += buf_add(buf, &msg.marker, sizeof(msg.marker));
	errs += buf_add(buf, &msg.len, sizeof(msg.len));
	errs += buf_add(buf, &msg.type, sizeof(msg.type));
d1363 2
a1364 24
	if (errs > 0) {
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
		return;
	}

	LIST_FOREACH(mrt, &mrthead, entry) {
		if (mrt->type != MRT_ALL_OUT)
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == peer->conf.id ||
		    mrt->group_id == peer->conf.groupid)
			mrt_dump_bgp_msg(mrt, buf->buf, len, peer, conf);
	}

	if (buf_close(&peer->wbuf, buf) == -1) {
		log_peer_warn(&peer->conf, "session_keepalive buf_close");
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
		return;
	}

	start_timer_keepalive(peer);
	peer->stats.msg_sent_keepalive++;
d1371 1
a1371 5
	struct msg_header	 msg;
	struct buf		*buf;
	struct mrt		*mrt;
	ssize_t			 len;
	int			 errs = 0;
d1381 1
a1381 7
	len = MSGSIZE_HEADER + datalen;

	memset(&msg.marker, 0xff, sizeof(msg.marker));
	msg.len = htons(len);
	msg.type = UPDATE;

	if ((buf = buf_open(len)) == NULL) {
a1384 4
	errs += buf_add(buf, &msg.marker, sizeof(msg.marker));
	errs += buf_add(buf, &msg.len, sizeof(msg.len));
	errs += buf_add(buf, &msg.type, sizeof(msg.type));
	errs += buf_add(buf, data, datalen);
d1386 3
a1388 2
	if (errs > 0) {
		buf_free(buf);
d1393 1
a1393 12
	LIST_FOREACH(mrt, &mrthead, entry) {
		if (mrt->type != MRT_ALL_OUT && mrt->type != MRT_UPDATE_OUT)
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == p->conf.id ||
		    mrt->group_id == p->conf.groupid)
			mrt_dump_bgp_msg(mrt, buf->buf, len, p, conf);
	}

	if (buf_close(&p->wbuf, buf) == -1) {
		log_peer_warn(&p->conf, "session_update: buf_close");
		buf_free(buf);
d1403 1
a1403 1
session_notification(struct peer *peer, u_int8_t errcode, u_int8_t subcode,
d1406 2
a1407 5
	struct msg_header	 msg;
	struct buf		*buf;
	struct mrt		*mrt;
	ssize_t			 len;
	int			 errs = 0;
d1410 1
a1410 1
	if (peer->stats.last_sent_errcode)	/* some notifctn already sent */
d1413 3
a1415 8
	len = MSGSIZE_NOTIFICATION_MIN + datalen;

	memset(&msg.marker, 0xff, sizeof(msg.marker));
	msg.len = htons(len);
	msg.type = NOTIFICATION;

	if ((buf = buf_open(len)) == NULL) {
		bgp_fsm(peer, EVNT_CON_FATAL);
d1418 2
a1419 4
	errs += buf_add(buf, &msg.marker, sizeof(msg.marker));
	errs += buf_add(buf, &msg.len, sizeof(msg.len));
	errs += buf_add(buf, &msg.type, sizeof(msg.type));
	errs += buf_add(buf, &errcode, sizeof(errcode));
d1421 1
a1421 1
		errs += buf_add(buf, &null8, sizeof(null8));
d1423 1
a1423 1
		errs += buf_add(buf, &subcode, sizeof(subcode));
d1426 1
a1426 1
		errs += buf_add(buf, data, datalen);
d1429 3
a1431 2
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
d1435 2
a1436 13
	LIST_FOREACH(mrt, &mrthead, entry) {
		if (mrt->type != MRT_ALL_OUT)
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == peer->conf.id ||
		    mrt->group_id == peer->conf.groupid)
			mrt_dump_bgp_msg(mrt, buf->buf, len, peer, conf);
	}

	if (buf_close(&peer->wbuf, buf) == -1) {
		log_peer_warn(&peer->conf, "session_notification: buf_close");
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
d1440 3
a1442 3
	peer->stats.msg_sent_notification++;
	peer->stats.last_sent_errcode = errcode;
	peer->stats.last_sent_suberr = subcode;
d1460 1
a1460 1
session_rrefresh(struct peer *peer, u_int16_t afi, u_int8_t safi)
d1462 1
a1462 4
	struct msg_header	 msg;
	struct buf		*buf;
	struct mrt		*mrt;
	ssize_t			 len;
d1466 2
a1467 8
	len = MSGSIZE_RREFRESH;

	memset(&msg.marker, 0xff, sizeof(msg.marker));
	msg.len = htons(len);
	msg.type = RREFRESH;

	if ((buf = buf_open(len)) == NULL) {
		bgp_fsm(peer, EVNT_CON_FATAL);
d1470 4
a1473 6
	errs += buf_add(buf, &msg.marker, sizeof(msg.marker));
	errs += buf_add(buf, &msg.len, sizeof(msg.len));
	errs += buf_add(buf, &msg.type, sizeof(msg.type));
	errs += buf_add(buf, &afi, sizeof(afi));
	errs += buf_add(buf, &null8, sizeof(null8));
	errs += buf_add(buf, &safi, sizeof(safi));
d1476 3
a1478 2
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
d1482 2
a1483 13
	LIST_FOREACH(mrt, &mrthead, entry) {
		if (mrt->type != MRT_ALL_OUT)
			continue;
		if ((mrt->peer_id == 0 && mrt->group_id == 0) ||
		    mrt->peer_id == peer->conf.id ||
		    mrt->group_id == peer->conf.groupid)
			mrt_dump_bgp_msg(mrt, buf->buf, len, peer, conf);
	}

	if (buf_close(&peer->wbuf, buf) == -1) {
		log_peer_warn(&peer->conf, "session_rrefresh buf_close");
		buf_free(buf);
		bgp_fsm(peer, EVNT_CON_FATAL);
d1487 1
a1487 1
	peer->stats.msg_sent_rrefresh++;
@


1.253
log
@make cloned sessions appear with RECONF_REINIT so they are treated like
peers added at runtime
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.252 2006/06/17 14:06:09 henning Exp $ */
d867 1
a867 1
		/* carp demotion first. new peers handled in peer_init */
@


1.252
log
@implement carp demotion control for bgpd.
sessions can be configured to modify the carp demotion counter for a
given interface group (usually, "carp", which has all carp interfaces)
when the session is not established. once the session is established for
60 seconds, the demotion is cleared.
this, used correctly, can prevent a bgpd-box which lost all sessions (and
thus has no routes) to be carp master, while the backup has sessions.
thought through and partially hacked on a drive from calgary to vancouver
with ryan, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.251 2006/06/12 12:45:14 henning Exp $ */
d2619 1
@


1.251
log
@in session_setup_socket(), to take address family dependent action
(set v4 TTL/v6 hoplimit, v4 TOS), do not look at remote sockaddr's af,
since that is not set at the first connection attempt yet. instead, use
the configured remote address' af.
problem spotted & my fix tested by Leen Besselink <leen@@consolejunkie.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.250 2006/06/10 16:32:38 henning Exp $ */
d84 1
d292 3
d415 11
d578 8
d867 5
d2303 3
a2305 2
			/* find ones to be deleted */
			for (p = peers; p != NULL; p = p->next)
d2309 4
d2771 15
@


1.250
log
@back in the dark age, carp interfaces were very strange - and we had to
detect them looking at their name, beginning with carp.
these days, we can just check for the iftype to be IFT_CARP.
wanted to do this for some time and kept forgetting. from the airplane over two
weeks ago, forgotten in a secondary tree again...
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.249 2006/05/27 21:24:36 claudio Exp $ */
d1075 1
a1075 1
	if (p->conf.ebgp && p->sa_remote.ss_family == AF_INET)
d1084 1
a1084 1
	if (p->conf.ebgp && p->sa_remote.ss_family == AF_INET6)
d1102 1
a1102 1
	if (p->sa_remote.ss_family == AF_INET &&
@


1.249
log
@Pass a IMSG_CTL_RESULT messgae back to bgpctl on reloads to indicate if
the reload was successful or not. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.248 2006/05/27 15:43:13 claudio Exp $ */
d25 1
d2321 1
a2321 1
			    strncmp(kif->ifname, "carp", 4)));
@


1.248
log
@Cleanup with lint. Make the poll fd indexes unsigned and because of that
control_accept should also return a unsigned int. Remove old prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.247 2006/05/23 12:11:38 henning Exp $ */
d2397 1
@


1.247
log
@allow bgpd to request a route refresh from a neighbor if that neighbor
announced route refresh capabilities
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.246 2006/03/22 10:18:49 claudio Exp $ */
a78 1
int	parse_keepalive(struct peer *);
d166 2
a167 2
	int			 nfds, i, j, timeout;
	int			 idx_peers, idx_listeners, idx_mrts;
@


1.246
log
@Add a new SHOW imsg to send optional attributes to bgpctl. This can be used
to show communites in bgpctl output. Only send these messages if it they are
requested to reduce the overhead for simple listings. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.245 2006/03/15 11:33:42 claudio Exp $ */
d72 1
d1450 66
@


1.245
log
@Allow the control socket to be changed on the command line. Useful if you
need to run multiple bgpds on a single box to simulate a IX. This helped
me massivly debugging error reports. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.244 2006/02/08 12:36:29 henning Exp $ */
d2321 1
@


1.244
log
@fix logic both in the decision when to re-init the capabilities negotiation
structures
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.243 2006/01/24 10:08:16 henning Exp $ */
d197 1
a197 1
	if ((csock = control_init(0, SOCKET_NAME)) == -1)
@


1.243
log
@missing space in error message, and make it slightly betterer while there
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.242 2006/01/24 10:03:44 henning Exp $ */
d876 1
a876 1
		if (event != EVNT_RCVD_OPEN) {	/* capa negotiation */
@


1.242
log
@introduce a second control socket, which is restricted to certain messages,
nameley the show ones. needed for looking glass style applications,
monitoring etc. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.241 2006/01/03 22:49:17 claudio Exp $ */
d1969 3
a1971 2
				    "parse_notification: capa_len %u exceeds"
				    "remaining msg length", capa_len);
@


1.241
log
@Track some (memory) statistics in the RDE. Accessible via bgpctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.240 2006/01/03 16:49:24 claudio Exp $ */
d49 2
a50 1
#define PFD_LISTENERS_START	3
d95 1
a95 1
int			 csock = -1;
d197 4
a200 1
	if ((csock = control_init()) == -1)
d240 2
a241 1
	csock = control_listen();
d359 2
d473 6
a478 1
			ctl_cnt += control_accept(csock);
d531 2
a532 1
	control_shutdown();
@


1.240
log
@Plug some mem leaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.239 2005/12/08 15:55:26 claudio Exp $ */
d2307 1
@


1.239
log
@When parsing open messages enforce that the optional parameter length is
equal to the size of the rest of the message and not only enforcing that
no overflow happens. Found via regress test. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.238 2005/11/01 10:58:29 claudio Exp $ */
d251 1
@


1.238
log
@Switch from the per peer filter set list to a filter-only solution.
The default filter_sets are converted into match filter rules that get
evaluated first. Simplifies code massively -- mainly the config reload
part -- and makes softreconfig out a piece of cake.  "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.237 2005/10/19 10:42:06 henning Exp $ */
d1776 1
a1776 1
	if (optparamlen > msglen - MSGSIZE_OPEN_MIN) {
@


1.237
log
@new keyword "down" in neighbor spec, when givenm, the session is not
started on bgpd startup but stays in IDLE. requested by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.236 2005/10/19 09:36:51 henning Exp $ */
a2076 2
struct filter_set_head	*session_set;

a2086 1
	struct filter_set	*s;
a2137 2
			TAILQ_INIT(&p->conf.attrset);
			session_set = &p->conf.attrset;
a2225 1
			session_set = NULL;
a2228 12
		case IMSG_FILTER_SET:
			if (idx != PFD_PIPE_MAIN)
				fatalx("reconf request not from parent");
			if (session_set == NULL) {
				log_warnx("IMSG_FILTER_SET unexpected");
				break;
			}
			if ((s = malloc(sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			memcpy(s, imsg.data, sizeof(struct filter_set));
			TAILQ_INSERT_TAIL(session_set, s, entry);
			break;
a2575 1
	struct filter_set	*s;
a2579 6

	TAILQ_FOREACH(s, &p->conf.attrset, entry) {
		if (imsg_compose(ibuf_rde, IMSG_FILTER_SET, p->conf.id, 0, -1,
		    s, sizeof(struct filter_set)) == -1)
			fatalx("imsg_compose error");
	}
@


1.236
log
@only allow connects in IDLE when the ConnectRetryTimer is running, aka
we intend to reconnect. fallout from fast reconnect. misbehaviour noticed
by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.235 2005/09/20 13:31:53 henning Exp $ */
d544 4
a547 1
	p->IdleHoldTimer = time(NULL);	/* start ASAP */
@


1.235
log
@let "bgpctl network show" print v6 addresses correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.234 2005/09/19 16:15:54 henning Exp $ */
d917 2
a918 1
	if (p != NULL && p->state == STATE_IDLE && p->errcnt < 2) {
@


1.234
log
@implement fast reconnects
when a peer drops to IDLE, we have to force him in IDLE for some time to
prevent fast flapping. however, the forced idle time is annoying when the
connection could be re-established immediately, i. e. bgpctl nei $peer clear
or similar.
implement an error counter per peer, increased every time we receive a
notification. when we are in state IDLE and get a connection from the peer
in question, check if the error counter is 1 or smaller. if so, change state
to active and accept the connection, otherwise keep the current behaviour
and reject the connection.
the error counter gets scaled back by the IdleHoldResetTimer that scales the
IdleHoldTime back as well
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.233 2005/09/08 10:46:40 henning Exp $ */
d2321 1
@


1.233
log
@fix reloads where capbilities change
when a new peer in initialized, the configured capailities are copied.
this copy is modified as part of the capabilities negotiation.
now if teh session drops we want to re-negotiate capabilities at the next
establishment, last not least because the configured capabilities might
have changed in between (that's how I stumbled over it, added v6 shitz)
so copy the configured capabilities over every time a session goes to
IDLE state, unless the reason is EVNT_RCVD_OPEN, because then we're in
capabilities negotiation.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.232 2005/07/24 11:56:37 henning Exp $ */
d382 1
d583 2
a584 1
			else if (peer->conf.passive || peer->conf.template) {
d593 1
d876 1
a876 3
		if (peer->IdleHoldTime > INTERVAL_IDLE_HOLD_INITIAL)
			peer->IdleHoldResetTimer =
			    time(NULL) + peer->IdleHoldTime;
d917 6
d1926 1
@


1.232
log
@we must start the ConnectRetry timer before calling session_connect in
all cases, since session_connect can in turn cause events that cause
state changes in the FSM that reset the ConnectRetryTimer.
debugged with Leen Besselink <leen@@consolejunkie.net> who was seeing
errnously running ConnectRetryTimers in a case with localhost connections
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.231 2005/07/18 11:51:54 dlg Exp $ */
a533 4
	memcpy(&p->capa.ann, &p->conf.capabilities, sizeof(p->capa.ann));
	if (!p->conf.announce_capa)
		session_capa_ann_none(p);

d855 7
@


1.231
log
@fix a block that was indented too far.

ok claudio@@, king bula sez ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.230 2005/07/18 11:41:15 claudio Exp $ */
a590 1
				session_connect(peer);
d593 1
@


1.230
log
@minor nits in session.c, add an additional nconf == NULL check and switch
some fatal()s to fatalx(). All done by dlg@@. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.229 2005/07/01 13:38:14 claudio Exp $ */
d1489 3
a1491 9
				if (errno != EINTR && errno != EAGAIN) {
					log_peer_warn(&p->conf, "read error");
					bgp_fsm(p, EVNT_CON_FATAL);
				}
				return (1);
			}
			if (n == 0) {	/* connection closed */
				bgp_fsm(p, EVNT_CON_CLOSED);
				return (1);
d1493 26
d1520 27
a1546 51
			rpos = 0;
			av = p->rbuf->wpos + n;
			p->stats.last_read = time(NULL);

			/*
			 * session might drop to IDLE -> buffers deallocated
			 * we MUST check rbuf != NULL before use
			 */
			for (;;) {
				if (rpos + MSGSIZE_HEADER > av)
					break;
				if (p->rbuf == NULL)
					break;
				if (parse_header(p, p->rbuf->buf + rpos,
				    &msglen, &msgtype) == -1)
					return (0);
				if (rpos + msglen > av)
					break;
				p->rbuf->rptr = p->rbuf->buf + rpos;

				switch (msgtype) {
				case OPEN:
					bgp_fsm(p, EVNT_RCVD_OPEN);
					p->stats.msg_rcvd_open++;
					break;
				case UPDATE:
					bgp_fsm(p, EVNT_RCVD_UPDATE);
					p->stats.msg_rcvd_update++;
					break;
				case NOTIFICATION:
					bgp_fsm(p, EVNT_RCVD_NOTIFICATION);
					p->stats.msg_rcvd_notification++;
					break;
				case KEEPALIVE:
					bgp_fsm(p, EVNT_RCVD_KEEPALIVE);
					p->stats.msg_rcvd_keepalive++;
					break;
				case RREFRESH:
					parse_refresh(p);
					p->stats.msg_rcvd_rrefresh++;
					break;
				default:	/* cannot happen */
					session_notification(p, ERR_HEADER,
					    ERR_HDR_TYPE, &msgtype, 1);
					log_warnx("received message with "
					    "unknown type %u", msgtype);
					bgp_fsm(p, EVNT_CON_FATAL);
				}
				rpos += msglen;
				if (++processed > MSG_PROCESS_LIMIT)
					break;
d1548 6
a1553 2
			if (p->rbuf == NULL)
				return (1);
d1555 6
a1560 7
			if (rpos < av) {
				left = av - rpos;
				memcpy(&p->rbuf->buf, p->rbuf->buf + rpos,
				    left);
				p->rbuf->wpos = left;
			} else
				p->rbuf->wpos = 0;
@


1.229
log
@Switch filter_sets form SIMPLEQ to TAILQ, needed for upcomming stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.228 2005/06/16 18:43:07 henning Exp $ */
d2134 2
d2143 2
a2144 1
					fatal("king bula sez: expected REINIT");
d2163 1
a2163 1
					fatal("king bula sez: expected KEEP");
@


1.228
log
@use prefixlen2mask() instead of doing the bitshifting by hand; fixes the
zero prefixlen case (32 bit shift on 32 bit val -> undefined result)
spotted by Moritz Grimm and otto
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.227 2005/06/09 12:31:38 claudio Exp $ */
d2127 1
a2127 1
			SIMPLEQ_INIT(&p->conf.attrset);
d2228 1
a2228 1
			SIMPLEQ_INSERT_TAIL(session_set, s, entry);
d2582 1
a2582 1
	SIMPLEQ_FOREACH(s, &p->conf.attrset, entry) {
@


1.227
log
@If there is a problem to connect to a remote peer, do the same log damping
as for other errors. Save the errno and only print a message if the errno
changed. So the log is not filled with "socket error: Connection refused"
when the peer is not yet listening on that address.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.226 2005/06/04 23:31:21 henning Exp $ */
d2521 1
a2521 1
		v4mask = htonl(0xffffffff << (32 - p->conf.remote_masklen));
@


1.226
log
@when the max-prefix limit was exceeded generate a STOP event; we do not
want the session to be restarted automagically in that case.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.225 2005/06/04 23:14:32 henning Exp $ */
d1441 5
a1445 1
					log_peer_warn(&p->conf, "socket error");
@


1.225
log
@call the FSM with a CON_FATAL event after sending notifications in the cases
where it was missing so that we actually close the connection
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.224 2005/06/04 22:58:03 henning Exp $ */
d2345 15
a2359 1
			bgp_fsm(p, EVNT_CON_FATAL);
@


1.224
log
@do not send out suberrorcodes for cease errors; there are none in the
standard
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.223 2005/06/04 22:54:22 henning Exp $ */
d1542 1
d1594 1
d1605 1
d1616 1
d1626 1
d1636 1
d1646 1
d1655 1
d2345 1
@


1.223
log
@use the recorded error code to prevent sending out multiple notifications
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.221 2005/06/04 07:07:34 henning Exp $ */
d1369 1
d1388 4
a1391 1
	errs += buf_add(buf, &subcode, sizeof(subcode));
@


1.222
log
@when sending out a notification record the error code and suberror code in
the peer stats struct, and clear them as soon as the session leaves IDLE
@
text
@d1370 3
@


1.221
log
@relay IMSG_CTL_KROUTE6 as well, from somewhere in BC on the drive to vancouver
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.220 2005/06/02 15:07:02 cloder Exp $ */
d581 3
d1410 1
d1412 2
@


1.220
log
@Use the correct pointer when printing out the error message. OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.219 2005/05/24 17:30:37 claudio Exp $ */
d2272 1
@


1.219
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.218 2005/05/23 22:45:02 henning Exp $ */
d2122 1
a2122 1
					    &la->sa));
@


1.218
log
@no need for endpwent()
(you lost, theo)
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.217 2005/05/03 07:01:23 djm Exp $ */
d621 1
a621 1
		break;
@


1.217
log
@setres[ug]id; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.216 2005/03/30 11:23:15 henning Exp $ */
a216 2

	endpwent();
@


1.216
log
@bgpd used to open listeners in advance in the parent and the SE picked
those it needed, closing all the others. this has some nasty races.
so let the parent keep the list of listeners so it knows when it has
to open a new one
claudio ok, also tested by jason ackley
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.215 2005/03/28 15:16:46 henning Exp $ */
d214 2
a215 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid))
@


1.215
log
@ewps, this was not supposed to creep in
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.214 2005/03/28 15:03:33 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
d2112 1
a2112 1
			TAILQ_FOREACH(la, conf->listen_addrs, entry) {
a2114 1
			}
d2116 9
a2124 4
			if ((nla->fd = imsg_get_fd(ibuf)) == -1)
				log_warnx("expected to receive fd for %s "
				    "but didn't receive any",
				    log_sockaddr((struct sockaddr *)&la->sa));
a2125 1
			if (la == NULL) {
d2136 2
a2138 1
				close(nla->fd);
d2140 1
a2162 6

			/* if there are no new listeners, keep default ones */
			if (TAILQ_EMPTY(nconf->listen_addrs))
				TAILQ_FOREACH(la, conf->listen_addrs, entry)
					if (la->flags & DEFAULT_LISTENER)
						la->reconf = RECONF_KEEP;
@


1.214
log
@free rules_l if the initial config file parse fails
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.213 2005/03/11 17:46:11 henning Exp $ */
d521 1
a521 1
	exit(0);
@


1.213
log
@shutdown() directly before close() is useless, theo
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.212 2004/12/23 17:34:04 henning Exp $ */
d521 1
a521 1
	_exit(0);
@


1.212
log
@in getpeerbydesc(), complain if we find more than one match and return NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.211 2004/12/23 17:24:03 henning Exp $ */
d812 1
a812 2
	if (peer->fd != -1) {
		shutdown(peer->fd, SHUT_RDWR);
d814 1
a814 1
	}
a917 1
				shutdown(connfd, SHUT_RDWR);
a925 1
			shutdown(connfd, SHUT_RDWR);
a933 1
				shutdown(connfd, SHUT_RDWR);
a943 1
				shutdown(connfd, SHUT_RDWR);
a949 1
			shutdown(connfd, SHUT_RDWR);
a956 1
		shutdown(connfd, SHUT_RDWR);
a2133 1
				shutdown(nla->fd, SHUT_RDWR);
a2174 1
					shutdown(la->fd, SHUT_RDWR);
@


1.211
log
@introduce getpeerbydesc(), find a peer by its description
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.210 2004/12/23 15:15:55 henning Exp $ */
d2395 8
a2402 1
	struct peer *p;
d2404 3
a2406 3
	for (p = peers; p != NULL && strcmp(p->conf.descr, descr);
	    p = p->next)
		;	/* nothing */
d2408 4
a2411 1
	return (p);
@


1.210
log
@lower latency by processing no more than 25 messages at once for each peer
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.209 2004/12/07 17:19:09 henning Exp $ */
d2386 12
@


1.209
log
@oups, little FSM error: when we're in CONNECT and get an CON_OPEN event
initialize and start the holdtimer, just like when we're in state ACTIVE.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.208 2004/11/23 13:07:01 claudio Exp $ */
d1424 1
a1424 1
	int		error;
d1540 2
@


1.208
log
@Switch from a single filter_set to a linked list of sets. With this change
it is possible to specify multiple communities. This is also the first step
to better bgpd filters. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.207 2004/11/18 17:17:56 henning Exp $ */
d609 2
@


1.207
log
@embed two struct capabilities, one for the capas announced by the peer and
one for the capas we announced him, into the session_up imsg to the RDE
after brainstorming with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.206 2004/11/18 17:07:38 henning Exp $ */
d2043 2
d2055 1
d2107 2
d2197 1
d2201 12
d2520 6
a2525 1
	struct session_up	sup;
d2527 5
a2531 1
	sup.remote_bgpid = p->remote_bgpid;
d2558 1
a2558 1
	memcpy(&sup.conf, &p->conf, sizeof(sup.conf));
@


1.206
log
@add an instance of struct capabilities to peer_conf, and inherit
peer->capa.ann from this
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.205 2004/11/18 16:38:05 henning Exp $ */
d2500 1
a2500 1
session_up(struct peer *peer)
d2504 1
a2504 1
	sup.remote_bgpid = peer->remote_bgpid;
d2506 1
a2506 1
	switch (peer->sa_local.ss_family) {
d2510 1
a2510 1
		    &((struct sockaddr_in *)&peer->sa_local)->sin_addr,
d2514 1
a2514 1
		    &((struct sockaddr_in *)&peer->sa_remote)->sin_addr,
d2520 1
a2520 1
		    &((struct sockaddr_in6 *)&peer->sa_local)->sin6_addr,
d2524 1
a2524 1
		    &((struct sockaddr_in6 *)&peer->sa_remote)->sin6_addr,
d2531 5
a2535 3
	memcpy(&sup.conf, &peer->conf, sizeof(sup.conf));
	peer->stats.last_updown = time(NULL);
	if (imsg_compose(ibuf_rde, IMSG_SESSION_UP, peer->conf.id, 0, -1,
@


1.205
log
@inside struct peer, replace the occurance of the older struct peer_capa
by two instances of the new struct capabilities, one for announcements
and one for the received capabilities
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.204 2004/11/18 16:30:05 henning Exp $ */
d536 2
a537 4
	p->capa.ann.mp_v4 = SAFI_UNICAST;
	p->capa.ann.mp_v6 = SAFI_NONE;
	p->capa.ann.refresh = 1;
	if (!p->conf.capabilities)
d849 1
@


1.204
log
@remove the global 'announce' flag from struct peer_capa, clear
individual capability flags where needed
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.203 2004/11/18 15:42:59 henning Exp $ */
d536 3
a538 3
	p->capa.ann_mp_v4 = SAFI_UNICAST;
	p->capa.ann_mp_v6 = SAFI_NONE;
	p->capa.ann_refresh = 1;
d1136 3
a1138 3
	peer->capa.ann_mp_v4 = SAFI_NONE;
	peer->capa.ann_mp_v4 = SAFI_NONE;
	peer->capa.ann_refresh = 0;
d1171 1
a1171 1
	if (p->capa.ann_mp_v4)
d1173 1
a1173 1
	if (p->capa.ann_mp_v6)
d1177 1
a1177 1
	if (p->capa.ann_refresh)
d1215 1
a1215 1
		if (p->capa.ann_mp_v4)
d1217 2
a1218 2
			    p->capa.ann_mp_v4);
		if (p->capa.ann_mp_v6)
d1220 1
a1220 1
			    p->capa.ann_mp_v6);
d1223 1
a1223 1
		if (p->capa.ann_refresh) {
d1930 2
a1931 2
				peer->capa.ann_mp_v4 = SAFI_NONE;
				peer->capa.ann_mp_v6 = SAFI_NONE;
d1936 1
a1936 1
				peer->capa.ann_refresh = 0;
d2018 1
a2018 1
				peer->capa.mp_v4 = mp_safi;
d2027 1
a2027 1
				peer->capa.mp_v6 = mp_safi;
d2034 1
a2034 1
			peer->capa.refresh = 1;
@


1.203
log
@let peer->capa.mp_[v4|v6] contain the SAFI, don't just use it as bool
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.202 2004/11/18 15:24:24 henning Exp $ */
d64 1
d535 1
a535 1
	p->capa.announce = p->conf.capabilities;
d539 3
d1133 8
d1170 9
a1178 14
	if (p->capa.announce) {
		/* multiprotocol extensions, RFC 2858 */
		if (p->capa.ann_mp_v4)
			op_len += 2 + 4;	/* 1 code + 1 len + 4 data */
		if (p->capa.ann_mp_v6)
			op_len += 2 + 4;	/* 1 code + 1 len + 4 data */

		/* route refresh, RFC 2918 */
		if (p->capa.ann_refresh)
			op_len += 2;	/* 1 code + 1 len, no data */

		if (op_len > 0)
			optparamlen = sizeof(op_type) + sizeof(op_len) + op_len;
	}
d1180 2
d1209 1
a1209 1
	if (p->capa.announce && optparamlen) {
d1904 1
a1904 1
			peer->capa.announce = 0;
d1946 1
a1946 1
				peer->capa.announce = 0;
d1955 1
a1955 1
		peer->capa.announce = 0;
@


1.202
log
@introduce session_capa_mp() which adds the multiprotocol announcements
to OPEN messages. eases session_open() quite a bit and kills duplicate code
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.201 2004/11/18 14:59:50 henning Exp $ */
d64 1
a64 1
int	session_capa_mp(struct buf *, u_int16_t, u_int8_t);
d535 2
a536 2
	p->capa.ann_mp_v4 = 1;
	p->capa.ann_mp_v6 = 0;
d1130 1
a1130 1
session_capa_mp(struct buf *buf, u_int16_t afi, u_int8_t safi)
d1207 2
a1208 1
			errs += session_capa_mp(buf, AFI_IPv4, SAFI_UNICAST);
d1210 2
a1211 1
			errs += session_capa_mp(buf, AFI_IPv6, SAFI_UNICAST);
d1921 2
a1922 2
				peer->capa.ann_mp_v4 = 0;
				peer->capa.ann_mp_v6 = 0;
@


1.201
log
@add code to announce support for IPv6 Unicast.
disabled for now, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.200 2004/11/18 14:10:36 henning Exp $ */
d64 1
d1129 18
a1156 1
	struct capa_mp		 capa_mp_v4, capa_mp_v6;
d1160 4
a1163 14
		if (p->capa.ann_mp_v4) {
			op_len += 2;	/* 1 code + 1 len */
			bzero(&capa_mp_v4, sizeof(capa_mp_v4));
			capa_mp_v4.afi = htons(AFI_IPv4);
			capa_mp_v4.safi = SAFI_UNICAST;
			op_len += 4;	/* 2 AFI + 1 pad + 1 safi */
		}
		if (p->capa.ann_mp_v6) {
			op_len += 2;	/* 1 code + 1 len */
			bzero(&capa_mp_v6, sizeof(capa_mp_v6));
			capa_mp_v6.afi = htons(AFI_IPv6);
			capa_mp_v6.safi = SAFI_UNICAST;
			op_len += 4;	/* 2 AFI + 1 pad + 1 safi */
		}
d1206 4
a1209 24
		if (p->capa.ann_mp_v4) {
			capa_code = CAPA_MP;
			capa_len = 4;
			errs += buf_add(buf, &capa_code, sizeof(capa_code));
			errs += buf_add(buf, &capa_len, sizeof(capa_len));
			errs += buf_add(buf, &capa_mp_v4.afi,
			    sizeof(capa_mp_v4.afi));
			errs += buf_add(buf, &capa_mp_v4.pad,
			    sizeof(capa_mp_v4.pad));
			errs += buf_add(buf, &capa_mp_v4.safi,
			    sizeof(capa_mp_v4.safi));
		}
		if (p->capa.ann_mp_v6) {
			capa_code = CAPA_MP;
			capa_len = 4;
			errs += buf_add(buf, &capa_code, sizeof(capa_code));
			errs += buf_add(buf, &capa_len, sizeof(capa_len));
			errs += buf_add(buf, &capa_mp_v6.afi,
			    sizeof(capa_mp_v6.afi));
			errs += buf_add(buf, &capa_mp_v6.pad,
			    sizeof(capa_mp_v6.pad));
			errs += buf_add(buf, &capa_mp_v6.safi,
			    sizeof(capa_mp_v6.safi));
		}
@


1.200
log
@supress logging of subsequent connect() failures as long as:
-the session alternates between Active and Connect. Other states reset logging
-the error is the same as the last connect() error seen
jajajaja claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.199 2004/11/11 16:56:08 claudio Exp $ */
d534 2
a535 1
	p->capa.ann_mp = 1;
d1138 1
a1138 1
	struct capa_mp		 capa_mp_v4;
d1141 3
a1143 2
		if (p->capa.ann_mp) {
			/* multiprotocol extensions, RFC 2858 */
d1147 1
a1147 1
			op_len += 6;	/* 1 code + 1 len + 4 data */
d1149 10
a1158 2
		if (p->capa.ann_refresh) {
			/* route refresh, RFC 2918 */
a1159 1
		}
d1197 2
a1198 2
		if (p->capa.ann_mp) {
			/* multiprotocol extensions, RFC 2858 */
d1210 12
d1223 1
a1224 1
			/* route refresh, RFC 2918 */
d1931 2
a1932 1
				peer->capa.ann_mp = 0;
@


1.199
log
@Unbreak link local IPv6 sessions by setting the correct scope_id in
addr2sa. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.198 2004/11/10 14:48:25 claudio Exp $ */
d1025 3
a1027 1
			log_peer_warn(&peer->conf, "connect");
@


1.198
log
@"not reached" does not help LINT use NOTREACHED instead and use it only in
places where needed. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.197 2004/11/02 10:56:48 henning Exp $ */
d2549 1
@


1.197
log
@save the previous state in struct peer, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.196 2004/10/19 12:02:50 henning Exp $ */
a1786 1
			/* not reached */
d2328 1
a2328 1
		/* not reached */
@


1.196
log
@allow neighbor definitions to depend on interface state.
with this, if a neighbor is configured as dependent on carp0 for example,
the neighbor will remain in state IDLE as long as carp0 is not master.
once carp0 becomes master the session(s) depending on it immediately
go to CONNECT (or ACTIVE, if they're configured passive), reducing failover
time. claudio ok, with some input from ryan as well
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.195 2004/10/07 13:39:14 henning Exp $ */
d882 1
d2075 1
a2075 1
				p->state = STATE_NONE;
d2406 1
a2406 1
		newpeer->state = STATE_NONE;
@


1.195
log
@use a static, const and prefilled u_int8_t[16] to check wether the marker
at the beginning of each BGP message is all 1s instead of looping and
comparing one by one
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.194 2004/10/05 11:47:41 henning Exp $ */
d536 6
d579 3
a581 1
			if (peer->conf.passive || peer->conf.template) {
d2030 1
d2033 1
a2033 1
	int			 n;
d2172 23
@


1.194
log
@reject an all zero bgpid, following a similar suggestion from
pascal.gloor@@spale.com
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.193 2004/09/22 08:46:28 henning Exp $ */
a1529 2
	u_char			 one = 0xff;
	int			 i;
d1531 3
d1537 5
a1541 9
	for (i = 0; i < 16; i++) {
		if (memcmp(p, &one, 1)) {
			log_peer_warnx(&peer->conf, "sync error");
			session_notification(peer, ERR_HEADER, ERR_HDR_SYNC,
			    NULL, 0);
			bgp_fsm(peer, EVNT_CON_FATAL);
			return (-1);
		}
		p++;
d1543 2
@


1.193
log
@don't bother shrinking the pfd and index2peer arrays
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.192 2004/09/16 17:44:36 henning Exp $ */
d1700 2
a1701 2
	/* check bgpid for validity, must be a valid ip address - HOW? */
	/* if ( bgpid invalid ) {
d1708 1
a1708 1
	} */
@


1.192
log
@when a cloned peer goes back to IDLE state, don't remove him immediately
but keep him around for some more time (an hour here).
fixes an issue Arvid was reporting: when a cloned neighbor rejects our OPEN
message due to capability negotiation (or missing implementation of those),
we set a marker and retry without. However, if we remove the peer immediately,
it gets freshly cloned on the next trial, with default settings, thus including
capability negotiation, and thus failes again.
this will also help with route flap dampening.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.191 2004/09/16 17:36:29 henning Exp $ */
a18 1

d299 1
a299 2
		if (peer_cnt > peer_l_elms ||
		    peer_cnt + 2 * PEER_L_RESERVE < peer_l_elms) {
d301 1
a301 1
			    (peer_cnt + PEER_L_RESERVE))) == NULL) {
d304 1
a304 2
				    " entries", peer_l_elms,
				    peer_cnt + PEER_L_RESERVE);
d308 1
a308 1
			peer_l_elms = peer_cnt + PEER_L_RESERVE;
d312 1
a312 1
		LIST_FOREACH(m, &mrthead, entry) {
a314 1
		}
d316 1
a316 2
		if (mrt_cnt > mrt_l_elms ||
		    mrt_cnt + 2 * PEER_L_RESERVE < mrt_l_elms) {
d318 1
a318 1
			    (mrt_cnt + PEER_L_RESERVE))) == NULL) {
d321 1
a321 2
				    " entries", mrt_l_elms,
				    mrt_cnt + PEER_L_RESERVE);
d325 1
a325 1
			mrt_l_elms = mrt_cnt + PEER_L_RESERVE;
d330 1
a330 2
		if (new_cnt > pfd_elms ||
		    (new_cnt + 2) * PFD_RESERVE < pfd_elms) {
d332 1
a332 1
			    (new_cnt + PFD_RESERVE))) == NULL) {
d335 1
a335 2
				    " entries", pfd_elms,
				    new_cnt + PFD_RESERVE);
d339 1
a339 1
			pfd_elms = new_cnt + PFD_RESERVE;
@


1.191
log
@imsg API cleanup:
-kill imsg_compose_pid, imsg_compose_fdpass and imsg_create_pid
-extend the original imsg_compose/_create API to take pid & fd too
-make imsg_compose do imsg_create + imsg_add + imsg_close instead of
 duplicating the code
-adjust all callers to the new API
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.190 2004/09/16 00:25:12 henning Exp $ */
d267 6
d847 1
a847 1
		if (event != EVNT_STOP && !peer->conf.cloned) {
a852 2
		if (peer->state != STATE_NONE && peer->conf.cloned)
			peer->conf.reconf_action = RECONF_DELETE;
@


1.190
log
@malloc the imsg buffers instead of having them staticly, suggested by
micskye some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.189 2004/09/09 21:53:57 henning Exp $ */
d1810 1
a1810 1
	if (imsg_compose(ibuf_rde, IMSG_UPDATE, peer->conf.id, p,
d1837 1
a1837 1
	if (imsg_compose(ibuf_rde, IMSG_REFRESH, peer->conf.id, &r,
d2445 1
a2445 1
	if (imsg_compose(ibuf_rde, IMSG_SESSION_DOWN, peer->conf.id,
d2484 1
a2484 1
	if (imsg_compose(ibuf_rde, IMSG_SESSION_UP, peer->conf.id,
d2492 1
a2492 1
	return (imsg_compose_pid(ibuf_main, type, pid, data, datalen));
d2498 1
a2498 1
	return (imsg_compose_pid(ibuf_rde, type, pid, data, datalen));
@


1.189
log
@correctly track peer count. fixes a memory corruption.
exactly the same bug as in ntpd, but caused completely different...
strange issues seen by arvid goetting who helped a lot in debugging,
bug found after an ntpd issue showed up and I saw the relation.
hunting with & ok claudio, otto, millert, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.188 2004/08/11 16:48:45 claudio Exp $ */
d95 2
a96 2
struct imsgbuf		 ibuf_rde;
struct imsgbuf		 ibuf_main;
d231 5
a235 2
	imsg_init(&ibuf_rde, pipe_s2r[0]);
	imsg_init(&ibuf_main, pipe_m2s[1]);
d345 1
a345 1
		pfd[PFD_PIPE_MAIN].fd = ibuf_main.fd;
d347 1
a347 1
		if (ibuf_main.w.queued > 0)
d349 1
a349 1
		pfd[PFD_PIPE_ROUTE].fd = ibuf_rde.fd;
d351 1
a351 1
		if (ibuf_rde.w.queued > 0)
d445 1
a445 1
			if (msgbuf_write(&ibuf_main.w) < 0)
d450 1
a450 1
			session_dispatch_imsg(&ibuf_main, PFD_PIPE_MAIN,
d455 1
a455 1
			if (msgbuf_write(&ibuf_rde.w) < 0)
d460 1
a460 1
			session_dispatch_imsg(&ibuf_rde, PFD_PIPE_ROUTE,
d512 6
a517 4
	msgbuf_write(&ibuf_rde.w);
	msgbuf_clear(&ibuf_rde.w);
	msgbuf_write(&ibuf_main.w);
	msgbuf_clear(&ibuf_main.w);
d1810 1
a1810 1
	if (imsg_compose(&ibuf_rde, IMSG_UPDATE, peer->conf.id, p,
d1837 1
a1837 1
	if (imsg_compose(&ibuf_rde, IMSG_REFRESH, peer->conf.id, &r,
d2445 1
a2445 1
	if (imsg_compose(&ibuf_rde, IMSG_SESSION_DOWN, peer->conf.id,
d2484 1
a2484 1
	if (imsg_compose(&ibuf_rde, IMSG_SESSION_UP, peer->conf.id,
d2492 1
a2492 1
	return (imsg_compose_pid(&ibuf_main, type, pid, data, datalen));
d2498 1
a2498 1
	return (imsg_compose_pid(&ibuf_rde, type, pid, data, datalen));
@


1.188
log
@mrt dumps for cloned sessions did not work because the wrong address was used.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.187 2004/08/11 10:09:30 claudio Exp $ */
d94 1
d169 1
a169 1
	u_int			 listener_cnt, peer_cnt, ctl_cnt, mrt_cnt;
d265 1
a265 1
				if (p->state == STATE_NONE) {
a266 2
					peer_cnt++;
				}
d533 1
@


1.187
log
@Cleanup on exit. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.186 2004/08/10 14:06:53 claudio Exp $ */
d871 1
a871 1
			    &peer->conf, conf);
d1207 1
a1207 1
				    &p->conf, conf);
d1260 1
a1260 1
			mrt_dump_bgp_msg(mrt, buf->buf, len, &peer->conf, conf);
d1319 1
a1319 1
			mrt_dump_bgp_msg(mrt, buf->buf, len, &p->conf, conf);
d1374 1
a1374 1
			mrt_dump_bgp_msg(mrt, buf->buf, len, &peer->conf, conf);
d1619 1
a1619 1
			mrt_dump_bgp_msg(mrt, data, *len, &peer->conf, conf);
@


1.186
log
@Gahhh, why is this still around? It was never necessary to inform the parent
after fd passing. I thought I removed that some time ago... anyway now it
is gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.185 2004/08/06 11:51:19 claudio Exp $ */
d506 3
@


1.185
log
@Forward IMSG_CTL_SHOW_NEIGHBOR messages to the rde so that we can report
the current and max prefix count back to bgpctl. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.184 2004/08/04 12:41:48 henning Exp $ */
a2187 5

			/* tell parent to close fd */
			if (imsg_compose(&ibuf_main, IMSG_MRT_CLOSE, 0,
			    &xmrt, sizeof(struct mrt)) == -1)
				log_warn("session_dispatch_imsg: mrt close");
@


1.184
log
@session_main() and rde_main() return... right, a pid. and a pid is a pid_t
and not an int.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.183 2004/07/13 17:57:20 jaredy Exp $ */
d2220 1
@


1.183
log
@fix some typos

ok henning otto
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.182 2004/07/04 03:51:31 henning Exp $ */
d158 1
a158 1
int
@


1.182
log
@2 more file descriptors for each RDE and SE inherited from the parent
we should close
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.181 2004/07/03 17:19:59 claudio Exp $ */
d1870 1
a1870 1
			    "disabling capability announcements alltogether");
d1910 1
a1910 1
				    "capability announcements alltogether",
@


1.181
log
@Switch mrt dumping to fd passing. This gives some speed up when extensive
dumping is done. Acctually mrt dumps were broken because of the fd passing.
The nice side effect is a much cleaner code, especially in the parent process.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.180 2004/06/22 07:58:19 alexander Exp $ */
d161 1
a161 1
    struct mrt_head *m_l, int pipe_m2s[2], int pipe_s2r[2])
d227 2
@


1.180
log
@Precedence fix; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.179 2004/06/22 07:42:41 henning Exp $ */
d97 1
a97 1
struct mrt_config_head	 mrt_l;
d163 2
a164 1
	int			 nfds, i, j, timeout, idx_peers, idx_listeners;
d167 3
a169 2
	u_int			 pfd_elms = 0, peer_l_elms = 0, new_cnt;
	u_int			 listener_cnt, peer_cnt, ctl_cnt;
d173 1
a173 2
	struct mrt		*m;
	struct mrt_config	*mrt;
d232 1
a232 1
	LIST_INIT(&mrt_l);
d251 1
a251 1
		LIST_REMOVE(m, list);
d304 22
a325 2
		new_cnt =
		    PFD_LISTENERS_START + listener_cnt + peer_cnt + ctl_cnt;
d415 10
d476 6
d493 4
a496 3
	while ((mrt = LIST_FIRST(&mrt_l)) != NULL) {
		LIST_REMOVE(mrt, list);
		free(mrt);
d801 1
a801 1
	struct mrt_config	*mrt;
d859 1
a859 1
	LIST_FOREACH(mrt, &mrt_l, list) {
d1115 1
a1115 1
	struct mrt_config	*mrt;
d1195 1
a1195 1
		LIST_FOREACH(mrt, &mrt_l, list) {
d1225 1
a1225 1
	struct mrt_config	*mrt;
d1249 1
a1249 1
	LIST_FOREACH(mrt, &mrt_l, list) {
d1275 1
a1275 1
	struct mrt_config	*mrt;
d1308 1
a1308 1
	LIST_FOREACH(mrt, &mrt_l, list) {
d1334 1
a1334 1
	struct mrt_config	*mrt;
d1363 1
a1363 1
	LIST_FOREACH(mrt, &mrt_l, list) {
d1522 1
a1522 1
	struct mrt_config	*mrt;
d1607 1
a1607 1
	LIST_FOREACH(mrt, &mrt_l, list) {
d2012 2
a2013 2
	struct mrt_config	 xmrt;
	struct mrt_config	*mrt;
d2159 46
a2204 19
		case IMSG_MRT_REQ:
			if ((mrt = calloc(1, sizeof(struct mrt_config))) ==
			    NULL)
				fatal("session_dispatch_imsg");
			memcpy(mrt, imsg.data, sizeof(struct mrt_config));
			mrt->ibuf = &ibuf_main;
			LIST_INSERT_HEAD(&mrt_l, mrt, list);
			break;
		case IMSG_MRT_END:
			memcpy(&xmrt, imsg.data, sizeof(struct mrt_config));
			LIST_FOREACH(mrt, &mrt_l, list) {
				if (mrt->type != xmrt.type)
					continue;
				if (mrt->peer_id == xmrt.peer_id &&
				    mrt->group_id == xmrt.group_id) {
					LIST_REMOVE(mrt, list);
					free(mrt);
					break;
				}
@


1.179
log
@missing bzero in a function for this strange other address family
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.178 2004/06/22 03:44:26 claudio Exp $ */
d292 1
a292 1
			    peer_cnt + PEER_L_RESERVE)) == NULL) {
d306 1
a306 1
		    new_cnt + 2 * PFD_RESERVE < pfd_elms) {
@


1.178
log
@Templates with unknown AS where always configured as ebgp peers even if
they were ibgp ones. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.177 2004/06/22 03:17:01 henning Exp $ */
d2337 1
@


1.177
log
@so we call realloc() on our pollfd array and the peer_l one when they shrunk
to save memory... yet, that realloc call can fail with ENOMEM ;)
don't shrink when (needed + reserve < allocated), but
(needed + 2 * reserve < allocated)
the longer term goal is of course to not fail at all when a shrink-realloc
fails... but that's for later
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.176 2004/06/20 18:35:12 henning Exp $ */
d1620 1
a1620 1
	if (peer->conf.cloned && !peer->conf.remote_as)
d1622 2
@


1.176
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.175 2004/06/20 17:49:46 henning Exp $ */
d290 1
a290 1
		    peer_cnt + PEER_L_RESERVE < peer_l_elms) {
d306 1
a306 1
		    new_cnt + PFD_RESERVE < pfd_elms) {
@


1.175
log
@implement file descriptor passing in the imsg/msgbuf framework, and use
it to let the main process to prepare new listening sockets (socket() and
bind()) on behalf of the session engine, which of course cannot bind() to
ports < 1024 any more once it dropped privileges. with some help from theo,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.174 2004/06/09 13:01:44 henning Exp $ */
d237 1
a237 1
		TAILQ_REMOVE(rules, r, entries);
d244 1
a244 1
		TAILQ_REMOVE(net_l, net, network_l);
d394 1
a394 1
		TAILQ_FOREACH(ctl_conn, &ctl_conns, entries) {
@


1.174
log
@move to a dynamically allocated struct pollfd array.
we used a ststic one with OPEN_MAX entries, which is a rather arbitary limit
as OPEN_MAX is _not_ the max # of open fds we can have, but just a default
for that setting.
in the same move we have to allocate the peer_l array, basically there
for pfd-index to peer pointers to prevent peer list scans all time,
dynamiccaly to. we overallocate a little and use that reserve until we
have to realloc again later to prevent reallocs for every single control
connection or a single flapping peer.
help & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.173 2004/06/06 17:38:10 henning Exp $ */
a116 22
	if (TAILQ_EMPTY(conf->listen_addrs)) {
		if ((la = calloc(1, sizeof(struct listen_addr))) == NULL)
			fatal("setup_listeners calloc");
		la->fd = -1;
		la->flags = DEFAULT_LISTENER;
		la->sa.ss_len = sizeof(struct sockaddr_in);
		((struct sockaddr_in *)&la->sa)->sin_family = AF_INET;
		((struct sockaddr_in *)&la->sa)->sin_addr.s_addr =
		    htonl(INADDR_ANY);
		((struct sockaddr_in *)&la->sa)->sin_port = htons(BGP_PORT);
		TAILQ_INSERT_TAIL(conf->listen_addrs, la, entry);

		if ((la = calloc(1, sizeof(struct listen_addr))) == NULL)
			fatal("setup_listeners calloc");
		la->fd = -1;
		la->flags = DEFAULT_LISTENER;
		la->sa.ss_len = sizeof(struct sockaddr_in6);
		((struct sockaddr_in6 *)&la->sa)->sin6_family = AF_INET6;
		((struct sockaddr_in6 *)&la->sa)->sin6_port = htons(BGP_PORT);
		TAILQ_INSERT_TAIL(conf->listen_addrs, la, entry);
	}

d121 1
a121 1
		if (la->fd != -1)
d124 5
a128 3
		if ((la->fd = socket(la->sa.ss_family, SOCK_STREAM,
		    IPPROTO_TCP)) == -1)
			fatal("socket");
a139 12
		if (bind(la->fd, (struct sockaddr *)&la->sa, la->sa.ss_len) ==
		    -1) {
			if (errno == EACCES) {
				log_warnx("can't establish listener on %s",
				    log_sockaddr((struct sockaddr *)&la->sa));
				close(la->fd);
				la->fd = -1;
				return (-1);
			} else
				fatal("bind");
		}

d147 2
a206 3
	listener_cnt = 0;
	setup_listeners(&listener_cnt);

d217 3
d2039 5
d2049 1
a2050 1
				la->flags = nla->flags;
d2056 2
d2098 1
@


1.173
log
@rework bgpd's handling of listening sockets. instead of one for each
supported address familiy, keep a tailq of an arbitary number of them.
the new struct listen_addr contains the sockaddr and the fd.
this fixes quite some nasty behaviour which was a consequence of the previous
model.
looks right deraadt@@, and discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.172 2004/05/28 18:39:09 henning Exp $ */
d53 1
a53 1
int	setup_listeners(void);
d78 1
a78 1
void	session_dispatch_imsg(struct imsgbuf *, int);
d111 1
a111 1
setup_listeners(void)
d115 1
d141 1
d183 2
d196 2
d199 1
a199 1
	struct peer		*p, *peer_l[OPEN_MAX], *last, *next;
d204 1
a204 1
	struct pollfd		 pfd[OPEN_MAX];
d207 1
d237 2
a238 1
	setup_listeners();
d262 2
d285 1
a285 23
		bzero(&pfd, sizeof(pfd));
		pfd[PFD_PIPE_MAIN].fd = ibuf_main.fd;
		pfd[PFD_PIPE_MAIN].events = POLLIN;
		if (ibuf_main.w.queued > 0)
			pfd[PFD_PIPE_MAIN].events |= POLLOUT;
		pfd[PFD_PIPE_ROUTE].fd = ibuf_rde.fd;
		pfd[PFD_PIPE_ROUTE].events = POLLIN;
		if (ibuf_rde.w.queued > 0)
			pfd[PFD_PIPE_ROUTE].events |= POLLOUT;
		pfd[PFD_SOCK_CTL].fd = csock;
		pfd[PFD_SOCK_CTL].events = POLLIN;

		nextaction = time(NULL) + 240;	/* loop every 240s at least */
		i = PFD_LISTENERS_START;

		TAILQ_FOREACH(la, conf->listen_addrs, entry) {
			pfd[i].fd = la->fd;
			pfd[i].events = POLLIN;
			i++;
		}

		idx_listeners = i;

d290 2
a291 2
				/* needs init? */
				if (p->state == STATE_NONE)
d293 2
d311 1
d317 54
d372 1
d417 1
a417 1
				peer_l[i] = p;
d445 2
a446 1
			session_dispatch_imsg(&ibuf_main, PFD_PIPE_MAIN);
d455 2
a456 1
			session_dispatch_imsg(&ibuf_rde, PFD_PIPE_ROUTE);
d461 1
a461 1
			control_accept(csock);
d472 2
a473 1
			nfds -= session_dispatch_msg(&pfd[j], peer_l[j]);
d476 1
a476 1
			nfds -= control_dispatch_msg(&pfd[j]);
d1999 1
a1999 1
session_dispatch_imsg(struct imsgbuf *ibuf, int idx)
d2134 1
a2134 1
			setup_listeners();
@


1.172
log
@detect absence of PF_KEY interface and/or the TCP_MD5SIG setsockopts
at runtime and disable said subsystems if so. helps the guys porting bgpd
to $otherBSD, and is actually the right thing to do. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.171 2004/05/28 16:33:40 henning Exp $ */
d47 4
a50 6
#define	PFD_LISTEN	0
#define	PFD_LISTEN6	1
#define PFD_PIPE_MAIN	2
#define PFD_PIPE_ROUTE	3
#define	PFD_SOCK_CTL	4
#define PFD_PEERS_START	5
d53 1
a53 1
int	setup_listener(struct sockaddr *);
d82 1
a92 2
int			 sock = -1;
int			 sock6 = -1;
d111 1
a111 1
setup_listener(struct sockaddr *sa)
d113 24
a136 1
	int	fd, opt;
d138 9
a146 2
	if (sa->sa_family != AF_INET && sa->sa_family != AF_INET6)
		fatal("king bula sez: unknown address family");
d148 9
a156 5
	if ((fd = socket(sa->sa_family, SOCK_STREAM, IPPROTO_TCP)) == -1) {
		log_warn("error setting up %s listener",
		    sa->sa_family == AF_INET ? "IPv4" : "IPv6");
		return (fd);
	}
d158 11
a168 8
	opt = 1;
	if (setsockopt(fd, IPPROTO_TCP, TCP_MD5SIG, &opt, sizeof(opt)) == -1) {
		if (errno == ENOPROTOOPT) {	/* system w/o md5sig support */
			log_warnx("md5 signatures not available, disabling");
			sysdep.no_md5sig = 1;
		} else
			fatal("setsockopt TCP_MD5SIG");
	}
d170 1
a170 4
	if (bind(fd, sa, sa->sa_len)) {
		close(fd);
		fatal("bind");
	}
d172 4
a175 1
	session_socket_blockmode(fd, BM_NONBLOCK);
d177 2
a178 3
	if (listen(fd, MAX_BACKLOG)) {
		close(fd);
		fatal("listen");
d181 1
a181 1
	return (fd);
d189 1
a189 1
	int			 nfds, i, j, timeout, idx_peers;
d200 1
d230 1
a230 2
	sock = setup_listener((struct sockaddr *)&conf->listen_addr);
	sock6 = setup_listener((struct sockaddr *)&conf->listen6_addr);
a275 4
		pfd[PFD_LISTEN].fd = sock;
		pfd[PFD_LISTEN].events = POLLIN;
		pfd[PFD_LISTEN6].fd = sock6;
		pfd[PFD_LISTEN6].events = POLLIN;
d288 9
a296 1
		i = PFD_PEERS_START;
a392 10
		if (nfds > 0 && pfd[PFD_LISTEN].revents & POLLIN) {
			nfds--;
			session_accept(sock);
		}

		if (nfds > 0 && pfd[PFD_LISTEN6].revents & POLLIN) {
			nfds--;
			session_accept(sock6);
		}

d416 8
a423 1
		for (j = PFD_PEERS_START; nfds > 0 && j < idx_peers; j++)
d442 6
d1957 1
d1984 4
d2011 23
d2043 1
d2050 1
a2050 1
			/* find peers to be deleted */
d2055 32
d2170 35
@


1.171
log
@don't want SO_REUSEPORT...
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.170 2004/05/21 11:48:56 claudio Exp $ */
d90 1
d128 7
a134 2
	if (setsockopt(fd, IPPROTO_TCP, TCP_MD5SIG, &opt, sizeof(opt)) == -1)
		fatal("setsockopt TCP_MD5SIG");
d199 1
a199 1
	if (pfkey_init() == -1)
d805 9
d815 7
d870 14
a883 1
	if (peer->conf.auth.method == AUTH_MD5SIG)
d890 1
a890 1

@


1.170
log
@Add support for dynamic announcements. Usefule to annouce temporary
blackhole routes or to make network announcements dependent on a external
state (e.g. for carp setups) OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.169 2004/05/08 11:22:43 henning Exp $ */
a126 2
	if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt)) == -1)
		fatal("setsockopt SO_REUSEPORT");
@


1.169
log
@remove unused argument to control_dispatch_msg(), lint
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.168 2004/05/06 14:41:05 henning Exp $ */
d1989 1
@


1.168
log
@oups, spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.167 2004/05/06 14:07:43 henning Exp $ */
d389 1
a389 1
			nfds -= control_dispatch_msg(&pfd[j], j);
d395 1
d456 2
a457 1
			/* init pfkey */
a727 1
		pfkey_remove(peer);
@


1.167
log
@the Address Family Identifier field in the capability announcement is
2 octets, thus we need to transform it from/to network byte order...
fixes capability announcement and -parsing
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.166 2004/05/06 12:18:02 henning Exp $ */
d942 1
a942 1
 	}
@


1.166
log
@do not punish the peer (by holding him in IDLE for IdleHoldTime seconds) when
receiving a "unsupported capabilities" notification. Speeds capability
negotiation up quite a bit with peers that like to whine about caoabilities
they don't understand
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.165 2004/05/06 12:09:25 henning Exp $ */
d995 1
a995 1
			capa_mp_v4.afi = AFI_IPv4;
d1685 1
d1839 1
@


1.165
log
@improve logging in teh capabilities parser
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.164 2004/05/06 11:57:55 henning Exp $ */
d1780 2
@


1.164
log
@scale socket buffer sizes (and thus window size) up to up to 64k,
but only of tcp md5sig or ipsec is in use. excellent idea by ryan some time
ago, claudio and theo agree
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.163 2004/05/06 09:11:18 henning Exp $ */
a1039 1

d1731 4
a1734 1
		if (datalen == 0)	/* zebra likes to send those.. humbug */
d1736 1
d1771 5
@


1.163
log
@there's a little race condition: a session is taken down and its associated
write buffers are cleared, but there could be imsgs from the RDE for that peer
(e. g. UPDATEs) in the read buffers for the pipe to the RDE or buffered in
the RDE or somesuch. Thus, in session_update(), explicitely check for the
session state and just drop the message if the session is not in state
ESTABLISHED.
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.162 2004/04/29 19:56:04 deraadt Exp $ */
d895 1
d930 13
@


1.162
log
@sock -> fd; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.161 2004/04/28 17:42:27 deraadt Exp $ */
d1139 3
@


1.161
log
@rename sock to fd
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.160 2004/04/28 06:45:37 henning Exp $ */
d243 1
a243 1
		pfd[PFD_PIPE_MAIN].fd = ibuf_main.sock;
d247 1
a247 1
		pfd[PFD_PIPE_ROUTE].fd = ibuf_rde.sock;
d338 1
a338 1
			pfd[i].fd = ctl_conn->ibuf.sock;
d423 1
a423 1
	p->fd = p->wbuf.sock = -1;
d691 1
a691 1
	peer->fd = peer->wbuf.sock = -1;
d813 1
a813 1
		p->fd = p->wbuf.sock = connfd;
d857 1
a857 1
	peer->wbuf.sock = peer->fd;
@


1.160
log
@if a peer follows the extremely misgiuded path that the RFCs just barely allow
to send a NOTIFICATION and thus ternminating the session when it sees a
capability it doesn't support (who would guess: zebra does so), parse the
data section of the notifcication to find out what what capabilties it didn't
like and do not advertise them the next time the session gets up. In case we
get a notification about unsupported capabilities with an empty data part
(don't ask for RFCs... and guess who does that), disable capabilty announcement
alltogether.
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.159 2004/04/28 00:38:39 henning Exp $ */
d115 1
a115 1
	int			 fd, opt;
d327 2
a328 2
			if (p->sock != -1 && events != 0) {
				pfd[i].fd = p->sock;
d423 1
a423 1
	p->sock = p->wbuf.sock = -1;
d687 3
a689 3
	if (peer->sock != -1) {
		shutdown(peer->sock, SHUT_RDWR);
		close(peer->sock);
d691 1
a691 1
	peer->sock = peer->wbuf.sock = -1;
d791 1
a791 1
		if (p->sock != -1) {
d813 1
a813 1
		p->sock = p->wbuf.sock = connfd;
d839 1
a839 1
	if (peer->sock != -1)
d842 1
a842 1
	if ((peer->sock = socket(peer->conf.remote_addr.af, SOCK_STREAM,
d850 1
a850 1
		if (setsockopt(peer->sock, IPPROTO_TCP, TCP_MD5SIG,
d857 1
a857 1
	peer->wbuf.sock = peer->sock;
d862 1
a862 1
		if (bind(peer->sock, sa, sa->sa_len) == -1) {
d874 1
a874 1
	session_socket_blockmode(peer->sock, BM_NONBLOCK);
d877 1
a877 1
	if (connect(peer->sock, sa, sa->sa_len) == -1) {
d898 1
a898 1
		if (setsockopt(p->sock, IPPROTO_IP, IP_TTL, &ttl,
d907 1
a907 1
		if (setsockopt(p->sock, IPPROTO_IPV6, IPV6_HOPLIMIT, &ttl,
d915 1
a915 1
	if (setsockopt(p->sock, IPPROTO_TCP, TCP_NODELAY, &nodelay,
d924 1
a924 1
	    setsockopt(p->sock, IPPROTO_IP, IP_TOS, &pre, sizeof(pre)) == -1) {
d956 1
a956 1
	if (getsockname(peer->sock, (struct sockaddr *)&peer->sa_local,
d960 1
a960 1
	if (getpeername(peer->sock, (struct sockaddr *)&peer->sa_remote,
d1294 2
a1295 3
		if ((n = read(p->sock, p->rbuf->buf + p->rbuf->wpos,
			    sizeof(p->rbuf->buf) - p->rbuf->wpos)) ==
			    -1) {
@


1.159
log
@prefix the auth related defines by AUTH_, we had a name clash, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.158 2004/04/27 22:42:13 henning Exp $ */
d425 2
d978 11
a988 8
		/* multiprotocol extensions, RFC 2858 */
		bzero(&capa_mp_v4, sizeof(capa_mp_v4));
		capa_mp_v4.afi = AFI_IPv4;
		capa_mp_v4.safi = SAFI_UNICAST;
		op_len += 6;	/* 1 code + 1 len + 4 data */

		/* route refresh, RFC 2918 */
		op_len += 2;	/* 1 code + 1 len, no data */
d1026 22
a1047 14
		/* multiprotocol extensions, RFC 2858 */
		capa_code = CAPA_MP;
		capa_len = 4;
		errs += buf_add(buf, &capa_code, sizeof(capa_code));
		errs += buf_add(buf, &capa_len, sizeof(capa_len));
		errs += buf_add(buf, &capa_mp_v4.afi, sizeof(capa_mp_v4.afi));
		errs += buf_add(buf, &capa_mp_v4.pad, sizeof(capa_mp_v4.pad));
		errs += buf_add(buf, &capa_mp_v4.safi, sizeof(capa_mp_v4.safi));

		/* route refresh, RFC 2918 */
		capa_code = CAPA_REFRESH;
		capa_len = 0;
		errs += buf_add(buf, &capa_code, sizeof(capa_code));
		errs += buf_add(buf, &capa_len, sizeof(capa_len));
d1692 2
d1713 5
a1717 1
	/* read & parse data section if needed */
d1719 38
a1756 1
	log_notification(peer, errcode, subcode, p, datalen);
@


1.158
log
@rename the ipsec struct to auth, move all tcpmd5 related fields in there, and
add a generic "method" field that expresses what method
(none/md5sig/ipsec manual/ipsec ike) is in use
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.157 2004/04/27 17:41:34 henning Exp $ */
d798 1
a798 1
		if (p->conf.auth.method == MD5SIG) {
d847 1
a847 1
	if (peer->conf.auth.method == MD5SIG)
@


1.157
log
@unbreak^2
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.156 2004/04/27 17:25:52 henning Exp $ */
d798 1
a798 1
		if (p->conf.tcp_md5_key[0]) {
d847 1
a847 1
	if (peer->conf.tcp_md5_key[0])
@


1.156
log
@repair
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.155 2004/04/27 04:38:12 deraadt Exp $ */
d983 1
@


1.155
log
@crud stripping; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.154 2004/04/27 04:06:58 henning Exp $ */
d881 2
a882 3
	}

	bgp_fsm(peer, EVNT_CON_OPEN);
@


1.154
log
@announce route refresh capability, and parse announced route refresh capa
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.153 2004/04/27 03:53:43 henning Exp $ */
d458 1
a458 1
			} 
d829 1
a829 1
	int			 n, opt = 1;
d875 1
a875 1
	if ((n = connect(peer->sock, sa, sa->sa_len)) == -1)
d881 1
d883 1
a883 2
	if (n == 0)
		bgp_fsm(peer, EVNT_CON_OPEN);
d971 1
a971 1
	int			 errs = 0, n;
d1048 1
a1048 1
		if ((n = buf_close(&p->wbuf, buf)) == -1) {
d1070 1
a1070 1
	int			 errs = 0, n;
d1101 1
a1101 1
	if ((n = buf_close(&peer->wbuf, buf)) == -1) {
d1120 1
a1120 1
	int			 errs = 0, n;
d1157 1
a1157 1
	if ((n = buf_close(&p->wbuf, buf)) == -1) {
d1176 1
a1176 1
	int			 errs = 0, n;
d1212 1
a1212 1
	if ((n = buf_close(&peer->wbuf, buf)) == -1) {
d1612 1
a1612 1
			/* not reached */			
@


1.153
log
@initial route refresh support per RFC2918
process incoming route refresh request and notify the RDE
not advertised via capabilities yet, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.152 2004/04/26 09:35:39 markus Exp $ */
d1029 1
d1031 4
d1779 3
@


1.152
log
@load ipsec SAs into the kernel and enable them.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.151 2004/04/26 01:43:13 henning Exp $ */
d76 1
d1327 4
d1427 9
d1636 26
@


1.151
log
@announce multiprotocol capabilities - IPv4 multicast for now
this implies ourgoing capabilities annoucnement is there and just needs the
values to be filled in for other shitz we'll support soonish
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.148 2004/04/25 19:12:57 henning Exp $ */
d453 1
a453 1
			if (pfkey_auth_establish(peer) == -1) {
d455 1
a455 1
				    "pfkey_auth setup failed");
d457 1
a457 1
			}
d723 1
a723 1
		pfkey_auth_remove(peer);
@


1.150
log
@better error logging in parse_capabilities()
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.149 2004/04/25 22:31:03 henning Exp $ */
d972 2
d977 5
d1020 8
a1027 1
		/* multiprotocol extensions, RFC 2858 */	
@


1.149
log
@sizeof(op_len) when dealing with op_len, not sizeof(op_type) - same size
so noop
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.148 2004/04/25 19:12:57 henning Exp $ */
d1663 3
a1665 1
		if (len < 2)
d1667 1
d1675 5
a1679 1
			if (len < capa_len)
d1681 1
d1690 4
a1693 1
			if (capa_len != 4)
d1695 1
d1700 4
a1703 1
				if (mp_safi < 1 || mp_safi > 3)
d1705 1
d1709 4
a1712 1
				if (mp_safi < 1 || mp_safi > 3)
d1714 1
@


1.148
log
@if remote-as was not configured, inherit the AS from the neighbors open
message for cloned neighbors, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.147 2004/04/25 18:21:18 henning Exp $ */
d1535 2
a1536 2
		p += sizeof(op_type);
		plen -= sizeof(op_type);
@


1.147
log
@reserve upper half of the (internal) ID space for cloned neighbors, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.146 2004/04/25 08:06:00 henning Exp $ */
d1464 4
@


1.146
log
@do not kill cloned neighbors on reload, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.145 2004/04/25 07:16:24 henning Exp $ */
d1915 1
a1915 1
		for (id = 1; id < UINT_MAX; id++) {
@


1.145
log
@add "neighbor cloning", allowing you to specify a prefix and prefixlength
instead of the neighbor's IP address. WHen a connection comes in matching
that mask we clone the neighbor spec.
IPv6 match code by itojun, rde feeding by claudio, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.144 2004/04/24 20:15:49 henning Exp $ */
d1779 2
a1780 1
				if (p->conf.reconf_action == RECONF_NONE)
@


1.144
log
@make failure in setting up the listeners non-fatal. should make bgpd work
on inet only kernels again, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.143 2004/04/24 19:36:19 henning Exp $ */
d84 1
d459 1
a459 1
			if (peer->conf.passive) {
d726 1
a726 1
		if (event != EVNT_STOP) {
d732 2
d1882 2
a1883 1
	struct peer *p;
d1887 2
a1888 1
		if (p->conf.remote_addr.af == ip->sa_family) {
d1900 45
d1948 37
d2039 1
@


1.143
log
@some rather boring windows talk at cansecwest made me hack initial support
for IPv6 transport
parts based on a diff from Brent Graveland
ok itojun@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.142 2004/04/16 04:52:26 henning Exp $ */
d116 1
a116 1
		return (-1);
d118 3
a120 1
	if ((fd = socket(sa->sa_family, SOCK_STREAM, IPPROTO_TCP)) == -1)
d122 1
d132 1
a132 1
		return (-1);
d139 1
a139 1
		return (-1);
d190 2
a191 6
	if ((sock = setup_listener((struct sockaddr *)&conf->listen_addr)) ==
	    -1)
		fatalx("IPv4 listener setup failed");
	if ((sock6 = setup_listener((struct sockaddr *)&conf->listen6_addr)) ==
	    -1)
		fatalx("IPv6 listener setup failed");
@


1.142
log
@let getpeerbyip work for both v4 and v6
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.140 2004/04/13 22:53:29 henning Exp $ */
d48 5
a52 4
#define PFD_PIPE_MAIN	1
#define PFD_PIPE_ROUTE	2
#define	PFD_SOCK_CTL	3
#define PFD_PEERS_START	4
d55 1
a55 1
int	setup_listener(void);
d92 1
d111 1
a111 1
setup_listener(void)
d115 4
a118 1
	if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
d127 1
a127 2
	if (bind(fd, (struct sockaddr *)&conf->listen_addr,
	    sizeof(conf->listen_addr))) {
a141 1

d187 6
a192 2
	if ((sock = setup_listener()) == -1)
		fatalx("listener setup failed");
d240 2
d356 5
d892 1
a892 1
	if (p->conf.ebgp)
d901 9
d919 2
a920 1
	if (setsockopt(p->sock, IPPROTO_IP, IP_TOS, &pre, sizeof(pre)) == -1) {
@


1.141
log
@make log_conn_attempt work in an address family independent matter
@
text
@d82 1
a82 1
struct peer		*getpeerbyaddr(struct bgpd_addr *);
d756 1
a756 1
	struct sockaddr_in	 cliaddr;
d768 1
a768 1
	p = getpeerbyip(cliaddr.sin_addr.s_addr);
d1854 1
a1854 1
getpeerbyip(in_addr_t ip)
d1859 12
a1870 3
	for (p = peers; p != NULL &&
	    p->conf.remote_addr.v4.s_addr != ip; p = p->next)
		;	/* nothing */
d1872 1
a1872 1
	return (p);
@


1.140
log
@parse the BGP Multiprotocol Extensions (RFC 2858) capabilities and store in
the peer struct, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.139 2004/03/20 23:17:35 david Exp $ */
d803 1
a803 1
		log_conn_attempt(p, cliaddr.sin_addr);
@


1.139
log
@comment spelling fixes; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.138 2004/03/18 15:09:31 henning Exp $ */
d1627 3
a1629 1
	void		*capa_val;
d1651 20
@


1.138
log
@when we are in state CONNECT, i. e. we have a half-open tcp connection
to the peer, and we get a connection from exactly that peer, we used to
refuse it (because we already had a - tho only half-open - connection).
this diff changes that so that the connection request from the neighbor is
preferred in only that specific case, and the existing half-open connection
is teared down.  this can speed up session re-establishment quite a bit,
especially with multihop.
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.137 2004/03/16 12:06:42 henning Exp $ */
d817 1
a817 1
	 * decribes; we simply make sure there is only ever one concurrent
@


1.137
log
@delay creating the control socket until after forking, but before chroot
(lives in /var/run, i. e. outside chroot) and privdrop.
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.136 2004/03/15 11:48:04 henning Exp $ */
d773 7
a779 3
			shutdown(connfd, SHUT_RDWR);
			close(connfd);
			return;
@


1.136
log
@properly check chdir success after chroot() and tweak err msgs a little,
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.135 2004/03/12 19:33:30 henning Exp $ */
d168 4
@


1.135
log
@not debugging any more
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.134 2004/03/11 13:35:05 claudio Exp $ */
d173 3
a175 2
		fatal("chroot failed");
	chdir("/");
@


1.134
log
@Free unneeded mrt lists in SE and on exit. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.133 2004/03/10 15:15:48 henning Exp $ */
d390 1
a390 1
	exit(0);
@


1.133
log
@pass a pointer to the network list as well to session_main so we can free()
the members after fork
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.132 2004/03/10 14:54:11 henning Exp $ */
d142 1
a142 1
    int pipe_m2s[2], int pipe_s2r[2])
d150 2
d218 6
d376 5
@


1.132
log
@while walking the peer list on shutdown free the peer structs
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.131 2004/03/10 14:45:25 henning Exp $ */
d141 2
a142 1
    struct filter_head *rules, int pipe_m2s[2], int pipe_s2r[2])
d149 1
d209 6
@


1.131
log
@pass a pointer to the filter rule list to session_main() so we can free()
the list entries and the head there after forking
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.130 2004/03/10 14:29:37 henning Exp $ */
d356 2
a357 1
	for (p = peers; p != NULL; p = p->next)
d359 2
@


1.130
log
@when we exit try to write out what is left in the msg buffers for the imsg
pipes and clear buffers afterwards
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.129 2004/03/10 13:45:16 henning Exp $ */
d140 2
a141 2
session_main(struct bgpd_config *config, struct peer *cpeers, int pipe_m2s[2],
    int pipe_s2r[2])
d143 9
a151 8
	int		 nfds, i, j, timeout, idx_peers;
	pid_t		 pid;
	time_t		 nextaction;
	struct passwd	*pw;
	struct peer	*p, *peer_l[OPEN_MAX], *last, *next;
	struct pollfd	 pfd[OPEN_MAX];
	struct ctl_conn	*ctl_conn;
	short		 events;
d201 7
d366 1
a366 1
	_exit(0);
@


1.129
log
@remove unused function
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.128 2004/03/10 11:38:33 henning Exp $ */
d350 5
@


1.128
log
@implement framework to announce capabilities in the open messages we send.
this includes handling "unsupported optional parameter" notifications from the
peer and retrying without capability announcement. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.127 2004/03/05 21:48:28 henning Exp $ */
a60 1
void	session_terminate(void);
a632 13
}

void
session_terminate(void)
{
	struct peer	*p;

	for (p = peers; p != NULL; p = p->next)
		bgp_fsm(p, EVNT_STOP);

	shutdown(sock, SHUT_RDWR);
	close(sock);
	sock = -1;
@


1.127
log
@huch, remove a debug message
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.126 2004/03/05 20:25:30 henning Exp $ */
d368 1
d507 7
a513 2
			parse_notification(peer);
			change_state(peer, STATE_IDLE, event);
d913 9
d923 1
a923 1
	len = MSGSIZE_OPEN_MIN;
d935 1
a935 1
	msg.optparamlen = 0;
d950 9
a1578 1
	/* log */
d1580 5
@


1.126
log
@add a parser for the capability announcements using the OPEN message as per
RFC 3392. we don't support any capability yet but this at least avoids one
session teardown and reestablishment when talking to peers which do support
capability announcement (as in: basically any) and we'll start supporting
some soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.125 2004/03/05 14:09:55 henning Exp $ */
a1589 2
			log_peer_warnx(&peer->conf, "got capability %u len %u",
			    capa_code, capa_len);
@


1.125
log
@improve logging when we are unhappy with an OPEN message, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.124 2004/03/05 13:30:01 henning Exp $ */
d78 1
d1446 2
a1447 2
		p++;
		plen--;
d1449 2
a1450 2
		p++;
		plen--;
d1467 9
d1557 38
@


1.124
log
@let parse_open() call change_state() on error itself, so that after sending
a notification about disagreement on optional parameters we do not
punish the peer by keeping him in Idle state for IdleHoldTime, rather let
him proceed to Connect immediately again. the "punishment" is of course a flap
protection in the first place. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.121 2004/02/26 16:16:41 claudio Exp $ */
d1428 2
d1438 2
d1452 2
d1474 3
@


1.123
log
@implement a parser for the optional attributes in OPEN messages and properly
refuse any if we find them. not refusing means agreement - so we agreed
with our peers on stuff we don't support. oups. claudio ok
@
text
@d498 1
d500 3
a502 5
				change_state(peer, STATE_IDLE, event);
			else {
				session_keepalive(peer);
				change_state(peer, STATE_OPENCONFIRM, event);
			}
d1348 1
a1348 1
	u_int8_t	 version;
d1367 2
d1370 6
a1375 4
			log_peer_warnx(&peer->conf,
			    "peer wants unrecognized version %u", version);
			session_notification(peer, ERR_OPEN,
			    ERR_OPEN_VERSION, &version, sizeof(version));
d1385 1
d1398 1
d1419 1
d1429 1
d1437 1
d1450 1
d1470 3
@


1.122
log
@when a session that had a tcp connection established is pushed back to IDLE,
try to write out what is left in the rite buffers. now notifications do reach
the peer...
@
text
@d1348 1
a1348 1
	u_char		*p;
d1350 1
a1350 1
	u_int16_t	 as;
d1353 7
a1359 1
	u_int8_t	 optparamlen;
d1421 44
a1464 1
	/* handle opt params... */
@


1.121
log
@show rib infrastructure. At least full dumps and per as dumps. Per prefix
dump need some more work. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.120 2004/02/25 19:48:18 claudio Exp $ */
d651 7
@


1.120
log
@Rewrite some parts of the mrt dump handling. It is no longer possible to
dump the filtered updates but therefore it is now possible to dump per
neighbor and also to dump the outgoing messages. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.119 2004/02/21 15:45:14 henning Exp $ */
a1579 1
		case IMSG_CTL_END:
d1584 9
d1725 6
@


1.119
log
@keep O_NONBLOCK after teh tcp sessions are established, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.116 2004/02/17 23:21:21 henning Exp $ */
d95 1
a95 2
int			 mrt_flagall = 0;
struct mrt_config	 mrt_allin;
d198 1
d647 2
d697 9
a705 4
	if (mrt_flagall == 1)
		mrt_dump_state(&mrt_allin, peer->state, state,
		    &peer->conf, conf);
	/* XXX mrt dump per peer */
d895 5
a899 4
	struct msg_open	 msg;
	struct buf	*buf;
	u_int16_t	 len;
	int		 errs = 0, n;
d929 10
d959 1
d983 9
d1009 1
d1039 9
d1065 1
d1094 9
d1250 5
a1254 4
	u_char		*p;
	u_char		 one = 0xff;
	int		 i;
	u_int16_t	 olen;
d1326 9
a1334 3
	if (mrt_flagall == 1)
		mrt_dump_bgp_msg(&mrt_allin, data, *len, 0, &peer->conf, conf);
	/* XXX mrt dump per peer */
d1478 2
a1479 1
	struct mrt_config	 mrt;
d1556 6
a1561 6
			memcpy(&mrt, imsg.data, sizeof(mrt));
			mrt.msgbuf = &ibuf_main.w;
			if (mrt.type == MRT_ALL_IN) {
				mrt_flagall = 1;
				memcpy(&mrt_allin, &mrt, sizeof(mrt_allin));
			}
d1564 10
a1573 4
			memcpy(&mrt, imsg.data, sizeof(mrt));
			if (mrt.type == MRT_ALL_IN) {
				mrt_flagall = 0;
				bzero(&mrt_allin, sizeof(mrt_allin));
@


1.118
log
@fix thinko in the revents & (POLLIN|POLLOUT) case
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.117 2004/02/17 23:55:11 henning Exp $ */
d748 1
a874 1
	session_socket_blockmode(peer->sock, BM_NORMAL);
@


1.117
log
@improve logging on connection open fail
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.116 2004/02/17 23:21:21 henning Exp $ */
d1083 2
d1086 2
a1087 3
				bgp_fsm(p, EVNT_CON_OPENFAIL);
			} else
				bgp_fsm(p, EVNT_CON_OPEN);
@


1.116
log
@init wbuf.sock too in init_peer()
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.115 2004/02/17 21:59:09 henning Exp $ */
a625 2
		peer->sock = -1;
		peer->wbuf.sock = -1;
d627 1
d1079 3
a1081 4
				    &error, &len) == -1)
					log_warnx("unknown socket error");
				else {
					errno = error;
@


1.115
log
@bit better err msgs after buf_close (which can't fail anyway actually)
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.114 2004/02/17 20:48:05 henning Exp $ */
d366 1
a366 1
	p->sock = -1;
@


1.114
log
@check for EAGAIN after read
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.113 2004/02/17 15:53:17 henning Exp $ */
d922 2
a923 5
		if ((n = buf_close(&p->wbuf, buf)) < 0) {
			if (n == -2)
				log_peer_warnx(&p->conf, "Connection closed");
			else
				log_peer_warn(&p->conf, "Write error");
d965 2
a966 5
	if ((n = buf_close(&peer->wbuf, buf)) < 0) {
		if (n == -2)
			log_peer_warnx(&peer->conf, "Connection closed");
		else
			log_peer_warn(&peer->conf, "Write error");
d1011 2
a1012 5
	if ((n = buf_close(&p->wbuf, buf)) < 0) {
		if (n == -2)
			log_peer_warnx(&p->conf, "Connection closed");
		else
			log_peer_warn(&p->conf, "Write error");
d1056 2
a1057 5
	if ((n = buf_close(&peer->wbuf, buf)) < 0) {
		if (n == -2)
			log_peer_warnx(&peer->conf, "Connection closed");
		else
			log_peer_warn(&peer->conf, "Write error");
d1116 1
a1116 1
				log_peer_warn(&p->conf, "Write error");
@


1.113
log
@two more returns; open msg counter might have gotten increased too much
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.112 2004/02/17 15:47:24 claudio Exp $ */
d1140 1
a1140 1
				if (errno != EINTR) {
@


1.112
log
@On write error return and do not try to make a read. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.111 2004/02/17 14:40:16 henning Exp $ */
d929 1
d934 1
@


1.111
log
@init len for getsockname and getpeername, found and ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.110 2004/02/16 13:17:31 claudio Exp $ */
d1128 1
@


1.110
log
@superfluous tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.109 2004/02/16 12:53:15 claudio Exp $ */
d876 1
d880 1
@


1.109
log
@Make the path attribute handling more RFC conformant. Also move the
parser to rde_attr.c where it belongs. Still missing: better aspath loop
detection (should be done afterwards) and some basic error checking for
optional attributes. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.108 2004/02/02 23:15:00 henning Exp $ */
d1558 1
a1558 1
			
@


1.108
log
@2 missing returns in error pathes
From: Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.107 2004/02/01 18:20:59 henning Exp $ */
d1434 1
d1437 1
a1437 1
	u_int8_t		 suberr;
d1546 1
a1546 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(suberr)) {
d1550 1
a1550 1
			if ((p = getpeerbyid(imsg.hdr.peerid)) == NULL)
d1553 1
a1553 4
			else {
				memcpy(&suberr, imsg.data, sizeof(suberr));
				session_notification(p, ERR_UPDATE, suberr,
				    NULL, 0);
d1555 9
@


1.107
log
@put v6 cruft into session_up() while beeing there... claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.106 2004/01/31 21:09:15 henning Exp $ */
d1020 1
d1068 1
@


1.106
log
@rename tcp sockopt TCP_SIGNATURE_ENABLE to TCP_MD5SIG
requested by theo
ok markus@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.105 2004/01/30 11:40:41 henning Exp $ */
d1622 3
a1624 2
		sup.local_addr.v4 =
		    ((struct sockaddr_in *)&peer->sa_local)->sin_addr;
d1626 13
a1638 2
		sup.remote_addr.v4 =
		    ((struct sockaddr_in *)&peer->sa_remote)->sin_addr;
d1641 1
a1641 1
		fatalx("session_up: only AF_INET supported");
@


1.105
log
@-enable md5sig on the listening socket
-on connections we just accepted, check wether md5sig is configured for that
peer, and check wether the connection is md5sig'd too. if not, refuse
tested against cisco 7200.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.103 2004/01/28 23:14:21 henning Exp $ */
d120 2
a121 3
	if (setsockopt(fd, IPPROTO_TCP, TCP_SIGNATURE_ENABLE, &opt,
	    sizeof(opt)) == -1)
		fatal("setsockopt TCPSIGNATURE_ENABLE");
d732 3
a734 3
			if (getsockopt(connfd, IPPROTO_TCP,
			    TCP_SIGNATURE_ENABLE, &opt, &len) == -1)
				fatal("getsockopt TCP_SIGNATURE_ENABLE");
d779 1
a779 1
		if (setsockopt(peer->sock, IPPROTO_TCP, TCP_SIGNATURE_ENABLE,
@


1.104
log
@enable tcp md5sig om the connecting socket when md5sig is configured for that
peer.
I just successfully established an md5sig'd session against a cisco 7200 with
that.
@
text
@d118 5
a122 1
	setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &opt, sizeof(opt));
d708 1
d730 13
@


1.103
log
@improve logging
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.102 2004/01/28 22:12:33 henning Exp $ */
d743 1
a743 1
	int			 n;
d760 8
@


1.102
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.101 2004/01/28 19:24:06 henning Exp $ */
d394 2
a395 1
				log_warnx("pfkey_auth setup failed");
@


1.101
log
@catch SIGINT here as well so we can properly shut down if ^C'ed in debug mode
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.100 2004/01/28 19:18:38 henning Exp $ */
d347 1
a347 1
		
@


1.100
log
@STOP events for all sessions before we exit.
allows for some cleanup to happen, especially we need this to remove
the md5sig flows
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.99 2004/01/28 18:24:25 henning Exp $ */
d102 1
d186 1
@


1.99
log
@repair the bind() in session_connect; only used if local-addr was specified
got broken in the sockaddr_in -> bgpd_addr conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.98 2004/01/28 18:19:32 henning Exp $ */
d343 3
@


1.98
log
@improve logging
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.97 2004/01/28 17:57:08 henning Exp $ */
d758 3
a760 3
	if (peer->conf.local_addr.af)
		if (bind(peer->sock, addr2sa(&peer->conf.local_addr, 0),
		    sizeof(peer->conf.local_addr))) {
d765 1
@


1.97
log
@we need a pfkey_init the gets us a PF_KEY socket before we drop privs
eases other code quite a bit in exchange...
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.96 2004/01/28 17:29:46 henning Exp $ */
d388 2
a389 1
			if (pfkey_auth_establish(peer) == -1)
d391 1
@


1.96
log
@call pfkey_auth_establish() on START events
call pfkey_auth_remove when a session drops back to IDLE state

ok markus@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.95 2004/01/27 16:49:53 henning Exp $ */
d173 3
@


1.95
log
@use a struct bgpd_addr instead of sockaddr_in for peer_config->local_addr and
->remote_addr for easier multiprotocol support

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.94 2004/01/23 18:06:01 henning Exp $ */
d384 4
d653 1
@


1.94
log
@make sure to only use the accept()ed connection of there is no other existing
tcp connection for the peer in question, and shutdown & close it otherwise.
add a comment about collision detection.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.93 2004/01/23 17:59:28 henning Exp $ */
d82 3
a84 1
struct peer	*getpeerbyid(u_int32_t);
d727 2
a728 1
	int		n;
d738 2
a739 1
	if ((peer->sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
d748 2
a749 2
	if (peer->conf.local_addr.sin_addr.s_addr)
		if (bind(peer->sock, (struct sockaddr *)&peer->conf.local_addr,
d763 2
a764 2
	if ((n = connect(peer->sock, (struct sockaddr *)&peer->conf.remote_addr,
	    sizeof(peer->conf.remote_addr))) == -1)
d1423 1
a1423 1
			p = getpeerbyip(pconf->remote_addr.sin_addr.s_addr);
d1522 14
d1542 1
a1542 1
	    p->conf.remote_addr.sin_addr.s_addr != ip; p = p->next)
d1600 27
@


1.93
log
@sync comments with reality and properly log accept() errors
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.92 2004/01/22 20:59:17 henning Exp $ */
d703 6
a708 2
		p->sock = connfd;
		p->wbuf.sock = connfd;
d727 6
a732 3
	/* collision detection, 6.8, missing */

	if (peer->sock != -1)	/* what do we do here? */
@


1.92
log
@make log_peer_* take a struct peer_config instead of the session engine
specific struct peer, and move their prototypes to bgpd.h to make it available
to whole bgpd

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.91 2004/01/22 20:34:56 henning Exp $ */
a689 2
	/* collision detection, 6.8, missing */

a693 1
			/* EINTR check needed? stevens says yes */
d696 1
a696 2
			/* what do we do here? log & ignore? */
			;
@


1.91
log
@use log_warnx and log_info. reclassify a few messages in the process and fix
a few messages.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.90 2004/01/22 19:07:34 henning Exp $ */
d225 1
a225 1
					log_peer_warnx(p, "removed");
d733 1
a733 1
		log_peer_warn(peer, "session_connect socket");
d744 1
a744 1
			log_peer_warn(peer, "session_connect bind");
d759 1
a759 1
			log_peer_warn(peer, "connect");
d781 2
a782 1
			log_peer_warn(p, "session_setup_socket setsockopt TTL");
d789 2
a790 1
		log_peer_warn(p, "session_setup_socket setsockopt TCP_NODELAY");
d796 2
a797 1
		log_peer_warn(p, "session_setup_socket setsockopt TOS");
d836 1
a836 1
session_open(struct peer *peer)
d850 2
a851 2
	if (peer->conf.holdtime)
		msg.holdtime = htons(peer->conf.holdtime);
d858 1
a858 1
		bgp_fsm(peer, EVNT_CON_FATAL);
d871 1
a871 1
		if ((n = buf_close(&peer->wbuf, buf)) < 0) {
d873 1
a873 1
				log_peer_warnx(peer, "Connection closed");
d875 1
a875 1
				log_peer_warn(peer, "Write error");
d877 1
a877 1
			bgp_fsm(peer, EVNT_CON_FATAL);
d881 1
a881 1
		bgp_fsm(peer, EVNT_CON_FATAL);
d884 1
a884 1
	peer->stats.msg_sent_open++;
d917 1
a917 1
			log_peer_warnx(peer, "Connection closed");
d919 1
a919 1
			log_peer_warn(peer, "Write error");
d966 1
a966 1
			log_peer_warnx(p, "Connection closed");
d968 1
a968 1
			log_peer_warn(p, "Write error");
d1013 1
a1013 1
			log_peer_warnx(peer, "Connection closed");
d1015 1
a1015 1
			log_peer_warn(peer, "Write error");
d1023 1
a1023 1
session_dispatch_msg(struct pollfd *pfd, struct peer *peer)
d1031 1
a1031 1
	if (peer->state == STATE_CONNECT) {
d1041 1
a1041 1
					log_peer_warn(peer, "socket error");
d1043 1
a1043 1
				bgp_fsm(peer, EVNT_CON_OPENFAIL);
d1045 1
a1045 1
				bgp_fsm(peer, EVNT_CON_OPEN);
d1049 1
a1049 1
			bgp_fsm(peer, EVNT_CON_OPENFAIL);
d1053 1
a1053 1
			bgp_fsm(peer, EVNT_CON_FATAL);
d1060 1
a1060 1
		bgp_fsm(peer, EVNT_CON_CLOSED);
d1064 1
a1064 1
		bgp_fsm(peer, EVNT_CON_FATAL);
d1068 2
a1069 2
	if (pfd->revents & POLLOUT && peer->wbuf.queued) {
		if ((error = msgbuf_write(&peer->wbuf)) < 0) {
d1071 1
a1071 1
				log_peer_warnx(peer, "Connection closed");
d1073 2
a1074 2
				log_peer_warn(peer, "Write error");
			bgp_fsm(peer, EVNT_CON_FATAL);
d1081 2
a1082 2
		if ((n = read(peer->sock, peer->rbuf->buf + peer->rbuf->wpos,
			    sizeof(peer->rbuf->buf) - peer->rbuf->wpos)) ==
d1085 2
a1086 2
					log_peer_warn(peer, "read error");
					bgp_fsm(peer, EVNT_CON_FATAL);
d1091 1
a1091 1
				bgp_fsm(peer, EVNT_CON_CLOSED);
d1096 2
a1097 2
			av = peer->rbuf->wpos + n;
			peer->stats.last_read = time(NULL);
d1106 1
a1106 1
				if (peer->rbuf == NULL)
d1108 1
a1108 1
				if (parse_header(peer, peer->rbuf->buf + rpos,
d1113 1
a1113 1
				peer->rbuf->rptr = peer->rbuf->buf + rpos;
d1117 2
a1118 2
					bgp_fsm(peer, EVNT_RCVD_OPEN);
					peer->stats.msg_rcvd_open++;
d1121 2
a1122 2
					bgp_fsm(peer, EVNT_RCVD_UPDATE);
					peer->stats.msg_rcvd_update++;
d1125 2
a1126 2
					bgp_fsm(peer, EVNT_RCVD_NOTIFICATION);
					peer->stats.msg_rcvd_notification++;
d1129 2
a1130 2
					bgp_fsm(peer, EVNT_RCVD_KEEPALIVE);
					peer->stats.msg_rcvd_keepalive++;
d1133 1
a1133 1
					session_notification(peer, ERR_HEADER,
d1140 1
a1140 1
			if (peer->rbuf == NULL)
d1145 1
a1145 1
				memcpy(&peer->rbuf->buf, peer->rbuf->buf + rpos,
d1147 1
a1147 1
				peer->rbuf->wpos = left;
d1149 1
a1149 1
				peer->rbuf->wpos = 0;
d1168 1
a1168 1
			log_peer_warnx(peer, "received message: sync error");
d1182 2
a1183 2
		log_peer_warnx(peer, "received message: illegal length: %u byte",
		    *len);
d1192 1
a1192 1
			log_peer_warnx(peer,
d1201 1
a1201 1
			log_peer_warnx(peer,
d1211 1
a1211 1
			log_peer_warnx(peer,
d1220 1
a1220 1
			log_peer_warnx(peer,
d1228 2
a1229 1
		log_peer_warnx(peer, "received msg with unknown type %u", *type);
d1258 1
a1258 1
			log_peer_warnx(peer,
d1269 1
a1269 1
		log_peer_warnx(peer, "peer AS %u unacceptable", ntohs(as));
d1279 2
a1280 2
		log_peer_warnx(peer, "peer requests unacceptable holdtime %u",
		    holdtime);
d1299 1
a1299 1
		log_peer_warnx(peer, "peer BGPID %lu unacceptable",
@


1.90
log
@log_peer_err -> log_peer_warn
log_peer_errx -> log_peer_warnx
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.89 2004/01/22 03:18:04 henning Exp $ */
d181 1
a181 1
	logit(LOG_INFO, "session engine ready");
d339 1
a339 1
	logit(LOG_INFO, "session engine exiting");
d936 1
a936 1
		logit(LOG_CRIT, "no such peer: id=%u", peerid);
d1035 1
a1035 1
					logit(LOG_CRIT, "unknown socket error");
d1132 2
a1133 3
					logit(LOG_CRIT,
					    "received message with unknown type"
					    " %u", msgtype);
d1449 1
a1449 1
			logit(LOG_INFO, "SE reconfigured");
d1482 1
a1482 1
				logit(LOG_CRIT, "RDE sent invalid update");
d1491 1
a1491 2
				logit(LOG_CRIT,
				    "RDE sent invalid notification");
d1495 1
a1495 1
				logit(LOG_CRIT, "no such peer: id=%u",
@


1.89
log
@s/log_err/log_warn/
it is like warn(3), nor err(3). so use a less confusing name.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.88 2004/01/17 18:05:46 henning Exp $ */
d225 1
a225 1
					log_peer_errx(p, "removed");
d733 1
a733 1
		log_peer_err(peer, "session_connect socket");
d744 1
a744 1
			log_peer_err(peer, "session_connect bind");
d759 1
a759 1
			log_peer_err(peer, "connect");
d781 1
a781 1
			log_peer_err(p, "session_setup_socket setsockopt TTL");
d788 1
a788 1
		log_peer_err(p, "session_setup_socket setsockopt TCP_NODELAY");
d794 1
a794 1
		log_peer_err(p, "session_setup_socket setsockopt TOS");
d870 1
a870 1
				log_peer_errx(peer, "Connection closed");
d872 1
a872 1
				log_peer_err(peer, "Write error");
d914 1
a914 1
			log_peer_errx(peer, "Connection closed");
d916 1
a916 1
			log_peer_err(peer, "Write error");
d963 1
a963 1
			log_peer_errx(p, "Connection closed");
d965 1
a965 1
			log_peer_err(p, "Write error");
d1010 1
a1010 1
			log_peer_errx(peer, "Connection closed");
d1012 1
a1012 1
			log_peer_err(peer, "Write error");
d1038 1
a1038 1
					log_peer_err(peer, "socket error");
d1068 1
a1068 1
				log_peer_errx(peer, "Connection closed");
d1070 1
a1070 1
				log_peer_err(peer, "Write error");
d1082 1
a1082 1
					log_peer_err(peer, "read error");
d1166 1
a1166 1
			log_peer_errx(peer, "received message: sync error");
d1180 1
a1180 1
		log_peer_errx(peer, "received message: illegal length: %u byte",
d1190 1
a1190 1
			log_peer_errx(peer,
d1199 1
a1199 1
			log_peer_errx(peer,
d1209 1
a1209 1
			log_peer_errx(peer,
d1218 1
a1218 1
			log_peer_errx(peer,
d1226 1
a1226 1
		log_peer_errx(peer, "received msg with unknown type %u", *type);
d1255 1
a1255 1
			log_peer_errx(peer,
d1266 1
a1266 1
		log_peer_errx(peer, "peer AS %u unacceptable", ntohs(as));
d1276 1
a1276 1
		log_peer_errx(peer, "peer requests unacceptable holdtime %u",
d1296 1
a1296 1
		log_peer_errx(peer, "peer BGPID %lu unacceptable",
@


1.88
log
@allow the interfaces as bgpd sees 'em to be queried via imsgs
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.87 2004/01/13 13:34:56 claudio Exp $ */
d826 1
a826 1
		log_err("getsockname");
d829 1
a829 1
		log_err("getpeername");
@


1.87
log
@Better update error handling. Ensure that the session goes down and
ignore all queued updates after an error. Looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.86 2004/01/11 20:13:00 claudio Exp $ */
d1470 1
@


1.86
log
@Add to the IMSG_SESSION_UP message the local and remote address of the
peer session. This is needed to set the correct nexthop address in outgoing
bgp UPDATES. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.85 2004/01/11 18:42:25 henning Exp $ */
d1382 1
d1486 17
@


1.85
log
@clean up setting the poll events a bit. no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.84 2004/01/11 02:35:14 henning Exp $ */
d1531 17
d1550 1
a1550 1
	    &peer->remote_bgpid, sizeof(peer->remote_bgpid)) == -1)
@


1.84
log
@new message IMSG_CTL_SHOW_NEXTHOP: request/send lost of BGP nexthops and
the result of their validity check
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.83 2004/01/11 01:04:43 henning Exp $ */
d145 1
d273 1
a273 1
			p->events = POLLIN;
d275 1
a275 1
				p->events |= POLLOUT;
d278 1
a278 1
			if (p->sock != -1 && p->events != 0) {
d280 1
a280 1
				pfd[i].events = p->events;
a370 1
			peer->events = 0;
a635 1
		peer->events = 0;
a656 1
		peer->events = (POLLIN|POLLOUT);
a658 1
		peer->events = (POLLIN|POLLOUT);
a660 1
		peer->events = POLLIN;
a662 1
		peer->events = POLLIN;
a664 1
		peer->events = POLLIN;
@


1.83
log
@once the tcp session is established use gettsockname/getpeername to get
local/remote sockaddr and store it in the peer struct

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.82 2004/01/10 22:25:58 henning Exp $ */
d1474 1
@


1.82
log
@re-enable sending outgoing updates

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.81 2004/01/10 20:28:48 henning Exp $ */
d66 1
d403 1
d430 1
d825 14
a844 2

	session_socket_blockmode(peer->sock, BM_NORMAL);
@


1.81
log
@we are only interested in POLLOUT for a session socket when we either
have queued writes or the connection is not yet established - but certainly
not if we ever had a queued write, forever...

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.80 2004/01/10 17:50:45 henning Exp $ */
a1471 1
#if 0
a1474 1
#endif
@


1.80
log
@disable sending UPDATEs for now; it triggers som blocking bug...

ok & debugging band-aid claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.79 2004/01/10 17:10:22 henning Exp $ */
d271 2
a272 1
			if (p->wbuf.queued > 0)
@


1.79
log
@i buy a break;
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.78 2004/01/10 17:04:07 henning Exp $ */
d1471 1
d1475 2
@


1.78
log
@send out UPDATE messages to the peer(s) that we receive from the RDE

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.77 2004/01/09 19:08:50 henning Exp $ */
d1462 1
@


1.77
log
@for IMSG_CTL_KROUTEs allow matching based on flags,
add IMGS_CTL_KROUTE_ADDR to match the route for a given address

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.76 2004/01/09 13:47:08 henning Exp $ */
d68 1
a68 1
void	session_update(struct peer *);
d81 2
d917 1
a917 1
session_update(struct peer *peer)
d919 43
a961 2
	start_timer_keepalive(peer);
	peer->stats.msg_sent_update++;
d1460 1
a1460 1
				fatalx("reconf request not from parent");
d1462 11
d1488 13
@


1.76
log
@get us a stateful imsg relaying framework, and the first receiver,
IMSG_CTL_KROUTE, to have the kroute structs forming the fib sent to a
control socket.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.74 2004/01/07 01:41:49 henning Exp $ */
d1414 1
@


1.75
log
@we must ignore SIGPIPE.
we do notice closed pipes just fine, tho there was at least one case where
we tried a write without POLLOUT and that got us a SIGPIPE before our pipe
closed detection catched it.

ok claudio@@
@
text
@d1413 5
d1457 1
a1457 1
imsg_compose_parent(int type, u_int32_t peerid, void *data, u_int16_t datalen)
d1459 1
a1459 1
	return (imsg_compose(&ibuf_main, type, peerid, data, datalen));
@


1.74
log
@handle global vs peer-specific holdtime in a nicer and reload-friendlier
way
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.73 2004/01/07 01:15:54 henning Exp $ */
d176 1
@


1.73
log
@don't try to be smart after config reloads and try to detect wether
a session needs a reinit for the new conf to kick in. the logic is
condemned to fail, and implicitly taking sessions down is BAD.

after discussion with mickey@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.72 2004/01/06 23:14:58 henning Exp $ */
a350 5
	
	if (!p->conf.holdtime)
		p->conf.holdtime = conf->holdtime;
	if (!p->conf.min_holdtime)
		p->conf.min_holdtime = conf->min_holdtime;
d834 4
a837 1
	msg.holdtime = htons(peer->conf.holdtime);
d1189 1
a1189 1
	u_int16_t	 holdtime, oholdtime;
d1228 5
a1232 1
	if (holdtime < peer->conf.holdtime)
d1235 1
a1235 1
		peer->holdtime = peer->conf.holdtime;
@


1.72
log
@two new imsg types, IMSG_CTL_NEIGHBOR_UP and _DOWN, on their receival on the
control socket the given neighbor session is sent a START / STOP signal.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.71 2004/01/06 21:48:19 henning Exp $ */
a1367 15
			if (bcmp(&p->conf.remote_addr, &pconf->remote_addr,
			    sizeof(struct sockaddr_in)))
				reconf = RECONF_REINIT;
			if (bcmp(&p->conf.local_addr, &pconf->local_addr,
			    sizeof(struct sockaddr_in)))
				reconf = RECONF_REINIT;
			if (p->conf.remote_as != pconf->remote_as)
				reconf = RECONF_REINIT;
			if (p->conf.distance != pconf->distance)
				reconf = RECONF_REINIT;

			if (p->state <= STATE_ACTIVE &&
			    p->conf.passive && !pconf->passive)
				reconf = RECONF_REINIT;

a1369 12
			if (pconf->reconf_action > reconf)
				p->conf.reconf_action = pconf->reconf_action;

			if (p->state >= STATE_OPENSENT) {
				if (p->holdtime == conf->holdtime &&
				    nconf->holdtime > conf->holdtime)
					p->conf.reconf_action = RECONF_REINIT;
				if (p->holdtime > nconf->holdtime)
					p->conf.reconf_action = RECONF_REINIT;
				if (p->holdtime < nconf->min_holdtime)
					p->conf.reconf_action = RECONF_REINIT;
			}
@


1.71
log
@initialize new peers inline instead of looping through 'em initing each
before the mainloop started, and a speerate init for those coming in
on reloads. much easier this way.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.70 2004/01/06 20:44:15 henning Exp $ */
a56 1
void	bgp_fsm(struct peer *, enum session_events);
@


1.70
log
@in session_dispatch_msg, in the loop where we suck the messages out of the
buffers, we need to check wether the buffers are still there before trying to
get the next message. the previous one might have caused the session to drop
back to the IDLE state, which implies that those buffers have been
deallocated.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.68 2004/01/06 19:19:21 henning Exp $ */
d56 1
a56 1
void	init_peers(void);
a184 1
	init_peers();
d210 1
a210 1
					change_state(p, STATE_IDLE, EVNT_NONE);
d346 1
a346 1
init_peers(void)
d348 1
a348 1
	struct peer	*p;
d350 7
a356 10
	for (p = peers; p != NULL; p = p->next) {
		if (p->state == STATE_NONE) {
			change_state(p, STATE_IDLE, EVNT_NONE);
			p->IdleHoldTimer = time(NULL);	/* start ASAP */
		}
		if (!p->conf.holdtime)
			p->conf.holdtime = conf->holdtime;
		if (!p->conf.min_holdtime)
			p->conf.min_holdtime = conf->min_holdtime;
	}
a1362 1
				p->sock = -1;
a1387 5

			if (!p->conf.holdtime)
				p->conf.holdtime = nconf->holdtime;
			if (!p->conf.min_holdtime)
				p->conf.min_holdtime = nconf->min_holdtime;
@


1.69
log
@allow holdtime and holdtime min to be configuered per peer

ok claudio@@
@
text
@d1049 4
d1056 2
d1091 3
@


1.68
log
@properly punish oscillating neighbors.
previously we were to forgiving so the punishment didn't kick in as
intended
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.67 2004/01/06 18:01:26 henning Exp $ */
d356 4
d844 1
a844 1
	msg.holdtime = htons(conf->holdtime);
d1219 1
a1219 1
	if (holdtime && holdtime < conf->min_holdtime) {
d1226 1
a1226 1
	if (holdtime < conf->holdtime)
d1229 1
a1229 1
		peer->holdtime = conf->holdtime;
d1384 5
@


1.67
log
@rename our StartTimer to IdleHoldTimer as per draft-ietf-idr-bgp4-23
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.66 2004/01/06 03:43:50 henning Exp $ */
d243 11
d265 3
d642 1
d651 2
a652 1
			if (peer->IdleHoldTime < UINT_MAX / 2)
d670 3
a672 1
		peer->IdleHoldTime = INTERVAL_IDLE_HOLD_INITIAL;
@


1.66
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.65 2004/01/05 22:57:58 claudio Exp $ */
d216 1
a216 1
					p->StartTimer = time(NULL);
d241 1
a241 1
			if (timer_due(p->StartTimer))
d252 2
a253 2
			if (p->StartTimer && p->StartTimer < nextaction)
				nextaction = p->StartTimer;
d340 1
a340 1
			p->StartTimer = time(NULL);	/* start ASAP */
d358 1
a358 1
			peer->StartTimer = 0;
d622 2
a623 2
		if (peer->StartTimerInterval == 0)
			peer->StartTimerInterval = INTERVAL_START;
d635 3
a637 4
			peer->StartTimer = time(NULL) +
			    peer->StartTimerInterval;
			if (peer->StartTimerInterval < UINT_MAX / 2)
				peer->StartTimerInterval *= 2;
d654 1
a654 1
		peer->StartTimerInterval = INTERVAL_START;
@


1.65
log
@Big overhaul of the mrt code.
Dumping of incomming bgp messages is now possible and dumping the (not yet)
filtered updates works too. Per neighbor dumps are still missing.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.64 2004/01/04 23:08:09 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
@


1.64
log
@cope with poll error
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.63 2004/01/04 20:21:07 henning Exp $ */
d44 1
d91 3
d663 4
d1154 3
d1296 1
d1398 15
d1455 1
a1455 1
}@


1.63
log
@err, on receival of keepalives increase the keepalive counter, not the update
counter...
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.62 2004/01/04 20:07:30 henning Exp $ */
d277 4
a280 4
		nfds = poll(pfd, i, timeout * 1000);
		/*
		 * what do we do on poll error?
		 */
@


1.62
log
@keep seperate message counters for open/update/keepalive/notification
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.61 2004/01/04 19:39:46 henning Exp $ */
d1045 1
a1045 1
					peer->stats.msg_rcvd_update++;
@


1.61
log
@-new imsg CTL_RELOAD
-upong receival in the SE forward to parent
-make sending messages from SE to parent work for that (was not required before)
-parent reacts to that just like a SIGHUP, reread config file
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.60 2004/01/04 18:51:23 henning Exp $ */
d846 1
a846 1
	peer->stats.msg_send++;
d888 1
a888 1
	peer->stats.msg_send++;
d895 1
d940 1
a940 1
	peer->stats.msg_send++;
d1033 1
d1037 1
d1041 1
d1045 1
a1054 1
				peer->stats.msg_rcvd++;
@


1.60
log
@allow "show neighbor" to be limited to one specific neighbor
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.59 2004/01/04 17:19:41 henning Exp $ */
d189 2
d286 4
d1419 6
@


1.59
log
@in the SE, keep the remote router-id in network byte order, just like
every other IP address
in the RDE, transform in into host byte order upon receival
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.58 2004/01/03 22:44:28 henning Exp $ */
a79 2

struct peer	*getpeerbyip(in_addr_t);
@


1.58
log
@keep track of last session up/down and last successfull read
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.57 2004/01/03 22:18:58 henning Exp $ */
d1202 1
a1202 1
	peer->remote_bgpid = ntohl(bgpid);
@


1.57
log
@add message counters
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.56 2004/01/03 20:22:07 henning Exp $ */
d1013 1
d1401 1
d1410 1
@


1.56
log
@decouple the peer list from bgpd_config.
so many parts of bgpd are not at all interested in the session specific peer
structs... allows for some further cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.55 2004/01/03 14:06:35 henning Exp $ */
d841 2
d884 1
d935 1
d1045 1
@


1.55
log
@change imsg_read semantics so that the number of bytes read is returned.
that means that the callers can (and must) coope with closed connections
themselves, what is exactly the desired behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.54 2004/01/01 23:46:47 henning Exp $ */
d83 2
a84 1
struct bgpd_config	*nconf = NULL;
d131 2
a132 1
session_main(struct bgpd_config *config, int pipe_m2s[2], int pipe_s2r[2])
d134 1
a134 1
	int		 nfds, i, j, timeout, npeers;
d138 1
a138 1
	struct peer	*p, *peers[OPEN_MAX], *last, *next;
d143 1
d202 1
a202 1
		for (p = conf->peers; p != NULL; p = next) {
d222 1
a222 1
						conf->peers = next;
d259 1
a259 1
				peers[i] = p;
d264 1
a264 1
		npeers = i;
d305 2
a306 2
		for (j = PFD_PEERS_START; nfds > 0 && j < npeers; j++)
			nfds -= session_dispatch_msg(&pfd[j], peers[j]);
d329 1
a329 1
	for (p = conf->peers; p != NULL; p = p->next) {
d593 1
a593 1
	for (p = conf->peers; p != NULL; p = p->next)
d1297 1
a1297 1
			nconf->peers = NULL;
d1312 2
a1313 2
				p->next = nconf->peers;
				nconf->peers = p;
d1358 1
a1358 1
			for (p = nconf->peers; p != NULL; p = next) {
d1360 2
a1361 2
				p->next = conf->peers;
				conf->peers = p;
d1364 1
a1364 1
			for (p = conf->peers; p != NULL; p = p->next)
d1385 1
a1385 1
	for (p = conf->peers; p != NULL &&
@


1.54
log
@listen on a AF_LOCAL socket for imsgs too.
only implemented type yet is IMSG_CTL_SHOW_NEIGHBOR which sends back
the struct peer for all neighbors.
will be used by bgpdctl
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.53 2004/01/01 23:09:09 henning Exp $ */
d1273 1
a1273 1
	if (imsg_read(ibuf) == -1)
d1275 3
@


1.53
log
@now that imsg_get uses bigger buffers, one read call can put more than one
imsg into the buffer. since imsg_get by definition only returns one imsg we
missed the next imsg(s) until the next poll event on the socket in question,
building up a queue on that socket. didn't show up as a problem yet...
factor out imsg_read, which reads into the buffer. imsg_get now entirely
operates on the buffers and does not read(2) itself.
make all callers cope by calling imsg_read on poll events and calling
imsg_get in a loop until all imsgs are processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.52 2003/12/30 21:05:09 henning Exp $ */
d25 1
d49 2
a50 6
#define PFD_PEERS_START	3

enum blockmodes {
	BM_NORMAL,
	BM_NONBLOCK
};
a63 1
void	session_socket_blockmode(int, enum blockmodes);
d83 1
a83 1
struct bgpd_config	*conf = NULL, *nconf = NULL;
d87 1
d132 1
a132 1
	int		 nfds, i, j, timeout;
d138 1
d178 2
d192 2
d261 10
d297 6
a302 1
		for (j = PFD_PEERS_START; nfds > 0 && j < i; j++) {
d304 3
a306 1
		}
d309 1
@


1.52
log
@small logic error in session_open/_keepalive/_notification (yes, the same in
all three) after buf_open failure. as this does not happen normally (except
for in out of memory cases) it wasn't noticed.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.51 2003/12/30 19:54:23 henning Exp $ */
d1253 9
a1261 2
	if ((n = imsg_get(ibuf, &imsg)) == -1)
		fatal("imsg_get error");
a1262 1
	if (n > 0) {
@


1.51
log
@we should not access ressources in a peer strcut 2 lines after we
detected a closed connection which caused an fsm call which causes a
deallocation of said ressources
(that was long for "missing return")
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.50 2003/12/30 13:06:00 henning Exp $ */
d792 1
a792 1
	if ((buf = buf_open(len)) == NULL)
d794 2
d834 1
a834 1
	if ((buf = buf_open(len)) == NULL)
d836 2
d855 1
d882 1
a882 1
	if ((buf = buf_open(len)) == NULL)
d884 2
@


1.50
log
@no empty default: cases in switch, gcc3 complaints via espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.49 2003/12/30 13:03:27 henning Exp $ */
d972 1
a972 1
			if (n == 0) /* connection closed */
d974 2
@


1.49
log
@typos from david
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.48 2003/12/28 14:34:30 henning Exp $ */
d350 1
d628 1
d1332 1
@


1.48
log
@redo the imsg readers to use bigger buffers and less read(2)s. should increase
performance even further.
gets rif od struct imsg_readbuf; rename peer_read_buf to read_buf as that
is more appropriate now.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.47 2003/12/27 14:28:41 henning Exp $ */
d914 1
a914 1
				/* error occured */
@


1.47
log
@few fatal()s should really be fatalx()
From: Dries Schellekens <gwyllion@@ace.ulyssis.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.46 2003/12/26 18:33:11 henning Exp $ */
d330 1
a330 1
			peer->rbuf = calloc(1, sizeof(struct peer_buf_read));
@


1.46
log
@let imsg_get and imsg_compose not fatal() but return errors upstream.
make the callers cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.45 2003/12/26 18:07:33 henning Exp $ */
d164 1
a164 1
		fatal("listener setup failed");
d1249 1
a1249 1
				fatal("reconf request not from parent");
d1260 1
a1260 1
				fatal("reconf request not from parent");
d1307 1
a1307 1
				fatal("reconf request not from parent");
d1309 1
a1309 1
				fatal("got IMSG_RECONF_DONE but no config");
@


1.45
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.44 2003/12/26 16:37:04 henning Exp $ */
d1192 3
a1194 1
	imsg_compose(&ibuf_rde, IMSG_UPDATE, peer->conf.id, p, datalen);
d1240 4
d1245 1
a1245 1
	if (imsg_get(ibuf, &imsg) > 0) {
d1351 3
a1353 2
	imsg_compose(&ibuf_rde, IMSG_SESSION_DOWN, peer->conf.id,
	    NULL, 0);
d1359 3
a1361 2
	imsg_compose(&ibuf_rde, IMSG_SESSION_UP, peer->conf.id,
	    &peer->remote_bgpid, sizeof(peer->remote_bgpid));
@


1.44
log
@log_err -> log_peer_err
log_errx -> log_peer_errx

because that is what they really are, peer specific.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.43 2003/12/25 14:28:49 henning Exp $ */
d146 1
a146 1
		fatal("cannot fork", errno);
d154 1
a154 1
		fatal(NULL, errno);
d157 1
a157 1
		fatal("chroot failed", errno);
d164 1
a164 1
		fatal("listener setup failed", 0);
d169 1
a169 1
		fatal("can't drop privileges", errno);
d278 1
a278 1
				fatal("pipe write error", errno);
d332 1
a332 1
				fatal(NULL, errno);
d758 1
a758 1
		fatal("fnctl F_GETFL", errno);
d766 1
a766 1
		fatal("fnctl F_SETFL", errno);
d1243 1
a1243 1
				fatal("reconf request not from parent", 0);
d1246 1
a1246 1
				fatal(NULL, errno);
d1254 1
a1254 1
				fatal("reconf request not from parent", 0);
d1260 1
a1260 1
					fatal("new_peer", errno);
d1301 1
a1301 1
				fatal("reconf request not from parent", 0);
d1303 1
a1303 1
				fatal("got IMSG_RECONF_DONE but no config", 0);
@


1.43
log
@implement "passive": do not attempt to open a tcp connection to the
neighbor system
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.42 2003/12/25 13:39:00 henning Exp $ */
d213 1
a213 1
					log_errx(p, "removed");
d684 1
a684 1
		log_err(peer, "session_connect socket");
d695 1
a695 1
			log_err(peer, "session_connect bind");
d710 1
a710 1
			log_err(peer, "connect");
d732 1
a732 1
			log_err(p, "session_setup_socket setsockopt TTL");
d739 1
a739 1
		log_err(p, "session_setup_socket setsockopt TCP_NODELAY");
d745 1
a745 1
		log_err(p, "session_setup_socket setsockopt TOS");
d804 1
a804 1
				log_errx(peer, "Connection closed");
d806 1
a806 1
				log_err(peer, "Write error");
d844 1
a844 1
			log_errx(peer, "Connection closed");
d846 1
a846 1
			log_err(peer, "Write error");
d894 1
a894 1
			log_errx(peer, "Connection closed");
d896 1
a896 1
			log_err(peer, "Write error");
d921 1
a921 1
					log_err(peer, "socket error");
d951 1
a951 1
				log_errx(peer, "Connection closed");
d953 1
a953 1
				log_err(peer, "Write error");
d965 1
a965 1
					log_err(peer, "read error");
d1033 1
a1033 1
			log_errx(peer, "received message: sync error");
d1047 1
a1047 1
		log_errx(peer, "received message: illegal length: %u byte",
d1057 1
a1057 1
			log_errx(peer,
d1066 1
a1066 1
			log_errx(peer,
d1076 1
a1076 1
			log_errx(peer,
d1085 1
a1085 1
			log_errx(peer,
d1093 1
a1093 1
		log_errx(peer, "received msg with unknown type %u", *type);
d1119 2
a1120 2
			log_errx(peer, "peer wants unrecognized version %u",
			    version);
d1130 1
a1130 1
		log_errx(peer, "peer AS %u unacceptable", ntohs(as));
d1140 1
a1140 1
		log_errx(peer, "peer requests unacceptable holdtime %u",
d1156 2
a1157 1
		log_errx(peer, "peer BGPID %lu unacceptable", ntohl(bgpid));
@


1.42
log
@make the listening socket nonblocking as well.
there's a small probability that poll() announces us a new connection on the
listening socket that vanishes before we can call accept(), and thus accept()
would block.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.41 2003/12/25 13:17:27 henning Exp $ */
a327 2
			peer->ConnectRetryTimer =
			    time(NULL) + INTERVAL_CONNECTRETRY;
d338 9
a346 2
			change_state(peer, STATE_CONNECT, event);
			session_connect(peer);
d1277 4
@


1.41
log
@small gotcha in the FSM:
if we're in state ACTIVE and get an TIMER_CONNRETRY event, we need to
change the state to CONNECT _before_ we call session_connect() to attempt
a connect, as session_connect can generate events that caus further state
changes.
as far as i saw that it only causes a bit confusion for sessions dangling
between CONNECT and ACTIVE all the time without causing real trouble, but bugs
are bugs, right.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.39 2003/12/24 23:48:05 henning Exp $ */
d50 5
d67 1
a67 1
void	session_socket_blockmode(int, int);
d120 3
d700 1
a700 1
	session_socket_blockmode(peer->sock, 1);
d748 1
a748 1
session_socket_blockmode(int fd, int block)
d755 1
a755 1
	if (block)
d772 1
a772 1
	session_socket_blockmode(peer->sock, 0);
@


1.40
log
@we need nonblocking connect
@
text
@d386 1
a387 1
			change_state(peer, STATE_CONNECT, event);
@


1.39
log
@syscalls return -1 on err so test for == -1 instead of the < 0 found in very
few places, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.38 2003/12/24 23:14:23 henning Exp $ */
d62 1
d692 2
d740 17
d763 2
@


1.38
log
@following up on a discussion with theo, read(2) as much as possible at once
and process the bgp messages after each other out of that big buffer.
gives a nice speedup, easier code and earlier connection close detection.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.37 2003/12/24 21:19:48 henning Exp $ */
d103 1
a103 1
	if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
d147 1
a147 1
	if (chroot(pw->pw_dir) < 0)
d154 1
a154 1
	if ((sock = setup_listener()) < 0)
d669 1
a669 1
	if ((peer->sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
d692 1
a692 1
	    sizeof(peer->conf.remote_addr))) < 0)
@


1.37
log
@EAGAIN can't happen here anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.36 2003/12/24 21:14:22 henning Exp $ */
d326 1
a326 2
			peer->rbuf->wptr = peer->rbuf->buf;
			peer->rbuf->pkt_len = MSGSIZE_HEADER;
d870 1
a870 1
	ssize_t		n, read_total;
d873 2
d926 2
a927 4
		read_total = 0;
		do {
			if ((n = read(peer->sock, peer->rbuf->wptr,
			    peer->rbuf->pkt_len - peer->rbuf->read_len)) ==
d935 35
a969 47
			read_total += n;
			peer->rbuf->wptr += n;
			peer->rbuf->read_len += n;
			if (peer->rbuf->read_len == peer->rbuf->pkt_len) {
				if (!peer->rbuf->seen_hdr) {	/* got header */
					if (parse_header(peer,
					    peer->rbuf->buf,
					    &peer->rbuf->pkt_len,
					    &peer->rbuf->type) == 1) {
						bgp_fsm(peer, EVNT_CON_FATAL);
						return (1);
					}
					peer->rbuf->seen_hdr = 1;
				} else {	/* we got the full packet */
					switch (peer->rbuf->type) {
					case OPEN:
						bgp_fsm(peer, EVNT_RCVD_OPEN);
						break;
					case UPDATE:
						bgp_fsm(peer, EVNT_RCVD_UPDATE);
						break;
					case NOTIFICATION:
						bgp_fsm(peer,
						    EVNT_RCVD_NOTIFICATION);
						break;
					case KEEPALIVE:
						bgp_fsm(peer,
						    EVNT_RCVD_KEEPALIVE);
						break;
					default:	/* cannot happen */
						session_notification(peer,
						    ERR_HEADER, ERR_HDR_TYPE,
						    &peer->rbuf->type, 1);
						logit(LOG_CRIT,
						    "received message with "
						    "unknown type %u",
						    peer->rbuf->type);
					}
					n = 0;	/* give others a chance... */
					if (peer->rbuf != NULL) {
						bzero(peer->rbuf, sizeof(struct
						    peer_buf_read));
						peer->rbuf->wptr =
						    peer->rbuf->buf;
						peer->rbuf->pkt_len =
						    MSGSIZE_HEADER;
					}
d971 1
d973 8
a980 3
		} while (n > 0);
		if (read_total == 0) /* connection closed */
			bgp_fsm(peer, EVNT_CON_CLOSED);
a982 1

d1076 1
a1076 1
	p = peer->rbuf->buf;
d1147 1
a1147 1
	p = peer->rbuf->buf;
d1152 1
a1152 1
	p = peer->rbuf->buf;
d1170 1
a1170 1
	p = peer->rbuf->buf;
d1175 1
a1175 1
	p = peer->rbuf->buf;
@


1.36
log
@no O_NONBLOCK for routing and tcp sockets, theo
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.35 2003/12/24 20:09:57 henning Exp $ */
d930 1
a930 1
				if (errno != EAGAIN && errno != EINTR) {
@


1.35
log
@now that the main process can cleanup without RDE's help, we do not need the
somewhat fragile IMSG_SHUTDOWN_* stuff any more. speeds shutdown up
enourmously.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.34 2003/12/24 13:28:02 henning Exp $ */
a117 4
	if (fcntl(fd, F_SETFL, O_NONBLOCK) == -1) {
		close(fd);
		return (-1);
	}
a685 6

	if (fcntl(peer->sock, F_SETFL, O_NONBLOCK) == -1) {
		log_err(peer, "session_connect fcntl");
		bgp_fsm(peer, EVNT_CON_OPENFAIL);
		return (-1);
	}
@


1.34
log
@handle write() returning 0 correctly, adjust the msgbuf API appropriately,
and make all callers cope.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.33 2003/12/24 11:39:43 henning Exp $ */
a1299 5
			break;
		case IMSG_SHUTDOWN_REQUEST:
			session_terminate();
			imsg_compose(&ibuf_main, IMSG_SHUTDOWN_DONE, 0,
			    NULL, 0);
@


1.33
log
@typos in comments, from jared
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.32 2003/12/23 19:14:49 deraadt Exp $ */
d272 2
a273 2
			if (msgbuf_write(&ibuf_rde.w) == -1)
				fatal("pipe write error", 0);
d753 1
a753 1
	int		 errs = 0;
d778 5
a782 1
		if (buf_close(&peer->wbuf, buf) == -1) {
d798 1
a798 1
	int			 errs = 0;
d818 5
a822 1
	if (buf_close(&peer->wbuf, buf) == -1) {
a824 1
		return;
d826 1
d843 1
a843 1
	int			 errs = 0;
d868 5
a872 1
	if (buf_close(&peer->wbuf, buf) == -1) {
d923 5
a927 1
		if (msgbuf_write(&peer->wbuf))
d929 1
d986 2
a987 2
						bzero(peer->rbuf,
						    sizeof(struct peer_buf_read));
@


1.32
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.31 2003/12/23 18:41:32 henning Exp $ */
d577 1
a577 1
		 * session was not established successfull before, the
@


1.31
log
@play nice on exit (when he listening coket is closed)
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.30 2003/12/23 18:28:05 henning Exp $ */
d122 1
a122 1
	
@


1.30
log
@send shutdown requests to the child processes and wait for a ackmessage from
them when shutting down.
the rde needs the main process to clean up the routing table on exit so the
parent process needs to be in service until the RDE is done.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.29 2003/12/23 16:11:06 henning Exp $ */
d179 2
a180 4
		if (sock != -1) {
			pfd[PFD_LISTEN].fd = sock;
			pfd[PFD_LISTEN].events = POLLIN;
		}
@


1.29
log
@do send session_down imsgs to RDE even if we are quitting
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.28 2003/12/23 01:06:21 henning Exp $ */
d84 1
d130 1
a130 1
	int		 sock, nfds, i, j, timeout;
d179 4
a182 2
		pfd[PFD_LISTEN].fd = sock;
		pfd[PFD_LISTEN].events = POLLIN;
a286 3
	session_terminate();
	shutdown(sock, SHUT_RDWR);
	close(sock);
d564 4
d1285 5
@


1.28
log
@allow the listening address to be specified, default to INADDR_ANY
should make jose@@ happy
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.27 2003/12/21 23:28:39 henning Exp $ */
d1304 2
a1305 3
	if (!session_quit)
		imsg_compose(&ibuf_rde, IMSG_SESSION_DOWN, peer->conf.id,
		    NULL, 0);
@


1.27
log
@rename get_imsg() to imsg_get(); that's more consistent
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.26 2003/12/21 23:26:38 henning Exp $ */
d100 1
a100 2
	int			fd, opt;
	struct sockaddr_in	addr;
d108 2
a109 6
	bzero(&addr, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sin_port = htons(BGP_PORT);

	if (bind(fd, (struct sockaddr *)&addr, sizeof(addr))) {
d121 1
a121 1

@


1.26
log
@wrap read & write buffers for imsgs into a struct.
finally gives us read buffers per pipe instead of per process, eleminating
a possible race.
also gets us a real imsg_init() that does all the boring init work
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.25 2003/12/21 22:16:53 henning Exp $ */
d1207 1
a1207 1
	if (get_imsg(ibuf, &imsg) > 0) {
@


1.25
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.24 2003/12/21 18:21:24 henning Exp $ */
d75 1
a75 1
void	session_dispatch_imsg(int, int);
d84 2
a85 1
struct msgbuf		 msgbuf_rde;
d177 2
a178 3
	msgbuf_init(&msgbuf_rde);
	msgbuf_rde.sock = pipe_s2r[0];
	init_imsg_buf();
d185 1
a185 1
		pfd[PFD_PIPE_MAIN].fd = pipe_m2s[1];
d187 1
a187 1
		pfd[PFD_PIPE_ROUTE].fd = pipe_s2r[0];
d189 1
a189 1
		if (msgbuf_rde.queued > 0)
d272 1
a272 2
			session_dispatch_imsg(pfd[PFD_PIPE_MAIN].fd,
			    PFD_PIPE_MAIN);
d276 1
a276 1
			if (msgbuf_write(&msgbuf_rde) == -1)
d281 1
a281 2
			session_dispatch_imsg(pfd[PFD_PIPE_ROUTE].fd,
			    PFD_PIPE_ROUTE);
d1160 1
a1160 1
	imsg_compose(&msgbuf_rde, IMSG_UPDATE, peer->conf.id, p, datalen);
d1200 1
a1200 1
session_dispatch_imsg(int fd, int idx)
d1207 1
a1207 1
	if (get_imsg(fd, &imsg) > 0) {
d1310 1
a1310 1
		imsg_compose(&msgbuf_rde, IMSG_SESSION_DOWN, peer->conf.id,
d1317 1
a1317 1
	imsg_compose(&msgbuf_rde, IMSG_SESSION_UP, peer->conf.id,
@


1.24
log
@queued_reads in struct peer was not ever used exept for an initialization to 0
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.23 2003/12/20 21:43:45 claudio Exp $ */
a75 1
void	session_write_imsg(int fd);
d84 1
a84 2
int			 s2r_queued_writes = 0;
int			 s2r_sock = -1;
a172 1
	s2r_sock = pipe_s2r[0];
d176 2
d189 1
a189 1
		if (s2r_queued_writes > 0)
d246 1
a246 1
			if (p->queued_writes > 0)
d277 2
a278 1
			session_write_imsg(pfd[PFD_PIPE_ROUTE].fd);
d342 3
d560 1
d593 1
a593 1
		buf_peer_remove(peer);
a595 1
		peer->queued_writes = 0;
d655 1
d685 2
d771 1
a771 1
	if ((buf = buf_open(peer, peer->sock, len)) == NULL)
d783 1
a783 1
		if (buf_close(buf) == -1) {
d807 1
a807 1
	if ((buf = buf_open(peer, peer->sock, len)) == NULL)
d819 1
a819 1
	if (buf_close(buf) == -1) {
d848 1
a848 1
	if ((buf = buf_open(peer, peer->sock, len)) == NULL)
d865 1
a865 1
	if (buf_close(buf) == -1) {
d915 2
a916 2
	if (pfd->revents & POLLOUT && peer->queued_writes) {
		if (buf_peer_write(peer))
d1162 1
a1162 2
	s2r_queued_writes += imsg_compose(s2r_sock, IMSG_UPDATE,
	    peer->conf.id, p, datalen);
a1308 10
session_write_imsg(int fd)
{
	int	n;

	if ((n = buf_sock_write(fd)) == -1)
		fatal("pipe write error", errno);
	s2r_queued_writes -= n;
}

void
d1312 2
a1313 2
		s2r_queued_writes += imsg_compose(s2r_sock, IMSG_SESSION_DOWN,
		    peer->conf.id, NULL, 0);
d1319 2
a1320 2
	s2r_queued_writes += imsg_compose(s2r_sock, IMSG_SESSION_UP,
	    peer->conf.id, &peer->remote_bgpid, sizeof(peer->remote_bgpid));
@


1.23
log
@knf. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.22 2003/12/20 21:31:37 henning Exp $ */
d592 1
a592 1
		peer->queued_writes = peer->queued_reads = 0;
@


1.22
log
@session_notification can take void *data too instead of u_char *data,
quite a few casts lost their life due to that
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.21 2003/12/20 21:26:48 henning Exp $ */
d1325 1
a1325 2
	    peer->conf.id, &peer->remote_bgpid,
	    sizeof(peer->remote_bgpid));
@


1.21
log
@more from the castathon; imsg_compose takes void * now so get rid of the casts
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.20 2003/12/20 21:16:04 henning Exp $ */
d67 1
a67 1
void	session_notification(struct peer *, u_int8_t, u_int8_t, u_char *,
d829 1
a829 1
    u_char *data, ssize_t datalen)
d960 1
a960 2
						    (u_char *)&peer->rbuf->type,
						    1);
d1015 1
a1015 1
		    (u_char *)&olen, sizeof(olen));
d1025 1
a1025 1
			    (u_char *)&olen, sizeof(olen));
d1035 1
a1035 1
			    (u_char *)&olen, sizeof(olen));
d1044 1
a1044 1
			    (u_char *)&olen, sizeof(olen));
d1053 1
a1053 1
			    (char *)&olen, sizeof(olen));
d1060 1
a1060 1
		    (u_char *)type, 1);
d1087 1
a1087 2
			    ERR_OPEN_VERSION, (u_char *)&version,
			    sizeof(version));
@


1.20
log
@typo, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.19 2003/12/20 21:14:55 henning Exp $ */
d1327 1
a1327 1
	    peer->conf.id, (u_char *)&peer->remote_bgpid,
@


1.19
log
@let buf_add take void *data instead of u_char *data and save a zillion
evil casts
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.18 2003/12/20 20:24:57 henning Exp $ */
d1297 1
a1297 1
	/* we might want a more efftive way to find peers by IP */
@


1.18
log
@revert last
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.17 2003/12/20 20:09:34 henning Exp $ */
d767 8
a774 11
	errs += buf_add(buf, (u_char *)&msg.header.marker,
	    sizeof(msg.header.marker));
	errs += buf_add(buf, (u_char *)&msg.header.len, sizeof(msg.header.len));
	errs += buf_add(buf, (u_char *)&msg.header.type,
	    sizeof(msg.header.type));
	errs += buf_add(buf, (u_char *)&msg.version, sizeof(msg.version));
	errs += buf_add(buf, (u_char *)&msg.myas, sizeof(msg.myas));
	errs += buf_add(buf, (u_char *)&msg.holdtime, sizeof(msg.holdtime));
	errs += buf_add(buf, (u_char *)&msg.bgpid, sizeof(msg.bgpid));
	errs += buf_add(buf, (u_char *)&msg.optparamlen,
	    sizeof(msg.optparamlen));
d803 3
a805 5
	errs += buf_add(buf, (u_char *)&msg.marker,
	    sizeof(msg.marker));
	errs += buf_add(buf, (u_char *)&msg.len, sizeof(msg.len));
	errs += buf_add(buf, (u_char *)&msg.type,
	    sizeof(msg.type));
d844 5
a848 7
	errs += buf_add(buf, (u_char *)&msg.marker,
	    sizeof(msg.marker));
	errs += buf_add(buf, (u_char *)&msg.len, sizeof(msg.len));
	errs += buf_add(buf, (u_char *)&msg.type,
	    sizeof(msg.type));
	errs += buf_add(buf, (u_char *)&errcode, sizeof(errcode));
	errs += buf_add(buf, (u_char *)&subcode, sizeof(subcode));
@


1.17
log
@don't cast imsg.data to struct peer_config, memcpy instead, fixes 64bit
prodded by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.16 2003/12/20 18:32:22 henning Exp $ */
d1209 1
a1209 1
	struct peer_config	 pconf;
d1229 2
a1230 2
			memcpy(&pconf, imsg.data, sizeof(pconf));
			p = getpeerbyip(pconf.remote_addr.sin_addr.s_addr);
d1243 1
a1243 1
			if (bcmp(&p->conf.remote_addr, &pconf.remote_addr,
d1246 1
a1246 1
			if (bcmp(&p->conf.local_addr, &pconf.local_addr,
d1249 1
a1249 1
			if (p->conf.remote_as != pconf.remote_as)
d1251 1
a1251 1
			if (p->conf.distance != pconf.distance)
d1254 1
a1254 1
			memcpy(&p->conf, &pconf, sizeof(pconf));
d1256 2
a1257 2
			if (pconf.reconf_action > reconf)
				p->conf.reconf_action = pconf.reconf_action;
@


1.16
log
@keep track which process we are so fatal() can log in which proc the
condition happened. fatal()s from subsystems used by all 3 processes like
the imsg subsystem were hard to track down without knowing in which process
the condition happened.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.15 2003/12/20 15:06:31 henning Exp $ */
d1209 1
a1209 1
	struct peer_config	*pconf;
d1229 2
a1230 2
			pconf = (struct peer_config *)imsg.data;
			p = getpeerbyip(pconf->remote_addr.sin_addr.s_addr);
d1243 1
a1243 1
			if (bcmp(&p->conf.remote_addr, &pconf->remote_addr,
d1246 1
a1246 1
			if (bcmp(&p->conf.local_addr, &pconf->local_addr,
d1249 1
a1249 1
			if (p->conf.remote_as != pconf->remote_as)
d1251 1
a1251 1
			if (p->conf.distance != pconf->distance)
d1254 1
a1254 1
			memcpy(&p->conf, pconf, sizeof(struct peer_config));
d1256 2
a1257 2
			if (pconf->reconf_action > reconf)
				p->conf.reconf_action = pconf->reconf_action;
@


1.15
log
@reconf is an enum reconf_action, not int
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.14 2003/12/20 14:33:09 henning Exp $ */
d159 1
d161 1
@


1.14
log
@read(2)/write(2) return ssize_t, not size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.13 2003/12/19 21:41:04 henning Exp $ */
d1209 1
a1209 1
	int			 reconf;
@


1.13
log
@even smaller typo with also big effect... < is not the same as >
of course the holdtime has to be _smaller_ than the minimal allowed holdtime
from the new configuration for the session needing a reinitialisation....
it beeing bigger is the normal case and no reason to reinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.12 2003/12/19 21:26:47 claudio Exp $ */
d68 1
a68 1
	    size_t);
d793 2
a794 2
	size_t		 len;
	int		 errs = 0;
d832 1
a832 1
    u_char *data, size_t datalen)
d836 2
a837 2
	size_t		 len;
	int		 errs = 0;
d873 1
a873 1
	size_t		n, read_total;
@


1.12
log
@Small typo/pasto big effect. Muddled keepalive timer with holdtimer.
Additionaly the keepalive timer is automaticaly restarted by
session_keepalive(). help & OK hungry henning :)
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.11 2003/12/19 21:06:46 henning Exp $ */
d1263 1
a1263 1
				if (p->holdtime > nconf->min_holdtime)
@


1.11
log
@when sending a notification things actually work better if you copy error code
and suberr code into the message... really
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.10 2003/12/19 20:34:53 henning Exp $ */
a428 1
				start_timer_keepalive(peer);
a461 1
			start_timer_keepalive(peer);
a502 1
			/* faaaaar later */
d507 1
a507 1
				start_timer_keepalive(peer);
@


1.10
log
@actually we need to init the configuration we receive in the reconfigure case
much earlier, on RECONF_CONF, and not on RECONF_DONE, to prevent an unneeded
session down/up cycle for already established sessions.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.9 2003/12/19 20:20:58 henning Exp $ */
d837 1
a837 1
	struct msg_notification	 msg;
d844 3
a846 3
	memset(&msg.header.marker, 0xff, sizeof(msg.header.marker));
	msg.header.len = htons(len);
	msg.header.type = NOTIFICATION;
d850 8
a857 5
	errs += buf_add(buf, (u_char *)&msg.header.marker,
	    sizeof(msg.header.marker));
	errs += buf_add(buf, (u_char *)&msg.header.len, sizeof(msg.header.len));
	errs += buf_add(buf, (u_char *)&msg.header.type,
	    sizeof(msg.header.type));
@


1.9
log
@conf->holdtime was not set to teh default value initially if no holdtime
was specified in teh config file. this was done correctly in the
reconfiguration process...
use a new function init_conf() to set defaults where needed; currently only
holdtime, and call it both in the startup and the reconf case.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.8 2003/12/19 16:46:07 henning Exp $ */
d1221 1
a1275 1
			init_conf(conf);
@


1.8
log
@when adding a new peer during reconfiguration set its sock to -1.
misbehaviour found by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.7 2003/12/19 11:25:18 henning Exp $ */
d52 1
d176 1
d297 7
a1272 2
			if (!conf->holdtime)
				conf->holdtime = INTERVAL_HOLD;
d1275 1
@


1.7
log
@don't bother sending a SESSION_DOWN imsg to the RDE if we are quitting, this
is at best pointless and usually just causes a fatal() when we try to send it
as the pipe is already closed by the RDE then. this way we can at least finish
the cleanup work, including notifications to the peers about us leaving.
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.6 2003/12/19 11:19:02 henning Exp $ */
d1224 1
@


1.6
log
@fix getpwnam use; noticed by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.5 2003/12/19 01:15:47 deraadt Exp $ */
d1314 3
a1316 2
	s2r_queued_writes += imsg_compose(s2r_sock, IMSG_SESSION_DOWN,
	    peer->conf.id, NULL, 0);
@


1.5
log
@knf & 64-bit cleanup; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.4 2003/12/18 18:56:23 henning Exp $ */
a142 6
	if ((pw = calloc(1, sizeof(struct passwd))) == NULL)
		fatal(NULL, errno);

	if ((pw = getpwnam(BGPD_USER)) == NULL)
		fatal(NULL, errno);

d152 3
d167 2
@


1.4
log
@reset nconf to NULL after free(), from claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.3 2003/12/17 19:26:26 henning Exp $ */
d958 1
a958 1
						     1);
@


1.3
log
@send reconf requests to the RDE as well and handle them there; syncing peer
data with RIB missing
use same message in RDE and SE for consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.2 2003/12/17 18:11:31 henning Exp $ */
d1279 1
@


1.2
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: session.c,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d1280 1
a1280 1
			logit(LOG_INFO, "got new configuration");
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d152 5
a156 7

        case 0:
                break;

        default:
                return (pid);
        }
d160 1
a160 1
	chdir ("/");
d292 1
a292 1
	_exit (0);
d829 1
a829 1
	struct msg_notification	msg;
d1204 1
a1204 1
		switch(imsg.hdr.type) {
d1278 1
a1278 1
			free (nconf);
@

