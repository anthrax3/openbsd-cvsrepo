head	1.86;
access;
symbols
	OPENBSD_6_2_BASE:1.86
	OPENBSD_6_1:1.84.0.4
	OPENBSD_6_1_BASE:1.84
	OPENBSD_6_0:1.82.0.10
	OPENBSD_6_0_BASE:1.82
	OPENBSD_5_9:1.82.0.4
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.82.0.6
	OPENBSD_5_8_BASE:1.82
	OPENBSD_5_7:1.82.0.2
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.81.0.6
	OPENBSD_5_6_BASE:1.81
	OPENBSD_5_5:1.81.0.4
	OPENBSD_5_5_BASE:1.81
	OPENBSD_5_4:1.80.0.6
	OPENBSD_5_4_BASE:1.80
	OPENBSD_5_3:1.80.0.4
	OPENBSD_5_3_BASE:1.80
	OPENBSD_5_2:1.80.0.2
	OPENBSD_5_2_BASE:1.80
	OPENBSD_5_1_BASE:1.79
	OPENBSD_5_1:1.79.0.6
	OPENBSD_5_0:1.79.0.4
	OPENBSD_5_0_BASE:1.79
	OPENBSD_4_9:1.79.0.2
	OPENBSD_4_9_BASE:1.79
	OPENBSD_4_8:1.78.0.4
	OPENBSD_4_8_BASE:1.78
	OPENBSD_4_7:1.78.0.2
	OPENBSD_4_7_BASE:1.78
	OPENBSD_4_6:1.68.0.4
	OPENBSD_4_6_BASE:1.68
	OPENBSD_4_5:1.64.0.2
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.61.0.4
	OPENBSD_4_4_BASE:1.61
	OPENBSD_4_3:1.61.0.2
	OPENBSD_4_3_BASE:1.61
	OPENBSD_4_2:1.60.0.2
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.53.0.2
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.51.0.2
	OPENBSD_4_0_BASE:1.51
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16;
locks; strict;
comment	@ * @;


1.86
date	2017.05.30.18.08.15;	author benno;	state Exp;
branches;
next	1.85;
commitid	3o7ea9wlSMxQvV12;

1.85
date	2017.05.27.10.33.15;	author phessler;	state Exp;
branches;
next	1.84;
commitid	SM4OMu9209fRs2iQ;

1.84
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.83;
commitid	airB1W2Kb948lFil;

1.83
date	2017.01.23.11.33.41;	author claudio;	state Exp;
branches;
next	1.82;
commitid	i0pKFCL4jnNsD3VA;

1.82
date	2014.12.18.19.28.44;	author tedu;	state Exp;
branches;
next	1.81;
commitid	YDg6rOJSaQoATD9X;

1.81
date	2013.08.14.20.34.27;	author claudio;	state Exp;
branches;
next	1.80;

1.80
date	2012.04.12.17.31.05;	author claudio;	state Exp;
branches;
next	1.79;

1.79
date	2010.12.31.21.22.42;	author guenther;	state Exp;
branches;
next	1.78;

1.78
date	2010.02.11.13.18.05;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2010.01.13.06.02.37;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2010.01.10.08.32.08;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2010.01.09.22.59.42;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2009.12.18.15.51.37;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2009.12.08.14.03.40;	author claudio;	state Exp;
branches;
next	1.72;

1.72
date	2009.12.04.13.28.34;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2009.10.30.15.11.00;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2009.08.06.08.53.11;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2009.06.06.01.10.29;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.26.13.59.30;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2009.03.22.22.35.00;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.13.04.18.12;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.13.21.35.16;	author sthen;	state Exp;
branches;
next	1.63;

1.63
date	2008.12.12.16.05.30;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2008.11.01.19.56.27;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2007.11.27.01.13.54;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.31.04.27.00;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.29.02.31.42;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.11.11.27.59;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2007.04.06.18.03.51;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2007.03.16.14.06.57;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2007.03.16.13.52.30;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.31.15.23.19;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.10.14.47.32;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.21.08.49.29;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.04.12.03.26;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2006.01.13.13.04.33;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.12.14.05.13;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.05.16.00.07;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.30.14.07.40;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2005.11.29.21.11.07;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2005.11.29.20.45.21;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.01.15.21.54;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.01.14.37.16;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.01.10.58.29;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.19.10.43.01;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2005.08.10.08.34.06;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.29.22.26.30;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.29.12.38.40;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2005.06.16.18.43.07;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.11.12.54.20;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.07.05.51.52;	author david;	state Exp;
branches;
next	1.33;

1.33
date	2004.11.11.13.29.37;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.11.13.06.45;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2004.09.28.12.09.31;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.20.15.31.56;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.13.14.03.20;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.10.12.57.18;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2004.08.06.12.04.08;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2004.08.05.18.44.19;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2004.08.05.16.26.56;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.30.14.44.30;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.13.17.57.20;	author jaredy;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.05.02.13.44;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.22.23.17.01;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.22.20.28.58;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.21.15.36.40;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.30.05.47.50;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.20.23.17.35;	author david;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.19.10.30.15;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2004.03.11.17.12.51;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.09.13.51.16;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.04.11.26.36;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.02.19.27.37;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.01.23.07.09;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.27.20.53.56;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.25.22.14.31;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.24.14.27.27;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.19.23.07.00;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.18.23.25.17;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.18.16.14.13;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.17.15.44.02;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.09.01.56.18;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.02.04.09.07.44;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.86
log
@remove extended communities that have the transitive bit set from
routes announced to an ebgp peer (ref. rfc4360). While here remove the
pratial flag from extended and large communities.
ok claudio@@
@
text
@/*	$OpenBSD: rde_update.c,v 1.85 2017/05/27 10:33:15 phessler Exp $ */

/*
 * Copyright (c) 2004 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/queue.h>

#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <siphash.h>

#include "bgpd.h"
#include "rde.h"
#include "log.h"

in_addr_t	up_get_nexthop(struct rde_peer *, struct rde_aspath *);
int		up_generate_mp_reach(struct rde_peer *, struct update_attr *,
		    struct rde_aspath *, u_int8_t);
int		up_generate_attr(struct rde_peer *, struct update_attr *,
		    struct rde_aspath *, u_int8_t);

/* update stuff. */
struct update_prefix {
	TAILQ_ENTRY(update_prefix)	 prefix_l;
	RB_ENTRY(update_prefix)		 entry;
	struct uplist_prefix		*prefix_h;
	struct bgpd_addr		 prefix;
	int				 prefixlen;
};

struct update_attr {
	TAILQ_ENTRY(update_attr)	 attr_l;
	RB_ENTRY(update_attr)		 entry;
	struct uplist_prefix		 prefix_h;
	u_char				*attr;
	u_char				*mpattr;
	u_int32_t			 attr_hash;
	u_int16_t			 attr_len;
	u_int16_t			 mpattr_len;
};

void	up_clear(struct uplist_attr *, struct uplist_prefix *);
int	up_prefix_cmp(struct update_prefix *, struct update_prefix *);
int	up_attr_cmp(struct update_attr *, struct update_attr *);
int	up_add(struct rde_peer *, struct update_prefix *, struct update_attr *);

RB_PROTOTYPE(uptree_prefix, update_prefix, entry, up_prefix_cmp)
RB_GENERATE(uptree_prefix, update_prefix, entry, up_prefix_cmp)

RB_PROTOTYPE(uptree_attr, update_attr, entry, up_attr_cmp)
RB_GENERATE(uptree_attr, update_attr, entry, up_attr_cmp)

SIPHASH_KEY uptree_key;

void
up_init(struct rde_peer *peer)
{
	u_int8_t	i;

	for (i = 0; i < AID_MAX; i++) {
		TAILQ_INIT(&peer->updates[i]);
		TAILQ_INIT(&peer->withdraws[i]);
	}
	RB_INIT(&peer->up_prefix);
	RB_INIT(&peer->up_attrs);
	peer->up_pcnt = 0;
	peer->up_acnt = 0;
	peer->up_nlricnt = 0;
	peer->up_wcnt = 0;
	arc4random_buf(&uptree_key, sizeof(uptree_key));
}

void
up_clear(struct uplist_attr *updates, struct uplist_prefix *withdraws)
{
	struct update_attr	*ua;
	struct update_prefix	*up;

	while ((ua = TAILQ_FIRST(updates)) != NULL) {
		TAILQ_REMOVE(updates, ua, attr_l);
		while ((up = TAILQ_FIRST(&ua->prefix_h)) != NULL) {
			TAILQ_REMOVE(&ua->prefix_h, up, prefix_l);
			free(up);
		}
		free(ua->attr);
		free(ua->mpattr);
		free(ua);
	}

	while ((up = TAILQ_FIRST(withdraws)) != NULL) {
		TAILQ_REMOVE(withdraws, up, prefix_l);
		free(up);
	}
}

void
up_down(struct rde_peer *peer)
{
	u_int8_t	i;

	for (i = 0; i < AID_MAX; i++)
		up_clear(&peer->updates[i], &peer->withdraws[i]);

	RB_INIT(&peer->up_prefix);
	RB_INIT(&peer->up_attrs);

	peer->up_pcnt = 0;
	peer->up_acnt = 0;
	peer->up_nlricnt = 0;
	peer->up_wcnt = 0;
}

int
up_prefix_cmp(struct update_prefix *a, struct update_prefix *b)
{
	int	i;

	if (a->prefix.aid < b->prefix.aid)
		return (-1);
	if (a->prefix.aid > b->prefix.aid)
		return (1);

	switch (a->prefix.aid) {
	case AID_INET:
		if (ntohl(a->prefix.v4.s_addr) < ntohl(b->prefix.v4.s_addr))
			return (-1);
		if (ntohl(a->prefix.v4.s_addr) > ntohl(b->prefix.v4.s_addr))
			return (1);
		break;
	case AID_INET6:
		i = memcmp(&a->prefix.v6, &b->prefix.v6,
		    sizeof(struct in6_addr));
		if (i > 0)
			return (1);
		if (i < 0)
			return (-1);
		break;
	case AID_VPN_IPv4:
		if (betoh64(a->prefix.vpn4.rd) < betoh64(b->prefix.vpn4.rd))
			return (-1);
		if (betoh64(a->prefix.vpn4.rd) > betoh64(b->prefix.vpn4.rd))
			return (1);
		if (ntohl(a->prefix.v4.s_addr) < ntohl(b->prefix.v4.s_addr))
			return (-1);
		if (ntohl(a->prefix.v4.s_addr) > ntohl(b->prefix.v4.s_addr))
			return (1);
		if (a->prefixlen < b->prefixlen)
			return (-1);
		if (a->prefixlen > b->prefixlen)
			return (1);
		if (a->prefix.vpn4.labellen < b->prefix.vpn4.labellen)
			return (-1);
		if (a->prefix.vpn4.labellen > b->prefix.vpn4.labellen)
			return (1);
		return (memcmp(a->prefix.vpn4.labelstack,
		    b->prefix.vpn4.labelstack, a->prefix.vpn4.labellen));
	default:
		fatalx("pt_prefix_cmp: unknown af");
	}
	if (a->prefixlen < b->prefixlen)
		return (-1);
	if (a->prefixlen > b->prefixlen)
		return (1);
	return (0);
}

int
up_attr_cmp(struct update_attr *a, struct update_attr *b)
{
	int	r;

	if ((r = a->attr_hash - b->attr_hash) != 0)
		return (r);
	if ((r = a->attr_len - b->attr_len) != 0)
		return (r);
	if ((r = a->mpattr_len - b->mpattr_len) != 0)
		return (r);
	if ((r = memcmp(a->mpattr, b->mpattr, a->mpattr_len)) != 0)
		return (r);
	return (memcmp(a->attr, b->attr, a->attr_len));
}

int
up_add(struct rde_peer *peer, struct update_prefix *p, struct update_attr *a)
{
	struct update_attr	*na = NULL;
	struct update_prefix	*np;
	struct uplist_attr	*upl = NULL;
	struct uplist_prefix	*wdl = NULL;

	upl = &peer->updates[p->prefix.aid];
	wdl = &peer->withdraws[p->prefix.aid];

	/* 1. search for attr */
	if (a != NULL && (na = RB_FIND(uptree_attr, &peer->up_attrs, a)) ==
	    NULL) {
		/* 1.1 if not found -> add */
		TAILQ_INIT(&a->prefix_h);
		if (RB_INSERT(uptree_attr, &peer->up_attrs, a) != NULL) {
			log_warnx("uptree_attr insert failed");
			/* cleanup */
			free(a->attr);
			free(a->mpattr);
			free(a);
			free(p);
			return (-1);
		}
		TAILQ_INSERT_TAIL(upl, a, attr_l);
		peer->up_acnt++;
	} else {
		/* 1.2 if found -> use that, free a */
		if (a != NULL) {
			free(a->attr);
			free(a->mpattr);
			free(a);
			a = na;
			/* move to end of update queue */
			TAILQ_REMOVE(upl, a, attr_l);
			TAILQ_INSERT_TAIL(upl, a, attr_l);
		}
	}

	/* 2. search for prefix */
	if ((np = RB_FIND(uptree_prefix, &peer->up_prefix, p)) == NULL) {
		/* 2.1 if not found -> add */
		if (RB_INSERT(uptree_prefix, &peer->up_prefix, p) != NULL) {
			log_warnx("uptree_prefix insert failed");
			/*
			 * cleanup. But do not free a because it is already
			 * linked or NULL. up_dump_attrnlri() will remove and
			 * free the empty attribute later.
			 */
			free(p);
			return (-1);
		}
		peer->up_pcnt++;
	} else {
		/* 2.2 if found -> use that and free p */
		TAILQ_REMOVE(np->prefix_h, np, prefix_l);
		free(p);
		p = np;
		if (p->prefix_h == wdl)
			peer->up_wcnt--;
		else
			peer->up_nlricnt--;
	}
	/* 3. link prefix to attr */
	if (a == NULL) {
		TAILQ_INSERT_TAIL(wdl, p, prefix_l);
		p->prefix_h = wdl;
		peer->up_wcnt++;
	} else {
		TAILQ_INSERT_TAIL(&a->prefix_h, p, prefix_l);
		p->prefix_h = &a->prefix_h;
		peer->up_nlricnt++;
	}
	return (0);
}

int
up_test_update(struct rde_peer *peer, struct prefix *p)
{
	struct bgpd_addr	 addr;
	struct attr		*attr;

	if (peer->state != PEER_UP)
		return (-1);

	if (p == NULL)
		/* no prefix available */
		return (0);

	if (peer == p->aspath->peer)
		/* Do not send routes back to sender */
		return (0);

	if (p->aspath->flags & F_ATTR_PARSE_ERR)
		fatalx("try to send out a botched path");
	if (p->aspath->flags & F_ATTR_LOOP)
		fatalx("try to send out a looped path");

	pt_getaddr(p->prefix, &addr);
	if (peer->capa.mp[addr.aid] == 0)
		return (-1);

	if (!p->aspath->peer->conf.ebgp && !peer->conf.ebgp) {
		/*
		 * route reflector redistribution rules:
		 * 1. if announce is set                -> announce
		 * 2. old non-client, new non-client    -> no
		 * 3. old client, new non-client        -> yes
		 * 4. old non-client, new client        -> yes
		 * 5. old client, new client            -> yes
		 */
		if (p->aspath->peer->conf.reflector_client == 0 &&
		    peer->conf.reflector_client == 0 &&
		    (p->aspath->flags & F_PREFIX_ANNOUNCED) == 0)
			/* Do not redistribute updates to ibgp peers */
			return (0);
	}

	/* announce type handling */
	switch (peer->conf.announce_type) {
	case ANNOUNCE_UNDEF:
	case ANNOUNCE_NONE:
	case ANNOUNCE_DEFAULT_ROUTE:
		/*
		 * no need to withdraw old prefix as this will be
		 * filtered out as well.
		 */
		return (-1);
	case ANNOUNCE_ALL:
		break;
	case ANNOUNCE_SELF:
		/*
		 * pass only prefix that have an aspath count
		 * of zero this is equal to the ^$ regex.
		 */
		if (p->aspath->aspath->ascnt != 0)
			return (0);
		break;
	}

	/* well known communities */
	if (community_match(p->aspath,
	    COMMUNITY_WELLKNOWN, COMMUNITY_NO_ADVERTISE))
		return (0);
	if (peer->conf.ebgp && community_match(p->aspath,
	    COMMUNITY_WELLKNOWN, COMMUNITY_NO_EXPORT))
		return (0);
	if (peer->conf.ebgp && community_match(p->aspath,
	    COMMUNITY_WELLKNOWN, COMMUNITY_NO_EXPSUBCONFED))
		return (0);

	/*
	 * Don't send messages back to originator
	 * this is not specified in the RFC but seems logical.
	 */
	if ((attr = attr_optget(p->aspath, ATTR_ORIGINATOR_ID)) != NULL) {
		if (memcmp(attr->data, &peer->remote_bgpid,
		    sizeof(peer->remote_bgpid)) == 0) {
			/* would cause loop don't send */
			return (-1);
		}
	}

	return (1);
}

int
up_generate(struct rde_peer *peer, struct rde_aspath *asp,
    struct bgpd_addr *addr, u_int8_t prefixlen)
{
	struct update_attr		*ua = NULL;
	struct update_prefix		*up;
	SIPHASH_CTX			ctx;

	if (asp) {
		ua = calloc(1, sizeof(struct update_attr));
		if (ua == NULL)
			fatal("up_generate");

		if (up_generate_attr(peer, ua, asp, addr->aid) == -1) {
			log_warnx("generation of bgp path attributes failed");
			free(ua);
			return (-1);
		}
		/*
		 * use aspath_hash as attr_hash, this may be unoptimal
		 * but currently I don't care.
		 */
		SipHash24_Init(&ctx, &uptree_key);
		SipHash24_Update(&ctx, ua->attr, ua->attr_len);
		if (ua->mpattr)
			SipHash24_Update(&ctx, ua->mpattr, ua->mpattr_len);
		ua->attr_hash = SipHash24_End(&ctx);
	}

	up = calloc(1, sizeof(struct update_prefix));
	if (up == NULL)
		fatal("up_generate");
	up->prefix = *addr;
	up->prefixlen = prefixlen;

	if (up_add(peer, up, ua) == -1)
		return (-1);

	return (0);
}

void
up_generate_updates(struct filter_head *rules, struct rde_peer *peer,
    struct prefix *new, struct prefix *old)
{
	struct rde_aspath		*asp;
	struct bgpd_addr		 addr;

	if (peer->state != PEER_UP)
		return;

	if (new == NULL) {
withdraw:
		if (up_test_update(peer, old) != 1)
			return;

		pt_getaddr(old->prefix, &addr);
		if (rde_filter(rules, NULL, peer, old->aspath, &addr,
		    old->prefix->prefixlen, old->aspath->peer) == ACTION_DENY)
			return;

		/* withdraw prefix */
		up_generate(peer, NULL, &addr, old->prefix->prefixlen);
	} else {
		switch (up_test_update(peer, new)) {
		case 1:
			break;
		case 0:
			goto withdraw;
		case -1:
			return;
		}

		pt_getaddr(new->prefix, &addr);
		if (rde_filter(rules, &asp, peer, new->aspath, &addr,
		    new->prefix->prefixlen, new->aspath->peer) == ACTION_DENY) {
			path_put(asp);
			goto withdraw;
		}
		if (asp == NULL)
			asp = new->aspath;

		up_generate(peer, asp, &addr, new->prefix->prefixlen);

		/* free modified aspath */
		if (asp != new->aspath)
			path_put(asp);
	}
}

/* send a default route to the specified peer */
void
up_generate_default(struct filter_head *rules, struct rde_peer *peer,
    u_int8_t aid)
{
	struct rde_aspath	*asp, *fasp;
	struct bgpd_addr	 addr;

	if (peer->capa.mp[aid] == 0)
		return;

	asp = path_get();
	asp->aspath = aspath_get(NULL, 0);
	asp->origin = ORIGIN_IGP;
	/* the other default values are OK, nexthop is once again NULL */

	/*
	 * XXX apply default overrides. Not yet possible, mainly a parse.y
	 * problem.
	 */
	/* rde_apply_set(asp, set, af, NULL ???, DIR_IN); */

	/* filter as usual */
	bzero(&addr, sizeof(addr));
	addr.aid = aid;

	if (rde_filter(rules, &fasp, peer, asp, &addr, 0, NULL) ==
	    ACTION_DENY) {
		path_put(fasp);
		path_put(asp);
		return;
	}

	/* generate update */
	if (fasp != NULL)
		up_generate(peer, fasp, &addr, 0);
	else
		up_generate(peer, asp, &addr, 0);

	/* no longer needed */
	path_put(fasp);
	path_put(asp);
}

/* generate a EoR marker in the update list. This is a horrible hack. */
int
up_generate_marker(struct rde_peer *peer, u_int8_t aid)
{
	struct update_attr	*ua;
	struct update_attr	*na = NULL;
	struct uplist_attr	*upl = NULL;

	ua = calloc(1, sizeof(struct update_attr));
	if (ua == NULL)
		fatal("up_generate_marker");

	upl = &peer->updates[aid];

	/* 1. search for attr */
	if ((na = RB_FIND(uptree_attr, &peer->up_attrs, ua)) == NULL) {
		/* 1.1 if not found -> add */
		TAILQ_INIT(&ua->prefix_h);
		if (RB_INSERT(uptree_attr, &peer->up_attrs, ua) != NULL) {
			log_warnx("uptree_attr insert failed");
			/* cleanup */
			free(ua);
			return (-1);
		}
		TAILQ_INSERT_TAIL(upl, ua, attr_l);
		peer->up_acnt++;
	} else {
		/* 1.2 if found -> use that, free ua */
		free(ua);
		ua = na;
		/* move to end of update queue */
		TAILQ_REMOVE(upl, ua, attr_l);
		TAILQ_INSERT_TAIL(upl, ua, attr_l);
	}
	return (0);
}

u_char	up_attr_buf[4096];

/* only for IPv4 */
in_addr_t
up_get_nexthop(struct rde_peer *peer, struct rde_aspath *a)
{
	in_addr_t	mask;

	/* nexthop, already network byte order */
	if (a->flags & F_NEXTHOP_NOMODIFY) {
		/* no modify flag set */
		if (a->nexthop == NULL)
			return (peer->local_v4_addr.v4.s_addr);
		else
			return (a->nexthop->exit_nexthop.v4.s_addr);
	} else if (a->flags & F_NEXTHOP_SELF)
		return (peer->local_v4_addr.v4.s_addr);
	else if (!peer->conf.ebgp) {
		/*
		 * If directly connected use peer->local_v4_addr
		 * this is only true for announced networks.
		 */
		if (a->nexthop == NULL)
			return (peer->local_v4_addr.v4.s_addr);
		else if (a->nexthop->exit_nexthop.v4.s_addr ==
		    peer->remote_addr.v4.s_addr)
			/*
			 * per RFC: if remote peer address is equal to
			 * the nexthop set the nexthop to our local address.
			 * This reduces the risk of routing loops.
			 */
			return (peer->local_v4_addr.v4.s_addr);
		else
			return (a->nexthop->exit_nexthop.v4.s_addr);
	} else if (peer->conf.distance == 1) {
		/* ebgp directly connected */
		if (a->nexthop != NULL &&
		    a->nexthop->flags & NEXTHOP_CONNECTED) {
			mask = htonl(
			    prefixlen2mask(a->nexthop->nexthop_netlen));
			if ((peer->remote_addr.v4.s_addr & mask) ==
			    (a->nexthop->nexthop_net.v4.s_addr & mask))
				/* nexthop and peer are in the same net */
				return (a->nexthop->exit_nexthop.v4.s_addr);
			else
				return (peer->local_v4_addr.v4.s_addr);
		} else
			return (peer->local_v4_addr.v4.s_addr);
	} else
		/* ebgp multihop */
		/*
		 * For ebgp multihop nh->flags should never have
		 * NEXTHOP_CONNECTED set so it should be possible to unify the
		 * two ebgp cases. But this is safe and RFC compliant.
		 */
		return (peer->local_v4_addr.v4.s_addr);
}

int
up_generate_mp_reach(struct rde_peer *peer, struct update_attr *upa,
    struct rde_aspath *a, u_int8_t aid)
{
	u_int16_t	tmp;

	switch (aid) {
	case AID_INET6:
		upa->mpattr_len = 21; /* AFI + SAFI + NH LEN + NH + Reserved */
		upa->mpattr = malloc(upa->mpattr_len);
		if (upa->mpattr == NULL)
			fatal("up_generate_mp_reach");
		if (aid2afi(aid, &tmp, &upa->mpattr[2]))
			fatalx("up_generate_mp_reachi: bad AID");
		tmp = htons(tmp);
		memcpy(upa->mpattr, &tmp, sizeof(tmp));
		upa->mpattr[3] = sizeof(struct in6_addr);
		upa->mpattr[20] = 0; /* Reserved must be 0 */

		/* nexthop dance see also up_get_nexthop() */
		if (a->flags & F_NEXTHOP_NOMODIFY) {
			/* no modify flag set */
			if (a->nexthop == NULL)
				memcpy(&upa->mpattr[4], &peer->local_v6_addr.v6,
				    sizeof(struct in6_addr));
			else
				memcpy(&upa->mpattr[4],
				    &a->nexthop->exit_nexthop.v6,
				    sizeof(struct in6_addr));
		} else if (a->flags & F_NEXTHOP_SELF)
			memcpy(&upa->mpattr[4], &peer->local_v6_addr.v6,
			    sizeof(struct in6_addr));
		else if (!peer->conf.ebgp) {
			/* ibgp */
			if (a->nexthop == NULL ||
			    (a->nexthop->exit_nexthop.aid == AID_INET6 &&
			    !memcmp(&a->nexthop->exit_nexthop.v6,
			    &peer->remote_addr.v6, sizeof(struct in6_addr))))
				memcpy(&upa->mpattr[4], &peer->local_v6_addr.v6,
				    sizeof(struct in6_addr));
			else
				memcpy(&upa->mpattr[4],
				    &a->nexthop->exit_nexthop.v6,
				    sizeof(struct in6_addr));
		} else if (peer->conf.distance == 1) {
			/* ebgp directly connected */
			if (a->nexthop != NULL &&
			    a->nexthop->flags & NEXTHOP_CONNECTED)
				if (prefix_compare(&peer->remote_addr,
				    &a->nexthop->nexthop_net,
				    a->nexthop->nexthop_netlen) == 0) {
					/*
					 * nexthop and peer are in the same
					 * subnet
					 */
					memcpy(&upa->mpattr[4],
					    &a->nexthop->exit_nexthop.v6,
					    sizeof(struct in6_addr));
					return (0);
				}
			memcpy(&upa->mpattr[4], &peer->local_v6_addr.v6,
			    sizeof(struct in6_addr));
		} else
			/* ebgp multihop */
			memcpy(&upa->mpattr[4], &peer->local_v6_addr.v6,
			    sizeof(struct in6_addr));
		return (0);
	case AID_VPN_IPv4:
		upa->mpattr_len = 17; /* AFI + SAFI + NH LEN + NH + Reserved */
		upa->mpattr = calloc(upa->mpattr_len, 1);
		if (upa->mpattr == NULL)
			fatal("up_generate_mp_reach");
		if (aid2afi(aid, &tmp, &upa->mpattr[2]))
			fatalx("up_generate_mp_reachi: bad AID");
		tmp = htons(tmp);
		memcpy(upa->mpattr, &tmp, sizeof(tmp));
		upa->mpattr[3] = sizeof(u_int64_t) + sizeof(struct in_addr);

		/* nexthop dance see also up_get_nexthop() */
		if (a->flags & F_NEXTHOP_NOMODIFY) {
			/* no modify flag set */
			if (a->nexthop == NULL)
				memcpy(&upa->mpattr[12],
				    &peer->local_v4_addr.v4,
				    sizeof(struct in_addr));
			else
				/* nexthops are stored as IPv4 addrs */
				memcpy(&upa->mpattr[12],
				    &a->nexthop->exit_nexthop.v4,
				    sizeof(struct in_addr));
		} else if (a->flags & F_NEXTHOP_SELF)
			memcpy(&upa->mpattr[12], &peer->local_v4_addr.v4,
			    sizeof(struct in_addr));
		else if (!peer->conf.ebgp) {
			/* ibgp */
			if (a->nexthop == NULL ||
			    (a->nexthop->exit_nexthop.aid == AID_INET &&
			    !memcmp(&a->nexthop->exit_nexthop.v4,
			    &peer->remote_addr.v4, sizeof(struct in_addr))))
				memcpy(&upa->mpattr[12],
				    &peer->local_v4_addr.v4,
				    sizeof(struct in_addr));
			else
				memcpy(&upa->mpattr[12],
				    &a->nexthop->exit_nexthop.v4,
				    sizeof(struct in_addr));
		} else if (peer->conf.distance == 1) {
			/* ebgp directly connected */
			if (a->nexthop != NULL &&
			    a->nexthop->flags & NEXTHOP_CONNECTED)
				if (prefix_compare(&peer->remote_addr,
				    &a->nexthop->nexthop_net,
				    a->nexthop->nexthop_netlen) == 0) {
					/*
					 * nexthop and peer are in the same
					 * subnet
					 */
					memcpy(&upa->mpattr[12],
					    &a->nexthop->exit_nexthop.v4,
					    sizeof(struct in_addr));
					return (0);
				}
			memcpy(&upa->mpattr[12], &peer->local_v4_addr.v4,
			    sizeof(struct in_addr));
		} else
			/* ebgp multihop */
			memcpy(&upa->mpattr[12], &peer->local_v4_addr.v4,
			    sizeof(struct in_addr));
		return (0);
	default:
		break;
	}
	return (-1);
}

int
up_generate_attr(struct rde_peer *peer, struct update_attr *upa,
    struct rde_aspath *a, u_int8_t aid)
{
	struct attr	*oa, *newaggr = NULL;
	u_char		*pdata;
	u_int32_t	 tmp32;
	in_addr_t	 nexthop;
	int		 flags, r, ismp = 0, neednewpath = 0;
	u_int16_t	 len = sizeof(up_attr_buf), wlen = 0, plen;
	u_int8_t	 l;
	u_int16_t	 nlen = 0;
	u_char		*ndata = NULL;

	/* origin */
	if ((r = attr_write(up_attr_buf + wlen, len, ATTR_WELL_KNOWN,
	    ATTR_ORIGIN, &a->origin, 1)) == -1)
		return (-1);
	wlen += r; len -= r;

	/* aspath */
	if (!peer->conf.ebgp ||
	    peer->conf.flags & PEERFLAG_TRANS_AS)
		pdata = aspath_prepend(a->aspath, peer->conf.local_as, 0,
		    &plen);
	else
		pdata = aspath_prepend(a->aspath, peer->conf.local_as, 1,
		    &plen);

	if (!rde_as4byte(peer))
		pdata = aspath_deflate(pdata, &plen, &neednewpath);

	if ((r = attr_write(up_attr_buf + wlen, len, ATTR_WELL_KNOWN,
	    ATTR_ASPATH, pdata, plen)) == -1)
		return (-1);
	wlen += r; len -= r;
	free(pdata);

	switch (aid) {
	case AID_INET:
		nexthop = up_get_nexthop(peer, a);
		if ((r = attr_write(up_attr_buf + wlen, len, ATTR_WELL_KNOWN,
		    ATTR_NEXTHOP, &nexthop, 4)) == -1)
			return (-1);
		wlen += r; len -= r;
		break;
	default:
		ismp = 1;
		break;
	}

	/*
	 * The old MED from other peers MUST not be announced to others
	 * unless the MED is originating from us or the peer is an IBGP one.
	 * Only exception are routers with "transparent-as yes" set.
	 */
	if (a->flags & F_ATTR_MED && (!peer->conf.ebgp ||
	    a->flags & F_ATTR_MED_ANNOUNCE ||
	    peer->conf.flags & PEERFLAG_TRANS_AS)) {
		tmp32 = htonl(a->med);
		if ((r = attr_write(up_attr_buf + wlen, len, ATTR_OPTIONAL,
		    ATTR_MED, &tmp32, 4)) == -1)
			return (-1);
		wlen += r; len -= r;
	}

	if (!peer->conf.ebgp) {
		/* local preference, only valid for ibgp */
		tmp32 = htonl(a->lpref);
		if ((r = attr_write(up_attr_buf + wlen, len, ATTR_WELL_KNOWN,
		    ATTR_LOCALPREF, &tmp32, 4)) == -1)
			return (-1);
		wlen += r; len -= r;
	}

	/*
	 * dump all other path attributes. Following rules apply:
	 *  1. well-known attrs: ATTR_ATOMIC_AGGREGATE and ATTR_AGGREGATOR
	 *     pass unmodified (enforce flags to correct values)
	 *     Actually ATTR_AGGREGATOR may be deflated for OLD 2-byte peers.
	 *  2. non-transitive attrs: don't re-announce to ebgp peers
	 *  3. transitive known attrs: announce unmodified
	 *  4. transitive unknown attrs: set partial bit and re-announce
	 */
	for (l = 0; l < a->others_len; l++) {
		if ((oa = a->others[l]) == NULL)
			break;
		switch (oa->type) {
		case ATTR_ATOMIC_AGGREGATE:
			if ((r = attr_write(up_attr_buf + wlen, len,
			    ATTR_WELL_KNOWN, ATTR_ATOMIC_AGGREGATE,
			    NULL, 0)) == -1)
				return (-1);
			break;
		case ATTR_AGGREGATOR:
			if (!rde_as4byte(peer)) {
				/* need to deflate the aggregator */
				u_int8_t	t[6];
				u_int16_t	tas;

				if ((!(oa->flags & ATTR_TRANSITIVE)) &&
				    peer->conf.ebgp) {
					r = 0;
					break;
				}

				memcpy(&tmp32, oa->data, sizeof(tmp32));
				if (ntohl(tmp32) > USHRT_MAX) {
					tas = htons(AS_TRANS);
					newaggr = oa;
				} else
					tas = htons(ntohl(tmp32));

				memcpy(t, &tas, sizeof(tas));
				memcpy(t + sizeof(tas),
				    oa->data + sizeof(tmp32),
				    oa->len - sizeof(tmp32));
				if ((r = attr_write(up_attr_buf + wlen, len,
				    oa->flags, oa->type, &t, sizeof(t))) == -1)
					return (-1);
				break;
			}
			/* FALLTHROUGH */
		case ATTR_COMMUNITIES:
		case ATTR_ORIGINATOR_ID:
		case ATTR_CLUSTER_LIST:
		case ATTR_LARGE_COMMUNITIES:
			if ((!(oa->flags & ATTR_TRANSITIVE)) &&
			    peer->conf.ebgp) {
				r = 0;
				break;
			}
			if ((r = attr_write(up_attr_buf + wlen, len,
			    oa->flags, oa->type, oa->data, oa->len)) == -1)
				return (-1);
			break;
		case ATTR_EXT_COMMUNITIES:
			/* handle (non-)transitive extended communities */
			if (peer->conf.ebgp) {
				ndata = community_ext_delete_non_trans(oa->data,
				    oa->len, &nlen);

				if (nlen > 0) {
					if ((r = attr_write(up_attr_buf + wlen,
					    len, oa->flags, oa->type, ndata,
					    nlen)) == -1) {
						free(ndata);
						return (-1);
					}
				} else
					r = 0;
				break;
			}
			if ((r = attr_write(up_attr_buf + wlen, len,
			    oa->flags, oa->type, oa->data, oa->len)) == -1)
				return (-1);
			break;
		default:
			/* unknown attribute */
			if (!(oa->flags & ATTR_TRANSITIVE)) {
				/*
				 * RFC 1771:
				 * Unrecognized non-transitive optional
				 * attributes must be quietly ignored and
				 * not passed along to other BGP peers.
				 */
				r = 0;
				break;
			}
			if ((r = attr_write(up_attr_buf + wlen, len,
			    oa->flags | ATTR_PARTIAL, oa->type,
			    oa->data, oa->len)) == -1)
				return (-1);
			break;
		}
		wlen += r; len -= r;
	}

	/* NEW to OLD conversion when going sending stuff to a 2byte AS peer */
	if (neednewpath) {
		if (!peer->conf.ebgp ||
		    peer->conf.flags & PEERFLAG_TRANS_AS)
			pdata = aspath_prepend(a->aspath, peer->conf.local_as,
			    0, &plen);
		else
			pdata = aspath_prepend(a->aspath, peer->conf.local_as,
			    1, &plen);
		flags = ATTR_OPTIONAL|ATTR_TRANSITIVE;
		if (!(a->flags & F_PREFIX_ANNOUNCED))
			flags |= ATTR_PARTIAL;
		if (plen == 0)
			r = 0;
		else if ((r = attr_write(up_attr_buf + wlen, len, flags,
		    ATTR_AS4_PATH, pdata, plen)) == -1)
			return (-1);
		wlen += r; len -= r;
		free(pdata);
	}
	if (newaggr) {
		flags = ATTR_OPTIONAL|ATTR_TRANSITIVE;
		if (!(a->flags & F_PREFIX_ANNOUNCED))
			flags |= ATTR_PARTIAL;
		if ((r = attr_write(up_attr_buf + wlen, len, flags,
		    ATTR_AS4_AGGREGATOR, newaggr->data, newaggr->len)) == -1)
			return (-1);
		wlen += r; len -= r;
	}

	/* write mp attribute to different buffer */
	if (ismp)
		if (up_generate_mp_reach(peer, upa, a, aid) == -1)
			return (-1);

	/* the bgp path attributes are now stored in the global buf */
	upa->attr = malloc(wlen);
	if (upa->attr == NULL)
		fatal("up_generate_attr");
	memcpy(upa->attr, up_attr_buf, wlen);
	upa->attr_len = wlen;
	return (wlen);
}

#define MIN_PREFIX_LEN	5	/* 1 byte prefix length + 4 bytes addr */
int
up_dump_prefix(u_char *buf, int len, struct uplist_prefix *prefix_head,
    struct rde_peer *peer)
{
	struct update_prefix	*upp;
	int			 r, wpos = 0;
	u_int8_t		 i;

	while ((upp = TAILQ_FIRST(prefix_head)) != NULL) {
		if ((r = prefix_write(buf + wpos, len - wpos,
		    &upp->prefix, upp->prefixlen)) == -1)
			break;
		wpos += r;
		if (RB_REMOVE(uptree_prefix, &peer->up_prefix, upp) == NULL)
			log_warnx("dequeuing update failed.");
		TAILQ_REMOVE(upp->prefix_h, upp, prefix_l);
		peer->up_pcnt--;
		for (i = 0; i < AID_MAX; i++) {
			if (upp->prefix_h == &peer->withdraws[i]) {
				peer->up_wcnt--;
				peer->prefix_sent_withdraw++;
			} else {
				peer->up_nlricnt--;
				peer->prefix_sent_update++;
			}
		}
		free(upp);
	}
	return (wpos);
}

int
up_dump_attrnlri(u_char *buf, int len, struct rde_peer *peer)
{
	struct update_attr	*upa;
	int			 r, wpos;
	u_int16_t		 attr_len;

	/*
	 * It is possible that a queued path attribute has no nlri prefix.
	 * Ignore and remove those path attributes.
	 */
	while ((upa = TAILQ_FIRST(&peer->updates[AID_INET])) != NULL)
		if (TAILQ_EMPTY(&upa->prefix_h)) {
			attr_len = upa->attr_len;
			if (RB_REMOVE(uptree_attr, &peer->up_attrs,
			    upa) == NULL)
				log_warnx("dequeuing update failed.");
			TAILQ_REMOVE(&peer->updates[AID_INET], upa, attr_l);
			free(upa->attr);
			free(upa->mpattr);
			free(upa);
			peer->up_acnt--;
			/* XXX horrible hack,
			 * if attr_len is 0, it is a EoR marker */
			if (attr_len == 0)
				return (-1);
		} else
			break;

	if (upa == NULL || upa->attr_len + MIN_PREFIX_LEN > len) {
		/*
		 * either no packet or not enough space.
		 * The length field needs to be set to zero else it would be
		 * an invalid bgp update.
		 */
		bzero(buf, 2);
		return (2);
	}

	/* first dump the 2-byte path attribute length */
	attr_len = htons(upa->attr_len);
	memcpy(buf, &attr_len, 2);
	wpos = 2;

	/* then the path attributes themselves */
	memcpy(buf + wpos, upa->attr, upa->attr_len);
	wpos += upa->attr_len;

	/* last but not least dump the nlri */
	r = up_dump_prefix(buf + wpos, len - wpos, &upa->prefix_h, peer);
	wpos += r;

	/* now check if all prefixes were written */
	if (TAILQ_EMPTY(&upa->prefix_h)) {
		if (RB_REMOVE(uptree_attr, &peer->up_attrs, upa) == NULL)
			log_warnx("dequeuing update failed.");
		TAILQ_REMOVE(&peer->updates[AID_INET], upa, attr_l);
		free(upa->attr);
		free(upa->mpattr);
		free(upa);
		peer->up_acnt--;
	}

	return (wpos);
}

u_char *
up_dump_mp_unreach(u_char *buf, u_int16_t *len, struct rde_peer *peer,
    u_int8_t aid)
{
	int		wpos;
	u_int16_t	datalen, tmp;
	u_int16_t	attrlen = 2;	/* attribute header (without len) */
	u_int8_t	flags = ATTR_OPTIONAL, safi;

	/*
	 * reserve space for withdraw len, attr len, the attribute header
	 * and the mp attribute header
	 */
	wpos = 2 + 2 + 4 + 3;

	if (*len < wpos)
		return (NULL);

	datalen = up_dump_prefix(buf + wpos, *len - wpos,
	    &peer->withdraws[aid], peer);
	if (datalen == 0)
		return (NULL);

	datalen += 3;	/* afi + safi */

	/* prepend header, need to do it reverse */
	/* safi & afi */
	if (aid2afi(aid, &tmp, &safi))
		fatalx("up_dump_mp_unreach: bad AID");
	buf[--wpos] = safi;
	wpos -= sizeof(u_int16_t);
	tmp = htons(tmp);
	memcpy(buf + wpos, &tmp, sizeof(u_int16_t));

	/* attribute length */
	if (datalen > 255) {
		attrlen += 2 + datalen;
		flags |= ATTR_EXTLEN;
		wpos -= sizeof(u_int16_t);
		tmp = htons(datalen);
		memcpy(buf + wpos, &tmp, sizeof(u_int16_t));
	} else {
		attrlen += 1 + datalen;
		buf[--wpos] = (u_char)datalen;
	}

	/* mp attribute */
	buf[--wpos] = (u_char)ATTR_MP_UNREACH_NLRI;
	buf[--wpos] = flags;

	/* attribute length */
	wpos -= sizeof(u_int16_t);
	tmp = htons(attrlen);
	memcpy(buf + wpos, &tmp, sizeof(u_int16_t));

	/* no IPv4 withdraws */
	wpos -= sizeof(u_int16_t);
	bzero(buf + wpos, sizeof(u_int16_t));

	if (wpos < 0)
		fatalx("up_dump_mp_unreach: buffer underflow");

	/* total length includes the two 2-bytes length fields. */
	*len = attrlen + 2 * sizeof(u_int16_t);

	return (buf + wpos);
}

int
up_dump_mp_reach(u_char *buf, u_int16_t *len, struct rde_peer *peer,
    u_int8_t aid)
{
	struct update_attr	*upa;
	int			wpos;
	u_int16_t		attr_len, datalen, tmp;
	u_int8_t		flags = ATTR_OPTIONAL;

	/*
	 * It is possible that a queued path attribute has no nlri prefix.
	 * Ignore and remove those path attributes.
	 */
	while ((upa = TAILQ_FIRST(&peer->updates[aid])) != NULL)
		if (TAILQ_EMPTY(&upa->prefix_h)) {
			attr_len = upa->attr_len;
			if (RB_REMOVE(uptree_attr, &peer->up_attrs,
			    upa) == NULL)
				log_warnx("dequeuing update failed.");
			TAILQ_REMOVE(&peer->updates[aid], upa, attr_l);
			free(upa->attr);
			free(upa->mpattr);
			free(upa);
			peer->up_acnt--;
			/* XXX horrible hack,
			 * if attr_len is 0, it is a EoR marker */
			if (attr_len == 0)
				return (-1);
		} else
			break;

	if (upa == NULL)
		return (-2);

	/*
	 * reserve space for attr len, the attributes, the
	 * mp attribute and the attribute header
	 */
	wpos = 2 + 2 + upa->attr_len + 4 + upa->mpattr_len;
	if (*len < wpos)
		return (-2);

	datalen = up_dump_prefix(buf + wpos, *len - wpos,
	    &upa->prefix_h, peer);
	if (datalen == 0)
		return (-2);

	if (upa->mpattr_len == 0 || upa->mpattr == NULL)
		fatalx("mulitprotocol update without MP attrs");

	datalen += upa->mpattr_len;
	wpos -= upa->mpattr_len;
	memcpy(buf + wpos, upa->mpattr, upa->mpattr_len);

	if (datalen > 255) {
		wpos -= 2;
		tmp = htons(datalen);
		memcpy(buf + wpos, &tmp, sizeof(tmp));
		datalen += 4;
		flags |= ATTR_EXTLEN;
	} else {
		buf[--wpos] = (u_char)datalen;
		datalen += 3;
	}
	buf[--wpos] = (u_char)ATTR_MP_REACH_NLRI;
	buf[--wpos] = flags;

	datalen += upa->attr_len;
	wpos -= upa->attr_len;
	memcpy(buf + wpos, upa->attr, upa->attr_len);

	if (wpos < 4)
		fatalx("Grrr, mp_reach buffer fucked up");

	wpos -= 2;
	tmp = htons(datalen);
	memcpy(buf + wpos, &tmp, sizeof(tmp));

	wpos -= 2;
	bzero(buf + wpos, 2);

	/* now check if all prefixes were written */
	if (TAILQ_EMPTY(&upa->prefix_h)) {
		if (RB_REMOVE(uptree_attr, &peer->up_attrs, upa) == NULL)
			log_warnx("dequeuing update failed.");
		TAILQ_REMOVE(&peer->updates[aid], upa, attr_l);
		free(upa->attr);
		free(upa->mpattr);
		free(upa);
		peer->up_acnt--;
	}

	*len = datalen + 4;
	return (wpos);
}
@


1.85
log
@Allow OpenBGPD to selectively choose which local ASN to use per-peer.
This is intended to be used for ASN migrations, not for permanent use.

You MUST use filters to protect yourself from receiving your own routes.
There be dragons and grues.

OK claudio@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.84 2017/01/24 04:22:42 benno Exp $ */
d739 2
d854 1
d858 21
@


1.84
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.83 2017/01/23 11:33:41 claudio Exp $ */
d749 2
a750 1
		pdata = aspath_prepend(a->aspath, rde_local_as(), 0, &plen);
d752 2
a753 1
		pdata = aspath_prepend(a->aspath, rde_local_as(), 1, &plen);
d886 2
a887 2
			pdata = aspath_prepend(a->aspath, rde_local_as(), 0,
			    &plen);
d889 2
a890 2
			pdata = aspath_prepend(a->aspath, rde_local_as(), 1,
			    &plen);
@


1.83
log
@Refactor a bit to make it look a bit more like the rde_update_update code.
No functional change, less recursion and indents.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.82 2014/12/18 19:28:44 tedu Exp $ */
d28 1
@


1.82
log
@two more uses of siphash. better hash for ipv4. maybe not needed for rbtree
hint, but still pretty. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.81 2013/08/14 20:34:27 claudio Exp $ */
d415 1
d431 1
a431 2
			up_generate_updates(rules, peer, NULL, old);
			return;
d440 1
a440 2
			up_generate_updates(rules, peer, NULL, old);
			return;
d442 4
d447 2
a448 3
		/* generate update */
		if (asp != NULL) {
			up_generate(peer, asp, &addr, new->prefix->prefixlen);
a449 3
		} else
			up_generate(peer, new->aspath, &addr,
			    new->prefix->prefixlen);
@


1.81
log
@Rewrite the internals of the RDE reload logic.
This is the first step to make bgpd reload non blocking in the RDE.
It also speeds up the reload time a fair bit in some cases (mainly if
you run with multiple RIBs and have larger filtersets) and it should also
fix a few edge cases on reloads.
Testing done by benno@@, florian@@ and sthen@@ OK henning@@ and benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.80 2012/04/12 17:31:05 claudio Exp $ */
a19 1
#include <sys/hash.h>
d24 1
d66 2
d83 1
d369 1
d385 2
a386 1
		ua->attr_hash = hash32_buf(ua->attr, ua->attr_len, HASHINIT);
d388 2
a389 2
			ua->attr_hash = hash32_buf(ua->mpattr, ua->mpattr_len,
			    ua->attr_hash);
@


1.80
log
@The ebgp flags is just a truth value and it is better to not == 1 compares.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.79 2010/12/31 21:22:42 guenther Exp $ */
d414 2
a415 3
		if (rde_filter(peer->ribid, NULL, rules, peer, old->aspath,
		    &addr, old->prefix->prefixlen, old->aspath->peer,
		    DIR_OUT) == ACTION_DENY)
d432 2
a433 3
		if (rde_filter(peer->ribid, &asp, rules, peer, new->aspath,
		    &addr, new->prefix->prefixlen, new->aspath->peer,
		    DIR_OUT) == ACTION_DENY) {
d475 2
a476 2
	if (rde_filter(peer->ribid, &fasp, rules, peer, asp, &addr, 0, NULL,
	    DIR_OUT) == ACTION_DENY) {
@


1.79
log
@Add missing #includes instead of assuming that some system header pulls in
the needed bits

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.78 2010/02/11 13:18:05 claudio Exp $ */
d296 1
a296 1
	if (p->aspath->peer->conf.ebgp == 0 && peer->conf.ebgp == 0) {
d777 1
a777 1
	if (a->flags & F_ATTR_MED && (peer->conf.ebgp == 0 ||
d787 1
a787 1
	if (peer->conf.ebgp == 0) {
d822 1
a822 1
				    peer->conf.ebgp != 0) {
d848 1
a848 1
			    peer->conf.ebgp != 0) {
@


1.78
log
@While looking through this code I figured out that set nexthop self and
no-modify are not supported for MP protocols like IPv6. Add support for
those and while testing find another bug in the same region. Inverse the
check for the return value of memcmp() -- we're interested in equality.
Until now IPv6 was running with an implicit set nexthop self on all iBGP
sessions. Oups. set nexthop stuff is OK when tested henning@@ and sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.77 2010/01/13 06:02:37 claudio Exp $ */
d22 1
@


1.77
log
@Add support for BGP MPLS VPN aka RFC 4364. This is only the RDE part so
that it is possible to use OpenBGPD as a route-reflector for VPNv4.
Some clean up of the BGP MP code so that multiple protocols are easier
supported. kroute/kernel support not yet done but comming.
OK henning@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.76 2010/01/10 08:32:08 claudio Exp $ */
d609 13
a621 1
		if (peer->conf.ebgp == 0) {
d625 1
a625 1
			    memcmp(&a->nexthop->exit_nexthop.v6,
d668 15
a682 1
		if (peer->conf.ebgp == 0) {
d686 1
a686 1
			    memcmp(&a->nexthop->exit_nexthop.v4,
@


1.76
log
@Generate a EoR marker in the update list instead of sending it independent
of the actual update dump. This will get us the right barrier and the EoR
is no longer sent way before the actual dump. Currently a nop since graceful
restart is turned off (unless you have announce restart yes in the config).
put it in henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.75 2010/01/09 22:59:42 claudio Exp $ */
d68 6
a73 4
	TAILQ_INIT(&peer->updates);
	TAILQ_INIT(&peer->withdraws);
	TAILQ_INIT(&peer->updates6);
	TAILQ_INIT(&peer->withdraws6);
d108 4
a111 2
	up_clear(&peer->updates, &peer->withdraws);
	up_clear(&peer->updates6, &peer->withdraws6);
d147 19
d200 2
a201 12
	switch (p->prefix.aid) {
	case AID_INET:
		upl = &peer->updates;
		wdl = &peer->withdraws;
		break;
	case AID_INET6:
		upl = &peer->updates6;
		wdl = &peer->withdraws6;
		break;
	default:
		fatalx("up_add: unknown AID");
	}
a504 1
	
d506 1
a506 10
	switch (aid) {
	case AID_INET:
		upl = &peer->updates;
		break;
	case AID_INET6:
		upl = &peer->updates6;
		break;
	default:
		fatalx("up_generate_marker: unknown AID");
	}
d601 3
a603 1
		tmp = htons(AFI_IPv6);
a604 1
		upa->mpattr[2] = SAFI_UNICAST;
d644 48
d901 1
d912 8
a919 7
		if (upp->prefix_h == &peer->withdraws ||
		    upp->prefix_h == &peer->withdraws6) {
			peer->up_wcnt--;
			peer->prefix_sent_withdraw++;
		} else {
			peer->up_nlricnt--;
			peer->prefix_sent_update++;
d937 1
a937 1
	while ((upa = TAILQ_FIRST(&peer->updates)) != NULL)
d943 1
a943 1
			TAILQ_REMOVE(&peer->updates, upa, attr_l);
d982 1
a982 1
		TAILQ_REMOVE(&peer->updates, upa, attr_l);
d993 2
a994 1
up_dump_mp_unreach(u_char *buf, u_int16_t *len, struct rde_peer *peer)
d999 1
a999 1
	u_int8_t	flags = ATTR_OPTIONAL;
d1011 1
a1011 1
	    &peer->withdraws6, peer);
d1019 3
a1021 1
	buf[--wpos] = SAFI_UNICAST;
d1023 1
a1023 1
	tmp = htons(AFI_IPv6);
d1061 2
a1062 1
up_dump_mp_reach(u_char *buf, u_int16_t *len, struct rde_peer *peer)
d1073 1
a1073 1
	while ((upa = TAILQ_FIRST(&peer->updates6)) != NULL)
d1079 1
a1079 1
			TAILQ_REMOVE(&peer->updates6, upa, attr_l);
d1145 1
a1145 1
		TAILQ_REMOVE(&peer->updates6, upa, attr_l);
@


1.75
log
@Fix fatalx message.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.74 2009/12/18 15:51:37 claudio Exp $ */
d481 47
d885 1
d894 4
d1003 1
a1003 1
u_char *
d1008 1
a1008 1
	u_int16_t		datalen, tmp;
d1017 1
d1026 4
d1034 1
a1034 1
		return (NULL);
d1042 1
a1042 1
		return (NULL);
d1047 1
a1047 1
		return (NULL);
d1095 1
a1095 1
	return (buf + wpos);
@


1.74
log
@Merge rde_filter_community() with community_match() and kill a useless
indirection.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.73 2009/12/08 14:03:40 claudio Exp $ */
d187 1
a187 1
		fatalx("up_add: unknown AF");
@


1.73
log
@Big AID change part two. This changes the mp capability into an array of
flags. This makes a lot of code much easier since the comparison is now
trivial. Additionally calculate the negotiated capabilities for a session
in the SE and pass that and only that to the RDE. This makes the decisions
in the RDE a lot easier.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.72 2009/12/04 13:28:34 claudio Exp $ */
d321 1
a321 1
	if (rde_filter_community(p->aspath,
d324 1
a324 1
	if (peer->conf.ebgp && rde_filter_community(p->aspath,
d327 1
a327 1
	if (peer->conf.ebgp && rde_filter_community(p->aspath,
@


1.72
log
@Remove a hardcoded AF_INET6 with the correct use of the current AID.
Found the hard way by Laurent CARON (lcaron at unix-scripts info)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.71 2009/12/01 14:28:05 claudio Exp $ */
d279 2
a280 12
	switch (addr.aid) {
	case AID_INET:
		/* XXX is this correct? */
		if (peer->capa_announced.mp_v4 == SAFI_NONE &&
		    peer->capa_received.mp_v6 != SAFI_NONE)
			return (-1);
		break;
	case AID_INET6:
		if (peer->capa_announced.mp_v6 == SAFI_NONE)
			return (-1);
		break;
	}
d440 1
a440 1
    sa_family_t af)
d445 1
a445 7
	if (peer->capa_received.mp_v4 == SAFI_NONE &&
	    peer->capa_received.mp_v6 != SAFI_NONE &&
	    af == AF_INET)
		return;

	if (peer->capa_received.mp_v6 == SAFI_NONE &&
	    af == AF_INET6)
d461 1
a461 1
	af2aid(af, 0, &addr.aid);
@


1.71
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.70 2009/10/30 15:11:00 claudio Exp $ */
d799 1
a799 1
		if (up_generate_mp_reach(peer, upa, a, AF_INET6) == -1)
@


1.70
log
@Routers with "transparent-as yes" set should behave more like iBGP ones.
In this case export the MED to all peers no matter what. It is no longer
needed to do the set med +0 hack. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.69 2009/08/06 08:53:11 claudio Exp $ */
d30 1
a30 1
		    struct rde_aspath *, sa_family_t);
d32 1
a32 1
		    struct rde_aspath *, sa_family_t);
d123 1
a123 1
	if (a->prefix.af < b->prefix.af)
d125 1
a125 1
	if (a->prefix.af > b->prefix.af)
d128 2
a129 2
	switch (a->prefix.af) {
	case AF_INET:
d135 1
a135 1
	case AF_INET6:
d177 2
a178 2
	switch (p->prefix.af) {
	case AF_INET:
d182 1
a182 1
	case AF_INET6:
d279 3
a281 2
	switch (addr.af) {
	case AF_INET:
d286 1
a286 1
	case AF_INET6:
d368 1
a368 1
		if (up_generate_attr(peer, ua, asp, addr->af) == -1) {
d477 1
a477 1
	addr.af = af;
d557 1
a557 1
    struct rde_aspath *a, sa_family_t af)
d561 2
a562 2
	switch (af) {
	case AF_INET6:
d577 1
a577 1
			    (a->nexthop->exit_nexthop.af == AF_INET6 &&
d617 1
a617 1
    struct rde_aspath *a, sa_family_t af)
d649 2
a650 2
	switch (af) {
	case AF_INET:
a1055 1

@


1.69
log
@Implement the error handling as proposed in draft-ietf-idr-optional-transitive
for optional transitive attributes. In short if the partial bit is set on
an optional transitive attribute but the attribute fails validation ignore
the attribute or mark the path as ineligible instead of killing the session
with a NOTIFICATION. Tested, input and OK sthen, OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.68 2009/06/06 01:10:29 claudio Exp $ */
d664 1
d667 2
a668 1
	    a->flags & F_ATTR_MED_ANNOUNCE)) {
@


1.68
log
@Some preliminary filter magic to support multiple RIBs on the filters.
It is ugly but does the trick for now. Filters will be rewritten anyway.
The rib specifier only makes sense on from rules. e.g. deny rib OMG from any
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.67 2009/03/26 13:59:30 henning Exp $ */
d273 2
@


1.67
log
@argh, do not reuse the global trans_as flag to be applied to the peer
specific or we had to widen the peer specific flags without need.
defien PERRFLAG_TRANS_AS instead and use that
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.66 2009/03/22 22:35:00 henning Exp $ */
d407 3
a409 3
		if (rde_filter(NULL, rules, peer, old->aspath, &addr,
		    old->prefix->prefixlen, old->aspath->peer, DIR_OUT) ==
		    ACTION_DENY)
d426 3
a428 3
		if (rde_filter(&asp, rules, peer, new->aspath, &addr,
		    new->prefix->prefixlen, new->aspath->peer, DIR_OUT) ==
		    ACTION_DENY) {
d476 2
a477 2
	if (rde_filter(&fasp, rules, peer, asp, &addr, 0, NULL, DIR_OUT) ==
	    ACTION_DENY) {
@


1.66
log
@make transparent-as yes|no settable peer neighbor with the global setting
acting as default.
per-neighbor requested by arnold nipper @@ decix, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.65 2009/03/13 04:18:12 claudio Exp $ */
d632 1
a632 1
	    peer->conf.flags & BGPD_FLAG_DECISION_TRANS_AS)
d765 1
a765 1
		    peer->conf.flags & BGPD_FLAG_DECISION_TRANS_AS)
@


1.65
log
@Correctly encode MP unreach NLRI so that IPv6 prefixes get removed correctly.
One bug was hiding another bug and only foundry based routers where unhappy
about these bad updates. Found by Arnoud Vermeer and Elisa Jasinska at ams-ix.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.64 2009/01/13 21:35:16 sthen Exp $ */
d632 1
a632 1
	    rde_decisionflags() & BGPD_FLAG_DECISION_TRANS_AS)
d765 1
a765 1
		    rde_decisionflags() & BGPD_FLAG_DECISION_TRANS_AS)
@


1.64
log
@Replace NEW_ASPATH/NEW_AGGREGATOR with the naming from RFC4893,
AS4_PATH/AS4_AGGREGATOR. No binary change.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.63 2008/12/12 16:05:30 claudio Exp $ */
d920 1
a920 7
	if (datalen > 255) {
		attrlen += 2 + datalen;
		flags |= ATTR_EXTLEN;
	} else {
		attrlen += 1 + datalen;
		buf++;
	}
d930 2
d935 2
a936 1
	} else
d938 1
d959 1
a959 1
	return (buf);
@


1.63
log
@Correctly set the partial bit on the AS4_PATH and AS4_AGGREGATOR attribute.
Per RFC4271 the partial bit must be set if the attribute was not generated
on the originating router. This is mostly cosmetics.
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.62 2008/11/01 19:56:27 claudio Exp $ */
d777 1
a777 1
		    ATTR_NEW_ASPATH, pdata, plen)) == -1)
d787 1
a787 1
		    ATTR_NEW_AGGREGATOR, newaggr->data, newaggr->len)) == -1)
@


1.62
log
@Use correct function names in fatal() messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.61 2007/11/27 01:13:54 claudio Exp $ */
d620 1
a620 1
	int		 r, ismp = 0, neednewpath = 0;
d771 3
d776 2
a777 3
		else if ((r = attr_write(up_attr_buf + wlen, len,
		    ATTR_OPTIONAL|ATTR_TRANSITIVE, ATTR_NEW_ASPATH,
		    pdata, plen)) == -1)
d783 5
a787 3
		if ((r = attr_write(up_attr_buf + wlen, len,
		    ATTR_OPTIONAL|ATTR_TRANSITIVE, ATTR_NEW_AGGREGATOR,
		    newaggr->data, newaggr->len)) == -1)
@


1.61
log
@Prefixes or actually pathes that would cause a rooting loops should not be
dropped when parsed but instead be added to the RIB marked as not eligible.
So the decision process does not pick them up as a valid route.
Tested and some ideas by Tony Sarendal (tony (at) polarcap (dot) org)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.60 2007/05/31 04:27:00 claudio Exp $ */
d363 1
a363 1
			fatal("up_generate_updates");
d382 1
a382 1
		fatal("up_generate_updates");
@


1.60
log
@Correctly encode ATTR_NEW_AGGREGATOR. The new aggregator is the one that
bgpd uses internaly so we can just dump that one out.
Found by Stuart Henderson, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.59 2007/05/29 02:31:42 claudio Exp $ */
d272 3
@


1.59
log
@Correctly fill the MP reach and unreach update messages. Until now
short updateds included a dummy ::/0 route and the withdraws were totaly
wrong because the AFI/SAFI header was missing.
put it in henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.58 2007/05/11 11:27:59 claudio Exp $ */
d613 1
a613 1
	struct attr	*oa;
d615 1
a615 1
	u_int32_t	 tmp32, aggr_as;
d617 1
a617 1
	int		 r, ismp = 0, neednewpath = 0, neednewaggr = 0;
d709 2
a710 2
				memcpy(&aggr_as, oa->data, sizeof(aggr_as));
				if (htonl(aggr_as) > USHRT_MAX) {
d712 1
a712 1
					neednewaggr = 1;
d714 1
a714 1
					tas = htons(ntohl(aggr_as));
d718 2
a719 2
				    oa->data + sizeof(aggr_as),
				    oa->len - sizeof(aggr_as));
d777 1
a777 1
	if (neednewaggr) {
d780 1
a780 1
		    &aggr_as, sizeof(aggr_as))) == -1)
@


1.58
log
@Various spelling fixes from Stuart Henderson.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.57 2007/04/23 13:04:24 claudio Exp $ */
d893 1
a893 1
	int		wpos = 8;	/* reserve some space for header */
d898 6
d912 1
d920 18
a937 5
	/* prepend header */
	/* no IPv4 withdraws */
	wpos = 0;
	bzero(buf, sizeof(u_int16_t));
	wpos += sizeof(u_int16_t);
d940 1
a942 1
	wpos += sizeof(u_int16_t);
d944 3
a946 3
	/* mp attribute */
	buf[wpos++] = flags;
	buf[wpos++] = (u_char)ATTR_MP_UNREACH_NLRI;
d948 2
a949 6
	if (datalen > 255) {
		tmp = htons(datalen);
		memcpy(buf + wpos, &tmp, sizeof(u_int16_t));
		wpos += sizeof(u_int16_t);
	} else
		buf[wpos++] = (u_char)datalen;
a1011 1
		buf++; wpos--; /* skip one byte */
d1022 1
a1022 1
	if (wpos != 4)
a1023 1
	*len = datalen + 4;
d1043 2
a1044 1
	return (buf);
@


1.57
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.56 2007/04/06 18:03:51 claudio Exp $ */
d316 1
a316 1
		 * pass only prefix that have a aspath count
d544 1
a544 1
		 * two ebgp cases. But this is save and RFC compliant.
d658 1
a658 1
	 * unless the MED is originating from us or the peer is a IBGP one.
d868 1
a868 1
	/* then the path attributes them self */
d876 1
a876 1
	/* now check if all prefixes where written */
d1018 1
a1018 1
	/* now check if all prefixes where written */
@


1.56
log
@Count the updates and withdraws for additional statisic gathering.
Discussed with henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.55 2007/03/16 14:06:57 claudio Exp $ */
a612 1
	struct aspath	*path;
d614 2
a615 1
	u_int32_t	 tmp32;
d617 2
a618 2
	int		 r, ismp = 0;
	u_int16_t	 len = sizeof(up_attr_buf), wlen = 0;
d630 1
a630 1
		path = aspath_prepend(a->aspath, rde_local_as(), 0);
d632 4
a635 1
		path = aspath_prepend(a->aspath, rde_local_as(), 1);
d638 1
a638 1
	    ATTR_ASPATH, path->data, path->len)) == -1)
a639 1
	aspath_put(path);
d641 1
d682 1
d698 28
d756 26
@


1.55
log
@A few more s/2858/4760/ and use RFC <number> everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.54 2007/03/16 13:52:30 claudio Exp $ */
d759 1
a759 1
		    upp->prefix_h == &peer->withdraws6)
d761 2
a762 1
		else
d764 2
@


1.54
log
@Update multiprotocol extension code to RFC 4760. This actually removes
a few things we actually never realy cared about.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.53 2007/01/31 15:23:19 claudio Exp $ */
d518 1
a518 1
			 * per rfc: if remote peer address is equal to
@


1.53
log
@Do not check that the aspath is loopfree for the peer when sending updates.
This is an undocumented optimisation that fails with the introduction of
AS 23456 as placeholder for 4-byte ASN.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.52 2006/11/10 14:47:32 henning Exp $ */
d557 1
a557 1
		upa->mpattr_len = 21; /* AFI + SAFI + NH LEN + NH + SNPA LEN */
d565 1
a565 1
		upa->mpattr[20] = 0; /* SNPA always 0 */
@


1.52
log
@char -> u_char in a few places
apparently from Jeff Rizzo <riz@@NetBSD.org> via "Thomas E. Spanjaard"
<tgen@@netphreax.net>, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.51 2006/04/21 08:49:29 claudio Exp $ */
a283 9
	}

	if (peer->conf.ebgp && !aspath_loopfree(p->aspath->aspath,
	    peer->conf.remote_as)) {
		/*
		 * Do not send routes back to sender which would
		 * cause an aspath loop.
		 */
		return (0);
@


1.51
log
@Remove function prototype that was never used. From deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.50 2006/04/04 12:03:26 henning Exp $ */
d838 1
a838 1
char *
d889 1
a889 1
char *
@


1.50
log
@add "set nexthop self", force nexthop to be set to own address even with IBGP
requested & tested Falk Brockerhoff <fb@@smartterra.de>, and tony sarendal
tested this too. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.49 2006/01/13 13:04:33 claudio Exp $ */
a32 1
int		up_set_prefix(u_char *, int, struct bgpd_addr *, u_int8_t);
@


1.49
log
@Simplify evaluation process. Instead of checking the reachability of a prefix
at many different places do it once. This simplifies the logic and makes it
easier to extend it for upcomming Adj-RIB-In addition. OK Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.48 2006/01/12 14:05:13 claudio Exp $ */
d516 3
a518 1
	} else if (!peer->conf.ebgp) {
@


1.48
log
@Copy AS path in rde_filter() on demand instead of doing it before calling
rde_filter(). Adapt path_update() to this change too. path_update() does
a path_copy before linking the rde_aspath into the RIB. Looks good Henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.47 2006/01/05 16:00:07 claudio Exp $ */
d409 1
a409 2
	if (new == NULL || (new->aspath->nexthop != NULL &&
	    new->aspath->nexthop->state != NEXTHOP_REACH)) {
@


1.47
log
@Cache optional BGP attributes (mostly communities) and use a simple
pointer plus a ref counter to link the attributes to the path object.
Saves +/- 10M on 11 full feeds. Looks good Henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.46 2005/12/30 14:07:40 claudio Exp $ */
d403 1
a403 1
	struct rde_aspath		*fasp;
a413 3
		/* copy attributes for output filter */
		fasp = path_copy(old->aspath);

d415 3
a417 3
		if (rde_filter(rules, peer, fasp, &addr, old->prefix->prefixlen,
		    old->aspath->peer, DIR_OUT) == ACTION_DENY) {
			path_put(fasp);
a418 2
		}
		path_put(fasp);
a432 3
		/* copy attributes for output filter */
		fasp = path_copy(new->aspath);

d434 4
a437 3
		if (rde_filter(rules, peer, fasp, &addr, new->prefix->prefixlen,
		    new->aspath->peer, DIR_OUT) == ACTION_DENY) {
			path_put(fasp);
d443 6
a448 4
		up_generate(peer, fasp, &addr, new->prefix->prefixlen);

		/* no longer needed */
		path_put(fasp);
d457 1
a457 1
	struct rde_aspath	*asp;
d484 1
a484 1
	if (rde_filter(rules, peer, asp, &addr, 0, NULL, DIR_OUT) ==
d486 1
d492 4
a495 1
	up_generate(peer, asp, &addr, 0);
d498 1
@


1.46
log
@Use sys/hash.h instead of own built functions that work similar.
While there reorder some structs to help with alignment.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.45 2005/11/29 21:11:07 claudio Exp $ */
d628 1
d692 3
a694 1
	TAILQ_FOREACH(oa, &a->others, entry) {
@


1.45
log
@Add a flags field to struct prefix which will be used shortly. Remove the peer
pointer so that the size does not grow. Adding 4 bytes to struct prefix would
result in 64MB more memory usage on one of my systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.44 2005/11/29 20:45:21 claudio Exp $ */
d20 1
d37 3
a41 3
	struct uplist_prefix		*prefix_h;
	TAILQ_ENTRY(update_prefix)	 prefix_l;
	RB_ENTRY(update_prefix)		 entry;
d45 5
a50 1
	u_char				*attr;
a52 4
	u_char				*mpattr;
	struct uplist_prefix		 prefix_h;
	TAILQ_ENTRY(update_attr)	 attr_l;
	RB_ENTRY(update_attr)		 entry;
d381 4
a384 2
		ua->attr_hash = aspath_hash(asp->aspath->data,
		    asp->aspath->len);
@


1.44
log
@even more spaces and tabs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.43 2005/11/01 15:21:54 claudio Exp $ */
d269 1
a269 1
	if (peer == p->peer)
d295 1
a295 1
	if (p->peer->conf.ebgp == 0 && peer->conf.ebgp == 0) {
d304 1
a304 1
		if (p->peer->conf.reflector_client == 0 &&
d416 1
a416 1
		    old->peer, DIR_OUT) == ACTION_DENY) {
d440 1
a440 1
		    new->peer, DIR_OUT) == ACTION_DENY) {
@


1.43
log
@Softreconfig out support. On config reload filter changes of outgoing rules
will propagte directly to the neighbors. There is no need to restart bgpd
in that case. Currently not optimal but a good start. "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.42 2005/11/01 14:37:16 claudio Exp $ */
d286 1
a286 1
	if (peer->conf.ebgp && !aspath_loopfree(p->aspath->aspath, 
@


1.42
log
@Major cleanup in rde_update.c. Merge equal code used in different places
into own functions. Move up_dump_upcall() into rde.c and rename it
rde_up_dump_upcall(). This is needed for the next step.
up_test_update() tests if an update or withdraw is needed and up_generate()
creates the updates.  "get it in" henning@@ (he is eager on softreconfig out)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.41 2005/11/01 10:58:29 claudio Exp $ */
d397 1
a397 1
up_generate_updates(struct rde_peer *peer,
d415 1
a415 1
		if (rde_filter(peer, fasp, &addr, old->prefix->prefixlen,
d429 1
a429 1
			up_generate_updates(peer, NULL, old);
d439 1
a439 1
		if (rde_filter(peer, fasp, &addr, new->prefix->prefixlen,
d442 1
a442 1
			up_generate_updates(peer, NULL, old);
d456 2
a457 1
up_generate_default(struct rde_peer *peer, sa_family_t af)
d486 1
a486 1
	if (rde_filter(peer, asp, &addr, 0, NULL, DIR_OUT) ==
@


1.41
log
@Switch from the per peer filter set list to a filter-only solution.
The default filter_sets are converted into match filter rules that get
evaluated first. Simplifies code massively -- mainly the config reload
part -- and makes softreconfig out a piece of cake.  "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.40 2005/10/19 10:43:01 henning Exp $ */
d256 2
a257 3
void
up_generate_updates(struct rde_peer *peer,
    struct prefix *new, struct prefix *old)
d259 2
a260 5
	struct update_attr		*a;
	struct update_prefix		*p;
	struct attr			*attr;
	struct rde_aspath		*fasp;
	struct bgpd_addr		 addr;
d263 22
a284 1
		return;
d286 8
a293 5
	if (new == NULL || (new->aspath->nexthop != NULL &&
	    new->aspath->nexthop->state != NEXTHOP_REACH)) {
		if (old == NULL)
			/* new prefix got filtered and no old prefix avail */
			return;
d295 15
a309 3
		if (peer == old->peer)
			/* Do not send routes back to sender */
			return;
d311 21
a331 12
		pt_getaddr(old->prefix, &addr);
		switch (addr.af) {
		case AF_INET:
			if (peer->capa_announced.mp_v4 == SAFI_NONE &&
			    peer->capa_received.mp_v6 != SAFI_NONE)
				return;
			break;
		case AF_INET6:
			if (peer->capa_announced.mp_v6 == SAFI_NONE)
				return;
			break;
		}
d333 10
a342 8
		if (peer->conf.ebgp &&
		    !aspath_loopfree(old->aspath->aspath,
		    peer->conf.remote_as))
			/*
			 * Do not send routes back to sender which would
			 * cause a aspath loop.
			 */
			return;
d344 9
a352 14
		if (old->peer->conf.ebgp == 0 && peer->conf.ebgp == 0) {
			/*
			 * route reflector redistribution rules:
			 * 1. if announce is set		-> announce
			 * 2. old non-client, new non-client	-> no
			 * 3. old client, new non-client	-> yes
			 * 4. old non-client, new client	-> yes
			 * 5. old client, new client		-> yes
			 */
			if (old->peer->conf.reflector_client == 0 &&
			    peer->conf.reflector_client == 0 &&
			    (old->aspath->flags & F_PREFIX_ANNOUNCED) == 0)
				/* Do not redistribute updates to ibgp peers */
				return;
d354 4
d359 6
a364 17
		/* announce type handling */
		switch (peer->conf.announce_type) {
		case ANNOUNCE_UNDEF:
		case ANNOUNCE_NONE:
		case ANNOUNCE_DEFAULT_ROUTE:
			return;
		case ANNOUNCE_ALL:
			break;
		case ANNOUNCE_SELF:
			/*
			 * pass only prefix that have a aspath count
			 * of zero this is equal to the ^$ regex.
			 */
			if (old->aspath->aspath->ascnt != 0)
				return;
			break;
		}
d366 4
a369 10
		/* well known communities */
		if (rde_filter_community(old->aspath,
		    COMMUNITY_WELLKNOWN, COMMUNITY_NO_ADVERTISE))
			return;
		if (peer->conf.ebgp && rde_filter_community(old->aspath,
		    COMMUNITY_WELLKNOWN, COMMUNITY_NO_EXPORT))
			return;
		if (peer->conf.ebgp && rde_filter_community(old->aspath,
		    COMMUNITY_WELLKNOWN, COMMUNITY_NO_EXPSUBCONFED))
			return;
d371 5
d377 2
a378 2
		 * Don't send messages back to originator
		 * this is not specified in the RFC but seems logical.
d380 30
a409 7
		if ((attr = attr_optget(old->aspath,
		    ATTR_ORIGINATOR_ID)) != NULL) {
			if (memcmp(attr->data, &peer->remote_bgpid,
			    sizeof(peer->remote_bgpid)) == 0)
				/* would cause loop don't send */
				return;
		}
d414 1
a414 2
		/* default override not needed here as this is a withdraw */

d423 1
a423 8
		p = calloc(1, sizeof(struct update_prefix));
		if (p == NULL)
			fatal("up_generate_updates");

		p->prefix = addr;
		p->prefixlen = old->prefix->prefixlen;
		if (up_add(peer, p, NULL) == -1)
			log_warnx("queuing withdraw failed.");
d425 2
a426 16
		if (peer == new->peer) {
			/* Do not send routes back to sender */
			up_generate_updates(peer, NULL, old);
			return;
		}

		pt_getaddr(new->prefix, &addr);
		switch (addr.af) {
		case AF_INET:
			if (peer->capa_announced.mp_v4 == SAFI_NONE &&
			    peer->capa_received.mp_v6 != SAFI_NONE)
				return;
			break;
		case AF_INET6:
			if (peer->capa_announced.mp_v6 == SAFI_NONE)
				return;
d428 1
a428 9
		}

		if (peer->conf.ebgp &&
		    !aspath_loopfree(new->aspath->aspath,
		    peer->conf.remote_as)) {
			/*
			 * Do not send routes back to sender which would
			 * cause a aspath loop.
			 */
d431 1
a431 58
		}

		if (new->peer->conf.ebgp == 0 && peer->conf.ebgp == 0) {
			/*
			 * route reflector redistribution rules:
			 * 1. if announce is set		-> announce
			 * 2. old non-client, new non-client	-> no
			 * 3. old client, new non-client	-> yes
			 * 4. old non-client, new client	-> yes
			 * 5. old client, new client		-> yes
			 */
			if (new->peer->conf.reflector_client == 0 &&
			    peer->conf.reflector_client == 0 &&
			    (new->aspath->flags & F_PREFIX_ANNOUNCED) == 0) {
				/* Do not redistribute updates to ibgp peers */
				up_generate_updates(peer, NULL, old);
				return;
			}
		}

		/* announce type handling */
		switch (peer->conf.announce_type) {
		case ANNOUNCE_UNDEF:
		case ANNOUNCE_NONE:
		case ANNOUNCE_DEFAULT_ROUTE:
			/*
			 * no need to withdraw old prefix as this will be
			 * filtered out as well.
			 */
			return;
		case ANNOUNCE_ALL:
			break;
		case ANNOUNCE_SELF:
			/*
			 * pass only prefix that have a aspath count
			 * of zero this is equal to the ^$ regex.
			 */
			if (new->aspath->aspath->ascnt != 0) {
				up_generate_updates(peer, NULL, old);
				return;
			}
			break;
		}

		/* well known communities */
		if (rde_filter_community(new->aspath,
		    COMMUNITY_WELLKNOWN, COMMUNITY_NO_ADVERTISE)) {
			up_generate_updates(peer, NULL, old);
			return;
		}
		if (peer->conf.ebgp && rde_filter_community(new->aspath,
		    COMMUNITY_WELLKNOWN, COMMUNITY_NO_EXPORT)) {
			up_generate_updates(peer, NULL, old);
			return;
		}
		if (peer->conf.ebgp && rde_filter_community(new->aspath,
		    COMMUNITY_WELLKNOWN, COMMUNITY_NO_EXPSUBCONFED)) {
			up_generate_updates(peer, NULL, old);
d438 1
a445 14
		/*
		 * Don't send messages back to originator
		 * this is not specified in the RFC but seems logical.
		 */
		if ((attr = attr_optget(new->aspath,
		    ATTR_ORIGINATOR_ID)) != NULL) {
			if (memcmp(attr->data, &peer->remote_bgpid,
			    sizeof(peer->remote_bgpid)) == 0) {
				/* would cause loop don't send */
				path_put(fasp);
				return;
			}
		}

d447 1
a447 23
		p = calloc(1, sizeof(struct update_prefix));
		if (p == NULL)
			fatal("up_generate_updates");

		a = calloc(1, sizeof(struct update_attr));
		if (a == NULL)
			fatal("up_generate_updates");

		if (up_generate_attr(peer, a, fasp, addr.af) == -1) {
			log_warnx("generation of bgp path attributes failed");
			free(a);
			free(p);
			return;
		}

		/*
		 * use aspath_hash as attr_hash, this may be unoptimal
		 * but currently I don't care.
		 */
		a->attr_hash = aspath_hash(fasp->aspath->data,
		    fasp->aspath->len);
		p->prefix = addr;
		p->prefixlen = new->prefix->prefixlen;
a450 3

		if (up_add(peer, p, a) == -1)
			log_warnx("queuing update failed.");
a457 2
	struct update_attr	*a;
	struct update_prefix	*p;
d479 1
d484 3
a486 5
	/*
	 * XXX we should pass peerself here. This will be fixed with the
	 * apply default overrides.
	 */
	if (rde_filter(peer, asp, &addr, 0, NULL, DIR_OUT) == ACTION_DENY) {
d492 1
a492 22
	p = calloc(1, sizeof(struct update_prefix));
	if (p == NULL)
		fatal("up_generate_default");

	a = calloc(1, sizeof(struct update_attr));
	if (a == NULL)
		fatal("up_generate_default");

	if (up_generate_attr(peer, a, asp, af) == -1) {
		log_warnx("generation of bgp path attributes failed");
		free(a);
		free(p);
		return;
	}

	/*
	 * use aspath_hash as attr_hash, this may be unoptimal
	 * but currently I don't care.
	 */
	a->attr_hash = aspath_hash(asp->aspath->data, asp->aspath->len);
	p->prefix = addr;
	p->prefixlen = 0; /* default route */
a495 14

	if (up_add(peer, p, a) == -1)
		log_warnx("queuing update failed.");

}

void
up_dump_upcall(struct pt_entry *pt, void *ptr)
{
	struct rde_peer	*peer = ptr;

	if (pt->active == NULL)
		return;
	up_generate_updates(peer, pt->active, NULL);
@


1.40
log
@tsc tsc tsc, tabs are not always holy
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.39 2005/08/10 08:34:06 claudio Exp $ */
d435 1
a435 1
			 * filtered out to.
a470 7

		/*
		 * apply default outgoing overrides,
		 * actually only prepend-self and nexthop no-modify
		 */
		rde_apply_set(fasp, &peer->conf.attrset, new->prefix->af,
		    new->aspath->peer, DIR_DEFAULT_OUT);
@


1.39
log
@Pass the correct peer to rde_apply_set(). rde_apply_set() needs to know
the peer where the prefix came from so that prepend-neighbor works.
Extend rde_filter() and make sure that the correct peer is passed.
Until now most cases resulted in a NULL peer causing a nasty crash that
was found by David Ulevitch. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.38 2005/07/29 22:26:30 claudio Exp $ */
d1046 1
a1046 1
	
@


1.38
log
@Debugging session at WTH. Fix many bugs in the IPv6 support -- some copy paste
and some more obscure ones. With this is it possible to run IPv6 sessions
between two bgpd.
OK if it does not break IPv4 hummpa barman Henning
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.37 2005/07/29 12:38:40 claudio Exp $ */
d363 2
a364 2
		if (rde_filter(peer, fasp, &addr,
		    old->prefix->prefixlen, DIR_OUT) == ACTION_DENY) {
d474 1
a474 1
		 * actually only prepend-self
d477 1
a477 1
		    fasp->peer, DIR_DEFAULT_OUT);
d479 2
a480 2
		if (rde_filter(peer, fasp, &addr,
		    new->prefix->prefixlen, DIR_OUT) == ACTION_DENY) {
d564 5
a568 1
	if (rde_filter(peer, asp, &addr, 0, DIR_OUT) == ACTION_DENY) {
@


1.37
log
@Add another piece to the IPv6 puzzle. This time code to generate MP updates.
Does not affect IPv4 minimaly tested for IPv6 because we still don't have an
IPv6 capable neighbor. henning@@ ya
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.36 2005/06/16 18:43:07 henning Exp $ */
d968 1
d970 2
a971 2
	bzero(buf, 2);
	wpos += 2;
d973 1
d975 2
a976 2
	memcpy(buf + wpos, &tmp, sizeof(tmp));
	wpos += 2;
d978 1
d984 2
a985 2
		memcpy(buf + wpos, &tmp, sizeof(tmp));
		wpos += 2;
d989 2
a990 1
	*len = datalen + wpos;
d1007 1
a1007 1
	while ((upa = TAILQ_FIRST(&peer->updates)) != NULL)
d1012 1
a1012 1
			TAILQ_REMOVE(&peer->updates, upa, attr_l);
d1020 3
d1024 2
a1025 2
	 * reserve space for withdraw len, attr len, the attributes, the
	 * mp attribute and the atributte header
d1032 1
a1032 1
	    &peer->withdraws6, peer);
d1036 3
d1076 1
a1076 1
		TAILQ_REMOVE(&peer->updates, upa, attr_l);
@


1.36
log
@use prefixlen2mask() instead of doing the bitshifting by hand; fixes the
zero prefixlen case (32 bit shift on 32 bit val -> undefined result)
spotted by Moritz Grimm and otto
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.35 2005/03/11 12:54:20 claudio Exp $ */
d27 6
a32 2
int	up_generate_attr(struct rde_peer *, struct update_attr *,
	    struct rde_aspath *);
d47 2
d93 1
d156 10
a165 8
	if (a->attr_hash < b->attr_hash)
		return (-1);
	if (a->attr_hash > b->attr_hash)
		return (1);
	if (a->attr_len < b->attr_len)
		return (-1);
	if (a->attr_len > b->attr_len)
		return (1);
d199 1
d210 1
d279 13
a362 1
		pt_getaddr(old->prefix, &addr);
d386 13
a478 1
		pt_getaddr(new->prefix, &addr);
d509 1
a509 1
		if (up_generate_attr(peer, a, fasp) == -1) {
d533 1
d542 9
d556 4
a559 1
	/* XXX apply default overrides. Not yet possible */
d578 1
a578 1
	if (up_generate_attr(peer, a, asp) == -1) {
d613 3
a615 3
int
up_generate_attr(struct rde_peer *peer, struct update_attr *upa,
    struct rde_aspath *a)
d617 1
a617 25
	struct aspath	*path;
	struct attr	*oa;
	u_int32_t	 tmp32;
	in_addr_t	 nexthop, mask;
	int		 r;
	u_int16_t	 len = sizeof(up_attr_buf), wlen = 0;

	/* origin */
	if ((r = attr_write(up_attr_buf + wlen, len, ATTR_WELL_KNOWN,
	    ATTR_ORIGIN, &a->origin, 1)) == -1)
		return (-1);
	wlen += r; len -= r;

	/* aspath */
	if (!peer->conf.ebgp ||
	    rde_decisionflags() & BGPD_FLAG_DECISION_TRANS_AS)
		path = aspath_prepend(a->aspath, rde_local_as(), 0);
	else
		path = aspath_prepend(a->aspath, rde_local_as(), 1);

	if ((r = attr_write(up_attr_buf + wlen, len, ATTR_WELL_KNOWN,
	    ATTR_ASPATH, path->data, path->len)) == -1)
		return (-1);
	aspath_put(path);
	wlen += r; len -= r;
d623 1
a623 1
			nexthop = peer->local_v4_addr.v4.s_addr;
d625 1
a625 1
			nexthop = a->nexthop->exit_nexthop.v4.s_addr;
d632 1
a632 1
			nexthop = peer->local_v4_addr.v4.s_addr;
d640 1
a640 1
			nexthop = peer->local_v4_addr.v4.s_addr;
d642 1
a642 1
			nexthop = a->nexthop->exit_nexthop.v4.s_addr;
d652 1
a652 1
				nexthop = a->nexthop->exit_nexthop.v4.s_addr;
d654 1
a654 1
				nexthop = peer->local_v4_addr.v4.s_addr;
d656 1
a656 1
			nexthop = peer->local_v4_addr.v4.s_addr;
d664 86
a749 1
		nexthop = peer->local_v4_addr.v4.s_addr;
d752 1
a752 1
	    ATTR_NEXTHOP, &nexthop, 4)) == -1)
d754 1
d757 13
d842 5
d873 2
a874 1
		if (upp->prefix_h == &peer->withdraws)
d901 1
d936 1
d942 132
@


1.35
log
@Finally commit the transparent-as and nexthop no-modify stuff I wrote on the
way to FOSDEM. With transparent-as set to ye bgpd will not prepend his own
AS for sent updates. NB the neighbor needs to set "enforce neighbor-as no"
or it will not like the received AS paths. With set nexthop no-modify bgpd
will change the nexthop as done normaly.
OK henning@@ man page update with help of jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.34 2005/02/07 05:51:52 david Exp $ */
d623 2
a624 2
			mask = 0xffffffff << (32 - a->nexthop->nexthop_netlen);
			mask = htonl(mask);
@


1.34
log
@spelling fix
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.33 2004/11/11 13:29:37 henning Exp $ */
d583 6
a588 1
	path = aspath_prepend(a->aspath, rde_local_as(), peer->conf.ebgp);
d596 7
a602 1
	if (peer->conf.ebgp == 0) {
@


1.33
log
@spaces at EOL in comments, spotted by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.32 2004/11/11 13:06:45 claudio Exp $ */
d438 1
a438 1
		 * acctually only prepend-self
@


1.32
log
@Store the local v4 and v6 address of a session. For IPv4 sessions the first
IPv6 address with global scope of the interface used by the session is used.
In any case the local endpoint of the session is used for one of the two no
matter what scope.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.31 2004/09/28 12:09:31 claudio Exp $ */
d281 1
a281 1
			 * 2. old non-client, new non-client	-> no 
d323 1
a323 1
		 * Don't send messages back to originator 
d378 1
a378 1
			 * 2. old non-client, new non-client	-> no 
d452 1
a452 1
		 * Don't send messages back to originator 
@


1.31
log
@Add prepend-neighbor feature. Prepend the remote-as n times similar to
prepend-self. Only for incomming UPDATEs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.30 2004/08/20 15:31:56 claudio Exp $ */
d593 1
a593 1
		 * If directly connected use peer->local_addr
d597 1
a597 1
			nexthop = peer->local_addr.v4.s_addr;
d605 1
a605 1
			nexthop = peer->local_addr.v4.s_addr;
d619 1
a619 1
				nexthop = peer->local_addr.v4.s_addr;
d621 1
a621 1
			nexthop = peer->local_addr.v4.s_addr;
d629 1
a629 1
		nexthop = peer->local_addr.v4.s_addr;
@


1.30
log
@Grrr. copy paste error. Dump MED and not local-pref. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.29 2004/08/13 14:03:20 claudio Exp $ */
d337 2
d435 7
@


1.29
log
@Fix minor issues with IPv6 dumps and add a function for dumping the RIB table
protocol independent. This new dump format is not (yet) supported by the
mrtd route_btoa tool. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.28 2004/08/10 12:57:18 claudio Exp $ */
d633 1
a633 1
		tmp32 = htonl(a->lpref);
@


1.28
log
@Correctly set the MED in outgoing UPDATEs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.27 2004/08/06 12:04:08 claudio Exp $ */
a28 2
int	up_set_prefix(u_char *, int, struct bgpd_addr *, u_int8_t);

a707 17
int
up_set_prefix(u_char *buf, int len, struct bgpd_addr *prefix, u_int8_t plen)
{
	int	totlen;

	if (prefix->af != AF_INET)
		return (-1);

	totlen = (plen + 7) / 8 + 1;

	if (totlen > len)
		return (-1);
	*buf++ = plen;
	memcpy(buf, &prefix->v4.s_addr, totlen - 1);
	return (totlen);
}

d717 1
a717 1
		if ((r = up_set_prefix(buf + wpos, len - wpos,
@


1.27
log
@Monster diff to get one step closer to IPv6 support.
Cleanup path attribute handling. First of all kill struct attr_flags, all
those infos are now in struct rde_aspath. Second move attribute parser
functions into rde.c, rde_attr.c is shared between bgpd and bgpctl.
Third reimplementation of the nexthop handling. Make it IPv6 ready and
fix some major bug relating to "set nexthop".
henning@@ OK if it breaks nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.26 2004/08/05 18:44:19 claudio Exp $ */
d630 2
a631 4
	 * The MED of other peers MUST not be announced to others.
	 * Currently we just dump it. Possibilities are setting the MED via
	 * a filter or set it to local-pref. struct attr_flags probably needs
	 * a med_in and a med_out field.
d633 8
@


1.26
log
@Cleanup aspath specific functions and api. Mainly switch to a refcnt based
allocation. This helps to save a bit of RAM. looks good henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.25 2004/08/05 16:26:56 claudio Exp $ */
d28 1
a28 1
	    struct attr_flags *, struct nexthop *);
d50 1
d66 2
d77 1
a77 1
up_down(struct rde_peer *peer)
d82 2
a83 2
	while ((ua = TAILQ_FIRST(&peer->updates)) != NULL) {
		TAILQ_REMOVE(&peer->updates, ua, attr_l);
d92 2
a93 2
	while ((up = TAILQ_FIRST(&peer->withdraws)) != NULL) {
		TAILQ_REMOVE(&peer->withdraws, up, prefix_l);
d96 7
a103 2
	TAILQ_INIT(&peer->updates);
	TAILQ_INIT(&peer->withdraws);
d159 1
a159 1
	return memcmp(a->attr, b->attr, a->attr_len);
d167 15
d196 1
a196 1
		TAILQ_INSERT_TAIL(&peer->updates, a, attr_l);
d205 2
a206 2
			TAILQ_REMOVE(&peer->updates, a, attr_l);
			TAILQ_INSERT_TAIL(&peer->updates, a, attr_l);
d229 1
a229 1
		if (p->prefix_h == &peer->withdraws)
d236 2
a237 2
		TAILQ_INSERT_TAIL(&peer->withdraws, p, prefix_l);
		p->prefix_h = &peer->withdraws;
d253 2
a254 2
	struct attr			*atr;
	struct attr_flags		 attrs;
d260 2
a261 2
	if (new == NULL || new->aspath->nexthop == NULL ||
	    new->aspath->nexthop->state != NEXTHOP_REACH) {
d263 1
a263 1
			/* new prefix got filtered and no old prefex avail */
d271 1
a271 1
		    !aspath_loopfree(old->aspath->flags.aspath,
d290 1
a290 2
			    (old->aspath->nexthop->flags &
			    NEXTHOP_ANNOUNCE) == 0)
d308 1
a308 1
			if (old->aspath->flags.aspath->ascnt != 0)
d314 1
a314 1
		if (rde_filter_community(&old->aspath->flags,
d317 1
a317 1
		if (peer->conf.ebgp && rde_filter_community(&old->aspath->flags,
d320 1
a320 1
		if (peer->conf.ebgp && rde_filter_community(&old->aspath->flags,
d325 2
a326 2
		 * don't send messages back to originator 
		 * NOTE this is not specified in the RFC but seems logical.
d328 1
a328 1
		if ((atr = attr_optget(&old->aspath->flags,
d330 1
a330 1
			if (memcmp(atr->data, &peer->remote_bgpid,
d337 1
a337 1
		attr_copy(&attrs, &old->aspath->flags);
d340 1
a340 1
		if (rde_filter(peer, &attrs, &addr,
d342 1
a342 1
			attr_free(&attrs);
d345 1
a345 1
		attr_free(&attrs);
d364 1
a364 1
		    !aspath_loopfree(new->aspath->flags.aspath,
d385 1
a385 2
			    (new->aspath->nexthop->flags &
			    NEXTHOP_ANNOUNCE) == 0) {
d409 1
a409 1
			if (new->aspath->flags.aspath->ascnt != 0) {
d417 1
a417 1
		if (rde_filter_community(&new->aspath->flags,
d422 1
a422 1
		if (peer->conf.ebgp && rde_filter_community(&new->aspath->flags,
d427 1
a427 1
		if (peer->conf.ebgp && rde_filter_community(&new->aspath->flags,
d434 1
a434 1
		attr_copy(&attrs, &new->aspath->flags);
d437 1
a437 1
		if (rde_filter(peer, &attrs, &addr,
d439 1
a439 1
			attr_free(&attrs);
d445 2
a446 2
		 * don't send messages back to originator 
		 * NOTE this is not specified in the RFC but seems logical.
d448 1
a448 1
		if ((atr = attr_optget(&new->aspath->flags,
d450 1
a450 1
			if (memcmp(atr->data, &peer->remote_bgpid,
d453 1
a453 1
				attr_free(&attrs);
d467 1
a467 2
		if (up_generate_attr(peer, a, &attrs,
		    new->aspath->nexthop) == -1) {
d478 2
a479 2
		a->attr_hash = aspath_hash(attrs.aspath->data,
		    attrs.aspath->len);
d484 1
a484 1
		attr_free(&attrs);
d496 1
a496 1
	struct attr_flags	 attrs;
a497 1
	struct nexthop		 nexthop;
d499 4
a502 15
	bzero(&attrs, sizeof(attrs));
	bzero(&addr, sizeof(addr));
	bzero(&nexthop, sizeof(nexthop));

	attrs.aspath = aspath_get(NULL, 0);
	attrs.nexthop.s_addr = INADDR_ANY;
	/* med = 0 */
	attrs.lpref = DEFAULT_LPREF;
	attrs.origin = ORIGIN_IGP;
	TAILQ_INIT(&attrs.others);

	nexthop.state = NEXTHOP_REACH;
	nexthop.flags = NEXTHOP_ANNOUNCE;
	nexthop.exit_nexthop.af = af;
	nexthop.true_nexthop.af = af;
d504 1
a504 1
	/* apply default overrides. Not yet possible */
d507 4
a510 3
	addr.af = AF_INET;
	if (rde_filter(peer, &attrs, &addr, 0, DIR_OUT) == ACTION_DENY) {
		attr_free(&attrs);
d523 1
a523 1
	if (up_generate_attr(peer, a, &attrs, &nexthop) == -1) {
d534 1
a534 1
	a->attr_hash = aspath_hash(attrs.aspath->data, attrs.aspath->len);
d539 1
a539 1
	attr_free(&attrs);
d546 10
d560 1
a560 1
    struct attr_flags *a, struct nexthop *nh)
d586 2
a587 1
		 * if directly connected use peer->local_addr
d589 1
a589 1
		if (nh->flags & NEXTHOP_ANNOUNCE)
d591 2
a592 1
		else if (a->nexthop.s_addr == peer->remote_addr.v4.s_addr)
d600 1
a600 1
			nexthop = nh->exit_nexthop.v4.s_addr;
d603 3
a605 2
		if (nh->flags & NEXTHOP_CONNECTED) {
			mask = 0xffffffff << (32 - nh->nexthop_netlen);
d608 1
a608 1
			    (nh->nexthop_net.v4.s_addr & mask))
d610 1
a610 1
				nexthop = nh->exit_nexthop.v4.s_addr;
d618 1
a618 1
		 * XXX for ebgp multihop nh->flags should never have
d620 1
a620 1
		 * two ebgp cases.
a805 9
void
up_dump_upcall(struct pt_entry *pt, void *ptr)
{
	struct rde_peer	*peer = ptr;

	if (pt->active == NULL)
		return;
	up_generate_updates(peer, pt->active, NULL);
}
@


1.25
log
@struct prefix has a pointer to the peer so use it everywhere directly instead
of the detour via aspath.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.24 2004/07/30 14:44:30 claudio Exp $ */
d286 1
a286 1
			if (old->aspath->flags.aspath->hdr.as_cnt != 0)
d388 1
a388 1
			if (new->aspath->flags.aspath->hdr.as_cnt != 0) {
d458 2
a459 1
		a->attr_hash = aspath_hash(attrs.aspath);
d484 1
a484 1
	attrs.aspath = aspath_create(NULL, 0);
d525 1
a525 1
	a->attr_hash = aspath_hash(attrs.aspath);
d543 1
d557 3
a559 2
	if ((r = aspath_write(up_attr_buf + wlen, len, a->aspath,
	    rde_local_as(), peer->conf.ebgp)) == -1)
d561 1
@


1.24
log
@Add new announce type "default-route" which will only announce the default
route to the specified neighbor. Idea and OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.23 2004/07/13 17:57:20 jaredy Exp $ */
d243 1
a243 1
		if (peer == old->aspath->peer)
d256 1
a256 1
		if (old->aspath->peer->conf.ebgp == 0 && peer->conf.ebgp == 0) {
d265 1
a265 1
			if (old->aspath->peer->conf.reflector_client == 0 &&
d335 1
a335 1
		if (peer == new->aspath->peer) {
d352 1
a352 1
		if (new->aspath->peer->conf.ebgp == 0 && peer->conf.ebgp == 0) {
d361 1
a361 1
			if (new->aspath->peer->conf.reflector_client == 0 &&
@


1.23
log
@fix some typos

ok henning otto
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.22 2004/07/05 02:13:44 henning Exp $ */
a235 6
	/*
	 * Filtering should be hooked up here.
	 * With filtering the decision if withdraw, update or nothing
	 * needs to be done on a per peer basis -- actually per filter
	 * set.
	 */
d258 1
a258 1
			 * redistribution rules:
d277 1
d304 1
a304 1
		 * XXX this is not specified in the RFC but seems logical.
d328 1
a328 1
			fatal("up_queue_update");
d354 1
a354 1
			 * redistribution rules:
d375 5
a379 1
			up_generate_updates(peer, NULL, old);
d425 1
a425 1
		 * XXX this is not specified in the RFC but seems logical.
d440 1
a440 1
			fatal("up_queue_update");
d444 1
a444 1
			fatal("up_queue_update");
d468 66
@


1.22
log
@fix a few KNF fallouts
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.21 2004/06/22 23:17:01 claudio Exp $ */
d265 1
a265 1
			 * 1. if annouce is set			-> announce
d360 1
a360 1
			 * 1. if annouce is set			-> announce
@


1.21
log
@Cleanup. jajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.20 2004/06/22 20:28:58 claudio Exp $ */
d114 1
a114 1
	
@


1.20
log
@Make the RDE IPv6 ready missing is the message handling. The internal
prefix tree changed form a hash table to a per AF RB tree.
OK henning@@ some ideas are from Brent Graveland.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.19 2004/06/20 18:35:12 henning Exp $ */
a24 1
#include "ensure.h"
d108 1
a108 1
	ENSURE(a->prefix.af == AF_INET);
d110 1
a110 1
	if (ntohl(a->prefix.v4.s_addr) < ntohl(b->prefix.v4.s_addr))
d112 1
a112 1
	if (ntohl(a->prefix.v4.s_addr) > ntohl(b->prefix.v4.s_addr))
d114 19
a159 2
	ENSURE(p != NULL);

d234 2
a235 1
	ENSURE(peer->state == PEER_UP);
a312 1
			ENSURE(atr->len == 4);
a429 1
			ENSURE(atr->len == 4);
d618 3
a620 2
	ENSURE(prefix->af == AF_INET);
	ENSURE(plen <= 32);
@


1.19
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.18 2004/05/21 15:36:40 claudio Exp $ */
d216 1
d306 2
a307 1
		if (rde_filter(peer, &attrs, &old->prefix->prefix,
d319 1
a319 1
		p->prefix = old->prefix->prefix;
d400 2
a401 1
		if (rde_filter(peer, &attrs, &new->prefix->prefix,
d445 1
a445 1
		p->prefix = new->prefix->prefix;
@


1.18
log
@RFC 2796 bgp route reflector support. This is very useful in conjunction
with templates. looks good, go for it henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.17 2004/04/30 05:47:50 deraadt Exp $ */
d544 1
a544 1
	TAILQ_FOREACH(oa, &a->others, attr_l) {
@


1.17
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.16 2004/03/20 23:17:35 david Exp $ */
d214 1
d244 16
a259 4
		if (peer->conf.ebgp == 0 && old->aspath->peer->conf.ebgp == 0 &&
		    (old->aspath->nexthop->flags & NEXTHOP_ANNOUNCE) == 0)
			/* Do not redistribute updates to ibgp peers */
			return;
d289 13
a309 1

d339 17
a355 5
		if (peer->conf.ebgp == 0 && new->aspath->peer->conf.ebgp == 0 &&
		    (new->aspath->nexthop->flags & NEXTHOP_ANNOUNCE) == 0) {
			/* Do not redistribute updates to ibgp peers */
			up_generate_updates(peer, NULL, old);
			return;
d405 15
d540 1
a540 1
	 *  2. non-transitive attrs: don't re-announce
a552 4
			if ((r = attr_write(up_attr_buf + wlen, len,
			    oa->flags, oa->type, oa->data, oa->len)) == -1)
				return (-1);
			break;
d554 7
d567 8
a574 2
			if (!(oa->flags & ATTR_TRANSITIVE))
				/* somehow a non-transitive slipped through */
d576 1
@


1.16
log
@comment spelling fixes; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.15 2004/03/19 10:30:15 claudio Exp $ */
d549 1
a549 1
#define MIN_PREFIX_LEN	5	/* 1 byte prefix lenght + 4 bytes addr */
@


1.15
log
@Fix memory leak in error path. Found by Patrick Latifi. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.14 2004/03/11 17:12:51 claudio Exp $ */
d265 1
a265 1
		/* well known communites */
d341 1
a341 1
		/* well known communites */
@


1.14
log
@Add basic support for communities. Currently it is only possible to filter
on communities, e.g match from any community 24640:* set localpref 666
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.13 2004/03/09 13:51:16 claudio Exp $ */
d151 4
d176 6
d295 1
a295 1
			log_warnx("queuing update failed.");
d378 1
a378 1
		    new->aspath->nexthop) == -1)
d380 4
@


1.13
log
@When a new prefix is filtered it is necessary to remove the old prefix.
This is done by a recursive call that does the withdraw. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.12 2004/03/04 11:26:36 henning Exp $ */
d255 11
d331 17
d488 6
a493 2
			    ATTR_OPTIONAL | ATTR_TRANSITIVE, ATTR_AGGREGATOR,
			    oa->data, oa->len)) == -1)
a495 4
		/*
		 * currently there are no non-transitive or transitive known
		 * attributes.
		 */
d498 1
a498 1
			if (!(oa->flags & ATTR_OPTIONAL))
@


1.12
log
@no ; after RB_PROTOTYPE / RB_GENERATE
From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.11 2004/03/02 19:27:37 claudio Exp $ */
d216 4
d276 1
a276 1
		if (peer == new->aspath->peer)
d278 1
d280 1
d284 1
a284 1
		    peer->conf.remote_as))
d289 1
d291 1
d294 1
a294 1
		    (new->aspath->nexthop->flags & NEXTHOP_ANNOUNCE) == 0)
d296 1
d298 1
d304 1
d313 2
a314 1
			if (new->aspath->flags.aspath->hdr.as_cnt != 0)
d316 1
d326 1
@


1.11
log
@Use ntohl() to compare in_addr_t so the tree is nicely sorted.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.10 2004/03/01 23:07:09 deraadt Exp $ */
d55 2
a56 2
RB_PROTOTYPE(uptree_prefix, update_prefix, entry, up_prefix_cmp);
RB_GENERATE(uptree_prefix, update_prefix, entry, up_prefix_cmp);
d58 2
a59 2
RB_PROTOTYPE(uptree_attr, update_attr, entry, up_attr_cmp);
RB_GENERATE(uptree_attr, update_attr, entry, up_attr_cmp);
@


1.10
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.9 2004/02/27 20:53:56 claudio Exp $ */
d111 1
a111 1
	if (a->prefix.v4.s_addr < b->prefix.v4.s_addr)
d113 1
a113 1
	if (a->prefix.v4.s_addr > b->prefix.v4.s_addr)
@


1.9
log
@remove unneded peer pointer in struct prefix and change a in_addr_t to
struct in_addr. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.8 2004/02/25 22:14:31 claudio Exp $ */
d210 1
a210 1
	 * needs to be done on a per peer basis -- acctually per filter
@


1.8
log
@Announce local networks to IBGP neighbors. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.7 2004/02/24 14:27:27 claudio Exp $ */
d216 1
a216 1
		if (peer == old->peer)
d229 1
a229 1
		if (peer->conf.ebgp == 0 && old->peer->conf.ebgp == 0 &&
d272 1
a272 1
		if (peer == new->peer)
d285 1
a285 1
		if (peer->conf.ebgp == 0 && new->peer->conf.ebgp == 0 &&
d376 1
a376 1
		else if (a->nexthop == peer->remote_addr.v4.s_addr)
@


1.7
log
@It is possible that a queued path attribute has no nlri prefix. Ignore and
remove those path attributes before using them in an UPDATE. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.6 2004/02/19 23:07:00 claudio Exp $ */
d229 2
a230 1
		if (peer->conf.ebgp == 0 && old->peer->conf.ebgp == 0)
d285 2
a286 1
		if (peer->conf.ebgp == 0 && new->peer->conf.ebgp == 0)
@


1.6
log
@Add support for basic filters. Nothing optimized and it has some issues but
this is a huge step forward. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.5 2004/02/18 23:25:17 claudio Exp $ */
d491 1
d524 17
a540 2
	upa = TAILQ_FIRST(&peer->updates);
	if (upa == NULL || upa->attr_len + 5 > len) {
@


1.5
log
@Do aspath loop detecion for outgoing messages too, but this time with the
remote peer as. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.4 2004/02/18 16:14:13 claudio Exp $ */
d204 1
d250 11
d305 9
d323 1
a323 1
		if (up_generate_attr(peer, a, &new->aspath->flags,
d331 1
a331 1
		a->attr_hash = aspath_hash(new->aspath->flags.aspath);
d335 3
d363 1
a363 1
	    rde_local_as(), peer->conf.ebgp == 0 ? 0 : 1)) == -1)
@


1.4
log
@Fix a nasty memory leak. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.3 2004/02/17 15:44:02 claudio Exp $ */
d219 9
d261 9
@


1.3
log
@Make gcc on sparc happy. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.2 2004/02/09 01:56:18 henning Exp $ */
d77 2
a78 2
	struct update_attr	*ua, *xua;
	struct update_prefix	*up, *xup;
d80 4
a83 6
	for (ua = TAILQ_FIRST(&peer->updates); ua != TAILQ_END(&peer->updates);
	    ua = xua) {
		xua = TAILQ_NEXT(ua, attr_l);
		for (up = TAILQ_FIRST(&ua->prefix_h);
		    up != TAILQ_END(&ua->prefix_h); up = xup) {
			xup = TAILQ_NEXT(up, prefix_l);
d86 1
d90 2
a91 3
	for (up = TAILQ_FIRST(&peer->withdraws);
	    up != TAILQ_END(&peer->withdraws); up = xup) {
		xup = TAILQ_NEXT(up, prefix_l);
d158 1
d453 1
a453 1
	struct update_prefix	*upp, *xupp;
d456 1
a456 3
	for (upp = TAILQ_FIRST(prefix_head);
	    upp != TAILQ_END(prefix_head); upp = xupp) {
		xupp = TAILQ_NEXT(upp, prefix_l);
d510 1
@


1.2
log
@replace a bunch of u_long by u_int32_t
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_update.c,v 1.1 2004/02/04 09:07:44 claudio Exp $ */
d141 1
a141 1
	struct update_attr	*na;
@


1.1
log
@Move the update generation into a separate file. The update generation has
nothing to do with the decision process. henning@@ "conceptual ok ;-)"
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d43 1
a43 1
	u_long				 attr_hash;
@

