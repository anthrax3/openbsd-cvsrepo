head	1.301;
access;
symbols
	OPENBSD_6_1:1.298.0.4
	OPENBSD_6_1_BASE:1.298
	OPENBSD_6_0:1.288.0.4
	OPENBSD_6_0_BASE:1.288
	OPENBSD_5_9:1.286.0.2
	OPENBSD_5_9_BASE:1.286
	OPENBSD_5_8:1.281.0.4
	OPENBSD_5_8_BASE:1.281
	OPENBSD_5_7:1.275.0.2
	OPENBSD_5_7_BASE:1.275
	OPENBSD_5_6:1.272.0.4
	OPENBSD_5_6_BASE:1.272
	OPENBSD_5_5:1.271.0.4
	OPENBSD_5_5_BASE:1.271
	OPENBSD_5_4:1.266.0.2
	OPENBSD_5_4_BASE:1.266
	OPENBSD_5_3:1.265.0.2
	OPENBSD_5_3_BASE:1.265
	OPENBSD_5_2:1.262.0.2
	OPENBSD_5_2_BASE:1.262
	OPENBSD_5_1_BASE:1.260
	OPENBSD_5_1:1.260.0.2
	OPENBSD_5_0:1.259.0.2
	OPENBSD_5_0_BASE:1.259
	OPENBSD_4_9:1.258.0.2
	OPENBSD_4_9_BASE:1.258
	OPENBSD_4_8:1.257.0.2
	OPENBSD_4_8_BASE:1.257
	OPENBSD_4_7:1.249.0.2
	OPENBSD_4_7_BASE:1.249
	OPENBSD_4_6:1.231.0.4
	OPENBSD_4_6_BASE:1.231
	OPENBSD_4_5:1.219.0.2
	OPENBSD_4_5_BASE:1.219
	OPENBSD_4_4:1.217.0.2
	OPENBSD_4_4_BASE:1.217
	OPENBSD_4_3:1.215.0.2
	OPENBSD_4_3_BASE:1.215
	OPENBSD_4_2:1.207.0.2
	OPENBSD_4_2_BASE:1.207
	OPENBSD_4_1:1.201.0.2
	OPENBSD_4_1_BASE:1.201
	OPENBSD_4_0:1.193.0.2
	OPENBSD_4_0_BASE:1.193
	OPENBSD_3_9:1.181.0.2
	OPENBSD_3_9_BASE:1.181
	OPENBSD_3_8:1.171.0.2
	OPENBSD_3_8_BASE:1.171
	OPENBSD_3_7:1.153.0.2
	OPENBSD_3_7_BASE:1.153
	OPENBSD_3_6:1.139.0.2
	OPENBSD_3_6_BASE:1.139
	OPENBSD_3_5:1.78.0.2
	OPENBSD_3_5_BASE:1.78;
locks; strict;
comment	@ * @;


1.301
date	2017.05.26.20.55.30;	author phessler;	state Exp;
branches;
next	1.300;
commitid	p82SYNnm0pVdbRCn;

1.300
date	2017.05.26.14.08.51;	author phessler;	state Exp;
branches;
next	1.299;
commitid	JyPMWhGxiJkO4I0Z;

1.299
date	2017.05.26.14.07.03;	author phessler;	state Exp;
branches;
next	1.298;
commitid	LUnjmoJppTSHl7SS;

1.298
date	2017.02.22.13.55.14;	author renato;	state Exp;
branches;
next	1.297;
commitid	jJ2W5Hz3cjuR3IvT;

1.297
date	2017.01.25.00.11.07;	author claudio;	state Exp;
branches;
next	1.296;
commitid	osRuMDRl3xarqyZN;

1.296
date	2017.01.24.04.22.42;	author benno;	state Exp;
branches;
next	1.295;
commitid	airB1W2Kb948lFil;

1.295
date	2017.01.18.04.28.45;	author phessler;	state Exp;
branches;
next	1.294;
commitid	JpzVQ9pZA3NZq1GA;

1.294
date	2017.01.13.18.59.12;	author phessler;	state Exp;
branches;
next	1.293;
commitid	3Jvf15B19ysa8i2W;

1.293
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.292;
commitid	3AKCl24jEn0sIt6p;

1.292
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.291;
commitid	uzjOUwLRoN7KbcZI;

1.291
date	2016.12.26.21.30.10;	author jca;	state Exp;
branches;
next	1.290;
commitid	4EK5zByufjOPkoKe;

1.290
date	2016.10.14.16.05.36;	author phessler;	state Exp;
branches;
next	1.289;
commitid	Ai7XVOgXw9ZLovz1;

1.289
date	2016.10.05.07.38.06;	author phessler;	state Exp;
branches;
next	1.288;
commitid	XF7pIhaJDJdwfpZW;

1.288
date	2016.06.21.21.35.24;	author benno;	state Exp;
branches;
next	1.287;
commitid	AL6SnrmnHkmPOpjv;

1.287
date	2016.06.03.17.36.37;	author benno;	state Exp;
branches;
next	1.286;
commitid	utIafqBHH3dRVCSC;

1.286
date	2015.10.27.18.19.33;	author mmcc;	state Exp;
branches;
next	1.285;
commitid	QJqNaKJginL2qSWP;

1.285
date	2015.10.22.13.30.07;	author reyk;	state Exp;
branches;
next	1.284;
commitid	uJZZjgtj3rHWMaJy;

1.284
date	2015.10.11.19.30.12;	author phessler;	state Exp;
branches;
next	1.283;
commitid	2KBZGXKaVqa0PMnV;

1.283
date	2015.09.21.09.47.15;	author phessler;	state Exp;
branches;
next	1.282;
commitid	0iY3tr4GQ1eTlhDV;

1.282
date	2015.09.21.09.41.48;	author phessler;	state Exp;
branches;
next	1.281;
commitid	78Z8h5siDmhtyGlU;

1.281
date	2015.07.16.18.26.04;	author claudio;	state Exp;
branches;
next	1.280;
commitid	LqSO5lx1xfCVcctP;

1.280
date	2015.04.26.20.12.03;	author benno;	state Exp;
branches;
next	1.279;
commitid	YKLP9qAJ8pARDutu;

1.279
date	2015.04.25.15.28.18;	author phessler;	state Exp;
branches;
next	1.278;
commitid	4yPC9ACFnDblFb1s;

1.278
date	2015.03.14.03.52.42;	author claudio;	state Exp;
branches;
next	1.277;
commitid	1OLz8RQEaC2xclFf;

1.277
date	2015.03.14.02.43.02;	author claudio;	state Exp;
branches;
next	1.276;
commitid	0cBsZXPDxYuXNDWX;

1.276
date	2015.03.14.02.32.35;	author claudio;	state Exp;
branches;
next	1.275;
commitid	aIIJ7KgsYMwjPwU7;

1.275
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.274;
commitid	3Z7yItGpFsmshk0c;

1.274
date	2014.11.03.16.55.59;	author bluhm;	state Exp;
branches;
next	1.273;
commitid	SvRBB6vjZmF8ZSzf;

1.273
date	2014.11.02.00.30.41;	author doug;	state Exp;
branches;
next	1.272;
commitid	rEtjfGsy6qgf1X2G;

1.272
date	2014.05.02.14.12.05;	author deraadt;	state Exp;
branches;
next	1.271;

1.271
date	2014.01.22.00.21.16;	author henning;	state Exp;
branches;
next	1.270;

1.270
date	2013.11.25.12.53.27;	author benno;	state Exp;
branches;
next	1.269;

1.269
date	2013.11.13.09.14.48;	author florian;	state Exp;
branches;
next	1.268;

1.268
date	2013.10.19.15.04.25;	author claudio;	state Exp;
branches;
next	1.267;

1.267
date	2013.09.27.08.23.11;	author sthen;	state Exp;
branches;
next	1.266;

1.266
date	2013.05.11.14.42.28;	author benno;	state Exp;
branches;
next	1.265;

1.265
date	2012.11.13.09.47.20;	author claudio;	state Exp;
branches;
next	1.264;

1.264
date	2012.09.23.09.39.17;	author claudio;	state Exp;
branches;
next	1.263;

1.263
date	2012.09.12.05.56.22;	author claudio;	state Exp;
branches;
next	1.262;

1.262
date	2012.07.13.15.25.37;	author claudio;	state Exp;
branches;
next	1.261;

1.261
date	2012.04.12.17.31.05;	author claudio;	state Exp;
branches;
next	1.260;

1.260
date	2011.09.17.16.29.44;	author claudio;	state Exp;
branches;
next	1.259;

1.259
date	2011.05.01.12.56.04;	author claudio;	state Exp;
branches;
next	1.258;

1.258
date	2010.09.02.14.03.21;	author sobrado;	state Exp;
branches;
next	1.257;

1.257
date	2010.08.03.18.42.40;	author henning;	state Exp;
branches;
next	1.256;

1.256
date	2010.06.27.19.53.34;	author claudio;	state Exp;
branches;
next	1.255;

1.255
date	2010.05.17.16.08.20;	author claudio;	state Exp;
branches;
next	1.254;

1.254
date	2010.05.17.15.49.29;	author claudio;	state Exp;
branches;
next	1.253;

1.253
date	2010.05.03.13.09.38;	author claudio;	state Exp;
branches;
next	1.252;

1.252
date	2010.04.28.13.07.48;	author claudio;	state Exp;
branches;
next	1.251;

1.251
date	2010.04.26.08.46.31;	author claudio;	state Exp;
branches;
next	1.250;

1.250
date	2010.03.31.18.53.23;	author claudio;	state Exp;
branches;
next	1.249;

1.249
date	2010.03.05.15.25.00;	author claudio;	state Exp;
branches;
next	1.248;

1.248
date	2010.01.13.06.02.37;	author claudio;	state Exp;
branches;
next	1.247;

1.247
date	2010.01.11.03.24.35;	author deraadt;	state Exp;
branches;
next	1.246;

1.246
date	2009.12.16.15.40.55;	author claudio;	state Exp;
branches;
next	1.245;

1.245
date	2009.12.09.12.52.07;	author claudio;	state Exp;
branches;
next	1.244;

1.244
date	2009.12.09.11.12.50;	author claudio;	state Exp;
branches;
next	1.243;

1.243
date	2009.12.08.14.03.40;	author claudio;	state Exp;
branches;
next	1.242;

1.242
date	2009.12.06.11.42.22;	author claudio;	state Exp;
branches;
next	1.241;

1.241
date	2009.12.01.14.28.05;	author claudio;	state Exp;
branches;
next	1.240;

1.240
date	2009.11.26.13.40.43;	author henning;	state Exp;
branches;
next	1.239;

1.239
date	2009.11.11.13.48.34;	author claudio;	state Exp;
branches;
next	1.238;

1.238
date	2009.10.13.09.51.53;	author claudio;	state Exp;
branches;
next	1.237;

1.237
date	2009.10.06.09.44.13;	author claudio;	state Exp;
branches;
next	1.236;

1.236
date	2009.09.04.13.08.49;	author claudio;	state Exp;
branches;
next	1.235;

1.235
date	2009.09.04.11.50.28;	author claudio;	state Exp;
branches;
next	1.234;

1.234
date	2009.08.31.13.03.31;	author claudio;	state Exp;
branches;
next	1.233;

1.233
date	2009.08.03.13.14.07;	author claudio;	state Exp;
branches;
next	1.232;

1.232
date	2009.07.20.14.56.20;	author claudio;	state Exp;
branches;
next	1.231;

1.231
date	2009.06.06.01.10.29;	author claudio;	state Exp;
branches;
next	1.230;

1.230
date	2009.06.06.01.07.01;	author claudio;	state Exp;
branches;
next	1.229;

1.229
date	2009.06.05.20.46.43;	author claudio;	state Exp;
branches;
next	1.228;

1.228
date	2009.06.05.19.52.32;	author claudio;	state Exp;
branches;
next	1.227;

1.227
date	2009.06.04.22.08.19;	author claudio;	state Exp;
branches;
next	1.226;

1.226
date	2009.06.04.04.46.42;	author claudio;	state Exp;
branches;
next	1.225;

1.225
date	2009.05.27.04.18.21;	author reyk;	state Exp;
branches;
next	1.224;

1.224
date	2009.04.23.16.20.39;	author sthen;	state Exp;
branches;
next	1.223;

1.223
date	2009.03.31.21.03.48;	author tobias;	state Exp;
branches;
next	1.222;

1.222
date	2009.03.26.13.59.30;	author henning;	state Exp;
branches;
next	1.221;

1.221
date	2009.03.22.22.34.59;	author henning;	state Exp;
branches;
next	1.220;

1.220
date	2009.03.18.19.41.41;	author claudio;	state Exp;
branches;
next	1.219;

1.219
date	2009.02.16.18.08.32;	author sthen;	state Exp;
branches;
next	1.218;

1.218
date	2008.10.17.13.02.55;	author henning;	state Exp;
branches;
next	1.217;

1.217
date	2008.07.08.13.14.58;	author claudio;	state Exp;
branches;
next	1.216;

1.216
date	2008.06.15.10.19.21;	author claudio;	state Exp;
branches;
next	1.215;

1.215
date	2008.02.26.10.09.58;	author mpf;	state Exp;
branches;
next	1.214;

1.214
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.213;

1.213
date	2007.10.20.14.24.02;	author pyr;	state Exp;
branches;
next	1.212;

1.212
date	2007.10.16.20.01.23;	author mpf;	state Exp;
branches;
next	1.211;

1.211
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.210;

1.210
date	2007.10.13.16.35.20;	author deraadt;	state Exp;
branches;
next	1.209;

1.209
date	2007.10.11.14.39.17;	author deraadt;	state Exp;
branches;
next	1.208;

1.208
date	2007.09.13.20.39.58;	author claudio;	state Exp;
branches;
next	1.207;

1.207
date	2007.05.31.18.38.58;	author claudio;	state Exp;
branches;
next	1.206;

1.206
date	2007.05.31.04.06.04;	author claudio;	state Exp;
branches;
next	1.205;

1.205
date	2007.05.28.17.26.33;	author henning;	state Exp;
branches;
next	1.204;

1.204
date	2007.04.23.13.04.24;	author claudio;	state Exp;
branches;
next	1.203;

1.203
date	2007.04.17.17.17.45;	author claudio;	state Exp;
branches;
next	1.202;

1.202
date	2007.03.29.13.09.26;	author claudio;	state Exp;
branches;
next	1.201;

1.201
date	2007.03.06.16.52.48;	author henning;	state Exp;
branches;
next	1.200;

1.200
date	2007.02.22.08.34.18;	author henning;	state Exp;
branches;
next	1.199;

1.199
date	2007.01.26.21.34.21;	author claudio;	state Exp;
branches;
next	1.198;

1.198
date	2006.12.05.12.08.13;	author henning;	state Exp;
branches;
next	1.197;

1.197
date	2006.11.28.16.39.34;	author henning;	state Exp;
branches;
next	1.196;

1.196
date	2006.10.25.18.48.29;	author henning;	state Exp;
branches;
next	1.195;

1.195
date	2006.09.19.12.15.29;	author henning;	state Exp;
branches;
next	1.194;

1.194
date	2006.09.19.11.53.10;	author henning;	state Exp;
branches;
next	1.193;

1.193
date	2006.08.27.16.11.05;	author henning;	state Exp;
branches;
next	1.192;

1.192
date	2006.08.04.12.01.48;	author henning;	state Exp;
branches;
next	1.191;

1.191
date	2006.06.17.14.06.09;	author henning;	state Exp;
branches;
next	1.190;

1.190
date	2006.05.31.02.16.25;	author pat;	state Exp;
branches;
next	1.189;

1.189
date	2006.05.26.01.06.12;	author deraadt;	state Exp;
branches;
next	1.188;

1.188
date	2006.04.26.17.13.14;	author claudio;	state Exp;
branches;
next	1.187;

1.187
date	2006.04.18.19.26.55;	author henning;	state Exp;
branches;
next	1.186;

1.186
date	2006.04.18.19.00.52;	author claudio;	state Exp;
branches;
next	1.185;

1.185
date	2006.04.04.12.03.26;	author henning;	state Exp;
branches;
next	1.184;

1.184
date	2006.03.22.13.30.35;	author claudio;	state Exp;
branches;
next	1.183;

1.183
date	2006.03.07.19.47.03;	author claudio;	state Exp;
branches;
next	1.182;

1.182
date	2006.03.04.19.33.22;	author miod;	state Exp;
branches;
next	1.181;

1.181
date	2006.02.10.14.34.40;	author claudio;	state Exp;
branches;
next	1.180;

1.180
date	2006.02.09.21.05.09;	author claudio;	state Exp;
branches;
next	1.179;

1.179
date	2006.02.02.14.06.05;	author claudio;	state Exp;
branches;
next	1.178;

1.178
date	2006.01.07.14.50.28;	author claudio;	state Exp;
branches;
next	1.177;

1.177
date	2005.11.29.16.01.00;	author claudio;	state Exp;
branches;
next	1.176;

1.176
date	2005.11.01.21.42.58;	author claudio;	state Exp;
branches;
next	1.175;

1.175
date	2005.11.01.18.11.24;	author claudio;	state Exp;
branches;
next	1.174;

1.174
date	2005.11.01.17.34.58;	author claudio;	state Exp;
branches;
next	1.173;

1.173
date	2005.11.01.10.58.29;	author claudio;	state Exp;
branches;
next	1.172;

1.172
date	2005.10.19.10.42.06;	author henning;	state Exp;
branches;
next	1.171;

1.171
date	2005.08.09.20.27.25;	author claudio;	state Exp;
branches;
next	1.170;

1.170
date	2005.07.28.20.01.21;	author henning;	state Exp;
branches;
next	1.169;

1.169
date	2005.07.28.16.27.01;	author henning;	state Exp;
branches;
next	1.168;

1.168
date	2005.07.04.09.37.24;	author claudio;	state Exp;
branches;
next	1.167;

1.167
date	2005.07.04.09.31.35;	author claudio;	state Exp;
branches;
next	1.166;

1.166
date	2005.07.01.13.38.14;	author claudio;	state Exp;
branches;
next	1.165;

1.165
date	2005.06.29.09.43.25;	author claudio;	state Exp;
branches;
next	1.164;

1.164
date	2005.06.09.15.32.03;	author claudio;	state Exp;
branches;
next	1.163;

1.163
date	2005.05.24.17.41.13;	author claudio;	state Exp;
branches;
next	1.162;

1.162
date	2005.04.28.13.54.45;	author claudio;	state Exp;
branches;
next	1.161;

1.161
date	2005.04.17.16.41.21;	author henning;	state Exp;
branches;
next	1.160;

1.160
date	2005.04.17.16.36.40;	author henning;	state Exp;
branches;
next	1.159;

1.159
date	2005.04.13.21.16.22;	author claudio;	state Exp;
branches;
next	1.158;

1.158
date	2005.04.12.14.32.00;	author claudio;	state Exp;
branches;
next	1.157;

1.157
date	2005.04.12.14.26.58;	author claudio;	state Exp;
branches;
next	1.156;

1.156
date	2005.03.29.11.13.33;	author henning;	state Exp;
branches;
next	1.155;

1.155
date	2005.03.28.15.39.32;	author henning;	state Exp;
branches;
next	1.154;

1.154
date	2005.03.23.22.26.34;	author claudio;	state Exp;
branches;
next	1.153;

1.153
date	2005.03.16.10.50.26;	author henning;	state Exp;
branches;
next	1.152;

1.152
date	2005.03.14.17.32.04;	author claudio;	state Exp;
branches;
next	1.151;

1.151
date	2005.03.13.15.27.30;	author henning;	state Exp;
branches;
next	1.150;

1.150
date	2005.03.11.12.54.19;	author claudio;	state Exp;
branches;
next	1.149;

1.149
date	2004.12.23.16.09.26;	author henning;	state Exp;
branches;
next	1.148;

1.148
date	2004.11.23.13.07.01;	author claudio;	state Exp;
branches;
next	1.147;

1.147
date	2004.11.19.14.43.57;	author claudio;	state Exp;
branches;
next	1.146;

1.146
date	2004.11.19.10.03.34;	author claudio;	state Exp;
branches;
next	1.145;

1.145
date	2004.11.18.17.07.38;	author henning;	state Exp;
branches;
next	1.144;

1.144
date	2004.11.11.10.35.15;	author claudio;	state Exp;
branches;
next	1.143;

1.143
date	2004.11.05.14.30.54;	author henning;	state Exp;
branches;
next	1.142;

1.142
date	2004.11.04.14.05.46;	author henning;	state Exp;
branches;
next	1.141;

1.141
date	2004.10.19.12.02.50;	author henning;	state Exp;
branches;
next	1.140;

1.140
date	2004.09.28.12.09.31;	author claudio;	state Exp;
branches;
next	1.139;

1.139
date	2004.08.24.15.33.48;	author henning;	state Exp;
branches;
next	1.138;

1.138
date	2004.08.24.15.30.07;	author henning;	state Exp;
branches;
next	1.137;

1.137
date	2004.08.24.12.59.41;	author claudio;	state Exp;
branches;
next	1.136;

1.136
date	2004.08.20.15.31.56;	author claudio;	state Exp;
branches;
next	1.135;

1.135
date	2004.08.20.14.56.09;	author claudio;	state Exp;
branches;
next	1.134;

1.134
date	2004.08.17.16.06.39;	author claudio;	state Exp;
branches;
next	1.133;

1.133
date	2004.08.13.14.03.20;	author claudio;	state Exp;
branches;
next	1.132;

1.132
date	2004.08.10.13.02.08;	author claudio;	state Exp;
branches;
next	1.131;

1.131
date	2004.08.05.18.40.44;	author claudio;	state Exp;
branches;
next	1.130;

1.130
date	2004.08.03.13.46.22;	author claudio;	state Exp;
branches;
next	1.129;

1.129
date	2004.08.02.21.30.55;	author claudio;	state Exp;
branches;
next	1.128;

1.128
date	2004.07.30.14.44.30;	author claudio;	state Exp;
branches;
next	1.127;

1.127
date	2004.07.28.17.05.08;	author henning;	state Exp;
branches;
next	1.126;

1.126
date	2004.07.28.15.10.01;	author henning;	state Exp;
branches;
next	1.125;

1.125
date	2004.07.28.15.05.20;	author henning;	state Exp;
branches;
next	1.124;

1.124
date	2004.07.28.14.43.54;	author henning;	state Exp;
branches;
next	1.123;

1.123
date	2004.07.28.14.15.28;	author henning;	state Exp;
branches;
next	1.122;

1.122
date	2004.07.28.12.46.36;	author henning;	state Exp;
branches;
next	1.121;

1.121
date	2004.07.27.20.26.59;	author henning;	state Exp;
branches;
next	1.120;

1.120
date	2004.07.27.13.27.42;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2004.07.13.17.57.20;	author jaredy;	state Exp;
branches;
next	1.118;

1.118
date	2004.07.05.16.54.53;	author henning;	state Exp;
branches;
next	1.117;

1.117
date	2004.07.03.17.19.59;	author claudio;	state Exp;
branches;
next	1.116;

1.116
date	2004.06.23.00.11.27;	author claudio;	state Exp;
branches;
next	1.115;

1.115
date	2004.06.20.18.35.12;	author henning;	state Exp;
branches;
next	1.114;

1.114
date	2004.06.08.14.34.48;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2004.06.06.17.38.10;	author henning;	state Exp;
branches;
next	1.112;

1.112
date	2004.05.21.15.36.40;	author claudio;	state Exp;
branches;
next	1.111;

1.111
date	2004.05.17.12.39.32;	author djm;	state Exp;
branches;
next	1.110;

1.110
date	2004.05.08.20.58.00;	author henning;	state Exp;
branches;
next	1.109;

1.109
date	2004.05.08.20.56.10;	author henning;	state Exp;
branches;
next	1.108;

1.108
date	2004.05.08.20.50.29;	author henning;	state Exp;
branches;
next	1.107;

1.107
date	2004.05.08.19.17.20;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2004.05.08.19.09.34;	author henning;	state Exp;
branches;
next	1.105;

1.105
date	2004.05.08.18.04.14;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2004.05.08.17.40.53;	author henning;	state Exp;
branches;
next	1.103;

1.103
date	2004.05.08.17.23.20;	author henning;	state Exp;
branches;
next	1.102;

1.102
date	2004.05.07.10.06.15;	author djm;	state Exp;
branches;
next	1.101;

1.101
date	2004.05.06.14.41.47;	author henning;	state Exp;
branches;
next	1.100;

1.100
date	2004.05.04.11.34.01;	author claudio;	state Exp;
branches;
next	1.99;

1.99
date	2004.04.30.17.34.05;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2004.04.30.05.47.50;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2004.04.29.19.56.04;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2004.04.28.06.43.04;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2004.04.28.04.34.46;	author henning;	state Exp;
branches;
next	1.94;

1.94
date	2004.04.28.01.36.56;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2004.04.28.00.38.39;	author henning;	state Exp;
branches;
next	1.92;

1.92
date	2004.04.27.23.15.28;	author markus;	state Exp;
branches;
next	1.91;

1.91
date	2004.04.27.23.02.41;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2004.04.27.22.42.13;	author henning;	state Exp;
branches;
next	1.89;

1.89
date	2004.04.27.22.06.54;	author henning;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.27.04.38.12;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.27.02.35.24;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2004.04.26.20.07.43;	author henning;	state Exp;
branches;
next	1.85;

1.85
date	2004.04.26.19.11.01;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2004.04.26.08.51.10;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2004.04.26.07.58.04;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2004.04.25.18.21.18;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2004.04.25.17.51.46;	author henning;	state Exp;
branches;
next	1.80;

1.80
date	2004.04.25.07.16.24;	author henning;	state Exp;
branches;
next	1.79;

1.79
date	2004.04.24.19.36.19;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2004.03.11.19.01.08;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2004.03.11.17.47.48;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2004.03.11.17.12.51;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2004.03.10.11.40.33;	author henning;	state Exp;
branches;
next	1.74;

1.74
date	2004.03.10.11.38.32;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2004.03.08.10.48.06;	author henning;	state Exp;
branches;
next	1.72;

1.72
date	2004.03.08.10.33.34;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2004.03.06.21.41.44;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2004.03.05.21.52.45;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.02.20.00.14;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.02.19.45.04;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.01.22.58.12;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2004.03.01.17.04.07;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2004.03.01.16.47.06;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2004.03.01.16.02.01;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2004.02.26.14.00.33;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2004.02.26.13.54.50;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2004.02.26.09.53.58;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2004.02.25.19.48.18;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2004.02.25.14.25.22;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.24.15.43.03;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.19.13.54.58;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.10.23.10.23;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.09.01.46.34;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.09.00.00.41;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2004.02.08.23.44.57;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2004.02.06.20.37.53;	author henning;	state Exp;
branches;
next	1.51;

1.51
date	2004.02.06.20.18.18;	author henning;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.05.23.50.54;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.05.14.42.45;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2004.02.05.14.29.09;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2004.02.03.22.28.05;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2004.02.03.17.36.30;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.01.19.46.05;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.28.23.49.55;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.28.23.31.28;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.27.16.49.53;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.26.21.08.18;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.26.14.42.47;	author henning;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.24.19.43.37;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.24.19.26.12;	author mcbride;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.22.21.09.00;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.17.19.35.36;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.17.19.15.07;	author henning;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.13.13.45.49;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.06.23.36.40;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.06.20.41.55;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.06.03.43.50;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.05.22.57.58;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.05.19.14.41;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.05.19.06.42;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.05.19.04.11;	author henning;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.03.20.37.34;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.03.20.22.07;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.27.21.40.43;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.27.17.34.10;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.27.14.42.59;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.27.14.28.41;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.26.20.52.14;	author jakob;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.26.18.07.32;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.25.23.23.51;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.25.18.35.17;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.25.18.04.10;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.25.17.58.50;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.25.17.35.53;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.25.14.28.49;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.24.14.10.49;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.24.13.49.21;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.23.13.13.24;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.23.01.06.21;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.22.19.43.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.22.19.39.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.22.19.36.19;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.21.22.16.53;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.20.20.53.30;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.19.01.38.34;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.17.18.11.31;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.17.11.46.54;	author henning;	state Exp;
branches;
next	;


desc
@@


1.301
log
@AS 0 is special and should be considered an error.

Drop the session if it shows during OPEN or CAPA, or mark as invalid if
it is part of an Update.

required by RFC 7607

man page OK jmc@@
OK florian@@ benno@@ claudio@@
@
text
@/*	$OpenBSD: parse.y,v 1.300 2017/05/26 14:08:51 phessler Exp $ */

/*
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 * Copyright (c) 2016 Job Snijders <job@@instituut.net>
 * Copyright (c) 2016 Peter Hessler <phessler@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <netinet/ip_ipsp.h>
#include <arpa/inet.h>
#include <netmpls/mpls.h>

#include <ctype.h>
#include <err.h>
#include <unistd.h>
#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>

#include "bgpd.h"
#include "mrt.h"
#include "session.h"
#include "rde.h"
#include "log.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

static struct bgpd_config	*conf;
static struct network_head	*netconf;
static struct peer		*peer_l, *peer_l_old;
static struct peer		*curpeer;
static struct peer		*curgroup;
static struct rdomain		*currdom;
static struct filter_head	*filter_l;
static struct filter_head	*peerfilter_l;
static struct filter_head	*groupfilter_l;
static struct filter_rule	*curpeer_filter[2];
static struct filter_rule	*curgroup_filter[2];
static u_int32_t		 id;

struct filter_rib_l {
	struct filter_rib_l	*next;
	char			 name[PEER_DESCR_LEN];
};

struct filter_peers_l {
	struct filter_peers_l	*next;
	struct filter_peers	 p;
};

struct filter_prefix_l {
	struct filter_prefix_l	*next;
	struct filter_prefix	 p;
};

struct filter_prefixlen {
	enum comp_ops		op;
	int			len_min;
	int			len_max;
};

struct filter_as_l {
	struct filter_as_l	*next;
	struct filter_as	 a;
};

struct filter_match_l {
	struct filter_match	 m;
	struct filter_prefix_l	*prefix_l;
	struct filter_as_l	*as_l;
} fmopts;

struct peer	*alloc_peer(void);
struct peer	*new_peer(void);
struct peer	*new_group(void);
int		 add_mrtconfig(enum mrt_type, char *, int, struct peer *,
		    char *);
int		 add_rib(char *, u_int, u_int16_t);
struct rde_rib	*find_rib(char *);
int		 get_id(struct peer *);
int		 merge_prefixspec(struct filter_prefix_l *,
		    struct filter_prefixlen *);
int		 expand_rule(struct filter_rule *, struct filter_rib_l *,
		    struct filter_peers_l *, struct filter_match_l *,
		    struct filter_set_head *);
int		 str2key(char *, char *, size_t);
int		 neighbor_consistent(struct peer *);
int		 merge_filterset(struct filter_set_head *, struct filter_set *);
void		 copy_filterset(struct filter_set_head *,
		    struct filter_set_head *);
void		 merge_filter_lists(struct filter_head *, struct filter_head *);
struct filter_rule	*get_rule(enum action_types);

int		 getcommunity(char *);
int		 parsecommunity(struct filter_community *, char *);
int64_t 	 getlargecommunity(char *);
int		 parselargecommunity(struct filter_largecommunity *, char *);
int		 parsesubtype(char *);
int		 parseextvalue(char *, u_int32_t *);
int		 parseextcommunity(struct filter_extcommunity *, char *,
		    char *);

typedef struct {
	union {
		int64_t			 number;
		char			*string;
		struct bgpd_addr	 addr;
		u_int8_t		 u8;
		struct filter_rib_l	*filter_rib;
		struct filter_peers_l	*filter_peers;
		struct filter_match_l	 filter_match;
		struct filter_prefix_l	*filter_prefix;
		struct filter_as_l	*filter_as;
		struct filter_set	*filter_set;
		struct filter_set_head	*filter_set_head;
		struct {
			struct bgpd_addr	prefix;
			u_int8_t		len;
		}			prefix;
		struct filter_prefixlen	prefixlen;
		struct {
			u_int8_t		enc_alg;
			char			enc_key[IPSEC_ENC_KEY_LEN];
			u_int8_t		enc_key_len;
		}			encspec;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	AS ROUTERID HOLDTIME YMIN LISTEN ON FIBUPDATE FIBPRIORITY RTABLE
%token	RDOMAIN RD EXPORTTRGT IMPORTTRGT
%token	RDE RIB EVALUATE IGNORE COMPARE
%token	GROUP NEIGHBOR NETWORK
%token	REMOTEAS DESCR LOCALADDR MULTIHOP PASSIVE MAXPREFIX RESTART
%token	ANNOUNCE CAPABILITIES REFRESH AS4BYTE CONNECTRETRY
%token	DEMOTE ENFORCE NEIGHBORAS REFLECTOR DEPEND DOWN SOFTRECONFIG
%token	DUMP IN OUT SOCKET RESTRICTED
%token	LOG ROUTECOLL TRANSPARENT
%token	TCP MD5SIG PASSWORD KEY TTLSECURITY
%token	ALLOW DENY MATCH
%token	QUICK
%token	FROM TO ANY
%token	CONNECTED STATIC
%token	COMMUNITY EXTCOMMUNITY LARGECOMMUNITY
%token	PREFIX PREFIXLEN SOURCEAS TRANSITAS PEERAS DELETE MAXASLEN MAXASSEQ
%token	SET LOCALPREF MED METRIC NEXTHOP REJECT BLACKHOLE NOMODIFY SELF
%token	PREPEND_SELF PREPEND_PEER PFTABLE WEIGHT RTLABEL ORIGIN
%token	ERROR INCLUDE
%token	IPSEC ESP AH SPI IKE
%token	IPV4 IPV6
%token	QUALIFY VIA
%token	NE LE GE XRANGE LONGER
%token	<v.string>		STRING
%token	<v.number>		NUMBER
%type	<v.number>		asnumber as4number as4number_any optnumber
%type	<v.number>		espah family restart origincode nettype
%type	<v.number>		yesno inout restricted
%type	<v.string>		string
%type	<v.addr>		address
%type	<v.prefix>		prefix addrspec
%type	<v.u8>			action quick direction delete
%type	<v.filter_rib>		filter_rib_h filter_rib_l filter_rib
%type	<v.filter_peers>	filter_peer filter_peer_l filter_peer_h
%type	<v.filter_match>	filter_match filter_elm filter_match_h
%type	<v.filter_as>		filter_as filter_as_l filter_as_h
%type	<v.filter_as>		filter_as_t filter_as_t_l filter_as_l_h
%type	<v.prefixlen>		prefixlenop
%type	<v.filter_set>		filter_set_opt
%type	<v.filter_set_head>	filter_set filter_set_l
%type	<v.filter_prefix>	filter_prefix filter_prefix_l filter_prefix_h
%type	<v.filter_prefix>	filter_prefix_m
%type	<v.u8>			unaryop equalityop binaryop filter_as_type
%type	<v.encspec>		encspec
%%

grammar		: /* empty */
		| grammar '\n'
		| grammar include '\n'
		| grammar conf_main '\n'
		| grammar varset '\n'
		| grammar rdomain '\n'
		| grammar neighbor '\n'
		| grammar group '\n'
		| grammar filterrule '\n'
		| grammar error '\n'		{ file->errors++; }
		;

asnumber	: NUMBER			{
			/*
			 * According to iana 65535 and 4294967295 are reserved
			 * but enforcing this is not duty of the parser.
			 */
			if ($1 < 0 || $1 > UINT_MAX) {
				yyerror("AS too big: max %u", UINT_MAX);
				YYERROR;
			}
		}

as4number	: STRING			{
			const char	*errstr;
			char		*dot;
			u_int32_t	 uvalh = 0, uval;

			if ((dot = strchr($1,'.')) != NULL) {
				*dot++ = '\0';
				uvalh = strtonum($1, 0, USHRT_MAX, &errstr);
				if (errstr) {
					yyerror("number %s is %s", $1, errstr);
					free($1);
					YYERROR;
				}
				uval = strtonum(dot, 0, USHRT_MAX, &errstr);
				if (errstr) {
					yyerror("number %s is %s", dot, errstr);
					free($1);
					YYERROR;
				}
				free($1);
			} else {
				yyerror("AS %s is bad", $1);
				free($1);
				YYERROR;
			}
			if (uvalh == 0 && uval == AS_TRANS) {
				yyerror("AS %u is reserved and may not be used",
				    AS_TRANS);
				YYERROR;
			}
			$$ = uval | (uvalh << 16);
		}
		| asnumber {
			if ($1 == AS_TRANS) {
				yyerror("AS %u is reserved and may not be used",
				    AS_TRANS);
				YYERROR;
			}
			$$ = $1;
		}
		;

as4number_any	: STRING			{
			const char	*errstr;
			char		*dot;
			u_int32_t	 uvalh = 0, uval;

			if ((dot = strchr($1,'.')) != NULL) {
				*dot++ = '\0';
				uvalh = strtonum($1, 0, USHRT_MAX, &errstr);
				if (errstr) {
					yyerror("number %s is %s", $1, errstr);
					free($1);
					YYERROR;
				}
				uval = strtonum(dot, 0, USHRT_MAX, &errstr);
				if (errstr) {
					yyerror("number %s is %s", dot, errstr);
					free($1);
					YYERROR;
				}
				free($1);
			} else {
				yyerror("AS %s is bad", $1);
				free($1);
				YYERROR;
			}
			$$ = uval | (uvalh << 16);
		}
		| asnumber {
			$$ = $1;
		}
		;

string		: string STRING			{
			if (asprintf(&$$, "%s %s", $1, $2) == -1)
				fatal("string: asprintf");
			free($1);
			free($2);
		}
		| STRING
		;

yesno		:  STRING			{
			if (!strcmp($1, "yes"))
				$$ = 1;
			else if (!strcmp($1, "no"))
				$$ = 0;
			else {
				yyerror("syntax error, "
				    "either yes or no expected");
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

varset		: STRING '=' string		{
			char *s = $1;
			if (cmd_opts & BGPD_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 1)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

conf_main	: AS as4number		{
			conf->as = $2;
			if ($2 > USHRT_MAX)
				conf->short_as = AS_TRANS;
			else
				conf->short_as = $2;
		}
		| AS as4number asnumber {
			conf->as = $2;
			conf->short_as = $3;
		}
		| ROUTERID address		{
			if ($2.aid != AID_INET) {
				yyerror("router-id must be an IPv4 address");
				YYERROR;
			}
			conf->bgpid = $2.v4.s_addr;
		}
		| HOLDTIME NUMBER	{
			if ($2 < MIN_HOLDTIME || $2 > USHRT_MAX) {
				yyerror("holdtime must be between %u and %u",
				    MIN_HOLDTIME, USHRT_MAX);
				YYERROR;
			}
			conf->holdtime = $2;
		}
		| HOLDTIME YMIN NUMBER	{
			if ($3 < MIN_HOLDTIME || $3 > USHRT_MAX) {
				yyerror("holdtime must be between %u and %u",
				    MIN_HOLDTIME, USHRT_MAX);
				YYERROR;
			}
			conf->min_holdtime = $3;
		}
		| LISTEN ON address	{
			struct listen_addr	*la;

			if ((la = calloc(1, sizeof(struct listen_addr))) ==
			    NULL)
				fatal("parse conf_main listen on calloc");

			la->fd = -1;
			memcpy(&la->sa, addr2sa(&$3, BGP_PORT), sizeof(la->sa));
			TAILQ_INSERT_TAIL(conf->listen_addrs, la, entry);
		}
		| FIBPRIORITY NUMBER		{
			if ($2 <= RTP_NONE || $2 > RTP_MAX) {
				yyerror("invalid fib-priority");
				YYERROR;
			}
			conf->fib_priority = $2;
		}
		| FIBUPDATE yesno		{
			struct rde_rib *rr;
			rr = find_rib("Loc-RIB");
			if (rr == NULL)
				fatalx("RTABLE can not find the main RIB!");

			if ($2 == 0)
				rr->flags |= F_RIB_NOFIBSYNC;
			else
				rr->flags &= ~F_RIB_NOFIBSYNC;
		}
		| ROUTECOLL yesno	{
			if ($2 == 1)
				conf->flags |= BGPD_FLAG_NO_EVALUATE;
			else
				conf->flags &= ~BGPD_FLAG_NO_EVALUATE;
		}
		| RDE RIB STRING {
			if (add_rib($3, 0, F_RIB_NOFIB)) {
				free($3);
				YYERROR;
			}
			free($3);
		}
		| RDE RIB STRING yesno EVALUATE {
			if ($4) {
				free($3);
				yyerror("bad rde rib definition");
				YYERROR;
			}
			if (add_rib($3, 0, F_RIB_NOFIB | F_RIB_NOEVALUATE)) {
				free($3);
				YYERROR;
			}
			free($3);
		}
		| RDE RIB STRING RTABLE NUMBER {
			if (add_rib($3, $5, 0)) {
				free($3);
				YYERROR;
			}
			free($3);
		}
		| RDE RIB STRING RTABLE NUMBER FIBUPDATE yesno {
			int	flags = 0;
			if ($7 == 0)
				flags = F_RIB_NOFIBSYNC;
			if (add_rib($3, $5, flags)) {
				free($3);
				YYERROR;
			}
			free($3);
		}
		| TRANSPARENT yesno	{
			if ($2 == 1)
				conf->flags |= BGPD_FLAG_DECISION_TRANS_AS;
			else
				conf->flags &= ~BGPD_FLAG_DECISION_TRANS_AS;
		}
		| LOG STRING		{
			if (!strcmp($2, "updates"))
				conf->log |= BGPD_LOG_UPDATES;
			else {
				free($2);
				YYERROR;
			}
			free($2);
		}
		| network
		| DUMP STRING STRING optnumber		{
			int action;

			if ($4 < 0 || $4 > INT_MAX) {
				yyerror("bad timeout");
				free($2);
				free($3);
				YYERROR;
			}
			if (!strcmp($2, "table"))
				action = MRT_TABLE_DUMP;
			else if (!strcmp($2, "table-mp"))
				action = MRT_TABLE_DUMP_MP;
			else if (!strcmp($2, "table-v2"))
				action = MRT_TABLE_DUMP_V2;
			else {
				yyerror("unknown mrt dump type");
				free($2);
				free($3);
				YYERROR;
			}
			free($2);
			if (add_mrtconfig(action, $3, $4, NULL, NULL) == -1) {
				free($3);
				YYERROR;
			}
			free($3);
		}
		| DUMP RIB STRING STRING STRING optnumber		{
			int action;

			if ($6 < 0 || $6 > INT_MAX) {
				yyerror("bad timeout");
				free($3);
				free($4);
				free($5);
				YYERROR;
			}
			if (!strcmp($4, "table"))
				action = MRT_TABLE_DUMP;
			else if (!strcmp($4, "table-mp"))
				action = MRT_TABLE_DUMP_MP;
			else if (!strcmp($4, "table-v2"))
				action = MRT_TABLE_DUMP_V2;
			else {
				yyerror("unknown mrt dump type");
				free($3);
				free($4);
				free($5);
				YYERROR;
			}
			free($4);
			if (add_mrtconfig(action, $5, $6, NULL, $3) == -1) {
				free($3);
				free($5);
				YYERROR;
			}
			free($3);
			free($5);
		}
		| mrtdump
		| RDE STRING EVALUATE		{
			if (!strcmp($2, "route-age"))
				conf->flags |= BGPD_FLAG_DECISION_ROUTEAGE;
			else {
				yyerror("unknown route decision type");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| RDE STRING IGNORE		{
			if (!strcmp($2, "route-age"))
				conf->flags &= ~BGPD_FLAG_DECISION_ROUTEAGE;
			else {
				yyerror("unknown route decision type");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| RDE MED COMPARE STRING	{
			if (!strcmp($4, "always"))
				conf->flags |= BGPD_FLAG_DECISION_MED_ALWAYS;
			else if (!strcmp($4, "strict"))
				conf->flags &= ~BGPD_FLAG_DECISION_MED_ALWAYS;
			else {
				yyerror("rde med compare: "
				    "unknown setting \"%s\"", $4);
				free($4);
				YYERROR;
			}
			free($4);
		}
		| NEXTHOP QUALIFY VIA STRING	{
			if (!strcmp($4, "bgp"))
				conf->flags |= BGPD_FLAG_NEXTHOP_BGP;
			else if (!strcmp($4, "default"))
				conf->flags |= BGPD_FLAG_NEXTHOP_DEFAULT;
			else {
				yyerror("nexthop depend on: "
				    "unknown setting \"%s\"", $4);
				free($4);
				YYERROR;
			}
			free($4);
		}
		| RTABLE NUMBER {
			struct rde_rib *rr;
			if (ktable_exists($2, NULL) != 1) {
				yyerror("rtable id %lld does not exist", $2);
				YYERROR;
			}
			rr = find_rib("Loc-RIB");
			if (rr == NULL)
				fatalx("RTABLE can not find the main RIB!");
			rr->rtableid = $2;
		}
		| CONNECTRETRY NUMBER {
			if ($2 > USHRT_MAX || $2 < 1) {
				yyerror("invalid connect-retry");
				YYERROR;
			}
			conf->connectretry = $2;
		}
		| SOCKET STRING	restricted {
			if (strlen($2) >=
			    sizeof(((struct sockaddr_un *)0)->sun_path)) {
				yyerror("socket path too long");
				YYERROR;
			}
			if ($3) {
				free(conf->rcsock);
				conf->rcsock = $2;
			} else {
				free(conf->csock);
				conf->csock = $2;
			}
		}
		;

mrtdump		: DUMP STRING inout STRING optnumber	{
			int action;

			if ($5 < 0 || $5 > INT_MAX) {
				yyerror("bad timeout");
				free($2);
				free($4);
				YYERROR;
			}
			if (!strcmp($2, "all"))
				action = $3 ? MRT_ALL_IN : MRT_ALL_OUT;
			else if (!strcmp($2, "updates"))
				action = $3 ? MRT_UPDATE_IN : MRT_UPDATE_OUT;
			else {
				yyerror("unknown mrt msg dump type");
				free($2);
				free($4);
				YYERROR;
			}
			if (add_mrtconfig(action, $4, $5, curpeer, NULL) ==
			    -1) {
				free($2);
				free($4);
				YYERROR;
			}
			free($2);
			free($4);
		}
		;

network		: NETWORK prefix filter_set	{
			struct network	*n;

			if ((n = calloc(1, sizeof(struct network))) == NULL)
				fatal("new_network");
			memcpy(&n->net.prefix, &$2.prefix,
			    sizeof(n->net.prefix));
			n->net.prefixlen = $2.len;
			filterset_move($3, &n->net.attrset);
			free($3);

			TAILQ_INSERT_TAIL(netconf, n, entry);
		}
		| NETWORK family RTLABEL STRING filter_set	{
			struct network	*n;

			if ((n = calloc(1, sizeof(struct network))) == NULL)
				fatal("new_network");
			if (afi2aid($2, SAFI_UNICAST, &n->net.prefix.aid) ==
			    -1) {
				yyerror("unknown family");
				filterset_free($5);
				free($5);
				YYERROR;
			}
			n->net.type = NETWORK_RTLABEL;
			n->net.rtlabel = rtlabel_name2id($4);
			filterset_move($5, &n->net.attrset);
			free($5);

			TAILQ_INSERT_TAIL(netconf, n, entry);
		}
		| NETWORK family nettype filter_set	{
			struct network	*n;

			if ((n = calloc(1, sizeof(struct network))) == NULL)
				fatal("new_network");
			if (afi2aid($2, SAFI_UNICAST, &n->net.prefix.aid) ==
			    -1) {
				yyerror("unknown family");
				filterset_free($4);
				free($4);
				YYERROR;
			}
			n->net.type = $3 ? NETWORK_STATIC : NETWORK_CONNECTED;
			filterset_move($4, &n->net.attrset);
			free($4);

			TAILQ_INSERT_TAIL(netconf, n, entry);
		}
		;

inout		: IN		{ $$ = 1; }
		| OUT		{ $$ = 0; }
		;

restricted	: RESTRICTED	{ $$ = 1; }
		| /* nothing */	{ $$ = 0; }
		;

address		: STRING		{
			u_int8_t	len;

			if (!host($1, &$$, &len)) {
				yyerror("could not parse address spec \"%s\"",
				    $1);
				free($1);
				YYERROR;
			}
			free($1);

			if (($$.aid == AID_INET && len != 32) ||
			    ($$.aid == AID_INET6 && len != 128)) {
				/* unreachable */
				yyerror("got prefixlen %u, expected %u",
				    len, $$.aid == AID_INET ? 32 : 128);
				YYERROR;
			}
		}
		;

prefix		: STRING '/' NUMBER	{
			char	*s;

			if ($3 < 0 || $3 > 128) {
				yyerror("bad prefixlen %lld", $3);
				free($1);
				YYERROR;
			}
			if (asprintf(&s, "%s/%lld", $1, $3) == -1)
				fatal(NULL);
			free($1);

			if (!host(s, &$$.prefix, &$$.len)) {
				yyerror("could not parse address \"%s\"", s);
				free(s);
				YYERROR;
			}
			free(s);
		}
		| NUMBER '/' NUMBER	{
			char	*s;

			/* does not match IPv6 */
			if ($1 < 0 || $1 > 255 || $3 < 0 || $3 > 32) {
				yyerror("bad prefix %lld/%lld", $1, $3);
				YYERROR;
			}
			if (asprintf(&s, "%lld/%lld", $1, $3) == -1)
				fatal(NULL);

			if (!host(s, &$$.prefix, &$$.len)) {
				yyerror("could not parse address \"%s\"", s);
				free(s);
				YYERROR;
			}
			free(s);
		}
		;

addrspec	: address	{
			memcpy(&$$.prefix, &$1, sizeof(struct bgpd_addr));
			if ($$.prefix.aid == AID_INET)
				$$.len = 32;
			else
				$$.len = 128;
		}
		| prefix
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl		/* one newline or more */
		;

optnumber	: /* empty */		{ $$ = 0; }
		| NUMBER
		;

rdomain		: RDOMAIN NUMBER optnl '{' optnl	{
			if (ktable_exists($2, NULL) != 1) {
				yyerror("rdomain %lld does not exist", $2);
				YYERROR;
			}
			if (!(currdom = calloc(1, sizeof(struct rdomain))))
				fatal(NULL);
			currdom->rtableid = $2;
			TAILQ_INIT(&currdom->import);
			TAILQ_INIT(&currdom->export);
			TAILQ_INIT(&currdom->net_l);
			netconf = &currdom->net_l;
		}
		    rdomainopts_l '}' {
			/* insert into list */
			SIMPLEQ_INSERT_TAIL(&conf->rdomains, currdom, entry);
			currdom = NULL;
			netconf = &conf->networks;
		}

rdomainopts_l	: rdomainopts_l rdomainoptsl
		| rdomainoptsl
		;

rdomainoptsl	: rdomainopts nl
		;

rdomainopts	: RD STRING {
			struct filter_extcommunity	ext;
			u_int64_t			rd;

			if (parseextcommunity(&ext, "rt", $2) == -1) {
				free($2);
				YYERROR;
			}
			free($2);
			/*
			 * RD is almost encode like an ext-community,
			 * but only almost so convert here.
			 */
			if (community_ext_conv(&ext, 0, &rd)) {
				yyerror("bad encoding of rd");
				YYERROR;
			}
			rd = betoh64(rd) & 0xffffffffffffULL;
			switch (ext.type) {
			case EXT_COMMUNITY_TWO_AS:
				rd |= (0ULL << 48);
				break;
			case EXT_COMMUNITY_IPV4:
				rd |= (1ULL << 48);
				break;
			case EXT_COMMUNITY_FOUR_AS:
				rd |= (2ULL << 48);
				break;
			default:
				yyerror("bad encoding of rd");
				YYERROR;
			}
			currdom->rd = htobe64(rd);
		}
		| EXPORTTRGT STRING STRING	{
			struct filter_set	*set;

			if ((set = calloc(1, sizeof(struct filter_set))) ==
			    NULL)
				fatal(NULL);
			set->type = ACTION_SET_EXT_COMMUNITY;
			if (parseextcommunity(&set->action.ext_community,
			    $2, $3) == -1) {
				free($3);
				free($2);
				free(set);
				YYERROR;
			}
			free($3);
			free($2);
			TAILQ_INSERT_TAIL(&currdom->export, set, entry);
		}
		| IMPORTTRGT STRING STRING	{
			struct filter_set	*set;

			if ((set = calloc(1, sizeof(struct filter_set))) ==
			    NULL)
				fatal(NULL);
			set->type = ACTION_SET_EXT_COMMUNITY;
			if (parseextcommunity(&set->action.ext_community,
			    $2, $3) == -1) {
				free($3);
				free($2);
				free(set);
				YYERROR;
			}
			free($3);
			free($2);
			TAILQ_INSERT_TAIL(&currdom->import, set, entry);
		}
		| DESCR string		{
			if (strlcpy(currdom->descr, $2,
			    sizeof(currdom->descr)) >=
			    sizeof(currdom->descr)) {
				yyerror("descr \"%s\" too long: max %zu",
				    $2, sizeof(currdom->descr) - 1);
				free($2);
				YYERROR;
			}
			free($2);
		}
		| FIBUPDATE yesno		{
			if ($2 == 0)
				currdom->flags |= F_RIB_NOFIBSYNC;
			else
				currdom->flags &= ~F_RIB_NOFIBSYNC;
		}
		| network
		| DEPEND ON STRING	{
			/* XXX this is a hack */
			if (if_nametoindex($3) == 0) {
				yyerror("interface %s does not exist", $3);
				free($3);
				YYERROR;
			}
			strlcpy(currdom->ifmpe, $3, IFNAMSIZ);
			free($3);
			if (get_mpe_label(currdom)) {
				yyerror("failed to get mpls label from %s",
				    currdom->ifmpe);
				YYERROR;
			}
		}
		;

neighbor	: {	curpeer = new_peer(); }
		    NEIGHBOR addrspec {
			memcpy(&curpeer->conf.remote_addr, &$3.prefix,
			    sizeof(curpeer->conf.remote_addr));
			curpeer->conf.remote_masklen = $3.len;
			if (($3.prefix.aid == AID_INET && $3.len != 32) ||
			    ($3.prefix.aid == AID_INET6 && $3.len != 128))
				curpeer->conf.template = 1;
			if (curpeer->conf.capabilities.mp[
			    curpeer->conf.remote_addr.aid] == -1)
				curpeer->conf.capabilities.mp[
				    curpeer->conf.remote_addr.aid] = 1;
			if (get_id(curpeer)) {
				yyerror("get_id failed");
				YYERROR;
			}
		}
		    peeropts_h {
			if (curpeer_filter[0] != NULL)
				TAILQ_INSERT_TAIL(peerfilter_l,
				    curpeer_filter[0], entry);
			if (curpeer_filter[1] != NULL)
				TAILQ_INSERT_TAIL(peerfilter_l,
				    curpeer_filter[1], entry);
			curpeer_filter[0] = NULL;
			curpeer_filter[1] = NULL;

			if (neighbor_consistent(curpeer) == -1)
				YYERROR;
			curpeer->next = peer_l;
			peer_l = curpeer;
			curpeer = curgroup;
		}
		;

group		: GROUP string optnl '{' optnl {
			curgroup = curpeer = new_group();
			if (strlcpy(curgroup->conf.group, $2,
			    sizeof(curgroup->conf.group)) >=
			    sizeof(curgroup->conf.group)) {
				yyerror("group name \"%s\" too long: max %zu",
				    $2, sizeof(curgroup->conf.group) - 1);
				free($2);
				YYERROR;
			}
			free($2);
			if (get_id(curgroup)) {
				yyerror("get_id failed");
				YYERROR;
			}
		}
		    groupopts_l '}' {
			if (curgroup_filter[0] != NULL)
				TAILQ_INSERT_TAIL(groupfilter_l,
				    curgroup_filter[0], entry);
			if (curgroup_filter[1] != NULL)
				TAILQ_INSERT_TAIL(groupfilter_l,
				    curgroup_filter[1], entry);
			curgroup_filter[0] = NULL;
			curgroup_filter[1] = NULL;

			free(curgroup);
			curgroup = NULL;
		}
		;

groupopts_l	: groupopts_l groupoptsl
		| groupoptsl
		;

groupoptsl	: peeropts nl
		| neighbor nl
		| error nl
		;

peeropts_h	: '{' optnl peeropts_l '}'
		| /* empty */
		;

peeropts_l	: peeropts_l peeroptsl
		| peeroptsl
		;

peeroptsl	: peeropts nl
		;

peeropts	: REMOTEAS as4number	{
			curpeer->conf.remote_as = $2;
		}
		| DESCR string		{
			if (strlcpy(curpeer->conf.descr, $2,
			    sizeof(curpeer->conf.descr)) >=
			    sizeof(curpeer->conf.descr)) {
				yyerror("descr \"%s\" too long: max %zu",
				    $2, sizeof(curpeer->conf.descr) - 1);
				free($2);
				YYERROR;
			}
			free($2);
		}
		| LOCALADDR address	{
			memcpy(&curpeer->conf.local_addr, &$2,
			    sizeof(curpeer->conf.local_addr));
		}
		| MULTIHOP NUMBER	{
			if ($2 < 2 || $2 > 255) {
				yyerror("invalid multihop distance %lld", $2);
				YYERROR;
			}
			curpeer->conf.distance = $2;
		}
		| PASSIVE		{
			curpeer->conf.passive = 1;
		}
		| DOWN			{
			curpeer->conf.down = 1;
		}
		| DOWN STRING		{
			curpeer->conf.down = 1;
			if (strlcpy(curpeer->conf.shutcomm, $2,
				sizeof(curpeer->conf.shutcomm)) >=
				sizeof(curpeer->conf.shutcomm)) {
				    yyerror("shutdown reason too long");
				    free($2);
				    YYERROR;
			}
			free($2);
		}
		| RIB STRING	{
			if (!find_rib($2)) {
				yyerror("rib \"%s\" does not exist.", $2);
				free($2);
				YYERROR;
			}
			if (strlcpy(curpeer->conf.rib, $2,
			    sizeof(curpeer->conf.rib)) >=
			    sizeof(curpeer->conf.rib)) {
				yyerror("rib name \"%s\" too long: max %zu",
				   $2, sizeof(curpeer->conf.rib) - 1);
				free($2);
				YYERROR;
			}
			free($2);
		}
		| HOLDTIME NUMBER	{
			if ($2 < MIN_HOLDTIME || $2 > USHRT_MAX) {
				yyerror("holdtime must be between %u and %u",
				    MIN_HOLDTIME, USHRT_MAX);
				YYERROR;
			}
			curpeer->conf.holdtime = $2;
		}
		| HOLDTIME YMIN NUMBER	{
			if ($3 < MIN_HOLDTIME || $3 > USHRT_MAX) {
				yyerror("holdtime must be between %u and %u",
				    MIN_HOLDTIME, USHRT_MAX);
				YYERROR;
			}
			curpeer->conf.min_holdtime = $3;
		}
		| ANNOUNCE family STRING {
			u_int8_t	aid, safi;
			int8_t		val = 1;

			if (!strcmp($3, "none")) {
				safi = SAFI_UNICAST;
				val = 0;
			} else if (!strcmp($3, "unicast")) {
				safi = SAFI_UNICAST;
			} else if (!strcmp($3, "vpn")) {
				safi = SAFI_MPLSVPN;
			} else {
				yyerror("unknown/unsupported SAFI \"%s\"",
				    $3);
				free($3);
				YYERROR;
			}
			free($3);

			if (afi2aid($2, safi, &aid) == -1) {
				yyerror("unknown AFI/SAFI pair");
				YYERROR;
			}
			curpeer->conf.capabilities.mp[aid] = val;
		}
		| ANNOUNCE CAPABILITIES yesno {
			curpeer->conf.announce_capa = $3;
		}
		| ANNOUNCE REFRESH yesno {
			curpeer->conf.capabilities.refresh = $3;
		}
		| ANNOUNCE RESTART yesno {
			curpeer->conf.capabilities.grestart.restart = $3;
		}
		| ANNOUNCE AS4BYTE yesno {
			curpeer->conf.capabilities.as4byte = $3;
		}
		| ANNOUNCE SELF {
			curpeer->conf.announce_type = ANNOUNCE_SELF;
		}
		| ANNOUNCE STRING {
			if (!strcmp($2, "self"))
				curpeer->conf.announce_type = ANNOUNCE_SELF;
			else if (!strcmp($2, "none"))
				curpeer->conf.announce_type = ANNOUNCE_NONE;
			else if (!strcmp($2, "all"))
				curpeer->conf.announce_type = ANNOUNCE_ALL;
			else if (!strcmp($2, "default-route"))
				curpeer->conf.announce_type =
				    ANNOUNCE_DEFAULT_ROUTE;
			else {
				yyerror("invalid announce type");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| ENFORCE NEIGHBORAS yesno {
			if ($3)
				curpeer->conf.enforce_as = ENFORCE_AS_ON;
			else
				curpeer->conf.enforce_as = ENFORCE_AS_OFF;
		}
		| MAXPREFIX NUMBER restart {
			if ($2 < 0 || $2 > UINT_MAX) {
				yyerror("bad maximum number of prefixes");
				YYERROR;
			}
			curpeer->conf.max_prefix = $2;
			curpeer->conf.max_prefix_restart = $3;
		}
		| TCP MD5SIG PASSWORD string {
			if (curpeer->conf.auth.method) {
				yyerror("auth method cannot be redefined");
				free($4);
				YYERROR;
			}
			if (strlcpy(curpeer->conf.auth.md5key, $4,
			    sizeof(curpeer->conf.auth.md5key)) >=
			    sizeof(curpeer->conf.auth.md5key)) {
				yyerror("tcp md5sig password too long: max %zu",
				    sizeof(curpeer->conf.auth.md5key) - 1);
				free($4);
				YYERROR;
			}
			curpeer->conf.auth.method = AUTH_MD5SIG;
			curpeer->conf.auth.md5key_len = strlen($4);
			free($4);
		}
		| TCP MD5SIG KEY string {
			if (curpeer->conf.auth.method) {
				yyerror("auth method cannot be redefined");
				free($4);
				YYERROR;
			}

			if (str2key($4, curpeer->conf.auth.md5key,
			    sizeof(curpeer->conf.auth.md5key)) == -1) {
				free($4);
				YYERROR;
			}
			curpeer->conf.auth.method = AUTH_MD5SIG;
			curpeer->conf.auth.md5key_len = strlen($4) / 2;
			free($4);
		}
		| IPSEC espah IKE {
			if (curpeer->conf.auth.method) {
				yyerror("auth method cannot be redefined");
				YYERROR;
			}
			if ($2)
				curpeer->conf.auth.method = AUTH_IPSEC_IKE_ESP;
			else
				curpeer->conf.auth.method = AUTH_IPSEC_IKE_AH;
		}
		| IPSEC espah inout SPI NUMBER STRING STRING encspec {
			u_int32_t	auth_alg;
			u_int8_t	keylen;

			if (curpeer->conf.auth.method &&
			    (((curpeer->conf.auth.spi_in && $3 == 1) ||
			    (curpeer->conf.auth.spi_out && $3 == 0)) ||
			    ($2 == 1 && curpeer->conf.auth.method !=
			    AUTH_IPSEC_MANUAL_ESP) ||
			    ($2 == 0 && curpeer->conf.auth.method !=
			    AUTH_IPSEC_MANUAL_AH))) {
				yyerror("auth method cannot be redefined");
				free($6);
				free($7);
				YYERROR;
			}

			if (!strcmp($6, "sha1")) {
				auth_alg = SADB_AALG_SHA1HMAC;
				keylen = 20;
			} else if (!strcmp($6, "md5")) {
				auth_alg = SADB_AALG_MD5HMAC;
				keylen = 16;
			} else {
				yyerror("unknown auth algorithm \"%s\"", $6);
				free($6);
				free($7);
				YYERROR;
			}
			free($6);

			if (strlen($7) / 2 != keylen) {
				yyerror("auth key len: must be %u bytes, "
				    "is %zu bytes", keylen, strlen($7) / 2);
				free($7);
				YYERROR;
			}

			if ($2)
				curpeer->conf.auth.method =
				    AUTH_IPSEC_MANUAL_ESP;
			else {
				if ($8.enc_alg) {
					yyerror("\"ipsec ah\" doesn't take "
					    "encryption keys");
					free($7);
					YYERROR;
				}
				curpeer->conf.auth.method =
				    AUTH_IPSEC_MANUAL_AH;
			}

			if ($5 <= SPI_RESERVED_MAX || $5 > UINT_MAX) {
				yyerror("bad spi number %lld", $5);
				free($7);
				YYERROR;
			}

			if ($3 == 1) {
				if (str2key($7, curpeer->conf.auth.auth_key_in,
				    sizeof(curpeer->conf.auth.auth_key_in)) ==
				    -1) {
					free($7);
					YYERROR;
				}
				curpeer->conf.auth.spi_in = $5;
				curpeer->conf.auth.auth_alg_in = auth_alg;
				curpeer->conf.auth.enc_alg_in = $8.enc_alg;
				memcpy(&curpeer->conf.auth.enc_key_in,
				    &$8.enc_key,
				    sizeof(curpeer->conf.auth.enc_key_in));
				curpeer->conf.auth.enc_keylen_in =
				    $8.enc_key_len;
				curpeer->conf.auth.auth_keylen_in = keylen;
			} else {
				if (str2key($7, curpeer->conf.auth.auth_key_out,
				    sizeof(curpeer->conf.auth.auth_key_out)) ==
				    -1) {
					free($7);
					YYERROR;
				}
				curpeer->conf.auth.spi_out = $5;
				curpeer->conf.auth.auth_alg_out = auth_alg;
				curpeer->conf.auth.enc_alg_out = $8.enc_alg;
				memcpy(&curpeer->conf.auth.enc_key_out,
				    &$8.enc_key,
				    sizeof(curpeer->conf.auth.enc_key_out));
				curpeer->conf.auth.enc_keylen_out =
				    $8.enc_key_len;
				curpeer->conf.auth.auth_keylen_out = keylen;
			}
			free($7);
		}
		| TTLSECURITY yesno	{
			curpeer->conf.ttlsec = $2;
		}
		| SET filter_set_opt	{
			struct filter_rule	*r;

			r = get_rule($2->type);
			if (merge_filterset(&r->set, $2) == -1)
				YYERROR;
		}
		| SET optnl "{" optnl filter_set_l optnl "}"	{
			struct filter_rule	*r;
			struct filter_set	*s;

			while ((s = TAILQ_FIRST($5)) != NULL) {
				TAILQ_REMOVE($5, s, entry);
				r = get_rule(s->type);
				if (merge_filterset(&r->set, s) == -1)
					YYERROR;
			}
			free($5);
		}
		| mrtdump
		| REFLECTOR		{
			if ((conf->flags & BGPD_FLAG_REFLECTOR) &&
			    conf->clusterid != 0) {
				yyerror("only one route reflector "
				    "cluster allowed");
				YYERROR;
			}
			conf->flags |= BGPD_FLAG_REFLECTOR;
			curpeer->conf.reflector_client = 1;
		}
		| REFLECTOR address	{
			if ($2.aid != AID_INET) {
				yyerror("route reflector cluster-id must be "
				    "an IPv4 address");
				YYERROR;
			}
			if ((conf->flags & BGPD_FLAG_REFLECTOR) &&
			    conf->clusterid != $2.v4.s_addr) {
				yyerror("only one route reflector "
				    "cluster allowed");
				YYERROR;
			}
			conf->flags |= BGPD_FLAG_REFLECTOR;
			curpeer->conf.reflector_client = 1;
			conf->clusterid = $2.v4.s_addr;
		}
		| DEPEND ON STRING	{
			if (strlcpy(curpeer->conf.if_depend, $3,
			    sizeof(curpeer->conf.if_depend)) >=
			    sizeof(curpeer->conf.if_depend)) {
				yyerror("interface name \"%s\" too long: "
				    "max %zu", $3,
				    sizeof(curpeer->conf.if_depend) - 1);
				free($3);
				YYERROR;
			}
			free($3);
		}
		| DEMOTE STRING		{
			if (strlcpy(curpeer->conf.demote_group, $2,
			    sizeof(curpeer->conf.demote_group)) >=
			    sizeof(curpeer->conf.demote_group)) {
				yyerror("demote group name \"%s\" too long: "
				    "max %zu", $2,
				    sizeof(curpeer->conf.demote_group) - 1);
				free($2);
				YYERROR;
			}
			free($2);
			if (carp_demote_init(curpeer->conf.demote_group,
			    cmd_opts & BGPD_OPT_FORCE_DEMOTE) == -1) {
				yyerror("error initializing group \"%s\"",
				    curpeer->conf.demote_group);
				YYERROR;
			}
		}
		| SOFTRECONFIG inout yesno {
			if ($2)
				curpeer->conf.softreconfig_in = $3;
			else
				curpeer->conf.softreconfig_out = $3;
		}
		| TRANSPARENT yesno	{
			if ($2 == 1)
				curpeer->conf.flags |= PEERFLAG_TRANS_AS;
			else
				curpeer->conf.flags &= ~PEERFLAG_TRANS_AS;
		}
		| LOG STRING		{
			if (!strcmp($2, "updates"))
				curpeer->conf.flags |= PEERFLAG_LOG_UPDATES;
			else if (!strcmp($2, "no"))
				curpeer->conf.flags &= ~PEERFLAG_LOG_UPDATES;
			else {
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

restart		: /* nada */		{ $$ = 0; }
		| RESTART NUMBER	{
			if ($2 < 1 || $2 > USHRT_MAX) {
				yyerror("restart out of range. 1 to %u minutes",
				    USHRT_MAX);
				YYERROR;
			}
			$$ = $2;
		}
		;

family		: IPV4	{ $$ = AFI_IPv4; }
		| IPV6	{ $$ = AFI_IPv6; }
		;

nettype		: STATIC { $$ = 1; },
		| CONNECTED { $$ = 0; }
		;

espah		: ESP		{ $$ = 1; }
		| AH		{ $$ = 0; }
		;

encspec		: /* nada */	{
			bzero(&$$, sizeof($$));
		}
		| STRING STRING {
			bzero(&$$, sizeof($$));
			if (!strcmp($1, "3des") || !strcmp($1, "3des-cbc")) {
				$$.enc_alg = SADB_EALG_3DESCBC;
				$$.enc_key_len = 21; /* XXX verify */
			} else if (!strcmp($1, "aes") ||
			    !strcmp($1, "aes-128-cbc")) {
				$$.enc_alg = SADB_X_EALG_AES;
				$$.enc_key_len = 16;
			} else {
				yyerror("unknown enc algorithm \"%s\"", $1);
				free($1);
				free($2);
				YYERROR;
			}
			free($1);

			if (strlen($2) / 2 != $$.enc_key_len) {
				yyerror("enc key length wrong: should be %u "
				    "bytes, is %zu bytes",
				    $$.enc_key_len * 2, strlen($2));
				free($2);
				YYERROR;
			}

			if (str2key($2, $$.enc_key, sizeof($$.enc_key)) == -1) {
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

filterrule	: action quick filter_rib_h direction filter_peer_h filter_match_h filter_set
		{
			struct filter_rule	 r;
			struct filter_rib_l	 *rb, *rbnext;

			bzero(&r, sizeof(r));
			r.action = $1;
			r.quick = $2;
			r.dir = $4;
			if ($3) {
				if (r.dir != DIR_IN) {
					yyerror("rib only allowed on \"from\" "
					    "rules.");

					for (rb = $3; rb != NULL; rb = rbnext) {
						rbnext = rb->next;
						free(rb);
					}
					YYERROR;
				}
			}
			if (expand_rule(&r, $3, $5, &$6, $7) == -1)
				YYERROR;
		}
		;

action		: ALLOW		{ $$ = ACTION_ALLOW; }
		| DENY		{ $$ = ACTION_DENY; }
		| MATCH		{ $$ = ACTION_NONE; }
		;

quick		: /* empty */	{ $$ = 0; }
		| QUICK		{ $$ = 1; }
		;

direction	: FROM		{ $$ = DIR_IN; }
		| TO		{ $$ = DIR_OUT; }
		;

filter_rib_h	: /* empty */			{ $$ = NULL; }
		| RIB filter_rib		{ $$ = $2; }
		| RIB '{' filter_rib_l '}'	{ $$ = $3; }

filter_rib_l	: filter_rib			{ $$ = $1; }
		| filter_rib_l comma filter_rib	{
			$3->next = $1;
			$$ = $3;
		}
		;

filter_rib	: STRING	{
			if (!find_rib($1)) {
				yyerror("rib \"%s\" does not exist.", $1);
				free($1);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_rib_l))) ==
			    NULL)
				fatal(NULL);
			$$->next = NULL;
			if (strlcpy($$->name, $1, sizeof($$->name)) >=
			    sizeof($$->name)) {
				yyerror("rib name \"%s\" too long: "
				    "max %zu", $1, sizeof($$->name) - 1);
				free($1);
				free($$);
				YYERROR;
			}
			free($1);
		}
		;

filter_peer_h	: filter_peer
		| '{' filter_peer_l '}'		{ $$ = $2; }
		;

filter_peer_l	: filter_peer				{ $$ = $1; }
		| filter_peer_l comma filter_peer	{
			$3->next = $1;
			$$ = $3;
		}
		;

filter_peer	: ANY		{
			if (($$ = calloc(1, sizeof(struct filter_peers_l))) ==
			    NULL)
				fatal(NULL);
			$$->p.peerid = $$->p.groupid = 0;
			$$->next = NULL;
		}
		| address	{
			struct peer *p;

			if (($$ = calloc(1, sizeof(struct filter_peers_l))) ==
			    NULL)
				fatal(NULL);
			$$->p.remote_as = $$->p.groupid = $$->p.peerid = 0;
			$$->next = NULL;
			for (p = peer_l; p != NULL; p = p->next)
				if (!memcmp(&p->conf.remote_addr,
				    &$1, sizeof(p->conf.remote_addr))) {
					$$->p.peerid = p->conf.id;
					break;
				}
			if ($$->p.peerid == 0) {
				yyerror("no such peer: %s", log_addr(&$1));
				free($$);
				YYERROR;
			}
		}
 		| AS as4number	{
			if (($$ = calloc(1, sizeof(struct filter_peers_l))) ==
			    NULL)
				fatal(NULL);
			$$->p.groupid = $$->p.peerid = 0;
			$$->p.remote_as = $2;
		}
		| GROUP STRING	{
			struct peer *p;

			if (($$ = calloc(1, sizeof(struct filter_peers_l))) ==
			    NULL)
				fatal(NULL);
			$$->p.remote_as = $$->p.peerid = 0;
			$$->next = NULL;
			for (p = peer_l; p != NULL; p = p->next)
				if (!strcmp(p->conf.group, $2)) {
					$$->p.groupid = p->conf.groupid;
					break;
				}
			if ($$->p.groupid == 0) {
				yyerror("no such group: \"%s\"", $2);
				free($2);
				free($$);
				YYERROR;
			}
			free($2);
		}
		;

filter_prefix_h	: IPV4 prefixlenop			 {
			if ($2.op == OP_NONE)
				$2.op = OP_GE;
			if (($$ = calloc(1, sizeof(struct filter_prefix_l))) ==
			    NULL)
				fatal(NULL);
			$$->p.addr.aid = AID_INET;
			if (merge_prefixspec($$, &$2) == -1) {
				free($$);
				YYERROR;
			}
		}
		| IPV6 prefixlenop			{
			if ($2.op == OP_NONE)
				$2.op = OP_GE;
			if (($$ = calloc(1, sizeof(struct filter_prefix_l))) ==
			    NULL)
				fatal(NULL);
			$$->p.addr.aid = AID_INET6;
			if (merge_prefixspec($$, &$2) == -1) {
				free($$);
				YYERROR;
			}
		}
		| PREFIX filter_prefix			{ $$ = $2; }
		| PREFIX '{' filter_prefix_m '}'	{ $$ = $3; }
		;

filter_prefix_m	: filter_prefix_l
		| '{' filter_prefix_l '}'		{ $$ = $2; }
		| '{' filter_prefix_l '}' filter_prefix_m
		{
			struct filter_prefix_l  *p;

			/* merge, both can be lists */
			for (p = $2; p != NULL && p->next != NULL; p = p->next)
				;       /* nothing */
			if (p != NULL)
				p->next = $4;
			$$ = $2;
		} 

filter_prefix_l	: filter_prefix				{ $$ = $1; }
		| filter_prefix_l comma filter_prefix	{
			$3->next = $1;
			$$ = $3;
		}
		;

filter_prefix	: prefix prefixlenop			{
			if (($$ = calloc(1, sizeof(struct filter_prefix_l))) ==
			    NULL)
				fatal(NULL);
			memcpy(&$$->p.addr, &$1.prefix,
			    sizeof($$->p.addr));
			$$->p.len = $1.len;

			if (merge_prefixspec($$, &$2) == -1) {
				free($$);
				YYERROR;
			}
		}
		;

filter_as_h	: filter_as_t
		| '{' filter_as_t_l '}'		{ $$ = $2; }
		;

filter_as_t_l	: filter_as_t
		| filter_as_t_l comma filter_as_t		{
			struct filter_as_l	*a;

			/* merge, both can be lists */
			for (a = $1; a != NULL && a->next != NULL; a = a->next)
				;	/* nothing */
			if (a != NULL)
				a->next = $3;
			$$ = $1;
		}
		;

filter_as_t	: filter_as_type filter_as			{
			$$ = $2;
			$$->a.type = $1;
		}
		| filter_as_type '{' filter_as_l_h '}'	{
			struct filter_as_l	*a;

			$$ = $3;
			for (a = $$; a != NULL; a = a->next)
				a->a.type = $1;
		}
		;

filter_as_l_h	: filter_as_l
		| '{' filter_as_l '}'			{ $$ = $2; }
		| '{' filter_as_l '}' filter_as_l_h
		{
			struct filter_as_l	*a;

			/* merge, both can be lists */
			for (a = $2; a != NULL && a->next != NULL; a = a->next)
				;	/* nothing */
			if (a != NULL)
				a->next = $4;
			$$ = $2;
		}
		;

filter_as_l	: filter_as
		| filter_as_l comma filter_as	{
			$3->next = $1;
			$$ = $3;
		}
		;

filter_as	: as4number_any		{
			if (($$ = calloc(1, sizeof(struct filter_as_l))) ==
			    NULL)
				fatal(NULL);
			$$->a.as = $1;
			$$->a.op = OP_EQ;
		}
		| NEIGHBORAS		{
			if (($$ = calloc(1, sizeof(struct filter_as_l))) ==
			    NULL)
				fatal(NULL);
			$$->a.flags = AS_FLAG_NEIGHBORAS;
		}
		| equalityop as4number_any	{
			if (($$ = calloc(1, sizeof(struct filter_as_l))) ==
			    NULL)
				fatal(NULL);
			$$->a.op = $1;
			$$->a.as = $2;
		}
		| as4number_any binaryop as4number_any {
			if (($$ = calloc(1, sizeof(struct filter_as_l))) ==
			    NULL)
				fatal(NULL);
			if ($1 >= $3) {
				yyerror("start AS is bigger than end");
				YYERROR;
			}
			$$->a.op = $2;
			$$->a.as_min = $1;
			$$->a.as_max = $3;
		}
		;

filter_match_h	: /* empty */			{
			bzero(&$$, sizeof($$));
			$$.m.community.as = COMMUNITY_UNSET;
			$$.m.large_community.as = COMMUNITY_UNSET;
		}
		| {
			bzero(&fmopts, sizeof(fmopts));
			fmopts.m.community.as = COMMUNITY_UNSET;
			fmopts.m.large_community.as = COMMUNITY_UNSET;
		}
		    filter_match		{
			memcpy(&$$, &fmopts, sizeof($$));
		}
		;

filter_match	: filter_elm
		| filter_match filter_elm
		;

filter_elm	: filter_prefix_h	{
			if (fmopts.prefix_l != NULL) {
				yyerror("\"prefix\" already specified");
				YYERROR;
			}
			fmopts.prefix_l = $1;
		}
		| filter_as_h		{
			if (fmopts.as_l != NULL) {
				yyerror("AS filters already specified");
				YYERROR;
			}
			fmopts.as_l = $1;
		}
		| MAXASLEN NUMBER	{
			if (fmopts.m.aslen.type != ASLEN_NONE) {
				yyerror("AS length filters already specified");
				YYERROR;
			}
			if ($2 < 0 || $2 > UINT_MAX) {
				yyerror("bad max-as-len %lld", $2);
				YYERROR;
			}
			fmopts.m.aslen.type = ASLEN_MAX;
			fmopts.m.aslen.aslen = $2;
		}
		| MAXASSEQ NUMBER	{
			if (fmopts.m.aslen.type != ASLEN_NONE) {
				yyerror("AS length filters already specified");
				YYERROR;
			}
			if ($2 < 0 || $2 > UINT_MAX) {
				yyerror("bad max-as-seq %lld", $2);
				YYERROR;
			}
			fmopts.m.aslen.type = ASLEN_SEQ;
			fmopts.m.aslen.aslen = $2;
		}
		| COMMUNITY STRING	{
			if (fmopts.m.community.as != COMMUNITY_UNSET) {
				yyerror("\"community\" already specified");
				free($2);
				YYERROR;
			}
			if (parsecommunity(&fmopts.m.community, $2) == -1) {
				free($2);
				YYERROR;
			}
			free($2);
		}
		| LARGECOMMUNITY STRING	{
			if (fmopts.m.large_community.as != COMMUNITY_UNSET) {
				yyerror("\"large-community\" already specified");
				free($2);
				YYERROR;
			}
			if (parselargecommunity(&fmopts.m.large_community, $2) == -1) {
				free($2);
				YYERROR;
			}
			free($2);
		}
		| EXTCOMMUNITY STRING STRING {
			if (fmopts.m.ext_community.flags &
			    EXT_COMMUNITY_FLAG_VALID) {
				yyerror("\"ext-community\" already specified");
				free($2);
				free($3);
				YYERROR;
			}

			if (parseextcommunity(&fmopts.m.ext_community,
			    $2, $3) == -1) {
				free($2);
				free($3);
				YYERROR;
			}
			free($2);
			free($3);
		}
		| NEXTHOP address 	{
			if (fmopts.m.nexthop.flags) {
				yyerror("nexthop already specified");
				YYERROR;
			}
			fmopts.m.nexthop.addr = $2;
			fmopts.m.nexthop.flags = FILTER_NEXTHOP_ADDR;
		}
		| NEXTHOP NEIGHBOR 	{
			if (fmopts.m.nexthop.flags) {
				yyerror("nexthop already specified");
				YYERROR;
			}
			fmopts.m.nexthop.flags = FILTER_NEXTHOP_NEIGHBOR;
		}
		;

prefixlenop	: /* empty */			{ bzero(&$$, sizeof($$)); }
		| LONGER				{
			bzero(&$$, sizeof($$));
			$$.op = OP_GE;
			$$.len_min = -1;
		}
		| PREFIXLEN unaryop NUMBER		{
			bzero(&$$, sizeof($$));
			if ($3 < 0 || $3 > 128) {
				yyerror("prefixlen must be >= 0 and <= 128");
				YYERROR;
			}
			if ($2 == OP_GT && $3 == 0) {
				yyerror("prefixlen must be > 0");
				YYERROR;
			}
			$$.op = $2;
			$$.len_min = $3;
		}
		| PREFIXLEN NUMBER binaryop NUMBER	{
			bzero(&$$, sizeof($$));
			if ($2 < 0 || $2 > 128 || $4 < 0 || $4 > 128) {
				yyerror("prefixlen must be < 128");
				YYERROR;
			}
			if ($2 >= $4) {
				yyerror("start prefixlen is bigger than end");
				YYERROR;
			}
			$$.op = $3;
			$$.len_min = $2;
			$$.len_max = $4;
		}
		;

filter_as_type	: AS		{ $$ = AS_ALL; }
		| SOURCEAS	{ $$ = AS_SOURCE; }
		| TRANSITAS	{ $$ = AS_TRANSIT; }
		| PEERAS	{ $$ = AS_PEER; }
		;

filter_set	: /* empty */					{ $$ = NULL; }
		| SET filter_set_opt				{
			if (($$ = calloc(1, sizeof(struct filter_set_head))) ==
			    NULL)
				fatal(NULL);
			TAILQ_INIT($$);
			TAILQ_INSERT_TAIL($$, $2, entry);
		}
		| SET optnl "{" optnl filter_set_l optnl "}"	{ $$ = $5; }
		;

filter_set_l	: filter_set_l comma filter_set_opt	{
			$$ = $1;
			if (merge_filterset($$, $3) == 1)
				YYERROR;
		}
		| filter_set_opt {
			if (($$ = calloc(1, sizeof(struct filter_set_head))) ==
			    NULL)
				fatal(NULL);
			TAILQ_INIT($$);
			TAILQ_INSERT_TAIL($$, $1, entry);
		}
		;

delete		: /* empty */	{ $$ = 0; }
		| DELETE	{ $$ = 1; }
		;

filter_set_opt	: LOCALPREF NUMBER		{
			if ($2 < -INT_MAX || $2 > UINT_MAX) {
				yyerror("bad localpref %lld", $2);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			if ($2 > 0) {
				$$->type = ACTION_SET_LOCALPREF;
				$$->action.metric = $2;
			} else {
				$$->type = ACTION_SET_RELATIVE_LOCALPREF;
				$$->action.relative = $2;
			}
		}
		| LOCALPREF '+' NUMBER		{
			if ($3 < 0 || $3 > INT_MAX) {
				yyerror("bad localpref +%lld", $3);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_RELATIVE_LOCALPREF;
			$$->action.relative = $3;
		}
		| LOCALPREF '-' NUMBER		{
			if ($3 < 0 || $3 > INT_MAX) {
				yyerror("bad localpref -%lld", $3);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_RELATIVE_LOCALPREF;
			$$->action.relative = -$3;
		}
		| MED NUMBER			{
			if ($2 < -INT_MAX || $2 > UINT_MAX) {
				yyerror("bad metric %lld", $2);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			if ($2 >= 0) {
				$$->type = ACTION_SET_MED;
				$$->action.metric = $2;
			} else {
				$$->type = ACTION_SET_RELATIVE_MED;
				$$->action.relative = $2;
			}
		}
		| MED '+' NUMBER			{
			if ($3 < 0 || $3 > INT_MAX) {
				yyerror("bad metric +%lld", $3);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_RELATIVE_MED;
			$$->action.relative = $3;
		}
		| MED '-' NUMBER			{
			if ($3 < 0 || $3 > INT_MAX) {
				yyerror("bad metric -%lld", $3);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_RELATIVE_MED;
			$$->action.relative = -$3;
		}
		| METRIC NUMBER			{	/* alias for MED */
			if ($2 < -INT_MAX || $2 > UINT_MAX) {
				yyerror("bad metric %lld", $2);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			if ($2 >= 0) {
				$$->type = ACTION_SET_MED;
				$$->action.metric = $2;
			} else {
				$$->type = ACTION_SET_RELATIVE_MED;
				$$->action.relative = $2;
			}
		}
		| METRIC '+' NUMBER			{
			if ($3 < 0 || $3 > INT_MAX) {
				yyerror("bad metric +%lld", $3);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_RELATIVE_MED;
			$$->action.metric = $3;
		}
		| METRIC '-' NUMBER			{
			if ($3 < 0 || $3 > INT_MAX) {
				yyerror("bad metric -%lld", $3);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_RELATIVE_MED;
			$$->action.relative = -$3;
		}
		| WEIGHT NUMBER				{
			if ($2 < -INT_MAX || $2 > UINT_MAX) {
				yyerror("bad weight %lld", $2);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			if ($2 > 0) {
				$$->type = ACTION_SET_WEIGHT;
				$$->action.metric = $2;
			} else {
				$$->type = ACTION_SET_RELATIVE_WEIGHT;
				$$->action.relative = $2;
			}
		}
		| WEIGHT '+' NUMBER			{
			if ($3 < 0 || $3 > INT_MAX) {
				yyerror("bad weight +%lld", $3);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_RELATIVE_WEIGHT;
			$$->action.relative = $3;
		}
		| WEIGHT '-' NUMBER			{
			if ($3 < 0 || $3 > INT_MAX) {
				yyerror("bad weight -%lld", $3);
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_RELATIVE_WEIGHT;
			$$->action.relative = -$3;
		}
		| NEXTHOP address		{
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_NEXTHOP;
			memcpy(&$$->action.nexthop, &$2,
			    sizeof($$->action.nexthop));
		}
		| NEXTHOP BLACKHOLE		{
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_NEXTHOP_BLACKHOLE;
		}
		| NEXTHOP REJECT		{
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_NEXTHOP_REJECT;
		}
		| NEXTHOP NOMODIFY		{
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_NEXTHOP_NOMODIFY;
		}
		| NEXTHOP SELF		{
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_NEXTHOP_SELF;
		}
		| PREPEND_SELF NUMBER		{
			if ($2 < 0 || $2 > 128) {
				yyerror("bad number of prepends");
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_PREPEND_SELF;
			$$->action.prepend = $2;
		}
		| PREPEND_PEER NUMBER		{
			if ($2 < 0 || $2 > 128) {
				yyerror("bad number of prepends");
				YYERROR;
			}
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_PREPEND_PEER;
			$$->action.prepend = $2;
		}
		| PFTABLE STRING		{
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_PFTABLE;
			if (!(cmd_opts & BGPD_OPT_NOACTION) &&
			    pftable_exists($2) != 0) {
				yyerror("pftable name does not exist");
				free($2);
				free($$);
				YYERROR;
			}
			if (strlcpy($$->action.pftable, $2,
			    sizeof($$->action.pftable)) >=
			    sizeof($$->action.pftable)) {
				yyerror("pftable name too long");
				free($2);
				free($$);
				YYERROR;
			}
			if (pftable_add($2) != 0) {
				yyerror("Couldn't register table");
				free($2);
				free($$);
				YYERROR;
			}
			free($2);
		}
		| RTLABEL STRING		{
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_RTLABEL;
			if (strlcpy($$->action.rtlabel, $2,
			    sizeof($$->action.rtlabel)) >=
			    sizeof($$->action.rtlabel)) {
				yyerror("rtlabel name too long");
				free($2);
				free($$);
				YYERROR;
			}
			free($2);
		}
		| COMMUNITY delete STRING	{
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			if ($2)
				$$->type = ACTION_DEL_COMMUNITY;
			else
				$$->type = ACTION_SET_COMMUNITY;

			if (parsecommunity(&$$->action.community, $3) == -1) {
				free($3);
				free($$);
				YYERROR;
			}
			free($3);
			/* Don't allow setting of any match */
			if (!$2 && ($$->action.community.as == COMMUNITY_ANY ||
			    $$->action.community.type == COMMUNITY_ANY)) {
				yyerror("'*' is not allowed in set community");
				free($$);
				YYERROR;
			}
		}
		| LARGECOMMUNITY delete STRING	{
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			if ($2)
				$$->type = ACTION_DEL_LARGE_COMMUNITY;
			else
				$$->type = ACTION_SET_LARGE_COMMUNITY;

			if (parselargecommunity(&$$->action.large_community,
			    $3) == -1) {
				free($3);
				free($$);
				YYERROR;
			}
			free($3);
			/* Don't allow setting of any match */
			if (!$2 &&
			    ($$->action.large_community.as == COMMUNITY_ANY ||
			    $$->action.large_community.ld1 == COMMUNITY_ANY ||
			    $$->action.large_community.ld2 == COMMUNITY_ANY)) {
				yyerror("'*' is not allowed in set community");
				free($$);
				YYERROR;
			}
		}
		| EXTCOMMUNITY delete STRING STRING {
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			if ($2)
				$$->type = ACTION_DEL_EXT_COMMUNITY;
			else
				$$->type = ACTION_SET_EXT_COMMUNITY;

			if (parseextcommunity(&$$->action.ext_community,
			    $3, $4) == -1) {
				free($3);
				free($4);
				free($$);
				YYERROR;
			}
			free($3);
			free($4);
		}
		| ORIGIN origincode {
			if (($$ = calloc(1, sizeof(struct filter_set))) == NULL)
				fatal(NULL);
			$$->type = ACTION_SET_ORIGIN;
			$$->action.origin = $2;
		}
		;

origincode	: string {
			if (!strcmp($1, "egp"))
				$$ = ORIGIN_EGP;
			else if (!strcmp($1, "igp"))
				$$ = ORIGIN_IGP;
			else if (!strcmp($1, "incomplete"))
				$$ = ORIGIN_INCOMPLETE;
			else {
				yyerror("unknown origin \"%s\"", $1);
				free($1);
				YYERROR;
			}
			free($1);
		};

comma		: ","
		| /* empty */
		;

unaryop		: '='		{ $$ = OP_EQ; }
		| NE		{ $$ = OP_NE; }
		| LE		{ $$ = OP_LE; }
		| '<'		{ $$ = OP_LT; }
		| GE		{ $$ = OP_GE; }
		| '>'		{ $$ = OP_GT; }
		;

equalityop	: '='		{ $$ = OP_EQ; }
		| NE		{ $$ = OP_NE; }
		;

binaryop	: '-'		{ $$ = OP_RANGE; }
		| XRANGE	{ $$ = OP_XRANGE; }
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "AS",			AS},
		{ "IPv4",		IPV4},
		{ "IPv6",		IPV6},
		{ "ah",			AH},
		{ "allow",		ALLOW},
		{ "announce",		ANNOUNCE},
		{ "any",		ANY},
		{ "as-4byte",		AS4BYTE },
		{ "blackhole",		BLACKHOLE},
		{ "capabilities",	CAPABILITIES},
		{ "community",		COMMUNITY},
		{ "compare",		COMPARE},
		{ "connect-retry",	CONNECTRETRY},
		{ "connected",		CONNECTED},
		{ "delete",		DELETE},
		{ "demote",		DEMOTE},
		{ "deny",		DENY},
		{ "depend",		DEPEND},
		{ "descr",		DESCR},
		{ "down",		DOWN},
		{ "dump",		DUMP},
		{ "enforce",		ENFORCE},
		{ "esp",		ESP},
		{ "evaluate",		EVALUATE},
		{ "export-target",	EXPORTTRGT},
		{ "ext-community",	EXTCOMMUNITY},
		{ "fib-priority",	FIBPRIORITY},
		{ "fib-update",		FIBUPDATE},
		{ "from",		FROM},
		{ "group",		GROUP},
		{ "holdtime",		HOLDTIME},
		{ "ignore",		IGNORE},
		{ "ike",		IKE},
		{ "import-target",	IMPORTTRGT},
		{ "in",			IN},
		{ "include",		INCLUDE},
		{ "inet",		IPV4},
		{ "inet6",		IPV6},
		{ "ipsec",		IPSEC},
		{ "key",		KEY},
		{ "large-community",	LARGECOMMUNITY},
		{ "listen",		LISTEN},
		{ "local-address",	LOCALADDR},
		{ "localpref",		LOCALPREF},
		{ "log",		LOG},
		{ "match",		MATCH},
		{ "max-as-len",		MAXASLEN},
		{ "max-as-seq",		MAXASSEQ},
		{ "max-prefix",		MAXPREFIX},
		{ "md5sig",		MD5SIG},
		{ "med",		MED},
		{ "metric",		METRIC},
		{ "min",		YMIN},
		{ "multihop",		MULTIHOP},
		{ "neighbor",		NEIGHBOR},
		{ "neighbor-as",	NEIGHBORAS},
		{ "network",		NETWORK},
		{ "nexthop",		NEXTHOP},
		{ "no-modify",		NOMODIFY},
		{ "on",			ON},
		{ "or-longer",		LONGER},
		{ "origin",		ORIGIN},
		{ "out",		OUT},
		{ "passive",		PASSIVE},
		{ "password",		PASSWORD},
		{ "peer-as",		PEERAS},
		{ "pftable",		PFTABLE},
		{ "prefix",		PREFIX},
		{ "prefixlen",		PREFIXLEN},
		{ "prepend-neighbor",	PREPEND_PEER},
		{ "prepend-self",	PREPEND_SELF},
		{ "qualify",		QUALIFY},
		{ "quick",		QUICK},
		{ "rd",			RD},
		{ "rde",		RDE},
		{ "rdomain",		RDOMAIN},
		{ "refresh",		REFRESH },
		{ "reject",		REJECT},
		{ "remote-as",		REMOTEAS},
		{ "restart",		RESTART},
		{ "restricted",		RESTRICTED},
		{ "rib",		RIB},
		{ "route-collector",	ROUTECOLL},
		{ "route-reflector",	REFLECTOR},
		{ "router-id",		ROUTERID},
		{ "rtable",		RTABLE},
		{ "rtlabel",		RTLABEL},
		{ "self",		SELF},
		{ "set",		SET},
		{ "socket",		SOCKET },
		{ "softreconfig",	SOFTRECONFIG},
		{ "source-as",		SOURCEAS},
		{ "spi",		SPI},
		{ "static",		STATIC},
		{ "tcp",		TCP},
		{ "to",			TO},
		{ "transit-as",		TRANSITAS},
		{ "transparent-as",	TRANSPARENT},
		{ "ttl-security",	TTLSECURITY},
		{ "via",		VIA},
		{ "weight",		WEIGHT}
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			fatal("yylex: strdup");
		return (STRING);
	case '!':
		next = lgetc(0);
		if (next == '=')
			return (NE);
		lungetc(next);
		break;
	case '<':
		next = lgetc(0);
		if (next == '=')
			return (LE);
		lungetc(next);
		break;
	case '>':
		next = lgetc(0);
		if (next == '<')
			return (XRANGE);
		else if (next == '=')
			return (GE);
		lungetc(next);
		break;
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '/' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_' || c == '*') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				fatal("yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		log_warnx("%s: group writable or world read/writeable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("malloc");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

int
parse_config(char *filename, struct bgpd_config *xconf, struct peer **xpeers)
{
	struct sym		*sym, *next;
	struct peer		*p, *pnext;
	struct rde_rib		*rr;
	int			 errors = 0;

	conf = new_config();

	if ((filter_l = calloc(1, sizeof(struct filter_head))) == NULL)
		fatal(NULL);
	if ((peerfilter_l = calloc(1, sizeof(struct filter_head))) == NULL)
		fatal(NULL);
	if ((groupfilter_l = calloc(1, sizeof(struct filter_head))) == NULL)
		fatal(NULL);
	TAILQ_INIT(filter_l);
	TAILQ_INIT(peerfilter_l);
	TAILQ_INIT(groupfilter_l);

	peer_l = NULL;
	peer_l_old = *xpeers;
	curpeer = NULL;
	curgroup = NULL;
	id = 1;

	netconf = &conf->networks;

	add_rib("Adj-RIB-In", 0, F_RIB_NOFIB | F_RIB_NOEVALUATE);
	add_rib("Loc-RIB", 0, F_RIB_LOCAL);

	if ((file = pushfile(filename, 1)) == NULL) {
		free(conf);
		return (-1);
	}
	topfile = file;

	yyparse();
	errors = file->errors;
	popfile();

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if ((cmd_opts & BGPD_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro \"%s\" not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	if (errors) {
		for (p = peer_l; p != NULL; p = pnext) {
			pnext = p->next;
			free(p);
		}

		while ((rr = SIMPLEQ_FIRST(&ribnames)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&ribnames, entry);
			free(rr);
		}

		filterlist_free(filter_l);
		filterlist_free(peerfilter_l);
		filterlist_free(groupfilter_l);

		free_config(conf);
	} else {
		/*
		 * Move filter list and static group and peer filtersets
		 * together. Static group sets come first then peer sets
		 * last normal filter rules.
		 */
		merge_filter_lists(conf->filters, groupfilter_l);
		merge_filter_lists(conf->filters, peerfilter_l);
		merge_filter_lists(conf->filters, filter_l);

		errors += mrt_mergeconfig(xconf->mrt, conf->mrt);
		errors += merge_config(xconf, conf, peer_l);
		*xpeers = peer_l;

		for (p = peer_l_old; p != NULL; p = pnext) {
			pnext = p->next;
			free(p);
		}

		free(filter_l);
		free(peerfilter_l);
		free(groupfilter_l);
	}

	return (errors ? -1 : 0);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		fatal("cmdline_symset: malloc");

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

int
getcommunity(char *s)
{
	int		 val;
	const char	*errstr;

	if (strcmp(s, "*") == 0)
		return (COMMUNITY_ANY);
	if (strcmp(s, "neighbor-as") == 0)
		return (COMMUNITY_NEIGHBOR_AS);
	val = strtonum(s, 0, USHRT_MAX, &errstr);
	if (errstr) {
		yyerror("Community %s is %s (max: %u)", s, errstr, USHRT_MAX);
		return (COMMUNITY_ERROR);
	}
	return (val);
}

int
parsecommunity(struct filter_community *c, char *s)
{
	char *p;
	int i, as;

	/* Well-known communities */
	if (strcasecmp(s, "NO_EXPORT") == 0) {
		c->as = COMMUNITY_WELLKNOWN;
		c->type = COMMUNITY_NO_EXPORT;
		return (0);
	} else if (strcasecmp(s, "NO_ADVERTISE") == 0) {
		c->as = COMMUNITY_WELLKNOWN;
		c->type = COMMUNITY_NO_ADVERTISE;
		return (0);
	} else if (strcasecmp(s, "NO_EXPORT_SUBCONFED") == 0) {
		c->as = COMMUNITY_WELLKNOWN;
		c->type = COMMUNITY_NO_EXPSUBCONFED;
		return (0);
	} else if (strcasecmp(s, "NO_PEER") == 0) {
		c->as = COMMUNITY_WELLKNOWN;
		c->type = COMMUNITY_NO_PEER;
		return (0);
	} else if (strcasecmp(s, "BLACKHOLE") == 0) {
		c->as = COMMUNITY_WELLKNOWN;
		c->type = COMMUNITY_BLACKHOLE;
		return (0);
	}

	if ((p = strchr(s, ':')) == NULL) {
		yyerror("Bad community syntax");
		return (-1);
	}
	*p++ = 0;

	if ((i = getcommunity(s)) == COMMUNITY_ERROR)
		return (-1);
	if (i == COMMUNITY_WELLKNOWN) {
		yyerror("Bad community AS number");
		return (-1);
	}
	as = i;

	if ((i = getcommunity(p)) == COMMUNITY_ERROR)
		return (-1);
	c->as = as;
	c->type = i;

	return (0);
}

int64_t
getlargecommunity(char *s)
{
	u_int		 val;
	const char	*errstr;

	if (strcmp(s, "*") == 0)
		return (COMMUNITY_ANY);
	if (strcmp(s, "neighbor-as") == 0)
		return (COMMUNITY_NEIGHBOR_AS);
	val = strtonum(s, 0, UINT_MAX, &errstr);
	if (errstr) {
		yyerror("Large Community %s is %s (max: %u)",
		    s, errstr, UINT_MAX);
		return (COMMUNITY_ERROR);
	}
	return (val);
}

int
parselargecommunity(struct filter_largecommunity *c, char *s)
{
	char *p, *q;
	int64_t as, ld1, ld2;

	if ((p = strchr(s, ':')) == NULL) {
		yyerror("Bad community syntax");
		return (-1);
	}
	*p++ = 0;

	if ((q = strchr(p, ':')) == NULL) {
		yyerror("Bad community syntax");
		return (-1);
	}
	*q++ = 0;

	if ((as = getlargecommunity(s)) == COMMUNITY_ERROR)
		return (-1);

	if ((ld1 = getlargecommunity(p)) == COMMUNITY_ERROR)
		return (-1);

	if ((ld2 = getlargecommunity(q)) == COMMUNITY_ERROR)
		return (-1);

	c->as = as;
	c->ld1 = ld1;
	c->ld2 = ld2;

	return (0);
}

int
parsesubtype(char *type)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "bdc",	EXT_COMMUNITY_BGP_COLLECT },
		{ "odi",	EXT_COMMUNITY_OSPF_DOM_ID },
		{ "ori",	EXT_COMMUNITY_OSPF_RTR_ID },
		{ "ort",	EXT_COMMUNITY_OSPF_RTR_TYPE },
		{ "rt",		EXT_COMMUNITY_ROUTE_TGT },
		{ "soo",	EXT_COMMUNITY_ROUTE_ORIG }
	};
	const struct keywords	*p;

	p = bsearch(type, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (-1);
}

int
parseextvalue(char *s, u_int32_t *v)
{
	const char 	*errstr;
	char		*p;
	struct in_addr	 ip;
	u_int32_t	 uvalh = 0, uval;

	if ((p = strchr(s, '.')) == NULL) {
		/* AS_PLAIN number (4 or 2 byte) */
		uval = strtonum(s, 0, UINT_MAX, &errstr);
		if (errstr) {
			yyerror("Bad ext-community %s is %s", s, errstr);
			return (-1);
		}
		*v = uval;
		if (uval > USHRT_MAX)
			return (EXT_COMMUNITY_FOUR_AS);
		else
			return (EXT_COMMUNITY_TWO_AS);
	} else if (strchr(p + 1, '.') == NULL) {
		/* AS_DOT number (4-byte) */
		*p++ = '\0';
		uvalh = strtonum(s, 0, USHRT_MAX, &errstr);
		if (errstr) {
			yyerror("Bad ext-community %s is %s", s, errstr);
			return (-1);
		}
		uval = strtonum(p, 0, USHRT_MAX, &errstr);
		if (errstr) {
			yyerror("Bad ext-community %s is %s", p, errstr);
			return (-1);
		}
		*v = uval | (uvalh << 16);
		return (EXT_COMMUNITY_FOUR_AS);
	} else {
		/* more than one dot -> IP address */
		if (inet_aton(s, &ip) == 0) {
			yyerror("Bad ext-community %s not parseable", s);
			return (-1);
		}
		*v = ip.s_addr;
		return (EXT_COMMUNITY_IPV4);
	}
	return (-1);
}

int
parseextcommunity(struct filter_extcommunity *c, char *t, char *s)
{
	const struct ext_comm_pairs	 iana[] = IANA_EXT_COMMUNITIES;
	const char 	*errstr;
	u_int64_t	 ullval;
	u_int32_t	 uval;
	char		*p, *ep;
	unsigned int	 i;
	int		 type, subtype;

	if ((subtype = parsesubtype(t)) == -1) {
		yyerror("Bad ext-community unknown type");
		return (-1);
	}

	if ((p = strchr(s, ':')) == NULL) {
		type = EXT_COMMUNITY_OPAQUE,
		errno = 0;
		ullval = strtoull(s, &ep, 0);
		if (s[0] == '\0' || *ep != '\0') {
			yyerror("Bad ext-community bad value");
			return (-1);
		}
		if (errno == ERANGE && ullval > EXT_COMMUNITY_OPAQUE_MAX) {
			yyerror("Bad ext-community value to big");
			return (-1);
		}
		c->data.ext_opaq = ullval;
	} else {
		*p++ = '\0';
		if ((type = parseextvalue(s, &uval)) == -1)
			return (-1);
		switch (type) {
		case EXT_COMMUNITY_TWO_AS:
			ullval = strtonum(p, 0, UINT_MAX, &errstr);
			break;
		case EXT_COMMUNITY_IPV4:
		case EXT_COMMUNITY_FOUR_AS:
			ullval = strtonum(p, 0, USHRT_MAX, &errstr);
			break;
		default:
			fatalx("parseextcommunity: unexpected result");
		}
		if (errstr) {
			yyerror("Bad ext-community %s is %s", p,
			    errstr);
			return (-1);
		}
		switch (type) {
		case EXT_COMMUNITY_TWO_AS:
			c->data.ext_as.as = uval;
			c->data.ext_as.val = ullval;
			break;
		case EXT_COMMUNITY_IPV4:
			c->data.ext_ip.addr.s_addr = uval;
			c->data.ext_ip.val = ullval;
			break;
		case EXT_COMMUNITY_FOUR_AS:
			c->data.ext_as4.as4 = uval;
			c->data.ext_as4.val = ullval;
			break;
		}
	}
	c->type = type;
	c->subtype = subtype;

	/* verify type/subtype combo */
	for (i = 0; i < sizeof(iana)/sizeof(iana[0]); i++) {
		if (iana[i].type == type && iana[i].subtype == subtype) {
			if (iana[i].transitive)
				c->type |= EXT_COMMUNITY_TRANSITIVE;
			c->flags |= EXT_COMMUNITY_FLAG_VALID;
			return (0);
		}
	}

	yyerror("Bad ext-community bad format for type");
	return (-1);
}

struct peer *
alloc_peer(void)
{
	struct peer	*p;
	u_int8_t	 i;

	if ((p = calloc(1, sizeof(struct peer))) == NULL)
		fatal("new_peer");

	/* some sane defaults */
	p->state = STATE_NONE;
	p->next = NULL;
	p->conf.distance = 1;
	p->conf.announce_type = ANNOUNCE_UNDEF;
	p->conf.announce_capa = 1;
	for (i = 0; i < AID_MAX; i++)
		p->conf.capabilities.mp[i] = -1;
	p->conf.capabilities.refresh = 1;
	p->conf.capabilities.grestart.restart = 1;
	p->conf.capabilities.as4byte = 1;
	p->conf.local_as = conf->as;
	p->conf.local_short_as = conf->short_as;
	p->conf.softreconfig_in = 1;
	p->conf.softreconfig_out = 1;

	return (p);
}

struct peer *
new_peer(void)
{
	struct peer		*p;

	p = alloc_peer();

	if (curgroup != NULL) {
		memcpy(p, curgroup, sizeof(struct peer));
		if (strlcpy(p->conf.group, curgroup->conf.group,
		    sizeof(p->conf.group)) >= sizeof(p->conf.group))
			fatalx("new_peer group strlcpy");
		if (strlcpy(p->conf.descr, curgroup->conf.descr,
		    sizeof(p->conf.descr)) >= sizeof(p->conf.descr))
			fatalx("new_peer descr strlcpy");
		p->conf.groupid = curgroup->conf.id;
		p->conf.local_as = curgroup->conf.local_as;
		p->conf.local_short_as = curgroup->conf.local_short_as;
	}
	p->next = NULL;
	if (conf->flags & BGPD_FLAG_DECISION_TRANS_AS)
		p->conf.flags |= PEERFLAG_TRANS_AS;
	return (p);
}

struct peer *
new_group(void)
{
	return (alloc_peer());
}

int
add_mrtconfig(enum mrt_type type, char *name, int timeout, struct peer *p,
    char *rib)
{
	struct mrt	*m, *n;

	LIST_FOREACH(m, conf->mrt, entry) {
		if ((rib && strcmp(rib, m->rib)) ||
		    (!rib && *m->rib))
			continue;
		if (p == NULL) {
			if (m->peer_id != 0 || m->group_id != 0)
				continue;
		} else {
			if (m->peer_id != p->conf.id ||
			    m->group_id != p->conf.groupid)
				continue;
		}
		if (m->type == type) {
			yyerror("only one mrtdump per type allowed.");
			return (-1);
		}
	}

	if ((n = calloc(1, sizeof(struct mrt_config))) == NULL)
		fatal("add_mrtconfig");

	n->type = type;
	if (strlcpy(MRT2MC(n)->name, name, sizeof(MRT2MC(n)->name)) >=
	    sizeof(MRT2MC(n)->name)) {
		yyerror("filename \"%s\" too long: max %zu",
		    name, sizeof(MRT2MC(n)->name) - 1);
		free(n);
		return (-1);
	}
	MRT2MC(n)->ReopenTimerInterval = timeout;
	if (p != NULL) {
		if (curgroup == p) {
			n->peer_id = 0;
			n->group_id = p->conf.id;
		} else {
			n->peer_id = p->conf.id;
			n->group_id = 0;
		}
	}
	if (rib) {
		if (!find_rib(rib)) {
			yyerror("rib \"%s\" does not exist.", rib);
			free(n);
			return (-1);
		}
		if (strlcpy(n->rib, rib, sizeof(n->rib)) >=
		    sizeof(n->rib)) {
			yyerror("rib name \"%s\" too long: max %zu",
			    name, sizeof(n->rib) - 1);
			free(n);
			return (-1);
		}
	}

	LIST_INSERT_HEAD(conf->mrt, n, entry);

	return (0);
}

int
add_rib(char *name, u_int rtableid, u_int16_t flags)
{
	struct rde_rib	*rr;
	u_int		 rdom;

	if ((rr = find_rib(name)) == NULL) {
		if ((rr = calloc(1, sizeof(*rr))) == NULL) {
			log_warn("add_rib");
			return (-1);
		}
	}
	if (strlcpy(rr->name, name, sizeof(rr->name)) >= sizeof(rr->name)) {
		yyerror("rib name \"%s\" too long: max %zu",
		   name, sizeof(rr->name) - 1);
		free(rr);
		return (-1);
	}
	rr->flags |= flags;
	if ((rr->flags & F_RIB_HASNOFIB) == 0) {
		if (ktable_exists(rtableid, &rdom) != 1) {
			yyerror("rtable id %u does not exist", rtableid);
			free(rr);
			return (-1);
		}
		if (rdom != 0) {
			yyerror("rtable %u does not belong to rdomain 0",
			    rtableid);
			free(rr);
			return (-1);
		}
		rr->rtableid = rtableid;
	}
	SIMPLEQ_INSERT_TAIL(&ribnames, rr, entry);
	return (0);
}

struct rde_rib *
find_rib(char *name)
{
	struct rde_rib	*rr;

	SIMPLEQ_FOREACH(rr, &ribnames, entry) {
		if (!strcmp(rr->name, name))
			return (rr);
	}
	return (NULL);
}

int
get_id(struct peer *newpeer)
{
	struct peer	*p;

	for (p = peer_l_old; p != NULL; p = p->next)
		if (newpeer->conf.remote_addr.aid) {
			if (!memcmp(&p->conf.remote_addr,
			    &newpeer->conf.remote_addr,
			    sizeof(p->conf.remote_addr))) {
				newpeer->conf.id = p->conf.id;
				return (0);
			}
		} else {	/* newpeer is a group */
			if (strcmp(newpeer->conf.group, p->conf.group) == 0) {
				newpeer->conf.id = p->conf.groupid;
				return (0);
			}
		}

	/* new one */
	for (; id < UINT_MAX / 2; id++) {
		for (p = peer_l_old; p != NULL &&
		    p->conf.id != id && p->conf.groupid != id; p = p->next)
			;	/* nothing */
		if (p == NULL) {	/* we found a free id */
			newpeer->conf.id = id++;
			return (0);
		}
	}

	return (-1);
}

int
merge_prefixspec(struct filter_prefix_l *p, struct filter_prefixlen *pl)
{
	u_int8_t max_len = 0;

	switch (p->p.addr.aid) {
	case AID_INET:
	case AID_VPN_IPv4:
		max_len = 32;
		break;
	case AID_INET6:
		max_len = 128;
		break;
	}

	switch (pl->op) {
	case OP_NONE:
		return (0);
	case OP_RANGE:
	case OP_XRANGE:
		if (pl->len_min > max_len || pl->len_max > max_len) {
			yyerror("prefixlen %d too big for AF, limit %d",
			    pl->len_min > max_len ? pl->len_min : pl->len_max,
			    max_len);
			return (-1);
		}
		if (pl->len_min < p->p.len) {
			yyerror("prefixlen %d smaller than prefix, limit %d",
			    pl->len_min, p->p.len);
			return (-1);
		}
		p->p.len_max = pl->len_max;
		break;
	case OP_GE:
		/* fix up the "or-longer" case */
		if (pl->len_min == -1)
			pl->len_min = p->p.len;
		/* FALLTHROUGH */
	case OP_EQ:
	case OP_NE:
	case OP_LE:
	case OP_GT:
		if (pl->len_min > max_len) {
			yyerror("prefixlen %d to big for AF, limit %d",
			    pl->len_min, max_len);
			return (-1);
		}
		if (pl->len_min < p->p.len) {
			yyerror("prefixlen %d smaller than prefix, limit %d",
			    pl->len_min, p->p.len);
			return (-1);
		}
		break;
	case OP_LT:
		if (pl->len_min > max_len - 1) {
			yyerror("prefixlen %d to big for AF, limit %d",
			    pl->len_min, max_len - 1);
			return (-1);
		}
		if (pl->len_min < p->p.len + 1) {
			yyerror("prefixlen %d too small for prefix, limit %d",
			    pl->len_min, p->p.len + 1);
			return (-1);
		}
		break;
	}

	p->p.op = pl->op;
	p->p.len_min = pl->len_min;
	return (0);
}

int
expand_rule(struct filter_rule *rule, struct filter_rib_l *rib,
    struct filter_peers_l *peer, struct filter_match_l *match,
    struct filter_set_head *set)
{
	struct filter_rule	*r;
	struct filter_rib_l	*rb, *rbnext;
	struct filter_peers_l	*p, *pnext;
	struct filter_prefix_l	*prefix, *prefix_next;
	struct filter_as_l	*a, *anext;
	struct filter_set	*s;

	rb = rib;
	do {
		p = peer;
		do {
			a = match->as_l;
			do {
				prefix = match->prefix_l;
				do {
					if ((r = calloc(1,
					    sizeof(struct filter_rule))) ==
						 NULL) {
						log_warn("expand_rule");
						return (-1);
					}

					memcpy(r, rule, sizeof(struct filter_rule));
					memcpy(&r->match, match,
					    sizeof(struct filter_match));
					TAILQ_INIT(&r->set);
					copy_filterset(set, &r->set);

					if (rb != NULL)
						strlcpy(r->rib, rb->name,
						     sizeof(r->rib));

					if (p != NULL)
						memcpy(&r->peer, &p->p,
						    sizeof(struct filter_peers));

					if (prefix != NULL)
						memcpy(&r->match.prefix, &prefix->p,
						    sizeof(r->match.prefix));

					if (a != NULL)
						memcpy(&r->match.as, &a->a,
						    sizeof(struct filter_as));

					TAILQ_INSERT_TAIL(filter_l, r, entry);

					if (prefix != NULL)
						prefix = prefix->next;
				} while (prefix != NULL);

				if (a != NULL)
					a = a->next;
			} while (a != NULL);

			if (p != NULL)
				p = p->next;
		} while (p != NULL);

		if (rb != NULL)
			rb = rb->next;
	} while (rb != NULL);

	for (rb = rib; rb != NULL; rb = rbnext) {
		rbnext = rb->next;
		free(rb);
	}

	for (p = peer; p != NULL; p = pnext) {
		pnext = p->next;
		free(p);
	}

	for (a = match->as_l; a != NULL; a = anext) {
		anext = a->next;
		free(a);
	}

	for (prefix = match->prefix_l; prefix != NULL; prefix = prefix_next) {
		prefix_next = prefix->next;
		free(prefix);
	}

	if (set != NULL) {
		while ((s = TAILQ_FIRST(set)) != NULL) {
			TAILQ_REMOVE(set, s, entry);
			free(s);
		}
		free(set);
	}

	return (0);
}

int
str2key(char *s, char *dest, size_t max_len)
{
	unsigned	i;
	char		t[3];

	if (strlen(s) / 2 > max_len) {
		yyerror("key too long");
		return (-1);
	}

	if (strlen(s) % 2) {
		yyerror("key must be of even length");
		return (-1);
	}

	for (i = 0; i < strlen(s) / 2; i++) {
		t[0] = s[2*i];
		t[1] = s[2*i + 1];
		t[2] = 0;
		if (!isxdigit(t[0]) || !isxdigit(t[1])) {
			yyerror("key must be specified in hex");
			return (-1);
		}
		dest[i] = strtoul(t, NULL, 16);
	}

	return (0);
}

int
neighbor_consistent(struct peer *p)
{
	u_int8_t	i;

	/* local-address and peer's address: same address family */
	if (p->conf.local_addr.aid &&
	    p->conf.local_addr.aid != p->conf.remote_addr.aid) {
		yyerror("local-address and neighbor address "
		    "must be of the same address family");
		return (-1);
	}

	/* with any form of ipsec local-address is required */
	if ((p->conf.auth.method == AUTH_IPSEC_IKE_ESP ||
	    p->conf.auth.method == AUTH_IPSEC_IKE_AH ||
	    p->conf.auth.method == AUTH_IPSEC_MANUAL_ESP ||
	    p->conf.auth.method == AUTH_IPSEC_MANUAL_AH) &&
	    !p->conf.local_addr.aid) {
		yyerror("neighbors with any form of IPsec configured "
		    "need local-address to be specified");
		return (-1);
	}

	/* with static keying we need both directions */
	if ((p->conf.auth.method == AUTH_IPSEC_MANUAL_ESP ||
	    p->conf.auth.method == AUTH_IPSEC_MANUAL_AH) &&
	    (!p->conf.auth.spi_in || !p->conf.auth.spi_out)) {
		yyerror("with manual keyed IPsec, SPIs and keys "
		    "for both directions are required");
		return (-1);
	}

	if (!conf->as) {
		yyerror("AS needs to be given before neighbor definitions");
		return (-1);
	}

	if (p->conf.remote_as == 0) {
		yyerror("peer AS may not be zero");
		return (-1);
	}

	/* set default values if they where undefined */
	p->conf.ebgp = (p->conf.remote_as != conf->as);
	if (p->conf.announce_type == ANNOUNCE_UNDEF)
		p->conf.announce_type = p->conf.ebgp ?
		    ANNOUNCE_SELF : ANNOUNCE_ALL;
	if (p->conf.enforce_as == ENFORCE_AS_UNDEF)
		p->conf.enforce_as = p->conf.ebgp ?
		    ENFORCE_AS_ON : ENFORCE_AS_OFF;

	/* EBGP neighbors are not allowed in route reflector clusters */
	if (p->conf.reflector_client && p->conf.ebgp) {
		yyerror("EBGP neighbors are not allowed in route "
		    "reflector clusters");
		return (-1);
	}

	/* the default MP capability is NONE */
	for (i = 0; i < AID_MAX; i++)
		if (p->conf.capabilities.mp[i] == -1)
			p->conf.capabilities.mp[i] = 0;

	return (0);
}

int
merge_filterset(struct filter_set_head *sh, struct filter_set *s)
{
	struct filter_set	*t;

	TAILQ_FOREACH(t, sh, entry) {
		/*
		 * need to cycle across the full list because even
		 * if types are not equal filterset_cmp() may return 0.
		 */
		if (filterset_cmp(s, t) == 0) {
			if (s->type == ACTION_SET_COMMUNITY)
				yyerror("community is already set");
			else if (s->type == ACTION_DEL_COMMUNITY)
				yyerror("community will already be deleted");
			else if (s->type == ACTION_SET_LARGE_COMMUNITY)
				yyerror("large-community is already set");
			else if (s->type == ACTION_DEL_LARGE_COMMUNITY)
				yyerror("large-community will already be deleted");
			else if (s->type == ACTION_SET_EXT_COMMUNITY)
				yyerror("ext-community is already set");
			else if (s->type == ACTION_DEL_EXT_COMMUNITY)
				yyerror(
				    "ext-community will already be deleted");
			else
				yyerror("redefining set parameter %s",
				    filterset_name(s->type));
			return (-1);
		}
	}

	TAILQ_FOREACH(t, sh, entry) {
		if (s->type < t->type) {
			TAILQ_INSERT_BEFORE(t, s, entry);
			return (0);
		}
		if (s->type == t->type)
			switch (s->type) {
			case ACTION_SET_COMMUNITY:
			case ACTION_DEL_COMMUNITY:
				if (s->action.community.as <
				    t->action.community.as ||
				    (s->action.community.as ==
				    t->action.community.as &&
				    s->action.community.type <
				    t->action.community.type)) {
					TAILQ_INSERT_BEFORE(t, s, entry);
					return (0);
				}
				break;
			case ACTION_SET_LARGE_COMMUNITY:
			case ACTION_DEL_LARGE_COMMUNITY:
				if (s->action.large_community.as <
				    t->action.large_community.as ||
				    (s->action.large_community.as ==
				    t->action.large_community.as &&
				    s->action.large_community.ld1 <
				    t->action.large_community.ld2 )) {
					TAILQ_INSERT_BEFORE(t, s, entry);
					return (0);
				}
				break;
			case ACTION_SET_EXT_COMMUNITY:
			case ACTION_DEL_EXT_COMMUNITY:
				if (memcmp(&s->action.ext_community,
				    &t->action.ext_community,
				    sizeof(s->action.ext_community)) < 0) {
					TAILQ_INSERT_BEFORE(t, s, entry);
					return (0);
				}
				break;
			case ACTION_SET_NEXTHOP:
				if (s->action.nexthop.aid <
				    t->action.nexthop.aid) {
					TAILQ_INSERT_BEFORE(t, s, entry);
					return (0);
				}
				break;
			default:
				break;
			}
	}

	TAILQ_INSERT_TAIL(sh, s, entry);
	return (0);
}

void
copy_filterset(struct filter_set_head *source, struct filter_set_head *dest)
{
	struct filter_set	*s, *t;

	if (source == NULL)
		return;

	TAILQ_FOREACH(s, source, entry) {
		if ((t = malloc(sizeof(struct filter_set))) == NULL)
			fatal(NULL);
		memcpy(t, s, sizeof(struct filter_set));
		TAILQ_INSERT_TAIL(dest, t, entry);
	}
}

void
merge_filter_lists(struct filter_head *dst, struct filter_head *src)
{
	struct filter_rule *r;

	while ((r = TAILQ_FIRST(src)) != NULL) {
		TAILQ_REMOVE(src, r, entry);
		TAILQ_INSERT_TAIL(dst, r, entry);
	}
}

struct filter_rule *
get_rule(enum action_types type)
{
	struct filter_rule	*r;
	int			 out;

	switch (type) {
	case ACTION_SET_PREPEND_SELF:
	case ACTION_SET_NEXTHOP_NOMODIFY:
	case ACTION_SET_NEXTHOP_SELF:
		out = 1;
		break;
	default:
		out = 0;
		break;
	}
	r = (curpeer == curgroup) ? curgroup_filter[out] : curpeer_filter[out];
	if (r == NULL) {
		if ((r = calloc(1, sizeof(struct filter_rule))) == NULL)
			fatal(NULL);
		r->quick = 0;
		r->dir = out ? DIR_OUT : DIR_IN;
		r->action = ACTION_NONE;
		r->match.community.as = COMMUNITY_UNSET;
		r->match.large_community.as = COMMUNITY_UNSET;
		TAILQ_INIT(&r->set);
		if (curpeer == curgroup) {
			/* group */
			r->peer.groupid = curgroup->conf.id;
			curgroup_filter[out] = r;
		} else {
			/* peer */
			r->peer.peerid = curpeer->conf.id;
			curpeer_filter[out] = r;
		}
	}
	return (r);
}
@


1.300
log
@Expand RIB names in groups

Diff from Denis Fondras, many thanks!

OK claudio@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.299 2017/05/26 14:07:03 phessler Exp $ */
d3661 5
@


1.299
log
@Allow nested {} in prefix lists.

Diff from Denis Fondras, many thanks!

OK claudio@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.298 2017/02/22 13:55:14 renato Exp $ */
d96 5
d138 3
a140 2
int		 expand_rule(struct filter_rule *, struct filter_peers_l *,
		    struct filter_match_l *, struct filter_set_head *);
d164 1
d215 1
a215 1
%type	<v.string>		string filter_rib
d219 1
d1483 1
a1483 1
filterrule	: action quick filter_rib direction filter_peer_h filter_match_h filter_set
d1486 1
d1496 5
a1500 1
					free($3);
a1502 14
				if (!find_rib($3)) {
					yyerror("rib \"%s\" does not exist.",
					    $3);
					free($3);
					YYERROR;
				}
				if (strlcpy(r.rib, $3, sizeof(r.rib)) >=
				    sizeof(r.rib)) {
					yyerror("rib name \"%s\" too long: "
					    "max %zu", $3, sizeof(r.rib) - 1);
					free($3);
					YYERROR;
				}
				free($3);
d1504 1
a1504 1
			if (expand_rule(&r, $5, &$6, $7) == -1)
d1522 32
a1553 2
filter_rib	: /* empty */	{ $$ = NULL; }
		| RIB STRING	{ $$ = $2; }
d3499 3
a3501 2
expand_rule(struct filter_rule *rule, struct filter_peers_l *peer,
    struct filter_match_l *match, struct filter_set_head *set)
d3504 1
d3510 1
a3510 1
	p = peer;
d3512 1
a3512 1
		a = match->as_l;
d3514 1
a3514 1
			prefix = match->prefix_l;
d3516 36
a3551 19
				if ((r = calloc(1,
				    sizeof(struct filter_rule))) == NULL) {
					log_warn("expand_rule");
					return (-1);
				}

				memcpy(r, rule, sizeof(struct filter_rule));
				memcpy(&r->match, match,
				    sizeof(struct filter_match));
				TAILQ_INIT(&r->set);
				copy_filterset(set, &r->set);

				if (p != NULL)
					memcpy(&r->peer, &p->p,
					    sizeof(struct filter_peers));

				if (prefix != NULL)
					memcpy(&r->match.prefix, &prefix->p,
					    sizeof(r->match.prefix));
d3554 2
a3555 2
					memcpy(&r->match.as, &a->a,
					    sizeof(struct filter_as));
d3557 3
a3559 1
				TAILQ_INSERT_TAIL(filter_l, r, entry);
d3561 8
a3568 11
				if (prefix != NULL)
					prefix = prefix->next;
			} while (prefix != NULL);

			if (a != NULL)
				a = a->next;
		} while (a != NULL);

		if (p != NULL)
			p = p->next;
	} while (p != NULL);
@


1.298
log
@Add missing htonl for IPsec SPI.

Also, do not allow to configure SPI values in the 0..255 range. RFC 4302
and RFC 4303 say the following:
"The set of SPI values in the range 1 through 255 are reserved by the
Internet Assigned Numbers Authority (IANA) for future use; a reserved
SPI value will not normally be assigned by IANA unless the use of the
assigned SPI value is specified in an RFC.  The SPI value of zero (0)
is reserved for local, implementation-specific use and MUST NOT be
sent on the wire".

ok and tweak benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.297 2017/01/25 00:11:07 claudio Exp $ */
d220 1
d1619 1
a1619 1
		| PREFIX '{' filter_prefix_l '}'	{ $$ = $3; }
d1621 14
@


1.297
log
@Flag the Loc-RIB with F_RIB_LOCAL so we can remove one ugly hack somewhere else
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.296 2017/01/24 04:22:42 benno Exp $ */
d30 1
d1270 1
a1270 1
			if ($5 < 0 || $5 > UINT_MAX) {
@


1.296
log
@sync log.c from relayd et al to bgpd.

there is still a little difference regarding handling of the verbosity
value that will be handled later.

ok claudio@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.295 2017/01/18 04:28:45 phessler Exp $ */
d2757 1
a2757 1
	add_rib("Loc-RIB", 0, 0);
@


1.295
log
@while a u_int is large enough for 32bit-asns, it is not big enough for
some of the magic values we use to indicate '*' or neighbor-as.

fixes "allow from any large-community neighbor-as:*:*"
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.294 2017/01/13 18:59:12 phessler Exp $ */
d47 1
@


1.294
log
@Add support for draft-ietf-idr-shutdown

    BGP state = Idle, marked down with shutdown reason "goodbye, we are
    upgrading to openbsd 6.1", down for 00:00:17

developed by Peter van Dijk <peter.van.dijk@@powerdns.com> and Job
Snijders <job@@ntt.net>, thank you!

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.293 2017/01/05 13:53:09 krw Exp $ */
d143 1
a143 1
u_int		 getlargecommunity(char *);
d2969 1
a2969 1
u_int
@


1.293
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.292 2017/01/05 12:42:18 krw Exp $ */
d1055 1
a1055 1
		| DOWN		{
d1057 11
@


1.292
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.291 2016/12/26 21:30:10 jca Exp $ */
d2758 1
a2758 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.291
log
@Typo, "more then" -> "more than"
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.290 2016/10/14 16:05:36 phessler Exp $ */
d2819 4
a2822 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d2881 1
a2881 1
	TAILQ_FOREACH(sym, &symhead, entry)
d2886 1
@


1.290
log
@Add support for draft-ietf-idr-large-community

Joint work with Job Snijders, many thanks!
OK benno@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.289 2016/10/05 07:38:06 phessler Exp $ */
d3069 1
a3069 1
		/* more then one dot -> IP address */
@


1.289
log
@Let bgpd announce routes based on a route-label.

OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.288 2016/06/21 21:35:24 benno Exp $ */
d8 2
d143 2
d192 1
a192 1
%token	COMMUNITY EXTCOMMUNITY
d1719 1
d1724 1
d1785 12
d2152 25
d2312 1
d2957 53
d3627 4
d3662 12
d3750 1
@


1.288
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.287 2016/06/03 17:36:37 benno Exp $ */
d674 19
@


1.287
log
@Add operators =, !=, - (range), >< (exclsive range) to the as-path
filters (AS, peer-as, source-as, transit-as).

Add a use case (block illegal AS numbers) to the bgpd.conf example.

feedback from claudio, sthen, florian,
ok florian@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.286 2015/10/27 18:19:33 mmcc Exp $ */
d340 1
d343 7
@


1.286
log
@calloc -> malloc when the memory is immediately overwritten with memcpy.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.285 2015/10/22 13:30:07 reyk Exp $ */
d199 1
a199 1
%type	<v.number>		asnumber as4number optnumber
d214 1
a214 1
%type	<v.u8>			unaryop binaryop filter_as_type
d283 32
d1651 1
a1651 1
filter_as	: as4number		{
d1656 1
d1664 19
d2158 4
@


1.285
log
@Revert revision 1.282:
"Allow for empty blocks for peers.  While this is bad style for permant
use, this is very nice to temporarily disable a peer option."

This broke the grammar by introducing shift/reduce errors.

OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.284 2015/10/11 19:30:12 phessler Exp $ */
d3512 1
a3512 1
		if ((t = calloc(1, sizeof(struct filter_set))) == NULL)
@


1.284
log
@standardize a community that has been independently created by nearly
every single AS on the planet: the blackhole

OK benno@@, claudio@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.283 2015/09/21 09:47:15 phessler Exp $ */
a961 1
		| /* allow empty blocks */
@


1.283
log
@Let us log all updates sent from an individual peer.  Since this can be
applied to a group, also let us disable logging on a sub-member of the
group.  Very handy for debugging naughty peers on a router with multiple
peers.

OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.282 2015/09/21 09:41:48 phessler Exp $ */
d2802 4
@


1.282
log
@Allow for empty blocks for peers.  While this is bad style for permant
use, this is very nice to temporarily disable a peer option.

OK sthen@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.281 2015/07/16 18:26:04 claudio Exp $ */
d1326 11
@


1.281
log
@Next round of config cleanup. Move various lists into the bgpd_config struct.
This is the next step to better split parsing and merging the config.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.280 2015/04/26 20:12:03 benno Exp $ */
d962 1
a962 1
		| error nl
@


1.280
log
@mlarkin asks "bgpctl checks the length of the control socket path to
make sure it fits. When browsing around last night I saw that bgpd
does not. Any reason it shouldn't? Please commit"

Add a check in parse.y to check this when reading the configuration.
ok phessler@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.279 2015/04/25 15:28:18 phessler Exp $ */
d80 1
a80 2
static struct mrt_head		*mrtconf;
static struct network_head	*netconf, *gnetconf;
a84 1
static struct rdomain_head	*rdom_l;
a89 1
static struct listen_addrs	*listen_addrs;
d375 1
a375 1
			TAILQ_INSERT_TAIL(listen_addrs, la, entry);
d761 1
a761 1
			SIMPLEQ_INSERT_TAIL(rdom_l, currdom, entry);
d763 1
a763 1
			netconf = gnetconf;
d2580 1
a2580 3
parse_config(char *filename, struct bgpd_config *xconf,
    struct mrt_head *xmconf, struct peer **xpeers, struct network_head *nc,
    struct filter_head *xfilter_l, struct rdomain_head *xrdom_l)
a2583 2
	struct listen_addr	*la;
	struct network		*n;
a2584 1
	struct rdomain		*rd;
d2587 1
a2587 4
	if ((conf = calloc(1, sizeof(struct bgpd_config))) == NULL)
		fatal(NULL);

	conf->csock = strdup(SOCKET_NAME);
a2588 10
	if ((file = pushfile(filename, 1)) == NULL) {
		free(conf);
		return (-1);
	}
	topfile = file;

	if ((mrtconf = calloc(1, sizeof(struct mrt_head))) == NULL)
		fatal(NULL);
	if ((listen_addrs = calloc(1, sizeof(struct listen_addrs))) == NULL)
		fatal(NULL);
a2594 2
	LIST_INIT(mrtconf);
	TAILQ_INIT(listen_addrs);
d2605 1
a2605 7
	/* network list is always empty in the parent */
	gnetconf = netconf = nc;
	TAILQ_INIT(netconf);
	/* init the empty filter list for later */
	TAILQ_INIT(xfilter_l);
	SIMPLEQ_INIT(xrdom_l);
	rdom_l = xrdom_l;
d2610 6
a2634 10
		/* XXX more leaks in this case */
		free(conf->csock);
		free(conf->rcsock);

		while ((la = TAILQ_FIRST(listen_addrs)) != NULL) {
			TAILQ_REMOVE(listen_addrs, la, entry);
			free(la);
		}
		free(listen_addrs);

d2640 3
a2642 4
		while ((n = TAILQ_FIRST(netconf)) != NULL) {
			TAILQ_REMOVE(netconf, n, entry);
			filterset_free(&n->net.attrset);
			free(n);
d2649 10
a2658 14
		while ((rr = SIMPLEQ_FIRST(&ribnames)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&ribnames, entry);
			free(rr);
		}
		while ((rd = SIMPLEQ_FIRST(rdom_l)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(rdom_l, entry);
			filterset_free(&rd->export);
			filterset_free(&rd->import);

			while ((n = TAILQ_FIRST(&rd->net_l)) != NULL) {
				TAILQ_REMOVE(&rd->net_l, n, entry);
				filterset_free(&n->net.attrset);
				free(n);
			}
d2660 2
a2661 5
			free(rd);
		}
	} else {
		errors += merge_config(xconf, conf, peer_l, listen_addrs);
		errors += mrt_mergeconfig(xmconf, mrtconf);
a2668 8
		/*
		 * Move filter list and static group and peer filtersets
		 * together. Static group sets come first then peer sets
		 * last normal filter rules.
		 */
		merge_filter_lists(xfilter_l, groupfilter_l);
		merge_filter_lists(xfilter_l, peerfilter_l);
		merge_filter_lists(xfilter_l, filter_l);
a2673 3
	free(conf);
	free(mrtconf);

d3032 1
a3032 1
	LIST_FOREACH(m, mrtconf, entry) {
d3086 1
a3086 1
	LIST_INSERT_HEAD(mrtconf, n, entry);
@


1.279
log
@allow us to write rules that match directly on the peer AS

...
allow from AS 1 prefix 192.0.2.0/24
...

Also adjust the IRR ruleset output to include the declared peer AS,
instead of hoping they listed their neighbor IP address!


OK benno@@
older version OK: claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.278 2015/03/14 03:52:42 claudio Exp $ */
d26 1
d582 5
@


1.278
log
@rename rde_free_filter() to filterlist_free() and start using it outside
of the RDE to free the filterlists. Also refactor common code to merge
filterlists into its own function. Makes the code look nicer.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.277 2015/03/14 02:43:02 claudio Exp $ */
d1460 1
a1460 1
			$$->p.groupid = $$->p.peerid = 0;
d1474 7
d1487 1
a1487 1
			$$->p.peerid = 0;
@


1.277
log
@Move the command line options (mainly -d and -v) out of struct bgpd_config
into a own flag field since these can't be modified via a config reload.
OK henning@@ benno@@ before lock
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.276 2015/03/14 02:32:35 claudio Exp $ */
d138 1
a2577 1
	struct filter_rule	*r;
d2666 4
a2669 17
		while ((r = TAILQ_FIRST(filter_l)) != NULL) {
			TAILQ_REMOVE(filter_l, r, entry);
			filterset_free(&r->set);
			free(r);
		}

		while ((r = TAILQ_FIRST(peerfilter_l)) != NULL) {
			TAILQ_REMOVE(peerfilter_l, r, entry);
			filterset_free(&r->set);
			free(r);
		}

		while ((r = TAILQ_FIRST(groupfilter_l)) != NULL) {
			TAILQ_REMOVE(groupfilter_l, r, entry);
			filterset_free(&r->set);
			free(r);
		}
d2702 6
a2707 12
		while ((r = TAILQ_FIRST(groupfilter_l)) != NULL) {
			TAILQ_REMOVE(groupfilter_l, r, entry);
			TAILQ_INSERT_TAIL(xfilter_l, r, entry);
		}
		while ((r = TAILQ_FIRST(peerfilter_l)) != NULL) {
			TAILQ_REMOVE(peerfilter_l, r, entry);
			TAILQ_INSERT_TAIL(xfilter_l, r, entry);
		}
		while ((r = TAILQ_FIRST(filter_l)) != NULL) {
			TAILQ_REMOVE(filter_l, r, entry);
			TAILQ_INSERT_TAIL(xfilter_l, r, entry);
		}
a2711 3
	free(filter_l);
	free(peerfilter_l);
	free(groupfilter_l);
d3541 11
@


1.276
log
@Move the code that adjust FIB priority when changed during a config reload
from the parsing function to the merge_config function where it belongs.
OK henning@@ benno@@ before lock
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.275 2014/11/20 05:51:20 jsg Exp $ */
d309 1
a309 1
			if (conf->opts & BGPD_OPT_VERBOSE)
d1305 1
a1305 1
			    conf->opts & BGPD_OPT_FORCE_DEMOTE) == -1) {
d1975 1
a1975 1
			if (!(conf->opts & BGPD_OPT_NOACTION) &&
a2584 1
	conf->opts = xconf->opts;
d2633 1
a2633 1
		if ((conf->opts & BGPD_OPT_VERBOSE2) && !sym->used)
@


1.275
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.274 2014/11/03 16:55:59 bluhm Exp $ */
a2580 3
	u_int8_t		 old_prio;

	old_prio = xconf->fib_priority;
a2734 7

	if (!errors && old_prio != RTP_NONE && old_prio !=
	    xconf->fib_priority) {
		kr_fib_decouple_all(old_prio);
		kr_fib_update_prio_all(xconf->fib_priority);
		kr_fib_couple_all(xconf->fib_priority);
	}
@


1.274
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK benno@@ doug@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.273 2014/11/02 00:30:41 doug Exp $ */
d2398 3
@


1.273
log
@Add gcc format attributes to parse.y's yyerror() for bgpd.

Fix some of the format characters in yyerror calls: %u -> %zu, %lld -> %u

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.272 2014/05/02 14:12:05 deraadt Exp $ */
d2102 1
a2102 1
	char		*nfmt;
d2106 2
a2107 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d2109 2
a2110 1
	free(nfmt);
@


1.272
log
@spelling; Denis Fondras
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.271 2014/01/22 00:21:16 henning Exp $ */
d58 3
a60 1
int		 yyerror(const char *, ...);
d843 1
a843 1
				yyerror("descr \"%s\" too long: max %u",
d914 1
a914 1
				yyerror("group name \"%s\" too long: max %u",
d968 1
a968 1
				yyerror("descr \"%s\" too long: max %u",
d981 1
a981 1
				yyerror("invalid multihop distance %d", $2);
d1001 1
a1001 1
				yyerror("rib name \"%s\" too long: max %u",
d1104 1
a1104 1
				yyerror("tcp md5sig password too long: max %u",
d1172 1
a1172 1
				    "is %u bytes", keylen, strlen($7) / 2);
d1286 1
a1286 1
				    "max %u", $3,
d1298 1
a1298 1
				    "max %u", $2,
d1370 1
a1370 1
				    "bytes, is %u bytes",
d1408 1
a1408 1
					    "max %u", $3, sizeof(r.rib) - 1);
d3125 1
a3125 1
		yyerror("filename \"%s\" too long: max %u",
d3148 1
a3148 1
			yyerror("rib name \"%s\" too long: max %u",
d3173 1
a3173 1
		yyerror("rib name \"%s\" too long: max %u",
d3181 1
a3181 1
			yyerror("rtable id %lld does not exist", rtableid);
d3186 1
a3186 1
			yyerror("rtable %lld does not belong to rdomain 0",
@


1.271
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.269 2013/11/13 09:14:48 florian Exp $ */
d231 1
a231 1
			 * Accroding to iana 65535 and 4294967295 are reserved
@


1.270
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d2508 2
a2509 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
@


1.269
log
@Knob to set priority with which bgpd inserts routes into the kernel
routing table. Need for it in "special" setups pointed out by
Loic Blot (loic.blot _AT_ unix-experience _DOT_ fr) on tech.
OK benno, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.268 2013/10/19 15:04:25 claudio Exp $ */
d2237 1
a2237 1
char	*parsebuf;
d2239 1
a2239 1
char	 pushback_buffer[MAXPUSHBACK];
d2332 2
a2333 2
	char	 buf[8096];
	char	*p, *val;
d2356 1
a2356 1
				*p++ = (char)c;
d2401 1
a2401 1
			*p++ = (char)c;
@


1.268
log
@Merge the prefix and prefixlen filter bits into one filter. Change the
filter expansion so that rules are grouped by prefixes last. The RDE will
then be able to optimize the rules into table lookups but that is a later
step. As additional goodies it is now possible to use inet and inet6
on their own and or-longer can be used as a shorthand for prefixlen >= len.
OK henning@@ sthen@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.267 2013/09/27 08:23:11 sthen Exp $ */
d173 1
a173 1
%token	AS ROUTERID HOLDTIME YMIN LISTEN ON FIBUPDATE RTABLE
d376 7
d2149 1
d2576 3
d2582 1
d2733 7
@


1.267
log
@typo in macro name; no md5 change
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.266 2013/05/11 14:42:28 benno Exp $ */
d102 6
a116 1
	u_int8_t		 aid;
d127 2
a154 1
		struct filter_prefixlen	 prefixlen;
d161 1
d195 1
a195 1
%token	NE LE GE XRANGE
d212 1
a212 2
%type	<v.filter_prefix>	filter_prefix filter_prefix_l
%type	<v.filter_prefix>	filter_prefix_h filter_prefix_m
d1487 23
a1509 16
filter_prefix_h	: PREFIX filter_prefix			{ $$ = $2; }
		| PREFIX '{' filter_prefix_m '}'	{ $$ = $3; }
		;

filter_prefix_m	: filter_prefix_l
		| '{' filter_prefix_l '}'		{ $$ = $2; }
		| '{' filter_prefix_l '}' filter_prefix_m
		{
			struct filter_prefix_l	*p;

			/* merge, both can be lists */
			for (p = $2; p != NULL && p->next != NULL; p = p->next)
				;	/* nothing */
			if (p != NULL)
				p->next = $4;
			$$ = $2;
d1511 2
d1522 1
a1522 7
filter_prefix	: prefix				{
			if (fmopts.aid && fmopts.aid != $1.prefix.aid) {
				yyerror("rules with mixed address families "
				    "are not allowed");
				YYERROR;
			} else
				fmopts.aid = $1.prefix.aid;
d1529 5
a1533 1
			$$->next = NULL;
a1626 14
		| PREFIXLEN prefixlenop		{
			if (fmopts.aid == 0) {
				yyerror("address family needs to be specified "
				    "before \"prefixlen\"");
				YYERROR;
			}
			if (fmopts.m.prefixlen.aid) {
				yyerror("\"prefixlen\" already specified");
				YYERROR;
			}
			memcpy(&fmopts.m.prefixlen, &$2,
			    sizeof(fmopts.m.prefixlen));
			fmopts.m.prefixlen.aid = fmopts.aid;
		}
a1687 14
		| IPV4			{
			if (fmopts.aid) {
				yyerror("address family already specified");
				YYERROR;
			}
			fmopts.aid = AID_INET;
		}
		| IPV6			{
			if (fmopts.aid) {
				yyerror("address family already specified");
				YYERROR;
			}
			fmopts.aid = AID_INET6;
		}
a1692 5
			if (fmopts.aid && fmopts.aid != $2.aid) {
				yyerror("nexthop address family doesn't match "
				    "rule address family");
				YYERROR;
			}
d1705 2
a1706 1
prefixlenop	: unaryop NUMBER		{
d1708 11
a1718 2
			if ($2 < 0 || $2 > 128) {
				yyerror("prefixlen must be < 128");
d1721 2
a1722 2
			$$.op = $1;
			$$.len_min = $2;
d1724 1
a1724 1
		| NUMBER binaryop NUMBER	{
d1726 1
a1726 1
			if ($1 < 0 || $1 > 128 || $3 < 0 || $3 > 128) {
d1730 1
a1730 1
			if ($1 >= $3) {
d1734 3
a1736 3
			$$.op = $2;
			$$.len_min = $1;
			$$.len_max = $3;
d2174 1
d3223 72
d3306 1
a3306 1
		prefix = match->prefix_l;
d3308 1
a3308 1
			a = match->as_l;
d3336 3
a3338 3
				if (a != NULL)
					a = a->next;
			} while (a != NULL);
d3340 3
a3342 3
			if (prefix != NULL)
				prefix = prefix->next;
		} while (prefix != NULL);
d3353 5
a3360 5
	}

	for (a = match->as_l; a != NULL; a = anext) {
		anext = a->next;
		free(a);
@


1.266
log
@change mrt rib dump ReopenTimerInterval from time_t to int. Intervalls
don't need to scale to 64 bits in this universe.
ok claudio@@ & florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.265 2012/11/13 09:47:20 claudio Exp $ */
d2883 1
a2883 1
		{ "soo",	EXT_CUMMUNITY_ROUTE_ORIG }
@


1.265
log
@Allow filtering based on the NEXTHOP attribute. This allows to build rules
like: allow from any nexthop neighbor (to allow only prefixes that use the
routers IP address as nexthop). Lots of testing, input and OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.264 2012/09/23 09:39:17 claudio Exp $ */
d117 1
a117 1
int		 add_mrtconfig(enum mrt_type, char *, time_t, struct peer *,
d442 1
a442 1
			if ($4 < 0 || $4 > UINT_MAX) {
d470 1
a470 1
			if ($6 < 0 || $6 > UINT_MAX) {
d578 1
a578 1
			if ($5 < 0 || $5 > UINT_MAX) {
d3084 1
a3084 1
add_mrtconfig(enum mrt_type type, char *name, time_t timeout, struct peer *p,
@


1.264
log
@Enable graceful restart by default. The only way to find out if it works for
real. After discussion with sthen@@, henning@@ and deraadt@@.
It can be disabled per neighbor with "announce restart no".
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.263 2012/09/12 05:56:22 claudio Exp $ */
d1702 20
@


1.263
log
@Better graceful restart support (implementing more then just the EoR record).
This implements only the "Restarting Client" bits of the RFC -- in other
words bgpd will keep the FIB when the client restarts but it will not do GR
when restarting itself. The capability is still off by default (you need
"announce restart yes" to enable it).
Tested by Anders Berggren. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.262 2012/07/13 15:25:37 claudio Exp $ */
d3022 1
a3022 1
	p->conf.capabilities.grestart.restart = 0;
@


1.262
log
@Make sure that set med 0 is ACTION_SET_MED and not relative. Fixes
set med 0 and Hennings iBGP sessions. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.261 2012/04/12 17:31:05 claudio Exp $ */
d1041 1
a1041 1
			curpeer->conf.capabilities.restart = $3;
d3022 1
a3022 1
	p->conf.capabilities.restart = 0;
@


1.261
log
@The ebgp flags is just a truth value and it is better to not == 1 compares.
OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.260 2011/09/17 16:29:44 claudio Exp $ */
d1807 1
a1807 1
			if ($2 > 0) {
d1842 1
a1842 1
			if ($2 > 0) {
@


1.260
log
@Implement new mrt table dump format as specified in draft-ietf-grow-mrt.
Tested with IP and IPv6 sessions and against the libbgpdump parser.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.259 2011/05/01 12:56:04 claudio Exp $ */
d3362 2
a3363 2
		p->conf.announce_type = p->conf.ebgp == 0 ?
		    ANNOUNCE_ALL : ANNOUNCE_SELF;
d3365 2
a3366 2
		p->conf.enforce_as = p->conf.ebgp == 0 ?
		    ENFORCE_AS_OFF : ENFORCE_AS_ON;
@


1.259
log
@On reload the filtersets attached to a network need to be moved to the
existing network element. First free the old filterset and then move
the new on top of it. This solves the reload issue with changing network
statements. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.258 2010/09/02 14:03:21 sobrado Exp $ */
d452 2
d481 2
@


1.258
log
@remove trailing spaces and tabs from source code; no binary changes
(verified by both sthen@@ and me).

ok sthen@@; "just commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.257 2010/08/03 18:42:40 henning Exp $ */
a128 2
void		 move_filterset(struct filter_set_head *,
		    struct filter_set_head *);
d609 1
a609 1
			move_filterset($3, &n->net.attrset);
d627 1
a627 1
			move_filterset($4, &n->net.attrset);
a3462 16
	}
}

void
move_filterset(struct filter_set_head *source, struct filter_set_head *dest)
{
	struct filter_set	*s;

	TAILQ_INIT(dest);

	if (source == NULL)
		return;

	while ((s = TAILQ_FIRST(source)) != NULL) {
		TAILQ_REMOVE(source, s, entry);
		TAILQ_INSERT_TAIL(dest, s, entry);
@


1.257
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.256 2010/06/27 19:53:34 claudio Exp $ */
d2391 1
a2391 1
		break;		
@


1.256
log
@Instead of specifying the control sockets on the command line have them
in bgpd.conf. This allows to add/modify restricted control sockets on runtime.
Feature request by a few people how often forgot to add -r path when restarting
bgpd (including myself).
NOTE: this removes the -s and -r arguments from bgpd so pay attention when
updateing.
jajaja sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.255 2010/05/17 16:08:20 claudio Exp $ */
d2367 2
a2368 1
				else if (next == '\n')
d2370 1
a2370 1
				else
@


1.255
log
@Implement two new filters, max-as-len and max-as-seq. The first is limiting
the length of an AS path (matches if the path is longer then the specified
lenght) the second matches when a sequence of the same AS number is longer
then the specified length).
max-as-len is good to protect crappy comercial bgp boxes from other crappy
comercial bgp boxes. max-as-seq was a feature request from SwissIX and maybe
EuroIX to find and filter prepends.
Additinal testing and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.254 2010/05/17 15:49:29 claudio Exp $ */
d175 1
a175 1
%token	DUMP IN OUT
d193 1
a193 1
%type	<v.number>		asnumber as4number optnumber yesno inout
d195 1
d562 9
d640 4
d2181 1
d2190 1
d2558 1
d2619 3
@


1.254
log
@Last bits of MPLS VPN support. Hook kernel routing tables and RIB together.
This adds a bit of new config to specify the mapping between an rdomain and
the BGP MPLS VPN instance, example:
rdomain 1 {
        descr "CUSTOMER1"
	rd 65003:1
	import-target rt 65003:3
	export-target rt 65003:1
	depend on mpe0
	network 192.168.224/24
}
The "depend on mpe0" is a but ugly but for now this is the quickest way to
figure out which interface bgp should use to insert the MPLS routes.

A big side-effect of this diff is that networks are now internally
distributed through kroute.c.
This needs some kernel changes that will follow hopefully soon.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.253 2010/05/03 13:09:38 claudio Exp $ */
d183 1
a183 1
%token	PREFIX PREFIXLEN SOURCEAS TRANSITAS PEERAS DELETE
d1619 24
d2134 2
@


1.253
log
@Make it possible to load multiple routing tables at the same time and use
those for alternate RIBs. This allows to use "rde rib TESTIT rtable 1".
NOTE: nexthop verification has changed for alternate tables. For now
nexthop will only be verified against the main routing table (id 0).
Because of this "nexthop qualify via bgp" may now compare the nexthops
against bgpd routes from a different RIB.
Tested by sthen@@, OK to move on by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.252 2010/04/28 13:07:48 claudio Exp $ */
d28 1
d78 1
a78 1
static struct network_head	*netconf;
d82 2
d169 1
d194 1
a194 1
%type	<v.number>		espah family restart origincode
d217 1
d439 1
a439 41
		| NETWORK prefix filter_set	{
			struct network	*n;

			if ((n = calloc(1, sizeof(struct network))) == NULL)
				fatal("new_network");
			memcpy(&n->net.prefix, &$2.prefix,
			    sizeof(n->net.prefix));
			n->net.prefixlen = $2.len;
			move_filterset($3, &n->net.attrset);
			free($3);

			TAILQ_INSERT_TAIL(netconf, n, entry);
		}
		| NETWORK family STATIC filter_set	{
			if ($2 == AFI_IPv4) {
				conf->flags |= BGPD_FLAG_REDIST_STATIC;
				move_filterset($4, &conf->staticset);
			} else if ($2 == AFI_IPv6) {
				conf->flags |= BGPD_FLAG_REDIST6_STATIC;
				move_filterset($4, &conf->staticset6);
			} else {
				yyerror("unknown family");
				free($4);
				YYERROR;
			}
			free($4);
		}
		| NETWORK family CONNECTED filter_set	{
			if ($2 == AFI_IPv4) {
				conf->flags |= BGPD_FLAG_REDIST_CONNECTED;
				move_filterset($4, &conf->connectset);
			} else if ($2 == AFI_IPv6) {
				conf->flags |= BGPD_FLAG_REDIST6_CONNECTED;
				move_filterset($4, &conf->connectset6);
			} else {
				yyerror("unknown family");
				free($4);
				YYERROR;
			}
			free($4);
		}
d593 33
d711 132
d1309 4
d2090 1
d2098 1
d2134 1
d2136 1
d2502 1
a2502 1
    struct filter_head *xfilter_l)
d2510 1
d2546 1
a2546 1
	netconf = nc;
d2550 2
d2553 1
a2553 1
	add_rib("Adj-RIB-In", 0, F_RIB_NOEVALUATE);
d2613 13
@


1.252
log
@Allow neighbor-as in AS filter statements like:
match from any source-as neighbor-as set localpref 1000
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.251 2010/04/26 08:46:31 claudio Exp $ */
d116 2
a117 2
int		 add_rib(char *, u_int16_t);
int		 find_rib(char *);
d367 5
d373 1
a373 1
				conf->flags |= BGPD_FLAG_NO_FIB_UPDATE;
d375 1
a375 1
				conf->flags &= ~BGPD_FLAG_NO_FIB_UPDATE;
d384 1
a384 1
			if (add_rib($3, F_RIB_NOFIB)) {
d393 12
d407 7
a413 1
			if (!add_rib($3, F_RIB_NOFIB | F_RIB_NOEVALUATE)) {
d579 3
a581 2
			if ($2 > RT_TABLEID_MAX || $2 < 0) {
				yyerror("invalid rtable id");
d584 4
a587 1
			conf->rtableid = $2;
d2412 2
a2413 2
	add_rib("Adj-RIB-In", F_RIB_NOEVALUATE);
	add_rib("Loc-RIB", 0);
d2926 1
a2926 1
add_rib(char *name, u_int16_t flags)
d2929 1
d2931 5
a2935 8
	if (find_rib(name)) {
		yyerror("rib \"%s\" allready exists.", name);
		return (-1);
	}

	if ((rr = calloc(1, sizeof(*rr))) == NULL) {
		log_warn("add_rib");
		return (-1);
d2940 1
d2944 14
d2962 1
a2962 1
int
d2969 1
a2969 1
			return (1);
d2971 1
a2971 1
	return (0);
@


1.251
log
@Fix some memory leaks on config reload failure and move one particular
cleanup loop to parse.y where it belongs.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.250 2010/03/31 18:53:23 claudio Exp $ */
d1404 6
@


1.250
log
@network static and network connected have been superseded by network inet
static and network inet connected a long time ago. It is time to remove
the old compat code.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.249 2010/03/05 15:25:00 claudio Exp $ */
d2338 1
d2415 1
d2421 1
d2427 1
d2433 1
d2435 4
@


1.249
log
@Allow to filter for ext-community attributes. Currently only perfect matches
work but that's already better then nothing. OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.248 2010/01/13 06:02:37 claudio Exp $ */
a450 12
		}
		| NETWORK STATIC filter_set	{
			/* keep for compatibility till after next release */
			conf->flags |= BGPD_FLAG_REDIST_STATIC;
			move_filterset($3, &conf->staticset);
			free($3);
		}
		| NETWORK CONNECTED filter_set	{
			/* keep for compatibility till after next release */
			conf->flags |= BGPD_FLAG_REDIST_CONNECTED;
			move_filterset($3, &conf->connectset);
			free($3);
@


1.248
log
@Add support for BGP MPLS VPN aka RFC 4364. This is only the RDE part so
that it is possible to use OpenBGPD as a route-reflector for VPNv4.
Some clean up of the BGP MP code so that multiple protocols are easier
supported. kroute/kernel support not yet done but comming.
OK henning@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.247 2010/01/11 03:24:35 deraadt Exp $ */
d1476 18
d2762 1
@


1.247
log
@lex <=, >=, !=, and >< into a single token for correctness and to reduce the
lookahead in the parser
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.246 2009/12/16 15:40:55 claudio Exp $ */
d855 1
a855 1
			} else if (!strcmp($3, "unicast"))
d857 3
a859 1
			else {
@


1.246
log
@Implement "set ext-community [delete] subtype key:value" to set and delete
extended communities as specified in RFC 4360. No matching implemented yet
and stuff like * and neighbor-as are neither supported but will be soon.
Looks good henning & sthen, manpage fixed by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.245 2009/12/09 12:52:07 claudio Exp $ */
d186 1
d1846 2
a1847 2
		| '!' '='	{ $$ = OP_NE; }
		| '<' '='	{ $$ = OP_LE; }
d1849 1
a1849 1
		| '>' '='	{ $$ = OP_GE; }
d1854 1
a1854 1
		| '>' '<'	{ $$ = OP_XRANGE; }
d2164 20
@


1.245
log
@parsecommunity() always works on a struct filter_community. So pass a
pointer to the struct instead of two int pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.244 2009/12/09 11:12:50 claudio Exp $ */
d132 4
d178 2
a179 1
%token	PREFIX PREFIXLEN SOURCEAS TRANSITAS PEERAS COMMUNITY DELETE
d1799 18
d1914 1
d2579 150
d3110 5
d3137 9
@


1.244
log
@parsecommunity() does not allow to set unknown well-known communities.
So there is no need to check that again. Switch a USHRT_MAX to
COMMUNITY_WELLKNOWN to make the compare clearer, the values are the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.243 2009/12/08 14:03:40 claudio Exp $ */
d131 1
a131 1
int		 parsecommunity(char *, int *, int *);
d1462 1
a1462 2
			if (parsecommunity($2, &fmopts.m.community.as,
			    &fmopts.m.community.type) == -1) {
d1780 1
a1780 2
			if (parsecommunity($3, &$$->action.community.as,
			    &$$->action.community.type) == -1) {
d2509 1
a2509 1
parsecommunity(char *s, int *as, int *type)
d2512 1
a2512 1
	int i;
d2516 2
a2517 2
		*as = COMMUNITY_WELLKNOWN;
		*type = COMMUNITY_NO_EXPORT;
d2520 2
a2521 2
		*as = COMMUNITY_WELLKNOWN;
		*type = COMMUNITY_NO_ADVERTISE;
d2524 2
a2525 2
		*as = COMMUNITY_WELLKNOWN;
		*type = COMMUNITY_NO_EXPSUBCONFED;
d2528 2
a2529 2
		*as = COMMUNITY_WELLKNOWN;
		*type = COMMUNITY_NO_PEER;
d2545 1
a2545 1
	*as = i;
d2549 2
a2550 1
	*type = i;
@


1.243
log
@Big AID change part two. This changes the mp capability into an array of
flags. This makes a lot of code much easier since the comparison is now
trivial. Additionally calculate the negotiated capabilities for a session
in the SE and pass that and only that to the RDE. This makes the decisions
in the RDE a lot easier.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.242 2009/12/06 11:42:22 claudio Exp $ */
a1794 17
			/* Don't allow setting of unknown well-known types */
			if ($$->action.community.as == COMMUNITY_WELLKNOWN) {
				switch ($$->action.community.type) {
				case COMMUNITY_NO_EXPORT:
				case COMMUNITY_NO_ADVERTISE:
				case COMMUNITY_NO_EXPSUBCONFED:
				case COMMUNITY_NO_PEER:
					/* valid */
					break;
				default:
					/* unknown */
					yyerror("Invalid well-known community");
					free($$);
					YYERROR;
					break;
				}
			}
d2543 1
a2543 1
	if (i == USHRT_MAX) {
@


1.242
log
@Doh, switch src and dst in memcpy calls or the wrong thing gets copied.
For some reasons memcpy has the argument reversed - grmbl.
Found the hard way by Insan Praja.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.241 2009/12/01 14:28:05 claudio Exp $ */
d700 4
a703 14
			switch (curpeer->conf.remote_addr.aid) {
			case AID_INET:
				if (curpeer->conf.capabilities.mp_v4 !=
				    SAFI_ALL)
					break;
				curpeer->conf.capabilities.mp_v4 = SAFI_UNICAST;
				break;
			case AID_INET6:
				if (curpeer->conf.capabilities.mp_v6 !=
				    SAFI_ALL)
					break;
				curpeer->conf.capabilities.mp_v6 = SAFI_UNICAST;
				break;
			}
d843 2
a844 1
			u_int8_t	safi;
d846 4
a849 3
			if (!strcmp($3, "none"))
				safi = SAFI_NONE;
			else if (!strcmp($3, "unicast"))
d859 3
a861 9
			switch ($2) {
			case AFI_IPv4:
				curpeer->conf.capabilities.mp_v4 = safi;
				break;
			case AFI_IPv6:
				curpeer->conf.capabilities.mp_v6 = safi;
				break;
			default:
				fatal("king bula sees borked AFI");
d863 1
d2577 1
d2588 2
a2589 2
	p->conf.capabilities.mp_v4 = SAFI_ALL;
	p->conf.capabilities.mp_v6 = SAFI_ALL;
d2880 2
d2932 3
a2934 4
	if (p->conf.capabilities.mp_v4 == SAFI_ALL)
		p->conf.capabilities.mp_v4 = SAFI_NONE;
	if (p->conf.capabilities.mp_v6 == SAFI_ALL)
		p->conf.capabilities.mp_v6 = SAFI_NONE;
@


1.241
log
@Use an artificial address family id in struct bgpd_addr and almost everywhere
else. Adds conversion functions to map AFI/SAFI and the Unix AF_ values
from and into AID used in bgpd.  This is needed to support things like MPLS
VPN and other upcomming changes that need to play a lot with AFI/SAFI pairs.
Mostly mechanical change, henning@@ has no particular issues with this.
Must go in so that I can continue working.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.240 2009/11/26 13:40:43 henning Exp $ */
d357 1
a357 1
			memcpy(addr2sa(&$3, BGP_PORT), &la->sa, sizeof(la->sa));
@


1.240
log
@support for set origin; based on an initial diff from
Sebastian Benoit <benoit-lists at fb12 dot de> who also tested this version
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.239 2009/11/11 13:48:34 claudio Exp $ */
d108 1
a108 1
	sa_family_t		 af;
d327 1
a327 1
			if ($2.af != AF_INET) {
a350 2
			struct sockaddr_in	*in;
			struct sockaddr_in6	*in6;
d357 1
a357 22
			la->sa.ss_family = $3.af;
			switch ($3.af) {
			case AF_INET:
				la->sa.ss_len = sizeof(struct sockaddr_in);
				in = (struct sockaddr_in *)&la->sa;
				in->sin_addr.s_addr = $3.v4.s_addr;
				in->sin_port = htons(BGP_PORT);
				break;
			case AF_INET6:
				la->sa.ss_len = sizeof(struct sockaddr_in6);
				in6 = (struct sockaddr_in6 *)&la->sa;
				memcpy(&in6->sin6_addr, &$3.v6,
				    sizeof(in6->sin6_addr));
				in6->sin6_port = htons(BGP_PORT);
				break;
			default:
				free(la);
				yyerror("king bula does not like family %u",
				    $3.af);
				YYERROR;
			}

d622 2
a623 2
			if (($$.af == AF_INET && len != 32) ||
			    ($$.af == AF_INET6 && len != 128)) {
d626 1
a626 1
				    len, $$.af == AF_INET ? 32 : 128);
d673 1
a673 1
			if ($$.prefix.af == AF_INET)
d697 2
a698 2
			if (($3.prefix.af == AF_INET && $3.len != 32) ||
			    ($3.prefix.af == AF_INET6 && $3.len != 128))
d700 2
a701 2
			switch (curpeer->conf.remote_addr.af) {
			case AF_INET:
d707 1
a707 1
			case AF_INET6:
d1095 1
a1095 1
			if ($2.af != AF_INET) {
d1348 1
a1348 1
			if (fmopts.af && fmopts.af != $1.prefix.af) {
d1353 1
a1353 1
				fmopts.af = $1.prefix.af;
d1449 1
a1449 1
			if (fmopts.af == 0) {
d1454 1
a1454 1
			if (fmopts.m.prefixlen.af) {
d1460 1
a1460 1
			fmopts.m.prefixlen.af = fmopts.af;
d1483 1
a1483 1
			if (fmopts.af) {
d1487 1
a1487 1
			fmopts.af = AF_INET;
d1490 1
a1490 1
			if (fmopts.af) {
d1494 1
a1494 1
			fmopts.af = AF_INET6;
d2751 1
a2751 1
		if (newpeer->conf.remote_addr.af) {
d2893 2
a2894 2
	if (p->conf.local_addr.af &&
	    p->conf.local_addr.af != p->conf.remote_addr.af) {
d2905 1
a2905 1
	    !p->conf.local_addr.af) {
d2992 2
a2993 2
				if (s->action.nexthop.af <
				    t->action.nexthop.af) {
@


1.239
log
@Plug two memory leaks in error pathes. Found by parfait. OK henning, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.238 2009/10/13 09:51:53 claudio Exp $ */
d176 1
a176 1
%token	PREPEND_SELF PREPEND_PEER PFTABLE WEIGHT RTLABEL
d184 1
a184 1
%type	<v.number>		espah family restart
d1849 6
d1857 15
d1975 1
@


1.238
log
@Disable graceful restart for now. The EOR marker is sent in the wrong place
and fixing this is not a two liner. Will be enabled again when I found out
how to fix this.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.237 2009/10/06 09:44:13 claudio Exp $ */
d375 1
@


1.237
log
@Add config knobs to enable/disable individual BGP capabilities per neighbor.
e.g. announce refresh no. With this be more aggressive when announcing our
capabilities and enable all of them by default. If there are troubles with
some neighbors adding the following config lines should bring you back
to the old behaviour:
announce refresh yes # was already on by default
announce restart no
announce as-4byte no # was only set on sessions to peers with 4byte AS nums
OK henning and sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.236 2009/09/04 13:08:49 claudio Exp $ */
d2603 1
a2603 1
	p->conf.capabilities.restart = 1;
@


1.236
log
@Make sure that a proper syntax error is produced when something else then
yes or no is used in a yes/no token. OK henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.235 2009/09/04 11:50:28 claudio Exp $ */
d165 2
a166 2
%token	ANNOUNCE DEMOTE CONNECTRETRY
%token	ENFORCE NEIGHBORAS CAPABILITIES REFLECTOR DEPEND DOWN SOFTRECONFIG
d903 9
d1907 1
d1965 1
d2603 2
a2604 2
	p->conf.capabilities.restart = 0;
	p->conf.capabilities.as4byte = 0;
a2923 4

	/* for testing: enable 4-byte AS number capability if necessary */
	if (conf->as > USHRT_MAX || p->conf.remote_as > USHRT_MAX)
		p->conf.capabilities.as4byte = 1;
@


1.235
log
@Use the address familiy of the neighbor IP to decide which MP type to use.
IPv4 session will still default to only announce inet unicast but now
IPv6 session will by default use announce inet6 unicast. The defaults
can be overridden on groups and in the neighbor itself but this new
behaviour is way more sane then the old one. OK henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.234 2009/08/31 13:03:31 claudio Exp $ */
d281 2
@


1.234
log
@Use UINT_MAX instead of ASNUM_MAX and get rid of this mostly useless define.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.233 2009/08/03 13:14:07 claudio Exp $ */
d720 14
d2587 2
a2588 2
	p->conf.capabilities.mp_v4 = SAFI_UNICAST;
	p->conf.capabilities.mp_v6 = SAFI_NONE;
d2931 6
@


1.233
log
@Make announce "self" work like all others (self is a bit special because
it's a keyword but "self" is not). OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.232 2009/07/20 14:56:20 claudio Exp $ */
d214 6
a219 2
			if ($1 < 0 || $1 >= ASNUM_MAX) {
				yyerror("AS too big: max %u", ASNUM_MAX - 1);
@


1.232
log
@Flag added RIBs as F_RIB_NOFIB | F_RIB_NOEVALUATE in the no-eval case even
though F_RIB_NOEVALUATE implicitly includes F_RIB_NOFIB.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.231 2009/06/06 01:10:29 claudio Exp $ */
d887 3
a889 1
			if (!strcmp($2, "none"))
@


1.231
log
@Some preliminary filter magic to support multiple RIBs on the filters.
It is ugly but does the trick for now. Filters will be rewritten anyway.
The rib specifier only makes sense on from rules. e.g. deny rib OMG from any
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.230 2009/06/06 01:07:01 claudio Exp $ */
d400 1
a400 1
			if (!add_rib($3, F_RIB_NOEVALUATE)) {
@


1.230
log
@Only the main Loc-RIB should update the FIB for now. So introduce a
F_RIB_NOFIB flag and apply it on all RIBs that are not F_RIB_NOEVALUATE.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.229 2009/06/05 20:46:43 claudio Exp $ */
d185 1
a185 1
%type	<v.string>		string
d1200 1
a1200 1
filterrule	: action quick direction filter_peer_h filter_match_h filter_set
d1207 24
a1230 3
			r.dir = $3;

			if (expand_rule(&r, $4, &$5, $6) == -1)
d1247 3
@


1.229
log
@Don't call the main RIB DEFAULT but Loc-RIB. Makes more sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.228 2009/06/05 19:52:32 claudio Exp $ */
d116 1
a116 1
int		 add_rib(char *, int);
d389 1
a389 1
			if (add_rib($3, 0)) {
d400 1
a400 1
			if (!add_rib($3, 1)) {
d826 1
d2300 1
a2300 1
	add_rib("Adj-RIB-In", 1);
d2653 1
a2653 1
add_rib(char *name, int noeval)
d2671 1
a2671 2
	if (noeval)
		rr->flags |= F_RIB_NOEVALUATE;
@


1.228
log
@Make it possible to bind peers to a specified RIB. Now only filters and
bgpctl are missing to have full support of multiple RIBs.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.227 2009/06/04 22:08:19 claudio Exp $ */
d2300 1
a2300 1
	add_rib("DEFAULT", 0);
@


1.227
log
@Make mrt understand alternate RIB plus remove some other static rib references.
There is still a problem with the mrt dumps because we only allow one in the
RDE. This needs some additional work.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.226 2009/06/04 04:46:42 claudio Exp $ */
d821 15
@


1.226
log
@Add "rde rib <name>" to the config and allow the rde to use these other RIBs.
Still a bit hackish, reload is missing and printconf as well. Looks good h@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.225 2009/05/27 04:18:21 reyk Exp $ */
d114 2
a115 1
int		 add_mrtconfig(enum mrt_type, char *, time_t, struct peer *);
d117 1
d494 1
a494 1
			if (add_mrtconfig(action, $3, $4, NULL) == -1) {
d500 30
d612 2
a613 1
			if (add_mrtconfig(action, $4, $5, curpeer) == -1) {
d2572 2
a2573 1
add_mrtconfig(enum mrt_type type, char *name, time_t timeout, struct peer *p)
d2578 3
d2616 14
d2641 3
a2643 5
	SIMPLEQ_FOREACH(rr, &ribnames, entry) {
		if (!strcmp(rr->name, name)) {
			yyerror("rib \"%s\" allready exists.", name);
			return (-1);
		}
d2658 12
@


1.225
log
@add an option to change the "connect-retry" timer which defaults to 120s.
this can be used to decrease the failover time in specific carp'ed
IBGP setups.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.224 2009/04/23 16:20:39 sthen Exp $ */
d42 1
d115 1
d160 1
a160 1
%token	RDE EVALUATE IGNORE COMPARE
d386 18
d1863 1
d2251 3
d2582 27
@


1.224
log
@allow bgpctl and bgpd.conf to contain 32-bit ASN written in ASPLAIN
format (RFC5396). ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.223 2009/03/31 21:03:48 tobias Exp $ */
d161 1
a161 1
%token	ANNOUNCE DEMOTE
d532 7
d1787 1
@


1.223
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.222 2009/03/26 13:59:30 henning Exp $ */
d210 2
a211 2
			if ($1 < 0 || $1 >= USHRT_MAX) {
				yyerror("AS too big: max %u", USHRT_MAX - 1);
@


1.222
log
@argh, do not reuse the global trans_as flag to be applied to the peer
specific or we had to widen the peer specific flags without need.
defien PERRFLAG_TRANS_AS instead and use that
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.221 2009/03/22 22:34:59 henning Exp $ */
d2129 1
a2129 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d2131 5
@


1.221
log
@make transparent-as yes|no settable peer neighbor with the global setting
acting as default.
per-neighbor requested by arnold nipper @@ decix, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.220 2009/03/18 19:41:41 claudio Exp $ */
d1063 1
a1063 1
				curpeer->conf.flags |= BGPD_FLAG_DECISION_TRANS_AS;
d1065 1
a1065 1
				curpeer->conf.flags &= ~BGPD_FLAG_DECISION_TRANS_AS;
d2491 2
a2492 2
	p->conf.flags = (conf->flags & BGPD_FLAG_DECISION_TRANS_AS);

@


1.220
log
@Introduce local_as in the peer config. This allows per peer local AS and
simplifies some code because it is possible to get the local AS from the
peer struct. Local AS needs more patching to work correctly though.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.219 2009/02/16 18:08:32 sthen Exp $ */
d1061 6
d2491 1
@


1.219
log
@typo in error message; "bigger that" -> "bigger than"
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.218 2008/10/17 13:02:55 henning Exp $ */
d2457 2
d2481 2
@


1.218
log
@bring in the findeol() fix from pfctl. list of affected parsers by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.217 2008/07/08 13:14:58 claudio Exp $ */
d1399 1
a1399 1
				yyerror("start prefixlen is bigger that end");
@


1.217
log
@Use correct format string specifier for int argument. Don't try to print it
as string. Fixes crash seen by Peter Bristow. "obviously ok" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.216 2008/06/15 10:19:21 claudio Exp $ */
a1935 1
	pushback_index = 0;
d1939 4
a1942 1
		c = lgetc(0);
@


1.216
log
@Allow bgpd to delete more then one community per filter rule. Fixes PR5807
tested by Raphael Ho long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.215 2008/02/26 10:09:58 mpf Exp $ */
d2384 1
a2384 1
		yyerror("Community %s is %s (max: %s)", s, errstr, USHRT_MAX);
@


1.215
log
@Have popfile() also close the main config file,
but only do the final popfile call after yyparse() is done.
This also fixes config reload on SIGHUP for some daemons.

Spotted by otto@@. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.214 2007/11/12 23:59:41 mpf Exp $ */
d2752 2
d2769 1
@


1.214
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.213 2007/10/20 14:24:02 pyr Exp $ */
d50 1
a50 1
} *file;
d1887 3
a1889 2
			yyerror("reached end of file while parsing quoted string");
			if (popfile() == EOF)
d1907 1
a1907 1
		if (popfile() == EOF)
d2149 1
a2149 1
	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
d2151 7
a2157 8
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
d2180 1
@


1.213
log
@ntpd and bgpd's turn to behave like the others.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.212 2007/10/16 20:01:23 mpf Exp $ */
a1903 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d1960 1
a1960 1
	while ((c = lgetc(0)) == ' ')
@


1.212
log
@Allow '=' to end a number in all lexers.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.211 2007/10/16 06:06:49 deraadt Exp $ */
d2129 2
a2130 1
	    (nfile->name = strdup(name)) == NULL)
d2132 1
d2134 1
a2185 1
		log_warnx("cannot open the main config file!");
@


1.211
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.210 2007/10/13 16:35:20 deraadt Exp $ */
d2038 1
a2038 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.210
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.208 2007/09/13 20:39:58 claudio Exp $ */
d2015 1
a2015 1
				if (next == quotec)
d2017 2
@


1.209
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d25 1
d31 1
d43 31
a87 18
TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
}				*file;

int	 yyerror(const char *, ...);
int	 yyparse(void);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(int);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);

a109 1
struct file	*include_file(const char *);
d126 2
a127 13
TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};

int	 symset(const char *, const char *, int);
char	*symget(const char *);
int	 getcommunity(char *);
int	 parsecommunity(char *, int *, int *);
d293 1
a293 1
			if ((nfile = include_file($2)) == NULL) {
d1867 1
a1867 1
lgetc(int inquot)
a1868 2
	FILE *f = file->stream;
	struct file	*prevfile;
d1885 7
a1891 2
	if (inquot) {
		c = getc(f);
d1895 2
a1896 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d1907 1
a1907 1
			c = getc(f);
d1909 1
a1909 1
		ungetc(c, f);
d1913 4
a1916 10
	while (c == EOF &&
	    (prevfile = TAILQ_PREV(file, files, entry)) != NULL) {
		prevfile->errors += file->errors;
		TAILQ_REMOVE(&files, file, entry);
		fclose(f);
		free(file->name);
		free(file);
		file = prevfile;
		f = file->stream;
		c = getc(f);
a1917 1

d1963 1
a1963 1
	int	 endc, next, c;
d2005 1
a2005 1
		endc = c;
d2007 1
a2007 1
			if ((c = lgetc(1)) == EOF)
d2013 1
a2013 1
				if ((next = lgetc(1)) == EOF)
d2015 1
a2015 1
				if (next == endc)
d2019 1
a2019 1
			} else if (c == endc) {
d2101 20
d2122 1
a2122 1
include_file(const char *name)
a2128 1

d2130 2
a2131 1
		log_warn("%s", nfile->name);
d2134 2
a2135 2

	if (check_file_secrecy(fileno(nfile->stream), nfile->name)) {
a2140 1

d2143 7
d2151 10
a2160 1
	return (nfile);
d2175 6
a2180 1
	if ((file = include_file(filename)) == NULL) {
a2184 2
	if ((conf = calloc(1, sizeof(struct bgpd_config))) == NULL)
		fatal(NULL);
a2205 1
	conf->opts = xconf->opts;
d2215 1
a2296 5

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
@


1.208
log
@Move parser to use NUMBER as all other parse.y do know. A bit tricky because
all the relative metrics need some special handling. OK henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.207 2007/05/31 18:38:58 claudio Exp $ */
d68 1
a68 1
int	 lgetc(void);
d1864 1
a1864 1
lgetc(void)
d1866 1
a1866 1
	int		 c, next;
d1868 1
d1884 7
a1890 2
	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
d1901 1
a1901 1
			c = getc(file->stream);
d1903 1
a1903 1
		ungetc(c, file->stream);
d1911 1
a1911 1
		fclose(file->stream);
d1915 2
a1916 1
		c = getc(file->stream);
d1948 1
a1948 1
		c = lgetc();
d1964 1
a1964 1
	int	 endc, c;
d1969 1
a1969 1
	while ((c = lgetc()) == ' ')
d1974 1
a1974 1
		while ((c = lgetc()) != '\n' && c != EOF)
d1978 1
a1978 1
			if ((c = lgetc()) == EOF)
d1995 1
a1995 1
			yyerror("macro \"%s\" not defined", buf);
d2008 1
a2008 1
			if ((c = lgetc()) == EOF)
a2009 4
			if (c == endc) {
				*p = '\0';
				break;
			}
d2013 10
d2046 1
a2046 1
		} while ((c = lgetc()) != EOF && isdigit(c));
d2054 2
a2055 1
			yylval.v.number = strtonum(buf, LLONG_MIN, LLONG_MAX, &errstr);
d2057 2
a2058 1
				yyerror("\"%s\" invalid number: %s", buf, errstr);
d2085 1
a2085 1
		} while ((c = lgetc()) != EOF && (allowed_in_string(c)));
@


1.207
log
@Init community in get_rule() to COMMUNITY_UNSET. get_rule() is called when
set is used inside neighbor or group statements and the result was that
these rules no longer machted everything. Problem found by Jon Morby.
Please commit henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.206 2007/05/31 04:06:04 claudio Exp $ */
d128 1
a128 1
		u_int32_t		 number;
d175 2
a176 1
%type	<v.number>		number asnumber as4number optnumber yesno inout
d206 2
a207 17
number		: STRING			{
			u_int32_t	 uval;
			const char	*errstr;

			uval = strtonum($1, 0, UINT_MAX, &errstr);
			if (errstr) {
				yyerror("number %s is %s", $1, errstr);
				free($1);
				YYERROR;
			} else
				$$ = uval;
			free($1);
		}
		;

asnumber	: number			{
			if ($1 >= USHRT_MAX) {
d234 1
a234 6
				uval = strtonum($1, 0, USHRT_MAX - 1, &errstr);
				if (errstr) {
					yyerror("number %s is %s", $1, errstr);
					free($1);
					YYERROR;
				}
d236 1
d245 9
d320 4
a323 4
		| HOLDTIME number	{
			if ($2 < MIN_HOLDTIME) {
				yyerror("holdtime must be at least %u",
				    MIN_HOLDTIME);
d328 4
a331 4
		| HOLDTIME YMIN number	{
			if ($3 < MIN_HOLDTIME) {
				yyerror("holdtime min must be at least %u",
				    MIN_HOLDTIME);
d452 6
d522 1
a522 1
		| RTABLE number {
d534 6
d585 1
a585 1
prefix		: STRING '/' number	{
d588 6
a593 1
			if (asprintf(&s, "%s/%u", $1, $3) == -1)
d604 18
d642 1
a642 1
		| number
d746 1
a746 1
		| MULTIHOP number	{
d759 4
a762 4
		| HOLDTIME number	{
			if ($2 < MIN_HOLDTIME) {
				yyerror("holdtime must be at least %u",
				    MIN_HOLDTIME);
d767 4
a770 4
		| HOLDTIME YMIN number	{
			if ($3 < MIN_HOLDTIME) {
				yyerror("holdtime min must be at least %u",
				    MIN_HOLDTIME);
d828 5
a832 1
		| MAXPREFIX number restart {
d880 1
a880 1
		| IPSEC espah inout SPI number STRING STRING encspec {
d932 6
d1061 1
a1061 1
		| RESTART number	{
d1380 1
a1380 1
prefixlenop	: unaryop number		{
d1382 1
a1382 1
			if ($2 > 128) {
d1389 1
a1389 1
		| number binaryop number	{
d1391 1
a1391 1
			if ($1 > 128 || $3 > 128) {
d1440 5
a1444 1
filter_set_opt	: LOCALPREF number		{
d1447 7
a1453 2
			$$->type = ACTION_SET_LOCALPREF;
			$$->action.metric = $2;
d1455 3
a1457 3
		| LOCALPREF '+' number		{
			if ($3 > INT_MAX) {
				yyerror("localpref too big: max %u", INT_MAX);
d1465 3
a1467 3
		| LOCALPREF '-' number		{
			if ($3 > INT_MAX) {
				yyerror("localpref to small: min -%u", INT_MAX);
d1475 5
a1479 1
		| MED number			{
d1482 7
a1488 2
			$$->type = ACTION_SET_MED;
			$$->action.metric = $2;
d1490 3
a1492 3
		| MED '+' number			{
			if ($3 > INT_MAX) {
				yyerror("metric too big: max %u", INT_MAX);
d1500 3
a1502 3
		| MED '-' number			{
			if ($3 > INT_MAX) {
				yyerror("metric to small: min -%u", INT_MAX);
d1510 5
a1514 1
		| METRIC number			{	/* alias for MED */
d1517 7
a1523 2
			$$->type = ACTION_SET_MED;
			$$->action.metric = $2;
d1525 3
a1527 3
		| METRIC '+' number			{
			if ($3 > INT_MAX) {
				yyerror("metric too big: max %u", INT_MAX);
d1535 3
a1537 3
		| METRIC '-' number			{
			if ($3 > INT_MAX) {
				yyerror("metric to small: min -%u", INT_MAX);
d1545 5
a1549 1
		| WEIGHT number				{
d1552 7
a1558 2
			$$->type = ACTION_SET_WEIGHT;
			$$->action.metric = $2;
d1560 3
a1562 3
		| WEIGHT '+' number			{
			if ($3 > INT_MAX) {
				yyerror("weight too big: max %u", INT_MAX);
d1570 3
a1572 3
		| WEIGHT '-' number			{
			if ($3 > INT_MAX) {
				yyerror("weight to small: min -%u", INT_MAX);
d1607 5
a1611 1
		| PREPEND_SELF number		{
d1615 5
a1619 2
			if ($2 > 128) {
				yyerror("too many prepends");
a1621 3
			$$->action.prepend = $2;
		}
		| PREPEND_PEER number		{
a1624 4
			if ($2 > 128) {
				yyerror("too many prepends");
				YYERROR;
			}
d2021 34
@


1.206
log
@Even so some IX in germany likes to abuse 0 as AS community number we should
not allow anybody to use 65535. That one is reserved for well known
communities. Add in that check again.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.205 2007/05/28 17:26:33 henning Exp $ */
d2698 1
@


1.205
log
@allow matching on communities using 0 in the AS part, that is in use.
that unfortunately means we cannot use 0 for "unset".
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.204 2007/04/23 13:04:24 claudio Exp $ */
d2273 4
@


1.204
log
@Make bgpd 4-byte AS compatible. All internal representations of AS numbers
are now 4-byte instead of the old 2-byte numbers. The only exception are
communities because they can not be switched. The RDE will inflate and deflate
the ASPATH and AGGREGATOR attributes on demand and create the NEW_ASPATH and
NEW_AGGREGATOR field whenever needed. Both old and new stile sessions are
supported and can be mixed. Currently new stile sessions with the 4-byte AS
number capability turned on are only enabled if one of the AS numbers involved
is a 4-byte one.
This is based on an initial diff by Geoff Huston gih (at) apnic (dot) net
Cleanup, testing and bug-fixes by myself (via AS 3.10).
Currently mrt table dumps are producing incompatible output this will be fixed
afterwards -- this diff is already big enough.

"get it in if you think it is ready" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.203 2007/04/17 17:17:45 claudio Exp $ */
d1270 8
a1277 2
filter_match_h	: /* empty */			{ bzero(&$$, sizeof($$)); }
		| { bzero(&fmopts, sizeof(fmopts)); }
d1316 1
a1316 1
			if (fmopts.m.community.as) {
a2272 4
	if (i == 0 || i == USHRT_MAX) {
		yyerror("Bad community AS number");
		return (-1);
	}
@


1.203
log
@Make "network inet connected" work again. inet and inet6 became keywords
some time ago. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.202 2007/03/29 13:09:26 claudio Exp $ */
d175 2
a176 2
%type	<v.number>		number asnumber optnumber yesno inout espah
%type	<v.number>		family restart
d227 38
a264 1
string		: string STRING				{
d273 1
a273 1
yesno		:  STRING		{
d296 1
a296 1
include		: INCLUDE STRING	{
d311 1
a311 1
conf_main	: AS asnumber		{
d313 8
d702 1
a702 1
peeropts	: REMOTEAS asnumber	{
d1262 1
a1262 1
filter_as	: asnumber		{
d2298 1
d2559 4
@


1.202
log
@Until now prefixlen defaulted to AF_INET if it was used without a prefix.
This makes prefixlen filtering for AF_INET6 unnecessary complex. From now
on if prefixlen is used alone the address family needs to be specified
beforehands via the new inet or inet6 keywords.
Remove an old check so that it is finally possible to filter IPv6 prefixes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.201 2007/03/06 16:52:48 henning Exp $ */
d373 2
a374 2
		| NETWORK STRING STATIC filter_set	{
			if (!strcmp($2, "inet")) {
d377 1
a377 1
			} else if (!strcmp($2, "inet6")) {
d380 4
a384 1
			free($2);
d387 2
a388 2
		| NETWORK STRING CONNECTED filter_set	{
			if (!strcmp($2, "inet")) {
d391 1
a391 1
			} else if (!strcmp($2, "inet6")) {
d394 4
a398 1
			free($2);
@


1.201
log
@allow filtering on peer-as (leftmost AS in path), ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.200 2007/02/22 08:34:18 henning Exp $ */
d92 1
a1030 7
			struct filter_prefix_l	*l;

			for (l = $5.prefix_l; l != NULL; l = l->next)
				if (l->p.addr.af && l->p.addr.af != AF_INET) {
					yyerror("king bula sez: AF_INET only");
					YYERROR;
				}
d1143 6
d1238 5
d1249 1
a1249 1
			fmopts.m.prefixlen.af = AF_INET;
d1271 14
d1661 2
@


1.200
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.199 2007/01/26 21:34:21 claudio Exp $ */
d166 1
a166 1
%token	PREFIX PREFIXLEN SOURCEAS TRANSITAS COMMUNITY DELETE
d1296 1
d1664 1
@


1.199
log
@AS 65535 aka USHRT_MAX is reserved and may not be used so adapt the
range check. Found while hacking on 4-byte AS support.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.198 2006/12/05 12:08:13 henning Exp $ */
d2145 1
a2145 1
	int	 	 val;
@


1.198
log
@implement the ttl security hack. since the pc slaves fear the word hack,
they call it "Generalized TTL Security Mechanism" officially, RFC 3682.
manpage with help from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.197 2006/11/28 16:39:34 henning Exp $ */
d220 2
a221 2
			if ($1 > USHRT_MAX) {
				yyerror("AS too big: max %u", USHRT_MAX);
@


1.197
log
@allow bgpd to work on alternate routing tables, claudio ok, jmc manpage help
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.196 2006/10/25 18:48:29 henning Exp $ */
d161 1
a161 1
%token	TCP MD5SIG PASSWORD KEY
d885 3
d1689 1
@


1.196
log
@use strtonum, Pierre-Yves Ritschard <pyr@@spootnik.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.195 2006/09/19 12:15:29 henning Exp $ */
d153 1
a153 1
%token	AS ROUTERID HOLDTIME YMIN LISTEN ON FIBUPDATE
d473 7
d1674 1
@


1.195
log
@save the parser state in one big struct, and make it interchangable, aka
make the parser restartable. with that implement "include" file support.
makes life a _lot_ easier with filter generation tools. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.193 2006/08/27 16:11:05 henning Exp $ */
a121 1
int	 atoul(char *, u_long *);
d205 2
a206 1
			u_long	ulval;
d208 3
a210 2
			if (atoul($1, &ulval) == -1) {
				yyerror("\"%s\" is not a number", $1);
d214 1
a214 1
				$$ = ulval;
a2130 16
atoul(char *s, u_long *ulvalp)
{
	u_long	 ulval;
	char	*ep;

	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
		return (-1);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (-1);
	*ulvalp = ulval;
	return (0);
}

int
d2133 2
a2134 1
	u_long	ulval;
d2140 3
a2142 6
	if (atoul(s, &ulval) == -1) {
		yyerror("\"%s\" is not a number", s);
		return (COMMUNITY_ERROR);
	}
	if (ulval > USHRT_MAX) {
		yyerror("Community too big: max %u", USHRT_MAX);
d2145 1
a2145 1
	return (ulval);
@


1.194
log
@kill useless debug code that somehow snuck in, some 2 years ago...
@
text
@a52 3
static FILE			*fin = NULL;
static int			 lineno = 1;
static int			 errors = 0;
d54 9
a62 1
char				*infile;
d68 1
a68 1
int	 lgetc(FILE *);
d94 1
d170 1
a170 1
%token	ERROR
d196 1
d202 1
a202 1
		| grammar error '\n'		{ errors++; }
d257 15
d1579 1
a1579 1
	errors = 1;
d1581 1
a1581 1
	if (asprintf(&nfmt, "%s:%d: %s", infile, yylval.lineno, fmt) == -1)
d1629 1
d1699 1
a1699 1
lgetc(FILE *f)
d1701 2
a1702 1
	int	c, next;
d1718 2
a1719 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d1724 2
a1725 2
		yylval.lineno = lineno;
		lineno++;
d1730 1
a1730 1
			c = getc(f);
d1732 1
a1732 1
		ungetc(c, f);
d1736 11
d1776 1
a1776 1
		c = lgetc(fin);
d1778 1
a1778 1
			lineno++;
d1797 1
a1797 1
	while ((c = lgetc(fin)) == ' ')
d1800 1
a1800 1
	yylval.lineno = lineno;
d1802 1
a1802 1
		while ((c = lgetc(fin)) != '\n' && c != EOF)
d1806 1
a1806 1
			if ((c = lgetc(fin)) == EOF)
d1836 1
a1836 1
			if ((c = lgetc(fin)) == EOF)
d1843 1
a1843 1
				lineno++;
d1871 1
a1871 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
d1880 2
a1881 2
		yylval.lineno = lineno;
		lineno++;
d1888 27
d1925 1
d1927 2
a1928 8
	if ((fin = fopen(filename, "r")) == NULL) {
		warn("%s", filename);
		return (-1);
	}
	infile = filename;

	if (check_file_secrecy(fileno(fin), filename)) {
		fclose(fin);
a1953 2
	lineno = 1;
	errors = 0;
d1964 1
a1964 2

	fclose(fin);
d2046 5
@


1.193
log
@add code to announce the restart capability according to
draft-ietf-idr-restart. Do not announce actual restart capabilities,
so that this only serves as indicator that we are capable of sending
and receiving the End-of-RIB marker.
leave disabled for now, since the code to actually send the EoR-marker
is currently ifdef'd out (to be fixed soon) and we wanna play safe for
4.0. and juniper doesn't support that capability (which is not a problem
per se) and at the same time has its capability negotiation code completely
fucked up, if a capability is rejected they don't indicate WHICH capability
they reject (which makes that a problem, tho still a small one and we cope).
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.192 2006/08/04 12:01:48 henning Exp $ */
a55 1
static int			 pdebug = 1;
d1662 1
a1662 3
	if (p) {
		if (pdebug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
d1664 1
a1664 3
	} else {
		if (pdebug > 1)
			fprintf(stderr, "string: %s\n", s);
a1665 1
	}
@


1.192
log
@add "restart" to max-prefix, allows sessions suspended due to reaching
max-prefix to be restarted automagically after a given number of minutes
requested by "Sylwester S. Biernacki" <obeer@@obeer.com>, manpage help jmc,
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.191 2006/06/17 14:06:09 henning Exp $ */
d2175 1
@


1.191
log
@implement carp demotion control for bgpd.
sessions can be configured to modify the carp demotion counter for a
given interface group (usually, "carp", which has all carp interfaces)
when the session is not established. once the session is established for
60 seconds, the demotion is cleared.
this, used correctly, can prevent a bgpd-box which lost all sessions (and
thus has no routes) to be carp master, while the backup has sessions.
thought through and partially hacked on a drive from calgary to vancouver
with ryan, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.190 2006/05/31 02:16:25 pat Exp $ */
d152 2
a153 1
%token	REMOTEAS DESCR LOCALADDR MULTIHOP PASSIVE MAXPREFIX ANNOUNCE DEMOTE
d171 1
a171 1
%type	<v.number>		family
d721 1
a721 1
		| MAXPREFIX number {
d723 1
d940 11
d1640 1
@


1.190
log
@Plug memory leaks in error path; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.189 2006/05/26 01:06:12 deraadt Exp $ */
d152 1
a152 1
%token	REMOTEAS DESCR LOCALADDR MULTIHOP PASSIVE MAXPREFIX ANNOUNCE
d912 18
d1579 1
@


1.189
log
@\<char> is <char> except for \<newline> -- no exceptions.  much like how
other things work.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.188 2006/04/26 17:13:14 claudio Exp $ */
d1423 1
d1431 1
d1437 1
d1451 1
@


1.188
log
@Remove filterset_names from bgpd.h and replace it with a function because
the table was already out of sync now. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.187 2006/04/18 19:26:55 henning Exp $ */
d1666 1
a1666 3
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, f);
@


1.187
log
@cannot see the string self in the ANNOUNCE STRING prod any more since
self is a token now
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.186 2006/04/18 19:00:52 claudio Exp $ */
d2435 1
a2435 1
				    filterset_names[s->type]);
@


1.186
log
@Fix "announce self" that got broken by "nexthop self". Found by Thomas Bader.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.185 2006/04/04 12:03:26 henning Exp $ */
d700 1
a700 3
			if (!strcmp($2, "self"))
				curpeer->conf.announce_type = ANNOUNCE_SELF;
			else if (!strcmp($2, "none"))
@


1.185
log
@add "set nexthop self", force nexthop to be set to own address even with IBGP
requested & tested Falk Brockerhoff <fb@@smartterra.de>, and tony sarendal
tested this too. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.184 2006/03/22 13:30:35 claudio Exp $ */
d693 6
a854 3
		}
		| ANNOUNCE CAPABILITIES yesno {
			curpeer->conf.announce_capa = $3;
@


1.184
log
@Change the way bgpd selects nexthops. Up until now every route was considered
when calculating the nexthop. Now only non BGP routes and not the default
route are used unless forced with the new config options
 nexthop qualify via bgp
 nexthop qualify via default
This change is required for complex setups e.g. where an additional IGP is
running.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.183 2006/03/07 19:47:03 claudio Exp $ */
d162 1
a162 1
%token	SET LOCALPREF MED METRIC NEXTHOP REJECT BLACKHOLE NOMODIFY
d1389 5
d1607 1
d2514 1
@


1.183
log
@Fix a bug reported by Xavier Beaudouin. On config reloads set parameters
inside group blocks were reset to default values. The problem was that
group ids changed on reload as soon as a new peer was added to one group.
Make sure that group ids remain the same over reloads a similar thing is
already done for peer ids. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.182 2006/03/04 19:33:22 miod Exp $ */
d167 1
d437 13
d1593 1
d1611 1
@


1.182
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.181 2006/02/10 14:34:40 claudio Exp $ */
d2203 2
a2204 2
	if (newpeer->conf.remote_addr.af)
		for (p = peer_l_old; p != NULL; p = p->next)
d2211 6
d2220 2
a2221 1
		for (p = peer_l_old; p != NULL && p->conf.id != id; p = p->next)
@


1.181
log
@Make it possible to turn suftreconfig in/out on or off. Default is on for
both directions. Manpage update follows. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.180 2006/02/09 21:05:09 claudio Exp $ */
d1257 1
a1257 1
				yyerror("localpref to big: max %u", INT_MAX);
d1283 1
a1283 1
				yyerror("metric to big: max %u", INT_MAX);
d1309 1
a1309 1
				yyerror("metric to big: max %u", INT_MAX);
d1335 1
a1335 1
				yyerror("weight to big: max %u", INT_MAX);
@


1.180
log
@Implement "set community delete 65001:*" and friends. This will remove
communities from the path attributes. Useful to make sure that the ones you
set later are set by a (evil) peer.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.179 2006/02/02 14:06:05 claudio Exp $ */
d153 1
a153 1
%token	ENFORCE NEIGHBORAS CAPABILITIES REFLECTOR DEPEND DOWN
d897 6
d1588 1
d2117 2
@


1.179
log
@Implement new special community "neighbor-as". neighbor-as is expanded on
the fly to the remote AS of the current neighbor. This can be used to
simplify rulesets in a dramatic way -- going from a script based nightmare
down to a handfull rules. jajajaja henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.178 2006/01/07 14:50:28 claudio Exp $ */
d161 1
a161 1
%token	PREFIX PREFIXLEN SOURCEAS TRANSITAS COMMUNITY
d173 1
a173 1
%type	<v.u8>			action quick direction
d1239 4
d1426 1
a1426 1
		| COMMUNITY STRING		{
d1429 6
a1434 2
			$$->type = ACTION_SET_COMMUNITY;
			if (parsecommunity($2, &$$->action.community.as,
d1436 2
a1437 1
				free($2);
d1440 1
a1440 1
			free($2);
d1442 2
a1443 2
			if ($$->action.community.as == COMMUNITY_ANY ||
			    $$->action.community.type == COMMUNITY_ANY) {
d1445 1
d1460 1
d1530 1
@


1.178
log
@Add COMMUNITY_NO_PEER to the list of known wellknown communities else it
is not possible to use NO_PEER as community in the config.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.177 2005/11/29 16:01:00 claudio Exp $ */
d1432 6
d2022 2
@


1.177
log
@superfluous ; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.176 2005/11/01 21:42:58 claudio Exp $ */
d1438 1
@


1.176
log
@Sort filter_set with equal type as well. This affects community
attributes and set nexthop. Now the full filter set list is sorted.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.175 2005/11/01 18:11:24 claudio Exp $ */
d184 1
a184 1
%type	<v.encspec>		encspec;
@


1.175
log
@Relative metrics should be stored in relative and not metric. The one
is singed the other not.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.174 2005/11/01 17:34:58 claudio Exp $ */
d2380 1
a2380 1
	TAILQ_FOREACH(t, sh, entry)
d2385 24
@


1.174
log
@Make sure, that the list of filter_sets is ordered. Makes comparing easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.173 2005/11/01 10:58:29 claudio Exp $ */
d1279 1
a1279 1
			$$->action.metric = $3;
d1331 1
a1331 1
			$$->action.metric = $3;
@


1.173
log
@Switch from the per peer filter set list to a filter-only solution.
The default filter_sets are converted into match filter rules that get
evaluated first. Simplifies code massively -- mainly the config reload
part -- and makes softreconfig out a piece of cake.  "get it in" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.172 2005/10/19 10:42:06 henning Exp $ */
d2366 4
d2379 7
d2413 1
a2413 1
	if (source == NULL || TAILQ_EMPTY(source))
@


1.172
log
@new keyword "down" in neighbor spec, when givenm, the session is not
started on bgpd startup but stays in IDLE. requested by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.171 2005/08/09 20:27:25 claudio Exp $ */
d48 4
d104 1
d537 9
d571 9
d840 4
a843 1
			if (merge_filterset(&curpeer->conf.attrset, $2) == -1)
d847 1
d852 3
a854 3
				if (merge_filterset(&curpeer->conf.attrset, s)
				    == -1)
				YYERROR;
d1803 6
d1811 3
d1824 1
a1824 3
	/* filter and network list are always empty in the parent */
	filter_l = xfilter_l;
	TAILQ_INIT(filter_l);
d1827 2
d1870 10
d1889 18
d1911 3
a2088 1
	TAILQ_INIT(&p->conf.attrset);
a2108 2
		TAILQ_INIT(&p->conf.attrset);
		copy_filterset(&curgroup->conf.attrset, &p->conf.attrset);
d2411 35
@


1.171
log
@Introduce new route decision tunable "rde med compare (always|strict)".
If set to always the med will also be compared between different AS.
The default is strict which is the way the RFC specifies it.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.170 2005/07/28 20:01:21 henning Exp $ */
d148 1
a148 1
%token	ENFORCE NEIGHBORAS CAPABILITIES REFLECTOR DEPEND
d611 3
d1488 1
@


1.170
log
@keywords have to be sorted, and I can't sort properly
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.169 2005/07/28 16:27:01 henning Exp $ */
d145 1
a145 1
%token	RDE EVALUATE IGNORE
d418 13
d1480 1
@


1.169
log
@allow the to be announced SAFIs to be specified per peer, that is part of the
multiprotocol shitz
claudi needs this to proceed with v6 stuff in the RIB, print stuff and
manpage later
from whatthehack, claudio ok, marcm schnell schnell schnell
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.168 2005/07/04 09:37:24 claudio Exp $ */
d1458 2
a1478 2
		{ "IPv4",		IPV4},
		{ "IPv6",		IPV6},
@


1.168
log
@New function filterset_cmp() used two compare two struct filter_set for
equality. This function is a bit more complicated than a memcmp() because there
are types that need to be considered equal e.g. ACTION_SET_MED and
ACTION_SET_RELATIVE_MED. Also ACTION_SET_COMMUNITY and ACTION_SET_NEXTHOP
need some special care.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.167 2005/07/04 09:31:35 claudio Exp $ */
d161 1
d164 1
d614 26
d856 4
d1477 2
@


1.167
log
@Switch some parser rules from "string" to "STRING". "string" is to greedy
and hides possible typos. e.g. set { rtlabel foo localperf 100 } was a valid
syntax but the result was a route label with name "foo localperf 100".
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.166 2005/07/01 13:38:14 claudio Exp $ */
d2250 2
a2251 8
		if (s->type != t->type)
			continue;

		switch (s->type) {
		case ACTION_SET_COMMUNITY:
			if (s->action.community.as == t->action.community.as &&
			    s->action.community.type ==
			    t->action.community.type) {
d2253 3
a2255 9
				return (-1);
			}
			break;
		case ACTION_SET_NEXTHOP:
			if (s->action.nexthop.af != t->action.nexthop.af)
				break;
			/* FALLTHROUGH */
		default:
			yyerror("redefining set parameters is not fluffy");
a2261 1

@


1.166
log
@Switch filter_sets form SIMPLEQ to TAILQ, needed for upcomming stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.165 2005/06/29 09:43:25 claudio Exp $ */
d319 1
a319 1
		| LOG string		{
d1310 1
a1310 1
		| PFTABLE string		{
d1334 1
a1334 1
		| RTLABEL string		{
@


1.165
log
@rtlabel support via filter sets. Just use "set rtlabel foobar" in filters
network and neighbor statements and the routes are labeled accordingly.
While doing that fix some mem-leaks by introducing filterset_free() and
remove the free on send option of send_filterset().
This took a bit longer because we need to carefully track the rtlabel id
refcnts or bad things may happen on reloads.
henning@@ looks fine
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.164 2005/06/09 15:32:03 claudio Exp $ */
d98 2
d336 1
a336 5
			if ($3 == NULL || SIMPLEQ_EMPTY($3))
				SIMPLEQ_INIT(&n->net.attrset);
			else
				memcpy(&n->net.attrset, $3,
				    sizeof(n->net.attrset));
d344 1
a344 5
				if ($4 == NULL || SIMPLEQ_EMPTY($4))
					SIMPLEQ_INIT(&conf->staticset);
				else
					memcpy(&conf->staticset, $4,
					    sizeof(conf->staticset));
d347 1
a347 5
				if ($4 == NULL || SIMPLEQ_EMPTY($4))
					SIMPLEQ_INIT(&conf->staticset6);
				else
					memcpy(&conf->staticset6, $4,
					    sizeof(conf->staticset6));
d355 1
a355 5
				if ($4 == NULL || SIMPLEQ_EMPTY($4))
					SIMPLEQ_INIT(&conf->connectset);
				else
					memcpy(&conf->connectset, $4,
					    sizeof(conf->connectset));
d358 1
a358 5
				if ($4 == NULL || SIMPLEQ_EMPTY($4))
					SIMPLEQ_INIT(&conf->connectset6);
				else
					memcpy(&conf->connectset6, $4,
					    sizeof(conf->connectset6));
d366 1
a366 5
			if ($3 == NULL || SIMPLEQ_EMPTY($3))
				SIMPLEQ_INIT(&conf->staticset);
			else
				memcpy(&conf->staticset, $3,
				    sizeof(conf->staticset));
d372 1
a372 5
			if ($3 == NULL || SIMPLEQ_EMPTY($3))
				SIMPLEQ_INIT(&conf->connectset);
			else
				memcpy(&conf->connectset, $3,
				    sizeof(conf->connectset));
d779 2
a780 2
			while ((s = SIMPLEQ_FIRST($5)) != NULL) {
				SIMPLEQ_REMOVE_HEAD($5, entry);
d1144 2
a1145 2
			SIMPLEQ_INIT($$);
			SIMPLEQ_INSERT_TAIL($$, $2, entry);
d1159 2
a1160 2
			SIMPLEQ_INIT($$);
			SIMPLEQ_INSERT_TAIL($$, $1, entry);
d1970 1
a1970 1
	SIMPLEQ_INIT(&p->conf.attrset);
d1991 1
a1991 1
		SIMPLEQ_INIT(&p->conf.attrset);
d2104 1
a2104 1
				SIMPLEQ_INIT(&r->set);
d2149 2
a2150 2
		while ((s = SIMPLEQ_FIRST(set)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(set, entry);
d2249 1
a2249 1
	SIMPLEQ_FOREACH(t, sh, entry) {
d2271 1
a2271 1
	SIMPLEQ_INSERT_TAIL(sh, s, entry);
d2284 1
a2284 1
	SIMPLEQ_FOREACH(s, source, entry) {
d2288 1
a2288 1
		SIMPLEQ_INSERT_TAIL(dest, t, entry);
d2291 17
@


1.164
log
@Change the "network connected|static" statements to "network inet|inet6
connected|static" so that it is possible to distinguish between IPv4 and IPv6
addresses. "network connected|static" is considered deprecated but will be
supported as an alias for "network inet connected|static" for some time (one
release) to simplify upgrades. This also solve a nasty crash when using
"network connected".  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.163 2005/05/24 17:41:13 claudio Exp $ */
d156 1
a156 1
%token	PREPEND_SELF PREPEND_PEER PFTABLE WEIGHT
d1360 13
d1508 1
@


1.163
log
@Remove unnecessary error check that is already done in parsecommunity().
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.162 2005/04/28 13:54:45 claudio Exp $ */
a328 4
			if ($2.prefix.af != AF_INET) {
				yyerror("king bula sez: AF_INET only for now");
				YYERROR;
			}
d343 38
d382 1
d392 1
@


1.162
log
@Support for "network connected" and "network static" -- announce all
directly connected respectively all static routes. The list is auto-
matically adjusted as soon as a route changes.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.161 2005/04/17 16:41:21 henning Exp $ */
a1333 5
			if ($$->action.community.as <= 0 ||
			    $$->action.community.as > 0xffff) {
				yyerror("Invalid community");
				YYERROR;
			}
@


1.161
log
@and don't try to free a null set either
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.160 2005/04/17 16:36:40 henning Exp $ */
d153 1
d347 18
d1415 1
d1467 1
@


1.160
log
@fix null pointer deref on filter rules without set part
problem reported by  "Alexey E. Suslikov" <cruel@@texnika.com.ua>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.159 2005/04/13 21:16:22 claudio Exp $ */
d2108 6
a2113 3
	while (set != NULL && (s = SIMPLEQ_FIRST(set)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(set, entry);
		free(s);
a2114 1
	free(set);
@


1.159
log
@filter_set cleanup. Plug some memleaks and fix an obvious bug in the
network case. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.158 2005/04/12 14:32:00 claudio Exp $ */
d2108 1
a2108 1
	while ((s = SIMPLEQ_FIRST(set)) != NULL) {
@


1.158
log
@Introduce a per prefix weight.  The weight is used to tip prefixes with equal
long AS pathes in one or the other direction.  It weights a prefix at a very
late stage in the decision process. This is a nice bgpd feature to traffic
engineer networks where most AS pathes are equally long.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.157 2005/04/12 14:26:58 claudio Exp $ */
d337 6
a342 2
			memcpy(&n->net.attrset, &$3,
			    sizeof(n->net.attrset));
d2047 1
d2107 7
@


1.157
log
@Fix some yyerror messages. Ja ja, INT_MAX is to small... OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.156 2005/03/29 11:13:33 henning Exp $ */
d155 1
a155 1
%token	PREPEND_SELF PREPEND_PEER PFTABLE
d1209 26
d1446 2
a1447 1
		{ "transparent-as",	TRANSPARENT}
@


1.156
log
@walk & free network and filter lists after parse errors
ok claudio theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.155 2005/03/28 15:39:32 henning Exp $ */
d1139 1
a1139 1
				yyerror("metric to small: max %u", INT_MAX);
d1149 1
a1149 1
				yyerror("metric to small: min -%u", INT_MAX);
d1165 1
a1165 1
				yyerror("metric to small: max %u", INT_MAX);
d1191 1
a1191 1
				yyerror("metric to small: max %u", INT_MAX);
@


1.155
log
@walk & free peer_l after failed config parsing attempts
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.154 2005/03/23 22:26:34 claudio Exp $ */
d1633 2
a1653 2
	netconf = nc;
	TAILQ_INIT(netconf);
d1663 3
d1668 2
a1669 1
	conf->opts = xconf->opts;
d1700 10
@


1.154
log
@Move the neighbor checking code from merge_config() to neighbor_consistent()
where it belongs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.153 2005/03/16 10:50:26 henning Exp $ */
d1686 1
a1686 1
		/* XXX more leaks in this case? */
d1692 5
@


1.153
log
@don't try to merge the freshly parsed config into the running one if
we had parser failures...
debugging session with claudio and jason ackley
ok claudio norby deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.152 2005/03/14 17:32:04 claudio Exp $ */
d2117 21
@


1.152
log
@Allow to modify the metrics in a relative way by prepending the number with
a '+' or '-'. e.g. set localpref +20. This is another gem from the FOSDEM
lying around on my HD gathering dust. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.151 2005/03/13 15:27:30 henning Exp $ */
d1632 1
d1685 16
a1700 7
	errors += merge_config(xconf, conf, peer_l, listen_addrs);
	errors += mrt_mergeconfig(xmconf, mrtconf);
	*xpeers = peer_l;

	for (p = peer_l_old; p != NULL; p = pnext) {
		pnext = p->next;
		free(p);
@


1.151
log
@s/to many/too many/, from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.150 2005/03/11 12:54:19 claudio Exp $ */
d1137 20
d1163 20
d1188 20
@


1.150
log
@Finally commit the transparent-as and nexthop no-modify stuff I wrote on the
way to FOSDEM. With transparent-as set to ye bgpd will not prepend his own
AS for sent updates. NB the neighbor needs to set "enforce neighbor-as no"
or it will not like the received AS paths. With set nexthop no-modify bgpd
will change the nexthop as done normaly.
OK henning@@ man page update with help of jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.149 2004/12/23 16:09:26 henning Exp $ */
d1176 1
a1176 1
				yyerror("to many prepends");
d1186 1
a1186 1
				yyerror("to many prepends");
@


1.149
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.148 2004/11/23 13:07:01 claudio Exp $ */
d148 1
a148 1
%token	LOG ROUTECOLL
d154 1
a154 1
%token	SET LOCALPREF MED METRIC NEXTHOP REJECT BLACKHOLE
d310 6
d1166 5
d1337 1
d1359 2
a1360 1
		{ "transit-as",		TRANSITAS}
@


1.148
log
@Switch from a single filter_set to a linked list of sets. With this change
it is possible to specify multiple communities. This is also the first step
to better bgpd filters. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.147 2004/11/19 14:43:57 claudio Exp $ */
d2048 1
a2048 1
		
@


1.147
log
@For consistency reasons rename struct as_filter to struct filter_as.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.146 2004/11/19 10:03:34 claudio Exp $ */
d92 1
a92 1
		    struct filter_match_l *, struct filter_set *);
d95 3
a97 1
int		 merge_filterset(struct filter_set *, struct filter_set *);
d125 2
a126 1
		struct filter_set	 filter_set;
d169 2
a170 1
%type	<v.filter_set>		filter_set filter_set_l filter_set_opt
d734 1
a734 1
			if (merge_filterset(&curpeer->conf.attrset, &$2) == -1)
d738 6
a743 1
			if (merge_filterset(&curpeer->conf.attrset, &$5) == -1)
d745 2
d845 1
a845 1
			if (expand_rule(&r, $4, &$5, &$6) == -1)
d1100 7
a1106 2
filter_set	: /* empty */					{
			bzero(&$$, sizeof($$));
a1107 1
		| SET filter_set_opt				{ $$ = $2; }
d1113 1
a1113 1
			if (merge_filterset(&$$, &$3) == 1)
d1116 7
a1122 1
		| filter_set_opt
d1126 4
a1129 2
			$$.flags = SET_LOCALPREF;
			$$.localpref = $2;
d1132 4
a1135 2
			$$.flags = SET_MED;
			$$.med = $2;
d1138 4
a1141 2
			$$.flags = SET_MED;
			$$.med = $2;
d1144 5
a1148 2
			$$.flags = SET_NEXTHOP;
			memcpy(&$$.nexthop, &$2, sizeof($$.nexthop));
d1151 3
a1153 1
			$$.flags = SET_NEXTHOP_BLACKHOLE;
d1156 3
a1158 1
			$$.flags = SET_NEXTHOP_REJECT;
d1161 3
a1163 1
			$$.flags = SET_PREPEND_SELF;
d1168 1
a1168 1
			$$.prepend_self = $2;
d1171 3
a1173 1
			$$.flags = SET_PREPEND_PEER;
d1178 1
a1178 1
			$$.prepend_peer = $2;
d1181 3
a1183 1
			$$.flags = SET_PFTABLE;
d1190 3
a1192 2
			if (strlcpy($$.pftable, $2, sizeof($$.pftable)) >=
			    sizeof($$.pftable)) {
d1205 5
a1209 3
			$$.flags = SET_COMMUNITY;
			if (parsecommunity($2, &$$.community.as,
			    &$$.community.type) == -1) {
d1214 2
a1215 1
			if ($$.community.as <= 0 || $$.community.as > 0xffff) {
d1220 2
a1221 2
			if ($$.community.as == COMMUNITY_WELLKNOWN) {
				switch ($$.community.type) {
d1797 1
d1805 1
a1805 1
	struct peer	*p;
d1818 2
d1908 1
a1908 1
    struct filter_match_l *match, struct filter_set *set)
d1930 2
a1931 1
				memcpy(&r->set, set, sizeof(struct filter_set));
d2041 1
a2041 1
merge_filterset(struct filter_set *a, struct filter_set *b)
d2043 23
a2065 3
	if (a->flags & b->flags) {
		yyerror("redefining set parameters is not fluffy");
		return (-1);
d2067 18
a2084 18
	a->flags |= b->flags;
	if (b->flags & SET_LOCALPREF)
		a->localpref = b->localpref;
	if (b->flags & SET_MED)
		a->med = b->med;
	if (b->flags & SET_NEXTHOP)
		memcpy(&a->nexthop, &b->nexthop,
		    sizeof(a->nexthop));
	if (b->flags & SET_PREPEND_SELF)
		a->prepend_self = b->prepend_self;
	if (b->flags & SET_PREPEND_PEER)
		a->prepend_peer = b->prepend_peer;
	if (b->flags & SET_PFTABLE)
		strlcpy(a->pftable, b->pftable,
		    sizeof(a->pftable));
	if (b->flags & SET_COMMUNITY) {
		a->community.as = b->community.as;
		a->community.type = b->community.type;
a2085 1
	return (0);
@


1.146
log
@Make "set network 127.0.0.1" work and use = instead of |= for the
blackhole/reject case as $$ is not zeroed. This caused funny results in
merge_filterset(). OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.145 2004/11/18 17:07:38 henning Exp $ */
d77 1
a77 1
	struct as_filter	 a;
d1895 1
a1895 1
					    sizeof(struct as_filter));
@


1.145
log
@add an instance of struct capabilities to peer_conf, and inherit
peer->capa.ann from this
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.144 2004/11/11 10:35:15 claudio Exp $ */
d1117 1
d1121 1
a1121 1
			$$.flags |= SET_NEXTHOP_BLACKHOLE;
d1124 1
a1124 1
			$$.flags |= SET_NEXTHOP_REJECT;
@


1.144
log
@New config statement "rde route-age [evaluate|ignore]". If set to evaluate
the best path selection will not only be based on the path attributes but
also on the age of the prefix. This is an extension to the RFC. The default
is ignore but previously it was implicitly set to evaluate.
OK henning@@ man page OK jaredy@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.143 2004/11/05 14:30:54 henning Exp $ */
d727 1
a727 1
			curpeer->conf.capabilities = $3;
d1748 4
a1751 1
	p->conf.capabilities = 1;
@


1.143
log
@memleaks in error pathes, again awesome work from Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.142 2004/11/04 14:05:46 henning Exp $ */
d140 1
d353 20
d1256 1
d1261 1
d1291 1
@


1.142
log
@(try to) open the config file earlier, makes the error handling easier in
case we cannot. in fact there was one missing free(), thus this diff
plugs a little memory hole (without real-world relevance I guess).
From Patrick Latifi, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.141 2004/10/19 12:02:50 henning Exp $ */
d865 1
d885 1
@


1.141
log
@allow neighbor definitions to depend on interface state.
with this, if a neighbor is configured as dependent on carp0 for example,
the neighbor will remain in state IDLE as long as carp0 is not master.
once carp0 becomes master the session(s) depending on it immediately
go to CONNECT (or ACTIVE, if they're configured passive), reducing failover
time. claudio ok, with some input from ryan as well
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.140 2004/09/28 12:09:31 claudio Exp $ */
d1489 11
a1520 15

	if ((fin = fopen(filename, "r")) == NULL) {
		warn("%s", filename);
		free(conf);
		free(mrtconf);
		return (-1);
	}
	infile = filename;

	if (check_file_secrecy(fileno(fin), filename)) {
		fclose(fin);
		free(conf);
		free(mrtconf);
		return (-1);
	}
@


1.140
log
@Add prepend-neighbor feature. Prepend the remote-as n times similar to
prepend-self. Only for incomming UPDATEs. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.139 2004/08/24 15:33:48 henning Exp $ */
d142 1
a142 1
%token	ENFORCE NEIGHBORAS CAPABILITIES REFLECTOR
d743 12
d1228 1
@


1.139
log
@don't do the pftable_exists() check if we are running -n, needs root
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.138 2004/08/24 15:30:07 henning Exp $ */
d150 2
a151 1
%token	SET LOCALPREF MED METRIC NEXTHOP PREPEND PFTABLE REJECT BLACKHOLE
d1090 2
a1091 2
		| PREPEND number		{
			$$.flags = SET_PREPEND;
d1096 9
a1104 1
			$$.prepend = $2;
d1250 2
a1251 1
		{ "prepend-self",	PREPEND},
d1968 4
a1971 2
	if (b->flags & SET_PREPEND)
		a->prepend = b->prepend;
@


1.138
log
@correctly inherit conf->opts from xconf->opts in parse_config(),
foudn by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.137 2004/08/24 12:59:41 claudio Exp $ */
d1099 2
a1100 1
			if (pftable_exists($2) != 0) {
@


1.137
log
@back out rev. 1.136. I commited that unintentionally and it does not work
without other nastier changes in parse.y.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.135 2004/08/20 14:56:09 claudio Exp $ */
d1485 1
@


1.136
log
@Grrr. copy paste error. Dump MED and not local-pref. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.134 2004/08/17 16:06:39 claudio Exp $ */
d149 1
a149 1
%token	PREFIX PREFIXLEN SOURCEAS TRANSITAS EMPTYAS COMMUNITY
a1050 1
		| EMPTYAS	{ $$ = AS_EMPTY; }
a1207 1
		{ "empty-as",		EMPTYAS},
@


1.135
log
@foobar-AS -> foobar-as as already done in some places. mIXeD cASe keywords
are not fluffy. OK henning@@
@
text
@d149 1
a149 1
%token	PREFIX PREFIXLEN SOURCEAS TRANSITAS COMMUNITY
d1051 1
d1209 1
@


1.134
log
@Merge set constructs in neighbor statements. This fixes a common problem:
previous sets were cleared by the last one. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.133 2004/08/13 14:03:20 claudio Exp $ */
d1248 1
a1248 1
		{ "source-AS",		SOURCEAS},
d1252 1
a1252 1
		{ "transit-AS",		TRANSITAS}
@


1.133
log
@Fix minor issues with IPv6 dumps and add a function for dumping the RIB table
protocol independent. This new dump format is not (yet) supported by the
mrtd route_btoa tool. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.132 2004/08/10 13:02:08 claudio Exp $ */
d95 1
d708 2
a709 2
			memcpy(&curpeer->conf.attrset, &$2,
			    sizeof(curpeer->conf.attrset));
d712 2
a713 2
			memcpy(&curpeer->conf.attrset, &$5,
			    sizeof(curpeer->conf.attrset));
d1062 1
a1062 2
			if ($$.flags & $3.flags) {
				yyerror("redefining set shitz is not fluffy");
a1063 18
			}
			$$.flags |= $3.flags;
			if ($3.flags & SET_LOCALPREF)
				$$.localpref = $3.localpref;
			if ($3.flags & SET_MED)
				$$.med = $3.med;
			if ($3.flags & SET_NEXTHOP)
				memcpy(&$$.nexthop, &$3.nexthop,
				    sizeof($$.nexthop));
			if ($3.flags & SET_PREPEND)
				$$.prepend = $3.prepend;
			if ($3.flags & SET_PFTABLE)
				strlcpy($$.pftable, $3.pftable,
				    sizeof($$.pftable));
			if ($3.flags & SET_COMMUNITY) {
				$$.community.as = $3.community.as;
				$$.community.type = $3.community.type;
			}
d1938 27
@


1.132
log
@switch nexthop in struct filter_set form struct in_addr to struct bgpd_addr
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.131 2004/08/05 18:40:44 claudio Exp $ */
d142 1
a142 1
%token	DUMP TABLE IN OUT
d329 15
a343 2
		| DUMP TABLE STRING optnumber		{
			if (add_mrtconfig(MRT_TABLE_DUMP, $3, $4, NULL) == -1) {
a1267 1
		{ "table",		TABLE},
@


1.131
log
@tab at EOL
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.130 2004/08/03 13:46:22 claudio Exp $ */
d1086 1
a1086 7
			if ($2.af == AF_INET) {
				$$.flags = SET_NEXTHOP;
				$$.nexthop.s_addr = $2.v4.s_addr;
			} else {
				yyerror("king bula sez: AF_INET only for now");
				YYERROR;
			}
@


1.130
log
@deny hilarious prepends. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.129 2004/08/02 21:30:55 claudio Exp $ */
d880 1
a880 1
		;			
d943 1
a943 1
		;			
@


1.129
log
@Fix a possible mem leak and add a missing yyerror(). OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.128 2004/07/30 14:44:30 claudio Exp $ */
d1102 4
@


1.128
log
@Add new announce type "default-route" which will only announce the default
route to the specified neighbor. Idea and OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.127 2004/07/28 17:05:08 henning Exp $ */
d544 1
d997 1
@


1.127
log
@allow "set metric" as synonym for "set med", from discussion with & ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.126 2004/07/28 15:10:01 henning Exp $ */
d540 3
@


1.126
log
@allow prefix lists inside prefix lists
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.125 2004/07/28 15:05:20 henning Exp $ */
d149 1
a149 1
%token	SET LOCALPREF MED NEXTHOP PREPEND PFTABLE REJECT BLACKHOLE
d1076 4
d1228 1
@


1.125
log
@allow AS lists inside AS lists
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.124 2004/07/28 14:43:54 henning Exp $ */
d164 2
a165 1
%type	<v.filter_prefix>	filter_prefix filter_prefix_l filter_prefix_h
d860 1
a860 1
		| PREFIX '{' filter_prefix_l '}'	{ $$ = $3; }
d862 15
@


1.124
log
@prevent the filter elements from beeing given more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.123 2004/07/28 14:15:28 henning Exp $ */
d161 1
a161 1
%type	<v.filter_as>		filter_as_t filter_as_t_l
d901 1
a901 1
		| filter_as_type '{' filter_as_l '}'	{
d910 16
a925 1
filter_as_l	: filter_as				{ $$ = $1; }
@


1.123
log
@add list expansion for AS in filter rules
actually, it's list expansion on steroids, this works:
deny from any { source-AS { 3320 852 } AS { 4589 174 } }
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.122 2004/07/28 12:46:36 henning Exp $ */
d937 4
d944 4
d953 4
d960 4
@


1.122
log
@rework the filter_match production and everything below - fixes
a couple of bugs
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.121 2004/07/27 20:26:59 henning Exp $ */
d75 5
d83 1
d120 1
d160 2
d165 1
a165 1
%type	<v.u8>			unaryop binaryop filter_as
d880 45
d944 2
a945 3
		| filter_as asnumber		{
			fmopts.m.as.as = $2;
			fmopts.m.as.type = $1;
d982 1
a982 1
filter_as	: AS		{ $$ = AS_ALL; }
d1766 1
d1772 7
a1778 5
			if ((r = calloc(1, sizeof(struct filter_rule))) ==
			    NULL) {
				log_warn("expand_rule");
				return (-1);
			}
d1780 22
a1801 13
			memcpy(r, rule, sizeof(struct filter_rule));
			memcpy(&r->match, match, sizeof(struct filter_match));
			memcpy(&r->set, set, sizeof(struct filter_set));

			if (p != NULL)
				memcpy(&r->peer, &p->p,
				    sizeof(struct filter_peers));

			if (prefix != NULL)
				memcpy(&r->match.prefix, &prefix->p,
				    sizeof(r->match.prefix));

			TAILQ_INSERT_TAIL(filter_l, r, entry);
d1821 4
@


1.121
log
@add support for {} expansion for prefix in the filter rules, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.120 2004/07/27 13:27:42 henning Exp $ */
d78 1
a78 1
};
d152 1
a152 1
%type	<v.filter_match>	filter_match
d756 1
a756 1
filterrule	: action quick direction filter_peer_h filter_match filter_set
d849 2
a850 2
filter_prefix_h	: filter_prefix
		| '{' filter_prefix_l '}'		{ $$ = $2; }
d871 4
a874 3
filter_match	: /* empty */			{ bzero(&$$, sizeof($$)); }
		| PREFIX filter_prefix_h	{
			$$.prefix_l = $2;
d876 8
a883 7
		| PREFIX prefix PREFIXLEN prefixlenop	{
			bzero(&$$, sizeof($$));
			memcpy(&$$.m.prefix.addr, &$2.prefix,
			    sizeof($$.m.prefix.addr));
			$$.m.prefix.len = $2.len;
			memcpy(&$$.m.prefixlen, &$4, sizeof($$.m.prefixlen));
			$$.m.prefixlen.af = $2.prefix.af;
d886 3
a888 3
			bzero(&$$, sizeof($$));
			memcpy(&$$.m.prefixlen, &$2, sizeof($$.m.prefixlen));
			$$.m.prefixlen.af = AF_INET;
d891 2
a892 3
			bzero(&$$, sizeof($$));
			$$.m.as.as = $2;
			$$.m.as.type = $1;
d895 2
a896 3
			bzero(&$$, sizeof($$));
			if (parsecommunity($2, &$$.m.community.as,
			    &$$.m.community.type) == -1) {
@


1.120
log
@suport macro expansion for peer spec in filter rules
things like
  deny from { $peer1 $peer2 } prefix 192.168.0.0/16
are now possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.119 2004/07/13 17:57:20 jaredy Exp $ */
d70 10
d86 1
a86 1
		    struct filter_match *, struct filter_set *);
d112 3
a114 1
		struct filter_match	 filter_match;
d152 2
a153 1
%type	<v.filter_match>	filter_match prefixlenop
d155 1
d758 2
a759 1
			struct filter_rule	r;
d761 5
a765 4
			if ($5.prefix.addr.af && $5.prefix.addr.af != AF_INET) {
				yyerror("king bula sez: AF_INET only for now");
				YYERROR;
			}
d849 22
d872 2
a873 5
		| PREFIX prefix			{
			bzero(&$$, sizeof($$));
			memcpy(&$$.prefix.addr, &$2.prefix,
			    sizeof($$.prefix.addr));
			$$.prefix.len = $2.len;
d877 5
a881 17
			memcpy(&$$.prefix.addr, &$2.prefix,
			    sizeof($$.prefix.addr));
			$$.prefix.len = $2.len;
			$$.prefixlen = $4.prefixlen;
			$$.prefixlen.af = $2.prefix.af;
			if ($$.prefixlen.af == AF_INET)
				if ($$.prefixlen.len_max > 32 ||
				    $$.prefixlen.len_min > 32) {
					yyerror("prefixlen must be <= 32");
					YYERROR;
				}
			if ($$.prefixlen.af == AF_INET6)
				if ($$.prefixlen.len_max > 128 ||
				    $$.prefixlen.len_min > 128) {
					yyerror("prefixlen must be <= 128");
					YYERROR;
				}
d885 2
a886 2
			$$.prefixlen = $2.prefixlen;
			$$.prefixlen.af = AF_INET;
d890 2
a891 2
			$$.as.as = $2;
			$$.as.type = $1;
d895 2
a896 2
			if (parsecommunity($2, &$$.community.as,
			    &$$.community.type) == -1) {
d910 2
a911 2
			$$.prefixlen.op = $1;
			$$.prefixlen.len_min = $2;
d923 3
a925 3
			$$.prefixlen.op = $2;
			$$.prefixlen.len_min = $1;
			$$.prefixlen.len_max = $3;
d1708 1
a1708 1
    struct filter_match *match, struct filter_set *set)
d1711 2
a1712 1
	struct filter_peers_l	*p, *next;
d1715 16
d1732 5
a1736 5
	do {
		if ((r = calloc(1, sizeof(struct filter_rule))) == NULL) {
			log_warn("expand_rule");
			return (-1);
		}
d1738 3
a1740 3
		memcpy(r, rule, sizeof(struct filter_rule));
		memcpy(&r->match, match, sizeof(struct filter_match));
		memcpy(&r->set, set, sizeof(struct filter_set));
d1743 2
a1744 1
			memcpy(&r->peer, &p->p, sizeof(struct filter_peers));
d1746 4
a1749 1
		TAILQ_INSERT_TAIL(filter_l, r, entry);
d1751 4
a1754 7
		if (p != NULL) {
			next = p->next;
			free(p);
			p = next;
		} else
			p = NULL;
	} while (p != NULL);
@


1.119
log
@fix some typos

ok henning otto
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.118 2004/07/05 16:54:53 henning Exp $ */
d65 5
d75 1
a75 1
int		 expand_rule(struct filter_rule *, struct filter_peers *,
d101 1
a101 1
		struct filter_peers	 filter_peers;
d139 1
a139 1
%type	<v.filter_peers>	filter_peer
d742 1
a742 1
filterrule	: action quick direction filter_peer filter_match filter_set
d756 1
a756 1
			if (expand_rule(&r, &$4, &$5, &$6) == -1)
d774 18
a791 1
filter_peer	: ANY		{ $$.peerid = $$.groupid = 0; }
d795 5
a799 1
			$$.groupid = $$.peerid = 0;
d803 1
a803 1
					$$.peerid = p->conf.id;
d806 1
a806 1
			if ($$.peerid == 0) {
d811 1
a811 1
		| GROUP string	{
d814 5
a818 1
			$$.peerid = 0;
d821 1
a821 1
					$$.groupid = p->conf.groupid;
d824 1
a824 1
			if ($$.groupid == 0) {
d1684 1
a1684 1
expand_rule(struct filter_rule *rule, struct filter_peers *peer,
d1688 1
d1690 1
a1690 4
	if ((r = calloc(1, sizeof(struct filter_rule))) == NULL) {
		log_warn("expand_rule");
		return (-1);
	}
d1692 5
a1696 4
	memcpy(r, rule, sizeof(struct filter_rule));
	memcpy(&r->peer, peer, sizeof(struct filter_peers));
	memcpy(&r->match, match, sizeof(struct filter_match));
	memcpy(&r->set, set, sizeof(struct filter_set));
d1698 16
a1713 1
	TAILQ_INSERT_TAIL(filter_l, r, entry);
@


1.118
log
@implement "set nexthop blackhole" and "set nexthop reject"
blackhole/reject routes will be entered to the kernel for matching ones.
this is intended to be used with the Cymru Bogon Route Server Project
(http://www.cymru.com/BGP/bogon-rs.html) and similar services, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.117 2004/07/03 17:19:59 claudio Exp $ */
d971 1
a971 1
				yyerror("Invalid comminity");
@


1.117
log
@Switch mrt dumping to fd passing. This gives some speed up when extensive
dumping is done. Acctually mrt dumps were broken because of the fd passing.
The nice side effect is a much cleaner code, especially in the parent process.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.116 2004/06/23 00:11:27 claudio Exp $ */
d125 1
a125 1
%token	SET LOCALPREF MED NEXTHOP PREPEND PFTABLE
d932 6
d1047 1
d1086 1
@


1.116
log
@Support rfc 3765 which adds a new well known community NOPEER. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.115 2004/06/20 18:35:12 henning Exp $ */
d1576 1
a1576 1
	LIST_FOREACH(m, mrtconf, list) {
d1578 1
a1578 1
			if (m->conf.peer_id != 0 || m->conf.group_id != 0)
d1581 2
a1582 2
			if (m->conf.peer_id != p->conf.id ||
			    m->conf.group_id != p->conf.groupid)
d1585 1
a1585 1
		if (m->conf.type == type) {
d1591 1
a1591 1
	if ((n = calloc(1, sizeof(struct mrt))) == NULL)
d1594 3
a1596 3
	n->conf.type = type;
	n->msgbuf.fd = -1;
	if (strlcpy(n->name, name, sizeof(n->name)) >= sizeof(n->name)) {
d1598 1
a1598 1
		    name, sizeof(n->name) - 1);
d1602 1
a1602 1
	n->ReopenTimerInterval = timeout;
d1605 2
a1606 2
			n->conf.peer_id = 0;
			n->conf.group_id = p->conf.id;
d1608 2
a1609 2
			n->conf.peer_id = p->conf.id;
			n->conf.group_id = 0;
d1613 1
a1613 1
	LIST_INSERT_HEAD(mrtconf, n, list);
@


1.115
log
@at least somewhat consistently name the TAILQ_ENTRYs... this confused me
more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.114 2004/06/08 14:34:48 henning Exp $ */
d1497 4
@


1.114
log
@fix a few memory leaks in error paths and one in the pftable path,
and simplyfy the prefix production error handling slightly
from Mr. Memleak Terminator Patrick Latifi <pat@@eyeo.org>, kickass!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.113 2004/06/06 17:38:10 henning Exp $ */
d77 1
a77 1
	TAILQ_ENTRY(sym)	 entries;
d298 1
a298 1
			TAILQ_INSERT_TAIL(netconf, n, network_l);
d1344 1
a1344 1
		next = TAILQ_NEXT(sym, entries);
d1351 1
a1351 1
			TAILQ_REMOVE(&symhead, sym, entries);
d1377 1
a1377 1
	    sym = TAILQ_NEXT(sym, entries))
d1386 1
a1386 1
			TAILQ_REMOVE(&symhead, sym, entries);
d1406 1
a1406 1
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d1437 1
a1437 1
	TAILQ_FOREACH(sym, &symhead, entries)
d1657 1
a1657 1
	TAILQ_INSERT_TAIL(filter_l, r, entries);
@


1.113
log
@rework bgpd's handling of listening sockets. instead of one for each
supported address familiy, keep a tailq of an arbitary number of them.
the new struct listen_addr contains the sockaddr and the fd.
this fixes quite some nasty behaviour which was a consequence of the previous
model.
looks right deraadt@@, and discussed with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.112 2004/05/21 15:36:40 claudio Exp $ */
d363 1
d366 1
a366 2
				yyerror("could not parse address \"%s/%u\"",
				    $1, $3);
a367 1
				free($1);
a369 1
			free($1);
d529 1
d547 1
d582 2
d595 1
a596 1
				free($6);
d940 1
d946 1
d951 1
d954 1
@


1.112
log
@RFC 2796 bgp route reflector support. This is very useful in conjunction
with templates. looks good, go for it henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.111 2004/05/17 12:39:32 djm Exp $ */
d48 1
d230 10
d242 4
a245 2
				conf->listen_addr.sin_addr.s_addr =
				    $3.v4.s_addr;
d248 5
a252 2
				memcpy(&conf->listen6_addr.sin6_addr, &$3.v6,
				    sizeof(conf->listen6_addr.sin6_addr));
d259 2
d1300 2
d1305 1
a1316 10
	conf->listen_addr.sin_len = sizeof(conf->listen_addr);
	conf->listen_addr.sin_family = AF_INET;
	conf->listen_addr.sin_addr.s_addr = INADDR_ANY;
	conf->listen_addr.sin_port = htons(BGP_PORT);

	bzero(&conf->listen6_addr, sizeof(conf->listen6_addr));
	conf->listen6_addr.sin6_len = sizeof(conf->listen6_addr);
	conf->listen6_addr.sin6_family = AF_INET6;
	conf->listen6_addr.sin6_port = htons(BGP_PORT);

d1350 1
a1350 1
	errors += merge_config(xconf, conf, peer_l);
@


1.111
log
@extend filter language to allow basic setting of COMMUNITIES attribute.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.110 2004/05/08 20:58:00 henning Exp $ */
d116 1
a116 1
%token	ENFORCE NEIGHBORAS CAPABILITIES
d649 26
d1057 1
@


1.110
log
@off by one in key too long detection
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.109 2004/05/08 20:56:10 henning Exp $ */
d87 1
a794 3
			char	*p;
			int	 i;

d796 2
a797 17
			if ((p = strchr($2, ':')) == NULL) {
				free($2);
				yyerror("Bad community syntax");
				YYERROR;
			}
			*p++ = 0;
			if ((i = getcommunity($2)) == COMMUNITY_ERROR) {
				free($2);
				YYERROR;
			}
			if (i == 0 || i == USHRT_MAX) {
				free($2);
				yyerror("Bad community AS number");
				YYERROR;
			}
			$$.community.as = i;
			if ((i = getcommunity(p)) == COMMUNITY_ERROR) {
a801 1
			$$.community.type = i;
d861 4
d906 28
d1435 42
d1680 1
a1680 1
}@


1.109
log
@fix redefinition detection with manual keyes ipsec
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.108 2004/05/08 20:50:29 henning Exp $ */
d1568 1
a1568 1
	if (strlen(s) / 2 >= max_len) {
@


1.108
log
@with manual keyed ipsec, we need keys and spis for both directions -
enforce that
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.107 2004/05/08 19:17:20 henning Exp $ */
d555 7
a561 1
			if (curpeer->conf.auth.method) {
@


1.107
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.106 2004/05/08 19:09:34 henning Exp $ */
d1589 1
d1597 1
d1605 9
@


1.106
log
@break out the consistency checking for neighbors in its own function,
and verify that peers with ipsec have local-address specified (needed to
set up the flows...)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.105 2004/05/08 18:04:14 henning Exp $ */
d582 2
a583 1
				curpeer->conf.auth.method = AUTH_IPSEC_MANUAL_ESP;
d586 2
a587 1
					yyerror("\"ipsec ah\" doesn't take encryption keys");
d591 2
a592 1
				curpeer->conf.auth.method = AUTH_IPSEC_MANUAL_AH;
@


1.105
log
@allow for neighbor statements without { parameters } block; everything
can be inherited from the group
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.104 2004/05/08 17:40:53 henning Exp $ */
d72 1
d392 1
a392 5
			if (curpeer->conf.local_addr.af &&
			    curpeer->conf.local_addr.af !=
			    curpeer->conf.remote_addr.af) {
				yyerror("local-address and neighbor address "
				    "must be of the same address family");
a393 2
			}

d1582 23
@


1.104
log
@add support for ipsec ah with manual keys, pfkey part already does so, and
flesh parser out a bit. also add support for printing ipsec ah with manual
keys in printconf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.103 2004/05/08 17:23:20 henning Exp $ */
d378 1
a378 1
		    NEIGHBOR addrspec optnl '{' optnl {
d390 1
a390 1
		    peeropts_l '}' {
d434 4
@


1.103
log
@factor out the string -> key conversion code used for md5sig and twice for ipsec
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.102 2004/05/07 10:06:15 djm Exp $ */
d126 1
a126 1
%type	<v.number>		number asnumber optnumber yesno inout
d542 1
a542 1
		| IPSEC ESP IKE {
d547 4
a550 1
			curpeer->conf.auth.method = AUTH_IPSEC_IKE_ESP;
d552 1
a552 8
		| IPSEC AH IKE {
			if (curpeer->conf.auth.method) {
				yyerror("auth method cannot be redefined");
				YYERROR;
			}
			curpeer->conf.auth.method = AUTH_IPSEC_IKE_AH;
		}
		| IPSEC ESP inout SPI number STRING STRING encspec {
a559 1
			curpeer->conf.auth.method = AUTH_IPSEC_MANUAL_ESP;
d582 11
d640 4
@


1.102
log
@add a filter option to dump prefixes learned in UPDATEs into a PF table,
intended for building realtime BGP blacklists (e.g. with spamd);
ok claudio & henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.101 2004/05/06 14:41:47 henning Exp $ */
d71 1
a527 3
			unsigned	i;
			char		s[3];

a531 6
			if (strlen($4) / 2 >=
			    sizeof(curpeer->conf.auth.md5key)) {
				yyerror("key too long");
				free($4);
				YYERROR;
			}
d533 2
a534 2
			if (strlen($4) % 2) {
				yyerror("key must be of even length");
a537 13

			for (i = 0; i < strlen($4) / 2; i++) {
				s[0] = $4[2*i];
				s[1] = $4[2*i + 1];
				s[2] = 0;
				if (!isxdigit(s[0]) || !isxdigit(s[1])) {
					yyerror("key must be specified in hex");
					free($4);
					YYERROR;
				}
				curpeer->conf.auth.md5key[i] =
				    strtoul(s, NULL, 16);
			}
a556 2
			unsigned	i;
			char		s[3];
a579 6
			if (strlen($7) % 2) {
				yyerror("auth key must be of even length");
				free($7);
				YYERROR;
			}

d587 4
a590 6
			for (i = 0; i < strlen($7) / 2; i++) {
				s[0] = $7[2*i];
				s[1] = $7[2*i + 1];
				s[2] = 0;
				if (!isxdigit(s[0]) || !isxdigit(s[1])) {
					yyerror("key must be specified in hex");
a593 10
				if ($3 == 1)
					curpeer->conf.auth.auth_key_in[i] =
					    strtoul(s, NULL, 16);
				else
					curpeer->conf.auth.auth_key_out[i] =
					    strtoul(s, NULL, 16);
			}
			free($7);

			if ($3 == 1) {
d604 6
d620 1
a639 3
			unsigned	i;
			char		s[3];

a655 6
			if (strlen($2) % 2) {
				yyerror("key must be of even length");
				free($2);
				YYERROR;
			}

d664 3
a666 10
			for (i = 0; i < strlen($2) / 2; i++) {
				s[0] = $2[2*i];
				s[1] = $2[2*i + 1];
				s[2] = 0;
				if (!isxdigit(s[0]) || !isxdigit(s[1])) {
					yyerror("key must be specified in hex");
					free($2);
					YYERROR;
				}
				$$.enc_key[i] = strtoul(s, NULL, 16);
d1540 30
@


1.101
log
@we need a seperate field for the md5 key len, can't use strlen, noticed
by markus some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.100 2004/05/04 11:34:01 claudio Exp $ */
d121 1
a121 1
%token	SET LOCALPREF MED NEXTHOP PREPEND
d908 3
d936 16
d1042 1
@


1.100
log
@Correctly plug the memory leak and fix a error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.99 2004/04/30 17:34:05 deraadt Exp $ */
d523 1
d560 1
@


1.99
log
@plug memory leaks; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.98 2004/04/30 05:47:50 deraadt Exp $ */
a837 1
			free($2);
d839 2
a840 1
				yyerror("Bad community as number");
d845 1
d848 1
@


1.98
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.97 2004/04/29 19:56:04 deraadt Exp $ */
d829 1
d834 2
a835 1
			if ((i = getcommunity($2)) == COMMUNITY_ERROR)
d837 2
d844 1
a844 1
			if ((i = getcommunity(p)) == COMMUNITY_ERROR)
d846 1
@


1.97
log
@sock -> fd; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.96 2004/04/28 06:43:04 deraadt Exp $ */
d698 1
a698 1
				yyerror("enc key lenght wrong: should be %u "
@


1.96
log
@FILE * leak; henning ja ja ja ja
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.95 2004/04/28 04:34:46 henning Exp $ */
d1494 1
a1494 1
	n->msgbuf.sock = -1;
@


1.95
log
@allow ah/esp spec with IKE, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.94 2004/04/28 01:36:56 henning Exp $ */
d1277 1
@


1.94
log
@prevent multiple auth methods to be specified
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.93 2004/04/28 00:38:39 henning Exp $ */
d561 1
a561 1
		| IPSEC IKE {
d566 8
a573 1
			curpeer->conf.auth.method = AUTH_IPSEC_IKE;
@


1.93
log
@prefix the auth related defines by AUTH_, we had a name clash, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.92 2004/04/27 23:15:28 markus Exp $ */
d510 4
d529 4
d562 4
d574 4
@


1.92
log
@set conf.auth.methodod for md5, too
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.91 2004/04/27 23:02:41 henning Exp $ */
d518 1
a518 1
			curpeer->conf.auth.method = MD5SIG;
d550 1
a550 1
			curpeer->conf.auth.method = MD5SIG;
d554 1
a554 1
			curpeer->conf.auth.method = IPSEC_IKE;
d562 1
a562 1
			curpeer->conf.auth.method = IPSEC_MANUAL_ESP;
@


1.91
log
@ike before in
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.90 2004/04/27 22:42:13 henning Exp $ */
d518 1
d550 1
@


1.90
log
@rename the ipsec struct to auth, move all tcpmd5 related fields in there, and
add a generic "method" field that expresses what method
(none/md5sig/ipsec manual/ipsec ike) is in use
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.89 2004/04/27 22:06:54 henning Exp $ */
d967 1
a968 1
		{ "ike",		IKE},
@


1.89
log
@parser parts for ipsec ike, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.88 2004/04/27 04:38:12 deraadt Exp $ */
d510 3
a512 3
			if (strlcpy(curpeer->conf.tcp_md5_key, $4,
			    sizeof(curpeer->conf.tcp_md5_key)) >=
			    sizeof(curpeer->conf.tcp_md5_key)) {
d514 1
a514 1
				    sizeof(curpeer->conf.tcp_md5_key) - 1);
d525 1
a525 1
			    sizeof(curpeer->conf.tcp_md5_key)) {
d546 1
a546 1
				curpeer->conf.tcp_md5_key[i] =
d552 1
a552 1
			curpeer->conf.ipsec.method = IPSEC_IKE;
d560 1
a560 1
			curpeer->conf.ipsec.method = IPSEC_MANUAL_ESP;
d599 1
a599 1
					curpeer->conf.ipsec.auth_key_in[i] =
d602 1
a602 1
					curpeer->conf.ipsec.auth_key_out[i] =
d608 4
a611 4
				curpeer->conf.ipsec.spi_in = $5;
				curpeer->conf.ipsec.auth_alg_in = auth_alg;
				curpeer->conf.ipsec.enc_alg_in = $8.enc_alg;
				memcpy(&curpeer->conf.ipsec.enc_key_in,
d613 2
a614 2
				    sizeof(curpeer->conf.ipsec.enc_key_in));
				curpeer->conf.ipsec.enc_keylen_in =
d616 1
a616 1
				curpeer->conf.ipsec.auth_keylen_in = keylen;
d618 4
a621 4
				curpeer->conf.ipsec.spi_out = $5;
				curpeer->conf.ipsec.auth_alg_out = auth_alg;
				curpeer->conf.ipsec.enc_alg_out = $8.enc_alg;
				memcpy(&curpeer->conf.ipsec.enc_key_out,
d623 2
a624 2
				    sizeof(curpeer->conf.ipsec.enc_key_out));
				curpeer->conf.ipsec.enc_keylen_out =
d626 1
a626 1
				curpeer->conf.ipsec.auth_keylen_out = keylen;
@


1.88
log
@crud stripping; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.87 2004/04/27 02:35:24 henning Exp $ */
d123 1
a123 1
%token	IPSEC ESP AH SPI
d551 3
d560 2
d968 1
@


1.87
log
@curpeer must be set back to curgroup, not NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.86 2004/04/26 20:07:43 henning Exp $ */
d321 1
a321 1
				     $1);
d345 1
a345 1
				     $1, $3);
@


1.86
log
@need more checks on the keys
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.85 2004/04/26 19:11:01 henning Exp $ */
d400 1
a400 1
			curpeer = NULL;
@


1.85
log
@unbreak
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.84 2004/04/26 08:51:10 henning Exp $ */
d555 1
d557 8
a564 3
			if (strlen($7) / 2 >
			    sizeof(curpeer->conf.ipsec.auth_key_in)) {
				yyerror("auth key too long");
d569 1
d573 7
a579 1
				free($6);
d600 1
a600 12

			if (!strcmp($6, "sha1"))
				auth_alg = SADB_AALG_SHA1HMAC;
			else if (!strcmp($6, "md5"))
				auth_alg = SADB_AALG_MD5HMAC;
			else {
				yyerror("unknown auth algorithm \"%s\"", $6);
				free($7);
				free($6);
				YYERROR;
			}
			free($6);
d611 1
a611 2
				curpeer->conf.ipsec.auth_keylen_in =
				    strlen($7) / 2;
d621 1
a621 2
				curpeer->conf.ipsec.auth_keylen_out =
				    strlen($7) / 2;
a622 1
			free($7);
d646 1
a646 1
			if (!strcmp($1, "3des") || !strcmp($1, "3des-cbc"))
d648 3
a650 2
			else if (!strcmp($1, "aes") ||
			    !strcmp($1, "aes-128-cbc"))
d652 2
a653 1
			else {
d661 2
a662 3
			if (strlen($2) / 2 >
			    sizeof(curpeer->conf.ipsec.enc_key_in)) {
				yyerror("enc key too long");
d667 4
a670 2
			if (strlen($2) % 2) {
				yyerror("key must be of even length");
a673 2

			$$.enc_key_len = strlen($2) / 2;
@


1.84
log
@don't forget to set keylen, markus
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.83 2004/04/26 07:58:04 henning Exp $ */
a586 1
			free($7);
d594 1
d623 1
d673 2
a686 1
			$$.enc_key_len = strlen($2) / 2;
@


1.83
log
@parser support for setting ipsec keys and such, markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.82 2004/04/25 18:21:18 henning Exp $ */
d684 1
@


1.82
log
@reserve upper half of the (internal) ID space for cloned neighbors, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.81 2004/04/25 17:51:46 henning Exp $ */
d99 5
d123 1
d134 1
d551 73
d638 49
d944 1
d954 1
d960 1
d989 1
@


1.81
log
@fix check wether local-address and neighbor are of same address family -
we have to delay this because the current context might be a group nd not
a single neighbor, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.80 2004/04/25 07:16:24 henning Exp $ */
d1364 1
a1364 1
	for (; id < UINT_MAX; id++) {
@


1.80
log
@add "neighbor cloning", allowing you to specify a prefix and prefixlength
instead of the neighbor's IP address. WHen a connection comes in matching
that mask we clone the neighbor spec.
IPv6 match code by itojun, rde feeding by claudio, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.79 2004/04/24 19:36:19 henning Exp $ */
d383 8
a450 5
			if ($2.af != curpeer->conf.remote_addr.af) {
				yyerror("local-address and neighbor address "
				    "must be of the same address family");
				YYERROR;
			}
@


1.79
log
@some rather boring windows talk at cansecwest made me hack initial support
for IPv6 transport
parts based on a diff from Brent Graveland
ok itojun@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.78 2004/03/11 19:01:08 claudio Exp $ */
d122 1
a122 1
%type	<v.prefix>		prefix
d348 10
d370 2
a371 2
		    NEIGHBOR address optnl '{' optnl {
			memcpy(&curpeer->conf.remote_addr, &$3,
d373 4
@


1.78
log
@There is no cnumber token in the parser so don't define a type for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.77 2004/03/11 17:47:48 henning Exp $ */
d219 12
a230 2
			if ($3.af != AF_INET) {
				yyerror("listen-on takes an IPv4 address");
a232 1
			conf->listen_addr.sin_addr.s_addr = $3.v4.s_addr;
a360 4
			if ($3.af != AF_INET) {
				yyerror("king bula sez: IPv4 transport only");
				YYERROR;
			}
d429 5
d1078 5
@


1.77
log
@yes, the keyword table has to be sorted ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.76 2004/03/11 17:12:51 claudio Exp $ */
d119 1
a119 1
%type	<v.number>		number asnumber optnumber cnumber yesno inout
@


1.76
log
@Add basic support for communities. Currently it is only possible to filter
on communities, e.g match from any community 24640:* set localpref 666
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.75 2004/03/10 11:40:33 henning Exp $ */
d813 1
a814 1
		{ "neighbor",		NEIGHBOR},
@


1.75
log
@oups
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.74 2004/03/10 11:38:32 henning Exp $ */
d84 1
d115 1
a115 1
%token	PREFIX PREFIXLEN SOURCEAS TRANSITAS
d119 1
a119 1
%type	<v.number>		number asnumber optnumber yesno inout
d629 1
a629 1
		| filter_as number		{
d631 10
a640 2
			if ($2 > 0xffff) {
				yyerror("AS out of range, max %u", 0xffff);
d643 11
a653 2
			$$.as.as = $2;
			$$.as.type = $1;
d792 1
d1014 1
a1014 1
	if (isalnum(c) || c == ':' || c == '_') {
d1204 18
@


1.74
log
@implement framework to announce capabilities in the open messages we send.
this includes handling "unsupported optional parameter" notifications from the
peer and retrying without capability announcement. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.73 2004/03/08 10:48:06 henning Exp $ */
d107 1
a107 1
%token	ENFORCE NEIGHBORAS
@


1.73
log
@mem leaks in error pathes, mostly from Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.72 2004/03/08 10:33:34 henning Exp $ */
d516 3
d773 1
d1200 1
@


1.72
log
@typo in format strin (ugh!) and few missing free()s, partitially from
Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.71 2004/03/06 21:41:44 henning Exp $ */
d144 1
d173 2
a174 1
			else
d176 1
d263 2
a264 1
			if (add_mrtconfig(MRT_TABLE_DUMP, $3, $4, NULL) == -1)
d266 1
d281 2
d285 3
a287 1
			if (add_mrtconfig(action, $4, $5, curpeer) == -1)
d289 1
d305 1
d308 1
a316 1
			free($1);
a326 1
				free(s);
d329 2
d333 1
a333 1

a334 1
			free($1);
d376 1
d379 1
a383 1
			free($2);
d417 1
d460 1
a460 1
				yyerror("unknown announcement type");
d480 1
d492 1
d498 1
d508 1
@


1.71
log
@plug a memory leak in the lexer.
the issue is this code fragement from yylex():
.		token = lookup(buf);
.		yylval.v.string = strdup(buf);
.		if (yylval.v.string == NULL)
.			fatal("yylex: strdup");
.		return (token);
lookup() tries to match buf against a list of keywords, and returns the
associated token if it has a match, or the token STRING otherwise.
STRING is the only token that needs (and free()s) yylval.v.string. however,
we assigned memory for it with the strdup in yylex for each and every token.
the fix is obviously only setting yylval.v.string when lookup() returns STRING.
Patrick Latifi noticed that something was leaking with token handling,
analysis and fix by me.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.70 2004/03/05 21:52:45 henning Exp $ */
d236 2
a237 1
			else
d239 1
d317 1
a317 1
				yyerror("could not parse address \"%s/%s\"",
d569 1
d572 1
@


1.70
log
@plug a couple of memory leaks, Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.69 2004/03/02 20:00:14 henning Exp $ */
d980 3
a982 4
		token = lookup(buf);
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			fatal("yylex: strdup");
@


1.69
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.68 2004/03/02 19:45:04 henning Exp $ */
d147 1
d174 1
d183 2
d238 1
d260 1
d278 2
d303 1
d321 1
d369 1
d448 1
d467 1
d495 1
@


1.68
log
@flesh out the address and prefix parsing, include v6 code, but reject v6
upwards, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.67 2004/03/01 22:58:12 henning Exp $ */
d303 1
a303 1
				
@


1.67
log
@make sure AS doesn't exceed upper bound, issue pointed out by
Brent Graveland <brent@@graveland.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.66 2004/03/01 17:04:07 henning Exp $ */
d94 4
d121 1
d235 1
a235 1
		| NETWORK address '/' number filter_set	{
d238 4
d244 4
a247 7
			memcpy(&n->net.prefix, &$2, sizeof(n->net.prefix));
			if ($4 > 32) {
				yyerror("invalid netmask");
				YYERROR;
			}
			n->net.prefixlen = $4;
			memcpy(&n->net.attrset, &$5,
d280 7
a286 1
			int	n;
d288 5
a292 4
			bzero(&$$, sizeof($$));
			$$.af = AF_INET;
			if ((n = inet_pton(AF_INET, $1, &$$.v4)) == -1) {
				yyerror("inet_pton: %s", strerror(errno));
d295 13
a307 3
			if (n == 0) {
				yyerror("could not parse address spec \"%s\"",
				     $1);
d310 2
d328 4
a331 1
			curpeer->conf.remote_addr.af = AF_INET;
d498 5
d559 1
a559 1
		| PREFIX address '/' number	{
d561 3
a563 6
			memcpy(&$$.prefix.addr, &$2, sizeof($$.prefix.addr));
			if ($4 > 32) {
				yyerror("prefixlength must be <= 32");
				YYERROR;
			}
			$$.prefix.len = $4;
d565 1
a565 1
		| PREFIX address '/' number PREFIXLEN prefixlenop	{
d567 17
a583 13
			memcpy(&$$.prefix.addr, &$2, sizeof($$.prefix.addr));
			if ($4 > 32) {
				yyerror("prefixlength must be <= 32");
				YYERROR;
			}
			$$.prefix.len = $4;
			$$.prefixlen = $6.prefixlen;
			$$.prefixlen.af = AF_INET;
			if ($$.prefixlen.len_max > 32 ||
			    $$.prefixlen.len_min > 32) {
				yyerror("prefixlength must be <= 32");
				YYERROR;
			}
@


1.66
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.65 2004/03/01 16:47:06 claudio Exp $ */
d114 1
a114 1
%type	<v.number>		number optnumber yesno inout
d145 7
d179 1
a179 1
conf_main	: AS number		{
d355 1
a355 1
peeropts	: REMOTEAS number	{
@


1.65
log
@Sync printconfig.c with parse.y. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.64 2004/03/01 16:02:01 claudio Exp $ */
d727 1
a727 1
		{ "route-collector",	ROUTECOLL},	
@


1.64
log
@Make it possible to diable the decision process. This is a feature only useful
for route-collectors. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.63 2004/02/26 14:00:33 claudio Exp $ */
d1186 7
a1192 2
		n->conf.peer_id = p->conf.id;
		n->conf.group_id = p->conf.groupid;
@


1.63
log
@Implement "enforce neighbor-as yes|no" which is by default on for ebgp
neighbors. While doing that check also that the nexthop is valid (not class D
or E and not in 127/8 range). Kill some TODO and XXX and rename the british
neighbour to neighbor as used everywhere else. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2004/02/26 13:54:50 claudio Exp $ */
d105 1
a105 1
%token	LOG
d211 6
d727 1
@


1.62
log
@No comma at the end of the keywords array. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.61 2004/02/26 09:53:58 claudio Exp $ */
d103 1
d397 6
d691 1
d708 1
@


1.61
log
@Add per netwok definition filter sets. So you can now use
network 10.0.0.0/8 set localpref 100
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2004/02/25 19:48:18 claudio Exp $ */
d718 1
a718 1
		{ "transit-AS",		TRANSITAS},
@


1.60
log
@Rewrite some parts of the mrt dump handling. It is no longer possible to
dump the filtered updates but therefore it is now possible to dump per
neighbor and also to dump the outgoing messages. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2004/02/25 14:25:22 henning Exp $ */
d216 1
a216 1
		| NETWORK address '/' number		{
d227 3
d435 6
a440 2
		| filter_set		{
			memcpy(&curpeer->conf.attrset, &$1,
a457 14
		| action quick direction filter_peer filter_match
		{
			struct filter_rule	r;
			struct filter_set	set;

			bzero(&r, sizeof(r));
			bzero(&set, sizeof(set));
			r.action = $1;
			r.quick = $2;
			r.dir = $3;

			if (expand_rule(&r, &$4, &$5, &set) == -1)
				YYERROR;
		}
d577 4
a580 1
filter_set	: SET filter_set_opt				{ $$ = $2; }
@


1.59
log
@kill "updates" keyword and use a ordinary string + strcmp at the one place
where it's needed, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2004/02/24 15:43:03 claudio Exp $ */
d67 1
a67 1
int		 add_mrtconfig(enum mrt_type, char *, time_t);
d103 1
a103 1
%token	DUMP MSG IN TABLE
d113 1
a113 1
%type	<v.number>		number optnumber yesno
a215 18
		| DUMP MSG STRING IN STRING optnumber	{
			int action;

			if (!strcmp($3, "all"))
				action = MRT_ALL_IN;
			else if (!strcmp($3, "filtered"))
				action = MRT_FILTERED_IN;
			else {
				yyerror("unknown mrt msg dump type");
				YYERROR;
			}
			if (add_mrtconfig(action, $5, $6) == -1)
				YYERROR;
		}
		| DUMP TABLE STRING optnumber		{
			if (add_mrtconfig(MRT_TABLE_DUMP, $3, $4) == -1)
				YYERROR;
		}
d229 25
d436 1
a702 1
		{ "msg",		MSG},
d708 1
d1142 1
a1142 1
add_mrtconfig(enum mrt_type type, char *name, time_t timeout)
d1147 8
d1173 4
@


1.58
log
@Enhance filters. prefixlen knows now 8-24 and 8><24. It is possible to use
prefix 10.0.0.0/8 prefixlen >= 8 and set localpref 100 can be set on a per
neighbor basis. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2004/02/19 13:54:58 claudio Exp $ */
d104 1
a104 1
%token	LOG UPDATES
d210 5
a214 2
		| LOG UPDATES		{
			conf->log |= BGPD_LOG_UPDATES;
a714 1
		{ "updates",		UPDATES},
@


1.57
log
@Make the code more portable. Add some missing header files and make the use
of the queue(3) makros more portable. OK henning@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2004/02/10 23:10:23 henning Exp $ */
d118 1
a118 1
%type	<v.filter_match>	filter_match
d120 1
a120 1
%type	<v.u8>			unaryop filter_as
d422 4
d440 14
d511 1
a511 1
		| PREFIXLEN unaryop number	{
d513 11
a523 2
			if ($3 > 128) {
				yyerror("prefixlen must be < 128");
d526 5
a530 2
			$$.prefixlen.op = $2;
			$$.prefixlen.len_min = $3;
d543 25
d573 2
a574 5
filter_set	: /* empty */				{
			bzero(&$$, sizeof($$));
		}
		| SET filter_set_opt			{ $$ = $2; }
		| SET "{" filter_set_l "}"		{ $$ = $3; }
d630 4
@


1.56
log
@enforce config file secrecy (correct owner, no rights for group/world)
help and ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2004/02/09 01:46:34 henning Exp $ */
d31 1
@


1.55
log
@make max_prefix an u_int32_t instead of an u_long and change its
meaning as in 0 means no limit insytead of setting it to ULONG_MAX for
no limit
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2004/02/09 00:00:41 henning Exp $ */
d899 6
@


1.54
log
@move printing the config to where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2004/02/08 23:44:57 henning Exp $ */
a1035 1
	p->conf.max_prefix = ULONG_MAX;
@


1.53
log
@factor out functions to print the configuration (rules only for now)
will become more and needed by bgpctl too
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2004/02/06 20:37:53 henning Exp $ */
a867 1
	struct filter_rule	*r;
a916 4

	if (xconf->opts & BGPD_OPT_VERBOSE)
		TAILQ_FOREACH(r, filter_l, entries)
			print_rule(peer_l, r);
@


1.52
log
@use a struct bgpd_addr for the address token instead of a in_addr, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2004/02/06 20:18:18 henning Exp $ */
a69 2
void		 print_op(enum comp_ops);
void		 print_rule(struct filter_rule *);
d921 1
a921 1
			print_rule(r);
a1149 113
}

void
print_op(enum comp_ops op)
{
	switch (op) {
	case OP_EQ:
		printf("=");
		break;
	case OP_NE:
		printf("!=");
		break;
	case OP_LE:
		printf("<=");
		break;
	case OP_LT:
		printf("<");
		break;
	case OP_GE:
		printf(">=");
		break;
	case OP_GT:
		printf(">");
		break;
	default:
		printf("?");
		break;
	}
}

void
print_rule(struct filter_rule *r)
{
	struct peer	*p;

	if (r->action == ACTION_ALLOW)
		printf("allow ");
	else if (r->action == ACTION_DENY)
		printf("deny ");
	else
		printf("match ");

	if (r->quick)
		printf("quick ");

	if (r->dir == DIR_IN)
		printf("from ");
	else if (r->dir == DIR_OUT)
		printf("to ");
	else
		printf("eeeeeeeps. ");

	if (r->peer.peerid) {
		for (p = peer_l; p != NULL && p->conf.id != r->peer.peerid;
		    p = p->next)
			;	/* nothing */
		if (p == NULL)
			printf("?");
		else
			printf("%s ", log_addr(&p->conf.remote_addr));
	} else if (r->peer.groupid) {
		for (p = peer_l; p != NULL &&
		    p->conf.groupid != r->peer.groupid; p = p->next)
			;	/* nothing */
		if (p == NULL)
			printf("group ? ");
		else
			printf("group %s ", p->conf.group);
	} else
		printf("any ");

	if (r->match.prefix.addr.af)
		printf("prefix %s/%u ", log_addr(&r->match.prefix.addr),
		    r->match.prefix.len);

	if (r->match.prefixlen.op) {
		if (r->match.prefixlen.op == OP_RANGE)
			printf("prefixlen %u - %u ", r->match.prefixlen.len_min,
			    r->match.prefixlen.len_max);
		else {
			printf("prefixlen ");
			print_op(r->match.prefixlen.op);
			printf(" %u ", r->match.prefixlen.len_min);
		}
	}

	if (r->match.as.type) {
		if (r->match.as.type == AS_ALL)
			printf("AS %u ", r->match.as.as);
		else if (r->match.as.type == AS_SOURCE)
			printf("source-AS %u ", r->match.as.as);
		else if (r->match.as.type == AS_TRANSIT)
			printf("transit-AS %u ", r->match.as.as);
		else
			printf("unfluffy-AS %u ", r->match.as.as);
	}

	if (r->set.flags) {
		printf("set { ");
		if (r->set.flags & SET_LOCALPREF)
			printf("localpref %u ", r->set.localpref);
		if (r->set.flags & SET_MED)
			printf("med %u ", r->set.med);
		if (r->set.flags & SET_NEXTHOP)
			printf("nexthop %s ", inet_ntoa(r->set.nexthop));
		if (r->set.flags & SET_PREPEND)
			printf("prepend-self %u ", r->set.prepend);


		printf("}");
	}

	printf("\n");
@


1.51
log
@initial cut at the filtering language.
structs etc to describe a rule, filter rule list management
parser groks filter defs now.

claudio ok, discussion & help also jakob theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2004/02/05 14:42:45 henning Exp $ */
d90 1
a90 1
		struct in_addr		 addr;
d176 5
a180 1
			conf->bgpid = $2.s_addr;
d199 5
a203 1
			conf->listen_addr.sin_addr.s_addr = $3.s_addr;
d237 1
a237 2
			n->net.prefix.af = AF_INET;
			n->net.prefix.v4 = $2;
d250 3
a252 1
			if ((n = inet_pton(AF_INET, $1, &$$)) == -1) {
d278 2
a279 1
			curpeer->conf.remote_addr.v4.s_addr = $3.s_addr;
d343 2
a344 2
			curpeer->conf.local_addr.af = AF_INET;
			curpeer->conf.local_addr.v4.s_addr = $2.s_addr;
d458 2
a459 2
				if (!memcmp(&p->conf.remote_addr.v4,
				    &$1, sizeof(p->conf.remote_addr.v4))) {
d464 1
a464 1
				yyerror("no such peer: %s", inet_ntoa($1));
d487 1
a487 2
			$$.prefix.addr.af = AF_INET;
			$$.prefix.addr.v4.s_addr = $2.s_addr;
d555 7
a561 2
			$$.flags = SET_NEXTHOP;
			$$.nexthop.s_addr = $2.s_addr;
@


1.50
log
@allocate curpeer little earlier.
there's a rather obscure error path where teh later allocation causes
trouble, claudio ok
@
text
@d46 1
d68 4
d88 7
a94 3
		u_int32_t	 number;
		char		*string;
		struct in_addr	 addr;
d107 5
d113 9
a121 4
%token	<v.string>	STRING
%type	<v.number>	number optnumber yesno
%type	<v.string>	string
%type	<v.addr>	address
d130 1
d415 152
d602 1
d604 2
d609 1
d616 1
d618 1
d621 1
d627 1
d631 4
d637 2
d641 2
d851 2
a852 1
    struct mrt_head *xmconf, struct peer **xpeers, struct network_head* nc)
d854 3
a856 2
	struct sym	*sym, *next;
	struct peer	*p, *pnext;
d873 2
d907 4
d1117 134
@


1.49
log
@error message tuning
more power!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2004/02/05 14:29:09 henning Exp $ */
d246 2
a247 2
neighbor	: NEIGHBOR address optnl '{' optnl {
			curpeer = new_peer();
d249 1
a249 1
			curpeer->conf.remote_addr.v4.s_addr = $2.s_addr;
@


1.48
log
@introduce group IDs. will be needed for filtering (or rather, ease things
there)
just assign them from the neighbor ID pool - fortunately, that is rather
simple, we just have to make sure that all members of the group and (later)
all filter rules pointing to the group agree on the ID, but it does not need
to stay the same across config reloads.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2004/02/03 22:28:05 henning Exp $ */
d118 1
a118 1
				yyerror("%s is not a number", $1);
d228 2
a229 1
				yyerror("could not parse address spec %s", $1);
d595 1
a595 1
			yyerror("macro '%s' not defined", buf);
d705 1
a705 1
			fprintf(stderr, "warning: macro '%s' not "
@


1.47
log
@replace the previous hack for the internal peer id allocator (which just used
the peer's ip address as u_int32_t) by a real id allocator that tries to
keep locality high. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2004/02/01 19:46:05 claudio Exp $ */
d270 4
d852 1
d900 8
a907 6
	for (p = peer_l_old; p != NULL; p = p->next)
		if (!memcmp(&p->conf.remote_addr, &newpeer->conf.remote_addr,
		    sizeof(p->conf.remote_addr))) {
			newpeer->conf.id = p->conf.id;
			return (0);
		}
@


1.46
log
@defer free()ing the previous peer list until after parsing the config file
so in the parser we can access it. will be needed soon.
@
text
@d50 1
d66 1
d249 4
d677 1
d888 25
@


1.45
log
@Set sane default announce types according to the peer type. For IBGP use
announce all and for EBGP use announce self. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2004/01/28 23:49:55 henning Exp $ */
d43 1
a43 1
static struct peer		*peer_l;
d655 1
d666 1
d706 5
@


1.44
log
@properly whine when password is too long instead of silently truncating
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2004/01/28 23:31:28 henning Exp $ */
d813 1
a813 1
	p->conf.announce_type = ANNOUNCE_SELF;
a834 1
	p->state = STATE_NONE;
a835 3
	p->conf.distance = 1;
	p->conf.announce_type = ANNOUNCE_SELF;
	p->conf.max_prefix = ULONG_MAX;
@


1.43
log
@implement
  tcp md5sig password
so that the key can be given in ascii, what unfortunately limits the key space
(cisco/juniper compat...)
we keep the ability to specify the key in hex whithout these limits.

help & ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2004/01/27 16:49:53 henning Exp $ */
d347 7
a353 2
			strlcpy(curpeer->conf.tcp_md5_key, $4,
			    sizeof(curpeer->conf.tcp_md5_key));
@


1.42
log
@use a struct bgpd_addr instead of sockaddr_in for peer_config->local_addr and
->remote_addr for easier multiprotocol support

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2004/01/26 21:08:18 henning Exp $ */
d95 1
a95 1
%token	TCP MD5SIG KEY
d346 4
d351 8
a358 1
			unsigned i;
d360 11
a370 3
			for (i = 0; i < strlen($4); i++)
				if (!isxdigit($4[i])) {
					yyerror("key should be in hex");
d373 3
a375 2
			strlcpy(curpeer->conf.tcp_sign_key, $4,
			    sizeof(curpeer->conf.tcp_sign_key));
d434 1
@


1.41
log
@rename "tcp signature" to "tcp md5sig" - the name is misleading, wether
ietf wants to call it so or not
prodded by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2004/01/26 14:42:47 henning Exp $ */
d245 2
a246 5
			curpeer->conf.remote_addr.sin_len =
			    sizeof(curpeer->conf.remote_addr);
			curpeer->conf.remote_addr.sin_family = AF_INET;
			curpeer->conf.remote_addr.sin_port = htons(BGP_PORT);
			curpeer->conf.remote_addr.sin_addr.s_addr = $2.s_addr;
d302 2
a303 4
			curpeer->conf.local_addr.sin_len =
			    sizeof(curpeer->conf.local_addr);
			curpeer->conf.local_addr.sin_family = AF_INET;
			curpeer->conf.local_addr.sin_addr.s_addr = $2.s_addr;
a788 2
	p->conf.local_addr.sin_len = sizeof(p->conf.local_addr);
	p->conf.local_addr.sin_family = AF_INET;
a813 2
	p->conf.local_addr.sin_len = sizeof(p->conf.local_addr);
	p->conf.local_addr.sin_family = AF_INET;
@


1.40
log
@first cut at tcpmd5 setup seupport from within bgpd. works so far.
with help from hshoexer@@ and markus@@
ok claudio@@ hshoexer@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2004/01/24 19:26:12 mcbride Exp $ */
d95 1
a95 1
%token	TCP SIGNATURE KEY
d351 1
a351 1
		| TCP SIGNATURE KEY string {
d411 1
a420 1
		{ "signature",		SIGNATURE},
@


1.39
log
@eek, no, ERROR is of course not unused
@
text
@d95 1
d351 11
d406 1
d420 1
d422 1
@


1.38
log
@Remove unused terminals.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2004/01/22 21:09:00 henning Exp $ */
d95 1
@


1.37
log
@provide a log_debug and use it in rde.c.
with this, logit() can be a private function.
we don't need to include syslog.h in bgpd.h any more; log.c and parse.y
who need it include it directly now.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2004/01/17 19:35:36 claudio Exp $ */
d90 1
a90 2
%token	SET
%token	AS ROUTERID HOLDTIME YMIN LISTEN ON NO FIBUPDATE
a92 1
%token	ERROR
a405 1
		{ "set",		SET},
@


1.36
log
@Make it possible to announce own networks. In the RDE these prefixes are
attached to a pseudo peer and inserted like all other prefixes into the RIB.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2004/01/17 19:15:07 henning Exp $ */
d34 1
@


1.35
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2004/01/13 13:45:49 claudio Exp $ */
d41 1
d91 1
a91 1
%token	GROUP NEIGHBOR
d201 2
d204 12
a215 1
;
d402 1
d617 1
a617 1
    struct mrt_head *xmconf, struct peer **xpeers)
d626 2
@


1.34
log
@Implement a max-prefix and a announce none | self | all neighbor statement.
The first limits the number of sent prefixes per peer the latter controls
which prefix we do annouce to the neighbor.
Another looks good from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2004/01/06 23:36:40 henning Exp $ */
d236 1
a236 1
		  peeropts_l '}' {
d253 1
a253 1
		  groupopts_l '}' {
d756 1
a756 1
	
@


1.33
log
@small bug that was not so easy to fix: we did not allow empty lines (or
comment-only lines) in the middle of neighbor/group blocks. as first or
last line in thise blocks they were accepted, but not in between.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2004/01/06 20:41:55 henning Exp $ */
d59 1
d91 1
a91 1
%token	REMOTEAS DESCR LOCALADDR MULTIHOP PASSIVE
d321 15
d373 1
d383 1
d750 1
a750 1
new_peer(void)
d756 19
d788 2
d799 1
a799 6
	struct peer	*p;

	if ((p = calloc(1, sizeof(struct peer))) == NULL)
		fatal("new_group");

	return (p);
@


1.32
log
@allow holdtime and holdtime min to be configuered per peer

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2004/01/06 03:43:50 henning Exp $ */
d220 3
d235 1
a235 1
		  peeropts_l optnl '}' {
d252 1
a252 1
		  groupopts_l optnl '}' {
d262 3
a264 3
groupoptsl	: peeropts '\n'
		| neighbor '\n'
		| error '\n'
d271 2
a272 2
peeroptsl	: peeropts '\n'
		| error '\n'
@


1.31
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2004/01/05 22:57:58 claudio Exp $ */
d300 16
@


1.30
log
@Big overhaul of the mrt code.
Dumping of incomming bgp messages is now possible and dumping the (not yet)
filtered updates works too. Per neighbor dumps are still missing.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2004/01/05 19:14:41 henning Exp $ */
d4 1
a4 1
 * Copyright (c) 2002, 2003 Henning Brauer <henning@@openbsd.org>
@


1.29
log
@missing fclose()

fd leak pointed out by Patrick Latifi, but it was not so easy to fix before
I just killed the support for config from stdin and his fix didn't work.
however, this is the 16 bytes memory leak on config reload i was hunting for
some time, big thanks to Patrick!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2004/01/05 19:06:42 henning Exp $ */
d36 1
d40 1
a40 1
static struct mrt_config	*mrtconf;
d61 1
a61 1
int		 add_mrtconfig(enum mrtdump_type, char *, time_t);
d92 1
a92 1
%token	MRTDUMP
d95 1
a95 1
%type	<v.number>	number yesno
d181 9
a189 11
		/*
		 *  XXX this is bad.
		 *  a) number should be optional
		 *  b) there are multiple dump types
		 */
		| MRTDUMP STRING STRING number	{
			if (strcmp($2, "table") == 0) {
				if (add_mrtconfig(MRT_TABLE_DUMP, $3, $4) == -1)
					YYERROR;
			} else {
				yyerror("unknown mrtdump type %s", $2);
d192 6
d199 2
a200 1
		;
d220 4
d339 1
d343 1
d348 1
a348 1
		{ "mrtdump",		MRTDUMP},
d356 1
d565 1
a565 1
    struct mrt_config *xmconf, struct peer **xpeers)
d571 1
a571 1
	if ((mrtconf = calloc(1, sizeof(struct mrt_config))) == NULL)
d750 1
a750 1
add_mrtconfig(enum mrtdump_type type, char *name, time_t timeout)
d752 1
a752 1
	struct mrtdump_config	*m, *n;
d755 1
a755 1
		if (m->type == type) {
d761 1
a761 1
	if ((n = calloc(1, sizeof(struct mrtdump_config))) == NULL)
d764 1
a764 1
	n->type = MRT_TABLE_DUMP;
@


1.28
log
@remove support for reading configuration from stdin.
that really does not make sense with a daemon and probably breaks horribly
on config reload
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2004/01/05 19:04:11 henning Exp $ */
d582 2
@


1.27
log
@fix off by ones with strlcpy()
memleak fixes in error paths
From: Patrick Latifi <pat@@eyeo.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2004/01/03 20:37:34 henning Exp $ */
d573 5
a577 11
	if (strcmp(filename, "-") == 0) {
		fin = stdin;
		infile = "stdin";
	} else {
		if ((fin = fopen(filename, "r")) == NULL) {
			warn("%s", filename);
			free(conf);
			free(mrtconf);
			return (-1);
		}
		infile = filename;
d579 1
@


1.26
log
@move some session specific stuff to session.h and make the few files
that need it include that
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2004/01/03 20:22:07 henning Exp $ */
d232 1
a232 1
			    sizeof(curgroup->conf.group)) >
d267 1
a267 1
			    sizeof(curpeer->conf.descr)) >
d579 3
a581 1
			return (1);
d655 2
a656 1
	int	 ret;
d661 2
a662 1
	if ((sym = malloc(strlen(s) - strlen(val) + 1)) == NULL)
d665 1
a665 1
	strlcpy(sym, s, strlen(s) - strlen(val) + 1);
d713 2
a714 2
		    sizeof(p->conf.group)) > sizeof(p->conf.group))
			fatalx("new_peer strlcpy");
d716 2
a717 2
		    sizeof(p->conf.descr)) > sizeof(p->conf.descr))
			fatalx("new_peer strlcpy");
d756 1
a756 1
	if (strlcpy(n->name, name, sizeof(n->name)) > sizeof(n->name)) {
d759 1
@


1.25
log
@decouple the peer list from bgpd_config.
so many parts of bgpd are not at all interested in the session specific peer
structs... allows for some further cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2003/12/27 21:40:43 henning Exp $ */
d36 1
d40 1
a40 1
static struct peer		*peers;
d223 2
a224 2
			curpeer->next = peers;
			peers = curpeer;
d562 1
a562 1
	peers = NULL;
d600 1
a600 1
	errors += merge_config(xconf, conf, peers);
d602 1
a602 1
	*xpeers = peers;
@


1.24
log
@bgpid -> router-id
local-addr -> local-address
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2003/12/27 17:34:10 henning Exp $ */
d39 1
d222 2
a223 2
			curpeer->next = conf->peers;
			conf->peers = curpeer;
d551 1
a551 1
    struct mrt_config *xmconf)
d561 1
d599 1
a599 1
	errors += merge_config(xconf, conf);
d601 1
@


1.23
log
@fix thinko
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2003/12/27 14:42:59 henning Exp $ */
d85 1
a85 1
%token	AS BGPID HOLDTIME YMIN LISTEN ON NO FIBUPDATE
d147 1
a147 1
		| BGPID address		{
a325 1
		{ "bgpid",		BGPID},
d331 1
a331 1
		{ "local-addr",		LOCALADDR},
d340 1
@


1.22
log
@"no fib-update" -> "fib-update [yes|no]"
makes more sense this way
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2003/12/27 14:28:41 henning Exp $ */
d170 1
a170 1
			if ($2 == 1)
@


1.21
log
@few fatal()s should really be fatalx()
From: Dries Schellekens <gwyllion@@ace.ulyssis.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2003/12/26 20:52:14 jakob Exp $ */
d92 1
a92 1
%type	<v.number>	number
d126 10
d169 5
a173 2
		| NO FIBUPDATE		{
			conf->flags |= BGPD_FLAG_NO_FIB_UPDATE;
a337 1
		{ "no",			NO},
@


1.20
log
@add option 'log updates' to log updates. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2003/12/26 18:07:32 henning Exp $ */
d294 1
a294 1
		fatal("yyerror asprintf");
@


1.19
log
@when this project started and i added the fatal() function, I made it take
the error number as parameter instead of accessing errno, because in one
place the error number was not in errno but fetched from a socket.
now, of course it makes much more sense to just set errno to the error number
just fecthed in this one place instead of having hundreds of fatal() calls
all transfer the errno round and round and round...
fix this, and also provide a fatalx, which does not care for errno and doesn't
invoke strerror.
oh, btw, in the place where we fetch the err # from the socket, we don't
call fatal anymore anyway...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2003/12/25 23:23:51 henning Exp $ */
d90 1
d162 3
d320 1
d330 1
@


1.18
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2003/12/25 18:35:17 henning Exp $ */
d118 1
a118 1
				fatal("string: asprintf", errno);
d129 1
a129 1
				fatal("cannot store variable", errno);
d290 1
a290 1
		fatal("yyerror asprintf", 0);
d495 1
a495 1
			fatal("yylex: strdup", errno);
d518 1
a518 1
			fatal("yylex: strdup", errno);
d537 1
a537 1
		fatal(NULL, errno);
d539 1
a539 1
		fatal(NULL, errno);
d637 1
a637 1
		fatal("cmdline_symset: malloc", errno);
d682 1
a682 1
		fatal("new_peer", errno);
d688 1
a688 1
			fatal("new_peer strlcpy", 0);
d691 1
a691 1
			fatal("new_peer strlcpy", 0);
d708 1
a708 1
		fatal("new_group", errno);
d726 1
a726 1
		fatal("add_mrtconfig", errno);
@


1.17
log
@must not remove macros vis cmdline after parsinf is done, we will need them
again on reload
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2003/12/25 18:04:10 henning Exp $ */
d566 1
a566 1
	for(sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
@


1.16
log
@don't leak in yyerror()
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2003/12/25 17:58:50 henning Exp $ */
d571 6
a576 4
		free(sym->nam);
		free(sym->val);
		TAILQ_REMOVE(&symhead, sym, entries);
		free(sym);
@


1.15
log
@o can't TAILQ_FOREACH when we TAILQ_REMOVE in the loop
o free(sym)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2003/12/25 17:35:53 henning Exp $ */
d293 1
@


1.14
log
@free where it was allocated; much easier to verify
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2003/12/25 14:28:49 henning Exp $ */
d533 1
a533 1
	struct sym	*sym;
d565 2
a566 1
	TAILQ_FOREACH(sym, &symhead, entries) {
d573 1
@


1.13
log
@implement "passive": do not attempt to open a tcp connection to the
neighbor system
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2003/12/24 14:10:49 henning Exp $ */
d576 3
@


1.12
log
@local-addr, not local-address.
it's better when documentation and code agree on the keyword...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2003/12/24 13:49:21 henning Exp $ */
d87 1
a87 1
%token	REMOTEAS DESCR LOCALADDR MULTIHOP
d269 3
d321 1
@


1.11
log
@add option to not touch the kernel routing table
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2003/12/23 13:13:24 henning Exp $ */
d311 1
a311 1
		{ "local-address",	LOCALADDR},
@


1.10
log
@better syntax for minimum accepted holdtime
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2003/12/23 01:06:21 henning Exp $ */
d85 1
a85 1
%token	AS BGPID HOLDTIME YMIN LISTEN ON
d158 3
d307 1
d316 1
@


1.9
log
@allow the listening address to be specified, default to INADDR_ANY
should make jose@@ happy
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2003/12/22 19:43:36 deraadt Exp $ */
d85 1
a85 1
%token	AS BGPID HOLDTIME HOLDTIME_MIN LISTEN ON
d147 3
a149 3
		| HOLDTIME_MIN number	{
			if ($2 < MIN_HOLDTIME) {
				yyerror("holdtime_min must be at least %u",
d153 1
a153 1
			conf->min_holdtime = $2;
a305 1
		{ "holdtime_min",	HOLDTIME_MIN},
d308 1
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2003/12/22 19:39:59 deraadt Exp $ */
d84 2
a85 1
%token	SET AS BGPID HOLDTIME HOLDTIME_MIN
d155 3
d307 1
d312 1
d536 5
@


1.7
log
@fix indent
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2003/12/22 19:36:19 henning Exp $ */
d184 1
a184 1
optnl		: '\n' optnl 
@


1.6
log
@ease grammar a lot. eleminate pstate and let yacc do the work for us instead.
nearly completely from theo with minor adjustment by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2003/12/21 22:16:53 henning Exp $ */
d213 1
a213 1
		   groupopts_l optnl '}' {
@


1.5
log
@overhaul the write buffering code.
introduce msgbuf API and bundle all info needed for the write buffers in a
struct msgbuf.
also switch to a write queue per handled connection (each bgp session, each
pipe) instead of one big one.
fixes some subtle problems and is overall nicer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2003/12/20 20:53:30 henning Exp $ */
a36 6
enum parse_state {
	PSTATE_MAIN,
	PSTATE_GROUP,
	PSTATE_NEIGHBOR
};

a44 1
static int			 pstate = PSTATE_MAIN;
a71 2
int	 check_state_peeropts(void);
int	 check_state_main(void);
d98 1
a100 3
		| grammar peeropts '\n'
		| grammar endsection '\n'
		| grammar varset '\n'
a132 2
			if (check_state_main())
				YYERROR;
a135 2
			if (check_state_main())
				YYERROR;
a138 2
			if (check_state_main())
				YYERROR;
a146 2
			if (check_state_main())
				YYERROR;
a159 2
			if (check_state_main())
				YYERROR;
d184 5
a188 7
neighbor	: NEIGHBOR address '{'	{
			if (pstate >= PSTATE_NEIGHBOR) {
				yyerror("neighbor statment not allowed in this "
				    "context");
				YYERROR;
			}
			pstate = PSTATE_NEIGHBOR;
d196 5
d203 1
a203 7
group		: GROUP string '{'	{
			if (pstate >= PSTATE_GROUP) {
				yyerror("group statment not allowed in this "
				    "context");
				YYERROR;
			}
			pstate = PSTATE_GROUP;
d213 21
a236 2
			if (check_state_peeropts())
				YYERROR;
a239 2
			if (check_state_peeropts())
				YYERROR;
a249 2
			if (check_state_peeropts())
				YYERROR;
a255 2
			if (check_state_peeropts())
				YYERROR;
a263 23
endsection	: '}'			{
			switch (pstate) {
			case PSTATE_GROUP:
				free(curgroup);
				curgroup = NULL;
				pstate = PSTATE_MAIN;
				break;
			case PSTATE_NEIGHBOR:
				curpeer->next = conf->peers;
				conf->peers = curpeer;
				curpeer = NULL;
				if (curgroup == NULL)
					pstate = PSTATE_MAIN;
				else
					pstate = PSTATE_GROUP;
				break;
			default:
				yyerror("\"}\" not allowed in this context");
				YYERROR;
				break;
			}
		}
		;
a711 22
}

int
check_state_peeropts(void)
{
	if (pstate != PSTATE_GROUP &&
	    pstate != PSTATE_NEIGHBOR) {
		yyerror("statement not allowed in this context");
		return (-1);
	} else
		return (0);
}

int
check_state_main(void)
{
	if (pstate != PSTATE_MAIN) {
		yyerror("This statement is only valid outside "
		    "group or neighbor definitions");
		return (-1);
	} else
		return (0);
@


1.4
log
@few missing break; in default: cases in switch; one noticed by tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2003/12/19 01:38:34 henning Exp $ */
d735 1
a735 1
	n->fd = -1;
@


1.3
log
@fix copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2003/12/17 18:11:31 henning Exp $ */
d294 1
@


1.2
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2003/12/17 11:46:54 henning Exp $ */
d4 4
a7 1
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
a20 2

/* lexer mostly from pfctl, written by Theo de Raadt */
@


1.1
log
@welcome, bgpd
started by me some time ago with moral support from theo, the proceeded up to
the point where the session engine worked correctly. claudio jeker joined
then and did a lot of work in the RDE.
it is not particulary usefull as application right now as parts are still
missing but is imported to enable more people to work on it.
status:
BGP sessions get established fine, OPEN messages and then KEEPALIVEs
exchanged etc. session FSM works fine; NOTIFICATIONs are handled fine, and
all connection drops etc I provoked get handled fine.
Incoming UPDATE messgages are parsed well and the data entered to the RIB,
the decision process is not yet there, neither is outgoing UPDATEs or sync
to the kernel routing table.

not connected to the builds yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d762 1
a762 1
		     "group or neighbor definitions");
@

