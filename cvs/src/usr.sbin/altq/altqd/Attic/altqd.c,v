head	1.9;
access;
symbols
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	snap20010624:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2002.11.23.18.47.28;	author deraadt;	state dead;
branches;
next	1.8;

1.8
date	2002.02.20.10.54.24;	author kjc;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.13.08.23.04;	author kjc;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.03.08.40.43;	author kjc;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.04.20.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.20.08.36.27;	author kjc;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.16.12.59.43;	author kjc;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.08.07.07.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.27.18.23.17;	author kjc;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.06.27.18.23.17;	author kjc;	state Exp;
branches;
next	;


desc
@@


1.9
log
@bye bye
@
text
@/*	$OpenBSD: altqd.c,v 1.8 2002/02/20 10:54:24 kjc Exp $	*/
/*	$KAME: altqd.c,v 1.9 2002/02/12 10:12:15 kjc Exp $	*/
/*
 * Copyright (c) 2001 Theo de Raadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright (C) 1997-2002
 *	Sony Computer Science Laboratories, Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY SONY CSL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL SONY CSL OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <net/if.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <syslog.h>
#include <err.h>
#ifndef __FreeBSD__
#include <util.h>
#endif

#include <altq/altq.h>
#include "altq_qop.h"
#include "quip_server.h"

#define MAX_CLIENT		10

static volatile sig_atomic_t gotsig_hup, gotsig_int, gotsig_term;

static void usage(void);
static void sig_handler(int);

static void
usage(void)
{
	fprintf(stderr, "usage: altqd [-vd] [-f config]\n");
	exit(1);
}

static void
sig_handler(int sig)
{
	switch (sig) {
	case SIGHUP:
		gotsig_hup = 1;
		break;
	case SIGINT:
		gotsig_int = 1;
		break;
	case SIGTERM:
		gotsig_term = 1;
		break;
	case SIGPIPE:
		/*
		 * we have lost an API connection.
		 * a subsequent output operation will catch EPIPE.
		 */
		break;
	}
}

int
main(int argc, char **argv)
{
	int	i, c, maxfd, rval, qpsock;
	fd_set	fds, rfds;
	FILE	*fp, *client[MAX_CLIENT];

	m_debug = 0;
	l_debug = LOG_INFO;
	fp = NULL;
	for (i = 0; i < MAX_CLIENT; i++)
		client[i] = NULL;

	while ((c = getopt(argc, argv, "f:vDdl:")) != -1) {
		switch (c) {
		case 'f':
			altqconfigfile = optarg;
			break;
		case 'D':	/* -D => dummy mode */
			Debug_mode = 1;
			printf("Debug mode set.\n");
			break;
		case 'v':
			l_debug = LOG_DEBUG;
			m_debug |= DEBUG_ALTQ;
			daemonize = 0;
			break;
		case 'd':
			daemonize = 0;
			break;
		case 'l':
			l_debug = atoi(optarg);
			break;
		default:
			usage();
		}
	}

	signal(SIGINT, sig_handler);
	signal(SIGTERM, sig_handler);
	signal(SIGHUP, sig_handler);
	signal(SIGPIPE, sig_handler);

	if (daemonize)
		openlog("altqd", LOG_PID, LOG_DAEMON);

	if (qcmd_init() != 0) {
		if (daemonize)
			closelog();
		exit(1);
	}

	/*
	 * open a unix domain socket for altqd clients
	 */
	if ((qpsock = socket(AF_LOCAL, SOCK_STREAM, 0)) < 0)
		LOG(LOG_ERR, errno, "can't open unix domain socket");
	else {
		struct sockaddr_un addr;

		bzero(&addr, sizeof(addr));
		addr.sun_family = AF_LOCAL;
		strlcpy(addr.sun_path, QUIP_PATH, sizeof(addr.sun_path));
		unlink(QUIP_PATH);
		if (bind(qpsock, (struct sockaddr *)&addr,
		    sizeof(addr)) < 0) {
			LOG(LOG_ERR, errno, "can't bind to %s", QUIP_PATH);
			close(qpsock);
			qpsock = -1;
		}
		chmod(QUIP_PATH, 0666);
		if (listen(qpsock, SOMAXCONN) < 0) {
			LOG(LOG_ERR, errno, "can't listen to %s", QUIP_PATH);
			close(qpsock);
			qpsock = -1;
		}
	}

	if (daemonize) {
		daemon(0, 0);

		/* save pid to the pid file (/var/tmp/altqd.pid) */
		if (pidfile(NULL))
			LOG(LOG_WARNING, errno, "can't open pid file");
	} else {
		/* interactive mode */
		fp = stdin;
		printf("\nEnter ? or command:\n");
		printf("altqd %s> ", cur_ifname());
		fflush(stdout);
	}

	/*
	 * go into the command mode.
	 */
	FD_ZERO(&fds);
	maxfd = 0;
	if (fp != NULL) {
		FD_SET(fileno(fp), &fds);
		maxfd = MAX(maxfd, fileno(fp) + 1);
	}
	if (qpsock >= 0) {
		FD_SET(qpsock, &fds);
		maxfd = MAX(maxfd, qpsock + 1);
	}

	rval = 1;
	while (rval) {
		if (gotsig_hup) {
			qcmd_destroyall();
			gotsig_hup = 0;
			LOG(LOG_INFO, 0, "reinitializing altqd...");
			if (qcmd_init() != 0) {
				LOG(LOG_INFO, 0, "reinitialization failed");
				break;
			}
		}
		if (gotsig_term || gotsig_int) {
			LOG(LOG_INFO, 0, "Exiting on signal %d",
			    gotsig_term ? SIGTERM : SIGINT);
			break;
		}

		FD_COPY(&fds, &rfds);
		if (select(maxfd, &rfds, NULL, NULL, NULL) < 0) {
			if (errno != EINTR)
				err(1, "select");
			continue;
		}

		/*
		 * if there is command input, read the input line,
		 * parse it, and execute.
		 */
		if (fp && FD_ISSET(fileno(fp), &rfds)) {
			rval = do_command(fp);
			if (rval == 0) {
				/* quit command or eof on input */
				LOG(LOG_INFO, 0, "Exiting.");
			} else if (fp == stdin)
				printf("altqd %s> ", cur_ifname());
			fflush(stdout);
		} else if (qpsock >= 0 && FD_ISSET(qpsock, &rfds)) {
			/*
			 * quip connection request from client via unix
			 * domain socket; get a new socket for this
			 * connection and add it to the select list.
			 */
			int newsock = accept(qpsock, NULL, NULL);

			if (newsock == -1) {
				LOG(LOG_ERR, errno, "accept");
				continue;
			}
			FD_SET(newsock, &fds);
			for (i = 0; i < MAX_CLIENT; i++)
				if (client[i] == NULL) {
					client[i] = fdopen(newsock, "r+");
					break;
				}
			maxfd = MAX(maxfd, newsock + 1);
		} else {
			/*
			 * check input from a client via unix domain socket
			 */
			for (i = 0; i < MAX_CLIENT; i++) {
				int fd;

				if (client[i] == NULL)
					continue;
				fd = fileno(client[i]);
				if (FD_ISSET(fd, &rfds)) {
					if (quip_input(client[i]) != 0 ||
					    fflush(client[i]) != 0) {
						/* connection closed */
						fclose(client[i]);
						client[i] = NULL;
						FD_CLR(fd, &fds);
					}
				}
			}
		}
	}

	/* cleanup and exit */
	qcmd_destroyall();
	if (qpsock >= 0)
		(void)close(qpsock);
	unlink(QUIP_PATH);

	for (i = 0; i < MAX_CLIENT; i++)
		if (client[i] != NULL)
			(void)fclose(client[i]);
	if (daemonize) {
		closelog();
	}
	exit(0);
}
@


1.8
log
@sync with KAME
- #include <util.h> for pidfile(3).
- use one signal handler instead of three.
- add static to internals.
@
text
@d1 1
a1 1
/*	$OpenBSD: altqd.c,v 1.7 2002/02/13 08:23:04 kjc Exp $	*/
@


1.7
log
@sync with KAME.
wipe away the remaining code fragments which might be
inherited from rsvpd.  (just to make sure.)
@
text
@d1 1
a1 1
/*	$OpenBSD: altqd.c,v 1.6 2001/12/03 08:40:43 kjc Exp $	*/
d67 3
d77 1
a77 1
volatile sig_atomic_t gotsig_hup, gotsig_int, gotsig_term;
d79 2
a80 5
void usage(void);
void sig_pipe(int);
void sig_hup(int);
void sig_int(int);
void sig_term(int);
d82 1
a82 1
void
d89 2
a90 2
void
sig_pipe(int sig)
d92 17
a108 22
	/*
	 * we have lost an API connection.
	 * a subsequent output operation will catch EPIPE.
	 */
}

void
sig_hup(int sig)
{
	gotsig_hup = 1;
}

void
sig_int(int sig)
{
	gotsig_int = 1;
}

void
sig_term(int sig)
{
	gotsig_term = 1;
d149 4
a152 4
	signal(SIGINT, sig_int);
	signal(SIGTERM, sig_term);
	signal(SIGHUP, sig_hup);
	signal(SIGPIPE, sig_pipe);
@


1.6
log
@cleanup submitted by by Miod Vallat <miod@@online.fr>
 - use pidfile()
 - simplifies some perror() + exit() constructs to use err() instead
 - fixes a warn() call instead of a LOG() after daemon() has been called
ok millert@@
@
text
@d1 2
a2 2
/*	$OpenBSD: altqd.c,v 1.5 2001/11/19 04:20:42 deraadt Exp $	*/
/*	$KAME: altqd.c,v 1.5 2001/08/16 10:39:16 kjc Exp $	*/
d27 1
a27 1
 * Copyright (C) 1997-2000
d52 6
a61 1
#include <ctype.h>
a67 9
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>

#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

d74 1
a74 9
int	altqd_socket = -1;
FILE *	client[MAX_CLIENT];
int	T;  			/* Current Thread number */
FILE	*infp;			/* Input file pointer */
char	*infile = NULL;		/* command input file.  stdin if NULL. */
fd_set	fds, t_fds;

#define  DEFAULT_DEBUG_MASK	0
#define  DEFAULT_LOGGING_LEVEL	LOG_INFO
a97 2
volatile sig_atomic_t gotsig_hup, gotsig_int, gotsig_term;

d119 9
a127 5
	int		c;
	int		i, maxfd;

	m_debug = DEFAULT_DEBUG_MASK;
	l_debug = DEFAULT_LOGGING_LEVEL;
d171 1
a171 1
	if ((altqd_socket = socket(AF_LOCAL, SOCK_STREAM, 0)) < 0)
d180 1
a180 1
		if (bind(altqd_socket, (struct sockaddr *)&addr,
d183 2
a184 2
			close(altqd_socket);
			altqd_socket = -1;
d187 1
a187 1
		if (listen(altqd_socket, SOMAXCONN) < 0) {
d189 2
a190 2
			close(altqd_socket);
			altqd_socket = -1;
d202 3
a204 8
		if (infile) {
			if ((infp = fopen(infile, "r")) == NULL)
				err(1, "Cannot open input file");
		} else {
			infp = stdin;
			printf("\nEnter ? or command:\n");
			printf("altqd %s> ", cur_ifname());
		}
a209 1
	 * the code below is taken from rtap of rsvpd.
d213 3
a215 3
	if (infp != NULL) {
		FD_SET(fileno(infp), &fds);
		maxfd = MAX(maxfd, fileno(infp) + 1);
d217 3
a219 3
	if (altqd_socket >= 0) {
		FD_SET(altqd_socket, &fds);
		maxfd = MAX(maxfd, altqd_socket + 1);
a220 2
	while (1) {
		int rc;
d222 2
d227 5
a231 2
			printf("reinitializing altqd...\n");
			qcmd_init();
d234 3
a236 8
			fprintf(stderr, "Exiting on signal %d\n",
				gotsig_term ? SIGTERM : SIGINT);

			qcmd_destroyall();

			if (daemonize)
				closelog();
			exit(0);
d239 2
a240 3
		FD_COPY(&fds, &t_fds);
		rc = select(maxfd, &t_fds, NULL, NULL, NULL);
		if (rc < 0) {
d247 1
a247 1
		 * If there is control input, read the input line,
d250 6
a255 18
		if (infp && FD_ISSET(fileno(infp), &t_fds)) {
			rc = DoCommand(infile, infp);
			if (rc == 0) {
				/*
				 * EOF on input.  If reading from file,
				 * go to stdin; else exit.
				 */
				if (infile) {
					infp = stdin;
					infile = NULL;
					printf("\nEnter ? or command:\n");
					FD_SET(fileno(infp), &fds);
				} else {
					LOG(LOG_INFO, 0, "Exiting.");
					(void) qcmd_destroyall();
					exit(0);
				}
			} else if (infp == stdin)
d258 1
a258 1
		} else if (altqd_socket >= 0 && FD_ISSET(altqd_socket, &t_fds)) {
d264 1
a264 1
			int newsock = accept(altqd_socket, NULL, NULL);
d287 1
a287 1
				if (FD_ISSET(fd, &t_fds)) {
d299 14
@


1.5
log
@blah blah blah.  guess what.  more signals
@
text
@d1 1
a1 1
/*	$OpenBSD: altqd.c,v 1.4 2001/08/20 08:36:27 kjc Exp $	*/
a75 1
#define  ALTQD_PID_FILE		"/var/run/altqd.pid"
a134 1
	extern char	*optarg;
a204 2
		FILE *fp;

d208 2
a209 6
		if ((fp = fopen(ALTQD_PID_FILE, "w")) != NULL) {
			fprintf(fp, "%d\n", getpid());
			fclose(fp);
		} else
			warn("can't open pid file: %s: %s",
			    ALTQD_PID_FILE, strerror(errno));
d213 2
a214 4
			if ((infp = fopen(infile, "r")) == NULL) {
				perror("Cannot open input file");
				exit(1);
			}
d246 3
a248 4
		if (gotsig_term) {
			fprintf(stderr, "Exiting on signal %d\n", SIGTERM);

			qcmd_destroyall();
a249 9
			/* if we have a pid file, remove it */
			if (daemonize) {
				unlink(ALTQD_PID_FILE);
				closelog();
			}
			exit(0);
		}
		if (gotsig_int) {
			fprintf(stderr, "Exiting on signal %d\n", SIGINT);
d252 1
a252 3
			/* if we have a pid file, remove it */
			if (daemonize) {
				unlink(ALTQD_PID_FILE);
a253 1
			}
d260 2
a261 4
			if (errno != EINTR) {
				perror("select");
				exit(1);
			}
@


1.4
log
@fix a bug that steps over the array boundary.
it hasn't been noticed until the recent code restructure.
report by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: altqd.c,v 1.3 2001/08/16 12:59:43 kjc Exp $	*/
d111 1
a111 1
int gotsig_hup, gotsig_int, gotsig_term;
@


1.3
log
@sync with KAME.
altq userland cleanup:
 - string operation audit
 - remove variable names from function prototypes
 - clean up error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: altqd.c,v 1.2 2001/08/08 07:07:27 deraadt Exp $	*/
d337 1
a337 1
			for (i = 0; i <= MAX_CLIENT; i++) {
@


1.2
log
@rewrite signal handlers to be race-safe.  rewrite USC/ISI code I think
sufficiently so that there is nothing in there that doesn't look like
any generic select loop from stevens.  The FD_SET code remains
overflowable... next thing to fix..
@
text
@d1 2
a2 2
/*	$OpenBSD: altqd.c,v 1.1.1.1 2001/06/27 18:23:17 kjc Exp $	*/
/*	$KAME: altqd.c,v 1.2 2000/10/18 09:15:15 kjc Exp $	*/
d89 6
d114 1
a114 1
sig_hup()
d120 1
a120 1
sig_int()
d126 1
a126 1
sig_term()
d184 1
a184 1
		LOG(LOG_ERR, errno, "can't open unix domain socket\n");
d194 1
a194 1
			LOG(LOG_ERR, errno, "can't bind to %s\n", QUIP_PATH);
d200 1
a200 1
			LOG(LOG_ERR, errno, "can't listen to %s\n", QUIP_PATH);
d307 1
a307 1
					LOG(LOG_INFO, 0, "Exiting.\n");
d323 1
a323 1
				LOG(LOG_ERR, errno, "accept error\n");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 23
a50 26
/*******************************************************************

  Copyright (c) 1996 by the University of Southern California
  All rights reserved.

  Permission to use, copy, modify, and distribute this software and its
  documentation in source and binary forms for any purpose and without
  fee is hereby granted, provided that both the above copyright notice
  and this permission notice appear in all copies. and that any
  documentation, advertising materials, and other materials related to
  such distribution and use acknowledge that the software was developed
  in part by the University of Southern California, Information
  Sciences Institute.  The name of the University may not be used to
  endorse or promote products derived from this software without
  specific prior written permission.

  THE UNIVERSITY OF SOUTHERN CALIFORNIA makes no representations about
  the suitability of this software for any purpose.  THIS SOFTWARE IS
  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

  Other copyrights might apply to parts of this software and are so
  noted when applicable.

********************************************************************/
d76 1
a76 3
#define  ALTQD_PID_FILE	  "/var/run/altqd.pid"

static int altqd_socket = -1;
a77 1
static FILE *client[MAX_CLIENT];
d79 6
a84 5
/* for command mode */
int             T;  		/* Current Thread number */
FILE		*infp;		/* Input file pointer */
char           *infile = NULL;  /* command input file.  stdin if NULL. */
fd_set		fds, t_fds;
d86 1
a86 1
#define  DEFAULT_DEBUG_MASK	0	
d89 2
a90 1
static void usage(void)
d92 2
a93 5
	fprintf(stderr, "usage: altqd [options]\n");
	fprintf(stderr, "    options:\n");
	fprintf(stderr, "    -f config_file	: set config file\n");
	fprintf(stderr, "    -v			: verbose (no daemonize)\n");
	fprintf(stderr, "    -d			: debug (no daemonize)\n");
d96 2
a97 2
static void
sig_handler(int sig)
d99 5
a103 7
	if (sig == SIGPIPE) {
		/*
		 * we have lost an API connection.
		 * a subsequent output operation will catch EPIPE.
		 */
		return;
	}
d105 1
a105 1
	qcmd_destroyall();
d107 5
a111 5
	if (sig == SIGHUP) {
		printf("reinitializing altqd...\n");
		qcmd_init();
		return;
	}
d113 5
a117 1
	fprintf(stderr, "Exiting on signal %d\n", sig);
d119 4
a122 12
	/* if we have a pid file, remove it */
	if (daemonize) {
		unlink(ALTQD_PID_FILE);
		closelog();
	}

	if (altqd_socket >= 0) {
		close(altqd_socket);
		altqd_socket = -1;
	}

	exit(0);
d125 2
a126 1
int main(int argc, char **argv)
a139 1

a143 1
			
a148 1

a151 1

a154 1

d160 4
a163 4
	signal(SIGINT, sig_handler);
	signal(SIGTERM, sig_handler);
	signal(SIGHUP, sig_handler);
	signal(SIGPIPE, sig_handler);
a176 2
	for (i = 0; i < MAX_CLIENT; i++)
		client[i] = NULL;
a181 1
		unlink(QUIP_PATH);
d184 2
a185 1
		strcpy(addr.sun_path, QUIP_PATH);
d187 3
a189 3
			 sizeof(addr)) < 0) {
			LOG(LOG_ERR, errno, "can't bind to %s\n",
			    QUIP_PATH);
d194 2
a195 2
			LOG(LOG_ERR, errno, "can't listen to %s\n",
			    QUIP_PATH);
d209 1
a209 2
		}
		else
d211 1
a211 1
			     ALTQD_PID_FILE, strerror(errno));
d215 1
a215 1
			if (NULL == (infp = fopen(infile, "r"))) {
d244 30
d277 1
a277 1
			if (errno != EINTR) {	
d283 1
a283 1
		
d288 1
a288 1
		if (infp != NULL && FD_ISSET(fileno(infp), &t_fds)) {
d298 2
a299 2
					printf("\nEnter ? or command:\n");	
				FD_SET(fileno(infp), &fds);
d315 1
@


1.1.1.1
log
@import ALTQ userland tools from KAME.
@
text
@@
