head	1.22;
access;
symbols
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.16
	OPENBSD_5_0:1.10.0.14
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.12
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.10
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.6
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.6.0.24
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.22
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.20
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.18
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.16
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.14
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.12
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2017.04.02.22.57.20;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	yZD7AsOt3hx3pBQy;

1.21
date	2016.08.02.17.00.09;	author jca;	state Exp;
branches;
next	1.20;
commitid	LwUwsYotrzF8sP65;

1.20
date	2016.06.29.14.19.38;	author jca;	state Exp;
branches;
next	1.19;
commitid	UKZNj8xE8arS6lgt;

1.19
date	2016.02.08.23.19.00;	author jca;	state Exp;
branches;
next	1.18;
commitid	731eoDfUV7AoJwjq;

1.18
date	2016.02.08.22.44.37;	author jca;	state Exp;
branches;
next	1.17;
commitid	ntLnlV1X8ggBAlZX;

1.17
date	2015.12.11.20.15.52;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	V4ug53xJVPDhBc3B;

1.16
date	2015.10.25.22.11.34;	author jca;	state Exp;
branches;
next	1.15;
commitid	fhTQouZIvPQVwdr9;

1.15
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.14;
commitid	GouatFiJVxwlAVIQ;

1.14
date	2013.11.12.22.27.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.30.12.29.04;	author florian;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.02.03.21.20;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2012.07.08.10.46.00;	author phessler;	state Exp;
branches;
next	1.10;

1.10
date	2008.07.21.19.14.15;	author rainer;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.08.21.08.57;	author rainer;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.23.10.17.50;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2008.04.21.20.40.55;	author rainer;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.10.19.57.35;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.29.14.34.05;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.15.11.06.25;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.06.10.14.46;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.23.11.33.47;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Always use return value of asprintf to determine success/failure,
don't rely upon *ret becoming NULL
ok millert, tom
@
text
@/*	$OpenBSD: dump.c,v 1.21 2016/08/02 17:00:09 jca Exp $	*/
/*	$KAME: dump.c,v 1.27 2002/05/29 14:23:55 itojun Exp $	*/

/*
 * Copyright (C) 2000 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_dl.h>

#include <netinet/in.h>

/* XXX: the following two are non-standard include files */
#include <netinet6/in6_var.h>
#include <netinet6/nd6.h>

#include <arpa/inet.h>

#include <time.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <netdb.h>
#include <event.h>

#include "rtadvd.h"
#include "if.h"
#include "log.h"
#include "dump.h"

extern struct ralist ralist;

static char *ether_str(struct sockaddr_dl *);
char *lifetime(int);

static char *rtpref_str[] = {
	"medium",		/* 00 */
	"high",			/* 01 */
	"rsv",			/* 10 */
	"low"			/* 11 */
};

static char *
ether_str(struct sockaddr_dl *sdl)
{
	static char hbuf[NI_MAXHOST];
	u_char *cp;

	if (sdl->sdl_alen) {
		cp = (u_char *)LLADDR(sdl);
		snprintf(hbuf, sizeof(hbuf), "%02x:%02x:%02x:%02x:%02x:%02x",
		    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
	} else
		snprintf(hbuf, sizeof(hbuf), "NONE");

	return(hbuf);
}

char *
lifetime(int lt)
{
	char *str;

	if (lt == ND6_INFINITE_LIFETIME) {
		if (asprintf(&str, "infinity") < 0)
			return (NULL);
	} else {
		if (asprintf(&str, "%ld", (long)lt) < 0)
			return (NULL);
	}
	return str;
}

void
rtadvd_dump(void)
{
	struct rainfo *rai;
	struct prefix *pfx;
	struct rdnss *rds;
	struct dnssl *dsl;
	struct dnssldom *dnsd;
	char prefixbuf[INET6_ADDRSTRLEN];
	int first;
	struct timeval now, next;
	char *origin, *vltime, *pltime, *flags;
	char *vltimexpire=NULL, *pltimexpire=NULL;
	char ctimebuf[26];

	gettimeofday(&now, NULL);
	SLIST_FOREACH(rai, &ralist, entry) {
		log_info("%s:", rai->ifname);

		log_info("  Status: %s",
		    (iflist[rai->ifindex]->ifm_flags & IFF_UP) ? "UP" : "DOWN");

		/* control information */
		if (rai->lastsent.tv_sec) {
			time_t t = rai->lastsent.tv_sec;
			(void)strlcpy(ctimebuf, ctime(&t), sizeof(ctimebuf));
			ctimebuf[strcspn(ctimebuf, "\n")] = '\0';
			log_info("  Last RA sent: %s", ctimebuf);
		}
		if (evtimer_pending(&rai->timer.ev, &next)) {
			time_t t = next.tv_sec;
			(void)strlcpy(ctimebuf, ctime(&t), sizeof(ctimebuf));
			ctimebuf[strcspn(ctimebuf, "\n")] = '\0';
			log_info("  Next RA will be sent: %s", ctimebuf);
		} else
			log_info("  RA timer is stopped");
		log_info("  waits: %u, initcount: %u",
		    rai->waiting, rai->initcounter);

		/* statistics */
		log_info("  statistics: RA(out/in/inconsistent): "
		    "%llu/%llu/%llu, RS(input): %llu",
		    (unsigned long long)rai->raoutput,
		    (unsigned long long)rai->rainput,
		    (unsigned long long)rai->rainconsistent,
		    (unsigned long long)rai->rsinput);

		/* interface information */
		if (rai->advlinkopt)
			log_info("  Link-layer address: %s",
			    ether_str(rai->sdl));
		log_info("  MTU: %d", rai->phymtu);

		/* Router configuration variables */
		log_info("  DefaultLifetime: %d, MaxAdvInterval: %d, "
		    "MinAdvInterval: %d, "
		    "Flags: %s%s, Preference: %s, MTU: %d",
		    rai->lifetime, rai->maxinterval, rai->mininterval,
		    rai->managedflg ? "M" : "-", rai->otherflg ? "O" : "-",
		    rtpref_str[(rai->rtpref >> 3) & 0xff], rai->linkmtu);
		log_info("  ReachableTime: %d, RetransTimer: %d, "
		    "CurHopLimit: %d", rai->reachabletime,
		    rai->retranstimer, rai->hoplimit);
		if (rai->clockskew)
			log_info("  Clock skew: %ldsec",
			    rai->clockskew);
		first = 1;
		TAILQ_FOREACH(pfx, &rai->prefixes, entry) {
			if (first) {
				log_info("  Prefixes:");
				first = 0;
			}
			switch (pfx->origin) {
			case PREFIX_FROM_KERNEL:
				origin = "KERNEL";
				break;
			case PREFIX_FROM_CONFIG:
				origin = "CONFIG";
				break;
			case PREFIX_FROM_DYNAMIC:
				origin = "DYNAMIC";
				break;
			default:
				origin = "";
			}
			if (pfx->vltimeexpire != 0)
				/* truncate to onwire value */
				asprintf(&vltimexpire, "(decr,expire %u)",
				    (u_int32_t)(pfx->vltimeexpire > now.tv_sec ?
				    pfx->vltimeexpire - now.tv_sec : 0));
			if (pfx->pltimeexpire != 0)
				/* truncate to onwire value */
				asprintf(&pltimexpire, "(decr,expire %u)",
				    (u_int32_t)(pfx->pltimeexpire > now.tv_sec ?
				    pfx->pltimeexpire - now.tv_sec : 0));

			vltime = lifetime(pfx->validlifetime);
			pltime = lifetime(pfx->preflifetime);
			asprintf(&flags, "%s%s",
			    pfx->onlinkflg ? "L" : "-",
			    pfx->autoconfflg ? "A" : "-");
			log_info("    %s/%d(%s, vltime: %s%s, "
			    "pltime: %s%s, flags: %s)",
			    inet_ntop(AF_INET6, &pfx->prefix, prefixbuf,
			    sizeof(prefixbuf)), pfx->prefixlen, origin,
			    vltime, (vltimexpire)? vltimexpire : "",
			    pltime, (pltimexpire)? pltimexpire : "", flags);

			free(vltimexpire);
			vltimexpire = NULL;
			free(pltimexpire);
			pltimexpire = NULL;
			free(vltime);
			free(pltime);
			free(flags);
		}

		if (!TAILQ_EMPTY(&rai->rdnsss))
			log_info("  Recursive DNS servers:");
		TAILQ_FOREACH(rds, &rai->rdnsss, entry) {
			log_info("    Servers:");
			for (first = 0; first < rds->servercnt; ++first) {
				inet_ntop(AF_INET6, &rds->servers[first],
				    prefixbuf, sizeof(prefixbuf));
				log_info("      %s", prefixbuf);
			}
			log_info("    Lifetime: %u", rds->lifetime);
		}

		if (!TAILQ_EMPTY(&rai->dnssls))
			log_info("  DNS search lists:");
		TAILQ_FOREACH(dsl, &rai->dnssls, entry) {
			log_info("    Domains:");

			TAILQ_FOREACH(dnsd, &dsl->dnssldoms, entry)
				log_info("      %s", dnsd->domain);

			log_info("    Lifetime: %u", dsl->lifetime);
		}
	}
}
@


1.21
log
@Move to libevent; ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.20 2016/06/29 14:19:38 jca Exp $	*/
d92 1
a92 1
	char *str = NULL;
d94 7
a100 4
	if (lt == ND6_INFINITE_LIFETIME)
		(void)asprintf(&str, "infinity");
	else
		(void)asprintf(&str, "%ld", (long)lt);
@


1.20
log
@Spring cleanup

- pointless casts, kill caddr_t or replace it with char *
- signed counters
- simplify if_getmtu, only one method is needed and SIOCGIFMTU is the
  cheapest
- we no longer have drivers for IFT_FDDI
- hide details of iflist management
- if (dflag) log_debug -> log_debug
- dead code and comments
- etc etc

Input from and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.19 2016/02/08 23:19:00 jca Exp $	*/
d54 1
a56 1
#include "timer.h"
d111 1
a111 1
	struct timeval now;
d114 1
d126 3
a128 2
			/* note that ctime() appends CR by itself */
			log_info("  Last RA sent: %s", ctime(&t));
d130 5
a134 3
		if (rai->timer) {
			time_t t = rai->timer->tm.tv_sec;
			log_info("  Next RA will be sent: %s", ctime(&t));
@


1.19
log
@Kill trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.18 2016/02/08 22:44:37 jca Exp $	*/
d115 1
a115 1
	gettimeofday(&now, NULL); /* XXX: unused in most cases */
a126 1

d133 2
a134 3
		log_info("  waits: %d, initcount: %d",

			rai->waiting, rai->initcounter);
@


1.18
log
@Print MAX addresses padded with a leading zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.17 2015/12/11 20:15:52 mmcc Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
@


1.17
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.16 2015/10/25 22:11:34 jca Exp $	*/
d81 2
a82 2
		snprintf(hbuf, sizeof(hbuf), "%x:%x:%x:%x:%x:%x",
			cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
@


1.16
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.15 2015/06/03 02:24:36 millert Exp $	*/
d207 4
a210 8
			if (vltimexpire) {
				free(vltimexpire);
				vltimexpire = NULL;
			}
			if (pltimexpire) {
				free(pltimexpire);
				pltimexpire = NULL;
			}
@


1.15
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.14 2013/11/12 22:27:13 deraadt Exp $	*/
d74 1
a74 2
ether_str(sdl)
	struct sockaddr_dl *sdl;
@


1.14
log
@ensure there are prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.13 2013/04/30 12:29:04 florian Exp $	*/
d93 1
a93 1
	char *str;
d96 1
a96 1
		asprintf(&str, "infinity");
d98 1
a98 1
		asprintf(&str, "%ld", (long)lt);
@


1.13
log
@move variables to type time_t; fix format strings

test/ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.12 2013/04/02 03:21:20 deraadt Exp $	*/
d64 1
d90 1
a90 1
char*
d103 1
a103 1
rtadvd_dump()
@


1.12
log
@tv_sec is not neccessarily the same type (or size) as time_t
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.11 2012/07/08 10:46:00 phessler Exp $	*/
d185 4
a188 3
				asprintf(&vltimexpire, "(decr,expire %ld)", (long)
				    pfx->vltimeexpire > now.tv_sec ?
				    pfx->vltimeexpire - now.tv_sec : 0);
d190 4
a193 3
				asprintf(&pltimexpire, "(decr,expire %ld)", (long)
				    pfx->pltimeexpire > now.tv_sec ?
				    pfx->pltimeexpire - now.tv_sec : 0);
@


1.11
log
@Add support for advertising dns servers and search paths in router
advertisements, according to RFC 6106.

original diff from Stephane A. Sezer on tech@@, many thanks!

OK phessler@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.10 2008/07/21 19:14:15 rainer Exp $	*/
d124 1
d126 1
a126 2
			log_info("  Last RA sent: %s",
			    ctime((time_t *)&rai->lastsent.tv_sec));
d130 3
a132 5
			log_info("  Next RA will be sent: %s",
			    ctime((time_t *)&rai->timer->tm.tv_sec));

		}
		else
@


1.10
log
@fix ugly debug dump output. found with bluhm@@

ok thib@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.9 2008/06/08 21:08:57 rainer Exp $	*/
d106 3
d218 23
@


1.9
log
@Send debug output to syslog instead of a file when receiving SIGUSR1.
This is a preparation for dropping privileges.

ok henning@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.8 2008/04/23 10:17:50 pyr Exp $	*/
d153 1
a153 1
		    "MinAdvInterval: %d"
d156 1
a156 1
		    rai->managedflg ? "M" : "", rai->otherflg ? "O" : "",
d195 2
a196 2
			    pfx->onlinkflg ? "L" : "",
			    pfx->autoconfflg ? "A" : "");
@


1.8
log
@Replace handrolled lists with SLISTs or TAILQs.
Timers remain and will be handled later.
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.7 2008/04/21 20:40:55 rainer Exp $	*/
d50 1
d58 1
a59 3
#include "log.h"

static FILE *fp;
a63 1
static void if_dump(void);
d89 14
a102 2
static void
if_dump()
d109 2
d114 1
a114 1
		fprintf(fp, "%s:\n", rai->ifname);
d116 2
a117 3
		fprintf(fp, "  Status: %s\n",
			(iflist[rai->ifindex]->ifm_flags & IFF_UP) ? "UP" :
			"DOWN");
d122 3
a124 2
			fprintf(fp, "  Last RA sent: %s",
				ctime((time_t *)&rai->lastsent.tv_sec));
d127 3
a129 2
			fprintf(fp, "  Next RA will be sent: %s",
				ctime((time_t *)&rai->timer->tm.tv_sec));
d132 3
a134 2
			fprintf(fp, "  RA timer is stopped");
		fprintf(fp, "  waits: %d, initcount: %d\n",
d138 2
a139 2
		fprintf(fp, "  statistics: RA(out/in/inconsistent): "
		    "%llu/%llu/%llu, ",
d142 1
a142 2
		    (unsigned long long)rai->rainconsistent);
		fprintf(fp, "RS(input): %llu\n",
d147 1
a147 1
			fprintf(fp, "  Link-layer address: %s\n",
d149 1
a149 1
		fprintf(fp, "  MTU: %d\n", rai->phymtu);
d152 4
a155 4
		fprintf(fp, "  DefaultLifetime: %d, MaxAdvInterval: %d, "
		    "MinAdvInterval: %d\n", rai->lifetime, rai->maxinterval,
		    rai->mininterval);
		fprintf(fp, "  Flags: %s%s%s, ",
d157 4
a160 7
		    "");
		fprintf(fp, "Preference: %s, ",
			rtpref_str[(rai->rtpref >> 3) & 0xff]);
		fprintf(fp, "MTU: %d\n", rai->linkmtu);
		fprintf(fp, "  ReachableTime: %d, RetransTimer: %d, "
			"CurHopLimit: %d\n", rai->reachabletime,
			rai->retranstimer, rai->hoplimit);
d162 1
a162 1
			fprintf(fp, "  Clock skew: %ldsec\n",
d167 1
a167 1
				fprintf(fp, "  Prefixes:\n");
a169 3
			fprintf(fp, "    %s/%d(",
			    inet_ntop(AF_INET6, &pfx->prefix, prefixbuf,
			    sizeof(prefixbuf)), pfx->prefixlen);
d172 1
a172 1
				fprintf(fp, "KERNEL, ");
d175 1
a175 1
				fprintf(fp, "CONFIG, ");
d178 1
a178 1
				fprintf(fp, "DYNAMIC, ");
d180 2
a182 5
			if (pfx->validlifetime == ND6_INFINITE_LIFETIME)
				fprintf(fp, "vltime: infinity");
			else
				fprintf(fp, "vltime: %ld",
					(long)pfx->validlifetime);
d184 3
a186 10
				fprintf(fp, "(decr,expire %ld), ", (long)
					pfx->vltimeexpire > now.tv_sec ?
					pfx->vltimeexpire - now.tv_sec : 0);
			else
				fprintf(fp, ", ");
			if (pfx->preflifetime ==  ND6_INFINITE_LIFETIME)
				fprintf(fp, "pltime: infinity");
			else
				fprintf(fp, "pltime: %ld",
					(long)pfx->preflifetime);
d188 27
a214 10
				fprintf(fp, "(decr,expire %ld), ", (long)
					pfx->pltimeexpire > now.tv_sec ?
					pfx->pltimeexpire - now.tv_sec : 0);
			else
				fprintf(fp, ", ");
			fprintf(fp, "flags: %s%s%s",
				pfx->onlinkflg ? "L" : "",
				pfx->autoconfflg ? "A" : "",
				"");
			fprintf(fp, ")\n");
a216 14
}

void
rtadvd_dump_file(dumpfile)
	char *dumpfile;
{
	if ((fp = fopen(dumpfile, "w")) == NULL) {
		log_warn("open a dump file(%s)", dumpfile);
		return;
	}

	if_dump();

	fclose(fp);
@


1.7
log
@Clean up logging by introducing the logging API used in
other daemons and clean up the command line options.
For details, see rtadvd(8).

ok bluhm@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.6 2002/06/10 19:57:35 espie Exp $	*/
d62 1
a62 1
extern struct rainfo *ralist;
d101 1
a101 1
	for (rai = ralist; rai; rai = rai->next) {
d154 2
a155 2
		for (first = 1, pfx = rai->prefix.next; pfx != &rai->prefix;
		     pfx = pfx->next) {
@


1.6
log
@Kill __FUNCTION__.
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.5 2002/05/29 14:34:05 itojun Exp $	*/
a49 1
#include <syslog.h>
d58 1
d210 1
a210 2
		syslog(LOG_WARNING, "<%s> open a dump file(%s)",
		       __func__, dumpfile);
@


1.5
log
@KNF, strlcpy, cleanups from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.4 2002/02/16 21:28:08 millert Exp $	*/
d211 1
a211 1
		       __FUNCTION__, dumpfile);
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 2
a2 2
/*	$OpenBSD: dump.c,v 1.3 2001/01/15 11:06:25 itojun Exp $	*/
/*	$KAME: dump.c,v 1.15 2000/11/11 06:57:22 jinmei Exp $	*/
a36 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#include <net/if_var.h>
#endif /* __FreeBSD__ >= 3 */
d53 1
d67 6
a72 5
#ifdef __FreeBSD__		/* XXX: see PORTABILITY */
#define LONGLONG "%qu"
#else
#define LONGLONG "%llu"
#endif
d78 1
a78 1
	static char ebuf[32];
d81 1
a81 1
	if (sdl->sdl_alen && sdl->sdl_alen > 5) {
d83 1
a83 1
		sprintf(ebuf, "%x:%x:%x:%x:%x:%x",
d85 2
a86 4
	}
	else {
		sprintf(ebuf, "NONE");
	}
d88 1
a88 1
	return(ebuf);
d124 7
a130 8
		fprintf(fp,
			"  statistics: RA(out/in/inconsistent): "
			LONGLONG "/" LONGLONG "/" LONGLONG ", ",
			(unsigned long long)rai->raoutput,
			(unsigned long long)rai->rainput,
			(unsigned long long)rai->rainconsistent);
		fprintf(fp, "RS(input): " LONGLONG "\n",
			(unsigned long long)rai->rsinput);
d135 1
a135 1
				ether_str(rai->sdl));
d139 9
a147 10
		fprintf(fp,
			"  DefaultLifetime: %d, MaxAdvInterval: %d, "
			"MinAdvInterval: %d\n",
			rai->lifetime, rai->maxinterval, rai->mininterval);
		fprintf(fp, "  Flags: %s%s%s MTU: %d\n",
			rai->managedflg ? "M" : "", rai->otherflg ? "O" : "",
#ifdef MIP6
			rai->haflg ? "H" :
#endif
			"", rai->linkmtu);
a150 5
#ifdef MIP6
		fprintf(fp, "  HAPreference: %d, HALifetime: %d\n",
			rai->hapref, rai->hatime);
#endif 

d153 1
a153 1
				rai->clockskew);  
d161 3
a163 4
				inet_ntop(AF_INET6, &pfx->prefix,
					  prefixbuf, sizeof(prefixbuf)),
				pfx->prefixlen);
			switch(pfx->origin) {
a198 3
#ifdef MIP6
				pfx->routeraddr ? "R" :
#endif
@


1.3
log
@sync with latest kame tree.
- reduce chances for signal handler rae condition
- decrease chances for misconfiguration
- feedbacks from router renumbering protocol bakeoff
- cleanups related to mtu handling
@
text
@d1 1
a1 1
/*	$OpenBSD: dump.c,v 1.2 2000/07/06 10:14:46 itojun Exp $	*/
d66 2
a67 2
static char *ether_str __P((struct sockaddr_dl *));
static void if_dump __P((void));
@


1.2
log
@sync with router renumber struct decl change.
more logs.  make it very sure to close temporary socket.
@
text
@d1 2
a2 2
/*	$OpenBSD: dump.c,v 1.1 2000/05/23 11:33:47 itojun Exp $	*/
/*	$KAME: dump.c,v 1.11 2000/05/27 11:30:43 jinmei Exp $	*/
d34 1
d101 1
d103 1
d161 3
d186 1
a186 1
				fprintf(fp, "vltime: infinity, ");
d188 1
a188 1
				fprintf(fp, "vltime: %ld, ",
d190 6
d197 1
a197 1
				fprintf(fp, "pltime: infinity, ");
d199 1
a199 1
				fprintf(fp, "pltime: %ld, ",
d201 6
@


1.1
log
@forgot to cvs add dump.[ch]
strict prototype
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: dump.c,v 1.10 2000/05/23 11:31:25 itojun Exp $	*/
d58 1
d104 4
d118 2
@

