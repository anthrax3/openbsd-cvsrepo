head	1.60;
access;
symbols
	OPENBSD_6_0:1.57.0.2
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.43.0.6
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.2
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.16
	OPENBSD_5_0:1.26.0.14
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.12
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.10
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.6
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.8
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.4
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.23.0.8
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.6
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.12
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.10
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.8
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.6
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	kame_19991211:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.60
date	2016.09.25.13.54.39;	author florian;	state Exp;
branches;
next	1.59;
commitid	7zkEamfTqSFskBzT;

1.59
date	2016.09.25.13.54.00;	author florian;	state Exp;
branches;
next	1.58;
commitid	1P1y3rRstlLGdta4;

1.58
date	2016.08.02.17.00.09;	author jca;	state Exp;
branches;
next	1.57;
commitid	LwUwsYotrzF8sP65;

1.57
date	2016.06.29.14.19.38;	author jca;	state Exp;
branches;
next	1.56;
commitid	UKZNj8xE8arS6lgt;

1.56
date	2016.03.01.20.51.05;	author jca;	state Exp;
branches;
next	1.55;
commitid	odaF3eMKay0HIw4l;

1.55
date	2016.03.01.12.52.43;	author jca;	state Exp;
branches;
next	1.54;
commitid	qLTuytlmNQD2lPuw;

1.54
date	2016.02.29.20.25.46;	author jca;	state Exp;
branches;
next	1.53;
commitid	a13okc2oAYKgLGZT;

1.53
date	2016.02.29.06.37.55;	author jca;	state Exp;
branches;
next	1.52;
commitid	M9X5kpFGOaLHtIxk;

1.52
date	2016.02.26.12.33.30;	author jca;	state Exp;
branches;
next	1.51;
commitid	77arGc2n86Wbep20;

1.51
date	2016.02.26.12.31.48;	author jca;	state Exp;
branches;
next	1.50;
commitid	97QqZOQOAOQrxev4;

1.50
date	2016.02.09.00.39.13;	author jca;	state Exp;
branches;
next	1.49;
commitid	56O7SdKp4bWnIxx6;

1.49
date	2016.02.08.23.19.00;	author jca;	state Exp;
branches;
next	1.48;
commitid	731eoDfUV7AoJwjq;

1.48
date	2016.02.08.23.15.37;	author jca;	state Exp;
branches;
next	1.47;
commitid	e0hXBsxU32N38fYG;

1.47
date	2016.02.05.11.26.26;	author reyk;	state Exp;
branches;
next	1.46;
commitid	Y6uVb5EfRwzHLjS6;

1.46
date	2016.01.25.05.00.12;	author jca;	state Exp;
branches;
next	1.45;
commitid	NIlfQ83qH3MDzjm9;

1.45
date	2015.12.11.20.15.52;	author mmcc;	state Exp;
branches;
next	1.44;
commitid	V4ug53xJVPDhBc3B;

1.44
date	2015.10.25.22.11.34;	author jca;	state Exp;
branches;
next	1.43;
commitid	fhTQouZIvPQVwdr9;

1.43
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	Uu5nFG3wCl0LACBb;

1.42
date	2014.07.04.22.39.31;	author guenther;	state Exp;
branches;
next	1.41;
commitid	uZtmgjqfBmgQ2HY0;

1.41
date	2014.06.29.00.58.45;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	JPNyzoRAXfnuJx1K;

1.40
date	2013.10.17.16.27.48;	author bluhm;	state Exp;
branches;
next	1.39;

1.39
date	2013.06.01.21.57.12;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2013.06.01.01.30.53;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2013.05.08.06.32.07;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2013.05.08.06.28.09;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2013.05.08.06.26.05;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2013.05.08.06.24.44;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2013.04.30.12.30.40;	author florian;	state Exp;
branches;
next	1.32;

1.32
date	2013.04.30.12.29.04;	author florian;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.17.00.38.29;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2012.09.05.05.52.10;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2012.07.09.08.55.19;	author phessler;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.08.10.46.00;	author phessler;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.08.09.30.03;	author phessler;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.23.10.17.50;	author pyr;	state Exp;
branches;
next	1.25;

1.25
date	2008.04.21.20.40.55;	author rainer;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.20.11.36.48;	author rainer;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.22.10.49.17;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.18.02.26.58;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.10.21.14.40;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.10.18.08.11;	author todd;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.15.02.52.10;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.10.19.57.35;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.09.02.15.54;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.08.18.11.13;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.29.14.34.05;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.03.09.27.31;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.05.06.05.08;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.04.06.22.05;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.23.15.36.40;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.21.15.11.18;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.15.11.06.24;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.06.10.14.46;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.23.11.23.22;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.13.06.16.11;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.08.05.34.45;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.02.04.10.37;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.11.10.33.28;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.11.10.23.29;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.11.10.23.29;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.60
log
@consistently use MAX_ prefix
OK jca
@
text
@/*	$OpenBSD: config.c,v 1.59 2016/09/25 13:54:00 florian Exp $	*/
/*	$KAME: config.c,v 1.62 2002/05/29 10:13:10 itojun Exp $	*/

/*
 * Copyright (C) 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/sysctl.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>
#include <net/if_dl.h>

#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>

#include <arpa/inet.h>

#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ifaddrs.h>
#include <stdint.h>
#include <event.h>

#include "rtadvd.h"
#include "advcap.h"
#include "if.h"
#include "config.h"
#include "log.h"

static void makeentry(char *, size_t, int, char *);
static int getinet6sysctl(int);

extern struct ralist ralist;

void
getconfig(char *intface)
{
	int stat, i;
	char tbuf[BUFSIZ];
	struct rainfo *tmp;
	long val;
	int64_t val64;
	char buf[BUFSIZ];
	char *bp = buf;
	char *addr;
	static int forwarding = -1;

#define MUSTHAVE(var, cap)	\
    do {								\
	int64_t t;							\
	if ((t = agetnum(cap)) < 0) {					\
		log_warnx("need %s for interface %s",			\
			cap, intface);					\
		exit(1);						\
	}								\
	var = t;							\
     } while (0)
#define MAYHAVE(var, cap, def)	\
     do {								\
	if ((var = agetnum(cap)) < 0)					\
		var = def;						\
     } while (0)

	if ((stat = agetent(tbuf, intface)) <= 0) {
		memset(tbuf, 0, sizeof(tbuf));
		log_info("Could not parse configuration file for %s"
		    " or the configuration file doesn't exist."
		    " Treat it as default", intface);
	}

	if ((tmp = calloc(1, sizeof(*tmp))) == NULL)
		fatal(NULL);

	TAILQ_INIT(&tmp->prefixes);
	TAILQ_INIT(&tmp->rtinfos);
	TAILQ_INIT(&tmp->rdnsss);
	TAILQ_INIT(&tmp->dnssls);

	/* check if we are allowed to forward packets (if not determined) */
	if (forwarding < 0) {
		if ((forwarding = getinet6sysctl(IPV6CTL_FORWARDING)) < 0)
			exit(1);
	}

	/* make sure that the user-specified interface name fits */
	if (strlcpy(tmp->ifname, intface,
	    sizeof(tmp->ifname)) >= sizeof(tmp->ifname))
		fatalx("invalid interface name");

	/* get interface information */
	if (agetflag("nolladdr"))
		tmp->advlinkopt = 0;
	else
		tmp->advlinkopt = 1;
	if (tmp->advlinkopt) {
		if ((tmp->sdl = if_nametosdl(intface)) == NULL) {
			log_warnx("can't get information of %s", intface);
			exit(1);
		}
		tmp->ifindex = tmp->sdl->sdl_index;
	} else
		tmp->ifindex = if_nametoindex(intface);
	if ((tmp->phymtu = if_getmtu(intface)) == 0) {
		tmp->phymtu = IPV6_MMTU;
		log_warn("can't get interface mtu of %s. Treat as %d",
		    intface, IPV6_MMTU);
	}

	/*
	 * set router configuration variables.
	 */
	MAYHAVE(val, "maxinterval", DEF_MAXRTRADVINTERVAL);
	if (val < MIN_MAXINTERVAL || val > MAX_MAXINTERVAL) {
		log_warnx("maxinterval (%ld) on %s is invalid "
		    "(must be between %u and %u)", val,
		    intface, MIN_MAXINTERVAL, MAX_MAXINTERVAL);
		exit(1);
	}
	tmp->maxinterval = (u_int)val;
	MAYHAVE(val, "mininterval", tmp->maxinterval/3);
	if (val < MIN_MININTERVAL || val > (tmp->maxinterval * 3) / 4) {
		log_warnx("mininterval (%ld) on %s is invalid "
		    "(must be between %u and %u)",
		    val, intface, MIN_MININTERVAL, (tmp->maxinterval * 3) / 4);
		exit(1);
	}
	tmp->mininterval = (u_int)val;

	MAYHAVE(val, "chlim", DEF_ADVCURHOPLIMIT);
	tmp->hoplimit = val & 0xff;

	MAYHAVE(val, "raflags", 0);
	tmp->managedflg = val & ND_RA_FLAG_MANAGED;
	tmp->otherflg = val & ND_RA_FLAG_OTHER;
	tmp->rtpref = val & ND_RA_FLAG_RTPREF_MASK;
	if (tmp->rtpref == ND_RA_FLAG_RTPREF_RSV) {
		log_warnx("invalid router preference (%02x) on %s",
		    tmp->rtpref, intface);
		exit(1);
	}

	MAYHAVE(val, "rltime", tmp->maxinterval * 3);
	if (val && (val < tmp->maxinterval || val > MAX_ROUTERLIFETIME)) {
		log_warnx("router lifetime (%ld) on %s is invalid "
		    "(must be 0 or between %d and %d)",
		    val, intface,
		    tmp->maxinterval, MAX_ROUTERLIFETIME);
		exit(1);
	}
	/*
	 * Basically, hosts MUST NOT send Router Advertisement messages at any
	 * time (RFC 2461, Section 6.2.3). However, it would sometimes be
	 * useful to allow hosts to advertise some parameters such as prefix
	 * information and link MTU. Thus, we allow hosts to invoke rtadvd
	 * only when router lifetime (on every advertising interface) is
	 * explicitely set to zero. (see also the above section)
	 */
	if (val && forwarding == 0) {
		log_warnx("non zero router lifetime is specified for %s, "
		    "which must not be allowed for hosts.  you must "
		    "change router lifetime or enable IPv6 forwarding.",
		    intface);
		exit(1);
	}
	tmp->lifetime = val & 0xffff;

	MAYHAVE(val, "rtime", DEF_ADVREACHABLETIME);
	if (val < 0 || val > MAX_REACHABLETIME) {
		log_warnx("reachable time (%ld) on %s is invalid"
		    " (must be no greater than %d)",
		    val, intface, MAX_REACHABLETIME);
		exit(1);
	}
	tmp->reachabletime = (u_int32_t)val;

	MAYHAVE(val64, "retrans", DEF_ADVRETRANSTIMER);
	if (val64 < 0 || val64 > 0xffffffff) {
		log_warnx("retrans time (%lld) on %s out of range",
		    (long long)val64, intface);
		exit(1);
	}
	tmp->retranstimer = (u_int32_t)val64;

	if (agetnum("hapref") != -1 || agetnum("hatime") != -1) {
		log_warnx("mobile-ip6 configuration not supported");
		exit(1);
	}
	/* prefix information */

	/*
	 * This is an implementation specific parameter to consider
	 * link propagation delays and poorly synchronized clocks when
	 * checking consistency of advertised lifetimes.
	 */
	MAYHAVE(val, "clockskew", 0);
	tmp->clockskew = val;

	tmp->pfxs = 0;
	for (i = -1; i < MAXPREFIX; i++) {
		struct prefix *pfx;
		char entbuf[256];

		makeentry(entbuf, sizeof(entbuf), i, "addr");
		addr = agetstr(entbuf, &bp);
		if (addr == NULL)
			continue;

		/* allocate memory to store prefix information */
		if ((pfx = calloc(1, sizeof(*pfx))) == NULL)
			fatal(NULL);

		/* link into chain */
		TAILQ_INSERT_TAIL(&tmp->prefixes, pfx, entry);
		tmp->pfxs++;

		pfx->origin = PREFIX_FROM_CONFIG;

		if (inet_pton(AF_INET6, addr, &pfx->prefix) != 1) {
			log_warn("inet_pton failed for %s", addr);
			exit(1);
		}
		if (IN6_IS_ADDR_MULTICAST(&pfx->prefix)) {
			log_warnx("multicast prefix (%s) must"
			    " not be advertised on %s",
			    addr, intface);
			exit(1);
		}
		if (IN6_IS_ADDR_LINKLOCAL(&pfx->prefix))
			log_info("link-local prefix (%s) will be"
			    " advertised on %s",
			    addr, intface);

		makeentry(entbuf, sizeof(entbuf), i, "prefixlen");
		MAYHAVE(val, entbuf, 64);
		if (val < 0 || val > 128) {
			log_warnx("prefixlen (%ld) for %s "
                            "on %s out of range",
			    val, addr, intface);
			exit(1);
		}
		pfx->prefixlen = (int)val;

		makeentry(entbuf, sizeof(entbuf), i, "pinfoflags");
		MAYHAVE(val, entbuf,
			(ND_OPT_PI_FLAG_ONLINK|ND_OPT_PI_FLAG_AUTO));
		pfx->onlinkflg = val & ND_OPT_PI_FLAG_ONLINK;
		pfx->autoconfflg = val & ND_OPT_PI_FLAG_AUTO;

		makeentry(entbuf, sizeof(entbuf), i, "vltime");
		MAYHAVE(val64, entbuf, DEF_ADVVALIDLIFETIME);
		if (val64 < 0 || val64 > 0xffffffff) {
			log_warnx("vltime (%lld) for"
			    " %s/%d on %s is out of range",
			    (long long)val64,
			    addr, pfx->prefixlen, intface);
			exit(1);
		}
		pfx->validlifetime = (u_int32_t)val64;

		makeentry(entbuf, sizeof(entbuf), i, "vltimedecr");
		if (agetflag(entbuf)) {
			struct timeval now;
			gettimeofday(&now, 0);
			pfx->vltimeexpire =
				now.tv_sec + pfx->validlifetime;
		}

		makeentry(entbuf, sizeof(entbuf), i, "pltime");
		MAYHAVE(val64, entbuf, DEF_ADVPREFERREDLIFETIME);
		if (val64 < 0 || val64 > 0xffffffff) {
			log_warnx("pltime (%lld) for %s/%d on %s"
			    " is out of range",
			    (long long)val64,
			    addr, pfx->prefixlen, intface);
			exit(1);
		}
		pfx->preflifetime = (u_int32_t)val64;

		makeentry(entbuf, sizeof(entbuf), i, "pltimedecr");
		if (agetflag(entbuf)) {
			struct timeval now;
			gettimeofday(&now, 0);
			pfx->pltimeexpire =
				now.tv_sec + pfx->preflifetime;
		}
	}
	if (tmp->pfxs == 0 && !agetflag("noifprefix"))
		get_prefix(tmp);

	for (i = -1; i < MAXRTINFO; i++) {
		struct rtinfo *rti;
		char entbuf[256];
		const char *flagstr;

		makeentry(entbuf, sizeof(entbuf), i, "rtprefix");
		addr = agetstr(entbuf, &bp);
		if (addr == NULL)
			continue;

		rti = malloc(sizeof(struct rtinfo));
		if (rti == NULL)
			fatal(NULL);

		if (inet_pton(AF_INET6, addr, &rti->prefix) != 1) {
			log_warn("inet_pton failed for %s", addr);
			exit(1);
		}

		makeentry(entbuf, sizeof(entbuf), i, "rtplen");
		MAYHAVE(val, entbuf, 64);
		if (val < 0 || val > 128) {
			log_warnx("route prefixlen (%ld) for %s "
                            "on %s out of range",
			    val, addr, intface);
			exit(1);
		}
		rti->prefixlen = (int)val;

		makeentry(entbuf, sizeof(entbuf), i, "rtflags");
		if ((flagstr = agetstr(entbuf, &bp))) {
			val = 0;
			if (strchr(flagstr, 'h'))
				val |= ND_RA_FLAG_RTPREF_HIGH;
			if (strchr(flagstr, 'l')) {
				if (val & ND_RA_FLAG_RTPREF_HIGH) {
					log_warnx("the \'h\' and \'l\'"
					    " route preferences are"
					    " exclusive");
					exit(1);
				}
				val |= ND_RA_FLAG_RTPREF_LOW;
			}
		} else
			MAYHAVE(val, entbuf, 0);

		rti->rtpref = val & ND_RA_FLAG_RTPREF_MASK;
		if (rti->rtpref == ND_RA_FLAG_RTPREF_RSV) {
			log_warnx("invalid route preference (%02x)"
			    " for %s/%d on %s",
			    rti->rtpref, addr, rti->prefixlen, intface);
			exit(1);
		}

		makeentry(entbuf, sizeof(entbuf), i, "rtltime");
		MAYHAVE(val64, entbuf, -1);
		if (val64 == -1)
			val64 = tmp->lifetime;
		if (val64 < 0 || val64 >= 0xffffffff) {
			log_warnx("route lifetime (%d) "
			    " for %s/%d on %s out of range",
			    rti->rtpref, addr, rti->prefixlen, intface);
			exit(1);
		}
		rti->lifetime = (uint32_t)val64;

		TAILQ_INSERT_TAIL(&tmp->rtinfos, rti, entry);
	}

	for (i = -1; i < MAXRDNSS; ++i) {
		struct rdnss *rds;
		char entbuf[256];
		char *tmpaddr;

		makeentry(entbuf, sizeof(entbuf), i, "rdnss");
		addr = agetstr(entbuf, &bp);
		if (addr == NULL)
			continue;

		/* servers are separated by commas in the config file */
		val = 1;
		tmpaddr = addr;
		while (*tmpaddr++)
			if (*tmpaddr == ',')
				++val;

		rds = malloc(sizeof(struct rdnss) + val * sizeof(struct in6_addr));
		if (rds == NULL)
			fatal(NULL);

		TAILQ_INSERT_TAIL(&tmp->rdnsss, rds, entry);

		rds->servercnt = val;

		makeentry(entbuf, sizeof(entbuf), i, "rdnssltime");
		MAYHAVE(val, entbuf, (tmp->maxinterval * 3) / 2);
		if (val < tmp->maxinterval || val > tmp->maxinterval * 2) {
			log_warnx("%s (%ld) on %s is invalid "
			    "(should be between %d and %d)",
			    entbuf, val, intface, tmp->maxinterval,
			    tmp->maxinterval * 2);
		}
		rds->lifetime = val;

		val = 0;
		while ((tmpaddr = strsep(&addr, ","))) {
			if (inet_pton(AF_INET6, tmpaddr, &rds->servers[val]) != 1) {
				log_warn("inet_pton failed for %s", tmpaddr);
				exit(1);
			}
			val++;
		}
	}

	for (i = -1; i < MAXDNSSL; ++i) {
		struct dnssl *dsl;
		char entbuf[256];
		char *tmpsl;

		makeentry(entbuf, sizeof(entbuf), i, "dnssl");
		addr = agetstr(entbuf, &bp);
		if (addr == NULL)
			continue;

		dsl = malloc(sizeof(struct dnssl));
		if (dsl == NULL)
			fatal(NULL);

		TAILQ_INIT(&dsl->dnssldoms);

		while ((tmpsl = strsep(&addr, ","))) {
			struct dnssldom *dnsd;
			size_t len;

			len = strlen(tmpsl);

			/* if the domain is not "dot-terminated", add it */
			if (tmpsl[len - 1] != '.')
				len += 1;

			dnsd = malloc(sizeof(struct dnssldom) + len + 1);
			if (dnsd == NULL)
				fatal(NULL);

			dnsd->length = len;
			strlcpy(dnsd->domain, tmpsl, len + 1);
			dnsd->domain[len - 1] = '.';
			dnsd->domain[len] = '\0';

			TAILQ_INSERT_TAIL(&dsl->dnssldoms, dnsd, entry);
		}

		TAILQ_INSERT_TAIL(&tmp->dnssls, dsl, entry);

		makeentry(entbuf, sizeof(entbuf), i, "dnsslltime");
		MAYHAVE(val, entbuf, (tmp->maxinterval * 3) / 2);
		if (val < tmp->maxinterval || val > tmp->maxinterval * 2) {
			log_warnx("%s (%ld) on %s is invalid "
			    "(should be between %d and %d)",
			    entbuf, val, intface, tmp->maxinterval,
			    tmp->maxinterval * 2);
		}
		dsl->lifetime = val;
	}

	MAYHAVE(val, "mtu", 0);
	if (val < 0 || val > 0xffffffff) {
		log_warnx("mtu (%ld) on %s out of range", val, intface);
		exit(1);
	}
	tmp->linkmtu = (u_int32_t)val;
	if (tmp->linkmtu == 0) {
		char *mtustr;

		if ((mtustr = agetstr("mtu", &bp)) &&
		    strcmp(mtustr, "auto") == 0)
			tmp->linkmtu = tmp->phymtu;
	}
	else if (tmp->linkmtu < IPV6_MMTU || tmp->linkmtu > tmp->phymtu) {
		log_warnx("advertised link mtu (%u) on %s is invalid (must"
		    " be between least MTU (%d) and physical link MTU (%d)",
		    tmp->linkmtu, intface, IPV6_MMTU, tmp->phymtu);
		exit(1);
	}

	/* route information */
	MAYHAVE(val, "routes", -1);
	if (val != -1)
		log_info("route information option is not available");

	/* okey */
	SLIST_INSERT_HEAD(&ralist, tmp, entry);

	/* construct the sending packet */
	make_packet(tmp);

	/* set timer */
	ra_timer_update(tmp);
}

void
get_prefix(struct rainfo *rai)
{
	struct ifaddrs *ifap, *ifa;
	struct prefix *pp;
	struct in6_addr *a;
	u_char *p, *ep, *m, *lim;
	u_char ntopbuf[INET6_ADDRSTRLEN];

	if (getifaddrs(&ifap) < 0)
		fatal("can't get interface addresses");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		int plen;

		if (strcmp(ifa->ifa_name, rai->ifname) != 0)
			continue;
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		a = &((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr;
		if (IN6_IS_ADDR_LINKLOCAL(a))
			continue;
		/* get prefix length */
		m = (u_char *)&((struct sockaddr_in6 *)ifa->ifa_netmask)->sin6_addr;
		lim = (u_char *)(ifa->ifa_netmask) + ifa->ifa_netmask->sa_len;
		plen = prefixlen(m, lim);
		if (plen <= 0 || plen > 128)
			fatalx("failed to get prefixlen or prefix is invalid");
		if (plen == 128)	/* XXX */
			continue;
		if (find_prefix(rai, a, plen)) {
			/* ignore a duplicated prefix. */
			continue;
		}

		/* allocate memory to store prefix info. */
		if ((pp = calloc(1, sizeof(*pp))) == NULL)
			fatal(NULL);

		/* set prefix, sweep bits outside of prefixlen */
		pp->prefixlen = plen;
		memcpy(&pp->prefix, a, sizeof(*a));
		if (1)
		{
			p = (u_char *)&pp->prefix;
			ep = (u_char *)(&pp->prefix + 1);
			while (m < lim && p < ep)
				*p++ &= *m++;
			while (p < ep)
				*p++ = 0x00;
		}
	        if (!inet_ntop(AF_INET6, &pp->prefix, ntopbuf,
	            sizeof(ntopbuf)))
			fatal("inet_ntop failed");
		log_debug("add %s/%d to prefix list on %s",
		    ntopbuf, pp->prefixlen, rai->ifname);

		/* set other fields with protocol defaults */
		pp->validlifetime = DEF_ADVVALIDLIFETIME;
		pp->preflifetime = DEF_ADVPREFERREDLIFETIME;
		pp->onlinkflg = 1;
		pp->autoconfflg = 1;
		pp->origin = PREFIX_FROM_KERNEL;

		/* link into chain */
		TAILQ_INSERT_TAIL(&rai->prefixes, pp, entry);

		/* counter increment */
		rai->pfxs++;
	}

	freeifaddrs(ifap);
}

static void
makeentry(char *buf, size_t len, int id, char *string)
{

	if (id < 0)
		strlcpy(buf, string, len);
	else
		snprintf(buf, len, "%s%d", string, id);
}

/*
 * Add a prefix to the list of specified interface and reconstruct
 * the outgoing packet.
 * The prefix must not be in the list.
 * XXX: other parameters of the prefix (e.g. lifetime) ought
 * to be specified.
 */
void
make_prefix(struct rainfo *rai, int ifindex, struct in6_addr *addr, int plen)
{
	struct prefix *prefix;
	u_char ntopbuf[INET6_ADDRSTRLEN];

	if ((prefix = calloc(1, sizeof(*prefix))) == NULL) {
		log_warn(NULL);
		return;		/* XXX: error or exit? */
	}
	prefix->prefix = *addr;
	prefix->prefixlen = plen;
	prefix->validlifetime = DEF_ADVVALIDLIFETIME;
	prefix->preflifetime = DEF_ADVPREFERREDLIFETIME;
	prefix->onlinkflg = 1;
	prefix->autoconfflg = 1;
	prefix->origin = PREFIX_FROM_DYNAMIC;

	TAILQ_INSERT_TAIL(&rai->prefixes, prefix, entry);

	log_debug("new prefix %s/%d was added on %s",
	    inet_ntop(AF_INET6, &prefix->prefix,
	       ntopbuf, INET6_ADDRSTRLEN),
	    prefix->prefixlen, rai->ifname);

	/* free the previous packet */
	free(rai->ra_data);
	rai->ra_data = NULL;

	/* reconstruct the packet */
	rai->pfxs++;
	make_packet(rai);

	/*
	 * reset the timer so that the new prefix will be advertised quickly.
	 */
	rai->initcounter = 0;
	ra_timer_update(rai);
}

/*
 * Delete a prefix to the list of specified interface and reconstruct
 * the outgoing packet.
 * The prefix must be in the list.
 */
void
delete_prefix(struct rainfo *rai, struct prefix *prefix)
{
	u_char ntopbuf[INET6_ADDRSTRLEN];

	TAILQ_REMOVE(&rai->prefixes, prefix, entry);
	log_debug("prefix %s/%d was deleted on %s",
	    inet_ntop(AF_INET6, &prefix->prefix, ntopbuf, INET6_ADDRSTRLEN),
	    prefix->prefixlen, rai->ifname);
	free(prefix);
	rai->pfxs--;
	make_packet(rai);
}

void
make_packet(struct rainfo *rainfo)
{
	size_t packlen, lladdroptlen = 0;
	char *buf;
	struct nd_router_advert *ra;
	struct nd_opt_prefix_info *ndopt_pi;
	struct nd_opt_mtu *ndopt_mtu;
	struct nd_opt_route_info *ndopt_rti;
	struct nd_opt_rdnss *ndopt_rdnss;
	struct nd_opt_dnssl *ndopt_dnssl;
	struct prefix *pfx;
	struct rtinfo *rti;
	struct rdnss *rds;
	struct dnssl *dsl;
	struct dnssldom *dnsd;

	/* calculate total length */
	packlen = sizeof(struct nd_router_advert);
	if (rainfo->advlinkopt) {
		if ((lladdroptlen = lladdropt_length(rainfo->sdl)) == 0) {
			log_info("link-layer address option has"
			    " null length on %s.  Treat as not included.",
			    rainfo->ifname);
			rainfo->advlinkopt = 0;
		}
		packlen += lladdroptlen;
	}
	if (rainfo->pfxs)
		packlen += sizeof(struct nd_opt_prefix_info) * rainfo->pfxs;
	if (rainfo->linkmtu)
		packlen += sizeof(struct nd_opt_mtu);
	TAILQ_FOREACH(rti, &rainfo->rtinfos, entry)
		packlen += sizeof(struct nd_opt_route_info) +
		    ((rti->prefixlen + 0x3f) >> 6) * 8;
	TAILQ_FOREACH(rds, &rainfo->rdnsss, entry)
		packlen += sizeof(struct nd_opt_rdnss) + 16 * rds->servercnt;
	TAILQ_FOREACH(dsl, &rainfo->dnssls, entry) {
		size_t domains_size = 0;

		packlen += sizeof(struct nd_opt_dnssl);

		/*
		 * Each domain in the packet ends with a null byte. Account for
		 * that here.
		 */
		TAILQ_FOREACH(dnsd, &dsl->dnssldoms, entry)
			domains_size += dnsd->length + 1;

		domains_size = (domains_size + 7) & ~7;

		packlen += domains_size;
	}

	/* allocate memory for the packet */
	if ((buf = malloc(packlen)) == NULL)
		fatal(NULL);
	/* free the previous packet */
	free(rainfo->ra_data);
	rainfo->ra_data = buf;
	/* XXX: what if packlen > 576? */
	rainfo->ra_datalen = packlen;

	/*
	 * construct the packet
	 */
	ra = (struct nd_router_advert *)buf;
	ra->nd_ra_type = ND_ROUTER_ADVERT;
	ra->nd_ra_code = 0;
	ra->nd_ra_cksum = 0;
	ra->nd_ra_curhoplimit = (u_int8_t)(0xff & rainfo->hoplimit);
	ra->nd_ra_flags_reserved = 0; /* just in case */
	/*
	 * XXX: the router preference field, which is a 2-bit field, should be
	 * initialized before other fields.
	 */
	ra->nd_ra_flags_reserved = 0xff & rainfo->rtpref;
	ra->nd_ra_flags_reserved |=
		rainfo->managedflg ? ND_RA_FLAG_MANAGED : 0;
	ra->nd_ra_flags_reserved |=
		rainfo->otherflg ? ND_RA_FLAG_OTHER : 0;
	ra->nd_ra_router_lifetime = htons(rainfo->lifetime);
	ra->nd_ra_reachable = htonl(rainfo->reachabletime);
	ra->nd_ra_retransmit = htonl(rainfo->retranstimer);
	buf += sizeof(*ra);

	if (rainfo->advlinkopt) {
		lladdropt_fill(rainfo->sdl, (struct nd_opt_hdr *)buf);
		buf += lladdroptlen;
	}

	if (rainfo->linkmtu) {
		ndopt_mtu = (struct nd_opt_mtu *)buf;
		ndopt_mtu->nd_opt_mtu_type = ND_OPT_MTU;
		ndopt_mtu->nd_opt_mtu_len = 1;
		ndopt_mtu->nd_opt_mtu_reserved = 0;
		ndopt_mtu->nd_opt_mtu_mtu = htonl(rainfo->linkmtu);
		buf += sizeof(struct nd_opt_mtu);
	}

	TAILQ_FOREACH(pfx, &rainfo->prefixes, entry) {
		u_int32_t vltime, pltime;
		struct timeval now;

		ndopt_pi = (struct nd_opt_prefix_info *)buf;
		ndopt_pi->nd_opt_pi_type = ND_OPT_PREFIX_INFORMATION;
		ndopt_pi->nd_opt_pi_len = 4;
		ndopt_pi->nd_opt_pi_prefix_len = pfx->prefixlen;
		ndopt_pi->nd_opt_pi_flags_reserved = 0;
		if (pfx->onlinkflg)
			ndopt_pi->nd_opt_pi_flags_reserved |=
				ND_OPT_PI_FLAG_ONLINK;
		if (pfx->autoconfflg)
			ndopt_pi->nd_opt_pi_flags_reserved |=
				ND_OPT_PI_FLAG_AUTO;
		if (pfx->vltimeexpire || pfx->pltimeexpire)
			gettimeofday(&now, NULL);
		if (pfx->vltimeexpire == 0)
			vltime = pfx->validlifetime;
		else
			vltime = (u_int32_t)(pfx->vltimeexpire > now.tv_sec ?
				pfx->vltimeexpire - now.tv_sec : 0);
		if (pfx->pltimeexpire == 0)
			pltime = pfx->preflifetime;
		else
			pltime = (u_int32_t)(pfx->pltimeexpire > now.tv_sec ?
				pfx->pltimeexpire - now.tv_sec : 0);
		if (vltime < pltime) {
			/*
			 * this can happen if vltime is decremented but pltime
			 * is not.
			 */
			pltime = vltime;
		}
		ndopt_pi->nd_opt_pi_valid_time = htonl(vltime);
		ndopt_pi->nd_opt_pi_preferred_time = htonl(pltime);
		ndopt_pi->nd_opt_pi_reserved2 = 0;
		ndopt_pi->nd_opt_pi_prefix = pfx->prefix;

		buf += sizeof(struct nd_opt_prefix_info);
	}

	TAILQ_FOREACH(rti, &rainfo->rtinfos, entry) {
		uint8_t psize = (rti->prefixlen + 0x3f) >> 6;

		ndopt_rti = (struct nd_opt_route_info *)buf;
		ndopt_rti->nd_opt_rti_type = ND_OPT_ROUTE_INFO;
		ndopt_rti->nd_opt_rti_len = 1 + psize;
		ndopt_rti->nd_opt_rti_prefixlen = rti->prefixlen;
		ndopt_rti->nd_opt_rti_flags = 0xff & rti->rtpref;
		ndopt_rti->nd_opt_rti_lifetime = htonl(rti->lifetime);
		memcpy(ndopt_rti + 1, &rti->prefix, psize * 8);
		buf += sizeof(struct nd_opt_route_info) + psize * 8;
	}

	TAILQ_FOREACH(rds, &rainfo->rdnsss, entry) {
		ndopt_rdnss = (struct nd_opt_rdnss *)buf;
		ndopt_rdnss->nd_opt_rdnss_type = ND_OPT_RDNSS;
		/*
		 * An IPv6 address is 16 bytes, so multiply the number of
		 * addresses by two to get a size in units of 8 bytes.
		 */
		ndopt_rdnss->nd_opt_rdnss_len = 1 + rds->servercnt * 2;
		ndopt_rdnss->nd_opt_rdnss_reserved = 0;
		ndopt_rdnss->nd_opt_rdnss_lifetime = htonl(rds->lifetime);

		buf += sizeof(struct nd_opt_rdnss);

		memcpy(buf, rds->servers, rds->servercnt * 16);
		buf += rds->servercnt * 16;
	}

	TAILQ_FOREACH(dsl, &rainfo->dnssls, entry) {
		u_int32_t size;

		ndopt_dnssl = (struct nd_opt_dnssl *)buf;
		ndopt_dnssl->nd_opt_dnssl_type = ND_OPT_DNSSL;
		ndopt_dnssl->nd_opt_dnssl_reserved = 0;
		ndopt_dnssl->nd_opt_dnssl_lifetime = htonl(dsl->lifetime);

		size = 0;
		TAILQ_FOREACH(dnsd, &dsl->dnssldoms, entry)
			size += dnsd->length + 1;
		/* align size on the next 8 byte boundary */
		size = (size + 7) & ~7;
		ndopt_dnssl->nd_opt_dnssl_len = 1 + size / 8;

		buf += sizeof(struct nd_opt_dnssl);

		TAILQ_FOREACH(dnsd, &dsl->dnssldoms, entry) {
			char *curlabel_begin;
			char *curlabel_end;

			curlabel_begin = dnsd->domain;
			while ((curlabel_end = strchr(curlabel_begin, '.'))
			    != NULL && curlabel_end > curlabel_begin)
			{
				size_t curlabel_size;

				curlabel_size = curlabel_end - curlabel_begin;
				*buf++ = curlabel_size;
				memcpy(buf, curlabel_begin, curlabel_size);
				buf += curlabel_size;
				curlabel_begin = curlabel_end + 1;
			}

			/* null-terminate the current domain */
			*buf++ = '\0';
		}

		/* zero out the end of the current option */
		while (((uintptr_t)buf) % 8 != 0)
			*buf++ = '\0';
	}
}

static int
getinet6sysctl(int code)
{
	int mib[] = { CTL_NET, PF_INET6, IPPROTO_IPV6, 0 };
	int value;
	size_t size;

	mib[3] = code;
	size = sizeof(value);
	if (sysctl(mib, sizeof(mib)/sizeof(mib[0]), &value, &size, NULL, 0)
	    < 0) {
		log_warn("failed to get ip6 sysctl(%d)", code);
		return(-1);
	} else
		return(value);
}
@


1.59
log
@Interval calculations are perfectly fine with ints.
OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.58 2016/08/02 17:00:09 jca Exp $	*/
d179 1
a179 1
	if (val && (val < tmp->maxinterval || val > MAXROUTERLIFETIME)) {
d183 1
a183 1
		    tmp->maxinterval, MAXROUTERLIFETIME);
d204 1
a204 1
	if (val < 0 || val > MAXREACHABLETIME) {
d207 1
a207 1
		    val, intface, MAXREACHABLETIME);
@


1.58
log
@Move to libevent; ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.57 2016/06/29 14:19:38 jca Exp $	*/
d151 1
a151 1
		    "(must be between %e and %u)", val,
d159 1
a159 1
		    "(must be between %e and %d)",
@


1.57
log
@Spring cleanup

- pointless casts, kill caddr_t or replace it with char *
- signed counters
- simplify if_getmtu, only one method is needed and SIOCGIFMTU is the
  cheapest
- we no longer have drivers for IFT_FDDI
- hide details of iflist management
- if (dflag) log_debug -> log_debug
- dead code and comments
- etc etc

Input from and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.56 2016/03/01 20:51:05 jca Exp $	*/
d58 1
a61 1
#include "timer.h"
d523 1
a523 4
	tmp->timer = rtadvd_add_timer(ra_timeout, ra_timer_update,
				      tmp, tmp);
	ra_timer_update(tmp, &tmp->timer->tm);
	rtadvd_set_timer(&tmp->timer->tm, tmp->timer);
d654 1
a654 2
	ra_timer_update(rai, &rai->timer->tm);
	rtadvd_set_timer(&rai->timer->tm, rai->timer);
@


1.56
log
@fatal("malloc") -> fatal(NULL)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.55 2016/03/01 12:52:43 jca Exp $	*/
d505 1
a505 1
		log_warnx("advertised link mtu (%lu) on %s is invalid (must"
d507 1
a507 2
		    (unsigned long)tmp->linkmtu, intface,
		    IPV6_MMTU, tmp->phymtu);
d525 1
a525 1
	ra_timer_update((void *)tmp, &tmp->timer->tm);
d657 1
a657 1
	ra_timer_update((void *)rai, &rai->timer->tm);
d909 1
a909 2
	}
	else
@


1.55
log
@Pointless 'return;' in void functions
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.54 2016/02/29 20:25:46 jca Exp $	*/
d108 1
a108 1
		fatal("malloc");
d246 1
a246 1
			fatal("calloc");
d338 1
a338 1
			fatal("malloc");
d414 1
a414 1
			fatal("malloc");
d452 1
a452 1
			fatal("malloc");
d468 1
a468 1
				fatal("malloc");
d567 1
a567 1
			fatal("calloc");
d628 1
a628 1
		log_warn("calloc");
d737 1
a737 1
		fatal("malloc");
@


1.54
log
@Merge add/make_prefix() and kill last use of struct in6_prefixreq in userland.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.53 2016/02/29 06:37:55 jca Exp $	*/
a894 2

	return;
@


1.53
log
@init_prefix() is now trivial, merge it with its caller.

Suggested by and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.52 2016/02/26 12:33:30 jca Exp $	*/
d621 2
a622 2
static void
add_prefix(struct rainfo *rai, struct in6_prefixreq *ipr)
d631 6
a636 6
	prefix->prefix = ipr->ipr_prefix.sin6_addr;
	prefix->prefixlen = ipr->ipr_plen;
	prefix->validlifetime = ipr->ipr_vltime;
	prefix->preflifetime = ipr->ipr_pltime;
	prefix->onlinkflg = ipr->ipr_raf_onlink;
	prefix->autoconfflg = ipr->ipr_raf_auto;
d642 1
a642 1
	    inet_ntop(AF_INET6, &ipr->ipr_prefix.sin6_addr,
d644 1
a644 1
	    ipr->ipr_plen, rai->ifname);
a678 23
}

void
make_prefix(struct rainfo *rai, int ifindex, struct in6_addr *addr, int plen)
{
	struct in6_prefixreq ipr;

	memset(&ipr, 0, sizeof(ipr));
	if (if_indextoname(ifindex, ipr.ipr_name) == NULL) {
		log_warn("Prefix added interface No.%d doesn't"
		    " exist. This should not happen!", ifindex);
		exit(1);
	}
	ipr.ipr_prefix.sin6_len = sizeof(ipr.ipr_prefix);
	ipr.ipr_prefix.sin6_family = AF_INET6;
	ipr.ipr_prefix.sin6_addr = *addr;
	ipr.ipr_plen = plen;
	ipr.ipr_vltime = DEF_ADVVALIDLIFETIME;
	ipr.ipr_pltime = DEF_ADVPREFERREDLIFETIME;
	ipr.ipr_raf_onlink = 1;
	ipr.ipr_raf_auto = 1;

	add_prefix(rai, &ipr);
@


1.52
log
@Remove #if'0ed code that uses a deprecated ioctl; ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.50 2016/02/09 00:39:13 jca Exp $	*/
a680 15
/*
 * Try to get an in6_prefixreq contents for a prefix which matches
 * ipr->ipr_prefix and ipr->ipr_plen and belongs to
 * the interface whose name is ipr->ipr_name[].
 */
static int
init_prefix(struct in6_prefixreq *ipr)
{
	ipr->ipr_vltime = DEF_ADVVALIDLIFETIME;
	ipr->ipr_pltime = DEF_ADVPREFERREDLIFETIME;
	ipr->ipr_raf_onlink = 1;
	ipr->ipr_raf_auto = 1;
	return 0;
}

d696 4
a700 2
	if (init_prefix(&ipr))
		return; /* init failed by some error */
@


1.51
log
@Kill some useless members of struct rainfo; ok florian@@
@
text
@a688 32
#if 0
	int s;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		log_warn("socket");
		exit(1);
	}

	if (ioctl(s, SIOCGIFPREFIX_IN6, (caddr_t)ipr) < 0) {
		log_warn("ioctl:SIOCGIFFLAGS: failed for %s", ifr.ifr_name);

		ipr->ipr_vltime = DEF_ADVVALIDLIFETIME;
		ipr->ipr_pltime = DEF_ADVPREFERREDLIFETIME;
		ipr->ipr_raf_onlink = 1;
		ipr->ipr_raf_auto = 1;
		/* omit other field initialization */
	}
	else if (ipr->ipr_origin < PR_ORIG_RR) {
		u_char ntopbuf[INET6_ADDRSTRLEN];

		log_warn("Added prefix(%s)'s origin %d is"
		    " lower than PR_ORIG_RR(router renumbering)."
		    " This should not happen if I am router",
		    inet_ntop(AF_INET6, &ipr->ipr_prefix.sin6_addr, ntopbuf,
			sizeof(ntopbuf)), ipr->ipr_origin);
		close(s);
		return 1;
	}

	close(s);
	return 0;
#else
a693 1
#endif
@


1.50
log
@Kill code to send unicast packets which never got enabled.

and get rid of pointless memory allocations.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.49 2016/02/08 23:19:00 jca Exp $	*/
a325 1
	tmp->rtinfocnt = 0;
a392 1
		tmp->rtinfocnt++;
a394 1
	tmp->rdnsscnt = 0;
a416 1
		tmp->rdnsscnt++;
a439 1
	tmp->dnsslcnt = 0;
a478 1
		tmp->dnsslcnt++;
@


1.49
log
@Kill trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.48 2016/02/08 23:15:37 jca Exp $	*/
a113 1
	SLIST_INIT(&tmp->soliciters);
@


1.48
log
@typos
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.47 2016/02/05 11:26:26 reyk Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d681 1
a681 1
	    inet_ntop(AF_INET6, &prefix->prefix, ntopbuf, INET6_ADDRSTRLEN), 
d882 1
a882 1
			pltime = (u_int32_t)(pfx->pltimeexpire > now.tv_sec ? 
@


1.47
log
@rtadvd used a strncpy with a src interface name from the command line
without checking its length.  Replace it with strlcpy, check for
truncation and move the check before using the user-specified
interface name.  While here, replace another strncpy of a interface
name with memset-zero + strlcpy and check for truncation in
if_getmtu() (should not happen as we validated the length before, but
it's better to be safe and generally a better practice).

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.46 2016/01/25 05:00:12 jca Exp $	*/
d193 1
a193 1
	 * explicitly set zero. (see also the above section)
d625 2
a626 2
 * XXX: other parameter of the prefix(e.g. lifetime) shoule be
 * able to be specified.
d886 1
a886 1
			 * this can happen if vltime is decrement but pltime
@


1.46
log
@Redundant assignement is redundant.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.45 2015/12/11 20:15:52 mmcc Exp $	*/
d122 5
a139 1
	strncpy(tmp->ifname, intface, sizeof(tmp->ifname));
@


1.45
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.44 2015/10/25 22:11:34 jca Exp $	*/
a811 1
	rainfo->ra_data = NULL;
@


1.44
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.43 2015/01/16 06:40:20 deraadt Exp $	*/
d810 3
a812 5
	if (rainfo->ra_data) {
		/* free the previous packet */
		free(rainfo->ra_data);
		rainfo->ra_data = NULL;
	}
@


1.43
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.42 2014/07/04 22:39:31 guenther Exp $	*/
d72 1
a72 2
getconfig(intface)
	char *intface;
d608 1
a608 5
makeentry(buf, len, id, string)
	char *buf;
	size_t len;
	int id;
	char *string;
@


1.42
log
@malloc+memset -> calloc

from Benjamin Baier (programmer (at) netzbasis.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.41 2014/06/29 00:58:45 deraadt Exp $	*/
a32 1
#include <sys/param.h>
@


1.41
log
@If you want <sys/queue.h>, you need to include it.  Don't assume that
<sys/sysctl.h> will pull in the universe (I am working on breaking that
assumption in a gentle fashion)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.40 2013/10/17 16:27:48 bluhm Exp $	*/
d244 2
a245 3
		if ((pfx = malloc(sizeof(struct prefix))) == NULL)
			fatal("malloc");
		memset(pfx, 0, sizeof(*pfx));
d571 2
a572 3
		if ((pp = malloc(sizeof(*pp))) == NULL)
			fatal("malloc");
		memset(pp, 0, sizeof(*pp));
d636 2
a637 2
	if ((prefix = malloc(sizeof(*prefix))) == NULL) {
		log_warn("malloc");
a639 1
	memset(prefix, 0, sizeof(*prefix));
@


1.40
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.39 2013/06/01 21:57:12 brad Exp $	*/
d38 1
@


1.39
log
@Remove (char *) casts as agetstr() returns char *.

Pointed out by bluhm@@ Ok bluhm@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.38 2013/06/01 01:30:53 brad Exp $	*/
d44 1
a44 1
#include <netinet/in_var.h>
@


1.38
log
@Add support for advertising route information (RFC 4191).

From FreeBSD via UMEZAWA Takeshi

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.37 2013/05/08 06:32:07 brad Exp $	*/
d238 1
a238 1
		addr = (char *)agetstr(entbuf, &bp);
d332 1
a332 1
		addr = (char *)agetstr(entbuf, &bp);
d356 1
a356 1
		if ((flagstr = (char *)agetstr(entbuf, &bp))) {
d505 1
a505 1
		if ((mtustr = (char *)agetstr("mtu", &bp)) &&
@


1.37
log
@Replace use of strncpy with memcpy. Previous code used strncpy on data
that is not null-terminated.

From Stephane A. Sezer

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.36 2013/05/08 06:28:09 brad Exp $	*/
d112 1
d325 71
d769 1
d773 1
d793 3
d904 13
@


1.36
log
@Minor style cleanups.

From Stephane A. Sezer

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.35 2013/05/08 06:26:05 brad Exp $	*/
d875 1
a875 1
				strncpy(buf, curlabel_begin, curlabel_size);
@


1.35
log
@Fix a comparison when building a packet with DNS search lists.

From Stephane A. Sezer

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.34 2013/05/08 06:24:44 brad Exp $	*/
a786 2
	
	
d832 4
a847 2
		char *curlabel_begin;
		char *curlabel_end;
d864 3
d868 2
a869 2
			while ((curlabel_end = strchr(curlabel_begin, '.')) &&
			    (curlabel_end - curlabel_begin) > 0)
d874 1
a874 2
				*buf = curlabel_size;
				++buf;
@


1.34
log
@Correctly compute packet size when including DNS search lists.

From Stephane A. Sezer

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.33 2013/04/30 12:30:40 florian Exp $	*/
d866 1
a866 1
			    (curlabel_end - curlabel_begin) > 1)
@


1.33
log
@- replace TIMEVAL_* function/macros with macros from sys/time.h
- replace insque(3) with SLIST from queue(3)
- with that, rewrite rtadvd_check_timer() logic to avoid
  timeval {0x7fffffff, 0x7fffffff}

test/ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.32 2013/04/30 12:29:04 florian Exp $	*/
d726 4
d731 1
a731 1
			domains_size += dnsd->length;
d856 1
a856 1
			size += dnsd->length;
@


1.32
log
@move variables to type time_t; fix format strings

test/ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.31 2013/03/17 00:38:29 brad Exp $	*/
a54 1
#include <search.h>
@


1.31
log
@Add the router preference defines to the icmp6.h header and remove the
defines that were part of rtadvd's code.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.30 2012/09/05 05:52:10 deraadt Exp $	*/
d806 2
a807 2
			vltime = (pfx->vltimeexpire > now.tv_sec) ?
				pfx->vltimeexpire - now.tv_sec : 0;
d811 2
a812 2
			pltime = (pfx->pltimeexpire > now.tv_sec) ? 
				pfx->pltimeexpire - now.tv_sec : 0;
@


1.30
log
@don't truncate a pointer to int, before checking the low bits -- use uintptr_t
from UMEZAWA Takeshi
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.29 2012/07/09 08:55:19 phessler Exp $	*/
a168 4
#ifndef ND_RA_FLAG_RTPREF_MASK
#define ND_RA_FLAG_RTPREF_MASK	0x18 /* 00011000 */
#define ND_RA_FLAG_RTPREF_RSV	0x10 /* 00010000 */
#endif
@


1.29
log
@Use size_t for the length variable

reminded by Brad, and lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.28 2012/07/08 10:46:00 phessler Exp $	*/
d58 1
d884 1
a884 1
		while ((int)buf % 8 != 0)
@


1.28
log
@Add support for advertising dns servers and search paths in router
advertisements, according to RFC 6106.

original diff from Stephane A. Sezer on tech@@, many thanks!

OK phessler@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.27 2012/07/08 09:30:03 phessler Exp $	*/
d394 1
a394 1
			ssize_t len;
@


1.27
log
@Add noifprefix, an option to send an RA with no prefix information.

From Stephane A. Sezer, many thanks!

OK phessler@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.26 2008/04/23 10:17:50 pyr Exp $	*/
d112 2
d328 100
d701 2
d704 3
d723 14
d829 56
@


1.26
log
@Replace handrolled lists with SLISTs or TAILQs.
Timers remain and will be handled later.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.25 2008/04/21 20:40:55 rainer Exp $	*/
d323 1
a323 1
	if (tmp->pfxs == 0)
@


1.25
log
@Clean up logging by introducing the logging API used in
other daemons and clean up the command line options.
For details, see rtadvd(8).

ok bluhm@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.24 2008/04/20 11:36:48 rainer Exp $	*/
d69 1
a69 1
extern struct rainfo *ralist;
d108 1
a108 2
	tmp = (struct rainfo *)malloc(sizeof(*ralist));
	if (tmp == NULL)
d111 2
a112 2
	memset(tmp, 0, sizeof(*tmp));
	tmp->prefix.next = tmp->prefix.prev = &tmp->prefix;
d249 1
a249 1
		insque(pfx, &tmp->prefix);
d353 1
a353 2
	tmp->next = ralist;
	ralist = tmp;
d431 1
a431 1
		insque(pp, &rai->prefix);
d480 1
a480 1
	insque(prefix, &rai->prefix);
d513 1
a513 1
	remque(prefix);
d668 1
a668 2
	for (pfx = rainfo->prefix.next;
	     pfx != &rainfo->prefix; pfx = pfx->next) {
@


1.24
log
@Take failed system calls more serious than LOG_INFO.
This is mainly in preparation for more changes to logging.

Ok bluhm@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.23 2006/03/22 10:49:17 claudio Exp $	*/
a51 1
#include <syslog.h>
d64 1
d89 1
a89 1
		fprintf(stderr, "rtadvd: need %s for interface %s\n",	\
d103 3
a105 5
		syslog(LOG_INFO,
		       "<%s> %s isn't defined in the configuration file"
		       " or the configuration file doesn't exist."
		       " Treat it as default",
		        __func__, intface);
d109 3
a111 5
	if (tmp == NULL) {
		syslog(LOG_INFO, "<%s> %s: can't allocate enough memory",
		    __func__, intface);
		exit(1);
	}
d128 1
a128 3
			syslog(LOG_ERR,
			       "<%s> can't get information of %s",
			       __func__, intface);
d137 2
a138 3
		syslog(LOG_WARNING,
		       "<%s> can't get interface mtu of %s. Treat as %d",
		       __func__, intface, IPV6_MMTU);
d146 3
a148 4
		syslog(LOG_ERR,
		       "<%s> maxinterval (%ld) on %s is invalid "
		       "(must be between %e and %u)", __func__, val,
		       intface, MIN_MAXINTERVAL, MAX_MAXINTERVAL);
d154 3
a156 5
		syslog(LOG_ERR,
		       "<%s> mininterval (%ld) on %s is invalid "
		       "(must be between %e and %d)",
		       __func__, val, intface, MIN_MININTERVAL,
		       (tmp->maxinterval * 3) / 4);
d173 2
a174 2
		syslog(LOG_ERR, "<%s> invalid router preference (%02x) on %s",
		       __func__, tmp->rtpref, intface);
d180 4
a183 5
		syslog(LOG_ERR,
		       "<%s> router lifetime (%ld) on %s is invalid "
		       "(must be 0 or between %d and %d)",
		       __func__, val, intface,
		       tmp->maxinterval, MAXROUTERLIFETIME);
d195 4
a198 5
		syslog(LOG_ERR,
		       "<%s> non zero router lifetime is specified for %s, "
		       "which must not be allowed for hosts.  you must "
		       "change router lifetime or enable IPv6 forwarding.",
		       __func__, intface);
d205 3
a207 4
		syslog(LOG_ERR,
		       "<%s> reachable time (%ld) on %s is invalid "
		       "(must be no greater than %d)",
		       __func__, val, intface, MAXREACHABLETIME);
d214 2
a215 2
		syslog(LOG_ERR, "<%s> retrans time (%lld) on %s out of range",
		       __func__, (long long)val64, intface);
d221 1
a221 3
		syslog(LOG_ERR,
		       "<%s> mobile-ip6 configuration not supported",
		       __func__);
d245 2
a246 6
		if ((pfx = malloc(sizeof(struct prefix))) == NULL) {
			syslog(LOG_ERR,
			       "<%s> can't allocate enough memory",
			       __func__);
			exit(1);
		}
d256 1
a256 3
			syslog(LOG_ERR,
			       "<%s> inet_pton failed for %s",
			       __func__, addr);
d260 3
a262 4
			syslog(LOG_ERR,
			       "<%s> multicast prefix (%s) must "
			       "not be advertised on %s",
			       __func__, addr, intface);
d266 3
a268 4
			syslog(LOG_NOTICE,
			       "<%s> link-local prefix (%s) will be"
			       " advertised on %s",
			       __func__, addr, intface);
d273 3
a275 3
			syslog(LOG_ERR, "<%s> prefixlen (%ld) for %s "
			       "on %s out of range",
			       __func__, val, addr, intface);
d289 3
a291 3
			syslog(LOG_ERR, "<%s> vltime (%lld) for "
			    "%s/%d on %s is out of range",
			    __func__, (long long)val64,
d308 3
a310 4
			syslog(LOG_ERR,
			    "<%s> pltime (%lld) for %s/%d on %s "
			    "is out of range",
			    __func__, (long long)val64,
d329 1
a329 3
		syslog(LOG_ERR,
		       "<%s> mtu (%ld) on %s out of range",
		       __func__, val, intface);
d341 4
a344 5
		syslog(LOG_ERR,
		       "<%s> advertised link mtu (%lu) on %s is invalid (must "
		       "be between least MTU (%d) and physical link MTU (%d)",
		       __func__, (unsigned long)tmp->linkmtu, intface,
		       IPV6_MMTU, tmp->phymtu);
d351 1
a351 1
		syslog(LOG_INFO, "route information option is not available");
d376 2
a377 6
	if (getifaddrs(&ifap) < 0) {
		syslog(LOG_ERR,
		       "<%s> can't get interface addresses",
		       __func__);
		exit(1);
	}
d393 2
a394 6
		if (plen <= 0 || plen > 128) {
			syslog(LOG_ERR, "<%s> failed to get prefixlen "
			       "or prefix is invalid",
			       __func__);
			exit(1);
		}
d403 2
a404 6
		if ((pp = malloc(sizeof(*pp))) == NULL) {
			syslog(LOG_ERR,
			       "<%s> can't get allocate buffer for prefix",
			       __func__);
			exit(1);
		}
d420 4
a423 7
	            sizeof(ntopbuf))) {
			syslog(LOG_ERR, "<%s> inet_ntop failed", __func__);
			exit(1);
		}
		syslog(LOG_DEBUG,
		       "<%s> add %s/%d to prefix list on %s",
		       __func__, ntopbuf, pp->prefixlen, rai->ifname);
d470 1
a470 2
		syslog(LOG_ERR, "<%s> memory allocation failed",
		       __func__);
d484 4
a487 4
	syslog(LOG_DEBUG, "<%s> new prefix %s/%d was added on %s",
	       __func__, inet_ntop(AF_INET6, &ipr->ipr_prefix.sin6_addr,
				       ntopbuf, INET6_ADDRSTRLEN),
	       ipr->ipr_plen, rai->ifname);
d516 3
a518 4
	syslog(LOG_DEBUG, "<%s> prefix %s/%d was deleted on %s",
	       __func__, inet_ntop(AF_INET6, &prefix->prefix,
				       ntopbuf, INET6_ADDRSTRLEN),
	       prefix->prefixlen, rai->ifname);
d536 1
a536 2
		syslog(LOG_ERR, "<%s> socket: %s", __func__,
		       strerror(errno));
d541 1
a541 2
		syslog(LOG_WARNING, "<%s> ioctl:SIOCGIFPREFIX %s", __func__,
		       strerror(errno));
d552 5
a556 5
		syslog(LOG_WARNING, "<%s> Added prefix(%s)'s origin %d is"
		       "lower than PR_ORIG_RR(router renumbering)."
		       "This should not happen if I am router", __func__,
		       inet_ntop(AF_INET6, &ipr->ipr_prefix.sin6_addr, ntopbuf,
				 sizeof(ntopbuf)), ipr->ipr_origin);
d579 2
a580 3
		syslog(LOG_ERR, "<%s> Prefix added interface No.%d doesn't"
		       "exist. This should not happen! %s", __func__,
		       ifindex, strerror(errno));
d607 3
a609 4
			syslog(LOG_INFO,
			       "<%s> link-layer address option has"
			       " null length on %s.  Treat as not included.",
			       __func__, rainfo->ifname);
d620 2
a621 6
	if ((buf = malloc(packlen)) == NULL) {
		syslog(LOG_ERR,
		       "<%s> can't get enough memory for an RA packet",
		       __func__);
		exit(1);
	}
d727 1
a727 3
		syslog(LOG_ERR, "<%s>: failed to get ip6 sysctl(%d): %s",
		       __func__, code,
		       strerror(errno));
@


1.23
log
@Add additional limit check to ensure that we do not overflow pp->prefix
while masking the prefix. Fix from itojun@@. OK dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.22 2003/06/18 02:26:58 itojun Exp $	*/
d586 1
a586 1
		syslog(LOG_INFO, "<%s> ioctl:SIOCGIFPREFIX %s", __func__,
@


1.22
log
@relax config syntax; addrs#x is not needed any more.  millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.21 2002/07/10 21:14:40 itojun Exp $	*/
d453 1
a453 1
			while (m < lim)
@


1.21
log
@sync w/kame (style)
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.20 2002/07/10 18:08:11 todd Exp $	*/
d66 1
a66 2
static void makeentry(char *, size_t, int, char *, int);
static void get_prefix(struct rainfo *);
d75 1
a75 1
	int stat, pfxs, i;
d242 1
a242 1
	 * This is an implementation specific parameter to consinder
d249 82
a330 3
	if ((pfxs = agetnum("addrs")) <= 0) {
		/* auto configure prefix information */
		if (agetstr("addr", &bp) || agetstr("addr1", &bp)) {
d332 4
a335 3
			       "<%s> conflicting prefix configuration for %s: "
			       "automatic and manual config at the same time",
			       __func__, intface);
d338 8
a345 108
		get_prefix(tmp);
	} else {
		tmp->pfxs = pfxs;
		for (i = 0; i < pfxs; i++) {
			struct prefix *pfx;
			char entbuf[256];
			int added = (pfxs > 1) ? 1 : 0;

			/* allocate memory to store prefix information */
			if ((pfx = malloc(sizeof(struct prefix))) == NULL) {
				syslog(LOG_ERR,
				       "<%s> can't allocate enough memory",
				       __func__);
				exit(1);
			}
			memset(pfx, 0, sizeof(*pfx));

			/* link into chain */
			insque(pfx, &tmp->prefix);

			pfx->origin = PREFIX_FROM_CONFIG;


			makeentry(entbuf, sizeof(entbuf), i, "addr", added);
			addr = (char *)agetstr(entbuf, &bp);
			if (addr == NULL) {
				syslog(LOG_ERR,
				       "<%s> need %s as a prefix for "
				       "interface %s",
				       __func__, entbuf, intface);
				exit(1);
			}
			if (inet_pton(AF_INET6, addr,
				      &pfx->prefix) != 1) {
				syslog(LOG_ERR,
				       "<%s> inet_pton failed for %s",
				       __func__, addr);
				exit(1);
			}
			if (IN6_IS_ADDR_MULTICAST(&pfx->prefix)) {
				syslog(LOG_ERR,
				       "<%s> multicast prefix (%s) must "
				       "not be advertised on %s",
				       __func__, addr, intface);
				exit(1);
			}
			if (IN6_IS_ADDR_LINKLOCAL(&pfx->prefix))
				syslog(LOG_NOTICE,
				       "<%s> link-local prefix (%s) will be"
				       " advertised on %s",
				       __func__, addr, intface);

			makeentry(entbuf, sizeof(entbuf), i, "prefixlen",
			    added);
			MAYHAVE(val, entbuf, 64);
			if (val < 0 || val > 128) {
				syslog(LOG_ERR, "<%s> prefixlen (%ld) for %s "
				       "on %s out of range",
				       __func__, val, addr, intface);
				exit(1);
			}
			pfx->prefixlen = (int)val;

			makeentry(entbuf, sizeof(entbuf), i, "pinfoflags",
			    added);
			MAYHAVE(val, entbuf,
				(ND_OPT_PI_FLAG_ONLINK|ND_OPT_PI_FLAG_AUTO));
			pfx->onlinkflg = val & ND_OPT_PI_FLAG_ONLINK;
			pfx->autoconfflg = val & ND_OPT_PI_FLAG_AUTO;

			makeentry(entbuf, sizeof(entbuf), i, "vltime", added);
			MAYHAVE(val64, entbuf, DEF_ADVVALIDLIFETIME);
			if (val64 < 0 || val64 > 0xffffffff) {
				syslog(LOG_ERR, "<%s> vltime (%lld) for "
				    "%s/%d on %s is out of range",
				    __func__, (long long)val64,
				    addr, pfx->prefixlen, intface);
				exit(1);
			}
			pfx->validlifetime = (u_int32_t)val64;

			makeentry(entbuf, sizeof(entbuf), i, "vltimedecr", added);
			if (agetflag(entbuf)) {
				struct timeval now;
				gettimeofday(&now, 0);
				pfx->vltimeexpire =
					now.tv_sec + pfx->validlifetime;
			}

			makeentry(entbuf, sizeof(entbuf), i, "pltime", added);
			MAYHAVE(val64, entbuf, DEF_ADVPREFERREDLIFETIME);
			if (val64 < 0 || val64 > 0xffffffff) {
				syslog(LOG_ERR,
				    "<%s> pltime (%lld) for %s/%d on %s "
				    "is out of range",
				    __func__, (long long)val64,
				    addr, pfx->prefixlen, intface);
				exit(1);
			}
			pfx->preflifetime = (u_int32_t)val64;

			makeentry(entbuf, sizeof(entbuf), i, "pltimedecr", added);
			if (agetflag(entbuf)) {
				struct timeval now;
				gettimeofday(&now, 0);
				pfx->pltimeexpire =
					now.tv_sec + pfx->preflifetime;
			}
d348 2
d394 1
a394 1
static void
d409 1
d449 1
d485 1
a485 1
makeentry(buf, len, id, string, add)
a489 1
	int add;
a490 1
	char *ep = buf + len;
d492 4
a495 7
	strlcpy(buf, string, len);
	if (add) {
		char *cp;

		cp = (char *)strchr(buf, '\0');
		snprintf(cp, ep - cp, "%d", id);
	}
@


1.20
log
@check malloc return; from Chad Loder <cloder@@acm.org>
ok me, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.19 2002/06/15 02:52:10 itojun Exp $	*/
d113 2
a114 2
		syslog(LOG_ERR, "<%s>(%s) can't allocate enough memory",
__func__, intface);
a116 1

@


1.19
log
@remove redundant arg to syslog()   netbsd-current via kame
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.18 2002/06/10 19:57:35 espie Exp $	*/
d112 6
@


1.18
log
@Kill __FUNCTION__.
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.17 2002/06/09 02:15:54 deraadt Exp $	*/
d189 1
a189 1
		       __func__, val, intface, tmp->maxinterval,
@


1.17
log
@strchr() instead of index()
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.16 2002/06/08 18:11:13 itojun Exp $	*/
d108 1
a108 1
		        __FUNCTION__, intface);
d130 1
a130 1
			       __FUNCTION__, intface);
d141 1
a141 1
		       __FUNCTION__, intface, IPV6_MMTU);
d151 1
a151 1
		       "(must be between %e and %u)", __FUNCTION__, val,
d161 1
a161 1
		       __FUNCTION__, val, intface, MIN_MININTERVAL,
d180 1
a180 1
		       __FUNCTION__, tmp->rtpref, intface);
d189 1
a189 1
		       __FUNCTION__, val, intface, tmp->maxinterval,
d206 1
a206 1
		       __FUNCTION__, intface);
d216 1
a216 1
		       __FUNCTION__, val, intface, MAXREACHABLETIME);
d224 1
a224 1
		       __FUNCTION__, (long long)val64, intface);
d232 1
a232 1
		       __FUNCTION__);
d251 1
a251 1
			       __FUNCTION__, intface);
d266 1
a266 1
				       __FUNCTION__);
d283 1
a283 1
				       __FUNCTION__, entbuf, intface);
d290 1
a290 1
				       __FUNCTION__, addr);
d297 1
a297 1
				       __FUNCTION__, addr, intface);
d304 1
a304 1
				       __FUNCTION__, addr, intface);
d312 1
a312 1
				       __FUNCTION__, val, addr, intface);
d329 1
a329 1
				    __FUNCTION__, (long long)val64,
d349 1
a349 1
				    __FUNCTION__, (long long)val64,
d369 1
a369 1
		       __FUNCTION__, val, intface);
d384 1
a384 1
		       __FUNCTION__, (unsigned long)tmp->linkmtu, intface,
d420 1
a420 1
		       __FUNCTION__);
d440 1
a440 1
			       __FUNCTION__);
d454 1
a454 1
			       __FUNCTION__);
d472 1
a472 1
			syslog(LOG_ERR, "<%s> inet_ntop failed", __FUNCTION__);
d477 1
a477 1
		       __FUNCTION__, ntopbuf, pp->prefixlen, rai->ifname);
d530 1
a530 1
		       __FUNCTION__);
d545 1
a545 1
	       __FUNCTION__, inet_ntop(AF_INET6, &ipr->ipr_prefix.sin6_addr,
d577 1
a577 1
	       __FUNCTION__, inet_ntop(AF_INET6, &prefix->prefix,
d597 1
a597 1
		syslog(LOG_ERR, "<%s> socket: %s", __FUNCTION__,
d603 1
a603 1
		syslog(LOG_INFO, "<%s> ioctl:SIOCGIFPREFIX %s", __FUNCTION__,
d617 1
a617 1
		       "This should not happen if I am router", __FUNCTION__,
d643 1
a643 1
		       "exist. This should not happen! %s", __FUNCTION__,
d674 1
a674 1
			       __FUNCTION__, rainfo->ifname);
d688 1
a688 1
		       __FUNCTION__);
d797 1
a797 1
		       __FUNCTION__, code,
@


1.16
log
@do not use deprecated ioctls
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.15 2002/05/29 14:34:05 itojun Exp $	*/
d510 1
a510 1
		cp = (char *)index(buf, '\0');
@


1.15
log
@KNF, strlcpy, cleanups from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.14 2002/02/16 21:28:08 millert Exp $	*/
d593 1
d626 7
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 2
a2 2
/*	$OpenBSD: config.c,v 1.13 2001/06/03 09:27:31 itojun Exp $	*/
/*	$KAME: config.c,v 1.47 2001/06/02 18:50:46 jinmei Exp $	*/
a39 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#include <net/if_var.h>
#endif /* __FreeBSD__ >= 3 */
a47 3
#ifdef MIP6
#include <netinet6/mip6.h>
#endif
a55 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a56 1
#endif
d66 1
a66 1
static void makeentry(char *, int, char *, int);
d80 1
a80 1
	long long val64;
d88 1
a88 1
	long long t;							\
d150 3
a152 2
		       "<%s> maxinterval must be between %e and %u",
		       __FUNCTION__, MIN_MAXINTERVAL, MAX_MAXINTERVAL);
d159 3
a161 3
		       "<%s> mininterval must be between %e and %d",
		       __FUNCTION__,
		       MIN_MININTERVAL,
d171 1
a171 1
	tmp->managedflg= val & ND_RA_FLAG_MANAGED;
d173 10
a182 4
#ifdef MIP6
	if (mobileip6)
		tmp->haflg = val & ND_RA_FLAG_HA;
#endif
d187 3
a189 3
		       "<%s> router lifetime on %s must be 0 or"
		       " between %d and %d",
		       __FUNCTION__, intface,
d202 1
a202 1
		syslog(LOG_WARNING,
d204 2
a205 1
		       "which must not be allowed for hosts.",
d212 1
a212 1
	if (val > MAXREACHABLETIME) {
d214 3
a216 2
		       "<%s> reachable time must be no greater than %d",
		       __FUNCTION__, MAXREACHABLETIME);
d223 2
a224 2
		syslog(LOG_ERR,
		       "<%s> retrans time out of range", __FUNCTION__);
d229 1
a229 2
#ifndef MIP6
	if (agetstr("hapref", &bp) || agetstr("hatime", &bp)) {
a234 27
#else
	if (!mobileip6) {
		if (agetstr("hapref", &bp) || agetstr("hatime", &bp)) {
			syslog(LOG_ERR,
			       "<%s> mobile-ip6 configuration without "
			       "proper command line option",
			       __FUNCTION__);
			exit(1);
		}
	} else {
		tmp->hapref = 0;
		if ((val = agetnum("hapref")) >= 0)
			tmp->hapref = (int16_t)val;
		if (tmp->hapref != 0) {
			tmp->hatime = 0;
			MUSTHAVE(val, "hatime");
			tmp->hatime = (u_int16_t)val;
			if (tmp->hatime <= 0) {
				syslog(LOG_ERR,
				       "<%s> home agent lifetime must be greater than 0",
				       __FUNCTION__);
				exit(1);
			}
		}
	}
#endif

d245 1
a245 1
	if ((pfxs = agetnum("addrs")) < 0) {
d255 1
a255 2
	}
	else {
d276 32
a307 1
			makeentry(entbuf, i, "prefixlen", added);
d310 3
a312 3
				syslog(LOG_ERR,
				       "<%s> prefixlen out of range",
				       __FUNCTION__);
d317 4
a320 13
			makeentry(entbuf, i, "pinfoflags", added);
#ifdef MIP6
			if (mobileip6)
			{
				MAYHAVE(val, entbuf,
				    (ND_OPT_PI_FLAG_ONLINK|ND_OPT_PI_FLAG_AUTO|
					 ND_OPT_PI_FLAG_ROUTER));
			} else
#endif
			{
				MAYHAVE(val, entbuf,
				    (ND_OPT_PI_FLAG_ONLINK|ND_OPT_PI_FLAG_AUTO));
			}
a322 3
#ifdef MIP6
			pfx->routeraddr = val & ND_OPT_PI_FLAG_ROUTER;
#endif
d324 1
a324 1
			makeentry(entbuf, i, "vltime", added);
d327 4
a330 3
				syslog(LOG_ERR,
				       "<%s> vltime out of range",
				       __FUNCTION__);
d335 1
a335 1
			makeentry(entbuf, i, "vltimedecr", added);
d343 1
a343 1
			makeentry(entbuf, i, "pltime", added);
d347 4
a350 2
				       "<%s> pltime out of range",
				       __FUNCTION__);
d355 1
a355 1
			makeentry(entbuf, i, "pltimedecr", added);
a361 29

			makeentry(entbuf, i, "addr", added);
			addr = (char *)agetstr(entbuf, &bp);
			if (addr == NULL) {
				syslog(LOG_ERR,
				       "<%s> need %s as an prefix for "
				       "interface %s",
				       __FUNCTION__, entbuf, intface);
				exit(1);
			}
			if (inet_pton(AF_INET6, addr,
				      &pfx->prefix) != 1) {
				syslog(LOG_ERR,
				       "<%s> inet_pton failed for %s",
				       __FUNCTION__, addr);
				exit(1);
			}
			if (IN6_IS_ADDR_MULTICAST(&pfx->prefix)) {
				syslog(LOG_ERR,
				       "<%s> multicast prefix(%s) must "
				       "not be advertised (IF=%s)",
				       __FUNCTION__, addr, intface);
				exit(1);
			}
			if (IN6_IS_ADDR_LINKLOCAL(&pfx->prefix))
				syslog(LOG_NOTICE,
				       "<%s> link-local prefix(%s) will be"
				       " advertised on %s",
				       __FUNCTION__, addr, intface);
d368 2
a369 1
		       "<%s> mtu out of range", __FUNCTION__);
d382 4
a385 3
		       "<%s> advertised link mtu must be between"
		       " least MTU and physical link MTU",
		       __FUNCTION__);
d389 5
d424 2
d433 16
a458 12
		/* set prefix length */
		m = (u_char *)&((struct sockaddr_in6 *)ifa->ifa_netmask)->sin6_addr;
		lim = (u_char *)(ifa->ifa_netmask) + ifa->ifa_netmask->sa_len;
		pp->prefixlen = prefixlen(m, lim);
		if (pp->prefixlen < 0 || pp->prefixlen > 128) {
			syslog(LOG_ERR,
			       "<%s> failed to get prefixlen "
			       "or prefix is invalid",
			       __FUNCTION__);
			exit(1);
		}

d460 1
d462 8
a469 7
		p = (u_char *)&pp->prefix;
		ep = (u_char *)(&pp->prefix + 1);
		while (m < lim)
			*p++ &= *m++;
		while (p < ep)
			*p++ = 0x00;

d497 6
a502 3
makeentry(buf, id, string, add)
    char *buf, *string;
    int id, add;
d504 3
a506 1
	strcpy(buf, string);
d511 1
a511 2
		cp += sprintf(cp, "%d", id);
		*cp = '\0';
d551 1
a551 1
	rai->ra_data = 0;
a656 4
#ifdef MIP6
	struct nd_opt_advinterval *ndopt_advint;
	struct nd_opt_homeagent_info *ndopt_hai;
#endif
d665 1
a665 2
			       " null length on %s."
			       " Treat as not included.",
a674 6
#ifdef MIP6
	if (mobileip6 && rainfo->maxinterval)
		packlen += sizeof(struct nd_opt_advinterval);
	if (mobileip6 && rainfo->hatime)
		packlen += sizeof(struct nd_opt_homeagent_info);
#endif
d683 5
d700 6
a705 1
	ra->nd_ra_flags_reserved = 0;
a709 4
#ifdef MIP6
	ra->nd_ra_flags_reserved |=
		rainfo->haflg ? ND_RA_FLAG_HA : 0;
#endif
a728 11
#ifdef MIP6
	if (mobileip6 && rainfo->maxinterval) {
		ndopt_advint = (struct nd_opt_advinterval *)buf;
		ndopt_advint->nd_opt_adv_type = ND_OPT_ADVINTERVAL;
		ndopt_advint->nd_opt_adv_len = 1;
		ndopt_advint->nd_opt_adv_reserved = 0;
		ndopt_advint->nd_opt_adv_interval = htonl(rainfo->maxinterval *
							  1000);
		buf += sizeof(struct nd_opt_advinterval);
	}
#endif
a729 11
#ifdef MIP6
	if (rainfo->hatime) {
		ndopt_hai = (struct nd_opt_homeagent_info *)buf;
		ndopt_hai->nd_opt_hai_type = ND_OPT_HOMEAGENT_INFO;
		ndopt_hai->nd_opt_hai_len = 1;
		ndopt_hai->nd_opt_hai_reserved = 0;
		ndopt_hai->nd_opt_hai_preference = htons(rainfo->hapref);
		ndopt_hai->nd_opt_hai_lifetime = htons(rainfo->hatime);
		buf += sizeof(struct nd_opt_homeagent_info);
	}
#endif
a746 5
#ifdef MIP6
		if (pfx->routeraddr)
			ndopt_pi->nd_opt_pi_flags_reserved |=
				ND_OPT_PI_FLAG_ROUTER;
#endif
@


1.13
log
@avoid integer overflow on lifetime value.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.12 2001/02/05 06:05:08 itojun Exp $	*/
d74 3
a76 3
static void makeentry __P((char *, int, char *, int));
static void get_prefix __P((struct rainfo *));
static int getinet6sysctl __P((int));
@


1.12
log
@typo.  ntohl -> htonl.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: config.c,v 1.11 2001/02/04 06:22:05 itojun Exp $	*/
/*	$KAME: config.c,v 1.33 2001/02/05 05:52:13 k-sugyou Exp $	*/
d96 1
a96 1
	int t;								\
@


1.11
log
@avoid infinite loop when -s is specified (select loop mistake).
make agetent() 32bit clean.  KAME PR 127.
disable -R (router renumbering receiver).  sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: config.c,v 1.10 2001/01/23 15:36:40 itojun Exp $	*/
/*	$KAME: config.c,v 1.32 2001/02/01 09:12:08 jinmei Exp $	*/
d746 1
a746 1
		ndopt_mtu->nd_opt_mtu_mtu = ntohl(rainfo->linkmtu);
d756 1
a756 1
		ndopt_advint->nd_opt_adv_interval = ntohl(rainfo->maxinterval *
d768 2
a769 2
		ndopt_hai->nd_opt_hai_preference = ntohs(rainfo->hapref);
		ndopt_hai->nd_opt_hai_lifetime = ntohs(rainfo->hatime);
d814 2
a815 2
		ndopt_pi->nd_opt_pi_valid_time = ntohl(vltime);
		ndopt_pi->nd_opt_pi_preferred_time = ntohl(pltime);
@


1.10
log
@make sure to initialize prefix information data before use.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: config.c,v 1.9 2001/01/21 15:11:18 itojun Exp $	*/
/*	$KAME: config.c,v 1.29 2001/01/23 14:13:08 jinmei Exp $	*/
d88 1
d220 2
a221 2
	MAYHAVE(val, "retrans", DEF_ADVRETRANSTIMER);
	if (val < 0 || val > 0xffffffff) {
d226 1
a226 1
	tmp->retranstimer = (u_int32_t)val;
d228 7
a234 2
#ifdef MIP6
	if (!mobileip6)
d236 1
a236 3
	if (1)
#endif
	{
d244 1
a244 3
	}
#ifdef MIP6
	else {
d320 1
a320 1
					 ND_OPT_PI_FLAG_RTADDR));
d330 1
a330 1
			pfx->routeraddr = val & ND_OPT_PI_FLAG_RTADDR;
d334 2
a335 2
			MAYHAVE(val, entbuf, DEF_ADVVALIDLIFETIME);
			if (val < 0 || val > 0xffffffff) {
d341 1
a341 1
			pfx->validlifetime = (u_int32_t)val;
d352 2
a353 2
			MAYHAVE(val, entbuf, DEF_ADVPREFERREDLIFETIME);
			if (val < 0 || val > 0xffffffff) {
d359 1
a359 1
			pfx->preflifetime = (u_int32_t)val;
d674 2
a675 2
	struct nd_opt_advint *ndopt_advint;
	struct nd_opt_hai *ndopt_hai;
d698 1
a698 1
		packlen += sizeof(struct nd_opt_advint);
d700 1
a700 1
		packlen += sizeof(struct nd_opt_hai);
d752 5
a756 5
		ndopt_advint = (struct nd_opt_advint *)buf;
		ndopt_advint->nd_opt_int_type = ND_OPT_ADV_INTERVAL;
		ndopt_advint->nd_opt_int_len = 1;
		ndopt_advint->nd_opt_int_reserved = 0;
		ndopt_advint->nd_opt_int_interval = ntohl(rainfo->maxinterval *
d758 1
a758 1
		buf += sizeof(struct nd_opt_advint);
d764 2
a765 2
		ndopt_hai = (struct nd_opt_hai *)buf;
		ndopt_hai->nd_opt_hai_type = ND_OPT_HA_INFORMATION;
d768 1
a768 1
		ndopt_hai->nd_opt_hai_pref = ntohs(rainfo->hapref);
d770 1
a770 1
		buf += sizeof(struct nd_opt_hai);
d793 1
a793 1
				ND_OPT_PI_FLAG_RTADDR;
@


1.9
log
@do not intsall rtadvd.conf into /etc, it is not required to use it
(rtadvd will derive the configuration from kernel settings).

make it clearer that rtadvd.conf is not necessary, in manpage.

sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: config.c,v 1.8 2001/01/15 11:06:24 itojun Exp $	*/
/*	$KAME: config.c,v 1.27 2001/01/19 03:07:18 itojun Exp $	*/
d295 2
d328 1
a328 2
			if (mobileip6)
				pfx->routeraddr = val & ND_OPT_PI_FLAG_RTADDR;
@


1.8
log
@sync with latest kame tree.
- reduce chances for signal handler rae condition
- decrease chances for misconfiguration
- feedbacks from router renumbering protocol bakeoff
- cleanups related to mtu handling
@
text
@d1 2
a2 2
/*	$OpenBSD: config.c,v 1.7 2000/07/06 10:14:46 itojun Exp $	*/
/*	$KAME: config.c,v 1.26 2000/12/25 12:19:27 itojun Exp $	*/
a435 75
#if 0
	size_t len;
	u_char *buf, *lim, *next;
	u_char ntopbuf[INET6_ADDRSTRLEN];

	if ((len = rtbuf_len()) < 0) {
		syslog(LOG_ERR,
		       "<%s> can't get buffer length for routing info",
		       __FUNCTION__);
		exit(1);
	}
	if ((buf = malloc(len)) == NULL) {
		syslog(LOG_ERR,
		       "<%s> can't allocate buffer", __FUNCTION__);
		exit(1);
	}
	if (get_rtinfo(buf, &len) < 0) {
		syslog(LOG_ERR,
		       "<%s> can't get routing inforamtion", __FUNCTION__);
		exit(1);
	}

	lim = buf + len;
	next = get_next_msg(buf, lim, rai->ifindex, &len,
			    RTADV_TYPE2BITMASK(RTM_GET));
	while (next < lim) {
		struct prefix *pp;
		struct in6_addr *a;

		/* allocate memory to store prefix info. */
		if ((pp = malloc(sizeof(*pp))) == NULL) {
			syslog(LOG_ERR,
			       "<%s> can't get allocate buffer for prefix",
			       __FUNCTION__);
			exit(1);
		}
		memset(pp, 0, sizeof(*pp));

		/* set prefix and its length */
		a = get_addr(next);
		memcpy(&pp->prefix, a, sizeof(*a));
		if ((pp->prefixlen = get_prefixlen(next)) < 0) {
			syslog(LOG_ERR,
			       "<%s> failed to get prefixlen "
			       "or prefix is invalid",
			       __FUNCTION__);
			exit(1);
		}
		syslog(LOG_DEBUG,
		       "<%s> add %s/%d to prefix list on %s",
		       __FUNCTION__,
		       inet_ntop(AF_INET6, a, ntopbuf, sizeof(ntopbuf)),
		       pp->prefixlen, rai->ifname);

		/* set other fields with protocol defaults */
		pp->validlifetime = DEF_ADVVALIDLIFETIME;
		pp->preflifetime = DEF_ADVPREFERREDLIFETIME;
		pp->onlinkflg = 1;
		pp->autoconfflg = 1;
		pp->origin = PREFIX_FROM_KERNEL;

		/* link into chain */
		insque(pp, &rai->prefix);

		/* counter increment */
		rai->pfxs++;

		/* forward pointer and get next prefix(if any) */
		next += len;
		next = get_next_msg(next, lim, rai->ifindex,
				    &len, RTADV_TYPE2BITMASK(RTM_GET));
	}

	free(buf);
#else
a510 1
#endif
@


1.7
log
@sync with router renumber struct decl change.
more logs.  make it very sure to close temporary socket.
@
text
@d1 2
a2 2
/*	$OpenBSD: config.c,v 1.6 2000/05/23 11:23:22 itojun Exp $	*/
/*	$KAME: config.c,v 1.12 2000/05/22 22:23:07 itojun Exp $	*/
d37 1
d66 1
d76 1
d91 1
d122 6
d193 15
d261 9
d340 8
d358 8
d436 1
d480 1
a480 1
			       "or prefixl is invalid",
d487 1
a487 1
		       inet_ntop(AF_INET6, a, ntopbuf, INET6_ADDRSTRLEN),
d510 77
d622 1
d849 3
d868 21
a888 3
		ndopt_pi->nd_opt_pi_valid_time = ntohl(pfx->validlifetime);
		ndopt_pi->nd_opt_pi_preferred_time =
			ntohl(pfx->preflifetime);
d896 20
@


1.6
log
@sync with latest kame.
- weaken logging priority for /etc/resolv.conf open failure
- gather stats, emit stats by SIGUSR1
- use SIOCGIFMTU to get interface MTU (just a matter of #ifdef)
From: "Todd T. Fries" <todd@@fries.net>
@
text
@d1 2
a2 2
/*	$OpenBSD: config.c,v 1.5 2000/03/13 06:16:11 itojun Exp $	*/
/*	$KAME: config.c,v 1.11 2000/05/16 13:34:13 itojun Exp $	*/
@


1.5
log
@bring in latest rtadvd source from kame.
this fixes unclosed file descriptor in router renumbering case.
@
text
@d1 2
a2 1
/*	$OpenBSD: config.c,v 1.4 2000/02/08 05:34:45 itojun Exp $	*/
d61 1
a61 1
#ifdef __NetBSD__
d264 2
d444 1
d500 1
d528 1
a528 1
 * The prefix must be in the list
@


1.4
log
@don't include netinet6/{icmp6,ip6}.h for rfc2292 conformance.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.3 2000/02/02 04:10:37 itojun Exp $	*/
d49 3
d89 1
a89 1
    {									\
d97 1
a97 1
     }
d99 1
a99 1
     {									\
d102 1
a102 1
     }
d146 1
a146 1
		       "<%s> maxinterval must be between %d and %d",
d154 1
a154 1
		       "<%s> mininterval must be between %d and %d",
d168 4
d201 33
d274 12
a285 2
			MAYHAVE(val, entbuf,
				(ND_OPT_PI_FLAG_ONLINK|ND_OPT_PI_FLAG_AUTO));
d288 4
d574 1
d612 4
d635 6
d666 4
d689 24
d726 5
@


1.3
log
@add -R flag (accept router renumbering).  this makes rtadvd to
take the safer side (router renumbering requires certain ipsec setup).
die gracefully on SIGTERM.
@
text
@d1 1
a1 1
/*	$OpenBSD: config.c,v 1.2 1999/12/11 10:33:28 itojun Exp $	*/
d46 1
a46 1
#include <netinet6/ip6.h>
d48 1
a48 1
#include <netinet6/icmp6.h>
@


1.2
log
@enable rtadvd in usr.sbin/Makefile.
rcsid police on usr.sbin/rtadvd.
add sample config into etc/rtadvd.conf.
add files into distrib/sets/list.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a68 1
static void make_packet __P((struct rainfo *));
d549 1
a549 1
static void
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@router advertisement daemon, from KAME
@
text
@@
