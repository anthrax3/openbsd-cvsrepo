head	1.17;
access;
symbols
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.22
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.20
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.18
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.16
	OPENBSD_5_0:1.13.0.14
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.12
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.10
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.11.0.12
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.10
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	kame_19991211:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2015.10.25.22.36.17;	author jca;	state Exp;
branches;
next	1.16;
commitid	sgPunlI9YqFCloS2;

1.16
date	2015.10.25.22.11.34;	author jca;	state Exp;
branches;
next	1.15;
commitid	fhTQouZIvPQVwdr9;

1.15
date	2015.01.19.18.20.47;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	1CWwCgfv5daBoWlX;

1.14
date	2013.11.22.15.15.17;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.21.20.40.55;	author rainer;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.20.11.36.48;	author rainer;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.11.19.59.07;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.27.00.41.48;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.10.19.57.35;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.29.14.34.05;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.04.06.22.05;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.23.11.23.22;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.11.10.33.28;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.11.10.23.29;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.11.10.23.29;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.17
log
@In case of error, also log the file name we failed to open.
@
text
@/*	$OpenBSD: advcap.c,v 1.16 2015/10/25 22:11:34 jca Exp $	*/
/*	$KAME: advcap.c,v 1.9 2002/05/29 14:28:35 itojun Exp $	*/

/*
 * Copyright (c) 1983 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * remcap - routines for dealing with the remote host data base
 *
 * derived from termcap
 */
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include "pathnames.h"
#include "log.h"

#define MAXHOP		32		/* max number of tc= indirections */

#define	tgetent		agetent
#define	tnchktc		anchktc
#define	tnamatch	anamatch
#define	tgetnum		agetnum
#define	tgetflag	agetflag
#define	tgetstr		agetstr

#if 0
#define V_TERMCAP	"REMOTE"
#define V_TERM		"HOST"
#endif


/*
 * termcap - routines for dealing with the terminal capability data base
 *
 * BUG:		Should use a "last" pointer in tbuf, so that searching
 *		for capabilities alphabetically would not be a n**2/2
 *		process when large numbers of capabilities are given.
 * Note:	If we add a last pointer now we will screw up the
 *		tc capability. We really should compile termcap.
 *
 * Essentially all the work here is scanning and decoding escapes
 * in string capabilities.  We don't use stdio because the editor
 * doesn't, and because living w/o it is not hard.
 */

static	char *tbuf;
static	int hopcount;	/* detect infinite loops in termcap, init 0 */

static	char *remotefile;

extern char *conffile;

int tgetent(char *, char *);
int getent(char *, char *, char *);
int tnchktc(void);
int tnamatch(char *);
static char *tskip(char *);
int64_t tgetnum(char *);
int tgetflag(char *);
char *tgetstr(char *, char **);
static char *tdecode(char *, char **);

/*
 * Get an entry for terminal name in buffer bp,
 * from the termcap file.  Parse is very rudimentary;
 * we just notice escaped newlines.
 */
int
tgetent(char *bp, char *name)
{
	char *cp;

	remotefile = cp = conffile ? conffile : _PATH_RTADVDCONF;
	return (getent(bp, name, cp));
}

int
getent(char *bp, char *name, char *cp)
{
	int c;
	int i = 0, cnt = 0;
	char ibuf[BUFSIZ];
	int tf;

	tbuf = bp;
	tf = 0;
	/*
	 * TERMCAP can have one of two things in it. It can be the
	 * name of a file to use instead of /etc/termcap. In this
	 * case it better start with a "/". Or it can be an entry to
	 * use so we don't have to read the file. In this case it
	 * has to already have the newlines crunched out.
	 */
	if (cp && *cp) {
		tf = open(cp, O_RDONLY);
	}
	if (tf < 0) {
		log_warn("open(\"%s\")", cp);
		return (-2);
	}
	for (;;) {
		cp = bp;
		for (;;) {
			if (i == cnt) {
				cnt = read(tf, ibuf, BUFSIZ);
				if (cnt <= 0) {
					close(tf);
					return (0);
				}
				i = 0;
			}
			c = ibuf[i++];
			if (c == '\n') {
				if (cp > bp && cp[-1] == '\\') {
					cp--;
					continue;
				}
				break;
			}
			if (cp >= bp + BUFSIZ) {
				write(STDERR_FILENO, "Remcap entry too long\n", 23);
				break;
			} else
				*cp++ = c;
		}
		*cp = 0;

		/*
		 * The real work for the match.
		 */
		if (tnamatch(name)) {
			close(tf);
			return (tnchktc());
		}
	}
}

/*
 * tnchktc: check the last entry, see if it's tc=xxx. If so,
 * recursively find xxx and append that entry (minus the names)
 * to take the place of the tc=xxx entry. This allows termcap
 * entries to say "like an HP2621 but doesn't turn on the labels".
 * Note that this works because of the left to right scan.
 */
int
tnchktc(void)
{
	char *p, *q;
	char tcname[16];	/* name of similar terminal */
	char tcbuf[BUFSIZ];
	char *holdtbuf = tbuf;
	int l;

	p = tbuf + strlen(tbuf) - 2;	/* before the last colon */
	while (*--p != ':')
		if (p < tbuf) {
			write(STDERR_FILENO, "Bad remcap entry\n", 18);
			return (0);
		}
	p++;
	/* p now points to beginning of last field */
	if (p[0] != 't' || p[1] != 'c')
		return (1);
	strlcpy(tcname, p + 3, sizeof tcname);
	q = tcname;
	while (*q && *q != ':')
		q++;
	*q = 0;
	if (++hopcount > MAXHOP) {
		write(STDERR_FILENO, "Infinite tc= loop\n", 18);
		return (0);
	}
	if (getent(tcbuf, tcname, remotefile) != 1) {
		log_warnx("Could not parse %s: "
		    "Unresolvable reference to %s.", remotefile, tcname);
		return (0);
	}
	for (q = tcbuf; *q++ != ':'; )
		;
	l = p - holdtbuf + strlen(q);
	if (l > BUFSIZ) {
		write(STDERR_FILENO, "Remcap entry too long\n", 23);
		q[BUFSIZ - (p-holdtbuf)] = 0;
	}
	strlcpy(p, q, holdtbuf + BUFSIZ - p);
	tbuf = holdtbuf;
	return (1);
}

/*
 * Tnamatch deals with name matching.  The first field of the termcap
 * entry is a sequence of names separated by |'s, so we compare
 * against each such name.  The normal : terminator after the last
 * name (before the first field) stops us.
 */
int
tnamatch(char *np)
{
	char *Np, *Bp;

	Bp = tbuf;
	if (*Bp == '#')
		return (0);
	for (;;) {
		for (Np = np; *Np && *Bp == *Np; Bp++, Np++)
			continue;
		if (*Np == 0 && (*Bp == '|' || *Bp == ':' || *Bp == 0))
			return (1);
		while (*Bp && *Bp != ':' && *Bp != '|')
			Bp++;
		if (*Bp == 0 || *Bp == ':')
			return (0);
		Bp++;
	}
}

/*
 * Skip to the next field.  Notice that this is very dumb, not
 * knowing about \: escapes or any such.  If necessary, :'s can be put
 * into the termcap file in octal.
 */
static char *
tskip(char *bp)
{
	int dquote;

	dquote = 0;
	while (*bp) {
		switch (*bp) {
		case ':':
			if (!dquote)
				goto breakbreak;
			else
				bp++;
			break;
		case '\\':
			bp++;
			if (isdigit((unsigned char)*bp)) {
				while (isdigit((unsigned char)*bp++))
					;
			} else
				bp++;
		case '"':
			dquote = (dquote ? 1 : 0);
			bp++;
			break;
		default:
			bp++;
			break;
		}
	}
breakbreak:
	if (*bp == ':')
		bp++;
	return (bp);
}

/*
 * Return the (numeric) option id.
 * Numeric options look like
 *	li#80
 * i.e. the option string is separated from the numeric value by
 * a # character.  If the option is not found we return -1.
 * Note that we handle octal numbers beginning with 0.
 */
int64_t
tgetnum(char *id)
{
	int64_t i;
	int base;
	char *bp = tbuf;

	for (;;) {
		bp = tskip(bp);
		if (*bp == 0)
			return (-1);
		if (strncmp(bp, id, strlen(id)) != 0)
			continue;
		bp += strlen(id);
		if (*bp == '@@')
			return (-1);
		if (*bp != '#')
			continue;
		bp++;
		base = 10;
		if (*bp == '0')
			base = 8;
		i = 0;
		while (isdigit((unsigned char)*bp))
			i *= base, i += *bp++ - '0';
		return (i);
	}
}

/*
 * Handle a flag option.
 * Flag options are given "naked", i.e. followed by a : or the end
 * of the buffer.  Return 1 if we find the option, or 0 if it is
 * not given.
 */
int
tgetflag(char *id)
{
	char *bp = tbuf;

	for (;;) {
		bp = tskip(bp);
		if (!*bp)
			return (0);
		if (strncmp(bp, id, strlen(id)) == 0) {
			bp += strlen(id);
			if (!*bp || *bp == ':')
				return (1);
			else if (*bp == '@@')
				return (0);
		}
	}
}

/*
 * Get a string valued option.
 * These are given as
 *	cl=^Z
 * Much decoding is done on the strings, and the strings are
 * placed in area, which is a ref parameter which is updated.
 * No checking on area overflow.
 */
char *
tgetstr(char *id, char **area)
{
	char *bp = tbuf;

	for (;;) {
		bp = tskip(bp);
		if (!*bp)
			return (0);
		if (strncmp(bp, id, strlen(id)) != 0)
			continue;
		bp += strlen(id);
		if (*bp == '@@')
			return (0);
		if (*bp != '=')
			continue;
		bp++;
		return (tdecode(bp, area));
	}
}

/*
 * Tdecode does the grung work to decode the
 * string capability escapes.
 */
static char *
tdecode(char *str, char **area)
{
	char *cp;
	int c;
	char *dp;
	int i;
	char term;

	term = ':';
	cp = *area;
again:
	if (*str == '"') {
		term = '"';
		str++;
	}
	while ((c = *str++) && c != term) {
		switch (c) {

		case '^':
			c = *str++ & 037;
			break;

		case '\\':
			dp = "E\033^^\\\\::n\nr\rt\tb\bf\f\"\"";
			c = *str++;
nextc:
			if (*dp++ == c) {
				c = *dp++;
				break;
			}
			dp++;
			if (*dp)
				goto nextc;
			if (isdigit((unsigned char)c)) {
				c -= '0', i = 2;
				do
					c <<= 3, c |= *str++ - '0';
				while (--i && isdigit((unsigned char)*str));
			}
			break;
		}
		*cp++ = c;
	}
	if (c == term && term != ':') {
		term = ':';
		goto again;
	}
	*cp++ = 0;
	str = *area;
	*area = cp;
	return (str);
}
@


1.16
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.15 2015/01/19 18:20:47 deraadt Exp $	*/
d131 1
a131 1
		log_warn("open");
@


1.15
log
@remove #ifndef #define blocks trying to handle lack of BUFSIZ
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.14 2013/11/22 15:15:17 deraadt Exp $	*/
d102 1
a102 2
tgetent(bp, name)
	char *bp, *name;
d111 1
a111 2
getent(bp, name, cp)
	char *bp, *name, *cp;
d179 1
a179 1
tnchktc()
d230 1
a230 2
tnamatch(np)
	char *np;
d256 1
a256 2
tskip(bp)
	char *bp;
d300 1
a300 2
tgetnum(id)
	char *id;
d335 1
a335 2
tgetflag(id)
	char *id;
d362 1
a362 2
tgetstr(id, area)
	char *id, **area;
d387 1
a387 3
tdecode(str, area)
	char *str;
	char **area;
@


1.14
log
@unsigned char casts where needed for for ctype.h
checked by florian
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.13 2008/04/21 20:40:55 rainer Exp $	*/
a49 3
#ifndef BUFSIZ
#define	BUFSIZ		1024
#endif
@


1.13
log
@Clean up logging by introducing the logging API used in
other daemons and clean up the command line options.
For details, see rtadvd(8).

ok bluhm@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.12 2008/04/20 11:36:48 rainer Exp $	*/
d278 2
a279 2
			if (isdigit(*bp)) {
				while (isdigit(*bp++))
d330 1
a330 1
		while (isdigit(*bp))
d432 1
a432 1
			if (isdigit(c)) {
d436 1
a436 1
				while (--i && isdigit(*str));
@


1.12
log
@Take failed system calls more serious than LOG_INFO.
This is mainly in preparation for more changes to logging.

Ok bluhm@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.11 2005/04/11 19:59:07 deraadt Exp $	*/
a44 1
#include <syslog.h>
d48 1
a66 1
char	*RM;
d133 1
a133 1
		tf = open(RM = cp, O_RDONLY);
d136 1
a136 2
		syslog(LOG_WARNING,
		       "<%s> open: %s", __func__, strerror(errno));
d212 2
@


1.11
log
@use STDERR_FILENO; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.10 2003/06/02 23:36:54 millert Exp $	*/
d137 1
a137 1
		syslog(LOG_INFO,
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.9 2003/04/27 00:41:48 deraadt Exp $	*/
d161 1
a161 1
				write(2,"Remcap entry too long\n", 23);
d197 1
a197 1
			write(2, "Bad remcap entry\n", 18);
d210 1
a210 1
		write(2, "Infinite tc= loop\n", 18);
d220 1
a220 1
		write(2, "Remcap entry too long\n", 23);
@


1.9
log
@string cleaning; from tdeval and tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.8 2002/06/10 19:57:35 espie Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Kill __FUNCTION__.
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.7 2002/05/29 14:34:05 itojun Exp $	*/
d227 1
a227 1
	strcpy(p, q);
@


1.7
log
@KNF, strlcpy, cleanups from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.6 2002/03/14 16:44:25 mpech Exp $	*/
d142 1
a142 1
		       "<%s> open: %s", __FUNCTION__, strerror(errno));
@


1.6
log
@kill more registers.

millert@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: advcap.c,v 1.5 2002/02/16 21:28:08 millert Exp $	*/
/*	$KAME: advcap.c,v 1.5 2001/02/01 09:12:08 jinmei Exp $	*/
d99 1
a99 1
long long tgetnum(char *);
d164 1
a164 1
			if (cp >= bp+BUFSIZ) {
d200 1
a200 1
		if (p<tbuf) {
d208 1
a208 1
	strcpy(tcname, p+3);
d310 1
a310 1
long long
d314 1
a314 1
	long long i;
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.4 2001/02/04 06:22:05 itojun Exp $	*/
d123 2
a124 2
	register int c;
	register int i = 0, cnt = 0;
d192 1
a192 1
	register char *p, *q;
d242 1
a242 1
	register char *Np, *Bp;
d267 1
a267 1
	register char *bp;
d314 3
a316 3
	register long long i;
	register int base;
	register char *bp = tbuf;
d350 1
a350 1
	register char *bp = tbuf;
d378 1
a378 1
	register char *bp = tbuf;
d402 1
a402 1
	register char *str;
d405 3
a407 3
	register char *cp;
	register int c;
	register char *dp;
@


1.4
log
@avoid infinite loop when -s is specified (select loop mistake).
make agetent() 32bit clean.  KAME PR 127.
disable -R (router renumbering receiver).  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: advcap.c,v 1.3 2000/05/23 11:23:22 itojun Exp $	*/
d94 9
a102 9
int tgetent __P((char *, char *));
int getent __P((char *, char *, char *));
int tnchktc __P((void));
int tnamatch __P((char *));
static char *tskip __P((char *));
long long tgetnum __P((char *));
int tgetflag __P((char *));
char *tgetstr __P((char *, char **));
static char *tdecode __P((char *, char **));
@


1.3
log
@sync with latest kame.
- weaken logging priority for /etc/resolv.conf open failure
- gather stats, emit stats by SIGUSR1
- use SIOCGIFMTU to get interface MTU (just a matter of #ifdef)
From: "Todd T. Fries" <todd@@fries.net>
@
text
@d1 2
a2 2
/*	$OpenBSD: advcap.c,v 1.2 1999/12/11 10:33:28 itojun Exp $	*/
/*	$KAME: advcap.c,v 1.4 2000/05/23 11:17:40 itojun Exp $	*/
d99 1
a99 1
int tgetnum __P((char *));
d310 1
a310 1
int
d314 1
a314 1
	register long int i;
@


1.2
log
@enable rtadvd in usr.sbin/Makefile.
rcsid police on usr.sbin/rtadvd.
add sample config into etc/rtadvd.conf.
add files into distrib/sets/list.
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
a36 4
#ifndef lint
static char sccsid[] = "@@(#)remcap.c	5.5 (Berkeley) 2/2/91";
#endif /* not lint */

d141 1
a141 1
		syslog(LOG_WARNING,
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@router advertisement daemon, from KAME
@
text
@@
