head	1.91;
access;
symbols
	OPENBSD_6_2:1.91.0.4
	OPENBSD_6_2_BASE:1.91
	OPENBSD_6_1:1.83.0.4
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.75.0.2
	OPENBSD_6_0_BASE:1.75
	OPENBSD_5_9:1.68.0.2
	OPENBSD_5_9_BASE:1.68
	OPENBSD_5_8:1.53.0.6
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.45.0.6
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.40.0.4
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.2
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.38.0.10
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.8
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.4
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.6
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.28.0.6
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.25.0.12
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.10
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.8
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.6
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.4
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	kame_19991211:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.91
date	2017.08.22.01.44.09;	author jca;	state Exp;
branches;
next	1.90;
commitid	8TqCbvtAyQz922aV;

1.90
date	2017.08.13.07.52.17;	author florian;	state Exp;
branches;
next	1.89;
commitid	89K2w5k1CHKrbrtB;

1.89
date	2017.08.12.07.38.26;	author florian;	state Exp;
branches;
next	1.88;
commitid	Q0smBW9AEZLLPQYj;

1.88
date	2017.08.10.19.07.14;	author jca;	state Exp;
branches;
next	1.87;
commitid	NTmGZ5SuATQQ3twg;

1.87
date	2017.07.12.06.11.07;	author florian;	state Exp;
branches;
next	1.86;
commitid	jGIspXgAx9pFxeFL;

1.86
date	2017.06.09.13.31.03;	author florian;	state Exp;
branches;
next	1.85;
commitid	LlOIRl1kIoyqJ4ia;

1.85
date	2017.04.05.14.50.05;	author jca;	state Exp;
branches;
next	1.84;
commitid	qd6b0MxddEZHB3pp;

1.84
date	2017.04.05.14.48.48;	author jca;	state Exp;
branches;
next	1.83;
commitid	9j56AwyxYHYCSFjv;

1.83
date	2017.01.20.23.29.58;	author benno;	state Exp;
branches;
next	1.82;
commitid	3AqljMRVX8SdKyh7;

1.82
date	2016.09.26.17.15.19;	author jca;	state Exp;
branches;
next	1.81;
commitid	cejVwQpY7FYSCLBx;

1.81
date	2016.09.21.18.54.24;	author jca;	state Exp;
branches;
next	1.80;
commitid	kQbjpIcdy1sNy5fX;

1.80
date	2016.09.21.18.51.05;	author jca;	state Exp;
branches;
next	1.79;
commitid	FI9BvbnjIAPrQyGg;

1.79
date	2016.09.15.16.16.03;	author jca;	state Exp;
branches;
next	1.78;
commitid	GzAm3cnfimMp8ONG;

1.78
date	2016.09.03.16.57.29;	author jca;	state Exp;
branches;
next	1.77;
commitid	7SEDXmmK8UwqV39l;

1.77
date	2016.08.20.15.10.18;	author jca;	state Exp;
branches;
next	1.76;
commitid	MP0D7nWYjFxZ58zJ;

1.76
date	2016.08.02.17.00.09;	author jca;	state Exp;
branches;
next	1.75;
commitid	LwUwsYotrzF8sP65;

1.75
date	2016.06.30.10.17.18;	author florian;	state Exp;
branches;
next	1.74;
commitid	4xZHVtO6VAaDhwlm;

1.74
date	2016.06.29.14.19.38;	author jca;	state Exp;
branches;
next	1.73;
commitid	UKZNj8xE8arS6lgt;

1.73
date	2016.03.01.20.51.05;	author jca;	state Exp;
branches;
next	1.72;
commitid	odaF3eMKay0HIw4l;

1.72
date	2016.03.01.12.52.43;	author jca;	state Exp;
branches;
next	1.71;
commitid	qLTuytlmNQD2lPuw;

1.71
date	2016.02.26.12.50.03;	author jca;	state Exp;
branches;
next	1.70;
commitid	O3kwoEygFzuy5eU7;

1.70
date	2016.02.26.12.46.10;	author jca;	state Exp;
branches;
next	1.69;
commitid	ruTUw7cc8ry2nGqT;

1.69
date	2016.02.26.12.34.30;	author jca;	state Exp;
branches;
next	1.68;
commitid	3Gy1tnlSeCn27qqI;

1.68
date	2016.02.09.00.40.00;	author jca;	state Exp;
branches;
next	1.67;
commitid	YjuFLjuxPNq0Hj8w;

1.67
date	2016.02.09.00.39.13;	author jca;	state Exp;
branches;
next	1.66;
commitid	56O7SdKp4bWnIxx6;

1.66
date	2016.02.08.23.19.00;	author jca;	state Exp;
branches;
next	1.65;
commitid	731eoDfUV7AoJwjq;

1.65
date	2016.02.08.23.15.37;	author jca;	state Exp;
branches;
next	1.64;
commitid	e0hXBsxU32N38fYG;

1.64
date	2016.02.07.21.10.33;	author jca;	state Exp;
branches;
next	1.63;
commitid	2ON9ppNo59Hozg6j;

1.63
date	2016.02.05.12.16.21;	author jca;	state Exp;
branches;
next	1.62;
commitid	ISz1Iw2cSCZfJFP0;

1.62
date	2016.02.05.12.15.15;	author jca;	state Exp;
branches;
next	1.61;
commitid	DpoUzItOlsh9VKpm;

1.61
date	2015.12.01.12.11.31;	author jca;	state Exp;
branches;
next	1.60;
commitid	DYOw8eAThQdST8xa;

1.60
date	2015.11.30.20.58.08;	author jca;	state Exp;
branches;
next	1.59;
commitid	NzXzLkpKQJI7NQZx;

1.59
date	2015.11.30.20.52.28;	author jca;	state Exp;
branches;
next	1.58;
commitid	0AFsvIbwpuBr4CTd;

1.58
date	2015.10.25.22.11.34;	author jca;	state Exp;
branches;
next	1.57;
commitid	fhTQouZIvPQVwdr9;

1.57
date	2015.10.25.21.31.58;	author jca;	state Exp;
branches;
next	1.56;
commitid	io0CTPXsqSHshCW4;

1.56
date	2015.10.25.21.23.42;	author jca;	state Exp;
branches;
next	1.55;
commitid	GzycAVdMw9ynTrjU;

1.55
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	z3HrihslRYb4HqW9;

1.54
date	2015.08.18.20.25.28;	author miod;	state Exp;
branches;
next	1.53;
commitid	Jx4kAjGMcrCkXO73;

1.53
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	Uu5nFG3wCl0LACBb;

1.52
date	2015.01.01.20.28.27;	author florian;	state Exp;
branches;
next	1.51;
commitid	ZNf1tCJq0aO2PJUt;

1.51
date	2015.01.01.16.31.59;	author florian;	state Exp;
branches;
next	1.50;
commitid	jxfyyzZMf0IwZi9R;

1.50
date	2014.11.18.20.54.29;	author krw;	state Exp;
branches;
next	1.49;
commitid	yCis8OrOsfixbKpI;

1.49
date	2014.11.02.02.33.33;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	B3C7DQrPMfdtSrkQ;

1.48
date	2014.10.22.19.47.28;	author brad;	state Exp;
branches;
next	1.47;
commitid	MqdFr2wZCHSR3ZEB;

1.47
date	2014.07.04.22.39.31;	author guenther;	state Exp;
branches;
next	1.46;
commitid	uZtmgjqfBmgQ2HY0;

1.46
date	2014.05.15.05.03.24;	author jca;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.05.14.25.52;	author dtucker;	state Exp;
branches;
next	1.44;

1.44
date	2013.04.30.12.30.40;	author florian;	state Exp;
branches;
next	1.43;

1.43
date	2013.04.30.12.29.04;	author florian;	state Exp;
branches;
next	1.42;

1.42
date	2013.04.19.05.06.35;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2013.04.17.00.14.37;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2012.07.08.10.46.00;	author phessler;	state Exp;
branches;
next	1.39;

1.39
date	2011.03.02.17.30.48;	author bluhm;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.21.23.44.04;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2008.11.03.07.02.44;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.09.22.53.24;	author rainer;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.08.21.08.57;	author rainer;	state Exp;
branches;
next	1.34;

1.34
date	2008.05.02.04.28.51;	author pyr;	state Exp;
branches;
next	1.33;

1.33
date	2008.04.23.10.17.50;	author pyr;	state Exp;
branches;
next	1.32;

1.32
date	2008.04.21.20.40.55;	author rainer;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2008.03.24.16.11.05;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2008.03.18.19.32.18;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.10.08.10.47;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.15.06.14.07;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.27.18.26.13;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.14.18.46.45;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.14.18.33.58;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.10.05.31.17;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.10.19.57.35;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.09.00.56.09;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.07.00.42.14;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.04.05.13.42;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.29.14.34.05;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.21.23.33.56;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.21.23.29.46;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.17.19.42.39;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.11.03.51.08;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.01.23.27.23;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.01.19.27.28;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.17.19.49.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.04.06.22.05;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.15.11.06.28;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.06.10.14.48;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.23.11.33.48;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.23.11.23.23;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.13.06.16.11;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.02.04.10.37;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.11.10.33.29;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.11.10.23.26;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.11.10.23.26;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.91
log
@Rename now oddly-named variable.
@
text
@/*	$OpenBSD: rtadvd.c,v 1.90 2017/08/13 07:52:17 florian Exp $	*/
/*	$KAME: rtadvd.c,v 1.66 2002/05/29 14:18:36 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/time.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>

#include <arpa/inet.h>

#include <time.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <err.h>
#include <errno.h>
#include <event.h>
#include <string.h>
#include <pwd.h>
#include <signal.h>
#include <fcntl.h>
#include <paths.h>

#include "rtadvd.h"
#include "advcap.h"
#include "if.h"
#include "config.h"
#include "dump.h"
#include "log.h"

struct msghdr rcvmhdr;
static u_char *rcvcmsgbuf;
static size_t rcvcmsgbuflen;
static u_char *sndcmsgbuf = NULL;
static size_t sndcmsgbuflen;
struct msghdr sndmhdr;
struct iovec rcviov[2];
struct iovec sndiov[2];
static char *rtsockbuf;
static size_t rtsockbuflen;
struct sockaddr_in6 from;
struct sockaddr_in6 sin6_allnodes = {sizeof(sin6_allnodes), AF_INET6};
int sock;
int rtsock = -1;
int ioctl_sock;
int dflag = 0, sflag = 0;

u_char *conffile = NULL;

struct ralist ralist;

struct nd_opt {
	SLIST_ENTRY(nd_opt)	 entry;
	struct nd_opt_hdr	*opt;
};

union nd_opts {
	struct nd_opt_hdr *nd_opt_array[9];
	struct {
		struct nd_opt_hdr *zero;
		struct nd_opt_hdr *src_lladdr;
		struct nd_opt_hdr *tgt_lladdr;
		struct nd_opt_prefix_info *pi;
		struct nd_opt_rd_hdr *rh;
		struct nd_opt_mtu *mtu;
		SLIST_HEAD(nd_optlist, nd_opt)	list;
	} nd_opt_each;
};
#define nd_opts_src_lladdr	nd_opt_each.src_lladdr
#define nd_opts_tgt_lladdr	nd_opt_each.tgt_lladdr
#define nd_opts_pi		nd_opt_each.pi
#define nd_opts_rh		nd_opt_each.rh
#define nd_opts_mtu		nd_opt_each.mtu
#define nd_opts_list		nd_opt_each.list

#define NDOPT_FLAG_SRCLINKADDR	(1 << 0)
#define NDOPT_FLAG_TGTLINKADDR	(1 << 1)
#define NDOPT_FLAG_PREFIXINFO	(1 << 2)
#define NDOPT_FLAG_RDHDR	(1 << 3)
#define NDOPT_FLAG_MTU		(1 << 4)
#define NDOPT_FLAG_RDNSS	(1 << 5)
#define NDOPT_FLAG_DNSSL	(1 << 6)
#define NDOPT_FLAG_ROUTE_INFO	(1 << 7)

u_int32_t ndopt_flags[] = {
	[ND_OPT_SOURCE_LINKADDR]	= NDOPT_FLAG_SRCLINKADDR,
	[ND_OPT_TARGET_LINKADDR]	= NDOPT_FLAG_TGTLINKADDR,
	[ND_OPT_PREFIX_INFORMATION]	= NDOPT_FLAG_PREFIXINFO,
	[ND_OPT_REDIRECTED_HEADER]	= NDOPT_FLAG_RDHDR,
	[ND_OPT_MTU]			= NDOPT_FLAG_MTU,
	[ND_OPT_ROUTE_INFO]		= NDOPT_FLAG_ROUTE_INFO,
	[ND_OPT_RDNSS]			= NDOPT_FLAG_RDNSS,
	[ND_OPT_DNSSL]			= NDOPT_FLAG_DNSSL,
};

static __dead void usage(void);
static void sock_open(void);
static void rtsock_open(void);
static void rs_input(int, struct nd_router_solicit *,
    struct in6_pktinfo *, struct sockaddr_in6 *);
static void ra_input(int, struct nd_router_advert *,
    struct in6_pktinfo *, struct sockaddr_in6 *);
static int prefix_check(struct nd_opt_prefix_info *, struct rainfo *,
    struct sockaddr_in6 *);
static int nd6_options(struct nd_opt_hdr *, int,
    union nd_opts *, u_int32_t);
static void free_ndopts(union nd_opts *);
static void ra_output(struct rainfo *, struct sockaddr_in6 *);
static struct rainfo *if_indextorainfo(int);
static int rdaemon(int);

static void dump_cb(int, short, void *);
static void die_cb(int, short, void *);
static void rtsock_cb(int, short, void *);
static void sock_cb(int, short, void *);
static void timer_cb(int, short, void *);

int
main(int argc, char *argv[])
{
	struct passwd *pw;
	int ch;
	int devnull = -1;
	struct event ev_sock;
	struct event ev_rtsock;
	struct event ev_sigterm;
	struct event ev_sigusr1;
	struct rainfo *rai;

	log_procname = getprogname();
	log_init(1);		/* log to stderr until daemonized */

	closefrom(3);

	/* get command line options and arguments */
	while ((ch = getopt(argc, argv, "c:ds")) != -1) {
		switch (ch) {
		case 'c':
			conffile = optarg;
			break;
		case 'd':
			dflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
	if (argc == 0)
		usage();

	if (!dflag) {
		devnull = open(_PATH_DEVNULL, O_RDWR, 0);
		if (devnull == -1)
			fatal("open(\"" _PATH_DEVNULL "\")");
	} else
		log_verbose(1);

	SLIST_INIT(&ralist);

	/* get iflist block from kernel */
	init_iflist();

	if (conffile == NULL)
		log_init(dflag);

	if ((ioctl_sock = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		fatal("socket");

	while (argc--)
		getconfig(*argv++);

	if (inet_pton(AF_INET6, ALLNODES, &sin6_allnodes.sin6_addr) != 1)
		fatal("inet_pton failed");

	sock_open();

	if (sflag == 0)
		rtsock_open();

	if ((pw = getpwnam(RTADVD_USER)) == NULL)
		fatal("getpwnam(" RTADVD_USER ")");
	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");
	if (setgroups(1, &pw->pw_gid) == -1 ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("cannot drop privileges");

	if (!dflag) {
		if (rdaemon(devnull) == -1)
			fatal("rdaemon");
	}

	if (conffile != NULL)
		log_init(dflag);

	if (pledge("stdio inet route", NULL) == -1)
		err(1, "pledge");

	event_init();

	signal_set(&ev_sigterm, SIGTERM, die_cb, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_set(&ev_sigusr1, SIGUSR1, dump_cb, NULL);
	signal_add(&ev_sigusr1, NULL);

	event_set(&ev_sock, sock, EV_READ|EV_PERSIST, sock_cb, NULL);
	event_add(&ev_sock, NULL);
	if (rtsock != -1) {
		event_set(&ev_rtsock, rtsock, EV_READ|EV_PERSIST, rtsock_cb,
		    NULL);
		event_add(&ev_rtsock, NULL);
	}

	SLIST_FOREACH(rai, &ralist, entry) {
		evtimer_set(&rai->timer.ev, timer_cb, rai);
		evtimer_add(&rai->timer.ev, &rai->timer.tm);
	}

	event_dispatch();

	log_warn("event_dispatch returned");

	return 1;
}

static void
usage(void)
{
	fprintf(stderr, "usage: %s [-ds] [-c configfile] interface ...\n",
	    getprogname());
	exit(1);
}

static void
dump_cb(int sig, short event, void *arg)
{
	rtadvd_dump();
}

static void
die_cb(int sig, short event, void *arg)
{
	struct rainfo *ra;
	int i;
	const int retrans = MAX_FINAL_RTR_ADVERTISEMENTS;

	log_debug("cease to be an advertising router");

	SLIST_FOREACH(ra, &ralist, entry) {
		ra->lifetime = 0;
		make_packet(ra);
	}
	for (i = 0; i < retrans; i++) {
		SLIST_FOREACH(ra, &ralist, entry)
			ra_output(ra, &sin6_allnodes);
		sleep(MIN_DELAY_BETWEEN_RAS);
	}
	exit(0);
	/*NOTREACHED*/
}

static void
rtsock_cb(int fd, short event, void *arg)
{
	int n, type, ifindex = 0, oldifflags, plen;
	char *rtm;
	u_char ifname[IF_NAMESIZE];
	struct prefix *prefix;
	struct rainfo *rai;
	struct in6_addr *addr;
	char addrbuf[INET6_ADDRSTRLEN];

	n = read(rtsock, rtsockbuf, rtsockbuflen);
	log_debug("received a routing message "
	    "(type = %d, len = %d)", rtmsg_type(rtsockbuf), n);

	rtm = rtsockbuf;
	if (validate_msg(rtm) == -1)
		return;

	type = rtmsg_type(rtm);
	switch (type) {
	case RTM_ADD:
	case RTM_DELETE:
		ifindex = get_rtm_ifindex(rtm);
		break;
	case RTM_NEWADDR:
	case RTM_DELADDR:
		ifindex = get_ifam_ifindex(rtm);
		break;
	case RTM_IFINFO:
		ifindex = get_ifm_ifindex(rtm);
		break;
	default:
		/* should not reach here */
		log_debug("unknown rtmsg %d on %s",
		    type, if_indextoname(ifindex, ifname));
		return;
	}

	if ((rai = if_indextorainfo(ifindex)) == NULL) {
		log_debug("route changed on "
		    "non advertising interface(%s)",
		    if_indextoname(ifindex, ifname));
		return;
	}
	oldifflags = iflist[ifindex]->ifm_flags;

	switch (type) {
	case RTM_ADD:
		/* init ifflags because it may have changed */
		iflist[ifindex]->ifm_flags =
			if_getflags(ifindex, iflist[ifindex]->ifm_flags);

		if (sflag)
			break;	/* we aren't interested in prefixes  */

		addr = get_addr(rtm);
		plen = get_prefixlen(rtm);
		/* sanity check for plen */
		/* as RFC2373, prefixlen is at least 4 */
		if (plen < 4 || plen > 127) {
			log_info("new interface route's"
			    " plen %d is invalid for a prefix", plen);
			break;
		}
		prefix = find_prefix(rai, addr, plen);
		if (prefix) {
			log_debug("new prefix(%s/%d) "
			    "added on %s, "
			    "but it was already in list",
			    inet_ntop(AF_INET6, addr,
				addrbuf, INET6_ADDRSTRLEN),
			    plen, rai->ifname);
			break;
		}
		make_prefix(rai, ifindex, addr, plen);
		break;
	case RTM_DELETE:
		/* init ifflags because it may have changed */
		iflist[ifindex]->ifm_flags =
			if_getflags(ifindex, iflist[ifindex]->ifm_flags);

		if (sflag)
			break;

		addr = get_addr(rtm);
		plen = get_prefixlen(rtm);
		/* sanity check for plen */
		/* as RFC2373, prefixlen is at least 4 */
		if (plen < 4 || plen > 127) {
			log_info("deleted interface route's "
			    "plen %d is invalid for a prefix", plen);
			break;
		}
		prefix = find_prefix(rai, addr, plen);
		if (prefix == NULL) {
			log_debug("prefix(%s/%d) was "
			    "deleted on %s, "
			    "but it was not in list",
			    inet_ntop(AF_INET6, addr,
				addrbuf, INET6_ADDRSTRLEN),
			    plen, rai->ifname);
			break;
		}
		delete_prefix(rai, prefix);
		break;
	case RTM_NEWADDR:
	case RTM_DELADDR:
		/* init ifflags because it may have changed */
		iflist[ifindex]->ifm_flags =
			if_getflags(ifindex, iflist[ifindex]->ifm_flags);
		break;
	case RTM_IFINFO:
		iflist[ifindex]->ifm_flags = get_ifm_flags(rtm);
		break;
	default:
		/* should not reach here */
		log_debug("unknown rtmsg %d on %s",
		    type, if_indextoname(ifindex, ifname));
		return;
	}

	/* check if an interface flag is changed */
	if ((oldifflags & IFF_UP) != 0 &&	/* UP to DOWN */
	    (iflist[ifindex]->ifm_flags & IFF_UP) == 0) {
		log_info("interface %s becomes down. stop timer.",
		    rai->ifname);
		evtimer_del(&rai->timer.ev);
	} else if ((oldifflags & IFF_UP) == 0 && /* DOWN to UP */
	    (iflist[ifindex]->ifm_flags & IFF_UP) != 0) {
		log_info("interface %s becomes up. restart timer.",
		    rai->ifname);

		rai->initcounter = 0; /* reset the counter */
		rai->waiting = 0; /* XXX */
		ra_timer_update(rai);
		evtimer_add(&rai->timer.ev, &rai->timer.tm);
	}
}

void
sock_cb(int fd, short event, void *arg)
{
	ssize_t len;
	int *hlimp = NULL;
	struct icmp6_hdr *icp;
	int ifindex = 0;
	struct cmsghdr *cm;
	struct in6_pktinfo *pi = NULL;
	u_char ntopbuf[INET6_ADDRSTRLEN], ifnamebuf[IFNAMSIZ];
	struct in6_addr dst = in6addr_any;

	/*
	 * Get message. We reset msg_controllen since the field could
	 * be modified if we had received a message before setting
	 * receive options.
	 */
	rcvmhdr.msg_controllen = rcvcmsgbuflen;
	if ((len = recvmsg(sock, &rcvmhdr, 0)) < 0)
		return;

	/* extract optional information via Advanced API */
	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&rcvmhdr);
	     cm;
	     cm = (struct cmsghdr *)CMSG_NXTHDR(&rcvmhdr, cm)) {
		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_PKTINFO &&
		    cm->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
			pi = (struct in6_pktinfo *)(CMSG_DATA(cm));
			ifindex = pi->ipi6_ifindex;
			dst = pi->ipi6_addr;
		}
		if (cm->cmsg_level == IPPROTO_IPV6 &&
		    cm->cmsg_type == IPV6_HOPLIMIT &&
		    cm->cmsg_len == CMSG_LEN(sizeof(int)))
			hlimp = (int *)CMSG_DATA(cm);
	}
	if (ifindex == 0) {
		log_warnx("failed to get receiving interface");
		return;
	}
	if (hlimp == NULL) {
		log_warnx("failed to get receiving hop limit");
		return;
	}

	/*
	 * If we happen to receive data on an interface which is now down,
	 * just discard the data.
	 */
	if ((iflist[pi->ipi6_ifindex]->ifm_flags & IFF_UP) == 0) {
		log_info("received data on a disabled interface (%s)",
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		return;
	}

	if (len < sizeof(struct icmp6_hdr)) {
		log_warnx("packet size(%zd) is too short", len);
		return;
	}

	icp = (struct icmp6_hdr *)rcvmhdr.msg_iov[0].iov_base;

	switch (icp->icmp6_type) {
	case ND_ROUTER_SOLICIT:
		/*
		 * Message verification - RFC-2461 6.1.1
		 * XXX: these checks must be done in the kernel as well,
		 *      but we can't completely rely on them.
		 */
		if (*hlimp != 255) {
			log_info("RS with invalid hop limit(%d) "
			    "received from %s on %s",
			    *hlimp,
			    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
			    INET6_ADDRSTRLEN),
			    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
			return;
		}
		if (icp->icmp6_code) {
			log_info("RS with invalid ICMP6 code(%d) "
			    "received from %s on %s",
			    icp->icmp6_code,
			    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
			    INET6_ADDRSTRLEN),
			    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
			return;
		}
		if (len < sizeof(struct nd_router_solicit)) {
			log_info("RS from %s on %s too short (len = %zd)",
			    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
			    INET6_ADDRSTRLEN),
			    if_indextoname(pi->ipi6_ifindex, ifnamebuf), len);
			return;
		}
		rs_input(len, (struct nd_router_solicit *)icp, pi, &from);
		break;
	case ND_ROUTER_ADVERT:
		/*
		 * Message verification - RFC-2461 6.1.2
		 * XXX: there's a same dilemma as above...
		 */
		if (*hlimp != 255) {
			log_info("RA with invalid hop limit(%d) "
			    "received from %s on %s",
			    *hlimp,
			    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
			    INET6_ADDRSTRLEN),
			    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
			return;
		}
		if (icp->icmp6_code) {
			log_info("RA with invalid ICMP6 code(%d) "
			    "received from %s on %s",
			    icp->icmp6_code,
			    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
			    INET6_ADDRSTRLEN),
			    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
			return;
		}
		if (len < sizeof(struct nd_router_advert)) {
			log_info("RA from %s on %s too short (len = %zd)",
			    inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
			    INET6_ADDRSTRLEN),
			    if_indextoname(pi->ipi6_ifindex, ifnamebuf), len);
			return;
		}
		ra_input(len, (struct nd_router_advert *)icp, pi, &from);
		break;
	default:
		/*
		 * Note that this case is POSSIBLE, especially just
		 * after invocation of the daemon. This is because we
		 * could receive message after opening the socket and
		 * before setting ICMP6 type filter(see sock_open()).
		 */
		log_warnx("invalid icmp type(%d)", icp->icmp6_type);
	}
}

static void
rs_input(int len, struct nd_router_solicit *rs,
	 struct in6_pktinfo *pi, struct sockaddr_in6 *from)
{
	u_char ntopbuf[INET6_ADDRSTRLEN], ifnamebuf[IFNAMSIZ];
	union nd_opts ndopts;
	struct rainfo *ra;

	log_debug("RS received from %s on %s",
	    inet_ntop(AF_INET6, &from->sin6_addr,
		ntopbuf, INET6_ADDRSTRLEN),
	    if_indextoname(pi->ipi6_ifindex, ifnamebuf));

	/* ND option check */
	memset(&ndopts, 0, sizeof(ndopts));
	SLIST_INIT(&ndopts.nd_opts_list);
	if (nd6_options((struct nd_opt_hdr *)(rs + 1),
			len - sizeof(struct nd_router_solicit),
			&ndopts, NDOPT_FLAG_SRCLINKADDR)) {
		log_debug("ND option check failed for an RS from %s on %s",
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		return;
	}

	/*
	 * If the IP source address is the unspecified address, there
	 * must be no source link-layer address option in the message.
	 * (RFC-2461 6.1.1)
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&from->sin6_addr) &&
	    ndopts.nd_opts_src_lladdr) {
		log_warnx("RS from unspecified src on %s has a link-layer"
		       " address option",
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		goto done;
	}

	SLIST_FOREACH(ra, &ralist, entry) {
		if (pi->ipi6_ifindex == ra->ifindex)
			break;
	}
	if (ra == NULL) {
		log_info("RS received on non advertising interface(%s)",
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		goto done;
	}

	ra->rsinput++;		/* increment statistics */

	if (ndopts.nd_opts_src_lladdr)
		ra_output(ra, from);
	else {
		/*
		 * Decide whether to send RA according to the rate-limit
		 * consideration.
		 */
		long delay;	/* must not be greater than 1000000 */
		struct timeval interval, now, min_delay, tm_tmp, next,
		    computed;

		/*
		 * If there is already a waiting RS packet, don't
		 * update the timer.
		 */
		if (ra->waiting++)
			goto done;

		gettimeofday(&now, NULL);

		/*
		 * Compute a random delay. If the computed value
		 * corresponds to a time later than the time the next
		 * multicast RA is scheduled to be sent, ignore the random
		 * delay and send the advertisement at the
		 * already-scheduled time. RFC-2461 6.2.6
		 */
		delay = arc4random_uniform(MAX_RA_DELAY_TIME);
		interval.tv_sec = 0;
		interval.tv_usec = delay;
		/*
		 * Could happen if an interface has transitioned from DOWN to
		 * UP and we haven't re-enabled the timer yet.
		 */
		if (!evtimer_pending(&ra->timer.ev, &next))
			goto done;
		timeradd(&now, &interval, &computed);
		if (timercmp(&computed, &next, >)) {
			log_debug("random delay is larger than "
			    "the rest of normal timer");
			goto done;
		}

		/*
		 * If we sent a multicast Router Advertisement within
		 * the last MIN_DELAY_BETWEEN_RAS seconds, schedule
		 * the advertisement to be sent at a time corresponding to
		 * MIN_DELAY_BETWEEN_RAS plus the random value after the
		 * previous advertisement was sent.
		 */
		min_delay.tv_sec = MIN_DELAY_BETWEEN_RAS;
		min_delay.tv_usec = 0;
		timeradd(&ra->lastsent, &min_delay, &tm_tmp);
		if (timercmp(&computed, &tm_tmp, <))
			computed = tm_tmp;
		timersub(&computed, &now, &computed);
		evtimer_add(&ra->timer.ev, &computed);
	}

  done:
	free_ndopts(&ndopts);
}

static void
ra_input(int len, struct nd_router_advert *ra,
	 struct in6_pktinfo *pi, struct sockaddr_in6 *from)
{
	struct rainfo *rai;
	u_char ntopbuf[INET6_ADDRSTRLEN], ifnamebuf[IFNAMSIZ];
	union nd_opts ndopts;
	char *on_off[] = {"OFF", "ON"};
	u_int32_t reachabletime, retranstimer, mtu;
	int inconsistent = 0;

	log_debug("RA received from %s on %s",
	    inet_ntop(AF_INET6, &from->sin6_addr,
		ntopbuf, INET6_ADDRSTRLEN),
	    if_indextoname(pi->ipi6_ifindex, ifnamebuf));

	/* ND option check */
	memset(&ndopts, 0, sizeof(ndopts));
	SLIST_INIT(&ndopts.nd_opts_list);
	if (nd6_options((struct nd_opt_hdr *)(ra + 1),
			len - sizeof(struct nd_router_advert),
			&ndopts, NDOPT_FLAG_SRCLINKADDR | NDOPT_FLAG_PREFIXINFO
			| NDOPT_FLAG_MTU | NDOPT_FLAG_ROUTE_INFO
			| NDOPT_FLAG_RDNSS | NDOPT_FLAG_DNSSL)) {
		log_warnx("ND option check failed for an RA from %s on %s",
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		return;
	}

	/*
	 * RA consistency check according to RFC-2461 6.2.7
	 */
	if ((rai = if_indextorainfo(pi->ipi6_ifindex)) == NULL)
		goto done;	/* not our interface */

	rai->rainput++;		/* increment statistics */

	/* Cur Hop Limit value */
	if (ra->nd_ra_curhoplimit && rai->hoplimit &&
	    ra->nd_ra_curhoplimit != rai->hoplimit) {
		log_info("CurHopLimit inconsistent on %s:  %d from %s,"
		    " %d from us",
		    rai->ifname,
		    ra->nd_ra_curhoplimit,
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    rai->hoplimit);
		inconsistent++;
	}
	/* M flag */
	if ((ra->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED) !=
	    rai->managedflg) {
		log_info("M flag inconsistent on %s: %s from %s, %s from us",
		    rai->ifname, on_off[rai->managedflg ? 0 : 1],
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    on_off[rai->managedflg ? 1 : 0]);
		inconsistent++;
	}
	/* O flag */
	if ((ra->nd_ra_flags_reserved & ND_RA_FLAG_OTHER) !=
	    rai->otherflg) {
		log_info("O flag inconsistent on %s: %s from %s, %s from us",
		    rai->ifname, on_off[rai->otherflg ? 0 : 1],
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    on_off[rai->otherflg ? 1 : 0]);
		inconsistent++;
	}
	/* Reachable Time */
	reachabletime = ntohl(ra->nd_ra_reachable);
	if (reachabletime && rai->reachabletime &&
	    reachabletime != rai->reachabletime) {
		log_info("ReachableTime inconsistent on %s:"
		    " %d from %s, %d from us",
		    rai->ifname, reachabletime,
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    rai->reachabletime);
		inconsistent++;
	}
	/* Retrans Timer */
	retranstimer = ntohl(ra->nd_ra_retransmit);
	if (retranstimer && rai->retranstimer &&
	    retranstimer != rai->retranstimer) {
		log_info("RetransTimer inconsistent on %s:"
		    " %d from %s, %d from us",
		    rai->ifname, retranstimer,
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    rai->retranstimer);
		inconsistent++;
	}
	/* Values in the MTU options */
	if (ndopts.nd_opts_mtu) {
		mtu = ntohl(ndopts.nd_opts_mtu->nd_opt_mtu_mtu);
		if (mtu && rai->linkmtu && mtu != rai->linkmtu) {
			log_info("MTU option value inconsistent on %s:"
			    " %d from %s, %d from us",
			    rai->ifname, mtu,
			    inet_ntop(AF_INET6, &from->sin6_addr,
				ntopbuf, INET6_ADDRSTRLEN),
			    rai->linkmtu);
			inconsistent++;
		}
	}
	/* Preferred and Valid Lifetimes for prefixes */
	{
		struct nd_opt 	*optp;

		if (ndopts.nd_opts_pi)
			if (prefix_check(ndopts.nd_opts_pi, rai, from))
				inconsistent++;
		SLIST_FOREACH(optp, &ndopts.nd_opts_list, entry) {
			if (prefix_check((struct nd_opt_prefix_info *)optp->opt,
					 rai, from))
				inconsistent++;
		}
	}

	if (inconsistent)
		rai->rainconsistent++;

  done:
	free_ndopts(&ndopts);
}

/* return a non-zero value if the received prefix is inconsistent with ours */
static int
prefix_check(struct nd_opt_prefix_info *pinfo,
	     struct rainfo *rai, struct sockaddr_in6 *from)
{
	time_t preferred_time, valid_time;
	struct prefix *pp;
	int inconsistent = 0;
	u_char ntopbuf[INET6_ADDRSTRLEN], prefixbuf[INET6_ADDRSTRLEN];
	struct timeval now;

	/*
	 * log if the advertised prefix has link-local scope(sanity check?)
	 */
	if (IN6_IS_ADDR_LINKLOCAL(&pinfo->nd_opt_pi_prefix))
		log_info("link-local prefix %s/%d is advertised "
		    "from %s on %s",
		    inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
			prefixbuf, INET6_ADDRSTRLEN),
		    pinfo->nd_opt_pi_prefix_len,
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    rai->ifname);

	if ((pp = find_prefix(rai, &pinfo->nd_opt_pi_prefix,
			      pinfo->nd_opt_pi_prefix_len)) == NULL) {
		log_info("prefix %s/%d from %s on %s is not in our list",
		    inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
			prefixbuf, INET6_ADDRSTRLEN),
		    pinfo->nd_opt_pi_prefix_len,
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    rai->ifname);
		return(0);
	}

	preferred_time = ntohl(pinfo->nd_opt_pi_preferred_time);
	if (pp->pltimeexpire) {
		/*
		 * The lifetime is decremented in real time, so we should
		 * compare the expiration time.
		 * (RFC 2461 Section 6.2.7.)
		 * XXX: can we really expect that all routers on the link
		 * have synchronized clocks?
		 */
		gettimeofday(&now, NULL);
		preferred_time += now.tv_sec;

		if (rai->clockskew &&
		    llabs(preferred_time - pp->pltimeexpire) > rai->clockskew) {
			log_info("preferred lifetime for %s/%d"
			    " (decr. in real time) inconsistent on %s:"
			    " %lld from %s, %lld from us",
			    inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
				prefixbuf, INET6_ADDRSTRLEN),
			    pinfo->nd_opt_pi_prefix_len,
			    rai->ifname, (long long)preferred_time,
			    inet_ntop(AF_INET6, &from->sin6_addr,
				ntopbuf, INET6_ADDRSTRLEN),
			    (long long)pp->pltimeexpire);
			inconsistent++;
		}
	} else if (preferred_time != pp->preflifetime)
		log_info("preferred lifetime for %s/%d"
		    " inconsistent on %s:"
		    " %lld from %s, %d from us",
		    inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
			prefixbuf, INET6_ADDRSTRLEN),
		    pinfo->nd_opt_pi_prefix_len,
		    rai->ifname, (long long)preferred_time,
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    pp->preflifetime);

	valid_time = ntohl(pinfo->nd_opt_pi_valid_time);
	if (pp->vltimeexpire) {
		gettimeofday(&now, NULL);
		valid_time += now.tv_sec;

		if (rai->clockskew &&
		    llabs(valid_time - pp->vltimeexpire) > rai->clockskew) {
			log_info("valid lifetime for %s/%d"
			    " (decr. in real time) inconsistent on %s:"
			    " %lld from %s, %lld from us",
			    inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
				prefixbuf, INET6_ADDRSTRLEN),
			    pinfo->nd_opt_pi_prefix_len,
			    rai->ifname, (long long)preferred_time,
			    inet_ntop(AF_INET6, &from->sin6_addr,
				ntopbuf, INET6_ADDRSTRLEN),
			    (long long)pp->vltimeexpire);
			inconsistent++;
		}
	} else if (valid_time != pp->validlifetime) {
		log_info("valid lifetime for %s/%d"
		    " inconsistent on %s:"
		    " %lld from %s, %d from us",
		    inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
			prefixbuf, INET6_ADDRSTRLEN),
		    pinfo->nd_opt_pi_prefix_len,
		    rai->ifname, (long long)valid_time,
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf, INET6_ADDRSTRLEN),
		    pp->validlifetime);
		inconsistent++;
	}

	return(inconsistent);
}

struct prefix *
find_prefix(struct rainfo *rai, struct in6_addr *prefix, int plen)
{
	struct prefix *pp;
	int bytelen, bitlen;
	u_char bitmask;

	TAILQ_FOREACH(pp, &rai->prefixes, entry) {
		if (plen != pp->prefixlen)
			continue;
		bytelen = plen / 8;
		bitlen = plen % 8;
		bitmask = 0xff << (8 - bitlen);
		if (memcmp(prefix, &pp->prefix, bytelen))
			continue;
		if (bitlen == 0 ||
		    ((prefix->s6_addr[bytelen] & bitmask) ==
		     (pp->prefix.s6_addr[bytelen] & bitmask))) {
			return(pp);
		}
	}

	return(NULL);
}

static int
nd6_options(struct nd_opt_hdr *hdr, int limit,
	    union nd_opts *ndopts, u_int32_t optflags)
{
	int optlen = 0;

	for (; limit > 0; limit -= optlen) {
		if (limit < sizeof(struct nd_opt_hdr)) {
			log_info("short option header");
			goto bad;
		}

		hdr = (struct nd_opt_hdr *)((char *)hdr + optlen);
		if (hdr->nd_opt_len == 0) {
			log_warnx("bad ND option length(0) (type = %d)",
			    hdr->nd_opt_type);
			goto bad;
		}
		optlen = hdr->nd_opt_len << 3;
		if (optlen > limit) {
			log_info("short option");
			goto bad;
		}

		if (hdr->nd_opt_type > ND_OPT_MTU &&
		    hdr->nd_opt_type != ND_OPT_ROUTE_INFO &&
		    hdr->nd_opt_type != ND_OPT_RDNSS &&
		    hdr->nd_opt_type != ND_OPT_DNSSL)
		{
			log_info("unknown ND option(type %d)",
			    hdr->nd_opt_type);
			continue;
		}

		if ((ndopt_flags[hdr->nd_opt_type] & optflags) == 0) {
			log_info("unexpected ND option(type %d)",
			    hdr->nd_opt_type);
			continue;
		}

		/*
		 * Option length check.  Do it here for all fixed-length
		 * options.
		 */
		if ((hdr->nd_opt_type == ND_OPT_RDNSS && (optlen < 24 ||
		    ((optlen - sizeof(struct nd_opt_rdnss)) % 16 != 0))) ||
		    (hdr->nd_opt_type == ND_OPT_DNSSL && optlen < 16) ||
		    (hdr->nd_opt_type == ND_OPT_MTU &&
		    (optlen != sizeof(struct nd_opt_mtu))) ||
		    ((hdr->nd_opt_type == ND_OPT_PREFIX_INFORMATION &&
		    optlen != sizeof(struct nd_opt_prefix_info)))) {
			log_info("invalid option length");
			continue;
		}

		switch (hdr->nd_opt_type) {
		case ND_OPT_SOURCE_LINKADDR:
			ndopts->nd_opt_array[hdr->nd_opt_type] = hdr;
			break;
		case ND_OPT_TARGET_LINKADDR:
		case ND_OPT_REDIRECTED_HEADER:
		case ND_OPT_ROUTE_INFO:
		case ND_OPT_RDNSS:
		case ND_OPT_DNSSL:
			break;	/* we don't care about these options */
		case ND_OPT_MTU:
			if (ndopts->nd_opt_array[hdr->nd_opt_type]) {
				log_info("duplicated ND option (type = %d)",
				    hdr->nd_opt_type);
			}
			ndopts->nd_opt_array[hdr->nd_opt_type] = hdr;
			break;
		case ND_OPT_PREFIX_INFORMATION:
		{
			struct nd_opt	*pfx;

			if (ndopts->nd_opts_pi == 0) {
				ndopts->nd_opts_pi =
				    (struct nd_opt_prefix_info *)hdr;
				continue;
			}
			if ((pfx = malloc(sizeof(*pfx))) == NULL) {
				log_warn(NULL);
				goto bad;
			}

			pfx->opt = hdr;
			SLIST_INSERT_HEAD(&ndopts->nd_opts_list, pfx, entry);

			break;
		}
		default:	/* impossible */
			break;
		}
	}

	return(0);

  bad:
	free_ndopts(ndopts);

	return(-1);
}

static void
free_ndopts(union nd_opts *ndopts)
{
	struct nd_opt *opt;

	while (!SLIST_EMPTY(&ndopts->nd_opts_list)) {
		opt = SLIST_FIRST(&ndopts->nd_opts_list);
		SLIST_REMOVE_HEAD(&ndopts->nd_opts_list, entry);
		free(opt);
	}
}

static void
sock_open(void)
{
	struct rainfo	*ra;
	struct icmp6_filter filt;
	struct ipv6_mreq mreq;
	int on;
	/* XXX: should be max MTU attached to the node */
	static u_char answer[1500];

	rcvcmsgbuflen = CMSG_SPACE(sizeof(struct in6_pktinfo)) +
	    CMSG_SPACE(sizeof(int));
	rcvcmsgbuf = malloc(rcvcmsgbuflen);
	if (rcvcmsgbuf == NULL)
		fatal(NULL);

	sndcmsgbuflen = CMSG_SPACE(sizeof(struct in6_pktinfo)) +
	    CMSG_SPACE(sizeof(int));
	sndcmsgbuf = malloc(sndcmsgbuflen);
	if (sndcmsgbuf == NULL)
		fatal(NULL);

	if ((sock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0)
		fatal("socket");

	/* specify to tell receiving interface */
	on = 1;
	if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on, sizeof(on))
	    < 0)
		fatal("IPV6_RECVPKTINFO");

	on = 1;
	/* specify to tell value of hoplimit field of received IP6 hdr */
	if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on, sizeof(on))
	    < 0)
		fatal("IPV6_RECVHOPLIMIT");

	ICMP6_FILTER_SETBLOCKALL(&filt);
	ICMP6_FILTER_SETPASS(ND_ROUTER_SOLICIT, &filt);
	ICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &filt);
	if (setsockopt(sock, IPPROTO_ICMPV6, ICMP6_FILTER, &filt, sizeof(filt))
	    < 0)
		fatal("ICMP6_FILTER");

	/*
	 * join all routers multicast address on each advertising interface.
	 */
	if (inet_pton(AF_INET6, ALLROUTERS_LINK, &mreq.ipv6mr_multiaddr.s6_addr)
	    != 1)
		fatal("inet_pton");
	SLIST_FOREACH(ra, &ralist, entry) {
		mreq.ipv6mr_interface = ra->ifindex;
		if (setsockopt(sock, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq,
		    sizeof(mreq)) < 0)
			fatal("IPV6_JOIN_GROUP(link) on %s", ra->ifname);
	}

	/* initialize msghdr for receiving packets */
	rcviov[0].iov_base = answer;
	rcviov[0].iov_len = sizeof(answer);
	rcvmhdr.msg_name = &from;
	rcvmhdr.msg_namelen = sizeof(from);
	rcvmhdr.msg_iov = rcviov;
	rcvmhdr.msg_iovlen = 1;
	rcvmhdr.msg_control = rcvcmsgbuf;
	rcvmhdr.msg_controllen = rcvcmsgbuflen;

	/* initialize msghdr for sending packets */
	sndmhdr.msg_namelen = sizeof(struct sockaddr_in6);
	sndmhdr.msg_iov = sndiov;
	sndmhdr.msg_iovlen = 1;
	sndmhdr.msg_control = sndcmsgbuf;
	sndmhdr.msg_controllen = sndcmsgbuflen;
}

/* open a routing socket to watch the routing table */
static void
rtsock_open(void)
{
	unsigned int rtfilter;

	if ((rtsock = socket(PF_ROUTE, SOCK_RAW, 0)) < 0)
		fatal("socket");

	rtfilter =
	    ROUTE_FILTER(RTM_ADD) |
	    ROUTE_FILTER(RTM_DELETE) |
	    ROUTE_FILTER(RTM_NEWADDR) |
	    ROUTE_FILTER(RTM_DELADDR) |
	    ROUTE_FILTER(RTM_IFINFO);

	if (setsockopt(rtsock, PF_ROUTE, ROUTE_MSGFILTER,
	    &rtfilter, sizeof(rtfilter)) == -1)
		fatal("setsockopt(ROUTE_MSGFILTER)");

	rtsockbuflen = 2048;
	rtsockbuf = malloc(rtsockbuflen);
	if (rtsockbuf == NULL)
		fatal(NULL);
}

static struct rainfo *
if_indextorainfo(int index)
{
	struct rainfo *rai;

	SLIST_FOREACH(rai, &ralist, entry) {
		if (rai->ifindex == index)
			return(rai);
	}

	return(NULL);		/* search failed */
}

static void
ra_output(struct rainfo *rainfo, struct sockaddr_in6 *to)
{
	struct cmsghdr *cm;
	struct in6_pktinfo *pi;
	ssize_t len;

	if ((iflist[rainfo->ifindex]->ifm_flags & IFF_UP) == 0) {
		log_debug("%s is not up, skip sending RA", rainfo->ifname);
		return;
	}

	make_packet(rainfo);	/* XXX: inefficient */

	sndmhdr.msg_name = to;
	sndmhdr.msg_iov[0].iov_base = rainfo->ra_data;
	sndmhdr.msg_iov[0].iov_len = rainfo->ra_datalen;

	cm = CMSG_FIRSTHDR(&sndmhdr);
	/* specify the outgoing interface */
	cm->cmsg_level = IPPROTO_IPV6;
	cm->cmsg_type = IPV6_PKTINFO;
	cm->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
	pi = (struct in6_pktinfo *)CMSG_DATA(cm);
	memset(&pi->ipi6_addr, 0, sizeof(pi->ipi6_addr));	/*XXX*/
	pi->ipi6_ifindex = rainfo->ifindex;

	/* specify the hop limit of the packet */
	{
		int hoplimit = 255;

		cm = CMSG_NXTHDR(&sndmhdr, cm);
		cm->cmsg_level = IPPROTO_IPV6;
		cm->cmsg_type = IPV6_HOPLIMIT;
		cm->cmsg_len = CMSG_LEN(sizeof(int));
		memcpy(CMSG_DATA(cm), &hoplimit, sizeof(int));
	}

	log_debug("send RA on %s, # of waitings = %u",
	    rainfo->ifname, rainfo->waiting);

	len = sendmsg(sock, &sndmhdr, 0);
	if (len < 0) {
		log_warn("sendmsg on %s", rainfo->ifname);
		return;
	}

	rainfo->raoutput++;

	if (memcmp(to, &sin6_allnodes, sizeof(sin6_allnodes)) == 0) {
		/* update counter */
		if (rainfo->initcounter < MAX_INITIAL_RTR_ADVERTISEMENTS)
			rainfo->initcounter++;
		/* update timestamp */
		gettimeofday(&rainfo->lastsent, NULL);

		/* reset waiting counter */
		rainfo->waiting = 0;
	}
}

/* process RA timer */
void
timer_cb(int fd, short event, void *data)
{
	struct rainfo *rai = (struct rainfo *)data;

	log_debug("RA timer on %s is expired", rai->ifname);

	ra_output(rai, &sin6_allnodes);

	ra_timer_update(rai);
	evtimer_add(&rai->timer.ev, &rai->timer.tm);
}

/* update RA timer */
void
ra_timer_update(struct rainfo *rai)
{
	struct timeval *tm = &rai->timer.tm;
	long interval;

	/*
	 * Whenever a multicast advertisement is sent from an interface,
	 * the timer is reset to a uniformly-distributed random value
	 * between the interface's configured MinRtrAdvInterval and
	 * MaxRtrAdvInterval (RFC2461 6.2.4).
	 */
	interval = rai->mininterval;
	interval += arc4random_uniform(rai->maxinterval - rai->mininterval);

	/*
	 * For the first few advertisements (up to
	 * MAX_INITIAL_RTR_ADVERTISEMENTS), if the randomly chosen interval
	 * is greater than MAX_INITIAL_RTR_ADVERT_INTERVAL, the timer
	 * SHOULD be set to MAX_INITIAL_RTR_ADVERT_INTERVAL instead.
	 * (RFC-2461 6.2.4)
	 */
	if (rai->initcounter < MAX_INITIAL_RTR_ADVERTISEMENTS &&
	    interval > MAX_INITIAL_RTR_ADVERT_INTERVAL)
		interval = MAX_INITIAL_RTR_ADVERT_INTERVAL;

	tm->tv_sec = interval;
	tm->tv_usec = 0;

	log_debug("RA timer on %s set to %lld.%lds", rai->ifname,
	    (long long)tm->tv_sec, tm->tv_usec);
}

int
rdaemon(int devnull)
{
	if (devnull == -1) {
		errno = EBADF;
		return (-1);
	}
	if (fcntl(devnull, F_GETFL) == -1)
		return (-1);

	switch (fork()) {
	case -1:
		return (-1);
	case 0:
		break;
	default:
		_exit(0);
	}

	if (setsid() == -1)
		return (-1);

	(void)dup2(devnull, STDIN_FILENO);
	(void)dup2(devnull, STDOUT_FILENO);
	(void)dup2(devnull, STDERR_FILENO);
	if (devnull > 2)
		(void)close(devnull);

	return (0);
}
@


1.90
log
@The impossibility has been impossible since an impossible long
time. And indeed it is impossible to arrive here with something other
than a ND_OPT_PREFIX_INFORMATION. Remove #if 0'ed block.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.89 2017/08/12 07:38:26 florian Exp $	*/
d311 1
a311 1
	char *next;
d322 2
a323 2
	next = rtsockbuf;
	if (validate_msg(next) == -1)
d326 1
a326 1
	type = rtmsg_type(next);
d330 1
a330 1
		ifindex = get_rtm_ifindex(next);
d334 1
a334 1
		ifindex = get_ifam_ifindex(next);
d337 1
a337 1
		ifindex = get_ifm_ifindex(next);
d363 2
a364 2
		addr = get_addr(next);
		plen = get_prefixlen(next);
d392 2
a393 2
		addr = get_addr(next);
		plen = get_prefixlen(next);
d420 1
a420 1
		iflist[ifindex]->ifm_flags = get_ifm_flags(next);
@


1.89
log
@No need to constantly re-open a socket. Just open it up front and keep
it around.
OK jca
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.88 2017/08/10 19:07:14 jca Exp $	*/
a839 5

#if 0				/* impossible */
	if (pinfo->nd_opt_pi_type != ND_OPT_PREFIX_INFORMATION)
		return(0);
#endif
@


1.88
log
@No need to handle multiple routing messages here.

route(4) sockets only ever ship a single routing message per read(2)
call, so simplify this.  Mostly mechanical diff for now, some further
cleanups will follow.

ok rob@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.87 2017/07/12 06:11:07 florian Exp $	*/
d82 1
d207 3
@


1.87
log
@replace
log_warnx("foo");
exit(1);
with
fatalx("foo);
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.86 2017/06/09 13:31:03 florian Exp $	*/
d306 2
a307 3
	int n, type, ifindex = 0, plen;
	size_t len;
	char *next, *lim;
d317 23
a339 13
	if (n > rtmsg_len(rtsockbuf)) {
		/*
		 * This usually won't happen for messages received on
		 * a routing socket.
		 */
		log_debug("received data length is larger than "
		    "1st routing message len. multiple messages? "
		    "read %d bytes, but 1st msg len = %d",
		    n, rtmsg_len(rtsockbuf));
#if 0
		/* adjust length */
		n = rtmsg_len(rtsockbuf);
#endif
d342 7
a348 5
	lim = rtsockbuf + n;
	for (next = rtsockbuf; next < lim; next += len) {
		int oldifflags;

		next = get_next_msg(next, lim, &len);
d350 16
a365 1
		if (len == 0)
d367 9
a375 5
		type = rtmsg_type(next);
		switch (type) {
		case RTM_ADD:
		case RTM_DELETE:
			ifindex = get_rtm_ifindex(next);
d377 18
a394 3
		case RTM_NEWADDR:
		case RTM_DELADDR:
			ifindex = get_ifam_ifindex(next);
a395 15
		case RTM_IFINFO:
			ifindex = get_ifm_ifindex(next);
			break;
		default:
			/* should not reach here */
			log_debug("unknown rtmsg %d on %s",
			    type, if_indextoname(ifindex, ifname));
			continue;
		}

		if ((rai = if_indextorainfo(ifindex)) == NULL) {
			log_debug("route changed on "
			    "non advertising interface(%s)",
			    if_indextoname(ifindex, ifname));
			continue;
d397 8
a404 69
		oldifflags = iflist[ifindex]->ifm_flags;

		switch (type) {
		case RTM_ADD:
			/* init ifflags because it may have changed */
			iflist[ifindex]->ifm_flags =
			    if_getflags(ifindex, iflist[ifindex]->ifm_flags);

			if (sflag)
				break;	/* we aren't interested in prefixes  */

			addr = get_addr(next);
			plen = get_prefixlen(next);
			/* sanity check for plen */
			/* as RFC2373, prefixlen is at least 4 */
			if (plen < 4 || plen > 127) {
				log_info("new interface route's"
				    " plen %d is invalid for a prefix", plen);
				break;
			}
			prefix = find_prefix(rai, addr, plen);
			if (prefix) {
				log_debug("new prefix(%s/%d) "
				    "added on %s, "
				    "but it was already in list",
				    inet_ntop(AF_INET6, addr,
				        addrbuf, INET6_ADDRSTRLEN),
				    plen, rai->ifname);
				break;
			}
			make_prefix(rai, ifindex, addr, plen);
			break;
		case RTM_DELETE:
			/* init ifflags because it may have changed */
			iflist[ifindex]->ifm_flags =
			    if_getflags(ifindex, iflist[ifindex]->ifm_flags);

			if (sflag)
				break;

			addr = get_addr(next);
			plen = get_prefixlen(next);
			/* sanity check for plen */
			/* as RFC2373, prefixlen is at least 4 */
			if (plen < 4 || plen > 127) {
				log_info("deleted interface route's "
				    "plen %d is invalid for a prefix", plen);
				break;
			}
			prefix = find_prefix(rai, addr, plen);
			if (prefix == NULL) {
				log_debug("prefix(%s/%d) was "
				    "deleted on %s, "
				    "but it was not in list",
				    inet_ntop(AF_INET6, addr,
				        addrbuf, INET6_ADDRSTRLEN),
				    plen, rai->ifname);
				break;
			}
			delete_prefix(rai, prefix);
			break;
		case RTM_NEWADDR:
		case RTM_DELADDR:
			/* init ifflags because it may have changed */
			iflist[ifindex]->ifm_flags =
			    if_getflags(ifindex, iflist[ifindex]->ifm_flags);
			break;
		case RTM_IFINFO:
			iflist[ifindex]->ifm_flags = get_ifm_flags(next);
a405 5
		default:
			/* should not reach here */
			log_debug("unknown rtmsg %d on %s",
			    type, if_indextoname(ifindex, ifname));
			return;
d407 17
d425 15
a439 16
		/* check if an interface flag is changed */
		if ((oldifflags & IFF_UP) != 0 &&	/* UP to DOWN */
		    (iflist[ifindex]->ifm_flags & IFF_UP) == 0) {
			log_info("interface %s becomes down. stop timer.",
			    rai->ifname);
			evtimer_del(&rai->timer.ev);
		} else if ((oldifflags & IFF_UP) == 0 && /* DOWN to UP */
			 (iflist[ifindex]->ifm_flags & IFF_UP) != 0) {
			log_info("interface %s becomes up. restart timer.",
			    rai->ifname);

			rai->initcounter = 0; /* reset the counter */
			rai->waiting = 0; /* XXX */
			ra_timer_update(rai);
			evtimer_add(&rai->timer.ev, &rai->timer.tm);
		}
@


1.86
log
@If we receive a router solicitation with a source link-layer address
option respond with a unicast advertisement. This improves air time on
wireless networks and reduces energy consumption on battery powered
devices. For details see RFC 7772 "Reducing Energy Consumption of
Router Advertisements" aka BCP 202.
Input & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.85 2017/04/05 14:50:05 jca Exp $	*/
d1155 2
a1156 4
		    sizeof(mreq)) < 0) {
			log_warn("IPV6_JOIN_GROUP(link) on %s", ra->ifname);
			exit(1);
		}
@


1.85
log
@Unify variables used for recvmsg/sendmsg

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.83 2017/01/20 23:29:58 benno Exp $	*/
d144 1
a144 1
static void ra_output(struct rainfo *);
d296 1
a296 1
			ra_output(ra);
d654 7
a660 5
	/*
	 * Decide whether to send RA according to the rate-limit
	 * consideration.
	 */
	{
d1043 2
d1219 1
a1219 1
ra_output(struct rainfo *rainfo)
d1232 1
a1232 1
	sndmhdr.msg_name = &sin6_allnodes;
a1264 3
	/* update counter */
	if (rainfo->initcounter < MAX_INITIAL_RTR_ADVERTISEMENTS)
		rainfo->initcounter++;
d1267 6
a1272 2
	/* update timestamp */
	gettimeofday(&rainfo->lastsent, NULL);
d1274 3
a1276 2
	/* reset waiting counter */
	rainfo->waiting = 0;
d1287 1
a1287 1
	ra_output(rai);
@


1.84
log
@sendmsg returns a signed value, fix error check

ok millert@@ deraadt@@
@
text
@d466 1
a466 1
	int i;
d481 1
a481 1
	if ((i = recvmsg(sock, &rcvmhdr, 0)) < 0)
d519 2
a520 2
	if (i < sizeof(struct icmp6_hdr)) {
		log_warnx("packet size(%d) is too short", i);
d551 2
a552 3
		if (i < sizeof(struct nd_router_solicit)) {
			log_info("RS from %s on %s does not have enough "
			    "length (len = %d)",
d555 1
a555 1
			    if_indextoname(pi->ipi6_ifindex, ifnamebuf), i);
d558 1
a558 1
		rs_input(i, (struct nd_router_solicit *)icp, pi, &from);
d583 2
a584 3
		if (i < sizeof(struct nd_router_advert)) {
			log_info("RA from %s on %s does not have enough "
			    "length (len = %d)",
d587 1
a587 1
			    if_indextoname(pi->ipi6_ifindex, ifnamebuf), i);
d590 1
a590 1
		ra_input(i, (struct nd_router_advert *)icp, pi, &from);
d1256 1
a1256 2

	if (len < 0)
d1258 2
@


1.83
log
@work on making log.c similar in all daemons:
reduce the (mostly whitespace) differences so that log.c's can be
diffed easily.
need to set verbose in main() when option -d is used.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.82 2016/09/26 17:15:19 jca Exp $	*/
d1221 1
a1221 1
	size_t len;
@


1.82
log
@Exit early from rdaemon() is the passed fd is invalid.

fd == -1 check suggested by deraadt@@, ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.81 2016/09/21 18:54:24 jca Exp $	*/
d166 1
d196 2
a197 1
	}
@


1.81
log
@Use a properly aligned buffer (malloc'd, not on stack) to get routing messages.

This fixes rtadvd on (at least) armv7.  Problem reported and fix tested
by Martin Brandenburg.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.80 2016/09/21 18:51:05 jca Exp $	*/
d1323 6
@


1.80
log
@Use the correct local variable to get address & prefixlen in routing messages

This currently has no effect because route sockets are datagram
(PR_ATOMIC) sockets, so we only get one message at a time.  This means
that the parsing code could be simplified.  route(4) sockets cluebat
from claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.79 2016/09/15 16:16:03 jca Exp $	*/
d76 2
d306 1
a306 1
	char msg[2048], *next, *lim;
d313 1
a313 1
	n = read(rtsock, msg, sizeof(msg));
d315 2
a316 2
	    "(type = %d, len = %d)", rtmsg_type(msg), n);
	if (n > rtmsg_len(msg)) {
d324 1
a324 1
		    n, rtmsg_len(msg));
d327 1
a327 1
		n = rtmsg_len(msg);
d331 2
a332 2
	lim = msg + n;
	for (next = msg; next < lim; next += len) {
d1194 5
@


1.79
log
@Go in the background later, using rdaemon().

rdaemon() works like daemon(3) but requires its caller to pre-open
/dev/null.  This makes it possible to go in the background after
a chroot(2), allowing for more error checking.  The pattern is basically
- open /dev/null
- chroot
- privdrop
- rdaemon

"design" initialy discussed with semarie@@ a while ago, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.78 2016/09/03 16:57:29 jca Exp $	*/
d374 2
a375 2
			addr = get_addr(msg);
			plen = get_prefixlen(msg);
d403 2
a404 2
			addr = get_addr(msg);
			plen = get_prefixlen(msg);
@


1.78
log
@typos
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.77 2016/08/20 15:10:18 jca Exp $	*/
d58 2
d144 1
d157 1
d189 6
a208 6
	if (conffile != NULL)
		log_init(dflag);

	if (!dflag)
		daemon(1, 0);

d225 8
d1311 25
@


1.77
log
@Tweak timer debug output.

-RA timer on em0 is set to 16:0
+RA timer on em0 is set to 16.0s
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.76 2016/08/02 17:00:09 jca Exp $	*/
d847 1
a847 1
	 * log if the adveritsed prefix has link-local scope(sanity check?)
d898 1
a898 1
		log_info("prefeerred lifetime for %s/%d"
@


1.76
log
@Move to libevent; ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.75 2016/06/30 10:17:18 florian Exp $	*/
d1297 1
a1297 1
	log_debug("RA timer on %s is set to %lld:%ld", rai->ifname,
@


1.75
log
@Prevent NULL deref, pointed out by llvm's scan-build.
OK jca, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.74 2016/06/29 14:19:38 jca Exp $	*/
a51 1
#include <poll.h>
d54 1
a60 1
#include "timer.h"
a70 2
volatile sig_atomic_t do_dump;
volatile sig_atomic_t do_die;
a128 2
static void set_die(int);
static __dead void die(void);
a130 1
static void rtadvd_input(void);
a140 2
static void rtmsg_input(void);
static void rtadvd_set_dump(int);
d143 6
a151 2
	struct pollfd pfd[2];
	struct timeval *timeout;
d153 6
a158 1
	int i, ch, npfd, tmout;
d224 18
a241 50
	npfd = 1;
	pfd[0].fd = sock;
	pfd[0].events = POLLIN;
	if (rtsock >= 0) {
		pfd[1].fd = rtsock;
		pfd[1].events = POLLIN;
		npfd++;
	}

	signal(SIGTERM, set_die);
	signal(SIGUSR1, rtadvd_set_dump);

	while (1) {
		if (do_dump) {	/* SIGUSR1 */
			do_dump = 0;
			rtadvd_dump();
		}

		if (do_die) {
			die();
			/*NOTREACHED*/
		}

		/* timer expiration check and reset the timer */
		timeout = rtadvd_check_timer();

		if (timeout != NULL) {
			tmout = timeout->tv_sec * 1000 + timeout->tv_usec /
			    1000;
			log_debug("set timer to %lld.%ld. waiting for "
			    "inputs or timeout",
			    (long long)timeout->tv_sec,
			    timeout->tv_usec);
		} else {
			tmout = INFTIM;
			log_debug("there's no timer. waiting for inputs");
		}

		if ((i = poll(pfd, npfd, tmout)) < 0) {
			/* EINTR would occur upon SIGUSR1 for status dump */
			if (errno != EINTR)
				log_warn("poll");
			continue;
		}
		if (i == 0)	/* timeout */
			continue;
		if (rtsock != -1 && (pfd[1].revents & POLLIN))
			rtmsg_input();
		if (pfd[0].revents & POLLIN)
			rtadvd_input();
d243 6
a248 1
	exit(0);		/* NOTREACHED */
d260 1
a260 1
rtadvd_set_dump(int signo)
d262 1
a262 1
	do_dump = 1;
d266 1
a266 7
set_die(int signo)
{
	do_die = 1;
}

static void
die(void)
d288 1
a288 1
rtmsg_input(void)
d433 1
a433 1
			rtadvd_remove_timer(&rai->timer);
d441 2
a442 4
			rai->timer = rtadvd_add_timer(ra_timeout,
			    ra_timer_update, rai, rai);
			ra_timer_update(rai, &rai->timer->tm);
			rtadvd_set_timer(&rai->timer->tm, rai->timer);
d448 1
a448 1
rtadvd_input(void)
d646 2
a647 1
		struct timeval interval, now, min_delay, tm_tmp, *rest;
d656 2
d668 8
a675 2
		rest = rtadvd_timer_rest(ra->timer);
		if (timercmp(rest, &interval, <)) {
d678 1
a678 1
			interval = *rest;
a687 2
		gettimeofday(&now, NULL);
		timersub(&now, &ra->lastsent, &tm_tmp);
d690 5
a694 6
		if (timercmp(&tm_tmp, &min_delay, <)) {
			timersub(&min_delay, &tm_tmp, &min_delay);
			timeradd(&min_delay, &interval, &interval);
		}
		rtadvd_set_timer(&interval, ra->timer);
		goto done;
d1255 1
a1255 1
ra_timeout(void *data)
d1262 3
d1269 1
a1269 1
ra_timer_update(void *data, struct timeval *tm)
d1271 1
a1271 1
	struct rainfo *rai = (struct rainfo *)data;
@


1.74
log
@Spring cleanup

- pointless casts, kill caddr_t or replace it with char *
- signed counters
- simplify if_getmtu, only one method is needed and SIOCGIFMTU is the
  cheapest
- we no longer have drivers for IFT_FDDI
- hide details of iflist management
- if (dflag) log_debug -> log_debug
- dead code and comments
- etc etc

Input from and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.73 2016/03/01 20:51:05 jca Exp $	*/
d157 1
a157 1
	int i, ch, npfd;
d249 3
a251 1
		if (timeout != NULL)
d256 2
a257 1
		else
d259 1
d261 1
a261 2
		if ((i = poll(pfd, npfd,
		    timeout->tv_sec * 1000 + timeout->tv_usec / 1000)) < 0) {
@


1.73
log
@fatal("malloc") -> fatal(NULL)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.72 2016/03/01 12:52:43 jca Exp $	*/
a40 1
#include <net/if_dl.h>
d149 1
d206 1
a206 1
	if (sflag == 0) {
a207 1
	}
d301 1
a301 2
	if (dflag)
		log_debug("cease to be an advertising router");
d329 2
a330 3
	if (dflag)
		log_debug("received a routing message "
		    "(type = %d, len = %d)", rtmsg_type(msg), n);
d336 4
a339 5
		if (dflag)
			log_debug("received data length is larger than "
			    "1st routing message len. multiple messages? "
			    "read %d bytes, but 1st msg len = %d",
			    n, rtmsg_len(msg));
d369 2
a370 3
			if (dflag)
				log_debug("unknown rtmsg %d on %s",
				    type, if_indextoname(ifindex, ifname));
d375 3
a377 4
			if (dflag)
				log_debug("route changed on "
				    "non advertising interface(%s)",
				    if_indextoname(ifindex, ifname));
d402 6
a407 7
				if (dflag)
					log_debug("new prefix(%s/%d) "
					    "added on %s, "
					    "but it was already in list",
					    inet_ntop(AF_INET6, addr,
					    (char *)addrbuf, INET6_ADDRSTRLEN),
					    plen, rai->ifname);
d431 6
a436 7
				if (dflag)
					log_debug("prefix(%s/%d) was "
					    "deleted on %s, "
					    "but it was not in list",
					    inet_ntop(AF_INET6, addr,
					    (char *)addrbuf, INET6_ADDRSTRLEN),
					    plen, rai->ifname);
d452 2
a453 3
			if (dflag)
				log_debug("unknown rtmsg %d on %s",
				    type, if_indextoname(ifindex, ifname));
d472 1
a472 1
			ra_timer_update((void *)rai, &rai->timer->tm);
d983 1
a983 1
		if (memcmp((void *)prefix, (void *)&pp->prefix, bytelen))
d1007 1
a1007 1
		hdr = (struct nd_opt_hdr *)((caddr_t)hdr + optlen);
d1109 1
a1109 1
void
d1158 1
a1158 1
		fatal("inet_pton failed(library bug?)");
a1167 2
	ra = SLIST_FIRST(&ralist);

d1169 1
a1169 1
	rcviov[0].iov_base = (caddr_t)answer;
d1171 1
a1171 1
	rcvmhdr.msg_name = (caddr_t)&from;
d1175 1
a1175 1
	rcvmhdr.msg_control = (caddr_t) rcvcmsgbuf;
d1182 1
a1182 1
	sndmhdr.msg_control = (caddr_t)sndcmsgbuf;
d1207 1
a1207 1
struct rainfo *
a1222 1
	int i;
d1225 1
d1234 2
a1235 2
	sndmhdr.msg_name = (caddr_t)&sin6_allnodes;
	sndmhdr.msg_iov[0].iov_base = (caddr_t)rainfo->ra_data;
d1258 1
a1258 1
	log_debug("send RA on %s, # of waitings = %d",
d1261 1
a1261 1
	i = sendmsg(sock, &sndmhdr, 0);
d1263 2
a1264 3
	if (i < 0 || i != rainfo->ra_datalen)
		if (i < 0)
			log_warn("sendmsg on %s", rainfo->ifname);
a1282 4

#ifdef notyet
	/* if necessary, reconstruct the packet. */
#endif
@


1.72
log
@Pointless 'return;' in void functions
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.71 2016/02/26 12:50:03 jca Exp $	*/
d1084 1
a1084 1
				log_warn("malloc");
d1132 1
a1132 1
		fatal("malloc");
d1138 1
a1138 1
		fatal("malloc");
@


1.71
log
@sys/signal.h -> signal.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.70 2016/02/26 12:46:10 jca Exp $	*/
a484 2

	return;
a625 1
		return;
a626 2

	return;
a732 1
	return;
a861 1
	return;
a1194 2

	return;
@


1.70
log
@Unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.69 2016/02/26 12:34:30 jca Exp $	*/
a34 1
#include <sys/signal.h>
d58 1
@


1.69
log
@GC remnants of the Router Renumbering code; ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.68 2016/02/09 00:40:00 jca Exp $	*/
a82 1
int log_perror = 0;
@


1.68
log
@another typo
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.67 2016/02/09 00:39:13 jca Exp $	*/
a1009 24
}

/* check if p0/plen0 matches p1/plen1; return 1 if matches, otherwise 0. */
int
prefix_match(struct in6_addr *p0, int plen0,
	     struct in6_addr *p1, int plen1)
{
	int bytelen, bitlen;
	u_char bitmask;

	if (plen0 < plen1)
		return(0);
	bytelen = plen1 / 8;
	bitlen = plen1 % 8;
	bitmask = 0xff << (8 - bitlen);
	if (memcmp((void *)p0, (void *)p1, bytelen))
		return(0);
	if (bitlen == 0 ||
	    ((p0->s6_addr[bytelen] & bitmask) ==
	     (p1->s6_addr[bytelen] & bitmask))) {
		return(1);
	}

	return(0);
@


1.67
log
@Kill code to send unicast packets which never got enabled.

and get rid of pointless memory allocations.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.66 2016/02/08 23:19:00 jca Exp $	*/
d1320 1
a1320 1
	/* reset waiting conter */
@


1.66
log
@Kill trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.65 2016/02/08 23:15:37 jca Exp $	*/
a692 12
		struct soliciter *sol;

		/*
		 * record sockaddr waiting for RA, if possible
		 */
		sol = malloc(sizeof(*sol));
		if (sol) {
			sol->addr = *from;
			/*XXX RFC2553 need clarification on flowinfo */
			sol->addr.sin6_flowinfo = 0;
			SLIST_INSERT_HEAD(&ra->soliciters, sol, entry);
		}
a1270 1
	struct soliciter *sol;
a1310 19

	/*
	 * unicast advertisements
	 * XXX commented out.  reason: though spec does not forbit it, unicast
	 * advert does not really help
	 */
	while (!SLIST_EMPTY(&rainfo->soliciters)) {
		sol = SLIST_FIRST(&rainfo->soliciters);
		SLIST_REMOVE_HEAD(&rainfo->soliciters, entry);
#if 0
		sndmhdr.msg_name = (caddr_t)&sol->addr;
		i = sendmsg(sock, &sndmhdr, 0);
		if (i < 0 || i != rainfo->ra_datalen)
			if (i < 0)
				log_warn("unicast sendmsg on %s",
				    rainfo->ifname);
#endif
		free(sol);
	}
@


1.65
log
@typos
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.64 2016/02/07 21:10:33 jca Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d337 1
a337 1
		 * This usually won't happen for messages received on 
d591 1
a591 1
		 * XXX: there's a same dilemma as above... 
d702 1
a702 1
			sol->addr.sin6_flowinfo = 0;	
d769 1
a769 1
	
d792 1
a792 1
	
d831 1
a831 1
		    rai->ifname, reachabletime, 
d878 1
a878 1
	
d1015 1
a1015 1
		    ((prefix->s6_addr[bytelen] & bitmask) == 
d1041 1
a1041 1
	     (p1->s6_addr[bytelen] & bitmask))) { 
d1121 1
a1121 1
		
d1178 1
a1178 1
	sndcmsgbuflen = CMSG_SPACE(sizeof(struct in6_pktinfo)) + 
d1317 1
a1317 1
	    rainfo->ifname, rainfo->waiting); 
d1384 1
a1384 1
	interval = rai->mininterval; 
@


1.64
log
@Mark a few others functions as __dead; ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.63 2016/02/05 12:16:21 jca Exp $	*/
d841 1
a841 1
		log_info("RetranceTimer inconsistent on %s:"
@


1.63
log
@select -> poll in log message; ok bluhm@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.62 2016/02/05 12:15:15 jca Exp $	*/
d135 1
a135 1
static void die(void);
@


1.62
log
@Bail out if an unknown option is passed.

There is no reason for rtadvd to be different from other daemons.

Input from and ok bluhm@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.61 2015/12/01 12:11:31 jca Exp $	*/
d263 1
a263 1
				log_warn("select");
@


1.61
log
@Use setsockopt(ROUTE_MSGFILTER) instead of hand-rolled filtering.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.60 2015/11/30 20:58:08 jca Exp $	*/
d133 1
a133 1
int main(int, char *[]);
d165 1
a165 3
#define OPTIONS "c:ds"
	while ((ch = getopt(argc, argv, OPTIONS)) != -1) {
#undef OPTIONS
d176 2
d182 2
a183 6
	if (argc == 0) {
		fprintf(stderr,
			"usage: rtadvd [-ds] [-c configfile] "
			"interface ...\n");
		exit(1);
	}
d274 8
@


1.60
log
@Clean up get_next_msg(): kill dead argument/code

The "ifindex" argument has always been zero, making the interface index
checks within get_next_msg() useless.  The caller already properly
retrieves and handle the interface index of the routing messages.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.59 2015/11/30 20:52:28 jca Exp $	*/
d351 2
a352 6
		next = get_next_msg(next, lim, &len,
				    RTADV_TYPE2BITMASK(RTM_ADD) |
				    RTADV_TYPE2BITMASK(RTM_DELETE) |
				    RTADV_TYPE2BITMASK(RTM_NEWADDR) |
				    RTADV_TYPE2BITMASK(RTM_DELADDR) |
				    RTADV_TYPE2BITMASK(RTM_IFINFO));
d1243 2
d1247 11
@


1.59
log
@Remove the already disabled Router Renumbering support (RFC2894).

This code has only been reachable for two months after rtadvd has been
imported into the tree.  This unsafe protocol is supposed to be used
along with IPsec and rrenumd(8), a KAME tool that we don't have.
I couldn't find an example of use in the real world.

ok sthen@@ florian@@ millter@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.58 2015/10/25 22:11:34 jca Exp $	*/
d351 1
a351 1
		next = get_next_msg(next, lim, 0, &len,
@


1.58
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.57 2015/10/25 21:31:58 jca Exp $	*/
a60 1
#include "rrenum.h"
a79 2
struct in6_addr in6a_site_allrouters;
static char *mcastif;
a81 1
int accept_rr = 0;
d165 1
a165 1
#define OPTIONS "c:dM:Rs"
a174 9
		case 'M':
			mcastif = optarg;
			break;
		case 'R':
			fprintf(stderr, "rtadvd: "
				"the -R option is currently ignored.\n");
			/* accept_rr = 1; */
			/* run anyway... */
			break;
d184 1
a184 1
			"usage: rtadvd [-dMRs] [-c configfile] "
a620 9
	case ICMP6_ROUTER_RENUMBERING:
		if (accept_rr == 0) {
			log_warnx("received a router renumbering "
			    "message, but not allowed to be accepted");
			break;
		}
		rr_input(i, (struct icmp6_router_renum *)icp, pi, &from,
			 &dst);
		break;
a1201 2
	if (accept_rr)
		ICMP6_FILTER_SETPASS(ICMP6_ROUTER_RENUMBERING, &filt);
d1204 1
a1204 1
		fatal("IICMP6_FILTER");
a1222 25
	/*
	 * When attending router renumbering, join all-routers site-local
	 * multicast group. 
	 */
	if (accept_rr) {
		if (inet_pton(AF_INET6, ALLROUTERS_SITE,
		    &in6a_site_allrouters) != 1)
			fatal("inet_pton failed(library bug?)");
		mreq.ipv6mr_multiaddr = in6a_site_allrouters;
		if (mcastif) {
			if ((mreq.ipv6mr_interface = if_nametoindex(mcastif))
			    == 0) {
				log_warn("invalid interface: %s", mcastif);
				exit(1);
			}
		} else
			mreq.ipv6mr_interface = ra->ifindex;
		if (setsockopt(sock, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq,
		    sizeof(mreq)) < 0) {
			log_warn("IPV6_JOIN_GROUP(site) on %s", mcastif ?
			    mcastif : ra->ifname);
			exit(1);
		}
	}
	
@


1.57
log
@pledge "stdio inet route"; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.56 2015/10/25 21:23:42 jca Exp $	*/
d157 1
a157 3
main(argc, argv)
	int argc;
	char *argv[];
d306 1
a306 1
die()
d329 1
a329 1
rtmsg_input()
d504 1
a504 1
rtadvd_input()
d1185 1
a1185 1
sock_open()
d1294 1
a1294 1
rtsock_open()
d1314 1
a1314 2
ra_output(rainfo)
struct rainfo *rainfo;
@


1.56
log
@Stop writing down a pidfile.

pid files aren't useful on OpenBSD, the rc.d(8) framework doesn't use
them.  In rtadvd, not writing a pid file means that we can set tighter
pledge(2) settings.  Also the pid file handling is pretty basic and the
atexit handler can't remove the pid file since rtadvd did a chroot - beurk.

ok florian@@, "perfect" deraadt@@ (!)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.55 2015/08/20 22:39:29 deraadt Exp $	*/
d240 3
@


1.55
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.54 2015/08/18 20:25:28 miod Exp $	*/
a57 1
#include <util.h>
a224 4

	/* record the current PID */
	if (pidfile(NULL) < 0)
		log_warnx("failed to open the pid log file, run anyway.");
@


1.54
log
@Fix inconsistent spelling of `inconsistent'
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.53 2015/01/16 06:40:20 deraadt Exp $	*/
d724 1
a724 1
		sol = (struct soliciter *)malloc(sizeof(*sol));
d1200 1
a1200 1
	rcvcmsgbuf = (u_char *)malloc(rcvcmsgbuflen);
d1206 1
a1206 1
	sndcmsgbuf = (u_char *)malloc(sndcmsgbuflen);
@


1.53
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.52 2015/01/01 20:28:27 florian Exp $	*/
d910 1
a910 1
/* return a non-zero value if the received prefix is inconsitent with ours */
@


1.52
log
@"The logging of errors SHOULD be restricted to conflicting information
that causes hosts to switch from one value to another with each
received advertisement." (RFC 4861)

Receiving of RAs on non-advertising interfaces is not a conflicting
information; don't log it.

"Mike." (the.lists AT mgm51 DOT com) reported that this
leads to excessive logging with certain cable providers in 2013.
Recently reported again by Aaron Riekenberg (aaron.riekenberg AT gmail
DOT com). Thanks!

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.51 2015/01/01 16:31:59 florian Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d35 1
@


1.51
log
@KNF; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.50 2014/11/18 20:54:29 krw Exp $	*/
d813 3
a815 7
	if ((rai = if_indextorainfo(pi->ipi6_ifindex)) == 0) {
		log_info("received RA from %s on non-advertising interface(%s)",
		    inet_ntop(AF_INET6, &from->sin6_addr, ntopbuf,
			INET6_ADDRSTRLEN),
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		goto done;
	}
@


1.50
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.49 2014/11/02 02:33:33 deraadt Exp $	*/
d1218 2
a1219 2
	if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &on,
		       sizeof(on)) < 0)
d1224 2
a1225 2
	if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on,
		       sizeof(on)) < 0)
d1233 2
a1234 2
	if (setsockopt(sock, IPPROTO_ICMPV6, ICMP6_FILTER, &filt,
		       sizeof(filt)) < 0)
d1240 1
a1240 2
	if (inet_pton(AF_INET6, ALLROUTERS_LINK,
		      &mreq.ipv6mr_multiaddr.s6_addr)
d1246 1
a1246 1
			       sizeof(mreq)) < 0) {
d1260 1
a1260 1
			      &in6a_site_allrouters) != 1)
d1271 4
a1274 4
		if (setsockopt(sock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
			       &mreq, sizeof(mreq)) < 0) {
			log_warn("IPV6_JOIN_GROUP(site) on %s",
			    mcastif ? mcastif : ra->ifname);
d1295 1
a1295 1
	
@


1.49
log
@convert select() to poll().
tested by brad (who found a conversion bug..)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.48 2014/10/22 19:47:28 brad Exp $	*/
a56 1
#include <stdlib.h>
@


1.48
log
@Replace abs(3) with llabs(3).

Pointed out by LLVM.

rtadvd.c:979:7: warning: absolute value function 'abs' given an argument of type
'long long' but has parameter of type 'int' which may cause truncation of value
[-Wabsolute-value]


ok dcoppa@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.47 2014/07/04 22:39:31 guenther Exp $	*/
d53 1
d162 1
a162 3
	fd_set *fdsetp, *selectfdp;
	int fdmasks;
	int maxfd = 0;
a163 1
	int i, ch;
d165 1
a230 1
	maxfd = sock;
d233 1
a233 4
		if (rtsock > sock)
			maxfd = rtsock;
	} else
		rtsock = -1;
d246 7
a252 8
	fdmasks = howmany(maxfd + 1, NFDBITS) * sizeof(fd_mask);
	if ((fdsetp = calloc(1, fdmasks)) == NULL) {
		err(1, "calloc");
		/*NOTREACHED*/
	}
	if ((selectfdp = malloc(fdmasks)) == NULL) {
		err(1, "malloc");
		/*NOTREACHED*/
a253 3
	FD_SET(sock, fdsetp);
	if (rtsock >= 0)
		FD_SET(rtsock, fdsetp);
a258 2
		memcpy(selectfdp, fdsetp, fdmasks); /* reinitialize */

d280 2
a281 2
		if ((i = select(maxfd + 1, selectfdp, NULL, NULL,
		    timeout)) < 0) {
d289 1
a289 1
		if (rtsock != -1 && FD_ISSET(rtsock, selectfdp))
d291 1
a291 1
		if (FD_ISSET(sock, selectfdp))
@


1.47
log
@malloc+memset -> calloc

from Benjamin Baier (programmer (at) netzbasis.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.46 2014/05/15 05:03:24 jca Exp $	*/
d979 1
a979 1
		    abs(preferred_time - pp->pltimeexpire) > rai->clockskew) {
d1010 1
a1010 1
		    abs(valid_time - pp->vltimeexpire) > rai->clockskew) {
@


1.46
log
@Deal with - actually, ignore - route info messages on the listening side.
Issue reported by consus at gmx dot com on bugs@@.
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.45 2013/05/05 14:25:52 dtucker Exp $	*/
d252 2
a253 2
	if ((fdsetp = malloc(fdmasks)) == NULL) {
		err(1, "malloc");
a259 1
	memset(fdsetp, 0, fdmasks);
@


1.45
log
@typo in log message.  ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.44 2013/04/30 12:30:40 florian Exp $	*/
d124 1
d132 1
d814 2
a815 1
			| NDOPT_FLAG_MTU | NDOPT_FLAG_RDNSS | NDOPT_FLAG_DNSSL)) {
d1115 1
d1149 1
@


1.44
log
@- replace TIMEVAL_* function/macros with macros from sys/time.h
- replace insque(3) with SLIST from queue(3)
- with that, rewrite rtadvd_check_timer() logic to avoid
  timeval {0x7fffffff, 0x7fffffff}

test/ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.43 2013/04/30 12:29:04 florian Exp $	*/
d978 1
a978 1
			log_info("prefeerred lifetime for %s/%d"
@


1.43
log
@move variables to type time_t; fix format strings

test/ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.42 2013/04/19 05:06:35 deraadt Exp $	*/
a205 3
	/* timer initialization */
	rtadvd_timer_init();

d760 1
a760 1
		if (TIMEVAL_LT(*rest, interval)) {
d774 1
a774 1
		TIMEVAL_SUB(&now, &ra->lastsent, &tm_tmp);
d777 3
a779 3
		if (TIMEVAL_LT(tm_tmp, min_delay)) {
			TIMEVAL_SUB(&min_delay, &tm_tmp, &min_delay);
			TIMEVAL_ADD(&min_delay, &interval, &interval);
@


1.42
log
@print tv_sec properly
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.41 2013/04/17 00:14:37 deraadt Exp $	*/
d931 1
a931 1
	u_int32_t preferred_time, valid_time;
d983 1
a983 1
			    " %d from %s, %ld from us",
d987 1
a987 1
			    rai->ifname, preferred_time,
d990 1
a990 1
			    pp->pltimeexpire);
d996 1
a996 1
		    " %d from %s, %d from us",
d1000 1
a1000 1
		    rai->ifname, preferred_time,
d1014 1
a1014 1
			    " %d from %s, %ld from us",
d1018 1
a1018 1
			    rai->ifname, preferred_time,
d1021 1
a1021 1
			    pp->vltimeexpire);
d1027 1
a1027 1
		    " %d from %s, %d from us",
d1031 1
a1031 1
		    rai->ifname, valid_time,
@


1.41
log
@handle large tv_sec
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.40 2012/07/08 10:46:00 phessler Exp $	*/
d1457 2
a1458 4
	log_debug("RA timer on %s is set to %ld:%ld", rai->ifname,
	    (long int)tm->tv_sec, (long int)tm->tv_usec);

	return;
@


1.40
log
@Add support for advertising dns servers and search paths in router
advertisements, according to RFC 6106.

original diff from Stephane A. Sezer on tech@@, many thanks!

OK phessler@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.39 2011/03/02 17:30:48 bluhm Exp $	*/
d286 1
a286 1
			log_debug("set timer to %ld:%ld. waiting for "
d288 2
a289 2
			    (long int)timeout->tv_sec,
			    (long int)timeout->tv_usec);
@


1.39
log
@Don't use a flag value as index into the 2 element array on_off.
Fixes a segmentation fault.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.38 2008/11/21 23:44:04 tedu Exp $	*/
d117 7
a123 5
#define NDOPT_FLAG_SRCLINKADDR 0x1
#define NDOPT_FLAG_TGTLINKADDR 0x2
#define NDOPT_FLAG_PREFIXINFO 0x4
#define NDOPT_FLAG_RDHDR 0x8
#define NDOPT_FLAG_MTU 0x10
d126 7
a132 2
	0, NDOPT_FLAG_SRCLINKADDR, NDOPT_FLAG_TGTLINKADDR,
	NDOPT_FLAG_PREFIXINFO, NDOPT_FLAG_RDHDR, NDOPT_FLAG_MTU,
d814 2
a815 2
			&ndopts, NDOPT_FLAG_SRCLINKADDR |
			NDOPT_FLAG_PREFIXINFO | NDOPT_FLAG_MTU)) {
d1114 3
a1116 1
		if (hdr->nd_opt_type > ND_OPT_MTU)
d1133 4
a1136 1
		if ((hdr->nd_opt_type == ND_OPT_MTU &&
d1148 2
d1171 1
a1171 1
			
@


1.38
log
@closefrom the fds that we aren't interested in.  pr5994
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.37 2008/11/03 07:02:44 deraadt Exp $	*/
d844 1
a844 1
		    rai->ifname, on_off[!rai->managedflg],
d847 1
a847 1
		    on_off[rai->managedflg]);
d854 1
a854 1
		    rai->ifname, on_off[!rai->otherflg],
d857 1
a857 1
		    on_off[rai->otherflg]);
@


1.37
log
@be more clear about what getpwnam failed; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.36 2008/06/09 22:53:24 rainer Exp $	*/
d160 2
@


1.36
log
@drop root privileges in rtadvd to _rtadvd

ok deraadt@@, reyk@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.35 2008/06/08 21:08:57 rainer Exp $	*/
d233 1
a233 1
		fatal("getpwnam");
@


1.35
log
@Send debug output to syslog instead of a file when receiving SIGUSR1.
This is a preparation for dropping privileges.

ok henning@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.34 2008/05/02 04:28:51 pyr Exp $	*/
d58 1
d157 1
d231 11
@


1.34
log
@do not always delay log initialization, when no configuration file is
present, which is the most common use of rtadvd, it would otherwise
always print messages to the console though the situation is valid.

this fixes a regression introduced with the new logging code.

ok rainer@@, todd@@, fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.33 2008/04/23 10:17:50 pyr Exp $	*/
a80 1
static char *dumpfilename = "/var/run/rtadvd.dump"; /* XXX: should be configurable */
d144 1
a144 1
static void rtadvd_set_dump_file(int);
d245 1
a245 1
	signal(SIGUSR1, rtadvd_set_dump_file);
d252 1
a252 1
			rtadvd_dump_file(dumpfilename);
d289 1
a289 1
rtadvd_set_dump_file(int signo)
@


1.33
log
@Replace handrolled lists with SLISTs or TAILQs.
Timers remain and will be handled later.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.32 2008/04/21 20:40:55 rainer Exp $	*/
d202 3
d211 2
a212 1
	log_init(dflag);
@


1.32
log
@Clean up logging by introducing the logging API used in
other daemons and clean up the command line options.
For details, see rtadvd(8).

ok bluhm@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.31 2008/04/13 00:22:17 djm Exp $	*/
d91 5
a95 4
struct rainfo *ralist = NULL;
struct nd_optlist {
	struct nd_optlist *next;
	struct nd_opt_hdr *opt;
d97 1
d107 1
a107 1
		struct nd_optlist *list;
d194 2
d307 1
a307 1
	for (ra = ralist; ra; ra = ra->next) {
d312 1
a312 1
		for (ra = ralist; ra; ra = ra->next)
d664 1
d688 1
a688 2
	ra = ralist;
	while (ra != NULL) {
a690 1
		ra = ra->next;
d717 1
a717 2
			sol->next = ra->soliciter;
			ra->soliciter = sol;
d786 1
d881 1
a881 1
		struct nd_optlist *optp = ndopts.nd_opts_list;
d886 1
a886 1
		while (optp) {
a889 1
			optp = optp->next;
d1023 1
a1023 1
	for (pp = rai->prefix.next; pp != &rai->prefix; pp = pp->next) {
d1128 2
a1129 2
			struct nd_optlist *pfxlist;

d1135 1
a1135 1
			if ((pfxlist = malloc(sizeof(*pfxlist))) == NULL) {
d1139 3
a1141 3
			pfxlist->next = ndopts->nd_opts_list;
			pfxlist->opt = hdr;
			ndopts->nd_opts_list = pfxlist;
d1161 1
a1161 1
	struct nd_optlist *opt = ndopts->nd_opts_list, *next;
d1163 3
a1165 2
	while (opt) {
		next = opt->next;
a1166 1
		opt = next;
d1173 1
a1175 1
	struct rainfo *ra = ralist;
d1223 1
a1223 1
	while (ra) {
a1229 1
		ra = ra->next;
d1232 2
d1250 1
a1250 1
			mreq.ipv6mr_interface = ralist->ifindex;
d1254 1
a1254 1
			    mcastif ? mcastif : ralist->ifname);
d1290 1
a1290 1
	struct rainfo *rai = ralist;
d1292 1
a1292 1
	for (rai = ralist; rai; rai = rai->next) {
d1307 1
a1307 1
	struct soliciter *sol, *nextsol;
d1354 3
a1356 3
	for (sol = rainfo->soliciter; sol; sol = nextsol) {
		nextsol = sol->next;

a1364 2

		sol->next = NULL;
a1366 1
	rainfo->soliciter = NULL;
@


1.31
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.30 2008/03/24 16:11:05 deraadt Exp $	*/
a56 1
#include <syslog.h>
d66 1
d87 1
d155 2
a156 1
	int fflag = 0, logopt;
d159 1
a159 1
#define OPTIONS "c:dDfM:Rs"
a168 6
		case 'D':
			dflag = 2;
			break;
		case 'f':
			fflag = 1;
			break;
d187 1
a187 1
			"usage: rtadvd [-DdfMRs] [-c configfile] "
a191 11
	logopt = LOG_NDELAY | LOG_PID;
	if (fflag)
		logopt |= LOG_PERROR;
	openlog("rtadvd", logopt, LOG_DAEMON);

	/* set log level */
	if (dflag == 0)
		(void)setlogmask(LOG_UPTO(LOG_ERR));
	if (dflag == 1)
		(void)setlogmask(LOG_UPTO(LOG_INFO));

d201 4
a204 4
	if (inet_pton(AF_INET6, ALLNODES, &sin6_allnodes.sin6_addr) != 1) {
		fprintf(stderr, "fatal: inet_pton failed\n");
		exit(1);
	}
d206 1
a206 1
	if (!fflag)
d212 2
a213 5
	if (pidfile(NULL) < 0) {
		syslog(LOG_ERR,
		    "<%s> failed to open the pid log file, run anyway.",
		    __func__);
	}
d256 3
a258 4
		if (timeout != NULL) {
			syslog(LOG_DEBUG,
			    "<%s> set timer to %ld:%ld. waiting for "
			    "inputs or timeout", __func__,
d261 2
a262 5
		} else {
			syslog(LOG_DEBUG,
			    "<%s> there's no timer. waiting for inputs",
			    __func__);
		}
d268 1
a268 2
				syslog(LOG_ERR, "<%s> select: %s",
				    __func__, strerror(errno));
d300 2
a301 4
	if (dflag > 1) {
		syslog(LOG_DEBUG, "<%s> cease to be an advertising router",
		    __func__);
	}
d329 3
a331 4
	if (dflag > 1) {
		syslog(LOG_DEBUG, "<%s> received a routing message "
		    "(type = %d, len = %d)", __func__, rtmsg_type(msg), n);
	}
d337 2
a338 3
		if (dflag > 1)
			syslog(LOG_DEBUG,
			    "<%s> received data length is larger than "
d341 1
a341 1
			    __func__, n, rtmsg_len(msg));
d375 3
a377 6
			if (dflag > 1) {
				syslog(LOG_DEBUG,
				       "<%s:%d> unknown rtmsg %d on %s",
				       __func__, __LINE__, type,
				       if_indextoname(ifindex, ifname));
			}
d382 4
a385 7
			if (dflag > 1) {
				syslog(LOG_DEBUG,
				       "<%s> route changed on "
				       "non advertising interface(%s)",
				       __func__,
				       if_indextoname(ifindex, ifname));
			}
d404 2
a405 3
				syslog(LOG_INFO, "<%s> new interface route's"
				    "plen %d is invalid for a prefix",
				    __func__, plen);
d410 2
a411 3
				if (dflag > 1) {
					syslog(LOG_DEBUG,
					    "<%s> new prefix(%s/%d) "
a413 1
					    __func__,
a416 1
				}
d434 2
a435 4
				syslog(LOG_INFO,
				    "<%s> deleted interface route's "
				    "plen %d is invalid for a prefix",
				    __func__, plen);
d440 2
a441 3
				if (dflag > 1) {
					syslog(LOG_DEBUG,
					    "<%s> prefix(%s/%d) was "
a443 1
					    __func__,
a446 1
				}
d462 3
a464 6
			if (dflag > 1) {
				syslog(LOG_DEBUG,
				    "<%s:%d> unknown rtmsg %d on %s",
				    __func__, __LINE__, type,
				    if_indextoname(ifindex, ifname));
			}
d471 2
a472 3
			syslog(LOG_INFO,
			    "<%s> interface %s becomes down. stop timer.",
			    __func__, rai->ifname);
d476 2
a477 3
			syslog(LOG_INFO,
			    "<%s> interface %s becomes up. restart timer.",
			    __func__, rai->ifname);
d529 1
a529 3
		syslog(LOG_ERR,
		       "<%s> failed to get receiving interface",
		       __func__);
d533 1
a533 3
		syslog(LOG_ERR,
		       "<%s> failed to get receiving hop limit",
		       __func__);
d542 2
a543 4
		syslog(LOG_INFO,
		       "<%s> received data on a disabled interface (%s)",
		       __func__,
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d548 1
a548 3
		syslog(LOG_ERR,
		       "<%s> packet size(%d) is too short",
		       __func__, i);
d562 1
a562 2
			syslog(LOG_NOTICE,
			    "<%s> RS with invalid hop limit(%d) "
d564 1
a564 1
			    __func__, *hlimp,
d571 1
a571 2
			syslog(LOG_NOTICE,
			    "<%s> RS with invalid ICMP6 code(%d) "
d573 1
a573 1
			    __func__, icp->icmp6_code,
d580 1
a580 2
			syslog(LOG_NOTICE,
			    "<%s> RS from %s on %s does not have enough "
a581 1
			    __func__,
d595 1
a595 2
			syslog(LOG_NOTICE,
			    "<%s> RA with invalid hop limit(%d) "
d597 1
a597 1
			    __func__, *hlimp,
d604 1
a604 2
			syslog(LOG_NOTICE,
			    "<%s> RA with invalid ICMP6 code(%d) "
d606 1
a606 1
			    __func__, icp->icmp6_code,
d613 1
a613 2
			syslog(LOG_NOTICE,
			    "<%s> RA from %s on %s does not have enough "
a614 1
			    __func__,
d624 2
a625 3
			syslog(LOG_ERR, "<%s> received a router renumbering "
			    "message, but not allowed to be accepted",
			    __func__);
d638 1
a638 2
		syslog(LOG_ERR, "<%s> invalid icmp type(%d)",
		    __func__, icp->icmp6_type);
d653 4
a656 6
	syslog(LOG_DEBUG,
	       "<%s> RS received from %s on %s",
	       __func__,
	       inet_ntop(AF_INET6, &from->sin6_addr,
			 ntopbuf, INET6_ADDRSTRLEN),
	       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d663 4
a666 6
		syslog(LOG_DEBUG,
		       "<%s> ND option check failed for an RS from %s on %s",
		       __func__,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d677 1
a677 2
		syslog(LOG_ERR,
		       "<%s> RS from unspecified src on %s has a link-layer"
a678 1
		       __func__,
d690 2
a691 4
		syslog(LOG_INFO,
		       "<%s> RS received on non advertising interface(%s)",
		       __func__,
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d737 2
a738 4
			syslog(LOG_DEBUG,
			       "<%s> random delay is larger than "
			       "the rest of normal timer",
			       __func__);
d777 4
a780 6
	syslog(LOG_DEBUG,
	       "<%s> RA received from %s on %s",
	       __func__,
	       inet_ntop(AF_INET6, &from->sin6_addr,
			 ntopbuf, INET6_ADDRSTRLEN),
	       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d788 4
a791 6
		syslog(LOG_ERR,
		       "<%s> ND option check failed for an RA from %s on %s",
		       __func__,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d799 4
a802 7
		syslog(LOG_INFO,
		       "<%s> received RA from %s on non-advertising"
		       " interface(%s)",
		       __func__,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d810 7
a816 9
		syslog(LOG_INFO,
		       "<%s> CurHopLimit inconsistent on %s:"
		       " %d from %s, %d from us",
		       __func__,
		       rai->ifname,
		       ra->nd_ra_curhoplimit,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       rai->hoplimit);
d822 5
a826 9
		syslog(LOG_INFO,
		       "<%s> M flag inconsistent on %s:"
		       " %s from %s, %s from us",
		       __func__,
		       rai->ifname,
		       on_off[!rai->managedflg],
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       on_off[rai->managedflg]);
d832 5
a836 9
		syslog(LOG_INFO,
		       "<%s> O flag inconsistent on %s:"
		       " %s from %s, %s from us",
		       __func__,
		       rai->ifname,
		       on_off[!rai->otherflg],
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       on_off[rai->otherflg]);
d843 6
a848 9
		syslog(LOG_INFO,
		       "<%s> ReachableTime inconsistent on %s:"
		       " %d from %s, %d from us",
		       __func__,
		       rai->ifname,
		       reachabletime,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       rai->reachabletime);
d855 6
a860 9
		syslog(LOG_INFO,
		       "<%s> RetranceTimer inconsistent on %s:"
		       " %d from %s, %d from us",
		       __func__,
		       rai->ifname,
		       retranstimer,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       rai->retranstimer);
d867 6
a872 8
			syslog(LOG_INFO,
			       "<%s> MTU option value inconsistent on %s:"
			       " %d from %s, %d from us",
			       __func__,
			       rai->ifname, mtu,
			       inet_ntop(AF_INET6, &from->sin6_addr,
					 ntopbuf, INET6_ADDRSTRLEN),
			       rai->linkmtu);
d880 1
a880 1
		if (ndopts.nd_opts_pi) {
a882 1
		}
d918 9
a926 12
	if (IN6_IS_ADDR_LINKLOCAL(&pinfo->nd_opt_pi_prefix)) {
		syslog(LOG_INFO,
		       "<%s> link-local prefix %s/%d is advertised "
		       "from %s on %s",
		       __func__,
		       inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
				 prefixbuf, INET6_ADDRSTRLEN),
		       pinfo->nd_opt_pi_prefix_len,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       rai->ifname);
	}
d930 7
a936 9
		syslog(LOG_INFO,
		       "<%s> prefix %s/%d from %s on %s is not in our list",
		       __func__,
		       inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
				 prefixbuf, INET6_ADDRSTRLEN),
		       pinfo->nd_opt_pi_prefix_len,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       rai->ifname);
d954 10
a963 12
			syslog(LOG_INFO,
			       "<%s> prefeerred lifetime for %s/%d"
			       " (decr. in real time) inconsistent on %s:"
			       " %d from %s, %ld from us",
			       __func__,
			       inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
					 prefixbuf, INET6_ADDRSTRLEN),
			       pinfo->nd_opt_pi_prefix_len,
			       rai->ifname, preferred_time,
			       inet_ntop(AF_INET6, &from->sin6_addr,
					 ntopbuf, INET6_ADDRSTRLEN),
			       pp->pltimeexpire);
d966 11
a976 14
	} else if (preferred_time != pp->preflifetime) {
		syslog(LOG_INFO,
		       "<%s> prefeerred lifetime for %s/%d"
		       " inconsistent on %s:"
		       " %d from %s, %d from us",
		       __func__,
		       inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
				 prefixbuf, INET6_ADDRSTRLEN),
		       pinfo->nd_opt_pi_prefix_len,
		       rai->ifname, preferred_time,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       pp->preflifetime);
	}
d985 10
a994 12
			syslog(LOG_INFO,
			       "<%s> valid lifetime for %s/%d"
			       " (decr. in real time) inconsistent on %s:"
			       " %d from %s, %ld from us",
			       __func__,
			       inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
					 prefixbuf, INET6_ADDRSTRLEN),
			       pinfo->nd_opt_pi_prefix_len,
			       rai->ifname, preferred_time,
			       inet_ntop(AF_INET6, &from->sin6_addr,
					 ntopbuf, INET6_ADDRSTRLEN),
			       pp->vltimeexpire);
d998 10
a1007 12
		syslog(LOG_INFO,
		       "<%s> valid lifetime for %s/%d"
		       " inconsistent on %s:"
		       " %d from %s, %d from us",
		       __func__,
		       inet_ntop(AF_INET6, &pinfo->nd_opt_pi_prefix,
				 prefixbuf, INET6_ADDRSTRLEN),
		       pinfo->nd_opt_pi_prefix_len,
		       rai->ifname, valid_time,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf, INET6_ADDRSTRLEN),
		       pp->validlifetime);
d1071 1
a1071 1
			syslog(LOG_INFO, "<%s> short option header", __func__);
d1077 2
a1078 3
			syslog(LOG_ERR,
			    "<%s> bad ND option length(0) (type = %d)",
			    __func__, hdr->nd_opt_type);
d1083 1
a1083 1
			syslog(LOG_INFO, "<%s> short option", __func__);
d1089 2
a1090 2
			syslog(LOG_INFO, "<%s> unknown ND option(type %d)",
			    __func__, hdr->nd_opt_type);
d1095 2
a1096 2
			syslog(LOG_INFO, "<%s> unexpected ND option(type %d)",
			    __func__, hdr->nd_opt_type);
d1108 1
a1108 2
			syslog(LOG_INFO, "<%s> invalid option length",
			    __func__);
d1119 2
a1120 3
				syslog(LOG_INFO,
				    "<%s> duplicated ND option (type = %d)",
				    __func__, hdr->nd_opt_type);
d1134 1
a1134 2
				syslog(LOG_ERR, "<%s> can't allocate memory",
				    __func__);
d1181 2
a1182 4
	if (rcvcmsgbuf == NULL) {
		syslog(LOG_ERR, "<%s> not enough core", __func__);
		exit(1);
	}
d1187 2
a1188 4
	if (sndcmsgbuf == NULL) {
		syslog(LOG_ERR, "<%s> not enough core", __func__);
		exit(1);
	}
d1190 2
a1191 5
	if ((sock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6)) < 0) {
		syslog(LOG_ERR, "<%s> socket: %s", __func__,
		       strerror(errno));
		exit(1);
	}
d1196 2
a1197 5
		       sizeof(on)) < 0) {
		syslog(LOG_ERR, "<%s> IPV6_RECVPKTINFO: %s",
		       __func__, strerror(errno));
		exit(1);
	}
d1202 2
a1203 5
		       sizeof(on)) < 0) {
		syslog(LOG_ERR, "<%s> IPV6_RECVHOPLIMIT: %s",
		       __func__, strerror(errno));
		exit(1);
	}
d1211 2
a1212 5
		       sizeof(filt)) < 0) {
		syslog(LOG_ERR, "<%s> IICMP6_FILTER: %s",
		       __func__, strerror(errno));
		exit(1);
	}
d1219 2
a1220 5
	    != 1) {
		syslog(LOG_ERR, "<%s> inet_pton failed(library bug?)",
		       __func__);
		exit(1);
	}
d1225 1
a1225 2
			syslog(LOG_ERR, "<%s> IPV6_JOIN_GROUP(link) on %s: %s",
			       __func__, ra->ifname, strerror(errno));
d1237 2
a1238 5
			      &in6a_site_allrouters) != 1) {
			syslog(LOG_ERR, "<%s> inet_pton failed(library bug?)",
			       __func__);
			exit(1);
		}
d1243 1
a1243 3
				syslog(LOG_ERR,
				       "<%s> invalid interface: %s",
				       __func__, mcastif);
d1250 2
a1251 5
			syslog(LOG_ERR,
			       "<%s> IPV6_JOIN_GROUP(site) on %s: %s",
			       __func__,
			       mcastif ? mcastif : ralist->ifname,
			       strerror(errno));
d1280 2
a1281 5
	if ((rtsock = socket(PF_ROUTE, SOCK_RAW, 0)) < 0) {
		syslog(LOG_ERR,
		       "<%s> socket: %s", __func__, strerror(errno));
		exit(1);
	}
d1307 1
a1307 2
		syslog(LOG_DEBUG, "<%s> %s is not up, skip sending RA",
		       __func__, rainfo->ifname);
d1337 2
a1338 3
	syslog(LOG_DEBUG,
	       "<%s> send RA on %s, # of waitings = %d",
	       __func__, rainfo->ifname, rainfo->waiting); 
d1342 3
a1344 7
	if (i < 0 || i != rainfo->ra_datalen)  {
		if (i < 0) {
			syslog(LOG_ERR, "<%s> sendmsg on %s: %s",
			       __func__, rainfo->ifname,
			       strerror(errno));
		}
	}
d1357 4
a1360 8
		if (i < 0 || i != rainfo->ra_datalen)  {
			if (i < 0) {
				syslog(LOG_ERR,
				    "<%s> unicast sendmsg on %s: %s",
				    __func__, rainfo->ifname,
				    strerror(errno));
			}
		}
d1390 1
a1390 3
	syslog(LOG_DEBUG,
	       "<%s> RA timer on %s is expired",
	       __func__, rai->ifname);
d1425 2
a1426 4
	syslog(LOG_DEBUG,
	       "<%s> RA timer on %s is set to %ld:%ld",
	       __func__, rai->ifname,
	       (long int)tm->tv_sec, (long int)tm->tv_usec);
@


1.30
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.29 2008/03/18 19:32:18 deraadt Exp $	*/
d805 1
a805 1
		delay = arc4random() % MAX_RA_DELAY_TIME;
d1571 1
a1571 1
	interval += arc4random() % (rai->maxinterval - rai->mininterval);
@


1.29
log
@correct CMSG_SPACE and CMSG_LEN handling as done in other places.  These
are the complicated cases where multiple messages are sent.  discussed
with kettenis, hshoexer, and rtsol tested by jmc - thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.28 2007/01/10 08:10:47 itojun Exp $	*/
a69 1
static size_t rcvcmsgbufspace;
a71 1
static size_t sndcmsgbufspace;
a1297 2
	    CMSG_LEN(sizeof(int));
	rcvcmsgbufspace = CMSG_SPACE(sizeof(struct in6_pktinfo)) +
d1299 1
a1299 1
	rcvcmsgbuf = (u_char *)malloc(rcvcmsgbufspace);
a1305 2
	    CMSG_LEN(sizeof(int));
	sndcmsgbufspace = CMSG_SPACE(sizeof(struct in6_pktinfo)) + 
d1307 1
a1307 1
	sndcmsgbuf = (u_char *)malloc(sndcmsgbufspace);
@


1.28
log
@remove ancient code.  sync w/ kame
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.27 2006/12/15 06:14:07 itojun Exp $	*/
d70 1
d73 1
d1300 4
a1303 2
				CMSG_SPACE(sizeof(int));
	rcvcmsgbuf = (u_char *)malloc(rcvcmsgbuflen);
d1310 4
a1313 2
				CMSG_SPACE(sizeof(int));
	sndcmsgbuf = (u_char *)malloc(sndcmsgbuflen);
@


1.27
log
@reduce RFC2292/3542 #ifdef.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.26 2005/10/27 18:26:13 jmc Exp $	*/
a542 3
#ifdef OLDRAWSOCKET
	struct ip6_hdr *ip;
#endif 
a599 11
#ifdef OLDRAWSOCKET
	if (i < sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr)) {
		syslog(LOG_ERR,
		       "<%s> packet size(%d) is too short",
		       __func__, i);
		return;
	}

	ip = (struct ip6_hdr *)rcvmhdr.msg_iov[0].iov_base;
	icp = (struct icmp6_hdr *)(ip + 1); /* XXX: ext. hdr? */
#else
a607 1
#endif
@


1.26
log
@sort options and sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.25 2003/03/14 18:46:45 itojun Exp $	*/
a1335 1
#ifdef IPV6_RECVPKTINFO
a1341 8
#else  /* old adv. API */
	if (setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, &on,
		       sizeof(on)) < 0) {
		syslog(LOG_ERR, "<%s> IPV6_PKTINFO: %s",
		       __func__, strerror(errno));
		exit(1);
	}
#endif 
a1344 1
#ifdef IPV6_RECVHOPLIMIT
a1350 8
#else  /* old adv. API */
	if (setsockopt(sock, IPPROTO_IPV6, IPV6_HOPLIMIT, &on,
		       sizeof(on)) < 0) {
		syslog(LOG_ERR, "<%s> IPV6_HOPLIMIT: %s",
		       __func__, strerror(errno));
		exit(1);
	}
#endif
@


1.25
log
@correct use of sizeof.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.24 2003/03/14 18:33:58 itojun Exp $	*/
d191 2
a192 2
			"usage: rtadvd [-dDfMRs] [-c conffile] "
			"interfaces...\n");
@


1.24
log
@add missing ND option length validation.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.23 2002/09/10 05:31:17 deraadt Exp $	*/
d1200 1
a1200 1
		if (limit < sizeof(struct nd_opt_hdr *)) {
@


1.23
log
@signo and ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.22 2002/06/10 19:57:35 espie Exp $	*/
d1200 5
a1205 1
		optlen = hdr->nd_opt_len << 3;
d1212 5
d1231 13
d1248 1
@


1.22
log
@Kill __FUNCTION__.
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.21 2002/06/09 00:56:09 deraadt Exp $	*/
d142 1
a142 1
static void rtadvd_set_dump_file(void);
d255 2
a256 2
	signal(SIGTERM, (void *)set_die);
	signal(SIGUSR1, (void *)rtadvd_set_dump_file);
d305 1
a305 1
rtadvd_set_dump_file()
d311 1
a311 2
set_die(sig)
	int sig;
@


1.21
log
@do not use \n in syslog()
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.20 2002/06/07 00:42:14 itojun Exp $	*/
d230 1
a230 1
		    __FUNCTION__);
d277 1
a277 1
			    "inputs or timeout", __FUNCTION__,
d283 1
a283 1
			    __FUNCTION__);
d291 1
a291 1
				    __FUNCTION__, strerror(errno));
d326 1
a326 1
		    __FUNCTION__);
d357 1
a357 1
		    "(type = %d, len = %d)", __FUNCTION__, rtmsg_type(msg), n);
d369 1
a369 1
			    __FUNCTION__, n, rtmsg_len(msg));
d406 1
a406 1
				       __FUNCTION__, __LINE__, type,
d417 1
a417 1
				       __FUNCTION__,
d440 1
a440 1
				    __FUNCTION__, plen);
d450 1
a450 1
					    __FUNCTION__,
d475 1
a475 1
				    __FUNCTION__, plen);
d485 1
a485 1
					    __FUNCTION__,
d508 1
a508 1
				    __FUNCTION__, __LINE__, type,
d519 1
a519 1
			    __FUNCTION__, rai->ifname);
d525 1
a525 1
			    __FUNCTION__, rai->ifname);
d582 1
a582 1
		       __FUNCTION__);
d588 1
a588 1
		       __FUNCTION__);
d599 1
a599 1
		       __FUNCTION__,
d608 1
a608 1
		       __FUNCTION__, i);
d618 1
a618 1
		       __FUNCTION__, i);
d636 1
a636 1
			    __FUNCTION__, *hlimp,
d646 1
a646 1
			    __FUNCTION__, icp->icmp6_code,
d656 1
a656 1
			    __FUNCTION__,
d673 1
a673 1
			    __FUNCTION__, *hlimp,
d683 1
a683 1
			    __FUNCTION__, icp->icmp6_code,
d693 1
a693 1
			    __FUNCTION__,
d705 1
a705 1
			    __FUNCTION__);
d719 1
a719 1
		    __FUNCTION__, icp->icmp6_type);
d736 1
a736 1
	       __FUNCTION__,
d748 1
a748 1
		       __FUNCTION__,
d765 1
a765 1
		       __FUNCTION__,
d779 1
a779 1
		       __FUNCTION__,
d829 1
a829 1
			       __FUNCTION__);
d870 1
a870 1
	       __FUNCTION__,
d883 1
a883 1
		       __FUNCTION__,
d897 1
a897 1
		       __FUNCTION__,
d911 1
a911 1
		       __FUNCTION__,
d925 1
a925 1
		       __FUNCTION__,
d939 1
a939 1
		       __FUNCTION__,
d954 1
a954 1
		       __FUNCTION__,
d969 1
a969 1
		       __FUNCTION__,
d984 1
a984 1
			       __FUNCTION__,
d1039 1
a1039 1
		       __FUNCTION__,
d1052 1
a1052 1
		       __FUNCTION__,
d1080 1
a1080 1
			       __FUNCTION__,
d1095 1
a1095 1
		       __FUNCTION__,
d1116 1
a1116 1
			       __FUNCTION__,
d1131 1
a1131 1
		       __FUNCTION__,
d1206 1
a1206 1
			    __FUNCTION__, hdr->nd_opt_type);
d1213 1
a1213 1
			    __FUNCTION__, hdr->nd_opt_type);
d1219 1
a1219 1
			    __FUNCTION__, hdr->nd_opt_type);
d1231 1
a1231 1
				    __FUNCTION__, hdr->nd_opt_type);
d1246 1
a1246 1
				    __FUNCTION__);
d1294 1
a1294 1
		syslog(LOG_ERR, "<%s> not enough core", __FUNCTION__);
d1302 1
a1302 1
		syslog(LOG_ERR, "<%s> not enough core", __FUNCTION__);
d1307 1
a1307 1
		syslog(LOG_ERR, "<%s> socket: %s", __FUNCTION__,
d1318 1
a1318 1
		       __FUNCTION__, strerror(errno));
d1325 1
a1325 1
		       __FUNCTION__, strerror(errno));
d1336 1
a1336 1
		       __FUNCTION__, strerror(errno));
d1343 1
a1343 1
		       __FUNCTION__, strerror(errno));
d1356 1
a1356 1
		       __FUNCTION__, strerror(errno));
d1367 1
a1367 1
		       __FUNCTION__);
d1375 1
a1375 1
			       __FUNCTION__, ra->ifname, strerror(errno));
d1389 1
a1389 1
			       __FUNCTION__);
d1398 1
a1398 1
				       __FUNCTION__, mcastif);
d1407 1
a1407 1
			       __FUNCTION__,
d1440 1
a1440 1
		       "<%s> socket: %s", __FUNCTION__, strerror(errno));
d1469 1
a1469 1
		       __FUNCTION__, rainfo->ifname);
d1501 1
a1501 1
	       __FUNCTION__, rainfo->ifname, rainfo->waiting); 
d1508 1
a1508 1
			       __FUNCTION__, rainfo->ifname,
d1528 1
a1528 1
				    __FUNCTION__, rainfo->ifname,
d1563 1
a1563 1
	       __FUNCTION__, rai->ifname);
d1600 1
a1600 1
	       __FUNCTION__, rai->ifname,
@


1.20
log
@avoid fd_set overrun.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.19 2002/06/04 05:13:42 itojun Exp $	*/
d325 1
a325 1
		syslog(LOG_DEBUG, "<%s> cease to be an advertising router\n",
@


1.19
log
@use arc4random
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.18 2002/05/29 14:34:05 itojun Exp $	*/
d149 2
a150 1
	fd_set fdset;
a232 2
	FD_ZERO(&fdset);
	FD_SET(sock, &fdset);
a235 1
		FD_SET(rtsock, &fdset);
d241 14
d259 1
a259 1
		struct fd_set select_fd = fdset; /* reinitialize */
d286 2
a287 2
		if ((i = select(maxfd + 1, &select_fd,
				NULL, NULL, timeout)) < 0) {
d296 1
a296 1
		if (rtsock != -1 && FD_ISSET(rtsock, &select_fd))
d298 1
a298 1
		if (FD_ISSET(sock, &select_fd))
@


1.18
log
@KNF, strlcpy, cleanups from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.17 2002/05/21 23:33:56 itojun Exp $	*/
a208 3
	/* random value initialization */
	srandom((u_long)time(NULL));

d809 1
a809 1
		delay = random() % MAX_RA_DELAY_TIME;
d1570 1
a1570 1
	interval += random() % (rai->maxinterval - rai->mininterval);
@


1.17
log
@duplicated prototype
@
text
@d1 2
a2 2
/*	$OpenBSD: rtadvd.c,v 1.16 2002/05/21 23:29:46 itojun Exp $	*/
/*	$KAME: rtadvd.c,v 1.50 2001/02/04 06:15:15 itojun Exp $	*/
a84 3
#ifdef MIP6
int mobileip6 = 0;
#endif
d96 1
a96 1
	struct nd_opt_hdr *nd_opt_array[7];
d122 1
a122 1
	NDOPT_FLAG_PREFIXINFO, NDOPT_FLAG_RDHDR, NDOPT_FLAG_MTU
a155 3
#ifdef MIP6
#define OPTIONS "c:dDfM:mRs"
#else
a156 1
#endif
a174 5
#ifdef MIP6
		case 'm':
			mobileip6 = 1;
			break;
#endif
a189 3
#ifdef MIP6
			"usage: rtadvd [-dDfMmRs] [-c conffile] "
#else
a190 1
#endif
d512 1
a512 1
		} else if ((oldifflags & IFF_UP) == 0 &&	/* DOWN to UP */
d736 1
a736 1
			 &ndopts, NDOPT_FLAG_SRCLINKADDR)) {
a1200 3
#ifdef MIP6
		if (hdr->nd_opt_type > ND_OPT_HOMEAGENT_INFO)
#else
a1201 1
#endif
a1218 4
#ifdef MIP6
		case ND_OPT_ADVINTERVAL:
		case ND_OPT_HOMEAGENT_INFO:
#endif
@


1.16
log
@minor KNF.  plug a memory leak on reconfig.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.15 2002/02/17 19:42:39 millert Exp $	*/
a145 2

struct prefix *find_prefix(struct rainfo *, struct in6_addr *, int);
@


1.15
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.14 2002/02/16 21:28:08 millert Exp $	*/
d158 1
a158 3
	int fflag = 0;

	openlog("rtadvd", LOG_NDELAY|LOG_PID, LOG_DAEMON);
d168 13
a180 13
		switch(ch) {
		 case 'c':
			 conffile = optarg;
			 break;
		 case 'd':
			 dflag = 1;
			 break;
		 case 'D':
			 dflag = 2;
			 break;
		 case 'f':
			 fflag = 1;
			 break;
d185 3
a187 3
		 case 'm':
			 mobileip6 = 1;
			 break;
d189 9
a197 9
		 case 'R':
			 fprintf(stderr, "rtadvd: "
				 "the -R option is currently ignored.\n");
			 /* accept_rr = 1; */
			 /* run anyway... */
			 break;
		 case 's':
			 sflag = 1;
			 break;
d213 5
d249 2
a250 2
		       "<%s> failed to open the pid log file, run anyway.",
		       __FUNCTION__);
d268 1
a268 1
		fd_set select_fd = fdset; /* reinitialize */
d285 4
a288 5
			       "<%s> set timer to %ld:%ld. waiting for "
			       "inputs or timeout",
			       __FUNCTION__,
			       (long int)timeout->tv_sec,
			       (long int)timeout->tv_usec);
d291 2
a292 2
			       "<%s> there's no timer. waiting for inputs",
			       __FUNCTION__);
d300 1
a300 1
				       __FUNCTION__, strerror(errno));
d365 2
a366 5
		syslog(LOG_DEBUG,
		       "<%s> received a routing message "
		       "(type = %d, len = %d)",
		       __FUNCTION__,
		       rtmsg_type(msg), n);
d375 4
a378 4
			       "<%s> received data length is larger than"
			       "1st routing message len. multiple messages?"
			       " read %d bytes, but 1st msg len = %d",
			       __FUNCTION__, n, rtmsg_len(msg));
d433 14
a446 15
		switch(type) {
		 case RTM_ADD:
			 /* init ifflags because it may have changed */
			 iflist[ifindex]->ifm_flags =
			 	if_getflags(ifindex,
					    iflist[ifindex]->ifm_flags);

			 if (sflag)
				 break;	/* we aren't interested in prefixes  */

			 addr = get_addr(msg);
			 plen = get_prefixlen(msg);
			 /* sanity check for plen */
			 if (plen < 4 /* as RFC2373, prefixlen is at least 4 */
			     || plen > 127) {
d448 2
a449 2
				       "plen %d is invalid for a prefix",
				       __FUNCTION__, plen);
d451 13
a463 37
			 }
			 prefix = find_prefix(rai, addr, plen);
			 if (prefix) {
				 if (dflag > 1) {
					 syslog(LOG_DEBUG,
						"<%s> new prefix(%s/%d) "
						"added on %s, "
						"but it was already in list",
						__FUNCTION__,
						inet_ntop(AF_INET6,
							  addr, (char *)addrbuf,
							  INET6_ADDRSTRLEN),
						plen,
						rai->ifname);
				 }
				 break;
			 }
			 make_prefix(rai, ifindex, addr, plen);
			 break;
		 case RTM_DELETE:
			 /* init ifflags because it may have changed */
			 iflist[ifindex]->ifm_flags =
			 	if_getflags(ifindex,
					    iflist[ifindex]->ifm_flags);

			 if (sflag)
				 break;

			 addr = get_addr(msg);
			 plen = get_prefixlen(msg);
			 /* sanity check for plen */
			 if (plen < 4 /* as RFC2373, prefixlen is at least 4 */
			     || plen > 127) {
				syslog(LOG_INFO, "<%s> deleted interface"
				       "route's"
				       "plen %d is invalid for a prefix",
				       __FUNCTION__, plen);
d465 38
a502 19
			 }
			 prefix = find_prefix(rai, addr, plen);
			 if (prefix == NULL) {
				 if (dflag > 1) {
					 syslog(LOG_DEBUG,
						"<%s> prefix(%s/%d) was "
						"deleted on %s, "
						"but it was not in list",
						__FUNCTION__,
						inet_ntop(AF_INET6,
							  addr, (char *)addrbuf,
							  INET6_ADDRSTRLEN),
						plen,
						rai->ifname);
				 }
				 break;
			 }
			 delete_prefix(rai, prefix);
			 break;
d505 4
a508 5
			 /* init ifflags because it may have changed */
			 iflist[ifindex]->ifm_flags =
			 	if_getflags(ifindex,
					    iflist[ifindex]->ifm_flags);
			 break;
d510 2
a511 2
			 iflist[ifindex]->ifm_flags = get_ifm_flags(next);
			 break;
d516 3
a518 3
				       "<%s:%d> unknown rtmsg %d on %s",
				       __FUNCTION__, __LINE__, type,
				       if_indextoname(ifindex, ifname));
d527 2
a528 2
			       "<%s> interface %s becomes down. stop timer.",
			       __FUNCTION__, rai->ifname);
d530 1
a530 2
		}
		else if ((oldifflags & IFF_UP) == 0 &&	/* DOWN to UP */
d533 2
a534 2
			       "<%s> interface %s becomes up. restart timer.",
			       __FUNCTION__, rai->ifname);
d539 1
a539 2
						      ra_timer_update,
						      rai, rai);
d634 96
a729 98
	switch(icp->icmp6_type) {
	 case ND_ROUTER_SOLICIT:
		 /*
		  * Message verification - RFC-2461 6.1.1
		  * XXX: these checks must be done in the kernel as well,
		  *      but we can't completely rely on them.
		  */
		 if (*hlimp != 255) {
			 syslog(LOG_NOTICE,
				"<%s> RS with invalid hop limit(%d) "
				"received from %s on %s",
				__FUNCTION__, *hlimp,
				inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
					  INET6_ADDRSTRLEN),
				if_indextoname(pi->ipi6_ifindex, ifnamebuf));
			 return;
		 }
		 if (icp->icmp6_code) {
			 syslog(LOG_NOTICE,
				"<%s> RS with invalid ICMP6 code(%d) "
				"received from %s on %s",
				__FUNCTION__, icp->icmp6_code,
				inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
					  INET6_ADDRSTRLEN),
				if_indextoname(pi->ipi6_ifindex, ifnamebuf));
			 return;
		 }
		 if (i < sizeof(struct nd_router_solicit)) {
			 syslog(LOG_NOTICE,
				"<%s> RS from %s on %s does not have enough "
				"length (len = %d)",
				__FUNCTION__,
				inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
					  INET6_ADDRSTRLEN),
				if_indextoname(pi->ipi6_ifindex, ifnamebuf), i);
			 return;
		 }
		 rs_input(i, (struct nd_router_solicit *)icp, pi, &from);
		 break;
	 case ND_ROUTER_ADVERT:
		 /*
		  * Message verification - RFC-2461 6.1.2
		  * XXX: there's a same dilemma as above... 
		  */
		 if (*hlimp != 255) {
			 syslog(LOG_NOTICE,
				"<%s> RA with invalid hop limit(%d) "
				"received from %s on %s",
				__FUNCTION__, *hlimp,
				inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
					  INET6_ADDRSTRLEN),
				if_indextoname(pi->ipi6_ifindex, ifnamebuf));
			 return;
		 }
		 if (icp->icmp6_code) {
			 syslog(LOG_NOTICE,
				"<%s> RA with invalid ICMP6 code(%d) "
				"received from %s on %s",
				__FUNCTION__, icp->icmp6_code,
				inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
					  INET6_ADDRSTRLEN),
				if_indextoname(pi->ipi6_ifindex, ifnamebuf));
			 return;
		 }
		 if (i < sizeof(struct nd_router_advert)) {
			 syslog(LOG_NOTICE,
				"<%s> RA from %s on %s does not have enough "
				"length (len = %d)",
				__FUNCTION__,
				inet_ntop(AF_INET6, &from.sin6_addr, ntopbuf,
					  INET6_ADDRSTRLEN),
				if_indextoname(pi->ipi6_ifindex, ifnamebuf), i);
			 return;
		 }
		 ra_input(i, (struct nd_router_advert *)icp, pi, &from);
		 break;
	 case ICMP6_ROUTER_RENUMBERING:
		 if (accept_rr == 0) {
			 syslog(LOG_ERR,
				"<%s> received a router renumbering "
				"message, but not allowed to be accepted",
				__FUNCTION__);
			 break;
		 }
		 rr_input(i, (struct icmp6_router_renum *)icp, pi, &from,
			  &dst);
		 break;
	 default:
		 /*
		  * Note that this case is POSSIBLE, especially just
		  * after invocation of the daemon. This is because we
		  * could receive message after opening the socket and
		  * before setting ICMP6 type filter(see sock_open()).
		  */
		 syslog(LOG_ERR,
			"<%s> invalid icmp type(%d)",
			__FUNCTION__, icp->icmp6_type);
		 return;
d813 1
a813 1
			ra->soliciter = sol->next;
d1099 1
a1099 2
	}
	else if (preferred_time != pp->preflifetime) {
d1135 1
a1135 2
	}
	else if (valid_time != pp->validlifetime) {
d1159 1
d1166 1
d1169 3
a1171 2
		if (prefix->s6_addr[bytelen] >> (8 - bitlen) ==
		    pp->prefix.s6_addr[bytelen] >> (8 - bitlen))
d1173 1
d1185 1
d1191 1
d1194 3
a1196 2
	if (p0->s6_addr[bytelen] >> (8 - bitlen) ==
	    p1->s6_addr[bytelen] >> (8 - bitlen))
d1198 1
d1214 2
a1215 2
			       "<%s> bad ND option length(0) (type = %d)",
			       __FUNCTION__, hdr->nd_opt_type);
d1219 8
a1226 5
		if (hdr->nd_opt_type > ND_OPT_MTU) {
			syslog(LOG_INFO,
			       "<%s> unknown ND option(type %d)",
			       __FUNCTION__,
			       hdr->nd_opt_type);
d1231 2
a1232 4
			syslog(LOG_INFO,
			       "<%s> unexpected ND option(type %d)",
			       __FUNCTION__,
			       hdr->nd_opt_type);
d1236 38
a1273 37
		switch(hdr->nd_opt_type) {
		 case ND_OPT_SOURCE_LINKADDR:
		 case ND_OPT_TARGET_LINKADDR:
		 case ND_OPT_REDIRECTED_HEADER:
		 case ND_OPT_MTU:
			 if (ndopts->nd_opt_array[hdr->nd_opt_type]) {
				 syslog(LOG_INFO,
					"<%s> duplicated ND option"
					" (type = %d)",
					__FUNCTION__,
					hdr->nd_opt_type);
			 }
			 ndopts->nd_opt_array[hdr->nd_opt_type] = hdr;
			 break;
		 case ND_OPT_PREFIX_INFORMATION:
		 {
			 struct nd_optlist *pfxlist;

			 if (ndopts->nd_opts_pi == 0) {
				 ndopts->nd_opts_pi =
					 (struct nd_opt_prefix_info *)hdr;
				 continue;
			 }
			 if ((pfxlist = malloc(sizeof(*pfxlist))) == NULL) {
				 syslog(LOG_ERR,
					"<%s> can't allocate memory",
					__FUNCTION__);
				 goto bad;
			 }
			 pfxlist->next = ndopts->nd_opts_list;
			 pfxlist->opt = hdr;
			 ndopts->nd_opts_list = pfxlist;

			 break;
		 }
		 default:	/* impossible */
			 break;
d1290 1
a1290 1
	while(opt) {
d1387 1
a1387 1
	while(ra) {
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.13 2002/01/11 03:51:08 itojun Exp $	*/
d134 8
a141 8
static void rs_input __P((int, struct nd_router_solicit *,
			  struct in6_pktinfo *, struct sockaddr_in6 *));
static void ra_input __P((int, struct nd_router_advert *,
			  struct in6_pktinfo *, struct sockaddr_in6 *));
static int prefix_check __P((struct nd_opt_prefix_info *, struct rainfo *,
			     struct sockaddr_in6 *));
static int nd6_options __P((struct nd_opt_hdr *, int,
			    union nd_opts *, u_int32_t));
@


1.13
log
@call daemon(3) prior to socket setups to avoid file descriptor close mistakes.
noted by markus, sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.12 2001/12/01 23:27:23 miod Exp $	*/
d128 6
a133 6
int main __P((int, char *[]));
static void set_die __P((int));
static void die __P((void));
static void sock_open __P((void));
static void rtsock_open __P((void));
static void rtadvd_input __P((void));
d142 4
a145 4
static void free_ndopts __P((union nd_opts *));
static void ra_output __P((struct rainfo *));
static void rtmsg_input __P((void));
static void rtadvd_set_dump_file __P((void));
d147 1
a147 1
struct prefix *find_prefix __P((struct rainfo *, struct in6_addr *, int));
@


1.12
log
@Use pidfile() instead of doing the equivalent thing by hand, and sometimes
forgetting to unlink the pid file at exit.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.11 2001/12/01 19:27:28 deraadt Exp $	*/
a236 1
	sock_open();
d240 2
@


1.11
log
@fd_set, not struct fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.10 2001/11/17 19:49:40 deraadt Exp $	*/
d58 2
a81 1
static char *pidfilename = "/var/run/rtadvd.pid"; /* should be configurable */
a158 2
	FILE *pidfp;
	pid_t pid;
d243 1
a243 2
	pid = getpid();
	if ((pidfp = fopen(pidfilename, "w")) == NULL)
d245 2
a246 5
		       "<%s> failed to open a log file(%s), run anyway.",
		       __FUNCTION__, pidfilename);
	else {
		fprintf(pidfp, "%d\n", pid);
		fclose(pidfp);
@


1.10
log
@use volatile sig_atomic_t where possible; simply volatile i other places
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.9 2001/02/04 06:22:05 itojun Exp $	*/
d269 1
a269 1
		struct fd_set select_fd = fdset; /* reinitialize */
@


1.9
log
@avoid infinite loop when -s is specified (select loop mistake).
make agetent() 32bit clean.  KAME PR 127.
disable -R (router renumbering receiver).  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.8 2001/01/15 11:06:28 itojun Exp $	*/
d71 2
a72 2
static int do_dump;
static int do_die;
@


1.8
log
@sync with latest kame tree.
- reduce chances for signal handler rae condition
- decrease chances for misconfiguration
- feedbacks from router renumbering protocol bakeoff
- cleanups related to mtu handling
@
text
@d1 2
a2 2
/*	$OpenBSD: rtadvd.c,v 1.7 2000/07/06 10:14:48 itojun Exp $	*/
/*	$KAME: rtadvd.c,v 1.47 2001/01/15 05:50:25 itojun Exp $	*/
d82 2
a83 1
int sock, rtsock;
d193 4
a196 1
			 accept_rr = 1;
d257 7
a263 4
	rtsock_open();
	FD_SET(rtsock, &fdset);
	if (rtsock > sock)
		maxfd = rtsock;
d307 1
a307 1
		if (sflag == 0 && FD_ISSET(rtsock, &select_fd))
@


1.7
log
@sync with router renumber struct decl change.
more logs.  make it very sure to close temporary socket.
@
text
@d1 2
a2 2
/*	$OpenBSD: rtadvd.c,v 1.6 2000/05/23 11:33:48 itojun Exp $	*/
/*	$KAME: rtadvd.c,v 1.31 2000/06/23 06:34:51 itojun Exp $	*/
d37 1
d72 1
d78 1
d81 1
d127 2
a128 1
static void die __P((int));
a140 1
static struct rainfo *if_indextorainfo __P((int));
d164 1
a164 1
#define OPTIONS "c:dDfmRs"
d166 1
a166 1
#define OPTIONS "c:dDfRs"
d183 3
d204 1
a204 1
			"usage: rtadvd [-dDfmRs] [-c conffile] "
d206 1
a206 1
			"usage: rtadvd [-dDfRs] [-c conffile] "
d256 1
a256 1
			maxfd = rtsock;
d258 1
a258 1
	signal(SIGTERM, (void *)die);
d269 5
d315 1
a315 1
die(sig)
d318 6
d352 1
a352 1
	u_char ifname[16];
d358 1
a358 1
	n = read(rtsock, msg, 2048);
d897 2
a898 2
			 &ndopts,
			NDOPT_FLAG_PREFIXINFO | NDOPT_FLAG_MTU)) { 
d926 1
a926 1
		syslog(LOG_WARNING,
d940 1
a940 1
		syslog(LOG_WARNING,
d954 1
a954 1
		syslog(LOG_WARNING,
d969 1
a969 1
		syslog(LOG_WARNING,
d984 1
a984 1
		syslog(LOG_WARNING,
d999 1
a999 1
			syslog(LOG_WARNING,
d1013 1
a1013 1
		
d1026 1
a1026 2
	if (inconsistent) {
		printf("RA input %d inconsistents\n", inconsistent);
a1027 1
	}
d1043 1
d1081 30
a1110 2
	if (preferred_time != pp->preflifetime) {
		syslog(LOG_WARNING,
a1121 1
		inconsistent++;
d1125 23
a1147 2
	if (valid_time != pp->validlifetime) {
		syslog(LOG_WARNING,
d1186 20
d1364 1
a1364 1
#endif 
d1381 2
a1382 1
	if (inet_pton(AF_INET6, ALLROUTERS, &mreq.ipv6mr_multiaddr.s6_addr)
d1390 1
a1390 2
		if (setsockopt(sock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
			       &mreq,
d1392 1
a1392 1
			syslog(LOG_ERR, "<%s> IPV6_JOIN_GROUP on %s: %s",
d1398 33
d1463 1
a1463 1
static struct rainfo *
d1491 2
d1597 1
a1597 1
	 * MaxRtrAdvInterval(discovery-v2-02 6.2.4).
@


1.6
log
@forgot to cvs add dump.[ch]
strict prototype
@
text
@d1 2
a2 2
/*	$OpenBSD: rtadvd.c,v 1.5 2000/05/23 11:23:23 itojun Exp $	*/
/*	$KAME: rtadvd.c,v 1.26 2000/05/23 11:31:26 itojun Exp $	*/
d246 3
a248 4
	if (sflag == 0) {
		rtsock_open();
		FD_SET(rtsock, &fdset);
		if (rtsock > sock)
a249 1
	}
d265 12
a276 5
		syslog(LOG_DEBUG,
		       "<%s> set timer to %ld:%ld. waiting for inputs " 
		       "or timeout",
		       __FUNCTION__,
		       (long int)timeout->tv_sec, (long int)timeout->tv_usec);
d351 1
a351 1
		 * an routing socket.
d367 2
d398 1
a398 1
			return;
d409 1
a409 1
			return;
d411 1
d415 1
a415 1
			 /* init iffalgs because it may have changed */
d420 3
d431 1
a431 1
				return;
d447 1
a447 1
				 return;
d457 3
d469 1
a469 1
				return;
d485 1
a485 1
				 return;
d509 23
d590 12
d621 1
a621 1
#endif 
d793 13
d849 1
a849 1
			goto done;
a1362 1

d1365 7
d1411 26
d1463 1
a1463 5
	if (iflist[rai->ifindex]->ifm_flags & IFF_UP)
		ra_output(rai);
	else
		syslog(LOG_DEBUG, "<%s> %s is not up, skip sending RA",
		       __FUNCTION__, rai->ifname);
@


1.5
log
@sync with latest kame.
- weaken logging priority for /etc/resolv.conf open failure
- gather stats, emit stats by SIGUSR1
- use SIOCGIFMTU to get interface MTU (just a matter of #ifdef)
From: "Todd T. Fries" <todd@@fries.net>
@
text
@d1 2
a2 2
/*	$OpenBSD: rtadvd.c,v 1.4 2000/03/13 06:16:11 itojun Exp $	*/
/*	$KAME: rtadvd.c,v 1.24 2000/05/22 21:58:10 itojun Exp $	*/
d63 1
a141 2

extern void rtadvd_dump_file __P((char *));
@


1.4
log
@bring in latest rtadvd source from kame.
this fixes unclosed file descriptor in router renumbering case.
@
text
@d1 2
a2 1
/*	$OpenBSD: rtadvd.c,v 1.3 2000/02/02 04:10:37 itojun Exp $	*/
d69 1
d75 2
d130 2
a131 2
static void prefix_check __P((struct nd_opt_prefix_info *, struct rainfo *,
			      struct sockaddr_in6 *));
d138 2
d142 1
d154 2
d157 1
a157 1
	openlog(*argv, LOG_NDELAY|LOG_PID, LOG_DAEMON);
d233 11
d254 2
a255 1
	signal(SIGTERM, die);
d260 5
d272 1
a272 1
		       timeout->tv_sec, timeout->tv_usec);
d275 5
a279 3
				NULL, NULL, timeout)) < 0){
			syslog(LOG_ERR, "<%s> select: %s",
			       __FUNCTION__, strerror(errno));
d293 6
d327 1
a327 1
	int n, type, ifindex, plen;
d736 2
d805 1
d842 2
d856 1
d870 1
d884 1
d899 1
d914 1
d928 1
d935 4
a938 2
		if (ndopts.nd_opts_pi)
			prefix_check(ndopts.nd_opts_pi, rai, from);
d940 3
a942 2
			prefix_check((struct nd_opt_prefix_info *)optp->opt,
				     rai, from);
d946 5
d957 2
a958 1
static void
d964 1
d969 1
a969 1
		return;
d999 1
a999 1
		return;
d1003 1
a1003 1
	if (preferred_time != pp->preflifetime)
d1016 2
d1020 1
a1020 1
	if (valid_time != pp->validlifetime)
d1033 4
d1347 1
d1409 2
a1410 1
	       __FUNCTION__, rai->ifname, tm->tv_sec, tm->tv_usec);
@


1.3
log
@add -R flag (accept router renumbering).  this makes rtadvd to
take the safer side (router renumbering requires certain ipsec setup).
die gracefully on SIGTERM.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtadvd.c,v 1.2 1999/12/11 10:33:29 itojun Exp $	*/
d50 1
d64 4
a67 2
static u_char rcvcmsgbuf[CMSG_SPACE(sizeof(struct in6_pktinfo)) +
			CMSG_SPACE(sizeof(int))];
d74 3
d151 7
a157 1
	while ((ch = getopt(argc, argv, "c:dDfRs")) != -1) {
d171 5
d188 5
a192 1
			"usage: rtadvd [-dDfsR] [-c conffile] "
d487 1
a487 1
	rcvmhdr.msg_controllen = sizeof(rcvcmsgbuf);
d1100 16
a1115 2
	static u_char sndcmsgbuf[CMSG_SPACE(sizeof(struct in6_pktinfo)) + 
				CMSG_SPACE(sizeof(int))];
d1200 1
a1200 1
	rcvmhdr.msg_controllen = sizeof(rcvcmsgbuf);
d1207 1
a1207 1
	sndmhdr.msg_controllen = sizeof(sndcmsgbuf);
@


1.2
log
@enable rtadvd in usr.sbin/Makefile.
rcsid police on usr.sbin/rtadvd.
add sample config into etc/rtadvd.conf.
add files into distrib/sets/list.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
a71 1
int accept_rr = 1;
d112 1
d145 1
a145 1
	while ((ch = getopt(argc, argv, "c:dDfs")) != -1) {
d159 3
d164 1
d171 1
a171 1
			"usage: rtadvd [-c conffile] [-d|D] [-f] [-s]"
d213 2
d244 26
d1090 8
d1104 1
d1108 8
d1122 1
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@router advertisement daemon, from KAME
@
text
@@
