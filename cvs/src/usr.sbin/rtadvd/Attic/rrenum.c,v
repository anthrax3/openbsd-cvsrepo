head	1.19;
access;
symbols
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.6
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.10.0.24
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.22
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.20
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.18
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.16
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.14
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.12
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.10
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.8
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.6
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	kame_19991211:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.11.30.20.52.28;	author jca;	state dead;
branches;
next	1.18;
commitid	0AFsvIbwpuBr4CTd;

1.18
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2014.06.29.00.58.45;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	JPNyzoRAXfnuJx1K;

1.16
date	2013.10.17.16.27.48;	author bluhm;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.18.07.34.59;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.26.18.26.21;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.23.10.17.50;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.21.20.40.55;	author rainer;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.10.19.57.35;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.29.14.34.05;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.21.23.29.46;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.21.15.42.36;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.15.11.06.27;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.06.10.14.47;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.23.11.23.23;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.13.06.16.11;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.11.10.33.28;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.11.10.23.27;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.11.10.23.27;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove the already disabled Router Renumbering support (RFC2894).

This code has only been reachable for two months after rtadvd has been
imported into the tree.  This unsafe protocol is supposed to be used
along with IPsec and rrenumd(8), a KAME tool that we don't have.
I couldn't find an example of use in the real world.

ok sthen@@ florian@@ millter@@
@
text
@/*	$OpenBSD: rrenum.c,v 1.18 2015/01/16 06:40:20 deraadt Exp $	*/
/*	$KAME: rrenum.c,v 1.11 2002/05/21 14:26:55 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <netinet/icmp6.h>

#include <arpa/inet.h>

#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include "rtadvd.h"
#include "rrenum.h"
#include "if.h"
#include "log.h"

#define	RR_ISSET_SEGNUM(segnum_bits, segnum) \
	((((segnum_bits)[(segnum) >> 5]) & (1 << ((segnum) & 31))) != 0)
#define	RR_SET_SEGNUM(segnum_bits, segnum) \
	(((segnum_bits)[(segnum) >> 5]) |= (1 << ((segnum) & 31)))

struct rr_operation {
	u_long	rro_seqnum;
	u_long	rro_segnum_bits[8];
};

static struct rr_operation rro;
static int rr_rcvifindex;
static int rrcmd2pco[RPM_PCO_MAX] = {
	0,
	SIOCAIFPREFIX_IN6,
	SIOCCIFPREFIX_IN6,
	SIOCSGIFPREFIX_IN6
};
static int s = -1;

/*
 * Check validity of a Prefix Control Operation(PCO).
 * Return 0 on success, 1 on failure.
 */
static int
rr_pco_check(int len, struct rr_pco_match *rpm)
{
	struct rr_pco_use *rpu, *rpulim;
	int checklen;

	/* rpm->rpm_len must be (4N * 3) as router-renum-05.txt */
	if ((rpm->rpm_len - 3) < 0 || /* must be at least 3 */
	    (rpm->rpm_len - 3) & 0x3) { /* must be multiple of 4 */
		log_warnx("rpm_len %d is not 4N * 3", rpm->rpm_len);
		return 1;
	}
	/* rpm->rpm_code must be valid value */
	switch (rpm->rpm_code) {
	case RPM_PCO_ADD:
	case RPM_PCO_CHANGE:
	case RPM_PCO_SETGLOBAL:
		break;
	default:
		log_warnx("unknown rpm_code %d", rpm->rpm_code);
		return 1;
	}
	/* rpm->rpm_matchlen must be 0 to 128 inclusive */
	if (rpm->rpm_matchlen > 128) {
		log_warnx("rpm_matchlen %d is over 128", rpm->rpm_matchlen);
		return 1;
	}

	/*
	 * rpu->rpu_uselen, rpu->rpu_keeplen, and sum of them must be
	 * between 0 and 128 inclusive
	 */
	for (rpu = (struct rr_pco_use *)(rpm + 1),
	     rpulim = (struct rr_pco_use *)((char *)rpm + len);
	     rpu < rpulim;
	     rpu += 1) {
		checklen = rpu->rpu_uselen;
		checklen += rpu->rpu_keeplen;
		/*
		 * omit these check, because either of rpu_uselen
		 * and rpu_keeplen is unsigned char
		 *  (128 > rpu_uselen > 0)
		 *  (128 > rpu_keeplen > 0)
		 *  (rpu_uselen + rpu_keeplen > 0)
		 */
		if (checklen > 128) {
			log_warnx("sum of rpu_uselen %d and"
			    " rpu_keeplen %d is %d(over 128)",
			    rpu->rpu_uselen,
			    rpu->rpu_keeplen,
			    rpu->rpu_uselen + rpu->rpu_keeplen);
			return 1;
		}
	}
	return 0;
}

static void
do_use_prefix(int len, struct rr_pco_match *rpm,
	      struct in6_rrenumreq *irr, int ifindex)
{
	struct rr_pco_use *rpu, *rpulim;
	struct rainfo *rai;
	struct prefix *pp;

	rpu = (struct rr_pco_use *)(rpm + 1);
	rpulim = (struct rr_pco_use *)((char *)rpm + len);

	if (rpu == rpulim) {	/* no use prefix */
		if (rpm->rpm_code == RPM_PCO_ADD)
			return;

		irr->irr_u_uselen = 0;
		irr->irr_u_keeplen = 0;
		irr->irr_raf_mask_onlink = 0;
		irr->irr_raf_mask_auto = 0;
		irr->irr_vltime = 0;
		irr->irr_pltime = 0;
		memset(&irr->irr_flags, 0, sizeof(irr->irr_flags));
		irr->irr_useprefix.sin6_len = 0; /* let it mean, no addition */
		irr->irr_useprefix.sin6_family = 0;
		irr->irr_useprefix.sin6_addr = in6addr_any;
		if (ioctl(s, rrcmd2pco[rpm->rpm_code], (caddr_t)irr) < 0 &&
		    errno != EADDRNOTAVAIL)
			log_warn("ioctl");
		return;
	}

	for (rpu = (struct rr_pco_use *)(rpm + 1),
	     rpulim = (struct rr_pco_use *)((char *)rpm + len);
	     rpu < rpulim;
	     rpu += 1) {
		/* init in6_rrenumreq fields */
		irr->irr_u_uselen = rpu->rpu_uselen;
		irr->irr_u_keeplen = rpu->rpu_keeplen;
		irr->irr_raf_mask_onlink =
			(rpu->rpu_ramask & ICMP6_RR_PCOUSE_RAFLAGS_ONLINK) == 0 ? 0 : 1;
		irr->irr_raf_mask_auto =
			(rpu->rpu_ramask & ICMP6_RR_PCOUSE_RAFLAGS_AUTO) == 0 ? 0 : 1;
		irr->irr_vltime = ntohl(rpu->rpu_vltime);
		irr->irr_pltime = ntohl(rpu->rpu_pltime);
		irr->irr_raf_onlink =
			(rpu->rpu_raflags & ICMP6_RR_PCOUSE_RAFLAGS_ONLINK) == 0 ? 0 : 1;
		irr->irr_raf_auto =
			(rpu->rpu_raflags & ICMP6_RR_PCOUSE_RAFLAGS_AUTO) == 0 ? 0 : 1;
		irr->irr_rrf_decrvalid =
			(rpu->rpu_flags & ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME) == 0 ? 0 : 1;
		irr->irr_rrf_decrprefd =
			(rpu->rpu_flags & ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME) == 0 ? 0 : 1;
		irr->irr_useprefix.sin6_len = sizeof(irr->irr_useprefix);
		irr->irr_useprefix.sin6_family = AF_INET6;
		irr->irr_useprefix.sin6_addr = rpu->rpu_prefix;

		if (ioctl(s, rrcmd2pco[rpm->rpm_code], (caddr_t)irr) < 0 &&
		    errno != EADDRNOTAVAIL)
			log_warn("ioctl");

		/* very adhoc: should be rewritten */
		if (rpm->rpm_code == RPM_PCO_CHANGE &&
		    IN6_ARE_ADDR_EQUAL(&rpm->rpm_prefix, &rpu->rpu_prefix) &&
		    rpm->rpm_matchlen == rpu->rpu_uselen &&
		    rpu->rpu_uselen == rpu->rpu_keeplen) {
			if ((rai = if_indextorainfo(ifindex)) == NULL)
				continue; /* non-advertising IF */

			TAILQ_FOREACH(pp, &rai->prefixes, entry) {
				struct timeval now;

				if (prefix_match(&pp->prefix, pp->prefixlen,
						 &rpm->rpm_prefix,
						 rpm->rpm_matchlen)) {
					/* change parameters */
					pp->validlifetime = ntohl(rpu->rpu_vltime);
					pp->preflifetime = ntohl(rpu->rpu_pltime);
					if (irr->irr_rrf_decrvalid) {
						gettimeofday(&now, 0);
						pp->vltimeexpire =
							now.tv_sec + pp->validlifetime;
					} else
						pp->vltimeexpire = 0;
					if (irr->irr_rrf_decrprefd) {
						gettimeofday(&now, 0);
						pp->pltimeexpire =
							now.tv_sec + pp->preflifetime;
					} else
						pp->pltimeexpire = 0;
				}
			}
		}
	}
}

/*
 * process a Prefix Control Operation(PCO).
 * return 0 on success, 1 on failure
 */
static int
do_pco(struct icmp6_router_renum *rr, int len, struct rr_pco_match *rpm)
{
	int ifindex = 0;
	struct in6_rrenumreq irr;

	if ((rr_pco_check(len, rpm) != 0))
		return 1;

	if (s == -1 && (s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		fatal("socket");

	memset(&irr, 0, sizeof(irr));
	irr.irr_origin = PR_ORIG_RR;
	irr.irr_m_len = rpm->rpm_matchlen;
	irr.irr_m_minlen = rpm->rpm_minlen;
	irr.irr_m_maxlen = rpm->rpm_maxlen;
	irr.irr_matchprefix.sin6_len = sizeof(irr.irr_matchprefix);
	irr.irr_matchprefix.sin6_family = AF_INET6;
	irr.irr_matchprefix.sin6_addr = rpm->rpm_prefix;

	while (if_indextoname(++ifindex, irr.irr_name)) {
		/*
		 * if ICMP6_RR_FLAGS_FORCEAPPLY(A flag) is 0 and IFF_UP is off,
		 * the interface is not applied
		 */
		if ((rr->rr_flags & ICMP6_RR_FLAGS_FORCEAPPLY) == 0 &&
		    (iflist[ifindex]->ifm_flags & IFF_UP) == 0)
			continue;
		/* TODO: interface scope check */
		do_use_prefix(len, rpm, &irr, ifindex);
	}
	if (errno == ENXIO)
		return 0;
	else if (errno) {
		log_warn("if_indextoname");
		return 1;
	}
	return 0;
}

/*
 * call do_pco() for each Prefix Control Operations(PCOs) in a received
 * Router Renumbering Command packet.
 * return 0 on success, 1 on failure
 */
static int
do_rr(int len, struct icmp6_router_renum *rr)
{
	struct rr_pco_match *rpm;
	char *cp, *lim;

	lim = (char *)rr + len;
	cp = (char *)(rr + 1);
	len -= sizeof(struct icmp6_router_renum);

	/* get iflist block from kernel again, to get up-to-date information */
	init_iflist();

	while (cp < lim) {
		int rpmlen;

		rpm = (struct rr_pco_match *)cp;
		if (len < sizeof(struct rr_pco_match)) {
		    tooshort:
			log_warnx("pkt too short. left len = %d. "
			    "garbage at end of pkt?", len);
			return 1;
		}
		rpmlen = rpm->rpm_len << 3;
		if (len < rpmlen)
			goto tooshort;

		if (do_pco(rr, rpmlen, rpm)) {
			log_warn("invalid PCO");
			goto next;
		}

	    next:
		cp += rpmlen;
		len -= rpmlen;
	}

	return 0;
}

/*
 * check validity of a router renumbering command packet
 * return 0 on success, 1 on failure
 */
static int
rr_command_check(int len, struct icmp6_router_renum *rr, struct in6_addr *from,
		 struct in6_addr *dst)
{
	u_char ntopbuf[INET6_ADDRSTRLEN];

	/* omit rr minimal length check. hope kernel have done it. */
	/* rr_command length check */
	if (len < (sizeof(struct icmp6_router_renum) +
		   sizeof(struct rr_pco_match))) {
		log_warnx("rr_command len %d is too short", len);
		return 1;
	}

	/* destination check. only for multicast. omit unicast check. */
	if (IN6_IS_ADDR_MULTICAST(dst) && !IN6_IS_ADDR_MC_LINKLOCAL(dst) &&
	    !IN6_IS_ADDR_MC_SITELOCAL(dst)) {
		log_warnx("dst mcast addr %s is illegal",
		    inet_ntop(AF_INET6, dst, ntopbuf, INET6_ADDRSTRLEN));
		return 1;
	}

	/* seqnum and segnum check */
	if (rro.rro_seqnum > rr->rr_seqnum) {
		log_warnx("rcvd old seqnum %d from %s",
		    (u_int32_t)ntohl(rr->rr_seqnum),
		    inet_ntop(AF_INET6, from, ntopbuf, INET6_ADDRSTRLEN));
		return 1;
	}
	if (rro.rro_seqnum == rr->rr_seqnum &&
	    (rr->rr_flags & ICMP6_RR_FLAGS_TEST) == 0 &&
	    RR_ISSET_SEGNUM(rro.rro_segnum_bits, rr->rr_segnum)) {
		if ((rr->rr_flags & ICMP6_RR_FLAGS_REQRESULT) != 0)
			log_warnx("rcvd duped segnum %d from %s",
			    rr->rr_segnum,
			    inet_ntop(AF_INET6, from, ntopbuf,
				INET6_ADDRSTRLEN));
		return 0;
	}

	/* update seqnum */
	if (rro.rro_seqnum != rr->rr_seqnum) {
		/* then must be "<" */

		/* init rro_segnum_bits */
		memset(rro.rro_segnum_bits, 0,
		       sizeof(rro.rro_segnum_bits));
	}
	rro.rro_seqnum = rr->rr_seqnum;

	return 0;
}

static void
rr_command_input(int len, struct icmp6_router_renum *rr,
		 struct in6_addr *from, struct in6_addr *dst)
{
	/* rr_command validity check */
	if (rr_command_check(len, rr, from, dst))
		goto failed;
	if ((rr->rr_flags & (ICMP6_RR_FLAGS_TEST|ICMP6_RR_FLAGS_REQRESULT)) ==
	    ICMP6_RR_FLAGS_TEST)
		return;

	/* do router renumbering */
	if (do_rr(len, rr)) {
		goto failed;
	}

	/* update segnum */
	RR_SET_SEGNUM(rro.rro_segnum_bits, rr->rr_segnum);

	return;

    failed:
	log_warnx("received RR was invalid");
	return;
}

void
rr_input(int len, struct icmp6_router_renum *rr, struct in6_pktinfo *pi,
	 struct sockaddr_in6 *from, struct in6_addr *dst)
{
	u_char ntopbuf[2][INET6_ADDRSTRLEN], ifnamebuf[IFNAMSIZ];

	log_debug("RR received from %s to %s on %s",
	    inet_ntop(AF_INET6, &from->sin6_addr,
		ntopbuf[0], INET6_ADDRSTRLEN),
	   inet_ntop(AF_INET6, &dst, ntopbuf[1], INET6_ADDRSTRLEN),
	   if_indextoname(pi->ipi6_ifindex, ifnamebuf));

	/* packet validation based on Section 4.1 of RFC2894 */
	if (len < sizeof(struct icmp6_router_renum)) {
		log_info("RR short message (size %d) from %s to %s on %s",
		    len,
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf[0], INET6_ADDRSTRLEN),
		    inet_ntop(AF_INET6, &dst, ntopbuf[1], INET6_ADDRSTRLEN),
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		return;
	}

	/*
	 * If the IPv6 destination address is neither an All Routers multicast
	 * address [AARCH] nor one of the receiving router's unicast addresses,
	 * the message MUST be discarded and SHOULD be logged to network
	 * management.
	 * We rely on the kernel input routine for unicast addresses, and thus
	 * check multicast destinations only.
	 */
	if (IN6_IS_ADDR_MULTICAST(&pi->ipi6_addr) &&
	    !IN6_ARE_ADDR_EQUAL(&in6a_site_allrouters, &pi->ipi6_addr)) {
		log_info("RR message with invalid destination (%s) "
		    "from %s on %s",
		    inet_ntop(AF_INET6, &dst, ntopbuf[0], INET6_ADDRSTRLEN),
		    inet_ntop(AF_INET6, &from->sin6_addr,
			ntopbuf[1], INET6_ADDRSTRLEN),
		    if_indextoname(pi->ipi6_ifindex, ifnamebuf));
		return;
	}

	rr_rcvifindex = pi->ipi6_ifindex;

	switch (rr->rr_code) {
	case ICMP6_ROUTER_RENUMBERING_COMMAND:
		rr_command_input(len, rr, &from->sin6_addr, dst);
		/* TODO: send reply msg */
		break;
	case ICMP6_ROUTER_RENUMBERING_RESULT:
		/* RESULT will be processed by rrenumd */
		break;
	case ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET:
		/* TODO: sequence number reset */
		break;
	default:
		log_warnx("received unknown code %d", rr->rr_code);
		break;

	}

	return;
}
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.17 2014/06/29 00:58:45 deraadt Exp $	*/
@


1.17
log
@If you want <sys/queue.h>, you need to include it.  Don't assume that
<sys/sysctl.h> will pull in the universe (I am working on breaking that
assumption in a gentle fashion)
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.16 2013/10/17 16:27:48 bluhm Exp $	*/
a32 1
#include <sys/param.h>
@


1.16
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.15 2013/05/18 07:34:59 jmc Exp $	*/
d37 1
@


1.15
log
@gabage->garbage in log string;
from Henning Petersen, netbsd pr 47823
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.14 2011/04/06 11:36:26 miod Exp $	*/
d41 1
a41 1
#include <netinet/in_var.h>
@


1.14
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.13 2010/06/26 18:26:21 guenther Exp $	*/
d300 1
a300 1
			    "gabage at end of pkt?", len);
@


1.13
log
@irr->irr_raf_mask_onlink and irr->irr_raf_mask_auto are single-bit bitfields
so they can only be set to 1 or 0.  Caught by gcc4.

ok mcbride@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.12 2008/04/23 10:17:50 pyr Exp $	*/
d240 1
a240 1
	if ((rr_pco_check(len, rpm) != NULL))
@


1.12
log
@Replace handrolled lists with SLISTs or TAILQs.
Timers remain and will be handled later.
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.11 2008/04/21 20:40:55 rainer Exp $	*/
d174 1
a174 1
			(rpu->rpu_ramask & ICMP6_RR_PCOUSE_RAFLAGS_ONLINK);
d176 1
a176 1
			(rpu->rpu_ramask & ICMP6_RR_PCOUSE_RAFLAGS_AUTO);
@


1.11
log
@Clean up logging by introducing the logging API used in
other daemons and clean up the command line options.
For details, see rtadvd(8).

ok bluhm@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.10 2002/06/10 19:57:35 espie Exp $	*/
d203 1
a203 2
			for (pp = rai->prefix.next; pp != &rai->prefix;
			     pp = pp->next) {
@


1.10
log
@Kill __FUNCTION__.
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.9 2002/05/29 14:34:05 itojun Exp $	*/
a48 1
#include <syslog.h>
d52 1
d87 1
a87 2
		syslog(LOG_WARNING, "<%s> rpm_len %d is not 4N * 3",
		       __func__, rpm->rpm_len);
d97 1
a97 2
		syslog(LOG_WARNING, "<%s> unknown rpm_code %d", __func__,
		       rpm->rpm_code);
d102 1
a102 2
		syslog(LOG_WARNING, "<%s> rpm_matchlen %d is over 128",
		       __func__, rpm->rpm_matchlen);
d124 5
a128 5
			syslog(LOG_WARNING, "<%s> sum of rpu_uselen %d and"
			       " rpu_keeplen %d is %d(over 128)",
			       __func__, rpu->rpu_uselen,
			       rpu->rpu_keeplen,
			       rpu->rpu_uselen + rpu->rpu_keeplen);
d162 1
a162 2
			syslog(LOG_ERR, "<%s> ioctl: %s", __func__,
			       strerror(errno));
d193 1
a193 2
			syslog(LOG_ERR, "<%s> ioctl: %s", __func__,
			       strerror(errno));
d244 2
a245 5
	if (s == -1 && (s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		syslog(LOG_ERR, "<%s> socket: %s", __func__,
		       strerror(errno));
		exit(1);
	}
d270 1
a270 2
		syslog(LOG_ERR, "<%s> if_indextoname: %s", __func__,
		       strerror(errno));
d300 2
a301 2
			syslog(LOG_ERR, "<%s> pkt too short. left len = %d. "
			       "gabage at end of pkt?", __func__, len);
d309 1
a309 1
			syslog(LOG_WARNING, "<%s> invalid PCO", __func__);
d335 1
a335 2
		syslog(LOG_ERR,	"<%s> rr_command len %d is too short",
		       __func__, len);
d342 2
a343 3
		syslog(LOG_ERR,	"<%s> dst mcast addr %s is illegal",
		       __func__,
		       inet_ntop(AF_INET6, dst, ntopbuf, INET6_ADDRSTRLEN));
d349 3
a351 4
		syslog(LOG_WARNING,
		       "<%s> rcvd old seqnum %d from %s",
		       __func__, (u_int32_t)ntohl(rr->rr_seqnum),
		       inet_ntop(AF_INET6, from, ntopbuf, INET6_ADDRSTRLEN));
d358 4
a361 5
			syslog(LOG_WARNING,
			       "<%s> rcvd duped segnum %d from %s",
			       __func__, rr->rr_segnum,
			       inet_ntop(AF_INET6, from, ntopbuf,
					 INET6_ADDRSTRLEN));
d400 1
a400 1
	syslog(LOG_ERR, "<%s> received RR was invalid", __func__);
d410 5
a414 7
	syslog(LOG_DEBUG,
	       "<%s> RR received from %s to %s on %s",
	       __func__,
	       inet_ntop(AF_INET6, &from->sin6_addr,
			 ntopbuf[0], INET6_ADDRSTRLEN),
	       inet_ntop(AF_INET6, &dst, ntopbuf[1], INET6_ADDRSTRLEN),
	       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d418 6
a423 7
		syslog(LOG_NOTICE,
		       "<%s>: RR short message (size %d) from %s to %s on %s",
		       __func__, len,
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf[0], INET6_ADDRSTRLEN),
		       inet_ntop(AF_INET6, &dst, ntopbuf[1], INET6_ADDRSTRLEN),
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d437 6
a442 8
		syslog(LOG_NOTICE,
		       "<%s>: RR message with invalid destination (%s) "
		       "from %s on %s",
		       __func__,
		       inet_ntop(AF_INET6, &dst, ntopbuf[0], INET6_ADDRSTRLEN),
		       inet_ntop(AF_INET6, &from->sin6_addr,
				 ntopbuf[1], INET6_ADDRSTRLEN),
		       if_indextoname(pi->ipi6_ifindex, ifnamebuf));
d460 1
a460 2
		syslog(LOG_ERR,	"<%s> received unknown code %d",
		       __func__, rr->rr_code);
@


1.9
log
@KNF, strlcpy, cleanups from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.8 2002/05/21 23:29:46 itojun Exp $	*/
d88 1
a88 1
		       __FUNCTION__, rpm->rpm_len);
d98 1
a98 1
		syslog(LOG_WARNING, "<%s> unknown rpm_code %d", __FUNCTION__,
d105 1
a105 1
		       __FUNCTION__, rpm->rpm_matchlen);
d129 1
a129 1
			       __FUNCTION__, rpu->rpu_uselen,
d165 1
a165 1
			syslog(LOG_ERR, "<%s> ioctl: %s", __FUNCTION__,
d197 1
a197 1
			syslog(LOG_ERR, "<%s> ioctl: %s", __FUNCTION__,
d250 1
a250 1
		syslog(LOG_ERR, "<%s> socket: %s", __FUNCTION__,
d278 1
a278 1
		syslog(LOG_ERR, "<%s> if_indextoname: %s", __FUNCTION__,
d310 1
a310 1
			       "gabage at end of pkt?", __FUNCTION__, len);
d318 1
a318 1
			syslog(LOG_WARNING, "<%s> invalid PCO", __FUNCTION__);
d345 1
a345 1
		       __FUNCTION__, len);
d353 1
a353 1
		       __FUNCTION__,
d362 1
a362 1
		       __FUNCTION__, (u_int32_t)ntohl(rr->rr_seqnum),
d372 1
a372 1
			       __FUNCTION__, rr->rr_segnum,
d413 1
a413 1
	syslog(LOG_ERR, "<%s> received RR was invalid", __FUNCTION__);
d425 1
a425 1
	       __FUNCTION__,
d435 1
a435 1
		       __FUNCTION__, len,
d456 1
a456 1
		       __FUNCTION__,
d479 1
a479 1
		       __FUNCTION__, rr->rr_code);
@


1.8
log
@minor KNF.  plug a memory leak on reconfig.
@
text
@d1 2
a2 2
/*	$OpenBSD: rrenum.c,v 1.7 2001/01/21 15:42:36 itojun Exp $	*/
/*	$KAME: rrenum.c,v 1.10 2001/01/21 15:32:16 itojun Exp $	*/
a38 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#include <net/if_var.h>
#endif /* __FreeBSD__ >= 3 */
@


1.7
log
@sync router renumbering flag bit to conform to 2292bis-02 and RR RFC.
sync with latest kame rtadvd (again).  mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: rrenum.c,v 1.6 2001/01/15 11:06:27 itojun Exp $	*/
d95 1
a95 1
	switch(rpm->rpm_code) {
@


1.6
log
@sync with latest kame tree.
- reduce chances for signal handler rae condition
- decrease chances for misconfiguration
- feedbacks from router renumbering protocol bakeoff
- cleanups related to mtu handling
@
text
@d1 2
a2 2
/*	$OpenBSD: rrenum.c,v 1.5 2000/07/06 10:14:47 itojun Exp $	*/
/*	$KAME: rrenum.c,v 1.8 2000/11/11 16:37:07 itojun Exp $	*/
@


1.5
log
@sync with router renumber struct decl change.
more logs.  make it very sure to close temporary socket.
@
text
@d1 2
a2 2
/*	$OpenBSD: rrenum.c,v 1.4 2000/05/23 11:23:23 itojun Exp $	*/
/*	$KAME: rrenum.c,v 1.4 2000/07/03 02:51:08 itojun Exp $	*/
d32 1
a32 1

d53 1
d142 3
a144 1
do_use_prefix(int len, struct rr_pco_match *rpm, struct in6_rrenumreq *irr) {
d146 2
d152 1
a152 1
	if (rpu == rpulim) {
d184 2
a185 2
		irr->irr_vltime = rpu->rpu_vltime;
		irr->irr_pltime = rpu->rpu_pltime;
d187 1
a187 1
			(rpu->rpu_raflags & ICMP6_RR_PCOUSE_RAFLAGS_ONLINK);
d189 1
a189 1
			(rpu->rpu_raflags & ICMP6_RR_PCOUSE_RAFLAGS_AUTO);
d191 1
a191 1
			(rpu->rpu_flags & ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME);
d193 1
a193 1
			(rpu->rpu_flags & ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME);
d202 34
d276 1
a276 1
		do_use_prefix(len, rpm, &irr);
d434 33
a467 2

	/* TODO: some consistency check. */
@


1.4
log
@sync with latest kame.
- weaken logging priority for /etc/resolv.conf open failure
- gather stats, emit stats by SIGUSR1
- use SIOCGIFMTU to get interface MTU (just a matter of #ifdef)
From: "Todd T. Fries" <todd@@fries.net>
@
text
@d1 2
a2 2
/*	$OpenBSD: rrenum.c,v 1.3 2000/03/13 06:16:11 itojun Exp $	*/
/*	$KAME: rrenum.c,v 1.3 2000/05/16 13:34:14 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d68 6
a73 5
static int rrcmd2pco[RPM_PCO_MAX] = {0,
				     SIOCAIFPREFIX_IN6,
				     SIOCCIFPREFIX_IN6,
				     SIOCSGIFPREFIX_IN6
				    };
d85 1
a85 1
	
d175 4
a178 2
		irr->irr_raf_mask_onlink = rpu->rpu_mask_onlink;
		irr->irr_raf_mask_auto = rpu->rpu_mask_autonomous;
d181 8
a188 4
		irr->irr_raf_onlink = rpu->rpu_onlink;
		irr->irr_raf_auto = rpu->rpu_autonomous;
		irr->irr_rrf_decrvalid = rpu->rpu_decr_vltime;
		irr->irr_rrf_decrprefd = rpu->rpu_decr_pltime;
d230 1
a230 1
		 * if rr_forceapply(A flag) is 0 and IFF_UP is off,
d233 1
a233 1
		if (!rr->rr_forceapply &&
d250 1
a250 1
 * call do_pco() for each Prefix Control Operations(PCOs) in a received 
d331 1
a331 1
	    rr->rr_test == 0 &&
d333 1
a333 1
		if (rr->rr_reqresult)
d343 1
a343 1
	if (rro.rro_seqnum != rr->rr_seqnum) { 
d362 2
a363 1
	if (rr->rr_test && !rr->rr_reqresult)
@


1.3
log
@bring in latest rtadvd source from kame.
this fixes unclosed file descriptor in router renumbering case.
@
text
@d1 2
a2 1
/*	$OpenBSD: rrenum.c,v 1.2 1999/12/11 10:33:28 itojun Exp $	*/
@


1.2
log
@enable rtadvd in usr.sbin/Makefile.
rcsid police on usr.sbin/rtadvd.
add sample config into etc/rtadvd.conf.
add files into distrib/sets/list.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 1
a72 1
static int s;
d205 1
a205 1
	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@router advertisement daemon, from KAME
@
text
@@
