head	1.45;
access;
symbols
	OPENBSD_6_1:1.41.0.4
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.40.0.2
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.6
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.12
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.10
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	kame_19991211:1.1.1.1
	KAME:1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2017.08.10.19.07.14;	author jca;	state Exp;
branches;
next	1.44;
commitid	NTmGZ5SuATQQ3twg;

1.44
date	2017.07.12.06.11.45;	author florian;	state Exp;
branches;
next	1.43;
commitid	beOkIKv5SJzw42f3;

1.43
date	2017.07.12.06.11.07;	author florian;	state Exp;
branches;
next	1.42;
commitid	jGIspXgAx9pFxeFL;

1.42
date	2017.07.12.06.09.03;	author florian;	state Exp;
branches;
next	1.41;
commitid	aKKKhYcNvEd3CqrK;

1.41
date	2016.08.02.17.00.09;	author jca;	state Exp;
branches;
next	1.40;
commitid	LwUwsYotrzF8sP65;

1.40
date	2016.06.29.14.19.38;	author jca;	state Exp;
branches;
next	1.39;
commitid	UKZNj8xE8arS6lgt;

1.39
date	2016.03.01.20.51.05;	author jca;	state Exp;
branches;
next	1.38;
commitid	odaF3eMKay0HIw4l;

1.38
date	2016.03.01.12.52.43;	author jca;	state Exp;
branches;
next	1.37;
commitid	qLTuytlmNQD2lPuw;

1.37
date	2016.02.08.23.19.00;	author jca;	state Exp;
branches;
next	1.36;
commitid	731eoDfUV7AoJwjq;

1.36
date	2016.02.05.11.26.26;	author reyk;	state Exp;
branches;
next	1.35;
commitid	Y6uVb5EfRwzHLjS6;

1.35
date	2015.12.11.20.15.52;	author mmcc;	state Exp;
branches;
next	1.34;
commitid	V4ug53xJVPDhBc3B;

1.34
date	2015.12.01.12.11.31;	author jca;	state Exp;
branches;
next	1.33;
commitid	DYOw8eAThQdST8xa;

1.33
date	2015.12.01.12.09.36;	author jca;	state Exp;
branches;
next	1.32;
commitid	o1CzYdbT8BvoV0T5;

1.32
date	2015.11.30.20.58.08;	author jca;	state Exp;
branches;
next	1.31;
commitid	NzXzLkpKQJI7NQZx;

1.31
date	2015.11.30.12.44.36;	author jca;	state Exp;
branches;
next	1.30;
commitid	R1DySEy6vWf8EpoW;

1.30
date	2015.11.03.15.59.31;	author mpi;	state Exp;
branches;
next	1.29;
commitid	xTjx46ksgonaOI1Y;

1.29
date	2015.10.25.22.11.34;	author jca;	state Exp;
branches;
next	1.28;
commitid	fhTQouZIvPQVwdr9;

1.28
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	z3HrihslRYb4HqW9;

1.27
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Uu5nFG3wCl0LACBb;

1.26
date	2014.06.29.00.58.45;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	JPNyzoRAXfnuJx1K;

1.25
date	2013.03.21.04.43.15;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.05.05.13.04;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2010.05.21.13.41.23;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.11.09.51.53;	author rainer;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.10.13.15.43;	author sthen;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.07.20.58.47;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.05.22.40.24;	author chris;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.21.20.40.55;	author rainer;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.16.16.08.15;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.09.23.18.18.09;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.21.04.06.01;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.10.19.57.35;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.00.56.09;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.21.23.29.46;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.17.19.42.39;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.21.15.42.35;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.21.15.11.18;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.15.11.06.25;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.01.01.24.04;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.06.10.14.46;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.23.11.23.23;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.13.06.16.11;	author itojun;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.12.11.10.33.28;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.12.11.10.23.28;	author itojun;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.12.11.10.23.28;	author itojun;	state Exp;
branches;
next	;

1.3.2.1
date	2000.10.21.05.19.33;	author jason;	state Exp;
branches;
next	;


desc
@@


1.45
log
@No need to handle multiple routing messages here.

route(4) sockets only ever ship a single routing message per read(2)
call, so simplify this.  Mostly mechanical diff for now, some further
cleanups will follow.

ok rob@@ florian@@
@
text
@/*	$OpenBSD: if.c,v 1.44 2017/07/12 06:11:45 florian Exp $	*/
/*	$KAME: if.c,v 1.17 2001/01/21 15:27:30 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/queue.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <net/if_types.h>
#include <ifaddrs.h>
#include <net/route.h>
#include <net/if_dl.h>
#include <netinet/in.h>
#include <netinet/icmp6.h>
#include <netinet/if_ether.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <event.h>

#include "rtadvd.h"
#include "if.h"
#include "log.h"

#define ROUNDUP(a, size) \
	(((a) & ((size)-1)) ? (1 + ((a) | ((size)-1))) : (a))

#define NEXT_SA(ap) (ap) = (struct sockaddr *) \
	((char *)(ap) + ((ap)->sa_len ? ROUNDUP((ap)->sa_len,\
						 sizeof(u_long)) :\
			  			 sizeof(u_long)))

struct if_msghdr **iflist;
static void get_iflist(char **buf, size_t *size);
static void parse_iflist(struct if_msghdr ***ifmlist_p, char *buf,
    size_t bufsize);

static void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			NEXT_SA(sa);
		}
		else
			rti_info[i] = NULL;
	}
}

struct sockaddr_dl *
if_nametosdl(char *name)
{
	struct ifaddrs *ifap, *ifa;
	struct sockaddr_dl *sdl;

	if (getifaddrs(&ifap) != 0)
		return (NULL);

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (strcmp(ifa->ifa_name, name) != 0)
			continue;
		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;

		sdl = malloc(ifa->ifa_addr->sa_len);
		if (!sdl)
			continue;	/*XXX*/

		memcpy(sdl, ifa->ifa_addr, ifa->ifa_addr->sa_len);
		freeifaddrs(ifap);
		return (sdl);
	}

	freeifaddrs(ifap);
	return (NULL);
}

int
if_getmtu(char *name)
{
	int		s, save_errno;
	struct ifreq	ifr;
	u_long		mtu = 0;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) >= 0) {
		memset(&ifr, 0, sizeof(ifr));
		ifr.ifr_addr.sa_family = AF_INET6;
		if (strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name)) >=
		    sizeof(ifr.ifr_name))
			fatalx("strlcpy");
		if (ioctl(s, SIOCGIFMTU, (char *)&ifr) >= 0)
			mtu = ifr.ifr_mtu;
		save_errno = errno;
		close(s);
		errno = save_errno;
	}

	return (mtu);
}

/* give interface index and its old flags, then new flags returned */
int
if_getflags(int ifindex, int oifflags)
{
	struct ifreq ifr;
	int s;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
		log_warn("socket");
		return (oifflags & ~IFF_UP);
	}

	if_indextoname(ifindex, ifr.ifr_name);
	if (ioctl(s, SIOCGIFFLAGS, (char *)&ifr) < 0) {
		log_warn("ioctl:SIOCGIFFLAGS: failed for %s", ifr.ifr_name);
		close(s);
		return (oifflags & ~IFF_UP);
	}
	close(s);
	return (ifr.ifr_flags);
}

#define ROUNDUP8(a) (1 + (((a) - 1) | 7))
int
lladdropt_length(struct sockaddr_dl *sdl)
{
	switch (sdl->sdl_type) {
	case IFT_CARP:
	case IFT_ETHER:
		return(ROUNDUP8(ETHER_ADDR_LEN + 2));
	default:
		return(0);
	}
}

void
lladdropt_fill(struct sockaddr_dl *sdl, struct nd_opt_hdr *ndopt)
{
	char *addr;

	ndopt->nd_opt_type = ND_OPT_SOURCE_LINKADDR; /* fixed */

	switch (sdl->sdl_type) {
	case IFT_CARP:
	case IFT_ETHER:
		ndopt->nd_opt_len = (ROUNDUP8(ETHER_ADDR_LEN + 2)) >> 3;
		addr = (char *)(ndopt + 1);
		memcpy(addr, LLADDR(sdl), ETHER_ADDR_LEN);
		break;
	default:
		fatalx("unsupported link type(%d)", sdl->sdl_type);
	}
}

#define SIN6(s) ((struct sockaddr_in6 *)(s))
int
validate_msg(char *buf)
{
	struct rt_msghdr *rtm = (struct rt_msghdr *)buf;
	struct ifa_msghdr *ifam;
	struct sockaddr *sa, *dst, *ifa, *rti_info[RTAX_MAX];

	/* just for safety */
	if (!rtm->rtm_msglen) {
		log_warnx("rtm_msglen is 0 (rtm=%p)", rtm);
		return -1;
	}
	if (rtm->rtm_version != RTM_VERSION)
		return -1;

	switch (rtm->rtm_type) {
	case RTM_ADD:
	case RTM_DELETE:
		if (rtm->rtm_tableid != 0)
			return -1;

		/* address related checks */
		sa = (struct sockaddr *)((char *)rtm + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
		if ((dst = rti_info[RTAX_DST]) == NULL ||
		    dst->sa_family != AF_INET6)
			return -1;

		if (IN6_IS_ADDR_LINKLOCAL(&SIN6(dst)->sin6_addr) ||
		    IN6_IS_ADDR_MULTICAST(&SIN6(dst)->sin6_addr))
			return -1;

		if (rti_info[RTAX_NETMASK] == NULL)
			return -1;

		/* found */
		return 0;
		/* NOTREACHED */
	case RTM_NEWADDR:
	case RTM_DELADDR:
		ifam = (struct ifa_msghdr *)rtm;

		/* address related checks */
		sa = (struct sockaddr *)((char *)rtm + rtm->rtm_hdrlen);
		get_rtaddrs(ifam->ifam_addrs, sa, rti_info);
		if ((ifa = rti_info[RTAX_IFA]) == NULL ||
		    (ifa->sa_family != AF_INET &&
		    ifa->sa_family != AF_INET6))
			return -1;

		if (ifa->sa_family == AF_INET6 &&
		    (IN6_IS_ADDR_LINKLOCAL(&SIN6(ifa)->sin6_addr) ||
		    IN6_IS_ADDR_MULTICAST(&SIN6(ifa)->sin6_addr)))
			return -1;

		/* found */
		return 0;
		/* NOTREACHED */
	case RTM_IFINFO:
		/* found */
		return 0;
		/* NOTREACHED */
	}
	return -1;
}

struct in6_addr *
get_addr(char *buf)
{
	struct rt_msghdr *rtm = (struct rt_msghdr *)buf;
	struct sockaddr *sa, *rti_info[RTAX_MAX];

	sa = (struct sockaddr *)(buf + rtm->rtm_hdrlen);
	get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

	return(&SIN6(rti_info[RTAX_DST])->sin6_addr);
}

int
get_rtm_ifindex(char *buf)
{
	struct rt_msghdr *rtm = (struct rt_msghdr *)buf;

	return rtm->rtm_index;
}

int
get_ifm_ifindex(char *buf)
{
	struct if_msghdr *ifm = (struct if_msghdr *)buf;

	return ((int)ifm->ifm_index);
}

int
get_ifam_ifindex(char *buf)
{
	struct ifa_msghdr *ifam = (struct ifa_msghdr *)buf;

	return ((int)ifam->ifam_index);
}

int
get_ifm_flags(char *buf)
{
	struct if_msghdr *ifm = (struct if_msghdr *)buf;

	return (ifm->ifm_flags);
}

int
get_prefixlen(char *buf)
{
	struct rt_msghdr *rtm = (struct rt_msghdr *)buf;
	struct sockaddr *sa, *rti_info[RTAX_MAX];
	u_char *p, *lim;

	sa = (struct sockaddr *)(buf + rtm->rtm_hdrlen);
	get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
	sa = rti_info[RTAX_NETMASK];

	p = (u_char *)(&SIN6(sa)->sin6_addr);
	lim = (u_char *)sa + sa->sa_len;
	return prefixlen(p, lim);
}

int
prefixlen(u_char *p, u_char *lim)
{
	int masklen;

	for (masklen = 0; p < lim; p++) {
		switch (*p) {
		case 0xff:
			masklen += 8;
			break;
		case 0xfe:
			masklen += 7;
			break;
		case 0xfc:
			masklen += 6;
			break;
		case 0xf8:
			masklen += 5;
			break;
		case 0xf0:
			masklen += 4;
			break;
		case 0xe0:
			masklen += 3;
			break;
		case 0xc0:
			masklen += 2;
			break;
		case 0x80:
			masklen += 1;
			break;
		case 0x00:
			break;
		default:
			return(-1);
		}
	}

	return(masklen);
}

int
rtmsg_type(char *buf)
{
	struct rt_msghdr *rtm = (struct rt_msghdr *)buf;

	return(rtm->rtm_type);
}

int
rtmsg_len(char *buf)
{
	struct rt_msghdr *rtm = (struct rt_msghdr *)buf;

	return(rtm->rtm_msglen);
}

/*
 * alloc buffer and get if_msghdrs block from kernel,
 * and put them into the buffer
 */
static void
get_iflist(char **buf, size_t *size)
{
	int mib[6];

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET6;
	mib[4] = NET_RT_IFLIST;
	mib[5] = 0;
	while (1) {
		if (sysctl(mib, 6, NULL, size, NULL, 0) == -1)
			fatal("sysctl: iflist size get failed");
		if (*size == 0)
			break;
		if ((*buf = realloc(*buf, *size)) == NULL)
			fatal(NULL);
		if (sysctl(mib, 6, *buf, size, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			fatal("sysctl: iflist get failed");
		}
		break;
	}
}

/*
 * alloc buffer and parse if_msghdrs block passed as arg,
 * and init the buffer as list of pointers ot each of the if_msghdr.
 */
static void
parse_iflist(struct if_msghdr ***ifmlist_p, char *buf, size_t bufsize)
{
	int iflentry_size, malloc_size;
	struct if_msghdr *ifm;
	struct ifa_msghdr *ifam;
	char *lim;

	/*
	 * Estimate least size of an iflist entry, to be obtained from kernel.
	 * Should add sizeof(sockaddr) ??
	 */
	iflentry_size = sizeof(struct if_msghdr);
	/* roughly estimate max list size of pointers to each if_msghdr */
	malloc_size = (bufsize/iflentry_size) * sizeof(size_t);
	if ((*ifmlist_p = malloc(malloc_size)) == NULL)
		fatal(NULL);

	lim = buf + bufsize;
	for (ifm = (struct if_msghdr *)buf; ifm < (struct if_msghdr *)lim;) {
		if (ifm->ifm_msglen == 0) {
			log_warnx("ifm_msglen is 0 (buf=%p lim=%p ifm=%p)",
			    buf, lim, ifm);
			return;
		}
		if (ifm->ifm_type == RTM_IFINFO) {
			if (ifm->ifm_version == RTM_VERSION)
				(*ifmlist_p)[ifm->ifm_index] = ifm;
		} else {
			fatalx("out of sync parsing NET_RT_IFLIST,"
			    " expected %d, got %d, msglen = %d,"
			    " buf:%p, ifm:%p, lim:%p",
			    RTM_IFINFO, ifm->ifm_type, ifm->ifm_msglen,
			    buf, ifm, lim);
		}
		for (ifam = (struct ifa_msghdr *)
			((char *)ifm + ifm->ifm_msglen);
		     ifam < (struct ifa_msghdr *)lim;
		     ifam = (struct ifa_msghdr *)
		     	((char *)ifam + ifam->ifam_msglen)) {
			/* just for safety */
			if (!ifam->ifam_msglen) {
				log_warnx("ifa_msglen is 0 "
				    "(buf=%p lim=%p ifam=%p)",
				    buf, lim, ifam);
				return;
			}
			if (ifam->ifam_type != RTM_NEWADDR)
				break;
		}
		ifm = (struct if_msghdr *)ifam;
	}
}

void
init_iflist(void)
{
	static size_t ifblock_size;
	static char *ifblock;

	if (ifblock) {
		free(ifblock);
		ifblock_size = 0;
	}
	free(iflist);
	/* get iflist block from kernel */
	get_iflist(&ifblock, &ifblock_size);

	/* make list of pointers to each if_msghdr */
	parse_iflist(&iflist, ifblock, ifblock_size);
}
@


1.44
log
@errno is not set, use log_warnx
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.43 2017/07/12 06:11:07 florian Exp $	*/
d189 2
a190 2
char *
get_next_msg(char *buf, char *lim, size_t *lenp)
d192 1
a192 1
	struct rt_msghdr *rtm;
d196 55
a250 64
	*lenp = 0;
	for (rtm = (struct rt_msghdr *)buf;
	     rtm < (struct rt_msghdr *)lim;
	     rtm = (struct rt_msghdr *)((char *)rtm + rtm->rtm_msglen)) {
		/* just for safety */
		if (!rtm->rtm_msglen) {
			log_warnx("rtm_msglen is 0 (buf=%p lim=%p rtm=%p)",
			    buf, lim, rtm);
			break;
		}
		if (rtm->rtm_version != RTM_VERSION)
			continue;

		switch (rtm->rtm_type) {
		case RTM_ADD:
		case RTM_DELETE:
			if (rtm->rtm_tableid != 0)
				continue;

			/* address related checks */
			sa = (struct sockaddr *)((char *)rtm + rtm->rtm_hdrlen);
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
			if ((dst = rti_info[RTAX_DST]) == NULL ||
			    dst->sa_family != AF_INET6)
				continue;

			if (IN6_IS_ADDR_LINKLOCAL(&SIN6(dst)->sin6_addr) ||
			    IN6_IS_ADDR_MULTICAST(&SIN6(dst)->sin6_addr))
				continue;

			if (rti_info[RTAX_NETMASK] == NULL)
				continue;

			/* found */
			*lenp = rtm->rtm_msglen;
			return (char *)rtm;
			/* NOTREACHED */
		case RTM_NEWADDR:
		case RTM_DELADDR:
			ifam = (struct ifa_msghdr *)rtm;

			/* address related checks */
			sa = (struct sockaddr *)((char *)rtm + rtm->rtm_hdrlen);
			get_rtaddrs(ifam->ifam_addrs, sa, rti_info);
			if ((ifa = rti_info[RTAX_IFA]) == NULL ||
			    (ifa->sa_family != AF_INET &&
			     ifa->sa_family != AF_INET6))
				continue;

			if (ifa->sa_family == AF_INET6 &&
			    (IN6_IS_ADDR_LINKLOCAL(&SIN6(ifa)->sin6_addr) ||
			     IN6_IS_ADDR_MULTICAST(&SIN6(ifa)->sin6_addr)))
				continue;

			/* found */
			*lenp = rtm->rtm_msglen;
			return (char *)rtm;
			/* NOTREACHED */
		case RTM_IFINFO:
			/* found */
			*lenp = rtm->rtm_msglen;
			return (char *)rtm;
			/* NOTREACHED */
		}
d252 1
a252 2

	return (char *)rtm;
@


1.43
log
@replace
log_warnx("foo");
exit(1);
with
fatalx("foo);
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.42 2017/07/12 06:09:03 florian Exp $	*/
d438 1
a438 1
			log_warn("ifm_msglen is 0 (buf=%p lim=%p ifm=%p)",
@


1.42
log
@Don't clobber errno, we want to log_warn what went wrong.
OK benno, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.41 2016/08/02 17:00:09 jca Exp $	*/
d184 1
a184 2
		log_warn("unsupported link type(%d)", sdl->sdl_type);
		exit(1);
d446 1
a446 1
			log_warn("out of sync parsing NET_RT_IFLIST,"
a450 1
			exit(1);
@


1.41
log
@Move to libevent; ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.40 2016/06/29 14:19:38 jca Exp $	*/
d114 1
a114 1
	int		s;
d126 1
d128 1
@


1.40
log
@Spring cleanup

- pointless casts, kill caddr_t or replace it with char *
- signed counters
- simplify if_getmtu, only one method is needed and SIOCGIFMTU is the
  cheapest
- we no longer have drivers for IFT_FDDI
- hide details of iflist management
- if (dflag) log_debug -> log_debug
- dead code and comments
- etc etc

Input from and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.39 2016/03/01 20:51:05 jca Exp $	*/
d49 1
@


1.39
log
@fatal("malloc") -> fatal(NULL)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.38 2016/03/01 12:52:43 jca Exp $	*/
d49 1
d58 1
a58 1
	((caddr_t)(ap) + ((ap)->sa_len ? ROUNDUP((ap)->sa_len,\
a62 4
int iflist_init_ok;
size_t ifblock_size;
char *ifblock;

d113 3
a115 23
	struct ifaddrs *ifap, *ifa;
	struct if_data *ifd;
	u_long mtu = 0;

	if (getifaddrs(&ifap) < 0)
		return(0);
	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (strcmp(ifa->ifa_name, name) == 0) {
			ifd = ifa->ifa_data;
			if (ifd)
				mtu = ifd->ifi_mtu;
			break;
		}
	}
	freeifaddrs(ifap);

#ifdef SIOCGIFMTU		/* XXX: this ifdef may not be necessary */
	if (mtu == 0) {
		struct ifreq ifr;
		int s;

		if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
			return(0);
d117 1
d123 2
a124 4
		if (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) < 0) {
			close(s);
			return(0);
		}
a125 2

		mtu = ifr.ifr_mtu;
a126 1
#endif
d128 1
a128 1
	return(mtu);
d144 1
a144 1
	if (ioctl(s, SIOCGIFFLAGS, (caddr_t)&ifr) < 0) {
a159 1
	case IFT_FDDI:
a175 1
	case IFT_FDDI:
d473 3
@


1.38
log
@Pointless 'return;' in void functions
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.37 2016/02/08 23:19:00 jca Exp $	*/
d430 1
a430 1
			fatal("malloc");
d460 1
a460 1
		fatal("malloc");
@


1.37
log
@Kill trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.36 2016/02/05 11:26:26 reyk Exp $	*/
a212 2

	return;
@


1.36
log
@rtadvd used a strncpy with a src interface name from the command line
without checking its length.  Replace it with strlcpy, check for
truncation and move the check before using the user-specified
interface name.  While here, replace another strncpy of a interface
name with memset-zero + strlcpy and check for truncation in
if_getmtu() (should not happen as we validated the length before, but
it's better to be safe and generally a better practice).

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.35 2015/12/11 20:15:52 mmcc Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d74 1
a74 1
	
d344 1
a344 1
	
@


1.35
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.34 2015/12/01 12:11:31 jca Exp $	*/
d140 1
d142 3
a144 2
		strncpy(ifr.ifr_name, name,
			sizeof(ifr.ifr_name));
@


1.34
log
@Use setsockopt(ROUTE_MSGFILTER) instead of hand-rolled filtering.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.33 2015/12/01 12:09:36 jca Exp $	*/
d506 1
a506 2
	if (iflist)
		free(iflist);
@


1.33
log
@This RTM_GET case can't trigger due to the filtering done above.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.32 2015/11/30 20:58:08 jca Exp $	*/
a214 1
#define FILTER_MATCH(type, filter) ((0x1 << type) & filter)
d217 1
a217 1
get_next_msg(char *buf, char *lim, size_t *lenp, int filter)
a234 2
		if (FILTER_MATCH(rtm->rtm_type, filter) == 0)
			continue;
a290 1
#undef FILTER_MATCH
@


1.32
log
@Clean up get_next_msg(): kill dead argument/code

The "ifindex" argument has always been zero, making the interface index
checks within get_next_msg() useless.  The caller already properly
retrieves and handle the interface index of the routing messages.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.31 2015/11/30 12:44:36 jca Exp $	*/
a239 1
		case RTM_GET:
@


1.31
log
@Fix dynamic prefix tracking.

This code should not be using RTAX_GATEWAY to retrieve the interface
index.  Also this index is meaningless within get_next_msg(), further
cleanup is planned.

Issue reported by Sly Midnight on bugs@@, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.30 2015/11/03 15:59:31 mpi Exp $	*/
a216 1
#define SDL(s) ((struct sockaddr_dl *)(s))
d218 1
a218 1
get_next_msg(char *buf, char *lim, int ifindex, size_t *lenp, int filter)
d222 1
a222 1
	struct sockaddr *sa, *dst, *gw, *ifa, *rti_info[RTAX_MAX];
a256 6
			if ((gw = rti_info[RTAX_GATEWAY]) == NULL ||
			    gw->sa_family != AF_INET6)
				continue;
			if (ifindex && SDL(gw)->sdl_index != ifindex)
				continue;

a266 2
			if (ifindex && ifam->ifam_index != ifindex)
				continue;
@


1.30
log
@Recognize carp(4) interfaces (yes, they are special...) in order to send
the src lladdr option.

Problem reported and diff provided by Lauri Tirkkonen on bugs@@

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.29 2015/10/25 22:11:34 jca Exp $	*/
d259 1
a259 1
			    gw->sa_family != AF_LINK)
a321 4
	struct sockaddr *sa, *rti_info[RTAX_MAX];

	sa = (struct sockaddr *)(buf + rtm->rtm_hdrlen);
	get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
d323 1
a323 1
	return(((struct sockaddr_dl *)rti_info[RTAX_GATEWAY])->sdl_index);
@


1.29
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.28 2015/08/20 22:39:29 deraadt Exp $	*/
d183 1
d200 1
@


1.28
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.27 2015/01/16 06:40:20 deraadt Exp $	*/
d516 1
a516 1
init_iflist()
@


1.27
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.26 2014/06/29 00:58:45 deraadt Exp $	*/
d475 1
a475 1
	if ((*ifmlist_p = (struct if_msghdr **)malloc(malloc_size)) == NULL)
@


1.26
log
@If you want <sys/queue.h>, you need to include it.  Don't assume that
<sys/sysctl.h> will pull in the universe (I am working on breaking that
assumption in a gentle fashion)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.25 2013/03/21 04:43:15 deraadt Exp $	*/
a32 1
#include <sys/param.h>
@


1.25
log
@create realloc() loops around sysctl for array-based mibs, in programs
which want a "full" dump
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.24 2011/07/05 05:13:04 claudio Exp $	*/
d36 1
@


1.24
log
@Do not use (ifam + 1) to find the start of the sockaddrs. Use the
rtm_hdrlen instead. Also move the ifindex check way further up.
OK dlg@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.23 2010/05/21 13:41:23 chl Exp $	*/
d440 14
a453 8

	if (sysctl(mib, 6, NULL, size, NULL, 0) < 0)
		fatal("sysctl: iflist size get failed");
	if ((*buf = malloc(*size)) == NULL)
		fatal("malloc");
	if (sysctl(mib, 6, *buf, size, NULL, 0) < 0)
		fatal("sysctl: iflist get failed");
	return;
@


1.23
log
@remove unused functions

from tobias@@ (loooooong time ago)

ok rainer@@ henning@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.22 2009/07/11 09:51:53 rainer Exp $	*/
d272 2
d276 1
a276 1
			sa = (struct sockaddr *)(ifam + 1);
a287 3
			if (ifindex && ifam->ifam_index != ifindex)
				continue;

d289 1
a289 1
			*lenp = ifam->ifam_msglen;
@


1.22
log
@fix the RTM_VERSION check in the evil loop to really get
all the interfaces

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.21 2009/07/10 13:15:43 sthen Exp $	*/
a212 13
int
rtbuf_len()
{
	size_t len;

	int mib[6] = {CTL_NET, AF_ROUTE, 0, AF_INET6, NET_RT_DUMP, 0};

	if (sysctl(mib, 6, NULL, &len, NULL, 0) < 0)
		return(-1);

	return(len);
}

a423 8
}

int
ifmsg_len(char *buf)
{
	struct if_msghdr *ifm = (struct if_msghdr *)buf;

	return(ifm->ifm_msglen);
@


1.21
log
@Advance the pointer past the message on the routing socket where
ifm_version is not RTM_VERSION - the for() loop doesn't do this itself.
Fixes endless loop introduced by preceding commit, noticed by marc@@.
ok claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.20 2009/07/07 20:58:47 claudio Exp $	*/
a500 5
		if (ifm->ifm_version != RTM_VERSION) {
			ifm += ifm->ifm_msglen;
			continue;
		}

d502 2
a503 1
			(*ifmlist_p)[ifm->ifm_index] = ifm;
@


1.20
log
@Forgot to commit this while adding all the RTM_VERSION checks. Reminded by
sthen@@ who also tested it. OK henning@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.19 2009/06/05 22:40:24 chris Exp $	*/
d501 2
a502 1
		if (ifm->ifm_version != RTM_VERSION)
d504 1
@


1.19
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.18 2008/04/21 20:40:55 rainer Exp $	*/
d246 3
a248 1
		if (FILTER_MATCH(rtm->rtm_type, filter) == 0) {
a249 1
		}
d501 2
@


1.18
log
@Clean up logging by introducing the logging API used in
other daemons and clean up the command line options.
For details, see rtadvd(8).

ok bluhm@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.17 2006/11/16 16:08:15 henning Exp $	*/
d239 1
a239 1
	     rtm = (struct rt_msghdr *)(((char *)rtm) + rtm->rtm_msglen)) {
d258 1
a258 1
			sa = (struct sockaddr *)(rtm + 1);
d323 1
a323 1
	sa = (struct sockaddr *)(rtm + 1);
d335 1
a335 1
	sa = (struct sockaddr *)(rtm + 1);
d372 1
a372 1
	sa = (struct sockaddr *)(rtm + 1);
@


1.17
log
@ignore messages for routing tables other than the main one
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.16 2003/09/23 18:18:09 itojun Exp $	*/
a48 1
#include <syslog.h>
d51 1
d164 1
a164 2
		syslog(LOG_ERR, "<%s> socket: %s", __func__,
		       strerror(errno));
d170 1
a170 2
		syslog(LOG_ERR, "<%s> ioctl:SIOCGIFFLAGS: failed for %s",
		       __func__, ifr.ifr_name);
d206 1
a206 2
		syslog(LOG_ERR, "<%s> unsupported link type(%d)",
		    __func__, sdl->sdl_type);
d242 2
a243 3
			syslog(LOG_WARNING, "<%s> rtm_msglen is 0 "
				"(buf=%p lim=%p rtm=%p)", __func__,
				buf, lim, rtm);
d462 6
a467 14
	if (sysctl(mib, 6, NULL, size, NULL, 0) < 0) {
		syslog(LOG_ERR, "<%s> sysctl: iflist size get failed",
		       __func__);
		exit(1);
	}
	if ((*buf = malloc(*size)) == NULL) {
		syslog(LOG_ERR, "<%s> malloc failed", __func__);
		exit(1);
	}
	if (sysctl(mib, 6, *buf, size, NULL, 0) < 0) {
		syslog(LOG_ERR, "<%s> sysctl: iflist get failed",
		       __func__);
		exit(1);
	}
d490 2
a491 4
	if ((*ifmlist_p = (struct if_msghdr **)malloc(malloc_size)) == NULL) {
		syslog(LOG_ERR, "<%s> malloc failed", __func__);
		exit(1);
	}
d496 2
a497 3
			syslog(LOG_WARNING, "<%s> ifm_msglen is 0 "
			       "(buf=%p lim=%p ifm=%p)", __func__,
			       buf, lim, ifm);
d504 6
a509 6
			syslog(LOG_ERR, "out of sync parsing NET_RT_IFLIST,"
			       "expected %d, got %d, msglen = %d,"
			       "buf:%p, ifm:%p, lim:%p",
			       RTM_IFINFO, ifm->ifm_type, ifm->ifm_msglen,
			       buf, ifm, lim);
			exit (1);
d518 3
a520 3
				syslog(LOG_WARNING, "<%s> ifa_msglen is 0 "
				       "(buf=%p lim=%p ifam=%p)", __func__,
				       buf, lim, ifam);
@


1.16
log
@simplify by using getifaddrs.  cedric@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.15 2003/09/21 04:06:01 itojun Exp $	*/
d258 3
@


1.15
log
@plug memory leak.  from kame.  fgsch ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.14 2002/06/10 19:57:35 espie Exp $	*/
d88 2
a89 6
	int mib[6] = {CTL_NET, AF_ROUTE, 0, 0, NET_RT_IFLIST, 0};
	char *buf, *next, *lim;
	size_t len;
	struct if_msghdr *ifm;
	struct sockaddr *sa, *rti_info[RTAX_MAX];
	struct sockaddr_dl *sdl = NULL, *ret_sdl = NULL;
d91 1
a91 1
	if (sysctl(mib, 6, NULL, &len, NULL, 0) < 0)
a92 4
	if ((buf = malloc(len)) == NULL)
		return (NULL);
	if (sysctl(mib, 6, buf, &len, NULL, 0) < 0)
		goto end;
d94 13
a106 23
	lim = buf + len;
	for (next = buf; next < lim; next += ifm->ifm_msglen) {
		ifm = (struct if_msghdr *)next;
		if (ifm->ifm_type == RTM_IFINFO) {
			sa = (struct sockaddr *)(ifm + 1);
			get_rtaddrs(ifm->ifm_addrs, sa, rti_info);
			if ((sa = rti_info[RTAX_IFP]) != NULL) {
				if (sa->sa_family == AF_LINK) {
					sdl = (struct sockaddr_dl *)sa;
					if (strlen(name) != sdl->sdl_nlen)
						continue; /* not same len */
					if (strncmp(&sdl->sdl_data[0],
						    name,
						    sdl->sdl_nlen) == 0) {
						break;
					}
				}
			}
		}
	}
	if (next == lim) {
		/* search failed */
		goto end;
d109 2
a110 8
	if ((ret_sdl = malloc(sdl->sdl_len)) == NULL)
		goto end;
	memcpy((caddr_t)ret_sdl, (caddr_t)sdl, sdl->sdl_len);
	return (ret_sdl);

  end:
	free(buf);
	return (ret_sdl);
@


1.14
log
@Kill __FUNCTION__.
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.13 2002/06/09 00:56:09 deraadt Exp $	*/
d93 1
a93 1
	struct sockaddr_dl *sdl = NULL, *ret_sdl;
d96 1
a96 1
		return(NULL);
d98 3
a100 5
		return(NULL);
	if (sysctl(mib, 6, buf, &len, NULL, 0) < 0) {
		free(buf);
		return(NULL);
	}
d124 1
a124 2
		free(buf);
		return(NULL);
d128 1
a128 1
		return(NULL);
d130 5
a134 1
	return(ret_sdl);
@


1.13
log
@do not use \n in syslog()
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.12 2002/05/21 23:29:46 itojun Exp $	*/
d187 1
a187 1
		syslog(LOG_ERR, "<%s> socket: %s", __FUNCTION__,
d195 1
a195 1
		       __FUNCTION__, ifr.ifr_name);
d232 1
a232 1
		    __FUNCTION__, sdl->sdl_type);
d269 1
a269 1
				"(buf=%p lim=%p rtm=%p)", __FUNCTION__,
d488 1
a488 1
		       __FUNCTION__);
d492 1
a492 1
		syslog(LOG_ERR, "<%s> malloc failed", __FUNCTION__);
d497 1
a497 1
		       __FUNCTION__);
d523 1
a523 1
		syslog(LOG_ERR, "<%s> malloc failed", __FUNCTION__);
d531 1
a531 1
			       "(buf=%p lim=%p ifm=%p)", __FUNCTION__,
d554 1
a554 1
				       "(buf=%p lim=%p ifam=%p)", __FUNCTION__,
@


1.12
log
@minor KNF.  plug a memory leak on reconfig.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.11 2002/02/17 19:42:39 millert Exp $	*/
d539 3
a541 3
			syslog(LOG_ERR, "out of sync parsing NET_RT_IFLIST\n"
			       "expected %d, got %d\n msglen = %d\n"
			       "buf:%p, ifm:%p, lim:%p\n",
@


1.11
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.10 2002/02/16 21:28:08 millert Exp $	*/
a38 3
#ifdef __FreeBSD__
# include <net/ethernet.h>
#endif
a39 3
#ifdef __NetBSD__
#include <net/if_ether.h>
#endif
a43 4
#ifdef __bsdi__
# include <netinet/if_ether.h>
#endif
#ifdef __OpenBSD__
a44 1
#endif
d207 6
a212 5
	switch(sdl->sdl_type) {
	 case IFT_ETHER:
		 return(ROUNDUP8(ETHER_ADDR_LEN + 2));
	 default:
		 return(0);
d223 11
a233 11
	switch(sdl->sdl_type) {
	 case IFT_ETHER:
		 ndopt->nd_opt_len = (ROUNDUP8(ETHER_ADDR_LEN + 2)) >> 3;
		 addr = (char *)(ndopt + 1);
		 memcpy(addr, LLADDR(sdl), ETHER_ADDR_LEN);
		 break;
	 default:
		 syslog(LOG_ERR,
			"<%s> unsupported link type(%d)",
			__FUNCTION__, sdl->sdl_type);
		 exit(1);
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.9 2001/01/21 15:42:35 itojun Exp $	*/
d78 2
a79 2
static void parse_iflist __P((struct if_msghdr ***ifmlist_p, char *buf,
		       size_t bufsize));
@


1.9
log
@sync router renumbering flag bit to conform to 2292bis-02 and RR RFC.
sync with latest kame rtadvd (again).  mostly cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.8 2001/01/21 15:11:18 itojun Exp $	*/
d77 1
a77 1
static void get_iflist __P((char **buf, size_t *size));
@


1.8
log
@do not intsall rtadvd.conf into /etc, it is not required to use it
(rtadvd will derive the configuration from kernel settings).

make it clearer that rtadvd.conf is not necessary, in manpage.

sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: if.c,v 1.7 2001/01/15 11:06:25 itojun Exp $	*/
/*	$KAME: if.c,v 1.16 2001/01/19 03:07:18 itojun Exp $	*/
d349 1
a349 1
#undef FILTER_MATCH(type, filter)
@


1.7
log
@sync with latest kame tree.
- reduce chances for signal handler rae condition
- decrease chances for misconfiguration
- feedbacks from router renumbering protocol bakeoff
- cleanups related to mtu handling
@
text
@d1 2
a2 2
/*	$OpenBSD: if.c,v 1.6 2000/09/01 01:24:04 itojun Exp $	*/
/*	$KAME: if.c,v 1.15 2000/10/25 04:30:44 jinmei Exp $	*/
a259 11
}

int
get_rtinfo(char *buf, size_t *len)
{
	int mib[6] = {CTL_NET, AF_ROUTE, 0, AF_INET6, NET_RT_DUMP, 0};

	if (sysctl(mib, 6, buf, len, NULL, 0) < 0)
		return(-1);

	return(0);
@


1.6
log
@repair a routine to grab interface MTU information.
@
text
@d1 2
a2 2
/*	$OpenBSD: if.c,v 1.5 2000/07/06 10:14:46 itojun Exp $	*/
/*	$KAME: if.c,v 1.12 2000/08/31 16:35:29 itojun Exp $	*/
a149 18
#ifdef SIOCGIFMTU
	struct ifreq ifr;
	int s;

	if ((s = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
		return(0);

	ifr.ifr_addr.sa_family = AF_INET6;
	strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFMTU, (caddr_t)&ifr) < 0) {
		close(s);
		return(0);
	}

	close(s);

	return(ifr.ifr_mtu);
#else
d152 1
a158 1
			freeifaddrs(ifap);
d160 2
a161 3
				return ifd->ifi_mtu;
			else
				return 0;
d165 20
a184 1
	return 0;
d186 2
a414 1
	int masklen;
d423 8
@


1.5
log
@sync with router renumber struct decl change.
more logs.  make it very sure to close temporary socket.
@
text
@d1 2
a2 2
/*	$OpenBSD: if.c,v 1.4 2000/05/23 11:23:23 itojun Exp $	*/
/*	$KAME: if.c,v 1.11 2000/07/06 08:20:04 jinmei Exp $	*/
d150 1
a150 1
#if 0
@


1.4
log
@sync with latest kame.
- weaken logging priority for /etc/resolv.conf open failure
- gather stats, emit stats by SIGUSR1
- use SIOCGIFMTU to get interface MTU (just a matter of #ifdef)
From: "Todd T. Fries" <todd@@fries.net>
@
text
@d1 2
a2 2
/*	$OpenBSD: if.c,v 1.3 2000/03/13 06:16:11 itojun Exp $	*/
/*	$KAME: if.c,v 1.8 2000/05/22 22:04:37 itojun Exp $	*/
d42 1
a42 3
#ifdef __bsdi__
# include <ifaddrs.h>
#endif
d150 1
a150 1
#ifndef __bsdi__
d208 1
a590 1
		
@


1.3
log
@bring in latest rtadvd source from kame.
this fixes unclosed file descriptor in router renumbering case.
@
text
@d1 2
a2 1
/*	$OpenBSD: if.c,v 1.2 1999/12/11 10:33:28 itojun Exp $	*/
d152 1
a152 1
#if defined(__FreeBSD__) || defined(__NetBSD__)
d169 1
a169 2
#endif
#ifdef __bsdi__
a187 2
	/* last resort */
	return 0;
@


1.3.2.1
log
@Pull in patch from current:
Fix (itojun):
repair a routine to grab interface MTU information.
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.3 2000/03/13 06:16:11 itojun Exp $	*/
d151 1
a151 1
#ifdef SIOCGIFMTU
d168 2
a169 1
#else
@


1.2
log
@enable rtadvd in usr.sbin/Makefile.
rcsid police on usr.sbin/rtadvd.
add sample config into etc/rtadvd.conf.
add files into distrib/sets/list.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d170 1
a170 1
	struct ifaddrs *ifa;
d173 1
a173 1
	if (getifaddrs(&ifa) < 0)
d175 1
a175 1
	while (ifa) {
d178 1
a183 1
		ifa = ifa->ifa_next;
d185 1
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@router advertisement daemon, from KAME
@
text
@@
