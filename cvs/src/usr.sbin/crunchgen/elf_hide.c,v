head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.6
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.6.0.14
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.12
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.10
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	z3HrihslRYb4HqW9;

1.9
date	2015.01.18.05.30.58;	author guenther;	state Exp;
branches;
next	1.8;
commitid	OYIU77lQl50OoBCB;

1.8
date	2014.05.20.01.25.24;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2013.11.12.19.48.40;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.20.02.08.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.04.04.59.48;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.02.23.59.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.24.17.23.26;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.08.20.42.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2008.08.22.15.18.55;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@/* $OpenBSD: elf_hide.c,v 1.9 2015/01/18 05:30:58 guenther Exp $ */

/*
 * Copyright (c) 1997 Dale Rahn.
 * All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/exec_elf.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "mangle.h"

extern	int elf_mangle;

void	load_strtab(Elf_Ehdr * pehdr, char *pexe);
void	dump_strtab(void);
char	*get_str(int indx);

void	load_symtab(Elf_Ehdr * pehdr, char *pexe);
void	dump_symtab(Elf_Shdr * symsect, Elf_Sym * symtab, int symtabsize);
void	fprint_str(FILE * channel, int indx);

void	load_shstr_tab(Elf_Ehdr * pehdr, char *pexe);
char	*get_shstr(int indx);
void	fprint_shstr(FILE * channel, int indx);

void	hide_sym(Elf_Ehdr * ehdr, Elf_Shdr * symsect,
	    Elf_Sym * symtab, int symtabsize, int symtabsecnum);
void	reorder_syms(Elf_Ehdr * ehdr, Elf_Shdr * symsect,
	    Elf_Sym * symtab, int symtabsize, int symtabsecnum);
typedef long    Symmap;
void	renum_reloc_syms(Elf_Ehdr * ehdr, Symmap * symmap,
	    int symtabsecnum);
void	elf_hide(int pfile, char *p);


char           *pexe;

void
elf_hide(int pfile, char *p)
{
	Elf_Ehdr       *pehdr;
#ifdef DEBUG
	Elf_Shdr       *pshdr;
	Elf_Phdr       *pphdr;
	int             i;
#endif

	pexe = p;
	pehdr = (Elf_Ehdr *) pexe;

#ifdef DEBUG
	printf("elf header\n");
	printf("e_type %x\n", pehdr->e_type);
	printf("e_machine %x\n", pehdr->e_machine);
	printf("e_version %x\n", pehdr->e_version);
	printf("e_entry %x\n", pehdr->e_entry);
	printf("e_phoff %x\n", pehdr->e_phoff);
	printf("e_shoff %x\n", pehdr->e_shoff);
	printf("e_flags %x\n", pehdr->e_flags);
	printf("e_ehsize %x\n", pehdr->e_ehsize);
	printf("e_phentsize %x\n", pehdr->e_phentsize);
	printf("e_phnum %x\n", pehdr->e_phnum);
	printf("e_shentsize %x\n", pehdr->e_shentsize);
	printf("e_shnum %x\n", pehdr->e_shnum);
	printf("e_shstrndx %x\n", pehdr->e_shstrndx);
#endif

	load_shstr_tab(pehdr, pexe);
#ifdef DEBUG
	for (i = 0; i < pehdr->e_shnum; i++) {
		pshdr = (Elf_Phdr *) (pexe + pehdr->e_shoff +
		    (i * pehdr->e_shentsize));

		printf("section header %d\n", i);
		printf("sh_name %x ", pshdr->sh_name);
		fprint_shstr(stdout, pshdr->sh_name);
		printf("\n");
		printf("sh_type %x\n", pshdr->sh_type);
		printf("sh_flags %x\n", pshdr->sh_flags);
		printf("sh_addr %x\n", pshdr->sh_addr);
		printf("sh_offset %x\n", pshdr->sh_offset);
		printf("sh_size %x\n", pshdr->sh_size);
		printf("sh_link %x\n", pshdr->sh_link);
		printf("sh_info %x\n", pshdr->sh_info);
		printf("sh_addralign %x\n", pshdr->sh_addralign);
		printf("sh_entsize %x\n", pshdr->sh_entsize);
	}
#endif				/* DEBUG */

#ifdef DEBUG
	for (i = 0; i < pehdr->e_phnum; i++) {
		pshdr = (Elf_Phdr *) (pexe + pehdr->e_phoff +
		    (i * pehdr->e_phentsize));

		printf("program header %d\n", i);
		printf("p_type %x\n", pphdr->p_type);
		printf("p_offset %x\n", pphdr->p_offset);
		printf("p_vaddr %x\n", pphdr->p_vaddr);
		printf("p_paddr %x\n", pphdr->p_paddr);
		printf("p_filesz %x\n", pphdr->p_filesz);
		printf("p_memsz %x\n", pphdr->p_memsz);
		printf("p_flags %x\n", pphdr->p_flags);
		printf("p_align %x\n", pphdr->p_align);
	}
#endif				/* DEBUG */
#if 0
	for (i = 0; i < pehdr->e_shnum; i++) {
		pshdr = (Elf_Phdr *) (pexe + pehdr->e_shoff +
		    (i * pehdr->e_shentsize));
		if (strcmp(".strtab", get_shstr(pshdr->sh_name)) == 0)
			break;
	}
	fprint_shstr(stdout, pshdr->sh_name);
	printf("\n");
#endif

	load_strtab(pehdr, pexe);
	load_symtab(pehdr, pexe);
	close(pfile);
}
char           *shstrtab;

void
load_shstr_tab(Elf_Ehdr * pehdr, char *pexe)
{
	Elf_Shdr       *pshdr;
	shstrtab = NULL;
	if (pehdr->e_shstrndx == 0)
		return;
	pshdr = (Elf_Shdr *) (pexe + pehdr->e_shoff +
	    (pehdr->e_shstrndx * pehdr->e_shentsize));

	shstrtab = (char *) (pexe + pshdr->sh_offset);
}

void
fprint_shstr(FILE * channel, int indx)
{
	if (shstrtab != NULL)
		fprintf(channel, "\"%s\"", &(shstrtab[indx]));
}

char           *
get_shstr(int indx)
{
	return &(shstrtab[indx]);
}

void
load_symtab(Elf_Ehdr * pehdr, char *pexe)
{
	Elf_Sym        *symtab;
	Elf_Shdr       *symsect;
	int             symtabsize;
	Elf_Shdr       *psymshdr;
	Elf_Shdr       *pshdr;
#ifdef DEBUG
	char           *shname;
#endif
	int             i;

	symtab = NULL;
	for (i = 0; i < pehdr->e_shnum; i++) {
		pshdr = (Elf_Shdr *) (pexe + pehdr->e_shoff +
		    (i * pehdr->e_shentsize));
		if (SHT_REL != pshdr->sh_type && SHT_RELA != pshdr->sh_type)
			continue;
		psymshdr = (Elf_Shdr *) (pexe + pehdr->e_shoff +
		    (pshdr->sh_link * pehdr->e_shentsize));
#ifdef DEBUG
		fprint_shstr(stdout, pshdr->sh_name);
		printf("\n");
#endif
		symtab = (Elf_Sym *) (pexe + psymshdr->sh_offset);
		symsect = psymshdr;
		symtabsize = psymshdr->sh_size;

#ifdef DEBUG
		dump_symtab(symsect, symtab, symtabsize);
#endif
		hide_sym(pehdr, symsect, symtab, symtabsize, pshdr->sh_link);
	}

}

void
dump_symtab(Elf_Shdr * symsect, Elf_Sym * symtab, int symtabsize)
{
	int             i;
	Elf_Sym        *psymtab;

	for (i = 0; i < (symtabsize / sizeof(Elf_Sym)); i++) {
		psymtab = &(symtab[i]);
		if ((psymtab->st_info & 0xf0) == 0x10 &&
		    (psymtab->st_shndx != SHN_UNDEF)) {
			printf("symbol %d:\n", i);
			printf("st_name %x \"%s\"\n", psymtab->st_name,
			    get_str(psymtab->st_name));
			printf("st_value %llx\n", (unsigned long long)psymtab->st_value);
			printf("st_size %llx\n", (unsigned long long)psymtab->st_size);
			printf("st_info %x\n", psymtab->st_info);
			printf("st_other %x\n", psymtab->st_other);
			printf("st_shndx %x\n", psymtab->st_shndx);
		}
	}
}

char           *strtab;
int             strtabsize;
void
load_strtab(Elf_Ehdr * pehdr, char *pexe)
{
	Elf_Shdr       *pshdr = NULL;
	char           *shname;
	int             i;
	strtab = NULL;
	for (i = 0; i < pehdr->e_shnum; i++) {
		pshdr = (Elf_Shdr *) (pexe + pehdr->e_shoff +
		    (i * pehdr->e_shentsize));

		shname = get_shstr(pshdr->sh_name);
		if (strcmp(".strtab", shname) == 0)
			break;
	}
#ifdef DEBUG
	fprint_shstr(stdout, pshdr->sh_name);
	printf("\n");
#endif

	strtab = (char *) (pexe + pshdr->sh_offset);

	strtabsize = pshdr->sh_size;

#ifdef DEBUG
	dump_strtab();
#endif
}

void
dump_strtab()
{
	int             index;
	char           *pstr;
	char           *pnstr;
	int             i = 0;
	index = 0;
	pstr = strtab;
	while (index < strtabsize) {
		printf("string %x: \"%s\"\n", i, pstr);
		pnstr = pstr + strlen(pstr) + 1;
		index = pnstr - strtab;
		pstr = pnstr;
		i++;
	}

}

void
fprint_str(FILE * channel, int indx)
{
	if (strtab != NULL)
		fprintf(channel, "\"%s\"", &(strtab[indx]));
}

char *
get_str(int indx)
{
	return &(strtab[indx]);
}

int             in_keep_list(char *symbol);

void
hide_sym(Elf_Ehdr * ehdr, Elf_Shdr * symsect,
    Elf_Sym * symtab, int symtabsize, int symtabsecnum)
{
	int             i;
	unsigned char   info;
	Elf_Sym        *psymtab;

	for (i = 0; i < (symtabsize / sizeof(Elf_Sym)); i++) {
		psymtab = &(symtab[i]);
		if ((psymtab->st_info & 0xf0) == 0x10 &&
		    (psymtab->st_shndx != SHN_UNDEF)) {
			if (in_keep_list(get_str(psymtab->st_name)))
				continue;
#ifdef DEBUG
			printf("symbol %d:\n", i);
			printf("st_name %x \"%s\"\n", psymtab->st_name,
			    get_str(psymtab->st_name));
			printf("st_info %x\n", psymtab->st_info);
#endif
			if (!elf_mangle) {
				info = psymtab->st_info;
				info = info & 0xf;
				psymtab->st_info = info;
			} else {
				mangle_str(get_str(psymtab->st_name));
			}
#ifdef DEBUG
			printf("st_info %x\n", psymtab->st_info);
#endif
		}
	}
	reorder_syms(ehdr, symsect, symtab, symtabsize, symtabsecnum);
}

void
reorder_syms(Elf_Ehdr * ehdr, Elf_Shdr * symsect,
    Elf_Sym * symtab, int symtabsize, int symtabsecnum)
{
	int             i;
	int             nsyms;
	int             cursym;
	Elf_Sym        *tmpsymtab;
	Symmap         *symmap;


	nsyms = symtabsize / sizeof(Elf_Sym);

	tmpsymtab = calloc(1, symtabsize);
	symmap = calloc(nsyms, sizeof(Symmap));
	if (!tmpsymtab || !symmap)
		errc(5, ENOMEM, "calloc");

	bcopy(symtab, tmpsymtab, symtabsize);

	cursym = 1;
	for (i = 1; i < nsyms; i++) {
		if ((tmpsymtab[i].st_info & 0xf0) == 0x00) {
#ifdef DEBUG
			printf("copying  l o%d n%d <%s>\n", i, cursym,
			    get_str(tmpsymtab[i].st_name));
#endif
			bcopy(&(tmpsymtab[i]), &(symtab[cursym]),
			    sizeof(Elf_Sym));
			symmap[i] = cursym;
			cursym++;
		}
	}
	symsect->sh_info = cursym;
	for (i = 1; i < nsyms; i++) {
		if ((tmpsymtab[i].st_info & 0xf0) != 0x00) {
#ifdef DEBUG
			printf("copying nl o%d n%d <%s>\n", i, cursym,
			    get_str(tmpsymtab[i].st_name));
#endif
			bcopy(&(tmpsymtab[i]), &(symtab[cursym]),
			    sizeof(Elf_Sym));
			symmap[i] = cursym;
			cursym++;
		}
	}
	if (cursym != nsyms) {
		printf("miscounted symbols somewhere c %d n %d \n",
		    cursym, nsyms);
		exit(5);
	}
	renum_reloc_syms(ehdr, symmap, symtabsecnum);
	free(tmpsymtab);
	free(symmap);
}

void
renum_reloc_syms(Elf_Ehdr * ehdr, Symmap * symmap, int symtabsecnum)
{
	Elf_Shdr       *pshdr;
	int             i, j;
	int             num_reloc;
	Elf_Rel        *prel;
	Elf_RelA       *prela;
	int             symnum;

	for (i = 0; i < ehdr->e_shnum; i++) {
		pshdr = (Elf_Shdr *) (pexe + ehdr->e_shoff +
		    (i * ehdr->e_shentsize));
		if ((pshdr->sh_type == SHT_RELA) &&
		    pshdr->sh_link == symtabsecnum) {

#ifdef DEBUG
			printf("section %d has rela relocations in symtab\n", i);
#endif
			prela = (Elf_RelA *) (pexe + pshdr->sh_offset);
			num_reloc = pshdr->sh_size / sizeof(Elf_RelA);
			for (j = 0; j < num_reloc; j++) {
				symnum = ELF_R_SYM(prela[j].r_info);
#ifdef DEBUG
				printf("sym num o %d n %d\n", symnum,
				    symmap[symnum]);
#endif
				prela[j].r_info = ELF_R_INFO(symmap[symnum],
				    ELF_R_TYPE(prela[j].r_info));
			}
		}
		if ((pshdr->sh_type == SHT_REL) &&
		    pshdr->sh_link == symtabsecnum) {
#ifdef DEBUG
			printf("section %d has rel relocations in symtab\n", i);
#endif
			prel = (Elf_Rel *) (pexe + pshdr->sh_offset);
			num_reloc = pshdr->sh_size / sizeof(Elf_Rel);
			for (j = 0; j < num_reloc; j++) {
				symnum = ELF_R_SYM(prel[j].r_info);
#ifdef DEBUG
				printf("sym num o %d n %d\n", symnum,
				    symmap[symnum]);
#endif
				prel[j].r_info = ELF_R_INFO(symmap[symnum],
				    ELF_R_TYPE(prel[j].r_info));
			}
		}
	}

}
@


1.9
log
@The world is ELF: use <sys/exec_elf.h> instead of <a.out.h> or <sys/exec.h>
Use a better test for an input being ELF: struct exec is dead and there are
defines for the ELF magic.  Reorder #includes and do some whitespace cleanup.
Oh, and don't lead the fd if an input file isn't ELF.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.8 2014/05/20 01:25:24 guenther Exp $ */
d352 2
a353 2
	tmpsymtab = (Elf_Sym *) calloc(1, symtabsize);
	symmap = (Symmap *) calloc(nsyms, sizeof(Symmap));
@


1.8
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.7 2013/11/12 19:48:40 deraadt Exp $ */
d32 2
a40 1
#include <sys/exec.h>
a42 3
#ifdef _NLIST_DO_ELF
#include <sys/exec_elf.h>

a445 1
#endif				/* _NLIST_DO_ELF */
@


1.7
log
@add missing protos
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.6 2010/07/20 02:08:15 deraadt Exp $ */
d357 1
a357 1
		errx(5, "calloc: %s", strerror(ENOMEM));
@


1.6
log
@delete unused variable
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.5 2009/12/04 04:59:48 drahn Exp $ */
d48 1
a48 1
void	dump_strtab();
d52 2
a53 1
void	dump_symtab();
d59 2
a60 1
void	hide_sym();
d66 1
@


1.5
log
@Change crunchgen to mangle names in sequence instead of randomly,
save the sequence numbers between runs, currently uses file 'mangledata'
this may be changed to be specified on the command line later.
Requested by Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.5 2009/12/04 04:54:33 drahn Exp $ */
a76 1
	struct stat     sb;
a148 2

	munmap(pexe, sb.st_size);
@


1.4
log
@that is not a small hack, it is big and gruesome and has very bad effects
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.3 2008/11/24 17:23:26 drahn Exp $ */
d40 2
d331 1
a331 26
				/*
				 * XXX This is a big ugly hack to be able to
				 * XXX use chrunchide with MIPS.
				 * XXX Because MIPS needs global symbols to stay
				 * XXX global (has to do with GOT), we mess
				 * XXX around with the symbol names instead.
				 * XXX For most uses this will be no problem,
				 * XXX symbols are stripped anyway.  However
				 * XXX symbol names will randomly clash.
				 */
				char *p;
				u_int32_t n, z;
				u_int32_t f;
				f = arc4random();

				z = f++;
				p = get_str(psymtab->st_name);
				n = strlen(p);
				if (n > 4)
					n = 4;
				while (n--) {
					p[n] = z;
					z >>= 8;
					while (p[n] == 0)
						p[n] += arc4random();
				}
@


1.3
log
@Change mips detection in crunchgen from ifdef to command line flag
ok deraadt@@, fkr@@, rainer@@. manpage cleanup thanks to jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.2 2008/09/08 20:42:24 deraadt Exp $ */
d330 1
a330 1
				 * XXX This is a small ugly hack to be able to
d336 2
a337 3
				 * XXX symbols are stripped anyway.
				 * XXX However, if many one character
				 * XXX symbols exist, names may clash.
@


1.2
log
@clean warnings on all architectures
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.1 2008/08/22 15:18:55 deraadt Exp $ */
d43 2
a308 1
#ifndef __mips__
a309 1
#endif
a311 4
#ifdef __mips__
	u_int32_t f = arc4random();
#endif

d324 16
a339 16
#ifndef __mips__
			info = psymtab->st_info;
			info = info & 0xf;
			psymtab->st_info = info;
#else
			/*
			 * XXX This is a small ugly hack to be able to use
			 * XXX chrunchide with MIPS.
			 * XXX Because MIPS needs global symbols to stay
			 * XXX global (has to do with GOT), we mess around
			 * XXX with the symbol names instead. For most uses
			 * XXX this will be no problem, symbols are stripped
			 * XXX anyway. However, if many one character
			 * XXX symbols exist, names may clash.
			 */
			{
d342 2
a356 2

#endif
@


1.1
log
@Merge crunchgen & crunchhide (using name checking), and move to usr.sbin
next step is to not install it as two programs, but be even more clever
@
text
@d1 1
a1 1
/* $OpenBSD: elf_hide.c,v 1.12 2007/08/14 20:43:10 miod Exp $ */
d228 2
a229 2
			printf("st_value %x\n", psymtab->st_value);
			printf("st_size %x\n", psymtab->st_size);
d307 1
d309 1
@

