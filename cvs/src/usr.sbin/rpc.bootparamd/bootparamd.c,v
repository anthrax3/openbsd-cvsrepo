head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.2
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.38
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.30
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.34
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.32
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.28
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.26
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.24
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.22
	OPENBSD_5_0:1.18.0.20
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.18
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.16
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.12
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.14
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.12
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.10
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.12
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.6
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.10.16.10.40.58;	author jca;	state Exp;
branches;
next	1.20;
commitid	ObnZ1HRbc42KwONM;

1.20
date	2015.11.26.19.00.40;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	0UZuVGmRAlDbBLQM;

1.19
date	2015.11.20.17.49.59;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	6kxiOmarHLue2eZL;

1.18
date	2007.02.18.20.33.45;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.25.19.05.09;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.21.19.54.47;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.06.21.34.03;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.19.02.18.06;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.14.03.53.05;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.11.18.49.18;	author hin;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.27.20.34.36;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	98.07.10.08.06.50;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.05.03.05.02.09;	author gene;	state Exp;
branches;
next	1.7;

1.7
date	97.06.23.09.31.08;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.07.14.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.10.15.13.31;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.10.05.07.23.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.31.01.20.48;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.41.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Rename local variable 'err' to 'error', to avoid -Wshadow conflicts with err.h
@
text
@/*	$OpenBSD: bootparamd.c,v 1.20 2015/11/26 19:00:40 deraadt Exp $	*/

/*
 * This code is not copyright, and is placed in the public domain.
 * Feel free to use and modify. Please send modifications and/or
 * suggestions + bug fixes to Klas Heggemann <klas@@nada.kth.se>
 *
 * Various small changes by Theo de Raadt <deraadt@@fsa.ca>
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <rpc/rpc.h>
#include <rpcsvc/bootparam_prot.h>
#include <rpcsvc/ypclnt.h>
#include <rpcsvc/yp_prot.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <netdb.h>
#include <ctype.h>
#include <syslog.h>
#include <string.h>
#include <unistd.h>
#include <err.h>
#include <stdlib.h>

#include "pathnames.h"

#define MAXLEN 800

struct hostent *he;
static char hostname[MAX_MACHINE_NAME];
static char askname[MAX_MACHINE_NAME];
static char domain_name[MAX_MACHINE_NAME];

extern void bootparamprog_1(struct svc_req *, SVCXPRT *);
int lookup_bootparam(char *client, char *client_canonical, char *id,
    char **server, char **path);

int	_rpcsvcdirty = 0;
int	_rpcpmstart = 0;
int	debug = 0;
int	dolog = 0;
struct in_addr route_addr;
struct sockaddr_in my_addr;
extern char *__progname;
char   *bootpfile = _PATH_BOOTPARAMS;

extern char *optarg;
extern int optind;

static void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-ds] [-f file] [-r router]\n",
	    __progname);
	exit(1);
}

/*
 * ever familiar
 */
int
main(int argc, char *argv[])
{
	struct hostent *he;
	struct stat buf;
	SVCXPRT *transp;
	int    c;

	while ((c = getopt(argc, argv, "dsr:f:")) != -1)
		switch (c) {
		case 'd':
			debug = 1;
			break;
		case 'r':
			if (inet_aton(optarg, &route_addr) == 1)
				break;
			he = gethostbyname(optarg);
			if (!he) {
				warnx("no such host: %s", optarg);
				usage();
			}
			bcopy(he->h_addr, &route_addr.s_addr,
			    sizeof(route_addr.s_addr));
			break;
		case 'f':
			bootpfile = optarg;
			break;
		case 's':
			dolog = 1;
#ifndef LOG_DAEMON
			openlog(__progname, 0, 0);
#else
			openlog(__progname, 0, LOG_DAEMON);
			setlogmask(LOG_UPTO(LOG_NOTICE));
#endif
			break;
		default:
			usage();
		}

	if (stat(bootpfile, &buf))
		err(1, "%s", bootpfile);

	if (!route_addr.s_addr) {
		get_myaddress(&my_addr);
		bcopy(&my_addr.sin_addr.s_addr, &route_addr.s_addr,
		    sizeof(route_addr.s_addr));
	}
	if (!debug) {
		if (daemon(0, 0))
			err(1, "can't detach from terminal");
	}

	(void) pmap_unset(BOOTPARAMPROG, BOOTPARAMVERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL)
		errx(1, "can't create udp service");

	if (!svc_register(transp, BOOTPARAMPROG, BOOTPARAMVERS, bootparamprog_1,
	    IPPROTO_UDP))
		errx(1, "unable to register BOOTPARAMPROG version %ld, udp",
		    BOOTPARAMVERS);

	if (pledge("stdio rpath dns", NULL) == -1)
		err(1, "pledge");

	svc_run();
	errx(1, "svc_run returned");
}

bp_whoami_res *
bootparamproc_whoami_1_svc(bp_whoami_arg *whoami, struct svc_req *rqstp)
{
	in_addr_t haddr;
	static bp_whoami_res res;

	if (debug)
		warnx("whoami got question for %d.%d.%d.%d",
		    255 & whoami->client_address.bp_address_u.ip_addr.net,
		    255 & whoami->client_address.bp_address_u.ip_addr.host,
		    255 & whoami->client_address.bp_address_u.ip_addr.lh,
		    255 & whoami->client_address.bp_address_u.ip_addr.impno);
	if (dolog)
		syslog(LOG_NOTICE, "whoami got question for %d.%d.%d.%d",
		    255 & whoami->client_address.bp_address_u.ip_addr.net,
		    255 & whoami->client_address.bp_address_u.ip_addr.host,
		    255 & whoami->client_address.bp_address_u.ip_addr.lh,
		    255 & whoami->client_address.bp_address_u.ip_addr.impno);

	bcopy(&whoami->client_address.bp_address_u.ip_addr,
	    &haddr, sizeof(haddr));
	he = gethostbyaddr(&haddr, sizeof(haddr), AF_INET);
	if (!he)
		goto failed;

	if (debug)
		warnx("This is host %s", he->h_name);
	if (dolog)
		syslog(LOG_NOTICE, "This is host %s", he->h_name);

	strlcpy(askname, he->h_name, sizeof askname);
	if (!lookup_bootparam(askname, hostname, NULL, NULL, NULL)) {
		res.client_name = hostname;
		getdomainname(domain_name, MAX_MACHINE_NAME);
		res.domain_name = domain_name;

		if (res.router_address.address_type != IP_ADDR_TYPE) {
			res.router_address.address_type = IP_ADDR_TYPE;
			bcopy(&route_addr.s_addr,
			    &res.router_address.bp_address_u.ip_addr, 4);
		}
		if (debug)
			warnx("Returning %s   %s    %d.%d.%d.%d",
			    res.client_name, res.domain_name,
			    255 & res.router_address.bp_address_u.ip_addr.net,
			    255 & res.router_address.bp_address_u.ip_addr.host,
			    255 & res.router_address.bp_address_u.ip_addr.lh,
			    255 & res.router_address.bp_address_u.ip_addr.impno);
		if (dolog)
			syslog(LOG_NOTICE, "Returning %s   %s    %d.%d.%d.%d",
			    res.client_name, res.domain_name,
			    255 & res.router_address.bp_address_u.ip_addr.net,
			    255 & res.router_address.bp_address_u.ip_addr.host,
			    255 & res.router_address.bp_address_u.ip_addr.lh,
			    255 & res.router_address.bp_address_u.ip_addr.impno);
		return (&res);
	}
failed:
	if (debug)
		warnx("whoami failed");
	if (dolog)
		syslog(LOG_NOTICE, "whoami failed");
	return (NULL);
}


bp_getfile_res *
bootparamproc_getfile_1_svc(bp_getfile_arg *getfile, struct svc_req *rqstp)
{
	static bp_getfile_res res;
	int error;

	if (debug)
		warnx("getfile got question for \"%s\" and file \"%s\"",
		    getfile->client_name, getfile->file_id);

	if (dolog)
		syslog(LOG_NOTICE,
		    "getfile got question for \"%s\" and file \"%s\"",
		    getfile->client_name, getfile->file_id);

	he = NULL;
	he = gethostbyname(getfile->client_name);
	if (!he)
		goto failed;

	strlcpy(askname, he->h_name, sizeof askname);
	error = lookup_bootparam(askname, NULL, getfile->file_id,
	    &res.server_name, &res.server_path);
	if (error == 0) {
		he = gethostbyname(res.server_name);
		if (!he)
			goto failed;
		bcopy(he->h_addr, &res.server_address.bp_address_u.ip_addr, 4);
		res.server_address.address_type = IP_ADDR_TYPE;
	} else if (error == ENOENT && !strcmp(getfile->file_id, "dump")) {
		/* Special for dump, answer with null strings. */
		res.server_name[0] = '\0';
		res.server_path[0] = '\0';
		bzero(&res.server_address.bp_address_u.ip_addr, 4);
	} else {
failed:
		if (debug)
			warnx("getfile failed for %s", getfile->client_name);
		if (dolog)
			syslog(LOG_NOTICE,
			    "getfile failed for %s", getfile->client_name);
		return (NULL);
	}

	if (debug)
		warnx("returning server:%s path:%s address: %d.%d.%d.%d",
		    res.server_name, res.server_path,
		    255 & res.server_address.bp_address_u.ip_addr.net,
		    255 & res.server_address.bp_address_u.ip_addr.host,
		    255 & res.server_address.bp_address_u.ip_addr.lh,
		    255 & res.server_address.bp_address_u.ip_addr.impno);
	if (dolog)
		syslog(LOG_NOTICE,
		    "returning server:%s path:%s address: %d.%d.%d.%d",
		    res.server_name, res.server_path,
		    255 & res.server_address.bp_address_u.ip_addr.net,
		    255 & res.server_address.bp_address_u.ip_addr.host,
		    255 & res.server_address.bp_address_u.ip_addr.lh,
		    255 & res.server_address.bp_address_u.ip_addr.impno);
	return (&res);
}

int
lookup_bootparam(char *client, char *client_canonical, char *id,
    char **server, char **path)
{
	FILE   *f;
	static char buf[BUFSIZ];
	char   *bp, *word = NULL;
	size_t  idlen = id == NULL ? 0 : strlen(id);
	int	contin = 0, found = 0;

	f = fopen(bootpfile, "r");
	if (f == NULL)
		return EINVAL;	/* ? */

	while (fgets(buf, sizeof buf, f)) {
		int	wascontin = contin;

		contin = buf[strlen(buf) - 2] == '\\';
		bp = buf + strspn(buf, " \t\n");

		switch (wascontin) {
		case -1:
			/* Continuation of uninteresting line */
			contin *= -1;
			continue;
		case 0:
			/* New line */
			contin *= -1;
			if (*bp == '#')
				continue;
			if ((word = strsep(&bp, " \t\n")) == NULL)
				continue;
			/* See if this line's client is the one we are
			 * looking for */
			if (strcasecmp(word, client) != 0) {
				/*
				 * If it didn't match, try getting the
				 * canonical host name of the client
				 * on this line and comparing that to
				 * the client we are looking for
				 */
				struct hostent *hp = gethostbyname(word);
				if (hp == NULL || strcasecmp(hp->h_name, client))
					continue;
			}
			contin *= -1;
			break;
		case 1:
			/* Continued line we want to parse below */
			break;
		}

		if (client_canonical)
			strlcpy(client_canonical, word, MAX_MACHINE_NAME);

		/* We have found a line for CLIENT */
		if (id == NULL) {
			(void) fclose(f);
			return 0;
		}

		/* Look for a value for the parameter named by ID */
		while ((word = strsep(&bp, " \t\n")) != NULL) {
			if (!strncmp(word, id, idlen) && word[idlen] == '=') {
				/* We have found the entry we want */
				*server = &word[idlen + 1];
				*path = strchr(*server, ':');
				if (*path == NULL)
					/* Malformed entry */
					continue;
				*(*path)++ = '\0';
				(void) fclose(f);
				return 0;
			}
		}

		found = 1;
	}

	(void) fclose(f);
	return found ? ENOENT : EPERM;
}
@


1.20
log
@Delete YP lookup code; user base of 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.19 2015/11/20 17:49:59 deraadt Exp $	*/
d209 1
a209 1
	int err;
d226 1
a226 1
	err = lookup_bootparam(askname, NULL, getfile->file_id,
d228 1
a228 1
	if (err == 0) {
d234 1
a234 1
	} else if (err == ENOENT && !strcmp(getfile->file_id, "dump")) {
@


1.19
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.18 2007/02/18 20:33:45 jmc Exp $	*/
a8 1
 * Parser rewritten (adding YP support) by Roland McGrath <roland@@frob.com>
a271 4
#ifdef YP
	static char *ypbuf = NULL;
	static int ypbuflen = 0;
#endif
a298 15
#ifdef YP
			/* A + in the file means try YP now */
			if (!strcmp(word, "+")) {
				char   *ypdom;

				if (yp_get_default_domain(&ypdom) ||
				    yp_match(ypdom, "bootparams", client,
					strlen(client), &ypbuf, &ypbuflen))
					continue;
				bp = ypbuf;
				word = client;
				contin *= -1;
				break;
			}
#endif
@


1.18
log
@sync usage() and synopsis; spotted by Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.17 2003/12/25 19:05:09 deraadt Exp $	*/
a65 1

d90 1
a90 1
			bcopy(he->h_addr, (char *) &route_addr.s_addr,
d133 3
d159 1
a159 1
	bcopy((char *) &whoami->client_address.bp_address_u.ip_addr,
d161 1
a161 1
	he = gethostbyaddr((char *) &haddr, sizeof(haddr), AF_INET);
d272 1
a272 1
	FILE   *f = fopen(bootpfile, "r");
d282 1
@


1.17
log
@bootparams is right name
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.16 2003/07/21 19:54:47 mickey Exp $	*/
d61 1
a61 1
	fprintf(stderr, "usage: %s [-d] [-s] [-r router] [-f bootparamsfile]\n",
@


1.16
log
@use __progname
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.15 2003/07/06 21:34:03 deraadt Exp $	*/
d61 1
a61 1
	fprintf(stderr, "usage: %s [-d] [-s] [-r router] [-f bootparmsfile]\n",
@


1.15
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.14 2002/07/19 02:18:06 deraadt Exp $	*/
d60 3
a62 2
	fprintf(stderr,
	    "usage: rpc.bootparamd [-d] [-s] [-r router] [-f bootparmsfile]\n");
@


1.14
log
@use inet_aton(); mickey says it does not break what he uses -- good enough
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.13 2002/07/14 03:53:05 deraadt Exp $	*/
d57 1
a57 1
void
@


1.13
log
@various cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.12 2002/06/11 18:49:18 hin Exp $	*/
d21 2
d49 1
a49 2
in_addr_t route_addr;
in_addr_t inet_addr();
d83 1
a83 2
			if (isdigit(*optarg)) {
				route_addr = inet_addr(optarg);
a84 1
			}
d90 2
a91 1
			bcopy(he->h_addr, (char *) &route_addr, sizeof(route_addr));
d112 1
a112 1
	if (!route_addr) {
d114 2
a115 1
		bcopy(&my_addr.sin_addr.s_addr, &route_addr, sizeof(route_addr));
d175 1
a175 1
			bcopy(&route_addr,
@


1.12
log
@-Wall cleanup

ok millert@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.11 2002/02/16 21:28:08 millert Exp $	*/
a34 1
static char buffer[MAXLEN];
a36 1
static char path[MAX_PATH_LEN];
d40 2
d45 2
a46 2
int     debug = 0;
int     dolog = 0;
d57 1
a57 1
usage()
d69 1
a69 3
main(argc, argv)
	int     argc;
	char  **argv;
a70 1
	SVCXPRT *transp;
d73 1
d129 1
a129 1
		errx(1, "unable to register BOOTPARAMPROG version %d, udp",
d137 1
a137 3
bootparamproc_whoami_1_svc(whoami, rqstp)
	bp_whoami_arg *whoami;
	struct svc_req *rqstp;
d155 2
a156 2
	bcopy((char *) &whoami->client_address.bp_address_u.ip_addr, (char *) &haddr,
	    sizeof(haddr));
d166 1
a166 2
	strncpy(askname, he->h_name, sizeof askname-1);
	askname[sizeof askname-1] = '\0';
d174 2
a175 1
			bcopy(&route_addr, &res.router_address.bp_address_u.ip_addr, 4);
a190 1

d203 1
a203 3
bootparamproc_getfile_1_svc(getfile, rqstp)
	bp_getfile_arg *getfile;
	struct svc_req *rqstp;
d206 1
a206 1
	int     err;
d213 2
a214 1
		syslog(LOG_NOTICE, "getfile got question for \"%s\" and file \"%s\"",
d222 1
a222 2
	strncpy(askname, he->h_name, sizeof askname-1);
	askname[sizeof askname-1] = '\0';
a263 1

d265 2
a266 6
lookup_bootparam(client, client_canonical, id, server, path)
	char	*client;
	char	*client_canonical;
	char	*id;
	char	**server;
	char	**path;
d274 1
a274 1
	char   *bp, *word;
d276 1
a276 2
	int     contin = 0;
	int     found = 0;
d282 2
a283 1
		int     wascontin = contin;
d335 1
a335 1
			strncpy(client_canonical, word, MAX_MACHINE_NAME);
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.10 2001/07/27 20:34:36 pvalchev Exp $	*/
d16 1
d19 2
d26 4
@


1.10
log
@Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.9 1998/07/10 08:06:50 deraadt Exp $	*/
d34 1
a34 1
extern void bootparamprog_1 __P((struct svc_req *, SVCXPRT *));
@


1.9
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparamd.c,v 1.8 1998/05/03 05:02:09 gene Exp $	*/
a66 1
	int     i, s, pid;
a68 1
	char   *optstring;
a204 1
	char   *where;
@


1.8
log
@Hmmm... $Id$ -> $OpenBSD$.
Looks like the Id tags were left over from RCSid's on the original files.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d148 1
a148 1
		syslog(LOG_NOTICE, "whoami got question for %d.%d.%d.%d\n",
d184 1
a184 1
			syslog(LOG_NOTICE, "Returning %s   %s    %d.%d.%d.%d\n",
d197 1
a197 1
		syslog(LOG_NOTICE, "whoami failed\n");
d216 1
a216 1
		syslog(LOG_NOTICE, "getfile got question for \"%s\" and file \"%s\"\n",
d258 1
a258 1
		    "returning server:%s path:%s address: %d.%d.%d.%d\n",
@


1.7
log
@long vs int
@
text
@d1 2
a9 2
 *
 * $Id: bootparamd.c,v 1.6 1997/01/17 07:14:26 millert Exp $
@


1.6
log
@r?index -> strr?chr
@
text
@d9 1
a9 1
 * $Id: bootparamd.c,v 1.5 1996/12/10 15:13:31 deraadt Exp $
d40 2
a41 1
unsigned long route_addr, inet_addr();
d138 1
a138 1
	long    haddr;
@


1.5
log
@cleanup, some from netbsd
@
text
@d9 1
a9 1
 * $Id: bootparamd.c,v 1.4 1996/10/05 07:23:03 deraadt Exp $
a66 1
	char   *rindex();
d206 1
a206 1
	char   *where, *index();
@


1.4
log
@strcasecmp hostnames; from netbsd
@
text
@d9 1
a9 1
 * $Id: bootparamd.c,v 1.3 1996/08/31 01:20:48 deraadt Exp $
d42 1
a42 1
char   *progname;
d53 1
a72 6
	progname = rindex(argv[0], '/');
	if (progname)
		progname++;
	else
		progname = argv[0];

d85 1
a85 2
				fprintf(stderr, "%s: No such host %s\n",
				    progname, optarg);
a86 1
				exit(1);
d96 1
a96 1
			openlog(progname, 0, 0);
d98 1
a98 1
			openlog(progname, 0, LOG_DAEMON);
a103 1
			exit(1);
d106 3
a108 5
	if (stat(bootpfile, &buf)) {
		fprintf(stderr, "%s: ", progname);
		perror(bootpfile);
		exit(1);
	}
d113 4
a116 2
	if (!debug)
		daemon();
d121 6
a126 8
	if (transp == NULL) {
		fprintf(stderr, "cannot create udp service.\n");
		exit(1);
	}
	if (!svc_register(transp, BOOTPARAMPROG, BOOTPARAMVERS,
		bootparamprog_1, IPPROTO_UDP)) {
		fprintf(stderr,
		    "bootparamd: unable to register BOOTPARAMPROG version %d, udp)\n",
d128 1
a128 2
		exit(1);
	}
d130 1
a130 2
	fprintf(stderr, "svc_run returned\n");
	exit(1);
d142 1
a142 1
		fprintf(stderr, "whoami got question for %d.%d.%d.%d\n",
d161 1
a161 1
		fprintf(stderr, "This is host %s\n", he->h_name);
d163 1
a163 1
		syslog(LOG_NOTICE, "This is host %s\n", he->h_name);
d177 1
a177 1
			fprintf(stderr, "Returning %s   %s    %d.%d.%d.%d\n",
d195 1
a195 1
		fprintf(stderr, "whoami failed\n");
d212 1
a212 1
		fprintf(stderr, "getfile got question for \"%s\" and file \"%s\"\n",
d242 1
a242 2
			fprintf(stderr, "getfile failed for %s\n",
			    getfile->client_name);
d245 1
a245 1
			    "getfile failed for %s\n", getfile->client_name);
d250 1
a250 2
		fprintf(stderr,
		    "returning server:%s path:%s address: %d.%d.%d.%d\n",
@


1.3
log
@buf oflow, found by das33@@cornell.edu
@
text
@d9 1
a9 1
 * $Id: bootparamd.c,v 1.2 1996/04/21 23:41:48 deraadt Exp $
d338 1
a338 1
			if (strcmp(word, client) != 0) {
d346 1
a346 1
				if (hp == NULL || strcmp(hp->h_name, client))
@


1.2
log
@sync to netbsd 960418
@
text
@d9 1
a9 1
 * $Id: bootparamd.c,v 1.1.1.1 1995/10/18 08:48:05 deraadt Exp $
d177 2
a178 1
	strcpy(askname, he->h_name);
d236 2
a237 1
	strcpy(askname, he->h_name);
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
 * $Id: bootparamd.c,v 1.5 1995/06/24 15:03:53 pk Exp $
d70 1
a70 1
	char    c;
d78 1
a78 1
	while ((c = getopt(argc, argv, "dsr:f:")) != EOF)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
