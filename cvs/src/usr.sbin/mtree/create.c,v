head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.2
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.30.0.8
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.4
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.4
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.2
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.20
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.16
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.14
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.12
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.10
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.8
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.6
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.14
	OPENBSD_2_8:1.11.0.12
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.10
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.8
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2016.08.16.16.41.46;	author krw;	state Exp;
branches;
next	1.31;
commitid	ScqME4mWPdd178mi;

1.31
date	2016.08.14.20.53.19;	author krw;	state Exp;
branches;
next	1.30;
commitid	xzhggEXArJSGtLMV;

1.30
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Uu5nFG3wCl0LACBb;

1.29
date	2013.08.22.04.43.41;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.16.23.42.44;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.08.21.19.42;	author naddy;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.10.00.42.09;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.21.19.36.04;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.01.18.32.20;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.09.16.22.03;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.02.17.35.08;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.30.21.45.41;	author vincent;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.17.01.16;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.09.18.49.09;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.10.02.37.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.10.02.33.46;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.11.05.20.31.26;	author flipk;	state Exp;
branches;
next	1.10;

1.10
date	97.07.25.20.12.15;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.07.18.05.49.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.18.05.46.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.12.23.05.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.04.06.09.15.30;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.03.21.40.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.12.10.08.25.58;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.12.08.01.13.39;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.03.02.00.46.02;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Nuke a bunch of whitespace nits seen while '%q' hunting.
@
text
@/*	$NetBSD: create.c,v 1.11 1996/09/05 09:24:19 mycroft Exp $	*/
/*	$OpenBSD: create.c,v 1.31 2016/08/14 20:53:19 krw Exp $	*/

/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <time.h>
#include <fcntl.h>
#include <fts.h>
#include <dirent.h>
#include <grp.h>
#include <pwd.h>
#include <errno.h>
#include <unistd.h>
#include <limits.h>
#include <stdio.h>
#include <stdarg.h>
#include <vis.h>
#include <md5.h>
#include <rmd160.h>
#include <sha1.h>
#include <sha2.h>
#include "mtree.h"
#include "extern.h"

#define	INDENTNAMELEN	15
#define	MAXLINELEN	80

extern u_int32_t crc_total;
extern int ftsoptions;
extern int dflag, iflag, nflag, sflag;
extern u_int keys;
extern char fullpath[PATH_MAX];

static gid_t gid;
static uid_t uid;
static mode_t mode;

static void	output(int, int *, const char *, ...)
		    __attribute__((__format__ (printf, 3, 4)));
static int	statd(FTS *, FTSENT *, uid_t *, gid_t *, mode_t *);
static void	statf(int, FTSENT *);

void
cwalk(void)
{
	FTS *t;
	FTSENT *p;
	time_t clock;
	char *argv[2], host[HOST_NAME_MAX+1];
	int indent = 0;

	(void)time(&clock);
	(void)gethostname(host, sizeof(host));
	(void)printf(
	    "#\t   user: %s\n#\tmachine: %s\n#\t   tree: %s\n#\t   date: %s",
	    getlogin(), host, fullpath, ctime(&clock));

	argv[0] = ".";
	argv[1] = NULL;
	if ((t = fts_open(argv, ftsoptions, dsort)) == NULL)
		error("fts_open: %s", strerror(errno));
	while ((p = fts_read(t))) {
		if (iflag)
			indent = p->fts_level * 4;
		switch(p->fts_info) {
		case FTS_D:
			if (!dflag)
				(void)printf("\n");
			if (!nflag)
				(void)printf("# %s\n", p->fts_path);
			statd(t, p, &uid, &gid, &mode);
			statf(indent, p);
			break;
		case FTS_DP:
			if (!nflag && (p->fts_level > 0))
				(void)printf("%*s# %s\n", indent, "", p->fts_path);
			(void)printf("%*s..\n", indent, "");
			if (!dflag)
				(void)printf("\n");
			break;
		case FTS_DNR:
		case FTS_ERR:
		case FTS_NS:
			(void)fprintf(stderr, "mtree: %s: %s\n",
			    p->fts_path, strerror(p->fts_errno));
			break;
		default:
			if (!dflag)
				statf(indent, p);
			break;
		}
	}
	(void)fts_close(t);
	if (sflag && keys & F_CKSUM)
		(void)fprintf(stderr,
		    "mtree: %s checksum: %u\n", fullpath, crc_total);
}

static void
statf(int indent, FTSENT *p)
{
	struct group *gr;
	struct passwd *pw;
	u_int32_t len, val;
	int fd, offset;
	char *name, *escaped_name;
	size_t esc_len;

	esc_len = p->fts_namelen * 4 + 1;
	escaped_name = malloc(esc_len);
	if (escaped_name == NULL)
		error("statf: %s", strerror(errno));
	strnvis(escaped_name, p->fts_name, esc_len,
	    VIS_WHITE | VIS_OCTAL | VIS_GLOB);

	if (iflag || S_ISDIR(p->fts_statp->st_mode))
		offset = printf("%*s%s", indent, "", escaped_name);
	else
		offset = printf("%*s    %s", indent, "", escaped_name);

	free(escaped_name);

	if (offset > (INDENTNAMELEN + indent))
		offset = MAXLINELEN;
	else
		offset += printf("%*s", (INDENTNAMELEN + indent) - offset, "");

	if (!S_ISREG(p->fts_statp->st_mode) && !dflag)
		output(indent, &offset, "type=%s", inotype(p->fts_statp->st_mode));
	if (p->fts_statp->st_uid != uid) {
		if (keys & F_UNAME) {
			if ((pw = getpwuid(p->fts_statp->st_uid)) != NULL) {
				output(indent, &offset, "uname=%s", pw->pw_name);
			} else {
				error("could not get uname for uid=%u",
				    p->fts_statp->st_uid);
			}
		}
		if (keys & F_UID)
			output(indent, &offset, "uid=%u", p->fts_statp->st_uid);
	}
	if (p->fts_statp->st_gid != gid) {
		if (keys & F_GNAME) {
			if ((gr = getgrgid(p->fts_statp->st_gid)) != NULL) {
				output(indent, &offset, "gname=%s", gr->gr_name);
			} else {
				error("could not get gname for gid=%u",
				    p->fts_statp->st_gid);
			}
		}
		if (keys & F_GID)
			output(indent, &offset, "gid=%u", p->fts_statp->st_gid);
	}
	if (keys & F_MODE && (p->fts_statp->st_mode & MBITS) != mode)
		output(indent, &offset, "mode=%#o", p->fts_statp->st_mode & MBITS);
	if (keys & F_NLINK && p->fts_statp->st_nlink != 1)
		output(indent, &offset, "nlink=%u", p->fts_statp->st_nlink);
	if (keys & F_SIZE && S_ISREG(p->fts_statp->st_mode))
		output(indent, &offset, "size=%lld",
		    (long long)p->fts_statp->st_size);
	if (keys & F_TIME)
		output(indent, &offset, "time=%lld.%ld",
		    (long long)p->fts_statp->st_mtimespec.tv_sec,
		    p->fts_statp->st_mtimespec.tv_nsec);
	if (keys & F_CKSUM && S_ISREG(p->fts_statp->st_mode)) {
		if ((fd = open(p->fts_accpath, MTREE_O_FLAGS, 0)) < 0 ||
		    crc(fd, &val, &len))
			error("%s: %s", p->fts_accpath, strerror(errno));
		(void)close(fd);
		output(indent, &offset, "cksum=%u", val);
	}
	if (keys & F_MD5 && S_ISREG(p->fts_statp->st_mode)) {
		char *md5digest, buf[MD5_DIGEST_STRING_LENGTH];

		md5digest = MD5File(p->fts_accpath,buf);
		if (!md5digest)
			error("%s: %s", p->fts_accpath, strerror(errno));
		else
			output(indent, &offset, "md5digest=%s", md5digest);
	}
	if (keys & F_RMD160 && S_ISREG(p->fts_statp->st_mode)) {
		char *rmd160digest, buf[RMD160_DIGEST_STRING_LENGTH];

		rmd160digest = RMD160File(p->fts_accpath,buf);
		if (!rmd160digest)
			error("%s: %s", p->fts_accpath, strerror(errno));
		else
			output(indent, &offset, "rmd160digest=%s", rmd160digest);
	}
	if (keys & F_SHA1 && S_ISREG(p->fts_statp->st_mode)) {
		char *sha1digest, buf[SHA1_DIGEST_STRING_LENGTH];

		sha1digest = SHA1File(p->fts_accpath,buf);
		if (!sha1digest)
			error("%s: %s", p->fts_accpath, strerror(errno));
		else
			output(indent, &offset, "sha1digest=%s", sha1digest);
	}
	if (keys & F_SHA256 && S_ISREG(p->fts_statp->st_mode)) {
		char *sha256digest, buf[SHA256_DIGEST_STRING_LENGTH];

		sha256digest = SHA256File(p->fts_accpath,buf);
		if (!sha256digest)
			error("%s: %s", p->fts_accpath, strerror(errno));
		else
			output(indent, &offset, "sha256digest=%s", sha256digest);
	}
	if (keys & F_SLINK &&
	    (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {
		name = rlink(p->fts_accpath);
		esc_len = strlen(name) * 4 + 1;
		escaped_name = malloc(esc_len);
		if (escaped_name == NULL)
			error("statf: %s", strerror(errno));
		strnvis(escaped_name, name, esc_len, VIS_WHITE | VIS_OCTAL);
		output(indent, &offset, "link=%s", escaped_name);
		free(escaped_name);
	}
	if (keys & F_FLAGS && !S_ISLNK(p->fts_statp->st_mode)) {
		char *file_flags;

		file_flags = fflagstostr(p->fts_statp->st_flags);
		if (file_flags == NULL)
			error("%s", strerror(errno));
		if (*file_flags != '\0')
			output(indent, &offset, "flags=%s", file_flags);
		else
			output(indent, &offset, "flags=none");
		free(file_flags);
	}
	(void)putchar('\n');
}

#define	MAXGID	5000
#define	MAXUID	5000
#define	MAXMODE	MBITS + 1

static int
statd(FTS *t, FTSENT *parent, uid_t *puid, gid_t *pgid, mode_t *pmode)
{
	FTSENT *p;
	gid_t sgid;
	uid_t suid;
	mode_t smode;
	struct group *gr;
	struct passwd *pw;
	gid_t savegid = *pgid;
	uid_t saveuid = *puid;
	mode_t savemode = *pmode;
	int maxgid;
	int maxuid;
	u_short maxmode;
	gid_t g[MAXGID];
	uid_t u[MAXUID];
	mode_t m[MAXMODE];
	static int first = 1;

	if ((p = fts_children(t, 0)) == NULL) {
		if (errno)
			error("%s: %s", RP(parent), strerror(errno));
		return (1);
	}

	bzero(g, sizeof(g));
	bzero(u, sizeof(u));
	bzero(m, sizeof(m));

	maxuid = maxgid = maxmode = 0;
	for (; p; p = p->fts_link) {
		if (!dflag || (dflag && S_ISDIR(p->fts_statp->st_mode))) {
			smode = p->fts_statp->st_mode & MBITS;
			if (smode < MAXMODE && ++m[smode] > maxmode) {
				savemode = smode;
				maxmode = m[smode];
			}
			sgid = p->fts_statp->st_gid;
			if (sgid < MAXGID && ++g[sgid] > maxgid) {
				savegid = sgid;
				maxgid = g[sgid];
			}
			suid = p->fts_statp->st_uid;
			if (suid < MAXUID && ++u[suid] > maxuid) {
				saveuid = suid;
				maxuid = u[suid];
			}
		}
	}
	/*
	 * If the /set record is the same as the last one we do not need to output
	 * a new one.  So first we check to see if anything changed.  Note that we
	 * always output a /set record for the first directory.
	 */
	if ((((keys & F_UNAME) | (keys & F_UID)) && (*puid != saveuid)) ||
	    (((keys & F_GNAME) | (keys & F_GID)) && (*pgid != savegid)) ||
	    ((keys & F_MODE) && (*pmode != savemode)) || (first)) {
		first = 0;
		if (dflag)
			(void)printf("/set type=dir");
		else
			(void)printf("/set type=file");
		if (keys & F_UNAME) {
			if ((pw = getpwuid(saveuid)) != NULL)
				(void)printf(" uname=%s", pw->pw_name);
			else
				error("could not get uname for uid=%u", saveuid);
		}
		if (keys & F_UID)
			(void)printf(" uid=%u", saveuid);
		if (keys & F_GNAME) {
			if ((gr = getgrgid(savegid)) != NULL)
				(void)printf(" gname=%s", gr->gr_name);
			else
				error("could not get gname for gid=%u", savegid);
		}
		if (keys & F_GID)
			(void)printf(" gid=%u", savegid);
		if (keys & F_MODE)
			(void)printf(" mode=%#o", savemode);
		if (keys & F_NLINK)
			(void)printf(" nlink=1");
		(void)printf("\n");
		*puid = saveuid;
		*pgid = savegid;
		*pmode = savemode;
	}
	return (0);
}

int
dsort(const FTSENT **a, const FTSENT **b)
{
	if (S_ISDIR((*a)->fts_statp->st_mode)) {
		if (!S_ISDIR((*b)->fts_statp->st_mode))
			return (1);
	} else if (S_ISDIR((*b)->fts_statp->st_mode))
		return (-1);
	return (strcmp((*a)->fts_name, (*b)->fts_name));
}

void
output(int indent, int *offset, const char *fmt, ...)
{
	va_list ap;
	char buf[1024];

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);

	if (*offset + strlen(buf) > MAXLINELEN - 3) {
		(void)printf(" \\\n%*s", INDENTNAMELEN + indent, "");
		*offset = INDENTNAMELEN + indent;
	}
	*offset += printf(" %s", buf) + 1;
}
@


1.31
log
@%qd -> %lld + (long long) for off_t's.

ok guenther@@ natano@@
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.30 2015/01/16 06:40:18 deraadt Exp $	*/
a118 1
			
d141 1
a141 1
 	strnvis(escaped_name, p->fts_name, esc_len,
@


1.30
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.29 2013/08/22 04:43:41 guenther Exp $	*/
d188 2
a189 1
		output(indent, &offset, "size=%qd", p->fts_statp->st_size);
@


1.29
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.28 2013/04/16 23:42:44 deraadt Exp $	*/
a32 1
#include <sys/param.h>
d42 1
d60 1
a60 1
extern char fullpath[MAXPATHLEN];
d77 1
a77 1
	char *argv[2], host[MAXHOSTNAMELEN];
@


1.28
log
@handle large time_t types; ok millert
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.27 2012/07/08 21:19:42 naddy Exp $	*/
d198 1
a198 1
		output(indent, &offset, "cksum=%lu", val);
@


1.27
log
@Add support for the "sha256digest" keyword to create/compare
SHA-256 digests of files.  In the man page, also replace SHA-1
with SHA-256 in the examples section.

Man page formatting tweak and ok schwarze@@
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.26 2009/10/27 23:59:53 deraadt Exp $	*/
d190 2
a191 2
		output(indent, &offset, "time=%ld.%ld",
		    p->fts_statp->st_mtimespec.tv_sec,
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.25 2005/08/10 00:42:09 millert Exp $	*/
d47 1
d49 1
a49 1
#include <rmd160.h>
d226 9
@


1.25
log
@Call open(2) with O_NONBLOCK and O_NOFOLLOW to make sure mtree can't
be halted by a FIFO or special device.
Use fgetln() instead of fgets() to handle arbitrarily long lines.
If a line starts with a comment char, don't check for line continuation char.
Adapted from a diff by Solar Designer.  OK deraadt@@ henning@@
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.24 2004/11/21 19:36:04 otto Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)create.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: create.c,v 1.24 2004/11/21 19:36:04 otto Exp $";
#endif
#endif /* not lint */
@


1.24
log
@Use the same ordering when verifying as with creating and replace
some hardcoded constants with symbolic ones. Noted by Ed Wandasiewicz
in PR 3991.

ok deraadt@@ millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.23 2004/08/01 18:32:20 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.23 2004/08/01 18:32:20 deraadt Exp $";
d73 2
a74 1
static void	output(int, int *, const char *, ...);
d149 2
a150 1
 	strnvis(escaped_name, p->fts_name, esc_len, VIS_WHITE | VIS_OCTAL);
d201 1
a201 1
		if ((fd = open(p->fts_accpath, O_RDONLY, 0)) < 0 ||
@


1.23
log
@ansi cleanup; khalek@@linuxgamers.net
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.22 2004/07/09 16:22:03 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.22 2004/07/09 16:22:03 deraadt Exp $";
a72 1
static int	dsort(const FTSENT **, const FTSENT **);
d215 1
a215 1
		char *rmd160digest, buf[41];
d224 1
a224 1
		char *sha1digest, buf[41];
d353 1
a353 1
static int
@


1.22
log
@ansi
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.21 2004/05/02 17:35:08 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.21 2004/05/02 17:35:08 millert Exp $";
d136 1
a136 3
statf(indent, p)
	int indent;
	FTSENT *p;
d264 1
a264 6
statd(t, parent, puid, pgid, pmode)
	FTS *t;
	FTSENT *parent;
	uid_t *puid;
	gid_t *pgid;
	mode_t *pmode;
d355 1
a355 2
dsort(a, b)
	const FTSENT **a, **b;
@


1.21
log
@Use MD5_DIGEST_STRING_LENGTH
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.20 2003/06/02 23:36:54 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.20 2003/06/02 23:36:54 millert Exp $";
d79 1
a79 1
cwalk()
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.19 2003/04/30 21:45:41 vincent Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.19 2003/04/30 21:45:41 vincent Exp $";
d209 1
a209 1
		char *md5digest, buf[33];
@


1.19
log
@one more strvis -> strnvis.

ok millert
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.18 2002/03/14 17:01:16 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.18 2002/03/14 17:01:16 millert Exp $";
@


1.18
log
@We also need to vis-encode the path contained in a symbolic link.
Based on a patch from Nicolas Rachinsky (FreeBSD PR 35454).
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.17 2002/03/14 16:44:25 mpech Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.17 2002/03/14 16:44:25 mpech Exp $";
d149 1
d151 2
a152 1
	escaped_name = malloc(p->fts_namelen * 4  +  1);
d155 1
a155 1
	strvis(escaped_name, p->fts_name, VIS_WHITE | VIS_OCTAL);
d242 2
a243 1
		escaped_name = malloc(strlen(name) * 4  +  1);
d246 1
a246 1
		strvis(escaped_name, name, VIS_WHITE | VIS_OCTAL);
@


1.17
log
@kill more registers.

millert@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.16 2002/03/09 18:49:09 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.16 2002/03/09 18:49:09 millert Exp $";
d148 1
a148 1
	char *escaped_name;
d238 9
a246 2
	    (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE))
		output(indent, &offset, "link=%s", rlink(p->fts_accpath));
@


1.16
log
@Escape whitespace and encode special chars with vis(3); from FreeBSD
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.15 2002/02/19 19:39:40 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.15 2002/02/19 19:39:40 millert Exp $";
d85 2
a86 2
	register FTS *t;
	register FTSENT *p;
d267 4
a270 4
	register FTSENT *p;
	register gid_t sgid;
	register uid_t suid;
	register mode_t smode;
@


1.15
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.14 2002/02/16 21:28:05 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.14 2002/02/16 21:28:05 millert Exp $";
d57 1
d148 6
d156 1
a156 1
		offset = printf("%*s%s", indent, "", p->fts_name);
d158 3
a160 1
		offset = printf("%*s    %s", indent, "", p->fts_name);
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.13 2001/08/10 02:37:14 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.13 2001/08/10 02:37:14 millert Exp $";
d56 1
a357 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a358 1
#ifdef __STDC__
a359 7
#else
output(indent, offset, fmt, va_alist)
	int indent;
	int *offset;
	char *fmt;
        va_dcl
#endif
d363 1
a363 1
#ifdef __STDC__
a364 3
#else
	va_start(ap);
#endif
@


1.13
log
@pass -Wall
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.12 2001/08/10 02:33:46 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: create.c,v 1.12 2001/08/10 02:33:46 millert Exp $";
d75 4
a78 4
static int	dsort __P((const FTSENT **, const FTSENT **));
static void	output __P((int, int *, const char *, ...));
static int	statd __P((FTS *, FTSENT *, uid_t *, gid_t *, mode_t *));
static void	statf __P((int, FTSENT *));
@


1.12
log
@Add file flag support to mtree from henning@@crackinghacking.de
with man page update and minor tweaks by me.
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.11 1997/11/05 20:31:26 flipk Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)create.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: create.c,v 1.11 1997/11/05 20:31:26 flipk Exp $";
d317 1
a317 1
		if (keys & F_UNAME)
d322 1
d325 1
a325 1
		if (keys & F_GNAME)
d330 1
@


1.11
log
@u_short keys --> u_int keys
so now, keywords "uid" and "uname" work again.
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.10 1997/07/25 20:12:15 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: create.c,v 1.10 1997/07/25 20:12:15 mickey Exp $";
d230 12
@


1.10
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.9 1997/07/18 05:49:02 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: create.c,v 1.9 1997/07/18 05:49:02 millert Exp $";
d68 1
a68 1
extern u_short keys;
@


1.9
log
@err() -> error() so we don't conflict with err(3).
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.8 1997/07/18 05:46:12 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: create.c,v 1.8 1997/07/18 05:46:12 millert Exp $";
d343 1
a343 1
#if __STDC__
d350 1
a350 1
#if __STDC__
d362 1
a362 1
#if __STDC__
@


1.8
log
@Add rmd160 support.  Sheesh, you'd think this was tripwire.
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.7 1997/07/12 23:05:34 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: create.c,v 1.7 1997/07/12 23:05:34 millert Exp $";
d98 1
a98 1
		err("fts_open: %s", strerror(errno));
d164 1
a164 1
				err("could not get uname for uid=%u",
d176 1
a176 1
				err("could not get gname for gid=%u",
d196 1
a196 1
			err("%s: %s", p->fts_accpath, strerror(errno));
d205 1
a205 1
			err("%s: %s", p->fts_accpath, strerror(errno));
d214 1
a214 1
			err("%s: %s", p->fts_accpath, strerror(errno));
d223 1
a223 1
			err("%s: %s", p->fts_accpath, strerror(errno));
d264 1
a264 1
			err("%s: %s", RP(parent), strerror(errno));
d309 1
a309 1
				err("could not get uname for uid=%u", saveuid);
d316 1
a316 1
				err("could not get gname for gid=%u", savegid);
@


1.7
log
@Add sha1 digest support.
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.6 1997/04/06 09:15:30 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: create.c,v 1.6 1997/04/06 09:15:30 deraadt Exp $";
d58 1
d208 9
@


1.6
log
@16 bit uids suck
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.5 1997/01/03 21:40:49 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: create.c,v 1.5 1997/01/03 21:40:49 millert Exp $";
d57 1
d203 1
a203 1
		if (!md5digest) {
d205 1
a205 1
		} else {
d207 9
a215 1
		}
@


1.5
log
@From NetBSD:
    Add a `-t' (touch) option to update time stamps.
    Only record size for regular files.
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.4 1996/12/10 08:25:58 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: create.c,v 1.9 1995/03/07 21:12:06 cgd Exp $";
d235 6
a240 1
	u_short maxgid, maxuid, maxmode, g[MAXGID], u[MAXUID], m[MAXMODE];
@


1.4
log
@merge freebsd mtree diffs, plus -Wall cleanup
@
text
@d1 2
a2 2
/*	$NetBSD: create.c,v 1.9 1995/03/07 21:12:06 cgd Exp $	*/
/*	$OpenBSD: create.c,v 1.3 1996/12/08 01:13:39 niklas Exp $	*/
d41 1
a41 1
static char rcsid[] = "$NetBSD: create.c,v 1.9 1995/03/07 21:12:06 cgd Exp $";
d185 1
a185 1
	if (keys & F_SIZE)
@


1.3
log
@64-bit clean + RCS tags
@
text
@d2 1
a2 1
/*	$OpenBSD: create.c,v 1.2 1996/03/02 00:46:02 tholo Exp $	*/
d56 1
d65 1
a65 1
extern int dflag, sflag;
d74 1
a74 1
static void	output __P((int *, const char *, ...));
d76 1
a76 1
static void	statf __P((FTSENT *));
d85 1
d97 3
a99 1
	while (p = fts_read(t))
d102 4
a105 1
			(void)printf("\n# %s\n", p->fts_path);
d107 1
a107 1
			statf(p);
d110 5
a114 2
			if (p->fts_level > 0)
				(void)printf("# %s\n..\n\n", p->fts_path);
d119 2
a120 2
			(void)fprintf(stderr,
			    "mtree: %s: %s\n", p->fts_path, strerror(errno));
d124 1
a124 1
				statf(p);
d128 1
d136 2
a137 1
statf(p)
d143 1
a143 1
	int fd, indent;
d145 2
a146 2
	if (S_ISDIR(p->fts_statp->st_mode))
		indent = printf("%s", p->fts_name); 
d148 1
a148 1
		indent = printf("    %s", p->fts_name);
d150 2
a151 2
	if (indent > INDENTNAMELEN)
		indent = MAXLINELEN;
d153 1
a153 1
		indent += printf("%*s", INDENTNAMELEN - indent, "");
d155 26
a180 12
	if (!S_ISREG(p->fts_statp->st_mode))
		output(&indent, "type=%s", inotype(p->fts_statp->st_mode));
	if (keys & (F_UID | F_UNAME) && p->fts_statp->st_uid != uid)
		if (keys & F_UNAME && (pw = getpwuid(p->fts_statp->st_uid)))
			output(&indent, "uname=%s", pw->pw_name);
		else /* if (keys & F_UID) */
			output(&indent, "uid=%u", p->fts_statp->st_uid);
	if (keys & (F_GID | F_GNAME) && p->fts_statp->st_gid != gid)
		if (keys & F_GNAME && (gr = getgrgid(p->fts_statp->st_gid)))
			output(&indent, "gname=%s", gr->gr_name);
		else /* if (keys & F_GID) */
			output(&indent, "gid=%u", p->fts_statp->st_gid);
d182 1
a182 1
		output(&indent, "mode=%#o", p->fts_statp->st_mode & MBITS);
d184 1
a184 1
		output(&indent, "nlink=%u", p->fts_statp->st_nlink);
d186 1
a186 1
		output(&indent, "size=%qd", p->fts_statp->st_size);
d188 1
a188 1
		output(&indent, "time=%ld.%ld",
d196 11
a206 1
		output(&indent, "cksum=%u", val);
d210 1
a210 1
		output(&indent, "link=%s", rlink(p->fts_accpath));
d232 3
a234 3
	gid_t savegid;
	uid_t saveuid;
	mode_t savemode;
d236 1
d250 16
a265 14
		smode = p->fts_statp->st_mode & MBITS;
		if (smode < MAXMODE && ++m[smode] > maxmode) {
			savemode = smode;
			maxmode = m[smode];
		}
		sgid = p->fts_statp->st_gid;
		if (sgid < MAXGID && ++g[sgid] > maxgid) {
			savegid = sgid;
			maxgid = g[sgid];
		}
		suid = p->fts_statp->st_uid;
		if (suid < MAXUID && ++u[suid] > maxuid) {
			saveuid = suid;
			maxuid = u[suid];
d268 11
a278 6
	(void)printf("/set type=file");
	if (keys & F_GID)
		(void)printf(" gid=%u", savegid);
	if (keys & F_GNAME)
		if ((gr = getgrgid(savegid)) != NULL)
			(void)printf(" gname=%s", gr->gr_name);
d280 14
d295 9
a303 15
	if (keys & F_UNAME)
		if ((pw = getpwuid(saveuid)) != NULL)
			(void)printf(" uname=%s", pw->pw_name);
		else
			(void)printf(" uid=%u", saveuid);
	if (keys & F_UID)
		(void)printf(" uid=%u", saveuid);
	if (keys & F_MODE)
		(void)printf(" mode=%#o", savemode);
	if (keys & F_NLINK)
		(void)printf(" nlink=1");
	(void)printf("\n");
	*puid = saveuid;
	*pgid = savegid;
	*pmode = savemode;
d327 1
a327 1
output(int *offset, const char *fmt, ...)
d329 2
a330 1
output(offset, fmt, va_alist)
d347 2
a348 2
		(void)printf(" \\\n%*s", INDENTNAMELEN, "");
		*offset = INDENTNAMELEN;
@


1.2
log
@timespec members are now named tv_{,u}sec
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d62 2
a63 1
extern int crc_total, ftsoptions;
d121 1
a121 1
		    "mtree: %s checksum: %lu\n", fullpath, crc_total);
d130 1
a130 1
	u_long len, val;
d170 1
a170 1
		output(&indent, "cksum=%lu", val);
@


1.1
log
@Initial revision
@
text
@d2 1
d162 2
a163 2
		    p->fts_statp->st_mtimespec.ts_sec,
		    p->fts_statp->st_mtimespec.ts_nsec);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
