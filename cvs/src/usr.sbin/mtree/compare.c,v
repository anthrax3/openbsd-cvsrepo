head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.12
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.10
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.6
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.10
	OPENBSD_5_0:1.22.0.8
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.20
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.16
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.14
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.12
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.10
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.8
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.6
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.12
	OPENBSD_2_8:1.10.0.10
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.8
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.08.16.16.41.46;	author krw;	state Exp;
branches;
next	1.26;
commitid	ScqME4mWPdd178mi;

1.26
date	2016.08.14.20.53.19;	author krw;	state Exp;
branches;
next	1.25;
commitid	xzhggEXArJSGtLMV;

1.25
date	2015.12.21.19.37.21;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	wQOWs1MfwVJdcEC9;

1.24
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2012.07.08.21.19.42;	author naddy;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.10.00.42.09;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.21.19.36.04;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.01.18.32.20;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.02.17.35.08;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.23.04.10.14;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.01.16.48.18;	author jakob;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.10.02.37.14;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.10.02.33.46;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.05.18.19.10.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.18.05.49.02;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.18.05.46.11;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.12.23.05.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.03.21.40.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.12.10.08.25.57;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.12.08.01.13.38;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.02.00.46.00;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.54.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Nuke a bunch of whitespace nits seen while '%q' hunting.
@
text
@/*	$NetBSD: compare.c,v 1.11 1996/09/05 09:56:48 mycroft Exp $	*/
/*	$OpenBSD: compare.c,v 1.26 2016/08/14 20:53:19 krw Exp $	*/

/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <fcntl.h>
#include <fts.h>
#include <errno.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <md5.h>
#include <rmd160.h>
#include <sha1.h>
#include <sha2.h>
#include "mtree.h"
#include "extern.h"

extern int lflag, tflag, uflag;

static char *ftype(u_int);

#define	INDENTNAMELEN	8
#define	LABEL \
	if (!label++) { \
		len = printf("%s: ", RP(p)); \
		if (len > INDENTNAMELEN) { \
			tab = "\t"; \
			(void)printf("\n"); \
		} else { \
			tab = ""; \
			(void)printf("%*s", INDENTNAMELEN - (int)len, ""); \
		} \
	}

#define REPLACE_COMMA(x)						\
	do {								\
		char *l;						\
		for (l = x; *l; l++) {					\
			if (*l == ',')					\
				*l = ' ';				\
		}							\
	} while (0)							\

int
compare(char *name, NODE *s, FTSENT *p)
{
	u_int32_t len, val;
	int fd, label;
	char *cp, *tab = "";

	label = 0;
	switch(s->type) {
	case F_BLOCK:
		if (!S_ISBLK(p->fts_statp->st_mode))
			goto typeerr;
		break;
	case F_CHAR:
		if (!S_ISCHR(p->fts_statp->st_mode))
			goto typeerr;
		break;
	case F_DIR:
		if (!S_ISDIR(p->fts_statp->st_mode))
			goto typeerr;
		break;
	case F_FIFO:
		if (!S_ISFIFO(p->fts_statp->st_mode))
			goto typeerr;
		break;
	case F_FILE:
		if (!S_ISREG(p->fts_statp->st_mode))
			goto typeerr;
		break;
	case F_LINK:
		if (!S_ISLNK(p->fts_statp->st_mode))
			goto typeerr;
		break;
	case F_SOCK:
		if (!S_ISSOCK(p->fts_statp->st_mode)) {
typeerr:		LABEL;
			(void)printf("\ttype (%s, %s)\n",
			    ftype(s->type), inotype(p->fts_statp->st_mode));
		}
		break;
	}
	/* Set the uid/gid first, then set the mode. */
	if (s->flags & (F_UID | F_UNAME) && s->st_uid != p->fts_statp->st_uid) {
		LABEL;
		(void)printf("%suser (%u, %u",
		    tab, s->st_uid, p->fts_statp->st_uid);
		if (uflag)
			if (chown(p->fts_accpath, s->st_uid, -1))
				(void)printf(", not modified: %s)\n",
				    strerror(errno));
			else
				(void)printf(", modified)\n");
		else
			(void)printf(")\n");
		tab = "\t";
	}
	if (s->flags & (F_GID | F_GNAME) && s->st_gid != p->fts_statp->st_gid) {
		LABEL;
		(void)printf("%sgid (%u, %u",
		    tab, s->st_gid, p->fts_statp->st_gid);
		if (uflag)
			if (chown(p->fts_accpath, -1, s->st_gid))
				(void)printf(", not modified: %s)\n",
				    strerror(errno));
			else
				(void)printf(", modified)\n");
		else
			(void)printf(")\n");
		tab = "\t";
	}
	if (s->flags & F_MODE &&
	    s->st_mode != (p->fts_statp->st_mode & MBITS)) {
		if (lflag) {
			mode_t tmode, mode;

			tmode = s->st_mode;
			mode = p->fts_statp->st_mode & MBITS;
			/*
			 * if none of the suid/sgid/etc bits are set,
			 * then if the mode is a subset of the target,
			 * skip.
			 */
			if (!((tmode & ~(S_IRWXU|S_IRWXG|S_IRWXO)) ||
			    (mode & ~(S_IRWXU|S_IRWXG|S_IRWXO))))
				if ((mode | tmode) == tmode)
					goto skip;
		}
		LABEL;
		(void)printf("%spermissions (%#o, %#o",
		    tab, s->st_mode, p->fts_statp->st_mode & MBITS);
		if (uflag)
			if (chmod(p->fts_accpath, s->st_mode))
				(void)printf(", not modified: %s)\n",
				    strerror(errno));
			else
				(void)printf(", modified)\n");
		else
			(void)printf(")\n");
		tab = "\t";
	skip:
		;
	}
	if (s->flags & F_NLINK && s->type != F_DIR &&
	    s->st_nlink != p->fts_statp->st_nlink) {
		LABEL;
		(void)printf("%slink count (%u, %u)\n",
		    tab, s->st_nlink, p->fts_statp->st_nlink);
		tab = "\t";
	}
	if (s->flags & F_SIZE && s->st_size != p->fts_statp->st_size) {
		LABEL;
		(void)printf("%ssize (%lld, %lld)\n",
		    tab, (long long)s->st_size,
		    (long long)p->fts_statp->st_size);
		tab = "\t";
	}
	/*
	 * XXX
	 * Since utimes(2) only takes a timeval, there's no point in
	 * comparing the low bits of the timespec nanosecond field.  This
	 * will only result in mismatches that we can never fix.
	 *
	 * Doesn't display microsecond differences.
	 */
	if (s->flags & F_TIME) {
		struct timeval tv[2];

		TIMESPEC_TO_TIMEVAL(&tv[0], &s->st_mtimespec);
		TIMESPEC_TO_TIMEVAL(&tv[1], &p->fts_statp->st_mtimespec);
		if (tv[0].tv_sec != tv[1].tv_sec ||
		    tv[0].tv_usec != tv[1].tv_usec) {
			LABEL;
			(void)printf("%smodification time (%.24s, ",
			    tab, ctime(&s->st_mtimespec.tv_sec));
			(void)printf("%.24s",
			    ctime(&p->fts_statp->st_mtimespec.tv_sec));
			if (tflag) {
				tv[1] = tv[0];
				if (utimes(p->fts_accpath, tv))
					(void)printf(", not modified: %s)\n",
					    strerror(errno));
				else
					(void)printf(", modified)\n");
			} else
				(void)printf(")\n");
			tab = "\t";
		}
	}
	if (s->flags & F_CKSUM) {
		if ((fd = open(p->fts_accpath, MTREE_O_FLAGS, 0)) < 0) {
			LABEL;
			(void)printf("%scksum: %s: %s\n",
			    tab, p->fts_accpath, strerror(errno));
			tab = "\t";
		} else if (crc(fd, &val, &len)) {
			(void)close(fd);
			LABEL;
			(void)printf("%scksum: %s: %s\n",
			    tab, p->fts_accpath, strerror(errno));
			tab = "\t";
		} else {
			(void)close(fd);
			if (s->cksum != val) {
				LABEL;
				(void)printf("%scksum (%u, %u)\n",
				    tab, s->cksum, val);
			}
			tab = "\t";
		}
	}
	if (s->flags & F_MD5) {
		char *new_digest, buf[MD5_DIGEST_STRING_LENGTH];

		new_digest = MD5File(p->fts_accpath, buf);
		if (!new_digest) {
			LABEL;
			printf("%sMD5File: %s: %s\n", tab, p->fts_accpath,
			       strerror(errno));
			tab = "\t";
		} else if (strcmp(new_digest, s->md5digest)) {
			LABEL;
			printf("%sMD5 (%s, %s)\n", tab, s->md5digest,
			       new_digest);
			tab = "\t";
		}
	}
	if (s->flags & F_RMD160) {
		char *new_digest, buf[RMD160_DIGEST_STRING_LENGTH];

		new_digest = RMD160File(p->fts_accpath, buf);
		if (!new_digest) {
			LABEL;
			printf("%sRMD160File: %s: %s\n", tab, p->fts_accpath,
			       strerror(errno));
			tab = "\t";
		} else if (strcmp(new_digest, s->rmd160digest)) {
			LABEL;
			printf("%sRMD160 (%s, %s)\n", tab, s->rmd160digest,
			       new_digest);
			tab = "\t";
		}
	}
	if (s->flags & F_SHA1) {
		char *new_digest, buf[SHA1_DIGEST_STRING_LENGTH];

		new_digest = SHA1File(p->fts_accpath, buf);
		if (!new_digest) {
			LABEL;
			printf("%sSHA1File: %s: %s\n", tab, p->fts_accpath,
			       strerror(errno));
			tab = "\t";
		} else if (strcmp(new_digest, s->sha1digest)) {
			LABEL;
			printf("%sSHA1 (%s, %s)\n", tab, s->sha1digest,
			       new_digest);
			tab = "\t";
		}
	}
	if (s->flags & F_SHA256) {
		char *new_digest, buf[SHA256_DIGEST_STRING_LENGTH];

		new_digest = SHA256File(p->fts_accpath, buf);
		if (!new_digest) {
			LABEL;
			printf("%sSHA256File: %s: %s\n", tab, p->fts_accpath,
			       strerror(errno));
			tab = "\t";
		} else if (strcmp(new_digest, s->sha256digest)) {
			LABEL;
			printf("%sSHA256 (%s, %s)\n", tab, s->sha256digest,
			       new_digest);
			tab = "\t";
		}
	}
	if (s->flags & F_SLINK && strcmp(cp = rlink(name), s->slink)) {
		LABEL;
		(void)printf("%slink ref (%s, %s)\n", tab, cp, s->slink);
	}
	if (s->flags & F_FLAGS && s->file_flags != p->fts_statp->st_flags) {
		char *db_flags = NULL;
		char *cur_flags = NULL;

		if ((db_flags = fflagstostr(s->file_flags)) == NULL ||
		    (cur_flags = fflagstostr(p->fts_statp->st_flags)) == NULL) {
			LABEL;
			(void)printf("%sflags: %s %s\n", tab, p->fts_accpath,
				     strerror(errno));
			tab = "\t";
			free(db_flags);
			free(cur_flags);
		} else {
			LABEL;
			REPLACE_COMMA(db_flags);
			REPLACE_COMMA(cur_flags);
			printf("%sflags (%s, %s", tab, (*db_flags == '\0') ?
						  "-" : db_flags,
						  (*cur_flags == '\0') ?
						  "-" : cur_flags);
				tab = "\t";
			if (uflag)
				if (chflags(p->fts_accpath, s->file_flags))
					(void)printf(", not modified: %s)\n",
						strerror(errno));
				else
					(void)printf(", modified)\n");
			else
				(void)printf(")\n");
			tab = "\t";

			free(db_flags);
			free(cur_flags);
		}
	}
	return (label);
}

char *
inotype(u_int type)
{
	switch(type & S_IFMT) {
	case S_IFBLK:
		return ("block");
	case S_IFCHR:
		return ("char");
	case S_IFDIR:
		return ("dir");
	case S_IFIFO:
		return ("fifo");
	case S_IFREG:
		return ("file");
	case S_IFLNK:
		return ("link");
	case S_IFSOCK:
		return ("socket");
	default:
		return ("unknown");
	}
	/* NOTREACHED */
}

static char *
ftype(u_int type)
{
	switch(type) {
	case F_BLOCK:
		return ("block");
	case F_CHAR:
		return ("char");
	case F_DIR:
		return ("dir");
	case F_FIFO:
		return ("fifo");
	case F_FILE:
		return ("file");
	case F_LINK:
		return ("link");
	case F_SOCK:
		return ("socket");
	default:
		return ("unknown");
	}
	/* NOTREACHED */
}

char *
rlink(char *name)
{
	static char lbuf[PATH_MAX];
	int len;

	if ((len = readlink(name, lbuf, sizeof(lbuf)-1)) == -1)
		error("%s: %s", name, strerror(errno));
	lbuf[len] = '\0';
	return (lbuf);
}
@


1.26
log
@%qd -> %lld + (long long) for off_t's.

ok guenther@@ natano@@
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.25 2015/12/21 19:37:21 mmcc Exp $	*/
d215 2
a216 2
				else  
					(void)printf(", modified)\n");  
d219 1
a219 1
			tab = "\t";   
d330 1
a330 1
						  (*cur_flags == '\0') ? 
d337 1
a337 1
				else	
d341 1
a341 1
			tab = "\t"; 
@


1.25
log
@Remove NULL-checks before free().
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.24 2015/01/16 06:40:18 deraadt Exp $	*/
d185 3
a187 2
		(void)printf("%ssize (%qd, %qd)\n",
		    tab, s->st_size, p->fts_statp->st_size);
@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.23 2012/07/08 21:19:42 naddy Exp $	*/
d321 2
a322 4
			if (db_flags != NULL)
				free(db_flags);
			if (cur_flags != NULL)
				free(cur_flags);
@


1.23
log
@Add support for the "sha256digest" keyword to create/compare
SHA-256 digests of files.  In the man page, also replace SHA-1
with SHA-256 in the examples section.

Man page formatting tweak and ok schwarze@@
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.22 2009/10/27 23:59:53 deraadt Exp $	*/
a32 1
#include <sys/param.h>
d40 1
d402 1
a402 1
	static char lbuf[MAXPATHLEN];
@


1.22
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.21 2005/08/10 00:42:09 millert Exp $	*/
d42 1
d44 1
a44 1
#include <rmd160.h>
d287 16
@


1.21
log
@Call open(2) with O_NONBLOCK and O_NOFOLLOW to make sure mtree can't
be halted by a FIFO or special device.
Use fgetln() instead of fgets() to handle arbitrarily long lines.
If a line starts with a comment char, don't check for line continuation char.
Adapted from a diff by Solar Designer.  OK deraadt@@ henning@@
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.20 2004/11/21 19:36:04 otto Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)compare.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: compare.c,v 1.20 2004/11/21 19:36:04 otto Exp $";
#endif
#endif /* not lint */
@


1.20
log
@Use the same ordering when verifying as with creating and replace
some hardcoded constants with symbolic ones. Noted by Ed Wandasiewicz
in PR 3991.

ok deraadt@@ millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.19 2004/08/01 18:32:20 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: compare.c,v 1.19 2004/08/01 18:32:20 deraadt Exp $";
d229 1
a229 1
		if ((fd = open(p->fts_accpath, O_RDONLY, 0)) < 0) {
@


1.19
log
@ansi cleanup; khalek@@linuxgamers.net
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.18 2004/05/02 17:35:08 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: compare.c,v 1.18 2004/05/02 17:35:08 millert Exp $";
d267 1
a267 1
		char *new_digest, buf[41];
d283 1
a283 1
		char *new_digest, buf[41];
@


1.18
log
@Use MD5_DIGEST_STRING_LENGTH
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.17 2003/06/02 23:36:54 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: compare.c,v 1.17 2003/06/02 23:36:54 millert Exp $";
d82 1
a82 4
compare(name, s, p)
	char *name;
	NODE *s;
	FTSENT *p;
d343 1
a343 2
inotype(type)
	u_int type;
d367 1
a367 2
ftype(type)
	u_int type;
d391 1
a391 2
rlink(name)
	char *name;
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.16 2002/09/23 04:10:14 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: compare.c,v 1.16 2002/09/23 04:10:14 millert Exp $";
d254 1
a254 1
		char *new_digest, buf[33];
@


1.16
log
@Add missing includes, breaks and semicolons to appease gcc3; David Krause
deraadt@@ OK
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.15 2002/03/14 16:44:25 mpech Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: compare.c,v 1.15 2002/03/14 16:44:25 mpech Exp $";
@


1.15
log
@kill more registers.

millert@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.14 2002/02/16 21:28:05 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: compare.c,v 1.14 2002/02/16 21:28:05 millert Exp $";
d188 1
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.13 2001/10/01 16:48:18 jakob Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: compare.c,v 1.13 2001/10/01 16:48:18 jakob Exp $";
d88 2
a89 2
	register NODE *s;
	register FTSENT *p;
d403 1
a403 1
	register int len;
@


1.13
log
@add -l flag - do loose permissions checks, in which more stringent permissions
will match less stringent ones. ok millert@@, deraadt@@.
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.12 2001/08/10 02:37:14 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: compare.c,v 1.12 2001/08/10 02:37:14 millert Exp $";
d61 1
a61 1
static char *ftype __P((u_int));
@


1.12
log
@pass -Wall
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.11 2001/08/10 02:33:46 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: compare.c,v 1.11 2001/08/10 02:33:46 millert Exp $";
d59 1
a59 1
extern int tflag, uflag;
d160 15
d187 1
@


1.11
log
@Add file flag support to mtree from henning@@crackinghacking.de
with man page update and minor tweaks by me.
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.10 1998/05/18 19:10:06 deraadt Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)compare.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: compare.c,v 1.10 1998/05/18 19:10:06 deraadt Exp $";
d218 1
a218 1
	if (s->flags & F_CKSUM)
d239 1
@


1.10
log
@readlink len-1
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.9 1997/07/18 05:49:02 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: compare.c,v 1.9 1997/07/18 05:49:02 millert Exp $";
d76 9
d290 37
@


1.9
log
@err() -> error() so we don't conflict with err(3).
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.8 1997/07/18 05:46:11 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: compare.c,v 1.8 1997/07/18 05:46:11 millert Exp $";
d342 1
a342 1
	if ((len = readlink(name, lbuf, sizeof(lbuf))) == -1)
@


1.8
log
@Add rmd160 support.  Sheesh, you'd think this was tripwire.
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.7 1997/07/12 23:05:34 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: compare.c,v 1.7 1997/07/12 23:05:34 millert Exp $";
d343 1
a343 1
		err("%s: %s", name, strerror(errno));
@


1.7
log
@Add sha1 digest support.
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.6 1997/01/03 21:40:48 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: compare.c,v 1.6 1997/01/03 21:40:48 millert Exp $";
d55 1
d242 16
@


1.6
log
@From NetBSD:
    Add a `-t' (touch) option to update time stamps.
    Only record size for regular files.
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.5 1996/12/10 08:25:57 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: compare.c,v 1.9 1995/10/22 20:12:07 pk Exp $";
d54 1
d232 1
a232 1
		new_digest = MD5File(p->fts_accpath,buf);
d245 2
d248 13
@


1.5
log
@merge freebsd mtree diffs, plus -Wall cleanup
@
text
@d1 2
a2 2
/*	$NetBSD: compare.c,v 1.9 1995/10/22 20:12:07 pk Exp $	*/
/*	$OpenBSD: compare.c,v 1.4 1996/12/08 01:13:38 niklas Exp $	*/
d41 1
a41 1
static char rcsid[] = "$NetBSD: compare.c,v 1.9 1995/10/22 20:12:07 pk Exp $";
d57 1
a57 1
extern int uflag;
a79 1
	extern int uflag;
d177 5
a181 1
	 * Catches nano-second differences, but doesn't display them.
d183 23
a205 9
	if ((s->flags & F_TIME) &&
	     ((s->st_mtimespec.tv_sec != p->fts_statp->st_mtimespec.tv_sec) ||
	     (s->st_mtimespec.tv_nsec != p->fts_statp->st_mtimespec.tv_nsec))) {
		LABEL;
		(void)printf("%smodification time (%.24s, ",
		    tab, ctime(&s->st_mtimespec.tv_sec));
		(void)printf("%.24s)\n",
		    ctime(&p->fts_statp->st_mtimespec.tv_sec));
		tab = "\t";
@


1.4
log
@64-bit clean + RCS tags
@
text
@d2 1
a2 1
/*	$OpenBSD: compare.c,v 1.3 1996/03/02 00:46:00 tholo Exp $	*/
d53 1
d70 1
a70 1
			(void)printf("%*s", INDENTNAMELEN - len, ""); \
d83 1
a83 1
	char *cp, *tab;
d180 3
a182 3
	if (s->flags & F_TIME &&
	    (s->st_mtimespec.tv_sec != p->fts_statp->st_mtimespec.tv_sec ||
	    s->st_mtimespec.tv_nsec != p->fts_statp->st_mtimespec.tv_nsec)) {
d206 1
a206 1
				(void)printf("%scksum (%u, %u)\n", 
d211 17
@


1.3
log
@timespec members are now named tv_{,u}sec
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d80 1
a80 1
	u_long len, val;
d205 1
a205 1
				(void)printf("%scksum (%lu, %lu)\n", 
@


1.2
log
@from netbsd: add () in an expression even though it is not really needed
@
text
@d2 1
d180 2
a181 2
	    (s->st_mtimespec.ts_sec != p->fts_statp->st_mtimespec.ts_sec ||
	    s->st_mtimespec.ts_nsec != p->fts_statp->st_mtimespec.ts_nsec)) {
d184 1
a184 1
		    tab, ctime(&s->st_mtimespec.ts_sec));
d186 1
a186 1
		    ctime(&p->fts_statp->st_mtimespec.ts_sec));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: compare.c,v 1.8 1995/03/07 21:12:05 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: compare.c,v 1.8 1995/03/07 21:12:05 cgd Exp $";
d179 2
a180 2
	    s->st_mtimespec.ts_sec != p->fts_statp->st_mtimespec.ts_sec ||
	    s->st_mtimespec.ts_nsec != p->fts_statp->st_mtimespec.ts_nsec) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
