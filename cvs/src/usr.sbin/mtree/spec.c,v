head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.6
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.26.0.18
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.14
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.16
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.8
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.12
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.10
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.6
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.4
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.12
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.10
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.8
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.6
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.12
	OPENBSD_2_8:1.10.0.10
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.8
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2016.08.16.16.41.46;	author krw;	state Exp;
branches;
next	1.27;
commitid	ScqME4mWPdd178mi;

1.27
date	2016.08.14.18.34.48;	author guenther;	state Exp;
branches;
next	1.26;
commitid	PKvTittpF6Ut9SpV;

1.26
date	2012.07.08.21.19.42;	author naddy;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.13.20.47.29;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.10.00.42.09;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.01.18.32.20;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.09.16.22.03;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.01.18.25.48;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.02.17.55.53;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.19.10.43.55;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.17.01.16;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.09.18.49.09;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.10.02.37.14;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.10.02.33.46;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.09.24.02.42.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.18.05.49.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.18.05.46.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.12.23.05.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.07.14.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.03.21.40.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.12.20.18.13.44;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.10.08.26.10;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.02.00.46.04;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.49;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Nuke a bunch of whitespace nits seen while '%q' hunting.
@
text
@/*	$NetBSD: spec.c,v 1.6 1995/03/07 21:12:12 cgd Exp $	*/
/*	$OpenBSD: spec.c,v 1.27 2016/08/14 18:34:48 guenther Exp $	*/

/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <pwd.h>
#include <grp.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <ctype.h>
#include <vis.h>
#include "mtree.h"
#include "extern.h"

int lineno;				/* Current spec line number. */

static void	 set(char *, NODE *);
static void	 unset(char *, NODE *);

NODE *
spec(void)
{
	NODE *centry, *last;
	char *p;
	NODE ginfo, *root;
	int c_cur, c_next;
	char *buf, *tbuf = NULL;
	size_t len;

	last = root = NULL;
	bzero(&ginfo, sizeof(ginfo));
	centry = &ginfo;
	c_cur = c_next = 0;
	for (lineno = 1; (buf = fgetln(stdin, &len));
	    ++lineno, c_cur = c_next, c_next = 0) {
		/* Null-terminate the line. */
		if (buf[len - 1] == '\n') {
			buf[--len] = '\0';
		} else {
			/* EOF with no newline. */
			tbuf = malloc(len + 1);
			memcpy(tbuf, buf, len);
			tbuf[len] = '\0';
			buf = tbuf;
		}

		/* Skip leading whitespace. */
		for (p = buf; isspace((unsigned char)*p); p++)
			;

		/* If nothing but whitespace or comment char, continue. */
		if (*p == '\0' || *p == '#')
			continue;

		/* See if next line is continuation line. */
		if (buf[len - 1] == '\\') {
			c_next = 1;
			if (--len == 0)
				continue;
			buf[len] = '\0';
		}

#ifdef DEBUG
		(void)fprintf(stderr, "line %d: {%s}\n", lineno, p);
#endif
		if (c_cur) {
			set(p, centry);
			continue;
		}

		/* Grab file name, "$", "set", or "unset". */
		if ((p = strtok(p, "\n\t ")) == NULL)
			error("missing field");

		if (p[0] == '/')
			switch(p[1]) {
			case 's':
				if (strcmp(p + 1, "set"))
					break;
				set(NULL, &ginfo);
				continue;
			case 'u':
				if (strcmp(p + 1, "unset"))
					break;
				unset(NULL, &ginfo);
				continue;
			}

		if (strchr(p, '/'))
			error("slash character in file name");

		if (!strcmp(p, "..")) {
			/* Don't go up, if haven't gone down. */
			if (!root)
				goto noparent;
			if (last->type != F_DIR || last->flags & F_DONE) {
				if (last == root)
					goto noparent;
				last = last->parent;
			}
			last->flags |= F_DONE;
			continue;

noparent:		error("no parent node");
		}

		len = strlen(p) + 1;	/* NUL in struct _node */
		if ((centry = calloc(1, sizeof(NODE) + len - 1)) == NULL)
			error("%s", strerror(errno));
		*centry = ginfo;
#define	MAGIC	"?*["
		if (strpbrk(p, MAGIC))
			centry->flags |= F_MAGIC;
		if (strunvis(centry->name, p) == -1) {
			fprintf(stderr,
			    "mtree: filename (%s) encoded incorrectly\n", p);
			strlcpy(centry->name, p, len);
		}
		set(NULL, centry);

		if (!root) {
			last = root = centry;
			root->parent = root;
		} else if (last->type == F_DIR && !(last->flags & F_DONE)) {
			centry->parent = last;
			last = last->child = centry;
		} else {
			centry->parent = last->parent;
			centry->prev = last;
			last = last->next = centry;
		}
	}
	free(tbuf);
	return (root);
}

static void
set(char *t, NODE *ip)
{
	int type;
	char *kw, *val = NULL;
	struct group *gr;
	struct passwd *pw;
	void *m;
	int value;
	u_int32_t fset, fclr;
	char *ep;
	size_t len;

	for (; (kw = strtok(t, "= \t\n")); t = NULL) {
		ip->flags |= type = parsekey(kw, &value);
		if (value && (val = strtok(NULL, " \t\n")) == NULL)
			error("missing value");
		switch(type) {
		case F_CKSUM:
			ip->cksum = strtoul(val, &ep, 10);
			if (*ep)
				error("invalid checksum %s", val);
			break;
		case F_MD5:
			ip->md5digest = strdup(val);
			if (!ip->md5digest)
				error("%s", strerror(errno));
			break;
		case F_FLAGS:
			if (!strcmp(val, "none")) {
				ip->file_flags = 0;
				break;
			}
			if (strtofflags(&val, &fset, &fclr))
				error("%s", strerror(errno));
			ip->file_flags = fset;
			break;
		case F_GID:
			ip->st_gid = strtoul(val, &ep, 10);
			if (*ep)
				error("invalid gid %s", val);
			break;
		case F_GNAME:
			if ((gr = getgrnam(val)) == NULL)
			    error("unknown group %s", val);
			ip->st_gid = gr->gr_gid;
			break;
		case F_IGN:
			/* just set flag bit */
			break;
		case F_MODE:
			if ((m = setmode(val)) == NULL)
				error("invalid file mode %s", val);
			ip->st_mode = getmode(m, 0);
			free(m);
			break;
		case F_NLINK:
			ip->st_nlink = strtoul(val, &ep, 10);
			if (*ep)
				error("invalid link count %s", val);
			break;
		case F_RMD160:
			ip->rmd160digest = strdup(val);
			if (!ip->rmd160digest)
				error("%s", strerror(errno));
			break;
		case F_SHA1:
			ip->sha1digest = strdup(val);
			if (!ip->sha1digest)
				error("%s", strerror(errno));
			break;
		case F_SHA256:
			ip->sha256digest = strdup(val);
			if (!ip->sha256digest)
				error("%s", strerror(errno));
			break;
		case F_SIZE:
			ip->st_size = strtoll(val, &ep, 10);
			if (*ep)
				error("invalid size %s", val);
			break;
		case F_SLINK:
			len = strlen(val) + 1;
			if ((ip->slink = malloc(len)) == NULL)
				error("%s", strerror(errno));
			if (strunvis(ip->slink, val) == -1) {
				fprintf(stderr,
				    "mtree: filename (%s) encoded incorrectly\n", val);
				strlcpy(ip->slink, val, len);
			}
			break;
		case F_TIME:
			ip->st_mtimespec.tv_sec = strtoul(val, &ep, 10);
			if (*ep != '.')
				error("invalid time %s", val);
			val = ep + 1;
			ip->st_mtimespec.tv_nsec = strtoul(val, &ep, 10);
			if (*ep)
				error("invalid time %s", val);
			break;
		case F_TYPE:
			switch(*val) {
			case 'b':
				if (!strcmp(val, "block"))
					ip->type = F_BLOCK;
				break;
			case 'c':
				if (!strcmp(val, "char"))
					ip->type = F_CHAR;
				break;
			case 'd':
				if (!strcmp(val, "dir"))
					ip->type = F_DIR;
				break;
			case 'f':
				if (!strcmp(val, "file"))
					ip->type = F_FILE;
				if (!strcmp(val, "fifo"))
					ip->type = F_FIFO;
				break;
			case 'l':
				if (!strcmp(val, "link"))
					ip->type = F_LINK;
				break;
			case 's':
				if (!strcmp(val, "socket"))
					ip->type = F_SOCK;
				break;
			default:
				error("unknown file type %s", val);
			}
			break;
		case F_UID:
			ip->st_uid = strtoul(val, &ep, 10);
			if (*ep)
				error("invalid uid %s", val);
			break;
		case F_UNAME:
			if ((pw = getpwnam(val)) == NULL)
			    error("unknown user %s", val);
			ip->st_uid = pw->pw_uid;
			break;
		}
	}
}

static void
unset(char *t, NODE *ip)
{
	char *p;

	while ((p = strtok(t, "\n\t ")))
		ip->flags &= ~parsekey(p, NULL);
}
@


1.27
log
@Convert remaining calls to strtoq/strtouq in base with strtoll/strtoull.
Fix a type mismatch in ftp's "page" command and could make transfers restart
at the wrong position.

ok and a ull->ll tweak from natano@@, ok tedu@@
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.26 2012/07/08 21:19:42 naddy Exp $	*/
d100 1
a100 1
			
d203 1
a203 1
			break; 
@


1.26
log
@Add support for the "sha256digest" keyword to create/compare
SHA-256 digests of files.  In the man page, also replace SHA-1
with SHA-256 in the examples section.

Man page formatting tweak and ok schwarze@@
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.25 2009/10/27 23:59:53 deraadt Exp $	*/
d244 1
a244 1
			ip->st_size = strtouq(val, &ep, 10);
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.24 2008/06/13 20:47:29 espie Exp $	*/
d236 5
@


1.24
log
@fix two smalls bugs wrt contination lines.
- continuation line at file start would segfault: make it change ginfo
as it should instead.
- empty continuation lines should be valid.

okay millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.23 2005/08/10 00:42:09 millert Exp $	*/
a31 8

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)spec.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: spec.c,v 1.23 2005/08/10 00:42:09 millert Exp $";
#endif
#endif /* not lint */
@


1.23
log
@Call open(2) with O_NONBLOCK and O_NOFOLLOW to make sure mtree can't
be halted by a FIFO or special device.
Use fgetln() instead of fgets() to handle arbitrarily long lines.
If a line starts with a comment char, don't check for line continuation char.
Adapted from a diff by Solar Designer.  OK deraadt@@ henning@@
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.22 2004/08/01 18:32:20 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.22 2004/08/01 18:32:20 deraadt Exp $";
d68 1
a68 1
	centry = last = root = NULL;
d70 1
d95 1
a98 1
			c_next = 1;
@


1.22
log
@ansi cleanup; khalek@@linuxgamers.net
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.21 2004/07/09 16:22:03 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.21 2004/07/09 16:22:03 deraadt Exp $";
d65 1
a65 1
	char buf[2048];
d71 1
a71 1
	for (lineno = 1; fgets(buf, sizeof(buf), stdin);
d73 9
a81 12
		/* Skip empty lines. */
		if (buf[0] == '\n')
			continue;

		/* Find end of line. */
		if ((p = strchr(buf, '\n')) == NULL)
			error("line %d too long", lineno);

		/* See if next line is continuation line. */
		if (p[-1] == '\\') {
			--p;
			c_next = 1;
a83 3
		/* Null-terminate the line. */
		*p = '\0';

d85 2
a86 1
		for (p = buf; *p && isspace(*p); ++p);
d89 1
a89 1
		if (!*p || *p == '#')
d92 8
d170 1
@


1.21
log
@ansi
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.20 2004/07/01 18:25:48 otto Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.20 2004/07/01 18:25:48 otto Exp $";
d171 1
a171 3
set(t, ip)
	char *t;
	NODE *ip;
d312 1
a312 3
unset(t, ip)
	char *t;
	NODE *ip;
@


1.20
log
@setmode(3) returns void *, not mode_t *.  ok millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.19 2004/05/02 17:55:53 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.19 2004/05/02 17:55:53 millert Exp $";
d59 1
a59 1
spec()
@


1.19
log
@Mtree needs the old crc routines; remove some extraneous includes while
I am at it.
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.18 2003/06/02 23:36:54 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.18 2003/06/02 23:36:54 millert Exp $";
d179 1
a179 1
	mode_t *m;
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.17 2003/04/19 10:43:55 henning Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.17 2003/04/19 10:43:55 henning Exp $";
a42 1
#include <fts.h>
@


1.17
log
@string stuff, ok krw@@
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.16 2002/03/14 17:01:16 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.16 2002/03/14 17:01:16 millert Exp $";
@


1.16
log
@We also need to vis-encode the path contained in a symbolic link.
Based on a patch from Nicolas Rachinsky (FreeBSD PR 35454).
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.15 2002/03/14 16:44:25 mpech Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.15 2002/03/14 16:44:25 mpech Exp $";
d71 1
d146 2
a147 1
		if ((centry = calloc(1, sizeof(NODE) + strlen(p))) == NULL)
d156 1
a156 1
			strcpy(centry->name, p);
d188 1
d254 2
a255 1
			if ((ip->slink = malloc(strlen(val) + 1)) == NULL)
d260 1
a260 1
				strcpy(ip->slink, val);
@


1.15
log
@kill more registers.

millert@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.14 2002/03/09 18:49:09 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.14 2002/03/09 18:49:09 millert Exp $";
d251 1
a251 1
			if ((ip->slink = strdup(val)) == NULL)
d253 5
@


1.14
log
@Escape whitespace and encode special chars with vis(3); from FreeBSD
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.13 2002/02/16 21:28:05 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.13 2002/02/16 21:28:05 millert Exp $";
d66 2
a67 2
	register NODE *centry, *last;
	register char *p;
d176 1
a176 1
	register NODE *ip;
d178 1
a178 1
	register int type;
d312 1
a312 1
	register NODE *ip;
d314 1
a314 1
	register char *p;
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.12 2001/08/10 02:37:14 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.12 2001/08/10 02:37:14 millert Exp $";
d54 1
a147 1
		(void)strcpy(centry->name, p);
d151 5
@


1.12
log
@pass -Wall
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.11 2001/08/10 02:33:46 millert Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: spec.c,v 1.11 2001/08/10 02:33:46 millert Exp $";
d59 2
a60 2
static void	 set __P((char *, NODE *));
static void	 unset __P((char *, NODE *));
@


1.11
log
@Add file flag support to mtree from henning@@crackinghacking.de
with man page update and minor tweaks by me.
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.10 1998/09/24 02:42:38 millert Exp $	*/
d39 1
a39 1
static char sccsid[] = "@@(#)spec.c	8.1 (Berkeley) 6/6/93";
d41 1
a41 1
static char rcsid[] = "$OpenBSD: spec.c,v 1.10 1998/09/24 02:42:38 millert Exp $";
@


1.10
log
@The return value of setmode(3) is a pointer to malloc()'ed area and
must be freed to avoid memory leaks if called repeatedly.
From itohy@@netbsd.org
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.9 1997/07/18 05:49:04 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: spec.c,v 1.9 1997/07/18 05:49:04 millert Exp $";
d174 1
a174 1
	register char *kw, *val = NULL;
d179 1
d197 9
@


1.9
log
@err() -> error() so we don't conflict with err(3).
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.8 1997/07/18 05:46:14 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: spec.c,v 1.8 1997/07/18 05:46:14 millert Exp $";
d213 1
@


1.8
log
@Add rmd160 support.  Sheesh, you'd think this was tripwire.
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.7 1997/07/12 23:05:36 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: spec.c,v 1.7 1997/07/12 23:05:36 millert Exp $";
d82 1
a82 1
			err("line %d too long", lineno);
d110 1
a110 1
			err("missing field");
d127 1
a127 1
			err("slash character in file name");
d141 1
a141 1
noparent:		err("no parent node");
d145 1
a145 1
			err("%s", strerror(errno));
d184 1
a184 1
			err("missing value");
d189 1
a189 1
				err("invalid checksum %s", val);
d194 1
a194 1
				err("%s", strerror(errno));
d199 1
a199 1
				err("invalid gid %s", val);
d203 1
a203 1
			    err("unknown group %s", val);
d211 1
a211 1
				err("invalid file mode %s", val);
d217 1
a217 1
				err("invalid link count %s", val);
d222 1
a222 1
				err("%s", strerror(errno));
d227 1
a227 1
				err("%s", strerror(errno));
d232 1
a232 1
				err("invalid size %s", val);
d236 1
a236 1
				err("%s", strerror(errno));
d241 1
a241 1
				err("invalid time %s", val);
d245 1
a245 1
				err("invalid time %s", val);
d276 1
a276 1
				err("unknown file type %s", val);
d282 1
a282 1
				err("invalid uid %s", val);
d286 1
a286 1
			    err("unknown user %s", val);
@


1.7
log
@Add sha1 digest support.
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.6 1997/01/17 07:14:10 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: spec.c,v 1.6 1997/01/17 07:14:10 millert Exp $";
d218 5
@


1.6
log
@r?index -> strr?chr
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.5 1997/01/03 21:40:51 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: spec.c,v 1.5 1997/01/03 21:40:51 millert Exp $";
d193 1
a193 1
			if (!ip->md5digest) {
a194 1
			}
d218 5
@


1.5
log
@From NetBSD:
    Add a `-t' (touch) option to update time stamps.
    Only record size for regular files.
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.4 1996/12/20 18:13:44 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: spec.c,v 1.6 1995/03/07 21:12:12 cgd Exp $";
d81 1
a81 1
		if ((p = index(buf, '\n')) == NULL)
d126 1
a126 1
		if (index(p, '/'))
@


1.4
log
@Add back "optional" keyword that got nuked in merge of FreeBSD mods.
@
text
@d2 1
a2 1
/*	$OpenBSD: spec.c,v 1.3 1996/12/10 08:26:10 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$NetBSD: spec.c,v 1.6 1995/03/07 21:12:12 cgd Exp $";
@


1.3
log
@merge freebsd mtree diffs, plus -Wall cleanup
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d221 1
a221 1
			ip->st_size = strtoq(val, &ep, 10);
@


1.2
log
@timespec members are now named tv_{,u}sec
@
text
@d71 1
a71 1
	root = NULL;
d174 1
a174 1
	register char *kw, *val;
d181 1
a181 1
	for (; kw = strtok(t, "= \t\n"); t = NULL) {
d191 6
d221 1
a221 1
			ip->st_size = strtouq(val, &ep, 10);
d291 1
a291 1
	while (p = strtok(t, "\n\t "))
@


1.1
log
@Initial revision
@
text
@d2 1
d224 1
a224 1
			ip->st_mtimespec.ts_sec = strtoul(val, &ep, 10);
d228 1
a228 1
			ip->st_mtimespec.ts_nsec = strtoul(val, &ep, 10);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
