head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.10
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.4
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.20.0.16
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.14
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.12
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.12
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.10
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.8
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	Uu5nFG3wCl0LACBb;

1.24
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.23;
commitid	yLXrOcgrag4eS8u4;

1.23
date	2014.06.20.04.04.52;	author lteo;	state Exp;
branches;
next	1.22;
commitid	2daJ0iB9vSWHdMTb;

1.22
date	2014.01.11.04.40.45;	author lteo;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.11.04.35.52;	author lteo;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.25.10.53.35;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.17.05.47.17;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.10.19.54.18;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.08.17.35.57;	author cedric;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.07.18.48.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.02.12.06.57;	author jakob;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.02.12.05.13;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.02.12.01.35;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.10.22.17.08;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.03.14.31.57;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	98.07.13.22.13.47;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.20.12.24;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.37;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.23;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.25;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: print-icmp.c,v 1.24 2014/08/14 12:44:44 mpi Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/time.h>
#include <sys/socket.h>

struct mbuf;
struct rtentry;
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>

#include <stdio.h>
#include <string.h>
#include <limits.h>

#include "interface.h"
#include "addrtoname.h"
#include "extract.h"			/* must come after interface.h */

/* rfc1700 */
#ifndef ICMP_UNREACH_NET_UNKNOWN
#define ICMP_UNREACH_NET_UNKNOWN	6	/* destination net unknown */
#endif
#ifndef ICMP_UNREACH_HOST_UNKNOWN
#define ICMP_UNREACH_HOST_UNKNOWN	7	/* destination host unknown */
#endif
#ifndef ICMP_UNREACH_ISOLATED
#define ICMP_UNREACH_ISOLATED		8	/* source host isolated */
#endif
#ifndef ICMP_UNREACH_NET_PROHIB
#define ICMP_UNREACH_NET_PROHIB		9	/* admin prohibited net */
#endif
#ifndef ICMP_UNREACH_HOST_PROHIB
#define ICMP_UNREACH_HOST_PROHIB	10	/* admin prohibited host */
#endif
#ifndef ICMP_UNREACH_TOSNET
#define ICMP_UNREACH_TOSNET		11	/* tos prohibited net */
#endif
#ifndef ICMP_UNREACH_TOSHOST
#define ICMP_UNREACH_TOSHOST		12	/* tos prohibited host */
#endif

/* rfc1716 */
#ifndef ICMP_UNREACH_FILTER_PROHIB
#define ICMP_UNREACH_FILTER_PROHIB	13	/* admin prohibited filter */
#endif
#ifndef ICMP_UNREACH_HOST_PRECEDENCE
#define ICMP_UNREACH_HOST_PRECEDENCE	14	/* host precedence violation */
#endif
#ifndef ICMP_UNREACH_PRECEDENCE_CUTOFF
#define ICMP_UNREACH_PRECEDENCE_CUTOFF	15	/* precedence cutoff */
#endif

/* rfc1256 */
#ifndef ICMP_ROUTERADVERT
#define ICMP_ROUTERADVERT		9	/* router advertisement */
#endif
#ifndef ICMP_ROUTERSOLICIT
#define ICMP_ROUTERSOLICIT		10	/* router solicitation */
#endif

#define ICMP_INFOTYPE(type) \
    ((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || \
    (type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || \
    (type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || \
    (type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || \
    (type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)

/* Most of the icmp types */
static struct tok icmp2str[] = {
	{ ICMP_ECHOREPLY,		"echo reply" },
	{ ICMP_SOURCEQUENCH,		"source quench" },
	{ ICMP_ECHO,			"echo request" },
	{ ICMP_ROUTERSOLICIT,		"router solicitation" },
	{ ICMP_TSTAMP,			"time stamp request" },
	{ ICMP_TSTAMPREPLY,		"time stamp reply" },
	{ ICMP_IREQ,			"information request" },
	{ ICMP_IREQREPLY,		"information reply" },
	{ ICMP_MASKREQ,			"address mask request" },
	{ 0,				NULL }
};

/* Formats for most of the ICMP_UNREACH codes */
static struct tok unreach2str[] = {
	{ ICMP_UNREACH_NET,		"net %s unreachable" },
	{ ICMP_UNREACH_HOST,		"host %s unreachable" },
	{ ICMP_UNREACH_SRCFAIL,
	    "%s unreachable - source route failed" },
	{ ICMP_UNREACH_NET_UNKNOWN,	"net %s unreachable - unknown" },
	{ ICMP_UNREACH_HOST_UNKNOWN,	"host %s unreachable - unknown" },
	{ ICMP_UNREACH_ISOLATED,
	    "%s unreachable - source host isolated" },
	{ ICMP_UNREACH_NET_PROHIB,
	    "net %s unreachable - admin prohibited" },
	{ ICMP_UNREACH_HOST_PROHIB,
	    "host %s unreachable - admin prohibited" },
	{ ICMP_UNREACH_TOSNET,
	    "net %s unreachable - tos prohibited" },
	{ ICMP_UNREACH_TOSHOST,
	    "host %s unreachable - tos prohibited" },
	{ ICMP_UNREACH_FILTER_PROHIB,
	    "host %s unreachable - admin prohibited filter" },
	{ ICMP_UNREACH_HOST_PRECEDENCE,
	    "host %s unreachable - host precedence violation" },
	{ ICMP_UNREACH_PRECEDENCE_CUTOFF,
	    "host %s unreachable - precedence cutoff" },
	{ 0,				NULL }
};

/* Formats for the ICMP_REDIRECT codes */
static struct tok type2str[] = {
	{ ICMP_REDIRECT_NET,		"redirect %s to net %s" },
	{ ICMP_REDIRECT_HOST,		"redirect %s to host %s" },
	{ ICMP_REDIRECT_TOSNET,		"redirect-tos %s to net %s" },
	{ ICMP_REDIRECT_TOSHOST,	"redirect-tos %s to net %s" },
	{ 0,				NULL }
};

/* rfc1191 */
struct mtu_discovery {
	short unused;
	short nexthopmtu;
};

/* rfc1256 */
struct ih_rdiscovery {
	u_char ird_addrnum;
	u_char ird_addrsiz;
	u_short ird_lifetime;
};

struct id_rdiscovery {
	u_int32_t ird_addr;
	u_int32_t ird_pref;
};

void
icmp_print(const u_char *bp, u_int length, const u_char *bp2)
{
	const struct icmp *dp;
	const struct ip *ip;
	const char *str, *fmt;
	const struct ip *oip;
	const struct udphdr *ouh;
	u_int hlen, dport, mtu;
	char buf[HOST_NAME_MAX+1+256];
	char buf2[HOST_NAME_MAX+1+256];

	dp = (struct icmp *)bp;
	ip = (struct ip *)bp2;
	str = buf;

        (void)printf("%s > %s: ",
		ipaddr_string(&ip->ip_src),
		ipaddr_string(&ip->ip_dst));

	TCHECK(dp->icmp_code);
	if (qflag) 
		(void) snprintf(buf, sizeof buf, "%u %u", dp->icmp_type,
		    dp->icmp_code);
	else switch (dp->icmp_type) {

	case ICMP_ECHOREPLY:
	case ICMP_ECHO:
		if (vflag) {
			TCHECK(dp->icmp_seq);
			(void)snprintf(buf, sizeof buf,
				       "echo %s (id:%04x seq:%u)",
				       (dp->icmp_type == ICMP_ECHO)?
				       "request": "reply",
				       ntohs(dp->icmp_id),
				       ntohs(dp->icmp_seq));
		} else
			str = tok2str(icmp2str, "type-#%u", dp->icmp_type);
		break;

	case ICMP_UNREACH:
		TCHECK(dp->icmp_ip.ip_dst);
		switch (dp->icmp_code) {

		case ICMP_UNREACH_PROTOCOL:
			TCHECK(dp->icmp_ip.ip_p);
			(void)snprintf(buf, sizeof buf,
				       "%s protocol %u unreachable",
				       ipaddr_string(&dp->icmp_ip.ip_dst),
				       dp->icmp_ip.ip_p);
			break;

		case ICMP_UNREACH_PORT:
			TCHECK(dp->icmp_ip.ip_p);
			oip = &dp->icmp_ip;
			hlen = oip->ip_hl * 4;
			ouh = (struct udphdr *)(((u_char *)oip) + hlen);
			TCHECK(ouh->uh_dport);
			dport = ntohs(ouh->uh_dport);
			switch (oip->ip_p) {

			case IPPROTO_TCP:
				(void)snprintf(buf, sizeof buf,
					"%s tcp port %s unreachable",
					ipaddr_string(&oip->ip_dst),
					tcpport_string(dport));
				break;

			case IPPROTO_UDP:
				(void)snprintf(buf, sizeof buf,
					"%s udp port %s unreachable",
					ipaddr_string(&oip->ip_dst),
					udpport_string(dport));
				break;

			default:
				(void)snprintf(buf, sizeof buf,
					"%s protocol %u port %u unreachable",
					ipaddr_string(&oip->ip_dst),
					oip->ip_p, dport);
				break;
			}
			break;

		case ICMP_UNREACH_NEEDFRAG:
			{
			const struct mtu_discovery *mp;

			mp = (struct mtu_discovery *)&dp->icmp_void;
                        mtu = EXTRACT_16BITS(&mp->nexthopmtu);
                        if (mtu)
			    (void)snprintf(buf, sizeof buf,
				"%s unreachable - need to frag (mtu %u)",
				ipaddr_string(&dp->icmp_ip.ip_dst), mtu);
                        else
			    (void)snprintf(buf, sizeof buf,
				"%s unreachable - need to frag",
				ipaddr_string(&dp->icmp_ip.ip_dst));
			}
			break;

		default:
			fmt = tok2str(unreach2str, "#%u %%s unreachable",
			    dp->icmp_code);
			(void)snprintf(buf, sizeof buf, fmt,
			    ipaddr_string(&dp->icmp_ip.ip_dst));
			break;
		}
		break;

	case ICMP_REDIRECT:
		TCHECK(dp->icmp_ip.ip_dst);
		fmt = tok2str(type2str, "redirect-#%u %%s to net %%s",
		    dp->icmp_code);
		(void)snprintf(buf, sizeof buf, fmt,
		    ipaddr_string(&dp->icmp_ip.ip_dst),
		    ipaddr_string(&dp->icmp_gwaddr));
		break;

	case ICMP_ROUTERADVERT:
		{
		const struct ih_rdiscovery *ihp;
		const struct id_rdiscovery *idp;
		u_int lifetime, num, size;

		(void)strlcpy(buf, "router advertisement", sizeof(buf));

		ihp = (struct ih_rdiscovery *)&dp->icmp_void;
		TCHECK(*ihp);
		(void)strlcat(buf, " lifetime ", sizeof(buf));
		lifetime = EXTRACT_16BITS(&ihp->ird_lifetime);
		if (lifetime < 60)
			(void)snprintf(buf2, sizeof(buf2), "%u", lifetime);
		else if (lifetime < 60 * 60)
			(void)snprintf(buf2, sizeof(buf2), "%u:%02u",
			    lifetime / 60, lifetime % 60);
		else
			(void)snprintf(buf2, sizeof(buf2), "%u:%02u:%02u",
			    lifetime / 3600, (lifetime % 3600) / 60,
			    lifetime % 60);
		strlcat(buf, buf2, sizeof(buf));

		num = ihp->ird_addrnum;
		(void)snprintf(buf2, sizeof(buf2), " %u:", num);
		strlcat(buf, buf2, sizeof(buf));

		size = ihp->ird_addrsiz;
		if (size != 2) {
			(void)snprintf(buf2, sizeof(buf2), " [size %u]", size);
			strlcat(buf, buf2, sizeof(buf));
			break;
		}
		idp = (struct id_rdiscovery *)&dp->icmp_data;
		while (num-- > 0) {
			TCHECK(*idp);
			(void)snprintf(buf2, sizeof(buf2), " {%s %u}",
			    ipaddr_string(&idp->ird_addr),
			    EXTRACT_32BITS(&idp->ird_pref));
			strlcat(buf, buf2, sizeof(buf));
		}
		}
		break;

	case ICMP_TIMXCEED:
		TCHECK(dp->icmp_ip.ip_dst);
		switch (dp->icmp_code) {

		case ICMP_TIMXCEED_INTRANS:
			str = "time exceeded in-transit";
			break;

		case ICMP_TIMXCEED_REASS:
			str = "ip reassembly time exceeded";
			break;

		default:
			(void)snprintf(buf, sizeof buf,
				"time exceeded-#%u", dp->icmp_code);
			break;
		}
		break;

	case ICMP_PARAMPROB:
		switch (dp->icmp_code) {
		case ICMP_PARAMPROB_OPTABSENT:
			str = "requested option absent";
			break;
		case ICMP_PARAMPROB_LENGTH:
			snprintf(buf, sizeof buf, "bad length %u", dp->icmp_pptr);
			break;
		default:
			TCHECK(dp->icmp_pptr);
			(void)snprintf(buf, sizeof buf,
				"parameter problem - octet %u",
				dp->icmp_pptr);
			break;
		}
		break;

	case ICMP_MASKREPLY:
		TCHECK(dp->icmp_mask);
		(void)snprintf(buf, sizeof buf, "address mask is 0x%08x",
		    (u_int32_t)ntohl(dp->icmp_mask));
		break;

	default:
		str = tok2str(icmp2str, "type-#%u", dp->icmp_type);
		break;
	}
	(void)printf("icmp: %s", str);
	if (vflag) {
		if (TTEST2(dp->icmp_type, length)) {
			u_int16_t sum, icmp_sum;
			sum = in_cksum((const u_short *)dp, length, 0);
			if (sum != 0) {
				icmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);
				(void)printf(" [bad icmp cksum %x! -> %x]", icmp_sum,
				    in_cksum_shouldbe(icmp_sum, sum));
			}
			else
				(void)printf(" [icmp cksum ok]");
		}
	}
	if (vflag > 1 && !ICMP_INFOTYPE(dp->icmp_type) &&
	    TTEST(dp->icmp_ip)) {
		(void)printf(" for ");
		oip = &dp->icmp_ip;
		ip_print((u_char *)oip, ntohs(oip->ip_len));
	}
	return;
trunc:
	fputs("[|icmp]", stdout);
}
@


1.24
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.23 2014/06/20 04:04:52 lteo Exp $	*/
a23 1
#include <sys/param.h>
d42 1
d174 2
a175 2
	char buf[MAXHOSTNAMELEN+256];
	char buf2[MAXHOSTNAMELEN+256];
@


1.23
log
@Instead of showing the difference between a bad checksum and a good
checksum, make tcpdump (with the -v flag) show the actual bad checksum
within the IP/protocol header itself and what the good checksum should
be, e.g. "[bad tcp cksum abcd! -> d1e6]"

This change applies to IP, TCP (over IPv4 and IPv6), UDP (over IPv4 and
IPv6), ICMP, and ICMPv6.  This commit also fixes several inconsistencies
in the way bad checksums were displayed for these protocols.

Tested on amd64, i386, and macppc.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.22 2014/01/11 04:40:45 lteo Exp $	*/
a33 1
#include <netinet/in_systm.h>
a39 1
#include <netinet/tcpip.h>
@


1.22
log
@Let tcpdump detect bad ICMP checksums with the -v flag.

Tested on amd64, i386, loongson, and macppc.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.21 2014/01/11 04:35:52 lteo Exp $	*/
a377 1
		u_int16_t sum;
d379 1
d381 5
a385 2
			if (sum != 0)
				(void)printf(" [bad icmp cksum %x!]", sum);
d389 1
a389 1
    }
@


1.21
log
@Make icmp_print() accept the length variable, which is the length of the
packet without the IP header.  This is needed by the next commit that
will allow tcpdump to detect bad ICMP checksums.

Related functions like {tcp,udp,icmp6}_print() already accept this
length variable, so this change makes icmp_print() consistent with
them as well.

This commit makes no functional change to tcpdump itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.20 2009/10/27 23:59:55 deraadt Exp $	*/
d376 11
a386 1
        (void)printf("icmp: %s", str);
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.19 2009/05/25 10:53:35 sthen Exp $	*/
d168 1
a168 1
icmp_print(const u_char *bp, const u_char *bp2)
@


1.19
log
@add a missing check for truncated dport in the returned UDP header for
ICMP_UNREACH_PORT. from Peter J. Philipp, ok jsing@@. Closes system/6149.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.18 2007/10/07 16:41:05 deraadt Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id: print-icmp.c,v 1.18 2007/10/07 16:41:05 deraadt Exp $ (LBL)";
#endif
@


1.18
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.17 2004/10/17 05:47:17 otto Exp $	*/
d26 1
a26 1
    "@@(#) $Id$ (LBL)";
d229 1
@


1.17
log
@implement -q for icmp, deregister, print usigned values using an unsigned
format. ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.16 2004/08/10 19:54:18 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.16 2004/08/10 19:54:18 markus Exp $ (LBL)";
@


1.16
log
@print the original ip packet on -vv; based on tcpdump.org; ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.15 2003/09/08 17:35:57 cedric Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.15 2003/09/08 17:35:57 cedric Exp $ (LBL)";
d173 1
a173 1
icmp_print(register const u_char *bp, register const u_char *bp2)
d175 6
a180 6
	register const struct icmp *dp;
	register const struct ip *ip;
	register const char *str, *fmt;
	register const struct ip *oip;
	register const struct udphdr *ouh;
	register u_int hlen, dport, mtu;
d193 4
a196 1
	switch (dp->icmp_type) {
d203 1
a203 1
				       "echo %s (id:%04x seq:%d)",
d209 1
a209 1
			str = tok2str(icmp2str, "type-#%d", dp->icmp_type);
d219 1
a219 1
				       "%s protocol %d unreachable",
d248 1
a248 1
					"%s protocol %d port %d unreachable",
d257 1
a257 1
			register const struct mtu_discovery *mp;
d263 1
a263 1
				"%s unreachable - need to frag (mtu %d)",
d273 1
a273 1
			fmt = tok2str(unreach2str, "#%d %%s unreachable",
d283 1
a283 1
		fmt = tok2str(type2str, "redirect-#%d %%s to net %%s",
d292 2
a293 2
		register const struct ih_rdiscovery *ihp;
		register const struct id_rdiscovery *idp;
d314 1
a314 1
		(void)snprintf(buf2, sizeof(buf2), " %d:", num);
d319 1
a319 1
			(void)snprintf(buf2, sizeof(buf2), " [size %d]", size);
d348 1
a348 1
				"time exceeded-#%d", dp->icmp_code);
d359 1
a359 1
			snprintf(buf, sizeof buf, "bad length %d", dp->icmp_pptr);
d364 1
a364 1
				"parameter problem - octet %d",
d377 1
a377 1
		str = tok2str(icmp2str, "type-#%d", dp->icmp_type);
@


1.15
log
@Fix 'tcpdump -v icmp' endianess buglet, print ID in hex.
Found by ho@@, help/test pb@@, hex suggestion/ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.14 2002/02/19 19:39:40 millert Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.14 2002/02/19 19:39:40 millert Exp $ (LBL)";
d97 7
d378 6
@


1.14
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.13 2001/11/07 18:48:16 deraadt Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.13 2001/11/07 18:48:16 deraadt Exp $ (LBL)";
d193 1
a193 1
				       "echo %s (id:%d seq:%d)",
d196 2
a197 1
				       dp->icmp_id, dp->icmp_seq);
@


1.13
log
@simplify buffer handling; ok ho
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.12 2001/09/02 12:06:57 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.12 2001/09/02 12:06:57 jakob Exp $ (LBL)";
a32 1
#ifdef __STDC__
a34 1
#endif
@


1.12
log
@bad typecast
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.11 2001/09/02 12:05:13 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.11 2001/09/02 12:05:13 jakob Exp $ (LBL)";
a169 1
	register char *cp;
d177 1
d287 1
a287 3
		(void)strncpy(buf, "router advertisement", sizeof buf-1);
		buf[sizeof buf-1] = '\0';
		cp = buf + strlen(buf);
d291 1
a291 2
		(void)strcpy(cp, " lifetime ");
		cp = buf + strlen(buf);
d294 1
a294 1
			(void)snprintf(cp, buf + sizeof buf - cp, "%u", lifetime);
d296 1
a296 1
			(void)snprintf(cp, buf + sizeof buf - cp, "%u:%02u",
d299 2
a300 3
			(void)snprintf(cp, buf + sizeof buf - cp, "%u:%02u:%02u",
			    lifetime / 3600,
			    (lifetime % 3600) / 60,
d302 1
a302 1
		cp = buf + strlen(buf);
d305 2
a306 2
		(void)snprintf(cp, buf + sizeof buf - cp, " %d:", num);
		cp = buf + strlen(buf);
d310 2
a311 2
			(void)snprintf(cp, buf - sizeof buf - cp,
				" [size %d]", size);
d317 1
a317 1
			(void)snprintf(cp, buf + sizeof buf - cp, " {%s %u}",
d320 1
a320 1
			cp = buf + strlen(buf);
@


1.11
log
@to much copy and paste; cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.10 2001/09/02 12:01:35 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.10 2001/09/02 12:01:35 jakob Exp $ (LBL)";
d200 1
a200 1
			buf = tok2str(icmp2str, "type-#%d", dp->icmp_type);
@


1.10
log
@add support for printing id and seq with icmp echo/echoreply; based on patch from cyxob@@thief.dyndns.org
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.9 2001/06/10 22:17:08 mickey Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.9 2001/06/10 22:17:08 mickey Exp $ (LBL)";
d199 2
a200 5
		} else {
			fmt = tok2str(icmp2str, "type-#%d", dp->icmp_type);
			(void)snprintf(buf, sizeof buf, fmt,
			    ipaddr_string(&dp->icmp_ip.ip_dst));
		}
@


1.9
log
@detailed ICMP_PARAMPROB printing; jakob@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp.c,v 1.8 2000/10/03 14:31:57 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.8 2000/10/03 14:31:57 ho Exp $ (LBL)";
d189 16
@


1.8
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.7 1998/07/13 22:13:47 deraadt Exp $ (LBL)";
d336 8
a343 5
		if (dp->icmp_code)
			(void)snprintf(buf, sizeof buf,
				"parameter problem - code %d",
				dp->icmp_code);
		else {
d348 1
@


1.7
log
@snprintf madness
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.6 1997/07/25 20:12:24 mickey Exp $ (LBL)";
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-icmp.c,v 1.5 1996/12/12 16:22:37 bitblt Exp $ (LBL)";
d175 1
a175 1
	char buf[256];
d194 2
a195 1
			(void)sprintf(buf, "%s protocol %d unreachable",
d209 1
a209 1
				(void)sprintf(buf,
d216 1
a216 1
				(void)sprintf(buf,
d223 1
a223 1
				(void)sprintf(buf,
d238 1
a238 1
			    (void)sprintf(buf,
d242 1
a242 1
			    (void)sprintf(buf,
d251 1
a251 1
			(void)sprintf(buf, fmt,
d261 1
a261 1
		(void)sprintf(buf, fmt,
d272 2
a273 1
		(void)strcpy(buf, "router advertisement");
d282 1
a282 1
			(void)sprintf(cp, "%u", lifetime);
d284 1
a284 1
			(void)sprintf(cp, "%u:%02u",
d287 1
a287 1
			(void)sprintf(cp, "%u:%02u:%02u",
d294 1
a294 1
		(void)sprintf(cp, " %d:", num);
d299 2
a300 1
			(void)sprintf(cp, " [size %d]", size);
d306 1
a306 1
			(void)sprintf(cp, " {%s %u}",
d327 2
a328 1
			(void)sprintf(buf, "time exceeded-#%d", dp->icmp_code);
d335 3
a337 2
			(void)sprintf(buf, "parameter problem - code %d",
					dp->icmp_code);
d340 3
a342 2
			(void)sprintf(buf, "parameter problem - octet %d",
					dp->icmp_pptr);
d348 1
a348 1
		(void)sprintf(buf, "address mask is 0x%08x",
@


1.5
log
@*** empty log message ***
@
text
@d24 1
a24 1
    "@@(#) $Header: print-icmp.c,v 1.38 96/09/26 23:36:44 leres Exp $ (LBL)";
d31 1
a31 1
#if __STDC__
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d23 2
a24 2
static char rcsid[] =
    "@@(#) Header: print-icmp.c,v 1.27 96/06/24 22:14:23 leres Exp (LBL)";
a28 1
#include <sys/types.h>
d49 1
d53 1
d55 1
a55 1
/* Compatibility */
d78 19
d102 1
a114 1
	{ ICMP_UNREACH_NEEDFRAG,	"%s unreachable - need to frag" },
d129 6
d147 18
d168 1
d174 1
a174 1
	register int hlen, dport;
a176 2
#define TCHECK(var, l) if ((u_char *)&(var) > snapend - l) goto trunc

d185 1
a185 1
	TCHECK(dp->icmp_code, sizeof(dp->icmp_code));
d189 1
a189 1
		TCHECK(dp->icmp_ip.ip_dst, sizeof(dp->icmp_ip.ip_dst));
d193 1
a193 1
			TCHECK(dp->icmp_ip.ip_p, sizeof(dp->icmp_ip.ip_p));
d200 1
a200 1
			TCHECK(dp->icmp_ip.ip_p, sizeof(dp->icmp_ip.ip_p));
d230 17
d257 1
a257 1
		TCHECK(dp->icmp_ip.ip_dst, sizeof(dp->icmp_ip.ip_dst));
d265 46
d312 1
a312 1
		TCHECK(dp->icmp_ip.ip_dst, sizeof(dp->icmp_ip.ip_dst));
d334 1
a334 1
			TCHECK(dp->icmp_pptr, sizeof(dp->icmp_pptr));
d341 1
a341 1
		TCHECK(dp->icmp_mask, sizeof(dp->icmp_mask));
a353 1
#undef TCHECK
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-icmp.c,v 1.3 1995/03/06 19:11:13 mycroft Exp $	*/
/*	$NetBSD: print-icmp.c,v 1.3 1995/03/06 19:11:13 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994
d26 1
a26 1
    "@@(#) Header: print-icmp.c,v 1.20 94/06/14 20:17:39 leres Exp (LBL)";
d34 4
d56 67
d128 1
a128 1
	register const char *str;
a131 1
	register const u_char *ep;
d134 1
a134 1
#define TCHECK(var, l) if ((u_char *)&(var) > ep - l) goto trunc
a138 2
	/* 'ep' points to the end of avaible data. */
	ep = snapend;
d146 1
a146 3
	case ICMP_ECHOREPLY:
		str = "echo reply";
		break;
d150 1
a150 8
		case ICMP_UNREACH_NET:
			(void)sprintf(buf, "net %s unreachable",
				       ipaddr_string(&dp->icmp_ip.ip_dst));
			break;
		case ICMP_UNREACH_HOST:
			(void)sprintf(buf, "host %s unreachable",
				       ipaddr_string(&dp->icmp_ip.ip_dst));
			break;
d157 1
d165 1
d172 1
d179 1
d188 6
a193 8
		case ICMP_UNREACH_NEEDFRAG:
			(void)sprintf(buf, "%s unreachable - need to frag",
				       ipaddr_string(&dp->icmp_ip.ip_dst));
			break;
		case ICMP_UNREACH_SRCFAIL:
			(void)sprintf(buf,
				"%s unreachable - source route failed",
				ipaddr_string(&dp->icmp_ip.ip_dst));
d197 1
a197 3
	case ICMP_SOURCEQUENCH:
		str = "source quench";
		break;
d200 5
a204 25
		switch (dp->icmp_code) {
		case ICMP_REDIRECT_NET:
			(void)sprintf(buf, "redirect %s to net %s",
				       ipaddr_string(&dp->icmp_ip.ip_dst),
				       ipaddr_string(&dp->icmp_gwaddr));
			break;
		case ICMP_REDIRECT_HOST:
			(void)sprintf(buf, "redirect %s to host %s",
				       ipaddr_string(&dp->icmp_ip.ip_dst),
				       ipaddr_string(&dp->icmp_gwaddr));
			break;
		case ICMP_REDIRECT_TOSNET:
			(void)sprintf(buf, "redirect-tos %s to net %s",
				       ipaddr_string(&dp->icmp_ip.ip_dst),
				       ipaddr_string(&dp->icmp_gwaddr));
			break;
		case ICMP_REDIRECT_TOSHOST:
			(void)sprintf(buf, "redirect-tos %s to host %s",
				       ipaddr_string(&dp->icmp_ip.ip_dst),
				       ipaddr_string(&dp->icmp_gwaddr));
			break;
		}
		break;
	case ICMP_ECHO:
		str = "echo request";
d206 1
d210 1
d214 1
d218 4
d224 1
d235 1
a235 15
	case ICMP_TSTAMP:
		str = "time stamp request";
		break;
	case ICMP_TSTAMPREPLY:
		str = "time stamp reply";
		break;
	case ICMP_IREQ:
		str = "information request";
		break;
	case ICMP_IREQREPLY:
		str = "information reply";
		break;
	case ICMP_MASKREQ:
		str = "address mask request";
		break;
d239 1
a239 1
		    ntohl(dp->icmp_mask));
d241 1
d243 1
a243 1
		(void)sprintf(buf, "type-#%d", dp->icmp_type);
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
