head	1.37;
access;
symbols
	OPENBSD_6_2:1.37.0.6
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.4
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.31.0.22
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.20
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.16
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.14
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.12
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.10
	OPENBSD_5_0:1.31.0.8
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.6
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.4
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.30.0.10
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.6
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.28.0.6
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.4
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.19.0.8
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.17.0.4
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2016.12.14.19.12.16;	author jca;	state Exp;
branches;
next	1.36;
commitid	Zsv5Q9iqF1vZQm9Q;

1.36
date	2015.11.18.15.36.20;	author mmcc;	state Exp;
branches;
next	1.35;
commitid	vQk1DzJRhR5UcrJ1;

1.35
date	2015.11.01.21.41.23;	author mmcc;	state Exp;
branches;
next	1.34;
commitid	p1uj0s8jedCmaMGx;

1.34
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Zx2k82IzYwwZaEz9;

1.33
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Uu5nFG3wCl0LACBb;

1.32
date	2014.10.08.04.58.50;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	tvvG4x1KpJxFKdVD;

1.31
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.21.03.13.14;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.26.21.10.54;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.23.17.29.22;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.22.18.41.33;	author moritz;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.13.05.37.25;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.13.17.56.29;	author canacar;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.04.08.35.12;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.02.09.43.27;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.31.15.13.03;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.28.19.44.55;	author canacar;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.03.12.09.12;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.23.18.32.20;	author jakob;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.31.16.06.46;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.03.14.31.54;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.24.10.55.57;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.30.05.23.28;	author ericj;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.26.21.35.37;	author jakob;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.07.13.35.53;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.16.12.07.29;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	99.10.06.01.46.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.09.16.20.58.44;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	99.07.28.20.41.35;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.20.12.20;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.23.00;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.06;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.10;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.58.55;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.23;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Sync extern decl of eproto_db with what's in libpcap.

For some reason this crashes on armv7.  Issue reported by Lars Nooden.
@
text
@/*	$OpenBSD: addrtoname.c,v 1.36 2015/11/18 15:36:20 mmcc Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  Internet, ethernet, port, and protocol string to address
 *  and address to string conversion routines
 */

#include <sys/socket.h>
#include <sys/time.h>
#include <sys/types.h>

struct mbuf;
struct rtentry;
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif

#include <arpa/inet.h>

#include <ctype.h>
#include <inttypes.h>
#include <netdb.h>
#include <pcap.h>
#include <pcap-namedb.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>

#include "interface.h"
#include "addrtoname.h"
#include "llc.h"
#include "privsep.h"
#include "savestr.h"

/*
 * hash tables for whatever-to-name translations
 */

#define HASHNAMESIZE 4096

struct hnamemem {
	u_int32_t addr;
	char *name;
	struct hnamemem *nxt;
};

struct hnamemem hnametable[HASHNAMESIZE];
struct hnamemem tporttable[HASHNAMESIZE];
struct hnamemem uporttable[HASHNAMESIZE];
struct hnamemem eprototable[HASHNAMESIZE];
struct hnamemem dnaddrtable[HASHNAMESIZE];
struct hnamemem llcsaptable[HASHNAMESIZE];

#ifdef INET6
struct h6namemem {
	struct in6_addr addr;
	char *name;
	struct h6namemem *nxt;
};

struct h6namemem h6nametable[HASHNAMESIZE];
#endif /* INET6 */

struct enamemem {
	u_short e_addr0;
	u_short e_addr1;
	u_short e_addr2;
	char *e_name;
	u_char *e_nsap;			/* used only for nsaptable[] */
#define e_bs e_nsap			/* for bytestringtable */
	struct enamemem *e_nxt;
};

struct enamemem enametable[HASHNAMESIZE];
struct enamemem nsaptable[HASHNAMESIZE];
struct enamemem bytestringtable[HASHNAMESIZE];
static char *ipprototable[256];

struct protoidmem {
	u_int32_t p_oui;
	u_short p_proto;
	char *p_name;
	struct protoidmem *p_nxt;
};

struct protoidmem protoidtable[HASHNAMESIZE];

/*
 * A faster replacement for inet_ntoa().
 */
char *
intoa(u_int32_t addr)
{
	char *cp;
	u_int byte;
	int n;
	static char buf[sizeof(".xxx.xxx.xxx.xxx")];

	NTOHL(addr);
	cp = &buf[sizeof buf];
	*--cp = '\0';

	n = 4;
	do {
		byte = addr & 0xff;
		*--cp = byte % 10 + '0';
		byte /= 10;
		if (byte > 0) {
			*--cp = byte % 10 + '0';
			byte /= 10;
			if (byte > 0)
				*--cp = byte + '0';
		}
		*--cp = '.';
		addr >>= 8;
	} while (--n > 0);

	return cp + 1;
}

static u_int32_t f_netmask;
static u_int32_t f_localnet;
static u_int32_t netmask;

/*
 * Return a name for the IP address pointed to by ap.  This address
 * is assumed to be in network byte order.
 */
char *
getname(const u_char *ap)
{
	char host[HOST_NAME_MAX+1];
	u_int32_t addr;
	struct hnamemem *p;

	/*
	 * Extract 32 bits in network order, dealing with alignment.
	 */
	switch ((intptr_t)ap & (sizeof(u_int32_t)-1)) {

	case 0:
		addr = *(u_int32_t *)ap;
		break;

	case 2:
#if BYTE_ORDER == BIG_ENDIAN
		addr = ((u_int32_t)*(u_short *)ap << 16) |
			(u_int32_t)*(u_short *)(ap + 2);
#else
		addr = ((u_int32_t)*(u_short *)(ap + 2) << 16) |
			(u_int32_t)*(u_short *)ap;
#endif
		break;

	default:
#if BYTE_ORDER == BIG_ENDIAN
		addr = ((u_int32_t)ap[0] << 24) |
			((u_int32_t)ap[1] << 16) |
			((u_int32_t)ap[2] << 8) |
			(u_int32_t)ap[3];
#else
		addr = ((u_int32_t)ap[3] << 24) |
			((u_int32_t)ap[2] << 16) |
			((u_int32_t)ap[1] << 8) |
			(u_int32_t)ap[0];
#endif
		break;
	}

	p = &hnametable[addr & (HASHNAMESIZE-1)];
	for (; p->nxt; p = p->nxt) {
		if (p->addr == addr)
			return (p->name);
	}
	p->addr = addr;
	p->nxt = newhnamemem();

	/*
	 * Only print names when:
	 *	(1) -n was not given
	 *      (2) Address is foreign and -f was given. (If -f was not
	 *	    give, f_netmask and f_local are 0 and the test
	 *	    evaluates to true)
	 *      (3) -a was given or the host portion is not all ones
	 *          nor all zeros (i.e. not a network or broadcast address)
	 */
	if (!nflag &&
	    (addr & f_netmask) == f_localnet &&
	    (aflag ||
	    !((addr & ~netmask) == 0 || (addr | netmask) == 0xffffffff))) {
		size_t n = priv_gethostbyaddr((char *)&addr, sizeof(addr),
		    AF_INET, host, sizeof(host));
		if (n > 0) {
			char *dotp;

			p->name = savestr(host);
			if (Nflag) {
				/* Remove domain qualifications */
				dotp = strchr(p->name, '.');
				if (dotp)
					*dotp = '\0';
			}
			return (p->name);
		}
	}
	p->name = savestr(intoa(addr));
	return (p->name);
}

#ifdef INET6
/*
 * Return a name for the IP6 address pointed to by ap.  This address
 * is assumed to be in network byte order.
 */
char *
getname6(const u_char *ap)
{
	char host[HOST_NAME_MAX+1];
	struct in6_addr addr;
	struct h6namemem *p;
	char *cp;
	char ntop_buf[INET6_ADDRSTRLEN];

	memcpy(&addr, ap, sizeof(addr));
	p = &h6nametable[*(u_int16_t *)&addr.s6_addr[14] & (HASHNAMESIZE-1)];
	for (; p->nxt; p = p->nxt) {
		if (memcmp(&p->addr, &addr, sizeof(addr)) == 0)
			return (p->name);
	}
	p->addr = addr;
	p->nxt = newh6namemem();

	/*
	 * Only print names when:
	 *	(1) -n was not given
	 *      (2) Address is foreign and -f was given. (If -f was not
	 *	    give, f_netmask and f_local are 0 and the test
	 *	    evaluates to true)
	 *      (3) -a was given or the host portion is not all ones
	 *          nor all zeros (i.e. not a network or broadcast address)
	 */
	if (!nflag
#if 0
	&&
	    (addr & f_netmask) == f_localnet &&
	    (aflag ||
	    !((addr & ~netmask) == 0 || (addr | netmask) == 0xffffffff))
#endif
	    ) {
		size_t n = priv_gethostbyaddr((char *)&addr, sizeof(addr),
		    AF_INET6, host, sizeof(host));
		if (n > 0) {
			char *dotp;

			p->name = savestr(host);
			if (Nflag) {
				/* Remove domain qualifications */
				dotp = strchr(p->name, '.');
				if (dotp)
					*dotp = '\0';
			}
			return (p->name);
		}
	}
	cp = (char *)inet_ntop(AF_INET6, &addr, ntop_buf, sizeof(ntop_buf));
	p->name = savestr(cp);
	return (p->name);
}
#endif /* INET6 */

static char hex[] = "0123456789abcdef";


/* Find the hash node that corresponds the ether address 'ep' */

static inline struct enamemem *
lookup_emem(const u_char *ep)
{
	u_int i, j, k;
	struct enamemem *tp;

	k = (ep[0] << 8) | ep[1];
	j = (ep[2] << 8) | ep[3];
	i = (ep[4] << 8) | ep[5];

	tp = &enametable[(i ^ j) & (HASHNAMESIZE-1)];
	while (tp->e_nxt)
		if (tp->e_addr0 == i &&
		    tp->e_addr1 == j &&
		    tp->e_addr2 == k)
			return tp;
		else
			tp = tp->e_nxt;
	tp->e_addr0 = i;
	tp->e_addr1 = j;
	tp->e_addr2 = k;
	tp->e_nxt = calloc(1, sizeof(*tp));
	if (tp->e_nxt == NULL)
		error("lookup_emem: calloc");

	return tp;
}

/*
 * Find the hash node that corresponds to the bytestring 'bs' 
 * with length 'nlen'
 */

static inline struct enamemem *
lookup_bytestring(const u_char *bs, const int nlen)
{
	struct enamemem *tp;
	u_int i, j, k;

	if (nlen >= 6) {
		k = (bs[0] << 8) | bs[1];
		j = (bs[2] << 8) | bs[3];
		i = (bs[4] << 8) | bs[5];
	} else if (nlen >= 4) {
		k = (bs[0] << 8) | bs[1];
		j = (bs[2] << 8) | bs[3];
		i = 0;
	} else
		i = j = k = 0;

	tp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];
	while (tp->e_nxt)
		if (tp->e_addr0 == i &&
		    tp->e_addr1 == j &&
		    tp->e_addr2 == k &&
		    bcmp((char *)bs, (char *)(tp->e_bs), nlen) == 0)
			return tp;
		else
			tp = tp->e_nxt;

	tp->e_addr0 = i;
	tp->e_addr1 = j;
	tp->e_addr2 = k;

	tp->e_bs = calloc(1, nlen + 1);
	if (tp->e_bs == NULL)
		error("lookup_bytestring: calloc");
	bcopy(bs, tp->e_bs, nlen);
	tp->e_nxt = calloc(1, sizeof(*tp));
	if (tp->e_nxt == NULL)
		error("lookup_bytestring: calloc");

	return tp;
}

/* Find the hash node that corresponds the NSAP 'nsap' */

static inline struct enamemem *
lookup_nsap(const u_char *nsap)
{
	u_int i, j, k;
	int nlen = *nsap;
	struct enamemem *tp;
	const u_char *ensap = nsap + nlen - 6;

	if (nlen > 6) {
		k = (ensap[0] << 8) | ensap[1];
		j = (ensap[2] << 8) | ensap[3];
		i = (ensap[4] << 8) | ensap[5];
	}
	else
		i = j = k = 0;

	tp = &nsaptable[(i ^ j) & (HASHNAMESIZE-1)];
	while (tp->e_nxt)
		if (tp->e_addr0 == i &&
		    tp->e_addr1 == j &&
		    tp->e_addr2 == k &&
		    tp->e_nsap[0] == nlen &&
		    memcmp((char *)&(nsap[1]),
			(char *)&(tp->e_nsap[1]), nlen) == 0)
			return tp;
		else
			tp = tp->e_nxt;
	tp->e_addr0 = i;
	tp->e_addr1 = j;
	tp->e_addr2 = k;
	tp->e_nsap = malloc(nlen + 1);
	if (tp->e_nsap == NULL)
		error("lookup_nsap: malloc");
	memcpy((char *)tp->e_nsap, (char *)nsap, nlen + 1);
	tp->e_nxt = calloc(1, sizeof(*tp));
	if (tp->e_nxt == NULL)
		error("lookup_nsap: calloc");

	return tp;
}

/* Find the hash node that corresponds the protoid 'pi'. */

static inline struct protoidmem *
lookup_protoid(const u_char *pi)
{
	u_int i, j;
	struct protoidmem *tp;

	/* 5 octets won't be aligned */
	i = (((pi[0] << 8) + pi[1]) << 8) + pi[2];
	j =   (pi[3] << 8) + pi[4];
	/* XXX should be endian-insensitive, but do big-endian testing  XXX */

	tp = &protoidtable[(i ^ j) & (HASHNAMESIZE-1)];
	while (tp->p_nxt)
		if (tp->p_oui == i && tp->p_proto == j)
			return tp;
		else
			tp = tp->p_nxt;
	tp->p_oui = i;
	tp->p_proto = j;
	tp->p_nxt = calloc(1, sizeof(*tp));
	if (tp->p_nxt == NULL)
		error("lookup_protoid: calloc");

	return tp;
}

char *
etheraddr_string(const u_char *ep)
{
	struct enamemem *tp;
	struct ether_addr e;

	tp = lookup_emem(ep);
	if (tp->e_name)
		return (tp->e_name);
#ifdef HAVE_ETHER_NTOHOST
	if (!nflag) {
		char buf[HOST_NAME_MAX+1 + 1];
		if (priv_ether_ntohost(buf, sizeof(buf),
		    (struct ether_addr *)ep) > 0) {
			tp->e_name = savestr(buf);
			return (tp->e_name);
		}
	}
#endif
	memcpy(e.ether_addr_octet, ep, sizeof(e.ether_addr_octet));
	tp->e_name = savestr(ether_ntoa(&e));
	return (tp->e_name);
}

char *
linkaddr_string(const u_char *ep, const int len)
{
	u_int i, j;
	char *cp;
	struct enamemem *tp;

	if (len == 6)	/* XXX not totally correct... */
		return etheraddr_string(ep);
	
	tp = lookup_bytestring(ep, len);
	if (tp->e_name)
		return (tp->e_name);

	tp->e_name = cp = reallocarray(NULL, len, 3);
	if (tp->e_name == NULL)
		error("linkaddr_string: malloc");
	if ((j = *ep >> 4) != 0)
		*cp++ = hex[j];
	*cp++ = hex[*ep++ & 0xf];
	for (i = len-1; i > 0 ; --i) {
		*cp++ = ':';
		if ((j = *ep >> 4) != 0)
			*cp++ = hex[j];
		*cp++ = hex[*ep++ & 0xf];
	}
	*cp = '\0';
	return (tp->e_name);
}

char *
etherproto_string(u_short port)
{
	char *cp;
	struct hnamemem *tp;
	u_int32_t i = port;
	char buf[sizeof("0000")];

	for (tp = &eprototable[i & (HASHNAMESIZE-1)]; tp->nxt; tp = tp->nxt)
		if (tp->addr == i)
			return (tp->name);

	tp->addr = i;
	tp->nxt = newhnamemem();

	cp = buf;
	NTOHS(port);
	*cp++ = hex[port >> 12 & 0xf];
	*cp++ = hex[port >> 8 & 0xf];
	*cp++ = hex[port >> 4 & 0xf];
	*cp++ = hex[port & 0xf];
	*cp++ = '\0';
	tp->name = savestr(buf);
	return (tp->name);
}

char *
protoid_string(const u_char *pi)
{
	u_int i, j;
	char *cp;
	struct protoidmem *tp;
	char buf[sizeof("00:00:00:00:00")];

	tp = lookup_protoid(pi);
	if (tp->p_name)
		return tp->p_name;

	cp = buf;
	if ((j = *pi >> 4) != 0)
		*cp++ = hex[j];
	*cp++ = hex[*pi++ & 0xf];
	for (i = 4; (int)--i >= 0;) {
		*cp++ = ':';
		if ((j = *pi >> 4) != 0)
			*cp++ = hex[j];
		*cp++ = hex[*pi++ & 0xf];
	}
	*cp = '\0';
	tp->p_name = savestr(buf);
	return (tp->p_name);
}

char *
llcsap_string(u_char sap)
{
	struct hnamemem *tp;
	u_int32_t i = sap;
	char buf[sizeof("sap 00")];

	for (tp = &llcsaptable[i & (HASHNAMESIZE-1)]; tp->nxt; tp = tp->nxt)
		if (tp->addr == i)
			return (tp->name);

	tp->addr = i;
	tp->nxt = newhnamemem();

	snprintf(buf, sizeof(buf), "sap %02x", sap & 0xff);
	tp->name = savestr(buf);
	return (tp->name);
}

char *
isonsap_string(const u_char *nsap)
{
	u_int i, nlen = nsap[0];
	char *cp;
	struct enamemem *tp;

	tp = lookup_nsap(nsap);
	if (tp->e_name)
		return tp->e_name;

	tp->e_name = cp = malloc(nlen * 2 + 2);
	if (cp == NULL)
		error("isonsap_string: malloc");

	nsap++;
	*cp++ = '/';
	for (i = nlen; (int)--i >= 0;) {
		*cp++ = hex[*nsap >> 4];
		*cp++ = hex[*nsap++ & 0xf];
	}
	*cp = '\0';
	return (tp->e_name);
}

char *
tcpport_string(u_short port)
{
	struct hnamemem *tp;
	u_int32_t i = port;
	char buf[sizeof("00000")];

	for (tp = &tporttable[i & (HASHNAMESIZE-1)]; tp->nxt; tp = tp->nxt)
		if (tp->addr == i)
			return (tp->name);

	tp->addr = i;
	tp->nxt = newhnamemem();

	(void)snprintf(buf, sizeof(buf), "%u", i);
	tp->name = savestr(buf);
	return (tp->name);
}

char *
udpport_string(u_short port)
{
	struct hnamemem *tp;
	u_int32_t i = port;
	char buf[sizeof("00000")];

	for (tp = &uporttable[i & (HASHNAMESIZE-1)]; tp->nxt; tp = tp->nxt)
		if (tp->addr == i)
			return (tp->name);

	tp->addr = i;
	tp->nxt = newhnamemem();

	(void)snprintf(buf, sizeof(buf), "%u", i);
	tp->name = savestr(buf);
	return (tp->name);
}

char *
ipproto_string(u_int proto)
{
	return ipprototable[proto & 0xff];
}

static void
init_servarray(void)
{
	struct hnamemem *table;
	int i, port;
	char buf[sizeof("0000000000")];
	char service[BUFSIZ];
	char protocol[BUFSIZ];

	priv_getserventries();
	while (priv_getserventry(service, sizeof(service), &port, protocol,
	    sizeof(protocol)) != 0) {
		port = ntohs(port);
		i = port & (HASHNAMESIZE-1);
		if (strcmp(protocol, "tcp") == 0)
			table = &tporttable[i];
		else if (strcmp(protocol, "udp") == 0)
			table = &uporttable[i];
		else
			continue;

		while (table->name)
			table = table->nxt;
		if (nflag) {
			(void)snprintf(buf, sizeof(buf), "%d", port);
			table->name = savestr(buf);
		} else
			table->name = savestr(service);
		table->addr = port;
		table->nxt = newhnamemem();
	}
}

static void
init_ipprotoarray(void)
{
	int i;
	char buf[sizeof("000")];
	char prot[BUFSIZ];

	if (!nflag) {
		priv_getprotoentries();
		while (priv_getprotoentry(prot, sizeof(prot), &i) != 0)
			ipprototable[i & 0xff] = savestr(prot);
	}
	for (i = 0; i < 256; i++)
		if (ipprototable[i] == NULL) {
			(void)snprintf(buf, sizeof(buf), "%d", i);
			ipprototable[i] = savestr(buf);
		}
}

/* XXX from libpcap */
extern const struct eproto {
	char *s;
	u_short p;
} * const eproto_db;

static void
init_eprotoarray(void)
{
	int i;
	struct hnamemem *table;

	for (i = 0; eproto_db[i].s; i++) {
		int j = ntohs(eproto_db[i].p) & (HASHNAMESIZE-1);
		table = &eprototable[j];
		while (table->name)
			table = table->nxt;
		table->name = eproto_db[i].s;
		table->addr = ntohs(eproto_db[i].p);
		table->nxt = newhnamemem();
	}
}

/*
 * SNAP proto IDs with org code 0:0:0 are actually encapsulated Ethernet
 * types.
 */
static void
init_protoidarray(void)
{
	int i;
	struct protoidmem *tp;
	u_char protoid[5];

	protoid[0] = 0;
	protoid[1] = 0;
	protoid[2] = 0;
	for (i = 0; eproto_db[i].s; i++) {
		u_short etype = htons(eproto_db[i].p);

		memcpy((char *)&protoid[3], (char *)&etype, 2);
		tp = lookup_protoid(protoid);
		tp->p_name = savestr(eproto_db[i].s);
	}
}

static struct etherlist {
	u_char addr[6];
	char *name;
} etherlist[] = {
	{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }, "Broadcast" },
	{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, NULL }
};

/*
 * Initialize the ethers hash table.  We take two different approaches
 * depending on whether or not the system provides the ethers name
 * service.  If it does, we just wire in a few names at startup,
 * and etheraddr_string() fills in the table on demand.  If it doesn't,
 * then we suck in the entire /etc/ethers file at startup.  The idea
 * is that parsing the local file will be fast, but spinning through
 * all the ethers entries via NIS & next_etherent might be very slow.
 *
 * XXX pcap_next_etherent doesn't belong in the pcap interface, but
 * since the pcap module already does name-to-address translation,
 * it's already does most of the work for the ethernet address-to-name
 * translation, so we just pcap_next_etherent as a convenience.
 */
static void
init_etherarray(void)
{
	struct etherlist *el;
	struct enamemem *tp;
#ifdef HAVE_ETHER_NTOHOST
	char name[HOST_NAME_MAX+1 + 1];
#else
	struct pcap_etherent *ep;
	FILE *fp;

	/* Suck in entire ethers file */
	fp = fopen(PCAP_ETHERS_FILE, "r");
	if (fp != NULL) {
		while ((ep = pcap_next_etherent(fp)) != NULL) {
			tp = lookup_emem(ep->addr);
			tp->e_name = savestr(ep->name);
		}
		(void)fclose(fp);
	}
#endif

	/* Hardwire some ethernet names */
	for (el = etherlist; el->name != NULL; ++el) {
		tp = lookup_emem(el->addr);
		/* Don't override existing name */
		if (tp->e_name != NULL)
			continue;

#ifdef HAVE_ETHER_NTOHOST
                /* Use yp/nis version of name if available */
                if (priv_ether_ntohost(name, sizeof(name),
		    (struct ether_addr *)el->addr) > 0) {
                        tp->e_name = savestr(name);
			continue;
		}
#endif
		tp->e_name = el->name;
	}
}

static struct tok llcsap_db[] = {
	{ LLCSAP_NULL,		"null" },
	{ LLCSAP_8021B_I,	"802.1b-gsap" },
	{ LLCSAP_8021B_G,	"802.1b-isap" },
	{ LLCSAP_IP,		"ip-sap" },
	{ LLCSAP_PROWAYNM,	"proway-nm" },
	{ LLCSAP_8021D,		"802.1d" },
	{ LLCSAP_RS511,		"eia-rs511" },
	{ LLCSAP_ISO8208,	"x.25/llc2" },
	{ LLCSAP_PROWAY,	"proway" },
	{ LLCSAP_ISONS,		"iso-clns" },
	{ LLCSAP_GLOBAL,	"global" },
	{ 0,			NULL }
};

static void
init_llcsaparray(void)
{
	int i;
	struct hnamemem *table;

	for (i = 0; llcsap_db[i].s != NULL; i++) {
		table = &llcsaptable[llcsap_db[i].v];
		while (table->name)
			table = table->nxt;
		table->name = llcsap_db[i].s;
		table->addr = llcsap_db[i].v;
		table->nxt = newhnamemem();
	}
}

/*
 * Initialize the address to name translation machinery.  We map all
 * non-local IP addresses to numeric addresses if fflag is true (i.e.,
 * to prevent blocking on the nameserver).  localnet is the IP address
 * of the local network.  mask is its subnet mask.
 */
void
init_addrtoname(u_int32_t localnet, u_int32_t mask)
{
	netmask = mask;
	if (fflag) {
		f_localnet = localnet;
		f_netmask = mask;
	}

	init_servarray();
	init_ipprotoarray();

	if (nflag)
		/*
		 * Simplest way to suppress names.
		 */
		return;

	init_etherarray();
	init_eprotoarray();
	init_llcsaparray();
	init_protoidarray();
}

char *
dnaddr_string(u_short dnaddr)
{
	struct hnamemem *tp;

	for (tp = &dnaddrtable[dnaddr & (HASHNAMESIZE-1)]; tp->nxt != 0;
	     tp = tp->nxt)
		if (tp->addr == dnaddr)
			return (tp->name);

	tp->addr = dnaddr;
	tp->nxt = newhnamemem();
	if (nflag)
		tp->name = dnnum_string(dnaddr);
	else
		tp->name = dnname_string(dnaddr);

	return(tp->name);
}

/* Return a zero'ed hnamemem struct and cuts down on calloc() overhead */
struct hnamemem *
newhnamemem(void)
{
	struct hnamemem *p;
	static struct hnamemem *ptr = NULL;
	static u_int num = 0;

	if (num  <= 0) {
		num = 64;
		ptr = calloc(num, sizeof (*ptr));
		if (ptr == NULL)
			error("newhnamemem: calloc");
	}
	--num;
	p = ptr++;
	return (p);
}

#ifdef INET6
/* Return a zero'ed h6namemem struct and cuts down on calloc() overhead */
struct h6namemem *
newh6namemem(void)
{
	struct h6namemem *p;
	static struct h6namemem *ptr = NULL;
	static u_int num = 0;

	if (num  <= 0) {
		num = 64;
		ptr = calloc(num, sizeof (*ptr));
		if (ptr == NULL)
			error("newh6namemem: calloc");
	}
	--num;
	p = ptr++;
	return (p);
}
#endif /* INET6 */
@


1.36
log
@Remove memory.h includes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.35 2015/11/01 21:41:23 mmcc Exp $	*/
d696 2
a697 2
/*XXX from libbpfc.a */
extern struct eproto {
d700 1
a700 1
} eproto_db[];
@


1.35
log
@Remove register keyword uses. Still needs to be done in all other
tcpdump source files.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.34 2015/08/21 02:07:32 deraadt Exp $	*/
a48 3
#ifdef HAVE_MEMORY_H
#include <memory.h>
#endif
@


1.34
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.33 2015/01/16 06:40:21 deraadt Exp $	*/
d124 3
a126 3
	register char *cp;
	register u_int byte;
	register int n;
d251 1
a251 1
	register char *cp;
d309 1
a309 1
	register u_int i, j, k;
d340 1
a340 1
lookup_bytestring(register const u_char *bs, const int nlen)
d343 1
a343 1
	register u_int i, j, k;
d384 1
a384 1
lookup_nsap(register const u_char *nsap)
d386 1
a386 1
	register u_int i, j, k;
d429 1
a429 1
	register u_int i, j;
d453 1
a453 1
etheraddr_string(register const u_char *ep)
d455 1
a455 1
	register struct enamemem *tp;
d479 3
a481 3
	register u_int i, j;
	register char *cp;
	register struct enamemem *tp;
d509 3
a511 3
	register char *cp;
	register struct hnamemem *tp;
	register u_int32_t i = port;
d533 1
a533 1
protoid_string(register const u_char *pi)
d535 3
a537 3
	register u_int i, j;
	register char *cp;
	register struct protoidmem *tp;
d562 2
a563 2
	register struct hnamemem *tp;
	register u_int32_t i = sap;
d581 3
a583 3
	register u_int i, nlen = nsap[0];
	register char *cp;
	register struct enamemem *tp;
d606 2
a607 2
	register struct hnamemem *tp;
	register u_int32_t i = port;
d623 1
a623 1
udpport_string(register u_short port)
d625 2
a626 2
	register struct hnamemem *tp;
	register u_int32_t i = port;
d708 2
a709 2
	register int i;
	register struct hnamemem *table;
d729 2
a730 2
	register int i;
	register struct protoidmem *tp;
d770 2
a771 2
	register struct etherlist *el;
	register struct enamemem *tp;
d775 2
a776 2
	register struct pcap_etherent *ep;
	register FILE *fp;
d826 2
a827 2
	register int i;
	register struct hnamemem *table;
d872 1
a872 1
	register struct hnamemem *tp;
d893 1
a893 1
	register struct hnamemem *p;
d913 1
a913 1
	register struct h6namemem *p;
@


1.33
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.32 2014/10/08 04:58:50 deraadt Exp $	*/
d327 1
a327 1
	tp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));
d370 1
a370 1
	tp->e_bs = (u_char *) calloc(1, nlen + 1);
d374 1
a374 1
	tp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));
d413 1
a413 1
	tp->e_nsap = (u_char *)malloc(nlen + 1);
d417 1
a417 1
	tp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));
d445 1
a445 1
	tp->p_nxt = (struct protoidmem *)calloc(1, sizeof(*tp));
d589 1
a589 1
	tp->e_name = cp = (char *)malloc(nlen * 2 + 2);
d899 1
a899 1
		ptr = (struct hnamemem *)calloc(num, sizeof (*ptr));
d919 1
a919 1
		ptr = (struct h6namemem *)calloc(num, sizeof (*ptr));
@


1.32
log
@obvious malloc() -> reallocarray() oflow check; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.31 2009/10/27 23:59:55 deraadt Exp $	*/
a26 1
#include <sys/param.h>
d57 1
d162 1
a162 1
	char host[MAXHOSTNAMELEN];
d248 1
a248 1
	char host[MAXHOSTNAMELEN];
d463 1
a463 1
		char buf[MAXHOSTNAMELEN + 1];
d773 1
a773 1
	char name[MAXHOSTNAMELEN + 1];
@


1.31
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.30 2007/10/07 16:41:05 deraadt Exp $	*/
d490 1
a490 1
	tp->e_name = cp = (char *)malloc(len*3);
@


1.30
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.29 2007/06/21 03:13:14 ray Exp $	*/
a25 4
#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.29
log
@Print leading zeros in MAC addresses.  Initial diff from Stanislav
Kruchinin, idea to use ether_ntoa from Claudio Jeker.

OK canacar, idea OK henning, jasper, and tedu.
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.28 2006/02/26 21:10:54 otto Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /home/ray/openbsd/src/usr.sbin/tcpdump/addrtoname.c,v 1.28 2006/02/26 21:10:54 otto Exp $ (LBL)";
@


1.28
log
@check return value of calloc(3)'; From Alexey Dobriyan; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.27 2006/01/23 17:29:22 millert Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.27 2006/01/23 17:29:22 millert Exp $ (LBL)";
d34 1
a458 2
	register u_int i, j;
	register char *cp;
d460 1
a460 1
	char buf[sizeof("00:00:00:00:00:00")];
d475 2
a476 12
	cp = buf;
	if ((j = *ep >> 4) != 0)
		*cp++ = hex[j];
	*cp++ = hex[*ep++ & 0xf];
	for (i = 5; (int)--i >= 0;) {
		*cp++ = ':';
		if ((j = *ep >> 4) != 0)
			*cp++ = hex[j];
		*cp++ = hex[*ep++ & 0xf];
	}
	*cp = '\0';
	tp->e_name = savestr(buf);
@


1.27
log
@Include <sys/param.h> instead of <sys/types.h> so we get MAXHOSTNAMELEN
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.26 2005/05/22 18:41:33 moritz Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /home/cvs/openbsd/src/usr.sbin/tcpdump/addrtoname.c,v 1.26 2005/05/22 18:41:33 moritz Exp $ (LBL)";
d374 2
@


1.26
log
@fix signal race in statistics output. ok cloder@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.25 2004/12/13 05:37:25 itojun Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.25 2004/12/13 05:37:25 itojun Exp $ (LBL)";
d31 1
a31 1
#include <sys/types.h>
@


1.25
log
@permit protocol name longer than 3 letters.  canacar ok
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.24 2004/02/13 17:56:29 canacar Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.24 2004/02/13 17:56:29 canacar Exp $ (LBL)";
a66 1
#include "setsignal.h"
@


1.24
log
@Print protocol and service numbers correctly when -n switch is specified.
reported by mcbride@@
ok otto@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.23 2004/02/04 08:35:12 otto Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.23 2004/02/04 08:35:12 otto Exp $ (LBL)";
d668 1
a668 1
	char protocol[sizeof("tcp")];
@


1.23
log
@Some more non-alignment problems resolved.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.22 2004/02/02 09:43:27 otto Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.22 2004/02/02 09:43:27 otto Exp $ (LBL)";
d867 4
a877 1
	init_servarray();
a880 1
	init_ipprotoarray();
@


1.22
log
@Do away with non-aligned memory accesses.
ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.21 2004/01/31 15:13:03 otto Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.21 2004/01/31 15:13:03 otto Exp $ (LBL)";
d49 1
d173 1
a173 1
	switch ((long)ap & 3) {
@


1.21
log
@general cleanup and better SIGCHLD handling from millert@@
ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.20 2004/01/28 19:44:55 canacar Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.20 2004/01/28 19:44:55 canacar Exp $ (LBL)";
a168 3
#ifndef LBL_ALIGN
	addr = *(const u_int32_t *)ap;
#else
d202 1
a202 1
#endif
@


1.20
log
@privilege separated tcpdump, joint work with otto@@

tested by avsm@@ vincent@@ dhartmei@@ markus@@ hshoexer@@ and others
go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.19 2002/02/19 19:39:40 millert Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.19 2002/02/19 19:39:40 millert Exp $ (LBL)";
d227 2
a228 2
		int n = priv_gethostbyaddr((char *)&addr, 4, AF_INET,
		    host, sizeof(host));
d286 1
a286 1
		int n = priv_gethostbyaddr((char *)&addr, sizeof(addr),
@


1.19
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.18 2001/11/03 12:09:12 ho Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.18 2001/11/03 12:09:12 ho Exp $ (LBL)";
d64 1
d110 1
d165 1
a165 1
	register struct hostent *hp;
d227 3
a229 2
		hp = gethostbyaddr((char *)&addr, 4, AF_INET);
		if (hp) {
d232 1
a232 1
			p->name = savestr(hp->h_name);
d254 1
a254 1
	register struct hostent *hp;
d286 3
a288 2
		hp = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET6);
		if (hp) {
d291 1
a291 1
			p->name = savestr(hp->h_name);
d470 2
a471 1
		if (ether_ntohost(buf, (struct ether_addr *)ep) == 0) {
d657 6
d666 2
a667 3
	struct servent *sv;
	register struct hnamemem *table;
	register int i;
d669 2
d672 4
a675 2
	while ((sv = getservent()) != NULL) {
		int port = ntohs(sv->s_port);
d677 1
a677 1
		if (strcmp(sv->s_proto, "tcp") == 0)
d679 1
a679 1
		else if (strcmp(sv->s_proto, "udp") == 0)
d690 1
a690 1
			table->name = savestr(sv->s_name);
d694 19
a712 1
	endservent();
d814 2
a815 1
                if (ether_ntohost(name, (struct ether_addr *)el->addr) == 0) {
d880 1
@


1.18
log
@Don't try to avoid name lookup waits with setjmp/signal. By deraadt@@, me.
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.17 2000/11/23 18:32:20 jakob Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.17 2000/11/23 18:32:20 jakob Exp $ (LBL)";
a34 1
#ifdef __STDC__
a36 1
#endif
@


1.17
log
@fix one more s/sprintf/snprintf/; jeremy@@hack.org.il
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.16 2000/10/31 16:06:46 deraadt Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.16 2000/10/31 16:06:46 deraadt Exp $ (LBL)";
a68 3
/* Forwards */
static RETSIGTYPE nohostname(int);

a158 14
 * "getname" is written in this atrocious way to make sure we don't
 * wait forever while trying to get hostnames from yp.
 */
#include <setjmp.h>

jmp_buf getname_env;

static RETSIGTYPE
nohostname(int signo)
{
	longjmp(getname_env, 1);
}

/*
d167 1
a167 1
	static struct hnamemem *p;		/* static for longjmp() */
d216 1
a216 1
	 *	(1) -n was not given.
d227 10
a236 16
		if (!setjmp(getname_env)) {
			(void)setsignal(SIGALRM, nohostname);
			(void)alarm(20);
			hp = gethostbyaddr((char *)&addr, 4, AF_INET);
			(void)alarm(0);
			if (hp) {
				char *dotp;

				p->name = savestr(hp->h_name);
				if (Nflag) {
					/* Remove domain qualifications */
					dotp = strchr(p->name, '.');
					if (dotp)
						*dotp = '\0';
				}
				return (p->name);
d238 1
d255 1
a255 1
	static struct h6namemem *p;		/* static for longjmp() */
d270 1
a270 1
	 *	(1) -n was not given.
d285 10
a294 16
		if (!setjmp(getname_env)) {
			(void)setsignal(SIGALRM, nohostname);
			(void)alarm(20);
			hp = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET6);
			(void)alarm(0);
			if (hp) {
				char *dotp;

				p->name = savestr(hp->h_name);
				if (Nflag) {
					/* Remove domain qualifications */
					dotp = strchr(p->name, '.');
					if (dotp)
						*dotp = '\0';
				}
				return (p->name);
d296 1
@


1.16
log
@some buffer care; jakob
@
text
@d1 1
a1 1
/*	$OpenBSD: addrtoname.c,v 1.15 2000/10/03 14:31:54 ho Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.15 2000/10/03 14:31:54 ho Exp $ (LBL)";
d676 1
a676 1
	(void)sprintf(buf, "%u", i);
@


1.15
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.14 2000/09/24 10:55:57 brad Exp $ (LBL)";
d657 1
a657 1
	(void)sprintf(buf, "%u", i);
d702 1
a702 1
			(void)sprintf(buf, "%d", port);
@


1.14
log
@re-apply this fix for big endian systems, this was lost in rev 1.12
@
text
@d1 2
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.13 2000/04/30 05:23:28 ericj Exp $ (LBL)";
@


1.13
log
@be more careful with strcpy/sprintf. From tcpdump.org. millert@@ ok
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.12 2000/04/26 21:35:37 jakob Exp $ (LBL)";
d197 1
a197 1
#ifdef WORDS_BIGENDIAN
d207 1
a207 1
#ifdef WORDS_BIGENDIAN
@


1.12
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.11 2000/02/07 13:35:53 itojun Exp $ (LBL)";
a599 1
	register char *cp;
d611 1
a611 6
	cp = buf;
	(void)strcpy(cp, "sap ");
	cp += strlen(cp);
	*cp++ = hex[sap >> 4 & 0xf];
	*cp++ = hex[sap & 0xf];
	*cp++ = '\0';
@


1.11
log
@fix include file path.
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.10 2000/01/16 12:07:29 jakob Exp $ (LBL)";
a51 3
#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif
d105 1
d111 1
d197 1
a197 1
#if BYTE_ORDER == BIG_ENDIAN
d207 1
a207 1
#if BYTE_ORDER == BIG_ENDIAN
d363 45
d492 1
a492 1
		char buf[128];
d515 30
d790 1
a790 1
	char name[256];
@


1.10
log
@INET6 address resolution (from KAME)
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.9 1999/10/06 01:46:40 deraadt Exp $ (LBL)";
d43 1
a43 1
#include <netinet6/ip6.h>
@


1.9
log
@big endian fixes; ryker, jd@@noc7.uchsc.edu
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.8 1999/09/16 20:58:44 brad Exp $ (LBL)";
d42 4
d52 4
d57 1
d92 10
d266 65
d846 21
@


1.8
log
@bring more inline with tcpdump 3.4
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.7 1999/07/28 20:41:35 jakob Exp $ (LBL)";
d179 1
a179 1
#ifdef WORDS_BIGENDIAN
d189 1
a189 1
#ifdef WORDS_BIGENDIAN
@


1.7
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.6 1997/07/25 20:12:20 mickey Exp $ (LBL)";
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/addrtoname.c,v 1.5 1996/12/12 16:23:00 bitblt Exp $ (LBL)";
d48 1
d58 2
d214 5
a218 5
	 *	(2) Address is foreign and -f was given.  If -f was not
	 *	    present, f_netmask and f_local are 0 and the second
	 *	    test will succeed.
	 *	(3) The host portion is not 0 (i.e., a network address).
	 *	(4) The host portion is not broadcast.
d220 4
a223 2
	if (!nflag && (addr & f_netmask) == f_localnet
	    && (addr &~ netmask) != 0 && (addr | netmask) != 0xffffffff) {
d225 1
a225 1
			(void)signal(SIGALRM, nohostname);
d315 1
a315 1
	memcpy(tp->e_nsap, nsap, nlen + 1);
d704 1
a704 1
init_addrtoname(int fflag, u_int32_t localnet, u_int32_t mask)
@


1.5
log
@*** empty log message ***
@
text
@d26 1
a26 1
    "@@(#) $Header: addrtoname.c,v 1.54 96/12/05 22:10:19 leres Exp $ (LBL)";
d33 1
a33 1
#if __STDC__
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d25 2
a26 2
static char rcsid[] =
    "@@(#) Header: addrtoname.c,v 1.48 96/06/19 00:50:15 leres Exp (LBL)";
d163 1
a163 1
#ifndef TCPDUMP_ALIGN
d167 1
a167 1
	 * Deal with alignment.
d176 4
a179 1
#if BYTE_ORDER == LITTLE_ENDIAN
a181 3
#else
		addr = ((u_int32_t)*(u_short *)ap << 16) |
			(u_int32_t)*(u_short *)(ap + 2);
d186 6
a191 1
#if BYTE_ORDER == LITTLE_ENDIAN
a195 5
#else
		addr = ((u_int32_t)ap[0] << 24) |
			((u_int32_t)ap[1] << 16) |
			((u_int32_t)ap[2] << 8) |
			(u_int32_t)ap[3];
d741 1
a741 1
newhnamemem()
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: addrtoname.c,v 1.4 1995/04/24 13:27:39 cgd Exp $	*/
/*	$NetBSD: addrtoname.c,v 1.4 1995/04/24 13:27:39 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1990, 1991, 1992, 1993, 1994
d28 1
a28 1
    "@@(#) Header: addrtoname.c,v 1.37 94/06/16 00:42:28 mccanne Exp (LBL)";
d35 4
a52 1
#ifdef __STDC__
a53 1
#endif
d60 2
a61 5
static SIGRET nohostname(int);
#ifdef ETHER_SERVICE
struct ether_addr;
extern int ether_ntohost(char *, struct ether_addr *);
#endif
d70 1
a70 1
	u_int32 addr;
d95 1
a95 1
	u_long p_oui;
d107 1
a107 1
intoa(u_int32 addr)
d136 3
a138 3
static u_int32 f_netmask;
static u_int32 f_localnet;
static u_int32 netmask;
d148 1
a148 1
static SIGRET
d162 1
a162 2
	register char *cp;
	u_int32 addr;
d166 1
a166 1
	addr = *(const u_int32 *)ap;
d174 1
a174 1
		addr = *(u_int32 *)ap;
d179 2
a180 2
		addr = ((u_int32)*(u_short *)(ap + 2) << 16) |
			(u_int32)*(u_short *)ap;
d182 2
a183 2
		addr = ((u_int32)*(u_short *)ap << 16) |
			(u_int32)*(u_short *)(ap + 2);
d189 4
a192 4
		addr = ((u_int32)ap[0] << 24) |
			((u_int32)ap[1] << 16) |
			((u_int32)ap[2] << 8) |
			(u_int32)ap[3];
d194 4
a197 4
		addr = ((u_int32)ap[3] << 24) |
			((u_int32)ap[2] << 16) |
			((u_int32)ap[1] << 8) |
			(u_int32)ap[0];
d208 1
a208 1
	p->nxt = (struct hnamemem *)calloc(1, sizeof (*p));
d234 1
a234 1
						*dotp = 0;
d240 1
a240 2
	cp = intoa(addr);
	p->name = savestr(cp);
d247 1
a247 1
/* Find the hash node that corresponds the ether address 'ep'. */
d271 2
d277 1
a277 1
/* Find the hash node that corresponds the NSAP 'nsap'. */
d301 1
a301 1
		    bcmp((char *)&(nsap[1]),
d309 4
a312 2
	tp->e_nsap = (u_char *) calloc(1, nlen + 1);
	bcopy(nsap, tp->e_nsap, nlen + 1);
d314 2
d342 2
d354 1
d359 1
a359 1
#ifdef ETHER_SERVICE
d368 1
a368 2
	tp->e_name = cp = (char *)malloc(sizeof("00:00:00:00:00:00"));

d379 1
d388 2
a389 1
	register u_long i = port;
a394 1
	tp->name = cp = (char *)malloc(sizeof("0000"));
d396 1
a396 1
	tp->nxt = (struct hnamemem *)calloc(1, sizeof (*tp));
d398 1
d405 1
d415 1
d421 1
a421 2
	tp->p_name = cp = (char *)malloc(sizeof("00:00:00:00:00"));

d432 1
d441 2
a442 1
	register u_long i = sap;
a447 1
	tp->name = cp = (char *)malloc(sizeof("sap 00"));
d449 1
a449 1
	tp->nxt = (struct hnamemem *)calloc(1, sizeof (*tp));
d451 1
d457 1
d473 2
d490 2
a491 1
	register u_long i = port;
a496 1
	tp->name = (char *)malloc(sizeof("00000"));
d498 1
a498 1
	tp->nxt = (struct hnamemem *)calloc(1, sizeof (*tp));
d500 2
a501 1
	(void)sprintf(tp->name, "%d", i);
d509 2
a510 1
	register u_long i = port;
a515 1
	tp->name = (char *)malloc(sizeof("00000"));
d517 1
a517 3
	tp->nxt = (struct hnamemem *)calloc(1, sizeof(*tp));

	(void)sprintf(tp->name, "%d", i);
d519 2
d530 1
a544 2
			char buf[32];

d550 1
a550 1
		table->nxt = (struct hnamemem *)calloc(1, sizeof(*table));
d574 1
a574 1
		table->nxt = (struct hnamemem *)calloc(1, sizeof(*table));
d594 2
a595 1
		bcopy((char *)&etype, (char *)&protoid[3], 2);
d628 3
a630 1
#ifndef ETHER_SERVICE
d647 6
a652 1
#ifdef ETHER_SERVICE
d654 3
a656 4
		char wrk[256];
                if (ether_ntohost(wrk, (struct ether_addr *)el->addr) == 0) {
			tp = lookup_emem(el->addr);
                        tp->e_name = savestr(wrk);
a657 5
#else
		/* install if not already present */
		tp = lookup_emem(el->addr);
		if (tp->e_name == NULL)
			tp->e_name = el->name;
d659 1
a659 1

d663 1
a663 1
static struct token llcsap_db[] = {
d690 1
a690 1
		table->nxt = (struct hnamemem *)calloc(1, sizeof(*table));
d701 1
a701 1
init_addrtoname(int fflag, u_int32 localnet, u_int32 mask)
d732 1
a732 1
	tp->nxt = (struct hnamemem *)calloc(1, sizeof(*tp));
d739 19
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
