head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.14
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.10
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.12
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.10
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.8
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	enjTsnD5UO6xazKc;

1.19
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	Uu5nFG3wCl0LACBb;

1.18
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.17;
commitid	yLXrOcgrag4eS8u4;

1.17
date	2014.07.04.08.42.38;	author bluhm;	state Exp;
branches;
next	1.16;
commitid	cgxc0zwlHbAcF8bU;

1.16
date	2011.03.22.17.31.18;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2010.08.04.16.47.01;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.14.03.23.49;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.21.23.09.34;	author cloder;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.17.17.24.30;	author stevesk;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.08.10.58.27;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.03.14.31.58;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.26.21.35.42;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.30;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.27;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.33;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@/*	$OpenBSD: print-ospf.c,v 1.19 2015/01/16 06:40:21 deraadt Exp $	*/

/*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * OSPF support contributed by Jeffrey Honig (jch@@mitchell.cit.cornell.edu)
 */

#include <sys/time.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#include <ctype.h>
#include <stdio.h>

#include "interface.h"
#include "addrtoname.h"

#include "ospf.h"

struct bits {
	u_int32_t bit;
	const char *str;
};

static const struct bits ospf_option_bits[] = {
	{ OSPF_OPTION_T,	"T" },
	{ OSPF_OPTION_E,	"E" },
	{ OSPF_OPTION_MC,	"MC" },
	{ 0,			NULL }
};

static const struct bits ospf_rla_flag_bits[] = {
	{ RLA_FLAG_B,		"B" },
	{ RLA_FLAG_E,		"E" },
	{ RLA_FLAG_W1,		"W1" },
	{ RLA_FLAG_W2,		"W2" },
	{ 0,			NULL }
};

static struct tok type2str[] = {
	{ OSPF_TYPE_UMD,	"umd" },
	{ OSPF_TYPE_HELLO,	"hello" },
	{ OSPF_TYPE_DB,		"dd" },
	{ OSPF_TYPE_LSR,	"ls_req" },
	{ OSPF_TYPE_LSU,	"ls_upd" },
	{ OSPF_TYPE_LSA,	"ls_ack" },
	{ 0,			NULL }
};

static char tstr[] = " [|ospf]";

/* Forwards */
static inline void ospf_print_seqage(u_int32_t, time_t);
static inline void ospf_print_bits(const struct bits *, u_char);
static void ospf_print_ls_type(u_int, const struct in_addr *,
    const struct in_addr *, const char *);
static int ospf_print_lshdr(const struct lsa_hdr *);
static int ospf_print_lsa(const struct lsa *);
static int ospf_decode_v2(const struct ospfhdr *, const u_char *);

static inline void
ospf_print_seqage(u_int32_t seq, time_t us)
{
	time_t sec = us % 60;
	time_t mins = (us / 60) % 60;
	time_t hour = us / 3600;

	printf(" S %X age ", seq);
	if (hour)
		printf("%u:%02u:%02u",
		    (u_int32_t) hour, (u_int32_t) mins, (u_int32_t) sec);
	else if (mins)
		printf("%u:%02u", (u_int32_t) mins, (u_int32_t) sec);
	else
		printf("%u", (u_int32_t) sec);
}


static inline void
ospf_print_bits(const struct bits *bp, u_char options)
{
	char sep = ' ';

	do {
		if (options & bp->bit) {
			printf("%c%s", sep, bp->str);
			sep = '/';
		}
	} while ((++bp)->bit);
}

static void
ospf_print_ls_type(u_int ls_type, const struct in_addr *ls_stateid,
    const struct in_addr *ls_router, const char *fmt)
{

	switch (ls_type) {

	case LS_TYPE_ROUTER:
		printf(" rtr %s", ipaddr_string(ls_router));
		break;

	case LS_TYPE_NETWORK:
		printf(" net dr %s if %s",
		    ipaddr_string(ls_router),
		    ipaddr_string(ls_stateid));
		break;

	case LS_TYPE_SUM_IP:
		printf(" sum %s abr %s",
		    ipaddr_string(ls_stateid),
		    ipaddr_string(ls_router));
		break;

	case LS_TYPE_SUM_ABR:
		printf(" abr %s rtr %s",
		    ipaddr_string(ls_router),
		    ipaddr_string(ls_stateid));
		break;

	case LS_TYPE_ASE:
		printf(" ase %s asbr %s",
		    ipaddr_string(ls_stateid),
		    ipaddr_string(ls_router));
		break;

	case LS_TYPE_GROUP:
		printf(" group %s rtr %s",
		    ipaddr_string(ls_stateid),
		    ipaddr_string(ls_router));
		break;

	default:
		putchar(' ');
		printf(fmt, ls_type);
		break;
	}
}

static int
ospf_print_lshdr(const struct lsa_hdr *lshp)
{

	TCHECK(lshp->ls_type);
	printf(" {");						/* } (ctags) */

	TCHECK(lshp->ls_options);
	ospf_print_bits(ospf_option_bits, lshp->ls_options);
	TCHECK(lshp->ls_seq);
	ospf_print_seqage(ntohl(lshp->ls_seq), ntohs(lshp->ls_age));
	ospf_print_ls_type(lshp->ls_type, &lshp->ls_stateid, &lshp->ls_router,
	    "ls_type %d");

	return (0);
trunc:
	return (1);
}


/*
 * Print a single link state advertisement.  If truncated return 1, else 0.
 */
static int
ospf_print_lsa(const struct lsa *lsap)
{
	const u_char *ls_end;
	const struct rlalink *rlp;
	const struct tos_metric *tosp;
	const struct in_addr *ap;
	const struct aslametric *almp;
	const struct mcla *mcp;
	const u_int32_t *lp;
	int j, k;

	if (ospf_print_lshdr(&lsap->ls_hdr))
		return (1);
	TCHECK(lsap->ls_hdr.ls_length);
	ls_end = (u_char *)lsap + ntohs(lsap->ls_hdr.ls_length);
	switch (lsap->ls_hdr.ls_type) {

	case LS_TYPE_ROUTER:
		TCHECK(lsap->lsa_un.un_rla.rla_flags);
		ospf_print_bits(ospf_rla_flag_bits,
		    lsap->lsa_un.un_rla.rla_flags);

		TCHECK(lsap->lsa_un.un_rla.rla_count);
		j = ntohs(lsap->lsa_un.un_rla.rla_count);
		TCHECK(lsap->lsa_un.un_rla.rla_link);
		rlp = lsap->lsa_un.un_rla.rla_link;
		while (j--) {
			TCHECK(*rlp);
			printf(" {");				/* } (ctags) */
			switch (rlp->link_type) {

			case RLA_TYPE_VIRTUAL:
				printf(" virt");
				/* FALLTHROUGH */

			case RLA_TYPE_ROUTER:
				printf(" nbrid %s if %s",
				    ipaddr_string(&rlp->link_id),
				    ipaddr_string(&rlp->link_data));
				break;

			case RLA_TYPE_TRANSIT:
				printf(" dr %s if %s",
				    ipaddr_string(&rlp->link_id),
				    ipaddr_string(&rlp->link_data));
				break;

			case RLA_TYPE_STUB:
				printf(" net %s mask %s",
				    ipaddr_string(&rlp->link_id),
				    ipaddr_string(&rlp->link_data));
				break;

			default:
								/* { (ctags) */
				printf(" ??RouterLinksType %d?? }",
				    rlp->link_type);
				return (0);
			}
			printf(" tos 0 metric %d", ntohs(rlp->link_tos0metric));
			tosp = (struct tos_metric *)
			    ((sizeof rlp->link_tos0metric) + (u_char *) rlp);
			for (k = 0; k < (int) rlp->link_toscount; ++k, ++tosp) {
				TCHECK(*tosp);
				printf(" tos %d metric %d",
				    tosp->tos_type,
				    ntohs(tosp->tos_metric));
			}
								/* { (ctags) */
			printf(" }");
			rlp = (struct rlalink *)((u_char *)(rlp + 1) +
			    ((rlp->link_toscount) * sizeof(*tosp)));
		}
		break;

	case LS_TYPE_NETWORK:
		TCHECK(lsap->lsa_un.un_nla.nla_mask);
		printf(" mask %s rtrs",
		    ipaddr_string(&lsap->lsa_un.un_nla.nla_mask));
		ap = lsap->lsa_un.un_nla.nla_router;
		while ((u_char *)ap < ls_end) {
			TCHECK(*ap);
			printf(" %s", ipaddr_string(ap));
			++ap;
		}
		break;

	case LS_TYPE_SUM_IP:
		TCHECK(lsap->lsa_un.un_nla.nla_mask);
		printf(" mask %s",
		    ipaddr_string(&lsap->lsa_un.un_sla.sla_mask));
		/* FALLTHROUGH */

	case LS_TYPE_SUM_ABR:
		TCHECK(lsap->lsa_un.un_sla.sla_tosmetric);
		lp = lsap->lsa_un.un_sla.sla_tosmetric;
		while ((u_char *)lp < ls_end) {
			u_int32_t ul;

			TCHECK(*lp);
			ul = ntohl(*lp);
			printf(" tos %d metric %d",
			    (ul & SLA_MASK_TOS) >> SLA_SHIFT_TOS,
			    ul & SLA_MASK_METRIC);
			++lp;
		}
		break;

	case LS_TYPE_ASE:
		TCHECK(lsap->lsa_un.un_nla.nla_mask);
		printf(" mask %s",
		    ipaddr_string(&lsap->lsa_un.un_asla.asla_mask));

		TCHECK(lsap->lsa_un.un_sla.sla_tosmetric);
		almp = lsap->lsa_un.un_asla.asla_metric;
		while ((u_char *)almp < ls_end) {
			u_int32_t ul;

			TCHECK(almp->asla_tosmetric);
			ul = ntohl(almp->asla_tosmetric);
			printf(" type %d tos %d metric %d",
			    (ul & ASLA_FLAG_EXTERNAL) ? 2 : 1,
			    (ul & ASLA_MASK_TOS) >> ASLA_SHIFT_TOS,
			    (ul & ASLA_MASK_METRIC));
			TCHECK(almp->asla_forward);
			if (almp->asla_forward.s_addr) {
				printf(" forward %s",
				    ipaddr_string(&almp->asla_forward));
			}
			TCHECK(almp->asla_tag);
			if (almp->asla_tag) {
				printf(" tag %u",
				    ntohl(almp->asla_tag));
			}
			++almp;
		}
		break;

	case LS_TYPE_GROUP:
		/* Multicast extensions as of 23 July 1991 */
		mcp = lsap->lsa_un.un_mcla;
		while ((u_char *)mcp < ls_end) {
			TCHECK(mcp->mcla_vid);
			switch (ntohl(mcp->mcla_vtype)) {

			case MCLA_VERTEX_ROUTER:
				printf(" rtr rtrid %s",
				    ipaddr_string(&mcp->mcla_vid));
				break;

			case MCLA_VERTEX_NETWORK:
				printf(" net dr %s",
				    ipaddr_string(&mcp->mcla_vid));
				break;

			default:
				printf(" ??VertexType %u??",
				    (u_int32_t)ntohl(mcp->mcla_vtype));
				break;
			}
		++mcp;
		}
	}

								/* { (ctags) */
	fputs(" }", stdout);
	return (0);
trunc:
	fputs(" }", stdout);
	return (1);
}

static int
ospf_decode_v2(const struct ospfhdr *op, const u_char *dataend)
{
	const struct in_addr *ap;
	const struct lsr *lsrp;
	const struct lsa_hdr *lshp;
	const struct lsa *lsap;
	char sep;
	int i;

	switch (op->ospf_type) {

	case OSPF_TYPE_UMD:
		/*
		 * Rob Coltun's special monitoring packets;
		 * do nothing
		 */
		break;

	case OSPF_TYPE_HELLO:
		if (vflag) {
			TCHECK(op->ospf_hello.hello_deadint);
			ospf_print_bits(ospf_option_bits,
			    op->ospf_hello.hello_options);
			printf(" mask %s int %d pri %d dead %u",
			    ipaddr_string(&op->ospf_hello.hello_mask),
			    ntohs(op->ospf_hello.hello_helloint),
			    op->ospf_hello.hello_priority,
			    (u_int32_t)ntohl(op->ospf_hello.hello_deadint));
		}
		TCHECK(op->ospf_hello.hello_dr);
		if (op->ospf_hello.hello_dr.s_addr != 0)
			printf(" dr %s",
			    ipaddr_string(&op->ospf_hello.hello_dr));
		TCHECK(op->ospf_hello.hello_bdr);
		if (op->ospf_hello.hello_bdr.s_addr != 0)
			printf(" bdr %s",
			    ipaddr_string(&op->ospf_hello.hello_bdr));
		if (vflag) {
			printf(" nbrs");
			ap = op->ospf_hello.hello_neighbor;
			while ((u_char *)ap < dataend) {
				TCHECK(*ap);
				printf(" %s", ipaddr_string(ap));
				++ap;
			}
		}
		break;	/* HELLO */

	case OSPF_TYPE_DB:
		TCHECK(op->ospf_db.db_options);
		ospf_print_bits(ospf_option_bits, op->ospf_db.db_options);
		sep = ' ';
		TCHECK(op->ospf_db.db_flags);
		if (op->ospf_db.db_flags & OSPF_DB_INIT) {
			printf("%cI", sep);
			sep = '/';
		}
		if (op->ospf_db.db_flags & OSPF_DB_MORE) {
			printf("%cM", sep);
			sep = '/';
		}
		if (op->ospf_db.db_flags & OSPF_DB_MASTER) {
			printf("%cMS", sep);
			sep = '/';
		}
		TCHECK(op->ospf_db.db_seq);
		printf(" mtu %u S %X", ntohs(op->ospf_db.db_mtu),
		    (u_int32_t)ntohl(op->ospf_db.db_seq));

		if (vflag) {
			/* Print all the LS adv's */
			lshp = op->ospf_db.db_lshdr;

			while (!ospf_print_lshdr(lshp)) {
							/* { (ctags) */
				printf(" }");
				++lshp;
			}
		}
		break;

	case OSPF_TYPE_LSR:
		if (vflag) {
			lsrp = op->ospf_lsr;
			while ((u_char *)lsrp < dataend) {
				TCHECK(*lsrp);
				printf(" {");		/* } (ctags) */
				ospf_print_ls_type(ntohl(lsrp->ls_type),
				    &lsrp->ls_stateid,
				    &lsrp->ls_router,
				    "LinkStateType %d");
							/* { (ctags) */
				printf(" }");
				++lsrp;
			}
		}
		break;

	case OSPF_TYPE_LSU:
		if (vflag) {
			lsap = op->ospf_lsu.lsu_lsa;
			TCHECK(op->ospf_lsu.lsu_count);
			i = ntohl(op->ospf_lsu.lsu_count);
			while (i--) {
				if (ospf_print_lsa(lsap))
					goto trunc;
				lsap = (struct lsa *)((u_char *)lsap +
				    ntohs(lsap->ls_hdr.ls_length));
			}
		}
		break;


	case OSPF_TYPE_LSA:
		if (vflag) {
			lshp = op->ospf_lsa.lsa_lshdr;

			while (!ospf_print_lshdr(lshp)) {
							/* { (ctags) */
				printf(" }");
				++lshp;
			}
		}
		break;

	default:
		printf("v2 type %d", op->ospf_type);
		break;
	}
	return (0);
trunc:
	return (1);
}

void
ospf_print(const u_char *bp, u_int length, const u_char *bp2)
{
	const struct ospfhdr *op;
	const struct ip *ip;
	const u_char *dataend;
	const char *cp;

	op = (struct ospfhdr *)bp;
	ip = (struct ip *)bp2;
	/* Print the source and destination address  */
	(void) printf("%s > %s:",
	    ipaddr_string(&ip->ip_src),
	    ipaddr_string(&ip->ip_dst));

        /* XXX Before we do anything else, strip off the MD5 trailer */
        TCHECK(op->ospf_authtype);
        if (ntohs(op->ospf_authtype) == OSPF_AUTH_MD5) {
                length -= OSPF_AUTH_MD5_LEN;
                snapend -= OSPF_AUTH_MD5_LEN;
        }

	/* If the type is valid translate it, or just print the type */
	/* value.  If it's not valid, say so and return */
	TCHECK(op->ospf_type);
	cp = tok2str(type2str, "type%d", op->ospf_type);
	printf(" OSPFv%d-%s ", op->ospf_version, cp);
	if (*cp == 't')
		return;

	TCHECK(op->ospf_len);
	if (length < ntohs(op->ospf_len)) {
		printf(" [len %d]", ntohs(op->ospf_len));
		return;
	} else if (length > ntohs(op->ospf_len)) {
		printf(" %d[%d]:", ntohs(op->ospf_len), length);
		length = ntohs(op->ospf_len);
	} else
		printf(" %d:", length);
	dataend = bp + length;

	TCHECK(op->ospf_routerid);
	printf(" rtrid %s", ipaddr_string(&op->ospf_routerid));

	TCHECK(op->ospf_areaid);
	if (op->ospf_areaid.s_addr != 0)
		printf(" area %s", ipaddr_string(&op->ospf_areaid));
	else
		printf(" backbone");

	if (vflag) {
		/* Print authentication data (should we really do this?) */
		TCHECK2(op->ospf_authdata[0], sizeof(op->ospf_authdata));
		switch (ntohs(op->ospf_authtype)) {

		case OSPF_AUTH_NONE:
			break;

		case OSPF_AUTH_SIMPLE:
			printf(" auth \"");
			(void)fn_printn(op->ospf_authdata,
			    sizeof(op->ospf_authdata), NULL);
			printf("\"");
			break;

		case OSPF_AUTH_MD5:
			printf(" auth MD5");
			break;

		default:
			printf(" ??authtype-%d??", ntohs(op->ospf_authtype));
			return;
		}
	}
	/* Do rest according to version.	 */
	switch (op->ospf_version) {

	case 2:
		/* ospf version 2 */
		if (ospf_decode_v2(op, dataend))
			goto trunc;
		break;

	default:
		printf(" ospf [version %d]", op->ospf_version);
		break;
	}			/* end switch on version */

	return;
trunc:
	fputs(tstr, stdout);
}
@


1.19
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.18 2014/08/14 12:44:44 mpi Exp $	*/
d83 1
a83 1
ospf_print_seqage(register u_int32_t seq, register time_t us)
d85 3
a87 3
	register time_t sec = us % 60;
	register time_t mins = (us / 60) % 60;
	register time_t hour = us / 3600;
d101 1
a101 1
ospf_print_bits(register const struct bits *bp, register u_char options)
d103 1
a103 1
	register char sep = ' ';
d114 2
a115 3
ospf_print_ls_type(register u_int ls_type,
    register const struct in_addr *ls_stateid,
    register const struct in_addr *ls_router, register const char *fmt)
d162 1
a162 1
ospf_print_lshdr(register const struct lsa_hdr *lshp)
d185 1
a185 1
ospf_print_lsa(register const struct lsa *lsap)
d187 8
a194 8
	register const u_char *ls_end;
	register const struct rlalink *rlp;
	register const struct tos_metric *tosp;
	register const struct in_addr *ap;
	register const struct aslametric *almp;
	register const struct mcla *mcp;
	register const u_int32_t *lp;
	register int j, k;
d282 1
a282 1
			register u_int32_t ul;
d301 1
a301 1
			register u_int32_t ul;
d358 1
a358 2
ospf_decode_v2(register const struct ospfhdr *op,
    register const u_char *dataend)
d360 6
a365 6
	register const struct in_addr *ap;
	register const struct lsr *lsrp;
	register const struct lsa_hdr *lshp;
	register const struct lsa *lsap;
	register char sep;
	register int i;
d493 1
a493 2
ospf_print(register const u_char *bp, register u_int length,
    register const u_char *bp2)
d495 4
a498 4
	register const struct ospfhdr *op;
	register const struct ip *ip;
	register const u_char *dataend;
	register const char *cp;
@


1.18
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.17 2014/07/04 08:42:38 bluhm Exp $	*/
a25 1
#include <sys/param.h>
@


1.17
log
@Tcpdump did not show the OSPF router id of hello packets if it was
equal to the source ip address.  This is confusing and inconsistent
with IPv6.  So always print the rtrid.
OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.16 2011/03/22 17:31:18 claudio Exp $	*/
a30 1
#include <netinet/in_systm.h>
@


1.16
log
@Don't be to strict when checking the length of an ospf packet.
Allow for padding bytes in the IP packet (length > ntohs(op->ospf_len))
but report both length in that case.
OK sthen@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.15 2010/08/04 16:47:01 sthen Exp $	*/
a537 1
	/* Print the routerid if it is not the same as the source */
d539 1
a539 2
	if (ip->ip_src.s_addr != op->ospf_routerid.s_addr)
		printf(" rtrid %s", ipaddr_string(&op->ospf_routerid));
@


1.15
log
@Print the MTU in OSPF dd packets. Borrowed from the ospf6 printer.
ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.14 2009/10/27 23:59:55 deraadt Exp $	*/
d523 1
a523 1
	printf(" OSPFv%d-%s %d:", op->ospf_version, cp, length);
d528 1
a528 1
	if (length != ntohs(op->ospf_len)) {
d531 5
a535 1
	}
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.13 2007/10/07 16:41:05 deraadt Exp $	*/
d428 2
a429 1
		printf(" S %X", (u_int32_t)ntohl(op->ospf_db.db_seq));
@


1.13
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.12 2007/06/14 03:23:49 reyk Exp $	*/
a24 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.12
log
@The External Route Tag for AS-External-LSAs can be an arbitrary 32bit
value and doesn't need to be an IPv4 address. It is more like a
vendor-specific field.

as discussed with claudio after looking into rfc2328
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.11 2006/04/21 23:09:34 cloder Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ospf.c,v 1.11 2006/04/21 23:09:34 cloder Exp $ (LBL)";
@


1.11
log
@Add comments to please lint. No code changes. OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.10 2005/12/17 17:24:30 stevesk Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ospf.c,v 1.10 2005/12/17 17:24:30 stevesk Exp $ (LBL)";
d323 3
a325 3
			if (almp->asla_tag.s_addr) {
				printf(" tag %s",
				    ipaddr_string(&almp->asla_tag));
@


1.10
log
@remove extra space in output of router LSA; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.9 2003/07/08 10:58:27 markus Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ospf.c,v 1.9 2003/07/08 10:58:27 markus Exp $ (LBL)";
d226 1
a226 1
				/* Fall through */
d284 1
a284 1
		/* Fall through */
@


1.9
log
@print ip_{src,dst} again; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ospf.c,v 1.8 2000/10/03 14:31:58 ho Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ospf.c,v 1.8 2000/10/03 14:31:58 ho Exp $ (LBL)";
d129 1
a129 1
		printf(" rtr %s ", ipaddr_string(ls_router));
@


1.8
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ospf.c,v 1.7 2000/04/26 21:35:42 jakob Exp $ (LBL)";
a511 1
#if 0
a514 1
#endif
@


1.7
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ospf.c,v 1.6 1999/07/28 20:41:36 jakob Exp $ (LBL)";
@


1.6
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ospf.c,v 1.5 1996/12/12 16:22:30 bitblt Exp $ (LBL)";
d510 1
d514 1
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
d26 1
a26 1
    "@@(#) $Header: print-ospf.c,v 1.23 96/12/10 23:15:46 leres Exp $ (LBL)";
d218 1
a218 5
			register struct rlalink *rln =
			    (struct rlalink *)((u_char *)(rlp + 1) +
			    ((rlp->link_toscount) * sizeof(*tosp)));

			TCHECK(*rln);
d261 2
a262 1
			rlp = rln;
d514 7
d560 4
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d25 2
a26 2
static char rcsid[] =
    "@@(#) Header: print-ospf.c,v 1.18 96/06/15 13:19:49 leres Exp (LBL)";
d47 2
a48 2
    u_int32_t bit;
    const char *str;
d66 8
a73 7
static const char *ospf_types[OSPF_TYPE_MAX] = {
  (char *) 0,
  "hello",
  "dd",
  "ls_req",
  "ls_upd",
  "ls_ack"
d76 11
d90 12
a101 18
    register time_t sec = us % 60;
    register time_t mins = (us / 60) % 60;
    register time_t hour = us/3600;

    printf(" S %X age ", seq);
    if (hour) {
	printf("%u:%02u:%02u",
	       (u_int32_t)hour,
	       (u_int32_t)mins,
	       (u_int32_t)sec);
    } else if (mins) {
	printf("%u:%02u",
	       (u_int32_t)mins,
	       (u_int32_t)sec);
    } else {
	printf("%u",
	       (u_int32_t)sec);
    }
d108 1
a108 1
    char sep = ' ';
d110 6
a115 8
    do {
	if (options & bp->bit) {
	    printf("%c%s",
		   sep,
		   bp->str);
	    sep = '/';
	}
    } while ((++bp)->bit) ;
d118 11
d130 5
a134 14
#define	LS_PRINT(lsp, type) switch (type) { \
    case LS_TYPE_ROUTER: \
	printf(" rtr %s ", ipaddr_string(&lsp->ls_router)); break; \
    case LS_TYPE_NETWORK: \
	printf(" net dr %s if %s", ipaddr_string(&lsp->ls_router), ipaddr_string(&lsp->ls_stateid)); break; \
    case LS_TYPE_SUM_IP: \
	printf(" sum %s abr %s", ipaddr_string(&lsp->ls_stateid), ipaddr_string(&lsp->ls_router)); break; \
    case LS_TYPE_SUM_ABR: \
	printf(" abr %s rtr %s", ipaddr_string(&lsp->ls_router), ipaddr_string(&lsp->ls_stateid)); break; \
    case LS_TYPE_ASE: \
	printf(" ase %s asbr %s", ipaddr_string(&lsp->ls_stateid), ipaddr_string(&lsp->ls_router)); break; \
    case LS_TYPE_GROUP: \
	printf(" group %s rtr %s", ipaddr_string(&lsp->ls_stateid), ipaddr_string(&lsp->ls_router)); break; \
    }
d136 11
a146 6
static int
ospf_print_lshdr(register const struct lsa_hdr *lshp, const caddr_t end)
{
    if ((caddr_t) (lshp + 1) > end) {
	return 1;
    }
d148 5
a152 1
    printf(" {");						/* } (ctags) */
d154 12
a165 4
    if (!lshp->ls_type || lshp->ls_type >= LS_TYPE_MAX) {
	printf(" ??LS type %d?? }", lshp->ls_type);		/* { (ctags) */
	return 1;
    }
d167 3
a169 2
    ospf_print_bits(ospf_option_bits, lshp->ls_options);
    ospf_print_seqage(ntohl(lshp->ls_seq), ntohs(lshp->ls_age));
d171 2
a172 1
    LS_PRINT(lshp, lshp->ls_type);
d174 10
a183 1
    return 0;
a189 1

d191 1
a191 1
ospf_print_lsa(register const struct lsa *lsap, const caddr_t end)
d193 75
a267 38
    register const char *ls_end;
    const struct rlalink *rlp;
    const struct tos_metric *tosp;
    const struct in_addr *ap;
    const struct aslametric *almp;
    const struct mcla *mcp;
    const u_int32_t *lp;
    int j, k;

    if (ospf_print_lshdr(&lsap->ls_hdr, end)) {
	return 1;
    }

    ls_end = (caddr_t) lsap + ntohs(lsap->ls_hdr.ls_length);

    if (ls_end > end) {
	printf(" }");						/* { (ctags) */
	return 1;
    }

    switch (lsap->ls_hdr.ls_type) {
    case LS_TYPE_ROUTER:
	ospf_print_bits(ospf_rla_flag_bits, lsap->lsa_un.un_rla.rla_flags);

	j = ntohs(lsap->lsa_un.un_rla.rla_count);
	rlp = lsap->lsa_un.un_rla.rla_link;
	while (j--) {
	    struct rlalink *rln = (struct rlalink *) ((caddr_t) (rlp + 1) + ((rlp->link_toscount) * sizeof (struct tos_metric)));

	    if ((caddr_t) rln > ls_end) {
		break;
	    }
	    printf(" {");					/* } (ctags) */

	    switch (rlp->link_type) {
	    case RLA_TYPE_VIRTUAL:
		printf(" virt");
		/* Fall through */
d269 11
a279 35
	    case RLA_TYPE_ROUTER:
		printf(" nbrid %s if %s",
		       ipaddr_string(&rlp->link_id),
		       ipaddr_string(&rlp->link_data));
		break;

	    case RLA_TYPE_TRANSIT:
		printf(" dr %s if %s",
		       ipaddr_string(&rlp->link_id),
		       ipaddr_string(&rlp->link_data));
		break;

	    case RLA_TYPE_STUB:
		printf(" net %s mask %s",
		       ipaddr_string(&rlp->link_id),
		       ipaddr_string(&rlp->link_data));
		break;

	    default:
		printf(" ??RouterLinksType %d?? }",		/* { (ctags) */
		       rlp->link_type);
		return 0;
	    }
	    printf(" tos 0 metric %d",
		   ntohs(rlp->link_tos0metric));
	    tosp = (struct tos_metric *) ((sizeof rlp->link_tos0metric) + (caddr_t) rlp);
	    for (k = 0; k < rlp->link_toscount; k++, tosp++) {
		printf(" tos %d metric %d",
		       tosp->tos_type,
		       ntohs(tosp->tos_metric));
	    }
	    printf(" }");					/* { (ctags) */
	    rlp = rln;
	}
	break;
d281 5
a285 10
    case LS_TYPE_NETWORK:
	printf(" mask %s rtrs",
	       ipaddr_string(&lsap->lsa_un.un_nla.nla_mask));
	for (ap = lsap->lsa_un.un_nla.nla_router;
	     (caddr_t) (ap + 1) <= ls_end;
	     ap++) {
	    printf(" %s",
		   ipaddr_string(ap));
	}
	break;
d287 13
a299 51
    case LS_TYPE_SUM_IP:
	printf(" mask %s",
	       ipaddr_string(&lsap->lsa_un.un_sla.sla_mask));
	/* Fall through */

    case LS_TYPE_SUM_ABR:

	for (lp = lsap->lsa_un.un_sla.sla_tosmetric;
	     (caddr_t) (lp + 1) <= ls_end;
	     lp++) {
	    u_int32_t ul = ntohl(*lp);

	    printf(" tos %d metric %d",
		   (ul & SLA_MASK_TOS) >> SLA_SHIFT_TOS,
		   ul & SLA_MASK_METRIC);
	}
	break;

    case LS_TYPE_ASE:
	printf(" mask %s",
	       ipaddr_string(&lsap->lsa_un.un_asla.asla_mask));

	for (almp = lsap->lsa_un.un_asla.asla_metric;
	     (caddr_t) (almp + 1) <= ls_end;
	     almp++) {
	    u_int32_t ul = ntohl(almp->asla_tosmetric);

	    printf(" type %d tos %d metric %d",
		   (ul & ASLA_FLAG_EXTERNAL) ? 2 : 1,
		   (ul & ASLA_MASK_TOS) >> ASLA_SHIFT_TOS,
		   (ul & ASLA_MASK_METRIC));
	    if (almp->asla_forward.s_addr) {
		printf(" forward %s",
		       ipaddr_string(&almp->asla_forward));
	    }
	    if (almp->asla_tag.s_addr) {
		printf(" tag %s",
		       ipaddr_string(&almp->asla_tag));
	    }
	}
	break;

    case LS_TYPE_GROUP:
	/* Multicast extensions as of 23 July 1991 */
	for (mcp = lsap->lsa_un.un_mcla;
	     (caddr_t) (mcp + 1) <= ls_end;
	     mcp++) {
	    switch (ntohl(mcp->mcla_vtype)) {
	    case MCLA_VERTEX_ROUTER:
		printf(" rtr rtrid %s",
		       ipaddr_string(&mcp->mcla_vid));
d302 28
a329 3
	    case MCLA_VERTEX_NETWORK:
		printf(" net dr %s",
		       ipaddr_string(&mcp->mcla_vid));
d332 24
a355 5
	    default:
		printf(" ??VertexType %u??",
		       (u_int32_t)ntohl(mcp->mcla_vtype));
		break;
	    }
a356 1
    }
d358 6
a363 2
    printf(" }");						/* { (ctags) */
    return 0;
d366 3
a368 4

void
ospf_print(register const u_char *bp, register int length,
	   register const u_char *bp2)
d370 6
a375 35
    register const struct ospfhdr *op;
    register const struct ip *ip;
    register const caddr_t end = (caddr_t)snapend;
    register const struct lsa *lsap;
    register const struct lsa_hdr *lshp;
    char sep;
    int i, j;
    const struct in_addr *ap;
    const struct lsr *lsrp;

    op = (struct ospfhdr *)bp;
    ip = (struct ip  *)bp2;
    /* Print the source and destination address	*/
    (void) printf("%s > %s:",
		  ipaddr_string(&ip->ip_src),
		  ipaddr_string(&ip->ip_dst));

    if ((caddr_t) (&op->ospf_len + 1) > end) {
	goto trunc_test;
    }

    /* If the type is valid translate it, or just print the type */
    /* value.  If it's not valid, say so and return */
    if (op->ospf_type || op->ospf_type < OSPF_TYPE_MAX) {
	printf(" OSPFv%d-%s %d:",
	       op->ospf_version,
	       ospf_types[op->ospf_type],
	       length);
    } else {
	printf(" ospf-v%d-??type %d?? %d:",
	       op->ospf_version,
	       op->ospf_type,
	       length);
	return;
    }
d377 1
a377 57
    if (length != ntohs(op->ospf_len)) {
	printf(" ??len %d??",
	       ntohs(op->ospf_len));
	goto trunc_test;
    }

    if ((caddr_t) (&op->ospf_routerid + 1) > end) {
	goto trunc_test;
    }

    /* Print the routerid if it is not the same as the source */
    if (ip->ip_src.s_addr != op->ospf_routerid.s_addr) {
	printf(" rtrid %s",
	       ipaddr_string(&op->ospf_routerid));
    }

    if ((caddr_t) (&op->ospf_areaid + 1) > end) {
	goto trunc_test;
    }

    if (op->ospf_areaid.s_addr) {
	printf(" area %s",
	       ipaddr_string(&op->ospf_areaid));
    } else {
	printf(" backbone");
    }

    if ((caddr_t) (op->ospf_authdata + OSPF_AUTH_SIZE) > end) {
	goto trunc_test;
    }

    if (vflag) {
	/* Print authentication data (should we really do this?) */
	switch (ntohs(op->ospf_authtype)) {
	case OSPF_AUTH_NONE:
	    break;

	case OSPF_AUTH_SIMPLE:
	    printf(" auth ");
	    j = 0;
	    for (i = 0; i < sizeof (op->ospf_authdata); i++) {
		if (!isprint(op->ospf_authdata[i])) {
		    j = 1;
		    break;
		}
	    }
	    if (j) {
		/* Print the auth-data as a string of octets */
		printf("%s.%s",
		       ipaddr_string((struct in_addr *) op->ospf_authdata),
		       ipaddr_string((struct in_addr *) &op->ospf_authdata[sizeof (struct in_addr)]));
	    } else {
		/* Print the auth-data as a text string */
		printf("'%.8s'",
		       op->ospf_authdata);
	    }
	    break;
d379 6
a384 6
	default:
	    printf(" ??authtype-%d??",
		   ntohs(op->ospf_authtype));
	    return;
	}
    }
d386 29
d416 19
a434 7
    /* Do rest according to version.	*/
    switch (op->ospf_version) {
    case 2:
        /* ospf version 2	*/
	switch (op->ospf_type) {
	case OSPF_TYPE_UMD:		/* Rob Coltun's special monitoring packets; do nothing	*/
	    break;
d436 10
a445 2
	case OSPF_TYPE_HELLO:
	    if ((caddr_t) (&op->ospf_hello.hello_deadint + 1) > end) {
d447 15
a461 36
	    }
	    if (vflag) {
		ospf_print_bits(ospf_option_bits, op->ospf_hello.hello_options);
		printf(" mask %s int %d pri %d dead %u",
		       ipaddr_string(&op->ospf_hello.hello_mask),
		       ntohs(op->ospf_hello.hello_helloint),
		       op->ospf_hello.hello_priority,
		       (u_int32_t)ntohl(op->ospf_hello.hello_deadint));
	    }

	    if ((caddr_t) (&op->ospf_hello.hello_dr + 1) > end) {
		break;
	    }
	    if (op->ospf_hello.hello_dr.s_addr) {
		printf(" dr %s",
		       ipaddr_string(&op->ospf_hello.hello_dr));
	    }

	    if ((caddr_t) (&op->ospf_hello.hello_bdr + 1) > end) {
		break;
	    }
	    if (op->ospf_hello.hello_bdr.s_addr) {
		printf(" bdr %s",
		       ipaddr_string(&op->ospf_hello.hello_bdr));
	    }

	    if (vflag) {
		if ((caddr_t) (op->ospf_hello.hello_neighbor + 1) > end) {
		    break;
		}
		printf(" nbrs");
		for (ap = op->ospf_hello.hello_neighbor;
		     (caddr_t) (ap + 1) <= end;
		     ap++) {
		    printf(" %s",
			   ipaddr_string(ap));
d463 1
a463 2
	    }
	    break;			/*  HELLO	*/
d465 12
a476 2
	case OSPF_TYPE_DB:
	    if ((caddr_t) (&op->ospf_db.db_seq + 1) > end) {
d478 11
a488 27
	    }
	    ospf_print_bits(ospf_option_bits, op->ospf_db.db_options);
	    sep = ' ';
	    if (op->ospf_db.db_flags & OSPF_DB_INIT) {
		printf("%cI",
		       sep);
		sep = '/';
	    }
	    if (op->ospf_db.db_flags & OSPF_DB_MORE) {
		printf("%cM",
		       sep);
		sep = '/';
	    }
	    if (op->ospf_db.db_flags & OSPF_DB_MASTER) {
		printf("%cMS",
		       sep);
		sep = '/';
	    }
	    printf(" S %X", (u_int32_t)ntohl(op->ospf_db.db_seq));

	    if (vflag) {
		/* Print all the LS adv's */
		lshp = op->ospf_db.db_lshdr;

		while (!ospf_print_lshdr(lshp, end)) {
		    printf(" }");				/* { (ctags) */
		    lshp++;
d490 41
a530 2
	    }
	    break;
d532 15
a546 4
	case OSPF_TYPE_LSR:
	    if (vflag) {
		for (lsrp = op->ospf_lsr; (caddr_t) (lsrp+1) <= end; lsrp++) {
		    int32_t type;
d548 1
a548 1
		    if ((caddr_t) (lsrp + 1) > end) {
a549 1
		    }
d551 5
a555 4
		    printf(" {");				/* } (ctags) */
		    if (!(type = ntohl(lsrp->ls_type)) || type >= LS_TYPE_MAX) {
			printf(" ??LinkStateType %d }", type);	/* { (ctags) */
			printf(" }");				/* { (ctags) */
a556 1
		    }
d558 3
a560 2
		    LS_PRINT(lsrp, type);
		    printf(" }");				/* { (ctags) */
d562 3
a564 2
	    }
	    break;
d566 5
a570 11
	case OSPF_TYPE_LSU:
	    if (vflag) {
		lsap = op->ospf_lsu.lsu_lsa;
		i = ntohl(op->ospf_lsu.lsu_count);

		while (i-- &&
		       !ospf_print_lsa(lsap, end)) {
		    lsap = (struct lsa *) ((caddr_t) lsap + ntohs(lsap->ls_hdr.ls_length));
		}
	    }
	    break;
d572 4
d577 3
a579 25
	case OSPF_TYPE_LSA:
	    if (vflag) {
		lshp = op->ospf_lsa.lsa_lshdr;

		while (!ospf_print_lshdr(lshp, end)) {
		    printf(" }");				/* { (ctags) */
		    lshp++;
		}
		break;
	    }
	}			/* end switch on v2 packet type	*/
	break;

    default:
	printf(" ospf [version %d]",
	       op->ospf_version);
	break;
    }					/* end switch on version	*/

  trunc_test:
    if ((snapend - bp) < length) {
	printf(" [|]");
    }

    return;				/* from ospf_print	*/
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-ospf.c,v 1.3 1995/03/06 19:11:25 mycroft Exp $	*/
/*	$NetBSD: print-ospf.c,v 1.3 1995/03/06 19:11:25 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1992, 1993, 1994
d28 1
a28 1
    "@@(#) Header: print-ospf.c,v 1.12 94/06/14 20:18:46 leres Exp (LBL)";
a39 1
#include <errno.h>
a47 4
#ifndef	__GNUC__
#define	inline
#endif

d49 1
a49 1
    u_int32 bit;
d78 1
a78 1
ospf_print_seqage(register u_int32 seq, register time_t us)
d84 1
a84 2
    printf(" S %X age ",
	   seq);
d86 4
a89 4
	printf("%d:%02d:%02d",
	       hour,
	       mins,
	       sec);
d91 3
a93 3
	printf("%d:%02d",
	       mins,
	       sec);
d95 2
a96 2
	printf("%d",
	       sec);
d142 1
a142 2
	printf(" ??LS type %d?? }",				/* { (ctags) */
	       lshp->ls_type);
d147 1
a147 2
    ospf_print_seqage(ntohl(lshp->ls_seq),
			  ntohs(lshp->ls_age));
d168 1
a168 1
    const u_int32 *lp;
d229 1
a229 1
		       ntohs(tosp->tos_type),
d258 1
a258 1
	    u_int32 ul = ntohl(*lp);
d273 1
a273 1
	    u_int32 ul = ntohl(almp->asla_tosmetric);
d307 2
a308 2
		printf(" ??VertexType %d??",
		       ntohl(mcp->mcla_vtype));
d439 1
a439 1
		printf(" mask %s int %d pri %d dead %d",
d443 1
a443 1
		       ntohl(op->ospf_hello.hello_deadint));
d497 1
a497 2
	    printf(" S %X",
		   ntohl(op->ospf_db.db_seq));
d513 1
a513 1
		    int32 type;
d520 2
a521 3
		    if (!(type = lsrp->ls_type) || type >= LS_TYPE_MAX) {
			printf(" ??LinkStateType %d }",		/* { (ctags) */
			       type);
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
