head	1.22;
access;
symbols
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.8
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.6
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.16
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.14
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.12
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.10
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.6
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.12.22.21.01.07;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	2fFDLAOGZEyS0nuD;

1.21
date	2015.11.18.15.36.20;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	vQk1DzJRhR5UcrJ1;

1.20
date	2015.11.15.20.35.36;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	kFQYMPTA5NvE3RXS;

1.19
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	Uu5nFG3wCl0LACBb;

1.18
date	2013.10.27.18.49.25;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.01.08.21.29.35;	author stevesk;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.21.11.17.20;	author canacar;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.17.23.33.50;	author stevesk;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.03.14.31.56;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.26.21.35.39;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	99.09.16.20.58.46;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	98.07.08.22.32.03;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.20.12.22;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.41;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.16;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.31;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.18;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@assign pointers to NULL rather than 0
@
text
@/*	$OpenBSD: print-bootp.c,v 1.21 2015/11/18 15:36:20 mmcc Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Format and print bootp packets.
 */
#include <sys/time.h>
#include <sys/socket.h>

struct mbuf;
struct rtentry;
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#include "interface.h"
#include "addrtoname.h"
#include "bootp.h"

static void rfc1048_print(const u_char *, u_int);
static void cmu_print(const u_char *, u_int);

static char tstr[] = " [|bootp]";

/*
 * Print bootp requests
 */
void
bootp_print(const u_char *cp, u_int length,
	    u_short sport, u_short dport)
{
	const struct bootp *bp;
	static u_char vm_cmu[4] = VM_CMU;
	static u_char vm_rfc1048[4] = VM_RFC1048;

	bp = (struct bootp *)cp;
	TCHECK(bp->bp_op);
	switch (bp->bp_op) {

	case BOOTREQUEST:
		/* Usually, a request goes from a client to a server */
		if (sport != IPPORT_BOOTPC || dport != IPPORT_BOOTPS)
			printf(" (request)");
		break;

	case BOOTREPLY:
		/* Usually, a reply goes from a server to a client */
		if (sport != IPPORT_BOOTPS || dport != IPPORT_BOOTPC)
			printf(" (reply)");
		break;

	default:
		printf(" bootp-#%d", bp->bp_op);
	}

	TCHECK(bp->bp_flags);

	/* The usual hardware address type is 1 (10Mb Ethernet) */
	if (bp->bp_htype != 1)
		printf(" htype-#%d", bp->bp_htype);

	/* The usual length for 10Mb Ethernet address is 6 bytes */
	if (bp->bp_htype != 1 || bp->bp_hlen != 6)
		printf(" hlen:%d", bp->bp_hlen);

	/* Only print interesting fields */
	if (bp->bp_hops)
		printf(" hops:%d", bp->bp_hops);
	if (bp->bp_xid)
		printf(" xid:0x%x", (u_int32_t)ntohl(bp->bp_xid));
	if (bp->bp_secs)
		printf(" secs:%d", ntohs(bp->bp_secs));
	if (bp->bp_flags)
		printf(" flags:0x%x", ntohs(bp->bp_flags));

	/* Client's ip address */
	TCHECK(bp->bp_ciaddr);
	if (bp->bp_ciaddr.s_addr)
		printf(" C:%s", ipaddr_string(&bp->bp_ciaddr));

	/* 'your' ip address (bootp client) */
	TCHECK(bp->bp_yiaddr);
	if (bp->bp_yiaddr.s_addr)
		printf(" Y:%s", ipaddr_string(&bp->bp_yiaddr));

	/* Server's ip address */
	TCHECK(bp->bp_siaddr);
	if (bp->bp_siaddr.s_addr)
		printf(" S:%s", ipaddr_string(&bp->bp_siaddr));

	/* Gateway's ip address */
	TCHECK(bp->bp_giaddr);
	if (bp->bp_giaddr.s_addr)
		printf(" G:%s", ipaddr_string(&bp->bp_giaddr));

	/* Client's Ethernet address */
	if (bp->bp_htype == 1 && bp->bp_hlen == 6) {
		const struct ether_header *eh;
		const char *e;

		TCHECK2(bp->bp_chaddr[0], 6);
		eh = (struct ether_header *)packetp;
		if (bp->bp_op == BOOTREQUEST)
			e = (const char *)ESRC(eh);
		else if (bp->bp_op == BOOTREPLY)
			e = (const char *)EDST(eh);
		else
			e = NULL;
		if (e == 0 || memcmp((char *)bp->bp_chaddr, e, 6) != 0)
			printf(" ether %s", etheraddr_string(bp->bp_chaddr));
	}

	TCHECK2(bp->bp_sname[0], 1);		/* check first char only */
	if (*bp->bp_sname) {
		printf(" sname \"");
		if (fn_print(bp->bp_sname, snapend)) {
			putchar('"');
			fputs(tstr + 1, stdout);
			return;
		}
		putchar('"');
	}
	TCHECK2(bp->bp_file[0], 1);		/* check first char only */
	if (*bp->bp_file) {
		printf(" file \"");
		if (fn_print(bp->bp_file, snapend)) {
			putchar('"');
			fputs(tstr + 1, stdout);
			return;
		}
		putchar('"');
	}

	/* Decode the vendor buffer */
	TCHECK2(bp->bp_vend[0], sizeof(u_int32_t));
	length -= sizeof(*bp) - sizeof(bp->bp_vend);
	if (memcmp((char *)bp->bp_vend, (char *)vm_rfc1048,
		 sizeof(u_int32_t)) == 0)
		rfc1048_print(bp->bp_vend, length);
	else if (memcmp((char *)bp->bp_vend, (char *)vm_cmu,
		      sizeof(u_int32_t)) == 0)
		cmu_print(bp->bp_vend, length);
	else {
		u_int32_t ul;

		memcpy((char *)&ul, (char *)bp->bp_vend, sizeof(ul));
		if (ul != 0)
			printf("vend-#0x%x", ul);
	}

	return;
trunc:
	fputs(tstr, stdout);
}

/* The first character specifies the format to print */
static struct tok tag2str[] = {
/* RFC1048 tags */
	{ TAG_PAD,		" PAD" },
	{ TAG_SUBNET_MASK,	"iSM" },	/* subnet mask (RFC950) */
	{ TAG_TIME_OFFSET,	"lTZ" },	/* seconds from UTC */
	{ TAG_GATEWAY,		"iDG" },	/* default gateway */
	{ TAG_TIME_SERVER,	"iTS" },	/* time servers (RFC868) */
	{ TAG_NAME_SERVER,	"iIEN" },	/* IEN name servers (IEN116) */
	{ TAG_DOMAIN_SERVER,	"iNS" },	/* domain name (RFC1035) */
	{ TAG_LOG_SERVER,	"iLOG" },	/* MIT log servers */
	{ TAG_COOKIE_SERVER,	"iCS" },	/* cookie servers (RFC865) */
	{ TAG_LPR_SERVER,	"iLPR" },	/* lpr server (RFC1179) */
	{ TAG_IMPRESS_SERVER,	"iIM" },	/* impress servers (Imagen) */
	{ TAG_RLP_SERVER,	"iRL" },	/* resource location (RFC887) */
	{ TAG_HOSTNAME,		"aHN" },	/* ascii hostname */
	{ TAG_BOOTSIZE,		"sBS" },	/* 512 byte blocks */
	{ TAG_END,		" END" },
/* RFC1497 tags */
	{ TAG_DUMPPATH,		"aDP" },
	{ TAG_DOMAINNAME,	"aDN" },
	{ TAG_SWAP_SERVER,	"iSS" },
	{ TAG_ROOTPATH,		"aRP" },
	{ TAG_EXTPATH,		"aEP" },
/* RFC2132 tags */
	{ TAG_IP_FORWARD,	"BIPF" },
	{ TAG_NL_SRCRT,		"BSRT" },
	{ TAG_PFILTERS,		"pPF" },
	{ TAG_REASS_SIZE,	"sRSZ" },
	{ TAG_DEF_TTL,		"bTTL" },
	{ TAG_MTU_TIMEOUT,	"lMA" },
	{ TAG_MTU_TABLE,	"sMT" },
	{ TAG_INT_MTU,		"sMTU" },
	{ TAG_LOCAL_SUBNETS,	"BLSN" },
	{ TAG_BROAD_ADDR,	"iBR" },
	{ TAG_DO_MASK_DISC,	"BMD" },
	{ TAG_SUPPLY_MASK,	"BMS" },
	{ TAG_DO_RDISC,		"BRD" },
	{ TAG_RTR_SOL_ADDR,	"iRSA" },
	{ TAG_STATIC_ROUTE,	"pSR" },
	{ TAG_USE_TRAILERS,	"BUT" },
	{ TAG_ARP_TIMEOUT,	"lAT" },
	{ TAG_ETH_ENCAP,	"BIE" },
	{ TAG_TCP_TTL,		"bTT" },
	{ TAG_TCP_KEEPALIVE,	"lKI" },
	{ TAG_KEEPALIVE_GO,	"BKG" },
	{ TAG_NIS_DOMAIN,	"aYD" },
	{ TAG_NIS_SERVERS,	"iYS" },
	{ TAG_NTP_SERVERS,	"iNTP" },
	{ TAG_VENDOR_OPTS,	"bVO" },
	{ TAG_NETBIOS_NS,	"iWNS" },
	{ TAG_NETBIOS_DDS,	"iWDD" },
	{ TAG_NETBIOS_NODE,	"bWNT" },
	{ TAG_NETBIOS_SCOPE,	"aWSC" },
	{ TAG_XWIN_FS,		"iXFS" },
	{ TAG_XWIN_DM,		"iXDM" },
	{ TAG_NIS_P_DOMAIN,	"sN+D" },
	{ TAG_NIS_P_SERVERS,	"iN+S" },
	{ TAG_MOBILE_HOME,	"iMH" },
	{ TAG_SMPT_SERVER,	"iSMTP" },
	{ TAG_POP3_SERVER,	"iPOP3" },
	{ TAG_NNTP_SERVER,	"iNNTP" },
	{ TAG_WWW_SERVER,	"iWWW" },
	{ TAG_FINGER_SERVER,	"iFG" },
	{ TAG_IRC_SERVER,	"iIRC" },
	{ TAG_STREETTALK_SRVR,	"iSTS" },
	{ TAG_STREETTALK_STDA,	"iSTDA" },
	{ TAG_REQUESTED_IP,	"iRQ" },
	{ TAG_IP_LEASE,		"lLT" },
	{ TAG_OPT_OVERLOAD,	"bOO" },
	{ TAG_TFTP_SERVER,	"aTFTP" },
	{ TAG_BOOTFILENAME,	"aBF" },
	{ TAG_DHCP_MESSAGE,	" DHCP" },
	{ TAG_SERVER_ID,	"iSID" },
	{ TAG_PARM_REQUEST,	"bPR" },
	{ TAG_MESSAGE,		"aMSG" },
	{ TAG_MAX_MSG_SIZE,	"sMSZ" },
	{ TAG_RENEWAL_TIME,	"lRN" },
	{ TAG_REBIND_TIME,	"lRB" },
	{ TAG_VENDOR_CLASS,	"bVC" },
	{ TAG_CLIENT_ID,	"bCID" },
	{ 0,			NULL }
};

static void
rfc1048_print(const u_char *bp, u_int length)
{
	u_char tag;
	u_int len, size;
	const char *cp;
	u_char c;
	int first;
	u_int32_t ul;
	u_short us;

	printf(" vend-rfc1048");

	/* Step over magic cookie */
	bp += sizeof(int32_t);

	/* Loop while we there is a tag left in the buffer */
	while (bp + 1 < snapend) {
		tag = *bp++;
		if (tag == TAG_PAD)
			continue;
		if (tag == TAG_END)
			return;
		cp = tok2str(tag2str, "?T%d", tag);
		c = *cp++;
		printf(" %s:", cp);

		/* Get the length; check for truncation */
		if (bp + 1 >= snapend) {
			fputs(tstr, stdout);
			return;
		}
		len = *bp++;
		if (bp + len >= snapend) {
			fputs(tstr, stdout);
			return;
		}

		if (tag == TAG_DHCP_MESSAGE && len == 1) {
			c = *bp++;
			switch (c) {
			case DHCPDISCOVER:	printf("DISCOVER");	break;
			case DHCPOFFER:		printf("OFFER");	break;
			case DHCPREQUEST:	printf("REQUEST");	break;
			case DHCPDECLINE:	printf("DECLINE");	break;
			case DHCPACK:		printf("ACK");		break;
			case DHCPNAK:		printf("NACK");		break;
			case DHCPRELEASE:	printf("RELEASE");	break;
			case DHCPINFORM:	printf("INFORM");	break;
			default:		printf("%u", c);	break;
			}
			continue;
		}

		if (tag == TAG_PARM_REQUEST) {
			first = 1;
			while (len-- > 0) {
				c = *bp++;
				cp = tok2str(tag2str, "?%d", c);
				if (!first)
					putchar('+');
				printf("%s", cp + 1);
				first = 0;
			}
			continue;
		}

		/* Print data */
		size = len;
		if (c == '?') {
			/* Base default formats for unknown tags on data size */
			if (size & 1)
				c = 'b';
			else if (size & 2)
				c = 's';
			else
				c = 'l';
		}
		first = 1;
		switch (c) {

		case 'a':
			/* ascii strings */
			putchar('"');
			(void)fn_printn(bp, size, NULL);
			putchar('"');
			bp += size;
			size = 0;
			break;

		case 'i':
		case 'l':
			/* ip addresses/32-bit words */
			while (size >= sizeof(ul)) {
				if (!first)
					putchar(',');
				memcpy((char *)&ul, (char *)bp, sizeof(ul));
				if (c == 'i')
					printf("%s", ipaddr_string(&ul));
				else
					printf("%u", ntohl(ul));
				bp += sizeof(ul);
				size -= sizeof(ul);
				first = 0;
			}
			break;

		case 'p':
			/* IP address pairs */
			while (size >= 2*sizeof(ul)) {
				if (!first)
					putchar(',');
				memcpy((char *)&ul, (char *)bp, sizeof(ul));
				printf("(%s:", ipaddr_string(&ul));
				bp += sizeof(ul);
				memcpy((char *)&ul, (char *)bp, sizeof(ul));
				printf("%s)", ipaddr_string(&ul));
				bp += sizeof(ul);
				size -= 2*sizeof(ul);
				first = 0;
			}
			break;

		case 's':
			/* shorts */
			while (size >= sizeof(us)) {
				if (!first)
					putchar(',');
				memcpy((char *)&us, (char *)bp, sizeof(us));
				printf("%u", ntohs(us));
				bp += sizeof(us);
				size -= sizeof(us);
				first = 0;
			}
			break;

		case 'B':
			/* boolean */
			while (size > 0) {
				if (!first)
					putchar(',');
				switch (*bp) {
				case 0:
					putchar('N');
					break;
				case 1:
					putchar('Y');
					break;
				default:
					printf("%d?", *bp);
					break;
				}
				++bp;
				--size;
				first = 0;
			}
			break;

		case 'b':
		default:
			/* Bytes */
			while (size > 0) {
				if (!first)
					putchar('.');
				printf("%d", *bp);
				++bp;
				--size;
				first = 0;
			}
			break;
		}
		/* Data left over? */
		if (size)
			printf("[len %d]", len);
	}
}

static void
cmu_print(const u_char *bp, u_int length)
{
	const struct cmu_vend *cmu;
	static const char fmt[] = " %s:%s";

#define PRINTCMUADDR(m, s) { TCHECK(cmu->m); \
    if (cmu->m.s_addr != 0) \
	printf(fmt, s, ipaddr_string(&cmu->m.s_addr)); }

	printf(" vend-cmu");
	cmu = (struct cmu_vend *)bp;

	/* Only print if there are unknown bits */
	TCHECK(cmu->v_flags);
	if ((cmu->v_flags & ~(VF_SMASK)) != 0)
		printf(" F:0x%x", cmu->v_flags);
	PRINTCMUADDR(v_dgate, "DG");
	PRINTCMUADDR(v_smask, cmu->v_flags & VF_SMASK ? "SM" : "SM*");
	PRINTCMUADDR(v_dns1, "NS1");
	PRINTCMUADDR(v_dns2, "NS2");
	PRINTCMUADDR(v_ins1, "IEN1");
	PRINTCMUADDR(v_ins2, "IEN2");
	PRINTCMUADDR(v_ts1, "TS1");
	PRINTCMUADDR(v_ts2, "TS2");
	return;

trunc:
	fputs(tstr, stdout);
#undef PRINTCMUADDR
}
@


1.21
log
@Remove memory.h includes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bootp.c,v 1.20 2015/11/15 20:35:36 mmcc Exp $	*/
d131 1
a131 1
			e = 0;
@


1.20
log
@Remove more register keywords.

ok daniel@@, discussed on hackers@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bootp.c,v 1.19 2015/01/16 06:40:21 deraadt Exp $	*/
a35 1
#include <memory.h>
@


1.19
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bootp.c,v 1.18 2013/10/27 18:49:25 guenther Exp $	*/
d53 1
a53 1
bootp_print(register const u_char *cp, u_int length,
d56 1
a56 1
	register const struct bootp *bp;
d122 2
a123 2
		register const struct ether_header *eh;
		register const char *e;
d265 1
a265 1
rfc1048_print(register const u_char *bp, register u_int length)
d267 4
a270 4
	register u_char tag;
	register u_int len, size;
	register const char *cp;
	register u_char c;
d442 1
a442 1
cmu_print(register const u_char *bp, register u_int length)
d444 1
a444 1
	register const struct cmu_vend *cmu;
@


1.18
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bootp.c,v 1.17 2009/10/27 23:59:55 deraadt Exp $	*/
a24 1
#include <sys/param.h>
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bootp.c,v 1.16 2007/10/07 16:41:05 deraadt Exp $	*/
d446 1
a446 1
	char *fmt = " %s:%s";
@


1.16
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bootp.c,v 1.15 2007/01/08 21:29:35 stevesk Exp $	*/
a24 5
#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif

@


1.15
log
@c should be u_char for printing option numbers.  fix parameter request
list option numbers >127 being negative.  ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bootp.c,v 1.14 2006/05/21 11:17:20 canacar Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-bootp.c,v 1.14 2006/05/21 11:17:20 canacar Exp $ (LBL)";
@


1.14
log
@Fix size checks for bootp packets. Problem found and initial patch
from pedro@@. ok moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bootp.c,v 1.13 2005/11/17 23:33:50 stevesk Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-bootp.c,v 1.13 2005/11/17 23:33:50 stevesk Exp $ (LBL)";
d276 1
a276 1
	register char c;
@


1.13
log
@fix byteorder for "s" and "l" formats; ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bootp.c,v 1.12 2002/02/19 19:39:40 millert Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-bootp.c,v 1.12 2002/02/19 19:39:40 millert Exp $ (LBL)";
d86 1
a86 1
	TCHECK(bp->bp_secs);
d153 1
a153 1
	TCHECK2(bp->bp_sname[0], 1);		/* check first char only */
d165 1
a165 1
	TCHECK(bp->bp_vend[0]);
@


1.12
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bootp.c,v 1.11 2000/10/03 14:31:56 ho Exp $	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-bootp.c,v 1.11 2000/10/03 14:31:56 ho Exp $ (LBL)";
d370 1
a370 1
					printf("%u", ul);
d399 1
a399 1
				printf("%d", us);
@


1.11
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-bootp.c,v 1.10 2000/04/26 21:35:39 jakob Exp $ (LBL)";
a33 1
#ifdef __STDC__
a35 1
#endif
@


1.10
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-bootp.c,v 1.9 1999/09/16 20:58:46 brad Exp $ (LBL)";
@


1.9
log
@bring more inline with tcpdump 3.4
@
text
@d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-bootp.c,v 1.8 1999/07/28 20:41:36 jakob Exp $ (LBL)";
d103 2
d153 1
a153 1
	TCHECK2(bp->bp_file[0], 1);		/* check first char only */
d210 57
d308 29
d377 16
d402 22
@


1.8
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996
d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-bootp.c,v 1.7 1998/07/08 22:32:03 deraadt Exp $ (LBL)";
@


1.7
log
@length check bp_file; cgd
@
text
@d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-bootp.c,v 1.6 1997/07/25 20:12:22 mickey Exp $ (LBL)";
d42 1
d149 1
d159 1
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-bootp.c,v 1.5 1996/12/12 16:22:41 bitblt Exp $ (LBL)";
d149 1
a149 1
	TCHECK2(bp->bp_sname[0], 1);		/* check first char only */
@


1.5
log
@*** empty log message ***
@
text
@d25 1
a25 1
    "@@(#) $Header: print-bootp.c,v 1.43 96/09/26 23:36:42 leres Exp $ (LBL)";
d32 1
a32 1
#if __STDC__
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d24 2
a25 2
static char rcsid[] =
    "@@(#) Header: print-bootp.c,v 1.38 96/06/23 02:11:45 leres Exp (LBL)";
a29 1
#include <sys/types.h>
d49 2
a50 2
static void rfc1048_print(const u_char *, int);
static void cmu_print(const u_char *, int);
d58 1
a58 1
bootp_print(register const u_char *cp, int length,
a63 3
	const u_char *ep;

#define TCHECK(var, l) if ((u_char *)&(var) > ep - l) goto trunc
d66 1
a66 4
	/* 'ep' points to the end of available data. */
	ep = snapend;

	TCHECK(bp->bp_op, sizeof(bp->bp_op));
d85 1
a85 1
	TCHECK(bp->bp_secs, sizeof(bp->bp_secs));
d104 1
a104 1
	TCHECK(bp->bp_ciaddr, sizeof(bp->bp_ciaddr));
d109 1
a109 1
	TCHECK(bp->bp_yiaddr, sizeof(bp->bp_yiaddr));
d114 1
a114 1
	TCHECK(bp->bp_siaddr, sizeof(bp->bp_siaddr));
d119 1
a119 1
	TCHECK(bp->bp_giaddr, sizeof(bp->bp_giaddr));
d128 1
a128 1
		TCHECK(bp->bp_chaddr[0], 6);
d140 1
a140 1
	TCHECK(bp->bp_sname[0], 1);		/* check first char only */
d142 3
a144 2
		printf(" sname ");
		if (fn_print(bp->bp_sname, ep)) {
d149 1
a149 1
	TCHECK(bp->bp_sname[0], 1);		/* check first char only */
d151 3
a153 2
		printf(" file ");
		if (fn_print(bp->bp_file, ep)) {
d160 1
a160 1
	TCHECK(bp->bp_vend[0], sizeof(bp->bp_vend));
a178 1
#undef TCHECK
d209 1
a209 1
rfc1048_print(register const u_char *bp, register int length)
a211 1
	register const u_char *ep;
a220 3
	/* Setup end pointer */
	ep = bp + length;

d225 1
a225 1
	while (bp + 1 < ep) {
d236 1
a236 1
		if (bp + 1 >= ep) {
d241 1
a241 1
		if (bp + len >= ep) {
d262 1
d264 1
d319 1
a319 1
cmu_print(register const u_char *bp, register int length)
a321 1
	register const u_char *ep;
d324 1
a324 2
#define TCHECK(var, l) if ((u_char *)&(var) > ep - l) goto trunc
#define PRINTCMUADDR(m, s) { TCHECK(cmu->m, sizeof(cmu->m)); \
a327 3
	/* Setup end pointer */
	ep = bp + length;

d332 1
a332 1
	TCHECK(cmu->v_flags, sizeof(cmu->v_flags));
a346 1
#undef TCHECK
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-bootp.c,v 1.2 1995/03/06 19:11:05 mycroft Exp $	*/
/*	$NetBSD: print-bootp.c,v 1.2 1995/03/06 19:11:05 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1990, 1991, 1993, 1994
d27 1
a27 1
    "@@(#) Header: print-bootp.c,v 1.30 94/06/14 20:17:37 leres Exp (LBL)";
d35 4
d46 1
d72 1
a72 1
	/* 'ep' points to the end of avaible data. */
d108 1
a108 1
		printf(" xid:0x%x", ntohl(bp->bp_xid));
d145 1
a145 1
		if (e == 0 || bcmp((char *)bp->bp_chaddr, e, 6) != 0)
d169 2
a170 2
	if (bcmp((char *)bp->bp_vend, (char *)vm_rfc1048,
		 sizeof(u_int32)) == 0)
d172 2
a173 2
	else if (bcmp((char *)bp->bp_vend, (char *)vm_cmu,
		      sizeof(u_int32)) == 0)
d176 1
a176 1
		u_int32 ul;
d178 1
a178 1
		bcopy((char *)bp->bp_vend, (char *)&ul, sizeof(ul));
d190 1
a190 1
static struct token tag2str[] = {
d225 1
a225 1
	u_int32 ul;
d234 1
a234 1
	bp += sizeof(int32);
d285 1
a285 1
				bcopy((char *)bp, (char *)&ul, sizeof(ul));
d289 1
a289 1
					printf("%lu", ul);
d301 1
a301 1
				bcopy((char *)bp, (char *)&us, sizeof(us));
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
