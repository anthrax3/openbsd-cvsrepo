head	1.40;
access;
symbols
	OPENBSD_6_2:1.40.0.2
	OPENBSD_6_2_BASE:1.40
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.32.0.6
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.8
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.4
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.12.0.22
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.20
	OPENBSD_5_0:1.12.0.18
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.16
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.14
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.10
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.12
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.40
date	2017.09.01.14.04.49;	author stsp;	state Exp;
branches;
next	1.39;
commitid	hgtOdzeJfB27Yyq0;

1.39
date	2017.03.04.17.51.20;	author stsp;	state Exp;
branches;
next	1.38;
commitid	4RO4CxZUqBabInko;

1.38
date	2017.01.29.15.16.14;	author stsp;	state Exp;
branches;
next	1.37;
commitid	ACessxjh9KGMJmzb;

1.37
date	2016.12.18.11.15.02;	author stsp;	state Exp;
branches;
next	1.36;
commitid	yBS8cMQBzcNmu2AQ;

1.36
date	2016.12.18.10.38.01;	author stsp;	state Exp;
branches;
next	1.35;
commitid	Zo4B0a5eks7cqgpf;

1.35
date	2016.11.19.19.35.46;	author stsp;	state Exp;
branches;
next	1.34;
commitid	kZBW93iPfnyew3pL;

1.34
date	2016.10.08.14.45.11;	author stsp;	state Exp;
branches;
next	1.33;
commitid	44sZQpZ4deOUcvjy;

1.33
date	2016.09.02.17.11.46;	author stsp;	state Exp;
branches;
next	1.32;
commitid	uPlzEhTVgGaFQ75Z;

1.32
date	2016.02.21.16.09.47;	author stsp;	state Exp;
branches;
next	1.31;
commitid	Cd6rNuWEONtQSGWF;

1.31
date	2016.02.04.10.58.48;	author stsp;	state Exp;
branches;
next	1.30;
commitid	yaMLIJCM37EvWSk9;

1.30
date	2016.02.03.16.08.09;	author stsp;	state Exp;
branches;
next	1.29;
commitid	cgA1hPJA24qEi6m8;

1.29
date	2016.02.01.10.09.44;	author stsp;	state Exp;
branches;
next	1.28;
commitid	0kA7rrW32MQvLqjG;

1.28
date	2016.01.12.09.28.10;	author stsp;	state Exp;
branches;
next	1.27;
commitid	1npmDuWgN1zBR6BQ;

1.27
date	2015.10.13.14.36.15;	author stsp;	state Exp;
branches;
next	1.26;
commitid	5m4bwYbwNdtzNwUI;

1.26
date	2015.10.12.13.01.50;	author stsp;	state Exp;
branches;
next	1.25;
commitid	VjwdY1JAiSqOQKpW;

1.25
date	2015.10.10.07.52.30;	author stsp;	state Exp;
branches;
next	1.24;
commitid	6STil4vxiVtH6UKd;

1.24
date	2015.07.19.02.49.54;	author stsp;	state Exp;
branches;
next	1.23;
commitid	ER346Lo5Ck6Z7DBI;

1.23
date	2015.07.18.23.35.01;	author stsp;	state Exp;
branches;
next	1.22;
commitid	S2JGvfZzvAYB9FHc;

1.22
date	2015.07.17.19.43.43;	author stsp;	state Exp;
branches;
next	1.21;
commitid	prfU3t8LBQyTM0OY;

1.21
date	2015.07.17.17.41.41;	author stsp;	state Exp;
branches;
next	1.20;
commitid	AmTnGWcNYbUYBsPa;

1.20
date	2015.07.16.23.34.54;	author sthen;	state Exp;
branches;
next	1.19;
commitid	BNi3jQhIBt5i3YIu;

1.19
date	2015.07.16.20.57.13;	author stsp;	state Exp;
branches;
next	1.18;
commitid	phhXXJxVbnQG2Ywo;

1.18
date	2015.07.15.03.05.00;	author stsp;	state Exp;
branches;
next	1.17;
commitid	uQManZ8b6IlCY6zQ;

1.17
date	2015.04.08.21.44.16;	author sthen;	state Exp;
branches;
next	1.16;
commitid	iPBxetNUnN0HF1x8;

1.16
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Uu5nFG3wCl0LACBb;

1.15
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.14;
commitid	yLXrOcgrag4eS8u4;

1.14
date	2014.07.20.17.52.34;	author stsp;	state Exp;
branches;
next	1.13;
commitid	p3QkvBrTOSJIOFZf;

1.13
date	2013.01.17.02.53.07;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.14.19.10.45;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.02.22.09.01;	author canacar;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.03.23.47.28;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.27.12.39.24;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.26.16.41.33;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.23.21.53.01;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.18.17.52.46;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.22.11.36.12;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.28.09.01.52;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.09.11.43.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.08.14.55.41;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.07.16.13.38;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Make 'tcpdump -v' decode RSN information elements in beacons
instead of lazily dumping them in hex.
ok mpi@@
@
text
@/*	$OpenBSD: print-802_11.c,v 1.39 2017/03/04 17:51:20 stsp Exp $	*/

/*
 * Copyright (c) 2005 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/time.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/ioctl.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211.h>
#include <net80211/ieee80211_radiotap.h>

#include <ctype.h>
#include <pcap.h>
#include <stdio.h>
#include <string.h>

#include "addrtoname.h"
#include "interface.h"

const char *ieee80211_ctl_subtype_name[] = {
	"reserved#0",
	"reserved#1",
	"reserved#2",
	"reserved#3",
	"reserved#4",
	"reserved#5",
	"reserved#6",
	"wrapper",
	"block ack request",
	"block ack", 
	"ps poll", 
	"rts", 
	"cts", 
	"ack", 
	"cf-end", 
	"cf-end-ack", 
};

const char *ieee80211_mgt_subtype_name[] = {
	"association request",
	"association response",
	"reassociation request",
	"reassociation response",
	"probe request",
	"probe response",
	"reserved#6",
	"reserved#7",
	"beacon",
	"atim",
	"disassociation",
	"authentication",
	"deauthentication",
	"action",
	"action noack",
	"reserved#15"
};

const char *ieee80211_data_subtype_name[] = {
	"data",
	"data cf ack",
	"data cf poll",
	"data cf poll ack",
	"no-data",
	"no-data cf poll",
	"no-data cf ack",
	"no-data cf poll ack",
	"QoS data",
	"QoS data cf ack",
	"QoS data cf poll",
	"QoS data cf poll ack",
	"QoS no-data",
	"QoS no-data cf poll",
	"QoS no-data cf ack",
	"QoS no-data cf poll ack"
};

int	 ieee80211_hdr(struct ieee80211_frame *);
int	 ieee80211_data(struct ieee80211_frame *, u_int);
void	 ieee80211_print_element(u_int8_t *, u_int);
void	 ieee80211_print_essid(u_int8_t *, u_int);
void	 ieee80211_print_country(u_int8_t *, u_int);
void	 ieee80211_print_htcaps(u_int8_t *, u_int);
void	 ieee80211_print_htop(u_int8_t *, u_int);
void	 ieee80211_print_rsncipher(u_int8_t []);
void	 ieee80211_print_akm(u_int8_t []);
void	 ieee80211_print_rsn(u_int8_t *, u_int);
int	 ieee80211_print_beacon(struct ieee80211_frame *, u_int);
int	 ieee80211_print_assocreq(struct ieee80211_frame *, u_int);
int	 ieee80211_print_elements(uint8_t *);
int	 ieee80211_frame(struct ieee80211_frame *, u_int);
int	 ieee80211_print(struct ieee80211_frame *, u_int);
u_int	 ieee80211_any2ieee(u_int, u_int);
void	 ieee80211_reason(u_int16_t);

#define TCARR(a)	TCHECK2(*a, sizeof(a))

int ieee80211_encap = 0;

int
ieee80211_hdr(struct ieee80211_frame *wh)
{
	struct ieee80211_frame_addr4 *w4;

	switch (wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) {
	case IEEE80211_FC1_DIR_NODS:
		TCARR(wh->i_addr2);
		printf("%s", etheraddr_string(wh->i_addr2));
		TCARR(wh->i_addr1);
		printf(" > %s", etheraddr_string(wh->i_addr1));
		TCARR(wh->i_addr3);
		printf(", bssid %s", etheraddr_string(wh->i_addr3));
		break;
	case IEEE80211_FC1_DIR_TODS:
		TCARR(wh->i_addr2);
		printf("%s", etheraddr_string(wh->i_addr2));
		TCARR(wh->i_addr3);
		printf(" > %s", etheraddr_string(wh->i_addr3));
		TCARR(wh->i_addr1);
		printf(", bssid %s, > DS", etheraddr_string(wh->i_addr1));
		break;
	case IEEE80211_FC1_DIR_FROMDS:
		TCARR(wh->i_addr3);
		printf("%s", etheraddr_string(wh->i_addr3));
		TCARR(wh->i_addr1);
		printf(" > %s", etheraddr_string(wh->i_addr1));
		TCARR(wh->i_addr2);
		printf(", bssid %s, DS >", etheraddr_string(wh->i_addr2));
		break;
	case IEEE80211_FC1_DIR_DSTODS:
		w4 = (struct ieee80211_frame_addr4 *) wh;
		TCARR(w4->i_addr4);
		printf("%s", etheraddr_string(w4->i_addr4));
		TCARR(w4->i_addr3);
		printf(" > %s", etheraddr_string(w4->i_addr3));
		TCARR(w4->i_addr2);
		printf(", bssid %s", etheraddr_string(w4->i_addr2));
		TCARR(w4->i_addr1);
		printf(" > %s, DS > DS", etheraddr_string(w4->i_addr1));
		break;
	}
	if (vflag) {
		u_int16_t seq;
		TCARR(wh->i_seq);
		bcopy(wh->i_seq, &seq, sizeof(u_int16_t));
		printf(" (seq %u): ", letoh16(seq));
	} else
		printf(": ");

	return (0);

 trunc:
	/* Truncated elements in frame */
	return (1);
}

int
ieee80211_data(struct ieee80211_frame *wh, u_int len)
{
	u_int8_t *t = (u_int8_t *)wh;
	u_int datalen;
	int data = !(wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_NODATA);
	int hasqos = ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) ==
	    (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS));
	u_char *esrc = NULL, *edst = NULL;

	if (hasqos) {
		struct ieee80211_qosframe *wq;

		wq = (struct ieee80211_qosframe *) wh;
		TCHECK(*wq);
		t += sizeof(*wq);
		datalen = len - sizeof(*wq);
	} else {
		TCHECK(*wh);
		t += sizeof(*wh);
		datalen = len - sizeof(*wh);
	}

	switch (wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) {
	case IEEE80211_FC1_DIR_TODS:
		esrc = wh->i_addr2;
		edst = wh->i_addr3;
		break;
	case IEEE80211_FC1_DIR_FROMDS:
		esrc = wh->i_addr3;
		edst = wh->i_addr1;
		break;
	case IEEE80211_FC1_DIR_NODS:
		esrc = wh->i_addr2;
		edst = wh->i_addr1;
		break;
	case IEEE80211_FC1_DIR_DSTODS:
		if (hasqos) {
			struct ieee80211_qosframe_addr4 *w4;

			w4 = (struct ieee80211_qosframe_addr4 *) wh;
			TCHECK(*w4);
			t = (u_int8_t *) (w4 + 1);
			datalen = len - sizeof(*w4);
			esrc = w4->i_addr4;
			edst = w4->i_addr3;
		} else {
			struct ieee80211_frame_addr4 *w4;

			w4 = (struct ieee80211_frame_addr4 *) wh;
			TCHECK(*w4);
			t = (u_int8_t *) (w4 + 1);
			datalen = len - sizeof(*w4);
			esrc = w4->i_addr4;
			edst = w4->i_addr3;
		}
		break;
	}

	if (data && esrc)
		llc_print(t, datalen, datalen, esrc, edst);
	else if (eflag && esrc)
		printf("%s > %s",
		    etheraddr_string(esrc), etheraddr_string(edst));

	return (0);

 trunc:
	/* Truncated elements in frame */
	return (1);
}

/* Caller checks len */
void
ieee80211_print_element(u_int8_t *data, u_int len)
{
	u_int8_t *p;
	int i;

	printf(" 0x");
	for (i = 0, p = data; i < len; i++, p++)
		printf("%02x", *p);
}

/* Caller checks len */
void
ieee80211_print_essid(u_int8_t *essid, u_int len)
{
	u_int8_t *p;
	int i;

	if (len > IEEE80211_NWID_LEN)
		len = IEEE80211_NWID_LEN;

	/* determine printable or not */
	for (i = 0, p = essid; i < len; i++, p++) {
		if (*p < ' ' || *p > 0x7e)
			break;
	}
	if (i == len) {
		printf(" (");
		for (i = 0, p = essid; i < len; i++, p++)
			putchar(*p);
		putchar(')');
	} else
		ieee80211_print_element(essid, len);
}

/* Caller checks len */
void
ieee80211_print_country(u_int8_t *data, u_int len)
{
	u_int8_t first_chan, nchan, maxpower;

	if (len < 6)
		return;

	/* country string */
	printf((isprint(data[0]) ? " '%c" : " '\\%03o"), data[0]);
	printf((isprint(data[1]) ? "%c" : "\\%03o"), data[1]);
	printf((isprint(data[2]) ? "%c'" : "\\%03o'"), data[2]);

	len -= 3;
	data += 3;

	/* channels and corresponding TX power limits */
	while (len >= 3) {
		/* no pretty-printing for nonsensical zero values,
		 * nor for operating extension IDs (values >= 201) */
		if (data[0] == 0 || data[1] == 0 ||
		    data[0] >= 201 || data[1] >= 201) {
			printf(", %d %d %d", data[0], data[1], data[2]);
			len -= 3;
			data += 3;
			continue;
		}

		first_chan = data[0];
		nchan = data[1];
		maxpower = data[2];

		printf(", channel%s %d", nchan == 1 ? "" : "s", first_chan);
		if (nchan > 1)
			printf("-%d", first_chan + nchan - 1);
		printf(" limit %ddB", maxpower);

		len -= 3;
		data += 3;
	}
}

/* Caller checks len */
void
ieee80211_print_htcaps(u_int8_t *data, u_int len)
{
	uint16_t htcaps, rxrate;
	int smps, rxstbc;
	uint8_t ampdu, txmcs;
	int i;
	uint8_t *rxmcs;

	if (len < 2) {
		ieee80211_print_element(data, len);
		return;
	}

	htcaps = (data[0]) | (data[1] << 8);
	printf("=<");

	/* channel width */
	if (htcaps & IEEE80211_HTCAP_CBW20_40)
		printf("20/40MHz");
	else
		printf("20MHz");

	/* LDPC coding */
	if (htcaps & IEEE80211_HTCAP_LDPC)
		printf(",LDPC");

	/* spatial multiplexing power save mode */
	smps = (htcaps & IEEE80211_HTCAP_SMPS_MASK)
	    >> IEEE80211_HTCAP_SMPS_SHIFT;
	if (smps == 0)
		printf(",SMPS static");
	else if (smps == 1)
		printf(",SMPS dynamic");

	/* 11n greenfield mode */
	if (htcaps & IEEE80211_HTCAP_GF)
		printf(",greenfield");

	/* short guard interval */
	if (htcaps & IEEE80211_HTCAP_SGI20)
		printf(",SGI@@20MHz");
	if (htcaps & IEEE80211_HTCAP_SGI40)
		printf(",SGI@@40MHz");

	/* space-time block coding */
	if (htcaps & IEEE80211_HTCAP_TXSTBC)
		printf(",TXSTBC");
	rxstbc = (htcaps & IEEE80211_HTCAP_RXSTBC_MASK)
	    >> IEEE80211_HTCAP_RXSTBC_SHIFT;
	if (rxstbc > 0 && rxstbc < 4)
		printf(",RXSTBC %d stream", rxstbc);

	/* delayed block-ack */
	if (htcaps & IEEE80211_HTCAP_DELAYEDBA)
		printf(",delayed BA");

	/* max A-MSDU length */
	if (htcaps & IEEE80211_HTCAP_AMSDU7935)
		printf(",A-MSDU 7935");
	else
		printf(",A-MSDU 3839");

	/* DSSS/CCK in 40MHz mode */
	if (htcaps & IEEE80211_HTCAP_DSSSCCK40)
		printf(",DSSS/CCK@@40MHz");

	/* 40MHz intolerant */
	if (htcaps & IEEE80211_HTCAP_40INTOLERANT)
		printf(",40MHz intolerant");

	/* L-SIG TXOP protection */
	if (htcaps & IEEE80211_HTCAP_LSIGTXOPPROT)
		printf(",L-SIG TXOP prot");

	if (len < 3) {
		printf(">");
		return;
	}

	/* A-MPDU parameters. */
	ampdu = data[2];

	/* A-MPDU length exponent */
	if ((ampdu & IEEE80211_AMPDU_PARAM_LE) >= 0 &&
	    (ampdu & IEEE80211_AMPDU_PARAM_LE) <= 3)
		printf(",A-MPDU max %d",
		    (1 << (13 + (ampdu & IEEE80211_AMPDU_PARAM_LE))) - 1);

	/* A-MPDU start spacing */
	if (ampdu & IEEE80211_AMPDU_PARAM_SS) {
		float ss;

		switch ((ampdu & IEEE80211_AMPDU_PARAM_SS) >> 2) {
		case 1:
			ss = 0.25;
			break;
		case 2:
			ss = 0.5;
			break;
		case 3:
			ss = 1;
			break;
		case 4:
			ss = 2;
			break;
		case 5:
			ss = 4;
			break;
		case 6:
			ss = 8;
			break;
		case 7:
			ss = 16;
			break;
		default:
			ss = 0;
			break;
		}
		if (ss != 0)
			printf(",A-MPDU spacing %.2fus", ss);
	}

	if (len < 21) {
		printf(">");
		return;
	}

	/* Supported MCS set. */
	printf(",RxMCS 0x");
	rxmcs = &data[3];
	for (i = 0; i < 10; i++)
		printf("%02x", rxmcs[i]);

	/* Max MCS Rx rate (a value of 0 means "not specified"). */
	rxrate = ((data[13] | (data[14]) << 8) & IEEE80211_MCS_RX_RATE_HIGH);
	if (rxrate)
		printf(",RxMaxrate %huMb/s", rxrate);

	/* Tx MCS Set */
	txmcs = data[15];
	if (txmcs & IEEE80211_TX_MCS_SET_DEFINED) {
		if (txmcs & IEEE80211_TX_RX_MCS_NOT_EQUAL) {
			/* Number of spatial Tx streams. */
			printf(",%d Tx streams",
			     1 + ((txmcs & IEEE80211_TX_SPATIAL_STREAMS) >> 2));
			/* Transmit unequal modulation supported. */
			if (txmcs & IEEE80211_TX_UNEQUAL_MODULATION)
				printf(",UEQM");
		}
	}

	printf(">");
}

/* Caller checks len */
void
ieee80211_print_htop(u_int8_t *data, u_int len)
{
	u_int8_t primary_chan;
	u_int8_t htopinfo[5];
	u_int8_t basic_mcs[16];
	int sco, htprot, i;

	if (len < sizeof(primary_chan) + sizeof(htopinfo) + sizeof(basic_mcs)) {
		ieee80211_print_element(data, len);
		return;
	}

	htopinfo[0] = data[1];

	printf("=<");

	/* primary channel and secondary channel offset */
	primary_chan = data[0];
	sco = ((htopinfo[0] & IEEE80211_HTOP0_SCO_MASK)
	    >> IEEE80211_HTOP0_SCO_SHIFT);
	if (sco == 0) /* no secondary channel */
		printf("20MHz chan %d", primary_chan);
	else if (sco == 1) { /* secondary channel above */
		if (primary_chan >= 1 && primary_chan <= 13) /* 2GHz */
			printf("40MHz chan %d:%d", primary_chan,
			    primary_chan + 1);
		else if (primary_chan >= 34) /* 5GHz */
			printf("40MHz chan %d:%d", primary_chan,
			    primary_chan + 4);
		else
			printf("[invalid 40MHz chan %d+]", primary_chan);
	} else if (sco == 3) { /* secondary channel below */
		if (primary_chan >= 2 && primary_chan <= 14) /* 2GHz */
			printf("40MHz chan %d:%d", primary_chan,
			    primary_chan - 1);
		else if (primary_chan >= 40) /* 5GHz */
			printf("40MHz chan %d:%d", primary_chan,
			    primary_chan - 4);
		else
			printf("[invalid 40MHz chan %d-]", primary_chan);
	} else
		printf("chan %d [invalid secondary channel offset %d]",
		    primary_chan, sco);

	/* STA channel width */
	if ((htopinfo[0] & IEEE80211_HTOP0_CHW) == 0)
		printf(",STA chanw 20MHz");

	/* reduced interframe space (RIFS) permitted */
	if (htopinfo[0] & IEEE80211_HTOP0_RIFS)
		printf(",RIFS");

	htopinfo[1] = data[2];

	/* protection requirements for HT transmissions */
	htprot = ((htopinfo[1] & IEEE80211_HTOP1_PROT_MASK)
	    >> IEEE80211_HTOP1_PROT_SHIFT);
	switch (htprot) {
	case IEEE80211_HTPROT_NONE:
		printf(",htprot none");
		break;
	case IEEE80211_HTPROT_NONMEMBER:
		printf(",htprot non-member");
		break;
	case IEEE80211_HTPROT_20MHZ:
		printf(",htprot 20MHz");
		break;
	case IEEE80211_HTPROT_NONHT_MIXED:
		printf(",htprot non-HT-mixed");
		break;
	default:
		printf(",htprot %d", htprot);
		break;
	}

	/* non-greenfield STA present */
	if (htopinfo[1] & IEEE80211_HTOP1_NONGF_STA)
		printf(",non-greenfield STA");

	/* non-HT STA present */
	if (htopinfo[1] & IEEE80211_HTOP1_OBSS_NONHT_STA)
		printf(",non-HT STA");

	htopinfo[3] = data[4];

	/* dual-beacon */
	if (htopinfo[3] & IEEE80211_HTOP2_DUALBEACON)
		printf(",dualbeacon");

	/* dual CTS protection */
	if (htopinfo[3] & IEEE80211_HTOP2_DUALCTSPROT)
		printf(",dualctsprot");

	htopinfo[4] = data[5];

	/* space-time block coding (STBC) beacon */
	if ((htopinfo[4] << 8) & IEEE80211_HTOP2_STBCBEACON)
		printf(",STBC beacon");

	/* L-SIG (non-HT signal field) TX opportunity (TXOP) protection */
	if ((htopinfo[4] << 8) & IEEE80211_HTOP2_LSIGTXOP)
		printf(",lsigtxprot");

	/* phased-coexistence operation (PCO) active */
	if ((htopinfo[4] << 8) & IEEE80211_HTOP2_PCOACTIVE) {
		/* PCO phase */
		if ((htopinfo[4] << 8) & IEEE80211_HTOP2_PCOPHASE40)
			printf(",pco40MHz");
		else
			printf(",pco20MHz");
	}

	/* basic MCS set */
	memcpy(basic_mcs, &data[6], sizeof(basic_mcs));
	printf(",basic MCS set 0x");
	for (i = 0; i < sizeof(basic_mcs) / sizeof(basic_mcs[0]); i++)
			printf("%x", basic_mcs[i]);

	printf(">");
}

void
ieee80211_print_rsncipher(uint8_t selector[4])
{
	if (memcmp(selector, MICROSOFT_OUI, 3) != 0 &&
	    memcmp(selector, IEEE80211_OUI, 3) != 0) {
		printf("0x%x%x%x%x", selector[0], selector[1], selector[2],
		     selector[3]);
	    	return;
	}

	/* See 802.11-2012 Table 8-99 */
	switch (selector[3]) {
	case 0:	/* use group data cipher suite */
		printf("usegroup");
		break;
	case 1:	/* WEP-40 */
		printf("wep40");
		break;
	case 2:	/* TKIP */
		printf("tkip");
		break;
	case 4:	/* CCMP (RSNA default) */
		printf("ccmp");
		break;
	case 5:	/* WEP-104 */
		printf("wep104");
		break;
	case 6:	/* BIP */
		printf("bip");
		break;
	default:
		printf("%d", selector[3]);
		break;
	}
}

void
ieee80211_print_akm(uint8_t selector[4])
{
	if (memcmp(selector, MICROSOFT_OUI, 3) != 0 &&
	    memcmp(selector, IEEE80211_OUI, 3) != 0) {
		printf("0x%x%x%x%x", selector[0], selector[1], selector[2],
		     selector[3]);
	    	return;
	}

	switch (selector[3]) {
	case 1:
		printf("802.1x");
		break;
	case 2:
		printf("PSK");
		break;
	case 5:
		printf("SHA256-802.1x");
		break;
	case 6:
		printf("SHA256-PSK");
		break;
	default:
		printf("%d", selector[3]);
		break;
	}
}

/* Caller checks len */
void
ieee80211_print_rsn(u_int8_t *data, u_int len)
{
	uint16_t version, nciphers, nakms, rsncap, npmk;
	int i, j;
	uint8_t selector[4];

	if (len < 2) {
		ieee80211_print_element(data, len);
		return;
	}

	version = (data[0]) | (data[1] << 8);
	printf("=<version %d", version);

	if (len < 6) {
		printf(">");
		return;
	}

	data += 2;
	printf(",groupcipher ");
	for (i = 0; i < 4; i++)
		selector[i] = data[i];
	ieee80211_print_rsncipher(selector);

	if (len < 8) {
		printf(">");
		return;
	}

	data += 4;
	nciphers = (data[0]) | ((data[1]) << 8);
	data += 2;

	if (len < 8 + (nciphers * 4)) {
		printf(">");
		return;
	}

	printf(",cipher%s ", nciphers > 1 ? "s" : "");
	for (i = 0; i < nciphers; i++) {
		for (j = 0; j < 4; j++)
			selector[j] = data[i + j];
		ieee80211_print_rsncipher(selector);
		if (i < nciphers - 1)
			printf(" ");
		data += 4;
	}

	if (len < 8 + (nciphers * 4) + 2) {
		printf(">");
		return;
	}

	nakms = (data[0]) | ((data[1]) << 8);
	data += 2;

	if (len < 8 + (nciphers * 4) + 2 + (nakms * 4)) {
		printf(">");
		return;
	}

	printf(",akm%s ", nakms > 1 ? "s" : "");
	for (i = 0; i < nciphers; i++) {
		for (j = 0; j < 4; j++)
			selector[j] = data[i + j];
		ieee80211_print_akm(selector);
		if (i < nciphers - 1)
			printf(" ");
		data += 4;
	}

	if (len < 8 + (nciphers * 4) + 2 + (nakms * 4) + 2) {
		printf(">");
		return;
	}

	rsncap = (data[0]) | ((data[1]) << 8);
	printf(",rsncap 0x%x", rsncap);
	data += 2;

	if (len < 8 + (nciphers * 4) + 2 + (nakms * 4) + 2 + 2) {
		printf(">");
		return;
	}

	npmk = (data[0]) | ((data[1]) << 8);
	data += 2;

	if (len < 8 + (nciphers * 4) + 2 + (nakms * 4) + 2 + 2 +
	    (npmk * IEEE80211_PMKID_LEN)) {
		printf(">");
		return;
	}

	if (npmk >= 1)
		printf(",pmkid%s ", npmk > 1 ? "s" : "");
	for (i = 0; i < npmk; i++) {
		printf("0x");
		for (j = 0; j < IEEE80211_PMKID_LEN; j++)
			printf("%x", data[i + j]);
		if (i < npmk - 1)
			printf(" ");
		data += IEEE80211_PMKID_LEN;
	}

	if (len < 8 + (nciphers * 4) + 2 + (nakms * 4) + 2 + 2 +
	    (npmk * IEEE80211_PMKID_LEN) + 4) {
		printf(">");
		return;
	}

	printf(",integrity-groupcipher ");
	for (i = 0; i < 4; i++)
		selector[i] = data[i];
	ieee80211_print_rsncipher(selector);

	printf(">");
}

int
ieee80211_print_beacon(struct ieee80211_frame *wh, u_int len)
{
	uint64_t tstamp;
	uint16_t bintval, capinfo;
	uint8_t *frm;

	if (len < sizeof(tstamp) + sizeof(bintval) + sizeof(capinfo))
		return 1; /* truncated */

	frm = (u_int8_t *)&wh[1];

	bcopy(frm, &tstamp, sizeof(u_int64_t));
	frm += 8;
	if (vflag > 1)
		printf(", timestamp %llu", letoh64(tstamp));

	bcopy(frm, &bintval, sizeof(u_int16_t));
	frm += 2;
	if (vflag > 1)
		printf(", interval %u", letoh16(bintval));

	bcopy(frm, &capinfo, sizeof(u_int16_t));
	frm += 2;
	if (vflag)
		printb(", caps", letoh16(capinfo), IEEE80211_CAPINFO_BITS);

	return ieee80211_print_elements(frm);
}

int
ieee80211_print_assocreq(struct ieee80211_frame *wh, u_int len)
{
	uint8_t subtype;
	uint16_t capinfo, lintval;
	uint8_t *frm;

	subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

	if (len < sizeof(capinfo) + sizeof(lintval) +
	    (subtype == IEEE80211_FC0_SUBTYPE_REASSOC_REQ ?
	    IEEE80211_ADDR_LEN : 0))
		return 1; /* truncated */

	frm = (u_int8_t *)&wh[1];

	bcopy(frm, &capinfo, sizeof(u_int16_t));
	frm += 2;
	if (vflag)
		printb(", caps", letoh16(capinfo), IEEE80211_CAPINFO_BITS);

	bcopy(frm, &lintval, sizeof(u_int16_t));
	frm += 2;
	if (vflag > 1)
		printf(", listen interval %u", letoh16(lintval));

	if (subtype == IEEE80211_FC0_SUBTYPE_REASSOC_REQ) {
		if (vflag)
			printf(", AP %s", etheraddr_string(frm));
		frm += IEEE80211_ADDR_LEN;
	}

	return ieee80211_print_elements(frm);
}

int
ieee80211_print_elements(uint8_t *frm)
{
	int i;

	while (TTEST2(*frm, 2)) {
		u_int len = frm[1];
		u_int8_t *data = frm + 2;

		if (!TTEST2(*data, len))
			break;

#define ELEM_CHECK(l)	if (len != l) goto trunc

		switch (*frm) {
		case IEEE80211_ELEMID_SSID:
			printf(", ssid");
			ieee80211_print_essid(data, len);
			break;
		case IEEE80211_ELEMID_RATES:
			printf(", rates");
			if (!vflag)
				break;
			for (i = len; i > 0; i--, data++)
				printf(" %uM%s",
				    (data[0] & IEEE80211_RATE_VAL) / 2,
				    (data[0] & IEEE80211_RATE_BASIC
				    ? "*" : ""));
			break;
		case IEEE80211_ELEMID_FHPARMS:
			ELEM_CHECK(5);
			printf(", fh (dwell %u, chan %u, index %u)",
			    (data[1] << 8) | data[0],
			    (data[2] - 1) * 80 + data[3],	/* FH_CHAN */
			    data[4]);
			break;
		case IEEE80211_ELEMID_DSPARMS:
			ELEM_CHECK(1);
			printf(", ds");
			if (vflag)
				printf(" (chan %u)", data[0]);
			break;
		case IEEE80211_ELEMID_CFPARMS:
			printf(", cf");
			if (vflag)
				ieee80211_print_element(data, len);
			break;
		case IEEE80211_ELEMID_TIM:
			printf(", tim");
			if (vflag)
				ieee80211_print_element(data, len);
			break;
		case IEEE80211_ELEMID_IBSSPARMS:
			printf(", ibss");
			if (vflag)
				ieee80211_print_element(data, len);
			break;
		case IEEE80211_ELEMID_COUNTRY:
			printf(", country");
			if (vflag)
				ieee80211_print_country(data, len);
			break;
		case IEEE80211_ELEMID_CHALLENGE:
			printf(", challenge");
			if (vflag)
				ieee80211_print_element(data, len);
			break;
		case IEEE80211_ELEMID_CSA:
			ELEM_CHECK(3);
			printf(", csa (chan %u count %u%s)", data[1], data[2],
			    (data[0] == 1) ? " noTX" : "");
			break;
		case IEEE80211_ELEMID_ERP:
			printf(", erp");
			if (vflag)
				ieee80211_print_element(data, len);
			break;
		case IEEE80211_ELEMID_RSN:
			printf(", rsn");
			if (vflag)
				ieee80211_print_rsn(data, len);
			break;
		case IEEE80211_ELEMID_XRATES:
			printf(", xrates");
			if (!vflag)
				break;
			for (i = len; i > 0; i--, data++)
				printf(" %uM",
				    (data[0] & IEEE80211_RATE_VAL) / 2);
			break;
		case IEEE80211_ELEMID_TPC_REPORT:
			printf(", tpcreport");
			if (vflag)
				ieee80211_print_element(data, len);
			break;
		case IEEE80211_ELEMID_TPC_REQUEST:
			printf(", tpcrequest");
			if (vflag)
				ieee80211_print_element(data, len);
			break;
		case IEEE80211_ELEMID_HTCAPS:
			printf(", htcaps");
			if (vflag)
				ieee80211_print_htcaps(data, len);
			break;
		case IEEE80211_ELEMID_HTOP:
			printf(", htop");
			if (vflag)
				ieee80211_print_htop(data, len);
			break;
		case IEEE80211_ELEMID_POWER_CONSTRAINT:
			ELEM_CHECK(1);
			printf(", power constraint %udB", data[0]);
			break;
		case IEEE80211_ELEMID_QBSS_LOAD:
			ELEM_CHECK(5);
			printf(", %u stations, %d%% utilization, "
			    "admission capacity %uus/s",
			    (data[0] | data[1] << 8),
			    (data[2] * 100) / 255,
			    (data[3] | data[4] << 8) / 32);
			break;
		case IEEE80211_ELEMID_VENDOR:
			printf(", vendor");
			if (vflag)
				ieee80211_print_element(data, len);
			break;
		default:
			printf(", %u:%u", (u_int) *frm, len);
			if (vflag)
				ieee80211_print_element(data, len);
			break;
		}
		frm += len + 2;

		if (frm >= snapend)
			break;
	}

#undef ELEM_CHECK

	return (0);

 trunc:
	/* Truncated elements in frame */
	return (1);
}

int
ieee80211_frame(struct ieee80211_frame *wh, u_int len)
{
	u_int8_t subtype, type, *frm;

	TCARR(wh->i_fc);

	type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;
	subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

	frm = (u_int8_t *)&wh[1];

	if (vflag)
		printb(" flags", wh->i_fc[1], IEEE80211_FC1_BITS);

	switch (type) {
	case IEEE80211_FC0_TYPE_DATA:
		printf(": %s: ", ieee80211_data_subtype_name[
		    subtype >> IEEE80211_FC0_SUBTYPE_SHIFT]);
		ieee80211_data(wh, len);
		break;
	case IEEE80211_FC0_TYPE_MGT:
		printf(": %s", ieee80211_mgt_subtype_name[
		    subtype >> IEEE80211_FC0_SUBTYPE_SHIFT]);
		switch (subtype) {
		case IEEE80211_FC0_SUBTYPE_BEACON:
		case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
			if (ieee80211_print_beacon(wh, len) != 0)
				goto trunc;
			break;
		case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:
		case IEEE80211_FC0_SUBTYPE_REASSOC_REQ:
			if (ieee80211_print_assocreq(wh, len) != 0)
				goto trunc;
			break;
		case IEEE80211_FC0_SUBTYPE_AUTH:
			TCHECK2(*frm, 2);		/* Auth Algorithm */
			switch (IEEE80211_AUTH_ALGORITHM(frm)) {
			case IEEE80211_AUTH_ALG_OPEN:
				TCHECK2(*frm, 4);	/* Auth Transaction */
				switch (IEEE80211_AUTH_TRANSACTION(frm)) {
				case IEEE80211_AUTH_OPEN_REQUEST:
					printf(" request");
					break;
				case IEEE80211_AUTH_OPEN_RESPONSE:
					printf(" response");
					break;
				}
				break;
			case IEEE80211_AUTH_ALG_SHARED:
				TCHECK2(*frm, 4);	/* Auth Transaction */
				switch (IEEE80211_AUTH_TRANSACTION(frm)) {
				case IEEE80211_AUTH_SHARED_REQUEST:
					printf(" request");
					break;
				case IEEE80211_AUTH_SHARED_CHALLENGE:
					printf(" challenge");
					break;
				case IEEE80211_AUTH_SHARED_RESPONSE:
					printf(" response");
					break;
				case IEEE80211_AUTH_SHARED_PASS:
					printf(" pass");
					break;
				}
				break;
			case IEEE80211_AUTH_ALG_LEAP:
				printf(" (leap)");
				break;
			}
			break;
		case IEEE80211_FC0_SUBTYPE_DEAUTH:
		case IEEE80211_FC0_SUBTYPE_DISASSOC:
			TCHECK2(*frm, 2);		/* Reason Code */
			ieee80211_reason(frm[0] | (frm[1] << 8));
			break;
		}
		break;
	case IEEE80211_FC0_TYPE_CTL: {
		u_int8_t *t = (u_int8_t *) wh;

		printf(": %s", ieee80211_ctl_subtype_name[
		    subtype >> IEEE80211_FC0_SUBTYPE_SHIFT]);
		if (!vflag)
			break;

		/* See 802.11 2012 "8.3.1 Control frames". */
		t += 2; /* skip Frame Control */
		switch (subtype) {
		case IEEE80211_FC0_SUBTYPE_RTS:
		case IEEE80211_FC0_SUBTYPE_BAR:
		case IEEE80211_FC0_SUBTYPE_BA:
			TCHECK2(*t, 2); /* Duration */
			printf(", duration %dus", (t[0] | t[1] << 8));
			t += 2;
			TCHECK2(*t, 6); /* RA */
			printf(", ra %s", etheraddr_string(t));
			t += 6;
			TCHECK2(*t, 6); /* TA */
			printf(", ta %s", etheraddr_string(t));
			if (subtype == IEEE80211_FC0_SUBTYPE_BAR ||
			    subtype == IEEE80211_FC0_SUBTYPE_BA) {
				u_int16_t ctrl;

				t += 6;	
				TCHECK2(*t, 2); /* BAR/BA control */
				ctrl = t[0] | (t[1] << 8);
				if (ctrl & IEEE80211_BA_ACK_POLICY)
					printf(", no ack");
				else
					printf(", normal ack");
				if ((ctrl & IEEE80211_BA_MULTI_TID) == 0 &&
				    (ctrl & IEEE80211_BA_COMPRESSED) == 0)
					printf(", basic variant");
				else if ((ctrl & IEEE80211_BA_MULTI_TID) &&
				    (ctrl & IEEE80211_BA_COMPRESSED))
					printf(", multi-tid variant");
				else if (ctrl & IEEE80211_BA_COMPRESSED)
					printf(", compressed variant");
			}
			break;
		case IEEE80211_FC0_SUBTYPE_CTS:
		case IEEE80211_FC0_SUBTYPE_ACK:
			TCHECK2(*t, 2); /* Duration */
			printf(", duration %dus", (t[0] | t[1] << 8));
			t += 2;
			TCHECK2(*t, 6); /* RA */
			printf(", ra %s", etheraddr_string(t));
			break;
		case IEEE80211_FC0_SUBTYPE_PS_POLL:
			TCHECK2(*t, 2); /* AID */
			printf(", aid 0x%x", (t[0] | t[1] << 8));
			t += 2;
			TCHECK2(*t, 6); /* BSSID(RA) */
			printf(", ra %s", etheraddr_string(t));
			t += 6;
			TCHECK2(*t, 6); /* TA */
			printf(", ta %s", etheraddr_string(t));
			break;
		}
		break;
	}
	default:
		printf(": type#%d", type);
		break;
	}

	return (0);

 trunc:
	/* Truncated 802.11 frame */
	return (1);
}

u_int
ieee80211_any2ieee(u_int freq, u_int flags)
{
	if (flags & IEEE80211_CHAN_2GHZ) {
		if (freq == 2484)
			return 14;
		if (freq < 2484)
			return (freq - 2407) / 5;
		else
			return 15 + ((freq - 2512) / 20);
	} else if (flags & IEEE80211_CHAN_5GHZ) {
		return (freq - 5000) / 5;
	} else {
		/* Assume channel is already an IEEE number */
		return (freq);
	}
}

int
ieee80211_print(struct ieee80211_frame *wh, u_int len)
{
	if (eflag)
		if (ieee80211_hdr(wh))
			return (1);

	printf("802.11");

	return (ieee80211_frame(wh, len));
}

void
ieee802_11_if_print(u_char *user, const struct pcap_pkthdr *h,
    const u_char *p)
{
	struct ieee80211_frame *wh = (struct ieee80211_frame*)p;

	if (!ieee80211_encap)
		ts_print(&h->ts);

	packetp = p;
	snapend = p + h->caplen;

	if (ieee80211_print(wh, (u_int)h->len) != 0)
		printf("[|802.11]");

	if (!ieee80211_encap) {
		if (xflag)
			default_print(p, (u_int)h->len);
		putchar('\n');
	}
}

void
ieee802_11_radio_if_print(u_char *user, const struct pcap_pkthdr *h,
    const u_char *p)
{
	struct ieee80211_radiotap_header *rh =
	    (struct ieee80211_radiotap_header*)p;
	struct ieee80211_frame *wh;
	u_int8_t *t;
	u_int32_t present;
	u_int len, rh_len;
	u_int16_t tmp;

	if (!ieee80211_encap)
		ts_print(&h->ts);

	packetp = p;
	snapend = p + h->caplen;

	TCHECK(*rh);

	len = h->len;
	rh_len = letoh16(rh->it_len);
	if (rh->it_version != 0) {
		printf("[?radiotap + 802.11 v:%u]", rh->it_version);
		goto out;
	}

	wh = (struct ieee80211_frame *)(p + rh_len);
	if (len <= rh_len || ieee80211_print(wh, len - rh_len))
		printf("[|802.11]");

	t = (u_int8_t*)p + sizeof(struct ieee80211_radiotap_header);

	if ((present = letoh32(rh->it_present)) == 0)
		goto out;

	printf(", <radiotap v%u", rh->it_version);

#define RADIOTAP(_x)	\
	(present & (1 << IEEE80211_RADIOTAP_##_x))

	if (RADIOTAP(TSFT)) {
		u_int64_t tsf;

		TCHECK2(*t, 8);
		bcopy(t, &tsf, sizeof(u_int64_t));
		if (vflag > 1)
			printf(", tsf %llu", letoh64(tsf));
		t += 8;
	}

	if (RADIOTAP(FLAGS)) {
		u_int8_t flags = *(u_int8_t*)t;
		TCHECK2(*t, 1);

		if (flags & IEEE80211_RADIOTAP_F_CFP)
			printf(", CFP");
		if (flags & IEEE80211_RADIOTAP_F_SHORTPRE)
			printf(", SHORTPRE");
		if (flags & IEEE80211_RADIOTAP_F_WEP)
			printf(", WEP");
		if (flags & IEEE80211_RADIOTAP_F_FRAG)
			printf(", FRAG");
		t += 1;
	}

	if (RADIOTAP(RATE)) {
		TCHECK2(*t, 1);
		if (vflag) {
			uint8_t rate = *(u_int8_t*)t;
			if (rate & 0x80)
				printf(", MCS %u", rate & 0x7f);
			else
				printf(", %uMbit/s", rate / 2);
		}
		t += 1;
	}

	if (RADIOTAP(CHANNEL)) {
		u_int16_t freq, flags;
		TCHECK2(*t, 2);

		bcopy(t, &freq, sizeof(u_int16_t));
		freq = letoh16(freq);
		t += 2;
		TCHECK2(*t, 2);
		bcopy(t, &flags, sizeof(u_int16_t));
		flags = letoh16(flags);
		t += 2;

		printf(", chan %u", ieee80211_any2ieee(freq, flags));

		if (flags & IEEE80211_CHAN_HT)
			printf(", 11n");
		else if (flags & IEEE80211_CHAN_DYN &&
		    flags & IEEE80211_CHAN_2GHZ)
			printf(", 11g");
		else if (flags & IEEE80211_CHAN_CCK &&
		    flags & IEEE80211_CHAN_2GHZ)
			printf(", 11b");
		else if (flags & IEEE80211_CHAN_OFDM &&
		    flags & IEEE80211_CHAN_2GHZ)
			printf(", 11G");
		else if (flags & IEEE80211_CHAN_OFDM &&
		    flags & IEEE80211_CHAN_5GHZ)
			printf(", 11a");

		if (flags & IEEE80211_CHAN_XR)
			printf(", XR");
	}

	if (RADIOTAP(FHSS)) {
		TCHECK2(*t, 2);
		printf(", fhss %u/%u", *(u_int8_t*)t, *(u_int8_t*)t + 1);
		t += 2;
	}

	if (RADIOTAP(DBM_ANTSIGNAL)) {
		TCHECK(*t);
		printf(", sig %ddBm", *(int8_t*)t);
		t += 1;
	}

	if (RADIOTAP(DBM_ANTNOISE)) {
		TCHECK(*t);
		printf(", noise %ddBm", *(int8_t*)t);
		t += 1;
	}

	if (RADIOTAP(LOCK_QUALITY)) {
		TCHECK2(*t, 2);
		if (vflag) {
			bcopy(t, &tmp, sizeof(u_int16_t));
			printf(", quality %u", letoh16(tmp));
		}
		t += 2;
	}

	if (RADIOTAP(TX_ATTENUATION)) {
		TCHECK2(*t, 2);
		if (vflag) {
			bcopy(t, &tmp, sizeof(u_int16_t));
			printf(", txatt %u", letoh16(tmp));
		}
		t += 2;
	}

	if (RADIOTAP(DB_TX_ATTENUATION)) {
		TCHECK2(*t, 2);
		if (vflag) {
			bcopy(t, &tmp, sizeof(u_int16_t));
			printf(", txatt %udB", letoh16(tmp));
		}
		t += 2;
	}

	if (RADIOTAP(DBM_TX_POWER)) {
		TCHECK(*t);
		printf(", txpower %ddBm", *(int8_t*)t);
		t += 1;
	}

	if (RADIOTAP(ANTENNA)) {
		TCHECK(*t);
		if (vflag)
			printf(", antenna %u", *(u_int8_t*)t);
		t += 1;
	}

	if (RADIOTAP(DB_ANTSIGNAL)) {
		TCHECK(*t);
		printf(", signal %udB", *(u_int8_t*)t);
		t += 1;
	}

	if (RADIOTAP(DB_ANTNOISE)) {
		TCHECK(*t);
		printf(", noise %udB", *(u_int8_t*)t);
		t += 1;
	}

	if (RADIOTAP(FCS)) {
		TCHECK2(*t, 4);
		if (vflag) {
			u_int32_t fcs;
			bcopy(t, &fcs, sizeof(u_int32_t));
			printf(", fcs %08x", letoh32(fcs));
		}
		t += 4;
	}

	if (RADIOTAP(RSSI)) {
		u_int8_t rssi, max_rssi;
		TCHECK(*t);
		rssi = *(u_int8_t*)t;
		t += 1;
		TCHECK(*t);
		max_rssi = *(u_int8_t*)t;
		t += 1;

		printf(", rssi %u/%u", rssi, max_rssi);
	}

#undef RADIOTAP

	putchar('>');
	goto out;

 trunc:
	/* Truncated frame */
	printf("[|radiotap + 802.11]");

 out:
	if (!ieee80211_encap) {
		if (xflag)
			default_print(p, h->len);
		putchar('\n');
	}
}

void
ieee80211_reason(u_int16_t reason)
{
	if (!vflag)
		return;

	switch (reason) {
	case IEEE80211_REASON_UNSPECIFIED:
		printf(", unspecified failure");
		break;
	case IEEE80211_REASON_AUTH_EXPIRE:
		printf(", authentication expired");
		break;
	case IEEE80211_REASON_AUTH_LEAVE:
		printf(", deauth - station left");
		break;
	case IEEE80211_REASON_ASSOC_EXPIRE:
		printf(", association expired");
		break;
	case IEEE80211_REASON_ASSOC_TOOMANY:
		printf(", too many associated stations");
		break;
	case IEEE80211_REASON_NOT_AUTHED:
		printf(", not authenticated");
		break;
	case IEEE80211_REASON_NOT_ASSOCED:
		printf(", not associated");
		break;
	case IEEE80211_REASON_ASSOC_LEAVE:
		printf(", disassociated - station left");
		break;
	case IEEE80211_REASON_ASSOC_NOT_AUTHED:
		printf(", association but not authenticated");
		break;
	case IEEE80211_REASON_RSN_REQUIRED:
		printf(", rsn required");
		break;
	case IEEE80211_REASON_RSN_INCONSISTENT:
		printf(", rsn inconsistent");
		break;
	case IEEE80211_REASON_IE_INVALID:
		printf(", ie invalid");
		break;
	case IEEE80211_REASON_MIC_FAILURE:
		printf(", mic failure");
		break;
	default:
		printf(", unknown reason %u", reason);
	}
}
@


1.39
log
@Make tcpdump show HT protection settings consistently. Previously, nothing
was displayed if HT protection was disabled. Now it displays as "htprot none".
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.38 2017/01/29 15:16:14 stsp Exp $	*/
d104 3
d607 187
d939 1
a939 1
				ieee80211_print_element(data, len);
@


1.38
log
@Fix tcpdump(8) display of duration values provided in 802.11 control frames.
These values are in microseconds, not milliseconds.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.37 2016/12/18 11:15:02 stsp Exp $	*/
d488 1
a488 1
	int sco, prot, i;
d538 1
a538 1
	prot = ((htopinfo[1] & IEEE80211_HTOP1_PROT_MASK)
d540 17
a556 6
	if (prot == 1)
		printf(",protect non-member");
	else if (prot == 2)
		printf(",protect 20MHz");
	else if (prot == 3)
		printf(",protect non-HT");
@


1.37
log
@Remove duplicated lines of code introduced in my previous tcpdump commit.
Noticed by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.36 2016/12/18 10:38:01 stsp Exp $	*/
d899 1
a899 1
			printf(", duration %dms", (t[0] | t[1] << 8));
d930 1
a930 1
			printf(", duration %dms", (t[0] | t[1] << 8));
@


1.36
log
@Make tcpdump show "11n" for a channel which is used in 11n mode.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.35 2016/11/19 19:35:46 stsp Exp $	*/
a1105 3
		else if (flags & IEEE80211_CHAN_DYN &&
		    flags & IEEE80211_CHAN_2GHZ)
			printf(", 11g");
@


1.35
log
@Make tcpdump indicate basic rates listed in beacons with an asterisk.
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.34 2016/10/08 14:45:11 stsp Exp $	*/
d1104 6
a1109 1
		if (flags & IEEE80211_CHAN_DYN &&
@


1.34
log
@Make tcpdump show MCS stored in radiotap's rate field.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.33 2016/09/02 17:11:46 stsp Exp $	*/
d682 4
a685 2
				printf(" %uM",
				    (data[0] & IEEE80211_RATE_VAL) / 2);
@


1.33
log
@Make tcpdump print details about association requests in verbose mode.
Refactor such that we can share some of the code for beacon printing.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.32 2016/02/21 16:09:47 stsp Exp $	*/
d1078 7
a1084 2
		if (vflag)
			printf(", %uMbit/s", (*(u_int8_t*)t) / 2);
@


1.32
log
@Make tcpdump show details of beacon country elements in verbose mode only.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.31 2016/02/04 10:58:48 stsp Exp $	*/
d104 3
a106 1
int	 ieee80211_elements(struct ieee80211_frame *, u_int);
d594 1
a594 1
ieee80211_elements(struct ieee80211_frame *wh, u_int flen)
d596 6
a601 4
	u_int8_t *buf, *frm;
	u_int64_t tstamp;
	u_int16_t bintval, capinfo;
	int i;
a602 1
	buf = (u_int8_t *)wh;
a604 1
	TCHECK2(*frm, 8);
a606 1

a609 1
	TCHECK2(*frm, 2);
a611 1

a614 1
	TCHECK2(*frm, 2);
d617 21
d639 2
d642 20
a661 2
		printb(", caps", letoh16(capinfo),
		    IEEE80211_CAPINFO_BITS);
d670 1
a670 1
#define ELEM_CHECK(l)	if (len != l) break
d831 6
a836 1
			if (ieee80211_elements(wh, len) != 0)
@


1.31
log
@Fix an infinite loop when printing a country element in a management
frame in case we hit channel Tx power limits we can't pretty-print.
Also ensure we consume the last item in this list.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.30 2016/02/03 16:08:09 stsp Exp $	*/
d676 2
a677 1
			ieee80211_print_country(data, len);
@


1.30
log
@Make tcpdump show 802.11 control frames.
ok kettenis@@, and help from David Vasek (thanks!)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.29 2016/02/01 10:09:44 stsp Exp $	*/
d298 1
a298 1
	while (len > 3)	{
d304 2
@


1.29
log
@Make tcpdump show 802.11 QoS frames properly.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.28 2016/01/12 09:28:10 stsp Exp $	*/
d40 19
d835 64
@


1.28
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.27 2015/10/13 14:36:15 stsp Exp $	*/
a155 1
	struct ieee80211_frame_addr4 *w4;
d158 3
d163 12
a174 3
	TCHECK(*wh);
	t += sizeof(struct ieee80211_frame);
	datalen = len - sizeof(struct ieee80211_frame);
d190 19
a208 6
		w4 = (struct ieee80211_frame_addr4 *) wh;
		TCHECK(*w4);
		t = (u_int8_t *) (w4 + 1);
		datalen = len - sizeof(*w4);
		esrc = w4->i_addr4;
		edst = w4->i_addr3;
@


1.27
log
@Don't use exp2f(), it breaks build on vax. Use a shift instead.
reported by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.26 2015/10/12 13:01:50 stsp Exp $	*/
a955 2
		if (flags & IEEE80211_CHAN_TURBO)
			printf(", TURBO");
@


1.26
log
@Fix a copy-pasto: Check the correct bit for STBC beacon in HT OP element.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.25 2015/10/10 07:52:30 stsp Exp $	*/
a35 1
#include <math.h>
d366 1
a366 1
		    (int)(exp2f(13 + (ampdu & IEEE80211_AMPDU_PARAM_LE)) - 1));
@


1.25
log
@Make tcpdump(1) print more information from the HT Capabilities element.
tweak + ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.24 2015/07/19 02:49:54 stsp Exp $	*/
d522 1
a522 1
	if ((htopinfo[4] << 8) & IEEE80211_HTOP2_DUALCTSPROT)
@


1.24
log
@In tcpdump, show 11n HTOP primary and secondary channel numbers for 40MHz BSS,
instead of showing just the primary one and "above" or "below" for secondary.
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.23 2015/07/18 23:35:01 stsp Exp $	*/
d36 1
d283 1
a283 1
	u_int16_t htcaps;
d285 3
d354 77
@


1.23
log
@Make tcpdump show HTOP elements in 11n management frames; ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.22 2015/07/17 19:43:43 stsp Exp $	*/
d376 1
a376 1
	if (sco == 0)
d378 19
a396 5
	else if (sco == 1)
		printf("40MHz primary chan %d secondary above", primary_chan);
	else if (sco == 3)
		printf("40MHz primary chan %d secondary below", primary_chan);
	else
@


1.22
log
@Make tcpdump decode the country element in 802.11 mgmt frames.
much help and ok zhuk@@, ok sthen@@ for an earlier version
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.21 2015/07/17 17:41:41 stsp Exp $	*/
d84 1
d354 98
d581 5
@


1.21
log
@Make tcpdump display BSS load information contained in 802.11 mgmt frames.
ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.20 2015/07/16 23:34:54 sthen Exp $	*/
d32 1
d82 1
d238 41
d438 1
a438 2
			for (i = len; i > 0; i--, data++)
				printf(" %u", data[0]);
d482 4
@


1.20
log
@add missing ELEM_CHECK for csa printing, spotted by / ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.19 2015/07/16 20:57:13 stsp Exp $	*/
d440 8
@


1.19
log
@Make tcpdump show 11n HT capabilities in 802.11 management frames.
ok deraadt@@ zhuk@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.18 2015/07/15 03:05:00 stsp Exp $	*/
d404 1
@


1.18
log
@Unbreak the tree. Remove use of removed ieee80211 element IDs from hostapd
and from tcpdump.
Pointed out by James Hartley.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.17 2015/04/08 21:44:16 sthen Exp $	*/
d81 1
d234 76
d434 5
@


1.17
log
@Teach the 802.11 printer about Channel Switch Announcements (advertised by
an AP in beacons in the run-up to a channel switch, either for radar avoidance,
or for frequency management). ok stsp@@

We don't support these in net80211 yet (as pointed out by stsp a few days ago)
but it's useful to at least have a way to debug why your connection is getting
knocked down!
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.16 2015/01/16 06:40:21 deraadt Exp $	*/
d348 2
a349 2
		case IEEE80211_ELEMID_TPC:
			printf(", tpc");
d353 2
a354 2
		case IEEE80211_ELEMID_CCKM:
			printf(", cckm");
@


1.16
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.15 2014/08/14 12:44:44 mpi Exp $	*/
d325 4
@


1.15
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.14 2014/07/20 17:52:34 stsp Exp $	*/
a18 1
#include <sys/param.h>
@


1.14
log
@Fix tcpdump(8) display of logical link control data in IEEE802 frames.
The frame subtype field is in the first byte of frame control but tcpdump(8)
was looking at the second byte to determine if this is a data frame.
Patch by Nathanael Rensen, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.13 2013/01/17 02:53:07 claudio Exp $	*/
a27 1
#include <netinet/in_systm.h>
@


1.13
log
@Dump some more flags and subtypes in tcpdump. Especially flags used in
power saving mode. OK giovanni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.12 2007/08/14 19:10:45 mglocker Exp $	*/
d156 1
a156 1
	int data = !(wh->i_fc[1] & IEEE80211_FC0_SUBTYPE_NODATA);
@


1.12
log
@Fix Segmentation fault for tcpdump when used in combination with
``-v -y IEEE802_11'', and ``-v -y IEEE802_11_RADIO''.  The snaplen
was passed instead of the real packet size at some point, which caused
tcpdump todo tcp checksum verifications on packets where it shouldn't.

Diff from canacar@@ and me, tested by canacar@@, reyk@@, and me.

OK canacar@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.11 2007/07/02 22:09:01 canacar Exp $	*/
d55 2
a56 2
	"reserved#13",
	"reserved#14",
d60 19
d156 2
d165 2
a166 1
		llc_print(t, datalen, datalen, wh->i_addr2, wh->i_addr3);
d169 2
a170 1
		llc_print(t, datalen, datalen, wh->i_addr3, wh->i_addr1);
d173 2
a174 1
		llc_print(t, datalen, datalen, wh->i_addr2, wh->i_addr1);
d181 2
a182 1
		llc_print(t, datalen, datalen, w4->i_addr4, w4->i_addr3);
d186 6
d394 3
d399 2
a400 1
		printf(": data: ");
a458 3

	if (wh->i_fc[1] & IEEE80211_FC1_WEP)
		printf(", WEP");
@


1.11
log
@Display payload for DS to DS and NO DS traffic.
ok reyk@@, looks ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.10 2007/06/03 23:47:28 reyk Exp $	*/
d477 1
a477 1
	if (ieee80211_print(wh, (u_int)h->caplen) != 0)
d482 1
a482 1
			default_print(p, (u_int)h->caplen);
d507 1
a507 1
	len = h->caplen;
d697 1
a697 1
			default_print(p, h->caplen);
@


1.10
log
@unbreak 802.11 element parsing by using the TCHECK2 macro correctly

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.9 2007/03/27 12:39:24 claudio Exp $	*/
d135 1
d138 1
a138 1
	TCHECK2(*t, sizeof(struct ieee80211_frame));
d150 2
d153 5
@


1.9
log
@Fix aligenment issues by using bcopy() and a local variable instead of the
problematic *(u_intXX_t*)t casts. This fixes the bus errors I got on sparc64
while doing IEEE802_11_RADIO dumps. OK reyk@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.8 2007/03/26 16:41:33 claudio Exp $	*/
d207 1
a207 1
	TCHECK2(frm, 8);
d214 1
a214 1
	TCHECK2(frm, 2);
d221 1
a221 1
	TCHECK2(frm, 2);
@


1.8
log
@Print the reason code of deauth and disassociation packets if in verbose mode.
This helps debugging issues with stations that fail to join a network.
OK mglocker@@, reyk@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.7 2006/06/23 21:53:01 reyk Exp $	*/
d117 1
d119 2
a120 1
		printf(" (seq %u): ", letoh16(*(u_int16_t *)&wh->i_seq[0]));
d200 2
a201 1
	u_int8_t *tstamp, *bintval, *capinfo;
d207 2
a208 2
	tstamp = frm;
	TCHECK2(*tstamp, 8);
d212 1
a212 1
		printf(", timestamp %llu", letoh64(*(u_int64_t *)tstamp));
d214 2
a215 2
	bintval = frm;
	TCHECK2(*bintval, 2);
d219 1
a219 1
		printf(", interval %u", letoh16(*(u_int16_t *)bintval));
d221 2
a222 2
	capinfo = frm;
	TCHECK2(*capinfo, 2);
d226 1
a226 1
		printb(", caps", letoh16(*(u_int16_t *)capinfo),
d489 1
d521 2
d524 1
d526 1
a526 1
			printf(", tsf %llu", letoh64(*(u_int64_t*)t));
d556 2
a557 1
		freq = letoh16(*(u_int16_t*)t);
d560 2
a561 1
		flags = letoh16(*(u_int16_t*)t);
d605 4
a608 2
		if (vflag)
			printf(", quality %u", letoh16(*(u_int16_t*)t));
d614 4
a617 3
		if (vflag)
			printf(", txatt %u",
			    letoh16(*(u_int16_t*)t));
d623 4
a626 3
		if (vflag)
			printf(", txatt %udB",
			    letoh16(*(u_int16_t*)t));
d657 5
a661 2
		if (vflag)
			printf(", fcs %08x", letoh32(*(u_int32_t*)t));
@


1.7
log
@set the RSSI Max value in ath(4) and use the new RSSI radiotap header
instead of the old db signal header. also allow tcpdump and hostapd to
print the new RSSI radiotap header values current/max rssi.

ok damien@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.6 2005/12/18 17:52:46 reyk Exp $	*/
d68 1
d402 5
d675 51
@


1.6
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.5 2005/11/22 11:36:12 reyk Exp $	*/
d641 12
@


1.5
log
@add printer for IAPP and hostapd(8) messages

ok canacar@@, tested by aanriot@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.4 2005/05/28 09:01:52 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.4
log
@support decapsulation of 802.11 data frames

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.3 2005/03/09 11:43:17 deraadt Exp $	*/
d71 2
d454 2
a455 1
	ts_print(&h->ts);
d463 5
a467 4
	if (xflag)
		default_print(p, (u_int)h->caplen);

	putchar('\n');
d481 2
a482 1
	ts_print(&h->ts);
d492 1
a492 1
		printf("[?radiotap + 802.11 v:%u]\n", rh->it_version);
d653 5
a657 3
	if (xflag)
		default_print(p, h->caplen);
	putchar('\n');
@


1.3
log
@simplification; ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.2 2005/03/08 14:55:41 deraadt Exp $	*/
d61 1
d126 29
d351 2
a352 1
		printf(": data");
@


1.2
log
@make this compile on strict-alignment architectures.  someone send
reyk a sparc64 please!
@
text
@d1 1
a1 1
/*	$OpenBSD: print-802_11.c,v 1.1 2005/03/07 16:13:38 reyk Exp $	*/
d129 1
a130 1
	u_int8_t *p;
d133 1
a133 1
	for (i = 0, p = data; i < len; i++, p++) {
a134 1
	}
d141 1
a142 1
	u_int8_t *p;
d157 1
a157 1
	} else {
a158 1
	}
d191 1
a191 1
			IEEE80211_CAPINFO_BITS);
a432 2

	return;
a609 1

a618 1

a619 2

	return;
@


1.1
log
@add a printer for 802.11 and for additional radiotap headers,
use -y IEEE802_11 or IEEE802_11_RADIO if supported by the driver.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d486 1
d488 1
a488 1
		u_int8_t flags = *(u_int8_t*)t;
@

