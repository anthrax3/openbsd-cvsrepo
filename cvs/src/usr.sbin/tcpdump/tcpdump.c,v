head	1.80;
access;
symbols
	OPENBSD_6_1:1.79.0.4
	OPENBSD_6_1_BASE:1.79
	OPENBSD_6_0:1.78.0.6
	OPENBSD_6_0_BASE:1.78
	OPENBSD_5_9:1.78.0.2
	OPENBSD_5_9_BASE:1.78
	OPENBSD_5_8:1.72.0.4
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.68.0.2
	OPENBSD_5_7_BASE:1.68
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.65.0.10
	OPENBSD_5_5_BASE:1.65
	OPENBSD_5_4:1.65.0.6
	OPENBSD_5_4_BASE:1.65
	OPENBSD_5_3:1.65.0.4
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.65.0.2
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.8
	OPENBSD_5_0:1.63.0.6
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.63.0.4
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.63.0.2
	OPENBSD_4_8_BASE:1.63
	OPENBSD_4_7:1.62.0.2
	OPENBSD_4_7_BASE:1.62
	OPENBSD_4_6:1.61.0.6
	OPENBSD_4_6_BASE:1.61
	OPENBSD_4_5:1.61.0.2
	OPENBSD_4_5_BASE:1.61
	OPENBSD_4_4:1.60.0.2
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.59.0.2
	OPENBSD_4_3_BASE:1.59
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.55.0.4
	OPENBSD_4_1_BASE:1.55
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.49.0.2
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.27.0.4
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.80
date	2017.09.08.19.10.57;	author brynet;	state Exp;
branches;
next	1.79;
commitid	Zjq9j60IOf1zHWPz;

1.79
date	2016.11.16.13.47.27;	author reyk;	state Exp;
branches;
next	1.78;
commitid	XyJooSdwV3dkETpz;

1.78
date	2015.12.22.21.01.07;	author mmcc;	state Exp;
branches;
next	1.77;
commitid	2fFDLAOGZEyS0nuD;

1.77
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.76;
commitid	enjTsnD5UO6xazKc;

1.76
date	2015.10.28.12.28.14;	author jca;	state Exp;
branches;
next	1.75;
commitid	0Lo3UeBWbwdhuhzA;

1.75
date	2015.10.14.04.55.17;	author guenther;	state Exp;
branches;
next	1.74;
commitid	FoAGJDCiesKJyWSq;

1.74
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	sbrB3Q5CNxcwZpfU;

1.73
date	2015.10.03.00.51.08;	author deraadt;	state Exp;
branches;
next	1.72;
commitid	YbgJcqz31YZWm8nH;

1.72
date	2015.07.14.20.23.40;	author deraadt;	state Exp;
branches;
next	1.71;
commitid	KnDOzicNjGqmISR3;

1.71
date	2015.07.12.19.58.00;	author naddy;	state Exp;
branches;
next	1.70;
commitid	5THhmsqmzzYI9j9t;

1.70
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	6b2lLILbgCR1fvia;

1.69
date	2015.04.15.02.32.28;	author deraadt;	state Exp;
branches;
next	1.68;
commitid	2T644fg5Mjn5ayVM;

1.68
date	2015.02.09.23.00.14;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	822YD61EeG0Xl9Na;

1.67
date	2014.11.26.18.34.52;	author millert;	state Exp;
branches;
next	1.66;
commitid	9QOFSShUOtA0kQLF;

1.66
date	2014.06.30.04.25.11;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	MUfCbXZelRfRbmuN;

1.65
date	2012.07.11.10.37.38;	author sthen;	state Exp;
branches;
next	1.64;

1.64
date	2012.07.10.18.07.37;	author sthen;	state Exp;
branches;
next	1.63;

1.63
date	2010.06.26.16.47.07;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2009.02.14.11.18.56;	author sthen;	state Exp;
branches;
next	1.60;

1.60
date	2008.04.18.21.35.11;	author djm;	state Exp;
branches;
next	1.59;

1.59
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.08.28.12.52.06;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2007.08.13.20.27.13;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.01.18.19.40;	author todd;	state Exp;
branches;
next	1.55;

1.55
date	2006.06.16.16.55.46;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2006.04.22.19.26.05;	author moritz;	state Exp;
branches;
next	1.53;

1.53
date	2006.04.22.17.24.33;	author moritz;	state Exp;
branches;
next	1.52;

1.52
date	2006.04.21.23.09.34;	author cloder;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.17.23.49.59;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.13.19.05.56;	author moritz;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.15.20.34.23;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.18.11.06.51;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.07.19.45.26;	author mpf;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.28.09.01.52;	author reyk;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.22.18.41.34;	author moritz;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.30.22.13.54;	author moritz;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.25.13.45.30;	author moritz;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.07.16.13.38;	author reyk;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.06.21.05.49;	author jmc;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.06.18.44.50;	author reyk;	state Exp;
branches;
next	1.39;

1.39
date	2004.09.16.11.29.51;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.20.17.51.55;	author avsm;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.21.05.48.50;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.28.02.17.03;	author mcbride;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.28.19.44.55;	author canacar;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.25.13.32.58;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.21.19.14.23;	author frantzen;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.17.08.45.37;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.14.08.50.37;	author canacar;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.30.13.56.23;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.30.00.20.46;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.29.18.27.54;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.23.23.32.20;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.07.22.34.28;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.07.18.48.00;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.07.07.41.21;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.02.16.19.27;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.25.23.05.17;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.19.17.53.19;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.10.19.05.21;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.03.14.21.57;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.30.05.23.28;	author ericj;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.26.21.35.44;	author jakob;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.26.05.24.25;	author ericj;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.16.13.36.36;	author jakob;	state Exp;
branches;
next	1.14;

1.14
date	99.09.16.20.58.48;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	99.07.28.20.41.37;	author jakob;	state Exp;
branches;
next	1.12;

1.12
date	99.06.29.20.33.29;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.09.22.22.03.02;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	98.06.25.19.42.48;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	98.06.11.00.01.24;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	98.06.04.23.11.42;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.15.23.44.25;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.12.12.16.22.21;	author bitblt;	state Exp;
branches;
next	1.5;

1.5
date	96.11.12.08.52.38;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.34;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.58;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.46;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.80
log
@fork+exec model for tcpdump(8); re-exec the privileged child after fork

While tcpdump isn't a daemon in the traditional sense, it's not uncommon
for people to have long running sessions.  At least on OpenBSD, this is
even safe thanks to the existing privsep design by otto@@, canacar@@ and
pledge(2) work done by deraadt.

ok deraadt@@
@
text
@/*	$OpenBSD: tcpdump.c,v 1.79 2016/11/16 13:47:27 reyk Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

/*
 * tcpdump - monitor tcp/ip traffic on an ethernet.
 *
 * First written in 1987 by Van Jacobson, Lawrence Berkeley Laboratory.
 * Mercilessly hacked and occasionally improved since then via the
 * combined efforts of Van, Steve McCanne and Craig Leres of LBL.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/wait.h>

#include <netinet/in.h>

#include <pcap.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>

#include "interface.h"
#include "addrtoname.h"
#include "setsignal.h"
#include "gmt2local.h"

#include <sys/socket.h>
#include <net/if.h>
#include <net/pfvar.h>
#include "pfctl.h"
#include "pfctl_parser.h"
#include "privsep.h"

int Aflag;			/* dump ascii */
int aflag;			/* translate network and broadcast addresses */
int dflag;			/* print filter code */
int eflag;			/* print ethernet header */
int fflag;			/* don't translate "foreign" IP address */
int Iflag;			/* include interface in output */
int Lflag;			/* List available link types */
int nflag;			/* leave addresses as numbers */
int Nflag;			/* remove domains from printed host names */
int Oflag = 1;			/* run filter code optimizer */
int oflag;			/* print passive OS fingerprints */
int pflag;			/* don't go promiscuous */
int qflag;			/* quick (shorter) output */
int Sflag;			/* print raw TCP sequence numbers */
int tflag = 1;			/* print packet arrival time */
int vflag;			/* verbose */
int xflag;			/* print packet in hex */
int Xflag;			/* print packet in emacs-hexl style */

int packettype;

char *program_name;
char *device = NULL;

int32_t thiszone;		/* seconds offset from gmt to local time */

extern volatile pid_t child_pid;

/* Externs */
extern void bpf_dump(struct bpf_program *, int);
extern int esp_init(char *);

/* Forwards */
void	cleanup(int);
void	gotchld(int);
extern __dead void usage(void);

/* Length of saved portion of packet. */
int snaplen = 0;

struct printer {
	pcap_handler f;
	int type;
};

/* XXX needed if using old bpf.h */
#ifndef DLT_ATM_RFC1483
#define DLT_ATM_RFC1483 11
#endif

static struct printer printers[] = {
	{ ether_if_print,		DLT_EN10MB },
	{ ether_if_print,		DLT_IEEE802 },
	{ sl_if_print,			DLT_SLIP },
	{ sl_bsdos_if_print,		DLT_SLIP_BSDOS },
	{ ppp_if_print,			DLT_PPP },
	{ fddi_if_print,		DLT_FDDI },
	{ null_if_print,		DLT_NULL },
	{ raw_if_print,			DLT_RAW },
	{ atm_if_print,			DLT_ATM_RFC1483 },
	{ loop_if_print,		DLT_LOOP },
	{ enc_if_print,			DLT_ENC },
	{ pflog_if_print,		DLT_PFLOG },
	{ pfsync_if_print,		DLT_PFSYNC },
	{ ppp_ether_if_print,		DLT_PPP_ETHER },
	{ ieee802_11_if_print,		DLT_IEEE802_11 },
	{ ieee802_11_radio_if_print,	DLT_IEEE802_11_RADIO },
	{ ofp_if_print,			DLT_OPENFLOW },
	{ NULL,				0 },
};

static pcap_handler
lookup_printer(int type)
{
	struct printer *p;

	for (p = printers; p->f; ++p) {
		if (type == p->type)
			return p->f;
	}

	error("unknown data link type 0x%x", type);
	/* NOTREACHED */
}

static int
init_pfosfp(void)
{
	pf_osfp_initialize();
	if (pfctl_file_fingerprints(-1,
	    PF_OPT_QUIET|PF_OPT_NOACTION, PF_OSFP_FILE) == 0)
		return 1;
	return 0;
}

static pcap_t *pd;

/* Multiple DLT support */
void		 pcap_list_linktypes(pcap_t *);
void		 pcap_print_linktype(u_int);

void
pcap_print_linktype(u_int dlt)
{
	const char *name;

	if ((name = pcap_datalink_val_to_name(dlt)) != NULL)
		fprintf(stderr, "%s\n", name);
	else
		fprintf(stderr, "<unknown: %u>\n", dlt);
}

void
pcap_list_linktypes(pcap_t *p)
{
	int fd = p->fd;
	u_int n;

#define MAXDLT	100

	u_int dltlist[MAXDLT];
	struct bpf_dltlist dl = {MAXDLT, dltlist};

	if (fd < 0)
		error("Invalid bpf descriptor");

	if (ioctl(fd, BIOCGDLTLIST, &dl) < 0)
		err(1, "BIOCGDLTLIST");

	if (dl.bfl_len > MAXDLT)
		error("Invalid number of linktypes: %u", dl.bfl_len);

	fprintf(stderr, "%d link type%s supported:\n", dl.bfl_len,
	    dl.bfl_len == 1 ? "" : "s");

	for (n = 0; n < dl.bfl_len; n++) {
		fprintf(stderr, "\t");
		pcap_print_linktype(dltlist[n]);
	}
}

int
main(int argc, char **argv)
{
	int cnt = -1, op, i;
	bpf_u_int32 localnet, netmask;
	char *cp, *infile = NULL, *RFileName = NULL;
	char ebuf[PCAP_ERRBUF_SIZE], *WFileName = NULL;
	pcap_handler printer;
	struct bpf_program *fcode;
	u_char *pcap_userdata;
	u_int dirfilt = 0, dlt = (u_int) -1;
	const char *errstr;

	if ((cp = strrchr(argv[0], '/')) != NULL)
		program_name = cp + 1;
	else
		program_name = argv[0];

	/* '-P' used internally, exec privileged portion */
	if (argc >= 2 && strcmp("-P", argv[1]) == 0)
		priv_exec(argc, argv);

	if (priv_init(argc, argv))
		error("Failed to setup privsep");

	/* state: STATE_INIT */

	opterr = 0;
	while ((op = getopt(argc, argv,
	    "Aac:D:deE:fF:i:IlLnNOopqr:s:StT:vw:xXy:Y")) != -1)
		switch (op) {

		case 'A':
			xflag = 1;
			Aflag = 1;
			break;

		case 'a':
			aflag = 1;
			break;

		case 'c':
			cnt = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				error("invalid packet count %s: %s",
				    optarg, errstr);
			break;

		case 'D':
			if (strcasecmp(optarg, "in") == 0)
				dirfilt = BPF_DIRECTION_OUT;
			else if (strcasecmp(optarg, "out") == 0)
				dirfilt = BPF_DIRECTION_IN;
			else
				error("invalid traffic direction %s", optarg);
			break;

		case 'd':
			++dflag;
			break;
		case 'e':
			eflag = 1;
			break;

		case 'f':
			fflag = 1;
			break;

		case 'F':
			infile = optarg;
			break;

		case 'i':
			device = optarg;
			break;

		case 'I':
			Iflag = 1;
			break;

		case 'l':
			setvbuf(stdout, NULL, _IOLBF, 0);
			break;
		case 'L':
			Lflag = 1;
			break;
		case 'n':
			nflag = 1;
			break;

		case 'N':
			Nflag = 1;
			break;

		case 'O':
			Oflag = 0;
			break;

		case 'o':
			oflag = 1;
			break;

		case 'p':
			pflag = 1;
			break;

		case 'q':
			qflag = 1;
			break;

		case 'r':
			RFileName = optarg;
			break;

		case 's':
			snaplen = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				error("invalid snaplen %s: %s", optarg, errstr);
			break;

		case 'S':
			Sflag = 1;
			break;

		case 't':
			--tflag;
			break;

		case 'T':
			if (strcasecmp(optarg, "vat") == 0)
				packettype = PT_VAT;
			else if (strcasecmp(optarg, "wb") == 0)
				packettype = PT_WB;
			else if (strcasecmp(optarg, "rpc") == 0)
				packettype = PT_RPC;
			else if (strcasecmp(optarg, "rtp") == 0)
				packettype = PT_RTP;
			else if (strcasecmp(optarg, "rtcp") == 0)
				packettype = PT_RTCP;
			else if (strcasecmp(optarg, "cnfp") == 0)
				packettype = PT_CNFP;
			else if (strcasecmp(optarg, "vrrp") == 0)
				packettype = PT_VRRP;
			else if (strcasecmp(optarg, "tcp") == 0)
				packettype = PT_TCP;
			else if (strcasecmp(optarg, "sack") == 0)
				/*
				 * kept for compatibility; DEFAULT_SNAPLEN
				 * used to be too short to capture SACK.
				 */
				;
			else
				error("unknown packet type `%s'", optarg);
			break;

		case 'v':
			++vflag;
			break;

		case 'w':
			WFileName = optarg;
			break;
#ifdef YYDEBUG
		case 'Y':
			{
			/* Undocumented flag */
			extern int yydebug;
			yydebug = 1;
			}
			break;
#endif
		case 'y':
			i = pcap_datalink_name_to_val(optarg);
			if (i < 0)
				error("invalid data link type: %s", optarg);
			dlt = (u_int)i;
			break;

		case 'x':
			xflag = 1;
			break;

		case 'X':
			Xflag = 1;
			xflag = 1;
			break;

		case 'E':
			if (esp_init(optarg) < 0)
				error("bad esp specification `%s'", optarg);
			break;

		default:
			usage();
			/* NOTREACHED */
		}

	if (snaplen == 0) {
		switch (dlt) {
		case DLT_IEEE802_11:
			snaplen = IEEE802_11_SNAPLEN;
			break;
		case DLT_IEEE802_11_RADIO:
			snaplen = IEEE802_11_RADIO_SNAPLEN;
			break;
		default:
			snaplen = DEFAULT_SNAPLEN;
			break;
		}
	}

	if (aflag && nflag)
		error("-a and -n options are incompatible");

	if (RFileName != NULL) {
		pd = priv_pcap_offline(RFileName, ebuf);
		if (pd == NULL)
			error("%s", ebuf);
		/* state: STATE_BPF */
		localnet = 0;
		netmask = 0;
		if (fflag != 0)
			error("-f and -r options are incompatible");
	} else {
		if (device == NULL) {
			device = pcap_lookupdev(ebuf);
			if (device == NULL)
				error("%s", ebuf);
		}
		pd = priv_pcap_live(device, snaplen, !pflag, 1000, ebuf,
		    dlt, dirfilt);
		if (pd == NULL)
			error("%s", ebuf);

		/* state: STATE_BPF */
		if (pcap_lookupnet(device, &localnet, &netmask, ebuf)) {
			if (fflag)
				warning("%s", ebuf);
			localnet = 0;
			netmask = 0;
		}
	}
	i = pcap_snapshot(pd);
	if (snaplen < i) {
		warning("snaplen raised from %d to %d", snaplen, i);
		snaplen = i;
	}

	if (Lflag) {
		pcap_list_linktypes(pd);
		exit(0);
	}

	fcode = priv_pcap_setfilter(pd, Oflag, netmask);
	/* state: STATE_FILTER */
	if (fcode == NULL)
		error("%s", pcap_geterr(pd));
	if (dflag) {
		bpf_dump(fcode, dflag);
		exit(0);
	}
	init_addrtoname(localnet, netmask);

	if (WFileName) {
		pcap_dumper_t *p;

		p = priv_pcap_dump_open(pd, WFileName);
		/* state: STATE_RUN */
		if (p == NULL)
			error("%s", pcap_geterr(pd));
		{
			FILE *fp = (FILE *)p;	/* XXX touching pcap guts! */
			fflush(fp);
			setvbuf(fp, NULL, _IONBF, 0);
		}
		printer = pcap_dump;
		pcap_userdata = (u_char *)p;
	} else {
		printer = lookup_printer(pcap_datalink(pd));
		pcap_userdata = NULL;
		priv_init_done();
		/* state: STATE_RUN */
	}
	if (RFileName == NULL) {
		(void)fprintf(stderr, "%s: listening on %s, link-type ",
		    program_name, device);
		pcap_print_linktype(pd->linktype);
		(void)fflush(stderr);
	}

	if (oflag)
		oflag = init_pfosfp();
	if (tflag > 0)
		thiszone = gmt2local(0);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if (pcap_loop(pd, cnt, printer, pcap_userdata) < 0) {
		(void)fprintf(stderr, "%s: pcap_loop: %s\n",
		    program_name, pcap_geterr(pd));
		exit(1);
	}
	pcap_close(pd);
	exit(0);
}

/* make a clean exit on interrupts */
void
cleanup(int signo)
{
	struct pcap_stat stat;
	sigset_t allsigs;
	char buf[1024];

	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, NULL);

	/* Can't print the summary if reading from a savefile */
	(void)write(STDERR_FILENO, "\n", 1);
	if (pd != NULL && pcap_file(pd) == NULL) {
		if (priv_pcap_stats(&stat) < 0) {
			(void)snprintf(buf, sizeof buf,
			    "pcap_stats: %s\n", pcap_geterr(pd));
			write(STDERR_FILENO, buf, strlen(buf));
		} else {
			(void)snprintf(buf, sizeof buf,
			    "%u packets received by filter\n", stat.ps_recv);
			write(STDERR_FILENO, buf, strlen(buf));
			(void)snprintf(buf, sizeof buf,
			    "%u packets dropped by kernel\n", stat.ps_drop);
			write(STDERR_FILENO, buf, strlen(buf));
		}
	}
	_exit(0);
}

void
gotchld(int signo)
{
	pid_t pid;
	int status;
	int save_err = errno;

	do {
		pid = waitpid(child_pid, &status, WNOHANG);
		if (pid > 0 && (WIFEXITED(status) || WIFSIGNALED(status)))
			cleanup(0);
	} while (pid == -1 && errno == EINTR);

	if (pid == -1)
		_exit(1);

	errno = save_err;
}

/* dump the buffer in `emacs-hexl' style */
void
default_print_hexl(const u_char *cp, unsigned int length)
{
	unsigned int i, j, jm;
	int c;
	char ln[128], buf[128];

	printf("\n");
	for (i = 0; i < length; i += 0x10) {
		snprintf(ln, sizeof(ln), "  %04x: ", (unsigned int)i);
		jm = length - i;
		jm = jm > 16 ? 16 : jm;

		for (j = 0; j < jm; j++) {
			if ((j % 2) == 1)
				snprintf(buf, sizeof(buf), "%02x ",
				    (unsigned int)cp[i+j]);
			else
				snprintf(buf, sizeof(buf), "%02x",
				    (unsigned int)cp[i+j]);
			strlcat(ln, buf, sizeof ln);
		}
		for (; j < 16; j++) {
			if ((j % 2) == 1)
				snprintf(buf, sizeof buf, "   ");
			else
				snprintf(buf, sizeof buf, "  ");
			strlcat(ln, buf, sizeof ln);
		}

		strlcat(ln, " ", sizeof ln);
		for (j = 0; j < jm; j++) {
			c = cp[i+j];
			c = isprint(c) ? c : '.';
			buf[0] = c;
			buf[1] = '\0';
			strlcat(ln, buf, sizeof ln);
		}
		printf("%s\n", ln);
	}
}

/* dump the text from the buffer */
void
default_print_ascii(const u_char *cp, unsigned int length)
{
	int c, i;

	printf("\n");
	for (i = 0; i < length; i++) {
		c = cp[i];
		if (isprint(c) || c == '\t' || c == '\n' || c == '\r')
			putchar(c);
		else
			putchar('.');
	}
}

/* Like default_print() but data need not be aligned */
void
default_print_unaligned(const u_char *cp, u_int length)
{
	u_int i, s;
	int nshorts;

	if (Xflag) {
		/* dump the buffer in `emacs-hexl' style */
		default_print_hexl(cp, length);
	} else if (Aflag) {
		/* dump the text in the buffer */
		default_print_ascii(cp, length);
	} else {
		/* dump the buffer in old tcpdump style */
		nshorts = (u_int) length / sizeof(u_short);
		i = 0;
		while (--nshorts >= 0) {
			if ((i++ % 8) == 0)
				(void)printf("\n\t\t\t");
			s = *cp++;
			(void)printf(" %02x%02x", s, *cp++);
		}
		if (length & 1) {
			if ((i % 8) == 0)
				(void)printf("\n\t\t\t");
			(void)printf(" %02x", *cp);
		}
	}
}

void
default_print(const u_char *bp, u_int length)
{
	const u_short *sp;
	u_int i;
	int nshorts;

	if (Xflag) {
		/* dump the buffer in `emacs-hexl' style */
		default_print_hexl(bp, length);
	} else if (Aflag) {
		/* dump the text in the buffer */
		default_print_ascii(bp, length);
	} else {
		/* dump the buffer in old tcpdump style */
		if ((long)bp & 1) {
			default_print_unaligned(bp, length);
			return;
		}
		sp = (u_short *)bp;
		nshorts = (u_int) length / sizeof(u_short);
		i = 0;
		while (--nshorts >= 0) {
			if ((i++ % 8) == 0)
				(void)printf("\n\t\t\t");
			(void)printf(" %04x", ntohs(*sp++));
		}
		if (length & 1) {
			if ((i % 8) == 0)
				(void)printf("\n\t\t\t");
			(void)printf(" %02x", *(u_char *)sp);
		}
	}
}

void
set_slave_signals(void)
{
	setsignal(SIGTERM, cleanup);
	setsignal(SIGINT, cleanup);
	setsignal(SIGCHLD, gotchld);
	setsignal(SIGHUP, cleanup);
}

__dead void
usage(void)
{
	(void)fprintf(stderr,
"Usage: %s [-AadefILlNnOopqStvXx] [-c count] [-D direction]\n",
	    program_name);
	(void)fprintf(stderr,
"\t       [-E [espalg:]espkey] [-F file] [-i interface] [-r file]\n");
	(void)fprintf(stderr,
"\t       [-s snaplen] [-T type] [-w file] [-y datalinktype] [expression]\n");
	exit(1);
}
@


1.79
log
@Add new DLT_OPENFLOW link-type to allow using tcpdump to debug switch(4),
eg. tcpdump -y openflow -i switch0

Includes a minor bump for libpcap.

Feedback and OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.78 2015/12/22 21:01:07 mmcc Exp $	*/
d220 4
@


1.78
log
@assign pointers to NULL rather than 0
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.77 2015/11/16 00:16:39 mmcc Exp $	*/
d129 1
@


1.77
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.76 2015/10/28 12:28:14 jca Exp $	*/
d477 1
a477 1
		pcap_userdata = 0;
@


1.76
log
@pcap_stat fields are unsigned, print them as such

Patch from Kevin Reay.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.75 2015/10/14 04:55:17 guenther Exp $	*/
d615 1
a615 1
default_print_unaligned(register const u_char *cp, register u_int length)
d617 2
a618 2
	register u_int i, s;
	register int nshorts;
d645 1
a645 1
default_print(register const u_char *bp, register u_int length)
d647 3
a649 3
	register const u_short *sp;
	register u_int i;
	register int nshorts;
@


1.75
log
@Remove conditional compilation and #defines around signal handling
Don't catch signals that were ignored on entry
Suppress SIGCHLD if our kid is stopped: we don't care and it's not an error

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.74 2015/10/09 01:37:09 deraadt Exp $	*/
d525 1
a525 1
			    "%d packets received by filter\n", stat.ps_recv);
d528 1
a528 1
			    "%d packets dropped by kernel\n", stat.ps_drop);
@


1.74
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.73 2015/10/03 00:51:08 deraadt Exp $	*/
d95 2
a96 2
RETSIGTYPE cleanup(int);
RETSIGTYPE gotchld(int);
d506 1
a506 2
/* ARGSUSED */
RETSIGTYPE
d535 1
a535 2
/* ARGSUSED */
RETSIGTYPE
a681 2
	RETSIGTYPE (*oldhandler)(int);

d685 1
a685 3
	/* Cooperate with nohup(1) XXX is this still necessary/working? */
	if ((oldhandler = setsignal(SIGHUP, cleanup)) != SIG_DFL)
		(void)setsignal(SIGHUP, oldhandler);
@


1.73
log
@tcpdump is two-process privsep.

the packet processor pid is initialized on a socketpair, and then only
does byte analysis. it can be protected using a "stdio" tame request.
an successfull attack against it will find it cannot open files nor
sockets, and faces various other limitations described in the tame(2)
manual page.

the monitor process can be restricted to "malloc cmsg inet ioctl dns rpath".
that sounds like a large subset, but notice it cannot create or write files.
maybe this set can be wittled down by hoisting more initialization code
upwards?

with help from canacar a while back.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.72 2015/07/14 20:23:40 deraadt Exp $	*/
d493 2
a494 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.72
log
@Move the BIOCGSTATS ioctl operation done by the tcpdump process
(at ^C time) into a services provided by the privsep monitor.
ok canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.71 2015/07/12 19:58:00 naddy Exp $	*/
d493 2
@


1.71
log
@For ASCII dumps, tighten printable characters.  \v and \f aren't.
ok semarie@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.70 2015/04/18 18:28:38 deraadt Exp $	*/
d518 1
a518 1
		if (pcap_stats(pd, &stat) < 0) {
@


1.70
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.69 2015/04/15 02:32:28 deraadt Exp $	*/
d606 4
a609 2
		c = isprint(c) || isspace(c) ? c : '.';
		putchar(c);
@


1.69
log
@opt{ind,err,arg} are already known
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.68 2015/02/09 23:00:14 deraadt Exp $	*/
d45 1
d213 1
d240 4
a243 3
			cnt = atoi(optarg);
			if (cnt <= 0)
				error("invalid packet count %s", optarg);
d313 3
a315 3
			snaplen = atoi(optarg);
			if (snaplen <= 0)
				error("invalid snaplen %s", optarg);
@


1.68
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.67 2014/11/26 18:34:52 millert Exp $	*/
a199 4

extern int optind;
extern int opterr;
extern char *optarg;
@


1.67
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.66 2014/06/30 04:25:11 deraadt Exp $	*/
d233 2
a234 2
			if (xflag == 0) ++xflag;
			++Aflag;
d238 1
a238 1
			++aflag;
d260 1
a260 1
			++eflag;
d264 1
a264 1
			++fflag;
d276 1
a276 1
			++Iflag;
d283 1
a283 1
			++Lflag;
d286 1
a286 1
			++nflag;
d290 1
a290 1
			++Nflag;
d302 1
a302 1
			++pflag;
d306 1
a306 1
			++qflag;
d320 1
a320 1
			++Sflag;
d378 1
a378 1
			++xflag;
d382 2
a383 2
			++Xflag;
			if (xflag == 0) ++xflag;
@


1.66
log
@remove backwards compat layer for alpha osf1.  back then compilers and
the parsers sucked, so byte misalignment repair was requested. These
days it means the parsers should improve.
ok lteo
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.65 2012/07/11 10:37:38 sthen Exp $	*/
a279 3
#ifdef HAVE_SETLINEBUF
			setlinebuf(stdout);
#else
a280 1
#endif
@


1.65
log
@cleanup offset argument in default_print_* functions, pointed out by Mike Small
ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.64 2012/07/10 18:07:37 sthen Exp $	*/
a50 1
#include "machdep.h"
a225 2
	if (abort_on_misalignment(ebuf, sizeof(ebuf)) < 0)
		error("%s", ebuf);
@


1.64
log
@support -A to print the ascii text of captured packets.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.63 2010/06/26 16:47:07 henning Exp $	*/
d564 1
a564 1
default_print_hexl(const u_char *cp, unsigned int length, unsigned int offset)
d572 1
a572 2
		snprintf(ln, sizeof(ln), "  %04x: ",
		    (unsigned int)(i + offset));
d607 1
a607 1
default_print_ascii(const u_char *cp, unsigned int length, unsigned int offset)
d628 1
a628 1
		default_print_hexl(cp, length, 0);
d631 1
a631 1
		default_print_ascii(cp, length, 0);
d659 1
a659 1
		default_print_hexl(bp, length, 0);
d662 1
a662 1
		default_print_ascii(bp, length, 0);
@


1.63
log
@remove support for the old pflog format, replaced in 2003
ok ryan theo & herr reyksminister
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.62 2009/10/27 23:59:57 deraadt Exp $	*/
d62 1
d232 1
a232 1
	    "ac:D:deE:fF:i:IlLnNOopqr:s:StT:vw:xXy:Y")) != -1)
d235 5
d606 14
d630 3
d661 3
d703 1
a703 1
"Usage: %s [-adefILlNnOopqStvXx] [-c count] [-D direction]\n",
@


1.62
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.61 2009/02/14 11:18:56 sthen Exp $	*/
a123 1
	{ pflog_old_if_print,		DLT_OLD_PFLOG },
@


1.61
log
@increase the default snaplen to 116, allows capture of pflog+ipv6+tcp
without knobs.  ok djm, deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.60 2008/04/18 21:35:11 djm Exp $	*/
a22 8

#ifndef lint
static const char copyright[] =
    "@@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997\n\
The Regents of the University of California.  All rights reserved.\n";
static const char rcsid[] =
    "@@(#) $Id: tcpdump.c,v 1.60 2008/04/18 21:35:11 djm Exp $ (LBL)";
#endif
@


1.60
log
@add filtering on direction; ok mpf@@ deraadt@@ feedback jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.59 2007/10/07 16:41:05 deraadt Exp $	*/
d29 1
a29 1
    "@@(#) $Id: tcpdump.c,v 1.59 2007/10/07 16:41:05 deraadt Exp $ (LBL)";
d355 5
a359 1
				snaplen = SACK_SNAPLEN;
@


1.59
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.58 2007/08/28 12:52:06 markus Exp $	*/
d29 1
a29 1
    "@@(#) $Id$ (LBL)";
d224 1
a224 1
	u_int dlt = (u_int) -1;
d240 1
a240 1
	    "ac:deE:fF:i:IlLnNOopqr:s:StT:vw:xXy:Y")) != -1)
d253 9
d434 2
a435 1
		pd = priv_pcap_live(device, snaplen, !pflag, 1000, ebuf, dlt);
d682 1
a682 1
"Usage: %s [-adefILlNnOopqStvXx] [-c count] [-E [espalg:]espkey] [-F file]\n",
d685 1
a685 1
"\t       [-i interface] [-r file] [-s snaplen] [-T type] [-w file]\n");
d687 1
a687 1
"\t       [-y datalinktype] [expression]\n");
@


1.58
log
@add -I option for printing the interfaces;
ok hshoexer, henning, mcbridge (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.57 2007/08/13 20:27:13 krw Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.57 2007/08/13 20:27:13 krw Exp $ (LBL)";
@


1.57
log
@No need to #include <netinet/in.h> twice. Noticed by Diego Casati.

ok stevesk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.56 2007/06/01 18:19:40 todd Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.56 2007/06/01 18:19:40 todd Exp $ (LBL)";
d74 1
d91 1
d219 1
a219 1
	char *cp, *infile = NULL, *device = NULL, *RFileName = NULL;
d240 1
a240 1
	    "ac:deE:fF:i:lLnNOopqr:s:StT:vw:xXy:Y")) != -1)
d272 4
d672 1
a672 1
"Usage: %s [-adefLlNnOopqStvXx] [-c count] [-E [espalg:]espkey] [-F file]\n",
@


1.56
log
@Move a useless warning to the only case that uses it (-f) from canacar@@
ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.55 2006/06/16 16:55:46 deraadt Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.55 2006/06/16 16:55:46 deraadt Exp $ (LBL)";
a64 1
#include <netinet/in.h>
@


1.55
log
@printing these version numbers in usage is ugly and useless
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.54 2006/04/22 19:26:05 moritz Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.54 2006/04/22 19:26:05 moritz Exp $ (LBL)";
d426 2
a427 1
			warning("%s", ebuf);
@


1.54
log
@Set signal handlers directly after the fork(2), so that we avoid
situations, where the privileged child dies before the unprivileged
parent has set a signal handler for SIGCHLD.

ok deraadt@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.53 2006/04/22 17:24:33 moritz Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.53 2006/04/22 17:24:33 moritz Exp $ (LBL)";
a664 5
	extern char version[];
	extern char pcap_version[];

	(void)fprintf(stderr, "%s version %s\n", program_name, version);
	(void)fprintf(stderr, "libpcap version %s\n", pcap_version);
d669 1
a669 1
"\t\t[-i interface] [-r file] [-s snaplen] [-T type] [-w file]\n");
d671 1
a671 1
"\t\t[-y datalinktype] [expression]\n");
@


1.53
log
@Remove remaining stuff from state QUIT, adjust some comments
and close a fd leak in read_infile(). ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.52 2006/04/21 23:09:34 cloder Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.52 2006/04/21 23:09:34 cloder Exp $ (LBL)";
a221 1
	RETSIGTYPE (*oldhandler)(int);
a451 7
	setsignal(SIGTERM, cleanup);
	setsignal(SIGINT, cleanup);
	setsignal(SIGCHLD, gotchld);
	/* Cooperate with nohup(1) XXX is this still necessary/working? */
	if ((oldhandler = setsignal(SIGHUP, cleanup)) != SIG_DFL)
		(void)setsignal(SIGHUP, oldhandler);

d647 13
@


1.52
log
@Add comments to please lint. No code changes. OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.51 2006/04/17 23:49:59 deraadt Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.51 2006/04/17 23:49:59 deraadt Exp $ (LBL)";
a225 1
	/* state: STATE_INIT */
d234 1
@


1.51
log
@initialize program_name before we privsep, otherwise the child does not
know our name
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.50 2006/03/13 19:05:56 moritz Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.50 2006/03/13 19:05:56 moritz Exp $ (LBL)";
d503 1
d533 1
@


1.50
log
@Simplify error() and warning() a bit. From Alexey Dobriyan.
ok jaredy@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.49 2006/02/15 20:34:23 otto Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.49 2006/02/15 20:34:23 otto Exp $ (LBL)";
d216 1
a216 1
	register int cnt, op, i;
d218 2
a219 1
	register char *cp, *infile, *device, *RFileName, *WFileName;
a223 1
	char ebuf[PCAP_ERRBUF_SIZE];
a225 9
	cnt = -1;
	device = NULL;
	infile = NULL;
	RFileName = NULL;
	WFileName = NULL;

	if (priv_init(argc, argv))
		error("Failed to setup privsep");

d231 3
@


1.49
log
@Initialize snaplen also when reading a dump file. Fixes problems
on 64bit archs when processing files with large snaplens, as seen
by Alf Schlichting.  ok moritz@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.48 2005/11/18 11:06:51 djm Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.48 2005/11/18 11:06:51 djm Exp $ (LBL)";
d198 1
a198 1
		error("Invalid number of linktypes: %u\n", dl.bfl_len);
@


1.48
log
@use new libpcap-provided datalink_x_to_y functions instead of local copies
(with different prototypes); ok mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.47 2005/10/07 19:45:26 mpf Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.47 2005/10/07 19:45:26 mpf Exp $ (LBL)";
a431 6
		i = pcap_snapshot(pd);
		if (snaplen < i) {
			warning("snaplen raised from %d to %d", snaplen, i);
			snaplen = i;
		}

d437 5
@


1.47
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.46 2005/05/28 09:01:52 reyk Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.46 2005/05/28 09:01:52 reyk Exp $ (LBL)";
a167 58
int		 pcap_datalink_name_to_val(const char *);
const char	*pcap_datalink_val_to_name(u_int);

const struct pcap_linktype {
	u_int dlt_id;
	const char *dlt_name;
} pcap_linktypes[] = {
	{ DLT_NULL,		"NULL" },
	{ DLT_EN10MB,		"EN10MB" },
	{ DLT_EN3MB,		"EN3MB" },
	{ DLT_AX25,		"AX25" },
	{ DLT_PRONET,		"PRONET" },
	{ DLT_CHAOS,		"CHAOS" },
	{ DLT_IEEE802,		"IEEE802" },
	{ DLT_ARCNET,		"ARCNET" },
	{ DLT_SLIP,		"SLIP" },
	{ DLT_PPP,		"PPP" },
	{ DLT_FDDI,		"FDDI" },
	{ DLT_ATM_RFC1483,	"ATM_RFC1483" },
	{ DLT_LOOP,		"LOOP" },
	{ DLT_ENC,		"ENC" },
	{ DLT_RAW,		"RAW" },
	{ DLT_SLIP_BSDOS,	"SLIP_BSDOS" },
	{ DLT_PPP_BSDOS,	"PPP_BSDOS" },
	{ DLT_OLD_PFLOG,	"OLD_PFLOG" },
	{ DLT_PFSYNC,		"PFSYNC" },
	{ DLT_PPP_ETHER,	"PPP_ETHER" },
	{ DLT_IEEE802_11,	"IEEE802_11" },
	{ DLT_PFLOG,		"PFLOG" },
	{ DLT_IEEE802_11_RADIO,	"IEEE802_11_RADIO" },
	{ 0,			NULL }
};

int
pcap_datalink_name_to_val(const char *name)
{
	int i;

	for (i = 0; pcap_linktypes[i].dlt_name != NULL; i++) {
		if (strcasecmp(pcap_linktypes[i].dlt_name, name) == 0)
			return (pcap_linktypes[i].dlt_id);
	}

	return (-1);
}

const char *
pcap_datalink_val_to_name(u_int dlt)
{
	int i;

	for (i = 0; pcap_linktypes[i].dlt_name != NULL; i++) {
		if (pcap_linktypes[i].dlt_id == dlt)
			return (pcap_linktypes[i].dlt_name);
	}

	return (NULL);
}
d200 2
a201 1
	fprintf(stderr, "%d link types supported:\n", dl.bfl_len);
@


1.46
log
@support decapsulation of 802.11 data frames

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.45 2005/05/22 18:41:34 moritz Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.45 2005/05/22 18:41:34 moritz Exp $ (LBL)";
d358 1
a358 1
				oflag = 1;
@


1.45
log
@fix signal race in statistics output. ok cloder@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.44 2005/03/30 22:13:54 moritz Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.44 2005/03/30 22:13:54 moritz Exp $ (LBL)";
d454 3
d458 1
a458 1
			snaplen = RADIOTAP_SNAPLEN;
@


1.44
log
@output final summary to stderr instead of stdout,
so it won't get mixed when tcpdump -w - is used.
ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.43 2005/03/25 13:45:30 moritz Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.43 2005/03/25 13:45:30 moritz Exp $ (LBL)";
d43 1
d55 1
d94 2
d102 1
d516 1
d568 1
d571 3
d575 1
a576 4
#if 0
		(void)fflush(stdout);	/* XXX unsafe */
#endif
		(void)write(STDERR_FILENO, "\n", 1);
d591 19
@


1.43
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.42 2005/03/07 16:13:38 reyk Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.42 2005/03/07 16:13:38 reyk Exp $ (LBL)";
d573 1
a573 1
			write(STDOUT_FILENO, buf, strlen(buf));
d577 1
a577 1
			write(STDOUT_FILENO, buf, strlen(buf));
d580 1
a580 1
			write(STDOUT_FILENO, buf, strlen(buf));
@


1.42
log
@add a printer for 802.11 and for additional radiotap headers,
use -y IEEE802_11 or IEEE802_11_RADIO if supported by the driver.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.41 2005/03/06 21:05:49 jmc Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.41 2005/03/06 21:05:49 jmc Exp $ (LBL)";
d450 1
a450 1
			snaplen = RADIOTAP_SNAPLEN;			
@


1.41
log
@uppercase takes precedence over lower when sorting options;
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.40 2005/03/06 18:44:50 reyk Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.40 2005/03/06 18:44:50 reyk Exp $ (LBL)";
d101 1
a101 1
int snaplen = DEFAULT_SNAPLEN;
d129 2
d190 1
d192 1
d446 11
@


1.40
log
@add support for multiple DLTs using the -L and -y options.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.39 2004/09/16 11:29:51 markus Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.39 2004/09/16 11:29:51 markus Exp $ (LBL)";
d684 1
a684 1
"Usage: %s [-adeflLnNoOpqStvxX] [-c count] [-E [espalg:]espkey] [-F file]\n",
@


1.39
log
@add -T tcp to enforce interpretation as TCP
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.38 2004/06/20 17:51:55 avsm Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.38 2004/06/20 17:51:55 avsm Exp $ (LBL)";
d42 1
d53 1
d73 1
d114 16
a129 16
	{ ether_if_print,	DLT_EN10MB },
	{ ether_if_print,	DLT_IEEE802 },
	{ sl_if_print,		DLT_SLIP },
	{ sl_bsdos_if_print,	DLT_SLIP_BSDOS },
	{ ppp_if_print,		DLT_PPP },
	{ fddi_if_print,	DLT_FDDI },
	{ null_if_print,	DLT_NULL },
	{ raw_if_print,		DLT_RAW },
	{ atm_if_print,		DLT_ATM_RFC1483 },
	{ loop_if_print, 	DLT_LOOP },
	{ enc_if_print, 	DLT_ENC },
	{ pflog_if_print, 	DLT_PFLOG },
	{ pflog_old_if_print, 	DLT_OLD_PFLOG },
	{ pfsync_if_print, 	DLT_PFSYNC },
	{ ppp_ether_if_print,	DLT_PPP_ETHER },
	{ NULL,			0 },
d137 1
a137 1
	for (p = printers; p->f; ++p)
d140 1
d158 99
d272 1
d293 2
a294 1
	while ((op = getopt(argc, argv, "ac:deE:fF:i:lnNOopqr:s:StT:vw:xXY")) != -1)
a309 1

d333 3
a335 1

d417 7
a449 1

d461 1
a461 1
		pd = priv_pcap_live(device, snaplen, !pflag, 1000, ebuf);
d479 5
d521 1
a521 1
		(void)fprintf(stderr, "%s: listening on %s\n",
d523 1
d684 1
a684 1
"Usage: %s [-adeflnNoOpqStvxX] [-c count] [-E [espalg:]espkey] [-F file]\n",
d689 1
a689 1
"\t\t[expression]\n");
@


1.38
log
@- do not use __attribute__((volatile)) as its a synonym for __dead nowadays
- bad format string "\%s" -> "%s" in print-ike.c
fixes parsing using CIL, discussed with millert@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.37 2004/05/21 05:48:50 brad Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.37 2004/05/21 05:48:50 brad Exp $ (LBL)";
d287 2
@


1.37
log
@add DLT_PPP_ETHER support plus some fixes for pppoe_if_print().

ok canacar@@

From: Marc Huber <pppoe at pro-bono-publico dot de>
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.36 2004/04/28 02:17:03 mcbride Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.36 2004/04/28 02:17:03 mcbride Exp $ (LBL)";
d95 1
a95 1
extern __dead void usage(void) __attribute__((volatile));
@


1.36
log
@Make tcpdump print carp as carp. Printing vrrp can be forced with -T vrrp.

ok markus@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.35 2004/01/28 19:44:55 canacar Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.35 2004/01/28 19:44:55 canacar Exp $ (LBL)";
d125 1
@


1.35
log
@privilege separated tcpdump, joint work with otto@@

tested by avsm@@ vincent@@ dhartmei@@ markus@@ hshoexer@@ and others
go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.34 2003/09/25 13:32:58 jmc Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.34 2003/09/25 13:32:58 jmc Exp $ (LBL)";
d284 2
@


1.34
log
@- simplify macros
- sort options
- typos and formatting improvements
- sync usage() and SYNOPSIS
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.33 2003/08/21 19:14:23 frantzen Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.33 2003/08/21 19:14:23 frantzen Exp $ (LBL)";
d65 1
a84 1

d141 10
d162 1
a162 1
	register char *cp, *infile, *cmdbuf, *device, *RFileName, *WFileName;
d164 1
a164 1
	struct bpf_program fcode;
d174 5
a241 3
			pf_osfp_initialize();
			if (pfctl_file_fingerprints(-1,
			    PF_OPT_QUIET|PF_OPT_NOACTION, PF_OSFP_FILE) == 0)
a327 3
	if (tflag > 0)
		thiszone = gmt2local(0);

d329 1
a329 9
		/*
		 * We don't need network access, so set it back to the user id.
		 * Also, this prevents the user from reading anyone's
		 * trace file.
		 */
		seteuid(getuid());
		setuid(getuid());

		pd = pcap_open_offline(RFileName, ebuf);
d332 2
d344 1
a344 1
		pd = pcap_open_live(device, snaplen, !pflag, 1000, ebuf);
d347 2
d354 2
a355 1
		if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {
a359 6

		/*
		 * Let user own process after socket has been opened.
		 */
		seteuid(getuid());
		setuid(getuid());
a360 4
	if (infile)
		cmdbuf = read_infile(infile);
	else
		cmdbuf = copy_argv(&argv[optind]);
d362 3
a364 1
	if (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)
d367 1
a367 1
		bpf_dump(&fcode, dflag);
d372 3
a374 3
	(void)setsignal(SIGTERM, cleanup);
	(void)setsignal(SIGINT, cleanup);
	/* Cooperate with nohup(1) */
a377 2
	if (pcap_setfilter(pd, &fcode) < 0)
		error("%s", pcap_geterr(pd));
d381 2
a382 1
		p = pcap_dump_open(pd, WFileName);
d395 2
d403 7
@


1.33
log
@print the operating system of TCP SYN packets with the -o option
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.32 2003/07/17 08:45:37 markus Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.32 2003/07/17 08:45:37 markus Exp $ (LBL)";
d555 1
a555 1
"Usage: %s [-adeflnNOpqStvxX] [-c count] [-F file] [-i interface] [-r file]\n",
d558 1
a558 1
"\t\t[-s snaplen] [-T type] [-w file] [-E [espalg:]espkey]\n");
@


1.32
log
@add support for ESP decryption; ok deraadt@@; feedback mickey@@;
many manpage fixes from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.31 2003/05/14 08:50:37 canacar Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.31 2003/05/14 08:50:37 canacar Exp $ (LBL)";
d59 7
d73 1
d173 1
a173 1
	while ((op = getopt(argc, argv, "ac:deE:fF:i:lnNOpqr:s:StT:vw:xXY")) != -1)
d224 7
@


1.31
log
@libpcap and tcpdump now understand the new pflog datalink type.
old datalink type is still recognized.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.30 2002/11/30 13:56:23 mickey Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.30 2002/11/30 13:56:23 mickey Exp $ (LBL)";
d83 1
d165 1
a165 1
	while ((op = getopt(argc, argv, "ac:defF:i:lnNOpqr:s:StT:vw:xXY")) != -1)
d288 5
d540 2
a541 1
"Usage: %s [-adeflnNOpqStvxX] [-c count] [ -F file ]\n", program_name);
d543 1
a543 1
"\t\t[ -i interface ] [ -r file ] [ -s snaplen ]\n");
d545 1
a545 1
"\t\t[ -T type ] [ -w file ] [ expression ]\n");
@


1.30
log
@pfsync support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.29 2002/11/30 00:20:46 deraadt Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.29 2002/11/30 00:20:46 deraadt Exp $ (LBL)";
d114 1
@


1.29
log
@stop breaking the damn tree mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.27 2002/01/23 23:32:20 mickey Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.27 2002/01/23 23:32:20 mickey Exp $ (LBL)";
d114 1
@


1.28
log
@tcpdump support for pfsync; henning@@ ok
@
text
@d101 1
a101 1
static const struct printer printers[] = {
a113 1
	{ pfsync_if_print, 	DLT_PFSYNC },
d120 1
a120 1
	const struct printer *p;
@


1.27
log
@proper handling for DLT_NULL and DLT_LOOP (header byte swapping); pointed out and tested by Alexander Yurchenko <grange@@rt.mipt.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.26 2001/12/07 22:34:28 deraadt Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.26 2001/12/07 22:34:28 deraadt Exp $ (LBL)";
d101 1
a101 1
static struct printer printers[] = {
d114 1
d121 1
a121 1
	struct printer *p;
@


1.26
log
@OK, this is horrible.  stdio safety in a signal handler, requires that we
make the regular data stream non-buffered.  This drastically reduces tcpdump
performance.  Let us commit this, and see how people react.  But
realistically, without this, we cannot gaurantee that the tail of a file is
correct on signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.25 2001/11/07 18:48:00 deraadt Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.25 2001/11/07 18:48:00 deraadt Exp $ (LBL)";
d111 1
a111 1
	{ null_if_print, 	DLT_LOOP },
@


1.25
log
@avoid buffer overflows.  when will people learn to use snprintf correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.24 2001/11/07 07:41:21 deraadt Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.24 2001/11/07 07:41:21 deraadt Exp $ (LBL)";
d360 3
a362 1
		pcap_dumper_t *p = pcap_dump_open(pd, WFileName);
d365 5
@


1.24
log
@skip the unsafe bit in the signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.23 2001/11/02 16:19:27 deraadt Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.23 2001/11/02 16:19:27 deraadt Exp $ (LBL)";
d418 1
a418 1
	char ln[128];
d422 2
a423 3
		snprintf(ln, 
			 sizeof(ln),
			 "  %04x: ", (unsigned int)(i + offset));
d429 2
a430 3
				snprintf(ln + strlen(ln),
					 sizeof(ln) - strlen(ln),
					 "%02x ", (unsigned int)cp[i+j]);
d432 3
a434 3
				snprintf(ln + strlen(ln), 
					 sizeof(ln) - strlen(ln),
					 "%02x", (unsigned int)cp[i+j]);
d438 1
a438 3
				snprintf(ln + strlen(ln), 
					 sizeof(ln) - strlen(ln),
					 "   ");
d440 2
a441 3
				snprintf(ln + strlen(ln), 
					 sizeof(ln) - strlen(ln),
					 "  ");
d444 1
a444 1
		snprintf(ln + strlen(ln), sizeof(ln) - strlen(ln), " ");
d448 3
a450 3
			snprintf(ln + strlen(ln), 
				 sizeof(ln) - strlen(ln), 
				 "%c", c);
@


1.23
log
@avoid stdio in signal handler (not complete yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.22 2001/06/25 23:05:17 provos Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.22 2001/06/25 23:05:17 provos Exp $ (LBL)";
d392 1
d394 1
@


1.22
log
@interpret DLT_PFLOG
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.21 2001/01/19 17:53:19 deraadt Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.21 2001/01/19 17:53:19 deraadt Exp $ (LBL)";
d388 1
d392 13
a404 11
		/* XXX unsafe */
		(void)fflush(stdout);
		putc('\n', stderr);
		if (pcap_stats(pd, &stat) < 0)
			(void)fprintf(stderr, "pcap_stats: %s\n",
			    pcap_geterr(pd));
		else {
			(void)fprintf(stderr, "%d packets received by filter\n",
			    stat.ps_recv);
			(void)fprintf(stderr, "%d packets dropped by kernel\n",
			    stat.ps_drop);
d407 1
a407 1
	exit(0);
@


1.21
log
@mark remaining signal races which are difficult to fix
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.20 2000/12/10 19:05:21 provos Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.20 2000/12/10 19:05:21 provos Exp $ (LBL)";
d113 1
@


1.20
log
@for correctness, do seteuid, too. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcpdump.c,v 1.19 2000/10/03 14:21:57 ho Exp $	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.19 2000/10/03 14:21:57 ho Exp $ (LBL)";
d390 1
@


1.19
log
@Compile with -Wall. Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.18 2000/04/30 05:23:28 ericj Exp $ (LBL)";
d301 1
d334 1
@


1.18
log
@be more careful with strcpy/sprintf. From tcpdump.org. millert@@ ok
@
text
@d1 2
d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.17 2000/04/26 21:35:44 jakob Exp $ (LBL)";
d51 1
@


1.17
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.16 2000/03/26 05:24:25 ericj Exp $ (LBL)";
d154 1
a154 1
	if (abort_on_misalignment(ebuf) < 0)
@


1.16
log
@correct usage() return value
@
text
@d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.15 2000/01/16 13:36:36 jakob Exp $ (LBL)";
d285 3
@


1.15
log
@print pcap_version in usage()
@
text
@d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.14 1999/09/16 20:58:48 brad Exp $ (LBL)";
d520 1
a520 1
	exit(-1);
@


1.14
log
@bring more inline with tcpdump 3.4
@
text
@d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.13 1999/07/28 20:41:37 jakob Exp $ (LBL)";
d510 1
d513 1
d515 1
a515 1
"Usage: tcpdump [-adeflnNOpqStvxX] [-c count] [ -F file ]\n");
@


1.13
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
d24 1
a24 1
    "@@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996\n\
d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.12 1999/06/29 20:33:29 deraadt Exp $ (LBL)";
d73 1
d102 1
d106 1
@


1.12
log
@permit attach to address-less interfaces
@
text
@d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.11 1998/09/22 22:03:02 provos Exp $ (LBL)";
d53 2
d56 3
d62 1
d65 1
a66 1
int eflag;			/* print ethernet header */
d69 2
a70 2
int Oflag = 1;			/* run filter code optimizer */
int Sflag;			/* print raw TCP sequence numbers */
a72 2
int dflag;			/* print filter code */

a106 1
	{ null_if_print, 	DLT_LOOP },
d137 1
d155 1
a155 1
	while ((op = getopt(argc, argv, "c:defF:i:lnNOpqr:s:StT:vw:xY")) != -1)
d157 5
d273 5
d284 1
a284 1
		thiszone = gmt2local();
d337 1
a337 1
	init_addrtoname(fflag, localnet, netmask);
d339 5
a343 3
	(void)signal(SIGTERM, cleanup);
	(void)signal(SIGINT, cleanup);
	(void)signal(SIGHUP, cleanup);
d394 49
d450 18
a467 12
	nshorts = (u_int) length / sizeof(u_short);
	i = 0;
	while (--nshorts >= 0) {
		if ((i++ % 8) == 0)
			(void)printf("\n\t\t\t");
		s = *cp++;
		(void)printf(" %02x%02x", s, *cp++);
	}
	if (length & 1) {
		if ((i % 8) == 0)
			(void)printf("\n\t\t\t");
		(void)printf(" %02x", *cp);
d478 22
a499 16
	if ((long)bp & 1) {
		default_print_unaligned(bp, length);
		return;
	}
	sp = (u_short *)bp;
	nshorts = (u_int) length / sizeof(u_short);
	i = 0;
	while (--nshorts >= 0) {
		if ((i++ % 8) == 0)
			(void)printf("\n\t\t\t");
		(void)printf(" %04x", ntohs(*sp++));
	}
	if (length & 1) {
		if ((i % 8) == 0)
			(void)printf("\n\t\t\t");
		(void)printf(" %02x", *(u_char *)sp);
d508 1
a508 1
	(void)fprintf(stderr, "Version %s\n", version);
d510 1
a510 1
"Usage: tcpdump [-deflnNOpqStvx] [-c count] [ -F file ]\n");
@


1.11
log
@make tcpdump aware of SACK (RFC 2018), loosely based on a patch from
hari@@cs.berkeley.edu.
@
text
@d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.10 1998/06/25 19:42:48 mickey Exp $ (LBL)";
d301 6
a306 2
		if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0)
			error("%s", ebuf);
@


1.10
log
@add cisco netflow proto printing; not tested w/ version 5, but should work anyways
@
text
@d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.9 1998/06/11 00:01:24 provos Exp $ (LBL)";
d238 2
@


1.9
log
@handle IPSec processed packets (DLT_ENC) in libpcap, display them with
tcpdump + additional info (SPI + which type of transforms where passed).
@
text
@d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.8 1998/06/04 23:11:42 deraadt Exp $ (LBL)";
d236 2
@


1.8
log
@add DLT_LOOP support; 4-byte header indicates proto; cstone@@pobox.com
@
text
@d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.7 1997/01/15 23:44:25 millert Exp $ (LBL)";
d101 2
@


1.7
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d27 1
a27 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/tcpdump.c,v 1.6 1996/12/12 16:22:21 bitblt Exp $ (LBL)";
d101 1
@


1.6
log
@*** empty log message ***
@
text
@d27 1
a27 1
    "@@(#) $Header: tcpdump.c,v 1.118 96/12/10 23:22:27 leres Exp $ (LBL)";
d148 1
a148 1
	while ((op = getopt(argc, argv, "c:defF:i:lnNOpqr:s:StT:vw:xY")) != EOF)
@


1.5
log
@initialize:
int thiszone=0;
@
text
@a0 2
/*	$OpenBSD: tcpdump.c,v 1.4 1996/07/13 11:01:34 mickey Exp $	*/

d2 1
a2 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995
d21 1
d23 2
a24 2
char copyright[] =
    "@@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995\n\
d26 2
a27 2
static  char rcsid[] =
    "@@(#)Header: tcpdump.c,v 1.109 96/06/22 14:46:37 leres Exp (LBL)";
a39 4
#ifdef __osf__
#include <sys/sysinfo.h>
#include <sys/proc.h>
#endif
d52 1
d71 1
a71 1
int32_t thiszone=0;		/* seconds offset from gmt to local time */
a78 3
#ifdef __osf__
static void abort_on_misalignment(void);
#endif
d95 1
a118 12
/* OSF magic */
#ifdef __osf__
static void
abort_on_misalignment()
{
	static int buf[2] = { SSIN_UACPROC, UAC_SIGBUS };

	if (setsysinfo(SSI_NVPAIRS, (caddr_t)buf, 1, 0, 0) < 0)
		error("setsysinfo: %s", pcap_strerror(errno));
}
#endif

d132 1
a132 5
	char errbuf[PCAP_ERRBUF_SIZE];

#ifdef __osf__
	abort_on_misalignment();
#endif
d144 3
d152 2
d210 2
d273 1
a273 1
		pd = pcap_open_offline(RFileName, errbuf);
d275 1
a275 1
			error(errbuf);
d282 1
a282 1
			device = pcap_lookupdev(errbuf);
d284 1
a284 1
				error(errbuf);
d286 1
a286 1
		pd = pcap_open_live(device, snaplen, !pflag, 1000, errbuf);
d288 1
a288 1
			error(errbuf);
d294 2
a295 2
		if (pcap_lookupnet(device, &localnet, &netmask, errbuf) < 0)
			error(errbuf);
a305 4
	/* XXX padding only needed for kernel fcode */
	if (RFileName != NULL)
		pcap_fddipad = 0;

d307 1
a307 1
		error(pcap_geterr(pd));
d319 1
a319 1
		error(pcap_geterr(pd));
d323 1
a323 1
			error(pcap_geterr(pd));
d369 1
a369 1
default_print_unaligned(register const u_char *cp, register int length)
d390 1
a390 1
default_print(register const u_char *bp, register int length)
d416 1
a416 1
usage()
@


1.4
log
@it is 3.2 now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 1
a75 1
int32_t thiszone;		/* seconds offset from gmt to local time */
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: tcpdump.c,v 1.4.4.1 1996/06/05 18:07:48 cgd Exp $	*/
/*	$NetBSD: tcpdump.c,v 1.4.4.1 1996/06/05 18:07:48 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
d25 2
a26 1
    "@@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994\nThe Regents of the University of California.  All rights reserved.\n";
d28 1
a28 1
    "@@(#)Header: tcpdump.c,v 1.93 94/06/10 17:01:44 mccanne Exp (LBL)";
d41 4
a50 1
#ifdef __STDC__
d52 1
a52 1
#endif
a53 1
#include <string.h>
d75 1
a75 1
int thiszone;
d77 1
a77 1
SIGRET cleanup(int);
d80 7
d95 5
d106 1
d125 1
d127 1
a127 3
#include <sys/sysinfo.h>
#include <sys/proc.h>
void
d130 4
a133 8
	int buf[2];
	
	buf[0] = SSIN_UACPROC;
	buf[1] = UAC_SIGBUS;
	if (setsysinfo(SSI_NVPAIRS, buf, 1, 0, 0) < 0) {
		perror("setsysinfo");
		exit(1);
	}
d135 1
d137 3
a139 1
#endif
d144 2
a145 2
	register int cnt, op;
	u_int32_t localnet, netmask;
a151 3
	extern char *optarg;
	extern int optind, opterr;

d194 1
d196 3
d239 1
a239 1
				packettype = 1;
d241 1
a241 1
				packettype = 2;
d243 1
a243 1
				packettype = 3;
d245 3
a247 1
				packettype = 4;
d262 1
d304 5
d321 4
d350 3
a352 2
		fprintf(stderr, "%s: listening on %s\n", program_name, device);
		fflush(stderr);
d355 1
a355 1
		(void)fprintf(stderr, "%s: pcap_loop %s\n",
d364 1
a364 1
SIGRET
d434 1
a434 1
void
d441 3
a443 1
"Usage: tcpdump [-deflnOpqtvx] [-c count] [-i interface]\n");
d445 1
a445 1
"\t\t[-r filename] [-w filename] [expr]\n");
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tcpdump.c,v 1.3 1995/04/24 13:27:48 cgd Exp $	*/
a23 24

/*
 * Copyright (c) 1995 Sun Microsystems, Inc.
 * All rights reserved.
 * 
 * Permission is hereby granted, without written agreement and without
 * license or royalty fees, to use, copy, modify, and distribute this
 * software and its documentation for any purpose, provided that the
 * above copyright notice and the following two paragraphs appear in
 * all copies of this software.

 * IN NO EVENT SHALL SUN MICROSYSTEMS, INC. BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 * SUN MICROSYSTEMS, INC. HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.

 * SUN MICROSYSTEMS, INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 * THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND SUN
 * MICROSYSTEMS, INC. HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,
 * UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
*/
d28 1
a28 1
    "@@(#)Header: tcpdump.c,v 1.93 94/06/10 17:01:44 mccanne Exp $ (LBL)";
a67 1
int skipflag;			/* Print out SKIP packets */
d132 1
a132 1
	u_long localnet, netmask;
d157 1
a157 1
	while ((op = getopt(argc, argv, "c:defF:i:klnNOpqr:s:StT:vw:xY")) != EOF)
a182 4
		case 'k':
			skipflag++;
			break;

d328 1
a328 1
		(void)fprintf(stderr, "%s: pcap_loop: %s\n",
@


1.1
log
@Initial revision
@
text
@d1 1
d24 24
d52 1
a52 1
    "@@(#)Header: tcpdump.c,v 1.93 94/06/10 17:01:44 mccanne Exp (LBL)";
d92 1
d182 1
a182 1
	while ((op = getopt(argc, argv, "c:defF:i:lnNOpqr:s:StT:vw:xY")) != EOF)
d208 4
d356 5
a360 1
	pcap_loop(pd, cnt, printer, pcap_userdata);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
