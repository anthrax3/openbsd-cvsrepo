head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.2
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.6
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.15.0.14
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.12
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.8
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.4
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.1.0.8
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.12.13.06.40.21;	author dlg;	state Exp;
branches;
next	1.23;
commitid	ubBXfkILK3unVw7s;

1.23
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	enjTsnD5UO6xazKc;

1.22
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Zx2k82IzYwwZaEz9;

1.21
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2014.12.09.17.03.19;	author mikeb;	state Exp;
branches;
next	1.19;
commitid	jvJGNbHm278R5JJF;

1.19
date	2014.12.03.13.22.18;	author mikeb;	state Exp;
branches;
next	1.18;
commitid	ykwaSylMzIi44JzN;

1.18
date	2014.12.03.13.19.03;	author mikeb;	state Exp;
branches;
next	1.17;
commitid	wPf5BYNAX6n2pykw;

1.17
date	2014.11.20.03.56.33;	author jsg;	state Exp;
branches;
next	1.16;
commitid	Xd1bk5sfxUt1kS58;

1.16
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.15;
commitid	yLXrOcgrag4eS8u4;

1.15
date	2011.09.17.16.45.42;	author naddy;	state Exp;
branches;
next	1.14;

1.14
date	2011.06.27.16.54.14;	author dhill;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.06.16.01.57;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.27.13.14.35;	author bluhm;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.04.18.38.29;	author canacar;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.27.18.15.25;	author canacar;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.06.09.51.33;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.19.14.25.04;	author naddy;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.08.19.24.03;	author canacar;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.04.08.35.12;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.27.10.00.40;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.07.07.40.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.26.21.35.41;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.24
log
@teach tcpdump some more things about gre.

gre can be encapsulated in ipv6.
gre can encapsulate ipv6, mpls, and ethernet.
nvgre is based on gre, so if the header could be nvgre print the
vsid and flow id as well as the key.

ok stsp@@
@
text
@/*	$OpenBSD: print-ip6.c,v 1.23 2015/11/16 00:16:39 mmcc Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifdef INET6

#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>

#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "interface.h"
#include "addrtoname.h"

#include <netinet/ip6.h>

/*
 * print an IP6 datagram.
 */
void
ip6_print(const u_char *bp, u_int length)
{
	const struct ip6_hdr *ip6;
	int hlen;
	int len;
	const u_char *cp;
	const u_char *pktp = packetp;
	const u_char *send = snapend;
	int nh;
	u_int flow;

	ip6 = (const struct ip6_hdr *)bp;
	if ((u_char *)(ip6 + 1) > snapend) {
		printf("[|ip6]");
		return;
	}

	/*
	 * The IP header is not word aligned, so copy into abuf.
	 * This will never happen with BPF.  It does happen with
	 * raw packet dumps from -r.
	 */
	if ((intptr_t)ip6 & (sizeof(u_int32_t)-1)) {
		static u_char *abuf = NULL;
		static int didwarn = 0;
		int clen = snapend - bp;
		if (clen > snaplen)
			clen = snaplen;

		if (abuf == NULL) {
			abuf = malloc(snaplen);
			if (abuf == NULL)
				error("ip6_print: malloc");
		}
		memmove((char *)abuf, (char *)ip6, min(length, clen));
		snapend = abuf + clen;
		packetp = bp = abuf;
		ip6 = (struct ip6_hdr *)abuf;
		/* We really want libpcap to give us aligned packets */
		if (!didwarn) {
			warning("compensating for unaligned libpcap packets");
			++didwarn;
		}
	}

	if (length < sizeof (struct ip6_hdr)) {
		(void)printf("truncated-ip6 %d", length);
		goto out;
	}
	if ((ip6->ip6_vfc & IPV6_VERSION_MASK) != IPV6_VERSION) {
		(void)printf("bad-ip6-version %u", ip6->ip6_vfc >> 4);
		goto out;
	}
	hlen = sizeof(struct ip6_hdr);

	len = ntohs(ip6->ip6_plen);
	if (length < len + hlen)
		(void)printf("truncated-ip6 - %d bytes missing!",
			len + hlen - length);

	cp = (const u_char *)ip6;
	nh = ip6->ip6_nxt;
	while (cp + hlen <= snapend) {
		cp += hlen;

#ifndef IPPROTO_IPV4
#define IPPROTO_IPV4	4
#endif
		if (cp == (u_char *)(ip6 + 1) &&
		    nh != IPPROTO_TCP && nh != IPPROTO_UDP &&
		    nh != IPPROTO_ESP && nh != IPPROTO_AH &&
		    (vflag || (nh != IPPROTO_IPV4 && nh != IPPROTO_IPV6))) {
			(void)printf("%s > %s: ", ip6addr_string(&ip6->ip6_src),
				     ip6addr_string(&ip6->ip6_dst));
		}

		switch (nh) {
		case IPPROTO_HOPOPTS:
			hlen = hbhopt_print(cp);
			nh = *cp;
			break;
		case IPPROTO_DSTOPTS:
			hlen = dstopt_print(cp);
			nh = *cp;
			break;
		case IPPROTO_FRAGMENT:
			hlen = frag6_print(cp, (const u_char *)ip6);
			if (snapend < cp + hlen)
				goto end;
			nh = *cp;
			break;
		case IPPROTO_ROUTING:
			hlen = rt6_print(cp, (const u_char *)ip6);
			nh = *cp;
			break;
		case IPPROTO_TCP:
			tcp_print(cp, len + sizeof(struct ip6_hdr) - (cp - bp),
				(const u_char *)ip6);
			goto end;
		case IPPROTO_UDP:
			udp_print(cp, len + sizeof(struct ip6_hdr) - (cp - bp),
				(const u_char *)ip6);
			goto end;
		case IPPROTO_ESP:
			esp_print(cp, len + sizeof(struct ip6_hdr) - (cp - bp),
				(const u_char *)ip6);
			goto end;
		case IPPROTO_AH:
			ah_print(cp, len + sizeof(struct ip6_hdr) - (cp - bp),
				(const u_char *)ip6);
			goto end;
		case IPPROTO_ICMPV6:
			icmp6_print(cp, len + sizeof(struct ip6_hdr) - (cp - bp),
				(const u_char *)ip6);
			goto end;
		case IPPROTO_PIM:
			(void)printf("PIM");
			pim_print(cp, len);
			goto end;
#ifndef IPPROTO_OSPF
#define IPPROTO_OSPF 89
#endif
		case IPPROTO_OSPF:
			ospf6_print(cp, len);
			goto end;
		case IPPROTO_IPV6:
			ip6_print(cp, len);
			if (! vflag)
				printf(" (encap)");
			goto end;
		case IPPROTO_IPV4:
			ip_print(cp, len);
			if (! vflag)
				printf(" (encap)");
			goto end;

#ifndef IPPROTO_GRE
#define IPPROTO_GRE 47
#endif
		case IPPROTO_GRE:
			gre_print(cp, len);
			if (! vflag) {
				printf(" (gre encap)");
				goto out;
			}
			goto end;

		case IPPROTO_NONE:
			(void)printf("no next header");
			goto end;

#ifndef IPPROTO_CARP  
#define IPPROTO_CARP 112
#endif
		case IPPROTO_CARP:
			if (packettype == PT_VRRP)
				vrrp_print(cp, len, ip6->ip6_hlim);
			else
				carp_print(cp, len, ip6->ip6_hlim);
			break;

		default:
			(void)printf("ip-proto-%d %d", ip6->ip6_nxt, len);
			goto end;
		}
		if (hlen == 0)
			break;
	}

 end:

	flow = ntohl(ip6->ip6_flow);
#if 0
	/* rfc1883 */
	if (flow & 0x0f000000)
		(void)printf(" [pri 0x%x]", (flow & 0x0f000000) >> 24);
	if (flow & 0x00ffffff)
		(void)printf(" [flowlabel 0x%x]", flow & 0x00ffffff);
#else
	/* RFC 2460 */
	if (flow & 0x0ff00000)
		(void)printf(" [class 0x%x]", (flow & 0x0ff00000) >> 20);
	if (flow & 0x000fffff)
		(void)printf(" [flowlabel 0x%x]", flow & 0x000fffff);
#endif

	if (ip6->ip6_hlim <= 1)
		(void)printf(" [hlim %d]", (int)ip6->ip6_hlim);

	if (vflag) {
		printf(" (");
		(void)printf("len %d", len);
		if (ip6->ip6_hlim > 1)
			(void)printf(", hlim %d", (int)ip6->ip6_hlim);
		printf(")");
	}

 out:
	packetp = pktp;
	snapend = send;
}

#endif /* INET6 */
@


1.23
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.22 2015/08/21 02:07:32 deraadt Exp $	*/
d187 12
@


1.22
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.21 2015/01/16 06:40:21 deraadt Exp $	*/
d52 1
a52 1
ip6_print(register const u_char *bp, register u_int length)
d54 4
a57 4
	register const struct ip6_hdr *ip6;
	register int hlen;
	register int len;
	register const u_char *cp;
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.20 2014/12/09 17:03:19 mikeb Exp $	*/
d82 1
a82 1
			abuf = (u_char *)malloc(snaplen);
@


1.20
log
@Catch up with the BPF_ALIGNMENT switch to the uint32_t.

bpf aligns data following the datalink header (e.g. ethernet)
on the BPF_ALIGNMENT boundary.  Since rev1.41 of bpf.h it's
uint32_t instead of a long.  And also since then almost all
packets become "unaligned" from the tcpdump perspective and
require costly copies into the internal buffer.  Neither IP
header (struct ip) nor IPv6 (struct ip6_hdr) have fields
larger than 32 bits and therefore alignment requirements for
them are at most 32 bit.

ok millert, jsg, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.19 2014/12/03 13:22:18 mikeb Exp $	*/
a25 1
#include <sys/param.h>
@


1.19
log
@Restore packetp and snapend pointers once we're done with an incorrectly
aligned IP/IPv6 packet so that tcpdump can print hexdump of the whole
packet including the Ethernet header (if requested) and not only the
IP/IPv6 part of it.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.18 2014/12/03 13:19:03 mikeb Exp $	*/
d75 1
a75 1
	if ((intptr_t)ip6 & (sizeof(long)-1)) {
@


1.18
log
@Fixup a crash found by jsg using the AFL fuzzer.  IP and IPv6 printing
routines should check that there's at least a complete IP/IPv6 header
available in the buffer before trying to do anything else.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.17 2014/11/20 03:56:33 jsg Exp $	*/
d59 2
d100 1
a100 1
		return;
d104 1
a104 1
		return;
d211 1
a211 1
	
d237 4
@


1.17
log
@Make ip6_print() take an unsigned length matching
ip_print() and others.

Allows code deciding on a minimum length to memmove()
to work as intended, preventing various crashes found
with the afl fuzzer.  Callers of ip6_print() should of
course be fixed to provide sane lengths as well.

ok deraadt@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.16 2014/08/14 12:44:44 mpi Exp $	*/
d61 1
a61 1
	
d63 4
a95 4
	if ((u_char *)(ip6 + 1) > snapend) {
		printf("[|ip6]");
		return;
	}
@


1.16
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.15 2011/09/17 16:45:42 naddy Exp $	*/
d53 1
a53 1
ip6_print(register const u_char *bp, register int length)
@


1.15
log
@update pointer variable after copying misaligned packet; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.14 2011/06/27 16:54:14 dhill Exp $	*/
a31 1
#include <netinet/in_systm.h>
@


1.14
log
@fix an off by one which resulted in 'no next header' packets not being
displayed.

help from bluhm@@
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.13 2010/04/06 16:01:57 jsg Exp $	*/
d84 1
a84 1
		packetp = abuf;
@


1.13
log
@Add support for decoding MLDv2 initially from tcpdump.org via FreeBSD,
cleaned up to be less gross after some suggestions from stsp.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.12 2009/11/27 13:14:35 bluhm Exp $	*/
d114 1
a114 1
	while (cp + hlen < snapend) {
d139 1
a139 1
			if (snapend <= cp + hlen)
@


1.12
log
@Print outer ipv6 addresses for encapsulated packets only if tcpdump
is run with -v.  This behavior is analog to ipv4.
ok mpf@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.11 2009/10/27 23:59:55 deraadt Exp $	*/
d164 2
a165 1
			icmp6_print(cp, (const u_char *)ip6);
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.10 2007/10/04 18:38:29 canacar Exp $	*/
d117 3
d122 2
a123 1
		    nh != IPPROTO_ESP && nh != IPPROTO_AH) {
d178 2
a180 3
#ifndef IPPROTO_IPV4
#define IPPROTO_IPV4	4
#endif
d183 2
@


1.10
log
@Handle CARP for IPv6. Reported and tested by todd@@
ok todd@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.9 2007/06/27 18:15:25 canacar Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) /master/usr.sbin/tcpdump/tcpdump/print-ip.c,v 2.1 1995/02/03 18:14:45 polk Exp (LBL)";
#endif
@


1.9
log
@When aligning buffers correctly handle the case where the
buffers overlap, which happens on 64 bit archs, when
handling encapsulated packets. Reported and tested by Jurjen Oskam
additional testing by Stuart Henderson and todd@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.8 2007/05/06 09:51:33 claudio Exp $	*/
d189 10
@


1.8
log
@Fix the out of bounds check when parsing IPv6 headers. Fixes a SIGSEGV
when parsing IPv6 headers with unknown or corrupted header options.
OK henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.7 2006/09/19 14:25:04 naddy Exp $	*/
d78 3
d87 2
a88 2
		memcpy((char *)abuf, (char *)ip6, min(length, snaplen));
		snapend += abuf - (u_char *)ip6;
@


1.7
log
@enable ESP and AH dissectors over IPv6; ok mpf@@ (at k2k6)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.6 2005/10/08 19:24:03 canacar Exp $	*/
d116 1
a116 1
	while (cp < snapend) {
@


1.6
log
@Check IP version when decoding v4 and v6 packets.
From Jason Wright via PR-4531.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.5 2004/02/04 08:35:12 otto Exp $	*/
d119 3
a121 2
		if (cp == (u_char *)(ip6 + 1)
		 && nh != IPPROTO_TCP && nh != IPPROTO_UDP) {
d151 8
@


1.5
log
@Some more non-alignment problems resolved.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.4 2003/01/27 10:00:40 henning Exp $	*/
d101 4
@


1.4
log
@bugfix from Can Erkin Acar <canacar@@eee.metu.edu.tr>:
hbhopt_print() and dstopt_print() can return 0 if
the option is located just one byte short of snapend
this would cause an infinite loop in ip6_print().
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.3 2002/02/19 19:39:40 millert Exp $	*/
d44 1
d47 1
a69 1
#ifdef TCPDUMP_ALIGN
d75 3
a77 2
	if ((int)ip & (sizeof(long)-1)) {
		static u_char *abuf;
d79 1
a79 1
		if (abuf == NULL)
d81 5
a85 2
		bcopy((char *)ip, (char *)abuf, min(length, snaplen));
		snapend += abuf - (u_char *)ip;
d87 6
a92 1
		ip = (struct ip6_hdr *)abuf;
d94 1
a94 1
#endif
@


1.3
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.2 2001/11/07 07:40:13 deraadt Exp $	*/
d168 2
@


1.2
log
@typos
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip6.c,v 1.1 2000/04/26 21:35:41 jakob Exp $	*/
a44 1
#ifdef __STDC__
a45 1
#endif
@


1.1
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 2
a74 2
	 * This will never happen with BPF.  It does happen raw packet
	 * dumps from -r.
d79 1
a79 1
		if (abuf == 0)
@

