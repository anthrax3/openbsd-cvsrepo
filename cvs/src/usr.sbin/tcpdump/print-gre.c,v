head	1.12;
access;
symbols
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.48
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.46
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.42
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.40
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.38
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.36
	OPENBSD_5_0:1.7.0.34
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.32
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.30
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.26
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.28
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.24
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.14
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.12
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.10
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.8
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.6
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.12.13.06.40.21;	author dlg;	state Exp;
branches;
next	1.11;
commitid	ubBXfkILK3unVw7s;

1.11
date	2015.11.05.11.55.21;	author jca;	state Exp;
branches;
next	1.10;
commitid	TQMD0AvKtjTMs6A2;

1.10
date	2015.11.05.11.52.24;	author jca;	state Exp;
branches;
next	1.9;
commitid	6pCIA1fkch0zuIhW;

1.9
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	Uu5nFG3wCl0LACBb;

1.8
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.7;
commitid	yLXrOcgrag4eS8u4;

1.7
date	2003.06.03.00.21.04;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.30.03.04.04;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.18.20.40.06;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.18.19.39.35;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.18.18.49.03;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.03.14.31.57;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	96.12.12.16.22.37;	author bitblt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@teach tcpdump some more things about gre.

gre can be encapsulated in ipv6.
gre can encapsulate ipv6, mpls, and ethernet.
nvgre is based on gre, so if the header could be nvgre print the
vsid and flow id as well as the key.

ok stsp@@
@
text
@/*	$OpenBSD: print-gre.c,v 1.11 2015/11/05 11:55:21 jca Exp $	*/

/*
 * Copyright (c) 2002 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * tcpdump filter for GRE - Generic Routing Encapsulation
 * RFC1701 (GRE), RFC1702 (GRE IPv4), and RFC2637 (Enhanced GRE)
 */

#include <sys/time.h>
#include <sys/uio.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>

#include <net/ethertypes.h>

#include <stdio.h>
#include <string.h>

#include "interface.h"
#include "addrtoname.h"
#include "extract.h"

#define	GRE_CP		0x8000		/* checksum present */
#define	GRE_RP		0x4000		/* routing present */
#define	GRE_KP		0x2000		/* key present */
#define	GRE_SP		0x1000		/* sequence# present */
#define	GRE_sP		0x0800		/* source routing */
#define	GRE_RECRS	0x0700		/* recursion count */
#define	GRE_AP		0x0080		/* acknowledgment# present */
#define	GRE_VERS	0x0007		/* protocol version */

/* source route entry types */
#define	GRESRE_IP	0x0800		/* IP */
#define	GRESRE_ASN	0xfffe		/* ASN */

#define NVGRE_VSID_MASK		0xffffff00U
#define NVGRE_VSID_SHIFT	8
#define NVGRE_FLOWID_MASK	0x000000ffU
#define NVGRE_FLOWID_SHIFT	0

void gre_print_0(const u_char *, u_int);
void gre_print_1(const u_char *, u_int);
void gre_sre_print(u_int16_t, u_int8_t, u_int8_t, const u_char *, u_int);
void gre_sre_ip_print(u_int8_t, u_int8_t, const u_char *, u_int);
void gre_sre_asn_print(u_int8_t, u_int8_t, const u_char *, u_int);

void
gre_print(const u_char *bp, u_int length)
{
	u_int len = length, vers;

	if (bp + len > snapend)
		len = snapend - bp;

	if (len < 2) {
		printf("[|gre]");
		return;
	}
	vers = EXTRACT_16BITS(bp) & GRE_VERS;

	switch (vers) {
	case 0:
		gre_print_0(bp, len);
		break;
	case 1:
		gre_print_1(bp, len);
		break;
	default:
		printf("gre-unknown-version=%u", vers);
		break;
	}
}

void
gre_print_0(const u_char *bp, u_int length)
{
	u_int len = length;
	u_int16_t flags, prot;

	flags = EXTRACT_16BITS(bp);
	if (vflag) {
		printf("[%s%s%s%s%s] ",
		    (flags & GRE_CP) ? "C" : "",
		    (flags & GRE_RP) ? "R" : "",
		    (flags & GRE_KP) ? "K" : "",
		    (flags & GRE_SP) ? "S" : "",
		    (flags & GRE_sP) ? "s" : "");
	}

	len -= 2;
	bp += 2;

	if (len < 2)
		goto trunc;
	prot = EXTRACT_16BITS(bp);
	printf("%s", etherproto_string(prot));

	len -= 2;
	bp += 2;

	if ((flags & GRE_CP) | (flags & GRE_RP)) {
		if (len < 2)
			goto trunc;
		if (vflag)
			printf(" sum 0x%x", EXTRACT_16BITS(bp));
		bp += 2;
		len -= 2;

		if (len < 2)
			goto trunc;
		printf(" off 0x%x", EXTRACT_16BITS(bp));
		bp += 2;
		len -= 2;
	}

	if (flags & GRE_KP) {
		uint32_t key, vsid;

		if (len < 4)
			goto trunc;
		key = EXTRACT_32BITS(bp);

		/* maybe NVGRE? */
		if (flags == (GRE_KP | 0) && prot == ETHERTYPE_TRANSETHER) {
			vsid = (key & NVGRE_VSID_MASK) >> NVGRE_VSID_SHIFT;
			printf(" NVGRE vsid=%u (0x%x)+flowid=0x%02x /",
			    vsid, vsid,
			    (key & NVGRE_FLOWID_MASK) >> NVGRE_FLOWID_SHIFT);
		}
		printf(" key=%u (0x%x)", key, key);
		bp += 4;
		len -= 4;
	}

	if (flags & GRE_SP) {
		if (len < 4)
			goto trunc;
		printf(" seq %u", EXTRACT_32BITS(bp));
		bp += 4;
		len -= 4;
	}

	if (flags & GRE_RP) {
		for (;;) {
			u_int16_t af;
			u_int8_t sreoff;
			u_int8_t srelen;

			if (len < 4)
				goto trunc;
			af = EXTRACT_16BITS(bp);
			sreoff = *(bp + 2);
			srelen = *(bp + 3);
			bp += 4;
			len -= 4;

			if (af == 0 && srelen == 0)
				break;

			gre_sre_print(af, sreoff, srelen, bp, len);

			if (len < srelen)
				goto trunc;
			bp += srelen;
			len -= srelen;
		}
	}

	printf(": ");

	switch (prot) {
	case ETHERTYPE_IP:
		ip_print(bp, len);
		break;
	case ETHERTYPE_IPV6:
		ip6_print(bp, len);
		break;
	case ETHERTYPE_MPLS:
		mpls_print(bp, len);
		break;
	case ETHERTYPE_TRANSETHER:
		ether_print(bp, len);
		break;
	default:
		printf("gre-proto-0x%x", prot);
	}
	return;

trunc:
	printf("[|gre]");
}

void
gre_print_1(const u_char *bp, u_int length)
{
	u_int len = length;
	u_int16_t flags, prot;

	flags = EXTRACT_16BITS(bp);
	len -= 2;
	bp += 2;

	if (vflag) {
		printf("[%s%s%s%s%s%s]",
		    (flags & GRE_CP) ? "C" : "",
		    (flags & GRE_RP) ? "R" : "",
		    (flags & GRE_KP) ? "K" : "",
		    (flags & GRE_SP) ? "S" : "",
		    (flags & GRE_sP) ? "s" : "",
		    (flags & GRE_AP) ? "A" : "");
	}

	if (len < 2)
		goto trunc;
	prot = EXTRACT_16BITS(bp);
	len -= 2;
	bp += 2;

	if (flags & GRE_CP) {
		printf(" cpset!");
		return;
	}
	if (flags & GRE_RP) {
		printf(" rpset!");
		return;
	}
	if ((flags & GRE_KP) == 0) {
		printf(" kpunset!");
		return;
	}
	if (flags & GRE_sP) {
		printf(" spset!");
		return;
	}

	if (flags & GRE_KP) {
		u_int32_t k;

		if (len < 4)
			goto trunc;
		k = EXTRACT_32BITS(bp);
		printf(" call %d", k & 0xffff);
		len -= 4;
		bp += 4;
	}

	if (flags & GRE_SP) {
		if (len < 4)
			goto trunc;
		printf(" seq %u", EXTRACT_32BITS(bp));
		bp += 4;
		len -= 4;
	}

	if (flags & GRE_AP) {
		if (len < 4)
			goto trunc;
		printf(" ack %u", EXTRACT_32BITS(bp));
		bp += 4;
		len -= 4;
	}

	if ((flags & GRE_SP) == 0) {
		printf(" no-payload");
		return;
	}

	printf(": ");

	switch (prot) {
	case ETHERTYPE_PPP:
		printf("gre-ppp-payload");
		break;
	default:
		printf("gre-proto-0x%x", prot);
		break;
	}
	return;

trunc:
	printf("[|gre]");
}

void
gre_sre_print(u_int16_t af, u_int8_t sreoff, u_int8_t srelen,
    const u_char *bp, u_int len)
{
	switch (af) {
	case GRESRE_IP:
		printf(" (rtaf=ip");
		gre_sre_ip_print(sreoff, srelen, bp, len);
		printf(")");
		break;
	case GRESRE_ASN:
		printf(" (rtaf=asn");
		gre_sre_asn_print(sreoff, srelen, bp, len);
		printf(")");
		break;
	default:
		printf(" (rtaf=0x%x)", af);
	}
}
void
gre_sre_ip_print(u_int8_t sreoff, u_int8_t srelen, const u_char *bp, u_int len)
{
	struct in_addr a;
	const u_char *up = bp;

	if (sreoff & 3) {
		printf(" badoffset=%u", sreoff);
		return;
	}
	if (srelen & 3) {
		printf(" badlength=%u", srelen);
		return;
	}
	if (sreoff >= srelen) {
		printf(" badoff/len=%u/%u", sreoff, srelen);
		return;
	}

	for (;;) {
		if (len < 4 || srelen == 0)
			return;

		memcpy(&a, bp, sizeof(a));
		printf(" %s%s",
		    ((bp - up) == sreoff) ? "*" : "",
		    inet_ntoa(a));

		bp += 4;
		len -= 4;
		srelen -= 4;
	}
}

void
gre_sre_asn_print(u_int8_t sreoff, u_int8_t srelen, const u_char *bp, u_int len)
{
	const u_char *up = bp;

	if (sreoff & 1) {
		printf(" badoffset=%u", sreoff);
		return;
	}
	if (srelen & 1) {
		printf(" badlength=%u", srelen);
		return;
	}
	if (sreoff >= srelen) {
		printf(" badoff/len=%u/%u", sreoff, srelen);
		return;
	}

	for (;;) {
		if (len < 2 || srelen == 0)
			return;

		printf(" %s%x",
		    ((bp - up) == sreoff) ? "*" : "",
		    EXTRACT_16BITS(bp));

		bp += 2;
		len -= 2;
		srelen -= 2;
	}
}
@


1.11
log
@Cap the GRE packet len to tcpdump's snap len, fixes a segfault.

From Kevin Reay, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-gre.c,v 1.10 2015/11/05 11:52:24 jca Exp $	*/
d42 2
a59 3
#define	GREPROTO_IP	0x0800		/* IP */
#define	GREPROTO_PPP	0x880b		/* PPTP */

d64 5
d89 2
a90 1
	if (vers == 0)
d92 2
a93 1
	else if (vers == 1)
d95 2
a96 1
	else
d98 2
a99 2
	return;

d124 2
d133 1
a133 1
			printf("sum 0x%x ", EXTRACT_16BITS(bp));
d139 1
a139 1
		printf("off 0x%x ", EXTRACT_16BITS(bp));
d145 2
d149 10
a158 1
		printf("key=0x%x ", EXTRACT_32BITS(bp));
d166 1
a166 1
		printf("seq %u ", EXTRACT_32BITS(bp));
d197 2
d200 1
a200 1
	case GREPROTO_IP:
d203 9
d232 1
a232 1
		printf("[%s%s%s%s%s%s] ",
d248 1
a248 1
		printf("cpset!");
d252 1
a252 1
		printf("rpset!");
d256 1
a256 1
		printf("kpunset!");
d260 1
a260 1
		printf("spset!");
d270 1
a270 1
		printf("call %d ", k & 0xffff);
d278 1
a278 1
		printf("seq %u ", EXTRACT_32BITS(bp));
d286 1
a286 1
		printf("ack %u ", EXTRACT_32BITS(bp));
d292 1
a292 1
		printf("no-payload");
d296 2
d299 1
a299 1
	case GREPROTO_PPP:
d318 1
a318 1
		printf("(rtaf=ip");
d320 1
a320 1
		printf(") ");
d323 1
a323 1
		printf("(rtaf=asn");
d325 1
a325 1
		printf(") ");
d328 1
a328 1
		printf("(rtaf=0x%x) ", af);
@


1.10
log
@When fetching the GRE version, use GRE_VERS and not a naked "7" as mask.

From Kevin Reay
@
text
@d1 1
a1 1
/*	$OpenBSD: print-gre.c,v 1.9 2015/01/16 06:40:21 deraadt Exp $	*/
d75 3
@


1.9
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-gre.c,v 1.8 2014/08/14 12:44:44 mpi Exp $	*/
d80 1
a80 1
	vers = EXTRACT_16BITS(bp) & 7;
@


1.8
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-gre.c,v 1.7 2003/06/03 00:21:04 jason Exp $	*/
a33 1
#include <sys/param.h>
@


1.7
log
@last bit of clause 3 & 4 nuking for me.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-gre.c,v 1.6 2002/10/30 03:04:04 fgsch Exp $	*/
a39 1
#include <netinet/in_systm.h>
@


1.6
log
@o for gre version 1, correctly check if kp (key present) is unset.
o remove trailing spaces for better output.
o print sequence, acknowledge and callid as unsigned, and remove key
  from version 1 since it's actually the payload length (not including
  the gre header).
jason@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-gre.c,v 1.4 2002/09/18 19:39:35 jason Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.5
log
@Handle RFC2637 (PPTP defines an enhanced GRE... *sigh*)
@
text
@d150 1
a150 1
		printf("seq=0x%x ", EXTRACT_32BITS(bp));
d221 1
a221 1
		printf("cpset! ");
d225 1
a225 1
		printf("rpset! ");
d228 2
a229 2
	if ((flags & GRE_KP) != 0) {
		printf("kpunset! ");
d233 1
a233 1
		printf("spset! ");
d243 1
a243 1
		printf("key=0x%x call=0x%x ", (k >> 16) & 0xffff, k & 0xffff);
d251 1
a251 1
		printf("seq=0x%x ", EXTRACT_32BITS(bp));
d259 1
a259 1
		printf("ack=0x%x ", EXTRACT_32BITS(bp));
d265 1
a265 1
		printf("no-payload ");
d271 1
a271 1
		printf("gre-ppp-payload ");
d274 1
a274 1
		printf("gre-proto-0x%x ", prot);
@


1.4
log
@Fully decode source routing elements defined in rfc1702
@
text
@d1 1
a1 1
/*	$OpenBSD: print-gre.c,v 1.3 2002/09/18 18:49:03 jason Exp $	*/
d35 2
a36 1
 * tcpdump filter for GRE - Generic Routing Encapsulation (RFC1701 and RFC1702)
d62 1
d66 1
d72 2
d81 21
a104 2
	if (len < 2)
		goto trunc;
a105 4
	if ((flags & 7) != 0) {
		printf("gre: unknown version %u", flags & 7);
		return;
	}
d114 1
a155 1
		/* Just skip over routing info */
d187 89
@


1.3
log
@Rewrite from scratch: same basic functionality, but better license and
knows how to skip routing info and process the rest of the packet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 4
d46 1
d49 1
d65 8
d152 2
d172 85
@


1.2
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d4 2
a5 2
 * Copyright (c) 1996
 *      The Regents of the University of California.  All rights reserved.
d7 13
a19 12
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Lawrence Berkeley Laboratory,
 * Berkeley, CA.  The name of the University may not be used to
 * endorse or promote products derived from this software without
 * specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d21 11
a31 5
 * Initial contribution from John Hawkinson <jhawk@@bbnplanet.com>
 *
 * This module implements support for decoding GRE (Generic Routing
 * Encapsulation) tunnels; they're documented in RFC1701 and RFC1702.
 * This code only supports the IP encapsulation thereof.
a33 5
#ifndef lint
static const char rcsid[] =
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-gre.c,v 1.1 1996/12/12 16:22:37 bitblt Exp $";
#endif

a42 1
#include <netdb.h>
d47 1
a47 34
#include "extract.h"		/* must come after interface.h */

#define GRE_SIZE (20)

struct gre {
	u_short flags;
	u_short proto;
	union {
		struct gre_ckof {
			u_short cksum;
			u_short offset;
		}        gre_ckof;
		u_int32_t key;
		u_int32_t seq;
	}     gre_void1;
	union {
		u_int32_t key;
		u_int32_t seq;
		u_int32_t routing;
	}     gre_void2;
	union {
		u_int32_t seq;
		u_int32_t routing;
	}     gre_void3;
	union {
		u_int32_t routing;
	}     gre_void4;
};

#define GRE_CP		0x8000	/* Checksum Present */
#define GRE_RP		0x4000	/* Routing Present */
#define GRE_KP		0x2000	/* Key Present */
#define GRE_SP		0x1000	/* Sequence Present */

d49 7
a55 1
#define GREPROTO_IP	0x0800
d57 1
a58 3
/*
 * Deencapsulate and print a GRE-tunneled IP datagram
 */
d62 2
a63 3
	const u_char *cp = bp + 4;
	const struct gre *gre;
	u_short flags, proto;
d65 17
a81 1
	gre = (const struct gre *)bp;
d83 1
a83 1
	if (length < GRE_SIZE) {
d85 17
a102 2
	flags = EXTRACT_16BITS(&gre->flags);
	proto = EXTRACT_16BITS(&gre->proto);
d104 7
a110 16
	if (vflag) {
		/* Decode the flags */
		putchar('[');
		if (flags & GRE_CP)
			putchar('C');
		if (flags & GRE_RP)
			putchar('R');
		if (flags & GRE_KP)
			putchar('K');
		if (flags & GRE_SP)
			putchar('S');
		fputs("] ", stdout);
	}
	/* Checksum & Offset are present */
	if ((flags & GRE_CP) | (flags & GRE_RP))
		cp += 4;
d112 7
a118 3
	/* We don't support routing fields (variable length) now. Punt. */
	if (flags & GRE_RP)
		return;
d120 24
a143 6
	if (flags & GRE_KP)
		cp += 4;
	if (flags & GRE_SP)
		cp += 4;

	switch (proto) {
d145 1
d147 1
a147 1
		ip_print(cp, length - ((cp - bp) / sizeof(u_char)));
a148 1

d150 1
a150 2
		printf("gre-proto-0x%04X", proto);
		break;
d155 1
a155 2
	fputs("[|gre]", stdout);

@


1.1
log
@*** empty log message ***
@
text
@d1 2
d29 1
a29 1
    "@@(#) $Header: print-gre.c,v 1.4 96/12/10 23:28:23 leres Exp $";
@

