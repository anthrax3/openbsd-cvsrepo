head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.8
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.10.0.26
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.18
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.22
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.20
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.10
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.8.0.26
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.24
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.22
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.20
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.18
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.16
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.14
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.12
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.10
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.8
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.6
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2016.01.15.18.02.18;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	jR9OKgc7MnXeFbOX;

1.13
date	2016.01.15.03.03.07;	author mmcc;	state Exp;
branches;
next	1.12;
commitid	4rp6deJlejoV8YGB;

1.12
date	2015.11.18.15.36.20;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	vQk1DzJRhR5UcrJ1;

1.11
date	2015.11.15.20.35.36;	author mmcc;	state Exp;
branches;
next	1.10;
commitid	kFQYMPTA5NvE3RXS;

1.10
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.15.01.11.26;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.03.14.31.56;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.44;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.14;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.15;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.24;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@remove a macro that was made an identity function by my previous commit

ok deraadt@@
@
text
@/*	$OpenBSD: parsenfsfh.c,v 1.13 2016/01/15 03:03:07 mmcc Exp $	*/

/*
 * Copyright (c) 1993, 1994 Jeffrey C. Mogul, Digital Equipment Corporation,
 * Western Research Laboratory. All rights reserved.
 * Copyright (c) 2001 Compaq Computer Corporation. All rights reserved.
 *
 *  Permission to use, copy, and modify this software and its
 *  documentation is hereby granted only under the following terms and
 *  conditions.  Both the above copyright notice and this permission
 *  notice must appear in all copies of the software, derivative works
 *  or modified versions, and any portions thereof, and both notices
 *  must appear in supporting documentation.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *    1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND COMPAQ COMPUTER CORPORATION
 *  DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 *  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO
 *  EVENT SHALL COMPAQ COMPUTER CORPORATION BE LIABLE FOR ANY
 *  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
 *  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 *  OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 *  SOFTWARE.
 */

/*
 * parsenfsfh.c - portable parser for NFS file handles
 *			uses all sorts of heuristics
 *
 * Jeffrey C. Mogul
 * Digital Equipment Corporation
 * Western Research Laboratory
 */

#include <sys/types.h>
#include <sys/time.h>

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#include "interface.h"
#include "nfsfh.h"

/*
 * This routine attempts to parse a file handle (in network byte order),
 * using heuristics to guess what kind of format it is in.  See the
 * file "fhandle_layouts" for a detailed description of the various
 * patterns we know about.
 *
 * The file handle is parsed into our internal representation of a
 * file-system id, and an internal representation of an inode-number.
 */

#define	FHT_UNKNOWN	0
#define	FHT_AUSPEX	1
#define	FHT_DECOSF	2
#define	FHT_IRIX4	3
#define	FHT_IRIX5	4
#define	FHT_SUNOS3	5
#define	FHT_SUNOS4	6
#define	FHT_ULTRIX	7
#define	FHT_VMSUCX	8
#define	FHT_SUNOS5	9
#define	FHT_AIX32	10
#define	FHT_HPUX9	11

#define	make_uint32(msb,b,c,lsb)\
	((lsb) + ((c)<<8) + ((b)<<16) + ((msb)<<24))

#define	make_uint24(msb,b, lsb)\
	((lsb) + ((b)<<8) + ((msb)<<16))

#define	make_uint16(msb,lsb)\
	((lsb) + ((msb)<<8))

#ifdef	__alpha
	/* or other 64-bit systems */
#define	make_uint48(msb,b,c,d,e,lsb)\
	((lsb) + ((e)<<8) + ((d)<<16) + ((c)<<24) + ((b)<<32) + ((msb)<<40))
#else
	/* on 32-bit systems ignore high-order bits */
#define	make_uint48(msb,b,c,d,e,lsb)\
	((lsb) + ((e)<<8) + ((d)<<16) + ((c)<<24))
#endif

static int is_UCX(unsigned char *);

void
Parse_fh(fh, fsidp, inop, osnamep, fsnamep)
caddr_t *fh;
my_fsid *fsidp;
ino_t *inop;
char **osnamep;		/* if non-NULL, return OS name here */
char **fsnamep;		/* if non-NULL, return server fs name here (for VMS) */
{
	unsigned char *fhp = (unsigned char *)fh;
	u_int32_t temp;
	int fhtype = FHT_UNKNOWN;

	/*
	 * This is basically a big decision tree
	 */
	if ((fhp[0] == 0) && (fhp[1] == 0)) {
	    /* bytes[0,1] == (0,0); rules out Ultrix, IRIX5, SUNOS5 */
	    /* probably rules out HP-UX, AIX unless they allow major=0 */
	    if ((fhp[2] == 0) && (fhp[3] == 0)) {
		/* bytes[2,3] == (0,0); must be Auspex */
		/* XXX or could be Ultrix+MASSBUS "hp" disk? */
		fhtype = FHT_AUSPEX;
	    }
	    else {
		/*
		 * bytes[2,3] != (0,0); rules out Auspex, could be
		 * DECOSF, SUNOS4, or IRIX4
		 */
		if ((fhp[4] != 0) && (fhp[5] == 0) &&
			(fhp[8] == 12) && (fhp[9] == 0)) {
		    /* seems to be DECOSF, with minor == 0 */
		    fhtype = FHT_DECOSF;
		}
		else {
		    /* could be SUNOS4 or IRIX4 */
		    /* XXX the test of fhp[5] == 8 could be wrong */
		    if ((fhp[4] == 0) && (fhp[5] == 8) && (fhp[6] == 0) &&
			(fhp[7] == 0)) {
			/* looks like a length, not a file system typecode */
			fhtype = FHT_IRIX4;
		    }
		    else {
			/* by elimination */
			fhtype = FHT_SUNOS4;
		    }
		}
	    }
	}
	else {
	    /*
	     * bytes[0,1] != (0,0); rules out Auspex, IRIX4, SUNOS4
	     * could be IRIX5, DECOSF, UCX, Ultrix, SUNOS5
	     * could be AIX, HP-UX
	     */
	    if ((fhp[2] == 0) && (fhp[3] == 0)) {
		/*
		 * bytes[2,3] == (0,0); rules out OSF, probably not UCX
		 * (unless the exported device name is just one letter!),
		 * could be Ultrix, IRIX5, AIX, or SUNOS5
		 * might be HP-UX (depends on their values for minor devs)
		 */
		/*XXX we probably only need to test of these two bytes */
		if ((fhp[21] == 0) && (fhp[23] == 0)) {
		    fhtype = FHT_ULTRIX;
		}
		else {
		    /* Could be SUNOS5/IRIX5, maybe AIX */
		    /* XXX no obvious difference between SUNOS5 and IRIX5 */
		    if (fhp[9] == 10)
			fhtype = FHT_SUNOS5;
		    /* XXX what about AIX? */
		}
	    }
	    else {
		/*
		 * bytes[2,3] != (0,0); rules out Ultrix, could be
		 * DECOSF, SUNOS5, IRIX5, AIX, HP-UX, or UCX
		 */
		if ((fhp[8] == 12) && (fhp[9] == 0)) {
		    fhtype = FHT_DECOSF;
		}
		else if ((fhp[8] == 0) && (fhp[9] == 10)) {
		    /* could be SUNOS5/IRIX5, AIX, HP-UX */
		    if ((fhp[7] == 0) && (fhp[6] == 0) &&
			(fhp[5] == 0) && (fhp[4] == 0)) {
			/* XXX is this always true of HP-UX? */
			fhtype = FHT_HPUX9;
		    }
		    else if (fhp[7] == 2) {
			/* This would be MNT_NFS on AIX, which is impossible */
			fhtype = FHT_SUNOS5;	/* or maybe IRIX5 */
		    }
		    else {
			/*
			 * XXX Could be SUNOS5/IRIX5 or AIX.  I don't
			 * XXX see any way to disambiguate these, so
			 * XXX I'm going with the more likely guess.
			 * XXX Sorry, Big Blue.
			 */
			fhtype = FHT_SUNOS5;	/* or maybe IRIX5 */
		    }
	        }
		else {
		    if (is_UCX(fhp)) {
			fhtype = FHT_VMSUCX;
		    }
		    else {
			fhtype = FHT_UNKNOWN;
		    }
		}
	    }
	}

	/* XXX still needs to handle SUNOS3 */

	switch (fhtype) {
	case FHT_AUSPEX:
	    fsidp->Fsid_dev.Minor = fhp[7];
	    fsidp->Fsid_dev.Major = fhp[6];
	    fsidp->fsid_code = 0;

	    temp = make_uint32(fhp[12], fhp[13], fhp[14], fhp[15]);
	    *inop = temp;

	    if (osnamep)
		*osnamep = "Auspex";
	    break;

	case FHT_DECOSF:
	    fsidp->fsid_code = make_uint32(fhp[7], fhp[6], fhp[5], fhp[4]);
			/* XXX could ignore 3 high-order bytes */

	    temp = make_uint32(fhp[3], fhp[2], fhp[1], fhp[0]);
	    fsidp->Fsid_dev.Minor = temp & 0xFFFFF;
	    fsidp->Fsid_dev.Major = (temp>>20) & 0xFFF;

	    temp = make_uint32(fhp[15], fhp[14], fhp[13], fhp[12]);
	    *inop = temp;
	    if (osnamep)
		*osnamep = "OSF";
	    break;

	case FHT_IRIX4:
	    fsidp->Fsid_dev.Minor = fhp[3];
	    fsidp->Fsid_dev.Major = fhp[2];
	    fsidp->fsid_code = 0;

	    temp = make_uint32(fhp[8], fhp[9], fhp[10], fhp[11]);
	    *inop = temp;

	    if (osnamep)
		*osnamep = "IRIX4";
	    break;

	case FHT_IRIX5:
	    fsidp->Fsid_dev.Minor = make_uint16(fhp[2], fhp[3]);
	    fsidp->Fsid_dev.Major = make_uint16(fhp[0], fhp[1]);
	    fsidp->fsid_code = make_uint32(fhp[4], fhp[5], fhp[6], fhp[7]);

	    temp = make_uint32(fhp[12], fhp[13], fhp[14], fhp[15]);
	    *inop = temp;

	    if (osnamep)
		*osnamep = "IRIX5";
	    break;

	case FHT_SUNOS3:
	    if (osnamep)
		*osnamep = "SUNOS3";
	    break;

	case FHT_SUNOS4:
	    fsidp->Fsid_dev.Minor = fhp[3];
	    fsidp->Fsid_dev.Major = fhp[2];
	    fsidp->fsid_code = make_uint32(fhp[4], fhp[5], fhp[6], fhp[7]);

	    temp = make_uint32(fhp[12], fhp[13], fhp[14], fhp[15]);
	    *inop = temp;

	    if (osnamep)
		*osnamep = "SUNOS4";
	    break;

	case FHT_SUNOS5:
	    temp = make_uint16(fhp[0], fhp[1]);
	    fsidp->Fsid_dev.Major = (temp>>2) &  0x3FFF;
	    temp = make_uint24(fhp[1], fhp[2], fhp[3]);
	    fsidp->Fsid_dev.Minor = temp & 0x3FFFF;
	    fsidp->fsid_code = make_uint32(fhp[4], fhp[5], fhp[6], fhp[7]);

	    temp = make_uint32(fhp[12], fhp[13], fhp[14], fhp[15]);
	    *inop = temp;

	    if (osnamep)
		*osnamep = "SUNOS5";
	    break;

	case FHT_ULTRIX:
	    fsidp->fsid_code = 0;
	    fsidp->Fsid_dev.Minor = fhp[0];
	    fsidp->Fsid_dev.Major = fhp[1];

	    temp = make_uint32(fhp[7], fhp[6], fhp[5], fhp[4]);
	    *inop = temp;
	    if (osnamep)
		*osnamep = "Ultrix";
	    break;

	case FHT_VMSUCX:
	    /* No numeric file system ID, so hash on the device-name */
	    if (sizeof(*fsidp) >= 14) {
		if (sizeof(*fsidp) > 14)
		    memset((char *)fsidp, 0, sizeof(*fsidp));
		/* just use the whole thing */
		memcpy((char *)fsidp, (char *)fh, 14);
	    }
	    else {
		u_int32_t tempa[4];	/* at least 16 bytes, maybe more */

		memset((char *)tempa, 0, sizeof(tempa));
		memcpy((char *)tempa, (char *)fh, 14); /* ensure alignment */
		fsidp->Fsid_dev.Minor = tempa[0] + (tempa[1]<<1);
		fsidp->Fsid_dev.Major = tempa[2] + (tempa[3]<<1);
		fsidp->fsid_code = 0;
	    }

	    /* VMS file ID is: (RVN, FidHi, FidLo) */
	    *inop = make_uint32(fhp[26], fhp[27], fhp[23], fhp[22]);

	    /* Caller must save (and null-terminate?) this value */
	    if (fsnamep)
		*fsnamep = (char *)&(fhp[1]);

	    if (osnamep)
		*osnamep = "VMS";
	    break;

	case FHT_AIX32:
	    fsidp->Fsid_dev.Minor = make_uint16(fhp[2], fhp[3]);
	    fsidp->Fsid_dev.Major = make_uint16(fhp[0], fhp[1]);
	    fsidp->fsid_code = make_uint32(fhp[4], fhp[5], fhp[6], fhp[7]);

	    temp = make_uint32(fhp[12], fhp[13], fhp[14], fhp[15]);
	    *inop = temp;

	    if (osnamep)
		*osnamep = "AIX32";
	    break;

	case FHT_HPUX9:
	    fsidp->Fsid_dev.Major = fhp[0];
	    temp = make_uint24(fhp[1], fhp[2], fhp[3]);
	    fsidp->Fsid_dev.Minor = temp;
	    fsidp->fsid_code = make_uint32(fhp[4], fhp[5], fhp[6], fhp[7]);

	    temp = make_uint32(fhp[12], fhp[13], fhp[14], fhp[15]);
	    *inop = temp;

	    if (osnamep)
		*osnamep = "HPUX9";
	    break;

	case FHT_UNKNOWN:
#ifdef DEBUG
	    {
		int i;
		for (i = 0; i < 32; i++)
			(void)fprintf(stderr, "%x.", fhp[i]);
		(void)fprintf(stderr, "\n");
	    }
#endif
	    /* XXX for now, give "bogus" values to aid debugging */
	    fsidp->fsid_code = 0;
	    fsidp->Fsid_dev.Minor = 257;
	    fsidp->Fsid_dev.Major = 257;
	    *inop = 1;

	    /* display will show this string instead of (257,257) */
	    if (fsnamep)
		*fsnamep = "Unknown";

	    if (osnamep)
		*osnamep = "Unknown";
	    break;

	}
}

/*
 * Is this a VMS UCX file handle?
 *	Check for:
 *	(1) leading code byte	[XXX not yet]
 *	(2) followed by string of printing chars & spaces
 *	(3) followed by string of nulls
 */
static int
is_UCX(fhp)
unsigned char *fhp;
{
	int i;
	int seen_null = 0;

	for (i = 1; i < 14; i++) {
	    if (isprint(fhp[i])) {
		if (seen_null)
		   return(0);
		else
		   continue;
	    }
	    else if (fhp[i] == 0) {
		seen_null = 1;
		continue;
	    }
	    else
		return(0);
	}

	return(1);
}
@


1.13
log
@Remove preprocessor conditions (checking for ancient OSs) that try to
divine whether a file handle was generated on the current host. More
simplifications to come.

supported by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parsenfsfh.c,v 1.12 2015/11/18 15:36:20 mmcc Exp $	*/
a77 2
#define	XFF(x)	(x)

d79 1
a79 1
	(XFF(lsb) + (XFF(c)<<8) + (XFF(b)<<16) + (XFF(msb)<<24))
d82 1
a82 1
	(XFF(lsb) + (XFF(b)<<8) + (XFF(msb)<<16))
d85 1
a85 1
	(XFF(lsb) + (XFF(msb)<<8))
@


1.12
log
@Remove memory.h includes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parsenfsfh.c,v 1.11 2015/11/15 20:35:36 mmcc Exp $	*/
a77 4
#ifdef	ultrix
/* Nasty hack to keep the Ultrix C compiler from emitting bogus warnings */
#define	XFF(x)	((u_int32_t)(x))
#else
a78 1
#endif
d102 1
a102 1
Parse_fh(fh, fsidp, inop, osnamep, fsnamep, ourself)
a107 1
int ourself;		/* true if file handle was generated on this host */
a112 24
	if (ourself) {
	    /* File handle generated on this host, no need for guessing */
#if	defined(IRIX40)
	    fhtype = FHT_IRIX4;
#endif
#if	defined(IRIX50)
	    fhtype = FHT_IRIX5;
#endif
#if	defined(IRIX51)
	    fhtype = FHT_IRIX5;
#endif
#if	defined(SUNOS4)
	    fhtype = FHT_SUNOS4;
#endif
#if	defined(SUNOS5)
	    fhtype = FHT_SUNOS5;
#endif
#if	defined(ultrix)
	    fhtype = FHT_ULTRIX;
#endif
#if	defined(__osf__)
	    fhtype = FHT_DECOSF;
#endif
	}
d116 1
a116 1
	else if ((fhp[0] == 0) && (fhp[1] == 0)) {
a365 1
		/* XXX debugging */
@


1.11
log
@Remove more register keywords.

ok daniel@@, discussed on hackers@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parsenfsfh.c,v 1.10 2009/10/27 23:59:55 deraadt Exp $	*/
a48 1
#include <memory.h>
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: parsenfsfh.c,v 1.9 2007/10/07 16:41:05 deraadt Exp $	*/
d109 1
a109 1
register caddr_t *fh;
d116 1
a116 1
	register unsigned char *fhp = (unsigned char *)fh;
d432 1
a432 1
	register int i;
@


1.9
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: parsenfsfh.c,v 1.8 2001/06/15 01:11:26 itojun Exp $	*/
a43 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.8
log
@copyright clarification.  sync with tcpdump.org.
based on communiation with the author, Jeffrey Mogul <mogul@@pa.dec.com>.
by Jakob Schlyter <jakob@@openbsd.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: parsenfsfh.c,v 1.7 2000/10/03 14:31:56 ho Exp $	*/
d47 1
a47 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/parsenfsfh.c,v 1.7 2000/10/03 14:31:56 ho Exp $ (LBL)";
@


1.7
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 34
a34 1
/*	$OpenBSD$	*/
d47 1
a47 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/parsenfsfh.c,v 1.6 1999/07/28 20:41:36 jakob Exp $ (LBL)";
@


1.6
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d1 2
d14 1
a14 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/parsenfsfh.c,v 1.5 1996/12/12 16:22:44 bitblt Exp $ (LBL)";
@


1.5
log
@*** empty log message ***
@
text
@d12 1
a12 1
    "@@(#) $Header: parsenfsfh.c,v 1.12 96/12/10 23:25:50 leres Exp $ (LBL)";
d315 2
a316 1
		memcpy((char *)fsidp, fh, 14);	/* just use the whole thing */
d322 1
a322 1
		memcpy((char *)tempa, fh, 14);	/* ensure alignment */
@


1.4
log
@it is 3.2 now.
@
text
@a0 6
/*	$OpenBSD$	*/

#ifndef lint
static char *RCSid = "Header: parsenfsfh.c,v 1.9 95/10/19 20:27:44 leres Exp";
#endif

d10 5
d219 2
a220 2
	    fsidp->fsid_dev.Minor = fhp[7];
	    fsidp->fsid_dev.Major = fhp[6];
d235 2
a236 2
	    fsidp->fsid_dev.Minor = temp & 0xFFFFF;
	    fsidp->fsid_dev.Major = (temp>>20) & 0xFFF;
d245 2
a246 2
	    fsidp->fsid_dev.Minor = fhp[3];
	    fsidp->fsid_dev.Major = fhp[2];
d257 2
a258 2
	    fsidp->fsid_dev.Minor = make_uint16(fhp[2], fhp[3]);
	    fsidp->fsid_dev.Major = make_uint16(fhp[0], fhp[1]);
d274 2
a275 2
	    fsidp->fsid_dev.Minor = fhp[3];
	    fsidp->fsid_dev.Major = fhp[2];
d287 1
a287 1
	    fsidp->fsid_dev.Major = (temp>>2) &  0x3FFF;
d289 1
a289 1
	    fsidp->fsid_dev.Minor = temp & 0x3FFFF;
d301 2
a302 2
	    fsidp->fsid_dev.Minor = fhp[0];
	    fsidp->fsid_dev.Major = fhp[1];
d322 2
a323 2
		fsidp->fsid_dev.Minor = tempa[0] + (tempa[1]<<1);
		fsidp->fsid_dev.Major = tempa[2] + (tempa[3]<<1);
d339 2
a340 2
	    fsidp->fsid_dev.Minor = make_uint16(fhp[2], fhp[3]);
	    fsidp->fsid_dev.Major = make_uint16(fhp[0], fhp[1]);
d351 1
a351 1
	    fsidp->fsid_dev.Major = fhp[0];
d353 1
a353 1
	    fsidp->fsid_dev.Minor = temp;
d375 2
a376 2
	    fsidp->fsid_dev.Minor = 257;
	    fsidp->fsid_dev.Major = 257;
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: parsenfsfh.c,v 1.3 1996/05/20 00:41:07 fvdl Exp $	*/
/*	$NetBSD: parsenfsfh.c,v 1.3 1996/05/20 00:41:07 fvdl Exp $	*/
d4 1
a4 1
static char *RCSid = "Header: parsenfsfh.c,v 1.5 94/01/13 19:06:41 leres Exp";
d19 2
a21 1
#include <ctype.h>
a27 8
 * Make sure that we use 32-bit integers when necessary.  The "x"
 * suffix is to avoid possible identifier conflicts.
 */

typedef int int32x;
typedef unsigned int u_int32x;

/*
d52 1
a52 1
#define	XFF(x)	((unsigned long)(x))
d79 1
a79 1
Parse_fh(fh, len, fsidp, inop, osnamep, fsnamep, ourself)
a80 1
int len;
d88 1
a88 1
	u_int32x temp;
d315 2
a316 2
		    bzero((char *)fsidp, sizeof(*fsidp));
		bcopy(fh, (char *)fsidp, 14);	/* just use the whole thing */
d319 1
a319 1
		u_long tempa[4];	/* at least 16 bytes, maybe more */
d321 2
a322 2
		bzero((char *)tempa, sizeof(tempa));
		bcopy(fh, (char *)tempa, 14);	/* ensure alignment */
d369 3
a371 2
		for (i=0; i<32;i++) fprintf(stderr, "%x.", fhp[i]);
		fprintf(stderr, "\n");
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: parsenfsfh.c,v 1.2 1995/03/06 19:11:00 mycroft Exp $	*/
d87 1
a87 1
Parse_fh(fh, fsidp, inop, osnamep, fsnamep, ourself)
d89 1
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
