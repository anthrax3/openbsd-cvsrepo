head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.26
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.18
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.10
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.6.0.30
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.28
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.26
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.24
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.22
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.20
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.18
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.16
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.14
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.12
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.10
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.8
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2017.08.30.09.23.00;	author otto;	state Exp;
branches;
next	1.9;
commitid	sxpxCZczzbev4y6h;

1.9
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.8;
commitid	enjTsnD5UO6xazKc;

1.8
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.03.14.31.58;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.24;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.33;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.42;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@unsigneds cannot be < 0; ok jca@@
@
text
@/*	$OpenBSD: print-wb.c,v 1.9 2015/11/16 00:16:39 mmcc Exp $	*/

/*
 * Copyright (c) 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/types.h>
#include <sys/time.h>

#include <netinet/in.h>

#include <stdio.h>

#include "interface.h"
#include "addrtoname.h"

/* XXX need to add byte-swapping macros! */

/*
 * Largest packet size.  Everything should fit within this space.
 * For instance, multiline objects are sent piecewise.
 */
#define MAXFRAMESIZE 1024

/*
 * Multiple drawing ops can be sent in one packet.  Each one starts on a
 * an even multiple of DOP_ALIGN bytes, which must be a power of two.
 */
#define DOP_ALIGN 4
#define DOP_ROUNDUP(x)	((((int)(x)) + (DOP_ALIGN - 1)) & ~(DOP_ALIGN - 1))
#define DOP_NEXT(d)\
	((struct dophdr *)((u_char *)(d) + \
			  DOP_ROUNDUP(ntohs((d)->dh_len) + sizeof(*(d)))))

/*
 * Format of the whiteboard packet header.
 * The transport level header.
 */
struct pkt_hdr {
	u_int32_t ph_src;		/* site id of source */
	u_int32_t ph_ts;		/* time stamp (for skew computation) */
	u_short ph_version;	/* version number */
	u_char ph_type;		/* message type */
	u_char ph_flags;	/* message flags */
};

/* Packet types */
#define PT_DRAWOP	0	/* drawing operation */
#define PT_ID		1	/* announcement packet */
#define PT_RREQ		2	/* repair request */
#define PT_RREP		3	/* repair reply */
#define PT_KILL		4	/* terminate participation */
#define PT_PREQ         5       /* page vector request */
#define PT_PREP         7       /* page vector reply */

/* flags */
#define PF_USER		0x01	/* hint that packet has interactive data */
#define PF_VIS		0x02	/* only visible ops wanted */

struct PageID {
	u_int32_t p_sid;		/* session id of initiator */
	u_int32_t p_uid;		/* page number */
};

struct dophdr {
	u_int32_t  dh_ts;		/* sender's timestamp */
	u_short	dh_len;		/* body length */
	u_char	dh_flags;
	u_char	dh_type;	/* body type */
	/* body follows */
};
/*
 * Drawing op sub-types.
 */
#define DT_RECT         2
#define DT_LINE         3
#define DT_ML           4
#define DT_DEL          5
#define DT_XFORM        6
#define DT_ELL          7
#define DT_CHAR         8
#define DT_STR          9
#define DT_NOP          10
#define DT_PSCODE       11
#define DT_PSCOMP       12
#define DT_REF          13
#define DT_SKIP         14
#define DT_HOLE         15
#define DT_MAXTYPE      15

/*
 * A drawing operation.
 */
struct pkt_dop {
	struct PageID pd_page;	/* page that operations apply to */
	u_int32_t	pd_sseq;	/* start sequence number */
	u_int32_t	pd_eseq;	/* end sequence number */
	/* drawing ops follow */
};

/*
 * A repair request.
 */
struct pkt_rreq {
        u_int32_t pr_id;           /* source id of drawops to be repaired */
        struct PageID pr_page;           /* page of drawops */
        u_int32_t pr_sseq;         /* start seqno */
        u_int32_t pr_eseq;         /* end seqno */
};

/*
 * A repair reply.
 */
struct pkt_rrep {
	u_int32_t pr_id;	/* original site id of ops  */
	struct pkt_dop pr_dop;
	/* drawing ops follow */
};

struct id_off {
        u_int32_t id;
        u_int32_t off;
};

struct pgstate {
	u_int32_t slot;
	struct PageID page;
	u_short nid;
	u_short rsvd;
        /* seqptr's */
};

/*
 * An announcement packet.
 */
struct pkt_id {
	u_int32_t pi_mslot;
        struct PageID    pi_mpage;        /* current page */
	struct pgstate pi_ps;
        /* seqptr's */
        /* null-terminated site name */
};

struct pkt_preq {
        struct PageID  pp_page;
        u_int32_t  pp_low;
        u_int32_t  pp_high;
};

struct pkt_prep {
        u_int32_t  pp_n;           /* size of pageid array */
        /* pgstate's follow */
};

static int
wb_id(const struct pkt_id *id, u_int len)
{
	int i;
	const char *cp;
	const struct id_off *io;
	char c;
	int nid;

	printf(" wb-id:");
	len -= sizeof(*id);
	if ((u_char *)(id + 1) > snapend)
		return (-1);

	printf(" %u/%s:%u (max %u/%s:%u) ",
	       (u_int32_t)ntohl(id->pi_ps.slot),
	       ipaddr_string(&id->pi_ps.page.p_sid),
	       (u_int32_t)ntohl(id->pi_ps.page.p_uid),
	       (u_int32_t)ntohl(id->pi_mslot),
	       ipaddr_string(&id->pi_mpage.p_sid),
	       (u_int32_t)ntohl(id->pi_mpage.p_uid));

	nid = ntohs(id->pi_ps.nid);
	len -= sizeof(*io) * nid;
	io = (struct id_off *)(id + 1);
	cp = (char *)(io + nid);
	if ((u_char *)cp + len <= snapend) {
		putchar('"');
		(void)fn_print((u_char *)cp, (u_char *)cp + len);
		putchar('"');
	}

	c = '<';
	for (i = 0; i < nid && (u_char *)io < snapend; ++io, ++i) {
		printf("%c%s:%u",
		    c, ipaddr_string(&io->id), (u_int32_t)ntohl(io->off));
		c = ',';
	}
	if (i >= nid) {
		printf(">");
		return (0);
	}
	return (-1);
}

static int
wb_rreq(const struct pkt_rreq *rreq, u_int len)
{
	printf(" wb-rreq:");
	if (len < sizeof(*rreq) || (u_char *)(rreq + 1) > snapend)
		return (-1);

	printf(" please repair %s %s:%u<%u:%u>",
	       ipaddr_string(&rreq->pr_id),
	       ipaddr_string(&rreq->pr_page.p_sid),
	       (u_int32_t)ntohl(rreq->pr_page.p_uid),
	       (u_int32_t)ntohl(rreq->pr_sseq),
	       (u_int32_t)ntohl(rreq->pr_eseq));
	return (0);
}

static int
wb_preq(const struct pkt_preq *preq, u_int len)
{
	printf(" wb-preq:");
	if (len < sizeof(*preq) || (u_char *)(preq + 1) > snapend)
		return (-1);

	printf(" need %u/%s:%u",
	       (u_int32_t)ntohl(preq->pp_low),
	       ipaddr_string(&preq->pp_page.p_sid),
	       (u_int32_t)ntohl(preq->pp_page.p_uid));
	return (0);
}

static int
wb_prep(const struct pkt_prep *prep, u_int len)
{
	int n;
	const struct pgstate *ps;
	const u_char *ep = snapend;

	printf(" wb-prep:");
	if (len < sizeof(*prep)) {
		return (-1);
	}
	n = ntohl(prep->pp_n);
	ps = (const struct pgstate *)(prep + 1);
	while (--n >= 0 && (u_char *)ps < ep) {
		const struct id_off *io, *ie;
		char c = '<';

		printf(" %u/%s:%u",
		    (u_int32_t)ntohl(ps->slot),
		    ipaddr_string(&ps->page.p_sid),
		    (u_int32_t)ntohl(ps->page.p_uid));
		io = (struct id_off *)(ps + 1);
		for (ie = io + ps->nid; io < ie && (u_char *)io < ep; ++io) {
			printf("%c%s:%u", c, ipaddr_string(&io->id),
			    (u_int32_t)ntohl(io->off));
			c = ',';
		}
		printf(">");
		ps = (struct pgstate *)io;
	}
	return ((u_char *)ps <= ep? 0 : -1);
}


char *dopstr[] = {
	"dop-0!",
	"dop-1!",
	"RECT",
	"LINE",
	"ML",
	"DEL",
	"XFORM",
	"ELL",
	"CHAR",
	"STR",
	"NOP",
	"PSCODE",
	"PSCOMP",
	"REF",
	"SKIP",
	"HOLE",
};

static int
wb_dops(const struct dophdr *dh, u_int32_t ss, u_int32_t es)
{
	printf(" <");
	for ( ; ss <= es; ++ss) {
		int t = dh->dh_type;

		if (t > DT_MAXTYPE)
			printf(" dop-%d!", t);
		else {
			printf(" %s", dopstr[t]);
			if (t == DT_SKIP || t == DT_HOLE) {
				int ts = ntohl(dh->dh_ts);
				printf("%d", ts - ss + 1);
				if (ss > ts || ts > es) {
					printf("[|]");
					if (ts < ss)
						return (0);
				}
				ss = ts;
			}
		}
		dh = DOP_NEXT(dh);
		if ((u_char *)dh > snapend) {
			printf("[|wb]");
			break;
		}
	}
	printf(" >");
	return (0);
}

static int
wb_rrep(const struct pkt_rrep *rrep, u_int len)
{
	const struct pkt_dop *dop = &rrep->pr_dop;

	printf(" wb-rrep:");
	len -= sizeof(*rrep);
	if ((u_char *)(rrep + 1) > snapend)
		return (-1);

	printf(" for %s %s:%u<%u:%u>",
	    ipaddr_string(&rrep->pr_id),
	    ipaddr_string(&dop->pd_page.p_sid),
	    (u_int32_t)ntohl(dop->pd_page.p_uid),
	    (u_int32_t)ntohl(dop->pd_sseq),
	    (u_int32_t)ntohl(dop->pd_eseq));

	if (vflag)
		return (wb_dops((const struct dophdr *)(dop + 1),
		    ntohl(dop->pd_sseq), ntohl(dop->pd_eseq)));
	return (0);
}

static int
wb_drawop(const struct pkt_dop *dop, u_int len)
{
	printf(" wb-dop:");
	len -= sizeof(*dop);
	if ((u_char *)(dop + 1) > snapend)
		return (-1);

	printf(" %s:%u<%u:%u>",
	    ipaddr_string(&dop->pd_page.p_sid),
	    (u_int32_t)ntohl(dop->pd_page.p_uid),
	    (u_int32_t)ntohl(dop->pd_sseq),
	    (u_int32_t)ntohl(dop->pd_eseq));

	if (vflag)
		return (wb_dops((const struct dophdr *)(dop + 1),
				ntohl(dop->pd_sseq), ntohl(dop->pd_eseq)));
	return (0);
}

/*
 * Print whiteboard multicast packets.
 */
void
wb_print(const void *hdr, u_int len)
{
	const struct pkt_hdr *ph;

	ph = (const struct pkt_hdr *)hdr;
	len -= sizeof(*ph);
	if ((u_char *)(ph + 1) <= snapend) {
		if (ph->ph_flags)
			printf("*");
		switch (ph->ph_type) {

		case PT_KILL:
			printf(" wb-kill");
			return;

		case PT_ID:
			if (wb_id((struct pkt_id *)(ph + 1), len) >= 0)
				return;
			break;

		case PT_RREQ:
			if (wb_rreq((struct pkt_rreq *)(ph + 1), len) >= 0)
				return;
			break;

		case PT_RREP:
			if (wb_rrep((struct pkt_rrep *)(ph + 1), len) >= 0)
				return;
			break;

		case PT_DRAWOP:
			if (wb_drawop((struct pkt_dop *)(ph + 1), len) >= 0)
				return;
			break;

		case PT_PREQ:
			if (wb_preq((struct pkt_preq *)(ph + 1), len) >= 0)
				return;
			break;

		case PT_PREP:
			if (wb_prep((struct pkt_prep *)(ph + 1), len) >= 0)
				return;
			break;

		default:
			printf(" wb-%d!", ph->ph_type);
			return;
		}
	}
	printf("[|wb]");
}
@


1.9
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-wb.c,v 1.8 2009/10/27 23:59:57 deraadt Exp $	*/
d183 1
a183 1
	if (len < 0 || (u_char *)(id + 1) > snapend)
d339 1
a339 1
	if (len < 0 || (u_char *)(rrep + 1) > snapend)
d360 1
a360 1
	if (len < 0 || (u_char *)(dop + 1) > snapend)
d385 1
a385 1
	if (len < 0 || (u_char *)(ph + 1) <= snapend) {
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-wb.c,v 1.7 2007/10/07 16:41:05 deraadt Exp $	*/
d305 1
a305 1
		register int t = dh->dh_type;
d379 1
a379 1
wb_print(register const void *hdr, register u_int len)
d381 1
a381 1
	register const struct pkt_hdr *ph;
@


1.7
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-wb.c,v 1.6 2000/10/03 14:31:58 ho Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.6
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-wb.c,v 1.5 1996/12/12 16:22:24 bitblt Exp $ (LBL)";
@


1.5
log
@*** empty log message ***
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: print-wb.c,v 1.23 96/12/10 23:21:43 leres Exp $ (LBL)";
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1993, 1994, 1995
d23 2
a24 2
static char rcsid[] =
    "@@(#) Header: print-wb.c,v 1.18 95/10/18 22:21:27 leres Exp (LBL)";
d52 1
a52 1
	((struct dophdr*)((u_char *)(d) + \
d128 1
a128 1
        u_int32_t pr_eseq;         /* end seqno*/
d176 1
a176 1
wb_id(const struct pkt_id *id, int len)
d201 5
a205 2
	if ((u_char *)cp + len <= snapend)
		fn_print((u_char *)cp, (u_char *)cp + len);
d208 1
a208 1
	for (i = 0; i < nid && (u_char*)io < snapend; ++io, ++i) {
d221 1
a221 1
wb_rreq(const struct pkt_rreq *rreq, int len)
d237 1
a237 1
wb_preq(const struct pkt_preq *preq, int len)
d251 1
a251 1
wb_prep(const struct pkt_prep *prep, int len)
d254 2
a255 2
	const struct pgstate* ps;
	const u_char* ep = snapend;
d262 2
a263 2
	ps = (const struct pgstate*)(prep + 1);
	while (--n >= 0 && (u_char*)ps < ep) {
d271 2
a272 2
		io = (struct id_off*)(ps + 1);
		for (ie = io + ps->nid; io < ie && (u_char*)io < ep; ++io) {
d278 1
a278 1
		ps = (struct pgstate*)io;
d280 1
a280 1
	return ((u_char*)ps <= ep? 0 : -1);
d326 1
a326 1
		if ((u_char*)dh >= snapend) {
d336 1
a336 1
wb_rrep(const struct pkt_rrep *rrep, int len)
d353 1
a353 1
		return (wb_dops((const struct dophdr*)(dop + 1),
d359 1
a359 1
wb_drawop(const struct pkt_dop *dop, int len)
d373 1
a373 1
		return (wb_dops((const struct dophdr*)(dop + 1),
d382 1
a382 1
wb_print(register const void *hdr, register int len)
d384 1
a384 1
	register const struct pkt_hdr* ph;
d386 1
a386 1
	ph = (const struct pkt_hdr*)hdr;
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-wb.c,v 1.2 1995/03/06 19:11:37 mycroft Exp $	*/
/*	$NetBSD: print-wb.c,v 1.2 1995/03/06 19:11:37 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1993, 1994
d26 1
a26 1
    "@@(#) Header: print-wb.c,v 1.14 94/06/14 20:18:50 leres Exp (LBL)";
d62 2
a63 2
	u_int32 ph_src;		/* site id of source */
	u_int32 ph_ts;		/* time stamp (for skew computation) */
d83 2
a84 2
	u_int32 p_sid;		/* session id of initiator */
	u_int32 p_uid;		/* page number */
d88 1
a88 1
	u_int32  dh_ts;		/* sender's timestamp */
d118 2
a119 2
	u_int32	pd_sseq;	/* start sequence number */
	u_int32	pd_eseq;	/* end sequence number */
d127 1
a127 1
        u_int32 pr_id;           /* source id of drawops to be repaired */
d129 2
a130 2
        u_int32 pr_sseq;         /* start seqno */
        u_int32 pr_eseq;         /* end seqno*/
d137 1
a137 1
	u_int32 pr_id;	/* original site id of ops  */
d143 2
a144 2
        u_int32 id;
        u_int32 off;
d148 1
a148 1
	u_int32 slot;
d159 1
a159 1
	u_int32 pi_mslot;
d168 2
a169 2
        u_int32  pp_low;
        u_int32  pp_high;
d173 1
a173 1
        u_int32  pp_n;           /* size of pageid array */
d186 1
d188 1
a188 5
	if (len < 0) {
		printf(" truncated-wb-id!");
		return (0);
	}
	if ((u_char *)(id + 1) > snapend)
d190 9
a200 4
	if (len < 0) {
		printf(" truncated-wb-id!");
		return (0);
	}
d203 2
a204 15
	if ((u_char *)cp + len > snapend)
		return (-1);

	printf(" wb-id: %d/%s:%d (max %d/%s:%d) ",
	       ntohl(id->pi_ps.slot),
	       ipaddr_string(&id->pi_ps.page.p_sid),
	       ntohl(id->pi_ps.page.p_uid),
	       ntohl(id->pi_mslot),
	       ipaddr_string(&id->pi_mpage.p_sid),
	       ntohl(id->pi_mpage.p_uid));

	if (cp[len - 1] != '\0')
		printf("(unterm!) ");

	fn_print((u_char *)cp, (u_char *)cp + len);
d207 3
a209 2
	for (i = 0; i < nid; ++io, ++i) {
		printf("%c%s:%d", c, ipaddr_string(&io->id), ntohl(io->off));
d212 5
a216 2
	printf(">");
	return (0);
d222 2
a223 5
	if (len < sizeof(*rreq)) {
		printf(" truncated-wb-rreq!");
		return (0);
	}
	if ((u_char *)(rreq + 1) > snapend)
d226 1
a226 1
	printf(" wb-rreq: please repair %s %s:%ld<%ld:%ld>",
d228 4
a231 2
	       ipaddr_string(&rreq->pr_page.p_sid), ntohl(rreq->pr_page.p_uid),
	       ntohl(rreq->pr_sseq), ntohl(rreq->pr_eseq));
d238 2
a239 5
	if (len < sizeof(*preq)) {
		printf(" truncated-wb-preq!");
		return (0);
	}
	if ((u_char *)(preq + 1) > snapend)
d242 2
a243 2
	printf(" wb-preq: need %d/%s:%ld",
	       ntohl(preq->pp_low),
d245 1
a245 1
	       ntohl(preq->pp_page.p_uid));
d256 1
d258 1
a258 2
		printf(" truncated-wb-prep!");
		return (0);
a259 1
	printf(" wb-prep:");
d266 4
a269 3
		printf(" %lu/%s:%lu", ntohl(ps->slot),
			ipaddr_string(&ps->page.p_sid),
			ntohl(ps->page.p_uid));
d272 2
a273 2
			printf("%c%s:%lu", c, ipaddr_string(&io->id),
				ntohl(io->off));
d303 1
a303 1
wb_dops(const struct dophdr *dh, u_int32 ss, u_int32 es)
d339 1
d341 1
a341 5
	if (len < 0) {
		printf(" truncated-wb-rrep!");
		return (0);
	}
	if ((u_char *)(rrep + 1) > snapend)
d344 11
a354 7
	printf(" wb-rrep: for %s %s:%d<%ld:%ld>",
	       ipaddr_string(&rrep->pr_id),
	       ipaddr_string(&dop->pd_page.p_sid), ntohl(dop->pd_page.p_uid),
	       ntohl(dop->pd_sseq), ntohl(dop->pd_eseq));

	return (wb_dops((const struct dophdr*)(dop + 1),
			ntohl(dop->pd_sseq), ntohl(dop->pd_eseq)));
d360 1
d362 1
a362 5
	if (len < 0) {
		printf(" truncated-wb-dop!");
		return (0);
	}
	if ((u_char *)(dop + 1) > snapend)
d365 10
a374 6
	printf(" wb-dop: %s:%d<%ld:%ld>",
	       ipaddr_string(&dop->pd_page.p_sid), ntohl(dop->pd_page.p_uid),
	       ntohl(dop->pd_sseq), ntohl(dop->pd_eseq));

	return (wb_dops((const struct dophdr*)(dop + 1),
			ntohl(dop->pd_sseq), ntohl(dop->pd_eseq)));
d387 43
a429 50
	if (len < 0) {
		printf(" truncated-wb!");
		return;
	}
	if ((u_char *)(ph + 1) > snapend) {
 trunc:
		printf("[|wb]");
		return;
	}
	if (ph->ph_flags)
		printf("*");
	switch (ph->ph_type) {

	case PT_KILL:
		printf(" wb-kill");
		break;

	case PT_ID:
		if (wb_id((struct pkt_id *)(ph + 1), len) < 0)
			goto trunc;
		break;

	case PT_RREQ:
		if (wb_rreq((struct pkt_rreq *)(ph + 1), len) < 0)
			goto trunc;
		break;

	case PT_RREP:
		if (wb_rrep((struct pkt_rrep *)(ph + 1), len) < 0)
			goto trunc;
		break;

	case PT_DRAWOP:
		if (wb_drawop((struct pkt_dop *)(ph + 1), len) < 0)
			goto trunc;
		break;

	case PT_PREQ:
		if (wb_preq((struct pkt_preq *)(ph + 1), len) < 0)
			goto trunc;
		break;

	case PT_PREP:
		if (wb_prep((struct pkt_prep *)(ph + 1), len) < 0)
			goto trunc;
		break;

	default:
		printf(" wb-%d!", ph->ph_type);
		return;
d431 1
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
