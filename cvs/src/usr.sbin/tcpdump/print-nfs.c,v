head	1.22;
access;
symbols
	OPENBSD_6_0:1.22.0.6
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.12
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.8
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.6
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.12
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.10
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.01.15.03.03.07;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	4rp6deJlejoV8YGB;

1.21
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	enjTsnD5UO6xazKc;

1.20
date	2015.10.15.02.33.25;	author lteo;	state Exp;
branches;
next	1.19;
commitid	uTHf83GQs95tFzYJ;

1.19
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	Uu5nFG3wCl0LACBb;

1.18
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.17;
commitid	yLXrOcgrag4eS8u4;

1.17
date	2014.02.05.21.12.19;	author florian;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.29.11.39.25;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.24.02.38.25;	author moritz;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.23.20.32.05;	author moritz;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.16.11.26.39;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.07.18.48.16;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.05.08.17.45;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.03.14.31.58;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.20.12.25;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.06.30.21.25.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.32;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.26;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.30;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Remove preprocessor conditions (checking for ancient OSs) that try to
divine whether a file handle was generated on the current host. More
simplifications to come.

supported by deraadt@@
@
text
@/*	$OpenBSD: print-nfs.c,v 1.21 2015/11/16 00:16:39 mmcc Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/time.h>
#include <sys/socket.h>

struct mbuf;
struct rtentry;
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif /*INET6*/

#include <rpc/rpc.h>

#include <ctype.h>
#include <pcap.h>
#include <stdio.h>
#include <string.h>

#include "interface.h"
#include "addrtoname.h"

#include "nfs.h"
#include "nfsfh.h"

static void nfs_printfh(const u_int32_t *, const u_int);
static void xid_map_enter(const struct rpc_msg *, const u_char *);
static int32_t xid_map_find(const struct rpc_msg *, const u_char *,
			    u_int32_t *, u_int32_t *);
static void interp_reply(const struct rpc_msg *, u_int32_t, u_int32_t, int);
static const u_int32_t *parse_post_op_attr(const u_int32_t *, int);
static void print_sattr3(const struct nfsv3_sattr *sa3, int verbose);
static int print_int64(const u_int32_t *dp, int how);

/*
 * Mapping of old NFS Version 2 RPC numbers to generic numbers.
 */
u_int32_t nfsv3_procid[NFS_NPROCS] = {
	NFSPROC_NULL,
	NFSPROC_GETATTR,
	NFSPROC_SETATTR,
	NFSPROC_NOOP,
	NFSPROC_LOOKUP,
	NFSPROC_READLINK,
	NFSPROC_READ,
	NFSPROC_NOOP,
	NFSPROC_WRITE,
	NFSPROC_CREATE,
	NFSPROC_REMOVE,
	NFSPROC_RENAME,
	NFSPROC_LINK,
	NFSPROC_SYMLINK,
	NFSPROC_MKDIR,
	NFSPROC_RMDIR,
	NFSPROC_READDIR,
	NFSPROC_FSSTAT,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP
};


static struct tok nfsvers2str[] = {
	{ NFS_VER2,	"NFSv2" },
	{ NFS_VER3,	"NFSv3" },
	{ NFS_VER4,	"NFSv4" },
	{ 0, NULL }
};

/*
 * NFS V2 and V3 status values.
 *
 * Some of these come from the RFCs for NFS V2 and V3, with the message
 * strings taken from the FreeBSD C library "errlst.c".
 *
 * Others are errors that are not in the RFC but that I suspect some
 * NFS servers could return; the values are FreeBSD errno values, as
 * the first NFS server was the SunOS 2.0 one, and until 5.0 SunOS
 * was primarily BSD-derived.
 */
static struct tok status2str[] = {
	{ 1,     "Operation not permitted" },	/* EPERM */
	{ 2,     "No such file or directory" },	/* ENOENT */
	{ 5,     "Input/output error" },	/* EIO */
	{ 6,     "Device not configured" },	/* ENXIO */
	{ 11,    "Resource deadlock avoided" },	/* EDEADLK */
	{ 12,    "Cannot allocate memory" },	/* ENOMEM */
	{ 13,    "Permission denied" },		/* EACCES */
	{ 17,    "File exists" },		/* EEXIST */
	{ 18,    "Cross-device link" },		/* EXDEV */
	{ 19,    "Operation not supported by device" }, /* ENODEV */
	{ 20,    "Not a directory" },		/* ENOTDIR */
	{ 21,    "Is a directory" },		/* EISDIR */
	{ 22,    "Invalid argument" },		/* EINVAL */
	{ 26,    "Text file busy" },		/* ETXTBSY */
	{ 27,    "File too large" },		/* EFBIG */
	{ 28,    "No space left on device" },	/* ENOSPC */
	{ 30,    "Read-only file system" },	/* EROFS */
	{ 31,    "Too many links" },		/* EMLINK */
	{ 45,    "Operation not supported" },	/* EOPNOTSUPP */
	{ 62,    "Too many levels of symbolic links" }, /* ELOOP */
	{ 63,    "File name too long" },	/* ENAMETOOLONG */
	{ 66,    "Directory not empty" },	/* ENOTEMPTY */
	{ 69,    "Disc quota exceeded" },	/* EDQUOT */
	{ 70,    "Stale NFS file handle" },	/* ESTALE */
	{ 71,    "Too many levels of remote in path" }, /* EREMOTE */
	{ 99,    "Write cache flushed to disk" }, /* NFSERR_WFLUSH (not used) */
	{ 10001, "Illegal NFS file handle" },	/* NFS3ERR_BADHANDLE */
	{ 10002, "Update synchronization mismatch" }, /* NFS3ERR_NOT_SYNC */
	{ 10003, "READDIR/READDIRPLUS cookie is stale" }, /* NFS3ERR_BAD_COOKIE */
	{ 10004, "Operation not supported" },	/* NFS3ERR_NOTSUPP */
	{ 10005, "Buffer or request is too small" }, /* NFS3ERR_TOOSMALL */
	{ 10006, "Unspecified error on server" }, /* NFS3ERR_SERVERFAULT */
	{ 10007, "Object of that type not supported" }, /* NFS3ERR_BADTYPE */
	{ 10008, "Request couldn't be completed in time" }, /* NFS3ERR_JUKEBOX */
	{ 0,     NULL }
};

static struct tok nfsv3_writemodes[] = {
	{ 0,		"unstable" },
	{ 1,		"datasync" },
	{ 2,		"filesync" },
	{ 0,		NULL }
};

static struct tok type2str[] = {
	{ NFNON,	"NON" },
	{ NFREG,	"REG" },
	{ NFDIR,	"DIR" },
	{ NFBLK,	"BLK" },
	{ NFCHR,	"CHR" },
	{ NFLNK,	"LNK" },
	{ NFFIFO,	"FIFO" },
	{ 0,		NULL }
};

/*
 * Print out a 64-bit integer. This appears to be different on each system,
 * try to make the best of it. The integer stored as 2 consecutive XDR
 * encoded 32-bit integers, to which a pointer is passed.
 *
 * Assume that a system that has INT64_FORMAT defined, has a 64-bit
 * integer datatype and can print it.
 */ 

#define UNSIGNED 0
#define SIGNED   1
#define HEX      2

static int print_int64(const u_int32_t *dp, int how)
{
#ifdef INT64_FORMAT
	u_int64_t res;

	TCHECK(dp[1]);
	res = ((u_int64_t)ntohl(dp[0]) << 32) | (u_int64_t)ntohl(dp[1]);
	switch (how) {
	case SIGNED:
		printf(INT64_FORMAT, res);
		break;
	case UNSIGNED:
		printf(U_INT64_FORMAT, res);
		break;
	case HEX:
		printf(HEX_INT64_FORMAT, res);
		break;
	default:
		return (0);
	}
#else
	switch (how) {
	case SIGNED:
	case UNSIGNED:
	case HEX:
		TCHECK(dp[1]);
		if (dp[0])
			printf("0x%x%08x", (u_int32_t)ntohl(dp[0]),
			    (u_int32_t)ntohl(dp[1]));
		else
			printf("0x%x", (u_int32_t)ntohl(dp[1]));
		break;
	default:
		return (0);
	}
#endif
	return 1;

trunc:
	return (0);
}

static const u_int32_t *
parse_sattr3(const u_int32_t *dp, struct nfsv3_sattr *sa3)
{
	TCHECK(dp[0]);
	if ((sa3->sa_modeset = ntohl(*dp++))) {
		TCHECK(dp[0]);
		sa3->sa_mode = ntohl(*dp++);
	}

	TCHECK(dp[0]);
	if ((sa3->sa_uidset = ntohl(*dp++))) {
		TCHECK(dp[0]);
		sa3->sa_uid = ntohl(*dp++);
	}

	TCHECK(dp[0]);
	if ((sa3->sa_gidset = ntohl(*dp++))) {
		TCHECK(dp[0]);
		sa3->sa_gid = ntohl(*dp++);
	}

	TCHECK(dp[0]);
	if ((sa3->sa_sizeset = ntohl(*dp++))) {
		TCHECK(dp[0]);
		sa3->sa_size = ntohl(*dp++);
	}

	TCHECK(dp[0]);
	if ((sa3->sa_atimetype = ntohl(*dp++)) == NFSV3SATTRTIME_TOCLIENT) {
		TCHECK(dp[1]);
		sa3->sa_atime.nfsv3_sec = ntohl(*dp++);
		sa3->sa_atime.nfsv3_nsec = ntohl(*dp++);
	}

	TCHECK(dp[0]);
	if ((sa3->sa_mtimetype = ntohl(*dp++)) == NFSV3SATTRTIME_TOCLIENT) {
		TCHECK(dp[1]);
		sa3->sa_mtime.nfsv3_sec = ntohl(*dp++);
		sa3->sa_mtime.nfsv3_nsec = ntohl(*dp++);
	}

	return dp;
trunc:
	return NULL;
}

static int nfserr;		/* true if we error rather than trunc */

static void
print_sattr3(const struct nfsv3_sattr *sa3, int verbose)
{
	if (sa3->sa_modeset)
		printf(" mode %o", sa3->sa_mode);
	if (sa3->sa_uidset)
		printf(" uid %u", sa3->sa_uid);
	if (sa3->sa_gidset)
		printf(" gid %u", sa3->sa_gid);
	if (verbose > 1) {
		if (sa3->sa_atimetype == NFSV3SATTRTIME_TOCLIENT)
			printf(" atime %u.%06u", sa3->sa_atime.nfsv3_sec,
			       sa3->sa_atime.nfsv3_nsec);
		if (sa3->sa_mtimetype == NFSV3SATTRTIME_TOCLIENT)
			printf(" mtime %u.%06u", sa3->sa_mtime.nfsv3_sec,
			       sa3->sa_mtime.nfsv3_nsec);
	}
}

void
nfsreply_print(const u_char *bp, u_int length, const u_char *bp2)
{
	const struct rpc_msg *rp;
	u_int32_t proc, vers;

	nfserr = 0;		/* assume no error */
	rp = (const struct rpc_msg *)bp;

	printf("xid 0x%x reply %s %d", (u_int32_t)ntohl(rp->rm_xid),
		ntohl(rp->rm_reply.rp_stat) == MSG_ACCEPTED ? "ok":"ERR",
		length);
	if (xid_map_find(rp, bp2, &proc, &vers) >= 0)
		interp_reply(rp, proc, vers, length);
}

/*
 * Return a pointer to the first file handle in the packet.
 * If the packet was truncated, return 0.
 */
static const u_int32_t *
parsereq(const struct rpc_msg *rp, u_int length)
{
	const u_int32_t *dp;
	u_int len;

	/*
	 * find the start of the req data (if we captured it)
	 */
	dp = (u_int32_t *)&rp->rm_call.cb_cred;
	TCHECK(dp[1]);
	len = ntohl(dp[1]);
	if (len < length) {
		dp += (len + (2 * sizeof(*dp) + 3)) / sizeof(*dp);
		TCHECK(dp[1]);
		len = ntohl(dp[1]);
		if (len < length) {
			dp += (len + (2 * sizeof(*dp) + 3)) / sizeof(*dp);
			TCHECK2(dp[0], 0);
			return (dp);
		}
	}
trunc:
	return (NULL);
}

/*
 * Print out an NFS file handle and return a pointer to following word.
 * If packet was truncated, return 0.
 */
static const u_int32_t *
parsefh(const u_int32_t *dp, int v3)
{
	int len;

	if (v3) {
		TCHECK(dp[0]);
		len = (int)ntohl(*dp) / 4;
		dp++;
	} else
		len = NFSX_V2FH / 4;

	if (TTEST2(*dp, len * sizeof(*dp))) {
		nfs_printfh(dp, len);
		return (dp + len);
	}
trunc:
	return (NULL);
}

/*
 * Print out a file name and return pointer to 32-bit word past it.
 * If packet was truncated, return 0.
 */
static const u_int32_t *
parsefn(const u_int32_t *dp)
{
	u_int32_t len;
	const u_char *cp;

	/* Bail if we don't have the string length */
	TCHECK(*dp);

	/* Fetch string length; convert to host order */
	len = *dp++;
	NTOHL(len);

	TCHECK2(*dp, ((len + 3) & ~3));

	cp = (u_char *)dp;
	/* Update 32-bit pointer (NFS filenames padded to 32-bit boundaries) */
	dp += ((len + 3) & ~3) / sizeof(*dp);
	putchar('"');
	if (fn_printn(cp, len, snapend)) {
		putchar('"');
		goto trunc;
	}
	putchar('"');

	return (dp);
trunc:
	return NULL;
}

/*
 * Print out file handle and file name.
 * Return pointer to 32-bit word past file name.
 * If packet was truncated (or there was some other error), return 0.
 */
static const u_int32_t *
parsefhn(const u_int32_t *dp, int v3)
{
	dp = parsefh(dp, v3);
	if (dp == NULL)
		return (NULL);
	putchar(' ');
	return (parsefn(dp));
}

void
nfsreq_print(const u_char *bp, u_int length, const u_char *bp2)
{
	const struct rpc_msg *rp;
	const u_int32_t *dp;
	nfstype type;
	int vers;
	int v3 = 0;
	u_int32_t proc;
	struct nfsv3_sattr sa3;

	nfserr = 0;		/* assume no error */
	rp = (const struct rpc_msg *)bp;

	vers = ntohl(rp->rm_call.cb_vers);
	if (vers == NFS_VER3)
		v3 = 1;

	printf("xid 0x%x (%s) %d", (u_int32_t)ntohl(rp->rm_xid),
	    tok2str(nfsvers2str, "Unk %i", vers), length);

	xid_map_enter(rp, bp2);	/* record proc number for later on */
	proc = ntohl(rp->rm_call.cb_proc);

	if (!v3 && proc < NFS_NPROCS)
		proc =  nfsv3_procid[proc];

	switch (proc) {
	case NFSPROC_NOOP:
		printf(" nop");
		return;
	case NFSPROC_NULL:
		printf(" null");
		return;

	case NFSPROC_GETATTR:
		printf(" getattr");
		if ((dp = parsereq(rp, length)) != NULL &&
		    parsefh(dp, v3) != NULL)
			return;
		break;

	case NFSPROC_SETATTR:
		printf(" setattr");
		if ((dp = parsereq(rp, length)) != NULL &&
		    parsefh(dp, v3) != NULL)
			return;
		break;

	case NFSPROC_LOOKUP:
		printf(" lookup");
		if ((dp = parsereq(rp, length)) != NULL &&
		    parsefhn(dp, v3) != NULL)
			return;
		break;

	case NFSPROC_ACCESS:
		printf(" access");
		if ((dp = parsereq(rp, length)) != NULL &&
		    (dp = parsefh(dp, v3)) != NULL) {
			TCHECK(dp[0]);
			printf(" %04x", (u_int32_t)ntohl(dp[0]));
			return;
		}
		break;

	case NFSPROC_READLINK:
		printf(" readlink");
		if ((dp = parsereq(rp, length)) != NULL &&
		    parsefh(dp, v3) != NULL)
			return;
		break;

	case NFSPROC_READ:
		printf(" read");
		if ((dp = parsereq(rp, length)) != NULL &&
		    (dp = parsefh(dp, v3)) != NULL) {
			if (v3) {
				TCHECK(dp[2]);
				printf(" %u bytes @@ ",
				       (u_int32_t) ntohl(dp[2]));
				print_int64(dp, UNSIGNED);
			} else {
				TCHECK(dp[1]);
				printf(" %u bytes @@ %u",
				    (u_int32_t)ntohl(dp[1]),
				    (u_int32_t)ntohl(dp[0]));
			}
			return;
		}
		break;

	case NFSPROC_WRITE:
		printf(" write");
		if ((dp = parsereq(rp, length)) != NULL &&
		    (dp = parsefh(dp, v3)) != NULL) {
			if (v3) {
				TCHECK(dp[4]);
				printf(" %u bytes @@ ",
						(u_int32_t) ntohl(dp[4]));
				print_int64(dp, UNSIGNED);
				if (vflag) {
					dp += 3;
					TCHECK(dp[0]);
					printf(" <%s>",
						tok2str(nfsv3_writemodes,
							NULL, ntohl(*dp)));
				}
			} else {
				TCHECK(dp[3]);
				printf(" %u (%u) bytes @@ %u (%u)",
						(u_int32_t)ntohl(dp[3]),
						(u_int32_t)ntohl(dp[2]),
						(u_int32_t)ntohl(dp[1]),
						(u_int32_t)ntohl(dp[0]));
			}
			return;
		}
		break;

	case NFSPROC_CREATE:
		printf(" create");
		if ((dp = parsereq(rp, length)) != NULL &&
		    parsefhn(dp, v3) != NULL)
			return;
		break;

	case NFSPROC_MKDIR:
		printf(" mkdir");
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp, v3) != 0)
			return;
		break;

	case NFSPROC_SYMLINK:
		printf(" symlink");
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefhn(dp, v3)) != 0) {
			fputs(" ->", stdout);
			if (v3 && (dp = parse_sattr3(dp, &sa3)) == 0)
				break;
			if (parsefn(dp) == 0)
				break;
			if (v3 && vflag)
				print_sattr3(&sa3, vflag);
			return;
		}
		break;

	case NFSPROC_MKNOD:
		printf(" mknod");
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefhn(dp, v3)) != 0) {
			TCHECK(*dp);
			type = (nfstype)ntohl(*dp++);
			if ((dp = parse_sattr3(dp, &sa3)) == 0)
				break;
			printf(" %s", tok2str(type2str, "unk-ft %d", type));
			if (vflag && (type == NFCHR || type == NFBLK)) {
				TCHECK(dp[1]);
				printf(" %u/%u",
				       (u_int32_t)ntohl(dp[0]),
				       (u_int32_t)ntohl(dp[1]));
				dp += 2;
			}
			if (vflag)
				print_sattr3(&sa3, vflag);
			return;
		}
		break;

	case NFSPROC_REMOVE:
		printf(" remove");
		if ((dp = parsereq(rp, length)) != NULL &&
		    parsefhn(dp, v3) != NULL)
			return;
		break;

	case NFSPROC_RMDIR:
		printf(" rmdir");
		if ((dp = parsereq(rp, length)) != NULL &&
		    parsefhn(dp, v3) != NULL)
			return;
		break;

	case NFSPROC_RENAME:
		printf(" rename");
		if ((dp = parsereq(rp, length)) != NULL &&
		    (dp = parsefhn(dp, v3)) != NULL) {
			fputs(" ->", stdout);
			if (parsefhn(dp, v3) != NULL)
				return;
		}
		break;

	case NFSPROC_LINK:
		printf(" link");
		if ((dp = parsereq(rp, length)) != NULL &&
		    (dp = parsefh(dp, v3)) != NULL) {
			fputs(" ->", stdout);
			if (parsefhn(dp, v3) != NULL)
				return;
		}
		break;

	case NFSPROC_READDIR:
		printf(" readdir");
		if ((dp = parsereq(rp, length)) != NULL &&
		    (dp = parsefh(dp, v3)) != NULL) {
			if (v3) {
				TCHECK(dp[4]);
				/*
				 * We shouldn't really try to interpret the
				 * offset cookie here.
				 */
				printf(" %u bytes @@ ",
				    (u_int32_t) ntohl(dp[4]));
				print_int64(dp, SIGNED);
				if (vflag)
					printf(" verf %08x%08x", dp[2],
					       dp[3]);
			} else {
				TCHECK(dp[1]);
				/*
				 * Print the offset as signed, since -1 is
				 * common, but offsets > 2^31 aren't.
				 */
				printf(" %u bytes @@ %d",
				    (u_int32_t)ntohl(dp[1]),
				    (u_int32_t)ntohl(dp[0]));
			}
			return;
		}
		break;

	case NFSPROC_READDIRPLUS:
		printf(" readdirplus");
		if ((dp = parsereq(rp, length)) != NULL &&
		    (dp = parsefh(dp, v3)) != NULL) {
			TCHECK(dp[4]);
			/*
			 * We don't try to interpret the offset
			 * cookie here.
			 */
			printf(" %u bytes @@ ", (u_int32_t) ntohl(dp[4]));
			print_int64(dp, SIGNED);
			if (vflag) {
				TCHECK(dp[5]);
				printf(" max %u verf %08x%08x",
				       (u_int32_t) ntohl(dp[5]), dp[2], dp[3]);
			}
			return;
		}
		break;

	case NFSPROC_FSSTAT:
		printf(" fsstat");
		if ((dp = parsereq(rp, length)) != NULL &&
		    parsefh(dp, v3) != NULL)
			return;
		break;

	case NFSPROC_FSINFO:
		printf(" fsinfo");
		if ((dp = parsereq(rp, length)) != NULL &&
		    parsefh(dp, v3) != NULL)
			return;
		break;

	case NFSPROC_PATHCONF:
		printf(" pathconf");
		if ((dp = parsereq(rp, length)) != NULL &&
		    parsefh(dp, v3) != NULL)
			return;
		break;

	case NFSPROC_COMMIT:
		printf(" commit");
		if ((dp = parsereq(rp, length)) != NULL &&
		    (dp = parsefh(dp, v3)) != NULL) {
			TCHECK(dp[2]);
			printf(" %u bytes @@ ", (u_int32_t) ntohl(dp[2]));
			print_int64(dp, UNSIGNED);
			return;
		}
		break;

	default:
		printf(" proc-%u", (u_int32_t)ntohl(rp->rm_call.cb_proc));
		return;
	}

trunc:
	if (!nfserr)
		fputs(" [|nfs]", stdout);
}

/*
 * Print out an NFS file handle.
 * We assume packet was not truncated before the end of the
 * file handle pointed to by dp.
 *
 * Note: new version (using portable file-handle parser) doesn't produce
 * generation number.  It probably could be made to do that, with some
 * additional hacking on the parser code.
 */
static void
nfs_printfh(const u_int32_t *dp, const u_int len)
{
	my_fsid fsid;
	ino_t ino;
	char *sfsname = NULL;

	Parse_fh((caddr_t *)dp, &fsid, &ino, NULL, &sfsname);

	if (sfsname) {
		/* file system ID is ASCII, not numeric, for this server OS */
		static char temp[NFSX_V3FHMAX+1];

		/* Make sure string is null-terminated */
		strlcpy(temp, sfsname, sizeof(temp));
		/* Remove trailing spaces */
		sfsname = strchr(temp, ' ');
		if (sfsname)
			*sfsname = 0;

		(void)printf(" fh %s/%u", temp, (u_int32_t)ino);
	} else {
		(void)printf(" fh %u,%u/%u",
		    fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor, (u_int32_t)ino);
	}
}

/*
 * Maintain a small cache of recent client.XID.server/proc pairs, to allow
 * us to match up replies with requests and thus to know how to parse
 * the reply.
 */

struct xid_map_entry {
	u_int32_t	xid;		/* transaction ID (net order) */
	int ipver;			/* IP version (4 or 6) */
#ifdef INET6
	struct in6_addr	client;		/* client IP address (net order) */
	struct in6_addr	server;		/* server IP address (net order) */
#else
	struct in_addr	client;		/* client IP address (net order) */
	struct in_addr	server;		/* server IP address (net order) */
#endif /*INET6*/
	u_int32_t	proc;		/* call proc number (host order) */
	u_int32_t	vers;		/* program version (host order) */
};

/*
 * Map entries are kept in an array that we manage as a ring;
 * new entries are always added at the tail of the ring.  Initially,
 * all the entries are zero and hence don't match anything.
 */

#define	XIDMAPSIZE	64

struct xid_map_entry xid_map[XIDMAPSIZE];

int	xid_map_next = 0;
int	xid_map_hint = 0;

static void
xid_map_enter(const struct rpc_msg *rp, const u_char *bp)
{
	struct ip *ip = NULL;
#ifdef INET6
	struct ip6_hdr *ip6 = NULL;
#endif /*INET6*/
	struct xid_map_entry *xmep;

	ip = (struct ip *)bp;

	xmep = &xid_map[xid_map_next];

	if (++xid_map_next >= XIDMAPSIZE)
		xid_map_next = 0;

	xmep->xid = rp->rm_xid;
	xmep->ipver = ip->ip_v;

	switch (xmep->ipver) {
	case 4:
		memcpy(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));
		memcpy(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));
		break;
#ifdef INET6
	case 6:
		ip6 = (struct ip6_hdr *)bp;
		memcpy(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));
		memcpy(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));
		break;
	default:
		return;
#endif /*INET6*/
	}
	xmep->proc = ntohl(rp->rm_call.cb_proc);
	xmep->vers = ntohl(rp->rm_call.cb_vers);
}

/*
 * Returns 0 and puts NFSPROC_xxx in proc return and
 * version in vers return, or returns -1 on failure
 */
static int
xid_map_find(const struct rpc_msg *rp, const u_char *bp, u_int32_t *proc,
	     u_int32_t *vers)
{
	int i;
	struct xid_map_entry *xmep;
	u_int32_t xid = rp->rm_xid;
	struct ip *ip = (struct ip *)bp;
#ifdef INET6
	struct ip6_hdr *ip6 = (struct ip6_hdr *)bp;
#endif /*INET6*/
	int cmp;

	/* Start searching from where we last left off */
	i = xid_map_hint; 
	do {
		xmep = &xid_map[i];
		cmp = 1;
		if (xmep->ipver != ip->ip_v || xmep->xid != xid)
			goto nextitem;
		switch (xmep->ipver) {
		case 4:
			if (memcmp(&ip->ip_src, &xmep->server,
				   sizeof(ip->ip_src)) != 0 ||
			    memcmp(&ip->ip_dst, &xmep->client,
				   sizeof(ip->ip_dst)) != 0) {
				cmp = 0;
			}
			break;
#ifdef INET6
		case 6:
			if (memcmp(&ip6->ip6_src, &xmep->server,
				   sizeof(ip6->ip6_src)) != 0 ||
			    memcmp(&ip6->ip6_dst, &xmep->client,
				   sizeof(ip6->ip6_dst)) != 0) {
				cmp = 0;
			}
			break;
#endif /*INET6*/
		default:
			cmp = 0;
			break;
		}
		if (cmp) {
			/* match */
			xid_map_hint = i;
			*proc = xmep->proc;
			*vers = xmep->vers;
			return 0;
		}
	nextitem:
		if (++i >= XIDMAPSIZE)
			i = 0;
	} while (i != xid_map_hint);

	/* search failed */
	return (-1);
}

/*
 * Routines for parsing reply packets
 */

/*
 * Return a pointer to the beginning of the actual results.
 * If the packet was truncated, return 0.
 */
static const u_int32_t *
parserep(const struct rpc_msg *rp, u_int length)
{
	const u_int32_t *dp;
	u_int len;
	enum accept_stat astat;

	/*
	 * Portability note:
	 * Here we find the address of the ar_verf credentials.
	 * Originally, this calculation was
	 *	dp = (u_int32_t *)&rp->rm_reply.rp_acpt.ar_verf
	 * On the wire, the rp_acpt field starts immediately after
	 * the (32 bit) rp_stat field.  However, rp_acpt (which is a
	 * "struct accepted_reply") contains a "struct opaque_auth",
	 * whose internal representation contains a pointer, so on a
	 * 64-bit machine the compiler inserts 32 bits of padding
	 * before rp->rm_reply.rp_acpt.ar_verf.  So, we cannot use
	 * the internal representation to parse the on-the-wire
	 * representation.  Instead, we skip past the rp_stat field,
	 * which is an "enum" and so occupies one 32-bit word.
	 */
	dp = ((const u_int32_t *)&rp->rm_reply) + 1;
	TCHECK(dp[1]);
	len = ntohl(dp[1]);
	if (len >= length)
		return (NULL);
	/*
	 * skip past the ar_verf credentials.
	 */
	dp += (len + (2*sizeof(u_int32_t) + 3)) / sizeof(u_int32_t);
	TCHECK2(dp[0], 0);

	/*
	 * now we can check the ar_stat field
	 */
	astat = ntohl(*(enum accept_stat *)dp);
	switch (astat) {

	case SUCCESS:
		break;

	case PROG_UNAVAIL:
		printf(" PROG_UNAVAIL");
		nfserr = 1;		/* suppress trunc string */
		return (NULL);

	case PROG_MISMATCH:
		printf(" PROG_MISMATCH");
		nfserr = 1;		/* suppress trunc string */
		return (NULL);

	case PROC_UNAVAIL:
		printf(" PROC_UNAVAIL");
		nfserr = 1;		/* suppress trunc string */
		return (NULL);

	case GARBAGE_ARGS:
		printf(" GARBAGE_ARGS");
		nfserr = 1;		/* suppress trunc string */
		return (NULL);

	case SYSTEM_ERR:
		printf(" SYSTEM_ERR");
		nfserr = 1;		/* suppress trunc string */
		return (NULL);

	default:
		printf(" ar_stat %d", astat);
		nfserr = 1;		/* suppress trunc string */
		return (NULL);
	}
	/* successful return */
	TCHECK2(*dp, sizeof(astat));
	return ((u_int32_t *) (sizeof(astat) + ((char *)dp)));
trunc:
	return (0);
}

static const u_int32_t *
parsestatus(const u_int32_t *dp, int *er)
{
	int errnum;

	TCHECK(dp[0]);

	errnum = ntohl(dp[0]);
	if (er)
		*er = errnum;
	if (errnum != 0) {
		if (!qflag)
			printf(" ERROR: %s",
			    tok2str(status2str, "unk %d", errnum));
		nfserr = 1;
	}
	return (dp + 1);
trunc:
	return NULL;
}

static const u_int32_t *
parsefattr(const u_int32_t *dp, int verbose, int v3)
{
	const struct nfs_fattr *fap;

	fap = (const struct nfs_fattr *)dp;
	TCHECK(fap->fa_gid);
	if (verbose) {
		printf(" %s %o ids %d/%d",
		    tok2str(type2str, "unk-ft %d ",
		    (u_int32_t)ntohl(fap->fa_type)),
		    (u_int32_t)ntohl(fap->fa_mode),
		    (u_int32_t)ntohl(fap->fa_uid),
		    (u_int32_t) ntohl(fap->fa_gid));
		if (v3) {
			TCHECK(fap->fa3_size);
			printf(" sz ");
			print_int64((u_int32_t *)&fap->fa3_size, UNSIGNED);
		} else {
			TCHECK(fap->fa2_size);
			printf(" sz %d", (u_int32_t) ntohl(fap->fa2_size));
		}
	}
	/* print lots more stuff */
	if (verbose > 1) {
		if (v3) {
			TCHECK(fap->fa3_ctime);
			printf(" nlink %d rdev %d/%d",
			       (u_int32_t)ntohl(fap->fa_nlink),
			       (u_int32_t) ntohl(fap->fa3_rdev.specdata1),
			       (u_int32_t) ntohl(fap->fa3_rdev.specdata2));
			printf(" fsid ");
			print_int64((u_int32_t *)&fap->fa3_fsid, HEX);
			printf(" fileid ");
			print_int64((u_int32_t *)&fap->fa3_fileid, HEX);
			printf(" a/m/ctime %u.%06u",
			       (u_int32_t) ntohl(fap->fa3_atime.nfsv3_sec),
			       (u_int32_t) ntohl(fap->fa3_atime.nfsv3_nsec));
			printf(" %u.%06u",
			       (u_int32_t) ntohl(fap->fa3_mtime.nfsv3_sec),
			       (u_int32_t) ntohl(fap->fa3_mtime.nfsv3_nsec));
			printf(" %u.%06u",
			       (u_int32_t) ntohl(fap->fa3_ctime.nfsv3_sec),
			       (u_int32_t) ntohl(fap->fa3_ctime.nfsv3_nsec));
		} else {
			TCHECK(fap->fa2_ctime);
			printf("nlink %d rdev %x fsid %x fileid %x a/m/ctime",
			       (u_int32_t) ntohl(fap->fa_nlink),
			       (u_int32_t) ntohl(fap->fa2_rdev),
			       (u_int32_t) ntohl(fap->fa2_fsid),
			       (u_int32_t) ntohl(fap->fa2_fileid));
			printf(" %u.%06u",
			       (u_int32_t) ntohl(fap->fa2_atime.nfsv2_sec),
			       (u_int32_t) ntohl(fap->fa2_atime.nfsv2_usec));
			printf(" %u.%06u",
			       (u_int32_t) ntohl(fap->fa2_mtime.nfsv2_sec),
			       (u_int32_t) ntohl(fap->fa2_mtime.nfsv2_usec));
			printf(" %u.%06u",
			       (u_int32_t) ntohl(fap->fa2_ctime.nfsv2_sec),
			       (u_int32_t) ntohl(fap->fa2_ctime.nfsv2_usec));
		}
	}
	return ((const u_int32_t *)((unsigned char *)dp +
		(v3 ? NFSX_V3FATTR : NFSX_V2FATTR)));
trunc:
	return (NULL);
}

static int
parseattrstat(const u_int32_t *dp, int verbose, int v3)
{
	int er;

	dp = parsestatus(dp, &er);
	if (dp == NULL)
		return (0);
	if (er)
		return (1);

	return (parsefattr(dp, verbose, v3) != NULL);
}

static int
parsediropres(const u_int32_t *dp)
{
	int er;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	if (er)
		return (1);

	dp = parsefh(dp, 0);
	if (dp == NULL)
		return (0);

	return (parsefattr(dp, vflag, 0) != NULL);
}

static int
parselinkres(const u_int32_t *dp, int v3)
{
	int er;

	dp = parsestatus(dp, &er);
	if (dp == NULL)
		return(0);
	if (er)
		return(1);
	if (v3 && !(dp = parse_post_op_attr(dp, vflag)))
		return (0);
	putchar(' ');
	return (parsefn(dp) != NULL);
}

static int
parsestatfs(const u_int32_t *dp, int v3)
{
	const struct nfs_statfs *sfsp;
	int er;

	dp = parsestatus(dp, &er);
	if (dp == NULL)
		return (0);
	if (!v3 && er)
		return (1);

	if (qflag)
		return(1);

	if (v3) {
		if (vflag)
			printf(" POST:");
		if (!(dp = parse_post_op_attr(dp, vflag)))
			return (0);
	}

	TCHECK2(*dp, (v3 ? NFSX_V3STATFS : NFSX_V2STATFS));

	sfsp = (const struct nfs_statfs *)dp;

	if (v3) {
		printf(" tbytes ");
		print_int64((u_int32_t *)&sfsp->sf_tbytes, UNSIGNED);
		printf(" fbytes ");
		print_int64((u_int32_t *)&sfsp->sf_fbytes, UNSIGNED);
		printf(" abytes ");
		print_int64((u_int32_t *)&sfsp->sf_abytes, UNSIGNED);
		if (vflag) {
			printf(" tfiles ");
			print_int64((u_int32_t *)&sfsp->sf_tfiles, UNSIGNED);
			printf(" ffiles ");
			print_int64((u_int32_t *)&sfsp->sf_ffiles, UNSIGNED);
			printf(" afiles ");
			print_int64((u_int32_t *)&sfsp->sf_afiles, UNSIGNED);
			printf(" invar %u",
			       (u_int32_t) ntohl(sfsp->sf_invarsec));
		}
	} else {
		printf(" tsize %d bsize %d blocks %d bfree %d bavail %d",
			(u_int32_t)ntohl(sfsp->sf_tsize),
			(u_int32_t)ntohl(sfsp->sf_bsize),
			(u_int32_t)ntohl(sfsp->sf_blocks),
			(u_int32_t)ntohl(sfsp->sf_bfree),
			(u_int32_t)ntohl(sfsp->sf_bavail));
	}

	return (1);
trunc:
	return (0);
}

static int
parserddires(const u_int32_t *dp)
{
	int er;

	dp = parsestatus(dp, &er);
	if (dp == NULL)
		return (0);
	if (er)
		return (1);
	if (qflag)
		return (1);

	TCHECK(dp[2]);
	printf(" offset %x size %d ",
	       (u_int32_t)ntohl(dp[0]), (u_int32_t)ntohl(dp[1]));
	if (dp[2] != 0)
		printf(" eof");

	return (1);
trunc:
	return (0);
}

static const u_int32_t *
parse_wcc_attr(const u_int32_t *dp)
{
	printf(" sz ");
	print_int64(dp, UNSIGNED);
	TCHECK(dp[5]);
	printf(" mtime %u.%06u ctime %u.%06u",
	       (u_int32_t)ntohl(dp[2]), (u_int32_t)ntohl(dp[3]),
	       (u_int32_t)ntohl(dp[4]), (u_int32_t)ntohl(dp[5]));
	return (dp + 6);

trunc:
	return (NULL);
}

/*
 * Pre operation attributes. Print only if vflag > 1.
 */
static const u_int32_t *
parse_pre_op_attr(const u_int32_t *dp, int verbose)
{
	TCHECK(dp[0]);
	if (!ntohl(dp[0]))
		return (dp + 1);
	dp++;
	TCHECK2(*dp, 24);
	if (verbose > 1) {
		return parse_wcc_attr(dp);
	} else {
		/* If not verbose enough, just skip over wcc_attr */
		return (dp + 6);
	}
trunc:
	return (NULL);
}

/*
 * Post operation attributes are printed if vflag >= 1
 */
static const u_int32_t *
parse_post_op_attr(const u_int32_t *dp, int verbose)
{
	TCHECK(dp[0]);
	if (!ntohl(dp[0]))
		return (dp + 1);
	dp++;
	if (verbose) {
		return parsefattr(dp, verbose, 1);
	} else
		return (dp + (NFSX_V3FATTR / sizeof (u_int32_t)));
trunc:
	return (NULL);
}

static const u_int32_t *
parse_wcc_data(const u_int32_t *dp, int verbose)
{
	if (verbose > 1)
		printf(" PRE:");
	if (!(dp = parse_pre_op_attr(dp, verbose)))
		return (0);

	if (verbose)
		printf(" POST:");
	return parse_post_op_attr(dp, verbose);
}

static const u_int32_t *
parsecreateopres(const u_int32_t *dp, int verbose)
{
	int er;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	if (er)
		dp = parse_wcc_data(dp, verbose);
	else {
		TCHECK(dp[0]);
		if (!ntohl(dp[0]))
			return (dp + 1);
		dp++;
		if (!(dp = parsefh(dp, 1)))
			return (0);
		if (verbose) {
			if (!(dp = parse_post_op_attr(dp, verbose)))
				return (0);
			if (vflag > 1) {
				printf(" dir attr:");
				dp = parse_wcc_data(dp, verbose);
			}
		}
	}
	return (dp);
trunc:
	return (NULL);
}

static int
parsewccres(const u_int32_t *dp, int verbose)
{
	int er;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	return parse_wcc_data(dp, verbose) != 0;
}

static const u_int32_t *
parsev3rddirres(const u_int32_t *dp, int verbose)
{
	int er;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	if (vflag)
		printf(" POST:");
	if (!(dp = parse_post_op_attr(dp, verbose)))
		return (0);
	if (er)
		return dp;
	if (vflag) {
		TCHECK(dp[1]);
		printf(" verf %08x%08x", dp[0], dp[1]);
		dp += 2;
	}
	return dp;
trunc:
	return (NULL);
}

static int
parsefsinfo(const u_int32_t *dp)
{
	struct nfsv3_fsinfo *sfp;
	int er;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	if (vflag)
		printf(" POST:");
	if (!(dp = parse_post_op_attr(dp, vflag)))
		return (0);
	if (er)
		return (1);

	sfp = (struct nfsv3_fsinfo *)dp;
	TCHECK(*sfp);
	printf(" rtmax %u rtpref %u wtmax %u wtpref %u dtpref %u",
	       (u_int32_t) ntohl(sfp->fs_rtmax),
	       (u_int32_t) ntohl(sfp->fs_rtpref),
	       (u_int32_t) ntohl(sfp->fs_wtmax),
	       (u_int32_t) ntohl(sfp->fs_wtpref),
	       (u_int32_t) ntohl(sfp->fs_dtpref));
	if (vflag) {
		printf(" rtmult %u wtmult %u maxfsz ",
		       (u_int32_t) ntohl(sfp->fs_rtmult),
		       (u_int32_t) ntohl(sfp->fs_wtmult));
		print_int64((u_int32_t *)&sfp->fs_maxfilesize, UNSIGNED);
		printf(" delta %u.%06u ",
		       (u_int32_t) ntohl(sfp->fs_timedelta.nfsv3_sec),
		       (u_int32_t) ntohl(sfp->fs_timedelta.nfsv3_nsec));
	}
	return (1);
trunc:
	return (0);
}

static int
parsepathconf(const u_int32_t *dp)
{
	int er;
	struct nfsv3_pathconf *spp;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	if (vflag)
		printf(" POST:");
	if (!(dp = parse_post_op_attr(dp, vflag)))
		return (0);
	if (er)
		return (1);

	spp = (struct nfsv3_pathconf *)dp;
	TCHECK(*spp);

	printf(" linkmax %u namemax %u %s %s %s %s",
	       (u_int32_t) ntohl(spp->pc_linkmax),
	       (u_int32_t) ntohl(spp->pc_namemax),
	       ntohl(spp->pc_notrunc) ? "notrunc" : "",
	       ntohl(spp->pc_chownrestricted) ? "chownres" : "",
	       ntohl(spp->pc_caseinsensitive) ? "igncase" : "",
	       ntohl(spp->pc_casepreserving) ? "keepcase" : "");
	return (1);
trunc:
	return (0);
}

static void
interp_reply(const struct rpc_msg *rp, u_int32_t proc, u_int32_t vers, int length)
{
	const u_int32_t *dp;
	int v3;
	int er;

	v3 = (vers == NFS_VER3);

	if (!v3 && proc < NFS_NPROCS)
		proc = nfsv3_procid[proc];

	switch (proc) {

	case NFSPROC_NOOP:
		printf(" nop");
		return;

	case NFSPROC_NULL:
		printf(" null");
		return;

	case NFSPROC_GETATTR:
		printf(" getattr");
		dp = parserep(rp, length);
		if (dp != NULL && parseattrstat(dp, !qflag, v3) != 0)
			return;
		break;

	case NFSPROC_SETATTR:
		printf(" setattr");
		if (!(dp = parserep(rp, length)))
			return;
		if (v3) {
			if (parsewccres(dp, vflag))
				return;
		} else {
			if (parseattrstat(dp, !qflag, 0) != 0)
				return;
		}
		break;

	case NFSPROC_LOOKUP:
		printf(" lookup");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(dp, &er)))
				break;
			if (er) {
				if (vflag > 1) {
					printf(" post dattr:");
					dp = parse_post_op_attr(dp, vflag);
				}
			} else {
				if (!(dp = parsefh(dp, v3)))
					break;
				if ((dp = parse_post_op_attr(dp, vflag)) &&
				    vflag > 1) {
					printf(" post dattr:");
					dp = parse_post_op_attr(dp, vflag);
				}
			}
			if (dp)
				return;
		} else {
			if (parsediropres(dp) != 0)
				return;
		}
		break;

	case NFSPROC_ACCESS:
		printf(" access");
		if (!(dp = parserep(rp, length)))
			break;
		if (!(dp = parsestatus(dp, &er)))
			break;
		if (vflag)
			printf(" attr:");
		if (!(dp = parse_post_op_attr(dp, vflag)))
			break;
		if (!er) {
			TCHECK(dp[0]);
			printf(" c %04x", (u_int32_t)ntohl(dp[0]));
		}
		return;

	case NFSPROC_READLINK:
		printf(" readlink");
		dp = parserep(rp, length);
		if (dp != NULL && parselinkres(dp, v3) != 0)
			return;
		break;

	case NFSPROC_READ:
		printf(" read");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(dp, &er)))
				break;
			if (!(dp = parse_post_op_attr(dp, vflag)))
				break;
			if (er)
				return;
			if (vflag) {
				TCHECK(dp[1]);
				printf(" %u bytes", (u_int32_t) ntohl(dp[0]));
				if (ntohl(dp[1]))
					printf(" EOF");
			}
			return;
		} else {
			if (parseattrstat(dp, vflag, 0) != 0)
				return;
		}
		break;

	case NFSPROC_WRITE:
		printf(" write");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(dp, &er)))
				break;
			if (!(dp = parse_wcc_data(dp, vflag)))
				break;
			if (er)
				return;
			if (vflag) {
				TCHECK(dp[0]);
				printf(" %u bytes", (u_int32_t) ntohl(dp[0]));
				if (vflag > 1) {
					TCHECK(dp[1]);
					printf(" <%s>",
						tok2str(nfsv3_writemodes,
							NULL, ntohl(dp[1])));
				}
				return;
			}
		} else {
			if (parseattrstat(dp, vflag, v3) != 0)
				return;
		}
		break;

	case NFSPROC_CREATE:
		printf(" create");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsecreateopres(dp, vflag) != 0)
				return;
		} else {
			if (parsediropres(dp) != 0)
				return;
		}
		break;

	case NFSPROC_MKDIR:
		printf(" mkdir");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsecreateopres(dp, vflag) != 0)
				return;
		} else {
			if (parsediropres(dp) != 0)
				return;
		}
		break;

	case NFSPROC_SYMLINK:
		printf(" symlink");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsecreateopres(dp, vflag) != 0)
				return;
		} else {
			if (parsestatus(dp, &er) != 0)
				return;
		}
		break;

	case NFSPROC_MKNOD:
		printf(" mknod");
		if (!(dp = parserep(rp, length)))
			break;
		if (parsecreateopres(dp, vflag) != 0)
			return;
		break;

	case NFSPROC_REMOVE:
		printf(" remove");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsewccres(dp, vflag))
				return;
		} else {
			if (parsestatus(dp, &er) != 0)
				return;
		}
		break;

	case NFSPROC_RMDIR:
		printf(" rmdir");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsewccres(dp, vflag))
				return;
		} else {
			if (parsestatus(dp, &er) != 0)
				return;
		}
		break;

	case NFSPROC_RENAME:
		printf(" rename");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(dp, &er)))
				break;
			if (vflag) {
				printf(" from:");
				if (!(dp = parse_wcc_data(dp, vflag)))
					break;
				printf(" to:");
				if (!(dp = parse_wcc_data(dp, vflag)))
					break;
			}
			return;
		} else {
			if (parsestatus(dp, &er) != 0)
				return;
		}
		break;

	case NFSPROC_LINK:
		printf(" link");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(dp, &er)))
				break;
			if (vflag) {
				printf(" file POST:");
				if (!(dp = parse_post_op_attr(dp, vflag)))
					break;
				printf(" dir:");
				if (!(dp = parse_wcc_data(dp, vflag)))
					break;
				return;
			}
		} else {
			if (parsestatus(dp, &er) != 0)
				return;
		}
		break;

	case NFSPROC_READDIR:
		printf(" readdir");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsev3rddirres(dp, vflag))
				return;
		} else {
			if (parserddires(dp) != 0)
				return;
		}
		break;

	case NFSPROC_READDIRPLUS:
		printf(" readdirplus");
		if (!(dp = parserep(rp, length)))
			break;
		if (parsev3rddirres(dp, vflag))
			return;
		break;

	case NFSPROC_FSSTAT:
		printf(" fsstat");
		dp = parserep(rp, length);
		if (dp != NULL && parsestatfs(dp, v3) != 0)
			return;
		break;

	case NFSPROC_FSINFO:
		printf(" fsinfo");
		dp = parserep(rp, length);
		if (dp != NULL && parsefsinfo(dp) != 0)
			return;
		break;

	case NFSPROC_PATHCONF:
		printf(" pathconf");
		dp = parserep(rp, length);
		if (dp != NULL && parsepathconf(dp) != 0)
			return;
		break;

	case NFSPROC_COMMIT:
		printf(" commit");
		dp = parserep(rp, length);
		if (dp != NULL && parsewccres(dp, vflag) != 0)
			return;
		break;

	default:
		printf(" proc-%u", proc);
		return;
	}
trunc:
	if (!nfserr)
		fputs(" [|nfs]", stdout);
}
@


1.21
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.20 2015/10/15 02:33:25 lteo Exp $	*/
d722 1
a722 1
	Parse_fh((caddr_t *)dp, &fsid, &ino, NULL, &sfsname, 0);
@


1.20
log
@Fix a crash that occurs when printing the filename in a malformed NFS
request packet.

From Kevin Reay who obtained the fix from the tcpdump.org repo (part of
commit 6191f36146f5d286304e9b6e893477fe509d83ab).

ok canacar@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.19 2015/01/16 06:40:21 deraadt Exp $	*/
d292 1
a292 2
nfsreply_print(register const u_char *bp, u_int length,
	       register const u_char *bp2)
d294 1
a294 1
	register const struct rpc_msg *rp;
d312 1
a312 1
parsereq(register const struct rpc_msg *rp, register u_int length)
d314 2
a315 2
	register const u_int32_t *dp;
	register u_int len;
d342 1
a342 1
parsefh(register const u_int32_t *dp, int v3)
d366 1
a366 1
parsefn(register const u_int32_t *dp)
d368 2
a369 2
	register u_int32_t len;
	register const u_char *cp;
d401 1
a401 1
parsefhn(register const u_int32_t *dp, int v3)
d411 1
a411 2
nfsreq_print(register const u_char *bp, u_int length,
    register const u_char *bp2)
d413 2
a414 2
	register const struct rpc_msg *rp;
	register const u_int32_t *dp;
d716 1
a716 1
nfs_printfh(register const u_int32_t *dp, const u_int len)
d885 1
a885 1
parserep(register const struct rpc_msg *rp, register u_int length)
d887 1
a887 1
	register const u_int32_t *dp;
d1380 2
a1381 2
	register const u_int32_t *dp;
	register int v3;
@


1.19
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.18 2014/08/14 12:44:44 mpi Exp $	*/
a383 1
	/* XXX seems like we should be checking the length */
d385 4
a388 1
	(void) fn_printn(cp, len, NULL);
@


1.18
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.17 2014/02/05 21:12:19 florian Exp $	*/
a23 1
#include <sys/param.h>
@


1.17
log
@Don't segfault on IPv6 NFS traffic; found the hard why by matthieu@@.
Fix inspired by what upstream is doing.
Tested by me and matthieu@@.
Input^WHand holding and OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.16 2009/10/27 23:59:55 deraadt Exp $	*/
a33 1
#include <netinet/in_systm.h>
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.15 2007/06/29 11:39:25 thib Exp $	*/
d38 4
d753 4
d759 1
d781 3
d794 17
a810 3
	xmep->ipver = 4;
	memcpy(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));
	memcpy(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));
d827 3
d848 10
@


1.15
log
@make it easy to spot wich nfs version the traffic is.
input & OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.14 2005/05/24 02:38:25 moritz Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) Header: print-nfs.c,v 1.64 97/06/30 13:51:16 leres Exp $ (LBL)";
#endif
@


1.14
log
@more missing bounds checks. ok marius@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.13 2005/05/23 20:32:05 moritz Exp $	*/
d97 8
d419 2
a420 1
	int v3;
d426 7
a432 1
	printf("xid 0x%x %d", (u_int32_t)ntohl(rp->rm_xid), length);
a434 2

	v3 = (ntohl(rp->rm_call.cb_vers) == NFS_VER3);
@


1.13
log
@add some missing bounds checks. ok marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.12 2004/09/16 11:26:39 markus Exp $	*/
d182 1
d202 1
d214 3
d1140 1
d1145 3
d1413 2
a1414 1
		if (!er)
d1416 1
@


1.12
log
@nfs v3 support from tcpdump.org/netbsd; tests with pedro, marius
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.11 2002/02/19 19:39:40 millert Exp $	*/
d640 2
a641 1
			if (vflag)
d644 1
d674 1
@


1.11
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.10 2001/11/07 18:48:16 deraadt Exp $	*/
d53 1
a53 1
#include "nfsv2.h"
d56 203
a258 5
static void nfs_printfh(const u_int32_t *);
static void xid_map_enter(const struct rpc_msg *, const struct ip *);
static u_int32_t xid_map_find(const struct rpc_msg *, const struct ip *,
    u_int32_t *);
static void interp_reply(const struct rpc_msg *, u_int32_t, u_int);
d262 19
d286 1
a286 2
	register const struct ip *ip;
	u_int32_t proc;
a289 1
	ip = (const struct ip *)bp2;
d294 2
a295 2
	if (xid_map_find(rp, ip, &proc))
		interp_reply(rp, proc, length);
d333 1
a333 1
parsefh(register const u_int32_t *dp)
d335 12
a346 3
	if (dp + 8 <= (u_int32_t *)snapend) {
		nfs_printfh(dp);
		return (dp + 8);
d348 1
d363 1
a363 2
	if ((u_char *)dp > snapend - sizeof(*dp))
		return (NULL);
d369 2
a373 2
	if ((u_char *)dp > snapend)
		return (NULL);
d380 2
d390 1
a390 1
parsefhn(register const u_int32_t *dp)
d392 1
a392 1
	dp = parsefh(dp);
a403 1
	register const struct ip *ip;
d405 4
a411 1
	ip = (const struct ip *)bp2;
d414 1
a414 1
	xid_map_enter(rp, ip);	/* record proc number for later on */
d416 7
a422 2
	switch (ntohl(rp->rm_call.cb_proc)) {
#ifdef NFSPROC_NOOP
a425 3
#else
#define NFSPROC_NOOP -1
#endif
d432 2
a433 1
		if ((dp = parsereq(rp, length)) != NULL && parsefh(dp) != NULL)
d439 2
a440 1
		if ((dp = parsereq(rp, length)) != NULL && parsefh(dp) != NULL)
a443 5
#if NFSPROC_ROOT != NFSPROC_NOOP
	case NFSPROC_ROOT:
		printf(" root");
		break;
#endif
d446 11
a456 1
		if ((dp = parsereq(rp, length)) != NULL && parsefhn(dp) != NULL)
d458 1
d463 2
a464 1
		if ((dp = parsereq(rp, length)) != NULL && parsefh(dp) != NULL)
d471 12
a482 5
		    (dp = parsefh(dp)) != NULL) {
			TCHECK2(dp[0], 3 * sizeof(*dp));
			printf(" %u bytes @@ %u",
			    (u_int32_t)ntohl(dp[1]),
			    (u_int32_t)ntohl(dp[0]));
a486 15
#if NFSPROC_WRITECACHE != NFSPROC_NOOP
	case NFSPROC_WRITECACHE:
		printf(" writecache");
		if ((dp = parsereq(rp, length)) != NULL &&
		    (dp = parsefh(dp)) != NULL) {
			TCHECK2(dp[0], 4 * sizeof(*dp));
			printf(" %u (%u) bytes @@ %u (%u)",
			    (u_int32_t)ntohl(dp[3]),
			    (u_int32_t)ntohl(dp[2]),
			    (u_int32_t)ntohl(dp[1]),
			    (u_int32_t)ntohl(dp[0]));
			return;
		}
		break;
#endif
d490 21
a510 7
		    (dp = parsefh(dp)) != NULL) {
			TCHECK2(dp[0], 4 * sizeof(*dp));
			printf(" %u (%u) bytes @@ %u (%u)",
			    (u_int32_t)ntohl(dp[3]),
			    (u_int32_t)ntohl(dp[2]),
			    (u_int32_t)ntohl(dp[1]),
			    (u_int32_t)ntohl(dp[0]));
d517 44
a560 1
		if ((dp = parsereq(rp, length)) != NULL && parsefhn(dp) != NULL)
d562 1
d567 9
a575 1
		if ((dp = parsereq(rp, length)) != NULL && parsefhn(dp) != NULL)
d582 1
a582 1
		    (dp = parsefhn(dp)) != NULL) {
d584 1
a584 1
			if (parsefhn(dp) != NULL)
d592 1
a592 1
		    (dp = parsefh(dp)) != NULL) {
d594 1
a594 1
			if (parsefhn(dp) != NULL)
d599 32
a630 2
	case NFSPROC_SYMLINK:
		printf(" symlink");
d632 12
a643 4
		    (dp = parsefhn(dp)) != NULL) {
			fputs(" -> ", stdout);
			if (parsefn(dp) != NULL)
				return;
d647 4
a650 3
	case NFSPROC_MKDIR:
		printf(" mkdir");
		if ((dp = parsereq(rp, length)) != NULL && parsefhn(dp) != NULL)
d654 4
a657 3
	case NFSPROC_RMDIR:
		printf(" rmdir");
		if ((dp = parsereq(rp, length)) != NULL && parsefhn(dp) != NULL)
d661 2
a662 2
	case NFSPROC_READDIR:
		printf(" readdir");
d664 1
a664 9
		    (dp = parsefh(dp)) != NULL) {
			TCHECK2(dp[0], 2 * sizeof(*dp));
			/*
			 * Print the offset as signed, since -1 is common,
			 * but offsets > 2^31 aren't.
			 */
			printf(" %u bytes @@ %d",
			    (u_int32_t)ntohl(dp[1]),
			    (u_int32_t)ntohl(dp[0]));
a665 1
		}
d668 6
a673 3
	case NFSPROC_STATFS:
		printf(" statfs");
		if ((dp = parsereq(rp, length)) != NULL && parsefh(dp) != NULL)
d675 1
d682 1
d698 1
a698 1
nfs_printfh(register const u_int32_t *dp)
d708 1
a708 1
		static char temp[NFS_FHSIZE+1];
d731 2
a732 1
	u_int32_t		xid;		/* transaction ID (net order) */
d735 2
a736 1
	u_int32_t		proc;		/* call proc number (host order) */
d753 1
a753 1
xid_map_enter(const struct rpc_msg *rp, const struct ip *ip)
d755 1
d758 2
d766 3
a768 2
	xmep->client = ip->ip_src;
	xmep->server = ip->ip_dst;
d770 1
d773 7
a779 3
/* Returns true and sets proc success or false on failure */
static u_int32_t
xid_map_find(const struct rpc_msg *rp, const struct ip *ip, u_int32_t *proc)
d784 2
a785 2
	u_int32_t clip = ip->ip_dst.s_addr;
	u_int32_t sip = ip->ip_src.s_addr;
d788 1
a788 1
	i = xid_map_hint;
d791 17
a807 2
		if (xmep->xid == xid && xmep->client.s_addr == clip &&
		    xmep->server.s_addr == sip) {
d811 2
a812 1
			return (1);
d814 1
d820 1
a820 1
	return (0);
d854 1
a854 1
	TCHECK2(dp[0], 1);
d904 2
a905 3
	if ((sizeof(astat) + ((u_char *)dp)) < snapend)
		return ((u_int32_t *) (sizeof(astat) + ((char *)dp)));

d907 1
a907 1
	return (NULL);
d911 1
a911 1
parsestatus(const u_int32_t *dp)
d913 1
a913 1
	register int errnum;
d916 1
d918 2
d922 3
a924 3
			printf(" ERROR: %s", pcap_strerror(errnum));
		nfserr = 1;		/* suppress trunc string */
		return (NULL);
d928 1
a928 1
	return (NULL);
a930 10
static struct tok type2str[] = {
	{ NFNON,	"NON" },
	{ NFREG,	"REG" },
	{ NFDIR,	"DIR" },
	{ NFBLK,	"BLK" },
	{ NFCHR,	"CHR" },
	{ NFLNK,	"LNK" },
	{ 0,		NULL }
};

d932 1
a932 1
parsefattr(const u_int32_t *dp, int verbose)
d934 1
a934 1
	const struct nfsv2_fattr *fap;
d936 2
a937 1
	fap = (const struct nfsv2_fattr *)dp;
d939 1
a939 2
		TCHECK(fap->fa_nfssize);
		printf(" %s %o ids %u/%u sz %u ",
d944 9
a952 2
		    (u_int32_t)ntohl(fap->fa_gid),
		    (u_int32_t)ntohl(fap->fa_nfssize));
d956 36
a991 18
		TCHECK(fap->fa_nfsfileid);
		printf("nlink %u rdev %x fsid %x nodeid %x a/m/ctime ",
		    (u_int32_t)ntohl(fap->fa_nlink),
		    (u_int32_t)ntohl(fap->fa_nfsrdev),
		    (u_int32_t)ntohl(fap->fa_nfsfsid),
		    (u_int32_t)ntohl(fap->fa_nfsfileid));
		TCHECK(fap->fa_nfsatime);
		printf("%u.%06u ",
		    (u_int32_t)ntohl(fap->fa_nfsatime.nfs_sec),
		    (u_int32_t)ntohl(fap->fa_nfsatime.nfs_usec));
		TCHECK(fap->fa_nfsmtime);
		printf("%u.%06u ",
		    (u_int32_t)ntohl(fap->fa_nfsmtime.nfs_sec),
		    (u_int32_t)ntohl(fap->fa_nfsmtime.nfs_usec));
		TCHECK(fap->fa_nfsctime);
		printf("%u.%06u ",
		    (u_int32_t)ntohl(fap->fa_nfsctime.nfs_sec),
		    (u_int32_t)ntohl(fap->fa_nfsctime.nfs_usec));
d993 2
a994 1
	return ((const u_int32_t *)&fap[1]);
d1000 1
a1000 1
parseattrstat(const u_int32_t *dp, int verbose)
d1002 1
d1004 1
a1004 1
	dp = parsestatus(dp);
d1007 2
d1010 1
a1010 1
	return (parsefattr(dp, verbose) != NULL);
d1016 1
d1018 1
a1018 2
	dp = parsestatus(dp);
	if (dp == NULL)
d1020 2
d1023 1
a1023 1
	dp = parsefh(dp);
d1027 1
a1027 1
	return (parsefattr(dp, vflag) != NULL);
d1031 1
a1031 1
parselinkres(const u_int32_t *dp)
d1033 3
a1035 1
	dp = parsestatus(dp);
d1037 4
a1041 1

d1047 1
a1047 1
parsestatfs(const u_int32_t *dp)
d1049 2
a1050 1
	const struct nfsv2_statfs *sfsp;
d1052 1
a1052 1
	dp = parsestatus(dp);
d1055 16
d1072 24
a1095 9
	if (!qflag) {
		sfsp = (const struct nfsv2_statfs *)dp;
		TCHECK(sfsp->sf_bavail);
		printf(" tsize %u bsize %u blocks %u bfree %u bavail %u",
		    (u_int32_t)ntohl(sfsp->sf_tsize),
		    (u_int32_t)ntohl(sfsp->sf_bsize),
		    (u_int32_t)ntohl(sfsp->sf_blocks),
		    (u_int32_t)ntohl(sfsp->sf_bfree),
		    (u_int32_t)ntohl(sfsp->sf_bavail));
d1106 3
a1108 1
	dp = parsestatus(dp);
d1111 89
a1199 1
	if (!qflag) {
d1201 43
a1243 1
		printf(" offset %x", (u_int32_t)ntohl(dp[0]));
d1245 2
a1246 4
		printf(" size %u", (u_int32_t)ntohl(dp[1]));
		TCHECK(dp[2]);
		if (dp[2] != 0)
			printf(" eof");
d1248 19
d1268 47
d1321 1
a1321 1
interp_reply(const struct rpc_msg *rp, u_int32_t proc, u_int length)
d1324 7
a1333 1
#ifdef NFSPROC_NOOP
d1337 1
a1337 3
#else
#define NFSPROC_NOOP -1
#endif
d1345 1
a1345 1
		if (dp != NULL && parseattrstat(dp, !qflag) != 0)
d1351 1
a1351 2
		dp = parserep(rp, length);
		if (dp != NULL && parseattrstat(dp, !qflag) != 0)
d1353 7
a1361 5
#if NFSPROC_ROOT != NFSPROC_NOOP
	case NFSPROC_ROOT:
		printf(" root");
		break;
#endif
d1364 25
a1388 3
		dp = parserep(rp, length);
		if (dp != NULL && parsediropres(dp) != 0)
			return;
d1391 14
d1408 1
a1408 1
		if (dp != NULL && parselinkres(dp) != 0)
d1414 15
a1428 2
		dp = parserep(rp, length);
		if (dp != NULL && parseattrstat(dp, vflag) != 0)
d1430 4
a1435 5
#if NFSPROC_WRITECACHE != NFSPROC_NOOP
	case NFSPROC_WRITECACHE:
		printf(" writecache");
		break;
#endif
d1438 24
a1461 3
		dp = parserep(rp, length);
		if (dp != NULL && parseattrstat(dp, vflag) != 0)
			return;
d1466 42
a1507 2
		dp = parserep(rp, length);
		if (dp != NULL && parsediropres(dp) != 0)
d1513 22
a1534 3
		dp = parserep(rp, length);
		if (dp != NULL && parsestatus(dp) != 0)
			return;
d1539 13
a1551 2
		dp = parserep(rp, length);
		if (dp != NULL && parsestatus(dp) != 0)
d1553 4
d1561 31
a1591 3
		dp = parserep(rp, length);
		if (dp != NULL && parsestatus(dp) != 0)
			return;
d1594 5
a1598 4
	case NFSPROC_SYMLINK:
		printf(" symlink");
		dp = parserep(rp, length);
		if (dp != NULL && parsestatus(dp) != 0)
d1602 2
a1603 2
	case NFSPROC_MKDIR:
		printf(" mkdir");
d1605 1
a1605 1
		if (dp != NULL && parsediropres(dp) != 0)
d1609 2
a1610 2
	case NFSPROC_RMDIR:
		printf(" rmdir");
d1612 1
a1612 1
		if (dp != NULL && parsestatus(dp) != 0)
d1616 2
a1617 2
	case NFSPROC_READDIR:
		printf(" readdir");
d1619 1
a1619 1
		if (dp != NULL && parserddires(dp) != 0)
d1623 2
a1624 2
	case NFSPROC_STATFS:
		printf(" statfs");
d1626 1
a1626 1
		if (dp != NULL && parsestatfs(dp) != 0)
d1634 1
@


1.10
log
@simplify buffer handling; ok ho
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.9 2000/12/05 08:17:45 jakob Exp $	*/
a32 1
#ifdef __STDC__
a34 1
#endif
@


1.9
log
@tcpdump incorrectly print port numbers when parsing NFS (PR#1540)
fix submitted by Grigoriy Orlov <gluk@@ptci.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: print-nfs.c,v 1.8 2000/10/03 14:31:58 ho Exp $	*/
d380 1
a380 1
		strncpy(temp, sfsname, NFS_FHSIZE);
@


1.8
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 3
a80 18
	if (!nflag)
		(void)printf("%s.nfs > %s.%x: reply %s %d",
			     ipaddr_string(&ip->ip_src),
			     ipaddr_string(&ip->ip_dst),
			     (u_int32_t)ntohl(rp->rm_xid),
			     ntohl(rp->rm_reply.rp_stat) == MSG_ACCEPTED?
				     "ok":"ERR",
			     length);
	else
		(void)printf("%s.%x > %s.%x: reply %s %d",
			     ipaddr_string(&ip->ip_src),
			     NFS_PORT,
			     ipaddr_string(&ip->ip_dst),
			     (u_int32_t)ntohl(rp->rm_xid),
			     ntohl(rp->rm_reply.rp_stat) == MSG_ACCEPTED?
			     	"ok":"ERR",
			     length);

d186 1
a186 13
	if (!nflag)
		(void)printf("%s.%x > %s.nfs: %d",
			     ipaddr_string(&ip->ip_src),
			     (u_int32_t)ntohl(rp->rm_xid),
			     ipaddr_string(&ip->ip_dst),
			     length);
	else
		(void)printf("%s.%x > %s.%x: %d",
			     ipaddr_string(&ip->ip_src),
			     (u_int32_t)ntohl(rp->rm_xid),
			     ipaddr_string(&ip->ip_dst),
			     NFS_PORT,
			     length);
@


1.7
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 2
@


1.6
log
@signed int fix from leres@@ee.lbl.gov
@
text
@d31 1
a31 1
#if __STDC__
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
d24 1
a24 1
    "@@(#) $Header: print-nfs.c,v 1.63 96/12/10 23:18:07 leres Exp $ (LBL)";
d58 2
a59 1
static int32_t xid_map_find(const struct rpc_msg *, const struct ip *);
d70 1
a70 1
	int32_t proc;
d94 2
a95 3
	proc = xid_map_find(rp, ip);
	if (proc >= 0)
		interp_reply(rp, (u_int32_t)proc, length);
d460 3
a462 3
/* Returns NFSPROC_xxx or -1 on failure */
static int32_t
xid_map_find(const struct rpc_msg *rp, const struct ip *ip)
d478 2
a479 1
			return ((int32_t)xmep->proc);
d486 1
a486 1
	return (-1);
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995
d23 2
a24 2
static char rcsid[] =
    "@@(#) Header: print-nfs.c,v 1.52 95/10/22 02:46:29 leres Exp (LBL)";
a28 1
#include <sys/types.h>
d59 3
a61 1
static void interp_reply(const struct rpc_msg *, u_int32_t, int);
d64 1
a64 1
nfsreply_print(register const u_char *bp, int length,
d71 1
d103 1
a103 1
parsereq(register const struct rpc_msg *rp, register int length)
d105 1
a105 2
	register const u_int32_t *dp = (u_int32_t *)&rp->rm_call.cb_cred;
	register const u_int32_t *ep = (u_int32_t *)snapend;
a107 2
	if (&dp[2] >= ep)
		return (0);
d111 11
a121 11
	len =  ntohl(dp[1]);
	if (dp < ep && len < length) {
		dp += (len + (2 * sizeof(u_int32_t) + 3)) / sizeof(u_int32_t);
		if (&dp[2] < ep) {
			len = ntohl(dp[1]);
			if (dp < ep && len < length) {
				dp += (len + (2 * sizeof(u_int32_t) + 3)) /
					sizeof(u_int32_t);
				if (dp < ep)
					return (dp);
			}
d124 2
a125 1
	return (0);
d139 1
a139 1
	return (0);
d154 1
a154 1
		return(0);
d164 1
a164 1
		return (0);
d166 1
d168 1
d182 2
a183 2
	if (dp == 0)
		return (0);
d189 2
a190 1
nfsreq_print(register const u_char *bp, int length, register const u_char *bp2)
a194 3
	register const u_char *ep;

#define TCHECK(p, l) if ((u_char *)(p) > ep - l) break
d196 1
a198 1
	ep = snapend;
d229 1
a229 1
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp) != 0)
d235 1
a235 1
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp) != 0)
d246 1
a246 1
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp) != 0)
d252 1
a252 1
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp) != 0)
d258 3
a260 3
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefh(dp)) != 0) {
			TCHECK(dp, 3 * sizeof(*dp));
d271 3
a273 3
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefh(dp)) != 0) {
			TCHECK(dp, 4 * sizeof(*dp));
d285 3
a287 3
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefh(dp)) != 0) {
			TCHECK(dp, 4 * sizeof(*dp));
d299 1
a299 1
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp) != 0)
d305 1
a305 1
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp) != 0)
d311 2
a312 2
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefhn(dp)) != 0) {
d314 1
a314 1
			if (parsefhn(dp) != 0)
d321 2
a322 2
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefh(dp)) != 0) {
d324 1
a324 1
			if (parsefhn(dp) != 0)
d331 2
a332 2
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefhn(dp)) != 0) {
d334 1
a334 1
			if (parsefn(dp) != 0)
d341 1
a341 1
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp) != 0)
d347 1
a347 1
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp) != 0)
d353 3
a355 3
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefh(dp)) != 0) {
			TCHECK(dp, 2 * sizeof(*dp));
d369 1
a369 1
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp) != 0)
d377 3
a379 2
	fputs(" [|nfs]", stdout);
#undef TCHECK
d398 1
a398 1
	Parse_fh((caddr_t*)dp, &fsid, &ino, NULL, &sfsname, 0);
d401 2
a402 2
	    /* file system ID is ASCII, not numeric, for this server OS */
	    static char temp[NFS_FHSIZE+1];
d404 11
a414 14
	    /* Make sure string is null-terminated */
	    strncpy(temp, sfsname, NFS_FHSIZE);
	    /* Remove trailing spaces */
	    sfsname = strchr(temp, ' ');
	    if (sfsname)
		*sfsname = 0;

	    (void)printf(" fh %s/%u", temp, (u_int32_t)ino);
	}
	else {
	    (void)printf(" fh %u,%u/%u",
		fsid.fsid_dev.Major,
		fsid.fsid_dev.Minor,
		(u_int32_t)ino);
d485 1
a485 1
	return(-1);
d497 1
a497 1
parserep(register const struct rpc_msg *rp, register int length)
d500 1
a500 2
	register const u_int32_t *ep = (const u_int32_t *)snapend;
	int len;
d519 1
a519 2
	if (&dp[1] >= ep)
		return(0);
d522 1
a522 1
		return(0);
d527 1
a527 2
	if (dp >= ep)
		return(0);
d540 2
a541 1
		return(0);
d545 2
a546 1
		return(0);
d550 2
a551 1
		return(0);
d555 2
a556 1
		return(0);
d560 2
a561 1
		return(0);
d565 2
a566 1
		return(0);
d569 2
a570 2
	if ((sizeof(astat) + ((char *)dp)) < (char *)ep)
		return((u_int32_t *) (sizeof(astat) + ((char *)dp)));
d572 2
a573 1
	return (0);
a575 2
#define T2CHECK(p, l) if ((u_char *)(p) > ((u_char *)snapend) - l) return(0)

d579 1
a579 2
	int errnum;
	T2CHECK(dp, 4);
d581 1
d584 4
a587 8
		char *errmsg;

		if (qflag)
			return(0);

		errmsg = pcap_strerror(errnum);
		printf(" ERROR: %s", errmsg);
		return(0);
d590 2
a608 2
	T2CHECK(dp, 4);

d610 2
a611 1
	if (verbose)
d619 1
d622 1
d628 1
d632 1
d636 1
d642 2
d649 1
d660 1
d677 1
a677 1
		return(0);
d690 1
a690 1
		return(0);
d692 10
a701 12
	if (qflag)
		return(1);

	T2CHECK(dp, 20);

	sfsp = (const struct nfsv2_statfs *)dp;
	printf(" tsize %u bsize %u blocks %u bfree %u bavail %u",
	    (u_int32_t)ntohl(sfsp->sf_tsize),
	    (u_int32_t)ntohl(sfsp->sf_bsize),
	    (u_int32_t)ntohl(sfsp->sf_blocks),
	    (u_int32_t)ntohl(sfsp->sf_bfree),
	    (u_int32_t)ntohl(sfsp->sf_bavail));
d704 2
d712 1
a712 1
	if (dp == 0)
d714 9
a722 9
	if (qflag)
		return (1);

	T2CHECK(dp, 12);
	printf(" offset %x size %u ",
	    (u_int32_t)ntohl(dp[0]),
	    (u_int32_t)ntohl(dp[1]));
	if (dp[2] != 0)
		printf("eof");
d725 2
d730 1
a730 1
interp_reply(const struct rpc_msg *rp, u_int32_t proc, int length)
d750 1
a750 1
		if (dp != 0 && parseattrstat(dp, !qflag) != 0)
d757 1
a757 1
		if (dp != 0 && parseattrstat(dp, !qflag) != 0)
d769 1
a769 1
		if (dp != 0 && parsediropres(dp) != 0)
d776 1
a776 1
		if (dp != 0 && parselinkres(dp) != 0)
d783 1
a783 1
		if (dp != 0 && parseattrstat(dp, vflag) != 0)
d795 1
a795 1
		if (dp != 0 && parseattrstat(dp, vflag) != 0)
d802 1
a802 1
		if (dp != 0 && parsediropres(dp) != 0)
d809 1
a809 1
		if (dp != 0 && parsestatus(dp) != 0)
d816 1
a816 1
		if (dp != 0 && parsestatus(dp) != 0)
d823 1
a823 1
		if (dp != 0 && parsestatus(dp) != 0)
d830 1
a830 1
		if (dp != 0 && parsestatus(dp) != 0)
d837 1
a837 1
		if (dp != 0 && parsediropres(dp) != 0)
d844 1
a844 1
		if (dp != 0 && parsestatus(dp) != 0)
d851 1
a851 1
		if (dp != 0 && parserddires(dp) != 0)
d858 1
a858 1
		if (dp != 0 && parsestatfs(dp) != 0)
d866 2
a867 1
	fputs(" [|nfs]", stdout);
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-nfs.c,v 1.5 1996/05/20 00:41:09 fvdl Exp $	*/
/*	$NetBSD: print-nfs.c,v 1.5 1996/05/20 00:41:09 fvdl Exp $	*/
d4 1
a4 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
d26 1
a26 1
    "@@(#) Header: print-nfs.c,v 1.41 94/06/12 14:35:15 leres Exp (LBL)";
d34 4
a45 3
#ifdef SOLARIS
#include <tiuser.h>
#endif
a46 1
#include <rpc/pmap_prot.h>
d49 1
a50 1
#include <errno.h>
a54 1
#include "extract.h"			/* must come after interface.h */
d56 1
a56 1
#include "nfs.h"
d59 1
a59 1
static void nfs_printfh(const u_int32 *, const int);
d61 2
a62 176
static int32 xid_map_find(const struct rpc_msg *, const struct ip *, u_int32 *,
			  u_int32 *);
static void interp_reply(const struct rpc_msg *, u_int32, u_int32, int);
static const u_int32 *parse_post_op_attr(const u_int32 *, int);

/*
 * Mapping of old NFS Version 2 RPC numbers to generic numbers.
 */
u_int32 nfsv3_procid[NFS_NPROCS] = {
	NFSPROC_NULL,
	NFSPROC_GETATTR,
	NFSPROC_SETATTR,
	NFSPROC_NOOP,
	NFSPROC_LOOKUP,
	NFSPROC_READLINK,
	NFSPROC_READ,
	NFSPROC_NOOP,
	NFSPROC_WRITE,
	NFSPROC_CREATE,
	NFSPROC_REMOVE,
	NFSPROC_RENAME,
	NFSPROC_LINK,
	NFSPROC_SYMLINK,
	NFSPROC_MKDIR,
	NFSPROC_RMDIR,
	NFSPROC_READDIR,
	NFSPROC_FSSTAT,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP
};

const char *nfsv3_writemodes[NFSV3WRITE_NMODES] = {
	"unstable",
	"datasync",
	"filesync"
};

static struct token type2str[] = {
	{ NFNON,	"NON" },
	{ NFREG,	"REG" },
	{ NFDIR,	"DIR" },
	{ NFBLK,	"BLK" },
	{ NFCHR,	"CHR" },
	{ NFLNK,	"LNK" },
	{ NFFIFO,	"FIFO" },
	{ 0,		NULL }
};

/*
 * Print out a 64-bit integer. This appears to be different on each system,
 * try to make the best of it. The integer stored as 2 consecutive XDR
 * encoded 32-bit integers, to which a pointer is passed.
 *
 * Assume that a system that has INT64_FORMAT defined, has a 64-bit
 * integer datatype and can print it.
 */ 

#define UNSIGNED 0
#define SIGNED   1
#define HEX      2

int print_int64(const u_int32 *dp, int how)
{
	static char buf[32];
#ifdef INT64_FORMAT
	u_int64 res;

	res = ((u_int64)ntohl(dp[0]) << 32) | (u_int64)ntohl(dp[1]);
	switch (how) {
	case SIGNED:
		printf(INT64_FORMAT, res);
		break;
	case UNSIGNED:
		printf(U_INT64_FORMAT, res);
		break;
	case HEX:
		printf(HEX_INT64_FORMAT, res);
		break;
	default:
		return (0);
	}
#else
	/*
	 * XXX - throw upper 32 bits away.
	 * Could also go for hex: printf("0x%x%x", dp[0], dp[1]);
	 */
	if (sign)
		printf("%ld", (int)dp[1]);
	else
		printf("%lu", (unsigned int)dp[1]);
#endif
	return 1;
}

static const u_int32 *
parse_sattr3(const u_int32 *dp, struct nfsv3_sattr *sa3)
{
	register const u_int32 *ep = (u_int32 *)snapend;

	if (dp + 1 > ep)
		return (0);
	if ((sa3->sa_modeset = ntohl(*dp++))) {
		if (dp + 1 > ep)
			return (0);
		sa3->sa_mode = ntohl(*dp++);
	}

	if (dp + 1 > ep)
		return (0);
	if ((sa3->sa_uidset = ntohl(*dp++))) {
		if (dp + 1 > ep)
			return (0);
		sa3->sa_uid = ntohl(*dp++);
	}

	if (dp + 1 > ep)
		return (0);
	if ((sa3->sa_gidset = ntohl(*dp++))) {
		if (dp + 1 > ep)
			return (0);
		sa3->sa_gid = ntohl(*dp++);
	}

	if (dp + 1 > ep)
		return (0);
	if ((sa3->sa_sizeset = ntohl(*dp++))) {
		if (dp + 1 > ep)
			return (0);
		sa3->sa_size = ntohl(*dp++);
	}

	if (dp + 1 > ep)
		return (0);
	if ((sa3->sa_atimetype = ntohl(*dp++)) == NFSV3SATTRTIME_TOCLIENT) {
		if (dp + 2 > ep)
			return (0);
		sa3->sa_atime.nfsv3_sec = ntohl(*dp++);
		sa3->sa_atime.nfsv3_nsec = ntohl(*dp++);
	}

	if (dp + 1 > ep)
		return (0);
	if ((sa3->sa_mtimetype = ntohl(*dp++)) == NFSV3SATTRTIME_TOCLIENT) {
		if (dp + 2 > ep)
			return (0);
		sa3->sa_mtime.nfsv3_sec = ntohl(*dp++);
		sa3->sa_mtime.nfsv3_nsec = ntohl(*dp++);
	}

	return dp;
}

void
print_sattr3(const struct nfsv3_sattr *sa3, int verbose)
{
	if (sa3->sa_modeset)
		printf(" mode %o", sa3->sa_mode);
	if (sa3->sa_uidset)
		printf(" uid %u", sa3->sa_uid);
	if (sa3->sa_gidset)
		printf(" gid %u", sa3->sa_gid);
	if (verbose > 1) {
		if (sa3->sa_atimetype == NFSV3SATTRTIME_TOCLIENT)
			printf(" atime %u.%06u", sa3->sa_atime.nfsv3_sec,
			       sa3->sa_atime.nfsv3_nsec);
		if (sa3->sa_mtimetype == NFSV3SATTRTIME_TOCLIENT)
			printf(" mtime %u.%06u", sa3->sa_mtime.nfsv3_sec,
			       sa3->sa_mtime.nfsv3_nsec);
	}
}
d70 1
a70 1
	u_int32 proc, vers;
d79 1
a79 1
			     ntohl(rp->rm_xid),
d88 1
a88 1
			     ntohl(rp->rm_xid),
d93 3
a95 2
	if (xid_map_find(rp, ip, &proc, &vers) >= 0)
		interp_reply(rp, proc, vers, length);
d102 1
a102 1
static const u_int32 *
d105 2
a106 2
	register const u_int32 *dp = (u_int32 *)&rp->rm_call.cb_cred;
	register const u_int32 *ep = (u_int32 *)snapend;
d116 9
a124 7
		dp += (len + (2 * sizeof(u_int32) + 3)) / sizeof(u_int32);
		len = ntohl(dp[1]);
		if ((dp < ep) && (len < length)) {
			dp += (len + (2 * sizeof(u_int32) + 3)) /
				sizeof(u_int32);
			if (dp < ep)
				return (dp);
d134 2
a135 2
static const u_int32 *
parsefh(register const u_int32 *dp, int v3)
d137 3
a139 13
	int len;

	if (v3) {
		if (dp + 1 > (u_int32 *)snapend)
			return (0);
		len = (int)ntohl(*dp) / 4;
		dp++;
	} else
		len = NFSX_V2FH / 4;

	if (dp + len <= (u_int32 *)snapend) {
		nfs_printfh(dp, len);
		return (dp + len);
d148 2
a149 2
static const u_int32 *
parsefn(register const u_int32 *dp)
d151 1
a151 1
	register u_int32 len;
d178 2
a179 2
static const u_int32 *
parsefhn(register const u_int32 *dp, int v3)
d181 1
a181 1
	dp = parsefh(dp, v3);
d193 1
a193 1
	register const u_int32 *dp;
a194 3
	nfstype type;
	int proc, v3;
	struct nfsv3_sattr sa3;
d204 1
a204 1
			     ntohl(rp->rm_xid),
d210 1
a210 1
			     ntohl(rp->rm_xid),
d217 2
a218 7
	v3 = (ntohl(rp->rm_call.cb_vers) == NFS_VER3);
	proc = ntohl(rp->rm_call.cb_proc);

	if (!v3 && proc < NFS_NPROCS)
		proc =  nfsv3_procid[proc];

	switch (proc) {
d222 3
d231 1
a231 1
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp, v3) != 0)
d237 1
a237 1
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp, v3) != 0)
d241 5
d248 1
a248 1
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp, v3) != 0)
a251 10
	case NFSPROC_ACCESS:
		printf(" access");
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefh(dp, v3)) != 0) {
			TCHECK(dp, 4);
			printf(" %04x", ntohl(dp[0]));
			return;
		}
		break;

d254 1
a254 1
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp, v3) != 0)
d261 5
a265 10
		    (dp = parsefh(dp, v3)) != 0) {
			if (v3) {
				TCHECK(dp, 3 * sizeof(*dp));
				printf(" %lu bytes @@ ", ntohl(dp[2]));
				print_int64(dp, UNSIGNED);
			} else {
				TCHECK(dp, 2 * sizeof(*dp));
				printf(" %lu bytes @@ %lu",
				       ntohl(dp[1]), ntohl(dp[0]));
			}
d270 15
d288 7
a294 17
		    (dp = parsefh(dp, v3)) != 0) {
			if (v3) {
				TCHECK(dp, 3 * sizeof(*dp));
				printf(" %lu bytes @@ ", ntohl(dp[4]));
				print_int64(dp, UNSIGNED);
				if (vflag) {
					dp += 3;
					TCHECK(dp, sizeof(*dp));
					printf(" <%s>",
					       nfsv3_writemodes[ntohl(*dp)]);
				}
			} else {
				TCHECK(dp, 4 * sizeof(*dp));
				printf(" %lu (%lu) bytes @@ %lu (%lu)",
				       ntohl(dp[3]), ntohl(dp[2]),
				       ntohl(dp[1]), ntohl(dp[0]));
			}
d301 1
a301 1
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp, v3) != 0)
a304 43
	case NFSPROC_MKDIR:
		printf(" mkdir");
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp, v3) != 0)
			return;
		break;

	case NFSPROC_SYMLINK:
		printf(" symlink");
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefhn(dp, v3)) != 0) {
			fputs(" -> ", stdout);
			if (v3 && (dp = parse_sattr3(dp, &sa3)) == 0)
				break;
			if (parsefn(dp) == 0)
				break;
			if (v3 && vflag)
				print_sattr3(&sa3, vflag);
			return;
		}
		break;

	case NFSPROC_MKNOD:
		printf(" mknod");
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefhn(dp, v3)) != 0) {
			if (dp + 1 > (u_int32 *)snapend)
				break;
			type = (nfstype)ntohl(*dp++);
			if ((dp = parse_sattr3(dp, &sa3)) == 0)
				break;
			printf(" %s", tok2str(type2str, "unk-ft %d", type));
			if (vflag && (type == NFCHR || type == NFBLK)) {
				if (dp + 2 > (u_int32 *)snapend)
					break;
				printf(" %u/%u", ntohl(dp[0]), ntohl(dp[1]));
				dp += 2;
			}
			if (vflag)
				print_sattr3(&sa3, vflag);
			return;
		}
		break;

d307 1
a307 7
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp, v3) != 0)
			return;
		break;

	case NFSPROC_RMDIR:
		printf(" rmdir");
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp, v3) != 0)
d314 1
a314 1
		    (dp = parsefhn(dp, v3)) != 0) {
d316 1
a316 1
			if (parsefhn(dp, v3) != 0)
d324 1
a324 1
		    (dp = parsefh(dp, v3)) != 0) {
d326 1
a326 1
			if (parsefhn(dp, v3) != 0)
d331 2
a332 2
	case NFSPROC_READDIR:
		printf(" readdir");
d334 4
a337 22
		    (dp = parsefh(dp, v3)) != 0) {
			if (v3) {
				TCHECK(dp, 20);
				/*
				 * We shouldn't really try to interpret the
				 * offset cookie here.
				 */
				printf(" %lu bytes @@ ", ntohl(dp[4]));
				print_int64(dp, SIGNED);
				if (vflag)
					printf(" verf %08lx%08lx", dp[2],
					       dp[3]);
			} else {
				TCHECK(dp, 2 * sizeof(*dp));
				/*
				 * Print the offset as signed, since -1 is
				 * common, but offsets > 2^31 aren't.
				 */
				printf(" %lu bytes @@ %ld", ntohl(dp[1]),
				       ntohl(dp[0]));
			}
			return;
d341 3
a343 14
	case NFSPROC_READDIRPLUS:
		printf(" readdirplus");
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefh(dp, v3)) != 0) {
			TCHECK(dp, 20);
			/*
			 * We don't try to interpret the offset
			 * cookie here.
			 */
			printf(" %lu bytes @@ ", ntohl(dp[4]));
			print_int64(dp, SIGNED);
			if (vflag)
				printf(" max %lu verf %08lx%08lx",
				       ntohl(dp[5]), dp[2], dp[3]);
a344 1
		}
d347 3
a349 3
	case NFSPROC_FSSTAT:
		printf(" fsstat");
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp, v3) != 0)
d353 14
a366 2
	case NFSPROC_FSINFO:
		printf(" fsinfo");
d369 3
a371 10
	case NFSPROC_PATHCONF:
		printf(" pathconf");
		break;

	case NFSPROC_COMMIT:
		printf(" commit");
		if ((dp = parsereq(rp, length)) != 0 &&
		    (dp = parsefh(dp, v3)) != 0) {
			printf(" %lu bytes @@ ", ntohl(dp[2]));
			print_int64(dp, UNSIGNED);
a372 1
		}
d376 1
a376 1
		printf(" proc-%lu", ntohl(rp->rm_call.cb_proc));
d380 1
d393 1
a393 1
nfs_printfh(register const u_int32 *dp, const int len)
d399 1
a399 1
	Parse_fh((caddr_t*)dp, len, &fsid, &ino, NULL, &sfsname, 0);
d403 1
a403 1
	    static char temp[NFSX_V3FHMAX+1];
d406 1
a406 1
	    strncpy(temp, sfsname, NFSX_V3FHMAX);
d412 1
a412 1
	    (void)printf(" fh %s/%ld", temp, ino);
d415 4
a418 3
	    (void)printf(" fh %d,%d/%ld",
			fsid.fsid_dev.Major, fsid.fsid_dev.Minor,
			ino);
d429 1
a429 1
	u_int32		xid;		/* transaction ID (net order) */
d432 1
a432 2
	u_int32		proc;		/* call proc number (host order) */
	u_int32		vers;		/* program version (host order) */
a461 1
	xmep->vers = ntohl(rp->rm_call.cb_vers);
d465 2
a466 3
static int
xid_map_find(const struct rpc_msg *rp, const struct ip *ip, u_int32 *proc,
	     u_int32 *vers)
d470 3
a472 3
	u_int32 xid = rp->rm_xid;
	u_int32 clip = ip->ip_dst.s_addr;
	u_int32 sip = ip->ip_src.s_addr;
d482 1
a482 3
			*proc = xmep->proc;
			*vers = xmep->vers;
			return 0;
d500 1
a500 1
static const u_int32 *
d503 2
a504 2
	register const u_int32 *dp;
	register const u_int32 *ep = (const u_int32 *)snapend;
d512 1
a512 1
	 *	dp = (u_int32 *)&rp->rm_reply.rp_acpt.ar_verf
d523 1
a523 1
	dp = ((const u_int32 *)&rp->rm_reply) + 1;
d532 1
a532 1
	dp += (len + (2*sizeof(u_int32) + 3)) / sizeof(u_int32);
d571 1
a571 1
		return((u_int32 *) (sizeof(astat) + ((char *)dp)));
d578 2
a579 12
/*
 * Not all systems have strerror().
 */
static char *
strerr(int errno)
{

	return (strerror(errno));
}

static const u_int32 *
parsestatus(const u_int32 *dp, int *er)
d581 1
a581 1
	int errno;
d584 2
a585 4
	errno = ntohl(dp[0]);
	if (er)
		*er = errno;
	if (errno != 0 && !qflag) {
d588 6
a593 5
		errmsg = strerr(errno);
		if (errmsg)
			printf(" ERROR: '%s'", errmsg);
		else
			printf(" ERROR: %d", errno);
d598 12
a609 2
static const u_int32 *
parsefattr(const u_int32 *dp, int verbose, int v3)
d611 1
a611 1
	const struct nfs_fattr *fap;
d613 1
a613 1
	T2CHECK(dp,  5 * sizeof(*dp));
d615 9
a623 17
	fap = (const struct nfs_fattr *)dp;
	if (verbose) {
		printf(" %s %o ids %d/%d",
		    tok2str(type2str, "unk-ft %d ", ntohl(fap->fa_type)),
		       ntohl(fap->fa_mode), ntohl(fap->fa_uid),
		       ntohl(fap->fa_gid));
		if (v3) {
			T2CHECK(dp,  7 * sizeof(*dp));
			printf(" sz ");
			print_int64((u_int32 *)&fap->fa3_size, UNSIGNED);
			putchar(' ');
		}
		else {
			T2CHECK(dp,  6 * sizeof(*dp));
			printf(" sz %d ", ntohl(fap->fa2_size));
		}
	}
d626 14
a639 34
		if (v3) {
			T2CHECK(dp, 64);
			printf("nlink %d rdev %d/%d ",
			       ntohl(fap->fa_nlink),
			       ntohl(fap->fa3_rdev.specdata1),
			       ntohl(fap->fa3_rdev.specdata2));
			printf("fsid ");
			print_int64((u_int32 *)&fap->fa2_fsid, HEX);
			printf(" nodeid ");
			print_int64((u_int32 *)&fap->fa2_fileid, HEX);
			printf(" a/m/ctime %u.%06u ",
			       ntohl(fap->fa3_atime.nfsv3_sec),
			       ntohl(fap->fa3_atime.nfsv3_nsec));
			printf("%u.%06u ",
			       ntohl(fap->fa3_mtime.nfsv3_sec),
			       ntohl(fap->fa3_mtime.nfsv3_nsec));
			printf("%u.%06u ",
			       ntohl(fap->fa3_ctime.nfsv3_sec),
			       ntohl(fap->fa3_ctime.nfsv3_nsec));
		} else {
			T2CHECK(dp, 48);
			printf("nlink %d rdev %x fsid %x nodeid %x a/m/ctime ",
			       ntohl(fap->fa_nlink), ntohl(fap->fa2_rdev),
			       ntohl(fap->fa2_fsid), ntohl(fap->fa2_fileid));
			printf("%u.%06u ",
			       ntohl(fap->fa2_atime.nfsv2_sec),
			       ntohl(fap->fa2_atime.nfsv2_usec));
			printf("%u.%06u ",
			       ntohl(fap->fa2_mtime.nfsv2_sec),
			       ntohl(fap->fa2_mtime.nfsv2_usec));
			printf("%u.%06u ",
			       ntohl(fap->fa2_ctime.nfsv2_sec),
			       ntohl(fap->fa2_ctime.nfsv2_usec));
		}
d641 1
a641 2
	return ((const u_int32 *)((unsigned char *)dp +
		(v3 ? NFSX_V3FATTR : NFSX_V2FATTR)));
d645 1
a645 1
parseattrstat(const u_int32 *dp, int verbose, int v3)
d647 2
a648 4
	int er;

	dp = parsestatus(dp, &er);
	if (dp == NULL || er)
d651 1
a651 1
	return ((long)parsefattr(dp, verbose, v3));
d655 1
a655 1
parsediropres(const u_int32 *dp)
d657 2
a658 3
	int er;

	if (!(dp = parsestatus(dp, &er)) || er)
d661 1
a661 1
	dp = parsefh(dp, 0);
d665 1
a665 1
	return (parsefattr(dp, vflag, 0) != NULL);
d669 1
a669 1
parselinkres(const u_int32 *dp, int v3)
d671 3
a673 1
	int er;
a674 5
	dp = parsestatus(dp, &er);
	if (dp == NULL || er)
		return(0);
	if (v3 && !(dp = parse_post_op_attr(dp, vflag)))
		return (0);
d680 1
a680 1
parsestatfs(const u_int32 *dp, int v3)
d682 1
a682 2
	const struct nfs_statfs *sfsp;
	int er;
d684 2
a685 2
	dp = parsestatus(dp, &er);
	if (dp == NULL || (!v3 && er))
d691 1
a691 10
	if (v3) {
		if (vflag)
			printf(" POST:");
		if (!(dp = parse_post_op_attr(dp, vflag)))
			return (0);
	}

	T2CHECK(dp, (v3 ? NFSX_V3STATFS : NFSX_V2STATFS));

	sfsp = (const struct nfs_statfs *)dp;
d693 7
a699 22
	if (v3) {
		printf(" tbytes ");
		print_int64((u_int32 *)&sfsp->sf_tbytes, UNSIGNED);
		printf(" fbytes ");
		print_int64((u_int32 *)&sfsp->sf_fbytes, UNSIGNED);
		printf(" abytes ");
		print_int64((u_int32 *)&sfsp->sf_abytes, UNSIGNED);
		if (vflag) {
			printf(" tfiles ");
			print_int64((u_int32 *)&sfsp->sf_tfiles, UNSIGNED);
			printf(" ffiles ");
			print_int64((u_int32 *)&sfsp->sf_ffiles, UNSIGNED);
			printf(" afiles ");
			print_int64((u_int32 *)&sfsp->sf_afiles, UNSIGNED);
			printf(" invar %lu", ntohl(sfsp->sf_invarsec));
		}
	} else {
		printf(" tsize %d bsize %d blocks %d bfree %d bavail %d",
		       ntohl(sfsp->sf_tsize), ntohl(sfsp->sf_bsize),
		       ntohl(sfsp->sf_blocks), ntohl(sfsp->sf_bfree),
		       ntohl(sfsp->sf_bavail));
	}
d705 1
a705 1
parserddires(const u_int32 *dp)
d707 2
a708 4
	int er;

	dp = parsestatus(dp, &er);
	if (dp == 0 || er)
d714 3
a716 1
	printf(" offset %x size %d ", ntohl(dp[0]), ntohl(dp[1]));
a722 178
static const u_int32 *
parse_wcc_attr(const u_int32 *dp)
{
	printf(" sz ");
	print_int64(dp, UNSIGNED);
	printf(" mtime %u.%06u ctime %u.%06u", ntohl(dp[2]), ntohl(dp[3]),
	       ntohl(dp[4]), ntohl(dp[5]));
	return (dp + 6);
}

/*
 * Pre operation attributes. Print only if vflag > 1.
 */
static const u_int32 *
parse_pre_op_attr(const u_int32 *dp, int verbose)
{
	T2CHECK(dp, 4);
	if (!ntohl(dp[0]))
		return (dp + 1);
	dp++;
	T2CHECK(dp, 24);
	if (verbose > 1) {
		return parse_wcc_attr(dp);
	} else {
		/* If not verbose enough, just skip over wcc_attr */
		return (dp + 6);
	}
}

/*
 * Post operation attributes are printed if vflag >= 1
 */
static const u_int32 *
parse_post_op_attr(const u_int32 *dp, int verbose)
{
	T2CHECK(dp, 4);
	if (!ntohl(dp[0]))
		return (dp + 1);
	dp++;
	if (verbose) {
		return parsefattr(dp, verbose, 1);
	} else
		return (dp + (NFSX_V3FATTR / sizeof (u_int32)));
}

static const u_int32 *
parse_wcc_data(const u_int32 *dp, int verbose)
{
	if (verbose > 1)
		printf(" PRE:");
	if (!(dp = parse_pre_op_attr(dp, verbose)))
		return (0);

	if (verbose)
		printf(" POST:");
	return parse_post_op_attr(dp, verbose);
}

static const u_int32 *
parsecreateopres(const u_int32 *dp, int verbose)
{
	int er;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	if (er)
		dp = parse_wcc_data(dp, verbose);
	else {
		T2CHECK(dp, 4);
		if (!ntohl(dp[0]))
			return (dp + 1);
		dp++;
		if (!(dp = parsefh(dp, 1)))
			return (0);
		if (verbose) {
			if (!(dp = parse_post_op_attr(dp, verbose)))
				return (0);
			if (vflag > 1) {
				printf("dir attr:");
				dp = parse_wcc_data(dp, verbose);
			}
		}
	}
	return (dp);
}

static int
parsewccres(const u_int32 *dp, int verbose)
{
	int er;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	return parse_wcc_data(dp, verbose) != 0;
}

static const u_int32 *
parsev3rddirres(const u_int32 *dp, int verbose)
{
	int er;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	if (vflag)
		printf(" POST:");
	if (!(dp = parse_post_op_attr(dp, verbose)))
		return (0);
	if (er)
		return dp;
	if (vflag) {
		T2CHECK(dp, 8);
		printf(" verf %08lx%08lx", dp[0], dp[1]);
		dp += 2;
	}
	return dp;
}

static int
parsefsinfo(const u_int32 *dp)
{
	struct nfsv3_fsinfo *sfp;
	int er;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	if (vflag)
		printf(" POST:");
	if (!(dp = parse_post_op_attr(dp, vflag)))
		return (0);
	if (er)
		return (1);

	T2CHECK(dp, sizeof (struct nfsv3_fsinfo));

	sfp = (struct nfsv3_fsinfo *)dp;
	printf(" rtmax %lu rtpref %lu wtmax %lu wtpref %lu dtpref %lu",
	       ntohl(sfp->fs_rtmax), ntohl(sfp->fs_rtpref),
	       ntohl(sfp->fs_wtmax), ntohl(sfp->fs_wtpref),
	       ntohl(sfp->fs_dtpref));
	if (vflag) {
		printf(" rtmult %lu wtmult %lu maxfsz ",
		       ntohl(sfp->fs_rtmult), ntohl(sfp->fs_wtmult));
		print_int64((u_int32 *)&sfp->fs_maxfilesize, UNSIGNED);
		printf(" delta %u.%06u ", ntohl(sfp->fs_timedelta.nfsv3_sec),
		       ntohl(sfp->fs_timedelta.nfsv3_nsec));
	}
	return (1);
}

static int
parsepathconf(const u_int32 *dp)
{
	int er;
	struct nfsv3_pathconf *spp;

	if (!(dp = parsestatus(dp, &er)))
		return (0);
	if (vflag)
		printf(" POST:");
	if (!(dp = parse_post_op_attr(dp, vflag)))
		return (0);
	if (er)
		return (1);

	T2CHECK(dp, sizeof (struct nfsv3_pathconf));

	spp = (struct nfsv3_pathconf *)dp;

	printf(" linkmax %lu namemax %lu %s %s %s %s",
	       ntohl(spp->pc_linkmax),
	       ntohl(spp->pc_namemax),
	       ntohl(spp->pc_notrunc) ? "notrunc" : "",
	       ntohl(spp->pc_chownrestricted) ? "chownres" : "",
	       ntohl(spp->pc_caseinsensitive) ? "igncase" : "",
	       ntohl(spp->pc_casepreserving) ? "keepcase" : "");
	return (0);
}
				
d724 1
a724 1
interp_reply(const struct rpc_msg *rp, u_int32 proc, u_int32 vers, int length)
d726 1
a726 9
	register const u_int32 *dp;
	register int v3;
	register const u_char *ep = snapend;
	int er;

	v3 = (vers == NFS_VER3);

	if (!v3 && proc < NFS_NPROCS)
		proc = nfsv3_procid[proc];
d730 1
d734 3
a736 1

d744 1
a744 1
		if (dp != 0 && parseattrstat(dp, !qflag, v3) != 0)
d750 2
a751 1
		if (!(dp = parserep(rp, length)))
a752 7
		if (v3) {
			if (parsewccres(dp, vflag))
				return;
		} else {
			if (parseattrstat(dp, !qflag, 0) != 0)
				return;
		}
d755 5
d762 3
a764 25
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(dp, &er)))
				break;
			if (er) {
				if (vflag > 1) {
					printf(" post dattr:");
					dp = parse_post_op_attr(dp, vflag);
				}
			} else {
				if (!(dp = parsefh(dp, v3)))
					break;
				if ((dp = parse_post_op_attr(dp, vflag)) &&
				    vflag > 1) {
					printf(" post dattr:");
					dp = parse_post_op_attr(dp, vflag);
				}
			}
			if (dp)
				return;
		} else {
			if (parsediropres(dp) != 0)
				return;
		}
a766 13
	case NFSPROC_ACCESS:
		printf(" access");
		dp = parserep(rp, length);
		if (!(dp = parsestatus(dp, &er)))
			break;
		if (vflag)
			printf(" attr:");
		if (!(dp = parse_post_op_attr(dp, vflag)))
			break;
		if (!er)
			printf(" c %04x", ntohl(dp[0]));
		return;

d770 1
a770 1
		if (dp != 0 && parselinkres(dp, v3) != 0)
d776 2
a777 15
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(dp, &er)))
				break;
			if (!(dp = parse_post_op_attr(dp, vflag)))
				break;
			if (er)
				return;
			if (vflag) {
				TCHECK(dp, 8);
				printf("%lu bytes", ntohl(dp[0]));
				if (ntohl(dp[1]))
					printf(" EOF");
			}
a778 4
		} else {
			if (parseattrstat(dp, vflag, 0) != 0)
				return;
		}
d781 5
d788 3
a790 23
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(dp, &er)))
				break;
			if (!(dp = parse_wcc_data(dp, vflag)))
				break;
			if (er)
				return;
			if (vflag) {
				TCHECK(dp, 4);
				printf("%lu bytes", ntohl(dp[0]));
				if (vflag > 1) {
					TCHECK(dp, 4);
					printf(" <%s>",
					       nfsv3_writemodes[ntohl(dp[1])]);
				}
				return;
			}
		} else {
			if (parseattrstat(dp, vflag, v3) != 0)
				return;
		}
d795 2
a796 42
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsecreateopres(dp, vflag) != 0)
				return;
		} else {
			if (parsediropres(dp) != 0)
				return;
		}
		break;

	case NFSPROC_MKDIR:
		printf(" mkdir");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsecreateopres(dp, vflag) != 0)
				return;
		} else {
			if (parsediropres(dp) != 0)
				return;
		}
		break;

	case NFSPROC_SYMLINK:
		printf(" symlink");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsecreateopres(dp, vflag) != 0)
				return;
		} else {
			if (parsestatus(dp, &er) != 0)
				return;
		}
		break;

	case NFSPROC_MKNOD:
		printf(" mknod");
		if (!(dp = parserep(rp, length)))
			break;
		if (parsecreateopres(dp, vflag) != 0)
d802 3
a804 22
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsewccres(dp, vflag))
				return;
		} else {
			if (parsestatus(dp, &er) != 0)
				return;
		}
		break;

	case NFSPROC_RMDIR:
		printf(" rmdir");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsewccres(dp, vflag))
				return;
		} else {
			if (parsestatus(dp, &er) != 0)
				return;
		}
d809 2
a810 13
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(dp, &er)))
				break;
			if (vflag) {
				printf(" from:");
				if (!(dp = parse_wcc_data(dp, vflag)))
					break;
				printf(" to:");
				if (!(dp = parse_wcc_data(dp, vflag)))
					break;
			}
a811 4
		} else {
			if (parsestatus(dp, &er) != 0)
				return;
		}
d816 3
a818 18
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (!(dp = parsestatus(dp, &er)))
				break;
			if (vflag) {
				printf(" file POST:");
				if (!(dp = parse_post_op_attr(dp, vflag)))
					break;
				printf(" dir:");
				if (!(dp = parse_wcc_data(dp, vflag)))
					break;
				return;
			}
		} else {
			if (parsestatus(dp, &er) != 0)
				return;
		}
d821 4
a824 18
	case NFSPROC_READDIR:
		printf(" readdir");
		if (!(dp = parserep(rp, length)))
			break;
		if (v3) {
			if (parsev3rddirres(dp, vflag))
				return;
		} else {
			if (parserddires(dp) != 0)
				return;
		}
		break;

	case NFSPROC_READDIRPLUS:
		printf(" readdirplus");
		if (!(dp = parserep(rp, length)))
			break;
		if (parsev3rddirres(dp, vflag))
d828 2
a829 2
	case NFSPROC_FSSTAT:
		printf(" fsstat");
d831 1
a831 1
		if (dp != 0 && parsestatfs(dp, v3) != 0)
d835 2
a836 2
	case NFSPROC_FSINFO:
		printf(" fsinfo");
d838 1
a838 1
		if (dp != 0 && parsefsinfo(dp) != 0)
d842 2
a843 2
	case NFSPROC_PATHCONF:
		printf(" pathconf");
d845 1
a845 1
		if (dp != 0 && parsepathconf(dp) != 0)
d849 2
a850 2
	case NFSPROC_COMMIT:
		printf(" commit");
d852 1
a852 1
		if (dp != 0 && parsewccres(dp, vflag) != 0)
d857 1
a857 1
		printf(" proc-%lu", proc);
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: print-nfs.c,v 1.4 1995/04/24 13:27:45 cgd Exp $	*/
d58 1
a58 1
#include "nfsv2.h"
d61 1
a61 1
static void nfs_printfh(const u_int32 *);
d63 176
a238 2
static int32 xid_map_find(const struct rpc_msg *, const struct ip *);
static void interp_reply(const struct rpc_msg *, u_int32, int);
d246 1
a246 1
	int32 proc;
d269 2
a270 3
	proc = xid_map_find(rp, ip);
	if (proc >= 0)
		interp_reply(rp, (u_int32)proc, length);
d308 1
a308 1
parsefh(register const u_int32 *dp)
d310 13
a322 3
	if (dp + 8 <= (u_int32 *)snapend) {
		nfs_printfh(dp);
		return (dp + 8);
d362 1
a362 1
parsefhn(register const u_int32 *dp)
d364 1
a364 1
	dp = parsefh(dp);
d378 3
d403 7
a409 2
	switch (ntohl(rp->rm_call.cb_proc)) {
#ifdef NFSPROC_NOOP
a412 3
#else
#define NFSPROC_NOOP -1
#endif
d419 1
a419 1
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp) != 0)
d425 1
a425 1
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp) != 0)
a428 5
#if NFSPROC_ROOT != NFSPROC_NOOP
	case NFSPROC_ROOT:
		printf(" root");
		break;
#endif
d431 1
a431 1
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp) != 0)
d435 10
d447 1
a447 1
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp) != 0)
d454 10
a463 4
		    (dp = parsefh(dp)) != 0) {
			TCHECK(dp, 3 * sizeof(*dp));
			printf(" %lu bytes @@ %lu",
			       ntohl(dp[1]), ntohl(dp[0]));
d468 2
a469 3
#if NFSPROC_WRITECACHE != NFSPROC_NOOP
	case NFSPROC_WRITECACHE:
		printf(" writecache");
d471 17
a487 5
		    (dp = parsefh(dp)) != 0) {
			TCHECK(dp, 4 * sizeof(*dp));
			printf(" %lu (%lu) bytes @@ %lu (%lu)",
			       ntohl(dp[3]), ntohl(dp[2]),
			       ntohl(dp[1]), ntohl(dp[0]));
d491 15
a505 3
#endif
	case NFSPROC_WRITE:
		printf(" write");
d507 8
a514 5
		    (dp = parsefh(dp)) != 0) {
			TCHECK(dp, 4 * sizeof(*dp));
			printf(" %lu (%lu) bytes @@ %lu (%lu)",
			       ntohl(dp[3]), ntohl(dp[2]),
			       ntohl(dp[1]), ntohl(dp[0]));
d519 18
a536 3
	case NFSPROC_CREATE:
		printf(" create");
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp) != 0)
d538 1
d543 7
a549 1
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp) != 0)
d556 1
a556 1
		    (dp = parsefhn(dp)) != 0) {
d558 1
a558 1
			if (parsefhn(dp) != 0)
d566 1
a566 1
		    (dp = parsefh(dp)) != 0) {
d568 1
a568 1
			if (parsefhn(dp) != 0)
d573 2
a574 2
	case NFSPROC_SYMLINK:
		printf(" symlink");
d576 22
a597 4
		    (dp = parsefhn(dp)) != 0) {
			fputs(" -> ", stdout);
			if (parsefn(dp) != 0)
				return;
d601 14
a614 3
	case NFSPROC_MKDIR:
		printf(" mkdir");
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp) != 0)
d616 1
d619 3
a621 3
	case NFSPROC_RMDIR:
		printf(" rmdir");
		if ((dp = parsereq(rp, length)) != 0 && parsefhn(dp) != 0)
d625 10
a634 2
	case NFSPROC_READDIR:
		printf(" readdir");
d636 3
a638 7
		    (dp = parsefh(dp)) != 0) {
			TCHECK(dp, 2 * sizeof(*dp));
			/*
			 * Print the offset as signed, since -1 is common,
			 * but offsets > 2^31 aren't.
			 */
			printf(" %lu bytes @@ %ld", ntohl(dp[1]), ntohl(dp[0]));
a642 6
	case NFSPROC_STATFS:
		printf(" statfs");
		if ((dp = parsereq(rp, length)) != 0 && parsefh(dp) != 0)
			return;
		break;

a647 1
#undef TCHECK
d660 1
a660 1
nfs_printfh(register const u_int32 *dp)
d666 1
a666 1
	Parse_fh((caddr_t*)dp, &fsid, &ino, NULL, &sfsname, 0);
d670 1
a670 1
	    static char temp[NFS_FHSIZE+1];
d673 1
a673 1
	    strncpy(temp, sfsname, NFS_FHSIZE);
d699 1
d729 1
d733 3
a735 2
static int32
xid_map_find(const struct rpc_msg *rp, const struct ip *ip)
d751 3
a753 1
			return ((int32)xmep->proc);
d860 1
a860 1
parsestatus(const u_int32 *dp)
d866 3
a868 1
	if (errno != 0) {
a870 3
		if (qflag)
			return(0);

d873 1
a873 1
			printf(" ERROR: %s", errmsg);
a875 1
		return(0);
a879 10
static struct token type2str[] = {
	{ NFNON,	"NON" },
	{ NFREG,	"REG" },
	{ NFDIR,	"DIR" },
	{ NFBLK,	"BLK" },
	{ NFCHR,	"CHR" },
	{ NFLNK,	"LNK" },
	{ 0,		NULL }
};

d881 1
a881 1
parsefattr(const u_int32 *dp, int verbose)
d883 1
a883 1
	const struct nfsv2_fattr *fap;
d885 1
a885 1
	T2CHECK(dp, 4);
d887 3
a889 3
	fap = (const struct nfsv2_fattr *)dp;
	if (verbose)
		printf(" %s %o ids %d/%d sz %d ",
d892 12
a903 1
		       ntohl(fap->fa_gid), ntohl(fap->fa_nfssize));
d906 34
a939 12
		printf("nlink %d rdev %x fsid %x nodeid %x a/m/ctime ",
		       ntohl(fap->fa_nlink), ntohl(fap->fa_nfsrdev),
		       ntohl(fap->fa_nfsfsid), ntohl(fap->fa_nfsfileid));
		printf("%d.%06d ",
		       ntohl(fap->fa_nfsatime.nfs_sec),
		       ntohl(fap->fa_nfsatime.nfs_usec));
		printf("%d.%06d ",
		       ntohl(fap->fa_nfsmtime.nfs_sec),
		       ntohl(fap->fa_nfsmtime.nfs_usec));
		printf("%d.%06d ",
		       ntohl(fap->fa_nfsctime.nfs_sec),
		       ntohl(fap->fa_nfsctime.nfs_usec));
d941 2
a942 1
	return ((const u_int32 *)&fap[1]);
d946 1
a946 1
parseattrstat(const u_int32 *dp, int verbose)
d948 4
a951 2
	dp = parsestatus(dp);
	if (dp == NULL)
d954 1
a954 1
	return ((long)parsefattr(dp, verbose));
d960 3
a962 2
	dp = parsestatus(dp);
	if (dp == NULL)
d965 1
a965 1
	dp = parsefh(dp);
d969 1
a969 1
	return (parsefattr(dp, vflag) != NULL);
d973 1
a973 1
parselinkres(const u_int32 *dp)
d975 4
a978 2
	dp = parsestatus(dp);
	if (dp == NULL)
d980 2
a981 1

d987 1
a987 1
parsestatfs(const u_int32 *dp)
d989 2
a990 1
	const struct nfsv2_statfs *sfsp;
d992 2
a993 2
	dp = parsestatus(dp);
	if (dp == NULL)
d999 10
a1008 1
	T2CHECK(dp, 20);
d1010 22
a1031 5
	sfsp = (const struct nfsv2_statfs *)dp;
	printf(" tsize %d bsize %d blocks %d bfree %d bavail %d",
	       ntohl(sfsp->sf_tsize), ntohl(sfsp->sf_bsize),
	       ntohl(sfsp->sf_blocks), ntohl(sfsp->sf_bfree),
	       ntohl(sfsp->sf_bavail));
d1039 4
a1042 2
	dp = parsestatus(dp);
	if (dp == 0)
d1055 178
d1234 1
a1234 1
interp_reply(const struct rpc_msg *rp, u_int32 proc, int length)
d1237 8
a1247 1
#ifdef NFSPROC_NOOP
d1251 1
a1251 3
#else
#define NFSPROC_NOOP -1
#endif
d1259 1
a1259 1
		if (dp != 0 && parseattrstat(dp, !qflag) != 0)
d1265 1
a1265 2
		dp = parserep(rp, length);
		if (dp != 0 && parseattrstat(dp, !qflag) != 0)
d1267 7
a1275 5
#if NFSPROC_ROOT != NFSPROC_NOOP
	case NFSPROC_ROOT:
		printf(" root");
		break;
#endif
d1278 29
d1308 9
a1316 3
		if (dp != 0 && parsediropres(dp) != 0)
			return;
		break;
d1321 1
a1321 1
		if (dp != 0 && parselinkres(dp) != 0)
d1327 15
a1341 2
		dp = parserep(rp, length);
		if (dp != 0 && parseattrstat(dp, vflag) != 0)
d1343 4
a1348 5
#if NFSPROC_WRITECACHE != NFSPROC_NOOP
	case NFSPROC_WRITECACHE:
		printf(" writecache");
		break;
#endif
d1351 23
a1373 3
		dp = parserep(rp, length);
		if (dp != 0 && parseattrstat(dp, vflag) != 0)
			return;
d1378 42
a1419 2
		dp = parserep(rp, length);
		if (dp != 0 && parsediropres(dp) != 0)
d1425 22
a1446 3
		dp = parserep(rp, length);
		if (dp != 0 && parsestatus(dp) != 0)
			return;
d1451 13
a1463 2
		dp = parserep(rp, length);
		if (dp != 0 && parsestatus(dp) != 0)
d1465 4
d1473 31
a1503 3
		dp = parserep(rp, length);
		if (dp != 0 && parsestatus(dp) != 0)
			return;
d1506 5
a1510 4
	case NFSPROC_SYMLINK:
		printf(" symlink");
		dp = parserep(rp, length);
		if (dp != 0 && parsestatus(dp) != 0)
d1514 2
a1515 2
	case NFSPROC_MKDIR:
		printf(" mkdir");
d1517 1
a1517 1
		if (dp != 0 && parsediropres(dp) != 0)
d1521 2
a1522 2
	case NFSPROC_RMDIR:
		printf(" rmdir");
d1524 1
a1524 1
		if (dp != 0 && parsestatus(dp) != 0)
d1528 2
a1529 2
	case NFSPROC_READDIR:
		printf(" readdir");
d1531 1
a1531 1
		if (dp != 0 && parserddires(dp) != 0)
d1535 2
a1536 2
	case NFSPROC_STATFS:
		printf(" statfs");
d1538 1
a1538 1
		if (dp != 0 && parsestatfs(dp) != 0)
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
