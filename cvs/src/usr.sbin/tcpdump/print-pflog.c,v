head	1.31;
access;
symbols
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.24.0.14
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.12
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.8
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.6
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.4
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.4
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9;
locks; strict;
comment	@ * @;


1.31
date	2017.05.24.16.20.26;	author bluhm;	state Exp;
branches;
next	1.30;
commitid	f270cFipBydl8N7N;

1.30
date	2017.01.24.22.40.09;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	DUPaNwLEn6fhN1Qr;

1.29
date	2016.04.04.16.26.00;	author sthen;	state Exp;
branches;
next	1.28;
commitid	NOQPmnaJyaxPCccu;

1.28
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	enjTsnD5UO6xazKc;

1.27
date	2015.01.20.18.26.58;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	qRSGCXxt7yQIBAcS;

1.26
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.24;
commitid	yLXrOcgrag4eS8u4;

1.24
date	2011.10.13.18.32.30;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2010.10.09.08.22.26;	author canacar;	state Exp;
branches;
next	1.22;

1.22
date	2010.09.21.10.46.12;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.26.16.47.07;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.06.12.09.06;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.23.22.33.11;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.27.17.22.41;	author dhartmei;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.11.15.54.11;	author dhartmei;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.21.21.01.15;	author dhartmei;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.14.08.50.37;	author canacar;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.28.22.45.19;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.01.16.55.16;	author mcbride;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.18.14.52.53;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.03.13.27.14;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.20.36.00;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.26.22.51.03;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.26.22.26.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.26.19.06.16;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.26.16.08.23;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.26.15.40.29;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.25.23.05.17;	author provos;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Sync NO_PID value from kernel header to tcpdump source.  It is
#ifdef _KERNEL, so it does not work automatically.  This prevents
some bogus uid and pid print when dumping from pflog interface.
from Matthias Pitzl; OK deraadt@@
@
text
@/*	$OpenBSD: print-pflog.c,v 1.30 2017/01/24 22:40:09 deraadt Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/param.h>	/* MAXCOMLEN */
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/mbuf.h>

#ifndef NO_PID
#define NO_PID	(99999+1)
#endif

struct rtentry;

#include <netinet/in.h>
#include <netinet/ip.h>
#include <net/if.h>
#include <net/pfvar.h>
#include <net/if_pflog.h>

#include <arpa/inet.h>

#include <ctype.h>
#include <netdb.h>
#include <pcap.h>
#include <signal.h>
#include <stdio.h>

#include "interface.h"
#include "addrtoname.h"

char *pf_reasons[PFRES_MAX+2] = PFRES_NAMES;

void
pflog_if_print(u_char *user, const struct pcap_pkthdr *h,
     const u_char *p)
{
	u_int length = h->len;
	u_int hdrlen;
	u_int caplen = h->caplen;
	const struct ip *ip;
#ifdef INET6
	const struct ip6_hdr *ip6;
#endif
	const struct pfloghdr *hdr;
	u_int8_t af;

	ts_print(&h->ts);

	/* check length */
	if (caplen < sizeof(u_int8_t)) {
		printf("[|pflog]");
		goto out;
	}

#define MIN_PFLOG_HDRLEN	45
	hdr = (struct pfloghdr *)p;
	if (hdr->length < MIN_PFLOG_HDRLEN) {
		printf("[pflog: invalid header length!]");
		goto out;
	}
	hdrlen = (hdr->length + 3) & 0xfc;

	if (caplen < hdrlen) {
		printf("[|pflog]");
		goto out;
	}

	/*
	 * Some printers want to get back at the link level addresses,
	 * and/or check that they're not walking off the end of the packet.
	 * Rather than pass them all the way down, we set these globals.
	 */
	packetp = p;
	snapend = p + caplen;

	hdr = (struct pfloghdr *)p;
	if (eflag) {
		printf("rule ");
		if (ntohl(hdr->rulenr) == (u_int32_t) -1)
			printf("def");
		else {
			printf("%u", ntohl(hdr->rulenr));
			if (hdr->ruleset[0]) {
				printf(".%s", hdr->ruleset);
				if (ntohl(hdr->subrulenr) == (u_int32_t) -1)
					printf(".def");
				else
					printf(".%u", ntohl(hdr->subrulenr));
			}
		}
		if (hdr->reason < PFRES_MAX)
			printf("/(%s) ", pf_reasons[hdr->reason]);
		else
			printf("/(unkn %u) ", (unsigned)hdr->reason);
		if (vflag)
			printf("[uid %u, pid %u] ", (unsigned)hdr->rule_uid,
			    (unsigned)hdr->rule_pid);

		switch (hdr->action) {
		case PF_MATCH:
			printf("match");
			break;
		case PF_SCRUB:
			printf("scrub");
			break;
		case PF_PASS:
			printf("pass");
			break;
		case PF_DROP:
			printf("block");
			break;
		case PF_NAT:
		case PF_NONAT:
			printf("nat");
			break;
		case PF_BINAT:
		case PF_NOBINAT:
			printf("binat");
			break;
		case PF_RDR:
		case PF_NORDR:
			printf("rdr");
			break;
		}
		printf(" %s on %s: ",
		    hdr->dir == PF_OUT ? "out" : "in",
		    hdr->ifname);
		if (vflag && hdr->pid != NO_PID)
			printf("[uid %u, pid %u] ", (unsigned)hdr->uid,
			    (unsigned)hdr->pid);
		if (vflag && hdr->rewritten) {
			char buf[48];

			if (inet_ntop(hdr->af, &hdr->saddr.v4, buf,
			    sizeof(buf)) == NULL)
				printf("[orig src ?, ");
			else
				printf("[orig src %s:%u, ", buf,
				    ntohs(hdr->sport));
			if (inet_ntop(hdr->af, &hdr->daddr.v4, buf,
			    sizeof(buf)) == NULL)
				printf("dst ?] ");
			else
				printf("dst %s:%u] ", buf,
				    ntohs(hdr->dport));
		}
	}
	af = hdr->naf;
	length -= hdrlen;
	if (af == AF_INET) {
		ip = (struct ip *)(p + hdrlen);
		ip_print((const u_char *)ip, length);
		if (xflag)
			default_print((const u_char *)ip,
			    caplen - hdrlen);
	} else {
#ifdef INET6
		ip6 = (struct ip6_hdr *)(p + hdrlen);
		ip6_print((const u_char *)ip6, length);
		if (xflag)
			default_print((const u_char *)ip6,
			    caplen - hdrlen);
#endif
	}

out:
	putchar('\n');
}
@


1.30
log
@do not need sys/proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.29 2016/04/04 16:26:00 sthen Exp $	*/
d33 1
a33 1
#define NO_PID	(32766+1)
@


1.29
log
@Add sys/queue.h where it's needed. Unbreak userland following recent
removal from mbuf.h.  ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.28 2015/11/16 00:16:39 mmcc Exp $	*/
a30 1
#include <sys/proc.h>
@


1.28
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.27 2015/01/20 18:26:58 deraadt Exp $	*/
d29 1
@


1.27
log
@Adjust <sys/param.h> comments regarding use of use of MSIZE, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.26 2015/01/16 06:40:21 deraadt Exp $	*/
d59 1
a59 1
     register const u_char *p)
@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.25 2014/08/14 12:44:44 mpi Exp $	*/
d24 1
a24 1
#include <sys/param.h>	/* MSIZE MAXCOMLEN */
a36 2
#include <net/if.h>
#include <net/if_pflog.h>
d40 1
a40 1

d42 1
@


1.25
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.24 2011/10/13 18:32:30 claudio Exp $	*/
d24 1
a24 2
#include <sys/types.h>
#include <sys/param.h>
@


1.24
log
@Teach some userland tools about NAT64. I think this is mostly from mikeb@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.23 2010/10/09 08:22:26 canacar Exp $	*/
a41 1
#include <netinet/in_systm.h>
@


1.23
log
@Do not use BPF_WORDALIGN when computing pflog header length as it aligns
to 8-byte boundary on 64-bit architectures. Instead explicitly round up
to a 4-byte boundary. Reported and tested by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.22 2010/09/21 10:46:12 henning Exp $	*/
d175 1
a175 1
	af = hdr->af;
@


1.22
log
@when a packet has had addresses and/or ports rewritten, show the original
addresses/ports too. ok ryan dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.21 2010/06/26 16:47:07 henning Exp $	*/
d88 1
a88 1
	hdrlen = BPF_WORDALIGN(hdr->length);
@


1.21
log
@remove support for the old pflog format, replaced in 2003
ok ryan theo & herr reyksminister
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.20 2009/10/27 23:59:55 deraadt Exp $	*/
d24 1
d47 2
d158 16
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.19 2009/04/06 12:09:06 henning Exp $	*/
a170 92
#endif
	}

out:
	putchar('\n');
}


void
pflog_old_if_print(u_char *user, const struct pcap_pkthdr *h,
     register const u_char *p)
{
	u_int length = h->len;
	u_int caplen = h->caplen;
	const struct ip *ip;
#ifdef INET6
	const struct ip6_hdr *ip6;
#endif
	const struct old_pfloghdr *hdr;
	u_short res;
	char reason[128], *why;
	u_int8_t af;

	ts_print(&h->ts);

	if (caplen < OLD_PFLOG_HDRLEN) {
		printf("[|pflog]");
		goto out;
	}

	/*
	 * Some printers want to get back at the link level addresses,
	 * and/or check that they're not walking off the end of the packet.
	 * Rather than pass them all the way down, we set these globals.
	 */
	packetp = p;
	snapend = p + caplen;

	hdr = (struct old_pfloghdr *)p;
	if (eflag) {
		res = ntohs(hdr->reason);
		why = (res < PFRES_MAX) ? pf_reasons[res] : "unkn";

		snprintf(reason, sizeof(reason), "%d(%s)", res, why);

		printf("rule %d/%s: ",
		    (short)ntohs(hdr->rnr), reason);
		switch (ntohs(hdr->action)) {
		case PF_MATCH:
			printf("match");
			break;
		case PF_SCRUB:
			printf("scrub");
			break;
		case PF_PASS:
			printf("pass");
			break;
		case PF_DROP:
			printf("block");
			break;
		case PF_NAT:
		case PF_NONAT:
			printf("nat");
			break;
		case PF_BINAT:
		case PF_NOBINAT:
			printf("binat");
			break;
		case PF_RDR:
		case PF_NORDR:
			printf("rdr");
			break;
		}
		printf(" %s on %s: ",
		    ntohs(hdr->dir) == PF_OUT ? "out" : "in",
		    hdr->ifname);
	}
	af = ntohl(hdr->af);
	length -= OLD_PFLOG_HDRLEN;
	if (af == AF_INET) {
		ip = (struct ip *)(p + OLD_PFLOG_HDRLEN);
		ip_print((const u_char *)ip, length);
		if (xflag)
			default_print((const u_char *)ip,
			    caplen - OLD_PFLOG_HDRLEN);
	} else {
#ifdef INET6
		ip6 = (struct ip6_hdr *)(p + OLD_PFLOG_HDRLEN);
		ip6_print((const u_char *)ip6, length);
		if (xflag)
			default_print((const u_char *)ip6,
			    caplen - OLD_PFLOG_HDRLEN);
@


1.19
log
@teach tcpdump about match rules
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.18 2007/10/07 16:41:05 deraadt Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id: print-pflog.c,v 1.18 2007/10/07 16:41:05 deraadt Exp $ (LBL)";
#endif
@


1.18
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.17 2005/11/23 22:33:11 cloder Exp $	*/
d26 1
a26 1
    "@@(#) $Id$ (LBL)";
d129 3
d224 3
@


1.17
log
@Replace a C++ comment with a C comment. No code changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.16 2005/05/27 17:22:41 dhartmei Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.16 2005/05/27 17:22:41 dhartmei Exp $ (LBL)";
@


1.16
log
@log two pairs of uid/pid through pflog: the uid/pid of the process that
inserted the rule which causes the logging. secondly, the uid/pid of the
process in case the logged packet is delivered to/from a local socket.
a lookup of the local socket can be forced for logged packets with a new
option, 'log (user)'. make tcpdump print the additional information when
-e and -v is used. note: this changes the pflog header struct, rebuild all
dependancies. ok bob@@, henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.15 2005/03/11 15:54:11 dhartmei Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.15 2005/03/11 15:54:11 dhartmei Exp $ (LBL)";
d78 1
a78 1
	// check length
@


1.15
log
@clean up printing of rule numbers. omit ruleset name and sub-rule number
when irrelevant. print 'def' for default rule. omit numerical reason if
description is printed. ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.14 2003/06/21 21:01:15 dhartmei Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.14 2003/06/21 21:01:15 dhartmei Exp $ (LBL)";
d35 5
d124 3
d154 3
@


1.14
log
@#ifdef INET6
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.13 2003/05/14 08:50:37 canacar Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.13 2003/05/14 08:50:37 canacar Exp $ (LBL)";
a68 2
	u_int32_t res;
	char reason[128], *why;
d102 15
a116 8
		res = hdr->reason;
		why = (res < PFRES_MAX) ? pf_reasons[res] : "unkn";

		snprintf(reason, sizeof(reason), "%d(%s)", res, why);

		if (ntohl(hdr->subrulenr) == (u_int32_t) -1)
			printf("rule %u/%s: ",
			   ntohl(hdr->rulenr), reason);
d118 1
a118 2
			printf("rule %u.%s.%u/%s: ", ntohl(hdr->rulenr),
			    hdr->ruleset, ntohl(hdr->subrulenr), reason);
@


1.13
log
@libpcap and tcpdump now understand the new pflog datalink type.
old datalink type is still recognized.

ok henning@@ dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.12 2003/01/28 22:45:19 henning Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.12 2003/01/28 22:45:19 henning Exp $ (LBL)";
d65 1
d67 1
d152 1
d158 1
d173 1
d175 1
d241 1
d247 1
@


1.12
log
@a lost ntohs() caused tcpdump not to print the action.

debugging session with and ok'd by dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.11 2003/01/01 16:55:16 mcbride Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.11 2003/01/01 16:55:16 mcbride Exp $ (LBL)";
d62 1
d67 104
d177 1
a177 1
	if (caplen < PFLOG_HDRLEN) {
d190 1
a190 1
	hdr = (struct pfloghdr *)p;
d227 1
a227 1
	length -= PFLOG_HDRLEN;
d229 1
a229 1
		ip = (struct ip *)(p + PFLOG_HDRLEN);
d233 1
a233 1
			    caplen - PFLOG_HDRLEN);
d235 1
a235 1
		ip6 = (struct ip6_hdr *)(p + PFLOG_HDRLEN);
d239 1
a239 1
			    caplen - PFLOG_HDRLEN);
@


1.11
log
@Support all possible rule types ("scrub" rules can log packets being
dropped, others may as well in the future).

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.10 2002/02/19 19:39:40 millert Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.10 2002/02/19 19:39:40 millert Exp $ (LBL)";
d94 1
a94 1
		switch (hdr->action) {
@


1.10
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.9 2001/09/18 14:52:53 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.9 2001/09/18 14:52:53 jakob Exp $ (LBL)";
d92 26
a117 3
		printf("rule %d/%s: %s %s on %s: ",
		    (short)ntohs(hdr->rnr), reason,
		    ntohs(hdr->action) == PF_PASS ? "pass" : "block",
@


1.9
log
@handle ipv6; mcbride@@countersiege.com
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.8 2001/09/03 13:27:14 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.8 2001/09/03 13:27:14 jakob Exp $ (LBL)";
a35 1
#ifdef __STDC__
a36 1
#endif
@


1.8
log
@only print pf rules when using -e flag; <canacar@@eee.metu.edu.tr>
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.7 2001/07/17 20:36:00 provos Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.7 2001/07/17 20:36:00 provos Exp $ (LBL)";
d66 1
d70 1
d87 1
a88 2
		hdr = (struct pfloghdr *)p;

d100 1
d102 13
a114 2
	ip = (struct ip *)(p + PFLOG_HDRLEN);
	ip_print((const u_char *)ip, length);
a115 2
	if (xflag)
		default_print((const u_char *)ip, caplen - PFLOG_HDRLEN);
@


1.7
log
@make it compile
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.6 2001/06/26 22:51:03 deraadt Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /mnt/src/usr.sbin/tcpdump/print-pflog.c,v 1.6 2001/06/26 22:51:03 deraadt Exp $ (LBL)";
a83 2
	
	hdr = (struct pfloghdr *)p;
d85 2
a86 2
	res = ntohs(hdr->reason);
	why = (res < PFRES_MAX) ? pf_reasons[res] : "unkn";
d88 2
a89 1
	snprintf(reason, sizeof(reason), "%d(%s)", res, why); 
d91 1
a91 5
	printf("rule %d/%s: %s %s on %s: ",
	       (short)ntohs(hdr->rnr), reason,
	       ntohs(hdr->action) == PF_PASS ? "pass" : "block",
	       ntohs(hdr->dir) == PF_OUT ? "out" : "in",
	       hdr->ifname);
d93 6
@


1.6
log
@fix PFRES_MAX handling
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.5 2001/06/26 22:26:14 deraadt Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.5 2001/06/26 22:26:14 deraadt Exp $ (LBL)";
a39 1
#include <net/pfvar.h>
d45 2
@


1.5
log
@array of counters indexed by reason codes
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.4 2001/06/26 19:06:16 provos Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.4 2001/06/26 19:06:16 provos Exp $ (LBL)";
d87 1
a87 1
	why = (res <= PFRES_MAX) ? pf_reasons[res] : "unkn";
@


1.4
log
@print reason sub codes.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.3 2001/06/26 16:08:23 provos Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.3 2001/06/26 16:08:23 provos Exp $ (LBL)";
d56 2
d87 1
a87 21
	switch(res) {
	case PFRES_MATCH:
		why = "match";
		break;

	case PFRES_BADOFF:
		why = "bad-offset";
		break;

	case PFRES_FRAG:
		why = "fragment";
		break;

	case PFRES_SHORT:
		why = "short";
		break;

	default:
		why = "unkn";
		break;
	}
@


1.3
log
@print reason nr and text.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.2 2001/06/26 15:40:29 provos Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.2 2001/06/26 15:40:29 provos Exp $ (LBL)";
d90 12
d110 1
a110 1
	       ntohs(hdr->rnr), reason,
@


1.2
log
@print out reason code, unless it is just a match
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.1 2001/06/25 23:05:17 provos Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.1 2001/06/25 23:05:17 provos Exp $ (LBL)";
d64 2
a65 1
	const char *reason;
d84 2
a85 1
	switch(ntohs(hdr->reason)) {
d87 1
a87 1
		reason = "";
d91 1
a91 1
		reason = "(unknown)";
d95 3
a97 1
	printf("rule nr %d%s: %s %s on %s: ",
@


1.1
log
@interpret DLT_PFLOG
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pflog.c,v 1.6 2000/10/03 14:31:57 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pflog.c,v 1.6 2000/10/03 14:31:57 ho Exp $ (LBL)";
d64 1
d83 12
a94 2
	printf("rule nr %d: %s %s on %s: ",
	       ntohl(hdr->rnr),
@

