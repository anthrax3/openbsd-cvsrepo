head	1.27;
access;
symbols
	OPENBSD_6_0:1.27.0.6
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.25.0.26
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.18
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.22
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.20
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.16
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.14
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.12
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.6
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.8
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	enjTsnD5UO6xazKc;

1.26
date	2015.09.27.05.25.01;	author guenther;	state Exp;
branches;
next	1.25;
commitid	PQh1CHLROh0mqpnf;

1.25
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2008.09.19.08.52.16;	author mpf;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.28.12.52.06;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.22.17.24.33;	author moritz;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.13.19.05.56;	author moritz;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.07.16.13.38;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.28.09.37.26;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.23.06.12.07;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.28.19.44.55;	author canacar;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.06.03.11.40;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.02.18.04.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.03.13.25.53;	author jakob;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.05.22.34.01;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.31.16.06.49;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.03.14.31.59;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	99.09.16.20.58.48;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	99.07.28.20.41.37;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.20.12.28;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.20;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.35;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.47;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@/*	$OpenBSD: util.c,v 1.26 2015/09/27 05:25:01 guenther Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/file.h>
#include <sys/limits.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#include <pcap.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#ifdef TIME_WITH_SYS_TIME
#include <time.h>
#endif
#include <unistd.h>

#include "interface.h"
#include "privsep.h"
/*
 * Print out a filename (or other ascii string).
 * If ep is NULL, assume no truncation check is needed.
 * Return true if truncated.
 */
int
fn_print(const u_char *s, const u_char *ep)
{
	int ret;
	u_char c;

	ret = 1;			/* assume truncated */
	while (ep == NULL || s < ep) {
		c = *s++;
		if (c == '\0') {
			ret = 0;
			break;
		}
		if (!isascii(c)) {
			c = toascii(c);
			putchar('M');
			putchar('-');
		}
		if (!isprint(c)) {
			c ^= 0x40;	/* DEL to ?, others to alpha */
			putchar('^');
		}
		putchar(c);
	}
	return(ret);
}

/*
 * Print out a counted filename (or other ascii string).
 * If ep is NULL, assume no truncation check is needed.
 * Return true if truncated.
 */
int
fn_printn(const u_char *s, u_int n, const u_char *ep)
{
	int ret;
	u_char c;

	ret = 1;			/* assume truncated */
	while (ep == NULL || s < ep) {
		if (n-- <= 0) {
			ret = 0;
			break;
		}
		c = *s++;
		if (!isascii(c)) {
			c = toascii(c);
			putchar('M');
			putchar('-');
		}
		if (!isprint(c)) {
			c ^= 0x40;	/* DEL to ?, others to alpha */
			putchar('^');
		}
		putchar(c);
	}
	return(ret);
}

/*
 * Print the timestamp
 */
void
ts_print(const struct bpf_timeval *tvp)
{
	int s;
#define TSBUFLEN 32
	static char buf[TSBUFLEN];
	static struct bpf_timeval last;
	struct timeval diff;
	time_t t;

	if (Iflag && device)
		(void)printf("%s ", device);
	switch(tflag){
	case 0:
		break;
	case -1:
		/* Unix timeval style */
		(void)printf("%u.%06u ",
		    (u_int32_t)tvp->tv_sec, (u_int32_t)tvp->tv_usec);
		break;
	case -2:
		t=tvp->tv_sec;
		strftime(buf, TSBUFLEN, "%b %d %T", priv_localtime(&t));
		printf("%s.%06u ", buf, (u_int32_t)tvp->tv_usec);
		break;
	case -3:
	case -4:
		/* time since first/last frame */
		timersub(tvp, &last, &diff);
		(void)printf("%u.%06u ",
		    (u_int32_t)diff.tv_sec, (u_int32_t)diff.tv_usec);
		if (tflag == -3 || (last.tv_sec == 0 && last.tv_usec == 0))
			last = *tvp;
		break;
	default:
		/* Default */
		s = (tvp->tv_sec + thiszone) % 86400;
		(void)printf("%02d:%02d:%02d.%06u ",
		    s / 3600, (s % 3600) / 60, s % 60, (u_int32_t)tvp->tv_usec);
		break;
	}
}

/*
 * Print a relative number of seconds (e.g. hold time, prune timer)
 * in the form 5m1s.  This does no truncation, so 32230861 seconds
 * is represented as 1y1w1d1h1m1s.
 */
void
relts_print(int secs)
{
	static char *lengths[] = {"y", "w", "d", "h", "m", "s"};
	static int seconds[] = {31536000, 604800, 86400, 3600, 60, 1};
	char **l = lengths;
	int *s = seconds;

	if (secs <= 0) {
		(void)printf("0s");
		return;
	}
	while (secs > 0) {
		if (secs >= *s) {
			(void)printf("%d%s", secs / *s, *l);
			secs -= (secs / *s) * *s;
		}
		s++;
		l++;
	}
}

/*
 * Convert a token value to a string; use "fmt" if not found.
 */
const char *
tok2str(const struct tok *lp, const char *fmt, int v)
{
	static char buf[128];

	while (lp->s != NULL) {
		if (lp->v == v)
			return (lp->s);
		++lp;
	}
	if (fmt == NULL)
		fmt = "#%d";
	(void)snprintf(buf, sizeof(buf), fmt, v);
	return (buf);
}


__dead void
error(const char *fmt, ...)
{
	va_list ap;

	(void)fprintf(stderr, "%s: ", program_name);
	va_start(ap, fmt);
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fputc('\n', stderr);
	exit(1);
	/* NOTREACHED */
}

void
warning(const char *fmt, ...)
{
	va_list ap;

	(void)fprintf(stderr, "%s: WARNING: ", program_name);
	va_start(ap, fmt);
	(void)vfprintf(stderr, fmt, ap);
	va_end(ap);
	(void)fputc('\n', stderr);
}


/*
 * Copy arg vector into a new buffer, concatenating arguments with spaces.
 */
char *
copy_argv(char * const *argv)
{
	size_t len = 0, n;
	char *buf;

	if (argv == NULL)
		return (NULL);

	for (n = 0; argv[n]; n++)
		len += strlen(argv[n])+1;
	if (len == 0)
		return (NULL);

	buf = malloc(len);
	if (buf == NULL)
		return (NULL);

	strlcpy(buf, argv[0], len);
	for (n = 1; argv[n]; n++) {
		strlcat(buf, " ", len);
		strlcat(buf, argv[n], len);
	}
	return (buf);
}

char *
read_infile(char *fname)
{
	struct stat	 buf;
	int		 fd;
	ssize_t		 cc;
	size_t		 bs;
	char		*cp;

	fd = open(fname, O_RDONLY);
	if (fd < 0)
		error("can't open %s: %s", fname, pcap_strerror(errno));

	if (fstat(fd, &buf) < 0)
		error("can't stat %s: %s", fname, pcap_strerror(errno));

	if (buf.st_size >= SSIZE_MAX)
		error("file too long");

	bs = buf.st_size;
	cp = malloc(bs + 1);
	if (cp == NULL)
		err(1, NULL);
	cc = read(fd, cp, bs);
	if (cc == -1)
		error("read %s: %s", fname, pcap_strerror(errno));
	if (cc != bs)
		error("short read %s (%ld != %lu)", fname, (long)cc,
		    (unsigned long)bs);
	cp[bs] = '\0';
	close(fd);

	return (cp);
}

void
safeputs(const char *s)
{
	while (*s) {
		safeputchar(*s);
		s++;
	}
}

void
safeputchar(int c)
{
	unsigned char ch;

	ch = (unsigned char)(c & 0xff);
	if (c < 0x80 && isprint(c))
		printf("%c", c & 0xff);
	else
		printf("\\%03o", c & 0xff);
}

/*
 * Print a value a la the %b format of the kernel's printf
 * (from sbin/ifconfig/ifconfig.c)
 */
void
printb(char *s, unsigned short v, char *bits)
{
	int i, any = 0;
	char c;

	if (bits && *bits == 8)
		printf("%s=%o", s, v);
	else
		printf("%s=%x", s, v);

	if (bits) {
		bits++;
		putchar('<');
		while ((i = *bits++)) {
			if (v & (1 << (i-1))) {
				if (any)
					putchar(',');
				any = 1;
				for (; (c = *bits) > 32; bits++)
					putchar(c);
			} else
				for (; *bits > 32; bits++)
					;
		}
		putchar('>');
	}
}
@


1.26
log
@lint is dead: delete the trivial uses of /* VARARGS[0-9]+ */
(others require more care)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.25 2009/10/27 23:59:57 deraadt Exp $	*/
d54 1
a54 1
fn_print(register const u_char *s, register const u_char *ep)
d56 2
a57 2
	register int ret;
	register u_char c;
d86 1
a86 2
fn_printn(register const u_char *s, register u_int n,
	  register const u_char *ep)
d88 2
a89 2
	register int ret;
	register u_char c;
d116 1
a116 1
ts_print(register const struct bpf_timeval *tvp)
d118 1
a118 1
	register int s;
d189 1
a189 2
tok2str(register const struct tok *lp, register const char *fmt,
	register int v)
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.24 2008/09/19 08:52:16 mpf Exp $	*/
a206 1
/* VARARGS */
a220 1
/* VARARGS */
@


1.24
log
@Merge printb() fix from ifconfig.c -r 1.157:
Don't increment a pointer *before* testing it for NULL.
OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.23 2007/10/07 16:41:05 deraadt Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id: util.c,v 1.23 2007/10/07 16:41:05 deraadt Exp $ (LBL)";
#endif
@


1.23
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.22 2007/08/28 12:52:06 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Id$ (LBL)";
d340 1
a340 1
	bits++;
d342 1
@


1.22
log
@add -I option for printing the interfaces;
ok hshoexer, henning, mcbridge (some time ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.21 2006/04/22 17:24:33 moritz Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.21 2006/04/22 17:24:33 moritz Exp $ (LBL)";
@


1.21
log
@Remove remaining stuff from state QUIT, adjust some comments
and close a fd leak in read_infile(). ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.20 2006/03/13 19:05:56 moritz Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.20 2006/03/13 19:05:56 moritz Exp $ (LBL)";
d131 2
@


1.20
log
@Simplify error() and warning() a bit. From Alexey Dobriyan.
ok jaredy@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.19 2005/03/07 16:13:38 reyk Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.19 2005/03/07 16:13:38 reyk Exp $ (LBL)";
d298 1
@


1.19
log
@add a printer for 802.11 and for additional radiotap headers,
use -y IEEE802_11 or IEEE802_11_RADIO if supported by the driver.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.18 2004/07/28 09:37:26 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.18 2004/07/28 09:37:26 markus Exp $ (LBL)";
d220 1
a220 5
	if (*fmt) {
		fmt += strlen(fmt);
		if (fmt[-1] != '\n')
			(void)fputc('\n', stderr);
	}
d235 1
a235 5
	if (*fmt) {
		fmt += strlen(fmt);
		if (fmt[-1] != '\n')
			(void)fputc('\n', stderr);
	}
@


1.18
log
@add -ttttt (timestamp difference since the first packet); ok thierry
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.17 2004/06/23 06:12:07 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.17 2004/06/23 06:12:07 markus Exp $ (LBL)";
d329 32
@


1.17
log
@-tttt prints time between packets; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.16 2004/01/28 19:44:55 canacar Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.16 2004/01/28 19:44:55 canacar Exp $ (LBL)";
d145 2
a146 1
		/* time since last frame */
d150 2
a151 1
		last = *tvp;
@


1.16
log
@privilege separated tcpdump, joint work with otto@@

tested by avsm@@ vincent@@ dhartmei@@ markus@@ hshoexer@@ and others
go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.15 2002/02/19 19:39:40 millert Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.15 2002/02/19 19:39:40 millert Exp $ (LBL)";
d127 2
d143 7
@


1.15
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.14 2001/11/06 03:11:40 deraadt Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.14 2001/11/06 03:11:40 deraadt Exp $ (LBL)";
d32 1
d36 1
d52 1
a52 1

d139 1
a139 1
		strftime(buf, TSBUFLEN, "%b %d %T", localtime(&t));
d235 1
d240 1
a240 1
copy_argv(register char **argv)
d242 1
a242 2
	register char **p;
	register u_int len = 0;
a243 1
	char *src, *dst;
d245 2
a246 3
	p = argv;
	if (*p == 0)
		return 0;
d248 4
a251 2
	while (*p)
		len += strlen(*p++) + 1;
d253 1
a253 1
	buf = (char *)malloc(len);
d255 1
a255 1
		error("copy_argv: malloc");
d257 4
a260 6
	p = argv;
	dst = buf;
	while ((src = *p++) != NULL) {
		while ((*dst++ = *src++) != '\0')
			;
		dst[-1] = ' ';
d262 1
a262 3
	dst[-1] = '\0';

	return buf;
d268 5
a272 3
	register int fd, cc;
	register char *cp;
	struct stat buf;
d281 9
a289 3
	cp = malloc((u_int)buf.st_size + 1);
	cc = read(fd, cp, (int)buf.st_size);
	if (cc < 0)
d291 4
a294 3
	if (cc != buf.st_size)
		error("short read %s (%d != %d)", fname, cc, (int)buf.st_size);
	cp[(int)buf.st_size] = '\0';
@


1.14
log
@a bit of snprintf cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.13 2001/10/02 18:04:36 deraadt Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.13 2001/10/02 18:04:36 deraadt Exp $ (LBL)";
a40 1
#ifdef __STDC__
a41 3
#else
#include <varargs.h>
#endif
a198 1
#ifdef __STDC__
a199 5
#else
error(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif
a203 1
#ifdef __STDC__
a204 3
#else
	va_start(ap);
#endif
a217 1
#ifdef __STDC__
a218 5
#else
warning(fmt, va_alist)
	const char *fmt;
	va_dcl
#endif
a222 1
#ifdef __STDC__
a223 3
#else
	va_start(ap);
#endif
@


1.13
log
@change timeval to bpf_timeval; 32 bit in size, permitting much greater portability
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.12 2001/09/03 13:25:53 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.12 2001/09/03 13:25:53 jakob Exp $ (LBL)";
d137 1
a137 1
		(u_int32_t)tvp->tv_sec, (u_int32_t)tvp->tv_usec);
@


1.12
log
@print day and month using -ttt flag; <canacar@@eee.metu.edu.tr>
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.11 2001/03/05 22:34:01 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.11 2001/03/05 22:34:01 jakob Exp $ (LBL)";
d124 1
a124 1
ts_print(register const struct timeval *tvp)
@


1.11
log
@add relts_print, safeputs and safeputchar
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.10 2000/10/31 16:06:49 deraadt Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.10 2000/10/31 16:06:49 deraadt Exp $ (LBL)";
d127 18
a144 2

	if (tflag > 0) {
d149 1
a149 4
	} else if (tflag < 0) {
		/* Unix timeval style */
		(void)printf("%u.%06u ",
		    (u_int32_t)tvp->tv_sec, (u_int32_t)tvp->tv_usec);
@


1.10
log
@some buffer care; jakob
@
text
@d1 1
a1 1
/*	$OpenBSD: util.c,v 1.9 2000/10/03 14:31:59 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.9 2000/10/03 14:31:59 ho Exp $ (LBL)";
d141 27
d301 21
@


1.9
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.8 1999/09/16 20:58:48 brad Exp $ (LBL)";
d156 1
a156 1
	(void)sprintf(buf, fmt, v);
@


1.8
log
@bring more inline with tcpdump 3.4
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.7 1999/07/28 20:41:37 jakob Exp $ (LBL)";
@


1.7
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996
d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.6 1997/07/25 20:12:28 mickey Exp $ (LBL)";
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/util.c,v 1.5 1996/12/12 16:22:20 bitblt Exp $ (LBL)";
a248 25
/* A replacement for strdup() that cuts down on malloc() overhead */
char *
savestr(register const char *str)
{
	register u_int size;
	register char *p;
	static char *strptr = NULL;
	static u_int strsize = 0;

	size = strlen(str) + 1;
	if (size > strsize) {
		strsize = 1024;
		if (strsize < size)
			strsize = size;
		strptr = (char *)malloc(strsize);
		if (strptr == NULL)
			error("savestr: malloc");
	}
	(void)strcpy(strptr, str);
	p = strptr;
	strptr += size;
	strsize -= size;
	return (p);
}

a271 32
}

/*
 * Returns the difference between gmt and local time in seconds.
 * Use gmtime() and localtime() to keep things simple.
 */
int32_t
gmt2local(void)
{
	register int dt, dir;
	register struct tm *gmt, *loc;
	time_t t;
	struct tm sgmt;

	t = time(NULL);
	gmt = &sgmt;
	*gmt = *gmtime(&t);
	loc = localtime(&t);
	dt = (loc->tm_hour - gmt->tm_hour) * 60 * 60 +
	    (loc->tm_min - gmt->tm_min) * 60;

	/*
	 * If the year or julian day is different, we span 00:00 GMT
	 * and must add or subtract a day. Check the year first to
	 * avoid problems when the julian day wraps.
	 */
	dir = loc->tm_year - gmt->tm_year;
	if (dir == 0)
		dir = loc->tm_yday - gmt->tm_yday;
	dt += dir * 24 * 60 * 60;

	return (dt);
@


1.5
log
@*** empty log message ***
@
text
@d24 1
a24 1
    "@@(#) $Header: util.c,v 1.55 96/09/26 23:36:51 leres Exp $ (LBL)";
d39 1
a39 1
#if __STDC__
d161 1
a161 1
#if __STDC__
d172 1
a172 1
#if __STDC__
d190 1
a190 1
#if __STDC__
d201 1
a201 1
#if __STDC__
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d23 2
a24 2
static char rcsid[] =
    "@@(#) Header: util.c,v 1.48 96/06/23 02:26:42 leres Exp (LBL)";
d33 1
d37 1
a64 1
	putchar('"');
a81 1
	putchar('"');
a97 1
	putchar('"');
a114 1
	putchar('"');
d200 1
a200 1
	(void)fprintf(stderr, "%s: warning: ", program_name);
d222 1
a222 1
	register int len = 0;
a273 1

d277 2
a279 2
	int fd;
	char *p;
d283 1
a283 1
		error("can't open '%s'", fname);
d286 1
a286 1
		error("can't stat '%s'", fname);
d288 7
a294 5
	p = malloc((u_int)buf.st_size + 1);
	if (p == NULL)
		error("read_infile: malloc");
	if (read(fd, p, (int)buf.st_size) != buf.st_size)
		error("problem reading '%s'", fname);
d296 1
a296 3
	p[(int)buf.st_size] = '\0';

	return p;
d299 4
d304 1
a304 1
gmt2local()
d306 21
a326 33
	register int t;
#if !defined(HAVE_ALTZONE) && !defined(HAVE_TIMEZONE)
	struct timeval tv;
	struct timezone tz;
	register struct tm *tm;
#endif

	t = 0;
#if !defined(HAVE_ALTZONE) && !defined(HAVE_TIMEZONE)
	if (gettimeofday(&tv, &tz) < 0)
		error("gettimeofday");
	tm = localtime((time_t *)&tv.tv_sec);
#ifdef HAVE_TM_GMTOFF
	t = tm->tm_gmtoff;
#else
	t = tz.tz_minuteswest * -60;
	/* XXX Some systems need this, some auto offset tz_minuteswest... */
	if (tm->tm_isdst)
		t += 60 * 60;
#endif
#endif

#ifdef HAVE_TIMEZONE
	tzset();
	t = -timezone;
	if (daylight)
		t += 60 * 60;
#endif

#ifdef HAVE_ALTZONE
	tzset();
	t = -altzone;
#endif
d328 1
a328 1
	return (t);
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: util.c,v 1.5 1996/05/20 00:41:19 fvdl Exp $	*/
/*	$NetBSD: util.c,v 1.5 1996/05/20 00:41:19 fvdl Exp $	*/
d4 1
a4 1
 * Copyright (c) 1990, 1991, 1993, 1994
d26 1
a26 1
    "@@(#) Header: util.c,v 1.28+ 94/06/12 14:30:31 leres Exp (LBL)";
a28 1
#include <stdlib.h>
d35 1
a35 1
#ifdef SVR4
a37 3
#ifdef __STDC__
#include <stdlib.h>
#endif
d44 1
d46 3
a128 1
	extern int32 thiszone;
d133 2
a134 2
		(void)printf("%02d:%02d:%02d.%06d ",
		    s / 3600, (s % 3600) / 60, s % 60, tvp->tv_usec);
d137 2
a138 1
		(void)printf("%d.%06d ", tvp->tv_sec, tvp->tv_usec);
d146 1
a146 1
tok2str(register const struct token *lp, register const char *fmt,
a161 47
/* A replacement for strdup() that cuts down on malloc() overhead */
char *
savestr(register const char *str)
{
	register u_int size;
	register char *p;
	static char *strptr = NULL;
	static u_int strsize = 0;

	size = strlen(str) + 1;
	if (size > strsize) {
		strsize = 1024;
		if (strsize < size)
			strsize = size;
		strptr = (char *)malloc(strsize);
		if (strptr == NULL)
			error("savestr: malloc");
	}
	(void)strcpy(strptr, str);
	p = strptr;
	strptr += size;
	strsize -= size;
	return (p);
}

#ifdef NOVFPRINTF
/*
 * Stock 4.3 doesn't have vfprintf.
 * This routine is due to Chris Torek.
 */
vfprintf(f, fmt, args)
	FILE *f;
	char *fmt;
	va_list args;
{
	int ret;

	if ((f->_flag & _IOWRT) == 0) {
		if (f->_flag & _IORW)
			f->_flag |= _IOWRT;
		else
			return EOF;
	}
	ret = _doprnt(fmt, args, f);
	return ferror(f) ? EOF : ret;
}
#endif
d165 2
a166 2
#if __STDC__ || defined(SOLARIS)
error(char *fmt, ...)
d169 1
a169 1
	char *fmt;
d194 2
a195 2
#if __STDC__ || defined(SOLARIS)
warning(char *fmt, ...)
d198 1
a198 1
	char *fmt;
d238 2
d253 26
d291 1
a291 1
		error("can't state '%s'", fname);
d293 3
a295 1
	p = (char *)malloc((u_int)buf.st_size);
d299 2
d304 1
a304 1
int
d307 2
a308 1
#ifndef SVR4
d312 1
a312 1
	register int t;
d314 2
d319 1
a319 1
#ifndef SUNOS3
d323 1
d325 1
a325 1
		t += 3600;
d327 10
a336 2
	return (t);
#else
d338 1
a338 1
	return (-altzone);
d340 2
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: util.c,v 1.3 1995/03/06 19:11:53 mycroft Exp $	*/
d27 1
a27 1
    "@@(#) Header: util.c,v 1.28 94/06/12 14:30:31 leres Exp (LBL)";
d37 1
a37 1
#ifdef SOLARIS
d177 1
a177 1
		strptr = malloc(strsize);
d285 1
a285 1
	buf = malloc(len);
d313 1
a313 1
	p = malloc((u_int)buf.st_size);
d337 1
a337 1
		t += 60 * 60;
@


1.1
log
@Initial revision
@
text
@d1 1
d323 2
a324 2
#ifndef SOLARIS
	struct timeval now;
d326 2
a327 1
	long t;
d329 1
a329 1
	if (gettimeofday(&now, &tz) < 0)
d331 4
d336 3
a338 2
	if (localtime((time_t *)&now.tv_sec)->tm_isdst)
		t += 3600;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
