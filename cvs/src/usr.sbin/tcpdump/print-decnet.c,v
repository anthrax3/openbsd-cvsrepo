head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.10
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.8
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.6
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.22
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.20
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.24
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.22
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.20
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.18
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.16
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.14
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.12
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.10
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.8
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	enjTsnD5UO6xazKc;

1.16
date	2015.11.07.21.58.05;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	Nzm110Df4YkQU2bc;

1.15
date	2015.10.24.16.32.52;	author sthen;	state Exp;
branches;
next	1.14;
commitid	mtTYHvuWtTUvbCAV;

1.14
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	Zx2k82IzYwwZaEz9;

1.13
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	Uu5nFG3wCl0LACBb;

1.12
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.03.11.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.03.14.31.56;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	99.09.16.20.58.46;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.20.12.23;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.41;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.17;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.20;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@/*	$OpenBSD: print-decnet.c,v 1.16 2015/11/07 21:58:05 mmcc Exp $	*/

/*
 * Copyright (c) 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/time.h>
#include <sys/socket.h>

struct mbuf;
struct rtentry;
#include <net/if.h>

#ifdef	HAVE_LIBDNET
#include <netdnet/dnetdb.h>
#endif

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "decnet.h"
#include "extract.h"
#include "interface.h"
#include "addrtoname.h"

/* Forwards */
static int print_decnet_ctlmsg(const union routehdr *, u_int, u_int);
static void print_t_info(int);
static int print_l1_routes(const char *, u_int);
static int print_l2_routes(const char *, u_int);
static void print_i_info(int);
static int print_elist(const char *, u_int);
static int print_nsp(const u_char *, u_int);
static void print_reason(int);
#ifdef	PRINT_NSPDATA
static void pdata(u_char *, int);
#endif

#ifdef	HAVE_LIBDNET
extern char *dnet_htoa(struct dn_naddr *);
#endif

void
decnet_print(const u_char *ap, u_int length, u_int caplen)
{
	static union routehdr rhcopy;
	union routehdr *rhp = &rhcopy;
	int mflags;
	int dst, src, hops;
	u_int rhlen, nsplen, pktlen;
	const u_char *nspp;

	if (length < sizeof(struct shorthdr)) {
		(void)printf("[|decnet]");
		return;
	}

	TCHECK2(*ap, sizeof(short));
	pktlen = EXTRACT_LE_16BITS(ap);
	if (pktlen < sizeof(struct shorthdr)) {
		(void)printf("[|decnet]");
		return;
	}
	if (pktlen > length) {
		(void)printf("[|decnet]");
		return;
	}
	length = pktlen;

	rhlen = min(length, caplen);
	rhlen = min(rhlen, sizeof(*rhp));
	memcpy((char *)rhp, (char *)&(ap[sizeof(short)]), rhlen);

	TCHECK(rhp->rh_short.sh_flags);
	mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);

	if (mflags & RMF_PAD) {
	    /* pad bytes of some sort in front of message */
	    u_int padlen = mflags & RMF_PADMASK;
	    if (vflag)
		(void) printf("[pad:%d] ", padlen);
	    if (length < padlen + 2) {
		(void)printf("[|decnet]");
		return;
	    }
	    TCHECK2(ap[sizeof(short)], padlen);
	    ap += padlen;
	    length -= padlen;
	    caplen -= padlen;
	    rhlen = min(length, caplen);
	    rhlen = min(rhlen, sizeof(*rhp));
	    memcpy((char *)rhp, (char *)&(ap[sizeof(short)]), rhlen);
	    mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
	}

	if (mflags & RMF_FVER) {
		(void) printf("future-version-decnet");
		default_print(ap, min(length, caplen));
		return;
	}

	/* is it a control message? */
	if (mflags & RMF_CTLMSG) {
		if(!print_decnet_ctlmsg(rhp, length, caplen))
			goto trunc;
		return;
	}

	switch (mflags & RMF_MASK) {
	case RMF_LONG:
	    if (length < sizeof(struct longhdr)) {
		(void)printf("[|decnet]");
		return;
	    }
	    TCHECK(rhp->rh_long);
	    dst =
		EXTRACT_LE_16BITS(rhp->rh_long.lg_dst.dne_remote.dne_nodeaddr);
	    src =
		EXTRACT_LE_16BITS(rhp->rh_long.lg_src.dne_remote.dne_nodeaddr);
	    hops = EXTRACT_LE_8BITS(rhp->rh_long.lg_visits);
	    nspp = &(ap[sizeof(short) + sizeof(struct longhdr)]);
	    nsplen = length - sizeof(struct longhdr);
	    break;
	case RMF_SHORT:
	    TCHECK(rhp->rh_short);
	    dst = EXTRACT_LE_16BITS(rhp->rh_short.sh_dst);
	    src = EXTRACT_LE_16BITS(rhp->rh_short.sh_src);
	    hops = (EXTRACT_LE_8BITS(rhp->rh_short.sh_visits) & VIS_MASK)+1;
	    nspp = &(ap[sizeof(short) + sizeof(struct shorthdr)]);
	    nsplen = length - sizeof(struct shorthdr);
	    break;
	default:
	    (void) printf("unknown message flags under mask");
	    default_print((u_char *)ap, min(length, caplen));
	    return;
	}

	(void)printf("%s > %s %d ",
			dnaddr_string(src), dnaddr_string(dst), pktlen);
	if (vflag) {
	    if (mflags & RMF_RQR)
		(void)printf("RQR ");
	    if (mflags & RMF_RTS)
		(void)printf("RTS ");
	    if (mflags & RMF_IE)
		(void)printf("IE ");
	    (void)printf("%d hops ", hops);
	}

	if (!print_nsp(nspp, nsplen))
		goto trunc;
	return;

trunc:
	(void)printf("[|decnet]");
	return;
}

static int
print_decnet_ctlmsg(const union routehdr *rhp, u_int length,
    u_int caplen)
{
	int mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
	union controlmsg *cmp = (union controlmsg *)rhp;
	int src, dst, info, blksize, eco, ueco, hello, other, vers;
	etheraddr srcea, rtea;
	int priority;
	char *rhpx = (char *)rhp;
	int ret;

	switch (mflags & RMF_CTLMASK) {
	case RMF_INIT:
	    (void)printf("init ");
	    if (length < sizeof(struct initmsg))
		goto trunc;
	    TCHECK(cmp->cm_init);
	    src = EXTRACT_LE_16BITS(cmp->cm_init.in_src);
	    info = EXTRACT_LE_8BITS(cmp->cm_init.in_info);
	    blksize = EXTRACT_LE_16BITS(cmp->cm_init.in_blksize);
	    vers = EXTRACT_LE_8BITS(cmp->cm_init.in_vers);
	    eco = EXTRACT_LE_8BITS(cmp->cm_init.in_eco);
	    ueco = EXTRACT_LE_8BITS(cmp->cm_init.in_ueco);
	    hello = EXTRACT_LE_16BITS(cmp->cm_init.in_hello);
	    print_t_info(info);
	    (void)printf(
		"src %sblksize %d vers %d eco %d ueco %d hello %d",
			dnaddr_string(src), blksize, vers, eco, ueco,
			hello);

	    ret = 1;
	    break;
	case RMF_VER:
	    (void)printf("verification ");
	    if (length < sizeof(struct verifmsg))
		goto trunc;
	    TCHECK(cmp->cm_ver);
	    src = EXTRACT_LE_16BITS(cmp->cm_ver.ve_src);
	    other = EXTRACT_LE_8BITS(cmp->cm_ver.ve_fcnval);
	    (void)printf("src %s fcnval %o", dnaddr_string(src), other);
	    ret = 1;
	    break;
	case RMF_TEST:
	    (void)printf("test ");
	    if (length < sizeof(struct testmsg))
		goto trunc;
	    TCHECK(cmp->cm_test);
	    src = EXTRACT_LE_16BITS(cmp->cm_test.te_src);
	    other = EXTRACT_LE_8BITS(cmp->cm_test.te_data);
	    (void)printf("src %s data %o", dnaddr_string(src), other);
	    ret = 1;
	    break;
	case RMF_L1ROUT:
	    (void)printf("lev-1-routing ");
	    if (length < sizeof(struct l1rout))
		goto trunc;
	    TCHECK(cmp->cm_l1rou);
	    src = EXTRACT_LE_16BITS(cmp->cm_l1rou.r1_src);
	    (void)printf("src %s ", dnaddr_string(src));
	    ret = print_l1_routes(&(rhpx[sizeof(struct l1rout)]),
				length - sizeof(struct l1rout));
	    break;
	case RMF_L2ROUT:
	    (void)printf("lev-2-routing ");
	    if (length < sizeof(struct l2rout))
		goto trunc;
	    TCHECK(cmp->cm_l2rout);
	    src = EXTRACT_LE_16BITS(cmp->cm_l2rout.r2_src);
	    (void)printf("src %s ", dnaddr_string(src));
	    ret = print_l2_routes(&(rhpx[sizeof(struct l2rout)]),
				length - sizeof(struct l2rout));
	    break;
	case RMF_RHELLO:
	    (void)printf("router-hello ");
	    if (length < sizeof(struct rhellomsg))
		goto trunc;
	    TCHECK(cmp->cm_rhello);
	    vers = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_vers);
	    eco = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_eco);
	    ueco = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_ueco);
	    memcpy((char *)&srcea, (char *)&(cmp->cm_rhello.rh_src),
		sizeof(srcea));
	    src = EXTRACT_LE_16BITS(srcea.dne_remote.dne_nodeaddr);
	    info = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_info);
	    blksize = EXTRACT_LE_16BITS(cmp->cm_rhello.rh_blksize);
	    priority = EXTRACT_LE_8BITS(cmp->cm_rhello.rh_priority);
	    hello = EXTRACT_LE_16BITS(cmp->cm_rhello.rh_hello);
	    print_i_info(info);
	    (void)printf(
	    "vers %d eco %d ueco %d src %s blksize %d pri %d hello %d",
			vers, eco, ueco, dnaddr_string(src),
			blksize, priority, hello);
	    ret = print_elist(&(rhpx[sizeof(struct rhellomsg)]),
				length - sizeof(struct rhellomsg));
	    break;
	case RMF_EHELLO:
	    (void)printf("endnode-hello ");
	    if (length < sizeof(struct ehellomsg))
		goto trunc;
	    TCHECK(cmp->cm_ehello);
	    vers = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_vers);
	    eco = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_eco);
	    ueco = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_ueco);
	    memcpy((char *)&srcea, (char *)&(cmp->cm_ehello.eh_src),
		sizeof(srcea));
	    src = EXTRACT_LE_16BITS(srcea.dne_remote.dne_nodeaddr);
	    info = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_info);
	    blksize = EXTRACT_LE_16BITS(cmp->cm_ehello.eh_blksize);
	    /*seed*/
	    memcpy((char *)&rtea, (char *)&(cmp->cm_ehello.eh_router),
		sizeof(rtea));
	    dst = EXTRACT_LE_16BITS(rtea.dne_remote.dne_nodeaddr);
	    hello = EXTRACT_LE_16BITS(cmp->cm_ehello.eh_hello);
	    other = EXTRACT_LE_8BITS(cmp->cm_ehello.eh_data);
	    print_i_info(info);
	    (void)printf(
	"vers %d eco %d ueco %d src %s blksize %d rtr %s hello %d data %o",
			vers, eco, ueco, dnaddr_string(src),
			blksize, dnaddr_string(dst), hello, other);
	    ret = 1;
	    break;

	default:
	    (void)printf("unknown control message");
	    default_print((u_char *)rhp, min(length, caplen));
	    ret = 1;
	    break;
	}
	return (ret);

trunc:
	return (0);
}

static void
print_t_info(int info)
{
	int ntype = info & 3;
	switch (ntype) {
	case 0: (void)printf("reserved-ntype? "); break;
	case TI_L2ROUT: (void)printf("l2rout "); break;
	case TI_L1ROUT: (void)printf("l1rout "); break;
	case TI_ENDNODE: (void)printf("endnode "); break;
	}
	if (info & TI_VERIF)
	    (void)printf("verif ");
	if (info & TI_BLOCK)
	    (void)printf("blo ");
}

static int
print_l1_routes(const char *rp, u_int len)
{
	int count;
	int id;
	int info;

	/* The last short is a checksum */
	while (len > (3 * sizeof(short))) {
	    TCHECK2(*rp, 3 * sizeof(short));
	    count = EXTRACT_LE_16BITS(rp);
	    if (count > 1024)
		return (1);	/* seems to be bogus from here on */
	    rp += sizeof(short);
	    len -= sizeof(short);
	    id = EXTRACT_LE_16BITS(rp);
	    rp += sizeof(short);
	    len -= sizeof(short);
	    info = EXTRACT_LE_16BITS(rp);
	    rp += sizeof(short);
	    len -= sizeof(short);
	    (void)printf("{ids %d-%d cost %d hops %d} ", id, id + count,
			    RI_COST(info), RI_HOPS(info));
	}
	return (1);

trunc:
	return (0);
}

static int
print_l2_routes(const char *rp, u_int len)
{
	int count;
	int area;
	int info;

	/* The last short is a checksum */
	while (len > (3 * sizeof(short))) {
	    TCHECK2(*rp, 3 * sizeof(short));
	    count = EXTRACT_LE_16BITS(rp);
	    if (count > 1024)
		return (1);	/* seems to be bogus from here on */
	    rp += sizeof(short);
	    len -= sizeof(short);
	    area = EXTRACT_LE_16BITS(rp);
	    rp += sizeof(short);
	    len -= sizeof(short);
	    info = EXTRACT_LE_16BITS(rp);
	    rp += sizeof(short);
	    len -= sizeof(short);
	    (void)printf("{areas %d-%d cost %d hops %d} ", area, area + count,
			    RI_COST(info), RI_HOPS(info));
	}
	return (1);

trunc:
	return (0);
}

static void
print_i_info(int info)
{
	int ntype = info & II_TYPEMASK;
	switch (ntype) {
	case 0: (void)printf("reserved-ntype? "); break;
	case II_L2ROUT: (void)printf("l2rout "); break;
	case II_L1ROUT: (void)printf("l1rout "); break;
	case II_ENDNODE: (void)printf("endnode "); break;
	}
	if (info & II_VERIF)
	    (void)printf("verif ");
	if (info & II_NOMCAST)
	    (void)printf("nomcast ");
	if (info & II_BLOCK)
	    (void)printf("blo ");
}

static int
print_elist(const char *elp, u_int len)
{
	/* Not enough examples available for me to debug this */
	return (1);
}

static int
print_nsp(const u_char *nspp, u_int nsplen)
{
	const struct nsphdr *nsphp = (struct nsphdr *)nspp;
	int dst, src, flags;

	if (nsplen < sizeof(struct nsphdr))
		goto trunc;
	TCHECK(*nsphp);
	flags = EXTRACT_LE_8BITS(nsphp->nh_flags);
	dst = EXTRACT_LE_16BITS(nsphp->nh_dst);
	src = EXTRACT_LE_16BITS(nsphp->nh_src);

	switch (flags & NSP_TYPEMASK) {
	case MFT_DATA:
	    switch (flags & NSP_SUBMASK) {
	    case MFS_BOM:
	    case MFS_MOM:
	    case MFS_EOM:
	    case MFS_BOM+MFS_EOM:
		printf("data %d>%d ", src, dst);
		{
		    struct seghdr *shp = (struct seghdr *)nspp;
		    int ack;
#ifdef	PRINT_NSPDATA
		    u_char *dp;
#endif
		    u_int data_off = sizeof(struct minseghdr);

		    if (nsplen < data_off)
			goto trunc;
		    TCHECK(shp->sh_seq[0]);
		    ack = EXTRACT_LE_16BITS(shp->sh_seq[0]);
		    if (ack & SGQ_ACK) {	/* acknum field */
			if ((ack & SGQ_NAK) == SGQ_NAK)
			    (void)printf("nak %d ", ack & SGQ_MASK);
			else
			    (void)printf("ack %d ", ack & SGQ_MASK);
		        data_off += sizeof(short);
			if (nsplen < data_off)
			    goto trunc;
			TCHECK(shp->sh_seq[1]);
			ack = EXTRACT_LE_16BITS(shp->sh_seq[1]);
			if (ack & SGQ_OACK) {	/* ackoth field */
			    if ((ack & SGQ_ONAK) == SGQ_ONAK)
				(void)printf("onak %d ", ack & SGQ_MASK);
			    else
				(void)printf("oack %d ", ack & SGQ_MASK);
			    data_off += sizeof(short);
			    if (nsplen < data_off)
				goto trunc;
			    TCHECK(shp->sh_seq[2]);
			    ack = EXTRACT_LE_16BITS(shp->sh_seq[2]);
			}
		    }
		    (void)printf("seg %d ", ack & SGQ_MASK);
#ifdef	PRINT_NSPDATA
		    if (nsplen > data_off) {
			dp = &(nspp[data_off]);
			TCHECK2(*dp, nsplen - data_off);
			pdata(dp, nsplen - data_off);
		    }
#endif
		}
		break;
	    case MFS_ILS+MFS_INT:
		printf("intr ");
		{
		    struct seghdr *shp = (struct seghdr *)nspp;
		    int ack;
#ifdef	PRINT_NSPDATA
		    u_char *dp;
#endif
		    u_int data_off = sizeof(struct minseghdr);

		    if (nsplen < data_off)
			goto trunc;
		    TCHECK(shp->sh_seq[0]);
		    ack = EXTRACT_LE_16BITS(shp->sh_seq[0]);
		    if (ack & SGQ_ACK) {	/* acknum field */
			if ((ack & SGQ_NAK) == SGQ_NAK)
			    (void)printf("nak %d ", ack & SGQ_MASK);
			else
			    (void)printf("ack %d ", ack & SGQ_MASK);
		        data_off += sizeof(short);
			if (nsplen < data_off)
			    goto trunc;
			TCHECK(shp->sh_seq[1]);
			ack = EXTRACT_LE_16BITS(shp->sh_seq[1]);
			if (ack & SGQ_OACK) {	/* ackdat field */
			    if ((ack & SGQ_ONAK) == SGQ_ONAK)
				(void)printf("nakdat %d ", ack & SGQ_MASK);
			    else
				(void)printf("ackdat %d ", ack & SGQ_MASK);
			    data_off += sizeof(short);
			    if (nsplen < data_off)
				goto trunc;
			    TCHECK(shp->sh_seq[2]);
			    ack = EXTRACT_LE_16BITS(shp->sh_seq[2]);
			}
		    }
		    (void)printf("seg %d ", ack & SGQ_MASK);
#ifdef	PRINT_NSPDATA
		    if (nsplen > data_off) {
			dp = &(nspp[data_off]);
			TCHECK2(*dp, nsplen - data_off);
			pdata(dp, nsplen - data_off);
		    }
#endif
		}
		break;
	    case MFS_ILS:
		(void)printf("link-service %d>%d ", src, dst);
		{
		    struct seghdr *shp = (struct seghdr *)nspp;
		    struct lsmsg *lsmp =
			(struct lsmsg *)&(nspp[sizeof(struct seghdr)]);
		    int ack;
		    int lsflags, fcval;

		    if (nsplen < sizeof(struct seghdr) + sizeof(struct lsmsg))
			goto trunc;
		    TCHECK(shp->sh_seq[0]);
		    ack = EXTRACT_LE_16BITS(shp->sh_seq[0]);
		    if (ack & SGQ_ACK) {	/* acknum field */
			if ((ack & SGQ_NAK) == SGQ_NAK)
			    (void)printf("nak %d ", ack & SGQ_MASK);
			else
			    (void)printf("ack %d ", ack & SGQ_MASK);
			TCHECK(shp->sh_seq[1]);
		        ack = EXTRACT_LE_16BITS(shp->sh_seq[1]);
			if (ack & SGQ_OACK) {	/* ackdat field */
			    if ((ack & SGQ_ONAK) == SGQ_ONAK)
				(void)printf("nakdat %d ", ack & SGQ_MASK);
			    else
				(void)printf("ackdat %d ", ack & SGQ_MASK);
			    TCHECK(shp->sh_seq[2]);
			    ack = EXTRACT_LE_16BITS(shp->sh_seq[2]);
			}
		    }
		    (void)printf("seg %d ", ack & SGQ_MASK);
		    TCHECK(*lsmp);
		    lsflags = EXTRACT_LE_8BITS(lsmp->ls_lsflags);
		    fcval = EXTRACT_LE_8BITS(lsmp->ls_fcval);
		    switch (lsflags & LSI_MASK) {
		    case LSI_DATA:
			(void)printf("dat seg count %d ", fcval);
			switch (lsflags & LSM_MASK) {
			case LSM_NOCHANGE:
			    break;
			case LSM_DONOTSEND:
			    (void)printf("donotsend-data ");
			    break;
			case LSM_SEND:
			    (void)printf("send-data ");
			    break;
			default:
			    (void)printf("reserved-fcmod? %x", lsflags);
			    break;
			}
			break;
		    case LSI_INTR:
			(void)printf("intr req count %d ", fcval);
			break;
		    default:
			(void)printf("reserved-fcval-int? %x", lsflags);
			break;
		    }
		}
		break;
	    default:
		(void)printf("reserved-subtype? %x %d > %d", flags, src, dst);
		break;
	    }
	    break;
	case MFT_ACK:
	    switch (flags & NSP_SUBMASK) {
	    case MFS_DACK:
		(void)printf("data-ack %d>%d ", src, dst);
		{
		    struct ackmsg *amp = (struct ackmsg *)nspp;
		    int ack;

		    if (nsplen < sizeof(struct ackmsg))
			goto trunc;
		    TCHECK(*amp);
		    ack = EXTRACT_LE_16BITS(amp->ak_acknum[0]);
		    if (ack & SGQ_ACK) {	/* acknum field */
			if ((ack & SGQ_NAK) == SGQ_NAK)
			    (void)printf("nak %d ", ack & SGQ_MASK);
			else
			    (void)printf("ack %d ", ack & SGQ_MASK);
		        ack = EXTRACT_LE_16BITS(amp->ak_acknum[1]);
			if (ack & SGQ_OACK) {	/* ackoth field */
			    if ((ack & SGQ_ONAK) == SGQ_ONAK)
				(void)printf("onak %d ", ack & SGQ_MASK);
			    else
				(void)printf("oack %d ", ack & SGQ_MASK);
			}
		    }
		}
		break;
	    case MFS_IACK:
		(void)printf("ils-ack %d>%d ", src, dst);
		{
		    struct ackmsg *amp = (struct ackmsg *)nspp;
		    int ack;

		    if (nsplen < sizeof(struct ackmsg))
			goto trunc;
		    TCHECK(*amp);
		    ack = EXTRACT_LE_16BITS(amp->ak_acknum[0]);
		    if (ack & SGQ_ACK) {	/* acknum field */
			if ((ack & SGQ_NAK) == SGQ_NAK)
			    (void)printf("nak %d ", ack & SGQ_MASK);
			else
			    (void)printf("ack %d ", ack & SGQ_MASK);
		        TCHECK(amp->ak_acknum[1]);
			ack = EXTRACT_LE_16BITS(amp->ak_acknum[1]);
			if (ack & SGQ_OACK) {	/* ackdat field */
			    if ((ack & SGQ_ONAK) == SGQ_ONAK)
				(void)printf("nakdat %d ", ack & SGQ_MASK);
			    else
				(void)printf("ackdat %d ", ack & SGQ_MASK);
			}
		    }
		}
		break;
	    case MFS_CACK:
		(void)printf("conn-ack %d", dst);
		break;
	    default:
		(void)printf("reserved-acktype? %x %d > %d", flags, src, dst);
		break;
	    }
	    break;
	case MFT_CTL:
	    switch (flags & NSP_SUBMASK) {
	    case MFS_CI:
	    case MFS_RCI:
		if ((flags & NSP_SUBMASK) == MFS_CI)
		    (void)printf("conn-initiate ");
		else
		    (void)printf("retrans-conn-initiate ");
		(void)printf("%d>%d ", src, dst);
		{
		    struct cimsg *cimp = (struct cimsg *)nspp;
		    int services, info, segsize;
#ifdef	PRINT_NSPDATA
		    u_char *dp;
#endif

		    if (nsplen < sizeof(struct cimsg))
			goto trunc;
		    TCHECK(*cimp);
		    services = EXTRACT_LE_8BITS(cimp->ci_services);
		    info = EXTRACT_LE_8BITS(cimp->ci_info);
		    segsize = EXTRACT_LE_16BITS(cimp->ci_segsize);

		    switch (services & COS_MASK) {
		    case COS_NONE:
			break;
		    case COS_SEGMENT:
			(void)printf("seg ");
			break;
		    case COS_MESSAGE:
			(void)printf("msg ");
			break;
		    case COS_CRYPTSER:
			(void)printf("crypt ");
			break;
		    }
		    switch (info & COI_MASK) {
		    case COI_32:
			(void)printf("ver 3.2 ");
			break;
		    case COI_31:
			(void)printf("ver 3.1 ");
			break;
		    case COI_40:
			(void)printf("ver 4.0 ");
			break;
		    case COI_41:
			(void)printf("ver 4.1 ");
			break;
		    }
		    (void)printf("segsize %d ", segsize);
#ifdef	PRINT_NSPDATA
		    if (nsplen > sizeof(struct cimsg)) {
			dp = &(nspp[sizeof(struct cimsg)]);
			TCHECK2(*dp, nsplen - sizeof(struct cimsg));
			pdata(dp, nsplen - sizeof(struct cimsg));
		    }
#endif
		}
		break;
	    case MFS_CC:
		(void)printf("conn-confirm %d>%d ", src, dst);
		{
		    struct ccmsg *ccmp = (struct ccmsg *)nspp;
		    int services, info;
		    u_int segsize, optlen;
#ifdef	PRINT_NSPDATA
		    u_char *dp;
#endif

		    if (nsplen < sizeof(struct ccmsg))
			goto trunc;
		    TCHECK(*ccmp);
		    services = EXTRACT_LE_8BITS(ccmp->cc_services);
		    info = EXTRACT_LE_8BITS(ccmp->cc_info);
		    segsize = EXTRACT_LE_16BITS(ccmp->cc_segsize);
		    optlen = EXTRACT_LE_8BITS(ccmp->cc_optlen);

		    switch (services & COS_MASK) {
		    case COS_NONE:
			break;
		    case COS_SEGMENT:
			(void)printf("seg ");
			break;
		    case COS_MESSAGE:
			(void)printf("msg ");
			break;
		    case COS_CRYPTSER:
			(void)printf("crypt ");
			break;
		    }
		    switch (info & COI_MASK) {
		    case COI_32:
			(void)printf("ver 3.2 ");
			break;
		    case COI_31:
			(void)printf("ver 3.1 ");
			break;
		    case COI_40:
			(void)printf("ver 4.0 ");
			break;
		    case COI_41:
			(void)printf("ver 4.1 ");
			break;
		    }
		    (void)printf("segsize %d ", segsize);
		    if (optlen) {
			(void)printf("optlen %d ", optlen);
#ifdef	PRINT_NSPDATA
			if (optlen > nsplen - sizeof(struct ccmsg))
			    goto trunc;
			dp = &(nspp[sizeof(struct ccmsg)]);
			TCHECK2(*dp, optlen);
			pdata(dp, optlen);
#endif
		    }
		}
		break;
	    case MFS_DI:
		(void)printf("disconn-initiate %d>%d ", src, dst);
		{
		    struct dimsg *dimp = (struct dimsg *)nspp;
		    int reason;
		    u_int optlen;
#ifdef	PRINT_NSPDATA
		    u_char *dp;
#endif

		    if (nsplen < sizeof(struct dimsg))
			goto trunc;
		    TCHECK(*dimp);
		    reason = EXTRACT_LE_16BITS(dimp->di_reason);
		    optlen = EXTRACT_LE_8BITS(dimp->di_optlen);

		    print_reason(reason);
		    if (optlen) {
			(void)printf("optlen %d ", optlen);
#ifdef	PRINT_NSPDATA
			if (optlen > nsplen - sizeof(struct dimsg))
			    goto trunc;
			dp = &(nspp[sizeof(struct dimsg)]);
			TCHECK2(*dp, optlen);
			pdata(dp, optlen);
#endif
		    }
		}
		break;
	    case MFS_DC:
		(void)printf("disconn-confirm %d>%d ", src, dst);
		{
		    struct dcmsg *dcmp = (struct dcmsg *)nspp;
		    int reason;

		    TCHECK(*dcmp);
		    reason = EXTRACT_LE_16BITS(dcmp->dc_reason);

		    print_reason(reason);
		}
		break;
	    default:
		(void)printf("reserved-ctltype? %x %d > %d", flags, src, dst);
		break;
	    }
	    break;
	default:
	    (void)printf("reserved-type? %x %d > %d", flags, src, dst);
	    break;
	}
	return (1);

trunc:
	return (0);
}

static struct tok reason2str[] = {
	{ UC_OBJREJECT,		"object rejected connect" },
	{ UC_RESOURCES,		"insufficient resources" },
	{ UC_NOSUCHNODE,	"unrecognized node name" },
	{ DI_SHUT,		"node is shutting down" },
	{ UC_NOSUCHOBJ,		"unrecognized object" },
	{ UC_INVOBJFORMAT,	"invalid object name format" },
	{ UC_OBJTOOBUSY,	"object too busy" },
	{ DI_PROTOCOL,		"protocol error discovered" },
	{ DI_TPA,		"third party abort" },
	{ UC_USERABORT,		"user abort" },
	{ UC_INVNODEFORMAT,	"invalid node name format" },
	{ UC_LOCALSHUT,		"local node shutting down" },
	{ DI_LOCALRESRC,	"insufficient local resources" },
	{ DI_REMUSERRESRC,	"insufficient remote user resources" },
	{ UC_ACCESSREJECT,	"invalid access control information" },
	{ DI_BADACCNT,		"bad ACCOUNT information" },
	{ UC_NORESPONSE,	"no response from object" },
	{ UC_UNREACHABLE,	"node unreachable" },
	{ DC_NOLINK,		"no link terminate" },
	{ DC_COMPLETE,		"disconnect complete" },
	{ DI_BADIMAGE,		"bad image data in connect" },
	{ DI_SERVMISMATCH,	"cryptographic service mismatch" },
	{ 0,			NULL }
};

static void
print_reason(int reason)
{
	printf("%s ", tok2str(reason2str, "reason-%d", reason));
}

char *
dnnum_string(u_short dnaddr)
{
	char *str;
	int area = (u_short)(dnaddr & AREAMASK) >> AREASHIFT;
	int node = dnaddr & NODEMASK;
	int len = sizeof("00.0000");

	str = malloc(len);
	if (str == NULL)
		error("dnnum_string: malloc");
	snprintf(str, len, "%d.%d", area, node);
	return(str);
}

char *
dnname_string(u_short dnaddr)
{
#ifdef	HAVE_LIBDNET
	struct dn_naddr dna;

	dna.a_len = sizeof(short);
	memcpy((char *)dna.a_addr, (char *)&dnaddr, sizeof(short));
	return (savestr(dnet_htoa(&dna)));
#else
	return(dnnum_string(dnaddr));	/* punt */
#endif
}

#ifdef	PRINT_NSPDATA
static void
pdata(u_char *dp, u_int maxlen)
{
	int c;
	u_int x = maxlen;

	while (x-- > 0) {
	    c = (unsigned char)*dp++;
	    if (isprint(c))
		putchar(c);
	    else
		printf("\\%o", c & 0xFF);
	}
}
#endif
@


1.16
log
@Ensure the safety of isprint()'s argument. Suggested by guenther@@ a few
weeks ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-decnet.c,v 1.15 2015/10/24 16:32:52 sthen Exp $	*/
d64 1
a64 2
decnet_print(register const u_char *ap, register u_int length,
	     register u_int caplen)
d67 2
a68 2
	register union routehdr *rhp = &rhcopy;
	register int mflags;
d180 1
a180 1
print_decnet_ctlmsg(register const union routehdr *rhp, u_int length,
d184 1
a184 1
	register union controlmsg *cmp = (union controlmsg *)rhp;
d852 1
a852 1
print_reason(register int reason)
@


1.15
log
@Carry out additional length/size checks in DECnet packet printing, avoiding a
segfault with malformed packets. Adapted from f61639179282 in tcpdump.org git
by Kevin Reay, but not including the header no-copy optimization that was in
the upstream patch.  ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-decnet.c,v 1.14 2015/08/21 02:07:32 deraadt Exp $	*/
d891 1
a891 1
	char c;
d895 1
a895 1
	    c = *dp++;
@


1.14
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: print-decnet.c,v 1.13 2015/01/16 06:40:21 deraadt Exp $	*/
d47 1
a47 1
static void print_decnet_ctlmsg(const union routehdr *, u_int);
d49 2
a50 2
static void print_l1_routes(const char *, u_int);
static void print_l2_routes(const char *, u_int);
d52 2
a53 2
static void print_elist(const char *, u_int);
static void print_nsp(const u_char *, u_int);
d79 1
d81 9
d95 1
d103 5
d119 1
a119 1
		default_print(ap, length);
d125 2
a126 1
		print_decnet_ctlmsg(rhp, min(length, caplen));
d132 5
d143 1
a143 2
	    nsplen = min((length - sizeof(struct longhdr)),
			 (caplen - sizeof(struct longhdr)));
d146 1
d151 1
a151 2
	    nsplen = min((length - sizeof(struct shorthdr)),
			 (caplen - sizeof(struct shorthdr)));
d155 1
a155 1
	    default_print((u_char *)ap, length);
d171 7
a177 1
	print_nsp(nspp, nsplen);
d180 3
a182 2
static void
print_decnet_ctlmsg(register const union routehdr *rhp, u_int length)
d190 1
d195 3
d210 2
d215 3
d221 1
d225 3
d231 1
d235 3
d240 1
a240 1
	    print_l1_routes(&(rhpx[sizeof(struct l1rout)]),
d245 3
d250 1
a250 1
	    print_l2_routes(&(rhpx[sizeof(struct l2rout)]),
d255 3
d273 1
a273 1
	    print_elist(&(rhpx[sizeof(struct rhellomsg)]),
d278 3
d300 1
d305 2
a306 1
	    default_print((u_char *)rhp, length);
d309 4
d331 1
a331 1
static void
d340 1
d343 1
a343 1
		return;	/* seems to be bogus from here on */
d355 4
d361 1
a361 1
static void
d370 1
d373 1
a373 1
		return;	/* seems to be bogus from here on */
d385 4
d409 1
a409 1
static void
d413 1
d416 1
a416 1
static void
d422 3
d445 3
d454 5
a458 2
		        ack = EXTRACT_LE_16BITS(shp->sh_seq[1]);
			data_off += sizeof(short);
d464 4
a468 1
			    data_off += sizeof(short);
d473 5
a477 2
		    dp = &(nspp[data_off]);
		    pdata(dp, 10);
d491 3
d500 5
a504 2
		        ack = EXTRACT_LE_16BITS(shp->sh_seq[1]);
			data_off += sizeof(short);
d510 4
a514 1
			    data_off += sizeof(short);
d519 5
a523 2
		    dp = &(nspp[data_off]);
		    pdata(dp, 10);
d536 3
d545 1
d552 1
d557 1
d599 3
d624 3
d633 2
a634 1
		        ack = EXTRACT_LE_16BITS(amp->ak_acknum[1]);
d668 3
d704 5
a708 2
		    dp = &(nspp[sizeof(struct cimsg)]);
		    pdata(dp, nsplen - sizeof(struct cimsg));
d722 3
d761 2
a762 1
			optlen = min(optlen, nsplen - sizeof(struct ccmsg));
d764 1
d780 3
d790 2
a791 1
			optlen = min(optlen, nsplen - sizeof(struct dimsg));
d793 1
d805 1
d820 4
@


1.13
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-decnet.c,v 1.12 2009/10/27 23:59:55 deraadt Exp $	*/
d734 1
a734 1
	str = (char *)malloc(len);
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-decnet.c,v 1.11 2007/10/07 16:41:05 deraadt Exp $	*/
a23 1
#include <sys/param.h>
@


1.11
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-decnet.c,v 1.10 2002/02/19 19:39:40 millert Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.10
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-decnet.c,v 1.9 2001/11/06 03:11:40 deraadt Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-decnet.c,v 1.9 2001/11/06 03:11:40 deraadt Exp $ (LBL)";
@


1.9
log
@a bit of snprintf cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: print-decnet.c,v 1.8 2000/10/03 14:31:56 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-decnet.c,v 1.8 2000/10/03 14:31:56 ho Exp $ (LBL)";
a32 1
#ifdef __STDC__
a34 1
#endif
@


1.8
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-decnet.c,v 1.7 1999/09/16 20:58:46 brad Exp $ (LBL)";
d740 1
d742 1
a742 1
	str = (char *)malloc(sizeof("00.0000"));
d745 1
a745 1
	sprintf(str, "%d.%d", area, node);
@


1.7
log
@bring more inline with tcpdump 3.4
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-decnet.c,v 1.6 1997/07/25 20:12:23 mickey Exp $ (LBL)";
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d2 1
a2 1
 * Copyright (c) 1992, 1993, 1994, 1995, 1996
d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-decnet.c,v 1.5 1996/12/12 16:22:41 bitblt Exp $ (LBL)";
@


1.5
log
@*** empty log message ***
@
text
@d24 1
a24 1
    "@@(#) $Header: print-decnet.c,v 1.24 96/11/05 13:30:38 leres Exp $ (LBL)";
d31 1
a31 1
#if __STDC__
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1992, 1993, 1994, 1995
d23 2
a24 2
static char rcsid[] =
    "@@(#) Header: print-decnet.c,v 1.19 95/10/07 22:15:12 leres Exp (LBL)";
d27 1
a27 1
#include <sys/types.h>
d48 1
d53 1
a53 1
static void print_decnet_ctlmsg(const union routehdr *, int);
d55 2
a56 2
static void print_l1_routes(const char *, int);
static void print_l2_routes(const char *, int);
d58 2
a59 2
static void print_elist(const char *, int);
static void print_nsp(const u_char *, int);
d70 2
a71 2
decnet_print(register const u_char *ap, register int length,
	     register int caplen)
d77 1
a77 1
	int rhlen;
a78 2
	int nsplen;
	int pktlen;
d85 1
a85 1
	pktlen = EXTRACT_16BITS(ap);
d91 1
a91 1
	mflags = EXTRACT_8BITS(rhp->rh_short.sh_flags);
d95 1
a95 1
	    int padlen = mflags & RMF_PADMASK;
d104 1
a104 1
	    mflags = EXTRACT_8BITS(rhp->rh_short.sh_flags);
d121 5
a125 3
	    dst = EXTRACT_16BITS(rhp->rh_long.lg_dst.dne_remote.dne_nodeaddr);
	    src = EXTRACT_16BITS(rhp->rh_long.lg_src.dne_remote.dne_nodeaddr);
	    hops = EXTRACT_8BITS(rhp->rh_long.lg_visits);
d131 3
a133 3
	    dst = EXTRACT_16BITS(rhp->rh_short.sh_dst);
	    src = EXTRACT_16BITS(rhp->rh_short.sh_src);
	    hops = (EXTRACT_8BITS(rhp->rh_short.sh_visits) & VIS_MASK)+1;
d160 1
a160 1
print_decnet_ctlmsg(register const union routehdr *rhp, int length)
d162 1
a162 1
	int mflags = EXTRACT_8BITS(rhp->rh_short.sh_flags);
d172 7
a178 7
	    src = EXTRACT_16BITS(cmp->cm_init.in_src);
	    info = EXTRACT_8BITS(cmp->cm_init.in_info);
	    blksize = EXTRACT_16BITS(cmp->cm_init.in_blksize);
	    vers = EXTRACT_8BITS(cmp->cm_init.in_vers);
	    eco = EXTRACT_8BITS(cmp->cm_init.in_eco);
	    ueco = EXTRACT_8BITS(cmp->cm_init.in_ueco);
	    hello = EXTRACT_16BITS(cmp->cm_init.in_hello);
d187 2
a188 2
	    src = EXTRACT_16BITS(cmp->cm_ver.ve_src);
	    other = EXTRACT_8BITS(cmp->cm_ver.ve_fcnval);
d193 2
a194 2
	    src = EXTRACT_16BITS(cmp->cm_test.te_src);
	    other = EXTRACT_8BITS(cmp->cm_test.te_data);
d199 1
a199 1
	    src = EXTRACT_16BITS(cmp->cm_l1rou.r1_src);
d206 1
a206 1
	    src = EXTRACT_16BITS(cmp->cm_l2rout.r2_src);
d213 3
a215 3
	    vers = EXTRACT_8BITS(cmp->cm_rhello.rh_vers);
	    eco = EXTRACT_8BITS(cmp->cm_rhello.rh_eco);
	    ueco = EXTRACT_8BITS(cmp->cm_rhello.rh_ueco);
d218 5
a222 5
	    src = EXTRACT_16BITS(srcea.dne_remote.dne_nodeaddr);
	    info = EXTRACT_8BITS(cmp->cm_rhello.rh_info);
	    blksize = EXTRACT_16BITS(cmp->cm_rhello.rh_blksize);
	    priority = EXTRACT_8BITS(cmp->cm_rhello.rh_priority);
	    hello = EXTRACT_16BITS(cmp->cm_rhello.rh_hello);
d233 3
a235 3
	    vers = EXTRACT_8BITS(cmp->cm_ehello.eh_vers);
	    eco = EXTRACT_8BITS(cmp->cm_ehello.eh_eco);
	    ueco = EXTRACT_8BITS(cmp->cm_ehello.eh_ueco);
d238 3
a240 3
	    src = EXTRACT_16BITS(srcea.dne_remote.dne_nodeaddr);
	    info = EXTRACT_8BITS(cmp->cm_ehello.eh_info);
	    blksize = EXTRACT_16BITS(cmp->cm_ehello.eh_blksize);
d244 3
a246 3
	    dst = EXTRACT_16BITS(rtea.dne_remote.dne_nodeaddr);
	    hello = EXTRACT_16BITS(cmp->cm_ehello.eh_hello);
	    other = EXTRACT_8BITS(cmp->cm_ehello.eh_data);
d278 1
a278 1
print_l1_routes(const char *rp, int len)
d286 1
a286 1
	    count = EXTRACT_16BITS(rp);
d291 1
a291 1
	    id = EXTRACT_16BITS(rp);
d294 1
a294 1
	    info = EXTRACT_16BITS(rp);
d303 1
a303 1
print_l2_routes(const char *rp, int len)
d311 1
a311 1
	    count = EXTRACT_16BITS(rp);
d316 1
a316 1
	    area = EXTRACT_16BITS(rp);
d319 1
a319 1
	    info = EXTRACT_16BITS(rp);
d346 1
a346 1
print_elist(const char *elp, int len)
d352 1
a352 1
print_nsp(const u_char *nspp, int nsplen)
d357 3
a359 3
	flags = EXTRACT_8BITS(nsphp->nh_flags);
	dst = EXTRACT_16BITS(nsphp->nh_dst);
	src = EXTRACT_16BITS(nsphp->nh_src);
d375 1
a375 1
		    int data_off = sizeof(struct minseghdr);
d377 1
a377 1
		    ack = EXTRACT_16BITS(shp->sh_seq[0]);
d383 1
a383 1
		        ack = EXTRACT_16BITS(shp->sh_seq[1]);
d390 1
a390 1
			    ack = EXTRACT_16BITS(shp->sh_seq[2]);
d409 1
a409 1
		    int data_off = sizeof(struct minseghdr);
d411 1
a411 1
		    ack = EXTRACT_16BITS(shp->sh_seq[0]);
d417 1
a417 1
		        ack = EXTRACT_16BITS(shp->sh_seq[1]);
d424 1
a424 1
			    ack = EXTRACT_16BITS(shp->sh_seq[2]);
d444 1
a444 1
		    ack = EXTRACT_16BITS(shp->sh_seq[0]);
d450 1
a450 1
		        ack = EXTRACT_16BITS(shp->sh_seq[1]);
d456 1
a456 1
			    ack = EXTRACT_16BITS(shp->sh_seq[2]);
d460 2
a461 2
		    lsflags = EXTRACT_8BITS(lsmp->ls_lsflags);
		    fcval = EXTRACT_8BITS(lsmp->ls_fcval);
d501 1
a501 1
		    ack = EXTRACT_16BITS(amp->ak_acknum[0]);
d507 1
a507 1
		        ack = EXTRACT_16BITS(amp->ak_acknum[1]);
d523 1
a523 1
		    ack = EXTRACT_16BITS(amp->ak_acknum[0]);
d529 1
a529 1
		        ack = EXTRACT_16BITS(amp->ak_acknum[1]);
d563 3
a565 3
		    services = EXTRACT_8BITS(cimp->ci_services);
		    info = EXTRACT_8BITS(cimp->ci_info);
		    segsize = EXTRACT_16BITS(cimp->ci_segsize);
d605 2
a606 1
		    int services, info, segsize, optlen;
d611 4
a614 4
		    services = EXTRACT_8BITS(ccmp->cc_services);
		    info = EXTRACT_8BITS(ccmp->cc_info);
		    segsize = EXTRACT_16BITS(ccmp->cc_segsize);
		    optlen = EXTRACT_8BITS(ccmp->cc_optlen);
d658 2
a659 1
		    int reason, optlen;
d664 2
a665 2
		    reason = EXTRACT_16BITS(dimp->di_reason);
		    optlen = EXTRACT_8BITS(dimp->di_optlen);
d684 1
a684 1
		    reason = EXTRACT_16BITS(dcmp->dc_reason);
d736 1
a736 1
	int area = (dnaddr & AREAMASK) >> AREASHIFT;
d762 1
a762 1
pdata(u_char *dp, int maxlen)
d765 1
a765 1
	int x = maxlen;
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-decnet.c,v 1.2 1995/03/06 19:11:07 mycroft Exp $	*/
/*	$NetBSD: print-decnet.c,v 1.2 1995/03/06 19:11:07 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1992, 1993, 1994
d26 1
a26 1
    "@@(#) Header: print-decnet.c,v 1.15 94/06/20 19:44:38 leres Exp (LBL)";
d33 4
d38 2
a39 1
#ifdef	DECNETLIB
a44 1
#ifdef __STDC__
d46 1
a46 1
#endif
d66 1
a66 1
#ifdef	DECNETLIB
d92 1
a92 1
	bcopy(&(ap[sizeof(short)]), rhp, rhlen);
d106 1
a106 1
	    bcopy(&(ap[sizeof(short)]), rhp, rhlen);
d217 2
a218 1
	    bcopy(&(cmp->cm_rhello.rh_src), &srcea, sizeof(srcea));
d237 2
a238 1
	    bcopy(&(cmp->cm_ehello.eh_src), &srcea, sizeof(srcea));
d243 2
a244 1
	    bcopy(&(cmp->cm_ehello.eh_router), &rtea, sizeof(rtea));
d699 1
a699 1
struct token reason2str[] = {
d739 2
d748 1
a748 1
#ifdef	DECNETLIB
d752 1
a752 1
	bcopy((char *)&dnaddr, dna.a_addr, sizeof(short));
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
