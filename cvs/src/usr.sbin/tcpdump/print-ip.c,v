head	1.47;
access;
symbols
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.45.0.6
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.43.0.6
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.36.0.16
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.14
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.12
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.10
	OPENBSD_5_0:1.36.0.8
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.6
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.4
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.34.0.10
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.6
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.4
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.28.0.4
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.19.0.4
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.4
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2016.10.30.04.10.21;	author jsg;	state Exp;
branches;
next	1.46;
commitid	mmfAOrSATz2Bc9lt;

1.46
date	2016.10.30.04.03.29;	author jsg;	state Exp;
branches;
next	1.45;
commitid	Gr22ZWrtWN39RwIq;

1.45
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.44;
commitid	enjTsnD5UO6xazKc;

1.44
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	Zx2k82IzYwwZaEz9;

1.43
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	Uu5nFG3wCl0LACBb;

1.42
date	2014.12.09.17.03.19;	author mikeb;	state Exp;
branches;
next	1.41;
commitid	jvJGNbHm278R5JJF;

1.41
date	2014.12.03.13.22.18;	author mikeb;	state Exp;
branches;
next	1.40;
commitid	ykwaSylMzIi44JzN;

1.40
date	2014.12.03.13.19.03;	author mikeb;	state Exp;
branches;
next	1.39;
commitid	wPf5BYNAX6n2pykw;

1.39
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.38;
commitid	yLXrOcgrag4eS8u4;

1.38
date	2014.06.20.04.04.52;	author lteo;	state Exp;
branches;
next	1.37;
commitid	2daJ0iB9vSWHdMTb;

1.37
date	2014.01.11.04.35.52;	author lteo;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.12.06.10.33;	author naddy;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.27.18.15.25;	author canacar;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.01.17.18.39;	author moritz;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.29.20.41.41;	author moritz;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.29.20.30.11;	author moritz;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.08.19.24.03;	author canacar;	state Exp;
branches;
next	1.28;

1.28
date	2004.10.15.11.10.29;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2004.08.10.19.55.35;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.08.01.01.35;	author mcbride;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.28.02.17.03;	author mcbride;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.04.08.35.12;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.02.09.43.27;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.21.06.15.18;	author mcbride;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.17.21.36.17;	author mcbride;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.15.07.11.31;	author mcbride;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.20.23.39.20;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.11.12.21.32;	author cedric;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.18.08.51.17;	author jakob;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.10.10.22.59;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.15.16.16.48;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.05.15.18.47;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.22.19.08.00;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.07.21.52.38;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.03.14.31.57;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.26.21.35.40;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.16.11.20.14;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	99.10.06.01.46.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.09.16.20.58.47;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.35;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.23;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.26;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.47
log
@If a length from an ip packet encapsulated in gre or etherip would cause
the position to go past snapend truncate.  Found with afl.
@
text
@/*	$OpenBSD: print-ip.c,v 1.46 2016/10/30 04:03:29 jsg Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/time.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>

#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "addrtoname.h"
#include "interface.h"
#include "extract.h"			/* must come after interface.h */

/* Compatibility */
#ifndef	IPPROTO_ND
#define	IPPROTO_ND	77
#endif

#ifndef IN_CLASSD
#define IN_CLASSD(i) (((int32_t)(i) & 0xf0000000) == 0xe0000000)
#endif

/* Definitions required for ECN
   for use if the OS running tcpdump does not have ECN */
#ifndef IPTOS_ECT
#define IPTOS_ECT	0x02	/* ECN Capable Transport in IP header*/
#endif
#ifndef IPTOS_CE
#define IPTOS_CE	0x01	/* ECN Cong. Experienced in IP header*/
#endif

/* (following from ipmulti/mrouted/prune.h) */

/*
 * The packet format for a traceroute request.
 */
struct tr_query {
	u_int  tr_src;			/* traceroute source */
	u_int  tr_dst;			/* traceroute destination */
	u_int  tr_raddr;		/* traceroute response address */
#if BYTE_ORDER == BIG_ENDIAN
	struct {
		u_int   ttl : 8;	/* traceroute response ttl */
		u_int   qid : 24;	/* traceroute query id */
	} q;
#else
	struct {
		u_int	qid : 24;	/* traceroute query id */
		u_int	ttl : 8;	/* traceroute response ttl */
	} q;
#endif
};

#define tr_rttl q.ttl
#define tr_qid  q.qid

/*
 * Traceroute response format.  A traceroute response has a tr_query at the
 * beginning, followed by one tr_resp for each hop taken.
 */
struct tr_resp {
	u_int tr_qarr;			/* query arrival time */
	u_int tr_inaddr;		/* incoming interface address */
	u_int tr_outaddr;		/* outgoing interface address */
	u_int tr_rmtaddr;		/* parent address in source tree */
	u_int tr_vifin;			/* input packet count on interface */
	u_int tr_vifout;		/* output packet count on interface */
	u_int tr_pktcnt;		/* total incoming packets for src-grp */
	u_char  tr_rproto;		/* routing proto deployed on router */
	u_char  tr_fttl;		/* ttl required to forward on outvif */
	u_char  tr_smask;		/* subnet mask for src addr */
	u_char  tr_rflags;		/* forwarding error codes */
};

/* defs within mtrace */
#define TR_QUERY 1
#define TR_RESP	2

/* fields for tr_rflags (forwarding error codes) */
#define TR_NO_ERR	0
#define TR_WRONG_IF	1
#define TR_PRUNED	2
#define TR_OPRUNED	3
#define TR_SCOPED	4
#define TR_NO_RTE	5
#define TR_NO_FWD	7
#define TR_NO_SPACE	0x81
#define TR_OLD_ROUTER	0x82

/* fields for tr_rproto (routing protocol) */
#define TR_PROTO_DVMRP	1
#define TR_PROTO_MOSPF	2
#define TR_PROTO_PIM	3
#define TR_PROTO_CBT	4

static void print_mtrace(const u_char *bp, u_int len)
{
	struct tr_query *tr = (struct tr_query *)(bp + 8);

	printf("mtrace %d: %s to %s reply-to %s", tr->tr_qid,
		ipaddr_string(&tr->tr_src), ipaddr_string(&tr->tr_dst),
		ipaddr_string(&tr->tr_raddr));
	if (IN_CLASSD(ntohl(tr->tr_raddr)))
		printf(" with-ttl %d", tr->tr_rttl);
}

static void print_mresp(const u_char *bp, u_int len)
{
	struct tr_query *tr = (struct tr_query *)(bp + 8);

	printf("mresp %d: %s to %s reply-to %s", tr->tr_qid,
		ipaddr_string(&tr->tr_src), ipaddr_string(&tr->tr_dst),
		ipaddr_string(&tr->tr_raddr));
	if (IN_CLASSD(ntohl(tr->tr_raddr)))
		printf(" with-ttl %d", tr->tr_rttl);
}

static void
igmp_print(const u_char *bp, u_int len, const u_char *bp2)
{
	const struct ip *ip;

	ip = (const struct ip *)bp2;
        (void)printf("%s > %s: ",
		ipaddr_string(&ip->ip_src),
		ipaddr_string(&ip->ip_dst));

	TCHECK2(bp[0], 8);
	switch (bp[0]) {
	case 0x11:
		(void)printf("igmp query");
		if (*(int *)&bp[4])
			(void)printf(" [gaddr %s]", ipaddr_string(&bp[4]));
		if (len != 8)
			(void)printf(" [len %d]", len);
		break;
	case 0x12:
		(void)printf("igmp report %s", ipaddr_string(&bp[4]));
		if (len != 8)
			(void)printf(" [len %d]", len);
		break;
	case 0x16:
		(void)printf("igmp nreport %s", ipaddr_string(&bp[4]));
		break;
	case 0x17:
		(void)printf("igmp leave %s", ipaddr_string(&bp[4]));
		break;
	case 0x13:
		(void)printf("igmp dvmrp");
		if (len < 8)
			(void)printf(" [len %d]", len);
		else
			dvmrp_print(bp, len);
		break;
	case 0x14:
		(void)printf("igmp pim");
		pim_print(bp, len);
  		break;
	case 0x1e:
		print_mresp(bp, len);
		break;
	case 0x1f:
		print_mtrace(bp, len);
		break;
	default:
		(void)printf("igmp-%d", bp[0] & 0xf);
		break;
	}
	if ((bp[0] >> 4) != 1)
		(void)printf(" [v%d]", bp[0] >> 4);

	TCHECK2(bp[0], len);
	if (vflag) {
		/* Check the IGMP checksum */
		u_int32_t sum = 0;
		int count;
		const u_short *sp = (u_short *)bp;
		
		for (count = len / 2; --count >= 0; )
			sum += *sp++;
		if (len & 1)
			sum += ntohs(*(u_char *) sp << 8);
		while (sum >> 16)
			sum = (sum & 0xffff) + (sum >> 16);
		sum = 0xffff & ~sum;
		if (sum != 0)
			printf(" bad igmp cksum %x!", EXTRACT_16BITS(&bp[2]));
	}
	return;
trunc:
	fputs("[|igmp]", stdout);
}

/*
 * print the recorded route in an IP RR, LSRR or SSRR option.
 */
static void
ip_printroute(const char *type, const u_char *cp, u_int length)
{
	u_int ptr = cp[2] - 1;
	u_int len;

	printf(" %s{", type);
	if ((length + 1) & 3)
		printf(" [bad length %d]", length);
	if (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)
		printf(" [bad ptr %d]", cp[2]);

	type = "";
	for (len = 3; len < length; len += 4) {
		if (ptr == len)
			type = "#";
		printf("%s%s", type, ipaddr_string(&cp[len]));
		type = " ";
	}
	printf("%s}", ptr == len? "#" : "");
}

/*
 * print IP options.
 */
static void
ip_optprint(const u_char *cp, u_int length)
{
	u_int len;
	int tt;

	for (; length > 0; cp += len, length -= len) {
		TCHECK(cp[1]);
		tt = *cp;
		len = (tt == IPOPT_NOP || tt == IPOPT_EOL) ? 1 : cp[1];
		if (len <= 0) {
			printf("[|ip op len %d]", len);
			return;
		}
		if (&cp[1] >= snapend || cp + len > snapend) {
			printf("[|ip]");
			return;
		}
		switch (tt) {

		case IPOPT_EOL:
			printf(" EOL");
			if (length > 1)
				printf("-%d", length - 1);
			return;

		case IPOPT_NOP:
			printf(" NOP");
			break;

		case IPOPT_TS:
			printf(" TS{%d}", len);
			break;

		case IPOPT_SECURITY:
			printf(" SECURITY{%d}", len);
			break;

		case IPOPT_RR:
			printf(" RR{%d}=", len);
			ip_printroute("RR", cp, len);
			break;

		case IPOPT_SSRR:
			ip_printroute("SSRR", cp, len);
			break;

		case IPOPT_LSRR:
			ip_printroute("LSRR", cp, len);
			break;

		default:
			printf(" IPOPT-%d{%d}", cp[0], len);
			break;
		}
	}
	return;

trunc:
	printf("[|ip]");
}

/*
 * compute an IP header checksum.
 * don't modifiy the packet.
 */
u_short
in_cksum(const u_short *addr, int len, int csum)
{
	int nleft = len;
	const u_short *w = addr;
	u_short answer;
	int sum = csum;

 	/*
	 *  Our algorithm is simple, using a 32 bit accumulator (sum),
	 *  we add sequential 16 bit words to it, and at the end, fold
	 *  back all the carry bits from the top 16 bits into the lower
	 *  16 bits.
 	 */
	while (nleft > 1)  {
		sum += *w++;
		nleft -= 2;
	}
	if (nleft == 1)
		sum += htons(*(u_char *)w<<8);

	/*
	 * add back carry outs from top 16 bits to low 16 bits
	 */
	sum = (sum >> 16) + (sum & 0xffff);	/* add hi 16 to low 16 */
	sum += (sum >> 16);			/* add carry */
	answer = ~sum;				/* truncate to 16 bits */
	return (answer);
}

/*
 * print an IP datagram.
 */
void
ip_print(const u_char *bp, u_int length)
{
	const struct ip *ip;
	u_int hlen, len, off;
	const u_char *cp;
	const u_char *pktp = packetp;
	const u_char *send = snapend;

	TCHECK2(bp[0], 1);
	ip = (const struct ip *)bp;

	/*
	 * If the IP header is not aligned, copy into abuf.
	 * This will never happen with BPF.  It does happen with raw packet
	 * dumps from -r.
	 */
	if ((intptr_t)ip & (sizeof(u_int32_t)-1)) {
		static u_char *abuf = NULL;
		static int didwarn = 0;
		int clen = snapend - bp;

		if (clen > snaplen)
			clen = snaplen;
		if (abuf == NULL) {
			abuf = malloc(snaplen);
			if (abuf == NULL)
				error("ip_print: malloc");
		}
		memmove((char *)abuf, (char *)ip, min(length, clen));
		snapend = abuf + clen;
		packetp = abuf;
		ip = (struct ip *)abuf;
		/* We really want libpcap to give us aligned packets */
		if (!didwarn) {
			warning("compensating for unaligned libpcap packets");
			++didwarn;
		}
	}

	TCHECK(*ip);
	if (ip->ip_v != IPVERSION) {
		(void)printf("bad-ip-version %u", ip->ip_v);
		goto out;
	}

	len = ntohs(ip->ip_len);
	if (length < len) {
		(void)printf("truncated-ip - %d bytes missing!",
			len - length);
		len = length;
	}

	hlen = ip->ip_hl * 4;
	if (hlen < sizeof(struct ip) || hlen > len) {
		(void)printf("bad-hlen %d", hlen);
		goto out;
	}

	len -= hlen;

	/*
	 * If this is fragment zero, hand it to the next higher
	 * level protocol.
	 */
	off = ntohs(ip->ip_off);
	if ((off & 0x1fff) == 0) {
		cp = (const u_char *)ip + hlen;
		if (cp > snapend)
			goto trunc;
		switch (ip->ip_p) {

		case IPPROTO_TCP:
			tcp_print(cp, len, (const u_char *)ip);
			break;

		case IPPROTO_UDP:
			udp_print(cp, len, (const u_char *)ip);
			break;

		case IPPROTO_ICMP:
			icmp_print(cp, len, (const u_char *)ip);
			break;

#ifndef IPPROTO_IGRP
#define IPPROTO_IGRP 9
#endif
		case IPPROTO_IGRP:
			igrp_print(cp, len, (const u_char *)ip);
			break;

		case IPPROTO_ND:
			(void)printf("%s > %s:", ipaddr_string(&ip->ip_src),
				ipaddr_string(&ip->ip_dst));
			(void)printf(" nd %d", len);
			break;

#ifndef IPPROTO_OSPF
#define IPPROTO_OSPF 89
#endif
		case IPPROTO_OSPF:
			ospf_print(cp, len, (const u_char *)ip);
			break;

#ifndef IPPROTO_IGMP
#define IPPROTO_IGMP 2
#endif
		case IPPROTO_IGMP:
			igmp_print(cp, len, (const u_char *)ip);
			break;

#ifndef IPPROTO_IPIP
#define IPPROTO_IPIP 4
#endif
		case IPPROTO_IPIP:
			/* ip-in-ip encapsulation */
			if (vflag)
				(void)printf("%s > %s: ",
					     ipaddr_string(&ip->ip_src),
					     ipaddr_string(&ip->ip_dst));
			ip_print(cp, len);
			if (! vflag) {
				printf(" (encap)");
				goto out;
			}
			break;

#ifdef INET6
#ifndef IPPROTO_IPV6
#define IPPROTO_IPV6
#endif
		case IPPROTO_IPV6:
			/* ip6-in-ip encapsulation */
			if (vflag)
				(void)printf("%s > %s: ",
					     ipaddr_string(&ip->ip_src),
					     ipaddr_string(&ip->ip_dst));
			ip6_print(cp, len);
			if (! vflag) {
 				printf(" (encap)");
				goto out;
 			}
 			break;
#endif /*INET6*/

#ifndef IPPROTO_GRE
#define IPPROTO_GRE 47
#endif
		case IPPROTO_GRE:
			if (vflag)
				(void)printf("gre %s > %s: ",
					     ipaddr_string(&ip->ip_src),
					     ipaddr_string(&ip->ip_dst));
			/* do it */
			gre_print(cp, len);
			if (! vflag) {
				printf(" (gre encap)");
				goto out;
  			}
  			break;

#ifndef IPPROTO_ESP
#define IPPROTO_ESP 50
#endif
		case IPPROTO_ESP:
			esp_print(cp, len, (const u_char *)ip);
			break;

#ifndef IPPROTO_AH
#define IPPROTO_AH 51
#endif
		case IPPROTO_AH:
			ah_print(cp, len, (const u_char *)ip);
			break;

#ifndef IPPROTO_MOBILE
#define IPPROTO_MOBILE 55
#endif
		case IPPROTO_MOBILE:
			if (vflag)
				(void)printf("mobile %s > %s: ",
					     ipaddr_string(&ip->ip_src),
					     ipaddr_string(&ip->ip_dst));
			mobile_print(cp, len);
			if (! vflag) {
				printf(" (mobile encap)");
				goto out;
			}
			break;

#ifndef IPPROTO_ETHERIP
#define IPPROTO_ETHERIP	97
#endif
		case IPPROTO_ETHERIP:
			etherip_print(cp, snapend - cp, len,
			    (const u_char *)ip);
			break;

#ifndef	IPPROTO_IPCOMP
#define	IPPROTO_IPCOMP	108
#endif
		case IPPROTO_IPCOMP:
			ipcomp_print(cp, len, (const u_char *)ip);
			break;

#ifndef IPPROTO_CARP  
#define IPPROTO_CARP 112
#endif
		case IPPROTO_CARP:
			if (packettype == PT_VRRP) {
				if (vflag)
					(void)printf("vrrp %s > %s: ",
					     ipaddr_string(&ip->ip_src),
					     ipaddr_string(&ip->ip_dst));
				vrrp_print(cp, len, ip->ip_ttl);
			} else {
				if (vflag)
					(void)printf("carp %s > %s: ",
					     ipaddr_string(&ip->ip_src),
					     ipaddr_string(&ip->ip_dst));
				carp_print(cp, len, ip->ip_ttl);
			}
			break;

#ifndef IPPROTO_PFSYNC  
#define IPPROTO_PFSYNC 240
#endif
		case IPPROTO_PFSYNC:
			pfsync_ip_print(cp,
			    (int)(snapend - (u_char *)ip) - hlen,
			    (const u_char *)ip);
			break;

		default:
			(void)printf("%s > %s:", ipaddr_string(&ip->ip_src),
				ipaddr_string(&ip->ip_dst));
			(void)printf(" ip-proto-%d %d", ip->ip_p, len);
			break;
		}
	}
	/*
	 * for fragmented datagrams, print id:size@@offset.  On all
	 * but the last stick a "+".  For unfragmented datagrams, note
	 * the don't fragment flag.
	 */
	if (off & 0x3fff) {
		/*
		 * if this isn't the first frag, we're missing the
		 * next level protocol header.  print the ip addr.
		 */
		if (off & 0x1fff)
			(void)printf("%s > %s:", ipaddr_string(&ip->ip_src),
				      ipaddr_string(&ip->ip_dst));
		(void)printf(" (frag %d:%d@@%d%s)", ntohs(ip->ip_id), len,
			(off & 0x1fff) * 8,
			(off & IP_MF)? "+" : "");
	} 
	if (off & IP_DF)
		(void)printf(" (DF)");

	if (ip->ip_tos) {
		(void)printf(" [tos 0x%x", (int)ip->ip_tos);
		if (ip->ip_tos & (IPTOS_CE|IPTOS_ECT)) {
			(void)printf(" (");
			if (ip->ip_tos & IPTOS_ECT) {
				/* ECN-capable transport */
				putchar('E');
			}
			if (ip->ip_tos & IPTOS_CE) {
				/* _C_ongestion experienced (ECN) */
				putchar('C'); 
			}
			(void)printf(")");
  		}
		(void)printf("]");
	}

	if (ip->ip_ttl <= 1)
		(void)printf(" [ttl %d]", (int)ip->ip_ttl);

	if (vflag) {
		char *sep = "";

		printf(" (");
		if (ip->ip_ttl > 1) {
			(void)printf("%sttl %d", sep, (int)ip->ip_ttl);
			sep = ", ";
		}
		if ((off & 0x3fff) == 0) {
			(void)printf("%sid %d", sep, (int)ntohs(ip->ip_id));
			sep = ", ";
		}
		(void)printf("%slen %u", sep, ntohs(ip->ip_len));
		sep = ", ";
		if ((u_char *)ip + hlen <= snapend) {
			u_int16_t sum, ip_sum;
			sum = in_cksum((const u_short *)ip, hlen, 0);
			if (sum != 0) {
				ip_sum = EXTRACT_16BITS(&ip->ip_sum);
				(void)printf("%sbad ip cksum %x! -> %x", sep, ip_sum,
					     in_cksum_shouldbe(ip_sum, sum));
				sep = ", ";
			}
		}
		if (hlen > sizeof(struct ip)) {
			hlen -= sizeof(struct ip);
			(void)printf("%soptlen=%d", sep, hlen);
			ip_optprint((u_char *)(ip + 1), hlen);
		}
		printf(")");
	}
out:
	packetp = pktp;
	snapend = send;
	return;

trunc:
	printf("[|ip]");
}
@


1.46
log
@Replace a snapend test in ip_print() with a call to TCHECK2 as there
is already a trunc label with the same printf in the function.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.45 2015/11/16 00:16:39 mmcc Exp $	*/
d419 2
@


1.45
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.44 2015/08/21 02:07:32 deraadt Exp $	*/
d360 1
a361 4
	if ((u_char *)(ip + 1) > snapend) {
		printf("[|ip]");
		return;
	}
@


1.44
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.43 2015/01/16 06:40:21 deraadt Exp $	*/
d126 1
a126 1
static void print_mtrace(register const u_char *bp, register u_int len)
d128 1
a128 1
	register struct tr_query *tr = (struct tr_query *)(bp + 8);
d137 1
a137 1
static void print_mresp(register const u_char *bp, register u_int len)
d139 1
a139 1
	register struct tr_query *tr = (struct tr_query *)(bp + 8);
d149 1
a149 2
igmp_print(register const u_char *bp, register u_int len,
	   register const u_char *bp2)
d151 1
a151 1
	register const struct ip *ip;
d228 1
a228 1
ip_printroute(const char *type, register const u_char *cp, u_int length)
d230 2
a231 2
	register u_int ptr = cp[2] - 1;
	register u_int len;
d253 1
a253 1
ip_optprint(register const u_char *cp, u_int length)
d255 1
a255 1
	register u_int len;
d319 1
a319 1
in_cksum(const u_short *addr, register int len, int csum)
d352 1
a352 1
ip_print(register const u_char *bp, register u_int length)
d354 3
a356 3
	register const struct ip *ip;
	register u_int hlen, len, off;
	register const u_char *cp;
@


1.43
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.42 2014/12/09 17:03:19 mikeb Exp $	*/
d380 1
a380 1
			abuf = (u_char *)malloc(snaplen);
@


1.42
log
@Catch up with the BPF_ALIGNMENT switch to the uint32_t.

bpf aligns data following the datalink header (e.g. ethernet)
on the BPF_ALIGNMENT boundary.  Since rev1.41 of bpf.h it's
uint32_t instead of a long.  And also since then almost all
packets become "unaligned" from the tcpdump perspective and
require costly copies into the internal buffer.  Neither IP
header (struct ip) nor IPv6 (struct ip6_hdr) have fields
larger than 32 bits and therefore alignment requirements for
them are at most 32 bit.

ok millert, jsg, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.41 2014/12/03 13:22:18 mikeb Exp $	*/
a23 1
#include <sys/param.h>
@


1.41
log
@Restore packetp and snapend pointers once we're done with an incorrectly
aligned IP/IPv6 packet so that tcpdump can print hexdump of the whole
packet including the Ethernet header (if requested) and not only the
IP/IPv6 part of it.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.40 2014/12/03 13:19:03 mikeb Exp $	*/
d373 1
a373 1
	if ((intptr_t)ip & (sizeof(long)-1)) {
@


1.40
log
@Fixup a crash found by jsg using the AFL fuzzer.  IP and IPv6 printing
routines should check that there's at least a complete IP/IPv6 header
available in the buffer before trying to do anything else.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.39 2014/08/14 12:44:44 mpi Exp $	*/
d359 2
d399 1
a399 1
		return;
d412 1
a412 1
		return;
d477 1
a477 1
				return;
d494 1
a494 1
 				return;
d511 1
a511 1
				return;
d540 1
a540 1
				return;
d665 3
@


1.39
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.38 2014/06/20 04:04:52 lteo Exp $	*/
d361 5
@


1.38
log
@Instead of showing the difference between a bad checksum and a good
checksum, make tcpdump (with the -v flag) show the actual bad checksum
within the IP/protocol header itself and what the good checksum should
be, e.g. "[bad tcp cksum abcd! -> d1e6]"

This change applies to IP, TCP (over IPv4 and IPv6), UDP (over IPv4 and
IPv6), ICMP, and ICMPv6.  This commit also fixes several inconsistencies
in the way bad checksums were displayed for these protocols.

Tested on amd64, i386, and macppc.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.37 2014/01/11 04:35:52 lteo Exp $	*/
a28 1
#include <netinet/in_systm.h>
a33 1
#include <netinet/tcpip.h>
@


1.37
log
@Make icmp_print() accept the length variable, which is the length of the
packet without the IP header.  This is needed by the next commit that
will allow tcpdump to detect bad ICMP checksums.

Related functions like {tcp,udp,icmp6}_print() already accept this
length variable, so this change makes icmp_print() consistent with
them as well.

This commit makes no functional change to tcpdump itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.36 2010/01/12 06:10:33 naddy Exp $	*/
a629 1
		int sum;
d644 1
d647 3
a649 4
				(void)printf("%sbad cksum %x!", sep,
					     ntohs(ip->ip_sum));
				if (vflag > 1)
					(void)printf(" differs by %x", htons(sum));
@


1.36
log
@Add TCP/UDP checksum display for v6 and clean up the checksum
calculation.  Mostly from tcpdump.org; ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.35 2009/10/27 23:59:55 deraadt Exp $	*/
d430 1
a430 1
			icmp_print(cp, (const u_char *)ip);
@


1.35
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.34 2007/10/07 16:41:05 deraadt Exp $	*/
d323 1
a323 1
in_cksum(const u_short *addr, register int len, u_short csum)
@


1.34
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.33 2007/06/27 18:15:25 canacar Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.33
log
@When aligning buffers correctly handle the case where the
buffers overlap, which happens on 64 bit archs, when
handling encapsulated packets. Reported and tested by Jurjen Oskam
additional testing by Stuart Henderson and todd@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.32 2006/06/01 17:18:39 moritz Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.32 2006/06/01 17:18:39 moritz Exp $ (LBL)";
@


1.32
log
@Pass the captured packet length in addition to the real packet length
to etherip_print() and do all the bounds checking with it. Also add
bounds checks to ether_print(). This fixes even more crashes.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.31 2006/05/29 20:41:41 moritz Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.31 2006/05/29 20:41:41 moritz Exp $ (LBL)";
d376 1
d378 2
d385 2
a386 2
		memcpy((char *)abuf, (char *)ip, min(length, snaplen));
		snapend += abuf - (u_char *)ip;
@


1.31
log
@No need for return; at end of functions returning void.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.30 2006/05/29 20:30:11 moritz Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.30 2006/05/29 20:30:11 moritz Exp $ (LBL)";
d545 2
a546 1
			etherip_print(cp, len, (const u_char *)ip);
@


1.30
log
@Be more careful to not touch memory outside the
captured packet. Fixes some more crashes.

ok canacar@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.29 2005/10/08 19:24:03 canacar Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.29 2005/10/08 19:24:03 canacar Exp $ (LBL)";
a665 1
	return;
@


1.29
log
@Check IP version when decoding v4 and v6 packets.
From Jason Wright via PR-4531.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.28 2004/10/15 11:10:29 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.28 2004/10/15 11:10:29 markus Exp $ (LBL)";
d265 1
d268 2
a269 2
		int tt = *cp;

d317 4
d393 1
a393 8
	if ((u_char *)(ip + 1) > snapend) {
		printf("[|ip]");
		return;
	}
	if (length < sizeof (struct ip)) {
		(void)printf("truncated-ip %d", length);
		return;
	}
d398 8
d407 1
a407 1
	if (hlen < sizeof(struct ip)) {
a411 4
	len = ntohs(ip->ip_len);
	if (length < len)
		(void)printf("truncated-ip - %d bytes missing!",
			len - length);
d655 2
a656 1
		if ((hlen -= sizeof(struct ip)) > 0) {
d662 5
@


1.28
log
@print ip_len for -v; ok otto, hshoexer, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.27 2004/08/10 19:55:35 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.27 2004/08/10 19:55:35 markus Exp $ (LBL)";
d394 4
@


1.27
log
@print checksum differences on -vv; ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.26 2004/05/08 01:01:35 mcbride Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.26 2004/05/08 01:01:35 mcbride Exp $ (LBL)";
d637 2
@


1.26
log
@Pass the length of what was captured to pfsync_print, not the length
of the original packet.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.25 2004/04/28 02:17:03 mcbride Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.25 2004/04/28 02:17:03 mcbride Exp $ (LBL)";
d642 2
@


1.25
log
@Make tcpdump print carp as carp. Printing vrrp can be forced with -T vrrp.

ok markus@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.24 2004/02/04 08:35:12 otto Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.24 2004/02/04 08:35:12 otto Exp $ (LBL)";
d572 3
a574 1
			pfsync_ip_print(cp, len, (const u_char *)ip);
@


1.24
log
@Some more non-alignment problems resolved.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.23 2004/02/02 09:43:27 otto Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.23 2004/02/02 09:43:27 otto Exp $ (LBL)";
d549 2
a550 2
#ifndef IPPROTO_VRRP  
#define IPPROTO_VRRP 112
d552 10
a561 3
		case IPPROTO_VRRP:
			if (vflag)
				(void)printf("vrrp %s > %s: ",
d564 2
a565 1
			vrrp_print(cp, len, ip->ip_ttl);
@


1.23
log
@Do away with non-aligned memory accesses.
ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.22 2004/01/21 06:15:18 mcbride Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.22 2004/01/21 06:15:18 mcbride Exp $ (LBL)";
d42 1
d368 1
a368 1
	if ((long)ip & 3) {
@


1.22
log
@Clean up pfsync output: print source address by default, pass -vv correctly
to pf_print_state(), and other minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.21 2003/12/17 21:36:17 mcbride Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.21 2003/12/17 21:36:17 mcbride Exp $ (LBL)";
a361 1
#ifdef LBL_ALIGN
d364 1
a364 1
	 * This will never happen with BPF.  It does happen raw packet
d386 1
a386 1
#endif
@


1.21
log
@Change pfsync IP protocol and multicast group numbers.

IPPROTO_PFSYNC -> 240
INADDR_PFSYNC_GROUP -> 224.0.0.240

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.20 2003/12/15 07:11:31 mcbride Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.20 2003/12/15 07:11:31 mcbride Exp $ (LBL)";
a563 4
			if (vflag)
				(void)printf("pfsync %s > %s: ",
					     ipaddr_string(&ip->ip_src),
					     ipaddr_string(&ip->ip_dst));
@


1.20
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.19 2003/02/20 23:39:20 jason Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.19 2003/02/20 23:39:20 jason Exp $ (LBL)";
d561 1
a561 1
#define IPPROTO_PFSYNC 136
@


1.19
log
@add printing of ipcomp, and while in the neighborhood, make ah/esp actually
check the length of the data
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.18 2003/02/11 12:21:32 cedric Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.18 2003/02/11 12:21:32 cedric Exp $ (LBL)";
d558 11
@


1.18
log
@Show DF on IP fragments
ok henric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.17 2002/09/18 08:51:17 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.17 2002/09/18 08:51:17 jakob Exp $ (LBL)";
d540 7
@


1.17
log
@remove egp support; unresolved non-bsd license for a decoder of protocol that
noone uses anymore is not worth the amount of work needed to be resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.16 2002/04/10 10:22:59 deraadt Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.16 2002/04/10 10:22:59 deraadt Exp $ (LBL)";
d576 2
a577 1
	} else if (off & IP_DF)
@


1.16
log
@If the IP header length is zero, the packet will loop in ip_print().
Taken from tcpdump 3.7.1; mbing@@nfr.net; ho ok
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.15 2001/02/15 16:16:48 niklas Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.15 2001/02/15 16:16:48 niklas Exp $ (LBL)";
a439 4
			break;

		case IPPROTO_EGP:
			egp_print(cp, len, (const u_char *)ip);
@


1.15
log
@There has been confusion wrt IP protocols 4, 94 and 98.  Make us
consistent, and make IPSEC tunnelmode tcpdumping work as expected.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.14 2001/02/05 15:18:47 jason Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.14 2001/02/05 15:18:47 jason Exp $ (LBL)";
d397 4
@


1.14
log
@etherip printing code... handles draft (v2) and current (v3)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.13 2000/12/22 19:08:00 mickey Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.13 2000/12/22 19:08:00 mickey Exp $ (LBL)";
d456 2
a457 2
#ifndef IPPROTO_ENCAP
#define IPPROTO_ENCAP 4
d459 1
a459 1
		case IPPROTO_ENCAP:
d473 2
a474 2
#ifndef IP6PROTO_ENCAP
#define IP6PROTO_ENCAP 41
d476 1
a476 1
		case IP6PROTO_ENCAP:
@


1.13
log
@when printing vrrp and verbose set -- print src/dst ip addrs
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.12 2000/12/07 21:52:38 mickey Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.12 2000/12/07 21:52:38 mickey Exp $ (LBL)";
d534 8
@


1.12
log
@add vrrp printing; from tcpdump.org
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ip.c,v 1.11 2000/10/03 14:31:57 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.11 2000/10/03 14:31:57 ho Exp $ (LBL)";
d538 4
@


1.11
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.10 2000/04/26 21:35:40 jakob Exp $ (LBL)";
d321 2
a322 2
static int
in_cksum(const struct ip *ip)
d324 17
a340 3
	register const u_short *sp = (u_short *)ip;
	register u_int32_t sum = 0;
	register int count;
d343 1
a343 1
	 * No need for endian conversions.
d345 4
a348 7
	for (count = ip->ip_hl * 2; --count >= 0; )
		sum += *sp++;
	while (sum > 0xffff)
		sum = (sum & 0xffff) + (sum >> 16);
	sum = ~sum & 0xffff;

	return (sum);
d534 6
d601 1
a601 1
			sum = in_cksum(ip);
@


1.10
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.9 2000/01/16 11:20:14 jakob Exp $ (LBL)";
@


1.9
log
@Mobile IP support (from KAME/NetBSD)
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.8 1999/10/06 01:46:40 deraadt Exp $ (LBL)";
d458 18
@


1.8
log
@big endian fixes; ryker, jd@@noc7.uchsc.edu
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.7 1999/09/16 20:58:47 brad Exp $ (LBL)";
d487 15
@


1.7
log
@bring more inline with tcpdump 3.4
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.6 1999/07/28 20:41:36 jakob Exp $ (LBL)";
d76 1
a76 1
#ifdef WORDS_BIGENDIAN
@


1.6
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ip.c,v 1.5 1996/12/12 16:22:35 bitblt Exp $ (LBL)";
@


1.5
log
@*** empty log message ***
@
text
@d24 1
a24 1
    "@@(#) $Header: print-ip.c,v 1.62 96/12/10 23:20:31 leres Exp $ (LBL)";
d58 9
d475 14
d515 17
a531 2
	if (ip->ip_tos)
		(void)printf(" [tos 0x%x]", (int)ip->ip_tos);
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d23 2
a24 2
static char rcsid[] =
    "@@(#) Header: print-ip.c,v 1.49 96/06/20 22:01:23 leres Exp (LBL)";
a28 1
#include <sys/types.h>
d45 1
d47 1
a47 1
#include "addrtoname.h"
d64 8
a71 8
    u_int  tr_src;		/* traceroute source */
    u_int  tr_dst;		/* traceroute destination */
    u_int  tr_raddr;		/* traceroute response address */
#if defined(BYTE_ORDER) && (BYTE_ORDER == LITTLE_ENDIAN)
    struct {
	u_int	qid : 24;	/* traceroute query id */
	u_int	ttl : 8;	/* traceroute response ttl */
    } q;
d73 5
a77 5
    struct {
	u_int   ttl : 8;	/* traceroute response ttl */
	u_int   qid : 24;	/* traceroute query id */
    } q;
#endif /* BYTE_ORDER */
d88 11
a98 11
    u_int tr_qarr;		/* query arrival time */
    u_int tr_inaddr;		/* incoming interface address */
    u_int tr_outaddr;		/* outgoing interface address */
    u_int tr_rmtaddr;		/* parent address in source tree */
    u_int tr_vifin;		/* input packet count on interface */
    u_int tr_vifout;		/* output packet count on interface */
    u_int tr_pktcnt;		/* total incoming packets for src-grp */
    u_char  tr_rproto;		/* routing protocol deployed on router */
    u_char  tr_fttl;		/* ttl required to forward on outvif */
    u_char  tr_smask;		/* subnet mask for src addr */
    u_char  tr_rflags;		/* forwarding error codes */
d122 1
a122 1
static void print_mtrace(register const u_char *bp, register int len)
d124 1
a124 1
	register struct tr_query* tr = (struct tr_query*)(bp + 8);
d133 1
a133 1
static void print_mresp(register const u_char *bp, register int len)
d135 1
a135 1
	register struct tr_query* tr = (struct tr_query*)(bp + 8);
d145 1
a145 1
igmp_print(register const u_char *bp, register int len,
a148 1
	register const u_char *ep;
a150 1
	ep = (const u_char *)snapend;
d155 1
a155 4
	if (bp + 7 > ep) {
		(void)printf("[|igmp]");
		return;
	}
d198 21
d225 1
a225 1
ip_printroute(const char *type, register const u_char *cp, int length)
d227 2
a228 2
	int ptr = cp[2] - 1;
	int len;
a239 7
#ifdef TCPDUMP_ALIGN
		{
		struct in_addr addr;
		memcpy((char *)&addr, (char *)&cp[len], sizeof(addr));
		printf("%s%s", type, ipaddr_string(&addr));
		}
#else
a240 1
#endif
d250 1
a250 1
ip_optprint(register const u_char *cp, int length)
d252 1
a252 1
	int len;
d333 1
a333 1
ip_print(register const u_char *bp, register int length)
d336 1
a336 3
	register int hlen;
	register int len;
	register int off;
d340 1
a340 1
#ifdef TCPDUMP_ALIGN
d342 1
a342 1
	 * The IP header is not word aligned, so copy into abuf.
d346 1
a346 1
	if ((long)ip & (sizeof(long)-1)) {
d348 1
d359 5
d394 1
d398 1
d402 8
d415 1
d419 1
d426 1
d433 1
d449 17
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-ip.c,v 1.4 1995/04/24 13:27:43 cgd Exp $	*/
/*	$NetBSD: print-ip.c,v 1.4 1995/04/24 13:27:43 cgd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
d26 1
a26 1
    "@@(#) Header: print-ip.c,v 1.38 94/06/14 20:17:40 leres Exp (LBL)";
a43 1
#ifdef __STDC__
d45 1
a45 1
#endif
d51 95
d163 2
a164 2
	switch (bp[0] & 0xf) {
	case 1:
d171 1
a171 1
	case 2:
d176 8
a183 2
	case 3:
		(void)printf("igmp dvmrp %s", ipaddr_string(&bp[4]));
d186 12
a204 2
	if (bp[1])
		(void)printf(" [b1=0x%x]", bp[1]);
d229 1
a229 1
		bcopy((char *)&cp[len], (char *)&addr, sizeof(addr));
d252 4
d308 1
a308 1
	register u_int32 sum = 0;
d343 1
a343 1
		static u_char *abuf;
d345 1
a345 1
		if (abuf == 0)
d347 4
a350 1
		bcopy((char *)ip, (char *)abuf, min(length, snaplen));
d469 7
a475 5
		sum = in_cksum(ip);
		if (sum != 0) {
			(void)printf("%sbad cksum %x!", sep,
				     ntohs(ip->ip_sum));
			sep = ", ";
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: print-ip.c,v 1.4 1995/04/24 13:27:43 cgd Exp $ */
a24 24
/*
 * Copyright (c) 1995 Sun Microsystems, Inc.
 * All rights reserved.
 * 
 * Permission is hereby granted, without written agreement and without
 * license or royalty fees, to use, copy, modify, and distribute this
 * software and its documentation for any purpose, provided that the
 * above copyright notice and the following two paragraphs appear in
 * all copies of this software.

 * IN NO EVENT SHALL SUN MICROSYSTEMS, INC. BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 * SUN MICROSYSTEMS, INC. HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.

 * SUN MICROSYSTEMS, INC. SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 * THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND SUN
 * MICROSYSTEMS, INC. HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,
 * UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
*/

d27 1
a27 1
    "@@(#) Header: print-ip.c,v 1.38 94/06/14 20:17:40 leres Exp $ (LBL)";
a307 25
			break;
#ifndef IPPROTO_SKIP_OLD
#define IPPROTO_SKIP_OLD 79
#endif
		case IPPROTO_SKIP_OLD:
			skip_print_old(cp, len, (const u_char *) ip);
			break;
#ifndef IPPROTO_ESP
#define IPPROTO_ESP 50
#endif
		case IPPROTO_ESP:
			esp_print(cp, len, (const u_char *) ip);
			break;
#ifndef IPPROTO_AH
#define IPPROTO_AH 51
#endif
		case IPPROTO_AH:
			ah_print(cp, len, (const u_char *) ip);
			break;

#ifndef IPPROTO_SKIP
#define IPPROTO_SKIP 57
#endif
		case IPPROTO_SKIP:
			skip_print(cp, len, (const u_char *) ip);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: print-ip.c,v 1.4 1995/04/24 13:27:43 cgd Exp $	*/
d25 24
d51 1
a51 1
    "@@(#) Header: print-ip.c,v 1.38 94/06/14 20:17:40 leres Exp (LBL)";
d332 25
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
