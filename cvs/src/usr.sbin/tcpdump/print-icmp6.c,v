head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.10.0.8
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.6
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.4
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.4
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.07.28.13.05.52;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	gtiesyikik4h4cBw;

1.20
date	2016.05.07.19.36.45;	author jca;	state Exp;
branches;
next	1.19;
commitid	p9Xb7oxf4Pif7Q1f;

1.19
date	2016.05.06.17.16.24;	author jca;	state Exp;
branches;
next	1.18;
commitid	CqFUJqNlQcpt0uR9;

1.18
date	2016.03.15.05.03.11;	author mmcc;	state Exp;
branches;
next	1.17;
commitid	UUo2bJ8XhK7ac5DD;

1.17
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	enjTsnD5UO6xazKc;

1.16
date	2015.11.02.17.48.33;	author sthen;	state Exp;
branches;
next	1.15;
commitid	SD02zcoxrJ34JbpO;

1.15
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Uu5nFG3wCl0LACBb;

1.14
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.13;
commitid	yLXrOcgrag4eS8u4;

1.13
date	2014.06.20.04.04.52;	author lteo;	state Exp;
branches;
next	1.12;
commitid	2daJ0iB9vSWHdMTb;

1.12
date	2014.01.11.04.41.08;	author lteo;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.24.09.33.22;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2011.09.17.19.56.19;	author bluhm;	state Exp;
branches;
next	1.9;

1.9
date	2011.09.17.15.59.44;	author naddy;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.06.16.01.57;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2009.05.25.10.53.35;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.29.09.46.32;	author bluhm;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.28.11.05.06;	author dhartmei;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.30.18.36.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.04.03.51.53;	author pvalchev;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.26.21.35.40;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Use long labs(3) for pointer arithmetic.
Found by David Hill with clang.
@
text
@/*	$OpenBSD: print-icmp6.c,v 1.20 2016/05/07 19:36:45 jca Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifdef INET6

#include <ctype.h>

#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>

#include <arpa/inet.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#include <netinet6/mld6.h>

#include "interface.h"
#include "addrtoname.h"
#include "extract.h"

void icmp6_opt_print(const u_char *, int);
void mld6_print(const u_char *);
void mldv2_query_print(const u_char *, u_int);
void mldv2_report_print(const u_char *, u_int);

/* mldv2 report types */
static struct tok mldv2report2str[] = {
	{ 1,	"is_in" },
	{ 2,	"is_ex" },
	{ 3,	"to_in" },
	{ 4,	"to_ex" },
	{ 5,	"allow" },
	{ 6,	"block" },
	{ 0,	NULL }
};

#define MLDV2_QUERY_QRV			24
#define MLDV2_QUERY_QQIC 		25
#define MLDV2_QUERY_NSRCS		26
#define MLDV2_QUERY_SRC0		28

#define MLDV2_QUERY_QRV_SFLAG	(1 << 3)

#define MLD_V1_QUERY_MINLEN		24

#define MLDV2_REPORT_GROUP0		8

#define MLDV2_REPORT_MINLEN		8
#define MLDV2_REPORT_MINGRPLEN	20

#define MLDV2_RGROUP_NSRCS		2
#define MLDV2_RGROUP_MADDR		4

#define MLDV2_MRC_FLOAT			(1 << 15)
#define MLDV2_MRD(mant, exp)	((mant | 0x1000) << (exp + 3))

#define MLDV2_QQIC_FLOAT		(1 << 7)
#define MLDV2_QQI(mant, exp)	((mant | 0x10) << (exp + 3))

static int
icmp6_cksum(const struct ip6_hdr *ip6, const struct icmp6_hdr *icmp6,
    u_int len)
{
	union {
		struct {
			struct in6_addr ph_src;
			struct in6_addr ph_dst;
			u_int32_t       ph_len;
			u_int8_t        ph_zero[3];
			u_int8_t        ph_nxt;
		} ph;
		u_int16_t pa[20];
	} phu;
	size_t i;
	u_int32_t sum = 0;

	/* pseudo-header */
	memset(&phu, 0, sizeof(phu));
	phu.ph.ph_src = ip6->ip6_src;
	phu.ph.ph_dst = ip6->ip6_dst;
	phu.ph.ph_len = htonl(len);
	phu.ph.ph_nxt = IPPROTO_ICMPV6;

	for (i = 0; i < sizeof(phu.pa) / sizeof(phu.pa[0]); i++)
		sum += phu.pa[i];

	return in_cksum((u_short *)icmp6, len, sum);
}

void
icmp6_print(const u_char *bp, u_int length, const u_char *bp2)
{
	const struct icmp6_hdr *dp;
	const struct ip6_hdr *ip;
	const char *str;
	const struct ip6_hdr *oip;
	const struct udphdr *ouh;
	int hlen, dport;
	const u_char *ep;
	char buf[256];
	int icmp6len;

#if 0
#define TCHECK(var) if ((u_char *)&(var) > ep - sizeof(var)) goto trunc
#endif

	dp = (struct icmp6_hdr *)bp;
	ip = (struct ip6_hdr *)bp2;
	oip = (struct ip6_hdr *)(dp + 1);
	str = buf;
	/* 'ep' points to the end of avaible data. */
	ep = snapend;
	if (ip->ip6_plen)
		icmp6len = (ntohs(ip->ip6_plen) + sizeof(struct ip6_hdr) -
			    (bp - bp2));
	else			/* XXX: jumbo payload case... */
		icmp6len = snapend - bp;

#if 0
        (void)printf("%s > %s: ",
		ip6addr_string(&ip->ip6_src),
		ip6addr_string(&ip->ip6_dst));
#endif

	TCHECK(dp->icmp6_code);
	switch (dp->icmp6_type) {
	case ICMP6_DST_UNREACH:
		TCHECK(oip->ip6_dst);
		switch (dp->icmp6_code) {
		case ICMP6_DST_UNREACH_NOROUTE:
			printf("icmp6: %s unreachable route",
			       ip6addr_string(&oip->ip6_dst));
			break;
		case ICMP6_DST_UNREACH_ADMIN:
			printf("icmp6: %s unreachable prohibited",
			       ip6addr_string(&oip->ip6_dst));
			break;
#ifdef ICMP6_DST_UNREACH_BEYONDSCOPE
		case ICMP6_DST_UNREACH_BEYONDSCOPE:
#else
		case ICMP6_DST_UNREACH_NOTNEIGHBOR:
#endif
			printf("icmp6: %s beyond scope of source address %s",
			       ip6addr_string(&oip->ip6_dst),
			       ip6addr_string(&oip->ip6_src));
			break;
		case ICMP6_DST_UNREACH_ADDR:
			printf("icmp6: %s unreachable address",
			       ip6addr_string(&oip->ip6_dst));
			break;
		case ICMP6_DST_UNREACH_NOPORT:
			TCHECK(oip->ip6_nxt);
			hlen = sizeof(struct ip6_hdr);
			ouh = (struct udphdr *)(((u_char *)oip) + hlen);
			TCHECK(ouh->uh_dport);
			dport = ntohs(ouh->uh_dport);
			switch (oip->ip6_nxt) {
			case IPPROTO_TCP:
				printf("icmp6: %s tcp port %s unreachable",
					ip6addr_string(&oip->ip6_dst),
					tcpport_string(dport));
				break;
			case IPPROTO_UDP:
				printf("icmp6: %s udp port %s unreachable",
					ip6addr_string(&oip->ip6_dst),
					udpport_string(dport));
				break;
			default:
				printf("icmp6: %s protocol %d port %d unreachable",
					ip6addr_string(&oip->ip6_dst),
					oip->ip6_nxt, dport);
				break;
			}
			break;
		default:
			printf("icmp6: %s unreachable code-#%d",
				ip6addr_string(&oip->ip6_dst),
				dp->icmp6_code);
			break;
		}
		break;
	case ICMP6_PACKET_TOO_BIG:
		TCHECK(dp->icmp6_mtu);
		printf("icmp6: too big %u", (u_int32_t)ntohl(dp->icmp6_mtu));
		break;
	case ICMP6_TIME_EXCEEDED:
		TCHECK(oip->ip6_dst);
		switch (dp->icmp6_code) {
		case ICMP6_TIME_EXCEED_TRANSIT:
			printf("icmp6: time exceeded in-transit for %s",
				ip6addr_string(&oip->ip6_dst));
			break;
		case ICMP6_TIME_EXCEED_REASSEMBLY:
			printf("icmp6: ip6 reassembly time exceeded");
			break;
		default:
			printf("icmp6: time exceeded code-#%d",
				dp->icmp6_code);
			break;
		}
		break;
	case ICMP6_PARAM_PROB:
		TCHECK(oip->ip6_dst);
		switch (dp->icmp6_code) {
		case ICMP6_PARAMPROB_HEADER:
			printf("icmp6: parameter problem errorneous - octet %u",
				(u_int32_t)ntohl(dp->icmp6_pptr));
			break;
		case ICMP6_PARAMPROB_NEXTHEADER:
			printf("icmp6: parameter problem next header - octet %u",
				(u_int32_t)ntohl(dp->icmp6_pptr));
			break;
		case ICMP6_PARAMPROB_OPTION:
			printf("icmp6: parameter problem option - octet %u",
				(u_int32_t)ntohl(dp->icmp6_pptr));
			break;
		default:
			printf("icmp6: parameter problem code-#%d",
			       dp->icmp6_code);
			break;
		}
		break;
	case ICMP6_ECHO_REQUEST:
	case ICMP6_ECHO_REPLY:
		printf("icmp6: echo %s", dp->icmp6_type == ICMP6_ECHO_REQUEST ?
		    "request" : "reply");
		if (vflag) {
			TCHECK(dp->icmp6_seq);
			printf(" (id:%04x seq:%u)",
			    ntohs(dp->icmp6_id), ntohs(dp->icmp6_seq));
		}
		break;
	case ICMP6_MEMBERSHIP_QUERY:
		printf("icmp6: multicast listener query ");
		if (length == MLD_V1_QUERY_MINLEN) {
			mld6_print((const u_char *)dp);
		} else if (length >= MLD_V2_QUERY_MINLEN) {
			printf("v2 ");
			mldv2_query_print((const u_char *)dp, length);
		} else {
			printf("unknown-version (len %u) ", length);
		}
		break;
	case ICMP6_MEMBERSHIP_REPORT:
		printf("icmp6: multicast listener report ");
		mld6_print((const u_char *)dp);
		break;
	case ICMP6_MEMBERSHIP_REDUCTION:
		printf("icmp6: multicast listener done ");
		mld6_print((const u_char *)dp);
		break;
	case ND_ROUTER_SOLICIT:
		printf("icmp6: router solicitation ");
		if (vflag) {
#define RTSOLLEN 8
		        icmp6_opt_print((const u_char *)dp + RTSOLLEN,
					icmp6len - RTSOLLEN);
		}
		break;
	case ND_ROUTER_ADVERT:
		printf("icmp6: router advertisement");
		if (vflag) {
			struct nd_router_advert *p;

			p = (struct nd_router_advert *)dp;
			TCHECK(p->nd_ra_retransmit);
			printf("(chlim=%d, ", (int)p->nd_ra_curhoplimit);
			if (p->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED)
				printf("M");
			if (p->nd_ra_flags_reserved & ND_RA_FLAG_OTHER)
				printf("O");
			if (p->nd_ra_flags_reserved &
			    (ND_RA_FLAG_MANAGED|ND_RA_FLAG_OTHER))
				printf(", ");
			switch (p->nd_ra_flags_reserved
			    & ND_RA_FLAG_RTPREF_MASK) {
			case ND_RA_FLAG_RTPREF_HIGH:
				printf("pref=high, ");
				break;
			case ND_RA_FLAG_RTPREF_MEDIUM:
				printf("pref=medium, ");
				break;
			case ND_RA_FLAG_RTPREF_LOW:
				printf("pref=low, ");
				break;
			case ND_RA_FLAG_RTPREF_RSV:
				printf("pref=rsv, ");
				break;
			}
			printf("router_ltime=%d, ", ntohs(p->nd_ra_router_lifetime));
			printf("reachable_time=%u, ",
				(u_int32_t)ntohl(p->nd_ra_reachable));
			printf("retrans_time=%u)",
				(u_int32_t)ntohl(p->nd_ra_retransmit));
#define RTADVLEN 16
		        icmp6_opt_print((const u_char *)dp + RTADVLEN,
					icmp6len - RTADVLEN);
		}
		break;
	case ND_NEIGHBOR_SOLICIT:
	    {
		struct nd_neighbor_solicit *p;
		p = (struct nd_neighbor_solicit *)dp;
		TCHECK(p->nd_ns_target);
		printf("icmp6: neighbor sol: who has %s",
			ip6addr_string(&p->nd_ns_target));
		if (vflag) {
#define NDSOLLEN 24
		        icmp6_opt_print((const u_char *)dp + NDSOLLEN,
					icmp6len - NDSOLLEN);
		}
	    }
		break;
	case ND_NEIGHBOR_ADVERT:
	    {
		struct nd_neighbor_advert *p;

		p = (struct nd_neighbor_advert *)dp;
		TCHECK(p->nd_na_target);
		printf("icmp6: neighbor adv: tgt is %s",
			ip6addr_string(&p->nd_na_target));
                if (vflag) {
#define ND_NA_FLAG_ALL	\
	(ND_NA_FLAG_ROUTER|ND_NA_FLAG_SOLICITED|ND_NA_FLAG_OVERRIDE)
			/* we don't need ntohl() here.  see advanced-api-04. */
			if (p->nd_na_flags_reserved &  ND_NA_FLAG_ALL) {
#undef ND_NA_FLAG_ALL
				u_int32_t flags;

				flags = p->nd_na_flags_reserved;
				printf("(");
				if (flags & ND_NA_FLAG_ROUTER)
					printf("R");
				if (flags & ND_NA_FLAG_SOLICITED)
					printf("S");
				if (flags & ND_NA_FLAG_OVERRIDE)
					printf("O");
				printf(")");
			}
#define NDADVLEN 24
		        icmp6_opt_print((const u_char *)dp + NDADVLEN,
					icmp6len - NDADVLEN);
		}
	    }
		break;
	case ND_REDIRECT:
	{
#define RDR(i) ((struct nd_redirect *)(i))
		char tgtbuf[INET6_ADDRSTRLEN], dstbuf[INET6_ADDRSTRLEN];

		TCHECK(RDR(dp)->nd_rd_dst);
		inet_ntop(AF_INET6, &RDR(dp)->nd_rd_target,
			  tgtbuf, INET6_ADDRSTRLEN);
		inet_ntop(AF_INET6, &RDR(dp)->nd_rd_dst,
			  dstbuf, INET6_ADDRSTRLEN);
		printf("icmp6: redirect %s to %s", dstbuf, tgtbuf);
#define REDIRECTLEN 40
		if (vflag) {
			icmp6_opt_print((const u_char *)dp + REDIRECTLEN,
					icmp6len - REDIRECTLEN);
		}
		break;
	}
	case ICMP6_ROUTER_RENUMBERING:
		switch (dp->icmp6_code) {
		case ICMP6_ROUTER_RENUMBERING_COMMAND:
			printf("icmp6: router renum command");
			break;
		case ICMP6_ROUTER_RENUMBERING_RESULT:
			printf("icmp6: router renum result");
			break;
		default:
			printf("icmp6: router renum code-#%d", dp->icmp6_code);
			break;
		}
		break;
#ifdef ICMP6_WRUREQUEST
	case ICMP6_WRUREQUEST:	/*ICMP6_FQDN_QUERY*/
	    {
		int siz;
		siz = ep - (u_char *)(dp + 1);
		if (siz == 4)
			printf("icmp6: who-are-you request");
		else {
			printf("icmp6: FQDN request");
			if (vflag) {
				if (siz < 8)
					printf("?(icmp6_data %d bytes)", siz);
				else if (8 < siz)
					printf("?(extra %d bytes)", siz - 8);
			}
		}
		break;
	    }
#endif /*ICMP6_WRUREQUEST*/
#ifdef ICMP6_WRUREPLY
	case ICMP6_WRUREPLY:	/*ICMP6_FQDN_REPLY*/
	    {
		enum { UNKNOWN, WRU, FQDN } mode = UNKNOWN;
		u_char const *buf;
		u_char const *cp = NULL;

		buf = (u_char *)(dp + 1);

		/* fair guess */
		if (buf[12] == ep - buf - 13)
			mode = FQDN;
		else if (dp->icmp6_code == 1)
			mode = FQDN;

		/* wild guess */
		if (mode == UNKNOWN) {
			cp = buf + 4;
			while (cp < ep) {
				if (!isprint(*cp++))
					mode = FQDN;
			}
		}
		if (mode == UNKNOWN && 2 < labs(buf[12] - (ep - buf - 13)))
			mode = WRU;
		if (mode == UNKNOWN)
			mode = FQDN;

		if (mode == WRU) {
			cp = buf + 4;
			printf("icmp6: who-are-you reply(\"");
		} else if (mode == FQDN) {
			cp = buf + 13;
			printf("icmp6: FQDN reply(\"");
		}
		for (; cp < ep; cp++)
			printf((isprint(*cp) ? "%c" : "\\%03o"), *cp);
		printf("\"");
		if (vflag) {
			printf(",%s", mode == FQDN ? "FQDN" : "WRU");
			if (mode == FQDN) {
				int ttl;
				ttl = (int)ntohl(*(u_int32_t *)&buf[8]);
				if (dp->icmp6_code == 1)
					printf(",TTL=unknown");
				else if (ttl < 0)
					printf(",TTL=%d:invalid", ttl);
				else
					printf(",TTL=%d", ttl);
				if (buf[12] != ep - buf - 13) {
					(void)printf(",invalid namelen:%d/%u",
						buf[12],
						(unsigned int)(ep - buf - 13));
				}
			}
		}
		printf(")");
		break;
	    }
#endif /*ICMP6_WRUREPLY*/
	case MLDV2_LISTENER_REPORT:
		printf("multicast listener report v2");
		mldv2_report_print((const u_char *) dp, length);
		break;
	default:
		printf("icmp6: type-#%d", dp->icmp6_type);
		break;
	}
	if (vflag) {
		if (TTEST2(dp->icmp6_type, length)) {
			u_int16_t sum, icmp6_sum;
			sum = icmp6_cksum(ip, dp, length);
			if (sum != 0) {
				icmp6_sum = EXTRACT_16BITS(&dp->icmp6_cksum);
				printf(" [bad icmp6 cksum %x! -> %x]", icmp6_sum,
				    in_cksum_shouldbe(icmp6_sum, sum));
			} else
				printf(" [icmp6 cksum ok]");
		}
	}
	return;
trunc:
	fputs("[|icmp6]", stdout);
#if 0
#undef TCHECK
#endif
}

void
icmp6_opt_print(const u_char *bp, int resid)
{
	const struct nd_opt_hdr *op;
	const struct nd_opt_hdr *opl;	/* why there's no struct? */
	const struct nd_opt_prefix_info *opp;
	const struct icmp6_opts_redirect *opr;
	const struct nd_opt_mtu *opm;
	const struct nd_opt_rdnss *oprd;
	const struct nd_opt_route_info *opri;
	const u_char *ep;
	const struct in6_addr *in6p;
	struct in6_addr in6;
	int	i, opts_len;
#if 0
	const struct ip6_hdr *ip;
	const char *str;
	const struct ip6_hdr *oip;
	const struct udphdr *ouh;
	int hlen, dport;
	char buf[256];
#endif

#if 0
#define TCHECK(var) if ((u_char *)&(var) > ep - sizeof(var)) goto trunc
#endif
#define ECHECK(var) if ((u_char *)&(var) > ep - sizeof(var)) return

	op = (struct nd_opt_hdr *)bp;
#if 0
	ip = (struct ip6_hdr *)bp2;
	oip = &dp->icmp6_ip6;
	str = buf;
#endif
	/* 'ep' points to the end of avaible data. */
	ep = snapend;

	ECHECK(op->nd_opt_len);
	if (resid <= 0)
		return;
	if (op->nd_opt_len == 0)
		goto trunc;
	if (bp + (op->nd_opt_len << 3) > ep)
		goto trunc;
	switch (op->nd_opt_type) {
	case ND_OPT_SOURCE_LINKADDR:
		opl = (struct nd_opt_hdr *)op;
#if 1
		if ((u_char *)opl + (opl->nd_opt_len << 3) > ep)
			goto trunc;
#else
		TCHECK((u_char *)opl + (opl->nd_opt_len << 3) - 1);
#endif
		printf("(src lladdr: %s",
			etheraddr_string((u_char *)(opl + 1)));
		if (opl->nd_opt_len != 1)
			printf("!");
		printf(")");
		icmp6_opt_print((const u_char *)op + (op->nd_opt_len << 3),
				resid - (op->nd_opt_len << 3));
		break;
	case ND_OPT_TARGET_LINKADDR:
		opl = (struct nd_opt_hdr *)op;
#if 1
		if ((u_char *)opl + (opl->nd_opt_len << 3) > ep)
			goto trunc;
#else
		TCHECK((u_char *)opl + (opl->nd_opt_len << 3) - 1);
#endif
		printf("(tgt lladdr: %s",
			etheraddr_string((u_char *)(opl + 1)));
		if (opl->nd_opt_len != 1)
			printf("!");
		printf(")");
		icmp6_opt_print((const u_char *)op + (op->nd_opt_len << 3),
				resid - (op->nd_opt_len << 3));
		break;
	case ND_OPT_PREFIX_INFORMATION:
		opp = (struct nd_opt_prefix_info *)op;
		TCHECK(opp->nd_opt_pi_prefix);
		printf("(prefix info: ");
		if (opp->nd_opt_pi_flags_reserved & ND_OPT_PI_FLAG_ONLINK)
		       printf("L");
		if (opp->nd_opt_pi_flags_reserved & ND_OPT_PI_FLAG_AUTO)
		       printf("A");
		if (opp->nd_opt_pi_flags_reserved)
			printf(" ");
		printf("valid_ltime=");
		if ((u_int32_t)ntohl(opp->nd_opt_pi_valid_time) == ~0U)
			printf("infinity");
		else {
			printf("%u", (u_int32_t)ntohl(opp->nd_opt_pi_valid_time));
		}
		printf(", ");
		printf("preferred_ltime=");
		if ((u_int32_t)ntohl(opp->nd_opt_pi_preferred_time) == ~0U)
			printf("infinity");
		else {
			printf("%u", (u_int32_t)ntohl(opp->nd_opt_pi_preferred_time));
		}
		printf(", ");
		printf("prefix=%s/%d", ip6addr_string(&opp->nd_opt_pi_prefix),
			opp->nd_opt_pi_prefix_len);
		if (opp->nd_opt_pi_len != 4)
			printf("!");
		printf(")");
		icmp6_opt_print((const u_char *)op + (op->nd_opt_len << 3),
				resid - (op->nd_opt_len << 3));
		break;
	case ND_OPT_REDIRECTED_HEADER:
		opr = (struct icmp6_opts_redirect *)op;
		printf("(redirect)");
		/* xxx */
		icmp6_opt_print((const u_char *)op + (op->nd_opt_len << 3),
				resid - (op->nd_opt_len << 3));
		break;
	case ND_OPT_MTU:
		opm = (struct nd_opt_mtu *)op;
		TCHECK(opm->nd_opt_mtu_mtu);
		printf("(mtu: ");
		printf("mtu=%u", (u_int32_t)ntohl(opm->nd_opt_mtu_mtu));
		if (opm->nd_opt_mtu_len != 1)
			printf("!");
		printf(")");
		icmp6_opt_print((const u_char *)op + (op->nd_opt_len << 3),
				resid - (op->nd_opt_len << 3));
		break;
	case ND_OPT_ROUTE_INFO:
		opri = (struct nd_opt_route_info *)op;
		TCHECK(opri->nd_opt_rti_lifetime);
		printf("(route-info: ");
		memset(&in6, 0, sizeof(in6));
		in6p = (const struct in6_addr *)(opri + 1);
		switch (op->nd_opt_len) {
		case 1:
			break;
		case 2:
			TCHECK2(*in6p, 8);
			memcpy(&in6, opri + 1, 8);
			break;
		case 3:
			TCHECK(*in6p);
			memcpy(&in6, opri + 1, sizeof(in6));
			break;
		default:
			goto trunc;
		}
		printf("%s/%u, ", ip6addr_string(&in6),
		    opri->nd_opt_rti_prefixlen);
		switch (opri->nd_opt_rti_flags & ND_RA_FLAG_RTPREF_MASK) {
		case ND_RA_FLAG_RTPREF_HIGH:
			printf("pref=high, ");
			break;
		case ND_RA_FLAG_RTPREF_MEDIUM:
			printf("pref=medium, ");
			break;
		case ND_RA_FLAG_RTPREF_LOW:
			printf("pref=low, ");
			break;
		case ND_RA_FLAG_RTPREF_RSV:
			printf("pref=rsv, ");
			break;
		}
		printf("lifetime=%us)",
		    (u_int32_t)ntohl(opri->nd_opt_rti_lifetime));
		icmp6_opt_print((const u_char *)op + (op->nd_opt_len << 3),
				resid - (op->nd_opt_len << 3));
		break;
	case ND_OPT_RDNSS:
		oprd = (const struct nd_opt_rdnss *)op;
		printf("(rdnss: ");
		TCHECK(oprd->nd_opt_rdnss_lifetime);
		printf("lifetime=%us",
		    (u_int32_t)ntohl(oprd->nd_opt_rdnss_lifetime));
		if (oprd->nd_opt_rdnss_len < 3) {
			printf("!");
		} else for (i = 0; i < ((oprd->nd_opt_rdnss_len - 1) / 2); i++) {
			struct in6_addr *addr = (struct in6_addr *)(oprd + 1) + i;
			TCHECK2(*addr, sizeof(struct in6_addr));
			printf(", addr=%s", ip6addr_string(addr));
		}
		printf(")");
		icmp6_opt_print((const u_char *)op + (op->nd_opt_len << 3),
				resid - (op->nd_opt_len << 3));
		break;
	case ND_OPT_DNSSL:
		printf("(dnssl: opt_len=%d)", op->nd_opt_len);
		/* XXX */
		icmp6_opt_print((const u_char *)op + (op->nd_opt_len << 3),
				resid - (op->nd_opt_len << 3));
		break;
	default:
		opts_len = op->nd_opt_len;
		printf("(unknown opt_type=%d, opt_len=%d)",
		       op->nd_opt_type, opts_len);
		if (opts_len == 0)
			opts_len = 1; /* XXX */
		icmp6_opt_print((const u_char *)op + (opts_len << 3),
				resid - (opts_len << 3));
		break;
	}
	return;
 trunc:
	fputs("[ndp opt]", stdout);
	return;
#if 0
#undef TCHECK
#endif
#undef ECHECK
}

void
mld6_print(const u_char *bp)
{
	struct mld_hdr *mp = (struct mld_hdr *)bp;
	const u_char *ep;

	/* 'ep' points to the end of avaible data. */
	ep = snapend;

	if ((u_char *)mp + sizeof(*mp) > ep)
		return;

	printf("max resp delay: %d ", ntohs(mp->mld_maxdelay));
	printf("addr: %s", ip6addr_string(&mp->mld_addr));

	return;
}

void
mldv2_report_print(const u_char *bp, u_int len)
{
	struct icmp6_hdr *icp = (struct icmp6_hdr *) bp;
	u_int group, nsrcs, ngroups;
	u_int i, j;

	if (len < MLDV2_REPORT_MINLEN) {
		printf(" [invalid len %d]", len);
		return;
	}

	TCHECK(icp->icmp6_data16[1]);
	ngroups = ntohs(icp->icmp6_data16[1]);
	printf(", %d group record(s)", ngroups);
	if (vflag > 0) {
		/* Print the group records */
		group = MLDV2_REPORT_GROUP0;
		for (i = 0; i < ngroups; i++) {
			/* type(1) + auxlen(1) + numsrc(2) + grp(16) */
			if (len < group + MLDV2_REPORT_MINGRPLEN) {
				printf(" [invalid number of groups]");
				return;
			}
			TCHECK2(bp[group + MLDV2_RGROUP_MADDR],
			    sizeof(struct in6_addr));
			printf(" [gaddr %s",
			    ip6addr_string(&bp[group + MLDV2_RGROUP_MADDR]));
			printf(" %s", tok2str(mldv2report2str,
			    " [v2-report-#%d]", bp[group]));
			nsrcs = (bp[group + MLDV2_RGROUP_NSRCS] << 8) +
			    bp[group + MLDV2_RGROUP_NSRCS + 1];
			/* Check the number of sources and print them */
			if (len < group + MLDV2_REPORT_MINGRPLEN +
				    (nsrcs * sizeof(struct in6_addr))) {
				printf(" [invalid number of sources %d]", nsrcs);
				return;
			}
			if (vflag == 1)
				printf(", %d source(s)", nsrcs);
			else {
				/* Print the sources */
				(void)printf(" {");
				for (j = 0; j < nsrcs; j++) {
					TCHECK2(bp[group +
					    MLDV2_REPORT_MINGRPLEN +
					    j * sizeof(struct in6_addr)],
					    sizeof(struct in6_addr));
					printf(" %s", ip6addr_string(&bp[group +
					    MLDV2_REPORT_MINGRPLEN + j *
					    sizeof(struct in6_addr)]));
				}
				(void)printf(" }");
			}
			/* Next group record */
			group += MLDV2_REPORT_MINGRPLEN + nsrcs *
			    sizeof(struct in6_addr);
			printf("]");
		}
	}
	return;
trunc:
	(void)printf("[|icmp6]");
	return;
}

void
mldv2_query_print(const u_char *bp, u_int len)
{
	struct icmp6_hdr *icp = (struct icmp6_hdr *) bp;
	u_int mrc, qqic;
	int mrd, qqi;
	int mant, exp;
	u_int nsrcs;
	u_int i;

	if (len < MLD_V2_QUERY_MINLEN) {
		printf(" [invalid len %d]", len);
		return;
	}
	TCHECK(icp->icmp6_data16[0]);
	mrc = ntohs(icp->icmp6_data16[0]);
	if (mrc & MLDV2_MRC_FLOAT) {
		mant = MLD_MRC_MANT(mrc);
		exp = MLD_MRC_EXP(mrc);
		mrd = MLDV2_MRD(mant, exp);
	} else {
		mrd = mrc;
	}
	if (vflag) {
		(void)printf(" [max resp delay=%d]", mrd);
	} 
	TCHECK2(bp[8], sizeof(struct in6_addr));
	printf(" [gaddr %s", ip6addr_string(&bp[8]));

	if (vflag) {
		TCHECK(bp[MLDV2_QUERY_QQIC]);
		if (bp[MLDV2_QUERY_QRV] & MLDV2_QUERY_QRV_SFLAG) {
			printf(" sflag");
		}
		if (MLD_QRV(bp[MLDV2_QUERY_QRV])) {
			printf(" robustness=%d", MLD_QRV(bp[MLDV2_QUERY_QRV]));
		}
		qqic = bp[MLDV2_QUERY_QQIC];
		if (qqic & MLDV2_QQIC_FLOAT) {
			mant = MLD_QQIC_MANT(qqic);
			exp = MLD_QQIC_EXP(qqic);
			qqi = MLDV2_QQI(mant, exp);
		} else {
			qqi = bp[MLDV2_QUERY_QQIC];
		}
		printf(" qqi=%d", qqi);
	}

	TCHECK2(bp[MLDV2_QUERY_NSRCS], 2);
	nsrcs = ntohs(*(u_short *)&bp[MLDV2_QUERY_NSRCS]);
	if (nsrcs > 0) {
		if (len < MLD_V2_QUERY_MINLEN + nsrcs * sizeof(struct in6_addr))
			printf(" [invalid number of sources]");
		else if (vflag > 1) {
			printf(" {");
			for (i = 0; i < nsrcs; i++) {
				TCHECK2(bp[MLDV2_QUERY_SRC0 + i *
				    sizeof(struct in6_addr)],
				    sizeof(struct in6_addr));
				printf(" %s",
				    ip6addr_string(&bp[MLDV2_QUERY_SRC0 + i *
				    sizeof(struct in6_addr)]));
			}
			printf(" }");
		} else
			printf(", %d source(s)", nsrcs);
	}
	printf("]");
	return;
trunc:
	(void)printf("[|icmp6]");
	return;
}


#endif /* INET6 */
@


1.20
log
@Print RA Route Information prefix, preference and lifetime.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.19 2016/05/06 17:16:24 jca Exp $	*/
d455 1
a455 1
		if (mode == UNKNOWN && 2 < abs(buf[12] - (ep - buf - 13)))
@


1.19
log
@In verbose mode, print the router preference contained in RAs.

"pref" keyword taken from tcpdump.org.

ok mpi@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.18 2016/03/15 05:03:11 mmcc Exp $	*/
d529 1
d531 2
d648 37
a684 1
		printf("(route-info: opt_len=%d)", op->nd_opt_len);
@


1.18
log
@ o remove legacy code that defines abs(3) if it isn't available

 o inline an ugly and potentially risky macro of the form:

		#define x if (a) b; else

 o fix a >21 y.o. bug resulting from someone writing:

		puts("[nothing to parse], stdout");

   when they meant:

		fputs("[nothing to parse]", stdout);

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.17 2015/11/16 00:16:39 mmcc Exp $	*/
d308 18
a325 2
			if (p->nd_ra_flags_reserved != 0)
				printf(" ");
@


1.17
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.16 2015/11/02 17:48:33 sthen Exp $	*/
d46 1
a438 3
#ifndef abs
#define abs(a)	((0 < (a)) ? (a) : -(a))
#endif
@


1.16
log
@Print RDNSS nameserver addresses, and print option names for some other
known options that we don't otherwise decode yet (DNSSL, route information).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.15 2015/01/16 06:40:21 deraadt Exp $	*/
d128 7
a134 7
	register const struct icmp6_hdr *dp;
	register const struct ip6_hdr *ip;
	register const char *str;
	register const struct ip6_hdr *oip;
	register const struct udphdr *ouh;
	register int hlen, dport;
	register const u_char *ep;
d507 1
a507 1
icmp6_opt_print(register const u_char *bp, int resid)
d509 7
a515 7
	register const struct nd_opt_hdr *op;
	register const struct nd_opt_hdr *opl;	/* why there's no struct? */
	register const struct nd_opt_prefix_info *opp;
	register const struct icmp6_opts_redirect *opr;
	register const struct nd_opt_mtu *opm;
	register const struct nd_opt_rdnss *oprd;
	register const u_char *ep;
d518 5
a522 5
	register const struct ip6_hdr *ip;
	register const char *str;
	register const struct ip6_hdr *oip;
	register const struct udphdr *ouh;
	register int hlen, dport;
d679 1
a679 1
mld6_print(register const u_char *bp)
d681 2
a682 2
	register struct mld_hdr *mp = (struct mld_hdr *)bp;
	register const u_char *ep;
@


1.15
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.14 2014/08/14 12:44:44 mpi Exp $	*/
d514 1
d516 1
a516 1
	int	opts_len;
d627 28
@


1.14
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.13 2014/06/20 04:04:52 lteo Exp $	*/
a27 1
#include <sys/param.h>
@


1.13
log
@Instead of showing the difference between a bad checksum and a good
checksum, make tcpdump (with the -v flag) show the actual bad checksum
within the IP/protocol header itself and what the good checksum should
be, e.g. "[bad tcp cksum abcd! -> d1e6]"

This change applies to IP, TCP (over IPv4 and IPv6), UDP (over IPv4 and
IPv6), ICMP, and ICMPv6.  This commit also fixes several inconsistencies
in the way bad checksums were displayed for these protocols.

Tested on amd64, i386, and macppc.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.12 2014/01/11 04:41:08 lteo Exp $	*/
a36 1
#include <netinet/in_systm.h>
@


1.12
log
@Let tcpdump detect bad ICMPv6 checksums with the -v flag.

Tested on amd64, i386, loongson, and macppc.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.11 2013/10/24 09:33:22 deraadt Exp $	*/
d56 1
a488 1
		u_int16_t sum;
d490 1
d492 5
a496 3
			if (sum != 0)
				printf(" [bad icmp6 cksum %x!]", sum);
			else
@


1.11
log
@These two programs got fooled by the KAME/NRL split and need type repair.
They do not indicate a problem with the reduction of namespace export,
but got suckered into the 1999 plan.
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.10 2011/09/17 19:56:19 bluhm Exp $	*/
d48 1
d96 30
d486 10
@


1.10
log
@Make tcpdump -v print the id and seq of icmp6 echo packets.
ok claudio naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.9 2011/09/17 15:59:44 naddy Exp $	*/
d610 1
a610 1
	register struct mld6_hdr *mp = (struct mld6_hdr *)bp;
d619 2
a620 2
	printf("max resp delay: %d ", ntohs(mp->mld6_maxdelay));
	printf("addr: %s", ip6addr_string(&mp->mld6_addr));
@


1.9
log
@access a 32-bit field as u_int32_t, not as u_long; ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.8 2010/04/06 16:01:57 jsg Exp $	*/
a228 2
		printf("icmp6: echo request");
		break;
d230 7
a236 1
		printf("icmp6: echo reply");
@


1.8
log
@Add support for decoding MLDv2 initially from tcpdump.org via FreeBSD,
cleaned up to be less gross after some suggestions from stsp.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.7 2009/10/27 23:59:55 deraadt Exp $	*/
d425 2
a426 2
				long ttl;
				ttl = (long)ntohl(*(u_long *)&buf[8]);
d430 1
a430 1
					printf(",TTL=%ld:invalid", ttl);
d432 1
a432 1
					printf(",TTL=%ld", ttl);
@


1.7
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.6 2009/05/25 10:53:35 sthen Exp $	*/
d51 1
d58 36
d96 1
a96 1
icmp6_print(register const u_char *bp, register const u_char *bp2)
d236 8
a243 1
		mld6_print((const u_char *)dp);
d444 4
d620 142
@


1.6
log
@add a missing check for truncated dport in the returned UDP header for
ICMP_UNREACH_PORT. from Peter J. Philipp, ok jsing@@. Closes system/6149.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.5 2009/01/29 09:46:32 bluhm Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) /master/usr.sbin/tcpdump/tcpdump/print-icmp.c,v 2.1 1995/02/03 18:14:42 polk Exp (LBL)";
#endif
@


1.5
log
@In tcpdump some printf() had an additional \n at the end.  Removing
that new line restores the one-line -> one-packet semantics.

ok hshoexer@@, henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.4 2002/11/28 11:05:06 dhartmei Exp $	*/
d128 1
@


1.4
log
@Check for invalid ICMP6 option length, ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.3 2002/05/30 18:36:42 deraadt Exp $	*/
d156 1
a156 1
		printf("icmp6: too big %u\n", (u_int32_t)ntohl(dp->icmp6_mtu));
d178 1
a178 1
			printf("icmp6: parameter problem errorneous - octet %u\n",
d182 1
a182 1
			printf("icmp6: parameter problem next header - octet %u\n",
d186 1
a186 1
			printf("icmp6: parameter problem option - octet %u\n",
@


1.3
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.2 2001/06/04 03:51:53 pvalchev Exp $	*/
d452 4
@


1.2
log
@Spelling: preffered -> preferred
@
text
@d1 1
a1 1
/*	$OpenBSD: print-icmp6.c,v 1.1 2000/04/26 21:35:40 jakob Exp $	*/
d537 1
a537 1
		printf("(unknwon opt_type=%d, opt_len=%d)",
@


1.1
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d502 1
a502 1
		printf("preffered_ltime=");
@

