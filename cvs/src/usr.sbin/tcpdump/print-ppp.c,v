head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.2
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.29.0.8
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.6
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.26.0.14
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.12
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.8
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.6
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.4
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.10
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.8
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.13.0.6
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2017.07.25.16.07.28;	author espie;	state Exp;
branches;
next	1.29;
commitid	p9tCQvI8qDIOxFtC;

1.29
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.28;
commitid	enjTsnD5UO6xazKc;

1.28
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.26;
commitid	yLXrOcgrag4eS8u4;

1.26
date	2011.12.28.22.41.55;	author sthen;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.17.19.56.58;	author naddy;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.17.19.53.24;	author naddy;	state Exp;
branches;
next	1.23;

1.23
date	2010.01.13.11.15.20;	author naddy;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.12.00.02.16;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.10.15.24.24;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.09.06.01.05;	author canacar;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.04.15.10.12;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.08.19.45.15;	author canacar;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.21.05.48.50;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.03.14.21.56;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.31.05.11.09;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.20.04.51.54;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.18.14.39.35;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	99.09.16.17.36.33;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	99.02.16.03.45.11;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.02.11.12.48.29;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.20.12.27;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.28;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.28;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.34;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@make function match its prototype.

okay deraadt@@
@
text
@/*	$OpenBSD: print-ppp.c,v 1.29 2015/11/16 00:16:39 mmcc Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifdef PPP
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/ioctl.h>

struct mbuf;
struct rtentry;
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>

#include <ctype.h>
#include <netdb.h>
#include <pcap.h>
#include <signal.h>
#include <stdio.h>

#include <netinet/if_ether.h>
#include "ethertype.h"

#include <net/ppp_defs.h>
#include "interface.h"
#include "addrtoname.h"
#include "extract.h"

struct protonames {
	u_short protocol;
	char *name;
};

static struct protonames protonames[] = {
	/*
	 * Protocol field values.
	 */
	{ PPP_IP,	"IP" },		/* Internet Protocol */
	{ PPP_XNS,	"XNS" },	/* Xerox NS */
	{ PPP_IPX,	"IPX" },	/* IPX Datagram (RFC1552) */
	{ PPP_VJC_COMP,	"VJC_UNCOMP" },	/* VJ compressed TCP */
	{ PPP_VJC_UNCOMP,"VJC_UNCOMP" },/* VJ uncompressed TCP */
	{ PPP_COMP,	"COMP" },	/* compressed packet */
	{ PPP_IPCP,	"IPCP" },	/* IP Control Protocol */
	{ PPP_IPXCP,	"IPXCP" },	/* IPX Control Protocol (RFC1552) */
	{ PPP_IPV6CP,	"IPV6CP" },	/* IPv6 Control Protocol */
	{ PPP_CCP,	"CCP" },	/* Compression Control Protocol */
	{ PPP_LCP,	"LCP" },	/* Link Control Protocol */
	{ PPP_PAP,	"PAP" },	/* Password Authentication Protocol */
	{ PPP_LQR,	"LQR" },	/* Link Quality Report protocol */
	{ PPP_CHAP,	"CHAP" },	/* Cryptographic Handshake Auth. Proto */
	{ PPP_IPV6,	"IPV6" },	/* Internet Protocol v6 */
};

/* LCP */

#define LCP_CONF_REQ	1
#define LCP_CONF_ACK	2
#define LCP_CONF_NAK	3
#define LCP_CONF_REJ	4
#define LCP_TERM_REQ	5
#define LCP_TERM_ACK	6
#define LCP_CODE_REJ	7
#define LCP_PROT_REJ	8
#define LCP_ECHO_REQ	9
#define LCP_ECHO_RPL	10
#define LCP_DISC_REQ	11

#define LCP_MIN	LCP_CONF_REQ
#define LCP_MAX LCP_DISC_REQ

static char *lcpcodes[] = {
	/*
	 * LCP code values (RFC1661, pp26)
	 */
	"Configure-Request",
	"Configure-Ack",
	"Configure-Nak",
	"Configure-Reject",
	"Terminate-Request",
	"Terminate-Ack",
 	"Code-Reject",
	"Protocol-Reject",
	"Echo-Request",
	"Echo-Reply",
	"Discard-Request",
};

#define LCPOPT_VEXT	0
#define LCPOPT_MRU	1
#define LCPOPT_ACCM	2
#define LCPOPT_AP	3
#define LCPOPT_QP	4
#define LCPOPT_MN	5
#define LCPOPT_PFC	7
#define LCPOPT_ACFC	8

#define LCPOPT_MIN 0
#define LCPOPT_MAX 24

static char *lcpconfopts[] = {
	"Vendor-Ext",
	"Max-Rx-Unit",
	"Async-Ctrl-Char-Map",
	"Auth-Prot",
	"Quality-Prot",
	"Magic-Number",
	"unassigned (6)",	
	"Prot-Field-Compr",
	"Add-Ctrl-Field-Compr",
	"FCS-Alternatives",
	"Self-Describing-Pad",
	"Numbered-Mode",
	"Multi-Link-Procedure",
	"Call-Back",
	"Connect-Time"
	"Compund-Frames",
	"Nominal-Data-Encap",
	"Multilink-MRRU",
	"Multilink-SSNHF",
	"Multilink-ED",
	"Proprietary",
	"DCE-Identifier",
	"Multilink-Plus-Proc",
	"Link-Discriminator",
	"LCP-Auth-Option",
};

/* CHAP */

#define CHAP_CHAL	1
#define CHAP_RESP	2
#define CHAP_SUCC	3
#define CHAP_FAIL	4

#define CHAP_CODEMIN 1
#define CHAP_CODEMAX 4

static char *chapcode[] = {
	"Challenge",
	"Response",
	"Success",
	"Failure",	
};

/* PAP */

#define PAP_AREQ	1
#define PAP_AACK	2
#define PAP_ANAK	3

#define PAP_CODEMIN	1
#define PAP_CODEMAX	3

static char *papcode[] = {
	"Authenticate-Request",
	"Authenticate-Ack",
	"Authenticate-Nak",
};

/* IPCP */

#define IPCP_CODE_CFG_REQ	1
#define IPCP_CODE_CFG_ACK	2
#define IPCP_CODE_CFG_NAK	3
#define IPCP_CODE_CFG_REJ	4
#define IPCP_CODE_TRM_REQ	5
#define IPCP_CODE_TRM_ACK	6
#define IPCP_CODE_COD_REJ	7

#define IPCP_CODE_MIN IPCP_CODE_CFG_REQ
#define IPCP_CODE_MAX IPCP_CODE_COD_REJ

#define IPCP_2ADDR	1
#define IPCP_CP		2
#define IPCP_ADDR	3

/* IPV6CP */

#define IPV6CP_CODE_CFG_REQ	1
#define IPV6CP_CODE_CFG_ACK	2
#define IPV6CP_CODE_CFG_NAK	3
#define IPV6CP_CODE_CFG_REJ	4
#define IPV6CP_CODE_TRM_REQ	5
#define IPV6CP_CODE_TRM_ACK	6
#define IPV6CP_CODE_COD_REJ	7

#define IPV6CP_CODE_MIN IPV6CP_CODE_CFG_REQ
#define IPV6CP_CODE_MAX IPV6CP_CODE_COD_REJ

#define IPV6CP_IFID	1

static int print_lcp_config_options(u_char *p);
static void handle_lcp(const u_char *p, int length);
static void handle_chap(const u_char *p, int length);
static void handle_ipcp(const u_char *p, int length);
static void handle_ipv6cp(const u_char *p, int length);
static void handle_pap(const u_char *p, int length);

struct pppoe_header {
	u_int8_t vertype;	/* PPPoE version/type */
	u_int8_t code;		/* PPPoE code (packet type) */
	u_int16_t sessionid;	/* PPPoE session id */
	u_int16_t len;		/* PPPoE payload length */
};
#define	PPPOE_CODE_SESSION	0x00	/* Session */
#define	PPPOE_CODE_PADO		0x07	/* Active Discovery Offer */
#define	PPPOE_CODE_PADI		0x09	/* Active Discovery Initiation */
#define	PPPOE_CODE_PADR		0x19	/* Active Discovery Request */
#define	PPPOE_CODE_PADS		0x65	/* Active Discovery Session-Confirm */
#define	PPPOE_CODE_PADT		0xa7	/* Active Discovery Terminate */
#define	PPPOE_TAG_END_OF_LIST		0x0000	/* End Of List */
#define	PPPOE_TAG_SERVICE_NAME		0x0101	/* Service Name */
#define	PPPOE_TAG_AC_NAME		0x0102	/* Access Concentrator Name */
#define	PPPOE_TAG_HOST_UNIQ		0x0103	/* Host Uniq */
#define	PPPOE_TAG_AC_COOKIE		0x0104	/* Access Concentratr Cookie */
#define	PPPOE_TAG_VENDOR_SPEC		0x0105	/* Vendor Specific */
#define	PPPOE_TAG_RELAY_SESSION		0x0110	/* Relay Session Id */
#define	PPPOE_TAG_MAX_PAYLOAD		0x0120	/* RFC 4638 Max Payload */
#define	PPPOE_TAG_SERVICE_NAME_ERROR	0x0201	/* Service Name Error */
#define	PPPOE_TAG_AC_SYSTEM_ERROR	0x0202	/* Acc. Concentrator Error */
#define	PPPOE_TAG_GENERIC_ERROR		0x0203	/* Generic Error */

void
ppp_hdlc_print(p, length)
	const u_char *p;
	int length;
{
	int proto = PPP_PROTOCOL(p);
	int i;

	for (i = sizeof(protonames) / sizeof(protonames[0]) - 1; i >= 0; i--) {
		if (proto == protonames[i].protocol) {
			printf("%s: ", protonames[i].name);

			switch(proto) {

			case PPP_LCP:
				handle_lcp(p, length);
				break;
			case PPP_CHAP:
				handle_chap(p, length);
				break;
			case PPP_PAP:
				handle_pap(p, length);
				break;
			case PPP_IPCP:
				handle_ipcp(p, length);
				break;
			case PPP_IPV6CP:
				handle_ipv6cp(p, length);
				break;
			}
			break;
		}
	}
	if (i < 0)
		printf("%04x: ", proto);
}

/* print LCP frame */

static void
handle_lcp(p, length)
	const u_char *p;
	int length;
{
	int x, j;
	u_char *ptr;

	TCHECK(*(p + 4));
	x = *(p + 4);

	if ((x >= LCP_MIN) && (x <= LCP_MAX))
		printf("%s", lcpcodes[x-1]);
	else {
		printf("0x%02x", x);
		return;
	}

	length -= 4;
	
	switch(x) {

	case LCP_CONF_REQ:
	case LCP_CONF_ACK:
	case LCP_CONF_NAK:
	case LCP_CONF_REJ:
		x = length;
		ptr = (u_char *)p+8;
		do {
			if((j = print_lcp_config_options(ptr)) == 0)
				break;
			x -= j;
			ptr += j;
		}
		while(x > 0);
		break;

	case LCP_ECHO_REQ:
	case LCP_ECHO_RPL:
		TCHECK2(*(p + 8), 4);
		printf(", Magic-Number=%d", ((*(p+ 8) << 24) + (*(p+9) << 16) +
					     (*(p+10) <<  8) + (*(p+11))));
		break;
	case LCP_TERM_REQ:
	case LCP_TERM_ACK:
	case LCP_CODE_REJ:
	case LCP_PROT_REJ:
	case LCP_DISC_REQ:
	default:
		break;
	}
	return;

trunc:
	printf("[|lcp]");
}

/* LCP config options */

static int
print_lcp_config_options(p)
	u_char *p;
{
	int len, opt;

	TCHECK2(*p, 2);
	len = *(p+1);
	opt = *p;

	if((opt >= LCPOPT_MIN) && (opt <= LCPOPT_MAX))
		printf(", %s", lcpconfopts[opt]);

	switch(opt) {
	case LCPOPT_MRU:
		if(len == 4) {
			TCHECK2(*(p + 2), 2);
			printf("=%d", (*(p+2) << 8) + *(p+3));
		}
		break;
	case LCPOPT_AP:
		if(len >= 4) {
			TCHECK2(*(p + 2), 2);
			if(*(p+2) == 0xc0 && *(p+3) == 0x23)
				printf(" PAP");
			else if(*(p+2) == 0xc2 && *(p+3) == 0x23) {
				printf(" CHAP/");
				TCHECK(*(p+4));
				switch(*(p+4)) {
				default:
					printf("unknown-algorithm-%d", *(p+4));
					break;
				case 5:
					printf("MD5");
					break;
				case 0x80:
					printf("Microsoft");
					break;
				}
			} else if(*(p+2) == 0xc2 && *(p+3) == 0x27)
					printf(" EAP");
			else if(*(p+2) == 0xc0 && *(p+3) == 0x27)
				printf(" SPAP");
			else if(*(p+2) == 0xc1 && *(p+3) == 0x23)
				printf(" Old-SPAP");
			else
				printf("unknown");
		}
		break;
	case LCPOPT_QP:
		if(len >= 4) {
			TCHECK2(*(p + 2), 2);
			if(*(p+2) == 0xc0 && *(p+3) == 0x25)
				printf(" LQR");
			else
				printf(" unknown");
		}
		break;
	case LCPOPT_MN:
		if(len == 6) {
			TCHECK2(*(p + 2), 4);
			printf("=%d", ((*(p+2) << 24) + (*(p+3) << 16) +
				       (*(p+4) <<  8) + (*(p+5))));
		}
		break;
	case LCPOPT_PFC:
		printf(" PFC");
		break;
	case LCPOPT_ACFC:
		printf(" ACFC");
		break;
	}
	return(len);

trunc:
	printf("[|lcp]");
	return 0;
}

/* CHAP */

static void
handle_chap(p, length)
	const u_char *p;
	int length;
{
	int x;
	u_char *ptr;

	TCHECK(*(p+4));
	x = *(p+4);

	if((x >= CHAP_CODEMIN) && (x <= CHAP_CODEMAX))
		printf("%s", chapcode[x-1]);
	else {
		printf("0x%02x", x);
		return;
	}

	length -= 4;
	
	switch(x) {
	case CHAP_CHAL:
	case CHAP_RESP:
		printf(", Value=");
		TCHECK(*(p+8));
		x = *(p+8);	/* value size */
		ptr = (u_char *)p+9;
		while(--x >= 0) {
			TCHECK(*ptr);
			printf("%02x", *ptr++);
		}
		x = length - *(p+8) - 1;
		printf(", Name=");
		while(--x >= 0) {
			TCHECK(*ptr);
			safeputchar(*ptr++);
		}
		break;
	}
	return;

trunc:
	printf("[|chap]");
}

/* PAP */

static void
handle_pap(p, length)
	const u_char *p;
	int length;
{
	int x;
	u_char *ptr;

	TCHECK(*(p+4));
	x = *(p+4);

	if((x >= PAP_CODEMIN) && (x <= PAP_CODEMAX))
		printf("%s", papcode[x-1]);
	else {
		printf("0x%02x", x);
		return;
	}

	length -= 4;

	switch(x) {
	case PAP_AREQ:
		printf(", Peer-Id=");
		TCHECK(*(p+8));
		x = *(p+8);	/* peerid size */
		ptr = (u_char *)p+9;
		while(--x >= 0) {
			TCHECK(*ptr);
			safeputchar(*ptr++);
		}
		TCHECK(*ptr);
		x = *ptr++;
		printf(", Passwd=");
		while(--x >= 0) {
			TCHECK(*ptr);
			safeputchar(*ptr++);
		}
		break;
	case PAP_AACK:
	case PAP_ANAK:		
		break;			
	}
	return;

trunc:
	printf("[|pap]");
}

/* IPCP */

static void
handle_ipcp(p, length)
	const u_char *p;
	int length;
{
	int x;

	TCHECK(*(p+4));
	x = *(p+4);

	if((x >= IPCP_CODE_MIN) && (x <= IPCP_CODE_MAX))
		printf("%s", lcpcodes[x-1]);	/* share table with LCP */
	else {
		printf("0x%02x", x);
		return;
	}

	length -= 4;

	TCHECK(*(p+8));	
	switch(*(p+8)) {
	case IPCP_2ADDR:
		printf(", IP-Addresses");
		TCHECK2(*(p+10), 8);
		printf(", Src=%d.%d.%d.%d",
		       *(p+10), *(p+11), *(p+12), *(p+13));
		printf(", Dst=%d.%d.%d.%d",
		       *(p+14), *(p+15), *(p+16), *(p+17));
		break;

	case IPCP_CP:
		printf(", IP-Compression-Protocol");
		break;

	case IPCP_ADDR:
		TCHECK2(*(p+10), 4);
		printf(", IP-Address=%d.%d.%d.%d",
		       *(p+10), *(p+11), *(p+12), *(p+13));
		break;
	default:
		printf(", Unknown IPCP code 0x%x", *(p+8));
		break;
	}
	return;

trunc:
	printf("[|ipcp]");
}

/* IPV6CP */

static void
handle_ipv6cp(p, length)
	const u_char *p;
	int length;
{
	int x;

	TCHECK(*(p+4));
	x = *(p+4);

	if((x >= IPV6CP_CODE_MIN) && (x <= IPV6CP_CODE_MAX))
		printf("%s", lcpcodes[x-1]);    /* share table with LCP */
	else {
		printf("0x%02x", x);
		return;
	}

	TCHECK(*(p+8));
	switch(*(p+8)) {
	case IPV6CP_IFID:
		TCHECK2(*(p + 10), 8);
		printf(", Interface-ID=%04x:%04x:%04x:%04x",
			EXTRACT_16BITS(p + 10),
			EXTRACT_16BITS(p + 12),
			EXTRACT_16BITS(p + 14),
			EXTRACT_16BITS(p + 16));
		break;

	default:
		printf(", Unknown IPV6CP code 0x%x", *(p+8));
		break;
	}
	return;

trunc:
	printf("[|ipv6cp]");
}

void
ppp_if_print(user, h, p)
	u_char *user;
	const struct pcap_pkthdr *h;
	const u_char *p;
{
	u_int length = h->len;
	u_int caplen = h->caplen;

	ts_print(&h->ts);

	if (caplen < PPP_HDRLEN) {
		printf("[|ppp]");
		goto out;
	}

	/*
	 * Some printers want to get back at the link level addresses,
	 * and/or check that they're not walking off the end of the packet.
	 * Rather than pass them all the way down, we set these globals.
	 */
	packetp = p;
	snapend = p + caplen;

	if (eflag)
		ppp_hdlc_print(p, length);

	length -= PPP_HDRLEN;

	switch(PPP_PROTOCOL(p)) {
	case PPP_IP:
	case ETHERTYPE_IP:
		ip_print((const u_char *)(p + PPP_HDRLEN), length);
		break;
	case PPP_IPV6:
	case ETHERTYPE_IPV6:
		ip6_print((const u_char *)(p + PPP_HDRLEN), length);
		break;
	case PPP_IPX:
	case ETHERTYPE_IPX:
		ipx_print((const u_char *)(p + PPP_HDRLEN), length);
		break;

#ifndef	PPP_MPLS
#define	PPP_MPLS	0x0281
#endif
	case PPP_MPLS:
		mpls_print((const u_char *)(p + PPP_HDRLEN), length);
		break;

	default:
		if(!eflag)
			ppp_hdlc_print(p, length);
		if(!xflag)
			default_print((const u_char *)(p + PPP_HDRLEN),
				      caplen - PPP_HDRLEN);
	}

	if (xflag)
		default_print((const u_char *)(p + PPP_HDRLEN),
			      caplen - PPP_HDRLEN);
out:
	putchar('\n');
}

void
ppp_ether_if_print(user, h, p)
	u_char *user;
	const struct pcap_pkthdr *h;
	const u_char *p;
{
	u_int16_t pppoe_sid, pppoe_len;
	u_int caplen = h->caplen;
	u_int16_t length = h->len;
	u_int16_t proto;
	int i;

	ts_print(&h->ts);

	packetp = p;
	snapend = p + caplen;

	if (eflag)
		printf("PPPoE ");

	if (caplen < sizeof(struct pppoe_header)) {
		printf("[|pppoe]");
		return;
	}

	if(eflag)
	{
		printf("\n\tcode ");
		switch (p[1]) {
		case PPPOE_CODE_PADI:
			printf("Initiation");
			break;
		case PPPOE_CODE_PADO:
			printf("Offer");
			break;
		case PPPOE_CODE_PADR:
			printf("Request");
			break;
		case PPPOE_CODE_PADS:
			printf("Confirm");
			break;
		case PPPOE_CODE_PADT:
			printf("Terminate");
			break;
		case PPPOE_CODE_SESSION:
			printf("Session");
			break;
		default:
			printf("Unknown(0x%02x)", p[1]);
			break;
		}
	}

	pppoe_sid = EXTRACT_16BITS(p + 2);
	pppoe_len = EXTRACT_16BITS(p + 4);

	if(eflag)
	    printf(", version %d, type %d, id 0x%04x, length %d",
		    (p[0] & 0xf), (p[0] & 0xf0) >> 4, pppoe_sid, pppoe_len);

	length -= sizeof(struct pppoe_header);
	caplen -= sizeof(struct pppoe_header);
	p += sizeof(struct pppoe_header);

	if (pppoe_len > caplen)
		pppoe_len = caplen;

	if (pppoe_len < 2) {
		printf("[|pppoe]");
		return;
	}
	proto = EXTRACT_16BITS(p);

	for (i = sizeof(protonames)/sizeof(protonames[0]) - 1; i >= 0; i--) {
		if (proto == protonames[i].protocol) {
			if (eflag)
				printf("\n\t%s: ", protonames[i].name);
			switch (proto) {
			case PPP_LCP:
				handle_lcp(p - 2, length + 2);
				break;
			case PPP_CHAP:
				handle_chap(p - 2, length + 2);
				break;
			case PPP_PAP:
				handle_pap(p - 2, length + 2);
				break;
			case PPP_IPCP:
				handle_ipcp(p - 2, length + 2);
				break;
			case PPP_IPV6CP:
				handle_ipv6cp(p - 2, length + 2);
				break;
			case PPP_IP:
				ip_print(p + 2, length - 2);
				break;
			case PPP_IPV6:
				ip6_print(p + 2, length - 2);
				break;
			case PPP_IPX:
				ipx_print(p + 2, length - 2);
			}
			break;
		}
	}
	if (i < 0)
		printf("\n\t%04x: ", proto);

	if (xflag)
	    default_print(p + 2, caplen - 2);
	putchar('\n');
}

int
pppoe_if_print(u_short ethertype, const u_char *p, u_int length, u_int caplen)
{
	u_int16_t pppoe_sid, pppoe_len;

	if (ethertype == ETHERTYPE_PPPOEDISC)
		printf("PPPoE-Discovery");
	else
		printf("PPPoE-Session");

	if (caplen < sizeof(struct pppoe_header)) {
		printf("[|pppoe]");
		return (1);
	}

	printf("\n\tcode ");
	switch (p[1]) {
	case PPPOE_CODE_PADI:
		printf("Initiation");
		break;
	case PPPOE_CODE_PADO:
		printf("Offer");
		break;
	case PPPOE_CODE_PADR:
		printf("Request");
		break;
	case PPPOE_CODE_PADS:
		printf("Confirm");
		break;
	case PPPOE_CODE_PADT:
		printf("Terminate");
		break;
	case PPPOE_CODE_SESSION:
		printf("Session");
		break;
	default:
		printf("Unknown(0x%02x)", p[1]);
		break;
	}

	pppoe_sid = EXTRACT_16BITS(p + 2);
	pppoe_len = EXTRACT_16BITS(p + 4);
	printf(", version %d, type %d, id 0x%04x, length %d",
	    (p[0] & 0xf), (p[0] & 0xf0) >> 4, pppoe_sid, pppoe_len);

	length -= sizeof(struct pppoe_header);
	caplen -= sizeof(struct pppoe_header);
	p += sizeof(struct pppoe_header);

	if (pppoe_len > caplen)
		pppoe_len = caplen;

	if (ethertype == ETHERTYPE_PPPOEDISC) {
		while (pppoe_len > 0) {
			u_int16_t t_type, t_len;

			if (pppoe_len < 4) {
				printf("\n\t[|pppoe]");
				break;
			}
			t_type = EXTRACT_16BITS(p);
			t_len = EXTRACT_16BITS(p + 2);

			pppoe_len -= 4;
			p += 4;

			if (pppoe_len < t_len) {
				printf("\n\t[|pppoe]");
				break;
			}

			printf("\n\ttag ");
			switch (t_type) {
			case PPPOE_TAG_END_OF_LIST:
				printf("End-Of-List");
				break;
			case PPPOE_TAG_SERVICE_NAME:
				printf("Service-Name");
				break;
			case PPPOE_TAG_AC_NAME:
				printf("AC-Name");
				break;
			case PPPOE_TAG_HOST_UNIQ:
				printf("Host-Uniq");
				break;
			case PPPOE_TAG_AC_COOKIE:
				printf("AC-Cookie");
				break;
			case PPPOE_TAG_VENDOR_SPEC:
				printf("Vendor-Specific");
				break;
			case PPPOE_TAG_RELAY_SESSION:
				printf("Relay-Session");
				break;
			case PPPOE_TAG_MAX_PAYLOAD:
				printf("PPP-Max-Payload");
				break;
			case PPPOE_TAG_SERVICE_NAME_ERROR:
				printf("Service-Name-Error");
				break;
			case PPPOE_TAG_AC_SYSTEM_ERROR:
				printf("AC-System-Error");
				break;
			case PPPOE_TAG_GENERIC_ERROR:
				printf("Generic-Error");
				break;
			default:
				printf("Unknown(0x%04x)", t_type);
			}
			printf(", length %u%s", t_len, t_len ? " " : "");

			if (t_len) {
				for (t_type = 0; t_type < t_len; t_type++) {
					if (isprint(p[t_type]))
						printf("%c", p[t_type]);
					else
						printf("\\%03o", p[t_type]);
				}
			}
			pppoe_len -= t_len;
			p += t_len;
		}
	}
	else if (ethertype == ETHERTYPE_PPPOE) {
		u_int16_t proto;
		int i;

		if (pppoe_len < 2) {
			printf("[|pppoe]");
			return (1);
		}
		proto = EXTRACT_16BITS(p);

		for (i = sizeof(protonames)/sizeof(protonames[0]) - 1; i >= 0;
		     i--) {
			if (proto == protonames[i].protocol) {
				printf("\n\t%s: ", protonames[i].name);
				switch (proto) {
				case PPP_LCP:
					handle_lcp(p - 2, length + 2);
					break;
				case PPP_CHAP:
					handle_chap(p - 2, length + 2);
					break;
				case PPP_PAP:
					handle_pap(p - 2, length + 2);
					break;
				case PPP_IPCP:
					handle_ipcp(p - 2, length + 2);
					break;
				case PPP_IPV6CP:
					handle_ipv6cp(p - 2, length + 2);
					break;
				case PPP_IP:
					ip_print(p + 2, length - 2);
					break;
				case PPP_IPV6:
					ip6_print(p + 2, length - 2);
					break;
				case PPP_IPX:
					ipx_print(p + 2, length - 2);
				}
				break;
			}
		}
		if (i < 0)
			printf("\n\t%04x: ", proto);
	}

	return (1);
}

#else

#include <sys/types.h>
#include <sys/time.h>

#include <stdio.h>

#include "interface.h"
void
ppp_if_print(user, h, p)
	u_char *user;
	const struct pcap_pkthdr *h;
	const u_char *p;
{
	error("not configured for ppp");
	/* NOTREACHED */
}
#endif
@


1.29
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.28 2015/01/16 06:40:21 deraadt Exp $	*/
d790 1
a790 4
pppoe_if_print(ethertype, p, length, caplen)
	u_short ethertype;
	const u_char *p;
	u_int length, caplen;
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.27 2014/08/14 12:44:44 mpi Exp $	*/
d615 1
a615 1
	register const u_char *p;
d617 2
a618 2
	register u_int length = h->len;
	register u_int caplen = h->caplen;
d680 1
a680 1
	register const u_char *p;
@


1.27
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.26 2011/12/28 22:41:55 sthen Exp $	*/
a24 1
#include <sys/param.h>
@


1.26
log
@Print PPP-Max-Payload headers (for RFC 4638 PPPoe), part of a larger diff
from Matt Dainty.  ok haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.25 2010/01/17 19:56:58 naddy Exp $	*/
a35 1
#include <netinet/in_systm.h>
@


1.25
log
@add a printer for IPV6CP (IPv6 Control Protocol); ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.24 2010/01/17 19:53:24 naddy Exp $	*/
d243 1
d887 3
@


1.24
log
@* remove a nonsensical print statement left over since antiquity
ok yasuoka@@

* add many missing truncation checks and don't output control
characters to the terminal
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.23 2010/01/13 11:15:20 naddy Exp $	*/
d70 1
d202 15
d221 1
d273 3
d572 40
d767 3
d939 3
@


1.23
log
@revert previous and allow reading the last element of the array; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.22 2009/11/12 00:02:16 deraadt Exp $	*/
a237 2
	printf("ID-%03d ", *(p+5));

d274 1
d305 1
d317 4
d329 5
a333 2
	int len	= *(p+1);
	int opt = *p;
d340 2
a341 1
		if(len == 4)
d343 1
d347 1
d352 1
d376 1
d384 2
a385 1
		if(len == 6)
d388 1
d398 4
d414 1
d430 1
d433 2
a434 1
		while(--x >= 0)
d436 1
d439 4
a442 2
		while(--x >= 0)
			printf("%c", *ptr++);
d445 4
d461 1
d476 1
d479 5
a483 2
		while(--x >= 0)
			printf("%c", *ptr++);
d486 4
a489 2
		while(--x >= 0)
			printf("%c", *ptr++);
d495 4
d510 1
d521 2
a522 1
	
d526 1
d538 1
d546 4
@


1.22
log
@fix read-one-beyond-of-array errors; ok sthen jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.21 2009/10/27 23:59:55 deraadt Exp $	*/
d328 1
a328 1
	if((opt >= LCPOPT_MIN) && (opt < LCPOPT_MAX))
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.20 2008/10/10 15:24:24 claudio Exp $	*/
d328 1
a328 1
	if((opt >= LCPOPT_MIN) && (opt <= LCPOPT_MAX))
@


1.20
log
@Fix -X output of ppp packets. Inspired by PR4624 and especially the patch
provided by canacar@@. I just modified it a bit to skip the data link proto
number as well. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.19 2007/10/07 16:41:05 deraadt Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id: print-ppp.c,v 1.19 2007/10/07 16:41:05 deraadt Exp $ (LBL)";
#endif
@


1.19
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.18 2007/07/09 06:01:05 canacar Exp $	*/
d26 1
a26 1
    "@@(#) $Id$ (LBL)";
d681 1
a681 3
	    default_print((const u_char *)
		(p + sizeof(struct pppoe_header)),
		 caplen - sizeof(struct pppoe_header));
@


1.18
log
@Handle IPv6 on PPP printer, from Stuart Henderson
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.17 2007/06/04 15:10:12 henning Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.17 2007/06/04 15:10:12 henning Exp $ (LBL)";
@


1.17
log
@do not inlcude ipx headers
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.16 2005/10/08 19:45:15 canacar Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.16 2005/10/08 19:45:15 canacar Exp $ (LBL)";
d80 1
d544 4
d668 3
d839 3
@


1.16
log
@Add a best effort mpls decoder. From Jason L. Wright.
Since the encapsulated protocol information is not always
available in the MPLS tag stack. The decoder attempts
to guess the protocol.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.15 2004/05/21 05:48:50 brad Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.15 2004/05/21 05:48:50 brad Exp $ (LBL)";
a42 3

#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
@


1.15
log
@add DLT_PPP_ETHER support plus some fixes for pppoe_if_print().

ok canacar@@

From: Marc Huber <pppoe at pro-bono-publico dot de>
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.14 2002/02/19 19:39:40 millert Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.14 2002/02/19 19:39:40 millert Exp $ (LBL)";
d549 7
@


1.14
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.13 2000/10/03 14:21:56 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.13 2000/10/03 14:21:56 ho Exp $ (LBL)";
d566 109
d688 1
a688 1
	if (length < sizeof(sizeof(struct pppoe_header))) {
d814 1
a814 1
					handle_lcp(p - 2, pppoe_len + 2);
d817 1
a817 1
					handle_chap(p - 2, pppoe_len + 2);
d820 1
a820 1
					handle_pap(p - 2, pppoe_len + 2);
d823 1
a823 1
					handle_ipcp(p - 2, pppoe_len + 2);
d826 1
a826 1
					ip_print(p + 2, pppoe_len - 2);
d829 1
a829 1
					ipx_print(p + 2, pppoe_len - 2);
@


1.13
log
@Compile with -Wall. Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.12 2000/07/31 05:11:09 jason Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.12 2000/07/31 05:11:09 jason Exp $ (LBL)";
a35 1
#ifdef __STDC__
a37 1
#endif
@


1.12
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.11 2000/06/20 04:51:54 jason Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.11 2000/06/20 04:51:54 jason Exp $ (LBL)";
a209 1
static int handle_lcp(const u_char *p, int length);
d211 4
a214 3
static int handle_chap(const u_char *p, int length);
static int handle_ipcp(const u_char *p, int length);
static int handle_pap(const u_char *p, int length);
d277 1
a277 1
static int
d397 1
a397 1
static int
d434 1
a434 1
static int
d473 1
a473 1
static int
@


1.11
log
@more info for pppoe strings
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.10 2000/02/18 14:39:35 jason Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.10 2000/02/18 14:39:35 jason Exp $ (LBL)";
d677 1
a677 1
			printf(", length %u", t_len);
@


1.10
log
@Add support for dumping PPPoE Discovery and Session packets
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.9 1999/09/16 17:36:33 brad Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.9 1999/09/16 17:36:33 brad Exp $ (LBL)";
d680 6
a685 3
				printf(", value %02x", p[0]);
				for (t_type = 1; t_type < t_len; t_type++)
					printf(":%02x", p[t_type]);
@


1.9
log
@remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.8 1999/02/16 03:45:11 deraadt Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.8 1999/02/16 03:45:11 deraadt Exp $ (LBL)";
d61 1
d216 23
d566 163
@


1.8
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ppp.c,v 1.7 1999/02/11 12:48:29 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.7 1999/02/11 12:48:29 mickey Exp $ (LBL)";
d71 13
a83 13
	PPP_IP,		"IP",		/* Internet Protocol */
	PPP_XNS,	"XNS",		/* Xerox NS */
	PPP_IPX,	"IPX",		/* IPX Datagram (RFC1552) */
	PPP_VJC_COMP,	"VJC_UNCOMP",	/* VJ compressed TCP */
	PPP_VJC_UNCOMP,	"VJC_UNCOMP",	/* VJ uncompressed TCP */
	PPP_COMP,	"COMP",		/* compressed packet */
	PPP_IPCP,	"IPCP",		/* IP Control Protocol */
	PPP_IPXCP,	"IPXCP",	/* IPX Control Protocol (RFC1552) */
	PPP_CCP,	"CCP",		/* Compression Control Protocol */
	PPP_LCP,	"LCP",		/* Link Control Protocol */
	PPP_PAP,	"PAP",		/* Password Authentication Protocol */
	PPP_LQR,	"LQR",		/* Link Quality Report protocol */
	PPP_CHAP,	"CHAP",		/* Cryptographic Handshake Auth. Proto*/
d221 1
a221 2
	int i, j, x;
	u_char *ptr;
d378 1
a378 1
	int x, j;
d415 1
a415 1
	int x, j;
d454 1
a454 2
	int x, j;
	u_char *ptr;
@


1.7
log
@print ppp; from isdn4bsd package by Hellmuth Michaellis <mh@@hcs.de>
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.6 1997/07/25 20:12:27 mickey Exp $ (LBL)";
d336 1
a336 1
					printf("Micro$oft");
d469 1
a469 2
	switch(*(p+8))
	{
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ppp.c,v 1.5 1996/12/12 16:22:28 bitblt Exp $ (LBL)";
d46 3
d55 4
d62 152
a213 2
/* XXX This goes somewhere else. */
#define PPP_HDRLEN 4
d216 282
a497 2
ppp_if_print(u_char *user, const struct pcap_pkthdr *h,
	     register const u_char *p)
a500 1
	const struct ip *ip;
d518 1
a518 2
		printf("%c %4d %02x %04x: ", p[0] ? 'O' : 'I', length,
		       p[1], ntohs(*(u_short *)&p[2]));
d521 18
a538 2
	ip = (struct ip *)(p + PPP_HDRLEN);
	ip_print((const u_char *)ip, length);
d541 2
a542 1
		default_print((const u_char *)ip, caplen - PPP_HDRLEN);
d546 1
d548 1
d556 4
a559 1
ppp_if_print(u_char *user, const struct pcap_pkthdr *h, const u_char *p)
@


1.5
log
@*** empty log message ***
@
text
@d24 1
a24 1
    "@@(#) $Header: print-ppp.c,v 1.24 96/12/10 23:23:12 leres Exp $ (LBL)";
d34 1
a34 1
#if __STDC__
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d23 2
a24 2
static  char rcsid[] =
	"@@(#)Header: print-ppp.c,v 1.21 96/06/03 02:54:07 leres Exp (LBL)";
d60 2
a61 2
	register int length = h->len;
	register int caplen = h->caplen;
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-ppp.c,v 1.3 1995/03/06 19:11:27 mycroft Exp $	*/
/*	$NetBSD: print-ppp.c,v 1.3 1995/03/06 19:11:27 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1990, 1991, 1993, 1994
d26 1
a26 1
	"@@(#)Header: print-ppp.c,v 1.18 94/06/10 17:01:37 mccanne Exp (LBL)";
d36 4
a46 1
#include <errno.h>
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
