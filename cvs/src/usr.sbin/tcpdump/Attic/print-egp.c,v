head	1.7;
access;
symbols
	OPENBSD_3_1:1.6.0.8
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2002.09.18.08.51.17;	author jakob;	state dead;
branches;
next	1.6;

1.6
date	2000.10.03.14.31.56;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.39;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.20;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.22;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove egp support; unresolved non-bsd license for a decoder of protocol that
noone uses anymore is not worth the amount of work needed to be resolved.
@
text
@/*	$OpenBSD: print-egp.c,v 1.6 2000/10/03 14:31:56 ho Exp $	*/

/*
 * Copyright (c) 1991, 1992, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Lawrence Berkeley Laboratory,
 * Berkeley, CA.  The name of the University may not be used to
 * endorse or promote products derived from this software without
 * specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Initial contribution from Jeff Honig (jch@@MITCHELL.CIT.CORNELL.EDU).
 */

#ifndef lint
static const char rcsid[] =
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-egp.c,v 1.6 2000/10/03 14:31:56 ho Exp $ (LBL)";
#endif

#include <sys/param.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>

#include <netdb.h>
#include <stdio.h>

#include "interface.h"
#include "addrtoname.h"

struct egp_packet {
	u_char  egp_version;
#define	EGP_VERSION	2
	u_char  egp_type;
#define  EGPT_ACQUIRE	3
#define  EGPT_REACH	5
#define  EGPT_POLL	2
#define  EGPT_UPDATE	1
#define  EGPT_ERROR	8
	u_char  egp_code;
#define  EGPC_REQUEST	0
#define  EGPC_CONFIRM	1
#define  EGPC_REFUSE	2
#define  EGPC_CEASE	3
#define  EGPC_CEASEACK	4
#define  EGPC_HELLO	0
#define  EGPC_HEARDU	1
	u_char  egp_status;
#define  EGPS_UNSPEC	0
#define  EGPS_ACTIVE	1
#define  EGPS_PASSIVE	2
#define  EGPS_NORES	3
#define  EGPS_ADMIN	4
#define  EGPS_GODOWN	5
#define  EGPS_PARAM	6
#define  EGPS_PROTO	7
#define  EGPS_INDET	0
#define  EGPS_UP	1
#define  EGPS_DOWN	2
#define  EGPS_UNSOL	0x80
	u_short  egp_checksum;
	u_short  egp_as;
	u_short  egp_sequence;
	union {
		u_short  egpu_hello;
		u_char egpu_gws[2];
		u_short  egpu_reason;
#define  EGPR_UNSPEC	0
#define  EGPR_BADHEAD	1
#define  EGPR_BADDATA	2
#define  EGPR_NOREACH	3
#define  EGPR_XSPOLL	4
#define  EGPR_NORESP	5
#define  EGPR_UVERSION	6
	} egp_handg;
#define  egp_hello  egp_handg.egpu_hello
#define  egp_intgw  egp_handg.egpu_gws[0]
#define  egp_extgw  egp_handg.egpu_gws[1]
#define  egp_reason  egp_handg.egpu_reason
	union {
		u_short  egpu_poll;
		u_int32_t egpu_sourcenet;
	} egp_pands;
#define  egp_poll  egp_pands.egpu_poll
#define  egp_sourcenet  egp_pands.egpu_sourcenet
};

char *egp_acquire_codes[] = {
	"request",
	"confirm",
	"refuse",
	"cease",
	"cease_ack"
};

char *egp_acquire_status[] = {
	"unspecified",
	"active_mode",
	"passive_mode",
	"insufficient_resources",
	"administratively_prohibited",
	"going_down",
	"parameter_violation",
	"protocol_violation"
};

char *egp_reach_codes[] = {
	"hello",
	"i-h-u"
};

char *egp_status_updown[] = {
	"indeterminate",
	"up",
	"down"
};

char *egp_reasons[] = {
	"unspecified",
	"bad_EGP_header_format",
	"bad_EGP_data_field_format",
	"reachability_info_unavailable",
	"excessive_polling_rate",
	"no_response",
	"unsupported_version"
};

static void
egpnrprint(register const struct egp_packet *egp, register u_int length)
{
	register const u_char *cp;
	u_int32_t addr;
	register u_int32_t net;
	register u_int netlen;
	int gateways, distances, networks;
	int t_gateways;
	char *comma;

	addr = egp->egp_sourcenet;
	if (IN_CLASSA(addr)) {
		net = addr & IN_CLASSA_NET;
		netlen = 1;
	} else if (IN_CLASSB(addr)) {
		net = addr & IN_CLASSB_NET;
		netlen = 2;
	} else if (IN_CLASSC(addr)) {
		net = addr & IN_CLASSC_NET;
		netlen = 3;
	} else {
		net = 0;
		netlen = 0;
	}
	cp = (u_char *)(egp + 1);

	t_gateways = egp->egp_intgw + egp->egp_extgw;
	for (gateways = 0; gateways < t_gateways; ++gateways) {
		/* Pickup host part of gateway address */
		addr = 0;
		TCHECK2(cp[0], 4 - netlen);
		switch (netlen) {

		case 1:
			addr = *cp++;
			/* fall through */
		case 2:
			addr = (addr << 8) | *cp++;
			/* fall through */
		case 3:
			addr = (addr << 8) | *cp++;
		}
		addr |= net;
		TCHECK2(cp[0], 1);
		distances = *cp++;
		printf(" %s %s ",
		       gateways < (int)egp->egp_intgw ? "int" : "ext",
		       ipaddr_string(&addr));

		comma = "";
		putchar('(');
		while (--distances >= 0) {
			TCHECK2(cp[0], 2);
			printf("%sd%d:", comma, (int)*cp++);
			comma = ", ";
			networks = *cp++;
			while (--networks >= 0) {
				/* Pickup network number */
				TCHECK2(cp[0], 1);
				addr = (u_int32_t)*cp++ << 24;
				if (IN_CLASSB(addr)) {
					TCHECK2(cp[0], 1);
					addr |= (u_int32_t)*cp++ << 16;
				} else if (!IN_CLASSA(addr)) {
					TCHECK2(cp[0], 2);
					addr |= (u_int32_t)*cp++ << 16;
					addr |= (u_int32_t)*cp++ << 8;
				}
				printf(" %s", ipaddr_string(&addr));
			}
		}
		putchar(')');
	}
	return;
trunc:
	fputs("[|]", stdout);
}

void
egp_print(register const u_char *bp, register u_int length,
	  register const u_char *bp2)
{
	register const struct egp_packet *egp;
	register const struct ip *ip;
	register int status;
	register int code;
	register int type;

	egp = (struct egp_packet *)bp;
	ip = (struct ip *)bp2;
        (void)printf("%s > %s: egp: ",
		     ipaddr_string(&ip->ip_src),
		     ipaddr_string(&ip->ip_dst));

	if (egp->egp_version != EGP_VERSION) {
		printf("[version %d]", egp->egp_version);
		return;
	}
	printf("as:%d seq:%d", ntohs(egp->egp_as), ntohs(egp->egp_sequence));

	type = egp->egp_type;
	code = egp->egp_code;
	status = egp->egp_status;

	switch (type) {
	case EGPT_ACQUIRE:
		printf(" acquire");
		switch (code) {
		case EGPC_REQUEST:
		case EGPC_CONFIRM:
			printf(" %s", egp_acquire_codes[code]);
			switch (status) {
			case EGPS_UNSPEC:
			case EGPS_ACTIVE:
			case EGPS_PASSIVE:
				printf(" %s", egp_acquire_status[status]);
				break;

			default:
				printf(" [status %d]", status);
				break;
			}
			printf(" hello:%d poll:%d",
			       ntohs(egp->egp_hello),
			       ntohs(egp->egp_poll));
			break;

		case EGPC_REFUSE:
		case EGPC_CEASE:
		case EGPC_CEASEACK:
			printf(" %s", egp_acquire_codes[code]);
			switch (status ) {
			case EGPS_UNSPEC:
			case EGPS_NORES:
			case EGPS_ADMIN:
			case EGPS_GODOWN:
			case EGPS_PARAM:
			case EGPS_PROTO:
				printf(" %s", egp_acquire_status[status]);
				break;

			default:
				printf("[status %d]", status);
				break;
			}
			break;

		default:
			printf("[code %d]", code);
			break;
		}
		break;

	case EGPT_REACH:
		switch (code) {

		case EGPC_HELLO:
		case EGPC_HEARDU:
			printf(" %s", egp_reach_codes[code]);
			if (status <= EGPS_DOWN)
				printf(" state:%s", egp_status_updown[status]);
			else
				printf(" [status %d]", status);
			break;

		default:
			printf("[reach code %d]", code);
			break;
		}
		break;

	case EGPT_POLL:
		printf(" poll");
		if (egp->egp_status <= EGPS_DOWN)
			printf(" state:%s", egp_status_updown[status]);
		else
			printf(" [status %d]", status);
		printf(" net:%s", ipaddr_string(&egp->egp_sourcenet));
		break;

	case EGPT_UPDATE:
		printf(" update");
		if (status & EGPS_UNSOL) {
			status &= ~EGPS_UNSOL;
			printf(" unsolicited");
		}
		if (status <= EGPS_DOWN)
			printf(" state:%s", egp_status_updown[status]);
		else
			printf(" [status %d]", status);
		printf(" %s int %d ext %d",
		       ipaddr_string(&egp->egp_sourcenet),
		       egp->egp_intgw,
		       egp->egp_extgw);
		if (vflag)
			egpnrprint(egp, length);
		break;

	case EGPT_ERROR:
		printf(" error");
		if (status <= EGPS_DOWN)
			printf(" state:%s", egp_status_updown[status]);
		else
			printf(" [status %d]", status);

		if (ntohs(egp->egp_reason) <= EGPR_UVERSION)
			printf(" %s", egp_reasons[ntohs(egp->egp_reason)]);
		else
			printf(" [reason %d]", ntohs(egp->egp_reason));
		break;

	default:
		printf("[type %d]", type);
		break;
	}
}
@


1.6
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-egp.c,v 1.5 1996/12/12 16:22:39 bitblt Exp $ (LBL)";
@


1.5
log
@*** empty log message ***
@
text
@d1 2
d25 1
a25 1
    "@@(#) $Header: print-egp.c,v 1.23 96/11/05 13:30:35 leres Exp $ (LBL)";
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d22 2
a23 2
static char rcsid[] =
    "@@(#) Header: print-egp.c,v 1.19 96/06/23 02:11:45 leres Exp (LBL)";
d139 1
a139 1
egpnrprint(register const struct egp_packet *egp, register int length)
d141 1
a141 2
	register const u_char *cp, *ep;
#define TCHECK(n) if (cp > ep - n) goto trunc
d144 1
a144 1
	register int netlen;
a163 1
	ep = snapend;
d169 1
a169 1
		TCHECK(4 - netlen);
d182 1
a182 1
		TCHECK(1);
d185 1
a185 1
		       gateways < egp->egp_intgw ? "int" : "ext",
d191 1
a191 1
			TCHECK(2);
d197 1
a197 1
				TCHECK(1);
d200 1
a200 1
					TCHECK(1);
d203 1
a203 1
					TCHECK(2);
d218 1
a218 1
egp_print(register const u_char *bp, register int length,
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-egp.c,v 1.2 1995/03/06 19:11:09 mycroft Exp $	*/
/*	$NetBSD: print-egp.c,v 1.2 1995/03/06 19:11:09 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1991, 1992, 1993, 1994
d18 1
a18 1
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d25 1
a25 1
    "@@(#) Header: print-egp.c,v 1.14 94/06/20 19:44:38 leres Exp (LBL)";
d94 1
a94 1
		u_int32 egpu_sourcenet;
d145 2
a146 2
	register u_int32 addr;
	register u_int32 net;
d190 1
a190 1
		       intoa(addr));
d202 1
a202 1
				addr = (u_int32)*cp++ << 24;
d205 1
a205 1
					addr |= (u_int32)*cp++ << 16;
d208 2
a209 2
					addr |= (u_int32)*cp++ << 16;
					addr |= (u_int32)*cp++ << 8;
d211 1
a211 1
				printf(" %s", intoa(addr));
d320 1
a320 1
		printf(" net:%s", intoa(egp->egp_sourcenet));
d334 1
a334 1
		       intoa(egp->egp_sourcenet),
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
