head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.2
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.8.0.10
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.7.0.18
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.22
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.20
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.16
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.14
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.12
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.10
	OPENBSD_5_0:1.7.0.8
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.6
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.12
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.10
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.8
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.6
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2017.09.08.19.10.57;	author brynet;	state Exp;
branches;
next	1.9;
commitid	Zjq9j60IOf1zHWPz;

1.9
date	2017.06.14.20.48.54;	author akfaew;	state Exp;
branches;
next	1.8;
commitid	npjVE26BsZCc6eQP;

1.8
date	2015.07.14.20.23.40;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	KnDOzicNjGqmISR3;

1.7
date	2009.08.25.06.59.17;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.18.21.35.11;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.25.10.35.14;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.06.18.44.50;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.15.13.13.05;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.31.15.13.03;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.19.44.55;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.10
log
@fork+exec model for tcpdump(8); re-exec the privileged child after fork

While tcpdump isn't a daemon in the traditional sense, it's not uncommon
for people to have long running sessions.  At least on OpenBSD, this is
even safe thanks to the existing privsep design by otto@@, canacar@@ and
pledge(2) work done by deraadt.

ok deraadt@@
@
text
@/*
 * Copyright (c) 2003 Can Erkin Acar
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _PRIVSEP_H_
#define _PRIVSEP_H_

#include <pcap-int.h>

#define TCPDUMP_MAGIC 0xa1b2c3d4

/* file ids used by priv_getlines */
#define FTAB_PFOSFP	0

enum cmd_types {
	PRIV_OPEN_BPF,		/* open a bpf descriptor */
	PRIV_OPEN_DUMP,		/* open dump file for reading */
	PRIV_OPEN_OUTPUT,	/* open output file */
	PRIV_SETFILTER,		/* set a bpf read filter */
	PRIV_GETHOSTBYADDR,	/* resolve numeric address into hostname */
	PRIV_ETHER_NTOHOST,	/* translate ethernet address into host name */
	PRIV_GETRPCBYNUMBER,	/* translate rpc number into name */
	PRIV_GETSERVENTRIES,	/* get the service entries table */
	PRIV_GETPROTOENTRIES,	/* get the ip protocol entries table */
	PRIV_LOCALTIME,		/* return localtime */
	PRIV_GETLINES,		/* get lines from a file */
	PRIV_INIT_DONE,		/* signal that the initialization is done */
	PRIV_PCAP_STATS		/* get pcap_stats() results */
};

struct ether_addr;

/* Privilege separation */
int	priv_init(int, char **);
__dead void priv_exec(int, char **);
void    priv_init_done(void);

int	setfilter(int, int, char *);
int	pcap_live(const char *, int, int, u_int, u_int);

struct bpf_program *priv_pcap_setfilter(pcap_t *, int, u_int32_t);
pcap_t *priv_pcap_live(const char *, int, int, int, char *, u_int,
	    u_int);
pcap_t *priv_pcap_offline(const char *, char *);

size_t	priv_gethostbyaddr(char *, size_t, int, char *, size_t);
size_t	priv_ether_ntohost(char *, size_t, struct ether_addr *);
size_t	priv_getrpcbynumber(int, char *, size_t);

struct tm *priv_localtime(const time_t *);

/* Start getting service entries */
void	priv_getserventries(void);

/* Retrieve a single service entry, should be called repeatedly after
   calling priv_getserventries() until it returns zero */
size_t	priv_getserventry(char *, size_t, int *, char *, size_t);

/* Start getting ip protocol entries */
void	priv_getprotoentries(void);

/* Retrieve a single protocol entry, should be called repeatedly after
   calling priv_getprotoentries() until it returns zero */
size_t	priv_getprotoentry(char *, size_t, int *);

/* Start getting lines from a file */
void	priv_getlines(size_t);

/* Retrieve a single line from a file, should be called repeatedly after
   calling priv_getlines() until it returns zero */
size_t	priv_getline(char *, size_t);

/* Return the pcap statistics upon completion */
int	priv_pcap_stats(struct pcap_stat *);

pcap_dumper_t *priv_pcap_dump_open(pcap_t *, char *);

/* File descriptor send/recv */
void	send_fd(int, int);
int	receive_fd(int);

/* communications over the channel */
int	may_read(int, void *, size_t);
void	must_read(int, void *, size_t);
void	must_write(int, const void *, size_t);
size_t	read_block(int, char *, size_t, const char *);
size_t	read_string(int, char *, size_t, const char *);
void	write_block(int, size_t, const char *);
void	write_command(int, int);
void	write_string(int, const char *);
void	write_zero(int);

extern int priv_fd;

#endif
@


1.9
log
@Don't support loading appletalk addresses from /etc/appletalk.names.

OK deraadt@@
@
text
@d47 1
@


1.8
log
@Move the BIOCGSTATS ioctl operation done by the tcpdump process
(at ^C time) into a services provided by the privsep monitor.
ok canacar
@
text
@d25 1
a25 2
#define FTAB_APPLETALK	0
#define FTAB_PFOSFP	1
@


1.7
log
@djm accidentally changed the type of dirfilt in the prototypes
of pcap_live and priv_pcap_live in rev 1.6 to differ from the implementations,
change the type back to what it was.

ok djm@@
@
text
@d40 2
a41 1
	PRIV_INIT_DONE          /* signal that the initialization is done */
d84 3
@


1.6
log
@add filtering on direction; ok mpf@@ deraadt@@ feedback jmc@@
@
text
@d50 1
a50 1
int	pcap_live(const char *, int, int, u_int, pcap_direction_t);
d54 1
a54 1
	    pcap_direction_t);
@


1.5
log
@whitespace
@
text
@d50 1
a50 1
int	pcap_live(const char *, int, int, u_int);
d53 2
a54 1
pcap_t *priv_pcap_live(const char *, int, int, int, char *, u_int);
@


1.4
log
@add support for multiple DLTs using the -L and -y options.

ok canacar@@
@
text
@d40 1
a40 1
       PRIV_INIT_DONE          /* signal that the initialization is done */
@


1.3
log
@Naming consistency. From Alexander Guy. ok canacar@@
@
text
@d50 1
a50 1
int	pcap_live(const char *, int, int);
d53 1
a53 1
pcap_t *priv_pcap_live(const char *, int, int, int, char *);
@


1.2
log
@general cleanup and better SIGCHLD handling from millert@@
ok canacar@@
@
text
@d40 1
a40 1
	PRIV_DONE_INIT		/* signal that the initialization is done */
@


1.1
log
@privilege separated tcpdump, joint work with otto@@

tested by avsm@@ vincent@@ dhartmei@@ markus@@ hshoexer@@ and others
go for it deraadt@@
@
text
@d67 1
a67 2
size_t	priv_getserventry(char *name, size_t name_len, int *port, char *prot,
    size_t prot_len);
d74 1
a74 1
size_t	priv_getprotoentry(char *name, size_t name_len, int *num);
d96 1
a96 1
void	write_command(int fd, int cmd);
@

