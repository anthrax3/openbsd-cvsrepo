head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.24
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.22
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.20
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.18
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.16
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.14
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.12
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.10
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.6
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	enjTsnD5UO6xazKc;

1.18
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2014.11.20.04.01.01;	author jsg;	state Exp;
branches;
next	1.16;
commitid	kVjw1k1p17TpqgiI;

1.16
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.15;
commitid	yLXrOcgrag4eS8u4;

1.15
date	2013.12.03.00.21.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.13.08.32.17;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.03.14.31.58;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.26.21.35.43;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	99.09.16.20.58.47;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.20.12.27;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.12.12.16.22.27;	author bitblt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.18.21.47.57;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.30;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.36;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@/*	$OpenBSD: print-sl.c,v 1.18 2015/01/16 06:40:21 deraadt Exp $	*/

/*
 * Copyright (c) 1989, 1990, 1991, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifdef HAVE_NET_SLIP_H
#include <sys/time.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

struct rtentry;
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>

#include <net/slcompress.h>
#include <net/slip.h>

#include <ctype.h>
#include <netdb.h>
#include <pcap.h>
#include <stdio.h>
#include <limits.h>

#include "interface.h"
#include "addrtoname.h"
#include "extract.h"			/* must come after interface.h */

static u_int lastlen[2][256];
static u_int lastconn = 255;

static void sliplink_print(const u_char *, const struct ip *, u_int);
static void compressed_sl_print(const u_char *, const struct ip *, u_int, int);

/* XXX BSD/OS 2.1 compatibility */
#if !defined(SLIP_HDRLEN) && defined(SLC_BPFHDR)
#define SLIP_HDRLEN SLC_BPFHDR
#define SLX_DIR 0
#define SLX_CHDR (SLC_BPFHDRLEN - 1)
#define CHDR_LEN (SLC_BPFHDR - SLC_BPFHDRLEN)
#endif

/* XXX needs more hacking to work right */

void
sl_if_print(u_char *user, const struct pcap_pkthdr *h, const u_char *p)
{
	u_int caplen = h->caplen;
	u_int length = h->len;
	const struct ip *ip;

	ts_print(&h->ts);

	if (caplen < SLIP_HDRLEN || length < SLIP_HDRLEN) {
		printf("[|slip]");
		goto out;
	}
	/*
	 * Some printers want to get back at the link level addresses,
	 * and/or check that they're not walking off the end of the packet.
	 * Rather than pass them all the way down, we set these globals.
	 */
	packetp = p;
	snapend = p + caplen;

	length -= SLIP_HDRLEN;

	ip = (struct ip *)(p + SLIP_HDRLEN);

	if (eflag)
		sliplink_print(p, ip, length);

	switch (ip->ip_v) {
	case 4:
		ip_print((u_char *)ip, length);
		break;
#ifdef INET6
	case 6:
		ip6_print((u_char *)ip, length);
		break;
#endif
	default:
		printf ("ip v%d", ip->ip_v);
	}

	if (xflag)
		default_print((u_char *)ip, caplen - SLIP_HDRLEN);
 out:
	putchar('\n');
}


void
sl_bsdos_if_print(u_char *user, const struct pcap_pkthdr *h, const u_char *p)
{
	u_int caplen = h->caplen;
	u_int length = h->len;
	const struct ip *ip;

	ts_print(&h->ts);

	if (caplen < SLIP_HDRLEN) {
		printf("[|slip]");
		goto out;
	}
	/*
	 * Some printers want to get back at the link level addresses,
	 * and/or check that they're not walking off the end of the packet.
	 * Rather than pass them all the way down, we set these globals.
	 */
	packetp = p;
	snapend = p + caplen;

	length -= SLIP_HDRLEN;

	ip = (struct ip *)(p + SLIP_HDRLEN);

#ifdef notdef
	if (eflag)
		sliplink_print(p, ip, length);
#endif

	ip_print((u_char *)ip, length);

	if (xflag)
		default_print((u_char *)ip, caplen - SLIP_HDRLEN);
 out:
	putchar('\n');
}

static void
sliplink_print(const u_char *p, const struct ip *ip, u_int length)
{
	int dir;
	u_int hlen;

	dir = p[SLX_DIR];
	putchar(dir == SLIPDIR_IN ? 'I' : 'O');
	putchar(' ');

	if (nflag) {
		/* XXX just dump the header */
		int i;

		for (i = SLX_CHDR; i < SLX_CHDR + CHDR_LEN - 1; ++i)
			printf("%02x.", p[i]);
		printf("%02x: ", p[SLX_CHDR + CHDR_LEN - 1]);
		return;
	}
	switch (p[SLX_CHDR] & 0xf0) {

	case TYPE_IP:
		printf("ip %d: ", length + SLIP_HDRLEN);
		break;

	case TYPE_UNCOMPRESSED_TCP:
		/*
		 * The connection id is stored in the IP protocol field.
		 * Get it from the link layer since sl_uncompress_tcp()
		 * has restored the IP header copy to IPPROTO_TCP.
		 */
		lastconn = ((struct ip *)&p[SLX_CHDR])->ip_p;
		hlen = ip->ip_hl;
		hlen += ((struct tcphdr *)&((int *)ip)[hlen])->th_off;
		lastlen[dir][lastconn] = length - (hlen << 2);
		printf("utcp %d: ", lastconn);
		break;

	default:
		if (p[SLX_CHDR] & TYPE_COMPRESSED_TCP) {
			compressed_sl_print(&p[SLX_CHDR], ip,
			    length, dir);
			printf(": ");
		} else
			printf("slip-%d!: ", p[SLX_CHDR]);
	}
}

static const u_char *
print_sl_change(const char *str, const u_char *cp)
{
	u_int i;

	if ((i = *cp++) == 0) {
		i = EXTRACT_16BITS(cp);
		cp += 2;
	}
	printf(" %s%d", str, i);
	return (cp);
}

static const u_char *
print_sl_winchange(const u_char *cp)
{
	short i;

	if ((i = *cp++) == 0) {
		i = EXTRACT_16BITS(cp);
		cp += 2;
	}
	if (i >= 0)
		printf(" W+%d", i);
	else
		printf(" W%d", i);
	return (cp);
}

static void
compressed_sl_print(const u_char *chdr, const struct ip *ip,
		    u_int length, int dir)
{
	const u_char *cp = chdr;
	u_int flags, hlen;

	flags = *cp++;
	if (flags & NEW_C) {
		lastconn = *cp++;
		printf("ctcp %d", lastconn);
	} else
		printf("ctcp *");

	/* skip tcp checksum */
	cp += 2;

	switch (flags & SPECIALS_MASK) {
	case SPECIAL_I:
		printf(" *SA+%d", lastlen[dir][lastconn]);
		break;

	case SPECIAL_D:
		printf(" *S+%d", lastlen[dir][lastconn]);
		break;

	default:
		if (flags & NEW_U)
			cp = print_sl_change("U=", cp);
		if (flags & NEW_W)
			cp = print_sl_winchange(cp);
		if (flags & NEW_A)
			cp = print_sl_change("A+", cp);
		if (flags & NEW_S)
			cp = print_sl_change("S+", cp);
		break;
	}
	if (flags & NEW_I)
		cp = print_sl_change("I+", cp);

	/*
	 * 'hlen' is the length of the uncompressed TCP/IP header (in words).
	 * 'cp - chdr' is the length of the compressed header.
	 * 'length - hlen' is the amount of data in the packet.
	 */
	hlen = ip->ip_hl;
	hlen += ((struct tcphdr *)&((int32_t *)ip)[hlen])->th_off;
	lastlen[dir][lastconn] = length - (hlen << 2);
	printf(" %d (%d)", lastlen[dir][lastconn], (int)(cp - chdr));
}
#else
#include <sys/types.h>
#include <sys/time.h>

#include <pcap.h>
#include <stdio.h>

#include "interface.h"

void
sl_if_print(u_char *user, const struct pcap_pkthdr *h, const u_char *p)
{

	error("not configured for slip");
	/* NOTREACHED */
}

void
sl_bsdos_if_print(u_char *user, const struct pcap_pkthdr *h, const u_char *p)
{

	error("not configured for slip");
	/* NOTREACHED */
}
#endif
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-sl.c,v 1.17 2014/11/20 04:01:01 jsg Exp $	*/
d71 3
a73 3
	register u_int caplen = h->caplen;
	register u_int length = h->len;
	register const struct ip *ip;
d119 3
a121 3
	register u_int caplen = h->caplen;
	register u_int length = h->len;
	register const struct ip *ip;
d155 1
a155 2
sliplink_print(register const u_char *p, register const struct ip *ip,
	       register u_int length)
d166 1
a166 1
		register int i;
d203 1
a203 1
print_sl_change(const char *str, register const u_char *cp)
d205 1
a205 1
	register u_int i;
d216 1
a216 1
print_sl_winchange(register const u_char *cp)
d218 1
a218 1
	register short i;
d235 2
a236 2
	register const u_char *cp = chdr;
	register u_int flags, hlen;
@


1.17
log
@sanity check the length of the packet in the pcap header
fixes a crash found by the afl fuzzer

ok djm@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-sl.c,v 1.16 2014/08/14 12:44:44 mpi Exp $	*/
a24 1
#include <sys/param.h>
a27 1
#include <sys/mbuf.h>
d46 1
@


1.16
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-sl.c,v 1.15 2013/12/03 00:21:21 deraadt Exp $	*/
d78 1
a78 1
	if (caplen < SLIP_HDRLEN) {
@


1.15
log
@no need for timeb.h
@
text
@d1 1
a1 1
/*	$OpenBSD: print-sl.c,v 1.14 2009/10/27 23:59:55 deraadt Exp $	*/
a35 1
#include <netinet/in_systm.h>
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-sl.c,v 1.13 2007/10/07 16:41:05 deraadt Exp $	*/
a26 1
#include <sys/timeb.h>
@


1.13
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-sl.c,v 1.12 2002/02/19 19:39:40 millert Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.12
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-sl.c,v 1.11 2000/10/13 08:32:17 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-sl.c,v 1.11 2000/10/13 08:32:17 jakob Exp $ (LBL)";
@


1.11
log
@fix build on alpha with -Werror; David Leonard <david.leonard@@csee.uq.edu.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: print-sl.c,v 1.10 2000/10/03 14:31:58 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-sl.c,v 1.10 2000/10/03 14:31:58 ho Exp $ (LBL)";
a37 1
#ifdef __STDC__
a38 1
#endif
@


1.10
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-sl.c,v 1.9 2000/04/26 21:35:43 jakob Exp $ (LBL)";
d290 1
a290 1
	printf(" %d (%d)", lastlen[dir][lastconn], cp - chdr);
@


1.9
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-sl.c,v 1.8 1999/09/16 20:58:47 brad Exp $ (LBL)";
@


1.8
log
@bring more inline with tcpdump 3.4
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-sl.c,v 1.7 1997/07/25 20:12:27 mickey Exp $ (LBL)";
a44 1
#include <netinet/ip_var.h>
a45 1
#include <netinet/udp_var.h>
a46 1
#include <netinet/tcpip.h>
a53 1
#include <signal.h>
d104 12
a115 1
	ip_print((u_char *)ip, length);
@


1.7
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d2 1
a2 1
 * Copyright (c) 1989, 1990, 1991, 1993, 1994, 1995, 1996
d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-sl.c,v 1.6 1996/12/12 16:22:27 bitblt Exp $ (LBL)";
d78 2
d116 39
d291 1
d294 8
@


1.6
log
@*** empty log message ***
@
text
@d24 1
a24 1
    "@@(#) $Header: print-sl.c,v 1.41 96/12/10 23:19:42 leres Exp $ (LBL)";
d36 1
a36 1
#if __STDC__
@


1.5
log
@ifdef CSLIP
@
text
@a0 2
/*	$OpenBSD: print-sl.c,v 1.4 1996/07/13 11:01:30 mickey Exp $	*/

d23 2
a24 2
static  char rcsid[] =
	"@@(#)Header: print-sl.c,v 1.36 96/06/23 02:11:46 leres Exp (LBL)";
d27 1
a27 1
#ifdef CSLIP
d64 2
a65 2
static int lastlen[2][256];
static int lastconn = 255;
d67 2
a68 2
static void sliplink_print(const u_char *, const struct ip *, int);
static void compressed_sl_print(const u_char *, const struct ip *, int, int);
d81 2
a82 2
	register int caplen = h->caplen;
	register int length = h->len;
d116 1
a116 1
	       register int length)
d119 1
a119 1
	int hlen;
d142 1
a142 1
		 * The connection id is stored in the IP protcol field.
d169 1
a169 1
		i = EXTRACT_SHORT(cp);
d182 1
a182 1
		i = EXTRACT_SHORT(cp);
d194 1
a194 1
		    int length, int dir)
d197 1
a197 2
	register u_int flags;
	int hlen;
d246 1
@


1.4
log
@it is 3.2 now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d29 1
a29 1
#ifdef HAVE_NET_SLIP_H
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-sl.c,v 1.6 1996/05/20 00:41:11 fvdl Exp $	*/
/*	$NetBSD: print-sl.c,v 1.6 1996/05/20 00:41:11 fvdl Exp $	*/
d4 1
a4 1
 * Copyright (c) 1989, 1990, 1991, 1993, 1994
d26 1
a26 1
	"@@(#)Header: print-sl.c,v 1.28+ 94/06/10 17:01:38 mccanne Exp (LBL)";
d29 1
a29 1
#ifdef CSLIP
d38 3
d42 1
a56 1
#include <errno.h>
d64 1
d72 8
d129 1
a129 1
		int i;
d131 3
a133 3
		for (i = 0; i < 15; ++i)
			printf("%02x.", p[SLX_CHDR + i]);
		printf("%02x: ", p[SLX_CHDR + 15]);
d144 1
a144 1
		 * The connection id is stode in the IP protcol field.
d148 1
a148 1
		lastconn = ip->ip_p;
d171 1
a171 1
		i = (cp[0] << 8) | cp[1];
d184 1
a184 1
		i = (cp[0] << 8) | cp[1];
d241 1
a241 1
	hlen += ((struct tcphdr *)&((int32 *)ip)[hlen])->th_off;
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: print-sl.c,v 1.5 1995/03/06 19:11:29 mycroft Exp $	*/
d27 1
a27 1
	"@@(#)Header: print-sl.c,v 1.28 94/06/10 17:01:38 mccanne Exp (LBL)";
d133 1
a133 1
		 * The connection id is stored in the IP protcol field.
d137 1
a137 1
		lastconn = ((struct ip *)&p[SLX_CHDR])->ip_p;
@


1.1
log
@Initial revision
@
text
@d1 1
d133 3
a135 1
		 * The connection id is stode in the IP protcol field.
d137 1
a137 1
		lastconn = ip->ip_p;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
