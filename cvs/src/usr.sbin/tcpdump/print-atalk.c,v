head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.30.0.6
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.26.0.22
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.20
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.16
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.14
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.12
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.14
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.12
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.10
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.8
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.6
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.16.0.6
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.4
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.10.28.12.54.05;	author jsg;	state Exp;
branches;
next	1.30;
commitid	4j6uwDmbhn3fjZ6j;

1.30
date	2015.11.15.20.35.36;	author mmcc;	state Exp;
branches;
next	1.29;
commitid	kFQYMPTA5NvE3RXS;

1.29
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Zx2k82IzYwwZaEz9;

1.28
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.26;
commitid	yLXrOcgrag4eS8u4;

1.26
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.27.18.15.25;	author canacar;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.04.08.35.12;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.02.09.43.27;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.28.19.44.55;	author canacar;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.14.21.28.10;	author pvalchev;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.06.03.11.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.30.12.30.04;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.31.16.06.48;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.03.14.31.56;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.26.21.35.39;	author jakob;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.03.05.43.42;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.03.01.46.23;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.09.16.20.58.45;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	98.07.13.22.13.46;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.05.14.21.16.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.20.12.21;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.07.23.02.59.01;	author denny;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.43;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.15;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.17;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.24;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Return early from atalk_print_llap() if the length is less than the
size of a header to avoid an integer underflow.
Found with afl.
@
text
@/*	$OpenBSD: print-atalk.c,v 1.30 2015/11/15 20:35:36 mmcc Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Format and print AppleTalk packets.
 */

#include <sys/time.h>
#include <sys/socket.h>

struct mbuf;
struct rtentry;
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/if_ether.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>

#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "interface.h"
#include "addrtoname.h"
#include "ethertype.h"
#include "extract.h"			/* must come after interface.h */
#include "appletalk.h"
#include "savestr.h"
#include "privsep.h"

static struct tok type2str[] = {
	{ ddpRTMP,		"rtmp" },
	{ ddpRTMPrequest,	"rtmpReq" },
	{ ddpECHO,		"echo" },
	{ ddpIP,		"IP" },
	{ ddpARP,		"ARP" },
	{ ddpKLAP,		"KLAP" },
	{ 0,			NULL }
};

struct aarp {
	u_int16_t	htype, ptype;
	u_int8_t	halen, palen;
	u_int16_t	op;
	u_int8_t	hsaddr[6];
	u_int8_t	psaddr[4];
	u_int8_t	hdaddr[6];
	u_int8_t	pdaddr[4];
};

static char tstr[] = "[|atalk]";

static void atp_print(const struct atATP *, u_int);
static void atp_bitmap_print(u_char);
static void nbp_print(const struct atNBP *, u_int, u_short, u_char, u_char);
static const char *print_cstring(const char *, const u_char *);
static const struct atNBPtuple *nbp_tuple_print(const struct atNBPtuple *,
						const u_char *,
						u_short, u_char, u_char);
static const struct atNBPtuple *nbp_name_print(const struct atNBPtuple *,
					       const u_char *);
static const char *ataddr_string(u_short, u_char);
static void ddp_print(const u_char *, u_int, int, u_short, u_char, u_char);
static const char *ddpskt_string(int);

/*
 * Print AppleTalk Datagram Delivery Protocol packets
 * without the LLAP encapsulating header (i.e.
 * from Ethertalk)
 */
void
atalk_print(const u_char *bp, u_int length)
{
	const struct atDDP *dp;
	u_short snet;

	if (length < ddpSize) {
		(void)printf(" [|ddp %d]", length);
		return;
	}
	dp = (const struct atDDP *)bp;
	snet = EXTRACT_16BITS(&dp->srcNet);
	printf("%s.%s", ataddr_string(snet, dp->srcNode),
	    ddpskt_string(dp->srcSkt));
	printf(" > %s.%s:",
	    ataddr_string(EXTRACT_16BITS(&dp->dstNet), dp->dstNode),
	    ddpskt_string(dp->dstSkt));
	bp += ddpSize;
	length -= ddpSize;
	ddp_print(bp, length, dp->type, snet, dp->srcNode, dp->srcSkt);
}

/*
 * Print AppleTalk Datagram Delivery Protocol packets
 * from localtalk (i.e. the 230 Kbps net built into
 * every Macintosh). We can get these from a localtalk
 * interface if we have one, or from UDP encapsulated tunnels.
 */
void
atalk_print_llap(const u_char *bp, u_int length)
{
	const struct LAP *lp;
	const struct atDDP *dp;
	const struct atShortDDP *sdp;
	u_short snet;

	if (length < sizeof(*lp)) {
		(void)printf(" [|llap %d]", length);
		return;
	}

	lp = (struct LAP *)bp;
	bp += sizeof(*lp);
	length -= sizeof(*lp);
	switch (lp->type) {

	case lapShortDDP:
		if (length < ddpSSize) {
			(void)printf(" [|sddp %d]", length);
			return;
		}
		sdp = (const struct atShortDDP *)bp;
		printf("%s.%s",
		    ataddr_string(0, lp->src), ddpskt_string(sdp->srcSkt));
		printf(" > %s.%s:",
		    ataddr_string(0, lp->dst), ddpskt_string(sdp->dstSkt));
		bp += ddpSSize;
		length -= ddpSSize;
		ddp_print(bp, length, sdp->type, 0, lp->src, sdp->srcSkt);
		break;

	case lapDDP:
		if (length < ddpSize) {
			(void)printf(" [|ddp %d]", length);
			return;
		}
		dp = (const struct atDDP *)bp;
		snet = EXTRACT_16BITS(&dp->srcNet);
		printf("%s.%s", ataddr_string(snet, dp->srcNode),
		    ddpskt_string(dp->srcSkt));
		printf(" > %s.%s:",
		    ataddr_string(EXTRACT_16BITS(&dp->dstNet), dp->dstNode),
		    ddpskt_string(dp->dstSkt));
		bp += ddpSize;
		length -= ddpSize;
		ddp_print(bp, length, dp->type, snet, dp->srcNode, dp->srcSkt);
		break;

#ifdef notdef
	case lapKLAP:
		klap_print(bp, length);
		break;
#endif

	default:
		printf("%d > %d at-lap#%d %d",
		    lp->src, lp->dst, lp->type, length);
		break;
	}
}

/* XXX should probably pass in the snap header and do checks like arp_print() */
void
aarp_print(const u_char *bp, u_int length)
{
	const struct aarp *ap;

#define AT(member) ataddr_string((ap->member[1]<<8)|ap->member[2],ap->member[3])

	printf("aarp ");
	ap = (const struct aarp *)bp;
	if (ntohs(ap->htype) == 1 && ntohs(ap->ptype) == ETHERTYPE_ATALK &&
	    ap->halen == 6 && ap->palen == 4 )
		switch (ntohs(ap->op)) {

		case 1:				/* request */
			(void)printf("who-has %s tell %s",
			    AT(pdaddr), AT(psaddr));
			return;

		case 2:				/* response */
			(void)printf("reply %s is-at %s",
			    AT(pdaddr), etheraddr_string(ap->hdaddr));
			return;

		case 3:				/* probe (oy!) */
			(void)printf("probe %s tell %s",
			    AT(pdaddr), AT(psaddr));
			return;
		}
	(void)printf("len %u op %u htype %u ptype %#x halen %u palen %u",
	    length, ntohs(ap->op), ntohs(ap->htype), ntohs(ap->ptype),
	    ap->halen, ap->palen);
}

static void
ddp_print(const u_char *bp, u_int length, int t,
	  u_short snet, u_char snode, u_char skt)
{

	if ((intptr_t)bp & (sizeof(long)-1)) {
		static u_char *abuf = NULL;
		int clen = snapend - bp;
		if (clen > snaplen)
			clen = snaplen;

		if (abuf == NULL) {
			abuf = malloc(snaplen);
			if (abuf == NULL)
				error("ddp_print: malloc");
		}
		memmove((char *)abuf, (char *)bp, min(length, clen));
		snapend = abuf + clen;
		packetp = abuf;
		bp = abuf;
	}

	switch (t) {

	case ddpNBP:
		nbp_print((const struct atNBP *)bp, length, snet, snode, skt);
		break;

	case ddpATP:
		atp_print((const struct atATP *)bp, length);
		break;

	default:
		(void)printf(" at-%s %d", tok2str(type2str, NULL, t), length);
		break;
	}
}

static void
atp_print(const struct atATP *ap, u_int length)
{
	char c;
	u_int32_t data;

	if ((const u_char *)(ap + 1) > snapend) {
		/* Just bail if we don't have the whole chunk. */
		fputs(tstr, stdout);
		return;
	}
	length -= sizeof(*ap);
	switch (ap->control & 0xc0) {

	case atpReqCode:
		(void)printf(" atp-req%s %d",
			     ap->control & atpXO? " " : "*",
			     EXTRACT_16BITS(&ap->transID));

		atp_bitmap_print(ap->bitmap);

		if (length != 0)
			(void)printf(" [len=%d]", length);

		switch (ap->control & (atpEOM|atpSTS)) {
		case atpEOM:
			(void)printf(" [EOM]");
			break;
		case atpSTS:
			(void)printf(" [STS]");
			break;
		case atpEOM|atpSTS:
			(void)printf(" [EOM,STS]");
			break;
		}
		break;

	case atpRspCode:
		(void)printf(" atp-resp%s%d:%d (%d)",
			     ap->control & atpEOM? "*" : " ",
			     EXTRACT_16BITS(&ap->transID), ap->bitmap, length);
		switch (ap->control & (atpXO|atpSTS)) {
		case atpXO:
			(void)printf(" [XO]");
			break;
		case atpSTS:
			(void)printf(" [STS]");
			break;
		case atpXO|atpSTS:
			(void)printf(" [XO,STS]");
			break;
		}
		break;

	case atpRelCode:
		(void)printf(" atp-rel  %d", EXTRACT_16BITS(&ap->transID));

		atp_bitmap_print(ap->bitmap);

		/* length should be zero */
		if (length)
			(void)printf(" [len=%d]", length);

		/* there shouldn't be any control flags */
		if (ap->control & (atpXO|atpEOM|atpSTS)) {
			c = '[';
			if (ap->control & atpXO) {
				(void)printf("%cXO", c);
				c = ',';
			}
			if (ap->control & atpEOM) {
				(void)printf("%cEOM", c);
				c = ',';
			}
			if (ap->control & atpSTS) {
				(void)printf("%cSTS", c);
				c = ',';
			}
			(void)printf("]");
		}
		break;

	default:
		(void)printf(" atp-0x%x  %d (%d)", ap->control,
			     EXTRACT_16BITS(&ap->transID), length);
		break;
	}
	data = EXTRACT_32BITS(&ap->userData);
	if (data != 0)
		(void)printf(" 0x%x", data);
}

static void
atp_bitmap_print(u_char bm)
{
	char c;
	int i;

	/*
	 * The '& 0xff' below is needed for compilers that want to sign
	 * extend a u_char, which is the case with the Ultrix compiler.
	 * (gcc is smart enough to eliminate it, at least on the Sparc).
	 */
	if ((bm + 1) & (bm & 0xff)) {
		c = '<';
		for (i = 0; bm; ++i) {
			if (bm & 1) {
				(void)printf("%c%d", c, i);
				c = ',';
			}
			bm >>= 1;
		}
		(void)printf(">");
	} else {
		for (i = 0; bm; ++i)
			bm >>= 1;
		if (i > 1)
			(void)printf("<0-%d>", i - 1);
		else
			(void)printf("<0>");
	}
}

static void
nbp_print(const struct atNBP *np, u_int length, u_short snet,
	  u_char snode, u_char skt)
{
	const struct atNBPtuple *tp =
			(struct atNBPtuple *)((u_char *)np + nbpHeaderSize);
	int i;
	const u_char *ep;

	if (length < nbpHeaderSize) {
		(void)printf(" truncated-nbp %d", length);
		return;
	}

	length -= nbpHeaderSize;
	if (length < 8) {
		/* must be room for at least one tuple */
		if (np->control == nbpNATLKerr) {
			(void)printf(" nbp-netatalk_err");
			return;
		} else if (np->control == nbpNATLKok) {
			(void)printf(" nbp-netatalk_ok");
			return;
		}
		(void)printf(" truncated-nbp nbp-0x%x  %d (%d)",
			np->control, np->id, length + nbpHeaderSize);
		return;
	}
	/* ep points to end of available data */
	ep = snapend;
	if ((const u_char *)tp > ep) {
		fputs(tstr, stdout);
		return;
	}
	switch (i = np->control & 0xf0) {

	case nbpBrRq:
	case nbpLkUp:
		(void)printf(i == nbpLkUp? " nbp-lkup %d:":" nbp-brRq %d:",
			     np->id);
		if ((const u_char *)(tp + 1) > ep) {
			fputs(tstr, stdout);
			return;
		}
		(void)nbp_name_print(tp, ep);
		/*
		 * look for anomalies: the spec says there can only
		 * be one tuple, the address must match the source
		 * address and the enumerator should be zero.
		 */
		if ((np->control & 0xf) != 1)
			(void)printf(" [ntup=%d]", np->control & 0xf);
		if (tp->enumerator)
			(void)printf(" [enum=%d]", tp->enumerator);
		if (EXTRACT_16BITS(&tp->net) != snet ||
		    tp->node != snode || tp->skt != skt)
			(void)printf(" [addr=%s.%d]",
			    ataddr_string(EXTRACT_16BITS(&tp->net),
			    tp->node), tp->skt);
		break;

	case nbpLkUpReply:
		(void)printf(" nbp-reply %d:", np->id);

		/* print each of the tuples in the reply */
		for (i = np->control & 0xf; --i >= 0 && tp; )
			tp = nbp_tuple_print(tp, ep, snet, snode, skt);
		break;

	case nbpNATLKrgstr:
	case nbpNATLKunrgstr:
		(void)printf((i == nbpNATLKrgstr) ?
			" nbp-netatalk_rgstr %d:" :
			" nbp-netatalk_unrgstr %d:",
			np->id);
		for (i = np->control & 0xf; --i >= 0 && tp; )
			tp = nbp_tuple_print(tp, ep, snet, snode, skt);
		break;

	default:
		(void)printf(" nbp-0x%x  %d (%d)", np->control, np->id,
				length);
		break;
	}
}

/* print a counted string */
static const char *
print_cstring(const char *cp, const u_char *ep)
{
	u_int length;

	if (cp >= (const char *)ep) {
		fputs(tstr, stdout);
		return (0);
	}
	length = *cp++;

	/* Spec says string can be at most 32 bytes long */
	if (length < 0 || length > 32) {
		(void)printf("[len=%d]", length);
		return (0);
	}
	while ((int)--length >= 0) {
		if (cp >= (char *)ep) {
			fputs(tstr, stdout);
			return (0);
		}
		putchar(*cp++);
	}
	return (cp);
}

static const struct atNBPtuple *
nbp_tuple_print(const struct atNBPtuple *tp,
		const u_char *ep,
		u_short snet, u_char snode,
		u_char skt)
{
	const struct atNBPtuple *tpn;

	if ((const u_char *)(tp + 1) > ep) {
		fputs(tstr, stdout);
		return 0;
	}
	tpn = nbp_name_print(tp, ep);

	/* if the enumerator isn't 1, print it */
	if (tp->enumerator != 1)
		(void)printf("(%d)", tp->enumerator);

	/* if the socket doesn't match the src socket, print it */
	if (tp->skt != skt)
		(void)printf(" %d", tp->skt);

	/* if the address doesn't match the src address, it's an anomaly */
	if (EXTRACT_16BITS(&tp->net) != snet || tp->node != snode)
		(void)printf(" [addr=%s]",
		    ataddr_string(EXTRACT_16BITS(&tp->net), tp->node));

	return (tpn);
}

static const struct atNBPtuple *
nbp_name_print(const struct atNBPtuple *tp, const u_char *ep)
{
	const char *cp = (const char *)tp + nbpTupleSize;

	putchar(' ');

	/* Object */
	putchar('"');
	if ((cp = print_cstring(cp, ep)) != NULL) {
		/* Type */
		putchar(':');
		if ((cp = print_cstring(cp, ep)) != NULL) {
			/* Zone */
			putchar('@@');
			if ((cp = print_cstring(cp, ep)) != NULL)
				putchar('"');
		}
	}
	return ((const struct atNBPtuple *)cp);
}


#define HASHNAMESIZE 4096

struct hnamemem {
	int addr;
	char *name;
	struct hnamemem *nxt;
};

static struct hnamemem hnametable[HASHNAMESIZE];

/*
 * see if there's an AppleTalk number to name map file.
 */
static void
init_atalk(void)
{
	struct hnamemem *tp;
	char nambuf[HOST_NAME_MAX+1 + 20];
	char line[BUFSIZ];
	int i1, i2, i3;

	priv_getlines(FTAB_APPLETALK);
	while (priv_getline(line, sizeof(line)) > 0) {
		if (line[0] == '\n' || line[0] == 0 || line[0] == '#')
			continue;
		if (sscanf(line, "%d.%d.%d %255s", &i1, &i2, &i3, nambuf) == 4)
			/* got a hostname. */
			i3 |= ((i1 << 8) | i2) << 8;
		else if (sscanf(line, "%d.%d %255s", &i1, &i2, nambuf) == 3)
			/* got a net name */
			i3 = (((i1 << 8) | i2) << 8) | 255;
		else
			continue;
		
		for (tp = &hnametable[i3 & (HASHNAMESIZE-1)];
		     tp->nxt; tp = tp->nxt)
			;
		tp->addr = i3;
		tp->nxt = newhnamemem();
		tp->name = savestr(nambuf);
	}
}

static const char *
ataddr_string(u_short atnet, u_char athost)
{
	struct hnamemem *tp, *tp2;
	int i = (atnet << 8) | athost;
	char nambuf[HOST_NAME_MAX+1 + 20];
	static int first = 1;

	if (first) {
		first = 0;
		init_atalk();
	}
	for (tp = &hnametable[i & (HASHNAMESIZE-1)]; tp->nxt; tp = tp->nxt)
		if (tp->addr == i)
			return (tp->name);

	/* didn't have the node name -- see if we've got the net name */
	i |= 255;
	for (tp2 = &hnametable[i & (HASHNAMESIZE-1)]; tp2->nxt; tp2 = tp2->nxt)
		if (tp2->addr == i) {
			tp->addr = (atnet << 8) | athost;
			tp->nxt = newhnamemem();
			(void)snprintf(nambuf, sizeof nambuf, "%s.%d",
			    tp2->name, athost);
			tp->name = savestr(nambuf);
			return (tp->name);
		}

	tp->addr = (atnet << 8) | athost;
	tp->nxt = newhnamemem();
	if (athost != 255)
		(void)snprintf(nambuf, sizeof nambuf, "%d.%d.%d",
			atnet >> 8, atnet & 0xff, athost);
	else
		(void)snprintf(nambuf, sizeof nambuf, "%d.%d",
			atnet >> 8, atnet & 0xff);
	tp->name = savestr(nambuf);

	return (tp->name);
}

static struct tok skt2str[] = {
	{ rtmpSkt,	"rtmp" },	/* routing table maintenance */
	{ nbpSkt,	"nis" },	/* name info socket */
	{ echoSkt,	"echo" },	/* AppleTalk echo protocol */
	{ zipSkt,	"zip" },	/* zone info protocol */
	{ 0,		NULL }
};

static const char *
ddpskt_string(int skt)
{
	static char buf[12];

	if (nflag) {
		(void)snprintf(buf, sizeof buf, "%d", skt);
		return (buf);
	}
	return (tok2str(skt2str, "%d", skt));
}
@


1.30
log
@Remove more register keywords.

ok daniel@@, discussed on hackers@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.29 2015/08/21 02:07:32 deraadt Exp $	*/
d130 5
@


1.29
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.28 2015/01/16 06:40:21 deraadt Exp $	*/
d96 1
a96 1
atalk_print(register const u_char *bp, u_int length)
d98 1
a98 1
	register const struct atDDP *dp;
d124 1
a124 1
atalk_print_llap(register const u_char *bp, u_int length)
d126 3
a128 3
	register const struct LAP *lp;
	register const struct atDDP *dp;
	register const struct atShortDDP *sdp;
d183 1
a183 1
aarp_print(register const u_char *bp, u_int length)
d185 1
a185 1
	register const struct aarp *ap;
d216 2
a217 2
ddp_print(register const u_char *bp, register u_int length, register int t,
	  register u_short snet, register u_char snode, u_char skt)
d254 1
a254 1
atp_print(register const struct atATP *ap, u_int length)
d346 1
a346 1
atp_bitmap_print(register u_char bm)
d348 2
a349 2
	register char c;
	register int i;
d377 2
a378 2
nbp_print(register const struct atNBP *np, u_int length, register u_short snet,
	  register u_char snode, register u_char skt)
d380 1
a380 1
	register const struct atNBPtuple *tp =
d464 1
a464 1
print_cstring(register const char *cp, register const u_char *ep)
d466 1
a466 1
	register u_int length;
d490 4
a493 4
nbp_tuple_print(register const struct atNBPtuple *tp,
		register const u_char *ep,
		register u_short snet, register u_char snode,
		register u_char skt)
d495 1
a495 1
	register const struct atNBPtuple *tpn;
d520 1
a520 1
nbp_name_print(const struct atNBPtuple *tp, register const u_char *ep)
d522 1
a522 1
	register const char *cp = (const char *)tp + nbpTupleSize;
d588 2
a589 2
	register struct hnamemem *tp, *tp2;
	register int i = (atnet << 8) | athost;
d635 1
a635 1
ddpskt_string(register int skt)
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.27 2014/08/14 12:44:44 mpi Exp $	*/
d227 1
a227 1
			abuf = (u_char *)malloc(snaplen);
@


1.27
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.26 2009/10/27 23:59:55 deraadt Exp $	*/
a25 1
#include <sys/param.h>
d45 1
d559 1
a559 1
	char nambuf[MAXHOSTNAMELEN + 20];
d590 1
a590 1
	char nambuf[MAXHOSTNAMELEN + 20];
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.25 2007/10/07 16:41:05 deraadt Exp $	*/
a34 1
#include <netinet/in_systm.h>
a40 1
#include <netinet/tcpip.h>
@


1.25
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.24 2007/06/27 18:15:25 canacar Exp $	*/
a24 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.24
log
@When aligning buffers correctly handle the case where the
buffers overlap, which happens on 64 bit archs, when
handling encapsulated packets. Reported and tested by Jurjen Oskam
additional testing by Stuart Henderson and todd@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.23 2004/02/04 08:35:12 otto Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.23 2004/02/04 08:35:12 otto Exp $ (LBL)";
@


1.23
log
@Some more non-alignment problems resolved.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.22 2004/02/02 09:43:27 otto Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.22 2004/02/02 09:43:27 otto Exp $ (LBL)";
d229 3
d238 2
a239 2
		memcpy(abuf, bp, min(length, snaplen));
		snapend += abuf - bp;
@


1.22
log
@Do away with non-aligned memory accesses.
ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.21 2004/01/28 19:44:55 canacar Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.21 2004/01/28 19:44:55 canacar Exp $ (LBL)";
d49 1
d227 1
a227 1
	if ((long)bp & 3) {
@


1.21
log
@privilege separated tcpdump, joint work with otto@@

tested by avsm@@ vincent@@ dhartmei@@ markus@@ hshoexer@@ and others
go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.20 2003/04/14 21:28:10 pvalchev Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.20 2003/04/14 21:28:10 pvalchev Exp $ (LBL)";
a225 1
#ifdef LBL_ALIGN
a238 1
#endif
@


1.20
log
@%d is 12 chars, not 10; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.19 2002/02/19 19:39:40 millert Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.19 2002/02/19 19:39:40 millert Exp $ (LBL)";
d59 1
d557 33
a596 1
	FILE *fp;
d598 3
a600 31
	/*
	 * if this is the first call, see if there's an AppleTalk
	 * number to name map file.
	 */
	if (first && (first = 0, !nflag)
	    && (fp = fopen("/etc/atalk.names", "r"))) {
		char line[256];
		int i1, i2, i3;

		while (fgets(line, sizeof(line), fp)) {
			if (line[0] == '\n' || line[0] == 0 || line[0] == '#')
				continue;
			if (sscanf(line, "%d.%d.%d %255s", &i1, &i2, &i3,
				     nambuf) == 4)
				/* got a hostname. */
				i3 |= ((i1 << 8) | i2) << 8;
			else if (sscanf(line, "%d.%d %255s", &i1, &i2,
					nambuf) == 3)
				/* got a net name */
				i3 = (((i1 << 8) | i2) << 8) | 255;
			else
				continue;

			for (tp = &hnametable[i3 & (HASHNAMESIZE-1)];
			     tp->nxt; tp = tp->nxt)
				;
			tp->addr = i3;
			tp->nxt = newhnamemem();
			tp->name = savestr(nambuf);
		}
		fclose(fp);
a601 1

@


1.19
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.18 2001/11/06 03:11:40 deraadt Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.18 2001/11/06 03:11:40 deraadt Exp $ (LBL)";
d638 1
a638 1
	static char buf[10];
@


1.18
log
@a bit of snprintf cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.17 2001/10/30 12:30:04 ho Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.17 2001/10/30 12:30:04 ho Exp $ (LBL)";
a34 1
#ifdef __STDC__
a36 1
#endif
@


1.17
log
@ddp_print needs aligned data (alpha,sparc). Noted (with a patch) by <jepeway@@blasted-heath.com>. Patch code relocated inside ddp_print(). Fixes PR# 1945.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.16 2000/10/31 16:06:48 deraadt Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.16 2000/10/31 16:06:48 deraadt Exp $ (LBL)";
d643 1
a643 1
		(void)sprintf(buf, "%d", skt);
@


1.16
log
@some buffer care; jakob
@
text
@d1 1
a1 1
/*	$OpenBSD: print-atalk.c,v 1.15 2000/10/03 14:31:56 ho Exp $	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.15 2000/10/03 14:31:56 ho Exp $ (LBL)";
d226 16
@


1.15
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.14 2000/04/26 21:35:39 jakob Exp $ (LBL)";
d547 1
a547 1
	char nambuf[256];
@


1.14
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d28 1
a28 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.13 2000/04/03 05:43:42 itojun Exp $ (LBL)";
@


1.13
log
@add more ntohs().  u_short -> u_int16_t.  (in-sync with tcpdump.org tree)
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.12 2000/04/03 01:46:23 deraadt Exp $ (LBL)";
d197 1
a197 1
	    ap->halen == 6 && ap->palen == 4)
d217 1
a217 1
	    ap->halen, ap->palen );
@


1.12
log
@byte order fixes; gwes@@oat.com
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.11 1999/09/16 20:58:45 brad Exp $ (LBL)";
d71 7
a77 7
	u_short htype, ptype;
	u_char	halen, palen;
	u_short op;
	u_char	hsaddr[6];
	u_char	psaddr[4];
	u_char	hdaddr[6];
	u_char	pdaddr[4];
d215 3
a217 2
	(void)printf("len %d op %d htype %d ptype %#x halen %d palen %d",
	    length, ap->op, ap->htype, ap->ptype, ap->halen, ap->palen );
@


1.11
log
@bring more inline with tcpdump 3.4
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.10 1999/07/28 20:41:36 jakob Exp $ (LBL)";
d196 3
a198 3
	if (ap->htype == 1 && ap->ptype == ETHERTYPE_ATALK &&
	    ap->halen == 6 && ap->palen == 4 )
		switch (ap->op) {
@


1.10
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.9 1998/07/13 22:13:46 deraadt Exp $ (LBL)";
@


1.9
log
@snprintf madness
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.8 1998/05/14 21:16:51 deraadt Exp $ (LBL)";
d58 1
d466 1
a466 1
	while (--length >= 0) {
d600 2
a601 1
		(void)snprintf(nambuf, sizeof nambuf, "%d.%d", atnet, athost);
d603 2
a604 1
		(void)snprintf(nambuf, sizeof nambuf, "%d", atnet);
@


1.8
log
@more careful scanf
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.7 1997/07/25 20:12:21 mickey Exp $ (LBL)";
d590 2
a591 1
			(void)sprintf(nambuf, "%s.%d", tp2->name, athost);
d599 1
a599 1
		(void)sprintf(nambuf, "%d.%d", atnet, athost);
d601 1
a601 1
		(void)sprintf(nambuf, "%d", atnet);
d618 1
a618 1
	static char buf[8];
@


1.7
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-atalk.c,v 1.6 1997/07/23 02:59:01 denny Exp $ (LBL)";
d559 1
a559 1
			if (sscanf(line, "%d.%d.%d %s", &i1, &i2, &i3,
d563 1
a563 1
			else if (sscanf(line, "%d.%d %s", &i1, &i2,
@


1.6
log
@Better handling for AppleTalk, and netatalk in particular.
Handle native Ethertalk phase 1 & 2 as well as the localtalk encapsulation a la Kinetics FastPath previously handled.
@
text
@d26 1
a26 1
    "@@(#) $Header: /usr/src/usr.sbin/tcpdump/RCS/print-atalk.c,v 1.3 1997/07/20 17:16:38 denny Exp denny $ (LBL)";
d33 1
a33 1
#if __STDC__
@


1.5
log
@*** empty log message ***
@
text
@d26 1
a26 1
    "@@(#) $Header: print-atalk.c,v 1.45 96/12/10 23:24:07 leres Exp $ (LBL)";
d95 3
a97 1
 * Print AppleTalk Datagram Delivery Protocol packets.
d102 28
d371 5
d379 9
a387 1
		(void)printf(" truncated-nbp %d", length + nbpHeaderSize);
d431 10
d598 1
a598 2
		(void)sprintf(nambuf, "%d.%d.%d",
		    atnet >> 8, atnet & 0xff, athost);
d600 1
a600 1
		(void)sprintf(nambuf, "%d.%d", atnet >> 8, atnet & 0xff);
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d2 1
a2 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995
d23 1
d25 2
a26 2
static  char rcsid[] =
	"@@(#)Header: print-atalk.c,v 1.40 95/10/07 22:13:43 leres Exp (LBL)";
a30 1
#include <sys/types.h>
d81 1
a81 1
static void atp_print(const struct atATP *, int);
d83 1
a83 1
static void nbp_print(const struct atNBP *, int, u_short, u_char, u_char);
d91 1
a91 1
static void ddp_print(const u_char *, int, int, u_short, u_char, u_char);
d98 1
a98 1
atalk_print(register const u_char *bp, int length)
d131 1
a131 1
		snet = EXTRACT_SHORT(&dp->srcNet);
d135 1
a135 1
		    ataddr_string(EXTRACT_SHORT(&dp->dstNet), dp->dstNode),
d157 1
a157 1
aarp_print(register const u_char *bp, int length)
d189 1
a189 1
ddp_print(register const u_char *bp, register int length, register int t,
d210 1
a210 1
atp_print(register const struct atATP *ap, int length)
d226 1
a226 1
			     EXTRACT_SHORT(&ap->transID));
d249 1
a249 1
			     EXTRACT_SHORT(&ap->transID), ap->bitmap, length);
d264 1
a264 1
		(void)printf(" atp-rel  %d", EXTRACT_SHORT(&ap->transID));
d293 1
a293 1
			     EXTRACT_SHORT(&ap->transID), length);
d296 1
a296 1
	data = EXTRACT_LONG(&ap->userData);
d333 1
a333 1
nbp_print(register const struct atNBP *np, int length, register u_short snet,
d338 1
a338 1
	int i = length;
d373 1
a373 1
		if (EXTRACT_SHORT(&tp->net) != snet ||
d376 1
a376 1
			    ataddr_string(EXTRACT_SHORT(&tp->net),
d399 1
a399 1
	register int length;
d445 1
a445 1
	if (EXTRACT_SHORT(&tp->net) != snet || tp->node != snode)
d447 1
a447 1
		    ataddr_string(EXTRACT_SHORT(&tp->net), tp->node));
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-atalk.c,v 1.3 1995/03/06 19:11:04 mycroft Exp $	*/
/*	$NetBSD: print-atalk.c,v 1.3 1995/03/06 19:11:04 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
d27 1
a27 1
	"@@(#)Header: print-atalk.c,v 1.36 94/06/20 19:44:34 leres Exp (LBL)";
d35 4
a51 1
#ifdef __STDC__
a52 1
#endif
d61 1
a61 1
static struct token type2str[] = {
d215 1
a215 1
	u_int32 data;
d523 1
a523 1
			tp->nxt = (struct hnamemem *)calloc(1, sizeof(*tp));
d538 1
a538 1
			tp->nxt = (struct hnamemem *)calloc(1, sizeof(*tp));
d545 1
a545 1
	tp->nxt = (struct hnamemem *)calloc(1, sizeof(*tp));
d551 1
a551 2
	i = strlen(nambuf) + 1;
	tp->name = strcpy(malloc((u_int) i), nambuf);
d556 1
a556 1
static struct token skt2str[] = {
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
