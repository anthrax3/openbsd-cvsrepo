head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.22
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.20
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.12.0.10
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.8
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.8
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.03.15.05.03.11;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	UUo2bJ8XhK7ac5DD;

1.20
date	2015.11.18.15.36.20;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	vQk1DzJRhR5UcrJ1;

1.19
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	enjTsnD5UO6xazKc;

1.18
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2009.11.12.00.02.16;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.17.17.33.15;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.30.12.32.32;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.11.07.40.10;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.19.04.55.03;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.03.11.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.11.22.26.39;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.03.14.31.58;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.26.21.35.43;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	99.09.16.20.58.47;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.27;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.30;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.48;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.37;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@ o remove legacy code that defines abs(3) if it isn't available

 o inline an ugly and potentially risky macro of the form:

		#define x if (a) b; else

 o fix a >21 y.o. bug resulting from someone writing:

		puts("[nothing to parse], stdout");

   when they meant:

		fputs("[nothing to parse]", stdout);

ok canacar@@
@
text
@/*	$OpenBSD: print-snmp.c,v 1.20 2015/11/18 15:36:20 mmcc Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997
 *     John Robert LoVerso. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * This implementation has been influenced by the CMU SNMP release,
 * by Steve Waldbusser.  However, this shares no code with that system.
 * Additional ASN.1 insight gained from Marshall T. Rose's _The_Open_Book_.
 * Earlier forms of this implementation were derived and/or inspired by an
 * awk script originally written by C. Philip Wood of LANL (but later
 * heavily modified by John Robert LoVerso).  The copyright notice for
 * that work is preserved below, even though it may not rightly apply
 * to this file.
 *
 * This started out as a very simple program, but the incremental decoding
 * (into the BE structure) complicated things.
 *
 #			Los Alamos National Laboratory
 #
 #	Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997
 #	This software was produced under a U.S. Government contract
 #	(W-7405-ENG-36) by Los Alamos National Laboratory, which is
 #	operated by the	University of California for the U.S. Department
 #	of Energy.  The U.S. Government is licensed to use, reproduce,
 #	and distribute this software.  Permission is granted to the
 #	public to copy and use this software without charge, provided
 #	that this Notice and any statement of authorship are reproduced
 #	on all copies.  Neither the Government nor the University makes
 #	any warranty, express or implied, or assumes any liability or
 #	responsibility for the use of this software.
 #	@@(#)snmp.awk.x	1.1 (LANL) 1/15/90
 */

#include <sys/time.h>

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#include "interface.h"
#include "addrtoname.h"

/*
 * Universal ASN.1 types
 * (we only care about the tag values for those allowed in the Internet SMI)
 */
char *Universal[] = {
	"U-0",
	"Boolean",
	"Integer",
#define INTEGER 2
	"Bitstring",
	"String",
#define STRING 4
	"Null",
#define ASN_NULL 5
	"ObjID",
#define OBJECTID 6
	"ObjectDes",
	"U-8","U-9","U-10","U-11",	/* 8-11 */
	"U-12","U-13","U-14","U-15",	/* 12-15 */
	"Sequence",
#define SEQUENCE 16
	"Set"
};

/*
 * Application-wide ASN.1 types from the Internet SMI and their tags
 */
char *Application[] = {
	"IpAddress",
#define IPADDR 0
	"Counter",
#define COUNTER 1
	"Gauge",
#define GAUGE 2
	"TimeTicks",
#define TIMETICKS 3
	"Opaque",
#define OPAQUE 4
	"NsapAddress",
#define NSAPADDR 5
	"Counter64",
#define COUNTER64 6
	"UInteger32"
#define UINTEGER32 7
};

/*
 * Context-specific ASN.1 types for the SNMP PDUs and their tags
 */
char *Context[] = {
	"GetRequest",
#define GETREQ 0
	"GetNextRequest",
#define GETNEXTREQ 1
	"GetResponse",
#define GETRESP 2
	"SetRequest",
#define SETREQ 3
	"Trap",
#define TRAP 4
	"GetBulkReq",
#define GETBULKREQ 5
	"InformReq",
#define INFORMREQ 6
	"TrapV2",
#define TRAPV2 7
	"Report"
#define REPORT 8
};

/*
 * Private ASN.1 types
 * The Internet SMI does not specify any
 */
char *Private[] = {
	"P-0"
};

/*
 * error-status values for any SNMP PDU
 */
char *ErrorStatus[] = {
	"noError",
	"tooBig",
	"noSuchName",
	"badValue",
	"readOnly",
	"genErr",
	"noAccess",
	"wrongType",
	"wrongLength",
	"wrongEnc",
	"wrongValue",
	"noCreation",
	"inconValue",
	"resUnavail",
	"commitFailed",
	"undoFailed",
	"authError",
	"notWritable",
	"inconName"
};
#define DECODE_ErrorStatus(e) \
	( e >= 0 && e <= sizeof(ErrorStatus)/sizeof(ErrorStatus[0]) \
	? ErrorStatus[e] : (snprintf(errbuf, sizeof(errbuf), "err=%u", e), errbuf))

/*
 * generic-trap values in the SNMP Trap-PDU
 */
char *GenericTrap[] = {
	"coldStart",
	"warmStart",
	"linkDown",
	"linkUp",
	"authenticationFailure",
	"egpNeighborLoss",
	"enterpriseSpecific"
#define GT_ENTERPRISE 6
};
#define DECODE_GenericTrap(t) \
	( t >= 0 && t < sizeof(GenericTrap)/sizeof(GenericTrap[0]) \
	? GenericTrap[t] : (snprintf(buf, sizeof(buf), "gt=%d", t), buf))

/*
 * ASN.1 type class table
 * Ties together the preceding Universal, Application, Context, and Private
 * type definitions.
 */
#define defineCLASS(x) { "x", x, sizeof(x)/sizeof(x[0]) } /* not ANSI-C */
struct {
	char	*name;
	char	**Id;
	    int	numIDs;
    } Class[] = {
	defineCLASS(Universal),
#define	UNIVERSAL	0
	defineCLASS(Application),
#define	APPLICATION	1
	defineCLASS(Context),
#define	CONTEXT		2
	defineCLASS(Private),
#define	PRIVATE		3
};

/*
 * defined forms for ASN.1 types
 */
char *Form[] = {
	"Primitive",
#define PRIMITIVE	0
	"Constructed",
#define CONSTRUCTED	1
};

/*
 * A structure for the OID tree for the compiled-in MIB.
 * This is stored as a general-order tree.
 */
struct obj {
	char	*desc;			/* name of object */
	u_int	oid;			/* sub-id following parent */
	u_char	type;			/* object type (unused) */
	struct obj *child, *next;	/* child and next sibling pointers */
} *objp = NULL;

/*
 * Include the compiled in SNMP MIB.  "mib.h" is produced by feeding
 * RFC-1156 format files into "makemib".  "mib.h" MUST define at least
 * a value for `mibroot'.
 *
 * In particular, this is gross, as this is including initialized structures,
 * and by right shouldn't be an "include" file.
 */
#include "mib.h"

/*
 * This defines a list of OIDs which will be abbreviated on output.
 * Currently, this includes the prefixes for the Internet MIB, the
 * private enterprises tree, and the experimental tree.
 */
struct obj_abrev {
	char *prefix;			/* prefix for this abrev */
	struct obj *node;		/* pointer into object table */
	char *oid;			/* ASN.1 encoded OID */
} obj_abrev_list[] = {
#ifndef NO_ABREV_MIB
	/* .iso.org.dod.internet.mgmt.mib */
	{ "",	&_mib_obj,		"\53\6\1\2\1" },
#endif
#ifndef NO_ABREV_ENTER
	/* .iso.org.dod.internet.private.enterprises */
	{ "E:",	&_enterprises_obj,	"\53\6\1\4\1" },
#endif
#ifndef NO_ABREV_EXPERI
	/* .iso.org.dod.internet.experimental */
	{ "X:",	&_experimental_obj,	"\53\6\1\3" },
#endif
#ifndef NO_ABREV_SNMPMIBOBJECTS
	/* .iso.org.dod.internet.snmpV2.snmpModules.snmpMIB.snmpMIBObjects */
	{ "S:", &_snmpmibobjects_obj,	"\53\6\1\6\3\1\1" },
#endif
	{ 0,0,0 }
};

/*
 * This is used in the OID print routine to walk down the object tree
 * rooted at `mibroot'.
 */
#define OBJ_PRINT(o, suppressdot) \
{ \
	if (objp) { \
		do { \
			if ((o) == objp->oid) \
				break; \
		} while ((objp = objp->next) != NULL); \
	} \
	if (objp) { \
		printf(suppressdot?"%s":".%s", objp->desc); \
		objp = objp->child; \
	} else \
		printf(suppressdot?"%u":".%u", (o)); \
}

/*
 * This is the definition for the Any-Data-Type storage used purely for
 * temporary internal representation while decoding an ASN.1 data stream.
 */
struct be {
	u_int32_t asnlen;
	union {
		caddr_t raw;
		int32_t integer;
		u_int32_t uns;
		u_int64_t uns64;
		const u_char *str;
	} data;
	u_short id;
	u_char form, class;		/* tag info */
	u_char type;
#define BE_ANY		255
#define BE_NONE		0
#define BE_NULL		1
#define BE_OCTET	2
#define BE_OID		3
#define BE_INT		4
#define BE_UNS		5
#define BE_STR		6
#define BE_SEQ		7
#define BE_INETADDR	8
#define BE_PDU		9
#define BE_UNS64	10
};

/*
 * Defaults for SNMP PDU components
 */
#define DEF_COMMUNITY "public"
#define DEF_VERSION 1

/*
 * constants for ASN.1 decoding
 */
#define OIDMUX 40
#define ASNLEN_INETADDR 4
#define ASN_SHIFT7 7
#define ASN_SHIFT8 8
#define ASN_BIT8 0x80
#define ASN_LONGLEN 0x80

#define ASN_ID_BITS 0x1f
#define ASN_FORM_BITS 0x20
#define ASN_FORM_SHIFT 5
#define ASN_CLASS_BITS 0xc0
#define ASN_CLASS_SHIFT 6

#define ASN_ID_EXT 0x1f		/* extension ID in tag field */

/*
 * truncated==1 means the packet was complete, but we don't have all of
 * it to decode.
 */
static int truncated;

/*
 * This decodes the next ASN.1 object in the stream pointed to by "p"
 * (and of real-length "len") and stores the intermediate data in the
 * provided BE object.
 *
 * This returns -l if it fails (i.e., the ASN.1 stream is not valid).
 * O/w, this returns the number of bytes parsed from "p".
 */
static int
asn1_parse(const u_char *p, u_int len, struct be *elem)
{
	u_char form, class, id;
	int i, hdr;

	elem->asnlen = 0;
	elem->type = BE_ANY;
	if (len < 1) {
		if (truncated)
			fputs("[|snmp]", stdout);
		else
			fputs("[nothing to parse]", stdout);
		return -1;
	}

	/*
	 * it would be nice to use a bit field, but you can't depend on them.
	 *  +---+---+---+---+---+---+---+---+
	 *  + class |frm|        id         |
	 *  +---+---+---+---+---+---+---+---+
	 *    7   6   5   4   3   2   1   0
	 */
	id = *p & ASN_ID_BITS;		/* lower 5 bits, range 00-1f */
#ifdef notdef
	form = (*p & 0xe0) >> 5;	/* move upper 3 bits to lower 3 */
	class = form >> 1;		/* bits 7&6 -> bits 1&0, range 0-3 */
	form &= 0x1;			/* bit 5 -> bit 0, range 0-1 */
#else
	form = (u_char)(*p & ASN_FORM_BITS) >> ASN_FORM_SHIFT;
	class = (u_char)(*p & ASN_CLASS_BITS) >> ASN_CLASS_SHIFT;
#endif
	elem->form = form;
	elem->class = class;
	elem->id = id;
	if (vflag)
		printf("|%.2x", *p);
	p++; len--; hdr = 1;
	/* extended tag field */
	if (id == ASN_ID_EXT) {
		for (id = 0; *p & ASN_BIT8 && len > 0; len--, hdr++, p++) {
			if (vflag)
				printf("|%.2x", *p);
			id = (id << 7) | (*p & ~ASN_BIT8);
		}
		if (len == 0 && *p & ASN_BIT8) {
			if (truncated)
				fputs("[|snmp]", stdout);
			else 
				fputs("[Xtagfield?]", stdout);
			return -1;
		}
		elem->id = id = (id << 7) | *p;
		--len;
		++hdr;
		++p;
	}
	if (len < 1) {
		if (truncated)
			fputs("[|snmp]", stdout);
		else
			fputs("[no asnlen]", stdout);
		return -1;
	}
	elem->asnlen = *p;
	if (vflag)
		printf("|%.2x", *p);
	p++; len--; hdr++;
	if (elem->asnlen & ASN_BIT8) {
		int noct = elem->asnlen % ASN_BIT8;
		elem->asnlen = 0;
		if (len < noct) {
			if (truncated)
				fputs("[|snmp]", stdout);
			else
				printf("[asnlen? %d<%d]", len, noct);
			return -1;
		}
		for (; noct-- > 0; len--, hdr++) {
			if (vflag)
				printf("|%.2x", *p);
			elem->asnlen = (elem->asnlen << ASN_SHIFT8) | *p++;
		}
	}
	if (len < elem->asnlen) {
		if (!truncated) {
			printf("[len%d<asnlen%u]", len, elem->asnlen);
			return -1;
		}
		/* maybe should check at least 4? */
		elem->asnlen = len;
	}
	if (form >= sizeof(Form)/sizeof(Form[0])) {
		if (truncated)
			fputs("[|snmp]", stdout);
		else
			printf("[form?%d]", form);
		return -1;
	}
	if (class >= sizeof(Class)/sizeof(Class[0])) {
		if (truncated)
			fputs("[|snmp]", stdout);
		else
			printf("[class?%c/%d]", *Form[form], class);
		return -1;
	}
	if ((int)id >= Class[class].numIDs) {
		if (truncated)
			fputs("[|snmp]", stdout);
		else
			printf("[id?%c/%s/%d]", *Form[form],
			    Class[class].name, id);
		return -1;
	}

	switch (form) {
	case PRIMITIVE:
		switch (class) {
		case UNIVERSAL:
			switch (id) {
			case STRING:
				elem->type = BE_STR;
				elem->data.str = p;
				break;

			case INTEGER: {
				int32_t data;
				elem->type = BE_INT;
				data = 0;

				if (*p & ASN_BIT8)	/* negative */
					data = -1;
				for (i = elem->asnlen; i-- > 0; p++)
					data = (data << ASN_SHIFT8) | *p;
				elem->data.integer = data;
				break;
			}

			case OBJECTID:
				elem->type = BE_OID;
				elem->data.raw = (caddr_t)p;
				break;

			case ASN_NULL:
				elem->type = BE_NULL;
				elem->data.raw = NULL;
				break;

			default:
				elem->type = BE_OCTET;
				elem->data.raw = (caddr_t)p;
				printf("[P/U/%s]",
					Class[class].Id[id]);
				break;
			}
			break;

		case APPLICATION:
			switch (id) {
			case IPADDR:
				elem->type = BE_INETADDR;
				elem->data.raw = (caddr_t)p;
				break;

			case COUNTER:
			case GAUGE:
			case TIMETICKS:
			case OPAQUE:
			case NSAPADDR:
			case UINTEGER32: {
				u_int32_t data;
				elem->type = BE_UNS;
				data = 0;
				for (i = elem->asnlen; i-- > 0; p++)
					data = (data << 8) + *p;
				elem->data.uns = data;
				break;
			}

			case COUNTER64: {
				u_int64_t data;
				elem->type = BE_UNS64;
				data = 0;
				for (i = elem->asnlen; i-- > 0; p++)
					data = (data << 8) + *p;
				elem->data.uns64 = data;
				break;
			}

			default:
				elem->type = BE_OCTET;
				elem->data.raw = (caddr_t)p;
				printf("[P/A/%s]",
					Class[class].Id[id]);
				break;
			}
			break;

		default:
			elem->type = BE_OCTET;
			elem->data.raw = (caddr_t)p;
			printf("[P/%s/%s]",
				Class[class].name, Class[class].Id[id]);
			break;
		}
		break;

	case CONSTRUCTED:
		switch (class) {
		case UNIVERSAL:
			switch (id) {
			case SEQUENCE:
				elem->type = BE_SEQ;
				elem->data.raw = (caddr_t)p;
				break;

			default:
				elem->type = BE_OCTET;
				elem->data.raw = (caddr_t)p;
				printf("C/U/%s", Class[class].Id[id]);
				break;
			}
			break;

		case CONTEXT:
			elem->type = BE_PDU;
			elem->data.raw = (caddr_t)p;
			break;

		default:
			elem->type = BE_OCTET;
			elem->data.raw = (caddr_t)p;
			printf("C/%s/%s",
				Class[class].name, Class[class].Id[id]);
			break;
		}
		break;
	}
	p += elem->asnlen;
	len -= elem->asnlen;
	return elem->asnlen + hdr;
}

/*
 * Display the ASN.1 object represented by the BE object.
 * This used to be an integral part of asn1_parse() before the intermediate
 * BE form was added.
 */
static void
asn1_print(struct be *elem)
{
	u_char *p = (u_char *)elem->data.raw;
	u_int32_t asnlen = elem->asnlen;
	int i;

	switch (elem->type) {

	case BE_OCTET:
		for (i = asnlen; i-- > 0; p++)
			printf("_%.2x", *p);
		break;

	case BE_NULL:
		break;

	case BE_OID: {
	int o = 0, first = -1, i = asnlen;

		if (!nflag && asnlen > 2) {
			struct obj_abrev *a = &obj_abrev_list[0];
			for (; a->node; a++) {
				if (!memcmp(a->oid, (char *)p,
				    strlen(a->oid))) {
					objp = a->node->child;
					i -= strlen(a->oid);
					p += strlen(a->oid);
					fputs(a->prefix, stdout);
					first = 1;
					break;
				}
			}
		}
		for (; i-- > 0; p++) {
			o = (o << ASN_SHIFT7) + (*p & ~ASN_BIT8);
			if (*p & ASN_LONGLEN)
				continue;

			/*
			 * first subitem encodes two items with 1st*OIDMUX+2nd
			 */
			if (first < 0) {
				if (!nflag)
					objp = mibroot;
				first = 0;
				OBJ_PRINT(o/OIDMUX, first);
				o %= OIDMUX;
			}
			OBJ_PRINT(o, first);
			if (--first < 0)
				first = 0;
			o = 0;
		}
		break;
	}

	case BE_INT:
		printf("%d", elem->data.integer);
		break;

	case BE_UNS:
		printf("%d", elem->data.uns);
		break;

	case BE_UNS64:
		printf("%lld", elem->data.uns64);
		break;

	case BE_STR: {
		int printable = 1, first = 1;
		const u_char *p = elem->data.str;
		for (i = asnlen; printable && i-- > 0; p++)
			printable = isprint(*p) || isspace(*p);
		p = elem->data.str;
		if (printable) {
			putchar('"');
			(void)fn_print(p, p + asnlen);
			putchar('"');
		} else
			for (i = asnlen; i-- > 0; p++) {
				printf(first ? "%.2x" : "_%.2x", *p);
				first = 0;
			}
		break;
	}

	case BE_SEQ:
		printf("Seq(%u)", elem->asnlen);
		break;

	case BE_INETADDR: {
		char sep;
		if (asnlen != ASNLEN_INETADDR)
			printf("[inetaddr len!=%d]", ASNLEN_INETADDR);
		sep='[';
		for (i = asnlen; i-- > 0; p++) {
			printf("%c%u", sep, *p);
			sep='.';
		}
		putchar(']');
		break;
	}

	case BE_PDU:
		printf("%s(%u)",
			Class[CONTEXT].Id[elem->id], elem->asnlen);
		break;

	case BE_ANY:
		fputs("[BE_ANY!?]", stdout);
		break;

	default:
		fputs("[be!?]", stdout);
		break;
	}
}

#ifdef notdef
/*
 * This is a brute force ASN.1 printer: recurses to dump an entire structure.
 * This will work for any ASN.1 stream, not just an SNMP PDU.
 *
 * By adding newlines and spaces at the correct places, this would print in
 * Rose-Normal-Form.
 *
 * This is not currently used.
 */
static void
asn1_decode(u_char *p, u_int length)
{
	struct be elem;
	int i = 0;

	while (i >= 0 && length > 0) {
		i = asn1_parse(p, length, &elem);
		if (i >= 0) {
			fputs(" ", stdout);
			asn1_print(&elem);
			if (elem.type == BE_SEQ || elem.type == BE_PDU) {
				fputs(" {", stdout);
				asn1_decode(elem.data.raw, elem.asnlen);
				fputs(" }", stdout);
			}
			length -= i;
			p += i;
		}
	}
}
#endif

/*
 * General SNMP header
 *	SEQUENCE {
 *		version INTEGER {version-1(0)},
 *		community OCTET STRING,
 *		data ANY	-- PDUs
 *	}
 * PDUs for all but Trap: (see rfc1157 from page 15 on)
 *	SEQUENCE {
 *		request-id INTEGER,
 *		error-status INTEGER,
 *		error-index INTEGER,
 *		varbindlist SEQUENCE OF
 *			SEQUENCE {
 *				name ObjectName,
 *				value ObjectValue
 *			}
 *	}
 * PDU for Trap:
 *	SEQUENCE {
 *		enterprise OBJECT IDENTIFIER,
 *		agent-addr NetworkAddress,
 *		generic-trap INTEGER,
 *		specific-trap INTEGER,
 *		time-stamp TimeTicks,
 *		varbindlist SEQUENCE OF
 *			SEQUENCE {
 *				name ObjectName,
 *				value ObjectValue
 *			}
 *	}
 */

/*
 * Decode SNMP varBind
 */
static void
varbind_print(u_char pduid, const u_char *np, u_int length, int error)
{
	struct be elem;
	int count = 0, ind;

	/* Sequence of varBind */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_SEQ) {
		fputs("[!SEQ of varbind]", stdout);
		asn1_print(&elem);
		return;
	}
	if (count < length)
		printf("[%d extra after SEQ of varbind]", length - count);
	/* descend */
	length = elem.asnlen;
	np = (u_char *)elem.data.raw;

	for (ind = 1; length > 0; ind++) {
		const u_char *vbend;
		u_int vblength;

		if (!error || ind == error)
			fputs(" ", stdout);

		/* Sequence */
		if ((count = asn1_parse(np, length, &elem)) < 0)
			return;
		if (elem.type != BE_SEQ) {
			fputs("[!varbind]", stdout);
			asn1_print(&elem);
			return;
		}
		vbend = np + count;
		vblength = length - count;
		/* descend */
		length = elem.asnlen;
		np = (u_char *)elem.data.raw;

		/* objName (OID) */
		if ((count = asn1_parse(np, length, &elem)) < 0)
			return;
		if (elem.type != BE_OID) {
			fputs("[objName!=OID]", stdout);
			asn1_print(&elem);
			return;
		}
		if (!error || ind == error)
			asn1_print(&elem);
		length -= count;
		np += count;

		if (pduid != GETREQ && pduid != GETNEXTREQ && !error)
				fputs("=", stdout);

		/* objVal (ANY) */
		if ((count = asn1_parse(np, length, &elem)) < 0)
			return;
		if (pduid == GETREQ || pduid == GETNEXTREQ || pduid == GETBULKREQ) {
			if (elem.type != BE_NULL) {
				fputs("[objVal!=NULL]", stdout);
				asn1_print(&elem);
			}
		} else
			if (error && ind == error && elem.type != BE_NULL)
				fputs("[err objVal!=NULL]", stdout);
			if (!error || ind == error)
				asn1_print(&elem);

		length = vblength;
		np = vbend;
	}
}

/*
 * Decode SNMP PDUs: GetRequest, GetNextRequest, GetResponse, and SetRequest
 */
static void
snmppdu_print(u_char pduid, const u_char *np, u_int length)
{
	struct be elem;
	int count = 0, error;

	/* reqId (Integer) */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_INT) {
		fputs("[reqId!=INT]", stdout);
		asn1_print(&elem);
		return;
	}
	/* ignore the reqId */
	length -= count;
	np += count;

	/* errorStatus (Integer) */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_INT) {
		fputs("[errorStatus!=INT]", stdout);
		asn1_print(&elem);
		return;
	}
	error = 0;
	if ((pduid == GETREQ || pduid == GETNEXTREQ)
	    && elem.data.integer != 0) {
		char errbuf[20];
		printf("[errorStatus(%s)!=0]",
			DECODE_ErrorStatus(elem.data.integer));
	} else if (pduid == GETBULKREQ)
		printf(" non-repeaters=%d", elem.data.integer);
	else if (elem.data.integer != 0) {
		char errbuf[20];
		printf(" %s", DECODE_ErrorStatus(elem.data.integer));
		error = elem.data.integer;
	}
	length -= count;
	np += count;

	/* errorIndex (Integer) */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_INT) {
		fputs("[errorIndex!=INT]", stdout);
		asn1_print(&elem);
		return;
	}
	if ((pduid == GETREQ || pduid == GETNEXTREQ)
	    && elem.data.integer != 0)
		printf("[errorIndex(%d)!=0]", elem.data.integer);
	else if (pduid == GETBULKREQ)
		printf(" max-repetitions=%d", elem.data.integer);
	else if (elem.data.integer != 0) {
		if (!error)
			printf("[errorIndex(%d) w/o errorStatus]",
				elem.data.integer);
		else {
			printf("@@%d", elem.data.integer);
			error = elem.data.integer;
		}
	} else if (error) {
		fputs("[errorIndex==0]", stdout);
		error = 0;
	}
	length -= count;
	np += count;

	varbind_print(pduid, np, length, error);
	return;
}

/*
 * Decode SNMP Trap PDU
 */
static void
trap_print(const u_char *np, u_int length)
{
	struct be elem;
	int count = 0, generic;

	putchar(' ');

	/* enterprise (oid) */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_OID) {
		fputs("[enterprise!=OID]", stdout);
		asn1_print(&elem);
		return;
	}
	asn1_print(&elem);
	length -= count;
	np += count;

	putchar(' ');

	/* agent-addr (inetaddr) */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_INETADDR) {
		fputs("[agent-addr!=INETADDR]", stdout);
		asn1_print(&elem);
		return;
	}
	asn1_print(&elem);
	length -= count;
	np += count;

	/* generic-trap (Integer) */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_INT) {
		fputs("[generic-trap!=INT]", stdout);
		asn1_print(&elem);
		return;
	}
	generic = elem.data.integer;
	{
		char buf[20];
		printf(" %s", DECODE_GenericTrap(generic));
	}
	length -= count;
	np += count;

	/* specific-trap (Integer) */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_INT) {
		fputs("[specific-trap!=INT]", stdout);
		asn1_print(&elem);
		return;
	}
	if (generic != GT_ENTERPRISE) {
		if (elem.data.integer != 0)
			printf("[specific-trap(%d)!=0]", elem.data.integer);
	} else
		printf(" s=%d", elem.data.integer);
	length -= count;
	np += count;

	putchar(' ');

	/* time-stamp (TimeTicks) */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_UNS) {			/* XXX */
		fputs("[time-stamp!=TIMETICKS]", stdout);
		asn1_print(&elem);
		return;
	}
	asn1_print(&elem);
	length -= count;
	np += count;

	varbind_print (TRAP, np, length, 0);
	return;
}

/*
 * Decode SNMP header and pass on to PDU printing routines
 */
void
snmp_print(const u_char *np, u_int length)
{
	struct be elem, pdu;
	int count = 0;

	truncated = 0;

	/* truncated packet? */
	if (np + length > snapend) {
		truncated = 1;
		length = snapend - np;
	}

	putchar(' ');

	/* initial Sequence */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_SEQ) {
		fputs("[!init SEQ]", stdout);
		asn1_print(&elem);
		return;
	}
	if (count < length)
		printf("[%d extra after iSEQ]", length - count);
	/* descend */
	length = elem.asnlen;
	np = (u_char *)elem.data.raw;
	/* Version (Integer) */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_INT) {
		fputs("[version!=INT]", stdout);
		asn1_print(&elem);
		return;
	}
	/* only handle version 1 and 2 */
	if (elem.data.integer > DEF_VERSION) {
		printf("[version(%d)>%d]", elem.data.integer, DEF_VERSION);
		return;
	}
	length -= count;
	np += count;

	/* Community (String) */
	if ((count = asn1_parse(np, length, &elem)) < 0)
		return;
	if (elem.type != BE_STR) {
		fputs("[comm!=STR]", stdout);
		asn1_print(&elem);
		return;
	}
	/* default community */
	if (strncmp((char *)elem.data.str, DEF_COMMUNITY,
	    sizeof(DEF_COMMUNITY) - 1))
		/* ! "public" */
		printf("C=%.*s ", (int)elem.asnlen, elem.data.str);
	length -= count;
	np += count;

	/* PDU (Context) */
	if ((count = asn1_parse(np, length, &pdu)) < 0)
		return;
	if (pdu.type != BE_PDU) {
		fputs("[no PDU]", stdout);
		return;
	}
	if (count < length)
		printf("[%d extra after PDU]", length - count);
	asn1_print(&pdu);
	/* descend into PDU */
	length = pdu.asnlen;
	np = (u_char *)pdu.data.raw;

	switch (pdu.id) {
	case TRAP:
		trap_print(np, length);
		break;
	case GETREQ:
	case GETNEXTREQ:
	case GETRESP:
	case SETREQ:
	case GETBULKREQ:
	case INFORMREQ:
	case TRAPV2:
	case REPORT:
		snmppdu_print(pdu.id, np, length);
		break;
	}
	return;
}
@


1.20
log
@Remove memory.h includes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.19 2015/11/16 00:16:39 mmcc Exp $	*/
a348 1
#define ifNotTruncated if (truncated) fputs("[|snmp]", stdout); else
d367 4
a370 1
		ifNotTruncated puts("[nothing to parse], stdout");
d404 4
a407 1
			ifNotTruncated fputs("[Xtagfield?]", stdout);
d416 4
a419 1
		ifNotTruncated fputs("[no asnlen]", stdout);
d430 4
a433 1
			ifNotTruncated printf("[asnlen? %d<%d]", len, noct);
d451 4
a454 1
		ifNotTruncated printf("[form?%d]", form);
d458 4
a461 1
		ifNotTruncated printf("[class?%c/%d]", *Form[form], class);
d465 5
a469 2
		ifNotTruncated printf("[id?%c/%s/%d]", *Form[form],
			Class[class].name, id);
@


1.19
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.18 2015/01/16 06:40:21 deraadt Exp $	*/
a60 3
#ifdef HAVE_MEMORY_H
#include <memory.h>
#endif
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.17 2009/11/12 00:02:16 deraadt Exp $	*/
d363 1
a363 1
asn1_parse(register const u_char *p, u_int len, struct be *elem)
d467 1
a467 1
				register int32_t data;
d511 1
a511 1
				register u_int32_t data;
d521 1
a521 1
				register u_int64_t data;
d659 1
a659 1
		register int printable = 1, first = 1;
@


1.17
log
@fix read-one-beyond-of-array errors; ok sthen jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.16 2009/10/27 23:59:55 deraadt Exp $	*/
a57 1
#include <sys/param.h>
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.15 2008/01/17 17:33:15 reyk Exp $	*/
d191 1
a191 1
	( t >= 0 && t <= sizeof(GenericTrap)/sizeof(GenericTrap[0]) \
@


1.15
log
@add basic snmpv2 support (snmpv2, trapv2, getbulk)

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.14 2007/10/30 12:32:32 reyk Exp $	*/
a56 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id: print-snmp.c,v 1.14 2007/10/30 12:32:32 reyk Exp $ (LBL)";
#endif
@


1.14
log
@fix printing of enterprise-specific SNMP traps.

ok claudio@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.13 2007/10/07 16:41:05 deraadt Exp $	*/
d60 1
a60 1
    "@@(#) $Id: print-snmp.c,v 1.13 2007/10/07 16:41:05 deraadt Exp $ (LBL)";
d112 8
a119 1
	"Opaque"
d134 1
a134 1
	"Trap"
d136 8
d163 14
a176 1
	"genErr"
d236 1
a236 1
	u_char	oid;			/* sub-id following parent */
d273 4
d309 1
d326 1
d333 1
a333 1
#define DEF_VERSION 0
d513 4
a516 1
			case TIMETICKS: {
d526 10
d660 4
d843 1
a843 1
		if (pduid == GETREQ || pduid == GETNEXTREQ) {
d894 3
a896 1
	} else if (elem.data.integer != 0) {
d915 2
d1063 3
a1065 3
	/* only handle version==0 */
	if (elem.data.integer != DEF_VERSION) {
		printf("[version(%d)!=0]", elem.data.integer);
d1109 4
@


1.13
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.12 2005/04/11 07:40:10 deraadt Exp $	*/
d60 1
a60 1
    "@@(#) $Id$ (LBL)";
d165 1
a165 1
#define GT_ENTERPRISE 7
@


1.12
log
@tcpdump developers are uncautious retards, plain and simple; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.11 2004/03/19 04:55:03 aaron Exp $	*/
d60 1
a60 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-snmp.c,v 1.11 2004/03/19 04:55:03 aaron Exp $ (LBL)";
@


1.11
log
@Remove errant ';' from end of for() statement. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.10 2001/11/06 03:11:40 deraadt Exp $	*/
d60 1
a60 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-snmp.c,v 1.10 2001/11/06 03:11:40 deraadt Exp $ (LBL)";
d840 1
a840 1
		char errbuf[10];
d844 1
a844 1
		char errbuf[10];
d928 1
a928 1
		char buf[10];
@


1.10
log
@a bit of snprintf cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.9 2001/08/11 22:26:39 jakob Exp $	*/
d60 1
a60 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-snmp.c,v 1.9 2001/08/11 22:26:39 jakob Exp $ (LBL)";
d558 1
a558 1
		for (i = asnlen; i-- > 0; p++);
@


1.9
log
@update license. ok from author (John LoVerso).
@
text
@d1 1
a1 1
/*	$OpenBSD: print-snmp.c,v 1.8 2000/10/03 14:31:58 ho Exp $	*/
d60 1
a60 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-snmp.c,v 1.8 2000/10/03 14:31:58 ho Exp $ (LBL)";
d152 1
a152 1
	? ErrorStatus[e] : (sprintf(errbuf, "err=%u", e), errbuf))
d169 1
a169 1
	? GenericTrap[t] : (sprintf(buf, "gt=%d", t), buf))
@


1.8
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 23
a27 1
 *	The Regents of the University of California.  All rights reserved.
a28 9
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by John Robert LoVerso.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d60 1
a60 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-snmp.c,v 1.7 2000/04/26 21:35:43 jakob Exp $ (LBL)";
@


1.7
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d47 1
a47 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-snmp.c,v 1.6 1999/09/16 20:58:47 brad Exp $ (LBL)";
@


1.6
log
@bring more inline with tcpdump 3.4
@
text
@d45 1
a45 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-snmp.c,v 1.5 1996/12/12 16:22:27 bitblt Exp $ (LBL)";
d52 3
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
 * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996
d29 1
a29 1
 #	Copyright, 1990.  The Regents of the University of California.
d45 1
a45 1
    "@@(#) $Header: print-snmp.c,v 1.31 96/12/10 23:22:55 leres Exp $ (LBL)";
d51 1
a52 1
#include <ctype.h>
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d42 1
d44 2
a45 2
static char rcsid[] =
    "@@(#) Id: print-snmp.c,v 3.10 91/01/17 01:18:13 loverso Exp Locker: loverso (jlv)";
a49 1
#include <sys/types.h>
d162 2
a163 2
	int	numIDs;
} Class[] = {
d261 2
a262 1
	u_char form, class, id;		/* tag info */
d317 1
a317 1
asn1_parse(register const u_char *p, int len, struct be *elem)
d342 2
a343 2
	form = (*p & ASN_FORM_BITS) >> ASN_FORM_SHIFT;
	class = (*p & ASN_CLASS_BITS) >> ASN_CLASS_SHIFT;
d356 1
a356 1
			id += *p & ~ASN_BIT8;
d362 4
d404 1
a404 1
	if (id >= Class[class].numIDs) {
d601 2
a602 1
		if (printable)
d604 2
a605 1
		else
d656 1
a656 1
asn1_decode(u_char *p, int length)
d715 1
a715 1
varbind_print(u_char pduid, const u_char *np, int length, int error)
d736 1
a736 1
		int vblength;
d794 1
a794 1
snmppdu_print(u_char pduid, const u_char *np, int length)
d867 1
a867 1
trap_print(const u_char *np, int length)
d954 1
a954 1
snmp_print(const u_char *np, int length)
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-snmp.c,v 1.3 1995/03/06 19:11:30 mycroft Exp $	*/
/*	$NetBSD: print-snmp.c,v 1.3 1995/03/06 19:11:30 mycroft Exp $	*/
d4 2
a5 2
 * Copyright (c) 1990, 1991, 1993, 1994
 *    John Robert LoVerso.  All rights reserved.
d15 1
a15 1
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d136 1
a136 1
	? ErrorStatus[e] : (sprintf(errbuf, "err=%d", e), errbuf))
d256 1
a256 1
	u_long asnlen;
d259 2
a260 2
		long integer;
		u_long uns;
d418 1
a418 1
				register long data;
d459 1
a459 1
				register u_long data;
d531 1
a531 1
	u_long asnlen = elem->asnlen;
d550 2
a551 1
				if (!bcmp(a->oid, (char *)p, strlen(a->oid))) {
d585 1
a585 1
		printf("%ld", elem->data.integer);
d589 1
a589 1
		printf("%ld", elem->data.uns);
d609 1
a609 1
		printf("Seq(%d)", elem->asnlen);
d626 1
a626 1
		printf("%s(%d)",
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
