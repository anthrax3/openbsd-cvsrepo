head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.2
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.16
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.12
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.16
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.14
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.12
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.10
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.8
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.12
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.10
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.8
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.6
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2017.02.27.11.44.23;	author jca;	state Exp;
branches;
next	1.23;
commitid	UjX9xeCwVI66R61t;

1.23
date	2016.03.07.19.33.26;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	dH2OOqaSrGDRNHR8;

1.22
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	enjTsnD5UO6xazKc;

1.21
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.19;
commitid	yLXrOcgrag4eS8u4;

1.19
date	2014.05.23.20.36.04;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.04.17.37.05;	author canacar;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.18.15.33.30;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.28.19.46.11;	author jakob;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.28.00.47.40;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.05.22.40.11;	author jakob;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.03.14.31.56;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.26.21.35.40;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.16.12.43.58;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	99.09.16.20.58.46;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.20.12.23;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.40;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.18;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.21;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Print the DNSSEC OKAY flag as "DO", like in upstream tcpdump

ok florian@@
@
text
@/*	$OpenBSD: print-domain.c,v 1.23 2016/03/07 19:33:26 mmcc Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/time.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>

#ifdef NOERROR
#undef NOERROR					/* Solaris sucks */
#endif
#ifdef NOERROR
#undef T_UNSPEC					/* SINIX does too */
#endif
#include "nameser.h"

#include <stdio.h>
#include <string.h>

#include "interface.h"
#include "addrtoname.h"
#include "extract.h"                    /* must come after interface.h */

static const char *ns_ops[] = {
	"", " inv_q", " stat", " op3", " notify", " update", " op6", " op7",
	" op8", " updataA", " updateD", " updateDA",
	" updateM", " updateMA", " zoneInit", " zoneRef",
};

static const char *ns_resp[] = {
	"", " FormErr", " ServFail", " NXDomain",
	" NotImp", " Refused", " YXDomain", " YXRRSet",
	" NXRRSet", " NotAuth", " NotZone", " Resp11",
	" Resp12", " Resp13", " Resp14", " NoChange",
};

/* skip over a domain name */
static const u_char *
ns_nskip(const u_char *cp)
{
	u_char i;

	if (!TTEST2(*cp, 1))
		return (NULL);
	i = *cp++;
	while (i) {
		if ((i & INDIR_MASK) == INDIR_MASK)
			return (cp + 1);
		if ((i & INDIR_MASK) == EDNS0_MASK) {
			int bitlen, bytelen;

			if ((i & ~INDIR_MASK) != EDNS0_ELT_BITLABEL)
				return(NULL); /* unknown ELT */
			if (!TTEST2(*cp, 1))
				return (NULL);
			if ((bitlen = *cp++) == 0)
				bitlen = 256;
			bytelen = (bitlen + 7) / 8;
			cp += bytelen;
		} else
			cp += i;
		if (!TTEST2(*cp, 1))
			return (NULL);
		i = *cp++;
	}
	return (cp);
}

/* print a <domain-name> */
static const u_char *
blabel_print(const u_char *cp)
{
	int bitlen, slen, b;
	const u_char *bitp, *lim;
	char tc;

	if (!TTEST2(*cp, 1))
		return(NULL);
	if ((bitlen = *cp) == 0)
		bitlen = 256;
	slen = (bitlen + 3) / 4;
	lim = cp + 1 + slen;

	/* print the bit string as a hex string */
	printf("\\[x");
	for (bitp = cp + 1, b = bitlen; bitp < lim && b > 7; b -= 8, bitp++) {
		TCHECK(*bitp);
		printf("%02x", *bitp);
	}
	if (b > 4) {
		TCHECK(*bitp);
		tc = *bitp++;
		printf("%02x", tc & (0xff << (8 - b)));
	} else if (b > 0) {
		TCHECK(*bitp);
		tc = *bitp++;
		printf("%1x", ((tc >> 4) & 0x0f) & (0x0f << (4 - b)));
	}
	printf("/%d]", bitlen);
	return lim;
trunc:
	printf(".../%d]", bitlen);
	return NULL;
}

static int
labellen(const u_char *cp)
{
	u_int i;

	if (!TTEST2(*cp, 1))
		return(-1);
	i = *cp;
	if ((i & INDIR_MASK) == EDNS0_MASK) {
		int bitlen, elt;
		if ((elt = (i & ~INDIR_MASK)) != EDNS0_ELT_BITLABEL) {
			printf("<ELT %d>", elt);
			return(-1);
		}
		if (!TTEST2(*(cp + 1), 1))
			return(-1);
		if ((bitlen = *(cp + 1)) == 0)
			bitlen = 256;
		return(((bitlen + 7) / 8) + 1);
	} else
		return(i);
}

static const u_char *
ns_nprint(const u_char *cp, const u_char *bp)
{
	u_int i, l;
	const u_char *rp = NULL;
	int compress = 0;
	int chars_processed;
	int elt;
	int data_size = snapend - bp;

	if ((l = labellen(cp)) == (u_int)-1)
		return(NULL);
	if (!TTEST2(*cp, 1))
		return(NULL);
	chars_processed = 1;
	if (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {
		compress = 0;
		rp = cp + l;
	}

	if (i != 0)
		while (i && cp < snapend) {
			if ((i & INDIR_MASK) == INDIR_MASK) {
				if (!compress) {
					rp = cp + 1;
					compress = 1;
				}
				if (!TTEST2(*cp, 1))
					return(NULL);
				cp = bp + (((i << 8) | *cp) & 0x3fff);
				if ((l = labellen(cp)) == (u_int)-1)
					return(NULL);
				if (!TTEST2(*cp, 1))
					return(NULL);
				i = *cp++;
				chars_processed++;

				/*
				 * If we've looked at every character in
				 * the message, this pointer will make
				 * us look at some character again,
				 * which means we're looping.
				 */
				if (chars_processed >= data_size) {
					printf("<LOOP>");
					return (NULL);
				}
				continue;
			}
			if ((i & INDIR_MASK) == EDNS0_MASK) {
				elt = (i & ~INDIR_MASK);
				switch(elt) {
				case EDNS0_ELT_BITLABEL:
					if (blabel_print(cp) == NULL)
						return (NULL);
					break;
				default:
					/* unknown ELT */
					printf("<ELT %d>", elt);
					return(NULL);
				}
			} else {
				if (fn_printn(cp, l, snapend))
					return(NULL);
			}

			cp += l;
			chars_processed += l;
			putchar('.');
			if ((l = labellen(cp)) == (u_int)-1)
				return(NULL);
			if (!TTEST2(*cp, 1))
				return(NULL);
			i = *cp++;
			chars_processed++;
			if (!compress)
				rp += l + 1;
		}
	else
		putchar('.');
	return (rp);
}

/* print a <character-string> */
static const u_char *
ns_cprint(const u_char *cp)
{
	u_int i;

	if (!TTEST2(*cp, 1))
		return (NULL);
	i = *cp++;
	if (fn_printn(cp, i, snapend))
		return (NULL);
	return (cp + i);
}

/* https://www.iana.org/assignments/dns-parameters */
struct tok ns_type2str[] = {
	{ T_A,		"A" },			/* RFC 1035 */
	{ T_NS,		"NS" },			/* RFC 1035 */
	{ T_MD,		"MD" },			/* RFC 1035 */
	{ T_MF,		"MF" },			/* RFC 1035 */
	{ T_CNAME,	"CNAME" },		/* RFC 1035 */
	{ T_SOA,	"SOA" },		/* RFC 1035 */
	{ T_MB,		"MB" },			/* RFC 1035 */
	{ T_MG,		"MG" },			/* RFC 1035 */
	{ T_MR,		"MR" },			/* RFC 1035 */
	{ T_NULL,	"NULL" },		/* RFC 1035 */
	{ T_WKS,	"WKS" },		/* RFC 1035 */
	{ T_PTR,	"PTR" },		/* RFC 1035 */
	{ T_HINFO,	"HINFO" },		/* RFC 1035 */
	{ T_MINFO,	"MINFO" },		/* RFC 1035 */
	{ T_MX,		"MX" },			/* RFC 1035 */
	{ T_TXT,	"TXT" },		/* RFC 1035 */
	{ T_RP,		"RP" },			/* RFC 1183 */
	{ T_AFSDB,	"AFSDB" },		/* RFC 1183 */
	{ T_X25,	"X25" },		/* RFC 1183 */
	{ T_ISDN,	"ISDN" },		/* RFC 1183 */
	{ T_RT,		"RT" },			/* RFC 1183 */
	{ T_NSAP,	"NSAP" },		/* RFC 1706 */
	{ T_NSAP_PTR,	"NSAP_PTR" },
	{ T_SIG,	"SIG" },		/* RFC 2535 */
	{ T_KEY,	"KEY" },		/* RFC 2535 */
	{ T_PX,		"PX" },			/* RFC 2163 */
	{ T_GPOS,	"GPOS" },		/* RFC 1712 */
	{ T_AAAA,	"AAAA" },		/* RFC 1886 */
	{ T_LOC,	"LOC" },		/* RFC 1876 */
	{ T_NXT,	"NXT" },		/* RFC 2535 */
	{ T_EID,	"EID" },		/* Nimrod */
	{ T_NIMLOC,	"NIMLOC" },		/* Nimrod */
	{ T_SRV,	"SRV" },		/* RFC 2782 */
	{ T_ATMA,	"ATMA" },		/* ATM Forum */
	{ T_NAPTR,	"NAPTR" },		/* RFC 2168, RFC 2915 */
	{ T_KX,		"KX" },			/* RFC 2230 */
	{ T_CERT,	"CERT" },		/* RFC 2538 */
	{ T_A6,		"A6" },			/* RFC 2874 */
	{ T_DNAME,	"DNAME" },		/* RFC 2672 */
	{ T_SINK, 	"SINK" },
	{ T_OPT,	"OPT" },		/* RFC 2671 */
	{ T_APL, 	"APL" },		/* RFC 3123 */
	{ T_DS,		"DS" },			/* RFC 4034 */
	{ T_SSHFP,	"SSHFP" },		/* RFC 4255 */
	{ T_IPSECKEY,	"IPSECKEY" },		/* RFC 4025 */
	{ T_RRSIG, 	"RRSIG" },		/* RFC 4034 */
	{ T_NSEC,	"NSEC" },		/* RFC 4034 */
	{ T_DNSKEY,	"DNSKEY" },		/* RFC 4034 */
	{ T_SPF,	"SPF" },		/* RFC-schlitt-spf-classic-02.txt */
	{ T_UINFO,	"UINFO" },
	{ T_UID,	"UID" },
	{ T_GID,	"GID" },
	{ T_UNSPEC,	"UNSPEC" },
	{ T_UNSPECA,	"UNSPECA" },
	{ T_TKEY,	"TKEY" },		/* RFC 2930 */
	{ T_TSIG,	"TSIG" },		/* RFC 2845 */
	{ T_IXFR,	"IXFR" },		/* RFC 1995 */
	{ T_AXFR,	"AXFR" },		/* RFC 1035 */
	{ T_MAILB,	"MAILB" },		/* RFC 1035 */
	{ T_MAILA,	"MAILA" },		/* RFC 1035 */
	{ T_ANY,	"ANY" },
	{ 0,		NULL }
};

struct tok ns_class2str[] = {
	{ C_IN,		"IN" },		/* Not used */
	{ C_CHAOS,	"CHAOS" },
	{ C_HS,		"HS" },
	{ C_ANY,	"ANY" },
	{ 0,		NULL }
};

/* print a query */
static const u_char *
ns_qprint(const u_char *cp, const u_char *bp, int is_mdns)
{
	const u_char *np = cp;
	u_int i, class;

	cp = ns_nskip(cp);

	if (cp == NULL || !TTEST2(*cp, 4))
		return(NULL);

	/* print the qtype */
	i = EXTRACT_16BITS(cp);
	cp += 2;
	printf(" %s", tok2str(ns_type2str, "Type%d", i));
	/* print the qclass (if it's not IN) */
	i = EXTRACT_16BITS(cp);
	cp += 2;
	if (is_mdns)
		class = (i & ~C_QU);
	else
		class = i;
	if (class != C_IN)
		printf(" %s", tok2str(ns_class2str, "(Class %d)", class));
	if (is_mdns && (i & C_QU))
		printf(" (QU)");

	fputs("? ", stdout);
	cp = ns_nprint(np, bp);
	return(cp ? cp + 4 : NULL);
}

/* print a reply */
static const u_char *
ns_rprint(const u_char *cp, const u_char *bp, int is_mdns)
{
	u_int i, class, opt_flags = 0;
	u_short typ, len;
	const u_char *rp;

	if (vflag) {
		putchar(' ');
		if ((cp = ns_nprint(cp, bp)) == NULL)
			return NULL;
	} else
		cp = ns_nskip(cp);

	if (cp == NULL || !TTEST2(*cp, 10))
		return (snapend);

	/* print the type/qtype */
	typ = EXTRACT_16BITS(cp);
	cp += 2;
	/* print the class (if it's not IN and the type isn't OPT) */
	i = EXTRACT_16BITS(cp);
	cp += 2;
	if (is_mdns)
		class = (i & ~C_CACHE_FLUSH);
	else
		class = i;
	if (class != C_IN && typ != T_OPT)
		printf(" %s", tok2str(ns_class2str, "(Class %d)", class));
	if (is_mdns) {
		if (i & C_CACHE_FLUSH)
			printf(" (Cache flush)");
	}

	if (typ == T_OPT) {
		/* get opt flags */
		cp += 2;
		opt_flags = EXTRACT_16BITS(cp);
		/* ignore rest of ttl field */
		cp += 2;
	} else if (vflag > 2) {
		/* print ttl */
		printf(" [");
		relts_print(EXTRACT_32BITS(cp));
		printf("]");
		cp += 4;
	} else {
		/* ignore ttl */
		cp += 4;
	}

	len = EXTRACT_16BITS(cp);
	cp += 2;

	rp = cp + len;

	printf(" %s", tok2str(ns_type2str, "Type%d", typ));
	if (rp > snapend)
		return(NULL);

	switch (typ) {
	case T_A:
		if (!TTEST2(*cp, sizeof(struct in_addr)))
			return(NULL);
		printf(" %s", ipaddr_string(cp));
		break;

	case T_NS:
	case T_CNAME:
	case T_PTR:
#ifdef T_DNAME
	case T_DNAME:
#endif
		putchar(' ');
		if (ns_nprint(cp, bp) == NULL)
			return(NULL);
		break;

	case T_SOA:
		if (!vflag)
			break;
		putchar(' ');
		if ((cp = ns_nprint(cp, bp)) == NULL)
			return(NULL);
		putchar(' ');
		if ((cp = ns_nprint(cp, bp)) == NULL)
			return(NULL);
		if (!TTEST2(*cp, 5 * 4))
			return(NULL);
		printf(" %u", EXTRACT_32BITS(cp));
		cp += 4;
		printf(" %u", EXTRACT_32BITS(cp));
		cp += 4;
		printf(" %u", EXTRACT_32BITS(cp));
		cp += 4;
		printf(" %u", EXTRACT_32BITS(cp));
		cp += 4;
		printf(" %u", EXTRACT_32BITS(cp));
		cp += 4;
		break;
	case T_MX:
		putchar(' ');
		if (!TTEST2(*cp, 2))
			return(NULL);
		if (ns_nprint(cp + 2, bp) == NULL)
			return(NULL);
		printf(" %d", EXTRACT_16BITS(cp));
		break;

	case T_TXT:
		while (cp < rp) {
			printf(" \"");
			cp = ns_cprint(cp);
			if (cp == NULL)
				return(NULL);
			putchar('"');
		}
		break;

	case T_SRV:
		putchar(' ');
		if (!TTEST2(*cp, 6))
			return(NULL);
		if (ns_nprint(cp + 6, bp) == NULL)
			return(NULL);
		printf(":%d %d %d", EXTRACT_16BITS(cp + 4),
			EXTRACT_16BITS(cp), EXTRACT_16BITS(cp + 2));
		break;

#ifdef INET6
	case T_AAAA:
		if (!TTEST2(*cp, sizeof(struct in6_addr)))
			return(NULL);
		printf(" %s", ip6addr_string(cp));
		break;

	case T_A6:
	    {
		struct in6_addr a;
		int pbit, pbyte;

		if (!TTEST2(*cp, 1))
			return(NULL);
		pbit = *cp;
		pbyte = (pbit & ~7) / 8;
		if (pbit > 128) {
			printf(" %u(bad plen)", pbit);
			break;
		} else if (pbit < 128) {
			if (!TTEST2(*(cp + 1), sizeof(a) - pbyte))
				return(NULL);
			memset(&a, 0, sizeof(a));
			memcpy(&a.s6_addr[pbyte], cp + 1, sizeof(a) - pbyte);
			printf(" %u %s", pbit, ip6addr_string(&a));
		}
		if (pbit > 0) {
			putchar(' ');
			if (ns_nprint(cp + 1 + sizeof(a) - pbyte, bp) == NULL)
				return(NULL);
		}
		break;
	    }
#endif /*INET6*/

	case T_OPT:
		printf(" UDPsize=%u", class);
		if (opt_flags & 0x8000)
			printf(" DO");
		break;

	case T_UNSPECA:		/* One long string */
		if (!TTEST2(*cp, len))
			return(NULL);
		if (fn_printn(cp, len, snapend))
			return(NULL);
		break;

	case T_TSIG:
	    {
		if (cp + len > snapend)
			return(NULL);
		if (!vflag)
			break;
		putchar(' ');
		if ((cp = ns_nprint(cp, bp)) == NULL)
			return(NULL);
		cp += 6;
		if (!TTEST2(*cp, 2))
			return(NULL);
		printf(" fudge=%u", EXTRACT_16BITS(cp));
		cp += 2;
		if (!TTEST2(*cp, 2))
			return(NULL);
		printf(" maclen=%u", EXTRACT_16BITS(cp));
		cp += 2 + EXTRACT_16BITS(cp);
		if (!TTEST2(*cp, 2))
			return(NULL);
		printf(" origid=%u", EXTRACT_16BITS(cp));
		cp += 2;
		if (!TTEST2(*cp, 2))
			return(NULL);
		printf(" error=%u", EXTRACT_16BITS(cp));
		cp += 2;
		if (!TTEST2(*cp, 2))
			return(NULL);
		printf(" otherlen=%u", EXTRACT_16BITS(cp));
		cp += 2;
	    }
	}
	return (rp);		/* XXX This isn't always right */
}

void
ns_print(const u_char *bp, u_int length, int is_mdns)
{
	const HEADER *np;
	int qdcount, ancount, nscount, arcount;
	const u_char *cp;
	u_int16_t b2;

	np = (const HEADER *)bp;
	TCHECK(*np);
	/* get the byte-order right */
	qdcount = EXTRACT_16BITS(&np->qdcount);
	ancount = EXTRACT_16BITS(&np->ancount);
	nscount = EXTRACT_16BITS(&np->nscount);
	arcount = EXTRACT_16BITS(&np->arcount);

	if (DNS_QR(np)) {
		/* this is a response */
		printf(" %d%s%s%s%s%s%s",
			EXTRACT_16BITS(&np->id),
			ns_ops[DNS_OPCODE(np)],
			ns_resp[DNS_RCODE(np)],
			DNS_AA(np)? "*" : "",
			DNS_RA(np)? "" : "-",
			DNS_TC(np)? "|" : "",
			DNS_AD(np)? "$" : "");

		if (qdcount != 1)
			printf(" [%dq]", qdcount);
		/* Print QUESTION section on -vv */
		cp = (const u_char *)(np + 1);
		while (qdcount--) {
			if (qdcount < EXTRACT_16BITS(&np->qdcount) - 1)
				putchar(',');
			if (vflag > 1) {
				fputs(" q:", stdout);
				if ((cp = ns_qprint(cp, bp, is_mdns)) == NULL)
					goto trunc;
			} else {
				if ((cp = ns_nskip(cp)) == NULL)
					goto trunc;
				cp += 4;	/* skip QTYPE and QCLASS */
			}
		}
		printf(" %d/%d/%d", ancount, nscount, arcount);
		if (ancount--) {
			if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
				goto trunc;
			while (cp < snapend && ancount--) {
				putchar(',');
				if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
					goto trunc;
			}
		}
		if (ancount > 0)
			goto trunc;
		/* Print NS and AR sections on -vv */
		if (vflag > 1) {
			if (cp < snapend && nscount--) {
				fputs(" ns:", stdout);
				if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
					goto trunc;
				while (cp < snapend && nscount--) {
					putchar(',');
					if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
						goto trunc;
				}
			}
			if (nscount > 0)
				goto trunc;
			if (cp < snapend && arcount--) {
				fputs(" ar:", stdout);
				if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
					goto trunc;
				while (cp < snapend && arcount--) {
					putchar(',');
					if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
						goto trunc;
				}
			}
			if (arcount > 0)
				goto trunc;
		}
	}
	else {
		/* this is a request */
		printf(" %d%s%s%s", EXTRACT_16BITS(&np->id), ns_ops[DNS_OPCODE(np)],
		    DNS_RD(np) ? "+" : "",
		    DNS_CD(np) ? "%" : "");

		/* any weirdness? AA is expected in NOTIFY. */
		b2 = EXTRACT_16BITS(((u_short *)np)+1);
		if ((b2 & 0x6cf) !=
		    (DNS_OPCODE(np) == NS_NOTIFY_OP ? htons(0x400) : 0))
			printf(" [b2&3=0x%x]", b2);

		if (DNS_OPCODE(np) == IQUERY) {
			if (qdcount)
				printf(" [%dq]", qdcount);
			if (ancount != 1)
				printf(" [%da]", ancount);
		}
		else {
			if (ancount)
				printf(" [%da]", ancount);
			if (qdcount != 1)
				printf(" [%dq]", qdcount);
		}
		if (nscount)
			printf(" [%dn]", nscount);
		if (arcount)
			printf(" [%dau]", arcount);

		cp = (const u_char *)(np + 1);
		if (qdcount--) {
			cp = ns_qprint(cp, (const u_char *)np, is_mdns);
			if (!cp)
				goto trunc;
			while (cp < snapend && qdcount--) {
				cp = ns_qprint((const u_char *)cp,
					       (const u_char *)np,
					       is_mdns);
				if (!cp)
					goto trunc;
			}
		}
		if (qdcount > 0)
			goto trunc;

		/* Print remaining sections on -vv */
		if (vflag > 1) {
			if (ancount--) {
				if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
					goto trunc;
				while (cp < snapend && ancount--) {
					putchar(',');
					if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
						goto trunc;
				}
			}
			if (ancount > 0)
				goto trunc;
			if (cp < snapend && nscount--) {
				fputs(" ns:", stdout);
				if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
					goto trunc;
				while (nscount-- && cp < snapend) {
					putchar(',');
					if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
						goto trunc;
				}
			}
			if (nscount > 0)
				goto trunc;
			if (cp < snapend && arcount--) {
				fputs(" ar:", stdout);
				if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
					goto trunc;
				while (cp < snapend && arcount--) {
					putchar(',');
					if ((cp = ns_rprint(cp, bp, is_mdns)) == NULL)
						goto trunc;
				}
			}
			if (arcount > 0)
				goto trunc;
		}
	}
	printf(" (%d)", length);
	return;

  trunc:
	printf("[|domain]");
	return;
}
@


1.23
log
@http -> https for IETF/IANA URLs in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.22 2015/11/16 00:16:39 mmcc Exp $	*/
d529 1
a529 1
			printf(" OK");
@


1.22
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.21 2015/01/16 06:40:21 deraadt Exp $	*/
d254 1
a254 1
/* http://www.iana.org/assignments/dns-parameters */
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.20 2014/08/14 12:44:44 mpi Exp $	*/
d67 1
a67 1
ns_nskip(register const u_char *cp)
d69 1
a69 1
	register u_char i;
d137 1
a137 1
	register u_int i;
d158 1
a158 1
ns_nprint(register const u_char *cp, register const u_char *bp)
d160 3
a162 3
	register u_int i, l;
	register const u_char *rp = NULL;
	register int compress = 0;
d242 1
a242 1
ns_cprint(register const u_char *cp)
d244 1
a244 1
	register u_int i;
d330 1
a330 1
ns_qprint(register const u_char *cp, register const u_char *bp, int is_mdns)
d332 2
a333 2
	register const u_char *np = cp;
	register u_int i, class;
d363 1
a363 1
ns_rprint(register const u_char *cp, register const u_char *bp, int is_mdns)
d365 3
a367 3
	register u_int i, class, opt_flags = 0;
	register u_short typ, len;
	register const u_char *rp;
d575 1
a575 1
ns_print(register const u_char *bp, u_int length, int is_mdns)
d577 3
a579 3
	register const HEADER *np;
	register int qdcount, ancount, nscount, arcount;
	register const u_char *cp;
@


1.20
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.19 2014/05/23 20:36:04 sthen Exp $	*/
a23 1
#include <sys/param.h>
@


1.19
log
@Don't print a "weird flag" type warning "[b2&3=0x2400]" for DNS NOTIFY
messages which should be sent with AA set. Adapted from a patch at
http://marc.info/?l=tcpdump-patches&m=98115734907026&w=2 pointed out by
Peter J. Philipp, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.18 2010/11/04 17:37:05 canacar Exp $	*/
a31 1
#include <netinet/in_systm.h>
@


1.18
log
@Sync with tcpdump.org to fix multicast DNS support, and get some
other updates in the process. Initial report/patch from  Christiano
F. Haesbaert. Ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d666 1
a666 1
		/* any weirdness? */
d668 2
a669 1
		if (b2 & 0x6cf)
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.16 2007/10/07 16:41:05 deraadt Exp $	*/
a103 1
	int truncated = 0;
d112 1
a112 4
	if ((lim = cp + 1 + slen) > snapend) {
		truncated = 1;
		lim = snapend;
	}
d116 2
a117 1
	for (bitp = cp + 1, b = bitlen; bitp < lim && b > 7; b -= 8, bitp++)
d119 3
a121 3
	if (bitp == lim)
		printf("...");
	else if (b > 4) {
d125 1
d130 4
a133 2

	return(truncated ? NULL : lim);
d146 2
a147 2

		if ((elt = (i & ~INDIR_MASK)) != EDNS0_ELT_BITLABEL)
d149 1
d293 2
a294 1
	{ T_KX,		"KX" },
d297 1
a297 1
	{ T_SINK,	"SINK" },
d299 8
a306 6
	{ T_APL,	"APL" },
	{ T_DS,		"DS" },
	{ T_SSHFP,	"SSHFP" },
	{ T_RRSIG,	"RRSIG" },
	{ T_NSEC,	"NSEC" },
	{ T_DNSKEY,	"DNSKEY" },
d335 1
a335 1
	register u_int i;
d342 1
a342 1
	/* print the qtype and qclass (if it's not IN) */
d346 1
d349 8
a356 4
	if (is_mdns && i == (C_IN|C_CACHE_FLUSH))
		printf(" (Cache flush)");
	else if (i != C_IN)
		printf(" %s", tok2str(ns_class2str, "(Class %d)", i));
d367 1
a367 1
	register u_int class;
d381 1
a381 1
	/* print the type/qtype and class (if it's not IN) */
d384 2
a385 1
	class = EXTRACT_16BITS(cp);
d387 5
a391 3
	if (is_mdns && class == (C_IN|C_CACHE_FLUSH))
		printf(" (Cache flush)");
	else if (class != C_IN && typ != T_OPT)
d393 4
d398 16
a413 2
	/* ignore ttl */
	cp += 4;
d530 2
@


1.16
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.15 2004/01/18 15:33:30 otto Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.15
log
@Sync print-domain with tcpdump.org; avoids tcpdump barfing on bogus
DNS traffic.

ok canacar@@ jakob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.14 2001/03/28 19:46:11 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /tcpdump/master/tcpdump/print-domain.c,v 1.86.2.2 2003/11/16 08:51:17 guy Exp $ (LBL)";
@


1.14
log
@improved print-domain. from tcpdump.org.
- better error control
- TSIG printing
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.13 2001/03/28 00:47:40 mickey Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-domain.c,v 1.13 2001/03/28 00:47:40 mickey Exp $ (LBL)";
d59 1
a59 1
static char *ns_ops[] = {
d65 1
a65 1
static char *ns_resp[] = {
d74 1
a74 1
ns_nskip(register const u_char *cp, register const u_char *bp)
d80 1
a80 2
	if (((i = *cp++) & INDIR_MASK) == INDIR_MASK)
		return (cp + 1);
d82 2
d173 1
a173 1
	if ((l = labellen(cp)) < 0)
d193 1
a193 1
				if ((l = labellen(cp)) < 0)
d232 1
a232 1
			if ((l = labellen(cp)) < 0)
d248 1
a248 1
ns_cprint(register const u_char *cp, register const u_char *bp)
d260 1
d262 22
a283 22
	{ T_A,		"A" },
	{ T_NS,		"NS" },
	{ T_MD,		"MD" },
	{ T_MF,		"MF" },
	{ T_CNAME,	"CNAME" },
	{ T_SOA,	"SOA" },
	{ T_MB,		"MB" },
	{ T_MG,		"MG" },
	{ T_MR,		"MR" },
	{ T_NULL,	"NULL" },
	{ T_WKS,	"WKS" },
	{ T_PTR,	"PTR" },
	{ T_HINFO,	"HINFO" },
	{ T_MINFO,	"MINFO" },
	{ T_MX,		"MX" },
	{ T_TXT,	"TXT" },
	{ T_RP,		"RP" },
	{ T_AFSDB,	"AFSDB" },
	{ T_X25,	"X25" },
	{ T_ISDN,	"ISDN" },
	{ T_RT,		"RT" },
	{ T_NSAP,	"NSAP" },
d285 23
a307 16
	{ T_SIG,	"SIG" },
	{ T_KEY,	"KEY" },
	{ T_PX,		"PX" },
	{ T_GPOS,	"GPOS" },
	{ T_AAAA,	"AAAA" },
	{ T_LOC,	"LOC" },
	{ T_NXT,	"NXT" },
	{ T_EID,	"EID" },
	{ T_NIMLOC,	"NIMLOC" },
	{ T_SRV,	"SRV" },
	{ T_ATMA,	"ATMA" },
	{ T_NAPTR,	"NAPTR" },
	{ T_CERT,	"CERT" },
	{ T_A6,		"A6" },
	{ T_DNAME,	"DNAME" },
	{ T_OPT,	"OPT" },
d313 6
a318 6
	{ T_TKEY,	"TKEY" },
	{ T_TSIG,	"TSIG" },
	{ T_IXFR,	"IXFR" },
	{ T_AXFR,	"AXFR" },
	{ T_MAILB,	"MAILB" },
	{ T_MAILA,	"MAILA" },
d333 1
a333 1
ns_qprint(register const u_char *cp, register const u_char *bp)
d338 1
a338 1
	cp = ns_nskip(cp, bp);
d344 2
a345 2
	i = *cp++ << 8;
	i |= *cp++;
d347 5
a351 3
	i = *cp++ << 8;
	i |= *cp++;
	if (i != C_IN)
d361 1
a361 1
ns_rprint(register const u_char *cp, register const u_char *bp)
d372 1
a372 1
		cp = ns_nskip(cp, bp);
d378 7
a384 5
	typ = *cp++ << 8;
	typ |= *cp++;
	class = *cp++ << 8;
	class |= *cp++;
	if (class != C_IN && typ != T_OPT)
d390 2
a391 2
	len = *cp++ << 8;
	len |= *cp++;
d449 10
d460 6
a465 1
		(void)ns_cprint(cp, bp);
d550 1
a550 1
ns_print(register const u_char *bp, u_int length)
d554 2
a555 1
	register const u_char *cp = NULL;
d560 4
a563 4
	qdcount = ntohs(np->qdcount);
	ancount = ntohs(np->ancount);
	nscount = ntohs(np->nscount);
	arcount = ntohs(np->arcount);
d568 1
a568 1
			ntohs(np->id),
d574 1
a574 1
			DNS_CD(np)? "%" : "");
d581 1
a581 1
			if (qdcount < ntohs(np->qdcount) - 1)
d585 1
a585 2
				if ((cp = ns_qprint((const u_char *)(np + 1), bp))
				    == NULL)
d588 1
a588 2
				if ((cp = ns_nskip((const u_char *)(np + 1), bp))
				    == NULL)
d595 1
a595 1
			if ((cp = ns_rprint(cp, bp)) == NULL)
d599 1
a599 1
				if ((cp = ns_rprint(cp, bp)) == NULL)
d609 1
a609 1
				if ((cp = ns_rprint(cp, bp)) == NULL)
d613 1
a613 1
					if ((cp = ns_rprint(cp, bp)) == NULL)
d621 1
a621 1
				if ((cp = ns_rprint(cp, bp)) == NULL)
d625 1
a625 1
					if ((cp = ns_rprint(cp, bp)) == NULL)
d635 1
a635 1
		printf(" %d%s%s%s", ntohs(np->id), ns_ops[DNS_OPCODE(np)],
d637 1
a637 1
		    DNS_AD(np) ? "$" : "");
d640 3
a642 2
		if (*(((u_short *)np)+1) & htons(0x6cf))
			printf(" [b2&3=0x%x]", ntohs(*(((u_short *)np)+1)));
d661 1
d663 1
a663 2
			cp = ns_qprint((const u_char *)(np + 1),
				       (const u_char *)np);
d668 2
a669 1
					       (const u_char *)np);
a678 2
			if (!cp)
				goto trunc;
d680 1
a680 1
				if ((cp = ns_rprint(cp, bp)) == NULL)
d684 1
a684 1
					if ((cp = ns_rprint(cp, bp)) == NULL)
d692 1
a692 1
				if ((cp = ns_rprint(cp, bp)) == NULL)
d696 1
a696 1
					if ((cp = ns_rprint(cp, bp)) == NULL)
d704 1
a704 1
				if ((cp = ns_rprint(cp, bp)) == NULL)
d708 1
a708 1
					if ((cp = ns_rprint(cp, bp)) == NULL)
@


1.13
log
@do not core on truncated query-less dns packets; fix pr1746
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.12 2001/03/05 22:40:11 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-domain.c,v 1.12 2001/03/05 22:40:11 jakob Exp $ (LBL)";
d60 1
a60 1
	"", " inv_q", " stat", " op3", " notify", " op5", " op6", " op7",
d67 2
a68 2
	" NotImp", " Refused", " Resp6", " Resp7",
	" Resp8", " Resp9", " Resp10", " Resp11",
d78 2
d82 1
a82 3
	if (cp >= snapend)
		return(NULL);
	while (i && cp < snapend) {
d88 2
d96 2
a97 2
		if (cp >= snapend)
			return(NULL);
d112 1
a112 1
	if (cp >= snapend)
d145 1
a145 1
	if (cp >= snapend)
d153 1
a153 1
		if (cp + 1 >= snapend)
d174 1
a174 1
	if (cp >= snapend)
d189 2
d192 1
a192 1
				if (cp >= snapend)
d194 1
a194 1
				if ((l = labellen(cp)) < 0)
d215 2
a216 1
					blabel_print(cp);
d225 1
a225 1
					break;
d231 3
a233 1
			if (cp >= snapend || (l = labellen(cp)) < 0)
d251 2
a252 2
	if (cp >= snapend)
		return NULL;
d254 2
a255 1
	(void)fn_printn(cp, i, snapend);
d304 3
d331 1
a331 1
	if (cp + 4 > snapend || cp == NULL)
d363 1
a363 1
	if (cp + 10 > snapend || cp == NULL)
d388 1
a388 1
		if (cp + sizeof(struct in_addr) > snapend)
d413 1
a413 1
		if (cp + 5 * 4 > snapend)
d428 1
a428 1
		if (cp + 2 > snapend)
d442 1
a442 1
		if (cp + sizeof(struct in6_addr) > snapend)
d452 2
d460 2
d480 8
d490 27
a516 2
		fn_printn(cp, len, snapend);
		break;
d529 1
d547 18
a564 10
		if (vflag > 1) {
			fputs(" q:", stdout);
			if ((cp = ns_qprint((const u_char *)(np + 1), bp))
			    == NULL)
				goto trunc;
		} else {
			if ((cp = ns_nskip((const u_char *)(np + 1), bp))
			    == NULL)
				goto trunc;
			cp += 4;
@


1.12
log
@improved DNS support (EDNS, A6). from tcpdump.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-domain.c,v 1.11 2000/10/03 14:31:56 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-domain.c,v 1.11 2000/10/03 14:31:56 ho Exp $ (LBL)";
d593 2
@


1.11
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-domain.c,v 1.10 2000/04/26 21:35:40 jakob Exp $ (LBL)";
a32 4
#ifdef __STDC__
struct mbuf;
struct rtentry;
#endif
d50 1
a50 1
#include <arpa/nameser.h>
a58 79
/* Compatibility */
#ifndef T_TXT
#define T_TXT		16		/* text strings */
#endif
#ifndef T_RP
#define T_RP		17		/* responsible person */
#endif
#ifndef T_AFSDB
#define T_AFSDB		18		/* AFS cell database */
#endif
#ifndef T_X25
#define T_X25		19		/* X_25 calling address */
#endif
#ifndef T_ISDN
#define T_ISDN		20		/* ISDN calling address */
#endif
#ifndef T_RT
#define T_RT		21		/* router */
#endif
#ifndef T_NSAP
#define T_NSAP		22		/* NSAP address */
#endif
#ifndef T_NSAP_PTR
#define T_NSAP_PTR	23		/* reverse NSAP lookup (deprecated) */
#endif
#ifndef T_SIG
#define T_SIG		24		/* security signature */
#endif
#ifndef T_KEY
#define T_KEY		25		/* security key */
#endif
#ifndef T_PX
#define T_PX		26		/* X.400 mail mapping */
#endif
#ifndef T_GPOS
#define T_GPOS		27		/* geographical position (withdrawn) */
#endif
#ifndef T_AAAA
#define T_AAAA		28		/* IP6 Address */
#endif
#ifndef T_LOC
#define T_LOC		29		/* Location Information */
#endif
#ifndef T_NXT
#define T_NXT		30		/* Next Valid Name in Zone */
#endif
#ifndef T_EID
#define T_EID		31		/* Endpoint identifier */
#endif
#ifndef T_NIMLOC
#define T_NIMLOC	32		/* Nimrod locator */
#endif
#ifndef T_SRV
#define T_SRV		33		/* Server selection */
#endif
#ifndef T_ATMA
#define T_ATMA		34		/* ATM Address */
#endif
#ifndef T_NAPTR
#define T_NAPTR		35		/* Naming Authority PoinTeR */
#endif
#ifndef T_A6
#define T_A6		38		/* IP6 address (ipngwg-dns-lookups) */
#endif

#ifndef T_UNSPEC
#define T_UNSPEC	103		/* Unspecified format (binary data) */
#endif
#ifndef T_UNSPECA
#define T_UNSPECA	104		/* "unspecified ascii". Ugly MIT hack */
#endif

#ifndef C_CHAOS
#define C_CHAOS		3		/* for chaos net (MIT) */
#endif
#ifndef C_HS
#define C_HS		4		/* for Hesiod name server (MIT) (XXX) */
#endif

d80 2
d83 13
a95 1
		cp += i;
d103 58
d163 3
a165 3
	register u_int i;
	register const u_char *rp;
	register int compress;
d167 1
d170 4
a173 1
	i = *cp++;
d175 1
a175 5
	rp = cp + i;
	if ((i & INDIR_MASK) == INDIR_MASK) {
		rp = cp + 1;
		compress = 1;
	} else
d177 3
d183 4
d188 4
d202 2
a203 4
					fn_printn(cp, 6, "<LOOP>");
					if (!compress)
						rp += i + 1;
					return (rp);
d207 18
a224 4
			if (fn_printn(cp, i, snapend))
				break;
			cp += i;
			chars_processed += i;
d226 2
d231 1
a231 1
				rp += i + 1;
d244 2
d251 1
a251 1
static struct tok type2str[] = {
d280 11
a290 11
	{ T_LOC,	"LOC " },
	{ T_NXT,	"NXT " },
	{ T_EID,	"EID " },
	{ T_NIMLOC,	"NIMLOC " },
	{ T_SRV,	"SRV " },
	{ T_ATMA,	"ATMA " },
	{ T_NAPTR,	"NAPTR " },
	{ T_A6,		"A6 " },
#ifndef T_UINFO
#define T_UINFO 100
#endif
a291 3
#ifndef T_UID
#define T_UID 101
#endif
a292 3
#ifndef T_GID
#define T_GID 102
#endif
d303 1
a303 1
static struct tok class2str[] = {
d305 1
a305 1
	{ C_CHAOS,	"CHAOS)" },
d312 1
a312 1
static void
d320 2
a321 2
	if (cp + 4 > snapend)
		return;
d326 1
a326 1
	printf(" %s", tok2str(type2str, "Type%d", i));
d330 1
a330 1
		printf(" %s", tok2str(class2str, "(Class %d)", i));
d333 2
a334 1
	ns_nprint(np, bp);
d341 1
a341 1
	register u_int i;
d347 2
a348 1
		cp = ns_nprint(cp, bp);
d352 1
a352 1
	if (cp + 10 > snapend)
d358 4
a361 4
	i = *cp++ << 8;
	i |= *cp++;
	if (i != C_IN)
		printf(" %s", tok2str(class2str, "(Class %d)", i));
d371 4
a374 1
	printf(" %s", tok2str(type2str, "Type%d", typ));
a375 1

d377 2
d386 1
a386 1
	case T_DNAME:	/*XXX not checked as there's no server support yet*/
d389 2
a390 1
		(void)ns_nprint(cp, bp);
d393 22
d417 4
a420 1
		(void)ns_nprint(cp + 2, bp);
d431 2
d436 1
a436 1
	case T_A6:	/*XXX not checked as there's no server support yet*/
d439 1
a439 1
		int pbyte;
d441 15
a455 5
		pbyte = (*cp + 7) / 8;
		memset(&a, 0, sizeof(a));
		memcpy(&a, cp + 1, pbyte);
		printf(" %u %s ", *cp, ip6addr_string(&a));
		(void)ns_nprint(cp + 1 + pbyte, bp);
d460 4
d465 3
a467 1
	        printf(" %.*s", len, cp);
d478 1
a478 1
	register const u_char *cp;
d487 1
a487 1
	if (np->qr) {
d489 1
a489 1
		printf(" %d%s%s%s%s%s",
d491 7
a497 8
			ns_ops[np->opcode],
			ns_resp[np->rcode],
			np->aa? "*" : "",
			np->ra? "" : "-",
			np->tc? "|" : "");
		if (qdcount != 1)
			printf(" [%dq]", qdcount);
		/* Print QUESTION section on -vv */
d499 10
a508 4
		            fputs(" q: ", stdout);
			    cp = ns_nprint((const u_char *)(np + 1), bp);
		} else
			    cp = ns_nskip((const u_char *)(np + 1), bp);
d511 3
a513 2
			cp = ns_rprint(cp + 4, bp);
			while (ancount-- && cp < snapend) {
d515 17
a531 1
				cp = ns_rprint(cp, bp);
d533 14
d551 3
a553 4
		printf(" %d%s%s",
		        ntohs(np->id),
			ns_ops[np->opcode],
			np->rd? "+" : "");
d556 1
a556 1
		if (*(((u_short *)np)+1) & htons(0x6ff))
d559 1
a559 1
		if (np->opcode == IQUERY) {
d576 53
a628 1
		ns_qprint((const u_char *)(np + 1), (const u_char *)np);
d631 5
@


1.10
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-domain.c,v 1.9 2000/01/16 12:43:58 jakob Exp $ (LBL)";
@


1.9
log
@INET6 (from KAME)
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-domain.c,v 1.8 1999/09/16 20:58:46 brad Exp $ (LBL)";
a44 1
#include <netinet/tcpip.h>
d55 1
d175 2
d179 1
d191 14
d210 1
d213 1
@


1.8
log
@bring more inline with tcpdump 3.4
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-domain.c,v 1.7 1999/07/28 20:41:36 jakob Exp $ (LBL)";
d104 21
d243 8
a250 1
	{ T_LOC ,	"LOC " },
d348 3
d365 19
@


1.7
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-domain.c,v 1.6 1997/07/25 20:12:23 mickey Exp $ (LBL)";
a52 1

a104 12
#ifndef T_UINFO
#define T_UINFO		100
#endif

#ifndef T_UID
#define T_UID		101
#endif

#ifndef T_GID
#define T_GID		102
#endif

a107 1

d223 3
d227 3
d231 3
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-domain.c,v 1.5 1996/12/12 16:22:40 bitblt Exp $ (LBL)";
d47 1
d49 2
d52 2
d106 12
d121 1
@


1.5
log
@*** empty log message ***
@
text
@d24 1
a24 1
    "@@(#) $Header: print-domain.c,v 1.37 96/12/10 23:21:06 leres Exp $ (LBL)";
d31 1
a31 1
#if __STDC__
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d23 2
a24 2
static char rcsid[] =
    "@@(#) Header: print-domain.c,v 1.29 96/06/19 00:49:25 leres Exp (LBL)";
a28 1
#include <sys/types.h>
d48 1
d57 1
a57 1
/* Compatiblity */
d165 3
a167 3
			do {
				putchar(*cp++);
			} while (--i);
d185 2
a186 5
	if (cp + i < snapend)
		do {
			putchar(*cp++);
		} while (--i);
	return (cp);
d314 1
a314 1
		printf(" %d", EXTRACT_SHORT(cp));
d326 1
a326 1
	return (rp);		/* XXX This isn't always right*/
d330 1
a330 1
ns_print(register const u_char *bp, int length)
@


1.3
log
@sync to latest
@
text
@d4 1
a4 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
d26 1
a26 1
    "@@(#) Header: print-domain.c,v 1.23 94/06/14 20:17:38 leres Exp (LBL)";
d34 4
d57 59
d118 1
a118 1
	"", " inv_q", " stat", " op3", " op4", " op5", " op6", " op7",
d132 1
a132 1
ns_nskip(register const u_char *cp)
d136 1
a136 1
	if (((i = *cp++) & 0xc0) == 0xc0)
d138 1
a138 1
	while (i) {
d145 3
a147 4
/* print a domain name */
static void
ns_nprint(register const u_char *cp, register const u_char *bp,
	  register const u_char *ep)
d150 2
d153 10
a162 4
	putchar(' ');
	if ((i = *cp++) != 0)
		while (i && cp < ep) {
			if ((i & 0xc0) == 0xc0) {
d172 2
d177 15
d194 1
a194 1
static struct token type2str[] = {
d210 14
a226 1
#ifdef T_UNSPEC
d228 1
a228 1
#endif
d236 8
d246 1
a246 2
ns_qprint(register const u_char *cp, register const u_char *bp,
	  register const u_char *ep)
d248 1
a248 1
	const u_char *np = cp;
d251 1
a251 1
	cp = ns_nskip(cp);
d253 1
a253 1
	if (cp + 4 > ep)
d261 3
a263 5
	if ((i |= *cp++) != C_IN)
		if (i == C_ANY)
			printf("(c_any)");
		else
			printf("(Class %d)", i);
d265 2
a266 2
	putchar('?');
	ns_nprint(np, bp, ep);
a268 1

d270 2
a271 3
static void
ns_rprint(register const u_char *cp, register const u_char *bp,
	  register const u_char *ep)
d274 2
a275 1
	u_short typ;
d277 5
a281 1
	cp = ns_nskip(cp);
d283 2
a284 2
	if (cp + 10 > ep)
		return;
d290 11
a300 5
	if ((i |= *cp++) != C_IN)
		if (i == C_ANY)
			printf("(c_any)");
		else
			printf("(Class %d)", i);
a301 2
	/* ignore ttl & len */
	cp += 6;
d312 2
a313 1
		ns_nprint(cp, bp, ep);
d317 12
a328 9
		ns_nprint(cp+2, bp, ep);
#ifndef TCPDUMP_ALIGN
		printf(" %d", *(short *)cp);
#else
		{
		    u_short x = *cp | cp[1] << 8;
		    printf(" %d", ntohs(x));
		}
#endif
d331 1
d338 2
a339 2
	int qdcount, ancount, nscount, arcount;
	const u_char *ep = snapend;
d359 6
d366 7
a372 3
		if (ancount)
			ns_rprint(ns_nskip((const u_char *)(np + 1)) + 4,
				  (const u_char *)np, ep);
d402 1
a402 1
		ns_qprint((const u_char *)(np + 1), (const u_char *)np, ep);
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d2 1
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
