head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.6
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.6
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.4
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.23
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.22;
commitid	enjTsnD5UO6xazKc;

1.22
date	2015.10.11.03.23.28;	author guenther;	state Exp;
branches;
next	1.21;
commitid	qKDtxPUi0fjziHg4;

1.21
date	2015.03.29.14.09.29;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	SFj5yhNu0OcZK6bT;

1.20
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	Uu5nFG3wCl0LACBb;

1.19
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.18;
commitid	yLXrOcgrag4eS8u4;

1.18
date	2014.01.11.04.35.52;	author lteo;	state Exp;
branches;
next	1.17;

1.17
date	2012.05.03.10.17.23;	author mikeb;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.06.16.01.57;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.11.13.23.01;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.18.01.53.06;	author mcbride;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.26.18.22.30;	author moritz;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.26.06.24.48;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.19.14.25.04;	author naddy;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.17.08.45.37;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.20.23.39.20;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.27.03.34.44;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.03.14.21.56;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.26.21.35.41;	author jakob;	state Exp;
branches;
next	1.3;

1.3
date	99.10.29.09.44.07;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	99.09.21.20.54.58;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@/*	$OpenBSD: print-ipsec.c,v 1.22 2015/10/11 03:23:28 guenther Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Format and print IPsec (ESP/AH) packets.
 *      By Tero Kivinen <kivinen@@ssh.fi>, Tero Mononen <tmo@@ssh.fi>,  
 *         Tatu Ylonen <ylo@@ssh.fi> and Timo J. Rinne <tri@@ssh.fi>
 *         in co-operation with SSH Communications Security, Espoo, Finland    
 */

#include <sys/time.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif

#include "addrtoname.h"
#include "interface.h"
#include "extract.h"		    /* must come after interface.h */

#include <openssl/evp.h>
#include <ctype.h>

/*
 * IPsec/ESP header
 */
struct esp_hdr {
	u_int esp_spi;
	u_int esp_seq;
};

static int espinit = 0;
static int espauthlen = 12;
static EVP_CIPHER_CTX ctx;

int
esp_init (char *espspec)
{
	const EVP_CIPHER *evp;
	char *p, *espkey, s[3], name[1024];
	u_char *key;
	int i, klen, len;

	evp = EVP_aes_128_cbc();	/* default */
	espkey = espspec;
	if ((p = strchr(espspec, ':')) != NULL) {
		len = p - espspec;
		if (len >= sizeof(name))
			error("espalg too long");
		memcpy(name, espspec, len);
		name[len] = '\0';
		espkey = p + 1;

		/* strip auth alg */
		espauthlen = 0;
		if ((p = strstr(name, "-hmac96")) != NULL) {
			espauthlen = 12;
			*p = '\0';
		}
		OpenSSL_add_all_algorithms();
		if ((evp = EVP_get_cipherbyname(name)) == NULL)
			error("espalg `%s' not supported", name);
	}
	klen = EVP_CIPHER_key_length(evp);
	if (strlen(espkey) != klen * 2)
		error("espkey size mismatch, %d bytes needed", klen);
	if ((key = malloc(klen)) == NULL)
		error("malloc failed");
	for (i = 0; i < klen; i++) {
		s[0] = espkey[2*i];
		s[1] = espkey[2*i + 1];
		s[2] = 0;
		if (!isxdigit((unsigned char)s[0]) ||
		    !isxdigit((unsigned char)s[1])) {
			free(key);
			error("espkey must be specified in hex");
		}
		key[i] = strtoul(s, NULL, 16);
	}
	EVP_CIPHER_CTX_init(&ctx);
	if (EVP_CipherInit(&ctx, evp, key, NULL, 0) < 0) {
		free(key);
		error("espkey init failed");
	}
	free(key);
	espinit = 1;
	return (0);
}

void 
esp_decrypt (const u_char *bp, u_int len, const u_char *bp2)
{
	const struct ip *ip;
	u_char *data, pad, nh;
	int blocksz;
 
	ip = (const struct ip *)bp2;

	blocksz = EVP_CIPHER_CTX_block_size(&ctx);

	/* Skip fragments and short packets */
	if (ntohs(ip->ip_off) & 0x3fff)
		return;
	if (snapend - bp < len) {
		printf(" [|esp]");
		return;
	}
	/*
	 * Skip ESP header and ignore authentication trailer.
	 * For decryption we need at least 2 blocks: IV and
	 * one cipher block.
	 */
	if (len < sizeof(struct esp_hdr) + espauthlen + 2 * blocksz) {
		printf(" [|esp]");
		return;
	}

	data = (char *)bp;
	data += sizeof(struct esp_hdr);
	len -= sizeof(struct esp_hdr);
	len -= espauthlen;

	/* the first block contains the IV */
	EVP_CipherInit(&ctx, NULL, NULL, data, 0);
	len -= blocksz;
	data += blocksz;

	/* decrypt remaining payload */
	EVP_Cipher(&ctx, data, data, len);

	nh = data[len - 1];
	pad = data[len - 2];

	/* verify padding */
	if (pad + 2 > len)
		return;
	if (data[len - 3]  != pad)
		return;
	if (vflag > 1)
		printf(" pad %d", pad);
	len -= (pad + 2);
	printf(": ");
	switch (nh) {
	case IPPROTO_TCP:
		tcp_print(data, len, bp2);
		break;
	case IPPROTO_UDP:
		udp_print(data, len, bp2);
		break;
	case IPPROTO_IPV6:
		ip6_print(data, len);
		break;
	case IPPROTO_IPV4:
		ip_print(data, len);
		break;
	case IPPROTO_ICMP:
		icmp_print(data, len, bp2);
		break;
	case IPPROTO_ICMPV6:
		icmp6_print(data, len, bp2);
		break;
	default:
		printf("ip-proto-%d %d", nh, len);
		break;
	}
	if (vflag)
		printf(" (esp)");
}

void 
esp_print (const u_char *bp, u_int len, const u_char *bp2)
{
	const struct ip *ip;
	const struct esp_hdr *esp;
	u_int plen = len;
#ifdef INET6
	const struct ip6_hdr *ip6;
#endif
 
	ip = (const struct ip *)bp2;
#ifdef INET6
	if (ip->ip_v == 6) {
		ip6 = (const struct ip6_hdr *)bp2;
		printf("esp %s > %s", ip6addr_string(&ip6->ip6_src),
		    ip6addr_string(&ip6->ip6_dst));
	} else
#endif
	{
		printf("esp %s > %s",
	    	    ipaddr_string(&ip->ip_src), ipaddr_string(&ip->ip_dst));
	}

	if (plen < sizeof(struct esp_hdr)) {
		printf("[|esp]");
		return;
	}
	esp = (const struct esp_hdr *)bp;

	printf(" spi 0x%08x seq %u len %d",
	    ntohl(esp->esp_spi), ntohl(esp->esp_seq), len);

	if (espinit)
		esp_decrypt(bp, len, bp2);
}

/*
 * IPsec/AH header
 */
struct ah_hdr {
	u_char  ah_nxt_hdr;
	u_char  ah_pl_len;
	u_short ah_reserved;
	u_int   ah_spi;
	u_int   ah_seq;
};

void
ah_print (const u_char *bp, u_int len, const u_char *bp2)
{
	const struct ip *ip;
	const struct ah_hdr *ah;
	u_int pl_len = len;
#ifdef INET6
	const struct ip6_hdr *ip6;
#endif

	ip = (const struct ip *)bp2;
#ifdef INET6
	if (ip->ip_v == 6) {
		ip6 = (const struct ip6_hdr *)bp2;
		printf("ah %s > %s", ip6addr_string(&ip6->ip6_src),
		    ip6addr_string(&ip6->ip6_dst));
	} else
#endif
	{
		printf("ah %s > %s",
	    	    ipaddr_string(&ip->ip_src), ipaddr_string(&ip->ip_dst));
	}

	if (pl_len < sizeof(struct ah_hdr)) {
		printf("[|ah]");
		return;
	}
	ah = (const struct ah_hdr *)bp;

	printf(" spi 0x%08x seq %u len %d",
	    ntohl(ah->ah_spi), ntohl(ah->ah_seq), len);

	if (vflag) {
	        (void)printf(" [ ");

	        pl_len = (ah->ah_pl_len + 2) << 2; /* RFC2402, sec 2.2 */

		if (len <= pl_len) {
		        (void)printf("truncated");
			goto out;
		}
		
		switch (ah->ah_nxt_hdr) { 

		case IPPROTO_IPIP: /* Tunnel Mode, IP-in-IP */
		        ip_print(bp + pl_len, len - pl_len); 
			break;

	        case IPPROTO_ICMP: /* From here and down; Transport mode */
		        icmp_print(bp + pl_len, len - pl_len,
				  (const u_char *) ip);
			break;

	        case IPPROTO_ICMPV6:
		        icmp6_print(bp + pl_len, len - pl_len,
				  (const u_char *) ip);
			break;

	        case IPPROTO_TCP:
		        tcp_print(bp + pl_len, len - pl_len, 
				  (const u_char *) ip);
			break;

	        case IPPROTO_UDP:
		        udp_print(bp + pl_len, len - pl_len, 
				  (const u_char *) ip);
			break;

		case IPPROTO_ESP:
		        esp_print(bp + pl_len, len - pl_len, 
				  (const u_char *) ip);
			break;

		case IPPROTO_AH:
		        ah_print(bp + pl_len, len - pl_len, 
				 (const u_char *) ip);
			break;

		default:
		        (void)printf("ip-proto-%d len %d", ah->ah_nxt_hdr,
				     len - pl_len);
		}
out:
		(void)printf(" ]");
	}

}

struct ipcomp_hdr {
	u_char  ipcomp_nxt_hdr;
	u_char	ipcomp_flags;
	u_short	ipcomp_cpi;
};

void
ipcomp_print (const u_char *bp, u_int len, const u_char *bp2)
{
	const struct ip *ip;
	const struct ipcomp_hdr *ipc;
	u_int plen = len;
 
	ip = (const struct ip *)bp2;

	printf("ipcomp %s > %s",
	    ipaddr_string(&ip->ip_src), ipaddr_string(&ip->ip_dst));

	if (plen < sizeof(struct ipcomp_hdr)) {
		printf("[|ipcomp]");
		return;
	}
	ipc = (const struct ipcomp_hdr *)bp;

	printf(" cpi 0x%04X flags %x next %x",
	    ntohs(ipc->ipcomp_cpi), ipc->ipcomp_flags, ipc->ipcomp_nxt_hdr);
}
@


1.22
log
@The <ctype.h> is*() interfaces expect EOF or an unsigned char; cast to
(unsigned char) as required

found by Michael McConville (mmcconv1 (at) sccs.swarthmore.edu) w/Coccinelle
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.21 2015/03/29 14:09:29 bluhm Exp $	*/
d202 1
a202 2
esp_print (register const u_char *bp, register u_int len,
	   register const u_char *bp2)
d249 1
a249 2
ah_print (register const u_char *bp, register u_int len,
	  register const u_char *bp2)
d343 1
a343 2
ipcomp_print (register const u_char *bp, register u_int len,
	  register const u_char *bp2)
@


1.21
log
@Most packets generate one line in tcpdump.  For AH and RIP there
was an extra line without benefit.  Remove the new-line in printf
to make parsing easier.
OK lteo@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.20 2015/01/16 06:40:21 deraadt Exp $	*/
d104 2
a105 1
		if (!isxdigit(s[0]) || !isxdigit(s[1])) {
@


1.20
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.19 2014/08/14 12:44:44 mpi Exp $	*/
d282 1
a282 1
	        (void)printf("\n\t[ ");
@


1.19
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.18 2014/01/11 04:35:52 lteo Exp $	*/
a28 1
#include <sys/param.h>
@


1.18
log
@Make icmp_print() accept the length variable, which is the length of the
packet without the IP header.  This is needed by the next commit that
will allow tcpdump to detect bad ICMP checksums.

Related functions like {tcp,udp,icmp6}_print() already accept this
length variable, so this change makes icmp_print() consistent with
them as well.

This commit makes no functional change to tcpdump itself.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.17 2012/05/03 10:17:23 mikeb Exp $	*/
a33 1
#include <netinet/in_systm.h>
a38 1
#include <netinet/tcpip.h>
@


1.17
log
@esp/ah sequence number is unsigned and should be printed as such;
ok haesbaert, sthen, yasuoka, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.16 2010/04/06 16:01:57 jsg Exp $	*/
d190 1
a190 1
		icmp_print(data, bp2);
d301 2
a302 1
		        icmp_print(bp + pl_len, (const u_char *) ip);
@


1.16
log
@Add support for decoding MLDv2 initially from tcpdump.org via FreeBSD,
cleaned up to be less gross after some suggestions from stsp.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.15 2009/11/11 13:23:01 jsg Exp $	*/
d233 1
a233 1
	printf(" spi 0x%08x seq %d len %d",
d281 1
a281 1
	printf(" spi 0x%08X seq %d len %d",
@


1.15
log
@Don't leak memory in error case.
Found by parfait.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.14 2009/10/27 23:59:55 deraadt Exp $	*/
d193 1
a193 1
		icmp6_print(data, bp2);
d305 2
a306 1
		        icmp6_print(bp + pl_len, (const u_char *) ip);
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.13 2009/02/18 01:53:06 mcbride Exp $	*/
d107 2
a108 1
		if (!isxdigit(s[0]) || !isxdigit(s[1]))
d110 1
@


1.13
log
@Print spi in lowercase hex for consistency with print-enc.c and ipsecctl.

ok hshoexer msf
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.12 2007/10/07 16:41:05 deraadt Exp $	*/
a27 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id: print-ipsec.c,v 1.12 2007/10/07 16:41:05 deraadt Exp $ (XXX)";
#endif
@


1.12
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.11 2006/12/26 18:22:30 moritz Exp $	*/
d31 1
a31 1
    "@@(#) $Id$ (XXX)";
d236 1
a236 1
	printf(" spi 0x%08X seq %d len %d",
@


1.11
log
@Fix truncation check by directly comparing both values and don't
compare the unsigned value of the subtraction against <= 0.

ok krw@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.10 2006/12/26 06:24:48 itojun Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ipsec.c,v 1.10 2006/12/26 06:24:48 itojun Exp $ (XXX)";
@


1.10
log
@print icmpv6 inside security header (ah/esp).
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.9 2006/09/19 14:25:04 naddy Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ipsec.c,v 1.9 2006/09/19 14:25:04 naddy Exp $ (XXX)";
d292 1
a292 1
		if (len - pl_len <= 0) {
@


1.9
log
@enable ESP and AH dissectors over IPv6; ok mpf@@ (at k2k6)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.8 2003/07/17 08:45:37 markus Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ipsec.c,v 1.8 2003/07/17 08:45:37 markus Exp $ (XXX)";
d195 3
d305 4
@


1.8
log
@add support for ESP decryption; ok deraadt@@; feedback mickey@@;
many manpage fixes from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.7 2003/02/20 23:39:20 jason Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /home/openbsd/src/usr.sbin/tcpdump/print-ipsec.c,v 1.4 2003/07/14 14:21:07 markus Exp markus $ (XXX)";
d52 4
d210 3
d215 11
a225 3

	printf("esp %s > %s",
	    ipaddr_string(&ip->ip_src), ipaddr_string(&ip->ip_dst));
d258 3
d263 11
a273 3

	printf("ah %s > %s",
	    ipaddr_string(&ip->ip_src), ipaddr_string(&ip->ip_dst));
@


1.7
log
@add printing of ipcomp, and while in the neighborhood, make ah/esp actually
check the length of the data
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.6 2001/06/27 03:34:44 angelos Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ipsec.c,v 1.6 2001/06/27 03:34:44 angelos Exp $ (XXX)";
d56 3
d67 132
d220 3
d250 1
a250 1
		printf("[|esp]");
@


1.6
log
@"IPSec" -> "IPsec" (jsyn@@nthought.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ipsec.c,v 1.5 2000/10/03 14:21:56 ho Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ipsec.c,v 1.5 2000/10/03 14:21:56 ho Exp $ (XXX)";
d70 6
d77 4
a80 1
	ip = (const struct ip *)bp2;
d83 2
a84 5
	(void)printf("esp %s > %s spi 0x%08X seq %d len %d",
		     ipaddr_string(&ip->ip_src),
		     ipaddr_string(&ip->ip_dst),
		     ntohl(esp->esp_spi), ntohl(esp->esp_seq), len);

d104 1
a104 1
	u_int pl_len;
d107 8
d117 2
a118 4
	(void)printf("ah %s > %s spi 0x%08X seq %d len %d",
		     ipaddr_string(&ip->ip_src),
		     ipaddr_string(&ip->ip_dst),
		     ntohl(ah->ah_spi), ntohl(ah->ah_seq), len);
d168 29
@


1.5
log
@Compile with -Wall. Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 1
a23 1
 * Format and print ipsec (esp/ah) packets.
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ipsec.c,v 1.4 2000/04/26 21:35:41 jakob Exp $ (XXX)";
d57 1
a57 1
 * IPSec/ESP header
d82 1
a82 1
 * IPSec/AH header
@


1.4
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ipsec.c,v 1.3 1999/10/29 09:44:07 ho Exp $ (XXX)";
d64 3
a66 2
void esp_print(register const u_char *bp, register u_int len,
	       register const u_char *bp2)
d92 3
a94 2
ah_print(register const u_char *bp, register u_int len,
	 register const u_char *bp2)
@


1.3
log
@Print AH payload data (with -v). jakob@@ ok.
@
text
@d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ipsec.c,v 1.2 1999/09/21 20:54:58 jakob Exp $ (XXX)";
a44 3
#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif
@


1.2
log
@print ESP/AH packet length; <ho@@openbsd.org>
@
text
@d29 1
a29 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ipsec.c,v 1.1 1999/07/28 20:41:36 jakob Exp $ (XXX)";
d85 5
a89 3
	u_int ah_dummy;
	u_int ah_spi;
	u_int ah_seq;
d97 1
d106 48
@


1.1
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d29 1
a29 1
    "@@(#) $Header: print-ike.c,v 0.0 00/00/00 00:00:00 xxx Exp $ (XXX)";
d74 1
a74 1
	(void)printf("esp %s > %s spi 0x%08X seq %d",
d77 1
a77 1
		     ntohl(esp->esp_spi), ntohl(esp->esp_seq));
d99 1
a99 1
	(void)printf("ah %s > %s spi 0x%08X seq %d",
d102 1
a102 1
		     ntohl(ah->ah_spi), ntohl(ah->ah_seq));
@

