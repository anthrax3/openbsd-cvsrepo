head	1.37;
access;
symbols
	OPENBSD_6_2:1.37.0.14
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.12
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.10
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.4
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.36.0.14
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.12
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.8
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.6
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.4
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.2
	OPENBSD_5_0:1.35.0.6
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.4
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.31.0.6
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.6
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.4
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.15.0.6
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.37
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Uu5nFG3wCl0LACBb;

1.36
date	2012.01.28.13.47.55;	author sthen;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.07.16.20.58;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.20.15.19.25;	author sthen;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.12.16.07.41;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.18.16.18.49;	author hshoexer;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.24.12.13.16;	author hshoexer;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.28.18.37.55;	author cloder;	state Exp;
branches;
next	1.27;

1.27
date	2005.06.28.09.28.28;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.07.09.50.48;	author hshoexer;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2004.07.29.10.29.44;	author ho;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2004.06.22.03.23.33;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.20.17.51.55;	author avsm;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.13.17.56.54;	author hshoexer;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.06.08.57.20;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.12.10.10.42;	author hshoexer;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.14.11.36.55;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.14.11.33.45;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.15.22.59.42;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.18.09.14.18;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.23.04.10.14;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.11.16.14.52;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.11.18.15.48;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.11.18.12.11;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.11.17.05.13;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.12.18.04.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.26.14.14.49;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.18.09.14.14;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.10.16.10.21;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.09.21.44.40;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.03.14.25.47;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	99.09.30.07.22.55;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	99.09.16.17.08.01;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	;

1.25.2.1
date	2005.09.04.19.06.37;	author brad;	state Exp;
branches;
next	;

1.26.2.1
date	2005.09.04.18.47.41;	author brad;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: print-ike.c,v 1.36 2012/01/28 13:47:55 sthen Exp $	*/

/*
 * Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999
 *	The Regents of the University of California.  All rights reserved.
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Format and print ike (isakmp) packets.
 *	By Tero Kivinen <kivinen@@ssh.fi>, Tero Mononen <tmo@@ssh.fi>,
 *         Tatu Ylonen <ylo@@ssh.fi> and Timo J. Rinne <tri@@ssh.fi>
 *         in co-operation with SSH Communications Security, Espoo, Finland
 */

#include <sys/time.h>
#include <sys/socket.h>

struct mbuf;
struct rtentry;
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#include "interface.h"
#include "addrtoname.h"
#include "ike.h"

struct isakmp_header {
	u_int8_t	init_cookie[8];
	u_int8_t	resp_cookie[8];
	u_int8_t	next_payload;
	u_int8_t	version;
	u_int8_t	exgtype;
	u_int8_t	flags;
	u_int8_t	msgid[4];
	u_int32_t	length;
	u_int8_t	payloads[0];
};

struct sa_payload {
	u_int8_t	next_payload;
	u_int8_t	reserved;
	u_int16_t	payload_length;
	u_int32_t	doi;
	u_int8_t	situation[0];
};

struct proposal_payload {
	u_int8_t	next_payload;
	u_int8_t	reserved;
	u_int16_t	payload_length;
	u_int8_t	nprop;
	u_int8_t	proto;
	u_int8_t	spi_size;
	u_int8_t	nspis;
	u_int8_t	spi[0];
};

struct transform_payload {
	u_int8_t	next_payload;
	u_int8_t	reserved;
	u_int16_t	payload_length;
	u_int8_t	ntrans;
	u_int8_t	transform;
	u_int16_t	reserved2;
	u_int8_t	attribute[0];
};

struct ke_payload {
	u_int8_t	next_payload;
	u_int8_t	reserved;
	u_int16_t	payload_length;
	u_int8_t	data[0];
};

struct id_payload {
	u_int8_t	next_payload;
	u_int8_t	reserved;
	u_int16_t	payload_length;
	u_int8_t	type;
	u_int8_t	id_data[3];
	u_int8_t	data[0];
};

struct notification_payload {
	u_int8_t	next_payload;
	u_int8_t	reserved;
	u_int16_t	payload_length;
	u_int32_t	doi;
	u_int8_t	protocol_id;
  	u_int8_t	spi_size;
  	u_int16_t	type;
	u_int8_t	data[0];
};

struct delete_payload {
	u_int8_t	next_payload;
	u_int8_t	reserved;
	u_int16_t	payload_length;
	u_int32_t	doi;
	u_int8_t	proto;
	u_int8_t	spi_size;
	u_int16_t	nspis;
	u_int8_t	spi[0];
};

struct vendor_payload {
	u_int8_t	next_payload;
	u_int8_t	reserved;
	u_int16_t	payload_length;
	u_int8_t	vid[0];
};

struct attribute_payload {
	u_int8_t	next_payload;
	u_int8_t	reserved;
	u_int16_t	payload_length;
	u_int8_t	type;
	u_int8_t	reserved2;
	u_int16_t	id;
};

static void ike_pl_print(u_int8_t, u_int8_t *, u_int8_t);

int ike_tab_level = 0;
u_int8_t xform_proto;

static const char *ike[] = IKE_PROTO_INITIALIZER;

#define SMALL_TABS 4
#define SPACES "                                                   "
const char *
ike_tab_offset(void)
{
	const char *p, *endline;
	static const char line[] = SPACES;

	endline = line + sizeof line - 1;
	p = endline - SMALL_TABS * (ike_tab_level);

	return (p > line ? p : line);
}

static char *
ike_get_cookie (u_int8_t *ic, u_int8_t *rc)
{
	static char cookie_jar[35];
	int i;

	for (i = 0; i < 8; i++)
		snprintf(cookie_jar + i*2, sizeof(cookie_jar) - i*2,
		    "%02x", *(ic + i));
	strlcat(cookie_jar, "->", sizeof(cookie_jar));
	for (i = 0; i < 8; i++)
		snprintf(cookie_jar + 18 + i*2, sizeof(cookie_jar) - 18 - i*2,
		    "%02x", *(rc + i));
	return cookie_jar;
}

/*
 * Print isakmp requests
 */
void
ike_print (const u_int8_t *cp, u_int length)
{
	struct isakmp_header *ih;
	const u_int8_t *ep;
	u_int8_t *payload, next_payload;
	int encrypted;
	static const char *exgtypes[] = IKE_EXCHANGE_TYPES_INITIALIZER;

	encrypted = 0;

#ifdef TCHECK
#undef TCHECK
#endif
#define TCHECK(var, l) if ((u_int8_t *)&(var) > ep - l) goto trunc

	ih = (struct isakmp_header *)cp;

	if (length < sizeof (struct isakmp_header))
		goto trunc;

	/* 'ep' points to the end of avaible data. */
	ep = snapend;

	printf(" isakmp");

	printf(" v%d.%d", ih->version >> 4, ih->version & 0xf);

	printf(" exchange ");
	if (ih->exgtype < (sizeof exgtypes/sizeof exgtypes[0]))
		printf("%s", exgtypes[ih->exgtype]);
	else
		printf("%d (unknown)", ih->exgtype);

	if (ih->flags & FLAGS_ENCRYPTION) {
		printf(" encrypted");
		encrypted = 1;
	}

	if (ih->flags & FLAGS_COMMIT) {
		printf(" commit");
	}

	printf("\n\tcookie: %s", ike_get_cookie (ih->init_cookie,
						 ih->resp_cookie));

	TCHECK(ih->msgid, sizeof(ih->msgid));
	printf(" msgid: %02x%02x%02x%02x", ih->msgid[0], ih->msgid[1],
	    ih->msgid[2], ih->msgid[3]);

	TCHECK(ih->length, sizeof(ih->length));
	printf(" len: %d", ntohl(ih->length));

	if (ih->version > IKE_VERSION_2) {
		printf(" new version");
		return;
	}

	payload = ih->payloads;
	next_payload = ih->next_payload;

	/* if encrypted, then open special file for encryption keys */
	if (encrypted) {
		/* decrypt XXX */
		return;
	}

	/* if verbose, print payload data */
	if (vflag)
		ike_pl_print(next_payload, payload, ISAKMP_DOI);

	return;

trunc:
	fputs(" [|isakmp]", stdout);
}

void
ike_pl_sa_print (u_int8_t *buf, int len)
{
	struct sa_payload *sp = (struct sa_payload *)buf;
	u_int32_t sit_ipsec, doi;

	if (len < sizeof(struct sa_payload)) {
		printf(" [|payload]");
		return;
	}

	doi = ntohl(sp->doi);
	printf(" DOI: %d", doi);

	if (doi == IPSEC_DOI) {
		if ((sp->situation + sizeof(u_int32_t)) > (buf + len)) {
			printf(" [|payload]");
			return;
		}
		printf("(IPSEC) situation: ");
		sit_ipsec = ntohl(*(u_int32_t *)sp->situation);
		if (sit_ipsec & IKE_SITUATION_IDENTITY_ONLY)
			printf("IDENTITY_ONLY ");
		if (sit_ipsec & IKE_SITUATION_SECRECY)
			printf("SECRECY ");
		if (sit_ipsec & IKE_SITUATION_INTEGRITY)
			printf("INTEGRITY ");
		if ((sit_ipsec & IKE_SITUATION_MASK) == 0)
			printf("0x%x (unknown)", sit_ipsec);
		ike_pl_print (PAYLOAD_PROPOSAL, buf +
		    sizeof(struct sa_payload) + sizeof(u_int32_t), IPSEC_DOI);
	} else
		printf(" situation: (unknown)");
}

int
ike_attribute_print (u_int8_t *buf, u_int8_t doi, int maxlen)
{
	static char *attrs[] = IKE_ATTR_INITIALIZER;
	static char *attr_enc[] = IKE_ATTR_ENCRYPT_INITIALIZER;
	static char *attr_hash[] = IKE_ATTR_HASH_INITIALIZER;
	static char *attr_auth[] = IKE_ATTR_AUTH_INITIALIZER;
	static char *attr_gdesc[] = IKE_ATTR_GROUP_DESC_INITIALIZER;
	static char *attr_gtype[] = IKE_ATTR_GROUP_INITIALIZER;
	static char *attr_ltype[] = IKE_ATTR_SA_DURATION_INITIALIZER;
	static char *ipsec_attrs[] = IPSEC_ATTR_INITIALIZER;
	static char *ipsec_attr_auth[] = IPSEC_ATTR_AUTH_INITIALIZER;
	static char *ipsec_attr_ltype[] = IPSEC_ATTR_DURATION_INITIALIZER;

	u_int8_t af   = buf[0] >> 7;
	u_int16_t type = (buf[0] & 0x7f) << 8 | buf[1];
	u_int16_t len  = buf[2] << 8 | buf[3], val;

	if (doi == ISAKMP_DOI)
		printf("\n\t%sattribute %s = ", ike_tab_offset(),
		    (type < sizeof attrs / sizeof attrs[0] ?
		    attrs[type] : "<unknown>"));
	else
		printf("\n\t%sattribute %s = ", ike_tab_offset(),
		    (type < (sizeof ipsec_attrs / sizeof ipsec_attrs[0]) ?
		    ipsec_attrs[type] : "<unknown>"));

	if ((af == 1 && maxlen < 4) || (af == 0 && maxlen < (len + 4))) {
		printf("\n\t%s[|attr]", ike_tab_offset());
		return maxlen;
	}

	if (af == 0) {
		/* AF=0; print the variable length attribute value */
		for (val = 0; val < len; val++)
			printf("%02x", *(buf + 4 + val));
		return len + 4;
	}

	val = len;	/* For AF=1, this field is the "VALUE" */
	len = 4; 	/* and with AF=1, length is always 4 */

#define CASE_PRINT(TYPE, var) \
	case TYPE : \
		if (val < sizeof var / sizeof var [0]) \
			printf("%s", var [val]); \
		else \
			printf("%d (unknown)", val); \
		break;

	if (doi == ISAKMP_DOI)
		switch(type) {
			CASE_PRINT(IKE_ATTR_ENCRYPTION_ALGORITHM, attr_enc);
			CASE_PRINT(IKE_ATTR_HASH_ALGORITHM, attr_hash);
			CASE_PRINT(IKE_ATTR_AUTHENTICATION_METHOD, attr_auth);
			CASE_PRINT(IKE_ATTR_GROUP_DESC, attr_gdesc);
			CASE_PRINT(IKE_ATTR_GROUP_TYPE, attr_gtype);
			CASE_PRINT(IKE_ATTR_LIFE_TYPE, attr_ltype);
		default:
			printf("%d", val);
		}
	else
		switch(type) {
			CASE_PRINT(IPSEC_ATTR_SA_LIFE_TYPE, ipsec_attr_ltype);
			CASE_PRINT(IPSEC_ATTR_AUTHENTICATION_ALGORITHM,
			    ipsec_attr_auth);
			case IPSEC_ATTR_ENCAPSULATION_MODE:
				printf("%s", tok2str(ipsec_attr_encap,
				    "%d", val));
				break;
		default:
			printf("%d", val);
		}

#undef CASE_PRINT
	return len;
}

void
ike_pl_transform_print (u_int8_t *buf, int len, u_int8_t doi)
{
	struct transform_payload *tp = (struct transform_payload *)buf;
	const char *ah[] = IPSEC_AH_INITIALIZER;
	const char *esp[] = IPSEC_ESP_INITIALIZER;
	const char *ipcomp[] = IPCOMP_INITIALIZER;
	u_int8_t *attr = tp->attribute;

	if (len < sizeof(struct transform_payload)) {
		printf(" [|payload]");
		return;
	}

	printf("\n\t%stransform: %u ID: ", ike_tab_offset(), tp->ntrans);

	switch (doi) {
	case ISAKMP_DOI:
		if (tp->transform < (sizeof ike / sizeof ike[0]))
			printf("%s", ike[tp->transform]);
		else
			printf("%d(unknown)", tp->transform);
		break;

	default: /* IPSEC_DOI */
		switch (xform_proto) { /* from ike_proposal_print */
		case PROTO_IPSEC_AH:
			if (tp->transform < (sizeof ah / sizeof ah[0]))
				printf("%s", ah[tp->transform]);
			else
				printf("%d(unknown)", tp->transform);
			break;
		case PROTO_IPSEC_ESP:
			if (tp->transform < (sizeof esp / sizeof esp[0]))
				printf("%s", esp[tp->transform]);
			else
				printf("%d(unknown)", tp->transform);
			break;
		case PROTO_IPCOMP:
			if (tp->transform < (sizeof ipcomp / sizeof ipcomp[0]))
				printf("%s", ipcomp[tp->transform]);
			else
				printf("%d(unknown)", tp->transform);
			break;
		default:
			printf("%d(unknown)", tp->transform);
		}
		break;
	}

	ike_tab_level++;
	while ((int)(attr - buf) < len) /* Skip last 'NONE' attr */
		attr += ike_attribute_print(attr, doi, len - (attr - buf));
	ike_tab_level--;
}

void
ike_pl_proposal_print (u_int8_t *buf, int len, u_int8_t doi)
{
	struct proposal_payload *pp = (struct proposal_payload *)buf;
	int i;

	if (len < sizeof(struct proposal_payload)) {
		printf(" [|payload]");
		return;
	}

	printf(" proposal: %d proto: %s spisz: %d xforms: %d",
	    pp->nprop, (pp->proto < (sizeof ike / sizeof ike[0]) ?
	    ike[pp->proto] : "(unknown)"), pp->spi_size, pp->nspis);

	xform_proto = pp->proto;

	if (pp->spi_size) {
		if ((pp->spi + pp->spi_size) > (buf + len)) {
			printf(" [|payload]");
			return;
		}
		if (pp->proto == PROTO_IPCOMP)
			printf(" CPI: 0x");
		else
			printf(" SPI: 0x");
		for (i = 0; i < pp->spi_size; i++)
			printf("%02x", pp->spi[i]);
	}

	/* Reset to sane value. */
	if (pp->proto == PROTO_ISAKMP)
		doi = ISAKMP_DOI;
	else
		doi = IPSEC_DOI;

	if (pp->nspis > 0)
		ike_pl_print(PAYLOAD_TRANSFORM, pp->spi + pp->spi_size, doi);
}

void
ike_pl_ke_print (u_int8_t *buf, int len, u_int8_t doi)
{
	if (len < sizeof(struct ke_payload)) {
		printf(" [|payload]");
		return;
	}

	if (doi != IPSEC_DOI)
		return;

	/* XXX ... */
}

void
ipsec_id_print (u_int8_t *buf, int len, u_int8_t doi)
{
	struct id_payload *ip = (struct id_payload *)buf;
	static const char *idtypes[] = IPSEC_ID_TYPE_INITIALIZER;
	char ntop_buf[INET6_ADDRSTRLEN];
	struct in_addr in;
	u_int8_t *p;

	if (len < sizeof (struct id_payload)) {
		printf(" [|payload]");
		return;
	}

	if (doi != ISAKMP_DOI)
		return;

	/* Don't print proto+port unless actually used */
	if (ip->id_data[0] | ip->id_data[1] | ip->id_data[2])
		printf(" proto: %d port: %d", ip->id_data[0],
		    (ip->id_data[1] << 8) + ip->id_data[2]);

	printf(" type: %s = ", ip->type < (sizeof idtypes/sizeof idtypes[0]) ?
	    idtypes[ip->type] : "<unknown>");

	switch (ip->type) {
	case IPSEC_ID_IPV4_ADDR:
		if ((ip->data + sizeof in) > (buf + len)) {
			printf(" [|payload]");
			return;
		}
		memcpy (&in.s_addr, ip->data, sizeof in);
		printf("%s", inet_ntoa (in));
		break;

	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV4_ADDR_RANGE:
		if ((ip->data + 2 * (sizeof in)) > (buf + len)) {
			printf(" [|payload]");
			return;
		}
		memcpy (&in.s_addr, ip->data, sizeof in);
		printf("%s%s", inet_ntoa (in),
		    ip->type == IPSEC_ID_IPV4_ADDR_SUBNET ? "/" : "-");
		memcpy (&in.s_addr, ip->data + sizeof in, sizeof in);
		printf("%s", inet_ntoa (in));
		break;

	case IPSEC_ID_IPV6_ADDR:
		if ((ip->data + sizeof ntop_buf) > (buf + len)) {
			printf(" [|payload]");
			return;
		}
		printf("%s", inet_ntop (AF_INET6, ip->data, ntop_buf,
		    sizeof ntop_buf));
		break;

	case IPSEC_ID_IPV6_ADDR_SUBNET:
	case IPSEC_ID_IPV6_ADDR_RANGE:
		if ((ip->data + 2 * sizeof ntop_buf) > (buf + len)) {
			printf(" [|payload]");
			return;
		}
		printf("%s%s", inet_ntop (AF_INET6, ip->data, ntop_buf,
		    sizeof ntop_buf),
		    ip->type == IPSEC_ID_IPV6_ADDR_SUBNET ? "/" : "-");
		printf("%s", inet_ntop (AF_INET6, ip->data + sizeof ntop_buf,
		    ntop_buf, sizeof ntop_buf));
		break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
		printf("\"");
		for (p = ip->data; (int)(p - buf) < len; p++)
			printf("%c",(isprint(*p) ? *p : '.'));
		printf("\"");
		break;

	case IPSEC_ID_DER_ASN1_DN:
	case IPSEC_ID_DER_ASN1_GN:
	case IPSEC_ID_KEY_ID:
	default:
		printf("\"(not shown)\"");
		break;
	}
}

void
ike_pl_delete_print (u_int8_t *buf, int len)
{
  	struct delete_payload *dp = (struct delete_payload *)buf;
	u_int32_t doi;
	u_int16_t s, nspis;
	u_int8_t *data;

	if (len < sizeof (struct delete_payload)) {
		printf(" [|payload]");
		return;
	}

	doi   = ntohl(dp->doi);
	nspis = ntohs(dp->nspis);

	if (doi != ISAKMP_DOI && doi != IPSEC_DOI) {
		printf(" (unknown DOI)");
		return;
	}

	printf(" DOI: %u(%s) proto: %s nspis: %u", doi,
	    doi == ISAKMP_DOI ? "ISAKMP" : "IPSEC",
	    dp->proto < (sizeof ike / sizeof ike[0]) ? ike[dp->proto] :
	    "(unknown)", nspis);

	if ((dp->spi + nspis * dp->spi_size) > (buf + len)) {
		printf(" [|payload]");
		return;
	}

	for (s = 0; s < nspis; s++) {
		data = dp->spi + s * dp->spi_size;
		if (dp->spi_size == 16)
			printf("\n\t%scookie: %s", ike_tab_offset(),
			    ike_get_cookie(&data[0], &data[8]));
		else
			printf("\n\t%sSPI: 0x%08x", ike_tab_offset(),
			    data[0]<<24 | data[1]<<16 | data[2]<<8 | data[3]);
	}
}

void
ike_pl_notification_print (u_int8_t *buf, int len)
{
  	static const char *nftypes[] = IKE_NOTIFY_TYPES_INITIALIZER;
  	struct notification_payload *np = (struct notification_payload *)buf;
	u_int32_t *replay, *seq;
	u_int32_t doi;
	u_int16_t type;
	u_int8_t *attr;

	if (len < sizeof (struct notification_payload)) {
		printf(" [|payload]");
		return;
	}

	doi  = ntohl (np->doi);
	type = ntohs (np->type);

	if (doi != ISAKMP_DOI && doi != IPSEC_DOI) {
		printf(" (unknown DOI)");
		return;
	}

	printf("\n\t%snotification: ", ike_tab_offset());

	if (type > 0 && type < (sizeof nftypes / sizeof nftypes[0])) {
		printf("%s", nftypes[type]);
		return;
	}
	switch (type) {

	case NOTIFY_IPSEC_RESPONDER_LIFETIME:
		printf("RESPONDER LIFETIME ");
		if (np->spi_size == 16)
			printf("(%s)", ike_get_cookie (&np->data[0],
			    &np->data[8]));
		else
			printf("SPI: 0x%08x", np->data[0]<<24 |
			    np->data[1]<<16 | np->data[2]<<8 | np->data[3]);
		attr = &np->data[np->spi_size];
		ike_tab_level++;
		while ((int)(attr - buf) < len - 4)  /* Skip last 'NONE' attr */
			attr += ike_attribute_print(attr, IPSEC_DOI,
			    len - (attr-buf));
		ike_tab_level--;
		break;

	case NOTIFY_IPSEC_REPLAY_STATUS:
		replay = (u_int32_t *)&np->data[np->spi_size];
		printf("REPLAY STATUS [%sabled] ", *replay ? "en" : "dis");
		if (np->spi_size == 16)
			printf("(%s)", ike_get_cookie (&np->data[0],
			    &np->data[8]));
		else
			printf("SPI: 0x%08x", np->data[0]<<24 |
			    np->data[1]<<16 | np->data[2]<<8 | np->data[3]);
		break;

	case NOTIFY_IPSEC_INITIAL_CONTACT:
		printf("INITIAL CONTACT (%s)", ike_get_cookie (&np->data[0],
		    &np->data[8]));
		break;

	case NOTIFY_STATUS_DPD_R_U_THERE:
	case NOTIFY_STATUS_DPD_R_U_THERE_ACK:
		printf("STATUS_DPD_R_U_THERE%s ",
		    type == NOTIFY_STATUS_DPD_R_U_THERE ? "" : "_ACK");
		if (np->spi_size != 16 ||
		    len < sizeof(struct notification_payload) +
		    sizeof(u_int32_t))
			printf("[bad notify]");
		else {
			seq = (u_int32_t *)&np->data[np->spi_size];
			printf("seq %u", ntohl(*seq));
		}
		break;
		

	default:
	  	printf("%d (unknown)", type);
		break;
	}
}

void
ike_pl_vendor_print (u_int8_t *buf, int len, u_int8_t doi)
{
	struct vendor_payload *vp = (struct vendor_payload *)buf;
	u_int8_t *p;
	int i;

	if (len < sizeof(struct vendor_payload)) {
		printf(" [|payload]");
		return;
	}

	for (i = 0; i < sizeof vendor_ids / sizeof vendor_ids[0]; i ++)
		if (memcmp(vp->vid, vendor_ids[i].vid,
		    vendor_ids[i].len) == 0) {
			printf (" (supports %s)", vendor_ids[i].name);
			return;
		}

	if (doi != IPSEC_DOI)
		return;

	printf(" \"");
	for (p = vp->vid; (int)(p - buf) < len; p++)
		printf("%c", (isprint(*p) ? *p : '.'));
	printf("\"");
}

/* IKE mode-config. */
int
ike_cfg_attribute_print (u_int8_t *buf, int attr_type, int maxlen)
{
	static char *attrs[] = IKE_CFG_ATTRIBUTE_INITIALIZER;
	char ntop_buf[INET6_ADDRSTRLEN];
	struct in_addr in;

	u_int8_t af = buf[0] >> 7;
	u_int16_t type = (buf[0] & 0x7f) << 8 | buf[1];
	u_int16_t len = af ? 2 : buf[2] << 8 | buf[3], p;
	u_int8_t *val = af ? buf + 2 : buf + 4;

	printf("\n\t%sattribute %s = ", ike_tab_offset(),
	    type < (sizeof attrs / sizeof attrs[0]) ? attrs[type] :
	    "<unknown>");

	if ((af == 1 && maxlen < 4) ||
	    (af == 0 && maxlen < (len + 4))) {
		printf("\n\t%s[|attr]", ike_tab_offset());
		return maxlen;
	}

	/* XXX The 2nd term is for bug compatibility with PGPnet.  */
	if (len == 0 || (af && !val[0] && !val[1])) {
		printf("<none>");
		return 4;
	}

	/* XXX Generally lengths are not checked well below.  */
	switch (type) {
	case IKE_CFG_ATTR_INTERNAL_IP4_ADDRESS:
	case IKE_CFG_ATTR_INTERNAL_IP4_NETMASK:
	case IKE_CFG_ATTR_INTERNAL_IP4_DNS:
	case IKE_CFG_ATTR_INTERNAL_IP4_NBNS:
	case IKE_CFG_ATTR_INTERNAL_IP4_DHCP:
		memcpy (&in.s_addr, val, sizeof in);
		printf("%s", inet_ntoa (in));
		break;

	case IKE_CFG_ATTR_INTERNAL_IP6_ADDRESS:
	case IKE_CFG_ATTR_INTERNAL_IP6_NETMASK:
	case IKE_CFG_ATTR_INTERNAL_IP6_DNS:
	case IKE_CFG_ATTR_INTERNAL_IP6_NBNS:
	case IKE_CFG_ATTR_INTERNAL_IP6_DHCP:
		printf("%s", inet_ntop (AF_INET6, val, ntop_buf,
		    sizeof ntop_buf));
		break;

	case IKE_CFG_ATTR_INTERNAL_IP4_SUBNET:
		memcpy(&in.s_addr, val, sizeof in);
		printf("%s/", inet_ntoa (in));
		memcpy(&in.s_addr, val + sizeof in, sizeof in);
		printf("%s", inet_ntoa (in));
		break;

	case IKE_CFG_ATTR_INTERNAL_IP6_SUBNET:
		printf("%s/%u", inet_ntop (AF_INET6, val, ntop_buf,
		    sizeof ntop_buf), val[16]);
		break;

	case IKE_CFG_ATTR_INTERNAL_ADDRESS_EXPIRY:
		printf("%u seconds",
		    val[0] << 24 | val[1] << 16 | val[2] << 8 | val[3]);
		break;

	case IKE_CFG_ATTR_APPLICATION_VERSION:
		for (p = 0; p < len; p++)
			printf("%c", isprint(val[p]) ? val[p] : '.');
		break;

	case IKE_CFG_ATTR_SUPPORTED_ATTRIBUTES:
		printf("<%d attributes>", len / 2);
		ike_tab_level++;
		for (p = 0; p < len; p += 2) {
			type = (val[p] << 8 | val[p + 1]) & 0x7fff;
			printf("\n\t%s%s", ike_tab_offset(),
			    type < (sizeof attrs/sizeof attrs[0]) ?
			    attrs[type] : "<unknown>");
		}
		ike_tab_level--;
		break;

	default:
		break;
	}
	return af ? 4 : len + 4;
}

void
ike_pl_attribute_print (u_int8_t *buf, int len)
{
	struct attribute_payload *ap = (struct attribute_payload *)buf;
	static const char *pl_attr[] = IKE_CFG_ATTRIBUTE_TYPE_INITIALIZER;
	u_int8_t *attr = buf + sizeof(struct attribute_payload);

	if (len < sizeof(struct attribute_payload)) {
		printf(" [|payload]");
		return;
	}

	printf(" type: %s Id: %d",
	    ap->type < (sizeof pl_attr/sizeof pl_attr[0]) ? pl_attr[ap->type] :
	    "<unknown>", ap->id);

	while ((int)(attr - buf) < len)
		attr += ike_cfg_attribute_print(attr, ap->type,
		    len - (attr - buf));
}

void
ike_pl_print (u_int8_t type, u_int8_t *buf, u_int8_t doi)
{
	static const char *pltypes[] = IKE_PAYLOAD_TYPES_INITIALIZER;
	static const char *plprivtypes[] = 
	    IKE_PRIVATE_PAYLOAD_TYPES_INITIALIZER;
	static const char *plv2types[] = IKEV2_PAYLOAD_TYPES_INITIALIZER;
	u_int8_t next_type;
	u_int16_t this_len;

	if (&buf[4] > snapend) {
		goto pltrunc;
	}

	next_type = buf[0];
	this_len = buf[2]<<8 | buf[3];

	if (type < PAYLOAD_PRIVATE_MIN && type >= PAYLOAD_IKEV2_SA)
		printf("\n\t%spayload: %s len: %hu", ike_tab_offset(),
		    plv2types[type - PAYLOAD_IKEV2_SA], this_len);
	else if (type < PAYLOAD_PRIVATE_MIN || type >= PAYLOAD_PRIVATE_MAX)
		printf("\n\t%spayload: %s len: %hu", ike_tab_offset(),
		    (type < (sizeof pltypes/sizeof pltypes[0]) ?
			pltypes[type] : "<unknown>"), this_len);
	else
		printf("\n\t%spayload: %s len: %hu", ike_tab_offset(),
		    plprivtypes[type - PAYLOAD_PRIVATE_MIN], this_len);

	if ((type < PAYLOAD_RESERVED_MIN &&
	    (type < sizeof(min_payload_lengths)/sizeof(min_payload_lengths[0]) &&
	    this_len < min_payload_lengths[type])) ||
	    this_len == 0)
		goto pltrunc;

	if ((type > PAYLOAD_PRIVATE_MIN && type < PAYLOAD_PRIVATE_MAX &&
	    this_len < min_priv_payload_lengths[type - PAYLOAD_PRIVATE_MIN]) ||
	    this_len == 0)
		goto pltrunc;
	    
	if (buf + this_len > snapend)
		goto pltrunc;

	ike_tab_level++;
	switch (type) {
	case PAYLOAD_NONE:
		return;

	case PAYLOAD_SA:
		ike_pl_sa_print(buf, this_len);
		break;

	case PAYLOAD_PROPOSAL:
		ike_pl_proposal_print(buf, this_len, doi);
		break;

	case PAYLOAD_TRANSFORM:
		ike_pl_transform_print(buf, this_len, doi);
		break;

	case PAYLOAD_KE:
		ike_pl_ke_print(buf, this_len, doi);
		break;

	case PAYLOAD_ID:
		/* Should only happen with IPsec DOI */
		ipsec_id_print(buf, this_len, doi);
		break;

	case PAYLOAD_CERT:
	case PAYLOAD_CERTREQUEST:
	case PAYLOAD_HASH:
	case PAYLOAD_SIG:
	case PAYLOAD_NONCE:
		break;

	case PAYLOAD_DELETE:
		ike_pl_delete_print(buf, this_len);
		break;

	case PAYLOAD_NOTIFICATION:
	  	ike_pl_notification_print(buf, this_len);
		break;

	case PAYLOAD_VENDOR:
		ike_pl_vendor_print(buf, this_len, doi);
		break;

	case PAYLOAD_ATTRIBUTE:
		ike_pl_attribute_print(buf, this_len);
		break;

	case PAYLOAD_SAK:
	case PAYLOAD_SAT:
	case PAYLOAD_KD:
	case PAYLOAD_SEQ:
	case PAYLOAD_POP:
	case PAYLOAD_NAT_D:
		break;

	case PAYLOAD_NAT_OA:
		/* RFC3947 NAT-OA uses a subset of the ID payload */
		ipsec_id_print(buf, this_len, doi);
		break;

	case PAYLOAD_NAT_D_DRAFT:
		break;

	case PAYLOAD_NAT_OA_DRAFT:
		ipsec_id_print(buf, this_len, doi);
		break;

	default:
		break;
	}
	ike_tab_level--;

	if (next_type)  /* Recurse over next payload */
		ike_pl_print(next_type, buf + this_len, doi);

	return;

pltrunc:
	if (doi == ISAKMP_DOI)
		fputs(" [|isakmp]", stdout);
	else
		fputs(" [|ipsec]", stdout);
}
@


1.36
log
@Print names rather than numbers for the old draft nat-t attributes,
cisco use these at least as recently as ASAs running 8.4(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.35 2010/06/07 16:20:58 jsg Exp $	*/
a29 1
#include <sys/param.h>
@


1.35
log
@minimal decode support for IKEv2 exchange types and payloads.

ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.34 2010/01/20 15:19:25 sthen Exp $	*/
a305 1
	static char *ipsec_attr_encap[] = IPSEC_ATTR_ENCAP_INITIALIZER;
a358 2
			CASE_PRINT(IPSEC_ATTR_ENCAPSULATION_MODE,
			    ipsec_attr_encap);
d361 4
@


1.34
log
@Print RFC3947 NAT Original Address (NAT-OA) payloads, they're a subset
of the id payload, so using the existing id printer. ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.33 2009/11/12 16:07:41 deraadt Exp $	*/
d236 1
a236 1
	if (ih->version > 16) {
d839 1
d850 4
a853 1
	if (type < PAYLOAD_PRIVATE_MIN || type >= PAYLOAD_PRIVATE_MAX)
@


1.33
log
@for packets with unknown payloads (outside the range of our knowledge) simply
treat them the same as truncated packets
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.32 2009/10/27 23:59:55 deraadt Exp $	*/
d926 2
d929 4
d934 2
d937 1
@


1.32
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.31 2008/12/18 16:18:49 hshoexer Exp $	*/
d858 3
a860 1
	    this_len < min_payload_lengths[type]) || this_len == 0)
@


1.31
log
@Instead of directly applying ntoh*() to fields of the captured
packet and thus modifying it use local varialbes instead.  Otherwise,
hexdumping packets shows corrupted data.

ok markus@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.30 2007/10/07 16:41:05 deraadt Exp $	*/
a28 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id: print-ike.c,v 1.30 2007/10/07 16:41:05 deraadt Exp $ (XXX)";
#endif
@


1.30
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.29 2006/08/24 12:13:16 hshoexer Exp $	*/
d32 1
a32 1
    "@@(#) $Id$ (XXX)";
d269 1
a269 1
	u_int32_t sit_ipsec;
d276 2
a277 2
	sp->doi = ntohl(sp->doi);
	printf(" DOI: %d", sp->doi);
d279 1
a279 1
	if (sp->doi == IPSEC_DOI) {
d578 2
a579 1
	u_int16_t s;
d587 2
a588 2
	dp->doi   = ntohl(dp->doi);
	dp->nspis = ntohs(dp->nspis);
d590 1
a590 1
	if (dp->doi != ISAKMP_DOI && dp->doi != IPSEC_DOI) {
d595 2
a596 2
	printf(" DOI: %u(%s) proto: %s nspis: %u", dp->doi,
	    dp->doi == ISAKMP_DOI ? "ISAKMP" : "IPSEC",
d598 1
a598 1
	    "(unknown)", dp->nspis);
d600 1
a600 1
	if ((dp->spi + dp->nspis * dp->spi_size) > (buf + len)) {
d605 1
a605 1
	for (s = 0; s < dp->nspis; s++) {
d622 2
d631 2
a632 2
	np->doi  = ntohl (np->doi);
	np->type = ntohs (np->type);
d634 1
a634 1
	if (np->doi != ISAKMP_DOI && np->doi != IPSEC_DOI) {
d641 2
a642 2
	if (np->type > 0 && np->type < (sizeof nftypes / sizeof nftypes[0])) {
		printf("%s", nftypes[np->type]);
d645 1
a645 1
	switch (np->type) {
d682 1
a682 1
		    np->type == NOTIFY_STATUS_DPD_R_U_THERE ? "" : "_ACK");
d695 1
a695 1
	  	printf("%d (unknown)", np->type);
@


1.29
log
@recognize xauth vendor payload
ok ho markus
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.28 2005/08/28 18:37:55 cloder Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.28 2005/08/28 18:37:55 cloder Exp $ (XXX)";
@


1.28
log
@Fix a reliability issue where an over-read of 4 bytes could result in the
tcpdump process being terminated when tcpdump running with -vv tries to
print a a short IKE SA payload.

Specifically OK'd for 3.8 release by deraadt@@.  OK canacar@@, hshoexer@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.27 2005/06/28 09:28:28 hshoexer Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.27 2005/06/28 09:28:28 hshoexer Exp $ (XXX)";
d711 1
a711 1
		    sizeof vendor_ids[i].vid) == 0) {
@


1.27
log
@some more ike payload types

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.26 2004/10/07 09:50:48 hshoexer Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/openbsd//src/usr.sbin/tcpdump/print-ike.c,v 1.26 2004/10/07 09:50:48 hshoexer Exp $ (XXX)";
d841 9
a849 2
	u_int8_t next_type = buf[0];
	u_int16_t this_len = buf[2]<<8 | buf[3];
d868 1
a868 1
	if ((u_int8_t *)&(buf[0]) > snapend - this_len)
@


1.26
log
@When printing attributes do not cast unsigned value to signed.

ok & help otto
ok deraadt henning markus
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.25 2004/07/29 10:29:44 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.25 2004/07/29 10:29:44 ho Exp $ (XXX)";
d913 5
d920 2
@


1.26.2.1
log
@MFC:
Fix by cloder@@

Fix a reliability issue where an over-read of 4 bytes could result in the
tcpdump process being terminated when tcpdump running with -vv tries to
print a short IKE SA payload.

ok deraadt@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.26 2004/10/07 09:50:48 hshoexer Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.26 2004/10/07 09:50:48 hshoexer Exp $ (XXX)";
d841 2
a842 9
	u_int8_t next_type;
	u_int16_t this_len;

	if (&buf[4] > snapend) {
		goto pltrunc;
	}

	next_type = buf[0];
	this_len = buf[2]<<8 | buf[3];
d861 1
a861 1
	if (buf + this_len > snapend)
@


1.25
log
@Report DPD notifications. Cleanup. markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.24 2004/06/22 03:23:33 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.24 2004/06/22 03:23:33 ho Exp $ (XXX)";
d336 1
a336 1
			printf("%02x", (char)*(buf + 4 + val));
@


1.25.2.1
log
@MFC:
Fix by cloder@@

Fix a reliability issue where an over-read of 4 bytes could result in the
tcpdump process being terminated when tcpdump running with -vv tries to
print a short IKE SA payload.

ok deraadt@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.25 2004/07/29 10:29:44 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.25 2004/07/29 10:29:44 ho Exp $ (XXX)";
d841 2
a842 9
	u_int8_t next_type;
	u_int16_t this_len;

	if (&buf[4] > snapend) {
		goto pltrunc;
	}

	next_type = buf[0];
	this_len = buf[2]<<8 | buf[3];
d861 1
a861 1
	if (buf + this_len > snapend)
@


1.24
log
@In draft-ietf-ipsec-nat-t-ike-01,02,03, NAT-D is payload 130. Rewrite a bit
to understand payloads in the private range. Also match a few "well-known"
vendor-IDs. markus@@ "looks ok".
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.23 2004/06/20 17:51:55 avsm Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.23 2004/06/20 17:51:55 avsm Exp $ (XXX)";
d620 1
a620 1
	u_int32_t *replay;
d645 1
a645 1
		printf("RESPONDER LIFETIME");
d675 15
@


1.23
log
@- do not use __attribute__((volatile)) as its a synonym for __dead nowadays
- bad format string "\%s" -> "%s" in print-ike.c
fixes parsing using CIL, discussed with millert@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.22 2004/04/13 17:56:54 hshoexer Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.22 2004/04/13 17:56:54 hshoexer Exp $ (XXX)";
d687 1
d694 7
d824 2
d829 7
a835 3
	printf("\n\t%spayload: %s len: %hu", ike_tab_offset(),
	    (type < (sizeof pltypes/sizeof pltypes[0]) ?
	    pltypes[type] : "<unknown>"), this_len);
d837 2
a838 2
	if ((type < PAYLOAD_RESERVED_MIN
	    && this_len < min_payload_lengths[type]) || this_len == 0)
d841 5
@


1.22
log
@Cleanup and more careful payload parsing.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.21 2004/04/06 08:57:20 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.21 2004/04/06 08:57:20 ho Exp $ (XXX)";
d715 1
a715 1
	printf("\n\t\%sattribute %s = ", ike_tab_offset(),
@


1.21
log
@Print DELETE payload contents. ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.20 2004/03/12 10:10:42 hshoexer Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.20 2004/03/12 10:10:42 hshoexer Exp $ (XXX)";
d65 45
d132 16
d268 16
a283 4
	u_int32_t situation = ntohl(*(u_int32_t *)(buf + 4));
	u_int8_t ike_doi = ntohl((*(u_int32_t *)buf));
	printf(" DOI: %d", ike_doi);
	if (ike_doi == IPSEC_DOI) {
d285 2
a286 1
		if (situation & IKE_SITUATION_IDENTITY_ONLY)
d288 1
a288 1
		if (situation & IKE_SITUATION_SECRECY)
d290 1
a290 1
		if (situation & IKE_SITUATION_INTEGRITY)
d292 4
a295 3
		if ((situation & IKE_SITUATION_MASK) == 0)
			printf("0x%x (unknown)", situation);
		ike_pl_print (PAYLOAD_PROPOSAL, buf + 8, IPSEC_DOI);
d380 1
d384 6
a389 1
	u_int8_t *attr = buf + 4;
d391 1
a391 1
	printf("\n\t%stransform: %u ID: ", ike_tab_offset(), buf[0]);
d395 2
a396 2
		if (buf[1] < (sizeof ike / sizeof ike[0]))
			printf("%s", ike[buf[1]]);
d398 1
a398 1
			printf("%d(unknown)", buf[1]);
d402 1
a402 1
		switch (xform_proto) {	/* from ike_proposal_print */
d404 2
a405 2
			if (buf[1] < (sizeof ah / sizeof ah[0]))
				printf("%s", ah[buf[1]]);
d407 1
a407 1
				printf("%d(unknown)", buf[1]);
d410 2
a411 2
			if (buf[1] < (sizeof esp / sizeof esp[0]))
				printf("%s", esp[buf[1]]);
d413 1
a413 1
				printf("%d(unknown)", buf[1]);
d416 2
a417 2
			if (buf[1] < (sizeof ipcomp / sizeof ipcomp[0]))
				printf("%s", ipcomp[buf[1]]);
d419 1
a419 1
				printf("%d(unknown)", buf[1]);
d422 1
a422 1
			printf("%d(unknown)", buf[1]);
d428 2
a429 2
	while ((int)(attr - buf) < len - 4)  /* Skip last 'NONE' attr */
		attr += ike_attribute_print(attr, doi, len - (attr-buf));
d436 7
a442 1
	u_int8_t i, p_id = buf[1], spisz = buf[2];
d445 2
a446 2
	    buf[0], (p_id < (sizeof ike / sizeof ike[0]) ? ike[p_id] :
	    "(unknown)"), spisz, buf[3]);
d448 1
a448 2
	/* We need to store this for upcoming ike_attribute_print call. */
	xform_proto = p_id;
d450 6
a455 2
	if (spisz) {
		if (p_id == PROTO_IPCOMP)
d459 2
a460 2
		for (i = 0; i < spisz && (i + 4) < len; i++)
			printf("%02x", buf[i + 4]);
d464 1
a464 1
	if (p_id == PROTO_ISAKMP)
d469 2
a470 2
	if ((char)buf[3] > 0)
		ike_pl_print(PAYLOAD_TRANSFORM, buf + 4 + buf[2], doi);
d476 5
d490 1
d496 5
d505 3
a507 2
	if (buf[1] | buf[2] | buf[3])
		printf(" proto: %d port: %d", buf[1], (buf[2] << 8) + buf[3]);
d509 2
a510 2
	printf(" type: %s = ", buf[0] < (sizeof idtypes/sizeof idtypes[0]) ?
	    idtypes[buf[0]] : "<unknown>");
d512 1
a512 1
	switch (buf[0]) {
d514 5
a518 1
		memcpy (&in.s_addr, buf + 4, sizeof in);
d521 1
d524 5
a528 1
		memcpy (&in.s_addr, buf + 4, sizeof in);
d530 2
a531 2
		    buf[0] == IPSEC_ID_IPV4_ADDR_SUBNET ? "/" : "-");
		memcpy (&in.s_addr, buf + 8, sizeof in);
d536 5
a540 1
		printf("%s", inet_ntop (AF_INET6, buf + 4, ntop_buf,
d543 1
d546 5
a550 1
		printf("%s%s", inet_ntop (AF_INET6, buf + 4, ntop_buf,
d552 2
a553 2
		    buf[0] == IPSEC_ID_IPV6_ADDR_SUBNET ? "/" : "-");
		printf("%s", inet_ntop (AF_INET6, buf + 4 + sizeof ntop_buf,
d555 1
d560 1
a560 1
		for(p = buf + 4; (int)(p - buf) < len - 4; p++)
d685 7
a691 1
	u_int8_t *p = buf;
d697 2
a698 2
	for (p = buf; (int)(p - buf) < len; p++)
		printf("%c",(isprint(*p) ? *p : '.'));
d794 1
d796 1
a796 2
	u_int8_t type, *attr;
	u_int16_t id;
d798 4
a801 3
	type = buf[0];
	id = buf[2]<<8 | buf[3];
	attr = buf + 4;
d804 2
a805 2
	    type < (sizeof pl_attr/sizeof pl_attr[0]) ? pl_attr[type] :
	    "<unknown>", id);
d807 3
a809 2
	while ((int)(attr - buf) < len - 4)
		attr += ike_cfg_attribute_print(attr, type, len - (attr-buf));
d836 1
a836 1
		ike_pl_sa_print(buf+4, this_len);
d840 1
a840 1
		ike_pl_proposal_print(buf+4, this_len, doi);
d844 1
a844 1
		ike_pl_transform_print(buf+4, this_len, doi);
d848 1
a848 1
		ike_pl_ke_print(buf+4, this_len, doi);
d853 1
a853 1
		ipsec_id_print(buf+4, this_len, doi);
d872 1
a872 1
		ike_pl_vendor_print(buf+4, this_len, doi);
d876 1
a876 1
		ike_pl_attribute_print(buf+4, this_len);
@


1.20
log
@Check payload size more carefully when printing ike messages.  Identified by
cloder@@.

ok ho@@ otto@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.19 2004/02/14 11:36:55 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.19 2004/02/14 11:36:55 ho Exp $ (XXX)";
d56 1
a56 1
	u_int8_t	nextpayload;
d76 11
d132 1
a132 1
	u_int8_t *payload, nextpayload;
d186 1
a186 1
	nextpayload = ih->nextpayload;
d196 1
a196 1
		ike_pl_print(nextpayload, payload, ISAKMP_DOI);
d454 41
d503 1
a503 1
		printf(" (|len)");
d732 2
d735 1
@


1.19
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.18 2004/02/14 11:33:45 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.18 2004/02/14 11:33:45 ho Exp $ (XXX)";
d635 2
a636 2
	int next_type = buf[0];
	int this_len = buf[2]<<8 | buf[3];
d638 1
a638 1
	printf("\n\t%spayload: %s len: %d", ike_tab_offset(),
d641 4
@


1.18
log
@Fix DOI select logic, which was broken for IKE vendors that sends non-zero
spi_size in their phase 1 proposals, such as some DLink VPN routers.
Also replace u_char with u_int8_t.  markus@@, hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.17 2004/01/15 22:59:42 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.17 2004/01/15 22:59:42 ho Exp $ (XXX)";
d364 1
a364 1
	  doi = ISAKMP_DOI;
d366 1
a366 1
	  doi = IPSEC_DOI;
@


1.17
log
@Input should be atleast an isakmp_header long. otto@@, markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.16 2003/12/18 09:14:18 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.16 2003/12/18 09:14:18 ho Exp $ (XXX)";
d54 9
a62 9
	u_char  init_cookie[8];
	u_char  resp_cookie[8];
	u_char  nextpayload;
	u_char  version;
	u_char  exgtype;
	u_char  flags;
	u_char  msgid[4];
	u_int32_t length;
	u_char  payloads[0];
d66 8
a73 8
	u_char    next_payload;
	u_char    reserved;
	u_int16_t payload_length;
	u_int32_t doi;
	u_char    protocol_id;
  	u_char    spi_size;
  	u_int16_t type;
	u_char    data[0];
d76 1
a76 1
static void ike_pl_print(u_char, u_char *, u_char);
d79 1
a79 1
u_char xform_proto;
d98 1
a98 1
ike_get_cookie (u_char *ic, u_char *rc)
d117 1
a117 1
ike_print (const u_char *cp, u_int length)
d120 2
a121 3
	const u_char *ep;
	u_char *payload;
	u_char  nextpayload;
d130 1
a130 1
#define TCHECK(var, l) if ((u_char *)&(var) > ep - l) goto trunc
d194 1
a194 1
ike_pl_sa_print (u_char *buf, int len)
d197 1
a197 1
	u_char ike_doi = ntohl((*(u_int32_t *)buf));
d215 1
a215 1
ike_attribute_print (u_char *buf, u_char doi, int maxlen)
d229 1
a229 1
	u_char    af   = buf[0] >> 7;
d292 1
a292 1
ike_pl_transform_print (u_char *buf, int len, u_char doi)
d297 1
a297 1
	u_char *attr = buf + 4;
d342 1
a342 1
ike_pl_proposal_print (u_char *buf, int len, u_char doi)
d360 7
a366 3
		doi = IPSEC_DOI;
	} else
		doi = ISAKMP_DOI;
d373 1
a373 1
ike_pl_ke_print (u_char *buf, int len, u_char doi)
d382 1
a382 1
ipsec_id_print (u_char *buf, int len, u_char doi)
d387 1
a387 1
	u_char *p;
d443 1
a443 1
ike_pl_notification_print (u_char *buf, int len)
d448 1
a448 1
	u_char *attr;
d510 1
a510 1
ike_pl_vendor_print (u_char *buf, int len, u_char doi)
d512 1
a512 1
	u_char *p = buf;
d525 1
a525 1
ike_cfg_attribute_print (u_char *buf, int attr_type, int maxlen)
d531 1
a531 1
	u_char    af   = buf[0] >> 7;
d533 2
a534 2
	u_int16_t len  = af ? 2 : buf[2] << 8 | buf[3], p;
	u_char   *val  = af ? buf + 2 : buf + 4;
d613 1
a613 1
ike_pl_attribute_print (u_char *buf, int len)
d616 1
a616 1
	u_char type, *attr;
d632 1
a632 1
ike_pl_print (u_char type, u_char *buf, u_char doi)
d642 1
a642 1
	if ((u_char *)&(buf[0]) > snapend - this_len)
@


1.16
log
@Recognize NAT-D and NAT-OA payloads. markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.15 2002/09/23 04:10:14 millert Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.15 2002/09/23 04:10:14 millert Exp $ (XXX)";
a133 1
	/* Note funny sized packets */
d135 2
a136 2
	if (length < 20)
		(void)printf(" [len=%d]", length);
@


1.15
log
@Add missing includes, breaks and semicolons to appease gcc3; David Krause
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.14 2002/07/11 16:14:52 stevesk Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.14 2002/07/11 16:14:52 stevesk Exp $ (XXX)";
d687 4
@


1.14
log
@print FQDN strings using correct length; ok ho@@ jakob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.13 2002/06/11 18:15:48 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.13 2002/06/11 18:15:48 ho Exp $ (XXX)";
d690 1
@


1.13
log
@For IPCOMP print CPI instead of SPI. Style.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.12 2002/06/11 18:12:11 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.12 2002/06/11 18:12:11 ho Exp $ (XXX)";
d426 1
a426 1
		for(p = buf + 4; (int)(p - buf) < len; p++)
@


1.12
log
@Don't assume 32bit SPI/CPI numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.11 2002/06/11 17:05:13 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.11 2002/06/11 17:05:13 ho Exp $ (XXX)";
d346 1
a346 1
	u_int8_t i, spisz = buf[2];
d349 1
a349 1
	    buf[0], (buf[1] < (sizeof ike / sizeof ike[0]) ? ike[buf[1]] :
d353 1
a353 1
	xform_proto = buf[1];
d356 4
a359 1
		printf(" SPI: 0x");
d361 1
a361 1
			printf ("%02x", buf[i + 4]);
@


1.11
log
@Decode IPCOMP transform IDs.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.10 2002/02/19 19:39:40 millert Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.10 2002/02/19 19:39:40 millert Exp $ (XXX)";
d346 2
d350 1
a350 1
	    "(unknown)"), buf[2], buf[3]);
d355 4
a358 4
	if (buf[2]) {
		/* XXX it is possible that spisz may be != 4 ... */
		printf(" SPI: 0x%08x",
		    buf[4]<<24 | buf[5]<<16 | buf[6]<<8 | buf[7]);
d364 1
a364 1
		ike_pl_print(PAYLOAD_TRANSFORM, buf+4+buf[2], doi);
@


1.10
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.9 2001/11/12 18:04:08 deraadt Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.9 2001/11/12 18:04:08 deraadt Exp $ (XXX)";
d298 1
d322 6
@


1.9
log
@care and KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.8 2001/10/26 14:14:49 ho Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.8 2001/10/26 14:14:49 ho Exp $ (XXX)";
a38 1
#ifdef __STDC__
a40 2
#endif

@


1.8
log
@(c)-2001.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.7 2001/04/18 09:14:14 niklas Exp $	*/
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.7 2001/04/18 09:14:14 niklas Exp $ (XXX)";
d65 1
a65 1
	u_char  payloads[0];  
d79 1
a79 1
static void ike_pl_print(register u_char, register u_char *, u_char);
d89 1
a89 1
ike_tab_offset (void)
d91 2
a92 2
  const char *p, *endline;
  static const char line[] = SPACES;
d94 2
a95 2
  endline = line + sizeof line - 1;
  p = endline - SMALL_TABS * (ike_tab_level);  
d97 1
a97 1
  return (p > line ? p : line);
d104 1
a104 2
	register int i;
	cookie_jar[0] = cookie_jar[34] = 0;
d107 3
a109 2
		sprintf (cookie_jar + (i<<1), "%02x", *(ic + i));
	strcat (cookie_jar, "->");
d111 2
a112 2
		sprintf (cookie_jar + 18 + (i<<1), "%02x", *(rc + i));

d120 1
a120 1
ike_print (register const u_char *cp, register u_int length)
d123 1
a123 1
	register const u_char *ep;
d135 1
a135 1
	
d138 2
a139 1
	if (length < 20) {
a140 1
	}
d151 1
a151 1
	        printf("%s", exgtypes[ih->exgtype]);
d153 1
a153 1
	        printf("%d (unknown)", ih->exgtype);
d159 1
a159 1
	
d168 2
a169 3
	printf(" msgid: %02x%02x%02x%02x",
	       ih->msgid[0], ih->msgid[1],
	       ih->msgid[2], ih->msgid[3]);
d173 1
a173 1
	
d190 1
a190 1
	        ike_pl_print(nextpayload, payload, ISAKMP_DOI);
d199 1
a199 1
ike_pl_sa_print (register u_char *buf, register int len)
d205 1
a205 1
	        printf("(IPSEC) situation: ");
d207 1
a207 1
		        printf("IDENTITY_ONLY ");
d209 1
a209 1
		        printf("SECRECY ");
d211 1
a211 1
		        printf("INTEGRITY ");
d213 4
a216 5
		        printf("0x%x (unknown)", situation);
	        ike_pl_print (PAYLOAD_PROPOSAL, buf + 8, IPSEC_DOI);
	}
	else
	        printf(" situation: (unknown)");
d220 1
a220 1
ike_attribute_print (register u_char *buf, u_char doi, register int maxlen)
d238 1
a238 1
	if (doi == ISAKMP_DOI) 
d240 2
a241 2
		       (type < sizeof attrs / sizeof attrs[0] ?
			attrs[type] : "<unknown>"));
d244 2
a245 2
		       (type < (sizeof ipsec_attrs / sizeof ipsec_attrs[0]) ?
			ipsec_attrs[type] : "<unknown>"));
d247 2
a248 3
	if ((af == 1 && maxlen < 4) ||
	    (af == 0 && maxlen < (len + 4))) {
		printf ("\n\t%s[|attr]", ike_tab_offset());
d262 7
a268 7
#define CASE_PRINT(TYPE,var) \
        case TYPE : \
               	if (val < sizeof var / sizeof var [0]) \
                       	printf("%s", var [val]); \
               	else \
                       	printf("%d (unknown)", val); \
               	break;
d285 1
a285 1
				   ipsec_attr_encap);
d287 1
a287 1
				   ipsec_attr_auth);
d289 1
a289 1
			printf ("%d", val);
a292 1

d297 1
a297 1
ike_pl_transform_print (register u_char *buf, register int len, u_char doi)
d304 1
a304 1
	
d308 1
a308 1
			printf ("%s", ike[buf[1]]);
d310 1
a310 1
			printf ("%d(unknown)", buf[1]);
d317 1
a317 1
				printf ("%s", ah[buf[1]]);
d319 1
a319 1
				printf ("%d(unknown)", buf[1]);
d323 1
a323 1
				printf ("%s", esp[buf[1]]);
d325 1
a325 1
				printf ("%d(unknown)", buf[1]);
d328 1
a328 1
			printf ("%d(unknown)", buf[1]);
d332 1
a332 1
 
d334 1
a334 1
	while((int)(attr - buf) < len - 4)  /* Skip last 'NONE' attr */
d340 1
a340 1
ike_pl_proposal_print (register u_char *buf, register int len, u_char doi)
d342 3
a344 3
	printf(" proposal: %d proto: %s spisz: %d xforms: %d", 
	       buf[0], (buf[1] < (sizeof ike / sizeof ike[0]) ? ike[buf[1]] : 
			"(unknown)"), buf[2], buf[3]);
d351 2
a352 2
		printf(" SPI: 0x%08x", 
		       buf[4]<<24 | buf[5]<<16 | buf[6]<<8 | buf[7]);
d354 1
a354 1
	} else 
d357 1
a357 1
	if((char)buf[3] > 0)
d362 1
a362 1
ike_pl_ke_print (register u_char *buf, register int len, u_char doi)
d369 1
a369 1
	
d371 1
a371 1
ipsec_id_print (register u_char *buf, register int len, u_char doi)
d378 1
a378 1
	if (doi != ISAKMP_DOI) 
d383 1
a383 1
		printf (" proto: %d port: %d", buf[1], (buf[2] << 8) + buf[3]);
d385 2
a386 2
	printf (" type: %s = ", buf[0] < (sizeof idtypes/sizeof idtypes[0]) ?
		idtypes[buf[0]] : "<unknown>");
d391 1
a391 1
		printf ("%s", inet_ntoa (in));
d396 2
a397 2
		printf ("%s%s", inet_ntoa (in),
			buf[0] == IPSEC_ID_IPV4_ADDR_SUBNET ? "/" : "-");
d399 1
a399 1
		printf ("%s", inet_ntoa (in));
d403 2
a404 2
		printf ("%s", inet_ntop (AF_INET6, buf + 4, ntop_buf,
					 sizeof ntop_buf));
d408 5
a412 5
		printf ("%s%s", inet_ntop (AF_INET6, buf + 4, ntop_buf,
					   sizeof ntop_buf),
			buf[0] == IPSEC_ID_IPV6_ADDR_SUBNET ? "/" : "-");
		printf ("%s", inet_ntop (AF_INET6, buf + 4 + sizeof ntop_buf,
					 ntop_buf, sizeof ntop_buf));
d416 1
a416 1
		printf ("\"");
d418 2
a419 2
			printf ("%c",(isprint(*p) ? *p : '.'));
		printf ("\"");
d426 1
a426 1
		printf ("\"(not shown)\"");
d432 1
a432 1
ike_pl_notification_print (register u_char *buf, register int len)
d440 1
a440 1
		printf (" (|len)");
d448 1
a448 1
		printf (" (unknown DOI)");
d452 1
a452 1
	printf ("\n\t%snotification: ", ike_tab_offset());
d454 1
a454 1
	if (np->type > 0 && np->type < (sizeof nftypes / sizeof nftypes[0]))
d456 3
a458 1
	else switch (np->type) {
d463 2
a464 2
			printf ("(%s)", ike_get_cookie (&np->data[0], 
							&np->data[8]));
d466 2
a467 2
			printf("SPI: 0x%08x", np->data[0]<<24 | 
			       np->data[1]<<16 | np->data[2]<<8 | np->data[3]);
d470 1
a470 1
		while((int)(attr - buf) < len - 4)  /* Skip last 'NONE' attr */
d472 2
a473 2
						    len - (attr-buf));
		ike_tab_level--;	
d480 2
a481 2
			printf ("(%s)", ike_get_cookie (&np->data[0], 
							&np->data[8]));
d483 3
a485 3
			printf("SPI: 0x%08x", np->data[0]<<24 | 
			       np->data[1]<<16 | np->data[2]<<8 | np->data[3]);
		break; 
d489 1
a489 1
							       &np->data[8]));
a495 1
  	return;
d497 1
a497 1
	
d499 1
a499 1
ike_pl_vendor_print (register u_char *buf, register int len, u_char doi)
d503 1
a503 1
	if (doi != IPSEC_DOI) 
d507 2
a508 2
	for(p = buf; (int)(p - buf) < len; p++)
	        printf("%c",(isprint(*p) ? *p : '.'));
d514 1
a514 2
ike_cfg_attribute_print (register u_char *buf, register int attr_type, 
			 register int maxlen)
d526 2
a527 2
	       type < (sizeof attrs / sizeof attrs[0]) ? attrs[type] : 
	       "<unknown>");
d531 1
a531 1
		printf ("\n\t%s[|attr]", ike_tab_offset());
d537 1
a537 1
		printf ("<none>");
d540 1
a540 1
	
d549 1
a549 1
		printf ("%s", inet_ntoa (in));
d551 1
a551 1
		
d557 2
a558 2
		printf ("%s", inet_ntop (AF_INET6, val, ntop_buf,
					 sizeof ntop_buf));
d567 1
a567 1
		
d569 2
a570 3
		printf("%s/%u", inet_ntop (AF_INET6, val, ntop_buf, 
					   sizeof ntop_buf),
		       val[16]);
d572 1
a572 1
		
d575 1
a575 1
		       val[0] << 24 | val[1] << 16 | val[2] << 8 | val[3]);
d582 1
a582 1
		
d589 2
a590 2
			       type < (sizeof attrs/sizeof attrs[0]) ?
			       attrs[type] : "<unknown>");
d594 1
a594 1
		
d602 1
a602 1
ike_pl_attribute_print (register u_char *buf, register int len)
d612 3
a614 3
	printf(" type: %s Id: %d", 
	       type < (sizeof pl_attr/sizeof pl_attr[0]) ? pl_attr[type] :
	       "<unknown>", id);
d616 1
a616 1
	while((int)(attr - buf) < len - 4)  
d621 1
a621 1
ike_pl_print (register u_char type, register u_char *buf, u_char doi)
d628 2
a629 2
	       (type < (sizeof pltypes/sizeof pltypes[0]) ?
		pltypes[type] : "<unknown>"), this_len);
d631 2
a632 2
	if ((u_char *)&(buf[0]) > snapend - this_len) 
	  goto pltrunc;
d635 1
a635 1
	switch(type) {
d642 1
a642 1
	    
d646 1
a646 1
	    
d650 1
a650 1
	    
d654 1
a654 1
	    
d657 1
a657 1
	        ipsec_id_print(buf+4, this_len, doi);
d667 1
a667 1
	    
d673 1
a673 1
	        ike_pl_vendor_print(buf+4, this_len, doi);
d677 1
a677 1
	        ike_pl_attribute_print(buf+4, this_len);
d684 2
a685 2
	if(next_type)  /* Recurse over next payload */
	        ike_pl_print(next_type, buf + this_len, doi);
a693 1

@


1.7
log
@Correct IKE mode config printouts, ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.6 2001/04/10 16:10:21 ho Exp $	*/
d6 1
a27 3
 *
 * Rewritten and extended (quite a lot, too) by Hakan Olsson <ho@@openbsd.org>
 *
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.6 2001/04/10 16:10:21 ho Exp $ (XXX)";
@


1.6
log
@Add IKE mode-config (as described in draft-dukes-ike-mode-cfg-01.txt)
decoding. Also some cleanup of attribute handling plus length checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.5 2001/04/09 21:44:40 ho Exp $	*/
d34 1
a34 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.5 2001/04/09 21:44:40 ho Exp $ (XXX)";
d528 2
a529 1
	u_int16_t len  = buf[2] << 8 | buf[3], p;
d541 2
a542 8
	if (af == 0) {
		for (p = 0; p < len; p++)
			printf ("%02x", (char)*(buf + 4 + p));
		return len + 4;
	}

	/* AF is 1 */
	if (len == 0) {
d547 1
d554 1
a554 1
		memcpy (&in.s_addr, buf + 4, sizeof in);
d563 1
a563 1
		printf ("%s", inet_ntop (AF_INET6, buf + 4, ntop_buf, 
d568 1
a568 1
		memcpy(&in.s_addr, buf + 4, sizeof in);
d570 1
a570 1
		memcpy(&in.s_addr, buf + 8, sizeof in);
d575 1
a575 1
		printf("%s/%u", inet_ntop (AF_INET6, buf + 4, ntop_buf, 
d577 1
a577 1
		       *(buf + 4 + 16));
d581 2
a582 1
		printf("%u seconds", *(u_int32_t *)(buf + 4));
d587 1
a587 2
			printf("%c", isprint(*(buf + 4 + p)) ? 
			       *(buf + 4 + p) : '.');
d594 1
a594 1
			type = (buf[4 + p] << 8 | buf[4 + p + 1]) & 0x7fff;
d605 1
a605 1
	return len + 4;
@


1.5
log
@Extend IKE knowledge so we can parse the rest (normally encrypted parts)
of the IKE negotiation. Useful for isakmpd's new -L and -l options.
Also some cleanup. (angelos@@, niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ike.c,v 1.4 2000/10/03 14:25:47 ho Exp $	*/
d34 1
a34 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.4 2000/10/03 14:25:47 ho Exp $ (XXX)";
d202 1
a202 1
ike_sa_print (register u_char *buf, register int len)
d224 1
a224 1
ike_attribute_print (register u_char *buf, u_char doi)
d238 3
a240 2
	unsigned short type = buf[0]<<8 | buf[1];
	unsigned short length = 0, p;
d244 2
a245 2
		       ((type & 0x7fff) < sizeof attrs / sizeof attrs[0] ?
			attrs[type & 0x7fff] : "unknown"));
d248 18
a265 10
		       ((type & 0x7fff) < 
			(sizeof ipsec_attrs / sizeof ipsec_attrs[0]) ?
			ipsec_attrs[type & 0x7fff] : "unknown"));
		
	if (!(type >> 15)) {
	        length = buf[2]<<8 | buf[3];
	        for (p = 0; p < length; p++)
	               printf("%02x", (char)*(buf + 4 + p));
	} else {
	        p = buf[2]<<8 | buf[3];
d269 6
a274 6
                if (p < sizeof var / sizeof var [0]) \
                        printf("%s", var [p]); \
                else \
                        printf("%d (unknown)", p); \
                break;
 
d276 1
a276 1
		switch(type & 0x7fff) {
d284 1
a284 1
			printf("%d", p);
d287 1
a287 1
		switch(type & 0x7fff) {
d294 1
a294 1
			printf ("%d", p);
d296 1
a296 1
	}
d299 1
a299 1
	return length + 4;
d303 1
a303 1
ike_transform_print (register u_char *buf, register int len, u_char doi)
d309 1
a309 1
	printf("\n\t%stransform: %d ID: ", ike_tab_offset(), (char)buf[0]);
d341 1
a341 1
		attr += ike_attribute_print(attr, doi);
d346 1
a346 1
ike_proposal_print (register u_char *buf, register int len, u_char doi)
d368 1
a368 1
ike_ke_print (register u_char *buf, register int len, u_char doi)
d424 1
a424 1
			printf("%c",(isprint(*p) ? *p : '.'));
d438 1
a438 1
ike_notification_print (register u_char *buf, register int len)
d475 2
a476 1
			attr += ike_attribute_print(attr, IPSEC_DOI);
d504 1
a504 1
ike_vendor_print (register u_char *buf, register int len, u_char doi)
d517 114
d651 1
a651 1
		ike_sa_print(buf+4, this_len);
d655 1
a655 1
		ike_proposal_print(buf+4, this_len, doi);
d659 1
a659 1
		ike_transform_print(buf+4, this_len, doi);
d663 1
a663 1
		ike_ke_print(buf+4, this_len, doi);
d680 1
a680 1
	  	ike_notification_print(buf, this_len);
d684 5
a688 1
	        ike_vendor_print(buf+4, this_len, doi);
@


1.4
log
@Print IKE notifications (with -v). Style. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.3 1999/09/30 07:22:55 ho Exp $ (XXX)";
d48 1
d81 1
a81 1
static int isakmp_doi;
d83 2
a84 1
static void isakmp_pl_print(register u_char type, register u_char *payload);
d86 1
a86 1
int ike_tab_level = 0;
d102 16
d122 1
a122 1
isakmp_print (register const u_char *cp, register u_int length)
d166 2
a167 10
	printf("\n\tcookie: %02x%02x%02x%02x%02x%02x%02x%02x->"
	       "%02x%02x%02x%02x%02x%02x%02x%02x",
	       ih->init_cookie[0], ih->init_cookie[1],
	       ih->init_cookie[2], ih->init_cookie[3], 
	       ih->init_cookie[4], ih->init_cookie[5], 
	       ih->init_cookie[6], ih->init_cookie[7], 
	       ih->resp_cookie[0], ih->resp_cookie[1], 
	       ih->resp_cookie[2], ih->resp_cookie[3], 
	       ih->resp_cookie[4], ih->resp_cookie[5], 
	       ih->resp_cookie[6], ih->resp_cookie[7]);
d193 1
a193 1
	        isakmp_pl_print(nextpayload, payload);
d202 1
a202 1
isakmp_sa_print (register u_char *buf, register int len)
d205 3
a207 3
	isakmp_doi = ntohl((*(u_int32_t *)buf));
	printf(" DOI: %d", isakmp_doi);
	if (isakmp_doi == IPSEC_DOI) {
d217 1
a217 1
	        isakmp_pl_print (PAYLOAD_PROPOSAL, buf + 8);
d224 1
a224 1
isakmp_attribute_print (register u_char *buf)
d233 4
d241 10
a250 3
	printf("\n\t%sattribute %s = ", ike_tab_offset(),
	       ((type & 0x7fff) < sizeof attrs / sizeof attrs[0] ?
		attrs[type & 0x7fff] : "unknown"));
d255 1
a255 2
	}
	else {
d266 12
d279 5
a283 6
		CASE_PRINT(IKE_ATTR_ENCRYPTION_ALGORITHM, attr_enc);
		CASE_PRINT(IKE_ATTR_HASH_ALGORITHM, attr_hash);
		CASE_PRINT(IKE_ATTR_AUTHENTICATION_METHOD, attr_auth);
		CASE_PRINT(IKE_ATTR_GROUP_DESC, attr_gdesc);
		CASE_PRINT(IKE_ATTR_GROUP_TYPE, attr_gtype);
		CASE_PRINT(IKE_ATTR_LIFE_TYPE, attr_ltype);
d285 1
a285 1
		  printf("%d", p);
d288 2
d294 1
a294 1
isakmp_transform_print (register u_char *buf, register int len)
d296 2
d300 1
a300 2
	printf("\n\t%stransform: %d ID: %d", ike_tab_offset(),
	       (char)buf[0], (char)buf[1]);
d302 28
d332 1
a332 1
	        attr += isakmp_attribute_print(attr);
d337 1
a337 1
isakmp_proposal_print (register u_char *buf, register int len)
d339 14
a352 3
	printf(" proposal: %d proto: %d(%s) spisz: %d xforms: %d", 
	       buf[0], buf[1], (buf[1] == PROTO_ISAKMP ? "ISAKMP" : "unknown"),
	       buf[2], buf[3]);
d355 1
a355 1
	       isakmp_pl_print(PAYLOAD_TRANSFORM, buf+4);
d359 1
a359 1
isakmp_ke_print (register u_char *buf, register int len)
d361 1
a361 1
	if (isakmp_doi != IPSEC_DOI)
d364 1
a364 1
	printf(" <KE payload data (not shown)> len: %d", len);
d368 1
a368 1
isakmp_id_print (register u_char *buf, register int len)
d370 6
a375 1
	if (isakmp_doi != IPSEC_DOI) 
d378 48
a425 1
	printf(" <ID payload data (not shown)> len: %d", len);
d429 1
a429 1
isakmp_notification_print (register u_char *buf, register int len)
d433 2
d453 34
a486 1
	else
d488 2
a489 1
	
d494 1
a494 1
isakmp_vendor_print (register u_char *buf, register int len)
d498 1
a498 1
	if (isakmp_doi != IPSEC_DOI) 
d508 1
a508 1
isakmp_pl_print (register u_char type, register u_char *buf)
d527 1
a527 1
		isakmp_sa_print(buf+4, this_len);
d531 1
a531 1
		isakmp_proposal_print(buf+4, this_len);
d535 1
a535 1
	        isakmp_transform_print(buf+4, this_len);
d539 1
a539 1
		isakmp_ke_print(buf+4, this_len);
d543 2
a544 1
	        isakmp_id_print(buf+4, this_len);
d556 1
a556 1
	  	isakmp_notification_print(buf, this_len);
d560 1
a560 1
	        isakmp_vendor_print(buf+4, this_len);
d568 1
a568 1
	        isakmp_pl_print(next_type, buf + this_len);
d573 5
a577 1
	fputs(" [|isakmp]", stdout);
@


1.3
log
@Improve tcpdump's IKE/ISAKMP knowledge. (jakob@@, hugh@@ ok)
@
text
@d1 2
d34 1
a34 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.2 1999/09/16 17:08:01 brad Exp $ (XXX)";
d45 1
a46 1

d55 1
a55 3
#ifdef MODEMASK
#undef MODEMASK					/* Solaris sucks */
#endif
d69 11
a81 170
/* XXX Perhaps move these to an <ike.h> file? */

#define IPSEC_DOI		1

#define PROTO_ISAKMP            1

#define PAYLOAD_NONE		0
#define PAYLOAD_SA		1
#define PAYLOAD_PROPOSAL	2
#define PAYLOAD_TRANSFORM	3
#define PAYLOAD_KE		4
#define PAYLOAD_ID		5
#define PAYLOAD_CERT		6
#define PAYLOAD_CERTREQUEST	7
#define PAYLOAD_HASH		8
#define PAYLOAD_SIG		9
#define PAYLOAD_NONCE		10
#define PAYLOAD_NOTIFICATION	11
#define PAYLOAD_DELETE		12
#define PAYLOAD_VENDOR          13

#define IKE_ATTR_ENCRYPTION_ALGORITHM	1
#define IKE_ATTR_HASH_ALGORITHM		2
#define IKE_ATTR_AUTHENTICATION_METHOD	3
#define IKE_ATTR_GROUP_DESC		4
#define IKE_ATTR_GROUP_TYPE		5
#define IKE_ATTR_LIFE_TYPE		11

#define IKE_ATTR_ENCRYPT_INITIALIZER					\
	{ "NONE", "DES_CBS", "IDEA_CBC", "BLOWFISH_CBC",		\
	  "RC5_R16_B64_CBC", "3DES_CBC", "CAST_CBC",			\
	}
#define IKE_ATTR_HASH_INITIALIZER					\
	{ "NONE", "MD5", "SHA", "TIGER",				\
	}
#define IKE_ATTR_AUTH_INITIALIZER					\
	{ "NONE", "PRE_SHARED", "DSS", "RSA_SIG",			\
	  "RSA_ENC", "RSA_ENC_REV",					\
	}
#define IKE_ATTR_GROUP_DESC_INITIALIZER					\
	{ "NONE", "MODP_768", "MODP_1024",				\
	  "E2CN_155", "E2CN_185", "MODP_1536",				\
	}
#define IKE_ATTR_GROUP_INITIALIZER					\
	{ "NONE", "MODP", "ECP", "E2CN",				\
	}
#define IKE_ATTR_SA_DURATION_INITIALIZER				\
	{ "NONE", "SECONDS", "KILOBYTES",				\
	}

#define IKE_ATTR_INITIALIZER						\
	{ "NONE", 			/* 0 (not in RFC) */		\
	  "ENCRYPTION_ALGORITHM", 	/* 1 */				\
	  "HASH_ALGORITHM",		/* 2 */				\
	  "AUTHENTICATION_METHOD",	/* 3 */				\
	  "GROUP_DESCRIPTION",		/* 4 */				\
	  "GROUP_TYPE",			/* 5 */				\
	  "GROUP_PRIME",		/* 6 */				\
	  "GROUP_GENERATOR_1",		/* 7 */				\
	  "GROUP_GENERATOR_2",		/* 8 */				\
	  "GROUP_CURVE_1",		/* 9 */				\
	  "GROUP_CURVE_2",		/* 10 */			\
	  "LIFE_TYPE",			/* 11 */			\
	  "LIFE_DURATION",		/* 12 */			\
	  "PRF",			/* 13 */			\
	  "KEY_LENGTH",			/* 14 */			\
	  "FIELD_SIZE",			/* 15 */			\
	  "GROUP_ORDER",		/* 16 */			\
	}

#define IKE_SITUATION_IDENTITY_ONLY	1
#define IKE_SITUATION_SECRECY		2
#define IKE_SITUATION_INTEGRITY		4
/* Mask is all the above, i.e 1+2+4 = 7 */
#define IKE_SITUATION_MASK		7

#define IKE_PAYLOAD_TYPES_INITIALIZER			\
	{ "NONE",		/*  0 */		\
	  "SA",			/*  1 */		\
	  "PROPOSAL",		/*  2 */		\
	  "TRANSFORM",		/*  3 */		\
	  "KEY_EXCH",		/*  4 */		\
	  "ID",			/*  5 */		\
	  "CERT",		/*  6 */		\
	  "CERTREQUEST",	/*  7 */		\
	  "HASH",		/*  8 */		\
	  "SIG",		/*  9 */		\
	  "NONCE",		/* 10 */		\
	  "NOTIFICATION",	/* 11 */		\
	  "DELETE",		/* 12 */		\
	  "VENDOR",		/* 13 */		\
	}

/* Exchange types */
#define EXCHANGE_NONE           0
#define EXCHANGE_BASE           1
#define EXCHANGE_ID_PROT        2
#define EXCHANGE_AUTH_ONLY      3
#define EXCHANGE_AGGRESSIVE     4
#define EXCHANGE_INFO           5
#define EXCHANGE_QUICK_MODE	32
#define EXCHANGE_NEW_GROUP_MODE	33

/* Exchange types */
#define IKE_EXCHANGE_TYPES_INITIALIZER			\
	{ "NONE",		/* 0 */			\
	  "BASE",		/* 1 */			\
	  "ID_PROT",		/* 2 */			\
	  "AUTH_ONLY",		/* 3 */			\
	  "AGGRESSIVE",		/* 4 */			\
	  "INFO",		/* 5 */			\
	  /* step up to type 32 with unknowns */	\
	  "unknown", "unknown", "unknown", "unknown",	\
	  "unknown", "unknown", "unknown", "unknown",	\
	  "unknown", "unknown", "unknown", "unknown",	\
	  "unknown", "unknown", "unknown", "unknown",	\
	  "unknown", "unknown", "unknown", "unknown",	\
	  "unknown", "unknown", "unknown", "unknown",	\
	  "unknown", "unknown",				\
	  "QUICK_MODE",		/* 32 */		\
	  "NEW_GROUP_MODE",	/* 33 */		\
	}

#define FLAGS_ENCRYPTION	1
#define FLAGS_COMMIT		2
#define FLAGS_AUTH_ONLY		4

#define CERT_NONE               0
#define CERT_PKCS               1
#define CERT_PGP                2
#define CERT_DNS                3
#define CERT_X509_SIG           4
#define CERT_X509_KE            5
#define CERT_KERBEROS           6
#define CERT_CRL                7
#define CERT_ARL                8
#define CERT_SPKI               9
#define CERT_X509_ATTR         10

#define NOTIFY_INVALID_PAYLOAD_TYPE          1
#define NOTIFY_DOI_NOT_SUPPORTED             2
#define NOTIFY_SITUATION_NOT_SUPPORTED       3
#define NOTIFY_INVALID_COOKIE                4
#define NOTIFY_INVALID_MAJOR_VERSION         5
#define NOTIFY_INVALID_MINOR_VERSION         6
#define NOTIFY_INVALID_EXCHANGE_TYPE         7
#define NOTIFY_INVALID_FLAGS                 8
#define NOTIFY_INVALID_MESSAGE_ID            9
#define NOTIFY_INVALID_PROTOCOL_ID           10
#define NOTIFY_INVALID_SPI                   11
#define NOTIFY_INVALID_TRANSFORM_ID          12
#define NOTIFY_ATTRIBUTES_NOT_SUPPORTED      13
#define NOTIFY_NO_PROPOSAL_CHOSEN            14
#define NOTIFY_BAD_PROPOSAL_SYNTAX           15
#define NOTIFY_PAYLOAD_MALFORMED             16
#define NOTIFY_INVALID_KEY_INFORMATION       17
#define NOTIFY_INVALID_ID_INFORMATION        18
#define NOTIFY_INVALID_CERT_ENCODING         19
#define NOTIFY_INVALID_CERTIFICATE           20
#define NOTIFY_CERT_TYPE_UNSUPPORTED         21
#define NOTIFY_INVALID_CERT_AUTHORITY        22
#define NOTIFY_INVALID_HASH_INFORMATION      23
#define NOTIFY_AUTHENTICATION_FAILED         24
#define NOTIFY_INVALID_SIGNATURE             25
#define NOTIFY_ADDRESS_NOTIFICATION          26
#define NOTIFY_NOTIFY_SA_LIFETIME            27
#define NOTIFY_CERTIFICATE_UNAVAILABLE       28
#define NOTIFY_UNSUPPORTED_EXCHANGE_TYPE     29
#define NOTIFY_UNEQUAL_PAYLOAD_LENGTHS       30

d88 2
a89 1
const char *ike_tab_offset(void)
d103 2
a104 1
void isakmp_print(register const u_char *cp, register int length)
d109 1
a109 2
	u_char  nextpayload, np1;
	u_int   paylen;
d191 2
a192 1
void isakmp_sa_print(register u_char *buf, register int len)
d213 2
a214 1
int isakmp_attribute_print(register u_char *buf)
d260 2
a261 1
void isakmp_transform_print(register u_char *buf, register int len)
d274 2
a275 1
void isakmp_proposal_print(register u_char *buf, register int len)
d285 2
a286 1
void isakmp_ke_print(register u_char *buf, register int len)
d294 2
a295 1
void isakmp_id_print(register u_char *buf, register int len)
d302 29
d332 2
a333 1
void isakmp_vendor_print(register u_char *buf, register int len)
d346 2
a347 1
void isakmp_pl_print(register u_char type, register u_char *buf)
a388 2
		break;
	    
d390 1
a390 3
#if 0
		isakmp_nonce_print(buf+4, this_len);
#endif
d394 1
a394 1
	case PAYLOAD_DELETE:
@


1.2
log
@- #if __STDC__ --> #ifdef __STDC__
- remove unused variables
@
text
@d25 3
d32 1
a32 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ike.c,v 1.1 1999/07/28 20:41:36 jakob Exp $ (XXX)";
d71 5
a75 2
#define FLAGS_ENCRYPTION	1
#define FLAGS_COMMIT		2
d90 103
d194 60
a253 1
#define IPSEC_DOI		1
d255 2
a256 3
static void isakmp_pl_print(register u_char type, 
			    register u_char *payload, 
			    register int paylen);
d269 1
d289 7
a295 1
	printf(" v%d.%d\n\t", ih->version >> 4, ih->version & 0xf);
d306 2
a307 1
	printf(" cookie: %02x%02x%02x%02x%02x%02x%02x%02x->%02x%02x%02x%02x%02x%02x%02x%02x\n\t",
d318 1
a318 1
	printf(" msgid:%02x%02x%02x%02x",
d323 1
a323 1
	printf(" length %d", ntohl(ih->length));
a329 1
	/* now, process payloads */
d339 3
a341 10
	while (nextpayload != 0) {
		np1 = payload[0];
		paylen = (payload[2] << 8) + payload[3];
		printf("\n\t\tload: %02x len: %04x",
		       nextpayload, paylen);
		TCHECK(payload[0], paylen);  
		isakmp_pl_print(nextpayload, payload, paylen);
		payload += paylen;
		nextpayload = np1;
	}
d351 17
a367 4
	isakmp_doi = ntohl((*(u_int32_t *)(buf+4)));
	printf(" SA doi: %d",
	       isakmp_doi, (isakmp_doi == IPSEC_DOI ? "(ipsec)" : ""));
	printf(" situation\n");
d369 2
a370 2
	
void isakmp_proposal_print(register u_char *buf, register int len)
d372 21
a392 2
	u_char *spis;
	int spisize, numspi, i;
d394 17
a410 13
	spisize = buf[6];
	numspi  = buf[7];
	  

	printf(" proposal number: %d protocol: %d spisize: %d #spi: %d", 
	       buf[4], buf[5], spisize, numspi);

	spis = buf+8;
	while (numspi) {
		printf("\n\t ");
		for (i=0; i<spisize; i++) {
			printf("%02x", *spis);
			spis++;
d413 1
d415 7
d423 16
d441 1
a441 2
	if (isakmp_doi != IPSEC_DOI) {
		printf("KE unknown doi\n");
d443 10
a452 1
	}
d455 14
a468 3
void isakmp_pl_print(register u_char type, 
		     register u_char *buf, 
		     register int len)
d470 12
d485 1
d487 1
a487 1
		isakmp_sa_print(buf, len);
d491 1
a491 1
		isakmp_proposal_print(buf, len);
d495 1
d499 1
a499 1
		isakmp_ke_print(buf, len);
d503 3
d514 1
a514 1
		isakmp_nonce_print(buf, len);
d520 6
d528 9
@


1.1
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d29 1
a29 1
    "@@(#) $Header: print-ike.c,v 0.0 00/00/00 00:00:00 xxx Exp $ (XXX)";
d36 1
a36 1
#if __STDC__
a97 1
	int mode, version, leapind;
@

