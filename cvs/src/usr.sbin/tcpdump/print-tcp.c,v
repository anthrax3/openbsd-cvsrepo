head	1.37;
access;
symbols
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.35.0.6
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.16
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.14
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.12
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.10
	OPENBSD_5_0:1.28.0.8
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.6
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.26.0.10
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.6
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.4
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.25.0.4
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.6
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.4
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2016.11.16.13.47.27;	author reyk;	state Exp;
branches;
next	1.36;
commitid	XyJooSdwV3dkETpz;

1.36
date	2016.10.22.20.55.04;	author rzalamena;	state Exp;
branches;
next	1.35;
commitid	cnmsKk1DpJAmVheV;

1.35
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.34;
commitid	enjTsnD5UO6xazKc;

1.34
date	2015.11.05.11.57.31;	author jca;	state Exp;
branches;
next	1.33;
commitid	WHlmbDo8fbaWbOF6;

1.33
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	z3HrihslRYb4HqW9;

1.32
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	Uu5nFG3wCl0LACBb;

1.31
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.30;
commitid	yLXrOcgrag4eS8u4;

1.30
date	2014.06.20.04.04.52;	author lteo;	state Exp;
branches;
next	1.29;
commitid	2daJ0iB9vSWHdMTb;

1.29
date	2014.02.05.21.12.19;	author florian;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.12.06.10.33;	author naddy;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.27.23.59.56;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.13.05.10.15;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.28.22.48.16;	author moritz;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.16.14.02.07;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.16.11.29.51;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.10.19.55.07;	author markus;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.28.14.08.14;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.15.12.27.07;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.12.10.58.25;	author dhartmei;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.21.19.14.23;	author frantzen;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.23.01.05.15;	author stevesk;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.25.19.56.11;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.07.22.36.46;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.12.05.08.17.45;	author jakob;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.03.14.21.56;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.26.21.35.43;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.16.11.43.58;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	99.11.26.18.16.55;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	99.09.16.17.59.50;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	1.6;

1.6
date	98.09.22.22.03.01;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.26;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.31;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.50;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.39;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Add new DLT_OPENFLOW link-type to allow using tcpdump to debug switch(4),
eg. tcpdump -y openflow -i switch0

Includes a minor bump for libpcap.

Feedback and OK rzalamena@@
@
text
@/*	$OpenBSD: print-tcp.c,v 1.36 2016/10/22 20:55:04 rzalamena Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/time.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <net/if.h>
#include <net/pfvar.h>

#include <rpc/rpc.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif

#include "interface.h"
#include "addrtoname.h"
#include "extract.h"

#include "nfs.h"

static void print_tcp_rst_data(const u_char *sp, u_int length);

#define MAX_RST_DATA_LEN	30

/* Compatibility */
#ifndef TCPOPT_WSCALE
#define	TCPOPT_WSCALE		3	/* window scale factor (rfc1072) */
#endif
#ifndef TCPOPT_SACKOK
#define	TCPOPT_SACKOK		4	/* selective ack ok (rfc2018) */
#endif
#ifndef TCPOPT_SACK
#define	TCPOPT_SACK		5	/* selective ack (rfc2018) */
#endif
#ifndef TCPOLEN_SACK
#define TCPOLEN_SACK		8	/* length of a SACK block */
#endif
#ifndef TCPOPT_ECHO
#define	TCPOPT_ECHO		6	/* echo (rfc1072) */
#endif
#ifndef TCPOPT_ECHOREPLY
#define	TCPOPT_ECHOREPLY	7	/* echo (rfc1072) */
#endif
#ifndef TCPOPT_TIMESTAMP
#define TCPOPT_TIMESTAMP	8	/* timestamps (rfc1323) */
#endif
#ifndef TCPOPT_CC
#define TCPOPT_CC		11	/* T/TCP CC options (rfc1644) */
#endif
#ifndef TCPOPT_CCNEW
#define TCPOPT_CCNEW		12	/* T/TCP CC options (rfc1644) */
#endif
#ifndef TCPOPT_CCECHO
#define TCPOPT_CCECHO		13	/* T/TCP CC options (rfc1644) */
#endif

/* Definitions required for ECN
   for use if the OS running tcpdump does not have ECN */
#ifndef TH_ECNECHO
#define TH_ECNECHO		0x40	/* ECN Echo in tcp header */
#endif
#ifndef TH_CWR
#define TH_CWR			0x80	/* ECN Cwnd Reduced in tcp header*/
#endif

struct tha {
#ifndef INET6
	struct in_addr src;
	struct in_addr dst;
#else
	struct in6_addr src;
	struct in6_addr dst;
#endif /*INET6*/
	u_int port;
};

struct tcp_seq_hash {
	struct tcp_seq_hash *nxt;
	struct tha addr;
	tcp_seq seq;
	tcp_seq ack;
};

#define TSEQ_HASHSIZE 919

/* These tcp optinos do not have the size octet */
#define ZEROLENOPT(o) ((o) == TCPOPT_EOL || (o) == TCPOPT_NOP)

static struct tcp_seq_hash tcp_seq_hash[TSEQ_HASHSIZE];

#ifndef BGP_PORT
#define BGP_PORT        179
#endif
#define NETBIOS_SSN_PORT 139

/* OpenFlow TCP ports. */
#define OLD_OFP_PORT	6633
#define OFP_PORT	6653

static int tcp_cksum(const struct ip *ip, const struct tcphdr *tp, int len)
{
	union phu {
		struct phdr {
			u_int32_t src;
			u_int32_t dst;
			u_char mbz;
			u_char proto;
			u_int16_t len;
		} ph;
		u_int16_t pa[6];
	} phu;
	const u_int16_t *sp;
	u_int32_t sum;

	/* pseudo-header.. */
	phu.ph.len = htons((u_int16_t)len);
	phu.ph.mbz = 0;
	phu.ph.proto = IPPROTO_TCP;
	memcpy(&phu.ph.src, &ip->ip_src.s_addr, sizeof(u_int32_t));
	memcpy(&phu.ph.dst, &ip->ip_dst.s_addr, sizeof(u_int32_t));

	sp = &phu.pa[0];
	sum = sp[0]+sp[1]+sp[2]+sp[3]+sp[4]+sp[5];

	return in_cksum((u_short *)tp, len, sum);
}

#ifdef INET6
static int tcp6_cksum(const struct ip6_hdr *ip6, const struct tcphdr *tp,
		      u_int len)
{
	union {
		struct {
			struct in6_addr ph_src;
			struct in6_addr ph_dst;
			u_int32_t       ph_len;
			u_int8_t        ph_zero[3];
			u_int8_t        ph_nxt;
		} ph;
		u_int16_t pa[20];
	} phu;
	size_t i;
	u_int32_t sum = 0;

	/* pseudo-header */
	memset(&phu, 0, sizeof(phu));
	phu.ph.ph_src = ip6->ip6_src;
	phu.ph.ph_dst = ip6->ip6_dst;
	phu.ph.ph_len = htonl(len);
	phu.ph.ph_nxt = IPPROTO_TCP;

	for (i = 0; i < sizeof(phu.pa) / sizeof(phu.pa[0]); i++)
		sum += phu.pa[i];

	return in_cksum((u_short *)tp, len, sum);
}
#endif


void
tcp_print(const u_char *bp, u_int length, const u_char *bp2)
{
	const struct tcphdr *tp;
	const struct ip *ip;
	u_char flags;
	int hlen;
	char ch;
	struct tcp_seq_hash *th = NULL;
	int rev = 0;
	u_int16_t sport, dport, win, urp;
	tcp_seq seq, ack;
#ifdef INET6
	const struct ip6_hdr *ip6;
#endif

	tp = (struct tcphdr *)bp;
	switch (((struct ip *)bp2)->ip_v) {
	case 4:
		ip = (struct ip *)bp2;
#ifdef INET6
		ip6 = NULL;
#endif
		break;
#ifdef INET6
	case 6:
		ip = NULL;
		ip6 = (struct ip6_hdr *)bp2;
		break;
#endif
	default:
		(void)printf("invalid ip version");
		return;
	}

	ch = '\0';
	if (length < sizeof(*tp)) {
		(void)printf("truncated-tcp %u", length);
		return;
	}

	if (!TTEST(tp->th_dport)) {
#ifdef INET6
		if (ip6) {
			(void)printf("%s > %s: [|tcp]",
				ip6addr_string(&ip6->ip6_src),
				ip6addr_string(&ip6->ip6_dst));
		} else
#endif /*INET6*/
		{
			(void)printf("%s > %s: [|tcp]",
				ipaddr_string(&ip->ip_src),
				ipaddr_string(&ip->ip_dst));
		}
		return;
	}

	sport = ntohs(tp->th_sport);
	dport = ntohs(tp->th_dport);

#ifdef INET6
	if (ip6) {
		if (ip6->ip6_nxt == IPPROTO_TCP) {
			(void)printf("%s.%s > %s.%s: ",
				ip6addr_string(&ip6->ip6_src),
				tcpport_string(sport),
				ip6addr_string(&ip6->ip6_dst),
				tcpport_string(dport));
		} else {
			(void)printf("%s > %s: ",
				tcpport_string(sport), tcpport_string(dport));
		}
	} else
#endif /*INET6*/
	{
		if (ip->ip_p == IPPROTO_TCP) {
			(void)printf("%s.%s > %s.%s: ",
				ipaddr_string(&ip->ip_src),
				tcpport_string(sport),
				ipaddr_string(&ip->ip_dst),
				tcpport_string(dport));
		} else {
			(void)printf("%s > %s: ",
				tcpport_string(sport), tcpport_string(dport));
		}
	}

	if (!qflag && TTEST(tp->th_seq) && !TTEST(tp->th_ack))
		(void)printf("%u ", ntohl(tp->th_seq));

	TCHECK(*tp);
	seq = ntohl(tp->th_seq);
	ack = ntohl(tp->th_ack);
	win = ntohs(tp->th_win);
	urp = ntohs(tp->th_urp);
	hlen = tp->th_off * 4;

	if (qflag) {
		(void)printf("tcp %d", length - tp->th_off * 4);
		return;
	} else if (packettype != PT_TCP) {

		/*
		 * If data present and NFS port used, assume NFS.
		 * Pass offset of data plus 4 bytes for RPC TCP msg length
		 * to NFS print routines.
		 */
		u_int len = length - hlen;
		if ((u_char *)tp + 4 + sizeof(struct rpc_msg) <= snapend &&
		    dport == NFS_PORT) {
			nfsreq_print((u_char *)tp + hlen + 4, len, bp2);
			return;
		} else if ((u_char *)tp + 4 + 
		    sizeof(struct rpc_msg) <= snapend && sport == NFS_PORT) {
			nfsreply_print((u_char *)tp + hlen + 4, len, bp2);
			return;
		}
	}
	if ((flags = tp->th_flags) & (TH_SYN|TH_FIN|TH_RST|TH_PUSH|
				      TH_ECNECHO|TH_CWR)) {
		if (flags & TH_SYN)
			putchar('S');
		if (flags & TH_FIN)
			putchar('F');
		if (flags & TH_RST)
			putchar('R');
		if (flags & TH_PUSH)
			putchar('P');
		if (flags & TH_CWR)
			putchar('W');	/* congestion _W_indow reduced (ECN) */
		if (flags & TH_ECNECHO)
			putchar('E');	/* ecn _E_cho sent (ECN) */
	} else
		putchar('.');

	if (!Sflag && (flags & TH_ACK)) {
		struct tha tha;
		/*
		 * Find (or record) the initial sequence numbers for
		 * this conversation.  (we pick an arbitrary
		 * collating order so there's only one entry for
		 * both directions).
		 */
#ifdef INET6
		bzero(&tha, sizeof(tha));
		rev = 0;
		if (ip6) {
			if (sport > dport) {
				rev = 1;
			} else if (sport == dport) {
			    int i;

			    for (i = 0; i < 4; i++) {
				if (((u_int32_t *)(&ip6->ip6_src))[i] >
				    ((u_int32_t *)(&ip6->ip6_dst))[i]) {
					rev = 1;
					break;
				}
			    }
			}
			if (rev) {
				tha.src = ip6->ip6_dst;
				tha.dst = ip6->ip6_src;
				tha.port = dport << 16 | sport;
			} else {
				tha.dst = ip6->ip6_dst;
				tha.src = ip6->ip6_src;
				tha.port = sport << 16 | dport;
			}
		} else {
			if (sport > dport ||
			    (sport == dport &&
			     ip->ip_src.s_addr > ip->ip_dst.s_addr)) {
				rev = 1;
			}
			if (rev) {
				*(struct in_addr *)&tha.src = ip->ip_dst;
				*(struct in_addr *)&tha.dst = ip->ip_src;
				tha.port = dport << 16 | sport;
			} else {
				*(struct in_addr *)&tha.dst = ip->ip_dst;
				*(struct in_addr *)&tha.src = ip->ip_src;
				tha.port = sport << 16 | dport;
			}
		}
#else
		if (sport < dport ||
		    (sport == dport &&
		     ip->ip_src.s_addr < ip->ip_dst.s_addr)) {
			tha.src = ip->ip_src, tha.dst = ip->ip_dst;
			tha.port = sport << 16 | dport;
			rev = 0;
		} else {
			tha.src = ip->ip_dst, tha.dst = ip->ip_src;
			tha.port = dport << 16 | sport;
			rev = 1;
		}
#endif

		for (th = &tcp_seq_hash[tha.port % TSEQ_HASHSIZE];
		     th->nxt; th = th->nxt)
			if (!memcmp((char *)&tha, (char *)&th->addr,
				  sizeof(th->addr)))
				break;

		if (!th->nxt || flags & TH_SYN) {
			/* didn't find it or new conversation */
			if (th->nxt == NULL) {
				th->nxt = calloc(1, sizeof(*th));
				if (th->nxt == NULL)
					error("tcp_print: calloc");
			}
			th->addr = tha;
			if (rev)
				th->ack = seq, th->seq = ack - 1;
			else
				th->seq = seq, th->ack = ack - 1;
		} else {
			if (rev)
				seq -= th->ack, ack -= th->seq;
			else
				seq -= th->seq, ack -= th->ack;
		}
	}
	hlen = tp->th_off * 4;
	if (hlen > length) {
		(void)printf(" [bad hdr length]");
		return;
	}

	if (ip && ip->ip_v == 4 && vflag) {
		if (TTEST2(tp->th_sport, length)) {
			u_int16_t sum, tcp_sum;
			sum = tcp_cksum(ip, tp, length);
			if (sum != 0) {
				tcp_sum = EXTRACT_16BITS(&tp->th_sum);
				(void)printf(" [bad tcp cksum %x! -> %x]", tcp_sum,
				    in_cksum_shouldbe(tcp_sum, sum));
			} else
				(void)printf(" [tcp sum ok]");
		}
	}
#ifdef INET6
	if (ip6 && ip6->ip6_plen && vflag) {
		if (TTEST2(tp->th_sport, length)) {
			u_int16_t sum, tcp_sum;
			sum = tcp6_cksum(ip6, tp, length);
			if (sum != 0) {
				tcp_sum = EXTRACT_16BITS(&tp->th_sum);
				(void)printf(" [bad tcp cksum %x! -> %x]", tcp_sum,
				    in_cksum_shouldbe(tcp_sum, sum));
			} else
				(void)printf(" [tcp sum ok]");
		}
	}
#endif

	/* OS Fingerprint */
	if (oflag && (flags & (TH_SYN|TH_ACK)) == TH_SYN) {
		struct pf_osfp_enlist *head = NULL;
		struct pf_osfp_entry *fp;
		unsigned long left;
		left = (unsigned long)(snapend - (const u_char *)tp);

		if (left >= hlen)
			head = pf_osfp_fingerprint_hdr(ip, ip6, tp);
		if (head) {
			int prev = 0;
			printf(" (src OS:");
			SLIST_FOREACH(fp, head, fp_entry) {
				if (fp->fp_enflags & PF_OSFP_EXPANDED)
					continue;
				if (prev)
					printf(",");
				printf(" %s", fp->fp_class_nm);
				if (fp->fp_version_nm[0])
					printf(" %s", fp->fp_version_nm);
				if (fp->fp_subtype_nm[0])
					printf(" %s", fp->fp_subtype_nm);
				prev = 1;
			}
			printf(")");
		} else {
			if (left < hlen)
				printf(" (src OS: short-pkt)");
			else
				printf(" (src OS: unknown)");
		}
	}

	length -= hlen;
	if (vflag > 1 || length > 0 || flags & (TH_SYN | TH_FIN | TH_RST))
		(void)printf(" %u:%u(%u)", seq, seq + length, length);
	if (flags & TH_ACK)
		(void)printf(" ack %u", ack);

	(void)printf(" win %u", win);

	if (flags & TH_URG)
		(void)printf(" urg %u", urp);
	/*
	 * Handle any options.
	 */
	if ((hlen -= sizeof(*tp)) > 0) {
		const u_char *cp;
		int i, opt, len, datalen;

		cp = (const u_char *)tp + sizeof(*tp);
		putchar(' ');
		ch = '<';
		while (hlen > 0) {
			putchar(ch);
			TCHECK(*cp);
			opt = *cp++;
			if (ZEROLENOPT(opt))
				len = 1;
			else {
				TCHECK(*cp);
				len = *cp++;	/* total including type, len */
				if (len < 2 || len > hlen)
					goto bad;
				--hlen;		/* account for length byte */
			}
			--hlen;			/* account for type byte */
			datalen = 0;

/* Bail if "l" bytes of data are not left or were not captured  */
#define LENCHECK(l) { if ((l) > hlen) goto bad; TCHECK2(*cp, l); }

			switch (opt) {

			case TCPOPT_MAXSEG:
				(void)printf("mss");
				datalen = 2;
				LENCHECK(datalen);
				(void)printf(" %u", EXTRACT_16BITS(cp));

				break;

			case TCPOPT_EOL:
				(void)printf("eol");
				break;

			case TCPOPT_NOP:
				(void)printf("nop");
				break;

			case TCPOPT_WSCALE:
				(void)printf("wscale");
				datalen = 1;
				LENCHECK(datalen);
				(void)printf(" %u", *cp);
				break;

			case TCPOPT_SACKOK:
				(void)printf("sackOK");
				if (len != 2)
					(void)printf("[len %d]", len);
				break;

			case TCPOPT_SACK:
			{
				u_long s, e;

				datalen = len - 2;
				if ((datalen % TCPOLEN_SACK) != 0 ||
				    !(flags & TH_ACK)) {
				         (void)printf("malformed sack ");
					 (void)printf("[len %d] ", datalen);
					 break;
				}
				printf("sack %d ", datalen/TCPOLEN_SACK);
				for (i = 0; i < datalen; i += TCPOLEN_SACK) {
					LENCHECK (i + TCPOLEN_SACK);
					s = EXTRACT_32BITS(cp + i);
					e = EXTRACT_32BITS(cp + i + 4);
					if (!Sflag) {
						if (rev) {
							s -= th->seq;
							e -= th->seq;
						} else {
							s -= th->ack;
							e -= th->ack;
						}
					}
					(void) printf("{%lu:%lu} ", s, e);
				}
				break;
			}
			case TCPOPT_ECHO:
				(void)printf("echo");
				datalen = 4;
				LENCHECK(datalen);
				(void)printf(" %u", EXTRACT_32BITS(cp));
				break;

			case TCPOPT_ECHOREPLY:
				(void)printf("echoreply");
				datalen = 4;
				LENCHECK(datalen);
				(void)printf(" %u", EXTRACT_32BITS(cp));
				break;

			case TCPOPT_TIMESTAMP:
				(void)printf("timestamp");
				datalen = 8;
				LENCHECK(4);
				(void)printf(" %u", EXTRACT_32BITS(cp));
				LENCHECK(datalen);
				(void)printf(" %u", EXTRACT_32BITS(cp + 4));
				break;

			case TCPOPT_CC:
				(void)printf("cc");
				datalen = 4;
				LENCHECK(datalen);
				(void)printf(" %u", EXTRACT_32BITS(cp));
				break;

			case TCPOPT_CCNEW:
				(void)printf("ccnew");
				datalen = 4;
				LENCHECK(datalen);
				(void)printf(" %u", EXTRACT_32BITS(cp));
				break;

			case TCPOPT_CCECHO:
				(void)printf("ccecho");
				datalen = 4;
				LENCHECK(datalen);
				(void)printf(" %u", EXTRACT_32BITS(cp));
				break;

			case TCPOPT_SIGNATURE:
				(void)printf("tcpmd5:");
				datalen = len - 2;
				for (i = 0; i < datalen; ++i) {
					LENCHECK(i+1);
					(void)printf("%02x", cp[i]);
				}
				break;

			default:
				(void)printf("opt-%d:", opt);
				datalen = len - 2;
				for (i = 0; i < datalen; ++i) {
					LENCHECK(i+1);
					(void)printf("%02x", cp[i]);
				}
				break;
			}

			/* Account for data printed */
			cp += datalen;
			hlen -= datalen;

			/* Check specification against observed length */
			++datalen;			/* option octet */
			if (!ZEROLENOPT(opt))
				++datalen;		/* size octet */
			if (datalen != len)
				(void)printf("[len %d]", len);
			ch = ',';
			if (opt == TCPOPT_EOL)
				break;
		}
		putchar('>');
	}

	if (length <= 0)
		return;

	/*
	 * Decode payload if necessary.
	*/
	bp += (tp->th_off * 4);
	if (flags & TH_RST) {
		if (vflag)
			print_tcp_rst_data(bp, length);
	} else {
		if (sport == BGP_PORT || dport == BGP_PORT)
			bgp_print(bp, length);
		else if (sport == OLD_OFP_PORT || dport == OLD_OFP_PORT ||
		    sport == OFP_PORT || dport == OFP_PORT)
			ofp_print(bp, length);
#if 0
		else if (sport == NETBIOS_SSN_PORT || dport == NETBIOS_SSN_PORT)
			nbt_tcp_print(bp, length);
#endif
	}
	return;
bad:
	fputs("[bad opt]", stdout);
	if (ch != '\0')
		putchar('>');
	return;
trunc:
	fputs("[|tcp]", stdout);
	if (ch != '\0')
		putchar('>');
}


/*
 * RFC1122 says the following on data in RST segments:
 *
 *         4.2.2.12  RST Segment: RFC-793 Section 3.4
 *
 *            A TCP SHOULD allow a received RST segment to include data.
 *
 *            DISCUSSION
 *                 It has been suggested that a RST segment could contain
 *                 ASCII text that encoded and explained the cause of the
 *                 RST.  No standard has yet been established for such
 *                 data.
 *
 */

static void
print_tcp_rst_data(const u_char *sp, u_int length)
{
	int c;

	if (TTEST2(*sp, length))
		printf(" [RST");
	else
		printf(" [!RST");
	if (length > MAX_RST_DATA_LEN) {
		length = MAX_RST_DATA_LEN;	/* can use -X for longer */
		putchar('+');			/* indicate we truncate */
	}
	putchar(' ');
	while (length-- && sp < snapend) {
		c = *sp++;
		safeputchar(c);
	}
	putchar(']');
}
@


1.36
log
@Teach tcpdump(8) how to read OpenFlow packets. This initial implementation
supports the following message types: hello, error, echo request/reply,
feature request/reply, set config, packet-in, packet-out, flow removed and
flow mod.

We currently only support printing this messages for OpenFlow 1.3.5, however
it is possible to reuse some functions and get other versions working too.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.35 2015/11/16 00:16:39 mmcc Exp $	*/
d674 1
a674 1
			ofp_print(bp);
@


1.35
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.34 2015/11/05 11:57:31 jca Exp $	*/
d126 4
d672 3
@


1.34
log
@Print unsigned integers as unsigned integers, kill inconsistent casts.

Initial diff by Kevin Reay.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.33 2015/08/20 22:39:29 deraadt Exp $	*/
d51 1
a51 1
static void print_tcp_rst_data(register const u_char *sp, u_int length);
d187 1
a187 2
tcp_print(register const u_char *bp, register u_int length,
	  register const u_char *bp2)
d189 7
a195 7
	register const struct tcphdr *tp;
	register const struct ip *ip;
	register u_char flags;
	register int hlen;
	register char ch;
	register struct tcp_seq_hash *th = NULL;
	register int rev = 0;
d199 1
a199 1
	register const struct ip6_hdr *ip6;
d490 2
a491 2
		register const u_char *cp;
		register int i, opt, len, datalen;
d702 1
a702 1
print_tcp_rst_data(register const u_char *sp, u_int length)
@


1.33
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.32 2015/01/16 06:40:21 deraadt Exp $	*/
d224 1
a224 1
		(void)printf("truncated-tcp %d", length);
d479 1
a479 2
		(void)printf(" %lu:%lu(%d)", (long) seq, (long) (seq + length),
		    length);
d483 1
a483 1
	(void)printf(" win %d", win);
d486 1
a486 1
		(void)printf(" urg %d", urp);
@


1.32
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.31 2014/08/14 12:44:44 mpi Exp $	*/
d395 1
a395 2
				th->nxt = (struct tcp_seq_hash *)
					calloc(1, sizeof(*th));
@


1.31
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.30 2014/06/20 04:04:52 lteo Exp $	*/
a23 1
#include <sys/param.h>
@


1.30
log
@Instead of showing the difference between a bad checksum and a good
checksum, make tcpdump (with the -v flag) show the actual bad checksum
within the IP/protocol header itself and what the good checksum should
be, e.g. "[bad tcp cksum abcd! -> d1e6]"

This change applies to IP, TCP (over IPv4 and IPv6), UDP (over IPv4 and
IPv6), ICMP, and ICMPv6.  This commit also fixes several inconsistencies
in the way bad checksums were displayed for these protocols.

Tested on amd64, i386, and macppc.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.29 2014/02/05 21:12:19 florian Exp $	*/
a28 1
#include <netinet/in_systm.h>
a31 1
#include <netinet/tcpip.h>
@


1.29
log
@Don't segfault on IPv6 NFS traffic; found the hard why by matthieu@@.
Fix inspired by what upstream is doing.
Tested by me and matthieu@@.
Input^WHand holding and OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.28 2010/01/12 06:10:33 naddy Exp $	*/
a421 1
		int sum;
d423 1
d425 5
a429 3
			if (sum != 0)
				(void)printf(" [bad tcp cksum %x!]", sum);
			else
a434 1
		int sum;
d436 1
d438 5
a442 3
			if (sum != 0)
				(void)printf(" [bad tcp cksum %x!]", sum);
			else
@


1.28
log
@Add TCP/UDP checksum display for v6 and clean up the checksum
calculation.  Mostly from tcpdump.org; ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.27 2009/10/27 23:59:56 deraadt Exp $	*/
d300 1
a300 2
			nfsreq_print((u_char *)tp + hlen + 4, len,
				     (u_char *)ip);
d304 1
a304 2
			nfsreply_print((u_char *)tp + hlen + 4, len,
				       (u_char *)ip);
@


1.27
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.26 2007/10/07 16:41:05 deraadt Exp $	*/
d129 1
a129 3
static int tcp_cksum(register const struct ip *ip,
		     register const struct tcphdr *tp,
		     register int len)
a130 1
	int i, tlen;
d141 1
a141 1
	register const u_int16_t *sp;
a142 1
	tlen = ntohs(ip->ip_len) - ((const char *)tp-(const char*)ip);
d145 1
a145 1
	phu.ph.len = htons(tlen);
d147 1
a147 1
	phu.ph.proto = ip->ip_p;
d154 2
a155 1
	sp = (const u_int16_t *)tp;
d157 16
a172 2
	for (i=0; i<(tlen&~1); i+= 2)
		sum += *sp++;
d174 6
a179 3
	if (tlen & 1) {
		sum += htons( (*(const char *)sp) << 8);
	}
d181 2
a182 3
	while (sum > 0xffff)
		sum = (sum & 0xffff) + (sum >> 16);
	sum = ~sum & 0xffff;
d184 1
a184 1
	return (sum);
d186 1
d433 12
@


1.26
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.25 2006/12/13 05:10:15 itojun Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.25
log
@IPv6 passive OS fingerprinting.
reuses IPv4 signature file (assuming that TCP code is shared among IPv4/v6).
mcbride ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.24 2006/05/28 22:48:16 moritz Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.24 2006/05/28 22:48:16 moritz Exp $ (LBL)";
@


1.24
log
@Correct more bounds checks which can lead to crashes.

ok canacar@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.23 2004/09/16 14:02:07 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.23 2004/09/16 14:02:07 markus Exp $ (LBL)";
d198 3
a200 1
	ip = (struct ip *)bp2;
d202 6
a207 1
	if (ip->ip_v == 6)
d209 7
a215 3
	else
		ip6 = NULL;
#endif /*INET6*/
d414 1
a414 1
	if (ip->ip_v == 4 && vflag) {
d426 1
a426 5
	if (oflag &&
#ifdef INET6
	    ip6 == NULL &&
#endif
	    (flags & (TH_SYN|TH_ACK)) == TH_SYN) {
d433 1
a433 1
			head = pf_osfp_fingerprint_hdr(ip, tp);
@


1.23
log
@print th_seq from truncated tcp headers (e.g. in icmp need-frag)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.22 2004/09/16 11:29:51 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.22 2004/09/16 11:29:51 markus Exp $ (LBL)";
d599 1
a599 1
					LENCHECK(i);
d608 1
a608 1
					LENCHECK(i);
d691 1
a691 1
	while (length-- && sp <= snapend) {
@


1.22
log
@add -T tcp to enforce interpretation as TCP
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.21 2004/08/10 19:55:07 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.21 2004/08/10 19:55:07 markus Exp $ (LBL)";
d256 3
@


1.21
log
@print ip/port for truncated tcp packets; ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.20 2004/07/28 14:08:14 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.20 2004/07/28 14:08:14 markus Exp $ (LBL)";
d267 2
a268 1
	} else {
@


1.20
log
@print th_seq for -vv; ok hshoexer, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.19 2004/01/15 12:27:07 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.19 2004/01/15 12:27:07 markus Exp $ (LBL)";
a205 1
	TCHECK(*tp);
d211 16
a228 6
	seq = ntohl(tp->th_seq);
	ack = ntohl(tp->th_ack);
	win = ntohs(tp->th_win);
	urp = ntohs(tp->th_urp);
	hlen = tp->th_off * 4;

d256 7
@


1.19
log
@print tcpmd5 signature options; with/ok itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.18 2003/10/12 10:58:25 dhartmei Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.18 2003/10/12 10:58:25 dhartmei Exp $ (LBL)";
d432 1
a432 1
	if (length > 0 || flags & (TH_SYN | TH_FIN | TH_RST))
@


1.18
log
@Make it compile without INET6, from Max Laier, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.17 2003/08/21 19:14:23 frantzen Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.17 2003/08/21 19:14:23 frantzen Exp $ (LBL)";
d573 9
@


1.17
log
@print the operating system of TCP SYN packets with the -o option
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.16 2001/12/23 01:05:15 stevesk Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.16 2001/12/23 01:05:15 stevesk Exp $ (LBL)";
d395 5
a399 1
	if (oflag && ip6 == NULL && (flags & (TH_SYN|TH_ACK)) == TH_SYN) {
@


1.16
log
@integrate a patch i did around 1.5 years ago that's already in
tcpdump.org and netbsd.  if verbose and TCP RST segment with payload,
print the payload string.  Mentat derived stacks may put text strings
in RST segments.  ok jakob@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.15 2001/06/25 19:56:11 itojun Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.15 2001/06/25 19:56:11 itojun Exp $ (LBL)";
d31 1
d39 2
d391 33
@


1.15
log
@disable smb decoder, as there seems to be fewer bound checks than needed
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.14 2000/12/07 22:36:46 mickey Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.14 2000/12/07 22:36:46 mickey Exp $ (LBL)";
d56 4
d569 6
a574 2
	if (sport == BGP_PORT || dport == BGP_PORT)
		bgp_print(bp, length);
d576 2
a577 2
	else if (sport == NETBIOS_SSN_PORT || dport == NETBIOS_SSN_PORT)
		nbt_tcp_print(bp, length);
d579 1
d592 36
@


1.14
log
@smb printing; from Andrew Tridgell; via tcpdump.org
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.13 2000/12/05 08:17:45 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.13 2000/12/05 08:17:45 jakob Exp $ (LBL)";
d567 1
d570 1
@


1.13
log
@tcpdump incorrectly print port numbers when parsing NFS (PR#1540)
fix submitted by Grigoriy Orlov <gluk@@ptci.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: print-tcp.c,v 1.12 2000/10/03 14:21:56 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.12 2000/10/03 14:21:56 ho Exp $ (LBL)";
d122 5
a563 3
#ifndef BGP_PORT
#define BGP_PORT	179
#endif
d567 2
@


1.12
log
@Compile with -Wall. Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.11 2000/04/26 21:35:43 jakob Exp $ (LBL)";
a207 20
	/*
	 * If data present and NFS port used, assume NFS.
	 * Pass offset of data plus 4 bytes for RPC TCP msg length
	 * to NFS print routines.
	 */
	if (!qflag) {
		u_int len = length - hlen;
		if ((u_char *)tp + 4 + sizeof(struct rpc_msg) <= snapend &&
		    dport == NFS_PORT) {
			nfsreq_print((u_char *)tp + hlen + 4, len,
				     (u_char *)ip);
			return;
		}
		else if ((u_char *)tp + 4 + sizeof(struct rpc_msg) <= snapend &&
		    sport == NFS_PORT) {
			nfsreply_print((u_char *)tp + hlen + 4, len,
				       (u_char *)ip);
			return;
		}
	}
d239 18
@


1.11
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.10 2000/01/16 11:43:58 jakob Exp $ (LBL)";
d177 2
a178 2
	register struct tcp_seq_hash *th;
	register int rev;
d480 1
a480 1
					(void) printf("{%u:%u} ", s, e);
@


1.10
log
@BGP support (from KAME/WIDE). INET6 parts not done yet.
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.9 1999/11/26 18:16:55 provos Exp $ (LBL)";
d37 2
d44 4
d52 2
d96 1
d99 4
d120 45
a164 1
#define NETBIOS_SSN_PORT 139
d177 5
a181 2
	u_short sport, dport, win, urp;
	u_int32_t seq, ack;
d185 6
d204 22
d227 26
a252 3
	(void)printf("%s.%s > %s.%s: ",
		ipaddr_string(&ip->ip_src), tcpport_string(sport),
		ipaddr_string(&ip->ip_dst), tcpport_string(dport));
d283 43
d337 1
d370 12
d384 2
a385 1
		(void)printf(" %u:%u(%d)", seq, seq + length, length);
@


1.9
log
@fix error where SACKs were not printed with absolute sequence numbers
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.8 1999/09/16 17:59:50 brad Exp $ (LBL)";
d384 13
@


1.8
log
@add braces to avoid ambiguous else
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.7 1999/07/28 20:41:36 jakob Exp $ (LBL)";
d309 1
a310 1
					}
@


1.7
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.6 1998/09/22 22:03:01 provos Exp $ (LBL)";
d301 1
a301 1
					if (!Sflag)
d310 1
@


1.6
log
@make tcpdump aware of SACK (RFC 2018), loosely based on a patch from
hari@@cs.berkeley.edu.
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-tcp.c,v 1.5 1996/12/12 16:22:26 bitblt Exp $ (LBL)";
d78 9
d107 1
d147 2
a148 1
	if ((flags = tp->th_flags) & (TH_SYN|TH_FIN|TH_RST|TH_PUSH)) {
d157 4
@


1.5
log
@*** empty log message ***
@
text
@d24 1
a24 1
    "@@(#) $Header: print-tcp.c,v 1.52 96/12/03 10:59:55 vern Exp $ (LBL)";
d51 1
a51 1
#define	TCPOPT_SACKOK		4	/* selective ack ok (rfc1072) */
d54 4
a57 1
#define	TCPOPT_SACK		5	/* selective ack (rfc1072) */
d108 2
a149 2
		register struct tcp_seq_hash *th;
		register int rev;
d266 2
d271 3
a273 1
				(void)printf("sack");
d275 20
a294 6
				for (i = 0; i < datalen; i += 4) {
					LENCHECK(i + 4);
					/* block-size@@relative-origin */
					(void)printf(" %u@@%u",
					    EXTRACT_16BITS(cp + i + 2),
					    EXTRACT_16BITS(cp + i));
a295 2
				if (datalen % 4)
					(void)printf("[len %d]", len);
d297 1
a297 1

@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d23 2
a24 2
static char rcsid[] =
    "@@(#) Header: print-tcp.c,v 1.40 96/06/24 15:29:37 leres Exp (LBL)";
a28 1
#include <sys/types.h>
d46 1
a74 1

d97 1
a97 1
tcp_print(register const u_char *bp, register int length,
d104 1
d110 3
a112 5
	if ((const u_char *)(tp + 1) > snapend) {
		printf("[|tcp]");
		return;
	}
	if (length < sizeof(struct tcphdr)) {
d176 1
a176 1
					calloc(1, sizeof (*th));
d193 4
d210 3
a212 4
	if ((hlen -= sizeof(struct tcphdr)) > 0) {
		register const u_char *cp = (const u_char *)tp + sizeof(*tp);
		int i, opt, len, datalen;
		char ch = '<';
d214 1
d216 2
a217 1
		while (--hlen >= 0) {
d219 1
a219 2
			if (cp > snapend)
				goto trunc;
d224 5
a228 4
				if (cp > snapend)
					goto trunc;
				len = *cp++;
				--hlen;
d230 1
d232 4
d241 2
a242 3
				if (cp + datalen > snapend)
					goto trunc;
				(void)printf(" %u", EXTRACT_SHORT(cp));
d257 1
a257 2
				if (cp + datalen > snapend)
					goto trunc;
d268 2
a269 4
				i = datalen;
				for (i = datalen; i > 0; i -= 4) {
					if (cp + i + 4 > snapend)
						goto trunc;
d272 2
a273 2
					    EXTRACT_SHORT(cp + 2),
					    EXTRACT_SHORT(cp));
d282 2
a283 3
				if (cp + datalen > snapend)
					goto trunc;
				(void)printf(" %u", EXTRACT_LONG(cp));
d289 2
a290 3
				if (cp + datalen > snapend)
					goto trunc;
				(void)printf(" %u", EXTRACT_LONG(cp));
d295 5
a299 8
				datalen = 4;
				if (cp + datalen > snapend)
					goto trunc;
				(void)printf(" %u", EXTRACT_LONG(cp));
				datalen += 4;
				if (cp + datalen > snapend)
					goto trunc;
				(void)printf(" %u", EXTRACT_LONG(cp + 4));
d305 2
a306 3
				if (cp + datalen > snapend)
					goto trunc;
				(void)printf(" %u", EXTRACT_LONG(cp));
d312 2
a313 3
				if (cp + datalen > snapend)
					goto trunc;
				(void)printf(" %u", EXTRACT_LONG(cp));
d319 2
a320 3
				if (cp + datalen > snapend)
					goto trunc;
				(void)printf(" %u", EXTRACT_LONG(cp));
d327 1
a327 2
					if (cp + i > snapend)
						goto trunc;
d344 2
d350 5
d356 3
a358 1
	(void)printf("[|tcp]>");
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-tcp.c,v 1.6.4.1 1996/05/26 18:36:15 fvdl Exp $	*/
/*	$NetBSD: print-tcp.c,v 1.6.4.1 1996/05/26 18:36:15 fvdl Exp $	*/
d4 1
a4 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
d26 1
a26 1
    "@@(#) Header: print-tcp.c,v 1.28 94/06/16 01:26:40 mccanne Exp (LBL)";
a39 2
#include <rpc/rpc.h>

a40 1
#ifdef __STDC__
d42 1
a42 1
#endif
d47 1
a47 2

#include "nfs.h"
d67 10
d93 3
d108 1
a108 1
	tcp_seq seq, ack;
d112 1
a112 1
	if ((const u_char *)(tp + 1)  > snapend) {
a126 23
	hlen = tp->th_off * 4;
	length -= hlen;

	/*
	 * If data present and NFS port used, assume NFS.
	 * Pass offset of data plus 4 bytes for RPC TCP msg length
	 * to NFS print routines.
	 */
	if (!qflag) {
		if ((u_char *)tp + 4 + sizeof(struct rpc_msg) <= snapend &&
		    dport == NFS_PORT) {
			nfsreq_print((u_char *)tp + hlen + 4, length,
				     (u_char *)ip);
			return;
		}
		else if ((u_char *)tp + 4 + sizeof(struct rpc_msg) <= snapend &&
		    sport == NFS_PORT) {
			nfsreply_print((u_char *)tp + hlen + 4, length,
				       (u_char *)ip);
			return;
		}
	}

d133 1
a133 1
		(void)printf("tcp %d", length);
d172 1
a172 1
			if (!bcmp((char *)&tha, (char *)&th->addr,
d178 1
a178 1
			if (!th->nxt)
d181 3
d196 2
d199 1
a199 1
		(void)printf(" %lu:%lu(%d)", seq, seq + length, length);
d212 1
a212 1
		int i;
d218 14
a231 1
			switch (*cp++) {
d233 6
a238 6
			{
				(void)printf("mss %d", cp[1] << 8 | cp[2]);
				if (*cp != 4)
					(void)printf("[len %d]", *cp);
				cp += 3;
				hlen -= 3;
d240 1
a240 1
			}
d244 1
d248 1
d250 5
a254 5
				(void)printf("wscale %d", cp[1]);
				if (*cp != 3)
					(void)printf("[len %d]", *cp);
				cp += 2;
				hlen -= 2;
d256 1
a258 4
				if (*cp != 2)
					(void)printf("[len %d]", *cp);
				cp += 1;
				hlen -= 1;
d260 17
d278 5
a282 8
			{
				(void)printf("echo %u",
					     cp[1] << 24 | cp[2] << 16 |
					     cp[3] << 8 | cp[4]);
				if (*cp != 6)
					(void)printf("[len %d]", *cp);
				cp += 5;
				hlen -= 5;
d284 1
a284 1
			}
d286 5
a290 8
			{
				(void)printf("echoreply %u",
					     cp[1] << 24 | cp[2] << 16 |
					     cp[3] << 8 | cp[4]);
				if (*cp != 6)
					(void)printf("[len %d]", *cp);
				cp += 5;
				hlen -= 5;
d292 1
a292 1
			}
d294 33
a326 10
			{
				(void)printf("timestamp %lu %lu",
					     cp[1] << 24 | cp[2] << 16 |
					     cp[3] << 8 | cp[4],
					     cp[5] << 24 | cp[6] << 16 |
					     cp[7] << 8 | cp[8]);
				if (*cp != 10)
					(void)printf("[len %d]", *cp);
				cp += 9;
				hlen -= 9;
d328 1
a328 1
  			}
d330 7
a336 3
				(void)printf("opt-%d:", cp[-1]);
				for (i = *cp++ - 2, hlen -= i + 1; i > 0; --i)
					(void)printf("%02x", *cp++);
d339 11
d354 3
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: print-tcp.c,v 1.5 1995/03/06 19:11:33 mycroft Exp $	*/
d41 2
d52 2
d100 1
a100 1
	u_int32 seq, ack;
d119 23
d148 1
a148 1
		(void)printf("tcp %d", length - tp->th_off * 4);
a207 2
	hlen = tp->th_off * 4;
	length -= hlen;
d209 1
a209 1
		(void)printf(" %u:%u(%d)", seq, seq + length, length);
@


1.1
log
@Initial revision
@
text
@d1 1
d96 1
a96 1
	tcp_seq seq, ack;
d184 1
a184 1
		(void)printf(" %lu:%lu(%d)", seq, seq + length, length);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
