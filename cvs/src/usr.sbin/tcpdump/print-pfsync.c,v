head	1.43;
access;
symbols
	OPENBSD_6_2:1.43.0.6
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.41.0.6
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.38.0.10
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.8
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.4
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.37.0.12
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.10
	OPENBSD_5_0:1.37.0.8
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.6
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.32.0.4
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.6
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.4
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7;
locks; strict;
comment	@ * @;


1.43
date	2017.01.20.09.36.42;	author claudio;	state Exp;
branches;
next	1.42;
commitid	naLhupjHh2Zg0ocS;

1.42
date	2016.10.27.13.55.21;	author millert;	state Exp;
branches;
next	1.41;
commitid	QUfZgt2LPMx9lTMn;

1.41
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.40;
commitid	enjTsnD5UO6xazKc;

1.40
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	Uu5nFG3wCl0LACBb;

1.39
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.38;
commitid	yLXrOcgrag4eS8u4;

1.38
date	2012.09.19.13.50.36;	author mikeb;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.09.09.54.16;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.31.01.21.29;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2009.02.23.10.28.16;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.16.00.31.25;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.21.08.42.00;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.31.04.16.26;	author mcbride;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.04.08.24.15;	author mcbride;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.28.15.10.07;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.07.23.48.40;	author mcbride;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.22.08.13.10;	author mcbride;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.20.20.03.05;	author mcbride;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.10.20.26.50;	author mcbride;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.10.09.21.55;	author mcbride;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.21.12.49.18;	author mcbride;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.21.06.15.18;	author mcbride;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.04.00.29.14;	author pvalchev;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.31.11.18.25;	author cedric;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.28.21.06.46;	author mcbride;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.28.17.18.58;	author mcbride;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.27.19.50.47;	author mcbride;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.19.23.13.08;	author mcbride;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.19.22.35.57;	author mcbride;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.15.07.11.31;	author mcbride;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.08.19.51.38;	author dhartmei;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.08.06.46.44;	author mcbride;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.05.00.44.10;	author mcbride;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.02.16.20.03;	author mcbride;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.21.09.07.00;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.07.00.28.08;	author dhartmei;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.04.01.13.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.23.18.55.53;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.20.22.25.59;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.30.13.56.23;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.30.00.20.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.29.18.27.54;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Another ip_ipsp.h missing, found by krw@@
@
text
@/*	$OpenBSD: print-pfsync.c,v 1.42 2016/10/27 13:55:21 millert Exp $	*/

/*
 * Copyright (c) 2002 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/time.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/ioctl.h>

#ifdef __STDC__
struct rtentry;
#endif
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_ipsp.h>

#include <net/pfvar.h>
#include <net/if_pfsync.h>

#include <ctype.h>
#include <netdb.h>
#include <pcap.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <vis.h>

#include "interface.h"
#include "addrtoname.h"
#include "pfctl_parser.h"
#include "pfctl.h"

void	pfsync_print(struct pfsync_header *, const u_char *, int);

void
pfsync_if_print(u_char *user, const struct pcap_pkthdr *h,
     const u_char *p)
{
	u_int caplen = h->caplen;

	ts_print(&h->ts);

	if (caplen < PFSYNC_HDRLEN) {
		printf("[|pfsync]");
		goto out;
	}

	pfsync_print((struct pfsync_header *)p,
	    p + sizeof(struct pfsync_header),
	    caplen - sizeof(struct pfsync_header));
out:
	if (xflag) {
		default_print((const u_char *)p, caplen);
	}
	putchar('\n');
}

void
pfsync_ip_print(const u_char *bp, u_int len, const u_char *bp2)
{
	struct pfsync_header *hdr = (struct pfsync_header *)bp;
	struct ip *ip = (struct ip *)bp2;

	if (vflag)
		printf("%s > %s: ", ipaddr_string(&ip->ip_src),
		    ipaddr_string(&ip->ip_dst));
	else
		printf("%s: ", ipaddr_string(&ip->ip_src));

	if (len < PFSYNC_HDRLEN)
		printf("[|pfsync]");
	else
		pfsync_print(hdr, bp + sizeof(struct pfsync_header),
		    len - sizeof(struct pfsync_header));
	putchar('\n');
}

const char *actnames[] = { PFSYNC_ACTIONS };

struct pfsync_actions {
	size_t len;
	int (*print)(int, const void *);
};

int	pfsync_print_clr(int, const void *);
int	pfsync_print_state(int, const void *);
int	pfsync_print_ins_ack(int, const void *);
int	pfsync_print_upd_c(int, const void *);
int	pfsync_print_upd_req(int, const void *);
int	pfsync_print_del_c(int, const void *);
int	pfsync_print_bus(int, const void *);
int	pfsync_print_tdb(int, const void *);
int	pfsync_print_eof(int, const void *);

struct pfsync_actions actions[] = {
	{ sizeof(struct pfsync_clr),		pfsync_print_clr },
	{ 0,					NULL },
	{ sizeof(struct pfsync_ins_ack),	pfsync_print_ins_ack },
	{ 0,					NULL },
	{ sizeof(struct pfsync_upd_c),		pfsync_print_upd_c },
	{ sizeof(struct pfsync_upd_req),	pfsync_print_upd_req },
	{ sizeof(struct pfsync_state),		pfsync_print_state },
	{ sizeof(struct pfsync_del_c),		pfsync_print_del_c },
	{ 0,					NULL },
	{ 0,					NULL },
	{ sizeof(struct pfsync_bus),		pfsync_print_bus },
	{ 0,					NULL },
	{ 0,					pfsync_print_eof },
	{ sizeof(struct pfsync_state),		pfsync_print_state },
	{ sizeof(struct pfsync_state),		pfsync_print_state },
	{ sizeof(struct pfsync_tdb),		pfsync_print_tdb },
};

void
pfsync_print(struct pfsync_header *hdr, const u_char *bp, int len)
{
	struct pfsync_subheader *subh;
	int count, plen, alen, flags = 0;
	int i;

	plen = ntohs(hdr->len);

	printf("PFSYNCv%d len %d", hdr->version, plen);

	if (hdr->version != PFSYNC_VERSION)
		return;

	plen -= sizeof(*hdr);

	if (vflag)
		flags |= PF_OPT_VERBOSE;
	if (vflag > 1)
		flags |= PF_OPT_VERBOSE2;
	if (!nflag)
		flags |= PF_OPT_USEDNS;

	while (plen > 0) {
		if (len < sizeof(*subh))
			break;

		subh = (struct pfsync_subheader *)bp;
		bp += sizeof(*subh);
		len -= sizeof(*subh);
		plen -= sizeof(*subh);

		if (subh->action >= PFSYNC_ACT_MAX) {
			printf("\n    act UNKNOWN id %d", subh->action);
			return;
		}

		count = ntohs(subh->count);
		printf("\n    act %s count %d", actnames[subh->action], count);
		alen = actions[subh->action].len;

		if (actions[subh->action].print == NULL) {
			printf("\n    unimplemented action");
			return;
		}

		for (i = 0; i < count; i++) {
			if (len < alen) {
				len = 0;
				break;
			}

			if (actions[subh->action].print(flags, bp) != 0)
				return;

			bp += alen;
			len -= alen;
			plen -= alen;
		}
	}

	if (plen > 0) {
		printf("\n    ...");
		return;
	}
	if (plen < 0) {
		printf("\n    invalid header length");
		return;
	}
	if (len > 0)
		printf("\n    invalid packet length");
}

int
pfsync_print_clr(int flags, const void *bp)
{
	const struct pfsync_clr *clr = bp;
	char ifname[IFNAMSIZ * 4 + 1];
	char *cp = ifname;
	int i;

	printf("\n\tcreatorid: %08x", htonl(clr->creatorid));
	if (clr->ifname[0] != '\0') {
		/* Treat clr->ifname as untrusted input. */
		for (i = 0; i < IFNAMSIZ && clr->ifname[i] != '\0'; i++)
			cp = vis(cp, clr->ifname[i], VIS_WHITE, 0);
		printf(" interface: %s", ifname);
	}

	return (0);
}

int
pfsync_print_state(int flags, const void *bp)
{
	struct pfsync_state *st = (struct pfsync_state *)bp;
	putchar('\n');
	print_state(st, flags);
	return (0);
}

int
pfsync_print_ins_ack(int flags, const void *bp)
{
	const struct pfsync_ins_ack *iack = bp;

	printf("\n\tid: %016llx creatorid: %08x", betoh64(iack->id),
	    ntohl(iack->creatorid));

	return (0);
}

int
pfsync_print_upd_c(int flags, const void *bp)
{
	const struct pfsync_upd_c *u = bp;

	printf("\n\tid: %016llx creatorid: %08x", betoh64(u->id),
	    ntohl(u->creatorid));

	return (0);
}

int
pfsync_print_upd_req(int flags, const void *bp)
{
	const struct pfsync_upd_req *ur = bp;

	printf("\n\tid: %016llx creatorid: %08x", betoh64(ur->id),
	    ntohl(ur->creatorid));

	return (0);
}

int
pfsync_print_del_c(int flags, const void *bp)
{
	const struct pfsync_del_c *d = bp;

	printf("\n\tid: %016llx creatorid: %08x", betoh64(d->id),
	    ntohl(d->creatorid));

	return (0);
}

int
pfsync_print_bus(int flags, const void *bp)
{
	const struct pfsync_bus *b = bp;
	u_int32_t endtime;
	int min, sec;
	const char *status;

	endtime = ntohl(b->endtime);
	sec = endtime % 60;
	endtime /= 60;
	min = endtime % 60;
	endtime /= 60;

	switch (b->status) {
	case PFSYNC_BUS_START:
		status = "start";
		break;
	case PFSYNC_BUS_END:
		status = "end";
		break;
	default:
		status = "UNKNOWN";
		break;
	}

	printf("\n\tcreatorid: %08x age: %.2u:%.2u:%.2u status: %s",
	    htonl(b->creatorid), endtime, min, sec, status);

	return (0);
}

int
pfsync_print_tdb(int flags, const void *bp)
{
	const struct pfsync_tdb *t = bp;

	printf("\n\tspi: 0x%08x rpl: %llu cur_bytes: %llu",
	    ntohl(t->spi), betoh64(t->rpl), betoh64(t->cur_bytes));

	return (0);
}

int
pfsync_print_eof(int flags, const void *bp)
{
	return (1);
}
@


1.42
log
@Don't assume clr->ifname is a NUL-terminated printable string.
Use vis(3) to safely print ifname and stop at IFNAMSIZ bytes.
Found with afl by jsg@@.  OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.41 2015/11/16 00:16:39 mmcc Exp $	*/
d41 1
@


1.41
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.40 2015/01/16 06:40:21 deraadt Exp $	*/
d51 1
d216 3
d221 6
a226 2
	if (clr->ifname[0] != '\0')
		printf(" interface: %s", clr->ifname);
@


1.40
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.39 2014/08/14 12:44:44 mpi Exp $	*/
d61 1
a61 1
     register const u_char *p)
@


1.39
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.38 2012/09/19 13:50:36 mikeb Exp $	*/
a28 1
#include <sys/param.h>
a32 1
#include <sys/mbuf.h>
@


1.38
log
@replay counter was bumped a while ago, update byte order conversion;
while here, improve the way information is printed out a bit.
with input and ok camield, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.37 2009/11/09 09:54:16 dlg Exp $	*/
a41 1
#include <netinet/in_systm.h>
@


1.37
log
@the new protocol moved insert and update.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.36 2009/10/27 23:59:55 deraadt Exp $	*/
d134 1
a134 1
	{ sizeof(struct pfsync_tdb),		pfsync_print_tdb },
d137 2
a138 1
	{ sizeof(struct pfsync_state),		pfsync_print_state }
d316 2
a317 2
	printf("\n\tspi: %08x rpl: %u cur_bytes: %llu",
	    htonl(t->spi), htonl(t->rpl), betoh64(t->cur_bytes));
@


1.36
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.35 2009/03/31 01:21:29 dlg Exp $	*/
d124 1
a124 1
	{ sizeof(struct pfsync_state),		pfsync_print_state },
d126 1
a126 1
	{ sizeof(struct pfsync_state),		pfsync_print_state },
d135 3
a137 1
	{ 0,					pfsync_print_eof }
@


1.35
log
@do not include space in the end of the from for a hmac. after discussion
with deraadt@@, mcbride@@, and mpf@@ it is obvious that a hmac doesnt make
sense for pfsync.

this also firms up some of the input parsing so it handles short frames a
bit better.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.32 2007/10/07 16:41:05 deraadt Exp $	*/
a27 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id: print-pfsync.c,v 1.34 2009/02/23 10:28:16 dlg Exp $";
#endif
@


1.34
log
@better detect short frames. always print the version and length of the
frame according to the pfsync header. dont try to parse an unsupported
version of the protocol.
@
text
@d31 1
a31 1
    "@@(#) $Id: print-pfsync.c,v 1.33 2009/02/16 00:31:25 dlg Exp $";
d140 1
a140 1
	{ sizeof(struct pfsync_eof),		pfsync_print_eof }
d184 1
a184 1
		if (alen == 0) {
d327 1
a327 8
	const struct pfsync_eof *eof = bp;
	int i;

	printf("\n\thmac: ");
	for (i = 0; i < sizeof(eof->hmac); i++)
		printf("%02x", eof->hmac[i]);

	return (0);
@


1.33
log
@pfsync v5, mostly written at n2k9, but based on work done at n2k8.

WARNING: THIS BREAKS COMPATIBILITY WITH THE PREVIOUS VERSION OF PFSYNC

this is a new variant of the protocol and a large reworking of the
pfsync code to address some performance issues. the single largest
benefit comes from having multiple pfsync messages of different
types handled in a single packet. pfsyncs handling of pf states is
highly optimised now, along with packet parsing and construction.

huggz for beck@@ for testing.
huge thanks to mcbride@@ for his help during development and for
finding all the bugs during the initial tests.
thanks to peter sutton for letting me get credit for this work.

ok beck@@ mcbride@@ "good." deraadt@@
@
text
@d31 1
a31 1
    "@@(#) $Id: print-pfsync.c,v 1.32 2007/10/07 16:41:05 deraadt Exp $";
d152 4
a155 2
	if (eflag)
		printf("PFSYNCv%d len %d", hdr->version, plen);
d190 2
a191 1
			if (alen > len)
d193 1
@


1.32
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.31 2007/09/21 08:42:00 markus Exp $	*/
d31 1
a31 1
    "@@(#) $Id$";
d65 1
a65 3
const char *pfsync_acts[] = { PFSYNC_ACTIONS };

void	pfsync_print(struct pfsync_header *, int);
d81 1
d105 2
a106 1
		pfsync_print(hdr, (len - sizeof(struct pfsync_header)));
d110 33
d144 1
a144 1
pfsync_print(struct pfsync_header *hdr, int len)
d146 5
a150 9
	struct pfsync_state *s;
	struct pfsync_state_upd *u;
	struct pfsync_state_del *d;
	struct pfsync_state_clr *c;
	struct pfsync_state_upd_req *r;
	struct pfsync_state_bus *b;
	struct pfsync_tdb *t;
	int i, flags = 0, min, sec;
	u_int64_t id;
d153 1
a153 2
		printf("PFSYNCv%d count %d: ",
		    hdr->version, hdr->count);
d155 1
a155 4
	if (hdr->action < PFSYNC_ACT_MAX)
		printf("%s:", pfsync_acts[hdr->action]);
	else
		printf("%d?:", hdr->action);
d164 12
a175 7
	switch (hdr->action) {
	case PFSYNC_ACT_CLR:
		if (sizeof(*c) <= len) {
			c = (void *)((char *)hdr + PFSYNC_HDRLEN);
			printf("\n\tcreatorid: %08x", htonl(c->creatorid));
			if (c->ifname[0] != '\0')
				printf(" interface: %s", c->ifname);
d177 8
a184 10
	case PFSYNC_ACT_INS:
	case PFSYNC_ACT_UPD:
	case PFSYNC_ACT_DEL:
		for (i = 1, s = (void *)((char *)hdr + PFSYNC_HDRLEN);
		    i <= hdr->count && i * sizeof(*s) <= len; i++, s++) {

			putchar('\n');
			print_state(s, flags);
			if (vflag > 1 && hdr->action == PFSYNC_ACT_UPD)
				printf(" updates: %d", s->updates);
d186 3
a188 39
		break;
	case PFSYNC_ACT_UPD_C:
		for (i = 1, u = (void *)((char *)hdr + PFSYNC_HDRLEN);
		    i <= hdr->count && i * sizeof(*u) <= len; i++, u++) {
			bcopy(&u->id, &id, sizeof(id));
			printf("\n\tid: %016llx creatorid: %08x",
			    betoh64(id), ntohl(u->creatorid));
			if (vflag > 1)
				printf(" updates: %d", u->updates);
		}
		break;
	case PFSYNC_ACT_DEL_C:
		for (i = 1, d = (void *)((char *)hdr + PFSYNC_HDRLEN);
		    i <= hdr->count && i * sizeof(*d) <= len; i++, d++) {
			bcopy(&d->id, &id, sizeof(id));
			printf("\n\tid: %016llx creatorid: %08x",
			    betoh64(id), ntohl(d->creatorid));
		}
		break;
	case PFSYNC_ACT_UREQ:
		for (i = 1, r = (void *)((char *)hdr + PFSYNC_HDRLEN);
		    i <= hdr->count && i * sizeof(*r) <= len; i++, r++) {
			bcopy(&r->id, &id, sizeof(id));
			printf("\n\tid: %016llx creatorid: %08x",
			    betoh64(id), ntohl(r->creatorid));
		}
		break;
	case PFSYNC_ACT_BUS:
		if (sizeof(*b) <= len) {
			b = (void *)((char *)hdr + PFSYNC_HDRLEN);
			printf("\n\tcreatorid: %08x", htonl(b->creatorid));
			sec = b->endtime % 60;
			b->endtime /= 60;
			min = b->endtime % 60;
			b->endtime /= 60;
			printf(" age %.2u:%.2u:%.2u", b->endtime, min, sec);
			switch (b->status) {
			case PFSYNC_BUS_START:
				printf(" status: start");
d190 7
a196 7
			case PFSYNC_BUS_END:
				printf(" status: end");
				break;
			default:
				printf(" status: ?");
				break;
			}
d198 96
d295 2
a296 7
	case PFSYNC_ACT_TDB_UPD:
		for (i = 1, t = (void *)((char *)hdr + PFSYNC_HDRLEN);
		    i <= hdr->count && i * sizeof(*t) <= len; i++, t++)
			printf("\n\tspi: %08x rpl: %u cur_bytes: %llu",
			    htonl(t->spi), htonl(t->rpl),
			    betoh64(t->cur_bytes));
			/* XXX add dst and sproto? */
d299 1
d302 29
@


1.31
log
@typo: print hexdump of packet, instead of pcap header; ok canacar, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.30 2007/05/31 04:16:26 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.30 2007/05/31 04:16:26 mcbride Exp $";
@


1.30
log
@pf_state is no longer the same; modify pf_print_state.c to accept
pfsync_state (as in pfctl, but in network byte order).

ok henning@@ toby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.29 2005/11/04 08:24:15 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.29 2005/11/04 08:24:15 mcbride Exp $";
d86 1
a86 1
		default_print((const u_char *)h, caplen);
@


1.29
log
@crank pf_state and pf_src_node byte and packet counters to u_in64_t, since
we're breaking pfsync compatibility this cycle anyways.

Requested by djm@@, ok henning@@, 'wheee!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.28 2005/05/28 15:10:07 ho Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.28 2005/05/28 15:10:07 ho Exp $";
a151 28
			struct pf_state st;

			bzero(&st, sizeof(st));
			bcopy(&s->id, &st.id, sizeof(st.id));
			strlcpy(st.u.ifname, s->ifname, sizeof(st.u.ifname));
			pf_state_host_ntoh(&s->lan, &st.lan);
			pf_state_host_ntoh(&s->gwy, &st.gwy);
			pf_state_host_ntoh(&s->ext, &st.ext);
			pf_state_peer_ntoh(&s->src, &st.src);
			pf_state_peer_ntoh(&s->dst, &st.dst);
			st.rule.nr = ntohl(s->rule);
			st.nat_rule.nr = ntohl(s->nat_rule);
			st.anchor.nr = ntohl(s->anchor);
			bcopy(&s->rt_addr, &st.rt_addr, sizeof(st.rt_addr));
			st.creation = ntohl(s->creation);
			st.expire = ntohl(s->expire);
			pf_state_counter_ntoh(s->packets[0], st.packets[0]);
			pf_state_counter_ntoh(s->packets[1], st.packets[1]);
			pf_state_counter_ntoh(s->bytes[0], st.bytes[0]);
			pf_state_counter_ntoh(s->bytes[1], st.bytes[1]);
			st.creatorid = s->creatorid;
			st.af = s->af;
			st.proto = s->proto;
			st.direction = s->direction;
			st.log = s->log;
			st.timeout = s->timeout;
			st.allow_opts = s->allow_opts;
			st.sync_flags = s->sync_flags;
d154 1
a154 1
			print_state(&st, flags);
@


1.28
log
@Add SA replay counter synchronization to pfsync(4). Required for IPsec
failover gateways. ok mcbride@@, "looks good" hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.27 2004/07/07 23:48:40 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.27 2004/07/07 23:48:40 mcbride Exp $";
d168 4
a171 4
			st.packets[0] = ntohl(s->packets[0]);
			st.packets[1] = ntohl(s->packets[1]);
			st.bytes[0] = ntohl(s->bytes[0]);
			st.bytes[1] = ntohl(s->bytes[1]);
@


1.27
log
@Include protocol name in printout.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.26 2004/03/22 08:13:10 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.26 2004/03/22 08:13:10 mcbride Exp $";
d119 1
d234 8
@


1.26
log
@Add support for PFSYNC_ACT_BUS. (Bulk Update Status)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.25 2004/02/20 20:03:05 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.25 2004/02/20 20:03:05 mcbride Exp $";
d123 1
a123 1
		printf("version %d count %d: ",
@


1.25
log
@Print ifname in PFSYNC_ACT_CLR message if present.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.24 2004/02/10 20:26:50 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.24 2004/02/10 20:26:50 mcbride Exp $";
d118 2
a119 1
	int i, flags = 0;
d210 22
@


1.24
log
@Make pfsync printing consistent with rest of tcpdump regarding newlines,
pass -vv in to pf_print_state(), and print update count where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.24 2004/02/10 19:56:45 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.24 2004/02/10 19:56:45 mcbride Exp $";
d142 2
@


1.23
log
@Make pfsync work correctly with IP options on 64-bit alignment
sensitive CPUs. Pointed out by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.22 2004/01/21 12:49:18 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.22 2004/01/21 12:49:18 mcbride Exp $";
a86 1
		putchar('\n');
d88 1
d99 1
a99 1
	 	   ipaddr_string(&ip->ip_dst));
d107 1
d118 1
a118 1
	int i, flags;
d126 1
a126 1
		printf("%s:\n", pfsync_acts[hdr->action]);
d128 1
a128 1
		printf("%d?:\n", hdr->action);
a129 1
	flags = 0;
d141 1
a141 1
			printf("\tcreatorid: %08x\n", htonl(c->creatorid));
d177 1
d179 2
d187 1
a187 1
			printf("\tid: %016llx creatorid: %08x\n",
d189 2
d197 1
a197 1
			printf("\tid: %016llx creatorid: %08x\n",
d205 1
a205 1
			printf("\tid: %016llx creatorid: %08x\n",
@


1.22
log
@Increment the right pointers, so we don't print the same entries repeatedly.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.21 2004/01/21 06:15:18 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.21 2004/01/21 06:15:18 mcbride Exp $";
d118 1
d151 1
a151 1
			st.id = s->id;
d183 1
d185 1
a185 1
			    betoh64(u->id), ntohl(u->creatorid));
d191 1
d193 1
a193 1
			    betoh64(d->id), ntohl(d->creatorid));
d199 1
d201 1
a201 1
			    betoh64(r->id), ntohl(r->creatorid));
@


1.21
log
@Clean up pfsync output: print source address by default, pass -vv correctly
to pf_print_state(), and other minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.20 2004/01/04 00:29:14 pvalchev Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.20 2004/01/04 00:29:14 pvalchev Exp $";
d181 1
a181 1
		    i <= hdr->count && i * sizeof(*u) <= len; i++, d++) {
d195 1
a195 1
		    i <= hdr->count && i * sizeof(*r) <= len; i++, d++) {
@


1.20
log
@zap unused variable; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.19 2003/12/31 11:18:25 cedric Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.19 2003/12/31 11:18:25 cedric Exp $";
d95 7
d131 2
d172 1
d183 1
a183 1
			    betoh64(u->id), htonl(u->creatorid));
d190 1
a190 1
			    betoh64(d->id), htonl(d->creatorid));
d197 1
a197 1
			    betoh64(r->id), htonl(r->creatorid));
@


1.19
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.18 2003/12/28 21:06:46 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.18 2003/12/28 21:06:46 mcbride Exp $";
a93 1
	const struct ip *ip = (const struct ip *)bp2;
@


1.18
log
@Unbreak tree by using correct PFSYNC_ACT_UREQ #define.
Also remove unused hlen variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.17 2003/12/28 17:18:58 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.17 2003/12/28 17:18:58 mcbride Exp $";
d143 1
@


1.17
log
@Add a new PFSYNC_ACT_UREQ message type.

A pfsync system which recieves a partial update for a state it cannot
find can now request a full version of the update, and insert it.
pfsync'd firewalls now converge more gracefully if one is missing some
states (due to reset, lost insert packets, etc).
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.16 2003/12/27 19:50:47 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.16 2003/12/27 19:50:47 mcbride Exp $";
a95 1
	u_int hlen = ip->ip_hl << 2;
d183 1
a183 1
	case PFSYNC_REQ_UPD:
@


1.16
log
@Zero out the pf_state struct before filling it with data from the
pfsync_state struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.15 2003/12/19 23:13:08 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.15 2003/12/19 23:13:08 mcbride Exp $";
d110 2
d130 5
d182 7
@


1.15
log
@Argh. Calculate the length really, really correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.14 2003/12/19 22:35:57 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.14 2003/12/19 22:35:57 mcbride Exp $";
d135 1
@


1.14
log
@Calculate the length of the captured pfsync payload correctly when printing
pfsync packets recieved on the wire. Prevents printing of giberish states
with snaplen smaller than the mtu of syncif on the sender, and probably
other ungoodness.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.13 2003/12/15 07:11:31 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.13 2003/12/15 07:11:31 mcbride Exp $";
d101 1
a101 1
		pfsync_print(hdr, (len - sizeof(struct pfsync_header) - hlen));
@


1.13
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.12 2003/11/08 19:51:38 dhartmei Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.12 2003/11/08 19:51:38 dhartmei Exp $";
d101 1
a101 1
		pfsync_print(hdr, (len - sizeof(struct pfsync_header) + hlen));
@


1.12
log
@Return proper anchor rule number in correct byte order.
From Pyun YongHyeon. ok henning@@, canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.11 2003/11/08 06:46:44 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.11 2003/11/08 06:46:44 mcbride Exp $";
d67 2
a72 1
	/*u_int length = h->len;*/
a73 3
	struct pfsync_header *hdr;
	struct pf_state *s;
	int i, flags;
d82 29
a110 2
	packetp = p;
	snapend = p + caplen;
a111 1
	hdr = (struct pfsync_header *)p;
d127 51
a177 26
	for (i = 1, s = (struct pf_state *)(p + PFSYNC_HDRLEN);
	    i <= hdr->count && PFSYNC_HDRLEN + i * sizeof(*s) <= caplen;
	    i++, s++) {
		struct pf_state st;

		bcopy(&s->lan, &st.lan, sizeof(st.lan));
		bcopy(&s->gwy, &st.gwy, sizeof(st.gwy));
		bcopy(&s->ext, &st.ext, sizeof(st.ext));
		pf_state_peer_ntoh(&s->src, &st.src);
		pf_state_peer_ntoh(&s->dst, &st.dst);
		st.rule.nr = ntohl(s->rule.nr);
		st.anchor.nr = ntohl(s->anchor.nr);
		bcopy(&s->rt_addr, &st.rt_addr, sizeof(st.rt_addr));
		st.creation = ntohl(s->creation);
		st.expire = ntohl(s->expire);
		st.packets[0] = ntohl(s->packets[0]);
		st.packets[1] = ntohl(s->packets[1]);
		st.bytes[0] = ntohl(s->bytes[0]);
		st.bytes[1] = ntohl(s->bytes[1]);
		st.af = s->af;
		st.proto = s->proto;
		st.direction = s->direction;
		st.log = s->log;
		st.allow_opts = s->allow_opts;

		print_state(&st, flags);
a178 4
out:
	if (xflag)
		default_print((const u_char *)hdr, caplen);
	putchar('\n');
@


1.11
log
@Print "|pfsync" if the packet is truncated, not "|pflog".
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.10 2003/11/05 00:44:10 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.10 2003/11/05 00:44:10 mcbride Exp $";
d114 1
@


1.10
log
@Make tcpdump -x work with pfsync.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.9 2003/11/02 16:20:03 mcbride Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.9 2003/11/02 16:20:03 mcbride Exp $";
d80 1
a80 1
		printf("[|pflog]");
@


1.9
log
@- newline before printing first state (so they all line up and the first
   state doesn't wrap)
- No need to print the rule number, that's included in the -v output.

ok dhartmei@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.8 2003/06/21 09:07:00 djm Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.8 2003/06/21 09:07:00 djm Exp $";
d130 2
@


1.8
log
@count packets and bidirectionally on state entries, allowing for fine-grained
traffic reporting w/ pfsync; ok dhartmei@@

Note: ABI change (new fields in struct pf_state), requires a rebuild of
pfctl and tcpdump.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.7 2003/01/07 00:28:08 dhartmei Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.7 2003/01/07 00:28:08 dhartmei Exp $";
d93 1
a93 1
		printf("%s: ", pfsync_acts[hdr->action]);
d95 1
a95 1
		printf("%d?: ", hdr->action);
a125 2

		printf("rule %d ", st.rule.nr);
@


1.7
log
@Remove pfr_unwrap_table workaround, it's no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.6 2003/01/04 01:13:21 deraadt Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.6 2003/01/04 01:13:21 deraadt Exp $";
d117 4
a120 2
		st.packets = ntohl(s->packets);
		st.bytes = ntohl(s->bytes);
@


1.6
log
@workaround until pf fixes this
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.5 2002/12/23 18:55:53 mickey Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.5 2002/12/23 18:55:53 mickey Exp $";
a130 7
}

int
pfr_unwrap_table(struct pfr_table *tbl, struct pf_addr_wrap *wrap,
    int flags)
{
	return -1;
@


1.5
log
@no need to ntohs the ports
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.4 2002/12/20 22:25:59 mickey Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.4 2002/12/20 22:25:59 mickey Exp $";
d63 1
a63 1
#include "pf_print_state.h"
d131 7
@


1.4
log
@use bcopy instead of struct assignment
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.3 2002/11/30 13:56:23 mickey Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.3 2002/11/30 13:56:23 mickey Exp $";
d108 3
a110 3
		bcopy(&s->lan, &st.lan, sizeof(st.lan)); NTOHS(st.lan.port);
		bcopy(&s->gwy, &st.gwy, sizeof(st.gwy)); NTOHS(st.gwy.port);
		bcopy(&s->ext, &st.ext, sizeof(st.ext)); NTOHS(st.ext.port);
@


1.3
log
@pfsync support; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: print-pfsync.c,v 1.1 2002/11/29 18:27:54 mickey Exp $	*/
d31 1
a31 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v 1.1 2002/11/29 18:27:54 mickey Exp $";
d58 1
d108 3
a110 3
		st.lan = s->lan; NTOHS(st.lan.port);
		st.gwy = s->gwy; NTOHS(st.gwy.port);
		st.ext = s->ext; NTOHS(st.ext.port);
d114 1
a114 1
		st.rt_addr = s->rt_addr;
@


1.2
log
@stop breaking the damn tree mickey
@
text
@d1 130
@


1.1
log
@tcpdump support for pfsync; henning@@ ok
@
text
@a0 130
/*	$OpenBSD$	*/

/*
 * Copyright (c) 2002 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef lint
static const char rcsid[] =
    "@@(#) $Header$";
#endif

#include <sys/param.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>

#ifdef __STDC__
struct rtentry;
#endif
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>

#include <net/pfvar.h>
#include <net/if_pfsync.h>

#include <ctype.h>
#include <netdb.h>
#include <pcap.h>
#include <signal.h>
#include <stdio.h>

#include "interface.h"
#include "addrtoname.h"
#include "pfctl_parser.h"
#include "pf_print_state.h"

const char *pfsync_acts[] = { PFSYNC_ACTIONS };

void
pfsync_if_print(u_char *user, const struct pcap_pkthdr *h,
     register const u_char *p)
{
	/*u_int length = h->len;*/
	u_int caplen = h->caplen;
	struct pfsync_header *hdr;
	struct pf_state *s;
	int i, flags;

	ts_print(&h->ts);

	if (caplen < PFSYNC_HDRLEN) {
		printf("[|pflog]");
		goto out;
	}

	packetp = p;
	snapend = p + caplen;

	hdr = (struct pfsync_header *)p;
	if (eflag)
		printf("version %d count %d: ",
		    hdr->version, hdr->count);

	if (hdr->action < PFSYNC_ACT_MAX)
		printf("%s: ", pfsync_acts[hdr->action]);
	else
		printf("%d?: ", hdr->action);

	flags = 0;
	if (vflag)
		flags |= PF_OPT_VERBOSE;
	if (!nflag)
		flags |= PF_OPT_USEDNS;

	for (i = 1, s = (struct pf_state *)(p + PFSYNC_HDRLEN);
	    i <= hdr->count && PFSYNC_HDRLEN + i * sizeof(*s) <= caplen;
	    i++, s++) {
		struct pf_state st;

		st.lan = s->lan; NTOHS(st.lan.port);
		st.gwy = s->gwy; NTOHS(st.gwy.port);
		st.ext = s->ext; NTOHS(st.ext.port);
		pf_state_peer_ntoh(&s->src, &st.src);
		pf_state_peer_ntoh(&s->dst, &st.dst);
		st.rule.nr = ntohl(s->rule.nr);
		st.rt_addr = s->rt_addr;
		st.creation = ntohl(s->creation);
		st.expire = ntohl(s->expire);
		st.packets = ntohl(s->packets);
		st.bytes = ntohl(s->bytes);
		st.af = s->af;
		st.proto = s->proto;
		st.direction = s->direction;
		st.log = s->log;
		st.allow_opts = s->allow_opts;

		printf("rule %d ", st.rule.nr);

		print_state(&st, flags);
	}
out:
	putchar('\n');
}
@

