head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.6.0.22
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.10
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.6
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.30
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.28
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.26
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.24
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.22
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.20
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.18
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.16
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.14
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.12
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.10
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.8
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.8;
commitid	enjTsnD5UO6xazKc;

1.8
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	Uu5nFG3wCl0LACBb;

1.7
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.6;
commitid	yLXrOcgrag4eS8u4;

1.6
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.03.14.31.56;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.26.21.35.40;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	96.12.12.16.22.39;	author bitblt;	state Exp;
branches;
next	1.1;

1.1
date	96.07.13.11.01.19;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@/*	$OpenBSD: print-dvmrp.c,v 1.8 2015/01/16 06:40:21 deraadt Exp $	*/

/*
 * Copyright (c) 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/time.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include "interface.h"
#include "addrtoname.h"

/*
 * DVMRP message types and flag values shamelessly stolen from
 * mrouted/dvmrp.h.
 */
#define DVMRP_PROBE		1	/* for finding neighbors */
#define DVMRP_REPORT		2	/* for reporting some or all routes */
#define DVMRP_ASK_NEIGHBORS	3	/* sent by mapper, asking for a list */
					/*
					 * of this router's neighbors
					 */
#define DVMRP_NEIGHBORS		4	/* response to such a request */
#define DVMRP_ASK_NEIGHBORS2	5	/* as above, want new format reply */
#define DVMRP_NEIGHBORS2	6
#define DVMRP_PRUNE		7	/* prune message */
#define DVMRP_GRAFT		8	/* graft message */
#define DVMRP_GRAFT_ACK		9	/* graft acknowledgement */

/*
 * 'flags' byte values in DVMRP_NEIGHBORS2 reply.
 */
#define DVMRP_NF_TUNNEL		0x01	/* neighbors reached via tunnel */
#define DVMRP_NF_SRCRT		0x02	/* tunnel uses IP source routing */
#define DVMRP_NF_DOWN		0x10	/* kernel state of interface */
#define DVMRP_NF_DISABLED	0x20	/* administratively disabled */
#define DVMRP_NF_QUERIER	0x40	/* I am the subnet's querier */

static void print_probe(const u_char *, const u_char *, u_int);
static void print_report(const u_char *, const u_char *, u_int);
static void print_neighbors(const u_char *, const u_char *, u_int);
static void print_neighbors2(const u_char *, const u_char *, u_int);
static void print_prune(const u_char *, const u_char *, u_int);
static void print_graft(const u_char *, const u_char *, u_int);
static void print_graft_ack(const u_char *, const u_char *, u_int);

static u_int32_t target_level;

void
dvmrp_print(const u_char *bp, u_int len)
{
	const u_char *ep;
	u_char type;

	ep = (const u_char *)snapend;
	if (bp >= ep)
		return;

	type = bp[1];
	bp += 8;
	/*
	 * Skip IGMP header
	 */

	len -= 8;

	switch (type) {

	case DVMRP_PROBE:
		printf(" Probe");
		if (vflag)
			print_probe(bp, ep, len);
		break;

	case DVMRP_REPORT:
		printf(" Report");
		if (vflag)
			print_report(bp, ep, len);
		break;

	case DVMRP_ASK_NEIGHBORS:
		printf(" Ask-neighbors(old)");
		break;

	case DVMRP_NEIGHBORS:
		printf(" Neighbors(old)");
		print_neighbors(bp, ep, len);
		break;

	case DVMRP_ASK_NEIGHBORS2:
		printf(" Ask-neighbors2");
		break;

	case DVMRP_NEIGHBORS2:
		printf(" Neighbors2");
		/*
		 * extract version and capabilities from IGMP group
		 * address field
		 */
		bp -= 4;
		target_level = (bp[0] << 24) | (bp[1] << 16) |
		    (bp[2] << 8) | bp[3];
		bp += 4;
		print_neighbors2(bp, ep, len);
		break;

	case DVMRP_PRUNE:
		printf(" Prune");
		print_prune(bp, ep, len);
		break;

	case DVMRP_GRAFT:
		printf(" Graft");
		print_graft(bp, ep, len);
		break;

	case DVMRP_GRAFT_ACK:
		printf(" Graft-ACK");
		print_graft_ack(bp, ep, len);
		break;

	default:
		printf(" [type %d]", type);
		break;
	}
}

static void
print_report(const u_char *bp, const u_char *ep, u_int len)
{
	u_int32_t mask, origin;
	int metric, i, width, done;

	while (len > 0) {
		if (len < 3) {
			printf(" [|]");
			return;
		}
		mask = (u_int32_t)0xff << 24 | bp[0] << 16 | bp[1] << 8 | bp[2];
		width = 1;
		if (bp[0])
			width = 2;
		if (bp[1])
			width = 3;
		if (bp[2])
			width = 4;

		printf("\n\tMask %s", intoa(htonl(mask)));
		bp += 3;
		len -= 3;
		do {
			if (bp + width + 1 > ep) {
				printf(" [|]");
				return;
			}
			if (len < width + 1) {
				printf("\n\t  [Truncated Report]");
				return;
			}
			origin = 0;
			for (i = 0; i < width; ++i)
				origin = origin << 8 | *bp++;
			for ( ; i < 4; ++i)
				origin <<= 8;

			metric = *bp++;
			done = metric & 0x80;
			metric &= 0x7f;
			printf("\n\t  %s metric %d", intoa(htonl(origin)),
				metric);
			len -= width + 1;
		} while (!done);
	}
}

#define GET_ADDR(to) (memcpy((char *)to, (char *)bp, 4), bp += 4)

static void
print_probe(const u_char *bp, const u_char *ep, u_int len)
{
	u_int32_t genid;
	u_char neighbor[4];

	if ((len < 4) || ((bp + 4) > ep)) {
		/* { (ctags) */
		printf(" [|}");
		return;
	}
	genid = (bp[0] << 24) | (bp[1] << 16) | (bp[2] << 8) | bp[3];
	bp += 4;
	len -= 4;
	printf("\n\tgenid %u", genid);

	while ((len > 0) && (bp < ep)) {
		if ((len < 4) || ((bp + 4) > ep)) {
			printf(" [|]");
			return;
		}
		GET_ADDR(neighbor);
		len -= 4;
		printf("\n\tneighbor %s", ipaddr_string(neighbor));
	}
}

static void
print_neighbors(const u_char *bp, const u_char *ep, u_int len)
{
	u_char laddr[4], neighbor[4];
	u_char metric;
	u_char thresh;
	int ncount;

	while (len > 0 && bp < ep) {
		if (len < 7 || (bp + 7) >= ep) {
			printf(" [|]");
			return;
		}
		GET_ADDR(laddr);
		metric = *bp++;
		thresh = *bp++;
		ncount = *bp++;
		len -= 7;
		while (--ncount >= 0 && (len >= 4) && (bp + 4) < ep) {
			GET_ADDR(neighbor);
			printf(" [%s ->", ipaddr_string(laddr));
			printf(" %s, (%d/%d)]",
				   ipaddr_string(neighbor), metric, thresh);
			len -= 4;
		}
	}
}

static void
print_neighbors2(const u_char *bp, const u_char *ep, u_int len)
{
	u_char laddr[4], neighbor[4];
	u_char metric, thresh, flags;
	int ncount;

	printf(" (v %d.%d):",
	       (int)target_level & 0xff,
	       (int)(target_level >> 8) & 0xff);

	while (len > 0 && bp < ep) {
		if (len < 8 || (bp + 8) >= ep) {
			printf(" [|]");
			return;
		}
		GET_ADDR(laddr);
		metric = *bp++;
		thresh = *bp++;
		flags = *bp++;
		ncount = *bp++;
		len -= 8;
		while (--ncount >= 0 && (len >= 4) && (bp + 4) <= ep) {
			GET_ADDR(neighbor);
			printf(" [%s -> ", ipaddr_string(laddr));
			printf("%s (%d/%d", ipaddr_string(neighbor),
				     metric, thresh);
			if (flags & DVMRP_NF_TUNNEL)
				printf("/tunnel");
			if (flags & DVMRP_NF_SRCRT)
				printf("/srcrt");
			if (flags & DVMRP_NF_QUERIER)
				printf("/querier");
			if (flags & DVMRP_NF_DISABLED)
				printf("/disabled");
			if (flags & DVMRP_NF_DOWN)
				printf("/down");
			printf(")]");
			len -= 4;
		}
		if (ncount != -1) {
			printf(" [|]");
			return;
		}
	}
}

static void
print_prune(const u_char *bp, const u_char *ep, u_int len)
{
	union a {
		u_char b[4];
		u_int32_t i;
	} prune_timer;

	if (len < 12 || (bp + 12) > ep) {
		printf(" [|]");
		return;
	}
	printf(" src %s grp %s", ipaddr_string(bp), ipaddr_string(bp + 4));
	bp += 8;
	GET_ADDR(prune_timer.b);
	printf(" timer %d", (int)ntohl(prune_timer.i));
}

static void
print_graft(const u_char *bp, const u_char *ep, u_int len)
{

	if (len < 8 || (bp + 8) > ep) {
		printf(" [|]");
		return;
	}
	printf(" src %s grp %s", ipaddr_string(bp), ipaddr_string(bp + 4));
}

static void
print_graft_ack(const u_char *bp, const u_char *ep, u_int len)
{

	if (len < 8 || (bp + 8) > ep) {
		printf(" [|]");
		return;
	}
	printf(" src %s grp %s", ipaddr_string(bp), ipaddr_string(bp + 4));
}
@


1.8
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-dvmrp.c,v 1.7 2014/08/14 12:44:44 mpi Exp $	*/
d79 1
a79 1
dvmrp_print(register const u_char *bp, register u_int len)
d81 2
a82 2
	register const u_char *ep;
	register u_char type;
d158 1
a158 2
print_report(register const u_char *bp, register const u_char *ep,
    register u_int len)
d160 2
a161 2
	register u_int32_t mask, origin;
	register int metric, i, width, done;
d208 1
a208 2
print_probe(register const u_char *bp, register const u_char *ep,
    register u_int len)
d210 1
a210 1
	register u_int32_t genid;
d235 1
a235 2
print_neighbors(register const u_char *bp, register const u_char *ep,
    register u_int len)
d238 3
a240 3
	register u_char metric;
	register u_char thresh;
	register int ncount;
d263 1
a263 2
print_neighbors2(register const u_char *bp, register const u_char *ep,
    register u_int len)
d266 2
a267 2
	register u_char metric, thresh, flags;
	register int ncount;
d310 1
a310 2
print_prune(register const u_char *bp, register const u_char *ep,
    register u_int len)
d328 1
a328 2
print_graft(register const u_char *bp, register const u_char *ep,
    register u_int len)
d339 1
a339 2
print_graft_ack(register const u_char *bp, register const u_char *ep,
    register u_int len)
@


1.7
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-dvmrp.c,v 1.6 2009/10/27 23:59:55 deraadt Exp $	*/
a23 1
#include <sys/param.h>
@


1.6
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-dvmrp.c,v 1.5 2007/10/07 16:41:05 deraadt Exp $	*/
a28 1
#include <netinet/in_systm.h>
@


1.5
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-dvmrp.c,v 1.4 2000/10/03 14:31:56 ho Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.4
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-dvmrp.c,v 1.3 2000/04/26 21:35:40 jakob Exp $ (LBL)";
@


1.3
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-dvmrp.c,v 1.2 1996/12/12 16:22:39 bitblt Exp $ (LBL)";
@


1.2
log
@*** empty log message ***
@
text
@d24 1
a24 1
    "@@(#) $Header: print-dvmrp.c,v 1.13 96/12/10 23:16:30 leres Exp $ (LBL)";
a37 1
#include <netinet/tcpip.h>
@


1.1
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d23 2
a24 2
static char rcsid[] =
"@@(#) Header: print-dvmrp.c,v 1.7 96/06/03 02:52:39 leres Exp (LBL)";
a28 1
#include <sys/types.h>
d74 7
a80 6
static void print_report(const u_char *, const u_char *, int);
static void print_neighbors(const u_char *, const u_char *, int);
static void print_neighbors2(const u_char *, const u_char *, int);
static void print_prune(const u_char *, const u_char *, int);
static void print_graft(const u_char *, const u_char *, int);
static void print_graft_ack(const u_char *, const u_char *, int);
d85 1
a85 1
dvmrp_print(register const u_char *bp, register int len)
d103 1
d106 2
d126 1
a126 1
		printf(" Ask-neighbors");
d130 1
a130 3
		printf(" Neighbors");
		bp -= 4;
		target_level = ((u_int32_t) * bp++ << 24);
d132 2
a133 1
		 * Group address in IGMP
d135 4
a138 9

		target_level += ((u_int32_t) * bp++ << 16);
		/*
		 * header is version number
		 */

		target_level += ((u_int32_t) * bp++ << 8);
		target_level += ((u_int32_t) * bp++);
		target_level = htonl(target_level);
d164 2
a165 1
print_report(const u_char *bp, const u_char *ep, int len)
d167 2
a168 5
	u_int32_t mask, origin;
	int metric;
	int i;
	int width;
	int done;
d175 1
a175 1
		mask = 0xff << 24 | bp[0] << 16 | bp[1] << 8 | bp[2];
d212 29
a240 1
#define GET_ADDR(to) (memcpy((char*)to, (char*)bp, 4), bp += 4)
d243 2
a244 1
print_neighbors(const u_char *bp, const u_char *ep, int len)
d247 3
a249 4
	u_char metric;
	u_char thresh;
	u_char save_nflag;
	int ncount;
a250 1
	save_nflag = nflag;
a262 1
			nflag = 0;
a263 1
			nflag = save_nflag;
d272 2
a273 1
print_neighbors2(const u_char *bp, const u_char *ep, int len)
d276 2
a277 5
	u_char metric;
	u_char thresh;
	u_char flags;
	u_char save_nflag;
	int ncount;
a282 1
	save_nflag = nflag;
d294 1
a294 1
		while (--ncount >= 0 && (len >= 4) && (bp + 4) < ep) {
a295 1
			nflag = 0;
a296 1
			nflag = save_nflag;
d320 2
a321 1
print_prune(const u_char *bp, const u_char *ep, int len)
d328 1
a328 1
	if (len < 12 || (bp + 12) >= ep) {
d339 2
a340 1
print_graft(const u_char *bp, const u_char *ep, int len)
d343 1
a343 1
	if (len < 8 || (bp + 8) >= ep) {
d351 2
a352 1
print_graft_ack(const u_char *bp, const u_char *ep, int len)
d355 1
a355 1
	if (len < 8 || (bp + 8) >= ep) {
@
