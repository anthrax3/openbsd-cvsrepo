head	1.47;
access;
symbols
	OPENBSD_6_2:1.47.0.2
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.44.0.4
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.43.0.2
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.30.0.14
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.12
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.8
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.6
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.8
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.6
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.25.0.6
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.47
date	2017.09.08.19.30.13;	author brynet;	state Exp;
branches;
next	1.46;
commitid	ziEQYN8P0UPCo62T;

1.46
date	2017.09.08.19.10.57;	author brynet;	state Exp;
branches;
next	1.45;
commitid	Zjq9j60IOf1zHWPz;

1.45
date	2017.06.14.20.48.54;	author akfaew;	state Exp;
branches;
next	1.44;
commitid	npjVE26BsZCc6eQP;

1.44
date	2017.01.23.04.25.05;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	NeJrtXDNhZqhGXfa;

1.43
date	2016.07.25.02.35.26;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	AOLMYJDaV8HzupnW;

1.42
date	2016.07.24.22.46.32;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	mTQu7YLPHT24Eh4N;

1.41
date	2016.07.21.07.22.38;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	6DXahMtdo98nP14o;

1.40
date	2015.12.05.19.27.17;	author mmcc;	state Exp;
branches;
next	1.39;
commitid	TVavcVNnqOmKxdg3;

1.39
date	2015.11.03.05.04.06;	author mmcc;	state Exp;
branches;
next	1.38;
commitid	giHXoDpjLMPr6jsH;

1.38
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	sbrB3Q5CNxcwZpfU;

1.37
date	2015.10.06.15.39.44;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Ytytyuwcp2O4NL3A;

1.36
date	2015.10.03.00.51.08;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	YbgJcqz31YZWm8nH;

1.35
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Zx2k82IzYwwZaEz9;

1.34
date	2015.07.14.20.23.40;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	KnDOzicNjGqmISR3;

1.33
date	2015.03.15.00.41.28;	author millert;	state Exp;
branches;
next	1.32;
commitid	IbVxlqGw2UipKdDr;

1.32
date	2015.01.20.18.26.58;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	qRSGCXxt7yQIBAcS;

1.31
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	Uu5nFG3wCl0LACBb;

1.30
date	2011.09.22.09.12.30;	author stsp;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.03.21.11.27;	author stsp;	state Exp;
branches;
next	1.28;

1.28
date	2009.04.17.22.31.24;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.18.21.35.11;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.27.16.22.14;	author martynas;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.22.19.26.05;	author moritz;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.22.17.24.33;	author moritz;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.21.23.09.34;	author cloder;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.23.15.42.51;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.23.06.56.42;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.22.19.53.33;	author moritz;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.22.18.41.33;	author moritz;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.03.01.01.14;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.20.20.57.07;	author moritz;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.10.19.59.02;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.10.16.10.37;	author moritz;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.26.18.39.10;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.25.13.45.30;	author moritz;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.06.18.44.50;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.14.19.07.03;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.09.19.21.55;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.15.13.13.05;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.23.06.00.50;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.08.12.24.07;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.03.10.20.51;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.14.19.17.05;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.05.22.12.06;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.04.09.47.10;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.31.15.13.03;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.19.44.55;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Whoops, remove extra include.
@
text
@/*	$OpenBSD: privsep.c,v 1.46 2017/09/08 19:10:57 brynet Exp $	*/

/*
 * Copyright (c) 2003 Can Erkin Acar
 * Copyright (c) 2003 Anil Madhavapeddy <anil@@recoil.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/ioctl.h>

#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <net/bpf.h>
#include <net/pfvar.h>

#include <rpc/rpc.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include "interface.h"
#include "privsep.h"
#include "pfctl_parser.h"

/*
 * tcpdump goes through four states: STATE_INIT is where the
 * bpf device and the input file is opened. In STATE_BPF, the
 * pcap filter gets set. STATE_FILTER is used for parsing
 * /etc/services and /etc/protocols and opening the output
 * file. STATE_RUN is the packet processing part.
 */

enum priv_state {
	STATE_INIT,		/* initial state */
	STATE_BPF,		/* input file/device opened */
	STATE_FILTER,		/* filter applied */
	STATE_RUN,		/* running and accepting network traffic */
	STATE_EXIT		/* in the process of dying */
};

#define ALLOW(action)	(1 << (action))

/*
 * Set of maximum allowed actions.
 */
static const int allowed_max[] = {
	/* INIT */	ALLOW(PRIV_OPEN_BPF) | ALLOW(PRIV_OPEN_DUMP) |
			ALLOW(PRIV_SETFILTER),
	/* BPF */	ALLOW(PRIV_SETFILTER),
	/* FILTER */	ALLOW(PRIV_OPEN_OUTPUT) | ALLOW(PRIV_GETSERVENTRIES) |
			ALLOW(PRIV_GETPROTOENTRIES) |
			ALLOW(PRIV_ETHER_NTOHOST) | ALLOW(PRIV_INIT_DONE),
	/* RUN */	ALLOW(PRIV_GETHOSTBYADDR) | ALLOW(PRIV_ETHER_NTOHOST) |
			ALLOW(PRIV_GETRPCBYNUMBER) | ALLOW(PRIV_GETLINES) |
			ALLOW(PRIV_LOCALTIME) | ALLOW(PRIV_PCAP_STATS),
	/* EXIT */	0
};

/*
 * Default set of allowed actions. More actions get added
 * later depending on the supplied parameters.
 */
static int allowed_ext[] = {
	/* INIT */	ALLOW(PRIV_SETFILTER),
	/* BPF */	ALLOW(PRIV_SETFILTER),
	/* FILTER */	ALLOW(PRIV_GETSERVENTRIES),
	/* RUN */	ALLOW(PRIV_GETLINES) | ALLOW(PRIV_LOCALTIME) |
			ALLOW(PRIV_PCAP_STATS),
	/* EXIT */	0
};

struct ftab {
	char *name;
	int max;
	int count;
};

static struct ftab file_table[] = {{PF_OSFP_FILE, 1, 0}};

#define NUM_FILETAB (sizeof(file_table) / sizeof(struct ftab))

int		debug_level = LOG_INFO;
int		priv_fd = -1;
volatile	pid_t child_pid = -1;
static volatile	sig_atomic_t cur_state = STATE_INIT;

extern void	set_slave_signals(void);

static void	impl_open_bpf(int, int *);
static void	impl_open_dump(int, const char *);
static void	impl_open_output(int, const char *);
static void	impl_setfilter(int, char *, int *);
static void	impl_init_done(int, int *);
static void	impl_gethostbyaddr(int);
static void	impl_ether_ntohost(int);
static void	impl_getrpcbynumber(int);
static void	impl_getserventries(int);
static void	impl_getprotoentries(int);
static void	impl_localtime(int fd);
static void	impl_getlines(int);
static void	impl_pcap_stats(int, int *);

static void	test_state(int, int);
static void	logmsg(int, const char *, ...);

int
priv_init(int argc, char **argv)
{
	int i, nargc, socks[2];
	struct passwd *pw;
	sigset_t allsigs, oset;
	char **privargv;

	closefrom(STDERR_FILENO + 1);
	for (i = 1; i < _NSIG; i++)
		signal(i, SIG_DFL);

	/* Create sockets */
	if (socketpair(AF_LOCAL, SOCK_STREAM, PF_UNSPEC, socks) == -1)
		err(1, "socketpair() failed");

	sigfillset(&allsigs);
	sigprocmask(SIG_BLOCK, &allsigs, &oset);

	child_pid = fork();
	if (child_pid < 0)
		err(1, "fork() failed");

	if (child_pid) {
		close(socks[0]);
		priv_fd = socks[1];

		set_slave_signals();
		sigprocmask(SIG_SETMASK, &oset, NULL);

		/*
		 * If run as regular user, packet parser will rely on
		 * pledge(2). If we are root, we want to chroot also..
		 */
		if (getuid() != 0)
			return (0);

		pw = getpwnam("_tcpdump");
		if (pw == NULL)
			errx(1, "unknown user _tcpdump");

		if (chroot(pw->pw_dir) == -1)
			err(1, "unable to chroot");
		if (chdir("/") == -1)
			err(1, "unable to chdir");

		/* drop to _tcpdump */
		if (setgroups(1, &pw->pw_gid) == -1)
			err(1, "setgroups() failed");
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
			err(1, "setresgid() failed");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
			err(1, "setresuid() failed");

		return (0);
	}
	close(socks[1]);

	if (dup2(socks[0], 3) == -1)
		err(1, "dup2 priv sock failed");
	closefrom(4);

	if ((privargv = reallocarray(NULL, argc + 2, sizeof(char *))) == NULL)
		err(1, "alloc priv argv failed");
	nargc = 0;
	privargv[nargc++] = argv[0];
	privargv[nargc++] = "-P";
	for (i = 1; i < argc; i++)
		privargv[nargc++] = argv[i];
	privargv[nargc] = NULL;
	execvp(privargv[0], privargv);
	err(1, "exec priv '%s' failed", privargv[0]);
}

__dead void
priv_exec(int argc, char *argv[])
{
	int bpfd = -1;
	int i, sock, cmd, nflag = 0, Pflag = 0;
	char *cmdbuf, *infile = NULL;
	char *RFileName = NULL;
	char *WFileName = NULL;

	sock = 3;

	closefrom(4);
	for (i = 1; i < _NSIG; i++)
		signal(i, SIG_DFL);

	signal(SIGINT, SIG_IGN);

	/* parse the arguments for required options */
	opterr = 0;
	while ((i = getopt(argc, argv,
	    "ac:D:deE:fF:i:lLnNOopPqr:s:StT:vw:xXy:Y")) != -1) {
		switch (i) {
		case 'n':
			nflag++;
			break;

		case 'r':
			RFileName = optarg;
			break;

		case 'w':
			WFileName = optarg;
			break;

		case 'F':
			infile = optarg;
			break;

		case 'P':
			Pflag = 1;
			break;

		default:
			/* nothing */
			break;
		}
	}

	if (!Pflag)
		errx(1, "exec without priv");

	if (RFileName != NULL) {
		if (strcmp(RFileName, "-") != 0)
			allowed_ext[STATE_INIT] |= ALLOW(PRIV_OPEN_DUMP);
	} else
		allowed_ext[STATE_INIT] |= ALLOW(PRIV_OPEN_BPF);
	if (WFileName != NULL) {
		if (strcmp(WFileName, "-") != 0)
			allowed_ext[STATE_FILTER] |= ALLOW(PRIV_OPEN_OUTPUT);
		else
			allowed_ext[STATE_FILTER] |= ALLOW(PRIV_INIT_DONE);
	} else
		allowed_ext[STATE_FILTER] |= ALLOW(PRIV_INIT_DONE);
	if (!nflag) {
		allowed_ext[STATE_RUN] |= ALLOW(PRIV_GETHOSTBYADDR);
		allowed_ext[STATE_FILTER] |= ALLOW(PRIV_ETHER_NTOHOST);
		allowed_ext[STATE_RUN] |= ALLOW(PRIV_ETHER_NTOHOST);
		allowed_ext[STATE_RUN] |= ALLOW(PRIV_GETRPCBYNUMBER);
		allowed_ext[STATE_FILTER] |= ALLOW(PRIV_GETPROTOENTRIES);
	}

	if (infile)
		cmdbuf = read_infile(infile);
	else
		cmdbuf = copy_argv(&argv[optind]);

	setproctitle("[priv]");

	for (;;) {
		if (may_read(sock, &cmd, sizeof(int)))
			break;
		switch (cmd) {
		case PRIV_OPEN_BPF:
			test_state(cmd, STATE_BPF);
			impl_open_bpf(sock, &bpfd);
			break;
		case PRIV_OPEN_DUMP:
			test_state(cmd, STATE_BPF);
			impl_open_dump(sock, RFileName);
			break;
		case PRIV_OPEN_OUTPUT:
			test_state(cmd, STATE_RUN);
			impl_open_output(sock, WFileName);
			break;
		case PRIV_SETFILTER:
			test_state(cmd, STATE_FILTER);
			impl_setfilter(sock, cmdbuf, &bpfd);
			break;
		case PRIV_INIT_DONE:
			test_state(cmd, STATE_RUN);
			impl_init_done(sock, &bpfd);

			if (pledge("stdio rpath inet unix dns recvfd bpf", NULL) == -1)
				err(1, "pledge");

			break;
		case PRIV_GETHOSTBYADDR:
			test_state(cmd, STATE_RUN);
			impl_gethostbyaddr(sock);
			break;
		case PRIV_ETHER_NTOHOST:
			test_state(cmd, cur_state);
			impl_ether_ntohost(sock);
			break;
		case PRIV_GETRPCBYNUMBER:
			test_state(cmd, STATE_RUN);
			impl_getrpcbynumber(sock);
			break;
		case PRIV_GETSERVENTRIES:
			test_state(cmd, STATE_FILTER);
			impl_getserventries(sock);
			break;
		case PRIV_GETPROTOENTRIES:
			test_state(cmd, STATE_FILTER);
			impl_getprotoentries(sock);
			break;
		case PRIV_LOCALTIME:
			test_state(cmd, STATE_RUN);
			impl_localtime(sock);
			break;
		case PRIV_GETLINES:
			test_state(cmd, STATE_RUN);
			impl_getlines(sock);
			break;
		case PRIV_PCAP_STATS:
			test_state(cmd, STATE_RUN);
			impl_pcap_stats(sock, &bpfd);
			break;
		default:
			logmsg(LOG_ERR, "[priv]: unknown command %d", cmd);
			exit(1);
			/* NOTREACHED */
		}
	}

	/* NOTREACHED */
	exit(0);
}

static void
impl_open_bpf(int fd, int *bpfd)
{
	int snaplen, promisc, err;
	u_int dlt, dirfilt;
	char device[IFNAMSIZ];
	size_t iflen;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_OPEN_BPF received");

	must_read(fd, &snaplen, sizeof(int));
	must_read(fd, &promisc, sizeof(int));
	must_read(fd, &dlt, sizeof(u_int));
	must_read(fd, &dirfilt, sizeof(u_int));
	iflen = read_string(fd, device, sizeof(device), __func__);
	if (iflen == 0)
		errx(1, "Invalid interface size specified");
	*bpfd = pcap_live(device, snaplen, promisc, dlt, dirfilt);
	err = errno;
	if (*bpfd < 0)
		logmsg(LOG_DEBUG,
		    "[priv]: failed to open bpf device for %s: %s",
		    device, strerror(errno));
	send_fd(fd, *bpfd);
	must_write(fd, &err, sizeof(int));
	/* do not close bpfd until filter is set */
}

static void
impl_open_dump(int fd, const char *RFileName)
{
	int file, err = 0;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_OPEN_DUMP received");

	if (RFileName == NULL) {
		file = -1;
		logmsg(LOG_ERR, "[priv]: No offline file specified");
	} else {
		file = open(RFileName, O_RDONLY, 0);
		err = errno;
		if (file < 0)
			logmsg(LOG_DEBUG, "[priv]: failed to open %s: %s",
			    RFileName, strerror(errno));
	}
	send_fd(fd, file);
	must_write(fd, &err, sizeof(int));
	if (file >= 0)
		close(file);
}

static void
impl_open_output(int fd, const char *WFileName)
{
	int file, err;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_OPEN_OUTPUT received");

	file = open(WFileName, O_WRONLY|O_CREAT|O_TRUNC, 0666);
	err = errno;
	send_fd(fd, file);
	must_write(fd, &err, sizeof(int));
	if (file < 0)
		logmsg(LOG_DEBUG, "[priv]: failed to open %s: %s",
		    WFileName, strerror(err));
	else
		close(file);
}

static void
impl_setfilter(int fd, char *cmdbuf, int *bpfd)
{
	logmsg(LOG_DEBUG, "[priv]: msg PRIV_SETFILTER received");

	if (setfilter(*bpfd, fd, cmdbuf))
		logmsg(LOG_DEBUG, "[priv]: setfilter() failed");
}

static void
impl_init_done(int fd, int *bpfd)
{
	int ret;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_INIT_DONE received");

	ret = 0;
	must_write(fd, &ret, sizeof(ret));
}

static void
impl_gethostbyaddr(int fd)
{
	char hostname[HOST_NAME_MAX+1];
	size_t hostname_len;
	int addr_af;
	struct hostent *hp;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_GETHOSTBYADDR received");

	/* Expecting: address block, address family */
	hostname_len = read_block(fd, hostname, sizeof(hostname), __func__);
	if (hostname_len == 0)
		_exit(1);
	must_read(fd, &addr_af, sizeof(int));
	hp = gethostbyaddr(hostname, hostname_len, addr_af);
	if (hp == NULL)
		write_zero(fd);
	else
		write_string(fd, hp->h_name);
}

static void
impl_ether_ntohost(int fd)
{
	struct ether_addr ether;
	char hostname[HOST_NAME_MAX+1];

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_ETHER_NTOHOST received");

	/* Expecting: ethernet address */
	must_read(fd, &ether, sizeof(ether));
	if (ether_ntohost(hostname, &ether) == -1)
		write_zero(fd);
	else
		write_string(fd, hostname);
}

static void
impl_getrpcbynumber(int fd)
{
	int rpc;
	struct rpcent *rpce;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_GETRPCBYNUMBER received");

	must_read(fd, &rpc, sizeof(int));
	rpce = getrpcbynumber(rpc);
	if (rpce == NULL)
		write_zero(fd);
	else
		write_string(fd, rpce->r_name);
}

static void
impl_getserventries(int fd)
{
	struct servent *sp;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_GETSERVENTRIES received");

	for (;;) {
		sp = getservent();
		if (sp == NULL) {
			write_zero(fd);
			break;
		} else {
			write_string(fd, sp->s_name);
			must_write(fd, &sp->s_port, sizeof(int));
			write_string(fd, sp->s_proto);
		}
	}
	endservent();
}

static void
impl_getprotoentries(int fd)
{
	struct protoent *pe;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_GETPROTOENTRIES received");

	for (;;) {
		pe = getprotoent();
		if (pe == NULL) {
			write_zero(fd);
			break;
		} else {
			write_string(fd, pe->p_name);
			must_write(fd, &pe->p_proto, sizeof(int));
		}
	}
	endprotoent();
}

/* read the time and send the corresponding localtime and gmtime
 * results back to the unprivileged process */
static void
impl_localtime(int fd)
{
	struct tm *lt, *gt;
	time_t t;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_LOCALTIME received");

	must_read(fd, &t, sizeof(time_t));

	/* this must be done separately, since they apparently use the
	 * same local buffer */
	if ((lt = localtime(&t)) == NULL)
		errx(1, "localtime()");
	must_write(fd, lt, sizeof(*lt));

	if ((gt = gmtime(&t)) == NULL)
		errx(1, "gmtime()");
	must_write(fd, gt, sizeof(*gt));

	if (lt->tm_zone == NULL)
		write_zero(fd);
	else
		write_string(fd, lt->tm_zone);
}

static void
impl_getlines(int fd)
{
	FILE *fp;
	char *buf, *lbuf, *file;
	size_t len, fid;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_GETLINES received");

	must_read(fd, &fid, sizeof(size_t));
	if (fid >= NUM_FILETAB)
		errx(1, "invalid file id");

	file = file_table[fid].name;

	if (file == NULL)
		errx(1, "invalid file referenced");

	if (file_table[fid].count >= file_table[fid].max)
		errx(1, "maximum open count exceeded for %s", file);

	file_table[fid].count++;

	if ((fp = fopen(file, "r")) == NULL) {
		write_zero(fd);
		return;
	}

	lbuf = NULL;
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			if ((lbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
			memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}

		write_string(fd, buf);

		free(lbuf);
		lbuf = NULL;
	}
	write_zero(fd);
	fclose(fp);
}

static void
impl_pcap_stats(int fd, int *bpfd)
{
	struct pcap_stat stats;

	logmsg(LOG_DEBUG, "[priv]: msg PRIV_PCAP_STATS received");

	if (ioctl(*bpfd, BIOCGSTATS, &stats) == -1)
		write_zero(fd);
	else
		must_write(fd, &stats, sizeof(stats));
}

void
priv_init_done(void)
{
	int ret;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	write_command(priv_fd, PRIV_INIT_DONE);
	must_read(priv_fd, &ret, sizeof(int));
}

/* Reverse address resolution; response is placed into res, and length of
 * response is returned (zero on error) */
size_t
priv_gethostbyaddr(char *addr, size_t addr_len, int af, char *res, size_t res_len)
{
	if (priv_fd < 0)
		errx(1, "%s called from privileged portion", __func__);

	write_command(priv_fd, PRIV_GETHOSTBYADDR);
	write_block(priv_fd, addr_len, addr);
	must_write(priv_fd, &af, sizeof(int));

	return (read_string(priv_fd, res, res_len, __func__));
}

size_t
priv_ether_ntohost(char *name, size_t name_len, struct ether_addr *e)
{
	if (priv_fd < 0)
		errx(1, "%s called from privileged portion", __func__);

	write_command(priv_fd, PRIV_ETHER_NTOHOST);
	must_write(priv_fd, e, sizeof(*e));

	/* Read the host name */
	return (read_string(priv_fd, name, name_len, __func__));
}

size_t
priv_getrpcbynumber(int rpc, char *progname, size_t progname_len)
{
	if (priv_fd < 0)
		errx(1, "%s called from privileged portion", __func__);

	write_command(priv_fd, PRIV_GETRPCBYNUMBER);
	must_write(priv_fd, &rpc, sizeof(int));

	return read_string(priv_fd, progname, progname_len, __func__);
}

/* start getting service entries */
void
priv_getserventries(void)
{
	if (priv_fd < 0)
		errx(1, "%s called from privileged portion", __func__);

	write_command(priv_fd, PRIV_GETSERVENTRIES);
}

/* retrieve a service entry, should be called repeatedly after calling
   priv_getserventries(), until it returns zero. */
size_t
priv_getserventry(char *name, size_t name_len, int *port, char *prot,
    size_t prot_len)
{
	if (priv_fd < 0)
		errx(1, "%s called from privileged portion", __func__);

	/* read the service name */
	if (read_string(priv_fd, name, name_len, __func__) == 0)
		return 0;

	/* read the port */
	must_read(priv_fd, port, sizeof(int));

	/* read the protocol */
	return (read_string(priv_fd, prot, prot_len, __func__));
}

/* start getting ip protocol entries */
void
priv_getprotoentries(void)
{
	if (priv_fd < 0)
		errx(1, "%s called from privileged portion", __func__);

	write_command(priv_fd, PRIV_GETPROTOENTRIES);
}

/* retrieve a ip protocol entry, should be called repeatedly after calling
   priv_getprotoentries(), until it returns zero. */
size_t
priv_getprotoentry(char *name, size_t name_len, int *num)
{
	if (priv_fd < 0)
		errx(1, "%s called from privileged portion", __func__);

	/* read the proto name */
	if (read_string(priv_fd, name, name_len, __func__) == 0)
		return 0;

	/* read the num */
	must_read(priv_fd, num, sizeof(int));

	return (1);
}

/* localtime() replacement: ask the privileged process for localtime and
 * gmtime, cache the localtime for about one minute i.e. until one of the
 * fields other than seconds changes. The check is done using gmtime
 * values since they are the same in parent and child. */
struct	tm *
priv_localtime(const time_t *t)
{
	static struct tm lt, gt0;
	static struct tm *gt = NULL;
	static char zone[PATH_MAX];

	if (gt != NULL) {
		gt = gmtime(t);
		gt0.tm_sec = gt->tm_sec;
		gt0.tm_zone = gt->tm_zone;

		if (memcmp(gt, &gt0, sizeof(struct tm)) == 0) {
			lt.tm_sec = gt0.tm_sec;
			return &lt;
		}
	}

	write_command(priv_fd, PRIV_LOCALTIME);
	must_write(priv_fd, t, sizeof(time_t));
	must_read(priv_fd, &lt, sizeof(lt));
	must_read(priv_fd, &gt0, sizeof(gt0));

	if (read_string(priv_fd, zone, sizeof(zone), __func__))
		lt.tm_zone = zone;
	else
		lt.tm_zone = NULL;

	gt0.tm_zone = NULL;
	gt = &gt0;

	return &lt;
}

/* start getting lines from a file */
void
priv_getlines(size_t sz)
{
	if (priv_fd < 0)
		errx(1, "%s called from privileged portion", __func__);

	write_command(priv_fd, PRIV_GETLINES);
	must_write(priv_fd, &sz, sizeof(size_t));
}

int
priv_pcap_stats(struct pcap_stat *ps)
{
	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	write_command(priv_fd, PRIV_PCAP_STATS);
	must_read(priv_fd, ps, sizeof(*ps));
	return (0);
}

/* retrieve a line from a file, should be called repeatedly after calling
   priv_getlines(), until it returns zero. */
size_t
priv_getline(char *line, size_t line_len)
{
	if (priv_fd < 0)
		errx(1, "%s called from privileged portion", __func__);

	/* read the line */
	return (read_string(priv_fd, line, line_len, __func__));
}

/* Read all data or return 1 for error. */
int
may_read(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while (n > pos) {
		res = read(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
			/* FALLTHROUGH */
		case 0:
			return (1);
		default:
			pos += res;
		}
	}
	return (0);
}

/* Read data with the assertion that it all must come through, or
 * else abort the process.  Based on atomicio() from openssh. */
void
must_read(int fd, void *buf, size_t n)
{
	char *s = buf;
	ssize_t res, pos = 0;

	while (n > pos) {
		res = read(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
			/* FALLTHROUGH */
		case 0:
			_exit(0);
		default:
			pos += res;
		}
	}
}

/* Write data with the assertion that it all has to be written, or
 * else abort the process.  Based on atomicio() from openssh. */
void
must_write(int fd, const void *buf, size_t n)
{
	const char *s = buf;
	ssize_t res, pos = 0;

	while (n > pos) {
		res = write(fd, s + pos, n - pos);
		switch (res) {
		case -1:
			if (errno == EINTR || errno == EAGAIN)
				continue;
			/* FALLTHROUGH */
		case 0:
			_exit(0);
		default:
			pos += res;
		}
	}
}

/* test for a given state, and possibly increase state */
static void
test_state(int action, int next)
{
	if (cur_state < 0 || cur_state > STATE_RUN) {
		logmsg(LOG_ERR, "[priv] Invalid state: %d", cur_state);
		_exit(1);
	}
	if ((allowed_max[cur_state] & allowed_ext[cur_state]
	    & ALLOW(action)) == 0) {
		logmsg(LOG_ERR, "[priv] Invalid action %d in state %d",
		    action, cur_state);
		_exit(1);
	}
	if (next < cur_state) {
		logmsg(LOG_ERR, "[priv] Invalid next state: %d < %d",
		    next, cur_state);
		_exit(1);
	}

	cur_state = next;
}

static void
logmsg(int pri, const char *message, ...)
{
	va_list ap;
	if (pri > debug_level)
		return;
	va_start(ap, message);

	vfprintf(stderr, message, ap);
	fprintf(stderr, "\n");
	va_end(ap);
}

/* write a command to the peer */
void
write_command(int fd, int cmd)
{
	must_write(fd, &cmd, sizeof(cmd));
}

/* write a zero 'length' to signal an error to read_{string|block} */
void
write_zero(int fd)
{
	size_t len = 0;
	must_write(fd, &len, sizeof(size_t));
}

/* send a string */
void
write_string(int fd, const char *str)
{
	size_t len;

	len = strlen(str) + 1;
	must_write(fd, &len, sizeof(size_t));
	must_write(fd, str, len);
}

/* send a block of data of given size */
void
write_block(int fd, size_t size, const char *str)
{
	must_write(fd, &size, sizeof(size_t));
	must_write(fd, str, size);
}

/* read a string from the channel, return 0 if error, or total size of
 * the buffer, including the terminating '\0' */
size_t
read_string(int fd, char *buf, size_t size, const char *func)
{
	size_t len;

	len = read_block(fd, buf, size, func);
	if (len == 0)
		return (0);

	if (buf[len - 1] != '\0')
		errx(1, "%s: received invalid string", func);

	return (len);
}

/* read a block of data from the channel, return length of data, or 0
 * if error */
size_t
read_block(int fd, char *buf, size_t size, const char *func)
{
	size_t len;
	/* Expect back an integer size, and then a string of that length */
	must_read(fd, &len, sizeof(size_t));

	/* Check there was no error (indicated by a return of 0) */
	if (len == 0)
		return (0);

	/* Make sure we aren't overflowing the passed in buffer */
	if (size < len)
		errx(1, "%s: overflow attempt in return", func);

	/* Read the string and make sure we got all of it */
	must_read(fd, buf, len);
	return (len);
}
@


1.46
log
@fork+exec model for tcpdump(8); re-exec the privileged child after fork

While tcpdump isn't a daemon in the traditional sense, it's not uncommon
for people to have long running sessions.  At least on OpenBSD, this is
even safe thanks to the existing privsep design by otto@@, canacar@@ and
pledge(2) work done by deraadt.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.45 2017/06/14 20:48:54 akfaew Exp $	*/
a35 1
#include <limits.h>
@


1.45
log
@Don't support loading appletalk addresses from /etc/appletalk.names.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.44 2017/01/23 04:25:05 deraadt Exp $	*/
d36 1
d136 1
a136 2
	int bpfd = -1;
	int i, socks[2], cmd, nflag = 0;
a137 3
	char *cmdbuf, *infile = NULL;
	char *RFileName = NULL;
	char *WFileName = NULL;
d139 1
d189 32
a221 1
	sigprocmask(SIG_SETMASK, &oset, NULL);
d227 1
a227 1
	    "ac:D:deE:fF:i:lLnNOopqr:s:StT:vw:xXy:Y")) != -1) {
d245 4
d255 3
a283 1
	close(socks[1]);
d286 1
a286 1
		if (may_read(socks[0], &cmd, sizeof(int)))
d291 1
a291 1
			impl_open_bpf(socks[0], &bpfd);
d295 1
a295 1
			impl_open_dump(socks[0], RFileName);
d299 1
a299 1
			impl_open_output(socks[0], WFileName);
d303 1
a303 1
			impl_setfilter(socks[0], cmdbuf, &bpfd);
d307 1
a307 1
			impl_init_done(socks[0], &bpfd);
d315 1
a315 1
			impl_gethostbyaddr(socks[0]);
d319 1
a319 1
			impl_ether_ntohost(socks[0]);
d323 1
a323 1
			impl_getrpcbynumber(socks[0]);
d327 1
a327 1
			impl_getserventries(socks[0]);
d331 1
a331 1
			impl_getprotoentries(socks[0]);
d335 1
a335 1
			impl_localtime(socks[0]);
d339 1
a339 1
			impl_getlines(socks[0]);
d343 1
a343 1
			impl_pcap_stats(socks[0], &bpfd);
d347 1
a347 1
			_exit(1);
d353 1
a353 1
	_exit(0);
@


1.44
log
@Split pledge "ioctl" into "tape" and "bpf", and allow SIOCGIFGROUP only
upon "inet".  Adjust the 4 programs that care about this.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.43 2016/07/25 02:35:26 deraadt Exp $	*/
d104 1
a104 2
static struct ftab file_table[] = {{"/etc/appletalk.names", 1, 0},
				   {PF_OSFP_FILE, 1, 0}};
@


1.43
log
@err() instead of errx(); noted by tim
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.42 2016/07/24 22:46:32 deraadt Exp $	*/
d275 1
a275 1
			if (pledge("stdio rpath inet unix ioctl dns recvfd", NULL) == -1)
@


1.42
log
@Split the root vs not-root cases better with regards to chroot setup.
ok kettenis benno tedu canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.41 2016/07/21 07:22:38 deraadt Exp $	*/
a176 1
		/* Attempt to chroot */
d178 1
a178 1
			errx(1, "unable to chroot");
@


1.41
log
@2004 privsep caused "tcpdump -r" to became a priviledged operation because
we felt chroot-containment was also necessary for off-line analysis.  Today
use of pledge "stdio" for the packet parser acts as an even better sandbox.
We can therefore silently ignore chroot setup failure, and regain tcpdump -r
support.

Result of a discussion with tedu -- which probably happened because we
became aware of the laughable retarded -Z option in upstream tcpdump.
ok tedu sthen guenther stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.40 2015/12/05 19:27:17 mmcc Exp $	*/
d167 2
a168 2
		 * Parent, attempt to drop privs and chroot.  If any of this
		 * fails that is OK, safety is still provided by pledge(2).
d170 3
d175 1
a175 1
			return (0);
d179 1
a179 1
			return (0);
d181 1
a181 1
			return (0);
d185 1
a185 1
			return (0);
d187 1
a187 1
			return (0);
d189 1
a189 1
			return (0);
@


1.40
log
@Remove two sets of NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.39 2015/11/03 05:04:06 mmcc Exp $	*/
a138 2
	uid_t uid;
	gid_t gid;
a143 3
	if (geteuid() != 0)
		errx(1, "need root privileges");

d160 10
a169 1
		/* Parent, drop privileges to _tcpdump */
d172 1
a172 1
			errx(1, "unknown user _tcpdump");
d174 5
a178 5
		/* chroot, drop privs and return */
		if (chroot(pw->pw_dir) != 0)
			err(1, "unable to chroot");
		if (chdir("/") != 0)
			err(1, "unable to chdir");
d182 1
a182 1
			err(1, "setgroups() failed");
d184 1
a184 1
			err(1, "setresgid() failed");
d186 1
a186 8
			err(1, "setresuid() failed");
		endpwent();

		close(socks[0]);
		priv_fd = socks[1];

		set_slave_signals();
		sigprocmask(SIG_SETMASK, &oset, NULL);
a192 9

	/* Child - drop suid privileges */
	gid = getgid();
	uid = getuid();

	if (setresgid(gid, gid, gid) == -1)
		err(1, "setresgid() failed");
	if (setresuid(uid, uid, uid) == -1)
		err(1, "setresuid() failed");
@


1.39
log
@Surround pledge call with blank lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.38 2015/10/09 01:37:09 deraadt Exp $	*/
d586 2
a587 4
		if (lbuf != NULL) {
			free(lbuf);
			lbuf = NULL;
		}
@


1.38
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.37 2015/10/06 15:39:44 deraadt Exp $	*/
d284 1
d287 1
@


1.37
log
@Move from tame "cmsg" to tame "sendfd" or "recvfd", depending on which
way the process moves fd's.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.37 2015/10/06 15:36:23 deraadt Exp $	*/
d284 2
a285 2
			if (tame("stdio rpath inet unix ioctl dns recvfd", NULL) == -1)
				err(1, "tame");
@


1.36
log
@tcpdump is two-process privsep.

the packet processor pid is initialized on a socketpair, and then only
does byte analysis. it can be protected using a "stdio" tame request.
an successfull attack against it will find it cannot open files nor
sockets, and faces various other limitations described in the tame(2)
manual page.

the monitor process can be restricted to "malloc cmsg inet ioctl dns rpath".
that sounds like a large subset, but notice it cannot create or write files.
maybe this set can be wittled down by hoisting more initialization code
upwards?

with help from canacar a while back.
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.35 2015/08/21 02:07:32 deraadt Exp $	*/
d284 1
a284 1
			if (tame("malloc cmsg inet ioctl dns rpath", NULL) == -1)
@


1.35
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.34 2015/07/14 20:23:40 deraadt Exp $	*/
d284 2
@


1.34
log
@Move the BIOCGSTATS ioctl operation done by the tcpdump process
(at ^C time) into a services provided by the privsep monitor.
ok canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.33 2015/03/15 00:41:28 millert Exp $	*/
d573 1
a573 1
			if ((lbuf = (char *)malloc(len + 1)) == NULL)
@


1.33
log
@tzfile.h is an internal header that should never have been installed.
What's worse, the tzfile.h that gets installed is over 20 years old
and doesn't match the real tzfile.h in libc/time.  This makes the
tree safe for /usr/include/tzfile.h removal.  The TM_YEAR_BASE
define has been moved to time.h temporarily until its usage is
replaced by 1900 in the tree.  Actual removal of tzfile.h is pending
a ports build.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.32 2015/01/20 18:26:58 deraadt Exp $	*/
d23 1
d63 2
a64 1
	STATE_RUN		/* running and accepting network traffic */
d81 2
a82 1
			ALLOW(PRIV_LOCALTIME)
d93 3
a95 1
	/* RUN */	ALLOW(PRIV_GETLINES) | ALLOW(PRIV_LOCALTIME)
d128 1
d195 1
d313 4
a403 2
	close(*bpfd);	/* done with bpf descriptor */
	*bpfd = -1;
a412 2
	close(*bpfd);	/* done with bpf descriptor */
	*bpfd = -1;
d591 13
d761 11
@


1.32
log
@Adjust <sys/param.h> comments regarding use of use of MSIZE, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.31 2015/01/16 06:40:22 deraadt Exp $	*/
a43 1
#include <tzfile.h>
d703 1
a703 1
	static char zone[TZ_MAX_CHARS];
@


1.31
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.30 2011/09/22 09:12:30 stsp Exp $	*/
d24 3
a27 1
#include <net/if.h>
a28 2
#include <netinet/in.h>
#include <netinet/if_ether.h>
@


1.30
log
@Revert r1.29. Now that the "C" locale is ASCII-only, this workaround
is no longer needed.  ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.28 2009/04/17 22:31:24 jmc Exp $	*/
d414 1
a414 1
	char hostname[MAXHOSTNAMELEN];
d437 1
a437 1
	char hostname[MAXHOSTNAMELEN];
@


1.29
log
@Call setlocale() to avoid display glitches in UTF-8 locales.
ok phessler nicm mikeb
@
text
@a34 1
#include <locale.h>
a163 3

		/* set the locale before chrooting */
		(void)setlocale(LC_CTYPE, "");
@


1.28
log
@correcto in comment; from Amarendra Godbole
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.27 2008/04/18 21:35:11 djm Exp $	*/
d35 1
d165 3
@


1.27
log
@add filtering on direction; ok mpf@@ deraadt@@ feedback jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.26 2007/11/27 16:22:14 martynas Exp $	*/
d52 1
a52 1
 * tcpdump goes through five states: STATE_INIT is where the
@


1.26
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.25 2006/04/22 19:26:05 moritz Exp $	*/
d203 1
a203 1
	    "ac:deE:fF:i:lLnNOopqr:s:StT:vw:xXy:Y")) != -1) {
d322 1
a322 1
	u_int dlt;
d331 1
d335 1
a335 1
	*bpfd = pcap_live(device, snaplen, promisc, dlt);
@


1.25
log
@Set signal handlers directly after the fork(2), so that we avoid
situations, where the privileged child dies before the unprivileged
parent has set a signal handler for SIGCHLD.

ok deraadt@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.24 2006/04/22 17:24:33 moritz Exp $	*/
d517 1
a517 1
	/* this must be done seperately, since they apparently use the
@


1.24
log
@Remove remaining stuff from state QUIT, adjust some comments
and close a fd leak in read_infile(). ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.23 2006/04/21 23:09:34 cloder Exp $	*/
d110 2
d139 1
d152 3
d182 4
d188 2
@


1.23
log
@Add comments to please lint. No code changes. OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.22 2005/09/23 15:42:51 otto Exp $	*/
d63 1
a63 1
	STATE_RUN,		/* running and accepting network traffic */
d80 1
a80 2
			ALLOW(PRIV_LOCALTIME),
	/* QUIT */	0
d91 1
a91 2
	/* RUN */	ALLOW(PRIV_GETLINES) | ALLOW(PRIV_LOCALTIME),
	/* QUIT */	0
@


1.22
log
@Only allow root to run tcpdump. It's needed for the chroot security.
ok moritz@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.21 2005/05/23 06:56:42 otto Exp $	*/
d758 1
d782 1
d805 1
@


1.21
log
@Call endpwent() _after_ we're done with the struct passwd fields.
ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.20 2005/05/22 19:53:33 moritz Exp $	*/
d140 3
d156 20
a175 29
		if (getuid() == 0) {
			/* Parent, drop privileges to _tcpdump */
			pw = getpwnam("_tcpdump");
			if (pw == NULL)
				errx(1, "unknown user _tcpdump");

			/* chroot, drop privs and return */
			if (chroot(pw->pw_dir) != 0)
				err(1, "unable to chroot");
			if (chdir("/") != 0)
				err(1, "unable to chdir");

			/* drop to _tcpdump */
			if (setgroups(1, &pw->pw_gid) == -1)
				err(1, "setgroups() failed");
			if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) == -1)
				err(1, "setresgid() failed");
			if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) == -1)
				err(1, "setresuid() failed");
			endpwent();
		} else {
			/* Parent - drop suid privileges */
			gid = getgid();
			uid = getuid();
			if (setresgid(gid, gid, gid) == -1)
				err(1, "setresgid() failed");
			if (setresuid(uid, uid, uid) == -1)
				err(1, "setresuid() failed");
		}
@


1.20
log
@correct comments and function namens to reflect new parent/child
situation. suggested by and ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.19 2005/05/22 18:41:33 moritz Exp $	*/
a157 1
			endpwent();
d172 1
@


1.19
log
@fix signal race in statistics output. ok cloder@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.18 2005/05/03 01:01:14 djm Exp $	*/
d112 12
a123 12
static void	parent_open_bpf(int, int *);
static void	parent_open_dump(int, const char *);
static void	parent_open_output(int, const char *);
static void	parent_setfilter(int, char *, int *);
static void	parent_init_done(int, int *);
static void	parent_gethostbyaddr(int);
static void	parent_ether_ntohost(int);
static void	parent_getrpcbynumber(int);
static void	parent_getserventries(int);
static void	parent_getprotoentries(int);
static void	parent_localtime(int fd);
static void	parent_getlines(int);
d154 1
d174 1
a174 1
			/* Child - drop suid privileges */
d187 1
a187 1
	/* Father - drop suid privileges */
d196 1
a196 2
	/* parse the arguments for required options so that the child
	 * need not send them back */
d257 1
a257 1
			parent_open_bpf(socks[0], &bpfd);
d261 1
a261 1
			parent_open_dump(socks[0], RFileName);
d265 1
a265 1
			parent_open_output(socks[0], WFileName);
d269 1
a269 1
			parent_setfilter(socks[0], cmdbuf, &bpfd);
d273 1
a273 1
			parent_init_done(socks[0], &bpfd);
d277 1
a277 1
			parent_gethostbyaddr(socks[0]);
d281 1
a281 1
			parent_ether_ntohost(socks[0]);
d285 1
a285 1
			parent_getrpcbynumber(socks[0]);
d289 1
a289 1
			parent_getserventries(socks[0]);
d293 1
a293 1
			parent_getprotoentries(socks[0]);
d297 1
a297 1
			parent_localtime(socks[0]);
d301 1
a301 1
			parent_getlines(socks[0]);
d315 1
a315 1
parent_open_bpf(int fd, int *bpfd)
d342 1
a342 1
parent_open_dump(int fd, const char *RFileName)
d365 1
a365 1
parent_open_output(int fd, const char *WFileName)
d383 1
a383 1
parent_setfilter(int fd, char *cmdbuf, int *bpfd)
d394 1
a394 1
parent_init_done(int fd, int *bpfd)
d407 1
a407 1
parent_gethostbyaddr(int fd)
d429 1
a429 1
parent_ether_ntohost(int fd)
d445 1
a445 1
parent_getrpcbynumber(int fd)
d461 1
a461 1
parent_getserventries(int fd)
d482 1
a482 1
parent_getprotoentries(int fd)
d502 1
a502 1
 * results back to the child */
d504 1
a504 1
parent_localtime(int fd)
d530 1
a530 1
parent_getlines(int fd)
d690 3
a692 3
/* localtime() replacement: ask parent for localtime and gmtime, cache
 * the localtime for about one minute i.e. until one of the fields other
 * than seconds changes. The check is done using gmtime
@


1.18
log
@more setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.17 2005/04/20 20:57:07 moritz Exp $	*/
d109 1
a109 1
static volatile	pid_t child_pid = -1;
a124 2
static void	sig_pass_to_chld(int);
static void	sig_got_chld(int);
d152 1
a152 1
	if (!child_pid) {
a247 6
	/* Pass ALRM/TERM/HUP through to child, and accept CHLD */
	signal(SIGALRM, sig_pass_to_chld);
	signal(SIGTERM, sig_pass_to_chld);
	signal(SIGHUP,  sig_pass_to_chld);
	signal(SIGCHLD, sig_got_chld);

a748 31
}

/* If priv parent gets a TERM or HUP, pass it through to child instead */
static void
sig_pass_to_chld(int sig)
{
	int save_err = errno;

	if (child_pid != -1)
		kill(child_pid, sig);
	errno = save_err;
}

/* When child dies, move into the shutdown state */
static void
sig_got_chld(int sig)
{
	pid_t pid;
	int status;
	int save_err = errno;

	do {
		pid = waitpid(child_pid, &status, WNOHANG);
		if (pid > 0 && (WIFEXITED(status) || WIFSIGNALED(status)))
			_exit(0);
	} while (pid == -1 && errno == EINTR);

	if (pid == -1)
		_exit(1);

	errno = save_err;
@


1.17
log
@fix signal race by removing STATE_QUIT completely.
help and ok otto@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.16 2005/04/10 19:59:02 otto Exp $	*/
d170 4
a173 8
			if (setegid(pw->pw_gid) == -1)
				err(1, "setegid() failed");
			if (setgid(pw->pw_gid) == -1)
				err(1, "setgid() failed");
			if (seteuid(pw->pw_uid) == -1)
				err(1, "seteuid() failed");
			if (setuid(pw->pw_uid) == -1)
				err(1, "setuid() failed");
d178 4
a181 8
			if (setegid(gid) == -1)
				err(1, "setegid() failed");
			if (setgid(gid) == -1)
				err(1, "setgid() failed");
			if (seteuid(uid) == -1)
				err(1, "seteuid() failed");
			if (setuid(uid) == -1)
				err(1, "setuid() failed");
d192 4
a195 8
	if (setegid(gid) == -1)
		err(1, "setegid() failed");
	if (setgid(gid) == -1)
		err(1, "setgid() failed");
	if (seteuid(uid) == -1)
		err(1, "seteuid() failed");
	if (setuid(uid) == -1)
		err(1, "setuid() failed");
@


1.16
log
@do not forget to call endpwent(). ok moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.15 2005/04/10 16:10:37 moritz Exp $	*/
a63 1
	STATE_QUIT		/* shutting down */
d271 1
a271 1
	while (cur_state < STATE_QUIT) {
d330 1
d792 2
d796 2
a797 3
	if (pid == child_pid && (WIFEXITED(status) || WIFSIGNALED(status)) &&
	    cur_state < STATE_QUIT)
		cur_state = STATE_QUIT;
d872 1
a872 1
	if (cur_state < 0 || cur_state > STATE_QUIT) {
@


1.15
log
@reduce the set of allowed actions in the privileged part
depending on the arguments supplied to tcpdump.

ok otto@@, canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.14 2005/03/26 18:39:10 otto Exp $	*/
d160 1
@


1.14
log
@simplify state engine, the old one was very confusing and wrong too.
ok moritz@@ "just get this in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.13 2005/03/25 13:45:30 moritz Exp $	*/
d69 4
a72 1
static const int allowed[] = {
d85 12
d135 1
a135 1
	int i, socks[2], cmd;
d215 4
d237 20
d874 2
a875 1
	if ((allowed[cur_state] & ALLOW(action)) == 0) {
@


1.13
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.12 2005/03/06 18:44:50 reyk Exp $	*/
d52 5
a56 3
 * tcpdump goes through three states: STATE_INIT is where the
 * descriptors and output files are opened. STATE_RUNNING is packet
 * processing part. It is not allowed to go back in states.
d58 1
d67 15
a162 1

d237 1
a237 1
			test_state(STATE_INIT, STATE_BPF);
d241 1
a241 1
			test_state(STATE_INIT, STATE_BPF);
d245 1
a245 1
			test_state(STATE_FILTER, STATE_RUN);
d249 1
a249 1
			test_state(STATE_INIT, STATE_FILTER);
d253 1
a253 1
			test_state(STATE_FILTER, STATE_RUN);
d257 1
a257 1
			test_state(STATE_RUN, STATE_RUN);
d261 1
a261 1
			test_state(STATE_BPF, cur_state);
d265 1
a265 1
			test_state(STATE_RUN, STATE_RUN);
d269 1
a269 1
			test_state(STATE_FILTER, STATE_FILTER);
d273 1
a273 1
			test_state(STATE_FILTER, STATE_FILTER);
d277 1
a277 1
			test_state(STATE_RUN, STATE_RUN);
d281 1
a281 1
			test_state(STATE_RUN, STATE_RUN);
d829 1
a829 1
test_state(int expect, int next)
d831 7
a837 3
	if (cur_state < expect) {
		logmsg(LOG_ERR, "[priv] Invalid state: %d < %d",
		    cur_state, expect);
a839 1

@


1.12
log
@add support for multiple DLTs using the -L and -y options.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.11 2004/07/14 19:07:03 henning Exp $	*/
d362 1
a362 1
	
d498 1
a498 1
	
d680 1
a680 1
	if (read_string(priv_fd, zone, sizeof(zone), __func__)) 
d732 1
a732 1
	
@


1.11
log
@no \n in errx(3)
From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.10 2004/06/09 19:21:55 otto Exp $	*/
d181 1
a181 1
	    "ac:deE:fF:i:lnNOopqr:s:StT:vw:xXY")) != -1) {
d281 1
d289 1
d293 1
a293 1
	*bpfd = pcap_live(device, snaplen, promisc);
@


1.10
log
@Take better care of people down under living in X and a half hour
timezones.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.9 2004/05/15 13:13:05 otto Exp $	*/
d547 1
a547 1
		errx(1, "%s: called from privileged portion\n", __func__);
@


1.9
log
@Naming consistency. From Alexander Guy. ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.8 2004/04/23 06:00:50 otto Exp $	*/
d652 3
a654 4
 * the localtime for about one hour i.e. until one of the fields other
 * than seconds and minutes change. The check is done using gmtime
 * values since they are the same in parent and child.
 * XXX assumes timezone granularity is 1 hour. */
a664 1
		gt0.tm_min = gt->tm_min;
a668 1
			lt.tm_min = gt0.tm_min;
@


1.8
log
@Silence getopt() in the priv process. ok canacar@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.7 2004/04/08 12:24:07 avsm Exp $	*/
d84 1
a84 1
static void	parent_done_init(int, int *);
d235 1
a235 1
		case PRIV_DONE_INIT:
d237 1
a237 1
			parent_done_init(socks[0], &bpfd);
d355 1
a355 1
parent_done_init(int fd, int *bpfd)
d359 1
a359 1
	logmsg(LOG_DEBUG, "[priv]: msg PRIV_DONE_INIT received");
d549 1
a549 1
	write_command(priv_fd, PRIV_DONE_INIT);
d655 1
a655 1
 * XXX assumes timezone granularity is 1 hour.  */
d745 1
a745 1
/* Read all data or return 1 for error.  */
@


1.7
log
@In error message, use saved errno, not current errno.
From Moritz Jodeit <moritz at jodeit.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.6 2004/04/03 10:20:51 avsm Exp $	*/
d179 1
@


1.6
log
@- dont send junk err in parent_open_dump() if filename is NULL
- dont close an invalid fd
canacar@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.5 2004/03/14 19:17:05 otto Exp $	*/
d337 1
a337 1
		    WFileName, strerror(errno));
@


1.5
log
@Check return code of chdir() after chroot(); noted by Joris Vink, slight mod
from avsm@@.
ok avsm@@ hshoexer@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.4 2004/02/05 22:12:06 otto Exp $	*/
d304 1
a304 1
	int file, err;
d320 2
a321 1
	close(file);
d333 2
d338 2
a339 4

	send_fd(fd, file);
	must_write(fd, &err, sizeof(int));
	close(file);
@


1.4
log
@Don't print two confusing error messages, print a single clear one.
ok deraadt@@ hshoexer@@ avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.3 2004/02/04 09:47:10 otto Exp $	*/
d131 2
a132 1
			chdir("/");
@


1.3
log
@Better error message when bpf device open fails.
ok dhartmei@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.2 2004/01/31 15:13:03 otto Exp $	*/
d278 1
a278 1
	int snaplen, promisc;
d290 1
d292 1
a292 1
		logmsg(LOG_NOTICE,
d296 1
d303 1
a303 1
	int file;
d312 1
d314 1
a314 1
			logmsg(LOG_NOTICE, "[priv]: failed to open %s: %s",
d318 1
d325 1
a325 1
	int file;
d330 1
d332 1
a332 1
		logmsg(LOG_NOTICE, "[priv]: failed to open %s: %s",
d336 1
@


1.2
log
@general cleanup and better SIGCHLD handling from millert@@
ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.1 2004/01/28 19:44:55 canacar Exp $	*/
d291 3
a293 1
		logmsg(LOG_NOTICE, "[priv]: failed to open bpf");
@


1.1
log
@privilege separated tcpdump, joint work with otto@@

tested by avsm@@ vincent@@ dhartmei@@ markus@@ hshoexer@@ and others
go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep.c,v 1.4 2003/10/22 19:53:15 deraadt Exp $	*/
d111 2
a203 3
	for (i = 1; i < _NSIG; i++)
		signal(i, SIG_DFL);

d708 1
a708 1
	int save_err;
a709 1
	save_err = errno;
a718 1
	int save_err;
d721 5
d727 2
a728 3
	save_err = errno;
	pid = waitpid(child_pid, &status, WCONTINUED);
	if ((pid == -1 || !WIFCONTINUED(status)) && cur_state < STATE_QUIT)
d730 1
@

