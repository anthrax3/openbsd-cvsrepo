head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.14
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.6
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.10
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.8
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.8
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.6
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.10
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.10
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.21
date	2016.05.08.08.20.50;	author natano;	state Exp;
branches;
next	1.20;
commitid	m6ORkv5QobVmEZci;

1.20
date	2016.05.03.07.41.24;	author natano;	state Exp;
branches;
next	1.19;
commitid	tjFA2ooWPM1VyyUp;

1.19
date	2015.10.01.13.18.40;	author jsg;	state Exp;
branches;
next	1.18;
commitid	nY0JRLHUdKt8mY54;

1.18
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Zx2k82IzYwwZaEz9;

1.17
date	2012.11.14.03.33.04;	author lteo;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.21.04.08.12;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.18.21.35.11;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.13.19.37.50;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.16.18.23.45;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.29.18.45.32;	author canacar;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.27.18.31.17;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.26.19.30.48;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.22.19.53.33;	author moritz;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.30.22.18.16;	author moritz;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.06.18.44.50;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.29.04.19.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.28.20.05.07;	author canacar;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.14.09.14.19;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.08.12.38.00;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.05.22.12.06;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.19.44.55;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Use /dev/bpf0 instead of /dev/bpf (without loop though), as suggested by
sthen@@. to make remote upgrades without media less painful.

ok tb@@
@
text
@/*	$OpenBSD: privsep_pcap.c,v 1.20 2016/05/03 07:41:24 natano Exp $ */

/*
 * Copyright (c) 2004 Can Erkin Acar
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <net/if.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <pcap-int.h>
#include <pcap.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "privsep.h"

/*
 * privileged part of priv_pcap_setfilter, compile the filter
 * expression, and return it to the parent. Note that we fake an hpcap
 * and use it to capture the error messages, and pass the error back
 * to client.
 */
int
setfilter(int bpfd, int sock, char *filter)
{
	struct bpf_program fcode;
	int oflag, snap, link;
	u_int32_t netmask;
	pcap_t hpcap;

	must_read(sock, &oflag, sizeof(oflag));
	must_read(sock, &netmask, sizeof(netmask));
	must_read(sock, &snap, sizeof(snap));
	must_read(sock, &link, sizeof(link));

	if (snap < 0) {
		snprintf(hpcap.errbuf, PCAP_ERRBUF_SIZE, "invalid snaplen");
		goto err;
	}

	/* fake hpcap, it only needs errbuf, snaplen, and linktype to
	 * compile a filter expression */
	/* XXX messing with pcap internals */
	hpcap.snapshot = snap;
	hpcap.linktype = link;
	if (pcap_compile(&hpcap, &fcode, filter, oflag, netmask))
		goto err;

	/* if bpf descriptor is open, set the filter XXX check oflag? */
	if (bpfd >= 0 && ioctl(bpfd, BIOCSETF, &fcode)) {
		snprintf(hpcap.errbuf, PCAP_ERRBUF_SIZE,
		    "ioctl: BIOCSETF: %s", strerror(errno));
		pcap_freecode(&fcode);
		goto err;
	}
	if (fcode.bf_len > 0) {
		/* write the filter */
		must_write(sock, &fcode.bf_len, sizeof(fcode.bf_len));
		must_write(sock, fcode.bf_insns,
		    fcode.bf_len * sizeof(struct bpf_insn));
	} else {
		snprintf(hpcap.errbuf, PCAP_ERRBUF_SIZE, "Invalid filter size");
		pcap_freecode(&fcode);
		goto err;
	}


	pcap_freecode(&fcode);
	return (0);

 err:
	fcode.bf_len = 0;
	must_write(sock, &fcode.bf_len, sizeof(fcode.bf_len));

	/* write back the error string */
	write_string(sock, hpcap.errbuf);
	return (1);
}

/*
 * filter is compiled and set in the privileged process.
 * get the compiled output and set it locally for filtering dumps etc.
 */
struct bpf_program *
priv_pcap_setfilter(pcap_t *hpcap, int oflag, u_int32_t netmask)
{
	struct bpf_program *fcode = NULL;
	int snap, link;
	char *ebuf;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	ebuf = pcap_geterr(hpcap);
	snap = pcap_snapshot(hpcap);
	link = pcap_datalink(hpcap);

	fcode = calloc(1, sizeof(*fcode));
	if (fcode == NULL) {
		snprintf(ebuf, PCAP_ERRBUF_SIZE, "out of memory");
		return (NULL);
	}

	write_command(priv_fd, PRIV_SETFILTER);

	/* send oflag, netmask, snaplen and linktype */
	must_write(priv_fd, &oflag, sizeof(oflag));
	must_write(priv_fd, &netmask, sizeof(netmask));
	must_write(priv_fd, &snap, sizeof(snap));
	must_write(priv_fd, &link, sizeof(link));

	/* receive compiled filter */
	must_read(priv_fd, &fcode->bf_len, sizeof(fcode->bf_len));
	if (fcode->bf_len <= 0) {
		int len;

		len = read_string(priv_fd, ebuf, PCAP_ERRBUF_SIZE, __func__);
		if (len == 0)
			snprintf(ebuf, PCAP_ERRBUF_SIZE, "pcap compile error");
		goto err;
	}

	fcode->bf_insns = calloc(fcode->bf_len, sizeof(struct bpf_insn));
	if (fcode->bf_insns == NULL) {
		snprintf(ebuf, PCAP_ERRBUF_SIZE, "out of memory");
		goto err;
	}

	must_read(priv_fd, fcode->bf_insns,
	    fcode->bf_len * sizeof(struct bpf_insn));

	pcap_setfilter(hpcap, fcode);
	return (fcode);

 err:
	free(fcode);
	return (NULL);
}


/* privileged part of priv_pcap_live */
int
pcap_live(const char *device, int snaplen, int promisc, u_int dlt,
    u_int dirfilt)
{
	int		fd;
	struct ifreq	ifr;
	unsigned	v;

	if (device == NULL || snaplen <= 0)
		return (-1);

	if ((fd = open("/dev/bpf0", O_RDONLY)) == -1)
		return (-1);

	v = 32768;	/* XXX this should be a user-accessible hook */
	ioctl(fd, BIOCSBLEN, &v);

	strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));
	if (ioctl(fd, BIOCSETIF, &ifr) < 0)
		goto error;

	if (dlt != (u_int) -1 && ioctl(fd, BIOCSDLT, &dlt))
		goto error;

	if (promisc)
		/* this is allowed to fail */
		ioctl(fd, BIOCPROMISC, NULL);
	if (ioctl(fd, BIOCSDIRFILT, &dirfilt) < 0)
		goto error;

	/* lock the descriptor */
	if (ioctl(fd, BIOCLOCK, NULL) < 0)
		goto error;
	return (fd);

 error:
	close(fd);
	return (-1);
}


/*
 * XXX reimplement pcap_open_live with privsep, this is the
 * unprivileged part.
 */
pcap_t *
priv_pcap_live(const char *dev, int slen, int prom, int to_ms,
    char *ebuf, u_int dlt, u_int dirfilt)
{
	int fd, err;
	struct bpf_version bv;
	u_int v;
	pcap_t *p;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	if (dev == NULL) {
		snprintf(ebuf, PCAP_ERRBUF_SIZE, "No interface specified");
		return (NULL);
	}

	p = malloc(sizeof(*p));
	if (p == NULL) {
		snprintf(ebuf, PCAP_ERRBUF_SIZE, "malloc: %s",
		    pcap_strerror(errno));
		return (NULL);
	}

	bzero(p, sizeof(*p));

	write_command(priv_fd, PRIV_OPEN_BPF);
	must_write(priv_fd, &slen, sizeof(int));
	must_write(priv_fd, &prom, sizeof(int));
	must_write(priv_fd, &dlt, sizeof(u_int));
	must_write(priv_fd, &dirfilt, sizeof(u_int));
	write_string(priv_fd, dev);

	fd = receive_fd(priv_fd);
	must_read(priv_fd, &err, sizeof(int));
	if (fd < 0) {
		snprintf(ebuf, PCAP_ERRBUF_SIZE,
		    "Failed to open bpf device for %s: %s",
		    dev, strerror(err));
		goto bad;
	}

	/* fd is locked, can only use 'safe' ioctls */
	if (ioctl(fd, BIOCVERSION, &bv) < 0) {
		snprintf(ebuf, PCAP_ERRBUF_SIZE, "BIOCVERSION: %s",
		    pcap_strerror(errno));
		goto bad;
	}

	if (bv.bv_major != BPF_MAJOR_VERSION ||
	    bv.bv_minor < BPF_MINOR_VERSION) {
		snprintf(ebuf, PCAP_ERRBUF_SIZE,
		    "kernel bpf filter out of date");
		goto bad;
	}

	p->fd = fd;
	p->snapshot = slen;

	/* Get the data link layer type. */
	if (ioctl(fd, BIOCGDLT, &v) < 0) {
		snprintf(ebuf, PCAP_ERRBUF_SIZE, "BIOCGDLT: %s",
		    pcap_strerror(errno));
		goto bad;
	}
	p->linktype = v;

	/* XXX hack */
	if (p->linktype == DLT_PFLOG && p->snapshot < 160)
		p->snapshot = 160;

	/* set timeout */
	if (to_ms != 0) {
		struct timeval to;
		to.tv_sec = to_ms / 1000;
		to.tv_usec = (to_ms * 1000) % 1000000;
		if (ioctl(p->fd, BIOCSRTIMEOUT, &to) < 0) {
			snprintf(ebuf, PCAP_ERRBUF_SIZE, "BIOCSRTIMEOUT: %s",
			    pcap_strerror(errno));
			goto bad;
		}
	}

	if (ioctl(fd, BIOCGBLEN, &v) < 0) {
		snprintf(ebuf, PCAP_ERRBUF_SIZE, "BIOCGBLEN: %s",
		    pcap_strerror(errno));
		goto bad;
	}
	p->bufsize = v;
	p->buffer = malloc(p->bufsize);
	if (p->buffer == NULL) {
		snprintf(ebuf, PCAP_ERRBUF_SIZE, "malloc: %s",
		    pcap_strerror(errno));
		goto bad;
	}
	return (p);

 bad:
	if (fd >= 0)
		close(fd);
	free(p);
	return (NULL);
}



/*
 * reimplement pcap_open_offline with privsep, this is the
 * unprivileged part.
 * XXX merge with above?
 */
static void
swap_hdr(struct pcap_file_header *hp)
{
	hp->version_major = swap16(hp->version_major);
	hp->version_minor = swap16(hp->version_minor);
	hp->thiszone = swap32(hp->thiszone);
	hp->sigfigs = swap32(hp->sigfigs);
	hp->snaplen = swap32(hp->snaplen);
	hp->linktype = swap32(hp->linktype);
}

pcap_t *
priv_pcap_offline(const char *fname, char *errbuf)
{
	pcap_t *p;
	FILE *fp = NULL;
	struct pcap_file_header hdr;
	int linklen, err;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	p = malloc(sizeof(*p));
	if (p == NULL) {
		strlcpy(errbuf, "out of swap", PCAP_ERRBUF_SIZE);
		return (NULL);
	}

	memset((char *)p, 0, sizeof(*p));

	if (fname[0] == '-' && fname[1] == '\0') {
		p->fd = -1;
		fp = stdin;
	} else {
		write_command(priv_fd, PRIV_OPEN_DUMP);
		p->fd = receive_fd(priv_fd);
		must_read(priv_fd, &err, sizeof(int));
		if (p->fd < 0) {
			snprintf(errbuf, PCAP_ERRBUF_SIZE,
			    "Failed to open input file %s: %s",
			    fname, strerror(err));
			goto bad;
		}

		fp = fdopen(p->fd, "r");
		if (fp == NULL) {
			snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s: %s", fname,
			    pcap_strerror(errno));
			close(p->fd);
			p->fd = -1;
			goto bad;
		}
	}
	if (fread((char *)&hdr, sizeof(hdr), 1, fp) != 1) {
		snprintf(errbuf, PCAP_ERRBUF_SIZE, "fread: %s",
		    pcap_strerror(errno));
		goto bad;
	}

	if (hdr.magic != TCPDUMP_MAGIC) {
		if (swap32(hdr.magic) != TCPDUMP_MAGIC) {
			snprintf(errbuf, PCAP_ERRBUF_SIZE,
			    "bad dump file format");
			goto bad;
		}
		p->sf.swapped = 1;
		swap_hdr(&hdr);
	}
	if (hdr.version_major < PCAP_VERSION_MAJOR) {
		snprintf(errbuf, PCAP_ERRBUF_SIZE, "archaic file format");
		goto bad;
	}

	p->tzoff = hdr.thiszone;
	p->snapshot = hdr.snaplen;
	p->linktype = hdr.linktype;
	p->sf.rfile = fp;
	p->bufsize = hdr.snaplen;

	/* Align link header as required for proper data alignment */
	/* XXX should handle all types */
	switch (p->linktype) {

	case DLT_EN10MB:
		linklen = 14;
		break;

	case DLT_FDDI:
		linklen = 13 + 8;	/* fddi_header + llc */
		break;

	case DLT_NULL:
	default:
		linklen = 0;
		break;
	}

	if (p->bufsize < 0)
		p->bufsize = BPF_MAXBUFSIZE;
	p->sf.base = malloc(p->bufsize + BPF_ALIGNMENT);
	if (p->sf.base == NULL) {
		strlcpy(errbuf, "out of swap", PCAP_ERRBUF_SIZE);
		goto bad;
	}
	p->buffer = p->sf.base + BPF_ALIGNMENT - (linklen % BPF_ALIGNMENT);
	p->sf.version_major = hdr.version_major;
	p->sf.version_minor = hdr.version_minor;
#ifdef PCAP_FDDIPAD
	/* XXX what to do with this? */
	/* XXX padding only needed for kernel fcode */
	pcap_fddipad = 0;
#endif
	return (p);

 bad:
	if (fp != NULL && p->fd != -1)
		fclose(fp);
	free(p);
	return (NULL);
}


static int
sf_write_header(FILE *fp, int linktype, int thiszone, int snaplen)
{
	struct pcap_file_header hdr;

	bzero(&hdr, sizeof hdr);
	hdr.magic = TCPDUMP_MAGIC;
	hdr.version_major = PCAP_VERSION_MAJOR;
	hdr.version_minor = PCAP_VERSION_MINOR;

	hdr.thiszone = thiszone;
	hdr.snaplen = snaplen;
	hdr.sigfigs = 0;
	hdr.linktype = linktype;

	if (fwrite((char *)&hdr, sizeof(hdr), 1, fp) != 1)
		return (-1);

	return (0);
}

pcap_dumper_t *
priv_pcap_dump_open(pcap_t *p, char *fname)
{
	int fd, err;
	FILE *f;

	if (priv_fd < 0)
		errx(1, "%s: called from privileged portion", __func__);

	if (fname[0] == '-' && fname[1] == '\0') {
		f = stdout;
		priv_init_done();
	} else {
		write_command(priv_fd, PRIV_OPEN_OUTPUT);
		fd = receive_fd(priv_fd);
		must_read(priv_fd, &err, sizeof(err));
		if (fd < 0)  {
			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
			    "Failed to open output file %s: %s",
			    fname, strerror(err));
			return (NULL);
		}
		f = fdopen(fd, "w");
		if (f == NULL) {
			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "%s: %s",
			    fname, pcap_strerror(errno));
			close(fd);
			return (NULL);
		}
	}

	(void)sf_write_header(f, p->linktype, p->tzoff, p->snapshot);
	return ((pcap_dumper_t *)f);
}
@


1.20
log
@Move to /dev/bpf; ok lteo
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.19 2015/10/01 13:18:40 jsg Exp $ */
d185 1
a185 1
	if ((fd = open("/dev/bpf", O_RDONLY)) == -1)
@


1.19
log
@remove a bsdi ifdef path
"kill it with fire" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.18 2015/08/21 02:07:32 deraadt Exp $ */
d178 1
a178 2
	char		bpf[sizeof "/dev/bpf0000000000"];
	int		fd, n = 0;
d185 1
a185 6
	do {
		snprintf(bpf, sizeof(bpf), "/dev/bpf%d", n++);
		fd = open(bpf, O_RDONLY);
	} while (fd < 0 && errno == EBUSY);

	if (fd < 0)
@


1.18
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.17 2012/11/14 03:33:04 lteo Exp $ */
a289 13
#if _BSDI_VERSION - 0 >= 199510
	/* The SLIP and PPP link layer header changed in BSD/OS 2.1 */
	switch (v) {

	case DLT_SLIP:
		v = DLT_SLIP_BSDOS;
		break;

	case DLT_PPP:
		v = DLT_PPP_BSDOS;
		break;
	}
#endif
@


1.17
log
@In the unlikely event that a NULL device is passed to priv_pcap_live(),
ensure that the function will stop and return NULL instead of continuing
(which could lead to a segfault).

ok benno deraadt otto
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.16 2010/09/21 04:08:12 henning Exp $ */
d242 1
a242 1
	p = (pcap_t *)malloc(sizeof(*p));
d327 1
a327 1
	p->buffer = (u_char *)malloc(p->bufsize);
d371 1
a371 1
	p = (pcap_t *)malloc(sizeof(*p));
d448 1
a448 1
	p->sf.base = (u_char *)malloc(p->bufsize + BPF_ALIGNMENT);
@


1.16
log
@temporary hack to raise snaplen for pflog so that pflog header, ip header
and protocol header actually fit in the common cases.
stays until canacar tells us how to do it right ;)
ok dlg ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.15 2008/04/18 21:35:11 djm Exp $ */
d237 1
a237 1
	if (dev == NULL)
d239 2
@


1.15
log
@add filtering on direction; ok mpf@@ deraadt@@ feedback jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.14 2005/11/13 19:37:50 otto Exp $ */
d302 4
@


1.14
log
@Do not clobber errno, from Andrey Matveev. ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.13 2005/10/16 18:23:45 otto Exp $ */
d175 2
a176 1
pcap_live(const char *device, int snaplen, int promisc, u_int dlt)
d207 2
d227 1
a227 1
    char *ebuf, u_int dlt)
d253 1
@


1.13
log
@Simplify some error paths. From Andrey Matveev. ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.12 2005/09/29 18:45:32 canacar Exp $ */
d385 2
a388 2
			snprintf(errbuf, PCAP_ERRBUF_SIZE, "%s: %s", fname,
			    pcap_strerror(errno));
a505 1
			close(fd);
d508 1
@


1.12
log
@Change DLT earlier. Fixes the loss of promisc mode when a non-default
DLT is specified.
looks sane deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.11 2005/09/27 18:31:17 otto Exp $ */
d168 1
a168 5
	if (fcode) {
		if (fcode->bf_insns)
			free(fcode->bf_insns);
		free(fcode);
	}
d178 1
a178 1
	int		fd = -1, n = 0;
d183 1
a183 1
		goto error;
d191 1
a191 1
		goto error;
d213 1
a213 2
	if (fd >= 0)
		close(fd);
@


1.11
log
@Fix another case of inconstitent error handling that was missed in the
previous commit.
ok moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.10 2005/09/26 19:30:48 otto Exp $ */
d204 3
a209 3

	if (dlt != (u_int) -1 && ioctl(fd, BIOCSDLT, &dlt))
		goto error;
@


1.10
log
@If setting the filter fails, pass the error back;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.9 2005/05/22 19:53:33 moritz Exp $ */
d88 3
a90 3
	/* write the filter */
	must_write(sock, &fcode.bf_len, sizeof(fcode.bf_len));
	if (fcode.bf_len > 0)
d93 1
a93 1
	else {
d95 1
@


1.9
log
@correct comments and function namens to reflect new parent/child
situation. suggested by and ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.8 2005/03/30 22:18:16 moritz Exp $ */
d81 7
d94 2
a95 2
		write_string(sock, "Invalid filter size");
		return (1);
a97 3
	/* if bpf descriptor is open, set the filter XXX check oflag? */
	if (bpfd >= 0 && ioctl(bpfd, BIOCSETF, &fcode))
		return 1;
@


1.8
log
@remove trailing \n in errx().
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.7 2005/03/06 18:44:50 reyk Exp $ */
d51 1
a51 1
 * expression, and return it to the child. Note that we fake an hpcap
d108 2
a109 2
 * filter is compiled and set in the parent, get the compiled output,
 * and set it locally, for filtering dumps etc.
@


1.7
log
@add support for multiple DLTs using the -L and -y options.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.6 2004/04/29 04:19:37 deraadt Exp $ */
d489 1
a489 1
		errx(1, "%s: called from privileged portion\n", __func__);
@


1.6
log
@a slight polishing...
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.5 2004/04/28 20:05:07 canacar Exp $ */
d174 1
a174 1
pcap_live(const char *device, int snaplen, int promisc)
d203 3
d223 2
a224 1
priv_pcap_live(const char *dev, int slen, int prom, int to_ms, char *ebuf)
d249 1
@


1.5
log
@Fix fd leaks.
Found by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.4 2004/04/14 09:14:19 otto Exp $ */
a95 1

a103 1

d114 1
d116 1
a116 2
	struct bpf_program *fcode = NULL;
	char *ebuf = pcap_geterr(hpcap);
d121 1
d143 1
d157 1
a157 1
		  fcode->bf_len * sizeof(struct bpf_insn));
a159 1

d177 1
a179 2
	int		fd = -1;
	int		n = 0;
a205 1

a210 1

a256 1

d318 1
a319 1
	return (p);
d446 1
a447 1
	return (p);
d461 1
@


1.4
log
@Don't forget to move to STATE_RUN if the -w output file is stdout.
ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.3 2004/04/08 12:38:00 avsm Exp $ */
d353 2
a354 2
	register pcap_t *p;
	register FILE *fp;
d385 2
d454 2
d505 1
@


1.3
log
@only close fd if its valid, from Moritz Jodeit <moritz at jodeit.org>
canacar@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.2 2004/02/05 22:12:06 otto Exp $ */
d486 1
a486 1
	if (fname[0] == '-' && fname[1] == '\0')
d488 2
a489 1
	else {
@


1.2
log
@Don't print two confusing error messages, print a single clear one.
ok deraadt@@ hshoexer@@ avsm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: privsep_pcap.c,v 1.1 2004/01/28 19:44:55 canacar Exp $ */
d326 2
a327 1
	close(fd);
@


1.1
log
@privilege separated tcpdump, joint work with otto@@

tested by avsm@@ vincent@@ dhartmei@@ markus@@ hshoexer@@ and others
go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d226 1
a226 1
	int fd;
d252 1
d255 2
a256 1
		    "Failed open bpf descriptor in privileged process.");
d355 1
a355 1
	int linklen;
d374 1
d377 2
a378 1
			    "Failed open input file in privileged process.");
d479 1
a479 1
	int fd;
d490 7
@

