head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.2
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.6
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.27.0.22
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.20
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.16
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.14
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.12
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.10
	OPENBSD_5_0:1.27.0.8
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.6
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.6
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.8
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.6
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.8
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.17.0.4
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.07.11.00.27.50;	author rzalamena;	state Exp;
branches;
next	1.30;
commitid	Sa8Q2I2tgAFG9H6l;

1.30
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.29;
commitid	enjTsnD5UO6xazKc;

1.29
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Uu5nFG3wCl0LACBb;

1.28
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.27;
commitid	yLXrOcgrag4eS8u4;

1.27
date	2010.01.14.04.57.06;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.05.01.25.24;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2008.10.16.12.57.01;	author mpf;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.01.17.18.39;	author moritz;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.28.15.48.33;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.08.19.45.15;	author canacar;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.22.16.18.52;	author jason;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.05.15.18.47;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.03.14.31.57;	author ho;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.26.21.35.40;	author jakob;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.07.18.16.37;	author chris;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.07.16.50.42;	author chris;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.19.14.55.18;	author chris;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.18.14.39.35;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.16.12.32.16;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	99.09.16.17.06.48;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	1.7;

1.7
date	97.07.27.01.34.34;	author denny;	state Exp;
branches;
next	1.6;

1.6
date	96.12.12.16.22.38;	author bitblt;	state Exp;
branches;
next	1.5;

1.5
date	96.11.12.08.31.57;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.21;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.23;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.25;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Teach tcpdump to recognize MPLS pseudowire with control words. Added
support to print encapsulated ethernet packets as well.

"Looks good" deraadt@@
@
text
@/*	$OpenBSD: print-ether.c,v 1.30 2015/11/16 00:16:39 mmcc Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/time.h>
#include <sys/socket.h>

struct mbuf;
struct rtentry;
#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/tcp.h>

#include <stdio.h>
#include <pcap.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif

#include "interface.h"
#include "addrtoname.h"
#include "ethertype.h"
#include "extract.h"

const u_char *packetp;
const u_char *snapend;

void ether_macctl(const u_char *, u_int);

void
ether_print(const u_char *bp, u_int length)
{
	const struct ether_header *ep;

	ep = (const struct ether_header *)bp;
	if (qflag) {
		TCHECK2(*ep, 12);
		(void)printf("%s %s %d: ",
			     etheraddr_string(ESRC(ep)),
			     etheraddr_string(EDST(ep)),
			     length);
	} else {
		TCHECK2(*ep, 14);
		(void)printf("%s %s %s %d: ",
			     etheraddr_string(ESRC(ep)),
			     etheraddr_string(EDST(ep)),
			     etherproto_string(ep->ether_type),
			     length);
	}
	return;
trunc:
	printf("[|ether] ");
}

u_short extracted_ethertype;

/*
 * This is the top level routine of the printer.  'p' is the points
 * to the ether header of the packet, 'tvp' is the timestamp,
 * 'length' is the length of the packet off the wire, and 'caplen'
 * is the number of bytes actually captured.
 */
void
ether_if_print(u_char *user, const struct pcap_pkthdr *h, const u_char *p)
{
	ts_print(&h->ts);

	/*
	 * Some printers want to get back at the ethernet addresses,
	 * and/or check that they're not walking off the end of the packet.
	 * Rather than pass them all the way down, we set these globals.
	 */
	snapend = p + h->caplen;

	ether_tryprint(p, h->len, 1);
}

void
ether_tryprint(const u_char *p, u_int length, int first_header)
{
	struct ether_header *ep;
	u_int caplen = snapend - p;
	u_short ether_type;

	if (caplen < sizeof(struct ether_header)) {
		printf("[|ether]");
		goto out;
	}

	if (eflag)
		ether_print(p, length);

	packetp = p;
	length -= sizeof(struct ether_header);
	caplen -= sizeof(struct ether_header);
	ep = (struct ether_header *)p;
	p += sizeof(struct ether_header);

	ether_type = ntohs(ep->ether_type);

	/*
	 * Is it (gag) an 802.3 encapsulation?
	 */
	extracted_ethertype = 0;
	if (ether_type <= ETHERMTU) {
		/* Try to print the LLC-layer header & higher layers */
		if (llc_print(p, length, caplen, ESRC(ep), EDST(ep)) == 0) {
			/* ether_type not known, print raw packet */
			if (!eflag)
				ether_print((u_char *)ep, length);
			if (extracted_ethertype) {
				printf("(LLC %s) ",
			       etherproto_string(htons(extracted_ethertype)));
			}
			if (!xflag && !qflag) {
				if (eflag)
					default_print(packetp,
					    snapend - packetp);
				else
					default_print(p, caplen);
			}
		}
	} else if (ether_encap_print(ether_type, p, length, caplen) == 0) {
		/* ether_type not known, print raw packet */
		if (!eflag)
			ether_print((u_char *)ep, length + sizeof(*ep));
		if (!xflag && !qflag) {
			if (eflag)
				default_print(packetp, snapend - packetp);
			else
				default_print(p, caplen);
		}
	}
	if (xflag && first_header) {
		if (eflag)
			default_print(packetp, snapend - packetp);
		else
			default_print(p, caplen);
	}
 out:
	if (first_header)
		putchar('\n');
}

/*
 * Prints the packet encapsulated in an Ethernet data segment
 * (or an equivalent encapsulation), given the Ethernet type code.
 *
 * Returns non-zero if it can do so, zero if the ethertype is unknown.
 *
 * Stuffs the ether type into a global for the benefit of lower layers
 * that might want to know what it is.
 */

int
ether_encap_print(u_short ethertype, const u_char *p,
    u_int length, u_int caplen)
{
recurse:
	extracted_ethertype = ethertype;

	switch (ethertype) {

	case ETHERTYPE_IP:
		ip_print(p, length);
		return (1);

#ifdef INET6
	case ETHERTYPE_IPV6:
		ip6_print(p, length);
		return (1);
#endif /*INET6*/

	case ETHERTYPE_ARP:
	case ETHERTYPE_REVARP:
		arp_print(p, length, caplen);
		return (1);

	case ETHERTYPE_DN:
		decnet_print(p, length, caplen);
		return (1);

	case ETHERTYPE_ATALK:
		if (vflag)
			fputs("et1 ", stdout);
		atalk_print_llap(p, length);
		return (1);

	case ETHERTYPE_AARP:
		aarp_print(p, length);
		return (1);

	case ETHERTYPE_8021Q:
		printf("802.1Q ");
	case ETHERTYPE_QINQ:
		if (ethertype == ETHERTYPE_QINQ)
			printf("QinQ s");
		printf("vid %d pri %d%s",
		       ntohs(*(unsigned short*)p)&0xFFF,
		       ntohs(*(unsigned short*)p)>>13,
		       (ntohs(*(unsigned short*)p)&0x1000) ? " cfi " : " ");
		ethertype = ntohs(*(unsigned short*)(p+2));
		p += 4;
		length -= 4;
		caplen -= 4;
		if (ethertype > ETHERMTU) 
			goto recurse;

		extracted_ethertype = 0;

		if (llc_print(p, length, caplen, p-18, p-12) == 0) {
			/* ether_type not known, print raw packet */
			if (!eflag)
				ether_print(p-18, length+4);
			if (extracted_ethertype) {
				printf("(LLC %s) ",
				etherproto_string(htons(extracted_ethertype)));
			}
			if (!xflag && !qflag)
				default_print(p-18, caplen+4);
		}
		return (1);

#ifdef PPP
	case ETHERTYPE_PPPOEDISC:
	case ETHERTYPE_PPPOE:
		pppoe_if_print(ethertype, p, length, caplen);
		return (1);
#endif

	case ETHERTYPE_FLOWCONTROL:
		ether_macctl(p, length);
		return (1);

	case ETHERTYPE_MPLS:
	case ETHERTYPE_MPLS_MCAST:
		mpls_print(p, length);
		return (1);

	case ETHERTYPE_LLDP:
		lldp_print(p, length);
		return (1);

	case ETHERTYPE_SLOW:
		slow_print(p, length);
		return (1);

	case ETHERTYPE_LAT:
	case ETHERTYPE_SCA:
	case ETHERTYPE_MOPRC:
	case ETHERTYPE_MOPDL:
		/* default_print for now */
	default:
		return (0);
	}
}

void
ether_macctl(const u_char *p, u_int length)
{
	printf("MACCTL");

	if (length < 2)
		goto trunc;
	if (EXTRACT_16BITS(p) == 0x0001) {
		u_int plen;

		printf(" PAUSE");

		length -= 2;
		p += 2;
		if (length < 2)
			goto trunc;
		plen = 512 * EXTRACT_16BITS(p);
		printf(" quanta %u", plen);
	} else {
		printf(" unknown-opcode(0x%04x)", EXTRACT_16BITS(p));
	}
	return;

trunc:
	printf("[|MACCTL]");
}
@


1.30
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.29 2015/01/16 06:40:21 deraadt Exp $	*/
d92 15
a106 2
	u_int caplen = h->caplen;
	u_int length = h->len;
d108 1
a110 2
	ts_print(&h->ts);

a115 8
	/*
	 * Some printers want to get back at the ethernet addresses,
	 * and/or check that they're not walking off the end of the packet.
	 * Rather than pass them all the way down, we set these globals.
	 */
	packetp = p;
	snapend = p + caplen;

d119 1
d160 1
a160 1
	if (xflag) {
d167 2
a168 1
	putchar('\n');
@


1.29
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.28 2014/08/14 12:44:44 mpi Exp $	*/
d57 1
a57 1
ether_print(register const u_char *bp, u_int length)
d59 1
a59 1
	register const struct ether_header *ep;
@


1.28
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.27 2010/01/14 04:57:06 jsing Exp $	*/
a23 1
#include <sys/param.h>
@


1.27
log
@Include the link-level header in the hex output if both the -x and -e
options are specified.

ok claudio@@ sthen@@ deraadt@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.25 2008/12/05 01:25:24 sthen Exp $	*/
a33 1
#include <netinet/in_systm.h>
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d138 7
a144 2
			if (!xflag && !qflag)
				default_print(p, caplen);
d150 11
a160 1
		if (!xflag && !qflag)
a162 2
	if (xflag)
		default_print(p, caplen);
@


1.25
log
@add ethertype and tcpdump support for VLAN stacking (QinQ) with
type number 0x88a8 specified by 802.1ad.

from reyk on misc@@.  "ok, go for it" dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.24 2008/10/16 12:57:01 mpf Exp $	*/
a22 4
#ifndef lint
static const char rcsid[] =
    "@@(#) $Id: print-ether.c,v 1.24 2008/10/16 12:57:01 mpf Exp $ (LBL)";
#endif
@


1.24
log
@Add support for IEEE "slow protocols" LACP, MARKER as per 802.3ad.
Code from tcpdump.org with cleanup and shrinkage by me.
Help and ideas for extra sanity checks from canacar@@
OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.23 2007/10/07 16:41:05 deraadt Exp $	*/
d25 1
a25 1
    "@@(#) $Id: print-ether.c,v 1.23 2007/10/07 16:41:05 deraadt Exp $ (LBL)";
d207 5
a211 1
		printf("802.1Q vid %d pri %d%s",
@


1.23
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.22 2006/06/01 17:18:39 moritz Exp $	*/
d25 1
a25 1
    "@@(#) $Id$ (LBL)";
d251 4
@


1.22
log
@Pass the captured packet length in addition to the real packet length
to etherip_print() and do all the bounds checking with it. Also add
bounds checks to ether_print(). This fixes even more crashes.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.21 2006/03/28 15:48:33 reyk Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.21 2006/03/28 15:48:33 reyk Exp $ (LBL)";
@


1.21
log
@Add a simple printer for IEEE 802.1AB LLDP, the Link Layer Discovery
Protocol.

LLDP is used by some switch vendors as a replacement for the non-free
Cizzco Discovery Protocol (CDP) due to some Cisco patentry...

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.20 2005/10/08 19:45:15 canacar Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.20 2005/10/08 19:45:15 canacar Exp $ (LBL)";
d68 2
a69 1
	if (qflag)
d74 2
a75 1
	else
d81 4
a109 3
	if (eflag)
		ether_print(p, length);

d117 3
@


1.20
log
@Add a best effort mpls decoder. From Jason L. Wright.
Since the encapsulated protocol information is not always
available in the MPLS tag stack. The decoder attempts
to guess the protocol.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.19 2004/01/22 16:18:52 jason Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.19 2004/01/22 16:18:52 jason Exp $ (LBL)";
d241 4
@


1.19
log
@802.3X pretty printer (dead simple)
jakob@@: "seems reasonable"
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.18 2002/02/19 19:39:40 millert Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.18 2002/02/19 19:39:40 millert Exp $ (LBL)";
d236 5
@


1.18
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.17 2001/02/05 15:18:47 jason Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.17 2001/02/05 15:18:47 jason Exp $ (LBL)";
d55 1
d60 2
d234 4
d246 27
@


1.17
log
@etherip printing code... handles draft (v2) and current (v3)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-ether.c,v 1.16 2000/10/03 14:31:57 ho Exp $	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.16 2000/10/03 14:31:57 ho Exp $ (LBL)";
a31 1
#ifdef __STDC__
a33 1
#endif
@


1.16
log
@Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.15 2000/04/26 21:35:40 jakob Exp $ (LBL)";
d61 1
a61 1
static inline void
d80 1
a80 1
static u_short extracted_ethertype;
@


1.15
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 2
d25 1
a25 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.14 2000/03/07 18:16:37 chris Exp $ (LBL)";
@


1.14
log
@Use ETHERTYPE_8021Q
@
text
@d23 1
a23 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.13 2000/03/07 16:50:42 chris Exp $ (LBL)";
a43 1
#include <netinet/tcpip.h>
d48 4
d171 6
@


1.13
log
@Add 802.1Q from kuznet@@ms2.inr.ac.ru via tcpdump.org
also, make extracted_ethertype not extern
@
text
@d23 1
a23 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.12 2000/02/19 14:55:18 chris Exp $ (LBL)";
d188 1
a188 1
	case ETHERTYPE_VLAN:
@


1.12
log
@Remove bogus 802.1Q code
ok jakob@@
@
text
@d23 1
a23 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.11 2000/02/18 14:39:35 jason Exp $ (LBL)";
d75 2
a89 1
	extern u_short extracted_ethertype;
a155 2
u_short	extracted_ethertype;

d160 1
d186 27
@


1.11
log
@Add support for dumping PPPoE Discovery and Session packets
@
text
@d23 1
a23 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.10 2000/01/16 12:32:16 jakob Exp $ (LBL)";
a186 11

	case ETHERTYPE_VLAN:
		printf("802.1q");
		if (eflag) {
			printf(" %s %d",
				etherproto_string(ntohs(*(u_int16_t *)p)),
				length - 4);
		}
		printf(": ");
		ether_print(p + 4, length - 4);
 		return (1);
@


1.10
log
@VLAN 802.1q support
@
text
@d23 1
a23 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.9 1999/09/16 17:06:48 brad Exp $ (LBL)";
d198 7
@


1.9
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d23 1
a23 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.8 1999/07/28 20:41:36 jakob Exp $ (LBL)";
d187 11
@


1.8
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d2 1
a2 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
d23 1
a23 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.7 1997/07/27 01:34:34 denny Exp $ (LBL)";
d30 1
a30 1
#if __STDC__
@


1.7
log
@Ethernet v2 encapsulated Appletalk packets are phase 1, w/ LLAP header.
802.3/SNAP encapsulated Appletalk packets are phase 2, w/ no LLAP header.
@
text
@d23 1
a23 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-ether.c,v 1.6 1996/12/12 16:22:38 bitblt Exp $ (LBL)";
d119 1
a119 1
	if (ether_type < ETHERMTU) {
@


1.6
log
@*** empty log message ***
@
text
@d23 1
a23 1
    "@@(#) $Header: print-ether.c,v 1.43 96/09/26 23:36:43 leres Exp $ (LBL)";
d181 1
a181 1
		atalk_print(p, length);
@


1.5
log
@add NetBIOS printing.
@
text
@a0 2
/*	$OpenBSD: print-ether.c,v 1.4 1996/07/13 11:01:21 mickey Exp $	*/

d22 2
a23 2
static char rcsid[] =
    "@@(#) Header: print-ether.c,v 1.39 96/06/03 03:05:27 leres Exp (LBL)";
a27 1
#include <sys/types.h>
d57 1
a57 1
ether_print(register const u_char *bp, int length)
d84 2
a85 2
	int caplen = h->caplen;
	int length = h->len;
d158 2
a159 1
ether_encap_print(u_short ethertype, const u_char *p, int length, int caplen)
a187 4
	case ETHERTYPE_8022:
		netbios_print(p, length);
		return (1);

d189 1
a196 1

@


1.4
log
@it is 3.2 now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d188 4
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-ether.c,v 1.3 1995/03/06 19:11:10 mycroft Exp $	*/
/*	$NetBSD: print-ether.c,v 1.3 1995/03/06 19:11:10 mycroft Exp $	*/
d4 1
a4 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
d25 1
a25 1
    "@@(#) Header: print-ether.c,v 1.37 94/06/10 17:01:29 mccanne Exp (LBL)";
d33 4
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
