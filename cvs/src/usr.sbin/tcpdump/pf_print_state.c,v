head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.2
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.12
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.10
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.6
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.4.0.4
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.3.0.6
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.4
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.2.0.8
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2016.10.28.12.42.39;	author jsg;	state Exp;
branches;
next	1.12;
commitid	B2Jf1y9OHeESZDN6;

1.12
date	2015.01.20.18.26.58;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	qRSGCXxt7yQIBAcS;

1.11
date	2012.07.08.17.48.37;	author lteo;	state Exp;
branches;
next	1.10;

1.10
date	2011.10.13.18.32.30;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2010.11.12.13.14.41;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.16.00.31.25;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.29.01.00.53;	author mcbride;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.09.11.57.52;	author mpf;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.31.04.16.26;	author mcbride;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.04.08.24.15;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.10.20.26.49;	author mcbride;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.19.44.55;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Don't assume s->ifname is NUL terminated and printable.
As in pfsync_print_clr() use vis(3) in print_state().  This was also
found with afl though with a different input.
@
text
@/*	$OpenBSD: pf_print_state.c,v 1.12 2015/01/20 18:26:58 deraadt Exp $	*/

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#define TCPSTATES
#include <netinet/in.h>
#include <netinet/tcp_fsm.h>
#include <net/pfvar.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <stdio.h>
#include <string.h>
#include <vis.h>

#include "pfctl_parser.h"
#include "pfctl.h"
#include "addrtoname.h"

void	print_name(struct pf_addr *, sa_family_t);

void
print_addr(struct pf_addr_wrap *addr, sa_family_t af, int verbose)
{
	switch (addr->type) {
	case PF_ADDR_DYNIFTL:
		printf("(%s", addr->v.ifname);
		if (addr->iflags & PFI_AFLAG_NETWORK)
			printf(":network");
		if (addr->iflags & PFI_AFLAG_BROADCAST)
			printf(":broadcast");
		if (addr->iflags & PFI_AFLAG_PEER)
			printf(":peer");
		if (addr->iflags & PFI_AFLAG_NOALIAS)
			printf(":0");
		if (verbose) {
			if (addr->p.dyncnt <= 0)
				printf(":*");
			else
				printf(":%d", addr->p.dyncnt);
		}
		printf(")");
		break;
	case PF_ADDR_TABLE:
		if (verbose)
			if (addr->p.tblcnt == -1)
				printf("<%s:*>", addr->v.tblname);
			else
				printf("<%s:%d>", addr->v.tblname,
				    addr->p.tblcnt);
		else
			printf("<%s>", addr->v.tblname);
		return;
	case PF_ADDR_ADDRMASK:
		if (PF_AZERO(&addr->v.a.addr, AF_INET6) &&
		    PF_AZERO(&addr->v.a.mask, AF_INET6))
			printf("any");
		else {
			char buf[48];

			if (inet_ntop(af, &addr->v.a.addr, buf,
			    sizeof(buf)) == NULL)
				printf("?");
			else
				printf("%s", buf);
		}
		break;
	case PF_ADDR_NOROUTE:
		printf("no-route");
		return;
	default:
		printf("?");
		return;
	}
	if (! PF_AZERO(&addr->v.a.mask, af)) {
		int bits = unmask(&addr->v.a.mask, af);

		if (bits != (af == AF_INET ? 32 : 128))
			printf("/%d", bits);
	}
}

void
print_name(struct pf_addr *addr, sa_family_t af)
{
	char *host;

	switch (af) {
	case AF_INET:
		host = getname((char *)&addr->v4);
		break;
	case AF_INET6:
		host = getname6((char *)&addr->v6);
		break;
	default:
		host = "?";
		break;
	}
	printf("%s", host);
}

void
print_host(struct pf_addr *addr, u_int16_t port, sa_family_t af, u_int16_t rdom,
    const char *proto, int opts)
{
	struct servent	*s = NULL;
	char		ps[6];

	if (rdom)
		printf("(%u) ", ntohs(rdom));

	if (opts & PF_OPT_USEDNS)
		print_name(addr, af);
	else {
		struct pf_addr_wrap aw;

		memset(&aw, 0, sizeof(aw));
		aw.v.a.addr = *addr;
		if (af == AF_INET)
			aw.v.a.mask.addr32[0] = 0xffffffff;
		else {
			memset(&aw.v.a.mask, 0xff, sizeof(aw.v.a.mask));
			af = AF_INET6;
		}
		print_addr(&aw, af, opts & PF_OPT_VERBOSE2);
	}

	if (port) {
		snprintf(ps, sizeof(ps), "%u", ntohs(port));
		if (opts & PF_OPT_PORTNAMES)
			s = getservbyport(port, proto);
		if (af == AF_INET)
			printf(":%s", s ? s->s_name : ps);
		else
			printf("[%s]", s ? s->s_name : ps);
	}
}

void
print_seq(struct pfsync_state_peer *p)
{
	if (p->seqdiff)
		printf("[%u + %u](+%u)", ntohl(p->seqlo),
		    ntohl(p->seqhi) - ntohl(p->seqlo), ntohl(p->seqdiff));
	else
		printf("[%u + %u]", ntohl(p->seqlo),
		    ntohl(p->seqhi) - ntohl(p->seqlo));
}

void
print_state(struct pfsync_state *s, int opts)
{
	struct pfsync_state_peer *src, *dst;
	struct pfsync_state_key *sk, *nk;
	char ifname[IFNAMSIZ * 4 + 1];
	int min, sec, sidx, didx, i;
	char *cp = ifname;

	if (s->direction == PF_OUT) {
		src = &s->src;
		dst = &s->dst;
		sk = &s->key[PF_SK_STACK];
		nk = &s->key[PF_SK_WIRE];
		if (s->proto == IPPROTO_ICMP || s->proto == IPPROTO_ICMPV6) 
			sk->port[0] = nk->port[0];
	} else {
		src = &s->dst;
		dst = &s->src;
		sk = &s->key[PF_SK_WIRE];
		nk = &s->key[PF_SK_STACK];
		if (s->proto == IPPROTO_ICMP || s->proto == IPPROTO_ICMPV6) 
			sk->port[1] = nk->port[1];
	}
	/* Treat s->ifname as untrusted input. */
	for (i = 0; i < IFNAMSIZ && s->ifname[i] != '\0'; i++)
		cp = vis(cp, s->ifname[i], VIS_WHITE, 0);
	printf("%s ", ifname);
	printf("%s ", ipproto_string(s->proto));

	if (nk->af != sk->af)
		sidx = 1, didx = 0;
	else
		sidx = 0, didx = 1;

	print_host(&nk->addr[didx], nk->port[didx], nk->af, nk->rdomain, NULL, opts);
	if (nk->af != sk->af || PF_ANEQ(&nk->addr[1], &sk->addr[1], nk->af) ||
	    nk->port[1] != sk->port[1]) {
		printf(" (");
		print_host(&sk->addr[1], sk->port[1], sk->af, sk->rdomain,
		    NULL, opts);
		printf(")");
	}
	if (s->direction == PF_OUT)
		printf(" -> ");
	else
		printf(" <- ");
	print_host(&nk->addr[sidx], nk->port[sidx], nk->af, nk->rdomain, NULL,
	    opts);
	if (nk->af != sk->af || PF_ANEQ(&nk->addr[0], &sk->addr[0], nk->af) ||
	    nk->port[0] != sk->port[0]) {
		printf(" (");
		print_host(&sk->addr[0], sk->port[0], sk->af, sk->rdomain, NULL,
		    opts);
		printf(")");
	}

	printf("    ");
	if (s->proto == IPPROTO_TCP) {
		if (src->state <= TCPS_TIME_WAIT &&
		    dst->state <= TCPS_TIME_WAIT)
			printf("\n   %s:%s", tcpstates[src->state],
			    tcpstates[dst->state]);
		else if (src->state == PF_TCPS_PROXY_SRC ||
		    dst->state == PF_TCPS_PROXY_SRC)
			printf("\n   PROXY:SRC");
		else if (src->state == PF_TCPS_PROXY_DST ||
		    dst->state == PF_TCPS_PROXY_DST)
			printf("\n   PROXY:DST");
		else
			printf("\n   <BAD STATE LEVELS %u:%u>",
			    src->state, dst->state);
		if (opts & PF_OPT_VERBOSE) {
			printf("\n   ");
			print_seq(src);
			if (src->wscale && dst->wscale)
				printf(" wscale %u",
				    src->wscale & PF_WSCALE_MASK);
			printf("  ");
			print_seq(dst);
			if (src->wscale && dst->wscale)
				printf(" wscale %u",
				    dst->wscale & PF_WSCALE_MASK);
		}
	} else if (s->proto == IPPROTO_UDP && src->state < PFUDPS_NSTATES &&
	    dst->state < PFUDPS_NSTATES) {
		const char *states[] = PFUDPS_NAMES;

		printf("   %s:%s", states[src->state], states[dst->state]);
	} else if (s->proto != IPPROTO_ICMP && src->state < PFOTHERS_NSTATES &&
	    dst->state < PFOTHERS_NSTATES) {
		/* XXX ICMP doesn't really have state levels */
		const char *states[] = PFOTHERS_NAMES;

		printf("   %s:%s", states[src->state], states[dst->state]);
	} else {
		printf("   %u:%u", src->state, dst->state);
	}

	if (opts & PF_OPT_VERBOSE) {
		u_int64_t packets[2];
		u_int64_t bytes[2];
		u_int32_t creation = ntohl(s->creation);
		u_int32_t expire = ntohl(s->expire);

		sec = creation % 60;
		creation /= 60;
		min = creation % 60;
		creation /= 60;
		printf("\n   age %.2u:%.2u:%.2u", creation, min, sec);
		sec = expire % 60;
		expire /= 60;
		min = expire % 60;
		expire /= 60;
		printf(", expires in %.2u:%.2u:%.2u", expire, min, sec);

		bcopy(s->packets[0], &packets[0], sizeof(u_int64_t));
		bcopy(s->packets[1], &packets[1], sizeof(u_int64_t));
		bcopy(s->bytes[0], &bytes[0], sizeof(u_int64_t));
		bcopy(s->bytes[1], &bytes[1], sizeof(u_int64_t));
		printf(", %llu:%llu pkts, %llu:%llu bytes",
		    betoh64(packets[0]),
		    betoh64(packets[1]),
		    betoh64(bytes[0]),
		    betoh64(bytes[1]));
		if (s->anchor != -1)
			printf(", anchor %u", ntohl(s->anchor));
		if (s->rule != -1)
			printf(", rule %u", ntohl(s->rule));
	}
	if (opts & PF_OPT_VERBOSE2) {
		u_int64_t id;

		bcopy(&s->id, &id, sizeof(u_int64_t));
		printf("\n   id: %016llx creatorid: %08x",
		    betoh64(id), ntohl(s->creatorid));
	}
}

int
unmask(struct pf_addr *m, sa_family_t af)
{
	int i = 31, j = 0, b = 0;
	u_int32_t tmp;

	while (j < 4 && m->addr32[j] == 0xffffffff) {
		b += 32;
		j++;
	}
	if (j < 4) {
		tmp = ntohl(m->addr32[j]);
		for (i = 31; tmp & (1 << i); --i)
			b++;
	}
	return (b);
}
@


1.12
log
@Adjust <sys/param.h> comments regarding use of use of MSIZE, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.11 2012/07/08 17:48:37 lteo Exp $	*/
d45 1
d186 3
a188 1
	int min, sec, sidx, didx;
d205 4
a208 1
	printf("%s ", s->ifname);
@


1.11
log
@New attempt to make the -P flag work with -ss, so that states can be
printed with port names if desired.

tcpdump's pf_print_state.c has diverged significantly from pfctl's, so
the change to tcpdump's pf_print_state.c is not exactly the same as
pfctl's.

ok henning sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.10 2011/10/13 18:32:30 claudio Exp $	*/
d37 1
@


1.10
log
@Teach some userland tools about NAT64. I think this is mostly from mikeb@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.9 2010/11/12 13:14:41 claudio Exp $	*/
d133 1
a133 1
    int opts)
d135 3
d158 3
d162 1
a162 1
			printf(":%u", ntohs(port));
d164 1
a164 1
			printf("[%u]", ntohs(port));
d209 1
a209 1
	print_host(&nk->addr[didx], nk->port[didx], nk->af, nk->rdomain, opts);
d214 1
a214 1
		    opts);
d221 2
a222 1
	print_host(&nk->addr[sidx], nk->port[sidx], nk->af, nk->rdomain, opts);
d226 1
a226 1
		print_host(&sk->addr[0], sk->port[0], sk->af, sk->rdomain,
@


1.9
log
@The ioctl to show states returns a pfsync_state which is in network byte
order and therefore a ntohs is needed to show the rdomain correctly.
OK henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.8 2009/11/03 10:59:04 claudio Exp $	*/
d178 1
a178 1
	int min, sec;
d198 7
a204 2
	print_host(&nk->addr[1], nk->port[1], s->af, nk->rdomain, opts);
	if (PF_ANEQ(&nk->addr[1], &sk->addr[1], s->af) ||
d207 2
a208 1
		print_host(&sk->addr[1], sk->port[1], s->af, sk->rdomain, opts);
d215 2
a216 2
	print_host(&nk->addr[0], nk->port[0], s->af, nk->rdomain, opts);
	if (PF_ANEQ(&nk->addr[0], &sk->addr[0], s->af) ||
d219 2
a220 1
		print_host(&sk->addr[0], sk->port[0], s->af, sk->rdomain, opts);
@


1.8
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.7 2009/02/16 00:31:25 dlg Exp $	*/
d132 1
a132 1
print_host(struct pf_addr *addr, u_int16_t port, sa_family_t af, int rdom,
d136 1
a136 1
		printf("(%d) ", rdom);
@


1.7
log
@pfsync v5, mostly written at n2k9, but based on work done at n2k8.

WARNING: THIS BREAKS COMPATIBILITY WITH THE PREVIOUS VERSION OF PFSYNC

this is a new variant of the protocol and a large reworking of the
pfsync code to address some performance issues. the single largest
benefit comes from having multiple pfsync messages of different
types handled in a single packet. pfsyncs handling of pf states is
highly optimised now, along with packet parsing and construction.

huggz for beck@@ for testing.
huge thanks to mcbride@@ for his help during development and for
finding all the bugs during the initial tests.
thanks to peter sutton for letting me get credit for this work.

ok beck@@ mcbride@@ "good." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.6 2008/05/29 01:00:53 mcbride Exp $	*/
d132 2
a133 1
print_host(struct pf_addr *addr, u_int16_t port, sa_family_t af, int opts)
d135 3
d198 1
a198 1
	print_host(&nk->addr[1], nk->port[1], s->af, opts);
d202 1
a202 1
		print_host(&sk->addr[1], sk->port[1], s->af, opts);
d209 1
a209 1
	print_host(&nk->addr[0], nk->port[0], s->af, opts);
d213 1
a213 1
		print_host(&sk->addr[0], sk->port[0], s->af, opts);
@


1.6
log
@Second half of PF state table rearrangement.
- Mechanical change: Use arrays for state key pointers in pf_state, and
  addr/port in pf_state_key, to allow the use of indexes.
- Fix NAT, pfsync, pfctl, and tcpdump to handle the new state structures.
  In struct pfsync_state, both state keys are included even when identical.
- Also fix some bugs discovered in the existing code during testing.
  (in particular, "block return" for TCP packets was not returning an RST)

ok henning beck deraadt
tested by otto dlg beck laurent

Special thanks to users Manuel Pata and Emilio Perea who did enough testing
to actually find some bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.5 2008/05/09 11:57:52 mpf Exp $	*/
d259 1
d266 5
a270 6
		sec = s->expire % 60;
		s->expire /= 60;
		min = s->expire % 60;
		s->expire /= 60;
		printf(", expires in %.2u:%.2u:%.2u",
		    ntohl(s->expire), min, sec);
@


1.5
log
@Don't just ntohl() the hours, but everything of the state
creation time. OK mcbride@@, henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.4 2007/05/31 04:16:26 mcbride Exp $	*/
d132 1
a132 1
print_host(struct pfsync_state_host *h, sa_family_t af, int opts)
a133 2
	u_int16_t p = ntohs(h->port);

d135 1
a135 1
		print_name(&h->addr, af);
d140 1
a140 1
		aw.v.a.addr = h->addr;
d150 1
a150 1
	if (p) {
d152 1
a152 1
			printf(":%u", p);
d154 1
a154 1
			printf("[%u]", p);
d173 1
d179 4
d186 4
d193 7
a199 7
	if (PF_ANEQ(&s->lan.addr, &s->gwy.addr, s->af) ||
	    (s->lan.port != s->gwy.port)) {
		print_host(&s->lan, s->af, opts);
		if (s->direction == PF_OUT)
			printf(" -> ");
		else
			printf(" <- ");
a200 1
	print_host(&s->gwy, s->af, opts);
d205 7
a211 1
	print_host(&s->ext, s->af, opts);
@


1.4
log
@pf_state is no longer the same; modify pf_print_state.c to accept
pfsync_state (as in pfctl, but in network byte order).

ok henning@@ toby@@ pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.3 2005/11/04 08:24:15 mcbride Exp $	*/
d246 1
d248 5
a252 5
		sec = s->creation % 60;
		s->creation /= 60;
		min = s->creation % 60;
		s->creation /= 60;
		printf("\n   age %.2u:%.2u:%.2u", ntohl(s->creation), min, sec);
@


1.3
log
@crank pf_state and pf_src_node byte and packet counters to u_in64_t, since
we're breaking pfsync compatibility this cycle anyways.

Requested by djm@@, ok henning@@, 'wheee!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.2 2004/02/10 20:26:49 mcbride Exp $	*/
d132 1
a132 1
print_host(struct pf_state_host *h, sa_family_t af, int opts)
d161 1
a161 1
print_seq(struct pf_state_peer *p)
d164 2
a165 2
		printf("[%u + %u](+%u)", p->seqlo, p->seqhi - p->seqlo,
		    p->seqdiff);
d167 2
a168 1
		printf("[%u + %u]", p->seqlo, p->seqhi - p->seqlo);
d172 1
a172 1
print_state(struct pf_state *s, int opts)
d174 1
a174 1
	struct pf_state_peer *src, *dst;
d184 1
a184 1
	printf("%s ", s->u.ifname);
d244 3
d251 1
a251 1
		printf("\n   age %.2u:%.2u:%.2u", s->creation, min, sec);
d256 7
a262 1
		printf(", expires in %.2u:%.2u:%.2u", s->expire, min, sec);
d264 8
a271 9
		    s->packets[0], s->packets[1], s->bytes[0], s->bytes[1]);
		if (s->anchor.nr != -1)
			printf(", anchor %u", s->anchor.nr);
		if (s->rule.nr != -1)
			printf(", rule %u", s->rule.nr);
		if (s->src_node != NULL)
			printf(", source-track");
		if (s->nat_src_node != NULL)
			printf(", sticky-address");
d274 3
d278 1
a278 1
		    betoh64(s->id), ntohl(s->creatorid));
@


1.2
log
@Make pfsync printing consistent with rest of tcpdump regarding newlines,
pass -vv in to pf_print_state(), and print update count where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.2 2004/02/10 19:56:44 mcbride Exp $	*/
d253 1
a253 1
		printf(", %u:%u pkts, %u:%u bytes",
@


1.1
log
@privilege separated tcpdump, joint work with otto@@

tested by avsm@@ vincent@@ dhartmei@@ markus@@ hshoexer@@ and others
go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_print_state.c,v 1.37 2003/12/31 11:18:24 cedric Exp $	*/
d54 1
a54 1
	switch(addr->type) {
d119 1
a119 1
		host = getname((char *)&addr->v4);		
d204 1
a204 1
			printf("   %s:%s\n", tcpstates[src->state],
d208 1
a208 1
			printf("   PROXY:SRC\n");
d211 1
a211 1
			printf("   PROXY:DST\n");
d213 1
a213 1
			printf("   <BAD STATE LEVELS %u:%u>\n",
d216 1
a216 1
			printf("   ");
a225 1
			printf("\n");
d231 1
a231 1
		printf("   %s:%s\n", states[src->state], states[dst->state]);
d237 1
a237 1
		printf("   %s:%s\n", states[src->state], states[dst->state]);
d239 1
a239 1
		printf("   %u:%u\n", src->state, dst->state);
d247 1
a247 1
		printf("   age %.2u:%.2u:%.2u", s->creation, min, sec);
a262 1
		printf("\n");
d265 1
a265 1
		printf("   id: %016llx creatorid: %08x\n",
@

