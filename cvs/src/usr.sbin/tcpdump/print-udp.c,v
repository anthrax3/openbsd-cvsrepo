head	1.40;
access;
symbols
	OPENBSD_6_0:1.40.0.6
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.38.0.6
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.16
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.14
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.12
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.10
	OPENBSD_5_0:1.34.0.8
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.6
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.4
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.30.0.10
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.6
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.4
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.8
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.6
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.21.0.6
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2015.12.22.21.01.07;	author mmcc;	state Exp;
branches;
next	1.39;
commitid	2fFDLAOGZEyS0nuD;

1.39
date	2015.11.16.00.16.39;	author mmcc;	state Exp;
branches;
next	1.38;
commitid	enjTsnD5UO6xazKc;

1.38
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	Uu5nFG3wCl0LACBb;

1.37
date	2014.08.14.12.44.44;	author mpi;	state Exp;
branches;
next	1.36;
commitid	yLXrOcgrag4eS8u4;

1.36
date	2014.06.20.04.04.52;	author lteo;	state Exp;
branches;
next	1.35;
commitid	2daJ0iB9vSWHdMTb;

1.35
date	2014.01.26.18.03.27;	author naddy;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.12.06.10.33;	author naddy;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.04.09.43.11;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2009.11.04.07.37.55;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.21.13.41.03;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.31.01.49.17;	author stevesk;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.23.14.20.19;	author stevesk;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.10.18.17.41;	author reyk;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.22.11.36.12;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.28.19.44.55;	author canacar;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.18.15.33.30;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.11.20.58.45;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2002.01.22.18.33.07;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.25.19.56.12;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.09.21.44.41;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.06.16.42.08;	author jakob;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.07.22.52.00;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.07.22.36.46;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.05.08.17.45;	author jakob;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.03.14.21.57;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.05.17.12.08;	author jakob;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.26.21.35.43;	author jakob;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.16.10.54.58;	author jakob;	state Exp;
branches;
next	1.10;

1.10
date	99.09.16.20.58.48;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	99.07.28.20.41.36;	author jakob;	state Exp;
branches;
next	1.8;

1.8
date	98.06.25.19.42.47;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.07.31.09.49.13;	author tqbf;	state Exp;
branches;
next	1.6;

1.6
date	97.07.23.02.59.02;	author denny;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.16.22.24;	author bitblt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.13.11.01.32;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.07.47.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.15.59.41;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.26;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.40
log
@assign pointers to NULL rather than 0
@
text
@/*	$OpenBSD: print-udp.c,v 1.39 2015/11/16 00:16:39 mmcc Exp $	*/

/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include <sys/time.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>

#include <net80211/ieee80211.h>

#ifdef NOERROR
#undef NOERROR					/* Solaris sucks */
#endif
#ifdef T_UNSPEC
#undef T_UNSPEC					/* SINIX does too */
#endif
#include <arpa/nameser.h>
#ifdef SEGSIZE
#undef SEGSIZE
#endif
#include <arpa/tftp.h>

#include <rpc/rpc.h>

#include <stdio.h>
#include <string.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif

#include "interface.h"
#include "addrtoname.h"
#include "extract.h"
#include "appletalk.h"

#include "nfsv2.h"
#include "bootp.h"
#include "iapp.h"

struct rtcphdr {
	u_short rh_flags;	/* T:2 P:1 CNT:5 PT:8 */
	u_short rh_len;		/* length of message (in words) */
	u_int rh_ssrc;		/* synchronization src id */
};

typedef struct {
	u_int upper;		/* more significant 32 bits */
	u_int lower;		/* less significant 32 bits */
} ntp64;

/*
 * Sender report.
 */
struct rtcp_sr {
	ntp64 sr_ntp;		/* 64-bit ntp timestamp */
	u_int sr_ts;		/* reference media timestamp */
	u_int sr_np;		/* no. packets sent */
	u_int sr_nb;		/* no. bytes sent */
};

/*
 * Receiver report.
 * Time stamps are middle 32-bits of ntp timestamp.
 */
struct rtcp_rr {
	u_int rr_srcid;		/* sender being reported */
	u_int rr_nl;		/* no. packets lost */
	u_int rr_ls;		/* extended last seq number received */
	u_int rr_dv;		/* jitter (delay variance) */
	u_int rr_lsr;		/* orig. ts from last rr from this src  */
	u_int rr_dlsr;		/* time from recpt of last rr to xmit time */
};

/*XXX*/
#define RTCP_PT_SR	200
#define RTCP_PT_RR	201
#define RTCP_PT_SDES	202
#define 	RTCP_SDES_CNAME	1
#define 	RTCP_SDES_NAME	2
#define 	RTCP_SDES_EMAIL	3
#define 	RTCP_SDES_PHONE	4
#define 	RTCP_SDES_LOC	5
#define 	RTCP_SDES_TOOL	6
#define 	RTCP_SDES_NOTE	7
#define 	RTCP_SDES_PRIV	8
#define RTCP_PT_BYE	203
#define RTCP_PT_APP	204

static void
vat_print(const void *hdr, u_int len, const struct udphdr *up)
{
	/* vat/vt audio */
	u_int ts = *(u_short *)hdr;
	if ((ts & 0xf060) != 0) {
		/* probably vt */
		(void)printf(" udp/vt %u %d / %d",
			     (u_int32_t)(ntohs(up->uh_ulen) - sizeof(*up)),
			     ts & 0x3ff, ts >> 10);
	} else {
		/* probably vat */
		u_int i0 = ntohl(((u_int *)hdr)[0]);
		u_int i1 = ntohl(((u_int *)hdr)[1]);
		printf(" udp/vat %u c%d %u%s",
			(u_int32_t)(ntohs(up->uh_ulen) - sizeof(*up) - 8),
			i0 & 0xffff,
			i1, i0 & 0x800000? "*" : "");
		/* audio format */
		if (i0 & 0x1f0000)
			printf(" f%d", (i0 >> 16) & 0x1f);
		if (i0 & 0x3f000000)
			printf(" s%d", (i0 >> 24) & 0x3f);
	}
}

static void
rtp_print(const void *hdr, u_int len, const struct udphdr *up)
{
	/* rtp v1 or v2 */
	u_int *ip = (u_int *)hdr;
	u_int hasopt, hasext, contype, hasmarker;
	u_int i0 = ntohl(((u_int *)hdr)[0]);
	u_int i1 = ntohl(((u_int *)hdr)[1]);
	u_int dlen = ntohs(up->uh_ulen) - sizeof(*up) - 8;
	const char * ptype;

	ip += 2;
	len >>= 2;
	len -= 2;
	hasopt = 0;
	hasext = 0;
	if ((i0 >> 30) == 1) {
		/* rtp v1 */
		hasopt = i0 & 0x800000;
		contype = (i0 >> 16) & 0x3f;
		hasmarker = i0 & 0x400000;
		ptype = "rtpv1";
	} else {
		/* rtp v2 */
		hasext = i0 & 0x10000000;
		contype = (i0 >> 16) & 0x7f;
		hasmarker = i0 & 0x800000;
		dlen -= 4;
		ptype = "rtp";
		ip += 1;
		len -= 1;
	}
	printf(" udp/%s %d c%d %s%s %d %u",
		ptype,
		dlen,
		contype,
		(hasopt || hasext)? "+" : "",
		hasmarker? "*" : "",
		i0 & 0xffff,
		i1);
	if (vflag) {
		printf(" %u", i1);
		if (hasopt) {
			u_int i2, optlen;
			do {
				i2 = ip[0];
				optlen = (i2 >> 16) & 0xff;
				if (optlen == 0 || optlen > len) {
					printf(" !opt");
					return;
				}
				ip += optlen;
				len -= optlen;
			} while ((int)i2 >= 0);
		}
		if (hasext) {
			u_int i2, extlen;
			i2 = ip[0];
			extlen = (i2 & 0xffff) + 1;
			if (extlen > len) {
				printf(" !ext");
				return;
			}
			ip += extlen;
		}
		if (contype == 0x1f) /*XXX H.261 */
			printf(" 0x%04x", ip[0] >> 16);
	}
}

static const u_char *
rtcp_print(const u_char *hdr, const u_char *ep)
{
	/* rtp v2 control (rtcp) */
	struct rtcp_rr *rr = NULL;
	struct rtcp_sr *sr;
	struct rtcphdr *rh = (struct rtcphdr *)hdr;
	u_int len;
	u_short flags;
	int cnt;
	double ts, dts;
	if ((u_char *)(rh + 1) > ep) {
		printf(" [|rtcp]");
		return (ep);
	}
	len = (ntohs(rh->rh_len) + 1) * 4;
	flags = ntohs(rh->rh_flags);
	cnt = (flags >> 8) & 0x1f;
	switch (flags & 0xff) {
	case RTCP_PT_SR:
		sr = (struct rtcp_sr *)(rh + 1);
		printf(" sr");
		if (len != cnt * sizeof(*rr) + sizeof(*sr) + sizeof(*rh))
			printf(" [%d]", len);
		if (vflag)
		  printf(" %u", (u_int32_t)ntohl(rh->rh_ssrc));
		if ((u_char *)(sr + 1) > ep) {
			printf(" [|rtcp]");
			return (ep);
		}
		ts = (double)((u_int32_t)ntohl(sr->sr_ntp.upper)) +
		    ((double)((u_int32_t)ntohl(sr->sr_ntp.lower)) /
		    4294967296.0);
		printf(" @@%.2f %u %up %ub", ts, (u_int32_t)ntohl(sr->sr_ts),
		    (u_int32_t)ntohl(sr->sr_np), (u_int32_t)ntohl(sr->sr_nb));
		rr = (struct rtcp_rr *)(sr + 1);
		break;
	case RTCP_PT_RR:
		printf(" rr");
		if (len != cnt * sizeof(*rr) + sizeof(*rh))
			printf(" [%d]", len);
		rr = (struct rtcp_rr *)(rh + 1);
		if (vflag)
		  printf(" %u", (u_int32_t)ntohl(rh->rh_ssrc));
		break;
	case RTCP_PT_SDES:
		printf(" sdes %d", len);
		if (vflag)
		  printf(" %u", (u_int32_t)ntohl(rh->rh_ssrc));
		cnt = 0;
		break;
	case RTCP_PT_BYE:
		printf(" bye %d", len);
		if (vflag)
		  printf(" %u", (u_int32_t)ntohl(rh->rh_ssrc));
		cnt = 0;
		break;
	default:
		printf(" type-0x%x %d", flags & 0xff, len);
		cnt = 0;
		break;
	}
	if (cnt > 1)
		printf(" c%d", cnt);
	while (--cnt >= 0) {
		if ((u_char *)(rr + 1) > ep) {
			printf(" [|rtcp]");
			return (ep);
		}
		if (vflag)
			printf(" %u", (u_int32_t)ntohl(rr->rr_srcid));
		ts = (double)((u_int32_t)ntohl(rr->rr_lsr)) / 65536.;
		dts = (double)((u_int32_t)ntohl(rr->rr_dlsr)) / 65536.;
		printf(" %ul %us %uj @@%.2f+%.2f",
		    (u_int32_t)ntohl(rr->rr_nl) & 0x00ffffff,
		    (u_int32_t)ntohl(rr->rr_ls),
		    (u_int32_t)ntohl(rr->rr_dv), ts, dts);
	}
	return (hdr + len);
}

static int udp_cksum(const struct ip *ip, const struct udphdr *up, int len)
{
	union phu {
		struct phdr {
			u_int32_t src;
			u_int32_t dst;
			u_char mbz;
			u_char proto;
			u_int16_t len;
		} ph;
		u_int16_t pa[6];
	} phu;
	const u_int16_t *sp;
	u_int32_t sum;

	/* pseudo-header.. */
	phu.ph.len = htons((u_int16_t)len);
	phu.ph.mbz = 0;
	phu.ph.proto = IPPROTO_UDP;
	memcpy(&phu.ph.src, &ip->ip_src.s_addr, sizeof(u_int32_t));
	memcpy(&phu.ph.dst, &ip->ip_dst.s_addr, sizeof(u_int32_t));

	sp = &phu.pa[0];
	sum = sp[0]+sp[1]+sp[2]+sp[3]+sp[4]+sp[5];

	return in_cksum((u_short *)up, len, sum);
}

#ifdef INET6
static int udp6_cksum(const struct ip6_hdr *ip6, const struct udphdr *up,
	u_int len)
{
	union {
		struct {
			struct in6_addr ph_src;
			struct in6_addr ph_dst;
			u_int32_t	ph_len;
			u_int8_t	ph_zero[3];
			u_int8_t	ph_nxt;
		} ph;
		u_int16_t pa[20];
	} phu;
	size_t i;
	u_int32_t sum = 0;

	/* pseudo-header */
	memset(&phu, 0, sizeof(phu));
	phu.ph.ph_src = ip6->ip6_src;
	phu.ph.ph_dst = ip6->ip6_dst;
	phu.ph.ph_len = htonl(len);
	phu.ph.ph_nxt = IPPROTO_UDP;

	for (i = 0; i < sizeof(phu.pa) / sizeof(phu.pa[0]); i++)
		sum += phu.pa[i];

	return in_cksum((u_short *)up, len, sum);
}
#endif



/* XXX probably should use getservbyname() and cache answers */
#define TFTP_PORT		69		/*XXX*/
#define KERBEROS_PORT		88		/*XXX*/
#define SUNRPC_PORT		111		/*XXX*/
#define NTP_PORT		123		/*XXX*/
#define NETBIOS_NS_PORT		137		/*XXX*/
#define NETBIOS_DGRAM_PORT	138		/*XXX*/
#define SNMP_PORT		161		/*XXX*/
#define SNMPTRAP_PORT		162		/*XXX*/
#define ISAKMP_PORT		500		/*XXX*/
#define RIP_PORT		520		/*XXX*/
#define TIMED_PORT		525		/*XXX*/
#define KERBEROS_SEC_PORT	750		/*XXX*/
#define LWRES_PORT		921
#define VQP_PORT		1589
#define OLD_RADIUS_AUTH_PORT	1645
#define OLD_RADIUS_ACCT_PORT	1646
#define L2TP_PORT		1701		/*XXX*/
#define RADIUS_AUTH_PORT	1812
#define RADIUS_ACCT_PORT	1813
#define HSRP_PORT		1985		/*XXX*/
#define GTP_C_PORT		2123
#define GTP_U_PORT		2152
#define GTP_PRIME_PORT		3386
#define UDPENCAP_PORT		4500		/*XXX*/
#define MULTICASTDNS_PORT	5353

#ifdef INET6
#define RIPNG_PORT		521		/*XXX*/
#define DHCP6_PORT1		546		/*XXX*/
#define DHCP6_PORT2		547		/*XXX*/
#endif

void
udp_print(const u_char *bp, u_int length, const u_char *bp2)
{
	const struct udphdr *up;
	const struct ip *ip;
	const u_char *cp;
	const u_char *ep = bp + length;
	u_int16_t sport, dport, ulen;
#ifdef INET6
	const struct ip6_hdr *ip6;
#endif

	if (ep > snapend)
		ep = snapend;
	up = (struct udphdr *)bp;
	ip = (struct ip *)bp2;
#ifdef INET6
	if (ip->ip_v == 6)
		ip6 = (struct ip6_hdr *)bp2;
	else
		ip6 = NULL;
#endif /*INET6*/
	cp = (u_char *)(up + 1);
	if (cp > snapend) {
		printf("[|udp]");
		return;
	}
	if (length < sizeof(struct udphdr)) {
		(void)printf(" truncated-udp %d", length);
		return;
	}
	length -= sizeof(struct udphdr);

	sport = ntohs(up->uh_sport);
	dport = ntohs(up->uh_dport);
	ulen = ntohs(up->uh_ulen);
	if (packettype) {
		struct rpc_msg *rp;
		enum msg_type direction;

		switch (packettype) {

		case PT_VAT:
			(void)printf("%s.%s > %s.%s:",
				ipaddr_string(&ip->ip_src),
				udpport_string(sport),
				ipaddr_string(&ip->ip_dst),
				udpport_string(dport));
			vat_print((void *)(up + 1), length, up);
			break;

		case PT_WB:
			(void)printf("%s.%s > %s.%s:",
				ipaddr_string(&ip->ip_src),
				udpport_string(sport),
				ipaddr_string(&ip->ip_dst),
				udpport_string(dport));
			wb_print((void *)(up + 1), length);
			break;

		case PT_RPC:
			(void)printf("%s.%s > %s.%s: ",
				ipaddr_string(&ip->ip_src),
				udpport_string(sport),
				ipaddr_string(&ip->ip_dst),
				udpport_string(dport));
			rp = (struct rpc_msg *)(up + 1);
			direction = (enum msg_type)ntohl(rp->rm_direction);
			if (direction == CALL)
				sunrpcrequest_print((u_char *)rp, length,
				    (u_char *)ip);
			else
				nfsreply_print((u_char *)rp, length,
				    (u_char *)ip);			/*XXX*/
			break;

		case PT_RTP:
			(void)printf("%s.%s > %s.%s:",
				ipaddr_string(&ip->ip_src),
				udpport_string(sport),
				ipaddr_string(&ip->ip_dst),
				udpport_string(dport));
			rtp_print((void *)(up + 1), length, up);
			break;

		case PT_RTCP:
			(void)printf("%s.%s > %s.%s:",
				ipaddr_string(&ip->ip_src),
				udpport_string(sport),
				ipaddr_string(&ip->ip_dst),
				udpport_string(dport));
			while (cp < ep)
				cp = rtcp_print(cp, ep);
			break;
		case PT_CNFP:
			cnfp_print(cp, length, (u_char *)ip);
			break;
		}
		return;
	}

	if (!qflag) {
		struct rpc_msg *rp;
		enum msg_type direction;

		rp = (struct rpc_msg *)(up + 1);
		if (TTEST(rp->rm_direction)) {
			direction = (enum msg_type)ntohl(rp->rm_direction);
			if (dport == NFS_PORT && direction == CALL) {
				(void)printf("%s.%s > %s.%s: ",
					ipaddr_string(&ip->ip_src),
					udpport_string(sport),
					ipaddr_string(&ip->ip_dst),
					udpport_string(dport));
				nfsreq_print((u_char *)rp, length,
				    (u_char *)ip);
				return;
			}
			if (sport == NFS_PORT && direction == REPLY) {
				(void)printf("%s.%s > %s.%s: ",
					ipaddr_string(&ip->ip_src),
					udpport_string(sport),
					ipaddr_string(&ip->ip_dst),
					udpport_string(dport));
				nfsreply_print((u_char *)rp, length,
				    (u_char *)ip);
				return;
			}
#ifdef notdef
			if (dport == SUNRPC_PORT && direction == CALL) {
				(void)printf("%s.%s > %s.%s: ",
					ipaddr_string(&ip->ip_src),
					udpport_string(sport),
					ipaddr_string(&ip->ip_dst),
					udpport_string(dport));
				sunrpcrequest_print((u_char *)rp, length, (u_char *)ip);
				return;
			}
#endif
		}
		if (TTEST(((struct LAP *)cp)->type) &&
		    ((struct LAP *)cp)->type == lapDDP &&
		    (atalk_port(sport) || atalk_port(dport))) {
			if (vflag)
				fputs("kip ", stdout);
			atalk_print_llap(cp, length);
			return;
		}
	}
#if 0
	(void)printf("%s.%s > %s.%s:",
		ipaddr_string(&ip->ip_src), udpport_string(sport),
		ipaddr_string(&ip->ip_dst), udpport_string(dport));
#else
#ifdef INET6
	if (ip6) {
		if (ip6->ip6_nxt == IPPROTO_UDP) {
			(void)printf("%s.%s > %s.%s:",
				ip6addr_string(&ip6->ip6_src),
				udpport_string(sport),
				ip6addr_string(&ip6->ip6_dst),
				udpport_string(dport));
		} else {
			(void)printf("%s > %s: ",
				udpport_string(sport), udpport_string(dport));
		}
	} else
#endif /*INET6*/
	{
		if (ip->ip_p == IPPROTO_UDP) {
			(void)printf("%s.%s > %s.%s:",
				ipaddr_string(&ip->ip_src),
				udpport_string(sport),
				ipaddr_string(&ip->ip_dst),
				udpport_string(dport));
		} else {
			(void)printf("%s > %s:",
				udpport_string(sport), udpport_string(dport));
		}
	}
#endif

	if (ip->ip_v == 4 && vflag) {
		u_int16_t sum, udp_sum = EXTRACT_16BITS(&up->uh_sum);
		if (udp_sum == 0) {
			(void)printf(" [no udp cksum]");
		} else if (TTEST2(cp[0], length)) {
			sum = udp_cksum(ip, up, length + sizeof(struct udphdr));
			if (sum != 0)
				(void)printf(" [bad udp cksum %x! -> %x]", udp_sum,
				    in_cksum_shouldbe(udp_sum, sum));
			else
				(void)printf(" [udp sum ok]");
		}
	}
#ifdef INET6
	if (ip->ip_v == 6 && ip6->ip6_plen && vflag) {
		u_int16_t sum, udp_sum = EXTRACT_16BITS(&up->uh_sum);
		/* for IPv6, UDP checksum is mandatory */
		if (udp_sum == 0) {
			(void)printf(" [invalid udp cksum 0]");
		} else if (TTEST2(cp[0], length)) {
			sum = udp6_cksum(ip6, up, length + sizeof(struct udphdr));
			if (sum != 0)
				(void)printf(" [bad udp cksum %x! -> %x]", udp_sum,
				    in_cksum_shouldbe(udp_sum, sum));
			else
				(void)printf(" [udp sum ok]");
		}
	}
#endif

	if (!qflag) {
#define ISPORT(p) (dport == (p) || sport == (p))
		if (ISPORT(NAMESERVER_PORT))
			ns_print((const u_char *)(up + 1), length, 0);
		else if (ISPORT(MULTICASTDNS_PORT))
			ns_print((const u_char *)(up + 1), length, 1);
		else if (ISPORT(LWRES_PORT))
			lwres_print((const u_char *)(up + 1), length);
		else if (ISPORT(TIMED_PORT))
			timed_print((const u_char *)(up + 1), length);
		else if (ISPORT(TFTP_PORT))
			tftp_print((const u_char *)(up + 1), length);
		else if (ISPORT(IPPORT_BOOTPC) || ISPORT(IPPORT_BOOTPS))
			bootp_print((const u_char *)(up + 1), length,
			    sport, dport);
		else if (ISPORT(RIP_PORT))
			rip_print((const u_char *)(up + 1), length);
		else if (ISPORT(SNMP_PORT) || ISPORT(SNMPTRAP_PORT))
			snmp_print((const u_char *)(up + 1), length);
		else if (ISPORT(NTP_PORT))
			ntp_print((const u_char *)(up + 1), length);
		else if (ISPORT(KERBEROS_PORT) || ISPORT(KERBEROS_SEC_PORT))
			krb_print((const void *)(up + 1), length);
		else if (ISPORT(L2TP_PORT))
			l2tp_print((const u_char *)(up + 1), length);
		else if (ISPORT(UDPENCAP_PORT))
			udpencap_print((const u_char *)(up + 1), length, bp2);
		else if (ISPORT(ISAKMP_PORT))
			ike_print((const u_char *)(up + 1), length);
#if 0
		else if (ISPORT(NETBIOS_NS_PORT))
			nbt_udp137_print((const u_char *)(up + 1), length);
		else if (ISPORT(NETBIOS_DGRAM_PORT))
			nbt_udp138_print((const u_char *)(up + 1), length);
#endif
                else if (ISPORT(OLD_RADIUS_AUTH_PORT) ||
                         ISPORT(OLD_RADIUS_ACCT_PORT) ||
                         ISPORT(RADIUS_AUTH_PORT)     ||
                         ISPORT(RADIUS_ACCT_PORT))
                        radius_print((const u_char *)(up + 1), length);
		else if (dport == 3456)
			vat_print((const void *)(up + 1), length, up);
		else if (ISPORT(IAPP_PORT) || ISPORT(IAPP_OLD_PORT))
			iapp_print((const u_char *)(up + 1), length);
		else if (ISPORT(VQP_PORT))
			vqp_print((const u_char *)(up + 1), length);
#ifdef INET6
		else if (ISPORT(RIPNG_PORT))
			ripng_print((const u_char *)(up + 1), length);
		else if (ISPORT(DHCP6_PORT1) || ISPORT(DHCP6_PORT2)) {
			dhcp6_print((const u_char *)(up + 1), length,
				sport, dport);
		}
#endif /*INET6*/
		else if (ISPORT(GTP_C_PORT) || ISPORT(GTP_U_PORT) ||
		    ISPORT(GTP_PRIME_PORT))
			gtp_print((const u_char *)(up + 1), length,
			    sport, dport);
		/*
		 * Kludge in test for whiteboard packets.
		 */
		else if (dport == 4567)
			wb_print((const void *)(up + 1), length);
		else if (dport == HSRP_PORT)
			hsrp_print((const u_char *)(up + 1), length);
		else
			(void)printf(" udp %u",
			    (u_int32_t)(ulen - sizeof(*up)));
#undef ISPORT
	} else
		(void)printf(" udp %u", (u_int32_t)(ulen - sizeof(*up)));
}
@


1.39
log
@Remove remaining instances of the register keyword.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.38 2015/01/16 06:40:22 deraadt Exp $	*/
d214 1
a214 1
	struct rtcp_rr *rr = 0;
@


1.38
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.37 2014/08/14 12:44:44 mpi Exp $	*/
d115 1
a115 1
vat_print(const void *hdr, u_int len, register const struct udphdr *up)
d141 1
a141 1
rtp_print(const void *hdr, u_int len, register const struct udphdr *up)
d386 1
a386 1
udp_print(register const u_char *bp, u_int length, register const u_char *bp2)
d388 4
a391 4
	register const struct udphdr *up;
	register const struct ip *ip;
	register const u_char *cp;
	register const u_char *ep = bp + length;
d394 1
a394 1
	register const struct ip6_hdr *ip6;
d422 1
a422 1
		register struct rpc_msg *rp;
d487 1
a487 1
		register struct rpc_msg *rp;
@


1.37
log
@No use for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.36 2014/06/20 04:04:52 lteo Exp $	*/
a23 1
#include <sys/param.h>
@


1.36
log
@Instead of showing the difference between a bad checksum and a good
checksum, make tcpdump (with the -v flag) show the actual bad checksum
within the IP/protocol header itself and what the good checksum should
be, e.g. "[bad tcp cksum abcd! -> d1e6]"

This change applies to IP, TCP (over IPv4 and IPv6), UDP (over IPv4 and
IPv6), ICMP, and ICMPv6.  This commit also fixes several inconsistencies
in the way bad checksums were displayed for these protocols.

Tested on amd64, i386, and macppc.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.35 2014/01/26 18:03:27 naddy Exp $	*/
a28 1
#include <netinet/in_systm.h>
@


1.35
log
@show that zero checksums are invalid for UDP over IPv6; input & ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.34 2010/01/12 06:10:33 naddy Exp $	*/
d60 1
d570 3
a572 3
		int sum = up->uh_sum;
		if (sum == 0) {
			(void)printf(" [no cksum]");
d576 2
a577 1
				(void)printf(" [bad udp cksum %x!]", sum);
d584 1
a584 1
		int sum = up->uh_sum;
d586 2
a587 2
		if (sum == 0) {
			(void)printf(" [invalid cksum 0]");
d591 2
a592 1
				(void)printf(" [bad udp cksum %x!]", sum);
@


1.34
log
@Add TCP/UDP checksum display for v6 and clean up the checksum
calculation.  Mostly from tcpdump.org; ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.33 2009/11/04 09:43:11 jsing Exp $	*/
d584 3
a586 1
		if (TTEST2(cp[0], length)) {
@


1.33
log
@Add support to tcpdump for decoding the GPRS Tunnelling Protocol (GTP),
used to carry GPRS data over IP for GSM and UMTS networks. The decoder
understands GTPv0, GTPv0', GTPv1-C, GTPv1-U and GTPv1' traffic, however
at this stage not all TLV fields are fully decoded.

This work has been kindly sponsored by SystemNet AS (www.systemnet.no).

"commit" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.30 2007/10/07 16:41:05 deraadt Exp $	*/
d292 1
a292 3
static int udp_cksum(register const struct ip *ip,
		     register const struct udphdr *up,
		     register int len)
a293 1
	int i, tlen;
d304 1
a304 1
	register const u_int16_t *sp;
a305 1
	tlen = ntohs(ip->ip_len) - ((const char *)up-(const char*)ip);
d308 1
a308 1
	phu.ph.len = htons(tlen);
d310 1
a310 1
	phu.ph.proto = ip->ip_p;
d317 2
a318 1
	sp = (const u_int16_t *)up;
d320 16
a335 2
	for (i=0; i<(tlen&~1); i+= 2)
		sum += *sp++;
d337 6
a342 3
	if (tlen & 1) {
		sum += htons( (*(const char *)sp) << 8);
	}
d344 2
a345 3
	while (sum > 0xffff)
		sum = (sum & 0xffff) + (sum >> 16);
	sum = ~sum & 0xffff;
d347 1
a347 1
	return (sum);
d349 1
d573 13
a585 1
			sum = udp_cksum(ip, up, length);
d592 1
@


1.32
log
@Sort port numbers and fix indentation.
@
text
@d360 3
d621 4
@


1.31
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d340 22
a361 22
#define TFTP_PORT 69		/*XXX*/
#define KERBEROS_PORT 88	/*XXX*/
#define SUNRPC_PORT 111		/*XXX*/
#define SNMP_PORT 161		/*XXX*/
#define NTP_PORT 123		/*XXX*/
#define SNMPTRAP_PORT 162	/*XXX*/
#define RIP_PORT 520		/*XXX*/
#define KERBEROS_SEC_PORT 750	/*XXX*/
#define L2TP_PORT 1701		/*XXX*/
#define ISAKMP_PORT   500	/*XXX*/
#define UDPENCAP_PORT  4500	/*XXX*/
#define TIMED_PORT 525		/*XXX*/
#define NETBIOS_NS_PORT    137	/*XXX*/
#define NETBIOS_DGRAM_PORT 138	/*XXX*/
#define OLD_RADIUS_AUTH_PORT 1645
#define OLD_RADIUS_ACCT_PORT 1646
#define RADIUS_AUTH_PORT     1812
#define RADIUS_ACCT_PORT     1813
#define HSRP_PORT 1985		/*XXX*/
#define VQP_PORT 1589
#define LWRES_PORT 921
#define MULTICASTDNS_PORT 5353
d364 3
a366 3
#define RIPNG_PORT 521		/*XXX*/
#define DHCP6_PORT1 546		/*XXX*/
#define DHCP6_PORT2 547		/*XXX*/
@


1.30
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.29 2006/11/21 13:41:03 markus Exp $	*/
a22 5

#ifndef lint
static const char rcsid[] =
    "@@(#) $Id$ (LBL)";
#endif
@


1.29
log
@try udpencap before ike; ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.28 2006/05/31 01:49:17 stevesk Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.28 2006/05/31 01:49:17 stevesk Exp $ (LBL)";
@


1.28
log
@remove extra space in output; ok markus@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.27 2006/05/23 14:20:19 stevesk Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.27 2006/05/23 14:20:19 stevesk Exp $ (LBL)";
d594 2
a597 2
		else if (ISPORT(UDPENCAP_PORT))
			udpencap_print((const u_char *)(up + 1), length, bp2);
@


1.27
log
@add VLAN Query Protocol (VQP) dissector; ok canacar@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.26 2006/03/10 18:17:41 reyk Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.26 2006/03/10 18:17:41 reyk Exp $ (LBL)";
d531 1
a531 1
			(void)printf("%s.%s > %s.%s: ",
d544 1
a544 1
			(void)printf("%s.%s > %s.%s: ",
d550 1
a550 1
			(void)printf("%s > %s: ",
@


1.26
log
@print IAPP messages for the old IAPP port 2313.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.25 2005/11/22 11:36:12 reyk Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.25 2005/11/22 11:36:12 reyk Exp $ (LBL)";
d364 1
d613 2
@


1.25
log
@add printer for IAPP and hostapd(8) messages

ok canacar@@, tested by aanriot@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.24 2004/01/28 19:44:55 canacar Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.24 2004/01/28 19:44:55 canacar Exp $ (LBL)";
d610 1
a610 1
		else if (ISPORT(IAPP_PORT))
@


1.24
log
@privilege separated tcpdump, joint work with otto@@

tested by avsm@@ vincent@@ dhartmei@@ markus@@ hshoexer@@ and others
go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.22 2003/06/11 20:58:45 markus Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.23 2004/01/18 15:33:30 otto Exp $ (LBL)";
d40 2
d69 1
d610 2
@


1.23
log
@Sync print-domain with tcpdump.org; avoids tcpdump barfing on bogus
DNS traffic.

ok canacar@@ jakob@@
@
text
@d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.22 2003/06/11 20:58:45 markus Exp $ (LBL)";
@


1.22
log
@support for NAT-T (draft-ietf-ipsec-udp-encaps-06.txt); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.21 2002/01/22 18:33:07 mickey Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.21 2002/01/22 18:33:07 mickey Exp $ (LBL)";
d362 1
d568 3
a570 1
			ns_print((const u_char *)(up + 1), length);
@


1.21
log
@HSRP dissector, from Julian Cowley <julian@@lava.net> via tcpdump.org
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.20 2001/06/25 19:56:12 itojun Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.20 2001/06/25 19:56:12 itojun Exp $ (LBL)";
d352 1
d589 2
@


1.20
log
@disable smb decoder, as there seems to be fewer bound checks than needed
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.19 2001/04/09 21:44:41 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.19 2001/04/09 21:44:41 ho Exp $ (LBL)";
d359 1
d614 2
@


1.19
log
@Extend IKE knowledge so we can parse the rest (normally encrypted parts)
of the IKE negotiation. Useful for isakmpd's new -L and -l options.
Also some cleanup. (angelos@@, niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.18 2001/03/06 16:42:08 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.18 2001/03/06 16:42:08 jakob Exp $ (LBL)";
d587 1
d592 1
@


1.18
log
@add lwres (BINDv9 resolver) printing. from tcpdump.org and modified by ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.17 2000/12/07 22:52:00 mickey Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.17 2000/12/07 22:52:00 mickey Exp $ (LBL)";
d586 1
a586 1
			isakmp_print((const u_char *)(up + 1), length);
@


1.17
log
@timed printing; from Ben Smithurst <ben@@scientia.demon.co.uk>; via tcpdump.org
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.16 2000/12/07 22:36:46 mickey Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.16 2000/12/07 22:36:46 mickey Exp $ (LBL)";
d359 1
d566 2
@


1.16
log
@smb printing; from Andrew Tridgell; via tcpdump.org
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.15 2000/12/05 08:17:45 jakob Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.15 2000/12/05 08:17:45 jakob Exp $ (LBL)";
d352 1
d565 2
@


1.15
log
@tcpdump incorrectly print port numbers when parsing NFS (PR#1540)
fix submitted by Grigoriy Orlov <gluk@@ptci.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: print-udp.c,v 1.14 2000/10/03 14:21:57 ho Exp $	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.14 2000/10/03 14:21:57 ho Exp $ (LBL)";
d581 4
@


1.14
log
@Compile with -Wall. Add $OpenBSD$. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.13 2000/05/05 17:12:08 jakob Exp $ (LBL)";
d426 5
d474 5
d484 5
d495 5
@


1.13
log
@#include <string.h>; <goeran@@cdg.chalmers.se>
@
text
@d1 2
d26 1
a26 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.12 2000/04/26 21:35:43 jakob Exp $ (LBL)";
d455 1
a455 1
			cnfp_print(cp, length, ip);
@


1.12
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.11 2000/01/16 10:54:58 jakob Exp $ (LBL)";
d53 1
@


1.11
log
@L2TP support (from KAME)
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.10 1999/09/16 20:58:48 brad Exp $ (LBL)";
d54 4
d291 47
a348 2
#define ISAKMP_UPORT1 7500	/*XXX*/
#define ISAKMP_UPORT2 8500	/*XXX*/
d355 6
a360 1
                                             
d369 4
a372 1
	u_short sport, dport, ulen;
d378 6
d491 1
d495 41
d556 1
a556 3
		else if (ISPORT(ISAKMP_PORT) ||
			ISPORT(ISAKMP_UPORT1) ||
			ISPORT(ISAKMP_UPORT2))
d565 8
@


1.10
log
@bring more inline with tcpdump 3.4
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.9 1999/07/28 20:41:36 jakob Exp $ (LBL)";
d296 1
d449 2
@


1.9
log
@-  Merge some changes from tcpdump 3.4
   -a flag; attempt to convert network and broadcast addresses to names
   Improved signal handling
   Miscellaneous fixes and typos
   OSPF MD5 authentication support

-  -X flag; emacs-hexl print (including ascii)

-  Add ECN bits to TCP and IP headers

-  IKE & IPsec (ESP & AH) support

OK deraadt@@
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.8 1998/06/25 19:42:47 mickey Exp $ (LBL)";
d38 1
d40 2
d43 1
d45 3
@


1.8
log
@add cisco netflow proto printing; not tested w/ version 5, but should work anyways
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.7 1997/07/31 09:49:13 tqbf Exp $ (LBL)";
d289 5
d441 4
@


1.7
log
@Add RADIUS printing support. Blech.
@
text
@d24 1
a24 1
    "@@(#) $Header: /cvs/src/usr.sbin/tcpdump/print-udp.c,v 1.6 1997/07/23 02:59:02 denny Exp $ (LBL)";
d374 3
@


1.6
log
@Better handling for AppleTalk, and netatalk in particular.
Handle native Ethertalk phase 1 & 2 as well as the localtalk encapsulation a la Kinetics FastPath previously handled.
@
text
@d24 1
a24 1
    "@@(#) $Header: /usr/src/usr.sbin/tcpdump/RCS/print-udp.c,v 1.2 1997/07/20 17:16:38 denny Exp denny $ (LBL)";
d289 5
d433 5
@


1.5
log
@*** empty log message ***
@
text
@d24 1
a24 1
    "@@(#) $Header: print-udp.c,v 1.58 96/12/10 23:22:07 leres Exp $ (LBL)";
d403 1
a403 1
			atalk_print(cp, length);
@


1.4
log
@it is 3.2 now.
@
text
@a0 2
/*	$OpenBSD$	*/

d23 2
a24 2
static char rcsid[] =
    "@@(#) Header: print-udp.c,v 1.51 96/06/23 02:26:12 leres Exp (LBL)";
a28 1
#include <sys/types.h>
d39 1
d56 1
a56 1
	u_short rh_len;		/* length of message (in bytes) */
d80 3
a82 3
	u_int rr_srcid;	/* sender being reported */
	u_int rr_nr;		/* no. packets received */
	u_int rr_np;		/* no. packets predicted */
d89 3
a91 3
#define RTCP_PT_SR	0
#define RTCP_PT_RR	1
#define RTCP_PT_SDES	2
d98 4
a101 3
#define 	RTCP_SDES_TXT	7
#define RTCP_PT_BYE	3
#define RTCP_PT_APP	4
d104 1
a104 1
vat_print(const void *hdr, int len, register const struct udphdr *up)
d130 1
a130 1
rtp_print(const void *hdr, int len, register const struct udphdr *up)
d134 1
a134 1
	u_int hasopt, contype, hasmarker;
d137 3
a139 2
	int dlen = ntohs(up->uh_ulen) - sizeof(*up) - 8;
	const char* ptype;
d143 2
d151 1
a151 1
	} else { /*XXX*/
d153 1
a153 1
		hasopt = i0 & 0x20000000;
d161 1
a161 1
	printf(" udp/%s %d c%d %s%s %d",
d165 1
a165 1
		hasopt? "+" : "",
d167 2
a168 1
		i0 & 0xffff);
d170 1
d181 1
d184 11
a194 1
		if (contype == 0x1f)
a195 1
		printf(" %u", i1);
d199 2
a200 2
static const u_char*
rtcp_print(const u_char *hdr)
d203 14
a216 9
	struct rtcp_rr* rr = 0;
	struct rtcp_sr* sr;
	struct rtcphdr* rh = (struct rtcphdr*)hdr;
	int len = (ntohs(rh->rh_len) + 1) * 4;
	u_short flags = ntohs(rh->rh_flags);
	int cnt = (flags >> 8) & 0x1f;
	double ts, dts, jitter;
	if (vflag)
		printf(" %u", (u_int32_t)ntohl(rh->rh_ssrc));
d219 1
a219 1
		sr = (struct rtcp_sr*)(rh + 1);
d223 12
a234 4
		ts = (double)((u_int32_t)ntohl(sr->sr_ts)) / 65536.;
		printf(" @@%.2f %up %ub", ts, (u_int32_t)ntohl(sr->sr_np),
		       (u_int32_t)ntohl(sr->sr_nb));
		rr = (struct rtcp_rr*)(sr + 1);
d240 3
a242 1
		rr = (struct rtcp_rr*)(rh + 1);
d246 2
d252 2
d264 1
a264 1
		if ((u_char*)(rr + 1) > snapend) {
d266 1
a266 1
			return (snapend);
d272 4
a275 5
		jitter = (double)((u_int32_t)ntohl(rr->rr_dv)) / 65536.;
		printf(" %ur %ue %.2fj @@%.2f+%.2f",
		    (u_int32_t)ntohl(rr->rr_nr),
		    (u_int32_t)ntohl(rr->rr_np),
		    jitter, ts, dts);
d291 1
a291 1
udp_print(register const u_char *bp, int length, register const u_char *bp2)
d296 1
d299 2
d367 2
a368 2
			while (cp < snapend)
				cp = rtcp_print(cp);
d374 1
a374 1
	if (! qflag) {
d379 12
a390 9
		direction = (enum msg_type)ntohl(rp->rm_direction);
		if (dport == NFS_PORT && direction == CALL) {
			nfsreq_print((u_char *)rp, length, (u_char *)ip);
			return;
		}
		else if (sport == NFS_PORT && direction == REPLY) {
			nfsreply_print((u_char *)rp, length, (u_char *)ip);
			return;
		}
d392 5
a396 3
		else if (dport == SUNRPC_PORT && direction == CALL) {
			sunrpcrequest_print((u_char *)rp, length, (u_char *)ip);
			return;
d398 2
a399 2
#endif
		else if (((struct LAP *)cp)->type == lapDDP &&
@


1.3
log
@sync to latest
@
text
@d1 1
a1 2
/**//*	$OpenBSD: print-udp.c,v 1.4 1996/05/20 00:41:16 fvdl Exp $	*/
/*	$NetBSD: print-udp.c,v 1.4 1996/05/20 00:41:16 fvdl Exp $	*/
d4 1
a4 1
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994
d26 1
a26 1
    "@@(#) Header: print-udp.c,v 1.37 94/06/10 17:01:42 mccanne Exp (LBL)";
a44 3
#ifdef SOLARIS
#include <tiuser.h>
#endif
a46 1
#include <errno.h>
d53 1
a53 1
#include "nfs.h"
d56 47
a102 1
extern int packettype;
d111 2
a112 2
		(void)printf(" udp/vt %d %d / %d",
			     ntohs(up->uh_ulen) - sizeof(*up),
d116 4
a119 4
		u_int i0 = ((u_int *)hdr)[0];
		u_int i1 = ((u_int *)hdr)[1];
		printf(" udp/vat %d c%d %u%s",
			ntohs(up->uh_ulen) - sizeof(*up) - 8,
d133 1
a133 1
	/* rtp v1 video */
d135 27
a161 6
	u_int i0 = ((u_int *)hdr)[0];
	u_int i1 = ((u_int *)hdr)[1];
	u_int hasopt = i0 & 0x800000;
	u_int contype = (i0 >> 16) & 0x3f;
	printf(" udp/rtp %d c%d %s%s %d",
		ntohs(up->uh_ulen) - sizeof(*up) - 8,
d164 1
a164 1
		i0 & 0x400000? "*" : "",
d166 1
a166 4
	if (contype == 31) {
		ip += 2;
		len >>= 2;
		len -= 2;
d179 3
a181 1
		printf(" 0x%04x", ip[0] >> 16);
d183 13
d197 49
a245 1
		printf(" %u", i1);
d250 1
d256 1
d287 2
a288 1
		case 1:
d296 2
a297 1
		case 2:
d305 2
a306 1
		case 3:
d316 2
a317 1
		case 4:
d325 10
d380 1
a380 1
		else if (dport == RIP_PORT)
d386 2
d396 2
a397 1
			(void)printf(" udp %d", ulen - sizeof(*up));
d400 1
a400 1
		(void)printf(" udp %d", ulen - sizeof(*up));
@


1.2
log
@Updating to the latest LBL release.
Sun's SKIP support added.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: print-udp.c,v 1.3 1995/03/06 19:11:36 mycroft Exp $	*/
d58 1
a58 1
#include "nfsv2.h"
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
