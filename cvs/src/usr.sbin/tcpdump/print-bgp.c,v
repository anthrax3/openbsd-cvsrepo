head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.2
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.18.0.6
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.6
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2016.10.27.08.21.58;	author phessler;	state Exp;
branches;
next	1.19;
commitid	zdFHk6zNsrChhL9l;

1.19
date	2016.10.13.08.48.15;	author phessler;	state Exp;
branches;
next	1.18;
commitid	DBJVA9ZRetYDoqTX;

1.18
date	2015.10.20.11.29.07;	author sthen;	state Exp;
branches;
next	1.17;
commitid	9UmkoROCNGivTqzL;

1.17
date	2015.01.16.06.40.21;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	Uu5nFG3wCl0LACBb;

1.16
date	2014.01.12.11.26.48;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2012.02.19.17.24.05;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.55;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.08.15.53.11;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.07.12.25.36;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.29.09.46.32;	author bluhm;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.07.16.41.05;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.14.17.42.06;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.27.12.38.39;	author canacar;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.15.48.34;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.06.14.17.57.21;	author moritz;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.27.23.03.01;	author cloder;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.03.12.21.12;	author ho;	state Exp;
branches
	1.4.8.1
	1.4.10.1
	1.4.12.1;
next	1.3;

1.3
date	2000.10.03.14.15.55;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.26.21.35.39;	author jakob;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.16.11.43.57;	author jakob;	state Exp;
branches;
next	;

1.4.8.1
date	2005.05.08.05.54.03;	author brad;	state Exp;
branches;
next	;

1.4.10.1
date	2005.05.08.05.48.01;	author brad;	state Exp;
branches;
next	;

1.4.12.1
date	2005.05.21.22.40.13;	author brad;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Huawei squatted on BGP Path Attribute 30, and Cisco squatted on 31.  So,
IANA moved the Large Communities attribute to 32, which is a nice pun on
the problem it is solving.
@
text
@/*	$OpenBSD: print-bgp.c,v 1.19 2016/10/13 08:48:15 phessler Exp $	*/

/*
 * Copyright (C) 1999 WIDE Project.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/time.h>
#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <limits.h>

#include "interface.h"
#include "addrtoname.h"
#include "extract.h"
#include "afnum.h"

struct bgp {
	u_int8_t bgp_marker[16];
	u_int16_t bgp_len;
	u_int8_t bgp_type;
};
#define BGP_SIZE		19	/* unaligned */

#define BGP_OPEN		1
#define BGP_UPDATE		2
#define BGP_NOTIFICATION	3
#define BGP_KEEPALIVE		4
#define BGP_ROUTE_REFRESH	5

struct bgp_open {
	u_int8_t bgpo_marker[16];
	u_int16_t bgpo_len;
	u_int8_t bgpo_type;
	u_int8_t bgpo_version;
	u_int16_t bgpo_myas;
	u_int16_t bgpo_holdtime;
	u_int32_t bgpo_id;
	u_int8_t bgpo_optlen;
	/* options should follow */
};
#define BGP_OPEN_SIZE		29	/* unaligned */

struct bgp_opt {
	u_int8_t bgpopt_type;
	u_int8_t bgpopt_len;
	/* variable length */
};
#define BGP_OPT_CAP		2
#define BGP_OPT_SIZE		2	/* some compilers may pad to 4 bytes */

#define BGP_UPDATE_MINSIZE	23

struct bgp_notification {
	u_int8_t bgpn_marker[16];
	u_int16_t bgpn_len;
	u_int8_t bgpn_type;
	u_int8_t bgpn_major;
	u_int8_t bgpn_minor;
	/* data should follow */
};
#define BGP_NOTIFICATION_SIZE		21	/* unaligned */

struct bgp_route_refresh {
	u_int8_t bgp_marker[16];
	u_int16_t len;
	u_int8_t type;
	u_int8_t afi[2]; /* unaligned; should be u_int16_t */
	u_int8_t res;
	u_int8_t safi;
};
#define BGP_ROUTE_REFRESH_SIZE          23

struct bgp_attr {
	u_int8_t bgpa_flags;
	u_int8_t bgpa_type;
	union {
		u_int8_t len;
		u_int16_t elen;
	} bgpa_len;
#define bgp_attr_len(p) \
	(((p)->bgpa_flags & 0x10) ? \
		ntohs((p)->bgpa_len.elen) : (p)->bgpa_len.len)
#define bgp_attr_off(p) \
	(((p)->bgpa_flags & 0x10) ? 4 : 3)
};

#define BGPTYPE_ORIGIN			1
#define BGPTYPE_AS_PATH			2
#define BGPTYPE_NEXT_HOP		3
#define BGPTYPE_MULTI_EXIT_DISC		4
#define BGPTYPE_LOCAL_PREF		5
#define BGPTYPE_ATOMIC_AGGREGATE	6
#define BGPTYPE_AGGREGATOR		7
#define	BGPTYPE_COMMUNITIES		8	/* RFC1997 */
#define	BGPTYPE_ORIGINATOR_ID		9	/* RFC1998 */
#define	BGPTYPE_CLUSTER_LIST		10	/* RFC1998 */
#define	BGPTYPE_DPA			11	/* draft-ietf-idr-bgp-dpa */
#define	BGPTYPE_ADVERTISERS		12	/* RFC1863 */
#define	BGPTYPE_RCID_PATH		13	/* RFC1863 */
#define BGPTYPE_MP_REACH_NLRI		14	/* RFC2283 */
#define BGPTYPE_MP_UNREACH_NLRI		15	/* RFC2283 */
#define BGPTYPE_EXTD_COMMUNITIES	16	/* RFC4360 */
#define BGPTYPE_AS4_PATH		17	/* RFC4893 */
#define BGPTYPE_AGGREGATOR4		18	/* RFC4893 */
#define BGPTYPE_LARGE_COMMUNITIES	32	/* draft-ietf-idr-large-community */

#define BGP_AS_SET             1
#define BGP_AS_SEQUENCE        2
#define BGP_CONFED_AS_SEQUENCE 3 /* draft-ietf-idr-rfc3065bis-01 */
#define BGP_CONFED_AS_SET      4 /* draft-ietf-idr-rfc3065bis-01  */

static struct tok bgp_as_path_segment_open_values[] = {
	{ BGP_AS_SET,			" {" },
	{ BGP_AS_SEQUENCE,		" " },
	{ BGP_CONFED_AS_SEQUENCE,	" (" },
	{ BGP_CONFED_AS_SET,		" ({" },
	{ 0, NULL},
};

static struct tok bgp_as_path_segment_close_values[] = {
	{ BGP_AS_SET,			"}" },
	{ BGP_AS_SEQUENCE,		"" },
	{ BGP_CONFED_AS_SEQUENCE,	")" },
	{ BGP_CONFED_AS_SET,		"})" },
	{ 0, NULL},
};

#define BGP_MP_NLRI_MINSIZE		3

static const char *bgptype[] = {
	NULL, "OPEN", "UPDATE", "NOTIFICATION", "KEEPALIVE", "ROUTE-REFRESH",
};
#define bgp_type(x) num_or_str(bgptype, sizeof(bgptype)/sizeof(bgptype[0]), (x))

static const char *bgpopt_type[] = {
	NULL, "Authentication Information", "Capabilities Advertisement",
};
#define bgp_opttype(x) \
	num_or_str(bgpopt_type, sizeof(bgpopt_type)/sizeof(bgpopt_type[0]), (x))

#define BGP_CAPCODE_MP			1
#define BGP_CAPCODE_REFRESH		2
#define BGP_CAPCODE_RESTART		64 /* draft-ietf-idr-restart-05  */
#define BGP_CAPCODE_AS4			65 /* RFC4893 */

static const char *bgp_capcode[] = {
	NULL, "MULTI_PROTOCOL", "ROUTE_REFRESH",
	/* 3: RFC5291 */ "OUTBOUND_ROUTE_FILTERING",
	/* 4: RFC3107 */ "MULTIPLE_ROUTES",
	/* 5: RFC5549 */ "EXTENDED_NEXTHOP_ENCODING",
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 64: RFC4724 */ "GRACEFUL_RESTART",
	/* 65: RFC4893 */ "AS4", 0,
	/* 67: [Chen] */ "DYNAMIC_CAPABILITY",
	/* 68: [Appanna] */ "MULTISESSION",
	/* 69: [draft-ietf-idr-add-paths] */ "ADD-PATH",
};

#define bgp_capcode(x) \
	num_or_str(bgp_capcode, sizeof(bgp_capcode)/sizeof(bgp_capcode[0]), (x))

#define BGP_NOTIFY_MAJOR_CEASE		6
static const char *bgpnotify_major[] = {
	NULL, "Message Header Error",
	"OPEN Message Error", "UPDATE Message Error",
	"Hold Timer Expired", "Finite State Machine Error",
	"Cease", "Capability Message Error",
};
#define bgp_notify_major(x) \
	num_or_str(bgpnotify_major, \
		sizeof(bgpnotify_major)/sizeof(bgpnotify_major[0]), (x))

static const char *bgpnotify_minor_msg[] = {
	NULL, "Connection Not Synchronized",
	"Bad Message Length", "Bad Message Type",
};

static const char *bgpnotify_minor_open[] = {
	NULL, "Unsupported Version Number",
	"Bad Peer AS", "Bad BGP Identifier",
	"Unsupported Optional Parameter", "Authentication Failure",
	"Unacceptable Hold Time", "Unsupported Capability",
};

static const char *bgpnotify_minor_update[] = {
	NULL, "Malformed Attribute List",
	"Unrecognized Well-known Attribute", "Missing Well-known Attribute",
	"Attribute Flags Error", "Attribute Length Error",
	"Invalid ORIGIN Attribute", "AS Routing Loop",
	"Invalid NEXT_HOP Attribute", "Optional Attribute Error",
	"Invalid Network Field", "Malformed AS_PATH",
};

/* RFC 4486 */
#define BGP_NOTIFY_MINOR_CEASE_MAXPRFX  1
static const char *bgpnotify_minor_cease[] = {
	NULL, "Maximum Number of Prefixes Reached", "Administratively Shutdown",
	"Peer De-configured", "Administratively Reset", "Connection Rejected",
	"Other Configuration Change", "Connection Collision Resolution",
	"Out of Resources",
};

static const char *bgpnotify_minor_cap[] = {
	NULL, "Invalid Action Value", "Invalid Capability Length",
	"Malformed Capability Value", "Unsupported Capability Code",
};

static const char **bgpnotify_minor[] = {
	NULL, bgpnotify_minor_msg, bgpnotify_minor_open, bgpnotify_minor_update,
};
static const int bgpnotify_minor_siz[] = {
	0,
	sizeof(bgpnotify_minor_msg)/sizeof(bgpnotify_minor_msg[0]),
	sizeof(bgpnotify_minor_open)/sizeof(bgpnotify_minor_open[0]),
	sizeof(bgpnotify_minor_update)/sizeof(bgpnotify_minor_update[0]),
	0,
	0,
	sizeof(bgpnotify_minor_cease)/sizeof(bgpnotify_minor_cease[0]),
	sizeof(bgpnotify_minor_cap)/sizeof(bgpnotify_minor_cap[0]),
};

static const char *bgpattr_origin[] = {
	"IGP", "EGP", "INCOMPLETE",
};
#define bgp_attr_origin(x) \
	num_or_str(bgpattr_origin, \
		sizeof(bgpattr_origin)/sizeof(bgpattr_origin[0]), (x))

static const char *bgpattr_type[] = {
	NULL, "ORIGIN", "AS_PATH", "NEXT_HOP",
	"MULTI_EXIT_DISC", "LOCAL_PREF", "ATOMIC_AGGREGATE", "AGGREGATOR",
	"COMMUNITIES", "ORIGINATOR_ID", "CLUSTER_LIST", "DPA",
	"ADVERTISERS", "RCID_PATH", "MP_REACH_NLRI", "MP_UNREACH_NLRI",
	"EXTD_COMMUNITIES", "AS4_PATH", "AGGREGATOR4", NULL, NULL, NULL,
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
	"LARGE_COMMUNITIES",
};
#define bgp_attr_type(x) \
	num_or_str(bgpattr_type, \
		sizeof(bgpattr_type)/sizeof(bgpattr_type[0]), (x))

/* Subsequent address family identifier, RFC2283 section 7 */
static const char *bgpattr_nlri_safi[] = {
	"Reserved", "Unicast", "Multicast", "Unicast+Multicast",
	"labeled Unicast", /* MPLS BGP RFC3107 */
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	/* 64-66: MPLS BGP RFC3107 */
	"Tunnel", "VPLS", "MDT",
};
#define bgp_attr_nlri_safi(x) \
	num_or_str(bgpattr_nlri_safi, \
		sizeof(bgpattr_nlri_safi)/sizeof(bgpattr_nlri_safi[0]), (x))

/* well-known community */
#define BGP_COMMUNITY_NO_EXPORT			0xffffff01
#define BGP_COMMUNITY_NO_ADVERT			0xffffff02
#define BGP_COMMUNITY_NO_EXPORT_SUBCONFED	0xffffff03
#define BGP_COMMUNITY_NO_PEER			0xffffff04

static const char *afnumber[] = AFNUM_NAME_STR;
#define af_name(x) \
	(((x) == 65535) ? afnumber[0] : \
		num_or_str(afnumber, \
			sizeof(afnumber)/sizeof(afnumber[0]), (x)))


static const char *
num_or_str(const char **table, size_t siz, int value)
{
	static char buf[20];
	if (value < 0 || siz <= value || table[value] == NULL) {
		snprintf(buf, sizeof(buf), "#%d", value);
		return buf;
	} else
		return table[value];
}

static const char *
bgp_notify_minor(int major, int minor)
{
	static const char **table;
	int siz;
	static char buf[20];
	const char *p;

	if (0 <= major
	 && major < sizeof(bgpnotify_minor)/sizeof(bgpnotify_minor[0])
	 && bgpnotify_minor[major]) {
		table = bgpnotify_minor[major];
		siz = bgpnotify_minor_siz[major];
		if (0 <= minor && minor < siz && table[minor])
			p = table[minor];
		else
			p = NULL;
	} else
		p = NULL;
	if (p == NULL) {
		snprintf(buf, sizeof(buf), "#%d", minor);
		return buf;
	} else
		return p;
}

static int
decode_prefix4(const u_char *pd, char *buf, u_int buflen)
{
	struct in_addr addr;
	u_int plen;
	int n;

	TCHECK(pd[0]);
	plen = pd[0]; /*
		       * prefix length is in bits; packet only contains
		       * enough bytes of address to contain this many bits
		       */
	plen = pd[0];
	if (plen < 0 || 32 < plen)
		return -1;
	memset(&addr, 0, sizeof(addr));
	TCHECK2(pd[1], (plen + 7) / 8);
	memcpy(&addr, &pd[1], (plen + 7) / 8);
	if (plen % 8) {
		((u_char *)&addr)[(plen + 7) / 8 - 1] &=
			((0xff00 >> (plen % 8)) & 0xff);
	}
	n = snprintf(buf, buflen, "%s/%u", getname((u_char *)&addr), plen);
	if (n == -1 || n >= buflen)
		return -1;

	return 1 + (plen + 7) / 8;

trunc:
	return -2;
}

#ifdef INET6
static int
decode_prefix6(const u_char *pd, char *buf, u_int buflen)
{
	struct in6_addr addr;
	u_int plen;
	int n;

	TCHECK(pd[0]);
	plen = pd[0];
	if (plen < 0 || 128 < plen)
		return -1;

	memset(&addr, 0, sizeof(addr));
	TCHECK2(pd[1], (plen + 7) / 8);
	memcpy(&addr, &pd[1], (plen + 7) / 8);
	if (plen % 8) {
		addr.s6_addr[(plen + 7) / 8 - 1] &=
			((0xff00 >> (plen % 8)) & 0xff);
	}

	n = snprintf(buf, buflen, "%s/%u", getname6((u_char *)&addr), plen);
	if (n == -1 || n >= buflen)
		return -1;

	return 1 + (plen + 7) / 8;

trunc:
	return -2;
}
#endif

static int
bgp_attr_print(const struct bgp_attr *attr, const u_char *dat, int len)
{
	int i;
	u_int16_t af;
	u_int8_t safi, snpa;
	int advance;
	int tlen, asn_bytes;
	const u_char *p;
	char buf[HOST_NAME_MAX+1 + 100];

	p = dat;
	tlen = len;
	asn_bytes = 0;

	switch (attr->bgpa_type) {
	case BGPTYPE_ORIGIN:
		if (len != 1)
			printf(" invalid len");
		else {
			TCHECK(p[0]);
			printf(" %s", bgp_attr_origin(p[0]));
		}
		break;
	case BGPTYPE_AS4_PATH:
		asn_bytes = 4;
		/* FALLTHROUGH */
	case BGPTYPE_AS_PATH:
	/*
	 * 2-byte speakers will receive AS4_PATH as well AS_PATH (2-byte).
	 * 4-byte speakers will only receive AS_PATH but it will be 4-byte.
	 * To identify which is the case, compare the length of the path
	 * segment value in bytes, with the path segment length from the
	 * message (counted in # of AS)
	 */
	 
		if (len % 2) {
			printf(" invalid len");
			break;
		}
		if (!len) {
			/* valid: local originated routes to IBGP peers */
			printf(" empty");
			break;
		}
		while (p < dat + len) {
			TCHECK2(p[0], 2);
			if (asn_bytes == 0) {
				if (p[1] == 0) {
				/* invalid: segment contains one or more AS */
					printf(" malformed");
					break;
				}
				asn_bytes = (len-2)/p[1];
			}
			printf("%s",
			    tok2str(bgp_as_path_segment_open_values,
			    "?", p[0]));
			for (i = 0; i < p[1] * asn_bytes; i += asn_bytes) {
				TCHECK2(p[2 + i], asn_bytes);
				printf("%s", i == 0 ? "" : " ");
				if (asn_bytes == 2 || EXTRACT_16BITS(&p[2 + i]))
					printf("%u%s",
					    EXTRACT_16BITS(&p[2 + i]),
					    asn_bytes == 4 ? "." : "");
				if (asn_bytes == 4)
					printf("%u",
					    EXTRACT_16BITS(&p[2 + i + 2]));
			}
			printf("%s",
			    tok2str(bgp_as_path_segment_close_values,
			    "?", p[0]));
			p += 2 + p[1] * asn_bytes;
		}
		break;
	case BGPTYPE_NEXT_HOP:
		if (len != 4)
			printf(" invalid len");
		else {
			TCHECK2(p[0], 4);
			printf(" %s", getname(p));
		}
		break;
	case BGPTYPE_MULTI_EXIT_DISC:
	case BGPTYPE_LOCAL_PREF:
		if (len != 4)
			printf(" invalid len");
		else {
			TCHECK2(p[0], 4);
			printf(" %u", EXTRACT_32BITS(p));
		}
		break;
	case BGPTYPE_ATOMIC_AGGREGATE:
		if (len != 0)
			printf(" invalid len");
		break;
	case BGPTYPE_AGGREGATOR4:
	case BGPTYPE_AGGREGATOR:
	/*
	 * like AS_PATH/AS4_PATH, AGGREGATOR can contain
	 * either 2-byte or 4-byte ASN, and AGGREGATOR4
	 * always contains 4-byte ASN.
	 */
		if (len != 6 && len != 8) {
			printf(" invalid len");
			break;
		}
		TCHECK2(p[0], len);
		printf(" AS #");
		if (len == 6 || EXTRACT_16BITS(p))
			printf("%u%s", EXTRACT_16BITS(p), len == 8 ? "." : "");
		if (len == 8)
			printf("%u", EXTRACT_16BITS(p+2));
		printf(", origin %s", getname(p+len-4));
		break;
	case BGPTYPE_COMMUNITIES:
		if (len % 4) {
			printf(" invalid len");
			break;
		}
		while (tlen>0) {
			u_int32_t comm;
			TCHECK2(p[0], 4);
			comm = EXTRACT_32BITS(p);
			switch (comm) {
			case BGP_COMMUNITY_NO_EXPORT:
				printf(" NO_EXPORT");
				break;
			case BGP_COMMUNITY_NO_ADVERT:
				printf(" NO_ADVERTISE");
				break;
			case BGP_COMMUNITY_NO_EXPORT_SUBCONFED:
				printf(" NO_EXPORT_SUBCONFED");
				break;
			case BGP_COMMUNITY_NO_PEER:
				printf(" NO_PEER");
				break;
			default:
				printf(" %d:%d",
					(comm >> 16) & 0xffff, comm & 0xffff);
				break;
			}
			tlen -= 4;
			p += 4;
		}
		break;
	case BGPTYPE_LARGE_COMMUNITIES:
		if (len == 0 || len % 12) {
			printf(" invalid len");
			break;
		}
		while (tlen>0) {
			TCHECK2(p[0], 12);
			printf(" %u:%u:%u",
			EXTRACT_32BITS(p),
			EXTRACT_32BITS(p + 4),
			EXTRACT_32BITS(p + 8));
			tlen -= 12;
			p += 12;
		}
		break;
	case BGPTYPE_ORIGINATOR_ID:
		if (len != 4) {
			printf(" invalid len");
			break;
                }
		TCHECK2(p[0], 4);
		printf("%s",getname(p));
		break;
	case BGPTYPE_CLUSTER_LIST:
		if (len % 4) {
			printf(" invalid len");
			break;
		}
		while (tlen>0) {
			TCHECK2(p[0], 4);
			printf(" %s%s",
			    getname(p),
			    (tlen>4) ? ", " : "");
			tlen -=4;
			p +=4;
		}
		break;
	case BGPTYPE_MP_REACH_NLRI:
		TCHECK2(p[0], BGP_MP_NLRI_MINSIZE);
		af = EXTRACT_16BITS(p);
		safi = p[2];
		if (safi >= 128)
			printf(" %s vendor specific %u,", af_name(af), safi);
		else {
			printf(" %s %s,", af_name(af),
				bgp_attr_nlri_safi(safi));
		}
		p += 3;

		if (af == AFNUM_INET)
			;
#ifdef INET6
		else if (af == AFNUM_INET6)
			;
#endif
		else
			break;

		TCHECK(p[0]);
		tlen = p[0];
		if (tlen) {
			printf(" nexthop");
			i = 0;
			while (i < tlen) {
				switch (af) {
				case AFNUM_INET:
					TCHECK2(p[1+i], sizeof(struct in_addr));
					printf(" %s", getname(p + 1 + i));
					i += sizeof(struct in_addr);
					break;
#ifdef INET6
				case AFNUM_INET6:
					TCHECK2(p[1+i], sizeof(struct in6_addr));
					printf(" %s", getname6(p + 1 + i));
					i += sizeof(struct in6_addr);
					break;
#endif
				default:
					printf(" (unknown af)");
					i = tlen;	/*exit loop*/
					break;
				}
			}
			printf(",");
		}
		p += 1 + tlen;

		TCHECK(p[0]);
		snpa = p[0];
		p++;
		if (snpa) {
			printf(" %u snpa", snpa);
			for (/*nothing*/; snpa > 0; snpa--) {
				TCHECK(p[0]);
				printf("(%d bytes)", p[0]);
				p += p[0] + 1;
			}
			printf(",");
		}

		printf(" NLRI");
		while (len - (p - dat) > 0) {
			switch (af) {
			case AFNUM_INET:
				advance = decode_prefix4(p, buf, sizeof(buf));
				break;
#ifdef INET6
			case AFNUM_INET6:
				advance = decode_prefix6(p, buf, sizeof(buf));
				break;
#endif
			default:
				printf(" (unknown af)");
				advance = 0;
				p = dat + len;
				break;
			}

			if (advance <= 0)
				break;

			printf(" %s", buf);
			p += advance;
		}

		break;

	case BGPTYPE_MP_UNREACH_NLRI:
		TCHECK2(p[0], BGP_MP_NLRI_MINSIZE);
		af = EXTRACT_16BITS(p);
		safi = p[2];
		if (safi >= 128)
			printf(" %s vendor specific %u,", af_name(af), safi);
		else {
			printf(" %s %s,", af_name(af),
				bgp_attr_nlri_safi(safi));
		}
		p += 3;

		printf(" Withdraw");
		while (len - (p - dat) > 0) {
			switch (af) {
			case AFNUM_INET:
				advance = decode_prefix4(p, buf, sizeof(buf));
				break;
#ifdef INET6
			case AFNUM_INET6:
				advance = decode_prefix6(p, buf, sizeof(buf));
				break;
#endif
			default:
				printf(" (unknown af)");
				advance = 0;
				p = dat + len;
				break;
			}

			if (advance <= 0)
				break;

			printf(" %s", buf);
			p += advance;
		}
		break;
	default:
		break;
	}
	return 1;

trunc:
	return 0;
}

static void
bgp_open_capa_print(const u_char *opt, int length)
{
	int i,cap_type,cap_len,tcap_len,cap_offset;

	i = 0;
	while (i < length) {
		TCHECK2(opt[i], 2);

		cap_type=opt[i];
		cap_len=opt[i+1];
		printf("%sCAP %s", i == 0 ? "(" : " ", 		/* ) */
		    bgp_capcode(cap_type));

		/* can we print the capability? */
		TCHECK2(opt[i+2],cap_len);
		i += 2;

		switch(cap_type) {
		case BGP_CAPCODE_MP:
			if (cap_len != 4) {
				printf(" BAD ENCODING");
				break;
			}
			printf(" [%s %s]",
			    af_name(EXTRACT_16BITS(opt+i)),
			    bgp_attr_nlri_safi(opt[i+3]));
			break;
		case BGP_CAPCODE_REFRESH:
			if (cap_len != 0) {
				printf(" BAD ENCODING");
				break;
			}
			break;
		case BGP_CAPCODE_RESTART:
			if (cap_len < 2 || (cap_len - 2) % 4) {
				printf(" BAD ENCODING");
				break;
			}
			printf(" [%s], Time %us",
			    ((opt[i])&0x80) ? "R" : "none",
			    EXTRACT_16BITS(opt+i)&0xfff);
			tcap_len=cap_len - 2;
			cap_offset=2;
			while(tcap_len>=4) {
				printf(" (%s %s)%s",
				    af_name(EXTRACT_16BITS(opt+i+cap_offset)),
				    bgp_attr_nlri_safi(opt[i+cap_offset+2]),
				    ((opt[i+cap_offset+3])&0x80) ?
					" forwarding state preserved" : "" );
				tcap_len-=4;
				cap_offset+=4;
			}
			break;
		case BGP_CAPCODE_AS4:
			if (cap_len != 4) {
				printf(" BAD ENCODING");
				break;
			}
			printf(" #");
			if (EXTRACT_16BITS(opt+i))
				printf("%u.",
				    EXTRACT_16BITS(opt+i));
			printf("%u",
			    EXTRACT_16BITS(opt+i+2));
			break;
		default:
			printf(" len %d", cap_len);
			break;
		}
		i += cap_len;
		if (i + cap_len < length)
			printf(",");
	}
	/* ( */
	printf(")");
	return;
trunc:
	printf("[|BGP]");
}

static void
bgp_open_print(const u_char *dat, int length)
{
	struct bgp_open bgpo;
	struct bgp_opt bgpopt;
	const u_char *opt;
	int i;

	TCHECK2(dat[0], BGP_OPEN_SIZE);
	memcpy(&bgpo, dat, BGP_OPEN_SIZE);

	printf(": Version %d,", bgpo.bgpo_version);
	printf(" AS #%u,", ntohs(bgpo.bgpo_myas));
	printf(" Holdtime %u,", ntohs(bgpo.bgpo_holdtime));
	printf(" ID %s,", getname((u_char *)&bgpo.bgpo_id));
	printf(" Option length %u", bgpo.bgpo_optlen);

	/* sanity checking */
	if ((length < bgpo.bgpo_optlen+BGP_OPEN_SIZE) || (!bgpo.bgpo_optlen))
		return;

	/* ugly! */
	opt = &((const struct bgp_open *)dat)->bgpo_optlen;
	opt++;

	i = 0;
	while (i < bgpo.bgpo_optlen) {
		TCHECK2(opt[i], BGP_OPT_SIZE);
		memcpy(&bgpopt, &opt[i], BGP_OPT_SIZE);
		if (i + 2 + bgpopt.bgpopt_len > bgpo.bgpo_optlen) {
			printf(" [|opt %d %d]", bgpopt.bgpopt_len, bgpopt.bgpopt_type);
			break;
		}

		if (i == 0)
			printf(" (");		/* ) */
		else
			printf(" ");

		switch(bgpopt.bgpopt_type) {
		case BGP_OPT_CAP:
			bgp_open_capa_print(opt + i + BGP_OPT_SIZE,
			    bgpopt.bgpopt_len);
			break;
		default:
			printf(" (option %s, len=%u)",
			    bgp_opttype(bgpopt.bgpopt_type),
			    bgpopt.bgpopt_len);
			break;
		}

		i += BGP_OPT_SIZE + bgpopt.bgpopt_len;
	}
	/* ( */
	printf(")");	
	return;
trunc:
	printf("[|BGP]");
}

static void
bgp_update_print(const u_char *dat, int length)
{
	struct bgp bgp;
	struct bgp_attr bgpa;
	const u_char *p;
	int len;
	int i;
	int newline;

	TCHECK2(dat[0], BGP_SIZE);
	memcpy(&bgp, dat, BGP_SIZE);
	p = dat + BGP_SIZE;	/*XXX*/
	printf(":");

	/* Unfeasible routes */
	len = EXTRACT_16BITS(p);
	if (len) {
		/*
		 * Without keeping state from the original NLRI message,
		 * it's not possible to tell if this a v4 or v6 route,
		 * so only try to decode it if we're not v6 enabled.
	         */
#ifdef INET6
		printf(" (Withdrawn routes: %d bytes)", len);
#else	
		char buf[HOST_NAME_MAX+1 + 100];
		int wpfx;

		TCHECK2(p[2], len);
 		i = 2;

		printf(" (Withdrawn routes:");
			
		while(i < 2 + len) {
			wpfx = decode_prefix4(&p[i], buf, sizeof(buf));
			if (wpfx == -1) {
				printf(" (illegal prefix length)");
				break;
			} else if (wpfx == -2)
				goto trunc;
			i += wpfx;
			printf(" %s", buf);
		}
		printf(")");
#endif
	}
	p += 2 + len;

	TCHECK2(p[0], 2);
	len = EXTRACT_16BITS(p);

	if (len == 0 && length == BGP_UPDATE_MINSIZE) {
		printf(" End-of-Rib Marker (empty NLRI)");
		return;
	}

	if (len) {
		/* do something more useful!*/
		i = 2;
		printf(" (Path attributes:");	/* ) */
		newline = 0;
		while (i < 2 + len) {
			int alen, aoff;

			TCHECK2(p[i], sizeof(bgpa));
			memcpy(&bgpa, &p[i], sizeof(bgpa));
			alen = bgp_attr_len(&bgpa);
			aoff = bgp_attr_off(&bgpa);

			if (vflag && newline)
				printf("\n\t\t");
			else
				printf(" ");
			printf("(");		/* ) */
			printf("%s", bgp_attr_type(bgpa.bgpa_type));
			if (bgpa.bgpa_flags) {
				printf("[%s%s%s%s",
					bgpa.bgpa_flags & 0x80 ? "O" : "",
					bgpa.bgpa_flags & 0x40 ? "T" : "",
					bgpa.bgpa_flags & 0x20 ? "P" : "",
					bgpa.bgpa_flags & 0x10 ? "E" : "");
				if (bgpa.bgpa_flags & 0xf)
					printf("+%x", bgpa.bgpa_flags & 0xf);
				printf("]");
			}

			if (!bgp_attr_print(&bgpa, &p[i + aoff], alen))
				goto trunc;
			newline = 1;

			/* ( */
			printf(")");	

			i += aoff + alen;
		}

		/* ( */
		printf(")");
	}
	p += 2 + len;

	if (len && dat + length > p)
		printf("\n\t\t");
	if (dat + length > p) {
		printf("(NLRI:");	/* ) */
		while (dat + length > p) {
			char buf[HOST_NAME_MAX+1 + 100];
			i = decode_prefix4(p, buf, sizeof(buf));
			if (i == -1) {
				printf(" (illegal prefix length)");
				break;
			} else if (i == -2)
				goto trunc;
			printf(" %s", buf);
			p += i;
		}

		/* ( */
		printf(")");
	}
	return;
trunc:
	printf("[|BGP]");
}

static void
bgp_notification_print(const u_char *dat, int length)
{
	struct bgp_notification bgpn;
	u_int16_t af;
	u_int8_t safi;
	const u_char *p;

	TCHECK2(dat[0], BGP_NOTIFICATION_SIZE);
	memcpy(&bgpn, dat, BGP_NOTIFICATION_SIZE);

	/* sanity checking */
	if (length<BGP_NOTIFICATION_SIZE)
		return;

	printf(": error %s,", bgp_notify_major(bgpn.bgpn_major));
	printf(" subcode %s",
		bgp_notify_minor(bgpn.bgpn_major, bgpn.bgpn_minor));

	if (bgpn.bgpn_major == BGP_NOTIFY_MAJOR_CEASE) {
		/*
		 * RFC 4486: optional maxprefix subtype of 7 bytes
		 * may contain AFI, SAFI and MAXPREFIXES
		 */
		if(bgpn.bgpn_minor == BGP_NOTIFY_MINOR_CEASE_MAXPRFX && 
		    length >= BGP_NOTIFICATION_SIZE + 7) {

			p = dat + BGP_NOTIFICATION_SIZE;
			TCHECK2(*p, 7);

			af = EXTRACT_16BITS(p);
			safi = p[2];
			printf(" %s %s,", af_name(af),
			    bgp_attr_nlri_safi(safi));

			printf(" Max Prefixes: %u", EXTRACT_32BITS(p+3));
		}
	}

	return;
trunc:
	printf("[|BGP]");
}

static void
bgp_route_refresh_print(const u_char *dat, int length)
{
	const struct bgp_route_refresh *bgp_route_refresh_header;

	TCHECK2(dat[0], BGP_ROUTE_REFRESH_SIZE);

	/* sanity checking */
	if (length<BGP_ROUTE_REFRESH_SIZE)
		return;

	bgp_route_refresh_header = (const struct bgp_route_refresh *)dat;

	printf(" (%s %s)",
	    af_name(EXTRACT_16BITS(&bgp_route_refresh_header->afi)),
	    bgp_attr_nlri_safi(bgp_route_refresh_header->safi));

	return;
trunc:
	printf("[|BGP]");
}

static int
bgp_header_print(const u_char *dat, int length)
{
	struct bgp bgp;

	TCHECK2(dat[0], BGP_SIZE);
	memcpy(&bgp, dat, BGP_SIZE);
	printf("(%s", bgp_type(bgp.bgp_type));		/* ) */

	switch (bgp.bgp_type) {
	case BGP_OPEN:
		bgp_open_print(dat, length);
		break;
	case BGP_UPDATE:
		bgp_update_print(dat, length);
		break;
	case BGP_NOTIFICATION:
		bgp_notification_print(dat, length);
		break;
	case BGP_KEEPALIVE:
		break;
	case BGP_ROUTE_REFRESH:
		bgp_route_refresh_print(dat, length);
	default:
		TCHECK2(*dat, length);
		break;
	}

	/* ( */
	printf(")");
	return 1;
trunc:
	printf("[|BGP]");
	return 0;
}

void
bgp_print(const u_char *dat, int length)
{
	const u_char *p;
	const u_char *ep;
	const u_char *start;
	const u_char marker[] = {
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	};
	struct bgp bgp;
	u_int16_t hlen;
	int newline;

	ep = dat + length;
	if (snapend < dat + length)
		ep = snapend;

	printf(": BGP");

	p = dat;
	newline = 0;
	start = p;
	while (p < ep) {
		if (!TTEST2(p[0], 1))
			break;
		if (p[0] != 0xff) {
			p++;
			continue;
		}

		if (!TTEST2(p[0], sizeof(marker)))
			break;
		if (memcmp(p, marker, sizeof(marker)) != 0) {
			p++;
			continue;
		}

		/* found BGP header */
		TCHECK2(p[0], BGP_SIZE);	/*XXX*/
		memcpy(&bgp, p, BGP_SIZE);

		if (start != p)
			printf(" [|BGP]");

		hlen = ntohs(bgp.bgp_len);
		if (vflag && newline)
			printf("\n\t");
		else
			printf(" ");
		if (hlen < BGP_SIZE) {
			printf("\n[|BGP Bogus header length %u < %u]",
			    hlen, BGP_SIZE);
			break;
		}
		if (TTEST2(p[0], hlen)) {
			if (!bgp_header_print(p, hlen))
				return;
			newline = 1;
			p += hlen;
			start = p;
		} else {
			printf("[|BGP %s]", bgp_type(bgp.bgp_type));
			break;
		}
	}

	return;

trunc:
	printf(" [|BGP]");
}
@


1.19
log
@Teach tcpdump to decode bgp path attribute draft-ietf-idr-large-community

Patch from Job Snijders, thanks!

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.18 2015/10/20 11:29:07 sthen Exp $	*/
d137 1
a137 1
#define BGPTYPE_LARGE_COMMUNITIES	30	/* draft-ietf-idr-large-community */
d270 2
a271 1
	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, "LARGE_COMMUNITIES",
@


1.18
log
@Add an explicit check for a malformed AS segment with (segment length 0),
avoiding division by zero when deciding whether it contains 2- or 4-byte ASNs.
Refactor TCHECK calls to ensure proper coverage.

From Kevin Reay, ok canacar with wording tweak (I used "malformed" rather
than canacar's suggested "invalid size" or Kevin's original "empty").
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.17 2015/01/16 06:40:21 deraadt Exp $	*/
d137 1
d269 2
a270 1
	"EXTD_COMMUNITIES", "AS4_PATH", "AGGREGATOR4",
d549 15
@


1.17
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.16 2014/01/12 11:26:48 deraadt Exp $	*/
d444 1
d449 1
a449 1
			TCHECK(p[0]);
d451 5
a460 1

a471 1
			TCHECK(p[0]);
a474 1
			TCHECK(p[1]);
@


1.16
log
@plen is unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.15 2012/02/19 17:24:05 claudio Exp $	*/
a31 1
#include <sys/param.h>
d42 1
d412 1
a412 1
	char buf[MAXHOSTNAMELEN + 100];
d871 1
a871 1
		char buf[MAXHOSTNAMELEN + 100];
d952 1
a952 1
			char buf[MAXHOSTNAMELEN + 100];
@


1.15
log
@Fix a classical bug (= vs ==). OK stsp@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.14 2009/10/27 23:59:55 deraadt Exp $	*/
d361 1
a361 1
	n = snprintf(buf, buflen, "%s/%d", getname((u_char *)&addr), plen);
d392 1
a392 1
	n = snprintf(buf, buflen, "%s/%d", getname6((u_char *)&addr), plen);
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.13 2009/09/08 15:53:11 claudio Exp $	*/
d881 1
a881 1
			if (wpfx = -1) {
@


1.13
log
@Make the BGP OPEN capability parser RFC 5492 compliant. While there add
additional checks to make sure the known capabilities are correctly
encoded and not truncated. Help and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.12 2009/09/07 12:25:36 sthen Exp $	*/
a30 5

#ifndef lint
static const char rcsid[] =
     "@@(#) $Id: print-bgp.c,v 1.12 2009/09/07 12:25:36 sthen Exp $";
#endif
@


1.12
log
@Teach the printer about capabilities, new cease codes, end-of-rib marker,
and handle 32-bit ASN.  ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.11 2009/01/29 09:46:32 bluhm Exp $	*/
d34 1
a34 1
     "@@(#) $Id: print-bgp.c,v 1.11 2009/01/29 09:46:32 bluhm Exp $";
d178 1
d710 81
d796 1
a796 1
	int i,cap_type,cap_len,tcap_len,cap_offset;
d831 2
a832 46
			cap_type=opt[i+BGP_OPT_SIZE];
			cap_len=opt[i+BGP_OPT_SIZE+1];
			tcap_len=cap_len;
			printf("(CAP %s",		/* ) */
			    bgp_capcode(cap_type));

			switch(cap_type) {
			case BGP_CAPCODE_MP:
				printf(" [%s %s]",
				    af_name(EXTRACT_16BITS(opt+i+BGP_OPT_SIZE+2)),
				    bgp_attr_nlri_safi(opt[i+BGP_OPT_SIZE+5]));
				break;
			case BGP_CAPCODE_RESTART:
				printf(" [%s], Time %us",
				    ((opt[i+BGP_OPT_SIZE+2])&0x80) ? "R" : "none",
				    EXTRACT_16BITS(opt+i+BGP_OPT_SIZE+2)&0xfff);
				tcap_len-=2;
				cap_offset=4;
				while(tcap_len>=4) {
					printf(" (%s %s)%s",
					    af_name(EXTRACT_16BITS(
						opt+i+BGP_OPT_SIZE+cap_offset)),
					    bgp_attr_nlri_safi(
						opt[i+BGP_OPT_SIZE+cap_offset+2]),
					    ((opt[i+BGP_OPT_SIZE+cap_offset+3])&0x80) ?
						" forwarding state preserved" : "" );
				tcap_len-=4;
				cap_offset+=4;
				}
				break;
			case BGP_CAPCODE_AS4:
				printf(" #");
				if (EXTRACT_16BITS(opt+i+BGP_OPT_SIZE+2))
					printf("%u.",
					    EXTRACT_16BITS(opt+i+BGP_OPT_SIZE+2));
				printf("%u",
				    EXTRACT_16BITS(opt+i+BGP_OPT_SIZE+4));
				break;
			default:
				break;
			}
			if (vflag > 1) {
				TCHECK2(opt[i+BGP_OPT_SIZE+2],cap_len);
			}
			/* ( */
			printf(")");	
@


1.11
log
@In tcpdump some printf() had an additional \n at the end.  Removing
that new line restores the one-line -> one-packet semantics.

ok hshoexer@@, henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.10 2007/10/07 16:41:05 deraadt Exp $	*/
d34 1
a34 1
     "@@(#) $Id: print-bgp.c,v 1.10 2007/10/07 16:41:05 deraadt Exp $";
d65 1
d85 1
d88 2
d100 10
d139 24
d167 1
a167 1
	NULL, "OPEN", "UPDATE", "NOTIFICATION", "KEEPALIVE",
d177 24
d205 1
a205 1
	"Cease",
d211 1
a211 1
static const char *bgpnotify_minor_1[] = {
d216 1
a216 1
static const char *bgpnotify_minor_2[] = {
d220 1
a220 1
	"Unacceptable Hold Time",
d223 1
a223 1
static const char *bgpnotify_minor_3[] = {
d232 14
d247 1
a247 1
	NULL, bgpnotify_minor_1, bgpnotify_minor_2, bgpnotify_minor_3,
d250 8
a257 3
	0, sizeof(bgpnotify_minor_1)/sizeof(bgpnotify_minor_1[0]),
	sizeof(bgpnotify_minor_2)/sizeof(bgpnotify_minor_2[0]),
	sizeof(bgpnotify_minor_3)/sizeof(bgpnotify_minor_3[0]),
d272 1
d281 7
d355 1
d414 1
a414 1
	int tlen;
d419 2
d431 3
d435 8
d452 23
a474 6
			/*
			 * under RFC1965, p[0] means:
			 * 1: AS_SET 2: AS_SEQUENCE
			 * 3: AS_CONFED_SET 4: AS_CONFED_SEQUENCE
			 */
			printf(" ");
d476 1
a476 15
			if (p[0] == 3 || p[0] == 4)
				printf("confed");
			printf("%s", (p[0] & 1) ? "{" : "");
			for (i = 0; i < p[1] * 2; i += 2) {
				TCHECK2(p[2 + i], 2); /* ASN is 2-bytes */
				printf("%s%u", i == 0 ? "" : " ",
					EXTRACT_16BITS(&p[2 + i]));
			}
			printf("%s", (p[0] & 1) ? "}" : "");
			/*
			 * 1 byte for attr type, 1 byte for path length,
			 * plus size of ASN (2-bytes for now) * no of ASN
			 *
			 */
			p += 2 + p[1] * 2;
d500 1
d502 6
a507 1
		if (len != 6) {
d511 7
a517 3
		TCHECK2(p[0], 6);
		printf(" AS #%u, origin %s", EXTRACT_16BITS(p),
			getname(p + 2));
d524 1
a524 1
		for (i = 0; i < len; i += 4) {
d526 2
a527 2
			TCHECK2(p[i], 4);
			comm = EXTRACT_32BITS(&p[i]);
d546 24
d577 1
a577 1
			printf(" %s vendor specific,", af_name(af));
d667 1
a667 1
			printf(" %s vendor specific,", af_name(af));
d714 1
a714 1
	int i;
d725 4
d742 61
a802 2
		printf(" (option %s, len=%d)", bgp_opttype(bgpopt.bgpopt_type),
			bgpopt.bgpopt_len);
d805 2
d848 1
a848 3
			if (wpfx == -2)
				goto trunc;
			else if (wpfx < 0) {
d851 2
a852 1
			}
d864 5
d921 1
a921 3
			if (i == -2)
				goto trunc;
			else if (i < 0) {
d924 2
a925 1
			}
d942 3
d949 4
d956 43
d1023 7
d1090 5
@


1.10
log
@trash $Header goo which is just annoying; 5595
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.9 2007/06/14 17:42:06 claudio Exp $	*/
d34 1
a34 1
     "@@(#) $Id$";
d652 1
a652 1
		printf(")\n");
@


1.9
log
@Print communities in a nicer format and include a missing well-known one.
This is mostly from Stuart Henderson. OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.8 2007/05/27 12:38:39 canacar Exp $	*/
d34 1
a34 1
     "@@(#) $TCPDUMP: /tcpdump/master/tcpdump/print-bgp.c,v 1.27 2001/10/18 09:52:17 itojun Exp $";
@


1.8
log
@Additional truncation checks, mostly from tcpdump.org,
and remove some unused hlen assignments found by lint
from Stuart Henderson, reviewed by me, ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.7 2006/03/28 15:48:34 reyk Exp $	*/
d208 1
d422 3
d426 1
a426 1
				printf(" (AS #%d value 0x%04x)",
@


1.7
log
@Add a simple printer for IEEE 802.1AB LLDP, the Link Layer Discovery
Protocol.

LLDP is used by some switch vendors as a replacement for the non-free
Cizzco Discovery Protocol (CDP) due to some Cisco patentry...

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.6 2005/06/14 17:57:21 moritz Exp $	*/
d120 1
a120 1
#define	BGPTYPE_DPA			11	/* work in progress */
d126 1
d260 5
a264 1
	plen = pd[0];
a266 1

d268 1
d279 3
d292 1
d298 1
d310 3
d316 1
a316 1
static void
d333 2
a334 1
		else
d336 1
d343 4
d354 1
d359 1
d364 5
d375 2
a376 1
		else
d378 1
d384 2
a385 1
		else
d387 1
d398 1
d409 1
d429 1
d449 1
d457 1
d463 1
d478 1
d484 1
d519 1
d558 4
a568 1
	int hlen;
a573 1
	hlen = ntohs(bgpo.bgpo_len);
a607 1
	int hlen;
a614 1
	hlen = ntohs(bgp.bgp_len);
d639 3
a641 1
			if (wpfx < 0) {
d655 1
d686 2
a687 1
			bgp_attr_print(&bgpa, &p[i + aoff], alen);
d708 6
a714 2
			if (i < 0)
				break;
a729 1
	int hlen;
a732 1
	hlen = ntohs(bgpn.bgpn_len);
d742 1
a742 1
static void
d765 1
a765 1
	return;
d768 1
d822 2
a823 1
			bgp_header_print(p, hlen);
@


1.6
log
@add missing error check for decode_prefix4. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.5 2005/04/27 23:03:01 cloder Exp $	*/
d52 1
d208 1
a208 23
/* RFC1700 address family numbers */
#define AFNUM_INET	1
#define AFNUM_INET6	2
#define AFNUM_NSAP	3
#define AFNUM_HDLC	4
#define AFNUM_BBN1822	5
#define AFNUM_802	6
#define AFNUM_E163	7
#define AFNUM_E164	8
#define AFNUM_F69	9
#define AFNUM_X121	10
#define AFNUM_IPX	11
#define AFNUM_ATALK	12
#define AFNUM_DECNET	13
#define AFNUM_BANYAN	14
#define AFNUM_E164NSAP	15

static const char *afnumber[] = {
	"Reserved", "IPv4", "IPv6", "NSAP", "HDLC",
	"BBN 1822", "802", "E.163", "E.164", "F.69",
	"X.121", "IPX", "Appletalk", "Decnet IV", "Banyan Vines",
	"E.164 with NSAP subaddress",
};
@


1.5
log
@Fix a potential infinite loop that could be triggered by an invalid BGP
packet.  Partially from tcpdump.org, with additional paranoia added so
that the problem is actually fixed.  OK deraadt, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.4 2002/09/03 12:21:12 ho Exp $	*/
d612 1
d620 6
a625 1
			i += decode_prefix4(&p[i], buf, sizeof(buf));
@


1.4
log
@Sync with tcpdump.org
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.3 2000/10/03 14:15:55 ho Exp $	*/
d278 1
d290 4
a293 1
	snprintf(buf, buflen, "%s/%d", getname((u_char *)&addr), plen);
d303 1
d315 5
a319 1
	snprintf(buf, buflen, "%s/%d", getname6((u_char *)&addr), plen);
a478 1
				printf(" %s", buf);
a482 1
				printf(" %s", buf);
d492 4
a516 1
				printf(" %s", buf);
a520 1
				printf(" %s", buf);
d530 4
d763 1
a763 1
	while (p < snapend) {
@


1.4.12.1
log
@MFC:
Fix by cloder@@

Fix a potential infinite loop that could be triggered by an invalid BGP
packet.  Partially from tcpdump.org, with additional paranoia added so
that the problem is actually fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.5 2005/04/27 23:03:01 cloder Exp $	*/
a277 1
	int n;
d289 1
a289 4
	n = snprintf(buf, buflen, "%s/%d", getname((u_char *)&addr), plen);
	if (n == -1 || n >= buflen)
		return -1;

a298 1
	int n;
d310 1
a310 5

	n = snprintf(buf, buflen, "%s/%d", getname6((u_char *)&addr), plen);
	if (n == -1 || n >= buflen)
		return -1;

d470 1
d475 1
a484 4
			if (advance <= 0)
				break;

			printf(" %s", buf);
d506 1
d511 1
a520 4
			if (advance <= 0)
				break;

			printf(" %s", buf);
d750 1
a750 1
	while (p < ep) {
@


1.4.8.1
log
@MFC:
Fix by cloder@@

Fix a potential infinite loop that could be triggered by an invalid BGP
packet.  Partially from tcpdump.org, with additional paranoia added so
that the problem is actually fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.4 2002/09/03 12:21:12 ho Exp $	*/
a277 1
	int n;
d289 1
a289 4
	n = snprintf(buf, buflen, "%s/%d", getname((u_char *)&addr), plen);
	if (n == -1 || n >= buflen)
		return -1;

a298 1
	int n;
d310 1
a310 5

	n = snprintf(buf, buflen, "%s/%d", getname6((u_char *)&addr), plen);
	if (n == -1 || n >= buflen)
		return -1;

d470 1
d475 1
a484 4
			if (advance <= 0)
				break;

			printf(" %s", buf);
d506 1
d511 1
a520 4
			if (advance <= 0)
				break;

			printf(" %s", buf);
d750 1
a750 1
	while (p < ep) {
@


1.4.10.1
log
@MFC:
Fix by cloder@@

Fix a potential infinite loop that could be triggered by an invalid BGP
packet.  Partially from tcpdump.org, with additional paranoia added so
that the problem is actually fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.4 2002/09/03 12:21:12 ho Exp $	*/
a277 1
	int n;
d289 1
a289 4
	n = snprintf(buf, buflen, "%s/%d", getname((u_char *)&addr), plen);
	if (n == -1 || n >= buflen)
		return -1;

a298 1
	int n;
d310 1
a310 5

	n = snprintf(buf, buflen, "%s/%d", getname6((u_char *)&addr), plen);
	if (n == -1 || n >= buflen)
		return -1;

d470 1
d475 1
a484 4
			if (advance <= 0)
				break;

			printf(" %s", buf);
d506 1
d511 1
a520 4
			if (advance <= 0)
				break;

			printf(" %s", buf);
d750 1
a750 1
	while (p < ep) {
@


1.3
log
@More careful ntohs/ntohl etc. From Gunnar Lindberg <lindberg@@cdg.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.2 2000/04/26 21:35:39 jakob Exp $	*/
d32 5
a42 6
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <arpa/inet.h>
d47 1
d51 1
d76 1
d83 1
d93 1
d132 1
a132 1
	NULL, "Authentication Information",
d196 1
a196 1
    "Reserved", "Unicast", "Multicast", "Unicast+Multicast",
d274 1
a274 1
decode_prefix4(const u_char *pd, char *buf, int buflen)
d277 1
a277 1
	int plen;
d289 1
a289 1
	snprintf(buf, buflen, "%s/%d", inet_ntoa(addr), plen);
d295 1
a295 1
decode_prefix6(const u_char *pd, char *buf, int buflen)
d298 1
a298 1
	int plen;
d310 1
a310 1
	snprintf(buf, buflen, "%s/%d", getname6((char *)&addr), plen);
d324 1
a324 4
	char buf[256];
	u_int16_t ss;
	u_int32_t ll;
	struct in_addr aa;
d350 1
a350 2
			for (i = 0; i < p[1]; i += 2) {
				memcpy((void *)&ss, (void *)&p[2+i], sizeof(ss));
d352 1
a352 1
							ntohs(ss));
d361 2
a362 4
		else {
			memcpy((void *)&aa.s_addr, (void *)&p[0], sizeof(aa.s_addr));
			printf(" %s", inet_ntoa(aa));
		}
d368 2
a369 4
		else {
			memcpy((void *)&ll, (void *)&p[0], sizeof(ll));
			printf(" %u", (u_int32_t)ntohl(ll));
		}
d380 2
a381 3
		memcpy((void *)&ss, (void *)&p[0], sizeof(ss));
		memcpy((void *)&aa.s_addr, (void *)&p[2], sizeof(aa.s_addr));
		printf(" AS #%u, origin %s", ntohs(ss), inet_ntoa(aa));
d390 1
a390 2
			memcpy((void *)&ll,(void *)&p[0+i],sizeof(ll));
			comm = (u_int32_t)ntohl(ll);
d409 1
a409 2
		memcpy((void *)&ss, (void *)&p[0], sizeof(ss));
		af = ntohs(ss);
d431 7
d439 4
a442 3
			if (af == AFNUM_INET6)
				advance = 16;
			else
d444 4
a447 6
				advance = 4; /* AFNUM_INET */

			for (i = 0; i < tlen; i += advance) {
				if (af == AFNUM_INET) {
				    memcpy((void *)&aa.s_addr, (void *)&p[1+i], sizeof(aa.s_addr));
				    printf(" %s", inet_ntoa(aa));
a448 4
#ifdef INET6
				else if (af == AFNUM_INET6)
					printf(" %s", getname6(p + 1 + i));
#endif
d467 5
d473 1
a473 1
			if (af == AFNUM_INET6)
d475 2
a476 1
			else
d478 6
a483 2
				advance = decode_prefix4(p, buf, sizeof(buf));
			printf(" %s", buf);
d491 1
a491 2
		memcpy((void *)&ss, (void *)&p[0], sizeof(ss));
		af = ntohs(ss);
d503 5
d509 1
a509 1
			if (af == AFNUM_INET6)
d511 2
a512 1
			else
d514 6
a519 3
				advance = decode_prefix4(p, buf, sizeof(buf));

			printf(" %s", buf);
d538 2
a539 1
	memcpy(&bgpo, dat, sizeof(bgpo));
d545 1
a545 1
	printf(" ID %s,", getname((const u_char *)&bgpo.bgpo_id));
d549 1
a549 1
	opt = &((struct bgp_open *)dat)->bgpo_optlen;
d552 4
a555 2
	for (i = 0; i < bgpo.bgpo_optlen; i++) {
		memcpy(&bgpopt, &opt[i], sizeof(bgpopt));
d563 1
a563 1
		i += sizeof(bgpopt) + bgpopt.bgpopt_len;
d565 3
a579 1
	u_int16_t ss;
d581 2
a582 1
	memcpy(&bgp, dat, sizeof(bgp));
d588 1
a588 2
	memcpy((void *)&ss, (void *)&p[0], sizeof(ss));
	len = ntohs(ss);
d590 6
d597 14
d614 2
a615 2
	memcpy((void *)&ss, (void *)&p[0], sizeof(ss));
	len = ntohs(ss);
d624 1
d636 1
a636 1
				printf("[%s%s%s%s]",
d640 4
a643 1
					bgpa.bgpa_flags & 0x00 ? "E" : "");
d665 1
a665 1
			char buf[256];
d676 3
d687 2
a688 1
	memcpy(&bgpn, dat, sizeof(bgpn));
d694 3
d704 2
a705 1
	memcpy(&bgp, dat, sizeof(bgp));
d722 3
d767 1
a767 1
		memcpy(&bgp, p, sizeof(bgp));
@


1.2
log
@INET6
DHCP/BOOTP
tcp & udp checksum detection
numerous bugfixes
@
text
@d1 1
a1 1
/*	$OpenBSD: print-bgp.c,v 1.1 2000/01/16 11:43:57 jakob Exp $	*/
d43 1
d285 1
a285 1
	snprintf(buf, buflen, "%s/%d", getname((char *)&addr), plen);
d321 3
d350 1
d352 1
a352 1
					ntohs(*(u_int16_t *)&p[2 + i]));
d361 4
a364 2
		else
			printf(" %s", getname(p));
d370 4
a373 2
		else
			printf(" %u", (u_int32_t)ntohl(*(u_int32_t *)p));
d384 3
a386 2
		printf(" AS #%u, origin %s", ntohs(*(u_int16_t *)p),
			getname(p + 2));
d395 2
a396 1
			comm = (u_int32_t)ntohl(*(u_int32_t *)&p[i]);
d415 2
a416 1
		af = ntohs(*(u_int16_t *)p);
a437 2
			if (af == AFNUM_INET)
				advance = 4;
d439 1
a439 1
			else if (af == AFNUM_INET6)
d441 1
d443 1
d446 4
a449 2
				if (af == AFNUM_INET)
					printf(" %s", getname(p + 1 + i));
a471 2
			if (af == AFNUM_INET)
				advance = decode_prefix4(p, buf, sizeof(buf));
d473 1
a473 1
			else if (af == AFNUM_INET6)
d475 1
d477 1
d486 2
a487 1
		af = ntohs(*(u_int16_t *)p);
a498 2
			if (af == AFNUM_INET)
				advance = decode_prefix4(p, buf, sizeof(buf));
d500 1
a500 1
			else if (af == AFNUM_INET6)
d502 1
d504 2
d531 1
a531 1
	printf(" ID %s,", getname((char *)&bgpo.bgpo_id));
d561 1
d569 2
a570 1
	len = ntohs(*(u_int16_t *)p);
d576 2
a577 1
	len = ntohs(*(u_int16_t *)p);
@


1.1
log
@BGP support (from KAME/WIDE). INET6 parts not done yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d383 1
a383 1
		for (i = 0; i < len; i++) {
d398 1
a398 1
					(comm >> 16) & 0xffff, comm & 0xfffff);
@

