head	1.34;
access;
symbols
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.6
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.4
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8;
locks; strict;
comment	@ * @;


1.34
date	2017.08.12.16.27.50;	author benno;	state Exp;
branches;
next	1.33;
commitid	j2LQSmU2VhBZ75Yh;

1.33
date	2017.05.30.12.42.31;	author friehm;	state Exp;
branches;
next	1.32;
commitid	aUDKS9b7zHFzXmWv;

1.32
date	2016.09.03.10.25.36;	author renato;	state Exp;
branches;
next	1.31;
commitid	2D672KsaUkm6FxSg;

1.31
date	2016.09.02.14.06.35;	author benno;	state Exp;
branches;
next	1.30;
commitid	Z2jEGSLNZuIKq53q;

1.30
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.29;
commitid	LQHdRRMF0nq0fugE;

1.29
date	2015.12.05.13.12.41;	author claudio;	state Exp;
branches;
next	1.28;
commitid	4xNKczBxYPO9zMjt;

1.28
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.27;
commitid	kLBPo9HaQrkEaNW3;

1.27
date	2015.02.10.05.39.10;	author claudio;	state Exp;
branches;
next	1.26;
commitid	LcINzHD3xxMOidFk;

1.26
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.24;
commitid	lIxCxHhVEpsmXOdi;

1.24
date	2013.11.13.20.49.49;	author benno;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.22.14.25.31;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.20.19.02.28;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.22.21.15.25;	author bluhm;	state Exp;
branches;
next	1.20;

1.20
date	2010.07.06.13.24.35;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.01.18.57.21;	author bluhm;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.22.19.47.05;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.22.19.44.52;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.02.20.24.58;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.06.09.02.46;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.31.20.29.56;	author jacekm;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.31.17.00.40;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.28.15.38.58;	author michele;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.28.22.05.04;	author sobrado;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.13.11.46.57;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.13.08.54.05;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.25.12.05.20;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.20.13.26.50;	author pyr;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.16.08.41.56;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.13.16.35.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.11.21.25.37;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.11.19.02.47;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.50;	author norby;	state Exp;
branches;
next	;


desc
@@


1.34
log
@bring ospf6d's log.c in sync with ospfd and bgpd
ok florian@@ claudio@@
@
text
@/*	$OpenBSD: ospf6d.c,v 1.33 2017/05/30 12:42:31 friehm Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2007 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/sysctl.h>
#include <syslog.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <event.h>
#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>

#include "ospf6d.h"
#include "ospf6.h"
#include "ospfe.h"
#include "control.h"
#include "log.h"
#include "rde.h"

void		main_sig_handler(int, short, void *);
__dead void	usage(void);
__dead void	ospfd_shutdown(void);

void	main_dispatch_ospfe(int, short, void *);
void	main_dispatch_rde(int, short, void *);

int	ospf_reload(void);
int	ospf_sendboth(enum imsg_type, void *, u_int16_t);
int	merge_interfaces(struct area *, struct area *);
struct iface *iface_lookup(struct area *, struct iface *);

int	pipe_parent2ospfe[2];
int	pipe_parent2rde[2];
int	pipe_ospfe2rde[2];

struct ospfd_conf	*ospfd_conf = NULL;
struct imsgev		*iev_ospfe;
struct imsgev		*iev_rde;
char			*conffile;

pid_t			 ospfe_pid = 0;
pid_t			 rde_pid = 0;

/* ARGSUSED */
void
main_sig_handler(int sig, short event, void *arg)
{
	/* signal handler rules don't apply, libevent decouples for us */
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		ospfd_shutdown();
		/* NOTREACHED */
	case SIGHUP:
		if (ospf_reload() == -1)
			log_warnx("configuration reload failed");
		else
			log_debug("configuration reloaded");
		break;
	default:
		fatalx("unexpected signal");
		/* NOTREACHED */
	}
}

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-dnv] [-D macro=value]"
	    " [-f file] [-s socket]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct event		 ev_sigint, ev_sigterm, ev_sighup;
	int			 ch, opts = 0;
	int			 debug = 0;
	int			 ipforwarding;
	int			 mib[4];
	size_t			 len;
	char			*sockname;

	conffile = CONF_FILE;
	ospfd_process = PROC_MAIN;
	sockname = OSPF6D_SOCKET;

	log_init(1, LOG_DAEMON);	/* log to stderr until daemonized */
	log_procinit(log_procnames[ospfd_process]);
	log_setverbose(1);

	while ((ch = getopt(argc, argv, "cdD:f:s:nv")) != -1) {
		switch (ch) {
		case 'c':
			opts |= OSPFD_OPT_FORCE_DEMOTE;
			break;
		case 'd':
			debug = 1;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'n':
			opts |= OSPFD_OPT_NOACTION;
			break;
		case 's':
			sockname = optarg;
			break;
		case 'v':
			if (opts & OSPFD_OPT_VERBOSE)
				opts |= OSPFD_OPT_VERBOSE2;
			opts |= OSPFD_OPT_VERBOSE;
			log_setverbose(1);
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	mib[0] = CTL_NET;
	mib[1] = PF_INET6;
	mib[2] = IPPROTO_IPV6;
	mib[3] = IPCTL_FORWARDING;
	len = sizeof(ipforwarding);
	if (sysctl(mib, 4, &ipforwarding, &len, NULL, 0) == -1)
		err(1, "sysctl");

	if (ipforwarding != 1) {
		log_warnx("WARNING: IPv6 forwarding NOT enabled, "
		    "running as stub router");
		opts |= OSPFD_OPT_STUB_ROUTER;
	}

	/* prepare and fetch interfaces early */
	if_init();

	/* parse config file */
	if ((ospfd_conf = parse_config(conffile, opts)) == NULL )
		exit(1);
	ospfd_conf->csock = sockname;

	if (ospfd_conf->opts & OSPFD_OPT_NOACTION) {
		if (ospfd_conf->opts & OSPFD_OPT_VERBOSE)
			print_config(ospfd_conf);
		else
			fprintf(stderr, "configuration OK\n");
		exit(0);
	}

	/* check for root privileges  */
	if (geteuid())
		errx(1, "need root privileges");

	/* check for ospfd user */
	if (getpwnam(OSPF6D_USER) == NULL)
		errx(1, "unknown user %s", OSPF6D_USER);

	log_init(debug, LOG_DAEMON);
	log_setverbose(ospfd_conf->opts & OSPFD_OPT_VERBOSE);

	if (!debug)
		daemon(1, 0);

	log_info("startup");

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_parent2ospfe) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_parent2rde) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_ospfe2rde) == -1)
		fatal("socketpair");

	/* start children */
	rde_pid = rde(ospfd_conf, pipe_parent2rde, pipe_ospfe2rde,
	    pipe_parent2ospfe);
	ospfe_pid = ospfe(ospfd_conf, pipe_parent2ospfe, pipe_ospfe2rde,
	    pipe_parent2rde);

	event_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, main_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, NULL);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);

	/* setup pipes to children */
	close(pipe_parent2ospfe[1]);
	close(pipe_parent2rde[1]);
	close(pipe_ospfe2rde[0]);
	close(pipe_ospfe2rde[1]);

	if ((iev_ospfe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_rde = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_ospfe->ibuf, pipe_parent2ospfe[0]);
	iev_ospfe->handler = main_dispatch_ospfe;
	imsg_init(&iev_rde->ibuf, pipe_parent2rde[0]);
	iev_rde->handler = main_dispatch_rde;

	/* setup event handler */
	iev_ospfe->events = EV_READ;
	event_set(&iev_ospfe->ev, iev_ospfe->ibuf.fd, iev_ospfe->events,
	    iev_ospfe->handler, iev_ospfe);
	event_add(&iev_ospfe->ev, NULL);

	iev_rde->events = EV_READ;
	event_set(&iev_rde->ev, iev_rde->ibuf.fd, iev_rde->events,
	    iev_rde->handler, iev_rde);
	event_add(&iev_rde->ev, NULL);

	if (kr_init(!(ospfd_conf->flags & OSPFD_FLAG_NO_FIB_UPDATE)) == -1)
		fatalx("kr_init failed");

	event_dispatch();

	ospfd_shutdown();
	/* NOTREACHED */
	return (0);
}

__dead void
ospfd_shutdown(void)
{
	pid_t	pid;
	int	status;

	/* close pipes */
	msgbuf_clear(&iev_ospfe->ibuf.w);
	close(iev_ospfe->ibuf.fd);
	msgbuf_clear(&iev_rde->ibuf.w);
	close(iev_rde->ibuf.fd);

	control_cleanup(ospfd_conf->csock);
	kr_shutdown();
	carp_demote_shutdown();

	log_debug("waiting for children to terminate");
	do {
		pid = wait(&status);
		if (pid == -1) {
			if (errno != EINTR && errno != ECHILD)
				fatal("wait");
		} else if (WIFSIGNALED(status))
			log_warnx("%s terminated; signal %d",
			    (pid == rde_pid) ? "route decision engine" :
			    "ospf engine", WTERMSIG(status));
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	free(iev_ospfe);
	free(iev_rde);
	free(ospfd_conf);

	log_info("terminating");
	exit(0);
}

/* imsg handling */
/* ARGSUSED */
void
main_dispatch_ospfe(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	struct demote_msg	 dmsg;
	ssize_t			 n;
	int			 shut = 0, verbose;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_RELOAD:
			if (ospf_reload() == -1)
				log_warnx("configuration reload failed");
			else
				log_debug("configuration reloaded");
			break;
		case IMSG_CTL_FIB_COUPLE:
			kr_fib_couple();
			break;
		case IMSG_CTL_FIB_DECOUPLE:
			kr_fib_decouple();
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
			kr_show_route(&imsg);
			break;
		case IMSG_DEMOTE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(dmsg))
				fatalx("invalid size of OE request");
			memcpy(&dmsg, imsg.data, sizeof(dmsg));
			carp_demote_set(dmsg.demote_group, dmsg.level);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by ospfe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		default:
			log_debug("main_dispatch_ospfe: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
void
main_dispatch_rde(int fd, short event, void *bula)
{
	struct imsgev	*iev = bula;
	struct imsgbuf	*ibuf = &iev->ibuf;
	struct imsg	 imsg;
	ssize_t		 n;
	int		 count, shut = 0;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_KROUTE_CHANGE:
			count = (imsg.hdr.len - IMSG_HEADER_SIZE) /
			    sizeof(struct kroute);
			if (kr_change(imsg.data, count))
				log_warn("main_dispatch_rde: error changing "
				    "route");
			break;
		case IMSG_KROUTE_DELETE:
			if (kr_delete(imsg.data))
				log_warn("main_dispatch_rde: error deleting "
				    "route");
			break;
		default:
			log_debug("main_dispatch_rde: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
main_imsg_compose_ospfe(int type, pid_t pid, void *data, u_int16_t datalen)
{
	if (iev_ospfe == NULL)
		return;
	imsg_compose_event(iev_ospfe, type, 0, pid, -1, data, datalen);
}

void
main_imsg_compose_rde(int type, pid_t pid, void *data, u_int16_t datalen)
{
	if (iev_rde == NULL)
		return;
	imsg_compose_event(iev_rde, type, 0, pid, -1, data, datalen);
}

void
imsg_event_add(struct imsgev *iev)
{
	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev);
	event_add(&iev->ev, NULL);
}

int
imsg_compose_event(struct imsgev *iev, u_int16_t type, u_int32_t peerid,
    pid_t pid, int fd, void *data, u_int16_t datalen)
{
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) != -1)
		imsg_event_add(iev);
	return (ret);
}

int
ospf_redistribute(struct kroute *kr, u_int32_t *metric)
{
	struct redistribute	*r;
	struct in6_addr		 ina, inb;
	u_int8_t		 is_default = 0;

	/* only allow ::/0 via REDIST_DEFAULT */
	if (IN6_IS_ADDR_UNSPECIFIED(&kr->prefix) && kr->prefixlen == 0)
		is_default = 1;

	SIMPLEQ_FOREACH(r, &ospfd_conf->redist_list, entry) {
		switch (r->type & ~REDIST_NO) {
		case REDIST_LABEL:
			if (kr->rtlabel == r->label) {
				*metric = r->metric;
				return (r->type & REDIST_NO ? 0 : 1);
			}
			break;
		case REDIST_STATIC:
			/*
			 * Dynamic routes are not redistributable. Placed here
			 * so that link local addresses can be redistributed
			 * via a rtlabel.
			 */
			if (is_default)
				continue;
			if (kr->flags & F_DYNAMIC)
				continue;
			if (kr->flags & F_STATIC) {
				*metric = r->metric;
				return (r->type & REDIST_NO ? 0 : 1);
			}
			break;
		case REDIST_CONNECTED:
			if (is_default)
				continue;
			if (kr->flags & F_DYNAMIC)
				continue;
			if (kr->flags & F_CONNECTED) {
				*metric = r->metric;
				return (r->type & REDIST_NO ? 0 : 1);
			}
			break;
		case REDIST_ADDR:
			if (kr->flags & F_DYNAMIC)
				continue;

			if (IN6_IS_ADDR_UNSPECIFIED(&r->addr) &&
			    r->prefixlen == 0) {
				if (is_default) {
					*metric = r->metric;
					return (r->type & REDIST_NO ? 0 : 1);
				} else
					return (0);
			}

			inet6applymask(&ina, &kr->prefix, r->prefixlen);
			inet6applymask(&inb, &r->addr, r->prefixlen);
			if (IN6_ARE_ADDR_EQUAL(&ina, &inb) &&
			    kr->prefixlen >= r->prefixlen) {
				*metric = r->metric;
				return (r->type & REDIST_NO ? 0 : 1);
			}
			break;
		case REDIST_DEFAULT:
			if (is_default) {
				*metric = r->metric;
				return (r->type & REDIST_NO ? 0 : 1);
			}
			break;
		}
	}

	return (0);
}

int
ospf_reload(void)
{
	struct area		*area;
	struct ospfd_conf	*xconf;

	if ((xconf = parse_config(conffile, ospfd_conf->opts)) == NULL)
		return (-1);

	/* send config to childs */
	if (ospf_sendboth(IMSG_RECONF_CONF, xconf, sizeof(*xconf)) == -1)
		return (-1);

	/* send areas, interfaces happen out of band */
	LIST_FOREACH(area, &xconf->area_list, entry) {
		if (ospf_sendboth(IMSG_RECONF_AREA, area, sizeof(*area)) == -1)
			return (-1);
	}

	if (ospf_sendboth(IMSG_RECONF_END, NULL, 0) == -1)
		return (-1);

	/* XXX send newly available interfaces to the childs */

	merge_config(ospfd_conf, xconf);
	/* update redistribute lists */
	kr_reload();
	return (0);
}

int
ospf_sendboth(enum imsg_type type, void *buf, u_int16_t len)
{
	if (imsg_compose_event(iev_ospfe, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	if (imsg_compose_event(iev_rde, type, 0, 0, -1, buf, len) == -1)
		return (-1);
	return (0);
}

void
merge_config(struct ospfd_conf *conf, struct ospfd_conf *xconf)
{
	struct area		*a, *xa, *na;
	struct iface		*iface;
	struct redistribute	*r;

	/* change of rtr_id needs a restart */
	conf->flags = xconf->flags;
	conf->spf_delay = xconf->spf_delay;
	conf->spf_hold_time = xconf->spf_hold_time;
	conf->redistribute = xconf->redistribute;

	if (ospfd_process == PROC_MAIN) {
		/* main process does neither use areas nor interfaces */
		while ((r = SIMPLEQ_FIRST(&conf->redist_list)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&conf->redist_list, entry);
			free(r);
		}
		while ((r = SIMPLEQ_FIRST(&xconf->redist_list)) != NULL) {
			SIMPLEQ_REMOVE_HEAD(&xconf->redist_list, entry);
			SIMPLEQ_INSERT_TAIL(&conf->redist_list, r, entry);
		}
		goto done;
	}

	/* merge areas and interfaces */
	for (a = LIST_FIRST(&conf->area_list); a != NULL; a = na) {
		na = LIST_NEXT(a, entry);
		/* find deleted areas */
		if ((xa = area_find(xconf, a->id)) == NULL) {
			if (ospfd_process == PROC_OSPF_ENGINE) {
				LIST_FOREACH(iface, &a->iface_list, entry)
					if_fsm(iface, IF_EVT_DOWN);
			}
			LIST_REMOVE(a, entry);
			area_del(a);
		}
	}

	for (xa = LIST_FIRST(&xconf->area_list); xa != NULL; xa = na) {
		na = LIST_NEXT(xa, entry);
		if ((a = area_find(conf, xa->id)) == NULL) {
			LIST_REMOVE(xa, entry);
			LIST_INSERT_HEAD(&conf->area_list, xa, entry);
			if (ospfd_process == PROC_OSPF_ENGINE) {
				/* start interfaces */
				ospfe_demote_area(xa, 0);
				LIST_FOREACH(iface, &xa->iface_list, entry)
					if_start(conf, iface);
			}
			/* no need to merge interfaces */
			continue;
		}
		/*
		 * stub is not yet used but switching between stub and normal
		 * will be another painful job.
		 */
		a->stub = xa->stub;
		a->stub_default_cost = xa->stub_default_cost;
		if (ospfd_process == PROC_RDE_ENGINE)
			a->dirty = 1; /* force SPF tree recalculation */

		/* merge interfaces */
		if (merge_interfaces(a, xa) &&
		    ospfd_process == PROC_OSPF_ENGINE)
			a->dirty = 1; /* force rtr LSA update */
	}

	if (ospfd_process == PROC_OSPF_ENGINE) {
		LIST_FOREACH(a, &conf->area_list, entry) {
			LIST_FOREACH(iface, &a->iface_list, entry) {
				if (iface->state == IF_STA_NEW) {
					iface->state = IF_STA_DOWN;
					if_start(conf, iface);
				}
			}
			if (a->dirty) {
				a->dirty = 0;
				orig_rtr_lsa(LIST_FIRST(&a->iface_list));
			}
		}
	}

done:
	while ((a = LIST_FIRST(&xconf->area_list)) != NULL) {
		LIST_REMOVE(a, entry);
		area_del(a);
	}
	free(xconf);
}

int
merge_interfaces(struct area *a, struct area *xa)
{
	struct iface	*i, *xi, *ni;
	int		 dirty = 0;

	/* problems:
	 * - new interfaces (easy)
	 * - deleted interfaces (needs to be done via fsm?)
	 * - changing passive (painful?)
	 */
	for (i = LIST_FIRST(&a->iface_list); i != NULL; i = ni) {
		ni = LIST_NEXT(i, entry);
		if (iface_lookup(xa, i) == NULL) {
			log_debug("merge_interfaces: proc %d area %s removing "
			    "interface %s", ospfd_process, inet_ntoa(a->id),
			    i->name);
			if (ospfd_process == PROC_OSPF_ENGINE)
				if_fsm(i, IF_EVT_DOWN);
			LIST_REMOVE(i, entry);
			if_del(i);
		}
	}

	for (xi = LIST_FIRST(&xa->iface_list); xi != NULL; xi = ni) {
		ni = LIST_NEXT(xi, entry);
		if ((i = iface_lookup(a, xi)) == NULL) {
			/* new interface but delay initialisation */
			log_debug("merge_interfaces: proc %d area %s adding "
			    "interface %s", ospfd_process, inet_ntoa(a->id),
			    xi->name);
			LIST_REMOVE(xi, entry);
			LIST_INSERT_HEAD(&a->iface_list, xi, entry);
			if (ospfd_process == PROC_OSPF_ENGINE)
				xi->state = IF_STA_NEW;
			continue;
		}
		log_debug("merge_interfaces: proc %d area %s merging "
		    "interface %s", ospfd_process, inet_ntoa(a->id), i->name);
		i->addr = xi->addr;
		i->dst = xi->dst;
		i->abr_id = xi->abr_id;
		i->baudrate = xi->baudrate;
		i->dead_interval = xi->dead_interval;
		i->mtu = xi->mtu;
		i->transmit_delay = xi->transmit_delay;
		i->hello_interval = xi->hello_interval;
		i->rxmt_interval = xi->rxmt_interval;
		if (i->metric != xi->metric)
			dirty = 1;
		i->metric = xi->metric;
		i->priority = xi->priority;
		i->flags = xi->flags; /* needed? */
		i->type = xi->type; /* needed? */
		i->if_type = xi->if_type; /* needed? */
		i->linkstate = xi->linkstate; /* needed? */

#if 0 /* XXX needs some kind of love */
		if (i->passive != xi->passive) {
			/* need to restart interface to cope with this change */
			if (ospfd_process == PROC_OSPF_ENGINE)
				if_fsm(i, IF_EVT_DOWN);
			i->passive = xi->passive;
			if (ospfd_process == PROC_OSPF_ENGINE)
				if_fsm(i, IF_EVT_UP);
		}
#endif
	}
	return (dirty);
}

struct iface *
iface_lookup(struct area *area, struct iface *iface)
{
	struct iface	*i;

	LIST_FOREACH(i, &area->iface_list, entry)
		if (i->ifindex == iface->ifindex)
			return (i);
	return (NULL);
}
@


1.33
log
@Adding multipath route support to ospf6d. Almost copied from ospfd.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.32 2016/09/03 10:25:36 renato Exp $ */
d28 1
a119 1
	log_procname = log_procnames[ospfd_process];
d122 3
a124 2
	log_init(1);	/* log to stderr until daemonized */
	log_verbose(1);
d152 1
a152 1
			log_verbose(1);
d203 2
a204 2
	log_init(debug);
	log_verbose(ospfd_conf->opts & OSPFD_OPT_VERBOSE);
d367 1
a367 1
			log_verbose(verbose);
@


1.32
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.31 2016/09/02 14:06:35 benno Exp $ */
d392 1
a392 1
	int		 shut = 0;
d416 3
a418 1
			if (kr_change(imsg.data))
@


1.31
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.30 2016/02/02 17:51:11 sthen Exp $ */
d51 1
a51 2
void		ospfd_shutdown(void);
int		check_child(pid_t, const char *);
d77 1
a77 6
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */

	int	die = 0;

d81 2
a82 14
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		if (check_child(ospfe_pid, "ospf engine")) {
			ospfe_pid = 0;
			die = 1;
		}
		if (check_child(rde_pid, "route decision engine")) {
			rde_pid = 0;
			die = 1;
		}
		if (die)
			ospfd_shutdown();
		break;
d109 1
a109 1
	struct event		 ev_sigint, ev_sigterm, ev_sigchld, ev_sighup;
a230 1
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, NULL);
a233 1
	signal_add(&ev_sigchld, NULL);
d272 1
a272 1
void
d276 1
d278 5
a282 5
	if (ospfe_pid)
		kill(ospfe_pid, SIGTERM);

	if (rde_pid)
		kill(rde_pid, SIGTERM);
d288 1
d290 8
a297 3
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
a299 1
	msgbuf_clear(&iev_ospfe->ibuf.w);
a300 1
	msgbuf_clear(&iev_rde->ibuf.w);
a305 20
}

int
check_child(pid_t pid, const char *pname)
{
	int	status;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("lost child: %s terminated; signal %d",
			    pname, WTERMSIG(status));
			return (1);
		}
	}

	return (0);
@


1.30
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.29 2015/12/05 13:12:41 claudio Exp $ */
d137 1
@


1.29
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.28 2015/09/27 17:31:50 stsp Exp $ */
a241 3

	/* show who we are */
	setproctitle("parent");
@


1.28
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.27 2015/02/10 05:39:10 claudio Exp $ */
d358 1
a358 1
		if ((n = imsg_read(ibuf)) == -1)
d432 1
a432 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.27
log
@Same session_socket_blockmode() changes as done to ospfd. Also do the same
kroute change (make socket non-blocking and add trigger for partial reads).
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.26 2015/01/16 06:40:19 deraadt Exp $ */
d781 1
a781 1
		i->media_type = xi->media_type; /* needed? */
@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.25 2014/07/12 20:16:38 krw Exp $ */
d227 2
a228 2
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_parent2ospfe) == -1)
d230 2
a231 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2rde) == -1)
d233 2
a234 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_ospfe2rde) == -1)
a235 6
	session_socket_blockmode(pipe_parent2ospfe[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2ospfe[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2rde[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2rde[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_ospfe2rde[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_ospfe2rde[1], BM_NONBLOCK);
@


1.25
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.24 2013/11/13 20:49:49 benno Exp $ */
a26 1
#include <sys/param.h>
@


1.24
log
@handle msgbuf_write() returning EAGAIN,
taken from claudios previous fix to ospfd.

"do it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.23 2013/03/22 14:25:31 sthen Exp $ */
d369 1
a369 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d371 2
d443 1
a443 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d445 2
@


1.23
log
@Allow use of an alternative control socket, ported from ospfd. ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.22 2011/08/20 19:02:28 sthen Exp $ */
d369 1
a369 1
		if (msgbuf_write(&ibuf->w) == -1)
d441 1
a441 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.22
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"-v" (previously only "-vd" worked). Similar to recent ospfd commit.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.21 2010/08/22 21:15:25 bluhm Exp $ */
d119 2
a120 1
	fprintf(stderr, "usage: %s [-dnv] [-D macro=value] [-f file]\n",
d134 1
d138 1
d143 1
a143 1
	while ((ch = getopt(argc, argv, "cdD:f:nv")) != -1) {
d162 3
d202 1
d310 1
a310 1
	control_cleanup();
@


1.21
log
@Redistributing the default route with ospf6d did not work correctly.
- kroute.c may not ignore the default route.
- Use the ROUNDUP macro from route/show.c as this one is also correct
  for netmask with prefixlen 0.
- Implement ospf_redistribute and the redistribute parser like
  ospfd.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.20 2010/07/06 13:24:35 bluhm Exp $ */
d138 1
d214 1
@


1.20
log
@Update the interfaces changes from kroute to rde via imsg.  This
is needed to orginate correct intra-area-prefix-lsas.
ok claudio@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.19 2010/07/01 18:57:21 bluhm Exp $ */
a57 2
void	ospf_redistribute_default(int);

a282 3
	/* redistribute default */
	ospf_redistribute_default(IMSG_NETWORK_ADD);

d515 1
d517 1
a517 1
	/* only allow 0.0.0.0/0 via REDISTRIBUTE_DEFAULT */
d519 1
a519 1
		return (0);
d535 2
d545 2
d557 11
a567 1
			inet6applymask(&ina, &kr->prefix, kr->prefixlen);
d575 6
a584 13
}

void
ospf_redistribute_default(int type)
{
	struct rroute	rr;

	if (!(ospfd_conf->redistribute & REDISTRIBUTE_DEFAULT))
		return;

	bzero(&rr, sizeof(rr));
	rr.metric = ospfd_conf->defaultmetric;
	main_imsg_compose_rde(type, 0, &rr, sizeof(struct rroute));
@


1.19
log
@The prefixes of interface addresses of an ospf link have to be
advertised as link-lsa and intra-area-prefix-lsa when they change
dynamically.  Handle RTM_NEWADDR and RTM_DELADDR in kroute by sending
an imsg to ospfe.  Upon this event, originate a new link-lsa in
ospfe.  In rde a new intra-area-prefix-lsa is generated when a
link-lsa appears or goes away.
ok claudio@@; ok and test stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.18 2009/12/22 19:47:05 claudio Exp $ */
d486 2
@


1.18
log
@Crap. Remove debug code that I did not plan to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.16 2009/11/02 20:24:58 claudio Exp $ */
d478 2
@


1.17
log
@Holy inconsitancy Batman! While it is impossible to use embeded scope ids
in almost all sockaddr_in6 addresses it is required for the nexthop and
sin6_scope_id is actually ignored there.
This needs to be fixed but my quota of IPv6 insanity is already used for today.
Workaround for now. My simple testsetup is now actually able to install
the first ospf6d learned routes in the kernel. Weeee!
@
text
@a449 1
log_debug("IMSG_KROUTE_CHANGE");
a454 1
log_debug("IMSG_KROUTE_DELETE");
@


1.16
log
@Add IMSG_CTL_LOG_VERBOSE similar to ospfd it allows to toggle debug logging.
henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.15 2009/06/06 09:02:46 eric Exp $ */
d450 1
d456 1
@


1.15
log
@make ospf6ctl/ospf6d imsg-in-a-lib ready too.

ospf6ctl is already broken in tree (not connected to build).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.14 2009/05/31 20:29:56 jacekm Exp $ */
d164 1
a165 1

d356 1
a356 1
	int			 shut = 0;
d398 5
@


1.14
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.13 2009/05/31 17:00:40 claudio Exp $ */
d70 2
a71 2
struct imsgbuf		*ibuf_ospfe;
struct imsgbuf		*ibuf_rde;
d263 2
a264 2
	if ((ibuf_ospfe = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_rde = malloc(sizeof(struct imsgbuf))) == NULL)
d266 4
a269 2
	imsg_init(ibuf_ospfe, pipe_parent2ospfe[0], main_dispatch_ospfe);
	imsg_init(ibuf_rde, pipe_parent2rde[0], main_dispatch_rde);
d272 9
a280 9
	ibuf_ospfe->events = EV_READ;
	event_set(&ibuf_ospfe->ev, ibuf_ospfe->fd, ibuf_ospfe->events,
	    ibuf_ospfe->handler, ibuf_ospfe);
	event_add(&ibuf_ospfe->ev, NULL);

	ibuf_rde->events = EV_READ;
	event_set(&ibuf_rde->ev, ibuf_rde->fd, ibuf_rde->events,
	    ibuf_rde->handler, ibuf_rde);
	event_add(&ibuf_rde->ev, NULL);
d316 4
a319 4
	msgbuf_clear(&ibuf_ospfe->w);
	free(ibuf_ospfe);
	msgbuf_clear(&ibuf_rde->w);
	free(ibuf_rde);
d351 2
a352 1
	struct imsgbuf		*ibuf = bula;
d407 1
a407 1
		imsg_event_add(ibuf);
d410 1
a410 1
		event_del(&ibuf->ev);
d419 2
a420 1
	struct imsgbuf  *ibuf = bula;
d462 1
a462 1
		imsg_event_add(ibuf);
d465 1
a465 1
		event_del(&ibuf->ev);
d473 1
a473 1
	imsg_compose(ibuf_ospfe, type, 0, pid, data, datalen);
d479 1
a479 1
	imsg_compose(ibuf_rde, type, 0, pid, data, datalen);
a481 1
/* this needs to be added here so that ospfctl can be used without libevent */
d483 1
a483 1
imsg_event_add(struct imsgbuf *ibuf)
d485 19
a503 7
	ibuf->events = EV_READ;
	if (ibuf->w.queued)
		ibuf->events |= EV_WRITE;

	event_del(&ibuf->ev);
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf);
	event_add(&ibuf->ev, NULL);
d608 1
a608 1
	if (imsg_compose(ibuf_ospfe, type, 0, 0, buf, len) == -1)
d610 1
a610 1
	if (imsg_compose(ibuf_rde, type, 0, 0, buf, len) == -1)
@


1.13
log
@libevent handler fix to allow EV_READ and EV_WRITE to be set at the same
time in the callback. Same diff that went into ospfd applied with some
fuzz.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.12 2009/03/28 15:38:58 michele Exp $ */
a363 1
		imsg_event_add(ibuf);
a429 1
		imsg_event_add(ibuf);
@


1.12
log
@Print the correct function name in log_debug().

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.11 2008/12/28 22:05:04 sobrado Exp $ */
d355 1
a355 2
	switch (event) {
	case EV_READ:
d360 2
a361 2
		break;
	case EV_WRITE:
a364 3
		return;
	default:
		fatalx("unknown event");
d422 1
a422 2
	switch (event) {
	case EV_READ:
d427 2
a428 2
		break;
	case EV_WRITE:
a431 3
		return;
	default:
		fatalx("unknown event");
@


1.11
log
@a few documentation updates for opsf6(8) and ospf6ctl(8): remove an
existing (but undocumented) flag from the usage of ospf6d;
documentation tweaks; while here, synchronize synopsis and usage.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.10 2008/05/13 11:46:57 pyr Exp $ */
d716 1
a716 1
			log_debug("merge_config: proc %d area %s removing "
d730 1
a730 1
			log_debug("merge_config: proc %d area %s adding "
d739 2
a740 2
		log_debug("merge_config: proc %d area %s merging interface %s",
		    ospfd_process, inet_ntoa(a->id), i->name);
@


1.10
log
@Unmangle previous commit. spotted by markus@@ (wow !)
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.9 2008/05/12 19:15:02 pyr Exp $ */
d121 1
a121 1
	fprintf(stderr, "usage: %s [-cdnv] [-D macro=value] [-f file]\n",
@


1.9
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.8 2007/12/13 08:54:05 claudio Exp $ */
d172 4
a175 4
        argc -= optind;
        argv += optind;
        if (argc > 0)
                usage();
@


1.8
log
@Monster commit of stuff I did mostly last month. What it does:
 * removes kif and uses iface for everything interface related.
   This removes unneeded data redundancy which makes the code more complex.
 * adds the link local prefix to struct iface and attaches a list with
   the other prefixes to the struct iface. This is needed to generate the
   link LSA.
 * disconnects struct iface from struct area (the backpointer is gone)
   this will make the reload code a bit easier.
norby@@ agrees with the direction we're heading with this
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.7 2007/10/25 12:05:20 claudio Exp $ */
d171 5
@


1.7
log
@Support -D makro=value like bgpd and ripd. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.6 2007/10/20 13:26:50 pyr Exp $ */
a129 1
	struct area		*a;
d186 2
a187 2
	/* fetch interfaces early */
	kif_init();
a277 6
	/* remove unneded stuff from config */
	while ((a = LIST_FIRST(&ospfd_conf->area_list)) != NULL) {
		LIST_REMOVE(a, entry);
		area_del(a);
	}

a389 8
		case IMSG_CTL_IFINFO:
			if (imsg.hdr.len == IMSG_HEADER_SIZE)
				kr_ifinfo(NULL, imsg.hdr.pid);
			else if (imsg.hdr.len == IMSG_HEADER_SIZE + IFNAMSIZ)
				kr_ifinfo(imsg.data, imsg.hdr.pid);
			else
				log_warnx("IFINFO request with wrong len");
			break;
a568 1
	struct iface		*iface;
d578 1
a578 1
	/* send interfaces */
a581 5

		LIST_FOREACH(iface, &area->iface_list, entry)
			if (ospf_sendboth(IMSG_RECONF_IFACE, iface,
			    sizeof(*iface)) == -1)
				return (-1);
d587 2
d653 2
a654 8
				LIST_FOREACH(iface, &xa->iface_list, entry) {
					if_init(conf, iface);
					if (if_fsm(iface, IF_EVT_UP)) {
						log_debug("error starting "
						    "interface %s",
						    iface->name);
					}
				}
d679 1
a679 6
					if_init(conf, iface);
					if (if_fsm(iface, IF_EVT_UP)) {
						log_debug("error starting "
						    "interface %s",
						    iface->name);
					}
d684 1
a684 1
				orig_rtr_lsa(a);
a729 1
			xi->area = a;
d754 1
d763 1
@


1.6
log
@Sync parse.y with recent enhancements in hoststated.
Fix behavior when running -n.
henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.5 2007/10/16 08:41:56 claudio Exp $ */
d121 2
a122 1
	fprintf(stderr, "usage: %s [-cdnv] [-f file]\n", __progname);
d142 1
a142 1
	while ((ch = getopt(argc, argv, "cdf:nv")) != -1) {
d149 5
@


1.5
log
@First step at making kroute IPv6 aware. This resulted in many additional
changes -- some are so hairy that I left them out for later by commenting out
larger blocks of code (just grep for XXX if you like to help).
Get it in early so that we can work on.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.4 2007/10/13 16:35:22 deraadt Exp $ */
d139 2
a166 3
	/* start logging */
	log_init(debug);

d203 2
@


1.4
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.3 2007/10/11 21:25:37 claudio Exp $ */
d508 1
d511 1
a511 1
	if (kr->prefix.s_addr == INADDR_ANY && kr->prefixlen == 0)
d546 4
a549 3
			if ((kr->prefix.s_addr & r->mask.s_addr) ==
			    (r->addr.s_addr & r->mask.s_addr) &&
			    kr->prefixlen >= mask2prefixlen(r->mask.s_addr)) {
d551 1
a551 1
				return (r->type & REDIST_NO? 0 : 1);
@


1.3
log
@No need to store the interface mask. An interface represents a link and is
only addressed via its link local address. All networks on top of it are
handled separately via type 8 Link-LSA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.2 2007/10/11 19:02:47 claudio Exp $ */
a57 1
int	check_file_secrecy(int, const char *);
a488 23
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		warn("cannot stat %s", fname);
		return (-1);
	}

	if (st.st_uid != 0 && st.st_uid != getuid()) {
		warnx("%s: owner not root or current user", fname);
		return (-1);
	}

	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		warnx("%s: group/world readable/writeable", fname);
		return (-1);
	}

	return (0);
@


1.2
log
@From ospfd:
Bye bye global ospf options. OSPF options are per area (at least the one
flag that we set). So introduce a area_ospf_options() function that will
return the correct flags for each area. This makes stub area support a lot
easier.
Don't check for OSPF_OPTION_E in the parent. OSPF_OPTION_E is per area and
so the parent process has no way to know if it should redistribute or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.c,v 1.1 2007/10/08 10:44:50 norby Exp $ */
a783 1
		i->mask = xi->mask;
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.c,v 1.48 2007/07/25 19:11:27 claudio Exp $ */
a531 4

	/* stub area router? */
	if ((ospfd_conf->options & OSPF_OPTION_E) == 0)
		return (0);
@

