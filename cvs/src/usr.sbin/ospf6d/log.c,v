head	1.14;
access;
symbols
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.10
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.8
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.7.0.4
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.14
date	2017.03.21.12.06.56;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	6uuBMurt3Uh42fgX;

1.13
date	2017.01.23.08.41.02;	author benno;	state Exp;
branches;
next	1.12;
commitid	bknMQJV4A7RndI2I;

1.12
date	2016.09.02.14.06.35;	author benno;	state Exp;
branches;
next	1.11;
commitid	Z2jEGSLNZuIKq53q;

1.11
date	2014.11.03.07.40.31;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	KxzfvwQ64ayFBEwr;

1.10
date	2012.10.22.07.28.49;	author bluhm;	state Exp;
branches;
next	1.9;

1.9
date	2012.09.20.07.22.48;	author bluhm;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.19.19.15.27;	author bluhm;	state Exp;
branches;
next	1.7;

1.7
date	2011.08.20.19.02.28;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2009.12.22.17.45.47;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.02.20.24.58;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.29.19.07.56;	author stsp;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.14.20.42.05;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.08.20.28.17;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.50;	author norby;	state Exp;
branches;
next	;


desc
@@


1.14
log
@From a syslog perspective it does not make sense to log fatal and
warn with the same severity.  Switch log_warn() to LOG_ERR and keep
fatal() at LOG_CRIT.
OK reyk@@ florian@@
@
text
@/*	$OpenBSD: log.c,v 1.13 2017/01/23 08:41:02 benno Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>

#include "log.h"
#include "ospf6d.h"

int		 debug;
int		 verbose;
const char	*log_procname;

void
log_init(int n_debug)
{
	extern char	*__progname;

	debug = n_debug;

	if (!debug)
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);

	tzset();
}

void
log_verbose(int v)
{
	verbose = v;
}

void
logit(int pri, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vlog(pri, fmt, ap);
	va_end(ap);
}

void
vlog(int pri, const char *fmt, va_list ap)
{
	char	*nfmt;

	if (debug) {
		/* best effort in out of mem situations */
		if (asprintf(&nfmt, "%s\n", fmt) == -1) {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		} else {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
		}
		fflush(stderr);
	} else
		vsyslog(pri, fmt, ap);
}

void
log_warn(const char *emsg, ...)
{
	char	*nfmt;
	va_list	 ap;

	/* best effort to even work in out of memory situations */
	if (emsg == NULL)
		logit(LOG_ERR, "%s", strerror(errno));
	else {
		va_start(ap, emsg);

		if (asprintf(&nfmt, "%s: %s", emsg, strerror(errno)) == -1) {
			/* we tried it... */
			vlog(LOG_ERR, emsg, ap);
			logit(LOG_ERR, "%s", strerror(errno));
		} else {
			vlog(LOG_ERR, nfmt, ap);
			free(nfmt);
		}
		va_end(ap);
	}
}

void
log_warnx(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_ERR, emsg, ap);
	va_end(ap);
}

void
log_info(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_INFO, emsg, ap);
	va_end(ap);
}

void
log_debug(const char *emsg, ...)
{
	va_list	 ap;

	if (verbose) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

void
fatal(const char *emsg, ...)
{
	char	 s[1024];
	va_list	 ap;

	va_start(ap, emsg);
	vsnprintf(s, sizeof(s), emsg, ap);
	va_end(ap);

	if (emsg == NULL)
		logit(LOG_CRIT, "fatal in %s: %s", log_procname,
		    strerror(errno));
	else
		if (errno)
			logit(LOG_CRIT, "fatal in %s: %s: %s",
			    log_procname, s, strerror(errno));
		else
			logit(LOG_CRIT, "fatal in %s: %s",
			    log_procname, s);

	exit(1);
}

void
fatalx(const char *emsg)
{
	errno = 0;
	fatal(emsg);
}
@


1.13
log
@copy log.c/h from bgpd.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.9 2016/09/02 14:02:48 benno Exp $ */
d90 1
a90 1
		logit(LOG_CRIT, "%s", strerror(errno));
d96 2
a97 2
			vlog(LOG_CRIT, emsg, ap);
			logit(LOG_CRIT, "%s", strerror(errno));
d99 1
a99 1
			vlog(LOG_CRIT, nfmt, ap);
d112 1
a112 1
	vlog(LOG_CRIT, emsg, ap);
@


1.12
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.11 2014/11/03 07:40:31 bluhm Exp $ */
a3 1
 * Copyright (c) 2006 Claudio Jeker <claudio@@openbsd.org>
a25 1
#include <unistd.h>
d139 1
a139 1
fatal(const char *emsg)
d141 7
d154 1
a154 1
			    log_procname, emsg, strerror(errno));
d157 1
a157 1
			    log_procname, emsg);
d159 1
a159 4
	if (ospfd_process == PROC_MAIN)
		exit(1);
	else				/* parent copes via SIGCHLD */
		_exit(1);
@


1.11
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.10 2012/10/22 07:28:49 bluhm Exp $ */
a19 6
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <netdb.h>
d26 1
d29 1
a30 1
#include "log.h"
d32 3
a34 8
static const char * const procnames[] = {
	"parent",
	"ospfe",
	"rde"
};

int	debug;
int	verbose;
d144 1
a144 1
		logit(LOG_CRIT, "fatal in %s: %s", procnames[ospfd_process],
d149 1
a149 1
			    procnames[ospfd_process], emsg, strerror(errno));
d152 1
a152 1
			    procnames[ospfd_process], emsg);
a164 167
}

const char *
log_in6addr(const struct in6_addr *addr)
{
	struct sockaddr_in6	sa_in6;

	bzero(&sa_in6, sizeof(sa_in6));
	sa_in6.sin6_len = sizeof(sa_in6);
	sa_in6.sin6_family = AF_INET6;
	memcpy(&sa_in6.sin6_addr, addr, sizeof(sa_in6.sin6_addr));

	/*
	 * Destination addresses contain embedded scopes.
	 * They must be recovered for ospf6ctl show fib.
	 */
	recoverscope(&sa_in6);

	return (log_sockaddr(&sa_in6));
}

const char *
log_in6addr_scope(const struct in6_addr *addr, unsigned int ifindex)
{
	struct sockaddr_in6	sa_in6;

	bzero(&sa_in6, sizeof(sa_in6));
	sa_in6.sin6_len = sizeof(sa_in6);
	sa_in6.sin6_family = AF_INET6;
	memcpy(&sa_in6.sin6_addr, addr, sizeof(sa_in6.sin6_addr));

	addscope(&sa_in6, ifindex);

	return (log_sockaddr(&sa_in6));
}

#define NUM_LOGS	4
const char *
log_rtr_id(u_int32_t id)
{
	static char	buf[NUM_LOGS][16];
	static int	round = 0;
	struct in_addr	addr;

	round = (round + 1) % NUM_LOGS;

	addr.s_addr = id;
	if (inet_ntop(AF_INET, &addr, buf[round], 16) == NULL)
		return ("?");
	else
		return buf[round];
}

const char *
log_sockaddr(void *vp)
{
	static char	buf[NUM_LOGS][NI_MAXHOST];
	static int	round = 0;
	struct sockaddr	*sa = vp;

	round = (round + 1) % NUM_LOGS;

	if (getnameinfo(sa, sa->sa_len, buf[round], NI_MAXHOST, NULL, 0,
	    NI_NUMERICHOST))
		return ("(unknown)");
	else
		return (buf[round]);
}

/* names */
const char *
nbr_state_name(int state)
{
	switch (state) {
	case NBR_STA_DOWN:
		return ("DOWN");
	case NBR_STA_ATTEMPT:
		return ("ATTMP");
	case NBR_STA_INIT:
		return ("INIT");
	case NBR_STA_2_WAY:
		return ("2-WAY");
	case NBR_STA_XSTRT:
		return ("EXSTA");
	case NBR_STA_SNAP:
		return ("SNAP");
	case NBR_STA_XCHNG:
		return ("EXCHG");
	case NBR_STA_LOAD:
		return ("LOAD");
	case NBR_STA_FULL:
		return ("FULL");
	default:
		return ("UNKNW");
	}
}

const char *
if_state_name(int state)
{
	switch (state) {
	case IF_STA_DOWN:
		return ("DOWN");
	case IF_STA_LOOPBACK:
		return ("LOOP");
	case IF_STA_WAITING:
		return ("WAIT");
	case IF_STA_POINTTOPOINT:
		return ("P2P");
	case IF_STA_DROTHER:
		return ("OTHER");
	case IF_STA_BACKUP:
		return ("BCKUP");
	case IF_STA_DR:
		return ("DR");
	default:
		return ("UNKNW");
	}
}

const char *
if_type_name(enum iface_type type)
{
	switch (type) {
	case IF_TYPE_POINTOPOINT:
		return ("POINTOPOINT");
	case IF_TYPE_BROADCAST:
		return ("BROADCAST");
	case IF_TYPE_NBMA:
		return ("NBMA");
	case IF_TYPE_POINTOMULTIPOINT:
		return ("POINTOMULTIPOINT");
	case IF_TYPE_VIRTUALLINK:
		return ("VIRTUALLINK");
	}
	/* NOTREACHED */
	return ("UNKNOWN");
}

const char *
dst_type_name(enum dst_type type)
{
	switch (type) {
	case DT_NET:
		return ("Network");
	case DT_RTR:
		return ("Router");
	}
	/* NOTREACHED */
	return ("unknown");
}

const char *
path_type_name(enum path_type type)
{
	switch (type) {
	case PT_INTRA_AREA:
		return ("Intra-Area");
	case PT_INTER_AREA:
		return ("Inter-Area");
	case PT_TYPE1_EXT:
		return ("Type 1 ext");
	case PT_TYPE2_EXT:
		return ("Type 2 ext");
	}
	/* NOTREACHED */
	return ("unknown");
@


1.10
log
@Unfortunately "ospf6ctl show fib" printed embedded scopes as the
destination addresses still contain them.  To fix that, call
recoverscope() in log_in6addr().  Also log_in6addr_scope() should
not fiddle with the scope itself, put that into a generic function
addscope().
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.9 2012/09/20 07:22:48 bluhm Exp $ */
a44 2

void	 logit(int, const char *, ...);
@


1.9
log
@Bring back log_in6addr_scope() as ospf6ctl uses it.
Found by kettenis@@ the hard way.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.8 2012/09/19 19:15:27 bluhm Exp $ */
d189 6
d208 1
a208 5
	/* XXX thanks, IPv6 & KAME, for this ugliness... */
	if (IN6_IS_ADDR_LINKLOCAL(&sa_in6.sin6_addr) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&sa_in6.sin6_addr)) {
		sa_in6.sin6_scope_id = ifindex;
	}
@


1.8
log
@Do not care about the kame hack when logging a link local address.
The scope should have been converted when we received it from kernel.
Remove log_in6addr_scope(), it is not used.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.7 2011/08/20 19:02:28 sthen Exp $ */
d188 19
@


1.7
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"-v" (previously only "-vd" worked). Similar to recent ospfd commit.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.6 2009/12/22 17:45:47 claudio Exp $ */
a182 1
	u_int16_t		tmp16;
a187 28

	/* XXX thanks, KAME, for this ugliness... adopted from route/show.c */
	if (IN6_IS_ADDR_LINKLOCAL(&sa_in6.sin6_addr) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&sa_in6.sin6_addr)) {
		memcpy(&tmp16, &sa_in6.sin6_addr.s6_addr[2], sizeof(tmp16));
		sa_in6.sin6_scope_id = ntohs(tmp16);
		sa_in6.sin6_addr.s6_addr[2] = 0;
		sa_in6.sin6_addr.s6_addr[3] = 0;
	}

	return (log_sockaddr(&sa_in6));
}

const char *
log_in6addr_scope(const struct in6_addr *addr, unsigned int ifindex)
{
	struct sockaddr_in6	sa_in6;

	bzero(&sa_in6, sizeof(sa_in6));
	sa_in6.sin6_len = sizeof(sa_in6);
	sa_in6.sin6_family = AF_INET6;
	memcpy(&sa_in6.sin6_addr, addr, sizeof(sa_in6.sin6_addr));

	/* XXX thanks, IPv6 & KAME, for this ugliness... */
	if (IN6_IS_ADDR_LINKLOCAL(&sa_in6.sin6_addr) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&sa_in6.sin6_addr)) {
		sa_in6.sin6_scope_id = ifindex;
	}
@


1.6
log
@Implement log_in6addr_scope() yet another function doing the same thing
again but different because of link local addressing.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2009/11/02 20:24:58 claudio Exp $ */
a53 1
	verbose = n_debug;
@


1.5
log
@Add IMSG_CTL_LOG_VERBOSE similar to ospfd it allows to toggle debug logging.
henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.4 2009/03/29 19:07:56 stsp Exp $ */
d198 19
@


1.4
log
@Add log_rtr_id() function to log 32bit numbers in dot-quad notation.
Most obvious use is to log router IDs.
To facilitate logging of multiple IDs within the same format string,
we use NUM_LOGS static buffers, just like log_sockaddr() does.

help and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2007/10/14 20:42:05 claudio Exp $ */
d44 1
d54 1
d63 6
d146 1
a146 1
	if (debug) {
@


1.3
log
@Switch log_sockaddr() to take a void * so it is not necessary to cast the
sockaddr_in6 or sockaddr_in to a sockaddr.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2007/10/08 20:28:17 claudio Exp $ */
d196 16
@


1.2
log
@Use a small cyclic buffer ring in log_in6addr() so that the function can be
used more then once per printf. The current limit is 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.1 2007/10/08 10:44:50 norby Exp $ */
d192 1
a192 1
	return (log_sockaddr((struct sockaddr *)&sa_in6));
d197 1
a197 1
log_sockaddr(struct sockaddr *sa)
d201 1
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2006/03/09 16:58:40 claudio Exp $ */
d195 1
d199 2
a200 1
	static char	buf[NI_MAXHOST];
d202 3
a204 1
	if (getnameinfo(sa, sa->sa_len, buf, sizeof(buf), NULL, 0,
d208 1
a208 1
		return (buf);
@

