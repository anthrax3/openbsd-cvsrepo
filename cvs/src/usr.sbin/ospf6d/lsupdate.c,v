head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.10
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.8.0.12
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.10
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.8
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.4
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.13
date	2015.01.28.22.03.17;	author bluhm;	state Exp;
branches;
next	1.12;
commitid	uF8XZsdxBSPX6Mo0;

1.12
date	2015.01.22.22.09.39;	author tedu;	state Exp;
branches;
next	1.11;
commitid	T9OZHPLQerEDZIns;

1.11
date	2014.12.18.19.27.04;	author tedu;	state Exp;
branches;
next	1.10;
commitid	lXAgN9ObCWsjuTmX;

1.10
date	2013.03.25.14.29.35;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.25.14.23.47;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.08.16.04.25;	author bluhm;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.03.10.00.34;	author bluhm;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.01.14.39.52;	author bluhm;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.06.09.02.46;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.11.13.48.39;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.10.14.09.25;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.50;	author norby;	state Exp;
branches;
next	;


desc
@@


1.13
log
@When comparing the LSA with the Ack, also check the age field.  This
ensures that a LSA withdrawal is not acked by a previous update.
From Florian Riehm;  OK claudio@@
@
text
@/*	$OpenBSD: lsupdate.c,v 1.12 2015/01/22 22:09:39 tedu Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005, 2007 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip6.h>
#include <netinet/ip_ah.h>
#include <arpa/inet.h>

#include <stdlib.h>
#include <string.h>
#include <siphash.h>

#include "ospf6.h"
#include "ospf6d.h"
#include "log.h"
#include "ospfe.h"
#include "rde.h"

extern struct ospfd_conf	*oeconf;
extern struct imsgev		*iev_rde;

struct ibuf *prepare_ls_update(struct iface *, int);
int	add_ls_update(struct ibuf *, struct iface *, void *, int, u_int16_t);
int	send_ls_update(struct ibuf *, struct iface *, struct in6_addr, u_int32_t);

void	ls_retrans_list_insert(struct nbr *, struct lsa_entry *);
void	ls_retrans_list_remove(struct nbr *, struct lsa_entry *);

/* link state update packet handling */
int
lsa_flood(struct iface *iface, struct nbr *originator, struct lsa_hdr *lsa_hdr,
    void *data)
{
	struct nbr		*nbr;
	struct lsa_entry	*le = NULL;
	int			 queued = 0, dont_ack = 0;
	int			 r;

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr == iface->self)
			continue;
		if (!(nbr->state & NBR_STA_FLOOD))
			continue;

		if (iface->state & IF_STA_DROTHER && !queued)
			while ((le = ls_retrans_list_get(iface->self, lsa_hdr)))
			    ls_retrans_list_free(iface->self, le);

		while ((le = ls_retrans_list_get(nbr, lsa_hdr)))
			ls_retrans_list_free(nbr, le);

		if (!(nbr->state & NBR_STA_FULL) &&
		    (le = ls_req_list_get(nbr, lsa_hdr)) != NULL) {
			r = lsa_newer(lsa_hdr, le->le_lsa);
			if (r > 0) {
				/* to flood LSA is newer than requested */
				ls_req_list_free(nbr, le);
				/* new needs to be flooded */
			} else if (r < 0) {
				/* to flood LSA is older than requested */
				continue;
			} else {
				/* LSA are equal */
				ls_req_list_free(nbr, le);
				continue;
			}
		}

		if (nbr == originator) {
			dont_ack++;
			continue;
		}

		/* non DR or BDR router keep all lsa in one retrans list */
		if (iface->state & IF_STA_DROTHER) {
			if (!queued)
				ls_retrans_list_add(iface->self, data,
				    iface->rxmt_interval, 0);
			queued = 1;
		} else {
			ls_retrans_list_add(nbr, data, iface->rxmt_interval, 0);
			queued = 1;
		}
	}

	if (!queued)
		return (0);

	if (iface == originator->iface && iface->self != originator) {
		if (iface->dr == originator || iface->bdr == originator)
			return (0);
		if (iface->state & IF_STA_BACKUP)
			return (0);
		dont_ack++;
	}

	/*
	 * initial flood needs to be queued separately, timeout is zero
	 * and oneshot has to be set because the retransimssion queues
	 * are already loaded.
	 */
	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		ls_retrans_list_add(iface->self, data, 0, 1);
		break;
	case IF_TYPE_NBMA:
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
		LIST_FOREACH(nbr, &iface->nbr_list, entry) {
			if (nbr == iface->self)
				continue;
			if (!(nbr->state & NBR_STA_FLOOD))
				continue;
			if (!TAILQ_EMPTY(&nbr->ls_retrans_list)) {
				le = TAILQ_LAST(&nbr->ls_retrans_list,
				    lsa_head);
				if (lsa_hdr->type != le->le_lsa->type ||
				    lsa_hdr->ls_id != le->le_lsa->ls_id ||
				    lsa_hdr->adv_rtr != le->le_lsa->adv_rtr)
					continue;
			}
			ls_retrans_list_add(nbr, data, 0, 1);
		}
		break;
	default:
		fatalx("lsa_flood: unknown interface type");
	}

	return (dont_ack == 2);
}

struct ibuf *
prepare_ls_update(struct iface *iface, int bigpkt)
{
	struct ibuf		*buf;
	size_t			 size;

	size = bigpkt ? IPV6_MAXPACKET : iface->mtu;
	if (size < IPV6_MMTU)
		size = IPV6_MMTU;
	size -= sizeof(struct ip6_hdr);
	/*
	 * Reserve space for optional ah or esp encryption.  The
	 * algorithm is taken from ah_output and esp_output, the
	 * values are the maxima of crypto/xform.c.
	 */
	size -= max(
	    /* base-ah-header replay authsize */
	    AH_FLENGTH + sizeof(u_int32_t) + 32,
	    /* spi sequence ivlen blocksize pad-length next-header authsize */
	    2 * sizeof(u_int32_t) + 16 + 16 + 2 * sizeof(u_int8_t) + 32);

	if ((buf = ibuf_open(size)) == NULL)
		fatal("prepare_ls_update");

	/* OSPF header */
	if (gen_ospf_hdr(buf, iface, PACKET_TYPE_LS_UPDATE))
		goto fail;

	/* reserve space for number of lsa field */
	if (ibuf_reserve(buf, sizeof(u_int32_t)) == NULL)
		goto fail;

	return (buf);
fail:
	log_warn("prepare_ls_update");
	ibuf_free(buf);
	return (NULL);
}

int
add_ls_update(struct ibuf *buf, struct iface *iface, void *data, int len,
    u_int16_t older)
{
	size_t		pos;
	u_int16_t	age;

	if (buf->wpos + len >= buf->max)
		return (0);

	pos = buf->wpos;
	if (ibuf_add(buf, data, len)) {
		log_warn("add_ls_update");
		return (0);
	}

	/* age LSA before sending it out */
	memcpy(&age, data, sizeof(age));
	age = ntohs(age);
	if ((age += older + iface->transmit_delay) >= MAX_AGE)
		age = MAX_AGE;
	age = htons(age);
	memcpy(ibuf_seek(buf, pos, sizeof(age)), &age, sizeof(age));

	return (1);
}

int
send_ls_update(struct ibuf *buf, struct iface *iface, struct in6_addr addr,
    u_int32_t nlsa)
{
	int			 ret;

	nlsa = htonl(nlsa);
	memcpy(ibuf_seek(buf, sizeof(struct ospf_hdr), sizeof(nlsa)),
	    &nlsa, sizeof(nlsa));
	/* calculate checksum */
	if (upd_ospf_hdr(buf, iface))
		goto fail;

	ret = send_packet(iface, buf->buf, buf->wpos, &addr);

	ibuf_free(buf);
	return (ret);
fail:
	log_warn("send_ls_update");
	ibuf_free(buf);
	return (-1);
}

void
recv_ls_update(struct nbr *nbr, char *buf, u_int16_t len)
{
	struct lsa_hdr		 lsa;
	u_int32_t		 nlsa;

	if (len < sizeof(nlsa)) {
		log_warnx("recv_ls_update: bad packet size, neighbor ID %s",
		    inet_ntoa(nbr->id));
		return;
	}
	memcpy(&nlsa, buf, sizeof(nlsa));
	nlsa = ntohl(nlsa);
	buf += sizeof(nlsa);
	len -= sizeof(nlsa);

	switch (nbr->state) {
	case NBR_STA_DOWN:
	case NBR_STA_ATTEMPT:
	case NBR_STA_INIT:
	case NBR_STA_2_WAY:
	case NBR_STA_XSTRT:
	case NBR_STA_SNAP:
		log_debug("recv_ls_update: packet ignored in state %s, "
		    "neighbor ID %s", nbr_state_name(nbr->state),
		    inet_ntoa(nbr->id));
		break;
	case NBR_STA_XCHNG:
	case NBR_STA_LOAD:
	case NBR_STA_FULL:
		for (; nlsa > 0 && len > 0; nlsa--) {
			if (len < sizeof(lsa)) {
				log_warnx("recv_ls_update: bad packet size, "
				    "neighbor ID %s", inet_ntoa(nbr->id));
				return;
			}
			memcpy(&lsa, buf, sizeof(lsa));
			if (len < ntohs(lsa.len)) {
				log_warnx("recv_ls_update: bad packet size, "
				    "neighbor ID %s", inet_ntoa(nbr->id));
				return;
			}
			imsg_compose_event(iev_rde, IMSG_LS_UPD, nbr->peerid, 0,
			    -1, buf, ntohs(lsa.len));
			buf += ntohs(lsa.len);
			len -= ntohs(lsa.len);
		}
		if (nlsa > 0 || len > 0) {
			log_warnx("recv_ls_update: bad packet size, "
			    "neighbor ID %s", inet_ntoa(nbr->id));
			return;
		}
		break;
	default:
		fatalx("recv_ls_update: unknown neighbor state");
	}
}

/* link state retransmit list */
void
ls_retrans_list_add(struct nbr *nbr, struct lsa_hdr *lsa,
    unsigned short timeout, unsigned short oneshot)
{
	struct timeval		 tv;
	struct lsa_entry	*le;
	struct lsa_ref		*ref;

	if ((ref = lsa_cache_get(lsa)) == NULL)
		fatalx("King Bula sez: somebody forgot to lsa_cache_add");

	if ((le = calloc(1, sizeof(*le))) == NULL)
		fatal("ls_retrans_list_add");

	le->le_ref = ref;
	le->le_when = timeout;
	le->le_oneshot = oneshot;

	ls_retrans_list_insert(nbr, le);

	if (!evtimer_pending(&nbr->ls_retrans_timer, NULL)) {
		timerclear(&tv);
		tv.tv_sec = TAILQ_FIRST(&nbr->ls_retrans_list)->le_when;

		if (evtimer_add(&nbr->ls_retrans_timer, &tv) == -1)
			fatal("ls_retrans_list_add");
	}
}

int
ls_retrans_list_del(struct nbr *nbr, struct lsa_hdr *lsa_hdr)
{
	struct lsa_entry	*le;

	if ((le = ls_retrans_list_get(nbr, lsa_hdr)) == NULL)
		return (-1);
	/*
	 * Compare LSA with the Ack by comparing not only the seq_num and
	 * checksum but also the age field.  Since we only care about MAX_AGE
	 * vs. non-MAX_AGE LSA, a simple >= comparison is good enough.  This
	 * ensures that a LSA withdrawal is not acked by a previous update.
	 */
	if (lsa_hdr->seq_num == le->le_ref->hdr.seq_num &&
	    lsa_hdr->ls_chksum == le->le_ref->hdr.ls_chksum &&
	    ntohs(lsa_hdr->age) >= ntohs(le->le_ref->hdr.age)) {
		ls_retrans_list_free(nbr, le);
		return (0);
	}

	return (-1);
}

struct lsa_entry *
ls_retrans_list_get(struct nbr *nbr, struct lsa_hdr *lsa_hdr)
{
	struct lsa_entry	*le;

	TAILQ_FOREACH(le, &nbr->ls_retrans_list, entry) {
		if ((lsa_hdr->type == le->le_ref->hdr.type) &&
		    (lsa_hdr->ls_id == le->le_ref->hdr.ls_id) &&
		    (lsa_hdr->adv_rtr == le->le_ref->hdr.adv_rtr))
			return (le);
	}
	return (NULL);
}

void
ls_retrans_list_insert(struct nbr *nbr, struct lsa_entry *new)
{
	struct lsa_entry	*le;
	unsigned short		 when = new->le_when;

	TAILQ_FOREACH(le, &nbr->ls_retrans_list, entry) {
		if (when < le->le_when) {
			new->le_when = when;
			TAILQ_INSERT_BEFORE(le, new, entry);
			nbr->ls_ret_cnt++;
			return;
		}
		when -= le->le_when;
	}
	new->le_when = when;
	TAILQ_INSERT_TAIL(&nbr->ls_retrans_list, new, entry);
	nbr->ls_ret_cnt++;
}

void
ls_retrans_list_remove(struct nbr *nbr, struct lsa_entry *le)
{
	struct timeval		 tv;
	struct lsa_entry	*next = TAILQ_NEXT(le, entry);
	int			 reset = 0;

	/* adjust timeout of next entry */
	if (next)
		next->le_when += le->le_when;

	if (TAILQ_FIRST(&nbr->ls_retrans_list) == le &&
	    evtimer_pending(&nbr->ls_retrans_timer, NULL))
		reset = 1;

	TAILQ_REMOVE(&nbr->ls_retrans_list, le, entry);
	nbr->ls_ret_cnt--;

	if (reset && TAILQ_FIRST(&nbr->ls_retrans_list)) {
		if (evtimer_del(&nbr->ls_retrans_timer) == -1)
			fatal("ls_retrans_list_remove");

		timerclear(&tv);
		tv.tv_sec = TAILQ_FIRST(&nbr->ls_retrans_list)->le_when;

		if (evtimer_add(&nbr->ls_retrans_timer, &tv) == -1)
			fatal("ls_retrans_list_remove");
	}
}

void
ls_retrans_list_free(struct nbr *nbr, struct lsa_entry *le)
{
	ls_retrans_list_remove(nbr, le);

	lsa_cache_put(le->le_ref, nbr);
	free(le);
}

void
ls_retrans_list_clr(struct nbr *nbr)
{
	struct lsa_entry	*le;

	while ((le = TAILQ_FIRST(&nbr->ls_retrans_list)) != NULL)
		ls_retrans_list_free(nbr, le);

	nbr->ls_ret_cnt = 0;
}

/* ARGSUSED */
void
ls_retrans_timer(int fd, short event, void *bula)
{
	struct timeval		 tv;
	struct timespec		 tp;
	struct in6_addr		 addr;
	struct nbr		*nbr = bula;
	struct lsa_entry	*le;
	struct ibuf		*buf;
	time_t			 now;
	int			 bigpkt, d;
	u_int32_t		 nlsa = 0;

	if ((le = TAILQ_FIRST(&nbr->ls_retrans_list)) != NULL)
		le->le_when = 0;	/* timer fired */
	else
		return;			/* queue empty, nothing to do */

	clock_gettime(CLOCK_MONOTONIC, &tp);
	now = tp.tv_sec;

	if (nbr->iface->self == nbr) {
		/*
		 * oneshot needs to be set for lsa queued for flooding,
		 * if oneshot is not set then the lsa needs to be converted
		 * because the router switched lately to DR or BDR
		 */
		if (le->le_oneshot && nbr->iface->state & IF_STA_DRORBDR)
			inet_pton(AF_INET6, AllSPFRouters, &addr);
		else if (nbr->iface->state & IF_STA_DRORBDR) {
			/*
			 * old retransmission needs to be converted into
			 * flood by rerunning the lsa_flood.
			 */
			lsa_flood(nbr->iface, nbr, &le->le_ref->hdr,
			    le->le_ref->data);
			ls_retrans_list_free(nbr, le);
			/* ls_retrans_list_free retriggers the timer */
			return;
		} else if (nbr->iface->type == IF_TYPE_POINTOPOINT)
			memcpy(&addr, &nbr->iface->dst, sizeof(addr));
		else
			inet_pton(AF_INET6, AllDRouters, &addr);
	} else
		memcpy(&addr, &nbr->addr, sizeof(addr));

	/*
	 * Allow big ipv6 packets that may get fragmented if a
	 * single lsa might be too big for an unfragmented packet.
	 * To avoid the exact algorithm duplicated here, just make
	 * a good guess.  If the first lsa is bigger than 1024
	 * bytes, reserve a separate big packet for it.  The kernel
	 * will figure out if fragmentation is necessary.  For
	 * smaller lsas, we avoid big packets and fragmentation.
	 */
	bigpkt = le->le_ref->len > 1024;
	if ((buf = prepare_ls_update(nbr->iface, bigpkt)) == NULL) {
		le->le_when = 1;
		goto done;
	}

	while ((le = TAILQ_FIRST(&nbr->ls_retrans_list)) != NULL &&
	    le->le_when == 0) {
		d = now - le->le_ref->stamp;
		if (d < 0)
			d = 0;
		else if (d > MAX_AGE)
			d = MAX_AGE;

		if (add_ls_update(buf, nbr->iface, le->le_ref->data,
		    le->le_ref->len, d) == 0) {
			if (nlsa)
				break;
			/*
			 * A single lsa is too big to fit into an update
			 * packet.  In this case drop the lsa, otherwise
			 * we send empty update packets in an endless loop.
			 */
			log_warnx("ls_retrans_timer: cannot send lsa, dropped");
			log_debug("ls_retrans_timer: type: %04x len: %u",
			    ntohs(le->le_ref->hdr.type), le->le_ref->len);
			ls_retrans_list_free(nbr, le);
			continue;
		}
		nlsa++;
		if (le->le_oneshot)
			ls_retrans_list_free(nbr, le);
		else {
			TAILQ_REMOVE(&nbr->ls_retrans_list, le, entry);
			nbr->ls_ret_cnt--;
			le->le_when = nbr->iface->rxmt_interval;
			ls_retrans_list_insert(nbr, le);
		}
		/* do not put additional lsa into fragmented big packet */
		if (bigpkt)
			break;
	}
	send_ls_update(buf, nbr->iface, addr, nlsa);

done:
	if ((le = TAILQ_FIRST(&nbr->ls_retrans_list)) != NULL) {
		timerclear(&tv);
		tv.tv_sec = le->le_when;

		if (evtimer_add(&nbr->ls_retrans_timer, &tv) == -1)
			fatal("ls_retrans_timer");
	}
}

LIST_HEAD(lsa_cache_head, lsa_ref);

struct lsa_cache {
	struct lsa_cache_head	*hashtbl;
	u_int32_t		 hashmask;
} lsacache;

SIPHASH_KEY lsacachekey;

struct lsa_ref		*lsa_cache_look(struct lsa_hdr *);

void
lsa_cache_init(u_int32_t hashsize)
{
	u_int32_t        hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	lsacache.hashtbl = calloc(hs, sizeof(struct lsa_cache_head));
	if (lsacache.hashtbl == NULL)
		fatal("lsa_cache_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&lsacache.hashtbl[i]);
	arc4random_buf(&lsacachekey, sizeof(lsacachekey));

	lsacache.hashmask = hs - 1;
}

static uint32_t
lsa_hash_hdr(const struct lsa_hdr *hdr)
{
	return SipHash24(&lsacachekey, hdr, sizeof(*hdr));
}

struct lsa_ref *
lsa_cache_add(void *data, u_int16_t len)
{
	struct lsa_cache_head	*head;
	struct lsa_ref		*ref, *old;
	struct timespec		 tp;

	if ((ref = calloc(1, sizeof(*ref))) == NULL)
		fatal("lsa_cache_add");
	memcpy(&ref->hdr, data, sizeof(ref->hdr));

	if ((old = lsa_cache_look(&ref->hdr))) {
		free(ref);
		old->refcnt++;
		return (old);
	}

	if ((ref->data = malloc(len)) == NULL)
		fatal("lsa_cache_add");
	memcpy(ref->data, data, len);

	clock_gettime(CLOCK_MONOTONIC, &tp);
	ref->stamp = tp.tv_sec;
	ref->len = len;
	ref->refcnt = 1;

	head = &lsacache.hashtbl[lsa_hash_hdr(&ref->hdr) & lsacache.hashmask];
	LIST_INSERT_HEAD(head, ref, entry);
	return (ref);
}

struct lsa_ref *
lsa_cache_get(struct lsa_hdr *lsa_hdr)
{
	struct lsa_ref		*ref;

	ref = lsa_cache_look(lsa_hdr);
	if (ref)
		ref->refcnt++;

	return (ref);
}

void
lsa_cache_put(struct lsa_ref *ref, struct nbr *nbr)
{
	if (--ref->refcnt > 0)
		return;

	if (ntohs(ref->hdr.age) >= MAX_AGE)
		ospfe_imsg_compose_rde(IMSG_LS_MAXAGE, nbr->peerid, 0,
		    ref->data, sizeof(struct lsa_hdr));

	free(ref->data);
	LIST_REMOVE(ref, entry);
	free(ref);
}

struct lsa_ref *
lsa_cache_look(struct lsa_hdr *lsa_hdr)
{
	struct lsa_cache_head	*head;
	struct lsa_ref		*ref;

	head = &lsacache.hashtbl[lsa_hash_hdr(lsa_hdr) & lsacache.hashmask];

	LIST_FOREACH(ref, head, entry) {
		if (memcmp(&ref->hdr, lsa_hdr, sizeof(*lsa_hdr)) == 0)
			/* found match */
			return (ref);
	}

	return (NULL);
}
@


1.12
log
@remove a stupid -Wstrict-prototype warning by making the hash function
static. noticed by florian riehm
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.11 2014/12/18 19:27:04 tedu Exp $ */
d335 6
d342 2
a343 1
	    lsa_hdr->ls_chksum == le->le_ref->hdr.ls_chksum) {
@


1.11
log
@simple to use siphash here. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.10 2013/03/25 14:29:35 markus Exp $ */
d567 1
a567 1
uint32_t
@


1.10
log
@sync w/ospfd: improve snapshot handling; ok claudio, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.8 2010/06/08 16:04:25 bluhm Exp $ */
a20 1
#include <sys/hash.h>
d29 1
d545 2
d562 1
d567 6
d599 1
a599 2
	head = &lsacache.hashtbl[hash32_buf(&ref->hdr, sizeof(ref->hdr),
	    HASHINIT) & lsacache.hashmask];
d637 1
a637 2
	head = &lsacache.hashtbl[hash32_buf(lsa_hdr, sizeof(*lsa_hdr),
	    HASHINIT) & lsacache.hashmask];
@


1.9
log
@sync w/ ospfd:
for point-to-point interfaces we need to send lsupdates to the
interface address, since there is no DR and multicast messages to
the DR will be ignored.  ok claudio@@, then@@
@
text
@@


1.8
log
@Calculate size of update packet with IPv6 header and reserve space
for IPsec.  Avoid IPv6 fragments where possible.  If a single LSA
is too big, put it into a separate packet with up to IPV6_MAXPACKET
bytes.  This packet may get fragmented by the kernel.
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.7 2010/06/03 10:00:34 bluhm Exp $ */
d468 3
a470 1
		} else
@


1.7
log
@The is no md5 authentication in OSPFv3.  Remove some leftovers from
the ospf6d packet lenght calculation.
ok claudio@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.6 2010/06/01 14:39:52 bluhm Exp $ */
d24 2
d40 1
a40 1
struct ibuf *prepare_ls_update(struct iface *);
d152 1
a152 1
prepare_ls_update(struct iface *iface)
d155 1
d157 16
a172 1
	if ((buf = ibuf_open(iface->mtu - sizeof(struct ip))) == NULL)
d439 1
a439 1
	int			 d;
d473 11
a483 1
	if ((buf = prepare_ls_update(nbr->iface)) == NULL) {
d520 3
@


1.6
log
@With IPv6 OSPF a single LSA can get larger than the MTU.  As a
workaround it is better to drop this LSA with a log entry instead
of sending emtpy update packets in a burst.  As link LSAs cannot
be split, the propper solution might be IPv6 fragments.  See also
RFC5340 Section 4.4.3.8 and Appendix A.1.
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.5 2010/05/26 13:56:08 nicm Exp $ */
d179 1
a179 1
	if (buf->wpos + len >= buf->max - MD5_DIGEST_LENGTH)
@


1.5
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.4 2009/06/06 09:02:46 eric Exp $ */
d469 14
a482 2
		    le->le_ref->len, d) == 0)
			break;
@


1.4
log
@make ospf6ctl/ospf6d imsg-in-a-lib ready too.

ospf6ctl is already broken in tree (not connected to build).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.3 2008/02/11 13:48:39 norby Exp $ */
d38 3
a40 3
struct buf *prepare_ls_update(struct iface *);
int	add_ls_update(struct buf *, struct iface *, void *, int, u_int16_t);
int	send_ls_update(struct buf *, struct iface *, struct in6_addr, u_int32_t);
d149 1
a149 1
struct buf *
d152 1
a152 1
	struct buf		*buf;
d154 1
a154 1
	if ((buf = buf_open(iface->mtu - sizeof(struct ip))) == NULL)
d162 1
a162 1
	if (buf_reserve(buf, sizeof(u_int32_t)) == NULL)
d168 1
a168 1
	buf_free(buf);
d173 1
a173 1
add_ls_update(struct buf *buf, struct iface *iface, void *data, int len,
d183 1
a183 1
	if (buf_add(buf, data, len)) {
d194 1
a194 1
	memcpy(buf_seek(buf, pos, sizeof(age)), &age, sizeof(age));
d200 1
a200 1
send_ls_update(struct buf *buf, struct iface *iface, struct in6_addr addr,
d206 1
a206 1
	memcpy(buf_seek(buf, sizeof(struct ospf_hdr), sizeof(nlsa)),
d214 1
a214 1
	buf_free(buf);
d218 1
a218 1
	buf_free(buf);
d419 1
a419 1
	struct buf		*buf;
@


1.3
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.2 2007/10/10 14:09:25 claudio Exp $ */
d36 1
a36 1
extern struct imsgbuf		*ibuf_rde;
d264 2
a265 2
			imsg_compose(ibuf_rde, IMSG_LS_UPD, nbr->peerid, 0,
			    buf, ntohs(lsa.len));
@


1.2
log
@send_packet() now takes a struct in6_addr as destination instead of a
struct sockaddr_in6 and builds the struct sockaddr_in6 internaly adding scope
if necessary. While there switch to sendto() we don't need any of the sendmsg()
features here.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.1 2007/10/08 10:44:50 norby Exp $ */
d155 1
a155 1
		fatal("send_ls_update");
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lsupdate.c,v 1.32 2006/06/02 18:49:55 norby Exp $ */
a202 1
	struct sockaddr_in6	 dst;
d212 1
a212 6
	/* set destination */
	dst.sin6_family = AF_INET6;
	dst.sin6_len = sizeof(struct sockaddr_in6);
	dst.sin6_addr = addr;

	ret = send_packet(iface, buf->buf, buf->wpos, &dst);
@

