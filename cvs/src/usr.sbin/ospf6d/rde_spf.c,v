head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.10
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.14
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.6
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.10
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.25
date	2015.12.05.06.45.19;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	kaPHlG1ByVeKfK88;

1.24
date	2012.09.18.18.58.57;	author bluhm;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.01.19.47.04;	author bluhm;	state Exp;
branches;
next	1.22;

1.22
date	2010.03.01.08.51.40;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2010.02.22.08.03.06;	author stsp;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.22.19.47.05;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.22.19.44.52;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.22.17.54.04;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.22.17.42.46;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.22.16.29.55;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.28.19.20.40;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.09.19.06.52;	author stsp;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.29.21.48.35;	author stsp;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.29.21.46.10;	author stsp;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.29.21.42.30;	author stsp;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.29.19.34.23;	author stsp;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.29.19.28.10;	author stsp;	state Exp;
branches;
next	1.8;

1.8
date	2009.03.29.19.25.49;	author stsp;	state Exp;
branches;
next	1.7;

1.7
date	2009.03.10.17.37.45;	author stsp;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.11.13.48.39;	author norby;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.27.12.23.06;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.16.21.36.19;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.16.13.01.07;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.16.08.41.56;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.51;	author norby;	state Exp;
branches;
next	;


desc
@@


1.25
log
@strings.h -> string.h to prevent an implicit declaration warning.
@
text
@/*	$OpenBSD: rde_spf.c,v 1.24 2012/09/18 18:58:57 bluhm Exp $ */

/*
 * Copyright (c) 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <err.h>
#include <stdlib.h>
#include <string.h>

#include "ospf6d.h"
#include "ospf6.h"
#include "log.h"
#include "rde.h"

extern struct ospfd_conf	*rdeconf;
TAILQ_HEAD(, vertex)		 cand_list;
RB_HEAD(rt_tree, rt_node)	 rt;
RB_PROTOTYPE(rt_tree, rt_node, entry, rt_compare)
RB_GENERATE(rt_tree, rt_node, entry, rt_compare)
struct vertex			*spf_root = NULL;

void		 calc_nexthop_clear(struct vertex *);
void		 calc_nexthop_add(struct vertex *, struct vertex *,
		     const struct in6_addr *, u_int32_t);
struct in6_addr	*calc_nexthop_lladdr(struct vertex *, struct lsa_rtr_link *,
		     unsigned int);
void		 calc_nexthop_transit_nbr(struct vertex *, struct vertex *,
		     unsigned int);
void		 calc_nexthop(struct vertex *, struct vertex *,
		     struct area *, struct lsa_rtr_link *);
void		 rt_nexthop_clear(struct rt_node *);
void		 rt_nexthop_add(struct rt_node *, struct v_nexthead *,
		     struct in_addr);
void		 rt_update(struct in6_addr *, u_int8_t, struct v_nexthead *,
		     u_int32_t, u_int32_t, struct in_addr, struct in_addr,
		     enum path_type, enum dst_type, u_int8_t, u_int32_t);
struct rt_node	*rt_lookup(enum dst_type, struct in6_addr *);
void		 rt_invalidate(struct area *);
int		 linked(struct vertex *, struct vertex *);

void
spf_calc(struct area *area)
{
	struct vertex		*v, *w;
	struct lsa_rtr_link	*rtr_link = NULL;
	struct lsa_net_link	*net_link;
	u_int32_t		 d;
	unsigned int		 i;

	/* clear SPF tree */
	spf_tree_clr(area);
	cand_list_clr();

	/* initialize SPF tree */
	if ((v = spf_root = lsa_find_rtr(area, rde_router_id())) == NULL)
		/* empty area because no interface is active */
		return;

	area->transit = 0;
	spf_root->cost = 0;
	w = NULL;

	/* calculate SPF tree */
	do {
		/* loop links */
		for (i = 0; i < lsa_num_links(v); i++) {
			switch (v->type) {
			case LSA_TYPE_ROUTER:
				rtr_link = get_rtr_link(v, i);
				switch (rtr_link->type) {
				case LINK_TYPE_POINTTOPOINT:
				case LINK_TYPE_VIRTUAL:
					/* find router LSA */
					w = lsa_find_rtr(area,
					    rtr_link->nbr_rtr_id);
					break;
				case LINK_TYPE_TRANSIT_NET:
					/* find network LSA */
					w = lsa_find_tree(&area->lsa_tree,
					    htons(LSA_TYPE_NETWORK),
					    rtr_link->nbr_iface_id,
					    rtr_link->nbr_rtr_id);
					break;
				default:
					fatalx("spf_calc: invalid link type");
				}
				break;
			case LSA_TYPE_NETWORK:
				net_link = get_net_link(v, i);
				/* find router LSA */
				w = lsa_find_rtr(area, net_link->att_rtr);
				break;
			default:
				fatalx("spf_calc: invalid LSA type");
			}

			if (w == NULL)
				continue;

			if (ntohs(w->lsa->hdr.age) == MAX_AGE)
				continue;

			if (lsa_num_links(w) == 0)
				continue;

			if (!linked(w, v)) {
				log_debug("spf_calc: w adv_rtr %s ls_id %s "
				    "type 0x%x numlinks %hu has no link to "
				    "v adv_rtr %s ls_id %s type 0x%x",
				    log_rtr_id(htonl(w->adv_rtr)),
				    log_rtr_id(htonl(w->ls_id)), w->type,
				    lsa_num_links(w),
				    log_rtr_id(htonl(v->adv_rtr)),
				    log_rtr_id(htonl(v->ls_id)), v->type);
				continue;
			}

			if (v->type == LSA_TYPE_ROUTER)
				d = v->cost + ntohs(rtr_link->metric);
			else
				d = v->cost;

			if (cand_list_present(w)) {
				if (d > w->cost)
					continue;
				if (d < w->cost) {
					w->cost = d;
					calc_nexthop_clear(w);
					calc_nexthop(w, v, area, rtr_link);
					/*
					 * need to readd to candidate list
					 * because the list is sorted
					 */
					TAILQ_REMOVE(&cand_list, w, cand);
					cand_list_add(w);
				} else
					/* equal cost path */
					calc_nexthop(w, v, area, rtr_link);
			} else if (w->cost == LS_INFINITY && d < LS_INFINITY) {
				w->cost = d;

				calc_nexthop_clear(w);
				calc_nexthop(w, v, area, rtr_link);
				cand_list_add(w);
			}
		}

		/* get next vertex */
		v = cand_list_pop();
		w = NULL;
	} while (v != NULL);

	/* spf_dump(area); */
	log_debug("spf_calc: area %s calculated", inet_ntoa(area->id));

	/* Dump SPF tree to log */
	RB_FOREACH(v, lsa_tree, &area->lsa_tree) {
		struct v_nexthop *vn;
		char hops[4096];
		struct iface *iface;

		bzero(hops, sizeof(hops));

		if (v->type != LSA_TYPE_ROUTER && v->type != LSA_TYPE_NETWORK)
			continue;

		TAILQ_FOREACH(vn, &v->nexthop, entry) {
			strlcat(hops, log_in6addr(&vn->nexthop), sizeof(hops));
			strlcat(hops, "%", sizeof(hops));
			if ((iface = if_find(vn->ifindex)) == NULL)
				fatalx("spf_calc: lost iface");
			strlcat(hops, iface->name, sizeof(hops));
			if (vn != TAILQ_LAST(&v->nexthop, v_nexthead))
				strlcat(hops, ", ", sizeof(hops));
		}
		log_debug("%s(%s, 0x%x, %s) cost %u has nexthops [%s]",
		    v == spf_root ? "*" : " ", log_rtr_id(htonl(v->adv_rtr)),
		    v->type, log_rtr_id(htonl(v->ls_id)), v->cost, hops);
	}

	area->num_spf_calc++;
	start_spf_timer();
}

void
rt_calc(struct vertex *v, struct area *area, struct ospfd_conf *conf)
{
	struct vertex		*w;
	struct lsa_intra_prefix	*iap;
	struct lsa_prefix	*prefix;
	struct in_addr		 adv_rtr;
	struct in6_addr		 ia6;
	u_int16_t		 i, off;
	u_int8_t		 flags;

	lsa_age(v);
	if (ntohs(v->lsa->hdr.age) == MAX_AGE)
		return;

	switch (v->type) {
	case LSA_TYPE_ROUTER:
		if (v->cost >= LS_INFINITY || TAILQ_EMPTY(&v->nexthop))
			return;

		/* router, only add border and as-external routers */
		flags = LSA_24_GETHI(ntohl(v->lsa->data.rtr.opts));
		if ((flags & (OSPF_RTR_B | OSPF_RTR_E)) == 0)
			return;

		bzero(&ia6, sizeof(ia6));
		adv_rtr.s_addr = htonl(v->adv_rtr);
		bcopy(&adv_rtr, &ia6.s6_addr[12], sizeof(adv_rtr));

		rt_update(&ia6, 128, &v->nexthop, v->cost, 0, area->id,
		    adv_rtr, PT_INTER_AREA, DT_RTR, flags, 0);
		break;
	case LSA_TYPE_INTRA_A_PREFIX:
		/* Find referenced LSA */
		iap = &v->lsa->data.pref_intra;
		switch (ntohs(iap->ref_type)) {
		case LSA_TYPE_ROUTER:
			w = lsa_find_rtr(area, iap->ref_adv_rtr);
			if (w == NULL) {
				warnx("rt_calc: Intra-Area-Prefix LSA (%s, %u) "
				    "references non-existent router %s",
				    log_rtr_id(htonl(v->adv_rtr)),
				    v->ls_id, log_rtr_id(iap->ref_adv_rtr));
				return;
			}
			flags = LSA_24_GETHI(ntohl(w->lsa->data.rtr.opts));
			break;
		case LSA_TYPE_NETWORK:
			w = lsa_find_tree(&area->lsa_tree, iap->ref_type,
			    iap->ref_ls_id, iap->ref_adv_rtr);
			if (w == NULL) {
				warnx("rt_calc: Intra-Area-Prefix LSA (%s, %u) "
				    "references non-existent Network LSA (%s, "
				    "%u)", log_rtr_id(htonl(v->adv_rtr)),
				    v->ls_id, log_rtr_id(iap->ref_adv_rtr),
				    ntohl(iap->ref_ls_id));
				return;
			}
			flags = 0;
			break;
		default:
			warnx("rt_calc: Intra-Area-Prefix LSA (%s, %u) has "
			    "invalid ref_type 0x%hx", log_rtr_id(v->adv_rtr),
			    v->ls_id, ntohs(iap->ref_type));
			return;
		}

		if (w->cost >= LS_INFINITY || TAILQ_EMPTY(&w->nexthop))
			return;

		/* Add prefixes listed in Intra-Area-Prefix LSA to routing
		 * table, using w as destination. */
		off = sizeof(v->lsa->hdr) + sizeof(struct lsa_intra_prefix);
		for (i = 0; i < ntohs(v->lsa->data.pref_intra.numprefix); i++) {
			prefix = (struct lsa_prefix *)((char *)(v->lsa) + off);
			if (!(prefix->options & OSPF_PREFIX_NU)) {
				bzero(&ia6, sizeof(ia6));
				bcopy(prefix + 1, &ia6,
				    LSA_PREFIXSIZE(prefix->prefixlen));

				adv_rtr.s_addr = htonl(w->adv_rtr);

				rt_update(&ia6, prefix->prefixlen, &w->nexthop,
				    w->cost + ntohs(prefix->metric), 0,
				    area->id, adv_rtr, PT_INTRA_AREA, DT_NET,
				    flags, 0);
			}
			off += sizeof(struct lsa_prefix)
			    + LSA_PREFIXSIZE(prefix->prefixlen);
		}
		break;
	case LSA_TYPE_INTER_A_PREFIX:
		/* XXX if ABR only look at area 0.0.0.0 LSA */
		/* ignore self-originated stuff */
		if (v->self)
			return;

		adv_rtr.s_addr = htonl(v->adv_rtr);
		w = lsa_find_rtr(area, adv_rtr.s_addr);
		if (w == NULL) {
			warnx("rt_calc: Inter-Area-Router LSA (%s, %u) "
			    "originated from non-existent router",
			    log_rtr_id(htonl(v->adv_rtr)),
			    v->ls_id);
			return;
		}
		if (w->cost >= LS_INFINITY || TAILQ_EMPTY(&w->nexthop))
			return;

		/* Add prefix listed in Inter-Area-Prefix LSA to routing
		 * table, using w as destination. */
		off = sizeof(v->lsa->hdr) + sizeof(struct lsa_prefix_sum);
		prefix = (struct lsa_prefix *)((char *)(v->lsa) + off);
		if (prefix->options & OSPF_PREFIX_NU)
			return;

		bzero(&ia6, sizeof(ia6));
		bcopy(prefix + 1, &ia6, LSA_PREFIXSIZE(prefix->prefixlen));

		rt_update(&ia6, prefix->prefixlen, &w->nexthop, w->cost +
		    (ntohs(v->lsa->data.rtr_sum.metric) & LSA_METRIC_MASK), 0,
		    area->id, adv_rtr, PT_INTER_AREA, DT_NET, 0, 0);
		break;
	case LSA_TYPE_INTER_A_ROUTER:
		/* XXX if ABR only look at area 0.0.0.0 LSA */
		/* ignore self-originated stuff */
		if (v->self)
			return;

		adv_rtr.s_addr = htonl(v->adv_rtr);
		w = lsa_find_rtr(area, adv_rtr.s_addr);
		if (w == NULL) {
			warnx("rt_calc: Inter-Area-Router LSA (%s, %u) "
			    "originated from non-existent router",
			    log_rtr_id(htonl(v->adv_rtr)),
			    v->ls_id);
			return;
		}
		if (w->cost >= LS_INFINITY || TAILQ_EMPTY(&w->nexthop))
			return;

		/* Add router listed in Inter-Area-Router LSA to routing
		 * table, using w as destination. */
		bzero(&ia6, sizeof(ia6));
		bcopy(&v->lsa->data.rtr_sum.dest_rtr_id, &ia6.s6_addr[12],
		    4);

		rt_update(&ia6, 128, &w->nexthop, w->cost +
		    (ntohs(v->lsa->data.rtr_sum.metric) & LSA_METRIC_MASK), 0,
		    area->id, adv_rtr, PT_INTER_AREA, DT_RTR, 0, 0);
		break;
	default:
		break;
	}
}

void
asext_calc(struct vertex *v)
{
	struct in6_addr		 addr, fw_addr;
	struct rt_node		*r;
	struct rt_nexthop	*rn;
	struct lsa_prefix	*prefix;
	struct in_addr		 adv_rtr, area;
	char			*p;
	u_int32_t		 metric, cost2, ext_tag = 0;
	enum path_type		 type;

	lsa_age(v);
	if (ntohs(v->lsa->hdr.age) == MAX_AGE ||
	    (ntohl(v->lsa->data.asext.metric) & LSA_METRIC_MASK) >=
	    LS_INFINITY)
		return;

	switch (v->type) {
	case LSA_TYPE_EXTERNAL:
		/* ignore self-originated stuff */
		if (v->self)
			return;

		adv_rtr.s_addr = htonl(v->adv_rtr);
		bzero(&addr, sizeof(addr));
		bcopy(&adv_rtr, &addr.s6_addr[12], sizeof(adv_rtr));
		if ((r = rt_lookup(DT_RTR, &addr)) == NULL)
			return;

		prefix = &v->lsa->data.asext.prefix;
		if (prefix->options & OSPF_PREFIX_NU)
			break;
		bzero(&addr, sizeof(addr));
		bcopy(prefix + 1, &addr,
		    LSA_PREFIXSIZE(prefix->prefixlen));

		p = (char *)(prefix + 1) + LSA_PREFIXSIZE(prefix->prefixlen);
		metric = ntohl(v->lsa->data.asext.metric);

		if (metric & LSA_ASEXT_F_FLAG) {
			bcopy(p, &fw_addr, sizeof(fw_addr));
			p += sizeof(fw_addr);

			/* lookup forwarding address */
			if ((r = rt_lookup(DT_NET, &fw_addr)) == NULL ||
			    (r->p_type != PT_INTRA_AREA &&
			    r->p_type != PT_INTER_AREA))
				return;
		}
		if (metric & LSA_ASEXT_T_FLAG) {
			bcopy(p, &ext_tag, sizeof(ext_tag));
			p += sizeof(ext_tag);
		}
		if (metric & LSA_ASEXT_E_FLAG) {
			v->cost = r->cost;
			cost2 = metric & LSA_METRIC_MASK;
			type = PT_TYPE2_EXT;
		} else {
			v->cost = r->cost + (metric & LSA_METRIC_MASK);
			cost2 = 0;
			type = PT_TYPE1_EXT;
		}

		area.s_addr = 0;
		calc_nexthop_clear(v);
		TAILQ_FOREACH(rn, &r->nexthop, entry) {
			if (rn->invalid)
				continue;

			if (rn->connected && r->d_type == DT_NET) {
				if (metric & LSA_ASEXT_F_FLAG)
					calc_nexthop_add(v, NULL, &fw_addr,
					    rn->ifindex);
				else
					fatalx("asext_calc: I'm sorry Dave, "
					    "I'm afraid I can't do that.");
			} else
				calc_nexthop_add(v, NULL, &rn->nexthop,
				    rn->ifindex);
		}

		rt_update(&addr, prefix->prefixlen,
		    &v->nexthop, v->cost, cost2, area, adv_rtr, type,
		    DT_NET, 0, ext_tag);
		break;
	default:
		fatalx("asext_calc: invalid LSA type");
	}
}

void
spf_tree_clr(struct area *area)
{
	struct lsa_tree	*tree = &area->lsa_tree;
	struct vertex	*v;

	RB_FOREACH(v, lsa_tree, tree) {
		v->cost = LS_INFINITY;
		calc_nexthop_clear(v);
	}
}

void
calc_nexthop_clear(struct vertex *v)
{
	struct v_nexthop	*vn;

	while ((vn = TAILQ_FIRST(&v->nexthop))) {
		TAILQ_REMOVE(&v->nexthop, vn, entry);
		free(vn);
	}
}

void
calc_nexthop_add(struct vertex *dst, struct vertex *parent,
	const struct in6_addr *nexthop, u_int32_t ifindex)
{
	struct v_nexthop	*vn;

	if ((vn = calloc(1, sizeof(*vn))) == NULL)
		fatal("calc_nexthop_add");

	vn->prev = parent;
	if (nexthop)
		vn->nexthop = *nexthop;
	vn->ifindex = ifindex;

	TAILQ_INSERT_TAIL(&dst->nexthop, vn, entry);
}

struct in6_addr *
calc_nexthop_lladdr(struct vertex *dst, struct lsa_rtr_link *rtr_link,
    unsigned int ifindex)
{
	struct iface		*iface;
	struct vertex		*link;
	struct rde_nbr		*nbr;

	/* Find outgoing interface, we need its LSA tree */
	LIST_FOREACH(iface, &dst->area->iface_list, entry) {
		if (ifindex == iface->ifindex)
			break;
	}
	if (!iface) {
		log_warnx("calc_nexthop_lladdr: no interface found for "
		    "ifindex %d", ntohl(rtr_link->iface_id));
		return (NULL);
	}

	/* Determine neighbor's link-local address.
	 * Try to get it from link LSA first. */
	link = lsa_find_tree(&iface->lsa_tree,
		htons(LSA_TYPE_LINK), rtr_link->iface_id,
		htonl(dst->adv_rtr));
	if (link)
		return &link->lsa->data.link.lladdr;

	/* Not found, so fall back to source address
	 * advertised in hello packet. */
	if ((nbr = rde_nbr_find(dst->peerid)) == NULL)
		fatalx("next hop is not a neighbor");
	return &nbr->addr;
}

void
calc_nexthop_transit_nbr(struct vertex *dst, struct vertex *parent,
    unsigned int ifindex)
{
	struct lsa_rtr_link	*rtr_link;
	unsigned int		 i;
	struct in6_addr		*lladdr;

	if (dst->type != LSA_TYPE_ROUTER)
		fatalx("calc_nexthop_transit_nbr: dst is not a router");
	if (parent->type != LSA_TYPE_NETWORK)
		fatalx("calc_nexthop_transit_nbr: parent is not a network");

	/* dst is a neighbor on a directly attached transit network.
	 * Figure out dst's link local address and add it as nexthop. */
	for (i = 0; i < lsa_num_links(dst); i++) {
		rtr_link = get_rtr_link(dst, i);
		if (rtr_link->type == LINK_TYPE_TRANSIT_NET &&
		    rtr_link->nbr_rtr_id == parent->lsa->hdr.adv_rtr &&
		    rtr_link->nbr_iface_id == parent->lsa->hdr.ls_id) {
			lladdr = calc_nexthop_lladdr(dst, rtr_link, ifindex);
			calc_nexthop_add(dst, parent, lladdr, ifindex);
		}
	}
}

void
calc_nexthop(struct vertex *dst, struct vertex *parent,
    struct area *area, struct lsa_rtr_link *rtr_link)
{
	struct v_nexthop	*vn;
	struct in6_addr		*nexthop;

	/* case 1 */
	if (parent == spf_root) {
		switch (dst->type) {
		case LSA_TYPE_ROUTER:
			if (rtr_link->type != LINK_TYPE_POINTTOPOINT)
				fatalx("inconsistent SPF tree");
			nexthop = calc_nexthop_lladdr(dst, rtr_link,
			    ntohl(rtr_link->iface_id));
			break;
		case LSA_TYPE_NETWORK:
			if (rtr_link->type != LINK_TYPE_TRANSIT_NET)
				fatalx("inconsistent SPF tree");

			/* Next hop address cannot be determined yet,
			 * we only know the outgoing interface. */
			nexthop = NULL;
			break;
		default:
			fatalx("calc_nexthop: invalid dst type");
		}

		calc_nexthop_add(dst, spf_root, nexthop,
		    ntohl(rtr_link->iface_id));
		return;
	}

	/* case 2 */
	if (parent->type == LSA_TYPE_NETWORK && dst->type == LSA_TYPE_ROUTER) {
		TAILQ_FOREACH(vn, &parent->nexthop, entry) {
			if (vn->prev == spf_root)
				calc_nexthop_transit_nbr(dst, parent,
				    vn->ifindex);
			else
				/* dst is more than one transit net away */
				calc_nexthop_add(dst, parent, &vn->nexthop,
				    vn->ifindex);
		}
		return;
	}

	/* case 3 */
	TAILQ_FOREACH(vn, &parent->nexthop, entry)
	    calc_nexthop_add(dst, parent, &vn->nexthop, vn->ifindex);
}

/* candidate list */
void
cand_list_init(void)
{
	TAILQ_INIT(&cand_list);
}

void
cand_list_add(struct vertex *v)
{
	struct vertex	*c = NULL;

	TAILQ_FOREACH(c, &cand_list, cand) {
		if (c->cost > v->cost) {
			TAILQ_INSERT_BEFORE(c, v, cand);
			return;
		} else if (c->cost == v->cost && c->type == LSA_TYPE_ROUTER &&
		    v->type == LSA_TYPE_NETWORK) {
			TAILQ_INSERT_BEFORE(c, v, cand);
			return;
		}
	}
	TAILQ_INSERT_TAIL(&cand_list, v, cand);
}

struct vertex *
cand_list_pop(void)
{
	struct vertex	*c;

	if ((c = TAILQ_FIRST(&cand_list)) != NULL) {
		TAILQ_REMOVE(&cand_list, c, cand);
	}

	return (c);
}

int
cand_list_present(struct vertex *v)
{
	struct vertex	*c;

	TAILQ_FOREACH(c, &cand_list, cand) {
		if (c == v)
			return (1);
	}

	return (0);
}

void
cand_list_clr(void)
{
	struct vertex *c;

	while ((c = TAILQ_FIRST(&cand_list)) != NULL) {
		TAILQ_REMOVE(&cand_list, c, cand);
	}
}

/* timers */
/* ARGSUSED */
void
spf_timer(int fd, short event, void *arg)
{
	struct vertex		*v;
	struct ospfd_conf	*conf = arg;
	struct area		*area;
	struct rt_node		*r;

	switch (conf->spf_state) {
	case SPF_IDLE:
		fatalx("spf_timer: invalid state IDLE");
	case SPF_HOLDQUEUE:
		conf->spf_state = SPF_DELAY;
		/* FALLTHROUGH */
	case SPF_DELAY:
		LIST_FOREACH(area, &conf->area_list, entry) {
			if (area->dirty) {
				/* invalidate RIB entries of this area */
				rt_invalidate(area);

				/* calculate SPF tree */
				spf_calc(area);

				/* calculate route table */
				RB_FOREACH(v, lsa_tree, &area->lsa_tree) {
					rt_calc(v, area, conf);
				}

				area->dirty = 0;
			}
		}

		/* calculate as-external routes, first invalidate them */
		rt_invalidate(NULL);
		RB_FOREACH(v, lsa_tree, &asext_tree) {
			asext_calc(v);
		}

		RB_FOREACH(r, rt_tree, &rt) {
			LIST_FOREACH(area, &conf->area_list, entry)
				rde_summary_update(r, area);

			if (r->d_type != DT_NET)
				continue;

			if (r->invalid)
				rde_send_delete_kroute(r);
			else
				rde_send_change_kroute(r);
		}

		LIST_FOREACH(area, &conf->area_list, entry)
			lsa_remove_invalid_sums(area);

		start_spf_holdtimer(conf);
		break;
	case SPF_HOLD:
		conf->spf_state = SPF_IDLE;
		break;
	default:
		fatalx("spf_timer: unknown state");
	}
}

void
start_spf_timer(void)
{
	struct timeval	tv;

	switch (rdeconf->spf_state) {
	case SPF_IDLE:
		timerclear(&tv);
		tv.tv_sec = rdeconf->spf_delay;
		rdeconf->spf_state = SPF_DELAY;
		if (evtimer_add(&rdeconf->ev, &tv) == -1)
			fatal("start_spf_timer");
		break;
	case SPF_DELAY:
		/* ignore */
		break;
	case SPF_HOLD:
		rdeconf->spf_state = SPF_HOLDQUEUE;
		break;
	case SPF_HOLDQUEUE:
		/* ignore */
		break;
	default:
		fatalx("start_spf_timer: invalid spf_state");
	}
}

void
stop_spf_timer(struct ospfd_conf *conf)
{
	if (evtimer_del(&conf->ev) == -1)
		fatal("stop_spf_timer");
}

void
start_spf_holdtimer(struct ospfd_conf *conf)
{
	struct timeval	tv;

	switch (conf->spf_state) {
	case SPF_DELAY:
		timerclear(&tv);
		tv.tv_sec = conf->spf_hold_time;
		conf->spf_state = SPF_HOLD;
		if (evtimer_add(&conf->ev, &tv) == -1)
			fatal("start_spf_holdtimer");
		break;
	case SPF_IDLE:
	case SPF_HOLD:
	case SPF_HOLDQUEUE:
		fatalx("start_spf_holdtimer: invalid state");
	default:
		fatalx("start_spf_holdtimer: unknown state");
	}
}

/* route table */
void
rt_init(void)
{
	RB_INIT(&rt);
}

int
rt_compare(struct rt_node *a, struct rt_node *b)
{
	int	i;

	/* XXX maybe a & b need to be switched */
	i = memcmp(&a->prefix, &b->prefix, sizeof(a->prefix));
	if (i)
		return (i);
	if (a->prefixlen < b->prefixlen)
		return (-1);
	if (a->prefixlen > b->prefixlen)
		return (1);
	if (a->d_type > b->d_type)
		return (-1);
	if (a->d_type < b->d_type)
		return (1);
	return (0);
}

struct rt_node *
rt_find(struct in6_addr *prefix, u_int8_t prefixlen, enum dst_type d_type)
{
	struct rt_node	s;

	s.prefix = *prefix;
	s.prefixlen = prefixlen;
	s.d_type = d_type;

	return (RB_FIND(rt_tree, &rt, &s));
}

int
rt_insert(struct rt_node *r)
{
	if (RB_INSERT(rt_tree, &rt, r) != NULL) {
		log_warnx("rt_insert failed for %s/%u",
		    log_in6addr(&r->prefix), r->prefixlen);
		free(r);
		return (-1);
	}

	return (0);
}

int
rt_remove(struct rt_node *r)
{
	if (RB_REMOVE(rt_tree, &rt, r) == NULL) {
		log_warnx("rt_remove failed for %s/%u",
		    log_in6addr(&r->prefix), r->prefixlen);
		return (-1);
	}

	rt_nexthop_clear(r);
	free(r);
	return (0);
}

void
rt_invalidate(struct area *area)
{
	struct rt_node		*r, *nr;
	struct rt_nexthop	*rn, *nrn;

	for (r = RB_MIN(rt_tree, &rt); r != NULL; r = nr) {
		nr = RB_NEXT(rt_tree, &rt, r);
		if (area == NULL) {
			/* look only at as_ext routes */
			if (r->p_type != PT_TYPE1_EXT &&
			    r->p_type != PT_TYPE2_EXT)
				continue;
		} else {
			/* ignore all as_ext routes */
			if (r->p_type == PT_TYPE1_EXT ||
			    r->p_type == PT_TYPE2_EXT)
				continue;

			/* look only at routes matching the area */
			if (r->area.s_addr != area->id.s_addr)
				continue;
		}
		r->invalid = 1;
		for (rn = TAILQ_FIRST(&r->nexthop); rn != NULL; rn = nrn) {
			nrn = TAILQ_NEXT(rn, entry);
			if (rn->invalid) {
				TAILQ_REMOVE(&r->nexthop, rn, entry);
				free(rn);
			} else
				rn->invalid = 1;
		}
		if (TAILQ_EMPTY(&r->nexthop))
			rt_remove(r);
	}
}

void
rt_nexthop_clear(struct rt_node *r)
{
	struct rt_nexthop	*rn;

	while ((rn = TAILQ_FIRST(&r->nexthop)) != NULL) {
		TAILQ_REMOVE(&r->nexthop, rn, entry);
		free(rn);
	}
}

void
rt_nexthop_add(struct rt_node *r, struct v_nexthead *vnh,
    struct in_addr adv_rtr)
{
	struct v_nexthop	*vn;
	struct rt_nexthop	*rn;
	struct timespec		 now;

	TAILQ_FOREACH(vn, vnh, entry) {
		TAILQ_FOREACH(rn, &r->nexthop, entry) {
			if (!IN6_ARE_ADDR_EQUAL(&rn->nexthop, &vn->nexthop))
				continue;

			rn->adv_rtr.s_addr = adv_rtr.s_addr;
			rn->connected = vn->prev == spf_root;
			rn->invalid = 0;

			r->invalid = 0;
			break;
		}
		if (rn)
			continue;

		if ((rn = calloc(1, sizeof(struct rt_nexthop))) == NULL)
			fatal("rt_nexthop_add");

		clock_gettime(CLOCK_MONOTONIC, &now);
		rn->nexthop = vn->nexthop;
		rn->ifindex = vn->ifindex;
		rn->adv_rtr.s_addr = adv_rtr.s_addr;
		rn->uptime = now.tv_sec;
		rn->connected = vn->prev == spf_root;
		rn->invalid = 0;

		r->invalid = 0;
		TAILQ_INSERT_TAIL(&r->nexthop, rn, entry);
	}
}

void
rt_clear(void)
{
	struct rt_node	*r;

	while ((r = RB_MIN(rt_tree, &rt)) != NULL)
		rt_remove(r);
}

void
rt_dump(struct in_addr area, pid_t pid, u_int8_t r_type)
{
	static struct ctl_rt	 rtctl;
	struct timespec		 now;
	struct rt_node		*r;
	struct rt_nexthop	*rn;

	clock_gettime(CLOCK_MONOTONIC, &now);

	RB_FOREACH(r, rt_tree, &rt) {
		if (r->invalid)
			continue;

		if (r->area.s_addr != area.s_addr)
			continue;

		switch (r_type) {
		case RIB_RTR:
			if (r->d_type != DT_RTR)
				continue;
			break;
		case RIB_NET:
			if (r->d_type != DT_NET)
				continue;
			if (r->p_type == PT_TYPE1_EXT ||
			    r->p_type == PT_TYPE2_EXT)
				continue;
			break;
		case RIB_EXT:
			if (r->p_type != PT_TYPE1_EXT &&
			    r->p_type != PT_TYPE2_EXT)
				continue;
			break;
		default:
			fatalx("rt_dump: invalid RIB type");
		}

		TAILQ_FOREACH(rn, &r->nexthop, entry) {
			if (rn->invalid)
				continue;

			rtctl.prefix = r->prefix;
			rtctl.nexthop = rn->nexthop;
			rtctl.ifindex = rn->ifindex;
			rtctl.area.s_addr = r->area.s_addr;
			rtctl.adv_rtr.s_addr = rn->adv_rtr.s_addr;
			rtctl.cost = r->cost;
			rtctl.cost2 = r->cost2;
			rtctl.p_type = r->p_type;
			rtctl.d_type = r->d_type;
			rtctl.flags = r->flags;
			rtctl.prefixlen = r->prefixlen;
			rtctl.uptime = now.tv_sec - rn->uptime;

			rde_imsg_compose_ospfe(IMSG_CTL_SHOW_RIB, 0, pid,
			    &rtctl, sizeof(rtctl));
		}
	}
}

void
rt_update(struct in6_addr *prefix, u_int8_t prefixlen, struct v_nexthead *vnh,
     u_int32_t cost, u_int32_t cost2, struct in_addr area,
     struct in_addr adv_rtr, enum path_type p_type, enum dst_type d_type,
     u_int8_t flags, u_int32_t tag)
{
	struct rt_node		*rte;
	struct rt_nexthop	*rn;
	int			 better = 0, equal = 0;

	if (vnh == NULL || TAILQ_EMPTY(vnh))	/* XXX remove */
		fatalx("rt_update: invalid nexthop");

	if ((rte = rt_find(prefix, prefixlen, d_type)) == NULL) {
		if ((rte = calloc(1, sizeof(struct rt_node))) == NULL)
			fatal("rt_update");

		TAILQ_INIT(&rte->nexthop);
		rte->prefix = *prefix;
		rte->prefixlen = prefixlen;
		rte->cost = cost;
		rte->cost2 = cost2;
		rte->area = area;
		rte->p_type = p_type;
		rte->d_type = d_type;
		rte->flags = flags;
		rte->ext_tag = tag;

		rt_nexthop_add(rte, vnh, adv_rtr);

		rt_insert(rte);
	} else {
		/* order:
		 * 1. intra-area
		 * 2. inter-area
		 * 3. type 1 as ext
		 * 4. type 2 as ext
		 */
		if (rte->invalid)	/* everything is better than invalid */
			better = 1;
		else if (p_type < rte->p_type)
			better = 1;
		else if (p_type == rte->p_type)
			switch (p_type) {
			case PT_INTRA_AREA:
			case PT_INTER_AREA:
				if (cost < rte->cost)
					better = 1;
				else if (cost == rte->cost &&
				    rte->area.s_addr == area.s_addr)
					equal = 1;
				break;
			case PT_TYPE1_EXT:
				if (cost < rte->cost)
					better = 1;
				else if (cost == rte->cost)
					equal = 1;
				break;
			case PT_TYPE2_EXT:
				if (cost2 < rte->cost2)
					better = 1;
				else if (cost2 == rte->cost2 &&
				    cost < rte->cost)
					better = 1;
				else if (cost2 == rte->cost2 &&
				    cost == rte->cost)
					equal = 1;
				break;
			}

		if (better) {
			TAILQ_FOREACH(rn, &rte->nexthop, entry)
				rn->invalid = 1;

			rte->area = area;
			rte->cost = cost;
			rte->cost2 = cost2;
			rte->p_type = p_type;
			rte->flags = flags;
			rte->ext_tag = tag;
		}

		if (equal || better)
			rt_nexthop_add(rte, vnh, adv_rtr);
	}
}

struct rt_node *
rt_lookup(enum dst_type type, struct in6_addr *addr)
{
	struct rt_node	*rn;
	struct in6_addr	 ina;
	u_int8_t	 i = 128;

	if (type == DT_RTR) {
		rn = rt_find(addr, 128, type);
		if (rn && rn->invalid == 0)
			return (rn);
		return (NULL);
	}

	/* type == DT_NET */
	do {
		inet6applymask(&ina, addr, i);
		if ((rn = rt_find(&ina, i, type)) && rn->invalid == 0)
			return (rn);
	} while (i-- != 0);

	return (NULL);
}

/* router LSA links */
struct lsa_rtr_link *
get_rtr_link(struct vertex *v, unsigned int idx)
{
	struct lsa_rtr_link	*rtr_link = NULL;
	unsigned int		 frag = 1;
	unsigned int		 frag_nlinks;
	unsigned int		 nlinks = 0;
	unsigned int		 i;

	if (v->type != LSA_TYPE_ROUTER)
		fatalx("get_rtr_link: invalid LSA type");

	/* Treat multiple Router-LSAs originated by the same router
	 * as an aggregate. */
	do {
		/* number of links validated earlier by lsa_check() */
		rtr_link = (struct lsa_rtr_link *)((char *)v->lsa +
		    sizeof(v->lsa->hdr) + sizeof(struct lsa_rtr));
		frag_nlinks = ((ntohs(v->lsa->hdr.len) -
		    sizeof(struct lsa_hdr) - sizeof(struct lsa_rtr)) /
		    sizeof(struct lsa_rtr_link));
		if (nlinks + frag_nlinks > idx) {
			for (i = 0; i < frag_nlinks; i++) {
				if (i + nlinks == idx)
					return (rtr_link);
				rtr_link++;
			}
		}
		nlinks += frag_nlinks;
		v = lsa_find_rtr_frag(v->area, htonl(v->adv_rtr), frag++);
	} while (v);

	return (NULL);
}

/* network LSA links */
struct lsa_net_link *
get_net_link(struct vertex *v, unsigned int idx)
{
	struct lsa_net_link	*net_link = NULL;
	char			*buf = (char *)v->lsa;
	unsigned int		 i;

	if (v->type != LSA_TYPE_NETWORK)
		fatalx("get_net_link: invalid LSA type");

	/* number of links validated earlier by lsa_check() */
	net_link = (struct lsa_net_link *)(buf + sizeof(v->lsa->hdr) +
	    sizeof(struct lsa_net));
	for (i = 0; i < lsa_num_links(v); i++) {
		if (i == idx)
			return (net_link);
		net_link++;
	}

	return (NULL);
}

/* misc */
int
linked(struct vertex *w, struct vertex *v)
{
	struct lsa_rtr_link	*rtr_link = NULL;
	struct lsa_net_link	*net_link = NULL;
	unsigned int		 i;

	switch (w->type) {
	case LSA_TYPE_ROUTER:
		for (i = 0; i < lsa_num_links(w); i++) {
			rtr_link = get_rtr_link(w, i);
			switch (v->type) {
			case LSA_TYPE_ROUTER:
				if (rtr_link->type == LINK_TYPE_POINTTOPOINT &&
				    rtr_link->nbr_rtr_id == htonl(v->adv_rtr))
					return (1);
				break;
			case LSA_TYPE_NETWORK:
				if (rtr_link->type == LINK_TYPE_TRANSIT_NET &&
				    rtr_link->nbr_rtr_id == htonl(v->adv_rtr) &&
				    rtr_link->nbr_iface_id == htonl(v->ls_id))
					return (1);
				break;
			default:
				fatalx("linked: invalid type");
			}
		}
		return (0);
	case LSA_TYPE_NETWORK:
		for (i = 0; i < lsa_num_links(w); i++) {
			net_link = get_net_link(w, i);
			switch (v->type) {
			case LSA_TYPE_ROUTER:
				if (net_link->att_rtr == htonl(v->adv_rtr))
					return (1);
				break;
			default:
				fatalx("linked: invalid type");
			}
		}
		return (0);
	default:
		fatalx("linked: invalid LSA type");
	}

	return (0);
}
@


1.24
log
@The if (!better && !equal) check is redundant as the same condition
is checked a few lines below again.  Fewer checks make the code
more readable.
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.23 2010/07/01 19:47:04 bluhm Exp $ */
d25 1
a25 1
#include <strings.h>
@


1.23
log
@Fix all white space bugs in ospf6d at once.  No binary change.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.22 2010/03/01 08:51:40 claudio Exp $ */
a1074 3

		if (!better && !equal)
			return;
@


1.22
log
@Add routing calculation code for AS-ext LSA and Inter-Area LSA but the
latter are not realy tested. AS-ext LSA are now correctly added to the
RIB.  "looks like you know what you're doing" stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.21 2010/02/22 08:03:06 stsp Exp $ */
d259 1
a259 1
			}	
d404 1
a404 1
		    	    (r->p_type != PT_INTRA_AREA &&
d562 1
a562 1
			nexthop = calc_nexthop_lladdr(dst, rtr_link, 
@


1.21
log
@Treat multiple Router-LSAs originated by the same router as an
aggregate, as mandated by RFC5340.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.20 2009/12/22 19:47:05 claudio Exp $ */
d218 16
d247 1
a247 1
			flags = LSA_24_GETHI(w->lsa->data.rtr.opts);
d292 61
a352 1
	/* TODO: inter-area routes, as-external routes */
d361 1
a361 1
#if 0
d364 4
a367 2
	u_int32_t		 cost2;
	struct in_addr		 addr, adv_rtr, a;
a368 1
#endif
d382 4
a385 2
#if 0 /* XXX this will be different for sure */
		if ((r = rt_lookup(DT_RTR, htonl(v->adv_rtr))) == NULL)
d388 25
a412 11
		/* XXX RFC1583Compatibility */
		if (v->lsa->data.asext.fw_addr != 0 &&
		    (r = rt_lookup(DT_NET, v->lsa->data.asext.fw_addr)) == NULL)
			return;

		if (v->lsa->data.asext.fw_addr != 0 &&
		    r->p_type != PT_INTRA_AREA &&
		    r->p_type != PT_INTER_AREA)
			return;

		if (ntohl(v->lsa->data.asext.metric) & LSA_ASEXT_E_FLAG) {
d414 1
a414 2
			cost2 = ntohl(v->lsa->data.asext.metric) &
			    LSA_METRIC_MASK;
d417 1
a417 2
			v->cost = r->cost + (ntohl(v->lsa->data.asext.metric) &
			     LSA_METRIC_MASK);
d422 1
a422 4
		a.s_addr = 0;
		adv_rtr.s_addr = htonl(v->adv_rtr);
		addr.s_addr = htonl(v->ls_id) & v->lsa->data.asext.mask;

d429 3
a431 3
				if (v->lsa->data.asext.fw_addr != 0)
					calc_nexthop_add(v, NULL,
					    v->lsa->data.asext.fw_addr);
d433 2
a434 2
					calc_nexthop_add(v, NULL,
					    htonl(v->adv_rtr));
d436 2
a437 2
				calc_nexthop_add(v, NULL, 0
				    /* XXX rn->nexthop.s_addri */);
d440 3
a442 4
		rt_update(addr, mask2prefixlen(v->lsa->data.asext.mask),
		    &v->nexthop, v->cost, cost2, a, adv_rtr, type,
		    DT_NET, 0, ntohl(v->lsa->data.asext.ext_tag));
#endif
d1104 1
a1104 1
		rn = rt_find(addr, 32, type);
@


1.20
log
@Crap. Remove debug code that I did not plan to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.18 2009/12/22 17:54:04 claudio Exp $ */
a81 4
		/* TODO: Treat multiple router LSAs originated by a single
		 * router as one aggregate. We don't do this [yet],
		 * but RFC5340 says we MUST do it. */

d1038 3
a1040 1
	char			*buf = (char *)v->lsa;
d1046 19
a1064 8
	/* number of links validated earlier by lsa_check() */
	rtr_link = (struct lsa_rtr_link *)(buf + sizeof(v->lsa->hdr) +
	    sizeof(struct lsa_rtr));
	for (i = 0; i < lsa_num_links(v); i++) {
		if (i == idx)
			return (rtr_link);
		rtr_link++;
	}
@


1.19
log
@Holy inconsitancy Batman! While it is impossible to use embeded scope ids
in almost all sockaddr_in6 addresses it is required for the nexthop and
sin6_scope_id is actually ignored there.
This needs to be fixed but my quota of IPv6 insanity is already used for today.
Workaround for now. My simple testsetup is now actually able to install
the first ospf6d learned routes in the kernel. Weeee!
@
text
@a621 3
log_debug("rt_calced: %s/%u  type %d inval %d",
    log_in6addr(&r->prefix), r->prefixlen, r->d_type, r->invalid);

@


1.18
log
@Link local addressing strikes again. Include ifindex in all nexthop
definitions so that we have a chance to build a correct nexthop.
Insane that a struct in6_addr is unable to fully specify an IPv6 address.
kroute.c still needs fixing but now the rib is starting to make sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.17 2009/12/22 17:42:46 claudio Exp $ */
d621 3
@


1.17
log
@Use correct interface id. iface_id is our ifindex, nbr_iface_id is the
interface id of the remote side. Found the hard way.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.16 2009/12/22 16:29:55 claudio Exp $ */
d43 1
a43 1
		     u_int32_t);
d45 1
a45 1
		     u_int32_t);
a215 1
	enum path_type		 type;
a271 6
				if (prefix->prefixlen == 128 ||
				    prefix->options & OSPF_PREFIX_LA)
					type = DT_RTR;
				else
					type = DT_NET;

d274 1
a274 1
				    area->id, adv_rtr, PT_INTRA_AREA, type,
d408 1
a408 1
    u_int32_t ifindex)
d442 1
a442 1
    u_int32_t ifindex)
d842 1
d906 1
@


1.16
log
@Give calc_nexthop_lladdr() a chance to find the correct link local address.
We need to pass our ifindex so that we can find the Link-LSA that has the
link local address stored for that router.  Don't we all like IPv6 link local
addresses and their insanity.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.15 2009/07/28 19:20:40 claudio Exp $ */
d487 1
a487 1
			    ntohl(rtr_link->nbr_iface_id));
@


1.15
log
@Install interface addresses of other routers (LA bit set or 128 prefixlen)
as router type and not as a network.
From stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.14 2009/04/09 19:06:52 stsp Exp $ */
d42 2
a43 1
struct in6_addr	*calc_nexthop_lladdr(struct vertex *, struct lsa_rtr_link *);
d45 1
a45 1
		     u_int32_t ifindex);
d414 2
a415 1
calc_nexthop_lladdr(struct vertex *dst, struct lsa_rtr_link *rtr_link)
d417 3
a419 3
	struct iface	*iface;
	struct vertex	*link;
	struct rde_nbr	*nbr;
d423 1
a423 1
		if (ntohl(rtr_link->iface_id) == iface->ifindex)
d427 2
a428 1
		warnx("calc_nexthop_lladdr: no interface found for ifindex");
d435 1
a435 1
		htons(LSA_TYPE_LINK), rtr_link->nbr_iface_id,
d467 1
a467 1
			lladdr = calc_nexthop_lladdr(dst, rtr_link);
d486 2
a487 1
			nexthop = calc_nexthop_lladdr(dst, rtr_link);
@


1.14
log
@Update rt_calc() for OSPFv3. The Routing Information Base is being
populated. Intra-area routes only for now.

"I see no obvious issues. Should go in so you can move forward" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.13 2009/03/29 21:48:35 stsp Exp $ */
d215 1
d272 6
d280 1
a280 1
				    area->id, adv_rtr, PT_INTRA_AREA, DT_NET,
@


1.13
log
@Update spf_calc() for OSPFv3.

This implements the first stage of the shortest path tree calculation
(Dijkstra calculation) as outlined in rfc5340, with the exception that
we do not yet treat multiple router LSAs originated by a single router
as an agregate. For now, we only use the Router LSA with the lowest link
state ID.

For each destination, show the calculated set of nexthops in the debug log.
We can stop doing this once spf tree calculation has been shown to be stable.

"A lot of debug code but yes why not. commit it." claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.12 2009/03/29 21:46:10 stsp Exp $ */
a207 1
#if 0 /* XXX needs a lot of work */
d209 6
a214 4
	struct v_nexthop	*vn;
	struct lsa_rtr_link	*rtr_link = NULL;
	int			 i;
	struct in_addr		 addr, adv_rtr;
d221 32
a252 3
	case LSA_TYPE_ROUTER:
		/* stub networks */
		if (v->cost >= LS_INFINITY || TAILQ_EMPTY(&v->nexthop))
a253 10

		for (i = 0; i < lsa_num_links(v); i++) {
			rtr_link = get_rtr_link(v, i);
			addr.s_addr = rtr_link->id;
			adv_rtr.s_addr = htonl(v->adv_rtr);

			rt_update(addr, mask2prefixlen(rtr_link->data),
			    &v->nexthop, v->cost + ntohs(rtr_link->metric), 0,
			    area->id, adv_rtr, PT_INTRA_AREA, DT_NET,
			    v->lsa->data.rtr.flags, 0);
d256 1
a256 2
		/* router, only add border and as-external routers */
		if ((v->lsa->data.rtr.flags & (OSPF_RTR_B | OSPF_RTR_E)) == 0)
d259 19
a277 55
		addr.s_addr = htonl(v->ls_id);
		adv_rtr.s_addr = htonl(v->adv_rtr);

		rt_update(addr, 32, &v->nexthop, v->cost, 0, area->id,
		    adv_rtr, PT_INTRA_AREA, DT_RTR, v->lsa->data.rtr.flags, 0);
		break;
	case LSA_TYPE_NETWORK:
		if (v->cost >= LS_INFINITY || TAILQ_EMPTY(&v->nexthop))
			return;

		addr.s_addr = htonl(v->ls_id) & v->lsa->data.net.mask;
		adv_rtr.s_addr = htonl(v->adv_rtr);
		rt_update(addr, mask2prefixlen(v->lsa->data.net.mask),
		    &v->nexthop, v->cost, 0, area->id, adv_rtr, PT_INTRA_AREA,
		    DT_NET, 0, 0);
		break;
	case LSA_TYPE_SUM_NETWORK:
	case LSA_TYPE_SUM_ROUTER:
		/* if ABR only look at area 0.0.0.0 LSA */
		if (area_border_router(conf) && area->id.s_addr != INADDR_ANY)
			return;

		/* ignore self-originated stuff */
		if (v->self)
			return;

		/* TODO type 3 area address range check */

		if ((w = lsa_find(area, LSA_TYPE_ROUTER,
		    htonl(v->adv_rtr),
		    htonl(v->adv_rtr))) == NULL)
			return;

		/* copy nexthops */
		calc_nexthop_clear(v);	/* XXX needed ??? */
		TAILQ_FOREACH(vn, &w->nexthop, entry)
			calc_nexthop_add(v, w, vn->nexthop.s_addr);

		v->cost = w->cost +
		    (ntohl(v->lsa->data.sum.metric) & LSA_METRIC_MASK);

		if (v->cost >= LS_INFINITY || TAILQ_EMPTY(&v->nexthop))
			return;

		adv_rtr.s_addr = htonl(v->adv_rtr);
		if (v->type == LSA_TYPE_SUM_NETWORK) {
			addr.s_addr = htonl(v->ls_id) & v->lsa->data.sum.mask;
			rt_update(addr, mask2prefixlen(v->lsa->data.sum.mask),
			    &v->nexthop, v->cost, 0, area->id, adv_rtr,
			    PT_INTER_AREA, DT_NET, 0, 0);
		} else {
			addr.s_addr = htonl(v->ls_id);
			rt_update(addr, 32, &v->nexthop, v->cost, 0, area->id,
			    adv_rtr, PT_INTER_AREA, DT_RTR,
			    v->lsa->data.rtr.flags, 0);
d279 2
a280 1

a281 3
	default:
		/* as-external LSA are stored in a different tree */
		fatalx("rt_calc: invalid LSA type");
a282 1
#endif
@


1.12
log
@Update calc_nexthop() for OSPFv3, using helper functions added in
last commit. Next hop IP addresses and outgoing interfaces can now
be correctly determined, paving the way for SPF tree calculation.
Arguments have changed, so update callers, too.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.11 2009/03/29 21:42:30 stsp Exp $ */
a64 1
	struct in_addr		 addr;
d71 1
a71 3
	if ((v = spf_root = lsa_find(LIST_FIRST(&area->iface_list), /* XXX */
	    LSA_TYPE_ROUTER, rde_router_id(),
	    rde_router_id())) == NULL)
d81 4
d94 2
a95 3
#if 0
					w = lsa_find(area, LSA_TYPE_ROUTER,
					    rtr_link->id, rtr_link->id);
a96 1
#endif
d99 4
a102 2
#if 0
					w = lsa_find_net(area, rtr_link->id);
a103 1
#endif
d111 1
a111 3
				w = lsa_find(LIST_FIRST(&area->iface_list), /* XXX */
				    LSA_TYPE_ROUTER,
				    net_link->att_rtr, net_link->att_rtr);
d120 4
a123 1
			if (w->lsa->hdr.age == MAX_AGE)
d127 8
a134 6
				addr.s_addr = htonl(w->ls_id);
				log_debug("spf_calc: w id %s type %d has ",
				    inet_ntoa(addr), w->type);
				addr.s_addr = htonl(v->ls_id);
				log_debug("    no link to v id %s type %d",
				    inet_ntoa(addr), v->type);
d174 26
a199 2
	log_debug("spf_calc: area %s calculated",
	    inet_ntoa(area->id));
@


1.11
log
@As a first step towards SPF tree calculation, prepare for proper
next-hop calculation.

In OSPFv3, next-hop IP addresses are always link-local.
The kernel will want to know which interface the link-local
address belongs to, so we need an ifindex in struct v_nexthop
in addition to the IP address.

Because we cannot determine a link-local next hop IP address
for transit networks, only the outgoing interface will be recorded.

Update calc_nexthop_add() according to the above.

Also add new helpers calc_nexthop_lladdr() and calc_nexthop_transit_nbr(),
to figure out link-local addresses of nexthop neighbours.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.10 2009/03/29 19:34:23 stsp Exp $ */
d45 2
a46 1
void		 calc_nexthop(struct vertex *, struct vertex *);
d146 1
a146 1
					calc_nexthop(w, v);
d155 1
a155 1
					calc_nexthop(w, v);
d160 1
a160 1
				calc_nexthop(w, v);
d457 2
a458 1
calc_nexthop(struct vertex *dst, struct vertex *parent)
a459 2
#if 0
	struct lsa_rtr_link	*rtr_link = NULL;
d461 1
a461 1
	int			 i;
d467 4
a470 10
			for (i = 0; i < lsa_num_links(dst); i++) {
				rtr_link = get_rtr_link(dst, i);
				if (rtr_link->type == LINK_TYPE_POINTTOPOINT &&
				    ntohl(rtr_link->id) == parent->ls_id) {
					calc_nexthop_add(dst, parent,
					    rtr_link->data);
					break;
				}
			}
			return;
d472 7
a478 21
			for (i = 0; i < lsa_num_links(parent); i++) {
				rtr_link = get_rtr_link(parent, i);
				switch (rtr_link->type) {
				case LINK_TYPE_POINTTOPOINT:
					/* ignore */
					break;
				case LINK_TYPE_TRANSIT_NET:
					if ((htonl(dst->ls_id) &
					    dst->lsa->data.net.mask) ==
					    (rtr_link->data &
					     dst->lsa->data.net.mask)) {
						calc_nexthop_add(dst, parent,
						    rtr_link->data);
					}
					break;
				default:
					fatalx("calc_nexthop: invalid link "
					    "type");
				}
			}
			return;
d482 4
d491 7
a497 16
			if (vn->prev == spf_root) {
				for (i = 0; i < lsa_num_links(dst); i++) {
					rtr_link = get_rtr_link(dst, i);
					if ((rtr_link->type ==
					    LINK_TYPE_TRANSIT_NET) &&
					    (rtr_link->data &
					    parent->lsa->data.net.mask) ==
					    (htonl(parent->ls_id) &
					    parent->lsa->data.net.mask))
						calc_nexthop_add(dst, parent,
						    rtr_link->data);
				}
			} else {
				calc_nexthop_add(dst, parent, 0
				    /* XXX vn->nexthop.s_addr */);
			}
d504 1
a504 2
	    calc_nexthop_add(dst, parent, 0 /* XXX vn->nexthop.s_addr */);
#endif
@


1.10
log
@Update linked() for OSPFv3.

A router vertex w has a point-to-point link back to a router
vertex v if v's router ID occurs as neighbour ID in one of the
point-to-point links described in w's router LSA.

A router vertex w has a link back to a network vertex v if the router
ID of v's advertising router (i.e. DR) occurs as neighbour ID in one
of the transit links described in w's router LSA, and v's interface
ID to the network matches the neighbour interface ID of that transit
link.

A network vertex w has a link back to a router vertex v if v's router
ID occurs in the list of attached routers in w's network LSA.

Also, get_rtr_link() and get_net_link() take an unsigned int now.

"commit it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.9 2009/03/29 19:28:10 stsp Exp $ */
d40 5
a44 1
void		 calc_nexthop_add(struct vertex *, struct vertex *, u_int32_t);
d381 2
a382 1
calc_nexthop_add(struct vertex *dst, struct vertex *parent, u_int32_t nexthop)
a385 4
	if (nexthop == 0)
		/* invalid nexthop, skip it */
		return;

d390 3
a392 1
	/* XXX  vn->nexthop.s_addr = nexthop; */
d395 58
@


1.9
log
@Change get_net_link()'s idx argument to unsigned, and make it
use less local variables. Makes it consistent with get_rtr_link().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.8 2009/03/29 19:25:49 stsp Exp $ */
d1041 1
a1041 1
	int			 i;
a1048 1
#if 0
d1050 1
a1050 1
				    rtr_link->id == htonl(v->ls_id))
a1052 1
#endif
d1054 3
a1056 2
#if 0
				if (rtr_link->id == htonl(v->ls_id))
a1058 1
#endif
d1069 1
a1069 1
				if (net_link->att_rtr == htonl(v->ls_id))
@


1.8
log
@Because get_rtr_link() forgot to increment the buffer offset
it was always returning the first link in the LSA, no matter
which link was requested. Fix this bug. Also, decrease the
number of local variables while here, and convert the idx argument
to unsigned int. Adjust one caller to pass an unsigned int,
other callers will be handled in follow-up commits.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.7 2009/03/10 17:37:45 stsp Exp $ */
d1014 1
a1014 1
get_net_link(struct vertex *v, int idx)
d1018 1
a1018 1
	u_int16_t		 i, off, nlinks;
d1023 4
a1026 6
	off = sizeof(v->lsa->hdr) + sizeof(u_int32_t);

	/* nlinks validated earlier by lsa_check() */
	nlinks = lsa_num_links(v);
	for (i = 0; i < nlinks; i++) {
		net_link = (struct lsa_net_link *)(buf + off);
d1029 1
a1029 2

		off += sizeof(struct lsa_net_link);
@


1.7
log
@The linked() function had an identity crisis and referred to itself
as "spf_calc" in fatal error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.6 2008/02/11 13:48:39 norby Exp $ */
d59 1
a59 1
	int			 i;
d991 1
a991 1
get_rtr_link(struct vertex *v, int idx)
d995 1
a995 1
	u_int16_t		 i, off, nlinks;
d1000 4
a1003 6
	off = sizeof(v->lsa->hdr) + sizeof(struct lsa_rtr);

	/* nlinks validated earlier by lsa_check() */
	nlinks = lsa_num_links(v);
	for (i = 0; i < nlinks; i++) {
		rtr_link = (struct lsa_rtr_link *)(buf + off);
d1006 1
@


1.6
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.5 2007/11/27 12:23:06 claudio Exp $ */
d1066 1
a1066 1
				fatalx("spf_calc: invalid type");
d1079 1
a1079 1
				fatalx("spf_calc: invalid type");
d1084 1
a1084 1
		fatalx("spf_calc: invalid LSA type");
@


1.5
log
@Make lsa_find() find link local LSA by passing the interface instead of the
area as lookup point. Additionally make lsa_dump or actually the code around
it pass all LSA to ospf6ctl. The rde_spf.c are not final.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.4 2007/10/16 21:36:19 claudio Exp $ */
d650 1
a650 1
		fatalx("spf_start_holdtimer: unknown state");
@


1.4
log
@Oups, unbreak there were some LINK_TYPE_STUB_NET left in the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.3 2007/10/16 13:01:07 norby Exp $ */
d67 2
a68 1
	if ((v = spf_root = lsa_find(area, LSA_TYPE_ROUTER, rde_router_id(),
d106 2
a107 1
				w = lsa_find(area, LSA_TYPE_ROUTER,
@


1.3
log
@Make ospf6d(8) not throw up on Router LSAs.

Initial step towards actually storing real LSAs.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.2 2007/10/16 08:41:56 claudio Exp $ */
a83 3
				case LINK_TYPE_STUB_NET:
					/* skip */
					continue;
a192 3
			if (rtr_link->type != LINK_TYPE_STUB_NET)
				continue;

a429 3
				case LINK_TYPE_STUB_NET:
					break;

@


1.2
log
@First step at making kroute IPv6 aware. This resulted in many additional
changes -- some are so hairy that I left them out for later by commenting out
larger blocks of code (just grep for XXX if you like to help).
Get it in early so that we can work on.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.1 2007/10/08 10:44:51 norby Exp $ */
d90 1
d94 1
d97 1
d100 1
d401 1
d476 1
a1014 3

		off += sizeof(struct lsa_rtr_link) +
		    rtr_link->num_tos * sizeof(u_int32_t);
d1060 1
d1065 1
d1067 1
d1071 1
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde_spf.c,v 1.63 2007/08/06 11:32:34 claudio Exp $ */
d25 1
d45 1
a45 1
void		 rt_update(struct in_addr, u_int8_t, struct v_nexthead *,
d48 1
a48 1
struct rt_node	*rt_lookup(enum dst_type, in_addr_t);
d173 1
d270 1
d276 1
d282 1
d296 1
d339 2
a340 1
				calc_nexthop_add(v, NULL, rn->nexthop.s_addr);
d346 1
d389 1
a389 1
	vn->nexthop.s_addr = nexthop;
d461 2
a462 2
				calc_nexthop_add(dst, parent,
				    vn->nexthop.s_addr);
d470 1
a470 1
	    calc_nexthop_add(dst, parent, vn->nexthop.s_addr);
d665 6
a670 4
	if (ntohl(a->prefix.s_addr) < ntohl(b->prefix.s_addr))
		return (-1);
	if (ntohl(a->prefix.s_addr) > ntohl(b->prefix.s_addr))
		return (1);
d683 1
a683 1
rt_find(in_addr_t prefix, u_int8_t prefixlen, enum dst_type d_type)
d687 1
a687 1
	s.prefix.s_addr = prefix;
d699 1
a699 1
		    inet_ntoa(r->prefix), r->prefixlen);
d712 1
a712 1
		    inet_ntoa(r->prefix), r->prefixlen);
d779 1
a779 1
			if (rn->nexthop.s_addr != vn->nexthop.s_addr)
d796 1
a796 1
		rn->nexthop.s_addr = vn->nexthop.s_addr;
d858 2
a859 2
			rtctl.prefix.s_addr = r->prefix.s_addr;
			rtctl.nexthop.s_addr = rn->nexthop.s_addr;
d877 1
a877 1
rt_update(struct in_addr prefix, u_int8_t prefixlen, struct v_nexthead *vnh,
d889 1
a889 1
	if ((rte = rt_find(prefix.s_addr, prefixlen, d_type)) == NULL) {
d894 1
a894 1
		rte->prefix.s_addr = prefix.s_addr;
d967 1
a967 1
rt_lookup(enum dst_type type, in_addr_t addr)
d970 2
a971 1
	u_int8_t	 i = 32;
d982 2
a983 2
		if ((rn = rt_find(addr & prefixlen2mask(i), i, type)) &&
		    rn->invalid == 0)
@

