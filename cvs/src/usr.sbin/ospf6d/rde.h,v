head	1.22;
access;
symbols
	OPENBSD_6_0:1.22.0.26
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.22
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.24
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.16
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.20
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.18
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.14
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.12
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.10
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.8
	OPENBSD_5_0:1.22.0.6
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5;
locks; strict;
comment	@ * @;


1.22
date	2010.07.01.19.47.04;	author bluhm;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.01.18.57.21;	author bluhm;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.01.08.55.45;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.02.22.08.03.06;	author stsp;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.22.17.54.04;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.29.21.42.30;	author stsp;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.29.19.28.10;	author stsp;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.29.19.25.49;	author stsp;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.29.19.18.20;	author stsp;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.29.19.14.23;	author stsp;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.29.16.24.38;	author stsp;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.12.01.21.49;	author stsp;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.07.00.33.13;	author stsp;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.12.16.54.30;	author stsp;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.27.21.58.28;	author stsp;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.03.00.23.50;	author stsp;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.30.22.24.34;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.27.12.23.06;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.27.11.29.34;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.16.12.05.52;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.16.08.41.56;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.51;	author norby;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Fix all white space bugs in ospf6d at once.  No binary change.
ok claudio@@
@
text
@/*	$OpenBSD: rde.h,v 1.21 2010/07/01 18:57:21 bluhm Exp $ */

/*
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _RDE_H_
#define _RDE_H_

#include <sys/types.h>
#include <sys/time.h>
#include <sys/tree.h>
#include <sys/queue.h>
#include <event.h>
#include <limits.h>

struct v_nexthop {
	TAILQ_ENTRY(v_nexthop)	 entry;
	struct vertex		*prev;
	struct in6_addr		 nexthop;
	unsigned int		 ifindex;
};

TAILQ_HEAD(v_nexthead, v_nexthop);

struct vertex {
	RB_ENTRY(vertex)	 entry;
	TAILQ_ENTRY(vertex)	 cand;
	struct v_nexthead	 nexthop;
	struct event		 ev;
	struct area		*area;
	struct lsa		*lsa;
	struct lsa_tree		*lsa_tree;
	time_t			 changed;
	time_t			 stamp;
	u_int32_t		 cost;
	u_int32_t		 peerid;	/* neighbor unique imsg ID */
	u_int32_t		 ls_id;
	u_int32_t		 adv_rtr;
	u_int16_t		 type;
	u_int8_t		 flooded;
	u_int8_t		 deleted;
	u_int8_t		 self;
};

struct rde_req_entry {
	TAILQ_ENTRY(rde_req_entry)	entry;
	u_int32_t			ls_id;
	u_int32_t			adv_rtr;
	u_int8_t			type;
};

/* just the info RDE needs */
struct rde_nbr {
	LIST_ENTRY(rde_nbr)		 entry, hash;
	struct in6_addr			 addr;
	struct in_addr			 id;
	struct in_addr			 area_id;
	TAILQ_HEAD(, rde_req_entry)	 req_list;
	struct area			*area;
	struct iface			*iface;
	u_int32_t			 peerid;	/* unique ID in DB */
	unsigned int			 ifindex;
	u_int32_t			 iface_id;	/* id of neighbor's
							   iface */
	int				 state;
	int				 self;
};

/* expanded and host-byte-order version of a lsa_prefix */
struct rt_prefix {
	struct in6_addr	prefix;
	u_int16_t	metric;
	u_int8_t	prefixlen;
	u_int8_t	options;
};

struct rt_nexthop {
	TAILQ_ENTRY(rt_nexthop)	entry;
	struct in6_addr		nexthop;
	struct in_addr		adv_rtr;
	unsigned int		ifindex;
	time_t			uptime;
	u_int8_t		connected;
	u_int8_t		invalid;
};

struct rt_node {
	RB_ENTRY(rt_node)	entry;
	TAILQ_HEAD(,rt_nexthop)	nexthop;
	struct in6_addr		prefix;
	struct in_addr		area;
	u_int32_t		cost;
	u_int32_t		cost2;
	u_int32_t		ext_tag;
	enum path_type		p_type;
	enum dst_type		d_type;
	u_int8_t		flags;
	u_int8_t		prefixlen;
	u_int8_t		invalid;
};

struct abr_rtr {
	struct in6_addr		 addr;
	struct in_addr		 abr_id;
	struct in6_addr		 dst_ip;
	struct in_addr		 area;
	u_int16_t		 metric;
};

extern struct lsa_tree	asext_tree;

/* rde.c */
pid_t		 rde(struct ospfd_conf *, int [2], int [2], int [2]);
int		 rde_imsg_compose_ospfe(int, u_int32_t, pid_t, void *,
		     u_int16_t);
u_int32_t	 rde_router_id(void);
void		 rde_send_change_kroute(struct rt_node *);
void		 rde_send_delete_kroute(struct rt_node *);
void		 rde_nbr_del(struct rde_nbr *);
int		 rde_nbr_loading(struct area *);
struct rde_nbr	*rde_nbr_self(struct area *);
struct rde_nbr	*rde_nbr_find(u_int32_t);
void		 rde_summary_update(struct rt_node *, struct area *);
void		 orig_intra_area_prefix_lsas(struct area *);

/* rde_lsdb.c */
void		 lsa_init(struct lsa_tree *);
int		 lsa_compare(struct vertex *, struct vertex *);
void		 vertex_free(struct vertex *);
int		 lsa_newer(struct lsa_hdr *, struct lsa_hdr *);
int		 lsa_check(struct rde_nbr *, struct lsa *, u_int16_t);
int		 lsa_self(struct lsa *);
void		 lsa_flush(struct rde_nbr *, struct lsa *);
void		 lsa_reflood(struct vertex *, struct lsa*);
int		 lsa_add(struct rde_nbr *, struct lsa *);
void		 lsa_del(struct rde_nbr *, struct lsa_hdr *);
void		 lsa_age(struct vertex *);
struct vertex	*lsa_find(struct iface *, u_int16_t, u_int32_t, u_int32_t);
struct vertex	*lsa_find_rtr(struct area *, u_int32_t);
struct vertex	*lsa_find_rtr_frag(struct area *, u_int32_t, unsigned int);
struct vertex	*lsa_find_tree(struct lsa_tree *, u_int16_t, u_int32_t,
		    u_int32_t);
u_int32_t	 lsa_find_lsid(struct lsa_tree *, u_int16_t, u_int32_t,
		    int (*)(struct lsa *, struct lsa *), struct lsa *);
u_int16_t	 lsa_num_links(struct vertex *);
void		 lsa_snap(struct rde_nbr *, u_int32_t);
void		 lsa_dump(struct lsa_tree *, int, pid_t);
void		 lsa_merge(struct rde_nbr *, struct lsa *, struct vertex *);
void		 lsa_remove_invalid_sums(struct area *);

/* rde_spf.c */
void		 spf_calc(struct area *);
void		 rt_calc(struct vertex *, struct area *, struct ospfd_conf *);
void		 asext_calc(struct vertex *);
void		 spf_tree_clr(struct area *);

void		 cand_list_init(void);
void		 cand_list_add(struct vertex *);
struct vertex	*cand_list_pop(void);
int		 cand_list_present(struct vertex *);
void		 cand_list_clr(void);

void		 spf_timer(int, short, void *);
void		 start_spf_timer(void);
void		 stop_spf_timer(struct ospfd_conf *);
void		 start_spf_holdtimer(struct ospfd_conf *);

void		 rt_init(void);
int		 rt_compare(struct rt_node *, struct rt_node *);
struct rt_node	*rt_find(struct in6_addr *, u_int8_t, enum dst_type);
int		 rt_insert(struct rt_node *);
int		 rt_remove(struct rt_node *);
void		 rt_clear(void);
void		 rt_dump(struct in_addr, pid_t, u_int8_t);

struct lsa_rtr_link	*get_rtr_link(struct vertex *, unsigned int);
struct lsa_net_link	*get_net_link(struct vertex *, unsigned int);

RB_PROTOTYPE(lsa_tree, vertex, entry, lsa_compare)

#endif	/* _RDE_H_ */
@


1.21
log
@The prefixes of interface addresses of an ospf link have to be
advertised as link-lsa and intra-area-prefix-lsa when they change
dynamically.  Handle RTM_NEWADDR and RTM_DELADDR in kroute by sending
an imsg to ospfe.  Upon this event, originate a new link-lsa in
ospfe.  In rde a new intra-area-prefix-lsa is generated when a
link-lsa appears or goes away.
ok claudio@@; ok and test stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.20 2010/03/01 08:55:45 claudio Exp $ */
d76 1
a76 1
	u_int32_t		 	 iface_id;	/* id of neighbor's
@


1.20
log
@Implement lsa_find_lsid(), a function that searches the LSDB for a LSA
specified by type, adv_rtr and an LSA to compare against. This is needed
to find either a free LS ID or the previously assigned LS ID of an AS-ext
LSA.  "looks like you know what you're doing" stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.19 2010/02/22 08:03:06 stsp Exp $ */
d137 1
@


1.19
log
@Treat multiple Router-LSAs originated by the same router as an
aggregate, as mandated by RFC5340.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.18 2009/12/22 17:54:04 claudio Exp $ */
d153 4
a156 1
struct vertex	*lsa_find_tree(struct lsa_tree *, u_int16_t, u_int32_t, u_int32_t);
@


1.18
log
@Link local addressing strikes again. Include ifindex in all nexthop
definitions so that we have a chance to build a correct nexthop.
Insane that a struct in6_addr is unable to fully specify an IPv6 address.
kroute.c still needs fixing but now the rib is starting to make sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.17 2009/03/29 21:42:30 stsp Exp $ */
d152 1
@


1.17
log
@As a first step towards SPF tree calculation, prepare for proper
next-hop calculation.

In OSPFv3, next-hop IP addresses are always link-local.
The kernel will want to know which interface the link-local
address belongs to, so we need an ifindex in struct v_nexthop
in addition to the IP address.

Because we cannot determine a link-local next hop IP address
for transit networks, only the outgoing interface will be recorded.

Update calc_nexthop_add() according to the above.

Also add new helpers calc_nexthop_lladdr() and calc_nexthop_transit_nbr(),
to figure out link-local addresses of nexthop neighbours.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.16 2009/03/29 19:28:10 stsp Exp $ */
d33 1
a33 1
	u_int32_t		 ifindex;
d94 1
@


1.16
log
@Change get_net_link()'s idx argument to unsigned, and make it
use less local variables. Makes it consistent with get_rtr_link().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.15 2009/03/29 19:25:49 stsp Exp $ */
d33 1
d134 1
@


1.15
log
@Because get_rtr_link() forgot to increment the buffer offset
it was always returning the first link in the LSA, no matter
which link was requested. Fix this bug. Also, decrease the
number of local variables while here, and convert the idx argument
to unsigned int. Adjust one caller to pass an unsigned int,
other callers will be handled in follow-up commits.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.14 2009/03/29 19:18:20 stsp Exp $ */
d182 1
a182 1
struct lsa_net_link	*get_net_link(struct vertex *, int);
@


1.14
log
@Remove lsa_find_net(), it isn't needed for OSPFv3.

pointed out by and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.13 2009/03/29 19:14:23 stsp Exp $ */
d181 1
a181 1
struct lsa_rtr_link	*get_rtr_link(struct vertex *, int);
@


1.13
log
@Add lsa_find_rtr() function, which finds among multiple router
LSAs originated by the same router the one with the lowest link
state ID.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.12 2009/03/29 16:24:38 stsp Exp $ */
a148 1
struct vertex	*lsa_find_net(struct area *area, u_int32_t);
@


1.12
log
@For SPF calculation, we will need the source address specified
in hello packets by next-hop neighbours. So when notifying the
RDE of a new neighbour, send the source address, too.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.11 2009/03/12 01:21:49 stsp Exp $ */
d148 1
@


1.11
log
@lsa_self() did too many things at once, and had too much logic
buried inside of it that its caller relied on.

So split it up as follows:
lsa_self()    Check whether an LSA is self-originated.
lsa_flush()   Flush an LSA from the LSDB.
lsa_reflood() Prepare an LSA for reflooding (actual reflooding currently
              requires sending an imsg which must be done by the caller).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.10 2009/03/07 00:33:13 stsp Exp $ */
d67 1
@


1.10
log
@Add lsa_find_tree() to allow searching for LSAs in a specific LSA tree.
We had code marked XXX searching an LSA tree manually using RB_FIND(),
switch it over to lsa_find_tree().
Make lsa_find() use the new function, too, to avoid code duplication.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.9 2009/02/12 16:54:30 stsp Exp $ */
d140 3
a142 1
int		 lsa_self(struct rde_nbr *, struct lsa *, struct vertex *);
@


1.9
log
@Make vertex_free() correctly free LSAs in per-interface LSA trees.

Save a pointer to the right LSA tree in new member v->lsa_tree.
This saves us the hassle of finding the right tree in vertex_free(),
we already know it at creation time so why not tuck it in there?

This might cause problems if the ospfe side ever decides to call
area_del() with a non-empty area->lsa_tree, without correctly
initialising v->lsa_tree. But grep shows that the area's lsa_tree
is currently just initialized on the ospfe side, but never modified.

ospf6d daemons which crashed after about 1 min with malloc options
FGJ are now happy.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.8 2009/01/27 21:58:28 stsp Exp $ */
d146 1
@


1.8
log
@Propagate the neighbour's interface ID, as received in hello packets,
to the RDE.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.7 2009/01/03 00:23:50 stsp Exp $ */
d44 1
@


1.7
log
@Since link LSAs live in iface->lsa_tree and not in area->lsa_tree,
we had better include LSAs from iface->lsa_tree when sending
DB summaries. Fixes initial flood of link LSAs.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.6 2008/12/30 22:24:34 claudio Exp $ */
d73 2
@


1.6
log
@lsa_get_prefix() needs to use something else then struct lsa_prefix to
store the prefix to because the onwire format has the prefix compressed and
so struct lsa_prefix will no longer carry the prefix in it. Use rt_prefix
instead which is the expanded and host-byte-order version of the former.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.5 2007/11/27 12:23:06 claudio Exp $ */
d144 1
a144 1
void		 lsa_snap(struct area *, u_int32_t);
@


1.5
log
@Make lsa_find() find link local LSA by passing the interface instead of the
area as lookup point. Additionally make lsa_dump or actually the code around
it pass all LSA to ospf6ctl. The rde_spf.c are not final.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.4 2007/11/27 11:29:34 claudio Exp $ */
d75 8
@


1.4
log
@Monster diff to bring us a bit on track again.
a) implement all (or at least most) lsa_check() cases.
b) classify the LSA scope correctly and add a per interface lsa_tree for
   the link local stuff.
c) implement a function to parse a prefix.

There is still a lot missing currently link local LSA are added to the
interface tree but nothing can access them (lsa_find() and a few friends
need some changes).
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.3 2007/10/16 12:05:52 norby Exp $ */
d133 1
a133 1
struct vertex	*lsa_find(struct area *, u_int16_t, u_int32_t, u_int32_t);
@


1.3
log
@In OSPFv3 the LSA type is a 16 bit value, furthermore it uses different
values than the v2 counterpart.

Change to u_int16_t and define new LSA types.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.2 2007/10/16 08:41:56 claudio Exp $ */
d70 1
d72 1
@


1.2
log
@First step at making kroute IPv6 aware. This resulted in many additional
changes -- some are so hairy that I left them out for later by commenting out
larger blocks of code (just grep for XXX if you like to help).
Get it in early so that we can work on.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.1 2007/10/08 10:44:51 norby Exp $ */
d50 1
a50 1
	u_int8_t		 type;
d131 1
a131 1
struct vertex	*lsa_find(struct area *, u_int8_t, u_int32_t, u_int32_t);
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.h,v 1.34 2007/06/19 16:45:15 reyk Exp $ */
d32 1
a32 1
	struct in_addr		 nexthop;
d77 1
a77 1
	struct in_addr		nexthop;
d87 1
a87 1
	struct in_addr		prefix;
d158 1
a158 1
struct rt_node	*rt_find(in_addr_t, u_int8_t, enum dst_type);
@

