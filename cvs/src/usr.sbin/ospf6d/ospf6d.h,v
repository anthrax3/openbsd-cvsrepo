head	1.31;
access;
symbols
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.12
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.4
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.8
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12;
locks; strict;
comment	@ * @;


1.31
date	2016.12.27.17.18.56;	author jca;	state Exp;
branches;
next	1.30;
commitid	04ojC2souZ1MiFQA;

1.30
date	2016.09.02.14.06.35;	author benno;	state Exp;
branches;
next	1.29;
commitid	Z2jEGSLNZuIKq53q;

1.29
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.28;
commitid	kLBPo9HaQrkEaNW3;

1.28
date	2013.03.25.14.29.35;	author markus;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.22.14.25.31;	author sthen;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.14.14.39.38;	author florian;	state Exp;
branches;
next	1.25;

1.25
date	2012.10.22.07.28.49;	author bluhm;	state Exp;
branches;
next	1.24;

1.24
date	2012.09.19.19.20.34;	author bluhm;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.07.00.36.13;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.22.21.15.25;	author bluhm;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.01.18.57.21;	author bluhm;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.03.10.00.34;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.22.19.32.36;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.22.17.54.04;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.02.20.24.58;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.06.18.31.42;	author pyr;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.06.09.02.46;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.28.22.47.36;	author stsp;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.30.21.31.54;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2007.12.13.08.54.05;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.27.12.23.06;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.27.11.29.34;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.16.08.41.56;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.11.21.29.53;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.11.21.25.37;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.11.20.20.44;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.11.19.10.55;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.11.19.06.41;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.11.19.02.47;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.09.06.12.04;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.50;	author norby;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Replace struct rroute with struct kroute, as done in ospfd

ok claudio@@
@
text
@/*	$OpenBSD: ospf6d.h,v 1.30 2016/09/02 14:06:35 benno Exp $ */

/*
 * Copyright (c) 2004, 2007 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _OSPF6D_H_
#define _OSPF6D_H_

#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/tree.h>
#include <net/if.h>
#include <netinet/in.h>
#include <event.h>

#include <imsg.h>
#include "ospf6.h"

#define CONF_FILE		"/etc/ospf6d.conf"
#define	OSPF6D_SOCKET		"/var/run/ospf6d.sock"
#define OSPF6D_USER		"_ospf6d"

#define NBR_HASHSIZE		128
#define LSA_HASHSIZE		512

#define NBR_IDSELF		1
#define NBR_CNTSTART		(NBR_IDSELF + 1)

#define	READ_BUF_SIZE		65535
#define	PKG_DEF_SIZE		512	/* compromise */
#define	RT_BUF_SIZE		16384
#define	MAX_RTSOCK_BUF		128 * 1024

#define	OSPFD_FLAG_NO_FIB_UPDATE	0x0001
#define	OSPFD_FLAG_STUB_ROUTER		0x0002

#define	F_OSPFD_INSERTED	0x0001
#define	F_KERNEL		0x0002
#define	F_BGPD_INSERTED		0x0004
#define	F_CONNECTED		0x0008
#define	F_DOWN			0x0010
#define	F_STATIC		0x0020
#define	F_DYNAMIC		0x0040
#define	F_REJECT		0x0080
#define	F_BLACKHOLE		0x0100
#define	F_REDISTRIBUTED		0x0200

static const char * const log_procnames[] = {
	"parent",
	"ospfe",
	"rde"
};

struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	void			*data;
	short			 events;
};

enum imsg_type {
	IMSG_NONE,
	IMSG_CTL_RELOAD,
	IMSG_CTL_SHOW_INTERFACE,
	IMSG_CTL_SHOW_DATABASE,
	IMSG_CTL_SHOW_DB_EXT,
	IMSG_CTL_SHOW_DB_LINK,
	IMSG_CTL_SHOW_DB_NET,
	IMSG_CTL_SHOW_DB_RTR,
	IMSG_CTL_SHOW_DB_INTRA,
	IMSG_CTL_SHOW_DB_SELF,
	IMSG_CTL_SHOW_DB_SUM,
	IMSG_CTL_SHOW_DB_ASBR,
	IMSG_CTL_SHOW_NBR,
	IMSG_CTL_SHOW_RIB,
	IMSG_CTL_SHOW_SUM,
	IMSG_CTL_SHOW_SUM_AREA,
	IMSG_CTL_FIB_COUPLE,
	IMSG_CTL_FIB_DECOUPLE,
	IMSG_CTL_AREA,
	IMSG_CTL_IFACE,
	IMSG_CTL_KROUTE,
	IMSG_CTL_KROUTE_ADDR,
	IMSG_CTL_END,
	IMSG_CTL_LOG_VERBOSE,
	IMSG_KROUTE_CHANGE,
	IMSG_KROUTE_DELETE,
	IMSG_KROUTE_GET,
	IMSG_IFINFO,
	IMSG_IFADD,
	IMSG_IFDELETE,
	IMSG_IFADDRNEW,
	IMSG_IFADDRDEL,
	IMSG_NEIGHBOR_UP,
	IMSG_NEIGHBOR_DOWN,
	IMSG_NEIGHBOR_CHANGE,
	IMSG_NETWORK_ADD,
	IMSG_NETWORK_DEL,
	IMSG_DD,
	IMSG_DD_END,
	IMSG_DB_SNAPSHOT,
	IMSG_DB_END,
	IMSG_LS_REQ,
	IMSG_LS_UPD,
	IMSG_LS_SNAP,
	IMSG_LS_ACK,
	IMSG_LS_FLOOD,
	IMSG_LS_BADREQ,
	IMSG_LS_MAXAGE,
	IMSG_ABR_UP,
	IMSG_ABR_DOWN,
	IMSG_RECONF_CONF,
	IMSG_RECONF_AREA,
	IMSG_RECONF_END,
	IMSG_DEMOTE
};

/* area */
struct vertex;
struct rde_nbr;
RB_HEAD(lsa_tree, vertex);

struct area {
	LIST_ENTRY(area)	 entry;
	struct in_addr		 id;
	struct lsa_tree		 lsa_tree;

	LIST_HEAD(, iface)	 iface_list;
	LIST_HEAD(, rde_nbr)	 nbr_list;
/*	list			 addr_range_list; */
	char			 demote_group[IFNAMSIZ];
	u_int32_t		 stub_default_cost;
	u_int32_t		 num_spf_calc;
	int			 active;
	u_int8_t		 transit;
	u_int8_t		 stub;
	u_int8_t		 dirty;
	u_int8_t		 demote_level;
};

/* interface states */
#define	IF_STA_NEW		0x00	/* dummy state for reload */
#define	IF_STA_DOWN		0x01
#define	IF_STA_LOOPBACK		0x02
#define	IF_STA_WAITING		0x04
#define	IF_STA_POINTTOPOINT	0x08
#define	IF_STA_DROTHER		0x10
#define	IF_STA_BACKUP		0x20
#define	IF_STA_DR		0x40
#define IF_STA_DRORBDR		(IF_STA_DR | IF_STA_BACKUP)
#define	IF_STA_MULTI		(IF_STA_DROTHER | IF_STA_BACKUP | IF_STA_DR)
#define	IF_STA_ANY		0x7f

/* interface events */
enum iface_event {
	IF_EVT_NOTHING,
	IF_EVT_UP,
	IF_EVT_WTIMER,
	IF_EVT_BACKUP_SEEN,
	IF_EVT_NBR_CHNG,
	IF_EVT_LOOP,
	IF_EVT_UNLOOP,
	IF_EVT_DOWN
};

/* interface actions */
enum iface_action {
	IF_ACT_NOTHING,
	IF_ACT_STRT,
	IF_ACT_ELECT,
	IF_ACT_RST
};

/* interface types */
enum iface_type {
	IF_TYPE_POINTOPOINT,
	IF_TYPE_BROADCAST,
	IF_TYPE_NBMA,
	IF_TYPE_POINTOMULTIPOINT,
	IF_TYPE_VIRTUALLINK
};

/* neighbor states */
#define	NBR_STA_DOWN		0x0001
#define	NBR_STA_ATTEMPT		0x0002
#define	NBR_STA_INIT		0x0004
#define	NBR_STA_2_WAY		0x0008
#define	NBR_STA_XSTRT		0x0010
#define NBR_STA_SNAP		0x0020
#define	NBR_STA_XCHNG		0x0040
#define	NBR_STA_LOAD		0x0080
#define	NBR_STA_FULL		0x0100
#define	NBR_STA_ACTIVE		(~NBR_STA_DOWN)
#define	NBR_STA_FLOOD		(NBR_STA_XCHNG | NBR_STA_LOAD | NBR_STA_FULL)
#define	NBR_STA_ADJFORM		(NBR_STA_XSTRT | NBR_STA_SNAP | NBR_STA_FLOOD)
#define	NBR_STA_BIDIR		(NBR_STA_2_WAY | NBR_STA_ADJFORM)
#define	NBR_STA_PRELIM		(NBR_STA_DOWN | NBR_STA_ATTEMPT | NBR_STA_INIT)
#define	NBR_STA_ANY		0xffff

/* neighbor events */
enum nbr_event {
	NBR_EVT_NOTHING,
	NBR_EVT_HELLO_RCVD,
	NBR_EVT_2_WAY_RCVD,
	NBR_EVT_NEG_DONE,
	NBR_EVT_SNAP_DONE,
	NBR_EVT_XCHNG_DONE,
	NBR_EVT_BAD_LS_REQ,
	NBR_EVT_LOAD_DONE,
	NBR_EVT_ADJ_OK,
	NBR_EVT_SEQ_NUM_MIS,
	NBR_EVT_1_WAY_RCVD,
	NBR_EVT_KILL_NBR,
	NBR_EVT_ITIMER,
	NBR_EVT_LL_DOWN,
	NBR_EVT_ADJTMOUT
};

/* neighbor actions */
enum nbr_action {
	NBR_ACT_NOTHING,
	NBR_ACT_RST_ITIMER,
	NBR_ACT_STRT_ITIMER,
	NBR_ACT_EVAL,
	NBR_ACT_SNAP,
	NBR_ACT_SNAP_DONE,
	NBR_ACT_XCHNG_DONE,
	NBR_ACT_ADJ_OK,
	NBR_ACT_RESTRT_DD,
	NBR_ACT_DEL,
	NBR_ACT_CLR_LST,
	NBR_ACT_HELLO_CHK
};

/* spf states */
enum spf_state {
	SPF_IDLE,
	SPF_DELAY,
	SPF_HOLD,
	SPF_HOLDQUEUE
};

enum dst_type {
	DT_NET,
	DT_RTR
};

enum path_type {
	PT_INTRA_AREA,
	PT_INTER_AREA,
	PT_TYPE1_EXT,
	PT_TYPE2_EXT
};

enum rib_type {
	RIB_NET = 1,
	RIB_RTR,
	RIB_EXT
};

struct iface_addr {
	TAILQ_ENTRY(iface_addr)	 entry;
	struct in6_addr		 addr;
	struct in6_addr		 dstbrd;
	u_int8_t		 prefixlen;
	u_int8_t		 redistribute;
};

/* lsa list used in RDE and OE */
TAILQ_HEAD(lsa_head, lsa_entry);

struct iface {
	LIST_ENTRY(iface)	 entry;
	TAILQ_ENTRY(iface)	 list;
	struct event		 hello_timer;
	struct event		 wait_timer;
	struct event		 lsack_tx_timer;

	LIST_HEAD(, nbr)	 nbr_list;
	TAILQ_HEAD(, iface_addr) ifa_list;
	struct lsa_head		 ls_ack_list;

	struct lsa_tree		 lsa_tree;	/* LSA with link local scope */

	char			 name[IF_NAMESIZE];
	char			 demote_group[IFNAMSIZ];
	struct in6_addr		 addr;
	struct in6_addr		 dst;
	struct in_addr		 abr_id;
	struct in_addr		 area_id;
	struct nbr		*dr;	/* designated router */
	struct nbr		*bdr;	/* backup designated router */
	struct nbr		*self;

	u_int64_t		 baudrate;
	u_int32_t		 ls_ack_cnt;
	time_t			 uptime;
	unsigned int		 ifindex;
	int			 fd;
	int			 state;
	int			 mtu;
	u_int16_t		 flags;
	u_int16_t		 transmit_delay;
	u_int16_t		 hello_interval;
	u_int16_t		 rxmt_interval;
	u_int16_t		 dead_interval;
	u_int16_t		 metric;
	enum iface_type		 type;
	u_int8_t		 if_type;
	u_int8_t		 linkstate;
	u_int8_t		 priority;
	u_int8_t		 cflags;
#define F_IFACE_PASSIVE		0x01
#define F_IFACE_CONFIGURED	0x02
#define F_IFACE_AVAIL		0x04
};

struct ifaddrchange {
	struct in6_addr		 addr;
	struct in6_addr		 dstbrd;
	unsigned int		 ifindex;
	u_int8_t		 prefixlen;
};

/* ospf_conf */
enum {
	PROC_MAIN,
	PROC_OSPF_ENGINE,
	PROC_RDE_ENGINE
} ospfd_process;

#define	REDIST_CONNECTED	0x01
#define	REDIST_STATIC		0x02
#define	REDIST_LABEL		0x04
#define	REDIST_ADDR		0x08
#define	REDIST_NO		0x10
#define	REDIST_DEFAULT		0x20

struct redistribute {
	SIMPLEQ_ENTRY(redistribute)	entry;
	struct in6_addr			addr;
	u_int32_t			metric;
	u_int16_t			label;
	u_int16_t			type;
	u_int8_t			prefixlen;
};

struct ospfd_conf {
	struct event		ev;
	struct in_addr		rtr_id;
	LIST_HEAD(, area)	area_list;
	LIST_HEAD(, vertex)	cand_list;
	SIMPLEQ_HEAD(, redistribute) redist_list;

	u_int32_t		opts;
#define OSPFD_OPT_VERBOSE	0x00000001
#define OSPFD_OPT_VERBOSE2	0x00000002
#define OSPFD_OPT_NOACTION	0x00000004
#define OSPFD_OPT_STUB_ROUTER	0x00000008
#define OSPFD_OPT_FORCE_DEMOTE	0x00000010
	u_int32_t		spf_delay;
	u_int32_t		spf_hold_time;
	time_t			uptime;
	int			spf_state;
	int			ospf_socket;
	int			flags;
	u_int8_t		border;
	u_int8_t		redistribute;
	char			*csock;
};

/* kroute */
struct kroute {
	struct in6_addr	prefix;
	struct in6_addr	nexthop;
	u_int32_t	ext_tag;
	u_int32_t	metric;
	unsigned int	scope;		/* scope of nexthop */
	u_int16_t	flags;
	u_int16_t	rtlabel;
	u_short		ifindex;
	u_int8_t	prefixlen;
};

/* name2id */
struct n2id_label {
	TAILQ_ENTRY(n2id_label)	 entry;
	char			*name;
	u_int16_t		 id;
	u_int32_t		 ext_tag;
	int			 ref;
};

TAILQ_HEAD(n2id_labels, n2id_label);
extern struct n2id_labels rt_labels;

/* control data structures */
struct ctl_iface {
	char			 name[IF_NAMESIZE];
	struct in6_addr		 addr;
	struct in6_addr		 mask;
	struct in_addr		 area;
	struct in_addr		 rtr_id;
	struct in_addr		 dr_id;
	struct in6_addr		 dr_addr;
	struct in_addr		 bdr_id;
	struct in6_addr		 bdr_addr;
	time_t			 hello_timer;
	time_t			 uptime;
	u_int64_t		 baudrate;
	u_int32_t		 dead_interval;
	unsigned int		 ifindex;
	int			 state;
	int			 mtu;
	int			 nbr_cnt;
	int			 adj_cnt;
	u_int16_t		 transmit_delay;
	u_int16_t		 hello_interval;
	u_int16_t		 flags;
	u_int16_t		 metric;
	u_int16_t		 rxmt_interval;
	enum iface_type		 type;
	u_int8_t		 linkstate;
	u_int8_t		 if_type;
	u_int8_t		 priority;
	u_int8_t		 passive;
};

struct ctl_nbr {
	char			 name[IF_NAMESIZE];
	struct in_addr		 id;
	struct in6_addr		 addr;
	struct in_addr		 dr;
	struct in_addr		 bdr;
	struct in_addr		 area;
	time_t			 dead_timer;
	time_t			 uptime;
	u_int32_t		 db_sum_lst_cnt;
	u_int32_t		 ls_req_lst_cnt;
	u_int32_t		 ls_retrans_lst_cnt;
	u_int32_t		 state_chng_cnt;
	u_int32_t		 options;
	int			 nbr_state;
	int			 iface_state;
	u_int8_t		 priority;
};

struct ctl_rt {
	struct in6_addr		 prefix;
	struct in6_addr		 nexthop;
	struct in_addr		 area;
	struct in_addr		 adv_rtr;
	time_t			 uptime;
	u_int32_t		 cost;
	u_int32_t		 cost2;
	unsigned int		 ifindex;	/* scope of nexthop */
	enum path_type		 p_type;
	enum dst_type		 d_type;
	u_int8_t		 flags;
	u_int8_t		 prefixlen;
};

struct ctl_sum {
	struct in_addr		 rtr_id;
	u_int32_t		 spf_delay;
	u_int32_t		 spf_hold_time;
	u_int32_t		 num_ext_lsa;
	u_int32_t		 num_area;
	time_t			 uptime;
};

struct ctl_sum_area {
	struct in_addr		 area;
	u_int32_t		 num_iface;
	u_int32_t		 num_adj_nbr;
	u_int32_t		 num_spf_calc;
	u_int32_t		 num_lsa;
};

struct demote_msg {
	char			 demote_group[IF_NAMESIZE];
	int			 level;
};

/* area.c */
struct area	*area_new(void);
int		 area_del(struct area *);
struct area	*area_find(struct ospfd_conf *, struct in_addr);
void		 area_track(struct area *, int);
int		 area_border_router(struct ospfd_conf *);
u_int32_t	 area_ospf_options(struct area *);

/* carp.c */
int		 carp_demote_init(char *, int);
void		 carp_demote_shutdown(void);
int		 carp_demote_get(char *);
int		 carp_demote_set(char *, int);

/* parse.y */
struct ospfd_conf	*parse_config(char *, int);
int			 cmdline_symset(char *);

/* interface.c */
int		 if_init(void);
struct iface	*if_find(unsigned int);
struct iface	*if_findname(char *);
struct iface	*if_new(u_short, char *);
void		 if_update(struct iface *, int, int, u_int8_t, u_int8_t,
		    u_int64_t);

/* in_cksum.c */
u_int16_t	 in_cksum(void *, size_t);

/* iso_cksum.c */
u_int16_t	 iso_cksum(void *, u_int16_t, u_int16_t);

/* kroute.c */
int		 kr_init(int);
int		 kr_change(struct kroute *);
int		 kr_delete(struct kroute *);
void		 kr_shutdown(void);
void		 kr_fib_couple(void);
void		 kr_fib_decouple(void);
void		 kr_dispatch_msg(int, short, void *);
void		 kr_show_route(struct imsg *);
void		 kr_reload(void);

void		 embedscope(struct sockaddr_in6 *);
void		 recoverscope(struct sockaddr_in6 *);
void		 addscope(struct sockaddr_in6 *, u_int32_t);
void		 clearscope(struct in6_addr *);
u_int8_t	 mask2prefixlen(struct sockaddr_in6 *);
struct in6_addr	*prefixlen2mask(u_int8_t);
void		inet6applymask(struct in6_addr *, const struct in6_addr *, int);

int		fetchifs(u_short);

/* logmsg.h */
const char	*log_in6addr(const struct in6_addr *);
const char	*log_in6addr_scope(const struct in6_addr *, unsigned int);
const char	*log_rtr_id(u_int32_t);
const char	*log_sockaddr(void *);
const char	*nbr_state_name(int);
const char	*if_state_name(int);
const char	*if_type_name(enum iface_type);
const char	*dst_type_name(enum dst_type);
const char	*path_type_name(enum path_type);

/* name2id.c */
u_int16_t	 rtlabel_name2id(const char *);
const char	*rtlabel_id2name(u_int16_t);
void		 rtlabel_unref(u_int16_t);
u_int32_t	 rtlabel_id2tag(u_int16_t);
u_int16_t	 rtlabel_tag2id(u_int32_t);
void		 rtlabel_tag(u_int16_t, u_int32_t);

/* ospf6d.c */
void	main_imsg_compose_ospfe(int, pid_t, void *, u_int16_t);
void	main_imsg_compose_rde(int, pid_t, void *, u_int16_t);
int	ospf_redistribute(struct kroute *, u_int32_t *);
void	merge_config(struct ospfd_conf *, struct ospfd_conf *);
void	imsg_event_add(struct imsgev *);
int	imsg_compose_event(struct imsgev *, u_int16_t, u_int32_t,
	    pid_t, int, void *, u_int16_t);

/* printconf.c */
void	print_config(struct ospfd_conf *);

#endif	/* _OSPF6D_H_ */
@


1.30
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.29 2015/09/27 17:31:50 stsp Exp $ */
d393 1
a398 5
};

struct rroute {
	struct kroute	kr;
	u_int32_t	metric;
@


1.29
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.28 2013/03/25 14:29:35 markus Exp $ */
d63 6
d558 5
a562 1
/* log.h */
@


1.28
log
@sync w/ospfd: improve snapshot handling; ok claudio, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.27 2013/03/22 14:25:31 sthen Exp $ */
d319 1
a319 1
	u_int8_t		 media_type;
d438 1
a438 1
	u_int8_t		 mediatype;
@


1.27
log
@Allow use of an alternative control socket, ported from ospfd. ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.26 2013/01/14 14:39:38 florian Exp $ */
d115 1
@


1.26
log
@kroute.c rev 1.69 of ospfd for ospf6d
------------------------------------------------------------------------
date: 2009/06/02 20:16:59;  author: claudio;  state: Exp;  lines: +13 -3
Track reject and blackhole routes and allow them to be redistributed even
though they point to the loopback. Mainly used for redistribute default since
on default free routers we need to have a fake route now.
After discussion with Tonnerre Lombard, idea OK henning@@
------------------------------------------------------------------------
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.25 2012/10/22 07:28:49 bluhm Exp $ */
d378 1
@


1.25
log
@Unfortunately "ospf6ctl show fib" printed embedded scopes as the
destination addresses still contain them.  To fix that, call
recoverscope() in log_in6addr().  Also log_in6addr_scope() should
not fiddle with the scope itself, put that into a generic function
addscope().
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.24 2012/09/19 19:20:34 bluhm Exp $ */
d59 3
a61 1
#define	F_REDISTRIBUTED		0x0100
@


1.24
log
@Instead of fiddling about the kame hack here and there, implement
the functions embedscope(), recoverscope(), clearscope().
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.23 2011/07/07 00:36:13 claudio Exp $ */
d540 1
@


1.23
log
@Kill nh_reachable. Link state checking is so easy now that it does not
matter anymore to cache this value for ospf6d.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.22 2010/08/22 21:15:25 bluhm Exp $ */
d538 3
@


1.22
log
@Redistributing the default route with ospf6d did not work correctly.
- kroute.c may not ignore the default route.
- Use the ROUNDUP macro from route/show.c as this one is also correct
  for netmask with prefixlen 0.
- Implement ospf_redistribute and the redistribute parser like
  ospfd.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.21 2010/07/01 18:57:21 bluhm Exp $ */
a318 1
	u_int8_t		 nh_reachable;
@


1.21
log
@The prefixes of interface addresses of an ospf link have to be
advertised as link-lsa and intra-area-prefix-lsa when they change
dynamically.  Handle RTM_NEWADDR and RTM_DELADDR in kroute by sending
an imsg to ospfe.  Upon this event, originate a new link-lsa in
ospfe.  In rde a new intra-area-prefix-lsa is generated when a
link-lsa appears or goes away.
ok claudio@@; ok and test stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.20 2010/06/03 10:00:34 bluhm Exp $ */
a60 3
#define REDISTRIBUTE_ON		0x01
#define REDISTRIBUTE_DEFAULT	0x02

d345 1
a362 1
	u_int32_t		defaultmetric;
@


1.20
log
@The is no md5 authentication in OSPFv3.  Remove some leftovers from
the ospf6d packet lenght calculation.
ok claudio@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.19 2009/12/22 19:32:36 claudio Exp $ */
d103 2
d327 7
@


1.19
log
@Add interface index aka. scope id to struct kroute so that the rde can pass
this information to kroute and kroute can use that information to fill in
the various sin6_scope_id fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.18 2009/12/22 17:54:04 claudio Exp $ */
a26 1
#include <md5.h>
@


1.18
log
@Link local addressing strikes again. Include ifindex in all nexthop
definitions so that we have a chance to build a correct nexthop.
Insane that a struct in6_addr is unable to fully specify an IPv6 address.
kroute.c still needs fixing but now the rib is starting to make sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.17 2009/11/02 20:24:58 claudio Exp $ */
d378 2
a381 1
	u_int32_t	ext_tag;
@


1.17
log
@Add IMSG_CTL_LOG_VERBOSE similar to ospfd it allows to toggle debug logging.
henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.16 2009/06/06 18:31:42 pyr Exp $ */
d461 1
@


1.16
log
@Get ready for including imsg.h from a lib, when it comes along.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.15 2009/06/06 09:02:46 eric Exp $ */
d97 1
@


1.15
log
@make ospf6ctl/ospf6d imsg-in-a-lib ready too.

ospf6ctl is already broken in tree (not connected to build).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.14 2009/01/28 22:47:36 stsp Exp $ */
d32 1
a32 1
#include "imsg.h"
@


1.14
log
@Teach ospf6d to originate Intra-Area-Prefix LSAs, which associate a list
of IPv6 prefixes with a Network LSA (there's another type of this LSA which
associates prefixes with a Router LSA -- this remains to be done).
Add what is necessary to allow ospf6ctl to read the new LSA type via IMSG.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.13 2008/12/30 21:31:54 claudio Exp $ */
d32 1
d65 2
a66 30
/* buffer */
struct buf {
	TAILQ_ENTRY(buf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 max;
	size_t			 wpos;
	size_t			 rpos;
};

struct msgbuf {
	TAILQ_HEAD(, buf)	 bufs;
	u_int32_t		 queued;
	int			 fd;
};

#define	IMSG_HEADER_SIZE	sizeof(struct imsg_hdr)
#define	MAX_IMSGSIZE		8192

struct buf_read {
	u_char			 buf[READ_BUF_SIZE];
	u_char			*rptr;
	size_t			 wpos;
};

struct imsgbuf {
	TAILQ_HEAD(, imsg_fd)	fds;
	struct buf_read		r;
	struct msgbuf		w;
	struct event		ev;
d68 3
a70 3
	int			fd;
	pid_t			pid;
	short			events;
a125 12
struct imsg_hdr {
	enum imsg_type	type;
	u_int16_t	len;
	u_int32_t	peerid;
	pid_t		pid;
};

struct imsg {
	struct imsg_hdr	 hdr;
	void		*data;
};

a495 12
/* buffer.c */
struct buf	*buf_open(size_t);
struct buf	*buf_dynamic(size_t, size_t);
int		 buf_add(struct buf *, void *, size_t);
void		*buf_reserve(struct buf *, size_t);
void		*buf_seek(struct buf *, size_t, size_t);
int		 buf_close(struct msgbuf *, struct buf *);
void		 buf_free(struct buf *);
void		 msgbuf_init(struct msgbuf *);
void		 msgbuf_clear(struct msgbuf *);
int		 msgbuf_write(struct msgbuf *);

a505 13
/* imsg.c */
void	 imsg_init(struct imsgbuf *, int, void (*)(int, short, void *));
ssize_t	 imsg_read(struct imsgbuf *);
ssize_t	 imsg_get(struct imsgbuf *, struct imsg *);
int	 imsg_compose(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
	    void *, u_int16_t);
struct buf	*imsg_create(struct imsgbuf *, enum imsg_type, u_int32_t, pid_t,
		    u_int16_t);
int	 imsg_add(struct buf *, void *, u_int16_t);
int	 imsg_close(struct imsgbuf *, struct buf *);
void	 imsg_free(struct imsg *);
void	 imsg_event_add(struct imsgbuf *); /* needs to be provided externally */

d552 1
a552 1
/* ospfd.c */
d557 3
@


1.13
log
@First try at originating Link (type-8) LSA. Code is wrong and the initial
LSA is lost in lsa_flood. Put this in because it goes in the right direction
and ospf6d is work in progress. Add necessary framework so that we can print
Link LSA in ospf6ctl.
Diff mostly from stsp@@ ospf6ctl part by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.12 2007/12/13 08:54:05 claudio Exp $ */
d109 1
@


1.12
log
@Monster commit of stuff I did mostly last month. What it does:
 * removes kif and uses iface for everything interface related.
   This removes unneeded data redundancy which makes the code more complex.
 * adds the link local prefix to struct iface and attaches a list with
   the other prefixes to the struct iface. This is needed to generate the
   link LSA.
 * disconnects struct iface from struct area (the backpointer is gone)
   this will make the reload code a bit easier.
norby@@ agrees with the direction we're heading with this
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.11 2007/11/27 12:23:06 claudio Exp $ */
d106 1
@


1.11
log
@Make lsa_find() find link local LSA by passing the interface instead of the
area as lookup point. Additionally make lsa_dump or actually the code around
it pass all LSA to ospf6ctl. The rde_spf.c are not final.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.10 2007/11/27 11:29:34 claudio Exp $ */
a120 1
	IMSG_CTL_IFINFO,
d126 2
a146 1
	IMSG_RECONF_IFACE,
d306 8
d319 1
d325 1
d335 1
a338 1
	struct area		*area;
d357 5
a361 1
	u_int8_t		 passive;
a425 18
struct kif_addr {
	TAILQ_ENTRY(kif_addr)	 entry;
	struct in6_addr		 addr;
	struct in6_addr		 mask;
	struct in6_addr		 dstbrd;
};

struct kif {
	char			 ifname[IF_NAMESIZE];
	u_long			 baudrate;
	int			 flags;
	int			 mtu;
	u_short			 ifindex;
	u_int8_t		 media_type;
	u_int8_t		 link_state;
	u_int8_t		 nh_reachable;	/* for nexthop verification */
};

d451 1
a451 1
	u_int32_t		 baudrate;
d568 8
a582 1
int		 kif_init(void);
a590 2
void		 kr_ifinfo(char *, pid_t);
struct kif	*kif_findname(char *, struct kif_addr **);
d596 2
@


1.10
log
@Monster diff to bring us a bit on track again.
a) implement all (or at least most) lsa_check() cases.
b) classify the LSA scope correctly and add a per interface lsa_tree for
   the link local stuff.
c) implement a function to parse a prefix.

There is still a lot missing currently link local LSA are added to the
interface tree but nothing can access them (lsa_find() and a few friends
need some changes).
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.9 2007/10/16 08:41:56 claudio Exp $ */
d118 1
@


1.9
log
@First step at making kroute IPv6 aware. This resulted in many additional
changes -- some are so hairy that I left them out for later by commenting out
larger blocks of code (just grep for XXX if you like to help).
Get it in early so that we can work on.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.8 2007/10/11 21:29:53 claudio Exp $ */
d316 2
@


1.8
log
@There is no need to support interface em0:<IP> anymore. Remove most of the
code the rest will be reused somehow.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.7 2007/10/11 21:25:37 claudio Exp $ */
d362 1
a362 2
	struct in_addr			addr;
	struct in_addr			mask;
d366 1
d395 2
a396 2
	struct in_addr	prefix;
	struct in_addr	nexthop;
d491 2
a492 2
	struct in_addr		 prefix;
	struct in_addr		 nexthop;
d589 3
a591 2
u_int8_t	mask2prefixlen(in_addr_t);
in_addr_t	prefixlen2mask(u_int8_t);
@


1.7
log
@No need to store the interface mask. An interface represents a link and is
only addressed via its link local address. All networks on top of it are
handled separately via type 8 Link-LSA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.6 2007/10/11 20:20:44 claudio Exp $ */
d586 1
a586 1
struct kif	*kif_findname(char *, struct in6_addr *, struct kif_addr **);
@


1.6
log
@In OSPFv3 auth crypt is no longer (actually all the auth code is gone) so
kill crypt_seq_num as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.5 2007/10/11 19:10:55 claudio Exp $ */
a320 1
	struct in6_addr		 mask;
@


1.5
log
@Last commit added way to much stuff. Revert the readd of global options.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.4 2007/10/11 19:06:41 claudio Exp $ */
a329 1
	u_int32_t		 crypt_seq_num;
@


1.4
log
@area_ospf_options() should return the options in network byte order.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.3 2007/10/11 19:02:47 claudio Exp $ */
a386 1
	u_int32_t		options; /* OSPF options */
@


1.3
log
@From ospfd:
Bye bye global ospf options. OSPF options are per area (at least the one
flag that we set). So introduce a area_ospf_options() function that will
return the correct flags for each area. This makes stub area support a lot
easier.
Don't check for OSPF_OPTION_E in the parent. OSPF_OPTION_E is per area and
so the parent process has no way to know if it should redistribute or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.2 2007/10/09 06:12:04 claudio Exp $ */
d387 1
@


1.2
log
@The router dead_interval switched from 32bit to a 16bit value in OSPFv3.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospf6d.h,v 1.1 2007/10/08 10:44:50 norby Exp $ */
a390 1
	int			options; /* OSPF options */
d486 1
a489 1
	u_int8_t		 options;
d534 1
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfd.h,v 1.68 2007/06/19 16:45:15 reyk Exp $ */
a328 1
	u_int32_t		 dead_interval;
d340 1
@

