head	1.14;
access;
symbols
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.16
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.12
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.6
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.8
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.14
date	2015.05.05.01.26.37;	author jsg;	state Exp;
branches;
next	1.13;
commitid	t9z5FiHTkQbSNv6Z;

1.13
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.12;
commitid	2uw1UTO4k6erpWzK;

1.12
date	2014.03.24.11.01.47;	author mpi;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.31.21.22.42;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.24.16.11.04;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.15.16.25.00;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.13.01.49.53;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.13.08.54.05;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.16.21.31.37;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.14.20.42.05;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.10.14.09.25;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.09.06.26.47;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.50;	author norby;	state Exp;
branches;
next	;


desc
@@


1.14
log
@use the sizeof the struct not the sizeof a pointer to the struct
ok claudio@@
@
text
@/*	$OpenBSD: packet.c,v 1.13 2014/10/25 03:23:49 lteo Exp $ */

/*
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip6.h>
#include <arpa/inet.h>
#include <net/if_dl.h>

#include <errno.h>
#include <event.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include "ospf6d.h"
#include "ospf6.h"
#include "log.h"
#include "ospfe.h"

int		 ip_hdr_sanity_check(const struct ip6_hdr *, u_int16_t);
int		 ospf_hdr_sanity_check(struct ospf_hdr *, u_int16_t,
		    const struct iface *, struct in6_addr *);
struct iface	*find_iface(struct ospfd_conf *, unsigned int,
		    struct in6_addr *);

int
gen_ospf_hdr(struct ibuf *buf, struct iface *iface, u_int8_t type)
{
	struct ospf_hdr	ospf_hdr;

	bzero(&ospf_hdr, sizeof(ospf_hdr));
	ospf_hdr.version = OSPF6_VERSION;
	ospf_hdr.type = type;
	ospf_hdr.rtr_id = ospfe_router_id();
	if (iface->type != IF_TYPE_VIRTUALLINK)
		ospf_hdr.area_id = iface->area_id.s_addr;
	ospf_hdr.instance = DEFAULT_INSTANCE_ID;
	ospf_hdr.zero = 0;		/* must be zero */

	return (ibuf_add(buf, &ospf_hdr, sizeof(ospf_hdr)));
}

int
upd_ospf_hdr(struct ibuf *buf, struct iface *iface)
{
	struct ospf_hdr	*ospf_hdr;

	if ((ospf_hdr = ibuf_seek(buf, 0, sizeof(*ospf_hdr))) == NULL)
		fatalx("upd_ospf_hdr: buf_seek failed");

	/* update length */
	if (buf->wpos > USHRT_MAX)
		fatalx("upd_ospf_hdr: resulting ospf packet too big");
	ospf_hdr->len = htons((u_int16_t)buf->wpos);
	ospf_hdr->chksum = 0; /* calculated via IPV6_CHECKSUM */

	return (0);
}

/* send and receive packets */
int
send_packet(struct iface *iface, void *pkt, size_t len,
    struct in6_addr *dst)
{
	struct sockaddr_in6	 sa6;

	/* setup buffer */
	bzero(&sa6, sizeof(sa6));

	sa6.sin6_family = AF_INET6;
	sa6.sin6_len = sizeof(sa6);
	sa6.sin6_addr = *dst;

	/* don't we all love link local scope and all the needed hacks for it */
	if (IN6_IS_ADDR_LINKLOCAL(dst) || IN6_IS_ADDR_MC_LINKLOCAL(dst))
		sa6.sin6_scope_id = iface->ifindex;

	/* set outgoing interface for multicast traffic */
	if (IN6_IS_ADDR_MULTICAST(dst))
		if (if_set_mcast(iface) == -1) {
			log_warn("send_packet: error setting multicast "
			    "interface, %s", iface->name);
			return (-1);
		}

	if (sendto(iface->fd, pkt, len, 0, (struct sockaddr *)&sa6,
	    sizeof(sa6)) == -1) {
		log_warn("send_packet: error sending packet on interface %s",
		    iface->name);
		return (-1);
	}

	return (0);
}

void
recv_packet(int fd, short event, void *bula)
{
	union {
		struct cmsghdr hdr;
		char	buf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
	} cmsgbuf;
	struct msghdr		 msg;
	struct iovec		 iov;
	struct in6_addr		 addr, dest;
	struct sockaddr_in6	 src;
	struct ospfd_conf	*xconf = bula;
	struct ospf_hdr		*ospf_hdr;
	struct iface		*iface;
	struct nbr		*nbr = NULL;
	char			*buf;
	struct cmsghdr		*cmsg;
	ssize_t			 r;
	u_int16_t		 len;
	int			 l;
	unsigned int		 ifindex = 0;

	if (event != EV_READ)
		return;

	/* setup buffer */
	bzero(&msg, sizeof(msg));
	iov.iov_base = buf = pkt_ptr;
	iov.iov_len = READ_BUF_SIZE;
	msg.msg_name = &src;
	msg.msg_namelen = sizeof(src);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);

	if ((r = recvmsg(fd, &msg, 0)) == -1) {
		if (errno != EAGAIN && errno != EINTR)
			log_debug("recv_packet: read error: %s",
			    strerror(errno));
		return;
	}
	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
	    cmsg = CMSG_NXTHDR(&msg, cmsg)) {
		if (cmsg->cmsg_level == IPPROTO_IPV6 &&
		    cmsg->cmsg_type == IPV6_PKTINFO) {
			ifindex = ((struct in6_pktinfo *)
			    CMSG_DATA(cmsg))->ipi6_ifindex;
			dest = ((struct in6_pktinfo *)
			    CMSG_DATA(cmsg))->ipi6_addr;
			break;
		}
	}

	/* find a matching interface */
	if ((iface = find_iface(xconf, ifindex, &src.sin6_addr)) == NULL) {
		/* XXX add a counter here */
		return;
	}
	/*
	 * Packet needs to be sent to AllSPFRouters or AllDRouters
	 * or to the address of the interface itself.
	 * AllDRouters is only valid for DR and BDR but this is checked later.
	 */
	inet_pton(AF_INET6, AllSPFRouters, &addr);

	if (!IN6_ARE_ADDR_EQUAL(&dest, &addr)) {
		inet_pton(AF_INET6, AllDRouters, &addr);
		if (!IN6_ARE_ADDR_EQUAL(&dest, &addr)) {
			if (!IN6_ARE_ADDR_EQUAL(&dest, &iface->addr)) {
				log_debug("recv_packet: packet sent to wrong "
				    "address %s, interface %s",
				    log_in6addr(&dest), iface->name);
				return;
			}
		}
	}

	len = (u_int16_t)r;
	/* OSPF header sanity checks */
	if (len < sizeof(*ospf_hdr)) {
		log_debug("recv_packet: bad packet size");
		return;
	}
	ospf_hdr = (struct ospf_hdr *)buf;

	if ((l = ospf_hdr_sanity_check(ospf_hdr, len, iface, &dest)) == -1)
		return;

	nbr = nbr_find_id(iface, ospf_hdr->rtr_id);
	if (ospf_hdr->type != PACKET_TYPE_HELLO && nbr == NULL) {
		log_debug("recv_packet: unknown neighbor ID");
		return;
	}

	buf += sizeof(*ospf_hdr);
	len = l - sizeof(*ospf_hdr);

	/* switch OSPF packet type */
	switch (ospf_hdr->type) {
	case PACKET_TYPE_HELLO:
		inet_pton(AF_INET6, AllDRouters, &addr);
		if (IN6_ARE_ADDR_EQUAL(&dest, &addr)) {
			log_debug("recv_packet: invalid destination IP "
			     "address");
			break;
		}

		recv_hello(iface, &src.sin6_addr, ospf_hdr->rtr_id, buf, len);
		break;
	case PACKET_TYPE_DD:
		recv_db_description(nbr, buf, len);
		break;
	case PACKET_TYPE_LS_REQUEST:
		recv_ls_req(nbr, buf, len);
		break;
	case PACKET_TYPE_LS_UPDATE:
		recv_ls_update(nbr, buf, len);
		break;
	case PACKET_TYPE_LS_ACK:
		recv_ls_ack(nbr, buf, len);
		break;
	default:
		log_debug("recv_packet: unknown OSPF packet type, interface %s",
		    iface->name);
	}
}

int
ospf_hdr_sanity_check(struct ospf_hdr *ospf_hdr, u_int16_t len,
    const struct iface *iface, struct in6_addr *dst)
{
	struct in6_addr		 addr;
	struct in_addr		 id;

	if (ospf_hdr->version != OSPF6_VERSION) {
		log_debug("recv_packet: invalid OSPF version %d",
		    ospf_hdr->version);
		return (-1);
	}

	if (ntohs(ospf_hdr->len) > len ||
	    len <= sizeof(struct ospf_hdr)) {
		log_debug("recv_packet: invalid OSPF packet length %d",
		    ntohs(ospf_hdr->len));
		return (-1);
	}

	if (iface->type != IF_TYPE_VIRTUALLINK) {
		if (ospf_hdr->area_id != iface->area_id.s_addr) {
			id.s_addr = ospf_hdr->area_id;
			log_debug("recv_packet: invalid area ID %s, "
			    "interface %s", inet_ntoa(id), iface->name);
			return (-1);
		}
	} else {
		if (ospf_hdr->area_id != 0) {
			id.s_addr = ospf_hdr->area_id;
			log_debug("recv_packet: invalid area ID %s, "
			    "interface %s", inet_ntoa(id), iface->name);
			return (-1);
		}
	}

	if (iface->type == IF_TYPE_BROADCAST || iface->type == IF_TYPE_NBMA) {
		if (inet_pton(AF_INET6, AllDRouters, &addr) == 0)
			fatalx("recv_packet: inet_pton");
		if (IN6_ARE_ADDR_EQUAL(dst, &addr) &&
		    (iface->state & IF_STA_DRORBDR) == 0) {
			log_debug("recv_packet: invalid destination IP in "
			    "state %s, interface %s",
			    if_state_name(iface->state), iface->name);
			return (-1);
		}
	}

	return (ntohs(ospf_hdr->len));
}

struct iface *
find_iface(struct ospfd_conf *xconf, unsigned int ifindex, struct in6_addr *src)
{
	struct area	*area;
	struct iface	*iface, *match = NULL;

	/*
	 * Returned interface needs to be active.
	 * Virtual-Links have higher precedence so the full interface
	 * list needs to be scanned for possible matches.
	 */
	LIST_FOREACH(area, &xconf->area_list, entry) {
		LIST_FOREACH(iface, &area->iface_list, entry) {
			switch (iface->type) {
			case IF_TYPE_VIRTUALLINK:
				if (IN6_ARE_ADDR_EQUAL(src, &iface->dst) &&
				    !(iface->cflags & F_IFACE_PASSIVE))
					return (iface);
				break;
			default:
				if (ifindex == iface->ifindex &&
				    !(iface->cflags & F_IFACE_PASSIVE))
					match = iface;
				break;
			}
		}
	}

	return (match);
}
@


1.13
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.12 2014/03/24 11:01:47 mpi Exp $ */
d68 1
a68 1
	if ((ospf_hdr = ibuf_seek(buf, 0, sizeof(ospf_hdr))) == NULL)
@


1.12
log
@Passing MSG_DONTROUTE to sendto() here has no effect since SO_DONTROUTE
is only implemented for IPv4.  Just remove it.

Tested by and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.11 2010/12/31 21:22:42 guenther Exp $ */
a23 1
#include <netinet/in_systm.h>
@


1.11
log
@Add missing #includes instead of assuming that some system header pulls in
the needed bits

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.10 2010/05/26 13:56:08 nicm Exp $ */
d107 1
a107 1
	if (sendto(iface->fd, pkt, len, MSG_DONTROUTE, (struct sockaddr *)&sa6,
@


1.10
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.9 2008/03/24 16:11:04 deraadt Exp $ */
d32 1
@


1.9
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.8 2008/03/15 16:25:00 deraadt Exp $ */
d47 1
a47 1
gen_ospf_hdr(struct buf *buf, struct iface *iface, u_int8_t type)
d60 1
a60 1
	return (buf_add(buf, &ospf_hdr, sizeof(ospf_hdr)));
d64 1
a64 1
upd_ospf_hdr(struct buf *buf, struct iface *iface)
d68 1
a68 1
	if ((ospf_hdr = buf_seek(buf, 0, sizeof(ospf_hdr))) == NULL)
@


1.8
log
@Repair more msg_controllen dealing with structures or arrays of
descriptors; ok hshoexer, also looked at by kettenis and henning
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.7 2008/03/13 01:49:53 deraadt Exp $ */
d150 1
a150 1
	msg.msg_controllen = CMSG_LEN(sizeof(struct in6_pktinfo));
@


1.7
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.6 2007/12/13 08:54:05 claudio Exp $ */
d150 1
a150 1
	msg.msg_controllen = sizeof(cmsgbuf.buf);
@


1.6
log
@Monster commit of stuff I did mostly last month. What it does:
 * removes kif and uses iface for everything interface related.
   This removes unneeded data redundancy which makes the code more complex.
 * adds the link local prefix to struct iface and attaches a list with
   the other prefixes to the struct iface. This is needed to generate the
   link LSA.
 * disconnects struct iface from struct area (the backpointer is gone)
   this will make the reload code a bit easier.
norby@@ agrees with the direction we're heading with this
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.5 2007/10/16 21:31:37 claudio Exp $ */
d119 4
a122 1
	char			 cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
d149 2
a150 2
	msg.msg_control = cbuf;
	msg.msg_controllen = sizeof(cbuf);
@


1.5
log
@remove log_debug() packet sending is now solid so no need to fill the log
with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.4 2007/10/14 20:42:05 claudio Exp $ */
d56 1
a56 1
		ospf_hdr.area_id = iface->area->id.s_addr;
d262 1
a262 1
		if (ospf_hdr->area_id != iface->area->id.s_addr) {
d308 1
a308 1
				    !iface->passive)
d313 1
a313 1
				    !iface->passive)
@


1.4
log
@Switch log_sockaddr() to take a void * so it is not necessary to cast the
sockaddr_in6 or sockaddr_in to a sockaddr.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.3 2007/10/10 14:09:25 claudio Exp $ */
a105 2
	log_debug("send_packet: iface %d addr %s dest %s", iface->ifindex,
	    log_in6addr(&iface->addr), log_sockaddr(&sa6));
@


1.3
log
@send_packet() now takes a struct in6_addr as destination instead of a
struct sockaddr_in6 and builds the struct sockaddr_in6 internaly adding scope
if necessary. While there switch to sendto() we don't need any of the sendmsg()
features here.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.2 2007/10/09 06:26:47 claudio Exp $ */
d107 1
a107 1
	    log_in6addr(&iface->addr), log_sockaddr((void *)&sa6));
@


1.2
log
@Remaining bit of last night work. Make packet reception use all the goodies
introduced (checksumming is no longer needed, no IP header checking is needed,
get a in6_pktinfo with the ifindex and dest addr, cleanup and remove a lot
of other code). With this ospf6d is able to send and receive first hello
packets.  OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.1 2007/10/08 10:44:50 norby Exp $ */
d83 1
a83 1
    struct sockaddr_in6 *dst)
d85 2
a86 2
	struct msghdr		 msg;
	struct iovec		 iov[1];
d88 9
a96 7
	bzero(&msg, sizeof(msg));
	iov[0].iov_base = pkt;
	iov[0].iov_len = len;
	msg.msg_name = dst;
	msg.msg_namelen = sizeof(*dst);
	msg.msg_iov = iov;
	msg.msg_iovlen = 1;
d99 1
a99 1
	if (IN6_IS_ADDR_MULTICAST(&dst->sin6_addr))
d107 3
a109 2
	    log_in6addr(&iface->addr), log_in6addr(&dst->sin6_addr));
	if (sendmsg(iface->fd, &msg, MSG_DONTROUTE) == -1) {
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.22 2006/11/17 08:55:31 claudio Exp $ */
d41 4
a44 3
int		 ospf_hdr_sanity_check(const struct ip6_hdr *,
		    struct ospf_hdr *, u_int16_t, const struct iface *);
struct iface	*find_iface(struct ospfd_conf *, unsigned int, struct in6_addr);
d75 1
a75 2

		ospf_hdr->chksum = in_cksum(buf->buf, buf->wpos);	/* XXX */
d104 2
a105 4

	log_debug("send_packet: iface %d addr %s", iface->ifindex,
	    log_in6addr(&iface->addr));
	log_debug("send_packet: dest %s", log_in6addr(&dst->sin6_addr));
d118 1
a118 1
	char			 cbuf[CMSG_SPACE(sizeof(struct sockaddr_dl))];
d121 2
a122 2
	struct ip6_hdr		 ip_hdr;
	struct in6_addr		 addr;
d141 2
d157 5
a161 3
		    cmsg->cmsg_type == IP_RECVIF) {
			ifindex = ((struct sockaddr_dl *)
			    CMSG_DATA(cmsg))->sdl_index;
a165 13
	len = (u_int16_t)r;

	/* IP header sanity checks */
	if (len < sizeof(ip_hdr)) {
		log_warnx("recv_packet: bad packet size");
		return;
	}
	memcpy(&ip_hdr, buf, sizeof(ip_hdr));
	if ((l = ip_hdr_sanity_check(&ip_hdr, len)) == -1)
		return;
	buf += l;
	len -= l;

d167 1
a167 1
	if ((iface = find_iface(xconf, ifindex, ip_hdr.ip6_src)) == NULL) {
a170 1
#if 1
d178 1
a178 1
	if (!IN6_ARE_ADDR_EQUAL(&ip_hdr.ip6_dst, &addr)) {
d180 2
a181 3
		if (!IN6_ARE_ADDR_EQUAL(&ip_hdr.ip6_dst, &addr)) {
			if (!IN6_ARE_ADDR_EQUAL(&ip_hdr.ip6_dst,
			     &iface->addr)) {
d184 1
a184 1
				    log_in6addr(&ip_hdr.ip6_dst), iface->name);
d189 2
a190 1
#endif
d198 1
a198 1
	if ((l = ospf_hdr_sanity_check(&ip_hdr, ospf_hdr, len, iface)) == -1)
a206 6
	if (in_cksum(buf, len)) {
		log_warnx("recv_packet: invalid checksum, "
		    "interface %s", iface->name);
		return;
	}

d214 1
a214 1
		if (IN6_ARE_ADDR_EQUAL(&ip_hdr.ip6_dst, &addr)) {
d220 1
a220 1
		recv_hello(iface, ip_hdr.ip6_src, ospf_hdr->rtr_id, buf, len);
d241 2
a242 19
ip_hdr_sanity_check(const struct ip6_hdr *ip_hdr, u_int16_t len)
{
	if (ntohs(ip_hdr->ip6_plen) != len) {
		log_debug("recv_packet: invalid IP packet length %u",
		    ntohs(ip_hdr->ip6_plen));
		return (-1);
	}

	if (ip_hdr->ip6_nxt != IPPROTO_OSPF)
		/* this is enforced by the socket itself */
		fatalx("recv_packet: invalid IP proto");

//XXX	return (ip_hdr->ip_hl << 2);
	return (sizeof(struct ip6_hdr));
}

int
ospf_hdr_sanity_check(const struct ip6_hdr *ip_hdr, struct ospf_hdr *ospf_hdr,
    u_int16_t len, const struct iface *iface)
d279 1
a279 1
		if (IN6_ARE_ADDR_EQUAL(&ip_hdr->ip6_dst, &addr) &&
d292 1
a292 1
find_iface(struct ospfd_conf *xconf, unsigned int ifindex, struct in6_addr src)
d294 2
a295 2
	struct area	*area = NULL;
	struct iface	*iface = NULL;
d297 5
a301 1
	/* returned interface needs to be active */
d306 1
a306 7
				if (IN6_ARE_ADDR_EQUAL(&src, &iface->dst) &&
				    !iface->passive)
					return (iface);
				break;
			case IF_TYPE_POINTOPOINT:
				if (ifindex == iface->ifindex &&
				    IN6_ARE_ADDR_EQUAL(&iface->dst, &src) &&
a310 1
#if 0
a311 2
				    (iface->addr.s_addr & iface->mask.s_addr) ==
				    (src.s_addr & iface->mask.s_addr) &&
d313 1
a313 2
					return (iface);
#endif
d319 1
a319 1
	return (NULL);
@

