head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.32
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.28
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.30
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.22
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.26
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.24
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.20
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.18
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.16
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.14
	OPENBSD_5_0:1.4.0.12
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.10
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.8
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.4
date	2008.12.28.20.08.31;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.11.19.06.41;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.11.19.02.47;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.50;	author norby;	state Exp;
branches;
next	;


desc
@@


1.4
log
@area_ospf_options() should not return network byte order options. Instead
the callers should take care of getting the byte order right. While there
remove the opts[123] from the hello_hdr and use LSA_24_* to handle this
nasty fields instead. Now router LSA have the correct flags set.
@
text
@/*	$OpenBSD: area.c,v 1.3 2007/10/11 19:06:41 claudio Exp $ */

/*
 * Copyright (c) 2004, 2005, 2007 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/tree.h>

#include <err.h>
#include <stdlib.h>

#include "ospf6.h"
#include "ospf6d.h"
#include "ospfe.h"
#include "rde.h"
#include "log.h"

struct area *
area_new(void)
{
	struct area *area = NULL;

	if ((area = calloc(1, sizeof(*area))) == NULL)
		errx(1, "area_new: calloc");

	LIST_INIT(&area->iface_list);
	LIST_INIT(&area->nbr_list);
	RB_INIT(&area->lsa_tree);

	return (area);
}

int
area_del(struct area *area)
{
	struct iface	*iface = NULL;
	struct vertex	*v, *nv;
	struct rde_nbr	*n;

	/* area is removed so neutralize the demotion done by the area */
	if (area->active == 0)
		ospfe_demote_area(area, 1);

	/* clean lists */
	while ((iface = LIST_FIRST(&area->iface_list)) != NULL) {
		LIST_REMOVE(iface, entry);
		if_del(iface);
	}

	while ((n = LIST_FIRST(&area->nbr_list)) != NULL)
		rde_nbr_del(n);

	for (v = RB_MIN(lsa_tree, &area->lsa_tree); v != NULL; v = nv) {
		nv = RB_NEXT(lsa_tree, &area->lsa_tree, v);
		vertex_free(v);
	}

	free(area);

	return (0);
}

struct area *
area_find(struct ospfd_conf *conf, struct in_addr area_id)
{
	struct area	*area;

	LIST_FOREACH(area, &conf->area_list, entry) {
		if (area->id.s_addr == area_id.s_addr) {
			return (area);
		}
	}

	return (NULL);
}

void
area_track(struct area *area, int state)
{
	int	old = area->active;

	if (state & NBR_STA_FULL)
		area->active++;
	else if (area->active == 0)
		fatalx("area_track: area already inactive");
	else
		area->active--;

	if (area->active == 0 || old == 0)
		ospfe_demote_area(area, old == 0);
}

int
area_border_router(struct ospfd_conf *conf)
{
	struct area	*area;
	int		 active = 0;

	LIST_FOREACH(area, &conf->area_list, entry)
		if (area->active > 0)
			active++;

	return (active > 1);
}

u_int32_t
area_ospf_options(struct area *area)
{
	u_int32_t	opt = OSPF_OPTION_V6 | OSPF_OPTION_R;

	if (area && !area->stub)
		opt |= OSPF_OPTION_E;

	return opt;
}
@


1.3
log
@area_ospf_options() should return the options in network byte order.
@
text
@d1 1
a1 1
/*	$OpenBSD: area.c,v 1.2 2007/10/11 19:02:47 claudio Exp $ */
d127 1
a127 1
	return (htonl(opt));
@


1.2
log
@From ospfd:
Bye bye global ospf options. OSPF options are per area (at least the one
flag that we set). So introduce a area_ospf_options() function that will
return the correct flags for each area. This makes stub area support a lot
easier.
Don't check for OSPF_OPTION_E in the parent. OSPF_OPTION_E is per area and
so the parent process has no way to know if it should redistribute or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: area.c,v 1.1 2007/10/08 10:44:50 norby Exp $ */
d127 1
a127 1
	return (opt);
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: area.c,v 1.6 2007/06/13 17:23:36 claudio Exp $ */
d117 11
@

