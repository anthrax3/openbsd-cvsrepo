head	1.50;
access;
symbols
	OPENBSD_6_0:1.47.0.4
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.45.0.6
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.38.0.2
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.37.0.6
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8;
locks; strict;
comment	@ * @;


1.50
date	2016.12.22.22.56.52;	author jca;	state Exp;
branches;
next	1.49;
commitid	S23PSmkHY0jjWsPv;

1.49
date	2016.09.03.10.25.36;	author renato;	state Exp;
branches;
next	1.48;
commitid	2D672KsaUkm6FxSg;

1.48
date	2016.09.02.14.06.35;	author benno;	state Exp;
branches;
next	1.47;
commitid	Z2jEGSLNZuIKq53q;

1.47
date	2015.12.05.13.12.41;	author claudio;	state Exp;
branches;
next	1.46;
commitid	4xNKczBxYPO9zMjt;

1.46
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.45;
commitid	kLBPo9HaQrkEaNW3;

1.45
date	2015.02.10.05.39.10;	author claudio;	state Exp;
branches;
next	1.44;
commitid	LcINzHD3xxMOidFk;

1.44
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.43;
commitid	yCis8OrOsfixbKpI;

1.43
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.42;
commitid	lIxCxHhVEpsmXOdi;

1.42
date	2013.11.13.20.49.49;	author benno;	state Exp;
branches;
next	1.41;

1.41
date	2013.03.25.14.29.35;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.22.14.25.31;	author sthen;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.22.12.14.42;	author sthen;	state Exp;
branches;
next	1.38;

1.38
date	2012.09.17.13.49.27;	author bluhm;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.07.17.10.48;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.07.04.13.23;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2011.07.07.00.36.13;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2011.05.02.09.24.00;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.22.20.27.52;	author bluhm;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.06.13.15.32;	author bluhm;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.01.19.47.04;	author bluhm;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.01.18.57.21;	author bluhm;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.06.09.02.46;	author eric;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.31.20.29.56;	author jacekm;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.31.17.00.40;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.29.19.02.58;	author stsp;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.19.22.08.14;	author stsp;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.10.17.32.58;	author stsp;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.03.14.12.22;	author stsp;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.03.14.02.01;	author stsp;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.29.20.15.50;	author stsp;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.29.19.07.53;	author stsp;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.28.22.47.36;	author stsp;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.03.00.18.51;	author stsp;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.02.21.05.26;	author stsp;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.30.22.51.52;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.30.22.29.54;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.30.21.44.18;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.30.21.31.54;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.28.21.22.14;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.28.20.08.31;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.28.19.36.44;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.13.08.54.05;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.27.12.23.06;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.27.11.29.34;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.13.13.21.56;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.11.20.01.38;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.11.19.02.47;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.09.06.17.40;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.50;	author norby;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Don't run the FSM if the interface state hasn't changed.

ok benno@@ claudio@@
@
text
@/*	$OpenBSD: ospfe.c,v 1.49 2016/09/03 10:25:36 renato Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if_types.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <fcntl.h>
#include <pwd.h>
#include <unistd.h>
#include <event.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>

#include "ospf6.h"
#include "ospf6d.h"
#include "ospfe.h"
#include "rde.h"
#include "control.h"
#include "log.h"

void		 ospfe_sig_handler(int, short, void *);
__dead void	 ospfe_shutdown(void);
void		 orig_rtr_lsa_all(struct area *);
void		 orig_rtr_lsa_area(struct area *);
struct iface	*find_vlink(struct abr_rtr *);

struct ospfd_conf	*oeconf = NULL, *nconf;
struct imsgev		*iev_main;
struct imsgev		*iev_rde;
int			 oe_nofib;

/* ARGSUSED */
void
ospfe_sig_handler(int sig, short event, void *bula)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		ospfe_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* ospf engine */
pid_t
ospfe(struct ospfd_conf *xconf, int pipe_parent2ospfe[2], int pipe_ospfe2rde[2],
    int pipe_parent2rde[2])
{
	struct area	*area;
	struct iface	*iface;
	struct redistribute *r;
	struct passwd	*pw;
	struct event	 ev_sigint, ev_sigterm;
	pid_t		 pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	/* create ospfd control socket outside chroot */
	if (control_init(xconf->csock) == -1)
		fatalx("control socket setup failed");

	/* create the raw ip socket */
	if ((xconf->ospf_socket = socket(AF_INET6,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK, IPPROTO_OSPF)) == -1)
		fatal("error creating raw socket");

	/* set some defaults */
	if (if_set_mcast_loop(xconf->ospf_socket) == -1)
		fatal("if_set_mcast_loop");
	if (if_set_ipv6_checksum(xconf->ospf_socket) == -1)
		fatal("if_set_ipv6_checksum");
	if (if_set_ipv6_pktinfo(xconf->ospf_socket, 1) == -1)
		fatal("if_set_ipv6_pktinfo");
	if_set_recvbuf(xconf->ospf_socket);

	oeconf = xconf;
	if (oeconf->flags & OSPFD_FLAG_NO_FIB_UPDATE)
		oe_nofib = 1;

	if ((pw = getpwnam(OSPF6D_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("ospf engine");
	ospfd_process = PROC_OSPF_ENGINE;
	log_procname = log_procnames[ospfd_process];

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	event_init();
	nbr_init(NBR_HASHSIZE);
	lsa_cache_init(LSA_HASHSIZE);

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, ospfe_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, ospfe_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipes */
	close(pipe_parent2ospfe[0]);
	close(pipe_ospfe2rde[1]);
	close(pipe_parent2rde[0]);
	close(pipe_parent2rde[1]);

	if ((iev_rde = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_rde->ibuf, pipe_ospfe2rde[0]);
	iev_rde->handler = ospfe_dispatch_rde;
	imsg_init(&iev_main->ibuf, pipe_parent2ospfe[1]);
	iev_main->handler = ospfe_dispatch_main;

	/* setup event handler */
	iev_rde->events = EV_READ;
	event_set(&iev_rde->ev, iev_rde->ibuf.fd, iev_rde->events,
	    iev_rde->handler, iev_rde);
	event_add(&iev_rde->ev, NULL);

	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	event_set(&oeconf->ev, oeconf->ospf_socket, EV_READ|EV_PERSIST,
	    recv_packet, oeconf);
	event_add(&oeconf->ev, NULL);

	/* remove unneeded config stuff */
	while ((r = SIMPLEQ_FIRST(&oeconf->redist_list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&oeconf->redist_list, entry);
		free(r);
	}

	/* listen on ospfd control socket */
	TAILQ_INIT(&ctl_conns);
	control_listen();

	if ((pkt_ptr = calloc(1, READ_BUF_SIZE)) == NULL)
		fatal("ospfe");

	/* start interfaces */
	LIST_FOREACH(area, &oeconf->area_list, entry) {
		ospfe_demote_area(area, 0);
		LIST_FOREACH(iface, &area->iface_list, entry)
			if_start(xconf, iface);
	}

	event_dispatch();

	ospfe_shutdown();
	/* NOTREACHED */
	return (0);
}

__dead void
ospfe_shutdown(void)
{
	struct area	*area;
	struct iface	*iface;

	/* close pipes */
	msgbuf_write(&iev_rde->ibuf.w);
	msgbuf_clear(&iev_rde->ibuf.w);
	close(iev_rde->ibuf.fd);
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	/* stop all interfaces and remove all areas */
	while ((area = LIST_FIRST(&oeconf->area_list)) != NULL) {
		LIST_FOREACH(iface, &area->iface_list, entry) {
			if (if_fsm(iface, IF_EVT_DOWN)) {
				log_debug("error stopping interface %s",
				    iface->name);
			}
		}
		LIST_REMOVE(area, entry);
		area_del(area);
	}

	close(oeconf->ospf_socket);

	/* clean up */
	free(iev_rde);
	free(iev_main);
	free(oeconf);
	free(pkt_ptr);

	log_info("ospf engine exiting");
	_exit(0);
}

/* imesg */
int
ospfe_imsg_compose_parent(int type, pid_t pid, void *data, u_int16_t datalen)
{
	return (imsg_compose_event(iev_main, type, 0, pid, -1, data, datalen));
}

int
ospfe_imsg_compose_rde(int type, u_int32_t peerid, pid_t pid,
    void *data, u_int16_t datalen)
{
	return (imsg_compose_event(iev_rde, type, peerid, pid, -1,
	    data, datalen));
}

/* ARGSUSED */
void
ospfe_dispatch_main(int fd, short event, void *bula)
{
	static struct area	*narea;
	struct area		*area;
	struct iface		*iface, *ifp;
	struct ifaddrchange	*ifc;
	struct iface_addr	*ia, *nia;
	struct imsg		 imsg;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	int			 n, stub_changed, shut = 0, isvalid, wasvalid;
	unsigned int		 ifindex;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("ospfe_dispatch_main: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_IFINFO:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct iface))
				fatalx("IFINFO imsg with wrong len");
			ifp = imsg.data;

			iface = if_find(ifp->ifindex);
			if (iface == NULL)
				fatalx("interface lost in ospfe");

			wasvalid = (iface->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(iface->linkstate);

			if_update(iface, ifp->mtu, ifp->flags, ifp->if_type,
			    ifp->linkstate, ifp->baudrate);

			isvalid = (iface->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(iface->linkstate);

			if (wasvalid == isvalid)
				break;

			if (isvalid) {
				if_fsm(iface, IF_EVT_UP);
				log_warnx("interface %s up", iface->name);
			} else {
				if_fsm(iface, IF_EVT_DOWN);
				log_warnx("interface %s down", iface->name);
			}
			break;
		case IMSG_IFADD:
			if ((iface = malloc(sizeof(struct iface))) == NULL)
				fatal(NULL);
			memcpy(iface, imsg.data, sizeof(struct iface));

			LIST_INIT(&iface->nbr_list);
			TAILQ_INIT(&iface->ls_ack_list);
			RB_INIT(&iface->lsa_tree);

			area = area_find(oeconf, iface->area_id);
			LIST_INSERT_HEAD(&area->iface_list, iface, entry);
			break;
		case IMSG_IFDELETE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(ifindex))
				fatalx("IFDELETE imsg with wrong len");

			memcpy(&ifindex, imsg.data, sizeof(ifindex));
			iface = if_find(ifindex);
			if (iface == NULL)
				fatalx("interface lost in ospfe");

			LIST_REMOVE(iface, entry);
			if_del(iface);
			break;
		case IMSG_IFADDRNEW:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct ifaddrchange))
				fatalx("IFADDRNEW imsg with wrong len");
			ifc = imsg.data;

			iface = if_find(ifc->ifindex);
			if (iface == NULL)
				fatalx("IFADDRNEW interface lost in ospfe");

			if ((ia = calloc(1, sizeof(struct iface_addr))) ==
			    NULL)
				fatal("ospfe_dispatch_main IFADDRNEW");
			ia->addr = ifc->addr;
			ia->dstbrd = ifc->dstbrd;
			ia->prefixlen = ifc->prefixlen;

			TAILQ_INSERT_TAIL(&iface->ifa_list, ia, entry);
			orig_link_lsa(iface);
			break;
		case IMSG_IFADDRDEL:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct ifaddrchange))
				fatalx("IFADDRDEL imsg with wrong len");
			ifc = imsg.data;

			iface = if_find(ifc->ifindex);
			if (iface == NULL)
				fatalx("IFADDRDEL interface lost in ospfe");

			for (ia = TAILQ_FIRST(&iface->ifa_list); ia != NULL;
			    ia = nia) {
				nia = TAILQ_NEXT(ia, entry);

				if (IN6_ARE_ADDR_EQUAL(&ia->addr,
				    &ifc->addr)) {
					TAILQ_REMOVE(&iface->ifa_list, ia,
					    entry);
					free(ia);
					break;
				}
			}
			orig_link_lsa(iface);
			break;
		case IMSG_RECONF_CONF:
			if ((nconf = malloc(sizeof(struct ospfd_conf))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct ospfd_conf));

			LIST_INIT(&nconf->area_list);
			LIST_INIT(&nconf->cand_list);
			break;
		case IMSG_RECONF_AREA:
			if ((narea = area_new()) == NULL)
				fatal(NULL);
			memcpy(narea, imsg.data, sizeof(struct area));

			LIST_INIT(&narea->iface_list);
			LIST_INIT(&narea->nbr_list);
			RB_INIT(&narea->lsa_tree);

			LIST_INSERT_HEAD(&nconf->area_list, narea, entry);
			break;
		case IMSG_RECONF_END:
			if ((oeconf->flags & OSPFD_FLAG_STUB_ROUTER) !=
			    (nconf->flags & OSPFD_FLAG_STUB_ROUTER))
				stub_changed = 1;
			else
				stub_changed = 0;
			merge_config(oeconf, nconf);
			nconf = NULL;
			if (stub_changed)
				orig_rtr_lsa_all(NULL);
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_END:
			control_imsg_relay(&imsg);
			break;
		default:
			log_debug("ospfe_dispatch_main: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
void
ospfe_dispatch_rde(int fd, short event, void *bula)
{
	struct lsa_hdr		 lsa_hdr;
	struct lsa_link		 lsa_link;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct nbr		*nbr;
	struct lsa_hdr		*lhp;
	struct lsa_ref		*ref;
	struct area		*area;
	struct iface		*iface;
	struct lsa_entry	*le;
	struct imsg		 imsg;
	struct abr_rtr		 ar;
	int			 n, noack = 0, shut = 0;
	u_int16_t		 l, age;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("ospfe_dispatch_rde: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_DD:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			/* put these on my ls_req_list for retrieval */
			lhp = lsa_hdr_new();
			memcpy(lhp, imsg.data, sizeof(*lhp));
			ls_req_list_add(nbr, lhp);
			break;
		case IMSG_DD_END:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			nbr->dd_pending--;
			if (nbr->dd_pending == 0 && nbr->state & NBR_STA_LOAD) {
				if (ls_req_list_empty(nbr))
					nbr_fsm(nbr, NBR_EVT_LOAD_DONE);
				else
					start_ls_req_tx_timer(nbr);
			}
			break;
		case IMSG_DB_SNAPSHOT:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;
			if (nbr->state != NBR_STA_SNAP)	/* discard */
				break;

			/* add LSA header to the neighbor db_sum_list */
			lhp = lsa_hdr_new();
			memcpy(lhp, imsg.data, sizeof(*lhp));
			db_sum_list_add(nbr, lhp);
			break;
		case IMSG_DB_END:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			nbr->dd_snapshot = 0;
			if (nbr->state != NBR_STA_SNAP)
				break;

			/* snapshot done, start tx of dd packets */
			nbr_fsm(nbr, NBR_EVT_SNAP_DONE);
			break;
		case IMSG_LS_FLOOD:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			l = imsg.hdr.len - IMSG_HEADER_SIZE;
			if (l < sizeof(lsa_hdr))
				fatalx("ospfe_dispatch_rde: "
				    "bad imsg size");
			memcpy(&lsa_hdr, imsg.data, sizeof(lsa_hdr));

			ref = lsa_cache_add(imsg.data, l);

			if (lsa_hdr.type == htons(LSA_TYPE_EXTERNAL)) {
				/*
				 * flood on all areas but stub areas and
				 * virtual links
				 */
				LIST_FOREACH(area, &oeconf->area_list, entry) {
					if (area->stub)
						continue;
					LIST_FOREACH(iface, &area->iface_list,
					    entry) {
						noack += lsa_flood(iface, nbr,
						    &lsa_hdr, imsg.data);
					}
				}
			} else if (lsa_hdr.type == htons(LSA_TYPE_LINK)) {
				/*
				 * Save link-LSA options of neighbor.
				 * This is needed to originate network-LSA.
				 */
				if (l - sizeof(lsa_hdr) < sizeof(lsa_link))
					fatalx("ospfe_dispatch_rde: "
					    "bad imsg link size");
				memcpy(&lsa_link, (char *)imsg.data +
				    sizeof(lsa_hdr), sizeof(lsa_link));
				nbr->link_options = lsa_link.opts &
				    htonl(LSA_24_MASK);

				/*
				 * flood on interface only
				 */
				noack += lsa_flood(nbr->iface, nbr,
				    &lsa_hdr, imsg.data);
			} else {
				/*
				 * flood on all area interfaces on
				 * area 0.0.0.0 include also virtual links.
				 */
				if ((area = area_find(oeconf,
				    nbr->iface->area_id)) == NULL)
					fatalx("interface lost area");
				LIST_FOREACH(iface, &area->iface_list, entry) {
					noack += lsa_flood(iface, nbr,
					    &lsa_hdr, imsg.data);
				}
				/* XXX virtual links */
			}

			/* remove from ls_req_list */
			le = ls_req_list_get(nbr, &lsa_hdr);
			if (!(nbr->state & NBR_STA_FULL) && le != NULL) {
				ls_req_list_free(nbr, le);
				/*
				 * XXX no need to ack requested lsa
				 * the problem is that the RFC is very
				 * unclear about this.
				 */
				noack = 1;
			}

			if (!noack && nbr->iface != NULL &&
			    nbr->iface->self != nbr) {
				if (!(nbr->iface->state & IF_STA_BACKUP) ||
				    nbr->iface->dr == nbr) {
					/* delayed ack */
					lhp = lsa_hdr_new();
					memcpy(lhp, &lsa_hdr, sizeof(*lhp));
					ls_ack_list_add(nbr->iface, lhp);
				}
			}

			lsa_cache_put(ref, nbr);
			break;
		case IMSG_LS_UPD:
		case IMSG_LS_SNAP:
			/*
			 * IMSG_LS_UPD is used in two cases:
			 * 1. as response to ls requests
			 * 2. as response to ls updates where the DB
			 *    is newer then the sent LSA
			 * IMSG_LS_SNAP is used in one case:
			 *    in EXSTART when the LSA has age MaxAge
			 */
			l = imsg.hdr.len - IMSG_HEADER_SIZE;
			if (l < sizeof(lsa_hdr))
				fatalx("ospfe_dispatch_rde: "
				    "bad imsg size");

			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			if (nbr->iface->self == nbr)
				break;

			if (imsg.hdr.type == IMSG_LS_SNAP &&
			    nbr->state != NBR_STA_SNAP)
				break;

			memcpy(&age, imsg.data, sizeof(age));
			ref = lsa_cache_add(imsg.data, l);
			if (ntohs(age) >= MAX_AGE)
				/* add to retransmit list */
				ls_retrans_list_add(nbr, imsg.data, 0, 0);
			else
				ls_retrans_list_add(nbr, imsg.data, 0, 1);

			lsa_cache_put(ref, nbr);
			break;
		case IMSG_LS_ACK:
			/*
			 * IMSG_LS_ACK is used in two cases:
			 * 1. LSA was a duplicate
			 * 2. LS age is MaxAge and there is no current
			 *    instance in the DB plus no neighbor in state
			 *    Exchange or Loading
			 */
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			if (nbr->iface->self == nbr)
				break;

			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(lsa_hdr))
				fatalx("ospfe_dispatch_rde: bad imsg size");
			memcpy(&lsa_hdr, imsg.data, sizeof(lsa_hdr));

			/* for case one check for implied acks */
			if (nbr->iface->state & IF_STA_DROTHER)
				if (ls_retrans_list_del(nbr->iface->self,
				    &lsa_hdr) == 0)
					break;
			if (ls_retrans_list_del(nbr, &lsa_hdr) == 0)
				break;

			/* send a direct acknowledgement */
			send_ls_ack(nbr->iface, nbr->addr, imsg.data,
			    imsg.hdr.len - IMSG_HEADER_SIZE);

			break;
		case IMSG_LS_BADREQ:
			nbr = nbr_find_peerid(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			if (nbr->iface->self == nbr)
				fatalx("ospfe_dispatch_rde: "
				    "dummy neighbor got BADREQ");

			nbr_fsm(nbr, NBR_EVT_BAD_LS_REQ);
			break;
		case IMSG_ABR_UP:
			memcpy(&ar, imsg.data, sizeof(ar));

			if ((iface = find_vlink(&ar)) != NULL &&
			    iface->state == IF_STA_DOWN)
				if (if_fsm(iface, IF_EVT_UP)) {
					log_debug("error starting interface %s",
					    iface->name);
				}
			break;
		case IMSG_ABR_DOWN:
			memcpy(&ar, imsg.data, sizeof(ar));

			if ((iface = find_vlink(&ar)) != NULL &&
			    iface->state == IF_STA_POINTTOPOINT)
				if (if_fsm(iface, IF_EVT_DOWN)) {
					log_debug("error stopping interface %s",
					    iface->name);
				}
			break;
		case IMSG_CTL_AREA:
		case IMSG_CTL_IFACE:
		case IMSG_CTL_END:
		case IMSG_CTL_SHOW_DATABASE:
		case IMSG_CTL_SHOW_DB_EXT:
		case IMSG_CTL_SHOW_DB_LINK:
		case IMSG_CTL_SHOW_DB_NET:
		case IMSG_CTL_SHOW_DB_RTR:
		case IMSG_CTL_SHOW_DB_INTRA:
		case IMSG_CTL_SHOW_DB_SELF:
		case IMSG_CTL_SHOW_DB_SUM:
		case IMSG_CTL_SHOW_DB_ASBR:
		case IMSG_CTL_SHOW_RIB:
		case IMSG_CTL_SHOW_SUM:
		case IMSG_CTL_SHOW_SUM_AREA:
			control_imsg_relay(&imsg);
			break;
		default:
			log_debug("ospfe_dispatch_rde: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

struct iface *
find_vlink(struct abr_rtr *ar)
{
	struct area	*area;
	struct iface	*iface = NULL;

	LIST_FOREACH(area, &oeconf->area_list, entry)
		LIST_FOREACH(iface, &area->iface_list, entry)
			if (iface->abr_id.s_addr == ar->abr_id.s_addr &&
			    iface->type == IF_TYPE_VIRTUALLINK &&
//XXX			    iface->area->id.s_addr == ar->area.s_addr) {
			    iface->area_id.s_addr == ar->area.s_addr) {
//XXX				iface->dst.s_addr = ar->dst_ip.s_addr;
				iface->dst = ar->dst_ip;
//XXX				iface->addr.s_addr = ar->addr.s_addr;
				iface->addr = ar->addr;
				iface->metric = ar->metric;

				return (iface);
			}

	return (iface);
}

void
orig_rtr_lsa_all(struct area *area)
{
	struct area	*a;

	/*
	 * update all router LSA in all areas except area itself,
	 * as this update is already running.
	 */
	LIST_FOREACH(a, &oeconf->area_list, entry)
		if (a != area)
			orig_rtr_lsa_area(a);
}

void
orig_rtr_lsa(struct iface *iface)
{
	struct area	*area;

	if ((area = area_find(oeconf, iface->area_id)) == NULL)
		fatalx("interface lost area");
	orig_rtr_lsa_area(area);
}

void
orig_rtr_lsa_area(struct area *area)
{
	struct lsa_hdr		 lsa_hdr;
	struct lsa_rtr		 lsa_rtr;
	struct lsa_rtr_link	 rtr_link;
	struct iface		*iface;
	struct ibuf		*buf;
	struct nbr		*nbr, *self = NULL;
	u_int32_t		 flags;
	u_int16_t		 chksum;
	u_int8_t		 border, virtual = 0;

	log_debug("orig_rtr_lsa: area %s", inet_ntoa(area->id));

	/* XXX IBUF_READ_SIZE */
	if ((buf = ibuf_dynamic(sizeof(lsa_hdr), IBUF_READ_SIZE)) == NULL)
		fatal("orig_rtr_lsa");

	/* reserve space for LSA header and LSA Router header */
	if (ibuf_reserve(buf, sizeof(lsa_hdr)) == NULL)
		fatal("orig_rtr_lsa: ibuf_reserve failed");

	if (ibuf_reserve(buf, sizeof(lsa_rtr)) == NULL)
		fatal("orig_rtr_lsa: ibuf_reserve failed");

	/* links */
	LIST_FOREACH(iface, &area->iface_list, entry) {
		if (self == NULL && iface->self != NULL)
			self = iface->self;

		bzero(&rtr_link, sizeof(rtr_link));

		switch (iface->type) {
		case IF_TYPE_POINTOPOINT:
			LIST_FOREACH(nbr, &iface->nbr_list, entry)
				if (nbr != iface->self &&
				    nbr->state & NBR_STA_FULL)
					break;
			if (nbr && iface->state & IF_STA_POINTTOPOINT) {
				log_debug("orig_rtr_lsa: point-to-point, "
				    "interface %s", iface->name);
				rtr_link.type = LINK_TYPE_POINTTOPOINT;
				rtr_link.metric = htons(iface->metric);
				rtr_link.iface_id = htonl(iface->ifindex);
				rtr_link.nbr_iface_id = htonl(nbr->iface_id);
				rtr_link.nbr_rtr_id = nbr->id.s_addr;
				if (ibuf_add(buf, &rtr_link, sizeof(rtr_link)))
					fatalx("orig_rtr_lsa: ibuf_add failed");
			}
			continue;
		case IF_TYPE_BROADCAST:
		case IF_TYPE_NBMA:
			if ((iface->state & IF_STA_MULTI)) {
				if (iface->dr == iface->self) {
					LIST_FOREACH(nbr, &iface->nbr_list,
					    entry)
						if (nbr != iface->self &&
						    nbr->state & NBR_STA_FULL)
							break;
				} else
					nbr = iface->dr;

				if (nbr && nbr->state & NBR_STA_FULL) {
					log_debug("orig_rtr_lsa: transit net, "
					    "interface %s", iface->name);

					rtr_link.type = LINK_TYPE_TRANSIT_NET;
					rtr_link.metric = htons(iface->metric);
					rtr_link.iface_id = htonl(iface->ifindex);
					rtr_link.nbr_iface_id = htonl(iface->dr->iface_id);
					rtr_link.nbr_rtr_id = iface->dr->id.s_addr;
					if (ibuf_add(buf, &rtr_link,
					    sizeof(rtr_link)))
						fatalx("orig_rtr_lsa: "
						    "ibuf_add failed");
					break;
				}
			}
			break;
#if 0 /* TODO virtualllink/pointtomulti */
		case IF_TYPE_VIRTUALLINK:
			LIST_FOREACH(nbr, &iface->nbr_list, entry) {
				if (nbr != iface->self &&
				    nbr->state & NBR_STA_FULL)
					break;
			}
			if (nbr) {
				rtr_link.id = nbr->id.s_addr;
//XXX				rtr_link.data = iface->addr.s_addr;
				rtr_link.type = LINK_TYPE_VIRTUAL;
				/* RFC 3137: stub router support */
				if (oeconf->flags & OSPFD_FLAG_STUB_ROUTER ||
				    oe_nofib)
					rtr_link.metric = 0xffff;
				else
					rtr_link.metric = htons(iface->metric);
				virtual = 1;
				if (ibuf_add(buf, &rtr_link, sizeof(rtr_link)))
					fatalx("orig_rtr_lsa: ibuf_add failed");

				log_debug("orig_rtr_lsa: virtual link, "
				    "interface %s", iface->name);
			}
			continue;
		case IF_TYPE_POINTOMULTIPOINT:
			log_debug("orig_rtr_lsa: stub net, "
			    "interface %s", iface->name);
//XXX			rtr_link.id = iface->addr.s_addr;
			rtr_link.data = 0xffffffff;
			rtr_link.type = LINK_TYPE_STUB_NET;
			rtr_link.metric = htons(iface->metric);
			if (ibuf_add(buf, &rtr_link, sizeof(rtr_link)))
				fatalx("orig_rtr_lsa: ibuf_add failed");

			LIST_FOREACH(nbr, &iface->nbr_list, entry) {
				if (nbr != iface->self &&
				    nbr->state & NBR_STA_FULL) {
					bzero(&rtr_link, sizeof(rtr_link));
					log_debug("orig_rtr_lsa: "
					    "point-to-multipoint, interface %s",
					    iface->name);
//XXX					rtr_link.id = nbr->addr.s_addr;
//XXX					rtr_link.data = iface->addr.s_addr;
					rtr_link.type = LINK_TYPE_POINTTOPOINT;
					/* RFC 3137: stub router support */
					if (oe_nofib || oeconf->flags &
					    OSPFD_FLAG_STUB_ROUTER)
						rtr_link.metric = 0xffff;
					else
						rtr_link.metric =
						    htons(iface->metric);
					if (ibuf_add(buf, &rtr_link,
					    sizeof(rtr_link)))
						fatalx("orig_rtr_lsa: "
						    "ibuf_add failed");
				}
			}
			continue;
#endif /* TODO virtualllink/pointtomulti */
		default:
			fatalx("orig_rtr_lsa: unknown interface type");
		}
	}

	/* LSA router header */
	lsa_rtr.opts = 0;
	flags = 0;

	/*
	 * Set the E bit as soon as an as-ext lsa may be redistributed, only
	 * setting it in case we redistribute something is not worth the fuss.
	 */
	if (oeconf->redistribute && !area->stub)
		flags |= OSPF_RTR_E;

	border = (area_border_router(oeconf) != 0);
	if (border != oeconf->border) {
		oeconf->border = border;
		orig_rtr_lsa_all(area);
	}

	if (oeconf->border)
		flags |= OSPF_RTR_B;
	/* TODO set V flag if a active virtual link ends here and the
	 * area is the transit area for this link. */
	if (virtual)
		flags |= OSPF_RTR_V;

	LSA_24_SETLO(lsa_rtr.opts, area_ospf_options(area));
	LSA_24_SETHI(lsa_rtr.opts, flags);
	lsa_rtr.opts = htonl(lsa_rtr.opts);
	memcpy(ibuf_seek(buf, sizeof(lsa_hdr), sizeof(lsa_rtr)),
	    &lsa_rtr, sizeof(lsa_rtr));

	/* LSA header */
	lsa_hdr.age = htons(DEFAULT_AGE);
	lsa_hdr.type = htons(LSA_TYPE_ROUTER);
	/* XXX needs to be fixed if multiple router-lsa need to be announced */
	lsa_hdr.ls_id = 0;
	lsa_hdr.adv_rtr = oeconf->rtr_id.s_addr;
	lsa_hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa_hdr.len = htons(buf->wpos);
	lsa_hdr.ls_chksum = 0;		/* updated later */
	memcpy(ibuf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));

	chksum = htons(iso_cksum(buf->buf, buf->wpos, LS_CKSUM_OFFSET));
	memcpy(ibuf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
	    &chksum, sizeof(chksum));

	if (self)
		imsg_compose_event(iev_rde, IMSG_LS_UPD, self->peerid, 0,
		    -1, buf->buf, buf->wpos);
	else
		log_warnx("orig_rtr_lsa: empty area %s",
		    inet_ntoa(area->id));

	ibuf_free(buf);
}

void
orig_net_lsa(struct iface *iface)
{
	struct lsa_hdr		 lsa_hdr;
	struct nbr		*nbr;
	struct ibuf		*buf;
	struct lsa_net		 lsa_net;
	int			 num_rtr = 0;
	u_int16_t		 chksum;

	/* XXX IBUF_READ_SIZE */
	if ((buf = ibuf_dynamic(sizeof(lsa_hdr), IBUF_READ_SIZE)) == NULL)
		fatal("orig_net_lsa");

	/* reserve space for LSA header and options field */
	if (ibuf_reserve(buf, sizeof(lsa_hdr) + sizeof(lsa_net)) == NULL)
		fatal("orig_net_lsa: ibuf_reserve failed");

	lsa_net.opts = 0;
	/* fully adjacent neighbors + self */
	LIST_FOREACH(nbr, &iface->nbr_list, entry)
		if (nbr->state & NBR_STA_FULL) {
			if (ibuf_add(buf, &nbr->id, sizeof(nbr->id)))
				fatal("orig_net_lsa: ibuf_add failed");
			lsa_net.opts |= nbr->link_options;
			num_rtr++;
		}

	if (num_rtr == 1) {
		/* non transit net therefore no need to generate a net lsa */
		ibuf_free(buf);
		return;
	}

	/* LSA header */
	if (iface->state & IF_STA_DR)
		lsa_hdr.age = htons(DEFAULT_AGE);
	else
		lsa_hdr.age = htons(MAX_AGE);

	lsa_hdr.type = htons(LSA_TYPE_NETWORK);
	/* for network LSAs, the link state ID equals the interface ID */
	lsa_hdr.ls_id = htonl(iface->ifindex);
	lsa_hdr.adv_rtr = oeconf->rtr_id.s_addr;
	lsa_hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa_hdr.len = htons(buf->wpos);
	lsa_hdr.ls_chksum = 0;		/* updated later */
	memcpy(ibuf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));

	lsa_net.opts &= lsa_net.opts & htonl(LSA_24_MASK);
	memcpy(ibuf_seek(buf, sizeof(lsa_hdr), sizeof(lsa_net)), &lsa_net,
	    sizeof(lsa_net));

	chksum = htons(iso_cksum(buf->buf, buf->wpos, LS_CKSUM_OFFSET));
	memcpy(ibuf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
	    &chksum, sizeof(chksum));

	imsg_compose_event(iev_rde, IMSG_LS_UPD, iface->self->peerid, 0,
	    -1, buf->buf, buf->wpos);

	ibuf_free(buf);
}

void
orig_link_lsa(struct iface *iface)
{
	struct lsa_hdr		 lsa_hdr;
	struct lsa_link		 lsa_link;
	struct lsa_prefix	 lsa_prefix;
	struct ibuf		*buf;
	struct iface_addr	*ia;
	struct in6_addr		 prefix;
	unsigned int		 num_prefix = 0;
	u_int16_t		 chksum;
	u_int32_t		 options;

	log_debug("orig_link_lsa: interface %s", iface->name);

	switch (iface->type) {
	case IF_TYPE_VIRTUALLINK:	/* forbidden by rfc5340 */
		return;
	case IF_TYPE_BROADCAST:
	case IF_TYPE_NBMA:
		if ((iface->state & IF_STA_MULTI) == 0)
			return;
		break;
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_POINTOMULTIPOINT:
		if ((iface->state & IF_STA_POINTTOPOINT) == 0)
			return;
		break;
	default:
		fatalx("orig_link_lsa: unknown interface type");
	}

	/* XXX IBUF_READ_SIZE */
	if ((buf = ibuf_dynamic(sizeof(lsa_hdr) + sizeof(lsa_link),
	    IBUF_READ_SIZE)) == NULL)
		fatal("orig_link_lsa");

	/* reserve space for LSA header and LSA link header */
	if (ibuf_reserve(buf, sizeof(lsa_hdr) + sizeof(lsa_link)) == NULL)
		fatal("orig_link_lsa: ibuf_reserve failed");

	/* link-local address, and all prefixes configured on interface */
	TAILQ_FOREACH(ia, &iface->ifa_list, entry) {
		if (IN6_IS_ADDR_LINKLOCAL(&ia->addr)) {
			log_debug("orig_link_lsa: link local address %s",
			    log_in6addr(&ia->addr));
			lsa_link.lladdr = ia->addr;
			continue;
		}

		lsa_prefix.prefixlen = ia->prefixlen;
		lsa_prefix.options = 0;
		lsa_prefix.metric = 0;
		inet6applymask(&prefix, &ia->addr, ia->prefixlen);
		log_debug("orig_link_lsa: prefix %s", log_in6addr(&prefix));
		if (ibuf_add(buf, &lsa_prefix, sizeof(lsa_prefix)))
			fatal("orig_link_lsa: ibuf_add failed");
		if (ibuf_add(buf, &prefix.s6_addr[0],
		    LSA_PREFIXSIZE(ia->prefixlen)))
			fatal("orig_link_lsa: ibuf_add failed");
		num_prefix++;
	}

	/* LSA link header (lladdr has already been filled in above) */
	LSA_24_SETHI(lsa_link.opts, iface->priority);
	options = area_ospf_options(area_find(oeconf, iface->area_id));
	LSA_24_SETLO(lsa_link.opts, options);
	lsa_link.opts = htonl(lsa_link.opts);
	lsa_link.numprefix = htonl(num_prefix);
	memcpy(ibuf_seek(buf, sizeof(lsa_hdr), sizeof(lsa_link)),
	    &lsa_link, sizeof(lsa_link));

	/* LSA header */
	lsa_hdr.age = htons(DEFAULT_AGE);
	lsa_hdr.type = htons(LSA_TYPE_LINK);
	/* for link LSAs, the link state ID equals the interface ID */
	lsa_hdr.ls_id = htonl(iface->ifindex);
	lsa_hdr.adv_rtr = oeconf->rtr_id.s_addr;
	lsa_hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa_hdr.len = htons(buf->wpos);
	lsa_hdr.ls_chksum = 0;		/* updated later */
	memcpy(ibuf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));

	chksum = htons(iso_cksum(buf->buf, buf->wpos, LS_CKSUM_OFFSET));
	memcpy(ibuf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
	    &chksum, sizeof(chksum));

	imsg_compose_event(iev_rde, IMSG_LS_UPD, iface->self->peerid, 0,
	    -1, buf->buf, buf->wpos);

	ibuf_free(buf);
}

u_int32_t
ospfe_router_id(void)
{
	return (oeconf->rtr_id.s_addr);
}

void
ospfe_fib_update(int type)
{
	int	old = oe_nofib;

	if (type == IMSG_CTL_FIB_COUPLE)
		oe_nofib = 0;
	if (type == IMSG_CTL_FIB_DECOUPLE)
		oe_nofib = 1;
	if (old != oe_nofib)
		orig_rtr_lsa_all(NULL);
}

void
ospfe_iface_ctl(struct ctl_conn *c, unsigned int idx)
{
	struct area		*area;
	struct iface		*iface;
	struct ctl_iface	*ictl;

	LIST_FOREACH(area, &oeconf->area_list, entry)
		LIST_FOREACH(iface, &area->iface_list, entry)
			if (idx == 0 || idx == iface->ifindex) {
				ictl = if_to_ctl(iface);
				imsg_compose_event(&c->iev,
				    IMSG_CTL_SHOW_INTERFACE, 0, 0, -1,
				    ictl, sizeof(struct ctl_iface));
			}
}

void
ospfe_nbr_ctl(struct ctl_conn *c)
{
	struct area	*area;
	struct iface	*iface;
	struct nbr	*nbr;
	struct ctl_nbr	*nctl;

	LIST_FOREACH(area, &oeconf->area_list, entry)
		LIST_FOREACH(iface, &area->iface_list, entry)
			LIST_FOREACH(nbr, &iface->nbr_list, entry) {
				if (iface->self != nbr) {
					nctl = nbr_to_ctl(nbr);
					imsg_compose_event(&c->iev,
					    IMSG_CTL_SHOW_NBR, 0, 0, -1, nctl,
					    sizeof(struct ctl_nbr));
				}
			}

	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}

void
ospfe_demote_area(struct area *area, int active)
{
	struct demote_msg	dmsg;

	if (ospfd_process != PROC_OSPF_ENGINE ||
	    area->demote_group[0] == '\0')
		return;

	bzero(&dmsg, sizeof(dmsg));
	strlcpy(dmsg.demote_group, area->demote_group,
	    sizeof(dmsg.demote_group));
	dmsg.level = area->demote_level;
	if (active)
		dmsg.level = -dmsg.level;

	ospfe_imsg_compose_parent(IMSG_DEMOTE, 0, &dmsg, sizeof(dmsg));
}

void
ospfe_demote_iface(struct iface *iface, int active)
{
	struct demote_msg	dmsg;

	if (ospfd_process != PROC_OSPF_ENGINE ||
	    iface->demote_group[0] == '\0')
		return;

	bzero(&dmsg, sizeof(dmsg));
	strlcpy(dmsg.demote_group, iface->demote_group,
	sizeof(dmsg.demote_group));
	if (active)
		dmsg.level = -1;
	else
		dmsg.level = 1;

	log_warnx("ospfe_demote_iface: group %s level %d", dmsg.demote_group,
	    dmsg.level);

	ospfe_imsg_compose_parent(IMSG_DEMOTE, 0, &dmsg, sizeof(dmsg));
}
@


1.49
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.48 2016/09/02 14:06:35 benno Exp $ */
d263 1
a263 1
	int			 n, stub_changed, shut = 0;
d296 3
d302 7
a308 2
			if ((iface->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(iface->linkstate)) {
@


1.48
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.47 2015/12/05 13:12:41 claudio Exp $ */
d46 1
a46 1
void		 ospfe_shutdown(void);
d198 1
a198 1
void
d204 8
a226 2
	msgbuf_write(&iev_rde->ibuf.w);
	msgbuf_clear(&iev_rde->ibuf.w);
a227 2
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
@


1.47
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.46 2015/09/27 17:31:50 stsp Exp $ */
d123 1
@


1.46
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.45 2015/02/10 05:39:10 claudio Exp $ */
d262 1
a262 1
		if ((n = imsg_read(ibuf)) == -1)
d276 1
a276 1
			fatal("ospfe_dispatch_main: imsg_read error");
d444 1
a444 1
		if ((n = imsg_read(ibuf)) == -1)
d458 1
a458 1
			fatal("ospfe_dispatch_rde: imsg_read error");
@


1.45
log
@Same session_socket_blockmode() changes as done to ospfd. Also do the same
kroute change (make socket non-blocking and add trigger for partial reads).
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.44 2014/11/18 20:54:28 krw Exp $ */
d291 1
a291 1
			if_update(iface, ifp->mtu, ifp->flags, ifp->media_type,
@


1.44
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.43 2014/07/12 20:16:38 krw Exp $ */
d96 2
a97 2
	if ((xconf->ospf_socket = socket(AF_INET6, SOCK_RAW,
	    IPPROTO_OSPF)) == -1)
@


1.43
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.42 2013/11/13 20:49:49 benno Exp $ */
a36 1
#include <stdlib.h>
@


1.42
log
@handle msgbuf_write() returning EAGAIN,
taken from claudios previous fix to ospfd.

"do it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.41 2013/03/25 14:29:35 markus Exp $ */
d269 1
a269 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d271 2
d451 1
a451 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d453 2
@


1.41
log
@sync w/ospfd: improve snapshot handling; ok claudio, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.40 2013/03/22 14:25:31 sthen Exp $ */
d269 1
a269 1
		if (msgbuf_write(&ibuf->w) == -1)
d449 1
a449 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.40
log
@Allow use of an alternative control socket, ported from ospfd. ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.39 2013/03/22 12:14:42 sthen Exp $ */
d487 2
d500 4
d593 1
d595 1
a595 1
			 * IMSG_LS_UPD is used in three cases:
d599 2
a600 1
			 * 3. in EXSTART when the LSA has age MaxAge
d612 4
@


1.39
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.38 2012/09/17 13:49:27 bluhm Exp $ */
d93 1
a93 1
	if (control_init() == -1)
@


1.38
log
@Fix trailing whitespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.37 2011/07/07 17:10:48 claudio Exp $ */
d925 1
a925 1
	 * area is the tranist area for this link. */
@


1.37
log
@Rework the distribution of link state and iface FSM state changes.
Link state changes are sent from the parent to both childs and
iface FSM state changes are sent from the ospfe to the rde.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.36 2011/07/07 04:13:23 claudio Exp $ */
d292 1
a292 1
			    
@


1.36
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.35 2011/07/07 00:36:13 claudio Exp $ */
a288 2
			iface->flags = ifp->flags;
			iface->linkstate = ifp->linkstate;
d290 3
@


1.35
log
@Kill nh_reachable. Link state checking is so easy now that it does not
matter anymore to cache this value for ospf6d.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.34 2011/05/02 09:24:00 claudio Exp $ */
d519 7
a525 7
				    if (area->stub)
					    continue;
				    LIST_FOREACH(iface, &area->iface_list,
					entry) {
					    noack += lsa_flood(iface, nbr,
						&lsa_hdr, imsg.data);
				    }
@


1.34
log
@Some cleanup, some KNF and sync non functional differences with
ospfd's version.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.33 2010/08/22 20:27:52 bluhm Exp $ */
a290 1
			iface->nh_reachable = ifp->nh_reachable;
d292 2
a293 1
			if (iface->nh_reachable) {
@


1.33
log
@Origin network-LSA with options based on the options of the link-LSAs.
Without this fix Cisco's OSPF 6 ignores our network-LSAs.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.32 2010/07/06 13:15:32 bluhm Exp $ */
d181 1
a181 1
	if ((pkt_ptr = calloc(1, IBUF_READ_SIZE)) == NULL)
d807 1
a807 1
					fatalx("orig_rtr_lsa: buf_add failed");
d834 1
a834 1
						    "buf_add failed");
d858 1
a858 1
					fatalx("orig_rtr_lsa: buf_add failed");
d872 1
a872 1
				fatalx("orig_rtr_lsa: buf_add failed");
d894 1
a894 1
						    "buf_add failed");
d988 1
a988 1
		/* non transit net therefor no need to generate a net lsa */
d1146 2
a1147 2
				    IMSG_CTL_SHOW_INTERFACE,
				    0, 0, -1, ictl, sizeof(struct ctl_iface));
d1184 1
a1184 1
	sizeof(dmsg.demote_group));
d1208 3
@


1.32
log
@Use the static variable narea only where needed for config reload.
The other imessages use the stack variables area and iface.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.31 2010/07/01 19:47:04 bluhm Exp $ */
d427 1
d529 12
d983 1
a983 1
			lsa_net.opts |= nbr->options;
@


1.31
log
@Fix all white space bugs in ospf6d at once.  No binary change.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.30 2010/07/01 18:57:21 bluhm Exp $ */
d252 2
a253 1
	static struct iface	*niface;
d256 5
a260 6
	struct imsg	 imsg;
	struct imsgev	*iev = bula;
	struct imsgbuf	*ibuf = &iev->ibuf;
	struct iface	*iface, *ifp;
	int		 n, stub_changed, shut = 0;
	unsigned int	 ifindex;
d302 1
a302 1
			if ((niface = malloc(sizeof(struct iface))) == NULL)
d304 1
a304 1
			memcpy(niface, imsg.data, sizeof(struct iface));
d306 3
a308 3
			LIST_INIT(&niface->nbr_list);
			TAILQ_INIT(&niface->ls_ack_list);
			RB_INIT(&niface->lsa_tree);
d310 2
a311 2
			narea = area_find(oeconf, niface->area_id);
			LIST_INSERT_HEAD(&narea->iface_list, niface, entry);
@


1.30
log
@The prefixes of interface addresses of an ospf link have to be
advertised as link-lsa and intra-area-prefix-lsa when they change
dynamically.  Handle RTM_NEWADDR and RTM_DELADDR in kroute by sending
an imsg to ospfe.  Upon this event, originate a new link-lsa in
ospfe.  In rde a new intra-area-prefix-lsa is generated when a
link-lsa appears or goes away.
ok claudio@@; ok and test stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.29 2010/05/26 13:56:08 nicm Exp $ */
d1013 1
a1013 1
	struct lsa_link	 	 lsa_link;
d1049 1
a1049 1
	
@


1.29
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.28 2009/06/06 09:02:46 eric Exp $ */
d253 2
d325 44
@


1.28
log
@make ospf6ctl/ospf6d imsg-in-a-lib ready too.

ospf6ctl is already broken in tree (not connected to build).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.27 2009/05/31 20:29:56 jacekm Exp $ */
d181 1
a181 1
	if ((pkt_ptr = calloc(1, READ_BUF_SIZE)) == NULL)
d707 1
a707 1
	struct buf		*buf;
d715 2
a716 2
	/* XXX READ_BUF_SIZE */
	if ((buf = buf_dynamic(sizeof(lsa_hdr), READ_BUF_SIZE)) == NULL)
d720 2
a721 2
	if (buf_reserve(buf, sizeof(lsa_hdr)) == NULL)
		fatal("orig_rtr_lsa: buf_reserve failed");
d723 2
a724 2
	if (buf_reserve(buf, sizeof(lsa_rtr)) == NULL)
		fatal("orig_rtr_lsa: buf_reserve failed");
d747 1
a747 1
				if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
d772 1
a772 1
					if (buf_add(buf, &rtr_link,
d798 1
a798 1
				if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
d812 1
a812 1
			if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
d832 1
a832 1
					if (buf_add(buf, &rtr_link,
d872 1
a872 1
	memcpy(buf_seek(buf, sizeof(lsa_hdr), sizeof(lsa_rtr)),
d884 1
a884 1
	memcpy(buf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));
d887 1
a887 1
	memcpy(buf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
d897 1
a897 1
	buf_free(buf);
d905 1
a905 1
	struct buf		*buf;
d910 2
a911 2
	/* XXX READ_BUF_SIZE */
	if ((buf = buf_dynamic(sizeof(lsa_hdr), READ_BUF_SIZE)) == NULL)
d915 2
a916 2
	if (buf_reserve(buf, sizeof(lsa_hdr) + sizeof(lsa_net)) == NULL)
		fatal("orig_net_lsa: buf_reserve failed");
d922 2
a923 2
			if (buf_add(buf, &nbr->id, sizeof(nbr->id)))
				fatal("orig_net_lsa: buf_add failed");
d930 1
a930 1
		buf_free(buf);
d947 1
a947 1
	memcpy(buf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));
d950 1
a950 1
	memcpy(buf_seek(buf, sizeof(lsa_hdr), sizeof(lsa_net)), &lsa_net,
d954 1
a954 1
	memcpy(buf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
d960 1
a960 1
	buf_free(buf);
d969 1
a969 1
	struct buf		*buf;
d995 3
a997 3
	/* XXX READ_BUF_SIZE */
	if ((buf = buf_dynamic(sizeof(lsa_hdr) + sizeof(lsa_link),
	    READ_BUF_SIZE)) == NULL)
d1001 2
a1002 2
	if (buf_reserve(buf, sizeof(lsa_hdr) + sizeof(lsa_link)) == NULL)
		fatal("orig_link_lsa: buf_reserve failed");
d1018 3
a1020 3
		if (buf_add(buf, &lsa_prefix, sizeof(lsa_prefix)))
			fatal("orig_link_lsa: buf_add failed");
		if (buf_add(buf, &prefix.s6_addr[0],
d1022 1
a1022 1
			fatal("orig_link_lsa: buf_add failed");
d1032 1
a1032 1
	memcpy(buf_seek(buf, sizeof(lsa_hdr), sizeof(lsa_link)),
d1044 1
a1044 1
	memcpy(buf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));
d1047 1
a1047 1
	memcpy(buf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
d1053 1
a1053 1
	buf_free(buf);
@


1.27
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.26 2009/05/31 17:00:40 claudio Exp $ */
d53 2
a54 2
struct imsgbuf		*ibuf_main;
struct imsgbuf		*ibuf_rde;
d148 2
a149 2
	if ((ibuf_rde = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d151 4
a154 2
	imsg_init(ibuf_rde, pipe_ospfe2rde[0], ospfe_dispatch_rde);
	imsg_init(ibuf_main, pipe_parent2ospfe[1], ospfe_dispatch_main);
d157 9
a165 9
	ibuf_rde->events = EV_READ;
	event_set(&ibuf_rde->ev, ibuf_rde->fd, ibuf_rde->events,
	    ibuf_rde->handler, ibuf_rde);
	event_add(&ibuf_rde->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d219 6
a224 6
	msgbuf_write(&ibuf_rde->w);
	msgbuf_clear(&ibuf_rde->w);
	free(ibuf_rde);
	msgbuf_write(&ibuf_main->w);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
d236 1
a236 1
	return (imsg_compose(ibuf_main, type, 0, pid, data, datalen));
d243 2
a244 1
	return (imsg_compose(ibuf_rde, type, peerid, pid, data, datalen));
d254 2
a255 1
	struct imsgbuf  *ibuf = bula;
d368 1
a368 1
		imsg_event_add(ibuf);
d371 1
a371 1
		event_del(&ibuf->ev);
d381 2
a382 1
	struct imsgbuf		*ibuf = bula;
d644 1
a644 1
		imsg_event_add(ibuf);
d647 1
a647 1
		event_del(&ibuf->ev);
d891 2
a892 2
		imsg_compose(ibuf_rde, IMSG_LS_UPD, self->peerid, 0,
		    buf->buf, buf->wpos);
d957 2
a958 2
	imsg_compose(ibuf_rde, IMSG_LS_UPD, iface->self->peerid, 0,
	    buf->buf, buf->wpos);
d1050 2
a1051 2
	imsg_compose(ibuf_rde, IMSG_LS_UPD, iface->self->peerid, 0,
	    buf->buf, buf->wpos);
d1086 3
a1088 2
				imsg_compose(&c->ibuf, IMSG_CTL_SHOW_INTERFACE,
				    0, 0, ictl, sizeof(struct ctl_iface));
d1105 2
a1106 2
					imsg_compose(&c->ibuf,
					    IMSG_CTL_SHOW_NBR, 0, 0, nctl,
d1111 1
a1111 1
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, NULL, 0);
@


1.26
log
@libevent handler fix to allow EV_READ and EV_WRITE to be set at the same
time in the callback. Same diff that went into ospfd applied with some
fuzz.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.25 2009/03/29 19:02:58 stsp Exp $ */
a264 1
		imsg_event_add(ibuf);
a397 1
		imsg_event_add(ibuf);
@


1.25
log
@Now that struct lsa_net represents just the options, orig_net_lsa()
can make use of it much better. No functional change.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.24 2009/02/19 22:08:14 stsp Exp $ */
d256 1
a256 2
	switch (event) {
	case EV_READ:
d261 2
a262 2
		break;
	case EV_WRITE:
a265 3
		return;
	default:
		fatalx("unknown event");
d390 1
a390 2
	switch (event) {
	case EV_READ:
d395 2
a396 2
		break;
	case EV_WRITE:
a399 3
		return;
	default:
		fatalx("unknown event");
@


1.24
log
@Remove origination of Intra-Area-Prefix LSAs from ospfe.
Will soon be done in rde instead.

"Sure but don't wait too long before readding the code in rde" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.23 2009/02/10 17:32:58 stsp Exp $ */
d911 1
a912 1
	u_int32_t		 opts;
d920 1
a920 1
	if (buf_reserve(buf, sizeof(lsa_hdr) + sizeof(opts)) == NULL)
d923 1
a923 1
	opts = 0;
d929 1
a929 1
			opts |= nbr->options;
d954 3
a956 3
	opts &= opts & htonl(LSA_24_MASK);
	memcpy(buf_seek(buf, sizeof(lsa_hdr), sizeof(opts)), &opts,
	    sizeof(opts));
@


1.23
log
@Fix two obvious copy-paste errors in fatal error messages. We were
printing IFINFO while we are actually handling an IFDELETE imsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.22 2009/02/03 14:12:22 stsp Exp $ */
a298 1
			orig_intra_lsa_rtr(iface);
a310 1
			orig_intra_lsa_rtr(niface);
a322 1
			orig_intra_lsa_rtr(iface);
a1056 100

	buf_free(buf);
}

void
orig_intra_lsa_rtr(struct iface *iface_arg)
{
	struct lsa_hdr		 lsa_hdr;
	struct lsa_intra_prefix	 lsa_intra;
	struct lsa_prefix	 lsa_prefix;
	struct in6_addr		 prefix;
	struct buf		*buf;
	struct area		*area;
	struct iface		*iface;
	struct iface_addr	*ia;
	struct nbr		*self;
	u_int16_t		 numprefix;
	u_int16_t		 chksum;

	/* XXX READ_BUF_SIZE */
	if ((buf = buf_dynamic(sizeof(lsa_hdr) + sizeof(lsa_intra),
	    READ_BUF_SIZE)) == NULL)
		fatal("orig_intra_lsa_rtr");

	/* reserve space for LSA header and Intra-Area-Prefix LSA header */
	if (buf_reserve(buf, sizeof(lsa_hdr) + sizeof(lsa_intra)) == NULL)
		fatal("orig_intra_lsa_rtr: buf_reserve failed");

	lsa_intra.ref_type = htons(LSA_TYPE_ROUTER);
	lsa_intra.ref_lsid = 0;
	lsa_intra.ref_adv_rtr = oeconf->rtr_id.s_addr;

	numprefix = 0;
	self = NULL;

	if ((area = area_find(oeconf, iface_arg->area_id)) == NULL)
		fatalx("interface lost area");

	log_debug("orig_intra_lsa_rtr: area %s", inet_ntoa(area->id));

	LIST_FOREACH(iface, &area->iface_list, entry) {
		if (self == NULL && iface->self != NULL)
			self = iface->self;

		if (iface->state & IF_STA_DOWN)
			continue;

		TAILQ_FOREACH(ia, &iface->ifa_list, entry) {
			if (IN6_IS_ADDR_LINKLOCAL(&ia->addr))
				continue;

			bzero(&lsa_prefix, sizeof(lsa_prefix));

			if (iface->type == IF_TYPE_POINTOMULTIPOINT ||
			    iface->state == IF_STA_LOOPBACK) {
				lsa_prefix.prefixlen = 128;
			} else {
				lsa_prefix.prefixlen = ia->prefixlen;
				lsa_prefix.metric = htons(iface->metric);
			}

			if (lsa_prefix.prefixlen == 128)
				lsa_prefix.options = OSPF_PREFIX_LA;

			inet6applymask(&prefix, &ia->addr, lsa_prefix.prefixlen);
			log_debug("orig_intra_lsa_rtr: prefix %s, interface %s",
			    log_in6addr(&prefix), iface->name);
			if (buf_add(buf, &lsa_prefix, sizeof(lsa_prefix)))
				fatal("orig_intra_lsa_rtr: buf_add failed");
			if (buf_add(buf, &prefix.s6_addr[0],
			    LSA_PREFIXSIZE(lsa_prefix.prefixlen)))
				fatal("orig_intra_lsa_rtr: buf_add failed");
			numprefix++;
		}

		/* TOD: Add prefixes of directly attached hosts, too */
		/* TOD: Add prefixes for virtual links */
	}

	lsa_intra.numprefix = htons(numprefix);
	memcpy(buf_seek(buf, sizeof(lsa_hdr), sizeof(lsa_intra)),
	    &lsa_intra, sizeof(lsa_intra));

	/* LSA header */
	lsa_hdr.age = htons(DEFAULT_AGE);
	lsa_hdr.type = htons(LSA_TYPE_INTRA_A_PREFIX);
	lsa_hdr.ls_id = htonl(1); /* TODO: fragmentation */
	lsa_hdr.adv_rtr = oeconf->rtr_id.s_addr;
	lsa_hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa_hdr.len = htons(buf->wpos);
	lsa_hdr.ls_chksum = 0;		/* updated later */
	memcpy(buf_seek(buf, 0, sizeof(lsa_hdr)), &lsa_hdr, sizeof(lsa_hdr));

	chksum = htons(iso_cksum(buf->buf, buf->wpos, LS_CKSUM_OFFSET));
	memcpy(buf_seek(buf, LS_CKSUM_OFFSET, sizeof(chksum)),
	    &chksum, sizeof(chksum));

	if (self)
		imsg_compose(ibuf_rde, IMSG_LS_UPD, self->peerid, 0,
		    buf->buf, buf->wpos);
@


1.22
log
@In Intra-Area-Prefix LSAs, set the LA-bit for all prefixes of 128-bit
length, regardless of interface type.
Allowed by RFC5340 and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.21 2009/02/03 14:02:01 stsp Exp $ */
d317 1
a317 1
				fatalx("IFINFO imsg with wrong len");
@


1.21
log
@Formatting fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.20 2009/01/29 20:15:50 stsp Exp $ */
a1115 1
				lsa_prefix.options = OSPF_PREFIX_LA;
d1120 3
@


1.20
log
@Correctly byte-swap the link state ID when building Intra-Area-Prefix
LSAs which refer to Router LSAs.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.19 2009/01/29 19:07:53 stsp Exp $ */
d1113 2
a1114 2
			if (iface->type == IF_TYPE_POINTOMULTIPOINT
			    || iface->state == IF_STA_LOOPBACK) {
@


1.19
log
@Originate Intra-Area-Prefix LSAs which reference a router LSA.
Routers can now advertise prefixes with global scope throughout
an area. This paves the way towards doing SPF calculations to
generate routing tables for a single area.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.18 2009/01/28 22:47:36 stsp Exp $ */
d1144 1
a1144 1
	lsa_hdr.ls_id = 1; /* TODO: fragmentation */
@


1.18
log
@Teach ospf6d to originate Intra-Area-Prefix LSAs, which associate a list
of IPv6 prefixes with a Network LSA (there's another type of this LSA which
associates prefixes with a Router LSA -- this remains to be done).
Add what is necessary to allow ospf6ctl to read the new LSA type via IMSG.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.17 2009/01/03 00:18:51 stsp Exp $ */
d299 1
d312 1
d325 1
d1028 2
a1029 1
		if (buf_add(buf, &prefix, LSA_PREFIXSIZE(ia->prefixlen)))
d1060 98
@


1.17
log
@orig_link_lsa() was assuming either virtual or broadcast link.
Make it handle other types of links, too.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.16 2009/01/02 21:05:26 stsp Exp $ */
d632 1
@


1.16
log
@Add support for originating router LSAs over point-to-point links.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.15 2008/12/30 22:51:52 claudio Exp $ */
d982 2
a983 4
	if (iface->type == IF_TYPE_VIRTUALLINK)
		return;
	
	if ((iface->state & IF_STA_MULTI) == 0)
d985 13
@


1.15
log
@Remove debug message that does not help. The problem with the initial flood
of the Link LSA is still not solved though.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.14 2008/12/30 22:29:54 claudio Exp $ */
a737 1
#if 0 /* TODO pointtopoint */
d743 1
a743 1
			if (nbr) {
a745 2
				rtr_link.id = nbr->id.s_addr;
//XXX				rtr_link.data = iface->addr.s_addr;
a746 21
				/* RFC 3137: stub router support */
				if (oeconf->flags & OSPFD_FLAG_STUB_ROUTER ||
				    oe_nofib)
					rtr_link.metric = 0xffff;
				else
					rtr_link.metric = htons(iface->metric);
				if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
					fatalx("orig_rtr_lsa: buf_add failed");
			}
			if (iface->state & IF_STA_POINTTOPOINT) {
				log_debug("orig_rtr_lsa: stub net, "
				    "interface %s", iface->name);
				bzero(&rtr_link, sizeof(rtr_link));
				if (nbr) {
//XXX					rtr_link.id = nbr->addr.s_addr;
					rtr_link.data = 0xffffffff;
				} else {
//XXX					rtr_link.id = iface->addr.s_addr;
//XXX					rtr_link.data = iface->mask.s_addr;
				}
				rtr_link.type = LINK_TYPE_STUB_NET;
d748 3
a754 1
#endif /* pointtopoint */
@


1.14
log
@Correctly encode the IPv6 prefix. Only (prefixlen + 31)/32 * 4 bytes are
attached to the LSA (saves 8 to 12 bytes per prefix and makes our life
more interesting or complex).
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.13 2008/12/30 21:44:18 claudio Exp $ */
a488 1
				log_debug("flooding link LSA");
@


1.13
log
@Correctly compute the options for the net LSA as pre RFC options is set to
the or-ed result of all active neighbors. freaky...
Discussed with stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.12 2008/12/30 21:31:54 claudio Exp $ */
a1032 1
		lsa_prefix.prefix = prefix;
d1035 2
@


1.12
log
@First try at originating Link (type-8) LSA. Code is wrong and the initial
LSA is lost in lsa_flood. Put this in because it goes in the right direction
and ospf6d is work in progress. Add necessary framework so that we can print
Link LSA in ospf6ctl.
Diff mostly from stsp@@ ospf6ctl part by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.11 2008/12/28 21:22:14 claudio Exp $ */
a930 1
	struct area		*area;
d941 2
a942 2
	/* reserve space for LSA header and LSA Router header */
	if (buf_reserve(buf, sizeof(lsa_hdr)) == NULL)
a944 1
	/* LSA options and then a list of all fully adjacent routers */
a945 7
	if ((area = area_find(oeconf, iface->area_id)) == NULL)
		fatalx("interface lost area");
	LSA_24_SETLO(opts, area_ospf_options(area));
	opts = htonl(opts);
	if (buf_add(buf, &opts, sizeof(opts)))
		fatal("orig_net_lsa: buf_add failed");

d951 1
d975 4
@


1.11
log
@Initial bits for originating net lsa again from Stefan Sperling with some
changes by myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.10 2008/12/28 20:08:31 claudio Exp $ */
d471 1
a471 1
			if (lsa_hdr.type == LSA_TYPE_EXTERNAL) {
d485 7
d630 1
d977 80
@


1.10
log
@area_ospf_options() should not return network byte order options. Instead
the callers should take care of getting the byte order right. While there
remove the opts[123] from the hello_hdr and use LSA_24_* to handle this
nasty fields instead. Now router LSA have the correct flags set.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.9 2008/12/28 19:36:44 claudio Exp $ */
a921 1
#if 0	/* XXX needs work */
d923 1
d927 1
d938 7
a944 2
	/* LSA net mask and then all fully adjacent routers */
	if (buf_add(buf, &iface->mask, sizeof(iface->mask)))
d967 3
a969 2
	lsa_hdr.type = LSA_TYPE_NETWORK;
//XXX	lsa_hdr.ls_id = iface->addr.s_addr;
a983 1
#endif
@


1.9
log
@First shot at originating router LSA, still a lot of XXX but seems to
work for IF_TYPE_BROADCAST networks.
Initial diff by Stefan Sperling, some additional work by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.8 2007/12/13 08:54:05 claudio Exp $ */
d890 1
@


1.8
log
@Monster commit of stuff I did mostly last month. What it does:
 * removes kif and uses iface for everything interface related.
   This removes unneeded data redundancy which makes the code more complex.
 * adds the link local prefix to struct iface and attaches a list with
   the other prefixes to the struct iface. This is needed to generate the
   link LSA.
 * disconnects struct iface from struct area (the backpointer is gone)
   this will make the reload code a bit easier.
norby@@ agrees with the direction we're heading with this
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.7 2007/11/27 12:23:06 claudio Exp $ */
a699 1
#if 0 /* XXX needs work */
d706 1
a706 1
	u_int16_t		 num_links = 0;
a729 11
		if (iface->state & IF_STA_LOOPBACK) {
//XXX			rtr_link.id = iface->addr.s_addr;
			rtr_link.data = 0xffffffff;
			rtr_link.type = LINK_TYPE_STUB_NET;
			rtr_link.metric = htons(iface->metric);
			num_links++;
			if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
				fatalx("orig_rtr_lsa: buf_add failed");
			continue;
		}

d731 1
a748 1
				num_links++;
a764 1
				num_links++;
d769 1
a785 2
//XXX					rtr_link.id = iface->dr->addr.s_addr;
//XXX					rtr_link.data = iface->addr.s_addr;
d787 8
a797 15

			if ((iface->flags & IFF_UP) == 0 ||
			    iface->linkstate == LINK_STATE_DOWN ||
			    (!LINK_STATE_IS_UP(iface->linkstate) &&
			    iface->media_type == IFT_CARP))
				continue;

			log_debug("orig_rtr_lsa: stub net, "
			    "interface %s", iface->name);

/*XXX			rtr_link.id =
			    iface->addr.s_addr & iface->mask.s_addr;
			rtr_link.data = iface->mask.s_addr;
XXX*/
			rtr_link.type = LINK_TYPE_STUB_NET;
d799 1
a815 1
				num_links++;
a830 1
			num_links++;
a850 1
					num_links++;
d858 1
a861 11

		rtr_link.num_tos = 0;
		/* RFC 3137: stub router support */
		if ((oeconf->flags & OSPFD_FLAG_STUB_ROUTER || oe_nofib) &&
		    rtr_link.type != LINK_TYPE_STUB_NET)
			rtr_link.metric = 0xffff;
		else
			rtr_link.metric = htons(iface->metric);
		num_links++;
		if (buf_add(buf, &rtr_link, sizeof(rtr_link)))
			fatalx("orig_rtr_lsa: buf_add failed");
d865 3
a867 1
	lsa_rtr.flags = 0;
d873 1
a873 1
		lsa_rtr.flags |= OSPF_RTR_E;
d882 1
a882 1
		lsa_rtr.flags |= OSPF_RTR_B;
d886 1
a886 1
		lsa_rtr.flags |= OSPF_RTR_V;
d888 2
a889 2
	lsa_rtr.dummy = 0;
	lsa_rtr.nlinks = htons(num_links);
d895 3
a897 2
	lsa_hdr.type = LSA_TYPE_ROUTER;
	lsa_hdr.ls_id = oeconf->rtr_id.s_addr;
a915 1
#endif
@


1.7
log
@Make lsa_find() find link local LSA by passing the interface instead of the
area as lookup point. Additionally make lsa_dump or actually the code around
it pass all LSA to ospf6ctl. The rde_spf.c are not final.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.6 2007/11/27 11:29:34 claudio Exp $ */
d49 1
d185 2
a186 7
		LIST_FOREACH(iface, &area->iface_list, entry) {
			if_init(xconf, iface);
			if (if_fsm(iface, IF_EVT_UP)) {
				log_debug("error starting interface %s",
				    iface->name);
			}
		}
d252 3
a254 4
	struct area	*area = NULL;
	struct iface	*iface = NULL;
	struct kif	*kif;
	int		 n, link_ok, stub_changed, shut = 0;
d281 1
a281 1
			    sizeof(struct kif))
d283 1
a283 5
			kif = imsg.data;
			link_ok = (kif->flags & IFF_UP) &&
			    (LINK_STATE_IS_UP(kif->link_state) ||
			    (kif->link_state == LINK_STATE_UNKNOWN &&
			    kif->media_type != IFT_CARP));
d285 13
a297 23
			LIST_FOREACH(area, &oeconf->area_list, entry) {
				LIST_FOREACH(iface, &area->iface_list, entry) {
					if (kif->ifindex == iface->ifindex &&
					    iface->type !=
					    IF_TYPE_VIRTUALLINK) {
						iface->flags = kif->flags;
						iface->linkstate =
						    kif->link_state;

						if (link_ok) {
							if_fsm(iface,
							    IF_EVT_UP);
							log_warnx("interface %s"
							    " up", iface->name);
						} else {
							if_fsm(iface,
							    IF_EVT_DOWN);
							log_warnx("interface %s"
							    " down",
							    iface->name);
						}
					}
				}
d300 25
a344 12
		case IMSG_RECONF_IFACE:
			if ((niface = malloc(sizeof(struct iface))) == NULL)
				fatal(NULL);
			memcpy(niface, imsg.data, sizeof(struct iface));

			LIST_INIT(&niface->nbr_list);
			TAILQ_INIT(&niface->ls_ack_list);
			RB_INIT(&niface->lsa_tree);

			niface->area = narea;
			LIST_INSERT_HEAD(&narea->iface_list, niface, entry);
			break;
a357 1
		case IMSG_CTL_IFINFO:
d490 3
a492 1
				area = nbr->iface->area;
d660 1
a660 1
			    iface->area->id.s_addr == ar->area.s_addr) {
d684 11
a694 1
			orig_rtr_lsa(a);
d698 1
a698 1
orig_rtr_lsa(struct area *area)
@


1.6
log
@Monster diff to bring us a bit on track again.
a) implement all (or at least most) lsa_check() cases.
b) classify the LSA scope correctly and add a per interface lsa_tree for
   the link local stuff.
c) implement a function to parse a prefix.

There is still a lot missing currently link local LSA are added to the
interface tree but nothing can access them (lsa_find() and a few friends
need some changes).
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.5 2007/10/13 13:21:56 claudio Exp $ */
d624 1
@


1.5
log
@From ospfd: Funny typo, it is fib not fip so adjust function name.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.4 2007/10/11 20:01:38 claudio Exp $ */
d346 1
@


1.4
log
@Disable some code that is currently far from working and results in frequent
session resets because of bad packets. With this it seems we survive the
hello and database exchange phases. A closer look at the DR and BDR calculation
is still needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.3 2007/10/11 19:02:47 claudio Exp $ */
d1010 1
a1010 1
ospfe_fip_update(int type)
@


1.3
log
@From ospfd:
Bye bye global ospf options. OSPF options are per area (at least the one
flag that we set). So introduce a area_ospf_options() function that will
return the correct flags for each area. This makes stub area support a lot
easier.
Don't check for OSPF_OPTION_E in the parent. OSPF_OPTION_E is per area and
so the parent process has no way to know if it should redistribute or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.2 2007/10/09 06:17:40 claudio Exp $ */
d693 1
d939 1
d945 1
d1000 1
@


1.2
log
@Instead of IP_RECVIF we use IPV6_RECVPKTINFO to get the ifindex and the
destination address of incomming packets. This also removes the need for
IP_HDRINCL. Additionally use IPV6_CHECKSUM to let the kernel do the
necessary packet checksumming, way easier than doing it in userland.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.1 2007/10/08 10:44:50 norby Exp $ */
d895 1
a895 1
	if (oeconf->redistribute && (oeconf->options & OSPF_OPTION_E))
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfe.c,v 1.57 2007/07/25 19:11:27 claudio Exp $ */
d103 4
a106 4
	if (if_set_ip_hdrincl(xconf->ospf_socket) == -1)
		fatal("if_set_ip_hdrincl");
	if (if_set_recvif(xconf->ospf_socket, 1) == -1)
		fatal("if_set_recvif");
a185 1
			log_debug("fire up the barbeque on %s", iface->name);
@

