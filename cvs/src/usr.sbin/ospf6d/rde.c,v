head	1.72;
access;
symbols
	OPENBSD_6_2:1.72.0.2
	OPENBSD_6_2_BASE:1.72
	OPENBSD_6_1:1.69.0.4
	OPENBSD_6_1_BASE:1.69
	OPENBSD_6_0:1.66.0.2
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.63.0.6
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.60.0.4
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.60.0.2
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.59.0.4
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.2
	OPENBSD_5_0:1.58.0.2
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.31.0.4
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11;
locks; strict;
comment	@ * @;


1.72
date	2017.08.12.16.27.50;	author benno;	state Exp;
branches;
next	1.71;
commitid	j2LQSmU2VhBZ75Yh;

1.71
date	2017.06.19.19.55.57;	author friehm;	state Exp;
branches;
next	1.70;
commitid	qQdgRe10zVbyVHr2;

1.70
date	2017.05.30.12.42.31;	author friehm;	state Exp;
branches;
next	1.69;
commitid	aUDKS9b7zHFzXmWv;

1.69
date	2016.12.27.17.18.56;	author jca;	state Exp;
branches;
next	1.68;
commitid	04ojC2souZ1MiFQA;

1.68
date	2016.09.03.10.25.36;	author renato;	state Exp;
branches;
next	1.67;
commitid	2D672KsaUkm6FxSg;

1.67
date	2016.09.02.14.06.35;	author benno;	state Exp;
branches;
next	1.66;
commitid	Z2jEGSLNZuIKq53q;

1.66
date	2016.06.06.15.57.44;	author benno;	state Exp;
branches;
next	1.65;
commitid	MyGYfH4IW1erkjil;

1.65
date	2015.12.05.13.12.41;	author claudio;	state Exp;
branches;
next	1.64;
commitid	4xNKczBxYPO9zMjt;

1.64
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.63;
commitid	kLBPo9HaQrkEaNW3;

1.63
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	Uu5nFG3wCl0LACBb;

1.62
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.61;
commitid	lIxCxHhVEpsmXOdi;

1.61
date	2013.11.13.20.49.49;	author benno;	state Exp;
branches;
next	1.60;

1.60
date	2012.09.17.13.49.27;	author bluhm;	state Exp;
branches;
next	1.59;

1.59
date	2011.11.06.10.29.05;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.07.17.10.48;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.07.04.37.56;	author claudio;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.07.04.35.47;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.07.00.36.13;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.04.04.08.34;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2011.05.05.15.58.02;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2011.05.02.06.34.29;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2010.08.22.20.55.10;	author bluhm;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.09.12.39.46;	author bluhm;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.06.13.24.35;	author bluhm;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.06.13.15.33;	author bluhm;	state Exp;
branches;
next	1.46;

1.46
date	2010.07.05.22.59.51;	author bluhm;	state Exp;
branches;
next	1.45;

1.45
date	2010.07.01.21.19.57;	author bluhm;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.01.19.47.04;	author bluhm;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.01.18.57.21;	author bluhm;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.28.15.05.01;	author bluhm;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.12.10.06.50;	author bluhm;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.01.11.29.29;	author bluhm;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.01.11.22.28;	author bluhm;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.16.11.36.10;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2010.03.01.08.58.48;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.24.12.21.05;	author stsp;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.22.19.32.36;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2009.11.02.20.24.58;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.28.19.16.34;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.28.19.14.25;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.06.09.02.46;	author eric;	state Exp;
branches;
next	1.30;

1.30
date	2009.05.31.20.29.56;	author jacekm;	state Exp;
branches;
next	1.29;

1.29
date	2009.05.31.17.00.40;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2009.04.09.19.00.40;	author stsp;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.29.21.42.30;	author stsp;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.12.01.21.49;	author stsp;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.07.00.33.13;	author stsp;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.19.22.21.17;	author stsp;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.19.22.19.53;	author stsp;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.19.22.17.07;	author stsp;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.19.22.05.32;	author stsp;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.10.17.32.58;	author stsp;	state Exp;
branches;
next	1.19;

1.19
date	2009.02.03.14.02.01;	author stsp;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.29.12.16.09;	author stsp;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.29.11.57.42;	author stsp;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.28.22.47.36;	author stsp;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.27.12.52.08;	author michele;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.03.00.23.50;	author stsp;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.30.21.31.54;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.28.18.43.53;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2008.02.11.13.48.39;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.13.08.54.05;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.27.12.23.06;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.27.11.29.34;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.17.07.16.02;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.16.20.27.24;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.16.12.05.52;	author norby;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.16.08.41.56;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.11.20.01.38;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.11.19.02.47;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.51;	author norby;	state Exp;
branches;
next	;


desc
@@


1.72
log
@bring ospf6d's log.c in sync with ospfd and bgpd
ok florian@@ claudio@@
@
text
@/*	$OpenBSD: rde.c,v 1.71 2017/06/19 19:55:57 friehm Exp $ */

/*
 * Copyright (c) 2004, 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <net/if_types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <err.h>
#include <errno.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <pwd.h>
#include <unistd.h>
#include <event.h>

#include "ospf6.h"
#include "ospf6d.h"
#include "ospfe.h"
#include "log.h"
#include "rde.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

void		 rde_sig_handler(int sig, short, void *);
__dead void	 rde_shutdown(void);
void		 rde_dispatch_imsg(int, short, void *);
void		 rde_dispatch_parent(int, short, void *);
void		 rde_dump_area(struct area *, int, pid_t);

void		 rde_send_summary(pid_t);
void		 rde_send_summary_area(struct area *, pid_t);
void		 rde_nbr_init(u_int32_t);
void		 rde_nbr_free(void);
struct rde_nbr	*rde_nbr_new(u_int32_t, struct rde_nbr *);
void		 rde_nbr_del(struct rde_nbr *);

void		 rde_req_list_add(struct rde_nbr *, struct lsa_hdr *);
int		 rde_req_list_exists(struct rde_nbr *, struct lsa_hdr *);
void		 rde_req_list_del(struct rde_nbr *, struct lsa_hdr *);
void		 rde_req_list_free(struct rde_nbr *);

struct lsa	*rde_asext_get(struct kroute *);
struct lsa	*rde_asext_put(struct kroute *);

int		 comp_asext(struct lsa *, struct lsa *);
struct lsa	*orig_asext_lsa(struct kroute *, u_int16_t);
struct lsa	*orig_sum_lsa(struct rt_node *, struct area *, u_int8_t, int);
struct lsa	*orig_intra_lsa_net(struct area *, struct iface *,
		 struct vertex *);
struct lsa	*orig_intra_lsa_rtr(struct area *, struct vertex *);
void		 append_prefix_lsa(struct lsa **, u_int16_t *,
		    struct lsa_prefix *);

/* A 32-bit value != any ifindex.
 * We assume ifindex is bound by [1, USHRT_MAX] inclusive. */
#define	LS_ID_INTRA_RTR	0x01000000

/* Tree of prefixes with global scope on given a link,
 * see orig_intra_lsa_*() */
struct prefix_node {
	RB_ENTRY(prefix_node)	 entry;
	struct lsa_prefix	*prefix;
};
RB_HEAD(prefix_tree, prefix_node);
RB_PROTOTYPE(prefix_tree, prefix_node, entry, prefix_compare);
int		 prefix_compare(struct prefix_node *, struct prefix_node *);
void		 prefix_tree_add(struct prefix_tree *, struct lsa_link *);

struct ospfd_conf	*rdeconf = NULL, *nconf = NULL;
struct imsgev		*iev_ospfe;
struct imsgev		*iev_main;
struct rde_nbr		*nbrself;
struct lsa_tree		 asext_tree;

/* ARGSUSED */
void
rde_sig_handler(int sig, short event, void *arg)
{
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */

	switch (sig) {
	case SIGINT:
	case SIGTERM:
		rde_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* route decision engine */
pid_t
rde(struct ospfd_conf *xconf, int pipe_parent2rde[2], int pipe_ospfe2rde[2],
    int pipe_parent2ospfe[2])
{
	struct event		 ev_sigint, ev_sigterm;
	struct timeval		 now;
	struct passwd		*pw;
	struct redistribute	*r;
	pid_t			 pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
		/* NOTREACHED */
	case 0:
		break;
	default:
		return (pid);
	}

	rdeconf = xconf;

	if ((pw = getpwnam(OSPF6D_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("route decision engine");
	/*
	 * XXX needed with fork+exec
	 * log_init(debug, LOG_DAEMON);
	 * log_setverbose(verbose);
	 */

	ospfd_process = PROC_RDE_ENGINE;
	log_procinit(log_procnames[ospfd_process]);

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	event_init();
	rde_nbr_init(NBR_HASHSIZE);
	lsa_init(&asext_tree);

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, rde_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, rde_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipes */
	close(pipe_ospfe2rde[0]);
	close(pipe_parent2rde[0]);
	close(pipe_parent2ospfe[0]);
	close(pipe_parent2ospfe[1]);

	if ((iev_ospfe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_ospfe->ibuf, pipe_ospfe2rde[1]);
	iev_ospfe->handler = rde_dispatch_imsg;
	imsg_init(&iev_main->ibuf, pipe_parent2rde[1]);
	iev_main->handler = rde_dispatch_parent;

	/* setup event handler */
	iev_ospfe->events = EV_READ;
	event_set(&iev_ospfe->ev, iev_ospfe->ibuf.fd, iev_ospfe->events,
	    iev_ospfe->handler, iev_ospfe);
	event_add(&iev_ospfe->ev, NULL);

	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	evtimer_set(&rdeconf->ev, spf_timer, rdeconf);
	cand_list_init();
	rt_init();

	while ((r = SIMPLEQ_FIRST(&rdeconf->redist_list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&rdeconf->redist_list, entry);
		free(r);
	}

	gettimeofday(&now, NULL);
	rdeconf->uptime = now.tv_sec;

	event_dispatch();

	rde_shutdown();
	/* NOTREACHED */

	return (0);
}

__dead void
rde_shutdown(void)
{
	struct area	*a;

	/* close pipes */
	msgbuf_clear(&iev_ospfe->ibuf.w);
	close(iev_ospfe->ibuf.fd);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	stop_spf_timer(rdeconf);
	cand_list_clr();
	rt_clear();

	while ((a = LIST_FIRST(&rdeconf->area_list)) != NULL) {
		LIST_REMOVE(a, entry);
		area_del(a);
	}
	rde_nbr_free();

	free(iev_ospfe);
	free(iev_main);
	free(rdeconf);

	log_info("route decision engine exiting");
	_exit(0);
}

int
rde_imsg_compose_ospfe(int type, u_int32_t peerid, pid_t pid, void *data,
    u_int16_t datalen)
{
	return (imsg_compose_event(iev_ospfe, type, peerid, pid, -1,
	    data, datalen));
}

/* ARGSUSED */
void
rde_dispatch_imsg(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	struct in_addr		 aid;
	struct ls_req_hdr	 req_hdr;
	struct lsa_hdr		 lsa_hdr, *db_hdr;
	struct rde_nbr		 rn, *nbr;
	struct timespec		 tp;
	struct lsa		*lsa;
	struct area		*area;
	struct vertex		*v;
	char			*buf;
	ssize_t			 n;
	time_t			 now;
	int			 r, state, self, shut = 0, verbose;
	u_int16_t		 l;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	clock_gettime(CLOCK_MONOTONIC, &tp);
	now = tp.tv_sec;

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("rde_dispatch_imsg: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_NEIGHBOR_UP:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(rn))
				fatalx("invalid size of OE request");
			memcpy(&rn, imsg.data, sizeof(rn));

			if (rde_nbr_new(imsg.hdr.peerid, &rn) == NULL)
				fatalx("rde_dispatch_imsg: "
				    "neighbor already exists");
			break;
		case IMSG_NEIGHBOR_DOWN:
			rde_nbr_del(rde_nbr_find(imsg.hdr.peerid));
			break;
		case IMSG_NEIGHBOR_CHANGE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(state))
				fatalx("invalid size of OE request");
			memcpy(&state, imsg.data, sizeof(state));

			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			if (state != nbr->state &&
			    (nbr->state & NBR_STA_FULL ||
			    state & NBR_STA_FULL)) {
				nbr->state = state;
				area_track(nbr->area, state);
				orig_intra_area_prefix_lsas(nbr->area);
			}

			nbr->state = state;
			if (nbr->state & NBR_STA_FULL)
				rde_req_list_free(nbr);
			break;
		case IMSG_DB_SNAPSHOT:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			lsa_snap(nbr, imsg.hdr.peerid);

			imsg_compose_event(iev_ospfe, IMSG_DB_END, imsg.hdr.peerid,
			    0, -1, NULL, 0);
			break;
		case IMSG_DD:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			buf = imsg.data;
			for (l = imsg.hdr.len - IMSG_HEADER_SIZE;
			    l >= sizeof(lsa_hdr); l -= sizeof(lsa_hdr)) {
				memcpy(&lsa_hdr, buf, sizeof(lsa_hdr));
				buf += sizeof(lsa_hdr);

				v = lsa_find(nbr->iface, lsa_hdr.type,
				    lsa_hdr.ls_id, lsa_hdr.adv_rtr);
				if (v == NULL)
					db_hdr = NULL;
				else
					db_hdr = &v->lsa->hdr;

				if (lsa_newer(&lsa_hdr, db_hdr) > 0) {
					/*
					 * only request LSAs that are
					 * newer or missing
					 */
					rde_req_list_add(nbr, &lsa_hdr);
					imsg_compose_event(iev_ospfe, IMSG_DD,
					    imsg.hdr.peerid, 0, -1, &lsa_hdr,
					    sizeof(lsa_hdr));
				}
			}
			if (l != 0)
				log_warnx("rde_dispatch_imsg: peerid %u, "
				    "trailing garbage in Database Description "
				    "packet", imsg.hdr.peerid);

			imsg_compose_event(iev_ospfe, IMSG_DD_END,
			    imsg.hdr.peerid, 0, -1, NULL, 0);
			break;
		case IMSG_LS_REQ:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			buf = imsg.data;
			for (l = imsg.hdr.len - IMSG_HEADER_SIZE;
			    l >= sizeof(req_hdr); l -= sizeof(req_hdr)) {
				memcpy(&req_hdr, buf, sizeof(req_hdr));
				buf += sizeof(req_hdr);

				if ((v = lsa_find(nbr->iface,
				    req_hdr.type, req_hdr.ls_id,
				    req_hdr.adv_rtr)) == NULL) {
					imsg_compose_event(iev_ospfe,
					    IMSG_LS_BADREQ, imsg.hdr.peerid,
					    0, -1, NULL, 0);
					continue;
				}
				imsg_compose_event(iev_ospfe, IMSG_LS_UPD,
				    imsg.hdr.peerid, 0, -1, v->lsa,
				    ntohs(v->lsa->hdr.len));
			}
			if (l != 0)
				log_warnx("rde_dispatch_imsg: peerid %u, "
				    "trailing garbage in LS Request "
				    "packet", imsg.hdr.peerid);
			break;
		case IMSG_LS_UPD:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			lsa = malloc(imsg.hdr.len - IMSG_HEADER_SIZE);
			if (lsa == NULL)
				fatal(NULL);
			memcpy(lsa, imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);

			if (!lsa_check(nbr, lsa,
			    imsg.hdr.len - IMSG_HEADER_SIZE)) {
				free(lsa);
				break;
			}

			v = lsa_find(nbr->iface, lsa->hdr.type, lsa->hdr.ls_id,
			    lsa->hdr.adv_rtr);
			if (v == NULL)
				db_hdr = NULL;
			else
				db_hdr = &v->lsa->hdr;

			if (nbr->self) {
				lsa_merge(nbr, lsa, v);
				/* lsa_merge frees the right lsa */
				break;
			}

			r = lsa_newer(&lsa->hdr, db_hdr);
			if (r > 0) {
				/* new LSA newer than DB */
				if (v && v->flooded &&
				    v->changed + MIN_LS_ARRIVAL >= now) {
					free(lsa);
					break;
				}

				rde_req_list_del(nbr, &lsa->hdr);

				self = lsa_self(lsa);
				if (self) {
					if (v == NULL)
						/* LSA is no longer announced,
						 * remove by premature aging. */
						lsa_flush(nbr, lsa);
					else
						lsa_reflood(v, lsa);
				} else if (lsa_add(nbr, lsa))
					/* delayed lsa, don't flood yet */
					break;

				/* flood and perhaps ack LSA */
				imsg_compose_event(iev_ospfe, IMSG_LS_FLOOD,
				    imsg.hdr.peerid, 0, -1, lsa,
				    ntohs(lsa->hdr.len));

				/* reflood self originated LSA */
				if (self && v)
					imsg_compose_event(iev_ospfe,
					    IMSG_LS_FLOOD, v->peerid, 0, -1,
					    v->lsa, ntohs(v->lsa->hdr.len));
				/* new LSA was not added so free it */
				if (self)
					free(lsa);
			} else if (r < 0) {
				/*
				 * point 6 of "The Flooding Procedure"
				 * We are violating the RFC here because
				 * it does not make sense to reset a session
				 * because an equal LSA is already in the table.
				 * Only if the LSA sent is older than the one
				 * in the table we should reset the session.
				 */
				if (rde_req_list_exists(nbr, &lsa->hdr)) {
					imsg_compose_event(iev_ospfe,
					    IMSG_LS_BADREQ, imsg.hdr.peerid,
					    0, -1, NULL, 0);
					free(lsa);
					break;
				}

				/* lsa no longer needed */
				free(lsa);

				/* new LSA older than DB */
				if (ntohl(db_hdr->seq_num) == MAX_SEQ_NUM &&
				    ntohs(db_hdr->age) == MAX_AGE)
					/* seq-num wrap */
					break;

				if (v->changed + MIN_LS_ARRIVAL >= now)
					break;

				/* directly send current LSA, no ack */
				imsg_compose_event(iev_ospfe, IMSG_LS_UPD,
				    imsg.hdr.peerid, 0, -1, v->lsa,
				    ntohs(v->lsa->hdr.len));
			} else {
				/* LSA equal send direct ack */
				imsg_compose_event(iev_ospfe, IMSG_LS_ACK,
				    imsg.hdr.peerid, 0, -1, &lsa->hdr,
				    sizeof(lsa->hdr));
				free(lsa);
			}
			break;
		case IMSG_LS_MAXAGE:
			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				break;

			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct lsa_hdr))
				fatalx("invalid size of OE request");
			memcpy(&lsa_hdr, imsg.data, sizeof(lsa_hdr));

			if (rde_nbr_loading(nbr->area))
				break;

			v = lsa_find(nbr->iface, lsa_hdr.type, lsa_hdr.ls_id,
			    lsa_hdr.adv_rtr);
			if (v == NULL)
				db_hdr = NULL;
			else
				db_hdr = &v->lsa->hdr;

			/*
			 * only delete LSA if the one in the db is not newer
			 */
			if (lsa_newer(db_hdr, &lsa_hdr) <= 0)
				lsa_del(nbr, &lsa_hdr);
			break;
		case IMSG_CTL_SHOW_DATABASE:
		case IMSG_CTL_SHOW_DB_EXT:
		case IMSG_CTL_SHOW_DB_LINK:
		case IMSG_CTL_SHOW_DB_NET:
		case IMSG_CTL_SHOW_DB_RTR:
		case IMSG_CTL_SHOW_DB_INTRA:
		case IMSG_CTL_SHOW_DB_SELF:
		case IMSG_CTL_SHOW_DB_SUM:
		case IMSG_CTL_SHOW_DB_ASBR:
			if (imsg.hdr.len != IMSG_HEADER_SIZE &&
			    imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(aid)) {
				log_warnx("rde_dispatch_imsg: wrong imsg len");
				break;
			}
			if (imsg.hdr.len == IMSG_HEADER_SIZE) {
				LIST_FOREACH(area, &rdeconf->area_list, entry) {
					rde_dump_area(area, imsg.hdr.type,
					    imsg.hdr.pid);
				}
				lsa_dump(&asext_tree, imsg.hdr.type,
				    imsg.hdr.pid);
			} else {
				memcpy(&aid, imsg.data, sizeof(aid));
				if ((area = area_find(rdeconf, aid)) != NULL) {
					rde_dump_area(area, imsg.hdr.type,
					    imsg.hdr.pid);
					if (!area->stub)
						lsa_dump(&asext_tree,
						    imsg.hdr.type,
						    imsg.hdr.pid);
				}
			}
			imsg_compose_event(iev_ospfe, IMSG_CTL_END, 0,
			    imsg.hdr.pid, -1, NULL, 0);
			break;
		case IMSG_CTL_SHOW_RIB:
			LIST_FOREACH(area, &rdeconf->area_list, entry) {
				imsg_compose_event(iev_ospfe, IMSG_CTL_AREA,
				    0, imsg.hdr.pid, -1, area, sizeof(*area));

				rt_dump(area->id, imsg.hdr.pid, RIB_RTR);
				rt_dump(area->id, imsg.hdr.pid, RIB_NET);
			}
			aid.s_addr = 0;
			rt_dump(aid, imsg.hdr.pid, RIB_EXT);

			imsg_compose_event(iev_ospfe, IMSG_CTL_END, 0,
			    imsg.hdr.pid, -1, NULL, 0);
			break;
		case IMSG_CTL_SHOW_SUM:
			rde_send_summary(imsg.hdr.pid);
			LIST_FOREACH(area, &rdeconf->area_list, entry)
				rde_send_summary_area(area, imsg.hdr.pid);
			imsg_compose_event(iev_ospfe, IMSG_CTL_END, 0,
			    imsg.hdr.pid, -1, NULL, 0);
			break;
		case IMSG_IFINFO:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(int))
				fatalx("IFINFO imsg with wrong len");

			nbr = rde_nbr_find(imsg.hdr.peerid);
			if (nbr == NULL)
				fatalx("IFINFO imsg with bad peerid");
			memcpy(&nbr->iface->state, imsg.data, sizeof(int));

			/* Resend LSAs if interface state changes. */
			orig_intra_area_prefix_lsas(nbr->area);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by ospfe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_setverbose(verbose);
			break;
		default:
			log_debug("rde_dispatch_imsg: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
void
rde_dispatch_parent(int fd, short event, void *bula)
{
	static struct area	*narea;
	struct area		*area;
	struct iface		*iface, *ifp;
	struct ifaddrchange	*ifc;
	struct iface_addr	*ia, *nia;
	struct imsg		 imsg;
	struct kroute		 kr;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct lsa		*lsa;
	struct vertex		*v;
	ssize_t			 n;
	int			 shut = 0, wasvalid;
	unsigned int		 ifindex;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("rde_dispatch_parent: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_NETWORK_ADD:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(kr)) {
				log_warnx("rde_dispatch_parent: "
				    "wrong imsg len");
				break;
			}
			memcpy(&kr, imsg.data, sizeof(kr));

			if ((lsa = rde_asext_get(&kr)) != NULL) {
				v = lsa_find(NULL, lsa->hdr.type,
				    lsa->hdr.ls_id, lsa->hdr.adv_rtr);

				lsa_merge(nbrself, lsa, v);
			}
			break;
		case IMSG_NETWORK_DEL:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(kr)) {
				log_warnx("rde_dispatch_parent: "
				    "wrong imsg len");
				break;
			}
			memcpy(&kr, imsg.data, sizeof(kr));

			if ((lsa = rde_asext_put(&kr)) != NULL) {
				v = lsa_find(NULL, lsa->hdr.type,
				    lsa->hdr.ls_id, lsa->hdr.adv_rtr);

				/*
				 * if v == NULL no LSA is in the table and
				 * nothing has to be done.
				 */
				if (v)
					lsa_merge(nbrself, lsa, v);
				else
					free(lsa);
			}
			break;
		case IMSG_IFINFO:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct iface))
				fatalx("IFINFO imsg with wrong len");

			ifp = imsg.data;
			iface = if_find(ifp->ifindex);
			if (iface == NULL)
				fatalx("interface lost in rde");

			wasvalid = (iface->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(iface->linkstate);

			if_update(iface, ifp->mtu, ifp->flags, ifp->if_type,
			    ifp->linkstate, ifp->baudrate);

			/* Resend LSAs if interface state changes. */
			if (wasvalid != (iface->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(iface->linkstate)) {
				area = area_find(rdeconf, iface->area_id);
				if (!area)
					fatalx("interface lost area");
				orig_intra_area_prefix_lsas(area);
			}
			break;
		case IMSG_IFADD:
			if ((iface = malloc(sizeof(struct iface))) == NULL)
				fatal(NULL);
			memcpy(iface, imsg.data, sizeof(struct iface));

			LIST_INIT(&iface->nbr_list);
			TAILQ_INIT(&iface->ls_ack_list);
			RB_INIT(&iface->lsa_tree);

			area = area_find(rdeconf, iface->area_id);
			LIST_INSERT_HEAD(&area->iface_list, iface, entry);
			break;
		case IMSG_IFDELETE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(ifindex))
				fatalx("IFDELETE imsg with wrong len");

			memcpy(&ifindex, imsg.data, sizeof(ifindex));
			iface = if_find(ifindex);
			if (iface == NULL)
				fatalx("interface lost in rde");

			LIST_REMOVE(iface, entry);
			if_del(iface);
			break;
		case IMSG_IFADDRNEW:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct ifaddrchange))
				fatalx("IFADDRNEW imsg with wrong len");
			ifc = imsg.data;

			iface = if_find(ifc->ifindex);
			if (iface == NULL)
				fatalx("IFADDRNEW interface lost in rde");

			if ((ia = calloc(1, sizeof(struct iface_addr))) ==
			    NULL)
				fatal("rde_dispatch_parent IFADDRNEW");
			ia->addr = ifc->addr;
			ia->dstbrd = ifc->dstbrd;
			ia->prefixlen = ifc->prefixlen;

			TAILQ_INSERT_TAIL(&iface->ifa_list, ia, entry);
			area = area_find(rdeconf, iface->area_id);
			if (area)
				orig_intra_area_prefix_lsas(area);
			break;
		case IMSG_IFADDRDEL:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(struct ifaddrchange))
				fatalx("IFADDRDEL imsg with wrong len");
			ifc = imsg.data;

			iface = if_find(ifc->ifindex);
			if (iface == NULL)
				fatalx("IFADDRDEL interface lost in rde");

			for (ia = TAILQ_FIRST(&iface->ifa_list); ia != NULL;
			    ia = nia) {
				nia = TAILQ_NEXT(ia, entry);

				if (IN6_ARE_ADDR_EQUAL(&ia->addr,
				    &ifc->addr)) {
					TAILQ_REMOVE(&iface->ifa_list, ia,
					    entry);
					free(ia);
					break;
				}
			}
			area = area_find(rdeconf, iface->area_id);
			if (area)
				orig_intra_area_prefix_lsas(area);
			break;
		case IMSG_RECONF_CONF:
			if ((nconf = malloc(sizeof(struct ospfd_conf))) ==
			    NULL)
				fatal(NULL);
			memcpy(nconf, imsg.data, sizeof(struct ospfd_conf));

			LIST_INIT(&nconf->area_list);
			LIST_INIT(&nconf->cand_list);
			break;
		case IMSG_RECONF_AREA:
			if ((narea = area_new()) == NULL)
				fatal(NULL);
			memcpy(narea, imsg.data, sizeof(struct area));

			LIST_INIT(&narea->iface_list);
			LIST_INIT(&narea->nbr_list);
			RB_INIT(&narea->lsa_tree);

			LIST_INSERT_HEAD(&nconf->area_list, narea, entry);
			break;
		case IMSG_RECONF_END:
			merge_config(rdeconf, nconf);
			nconf = NULL;
			break;
		default:
			log_debug("rde_dispatch_parent: unexpected imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
rde_dump_area(struct area *area, int imsg_type, pid_t pid)
{
	struct iface	*iface;

	/* dump header */
	imsg_compose_event(iev_ospfe, IMSG_CTL_AREA, 0, pid, -1,
	    area, sizeof(*area));

	/* dump link local lsa */
	LIST_FOREACH(iface, &area->iface_list, entry) {
		imsg_compose_event(iev_ospfe, IMSG_CTL_IFACE,
		    0, pid, -1, iface, sizeof(*iface));
		lsa_dump(&iface->lsa_tree, imsg_type, pid);
	}

	/* dump area lsa */
	lsa_dump(&area->lsa_tree, imsg_type, pid);
}

u_int32_t
rde_router_id(void)
{
	return (rdeconf->rtr_id.s_addr);
}

void
rde_send_change_kroute(struct rt_node *r)
{
	int			 krcount = 0;
	struct kroute		 kr;
	struct rt_nexthop	*rn;
	struct ibuf		*wbuf;

	if ((wbuf = imsg_create(&iev_main->ibuf, IMSG_KROUTE_CHANGE, 0, 0,
	    sizeof(kr))) == NULL) {
		return;
	}

	TAILQ_FOREACH(rn, &r->nexthop, entry) {
		if (rn->invalid)
			continue;
		krcount++;

		bzero(&kr, sizeof(kr));
		kr.prefix = r->prefix;
		kr.nexthop = rn->nexthop;
		if (IN6_IS_ADDR_LINKLOCAL(&rn->nexthop) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&rn->nexthop))
			kr.scope = rn->ifindex;
		kr.ifindex = rn->ifindex;
		kr.prefixlen = r->prefixlen;
		kr.ext_tag = r->ext_tag;
		imsg_add(wbuf, &kr, sizeof(kr));
	}
	if (krcount == 0)
		fatalx("rde_send_change_kroute: no valid nexthop found");

	imsg_close(&iev_main->ibuf, wbuf);
	imsg_event_add(iev_main);
}

void
rde_send_delete_kroute(struct rt_node *r)
{
	struct kroute	 kr;

	bzero(&kr, sizeof(kr));
	kr.prefix = r->prefix;
	kr.prefixlen = r->prefixlen;

	imsg_compose_event(iev_main, IMSG_KROUTE_DELETE, 0, 0, -1,
	    &kr, sizeof(kr));
}

void
rde_send_summary(pid_t pid)
{
	static struct ctl_sum	 sumctl;
	struct timeval		 now;
	struct area		*area;
	struct vertex		*v;

	bzero(&sumctl, sizeof(struct ctl_sum));

	sumctl.rtr_id.s_addr = rde_router_id();
	sumctl.spf_delay = rdeconf->spf_delay;
	sumctl.spf_hold_time = rdeconf->spf_hold_time;

	LIST_FOREACH(area, &rdeconf->area_list, entry)
		sumctl.num_area++;

	RB_FOREACH(v, lsa_tree, &asext_tree)
		sumctl.num_ext_lsa++;

	gettimeofday(&now, NULL);
	if (rdeconf->uptime < now.tv_sec)
		sumctl.uptime = now.tv_sec - rdeconf->uptime;
	else
		sumctl.uptime = 0;

	rde_imsg_compose_ospfe(IMSG_CTL_SHOW_SUM, 0, pid, &sumctl,
	    sizeof(sumctl));
}

void
rde_send_summary_area(struct area *area, pid_t pid)
{
	static struct ctl_sum_area	 sumareactl;
	struct iface			*iface;
	struct rde_nbr			*nbr;
	struct lsa_tree			*tree = &area->lsa_tree;
	struct vertex			*v;

	bzero(&sumareactl, sizeof(struct ctl_sum_area));

	sumareactl.area.s_addr = area->id.s_addr;
	sumareactl.num_spf_calc = area->num_spf_calc;

	LIST_FOREACH(iface, &area->iface_list, entry)
		sumareactl.num_iface++;

	LIST_FOREACH(nbr, &area->nbr_list, entry)
		if (nbr->state == NBR_STA_FULL && !nbr->self)
			sumareactl.num_adj_nbr++;

	RB_FOREACH(v, lsa_tree, tree)
		sumareactl.num_lsa++;

	rde_imsg_compose_ospfe(IMSG_CTL_SHOW_SUM_AREA, 0, pid, &sumareactl,
	    sizeof(sumareactl));
}

LIST_HEAD(rde_nbr_head, rde_nbr);

struct nbr_table {
	struct rde_nbr_head	*hashtbl;
	u_int32_t		 hashmask;
} rdenbrtable;

#define RDE_NBR_HASH(x)		\
	&rdenbrtable.hashtbl[(x) & rdenbrtable.hashmask]

void
rde_nbr_init(u_int32_t hashsize)
{
	struct rde_nbr_head	*head;
	u_int32_t		 hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	rdenbrtable.hashtbl = calloc(hs, sizeof(struct rde_nbr_head));
	if (rdenbrtable.hashtbl == NULL)
		fatal("rde_nbr_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&rdenbrtable.hashtbl[i]);

	rdenbrtable.hashmask = hs - 1;

	if ((nbrself = calloc(1, sizeof(*nbrself))) == NULL)
		fatal("rde_nbr_init");

	nbrself->id.s_addr = rde_router_id();
	nbrself->peerid = NBR_IDSELF;
	nbrself->state = NBR_STA_DOWN;
	nbrself->self = 1;
	head = RDE_NBR_HASH(NBR_IDSELF);
	LIST_INSERT_HEAD(head, nbrself, hash);
}

void
rde_nbr_free(void)
{
	free(nbrself);
	free(rdenbrtable.hashtbl);
}

struct rde_nbr *
rde_nbr_find(u_int32_t peerid)
{
	struct rde_nbr_head	*head;
	struct rde_nbr		*nbr;

	head = RDE_NBR_HASH(peerid);

	LIST_FOREACH(nbr, head, hash) {
		if (nbr->peerid == peerid)
			return (nbr);
	}

	return (NULL);
}

struct rde_nbr *
rde_nbr_new(u_int32_t peerid, struct rde_nbr *new)
{
	struct rde_nbr_head	*head;
	struct rde_nbr		*nbr;
	struct area		*area;
	struct iface		*iface;

	if (rde_nbr_find(peerid))
		return (NULL);
	if ((area = area_find(rdeconf, new->area_id)) == NULL)
		fatalx("rde_nbr_new: unknown area");

	if ((iface = if_find(new->ifindex)) == NULL)
		fatalx("rde_nbr_new: unknown interface");

	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
		fatal("rde_nbr_new");

	memcpy(nbr, new, sizeof(*nbr));
	nbr->peerid = peerid;
	nbr->area = area;
	nbr->iface = iface;

	TAILQ_INIT(&nbr->req_list);

	head = RDE_NBR_HASH(peerid);
	LIST_INSERT_HEAD(head, nbr, hash);
	LIST_INSERT_HEAD(&area->nbr_list, nbr, entry);

	return (nbr);
}

void
rde_nbr_del(struct rde_nbr *nbr)
{
	if (nbr == NULL)
		return;

	rde_req_list_free(nbr);

	LIST_REMOVE(nbr, entry);
	LIST_REMOVE(nbr, hash);

	free(nbr);
}

int
rde_nbr_loading(struct area *area)
{
	struct rde_nbr		*nbr;
	int			 checkall = 0;

	if (area == NULL) {
		area = LIST_FIRST(&rdeconf->area_list);
		checkall = 1;
	}

	while (area != NULL) {
		LIST_FOREACH(nbr, &area->nbr_list, entry) {
			if (nbr->self)
				continue;
			if (nbr->state & NBR_STA_XCHNG ||
			    nbr->state & NBR_STA_LOAD)
				return (1);
		}
		if (!checkall)
			break;
		area = LIST_NEXT(area, entry);
	}

	return (0);
}

struct rde_nbr *
rde_nbr_self(struct area *area)
{
	struct rde_nbr		*nbr;

	LIST_FOREACH(nbr, &area->nbr_list, entry)
		if (nbr->self)
			return (nbr);

	/* this may not happen */
	fatalx("rde_nbr_self: area without self");
	return (NULL);
}

/*
 * LSA req list
 */
void
rde_req_list_add(struct rde_nbr *nbr, struct lsa_hdr *lsa)
{
	struct rde_req_entry	*le;

	if ((le = calloc(1, sizeof(*le))) == NULL)
		fatal("rde_req_list_add");

	TAILQ_INSERT_TAIL(&nbr->req_list, le, entry);
	le->type = lsa->type;
	le->ls_id = lsa->ls_id;
	le->adv_rtr = lsa->adv_rtr;
}

int
rde_req_list_exists(struct rde_nbr *nbr, struct lsa_hdr *lsa_hdr)
{
	struct rde_req_entry	*le;

	TAILQ_FOREACH(le, &nbr->req_list, entry) {
		if ((lsa_hdr->type == le->type) &&
		    (lsa_hdr->ls_id == le->ls_id) &&
		    (lsa_hdr->adv_rtr == le->adv_rtr))
			return (1);
	}
	return (0);
}

void
rde_req_list_del(struct rde_nbr *nbr, struct lsa_hdr *lsa_hdr)
{
	struct rde_req_entry	*le;

	TAILQ_FOREACH(le, &nbr->req_list, entry) {
		if ((lsa_hdr->type == le->type) &&
		    (lsa_hdr->ls_id == le->ls_id) &&
		    (lsa_hdr->adv_rtr == le->adv_rtr)) {
			TAILQ_REMOVE(&nbr->req_list, le, entry);
			free(le);
			return;
		}
	}
}

void
rde_req_list_free(struct rde_nbr *nbr)
{
	struct rde_req_entry	*le;

	while ((le = TAILQ_FIRST(&nbr->req_list)) != NULL) {
		TAILQ_REMOVE(&nbr->req_list, le, entry);
		free(le);
	}
}

/*
 * as-external LSA handling
 */
struct lsa *
rde_asext_get(struct kroute *kr)
{
	struct area		*area;
	struct iface		*iface;
	struct iface_addr	*ia;
	struct in6_addr		 addr;

	LIST_FOREACH(area, &rdeconf->area_list, entry)
		LIST_FOREACH(iface, &area->iface_list, entry)
			TAILQ_FOREACH(ia, &iface->ifa_list, entry) {
				if (IN6_IS_ADDR_LINKLOCAL(&ia->addr))
					continue;

				inet6applymask(&addr, &ia->addr,
				    kr->prefixlen);
				if (!memcmp(&addr, &kr->prefix,
				    sizeof(addr)) && kr->prefixlen ==
				    ia->prefixlen) {
					/* already announced as Prefix LSA */
					log_debug("rde_asext_get: %s/%d is "
					    "part of prefix LSA",
					    log_in6addr(&kr->prefix),
					    kr->prefixlen);
					return (NULL);
				}
			}

	/* update of seqnum is done by lsa_merge */
	return (orig_asext_lsa(kr, DEFAULT_AGE));
}

struct lsa *
rde_asext_put(struct kroute *kr)
{
	/*
	 * just try to remove the LSA. If the prefix is announced as
	 * stub net LSA lsa_find() will fail later and nothing will happen.
	 */

	/* remove by reflooding with MAX_AGE */
	return (orig_asext_lsa(kr, MAX_AGE));
}

/*
 * summary LSA stuff
 */
void
rde_summary_update(struct rt_node *rte, struct area *area)
{
	struct vertex		*v = NULL;
//XXX	struct lsa		*lsa;
	u_int16_t		 type = 0;

	/* first check if we actually need to announce this route */
	if (!(rte->d_type == DT_NET || rte->flags & OSPF_RTR_E))
		return;
	/* never create summaries for as-ext LSA */
	if (rte->p_type == PT_TYPE1_EXT || rte->p_type == PT_TYPE2_EXT)
		return;
	/* no need for summary LSA in the originating area */
	if (rte->area.s_addr == area->id.s_addr)
		return;
	/* no need to originate inter-area routes to the backbone */
	if (rte->p_type == PT_INTER_AREA && area->id.s_addr == INADDR_ANY)
		return;
	/* TODO nexthop check, nexthop part of area -> no summary */
	if (rte->cost >= LS_INFINITY)
		return;
	/* TODO AS border router specific checks */
	/* TODO inter-area network route stuff */
	/* TODO intra-area stuff -- condense LSA ??? */

	if (rte->d_type == DT_NET) {
		type = LSA_TYPE_INTER_A_PREFIX;
	} else if (rte->d_type == DT_RTR) {
		type = LSA_TYPE_INTER_A_ROUTER;
	} else

#if 0 /* XXX a lot todo */
	/* update lsa but only if it was changed */
	v = lsa_find(area, type, rte->prefix.s_addr, rde_router_id());
	lsa = orig_sum_lsa(rte, area, type, rte->invalid);
	lsa_merge(rde_nbr_self(area), lsa, v);

	if (v == NULL)
		v = lsa_find(area, type, rte->prefix.s_addr, rde_router_id());
#endif

	/* suppressed/deleted routes are not found in the second lsa_find */
	if (v)
		v->cost = rte->cost;
}

/*
 * Functions for self-originated LSAs
 */

/* Prefix LSAs have variable size. We have to be careful to copy the right
 * amount of bytes, and to realloc() the right amount of memory. */
void
append_prefix_lsa(struct lsa **lsa, u_int16_t *len, struct lsa_prefix *prefix)
{
	struct lsa_prefix	*copy;
	unsigned int		 lsa_prefix_len;
	unsigned int		 new_len;
	char			*new_lsa;

	lsa_prefix_len = sizeof(struct lsa_prefix)
	    + LSA_PREFIXSIZE(prefix->prefixlen);

	new_len = *len + lsa_prefix_len;

	/* Make sure we have enough space for this prefix. */
	if ((new_lsa = realloc(*lsa, new_len)) == NULL)
		fatalx("append_prefix_lsa");

	/* Append prefix to LSA. */
	copy = (struct lsa_prefix *)(new_lsa + *len);
	memcpy(copy, prefix, lsa_prefix_len);
	copy->metric = 0;

	*lsa = (struct lsa *)new_lsa;
	*len = new_len;
}

int
prefix_compare(struct prefix_node *a, struct prefix_node *b)
{
	struct lsa_prefix	*p;
	struct lsa_prefix	*q;
	int			 i;
	int			 len;

	p = a->prefix;
	q = b->prefix;

	len = MINIMUM(LSA_PREFIXSIZE(p->prefixlen), LSA_PREFIXSIZE(q->prefixlen));

	i = memcmp(p + 1, q + 1, len);
	if (i)
		return (i);
	if (p->prefixlen < q->prefixlen)
		return (-1);
	if (p->prefixlen > q->prefixlen)
		return (1);
	return (0);
}

void
prefix_tree_add(struct prefix_tree *tree, struct lsa_link *lsa)
{
	struct prefix_node	*old;
	struct prefix_node	*new;
	struct in6_addr		 addr;
	unsigned int		 len;
	unsigned int		 i;
	char			*cur_prefix;

	cur_prefix = (char *)(lsa + 1);

	for (i = 0; i < ntohl(lsa->numprefix); i++) {
		if ((new = calloc(1, sizeof(*new))) == NULL)
			fatal("prefix_tree_add");
		new->prefix = (struct lsa_prefix *)cur_prefix;

		len = sizeof(*new->prefix)
		    + LSA_PREFIXSIZE(new->prefix->prefixlen);

		bzero(&addr, sizeof(addr));
		memcpy(&addr, new->prefix + 1,
		    LSA_PREFIXSIZE(new->prefix->prefixlen));

		if (!(IN6_IS_ADDR_LINKLOCAL(&addr)) &&
		    (new->prefix->options & OSPF_PREFIX_NU) == 0 &&
		    (new->prefix->options & OSPF_PREFIX_LA) == 0) {
			old = RB_INSERT(prefix_tree, tree, new);
			if (old != NULL) {
				old->prefix->options |= new->prefix->options;
				free(new);
			}
		}

		cur_prefix = cur_prefix + len;
	}
}

RB_GENERATE(prefix_tree, prefix_node, entry, prefix_compare)

struct lsa *
orig_intra_lsa_net(struct area *area, struct iface *iface, struct vertex *old)
{
	struct lsa		*lsa;
	struct vertex		*v;
	struct rde_nbr		*nbr;
	struct prefix_node	*node;
	struct prefix_tree	 tree;
	int			 num_full_nbr;
	u_int16_t		 len;
	u_int16_t		 numprefix;

	log_debug("orig_intra_lsa_net: area %s, interface %s",
	    inet_ntoa(area->id), iface->name);

	RB_INIT(&tree);

	if (iface->state & IF_STA_DR) {
		num_full_nbr = 0;
		LIST_FOREACH(nbr, &area->nbr_list, entry) {
			if (nbr->self ||
			    nbr->iface->ifindex != iface->ifindex ||
			    (nbr->state & NBR_STA_FULL) == 0)
				continue;
			num_full_nbr++;
			v = lsa_find(iface, htons(LSA_TYPE_LINK),
			    htonl(nbr->iface_id), nbr->id.s_addr);
			if (v)
				prefix_tree_add(&tree, &v->lsa->data.link);
		}
		if (num_full_nbr == 0) {
			/* There are no adjacent neighbors on link.
			 * If a copy of this LSA already exists in DB,
			 * it needs to be flushed. orig_intra_lsa_rtr()
			 * will take care of prefixes configured on
			 * this interface. */
			if (!old)
				return NULL;
		} else {
			/* Add our own prefixes configured for this link. */
			v = lsa_find(iface, htons(LSA_TYPE_LINK),
			    htonl(iface->ifindex), rde_router_id());
			if (v)
				prefix_tree_add(&tree, &v->lsa->data.link);
		}
	/* Continue only if a copy of this LSA already exists in DB.
	 * It needs to be flushed. */
	} else if (!old)
		return NULL;

	len = sizeof(struct lsa_hdr) + sizeof(struct lsa_intra_prefix);
	if ((lsa = calloc(1, len)) == NULL)
		fatal("orig_intra_lsa_net");

	lsa->data.pref_intra.ref_type = htons(LSA_TYPE_NETWORK);
	lsa->data.pref_intra.ref_ls_id = htonl(iface->ifindex);
	lsa->data.pref_intra.ref_adv_rtr = rde_router_id();

	numprefix = 0;
	RB_FOREACH(node, prefix_tree, &tree) {
		append_prefix_lsa(&lsa, &len, node->prefix);
		numprefix++;
	}

	lsa->data.pref_intra.numprefix = htons(numprefix);

	while (!RB_EMPTY(&tree))
		free(RB_REMOVE(prefix_tree, &tree, RB_ROOT(&tree)));

	/* LSA header */
	/* If numprefix is zero, originate with MAX_AGE to flush LSA. */
	lsa->hdr.age = numprefix == 0 ? htons(MAX_AGE) : htons(DEFAULT_AGE);
	lsa->hdr.type = htons(LSA_TYPE_INTRA_A_PREFIX);
	lsa->hdr.ls_id = htonl(iface->ifindex);
	lsa->hdr.adv_rtr = rde_router_id();
	lsa->hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa->hdr.len = htons(len);
	lsa->hdr.ls_chksum = htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	return lsa;
}

struct lsa *
orig_intra_lsa_rtr(struct area *area, struct vertex *old)
{
	char			lsa_prefix_buf[sizeof(struct lsa_prefix)
				    + sizeof(struct in6_addr)];
	struct lsa		*lsa;
	struct lsa_prefix	*lsa_prefix;
	struct in6_addr		*prefix;
	struct iface		*iface;
	struct iface_addr	*ia;
	struct rde_nbr		*nbr;
	u_int16_t		 len;
	u_int16_t		 numprefix;

	len = sizeof(struct lsa_hdr) + sizeof(struct lsa_intra_prefix);
	if ((lsa = calloc(1, len)) == NULL)
		fatal("orig_intra_lsa_rtr");

	lsa->data.pref_intra.ref_type = htons(LSA_TYPE_ROUTER);
	lsa->data.pref_intra.ref_ls_id = 0;
	lsa->data.pref_intra.ref_adv_rtr = rde_router_id();

	numprefix = 0;
	LIST_FOREACH(iface, &area->iface_list, entry) {
		if (!((iface->flags & IFF_UP) &&
		    LINK_STATE_IS_UP(iface->linkstate)))
			/* interface or link state down */
			continue;
		if ((iface->state & IF_STA_DOWN) &&
		    !(iface->cflags & F_IFACE_PASSIVE))
			/* passive interfaces stay in state DOWN */
			continue;

		/* Broadcast links with adjacencies are handled
		 * by orig_intra_lsa_net(), ignore. */
		if (iface->type == IF_TYPE_BROADCAST ||
		    iface->type == IF_TYPE_NBMA) {
			if (iface->state & IF_STA_WAITING)
				/* Skip, we're still waiting for
				 * adjacencies to form. */
				continue;

			LIST_FOREACH(nbr, &area->nbr_list, entry)
				if (!nbr->self &&
				    nbr->iface->ifindex == iface->ifindex &&
				    nbr->state & NBR_STA_FULL)
					break;
			if (nbr)
				continue;
		}

		lsa_prefix = (struct lsa_prefix *)lsa_prefix_buf;

		TAILQ_FOREACH(ia, &iface->ifa_list, entry) {
			if (IN6_IS_ADDR_LINKLOCAL(&ia->addr))
				continue;

			bzero(lsa_prefix_buf, sizeof(lsa_prefix_buf));

			if (iface->type == IF_TYPE_POINTOMULTIPOINT ||
			    iface->state & IF_STA_LOOPBACK) {
				lsa_prefix->prefixlen = 128;
			} else {
				lsa_prefix->prefixlen = ia->prefixlen;
				lsa_prefix->metric = htons(iface->metric);
			}

			if (lsa_prefix->prefixlen == 128)
				lsa_prefix->options |= OSPF_PREFIX_LA;

			log_debug("orig_intra_lsa_rtr: area %s, interface %s: "
			    "%s/%d", inet_ntoa(area->id),
			    iface->name, log_in6addr(&ia->addr),
			    lsa_prefix->prefixlen);

			prefix = (struct in6_addr *)(lsa_prefix + 1);
			inet6applymask(prefix, &ia->addr,
			    lsa_prefix->prefixlen);
			append_prefix_lsa(&lsa, &len, lsa_prefix);
			numprefix++;
		}

		/* TOD: Add prefixes of directly attached hosts, too */
		/* TOD: Add prefixes for virtual links */
	}

	/* If no prefixes were included, continue only if a copy of this
	 * LSA already exists in DB. It needs to be flushed. */
	if (numprefix == 0 && !old) {
		free(lsa);
		return NULL;
	}

	lsa->data.pref_intra.numprefix = htons(numprefix);

	/* LSA header */
	/* If numprefix is zero, originate with MAX_AGE to flush LSA. */
	lsa->hdr.age = numprefix == 0 ? htons(MAX_AGE) : htons(DEFAULT_AGE);
	lsa->hdr.type = htons(LSA_TYPE_INTRA_A_PREFIX);
	lsa->hdr.ls_id = htonl(LS_ID_INTRA_RTR);
	lsa->hdr.adv_rtr = rde_router_id();
	lsa->hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa->hdr.len = htons(len);
	lsa->hdr.ls_chksum = htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	return lsa;
}

void
orig_intra_area_prefix_lsas(struct area *area)
{
	struct lsa	*lsa;
	struct vertex	*old;
	struct iface	*iface;

	LIST_FOREACH(iface, &area->iface_list, entry) {
		if (iface->type == IF_TYPE_BROADCAST ||
		    iface->type == IF_TYPE_NBMA) {
			old = lsa_find(iface, htons(LSA_TYPE_INTRA_A_PREFIX),
			    htonl(iface->ifindex), rde_router_id());
			lsa = orig_intra_lsa_net(area, iface, old);
			if (lsa)
				lsa_merge(rde_nbr_self(area), lsa, old);
		}
	}

	old = lsa_find_tree(&area->lsa_tree, htons(LSA_TYPE_INTRA_A_PREFIX),
		htonl(LS_ID_INTRA_RTR), rde_router_id());
	lsa = orig_intra_lsa_rtr(area, old);
	if (lsa)
		lsa_merge(rde_nbr_self(area), lsa, old);
}

int
comp_asext(struct lsa *a, struct lsa *b)
{
	/* compare prefixes, if they are equal or not */
	if (a->data.asext.prefix.prefixlen != b->data.asext.prefix.prefixlen)
		return (-1);
	return (memcmp(
	    (char *)a + sizeof(struct lsa_hdr) + sizeof(struct lsa_asext),
	    (char *)b + sizeof(struct lsa_hdr) + sizeof(struct lsa_asext),
	    LSA_PREFIXSIZE(a->data.asext.prefix.prefixlen)));
}

struct lsa *
orig_asext_lsa(struct kroute *kr, u_int16_t age)
{
	struct lsa	*lsa;
	u_int32_t	 ext_tag;
	u_int16_t	 len, ext_off;

	len = sizeof(struct lsa_hdr) + sizeof(struct lsa_asext) +
	    LSA_PREFIXSIZE(kr->prefixlen);

	/*
	 * nexthop -- on connected routes we are the nexthop,
	 * on all other cases we should announce the true nexthop
	 * unless that nexthop is outside of the ospf cloud.
	 * XXX for now we don't do this.
	 */

	ext_off = len;
	if (kr->ext_tag) {
		len += sizeof(ext_tag);
	}
	if ((lsa = calloc(1, len)) == NULL)
		fatal("orig_asext_lsa");

	log_debug("orig_asext_lsa: %s/%d age %d",
	    log_in6addr(&kr->prefix), kr->prefixlen, age);

	/* LSA header */
	lsa->hdr.age = htons(age);
	lsa->hdr.type = htons(LSA_TYPE_EXTERNAL);
	lsa->hdr.adv_rtr = rdeconf->rtr_id.s_addr;
	lsa->hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa->hdr.len = htons(len);

	lsa->data.asext.prefix.prefixlen = kr->prefixlen;
	memcpy((char *)lsa + sizeof(struct lsa_hdr) + sizeof(struct lsa_asext),
	    &kr->prefix, LSA_PREFIXSIZE(kr->prefixlen));

	lsa->hdr.ls_id = lsa_find_lsid(&asext_tree, lsa->hdr.type,
	    lsa->hdr.adv_rtr, comp_asext, lsa);

	if (age == MAX_AGE) {
		/* inherit metric and ext_tag from the current LSA,
		 * some routers don't like to get withdraws that are
		 * different from what they have in their table.
		 */
		struct vertex *v;
		v = lsa_find(NULL, lsa->hdr.type, lsa->hdr.ls_id,
		    lsa->hdr.adv_rtr);
		if (v != NULL) {
			kr->metric = ntohl(v->lsa->data.asext.metric);
			if (kr->metric & LSA_ASEXT_T_FLAG) {
				memcpy(&ext_tag, (char *)v->lsa + ext_off,
				    sizeof(ext_tag));
				kr->ext_tag = ntohl(ext_tag);
			}
			kr->metric &= LSA_METRIC_MASK;
		}
	}

	if (kr->ext_tag) {
		lsa->data.asext.metric = htonl(kr->metric | LSA_ASEXT_T_FLAG);
		ext_tag = htonl(kr->ext_tag);
		memcpy((char *)lsa + ext_off, &ext_tag, sizeof(ext_tag));
	} else {
		lsa->data.asext.metric = htonl(kr->metric);
	}

	lsa->hdr.ls_chksum = 0;
	lsa->hdr.ls_chksum =
	    htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	return (lsa);
}

struct lsa *
orig_sum_lsa(struct rt_node *rte, struct area *area, u_int8_t type, int invalid)
{
#if 0 /* XXX a lot todo */
	struct lsa	*lsa;
	u_int16_t	 len;

	len = sizeof(struct lsa_hdr) + sizeof(struct lsa_sum);
	if ((lsa = calloc(1, len)) == NULL)
		fatal("orig_sum_lsa");

	/* LSA header */
	lsa->hdr.age = htons(invalid ? MAX_AGE : DEFAULT_AGE);
	lsa->hdr.type = type;
	lsa->hdr.adv_rtr = rdeconf->rtr_id.s_addr;
	lsa->hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa->hdr.len = htons(len);

	/* prefix and mask */
	/*
	 * TODO ls_id must be unique, for overlapping routes this may
	 * not be true. In this case a hack needs to be done to
	 * make the ls_id unique.
	 */
	lsa->hdr.ls_id = rte->prefix.s_addr;
	if (type == LSA_TYPE_SUM_NETWORK)
		lsa->data.sum.mask = prefixlen2mask(rte->prefixlen);
	else
		lsa->data.sum.mask = 0;	/* must be zero per RFC */

	lsa->data.sum.metric = htonl(rte->cost & LSA_METRIC_MASK);

	lsa->hdr.ls_chksum = 0;
	lsa->hdr.ls_chksum =
	    htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	return (lsa);
#endif
	return NULL;
}
@


1.71
log
@Import route priority support from ospfd to ospf6d.
Also remove the RTF_UP flag from hdr.rtm_flags in send_rtmsg() since
ospfd and bgpd don't set the flag.

OK bluhm@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.70 2017/05/30 12:42:31 friehm Exp $ */
d145 6
d152 1
a152 1
	log_procname = log_procnames[ospfd_process];
d609 1
a609 1
			log_verbose(verbose);
@


1.70
log
@Adding multipath route support to ospf6d. Almost copied from ospfd.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.69 2016/12/27 17:18:56 jca Exp $ */
a635 1
	struct rt_node		*rn;
a695 16
			break;
		case IMSG_KROUTE_GET:
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(kr)) {
				log_warnx("rde_dispatch_parent: "
				    "wrong imsg len");
				break;
			}
			memcpy(&kr, imsg.data, sizeof(kr));

			if ((rn = rt_find(&kr.prefix, kr.prefixlen,
			    DT_NET)) != NULL)
				rde_send_change_kroute(rn);
			else
				/* should not happen */
				imsg_compose_event(iev_main, IMSG_KROUTE_DELETE,
				    0, 0, -1, &kr, sizeof(kr));
@


1.69
log
@Replace struct rroute with struct kroute, as done in ospfd

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.68 2016/09/03 10:25:36 renato Exp $ */
d881 1
d884 6
d892 14
a905 2
		if (!rn->invalid)
			break;
d907 1
a907 1
	if (!rn)
d910 2
a911 12
	bzero(&kr, sizeof(kr));
	kr.prefix = r->prefix;
	kr.nexthop = rn->nexthop;
	if (IN6_IS_ADDR_LINKLOCAL(&rn->nexthop) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&rn->nexthop))
		kr.scope = rn->ifindex;
	kr.ifindex = rn->ifindex;
	kr.prefixlen = r->prefixlen;
	kr.ext_tag = r->ext_tag;

	imsg_compose_event(iev_main, IMSG_KROUTE_CHANGE, 0, 0, -1,
	    &kr, sizeof(kr));
@


1.68
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.67 2016/09/02 14:06:35 benno Exp $ */
d62 2
a63 2
struct lsa	*rde_asext_get(struct rroute *);
struct lsa	*rde_asext_put(struct rroute *);
d66 1
a66 1
struct lsa	*orig_asext_lsa(struct rroute *, u_int16_t);
a631 1
	struct rroute		 rr;
d662 1
a662 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(rr)) {
d667 1
a667 1
			memcpy(&rr, imsg.data, sizeof(rr));
d669 1
a669 1
			if ((lsa = rde_asext_get(&rr)) != NULL) {
d677 1
a677 1
			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(rr)) {
d682 1
a682 1
			memcpy(&rr, imsg.data, sizeof(rr));
d684 1
a684 1
			if ((lsa = rde_asext_put(&rr)) != NULL) {
d1187 1
a1187 1
rde_asext_get(struct rroute *rr)
d1201 3
a1203 3
				    rr->kr.prefixlen);
				if (!memcmp(&addr, &rr->kr.prefix,
				    sizeof(addr)) && rr->kr.prefixlen ==
d1208 2
a1209 2
					    log_in6addr(&rr->kr.prefix),
					    rr->kr.prefixlen);
d1215 1
a1215 1
	return (orig_asext_lsa(rr, DEFAULT_AGE));
d1219 1
a1219 1
rde_asext_put(struct rroute *rr)
d1227 1
a1227 1
	return (orig_asext_lsa(rr, MAX_AGE));
d1603 1
a1603 1
orig_asext_lsa(struct rroute *rr, u_int16_t age)
d1610 1
a1610 1
	    LSA_PREFIXSIZE(rr->kr.prefixlen);
d1620 1
a1620 1
	if (rr->kr.ext_tag) {
d1627 1
a1627 1
	    log_in6addr(&rr->kr.prefix), rr->kr.prefixlen, age);
d1636 1
a1636 1
	lsa->data.asext.prefix.prefixlen = rr->kr.prefixlen;
d1638 1
a1638 1
	    &rr->kr.prefix, LSA_PREFIXSIZE(rr->kr.prefixlen));
d1652 2
a1653 2
			rr->metric = ntohl(v->lsa->data.asext.metric);
			if (rr->metric & LSA_ASEXT_T_FLAG) {
d1656 1
a1656 1
				rr->kr.ext_tag = ntohl(ext_tag);
d1658 1
a1658 1
			rr->metric &= LSA_METRIC_MASK;
d1662 3
a1664 3
	if (rr->kr.ext_tag) {
		lsa->data.asext.metric = htonl(rr->metric | LSA_ASEXT_T_FLAG);
		ext_tag = htonl(rr->kr.ext_tag);
d1667 1
a1667 1
		lsa->data.asext.metric = htonl(rr->metric);
@


1.67
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.66 2016/06/06 15:57:44 benno Exp $ */
d45 1
a45 1
void		 rde_shutdown(void);
d210 1
a210 1
void
d215 6
a230 1
	msgbuf_clear(&iev_ospfe->ibuf.w);
a231 1
	msgbuf_clear(&iev_main->ibuf.w);
@


1.66
log
@add format attributes to the proper functions and then fix the
warning in rde.c
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.65 2015/12/05 13:12:41 claudio Exp $ */
d146 1
@


1.65
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.64 2015/09/27 17:31:50 stsp Exp $ */
d359 1
a359 1
				log_warnx("rde_dispatch_imsg: peerid %lu, "
d390 1
a390 1
				log_warnx("rde_dispatch_imsg: peerid %lu, "
@


1.64
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.63 2015/01/16 06:40:19 deraadt Exp $ */
d264 1
a264 1
		if ((n = imsg_read(ibuf)) == -1)
d281 1
a281 1
			fatal("rde_dispatch_imsg: imsg_read error");
d638 1
a638 1
		if ((n = imsg_read(ibuf)) == -1)
d652 1
a652 1
			fatal("rde_dispatch_parent: imsg_read error");
@


1.63
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.62 2014/07/12 20:16:38 krw Exp $ */
d723 1
a723 1
			if_update(iface, ifp->mtu, ifp->flags, ifp->media_type,
@


1.62
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.61 2013/11/13 20:49:49 benno Exp $ */
a20 1
#include <sys/param.h>			/* for MIN() */
d42 2
d1319 1
a1319 1
	len = MIN(LSA_PREFIXSIZE(p->prefixlen), LSA_PREFIXSIZE(q->prefixlen));
@


1.61
log
@handle msgbuf_write() returning EAGAIN,
taken from claudios previous fix to ospfd.

"do it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.60 2012/09/17 13:49:27 bluhm Exp $ */
d269 1
a269 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d271 2
d643 1
a643 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d645 2
@


1.60
log
@Fix trailing whitespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.59 2011/11/06 10:29:05 guenther Exp $ */
d269 1
a269 1
		if (msgbuf_write(&ibuf->w) == -1)
d641 1
a641 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.59
log
@Add a #include that's currently picked up via another header that's
violating namespace rules

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.58 2011/07/07 17:10:48 claudio Exp $ */
d1476 2
a1477 2
		if ((iface->state & IF_STA_DOWN) && 
		    !(iface->cflags & F_IFACE_PASSIVE)) 
@


1.58
log
@Rework the distribution of link state and iface FSM state changes.
Link state changes are sent from the parent to both childs and
iface FSM state changes are sent from the ospfe to the rde.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.57 2011/07/07 04:37:56 claudio Exp $ */
d21 1
@


1.57
log
@Just use if_find() to find an interface by ifindex.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.56 2011/07/07 04:35:47 claudio Exp $ */
a254 1
	struct iface		*iface, *ifp;
d580 1
a580 1
			    sizeof(struct iface))
d583 4
a586 5
			ifp = imsg.data;

			iface = if_find(ifp->ifindex);
			if (iface == NULL)
				fatalx("interface lost in rde");
d588 2
a589 17
			/* 
			 * Resend LSAs if interface flags change -
			 * carp/passive interfaces can come up and down
			 * without changing OSPF state.
			 */
			if ((iface->state != ifp->state) || 
			    (iface->linkstate != ifp->linkstate) || 
			    (iface->flags != ifp->flags)) {
				iface->state = ifp->state;
				iface->flags = ifp->flags;
				iface->linkstate = ifp->linkstate;

				area = area_find(rdeconf, iface->area_id);
				if (!area)
					fatalx("interface lost area");
				orig_intra_area_prefix_lsas(area);
			}
d618 1
a618 1
	struct iface		*iface;
d630 1
a630 1
	int			 shut = 0;
d701 27
a727 2
				imsg_compose_event(iev_main, IMSG_KROUTE_DELETE, 0,
				    0, -1, &kr, sizeof(kr));
@


1.56
log
@correct/change some debug and fatal messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.55 2011/07/07 00:36:13 claudio Exp $ */
d1032 1
a1032 5
	LIST_FOREACH(iface, &area->iface_list, entry) {
		if (iface->ifindex == new->ifindex)
			break;
	}
	if (iface == NULL)
@


1.55
log
@Kill nh_reachable. Link state checking is so easy now that it does not
matter anymore to cache this value for ospf6d.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.54 2011/07/04 04:34:14 claudio Exp $ */
d741 1
a741 1
				fatalx("interface lost in ospfe");
a1464 2
	log_debug("orig_intra_lsa_rtr: area %s", inet_ntoa(area->id));

a1475 4
		log_debug("orig_intra_lsa_rtr: area %s, interface %s: "
		    "including in intra-area-prefix LSA",
		    inet_ntoa(area->id), iface->name);

d1512 5
@


1.54
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.53 2011/07/04 04:08:34 claudio Exp $ */
a588 1
			iface->nh_reachable = ifp->nh_reachable;
@


1.53
log
@Make sure that passive interfaces (like carp) are added to the
intra-area rtr LSA. Diff initialy made by Patrick Coleman but
simplified by myself. Tested and OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.52 2011/05/05 15:58:02 claudio Exp $ */
d1471 1
a1471 3
		    (LINK_STATE_IS_UP(iface->linkstate) ||
		    (iface->linkstate == LINK_STATE_UNKNOWN &&
		    iface->media_type != IFT_CARP))))
@


1.52
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.51 2011/05/02 06:34:29 claudio Exp $ */
d24 1
a588 2
			iface->flags = ifp->flags;
			iface->linkstate = ifp->linkstate;
d590 9
a598 1
			if (iface->state != ifp->state) {
d600 3
d1470 5
a1474 1
		if (iface->state & IF_STA_DOWN)
d1476 8
@


1.51
log
@Don't include sys/param.h and reformat some lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.50 2010/08/22 20:55:10 bluhm Exp $ */
d510 1
a510 1
				    lsa_hdr.adv_rtr);
@


1.50
log
@When removing an announced prefix, inherit the metric and ext_tag
from the LSA that is currently in the tree.  Based on claudio@@'s
diff and his fix for ospfd.  Additionally originate an LSA with
external route tag correctly by writing the AS-external-LSA's bit
T into the correct field.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.49 2010/07/09 12:39:46 bluhm Exp $ */
a23 1
#include <sys/param.h>
d377 2
a378 2
					    IMSG_LS_BADREQ,
					    imsg.hdr.peerid, 0, -1, NULL, 0);
d407 1
a407 1
				    lsa->hdr.adv_rtr);
d450 2
a451 3
					    IMSG_LS_FLOOD,
					    v->peerid, 0, -1, v->lsa,
					    ntohs(v->lsa->hdr.len));
d466 2
a467 2
					    IMSG_LS_BADREQ,
					    imsg.hdr.peerid, 0, -1, NULL, 0);
@


1.49
log
@Do not try to originate an intra-area-prefix-lsa if an interface
address changes that does not belong to any area.  This fixes an
ospf6d crash.  To not search for the area in orig_intra_lsa_net(),
just pass the area as function parameter.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.48 2010/07/06 13:24:35 bluhm Exp $ */
d1577 1
a1577 1
	u_int16_t	 len, ext_off = 0;
d1589 1
a1590 1
		ext_off = len;
a1605 1
	lsa->data.asext.metric = htonl(rr->metric);
d1610 22
d1633 1
a1633 1
		lsa->data.asext.prefix.options |= LSA_ASEXT_T_FLAG;
d1636 2
a1639 2
	lsa->hdr.ls_id = lsa_find_lsid(&asext_tree, lsa->hdr.type,
	    lsa->hdr.adv_rtr, comp_asext, lsa);
@


1.48
log
@Update the interfaces changes from kroute to rde via imsg.  This
is needed to orginate correct intra-area-prefix-lsas.
ok claudio@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.47 2010/07/06 13:15:33 bluhm Exp $ */
d66 2
a67 1
struct lsa	*orig_intra_lsa_net(struct iface *, struct vertex *);
d758 2
a759 1
			orig_intra_area_prefix_lsas(area);
d784 2
a785 1
			orig_intra_area_prefix_lsas(area);
d1355 1
a1355 1
orig_intra_lsa_net(struct iface *iface, struct vertex *old)
a1358 1
	struct area		*area;
a1365 3
	if ((area = area_find(rdeconf, iface->area_id)) == NULL)
		fatalx("interface lost area");

d1547 1
a1547 1
			lsa = orig_intra_lsa_net(iface, old);
@


1.47
log
@Use the static variable narea only where needed for config reload.
The other imessages use the stack variables area and iface.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.46 2010/07/05 22:59:51 bluhm Exp $ */
d628 2
d737 46
@


1.46
log
@During network intra-area-prefix-lsa origination, the designated
router's prefixes were ignored if all other routers on that link
had no prefixes.  Advertise a intra-area-prefix-lsa with all prefixes
for the network if there are any adjacent neighbors on link.
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.45 2010/07/01 21:19:57 bluhm Exp $ */
d626 2
a627 1
	struct iface		*niface, *iface;
d712 1
a712 1
			if ((niface = malloc(sizeof(struct iface))) == NULL)
d714 1
a714 1
			memcpy(niface, imsg.data, sizeof(struct iface));
d716 3
a718 3
			LIST_INIT(&niface->nbr_list);
			TAILQ_INIT(&niface->ls_ack_list);
			RB_INIT(&niface->lsa_tree);
d720 2
a721 2
			narea = area_find(rdeconf, niface->area_id);
			LIST_INSERT_HEAD(&narea->iface_list, niface, entry);
@


1.45
log
@Fix memory leak by adding a missing free(lsa).
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.44 2010/07/01 19:47:04 bluhm Exp $ */
a69 1
int		 link_lsa_from_full_nbr(struct lsa *, struct iface *);
a1301 26
/* Return non-zero if Link LSA was originated from an adjacent neighbor. */
int
link_lsa_from_full_nbr(struct lsa *lsa, struct iface *iface)
{
	struct rde_nbr	*nbr;
	struct area	*area;

	if ((area = area_find(rdeconf, iface->area_id)) == NULL)
		fatalx("interface lost area");

	LIST_FOREACH(nbr, &area->nbr_list, entry) {
		if (nbr->self || nbr->iface->ifindex != iface->ifindex)
			continue;
		if (lsa->hdr.adv_rtr == nbr->id.s_addr)
			break;
	}
	if (!nbr)
		return 0;

	if (nbr->state & NBR_STA_FULL &&
	    ntohl(lsa->hdr.ls_id) == nbr->iface_id)
		return 1;

	return 0;
}

d1308 1
d1311 1
d1324 5
a1328 2
		RB_FOREACH(v, lsa_tree, &iface->lsa_tree) {
			if (v->type != LSA_TYPE_LINK)
d1330 4
a1333 1
			if (link_lsa_from_full_nbr(v->lsa, iface))
d1336 1
a1336 1
		if (RB_EMPTY(&tree)) {
@


1.44
log
@Fix all white space bugs in ospf6d at once.  No binary change.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.43 2010/07/01 18:57:21 bluhm Exp $ */
d691 2
@


1.43
log
@The prefixes of interface addresses of an ospf link have to be
advertised as link-lsa and intra-area-prefix-lsa when they change
dynamically.  Handle RTM_NEWADDR and RTM_DELADDR in kroute by sending
an imsg to ospfe.  Upon this event, originate a new link-lsa in
ospfe.  In rde a new intra-area-prefix-lsa is generated when a
link-lsa appears or goes away.
ok claudio@@; ok and test stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.42 2010/06/28 15:05:01 bluhm Exp $ */
d1218 1
a1218 1
	char  			*new_lsa;
d1243 1
a1243 1
	int		 	 i;
d1278 1
a1278 1
		len = sizeof(*new->prefix) 
d1323 1
a1323 1
	
d1457 1
a1457 1
			
@


1.42
log
@Store the ifindex into the kroute change imsg.  This way we can use
the interface index for writing routes into the kernel.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.41 2010/06/12 10:06:50 bluhm Exp $ */
a67 1
void		 orig_intra_area_prefix_lsas(struct area *);
@


1.41
log
@Fix an obvious use after free.  From ospfd.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.40 2010/06/01 11:29:29 bluhm Exp $ */
d820 1
@


1.40
log
@Add NULL pointer check after calloc.
ok claudio@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.39 2010/06/01 11:22:28 bluhm Exp $ */
a458 3
				/* lsa no longer needed */
				free(lsa);

d471 1
d474 3
@


1.39
log
@Fix error message.
ok claudio@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.38 2010/04/16 11:36:10 claudio Exp $ */
d1273 2
a1274 1
		new = calloc(sizeof(*new), 1);
@


1.38
log
@Move a function to a place that is a bit more logical. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.37 2010/03/01 08:58:48 claudio Exp $ */
d1419 1
a1419 1
		fatal("orig_intra_lsa_net");
@


1.37
log
@Support for redistributing AS-ext LSA (redistribute static/connected).
Appart from multi-area support this is the last big missing piece in
ospf6d. ospf6d should now work correctly in single area setups.
So please test.
"it's always nice to see those #if 0 being killed" stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.36 2010/01/24 12:21:05 stsp Exp $ */
a1208 78
struct lsa *
orig_intra_lsa_net(struct iface *iface, struct vertex *old)
{
	struct lsa		*lsa;
	struct vertex		*v;
	struct area		*area;
	struct prefix_node	*node;
	struct prefix_tree	 tree;
	u_int16_t		 len;
	u_int16_t		 numprefix;

	if ((area = area_find(rdeconf, iface->area_id)) == NULL)
		fatalx("interface lost area");

	log_debug("orig_intra_lsa_net: area %s, interface %s",
	    inet_ntoa(area->id), iface->name);

	RB_INIT(&tree);

	if (iface->state & IF_STA_DR) {
		RB_FOREACH(v, lsa_tree, &iface->lsa_tree) {
			if (v->type != LSA_TYPE_LINK)
				continue;
			if (link_lsa_from_full_nbr(v->lsa, iface))
				prefix_tree_add(&tree, &v->lsa->data.link);
		}
		if (RB_EMPTY(&tree)) {
			/* There are no adjacent neighbors on link.
			 * If a copy of this LSA already exists in DB,
			 * it needs to be flushed. orig_intra_lsa_rtr()
			 * will take care of prefixes configured on
			 * this interface. */
			if (!old)
				return NULL;
		} else {
			/* Add our own prefixes configured for this link. */
			v = lsa_find(iface, htons(LSA_TYPE_LINK),
			    htonl(iface->ifindex), rde_router_id());
			if (v)
				prefix_tree_add(&tree, &v->lsa->data.link);
		}
	/* Continue only if a copy of this LSA already exists in DB.
	 * It needs to be flushed. */
	} else if (!old)
		return NULL;

	len = sizeof(struct lsa_hdr) + sizeof(struct lsa_intra_prefix);
	if ((lsa = calloc(1, len)) == NULL)
		fatal("orig_intra_lsa_net");

	lsa->data.pref_intra.ref_type = htons(LSA_TYPE_NETWORK);
	lsa->data.pref_intra.ref_ls_id = htonl(iface->ifindex);
	lsa->data.pref_intra.ref_adv_rtr = rde_router_id();

	numprefix = 0;
	RB_FOREACH(node, prefix_tree, &tree) {
		append_prefix_lsa(&lsa, &len, node->prefix);
		numprefix++;
	}

	lsa->data.pref_intra.numprefix = htons(numprefix);

	while (!RB_EMPTY(&tree))
		free(RB_REMOVE(prefix_tree, &tree, RB_ROOT(&tree)));

	/* LSA header */
	/* If numprefix is zero, originate with MAX_AGE to flush LSA. */
	lsa->hdr.age = numprefix == 0 ? htons(MAX_AGE) : htons(DEFAULT_AGE);
	lsa->hdr.type = htons(LSA_TYPE_INTRA_A_PREFIX);
	lsa->hdr.ls_id = htonl(iface->ifindex);
	lsa->hdr.adv_rtr = rde_router_id();
	lsa->hdr.seq_num = htonl(INIT_SEQ_NUM);
	lsa->hdr.len = htons(len);
	lsa->hdr.ls_chksum = htons(iso_cksum(lsa, len, LS_CKSUM_OFFSET));

	return lsa;
}

d1323 78
@


1.36
log
@In orig_intra_lsa_rtr(), don't allocate and free a temporary buffer
which easily fits on the stack.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.35 2009/12/22 19:32:36 claudio Exp $ */
d63 1
d1114 5
a1118 4
#if 0
	struct area	*area;
	struct iface	*iface;
XXX
d1120 17
a1136 8
		LIST_FOREACH(iface, &area->iface_list, entry) {
			if ((iface->addr.s_addr & iface->mask.s_addr) ==
			    rr->kr.prefix.s_addr && iface->mask.s_addr ==
			    prefixlen2mask(rr->kr.prefixlen)) {
				/* already announced as (stub) net LSA */
				log_debug("rde_asext_get: %s/%d is net LSA",
				    inet_ntoa(rr->kr.prefix), rr->kr.prefixlen);
				return (NULL);
d1138 1
a1138 2
		}
#endif
d1527 12
a1541 1
#if 0 /* XXX a lot todo */
d1543 5
a1547 1
	u_int16_t	 len;
d1549 11
a1559 1
	len = sizeof(struct lsa_hdr) + sizeof(struct lsa_asext);
d1568 1
a1568 1
	lsa->hdr.type = LSA_TYPE_EXTERNAL;
a1572 18
	/* prefix and mask */
	/*
	 * TODO ls_id must be unique, for overlapping routes this may
	 * not be true. In this case a hack needs to be done to
	 * make the ls_id unique.
	 */
	lsa->hdr.ls_id = rr->kr.prefix.s_addr;
	lsa->data.asext.mask = prefixlen2mask(rr->kr.prefixlen);

	/*
	 * nexthop -- on connected routes we are the nexthop,
	 * on all other cases we announce the true nexthop.
	 * XXX this is wrong as the true nexthop may be outside
	 * of the ospf cloud and so unreachable. For now we force
	 * all traffic to be directed to us.
	 */
	lsa->data.asext.fw_addr = 0;

d1574 9
a1582 1
	lsa->data.asext.ext_tag = htonl(rr->kr.ext_tag);
d1584 2
a1590 2
#endif
	return NULL;
@


1.35
log
@Add interface index aka. scope id to struct kroute so that the rde can pass
this information to kroute and kroute can use that information to fill in
the various sin6_scope_id fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.34 2009/11/02 20:24:58 claudio Exp $ */
d1396 2
d1440 1
a1440 3
		if ((lsa_prefix = calloc(sizeof(*lsa_prefix)
		    + sizeof(struct in6_addr), 1)) == NULL)
			fatal("orig_intra_lsa_rtr");
d1446 1
a1446 2
			bzero(lsa_prefix, sizeof(*lsa_prefix)
			    + sizeof(struct in6_addr));
a1464 2

		free(lsa_prefix);
@


1.34
log
@Add IMSG_CTL_LOG_VERBOSE similar to ospfd it allows to toggle debug logging.
henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.33 2009/07/28 19:16:34 claudio Exp $ */
d815 3
@


1.33
log
@More fallout from the r1.31 commit. This time PID and the fd got swapped.
Again from stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.32 2009/07/28 19:14:25 claudio Exp $ */
d259 1
a259 1
	int			 r, state, self, shut = 0;
d599 5
@


1.32
log
@Running 'ospf6ctl show' twice caused ospf6d to fatal. Cause was a missing -
when passing -1 as fd to the imsg call. No frogs for eric@@ and pyr@@
From stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.31 2009/06/06 09:02:46 eric Exp $ */
d361 1
a361 1
			    imsg.hdr.peerid, -1, 0, NULL, 0);
@


1.31
log
@make ospf6ctl/ospf6d imsg-in-a-lib ready too.

ospf6ctl is already broken in tree (not connected to build).

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.30 2009/05/31 20:29:56 jacekm Exp $ */
d577 1
a577 1
			    imsg.hdr.pid, 1, NULL, 0);
@


1.30
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.29 2009/05/31 17:00:40 claudio Exp $ */
d88 2
a89 2
struct imsgbuf		*ibuf_ospfe;
struct imsgbuf		*ibuf_main;
d168 2
a169 2
	if ((ibuf_ospfe = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d171 4
a174 2
	imsg_init(ibuf_ospfe, pipe_ospfe2rde[1], rde_dispatch_imsg);
	imsg_init(ibuf_main, pipe_parent2rde[1], rde_dispatch_parent);
d177 9
a185 9
	ibuf_ospfe->events = EV_READ;
	event_set(&ibuf_ospfe->ev, ibuf_ospfe->fd, ibuf_ospfe->events,
	    ibuf_ospfe->handler, ibuf_ospfe);
	event_add(&ibuf_ospfe->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d222 4
a225 4
	msgbuf_clear(&ibuf_ospfe->w);
	free(ibuf_ospfe);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
d236 2
a237 1
	return (imsg_compose(ibuf_ospfe, type, peerid, pid, data, datalen));
d244 2
a245 1
	struct imsgbuf		*ibuf = bula;
d323 2
a324 2
			imsg_compose(ibuf_ospfe, IMSG_DB_END, imsg.hdr.peerid,
			    0, NULL, 0);
d350 2
a351 2
					imsg_compose(ibuf_ospfe, IMSG_DD,
					    imsg.hdr.peerid, 0, &lsa_hdr,
d360 2
a361 2
			imsg_compose(ibuf_ospfe, IMSG_DD_END, imsg.hdr.peerid,
			    0, NULL, 0);
d377 3
a379 2
					imsg_compose(ibuf_ospfe, IMSG_LS_BADREQ,
					    imsg.hdr.peerid, 0, NULL, 0);
d382 2
a383 2
				imsg_compose(ibuf_ospfe, IMSG_LS_UPD,
				    imsg.hdr.peerid, 0, v->lsa,
d444 2
a445 2
				imsg_compose(ibuf_ospfe, IMSG_LS_FLOOD,
				    imsg.hdr.peerid, 0, lsa,
d450 3
a452 2
					imsg_compose(ibuf_ospfe, IMSG_LS_FLOOD,
					    v->peerid, 0, v->lsa,
d470 3
a472 2
					imsg_compose(ibuf_ospfe, IMSG_LS_BADREQ,
					    imsg.hdr.peerid, 0, NULL, 0);
d486 2
a487 2
				imsg_compose(ibuf_ospfe, IMSG_LS_UPD,
				    imsg.hdr.peerid, 0, v->lsa,
d491 2
a492 2
				imsg_compose(ibuf_ospfe, IMSG_LS_ACK,
				    imsg.hdr.peerid, 0, &lsa->hdr,
d555 2
a556 2
			imsg_compose(ibuf_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    NULL, 0);
d560 2
a561 2
				imsg_compose(ibuf_ospfe, IMSG_CTL_AREA,
				    0, imsg.hdr.pid, area, sizeof(*area));
d569 2
a570 2
			imsg_compose(ibuf_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    NULL, 0);
d576 2
a577 2
			imsg_compose(ibuf_ospfe, IMSG_CTL_END, 0, imsg.hdr.pid,
			    NULL, 0);
d608 1
a608 1
		imsg_event_add(ibuf);
d611 1
a611 1
		event_del(&ibuf->ev);
d625 2
a626 1
	struct imsgbuf		*ibuf = bula;
d700 2
a701 2
				imsg_compose(ibuf_main, IMSG_KROUTE_DELETE, 0,
				    0, &kr, sizeof(kr));
d760 1
a760 1
		imsg_event_add(ibuf);
d763 1
a763 1
		event_del(&ibuf->ev);
d774 2
a775 1
	imsg_compose(ibuf_ospfe, IMSG_CTL_AREA, 0, pid, area, sizeof(*area));
d779 2
a780 2
		imsg_compose(ibuf_ospfe, IMSG_CTL_IFACE,
		    0, pid, iface, sizeof(*iface));
d813 2
a814 1
	imsg_compose(ibuf_main, IMSG_KROUTE_CHANGE, 0, 0, &kr, sizeof(kr));
d826 2
a827 1
	imsg_compose(ibuf_main, IMSG_KROUTE_DELETE, 0, 0, &kr, sizeof(kr));
@


1.29
log
@libevent handler fix to allow EV_READ and EV_WRITE to be set at the same
time in the callback. Same diff that went into ospfd applied with some
fuzz.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.28 2009/04/09 19:00:40 stsp Exp $ */
a266 1
		imsg_event_add(ibuf);
a634 1
		imsg_event_add(ibuf);
@


1.28
log
@Fix a naming inconsistency in struct lsa_intra_prefix (lsid -> ls_id).

"consistency is a good thing" jsing@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.27 2009/03/29 21:42:30 stsp Exp $ */
d258 1
a258 2
	switch (event) {
	case EV_READ:
d263 2
a264 2
		break;
	case EV_WRITE:
a267 3
		return;
	default:
		fatalx("unknown event");
d627 1
a627 2
	switch (event) {
	case EV_READ:
d632 2
a633 2
		break;
	case EV_WRITE:
a636 3
		return;
	default:
		fatalx("unknown event");
@


1.27
log
@As a first step towards SPF tree calculation, prepare for proper
next-hop calculation.

In OSPFv3, next-hop IP addresses are always link-local.
The kernel will want to know which interface the link-local
address belongs to, so we need an ifindex in struct v_nexthop
in addition to the IP address.

Because we cannot determine a link-local next hop IP address
for transit networks, only the outgoing interface will be recorded.

Update calc_nexthop_add() according to the above.

Also add new helpers calc_nexthop_lladdr() and calc_nexthop_transit_nbr(),
to figure out link-local addresses of nexthop neighbours.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.26 2009/03/12 01:21:49 stsp Exp $ */
d1241 1
a1241 1
	lsa->data.pref_intra.ref_lsid = htonl(iface->ifindex);
d1401 1
a1401 1
	lsa->data.pref_intra.ref_lsid = 0;
@


1.26
log
@lsa_self() did too many things at once, and had too much logic
buried inside of it that its caller relied on.

So split it up as follows:
lsa_self()    Check whether an LSA is self-originated.
lsa_flush()   Flush an LSA from the LSDB.
lsa_reflood() Prepare an LSA for reflooding (actual reflooding currently
              requires sending an imsg which must be done by the caller).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.25 2009/03/07 00:33:13 stsp Exp $ */
a51 1
struct rde_nbr	*rde_nbr_find(u_int32_t);
@


1.25
log
@Add lsa_find_tree() to allow searching for LSAs in a specific LSA tree.
We had code marked XXX searching an LSA tree manually using RB_FIND(),
switch it over to lsa_find_tree().
Make lsa_find() use the new function, too, to avoid code duplication.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.24 2009/02/19 22:21:17 stsp Exp $ */
d432 11
a442 4
				if (!(self = lsa_self(nbr, lsa, v)))
					if (lsa_add(nbr, lsa))
						/* delayed lsa */
						break;
d454 1
a454 1
				/* lsa not added so free it */
@


1.24
log
@Use rde_router_id() instead of directly accessing rdeconf->rtr_id.s_addr.

"For sure!" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.23 2009/02/19 22:19:53 stsp Exp $ */
a1485 1
	struct vertex	 key;
d1498 2
a1499 10
	/* XXX: lsa_find() should take an LSA tree as argument,
	 * if you have no iface at hand you cannot use it... */
	bzero(&key, sizeof(key));
	key.type = LSA_TYPE_INTRA_A_PREFIX;
	key.ls_id = LS_ID_INTRA_RTR;
	key.adv_rtr = ntohl(rde_router_id());
	old = RB_FIND(lsa_tree, &area->lsa_tree, &key);
	if (old && old->deleted)
		old = NULL;

@


1.23
log
@Enable origination of Intra-Area-Prefix LSAs in rde.

New Intra-Area-Prefix LSAs are originated when a neighbour
becomes adjacent, or when a neighbour loses adjacency,
or when an interface changes state.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.22 2009/02/19 22:17:07 stsp Exp $ */
d1236 1
a1236 1
	lsa->data.pref_intra.ref_adv_rtr = rdeconf->rtr_id.s_addr;
d1254 1
a1254 1
	lsa->hdr.adv_rtr = rdeconf->rtr_id.s_addr;
@


1.22
log
@Virtually re-implement origination of Intra-Area-Prefix LSAs.
We now comply with RFC5340 and move prefixes between the two
ref-types of Intra-Area-Prefix LSAs (router and network).

In case an LSA ends up having all of its prefixes moved to another
one, the LSA is flushed from the LSDB by re-originating with MAX_AGE.
(This does not yet work reliably. We end up having LSAs with zero
prefixes in the LSDB in some cases. Should not affect SPF calculation,
so not much harm done, but will need to be fixed.)

This commit just adds the necessary code to do origination,
but it is not being called yet. This will be done in a separate
commit.

"Looks good." claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.21 2009/02/19 22:05:32 stsp Exp $ */
d306 4
a309 2
			if (state != nbr->state && (nbr->state & NBR_STA_FULL ||
			    state & NBR_STA_FULL))
d311 2
d584 7
a590 1
			iface->state = ifp->state;
@


1.21
log
@Sync iface fsm state from ospfe to rde.

Also syncs other fields the ospfe is syncing to when getting
iface updates from parent process.
None of these fields are used by the rde yet, but state will be
important soon, for proper origination of Intra-Area-Prefix LSAs.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.20 2009/02/10 17:32:58 stsp Exp $ */
d66 10
a75 1
struct lsa	*orig_intra_lsa_net(struct area *, struct iface *);
d86 1
a86 3
void		 prefix_tree_add_net(struct prefix_tree *, struct lsa_link *);
void		 append_prefix_lsas(struct lsa **, u_int16_t *, u_int16_t *,
		    struct prefix_tree *);
a413 9

				if (lsa->hdr.type == htons(LSA_TYPE_NETWORK)) {
					struct lsa *intra;
					intra = orig_intra_lsa_net(nbr->area,
					    nbr->iface);
					if (intra)
						lsa_merge(nbr, intra, NULL);
				}

d1175 1
a1175 1
orig_intra_lsa_net(struct area *area, struct iface *iface)
d1179 2
a1180 1
	struct rde_nbr		*nbr;
d1185 3
d1191 29
d1228 4
a1231 32
	/* Build an RB tree of all global prefixes contained
	 * in this interface's link LSAs. This makes it easy
	 * to eliminate duplicates. */
	RB_INIT(&tree);
	RB_FOREACH(v, lsa_tree, &iface->lsa_tree) {
		if (v->lsa->hdr.type != htons(LSA_TYPE_LINK))
			continue;

		/* Make sure advertising router is adjacent... */
		LIST_FOREACH(nbr, &area->nbr_list, entry) {
			if (v->lsa->hdr.adv_rtr == nbr->id.s_addr)
				break;
		}
		if (!nbr) {
			fatalx("orig_intra_lsa_net: cannot find neighbor");
			free(lsa);
			return (NULL);
		}
		if (nbr->state < NBR_STA_2_WAY)
			continue;
		
		/* ... and that the LSA's link state ID matches
		 * the neighbour's interface ID. */
		if (ntohl(v->lsa->hdr.ls_id) != nbr->iface_id)
			continue;

		prefix_tree_add_net(&tree, &v->lsa->data.link);
	}

	if (RB_EMPTY(&tree)) {
		free(lsa);
		return NULL;
a1233 4
	append_prefix_lsas(&lsa, &len, &numprefix, &tree);
	if (lsa == NULL)
		fatalx("orig_intra_lsa_net: failed to append LSAs");

d1240 2
a1241 1
	lsa->hdr.age = htons(DEFAULT_AGE);
d1243 1
a1243 1
	lsa->hdr.ls_id = 0; /* TODO: fragmentation */
d1255 1
a1255 2
append_prefix_lsas(struct lsa **lsa, u_int16_t *len, u_int16_t *numprefix,
    struct prefix_tree *tree)
a1256 1
	struct prefix_node	*node;
d1262 2
a1263 1
	*numprefix = 0;
d1265 10
a1274 14
	RB_FOREACH(node, prefix_tree, tree) {
		lsa_prefix_len = sizeof(struct lsa_prefix)
		    + LSA_PREFIXSIZE(node->prefix->prefixlen);

		new_len = *len + lsa_prefix_len;

		/* Make sure we have enough space for this prefix. */
		if ((new_lsa = realloc(*lsa, new_len)) == NULL) {
			fatalx("append_prefix_lsas");
			free(*lsa);
			*lsa = NULL;
			*len = 0;
			return;
		}
d1276 2
a1277 9
		/* Append prefix to LSA. */
		copy = (struct lsa_prefix *)(new_lsa + *len);
		memcpy(copy, node->prefix, lsa_prefix_len);
		copy->metric = 0;

		*lsa = (struct lsa *)new_lsa;
		*len = new_len;
		(*numprefix)++;
	}
d1304 1
a1304 1
prefix_tree_add_net(struct prefix_tree *tree, struct lsa_link *lsa)
d1341 162
@


1.20
log
@Fix two obvious copy-paste errors in fatal error messages. We were
printing IFINFO while we are actually handling an IFDELETE imsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.19 2009/02/03 14:02:01 stsp Exp $ */
d245 1
d568 15
@


1.19
log
@Formatting fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.18 2009/01/29 12:16:09 stsp Exp $ */
d690 1
a690 1
				fatalx("IFINFO imsg with wrong len");
@


1.18
log
@Hard-code the Link State ID of Intra-Area-Prefix LSAs referencing Network
LSAs to zero. We were using the interface index, which is not quite right
for this type of LSA.

This is part of a greater scheme:
Intra-Area-Prefix LSAs referencing Router LSAs (not yet implemented)
will initially have their Link State ID hard-coded to one.
Then, as soon as we implement fragmentation of Intra-Area-Prefix LSAs,
Link State IDs for both types of Intra-Area-Prefix LSA will have to be
generated dynamically in a non-overlapping fashion.

discussed with claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.17 2009/01/29 11:57:42 stsp Exp $ */
d1322 3
a1324 3
		if (!(IN6_IS_ADDR_LINKLOCAL(&addr))
		    && (new->prefix->options & OSPF_PREFIX_NU) == 0
		    && (new->prefix->options & OSPF_PREFIX_LA) == 0) {
@


1.17
log
@Improve debugging message in orig_intra_lsa_net().
Print not just the area, but also the interface to the link the LSA
is generated for.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.16 2009/01/28 22:47:36 stsp Exp $ */
d1227 1
a1227 1
	lsa->hdr.ls_id = htonl(iface->ifindex);
@


1.16
log
@Teach ospf6d to originate Intra-Area-Prefix LSAs, which associate a list
of IPv6 prefixes with a Network LSA (there's another type of this LSA which
associates prefixes with a Router LSA -- this remains to be done).
Add what is necessary to allow ospf6ctl to read the new LSA type via IMSG.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.15 2009/01/27 12:52:08 michele Exp $ */
d1170 2
a1171 1
	log_debug("orig_intra_lsa_net: area %s", inet_ntoa(area->id));
@


1.15
log
@Again, no need to double check if neighbor exists.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.14 2009/01/03 00:23:50 stsp Exp $ */
d24 1
d66 14
d406 9
d517 1
a1155 1

d1157 1
a1157 1
 * functions for self-originated LSA
d1159 178
@


1.14
log
@Since link LSAs live in iface->lsa_tree and not in area->lsa_tree,
we had better include LSAs from iface->lsa_tree when sending
DB summaries. Fixes initial flood of link LSAs.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.13 2008/12/30 21:31:54 claudio Exp $ */
d267 1
a267 1
			if (rde_nbr_find(imsg.hdr.peerid))
a269 1
			rde_nbr_new(imsg.hdr.peerid, &rn);
@


1.13
log
@First try at originating Link (type-8) LSA. Code is wrong and the initial
LSA is lost in lsa_flood. Put this in because it goes in the right direction
and ospf6d is work in progress. Add necessary framework so that we can print
Link LSA in ospf6ctl.
Diff mostly from stsp@@ ospf6ctl part by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.12 2008/12/28 18:43:53 claudio Exp $ */
d297 1
a297 1
			lsa_snap(nbr->area, imsg.hdr.peerid);
@


1.12
log
@No need to byteswap req_hdr.type as lsa_find() will do that for us.
From Stefan Sperling
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.11 2008/02/11 13:48:39 norby Exp $ */
d491 1
@


1.11
log
@Correct the output of several error and debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.10 2007/12/13 08:54:05 claudio Exp $ */
d351 1
a351 1
				    ntohl(req_hdr.type), req_hdr.ls_id,
@


1.10
log
@Monster commit of stuff I did mostly last month. What it does:
 * removes kif and uses iface for everything interface related.
   This removes unneeded data redundancy which makes the code more complex.
 * adds the link local prefix to struct iface and attaches a list with
   the other prefixes to the struct iface. This is needed to generate the
   link LSA.
 * disconnects struct iface from struct area (the backpointer is gone)
   this will make the reload code a bit easier.
norby@@ agrees with the direction we're heading with this
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.9 2007/11/27 12:23:06 claudio Exp $ */
d498 1
a498 1
				log_warnx("rde_dispatch: wrong imsg len");
d544 1
a544 1
			log_debug("rde_dispatch_msg: unexpected imsg %d",
d601 2
a602 1
				log_warnx("rde_dispatch: wrong imsg len");
d616 2
a617 1
				log_warnx("rde_dispatch: wrong imsg len");
d636 2
a637 1
				log_warnx("rde_dispatch: wrong imsg len");
@


1.9
log
@Make lsa_find() find link local LSA by passing the interface instead of the
area as lookup point. Additionally make lsa_dump or actually the code around
it pass all LSA to ospf6ctl. The rde_spf.c are not final.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.8 2007/11/27 11:29:34 claudio Exp $ */
d564 1
a564 1
	struct iface		*niface;
d574 1
d647 25
a690 13
			break;
		case IMSG_RECONF_IFACE:
			if ((niface = malloc(sizeof(struct iface))) == NULL)
				fatal(NULL);
			memcpy(niface, imsg.data, sizeof(struct iface));

			LIST_INIT(&niface->nbr_list);
			TAILQ_INIT(&niface->ls_ack_list);
			RB_INIT(&niface->lsa_tree);

			niface->area = narea;
			LIST_INSERT_HEAD(&narea->iface_list, niface, entry);

@


1.8
log
@Monster diff to bring us a bit on track again.
a) implement all (or at least most) lsa_check() cases.
b) classify the LSA scope correctly and add a per interface lsa_tree for
   the link local stuff.
c) implement a function to parse a prefix.

There is still a lot missing currently link local LSA are added to the
interface tree but nothing can access them (lsa_find() and a few friends
need some changes).
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.7 2007/10/17 07:16:02 claudio Exp $ */
d45 1
d313 1
a313 1
				v = lsa_find(nbr->area, lsa_hdr.type,
d350 1
a350 1
				if ((v = lsa_find(nbr->area,
d382 1
a382 1
			v = lsa_find(nbr->area, lsa->hdr.type, lsa->hdr.ls_id,
d476 1
a476 1
			v = lsa_find(nbr->area, lsa_hdr.type, lsa_hdr.ls_id,
d503 1
a503 4
					imsg_compose(ibuf_ospfe, IMSG_CTL_AREA,
					    0, imsg.hdr.pid, area,
					    sizeof(*area));
					lsa_dump(&area->lsa_tree, imsg.hdr.type,
d511 1
a511 4
					imsg_compose(ibuf_ospfe, IMSG_CTL_AREA,
					    0, imsg.hdr.pid, area,
					    sizeof(*area));
					lsa_dump(&area->lsa_tree, imsg.hdr.type,
d697 19
@


1.7
log
@lsa_snap() should work so enable it.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.6 2007/10/16 20:27:24 claudio Exp $ */
d678 1
d869 1
d876 7
d889 1
@


1.6
log
@Enable the IMSG_DD related code. This code starts to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.5 2007/10/16 12:05:52 norby Exp $ */
d296 1
a296 2
//XXX needs work
//XXX			lsa_snap(nbr->area, imsg.hdr.peerid);
@


1.5
log
@In OSPFv3 the LSA type is a 16 bit value, furthermore it uses different
values than the v2 counterpart.

Change to u_int16_t and define new LSA types.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.4 2007/10/16 08:41:56 claudio Exp $ */
a307 1
#if 0	/* XXX does not work yet */
a334 1
#endif
@


1.4
log
@First step at making kroute IPv6 aware. This resulted in many additional
changes -- some are so hairy that I left them out for later by commenting out
larger blocks of code (just grep for XXX if you like to help).
Get it in early so that we can work on.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.3 2007/10/11 20:01:38 claudio Exp $ */
d1052 1
a1052 1
	u_int8_t		 type = 0;
d1074 1
a1074 1
		type = LSA_TYPE_SUM_NETWORK;
d1076 1
a1076 1
		type = LSA_TYPE_SUM_ROUTER;
a1077 1
		fatalx("rde_summary_update: unknown route type");
@


1.3
log
@Disable some code that is currently far from working and results in frequent
session resets because of bad packets. With this it seems we survive the
hello and database exchange phases. A closer look at the DR and BDR calculation
is still needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.2 2007/10/11 19:02:47 claudio Exp $ */
d646 1
a646 1
			if ((rn = rt_find(kr.prefix.s_addr, kr.prefixlen,
d726 2
a727 2
	kr.prefix.s_addr = r->prefix.s_addr;
	kr.nexthop.s_addr = rn->nexthop.s_addr;
d740 1
a740 1
	kr.prefix.s_addr = r->prefix.s_addr;
d1051 1
a1051 1
	struct lsa		*lsa;
d1080 1
d1088 1
d1102 1
d1111 1
a1111 1
	    inet_ntoa(rr->kr.prefix), rr->kr.prefixlen, age);
d1146 2
d1153 1
d1187 2
@


1.2
log
@From ospfd:
Bye bye global ospf options. OSPF options are per area (at least the one
flag that we set). So introduce a area_ospf_options() function that will
return the correct flags for each area. This makes stub area support a lot
easier.
Don't check for OSPF_OPTION_E in the parent. OSPF_OPTION_E is per area and
so the parent process has no way to know if it should redistribute or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.1 2007/10/08 10:44:51 norby Exp $ */
d296 2
a297 1
			lsa_snap(nbr->area, imsg.hdr.peerid);
d308 1
d336 1
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rde.c,v 1.69 2007/07/25 19:11:27 claudio Exp $ */
d63 1
a63 1
struct lsa	*orig_sum_lsa(struct rt_node *, u_int8_t, int);
d1079 1
a1079 1
	lsa = orig_sum_lsa(rte, type, rte->invalid);
d1143 1
a1143 1
orig_sum_lsa(struct rt_node *rte, u_int8_t type, int invalid)
@

