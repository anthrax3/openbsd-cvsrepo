head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.10
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.8
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.10
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8;
locks; strict;
comment	@ * @;


1.22
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.21;
commitid	kLBPo9HaQrkEaNW3;

1.21
date	2013.11.01.17.18.29;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2012.09.17.13.49.27;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.07.17.10.48;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.04.04.08.34;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.06.13.48.46;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.20.20.45.06;	author stsp;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.29.16.24.38;	author stsp;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.19.22.08.14;	author stsp;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.19.22.05.32;	author stsp;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.29.19.07.53;	author stsp;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.27.21.58.28;	author stsp;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.30.21.31.54;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.13.08.54.05;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.27.11.29.34;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.24.16.35.16;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.11.21.25.37;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.11.20.20.44;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.09.06.33.17;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.09.06.17.40;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2007.10.08.10.44.50;	author norby;	state Exp;
branches;
next	;


desc
@@


1.22
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@/*	$OpenBSD: interface.c,v 1.21 2013/11/01 17:18:29 deraadt Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005, 2007 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/if_types.h>
#include <ctype.h>
#include <err.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <event.h>

#include "ospf6d.h"
#include "ospf6.h"
#include "log.h"
#include "ospfe.h"

void		 if_hello_timer(int, short, void *);
void		 if_start_hello_timer(struct iface *);
void		 if_stop_hello_timer(struct iface *);
void		 if_stop_wait_timer(struct iface *);
void		 if_wait_timer(int, short, void *);
void		 if_start_wait_timer(struct iface *);
void		 if_stop_wait_timer(struct iface *);
struct nbr	*if_elect(struct nbr *, struct nbr *);

struct {
	int			state;
	enum iface_event	event;
	enum iface_action	action;
	int			new_state;
} iface_fsm[] = {
    /* current state	event that happened	action to take	resulting state */
    {IF_STA_DOWN,	IF_EVT_UP,		IF_ACT_STRT,	0},
    {IF_STA_WAITING,	IF_EVT_BACKUP_SEEN,	IF_ACT_ELECT,	0},
    {IF_STA_WAITING,	IF_EVT_WTIMER,		IF_ACT_ELECT,	0},
    {IF_STA_ANY,	IF_EVT_WTIMER,		IF_ACT_NOTHING,	0},
    {IF_STA_WAITING,	IF_EVT_NBR_CHNG,	IF_ACT_NOTHING,	0},
    {IF_STA_MULTI,	IF_EVT_NBR_CHNG,	IF_ACT_ELECT,	0},
    {IF_STA_ANY,	IF_EVT_NBR_CHNG,	IF_ACT_NOTHING,	0},
    {IF_STA_ANY,	IF_EVT_DOWN,		IF_ACT_RST,	IF_STA_DOWN},
    {IF_STA_ANY,	IF_EVT_LOOP,		IF_ACT_RST,	IF_STA_LOOPBACK},
    {IF_STA_LOOPBACK,	IF_EVT_UNLOOP,		IF_ACT_NOTHING,	IF_STA_DOWN},
    {-1,		IF_EVT_NOTHING,		IF_ACT_NOTHING,	0},
};

#if 0
/* TODO virtual links */
static int vlink_cnt = 0;
#endif

TAILQ_HEAD(, iface)	iflist;

const char * const if_event_names[] = {
	"NOTHING",
	"UP",
	"WAITTIMER",
	"BACKUPSEEN",
	"NEIGHBORCHANGE",
	"LOOP",
	"UNLOOP",
	"DOWN"
};

const char * const if_action_names[] = {
	"NOTHING",
	"START",
	"ELECT",
	"RESET"
};

int
if_fsm(struct iface *iface, enum iface_event event)
{
	int	old_state;
	int	new_state = 0;
	int	i, ret = 0;

	old_state = iface->state;

	for (i = 0; iface_fsm[i].state != -1; i++)
		if ((iface_fsm[i].state & old_state) &&
		    (iface_fsm[i].event == event)) {
			new_state = iface_fsm[i].new_state;
			break;
		}

	if (iface_fsm[i].state == -1) {
		/* event outside of the defined fsm, ignore it. */
		log_debug("if_fsm: interface %s, "
		    "event %s not expected in state %s", iface->name,
		    if_event_names[event], if_state_name(old_state));
		return (0);
	}

	switch (iface_fsm[i].action) {
	case IF_ACT_STRT:
		ret = if_act_start(iface);
		break;
	case IF_ACT_ELECT:
		ret = if_act_elect(iface);
		break;
	case IF_ACT_RST:
		ret = if_act_reset(iface);
		break;
	case IF_ACT_NOTHING:
		/* do nothing */
		break;
	}

	if (ret) {
		log_debug("if_fsm: error changing state for interface %s, "
		    "event %s, state %s", iface->name, if_event_names[event],
		    if_state_name(old_state));
		return (-1);
	}

	if (new_state != 0)
		iface->state = new_state;

	if (iface->state != old_state) {
		orig_rtr_lsa(iface);
		orig_link_lsa(iface);

		/* state change inform RDE */
		ospfe_imsg_compose_rde(IMSG_IFINFO, iface->self->peerid, 0,
		    &iface->state, sizeof(iface->state));
	}

	if (old_state & (IF_STA_MULTI | IF_STA_POINTTOPOINT) &&
	    (iface->state & (IF_STA_MULTI | IF_STA_POINTTOPOINT)) == 0)
		ospfe_demote_iface(iface, 0);
	if ((old_state & (IF_STA_MULTI | IF_STA_POINTTOPOINT)) == 0 &&
	    iface->state & (IF_STA_MULTI | IF_STA_POINTTOPOINT))
		ospfe_demote_iface(iface, 1);

	log_debug("if_fsm: event %s resulted in action %s and changing "
	    "state for interface %s from %s to %s",
	    if_event_names[event], if_action_names[iface_fsm[i].action],
	    iface->name, if_state_name(old_state), if_state_name(iface->state));

	return (ret);
}

int
if_init(void)
{
	TAILQ_INIT(&iflist);

	return (fetchifs(0));
}

/* XXX using a linked list should be OK for now */
struct iface *
if_find(unsigned int ifindex)
{
	struct iface	*iface;

	TAILQ_FOREACH(iface, &iflist, list) {
		if (ifindex == iface->ifindex)
			return (iface);
	}
	return (NULL);
}

struct iface *
if_findname(char *name)
{
	struct iface	*iface;

	TAILQ_FOREACH(iface, &iflist, list) {
		if (!strcmp(name, iface->name))
			return (iface);
	}
	return (NULL);
}

struct iface *
if_new(u_short ifindex, char *ifname)
{
	struct iface		*iface;

	if ((iface = calloc(1, sizeof(*iface))) == NULL)
		err(1, "if_new: calloc");

	iface->state = IF_STA_DOWN;

	LIST_INIT(&iface->nbr_list);
	TAILQ_INIT(&iface->ifa_list);
	TAILQ_INIT(&iface->ls_ack_list);
	RB_INIT(&iface->lsa_tree);

#if 0
	/* TODO */
	if (virtual) {
		iface->type = IF_TYPE_VIRTUALLINK;
		snprintf(iface->name, sizeof(iface->name), "vlink%d",
		    vlink_cnt++);
		iface->flags |= IFF_UP;
		iface->mtu = IP_MSS;
		return (iface);
	}
#endif
	strlcpy(iface->name, ifname, sizeof(iface->name));
	iface->ifindex = ifindex;

	TAILQ_INSERT_TAIL(&iflist, iface, list);

	return (iface);
}

void
if_update(struct iface *iface, int mtu, int flags, u_int8_t type,
    u_int8_t state, u_int64_t rate)
{
	iface->mtu = mtu;
	iface->flags = flags;
	iface->if_type = type;
	iface->linkstate = state;
	iface->baudrate = rate;

	/* set type */
	if (flags & IFF_POINTOPOINT)
		iface->type = IF_TYPE_POINTOPOINT;
	if (flags & IFF_BROADCAST && flags & IFF_MULTICAST)
		iface->type = IF_TYPE_BROADCAST;
	if (flags & IFF_LOOPBACK) {
		iface->type = IF_TYPE_POINTOPOINT;
		iface->cflags |= F_IFACE_PASSIVE;
	}
}

void
if_del(struct iface *iface)
{
	struct nbr	*nbr = NULL;

	log_debug("if_del: interface %s", iface->name);

	/* revert the demotion when the interface is deleted */
	if ((iface->state & (IF_STA_MULTI | IF_STA_POINTTOPOINT)) == 0)
		ospfe_demote_iface(iface, 1);

	/* clear lists etc */
	while ((nbr = LIST_FIRST(&iface->nbr_list)) != NULL)
		nbr_del(nbr);

	if (evtimer_pending(&iface->hello_timer, NULL))
		evtimer_del(&iface->hello_timer);
	if (evtimer_pending(&iface->wait_timer, NULL))
		evtimer_del(&iface->wait_timer);
	if (evtimer_pending(&iface->lsack_tx_timer, NULL))
		evtimer_del(&iface->lsack_tx_timer);

	ls_ack_list_clr(iface);
	TAILQ_REMOVE(&iflist, iface, list);
	free(iface);
}

void
if_start(struct ospfd_conf *xconf, struct iface *iface)
{
	/* init the dummy local neighbor */
	iface->self = nbr_new(ospfe_router_id(), iface, iface->ifindex, 1,
			NULL);

	/* set event handlers for interface */
	evtimer_set(&iface->lsack_tx_timer, ls_ack_tx_timer, iface);
	evtimer_set(&iface->hello_timer, if_hello_timer, iface);
	evtimer_set(&iface->wait_timer, if_wait_timer, iface);

	iface->fd = xconf->ospf_socket;

	ospfe_demote_iface(iface, 0);

	if (if_fsm(iface, IF_EVT_UP))
		log_debug("error starting interface %s", iface->name);
}

/* timers */
/* ARGSUSED */
void
if_hello_timer(int fd, short event, void *arg)
{
	struct iface *iface = arg;
	struct timeval tv;

	send_hello(iface);

	/* reschedule hello_timer */
	timerclear(&tv);
	tv.tv_sec = iface->hello_interval;
	if (evtimer_add(&iface->hello_timer, &tv) == -1)
		fatal("if_hello_timer");
}

void
if_start_hello_timer(struct iface *iface)
{
	struct timeval tv;

	timerclear(&tv);
	if (evtimer_add(&iface->hello_timer, &tv) == -1)
		fatal("if_start_hello_timer");
}

void
if_stop_hello_timer(struct iface *iface)
{
	if (evtimer_del(&iface->hello_timer) == -1)
		fatal("if_stop_hello_timer");
}

/* ARGSUSED */
void
if_wait_timer(int fd, short event, void *arg)
{
	struct iface *iface = arg;

	if_fsm(iface, IF_EVT_WTIMER);
}

void
if_start_wait_timer(struct iface *iface)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = iface->dead_interval;
	if (evtimer_add(&iface->wait_timer, &tv) == -1)
		fatal("if_start_wait_timer");
}

void
if_stop_wait_timer(struct iface *iface)
{
	if (evtimer_del(&iface->wait_timer) == -1)
		fatal("if_stop_wait_timer");
}

/* actions */
int
if_act_start(struct iface *iface)
{
	struct in6_addr		 addr;
	struct timeval		 now;

	if (!((iface->flags & IFF_UP) &&
	    LINK_STATE_IS_UP(iface->linkstate))) {
		log_debug("if_act_start: interface %s link down",
		    iface->name);
		return (0);
	}

	if (iface->if_type == IFT_CARP &&
	    !(iface->cflags & F_IFACE_PASSIVE)) {
		/* force passive mode on carp interfaces */
		log_warnx("if_act_start: forcing interface %s to passive",
		    iface->name);
		iface->cflags |= F_IFACE_PASSIVE;
	}

	gettimeofday(&now, NULL);
	iface->uptime = now.tv_sec;

	/* loopback interfaces have a special state */
	if (iface->flags & IFF_LOOPBACK)
		iface->state = IF_STA_LOOPBACK;

	if (iface->cflags & F_IFACE_PASSIVE) {
		/* for an update of stub network entries */
		orig_rtr_lsa(iface);
		return (0);
	}

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
		inet_pton(AF_INET6, AllSPFRouters, &addr);

		if (if_join_group(iface, &addr))
			return (-1);
		iface->state = IF_STA_POINTTOPOINT;
		break;
	case IF_TYPE_VIRTUALLINK:
		iface->state = IF_STA_POINTTOPOINT;
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_NBMA:
		log_debug("if_act_start: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	case IF_TYPE_BROADCAST:
		inet_pton(AF_INET6, AllSPFRouters, &addr);

		if (if_join_group(iface, &addr))
			return (-1);
		if (iface->priority == 0) {
			iface->state = IF_STA_DROTHER;
		} else {
			iface->state = IF_STA_WAITING;
			if_start_wait_timer(iface);
		}
		break;
	default:
		fatalx("if_act_start: unknown interface type");
	}

	/* hello timer needs to be started in any case */
	if_start_hello_timer(iface);
	return (0);
}

struct nbr *
if_elect(struct nbr *a, struct nbr *b)
{
	if (a->priority > b->priority)
		return (a);
	if (a->priority < b->priority)
		return (b);
	if (ntohl(a->id.s_addr) > ntohl(b->id.s_addr))
		return (a);
	return (b);
}

int
if_act_elect(struct iface *iface)
{
	struct in6_addr	 addr;
	struct nbr	*nbr, *bdr = NULL, *dr = NULL;
	int		 round = 0;
	int		 changed = 0;
	int		 old_state;
	char		 b1[16], b2[16], b3[16], b4[16];

start:
	/* elect backup designated router */
	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr->priority == 0 || nbr == dr ||	/* not electable */
		    nbr->state & NBR_STA_PRELIM ||	/* not available */
		    nbr->dr.s_addr == nbr->id.s_addr)	/* don't elect DR */
			continue;
		if (bdr != NULL) {
			/*
			 * routers announcing themselves as BDR have higher
			 * precedence over those routers announcing a
			 * different BDR.
			 */
			if (nbr->bdr.s_addr == nbr->id.s_addr) {
				if (bdr->bdr.s_addr == bdr->id.s_addr)
					bdr = if_elect(bdr, nbr);
				else
					bdr = nbr;
			} else if (bdr->bdr.s_addr != bdr->id.s_addr)
					bdr = if_elect(bdr, nbr);
		} else
			bdr = nbr;
	}

	/* elect designated router */
	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr->priority == 0 || nbr->state & NBR_STA_PRELIM ||
		    (nbr != dr && nbr->dr.s_addr != nbr->id.s_addr))
			/* only DR may be elected check priority too */
			continue;
		if (dr == NULL)
			dr = nbr;
		else
			dr = if_elect(dr, nbr);
	}

	if (dr == NULL) {
		/* no designate router found use backup DR */
		dr = bdr;
		bdr = NULL;
	}

	/*
	 * if we are involved in the election (e.g. new DR or no
	 * longer BDR) redo the election
	 */
	if (round == 0 &&
	    ((iface->self == dr && iface->self != iface->dr) ||
	    (iface->self != dr && iface->self == iface->dr) ||
	    (iface->self == bdr && iface->self != iface->bdr) ||
	    (iface->self != bdr && iface->self == iface->bdr))) {
		/*
		 * Reset announced DR/BDR to calculated one, so
		 * that we may get elected in the second round.
		 * This is needed to drop from a DR to a BDR.
		 */
		iface->self->dr.s_addr = dr->id.s_addr;
		if (bdr)
			iface->self->bdr.s_addr = bdr->id.s_addr;
		round = 1;
		goto start;
	}

	log_debug("if_act_elect: interface %s old dr %s new dr %s, "
	    "old bdr %s new bdr %s", iface->name,
	    iface->dr ? inet_ntop(AF_INET, &iface->dr->id, b1, sizeof(b1)) :
	    "none", dr ? inet_ntop(AF_INET, &dr->id, b2, sizeof(b2)) : "none",
	    iface->bdr ? inet_ntop(AF_INET, &iface->bdr->id, b3, sizeof(b3)) :
	    "none", bdr ? inet_ntop(AF_INET, &bdr->id, b4, sizeof(b4)) :
	    "none");

	/*
	 * After the second round still DR or BDR change state to DR or BDR,
	 * etc.
	 */
	old_state = iface->state;
	if (dr == iface->self)
		iface->state = IF_STA_DR;
	else if (bdr == iface->self)
		iface->state = IF_STA_BACKUP;
	else
		iface->state = IF_STA_DROTHER;

	/* TODO if iface is NBMA send all non eligible neighbors event Start */

	/*
	 * if DR or BDR changed issue a AdjOK? event for all neighbors > 2-Way
	 */
	if (iface->dr != dr || iface->bdr != bdr)
		changed = 1;

	iface->dr = dr;
	iface->bdr = bdr;

	if (changed) {
		inet_pton(AF_INET6, AllDRouters, &addr);
		if (old_state & IF_STA_DRORBDR &&
		    (iface->state & IF_STA_DRORBDR) == 0) {
			if (if_leave_group(iface, &addr))
				return (-1);
		} else if ((old_state & IF_STA_DRORBDR) == 0 &&
		    iface->state & IF_STA_DRORBDR) {
			if (if_join_group(iface, &addr))
				return (-1);
		}

		LIST_FOREACH(nbr, &iface->nbr_list, entry) {
			if (nbr->state & NBR_STA_BIDIR)
				nbr_fsm(nbr, NBR_EVT_ADJ_OK);
		}

		orig_rtr_lsa(iface);
		if (iface->state & IF_STA_DR || old_state & IF_STA_DR)
			orig_net_lsa(iface);
	}

	if_start_hello_timer(iface);
	return (0);
}

int
if_act_reset(struct iface *iface)
{
	struct nbr		*nbr = NULL;
	struct in6_addr		 addr;

	if (iface->cflags & F_IFACE_PASSIVE) {
		/* for an update of stub network entries */
		orig_rtr_lsa(iface);
		return (0);
	}

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		inet_pton(AF_INET6, AllSPFRouters, &addr);
		if (if_leave_group(iface, &addr)) {
			log_warnx("if_act_reset: error leaving group %s, "
			    "interface %s", log_in6addr(&addr), iface->name);
		}
		if (iface->state & IF_STA_DRORBDR) {
			inet_pton(AF_INET6, AllDRouters, &addr);
			if (if_leave_group(iface, &addr)) {
				log_warnx("if_act_reset: "
				    "error leaving group %s, interface %s",
				    log_in6addr(&addr), iface->name);
			}
		}
		break;
	case IF_TYPE_VIRTUALLINK:
		/* nothing */
		break;
	case IF_TYPE_NBMA:
	case IF_TYPE_POINTOMULTIPOINT:
		log_debug("if_act_reset: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	default:
		fatalx("if_act_reset: unknown interface type");
	}

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr_fsm(nbr, NBR_EVT_KILL_NBR)) {
			log_debug("if_act_reset: error killing neighbor %s",
			    inet_ntoa(nbr->id));
		}
	}

	iface->dr = NULL;
	iface->bdr = NULL;

	ls_ack_list_clr(iface);
	stop_ls_ack_tx_timer(iface);
	if_stop_hello_timer(iface);
	if_stop_wait_timer(iface);

	/* send empty hello to tell everybody that we are going down */
	send_hello(iface);

	return (0);
}

struct ctl_iface *
if_to_ctl(struct iface *iface)
{
	static struct ctl_iface	 ictl;
	struct timeval		 tv, now, res;
	struct nbr		*nbr;

	memcpy(ictl.name, iface->name, sizeof(ictl.name));
	memcpy(&ictl.addr, &iface->addr, sizeof(ictl.addr));
	ictl.rtr_id.s_addr = ospfe_router_id();
	memcpy(&ictl.area, &iface->area_id, sizeof(ictl.area));
	if (iface->dr) {
		memcpy(&ictl.dr_id, &iface->dr->id, sizeof(ictl.dr_id));
		memcpy(&ictl.dr_addr, &iface->dr->addr, sizeof(ictl.dr_addr));
	} else {
		bzero(&ictl.dr_id, sizeof(ictl.dr_id));
		bzero(&ictl.dr_addr, sizeof(ictl.dr_addr));
	}
	if (iface->bdr) {
		memcpy(&ictl.bdr_id, &iface->bdr->id, sizeof(ictl.bdr_id));
		memcpy(&ictl.bdr_addr, &iface->bdr->addr,
		    sizeof(ictl.bdr_addr));
	} else {
		bzero(&ictl.bdr_id, sizeof(ictl.bdr_id));
		bzero(&ictl.bdr_addr, sizeof(ictl.bdr_addr));
	}
	ictl.ifindex = iface->ifindex;
	ictl.state = iface->state;
	ictl.mtu = iface->mtu;
	ictl.nbr_cnt = 0;
	ictl.adj_cnt = 0;
	ictl.baudrate = iface->baudrate;
	ictl.dead_interval = iface->dead_interval;
	ictl.transmit_delay = iface->transmit_delay;
	ictl.hello_interval = iface->hello_interval;
	ictl.flags = iface->flags;
	ictl.metric = iface->metric;
	ictl.rxmt_interval = iface->rxmt_interval;
	ictl.type = iface->type;
	ictl.linkstate = iface->linkstate;
	ictl.if_type = iface->if_type;
	ictl.priority = iface->priority;
	ictl.passive = (iface->cflags & F_IFACE_PASSIVE) == F_IFACE_PASSIVE;

	gettimeofday(&now, NULL);
	if (evtimer_pending(&iface->hello_timer, &tv)) {
		timersub(&tv, &now, &res);
		ictl.hello_timer = res.tv_sec;
	} else
		ictl.hello_timer = -1;

	if (iface->state != IF_STA_DOWN) {
		ictl.uptime = now.tv_sec - iface->uptime;
	} else
		ictl.uptime = 0;

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr == iface->self)
			continue;
		ictl.nbr_cnt++;
		if (nbr->state & NBR_STA_ADJFORM)
			ictl.adj_cnt++;
	}

	return (&ictl);
}

/* misc */
void
if_set_recvbuf(int fd)
{
	int	bsize;

	bsize = 65535;
	while (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, &bsize,
	    sizeof(bsize)) == -1)
		bsize /= 2;
}

int
if_join_group(struct iface *iface, struct in6_addr *addr)
{
	struct ipv6_mreq	 mreq;

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		log_debug("if_join_group: interface %s addr %s",
		    iface->name, log_in6addr(addr));
		mreq.ipv6mr_multiaddr = *addr;
		mreq.ipv6mr_interface = iface->ifindex;

		if (setsockopt(iface->fd, IPPROTO_IPV6, IPV6_JOIN_GROUP,
		    &mreq, sizeof(mreq)) < 0) {
			log_warn("if_join_group: error IPV6_JOIN_GROUP, "
			    "interface %s address %s", iface->name,
			    log_in6addr(addr));
			return (-1);
		}
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_NBMA:
		log_debug("if_join_group: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	default:
		fatalx("if_join_group: unknown interface type");
	}

	return (0);
}

int
if_leave_group(struct iface *iface, struct in6_addr *addr)
{
	struct ipv6_mreq	 mreq;

	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		log_debug("if_leave_group: interface %s addr %s",
		    iface->name, log_in6addr(addr));
		mreq.ipv6mr_multiaddr = *addr;
		mreq.ipv6mr_interface = iface->ifindex;

		if (setsockopt(iface->fd, IPPROTO_IPV6, IPV6_LEAVE_GROUP,
		    (void *)&mreq, sizeof(mreq)) < 0) {
			log_warn("if_leave_group: error IPV6_LEAVE_GROUP, "
			    "interface %s address %s", iface->name,
			    log_in6addr(addr));
			return (-1);
		}
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_NBMA:
		log_debug("if_leave_group: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	default:
		fatalx("if_leave_group: unknown interface type");
	}
	return (0);
}

int
if_set_mcast(struct iface *iface)
{
	switch (iface->type) {
	case IF_TYPE_POINTOPOINT:
	case IF_TYPE_BROADCAST:
		if (setsockopt(iface->fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,
		    &iface->ifindex, sizeof(iface->ifindex)) < 0) {
			log_debug("if_set_mcast: error setting "
			    "IP_MULTICAST_IF, interface %s", iface->name);
			return (-1);
		}
		break;
	case IF_TYPE_POINTOMULTIPOINT:
	case IF_TYPE_VIRTUALLINK:
	case IF_TYPE_NBMA:
		log_debug("if_set_mcast: type %s not supported, interface %s",
		    if_type_name(iface->type), iface->name);
		return (-1);
	default:
		fatalx("if_set_mcast: unknown interface type");
	}

	return (0);
}

int
if_set_mcast_loop(int fd)
{
	u_int	loop = 0;

	if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,
	    (u_int *)&loop, sizeof(loop)) < 0) {
		log_warn("if_set_mcast_loop: error setting "
		    "IPV6_MULTICAST_LOOP");
		return (-1);
	}

	return (0);
}

int
if_set_ipv6_pktinfo(int fd, int enable)
{
	if (setsockopt(fd, IPPROTO_IPV6, IPV6_RECVPKTINFO, &enable,
	    sizeof(enable)) < 0) {
		log_warn("if_set_ipv6_pktinfo: error setting IPV6_PKTINFO");
		return (-1);
	}

	return (0);
}

int
if_set_ipv6_checksum(int fd)
{
	int	offset = offsetof(struct ospf_hdr, chksum);

	log_debug("if_set_ipv6_checksum setting cksum offset to %d", offset);
	if (setsockopt(fd, IPPROTO_IPV6, IPV6_CHECKSUM, &offset,
	     sizeof(offset)) < 0) {
		log_warn("if_set_ipv6_checksum: error setting IPV6_CHECKSUM");
		return (-1);
	}
	return (0);
}
@


1.21
log
@another annoying %i
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.20 2012/09/17 13:49:27 bluhm Exp $ */
d242 1
a242 1
	iface->media_type = type;
d379 1
a379 1
	if (iface->media_type == IFT_CARP &&
d681 1
a681 1
	ictl.mediatype = iface->media_type;
@


1.20
log
@Fix trailing whitespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.19 2011/07/07 17:10:48 claudio Exp $ */
d845 1
a845 1
	log_debug("if_set_ipv6_checksum setting cksum offset to %i", offset);
@


1.19
log
@Rework the distribution of link state and iface FSM state changes.
Link state changes are sent from the parent to both childs and
iface FSM state changes are sent from the ospfe to the rde.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.18 2011/07/04 04:34:14 claudio Exp $ */
d153 1
a153 1
	
@


1.18
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.17 2011/07/04 04:08:34 claudio Exp $ */
d148 4
a153 4
	/* Inform RDE in any case since the link state may have changed */
	ospfe_imsg_compose_rde(IMSG_IFINFO,
	    iface->self->peerid, 0, iface, sizeof(struct iface));

@


1.17
log
@Make sure that passive interfaces (like carp) are added to the
intra-area rtr LSA. Diff initialy made by Patrick Coleman but
simplified by myself. Tested and OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.16 2011/05/06 13:48:46 claudio Exp $ */
d373 1
a373 3
	    (LINK_STATE_IS_UP(iface->linkstate) ||
	    (iface->linkstate == LINK_STATE_UNKNOWN &&
	    iface->media_type != IFT_CARP)))) {
@


1.16
log
@Do not special case loopback interfaces on init. Instead force them
to IF_STA_LOOPBACK in if_act_start() this way they will repsect
IFF_UP on startup. Also mark the interfaces as passive.
Initial diff provided by Patrick Coleman. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.15 2009/09/20 20:45:06 stsp Exp $ */
a147 4

		/* state change inform RDE */
		ospfe_imsg_compose_rde(IMSG_IFINFO,
		    iface->self->peerid, 0, iface, sizeof(struct iface));
d149 4
@


1.15
log
@if_new() would treat the new interface as a virtual link if the ifname
parameter was NULL. But it's easy enough to make ifname != NULL by accident,
e.g. by passing a zeroed or even uninitialised array. This function should
accept a 'virtual' flag of some kind instead.
Since we don't even support virtual links yet, change the check to
"if (virtual)", #if 0 the check, and code that depends on it (including
a file-scope variable), and add comments marking this as TODO.

ok claudio, who requested #if 0 instead of deletion.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.14 2009/03/29 16:24:38 stsp Exp $ */
d253 1
a253 1
		iface->state = IF_STA_LOOPBACK;
d389 7
a400 3

	gettimeofday(&now, NULL);
	iface->uptime = now.tv_sec;
@


1.14
log
@For SPF calculation, we will need the source address specified
in hello packets by next-hop neighbours. So when notifying the
RDE of a new neighbour, send the source address, too.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.13 2009/02/19 22:08:14 stsp Exp $ */
d71 2
d74 1
d217 3
a219 1
	if (ifname == NULL) {
d227 1
a227 1

@


1.13
log
@Remove origination of Intra-Area-Prefix LSAs from ospfe.
Will soon be done in rde instead.

"Sure but don't wait too long before readding the code in rde" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.12 2009/02/19 22:05:32 stsp Exp $ */
d283 2
a284 1
	iface->self = nbr_new(ospfe_router_id(), iface, iface->ifindex, 1);
@


1.12
log
@Sync iface fsm state from ospfe to rde.

Also syncs other fields the ospfe is syncing to when getting
iface updates from parent process.
None of these fields are used by the rde yet, but state will be
important soon, for proper origination of Intra-Area-Prefix LSAs.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.11 2009/01/29 19:07:53 stsp Exp $ */
a144 1
		orig_intra_lsa_rtr(iface);
@


1.11
log
@Originate Intra-Area-Prefix LSAs which reference a router LSA.
Routers can now advertise prefixes with global scope throughout
an area. This paves the way towards doing SPF calculations to
generate routing tables for a single area.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.10 2009/01/27 21:58:28 stsp Exp $ */
d146 4
@


1.10
log
@Propagate the neighbour's interface ID, as received in hello packets,
to the RDE.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.9 2008/12/30 21:31:54 claudio Exp $ */
d145 1
@


1.9
log
@First try at originating Link (type-8) LSA. Code is wrong and the initial
LSA is lost in lsa_flood. Put this in because it goes in the right direction
and ospf6d is work in progress. Add necessary framework so that we can print
Link LSA in ospf6ctl.
Diff mostly from stsp@@ ospf6ctl part by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.8 2007/12/13 08:54:05 claudio Exp $ */
d279 1
a279 1
	iface->self = nbr_new(ospfe_router_id(), iface, 1);
@


1.8
log
@Monster commit of stuff I did mostly last month. What it does:
 * removes kif and uses iface for everything interface related.
   This removes unneeded data redundancy which makes the code more complex.
 * adds the link local prefix to struct iface and attaches a list with
   the other prefixes to the struct iface. This is needed to generate the
   link LSA.
 * disconnects struct iface from struct area (the backpointer is gone)
   this will make the reload code a bit easier.
norby@@ agrees with the direction we're heading with this
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.7 2007/11/27 11:29:34 claudio Exp $ */
d142 1
a142 1
	if (iface->state != old_state)
d144 2
@


1.7
log
@Monster diff to bring us a bit on track again.
a) implement all (or at least most) lsa_check() cases.
b) classify the LSA scope correctly and add a per interface lsa_tree for
   the link local stuff.
c) implement a function to parse a prefix.

There is still a lot missing currently link local LSA are added to the
interface tree but nothing can access them (lsa_find() and a few friends
need some changes).
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.6 2007/11/24 16:35:16 claudio Exp $ */
d73 2
d143 1
a143 1
		orig_rtr_lsa(iface->area);
d160 33
d194 1
a194 1
if_new(struct kif *kif, struct kif_addr *ka)
d204 1
d208 1
a208 1
	if (kif == NULL) {
d217 4
a220 1
	strlcpy(iface->name, kif->ifname, sizeof(iface->name));
d222 15
a236 2
	/* get type */
	if (kif->flags & IFF_POINTOPOINT)
d238 1
a238 2
	if (kif->flags & IFF_BROADCAST &&
	    kif->flags & IFF_MULTICAST)
d240 1
a240 1
	if (kif->flags & IFF_LOOPBACK) {
a243 16

	/* get mtu, index and flags */
	iface->mtu = kif->mtu;
	iface->ifindex = kif->ifindex;
	iface->flags = kif->flags;
	iface->linkstate = kif->link_state;
	iface->media_type = kif->media_type;
	iface->baudrate = kif->baudrate;

	/* set address, mask and p2p addr */
	iface->addr = ka->addr;
	if (kif->flags & IFF_POINTOPOINT) {
		iface->dst = ka->dstbrd;
	}

	return (iface);
d269 1
d274 1
a274 1
if_init(struct ospfd_conf *xconf, struct iface *iface)
d287 3
d369 2
a370 1
	if (iface->media_type == IFT_CARP && iface->passive == 0) {
d374 1
a374 1
		iface->passive = 1;
d377 1
a377 1
	if (iface->passive) {
d379 1
a379 1
		orig_rtr_lsa(iface->area);
d556 1
a556 1
		orig_rtr_lsa(iface->area);
d571 1
a571 1
	if (iface->passive) {
d573 1
a573 1
		orig_rtr_lsa(iface->area);
d637 1
a637 1
	memcpy(&ictl.area, &iface->area->id, sizeof(ictl.area));
d669 1
a669 1
	ictl.passive = iface->passive;
@


1.6
log
@Print the neighbor ID instead of the neighbor address in if_act_elect().
Neighbors are identified by ID in OSPF v3 and trying to print a IPv6 addr
as AF_INET was wrong anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.5 2007/10/11 21:25:37 claudio Exp $ */
d170 1
@


1.5
log
@No need to store the interface mask. An interface represents a link and is
only addressed via its link local address. All networks on top of it are
handled separately via type 8 Link-LSA.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.4 2007/10/11 20:20:44 claudio Exp $ */
d469 4
a472 4
	    iface->dr ? inet_ntop(AF_INET, &iface->dr->addr, b1, sizeof(b1)) :
	    "none", dr ? inet_ntop(AF_INET, &dr->addr, b2, sizeof(b2)) : "none",
	    iface->bdr ? inet_ntop(AF_INET, &iface->bdr->addr, b3, sizeof(b3)) :
	    "none", bdr ? inet_ntop(AF_INET, &bdr->addr, b4, sizeof(b4)) :
@


1.4
log
@In OSPFv3 auth crypt is no longer (actually all the auth code is gone) so
kill crypt_seq_num as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.3 2007/10/09 06:33:17 claudio Exp $ */
a202 1
	iface->mask = ka->mask;
a594 1
	memcpy(&ictl.mask, &iface->mask, sizeof(ictl.mask));
@


1.3
log
@Unneeded and to noisy debug output
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.2 2007/10/09 06:17:40 claudio Exp $ */
a169 2

	iface->crypt_seq_num = arc4random() & 0x0fffffff;
@


1.2
log
@Instead of IP_RECVIF we use IPV6_RECVPKTINFO to get the ifindex and the
destination address of incomming packets. This also removes the need for
IP_HDRINCL. Additionally use IPV6_CHECKSUM to let the kernel do the
necessary packet checksumming, way easier than doing it in userland.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.1 2007/10/08 10:44:50 norby Exp $ */
a741 1
		log_debug("if_set_mcast: iface %s", iface->name);
@


1.1
log
@Welcome ospf6d

The new ospf6d daemon will support OSPFv3, basically OSPF for IPv6 networks.

It is heavily based on ospfd(8), it is more or less a copy and paste of it.
Currently some unneeded stuff has been removed and the trasition from
IPv4 to IPv6 has begun.

ospf6d is not very usefull at the moment, it is being imported to allow more
people to work on it concurrently.

Not yet connected to the builds.

ok claudio@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: interface.c,v 1.59 2007/05/29 22:08:25 claudio Exp $ */
d30 1
a657 13
int
if_set_recvif(int fd, int enable)
{
#if 0
	if (setsockopt(fd, IPPROTO_IPV6, IP_RECVIF, &enable,
	    sizeof(enable)) < 0) {
		log_warn("if_set_recvif: error setting IP_RECVIF");
		return (-1);
	}
#endif
	return (0);
}

d779 13
a791 1
if_set_ip_hdrincl(int fd)
d793 1
a793 2
#if 0
	int	hincl = 1;
d795 4
a798 3
	if (setsockopt(fd, IPPROTO_IPV6, IP_HDRINCL, &hincl,
	     sizeof(hincl)) < 0) {
		log_warn("if_set_ip_hdrincl: error setting IP_HDRINCL");
a800 1
#endif
@

