head	1.116;
access;
symbols
	OPENBSD_6_1:1.93.0.4
	OPENBSD_6_1_BASE:1.93;
locks; strict;
comment	@# @;


1.116
date	2017.07.22.09.59.08;	author ajacoutot;	state Exp;
branches;
next	1.115;
commitid	NJSkJoDYmQL9PEqM;

1.115
date	2017.07.04.20.25.53;	author ajacoutot;	state Exp;
branches;
next	1.114;
commitid	mHN6HonMqaclahrc;

1.114
date	2017.06.09.07.37.38;	author ajacoutot;	state Exp;
branches;
next	1.113;
commitid	ouxRArwwJCkXVQO8;

1.113
date	2017.06.09.07.32.26;	author ajacoutot;	state Exp;
branches;
next	1.112;
commitid	lGVkZHG0dy6QECB3;

1.112
date	2017.05.27.09.05.25;	author ajacoutot;	state Exp;
branches;
next	1.111;
commitid	5YOwE5DEKNYYK7e0;

1.111
date	2017.05.26.15.28.00;	author ajacoutot;	state Exp;
branches;
next	1.110;
commitid	rzmhuwvrpBZM5Oqv;

1.110
date	2017.05.26.14.43.25;	author ajacoutot;	state Exp;
branches;
next	1.109;
commitid	TgKkL5lk62LejZmf;

1.109
date	2017.05.24.11.21.13;	author ajacoutot;	state Exp;
branches;
next	1.108;
commitid	aevQRK3NeMEc9Cob;

1.108
date	2017.05.24.08.32.16;	author ajacoutot;	state Exp;
branches;
next	1.107;
commitid	vcTcDA2vSLVG9SB0;

1.107
date	2017.05.24.08.30.31;	author ajacoutot;	state Exp;
branches;
next	1.106;
commitid	TIMF2nBMSZ37S3XJ;

1.106
date	2017.05.23.13.08.28;	author ajacoutot;	state Exp;
branches;
next	1.105;
commitid	zfFtCPvzH2421Yee;

1.105
date	2017.05.23.12.05.53;	author ajacoutot;	state Exp;
branches;
next	1.104;
commitid	ajLMsqT6PbWaBndq;

1.104
date	2017.05.23.12.01.53;	author ajacoutot;	state Exp;
branches;
next	1.103;
commitid	wtIHJ97rVRfKxtZL;

1.103
date	2017.05.18.12.02.06;	author ajacoutot;	state Exp;
branches;
next	1.102;
commitid	0riGZkIL3yq9eYsc;

1.102
date	2017.05.17.13.23.58;	author ajacoutot;	state Exp;
branches;
next	1.101;
commitid	uJzFod75GKtC8Jbm;

1.101
date	2017.05.12.15.04.07;	author ajacoutot;	state Exp;
branches;
next	1.100;
commitid	BbbyfAV9u05OPawP;

1.100
date	2017.05.08.09.45.14;	author ajacoutot;	state Exp;
branches;
next	1.99;
commitid	BA84a8wtHl4bWSpE;

1.99
date	2017.05.05.08.07.36;	author ajacoutot;	state Exp;
branches;
next	1.98;
commitid	T8jO3kw3ttawXhe6;

1.98
date	2017.05.04.12.28.14;	author ajacoutot;	state Exp;
branches;
next	1.97;
commitid	lscD1DSNgJsXcpv6;

1.97
date	2017.05.03.17.23.34;	author ajacoutot;	state Exp;
branches;
next	1.96;
commitid	msO6SH8Crq1Jahsf;

1.96
date	2017.05.03.12.26.52;	author ajacoutot;	state Exp;
branches;
next	1.95;
commitid	qjChsj6Hdzp4xpnX;

1.95
date	2017.04.30.13.41.10;	author ajacoutot;	state Exp;
branches;
next	1.94;
commitid	vqIQYF17PNoaZlPF;

1.94
date	2017.04.04.21.20.22;	author ajacoutot;	state Exp;
branches;
next	1.93;
commitid	fUre79VKiIgMwMYs;

1.93
date	2017.03.31.16.02.31;	author ajacoutot;	state Exp;
branches;
next	1.92;
commitid	CBIS9zKo5tsGYcuq;

1.92
date	2017.02.13.14.59.09;	author ajacoutot;	state Exp;
branches;
next	1.91;
commitid	wMAIfFeuqfp1plXh;

1.91
date	2017.01.30.15.36.20;	author ajacoutot;	state Exp;
branches;
next	1.90;
commitid	IIGFbxK9a2jvVj9L;

1.90
date	2017.01.26.04.38.27;	author rpe;	state Exp;
branches;
next	1.89;
commitid	CH3nx0qE1YFJIDep;

1.89
date	2017.01.26.04.34.51;	author rpe;	state Exp;
branches;
next	1.88;
commitid	23LVgR0UaYcS6SQG;

1.88
date	2017.01.26.04.08.50;	author rpe;	state Exp;
branches;
next	1.87;
commitid	Me55IrTFYGC0b1p6;

1.87
date	2017.01.26.03.55.25;	author rpe;	state Exp;
branches;
next	1.86;
commitid	9EGv2oNGGUnwYJ07;

1.86
date	2017.01.19.23.41.57;	author ajacoutot;	state Exp;
branches;
next	1.85;
commitid	No4nuDL5AlY49kzh;

1.85
date	2017.01.19.23.04.48;	author ajacoutot;	state Exp;
branches;
next	1.84;
commitid	EkUnV4ifKbKh0X1f;

1.84
date	2017.01.19.09.08.45;	author ajacoutot;	state Exp;
branches;
next	1.83;
commitid	5RdJHTPKp3kWCGOt;

1.83
date	2017.01.19.08.45.23;	author ajacoutot;	state Exp;
branches;
next	1.82;
commitid	YNAgfXs27R6adbI1;

1.82
date	2017.01.19.08.31.53;	author ajacoutot;	state Exp;
branches;
next	1.81;
commitid	XjmDJVUAMM5k3k4H;

1.81
date	2017.01.11.12.22.13;	author ajacoutot;	state Exp;
branches;
next	1.80;
commitid	bRZNZ7W4JiwgH5G4;

1.80
date	2017.01.11.08.11.19;	author ajacoutot;	state Exp;
branches;
next	1.79;
commitid	do4lignUutLF02Y5;

1.79
date	2016.12.31.15.52.36;	author ajacoutot;	state Exp;
branches;
next	1.78;
commitid	h00FnBv31jA8rFqu;

1.78
date	2016.12.08.09.47.37;	author ajacoutot;	state Exp;
branches;
next	1.77;
commitid	5yhVCU8MXmVm9GUP;

1.77
date	2016.12.07.15.36.50;	author ajacoutot;	state Exp;
branches;
next	1.76;
commitid	x9wvPQTtPZ0v8x07;

1.76
date	2016.12.06.16.16.12;	author ajacoutot;	state Exp;
branches;
next	1.75;
commitid	htuAlDNeMTHhJmWO;

1.75
date	2016.12.06.16.01.02;	author ajacoutot;	state Exp;
branches;
next	1.74;
commitid	i3Whyg2YaaGVfVny;

1.74
date	2016.12.06.11.10.00;	author ajacoutot;	state Exp;
branches;
next	1.73;
commitid	K70NkhxCRrjscTMW;

1.73
date	2016.12.06.10.29.04;	author ajacoutot;	state Exp;
branches;
next	1.72;
commitid	Xc679MfZWVrR6nTX;

1.72
date	2016.12.05.16.11.17;	author ajacoutot;	state Exp;
branches;
next	1.71;
commitid	FOjimRUua64dIVxQ;

1.71
date	2016.12.05.15.34.21;	author ajacoutot;	state Exp;
branches;
next	1.70;
commitid	9NnELtcboWIsKw6v;

1.70
date	2016.12.05.13.17.31;	author ajacoutot;	state Exp;
branches;
next	1.69;
commitid	HqCdub1EH6JzL79G;

1.69
date	2016.12.02.10.59.27;	author ajacoutot;	state Exp;
branches;
next	1.68;
commitid	aYw09jYuJPToTOwb;

1.68
date	2016.12.02.08.34.28;	author ajacoutot;	state Exp;
branches;
next	1.67;
commitid	JyJ9s1Vg07GajElN;

1.67
date	2016.12.01.10.58.54;	author ajacoutot;	state Exp;
branches;
next	1.66;
commitid	bDC1HkNuwq8QsC2b;

1.66
date	2016.11.30.15.19.16;	author ajacoutot;	state Exp;
branches;
next	1.65;
commitid	2CiEo2lIrN0UE6aT;

1.65
date	2016.11.30.13.53.14;	author ajacoutot;	state Exp;
branches;
next	1.64;
commitid	p7OkI33Yzziyn133;

1.64
date	2016.11.30.12.58.28;	author ajacoutot;	state Exp;
branches;
next	1.63;
commitid	wkS4a5Hu5l0bHxEH;

1.63
date	2016.11.27.11.38.50;	author ajacoutot;	state Exp;
branches;
next	1.62;
commitid	AiEgbXJoLieEiI1I;

1.62
date	2016.11.27.08.55.48;	author ajacoutot;	state Exp;
branches;
next	1.61;
commitid	nV7cXxOBpY4gvkgL;

1.61
date	2016.11.25.09.56.45;	author ajacoutot;	state Exp;
branches;
next	1.60;
commitid	AlSo0wpfYogGjcYN;

1.60
date	2016.11.22.14.20.39;	author ajacoutot;	state Exp;
branches;
next	1.59;
commitid	ekmaolIU1d0z2DVt;

1.59
date	2016.11.22.10.53.37;	author ajacoutot;	state Exp;
branches;
next	1.58;
commitid	Iyej2JUnlPp0fKcQ;

1.58
date	2016.11.21.16.27.36;	author ajacoutot;	state Exp;
branches;
next	1.57;
commitid	uM6J7oZoHhKGjVVL;

1.57
date	2016.11.21.14.43.52;	author ajacoutot;	state Exp;
branches;
next	1.56;
commitid	S6os1wAF9xeJD4nk;

1.56
date	2016.11.17.15.15.49;	author ajacoutot;	state Exp;
branches;
next	1.55;
commitid	mxuDI17KcevzcllT;

1.55
date	2016.11.17.14.05.46;	author ajacoutot;	state Exp;
branches;
next	1.54;
commitid	nCvac8uFSGX46vq5;

1.54
date	2016.11.16.16.11.31;	author ajacoutot;	state Exp;
branches;
next	1.53;
commitid	asx1ytellsY6rquS;

1.53
date	2016.11.16.15.27.52;	author ajacoutot;	state Exp;
branches;
next	1.52;
commitid	CmF1xzJjU00cwFqR;

1.52
date	2016.11.16.14.54.26;	author ajacoutot;	state Exp;
branches;
next	1.51;
commitid	S07AC7qVMNjl2NNq;

1.51
date	2016.11.15.14.46.00;	author ajacoutot;	state Exp;
branches;
next	1.50;
commitid	oFeoZ6XP2a9LWmcp;

1.50
date	2016.11.15.09.49.48;	author ajacoutot;	state Exp;
branches;
next	1.49;
commitid	QGP0acmIHFXsL7VU;

1.49
date	2016.11.14.15.45.40;	author ajacoutot;	state Exp;
branches;
next	1.48;
commitid	Pc48ePYOIs2DflRD;

1.48
date	2016.11.14.09.09.20;	author ajacoutot;	state Exp;
branches;
next	1.47;
commitid	ORQvaIe5dl5AU37Q;

1.47
date	2016.11.12.22.22.25;	author halex;	state Exp;
branches;
next	1.46;
commitid	EY5hdKbkm61oQ0nf;

1.46
date	2016.11.10.13.56.57;	author ajacoutot;	state Exp;
branches;
next	1.45;
commitid	nwJMIO37dhysMUaW;

1.45
date	2016.11.10.10.39.09;	author ajacoutot;	state Exp;
branches;
next	1.44;
commitid	DXNNVijdVRxu26Hm;

1.44
date	2016.11.10.10.27.31;	author ajacoutot;	state Exp;
branches;
next	1.43;
commitid	vQ7GSN3GtFBhNR9W;

1.43
date	2016.11.10.10.20.48;	author ajacoutot;	state Exp;
branches;
next	1.42;
commitid	zR0ffChxRX2iwSsW;

1.42
date	2016.11.08.16.39.57;	author ajacoutot;	state Exp;
branches;
next	1.41;
commitid	W1bwaM4gr7XGKbBp;

1.41
date	2016.11.08.12.11.22;	author ajacoutot;	state Exp;
branches;
next	1.40;
commitid	b3ban0iJUJNGDVm4;

1.40
date	2016.11.06.19.12.58;	author halex;	state Exp;
branches;
next	1.39;
commitid	rNFB0XA4WadK58HS;

1.39
date	2016.11.04.16.03.45;	author ajacoutot;	state Exp;
branches;
next	1.38;
commitid	nMUhgSlQZdJLdnQ9;

1.38
date	2016.11.04.15.32.13;	author ajacoutot;	state Exp;
branches;
next	1.37;
commitid	rpzpBprLVj5JvVZV;

1.37
date	2016.11.04.14.55.29;	author ajacoutot;	state Exp;
branches;
next	1.36;
commitid	vL7pYXlFdaSOwtFQ;

1.36
date	2016.11.04.14.18.45;	author ajacoutot;	state Exp;
branches;
next	1.35;
commitid	Rj85v7uAO2W7O79R;

1.35
date	2016.11.04.11.42.14;	author ajacoutot;	state Exp;
branches;
next	1.34;
commitid	pD8xZG2Aqxc4qD1j;

1.34
date	2016.11.03.17.14.31;	author ajacoutot;	state Exp;
branches;
next	1.33;
commitid	wN6iJHTIzFJ26Zw8;

1.33
date	2016.11.03.16.12.23;	author ajacoutot;	state Exp;
branches;
next	1.32;
commitid	CDkT0tOnQnsgR1ex;

1.32
date	2016.11.03.15.54.10;	author ajacoutot;	state Exp;
branches;
next	1.31;
commitid	aHrCFZy0Dsq16szr;

1.31
date	2016.11.03.15.34.31;	author ajacoutot;	state Exp;
branches;
next	1.30;
commitid	deS3y8tDDZ2qGj6n;

1.30
date	2016.11.03.14.36.54;	author ajacoutot;	state Exp;
branches;
next	1.29;
commitid	LbkOo6isanYLWoIG;

1.29
date	2016.11.03.14.13.15;	author ajacoutot;	state Exp;
branches;
next	1.28;
commitid	Urwlz1Snt5DC0kHY;

1.28
date	2016.11.03.12.40.08;	author ajacoutot;	state Exp;
branches;
next	1.27;
commitid	NaeL2jD5O8jKJvAq;

1.27
date	2016.11.03.12.27.34;	author ajacoutot;	state Exp;
branches;
next	1.26;
commitid	wEWg1xvVQCoS0psf;

1.26
date	2016.11.02.18.04.50;	author ajacoutot;	state Exp;
branches;
next	1.25;
commitid	SA8j6FdvXN2Nyx2h;

1.25
date	2016.11.01.21.51.44;	author ajacoutot;	state Exp;
branches;
next	1.24;
commitid	suo68rhXQN1qXdzm;

1.24
date	2016.11.01.20.46.02;	author ajacoutot;	state Exp;
branches;
next	1.23;
commitid	Ws9dcMZUJqoOeKY8;

1.23
date	2016.11.01.18.12.44;	author ajacoutot;	state Exp;
branches;
next	1.22;
commitid	BI0R6v68yRPW7dOL;

1.22
date	2016.11.01.16.21.47;	author ajacoutot;	state Exp;
branches;
next	1.21;
commitid	6ubnKp4qDtSSI2zQ;

1.21
date	2016.11.01.16.05.53;	author ajacoutot;	state Exp;
branches;
next	1.20;
commitid	fTvPB3Vh2juLKKUh;

1.20
date	2016.11.01.15.51.04;	author ajacoutot;	state Exp;
branches;
next	1.19;
commitid	pOVyygogXrJ8Q1w6;

1.19
date	2016.11.01.14.45.46;	author ajacoutot;	state Exp;
branches;
next	1.18;
commitid	LimVxVYG5alB1pJi;

1.18
date	2016.11.01.12.41.46;	author ajacoutot;	state Exp;
branches;
next	1.17;
commitid	CujulR1ZpnT0D86p;

1.17
date	2016.11.01.10.30.01;	author ajacoutot;	state Exp;
branches;
next	1.16;
commitid	lBekoWGi54ZNOM4H;

1.16
date	2016.11.01.10.25.43;	author ajacoutot;	state Exp;
branches;
next	1.15;
commitid	TpuKnGmWcn1I3Ec7;

1.15
date	2016.09.11.13.10.59;	author ajacoutot;	state Exp;
branches;
next	1.14;
commitid	cw9DZK8McAC7jXmM;

1.14
date	2016.09.11.11.50.34;	author ajacoutot;	state Exp;
branches;
next	1.13;
commitid	kIHEZhAPujlLCn30;

1.13
date	2016.09.10.16.19.14;	author ajacoutot;	state Exp;
branches;
next	1.12;
commitid	GZ02k1mt7frefWkf;

1.12
date	2016.09.10.16.07.33;	author ajacoutot;	state Exp;
branches;
next	1.11;
commitid	KAblsU0Djt7bTJ9b;

1.11
date	2016.09.07.16.01.48;	author ajacoutot;	state Exp;
branches;
next	1.10;
commitid	7ZVGHf1IyrLBeK1E;

1.10
date	2016.09.07.15.41.23;	author ajacoutot;	state Exp;
branches;
next	1.9;
commitid	E7C0wB7xNol9yuKi;

1.9
date	2016.09.07.15.19.33;	author ajacoutot;	state Exp;
branches;
next	1.8;
commitid	nm7rZP8I3lAOhOo7;

1.8
date	2016.09.06.14.33.42;	author ajacoutot;	state Exp;
branches;
next	1.7;
commitid	3rS0K3VTNytE8bXp;

1.7
date	2016.09.06.14.32.06;	author ajacoutot;	state Exp;
branches;
next	1.6;
commitid	who3vFNg3Oz0pKCR;

1.6
date	2016.09.06.13.55.40;	author ajacoutot;	state Exp;
branches;
next	1.5;
commitid	IU1kVADoc5GFNnby;

1.5
date	2016.09.05.12.05.13;	author ajacoutot;	state Exp;
branches;
next	1.4;
commitid	wlJf6nPKqTNwoTIZ;

1.4
date	2016.09.05.11.32.28;	author ajacoutot;	state Exp;
branches;
next	1.3;
commitid	xII2hb84mleS5y6K;

1.3
date	2016.09.05.11.29.34;	author robert;	state Exp;
branches;
next	1.2;
commitid	prEkMUymtzI7So7l;

1.2
date	2016.09.05.11.26.18;	author ajacoutot;	state Exp;
branches;
next	1.1;
commitid	Rn5PdkOH4f4LfLG0;

1.1
date	2016.09.05.11.04.45;	author ajacoutot;	state Exp;
branches;
next	;
commitid	cAZqvnQoXzHyIThf;


desc
@@


1.116
log
@Cleanup previous release patches and backup kernel _before_ applying new
patches. This will mitigate possible /var overflow (previous behavior was
to clean up _after_ applying all patches which means we would have rollback
patches from the previous and current release before the previous ones got
cleaned).
@
text
@#!/bin/ksh
#
# $OpenBSD: syspatch.sh,v 1.115 2017/07/04 20:25:53 ajacoutot Exp $
#
# Copyright (c) 2016, 2017 Antoine Jacoutot <ajacoutot@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

set -e
umask 0022

sp_err()
{
	echo "${1}" 1>&2 && return ${2:-1}
}

usage()
{
	sp_err "usage: ${0##*/} [-c | -l | -R | -r]"
}

apply_patch()
{
	local _edir _file _files _patch=$1 _ret=0 _s
	[[ -n ${_patch} ]]

	_edir=${_TMP}/${_patch}

	fetch_and_verify "syspatch${_patch}.tgz"

	trap '' INT
	echo "Installing patch ${_patch##${_OSrev}-}"
	install -d ${_edir} ${_PDIR}/${_patch}

	! ${_BSDMP} && [[ ! -f /bsd.mp ]] && _s="-s /^bsd.mp$//"
	_files="$(tar -xvzphf ${_TMP}/syspatch${_patch}.tgz -C ${_edir} ${_s})"

	checkfs ${_files}
	create_rollback ${_patch} "${_files}"

	for _file in ${_files}; do
		((_ret == 0)) || break
		if [[ ${_file} == @@(bsd|bsd.mp) ]]; then
			install_kernel ${_edir}/${_file} || _ret=$?
		else
			install_file ${_edir}/${_file} /${_file} || _ret=$?
		fi
	done

	if ((_ret != 0)); then
		sp_err "Failed to apply patch ${_patch##${_OSrev}-}" 0
		rollback_patch; return ${_ret}
	fi
	# don't fill up /tmp when installing multiple patches at once; non-fatal
	rm -rf ${_edir} ${_TMP}/syspatch${_patch}.tgz
	trap exit INT
}

# quick-and-dirty filesystem status and size checks:
# - assume old files are about the same size as new ones
# - ignore new (nonexistent) files
# - ignore rollback tarball: create_rollback() will handle the failure
# - compute total size of all files per fs, simpler and less margin for error
# - if we install a kernel, double /bsd size (duplicate it in the list) when:
#   - we are on an MP system (/bsd.mp does not exist there)
#   - /bsd.syspatchXX is not present (create_rollback will copy it from /bsd)
checkfs()
{
	local _d _dev _df _files="${@@}" _ret _sz
	[[ -n ${_files} ]]

	if echo "${_files}" | grep -qw bsd; then
		${_BSDMP} || [[ ! -f /bsd.syspatch${_OSrev} ]] &&
			_files="bsd ${_files}"
	fi

	set +e # ignore errors due to:
	# - nonexistent files (i.e. syspatch is installing new files)
	# - broken interpolation due to bogus devices like remote filesystems
	eval $(cd / &&
		stat -qf "_dev=\"\${_dev} %Sd\" %Sd=\"\${%Sd:+\${%Sd}\+}%Uz\"" \
			${_files}) 2>/dev/null || _ret=$?
	set -e
	[[ ${_ret} == 127 ]] && sp_err "Remote filesystem, aborting" 

	for _d in $(printf '%s\n' ${_dev} | sort -u); do
		mount | grep -v read-only | grep -q "^/dev/${_d} " ||
			sp_err "Read-only filesystem, aborting"
		_df=$(df -Pk | grep "^/dev/${_d} " | tr -s ' ' | cut -d ' ' -f4)
		_sz=$(($((_d))/1024))
		((_df > _sz)) || sp_err "No space left on ${_d}, aborting"
	done
}

create_rollback()
{
	# XXX annotate new files so we can remove them if we rollback?
	local _file _patch=$1 _rbfiles _ret=0
	[[ -n ${_patch} ]]
	shift
	local _files="${@@}"
	[[ -n ${_files} ]]

	for _file in ${_files}; do
		[[ -f /${_file} ]] || continue
		# only save the original release kernel once
		if [[ ${_file} == bsd && ! -f /bsd.syspatch${_OSrev} ]]; then
			install -FSp /bsd /bsd.syspatch${_OSrev}
		fi
		_rbfiles="${_rbfiles} ${_file}"
	done

	# GENERIC.MP: substitute bsd.mp->bsd and bsd.sp->bsd
	if ${_BSDMP} &&
		tar -tzf ${_TMP}/syspatch${_patch}.tgz bsd >/dev/null 2>&1; then
		tar -C / -czf ${_PDIR}/${_patch}/rollback.tgz -s '/^bsd.mp$//' \
			-s '/^bsd$/bsd.mp/' -s '/^bsd.sp$/bsd/' bsd.sp \
			${_rbfiles} || _ret=$?
	else
		tar -C / -czf ${_PDIR}/${_patch}/rollback.tgz ${_rbfiles} ||
			_ret=$?
	fi

	if ((_ret != 0)); then
		sp_err "Failed to create rollback patch ${_patch##${_OSrev}-}" 0
		rm -r ${_PDIR}/${_patch}; return ${_ret}
	fi
}

fetch_and_verify()
{
	local _tgz=$1 _title="Get/Verify"
	[[ -n ${_tgz} ]]

	[[ -t 0 ]] || echo "${_title} ${_tgz}"
	unpriv -f "${_TMP}/${_tgz}" ftp -VD "${_title}" -o "${_TMP}/${_tgz}" \
		"${_MIRROR}/${_tgz}"

	(cd ${_TMP} && sha256 -qC ${_TMP}/SHA256 ${_tgz})
}

install_file()
{
	# XXX handle hard and symbolic links, dir->file, file->dir?
	local _dst=$2 _fgrp _fmode _fown _src=$1
	[[ -f ${_src} && -f ${_dst} ]]

	eval $(stat -f "_fmode=%OMp%OLp _fown=%Su _fgrp=%Sg" ${_src})

	install -DFSp -m ${_fmode} -o ${_fown} -g ${_fgrp} ${_src} ${_dst}
}

install_kernel()
{
	local _bsd _kern=$1
	[[ -n ${_kern} ]]

	if ${_BSDMP}; then
		[[ ${_kern##*/} == bsd ]] && _bsd=bsd.sp || _bsd=bsd
	fi

	install -FSp ${_kern} /${_bsd:-${_kern##*/}}
}

ls_installed()
{
	local _p
	for _p in ${_PDIR}/${_OSrev}-+([[:digit:]])_+([[:alnum:]_]); do
		[[ -f ${_p}/rollback.tgz ]] && echo ${_p##*/${_OSrev}-}
	done | sort -V
}

ls_missing()
{
	local _c _f _cmd _l="$(ls_installed)" _p _r _sha=${_TMP}/SHA256

	# return inmediately if we cannot reach the mirror server
	[[ -d ${_MIRROR#file://*} ]] ||
		unpriv ftp -MVo /dev/null ${_MIRROR%syspatch/*} >/dev/null

	# don't output anything on stdout to prevent corrupting the patch list;
	# redirect stderr as well in case there's no patch available
	unpriv -f "${_sha}.sig" ftp -MVo "${_sha}.sig" "${_MIRROR}/SHA256.sig" \
		>/dev/null 2>&1 || return 0 # empty directory
	unpriv -f "${_sha}" signify -Veq -x ${_sha}.sig -m ${_sha} -p \
		/etc/signify/openbsd-${_OSrev}-syspatch.pub >/dev/null

	# if no earlier version of all files contained in the syspatch exists
	# on the system, it means a missing set so skip it
	grep -Eo "syspatch${_OSrev}-[[:digit:]]{3}_[[:alnum:]_]+" ${_sha} |
		while read _c; do _c=${_c##syspatch${_OSrev}-} &&
		[[ -n ${_l} ]] && echo ${_c} | grep -qw -- "${_l}" || echo ${_c}
	done | while read _p; do
		_cmd="ftp -MVo - ${_MIRROR}/syspatch${_OSrev}-${_p}.tgz"
		{ unpriv ${_cmd} | tar tzf -; } 2>/dev/null | while read _f; do
			[[ -f /${_f} ]] || continue && echo ${_p} && pkill -u \
				_syspatch -xf "${_cmd}" || true && break
		done
	done | sort -V
}

rollback_patch()
{
	local _edir _file _files _patch _ret=0

	_patch="$(ls_installed | tail -1)"
	[[ -n ${_patch} ]]

	_edir=${_TMP}/${_patch}-rollback
	_patch=${_OSrev}-${_patch}

	trap '' INT
	echo "Reverting patch ${_patch##${_OSrev}-}"
	install -d ${_edir}

	_files="$(tar xvzphf ${_PDIR}/${_patch}/rollback.tgz -C ${_edir})"
	checkfs ${_files} ${_PDIR} # check for read-only /var/syspatch

	for _file in ${_files}; do
		((_ret == 0)) || break
		if [[ ${_file} == @@(bsd|bsd.mp) ]]; then
			install_kernel ${_edir}/${_file} || _ret=$?
			# remove the backup kernel if all kernel syspatches have
			# been reverted; non-fatal
			cmp -s /bsd /bsd.syspatch${_OSrev} &&
				rm -f /bsd.syspatch${_OSrev}
		else
			install_file ${_edir}/${_file} /${_file} || _ret=$?
		fi
	done

	((_ret != 0)) || rm -r ${_PDIR}/${_patch} || _ret=$?
	((_ret == 0)) ||
		sp_err "Failed to revert patch ${_patch##${_OSrev}-}" ${_ret}
	rm -rf ${_edir} # don't fill up /tmp when using `-R'; non-fatal
	trap exit INT
}

sp_cleanup()
{
	local _d _k

	# remove non matching release /var/syspatch/ content
	for _d in ${_PDIR}/{.[!.],}*; do
		[[ -e ${_d} ]] || continue
		[[ ${_d##*/} == ${_OSrev}-+([[:digit:]])_+([[:alnum:]]|_) ]] &&
			[[ -f ${_d}/rollback.tgz ]] || rm -r ${_d}
	done

	# remove non matching release backup kernel
	for _k in /bsd.syspatch+([[:digit:]]); do
		[[ -f ${_k} ]] || continue
		[[ ${_k} == /bsd.syspatch${_OSrev} ]] || rm ${_k}
	done
}

unpriv()
{
	local _file=$2 _user=_syspatch

	if [[ $1 == -f && -n ${_file} ]]; then
		>${_file}
		chown "${_user}" "${_file}"
		chmod 0711 ${_TMP}
		shift 2
	fi
	(($# >= 1))

	eval su -s /bin/sh ${_user} -c "'$@@'"
}

[[ $@@ == @@(|-[[:alpha:]]) ]] || usage; [[ $@@ == @@(|-(c|r)) ]] &&
	(($(id -u) != 0)) && sp_err "${0##*/}: need root privileges"

# only run on release (not -current nor -stable)
set -A _KERNV -- $(sysctl -n kern.version |
	sed 's/^OpenBSD \([0-9]\.[0-9]\)\([^ ]*\).*/\1 \2/;q')
((${#_KERNV[*]} > 1)) && sp_err "Unsupported release: ${_KERNV[0]}${_KERNV[1]}"

_OSrev=${_KERNV[0]%.*}${_KERNV[0]#*.}
[[ -n ${_OSrev} ]]

_MIRROR=$(while read _line; do _line=${_line%%#*}; [[ -n ${_line} ]] &&
	print -r -- "${_line}"; done </etc/installurl | tail -1) 2>/dev/null
[[ ${_MIRROR} == @@(file|http|https)://*/*[!/] ]] ||
	sp_err "${0##*/}: invalid URL configured in /etc/installurl"
_MIRROR="${_MIRROR}/syspatch/${_KERNV[0]}/$(machine)"

(($(sysctl -n hw.ncpufound) > 1)) && _BSDMP=true || _BSDMP=false
_PDIR="/var/syspatch"
_TMP=$(mktemp -d -p /tmp syspatch.XXXXXXXXXX)

readonly _BSDMP _KERNV _MIRROR _OSrev _PDIR _TMP

trap 'set +e; rm -rf "${_TMP}"' EXIT
trap exit HUP INT TERM

while getopts clRr arg; do
	case ${arg} in
		c) ls_missing ;;
		l) ls_installed ;;
		R) while [[ -n $(ls_installed) ]]; do rollback_patch; done ;;
		r) rollback_patch ;;
		*) usage ;;
	esac
done
shift $((OPTIND - 1))
(($# != 0)) && usage

# default action: apply all patches
if ((OPTIND == 1)); then
	sp_cleanup
	_PATCHES=$(ls_missing)
	for _PATCH in ${_PATCHES}; do
		apply_patch ${_OSrev}-${_PATCH}
	done
	# in case a patch added a new directory (install -D)
	mtree -qdef /etc/mtree/4.4BSD.dist -p / -U >/dev/null
	[[ ! -f /var/sysmerge/xetc.tgz ]] ||
		mtree -qdef /etc/mtree/BSD.x11.dist -p / -U >/dev/null
fi
@


1.115
log
@Detect upfront whether we have a particular set installed and if not, do *not*
list a matching syspatch as available. This will allow to skip the syspatches
for the X sets for example if we don't have them installed. If we do install
these sets a posteriori, then syspatch *will* list the X syspatches if there are
any.

req. by many
ok robert@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.114 2017/06/09 07:37:38 ajacoutot Exp $
a264 5

	# in case a patch added a new directory (install -D)
	mtree -qdef /etc/mtree/4.4BSD.dist -p / -U >/dev/null
	[[ -f /var/sysmerge/xetc.tgz ]] &&
		mtree -qdef /etc/mtree/BSD.x11.dist -p / -U >/dev/null
d320 1
d322 1
d327 4
a330 1
	sp_cleanup
@


1.114
log
@Drop uneeded return from rollback_patch().
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.113 2017/06/09 07:32:26 ajacoutot Exp $
a50 6
	# create_rollback(): tar(1) was fed with an empty list of files; that is
	# not an error but no tarball is created; this happens if no earlier
	# version of the files contained in the syspatch exists on the system
	[[ ! -f ${_PDIR}/${_patch}/rollback.tgz ]] && unset _files &&
		echo "Missing set, skipping patch ${_patch##${_OSrev}-}"

d185 1
a185 1
	local _c _l="$(ls_installed)" _sha=${_TMP}/SHA256
d198 2
d203 6
@


1.113
log
@/etc/mtree/BSD.x11.dist is part of base, not X; so check for
/var/sysmerge/xetc.tgz to detect whether we have the x sets installed.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.112 2017/05/27 09:05:25 ajacoutot Exp $
d215 1
a215 1
	[[ -n ${_patch} ]] || return # function used as a while condition
@


1.112
log
@When running from cron, the ftp(1) progress bar is not shown; that's all fine
and dandy except that if there's fetch/verify error, we may not know which
syspatch caused this. So if we're not associated with a terminal, just echo
what ftp -VD would (without the progress bar).
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.111 2017/05/26 15:28:00 ajacoutot Exp $
d249 1
a249 1
	local _d _k _m
d265 3
a267 3
	for _m in /etc/mtree/{4.4BSD,BSD.x11}.dist; do
		[[ -f ${_m} ]] && mtree -qdef ${_m} -p / -U >/dev/null
	done
a299 1

@


1.111
log
@Don't try to revert the same patch in a loop if it returns an error.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.110 2017/05/26 14:43:25 ajacoutot Exp $
d148 1
a148 1
	local _tgz=$1
d151 3
a153 2
	unpriv -f "${_TMP}/${_tgz}" ftp -VD "Get/Verify" -o \
		"${_TMP}/${_tgz}" "${_MIRROR}/${_tgz}"
@


1.110
log
@Fix logic.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.109 2017/05/24 11:21:13 ajacoutot Exp $
d315 1
a315 1
		R) while rollback_patch; do :; done ;;
@


1.109
log
@Preserve the modification time when install(1)ing.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.106 2017/05/23 13:08:28 ajacoutot Exp $
d239 2
a240 1
	((_ret == 0)) && rm -r ${_PDIR}/${_patch} ||
@


1.108
log
@Don't fill up /tmp when installing or reverting multiple patches at once.
@
text
@d165 1
a165 1
	install -DFS -m ${_fmode} -o ${_fown} -g ${_fgrp} ${_src} ${_dst}
d177 1
a177 1
	install -FS ${_kern} /${_bsd:-${_kern##*/}}
@


1.107
log
@Also trap INT when reverting a patch.
@
text
@d70 2
d231 1
a231 1
			# been reverted; non-fatal (`-f')
d241 1
@


1.106
log
@Hide sh(1) error message when /etc/installurl does not exist; we already
error out with a message in this case since _MIRROR is empty.

reported by tedu@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.105 2017/05/23 12:05:53 ajacoutot Exp $
d217 1
d239 1
@


1.105
log
@Only install /bsd.mp on SP machines if it's already there (a default
installation will not have it).
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.104 2017/05/23 12:01:53 ajacoutot Exp $
d290 1
a290 1
	print -r -- "${_line}"; done </etc/installurl | tail -1)
@


1.104
log
@Shorten varname.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.103 2017/05/18 12:02:06 ajacoutot Exp $
d34 1
a34 1
	local _edir _file _files _patch=$1 _ret=0
d45 3
a47 1
	_files="$(tar xvzphf ${_TMP}/syspatch${_patch}.tgz -C ${_edir})"
a48 1

@


1.103
log
@Don't pass `-m' to ftp(1). Instead let isatty() decide whether we display the
progress bar or not for better cron(1)/logger(1) output.

req. by henning@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.102 2017/05/17 13:23:58 ajacoutot Exp $
d34 1
a34 1
	local _explodir _file _files _patch=$1 _ret=0
d37 1
a37 1
	_explodir=${_TMP}/${_patch}
d43 1
a43 1
	install -d ${_explodir} ${_PDIR}/${_patch}
d45 1
a45 1
	_files="$(tar xvzphf ${_TMP}/syspatch${_patch}.tgz -C ${_explodir})"
d59 1
a59 1
			install_kernel ${_explodir}/${_file} || _ret=$?
d61 1
a61 1
			install_file ${_explodir}/${_file} /${_file} || _ret=$?
d208 1
a208 1
	local _explodir _file _files _patch _ret=0
d213 1
a213 1
	_explodir=${_TMP}/${_patch}-rollback
d217 1
a217 1
	install -d ${_explodir}
d219 1
a219 1
	_files="$(tar xvzphf ${_PDIR}/${_patch}/rollback.tgz -C ${_explodir})"
d225 1
a225 1
			install_kernel ${_explodir}/${_file} || _ret=$?
d231 1
a231 1
			install_file ${_explodir}/${_file} /${_file} || _ret=$?
@


1.102
log
@Tweak remote fs check.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.101 2017/05/12 15:04:07 ajacoutot Exp $
d148 1
a148 1
	unpriv -f "${_TMP}/${_tgz}" ftp -Vm -D "Get/Verify" -o \
@


1.101
log
@Make sure we have a valid URL in /etc/installurl to prevent ending up stuck in
ftp(1) interactive mode.

reported by and OK sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.100 2017/05/08 09:45:14 ajacoutot Exp $
d75 1
d82 1
a82 1
	local _d _dev _df _files="${@@}" _sz
d95 1
a95 1
			${_files}) 2>/dev/null
d97 1
a97 1
	[[ -z ${_dev} && -n ${_files} ]] && sp_err "Remote filesystem, aborting"
@


1.100
log
@Only test the mirror if it's remote (and not a local directory).
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.99 2017/05/05 08:07:36 ajacoutot Exp $
d289 3
a291 1
[[ -z ${_MIRROR} ]] && sp_err "${0##*/}: no URL configured in /etc/installurl"
@


1.99
log
@Add a `-R' switch that reverts all patches.

prodded by deraadt@@
knobs sorting input jmc@@
ok sthen@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.97 2017/05/03 17:23:34 ajacoutot Exp $
d189 2
a190 1
	unpriv ftp -MVo /dev/null ${_MIRROR%syspatch/*} >/dev/null
@


1.98
log
@Expand comment and bump copyright while here.
@
text
@d29 1
a29 1
	sp_err "usage: ${0##*/} [-c | -l | -r]"
d209 1
a209 1
	[[ -n ${_patch} ]]
d300 1
a300 1
while getopts clr arg; do
d302 5
a306 4
		c) ls_missing;;
		l) ls_installed;;
		r) rollback_patch;;
		*) usage;;
@


1.97
log
@Output explicit error messages for:
- trying to install files mounted on a remote FS (diskless clients etc.)
- read-only FS
- not enough space on FS

These were all properly catched before (syspatch would refuse to do anything)
but the error message was a bit cryptic.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.96 2017/05/03 12:26:52 ajacoutot Exp $
d5 1
a5 1
# Copyright (c) 2016 Antoine Jacoutot <ajacoutot@@openbsd.org>
d155 1
a155 1
	# XXX handle symlinks, dir->file, file->dir?
@


1.96
log
@- Don't make an empty syspatch/ repo an error; having no available patch
is perfectly legit.
- Abort immediately if we cannot reach our mirror server listed in
installurl.
- Return a proper error code when running without arguments and we cannot
list the available patches.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.95 2017/04/30 13:41:10 ajacoutot Exp $
d72 1
a72 1
# quick-and-dirty size check:
d81 1
a81 1
	local _d _df _dev _files="${@@}" _sz
d89 3
d94 3
a96 1
			${_files}) || true # ignore nonexistent files
d100 1
a100 1
			sp_err "Remote or read-only filesystem, aborting"
@


1.95
log
@Tweak error message when running on an unsupported release.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.94 2017/04/04 21:20:22 ajacoutot Exp $
d183 5
a187 1
	# don't output anything on stdout to prevent corrupting the patch list
d189 1
a189 1
		>/dev/null 2>&1
d307 2
a308 1
	for _PATCH in $(ls_missing); do
@


1.94
log
@Also remove non syspatch hidden files/dirs.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.93 2017/03/31 16:02:31 ajacoutot Exp $
d272 1
a272 1
((${#_KERNV[*]} > 1)) && sp_err "Unsupported release ${_KERNV[*]}"
@


1.93
log
@Be quiet in case /var/syspatch/ is empty and that there's no remote sig
file yet (i.e. when we are in release mode but not released yet).

ok deraadt@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.92 2017/02/13 14:59:09 ajacoutot Exp $
d233 1
a233 1
	for _d in ${_PDIR}/*; do
@


1.92
log
@Reverse output when installing a patch; it's more logical (first get, then
install). While here, match the installer output a bit more:
Get/Verify ...
Installing ...

prodded by a mail exchange with "bytevolcano"
discussed with robert@@ sthen@@
ok robert@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.91 2017/01/30 15:36:20 ajacoutot Exp $
d185 1
a185 1
		>/dev/null
d234 1
@


1.91
log
@Drop empty line.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.90 2017/01/26 04:38:27 rpe Exp $
a38 1
	echo "Applying patch ${_patch##${_OSrev}-}"
d42 1
@


1.90
log
@Remove unused _REL variable

OK aja@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.89 2017/01/26 04:34:51 rpe Exp $
a288 1

@


1.89
log
@Move setting _OSrev to immediately after verifying _KERNV and exit
early if _OSrev is empty.

OK aja@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.88 2017/01/26 04:08:50 rpe Exp $
d285 1
a285 1
readonly _BSDMP _KERNV _MIRROR _OSrev _PDIR _REL _TMP
@


1.88
log
@No need to escape '.' in shell patterns - it has no special meaning.

OK aja@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.87 2017/01/26 03:55:25 rpe Exp $
d273 3
a281 1
_OSrev=${_KERNV[0]%.*}${_KERNV[0]#*.}
a289 1
[[ -n ${_OSrev} ]]
@


1.87
log
@Spacing and use arithmetic test

OK aja@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.86 2017/01/19 23:41:57 ajacoutot Exp $
d279 1
a279 1
_OSrev=${_KERNV[0]%\.*}${_KERNV[0]#*\.}
@


1.86
log
@Simplify: bundle stripcom().
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.84 2017/01/19 09:08:45 ajacoutot Exp $
d298 2
a299 2
shift $((OPTIND -1))
[[ $# -ne 0 ]] && usage
@


1.85
log
@/etc/mirror.conf -> /etc/installurl
discussed with deraadt@@ beck@@ rpe@@
@
text
@a249 10
stripcom() {                                                                    
	local _file=$1 _line
	[[ -f ${_file} ]]

	while read _line; do
		_line=${_line%%#*}
		[[ -n ${_line} ]] && print -r -- "${_line}"
	done <${_file}
}

d265 3
a267 1
# XXX needs a way to match release <=> syspatch
d273 4
a276 2
[[ $@@ == @@(|-[[:alpha:]]) ]] || usage; [[ $@@ == @@(|-(c|r)) ]] &&
	(($(id -u) != 0)) && sp_err "${0##*/}: need root privileges"
a278 3
_MIRROR=$(stripcom /etc/installurl) ||
	sp_err "${0##*/}: no mirror configured in /etc/installurl"
_MIRROR=${_MIRROR}/syspatch/${_KERNV[0]}/$(machine)/
d282 2
a283 1
readonly _BSDMP _MIRROR _OSrev _PDIR _REL _TMP
@


1.84
log
@ls_missing(): as a precaution, don't output anything on stdout when running
ftp(1) to prevent corrupting the patch list; we are already running in silent
mode but better safe than sorry.

Read the syspatch mirror base URL using stripcom() /etc/mirror.conf for the time
being; discussed with deraadt@@ and rpe@@ -- naming is not set in stone yet.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.78 2016/12/08 09:47:37 ajacoutot Exp $
d184 1
a184 1
	unpriv -f "${_sha}.sig" ftp -MVo "${_sha}.sig" "${_MIRROR}/SHA256.sig" |
d285 2
a286 2
_MIRROR=$(stripcom /etc/mirror.conf) ||
	sp_err "${0##*/}: no mirror configured in /etc/mirror.conf"
@


1.83
log
@Use the _syspatch user.
@
text
@d143 1
a143 1
		"${_TMP}/${_tgz}" "${_URL}/${_tgz}"
d183 3
a185 1
	unpriv -f "${_sha}.sig" ftp -MVo "${_sha}.sig" "${_URL}/SHA256.sig"
d187 1
a187 1
		/etc/signify/openbsd-${_OSrev}-syspatch.pub
d250 10
d285 3
d291 1
a291 3
# XXX to be discussed
_URL=https://syspatch.openbsd.org/pub/OpenBSD/${_KERNV[0]}/syspatch/$(machine)
readonly _BSDMP _FETCH _OSrev _PDIR _REL _TMP _URL
@


1.82
log
@Drop the _FETCH variable. It's useless, we are using ftp(1) specific options
that are different on the two invocations; it's not like we'll support using
wget|curl to fetch syspatches anyway.
@
text
@d250 1
a250 2
	# XXX use a dedicated user?
	local _file=$2 _user=_pkgfetch
@


1.81
log
@Match what the installer does:
- verify SHA256.sig and create SHA256 out of it
- get the list of syspatches from the verified SHA256
- use sha256 against the verified SHA256 to checksum the syspatches
@
text
@d142 1
a142 1
	unpriv -f "${_TMP}/${_tgz}" ${_FETCH} -mD "Get/Verify" -o \
d183 1
a183 1
	unpriv -f "${_sha}.sig" ${_FETCH} -o "${_sha}.sig" "${_URL}/SHA256.sig"
a273 1
_FETCH="ftp -MV"
@


1.80
log
@Drop FTP_KEEPALIVE, it's unused.
@
text
@d139 1
a139 1
	local _sig=${_TMP}/SHA256.sig _tgz=$1
a141 3
	[[ -f ${_sig} ]] || \
		unpriv -f "${_sig}" ${_FETCH} -o "${_sig}" "${_URL}/SHA256.sig"

d145 1
a145 3
	(cd ${_TMP} && unpriv signify -qC -p \
		/etc/signify/openbsd-${_OSrev}-syspatch.pub -x SHA256.sig \
		${_tgz})
d181 1
a181 1
	local _c _idx=${_TMP}/idx.txt _l="$(ls_installed)"
d183 3
a185 1
	unpriv -f "${_idx}" ${_FETCH} -o "${_idx}" "${_URL}/index.txt"
d187 1
a187 1
	grep -Eo "syspatch${_OSrev}-[[:digit:]]{3}_[[:alnum:]_]+" ${_idx} |
@


1.79
log
@The syspatch test repo can now be accessed over https.
@
text
@d277 1
a277 1
_FETCH="ftp -MVk ${FTP_KEEPALIVE-0}"
@


1.78
log
@Make it possible to install patches even if we don't have all sets installed
(e.g. no x sets); in this case, syspatch will skip the patch *but* it will still
be listed as available. This will allow applying the patch in case sets are
installed later on.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.74 2016/12/06 11:10:00 ajacoutot Exp $
d282 1
a282 1
_URL=http://syspatch.openbsd.org/pub/OpenBSD/${_KERNV[0]}/syspatch/$(machine)
@


1.77
log
@Cleanup syspatch directories that do not contain a tarball; it means it
was not applied properly.
@
text
@d50 6
a130 3
	# missing archive (empty _rbfiles list)
	[[ -f ${_PDIR}/${_patch}/rollback.tgz ]] || _ret=$?

a185 1
	# XXX match with installed sets
@


1.76
log
@Missed in previous.
@
text
@d234 1
a234 1
			[[ -d ${_d} ]] || rm -r ${_d}
@


1.75
log
@Better matching and remove a useless use of sort(1).
@
text
@d238 1
a238 1
	for _k in /bsd.syspatch*; do
@


1.74
log
@Catch mtree(8) error; it's only run when applying patches and we already
check for read-only... in this case.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.65 2016/11/30 13:53:14 ajacoutot Exp $
d176 1
a176 1
	for _p in ${_PDIR}/*; do
d183 9
a191 14
	# XXX match with installed sets (comp, x...)?
	local _index=${_TMP}/index.txt _installed _p
	_installed="$(ls_installed)"

	unpriv -f "${_index}" ${_FETCH} -o "${_index}" "${_URL}/index.txt"

	for _p in $(grep -o "syspatch${_OSrev}-[0-9][0-9][0-9]_.*" ${_index} |
		sed "s/^syspatch${_OSrev}-//;s/.tgz$//"| sort -V); do
		if [[ -n ${_installed} ]]; then
			echo ${_p} | grep -qw -- "${_installed}" || echo ${_p}
		else
			echo ${_p}
		fi
	done
d198 1
a198 1
	_patch="$(ls_installed | sort -V | tail -1)"
d233 2
a234 2
		[[ -e ${_d} ]] || continue
		[[ ${_d##*/} == ${_OSrev}-@@([0-9][0-9][0-9])_* ]] || rm -r ${_d}
@


1.73
log
@Tweak comment.
@
text
@d248 1
a248 2
	# in case a patch added a new directory (install -D);
	# non-fatal in case some mount point is read-only or remote
d250 1
a250 1
		[[ -f ${_m} ]] && mtree -qdef ${_m} -p / -U >/dev/null || true
@


1.72
log
@Explicit error when running on unsupported release.
@
text
@d98 1
d125 1
a125 1
	# XXX missing archive (empty _rbfiles list) probably means a missing set
@


1.71
log
@If we end up creating a rollback tarball from an empty list of files, it means
we are missing a base set. In this case, error out right away or we may end up
having the patch supposedly installed but without its corresponding rollback
tarball.
For now we only support *full* installations.

installed patches mismatch reported by Marc Benslahdine
@
text
@d274 1
a274 1
[[ -z ${_KERNV[1]} ]]
@


1.70
log
@Remove the ugly temporary quirks.
@
text
@d98 1
a98 1
	local _file _patch=$1 _rbfiles
d113 17
a129 15
	if ! (cd / &&
		# GENERIC.MP: substitute bsd.mp->bsd and bsd.sp->bsd
		if ${_BSDMP} &&
			tar -tzf ${_TMP}/syspatch${_patch}.tgz bsd >/dev/null \
				2>&1; then
			tar -czf ${_PDIR}/${_patch}/rollback.tgz \
				-s '/^bsd.mp$//' -s '/^bsd$/bsd.mp/' \
				-s '/^bsd.sp$/bsd/' bsd.sp ${_rbfiles}
		else
			tar -czf ${_PDIR}/${_patch}/rollback.tgz \
				${_rbfiles}
		fi
	); then
		rm -r ${_PDIR}/${_patch}
		sp_err "Failed to create rollback patch ${_patch##${_OSrev}-}"
@


1.69
log
@Simplify.
@
text
@a172 36
	### XXX temporary quirks; remove before 6.1 ############################
	local _r _s _t _u _v
	if [[ -f /bsd.rollback${_OSrev} ]]; then
		[[ $(id -u) -ne 0 ]] && sp_err "${0##*/}: need root privileges"
		mv /bsd.rollback${_OSrev} /bsd.syspatch${_OSrev}
	fi
	if [[ -d ${_PDIR}/${_KERNV[0]} ]]; then
		( cd ${_PDIR}/${_KERNV[0]} && for _r in *; do
			if [[ ${_r} == rollback-syspatch-${_OSrev}-*.tgz ]]; then
				[[ $(id -u) -ne 0 ]] &&
					sp_err "${0##*/}: need root privileges"
				mv ${_r} rollback${_OSrev}${_r#*-syspatch-${_OSrev}}
			fi
		done )
		( cd ${_PDIR}/${_KERNV[0]} && for _s in *; do
			if [[ ${_s} == rollback${_OSrev}-*.tgz ]]; then
				[[ $(id -u) -ne 0 ]] &&
					sp_err "${0##*/}: need root privileges"
				_t=${_s#rollback${_OSrev}-}
				_t=${_t%.tgz}
				mv ${_s} ${_t}.rollback.tgz
			fi
		done )
		( cd ${_PDIR}/${_KERNV[0]} && for _u in *; do
			if [[ ${_u} == *.rollback.tgz ]]; then
				[[ $(id -u) -ne 0 ]] &&
					sp_err "${0##*/}: need root privileges"
				_v=${_u%.rollback.tgz}
				install -d ${_PDIR}/${_OSrev}-${_v}
				mv ${_u} ${_PDIR}/${_OSrev}-${_v}/rollback.tgz
				mv ${_v}.patch.sig ${_PDIR}/${_OSrev}-${_v}/
			fi
		done )
		rmdir ${_PDIR}/${_KERNV[0]}
	fi
	########################################################################
@


1.68
log
@Few consistency fixes (no intended change in behaviour).
Fix logic in the error path of rollback_patch().
@
text
@d164 1
a164 2
		[[ ${_kern##*/} == bsd ]] && _bsd=bsd.sp
		[[ ${_kern##*/} == bsd.mp ]] && _bsd=bsd
d166 1
@


1.67
log
@Fix kernel matching installation:
bsd -> /bsd (sp) | /bsd.sp (mp)
bsd.mp -> /bsd (mp) | /bsd.mp (sp)

issue reported by Ossi Salmi, thanks!
@
text
@d51 1
a51 1
		((${_ret} == 0)) || break
d59 1
a59 1
	if ((${_ret} != 0)); then
d91 2
a92 3
		_sz=$(($((${_d}))/1024))
		[[ ${_df} -gt ${_sz} ]] ||
			sp_err "No space left on device ${_d}, aborting"
d249 1
a249 1
		((${_ret} == 0)) || break
d261 1
a261 1
	rm -r ${_PDIR}/${_patch} && ((${_ret} == 0)) ||
d313 1
a313 1
[[ $(sysctl -n hw.ncpufound) -gt 1 ]] && _BSDMP=true || _BSDMP=false
d338 1
a338 1
if ((${OPTIND} == 1)); then
@


1.66
log
@Simplify:
- consistency in integer checks
- drop apply_patches(), better call ther actual apply_patch() function from
within the script itself
@
text
@d161 1
a161 1
	local _bsd=/bsd _kern=$1
d165 2
a166 5
		[[ ${_kern##*/} == bsd ]] && _bsd=/bsd.sp
	fi

	if [[ -n ${_bsd} ]]; then
		install -FS ${_kern} ${_bsd}
d168 1
@


1.65
log
@During early testing, hardcode the syspatch repo to 'syspatch.openbsd.org'
which points to ftp.fr. This will change once 6.1 is out.

discussed with deraadt@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.62 2016/11/27 08:55:48 ajacoutot Exp $
d38 6
a43 1
	install -d ${_explodir}
a47 2
	install -d -m 0755 ${_PDIR}/${_patch}

d51 1
a51 1
		[[ ${_ret} == 0 ]] || break
d59 1
a59 1
	if [[ ${_ret} != 0 ]]; then
d63 1
a63 15
}

apply_patches()
{
	local _patch

	for _patch in $(ls_missing); do
		echo "Applying patch ${_patch}"
		fetch_and_verify "syspatch${_OSrev}-${_patch}.tgz"
		trap '' INT
		apply_patch "${_OSrev}-${_patch}"
		trap exit INT
	done

	sp_cleanup
d252 1
a252 1
		[[ ${_ret} == 0 ]] || break
d264 1
a264 1
	rm -r ${_PDIR}/${_patch} && [[ ${_ret} == 0 ]] ||
d302 1
a302 1
	(( $# >= 1 ))
d314 1
a314 1
	[[ $(id -u) -ne 0 ]] && sp_err "${0##*/}: need root privileges"
d338 1
a338 1
shift $(( OPTIND -1 ))
d341 6
a346 1
[[ ${OPTIND} != 1 ]] || apply_patches
@


1.64
log
@Change the hierarchy under /var/syspatch/ so that the output of installed or
missing patches matches the official names.
e.g.
$ doas syspatch -c
015_libssl

Add a bit more output on what we are doing.
Tighten a few checks and rename some vars.

People playing with syspatch on 6.0 should update syspatch.sh asap from current
as I will soon remove the temporary quirks glue.
@
text
@d149 1
a149 1
		unpriv -f "${_sig}" ${_FETCH} -o "${_sig}" "${PATCH_PATH}/SHA256.sig"
d152 1
a152 1
		"${_TMP}/${_tgz}" "${PATCH_PATH}/${_tgz}"
d234 1
a234 1
	unpriv -f "${_index}" ${_FETCH} -o "${_index}" "${PATCH_PATH}/index.txt"
a326 5
# XXX to be discussed; check for $ARCH?
[[ -d ${PATCH_PATH} ]] && PATCH_PATH="file://$(readlink -f ${PATCH_PATH})"
[[ ${PATCH_PATH%%://*} == @@(file|ftp|http|https) ]] ||
	sp_err "No valid PATCH_PATH set"

d332 3
a334 1
readonly _BSDMP _FETCH _OSrev _PDIR _REL _TMP
@


1.63
log
@Remove the backup kernel in rollback_patch() instead of the cleanup
function.
Consistent use of install(1).
@
text
@d40 1
a40 1
	_files="$(tar xvzphf ${_TMP}/${_patch}.tgz -C ${_explodir})"
d43 2
d57 1
a57 1
		sp_err "Failed to apply ${_patch} (/${_file})" 0
d67 2
a68 1
		fetch_and_verify "${_patch}"
d70 1
a70 1
		apply_patch "${_patch}"
d90 1
a90 1
		${_BSDMP} || [[ ! -f /bsd.syspatch${_RELINT} ]] &&
a111 1
	local _rbpatch=${_patch#syspatch${_RELINT}-}.rollback.tgz
a115 2
	[[ -d ${_PDIR}/${_REL} ]] || install -d -m 0755 ${_PDIR}/${_REL}

d119 2
a120 2
		if [[ ${_file} == bsd && ! -f /bsd.syspatch${_RELINT} ]]; then
			install -FSp /bsd /bsd.syspatch${_RELINT}
d128 3
a130 2
			tar -tzf ${_TMP}/${_patch}.tgz bsd >/dev/null 2>&1; then
			tar -czf ${_PDIR}/${_REL}/${_rbpatch} \
d134 2
a135 1
			tar -czf ${_PDIR}/${_REL}/${_rbpatch} ${_rbfiles}
d138 2
a139 2
		rm ${_PDIR}/${_REL}/${_rbpatch}
		sp_err "Failed to create rollback for ${_patch}"
d145 8
a152 2
	local _patch=$1 _sig=${_TMP}/SHA256.sig
	[[ -n ${_patch} ]]
a153 3
	unpriv -f "${_sig}" ${_FETCH} -o "${_sig}" "${PATCH_PATH}/SHA256.sig"
	unpriv -f "${_TMP}/${_patch}.tgz" ${_FETCH} -mD "Applying" -o \
		"${_TMP}/${_patch}.tgz" "${PATCH_PATH}/${_patch}.tgz"
d155 2
a156 2
		/etc/signify/openbsd-${_RELINT}-syspatch.pub -x SHA256.sig \
		${_patch}.tgz)
d187 3
a189 3
	### XXX temporary quirks; remove before 6.1
	local _r _s _t
	if [[ ! -d ${_PDIR}/${_REL} ]]; then
d191 1
a191 1
		install -d -m 0755 ${_PDIR}/${_REL}
d193 28
a220 3
	if [[ -f /bsd.rollback${_RELINT} ]]; then
		[[ $(id -u) -ne 0 ]] && sp_err "${0##*/}: need root privileges"
		mv /bsd.rollback${_RELINT} /bsd.syspatch${_RELINT}
d222 3
a224 20
	( cd ${_PDIR}/${_REL} && for _r in *; do
		if [[ ${_r} == rollback-syspatch-${_RELINT}-*.tgz ]]; then
			[[ $(id -u) -ne 0 ]] && \
				sp_err "${0##*/}: need root privileges"
			mv ${_r} rollback${_RELINT}${_r#*-syspatch-${_RELINT}}
		fi
	done )
	( cd ${_PDIR}/${_REL} && for _s in *; do
		if [[ ${_s} == rollback${_RELINT}-*.tgz ]]; then
			[[ $(id -u) -ne 0 ]] && \
				sp_err "${0##*/}: need root privileges"
			_t=${_s#rollback${_RELINT}-}
			_t=${_t%.tgz}
			mv ${_s} ${_t}.rollback.tgz
		fi
	done )
	###
	for _p in ${_PDIR}/${_REL}/*.rollback.tgz; do
		[[ -f ${_p} ]] && _p=${_p##*/} &&
			echo syspatch${_RELINT}-${_p%%.*}
d231 1
a231 1
	local _a _index=${_TMP}/index.txt _installed
d233 1
a233 1
	
d236 2
a237 2
	for _a in $(sed 's/^.* //;s/^M//;s/.tgz$//' ${_index} |
		grep "^syspatch${_RELINT}-.*$" | sort -V); do
d239 1
a239 1
			echo ${_a} | grep -qw -- "${_installed}" || echo ${_a}
d241 1
a241 1
			echo ${_a}
d248 1
a248 1
	local _explodir _file _files _patch _rbpatch _ret=0
d253 2
a254 2
	_rbpatch=${_patch#syspatch${_RELINT}-}.rollback.tgz
	_explodir=${_TMP}/${_rbpatch%.tgz}
d256 1
a256 1
	echo "Reverting ${_patch}"
d259 2
a260 2
	_files="$(tar xvzphf ${_PDIR}/${_REL}/${_rbpatch} -C ${_explodir})"
	checkfs ${_files} ${_PDIR}/${_REL} # check for ro /var/syspatch/${OSREV}
d268 2
a269 2
			cmp -s /bsd /bsd.syspatch${_RELINT} &&
				rm -f /bsd.syspatch${_RELINT}
d275 2
a276 5
	# `-f' in case we failed to install *.patch.sig
	rm -f ${_PDIR}/${_REL}/${_patch#syspatch${_RELINT}-}.patch.sig

	rm ${_PDIR}/${_REL}/${_rbpatch} && [[ ${_ret} == 0 ]] ||
		sp_err "Failed to revert ${_patch}" ${_ret}
d286 1
a286 1
		[[ ${_d##*/} == ${_REL} ]] || rm -r ${_d}
d292 1
a292 1
		[[ ${_k} == /bsd.syspatch${_RELINT} ]] || rm ${_k}
d297 2
a298 2
	for _m in 4.4BSD BSD.x11; do
		mtree -qdef /etc/mtree/${_m}.dist -p / -U >/dev/null || true
d334 1
a335 2
_REL=${_KERNV[0]}
_RELINT=${_REL%\.*}${_REL#*\.}
d337 1
a337 1
readonly _BSDMP _FETCH _PDIR _REL _RELINT _TMP
d342 1
a342 1
[[ -n ${_REL} && -n ${_RELINT} ]]
@


1.62
log
@Explicitely set umask.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.58 2016/11/21 16:27:36 ajacoutot Exp $
d38 1
a38 1
	mkdir -p ${_explodir}
d244 1
a244 1
	mkdir -p ${_explodir}
d253 4
a266 2

	sp_cleanup
a283 3

	# remove rollback kernel if all kernel syspatches have been reverted
	! cmp -s /bsd /bsd.syspatch${_RELINT} || rm /bsd.syspatch${_RELINT}
@


1.61
log
@Check args.
@
text
@d20 1
@


1.60
log
@Make sure /var/syspatch/$OSREV is not on a read-only mount-point when doing
a rollback.
@
text
@d314 2
a315 2
[[ $@@ == @@(|-c|-r) ]] && [[ $(id -u) -ne 0 ]] && \
	sp_err "${0##*/}: need root privileges"
@


1.59
log
@Allow passing an explicit return code to sp_err() in case we don't want to exit
right away.
Factorise some common stuff.
Be consistent in variables subtitution.
@
text
@d246 1
a246 1
	checkfs ${_files}
@


1.58
log
@Use the same basename for the rollback tarball as the original patch.sig.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.57 2016/11/21 14:43:52 ajacoutot Exp $
d23 1
a23 1
	echo "${@@}" 1>&2 && return 1
d33 1
a33 1
	local _explodir _file _files _patch=$1
d45 1
d47 1
a47 4
			if ! install_kernel ${_explodir}/${_file}; then
				rollback_patch
				sp_err "Failed to apply ${_patch} (/${_file})"
			fi
d49 1
a49 4
			if ! install_file ${_explodir}/${_file} /${_file}; then
				rollback_patch
				sp_err "Failed to apply ${_patch} (/${_file})"
			fi
d52 5
d92 1
a92 1
		${_files}) || true # ignore nonexistent files
d234 1
a234 1
	local _explodir _file _files _patch _rbpatch
d240 1
a240 1
	_explodir=${_TMP}/${_rbpatch}
d249 1
d251 1
a251 2
			install_kernel ${_explodir}/${_file} ||
				sp_err "Failed to revert ${_patch} (/${_file})"
d253 1
a253 2
			install_file ${_explodir}/${_file} /${_file} ||
				sp_err "Failed to revert ${_patch} (/${_file})"
d257 5
a261 1
	rm ${_PDIR}/${_REL}/{${_rbpatch},${_rbpatch%rollback.tgz}patch.sig}
d273 1
a273 1
		[[ ${_d:##*/} == ${_REL} ]] || rm -r ${_d}
d319 1
a319 1
[[ ${PATCH_PATH:%%://*} == @@(file|ftp|http|https) ]] ||
@


1.57
log
@Tweak comment. Reverse cmp logic while here.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.47 2016/11/12 22:22:25 halex Exp $
d108 1
a108 1
	local _rbpatch=rollback${_patch#syspatch}
d128 1
a128 1
			tar -czf ${_PDIR}/${_REL}/${_rbpatch}.tgz \
d132 1
a132 2
			tar -czf ${_PDIR}/${_REL}/${_rbpatch}.tgz \
				${_rbfiles}
d135 1
a135 1
		rm ${_PDIR}/${_REL}/${_rbpatch}.tgz
d182 1
a182 1
	local _r
d198 9
d208 3
a210 3
	for _p in ${_PDIR}/${_REL}/rollback${_RELINT}-*.tgz; do
		[[ -f ${_p} ]] && _p=${_p:##*/} && _p=${_p#rollback} &&
			echo syspatch${_p%.tgz}
d239 1
a239 1
	_rbpatch=rollback${_patch#syspatch}
d245 1
a245 2
	_files="$(tar xvzphf ${_PDIR}/${_REL}/${_rbpatch}.tgz -C \
		${_explodir})"
d258 1
a258 2
	rm ${_PDIR}/${_REL}/${_rbpatch}.tgz \
		${_PDIR}/${_REL}/${_patch#syspatch${_RELINT}-}.patch.sig
@


1.56
log
@Re-add the root user checks in the quirks; that part is to be removed soon.
@
text
@d267 1
a267 1
	# remove non matching release rollback kernel
d274 1
a274 1
	cmp -s /bsd /bsd.syspatch${_RELINT} && rm /bsd.syspatch${_RELINT}
@


1.55
log
@Drop priv. to the _pkgfetch (for now) user when running ftp(1) and signify(1).
Similar to what the installer does.

Listing installed patches and displaying the usage are now the only actions
allowed to a non-privileged user.

discussed with deraadt@@
@
text
@d185 1
d189 1
d194 2
@


1.54
log
@Merge comments altogether, it's easier to understand this way.
And drop some duplicate while here.
@
text
@a30 5
needs_root()
{
	[[ $(id -u) -ne 0 ]] && sp_err "${0##*/}: need root privileges"
}

a60 1
	needs_root
d143 1
a143 2
	# XXX privsep ala installer (doas|su)?
	local _patch=$1
d146 4
a149 4
	${_FETCH} -o "${_TMP}/SHA256.sig" "${PATCH_PATH}/SHA256.sig"
	${_FETCH} -mD "Applying" -o "${_TMP}/${_patch}.tgz" \
		"${PATCH_PATH}/${_patch}.tgz"
	(cd ${_TMP} && /usr/bin/signify -qC -p \
a184 1
		needs_root
a187 1
		needs_root
a191 1
			needs_root
d205 1
a205 1
	local _a _installed
d207 2
d210 1
a210 3
	${_FETCH} -o "${_TMP}/index.txt" "${PATCH_PATH}/index.txt"

	for _a in $(sed 's/^.* //;s/^M//;s/.tgz$//' ${_TMP}/index.txt |
a221 1
	needs_root
d279 16
d301 2
a302 2
# check args
[[ $@@ == @@(|-[[:alpha:]]) ]] || usage
d310 1
a310 1
_FETCH="/usr/bin/ftp -MVk ${FTP_KEEPALIVE-0}"
@


1.53
log
@If we install a new kernel, add /bsd twice (for size checking) when:
- we are on an MP system (/bsd.mp does not exist there)
- /bsd.syspatchXX is not present (create_rollback will add it)
@
text
@d79 7
a90 3
	# if we install a new kernel, add /bsd twice (for size checking) when:
	# - we are on an MP system (/bsd.mp does not exist there)
	# - /bsd.syspatchXX is not present (create_rollback will add it)
a95 1
	# assume old files are about the same size as new ones
a100 1
		# make sure the fs is local and RW
a102 4
		# quick-and-dirty size check:
		# - assume old files are about the same size as new ones
		# - ignore new (nonexistent) files
		# - check against all files total size, reduces margin of error
d104 1
a104 1
		_sz=$(($((${_d}))/1024)) # total size of all files
@


1.52
log
@/bsd.rollbackXX -> bsd.syspatchXX to make it more obvious where it comes from
and less prone to conflict.
Simplify ls_installed while here.
@
text
@d84 8
@


1.51
log
@checkfs: ignore nonexistent files and extend comment. There's actually no need
to double the size since files are replaced one by one.

create_rollback: create release directory with explicit permissions.

ls_installed: create release directory if it does not exist (temporary XXX) for
early testers without a 6.1 hier(7); issue reported by Marc Benslahdine
@
text
@d118 2
a119 2
		if [[ ${_file} == bsd && ! -f /bsd.rollback${_RELINT} ]]; then
			install -FSp /bsd /bsd.rollback${_RELINT}
d183 1
a183 1
	### XXX TMP
d189 4
d200 3
a202 4
	for _p in ${_PDIR}/${_REL}/*; do
		_p=${_p:##*/}
		[[ ${_p} == rollback${_RELINT}-*.tgz ]] &&
			_p=${_p#rollback} && echo syspatch${_p%.tgz}
d269 1
a269 1
	for _k in /bsd.rollback*; do
d271 1
a271 1
		[[ ${_k} == /bsd.rollback${_RELINT} ]] || rm ${_k}
d275 1
a275 1
	cmp -s /bsd /bsd.rollback${_RELINT} && rm /bsd.rollback${_RELINT}
@


1.50
log
@Double the required size to make sure we have enough space for install(1) safe
copy, the rollback tarball and in case we add new files.
@
text
@d84 1
d87 1
a87 1
		${_files})
d90 1
d93 4
d98 1
a98 3
		# double the required size to make sure we have enough space for
		# install(1) safe copy, the rollback tarball and new files
		_sz=$(($((${_d}))/1024*2))
d113 1
a113 1
	[[ -d ${_PDIR}/${_REL} ]] || install -d ${_PDIR}/${_REL}
d185 4
@


1.49
log
@Check for available space before installing a patch.
@
text
@a88 1
		# make sure the fs is local and RW
a90 1
		# make sure we have enough space
d92 3
a94 1
		_sz=$(($((${_d}))/1024))
@


1.48
log
@uniq -> sort -u
@
text
@d81 1
a81 2
	# XXX check for available space
	local _d _files="${@@}"
d84 6
a89 1
	for _d in $(stat -qf "%Sd" ${_files} | sort -u); do
d91 6
a96 1
		sp_err "Remote or read-only filesystem, aborting"
@


1.47
log
@Improve the cleanup error handling to make sure the exit code is
really preserved.

Noticed by, discussed with, and fix approved tb@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.46 2016/11/10 13:56:57 ajacoutot Exp $
d81 1
d85 1
a85 1
	for _d in $(stat -qf "%Sd" ${_files} | uniq); do
d264 1
@


1.46
log
@Simplify checkfs() and fix read-only/remote fs detection.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.42 2016/11/08 16:39:57 ajacoutot Exp $
d284 2
a285 2
trap 'rm -rf "${_TMP}"' EXIT
trap exit HUP INT TERM ERR
@


1.45
log
@Extend mtree(8) comment.
@
text
@d81 1
a81 1
	local _d _f _files="${@@}"
d84 3
a86 3
	for _d in $(stat -qf "%Sd" $(for _f in ${_files}; do echo /${_f%/*}
		done | uniq)); do mount | grep -q "^/dev/${_d} .*read-only" &&
			sp_err "Remote or read-only filesystem, aborting"
d257 1
a257 1
	# non-fatal in case some mount points are read-only
@


1.44
log
@Remove redundant check.
@
text
@d256 2
a257 1
	# non-fatal: the syspatch|rollback tarball should have correct perms
@


1.43
log
@Create the bsd rollback kernel in create_rollback() (it is contained in
the rollback tarball anyway but that's impractical if the new bsd does
not boot ;-)).
While here, make sure /bsd actually exists before saving it.
@
text
@d104 1
a104 1
		if [[ ${_file} == bsd && -f /bsd && ! -f /bsd.rollback${_RELINT} ]]; then
@


1.42
log
@syspatch-60-001_foobar -> syspatch60-001_foobar to match base system sets name.

Should be transparent to the early testers as long as you have the most recent
syspatch.sh checkout from cvs(1).
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.39 2016/11/04 16:03:45 ajacoutot Exp $
d103 4
a155 4

	# only save the original release kernel once
	[[ -f /bsd.rollback${_RELINT} ]] ||
		install -FSp /bsd /bsd.rollback${_RELINT}
@


1.41
log
@Few fixes and consistency.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.40 2016/11/06 19:12:58 halex Exp $
d94 1
d110 1
a110 1
			tar -czf ${_PDIR}/${_REL}/rollback-${_patch}.tgz \
d114 1
a114 1
			tar -czf ${_PDIR}/${_REL}/rollback-${_patch}.tgz \
d118 1
a118 1
		rm ${_PDIR}/${_REL}/rollback-${_patch}.tgz
d169 9
d180 2
a181 2
		[[ ${_p} == rollback-syspatch-${_RELINT}-*.tgz ]] &&
			_p=${_p#rollback-} && echo ${_p%.tgz}
d194 1
a194 1
		grep "^syspatch-${_RELINT}-.*$" | sort -V); do
d206 1
a206 1
	local _explodir _file _files _patch
d211 2
a212 1
	_explodir=${_TMP}/rollback-${_patch}
d217 1
a217 1
	_files="$(tar xvzphf ${_PDIR}/${_REL}/rollback-${_patch}.tgz -C \
d231 2
a232 2
	rm ${_PDIR}/${_REL}/rollback-${_patch}.tgz \
		${_PDIR}/${_REL}/${_patch#syspatch-${_RELINT}-}.patch.sig
@


1.40
log
@Rework the cleanup trap handling using the EXIT trap;

  trap 'cleanup; goes; here' EXIT
  trap exit HUP INT TERM ERR FOO BAR BAZ

This makes sure the cleanup is always done (unless we exec), and
preserves the exit code, such as SIGINT => 130.

Also trap less signals. Special signals are special.

tested and OK ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.39 2016/11/04 16:03:45 ajacoutot Exp $
d41 1
a41 1
	local _explodir=${_TMP}/${_patch}
d67 1
a67 1
	local _m _patch _patches="$(ls_missing)"
d69 1
a69 1
	for _patch in ${_patches}; do
d81 1
a81 1
	local _files="${@@}"
a83 2
	local _d _f

d124 1
a124 1
	# XXX privsep ala installer
a127 2
	local _key="/etc/signify/openbsd-${_RELINT}-syspatch.pub" _p

d131 3
a133 2
	(cd ${_TMP} &&
		/usr/bin/signify -qC -p ${_key} -x SHA256.sig ${_patch}.tgz)
d139 1
a139 1
	local _src=$1 _dst=$2
a141 1
	local _fmode _fown _fgrp
d170 1
a170 1
		[[ ${_p} = rollback-syspatch-${_RELINT}-*.tgz ]] &&
d201 2
a203 1
	_explodir=${_TMP}/rollback-${_patch}
@


1.39
log
@Be verbose when PATCH_PATH is not set (that is temporary until we agree on
a way to point to a syspatch mirror).
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.34 2016/11/03 17:14:31 ajacoutot Exp $
d71 1
a71 1
		trap "" 2
d73 1
a73 1
		trap "rm -rf ${_TMP}; exit 1" 2
d274 4
a279 2
trap "rm -rf ${_TMP}; exit 1" 2 3 9 13 15 ERR

a291 2

rm -rf ${_TMP}
@


1.38
log
@One more XXX.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.37 2016/11/04 14:55:29 ajacoutot Exp $
a80 1
	# XXX make sure we have enough space?
a262 1
[[ -n ${PATCH_PATH} ]]
d264 2
a265 1
[[ ${PATCH_PATH:%%://*} == @@(file|ftp|http|https) ]]
@


1.37
log
@Zap extra space.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.36 2016/11/04 14:18:45 ajacoutot Exp $
d81 1
@


1.36
log
@Make sure our filesystems are local and not read-only.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.34 2016/11/03 17:14:31 ajacoutot Exp $
d87 1
a87 1
		done | uniq)); do mount | grep -q "^/dev/${_d} .* read-only" &&
@


1.35
log
@Use 'rm -f' to remove the rollback tarball if we have an errir; it may
be because we have a read-only /var.
@
text
@a37 1
	# XXX make sure mount points are not read-only
d45 2
d79 13
d119 1
a119 2
		# `-f' in case /var is read-only
		rm -f ${_PDIR}/${_REL}/rollback-${_patch}.tgz
d211 1
@


1.34
log
@Missing local.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.15 2016/09/11 13:10:59 ajacoutot Exp $
d38 1
d105 2
a106 1
		rm ${_PDIR}/${_REL}/rollback-${_patch}.tgz
@


1.33
log
@rollback -> revert where it makes sense.
@
text
@d215 1
a215 1
	local _d _k
@


1.32
log
@XXX match with installed sets (comp, x...)?
@
text
@d200 1
a200 1
				sp_err "Failed to rollback ${_patch} (/${_file})"
d203 1
a203 1
				sp_err "Failed to rollback ${_patch} (/${_file})"
@


1.31
log
@Hardlinks are properly handled; for the rest, we'll see if we need to care
or not (XXX).
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.30 2016/11/03 14:36:54 ajacoutot Exp $
d166 1
@


1.30
log
@Make sure PATCH_PATH is an URL that ftp(1) can cope with.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.15 2016/09/11 13:10:59 ajacoutot Exp $
d126 1
a126 2
	# XXX handle sym/hardlinks?
	# XXX handle dir becoming file and vice-versa?
@


1.29
log
@Merge ls_avail() into ls_missing(), it's only used once.
While here, cope with a missing index.txt or other ftp(1) error.
@
text
@a116 1
	# XXX handle bogus PATCH_PATH (ftp(1) interactive mode)
a117 2

	# XXX handle bogus PATCH_PATH (ftp(1) interactive mode)
a169 1
	# XXX handle bogus PATCH_PATH (ftp(1) interactive mode)
d249 1
@


1.28
log
@Use hw.ncpufound.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.27 2016/11/03 12:27:34 ajacoutot Exp $
d120 1
a120 1
	# XXX see above
a157 8
ls_avail()
{
	# XXX see above + catch missing index.txt
	${_FETCH} -o - "${PATCH_PATH}/index.txt" |
		sed 's/^.* //;s/^M//;s/.tgz$//' |
		grep "^syspatch-${_RELINT}-.*$" | sort -V
}

d173 5
a177 1
	for _a in $(ls_avail); do
d255 1
a255 1
_FETCH="/usr/bin/ftp -MV -k ${FTP_KEEPALIVE-0}"
@


1.27
log
@Simplify for loops; prompted by a comment from rpe@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.15 2016/09/11 13:10:59 ajacoutot Exp $
d258 1
a258 2
# XXX hw.ncpufound ?
[[ $(sysctl -n hw.ncpu) -gt 1 ]] && _BSDMP=true || _BSDMP=false
@


1.26
log
@Be verbose when reverting a patch.

committing now to please espie@@
@
text
@d169 3
a171 4
	# no _REL dir = no installed patch
	cd ${_PDIR}/${_REL} 2>/dev/null && set -- * || return 0
	for _p; do
		 [[ ${_p} = rollback-syspatch-${_RELINT}-*.tgz ]] &&
d226 1
a226 2
	cd ${_PDIR} && set -- *
	for _d; do
d228 1
a228 1
		[[ ${_d} == ${_REL} ]] || rm -r ${_d}
d232 1
a232 2
	set -- /bsd.rollback*
	for _k; do
@


1.25
log
@Simplify.
@
text
@d199 1
@


1.24
log
@Tap SIGINT while install(1)ing so that we can properly rollback and not
be left in an inconsistent state.
@
text
@a46 1
	trap "" 2
a59 1
	trap - 2
d69 1
d71 1
a91 1
	trap "" 2
a106 1
	trap - 2
a204 1
	trap "" 2
a216 1
	trap - 2
d270 1
a270 1
trap "rm -rf ${_TMP}; exit 1" 3 9 13 15 ERR
@


1.23
log
@Add an XXX.
@
text
@d47 1
d61 1
d92 1
d108 1
a192 27
sp_cleanup()
{
	local _d _k

	# remove non matching release /var/syspatch/ content
	cd ${_PDIR} && set -- *
	for _d; do
		[[ -e ${_d} ]] || continue
		[[ ${_d} == ${_REL} ]] || rm -r ${_d}
	done

	# remove non matching release rollback kernel
	set -- /bsd.rollback*
	for _k; do
		[[ -f ${_k} ]] || continue
		[[ ${_k} == /bsd.rollback${_RELINT} ]] || rm ${_k}
	done

	# remove rollback kernel if all kernel syspatches have been reverted
	cmp -s /bsd /bsd.rollback${_RELINT} && rm /bsd.rollback${_RELINT}

	# non-fatal: the syspatch|rollback tarball should have correct perms
	for _m in 4.4BSD BSD.x11; do
		mtree -qdef /etc/mtree/${_m}.dist -p / -U >/dev/null || true
	done
}

d207 1
a217 1
	sp_cleanup
d220 30
d260 1
a260 1
# XXX to be discussed
d274 1
a274 1
trap "rm -rf ${_TMP}; exit 1" 2 3 9 13 15 ERR
@


1.22
log
@Only run sp_cleanup() when applying or reverting a patch (needs root).
@
text
@d158 1
@


1.21
log
@Also remove non matching release rollback kernel.
Temporary unhook the cleanup function during tests.
@
text
@a65 1
	[[ -n ${_patches} ]] || return 0 # nothing to do
d72 1
a72 4
	# non-fatal: the syspatch tarball should have correct permissions
	for _m in 4.4BSD BSD.x11; do
		mtree -qdef /etc/mtree/${_m}.dist -p / -U >/dev/null || true
	done
d208 5
d239 1
@


1.20
log
@Add a cleanup function to remove non matching release content from
/var/syspatch and the rollback kernel if all kernel syspatches have been
reverted.

While here, make sure _RELINT and _REL are declared properly.
@
text
@d194 1
a194 1
	local _d
d203 7
a278 1
sp_cleanup
@


1.19
log
@Simplify fetch_and_verify(), no need for a loop here.
@
text
@a64 1
	# XXX cleanup old rollback patches and sig (installer should as well)
d147 1
a147 1
	# we only save the original release kernel once
d192 15
d255 1
d272 1
@


1.18
log
@Add a few error messages so we know where we fail.
Regular operation is mostly quiet, i.e:
Applying syspatch-60-001_cp.tgz 100% |***********************| 65247       00:03

Move trap after we create the temporary directory so that we can remove it
on failure and fix a typo in readonly vars.
@
text
@d38 1
a38 1
	local _explodir _file _files _patch="$1"
d70 2
a71 1
		fetch_and_verify "${_patch}" && apply_patch "${_patch}"
d115 1
a115 1
	local _patch="$@@"
d120 1
d123 5
a127 7
	for _p in ${_patch}; do
		_p=${_p}.tgz
		 ${_FETCH} -mD "Applying" -o "${_TMP}/${_p}" \
			"${PATCH_PATH}/${_p}"
		(cd ${_TMP} &&
			/usr/bin/signify -qC -p ${_key} -x SHA256.sig ${_p})
	done
@


1.17
log
@install_patch -> apply_patch to remove confusion with install_kernel and
install_file.
@
text
@a20 2
trap "rm -rf ${_TMP}; exit 1" 2 3 9 13 15 ERR

d50 2
a51 1
				rollback_patch; return 1
d55 2
a56 1
				rollback_patch; return 1
d106 2
a107 1
		rm ${_PDIR}/${_REL}/rollback-${_patch}.tgz; return 1
d123 1
a123 1
		 ${_FETCH} -mD "Get/Verify" -o "${_TMP}/${_p}" \
d209 2
a210 1
			install_kernel ${_explodir}/${_file}
d212 2
a213 1
			install_file ${_explodir}/${_file} /${_file}
d240 3
a242 1
readonly _BSDMP _FETCH _PDIR _REL _RELINT_TMP
@


1.16
log
@We don't want to run on -stable (i.e. locally built release) but only on
official release.
Remove the half cooked rollback patch if we run into an error.
@
text
@d38 24
d70 1
a70 1
		fetch_and_verify "${_patch}" && install_patch "${_patch}"
a157 24
}

install_patch()
{
	local _explodir _file _files _patch="$1"
	[[ -n ${_patch} ]]

	local _explodir=${_TMP}/${_patch}
	mkdir -p ${_explodir}

	_files="$(tar xvzphf ${_TMP}/${_patch}.tgz -C ${_explodir})"
	create_rollback ${_patch} "${_files}"

	for _file in ${_files}; do
		if [[ ${_file} == @@(bsd|bsd.mp) ]]; then
			if ! install_kernel ${_explodir}/${_file}; then
				rollback_patch; return 1
			fi
		else
			if ! install_file ${_explodir}/${_file} /${_file}; then
				rollback_patch; return 1
			fi
		fi
	done
@


1.15
log
@First compute the variables, then set them readonly. So that we can catch
errors (e.g. mktemp(1) failing).
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.14 2016/09/11 11:50:34 ajacoutot Exp $
d70 1
a70 1
	(cd / &&
d81 3
a83 1
	)
d218 1
a218 1
# we do not run on current
d221 1
a221 1
[[ -z ${_KERNV[1]} ]] || [[ ${_KERNV[1]} == "-stable" ]]
@


1.14
log
@Indent cleanup.
Fix apply_patches return code while here.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.12 2016/09/10 16:07:33 ajacoutot Exp $
d228 1
d230 6
a235 6
readonly _BSDMP
readonly _FETCH="/usr/bin/ftp -MV -k ${FTP_KEEPALIVE-0}"
readonly _PDIR="/var/syspatch"
readonly _REL=${_KERNV[0]}
readonly _RELINT=${_REL%\.*}${_REL#*\.}
readonly _TMP=$(mktemp -d -p /tmp syspatch.XXXXXXXXXX)
@


1.13
log
@Drop syspatch_trap, it's simple enough for trap no needing its own function.
Introduce sp_err() which will get used for error messages.
@
text
@d41 1
a41 1
	# XXX cleanup mismatch/old rollback patches and sig (installer should as well)
d46 1
a46 2
		fetch_and_verify "${_patch}" && \
			install_patch "${_patch}" || return
d63 2
d70 1
a70 1
	(cd / && \
d72 1
a72 1
		if ${_BSDMP} && \
d98 2
a99 1
		(cd ${_TMP} && /usr/bin/signify -qC -p ${_key} -x SHA256.sig ${_p})
d111 1
a111 2
	eval $(stat -f "_fmode=%OMp%OLp _fown=%Su _fgrp=%Sg" \
		${_src})
d113 1
a113 2
	install -DFS -m ${_fmode} -o ${_fown} -g ${_fgrp} \
		${_src} ${_dst}
d122 1
a122 1
	[[ -f /bsd.rollback${_RELINT} ]] || \
d148 1
a148 2
				rollback_patch
				return 1
d152 1
a152 2
				rollback_patch
				return 1
d160 2
a161 1
	${_FETCH} -o - "${PATCH_PATH}/index.txt" | sed 's/^.* //;s/^M//;s/.tgz$//' | \
d171 1
a171 1
		 [[ ${_p} = rollback-syspatch-${_RELINT}-*.tgz ]] && \
d201 3
a203 1
	_files="$(tar xvzphf ${_PDIR}/${_REL}/rollback-${_patch}.tgz -C ${_explodir})"
d217 1
a217 1
set -A _KERNV -- $(sysctl -n kern.version | \
d247 1
a247 3
if [[ ${OPTIND} == 1 ]]; then
	apply_patches
fi
@


1.12
log
@apply_patches should not take any arguments.
Few tweaks while here.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.11 2016/09/07 16:01:48 ajacoutot Exp $
d21 1
a21 1
trap "syspatch_trap" 2 3 9 13 15 ERR
d23 1
a23 1
usage()
d25 1
a25 1
	echo "usage: ${0##*/} [-c | -l | -r]" >&2 && return 1
d28 1
a28 1
needs_root()
d30 1
a30 2
	[[ $(id -u) -ne 0 ]] && echo "${0##*/}: need root privileges" && \
		return 1
d33 1
a33 1
syspatch_trap()
d35 1
a35 2
	rm -rf ${_TMP}
	exit 1
@


1.11
log
@Don't fetch all patches at once but instead fetch+verify+patch one by one.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.9 2016/09/07 15:19:33 ajacoutot Exp $
d30 2
a31 2
	[[ $(id -u) -eq 0 ]] || \
		(echo "${0##*/}: need root privileges"; return 1)
d44 1
a44 1
	local _m _patch _patches="$@@"
d171 2
a172 1
	cd ${_PDIR}/${_REL} && set -- * || return 0 # no _REL dir = no patch
d249 1
a249 1
	apply_patches $(ls_missing)
@


1.10
log
@Don't put bsd.mp twice in the GENERIC.MP rollback tarball.
@
text
@d42 1
d48 2
a49 2
		fetch_and_verify "${_patch}"
		install_patch "${_patch}"
d194 1
d240 1
a240 1
		r) needs_root && rollback_patch;;
d248 1
a248 1
	needs_root && apply_patches $(ls_missing)
@


1.9
log
@syspatch goal is not to act as a package manager but to sync the system to the
corresponding stable. So prevent rollbacking a specific binpatch but instead
always rollback the latest one. It's the only way we can know the system is
consistent.

discussed with halex@@ jasper@@ robert@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.5 2016/09/05 12:05:13 ajacoutot Exp $
d71 1
a73 2
			# GENERIC.MP: substitute bsd.mp->bsd and bsd.sp->bsd
			# XXX bsd.mp created twice in the tarball
d75 2
a76 2
				-s '/^bsd$/bsd.mp/' -s '/^bsd.sp$/bsd/' \
				${_rbfiles} bsd.sp 2>/dev/null # no /bsd.mp
@


1.8
log
@Drop useless variable and check.
@
text
@d19 2
a22 2
set -e

d25 1
a25 1
	echo "usage: ${0##*/} [-c | -l | -r patchname ]" >&2 && return 1
a33 14
syspatch_sort()
{
	local _p _patch _patches=$(</dev/stdin)
	[[ -n ${_patches} ]] || return 0 # nothing to do

	for _patch in ${_patches}; do
		echo ${_patch##*_}
	done | sort -u | while read _p; do
		echo "${_patches}" | \
			grep -E "syspatch-${_RELINT}-[0-9]{3}_${_p}" | \
			sort -V | tail -1
	done
}

d47 2
a48 2
		fetch_and_verify "${_patch}" || return
		install_patch "${_patch}" || return
d77 1
a77 1
				${_rbfiles} bsd.sp 2>/dev/null || return # no /bsd.mp
d80 1
a80 1
				${_rbfiles} || return
d132 1
a132 1
		install -FS ${_kern} ${_bsd} || return
d150 1
a150 1
				rollback_patch ${_patch}
d155 1
a155 1
				rollback_patch ${_patch}
d194 3
a196 1
	local _explodir _file _files _patch=$1
a198 3
	# make sure the syspatch is installed and is the latest version
	echo ${_patch} | grep -qw -- "$(ls_installed | syspatch_sort)"

d205 1
a205 1
			install_kernel ${_explodir}/${_file} || return
d207 1
a207 1
			install_file ${_explodir}/${_file} /${_file} || return
d220 2
a221 4
# check unallowed args (-ab, -a foo -b, -a -b)
[[ -z $@@ || \
	$@@ == @@(|-[[:alnum:]]@@(|+([[:blank:]])[!-]*([![:blank:]])))*([[:blank:]]) ]] || \
	usage
d235 1
a235 1
while getopts clr: arg; do
d239 1
a239 1
		r) needs_root && rollback_patch "${OPTARG}";;
@


1.7
log
@Greatly simplify patch type detection and make things more generic.
@
text
@d134 1
a134 1
	local _backup=false _bsd=/bsd _kern=$1
d138 2
a139 1
	[[ -f /bsd.rollback${_RELINT} ]] || _backup=true
a142 4
	fi

	if ${_backup}; then
		install -FSp /bsd /bsd.rollback${_RELINT} || return
@


1.6
log
@Sort and set readonly global vars.
@
text
@d73 1
a73 1
	local _file _patch=$1 _rbfiles _type
a78 2
	_type=$(tar -tzf ${_TMP}/${_patch}.tgz bsd 2>/dev/null || echo userland)

d85 3
a87 1
		if [[ ${_type} == bsd ]]; then
d89 3
a91 8
			if ${_BSDMP}; then
				tar -czf ${_PDIR}/${_REL}/rollback-${_patch}.tgz \
					-s '/^bsd$/bsd.mp/' -s '/^bsd.sp$/bsd/' \
					${_rbfiles} bsd.sp 2>/dev/null || return # no /bsd.mp
			else
				tar -czf ${_PDIR}/${_REL}/rollback-${_patch}.tgz \
					${_rbfiles} || return
			fi
a164 1
		# can't rely on _type, we need to install 001_foo.patch.sig
d211 1
a211 1
	local _explodir _file _files _patch=$1 _type
a213 3
	_type=$(tar -tzf ${_PDIR}/${_REL}/rollback-${_patch}.tgz bsd \
		2>/dev/null || echo userland)

d222 1
a222 1
		if [[ ${_type} == bsd ]]; then
@


1.5
log
@Make sure the file exists before putting it in the rollback tarball.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.4 2016/09/05 11:32:28 ajacoutot Exp $
d256 3
d260 3
a262 5
_FETCH="/usr/bin/ftp -MV -k ${FTP_KEEPALIVE-0}"
_REL=${_KERNV[0]}
_RELINT=${_REL%\.*}${_REL#*\.}
_TMP=$(mktemp -d -p /tmp syspatch.XXXXXXXXXX)
[[ $(sysctl -n hw.ncpu) -gt 1 ]] && _BSDMP=true || _BSDMP=false
@


1.4
log
@Missing local.
Shorter var name.
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.3 2016/09/05 11:29:34 robert Exp $
d73 1
a73 1
	local _patch=$1 _type
d81 4
a84 2
	_files="$(echo ${_files} \
		| sed "s|var/syspatch/${_REL}/${_patch#syspatch-60-}.patch.sig||g")"
d92 1
a92 1
					${_files} bsd.sp 2>/dev/null || return # no /bsd.mp
d95 1
a95 1
					${_files} || return
d99 1
a99 1
				${_files} || return
@


1.3
log
@use a for loop for mtree for the two spec files
and add a better comment

ok ajacoutot@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.2 2016/09/05 11:26:18 ajacoutot Exp $
d57 1
a57 1
	local _patch _patches="$@@"
d65 1
a65 1
	# non-fatal -- the syspatch tarball should have correct permissions
d88 1
a88 1
				tar -czf ${_SYSPATCH_DIR}/${_REL}/rollback-${_patch}.tgz \
d92 1
a92 1
				tar -czf ${_SYSPATCH_DIR}/${_REL}/rollback-${_patch}.tgz \
d96 1
a96 1
			tar -czf ${_SYSPATCH_DIR}/${_REL}/rollback-${_patch}.tgz \
d192 1
a192 1
	cd ${_SYSPATCH_DIR}/${_REL} && set -- * || return 0 # no _REL dir = no patch
d218 1
a218 1
	_type=$(tar -tzf ${_SYSPATCH_DIR}/${_REL}/rollback-${_patch}.tgz bsd \
d227 1
a227 1
	_files="$(tar xvzphf ${_SYSPATCH_DIR}/${_REL}/rollback-${_patch}.tgz -C ${_explodir})"
d236 2
a237 2
	rm ${_SYSPATCH_DIR}/${_REL}/rollback-${_patch}.tgz \
		${_SYSPATCH_DIR}/${_REL}/${_patch#syspatch-${_RELINT}-}.patch.sig
d254 1
a254 1
readonly _SYSPATCH_DIR="/var/syspatch"
@


1.2
log
@No need to install the /var/syspatch/$REL directory, the binpatch does it for us.
Put /var/syspatch into a variable, it's used more than 10 times.

prodded by robert@@
@
text
@d3 1
a3 1
# $OpenBSD: syspatch.sh,v 1.1 2016/09/05 11:04:45 ajacoutot Exp $
d65 4
a68 3
	# XXX needed? -- non-fatal
	mtree -qdef /etc/mtree/4.4BSD.dist -p / -U >/dev/null || true
	mtree -qdef /etc/mtree/BSD.x11.dist -p / -U >/dev/null || true
@


1.1
log
@Welcome syspatch(8), a binary patch management utility for the base system.

This is currently a POC, maybe it will become something, maybe not.
Therefore it will not be hooked to the build before we are happy with it.

Workflow would be something like:
- fetch and verify signed tarballs containing the patched binaries from a mirror
- create a rollback tarball of the files we are about to replace
- extract and install the patched files

*** BIG FAT RED DISCLAIMER ***
This is very much WIP, it does *NOT* work, don't bikeshed, don't use it!

"get it in" deraadt@@
@
text
@d3 1
a3 1
# $OpenBSD$
a59 2
	install -d -m 0755 /var/syspatch/${_REL}

d87 1
a87 1
				tar -czf /var/syspatch/${_REL}/rollback-${_patch}.tgz \
d91 1
a91 1
				tar -czf /var/syspatch/${_REL}/rollback-${_patch}.tgz \
d95 1
a95 1
			tar -czf /var/syspatch/${_REL}/rollback-${_patch}.tgz \
d191 1
a191 1
	cd /var/syspatch/${_REL} && set -- *
d217 1
a217 1
	_type=$(tar -tzf /var/syspatch/${_REL}/rollback-${_patch}.tgz bsd \
d226 1
a226 1
	_files="$(tar xvzphf /var/syspatch/${_REL}/rollback-${_patch}.tgz -C ${_explodir})"
d235 2
a236 2
	rm /var/syspatch/${_REL}/rollback-${_patch}.tgz \
		/var/syspatch/${_REL}/${_patch#syspatch-${_RELINT}-}.patch.sig
d253 1
@

