head	1.79;
access;
symbols
	OPENBSD_6_1_BASE:1.79
	OPENBSD_6_0:1.79.0.4
	OPENBSD_6_0_BASE:1.79
	OPENBSD_5_9:1.79.0.2
	OPENBSD_5_9_BASE:1.79
	OPENBSD_5_8:1.75.0.6
	OPENBSD_5_8_BASE:1.75
	OPENBSD_5_7:1.75.0.2
	OPENBSD_5_7_BASE:1.75
	OPENBSD_5_6:1.65.0.4
	OPENBSD_5_6_BASE:1.65
	OPENBSD_5_5:1.63.0.4
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.61.0.2
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.58.0.4
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.58.0.2
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.4
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.56.0.4
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.56.0.2
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.54.0.2
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.53.0.6
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.49.0.4
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.49.0.2
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.44.0.4
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.27.0.4
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.79
date	2015.11.16.17.35.05;	author tedu;	state Exp;
branches;
next	1.78;
commitid	qJJmMTT2zWNnaNXR;

1.78
date	2015.11.13.12.59.25;	author jca;	state Exp;
branches;
next	1.77;
commitid	j2uRhO7qdUQjhkZP;

1.77
date	2015.10.11.20.23.49;	author guenther;	state Exp;
branches;
next	1.76;
commitid	i6P7pBlCuLlhNqfW;

1.76
date	2015.08.28.16.13.58;	author tedu;	state Exp;
branches;
next	1.75;
commitid	HrYcgT9rzQUvmNvP;

1.75
date	2015.02.06.08.16.50;	author dcoppa;	state Exp;
branches;
next	1.74;
commitid	Y0BsHx9r6GXhiW4Y;

1.74
date	2015.01.16.06.40.15;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	Uu5nFG3wCl0LACBb;

1.73
date	2014.10.28.06.04.19;	author dcoppa;	state Exp;
branches;
next	1.72;
commitid	MIWVD0z7dZ426ug2;

1.72
date	2014.10.26.22.16.16;	author guenther;	state Exp;
branches;
next	1.71;
commitid	VEsuFKmQ1pM1IHBT;

1.71
date	2014.10.17.07.41.40;	author jmc;	state Exp;
branches;
next	1.70;
commitid	KafvjMtcOLwLy07L;

1.70
date	2014.10.17.01.55.00;	author tedu;	state Exp;
branches;
next	1.69;
commitid	3d0XOepUjTsn1T1F;

1.69
date	2014.09.26.10.39.28;	author dcoppa;	state Exp;
branches;
next	1.68;
commitid	BJfnyhtUSykpK25y;

1.68
date	2014.09.26.08.55.59;	author tedu;	state Exp;
branches;
next	1.67;
commitid	eLb2aToyNhl3nK5r;

1.67
date	2014.09.15.19.08.22;	author miod;	state Exp;
branches;
next	1.66;
commitid	uuiU9j2I8AUx0fez;

1.66
date	2014.08.15.03.51.40;	author guenther;	state Exp;
branches;
next	1.65;
commitid	ILfd29dGeQRUYnTr;

1.65
date	2014.07.26.10.48.59;	author mpi;	state Exp;
branches;
next	1.64;
commitid	aVI6riP3a3eZyg2n;

1.64
date	2014.07.22.22.09.36;	author tedu;	state Exp;
branches;
next	1.63;
commitid	PwEnjZMJ8yq9P2md;

1.63
date	2013.11.13.04.50.21;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2013.08.22.04.43.41;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2013.05.19.18.37.40;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2013.05.15.22.46.00;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.58;

1.58
date	2012.03.26.20.17.45;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.21.06.45.04;	author jasper;	state Exp;
branches;
next	1.56;

1.56
date	2010.04.02.04.12.46;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2010.03.30.17.42.05;	author oga;	state Exp;
branches;
next	1.54;

1.54
date	2009.08.04.18.26.48;	author jmc;	state Exp;
branches;
next	1.53;

1.53
date	2009.02.26.17.21.56;	author oga;	state Exp;
branches;
next	1.52;

1.52
date	2009.02.26.00.29.39;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2009.02.04.05.22.58;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2009.02.03.01.52.49;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.24.14.58.44;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.18.13.34.23;	author mcbride;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.03.22.14.07;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.28.06.42.43;	author sturm;	state Exp;
branches;
next	1.45;

1.45
date	2007.03.29.22.17.34;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.12.19.40.18;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.15.20.30.28;	author sturm;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.14.22.30.53;	author sturm;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.19.19.17.10;	author sturm;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.02.04.35.49;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2005.12.02.04.27.52;	author beck;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.23.08.21.09;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.23.08.02.58;	author sturm;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.22.09.31.02;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.15.01.21.41;	author jmc;	state Exp;
branches;
next	1.34;

1.34
date	2005.06.14.15.18.53;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.09.04.53.51;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.03.10.22.42.46;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2004.09.14.22.27.46;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.21.19.00.05;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.26.17.03.22;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.11.23.33.25;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.09.06.19.46.52;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.04.07.31.16;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.14.04.21.41;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.16.08.47.50;	author mpech;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.22.00.32.16;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.12.17.03.39;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.09.20.48.17;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.09.14.57.45;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.14.22.18.33;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.14.20.11.22;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.17.22.35.01;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.09.07.05.00;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.07.01.10.42;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.23.01.00.41;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.22.06.06.27;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.22.05.24.03;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.22.04.49.14;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.22.01.14.06;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.09.03.24.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.16.23.33.20;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.06.22.29.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.06.04.21.41.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.07.21.04.06.30;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	98.07.18.02.42.28;	author marc;	state Exp;
branches;
next	1.3;

1.3
date	98.07.10.08.06.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.04.13.02.52.15;	author bitblt;	state Exp;
branches;
next	1.1;

1.1
date	96.04.29.13.08.46;	author hvozda;	state Exp;
branches;
next	;


desc
@@


1.79
log
@fix log messages, from jan stary
@
text
@/*	$OpenBSD: apmd.c,v 1.78 2015/11/13 12:59:25 jca Exp $	*/

/*
 *  Copyright (c) 1995, 1996 John T. Kohl
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/event.h>
#include <sys/time.h>
#include <sys/sched.h>
#include <sys/sysctl.h>
#include <stdio.h>
#include <syslog.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <err.h>
#include <limits.h>
#include <machine/apmvar.h>

#include "pathnames.h"
#include "apm-proto.h"

#define TRUE 1
#define FALSE 0

const char apmdev[] = _PATH_APM_CTLDEV;
const char sockfile[] = _PATH_APM_SOCKET;

int debug = 0;

int doperf = PERF_NONE;

extern char *__progname;

void usage(void);
int power_status(int fd, int force, struct apm_power_info *pinfo);
int bind_socket(const char *sn);
enum apm_state handle_client(int sock_fd, int ctl_fd);
int  get_avg_idle_mp(int ncpu);
int  get_avg_idle_up(void);
void perf_status(struct apm_power_info *pinfo, int ncpu);
void suspend(int ctl_fd);
void stand_by(int ctl_fd);
void hibernate(int ctl_fd);
void setperfpolicy(char *policy);
void sigexit(int signo);
void do_etc_file(const char *file);
void sockunlink(void);
void error(const char *fmt, const char *arg);
void set_driver_messages(int fd, int mode);

/* ARGSUSED */
void
sigexit(int signo)
{
	sockunlink();
	_exit(1);
}

void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-AadHLs] [-f devname] [-S sockname] [-t seconds]\n",
	    __progname);
	exit(1);
}

void
error(const char *fmt, const char *arg)
{
	char buf[128];

	if (debug)
		err(1, fmt, arg);
	else {
		strlcpy(buf, fmt, sizeof(buf));
		strlcat(buf, ": %m", sizeof(buf));
		syslog(LOG_ERR, buf, arg);
		exit(1);
	}
}


/*
 * tell the driver if it should display messages or not.
 */
void
set_driver_messages(int fd, int mode)
{
	if (ioctl(fd, APM_IOC_PRN_CTL, &mode) == -1)
		syslog(LOG_DEBUG, "can't disable driver messages, error: %m");
}

int
power_status(int fd, int force, struct apm_power_info *pinfo)
{
	struct apm_power_info bstate;
	static struct apm_power_info last;
	int acon = 0;

	if (fd == -1) {
		if (pinfo) {
			bstate.battery_state = 255;
			bstate.ac_state = 255;
			bstate.battery_life = 0;
			bstate.minutes_left = -1;
			*pinfo = bstate;
		}

		return 0;
	}

	if (ioctl(fd, APM_IOC_GETPOWER, &bstate) == 0) {
	/* various conditions under which we report status:  something changed
	 * enough since last report, or asked to force a print */
		if (bstate.ac_state == APM_AC_ON)
			acon = 1;
		if (force ||
		    bstate.ac_state != last.ac_state ||
		    bstate.battery_state != last.battery_state ||
		    (bstate.minutes_left && bstate.minutes_left < 15) ||
		    abs(bstate.battery_life - last.battery_life) >= 10) {
#ifdef __powerpc__
			/*
			 * When the battery is charging, the estimated life
			 * time is in fact the estimated remaining charge time
			 * on Apple machines, so lie in the stats.
			 * We still want an useful message if the battery or
			 * ac status changes, however.
			 */
			if (bstate.minutes_left != 0 &&
			    bstate.battery_state != APM_BATT_CHARGING)
#else
			if ((int)bstate.minutes_left > 0)
#endif
				syslog(LOG_NOTICE, "battery status: %s. "
				    "external power status: %s. "
				    "estimated battery life %d%% (%u minutes)",
				    battstate(bstate.battery_state),
				    ac_state(bstate.ac_state),
				    bstate.battery_life,
				    bstate.minutes_left);
			else
				syslog(LOG_NOTICE, "battery status: %s. "
				    "external power status: %s. "
				    "estimated battery life %d%%",
				    battstate(bstate.battery_state),
				    ac_state(bstate.ac_state),
				    bstate.battery_life);
			last = bstate;
		}
		if (pinfo)
			*pinfo = bstate;
	} else
		syslog(LOG_ERR, "cannot fetch power status: %m");

	return acon;
}

char socketname[PATH_MAX];

void
sockunlink(void)
{
	if (socketname[0])
		remove(socketname);
}

int
bind_socket(const char *sockname)
{
	struct sockaddr_un s_un;
	mode_t old_umask;
	int sock;

	sock = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0);
	if (sock == -1)
		error("cannot create local socket", NULL);

	s_un.sun_family = AF_UNIX;
	strlcpy(s_un.sun_path, sockname, sizeof(s_un.sun_path));

	/* remove it if present, we're moving in */
	(void) remove(sockname);

	old_umask = umask(077);
	if (bind(sock, (struct sockaddr *)&s_un, sizeof(s_un)) == -1)
		error("cannot bind on APM socket", NULL);
	umask(old_umask);
	if (chmod(sockname, 0660) == -1 || chown(sockname, 0, 0) == -1)
		error("cannot set socket mode/owner/group to 660/0/0", NULL);

	listen(sock, 1);
	strlcpy(socketname, sockname, sizeof socketname);
	atexit(sockunlink);

	return sock;
}

enum apm_state
handle_client(int sock_fd, int ctl_fd)
{
	/* accept a handle from the client, process it, then clean up */
	int cli_fd;
	struct sockaddr_un from;
	socklen_t fromlen;
	struct apm_command cmd;
	struct apm_reply reply;
	int cpuspeed_mib[] = {CTL_HW, HW_CPUSPEED};
	int cpuspeed = 0;
	size_t cpuspeed_sz = sizeof(cpuspeed);

	fromlen = sizeof(from);
	cli_fd = accept(sock_fd, (struct sockaddr *)&from, &fromlen);
	if (cli_fd == -1) {
		syslog(LOG_INFO, "client accept failure: %m");
		return NORMAL;
	}

	if (recv(cli_fd, &cmd, sizeof(cmd), 0) != sizeof(cmd)) {
		(void) close(cli_fd);
		syslog(LOG_INFO, "client size botch");
		return NORMAL;
	}

	if (cmd.vno != APMD_VNO) {
		close(cli_fd);			/* terminate client */
		/* no error message, just drop it. */
		return NORMAL;
	}

	power_status(ctl_fd, 0, &reply.batterystate);
	switch (cmd.action) {
	case SUSPEND:
		reply.newstate = SUSPENDING;
		break;
	case STANDBY:
		reply.newstate = STANDING_BY;
		break;
	case HIBERNATE:
		reply.newstate = HIBERNATING;
		break;
	case SETPERF_LOW:
		doperf = PERF_MANUAL;
		reply.newstate = NORMAL;
		syslog(LOG_NOTICE, "setting hw.perfpolicy to low");
		setperfpolicy("low");
		break;
	case SETPERF_HIGH:
		doperf = PERF_MANUAL;
		reply.newstate = NORMAL;
		syslog(LOG_NOTICE, "setting hw.perfpolicy to high");
		setperfpolicy("high");
		break;
	case SETPERF_AUTO:
	case SETPERF_COOL:
		doperf = PERF_AUTO;
		reply.newstate = NORMAL;
		syslog(LOG_NOTICE, "setting hw.perfpolicy to auto");
		setperfpolicy("auto");
		break;
	default:
		reply.newstate = NORMAL;
		break;
	}

	if (sysctl(cpuspeed_mib, 2, &cpuspeed, &cpuspeed_sz, NULL, 0) < 0)
		syslog(LOG_INFO, "cannot read hw.cpuspeed");

	reply.cpuspeed = cpuspeed;
	reply.perfmode = doperf;
	reply.vno = APMD_VNO;
	if (send(cli_fd, &reply, sizeof(reply), 0) != sizeof(reply))
		syslog(LOG_INFO, "reply to client botched");
	close(cli_fd);

	return reply.newstate;
}

void
suspend(int ctl_fd)
{
	syslog(LOG_NOTICE, "system suspending");
	do_etc_file(_PATH_APM_ETC_SUSPEND);
	sync();
	sleep(1);
	ioctl(ctl_fd, APM_IOC_SUSPEND, 0);
}

void
stand_by(int ctl_fd)
{
	syslog(LOG_NOTICE, "system entering standby");
	do_etc_file(_PATH_APM_ETC_STANDBY);
	sync();
	sleep(1);
	ioctl(ctl_fd, APM_IOC_STANDBY, 0);
}

void
hibernate(int ctl_fd)
{
	syslog(LOG_NOTICE, "system hibernating");
	do_etc_file(_PATH_APM_ETC_HIBERNATE);
	sync();
	sleep(1);
	ioctl(ctl_fd, APM_IOC_HIBERNATE, 0);
}

#define TIMO (10*60)			/* 10 minutes */

int
main(int argc, char *argv[])
{
	const char *fname = apmdev;
	int ctl_fd, sock_fd, ch, suspends, standbys, hibernates, resumes;
	int statonly = 0;
	int powerstatus = 0, powerbak = 0, powerchange = 0;
	int noacsleep = 0;
	struct timespec ts = {TIMO, 0}, sts = {0, 0};
	struct apm_power_info pinfo;
	time_t apmtimeout = 0;
	const char *sockname = sockfile;
	int kq, nchanges;
	struct kevent ev[2];
	int ncpu_mib[2] = { CTL_HW, HW_NCPU };
	int ncpu;
	size_t ncpu_sz = sizeof(ncpu);

	while ((ch = getopt(argc, argv, "aACdHLsf:t:S:")) != -1)
		switch(ch) {
		case 'a':
			noacsleep = 1;
			break;
		case 'd':
			debug = 1;
			break;
		case 'f':
			fname = optarg;
			break;
		case 'S':
			sockname = optarg;
			break;
		case 't':
			ts.tv_sec = strtoul(optarg, NULL, 0);
			if (ts.tv_sec == 0)
				usage();
			break;
		case 's':	/* status only */
			statonly = 1;
			break;
		case 'A':
		case 'C':
			if (doperf != PERF_NONE)
				usage();
			doperf = PERF_AUTO;
			setperfpolicy("auto");
			break;
		case 'L':
			if (doperf != PERF_NONE)
				usage();
			doperf = PERF_MANUAL;
			setperfpolicy("low");
			break;
		case 'H':
			if (doperf != PERF_NONE)
				usage();
			doperf = PERF_MANUAL;
			setperfpolicy("high");
			break;
		case '?':
		default:
			usage();
		}

	argc -= optind;
	argv += optind;

	if (argc != 0)
		usage();

	if (doperf == PERF_NONE)
		doperf = PERF_MANUAL;

	if (debug)
		openlog(__progname, LOG_CONS, LOG_LOCAL1);
	else {
		if (daemon(0, 0) < 0)
			error("failed to daemonize", NULL);
		openlog(__progname, LOG_CONS, LOG_DAEMON);
		setlogmask(LOG_UPTO(LOG_NOTICE));
	}

	(void) signal(SIGTERM, sigexit);
	(void) signal(SIGHUP, sigexit);
	(void) signal(SIGINT, sigexit);

	if ((ctl_fd = open(fname, O_RDWR | O_CLOEXEC)) == -1) {
		if (errno != ENXIO && errno != ENOENT)
			error("cannot open device file `%s'", fname);
	}

	sock_fd = bind_socket(sockname);

	power_status(ctl_fd, 1, &pinfo);

	if (statonly)
		exit(0);

	set_driver_messages(ctl_fd, APM_PRINT_OFF);

	kq = kqueue();
	if (kq <= 0)
		error("kqueue", NULL);

	EV_SET(&ev[0], sock_fd, EVFILT_READ, EV_ADD | EV_ENABLE | EV_CLEAR,
	    0, 0, NULL);
	if (ctl_fd == -1)
		nchanges = 1;
	else {
		EV_SET(&ev[1], ctl_fd, EVFILT_READ, EV_ADD | EV_ENABLE |
		    EV_CLEAR, 0, 0, NULL);
		nchanges = 2;
	}
	if (kevent(kq, ev, nchanges, NULL, 0, &sts) < 0)
		error("kevent", NULL);

	if (sysctl(ncpu_mib, 2, &ncpu, &ncpu_sz, NULL, 0) < 0)
		error("cannot read hw.ncpu", NULL);

	for (;;) {
		int rv;

		sts = ts;

		apmtimeout += 1;
		if ((rv = kevent(kq, NULL, 0, ev, 1, &sts)) < 0)
			break;

		if (apmtimeout >= ts.tv_sec) {
			apmtimeout = 0;

			/* wakeup for timeout: take status */
			powerbak = power_status(ctl_fd, 0, &pinfo);
			if (powerstatus != powerbak) {
				powerstatus = powerbak;
				powerchange = 1;
			}
		}

		if (!rv)
			continue;

		if (ev->ident == ctl_fd) {
			suspends = standbys = hibernates = resumes = 0;
			syslog(LOG_DEBUG, "apmevent %04x index %d",
			    (int)APM_EVENT_TYPE(ev->data),
			    (int)APM_EVENT_INDEX(ev->data));

			switch (APM_EVENT_TYPE(ev->data)) {
			case APM_SUSPEND_REQ:
			case APM_USER_SUSPEND_REQ:
			case APM_CRIT_SUSPEND_REQ:
			case APM_BATTERY_LOW:
				suspends++;
				break;
			case APM_USER_STANDBY_REQ:
			case APM_STANDBY_REQ:
				standbys++;
				break;
			case APM_USER_HIBERNATE_REQ:
				hibernates++;
				break;
#if 0
			case APM_CANCEL:
				suspends = standbys = 0;
				break;
#endif
			case APM_NORMAL_RESUME:
			case APM_CRIT_RESUME:
			case APM_SYS_STANDBY_RESUME:
				powerbak = power_status(ctl_fd, 0, &pinfo);
				if (powerstatus != powerbak) {
					powerstatus = powerbak;
					powerchange = 1;
				}
				resumes++;
				break;
			case APM_POWER_CHANGE:
				powerbak = power_status(ctl_fd, 0, &pinfo);
				if (powerstatus != powerbak) {
					powerstatus = powerbak;
					powerchange = 1;
				}
				break;
			default:
				;
			}

			if ((standbys || suspends) && noacsleep &&
			    power_status(ctl_fd, 0, &pinfo))
				syslog(LOG_DEBUG, "no! sleep! till brooklyn!");
			else if (suspends)
				suspend(ctl_fd);
			else if (standbys)
				stand_by(ctl_fd);
			else if (hibernates)
				hibernate(ctl_fd);
			else if (resumes) {
				do_etc_file(_PATH_APM_ETC_RESUME);
				syslog(LOG_NOTICE,
				    "system resumed from sleep");
			}

			if (powerchange) {
				if (powerstatus)
					do_etc_file(_PATH_APM_ETC_POWERUP);
				else
					do_etc_file(_PATH_APM_ETC_POWERDOWN);
				powerchange = 0;
			}

		} else if (ev->ident == sock_fd)
			switch (handle_client(sock_fd, ctl_fd)) {
			case NORMAL:
				break;
			case SUSPENDING:
				suspend(ctl_fd);
				break;
			case STANDING_BY:
				stand_by(ctl_fd);
				break;
			case HIBERNATING:
				hibernate(ctl_fd);
				break;
			}
	}
	error("kevent loop", NULL);

	return 1;
}

void
setperfpolicy(char *policy)
{
	int hw_perfpol_mib[] = { CTL_HW, HW_PERFPOLICY };
	char oldpolicy[32];
	size_t oldsz = sizeof(oldpolicy);
	int setlo = 0;

	if (strcmp(policy, "low") == 0) {
		policy = "manual";
		setlo = 1;
	}

	if (sysctl(hw_perfpol_mib, 2, oldpolicy, &oldsz, policy, strlen(policy) + 1) < 0)
		syslog(LOG_INFO, "cannot set hw.perfpolicy");

	if (setlo == 1) {
		int hw_perf_mib[] = {CTL_HW, HW_SETPERF};
		int perf;
		int new_perf = 0;
		size_t perf_sz = sizeof(perf);
		if (sysctl(hw_perf_mib, 2, &perf, &perf_sz, &new_perf, perf_sz) < 0)
			syslog(LOG_INFO, "cannot set hw.setperf");
	}
}

void
do_etc_file(const char *file)
{
	pid_t pid;
	int status;
	const char *prog;

	/* If file doesn't exist, do nothing. */
	if (access(file, X_OK|R_OK)) {
		syslog(LOG_DEBUG, "do_etc_file(): cannot access file %s", file);
		return;
	}

	prog = strrchr(file, '/');
	if (prog)
		prog++;
	else
		prog = file;

	pid = fork();
	switch (pid) {
	case -1:
		syslog(LOG_ERR, "failed to fork(): %m");
		return;
	case 0:
		/* We are the child. */
		execl(file, prog, (char *)NULL);
		syslog(LOG_ERR, "failed to exec %s: %m", file);
		_exit(1);
		/* NOTREACHED */
	default:
		/* We are the parent. */
		wait4(pid, &status, 0, 0);
		if (WIFEXITED(status))
			syslog(LOG_DEBUG, "%s exited with status %d", file,
			    WEXITSTATUS(status));
		else
			syslog(LOG_ERR, "%s exited abnormally.", file);
	}
}
@


1.78
log
@apmd doesn't connect to the socket, it binds on it; tweak error message
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.77 2015/10/11 20:23:49 guenther Exp $	*/
d280 1
a280 1
		syslog(LOG_NOTICE, "setting hw.perfpolicy to manual");
d308 1
a308 1
		syslog(LOG_INFO, "client reply botch");
@


1.77
log
@Userspace doesn't need to use SUN_LEN(): connect() and bind() must accept
sizeof(struct sockaddr_un), so do the simple, portable thing.
Also convert some strncpy() to strlcpy()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.76 2015/08/28 16:13:58 tedu Exp $	*/
d222 1
a222 1
		error("cannot connect to APM socket", NULL);
@


1.76
log
@log battery changes every 10%, not every 21.
ok deraadt jung phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.75 2015/02/06 08:16:50 dcoppa Exp $	*/
d215 1
a215 2
	strncpy(s_un.sun_path, sockname, sizeof(s_un.sun_path));
	s_un.sun_len = SUN_LEN(&s_un);
d221 1
a221 1
	if (bind(sock, (struct sockaddr *)&s_un, s_un.sun_len) == -1)
@


1.75
log
@
Handle hibernate button in the same way as suspend does: send an
APM_USER_HIBERNATE_REQ event so apmd(8) can get it if it's running.

ok mlarkin@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.74 2015/01/16 06:40:15 deraadt Exp $	*/
d156 1
a156 1
		    abs(bstate.battery_life - last.battery_life) > 20) {
@


1.74
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.73 2014/10/28 06:04:19 dcoppa Exp $	*/
d351 1
a351 1
	int ctl_fd, sock_fd, ch, suspends, standbys, resumes;
d490 1
a490 1
			suspends = standbys = resumes = 0;
d506 3
d542 2
@


1.73
log
@
Remove now useless defines

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.72 2014/10/26 22:16:16 guenther Exp $	*/
a31 1
#include <sys/param.h>
d50 1
d52 1
d194 1
a194 1
char socketname[MAXPATHLEN];
@


1.72
log
@Use socket(SOCK_CLOEXEC), open(O_CLOEXEC), and fcntl(F_DUPFD_CLOEXEC)
instead of calling fcntl(F_SETFD) later.

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.71 2014/10/17 07:41:40 jmc Exp $	*/
a63 5
#define PERFDEC 20
#define PERFMIN 0
#define PERFMAX 100
#define PERFINCTHRES 50
#define PERFDECTHRES 60
@


1.71
log
@remove -C from usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.70 2014/10/17 01:55:00 tedu Exp $	*/
d214 1
a214 1
	sock = socket(AF_UNIX, SOCK_STREAM, 0);
a442 3

	if (fcntl(sock_fd, F_SETFD, FD_CLOEXEC) == -1)
		error("cannot set close-on-exec for the socket", NULL);
@


1.70
log
@remove performance throttling code from here, use the kernel version
instead. this effectively kills -C, though the option is kept for compat.
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.69 2014/09/26 10:39:28 dcoppa Exp $	*/
d101 1
a101 1
	    "usage: %s [-AaCdHLs] [-f devname] [-S sockname] [-t seconds]\n",
@


1.69
log
@
zap now unused "PERFINC"
restore original behavior of apmtimeout

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.68 2014/09/26 08:55:59 tedu Exp $	*/
d82 1
a82 1
void setperf(int new_perf);
a197 153
/* multi- and uni-processor case */
int
get_avg_idle_mp(int ncpu)
{
	static int64_t **cp_time_old;
	static int64_t **cp_time;
	static int *avg_idle;
	int64_t change, sum, idle;
	int i, cpu, min_avg_idle;
	size_t cp_time_sz = CPUSTATES * sizeof(int64_t);

	if (!cp_time_old)
		if ((cp_time_old = calloc(sizeof(int64_t *), ncpu)) == NULL)
			return -1;

	if (!cp_time)
		if ((cp_time = calloc(sizeof(int64_t *), ncpu)) == NULL)
			return -1;

	if (!avg_idle)
		if ((avg_idle = calloc(sizeof(int), ncpu)) == NULL)
			return -1;

	min_avg_idle = 0;
	for (cpu = 0; cpu < ncpu; cpu++) {
		int cp_time_mib[] = {CTL_KERN, KERN_CPTIME2, cpu};

		if (!cp_time_old[cpu])
			if ((cp_time_old[cpu] =
			    calloc(sizeof(int64_t), CPUSTATES)) == NULL)
				return -1;

		if (!cp_time[cpu])
			if ((cp_time[cpu] =
			    calloc(sizeof(int64_t), CPUSTATES)) == NULL)
				return -1;

		if (sysctl(cp_time_mib, 3, cp_time[cpu], &cp_time_sz, NULL, 0)
		    < 0)
			syslog(LOG_INFO, "cannot read kern.cp_time2");

		sum = 0;
		for (i = 0; i < CPUSTATES; i++) {
			if ((change = cp_time[cpu][i] - cp_time_old[cpu][i])
			    < 0) {
				/* counter wrapped */
				change = ((uint64_t)cp_time[cpu][i] -
				    (uint64_t)cp_time_old[cpu][i]);
			}
			sum += change;
			if (i == CP_IDLE)
				idle = change;
		}
		if (sum == 0)
			sum = 1;

		/* smooth data */
		avg_idle[cpu] = (avg_idle[cpu] + (100 * idle) / sum) / 2;

		if (cpu == 0)
			min_avg_idle = avg_idle[cpu];

		if (avg_idle[cpu] < min_avg_idle)
			min_avg_idle = avg_idle[cpu];

		memcpy(cp_time_old[cpu], cp_time[cpu], cp_time_sz);
	}

	return min_avg_idle;
}

int
get_avg_idle_up(void)
{
	static long cp_time_old[CPUSTATES];
	static int avg_idle;
	long change, cp_time[CPUSTATES];
	int cp_time_mib[] = {CTL_KERN, KERN_CPTIME};
	size_t cp_time_sz = sizeof(cp_time);
	int i, idle, sum = 0;

	if (sysctl(cp_time_mib, 2, &cp_time, &cp_time_sz, NULL, 0) < 0)
		syslog(LOG_INFO, "cannot read kern.cp_time");

	for (i = 0; i < CPUSTATES; i++) {
		if ((change = cp_time[i] - cp_time_old[i]) < 0) {
			/* counter wrapped */
			change = ((unsigned long)cp_time[i] -
			    (unsigned long)cp_time_old[i]);
		}
		sum += change;
		if (i == CP_IDLE)
			idle = change;
	}
	if (sum == 0)
		sum = 1;

	/* smooth data */
	avg_idle = (avg_idle + (100 * idle) / sum) / 2;

	memcpy(cp_time_old, cp_time, sizeof(cp_time_old));

	return avg_idle;
}

void
perf_status(struct apm_power_info *pinfo, int ncpu)
{
	int avg_idle;
	int hw_perf_mib[] = {CTL_HW, HW_SETPERF};
	int perf;
	int forcehi = 0;
	size_t perf_sz = sizeof(perf);

	if (ncpu > 1) {
		avg_idle = get_avg_idle_mp(ncpu);
	} else {
		avg_idle = get_avg_idle_up();
	}

	if (avg_idle == -1)
		return;

	switch (doperf) {
	case PERF_AUTO:
		/*
		 * force setperf towards the max if we are connected to AC
		 * power and have a battery life greater than 15%, or if
		 * the battery is absent
		 */
		if ((pinfo->ac_state == APM_AC_ON && pinfo->battery_life > 15) ||
		    pinfo->battery_state == APM_BATTERY_ABSENT)
			forcehi = 1;		
		break;
	case PERF_COOL:
		forcehi = 0;
		break;
	}
	
	if (sysctl(hw_perf_mib, 2, &perf, &perf_sz, NULL, 0) < 0)
		syslog(LOG_INFO, "cannot read hw.setperf");

	if (forcehi || (avg_idle < PERFINCTHRES && perf < PERFMAX)) {
		perf = PERFMAX;
		setperf(perf);
	} else if (avg_idle > PERFDECTHRES && perf > PERFMIN) {
		perf -= PERFDEC;
		if (perf < PERFMIN)
			perf = PERFMIN;
		setperf(perf);
	}
}

d285 2
a286 2
		syslog(LOG_NOTICE, "setting hw.setperf to %d", PERFMIN);
		setperf(PERFMIN);
d291 2
a292 2
		syslog(LOG_NOTICE, "setting hw.setperf to %d", PERFMAX);
		setperf(PERFMAX);
d295 1
d298 2
a299 6
		syslog(LOG_NOTICE, "setting hw.setperf automatically");
		break;
	case SETPERF_COOL:
		doperf = PERF_COOL;
		reply.newstate = NORMAL;
		syslog(LOG_NOTICE, "setting hw.setperf for cool running");
d392 1
d396 1
a396 5
			break;
		case 'C':
			if (doperf != PERF_NONE)
				usage();
			doperf = PERF_COOL;
d402 1
a402 1
			setperf(PERFMIN);
d408 1
a408 1
			setperf(PERFMAX);
a472 4
	if (doperf == PERF_AUTO || doperf == PERF_COOL) {
		setperf(0);
		setperf(100);
	}
d478 1
a478 9
		if (doperf == PERF_AUTO || doperf == PERF_COOL) {
			sts.tv_sec = 0;
			sts.tv_nsec = 200000000;
			perf_status(&pinfo, ncpu);
			apmtimeout += 1;
		} else {
			apmtimeout += sts.tv_sec;
		}

d581 1
a581 1
setperf(int new_perf)
d583 21
a603 6
	int hw_perf_mib[] = {CTL_HW, HW_SETPERF};
	int perf;
	size_t perf_sz = sizeof(perf);

	if (sysctl(hw_perf_mib, 2, &perf, &perf_sz, &new_perf, perf_sz) < 0)
		syslog(LOG_INFO, "cannot set hw.setperf");
@


1.68
log
@now that mp setperf is fixed, let's try aggressive throttling again.
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.64 2014/07/22 22:09:36 tedu Exp $	*/
a63 1
#define PERFINC 50
d645 3
a649 1
		apmtimeout += 1;
@


1.67
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.66 2014/08/15 03:51:40 guenther Exp $	*/
d68 2
a69 2
#define PERFINCTHRES 10
#define PERFDECTHRES 30
d342 1
a342 3
		perf += PERFINC;
		if (perf > PERFMAX)
			perf = PERFMAX;
d643 2
a644 1
			sts.tv_sec = 1;
d648 1
a648 1
		apmtimeout += sts.tv_sec;
@


1.66
log
@Use O_CLOEXEC wherever we open a file and then call fcntl(F_SETFD, FD_CLOEXEC)
on it, simplifying error checking, reducing system calls, and improving
thread-safety for libraries.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.65 2014/07/26 10:48:59 mpi Exp $	*/
d40 1
a40 1
#include <sys/dkstat.h>
@


1.65
log
@Revert "adjust -C algorithm to be more aggressive in scaling up" for
the moment, it triggers a race that breaks suspend/resume on some
machines.

ok tedu@@, deraadt@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.64 2014/07/22 22:09:36 tedu Exp $	*/
d599 1
a599 1
	if ((ctl_fd = open(fname, O_RDWR)) == -1) {
d602 1
a602 2
	} else if (fcntl(ctl_fd, F_SETFD, FD_CLOEXEC) == -1)
		error("cannot set close-on-exec for `%s'", fname);
@


1.64
log
@adjust -C algorithm to be more aggressive in scaling up.
works better for me, and others as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.63 2013/11/13 04:50:21 deraadt Exp $	*/
d68 2
a69 2
#define PERFINCTHRES 50
#define PERFDECTHRES 60
d342 3
a344 1
		perf = PERFMAX;
d646 1
a646 2
			sts.tv_sec = 0;
			sts.tv_nsec = 200000000;
d650 1
a650 1
		apmtimeout += 1;
@


1.63
log
@protos, and please gcc warnings about operator precedence
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.62 2013/08/22 04:43:41 guenther Exp $	*/
d68 2
a69 2
#define PERFINCTHRES 10
#define PERFDECTHRES 30
d342 1
a342 3
		perf += PERFINC;
		if (perf > PERFMAX)
			perf = PERFMAX;
d644 2
a645 1
			sts.tv_sec = 1;
d649 1
a649 1
		apmtimeout += sts.tv_sec;
@


1.62
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.61 2013/05/19 18:37:40 tedu Exp $	*/
d87 2
d329 1
a329 1
		if (pinfo->ac_state == APM_AC_ON && pinfo->battery_life > 15 ||
@


1.61
log
@add some messages when entering suspend as well
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.60 2013/05/15 22:46:00 guenther Exp $	*/
d669 2
a670 2
			    APM_EVENT_TYPE(ev->data),
			    APM_EVENT_INDEX(ev->data));
@


1.60
log
@If execing an /etc/apm/* program fails, log the failure and error message.

ok tedu@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.59 2013/04/29 00:28:23 okan Exp $	*/
d479 1
d489 1
d499 1
d719 1
a719 1
				    "system resumed from APM sleep");
@


1.59
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.58 2012/03/26 20:17:45 deraadt Exp $	*/
d785 1
@


1.58
log
@Add hibernate request support.  Also installs a ZZZ binary for the
shortcut.
ok mlarkin miod
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.57 2011/04/21 06:45:04 jasper Exp $	*/
d597 1
a597 1
	} else if (fcntl(ctl_fd, F_SETFD, 1) == -1)
d602 1
a602 1
	if (fcntl(sock_fd, F_SETFD, 1) == -1)
@


1.57
log
@daemon() can fail; don't hide this for the user if that's the case.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.56 2010/04/02 04:12:46 deraadt Exp $	*/
d82 1
d433 3
d494 9
d736 3
@


1.56
log
@In automatic mode if the battery is absent go to 100%
From Pawlowski Marcin Piotr
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.55 2010/03/30 17:42:05 oga Exp $	*/
d571 2
a572 1
		daemon(0, 0);
@


1.55
log
@revert revision 1.53.

Now the kernel does a proper vt switch for us this hack is no longer
needed.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.52 2009/02/26 00:29:39 tedu Exp $	*/
d323 2
a324 1
		 * power and have a battery life greater than 15%
d326 2
a327 1
		if (pinfo->ac_state == APM_AC_ON && pinfo->battery_life > 15)
@


1.54
log
@-epm are not relevant to most (any?) setups and quiet is good anyway: remove
these options;

thanks marc for feedback on what these options were for;
ok oga deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.53 2009/02/26 17:21:56 oga Exp $	*/
a81 2
void suspend_req(int ctl_fd);
void stand_by_req(int ctl_fd);
a487 20
void
suspend_req(int ctl_fd)
{
	/* let the user get their finger off the enter key before we suspend */
	sleep(1);
	ioctl(ctl_fd, APM_IOC_SUSPEND_REQ, 0);
	/* give X a chance to do things */
	sleep(2);
}

void
stand_by_req(int ctl_fd)
{
	/* let the user get their finger off the enter key before we suspend */
	sleep(1);
	ioctl(ctl_fd, APM_IOC_STANDBY_REQ, 0);
	/* give X a chance to do things */
	sleep(2);
}

d716 1
a716 1
				suspend_req(ctl_fd);
d719 1
a719 1
				stand_by_req(ctl_fd);
@


1.53
log
@Change apmd to use the new _REQ ioctls for zzz, this gives X a chance to
vt-switch internally so it's likely to actually survive the suspend.

tested by beck@@, sthen@@. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.52 2009/02/26 00:29:39 tedu Exp $	*/
d101 1
a101 1
	    "usage: %s [-AaCdeHLmps] [-f devname] [-S sockname] [-t seconds]\n",
a517 2
	int enableonly = 0;
	int pctonly = 0;
a518 1
	int messages = 0;
d530 1
a530 1
	while ((ch = getopt(argc, argv, "aACdHLsepmf:t:S:")) != -1)
a551 6
		case 'e':
			enableonly = 1;
			break;
		case 'p':
			pctonly = 1;
			break;
a573 3
		case 'm':
			messages = 1;
			break;
d616 1
a616 12
	if (enableonly) {
		set_driver_messages(ctl_fd, APM_PRINT_ON);
		exit(0);
	}

	if (pctonly) {
		set_driver_messages(ctl_fd, APM_PRINT_PCT);
		exit(0);
	}

	if (!messages)
		set_driver_messages(ctl_fd, APM_PRINT_OFF);
@


1.52
log
@revert 1.50 and 1.51.  kettenis discovered they don't let his sparcle go slow enough
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.49 2007/11/24 14:58:44 deraadt Exp $	*/
d82 2
d490 20
d761 1
a761 1
				suspend(ctl_fd);
d764 1
a764 1
				stand_by(ctl_fd);
@


1.51
log
@gollo@@ thought the timeouts were a little short, and indeed, they are off by 1000.
(not much real effect, you can only sleep so short any way)
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.50 2009/02/03 01:52:49 tedu Exp $	*/
d64 2
a65 2
#define PERFINC 15
#define PERFDEC 15
a69 3
#define PERFTIMEOUTERR 999999999
#define PERFTIMEOUTFAST 10000000
#define PERFTIMEOUTSLOW 25000000
d77 3
a79 2
int  get_min_idle_mp(int ncpu);
useconds_t perf_status(struct apm_power_info *pinfo, int ncpu);
d198 1
a198 1
get_min_idle_mp(int ncpu)
d202 1
d204 1
a204 1
	int i, cpu, min_idle;
d215 5
a219 1
	min_idle = 100;
d233 2
a234 1
		if (sysctl(cp_time_mib, 3, cp_time[cpu], &cp_time_sz, NULL, 0))
a237 1
		idle = 100;
d239 2
a240 2
			change = cp_time[cpu][i] - cp_time_old[cpu][i];
			if (change < 0) {
d252 8
a259 2
		if ((100 * idle) / sum < min_idle)
			min_idle = (100 * idle) / sum;
d264 35
a298 1
	return min_idle;
d301 1
a301 1
useconds_t
d304 1
a304 1
	int avg_idle, min_idle;
d310 6
d317 1
a317 4
		return PERFTIMEOUTERR;

	if (sysctl(hw_perf_mib, 2, &perf, &perf_sz, NULL, 0) < 0)
		syslog(LOG_INFO, "cannot read hw.setperf");
d321 4
d326 2
a327 1
			forcehi = 1;
d329 17
a345 15
		min_idle = get_min_idle_mp(ncpu);
		if (forcehi || (min_idle < PERFINCTHRES && perf < PERFMAX)) {
			perf += PERFINC;
			if (perf > PERFMAX)
				perf = PERFMAX;
			setperf(perf);
			return PERFTIMEOUTFAST;
		} else if (min_idle > PERFDECTHRES && perf > PERFMIN) {
			perf -= PERFDEC;
			if (perf < PERFMIN)
				perf = PERFMIN;
			setperf(perf);
			return PERFTIMEOUTSLOW;
		} else
			return PERFTIMEOUTSLOW;
a346 1
	return PERFTIMEOUTSLOW;
d648 2
a649 2
			sts.tv_sec = 0;
			sts.tv_nsec = perf_status(&pinfo, ncpu);
@


1.50
log
@the prevalence of multi-core laptops revealed that taking the cpu average is
a poor way to adjust performance.  Even with a cpu pegged, apmd is quite slow
to react.  Change things to consider min idle time, not average.
Mostly from a diff by Laurence Tratt
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.49 2007/11/24 14:58:44 deraadt Exp $	*/
d71 2
a72 2
#define PERFTIMEOUTFAST 10000
#define PERFTIMEOUTSLOW 25000
@


1.49
log
@cope with incorrect extra arguments; from Rodolfo Gouveia
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.48 2007/07/18 13:34:23 mcbride Exp $	*/
d64 2
a65 2
#define PERFINC 50
#define PERFDEC 20
d70 3
d80 2
a81 3
int  get_avg_idle_mp(int ncpu);
int  get_avg_idle_up(void);
void perf_status(struct apm_power_info *pinfo, int ncpu);
d200 1
a200 1
get_avg_idle_mp(int ncpu)
a203 1
	static int *avg_idle;
d205 1
a205 1
	int i, cpu, min_avg_idle;
d216 1
a216 5
	if (!avg_idle)
		if ((avg_idle = calloc(sizeof(int), ncpu)) == NULL)
			return -1;

	min_avg_idle = 0;
d230 1
a230 2
		if (sysctl(cp_time_mib, 3, cp_time[cpu], &cp_time_sz, NULL, 0)
		    < 0)
d234 1
d236 2
a237 2
			if ((change = cp_time[cpu][i] - cp_time_old[cpu][i])
			    < 0) {
d249 2
a250 8
		/* smooth data */
		avg_idle[cpu] = (avg_idle[cpu] + (100 * idle) / sum) / 2;

		if (cpu == 0)
			min_avg_idle = avg_idle[cpu];

		if (avg_idle[cpu] < min_avg_idle)
			min_avg_idle = avg_idle[cpu];
d255 1
a255 35
	return min_avg_idle;
}

int
get_avg_idle_up(void)
{
	static long cp_time_old[CPUSTATES];
	static int avg_idle;
	long change, cp_time[CPUSTATES];
	int cp_time_mib[] = {CTL_KERN, KERN_CPTIME};
	size_t cp_time_sz = sizeof(cp_time);
	int i, idle, sum = 0;

	if (sysctl(cp_time_mib, 2, &cp_time, &cp_time_sz, NULL, 0) < 0)
		syslog(LOG_INFO, "cannot read kern.cp_time");

	for (i = 0; i < CPUSTATES; i++) {
		if ((change = cp_time[i] - cp_time_old[i]) < 0) {
			/* counter wrapped */
			change = ((unsigned long)cp_time[i] -
			    (unsigned long)cp_time_old[i]);
		}
		sum += change;
		if (i == CP_IDLE)
			idle = change;
	}
	if (sum == 0)
		sum = 1;

	/* smooth data */
	avg_idle = (avg_idle + (100 * idle) / sum) / 2;

	memcpy(cp_time_old, cp_time, sizeof(cp_time_old));

	return avg_idle;
d258 1
a258 1
void
d261 1
a261 1
	int avg_idle;
d267 2
a268 5
	if (ncpu > 1) {
		avg_idle = get_avg_idle_mp(ncpu);
	} else {
		avg_idle = get_avg_idle_up();
	}
d270 2
a271 2
	if (avg_idle == -1)
		return;
a274 4
		/*
		 * force setperf towards the max if we are connected to AC
		 * power and have a battery life greater than 15%
		 */
d276 1
a276 2
			forcehi = 1;		
		break;
d278 15
a292 17
		forcehi = 0;
		break;
	}
	
	if (sysctl(hw_perf_mib, 2, &perf, &perf_sz, NULL, 0) < 0)
		syslog(LOG_INFO, "cannot read hw.setperf");

	if (forcehi || (avg_idle < PERFINCTHRES && perf < PERFMAX)) {
		perf += PERFINC;
		if (perf > PERFMAX)
			perf = PERFMAX;
		setperf(perf);
	} else if (avg_idle > PERFDECTHRES && perf > PERFMIN) {
		perf -= PERFDEC;
		if (perf < PERFMIN)
			perf = PERFMIN;
		setperf(perf);
d294 1
d596 2
a597 2
			sts.tv_sec = 1;
			perf_status(&pinfo, ncpu);
@


1.48
log
@Fix uninitialised variable 'sum' in single-processor idle calculation.

ok ckuethe, sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.47 2007/06/03 22:14:07 tedu Exp $	*/
d571 3
@


1.47
log
@the kernel starts with setperf=100, even though the bios may have throttled.
this confuses apmd, so when using auto adjust modes, first cycle through
0 and 100 to make sure we're in a known state.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.46 2007/04/28 06:42:43 sturm Exp $	*/
d275 1
a275 1
	int i, idle, sum;
@


1.46
log
@support for cpu throttling on mp systems

based on a similar diff by Simon Effenberg

ok krw, gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.45 2007/03/29 22:17:34 deraadt Exp $	*/
d635 4
@


1.45
log
@sync sync sync is so 1970; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.44 2006/04/12 19:40:18 deraadt Exp $	*/
d77 3
a79 1
void perf_status(struct apm_power_info *pinfo);
d196 73
a268 2
void
perf_status(struct apm_power_info *pinfo)
a273 4
	int hw_perf_mib[] = {CTL_HW, HW_SETPERF};
	int i, idle, perf;
	int forcehi = 0;
	int sum = 0;
d275 1
a275 1
	size_t perf_sz = sizeof(perf);
d296 23
a346 2

	memcpy(cp_time_old, cp_time, sizeof(cp_time_old));
d507 3
d632 3
d642 1
a642 1
			perf_status(&pinfo);
@


1.44
log
@do not pass uninitialized variable cpuspeed up; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.43 2006/03/15 20:30:28 sturm Exp $	*/
a384 2
	sync();
	sync();
a392 2
	sync();
	sync();
@


1.43
log
@consistently use power *states* and performance *modes*

ok beck, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.42 2006/03/14 22:30:53 sturm Exp $	*/
d310 1
a310 1
	int cpuspeed;
@


1.42
log
@install these on amd64
even though amd64 does not have apm support, this change permits
hw.setperf manipulations via apm/apmd
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.41 2006/01/19 19:17:10 sturm Exp $	*/
d341 1
a341 1
		doperf = PERF_LOW;
d347 1
a347 1
		doperf = PERF_HIGH;
d371 1
a371 1
	reply.perfstate = doperf;
d463 1
a463 1
			doperf = PERF_LOW;
d469 1
a469 1
			doperf = PERF_HIGH;
d482 3
@


1.41
log
@prompted by deraadt:
manual performance mode -> low/high performance mode
show cpuspeed in apm output

ok beck, weingart
man page bits ok jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.40 2005/12/02 04:35:49 deraadt Exp $	*/
d496 1
a496 1
		if (errno != ENXIO)
@


1.40
log
@sync usage to man page
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.39 2005/12/02 04:27:52 beck Exp $	*/
d309 3
d341 1
a341 1
		doperf = PERF_MANUAL;
d347 1
a347 1
		doperf = PERF_MANUAL;
d367 4
d463 1
a463 1
			doperf = PERF_MANUAL;
d469 1
a469 1
			doperf = PERF_MANUAL;
@


1.39
log
@Modify automatic performance adjustment mode so that the cpu is set
to go fast if the power is connected and the battery is more than 15%
charged, and when on batteries keeps setperf low unless needed.
add a cool runnings mode option (-C) that does the previous behaviour
of keeping the CPU as low as possible unless needed.
ok deradt@@, sturm@@, "i like it's" djm@@ henning@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.38 2005/11/23 08:21:09 deraadt Exp $	*/
d97 2
a98 2
	    "usage: %s [-ademps] [-f devname] [-S sockname] [-t seconds]"
	    " [-C | -A | -L | -H]\n", __progname);
@


1.38
log
@do not abort if hw.setperf is not there.  warn.  maybe we should even
skip that, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.36 2005/11/22 09:31:02 mickey Exp $	*/
d77 1
a77 1
void perf_status(void);
d98 1
a98 1
	    " [-A | -L | -H]\n", __progname);
d195 1
a195 1
perf_status(void)
d203 1
d227 14
d244 1
a244 1
	if (avg_idle < PERFINCTHRES && perf < PERFMAX) {
d354 5
d409 1
d415 1
a415 1
	while ((ch = getopt(argc, argv, "aAdHLsepmf:t:S:")) != -1)
d448 5
d499 1
a499 1
	power_status(ctl_fd, 1, 0);
d538 1
a538 1
		if (doperf == PERF_AUTO) {
d540 1
a540 1
			perf_status();
d551 1
a551 1
			powerbak = power_status(ctl_fd, 0, 0);
d586 1
a586 1
				powerbak = power_status(ctl_fd, 0, 0);
d594 1
a594 1
				powerbak = power_status(ctl_fd, 0, 0);
d605 1
a605 1
			    power_status(ctl_fd, 0, 0))
@


1.37
log
@permit apmd to run on systems without apm support
let apmd control hw.setperf manually or dynamically

tested by Chris Kuethe and beck@@, 'get it in' deraadt@@
@
text
@d208 1
a208 1
		error("cannot read kern.cp_time", NULL);
d227 1
a227 1
		error("cannot read hw.setperf", NULL);
d624 1
a624 1
		error("cannot set hw.setperf", NULL);
@


1.36
log
@accidentaly lost a zero in timeout long time ago (;
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.35 2005/11/15 01:21:41 jmc Exp $	*/
d40 2
d63 8
d77 1
d80 1
d97 2
a98 2
	    "usage: %s [-ademps] [-f devname] [-S sockname] [-t seconds]\n",
	    __progname);
d135 12
d194 50
d322 17
d344 1
d389 1
d391 1
a391 1
	int kq;
d394 1
a394 1
	while ((ch = getopt(argc, argv, "adsepmf:t:S:")) != -1)
d422 17
d462 4
a465 4
	if ((ctl_fd = open(fname, O_RDWR)) == -1)
		error("cannot open device file `%s'", fname);

	if (fcntl(ctl_fd, F_SETFD, 1) == -1)
d495 1
a495 1
	EV_SET(&ev[0], ctl_fd, EVFILT_READ, EV_ADD | EV_ENABLE | EV_CLEAR,
d497 8
a504 3
	EV_SET(&ev[1], sock_fd, EVFILT_READ, EV_ADD | EV_ENABLE | EV_CLEAR,
	    0, 0, NULL);
	if (kevent(kq, ev, 2, NULL, 0, &sts) < 0)
d512 6
d521 9
a529 5
		/* wakeup for timeout: take status */
		powerbak = power_status(ctl_fd, 0, 0);
		if (powerstatus != powerbak) {
			powerstatus = powerbak;
			powerchange = 1;
d614 11
@


1.35
log
@sync usage() w/ man page;
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.34 2005/06/14 15:18:53 deraadt Exp $	*/
d283 1
a283 1
#define TIMO (1*60)			/* 10 minutes */
@


1.34
log
@remove speaker handling code.  if you really want this, use the /etc/apm/*
scripts to do it. as it is, for most people this is terribly annoying and
unneccessary; toby ok
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.33 2005/05/09 04:53:51 miod Exp $	*/
d85 1
a85 1
	    "usage: %s [-adempqs] [-f devfile] [-S sockfile] [-t timo]\n",
@


1.33
log
@Do not log useless messages if the apm implementation returns -1 in the
minutes_left field of the apm_power_info struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.32 2005/03/10 22:42:46 deraadt Exp $	*/
a69 1
void make_noise(int howmany);
a260 43
int speaker_ok = TRUE;

void
make_noise(int howmany)
{
	int spkrfd = -1;
	int trycnt;

	if (!speaker_ok)		/* don't bother after sticky errors */
		return;

	for (trycnt = 0; trycnt < 3; trycnt++) {
		spkrfd = open(_PATH_DEV_SPEAKER, O_WRONLY);
		if (spkrfd == -1) {
			switch (errno) {
			case EBUSY:
				usleep(500000);
				errno = EBUSY;
				continue;
			case ENOENT:
			case ENODEV:
			case ENXIO:
			case EPERM:
			case EACCES:
				syslog(LOG_WARNING, "speaker device "
				    _PATH_DEV_SPEAKER " unavailable: %m");
				speaker_ok = FALSE;
				return;
			}
		} else
			break;
	}

	if (spkrfd == -1) {
		syslog(LOG_WARNING, "cannot open " _PATH_DEV_SPEAKER ": %m");
		return;
	}

	syslog(LOG_DEBUG, "sending %d tones to speaker", howmany);
	write(spkrfd, "o4cc", 2 + howmany);
	close(spkrfd);
}

a265 1
	make_noise(2);
a276 1
	make_noise(1);
d301 1
a301 1
	while ((ch = getopt(argc, argv, "qadsepmf:t:S:")) != -1)
a302 3
		case 'q':
			speaker_ok = FALSE;
			break;
@


1.32
log
@only play with umask() for a moment -- restore after
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.31 2004/09/14 22:27:46 deraadt Exp $	*/
d145 1
a145 1
			if (bstate.minutes_left)
@


1.31
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.30 2004/05/21 19:00:05 deraadt Exp $	*/
d184 1
a196 1
	umask(077);
d198 1
d201 1
@


1.30
log
@init fromlen; andrushock@@korovino.net
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.29 2003/09/26 17:03:22 deraadt Exp $	*/
d74 1
@


1.29
log
@avoid strdup.  and, while at it, fix a file leak at sigexit time spotted
by ish
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.28 2003/06/11 23:33:25 deraadt Exp $	*/
d219 1
@


1.28
log
@some ansification, some de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.27 2002/09/06 19:46:52 deraadt Exp $	*/
d32 1
a32 1
#include <sys/types.h>
a52 1
#define MAX(a,b) (a > b ? a : b)
d72 1
d77 1
d170 1
a170 1
char *socketname;
d175 1
a175 1
	if (socketname)
d203 1
a203 1
	socketname = strdup(sockname);
@


1.27
log
@use more socklen_t; pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.26 2002/07/04 07:31:16 deraadt Exp $	*/
d260 1
a260 2
make_noise(howmany)
int howmany;
@


1.26
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.25 2002/06/14 04:21:41 deraadt Exp $	*/
d214 1
a214 1
	int fromlen;
@


1.25
log
@this group operator stuff is completely wrong
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.23 2002/02/22 00:32:16 mickey Exp $	*/
d64 3
a66 3
void usage (void);
int power_status (int fd, int force, struct apm_power_info *pinfo);
int bind_socket (const char *sn);
d131 1
a131 1
		     abs(bstate.battery_life - last.battery_life) > 20) {
d194 1
a194 1
	umask (077);
d238 9
a246 3
	case SUSPEND:	reply.newstate = SUSPENDING;	break;
	case STANDBY:	reply.newstate = STANDING_BY;	break;
	default:	reply.newstate = NORMAL;	break;
d495 1
@


1.24
log
@Since now /var/run/apmdev socket will be root:operator.
Idea from form@@.

millert@@ ok
@
text
@a48 1
#include <grp.h>
a181 1
	struct group *gr;
a183 4
	gr = getgrnam("operator");
	if (!gr)
		syslog(LOG_ERR, "no operator");

d198 2
a199 3
	if (chmod(sockname, 0660) == -1 || chown(sockname, 0,
		    gr ? gr->gr_gid : 0) == -1)
		error("cannot set socket chmod/chown", NULL);
@


1.23
log
@mark opened device and socket as close on exec; idea from freebsd pr/35182
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.22 2001/12/12 17:03:39 mickey Exp $	*/
d49 1
d183 1
d186 4
d204 3
a206 2
	if (chmod(sockname, 0660) == -1 || chown(sockname, 0, 0) == -1)
		error("cannot set socket mode/owner/group to 660/0/0", NULL);
@


1.22
log
@daemon() can close innocent file descriptors, including opened log.
be more carefull about that and nicer to debugging.
daemon() thingie was pointed out by markus@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.21 2001/12/09 20:48:17 mickey Exp $	*/
d394 3
d398 3
@


1.21
log
@i like it this way better
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.21 2001/12/09 20:28:59 mickey Exp $	*/
d89 15
d186 1
a186 1
		err(1, "cannot create local socket");
d197 1
a197 1
		err(1, "cannot connect to APM socket");
d199 1
a199 1
		err(1, "cannot set socket mode/owner/group to 660/0/0");
a378 5
	if ((ctl_fd = open(fname, O_RDWR)) == -1)
		err(1, "cannot open device file `%s'", fname);

	sock_fd = bind_socket(sockname);

d382 1
a384 1
		daemon(0, 0);
d391 5
d415 2
a416 4
	if (kq <= 0) {
		syslog(LOG_ERR, "kqueue: %m");
		exit(1);
	}
d422 2
a423 4
	if (kevent(kq, ev, 2, NULL, 0, &sts) < 0) {
		syslog(LOG_ERR, "kevent: %m");
		exit(1);
	}
d518 1
a518 1
	syslog(LOG_ERR, "kevent: %m");
@


1.20
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.19 2001/11/14 22:18:33 miod Exp $	*/
d48 1
d170 2
a171 4
	if (sock == -1) {
		syslog(LOG_ERR, "cannot create local socket: %m");
		exit(1);
	}
d181 4
a184 9
	if (bind(sock, (struct sockaddr *)&s_un, s_un.sun_len) == -1) {
		syslog(LOG_ERR, "cannot connect to APM socket: %m");
		exit(1);
	}
	if (chmod(sockname, 0660) == -1 || chown(sockname, 0, 0) == -1) {
		syslog(LOG_ERR,
		    "cannot set socket mode/owner/group to 660/0/0: %m");
		exit(1);
	}
d364 4
a367 4
	if ((ctl_fd = open(fname, O_RDWR)) == -1) {
		syslog(LOG_ERR, "cannot open device file `%s': %m", fname);
		exit(1);
	}
d377 4
a398 5
	(void) signal(SIGTERM, sigexit);
	(void) signal(SIGHUP, sigexit);
	(void) signal(SIGINT, sigexit);

	sock_fd = bind_socket(sockname);
d507 1
a507 1
	syslog(LOG_ERR, "kevent failed: %m");
@


1.19
log
@On macppc, when the battery is charging, the life time estimatation is in fact
the recharge time estimation.
So there is no need to annoy the user if this value is <= 10 minute, since
no surprise powerdown is about to happen.

ok drahn@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.18 2001/11/14 20:11:22 deraadt Exp $	*/
a47 1
#include <err.h>
d169 4
a172 2
	if (sock == -1)
		err(1, "cannot create local socket");
d182 9
a190 4
	if (bind(sock, (struct sockaddr *)&s_un, s_un.sun_len) == -1)
		err(1, "cannot connect to APM socket");
	if (chmod(sockname, 0660) == -1 || chown(sockname, 0, 0) == -1)
		err(1, "cannot set socket mode/owner/group to 660/0/0");
d370 4
a373 2
	if ((ctl_fd = open(fname, O_RDWR)) == -1)
		err(1, "cannot open device file `%s'", fname);
d407 4
a410 2
	if (kq <= 0)
		err(1, "kqueue");
d416 4
a419 2
	if (kevent(kq, ev, 2, NULL, 0, &sts) < 0)
		err(1, "kevent");
@


1.18
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.17 2001/08/17 22:35:01 mickey Exp $	*/
d117 11
d129 1
@


1.17
log
@changes for new kqueue iface, make sure to make includes first
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.16 2001/07/09 07:05:00 deraadt Exp $	*/
d77 1
a77 1
    _exit(1);
@


1.16
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.15 2001/07/07 01:10:42 mickey Exp $	*/
d32 8
a46 6
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/wait.h>
d292 1
a292 1
#define TIMO (10*60)			/* 10 minutes */
d298 1
a298 1
	int ctl_fd, sock_fd, ch, ready, fdsn, suspends, standbys, resumes;
d305 1
a305 3
	fd_set *devfdsp, *selfdsp;
	struct apm_event_info apmevent;
	struct timeval tv = {TIMO, 0}, stv;
d307 2
d328 2
a329 2
			tv.tv_sec = strtoul(optarg, NULL, 0);
			if (tv.tv_sec == 0)
d386 10
a395 10
	fdsn = howmany(MAX(ctl_fd, sock_fd)+1, NFDBITS) * sizeof(fd_mask);
	if ((devfdsp = (fd_set *)malloc(fdsn)) == NULL)
		err(1, "malloc");

	if ((selfdsp = (fd_set *)malloc(fdsn)) == NULL)
		err(1, "malloc");

	memset(devfdsp, 0, fdsn);
	FD_SET(ctl_fd, devfdsp);
	FD_SET(sock_fd, devfdsp);
d398 1
a398 2
		stv = tv;
		memmove(selfdsp, devfdsp, fdsn);
d400 4
a403 3
		ready = select(MAX(ctl_fd,sock_fd)+1, selfdsp, 0, 0, &stv);
		if (ready == -1 && errno != EINTR)
			continue;
d405 5
a409 7
		if (ready == 0) {
			/* wakeup for timeout: take status */
			powerbak = power_status(ctl_fd, 0, 0);
			if (powerstatus != powerbak) {
				powerstatus = powerbak;
				powerchange = 1;
			}
d412 4
a415 1
		if (FD_ISSET(ctl_fd, selfdsp)) {
d417 15
a431 16
			while (!ioctl(ctl_fd, APM_IOC_NEXTEVENT, &apmevent)) {

				syslog(LOG_DEBUG, "apmevent %04x index %d",
				    apmevent.type, apmevent.index);

				switch (apmevent.type) {
				case APM_SUSPEND_REQ:
				case APM_USER_SUSPEND_REQ:
				case APM_CRIT_SUSPEND_REQ:
				case APM_BATTERY_LOW:
					suspends++;
					break;
				case APM_USER_STANDBY_REQ:
				case APM_STANDBY_REQ:
					standbys++;
					break;
d433 3
a435 3
				case APM_CANCEL:
					suspends = standbys = 0;
					break;
d437 15
a451 18
				case APM_NORMAL_RESUME:
				case APM_CRIT_RESUME:
				case APM_SYS_STANDBY_RESUME:
					powerbak = power_status(ctl_fd, 0, 0);
					if (powerstatus != powerbak) {
						powerstatus = powerbak;
						powerchange = 1;
					}
					resumes++;
					break;
				case APM_POWER_CHANGE:
					powerbak = power_status(ctl_fd, 0, 0);
					if (powerstatus != powerbak) {
						powerstatus = powerbak;
						powerchange = 1;
					}
					break;
				default:
d453 2
d459 1
a459 1
				syslog(LOG_DEBUG, "no sleep till brooklyn");
a476 5
			ready--;
		}

		if (ready == 0)
			continue;
d478 1
a478 1
		if (FD_ISSET(sock_fd, selfdsp))
d490 1
a490 1
	syslog(LOG_ERR, "select failed: %m");
@


1.15
log
@cleanup and knf, some are from Kevin Steves <stevesk@@pobox.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: apmd.c,v 1.14 2001/03/23 01:00:41 mickey Exp $	*/
d525 1
a525 1
		execl(file, prog, NULL);
@


1.14
log
@ac on/off hooks; from angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
a6 1
 * 
d17 1
a17 1
 * 
d29 1
a29 1
 * 
a32 1
#include <errno.h>
a41 1
#include <sys/time.h>
d45 2
a47 1
#include <err.h>
d58 1
a58 1
static int debug = 0;
a60 5
extern char *optarg;
extern int optind;
extern int optopt;
extern int opterr;
extern int optreset;
a67 3
void resume(int ctl_fd);
void powerup(int ctl_fd);
void powerdown(int ctl_fd);
d81 2
a82 2
    fprintf(stderr,
	    "usage: %s [-dsaqepm] [-t timo] [-a] [-f devfile] [-S sockfile]\n",
d84 1
a84 1
    exit(1);
d91 1
a91 1
static void
d94 2
a95 2
    if ( ioctl(fd, APM_IOC_PRN_CTL, &mode) == -1 )
	    syslog( LOG_DEBUG, "can't disable driver messages, error: %m" );
d101 3
a103 3
    struct apm_power_info bstate;
    static struct apm_power_info last;
    int acon = 0;
d105 1
a105 1
    if (ioctl(fd, APM_IOC_GETPOWER, &bstate) == 0) {
d107 31
a137 28
	   enough since last report, or asked to force a print */
	if (bstate.ac_state == APM_AC_ON)
	    acon = 1;
	if (force || 
	    bstate.ac_state != last.ac_state ||
	    bstate.battery_state != last.battery_state ||
	    (bstate.minutes_left && bstate.minutes_left < 15) ||
	    abs(bstate.battery_life - last.battery_life) > 20) {
	    if (bstate.minutes_left)
		syslog(LOG_NOTICE,
		       "battery status: %s. external power status: %s. "
		       "estimated battery life %d%% (%d minutes)",
		       battstate(bstate.battery_state),
		       ac_state(bstate.ac_state), bstate.battery_life,
		       bstate.minutes_left );
	    else
		syslog(LOG_NOTICE,
		       "battery status: %s. external power status: %s. "
		       "estimated battery life %d%%",
		       battstate(bstate.battery_state),
		       ac_state(bstate.ac_state), bstate.battery_life);
	    last = bstate;
	}
	if (pinfo)
	    *pinfo = bstate;
    } else
	syslog(LOG_ERR, "cannot fetch power status: %m");
    return acon;
d140 1
a140 1
static char *socketname;
d142 1
a142 3
static void sockunlink(void);

static void
d145 2
a146 2
    if (socketname)
	(void) remove(socketname);
d152 23
a174 2
    int sock;
    struct sockaddr_un s_un;
d176 1
a176 18
    sock = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sock == -1)
	err(1, "cannot create local socket");

    s_un.sun_family = AF_UNIX;
    strncpy(s_un.sun_path, sockname, sizeof(s_un.sun_path));
    s_un.sun_len = SUN_LEN(&s_un);
    /* remove it if present, we're moving in */
    (void) remove(sockname);
    umask (077);
    if (bind(sock, (struct sockaddr *)&s_un, s_un.sun_len) == -1)
	err(1, "cannot connect to APM socket");
    if (chmod(sockname, 0660) == -1 || chown(sockname, 0, 0) == -1)
	err(1, "cannot set socket mode/owner/group to 660/0/0");
    listen(sock, 1);
    socketname = strdup(sockname);
    atexit(sockunlink);
    return sock;
d182 38
a219 40
    /* accept a handle from the client, process it, then clean up */
    int cli_fd;
    struct sockaddr_un from;
    int fromlen;
    struct apm_command cmd;
    struct apm_reply reply;

    cli_fd = accept(sock_fd, (struct sockaddr *)&from, &fromlen);
    if (cli_fd == -1) {
	syslog(LOG_INFO, "client accept failure: %m");
	return NORMAL;
    }
    if (recv(cli_fd, &cmd, sizeof(cmd), 0) != sizeof(cmd)) {
	(void) close(cli_fd);
	syslog(LOG_INFO, "client size botch");
	return NORMAL;
    }
    if (cmd.vno != APMD_VNO) {
	close(cli_fd);			/* terminate client */
	/* no error message, just drop it. */
	return NORMAL;
    }
    power_status(ctl_fd, 0, &reply.batterystate);
    switch (cmd.action) {
    default:
	reply.newstate = NORMAL;
	break;
    case SUSPEND:
	reply.newstate = SUSPENDING;
	break;
    case STANDBY:
	reply.newstate = STANDING_BY;
	break;
    }	
    reply.vno = APMD_VNO;
    if (send(cli_fd, &reply, sizeof(reply), 0) != sizeof(reply)) {
	syslog(LOG_INFO, "client reply botch");
    }
    close(cli_fd);
    return reply.newstate;
d222 1
a222 1
static int speaker_ok = TRUE;
d228 5
a232 2
    int spkrfd = -1;
    int trycnt;
d234 21
a254 2
    if (!speaker_ok)		/* don't bother after sticky errors */
	return;
a255 2
    for (trycnt = 0; trycnt < 3; trycnt++) {
	spkrfd = open(_PATH_DEV_SPEAKER, O_WRONLY);
d257 1
a257 13
	    switch (errno) {
	    case EBUSY:
		usleep(500000);
		errno = EBUSY;
		continue;
	    case ENOENT:
	    case ENODEV:
	    case ENXIO:
	    case EPERM:
	    case EACCES:
		syslog(LOG_INFO,
		       "speaker device " _PATH_DEV_SPEAKER " unavailable: %m");
		speaker_ok = FALSE;
d259 1
a259 19
	    }
	} else
	    break;
    }
    if (spkrfd == -1) {
	syslog(LOG_WARNING, "cannot open " _PATH_DEV_SPEAKER ": %m");
	return;
    }
    syslog(LOG_DEBUG, "sending %d tones to speaker", howmany);
    write(spkrfd, "o4cc", 2 + howmany);
    close(spkrfd);
    return;
}

void
powerup(int ctl_fd)
{
    do_etc_file(_PATH_APM_ETC_POWERUP);
}
d261 3
a263 4
void
powerdown(int ctl_fd)
{
    do_etc_file(_PATH_APM_ETC_POWERDOWN);
d269 7
a275 7
    do_etc_file(_PATH_APM_ETC_SUSPEND);
    sync();
    make_noise(2);
    sync();
    sync();
    sleep(1);
    ioctl(ctl_fd, APM_IOC_SUSPEND, 0);
d281 7
a287 7
    do_etc_file(_PATH_APM_ETC_STANDBY);
    sync();
    make_noise(1);
    sync();
    sync();
    sleep(1);
    ioctl(ctl_fd, APM_IOC_STANDBY, 0);
a291 6
void
resume(int ctl_fd)
{
    do_etc_file(_PATH_APM_ETC_RESUME);
}

d295 70
a364 50
    const char *fname = apmdev;
    int ctl_fd, sock_fd, ch, ready;
    int statonly = 0;
    int enableonly = 0;
    int pctonly = 0;
    int powerstatus = 0, powerbak = 0, powerchange = 0;
    int messages = 0;
    fd_set *devfdsp, *selfdsp;
    struct apm_event_info apmevent;
    int suspends, standbys, resumes;
    int noacsleep = 0;
    struct timeval tv = {TIMO, 0}, stv;
    const char *sockname = sockfile;
    int fdsn;

    while ((ch = getopt(argc, argv, "qadsepmf:t:S:")) != -1)
	switch(ch) {
	case 'q':
	    speaker_ok = FALSE;
	    break;
	case 'a':
	    noacsleep = 1;
	    break;
	case 'd':
	    debug = 1;
	    break;
	case 'f':
	    fname = optarg;
	    break;
	case 'S':
	    sockname = optarg;
	    break;
	case 't':
	    tv.tv_sec = strtoul(optarg, 0, 0);
	    if (tv.tv_sec == 0)
		usage();
	    break;
	case 's':			/* status only */
	    statonly = 1;
	    break;
	case 'e':
	    enableonly = 1;
	    break;
	case 'p':
	    pctonly = 1;
	    break;
	case 'm':
	    messages = 1;
	    break;
	case '?':
d366 8
a373 2
	default:
	    usage();
d375 55
a429 73
    argc -= optind;
    argv += optind;
    if ((ctl_fd = open(fname, O_RDWR)) == -1) {
	(void)err(1, "cannot open device file `%s'", fname);
    } 
    if (debug) {
	openlog(__progname, LOG_CONS, LOG_LOCAL1);
    } else {
	openlog(__progname, LOG_CONS, LOG_DAEMON);
	setlogmask(LOG_UPTO(LOG_NOTICE));
	daemon(0, 0);
    }
    power_status(ctl_fd, 1, 0);
    if (statonly)
	exit(0);
    if (enableonly) {
	set_driver_messages(ctl_fd, APM_PRINT_ON);
	exit(0);
    }
    if (pctonly) {
	set_driver_messages(ctl_fd, APM_PRINT_PCT);
	exit(0);
    }
    if ( ! messages ) {
	set_driver_messages(ctl_fd, APM_PRINT_OFF);
    }
    (void) signal(SIGTERM, sigexit);
    (void) signal(SIGHUP, sigexit);
    (void) signal(SIGINT, sigexit);

    sock_fd = bind_socket(sockname);

    fdsn = howmany(MAX(ctl_fd, sock_fd)+1, NFDBITS) * sizeof(fd_mask);
    if ((devfdsp = (fd_set *)malloc(fdsn)) == NULL)
	err(1, "malloc");
    if ((selfdsp = (fd_set *)malloc(fdsn)) == NULL)
	err(1, "malloc");
    memset(devfdsp, 0, fdsn);
    FD_SET(ctl_fd, devfdsp);
    FD_SET(sock_fd, devfdsp);
    
    for (;;) {
	stv = tv;
	memmove(selfdsp, devfdsp, fdsn);

	ready = select(MAX(ctl_fd,sock_fd)+1, selfdsp, 0, 0, &stv);
	if (ready == -1 && errno != EINTR)
	    continue;

	if (ready == 0) {
	    /* wakeup for timeout: take status */
	    powerbak = power_status(ctl_fd, 0, 0);
	    if (powerstatus != powerbak) {
		powerstatus = powerbak;
		powerchange = 1;
	    }
	}
	if (FD_ISSET(ctl_fd, selfdsp)) {
	    suspends = standbys = resumes = 0;
	    while (ioctl(ctl_fd, APM_IOC_NEXTEVENT, &apmevent) == 0) {
		syslog(LOG_DEBUG, "apmevent %04x index %d", apmevent.type,
		       apmevent.index);
		switch (apmevent.type) {
		case APM_SUSPEND_REQ:
		case APM_USER_SUSPEND_REQ:
		case APM_CRIT_SUSPEND_REQ:
		case APM_BATTERY_LOW:
		    suspends++;
		    break;
		case APM_USER_STANDBY_REQ:
		case APM_STANDBY_REQ:
		    standbys++;
		    break;
d431 3
a433 3
		case APM_CANCEL:
		    suspends = standbys = 0;
		    break;
d435 42
a476 19
		case APM_NORMAL_RESUME:
		case APM_CRIT_RESUME:
		case APM_SYS_STANDBY_RESUME:
		    powerbak = power_status(ctl_fd, 0, 0);
		    if (powerstatus != powerbak) {
			powerstatus = powerbak;
			powerchange = 1;
		    }
		    resumes++;
		    break;
		case APM_POWER_CHANGE:
		    powerbak = power_status(ctl_fd, 0, 0);
		    if (powerstatus != powerbak) {
			powerstatus = powerbak;
			powerchange = 1;
		    }
		    break;
		default:
		    break;
d478 19
a496 38
	    }
	    if ((standbys || suspends) && noacsleep &&
		power_status(ctl_fd, 0, 0)) {
		syslog(LOG_DEBUG, "not sleeping cuz AC is connected");
	    } else if (suspends) {
		suspend(ctl_fd);
	    } else if (standbys) {
		stand_by(ctl_fd);
	    } else if (resumes) {
		resume(ctl_fd);
		syslog(LOG_NOTICE, "system resumed from APM sleep");
	    }
	    if (powerchange) {
		if (powerstatus)
		    powerup(ctl_fd);
		else
		    powerdown(ctl_fd);
		powerchange = 0;
	    }
	    ready--;
	}
	if (ready == 0)
	    continue;
	if (FD_ISSET(sock_fd, selfdsp)) {
	    switch (handle_client(sock_fd, ctl_fd)) {
	    case NORMAL:
		break;
	    case SUSPENDING:
		suspend(ctl_fd);
		break;
	    case STANDING_BY:
		stand_by(ctl_fd);
		break;
	    }
	}
    }
    syslog(LOG_ERR, "select failed: %m");
    return 1;
d502 34
a535 34
    pid_t pid;
    int status;
    const char *prog;

    /* If file doesn't exist, do nothing. */
    if (access(file, X_OK|R_OK)) {
	syslog(LOG_DEBUG, "do_etc_file(): cannot access file %s", file);
	return;
    }

    prog = strrchr(file, '/');
    if (prog)
	prog++;
    else
	prog = file;

    pid = fork();
    switch (pid) {
    case -1:
	syslog(LOG_ERR, "failed to fork(): %m");
	return;
    case 0:
	/* We are the child. */
	execl(file, prog, NULL);
	_exit(1);
	/* NOTREACHED */
    default:
	/* We are the parent. */
	wait4(pid, &status, 0, 0);
	if (WIFEXITED(status))
	    syslog(LOG_DEBUG, "%s exited with status %d", file,
		   WEXITSTATUS(status));
	else {
	    syslog(LOG_ERR, "%s exited abnormally.", file);
a536 2
	break;
    }
@


1.13
log
@backing out undiscussed changes outside your area
@
text
@d1 2
d75 2
d271 11
d323 1
d423 5
a427 1
	    power_status(ctl_fd, 0, 0);
d453 5
d461 5
a465 1
		    power_status(ctl_fd, 0, 0);
d481 7
@


1.12
log
@Power status change after resume only if it really changed.
@
text
@a72 2
void powerup(int ctl_fd);
void powerdown(int ctl_fd);
a266 11
void
powerup(int ctl_fd)
{
    do_etc_file(_PATH_APM_ETC_POWERUP);
}

void
powerdown(int ctl_fd)
{
    do_etc_file(_PATH_APM_ETC_POWERDOWN);
}
a307 1
    int powerstatus = 0, powerbak = 0, powerchange = 0;
d407 1
a407 5
	    powerbak = power_status(ctl_fd, 0, 0);
	    if (powerstatus != powerbak) {
		powerstatus = powerbak;
		powerchange = 1;
	    }
a432 5
		    powerbak = power_status(ctl_fd, 0, 0);
		    if (powerstatus != powerbak) {
			powerstatus = powerbak;
			powerchange = 1;
		    }
d436 1
a436 5
		    powerbak = power_status(ctl_fd, 0, 0);
		    if (powerstatus != powerbak) {
			powerstatus = powerbak;
			powerchange = 1;
		    }
a451 7
	    }
	    if (powerchange) {
		if (powerstatus)
		    powerup(ctl_fd);
		else
		    powerdown(ctl_fd);
		powerchange = 0;
@


1.11
log
@Emulate a powerup/powerdown when resuming.
@
text
@d451 5
a455 2
		    powerstatus = power_status(ctl_fd, 0, 0);
		    powerchange = 1;
@


1.10
log
@Introduce powerup/powerdown actions, when power status changes (AC
connected/disconnected).
@
text
@d421 5
a425 1
	    power_status(ctl_fd, 0, 0);
d451 2
d476 2
a477 1
	    } else if (powerchange) {
@


1.9
log
@exit(-#) is wrong
@
text
@d73 2
d269 11
d321 1
d450 5
a454 1
		    power_status(ctl_fd, 0, 0);
d470 6
@


1.8
log
@use _exit() in signal handler
@
text
@d501 1
a501 1
	_exit(-1);
@


1.7
log
@use dynamic fd_set to avoid overflow
@
text
@d80 1
a80 1
    exit(1);
@


1.6
log
@quiet gcc
@
text
@d309 1
a309 2
    fd_set devfds;
    fd_set selcopy;
d315 1
d388 8
a395 3
    FD_ZERO(&devfds);
    FD_SET(ctl_fd, &devfds);
    FD_SET(sock_fd, &devfds);
d397 6
a402 5
    for (selcopy = devfds, errno = 0, stv = tv; 
	 (ready = select(MAX(ctl_fd,sock_fd)+1, &selcopy, 0, 0, &stv)) >= 0 ||
	     errno == EINTR;
	 selcopy = devfds, errno = 0, stv = tv) {
	if (errno == EINTR)
d404 1
d409 1
a409 1
	if (FD_ISSET(ctl_fd, &selcopy)) {
d457 1
a457 1
	if (FD_ISSET(sock_fd, &selcopy)) {
@


1.5
log
@update usage; back out time remaining display change until I'm sure it
is correct; don't long every power status change in normal operation (patch
from danw@@MIT.EDU).
@
text
@d230 1
a230 1
    int spkrfd;
d262 1
a262 1
    write (spkrfd, "o4cc", 2 + howmany);
@


1.4
log
@apmd will turn off apm driver messages when in daemon mode
added three flags.  -m to not turn off messages.  -e to turn them
back on after an apmd crash.  -p to turn on print percentage change mode.
@
text
@d86 3
a88 1
    fprintf(stderr,"usage: %s [-d] [-t timo] [-s] [-a] [-f devfile] [-S sockfile]\n", __progname);
d126 1
a126 1
		       bstate.minutes_left / 60 );
d429 1
a429 1
		    power_status(ctl_fd, 1, 0);
@


1.3
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d91 10
d124 1
a124 1
		       bstate.minutes_left);
d298 1
a298 1
void
d304 3
d315 1
a315 1
    while ((ch = getopt(argc, argv, "qadsf:t:S:")) != -1)
d340 9
d369 11
d462 1
a462 1
    exit(1);
@


1.2
log
@Fixed socket permissions race at startup; corrected error message to
correctly reflect socket permissions.
@
text
@d249 1
a249 1
    syslog(LOG_DEBUG, "sending %d tones to speaker\n", howmany);
@


1.1
log
@Pull in John Kohl's most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen).
@
text
@d156 1
d160 1
a160 1
	err(1, "cannot set socket mode/owner/group to 666/0/0");
@
