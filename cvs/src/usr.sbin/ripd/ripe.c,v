head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.10
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.5.0.4
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5;
locks; strict;
comment	@ * @;


1.22
date	2016.09.03.10.28.08;	author renato;	state Exp;
branches;
next	1.21;
commitid	3pamvrppu41vvs6n;

1.21
date	2016.09.02.14.07.52;	author benno;	state Exp;
branches;
next	1.20;
commitid	GaB0AXyD9uoXsTK0;

1.20
date	2016.08.02.16.05.32;	author jca;	state Exp;
branches;
next	1.19;
commitid	M3zXmxiZhTfusmGR;

1.19
date	2015.12.05.13.13.47;	author claudio;	state Exp;
branches;
next	1.18;
commitid	b7fx00QUWNpx3oj5;

1.18
date	2015.02.09.12.34.07;	author claudio;	state Exp;
branches;
next	1.17;
commitid	yvJdL4hNLXH54Vei;

1.17
date	2014.11.18.20.54.29;	author krw;	state Exp;
branches;
next	1.16;
commitid	yCis8OrOsfixbKpI;

1.16
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.15;
commitid	lIxCxHhVEpsmXOdi;

1.15
date	2013.11.26.12.00.19;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.06.08.20.55;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.31.20.30.15;	author jacekm;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.31.17.06.01;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.25.12.48.16;	author michele;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.17.14.19.39;	author michele;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.23.13.09.31;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.24.19.05.06;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.13.01.10;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.28.19.21.16;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.31.23.43.11;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.19.12.29.58;	author mcbride;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.16.11.58;	author norby;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@/*	$OpenBSD: ripe.c,v 1.21 2016/09/02 14:07:52 benno Exp $ */

/*
 * Copyright (c) 2006 Michele Marchetto <mydecay@@openbeer.it>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if_types.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <fcntl.h>
#include <pwd.h>
#include <unistd.h>
#include <event.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>

#include "ripd.h"
#include "rip.h"
#include "ripe.h"
#include "log.h"
#include "control.h"

void		 ripe_sig_handler(int, short, void *);
__dead void	 ripe_shutdown(void);

struct ripd_conf	*oeconf = NULL;
struct imsgev		*iev_main;
struct imsgev		*iev_rde;

/* ARGSUSED */
void
ripe_sig_handler(int sig, short event, void *bula)
{
	switch (sig) {
	case SIGINT:
	case SIGTERM:
		ripe_shutdown();
		/* NOTREACHED */
	default:
		fatalx("unexpected signal");
	}
}

/* rip engine */
pid_t
ripe(struct ripd_conf *xconf, int pipe_parent2ripe[2], int pipe_ripe2rde[2],
    int pipe_parent2rde[2])
{
	struct event		 ev_sigint, ev_sigterm;
	struct sockaddr_in	 addr;
	struct iface		*iface = NULL;
	struct passwd		*pw;
	struct redistribute	*r;
	pid_t			 pid;

	switch (pid = fork()) {
	case -1:
		fatal("cannot fork");
	case 0:
		break;
	default:
		return (pid);
	}

	/* create ripd control socket outside chroot */
	if (control_init(xconf->csock) == -1)
		fatalx("control socket setup failed");

	addr.sin_family = AF_INET;
	addr.sin_port = htons(RIP_PORT);
	addr.sin_addr.s_addr = INADDR_ANY;

	if ((xconf->rip_socket = socket(AF_INET,
	    SOCK_DGRAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    IPPROTO_UDP)) == -1)
		fatalx("error creating socket");

	if (bind(xconf->rip_socket, (struct sockaddr *)&addr,
	    sizeof(addr)) == -1)
		fatal("error binding socket");

	/* set some defaults */
	if (if_set_opt(xconf->rip_socket) == -1)
		fatal("if_set_opt");

	if (if_set_mcast_ttl(xconf->rip_socket, IP_DEFAULT_MULTICAST_TTL) == -1)
		fatal("if_set_mcast_ttl");

	if (if_set_mcast_loop(xconf->rip_socket) == -1)
		fatal("if_set_mcast_loop");

	if (if_set_tos(xconf->rip_socket, IPTOS_PREC_INTERNETCONTROL) == -1)
		fatal("if_set_tos");

	if_set_recvbuf(xconf->rip_socket);

	oeconf = xconf;

	if ((pw = getpwnam(RIPD_USER)) == NULL)
		fatal("getpwnam");

	if (chroot(pw->pw_dir) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");

	setproctitle("rip engine");
	ripd_process = PROC_RIP_ENGINE;
	log_procname = log_procnames[ripd_process];

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	event_init();
	nbr_init(NBR_HASHSIZE);

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, ripe_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, ripe_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal(SIGPIPE, SIG_IGN);
	signal(SIGHUP, SIG_IGN);

	/* setup pipes */
	close(pipe_parent2ripe[0]);
	close(pipe_ripe2rde[1]);
	close(pipe_parent2rde[0]);
	close(pipe_parent2rde[1]);

	if ((iev_rde = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_main = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_rde->ibuf, pipe_ripe2rde[0]);
	iev_rde->handler = ripe_dispatch_rde;
	imsg_init(&iev_main->ibuf, pipe_parent2ripe[1]);
	iev_main->handler = ripe_dispatch_main;

	/* setup event handler */
	iev_rde->events = EV_READ;
	event_set(&iev_rde->ev, iev_rde->ibuf.fd, iev_rde->events,
	    iev_rde->handler, iev_rde);
	event_add(&iev_rde->ev, NULL);

	iev_main->events = EV_READ;
	event_set(&iev_main->ev, iev_main->ibuf.fd, iev_main->events,
	    iev_main->handler, iev_main);
	event_add(&iev_main->ev, NULL);

	event_set(&oeconf->ev, oeconf->rip_socket, EV_READ|EV_PERSIST,
	    recv_packet, oeconf);
	event_add(&oeconf->ev, NULL);

	/* remove unneeded config stuff */
	while ((r = SIMPLEQ_FIRST(&oeconf->redist_list)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&oeconf->redist_list, entry);
		free(r);
	}

	/* listen on ripd control socket */
	TAILQ_INIT(&ctl_conns);
	control_listen();

	if ((pkt_ptr = calloc(1, IBUF_READ_SIZE)) == NULL)
		fatal("ripe");

	/* start interfaces */
	LIST_FOREACH(iface, &xconf->iface_list, entry) {
		if_init(xconf, iface);
		if (if_fsm(iface, IF_EVT_UP))
			log_debug("ripe: error starting interface: %s",
			    iface->name);
	}

	evtimer_set(&oeconf->report_timer, report_timer, oeconf);
	start_report_timer();

	ripe_imsg_compose_rde(IMSG_FULL_REQUEST, 0, 0, NULL, 0);

	event_dispatch();

	ripe_shutdown();
	/* NOTREACHED */
	return (0);
}

int
ripe_imsg_compose_parent(int type, pid_t pid, void *data, u_int16_t datalen)
{
	return (imsg_compose_event(iev_main, type, 0, pid, -1, data, datalen));
}

int
ripe_imsg_compose_rde(int type, u_int32_t peerid, pid_t pid,
    void *data, u_int16_t datalen)
{
	return (imsg_compose_event(iev_rde, type, peerid, pid, -1,
	    data, datalen));
}

/* ARGSUSED */
void
ripe_dispatch_main(int fd, short event, void *bula)
{
	struct imsg	 imsg;
	struct imsgev	*iev = bula;
	struct imsgbuf	*ibuf = &iev->ibuf;
	struct kif	*kif;
	struct iface	*iface;
	ssize_t		 n;
	int		 link_ok, shut = 0;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("ripe_dispatch_main: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_IFINFO:
			if (imsg.hdr.len - IMSG_HEADER_SIZE !=
			    sizeof(struct kif))
				fatalx("IFINFO imsg with wrong len");
			kif = imsg.data;
			link_ok = (kif->flags & IFF_UP) &&
			    LINK_STATE_IS_UP(kif->link_state);

			LIST_FOREACH(iface, &oeconf->iface_list, entry) {
				if (kif->ifindex == iface->ifindex) {
					iface->flags = kif->flags;
					iface->linkstate = kif->link_state;

					if (link_ok) {
						if_fsm(iface, IF_EVT_UP);
						log_warnx("interface %s up",
						    iface->name);
					} else {
						if_fsm(iface, IF_EVT_DOWN);
						log_warnx("interface %s down",
						    iface->name);
					}
				}
			}
			break;
		case IMSG_CTL_IFINFO:
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_END:
			control_imsg_relay(&imsg);
			break;
		default:
			log_debug("ripe_dispatch_main: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */  
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
void
ripe_dispatch_rde(int fd, short event, void *bula)
{
	struct rip_route	*rr;
	struct imsg		 imsg;
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct iface		*iface;
	struct nbr		*nbr;
	ssize_t			 n;
	int			 shut = 0;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("ripe_dispatch_rde: imsg_get error");
		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_REQUEST_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(*rr))
				fatalx("invalid size of RDE request");

			if ((rr = malloc(sizeof(*rr))) == NULL)
				fatal("ripe_dispatch_rde");

			memcpy(rr, imsg.data, sizeof(*rr));

			if (imsg.hdr.peerid != 0) {
				if ((nbr = nbr_find_peerid(imsg.hdr.peerid)) ==
				    NULL) {
					log_debug("unknown neighbor id %u",
					    imsg.hdr.peerid);
					break;
				}
				add_entry(&nbr->rq_list, rr);
				break;
			}

			LIST_FOREACH(iface, &oeconf->iface_list, entry) {
				add_entry(&iface->rq_list, rr);
			}
			break;
		case IMSG_SEND_REQUEST:
			if (imsg.hdr.peerid != 0) {
				if ((nbr = nbr_find_peerid(imsg.hdr.peerid)) ==
				    NULL) {
					log_debug("unknown neighbor id %u",
					    imsg.hdr.peerid);
					break;
				}
				send_request(&nbr->rq_list, NULL, nbr);
				break;
			}

			LIST_FOREACH(iface, &oeconf->iface_list, entry) {
				send_request(&iface->rq_list, iface, NULL);
			}
			break;
		case IMSG_RESPONSE_ADD:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(*rr))
				fatalx("invalid size of RDE request");

			if ((rr = malloc(sizeof(*rr))) == NULL)
				fatal("ripe_dispatch_rde");

			memcpy(rr, imsg.data, sizeof(*rr));

			if (imsg.hdr.peerid == 0) {
				LIST_FOREACH(iface, &oeconf->iface_list, entry)
					add_entry(&iface->rp_list, rr);

				break;
			}

			if ((nbr = nbr_find_peerid(imsg.hdr.peerid)) == NULL) {
				log_debug("unknown neighbor id %u",
				    imsg.hdr.peerid);
				break;
			}
			iface = nbr->iface;
			add_entry(&nbr->rp_list, rr);

			break;
		case IMSG_SEND_RESPONSE:
			if (imsg.hdr.peerid == 0) {
				LIST_FOREACH(iface, &oeconf->iface_list,
				    entry) {
					send_response(&iface->rp_list,
					    iface, NULL);
				}
				break;
			}

			if ((nbr = nbr_find_peerid(imsg.hdr.peerid)) == NULL) {
				log_debug("unknown neighbor id %u",
				    imsg.hdr.peerid);
				break;
			}
			send_response(&nbr->rp_list, NULL, nbr);
			nbr_fsm(nbr, NBR_EVT_RESPONSE_SENT);
			break;
		case IMSG_SEND_TRIGGERED_UPDATE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(struct
			    rip_route))
				fatalx("invalid size of RDE request");

			rr = imsg.data;

			LIST_FOREACH(iface, &oeconf->iface_list,
			    entry) {
				if (rr->ifindex != iface->ifindex)
					send_triggered_update(iface, rr);
			}
			break;
		case IMSG_CTL_END:
		case IMSG_CTL_SHOW_RIB:
			control_imsg_relay(&imsg);
			break;
		default:
			log_debug("ripe_dispatch_rde: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */  
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

__dead void
ripe_shutdown(void)
{
	struct iface	*iface;

	/* close pipes */
	msgbuf_write(&iev_rde->ibuf.w);
	msgbuf_clear(&iev_rde->ibuf.w);
	close(iev_rde->ibuf.fd);
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
	close(iev_main->ibuf.fd);

	LIST_FOREACH(iface, &oeconf->iface_list, entry) {
		if (if_fsm(iface, IF_EVT_DOWN)) {
			log_debug("error stopping interface %s",
			    iface->name);
		}
	}
	while ((iface = LIST_FIRST(&oeconf->iface_list)) != NULL) {
		LIST_REMOVE(iface, entry);
		if_del(iface);
	}

	close(oeconf->rip_socket);

	/* clean up */
	free(iev_rde);
	free(iev_main);
	free(oeconf);
	free(pkt_ptr);

	log_info("rip engine exiting");
	_exit(0);
}

void
ripe_iface_ctl(struct ctl_conn *c, unsigned int idx)
{
	struct iface		*iface;
	struct ctl_iface	*ictl;

	LIST_FOREACH(iface, &oeconf->iface_list, entry) {
		if (idx == 0 || idx == iface->ifindex) {
			ictl = if_to_ctl(iface);
			imsg_compose_event(&c->iev, IMSG_CTL_SHOW_IFACE,
			    0, 0, -1, ictl, sizeof(struct ctl_iface));
		}
	}
}

void
ripe_nbr_ctl(struct ctl_conn *c)
{
	struct iface	*iface;
	struct nbr	*nbr;
	struct ctl_nbr	*nctl;

	LIST_FOREACH(iface, &oeconf->iface_list, entry)
		LIST_FOREACH(nbr, &iface->nbr_list, entry) {
				nctl = nbr_to_ctl(nbr);
				imsg_compose_event(&c->iev,
				    IMSG_CTL_SHOW_NBR, 0, 0, -1, nctl,
				    sizeof(struct ctl_nbr));
		}

	imsg_compose_event(&c->iev, IMSG_CTL_END, 0, 0, -1, NULL, 0);
}

void
ripe_demote_iface(struct iface *iface, int active)
{
	struct demote_msg	dmsg;

	if (ripd_process != PROC_RIP_ENGINE ||
	    iface->demote_group[0] == '\0')
		return;

	bzero(&dmsg, sizeof(dmsg));
	strlcpy(dmsg.demote_group, iface->demote_group,
	    sizeof(dmsg.demote_group));
	if (active)
		dmsg.level = -1;
	else
		dmsg.level = 1;

	ripe_imsg_compose_parent(IMSG_DEMOTE, 0, &dmsg, sizeof(dmsg));
}
@


1.21
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.20 2016/08/02 16:05:32 jca Exp $ */
d46 1
a46 1
void		 ripe_shutdown(void);
d453 1
a453 1
void
d458 8
a479 2
	msgbuf_write(&iev_rde->ibuf.w);
	msgbuf_clear(&iev_rde->ibuf.w);
a480 2
	msgbuf_write(&iev_main->ibuf.w);
	msgbuf_clear(&iev_main->ibuf.w);
@


1.20
log
@Allow specifying an alternate socket path.

This allows one to run multiple ripd instances, for example to serve
multiple rdomains.  Diff from Nima GHOTBI, ok claudio@@ florian@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.19 2015/12/05 13:13:47 claudio Exp $ */
d131 1
@


1.19
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.18 2015/02/09 12:34:07 claudio Exp $ */
d88 1
a88 1
	if (control_init() == -1)
@


1.18
log
@Add SOCK_CLOEXEC | SOCK_NONBLOCK to two more socket calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.17 2014/11/18 20:54:29 krw Exp $ */
d237 1
a237 1
		if ((n = imsg_read(ibuf)) == -1)
d251 1
a251 1
			fatal("ripe_dispatch_main: imsg_read error");
d317 1
a317 1
		if ((n = imsg_read(ibuf)) == -1)
d331 1
a331 1
			fatal("ripe_dispatch_rde: imsg_read error");
@


1.17
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.16 2014/07/12 20:16:38 krw Exp $ */
d95 2
a96 1
	if ((xconf->rip_socket = socket(AF_INET, SOCK_DGRAM,
@


1.16
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.15 2013/11/26 12:00:19 henning Exp $ */
a37 1
#include <stdlib.h>
@


1.15
log
@msgbuf_write EAGAIN, ok gilles benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.14 2011/07/04 04:34:14 claudio Exp $ */
d243 1
a243 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d245 2
d323 1
a323 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d325 2
@


1.14
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.13 2010/05/26 13:56:08 nicm Exp $ */
d243 1
a243 1
		if (msgbuf_write(&ibuf->w) == -1)
d321 1
a321 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.13
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.12 2009/06/06 08:20:55 eric Exp $ */
d260 1
a260 3
			    (LINK_STATE_IS_UP(kif->link_state) ||
			    (kif->link_state == LINK_STATE_UNKNOWN &&
			    kif->media_type != IFT_CARP));
@


1.12
log
@make ripctl/ripd imsg-in-a-lib ready too.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.11 2009/05/31 20:30:15 jacekm Exp $ */
d187 1
a187 1
	if ((pkt_ptr = calloc(1, READ_BUF_SIZE)) == NULL)
@


1.11
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.10 2009/05/31 17:06:01 claudio Exp $ */
d50 2
a51 2
struct imsgbuf		*ibuf_main;
struct imsgbuf		*ibuf_rde;
d154 2
a155 2
	if ((ibuf_rde = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_main = malloc(sizeof(struct imsgbuf))) == NULL)
d157 4
a160 2
	imsg_init(ibuf_rde, pipe_ripe2rde[0], ripe_dispatch_rde);
	imsg_init(ibuf_main, pipe_parent2ripe[1], ripe_dispatch_main);
d163 9
a171 9
	ibuf_rde->events = EV_READ;
	event_set(&ibuf_rde->ev, ibuf_rde->fd, ibuf_rde->events,
	    ibuf_rde->handler, ibuf_rde);
	event_add(&ibuf_rde->ev, NULL);

	ibuf_main->events = EV_READ;
	event_set(&ibuf_main->ev, ibuf_main->fd, ibuf_main->events,
	    ibuf_main->handler, ibuf_main);
	event_add(&ibuf_main->ev, NULL);
d213 1
a213 1
	return (imsg_compose(ibuf_main, type, 0, pid, data, datalen));
d220 2
a221 1
	return (imsg_compose(ibuf_rde, type, peerid, pid, data, datalen));
d229 2
a230 1
	struct imsgbuf	*ibuf = bula;
d295 1
a295 1
		imsg_event_add(ibuf);
d298 1
a298 1
		event_del(&ibuf->ev);
d309 2
a310 1
	struct imsgbuf		*ibuf = bula;
d442 1
a442 1
		imsg_event_add(ibuf);
d445 1
a445 1
		event_del(&ibuf->ev);
d469 6
a474 6
	msgbuf_write(&ibuf_rde->w);
	msgbuf_clear(&ibuf_rde->w);
	free(ibuf_rde);
	msgbuf_write(&ibuf_main->w);
	msgbuf_clear(&ibuf_main->w);
	free(ibuf_main);
d491 2
a492 2
			imsg_compose(&c->ibuf, IMSG_CTL_SHOW_IFACE,
			    0, 0, ictl, sizeof(struct ctl_iface));
d507 2
a508 2
				imsg_compose(&c->ibuf,
				    IMSG_CTL_SHOW_NBR, 0, 0, nctl,
d512 1
a512 1
	imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, NULL, 0);
@


1.10
log
@Better EV_READ and EV_WRITE handling in the libevent callbacks. Again mostly
the same ospfd diff applied with some fuzz.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.9 2009/03/25 12:48:16 michele Exp $ */
a240 1
		imsg_event_add(ibuf);
a319 1
		imsg_event_add(ibuf);
@


1.9
log
@With redistribute connected set, announce the prefix on the interface
with address belonging to that prefix. Don't skip it.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.8 2008/12/17 14:19:39 michele Exp $ */
d232 1
a232 2
	switch (event) {
	case EV_READ:
d237 2
a238 2
		break;
	case EV_WRITE:
a241 3
		return;
	default:
		fatalx("unknown event");
d312 1
a312 2
	switch (event) {
	case EV_READ:
d317 2
a318 2
		break;
	case EV_WRITE:
a321 3
		return;
	default:
		fatalx("unknown event");
@


1.8
log
@Add support for demotion counter.
When interfaces go up/down the demotion counter of the
specified group is decreased/increased.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.7 2008/11/23 13:09:31 michele Exp $ */
d389 3
a391 10
				LIST_FOREACH(iface, &oeconf->iface_list,
				    entry) {
					if ((iface->addr.s_addr &
					    iface->mask.s_addr) !=
					    rr->address.s_addr ||
					    iface->mask.s_addr !=
					    rr->mask.s_addr)
						add_entry(&iface->rp_list,
						    rr);
				}
d401 2
a402 4
			if ((iface->addr.s_addr & iface->mask.s_addr) !=
			    rr->address.s_addr ||
			    iface->mask.s_addr != rr->mask.s_addr)
				add_entry(&nbr->rp_list, rr);
@


1.7
log
@Fix two error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.6 2007/10/24 19:05:06 claudio Exp $ */
d527 20
@


1.6
log
@Sync a bit more with ospfd. Do not fatal if one of the pipes is closed,
instead do a "nice" shutdown. Ignore SIGHUP in the childs even though we
have no reload support (yet). Remove some redundant code and clean up some
types.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.5 2007/01/08 13:01:10 claudio Exp $ */
d98 1
a98 1
		fatalx("if_init: cannot create socket");
d102 1
a102 1
		fatal("error creating socket");
@


1.5
log
@New redistribute code adapted from ospfd. It is now possible to do the same
redistribute setups as in ospfd (rtlables, per prefix, negation).
Tested, input and OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.4 2006/11/28 19:21:16 reyk Exp $ */
d146 1
a207 1
/* imesg */
a226 1
	int		 n, link_ok;
d229 2
d237 1
a237 1
			fatalx("pipe closed");
d295 7
a301 1
	imsg_event_add(ibuf);
d313 2
a314 1
	int			 n;
d321 1
a321 1
			fatalx("pipe closed");
d455 7
a461 1
	imsg_event_add(ibuf);
@


1.4
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.3 2006/10/31 23:43:11 michele Exp $ */
d72 2
a74 1
	struct sockaddr_in	 addr;
d76 1
a76 1
	struct event		 ev_sigint, ev_sigterm;
d173 6
@


1.3
log
@create a temporary neighbor instead of a permanent one when a request is received
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.2 2006/10/19 12:29:58 mcbride Exp $ */
d253 1
a253 1
			    (kif->link_state == LINK_STATE_UP ||
@


1.2
log
@Correct function name in log_debug() messages
@
text
@d1 1
a1 1
/*	$OpenBSD: ripe.c,v 1.1 2006/10/18 16:11:58 norby Exp $ */
d414 1
@


1.1
log
@Welcome ripd
started by Michele Marchetto some time ago by using the imsg/three process framework
of ospfd. He implemented most of the daemon with a little help and guidance from
Claudio and I.

Currently the daemon is more or less complete, with the exception of key lifetime
and rollover.

Not yet connected to the builds.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d184 2
a185 1
			log_debug("error starting interface: %s", iface->name);
@

