head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.32
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.34
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.26
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.30
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.28
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.24
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.22
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.20
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.18
	OPENBSD_5_0:1.9.0.16
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.14
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.12
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.8
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.10
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.6
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.11
date	2017.01.17.16.30.54;	author jca;	state Exp;
branches;
next	1.10;
commitid	Ywz8bnXTyXEFkF5Y;

1.10
date	2016.07.18.21.20.31;	author benno;	state Exp;
branches;
next	1.9;
commitid	gHj6CD6cOEVlL8Vc;

1.9
date	2007.10.24.19.50.33;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.18.17.00.59;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.27.20.19.04;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.23.21.10.10;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.24.15.56.28;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.10.10.28.18;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.01.20.55.40;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.31.23.43.11;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.16.11.58;	author norby;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Keep track of dead peers instead of freeing them right away.

This mimics what ospfd does, and avoids a (mostly harmless)
use-after-free.  Delay suggested by claudio@@, ok florian@@
@
text
@/*	$OpenBSD: neighbor.c,v 1.10 2016/07/18 21:20:31 benno Exp $ */

/*
 * Copyright (c) 2006 Michele Marchetto <mydecay@@openbeer.it>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005, 2006 Esben Norby <norby@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>

#include <ctype.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <event.h>

#include "ripd.h"
#include "rip.h"
#include "ripe.h"
#include "log.h"
#include "rde.h"

void	nbr_set_timer(struct nbr *);
void	nbr_stop_timer(struct nbr *);

void	nbr_failed_new(struct nbr *);
void	nbr_failed_timeout(int, short, void *);

LIST_HEAD(nbr_head, nbr);

struct nbr_table {
	struct nbr_head		*hashtbl;
	u_int32_t		 hashmask;
} nbrtable;

#define NBR_HASH(x)		\
	&nbrtable.hashtbl[(x) & nbrtable.hashmask]

u_int32_t	peercnt = NBR_CNTSTART;

struct {
	int		state;
	enum nbr_event	event;
	enum nbr_action	action;
	int		new_state;
} nbr_fsm_tbl[] = {
    /* current state	event that happened	action to take		resulting state */
    {NBR_STA_DOWN,	NBR_EVT_REQUEST_RCVD,	NBR_ACT_NOTHING,	NBR_STA_REQ_RCVD},
    {NBR_STA_DOWN,	NBR_EVT_RESPONSE_RCVD,	NBR_ACT_STRT_TIMER,	NBR_STA_ACTIVE},
    {NBR_STA_ACTIVE,	NBR_EVT_RESPONSE_RCVD,	NBR_ACT_RST_TIMER,	NBR_STA_ACTIVE},
    {NBR_STA_ACTIVE,	NBR_EVT_REQUEST_RCVD,	NBR_ACT_NOTHING,	NBR_STA_ACTIVE},
    {NBR_STA_ACTIVE,	NBR_EVT_TIMEOUT,	NBR_ACT_DEL,		NBR_STA_DOWN},
    {NBR_STA_REQ_RCVD,	NBR_EVT_RESPONSE_SENT,	NBR_ACT_DEL,		NBR_STA_DOWN},
    {NBR_STA_ACTIVE,	NBR_EVT_RESPONSE_SENT,	NBR_ACT_NOTHING,	NBR_STA_ACTIVE},
    {NBR_STA_ANY,	NBR_EVT_KILL_NBR,	NBR_ACT_DEL,		NBR_STA_DOWN},
    {-1,		NBR_EVT_NOTHING,	NBR_ACT_NOTHING,	0},
};

const char * const nbr_event_names[] = {
	"RESPONSE RCVD",
	"REQUEST RCVD",
	"RESPONSE SENT",
	"NBR TIMEOUT",
	"NBR KILL",
	"NOTHING"
};

const char * const nbr_action_names[] = {
	"START TIMER",
	"RESET TIMER",
	"DELETE NBR",
	"NOTHING"
};

int
nbr_fsm(struct nbr *nbr, enum nbr_event event)
{
	struct timeval	 now;
	int		 old_state;
	int		 new_state = 0;
	int		 i;

	old_state = nbr->state;
	for (i = 0; nbr_fsm_tbl[i].state != -1; i++)
		if ((nbr_fsm_tbl[i].state & old_state) &&
		    (nbr_fsm_tbl[i].event == event)) {
			new_state = nbr_fsm_tbl[i].new_state;
			break;
		}

	if (nbr_fsm_tbl[i].state == -1) {
		/* event outside of the defined fsm, ignore it. */
		log_warnx("nbr_fsm: neighbor ID %s, "
		    "event '%s' not expected in state '%s'",
		    inet_ntoa(nbr->id), nbr_event_name(event),
		    nbr_state_name(old_state));
		return (0);
	}

	switch (nbr_fsm_tbl[i].action) {
	case NBR_ACT_RST_TIMER:
		nbr_set_timer(nbr);
		break;
	case NBR_ACT_STRT_TIMER:
		nbr_set_timer(nbr);
		break;
	case NBR_ACT_DEL:
		nbr_act_del(nbr);
		break;
	case NBR_ACT_NOTHING:
		/* do nothing */
		break;
	}

	if (new_state != 0)
		nbr->state = new_state;

	if (old_state != nbr->state) {
		/* neighbor changed from/to ACTIVE */
		gettimeofday(&now, NULL);
		nbr->uptime = now.tv_sec;

		log_debug("nbr_fsm: event '%s' resulted in action '%s' and "
		    "changing state for neighbor ID %s from '%s' to '%s'",
		    nbr_event_name(event),
		    nbr_action_name(nbr_fsm_tbl[i].action),
		    inet_ntoa(nbr->id), nbr_state_name(old_state),
		    nbr_state_name(nbr->state));
	}

	return (0);
}

void
nbr_init(u_int32_t hashsize)
{
	u_int32_t	 hs, i;

	for (hs = 1; hs < hashsize; hs <<= 1)
		;
	nbrtable.hashtbl = calloc(hs, sizeof(struct nbr_head));
	if (nbrtable.hashtbl == NULL)
		fatal("nbr_init");

	for (i = 0; i < hs; i++)
		LIST_INIT(&nbrtable.hashtbl[i]);

	nbrtable.hashmask = hs - 1;
}

struct nbr *
nbr_new(u_int32_t nbr_id, struct iface *iface)
{
	struct nbr_head	*head;
	struct nbr	*nbr = NULL;

	if ((nbr = calloc(1, sizeof(*nbr))) == NULL)
		fatal("nbr_new");

	nbr->state = NBR_STA_DOWN;
	nbr->id.s_addr = nbr_id;

	/* get next unused peerid */
	while (nbr_find_peerid(++peercnt))
		;
	nbr->peerid = peercnt;
	head = NBR_HASH(nbr->peerid);
	LIST_INSERT_HEAD(head, nbr, hash);

	/* add to peer list */
	nbr->iface = iface;
	LIST_INSERT_HEAD(&iface->nbr_list, nbr, entry);

	TAILQ_INIT(&nbr->rp_list);
	TAILQ_INIT(&nbr->rq_list);

	/* set event structures */
	evtimer_set(&nbr->timeout_timer, nbr_timeout_timer, nbr);

	log_debug("nbr_new: neighbor ID %s, peerid %u",
	    inet_ntoa(nbr->id), nbr->peerid);

	return (nbr);
}

void
nbr_del(struct nbr *nbr)
{
	log_debug("nbr_del: neighbor ID %s, peerid %u", inet_ntoa(nbr->id),
	    nbr->peerid);

	/* stop timer */
	nbr_stop_timer(nbr);

	LIST_REMOVE(nbr, entry);
	LIST_REMOVE(nbr, hash);

	free(nbr);
}

void
nbr_act_del(struct nbr *nbr)
{
	/* If there is no authentication or it is just a route request
	 * there is no need to keep track of the failed neighbors */
	if (nbr->iface->auth_type == AUTH_CRYPT &&
	    nbr->state != NBR_STA_REQ_RCVD)
		nbr_failed_new(nbr);

	log_debug("nbr_act_del: neighbor ID %s, peerid %u", inet_ntoa(nbr->id),
	    nbr->peerid);

	/* schedule kill timer */
	nbr_set_timer(nbr);

	/* clear lists */
	clear_list(&nbr->rq_list);
	clear_list(&nbr->rp_list);
}

struct nbr *
nbr_find_peerid(u_int32_t peerid)
{
	struct nbr_head	*head;
	struct nbr	*nbr;

	head = NBR_HASH(peerid);

	LIST_FOREACH(nbr, head, hash) {
		if (nbr->peerid == peerid)
			return (nbr);
	}

	return (NULL);
}

struct nbr *
nbr_find_ip(struct iface *iface, u_int32_t src_ip)
{
	struct nbr	*nbr = NULL;

	LIST_FOREACH(nbr, &iface->nbr_list, entry) {
		if (nbr->id.s_addr == src_ip) {
			return (nbr);
		}
	}

	return (NULL);
}

/* failed nbr handling */
void
nbr_failed_new(struct nbr *nbr)
{
	struct timeval		 tv;
	struct iface		*iface;
	struct nbr_failed	*nbr_failed;

	if ((nbr_failed = calloc(1, sizeof(*nbr_failed))) == NULL)
		fatal("nbr_failed_new");

	nbr_failed->addr = nbr->addr;
	nbr_failed->auth_seq_num = nbr->auth_seq_num;
	iface = nbr->iface;

	timerclear(&tv);
	tv.tv_sec = FAILED_NBR_TIMEOUT;

	evtimer_set(&nbr_failed->timeout_timer, nbr_failed_timeout,
	    nbr_failed);

	if (evtimer_add(&nbr_failed->timeout_timer, &tv) == -1)
		fatal("nbr_failed_new");

	LIST_INSERT_HEAD(&iface->failed_nbr_list, nbr_failed, entry);
}

struct nbr_failed *
nbr_failed_find(struct iface *iface, u_int32_t src_ip)
{
	struct nbr_failed	*nbr_failed = NULL;

	LIST_FOREACH(nbr_failed, &iface->failed_nbr_list, entry) {
		if (nbr_failed->addr.s_addr == src_ip) {
			return (nbr_failed);
		}
	}

	return (NULL);
}

void
nbr_failed_delete(struct nbr_failed *nbr_failed)
{
	if (evtimer_pending(&nbr_failed->timeout_timer, NULL))
		if (evtimer_del(&nbr_failed->timeout_timer) == -1)
			fatal("nbr_failed_delete");

	LIST_REMOVE(nbr_failed, entry);
	free(nbr_failed);
}

/* timers */
/* ARGSUSED */
void
nbr_timeout_timer(int fd, short event, void *arg)
{
	struct nbr *nbr = arg;

	if (nbr->state == NBR_STA_DOWN)
		nbr_del(nbr);
	else
		nbr_fsm(nbr, NBR_EVT_TIMEOUT);
}

/* ARGSUSED */
void
nbr_failed_timeout(int fd, short event, void *arg)
{
	struct nbr_failed	*nbr_failed = arg;

	log_debug("nbr_failed_timeout: failed neighbor ID %s deleted",
	    inet_ntoa(nbr_failed->addr));

	nbr_failed_delete(nbr_failed);
}

/* actions */
void
nbr_set_timer(struct nbr *nbr)
{
	struct timeval	tv;

	timerclear(&tv);
	tv.tv_sec = NBR_TIMEOUT;

	if (evtimer_add(&nbr->timeout_timer, &tv) == -1)
		fatal("nbr_set_timer");
}

void
nbr_stop_timer(struct nbr *nbr)
{
	if (evtimer_del(&nbr->timeout_timer) == -1)
		fatal("nbr_stop_timer");
}

/* names */
const char *
nbr_event_name(int event)
{
	return (nbr_event_names[event]);
}

const char *
nbr_action_name(int action)
{
	return (nbr_action_names[action]);
}

struct ctl_nbr *
nbr_to_ctl(struct nbr *nbr)
{
	static struct ctl_nbr	 nctl;
	struct timeval		 tv, now, res;

	memcpy(nctl.name, nbr->iface->name, sizeof(nctl.name));
	memcpy(&nctl.id, &nbr->id, sizeof(nctl.id));
	memcpy(&nctl.addr, &nbr->addr, sizeof(nctl.addr));

	nctl.nbr_state = nbr->state;
	nctl.iface_state = nbr->iface->state;

	gettimeofday(&now, NULL);
	if (evtimer_pending(&nbr->timeout_timer, &tv)) {
		timersub(&tv, &now, &res);
		if (nbr->state & NBR_STA_DOWN)
			nctl.dead_timer = NBR_TIMEOUT - res.tv_sec;
		else
			nctl.dead_timer = res.tv_sec;
	} else
		nctl.dead_timer = 0;

	if (nbr->state == NBR_STA_ACTIVE) {
		nctl.uptime = now.tv_sec - nbr->uptime;
	} else
		nctl.uptime = 0;

	return (&nctl);
}
@


1.10
log
@add format attributes to log functions

ok   florian@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.9 2007/10/24 19:50:33 claudio Exp $ */
d206 15
d229 1
a229 1
	log_debug("nbr_del: neighbor ID %s, peerid %u", inet_ntoa(nbr->id),
d232 2
a233 2
	/* stop timer */
	nbr_stop_timer(nbr);
a237 5

	LIST_REMOVE(nbr, entry);
	LIST_REMOVE(nbr, hash);

	free(nbr);
d329 4
a332 1
	nbr_fsm(nbr, NBR_EVT_TIMEOUT);
@


1.9
log
@Garbage collect unused stuff found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.8 2007/10/18 17:00:59 deraadt Exp $ */
d199 1
a199 1
	log_debug("nbr_new: neighbor ID %s, peerid %lu",
d214 1
a214 1
	log_debug("nbr_del: neighbor ID %s, peerid %lu", inet_ntoa(nbr->id),
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.7 2007/03/27 20:19:04 michele Exp $ */
a46 1
void	nbr_failed_stop_timer(struct nbr_failed *);
@


1.7
log
@Remove unused parameter in nbr_new
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.6 2007/01/23 21:10:10 michele Exp $ */
d157 1
a157 1
	u_int32_t        hs, i;
d277 1
a277 1
	tv.tv_sec = FAILED_NBR_TIMEOUT; 
@


1.6
log
@add timeout for failed nbr structures

OK claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.5 2006/12/24 15:56:28 michele Exp $ */
d172 1
a172 1
nbr_new(u_int32_t nbr_id, struct iface *iface, int self)
@


1.5
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.4 2006/11/10 10:28:18 michele Exp $ */
d45 4
d74 1
a74 1
    {NBR_STA_ACTIVE,	NBR_EVT_RESPONSE_SENT,	NBR_ACT_NOTHING,	NBR_STA_ACTIVE},	
a208 3
	struct nbr_failed	*nbr_failed;
	struct iface		*iface;

d212 2
a213 10
	    nbr->state != NBR_STA_REQ_RCVD) {
		if ((nbr_failed = calloc(1, sizeof(*nbr_failed))) == NULL)
			fatal("nbr_act_del");

		nbr_failed->addr = nbr->addr;
		nbr_failed->auth_seq_num = nbr->auth_seq_num;
		iface = nbr->iface;
		LIST_INSERT_HEAD(&iface->failed_nbr_list,
		    nbr_failed, entry);
	}
d261 27
d303 1
a303 1
nbr_failed_delete(struct iface *iface, struct nbr_failed *nbr_failed)
d305 4
a309 1

d321 12
@


1.4
log
@clear lists before deleting neighbor

OK claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.3 2006/11/01 20:55:40 claudio Exp $ */
d310 1
a310 1
		fatal("nbr_ret_timer");
@


1.3
log
@Stop the running timer in case a neighbor is deleted. This fixes a crash
found by Martin Boehme. ok michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.2 2006/10/31 23:43:11 michele Exp $ */
d229 2
a230 1
	//response_list_clr(&nbr->rr_list);
@


1.2
log
@create a temporary neighbor instead of a permanent one when a request is received
@
text
@d1 1
a1 1
/*	$OpenBSD: neighbor.c,v 1.1 2006/10/18 16:11:58 norby Exp $ */
d42 2
a43 2
void		 nbr_start_timer(struct nbr *);
void		 nbr_reset_timer(struct nbr *);
d118 1
a118 1
		nbr_reset_timer(nbr);
d121 1
a121 1
		nbr_start_timer(nbr);
d225 3
d301 1
a301 1
nbr_reset_timer(struct nbr *nbr)
d309 1
a309 1
		fatal("nbr_reset_timer");
d313 1
a313 1
nbr_start_timer(struct nbr *nbr)
d315 2
a316 7
	struct timeval  tv;

	timerclear(&tv);
	tv.tv_sec = NBR_TIMEOUT;

	if (evtimer_add(&nbr->timeout_timer, &tv) == -1)
		fatal("nbr_start_timer");
@


1.1
log
@Welcome ripd
started by Michele Marchetto some time ago by using the imsg/three process framework
of ospfd. He implemented most of the daemon with a little help and guidance from
Claudio and I.

Currently the daemon is more or less complete, with the exception of key lifetime
and rollover.

Not yet connected to the builds.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d64 1
a64 1
    {NBR_STA_DOWN,	NBR_EVT_REQUEST_RCVD,	NBR_ACT_STRT_TIMER,	NBR_STA_ACTIVE},
d69 2
d78 1
d208 4
a211 1
	if (nbr->iface->auth_type == AUTH_CRYPT) {
@

