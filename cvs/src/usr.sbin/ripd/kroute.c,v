head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.2
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.31.0.8
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.14
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.10
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5;
locks; strict;
comment	@ * @;


1.32
date	2017.07.24.11.00.01;	author friehm;	state Exp;
branches;
next	1.31;
commitid	LhKZV4SjfogJNr88;

1.31
date	2015.09.27.17.32.36;	author stsp;	state Exp;
branches;
next	1.30;
commitid	i6S6VoG4dUqAlOvy;

1.30
date	2015.07.17.20.38.33;	author claudio;	state Exp;
branches;
next	1.29;
commitid	jg9ZnaLsVxiffvm8;

1.29
date	2015.02.11.05.58.08;	author claudio;	state Exp;
branches;
next	1.28;
commitid	mHmXCWAtRgVvDi4z;

1.28
date	2015.02.10.08.23.13;	author claudio;	state Exp;
branches;
next	1.27;
commitid	FVbF6kzXu3vu0Vv8;

1.27
date	2015.02.09.12.34.07;	author claudio;	state Exp;
branches;
next	1.26;
commitid	yvJdL4hNLXH54Vei;

1.26
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2014.06.23.03.46.17;	author guenther;	state Exp;
branches;
next	1.24;
commitid	uXnRK9VvnFZsAqfW;

1.24
date	2011.07.04.04.34.14;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2011.06.26.19.19.23;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.12.14.35.13;	author bluhm;	state Exp;
branches;
next	1.21;

1.21
date	2010.01.02.14.40.54;	author michele;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.26.18.24.58;	author michele;	state Exp;
branches;
next	1.19;

1.19
date	2009.09.24.12.30.36;	author michele;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.18.16.17.02;	author michele;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.07.12.07.23;	author michele;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.05.22.40.24;	author chris;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.02.21.43.36;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.31.09.11.45;	author michele;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.09.12.47.42;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.24.20.29.30;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.18.17.00.59;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.17.20.18.11;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.27.09.20.32;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.19.13.54.36;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.19.10.23.42;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.13.16.50.58;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2006.11.28.16.36.58;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.16.15.56.26;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.24.16.37.48;	author david;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.16.11.58;	author norby;	state Exp;
branches;
next	;

1.5.2.1
date	2007.04.30.20.45.01;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Unify ROUNDUP macros for parsing route messages.
Use the macro from route(8) / ospf6d(8) since it works also with argument 0.

OK claudio@@
@
text
@/*	$OpenBSD: kroute.c,v 1.31 2015/09/27 17:32:36 stsp Exp $ */

/*
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/tree.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "rip.h"
#include "ripd.h"
#include "log.h"

struct {
	u_int32_t		rtseq;
	pid_t			pid;
	int			fib_sync;
	int			fd;
	struct event		ev;
	u_int			rdomain;
} kr_state;

struct kroute_node {
	RB_ENTRY(kroute_node)	 entry;
	struct kroute		 r;
};

struct kif_node {
	RB_ENTRY(kif_node)	 entry;
	struct kif		 k;
};

void	kr_redistribute(int, struct kroute *);
int	kroute_compare(struct kroute_node *, struct kroute_node *);
int	kif_compare(struct kif_node *, struct kif_node *);
int	kr_change_fib(struct kroute_node *, struct kroute *, int);

struct kroute_node	*kroute_find(in_addr_t, in_addr_t, u_int8_t);
int			 kroute_insert(struct kroute_node *);
int			 kroute_remove(struct kroute_node *);
void			 kroute_clear(void);

struct kif_node		*kif_find(int);
int			 kif_insert(struct kif_node *);
int			 kif_remove(struct kif_node *);
void			 kif_clear(void);
int			 kif_validate(int);

struct kroute_node	*kroute_match(in_addr_t);

int		protect_lo(void);
u_int8_t	prefixlen_classful(in_addr_t);
void		get_rtaddrs(int, struct sockaddr *, struct sockaddr **);
void		if_change(u_short, int, struct if_data *);
void		if_announce(void *);

int		send_rtmsg(int, int, struct kroute *);
int		dispatch_rtmsg(void);
int		fetchtable(void);
int		fetchifs(int);

RB_HEAD(kroute_tree, kroute_node)	krt;
RB_PROTOTYPE(kroute_tree, kroute_node, entry, kroute_compare)
RB_GENERATE(kroute_tree, kroute_node, entry, kroute_compare)

RB_HEAD(kif_tree, kif_node)		kit;
RB_PROTOTYPE(kif_tree, kif_node, entry, kif_compare)
RB_GENERATE(kif_tree, kif_node, entry, kif_compare)

int
kif_init(void)
{
	RB_INIT(&kit);

	if (fetchifs(0) == -1)
		return (-1);

	return (0);
}

int
kr_init(int fs, u_int rdomain)
{
	int		opt = 0, rcvbuf, default_rcvbuf;
	socklen_t	optlen;

	if ((kr_state.fd = socket(AF_ROUTE,
	    SOCK_RAW | SOCK_CLOEXEC | SOCK_NONBLOCK, 0)) == -1) {
		log_warn("kr_init: socket");
		return (-1);
	}

	/* not interested in my own messages */
	if (setsockopt(kr_state.fd, SOL_SOCKET, SO_USELOOPBACK,
	    &opt, sizeof(opt)) == -1)
		log_warn("kr_init: setsockopt");	/* not fatal */

	/* grow receive buffer, don't wanna miss messages */
	optlen = sizeof(default_rcvbuf);
	if (getsockopt(kr_state.fd, SOL_SOCKET, SO_RCVBUF,
	    &default_rcvbuf, &optlen) == -1)
		log_warn("kr_init getsockopt SOL_SOCKET SO_RCVBUF");
	else
		for (rcvbuf = MAX_RTSOCK_BUF;
		    rcvbuf > default_rcvbuf &&
		    setsockopt(kr_state.fd, SOL_SOCKET, SO_RCVBUF,
		    &rcvbuf, sizeof(rcvbuf)) == -1 && errno == ENOBUFS;
		    rcvbuf /= 2)
			;	/* nothing */

	kr_state.pid = getpid();
	kr_state.rtseq = 1;

	RB_INIT(&krt);

	if (fetchtable() == -1)
		return (-1);

	if (protect_lo() == -1)
		return (-1);

	kr_state.fib_sync = fs; /* now set correct sync mode */
	kr_state.rdomain = rdomain;

	event_set(&kr_state.ev, kr_state.fd, EV_READ | EV_PERSIST,
	    kr_dispatch_msg, NULL);
	event_add(&kr_state.ev, NULL);

	return (0);
}

int
kr_change_fib(struct kroute_node *kr, struct kroute *kroute, int action)
{
	/* nexthop within 127/8 -> ignore silently */
	if ((kroute->nexthop.s_addr & htonl(IN_CLASSA_NET)) ==
	    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
		return (0);

	if (send_rtmsg(kr_state.fd, action, kroute) == -1)
		return (-1);

	if (action == RTM_ADD) {
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL)
			fatal("kr_change_fib");

		kr->r.prefix.s_addr = kroute->prefix.s_addr;
		kr->r.netmask.s_addr = kroute->netmask.s_addr;
		kr->r.nexthop.s_addr = kroute->nexthop.s_addr;
		kr->r.flags = kroute->flags |= F_RIPD_INSERTED;
		kr->r.priority = RTP_RIP;

		if (kroute_insert(kr) == -1) {
			log_debug("kr_update_fib: cannot insert %s",
			    inet_ntoa(kr->r.nexthop));
			free(kr);
		}
	} else
		kr->r.nexthop.s_addr = kroute->nexthop.s_addr;

	return (0);
}

int
kr_change(struct kroute *kroute)
{
	struct kroute_node	*kr;
	int			 action = RTM_ADD;

	kr = kroute_find(kroute->prefix.s_addr, kroute->netmask.s_addr,
	    RTP_RIP);
	if (kr != NULL)
		action = RTM_CHANGE;

	return (kr_change_fib(kr, kroute, action));
}

int
kr_delete(struct kroute *kroute)
{
	struct kroute_node	*kr;

	kr = kroute_find(kroute->prefix.s_addr, kroute->netmask.s_addr,
	    RTP_RIP);
	if (kr == NULL)
		return (0);

	if (kr->r.priority != RTP_RIP)
		log_warn("kr_delete_fib: %s/%d has wrong priority %d",
		    inet_ntoa(kr->r.prefix), mask2prefixlen(kr->r.netmask.s_addr),
		    kr->r.priority);

	if (send_rtmsg(kr_state.fd, RTM_DELETE, kroute) == -1)
		return (-1);

	if (kroute_remove(kr) == -1)
		return (-1);

	return (0);
}

void
kr_shutdown(void)
{
	kr_fib_decouple();

	kroute_clear();
	kif_clear();
}

void
kr_fib_couple(void)
{
	struct kroute_node	*kr;

	if (kr_state.fib_sync == 1)	/* already coupled */
		return;

	kr_state.fib_sync = 1;

	RB_FOREACH(kr, kroute_tree, &krt)
		if (kr->r.priority == RTP_RIP)
			send_rtmsg(kr_state.fd, RTM_ADD, &kr->r);

	log_info("kernel routing table coupled");
}

void
kr_fib_decouple(void)
{
	struct kroute_node	*kr;

	if (kr_state.fib_sync == 0)	/* already decoupled */
		return;

	RB_FOREACH(kr, kroute_tree, &krt)
		if (kr->r.priority == RTP_RIP)
			send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);

	kr_state.fib_sync = 0;

	log_info("kernel routing table decoupled");
}

/* ARGSUSED */
void
kr_dispatch_msg(int fd, short event, void *bula)
{
	dispatch_rtmsg();
}

void
kr_show_route(struct imsg *imsg)
{
	struct kroute_node	*kr;
	int			 flags;
	struct in_addr		 addr;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
		if (imsg->hdr.len != IMSG_HEADER_SIZE + sizeof(flags)) {
			log_warnx("kr_show_route: wrong imsg len");
			return;
		}
		memcpy(&flags, imsg->data, sizeof(flags));
		RB_FOREACH(kr, kroute_tree, &krt)
			if (!flags || kr->r.flags & flags) {
				main_imsg_compose_ripe(IMSG_CTL_KROUTE,
				    imsg->hdr.pid, &kr->r, sizeof(kr->r));
			}
		break;
	case IMSG_CTL_KROUTE_ADDR:
		if (imsg->hdr.len != IMSG_HEADER_SIZE +
		    sizeof(struct in_addr)) {
			log_warnx("kr_show_route: wrong imsg len");
			return;
		}
		memcpy(&addr, imsg->data, sizeof(addr));
		kr = NULL;
		kr = kroute_match(addr.s_addr);
		if (kr != NULL)
			main_imsg_compose_ripe(IMSG_CTL_KROUTE, imsg->hdr.pid,
			    &kr->r, sizeof(kr->r));
		break;
	default:
		log_debug("kr_show_route: error handling imsg");
		break;
	}

	main_imsg_compose_ripe(IMSG_CTL_END, imsg->hdr.pid, NULL, 0);
}

void
kr_ifinfo(char *ifname, pid_t pid)
{
	struct kif_node	*kif;

	RB_FOREACH(kif, kif_tree, &kit)
		if (ifname == NULL || !strcmp(ifname, kif->k.ifname)) {
			main_imsg_compose_ripe(IMSG_CTL_IFINFO,
			    pid, &kif->k, sizeof(kif->k));
		}

	main_imsg_compose_ripe(IMSG_CTL_END, pid, NULL, 0);
}

void
kr_redistribute(int type, struct kroute *kr)
{
	u_int32_t	a;


	if (type == IMSG_NETWORK_DEL) {
dont_redistribute:
		/* was the route redistributed? */
		if (kr->flags & F_REDISTRIBUTED) {
			/* remove redistributed flag */
			kr->flags &= ~F_REDISTRIBUTED;
			main_imsg_compose_rde(type, 0, kr,
			    sizeof(struct kroute));
		}
		return;
	}

	/* interface is not up and running so don't announce */
	if (kr->flags & F_DOWN)
		return;

	/*
	 * We consider the loopback net, multicast and experimental addresses
	 * as not redistributable.
	 */
	a = ntohl(kr->prefix.s_addr);
	if (IN_MULTICAST(a) || IN_BADCLASS(a) ||
	    (a >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
		return;
	/*
	 * Consider networks with nexthop loopback as not redistributable
	 * unless it is a reject or blackhole route.
	 */
	if (kr->nexthop.s_addr == htonl(INADDR_LOOPBACK) &&
	    !(kr->flags & (F_BLACKHOLE|F_REJECT)))
		return;

	/* Should we redistribute this route? */
	if (!rip_redistribute(kr))
		goto dont_redistribute;

	/* Does not matter if we resend the kr, the RDE will cope. */
	kr->flags |= F_REDISTRIBUTED;
	main_imsg_compose_rde(type, 0, kr, sizeof(struct kroute));
}

/* rb-tree compare */
int
kroute_compare(struct kroute_node *a, struct kroute_node *b)
{
	if (ntohl(a->r.prefix.s_addr) < ntohl(b->r.prefix.s_addr))
		return (-1);
	if (ntohl(a->r.prefix.s_addr) > ntohl(b->r.prefix.s_addr))
		return (1);
	if (ntohl(a->r.netmask.s_addr) < ntohl(b->r.netmask.s_addr))
		return (-1);
	if (ntohl(a->r.netmask.s_addr) > ntohl(b->r.netmask.s_addr))
		return (1);

	/* if the priority is RTP_ANY finish on the first address hit */
	if (a->r.priority == RTP_ANY || b->r.priority == RTP_ANY)
		return (0);
	if (a->r.priority < b->r.priority)
		return (-1);
	if (a->r.priority > b->r.priority)
		return (1);

	return (0);
}

int
kif_compare(struct kif_node *a, struct kif_node *b)
{
	return (b->k.ifindex - a->k.ifindex);
}

/* tree management */
struct kroute_node *
kroute_find(in_addr_t prefix, in_addr_t netmask, u_int8_t prio)
{
	struct kroute_node	s, *kn, *tmp;

	s.r.prefix.s_addr = prefix;
	s.r.netmask.s_addr = netmask;
	s.r.priority = prio;

	kn = RB_FIND(kroute_tree, &krt, &s);
	if (kn && prio == RTP_ANY) {
		tmp = RB_PREV(kroute_tree, &krt, kn);
		while (tmp) {
			if (kroute_compare(&s, tmp) == 0)
				kn = tmp;
			else
				break;
			tmp = RB_PREV(kroute_tree, &krt, kn);
		}
	}

	return (kn);
}

int
kroute_insert(struct kroute_node *kr)
{
	if (RB_INSERT(kroute_tree, &krt, kr) != NULL) {
		log_warnx("kroute_insert failed for %s/%u",
		    inet_ntoa(kr->r.prefix),
		    mask2prefixlen(kr->r.netmask.s_addr));
		free(kr);
		return (-1);
	}

	if (!(kr->r.flags & F_KERNEL)) {
		/* don't validate or redistribute rip route */
		kr->r.flags &= ~F_DOWN;
		return (0);
	}

	if (kif_validate(kr->r.ifindex))
		kr->r.flags &= ~F_DOWN;
	else
		kr->r.flags |= F_DOWN;

	kr_redistribute(IMSG_NETWORK_ADD, &kr->r);

	return (0);
}

int
kroute_remove(struct kroute_node *kr)
{
	if (RB_REMOVE(kroute_tree, &krt, kr) == NULL) {
		log_warnx("kroute_remove failed for %s/%u",
		    inet_ntoa(kr->r.prefix),
		    mask2prefixlen(kr->r.netmask.s_addr));
		return (-1);
	}

	kr_redistribute(IMSG_NETWORK_DEL, &kr->r);
	rtlabel_unref(kr->r.rtlabel);

	free(kr);
	return (0);
}

void
kroute_clear(void)
{
	struct kroute_node	*kr;

	while ((kr = RB_MIN(kroute_tree, &krt)) != NULL)
		kroute_remove(kr);
}

struct kif_node *
kif_find(int ifindex)
{
	struct kif_node	s;

	bzero(&s, sizeof(s));
	s.k.ifindex = ifindex;

	return (RB_FIND(kif_tree, &kit, &s));
}

struct kif *
kif_findname(char *ifname)
{
	struct kif_node	*kif;

	RB_FOREACH(kif, kif_tree, &kit)
		if (!strcmp(ifname, kif->k.ifname))
			return (&kif->k);

	return (NULL);
}

int
kif_insert(struct kif_node *kif)
{
	if (RB_INSERT(kif_tree, &kit, kif) != NULL) {
		log_warnx("RB_INSERT(kif_tree, &kit, kif)");
		free(kif);
		return (-1);
	}

	return (0);
}

int
kif_remove(struct kif_node *kif)
{
	if (RB_REMOVE(kif_tree, &kit, kif) == NULL) {
		log_warnx("RB_REMOVE(kif_tree, &kit, kif)");
		return (-1);
	}

	free(kif);
	return (0);
}

void
kif_clear(void)
{
	struct kif_node	*kif;

	while ((kif = RB_MIN(kif_tree, &kit)) != NULL)
		kif_remove(kif);
}

int
kif_validate(int ifindex)
{
	struct kif_node		*kif;

	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("interface with index %u not found", ifindex);
		return (1);
	}

	return (kif->k.nh_reachable);
}

struct kroute_node *
kroute_match(in_addr_t key)
{
	u_int8_t		 i;
	struct kroute_node	*kr;

	/* we will never match the default route */
	for (i = 32; i > 0; i--)
		if ((kr = kroute_find(key & prefixlen2mask(i),
		    prefixlen2mask(i), RTP_ANY)) != NULL)
			return (kr);

	/* if we don't have a match yet, try to find a default route */
	if ((kr = kroute_find(0, 0, RTP_ANY)) != NULL)
			return (kr);

	return (NULL);
}

/* misc */
int
protect_lo(void)
{
	struct kroute_node	*kr;

	/* special protection for 127/8 */
	if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
		log_warn("protect_lo");
		return (-1);
	}
	kr->r.prefix.s_addr = htonl(INADDR_LOOPBACK);
	kr->r.netmask.s_addr = htonl(IN_CLASSA_NET);
	kr->r.flags = F_KERNEL|F_CONNECTED;

	if (RB_INSERT(kroute_tree, &krt, kr) != NULL)
		free(kr);	/* kernel route already there, no problem */

	return (0);
}

u_int8_t
prefixlen_classful(in_addr_t ina)
{
	/* it hurt to write this. */

	if (ina >= 0xf0000000U)		/* class E */
		return (32);
	else if (ina >= 0xe0000000U)	/* class D */
		return (4);
	else if (ina >= 0xc0000000U)	/* class C */
		return (24);
	else if (ina >= 0x80000000U)	/* class B */
		return (16);
	else				/* class A */
		return (8);
}

u_int8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

in_addr_t
prefixlen2mask(u_int8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	return (htonl(0xffffffff << (32 - prefixlen)));
}

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))

void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		} else
			rti_info[i] = NULL;
	}
}

void
if_change(u_short ifindex, int flags, struct if_data *ifd)
{
	struct kif_node		*kif;
	struct kroute_node	*kr;
	int			 type;
	u_int8_t		 reachable;

	if ((kif = kif_find(ifindex)) == NULL) {
		log_warnx("interface with index %u not found", ifindex);
		return;
	}

	kif->k.flags = flags;
	kif->k.link_state = ifd->ifi_link_state;
	kif->k.if_type = ifd->ifi_type;
	kif->k.baudrate = ifd->ifi_baudrate;

	if ((reachable = (flags & IFF_UP) &&
	    LINK_STATE_IS_UP(ifd->ifi_link_state)) == kif->k.nh_reachable)
		return;		/* nothing changed wrt nexthop validity */

	kif->k.nh_reachable = reachable;
	type = reachable ? IMSG_NETWORK_ADD : IMSG_NETWORK_DEL;

	/* notify ripe about interface link state */
	main_imsg_compose_ripe(IMSG_IFINFO, 0, &kif->k, sizeof(kif->k));

	/* update redistribute list */
	RB_FOREACH(kr, kroute_tree, &krt)
		if (kr->r.ifindex == ifindex) {
			if (reachable)
				kr->r.flags &= ~F_DOWN;
			else
				kr->r.flags |= F_DOWN;

			kr_redistribute(type, &kr->r);
		}
}

void
if_announce(void *msg)
{
	struct if_announcemsghdr	*ifan;
	struct kif_node			*kif;

	ifan = msg;

	switch (ifan->ifan_what) {
	case IFAN_ARRIVAL:
		if ((kif = calloc(1, sizeof(struct kif_node))) == NULL) {
			log_warn("if_announce");
			return;
		}

		kif->k.ifindex = ifan->ifan_index;
		strlcpy(kif->k.ifname, ifan->ifan_name, sizeof(kif->k.ifname));
		kif_insert(kif);
		break;
	case IFAN_DEPARTURE:
		kif = kif_find(ifan->ifan_index);
		kif_remove(kif);
		break;
	}
}

/* rtsock */
int
send_rtmsg(int fd, int action, struct kroute *kroute)
{
	struct iovec		iov[4];
	struct rt_msghdr	hdr;
	struct sockaddr_in	prefix;
	struct sockaddr_in	nexthop;
	struct sockaddr_in	mask;
	int			iovcnt = 0;

	if (kr_state.fib_sync == 0)
		return (0);

	/* initialize header */
	bzero(&hdr, sizeof(hdr));
	hdr.rtm_version = RTM_VERSION;
	hdr.rtm_type = action;
	hdr.rtm_priority = RTP_RIP;
	hdr.rtm_tableid = kr_state.rdomain;
	if (action == RTM_CHANGE)
		hdr.rtm_fmask = RTF_REJECT|RTF_BLACKHOLE;
	hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	hdr.rtm_msglen = sizeof(hdr);
	/* adjust iovec */
	iov[iovcnt].iov_base = &hdr;
	iov[iovcnt++].iov_len = sizeof(hdr);

	bzero(&prefix, sizeof(prefix));
	prefix.sin_len = sizeof(prefix);
	prefix.sin_family = AF_INET;
	prefix.sin_addr.s_addr = kroute->prefix.s_addr;
	/* adjust header */
	hdr.rtm_addrs |= RTA_DST;
	hdr.rtm_msglen += sizeof(prefix);
	/* adjust iovec */
	iov[iovcnt].iov_base = &prefix;
	iov[iovcnt++].iov_len = sizeof(prefix);

	if (kroute->nexthop.s_addr != 0) {
		bzero(&nexthop, sizeof(nexthop));
		nexthop.sin_len = sizeof(nexthop);
		nexthop.sin_family = AF_INET;
		nexthop.sin_addr.s_addr = kroute->nexthop.s_addr;
		/* adjust header */
		hdr.rtm_flags |= RTF_GATEWAY;
		hdr.rtm_addrs |= RTA_GATEWAY;
		hdr.rtm_msglen += sizeof(nexthop);
		/* adjust iovec */
		iov[iovcnt].iov_base = &nexthop;
		iov[iovcnt++].iov_len = sizeof(nexthop);
	}

	bzero(&mask, sizeof(mask));
	mask.sin_len = sizeof(mask);
	mask.sin_family = AF_INET;
	mask.sin_addr.s_addr = kroute->netmask.s_addr;
	/* adjust header */
	hdr.rtm_addrs |= RTA_NETMASK;
	hdr.rtm_msglen += sizeof(mask);
	/* adjust iovec */
	iov[iovcnt].iov_base = &mask;
	iov[iovcnt++].iov_len = sizeof(mask);


retry:
	if (writev(fd, iov, iovcnt) == -1) {
		if (errno == ESRCH) {
			if (hdr.rtm_type == RTM_CHANGE) {
				hdr.rtm_type = RTM_ADD;
				goto retry;
			} else if (hdr.rtm_type == RTM_DELETE) {
				log_info("route %s/%u vanished before delete",
				    inet_ntoa(kroute->prefix),
				    mask2prefixlen(kroute->netmask.s_addr));
				return (0);
			}
		}
		log_warn("send_rtmsg: action %u, prefix %s/%u",
		    hdr.rtm_type, inet_ntoa(kroute->prefix),
		    mask2prefixlen(kroute->netmask.s_addr));
		return (0);
	}

	return (0);
}

int
fetchtable(void)
{
	size_t			 len;
	int			 mib[7];
	char			*buf, *next, *lim;
	struct rt_msghdr	*rtm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct sockaddr_rtlabel	*label;
	struct kroute_node	*kr;
	struct iface		*iface = NULL;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_DUMP;
	mib[5] = 0;
	mib[6] = kr_state.rdomain;	/* rtableid */

	if (sysctl(mib, 7, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchtable");
		return (-1);
	}
	if (sysctl(mib, 7, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	lim = buf + len;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (rtm->rtm_version != RTM_VERSION)
			continue;
		sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
		get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

		if ((sa = rti_info[RTAX_DST]) == NULL)
			continue;

		/* Skip ARP/ND cache and broadcast routes. */
		if (rtm->rtm_flags & (RTF_LLINFO|RTF_BROADCAST))
			continue;

#ifdef RTF_MPATH
		if (rtm->rtm_flags & RTF_MPATH)		/* multipath */
			continue;
#endif

		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("fetchtable");
			free(buf);
			return (-1);
		}

		kr->r.flags = F_KERNEL;
		kr->r.priority = rtm->rtm_priority;

		switch (sa->sa_family) {
		case AF_INET:
			kr->r.prefix.s_addr =
			    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
			sa_in = (struct sockaddr_in *)rti_info[RTAX_NETMASK];
			if (rtm->rtm_flags & RTF_STATIC)
				kr->r.flags |= F_STATIC;
			if (rtm->rtm_flags & RTF_BLACKHOLE)
				kr->r.flags |= F_BLACKHOLE;
			if (rtm->rtm_flags & RTF_REJECT)
				kr->r.flags |= F_REJECT;
			if (rtm->rtm_flags & RTF_DYNAMIC)
				kr->r.flags |= F_DYNAMIC;
			if (sa_in != NULL) {
				if (sa_in->sin_len == 0)
					break;
				kr->r.netmask.s_addr =
				    sa_in->sin_addr.s_addr;
			} else if (rtm->rtm_flags & RTF_HOST)
				kr->r.netmask.s_addr = prefixlen2mask(32);
			else
				kr->r.netmask.s_addr =
				    prefixlen2mask(prefixlen_classful
					(kr->r.prefix.s_addr));
			break;
		default:
			free(kr);
			continue;
		}

		kr->r.ifindex = rtm->rtm_index;

		iface = if_find_index(rtm->rtm_index);
		if (iface != NULL)
			kr->r.metric = iface->cost;
		else
			kr->r.metric = DEFAULT_COST;

		if ((sa = rti_info[RTAX_GATEWAY]) != NULL)
			switch (sa->sa_family) {
			case AF_INET:
				if (rtm->rtm_flags & RTF_CONNECTED) {
					kr->r.flags |= F_CONNECTED;
					break;
				}

				kr->r.nexthop.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				break;
			case AF_LINK:
				/*
				 * Traditional BSD connected routes have
				 * a gateway of type AF_LINK.
				 */
				kr->r.flags |= F_CONNECTED;
				break;
			}

		if (rtm->rtm_priority == RTP_RIP) {
			send_rtmsg(kr_state.fd, RTM_DELETE, &kr->r);
			free(kr);
		} else {
			if ((label = (struct sockaddr_rtlabel *)
			    rti_info[RTAX_LABEL]) != NULL)
				kr->r.rtlabel =
				    rtlabel_name2id(label->sr_label);
			kroute_insert(kr);
		}

	}
	free(buf);
	return (0);
}

int
fetchifs(int ifindex)
{
	size_t			 len;
	int			 mib[6];
	char			*buf, *next, *lim;
	struct if_msghdr	 ifm;
	struct kif_node		*kif;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_dl	*sdl;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_IFLIST;
	mib[5] = ifindex;

	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		return (-1);
	}
	if ((buf = malloc(len)) == NULL) {
		log_warn("fetchif");
		return (-1);
	}
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
		log_warn("sysctl");
		free(buf);
		return (-1);
	}

	lim = buf + len;
	for (next = buf; next < lim; next += ifm.ifm_msglen) {
		memcpy(&ifm, next, sizeof(ifm));
		if (ifm.ifm_version != RTM_VERSION)
			continue;
		if (ifm.ifm_type != RTM_IFINFO)
			continue;

		sa = (struct sockaddr *)(next + sizeof(ifm));
		get_rtaddrs(ifm.ifm_addrs, sa, rti_info);

		if ((kif = calloc(1, sizeof(struct kif_node))) == NULL) {
			log_warn("fetchifs");
			free(buf);
			return (-1);
		}

		kif->k.ifindex = ifm.ifm_index;
		kif->k.flags = ifm.ifm_flags;
		kif->k.link_state = ifm.ifm_data.ifi_link_state;
		kif->k.if_type = ifm.ifm_data.ifi_type;
		kif->k.baudrate = ifm.ifm_data.ifi_baudrate;
		kif->k.mtu = ifm.ifm_data.ifi_mtu;
		kif->k.nh_reachable = (kif->k.flags & IFF_UP) &&
		    LINK_STATE_IS_UP(ifm.ifm_data.ifi_link_state);
		if ((sa = rti_info[RTAX_IFP]) != NULL)
			if (sa->sa_family == AF_LINK) {
				sdl = (struct sockaddr_dl *)sa;
				if (sdl->sdl_nlen >= sizeof(kif->k.ifname))
					memcpy(kif->k.ifname, sdl->sdl_data,
					    sizeof(kif->k.ifname) - 1);
				else if (sdl->sdl_nlen > 0)
					memcpy(kif->k.ifname, sdl->sdl_data,
					    sdl->sdl_nlen);
				/* string already terminated via calloc() */
			}

		kif_insert(kif);
	}
	free(buf);
	return (0);
}

int
dispatch_rtmsg(void)
{
	char			 buf[RT_BUF_SIZE];
	ssize_t			 n;
	char			*next, *lim;
	struct rt_msghdr	*rtm;
	struct if_msghdr	 ifm;
	struct sockaddr		*sa, *rti_info[RTAX_MAX];
	struct sockaddr_in	*sa_in;
	struct sockaddr_rtlabel	*label;
	struct kroute_node	*kr;
	struct in_addr		 prefix, nexthop, netmask;
	struct iface		*iface = NULL;
	int			 flags;
	u_short			 ifindex = 0;
	u_int8_t		 metric, prio;

	if ((n = read(kr_state.fd, &buf, sizeof(buf))) == -1) {
		if (errno == EAGAIN || errno == EINTR)
			return (0);
		log_warn("dispatch_rtmsg: read error");
		return (-1);
	}

	if (n == 0) {
		log_warnx("routing socket closed");
		return (-1);
	}

	lim = buf + n;
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		if (lim < next + sizeof(u_short) ||
		    lim < next + rtm->rtm_msglen)
			fatalx("dispatch_rtmsg: partial rtm in buffer");
		if (rtm->rtm_version != RTM_VERSION)
			continue;

		prefix.s_addr = 0;
		netmask.s_addr = 0;
		flags = F_KERNEL;
		nexthop.s_addr = 0;
		prio = 0;

		if (rtm->rtm_type == RTM_ADD || rtm->rtm_type == RTM_CHANGE ||
		    rtm->rtm_type == RTM_DELETE) {
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

			if (rtm->rtm_tableid != kr_state.rdomain)
				continue;

			if (rtm->rtm_pid == kr_state.pid)	/* cause by us */
				continue;

			if (rtm->rtm_errno)			/* failed attempts... */
				continue;

			/* Skip ARP/ND cache and broadcast routes. */
			if (rtm->rtm_flags & (RTF_LLINFO|RTF_BROADCAST))
				continue;

			prio = rtm->rtm_priority;

			switch (sa->sa_family) {
			case AF_INET:
				prefix.s_addr =
				    ((struct sockaddr_in *)sa)->sin_addr.s_addr;
				sa_in = (struct sockaddr_in *)
				    rti_info[RTAX_NETMASK];
				if (sa_in != NULL) {
					if (sa_in->sin_len != 0)
						netmask.s_addr =
						    sa_in->sin_addr.s_addr;
				} else if (rtm->rtm_flags & RTF_HOST)
					netmask.s_addr = prefixlen2mask(32);
				else
					netmask.s_addr =
					    prefixlen2mask(prefixlen_classful(
						prefix.s_addr));
				if (rtm->rtm_flags & RTF_STATIC)
					flags |= F_STATIC;
				if (rtm->rtm_flags & RTF_BLACKHOLE)
					flags |= F_BLACKHOLE;
				if (rtm->rtm_flags & RTF_REJECT)
					flags |= F_REJECT;
				if (rtm->rtm_flags & RTF_DYNAMIC)
					flags |= F_DYNAMIC;
				break;
			default:
				continue;
			}

			ifindex = rtm->rtm_index;
			if ((sa = rti_info[RTAX_GATEWAY]) != NULL) {
				switch (sa->sa_family) {
				case AF_INET:
					nexthop.s_addr = ((struct
					    sockaddr_in *)sa)->sin_addr.s_addr;
					break;
				case AF_LINK:
					flags |= F_CONNECTED;
					break;
				}
			}
		}

		switch (rtm->rtm_type) {
		case RTM_ADD:
		case RTM_CHANGE:
			if (nexthop.s_addr == 0 && !(flags & F_CONNECTED)) {
				log_warnx("dispatch_rtmsg no nexthop for %s/%u",
				    inet_ntoa(prefix),
				    mask2prefixlen(netmask.s_addr));
				continue;
			}

			if ((kr = kroute_find(prefix.s_addr, netmask.s_addr,
			    prio)) != NULL) {
				if (kr->r.flags & F_REDISTRIBUTED)
					flags |= F_REDISTRIBUTED;
				kr->r.nexthop.s_addr = nexthop.s_addr;
				kr->r.flags = flags;
				kr->r.ifindex = ifindex;
				kr->r.priority = prio;

				rtlabel_unref(kr->r.rtlabel);
				kr->r.rtlabel = 0;
				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL)
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);

				if (kif_validate(kr->r.ifindex))
					kr->r.flags &= ~F_DOWN;
				else
					kr->r.flags |= F_DOWN;

				/* just readd, the RDE will care */
				kr_redistribute(IMSG_NETWORK_ADD, &kr->r);
			} else {
				if ((kr = calloc(1,
				    sizeof(struct kroute_node))) == NULL) {
					log_warn("dispatch_rtmsg");
					return (-1);
				}

				iface = if_find_index(rtm->rtm_index);
				if (iface != NULL)
					metric = iface->cost;
				else
					metric = DEFAULT_COST;

				kr->r.prefix.s_addr = prefix.s_addr;
				kr->r.netmask.s_addr = netmask.s_addr;
				kr->r.nexthop.s_addr = nexthop.s_addr;
				kr->r.metric = metric;
				kr->r.flags = flags;
				kr->r.ifindex = ifindex;

				if ((label = (struct sockaddr_rtlabel *)
				    rti_info[RTAX_LABEL]) != NULL)
					kr->r.rtlabel =
					    rtlabel_name2id(label->sr_label);

				kroute_insert(kr);
			}
			break;
		case RTM_DELETE:
			if ((kr = kroute_find(prefix.s_addr, netmask.s_addr,
			    prio)) == NULL)
				continue;
			if (!(kr->r.flags & F_KERNEL))
				continue;
			if (kroute_remove(kr) == -1)
				return (-1);
			break;
		case RTM_IFINFO:
			memcpy(&ifm, next, sizeof(ifm));
			if_change(ifm.ifm_index, ifm.ifm_flags,
			    &ifm.ifm_data);
			break;
		case RTM_IFANNOUNCE:
			if_announce(next);
			break;
		default:
			/* ignore for now */
			break;
		}
	}
	return (0);
}
@


1.31
log
@As done for bgpd recently, rename if_mediatype to if_type in ripd.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.30 2015/07/17 20:38:33 claudio Exp $ */
d635 2
a636 2
#define	ROUNDUP(a, size)	\
    (((a) & ((size) - 1)) ? (1 + ((a) | ((size) - 1))) : (a))
d647 1
a647 1
			    ROUNDUP(sa->sa_len, sizeof(long)));
@


1.30
log
@Like bgpd and ospfd filter routes by RTF_LLINFO and RTF_BROADCAST and use
the RTF_CONNECTED to know if a route is connected or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.29 2015/02/11 05:58:08 claudio Exp $ */
d668 1
a668 1
	kif->k.media_type = ifd->ifi_type;
d996 1
a996 1
		kif->k.media_type = ifm.ifm_data.ifi_type;
@


1.29
log
@Use sizeof(u_short) in the first check since there are RT messages that
are less then sizeof(*rtm) bytes long (e.g. interface announcements).
Found the hard way by phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.28 2015/02/10 08:23:13 claudio Exp $ */
d852 2
a853 1
		if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
d911 5
d920 4
d1078 2
a1079 1
			if (rtm->rtm_flags & RTF_LLINFO)	/* arp cache */
@


1.28
log
@Sync kroute code with what we do in ospfd/bgpd (EAGAIN handling).
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.27 2015/02/09 12:34:07 claudio Exp $ */
d1042 1
a1042 1
		if (lim < next + sizeof(*rtm) ||
@


1.27
log
@Add SOCK_CLOEXEC | SOCK_NONBLOCK to two more socket calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.26 2015/01/16 06:40:20 deraadt Exp $ */
d1028 2
d1042 3
@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.25 2014/06/23 03:46:17 guenther Exp $ */
d116 2
a117 1
	if ((kr_state.fd = socket(AF_ROUTE, SOCK_RAW, 0)) == -1) {
@


1.25
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.24 2011/07/04 04:34:14 claudio Exp $ */
a19 1
#include <sys/param.h>
@


1.24
log
@LINK_STATE_IS_UP() cleanup userland part. There is no need to special
case carp(4) interfaces anymore. LINK_STATE_IS_UP() almost always does
the right job.
OK deraadt@@ henning@@

This needs a -current kernel or link state may be not reported correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.23 2011/06/26 19:19:23 claudio Exp $ */
d820 1
a820 1
	mib[1] = AF_ROUTE;
d946 1
a946 1
	mib[1] = AF_ROUTE;
@


1.23
log
@Remove obsolete mcast routes in ldpd and ripd.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.22 2010/07/12 14:35:13 bluhm Exp $ */
d672 1
a672 3
	    (LINK_STATE_IS_UP(ifd->ifi_link_state) ||
	    (ifd->ifi_link_state == LINK_STATE_UNKNOWN &&
	    ifd->ifi_type != IFT_CARP))) == kif->k.nh_reachable)
d990 1
a990 3
		    (LINK_STATE_IS_UP(ifm.ifm_data.ifi_link_state) ||
		    (ifm.ifm_data.ifi_link_state == LINK_STATE_UNKNOWN &&
		    ifm.ifm_data.ifi_type != IFT_CARP));
@


1.22
log
@Merge duplicate log messages into one log_warn().
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.21 2010/01/02 14:40:54 michele Exp $ */
a99 3
struct kroute kr_all_rip_routers;
int	flag_all_rip_routers = 0;

a150 8
	kr_all_rip_routers.prefix.s_addr = inet_addr(ALL_RIP_ROUTERS);
	kr_all_rip_routers.netmask.s_addr = htonl(INADDR_BROADCAST);
	kr_all_rip_routers.nexthop.s_addr = htonl(INADDR_LOOPBACK);

	kr_state.fib_sync = 1; /* force addition of multicast route */
	if (send_rtmsg(kr_state.fd, RTM_ADD, &kr_all_rip_routers) != -1)
		flag_all_rip_routers = 1;

a234 5

	if (flag_all_rip_routers) {
		kr_state.fib_sync = 1; /* force removal of mulitcast route */
		(void)send_rtmsg(kr_state.fd, RTM_DELETE, &kr_all_rip_routers);
	}
@


1.21
log
@Fix comparison between the routing message's priority and RTP_RIP.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.20 2009/09/26 18:24:58 michele Exp $ */
d804 1
a804 2
		switch (errno) {
		case ESRCH:
a812 7
			} else {
				log_warnx("send_rtmsg: action %u, "
				    "prefix %s/%u: %s", hdr.rtm_type,
				    inet_ntoa(kroute->prefix),
				    mask2prefixlen(kroute->netmask.s_addr),
				    strerror(errno));
				return (0);
a813 7
			break;
		default:
			log_warnx("send_rtmsg: action %u, prefix %s/%u: %s",
			    hdr.rtm_type, inet_ntoa(kroute->prefix),
			    mask2prefixlen(kroute->netmask.s_addr),
			    strerror(errno));
			return (0);
d815 4
@


1.20
log
@Preliminary rdomain support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.19 2009/09/24 12:30:36 michele Exp $ */
d947 1
a947 1
		if (rtm->rtm_priority & RTP_RIP) {
@


1.19
log
@Priorities are now handled in the kernel so:

- RTF_PROTO3 is useless
- MPLS routes don't need special treatment anymore, so don't track them at all

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.18 2009/09/18 16:17:02 michele Exp $ */
d50 1
d115 1
a115 1
kr_init(int fs)
d163 1
d756 1
d854 1
a854 1
	mib[6] = 0;	/* rtableid */
d1085 1
a1085 1
			if (rtm->rtm_tableid != 0)
@


1.18
log
@Make kroute code routing priority aware.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.17 2009/07/07 12:07:23 michele Exp $ */
a752 1
	hdr.rtm_flags = RTF_PROTO3;
a1119 2
				if (rtm->rtm_flags & RTF_MPLS)
					flags |= F_LDPD_INSERTED;
@


1.17
log
@Make ripd(8) aware of MPLS routes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.16 2009/06/05 22:40:24 chris Exp $ */
d65 1
d67 1
a67 1
struct kroute_node	*kroute_find(in_addr_t, in_addr_t);
d171 1
a171 1
kr_change(struct kroute *kroute)
a172 27
	struct kroute_node	*kr;
	int			 action = RTM_ADD;

	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->netmask.s_addr)) !=
	    NULL) {
		if (!(kr->r.flags & F_KERNEL))
			action = RTM_CHANGE;
		else {	/* a non-rip route already exists. not a problem */
			if (!(kr->r.flags & (F_BGPD_INSERTED|
			    F_OSPFD_INSERTED|F_LDPD_INSERTED))) {
				kr->r.flags |= F_RIPD_INSERTED;
				return (0);
			}
			/*
			 * rip route has higher pref
			 * - reset flags to the rip ones
			 * - use RTM_CHANGE
			 * - zero out ifindex (this is no longer relevant)
			 */
			action = RTM_CHANGE;
			kr->r.flags = kroute->flags | F_RIPD_INSERTED;
			kr->r.ifindex = 0;
			rtlabel_unref(kr->r.rtlabel);
			kr->r.rtlabel = 0;
		}
	}

d182 3
a184 4
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("kr_change");
			return (-1);
		}
d189 1
d191 3
a193 1
		if (kroute_insert(kr) == -1)
d195 1
d203 14
d221 3
a223 5
	if ((kr = kroute_find(kroute->prefix.s_addr, kroute->netmask.s_addr)) ==
	    NULL)
		return (0);

	if (!(kr->r.flags & F_RIPD_INSERTED))
d226 4
a229 5
	if (kr->r.flags & F_KERNEL) {
		/* remove F_RIPD_INSERTED flag, route still exists in kernel */
		kr->r.flags &= ~F_RIPD_INSERTED;
		return (0);
	}
d265 1
a265 1
		if (!(kr->r.flags & F_KERNEL))
d280 1
a280 1
		if (!(kr->r.flags & F_KERNEL))
d409 9
d429 1
a429 1
kroute_find(in_addr_t prefix, in_addr_t netmask)
d431 1
a431 1
	struct kroute_node	s;
d435 1
d437 13
a449 1
	return (RB_FIND(kroute_tree, &krt, &s));
d583 1
a583 1
		    prefixlen2mask(i))) != NULL)
d587 1
a587 1
	if ((kr = kroute_find(0, 0)) != NULL)
d755 2
a756 3
	if (action == RTM_CHANGE)	/* force PROTO3 reset the other flags */
		hdr.rtm_fmask =
		    RTF_PROTO3|RTF_PROTO2|RTF_PROTO1|RTF_REJECT|RTF_BLACKHOLE;
d894 1
a908 4
			if (rtm->rtm_flags & RTF_PROTO1)
				kr->r.flags |= F_BGPD_INSERTED;
			if (rtm->rtm_flags & RTF_PROTO2)
				kr->r.flags |= F_OSPFD_INSERTED;
d945 1
a945 1
		if (rtm->rtm_flags & RTF_PROTO3) {
d1054 1
a1054 1
	u_int8_t		 metric;
d1076 1
d1095 2
a1120 4
				if (rtm->rtm_flags & RTF_PROTO1)
					flags |= F_BGPD_INSERTED;
				if (rtm->rtm_flags & RTF_PROTO2)
					flags |= F_OSPFD_INSERTED;
d1152 2
a1153 6
			if ((kr = kroute_find(prefix.s_addr, netmask.s_addr)) !=
			    NULL) {
				/* rip route overridden by kernel */
				/* pref is not checked because this is forced */
				if (kr->r.flags & F_RIPD_INSERTED)
					flags |= F_RIPD_INSERTED;
d1159 1
d1204 2
a1205 2
			if ((kr = kroute_find(prefix.s_addr, netmask.s_addr)) ==
			    NULL)
a1208 3
			if (kr->r.flags & F_RIPD_INSERTED)
				main_imsg_compose_rde(IMSG_KROUTE_GET, 0,
				    &kr->r, sizeof(struct kroute));
@


1.16
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.15 2009/06/02 21:43:36 claudio Exp $ */
d181 1
a181 1
			    F_OSPFD_INSERTED))) {
d1116 2
@


1.15
log
@Same reject and blackhole route handling as in ospfd. Allow those routes
to be redistributed even though they point to 127.0.0.1. OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.14 2009/03/31 09:11:45 michele Exp $ */
d864 1
a864 1
		sa = (struct sockaddr *)(rtm + 1);
d1073 1
a1073 1
			sa = (struct sockaddr *)(rtm + 1);
@


1.14
log
@Assign the correct metric to the routes learned from the kernel while ripd is
running.

Issue spotted and diff tested by Steven Surdock.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.13 2008/05/09 12:47:42 henning Exp $ */
d393 2
a394 1
	 * Consider networks with nexthop loopback as not redistributable.
d396 2
a397 1
	if (kr->nexthop.s_addr == htonl(INADDR_LOOPBACK))
d893 4
d1106 4
@


1.13
log
@prio RTP_RIP for inserted routes
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.12 2007/10/24 20:29:30 claudio Exp $ */
d920 1
a920 1
			kr->r.metric = 1;
d1039 1
d1042 1
d1167 7
d1177 1
@


1.12
log
@An u_int8_t is enough as prefixlen. Another lint warning gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.11 2007/10/18 17:00:59 deraadt Exp $ */
d742 1
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.10 2007/10/17 20:18:11 claudio Exp $ */
d565 1
a565 1
	int			 i;
@


1.10
log
@Add missing RTM_VERSION checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.9 2007/04/27 09:20:32 claudio Exp $ */
d932 1
a932 1
		if (rtm->rtm_flags & RTF_PROTO3)  {
@


1.9
log
@Ripd needs a valid route for 224.0.0.9 to work. Instead of forcing users to
set multicast_router=YES we inject a 224.0.0.9/32 route into the kernel and
remove the route on exit if the insert was successful. With this ripd
works out of the box.
OK michele@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.8 2007/04/19 13:54:36 claudio Exp $ */
d859 2
d983 2
d1054 2
@


1.8
log
@Use vectorized writes to send routing messages into the kernel instead of
using a static message structure. Similar diffs went into bgpd and ospfd.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.7 2007/03/19 10:23:42 claudio Exp $ */
d40 1
d98 3
a117 2
	kr_state.fib_sync = fs;

d152 10
d256 6
@


1.7
log
@Doh! If we support "redistribute rtlabel" we should actually track the
routing labels in ripd's kroute code. Just steal the code from ospfd which
does it right.  OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.6 2007/03/13 16:50:58 claudio Exp $ */
d25 1
d709 6
a714 6
	struct {
		struct rt_msghdr	hdr;
		struct sockaddr_in	prefix;
		struct sockaddr_in	nexthop;
		struct sockaddr_in	mask;
	} r;
d719 5
a723 5
	bzero(&r, sizeof(r));
	r.hdr.rtm_msglen = sizeof(r);
	r.hdr.rtm_version = RTM_VERSION;
	r.hdr.rtm_type = action;
	r.hdr.rtm_flags = RTF_PROTO3;
d725 1
a725 1
		r.hdr.rtm_fmask =
d727 42
a768 15
	r.hdr.rtm_seq = kr_state.rtseq++;	/* overflow doesn't matter */
	r.hdr.rtm_addrs = RTA_DST|RTA_GATEWAY|RTA_NETMASK;
	r.prefix.sin_len = sizeof(r.prefix);
	r.prefix.sin_family = AF_INET;
	r.prefix.sin_addr.s_addr = kroute->prefix.s_addr;

	r.nexthop.sin_len = sizeof(r.nexthop);
	r.nexthop.sin_family = AF_INET;
	r.nexthop.sin_addr.s_addr = kroute->nexthop.s_addr;
	if (kroute->nexthop.s_addr != 0)
		r.hdr.rtm_flags |= RTF_GATEWAY;

	r.mask.sin_len = sizeof(r.mask);
	r.mask.sin_family = AF_INET;
	r.mask.sin_addr.s_addr = kroute->netmask.s_addr;
d771 1
a771 1
	if (write(fd, &r, sizeof(r)) == -1) {
d774 2
a775 2
			if (r.hdr.rtm_type == RTM_CHANGE) {
				r.hdr.rtm_type = RTM_ADD;
d777 1
a777 1
			} else if (r.hdr.rtm_type == RTM_DELETE) {
d784 1
a784 1
				    "prefix %s/%u: %s", r.hdr.rtm_type,
d793 1
a793 1
			    r.hdr.rtm_type, inet_ntoa(kroute->prefix),
@


1.6
log
@Same problem as in ospfd's kroute.c don't check rtm_tableid without verifying
that rtm_type is one of RTM_ADD, RTM_CHANGE or RTM_DELETE.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.5 2006/11/28 19:21:15 reyk Exp $ */
d181 2
d459 1
d784 1
d887 5
a891 1
		} else
d893 1
d985 1
d1092 7
d1117 5
@


1.5
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.4 2006/11/28 16:36:58 henning Exp $ */
a999 3
		if (rtm->rtm_tableid != 0)
			continue;

d1004 3
@


1.5.2.1
log
@From claudio@@
> ospfd and ripd a re busted in 4.1 because the are unable to track
> linkstates. This was fixed in 1.43 of ospfd/kroute.c and 1.6 of
> ripd/kroute.c.
>
> revision 1.43
> date: 2007/03/13 16:48:03;  author: claudio;  state: Exp;  lines: +4 -4
> rtm_tableid is only valid for RTM_ADD, RTM_CHANGE and RTM_DELETE but not
> for stuff like RTM_IFINFO or RTM_IFANNOUNCE. So move check to a save
> location.
> Always check rtm_type before accessing some random value inside the route
> message.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.5 2006/11/28 19:21:15 reyk Exp $ */
d1000 3
a1006 3

			if (rtm->rtm_tableid != 0)
				continue;
@


1.4
log
@mib we pass to sysctl when fetching the routing table has 7 entries now,
not 6 any more (rtableid added). need to tell sysctl so.
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.3 2006/11/16 15:56:26 henning Exp $ */
d652 1
a652 1
	    (ifd->ifi_link_state == LINK_STATE_UP ||
d945 1
a945 1
		    (ifm.ifm_data.ifi_link_state == LINK_STATE_UP ||
@


1.3
log
@ignore messages for alternate routing tables for now; from bgpd
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.2 2006/10/24 16:37:48 david Exp $ */
d792 1
a792 1
	if (sysctl(mib, 6, NULL, &len, NULL, 0) == -1) {
d800 1
a800 1
	if (sysctl(mib, 6, buf, &len, NULL, 0) == -1) {
@


1.2
log
@spelling and typo fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: kroute.c,v 1.1 2006/10/18 16:11:58 norby Exp $ */
d776 1
a776 1
	int			 mib[6];
d790 1
d999 3
@


1.1
log
@Welcome ripd
started by Michele Marchetto some time ago by using the imsg/three process framework
of ospfd. He implemented most of the daemon with a little help and guidance from
Claudio and I.

Currently the daemon is more or less complete, with the exception of key lifetime
and rollover.

Not yet connected to the builds.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d377 1
a377 1
	/* Should we redistrubute this route? */
@

