head	1.37;
access;
symbols
	OPENBSD_6_2:1.37.0.6
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.37.0.4
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.34.0.4
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.31.0.6
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.12
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.10
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.8
	OPENBSD_5_0:1.28.0.6
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.4
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.37
date	2017.01.05.13.53.09;	author krw;	state Exp;
branches;
next	1.36;
commitid	3AKCl24jEn0sIt6p;

1.36
date	2017.01.05.12.42.19;	author krw;	state Exp;
branches;
next	1.35;
commitid	uzjOUwLRoN7KbcZI;

1.35
date	2016.06.21.21.35.25;	author benno;	state Exp;
branches;
next	1.34;
commitid	AL6SnrmnHkmPOpjv;

1.34
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.33;
commitid	3Z7yItGpFsmshk0c;

1.33
date	2014.11.03.20.15.31;	author bluhm;	state Exp;
branches;
next	1.32;
commitid	ziMZlrkCPhUaYhzj;

1.32
date	2014.11.03.03.42.12;	author doug;	state Exp;
branches;
next	1.31;
commitid	uiZmdZeIp1Ogo5tH;

1.31
date	2014.01.22.00.21.17;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2013.11.25.13.00.27;	author benno;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.06.21.42.40;	author sthen;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.03.18.42.41;	author henning;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.26.18.24.58;	author michele;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.26.11.12.50;	author michele;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.31.16.04.34;	author michele;	state Exp;
branches;
next	1.24;

1.24
date	2009.03.31.21.03.49;	author tobias;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.24.19.26.13;	author michele;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.04.22.59.28;	author michele;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.17.14.19.39;	author michele;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.17.13.02.55;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.27.15.36.42;	author mpf;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.26.10.09.58;	author mpf;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.24.19.50.33;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.20.13.26.50;	author pyr;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.18.17.00.59;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.18.09.47.57;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.16.20.01.23;	author mpf;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.13.16.35.22;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.11.14.39.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.11.23.06.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.11.22.15.17;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.15.18.23.43;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.08.13.01.10;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.25.20.01.49;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.25.20.01.02;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.24.16.37.48;	author david;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.16.11.58;	author norby;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Replace hand-rolled for(;;) emptying of 'symhead' TAILQ with more
modern TAILQ_FOREACH_SAFE().

No intentional functional change.

ok millert@@ bluhm@@ gilles@@
@
text
@/*	$OpenBSD: parse.y,v 1.36 2017/01/05 12:42:19 krw Exp $ */

/*
 * Copyright (c) 2006 Michele Marchetto <mydecay@@openbeer.it>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <unistd.h>
#include <ifaddrs.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>

#include "ripd.h"
#include "rip.h"
#include "ripe.h"
#include "log.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

static struct {
	u_int8_t		 auth_key[MAX_SIMPLE_AUTH_LEN];
	struct auth_md_head	 md_list;
	enum auth_type		 auth_type;
	u_int8_t		 auth_keyid;
	u_int8_t		 cost;
} *defs, globaldefs, ifacedefs;

struct iface	*iface = NULL;
static struct ripd_conf	*conf;
static int		 errors = 0;

struct iface	*conf_get_if(struct kif *);
void		 clear_config(struct ripd_conf *);
int		 check_file_secrecy(int, const char *);
u_int32_t	 get_rtr_id(void);
int		 host(const char *, struct in_addr *, struct in_addr *);

typedef struct {
	union {
		int64_t		 number;
		char		*string;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	SPLIT_HORIZON TRIGGERED_UPDATES FIBUPDATE REDISTRIBUTE RDOMAIN
%token	AUTHKEY AUTHTYPE AUTHMD AUTHMDKEYID
%token	INTERFACE RTLABEL
%token	COST PASSIVE
%token	YES NO
%token	DEMOTE
%token	ERROR
%token	<v.string>	STRING
%token	<v.number>	NUMBER
%type	<v.number>	yesno no
%type	<v.string>	string

%%

grammar		: /* empty */
		| grammar '\n'
		| grammar conf_main '\n'
		| grammar varset '\n'
		| grammar interface '\n'
		| grammar error '\n'		{ file->errors++; }
		;

string		: string STRING {
			if (asprintf(&$$, "%s %s", $1, $2) == -1) {
				free($1);
				free($2);
				yyerror("string: asprintf");
				YYERROR;
			}
			free($1);
			free($2);
		}
		| STRING
		;

yesno		: YES	{ $$ = 1; }
		| NO	{ $$ = 0; }
		;

no		: /* empty */	{ $$ = 0; }
		| NO		{ $$ = 1; }

varset		: STRING '=' string {
			char *s = $1;
			if (conf->opts & RIPD_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				fatal("cannot store variable");
			free($1);
			free($3);
		}
		;

conf_main	: SPLIT_HORIZON STRING {
			/* clean flags first */
			conf->options &= ~(OPT_SPLIT_HORIZON |
			    OPT_SPLIT_POISONED);
			if (!strcmp($2, "none"))
				/* nothing */ ;
			else if (!strcmp($2, "simple"))
				conf->options |= OPT_SPLIT_HORIZON;
			else if (!strcmp($2, "poisoned"))
				conf->options |= OPT_SPLIT_POISONED;
			else {
				yyerror("unknown split horizon type");
				free($2);
				YYERROR;
			}
			free($2);
		}
		| TRIGGERED_UPDATES yesno {
			if ($2 == 1)
				conf->options |= OPT_TRIGGERED_UPDATES;
			else
				conf->options &= ~OPT_TRIGGERED_UPDATES;
		}
		| RDOMAIN NUMBER {
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("invalid rdomain");
				YYERROR;
			}
			conf->rdomain = $2;
		}
		| FIBUPDATE yesno {
			if ($2 == 0)
				conf->flags |= RIPD_FLAG_NO_FIB_UPDATE;
			else
				conf->flags &= ~RIPD_FLAG_NO_FIB_UPDATE;
		}
		| no REDISTRIBUTE STRING {
			struct redistribute	*r;

			if ((r = calloc(1, sizeof(*r))) == NULL)
				fatal(NULL);
			if (!strcmp($3, "static"))
				r->type = REDIST_STATIC;
			else if (!strcmp($3, "connected"))
				r->type = REDIST_CONNECTED;
			else if (!strcmp($3, "default"))
				r->type = REDIST_DEFAULT;
			else if (host($3, &r->addr, &r->mask))
				r->type = REDIST_ADDR;
			else {
				yyerror("unknown redistribute type");
				free($3);
				free(r);
				YYERROR;
			}

			if ($1)
				r->type |= REDIST_NO;

			SIMPLEQ_INSERT_TAIL(&conf->redist_list, r,
			    entry);

			conf->redistribute |= REDISTRIBUTE_ON;
			free($3);
		}
		| no REDISTRIBUTE RTLABEL STRING {
			struct redistribute	*r;

			if ((r = calloc(1, sizeof(*r))) == NULL)
				fatal(NULL);
			r->type = REDIST_LABEL;
			r->label = rtlabel_name2id($4);
			if ($1)
				r->type |= REDIST_NO;
			free($4);

			SIMPLEQ_INSERT_TAIL(&conf->redist_list, r, entry);
			conf->redistribute |= REDISTRIBUTE_ON;
		}
		| defaults
		;

authmd		: AUTHMD NUMBER STRING {
			if ($2 < MIN_MD_ID || $2 > MAX_MD_ID) {
				yyerror("auth-md key-id out of range "
				    "(%d-%d)", MIN_MD_ID, MAX_MD_ID);
				free($3);
				YYERROR;
			}
			if (md_list_add(&defs->md_list, $2, $3) == -1) {
				yyerror("auth-md key length out of range "
				    "(max length %d)", MD5_DIGEST_LENGTH);
				free($3);
				YYERROR;
			}
			free($3);
		}

authmdkeyid	: AUTHMDKEYID NUMBER {
			if ($2 < MIN_MD_ID || $2 > MAX_MD_ID) {
				yyerror("auth-md-keyid out of range "
				    "(%d-%d)", MIN_MD_ID, MAX_MD_ID);
				YYERROR;
			}
			defs->auth_keyid = $2;
		}

authtype	: AUTHTYPE STRING {
			enum auth_type	type;

			if (!strcmp($2, "none"))
				type = AUTH_NONE;
			else if (!strcmp($2, "simple"))
				type = AUTH_SIMPLE;
			else if (!strcmp($2, "crypt"))
				type = AUTH_CRYPT;
			else {
				yyerror("unknown auth-type");
				free($2);
				YYERROR;
			}
			free($2);
			defs->auth_type = type;
		}
		;

authkey		: AUTHKEY STRING {
			if (strlen($2) > MAX_SIMPLE_AUTH_LEN) {
				yyerror("auth-key too long (max length %d)",
				    MAX_SIMPLE_AUTH_LEN);
				free($2);
				YYERROR;
			}
			bzero(defs->auth_key, MAX_SIMPLE_AUTH_LEN);
			memcpy(defs->auth_key, $2, strlen($2));
			free($2);
		}
		;

defaults	: COST NUMBER {
			if ($2 < 1 || $2 > INFINITY) {
				yyerror("cost out of range (%d-%d)", 1,
				    INFINITY);
				YYERROR;
			}
			defs->cost = $2;
		}
		| authtype
		| authkey
		| authmdkeyid
		| authmd
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl
		;

interface	: INTERFACE STRING {
			struct kif *kif;

			if ((kif = kif_findname($2)) == NULL) {
				yyerror("unknown interface %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
			iface = conf_get_if(kif);
			if (iface == NULL)
				YYERROR;
			LIST_INSERT_HEAD(&conf->iface_list, iface, entry);
			memcpy(&ifacedefs, defs, sizeof(ifacedefs));
			md_list_copy(&ifacedefs.md_list, &defs->md_list);
			defs = &ifacedefs;
		} interface_block {
			iface->cost = defs->cost;
			iface->auth_type = defs->auth_type;
			iface->auth_keyid = defs->auth_keyid;
			memcpy(iface->auth_key, defs->auth_key,
			    sizeof(iface->auth_key));
			md_list_copy(&iface->auth_md_list, &defs->md_list);
			md_list_clr(&defs->md_list);
			defs = &globaldefs;
		}
		;

interface_block	: '{' optnl interfaceopts_l '}'
		| '{' optnl '}'
		;

interfaceopts_l	: interfaceopts_l interfaceoptsl nl
		| interfaceoptsl optnl
		;

interfaceoptsl	: PASSIVE		{ iface->passive = 1; }
		| DEMOTE STRING		{
			if (strlcpy(iface->demote_group, $2,
			    sizeof(iface->demote_group)) >=
			    sizeof(iface->demote_group)) {
				yyerror("demote group name \"%s\" too long",
				    $2);
				free($2);
				YYERROR;
			}
			free($2);
			if (carp_demote_init(iface->demote_group,
			    conf->opts & RIPD_OPT_FORCE_DEMOTE) == -1) {
				yyerror("error initializing group \"%s\"",
				    iface->demote_group);
				YYERROR;
			}
		}
		| defaults
		;
%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		fatalx("yyerror vasprintf");
	va_end(ap);
	logit(LOG_CRIT, "%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
	    {"auth-key",		AUTHKEY},
	    {"auth-md",			AUTHMD},
	    {"auth-md-keyid",		AUTHMDKEYID},
	    {"auth-type",		AUTHTYPE},
	    {"cost",			COST},
	    {"demote",			DEMOTE},
	    {"fib-update",		FIBUPDATE},
	    {"interface",		INTERFACE},
	    {"no",			NO},
	    {"passive",			PASSIVE},
	    {"rdomain",			RDOMAIN},
	    {"redistribute",		REDISTRIBUTE},
	    {"rtlabel",			RTLABEL},
	    {"split-horizon",		SPLIT_HORIZON},
	    {"triggered-updates",	TRIGGERED_UPDATES},
	    {"yes",			YES}
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		log_warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		log_warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		log_warn("malloc");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		log_warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

struct ripd_conf *
parse_config(char *filename, int opts)
{
	struct sym	*sym, *next;

	if ((conf = calloc(1, sizeof(struct ripd_conf))) == NULL)
		fatal("parse_config");

	bzero(&globaldefs, sizeof(globaldefs));
	defs = &globaldefs;
	TAILQ_INIT(&defs->md_list);
	defs->cost = DEFAULT_COST;
	defs->auth_type = AUTH_NONE;
	conf->opts = opts;
	conf->options = OPT_SPLIT_POISONED;
	SIMPLEQ_INIT(&conf->redist_list);

	if ((file = pushfile(filename, !(conf->opts & RIPD_OPT_NOACTION))) == NULL) {
		free(conf);
		return (NULL);
	}
	topfile = file;

	yyparse();
	errors = file->errors;
	popfile();

	/* Free macros and check which have not been used. */
	TAILQ_FOREACH_SAFE(sym, &symhead, entry, next) {
		if ((conf->opts & RIPD_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	/* free global config defaults */
	md_list_clr(&globaldefs.md_list);

	if (errors) {
		clear_config(conf);
		return (NULL);
	}

	return (conf);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = strlen(s) - strlen(val) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

struct iface *
conf_get_if(struct kif *kif)
{
	struct iface	*i;

	LIST_FOREACH(i, &conf->iface_list, entry)
		if (i->ifindex == kif->ifindex) {
			yyerror("interface %s already configured",
			    kif->ifname);
			return (NULL);
		}

	i = if_new(kif);
	i->auth_keyid = 1;
	i->passive = 0;

	return (i);
}

void
clear_config(struct ripd_conf *xconf)
{
	struct iface	*i;

	while ((i = LIST_FIRST(&conf->iface_list)) != NULL) {
		LIST_REMOVE(i, entry);
		if_del(i);
	}

	free(xconf);
}

int
host(const char *s, struct in_addr *addr, struct in_addr *mask)
{
	struct in_addr		 ina;
	int			 bits = 32;

	bzero(&ina, sizeof(struct in_addr));
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (0);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (0);
	}

	addr->s_addr = ina.s_addr;
	mask->s_addr = prefixlen2mask(bits);

	return (1);
}
@


1.36
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2016/06/21 21:35:25 benno Exp $ */
d783 1
a783 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
@


1.35
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2014/11/20 05:51:20 jsg Exp $ */
d812 4
a815 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d874 1
a874 1
	TAILQ_FOREACH(sym, &symhead, entry)
d879 1
@


1.34
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2014/11/03 20:15:31 bluhm Exp $ */
d150 1
d153 7
@


1.33
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2014/11/03 03:42:12 doug Exp $ */
d598 3
@


1.32
log
@Add gcc format attributes to more warn/error functions in parse.y files.

Fix a few missing or incorrect format characters.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2014/01/22 00:21:17 henning Exp $ */
d386 1
a386 1
	char		*nfmt;
d390 2
a391 3
	if (asprintf(&nfmt, "%s:%d: %s", file->name, yylval.lineno, fmt) == -1)
		fatalx("yyerror asprintf");
	vlog(LOG_CRIT, nfmt, ap);
d393 2
a394 1
	free(nfmt);
@


1.31
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2013/03/06 21:42:40 sthen Exp $ */
d59 3
a61 1
int		 yyerror(const char *, ...);
d360 2
a361 1
				yyerror("demote group name \"%s\" too long");
@


1.30
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d687 2
a688 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
@


1.29
log
@as done in ospf{,6}d/relayd, sync yyerror in various other daemons with
that from bgpd, so that it logs to syslog when daemonized.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2010/08/03 18:42:41 henning Exp $ */
d436 1
a436 1
char	*parsebuf;
d438 1
a438 1
char	 pushback_buffer[MAXPUSHBACK];
d531 2
a532 2
	char	 buf[8096];
	char	*p, *val;
d555 1
a555 1
				*p++ = (char)c;
d600 1
a600 1
			*p++ = (char)c;
@


1.28
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2009/09/26 18:24:58 michele Exp $ */
d40 1
d382 2
a383 1
	va_list	ap;
d387 3
a389 3
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
d391 1
@


1.27
log
@Preliminary rdomain support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2009/09/26 11:12:50 michele Exp $ */
d584 2
a585 1
				else if (next == '\n')
d587 1
a587 1
				else
@


1.26
log
@Whitespace cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2009/07/31 16:04:34 michele Exp $ */
d104 1
a104 1
%token	SPLIT_HORIZON TRIGGERED_UPDATES FIBUPDATE REDISTRIBUTE
d179 7
d413 1
@


1.25
log
@Reword the split horizon parameters in the configuration file.
Now the choioses are: none, simple, poisoned.

Also make poisoned reverse the default behaviour.

Based on a diff by Eugene Yunak, thanks.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2009/03/31 21:03:49 tobias Exp $ */
d345 1
a345 1
interfaceoptsl	: PASSIVE  		{ iface->passive = 1; }
@


1.24
log
@Fixed memory leaks which would occur if the second of two memory
allocations fails.

looks right deraadt, krw
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2009/03/24 19:26:13 michele Exp $ */
d162 1
a162 1
			else if (!strcmp($2, "default"))
d743 1
@


1.23
log
@Change the behaviour of redistribute default.
Now a default route have to be present in the fib to be correctly advertised.

Spotted and tested by Steven Surdok on ripd.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2009/03/04 22:59:28 michele Exp $ */
d687 1
a687 2
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
d689 5
@


1.22
log
@typo;
unknon -> unknown
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2008/12/17 14:19:39 michele Exp $ */
d188 16
a203 22
			if (!strcmp($3, "default")) {
				if (!$1)
					conf->redistribute |=
					    REDISTRIBUTE_DEFAULT;
				else
					conf->redistribute &=
					    ~REDISTRIBUTE_DEFAULT;
			} else {
				if ((r = calloc(1, sizeof(*r))) == NULL)
					fatal(NULL);
				if (!strcmp($3, "static"))
					r->type = REDIST_STATIC;
				else if (!strcmp($3, "connected"))
					r->type = REDIST_CONNECTED;
				else if (host($3, &r->addr, &r->mask))
					r->type = REDIST_ADDR;
				else {
					yyerror("unknown redistribute type");
					free($3);
					free(r);
					YYERROR;
				}
d205 5
a209 2
				if ($1)
					r->type |= REDIST_NO;
a210 3
				SIMPLEQ_INSERT_TAIL(&conf->redist_list, r,
				    entry);
			}
@


1.21
log
@Add support for demotion counter.
When interfaces go up/down the demotion counter of the
specified group is decreased/increased.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2008/10/17 13:02:55 henning Exp $ */
d167 1
a167 1
				yyerror("unknon split horizon type");
@


1.20
log
@bring in the findeol() fix from pfctl. list of affected parsers by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2008/02/27 15:36:42 mpf Exp $ */
d109 1
d347 2
a348 2
interfaceopts_l	: interfaceopts_l interfaceoptsl
		| interfaceoptsl
d351 18
a368 2
interfaceoptsl	: PASSIVE nl		{ iface->passive = 1; }
		| defaults nl
d407 1
@


1.19
log
@Unbreak parser by initializing topfile correctly.
I got fooled by patch(1). Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2008/02/26 10:09:58 mpf Exp $ */
a487 1
	pushback_index = 0;
d491 4
a494 1
		c = lgetc(0);
@


1.18
log
@Have popfile() also close the main config file,
but only do the final popfile call after yyparse() is done.
This also fixes config reload on SIGHUP for some daemons.

Spotted by otto@@. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2007/11/12 23:59:41 mpf Exp $ */
d731 1
a757 1
	topfile = file;
@


1.17
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2007/10/24 19:50:33 claudio Exp $ */
d53 1
a53 1
} *file;
d439 3
a441 2
			yyerror("reached end of file while parsing quoted string");
			if (popfile() == EOF)
d459 1
a459 1
		if (popfile() == EOF)
d700 1
a700 1
	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
d702 7
a708 8
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
d757 1
@


1.16
log
@Garbage collect unused stuff found by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2007/10/20 13:26:50 pyr Exp $ */
a455 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d512 1
a512 1
	while ((c = lgetc(0)) == ' ')
@


1.15
log
@Sync parse.y with recent enhancements in hoststated.
Fix behavior when running -n.
henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2007/10/18 17:00:59 deraadt Exp $ */
a86 1
char			*start_state;
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2007/10/18 09:47:57 claudio Exp $ */
d682 2
a683 1
	    (nfile->name = strdup(name)) == NULL)
d685 1
d687 1
a736 1
		warn("%s", filename);
@


1.13
log
@Massive cleanup in the authentication code. the simple auth_key and the crypt
keys are not strings so a) use u_int8_t instead of char and b) uses memcpy
to copy the full MAX_SIMPLE_AUTH_LEN resp. MD5_DIGEST_LENGTH bytes around.
The parser needs some special code to ensure that the string is not to long
and if it is shorter then the buffer the rest needs to be zero padded.
Avoid to use strncpy() instead use a bzero(); memcpy() combo.
with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2007/10/16 20:01:23 mpf Exp $ */
d105 1
a105 1
%token  SPLIT_HORIZON TRIGGERED_UPDATES FIBUPDATE REDISTRIBUTE
d107 1
a107 1
%token  INTERFACE RTLABEL
d110 5
a114 5
%token  ERROR
%token  <v.string>	STRING
%token  <v.number>	NUMBER
%type   <v.number>	yesno no
%type   <v.string>	string
d159 1
a159 1
				    OPT_SPLIT_POISONED);
@


1.12
log
@Allow '=' to end a number in all lexers.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2007/10/16 06:06:49 deraadt Exp $ */
d77 1
a77 1
	char			 auth_key[MAX_SIMPLE_AUTH_LEN];
d244 1
a244 1
			if (strlen($3) > MD5_DIGEST_LENGTH) {
d246 1
a246 2
				    "(max length %d)",
				    MD5_DIGEST_LENGTH);
a249 1
			md_list_add(&defs->md_list, $2, $3);
d288 2
a289 2
			strncpy(defs->auth_key, $2,
			    sizeof(defs->auth_key));
@


1.11
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2007/10/13 16:35:22 deraadt Exp $ */
d593 1
a593 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.10
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2007/10/11 14:39:17 deraadt Exp $ */
d570 1
a570 1
				if (next == quotec)
d572 2
@


1.9
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2007/09/11 23:06:37 deraadt Exp $ */
d28 1
d34 1
d46 18
a63 6
static struct ripd_conf		*conf;
static FILE			*fin = NULL;
static int			 lineno = 1;
static int			 errors = 0;
char				*infile;
char				*start_state;
d65 10
a74 14
struct iface	*iface = NULL;

int		yyerror(const char *, ...);
int		yyparse(void);
int		kw_cmp(const void *, const void *);
int		lookup(char *);
int		lgetc(int);
int		lungetc(int);
int		findeol(void);
int		yylex(void);
void		clear_config(struct ripd_conf *);
int		check_file_secrecy(int, const char *);
u_int32_t	get_rtr_id(void);
int		host(const char *, struct in_addr *, struct in_addr *);
d84 10
a93 12
TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entries;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};

int			 symset(const char *, const char *, int);
char			*symget(const char *);
struct iface		*conf_get_if(struct kif *);
d123 1
d317 1
a317 1
interface       : INTERFACE STRING {
d345 1
a345 1
interface_block : '{' optnl interfaceopts_l '}'
d349 1
a349 1
interfaceopts_l : interfaceopts_l interfaceoptsl
d368 1
a368 1
	errors = 1;
d370 1
a370 1
	fprintf(stderr, "%s:%d: ", infile, yylval.lineno);
d422 1
a422 1
lgetc(int inquot)
d424 1
a424 2
	int	c, next;
	FILE *f = fin;
d440 7
a446 2
	if (inquot) {
		c = getc(f);
d450 2
a451 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d456 2
a457 2
		yylval.lineno = lineno;
		lineno++;
d462 1
a462 1
			c = getc(f);
d464 1
a464 1
		ungetc(c, f);
d468 5
d504 1
a504 1
			lineno++;
d518 1
a518 1
	int	 endc, next, c;
d526 1
a526 1
	yylval.lineno = lineno;
d560 1
a560 1
		endc = c;
d562 1
a562 1
			if ((c = lgetc(1)) == EOF)
d565 1
a565 1
				lineno++;
d568 1
a568 1
				if ((next = lgetc(1)) == EOF)
d570 1
a570 1
				if (next == endc)
d574 1
a574 1
			} else if (c == endc) {
d648 2
a649 2
		yylval.lineno = lineno;
		lineno++;
d656 61
d730 2
d733 1
a733 1
	if ((fin = fopen(filename, "r")) == NULL) {
a737 11
	infile = filename;

	conf->opts = opts;
	SIMPLEQ_INIT(&conf->redist_list);

	if (!(conf->opts & RIPD_OPT_NOACTION))
		if (check_file_secrecy(fileno(fin), filename)) {
			fclose(fin);
			free(conf);
			return (NULL);
		}
d740 2
a741 2

	fclose(fin);
d745 1
a745 1
		next = TAILQ_NEXT(sym, entries);
d752 1
a752 1
			TAILQ_REMOVE(&symhead, sym, entries);
d774 1
a774 1
	    sym = TAILQ_NEXT(sym, entries))
d783 1
a783 1
			TAILQ_REMOVE(&symhead, sym, entries);
d803 1
a803 1
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d834 1
a834 1
	TAILQ_FOREACH(sym, &symhead, entries)
d845 1
a845 1
	struct iface    *i;
@


1.8
log
@macro argument unused, using local instead; spotted by mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2007/09/11 22:15:17 deraadt Exp $ */
d57 1
a57 1
int		lgetc(FILE *);
d413 1
a413 1
lgetc(FILE *f)
d416 1
d432 5
d440 1
a440 3
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, f);
d484 1
a484 1
		c = lgetc(fin);
d500 1
a500 1
	int	 endc, c;
d505 1
a505 1
	while ((c = lgetc(fin)) == ' ')
d510 1
a510 1
		while ((c = lgetc(fin)) != '\n' && c != EOF)
d514 1
a514 1
			if ((c = lgetc(fin)) == EOF)
d544 1
a544 1
			if ((c = lgetc(fin)) == EOF)
a545 4
			if (c == endc) {
				*p = '\0';
				break;
			}
d549 10
d568 1
a568 1
			errx(1, "yylex: strdup");
d582 1
a582 1
		} while ((c = lgetc(fin)) != EOF && isdigit(c));
d621 1
a621 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
@


1.7
log
@extend lex to spot numbers in the stream, without impacting the parsing
of ip addresses and such.  this change is being pushed into all the pfctl
derived parsers, starting with the easy ones;  ok claudio michele
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2007/01/15 18:23:43 michele Exp $ */
d563 1
a563 1
	(isspace(x) || c == ')' || c ==',' || c == '/' || c == '}')
@


1.6
log
@allow users to specify interface specific parameters even on a global basis

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2007/01/08 13:01:10 claudio Exp $ */
d89 1
a89 1
		u_int32_t	 number;
d104 2
a105 1
%type   <v.number>	number yesno no
a116 15
number		: STRING {
			u_int32_t	 uval;
			const char	*errstr;

			uval = strtonum($1, 0, UINT_MAX, &errstr);
			if (errstr) {
				yyerror("number %s is %s", $1, errstr);
				free($1);
				YYERROR;
			} else
				$$ = uval;
			free($1);
		}
		;

d228 1
a228 1
authmd		: AUTHMD number STRING {
d246 1
a246 1
authmdkeyid	: AUTHMDKEYID number {
d287 1
a287 1
defaults	: COST number {
d560 36
@


1.5
log
@New redistribute code adapted from ospfd. It is now possible to do the same
redistribute setups as in ospfd (rtlables, per prefix, negation).
Tested, input and OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2006/10/25 20:01:49 henning Exp $ */
d239 1
d336 1
a336 2
			md_list_copy(&ifacedefs.md_list,
			    &defs->md_list);
d617 1
a617 1
	defs->cost = 1;
@


1.4
log
@strtonum, Pierre-Yves Ritschard <pyr@@spootnik.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2006/10/25 20:01:02 henning Exp $ */
d53 12
a64 11
int		 yyerror(const char *, ...);
int		 yyparse(void);
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(FILE *);
int		 lungetc(int);
int		 findeol(void);
int		 yylex(void);
void		 clear_config(struct ripd_conf *);
int		 check_file_secrecy(int fd, const char *fname);
u_int32_t	 get_rtr_id(void);
d99 1
a99 1
%token  INTERFACE
d101 1
d104 1
a104 1
%type   <v.number>	number yesno
d144 2
a145 12
yesno		: STRING {
			if (!strcmp($1, "yes"))
				$$ = 1;
			else if (!strcmp($1, "no"))
				$$ = 0;
			else {
				free($1);
				yyerror("recognized values are yes or no");
				YYERROR;
			}
			free($1);
		}
d148 3
d190 31
a220 16
		| REDISTRIBUTE STRING {
			if (!strcmp($2, "static"))
				conf->redistribute_flags |=
					REDISTRIBUTE_STATIC;
			else if (!strcmp($2, "connected"))
				conf->redistribute_flags |=
					REDISTRIBUTE_CONNECTED;
			else if (!strcmp($2, "default"))
				conf->redistribute_flags |=
					REDISTRIBUTE_DEFAULT;
			else if (!strcmp($2, "none"))
				conf->redistribute_flags = 0;
			else  {
				yyerror("unknown redistribute type");
				free($2);
				YYERROR;
d222 16
a237 1
			free($2);
d393 14
a406 11
	    {"auth-key",	    AUTHKEY},
	    {"auth-md",		    AUTHMD},
	    {"auth-md-keyid",	    AUTHMDKEYID},
	    {"auth-type",	    AUTHTYPE},
	    {"cost",		    COST},
	    {"fib-update",          FIBUPDATE},
	    {"interface",           INTERFACE},
	    {"passive",		    PASSIVE},
	    {"redistribute",        REDISTRIBUTE},
	    {"split-horizon",       SPLIT_HORIZON},
	    {"triggered-updates",   TRIGGERED_UPDATES}
d628 1
a628 1
	conf->redistribute_flags = 0;
d770 21
@


1.3
log
@geez, the anno 2004 bgpd debug shitz made it to ripd too
Pierre-Yves Ritschard <pyr@@spootnik.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2006/10/24 16:37:48 david Exp $ */
a83 1
int			 atoul(char *, u_long *);
d115 2
a116 1
			u_long  ulval;
d118 3
a120 2
			if (atoul($1, &ulval) == -1) {
				yyerror("%s is not a number", $1);
d124 1
a124 1
				$$ = ulval;
a709 16
}

int
atoul(char *s, u_long *ulvalp)
{
	u_long	 ulval;
	char	*ep;

	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
		return (-1);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (-1);
	*ulvalp = ulval;
	return (0);
@


1.2
log
@spelling and typo fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2006/10/18 16:11:58 norby Exp $ */
a47 1
static int			 pdebug = 1;
d384 1
a384 3
	if (p) {
		if (pdebug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
d386 1
a386 3
	} else {
		if (pdebug > 1)
			fprintf(stderr, "string: %s\n", s);
a387 1
	}
@


1.1
log
@Welcome ripd
started by Michele Marchetto some time ago by using the imsg/three process framework
of ospfd. He implemented most of the daemon with a little help and guidance from
Claudio and I.

Currently the daemon is more or less complete, with the exception of key lifetime
and rollover.

Not yet connected to the builds.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d264 1
a264 1
				yyerror("auth-key too long (max lenght %d)",
@

