head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.2
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.8
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.6
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.4
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.3.0.4
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.30
date	2016.09.03.10.28.08;	author renato;	state Exp;
branches;
next	1.29;
commitid	3pamvrppu41vvs6n;

1.29
date	2016.09.02.14.07.52;	author benno;	state Exp;
branches;
next	1.28;
commitid	GaB0AXyD9uoXsTK0;

1.28
date	2016.08.02.16.05.32;	author jca;	state Exp;
branches;
next	1.27;
commitid	M3zXmxiZhTfusmGR;

1.27
date	2016.02.02.17.51.11;	author sthen;	state Exp;
branches;
next	1.26;
commitid	LQHdRRMF0nq0fugE;

1.26
date	2015.12.05.13.13.47;	author claudio;	state Exp;
branches;
next	1.25;
commitid	b7fx00QUWNpx3oj5;

1.25
date	2015.02.09.12.13.42;	author claudio;	state Exp;
branches;
next	1.24;
commitid	b41fu1pxXgU3PIfI;

1.24
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2014.07.12.20.16.38;	author krw;	state Exp;
branches;
next	1.22;
commitid	lIxCxHhVEpsmXOdi;

1.22
date	2013.11.19.22.25.32;	author benno;	state Exp;
branches;
next	1.21;

1.21
date	2011.08.20.19.02.28;	author sthen;	state Exp;
branches;
next	1.20;

1.20
date	2010.02.08.00.26.51;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.02.20.28.49;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.26.18.24.58;	author michele;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.26.11.12.50;	author michele;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.06.08.20.55;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.31.20.30.15;	author jacekm;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.31.17.06.01;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.27.14.37.25;	author michele;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.24.19.26.13;	author michele;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.17.14.19.39;	author michele;	state Exp;
branches;
next	1.10;

1.10
date	2008.08.05.06.51.12;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.24.20.23.09;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.24.19.05.06;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.20.13.26.50;	author pyr;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.18.17.00.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.13.16.35.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.24.10.14.17;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.08.13.01.10;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.16.11.58;	author norby;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Simplify shutdown process.

On shutdown, there's no need to use kill(2) to kill the child
processes. Just closing the IPC sockets will make the children receive
an EOF, break out from the event loop and then exit.

Tha advantages of this "pipe teardown" are:
* simpler code;
* no need to pledge "proc" in the parent process;
* removal of a (hard to trigger) PID reuse race condition.

ok benno@@ claudio@@
@
text
@/*	$OpenBSD: ripd.c,v 1.29 2016/09/02 14:07:52 benno Exp $ */

/*
 * Copyright (c) 2006 Michele Marchetto <mydecay@@openbeer.it>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/sysctl.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <event.h>
#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>

#include "rip.h"
#include "ripd.h"
#include "ripe.h"
#include "log.h"
#include "control.h"
#include "rde.h"

__dead void		 usage(void);
void			 main_sig_handler(int, short, void *);
__dead void		 ripd_shutdown(void);
void			 main_dispatch_ripe(int, short, void *);
void			 main_dispatch_rde(int, short, void *);

int			 pipe_parent2ripe[2];
int			 pipe_parent2rde[2];
int			 pipe_ripe2rde[2];

struct ripd_conf	*conf = NULL;
struct imsgev		*iev_ripe;
struct imsgev		*iev_rde;

pid_t			 ripe_pid = 0;
pid_t			 rde_pid = 0;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-dnv] [-D macro=value] [-f file] [-s socket]\n",
	    __progname);
	exit(1);
}

/* ARGSUSED */
void
main_sig_handler(int sig, short event, void *arg)
{
	/* signal handler rules don't apply, libevent decouples for us */
	switch (sig) {
	case SIGTERM:
	case SIGINT:
		ripd_shutdown();
		/* NOTREACHED */
	case SIGHUP:
		/* reconfigure */
		/* ... */
		break;
	default:
		fatalx("unexpected signal");
		/* NOTREACHED */
	}
}

int
main(int argc, char *argv[])
{
	struct event	 ev_sigint, ev_sigterm, ev_sighup;
	int		 mib[4];
	int		 debug = 0;
	int		 ipforwarding;
	int		 ch;
	int		 opts = 0;
	char		*conffile;
	char 		*sockname;
	size_t		 len;

	conffile = CONF_FILE;
	ripd_process = PROC_MAIN;
	log_procname = log_procnames[ripd_process];
	sockname = RIPD_SOCKET;

	log_init(1);	/* log to stderr until daemonized */
	log_verbose(1);

	while ((ch = getopt(argc, argv, "cdD:f:ns:v")) != -1) {
		switch (ch) {
		case 'c':
			opts |= RIPD_OPT_FORCE_DEMOTE;
			break;
		case 'd':
			debug = 1;
			break;
		case 'D':
			if (cmdline_symset(optarg) < 0)
				log_warnx("could not parse macro definition %s",
				    optarg);
			break;
		case 'f':
			conffile = optarg;
			break;
		case 'n':
			opts |= RIPD_OPT_NOACTION;
			break;
		case 's':
			sockname = optarg;
			break;
		case 'v':
			if (opts & RIPD_OPT_VERBOSE)
				opts |= RIPD_OPT_VERBOSE2;
			opts |= RIPD_OPT_VERBOSE;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	mib[0] = CTL_NET;
	mib[1] = PF_INET;
	mib[2] = IPPROTO_IP;
	mib[3] = IPCTL_FORWARDING;
	len = sizeof(ipforwarding);
	if (sysctl(mib, 4, &ipforwarding, &len, NULL, 0) == -1)
		err(1, "sysctl");

	if (!ipforwarding)
		log_warnx("WARNING: IP forwarding NOT enabled");

	/* fetch interfaces early */
	kif_init();

	/* parse config file */
	if ((conf = parse_config(conffile, opts)) == NULL )
		exit(1);
	conf->csock = sockname;

	if (conf->opts & RIPD_OPT_NOACTION) {
		if (conf->opts & RIPD_OPT_VERBOSE)
			print_config(conf);
		else
			fprintf(stderr, "configuration OK\n");
		exit(0);
	}

	/* check for root privileges */
	if (geteuid())
		errx(1, "need root privileges");

	/* check for ripd user */
	if (getpwnam(RIPD_USER) == NULL)
		errx(1, "unknown user %s", RIPD_USER);

	log_init(debug);
	log_verbose(conf->opts & RIPD_OPT_VERBOSE);

	if (!debug)
		daemon(1, 0);

	log_info("startup");

	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_parent2ripe) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_parent2rde) == -1)
		fatal("socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    PF_UNSPEC, pipe_ripe2rde) == -1)
		fatal("socketpair");

	/* start children */
	rde_pid = rde(conf, pipe_parent2rde, pipe_ripe2rde, pipe_parent2ripe);
	ripe_pid = ripe(conf, pipe_parent2ripe, pipe_ripe2rde, pipe_parent2rde);

	event_init();

	/* setup signal handler */
	signal_set(&ev_sigint, SIGINT, main_sig_handler, NULL);
	signal_set(&ev_sigterm, SIGTERM, main_sig_handler, NULL);
	signal_set(&ev_sighup, SIGHUP, main_sig_handler, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);
	signal_add(&ev_sighup, NULL);
	signal(SIGPIPE, SIG_IGN);

	/* setup pipes to children */
	close(pipe_parent2ripe[1]);
	close(pipe_parent2rde[1]);
	close(pipe_ripe2rde[0]);
	close(pipe_ripe2rde[1]);

	if ((iev_ripe = malloc(sizeof(struct imsgev))) == NULL ||
	    (iev_rde = malloc(sizeof(struct imsgev))) == NULL)
		fatal(NULL);
	imsg_init(&iev_ripe->ibuf, pipe_parent2ripe[0]);
	iev_ripe->handler = main_dispatch_ripe;
	imsg_init(&iev_rde->ibuf, pipe_parent2rde[0]);
	iev_rde->handler = main_dispatch_rde;

	/* setup event handler */
	iev_ripe->events = EV_READ;
	event_set(&iev_ripe->ev, iev_ripe->ibuf.fd, iev_ripe->events,
	    iev_ripe->handler, iev_ripe);
	event_add(&iev_ripe->ev, NULL);

	iev_rde->events = EV_READ;
	event_set(&iev_rde->ev, iev_rde->ibuf.fd, iev_rde->events,
	    iev_rde->handler, iev_rde);
	event_add(&iev_rde->ev, NULL);

	if (kr_init(!(conf->flags & RIPD_FLAG_NO_FIB_UPDATE),
	    conf->rdomain) == -1)
		fatalx("kr_init failed");

	event_dispatch();

	ripd_shutdown();
	/* NOTREACHED */
	return (0);
}

__dead void
ripd_shutdown(void)
{
	struct iface	*i;
	pid_t		 pid;
	int		 status;

	/* close pipes */
	msgbuf_clear(&iev_ripe->ibuf.w);
	close(iev_ripe->ibuf.fd);
	msgbuf_clear(&iev_rde->ibuf.w);
	close(iev_rde->ibuf.fd);

	while ((i = LIST_FIRST(&conf->iface_list)) != NULL) {
		LIST_REMOVE(i, entry);
		if_del(i);
	}

	control_cleanup(conf->csock);
	kr_shutdown();

	log_debug("waiting for children to terminate");
	do {
		pid = wait(&status);
		if (pid == -1) {
			if (errno != EINTR && errno != ECHILD)
				fatal("wait");
		} else if (WIFSIGNALED(status))
			log_warnx("%s terminated; signal %d",
			    (pid == rde_pid) ? "route decision engine" :
			    "rip engine", WTERMSIG(status));
	} while (pid != -1 || (pid == -1 && errno == EINTR));

	free(iev_ripe);
	free(iev_rde);
	free(conf);

	log_info("terminating");
	exit(0);
}

/* imsg handling */
/* ARGSUSED */
void
main_dispatch_ripe(int fd, short event, void *bula)
{
	struct imsgev		*iev = bula;
	struct imsgbuf		*ibuf = &iev->ibuf;
	struct imsg		 imsg;
	struct demote_msg	 dmsg;
	ssize_t			 n;
	int			 shut = 0, verbose;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_RELOAD:
			/* XXX reconfig */
			break;
		case IMSG_CTL_FIB_COUPLE:
			kr_fib_couple();
			break;
		case IMSG_CTL_FIB_DECOUPLE:
			kr_fib_decouple();
			break;
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_KROUTE_ADDR:
			kr_show_route(&imsg);
			break;
		case IMSG_CTL_IFINFO:
			if (imsg.hdr.len == IMSG_HEADER_SIZE)
				kr_ifinfo(NULL, imsg.hdr.pid);
			else if (imsg.hdr.len == IMSG_HEADER_SIZE + IFNAMSIZ)
				kr_ifinfo(imsg.data, imsg.hdr.pid);
			else
				log_warnx("IFINFO request with wrong len");
			break;
		case IMSG_DEMOTE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(dmsg))
				fatalx("invalid size of OE request");
			memcpy(&dmsg, imsg.data, sizeof(dmsg));
			carp_demote_set(dmsg.demote_group, dmsg.level);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			/* already checked by ripe */
			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("main_dispatch_ripe: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */  
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

/* ARGSUSED */
void
main_dispatch_rde(int fd, short event, void *bula)
{
	struct imsgev	*iev = bula;
	struct imsgbuf	*ibuf = &iev->ibuf;
	struct imsg	 imsg;
	ssize_t		 n;
	int		 shut = 0;

	if (event & EV_READ) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			fatal("imsg_read error");
		if (n == 0)	/* connection closed */
			shut = 1;
	}
	if (event & EV_WRITE) {
		if ((n = msgbuf_write(&ibuf->w)) == -1 && errno != EAGAIN)
			fatal("msgbuf_write");
		if (n == 0)	/* connection closed */
			shut = 1;
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1)
			fatal("imsg_get");

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_KROUTE_CHANGE:
			if (kr_change(imsg.data))
				log_warn("main_dispatch_rde: error changing "
				    "route");
			break;
		case IMSG_KROUTE_DELETE:
			if (kr_delete(imsg.data))
				log_warn("main_dispatch_rde: error deleting "
				    "route");
			break;
		default:
			log_debug("main_dispatch_rde: error handling imsg %d",
			    imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}
	if (!shut)
		imsg_event_add(iev);
	else {
		/* this pipe is dead, so remove the event handler */  
		event_del(&iev->ev);
		event_loopexit(NULL);
	}
}

void
main_imsg_compose_ripe(int type, pid_t pid, void *data, u_int16_t datalen)
{
	imsg_compose_event(iev_ripe, type, 0, pid, -1, data, datalen);
}

void
main_imsg_compose_rde(int type, pid_t pid, void *data, u_int16_t datalen)
{
	imsg_compose_event(iev_rde, type, 0, pid, -1, data, datalen);
}

int
rip_redistribute(struct kroute *kr)
{
	struct redistribute	*r;
	u_int8_t		 is_default = 0;

	if (kr->flags & F_RIPD_INSERTED)
		return (1);

	/* only allow 0.0.0.0/0 via REDIST_DEFAULT */
	if (kr->prefix.s_addr == INADDR_ANY && kr->netmask.s_addr == INADDR_ANY)
		is_default = 1;

	SIMPLEQ_FOREACH(r, &conf->redist_list, entry) {
		switch (r->type & ~REDIST_NO) {
		case REDIST_LABEL:
			if (kr->rtlabel == r->label)
				return (r->type & REDIST_NO ? 0 : 1);
			break;
		case REDIST_STATIC:
			/*
			 * Dynamic routes are not redistributable. Placed here
			 * so that link local addresses can be redistributed
			 * via a rtlabel.
			 */
			if (is_default)
				continue;
			if (kr->flags & F_DYNAMIC)
				continue;
			if (kr->flags & F_STATIC)
				return (r->type & REDIST_NO ? 0 : 1);
			break;
		case REDIST_CONNECTED:
			if (is_default)
				continue;
			if (kr->flags & F_DYNAMIC)
				continue;
			if (kr->flags & F_CONNECTED)
				return (r->type & REDIST_NO ? 0 : 1);
			break;
		case REDIST_ADDR:
			if (kr->flags & F_DYNAMIC)
				continue;

			if (r->addr.s_addr == INADDR_ANY &&
			    r->mask.s_addr == INADDR_ANY) {
				if (is_default)
					return (r->type & REDIST_NO? 0 : 1);
				else
					return (0);
			}

			if ((kr->prefix.s_addr & r->mask.s_addr) ==
			    (r->addr.s_addr & r->mask.s_addr) &&
			    (kr->netmask.s_addr & r->mask.s_addr) ==
			    r->mask.s_addr)
				return (r->type & REDIST_NO? 0 : 1);
			break;
		case REDIST_DEFAULT:
			if (is_default)
				return (r->type & REDIST_NO? 0 : 1);
			break;
		}
	}

	return (0);
}

void
imsg_event_add(struct imsgev *iev)
{
	if (iev->handler == NULL) {
		imsg_flush(&iev->ibuf);
		return;
	}

	iev->events = EV_READ;
	if (iev->ibuf.w.queued)
		iev->events |= EV_WRITE;

	event_del(&iev->ev);
	event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev);
	event_add(&iev->ev, NULL);
}

int
imsg_compose_event(struct imsgev *iev, u_int16_t type,
    u_int32_t peerid, pid_t pid, int fd, void *data, u_int16_t datalen)
{
	int	ret;

	if ((ret = imsg_compose(&iev->ibuf, type, peerid,
	    pid, fd, data, datalen)) != -1)
		imsg_event_add(iev);
	return (ret);
}
@


1.29
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.28 2016/08/02 16:05:32 jca Exp $ */
a50 1
int			 check_child(pid_t, const char *);
d52 1
a52 1
void			 ripd_shutdown(void);
d82 1
a82 6
	/*
	 * signal handler rules don't apply, libevent decouples for us
	 */

	int	die = 0;

d86 2
a87 14
		die = 1;
		/* FALLTHROUGH */
	case SIGCHLD:
		if (check_child(ripe_pid, "rip engine")) {
			ripe_pid = 0;
			die = 1;
		}
		if (check_child(rde_pid, "route decision engine")) {
			rde_pid = 0;
			die = 1;
		}
		if (die)
			ripd_shutdown();
		break;
d101 1
a101 1
	struct event	 ev_sigint, ev_sigterm, ev_sigchld, ev_sighup;
a218 1
	signal_set(&ev_sigchld, SIGCHLD, main_sig_handler, NULL);
a221 1
	signal_add(&ev_sigchld, NULL);
d261 1
a261 1
void
d266 1
d268 5
a272 5
	if (ripe_pid)
		kill(ripe_pid, SIGTERM);

	if (rde_pid)
		kill(rde_pid, SIGTERM);
d282 1
d284 8
a291 3
		if ((pid = wait(NULL)) == -1 &&
		    errno != EINTR && errno != ECHILD)
			fatal("wait");
a293 1
	msgbuf_clear(&iev_ripe->ibuf.w);
a294 1
	msgbuf_clear(&iev_rde->ibuf.w);
a299 20
}

int
check_child(pid_t pid, const char *pname)
{
	int	status;

	if (waitpid(pid, &status, WNOHANG) > 0) {
		if (WIFEXITED(status)) {
			log_warnx("lost child: %s exited", pname);
			return (1);
		}
		if (WIFSIGNALED(status)) {
			log_warnx("lost child: %s terminated; signal %d",
			    pname, WTERMSIG(status));
			return (1);
		}
	}

	return (0);
@


1.28
log
@Allow specifying an alternate socket path.

This allows one to run multiple ripd instances, for example to serve
multiple rdomains.  Diff from Nima GHOTBI, ok claudio@@ florian@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.27 2016/02/02 17:51:11 sthen Exp $ */
d131 1
@


1.27
log
@Remove setproctitle() for the parent process. Because rc.d(8) uses process
titles (including flags) to distinguish between daemons, this makes it
possible to manage multiple copies of a daemon using the normal infrastructure
by symlinking rc.d scripts to a new name. ok jung@@ ajacoutot@@, smtpd ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.26 2015/12/05 13:13:47 claudio Exp $ */
d73 2
a74 1
	fprintf(stderr, "usage: %s [-dnv] [-D macro=value] [-f file]\n",
d126 1
d131 1
d136 1
a136 1
	while ((ch = getopt(argc, argv, "cdD:f:nv")) != -1) {
d155 3
d191 1
d297 1
a297 1
	control_cleanup();
@


1.26
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.25 2015/02/09 12:13:42 claudio Exp $ */
a222 3

	/* show who we are */
	setproctitle("parent");
@


1.25
log
@More session_socket_blockmode() removal. While there make the main UDP
socket non-blocking by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.24 2015/01/16 06:40:20 deraadt Exp $ */
d345 1
a345 1
		if ((n = imsg_read(ibuf)) == -1)
d424 1
a424 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.23 2014/07/12 20:16:38 krw Exp $ */
d210 2
a211 2
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC,
	    pipe_parent2ripe) == -1)
d213 2
a214 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_parent2rde) == -1)
d216 2
a217 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pipe_ripe2rde) == -1)
a218 6
	session_socket_blockmode(pipe_parent2ripe[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2ripe[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2rde[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_parent2rde[1], BM_NONBLOCK);
	session_socket_blockmode(pipe_ripe2rde[0], BM_NONBLOCK);
	session_socket_blockmode(pipe_ripe2rde[1], BM_NONBLOCK);
@


1.23
log
@Close connections when msgbuf_write() returns 0.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.22 2013/11/19 22:25:32 benno Exp $ */
a27 1
#include <sys/param.h>
@


1.22
log
@handle msgbuf_write() returning EAGAIN

"looks right" deraadt and sthen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.21 2011/08/20 19:02:28 sthen Exp $ */
d356 1
a356 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d358 2
d435 1
a435 1
		if (msgbuf_write(&ibuf->w) == -1 && errno != EAGAIN)
d437 2
@


1.21
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"-v" (previously only "-vd" worked). Similar to recent ospfd commit.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.20 2010/02/08 00:26:51 guenther Exp $ */
d356 1
a356 1
		if (msgbuf_write(&ibuf->w) == -1)
d433 1
a433 1
		if (msgbuf_write(&ibuf->w) == -1)
@


1.20
log
@Use SIGCHLD for the sigchild handler not SIGINT twice.
(This was inherited from ospfd; claudio fixed it there some time ago)
Spotted in ripd by haesbaert <at> haesbaert.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.19 2009/11/02 20:28:49 claudio Exp $ */
d132 1
d204 1
@


1.19
log
@Another routing daemon that gets IMSG_CTL_LOG_VERBOSE to allow toggeling of
log_debug(). ok michele, henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.18 2009/09/26 18:24:58 michele Exp $ */
d235 1
a235 1
	signal_set(&ev_sigchld, SIGINT, main_sig_handler, NULL);
@


1.18
log
@Preliminary rdomain support.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.17 2009/09/26 11:12:50 michele Exp $ */
d345 1
a345 1
	int			 shut = 0;
d392 5
@


1.17
log
@Whitespace cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.16 2009/06/06 08:20:55 eric Exp $ */
d268 2
a269 1
	if (kr_init(!(conf->flags & RIPD_FLAG_NO_FIB_UPDATE)) == -1)
@


1.16
log
@make ripctl/ripd imsg-in-a-lib ready too.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.15 2009/05/31 20:30:15 jacekm Exp $ */
d141 1
a141 1
                case 'D':
d341 1
a341 1
	struct imsg	 	 imsg;
d343 2
a344 2
	ssize_t		 	 n;
	int		 	 shut = 0;
d546 12
a557 12
        if (iev->handler == NULL) {
                imsg_flush(&iev->ibuf);
                return;
        }
        
        iev->events = EV_READ;
        if (iev->ibuf.w.queued)
                iev->events |= EV_WRITE;
                        
        event_del(&iev->ev);
        event_set(&iev->ev, iev->ibuf.fd, iev->events, iev->handler, iev);
        event_add(&iev->ev, NULL);   
d559 1
a559 1
                         
d564 6
a569 6
        int     ret;
                            
        if ((ret = imsg_compose(&iev->ibuf, type, peerid,
            pid, fd, data, datalen)) != -1)
                imsg_event_add(iev);
        return (ret);
@


1.15
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.14 2009/05/31 17:06:01 claudio Exp $ */
d63 2
a64 2
struct imsgbuf		*ibuf_ripe;
struct imsgbuf		*ibuf_rde;
d249 2
a250 2
	if ((ibuf_ripe = malloc(sizeof(struct imsgbuf))) == NULL ||
	    (ibuf_rde = malloc(sizeof(struct imsgbuf))) == NULL)
d252 4
a255 2
	imsg_init(ibuf_ripe, pipe_parent2ripe[0], main_dispatch_ripe);
	imsg_init(ibuf_rde, pipe_parent2rde[0], main_dispatch_rde);
d258 9
a266 9
	ibuf_ripe->events = EV_READ;
	event_set(&ibuf_ripe->ev, ibuf_ripe->fd, ibuf_ripe->events,
	    ibuf_ripe->handler, ibuf_ripe);
	event_add(&ibuf_ripe->ev, NULL);

	ibuf_rde->events = EV_READ;
	event_set(&ibuf_rde->ev, ibuf_rde->fd, ibuf_rde->events,
	    ibuf_rde->handler, ibuf_rde);
	event_add(&ibuf_rde->ev, NULL);
d304 4
a307 4
	msgbuf_clear(&ibuf_ripe->w);
	free(ibuf_ripe);
	msgbuf_clear(&ibuf_rde->w);
	free(ibuf_rde);
d339 2
a340 1
	struct imsgbuf		*ibuf = bula;
d400 1
a400 1
		imsg_event_add(ibuf);
d403 1
a403 1
		event_del(&ibuf->ev);
d412 2
a413 1
	struct imsgbuf	*ibuf = bula;
d455 1
a455 1
		imsg_event_add(ibuf);
d458 1
a458 1
		event_del(&ibuf->ev);
d466 1
a466 1
	imsg_compose(ibuf_ripe, type, 0, pid, data, datalen);
d472 1
a472 1
	imsg_compose(ibuf_rde, type, 0, pid, data, datalen);
a542 1
/* this needs to be added here so that ripctl can be used without libevent */
d544 1
a544 1
imsg_event_add(struct imsgbuf *ibuf)
d546 24
a569 7
	ibuf->events = EV_READ;
	if (ibuf->w.queued)
		ibuf->events |= EV_WRITE;

	event_del(&ibuf->ev);
	event_set(&ibuf->ev, ibuf->fd, ibuf->events, ibuf->handler, ibuf);
	event_add(&ibuf->ev, NULL);
@


1.14
log
@Better EV_READ and EV_WRITE handling in the libevent callbacks. Again mostly
the same ospfd diff applied with some fuzz.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.13 2009/03/27 14:37:25 michele Exp $ */
a351 1
		imsg_event_add(ibuf);
a422 1
		imsg_event_add(ibuf);
@


1.13
log
@Allow the announcement of default route also via redistribute 0.0.0.0/0
and route labels.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.12 2009/03/24 19:26:13 michele Exp $ */
d343 1
a343 2
	switch (event) {
	case EV_READ:
d348 2
a349 2
		break;
	case EV_WRITE:
a352 3
		return;
	default:
		fatalx("unknown event");
d415 1
a415 2
	switch (event) {
	case EV_READ:
d420 2
a421 2
		break;
	case EV_WRITE:
a424 3
		return;
	default:
		fatalx("unknown event");
@


1.12
log
@Change the behaviour of redistribute default.
Now a default route have to be present in the fib to be correctly advertised.

Spotted and tested by Steven Surdok on ripd.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.11 2008/12/17 14:19:39 michele Exp $ */
a496 2
			if (is_default)
				continue;
a521 2
			if (is_default)
				continue;
d524 9
d541 1
a541 1
				return (1);
@


1.11
log
@Add support for demotion counter.
When interfaces go up/down the demotion counter of the
specified group is decreased/increased.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.10 2008/08/05 06:51:12 claudio Exp $ */
a56 1
void			 ripd_redistribute_default(int);
a268 3
	/* redistribute default */
	ripd_redistribute_default(IMSG_NETWORK_ADD);

d485 1
d490 1
a490 1
	/* only allow 0.0.0.0/0 via REDISTRIBUTE_DEFAULT */
d492 1
a492 1
		return (0);
d497 2
d508 2
d516 2
d524 2
d534 4
a541 13
}

void
ripd_redistribute_default(int type)
{
	struct kroute	kr;

	if (!(conf->redistribute & REDISTRIBUTE_DEFAULT))
		return;

	bzero(&kr, sizeof(kr));
	kr.metric = 1;	/* default metric */
	main_imsg_compose_rde(type, 0, &kr, sizeof(struct kroute));
@


1.10
log
@Do not advertise the default route with wrong metric of 0. Set it to 1
by default. Reminded to commit this brad@@, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.9 2008/05/12 19:15:02 pyr Exp $ */
d134 1
a134 1
	while ((ch = getopt(argc, argv, "dD:f:nv")) != -1) {
d136 3
d341 5
a345 4
	struct imsgbuf	*ibuf = bula;
	struct imsg	 imsg;
	ssize_t		 n;
	int		 shut = 0;
d391 6
@


1.9
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.8 2007/10/24 20:23:09 claudio Exp $ */
d534 1
@


1.8
log
@Add the 5 needed lines to support -D makro=value option. Another surprising
finding by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.7 2007/10/24 19:05:06 claudio Exp $ */
d160 5
@


1.7
log
@Sync a bit more with ospfd. Do not fatal if one of the pipes is closed,
instead do a "nice" shutdown. Ignore SIGHUP in the childs even though we
have no reload support (yet). Remove some redundant code and clean up some
types.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.6 2007/10/20 13:26:50 pyr Exp $ */
d75 2
a76 1
	fprintf(stderr, "usage: %s [-dnv] [-f file]\n", __progname);
d134 1
a134 1
	while ((ch = getopt(argc, argv, "df:nv")) != -1) {
d138 5
@


1.6
log
@Sync parse.y with recent enhancements in hoststated.
Fix behavior when running -n.
henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.5 2007/10/18 17:00:59 deraadt Exp $ */
d330 1
d337 1
a337 1
			fatalx("pipe closed");
d384 7
a390 1
	imsg_event_add(ibuf);
d400 1
d407 1
a407 1
			fatalx("pipe closed");
d443 7
a449 1
	imsg_event_add(ibuf);
@


1.5
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.4 2007/10/13 16:35:22 deraadt Exp $ */
d131 2
a154 3
	/* start logging */
	log_init(debug);

d188 2
@


1.4
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.3 2007/01/24 10:14:17 claudio Exp $ */
d51 11
a61 11
__dead void	 usage(void);
int		 check_child(pid_t, const char *);
void		 main_sig_handler(int, short, void *);
void		 ripd_shutdown(void);
void		 main_dispatch_ripe(int, short, void *);
void		 main_dispatch_rde(int, short, void *);
void		 ripd_redistribute_default(int);

int     pipe_parent2ripe[2];
int     pipe_parent2rde[2];
int     pipe_ripe2rde[2];
d182 1
a182 1
	/* check for root privileges  */
d326 3
a328 3
	struct imsgbuf  *ibuf = bula;
	struct imsg      imsg;
	ssize_t          n;
d334 1
a334 1
		if (n == 0)     /* connection closed */
d389 3
a391 3
	struct imsgbuf  *ibuf = bula;
	struct imsg      imsg;
	ssize_t          n;
d397 1
a397 1
		if (n == 0)     /* connection closed */
@


1.3
log
@Ingore SIGPIPE in the parent and rde as well. This is needed to correctly
report crashes. Discussed with norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.2 2007/01/08 13:01:10 claudio Exp $ */
a56 1
int		 check_file_secrecy(int, const char *);
a446 23
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat     st;

	if (fstat(fd, &st)) {
		log_warn("cannot stat %s", fname);
		return (-1);
	}

	if (st.st_uid != 0 && st.st_uid != getuid()) {
		log_warnx("%s: owner not root or current user", fname);
		return (-1);
	}

	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		log_warnx("%s: group/world readable/writeable", fname);
		return (-1);
	}

	return (0);
@


1.2
log
@New redistribute code adapted from ospfd. It is now possible to do the same
redistribute setups as in ospfd (rtlables, per prefix, negation).
Tested, input and OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ripd.c,v 1.1 2006/10/18 16:11:58 norby Exp $ */
d228 1
@


1.1
log
@Welcome ripd started by Michele Marchetto some time ago by using the imsg/three process framework of ospfd. He implemented most of the daemon with a little help and guidance from Claudio and I. Currently the daemon is more or less complete, with the exception of key lifetime and rollover. Not yet connected to the builds. OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d58 1
d255 3
d475 2
d480 2
a481 6
	/* XXX this is funky, it is not possible to distribute static and
	 * connected. OSPFD has a much better way to do this including rtlabel
	 * support
	 */
	switch (conf->redistribute_flags) {
	case REDISTRIBUTE_NONE:
d483 34
a516 12
	case REDISTRIBUTE_STATIC:
		return (kr->flags & F_KERNEL ? 1 : 0);
	case REDISTRIBUTE_CONNECTED:
		return (kr->flags & F_CONNECTED ? 1 : 0);
	case REDISTRIBUTE_DEFAULT:
		if (kr->prefix.s_addr == INADDR_ANY &&
		    kr->netmask.s_addr == INADDR_ANY)
			return (1);
		else
			return (0);
	default:
		fatalx("unknown redistribute type");
d518 14
@


