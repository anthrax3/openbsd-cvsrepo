head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.4
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.14
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.12
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.8
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.6
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.4
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.6
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.14
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.10
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.8
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.6
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2017.03.21.12.06.56;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	6uuBMurt3Uh42fgX;

1.6
date	2016.09.02.14.07.52;	author benno;	state Exp;
branches;
next	1.5;
commitid	GaB0AXyD9uoXsTK0;

1.5
date	2014.11.03.20.15.31;	author bluhm;	state Exp;
branches;
next	1.4;
commitid	ziMZlrkCPhUaYhzj;

1.4
date	2011.08.20.19.02.28;	author sthen;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.02.20.28.49;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.31.23.43.11;	author michele;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.16.11.58;	author norby;	state Exp;
branches;
next	;


desc
@@


1.7
log
@From a syslog perspective it does not make sense to log fatal and
warn with the same severity.  Switch log_warn() to LOG_ERR and keep
fatal() at LOG_CRIT.
OK reyk@@ florian@@
@
text
@/*	$OpenBSD: log.c,v 1.6 2016/09/02 14:07:52 benno Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "log.h"
#include "ripd.h"

int		 debug;
int		 verbose;
const char	*log_procname;

void
log_init(int n_debug)
{
	extern char	*__progname;

	debug = n_debug;

	if (!debug)
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);

	tzset();
}

void
log_verbose(int v)
{
	verbose = v;
}

void
logit(int pri, const char *fmt, ...)
{
	va_list	ap;

	va_start(ap, fmt);
	vlog(pri, fmt, ap);
	va_end(ap);
}

void
vlog(int pri, const char *fmt, va_list ap)
{
	char	*nfmt;

	if (debug) {
		/* best effort in out of mem situations */
		if (asprintf(&nfmt, "%s\n", fmt) == -1) {
			vfprintf(stderr, fmt, ap);
			fprintf(stderr, "\n");
		} else {
			vfprintf(stderr, nfmt, ap);
			free(nfmt);
		}
		fflush(stderr);
	} else
		vsyslog(pri, fmt, ap);
}

void
log_warn(const char *emsg, ...)
{
	char	*nfmt;
	va_list	 ap;

	/* best effort to even work in out of memory situations */
	if (emsg == NULL)
		logit(LOG_ERR, "%s", strerror(errno));
	else {
		va_start(ap, emsg);

		if (asprintf(&nfmt, "%s: %s", emsg, strerror(errno)) == -1) {
			/* we tried it... */
			vlog(LOG_ERR, emsg, ap);
			logit(LOG_ERR, "%s", strerror(errno));
		} else {
			vlog(LOG_ERR, nfmt, ap);
			free(nfmt);
		}
		va_end(ap);
	}
}

void
log_warnx(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_ERR, emsg, ap);
	va_end(ap);
}

void
log_info(const char *emsg, ...)
{
	va_list	 ap;

	va_start(ap, emsg);
	vlog(LOG_INFO, emsg, ap);
	va_end(ap);
}

void
log_debug(const char *emsg, ...)
{
	va_list	 ap;

	if (verbose) {
		va_start(ap, emsg);
		vlog(LOG_DEBUG, emsg, ap);
		va_end(ap);
	}
}

void
fatal(const char *emsg)
{
	if (emsg == NULL)
		logit(LOG_CRIT, "fatal in %s: %s", log_procname,
		    strerror(errno));
	else
		if (errno)
			logit(LOG_CRIT, "fatal in %s: %s: %s",
			    log_procname, emsg, strerror(errno));
		else
			logit(LOG_CRIT, "fatal in %s: %s",
			    log_procname, emsg);

	if (ripd_process == PROC_MAIN)
		exit(1);
	else				/* parent copes via SIGCHLD */
		_exit(1);
}

void
fatalx(const char *emsg)
{
	errno = 0;
	fatal(emsg);
}
@


1.6
log
@work on making log.c similar in all daemons:

move daemon-local functions into new logmsg.c, and reduce
the (mostly whitespace) differences so that log.c's can be diffed easily.

ok claudio@@, feedback from henning@@, deraadt@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.5 2014/11/03 20:15:31 bluhm Exp $ */
d91 1
a91 1
		logit(LOG_CRIT, "%s", strerror(errno));
d97 2
a98 2
			vlog(LOG_CRIT, emsg, ap);
			logit(LOG_CRIT, "%s", strerror(errno));
d100 1
a100 1
			vlog(LOG_CRIT, nfmt, ap);
d113 1
a113 1
	vlog(LOG_CRIT, emsg, ap);
@


1.5
log
@Convert the logic in yyerror().  Instead of creating a temporary
format string, create a temporary message.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.4 2011/08/20 19:02:28 sthen Exp $ */
d25 1
d28 1
a29 7
#include "log.h"

static const char * const procnames[] = {
	"parent",
	"ripe",
	"rde"
};
d31 3
a33 2
int	debug;
int	verbose;
d143 1
a143 1
		logit(LOG_CRIT, "fatal in %s: %s", procnames[ripd_process],
d148 1
a148 1
			    procnames[ripd_process], emsg, strerror(errno));
d151 1
a151 1
			    procnames[ripd_process], emsg);
a163 61
}

/* names */
const char *
nbr_state_name(int state)
{
	switch (state) {
	case NBR_STA_DOWN:
		return ("DOWN");
	case NBR_STA_REQ_RCVD:
		return ("REQUEST RCVD");
	case NBR_STA_ACTIVE:
		return ("ACTIVE");
	default:
		return ("UNKNOWN");
	}
}

const char *
if_type_name(enum iface_type type)
{
	switch (type) {
	case IF_TYPE_POINTOPOINT:
		return ("POINTOPOINT");
	case IF_TYPE_BROADCAST:
		return ("BROADCAST");
	case IF_TYPE_NBMA:
		return ("NBMA");
	case IF_TYPE_POINTOMULTIPOINT:
		return ("POINTOMULTIPOINT");
	}
	/* NOTREACHED */
	return ("UNKNOWN");
}

const char *
if_auth_name(enum auth_type type)
{
	switch (type) {
	case AUTH_NONE:
		return ("none");
	case AUTH_SIMPLE:
		return ("simple");
	case AUTH_CRYPT:
		return ("crypt");
	}
	/* NOTREACHED */
	return ("unknown");
}

const char *
if_state_name(int state)
{
	switch (state) {
	case IF_STA_DOWN:
		return ("DOWN");
	case IF_STA_ACTIVE:
		return ("ACTIVE");
	default:
		return ("UNKNOWN");
	}
@


1.4
log
@Decouple log_verbose() from log_init() so the verbose flag stays set with
"-v" (previously only "-vd" worked). Similar to recent ospfd commit.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.3 2009/11/02 20:28:49 claudio Exp $ */
a37 2

void	logit(int, const char *, ...);
@


1.3
log
@Another routing daemon that gets IMSG_CTL_LOG_VERBOSE to allow toggeling of
log_debug(). ok michele, henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.2 2006/10/31 23:43:11 michele Exp $ */
a46 1
	verbose = n_debug;
@


1.2
log
@create a temporary neighbor instead of a permanent one when a request is received
@
text
@d1 1
a1 1
/*	$OpenBSD: log.c,v 1.1 2006/10/18 16:11:58 norby Exp $ */
d37 1
d47 1
d56 6
d139 1
a139 1
	if (debug) {
@


1.1
log
@Welcome ripd
started by Michele Marchetto some time ago by using the imsg/three process framework
of ospfd. He implemented most of the daemon with a little help and guidance from
Claudio and I.

Currently the daemon is more or less complete, with the exception of key lifetime
and rollover.

Not yet connected to the builds.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d172 2
@

