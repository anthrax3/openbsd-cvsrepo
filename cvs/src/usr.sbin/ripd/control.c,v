head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.2
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.4
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	OPENBSD_5_0:1.15.0.6
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2017.01.17.22.10.56;	author krw;	state Exp;
branches;
next	1.24;
commitid	nf3UdaW8au6U0a03;

1.24
date	2017.01.08.23.04.42;	author krw;	state Exp;
branches;
next	1.23;
commitid	T1ZdV0xhVeBLIhr0;

1.23
date	2016.08.02.16.05.32;	author jca;	state Exp;
branches;
next	1.22;
commitid	M3zXmxiZhTfusmGR;

1.22
date	2015.12.05.13.13.47;	author claudio;	state Exp;
branches;
next	1.21;
commitid	b7fx00QUWNpx3oj5;

1.21
date	2015.02.09.12.13.42;	author claudio;	state Exp;
branches;
next	1.20;
commitid	b41fu1pxXgU3PIfI;

1.20
date	2014.07.11.16.43.33;	author krw;	state Exp;
branches;
next	1.19;
commitid	TgA9QmI8ib2B7iAZ;

1.19
date	2013.11.19.22.25.32;	author benno;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2012.04.11.08.33.53;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2012.04.10.07.56.54;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.14.11.52.19;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.21.20.53.20;	author michele;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.08.15.54.50;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.02.19.10.02;	author mk;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.02.20.28.48;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.06.08.20.55;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.31.20.30.15;	author jacekm;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.31.17.06.01;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.25.17.09.55;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.31.12.17.35;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.24.20.20.32;	author claudio;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.17.19.57.54;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.19.10.10.29;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.23.17.38.10;	author claudio;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.16.11.58;	author norby;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Nuke some whitespace that keeps poking me in the eye as I try to
steal code.
@
text
@/*	$OpenBSD: control.c,v 1.24 2017/01/08 23:04:42 krw Exp $ */

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ripd.h"
#include "rip.h"
#include "ripe.h"
#include "log.h"
#include "control.h"

#define	CONTROL_BACKLOG	5

struct ctl_conn	*control_connbyfd(int);
struct ctl_conn	*control_connbypid(pid_t);
void		 control_close(int);

int
control_init(char *path)
{
	struct sockaddr_un	 sun;
	int			 fd;
	mode_t			 old_umask;

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,
	    0)) == -1) {
		log_warn("control_init: socket");
		return (-1);
	}

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, path, sizeof(sun.sun_path));

	if (unlink(path) == -1)
		if (errno != ENOENT) {
			log_warn("control_init: unlink %s", path);
			close(fd);
			return (-1);
		}

	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		log_warn("control_init: bind: %s", path);
		close(fd);
		umask(old_umask);
		return (-1);
	}
	umask(old_umask);

	if (chmod(path, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
		log_warn("control_init: chmod");
		close(fd);
		(void)unlink(path);
		return (-1);
	}

	control_state.fd = fd;

	return (0);
}

int
control_listen(void)
{

	if (listen(control_state.fd, CONTROL_BACKLOG) == -1) {
		log_warn("control_listen: listen");
		return (-1);
	}

	event_set(&control_state.ev, control_state.fd, EV_READ,
	    control_accept, NULL);
	event_add(&control_state.ev, NULL);
	evtimer_set(&control_state.evt, control_accept, NULL);

	return (0);
}

void
control_cleanup(char *path)
{
	event_del(&control_state.ev);
	event_del(&control_state.evt);
	unlink(path);
}

/* ARGSUSED */
void
control_accept(int listenfd, short event, void *bula)
{
	int			 connfd;
	socklen_t		 len;
	struct sockaddr_un	 sun;
	struct ctl_conn		*c;

	event_add(&control_state.ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	len = sizeof(sun);
	if ((connfd = accept4(listenfd, (struct sockaddr *)&sun, &len,
	    SOCK_CLOEXEC | SOCK_NONBLOCK)) == -1) {
		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval evtpause = { 1, 0 };

			event_del(&control_state.ev);
			evtimer_add(&control_state.evt, &evtpause);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			log_warn("control_accept: accept");
		return;
	}

	if ((c = calloc(1, sizeof(struct ctl_conn))) == NULL) {
		log_warn("control_accept");
		close(connfd);
		return;
	}

	imsg_init(&c->iev.ibuf, connfd);
	c->iev.handler = control_dispatch_imsg;
	c->iev.events = EV_READ;
	event_set(&c->iev.ev, c->iev.ibuf.fd, c->iev.events,
	    c->iev.handler, &c->iev);
	event_add(&c->iev.ev, NULL);

	TAILQ_INSERT_TAIL(&ctl_conns, c, entry);
}

struct ctl_conn *
control_connbyfd(int fd)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.fd == fd)
			break;
	}

	return (c);
}

struct ctl_conn *
control_connbypid(pid_t pid)
{
	struct ctl_conn	*c;

	TAILQ_FOREACH(c, &ctl_conns, entry) {
		if (c->iev.ibuf.pid == pid)
			break;
	}

	return (c);
}

void
control_close(int fd)
{
	struct ctl_conn	*c;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("control_close: fd %d: not found", fd);
		return;
	}

	msgbuf_clear(&c->iev.ibuf.w);
	TAILQ_REMOVE(&ctl_conns, c, entry);

	event_del(&c->iev.ev);
	close(c->iev.ibuf.fd);

	/* Some file descriptors are available again. */
	if (evtimer_pending(&control_state.evt, NULL)) {
		evtimer_del(&control_state.evt);
		event_add(&control_state.ev, NULL);
	}

	free(c);
}

/* ARGSUSED */
void
control_dispatch_imsg(int fd, short event, void *bula)
{
	struct ctl_conn	*c;
	struct imsg	 imsg;
	ssize_t		 n;
	unsigned int	 ifidx;
	int		 verbose;

	if ((c = control_connbyfd(fd)) == NULL) {
		log_warn("control_dispatch_imsg: fd %d: not found", fd);
		return;
	}

	if (event & EV_READ) {
		if (((n = imsg_read(&c->iev.ibuf)) == -1 && errno != EAGAIN) ||
		    n == 0) {
			control_close(fd);
			return;
		}
	}
	if (event & EV_WRITE) {
		if (msgbuf_write(&c->iev.ibuf.w) <= 0 && errno != EAGAIN) {
			control_close(fd);
			return;
		}
	}

	for (;;) {
		if ((n = imsg_get(&c->iev.ibuf, &imsg)) == -1) {
			control_close(fd);
			return;
		}

		if (n == 0)
			break;

		switch (imsg.hdr.type) {
		case IMSG_CTL_SHOW_INTERFACE:
			if (imsg.hdr.len - IMSG_HEADER_SIZE != sizeof(ifidx))
				return;

			memcpy(&ifidx, imsg.data, sizeof(ifidx));
			ripe_iface_ctl(c, ifidx);
			imsg_compose(&c->iev.ibuf, IMSG_CTL_END, 0, 0,
			    -1, NULL, 0);

			break;
		case IMSG_CTL_SHOW_RIB:
			c->iev.ibuf.pid = imsg.hdr.pid;
			ripe_imsg_compose_rde(imsg.hdr.type, 0,
			    imsg.hdr.pid, imsg.data, imsg.hdr.len -
			    IMSG_HEADER_SIZE);
			break;
		case IMSG_CTL_SHOW_NBR:
			ripe_nbr_ctl(c);
			break;
		case IMSG_CTL_KROUTE_ADDR:
		case IMSG_CTL_KROUTE:
		case IMSG_CTL_IFINFO:
			c->iev.ibuf.pid = imsg.hdr.pid;
			ripe_imsg_compose_parent(imsg.hdr.type,
			    imsg.hdr.pid, imsg.data,
			    imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
		case IMSG_CTL_FIB_COUPLE:
		case IMSG_CTL_FIB_DECOUPLE:
		case IMSG_CTL_RELOAD:
			c->iev.ibuf.pid = imsg.hdr.pid;
			ripe_imsg_compose_parent(imsg.hdr.type, 0, NULL, 0);
			break;
		case IMSG_CTL_LOG_VERBOSE:
			if (imsg.hdr.len != IMSG_HEADER_SIZE +
			    sizeof(verbose))
				break;

			/* forward to other processes */
			ripe_imsg_compose_parent(imsg.hdr.type, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);
			ripe_imsg_compose_rde(imsg.hdr.type, 0, imsg.hdr.pid,
			    imsg.data, imsg.hdr.len - IMSG_HEADER_SIZE);

			memcpy(&verbose, imsg.data, sizeof(verbose));
			log_verbose(verbose);
			break;
		default:
			log_debug("control_dispatch_imsg: "
			    "error handling imsg %d", imsg.hdr.type);
			break;
		}
		imsg_free(&imsg);
	}

	imsg_event_add(&c->iev);
}

int
control_imsg_relay(struct imsg *imsg)
{
	struct ctl_conn	*c;

	if ((c = control_connbypid(imsg->hdr.pid)) == NULL)
		return (0);

	return (imsg_compose_event(&c->iev, imsg->hdr.type, 0, imsg->hdr.pid,
	    -1, imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
}
@


1.24
log
@Replace hand-rolled for(;;) traversal of ctl_conns TAILQ with
TAILQ_FOREACH().

No intentional functional change.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.23 2016/08/02 16:05:32 jca Exp $ */
d294 1
a294 1
			break;		
@


1.23
log
@Allow specifying an alternate socket path.

This allows one to run multiple ripd instances, for example to serve
multiple rdomains.  Diff from Nima GHOTBI, ok claudio@@ florian@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.22 2015/12/05 13:13:47 claudio Exp $ */
d163 4
a166 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.fd != fd;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
d176 4
a179 3
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->iev.ibuf.pid != pid;
	    c = TAILQ_NEXT(c, entry))
		;	/* nothing */
@


1.22
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.21 2015/02/09 12:13:42 claudio Exp $ */
d42 1
a42 1
control_init(void)
d56 1
a56 1
	strlcpy(sun.sun_path, RIPD_SOCKET, sizeof(sun.sun_path));
d58 1
a58 1
	if (unlink(RIPD_SOCKET) == -1)
d60 1
a60 1
			log_warn("control_init: unlink %s", RIPD_SOCKET);
d67 1
a67 1
		log_warn("control_init: bind: %s", RIPD_SOCKET);
d74 1
a74 1
	if (chmod(RIPD_SOCKET, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP) == -1) {
d77 1
a77 1
		(void)unlink(RIPD_SOCKET);
d104 1
a104 1
control_cleanup(void)
d108 1
a108 1
	unlink(RIPD_SOCKET);
@


1.21
log
@More session_socket_blockmode() removal. While there make the main UDP
socket non-blocking by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.20 2014/07/11 16:43:33 krw Exp $ */
d223 2
a224 1
		if ((n = imsg_read(&c->iev.ibuf)) == -1 || n == 0) {
@


1.20
log
@Close the control fd when it has reported EOF.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.19 2013/11/19 22:25:32 benno Exp $ */
d48 2
a49 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
a80 1
	session_socket_blockmode(fd, BM_NONBLOCK);
d125 2
a126 2
	if ((connfd = accept(listenfd,
	    (struct sockaddr *)&sun, &len)) == -1) {
a141 2
	session_socket_blockmode(connfd, BM_NONBLOCK);

a312 17
}

void
session_socket_blockmode(int fd, enum blockmodes bm)
{
	int	flags;

	if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
		fatal("fcntl F_GETFL");

	if (bm == BM_NONBLOCK)
		flags |= O_NONBLOCK;
	else
		flags &= ~O_NONBLOCK;

	if ((flags = fcntl(fd, F_SETFL, flags)) == -1)
		fatal("fcntl F_SETFL");
@


1.19
log
@handle msgbuf_write() returning EAGAIN

"looks right" deraadt and sthen.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.18 2013/03/11 17:40:11 deraadt Exp $ */
d231 1
a231 1
		if (msgbuf_write(&c->iev.ibuf.w) == -1 && errno != EAGAIN) {
@


1.18
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.17 2012/04/11 08:33:53 deraadt Exp $ */
d231 1
a231 1
		if (msgbuf_write(&c->iev.ibuf.w) == -1) {
@


1.17
log
@delete excessive evtimer_pending; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.16 2012/04/10 07:56:54 deraadt Exp $ */
d136 2
a137 1
		} else if (errno != EWOULDBLOCK && errno != EINTR)
@


1.16
log
@Handle file descriptor exhaustion in the accept() case.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.15 2010/05/14 11:52:19 claudio Exp $ */
d107 1
a107 2
	if (evtimer_pending(&control_state.evt, NULL))
		event_del(&control_state.evt);
@


1.15
log
@Use calloc() instead of malloc() to allocate the connection structure. This
way the memory is zeroed. This is equivalent to the relayd commit by reyk.
OK reyk, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.14 2010/02/21 20:53:20 michele Exp $ */
d95 1
a95 1
	event_set(&control_state.ev, control_state.fd, EV_READ | EV_PERSIST,
d98 1
d106 3
d121 4
d128 10
a137 1
		if (errno != EWOULDBLOCK && errno != EINTR)
d199 7
@


1.14
log
@Kill double declaration of control_imsg_relay().

From Christiano F. Haesbaert.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.13 2009/12/08 15:54:50 jsg Exp $ */
d127 1
a127 1
	if ((c = malloc(sizeof(struct ctl_conn))) == NULL) {
@


1.13
log
@porcesses -> processes
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.12 2009/12/02 19:10:02 mk Exp $ */
a35 2

int control_imsg_relay(struct imsg *imsg);
@


1.12
log
@log_warn() consistency.

`OK' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.11 2009/11/02 20:28:48 claudio Exp $ */
d263 1
a263 1
			/* forward to other porcesses */
@


1.11
log
@Another routing daemon that gets IMSG_CTL_LOG_VERBOSE to allow toggeling of
log_debug(). ok michele, henning, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.10 2009/06/06 08:20:55 eric Exp $ */
d123 1
a123 1
			log_warn("control_accept");
@


1.10
log
@make ripctl/ripd imsg-in-a-lib ready too.

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.9 2009/05/31 20:30:15 jacekm Exp $ */
d195 1
d258 14
@


1.9
log
@Remove redundant imsg_event_add calls; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.8 2009/05/31 17:06:01 claudio Exp $ */
d135 6
a140 5
	imsg_init(&c->ibuf, connfd, control_dispatch_imsg);
	c->ibuf.events = EV_READ;
	event_set(&c->ibuf.ev, c->ibuf.fd, c->ibuf.events,
	    c->ibuf.handler, &c->ibuf);
	event_add(&c->ibuf.ev, NULL);
d150 1
a150 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.fd != fd;
d162 1
a162 1
	for (c = TAILQ_FIRST(&ctl_conns); c != NULL && c->ibuf.pid != pid;
d179 1
a179 1
	msgbuf_clear(&c->ibuf.w);
d182 2
a183 2
	event_del(&c->ibuf.ev);
	close(c->ibuf.fd);
d202 1
a202 1
		if ((n = imsg_read(&c->ibuf)) == -1 || n == 0) {
d208 1
a208 1
		if (msgbuf_write(&c->ibuf.w) == -1) {
d215 1
a215 1
		if ((n = imsg_get(&c->ibuf, &imsg)) == -1) {
d230 2
a231 1
			imsg_compose(&c->ibuf, IMSG_CTL_END, 0, 0, NULL, 0);
d235 1
a235 1
			c->ibuf.pid = imsg.hdr.pid;
d246 1
a246 1
			c->ibuf.pid = imsg.hdr.pid;
d254 1
a254 1
			c->ibuf.pid = imsg.hdr.pid;
d265 1
a265 1
	imsg_event_add(&c->ibuf);
d276 2
a277 2
	return (imsg_compose(&c->ibuf, imsg->hdr.type, 0, imsg->hdr.pid,
	    imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE));
@


1.8
log
@Better EV_READ and EV_WRITE handling in the libevent callbacks. Again mostly
the same ospfd diff applied with some fuzz.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.7 2009/02/25 17:09:55 claudio Exp $ */
a210 1
		imsg_event_add(&c->ibuf);
@


1.7
log
@Fix an invalid pointer dereference in control_close(). If control_connbyfd()
fails -- which should never happen -- the function does not return and is
accession the NULL set control pointer later on.
Found by Matthew Haub. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.6 2008/01/31 12:17:35 henning Exp $ */
d200 1
a200 2
	switch (event) {
	case EV_READ:
d205 3
a207 3
		break;
	case EV_WRITE:
		if (msgbuf_write(&c->ibuf.w) < 0) {
a211 3
		return;
	default:
		fatalx("unknown event");
@


1.6
log
@do not leak confd on malloc failure in control_accept()
found by Igor Zinovik <zinovik@@cs.karelia.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.5 2007/10/24 20:20:32 claudio Exp $ */
d173 1
a173 1
	if ((c = control_connbyfd(fd)) == NULL)
d175 2
@


1.5
log
@Use an ssize_t instead of int like in all other imsg handlers. Hint by lint
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.4 2007/10/17 19:57:54 claudio Exp $ */
d131 1
@


1.4
log
@Remove redundant code.
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.3 2007/03/19 10:10:29 henning Exp $ */
d189 1
a189 1
	int		 n;
@


1.3
log
@do not signal "connection closed" upstream on EINTR/EAGAIN, from bgpd et al
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.2 2007/01/23 17:38:10 claudio Exp $ */
a244 5
			c->ibuf.pid = imsg.hdr.pid;
			ripe_imsg_compose_parent(imsg.hdr.type,
			    imsg.hdr.pid, imsg.data,
			    imsg.hdr.len - IMSG_HEADER_SIZE);
			break;
@


1.2
log
@Typo in fatal() message found by dunceor @@ gmail dot com
@
text
@d1 1
a1 1
/*	$OpenBSD: control.c,v 1.1 2006/10/18 16:11:58 norby Exp $ */
d199 1
a199 1
		if ((n = imsg_read(&c->ibuf)) <= 0) {
@


1.1
log
@Welcome ripd
started by Michele Marchetto some time ago by using the imsg/three process framework
of ospfd. He implemented most of the daemon with a little help and guidance from
Claudio and I.

Currently the daemon is more or less complete, with the exception of key lifetime
and rollover.

Not yet connected to the builds.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d291 1
a291 1
		fatal("fnctl F_GETFL");
d299 1
a299 1
		fatal("fnctl F_SETFL");
@

