head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.12
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.20
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.18
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.14
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.12
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.6
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6;
locks; strict;
comment	@ * @;


1.12
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.11;
commitid	2uw1UTO4k6erpWzK;

1.11
date	2010.05.26.13.56.08;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.24.20.52.50;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.18.17.00.59;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.31.09.49.20;	author michele;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.11.15.55.52;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.10.10.28.18;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.03.15.21.25;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.31.23.43.11;	author michele;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.24.16.37.48;	author david;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.16.11.58;	author norby;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@/*	$OpenBSD: message.c,v 1.11 2010/05/26 13:56:08 nicm Exp $ */

/*
 * Copyright (c) 2006 Michele Marchetto <mydecay@@openbeer.it>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <netinet/udp.h>

#include <stdlib.h>
#include <string.h>

#include "ripd.h"
#include "rip.h"
#include "ripe.h"
#include "log.h"

extern struct ripd_conf	*oeconf;

void	 delete_entry(struct rip_route *);

/* timers */
/* ARGSUSED */
void
report_timer(int fd, short event, void *arg)
{
	struct timeval	 tv;

	ripe_imsg_compose_rde(IMSG_FULL_RESPONSE, 0, 0, NULL, 0);

	/* restart report timer */
	timerclear(&tv);
	tv.tv_sec = KEEPALIVE + arc4random_uniform(OFFSET);
	evtimer_add(&oeconf->report_timer, &tv);
}

int
start_report_timer(void)
{
	struct timeval	 tv;

	timerclear(&tv);
	tv.tv_sec = KEEPALIVE + arc4random_uniform(OFFSET);
	return (evtimer_add(&oeconf->report_timer, &tv));
}

/* list handlers */
void
add_entry(struct packet_head *r_list, struct rip_route *rr)
{
	struct packet_entry	*re;

	if (rr == NULL)
		fatalx("add_entry: no route report");

	if ((re = calloc(1, sizeof(*re))) == NULL)
		fatal("add_response");

	TAILQ_INSERT_TAIL(r_list, re, entry);
	re->rr = rr;
	rr->refcount++;
}

void
delete_entry(struct rip_route *rr)
{
	if (--rr->refcount == 0)
		free(rr);
}

void
clear_list(struct packet_head *r_list)
{
	struct packet_entry	*re;

	while ((re = TAILQ_FIRST(r_list)) != NULL) {
		TAILQ_REMOVE(r_list, re, entry);
		delete_entry(re->rr);
		free(re);
	}
}

/* communications */
int
send_triggered_update(struct iface *iface, struct rip_route *rr)
{
	struct sockaddr_in	 dst;
	struct ibuf		*buf;
	u_int16_t		 afi, route_tag;
	u_int32_t		 address, netmask, nexthop, metric;

	inet_aton(ALL_RIP_ROUTERS, &dst.sin_addr);

	dst.sin_port = htons(RIP_PORT);
	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);

	if (iface->passive)
		return (0);

	if ((buf = ibuf_open(iface->mtu - sizeof(struct ip) -
	    sizeof(struct udphdr))) == NULL)
		fatal("send_triggered_update");

	gen_rip_hdr(buf, COMMAND_RESPONSE);

	afi = htons(AF_INET);
	route_tag = 0;

	address = rr->address.s_addr;
	netmask = rr->mask.s_addr;
	nexthop = rr->nexthop.s_addr;
	metric = htonl(rr->metric);

	ibuf_add(buf, &afi, sizeof(afi));
	ibuf_add(buf, &route_tag, sizeof(route_tag));
	ibuf_add(buf, &address, sizeof(address));
	ibuf_add(buf, &netmask, sizeof(netmask));
	ibuf_add(buf, &nexthop, sizeof(nexthop));
	ibuf_add(buf, &metric, sizeof(metric));

	send_packet(iface, buf->buf, buf->wpos, &dst);
	ibuf_free(buf);

	return (0);
}

int
send_request(struct packet_head *r_list, struct iface *i, struct nbr *nbr)
{
	struct ibuf		*buf;
	struct iface		*iface;
	struct packet_entry	*entry;
	struct sockaddr_in	 dst;
	u_int8_t		 nentries;
	u_int8_t		 single_entry = 0;
	u_int32_t		 address, netmask, nexthop;
	u_int16_t		 port, afi, route_tag;
	u_int32_t		 metric;

	if (i == NULL) {
		/* directly to a nbr */
		iface = nbr->iface;
		dst.sin_addr = nbr->addr;
		port = htons(nbr->port);
	} else {
		/* multicast on interface */
		iface = i;
		inet_aton(ALL_RIP_ROUTERS, &dst.sin_addr);
		port = htons(RIP_PORT);
	}

	dst.sin_port = port;
	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);

	if (iface->passive)
		return (0);

	while (!TAILQ_EMPTY(r_list)) {
		if ((buf = ibuf_open(iface->mtu - sizeof(struct ip) -
		    sizeof(struct udphdr))) == NULL)
			fatal("send_request");

		gen_rip_hdr(buf, COMMAND_REQUEST);

		route_tag = 0;
		nentries = 0;

		if (TAILQ_FIRST(r_list) == TAILQ_LAST(r_list, packet_head))
			single_entry = 1;
		while (((entry = TAILQ_FIRST(r_list)) != NULL) &&
		    nentries < MAX_RIP_ENTRIES) {
			afi = htons(AF_INET);

			address = entry->rr->address.s_addr;
			netmask = entry->rr->mask.s_addr;
			nexthop = entry->rr->nexthop.s_addr;
			metric = htonl(entry->rr->metric);

			if (metric == htonl(INFINITY) && single_entry)
				afi = AF_UNSPEC;

			ibuf_add(buf, &afi, sizeof(afi));
			ibuf_add(buf, &route_tag, sizeof(route_tag));
			ibuf_add(buf, &address, sizeof(address));
			ibuf_add(buf, &netmask, sizeof(netmask));
			ibuf_add(buf, &nexthop, sizeof(nexthop));
			ibuf_add(buf, &metric, sizeof(metric));

			TAILQ_REMOVE(r_list, entry, entry);
			delete_entry(entry->rr);
			free(entry);
			nentries++;
		}
		send_packet(iface, buf->buf, buf->wpos, &dst);
		ibuf_free(buf);
	}

	return (0);
}

int
send_response(struct packet_head *r_list, struct iface *i, struct nbr *nbr)
{
	struct ibuf		*buf;
	struct iface		*iface;
	struct packet_entry	*entry;
	struct sockaddr_in	 dst;
	u_int8_t		 nentries;
	u_int16_t		 port, afi, route_tag;
	u_int32_t		 address, netmask, nexthop;
	u_int32_t		 metric;

	if (i == NULL) {
		/* directly to a nbr */
		iface = nbr->iface;
		dst.sin_addr = nbr->addr;
		port = htons(nbr->port);
	} else {
		/* multicast on interface */
		iface = i;
		inet_aton(ALL_RIP_ROUTERS, &dst.sin_addr);
		port = htons(RIP_PORT);
	}

	dst.sin_port = port;
	dst.sin_family = AF_INET;
	dst.sin_len = sizeof(struct sockaddr_in);

	if (iface->passive)
		return (0);

	while (!TAILQ_EMPTY(r_list)) {
		if ((buf = ibuf_open(iface->mtu - sizeof(struct ip) -
		    sizeof(struct udphdr))) == NULL)
			fatal("send_response");

		gen_rip_hdr(buf, COMMAND_RESPONSE);

		afi = htons(AF_INET);
		route_tag = 0;
		nentries = 0;

		if (iface->auth_type != AUTH_NONE) {
			if (auth_gen(buf, iface) == -1) {
				ibuf_free(buf);
				return (-1);
			}
			nentries++;
		}

		while ((entry = TAILQ_FIRST(r_list)) != NULL &&
		    nentries < MAX_RIP_ENTRIES) {
			address = entry->rr->address.s_addr;
			netmask = entry->rr->mask.s_addr;
			nexthop = entry->rr->nexthop.s_addr;
			metric = htonl(entry->rr->metric);

			if (entry->rr->ifindex == iface->ifindex) {
				if (oeconf->options & OPT_SPLIT_HORIZON)
					goto free;
				else if (oeconf->options & OPT_SPLIT_POISONED)
					metric = htonl(INFINITY);
			}

			/* If the nexthop is not reachable through the
			 * outgoing interface set it to INADDR_ANY */
			if ((nexthop & iface->mask.s_addr) !=
			    (iface->addr.s_addr & iface->mask.s_addr))
				nexthop = INADDR_ANY;

			ibuf_add(buf, &afi, sizeof(afi));
			ibuf_add(buf, &route_tag, sizeof(route_tag));
			ibuf_add(buf, &address, sizeof(address));
			ibuf_add(buf, &netmask, sizeof(netmask));
			ibuf_add(buf, &nexthop, sizeof(nexthop));
			ibuf_add(buf, &metric, sizeof(metric));
free:
			TAILQ_REMOVE(r_list, entry, entry);
			delete_entry(entry->rr);
			free(entry);
			nentries++;
		}

		if (iface->auth_type == AUTH_CRYPT)
			auth_add_trailer(buf, iface);

		send_packet(iface, buf->buf, buf->wpos, &dst);
		ibuf_free(buf);
	}

	return (0);
}

void
recv_request(struct iface *i, struct nbr *nbr, u_int8_t *buf, u_int16_t len)
{
	struct rip_entry	*e;
	struct rip_route	 rr;
	int			 l = len;

	bzero(&rr, sizeof(rr));

	if (len < RIP_ENTRY_LEN) {
		log_debug("recv_request: bad packet size, interface %s",
		    i->name);
		return;
	}

	/*
	 * XXX is it guaranteed that bus is properly aligned.
	 * If not this will bomb on strict alignment archs.
	 * */
	e = (struct rip_entry *)buf;

	if (len > RIP_ENTRY_LEN * MAX_RIP_ENTRIES) {
		log_debug("recv_request: packet too long\n");
		return;
	}

	l -= RIP_ENTRY_LEN;

	/*
	 * If there is exactly one entry in the request, and it has
	 * an address family identifier of zero and a metric of
	 * infinity (i.e., 16), then this is a request to send the
	 * entire routing table.
	 */
	if (e->AFI == 0 && e->metric == ntohl(INFINITY) && l == 0) {
		ripe_imsg_compose_rde(IMSG_FULL_RESPONSE, nbr->peerid,
		    0, NULL, 0);
		return;
	}

	for ( ; l >= 0; l -= RIP_ENTRY_LEN) {
		if (e->AFI != AF_INET) {
			log_debug("recv_request: AFI %d not supported\n",
			    e->AFI);
			return;
		}
		rr.address.s_addr = e->address;
		rr.mask.s_addr = e->mask;
		rr.nexthop.s_addr = e->nexthop;
		rr.metric = e->metric;
		rr.ifindex = i->ifindex;

		ripe_imsg_compose_rde(IMSG_ROUTE_REQUEST, nbr->peerid,
		    0, &rr, sizeof(rr));

		e++;
	}

	ripe_imsg_compose_rde(IMSG_ROUTE_REQUEST_END, nbr->peerid,
	    0, NULL, 0);
}

void
recv_response(struct iface *i, struct nbr *nbr, u_int8_t *buf, u_int16_t len)
{
	struct rip_route	 r;
	struct rip_entry	*e;
	int			 l;

	if (len < RIP_ENTRY_LEN) {
		log_debug("recv_response: bad packet size, interface %s",
		    i->name);
		return;
	}

	/* We must double check the length, because the only entry
	 * can be stripped off by authentication code
	 */
	if (len < RIP_ENTRY_LEN) {
		/* If there are no entries, our work is finished here */
		return;
	}

	/* XXX again */
	e = (struct rip_entry *)buf;

	if (len > RIP_ENTRY_LEN * MAX_RIP_ENTRIES) {
		log_debug("recv_response: packet too long\n");
		return;
	}

	l = len - sizeof(*e);

	for ( ; l >= 0; l -= RIP_ENTRY_LEN) {
		if (ntohs(e->AFI) != AF_INET) {
			log_debug("recv_response: AFI %d not supported\n",
			    e->AFI);
			return;
		}

		r.address.s_addr = e->address;
		r.mask.s_addr = e->mask;

		if (e->nexthop == INADDR_ANY ||
		    ((i->addr.s_addr & i->mask.s_addr) !=
		    (e->nexthop & i->mask.s_addr)))
			r.nexthop.s_addr = nbr->addr.s_addr;
		else
			r.nexthop.s_addr = e->nexthop;

		r.metric = ntohl(e->metric);
		r.ifindex = i->ifindex;

		ripe_imsg_compose_rde(IMSG_ROUTE_FEED, 0, 0, &r, sizeof(r));

		e++;
	}
}
@


1.11
log
@Rename some imsg bits to make namespace collisions less likely buf to
ibuf, buf_read to ibuf_read, READ_BUF_SIZE to IBUF_READ_SIZE.

ok henning gilles claudio jacekm deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.10 2008/04/13 00:22:17 djm Exp $ */
a21 1
#include <netinet/in_systm.h>
@


1.10
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.9 2007/10/24 20:52:50 claudio Exp $ */
d105 1
a105 1
	struct buf		*buf;
d118 1
a118 1
	if ((buf = buf_open(iface->mtu - sizeof(struct ip) -
d132 6
a137 6
	buf_add(buf, &afi, sizeof(afi));
	buf_add(buf, &route_tag, sizeof(route_tag));
	buf_add(buf, &address, sizeof(address));
	buf_add(buf, &netmask, sizeof(netmask));
	buf_add(buf, &nexthop, sizeof(nexthop));
	buf_add(buf, &metric, sizeof(metric));
d140 1
a140 1
	buf_free(buf);
d148 1
a148 1
	struct buf		*buf;
d178 1
a178 1
		if ((buf = buf_open(iface->mtu - sizeof(struct ip) -
d201 6
a206 6
			buf_add(buf, &afi, sizeof(afi));
			buf_add(buf, &route_tag, sizeof(route_tag));
			buf_add(buf, &address, sizeof(address));
			buf_add(buf, &netmask, sizeof(netmask));
			buf_add(buf, &nexthop, sizeof(nexthop));
			buf_add(buf, &metric, sizeof(metric));
d214 1
a214 1
		buf_free(buf);
d223 1
a223 1
	struct buf		*buf;
d252 1
a252 1
		if ((buf = buf_open(iface->mtu - sizeof(struct ip) -
d264 1
a264 1
				buf_free(buf);
d290 6
a295 6
			buf_add(buf, &afi, sizeof(afi));
			buf_add(buf, &route_tag, sizeof(route_tag));
			buf_add(buf, &address, sizeof(address));
			buf_add(buf, &netmask, sizeof(netmask));
			buf_add(buf, &nexthop, sizeof(nexthop));
			buf_add(buf, &metric, sizeof(metric));
d307 1
a307 1
		buf_free(buf);
@


1.9
log
@Make the packet buffer u_int8_t * everywhere. This is binary data and not
a string.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.8 2007/10/18 17:00:59 deraadt Exp $ */
d50 1
a50 1
	tv.tv_sec = KEEPALIVE + arc4random() % OFFSET;
d60 1
a60 1
	tv.tv_sec = KEEPALIVE + arc4random() % OFFSET;
@


1.8
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.7 2007/03/31 09:49:20 michele Exp $ */
d314 1
a314 1
recv_request(struct iface *i, struct nbr *nbr, char *buf, u_int16_t len)
d366 1
a366 1
		    0, (void *)&rr, sizeof(rr));
d376 1
a376 1
recv_response(struct iface *i, struct nbr *nbr, char *buf, u_int16_t len)
d426 1
a426 2
		ripe_imsg_compose_rde(IMSG_ROUTE_FEED, 0, 0, (void *)&r,
		    sizeof(r));
@


1.7
log
@Some code cleanups. Added one lint command, removed one unused function and
some other cosmetics.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.6 2006/11/11 15:55:52 michele Exp $ */
d44 1
a44 1
	struct timeval           tv;
d57 1
a57 1
	struct timeval  tv;
d92 1
a92 1
 
d118 2
a119 2
	if ((buf = buf_open(iface->mtu - sizeof(struct ip)
	    - sizeof(struct udphdr))) == NULL)
d178 2
a179 2
		if ((buf = buf_open(iface->mtu - sizeof(struct ip)
		    - sizeof(struct udphdr))) == NULL)
d223 1
a223 1
	struct buf              *buf;
d252 2
a253 2
		if ((buf = buf_open(iface->mtu - sizeof(struct ip)
		    - sizeof(struct udphdr))) == NULL)
d341 1
a341 1
        /*
@


1.6
log
@pass the right size of the message

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.5 2006/11/10 10:28:18 michele Exp $ */
d40 1
d263 2
a264 1
			if (auth_gen(buf, iface) < 0)
d266 1
@


1.5
log
@clear lists before deleting neighbor

OK claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.4 2006/11/03 15:21:25 michele Exp $ */
d424 1
a424 1
		    sizeof(*e));
@


1.4
log
@if the nexthop is not reachable through outgoing interface set it to
INADDR_ANY. Spotted out by Martin Boehme.

OK claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.3 2006/10/31 23:43:11 michele Exp $ */
d63 1
d87 13
@


1.3
log
@create a temporary neighbor instead of a permanent one when a request is received
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.2 2006/10/24 16:37:48 david Exp $ */
d254 1
a254 1
		    nentries < 25) {
d266 6
@


1.2
log
@spelling and typo fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.1 2006/10/18 16:11:58 norby Exp $ */
d175 1
a175 1
		    nentries < 25) {
@


1.1
log
@Welcome ripd started by Michele Marchetto some time ago by using the imsg/three process framework of ospfd. He implemented most of the daemon with a little help and guidance from Claudio and I. Currently the daemon is more or less complete, with the exception of key lifetime and rollover. Not yet connected to the builds. OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d307 1
a307 1
	 * If not this will bomb on strict aligenment archs.
@


