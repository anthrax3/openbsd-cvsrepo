head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.30
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.28
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.24
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.22
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.20
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.18
	OPENBSD_5_0:1.18.0.16
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.14
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.12
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.8
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.12.0.12
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.6
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2016.03.16.15.41.11;	author krw;	state Exp;
branches;
next	1.21;
commitid	JEVxsRygqcjPtWTf;

1.21
date	2015.12.19.20.38.35;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	Uh3VQ6rd60S309mW;

1.20
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	6b2lLILbgCR1fvia;

1.19
date	2014.10.08.04.55.03;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	PjMhl6cAGqJPnMrV;

1.18
date	2007.11.26.09.28.34;	author martynas;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.21.03.53.32;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.19.21.32.35;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.07.18.20.57;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.02.00.50.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.12.02.45.45;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.26.21.36.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.08.11.49.32;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.16.44.24;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.30.16.00.25;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.08.13.05.36.56;	author deraadt;	state Exp;
branches
	1.8.8.1;
next	1.7;

1.7
date	98.07.13.22.35.52;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.06.19.16.09.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.09.21.00.30.11;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.08.18.03.11.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.06.23.09.34.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.28.00.53.38;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.06.20.08.22.46;	author downsj;	state Exp;
branches;
next	;

1.8.8.1
date	2000.10.06.21.24.21;	author jason;	state Exp;
branches;
next	;


desc
@@


1.22
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@/*	$OpenBSD: fdformat.c,v 1.21 2015/12/19 20:38:35 mmcc Exp $	*/

/*
 * Copyright (C) 1992-1994 by Joerg Wunsch, Dresden
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * FreeBSD:
 * format a floppy disk
 * 
 * Added FD_GTYPE ioctl, verifying, proportional indicators.
 * Serge Vakulenko, vak@@zebub.msk.su
 * Sat Dec 18 17:45:47 MSK 1993
 *
 * Final adaptation, change format/verify logic, add separate
 * format gap/interleave values
 * Andrew A. Chernov, ache@@astral.msk.su
 * Thu Jan 27 00:47:24 MSK 1994
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <limits.h>
#include <ctype.h>
#include <err.h>
#include <util.h>

#include <errno.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <machine/ioctl_fd.h>

extern const char *__progname;

static void
format_track(int fd, int cyl, int secs, int head, int rate, int gaplen,
    int secsize, int fill, int interleave)
{
	struct fd_formb f;
	int i,j;
	int il[FD_MAX_NSEC + 1];

	memset(il,0,sizeof il);
	for(j = 0, i = 1; i <= secs; i++) {
		while(il[(j%secs)+1])
			j++;
		il[(j%secs)+1] = i;
		j += interleave;
        }

	f.format_version = FD_FORMAT_VERSION;
	f.head = head;
	f.cyl = cyl;
	f.transfer_rate = rate;

	f.fd_formb_secshift = secsize;
	f.fd_formb_nsecs = secs;
	f.fd_formb_gaplen = gaplen;
	f.fd_formb_fillbyte = fill;
	for(i = 0; i < secs; i++) {
		f.fd_formb_cylno(i) = cyl;
		f.fd_formb_headno(i) = head;
		f.fd_formb_secno(i) = il[i+1];
		f.fd_formb_secsize(i) = secsize;
	}
	if (ioctl(fd, FD_FORM, (caddr_t)&f) < 0)
		err(1, "FD_FORM");
}

static int
verify_track(int fd, int track, int tracksize)
{
	static char *buf = 0;
	static int bufsz = 0;
	int fdopts = -1, ofdopts, rv = 0;

	if (ioctl(fd, FD_GOPTS, &fdopts) < 0)
		warn("FD_GOPTS");
	else {
		ofdopts = fdopts;
		fdopts |= FDOPT_NORETRY;
		(void)ioctl(fd, FD_SOPTS, &fdopts);
	}
	
	if (bufsz < tracksize) {
		free(buf);
		bufsz = tracksize;
		buf = 0;
	}
	if (! buf)
		buf = malloc(bufsz);
	if (! buf) {
		fprintf (stderr, "\nfdformat: out of memory\n");
		exit (2);
	}
	if (lseek (fd, (off_t) track*tracksize, SEEK_SET) < 0)
		rv = -1;
	/* try twice reading it, without using the normal retrier */
	else if (read (fd, buf, tracksize) != tracksize
		 && read (fd, buf, tracksize) != tracksize)
		rv = -1;
	if (fdopts != -1)
		(void)ioctl(fd, FD_SOPTS, &ofdopts);
	return (rv);
}

static void
usage(void)
{
	printf("usage: %s [-nqv] [-c cyls] [-F fillbyte] [-g gap3len] ",
		__progname);
	printf("[-h heads]\n");
	printf("\t[-i intleave] [-r rate] [-S secshft] [-s secs]\n");
	printf("\t[-t steps_per_track] device_name\n");
	printf("Options:\n");
	printf("\t-n\tdon't verify floppy after formatting\n");
	printf("\t-q\tsuppress any normal output, don't ask for confirmation\n");
	printf("\t-v\tdon't format, verify only\n");
	printf("\tdevname\tthe full name of floppy device or in short form fd0, fd1\n");
	printf("Obscure options:\n");
	printf("\t-c #\tspecify number of cylinders, 40 or 80\n");
	printf("\t-F #\tspecify fill byte\n");
	printf("\t-g #\tspecify gap length\n");
	printf("\t-h #\tspecify number of floppy heads, 1 or 2\n");
	printf("\t-i #\tspecify interleave factor\n");
	printf("\t-r #\tspecify data rate, 250, 300 or 500 kbps\n");
	printf("\t-S #\tspecify sector size, 0=128, 1=256, 2=512 bytes\n");
	printf("\t-s #\tspecify number of sectors per track, 9, 10, 15 or 18\n");
	printf("\t-t #\tnumber of steps per track\n");
	exit(2);
}

static int
yes(void)
{
	char reply[256], *p;

	for (;;) {
		fflush(stdout);
		if (!fgets(reply, sizeof(reply), stdin))
			return (0);
		for (p=reply; *p==' ' || *p=='\t'; ++p)
			continue;
		if (*p=='y' || *p=='Y')
			return (1);
		if (*p=='n' || *p=='N' || *p=='\n' || *p=='\r')
			return (0);
		printf("Answer `yes' or `no': ");
	}
}

int
main(int argc, char *argv[])
{
	int cyls = -1, secs = -1, heads = -1, intleave = -1;
	int rate = -1, gaplen = -1, secsize = -1, steps = -1;
	int fill = 0xf6, quiet = 0, verify = 1, verify_only = 0;
	int fd, c, track, error, tracks_per_dot, bytes_per_track, errs;
	const char *errstr;
	char *devname;
	struct fd_type fdt;

	while((c = getopt(argc, argv, "c:s:h:r:g:S:F:t:i:qvn")) != -1)
		switch (c) {
		case 'c':       /* # of cyls */
			cyls = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-c %s: %s", optarg, errstr);
			break;

		case 's':       /* # of secs per track */
			secs = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-s %s: %s", optarg, errstr);
			break;

		case 'h':       /* # of heads */
			heads = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-h %s: %s", optarg, errstr);
			break;

		case 'r':       /* transfer rate, kilobyte/sec */
			rate = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-r %s: %s", optarg, errstr);
			break;

		case 'g':       /* length of GAP3 to format with */
			gaplen = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-g %s: %s", optarg, errstr);
			break;

		case 'S':       /* sector size shift factor (1 << S)*128 */
			secsize = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-S %s: %s", optarg, errstr);
			break;

		case 'F':       /* fill byte, C-like notation allowed */
			fill = (int)strtol(optarg, NULL, 0);
			break;

		case 't':       /* steps per track */
			steps = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-t %s: %s", optarg, errstr);
			break;

		case 'i':       /* interleave factor */
			intleave = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-i %s: %s", optarg, errstr);
			break;

		case 'q':
			quiet = 1;
			break;

		case 'n':
			verify = 0;
			break;

		case 'v':
			verify = 1;
			verify_only = 1;
			break;

		case '?': default:
			usage();
		}

	if (optind != argc - 1)
		usage();

	if ((fd = opendev(argv[optind], O_RDWR, OPENDEV_PART, &devname)) < 0)
		err(1, "%s", devname);

	if (ioctl(fd, FD_GTYPE, &fdt) < 0)
		errx(1, "not a floppy disk: %s", devname);

	switch (rate) {
	case -1:
		break;
	case 250:
		fdt.rate = FDC_250KBPS;
		break;
	case 300:
		fdt.rate = FDC_300KBPS;
		break;
	case 500:
		fdt.rate = FDC_500KBPS;
		break;
	default:
		errx(1, "invalid transfer rate: %d", rate);
	}

	if (cyls >= 0)
		fdt.tracks = cyls;
	if (secs >= 0)
		fdt.sectrac = secs;
	if (fdt.sectrac > FD_MAX_NSEC)
		errx(1, "too many sectors per track, max value is %d",
			FD_MAX_NSEC);
	if (heads >= 0)
		fdt.heads = heads;
	if (gaplen >= 0)
		fdt.gap2 = gaplen;
	if (secsize >= 0)
		fdt.secsize = secsize;
	if (steps >= 0)
		fdt.step = steps;

	bytes_per_track = fdt.sectrac * (1<<fdt.secsize) * 128;
	tracks_per_dot = fdt.tracks * fdt.heads / 40;
	if (tracks_per_dot == 0)
		tracks_per_dot++;

	if (verify_only) {
		if (!quiet)
			printf("Verify %dK floppy `%s'.\n",
				fdt.tracks * fdt.heads * bytes_per_track / 1024,
				devname);
	}
	else if (!quiet) {
		printf("Format %dK floppy `%s'? (y/n): ",
			fdt.tracks * fdt.heads * bytes_per_track / 1024,
			devname);
		if (!yes()) {
			printf("Not confirmed.\n");
			exit(0);
		}
	}

	/*
	 * Formatting.
	 */
	if (!quiet) {
		printf("Processing ");
		for (track = 0; track < fdt.tracks * fdt.heads; track++) {
			if (!((track + 1) % tracks_per_dot))
				putchar('-');
		}
		putchar('\r');
		printf("Processing ");
		fflush(stdout);
	}

	error = errs = 0;

	for (track = 0; track < fdt.tracks * fdt.heads; track++) {
		if (!verify_only) {
			format_track(fd, track / fdt.heads, fdt.sectrac,
				track % fdt.heads, fdt.rate, fdt.gap2,
				     fdt.secsize, fill,
				     intleave >= 0 ? intleave : 1);
			if (!quiet && !((track + 1) % tracks_per_dot)) {
				putchar('F');
				fflush(stdout);
			}
		}
		if (verify) {
			if (verify_track(fd, track, bytes_per_track) < 0)
				error = errs = 1;
			if (!quiet && !((track + 1) % tracks_per_dot)) {
				if (!verify_only)
					putchar('\b');
				if (error) {
					putchar('E');
					error = 0;
				}
				else
					putchar('V');
				fflush(stdout);
			}
		}
	}
	close(fd);
	if (!quiet)
		printf(" done.\n");

	exit(errs);
}
@


1.21
log
@Remove NULL-check before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.20 2015/04/18 18:28:38 deraadt Exp $	*/
d227 1
a227 1
			fill = (int)strtol(optarg, (char **)0, 0);
@


1.20
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.19 2014/10/08 04:55:03 deraadt Exp $	*/
d111 1
a111 2
		if (buf)
			free (buf);
@


1.19
log
@remove a space
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.18 2007/11/26 09:28:34 martynas Exp $	*/
d48 1
d185 1
d192 3
a194 1
			cyls = atoi(optarg);
d198 3
a200 1
			secs = atoi(optarg);
d204 3
a206 1
			heads = atoi(optarg);
d210 3
a212 1
			rate = atoi(optarg);
d216 3
a218 1
			gaplen = atoi(optarg);
d222 3
a224 1
			secsize = atoi(optarg);
d232 3
a234 1
			steps = atoi(optarg);
d238 3
a240 1
			intleave = atoi(optarg);
@


1.18
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.17 2007/02/21 03:53:32 ray Exp $	*/
d116 1
a116 1
		buf = malloc (bufsz);
@


1.17
log
@- Pass full buffer size to fgets.
- No need to initialize buffer.
- Spacing.

Based on diff from Charles Longeau <chl at tuxfamily dot org> long ago.

OK moritz@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.16 2007/02/19 21:32:35 jmc Exp $	*/
d142 1
a142 1
	printf("\t-q\tsupress any normal output, don't ask for confirmation\n");
@


1.16
log
@tidy up synopsis and usage(); reported by Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.15 2006/08/07 18:20:57 miod Exp $	*/
d161 1
a161 1
	char reply [256], *p;
a162 1
	reply[sizeof(reply)-1] = 0;
d165 1
a165 1
		if (! fgets (reply, sizeof(reply)-1, stdin))
@


1.15
log
@Avoid divide by zero in visual effects; spotted by Tobias Stoeckmann.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.14 2006/04/02 00:50:42 deraadt Exp $	*/
d135 1
a135 1
	printf("Usage:\n\t%s [-q] [-n | -v] [-c #] [-s #] [-h #]\n",
d137 3
a139 1
	printf("\t\t [-r #] [-g #] [-i #] [-S #] [-F #] [-t #] devname\n");
d141 1
a142 1
	printf("\t-n\tdon't verify floppy after formatting\n");
d147 2
a148 1
	printf("\t-s #\tspecify number of sectors per track, 9, 10, 15 or 18\n");
d150 1
a151 2
	printf("\t-g #\tspecify gap length\n");
	printf("\t-i #\tspecify interleave factor\n");
d153 1
a153 1
	printf("\t-F #\tspecify fill byte\n");
@


1.14
log
@use SEEK_* for lseek()
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.13 2006/03/12 02:45:45 deraadt Exp $	*/
d284 2
@


1.13
log
@missing close(); dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.12 2003/06/26 21:36:39 deraadt Exp $	*/
d121 1
a121 1
	if (lseek (fd, (off_t) track*tracksize, 0) < 0)
@


1.12
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.11 2003/03/08 11:49:32 matthieu Exp $	*/
d344 1
@


1.11
log
@fix fdformat usage(). Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.10 2002/03/14 16:44:24 mpech Exp $	*/
d60 2
a61 3
format_track(fd, cyl, secs, head, rate, gaplen, secsize, fill, interleave)
	int fd, cyl, secs, head, rate, gaplen, secsize;
	int fill, interleave;
d95 1
a95 2
verify_track(fd, track, tracksize)
	int fd, track, tracksize;
d133 1
a133 1
usage ()
d157 1
a157 1
yes ()
d177 1
a177 3
main(argc, argv)
	int argc;
	char *argv[];
@


1.10
log
@kill more registers.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.9 2000/06/30 16:00:25 millert Exp $	*/
a143 1
	printf("\t\tvalid choices are 360, 720, 800, 820, 1200, 1440, 1480, 1720\n");
@


1.9
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.8 1998/08/13 05:36:56 deraadt Exp $	*/
d65 1
a65 1
	register int i,j;
@


1.8
log
@fix exit code; fgsch@@olimpo.com.br
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.7 1998/07/13 22:35:52 deraadt Exp $	*/
d250 1
a250 1
		err(1, devname);
@


1.8.8.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.9 2000/06/30 16:00:25 millert Exp $	*/
d250 1
a250 1
		err(1, "%s", devname);
@


1.7
log
@fix bar printing, indent
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.6 1998/06/19 16:09:35 deraadt Exp $	*/
d156 1
a156 1
	exit(1);
@


1.6
log
@print correct status bar; blank@@fox.uni-trier.de
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.5 1997/09/21 00:30:11 millert Exp $	*/
d64 28
a91 27
        struct fd_formb f;
        register int i,j;
        int il[FD_MAX_NSEC + 1];

        memset(il,0,sizeof il);
        for(j = 0, i = 1; i <= secs; i++) {
            while(il[(j%secs)+1]) j++;
            il[(j%secs)+1] = i;
            j += interleave;
        }

        f.format_version = FD_FORMAT_VERSION;
        f.head = head;
        f.cyl = cyl;
        f.transfer_rate = rate;

        f.fd_formb_secshift = secsize;
        f.fd_formb_nsecs = secs;
        f.fd_formb_gaplen = gaplen;
        f.fd_formb_fillbyte = fill;
        for(i = 0; i < secs; i++) {
                f.fd_formb_cylno(i) = cyl;
                f.fd_formb_headno(i) = head;
                f.fd_formb_secno(i) = il[i+1];
                f.fd_formb_secsize(i) = secsize;
        }
        if(ioctl(fd, FD_FORM, (caddr_t)&f) < 0)
d99 3
a101 3
        static char *buf = 0;
        static int bufsz = 0;
        int fdopts = -1, ofdopts, rv = 0;
d103 1
a103 1
        if (ioctl(fd, FD_GOPTS, &fdopts) < 0)
d105 27
a131 27
        else {
                ofdopts = fdopts;
                fdopts |= FDOPT_NORETRY;
                (void)ioctl(fd, FD_SOPTS, &fdopts);
        }
        
        if (bufsz < tracksize) {
                if (buf)
                        free (buf);
                bufsz = tracksize;
                buf = 0;
        }
        if (! buf)
                buf = malloc (bufsz);
        if (! buf) {
                fprintf (stderr, "\nfdformat: out of memory\n");
                exit (2);
        }
        if (lseek (fd, (off_t) track*tracksize, 0) < 0)
                rv = -1;
        /* try twice reading it, without using the normal retrier */
        else if (read (fd, buf, tracksize) != tracksize
                 && read (fd, buf, tracksize) != tracksize)
                rv = -1;
        if(fdopts != -1)
                (void)ioctl(fd, FD_SOPTS, &ofdopts);
        return (rv);
d137 1
a137 1
        printf("Usage:\n\t%s [-q] [-n | -v] [-c #] [-s #] [-h #]\n",
d139 18
a156 18
        printf("\t\t [-r #] [-g #] [-i #] [-S #] [-F #] [-t #] devname\n");
        printf("Options:\n");
        printf("\t-q\tsupress any normal output, don't ask for confirmation\n");
        printf("\t-n\tdon't verify floppy after formatting\n");
        printf("\t-v\tdon't format, verify only\n");
        printf("\t\tvalid choices are 360, 720, 800, 820, 1200, 1440, 1480, 1720\n");
        printf("\tdevname\tthe full name of floppy device or in short form fd0, fd1\n");
        printf("Obscure options:\n");
        printf("\t-c #\tspecify number of cylinders, 40 or 80\n");
        printf("\t-s #\tspecify number of sectors per track, 9, 10, 15 or 18\n");
        printf("\t-h #\tspecify number of floppy heads, 1 or 2\n");
        printf("\t-r #\tspecify data rate, 250, 300 or 500 kbps\n");
        printf("\t-g #\tspecify gap length\n");
        printf("\t-i #\tspecify interleave factor\n");
        printf("\t-S #\tspecify sector size, 0=128, 1=256, 2=512 bytes\n");
        printf("\t-F #\tspecify fill byte\n");
        printf("\t-t #\tnumber of steps per track\n");
        exit(1);
d162 1
a162 1
        char reply [256], *p;
d164 13
a176 13
        reply[sizeof(reply)-1] = 0;
        for (;;) {
                fflush(stdout);
                if (! fgets (reply, sizeof(reply)-1, stdin))
                        return (0);
                for (p=reply; *p==' ' || *p=='\t'; ++p)
                        continue;
                if (*p=='y' || *p=='Y')
                        return (1);
                if (*p=='n' || *p=='N' || *p=='\n' || *p=='\r')
                        return (0);
                printf("Answer `yes' or `no': ");
        }
d184 57
a240 61
        int cyls = -1, secs = -1, heads = -1, intleave = -1;
        int rate = -1, gaplen = -1, secsize = -1, steps = -1;
        int fill = 0xf6, quiet = 0, verify = 1, verify_only = 0;
        int fd, c, track, error, tracks_per_dot, bytes_per_track, errs;
        char *devname;
        struct fd_type fdt;

        while((c = getopt(argc, argv, "c:s:h:r:g:S:F:t:i:qvn")) != -1)
                switch(c) {
                case 'c':       /* # of cyls */
                        cyls = atoi(optarg);
                        break;

                case 's':       /* # of secs per track */
                        secs = atoi(optarg);
                        break;

                case 'h':       /* # of heads */
                        heads = atoi(optarg);
                        break;

                case 'r':       /* transfer rate, kilobyte/sec */
                        rate = atoi(optarg);
                        break;

                case 'g':       /* length of GAP3 to format with */
                        gaplen = atoi(optarg);
                        break;

                case 'S':       /* sector size shift factor (1 << S)*128 */
                        secsize = atoi(optarg);
                        break;

                case 'F':       /* fill byte, C-like notation allowed */
                        fill = (int)strtol(optarg, (char **)0, 0);
                        break;

                case 't':       /* steps per track */
                        steps = atoi(optarg);
                        break;

                case 'i':       /* interleave factor */
                        intleave = atoi(optarg);
                        break;

                case 'q':
                        quiet = 1;
                        break;

                case 'n':
                        verify = 0;
                        break;

                case 'v':
                        verify = 1;
                        verify_only = 1;
                        break;

                case '?': default:
                        usage();
                }
d242 6
a247 2
        if(optind != argc - 1)
                usage();
d252 1
a252 1
        if(ioctl(fd, FD_GTYPE, &fdt) < 0)
d255 13
a267 6
        switch(rate) {
        case -1:  break;
        case 250: fdt.rate = FDC_250KBPS; break;
        case 300: fdt.rate = FDC_300KBPS; break;
        case 500: fdt.rate = FDC_500KBPS; break;
        default:
d269 1
a269 1
        }
d271 5
a275 3
        if (cyls >= 0)    fdt.tracks = cyls;
        if (secs >= 0)    fdt.sectrac = secs;
        if (fdt.sectrac > FD_MAX_NSEC)
d278 27
a304 23
        if (heads >= 0)   fdt.heads = heads;
        if (gaplen >= 0)  fdt.gap2 = gaplen;
        if (secsize >= 0) fdt.secsize = secsize;
        if (steps >= 0)   fdt.step = steps;

        bytes_per_track = fdt.sectrac * (1<<fdt.secsize) * 128;
        tracks_per_dot = fdt.tracks * fdt.heads / 40;

        if (verify_only) {
                if(!quiet)
                        printf("Verify %dK floppy `%s'.\n",
                                fdt.tracks * fdt.heads * bytes_per_track / 1024,
                                devname);
        }
        else if(!quiet) {
                printf("Format %dK floppy `%s'? (y/n): ",
                        fdt.tracks * fdt.heads * bytes_per_track / 1024,
                        devname);
                if(! yes ()) {
                        printf("Not confirmed.\n");
                        exit(0);
                }
        }
d306 5
a310 4
        /*
         * Formatting.
         */
        if(!quiet) {
d312 1
a312 1
			if ((track + 1) % tracks_per_dot)
d315 11
a325 10
                printf("Processing ");
                fflush(stdout);
        }

        error = errs = 0;

        for (track = 0; track < fdt.tracks * fdt.heads; track++) {
                if (!verify_only) {
                        format_track(fd, track / fdt.heads, fdt.sectrac,
                                track % fdt.heads, fdt.rate, fdt.gap2,
d328 23
a350 23
                        if(!quiet && !((track + 1) % tracks_per_dot)) {
                                putchar('F');
                                fflush(stdout);
                        }
                }
                if (verify) {
                        if (verify_track(fd, track, bytes_per_track) < 0)
                                error = errs = 1;
                        if(!quiet && !((track + 1) % tracks_per_dot)) {
                                if (!verify_only)
                                        putchar('\b');
                                if (error) {
                                        putchar('E');
                                        error = 0;
                                }
                                else
                                        putchar('V');
                                fflush(stdout);
                        }
                }
        }
        if(!quiet)
                printf(" done.\n");
d352 1
a352 1
        exit(errs);
@


1.5
log
@Make "fdformat fd0" work.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.4 1997/08/18 03:11:30 millert Exp $	*/
d296 4
a299 1
                printf("Processing ----------------------------------------\r");
@


1.4
log
@#include <string.h> not <strings.h> -- Yes, I'm a weanie...
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.3 1997/06/23 09:34:11 deraadt Exp $	*/
d50 1
d248 1
a248 2
	fd = opendev(argv[optind], O_RDWR, 0, &devname);
	if (fd < 0)
@


1.3
log
@off_t botch
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.2 1996/06/28 00:53:38 downsj Exp $	*/
d47 1
a47 1
#include <strings.h>
@


1.2
log
@cleanup: K&R function declarations; use opendev(); use err().
@
text
@d1 1
a1 1
/*	$OpenBSD: fdformat.c,v 1.1 1996/06/20 08:22:46 downsj Exp $	*/
d121 1
a121 1
        if (lseek (fd, (long) track*tracksize, 0) < 0)
@


1.1
log
@add fdformat for the i386: based on an old FreeBSD version, gotten from
jtk's port of dosemu; some cleaning by me, but it needs more.  Should
probably just be rewritten...
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
d56 2
d59 3
a61 2
format_track(int fd, int cyl, int secs, int head, int rate,
             int gaplen, int secsize, int fill,int interleave)
d89 2
a90 4
        if(ioctl(fd, FD_FORM, (caddr_t)&f) < 0) {
                perror("\nfdformat: ioctl(FD_FORM)");
                exit(1);
        }
d94 2
a95 1
verify_track(int fd, int track, int tracksize)
d102 1
a102 1
                perror("warning: ioctl(FD_GOPTS)");
a131 15
static const char *
makename(const char *arg)
{
        static char namebuff[20];       /* big enough for "/dev/rfd0a"... */

        memset(namebuff, 0, 20);
        if(*arg == '\0') /* ??? */
                return arg;
        if(*arg == '/')  /* do not convert absolute pathnames */
                return arg;
        strcpy(namebuff, "/dev/r");
        strncat(namebuff, arg, 3);
        return namebuff;
}

d133 1
a133 1
usage (void)
d135 2
a136 1
        printf("Usage:\n\tfdformat [-q] [-n | -v] [-f #] [-c #] [-s #] [-h #]\n");
a141 1
        printf("\t-f #\tspecify desired floppy capacity, in kilobytes;\n");
d154 1
a154 1
        exit(2);
d158 1
a158 1
yes (void)
d178 3
a180 1
main(int argc, char **argv)
d186 1
a186 1
        const char *devname;
d247 3
a249 1
        devname = makename(argv[optind]);
d251 2
a252 9
        if((fd = open(devname, O_RDWR)) < 0) {
                perror(devname);
                exit(1);
        }

        if(ioctl(fd, FD_GTYPE, &fdt) < 0) {
                fprintf(stderr, "fdformat: not a floppy disk: %s\n", devname);
                exit(1);
        }
d260 1
a260 2
                fprintf(stderr, "fdformat: invalid transfer rate: %d\n", rate);
                exit(2);
d265 3
a267 4
        if (fdt.sectrac > FD_MAX_NSEC) {
                fprintf(stderr, "fdformat: too many sectors per track, max value is %d\n", FD_MAX_NSEC);
                exit(2);
        }
d288 1
a288 1
                        return 0;
d333 1
a333 1
        return errs;
a334 15
/*
 * Local Variables:
 *  c-indent-level:               8
 *  c-continued-statement-offset: 8
 *  c-continued-brace-offset:     0
 *  c-brace-offset:              -8
 *  c-brace-imaginary-offset:     0
 *  c-argdecl-indent:             8
 *  c-label-offset:              -8
 *  c++-hanging-braces:           1
 *  c++-access-specifier-offset: -8
 *  c++-empty-arglist-indent:     8
 *  c++-friend-offset:            0
 * End:
 */
@
