head	1.52;
access;
symbols
	OPENBSD_6_2_BASE:1.52
	OPENBSD_6_1:1.50.0.4
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.52
date	2017.07.04.12.48.36;	author florian;	state Exp;
branches;
next	1.51;
commitid	iBpsLHx7QlkYyWrz;

1.51
date	2017.05.26.17.38.46;	author florian;	state Exp;
branches;
next	1.50;
commitid	N0RkgiLeoGfW3Ylk;

1.50
date	2016.09.04.14.40.34;	author florian;	state Exp;
branches;
next	1.49;
commitid	4zmH3cm7Cf5TL2le;

1.49
date	2016.08.16.08.23.18;	author reyk;	state Exp;
branches;
next	1.48;
commitid	EAdj7T4Vm523tLbL;

1.48
date	2015.11.20.09.04.01;	author tb;	state Exp;
branches;
next	1.47;
commitid	HtuBrqXX3ePzR4Fj;

1.47
date	2015.11.05.19.15.22;	author florian;	state Exp;
branches;
next	1.46;
commitid	3V63MnThncCnkzZ2;

1.46
date	2015.11.05.19.14.56;	author florian;	state Exp;
branches;
next	1.45;
commitid	4x1V9dSr2TTu4Yy1;

1.45
date	2015.09.25.20.15.28;	author millert;	state Exp;
branches;
next	1.44;
commitid	zgPmPe6cBPl9KH8p;

1.44
date	2015.01.22.18.22.27;	author florian;	state Exp;
branches;
next	1.43;
commitid	g8YaqoQUFSI1rWIB;

1.43
date	2015.01.19.21.18.47;	author guenther;	state Exp;
branches;
next	1.42;
commitid	R51OVDGCQeDBfXAb;

1.42
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Uu5nFG3wCl0LACBb;

1.41
date	2014.12.08.12.12.46;	author blambert;	state Exp;
branches;
next	1.40;
commitid	xe7QjWeTZUvEv29X;

1.40
date	2014.12.05.20.01.39;	author florian;	state Exp;
branches;
next	1.39;
commitid	PYjkcrr8y4gix3bd;

1.39
date	2014.12.05.19.59.55;	author florian;	state Exp;
branches;
next	1.38;
commitid	tG1FdIwYirxsUFub;

1.38
date	2014.12.05.19.58.47;	author florian;	state Exp;
branches;
next	1.37;
commitid	en5H4VWqIlvVjaYl;

1.37
date	2014.12.05.19.57.27;	author florian;	state Exp;
branches;
next	1.36;
commitid	p40r1sCQ0nDWVzfK;

1.36
date	2014.12.05.19.56.24;	author florian;	state Exp;
branches;
next	1.35;
commitid	NuGjHuxwmKOyKSta;

1.35
date	2014.09.19.21.28.32;	author florian;	state Exp;
branches;
next	1.34;
commitid	zlkAnJrgvfWgcMvb;

1.34
date	2014.07.13.21.46.25;	author claudio;	state Exp;
branches;
next	1.33;
commitid	heVlRT0Hd7Uz0LrI;

1.33
date	2014.06.10.14.38.27;	author florian;	state Exp;
branches;
next	1.32;
commitid	jSNYBWF4dnLcprQC;

1.32
date	2014.06.10.14.33.01;	author florian;	state Exp;
branches;
next	1.31;
commitid	tX75pAtRbzju23g4;

1.31
date	2014.04.16.14.43.43;	author florian;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.14.19.25.48;	author florian;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.13.08.46.20;	author florian;	state Exp;
branches;
next	1.28;

1.28
date	2014.03.17.13.39.29;	author florian;	state Exp;
branches;
next	1.27;

1.27
date	2014.01.19.00.01.05;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.31.21.53.16;	author florian;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.29.17.59.47;	author florian;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.23.15.29.21;	author florian;	state Exp;
branches;
next	1.23;

1.23
date	2013.10.21.18.19.27;	author florian;	state Exp;
branches;
next	1.22;

1.22
date	2013.10.21.18.17.58;	author florian;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.21.18.16.28;	author florian;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.20.16.47.24;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2013.10.20.09.36.29;	author benno;	state Exp;
branches;
next	1.18;

1.18
date	2013.10.19.14.18.35;	author florian;	state Exp;
branches;
next	1.17;

1.17
date	2013.10.18.14.48.54;	author florian;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.18.14.47.47;	author florian;	state Exp;
branches;
next	1.15;

1.15
date	2013.10.18.14.46.47;	author florian;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.18.14.44.36;	author florian;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.18.14.43.21;	author florian;	state Exp;
branches;
next	1.12;

1.12
date	2013.10.18.14.42.18;	author florian;	state Exp;
branches;
next	1.11;

1.11
date	2013.09.19.09.21.29;	author blambert;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.11.09.31.22;	author blambert;	state Exp;
branches;
next	1.9;

1.9
date	2013.09.06.12.17.28;	author blambert;	state Exp;
branches;
next	1.8;

1.8
date	2013.09.06.07.36.03;	author blambert;	state Exp;
branches;
next	1.7;

1.7
date	2013.08.30.07.10.26;	author blambert;	state Exp;
branches;
next	1.6;

1.6
date	2013.08.26.08.02.03;	author blambert;	state Exp;
branches;
next	1.5;

1.5
date	2013.08.23.07.12.49;	author blambert;	state Exp;
branches;
next	1.4;

1.4
date	2013.06.02.14.11.38;	author florian;	state Exp;
branches;
next	1.3;

1.3
date	2013.05.23.16.13.08;	author florian;	state Exp;
branches;
next	1.2;

1.2
date	2013.05.23.13.03.52;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2013.05.23.12.03.24;	author florian;	state Exp;
branches;
next	;


desc
@@


1.52
log
@consistently use the evtimer wrappers around the connection timeout.

this is instead of setting the timeout up with event_set and
event_add, but removing it with evtimer_del. this uses evtimer_set
and evtimer_add.

prompted by dlg's commit to identd
OK dlg
@
text
@/*	$OpenBSD: slowcgi.c,v 1.51 2017/05/26 17:38:46 florian Exp $ */
/*
 * Copyright (c) 2013 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2013 Florian Obser <florian@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <err.h>
#include <fcntl.h>
#include <errno.h>
#include <event.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#define TIMEOUT_DEFAULT		 120
#define SLOWCGI_USER		 "www"

#define FCGI_CONTENT_SIZE	 65535
#define FCGI_PADDING_SIZE	 255
#define FCGI_RECORD_SIZE	 \
    (sizeof(struct fcgi_record_header) + FCGI_CONTENT_SIZE + FCGI_PADDING_SIZE)

#define FCGI_ALIGNMENT		 8
#define FCGI_ALIGN(n)		 \
    (((n) + (FCGI_ALIGNMENT - 1)) & ~(FCGI_ALIGNMENT - 1))

#define STDOUT_DONE		 1
#define STDERR_DONE		 2
#define SCRIPT_DONE		 4

#define FCGI_BEGIN_REQUEST	 1
#define FCGI_ABORT_REQUEST	 2
#define FCGI_END_REQUEST	 3
#define FCGI_PARAMS		 4
#define FCGI_STDIN		 5
#define FCGI_STDOUT		 6
#define FCGI_STDERR		 7
#define FCGI_DATA		 8
#define FCGI_GET_VALUES		 9
#define FCGI_GET_VALUES_RESULT	10
#define FCGI_UNKNOWN_TYPE	11
#define FCGI_MAXTYPE		(FCGI_UNKNOWN_TYPE)

#define FCGI_REQUEST_COMPLETE	0
#define FCGI_CANT_MPX_CONN	1
#define FCGI_OVERLOADED		2
#define FCGI_UNKNOWN_ROLE	3

#define FD_RESERVE		5
#define FD_NEEDED		6
int cgi_inflight = 0;

struct listener {
	struct event	ev, pause;
};

struct env_val {
	SLIST_ENTRY(env_val)	 entry;
	char			*val;
};
SLIST_HEAD(env_head, env_val);

struct fcgi_record_header {
	uint8_t		version;
	uint8_t		type;
	uint16_t	id;
	uint16_t	content_len;
	uint8_t		padding_len;
	uint8_t		reserved;
}__packed;

struct fcgi_response {
	TAILQ_ENTRY(fcgi_response)	entry;
	uint8_t				data[FCGI_RECORD_SIZE];
	size_t				data_pos;
	size_t				data_len;
};
TAILQ_HEAD(fcgi_response_head, fcgi_response);

struct fcgi_stdin {
	TAILQ_ENTRY(fcgi_stdin)	entry;
	uint8_t			data[FCGI_RECORD_SIZE];
	size_t			data_pos;
	size_t			data_len;
};
TAILQ_HEAD(fcgi_stdin_head, fcgi_stdin);

struct request {
	struct event			ev;
	struct event			resp_ev;
	struct event			tmo;
	int				fd;
	uint8_t				buf[FCGI_RECORD_SIZE];
	size_t				buf_pos;
	size_t				buf_len;
	struct fcgi_response_head	response_head;
	struct fcgi_stdin_head		stdin_head;
	uint16_t			id;
	char				script_name[PATH_MAX];
	struct env_head			env;
	int				env_count;
	pid_t				script_pid;
	int				script_status;
	struct event			script_ev;
	struct event			script_err_ev;
	struct event			script_stdin_ev;
	int				stdin_fd_closed;
	int				stdout_fd_closed;
	int				stderr_fd_closed;
	uint8_t				script_flags;
	uint8_t				request_started;
	int				inflight_fds_accounted;
};

struct requests {
	SLIST_ENTRY(requests)	 entry;
	struct request		*request;
};
SLIST_HEAD(requests_head, requests);

struct slowcgi_proc {
	struct requests_head	requests;
	struct event		ev_sigchld;
	struct event		ev_sigpipe;
};

struct fcgi_begin_request_body {
	uint16_t	role;
	uint8_t		flags;
	uint8_t		reserved[5];
}__packed;

struct fcgi_end_request_body {
	uint32_t	app_status;
	uint8_t		protocol_status;
	uint8_t		reserved[3];
}__packed;

__dead void	usage(void);
int		slowcgi_listen(char *, struct passwd *);
void		slowcgi_paused(int, short, void *);
int		accept_reserve(int, struct sockaddr *, socklen_t *, int,
		    volatile int *);
void		slowcgi_accept(int, short, void *);
void		slowcgi_request(int, short, void *);
void		slowcgi_response(int, short, void *);
void		slowcgi_add_response(struct request *, struct fcgi_response *);
void		slowcgi_timeout(int, short, void *);
void		slowcgi_sig_handler(int, short, void *);
size_t		parse_record(uint8_t * , size_t, struct request *);
void		parse_begin_request(uint8_t *, uint16_t, struct request *,
		    uint16_t);
void		parse_params(uint8_t *, uint16_t, struct request *, uint16_t);
void		parse_stdin(uint8_t *, uint16_t, struct request *, uint16_t);
void		exec_cgi(struct request *);
void		script_in(int, struct event *, struct request *, uint8_t);
void		script_std_in(int, short, void *);
void		script_err_in(int, short, void *);
void		script_out(int, short, void *);
void		create_end_record(struct request *);
void		dump_fcgi_record(const char *,
		    struct fcgi_record_header *);
void		dump_fcgi_record_header(const char *,
		    struct fcgi_record_header *);
void		dump_fcgi_begin_request_body(const char *,
		    struct fcgi_begin_request_body *);
void		dump_fcgi_end_request_body(const char *,
		    struct fcgi_end_request_body *);
void		cleanup_request(struct request *);

struct loggers {
	__dead void (*err)(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
	__dead void (*errx)(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
	void (*warn)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
	void (*warnx)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
	void (*info)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
	void (*debug)(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
};

const struct loggers conslogger = {
	err,
	errx,
	warn,
	warnx,
	warnx, /* info */
	warnx /* debug */
};

__dead void	syslog_err(int, const char *, ...)
		    __attribute__((__format__ (printf, 2, 3)));
__dead void	syslog_errx(int, const char *, ...)
		    __attribute__((__format__ (printf, 2, 3)));
void		syslog_warn(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_warnx(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_info(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_debug(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		syslog_vstrerror(int, int, const char *, va_list)
		    __attribute__((__format__ (printf, 3, 0)));

const struct loggers syslogger = {
	syslog_err,
	syslog_errx,
	syslog_warn,
	syslog_warnx,
	syslog_info,
	syslog_debug
};

const struct loggers *logger = &conslogger;

#define lerr(_e, _f...) logger->err((_e), _f)
#define lerrx(_e, _f...) logger->errx((_e), _f)
#define lwarn(_f...) logger->warn(_f)
#define lwarnx(_f...) logger->warnx(_f)
#define linfo(_f...) logger->info(_f)
#define ldebug(_f...) logger->debug(_f)

__dead void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-d] [-p path] [-s socket] [-u user]\n",
	    __progname);
	exit(1);
}

struct timeval		timeout = { TIMEOUT_DEFAULT, 0 };
struct slowcgi_proc	slowcgi_proc;
int			debug = 0;
int			on = 1;
char			*fcgi_socket = "/var/www/run/slowcgi.sock";

int
main(int argc, char *argv[])
{
	extern char *__progname;
	struct listener	*l = NULL;
	struct passwd	*pw;
	struct stat	 sb;
	int		 c, fd;
	const char	*chrootpath = NULL;
	const char	*slowcgi_user = SLOWCGI_USER;

	/*
	 * Ensure we have fds 0-2 open so that we have no fd overlaps
	 * in exec_cgi() later. Just exit on error, we don't have enough
	 * fds open to output an error message anywhere.
	 */
	for (c=0; c < 3; c++) {
		if (fstat(c, &sb) == -1) {
			if ((fd = open("/dev/null", O_RDWR)) != -1) {
				if (dup2(fd, c) == -1)
					exit(1);
				if (fd > c)
					close(fd);
			} else
				exit(1);
		}
	}

	while ((c = getopt(argc, argv, "dp:s:u:")) != -1) {
		switch (c) {
		case 'd':
			debug = 1;
			break;
		case 'p':
			chrootpath = optarg;
			break;
		case 's':
			fcgi_socket = optarg;
			break;
		case 'u':
			slowcgi_user = optarg;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	if (geteuid() != 0)
		errx(1, "need root privileges");

	if (!debug && daemon(1, 0) == -1)
		err(1, "daemon");

	if (!debug) {
		openlog(__progname, LOG_PID|LOG_NDELAY, LOG_DAEMON);
		logger = &syslogger;
	}

	pw = getpwnam(SLOWCGI_USER);
	if (pw == NULL)
		lerrx(1, "no %s user", SLOWCGI_USER);

	fd = slowcgi_listen(fcgi_socket, pw);

	lwarnx("slowcgi_user: %s", slowcgi_user);
	pw = getpwnam(slowcgi_user);
	if (pw == NULL)
		lerrx(1, "no %s user", slowcgi_user);

	if (chrootpath == NULL)
		chrootpath = pw->pw_dir;

	if (chroot(chrootpath) == -1)
		lerr(1, "chroot(%s)", chrootpath);

	ldebug("chroot: %s", chrootpath);

	if (chdir("/") == -1)
		lerr(1, "chdir(/)");

	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		lerr(1, "unable to revoke privs");

	if (pledge("stdio rpath unix proc exec", NULL) == -1)
		lerr(1, "pledge");

	SLIST_INIT(&slowcgi_proc.requests);
	event_init();

	l = calloc(1, sizeof(*l));
	if (l == NULL)
		lerr(1, "listener ev alloc");

	event_set(&l->ev, fd, EV_READ | EV_PERSIST, slowcgi_accept, l);
	event_add(&l->ev, NULL);
	evtimer_set(&l->pause, slowcgi_paused, l);

	signal_set(&slowcgi_proc.ev_sigchld, SIGCHLD, slowcgi_sig_handler,
	    &slowcgi_proc);
	signal_set(&slowcgi_proc.ev_sigpipe, SIGPIPE, slowcgi_sig_handler,
	    &slowcgi_proc);

	signal_add(&slowcgi_proc.ev_sigchld, NULL);
	signal_add(&slowcgi_proc.ev_sigpipe, NULL);

	event_dispatch();
	return (0);
}

int
slowcgi_listen(char *path, struct passwd *pw)
{
	struct sockaddr_un	 sun;
	mode_t			 old_umask;
	int			 fd;

	if ((fd = socket(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC,
	    0)) == -1)
		lerr(1, "slowcgi_listen: socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	if (strlcpy(sun.sun_path, path, sizeof(sun.sun_path)) >=
	    sizeof(sun.sun_path))
		lerrx(1, "socket path too long");

	if (unlink(path) == -1)
		if (errno != ENOENT)
			lerr(1, "slowcgi_listen: unlink %s", path);

	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|
	    S_IXOTH);

	if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		lerr(1,"slowcgi_listen: bind: %s", path);

	umask(old_umask);

	if (chown(path, pw->pw_uid, pw->pw_gid) == -1)
		lerr(1, "slowcgi_listen: chown: %s", path);

	if (listen(fd, 5) == -1)
		lerr(1, "listen");

	ldebug("socket: %s", path);
	return fd;
}

void
slowcgi_paused(int fd, short events, void *arg)
{
	struct listener	*l = arg;
	event_add(&l->ev, NULL);
}

int
accept_reserve(int sockfd, struct sockaddr *addr, socklen_t *addrlen,
	int reserve, volatile int *counter)
{
	int ret;
	if (getdtablecount() + reserve +
	    (*counter * FD_NEEDED) >= getdtablesize()) {
		ldebug("inflight fds exceeded");
		errno = EMFILE;
		return -1;
	}

	if ((ret = accept4(sockfd, addr, addrlen, SOCK_NONBLOCK | SOCK_CLOEXEC))
	    > -1) {
		(*counter)++;
		ldebug("inflight incremented, now %d", *counter);
	}
	return ret;
}

void
slowcgi_accept(int fd, short events, void *arg)
{
	struct listener		*l;
	struct sockaddr_storage	 ss;
	struct timeval		 backoff;
	struct request		*c;
	struct requests		*requests;
	socklen_t		 len;
	int			 s;

	l = arg;
	backoff.tv_sec = 1;
	backoff.tv_usec = 0;
	c = NULL;

	len = sizeof(ss);
	if ((s = accept_reserve(fd, (struct sockaddr *)&ss,
	    &len, FD_RESERVE, &cgi_inflight)) == -1) {
		switch (errno) {
		case EINTR:
		case EWOULDBLOCK:
		case ECONNABORTED:
			return;
		case EMFILE:
		case ENFILE:
			event_del(&l->ev);
			evtimer_add(&l->pause, &backoff);
			return;
		default:
			lerr(1, "accept");
		}
	}

	c = calloc(1, sizeof(*c));
	if (c == NULL) {
		lwarn("cannot calloc request");
		close(s);
		cgi_inflight--;
		return;
	}
	requests = calloc(1, sizeof(*requests));
	if (requests == NULL) {
		lwarn("cannot calloc requests");
		close(s);
		cgi_inflight--;
		free(c);
		return;
	}
	c->fd = s;
	c->buf_pos = 0;
	c->buf_len = 0;
	c->request_started = 0;
	c->stdin_fd_closed = c->stdout_fd_closed = c->stderr_fd_closed = 0;
	c->inflight_fds_accounted = 0;
	TAILQ_INIT(&c->response_head);
	TAILQ_INIT(&c->stdin_head);

	event_set(&c->ev, s, EV_READ | EV_PERSIST, slowcgi_request, c);
	event_add(&c->ev, NULL);
	event_set(&c->resp_ev, s, EV_WRITE | EV_PERSIST, slowcgi_response, c);
	evtimer_set(&c->tmo, slowcgi_timeout, c);
	evtimer_add(&c->tmo, &timeout);
	requests->request = c;
	SLIST_INSERT_HEAD(&slowcgi_proc.requests, requests, entry);
}

void
slowcgi_timeout(int fd, short events, void *arg)
{
	cleanup_request((struct request*) arg);
}

void
slowcgi_sig_handler(int sig, short event, void *arg)
{
	struct request		*c;
	struct requests		*ncs;
	struct slowcgi_proc	*p;
	pid_t			 pid;
	int			 status;

	p = arg;

	switch (sig) {
	case SIGCHLD:
		while ((pid = waitpid(WAIT_ANY, &status, WNOHANG)) > 0) {
			c = NULL;
			SLIST_FOREACH(ncs, &p->requests, entry)
				if (ncs->request->script_pid == pid) {
					c = ncs->request;
					break;
				}
			if (c == NULL) {
				lwarnx("caught exit of unknown child %i", pid);
				continue;
			}

			if (WIFSIGNALED(status))
				c->script_status = WTERMSIG(status);
			else
				c->script_status = WEXITSTATUS(status);

			if (c->script_flags == (STDOUT_DONE | STDERR_DONE))
				create_end_record(c);
			c->script_flags |= SCRIPT_DONE;

			ldebug("wait: %s", c->script_name);
		}
		if (pid == -1 && errno != ECHILD)
			lwarn("waitpid");
		break;
	case SIGPIPE:
		/* ignore */
		break;
	default:
		lerr(1, "unexpected signal: %d", sig);
		break;
	}
}

void
slowcgi_add_response(struct request *c, struct fcgi_response *resp)
{
	struct fcgi_record_header	*header;
	size_t				 padded_len;

	header = (struct fcgi_record_header*)resp->data;

	/* The FastCGI spec suggests to align the output buffer */
	padded_len = FCGI_ALIGN(resp->data_len);
	if (padded_len > resp->data_len) {
		/* There should always be FCGI_PADDING_SIZE bytes left */
		if (padded_len > FCGI_RECORD_SIZE)
			lerr(1, "response too long");
		header->padding_len = padded_len - resp->data_len;
		resp->data_len = padded_len;
	}

	TAILQ_INSERT_TAIL(&c->response_head, resp, entry);
	event_add(&c->resp_ev, NULL);
}

void
slowcgi_response(int fd, short events, void *arg)
{
	struct request			*c;
	struct fcgi_record_header	*header;
	struct fcgi_response		*resp;
	ssize_t				 n;

	c = arg;

	while ((resp = TAILQ_FIRST(&c->response_head))) {
		header = (struct fcgi_record_header*) resp->data;
		if (debug)
			dump_fcgi_record("resp ", header);

		n = write(fd, resp->data + resp->data_pos, resp->data_len);
		if (n == -1) {
			if (errno == EAGAIN || errno == EINTR)
				return;
			cleanup_request(c);
			return;
		}
		resp->data_pos += n;
		resp->data_len -= n;
		if (resp->data_len == 0) {
			TAILQ_REMOVE(&c->response_head, resp, entry);
			free(resp);
		}
	}

	if (TAILQ_EMPTY(&c->response_head)) {
		if (c->script_flags == (STDOUT_DONE | STDERR_DONE |
		    SCRIPT_DONE))
			cleanup_request(c);
		else
			event_del(&c->resp_ev);
	}
}

void
slowcgi_request(int fd, short events, void *arg)
{
	struct request	*c;
	ssize_t		 n;
	size_t		 parsed;

	c = arg;

	n = read(fd, c->buf + c->buf_pos + c->buf_len,
	    FCGI_RECORD_SIZE - c->buf_pos-c->buf_len);

	switch (n) {
	case -1:
		switch (errno) {
		case EINTR:
		case EAGAIN:
			return;
		default:
			goto fail;
		}
		break;

	case 0:
		ldebug("closed connection");
		goto fail;
	default:
		break;
	}

	c->buf_len += n;

	/*
	 * Parse the records as they are received. Per the FastCGI
	 * specification, the server need only receive the FastCGI
	 * parameter records in full; it is free to begin execution
	 * at that point, which is what happens here.
	 */
	do {
		parsed = parse_record(c->buf + c->buf_pos, c->buf_len, c);
		c->buf_pos += parsed;
		c->buf_len -= parsed;
	} while (parsed > 0 && c->buf_len > 0);

	/* Make space for further reads */
	if (c->buf_len > 0) {
		bcopy(c->buf + c->buf_pos, c->buf, c->buf_len);
		c->buf_pos = 0;
	}
	return;
fail:
	cleanup_request(c);
}

void
parse_begin_request(uint8_t *buf, uint16_t n, struct request *c, uint16_t id)
{
	/* XXX -- FCGI_CANT_MPX_CONN */
	if (c->request_started) {
		lwarnx("unexpected FCGI_BEGIN_REQUEST, ignoring");
		return;
	}

	if (n != sizeof(struct fcgi_begin_request_body)) {
		lwarnx("wrong size %d != %lu", n,
		    sizeof(struct fcgi_begin_request_body));
		return;
	}

	c->request_started = 1;

	c->id = id;
	SLIST_INIT(&c->env);
	c->env_count = 0;
}
void
parse_params(uint8_t *buf, uint16_t n, struct request *c, uint16_t id)
{
	struct env_val			*env_entry;
	uint32_t			 name_len, val_len;

	if (!c->request_started) {
		lwarnx("FCGI_PARAMS without FCGI_BEGIN_REQUEST, ignoring");
		return;
	}

	if (c->id != id) {
		lwarnx("unexpected id, ignoring");
		return;
	}

	/*
	 * If this is the last FastCGI parameter record,
	 * begin execution of the CGI script.
	 */
	if (n == 0) {
		exec_cgi(c);
		return;
	}

	while (n > 0) {
		if (buf[0] >> 7 == 0) {
			name_len = buf[0];
			n--;
			buf++;
		} else {
			if (n > 3) {
				name_len = ((buf[0] & 0x7f) << 24) +
				    (buf[1] << 16) + (buf[2] << 8) + buf[3];
				n -= 4;
				buf += 4;
			} else
				return;
		}

		if (n > 0) {
			if (buf[0] >> 7 == 0) {
				val_len = buf[0];
				n--;
				buf++;
			} else {
				if (n > 3) {
					val_len = ((buf[0] & 0x7f) << 24) +
					    (buf[1] << 16) + (buf[2] << 8) +
					     buf[3];
					n -= 4;
					buf += 4;
				} else
					return;
			}
		} else
			return;

		if (n < name_len + val_len)
			return;

		if ((env_entry = malloc(sizeof(struct env_val))) == NULL) {
			lwarnx("cannot allocate env_entry");
			return;
		}

		if ((env_entry->val = calloc(sizeof(char), name_len + val_len +
		    2)) == NULL) {
			lwarnx("cannot allocate env_entry->val");
			free(env_entry);
			return;
		}

		bcopy(buf, env_entry->val, name_len);
		buf += name_len;
		n -= name_len;

		env_entry->val[name_len] = '\0';
		if (val_len < PATH_MAX && strcmp(env_entry->val,
		    "SCRIPT_NAME") == 0 && c->script_name[0] == '\0') {
			bcopy(buf, c->script_name, val_len);
			c->script_name[val_len] = '\0';
		} else if (val_len < PATH_MAX && strcmp(env_entry->val,
		    "SCRIPT_FILENAME") == 0) {
			bcopy(buf, c->script_name, val_len);
			c->script_name[val_len] = '\0';
		}
		env_entry->val[name_len] = '=';

		bcopy(buf, (env_entry->val) + name_len + 1, val_len);
		buf += val_len;
		n -= val_len;

		SLIST_INSERT_HEAD(&c->env, env_entry, entry);
		ldebug("env[%d], %s", c->env_count, env_entry->val);
		c->env_count++;
	}
}

void
parse_stdin(uint8_t *buf, uint16_t n, struct request *c, uint16_t id)
{
	struct fcgi_stdin	*node;

	if (c->id != id) {
		lwarnx("unexpected id, ignoring");
		return;
	}

	if ((node = calloc(1, sizeof(struct fcgi_stdin))) == NULL) {
		lwarnx("cannot calloc stdin node");
		return;
	}

	bcopy(buf, node->data, n);
	node->data_pos = 0;
	node->data_len = n;

	TAILQ_INSERT_TAIL(&c->stdin_head, node, entry);

	if (event_initialized(&c->script_stdin_ev))
		event_add(&c->script_stdin_ev, NULL);
}

size_t
parse_record(uint8_t *buf, size_t n, struct request *c)
{
	struct fcgi_record_header	*h;

	if (n < sizeof(struct fcgi_record_header))
		return (0);

	h = (struct fcgi_record_header*) buf;

	if (debug)
		dump_fcgi_record("", h);

	if (n < sizeof(struct fcgi_record_header) + ntohs(h->content_len)
	    + h->padding_len)
		return (0);

	if (h->version != 1)
		lerrx(1, "wrong version");

	switch (h->type) {
	case FCGI_BEGIN_REQUEST:
		parse_begin_request(buf + sizeof(struct fcgi_record_header),
		    ntohs(h->content_len), c, ntohs(h->id));
		break;
	case FCGI_PARAMS:
		parse_params(buf + sizeof(struct fcgi_record_header),
		    ntohs(h->content_len), c, ntohs(h->id));
		break;
	case FCGI_STDIN:
		parse_stdin(buf + sizeof(struct fcgi_record_header),
		    ntohs(h->content_len), c, ntohs(h->id));
		break;
	default:
		lwarnx("unimplemented type %d", h->type);
		break;
	}

	return (sizeof(struct fcgi_record_header) + ntohs(h->content_len)
	    + h->padding_len);
}

/*
 * Fork a new CGI process to handle the request, translating
 * between FastCGI parameter records and CGI's environment variables,
 * as well as between the CGI process' stdin/stdout and the
 * corresponding FastCGI records.
 */
void
exec_cgi(struct request *c)
{
	struct env_val	*env_entry;
	int		 s_in[2], s_out[2], s_err[2], i;
	pid_t		 pid;
	char		*argv[2];
	char		**env;
	char		*path;

	i = 0;

	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, s_in) == -1)
		lerr(1, "socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, s_out) == -1)
		lerr(1, "socketpair");
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, s_err) == -1)
		lerr(1, "socketpair");
	cgi_inflight--;
	c->inflight_fds_accounted = 1;
	ldebug("fork: %s", c->script_name);

	switch (pid = fork()) {
	case -1:
		c->script_status = errno;

		lwarn("fork");

		close(s_in[0]);
		close(s_out[0]);
		close(s_err[0]);

		close(s_in[1]);
		close(s_out[1]);
		close(s_err[1]);

		c->stdin_fd_closed = c->stdout_fd_closed =
		    c->stderr_fd_closed = 1;
		c->script_flags = (STDOUT_DONE | STDERR_DONE | SCRIPT_DONE);

		create_end_record(c);
		return;
	case 0:
		/* Child process */
		if (pledge("stdio rpath exec", NULL) == -1)
			lerr(1, "pledge");
		close(s_in[0]);
		close(s_out[0]);
		close(s_err[0]);

		if (dup2(s_in[1], STDIN_FILENO) == -1)
			_exit(1);
		if (dup2(s_out[1], STDOUT_FILENO) == -1)
			_exit(1);
		if (dup2(s_err[1], STDERR_FILENO) == -1)
			_exit(1);

		close(s_in[1]);
		close(s_out[1]);
		close(s_err[1]);

		path = strrchr(c->script_name, '/');
		if (path != NULL) {
			if (path != c->script_name) {
				*path = '\0';
				if (chdir(c->script_name) == -1)
					lwarn("cannot chdir to %s",
					    c->script_name);
				*path = '/';
			} else
				if (chdir("/") == -1)
					lwarn("cannot chdir to /");
		}

		argv[0] = c->script_name;
		argv[1] = NULL;
		if ((env = calloc(c->env_count + 1, sizeof(char*))) == NULL)
			_exit(1);
		SLIST_FOREACH(env_entry, &c->env, entry)
			env[i++] = env_entry->val;
		env[i++] = NULL;
		execve(c->script_name, argv, env);
		lwarn("execve %s", c->script_name);
		_exit(1);

	}

	/* Parent process*/
	close(s_in[1]);
	close(s_out[1]);
	close(s_err[1]);

	fcntl(s_in[0], F_SETFD, FD_CLOEXEC);
	fcntl(s_out[0], F_SETFD, FD_CLOEXEC);
	fcntl(s_err[0], F_SETFD, FD_CLOEXEC);

	if (ioctl(s_in[0], FIONBIO, &on) == -1)
		lerr(1, "script ioctl(FIONBIO)");
	if (ioctl(s_out[0], FIONBIO, &on) == -1)
		lerr(1, "script ioctl(FIONBIO)");
	if (ioctl(s_err[0], FIONBIO, &on) == -1)
		lerr(1, "script ioctl(FIONBIO)");

	c->script_pid = pid;
	event_set(&c->script_stdin_ev, s_in[0], EV_WRITE | EV_PERSIST,
	    script_out, c);
	event_add(&c->script_stdin_ev, NULL);
	event_set(&c->script_ev, s_out[0], EV_READ | EV_PERSIST,
	    script_std_in, c);
	event_add(&c->script_ev, NULL);
	event_set(&c->script_err_ev, s_err[0], EV_READ | EV_PERSIST,
	    script_err_in, c);
	event_add(&c->script_err_ev, NULL);
}

void
create_end_record(struct request *c)
{
	struct fcgi_response		*resp;
	struct fcgi_record_header	*header;
	struct fcgi_end_request_body	*end_request;

	if ((resp = calloc(1, sizeof(struct fcgi_response))) == NULL) {
		lwarnx("cannot malloc fcgi_response");
		return;
	}
	header = (struct fcgi_record_header*) resp->data;
	header->version = 1;
	header->type = FCGI_END_REQUEST;
	header->id = htons(c->id);
	header->content_len = htons(sizeof(struct
	    fcgi_end_request_body));
	header->padding_len = 0;
	header->reserved = 0;
	end_request = (struct fcgi_end_request_body *) (resp->data +
	    sizeof(struct fcgi_record_header));
	end_request->app_status = htonl(c->script_status);
	end_request->protocol_status = FCGI_REQUEST_COMPLETE;
	end_request->reserved[0] = 0;
	end_request->reserved[1] = 0;
	end_request->reserved[2] = 0;
	resp->data_pos = 0;
	resp->data_len = sizeof(struct fcgi_end_request_body) +
	    sizeof(struct fcgi_record_header);
	slowcgi_add_response(c, resp);
}

void
script_in(int fd, struct event *ev, struct request *c, uint8_t type)
{
	struct fcgi_response		*resp;
	struct fcgi_record_header	*header;
	ssize_t				 n;

	if ((resp = calloc(1, sizeof(struct fcgi_response))) == NULL) {
		lwarnx("cannot malloc fcgi_response");
		return;
	}
	header = (struct fcgi_record_header*) resp->data;
	header->version = 1;
	header->type = type;
	header->id = htons(c->id);
	header->padding_len = 0;
	header->reserved = 0;

	n = read(fd, resp->data + sizeof(struct fcgi_record_header),
	    FCGI_CONTENT_SIZE);

	if (n == -1) {
		switch (errno) {
		case EINTR:
		case EAGAIN:
			free(resp);
			return;
		default:
			n = 0; /* fake empty FCGI_STD{OUT,ERR} response */
		}
	}
	header->content_len = htons(n);
	resp->data_pos = 0;
	resp->data_len = n + sizeof(struct fcgi_record_header);
	slowcgi_add_response(c, resp);

	if (n == 0) {
		if (type == FCGI_STDOUT)
			c->script_flags |= STDOUT_DONE;
		else
			c->script_flags |= STDERR_DONE;

		if (c->script_flags == (STDOUT_DONE | STDERR_DONE |
		    SCRIPT_DONE)) {
			create_end_record(c);
		}
		event_del(ev);
		close(fd);
		if (type == FCGI_STDOUT)
			c->stdout_fd_closed = 1;
		else
			c->stderr_fd_closed = 1;
	}
}

void
script_std_in(int fd, short events, void *arg)
{
	struct request *c = arg;
	script_in(fd, &c->script_ev, c, FCGI_STDOUT);
}

void
script_err_in(int fd, short events, void *arg)
{
	struct request *c = arg;
	script_in(fd, &c->script_err_ev, c, FCGI_STDERR);
}

void
script_out(int fd, short events, void *arg)
{
	struct request		*c;
	struct fcgi_stdin	*node;
	ssize_t			 n;

	c = arg;

	while ((node = TAILQ_FIRST(&c->stdin_head))) {
		if (node->data_len == 0) { /* end of stdin marker */
			close(fd);
			c->stdin_fd_closed = 1;
			break;
		}
		n = write(fd, node->data + node->data_pos, node->data_len);
		if (n == -1) {
			if (errno == EAGAIN || errno == EINTR)
				return;
			event_del(&c->script_stdin_ev);
			return;
		}
		node->data_pos += n;
		node->data_len -= n;
		if (node->data_len == 0) {
			TAILQ_REMOVE(&c->stdin_head, node, entry);
			free(node);
		}
	}
	event_del(&c->script_stdin_ev);
}

void
cleanup_request(struct request *c)
{
	struct fcgi_response	*resp;
	struct fcgi_stdin	*stdin_node;
	struct env_val		*env_entry;
	struct requests		*ncs, *tcs;

	evtimer_del(&c->tmo);
	if (event_initialized(&c->ev))
		event_del(&c->ev);
	if (event_initialized(&c->resp_ev))
		event_del(&c->resp_ev);
	if (event_initialized(&c->script_ev)) {
		if (!c->stdout_fd_closed)
			close(EVENT_FD(&c->script_ev));
		event_del(&c->script_ev);
	}
	if (event_initialized(&c->script_err_ev)) {
		if (!c->stderr_fd_closed)
			close(EVENT_FD(&c->script_err_ev));
		event_del(&c->script_err_ev);
	}
	if (event_initialized(&c->script_stdin_ev)) {
		if (!c->stdin_fd_closed)
			close(EVENT_FD(&c->script_stdin_ev));
		event_del(&c->script_stdin_ev);
	}
	close(c->fd);
	while (!SLIST_EMPTY(&c->env)) {
		env_entry = SLIST_FIRST(&c->env);
		SLIST_REMOVE_HEAD(&c->env, entry);
		free(env_entry->val);
		free(env_entry);
	}

	while ((resp = TAILQ_FIRST(&c->response_head))) {
		TAILQ_REMOVE(&c->response_head, resp, entry);
		free(resp);
	}
	while ((stdin_node = TAILQ_FIRST(&c->stdin_head))) {
		TAILQ_REMOVE(&c->stdin_head, stdin_node, entry);
		free(stdin_node);
	}
	SLIST_FOREACH_SAFE(ncs, &slowcgi_proc.requests, entry, tcs) {
		if (ncs->request == c) {
			SLIST_REMOVE(&slowcgi_proc.requests, ncs, requests,
			    entry);
			free(ncs);
			break;
		}
	}
	if (! c->inflight_fds_accounted)
		cgi_inflight--;
	free(c);
}

void
dump_fcgi_record(const char *p, struct fcgi_record_header *h)
{
	dump_fcgi_record_header(p, h);

	if (h->type == FCGI_BEGIN_REQUEST)
		dump_fcgi_begin_request_body(p,
		    (struct fcgi_begin_request_body *)(h + 1));
	else if (h->type == FCGI_END_REQUEST)
		dump_fcgi_end_request_body(p,
		    (struct fcgi_end_request_body *)(h + 1));
}

void
dump_fcgi_record_header(const char* p, struct fcgi_record_header *h)
{
	ldebug("%sversion:         %d", p, h->version);
	ldebug("%stype:            %d", p, h->type);
	ldebug("%srequestId:       %d", p, ntohs(h->id));
	ldebug("%scontentLength:   %d", p, ntohs(h->content_len));
	ldebug("%spaddingLength:   %d", p, h->padding_len);
	ldebug("%sreserved:        %d", p, h->reserved);
}

void
dump_fcgi_begin_request_body(const char *p, struct fcgi_begin_request_body *b)
{
	ldebug("%srole             %d", p, ntohs(b->role));
	ldebug("%sflags            %d", p, b->flags);
}

void
dump_fcgi_end_request_body(const char *p, struct fcgi_end_request_body *b)
{
	ldebug("%sappStatus:       %d", p, ntohl(b->app_status));
	ldebug("%sprotocolStatus:  %d", p, b->protocol_status);
}

void
syslog_vstrerror(int e, int priority, const char *fmt, va_list ap)
{
	char *s;

	if (vasprintf(&s, fmt, ap) == -1) {
		syslog(LOG_EMERG, "unable to alloc in syslog_vstrerror");
		exit(1);
	}
	syslog(priority, "%s: %s", s, strerror(e));
	free(s);
}

__dead void
syslog_err(int ecode, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	syslog_vstrerror(errno, LOG_CRIT, fmt, ap);
	va_end(ap);
	exit(ecode);
}

__dead void
syslog_errx(int ecode, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(LOG_CRIT, fmt, ap);
	va_end(ap);
	exit(ecode);
}

void
syslog_warn(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	syslog_vstrerror(errno, LOG_ERR, fmt, ap);
	va_end(ap);
}

void
syslog_warnx(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(LOG_ERR, fmt, ap);
	va_end(ap);
}

void
syslog_info(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog(LOG_INFO, fmt, ap);
	va_end(ap);
}

void
syslog_debug(const char *fmt, ...)
{
	va_list ap;

	if (!debug)
		return;

	va_start(ap, fmt);
	vsyslog(LOG_DEBUG, fmt, ap);
	va_end(ap);
}
@


1.51
log
@Sync the severity of the syslog_* functions shared between identd, slowcgi,
tftp-proxy and tftpd to the severity used in log.c style loggers.
This also fixes an issue where syslog_err and syslog_errx logged with
different severities.

Sure deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.50 2016/09/04 14:40:34 florian Exp $ */
d509 2
a510 2
	event_set(&c->tmo, s, 0, slowcgi_timeout, c);
	event_add(&c->tmo, &timeout);
@


1.50
log
@Add format attribute to logger functions.
Fix format string while here.
Input & OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.49 2016/08/16 08:23:18 reyk Exp $ */
d1239 1
a1239 1
	syslog_vstrerror(errno, LOG_EMERG, fmt, ap);
d1250 1
a1250 1
	vsyslog(LOG_WARNING, fmt, ap);
d1261 1
a1261 1
	syslog_vstrerror(errno, LOG_WARNING, fmt, ap);
d1271 1
a1271 1
	vsyslog(LOG_WARNING, fmt, ap);
@


1.49
log
@As suggested by the FastCGI spec, zero-pad the response buffers to be
aligned to 8 bytes.  This matches what most other implementations are
doing.  While here, make sure that the allocated response buffers are
zero'ed out.

OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.48 2015/11/20 09:04:01 tb Exp $ */
d199 12
a210 6
	__dead void (*err)(int, const char *, ...);
	__dead void (*errx)(int, const char *, ...);
	void (*warn)(const char *, ...);
	void (*warnx)(const char *, ...);
	void (*info)(const char *, ...);
	void (*debug)(const char *, ...);
d222 14
a235 7
__dead void	syslog_err(int, const char *, ...);
__dead void	syslog_errx(int, const char *, ...);
void		syslog_warn(const char *, ...);
void		syslog_warnx(const char *, ...);
void		syslog_info(const char *, ...);
void		syslog_debug(const char *, ...);
void		syslog_vstrerror(int, int, const char *, va_list);
d694 1
a694 1
		lwarnx("wrong size %d != %d", n,
@


1.48
log
@typo in error message: to -> too

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.47 2015/11/05 19:15:22 florian Exp $ */
d50 4
d559 15
d986 1
a986 1
	if ((resp = malloc(sizeof(struct fcgi_response))) == NULL) {
d1018 1
a1018 1
	if ((resp = malloc(sizeof(struct fcgi_response))) == NULL) {
@


1.47
log
@pledge(2) for slowcgi.
After initialization slowcgi accepts from a AF_UNIX socket, forks and
execs. After fork we only need to close(2), chdir(2) and exec.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.46 2015/11/05 19:14:56 florian Exp $ */
d380 1
a380 1
		lerrx(1, "socket path to long");
@


1.46
log
@re-shuffle slowcgi_listen to run less code as root.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.45 2015/09/25 20:15:28 millert Exp $ */
d339 3
d889 2
@


1.45
log
@Output the contents of the environment in debug mode which is
most helpful in debugging interactions between httpd and slowcgi.
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.44 2015/01/22 18:22:27 florian Exp $ */
d163 1
a163 1
void		slowcgi_listen(char *, struct passwd *);
d257 1
a311 2
	event_init();

d316 1
a316 1
	slowcgi_listen(fcgi_socket, pw);
d340 9
d361 2
a362 1
void
a364 1
	struct listener		 *l = NULL;
a396 8
	l = calloc(1, sizeof(*l));
	if (l == NULL)
		lerr(1, "listener ev alloc");

	event_set(&l->ev, fd, EV_READ | EV_PERSIST, slowcgi_accept, l);
	event_add(&l->ev, NULL);
	evtimer_set(&l->pause, slowcgi_paused, l);

d398 1
@


1.44
log
@Clean up includes, while here fix a white space which lead to a false
positive during grep'ing.
OK reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.43 2015/01/19 21:18:47 guenther Exp $ */
d763 1
@


1.43
log
@The kernel doesn't actually care what a sockaddr's sa_len is on input,
so don't waste code setting it

improvment and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.42 2015/01/16 06:40:20 deraadt Exp $ */
a22 1
#include <sys/socketvar.h>
d24 1
d27 1
a29 1
#include <ctype.h>
a31 1
#include <netdb.h>
d35 1
d513 1
a513 1
		while((pid = waitpid(WAIT_ANY, &status, WNOHANG)) > 0) {
@


1.42
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.41 2014/12/08 12:12:46 blambert Exp $ */
a357 1
	size_t			 len;
d367 2
a368 2
	len = strlcpy(sun.sun_path, path, sizeof(sun.sun_path));
	if (len >= sizeof(sun.sun_path))
a369 1
	sun.sun_len = len;
@


1.41
log
@read(2) returns ssize_t, not size_t

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.40 2014/12/05 20:01:39 florian Exp $ */
d33 1
d122 1
a122 1
	char				script_name[MAXPATHLEN];
d749 1
a749 1
		if (val_len < MAXPATHLEN && strcmp(env_entry->val,
d753 1
a753 1
		} else if (val_len < MAXPATHLEN && strcmp(env_entry->val,
@


1.40
log
@Bail out if the buffer is too small to contain the length of a
parameter value.
Found while investigating a dead store pointed out by llvm scan-build.
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.39 2014/12/05 19:59:55 florian Exp $ */
d599 2
a600 1
	size_t		 n, parsed;
@


1.39
log
@dead stores; pointed out by llvm scan-build; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.38 2014/12/05 19:58:47 florian Exp $ */
a684 2
	name_len = val_len = 0;

d724 3
a726 1
		}
@


1.38
log
@pause shadows global; pointed out by gcc; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.37 2014/12/05 19:57:27 florian Exp $ */
a601 1
	parsed = 0;
a650 2
	struct fcgi_begin_request_body	*b;

a663 1
	b = (struct fcgi_begin_request_body*) buf;
@


1.37
log
@mode is unused; pointed out by gcc; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.36 2014/12/05 19:56:24 florian Exp $ */
d433 1
a433 1
	struct timeval		 pause;
d440 2
a441 2
	pause.tv_sec = 1;
	pause.tv_usec = 0;
d455 1
a455 1
			evtimer_add(&l->pause, &pause);
@


1.36
log
@declare lerr and lerrx __dead; unconfuses llvm scan-build
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.35 2014/09/19 21:28:32 florian Exp $ */
d358 1
a358 1
	mode_t			 old_umask, mode;
@


1.35
log
@Instead of doing the fcntl(2) and ioctl(2) song and dance just tell
socket(2) and accept4(2) that we want non-blocking-close-on-exec
sockets.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.34 2014/07/13 21:46:25 claudio Exp $ */
d194 2
a195 2
	void (*err)(int, const char *, ...);
	void (*errx)(int, const char *, ...);
d211 7
a217 7
void	syslog_err(int, const char *, ...);
void	syslog_errx(int, const char *, ...);
void	syslog_warn(const char *, ...);
void	syslog_warnx(const char *, ...);
void	syslog_info(const char *, ...);
void	syslog_debug(const char *, ...);
void	syslog_vstrerror(int, int, const char *, va_list);
d1198 1
a1198 1
void
d1209 1
a1209 1
void
@


1.34
log
@Use lerrx instead of errx since the logging subsystem is already initialized.
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.33 2014/06/10 14:38:27 florian Exp $ */
d361 2
a362 1
	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
a363 1
	fcntl(fd, F_SETFD, FD_CLOEXEC);
a386 3
	if (ioctl(fd, FIONBIO, &on) == -1)
		lerr(1, "listener ioctl(FIONBIO)");

d420 2
a421 1
	if ((ret = accept(sockfd, addr, addrlen)) > -1) {
a460 4

	fcntl(s, F_SETFD, FD_CLOEXEC);
	if (ioctl(s, FIONBIO, &on) == -1)
		lerr(1, "request ioctl(FIONBIO)");
@


1.33
log
@Implement -u (user to drop privs to) and -p flag (path to chroot to).
This allows to run slowcgi non-chrooted with -p /, requested by at
least ratchov@@ and henning@@.
Input by many, OK ratchov@@ on a previous diff, "looks good" millert@@,
man page bits tweak and OK schwarze@@ (all some time ago); OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.32 2014/06/10 14:33:01 florian Exp $ */
d314 1
a314 1
		errx(1, "no %s user", SLOWCGI_USER);
d321 1
a321 1
		errx(1, "no %s user", slowcgi_user);
@


1.32
log
@Cleanup socket creation.
Input ajacoutot some time ago; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.31 2014/04/16 14:43:43 florian Exp $ */
d241 2
a242 1
	fprintf(stderr, "usage: %s [-d] [-s socket]\n", __progname);
d259 2
d279 1
a279 1
	while ((c = getopt(argc, argv, "ds:")) != -1) {
d284 3
d290 3
a301 4
	pw = getpwnam(SLOWCGI_USER);
	if (pw == NULL)
		err(1, "no %s user", SLOWCGI_USER);

d312 4
d318 12
a329 2
	if (chroot(pw->pw_dir) == -1)
		lerr(1, "chroot(%s)", pw->pw_dir);
d332 1
a332 3
		lerr(1, "chdir(%s)", pw->pw_dir);

	ldebug("chroot: %s", pw->pw_dir);
@


1.31
log
@My previous attempt to chdir(2) to the directory containing the cgi
script was not quite right. slowcgi would try to chdir("") with a
SCRIPT_NAME of /foo.cgi; chdir("/") in that case.
I'm not sure how one would configure nginx/slowcgi to get to that
point though.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.30 2014/04/14 19:25:48 florian Exp $ */
d162 1
a162 1
void		slowcgi_listen(char *, gid_t);
d307 1
a307 1
	slowcgi_listen(fcgi_socket, pw->pw_gid);
d336 1
a336 1
slowcgi_listen(char *path, gid_t gid)
d359 2
a360 2
	old_umask = umask(S_IXUSR|S_IXGRP|S_IWOTH|S_IROTH|S_IXOTH);
	mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP;
d367 1
a367 4
	if (chmod(path, mode) == -1)
		lerr(1, "slowcgi_listen: chmod: %s", path);

	if (chown(path, 0, gid) == -1)
@


1.30
log
@Calculate the length of name and value for parameters the right way
around for the 4 byte encoding. With this QUERY_STRING can be longer
than 127 bytes.
Found the hard way while playing with smokeping.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.29 2014/04/13 08:46:20 florian Exp $ */
d897 9
a905 4
			*path = '\0';
			if (chdir(c->script_name) == -1)
				lwarn("cannot chdir to %s", c->script_name);
			*path = '/';
@


1.29
log
@httpd(8) did a chdir(2) to the directory containing the cgi script. As
there might be scripts depending on this do the same in slowcgi(8).

pointed out and OK ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.28 2014/03/17 13:39:29 florian Exp $ */
d699 2
a700 2
				name_len = ((buf[3] & 0x7f) << 24) +
				    (buf[2] << 16) + (buf[1] << 8) + buf[0];
d714 3
a716 3
					val_len = ((buf[3] & 0x7f) << 24) +
					    (buf[2] << 16) + (buf[1] << 8) +
					     buf[0];
@


1.28
log
@jturner pointed out that if one wants to run cgi scripts outside
/cgi-bin SCRIPT_NAME doesn't cut it. The spec says: "The SCRIPT_NAME
variable MUST be set to a URL path". Use SCRIPT_FILENAME which can be
an absolute filesystem path for these cases and fall back to using
SCRIPT_NAME if SCRIPT_FILENAME is not present.
Details how to handle this worked out by jturner and sthen.
Based on an erlier diff by jturner.
Tested by jturner
OK jturner, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.27 2014/01/19 00:01:05 djm Exp $ */
d844 1
d894 8
@


1.27
log
@fix reaper loop that could run indefinitely

log execve() failures to syslog (very useful for debugging SCRIPT_NAME
problems)

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.26 2013/10/31 21:53:16 florian Exp $ */
d744 5
a748 1
		    "SCRIPT_NAME") == 0) {
@


1.26
log
@Initialize sun_len, pointed out by deraadt@@.
While there also check length of socket path, more relevant now since
an alternative socket can be specified.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.25 2013/10/29 17:59:47 florian Exp $ */
d506 1
a506 1
		while((pid = waitpid(WAIT_ANY, &status, WNOHANG)) != -1) {
d529 2
d898 1
@


1.25
log
@Fix a potential file descriptor overlap in exec_cgi() by making sure
that file descriptors zero to two are always open when starting slowcgi.
pointed out, with and looks good to deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.24 2013/10/23 15:29:21 florian Exp $ */
d340 1
d350 4
a353 1
	strlcpy(sun.sun_path, path, sizeof(sun.sun_path));
@


1.24
log
@We need to loop around waitpid to catch all exited children as we are
not guaranteed to get one signal per child.
pointed out by deraadt
OK benno, blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.23 2013/10/21 18:19:27 florian Exp $ */
d256 19
a274 1
	int		 c;
d872 1
d879 5
@


1.23
log
@Do not leak fds in fork(2) error path.
pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.22 2013/10/21 18:17:58 florian Exp $ */
a480 1
	c = NULL;
d484 10
a493 5
		pid = wait(&status);
		SLIST_FOREACH(ncs, &p->requests, entry)
			if (ncs->request->script_pid == pid) {
				c = ncs->request;
				break;
a494 4
		if (c == NULL) {
			lwarnx("caught exit of unknown child %i", pid);
			break;
		}
d496 8
a503 8
		if (WIFSIGNALED(status))
			c->script_status = WTERMSIG(status);
		else
			c->script_status = WEXITSTATUS(status);

		if (c->script_flags == (STDOUT_DONE | STDERR_DONE))
			create_end_record(c);
		c->script_flags |= SCRIPT_DONE;
d505 2
a506 1
		ldebug("wait: %s", c->script_name);
@


1.22
log
@Check for EINTR, too.
pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.21 2013/10/21 18:16:28 florian Exp $ */
d830 2
d833 14
@


1.21
log
@No need for volatile here.
pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.20 2013/10/20 16:47:24 deraadt Exp $ */
d540 1
a540 1
			if (errno == EAGAIN)
d1001 1
a1001 1
			if (errno == EAGAIN)
@


1.20
log
@spelling, spacing, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.19 2013/10/20 09:36:29 benno Exp $ */
d73 1
a73 1
volatile int cgi_inflight = 0;
@


1.19
log
@reserve file descriptors for incoming connections so we
will be able to actually run the cgi for them later on.
mirrored on relayd.
ok florian@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.18 2013/10/19 14:18:35 florian Exp $ */
d119 1
a119 1
	struct fcgi_stdin_head		stdin_head;	
d249 1
a249 1
char 			*fcgi_socket = "/var/www/run/slowcgi.sock";
d286 1
a286 1
		
d382 1
a382 1
		ldebug("inflight fds exceded");
d412 1
a412 1
	    &len, FD_RESERVE, &cgi_inflight)) == -1) {		
d476 1
a476 1
	struct slowcgi_proc 	*p;
d512 1
a512 1

d526 1
a526 1
	struct request		 	*c;
d529 1
a529 1
	ssize_t 			 n;
d566 1
a566 1
	size_t 		 n, parsed;
d573 1
a573 1
	
d620 1
a620 1
	
d762 1
a762 1
	struct fcgi_record_header 	*h;
d794 1
d854 1
d920 1
a920 1
	ssize_t 			 n;
d934 2
a935 2
	     FCGI_CONTENT_SIZE);
	
d989 1
a989 1
	ssize_t 		 n;
@


1.18
log
@Keep track of which fds were closed before and only close those still
open.  Otherwise if there are parallel requests and the timing is just
right we were closing random fds from other connections.
OK blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.17 2013/10/18 14:48:54 florian Exp $ */
d71 3
d134 1
d164 2
d375 19
d411 2
a412 2
	s = accept(fd, (struct sockaddr *)&ss, &len);
	if (s == -1) {
d436 1
d443 1
d452 1
d823 2
d1066 2
@


1.17
log
@Do not fiddle with the response queue directly but go through
a new slowcgi_add_response() function. This ensures that we
always do an event_add.
OK blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.16 2013/10/18 14:47:47 florian Exp $ */
d126 3
d424 1
d931 4
d964 1
d998 2
a999 1
		close(EVENT_FD(&c->script_ev));
d1003 2
a1004 1
		close(EVENT_FD(&c->script_err_ev));
d1008 2
a1009 1
		close(EVENT_FD(&c->script_stdin_ev));
@


1.16
log
@Logging to syslog works better with openlog(3).
OK blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.15 2013/10/18 14:46:47 florian Exp $ */
d160 1
d426 1
a426 1

d485 7
d876 1
a876 1
	TAILQ_INSERT_TAIL(&c->response_head, resp, entry);	
d913 1
a913 6
	TAILQ_INSERT_TAIL(&c->response_head, resp, entry);

	event_del(&c->resp_ev);
	event_set(&c->resp_ev, EVENT_FD(&c->ev), EV_WRITE | EV_PERSIST,
	    slowcgi_response, c);
	event_add(&c->resp_ev, NULL);
@


1.15
log
@Use a dedicated socketpair for stdin, makes the code more symetric and
gets rid of shutdown(2) which might cause problems.
OK blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.14 2013/10/18 14:44:36 florian Exp $ */
d244 1
d272 5
@


1.14
log
@Calculate correct pointer for fcgi_{begin,end}_request_body.
input / OK blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.13 2013/10/18 14:43:21 florian Exp $ */
d709 2
a710 4
	event_del(&c->script_stdin_ev);
	event_set(&c->script_stdin_ev, EVENT_FD(&c->script_ev), EV_WRITE |
	    EV_PERSIST, script_out, c);
	event_add(&c->script_stdin_ev, NULL);
d764 1
a764 1
	int		 s[2], s_err[2], i;
d771 3
a773 1
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, s) == -1)
d785 2
a786 1
		close(s[0]);
d788 1
a788 1
		if (dup2(s[1], STDIN_FILENO) == -1)
d790 1
a790 1
		if (dup2(s[1], STDOUT_FILENO) == -1)
d806 2
a807 1
	close(s[1]);
d810 2
a811 1
	fcntl(s[0], F_SETFD, FD_CLOEXEC);
d814 3
a816 1
	if (ioctl(s[0], FIONBIO, &on) == -1)
d822 5
a826 1
	event_set(&c->script_ev, s[0], EV_READ | EV_PERSIST, script_std_in, c);
d946 1
a946 1
			shutdown(fd, SHUT_WR);
d963 1
@


1.13
log
@Calculate correct pointer for end_request; while there initialize
reserved to zero.
OK blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.12 2013/10/18 14:42:18 florian Exp $ */
d1015 1
a1015 1
		    (struct fcgi_begin_request_body *)((char *)h) + sizeof(*h));
d1018 1
a1018 1
		    (struct fcgi_end_request_body *)((char *)h) + sizeof(*h));
@


1.12
log
@set FD_CLOEXEC
OK blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.11 2013/09/19 09:21:29 blambert Exp $ */
d843 2
a844 2
	end_request = (struct fcgi_end_request_body *) resp->data +
	    sizeof(struct fcgi_record_header);
d847 3
@


1.11
log
@adjust the names to more accurately reflect the names of structs
and functions as they relate to the FastCGI protocol

style(9)ize some function declarations while here

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.10 2013/09/11 09:31:22 blambert Exp $ */
d28 1
d311 1
d393 1
d807 4
@


1.10
log
@Sprinkle some comments which clarify the protocol/process flow.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.9 2013/09/06 12:17:28 blambert Exp $ */
d106 1
a106 1
struct client {
d129 3
a131 3
struct clients {
	SLIST_ENTRY(clients)	 entry;
	struct client		*client;
d133 1
a133 1
SLIST_HEAD(clients_head, clients);
d136 1
a136 1
	struct clients_head	clients;
d155 8
a162 8
void		slowcgi_paused(int, short, void*);
void		slowcgi_accept(int, short, void*);
void		slowcgi_request(int, short, void*);
void		slowcgi_response(int, short, void*);
void		slowcgi_timeout(int, short, void*);
void		slowcgi_sig_handler(int, short, void*);
size_t		parse_request(uint8_t* , size_t, struct client*);
void		parse_begin_request(uint8_t*, uint16_t, struct client*,
d164 8
a171 8
void		parse_params(uint8_t*, uint16_t, struct client*, uint16_t);
void		parse_stdin(uint8_t*, uint16_t, struct client*, uint16_t);
void		exec_cgi(struct client*);
void		script_in(int, struct event*, struct client*, uint8_t);
void		script_std_in(int, short, void*);
void		script_err_in(int, short, void*);
void		script_out(int, short, void*);
void		create_end_request(struct client*);
d174 2
a175 2
void		dump_fcgi_record_header(const char*,
		    struct fcgi_record_header*);
d180 1
a180 1
void		cleanup_client(struct client*);
d287 1
a287 1
	SLIST_INIT(&slowcgi_proc.clients);
d363 2
a364 2
	struct client		*c;
	struct clients		*clients;
d392 1
a392 1
		lerr(1, "client ioctl(FIONBIO)");
d396 1
a396 1
		lwarn("cannot calloc client");
d400 3
a402 3
	clients = calloc(1, sizeof(*clients));
	if (clients == NULL) {
		lwarn("cannot calloc clients");
d419 2
a420 2
	clients->client = c;
	SLIST_INSERT_HEAD(&slowcgi_proc.clients, clients, entry);
d426 1
a426 1
	cleanup_client((struct client*) arg);
d432 2
a433 2
	struct client		*c;
	struct clients		*ncs;
d444 3
a446 3
		SLIST_FOREACH(ncs, &p->clients, entry)
			if (ncs->client->script_pid == pid) {
				c = ncs->client;
d460 1
a460 1
			create_end_request(c);
d477 1
a477 1
	struct client		 	*c;
d493 1
a493 1
			cleanup_client(c);
d507 1
a507 1
			cleanup_client(c);
d516 1
a516 1
	struct client	*c;
d552 1
a552 1
		parsed = parse_request(c->buf + c->buf_pos, c->buf_len, c);
d564 1
a564 1
	cleanup_client(c);
d568 1
a568 1
parse_begin_request(uint8_t *buf, uint16_t n, struct client *c, uint16_t id)
d592 1
a592 1
parse_params(uint8_t *buf, uint16_t n, struct client *c, uint16_t id)
d686 1
a686 1
parse_stdin(uint8_t *buf, uint16_t n, struct client *c, uint16_t id)
d713 1
a713 1
parse_request(uint8_t *buf, size_t n, struct client *c)
d760 1
a760 1
exec_cgi(struct client *c)
d818 1
a818 1
create_end_request(struct client *c)
d847 1
a847 1
script_in(int fd, struct event *ev, struct client *c, uint8_t type)
d895 1
a895 1
			create_end_request(c);
d905 1
a905 1
	struct client *c = arg;
d912 1
a912 1
	struct client *c = arg;
d919 1
a919 1
	struct client		*c;
d947 1
a947 1
cleanup_client(struct client *c)
d952 1
a952 1
	struct clients		*ncs, *tcs;
d987 3
a989 3
	SLIST_FOREACH_SAFE(ncs, &slowcgi_proc.clients, entry, tcs) {
		if (ncs->client == c) {
			SLIST_REMOVE(&slowcgi_proc.clients, ncs, clients,
@


1.9
log
@When dumping FastCGI protocol headers during debug, dump the
"request begin" and "request end" protocol entries in addition

While here, make the "FastCGI request body" struct's name
more precise (fcgi_end_request -> fcgi_end_request_body).

okay florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.8 2013/09/06 07:36:03 blambert Exp $ */
d545 6
d609 4
d617 1
d753 6
@


1.8
log
@Use the correct buffer size for memory allocation and reads.

okay florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.7 2013/08/30 07:10:26 blambert Exp $ */
d147 1
a147 1
struct fcgi_end_request {
d152 1
d172 2
d176 4
d181 1
d487 1
a487 1
			dump_fcgi_record_header("resp ", header);
d712 1
a712 1
		dump_fcgi_record_header("", h);
d805 1
a805 1
	struct fcgi_end_request		*end_request;
d816 1
a816 1
	    fcgi_end_request));
d819 1
a819 1
	end_request = (struct fcgi_end_request *) resp->data +
d824 1
a824 1
	resp->data_len = sizeof(struct fcgi_end_request) +
d982 13
d1003 14
@


1.7
log
@If the CGI script died due to receipt of signal, pass that back
to the HTTP frontend as the "application return status".

While here, add a pair of informative debugging statements.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.6 2013/08/26 08:02:03 blambert Exp $ */
d42 6
a47 1
#define FCGI_RECORD_SIZE	 64*1024
d92 1
a92 2
	uint8_t				data[FCGI_RECORD_SIZE + sizeof(struct
					    fcgi_record_header)];
d840 1
a840 1
	     FCGI_RECORD_SIZE);
@


1.6
log
@slowcgi grows an option to specify an alternate FastCGI socket
on which to listen.

okay dcoppa@@, henning@@, florian@@

manpage okay from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.5 2013/08/23 07:12:49 blambert Exp $ */
d268 2
d334 2
d437 8
a444 1
		if (c != NULL) {
d446 7
a452 4
			if (c->script_flags == (STDOUT_DONE | STDERR_DONE))
				create_end_request(c);
			c->script_flags |= SCRIPT_DONE;
		}
@


1.5
log
@Give slowcgi a style(9) scrubbing. No functional change.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.4 2013/06/02 14:11:38 florian Exp $ */
d149 1
a149 1
void		slowcgi_listen(const char *, gid_t);
d218 1
a218 1
	fprintf(stderr, "usage: %s [-d]\n", __progname);
d226 1
d234 1
a234 1
	while ((c = getopt(argc, argv, "d")) != -1) {
d239 3
d260 2
a261 1
	slowcgi_listen("/var/www/run/slowcgi.sock", pw->pw_gid);
d287 1
a287 1
slowcgi_listen(const char *path, gid_t gid)
@


1.4
log
@move bgplg and slowcgi sockets to /var/www/run
input reyk@@, guenther@@
"move fast" deraadt@@
OK naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.3 2013/05/23 16:13:08 florian Exp $ */
d348 2
a349 1
	pause.tv_sec = 1; pause.tv_usec = 0;
d459 1
a459 1
		if ( n == -1) {
d467 1
a467 1
		if(resp->data_len == 0) {
d491 1
a491 1
	n = read(fd, c->buf+c->buf_pos+c->buf_len,
d512 1
a512 1
	c->buf_len+=n;
d515 1
a515 1
		parsed = parse_request(c->buf+c->buf_pos, c->buf_len, c);
d520 1
d522 1
a522 1
		bcopy(c->buf+c->buf_pos, c->buf, c->buf_len);
d535 1
d623 2
a624 1
		buf += name_len; n -= name_len;
d634 3
a636 2
		bcopy(buf, (env_entry->val)+name_len+1, val_len);
		buf += val_len; n -= val_len;
a667 1

d692 1
a692 1
		parse_begin_request(buf+sizeof(struct fcgi_record_header),
d696 1
a696 1
		parse_params(buf+sizeof(struct fcgi_record_header),
d700 1
a700 1
		parse_stdin(buf+sizeof(struct fcgi_record_header),
d727 18
a744 22
	switch(pid = fork()) {
		case -1:
			lwarn("fork");
			return;
		case 0:
			/* Child process */
			close(s[0]);
			close(s_err[0]);
			if (dup2(s[1], STDIN_FILENO) == -1)
				_exit(1);
			if (dup2(s[1], STDOUT_FILENO) == -1)
				_exit(1);
			if (dup2(s_err[1], STDERR_FILENO) == -1)
				_exit(1);
			argv[0] = c->script_name;
			argv[1] = NULL;
			if((env = calloc(c->env_count+1, sizeof(char*)))==NULL)
				_exit(1);
			SLIST_FOREACH(env_entry, &c->env, entry)
				env[i++] = env_entry->val;
			env[i++] = NULL;
			execve(c->script_name, argv, env);
d746 5
d883 1
a883 1
		if ( n == -1) {
d891 1
a891 1
		if(node->data_len == 0) {
d940 1
a940 1
		if(ncs->client == c) {
d950 2
a951 1
void dump_fcgi_record_header(const char* p, struct fcgi_record_header *h)
@


1.3
log
@off by one, from Henri Kemppainen <duclare-at-guu.fi>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.2 2013/05/23 13:03:52 jasper Exp $ */
d256 1
a256 1
	slowcgi_listen("/var/www/logs/slowcgi.sock", pw->pw_gid);
@


1.2
log
@Fix pasto where 'c' instead of 'clients' is checked for NULL and add missing
free for the fcgi_response.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: slowcgi.c,v 1.1 2013/05/23 12:03:24 florian Exp $ */
d626 1
a626 1
			c->script_name[val_len+1] = '\0';
@


1.1
log
@Put slowcgi(8) a FastCGI to CGI wrapper in to work on it in tree.
Not hooked up to the build yet.
OK sthen@@, deraadt@@ agrees
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d379 1
a379 1
	if (c == NULL) {
d818 1
@

