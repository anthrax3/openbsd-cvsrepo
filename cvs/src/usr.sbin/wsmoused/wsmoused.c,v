head	1.36;
access;
symbols
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.6
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.4
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.8
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.6
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.6
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.36
date	2015.10.26.09.58.18;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	BbXgg723CihRSyQL;

1.35
date	2014.12.23.10.24.22;	author shadchin;	state Exp;
branches;
next	1.34;
commitid	81pkNKXJCtzY9JCs;

1.34
date	2014.12.22.11.21.49;	author shadchin;	state Exp;
branches;
next	1.33;
commitid	74rKxoe6VZzbQ7XP;

1.33
date	2014.12.21.18.23.37;	author shadchin;	state Exp;
branches;
next	1.32;
commitid	L502EmSxKv8c9xWE;

1.32
date	2014.05.14.18.23.22;	author shadchin;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.14.18.18.01;	author shadchin;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.14.18.14.09;	author shadchin;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.24.01.06.19;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.18.02.29.59;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2011.10.18.20.07.46;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2011.03.22.10.16.23;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.21.16.13.18;	author jacekm;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.05.03.37.10;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.24.16.28.09;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.18.20.19.20;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.10.22.37.17;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.17.08.42.41;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.12.21.13.34;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.04.21.41.12;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.22.11.11.27;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.08.08.49.51;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.26.16.09.27;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.13.11.20.47;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.26.09.32.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.27.18.54.09;	author jbm;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.06.51.42;	author mpech;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.15.02.18.39;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.12.01.15.37;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.09.14.58.27;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.02.16.19.48;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.20.21.22.16;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.31.22.34.54;	author jbm;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.13.06.32.18;	author pvalchev;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.12.17.53.16;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.14.04.47.41;	author aaron;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Stop writing a pidfile
ok benno jung
@
text
@/* $OpenBSD: wsmoused.c,v 1.35 2014/12/23 10:24:22 shadchin Exp $ */

/*
 * Copyright (c) 2001 Jean-Baptiste Marchand, Julien Montagne and Jerome Verdon
 *
 * Copyright (c) 1998 by Kazutaka Yokota
 *
 * Copyright (c) 1995 Michael Smith
 *
 * Copyright (c) 1993 by David Dawes <dawes@@xfree86.org>
 *
 * Copyright (c) 1990,91 by Thomas Roell, Dinkelscherben, Germany.
 *
 * All rights reserved.
 *
 * Most of this code was taken from the FreeBSD moused daemon, written by
 * Michael Smith. The FreeBSD moused daemon already contained code from the
 * Xfree Project, written by David Dawes and Thomas Roell and Kazutaka Yokota.
 *
 * Adaptation to OpenBSD was done by Jean-Baptiste Marchand, Julien Montagne
 * and Jerome Verdon.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by
 *      David Dawes, Jean-Baptiste Marchand, Julien Montagne, Thomas Roell,
 *      Michael Smith, Jerome Verdon and Kazutaka Yokota.
 * 4. The name authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 */

#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/tty.h>
#include <dev/wscons/wsconsio.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <poll.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <syslog.h>

#include "mouse_protocols.h"
#include "wsmoused.h"

#define	DEFAULT_TTY	"/dev/ttyCcfg"

extern char *__progname;
extern char *mouse_names[];

int debug = 0;
int background = FALSE;
int nodaemon = FALSE;
int identify = FALSE;

mouse_t mouse = {
	.flags = 0,
	.portname = NULL,
	.ttyname = NULL,
	.proto = P_UNKNOWN,
	.rate = MOUSE_RATE_UNKNOWN,
	.resolution = MOUSE_RES_UNKNOWN,
	.mfd = -1,
	.clickthreshold = 500,	/* 0.5 sec */
};

/* identify the type of a wsmouse supported mouse */
void
wsmouse_identify(void)
{
	unsigned int type;

	if (mouse.mfd != -1) {
		if (ioctl(mouse.mfd, WSMOUSEIO_GTYPE, &type) == -1)
			err(1, "can't detect mouse type");

		printf("wsmouse supported mouse: ");
		switch (type) {
		case WSMOUSE_TYPE_VSXXX:
			printf("DEC serial\n");
			break;
		case WSMOUSE_TYPE_PS2:
			printf("PS/2 compatible\n");
			break;
		case WSMOUSE_TYPE_USB:
			printf("USB\n");
			break;
		case WSMOUSE_TYPE_LMS:
			printf("Logitech busmouse\n");
			break;
		case WSMOUSE_TYPE_MMS:
			printf("Microsoft InPort mouse\n");
			break;
		case WSMOUSE_TYPE_TPANEL:
			printf("Generic Touch Panel\n");
			break;
		case WSMOUSE_TYPE_NEXT:
			printf("NeXT\n");
			break;
		case WSMOUSE_TYPE_ARCHIMEDES:
			printf("Archimedes\n");
			break;
		case WSMOUSE_TYPE_ADB:
			printf("ADB\n");
			break;
		case WSMOUSE_TYPE_HIL:
			printf("HP-HIL\n");
			break;
		case WSMOUSE_TYPE_LUNA:
			printf("Omron Luna\n");
			break;
		case WSMOUSE_TYPE_DOMAIN:
			printf("Apollo Domain\n");
			break;
		case WSMOUSE_TYPE_SUN:
			printf("Sun\n");
			break;
		default:
			printf("Unknown\n");
			break;
		}
	} else
		warnx("unable to open %s", mouse.portname);
}

/* wsmouse_init : init a wsmouse compatible mouse */
void
wsmouse_init(void)
{
	unsigned int res = WSMOUSE_RES_MIN;
	unsigned int rate = WSMOUSE_RATE_DEFAULT;

	ioctl(mouse.mfd, WSMOUSEIO_SRES, &res);
	ioctl(mouse.mfd, WSMOUSEIO_SRATE, &rate);
}

/*
 * Buttons remapping
 */

/* physical to logical button mapping */
static int p2l[MOUSE_MAXBUTTON] = {
	MOUSE_BUTTON1,	MOUSE_BUTTON2,	MOUSE_BUTTON3,	MOUSE_BUTTON4,
	MOUSE_BUTTON5,	MOUSE_BUTTON6,	MOUSE_BUTTON7,	MOUSE_BUTTON8,
};

static char *
skipspace(char *s)
{
	while (isspace((unsigned char)*s))
		++s;
	return s;
}

/* mouse_installmap : install a map between physical and logical buttons */
static int
mouse_installmap(char *arg)
{
	int pbutton;
	int lbutton;
	char *s;

	while (*arg) {
		arg = skipspace(arg);
		s = arg;
		while (isdigit((unsigned char)*arg))
			++arg;
		arg = skipspace(arg);
		if ((arg <= s) || (*arg != '='))
			return FALSE;
		lbutton = atoi(s);

		arg = skipspace(++arg);
		s = arg;
		while (isdigit((unsigned char)*arg))
			++arg;
		if (arg <= s || (!isspace((unsigned char)*arg) && *arg != '\0'))
			return FALSE;
		pbutton = atoi(s);

		if (lbutton <= 0 || lbutton > MOUSE_MAXBUTTON)
			return FALSE;
		if (pbutton <= 0 || pbutton > MOUSE_MAXBUTTON)
			return FALSE;
		p2l[pbutton - 1] = lbutton - 1;
	}
	return TRUE;
}

/* terminate signals handler */
static void
terminate(int sig)
{
	struct wscons_event event;
	unsigned int res;

	if (mouse.mfd != -1) {
		event.type = WSCONS_EVENT_WSMOUSED_OFF;
		ioctl(mouse.cfd, WSDISPLAYIO_WSMOUSED, &event);
		res = WSMOUSE_RES_DEFAULT;
		ioctl(mouse.mfd, WSMOUSEIO_SRES, &res);
		close(mouse.mfd);
		mouse.mfd = -1;
	}
	_exit(0);
}

/* buttons status (for multiple click detection) */
static struct {
	int count;		/* 0: up, 1: single click, 2: double click,... */
	struct timeval tv;	/* timestamp on the last `up' event */
} buttonstate[MOUSE_MAXBUTTON];

/*
 * handle button click
 * Note that an ioctl is sent for each button
 */
static void
mouse_click(struct wscons_event *event)
{
	struct timeval max_date;
	struct timeval now;
	struct timeval delay;
	int i; /* button number */
	
	i = event->value = p2l[event->value];

	gettimeofday(&now, NULL);
	delay.tv_sec = mouse.clickthreshold / 1000;
	delay.tv_usec = (mouse.clickthreshold % 1000) * 1000;
	timersub(&now, &delay, &max_date);

	if (event->type == WSCONS_EVENT_MOUSE_DOWN) {
		if (timercmp(&max_date, &buttonstate[i].tv, >)) {
			timerclear(&buttonstate[i].tv);
			buttonstate[i].count = 1;
		} else {
			buttonstate[i].count++;
		}
	} else {
		/* button is up */
		buttonstate[i].tv.tv_sec = now.tv_sec;
		buttonstate[i].tv.tv_usec = now.tv_usec;
	}

	/*
	 * we use the time field of wscons_event structure to put the number
	 * of multiple clicks
	 */
	if (event->type == WSCONS_EVENT_MOUSE_DOWN) {
		event->time.tv_sec = buttonstate[i].count;
		event->time.tv_nsec = 0;
	} else {
		/* button is up */
		event->time.tv_sec = 0;
		event->time.tv_nsec = 0;
	}
	ioctl(mouse.cfd, WSDISPLAYIO_WSMOUSED, event);
}

/* workaround for cursor speed on serial mice */
static void
normalize_event(struct wscons_event *event)
{
	int dx, dy;
	int two_power = 1;

/* 2: normal speed, 3: slower cursor, 1: faster cursor */
#define NORMALIZE_DIVISOR 3

	switch (event->type) {
	case WSCONS_EVENT_MOUSE_DELTA_X:
		dx = abs(event->value);
		while (dx > 2) {
			two_power++;
			dx = dx / 2;
		}
		event->value = event->value / (NORMALIZE_DIVISOR * two_power);
		break;
	case WSCONS_EVENT_MOUSE_DELTA_Y:
		two_power = 1;
		dy = abs(event->value);
		while (dy > 2) {
			two_power++;
			dy = dy / 2;
		}
		event->value = event->value / (NORMALIZE_DIVISOR * two_power);
		break;
	}
}

/* send a wscons_event to the kernel */
static void
treat_event(struct wscons_event *event)
{
	if (IS_MOTION_EVENT(event->type)) {
		ioctl(mouse.cfd, WSDISPLAYIO_WSMOUSED, event);
	} else if (IS_BUTTON_EVENT(event->type) &&
	    (uint)event->value < MOUSE_MAXBUTTON) {
		mouse_click(event);
	}
}

/* split a full mouse event into multiples wscons events */
static void
split_event(mousestatus_t *act)
{
	struct wscons_event event;
	int button, i, mask;

	if (act->dx != 0) {
		event.type = WSCONS_EVENT_MOUSE_DELTA_X;
		event.value = act->dx;
		normalize_event(&event);
		treat_event(&event);
	}
	if (act->dy != 0) {
		event.type = WSCONS_EVENT_MOUSE_DELTA_Y;
		event.value = 0 - act->dy;
		normalize_event(&event);
		treat_event(&event);
	}
	if (act->dz != 0) {
		event.type = WSCONS_EVENT_MOUSE_DELTA_Z;
		event.value = act->dz;
		treat_event(&event);
	}
	if (act->dw != 0) {
		event.type = WSCONS_EVENT_MOUSE_DELTA_W;
		event.value = act->dw;
		treat_event(&event);
	}

	/* buttons state */
	mask = act->flags & MOUSE_BUTTONS;
	if (mask == 0)
		/* no button modified */
		return;

	button = MOUSE_BUTTON1DOWN;
	for (i = 0; (i < MOUSE_MAXBUTTON) && (mask != 0); i++) {
		if (mask & 1) {
			event.type = (act->button & button) ?
			    WSCONS_EVENT_MOUSE_DOWN : WSCONS_EVENT_MOUSE_UP;
			event.value = i;
			treat_event(&event);
		}
		button <<= 1;
		mask >>= 1;
	}
}

/* main function */
static void
wsmoused(void)
{
	mousestatus_t action;
	struct wscons_event event; /* original wscons_event */
	struct pollfd pfd[1];
	int res;
	u_char b;

	/* notify kernel the start of wsmoused */
	event.type = WSCONS_EVENT_WSMOUSED_ON;
	res = ioctl(mouse.cfd, WSDISPLAYIO_WSMOUSED, &event);
	if (res != 0) {
		/* the display driver has no getchar() method */
		logerr(1, "this display driver has no support for wsmoused(8)");
	}

	bzero(&action, sizeof(action));
	bzero(&event, sizeof(event));
	bzero(&buttonstate, sizeof(buttonstate));

	pfd[0].fd = mouse.mfd;
	pfd[0].events = POLLIN;

	/* process mouse data */
	for (;;) {
		if (poll(pfd, 1, INFTIM) <= 0)
			logwarn("failed to read from mouse");

		if (mouse.proto == P_WSCONS) {
			/* wsmouse supported mouse */
			read(mouse.mfd, &event, sizeof(event));
			treat_event(&event);
		} else {
			/* serial mouse (not supported by wsmouse) */
			res = read(mouse.mfd, &b, 1);

			/* if we have a full mouse event */
			if (mouse_protocol(b, &action))
				/* split it as multiple wscons_event */
				split_event(&action);
		}
	}
}


static void
usage(void)
{
	fprintf(stderr, "usage: %s [-2dfi] [-C thresh] [-D device]"
	    " [-M N=M]\n\t[-p device] [-t type]\n", __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	unsigned int type;
	int opt;
	int i;

#define GETOPT_STRING "2dfhip:t:C:D:M:"
	while ((opt = (getopt(argc, argv, GETOPT_STRING))) != -1) {
		switch (opt) {
		case '2':
			/* on two button mice, right button pastes */
			p2l[MOUSE_BUTTON3] = MOUSE_BUTTON2;
			break;
		case 'd':
			++debug;
			break;
		case 'f':
			nodaemon = TRUE;
			break;
		case 'h':
			usage();
			break;
		case 'i':
			identify = TRUE;
			nodaemon = TRUE;
			break;
		case 'p':
			if ((mouse.portname = strdup(optarg)) == NULL)
				logerr(1, "out of memory");
			break;
		case 't':
			if (strcmp(optarg, "auto") == 0) {
				mouse.proto = P_UNKNOWN;
				mouse.flags &= ~NoPnP;
				break;
			}
			for (i = 0; mouse_names[i] != NULL; i++)
				if (strcmp(optarg,mouse_names[i]) == 0) {
					mouse.proto = i;
					mouse.flags |= NoPnP;
					break;
				}
			if (mouse_names[i] != NULL)
				break;
			warnx("no such mouse protocol `%s'", optarg);
			usage();
			break;
		case 'C':
#define MAX_CLICKTHRESHOLD 2000 /* max delay for double click */
			mouse.clickthreshold = atoi(optarg);
			if (mouse.clickthreshold < 0 ||
			    mouse.clickthreshold > MAX_CLICKTHRESHOLD) {
				warnx("invalid threshold `%s': max value is %d",
				    optarg, MAX_CLICKTHRESHOLD);
				usage();
			}
			break;
		case 'D':
			if ((mouse.ttyname = strdup(optarg)) == NULL)
				logerr(1, "out of memory");
			break;
		case 'M':
			if (!mouse_installmap(optarg)) {
				warnx("invalid mapping `%s'", optarg);
				usage();
			}
			break;
		default:
			usage();
		}
	}

	/*
	 * Use defaults if unspecified
	 */
	if (mouse.portname == NULL)
		mouse.portname = WSMOUSE_DEV;
	if (mouse.ttyname == NULL)
		mouse.ttyname = DEFAULT_TTY;

	if (identify == FALSE) {
		if ((mouse.cfd = open(mouse.ttyname, O_RDWR, 0)) == -1)
			logerr(1, "cannot open %s", mouse.ttyname);
	}

	if ((mouse.mfd = open(mouse.portname,
	    O_RDONLY | O_NONBLOCK, 0)) == -1)
		logerr(1, "unable to open %s", mouse.portname);

	/*
	 * Find out whether the mouse device is a wsmouse device
	 * or a serial device.
	 */
	if (ioctl(mouse.mfd, WSMOUSEIO_GTYPE, &type) != -1)
		mouse.proto = P_WSCONS;
	else {
		if (mouse_identify() == P_UNKNOWN) {
			close(mouse.mfd);
			logerr(1, "cannot determine mouse type on %s",
			    mouse.portname);
		}
	}

	if (identify == TRUE) {
		if (mouse.proto == P_WSCONS)
			wsmouse_identify();
		else
			printf("serial mouse: %s type\n",
			    mouse_name(mouse.proto));
		exit(0);
	}

	signal(SIGINT, terminate);
	signal(SIGQUIT, terminate);
	signal(SIGTERM, terminate);

	if (mouse.proto == P_WSCONS)
		wsmouse_init();
	else
		mouse_init();

	if (!nodaemon) {
		openlog(__progname, LOG_PID, LOG_DAEMON);
		if (daemon(0, 0)) {
			logerr(1, "failed to become a daemon");
		} else {
			background = TRUE;
		}
	}

	wsmoused();
	exit(0);
}
@


1.35
log
@Remove function mouse_map. This function is redundant.

ok zhuk@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.34 2014/12/22 11:21:49 shadchin Exp $ */
a75 1
#define	DEFAULT_PIDFILE	"/var/run/wsmoused.pid"
a83 1
char *pidfile = NULL;
a233 2
	if (pidfile != NULL)
		unlink(pidfile);
d432 1
a432 1
	fprintf(stderr, "usage: %s [-2dfi] [-C thresh] [-D device] [-I file]"
a439 1
	FILE *fp;
d444 1
a444 1
#define GETOPT_STRING "2dfhip:t:C:D:I:M:"
a498 3
		case 'I':
			pidfile = optarg;
			break;
a564 7
			if (pidfile != NULL) {
				fp = fopen(pidfile, "w");
				if (fp != NULL) {
					fprintf(fp, "%ld\n", (long)getpid());
					fclose(fp);
				}
			}
@


1.34
log
@Now does not need to be initialized event.value.
This not used anymore.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.33 2014/12/21 18:23:37 shadchin Exp $ */
a220 8
/* mouse_map : converts physical buttons to logical buttons */
static void
mouse_map(struct wscons_event *orig, struct wscons_event *mapped)
{
	mapped->type = orig->type;
	mapped->value = p2l[orig->value];
}

d257 3
a259 1
	int i = event->value; /* button number */
a328 2
	struct wscons_event mapped_event;

d333 1
a333 2
		mouse_map(event, &mapped_event);
		mouse_click(&mapped_event);
@


1.33
log
@Cleanup - remove event WSCONS_EVENT_WSMOUSED_SLEEP, WSCONS_EVENT_WSMOUSED_CLOSE.
Do not need it now.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.32 2014/05/14 18:23:22 shadchin Exp $ */
a403 3
	struct stat mdev_stat;

	/* initialization */
d405 1
a406 13
	if (mouse.proto == P_WSCONS) {
		/* get major and minor of mouse device */
		res = stat(mouse.portname, &mdev_stat);
		if (res != -1)
			event.value = mdev_stat.st_rdev;
		else
			event.value = 0;
	} else {
		/* X11 won't start when using wsmoused(8) with a serial mouse */
		event.value = 0;
	}

	/* notify kernel the start of wsmoused */
@


1.32
log
@Remove mouse.baudrate, it is always 1200.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.31 2014/05/14 18:18:01 shadchin Exp $ */
d332 1
a332 1
static int
a338 1
		return 1;
a342 1
		return 1;
a343 4
	if (event->type == WSCONS_EVENT_WSMOUSED_CLOSE)
		/* we have to close mouse fd */
		return 0;
	return 1;
d443 1
a443 50
			res = treat_event(&event);
			if (!res) {
				/*
				 * close mouse device and sleep until
				 * the X server releases it
				 */

				struct wscons_event sleeping;
				unsigned int tries;

				/* restore mouse resolution to default value */
				res = WSMOUSE_RES_DEFAULT;
				ioctl(mouse.mfd, WSMOUSEIO_SRES, &res);

				close(mouse.mfd);
				mouse.mfd = -1;

				/* sleep until X server releases mouse device */
				sleeping.type = WSCONS_EVENT_WSMOUSED_SLEEP;
				sleeping.value = 0;
				ioctl(mouse.cfd, WSDISPLAYIO_WSMOUSED,
				    &sleeping);

				/*
				 * Since the X server could still be running
				 * (e.g. when switching from the graphics
				 * screen to a virtual text console), it might
				 * not have freed the device yet.
				 *
				 * Try to open the device until it succeeds.
				 */
				tries = 0;
				for (;;) {
					if ((mouse.mfd = open(mouse.portname,
					    O_RDONLY | O_NONBLOCK, 0)) != -1)
						break;

					if (tries < 10) {
						tries++;
						sleep(1);
					} else {
						logwarn("unable to open %s, "
						    "will retry in 10 seconds",
						    mouse.portname);
						sleep(10);
					}
				}

				wsmouse_init();
			}
@


1.31
log
@Remove unused code.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.30 2014/05/14 18:14:09 shadchin Exp $ */
a91 1
	.baudrate = 1200,
@


1.30
log
@Remove unused variables.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.29 2013/11/24 01:06:19 deraadt Exp $ */
a92 1
	.old_baudrate = 1200,
@


1.29
log
@more unsigned char casts for ctype
ok jca
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.28 2013/04/18 02:29:59 deraadt Exp $ */
a95 2
	.zmap = 0,
	.wmode = 0,
@


1.28
log
@struct timezone is so 1980
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.27 2011/10/18 20:07:46 djm Exp $ */
d185 1
a185 1
	while (isspace(*s))
d201 1
a201 1
		while (isdigit(*arg))
d210 1
a210 1
		while (isdigit(*arg))
d212 1
a212 1
		if (arg <= s || (!isspace(*arg) && *arg != '\0'))
@


1.27
log
@delay daemon fork() until after initialisation has completed to fix
rc race that caused X11 to fail to open /dev/wsmouse; ok stsp miod
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.26 2011/03/22 10:16:23 okan Exp $ */
a268 1
	struct timezone tz;
d271 1
a271 1
	gettimeofday(&now, &tz);
@


1.26
log
@use timerclear macro

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.25 2009/06/21 16:13:18 jacekm Exp $ */
a609 16
	if (!nodaemon) {
		openlog(__progname, LOG_PID, LOG_DAEMON);
		if (daemon(0, 0)) {
			logerr(1, "failed to become a daemon");
		} else {
			background = TRUE;
			if (pidfile != NULL) {
				fp = fopen(pidfile, "w");
				if (fp != NULL) {
					fprintf(fp, "%ld\n", (long)getpid());
					fclose(fp);
				}
			}
		}
	}

d650 16
@


1.25
log
@Support mouses with lots of buttons.  Also, fix a crash when pressing
a button that's outside of the hardcoded range; miod@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.24 2009/06/05 03:37:10 miod Exp $ */
d279 1
a279 2
			buttonstate[i].tv.tv_sec = 0;
			buttonstate[i].tv.tv_usec = 0;
@


1.24
log
@Add the ability to attach wsmoused to a different wsdisplay than wsdisplay0
(i.e. ttyCcfg) with the new -D option.

While there, a lot of cleanup, including not creating a pidfile by default
(since there might be more than one wsmoused running on multiple wsdisplay
systems).
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.23 2007/11/24 16:28:09 miod Exp $ */
d346 2
a347 1
	} else if (IS_BUTTON_EVENT(event->type)) {
@


1.23
log
@Since switches from X to consoles are aysnchronous, wsmoused(8) can be awakened
before the X server has release the mouse device. Instead of an arbitrary sleep,
loop (with increasing delays) until we can open the device again.

Found the hard way and tested by jmc@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.22 2007/09/18 20:19:20 otto Exp $ */
d75 3
d82 1
a83 1
int background = FALSE;
d85 1
a85 1
char *pidfile = "/var/run/wsmoused.pid";
d90 1
d111 1
d138 15
d248 2
a249 1
	unlink(pidfile);
a414 1
	FILE *fp;
a416 16
	if (!nodaemon && !background) {
		if (daemon(0, 0)) {
			logerr(1, "failed to become a daemon");
		} else {
			background = TRUE;
			fp = fopen(pidfile, "w");
			if (fp != NULL) {
				fprintf(fp, "%ld\n", (long)getpid());
				fclose(fp);
			}
		}
	}

	if ((mouse.cfd = open("/dev/ttyCcfg", O_RDWR, 0)) == -1)
		logerr(1, "cannot open /dev/ttyCcfg");

d420 1
a420 2
	if (IS_WSMOUSE_DEV(mouse.portname)) {

d427 3
a430 3
	else
		/* X11 won't start using wsmoused(8) with a serial mouse */
		event.value = 0;
d432 1
a432 1
	/* notify kernel to start wsmoused */
d450 2
a451 1
		if (IS_WSMOUSE_DEV(mouse.portname)) {
d456 4
a459 2
				/* close mouse device and sleep until
				   the X server release it */
d495 1
a495 1
						logerr(1, "unable to open %s, "
d502 1
a502 1
				mouse_init();
d520 2
a521 2
	fprintf(stderr, "usage: %s [-2dfi] [-C thresh] [-I file] [-M N=M] \
[-p device] [-t type]\n", __progname);
d528 2
d533 1
a533 1
#define GETOPT_STRING "2dfhip:t:C:I:M:"
d551 1
d584 4
d601 4
a605 1
		/* default is /dev/wsmouse */
d607 2
d610 1
a610 1
	if (!nodaemon)
d612 10
a621 13

	for (;;) {
		signal(SIGINT , terminate);
		signal(SIGQUIT, terminate);
		signal(SIGTERM, terminate);
		if ((mouse.mfd = open(mouse.portname,
		    O_RDONLY | O_NONBLOCK, 0)) == -1)
			logerr(1, "unable to open %s", mouse.portname);
		if (IS_SERIAL_DEV(mouse.portname)) {
			if (mouse_identify() == P_UNKNOWN) {
				close(mouse.mfd);
				logerr(1, "cannot determine mouse type on %s",
				    mouse.portname);
d624 10
d635 11
a645 7
		if (identify == TRUE) {
			if (IS_WSMOUSE_DEV(mouse.portname))
				wsmouse_identify();
			else
				printf("serial mouse: %s type\n",
				    (char *)mouse_name(mouse.proto));
			exit(0);
d647 1
d649 16
d666 3
a668 2
		wsmoused();
	}
@


1.22
log
@use C99 explicit struct initializer instead of deprecated gcc 2.5
style. ok miod@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.21 2007/04/10 22:37:17 miod Exp $ */
d456 1
d471 24
a494 2
				/* waiting for availability of mouse device */
				sleep(1);
a495 4
				if ((mouse.mfd = open(mouse.portname,
				    O_RDONLY | O_NONBLOCK, 0)) == -1)
					logerr(1, "unable to open %s",
					    mouse.portname);
@


1.21
log
@Add support for a fourth axis on wsmouse devices, e.g. on the Apple Might
Mouse.  Currently limited to USB mice.

Adapted from a diff from Gareth <garf@@loveandnature.co.za> on tech@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.20 2006/04/17 08:42:41 deraadt Exp $ */
d85 11
a95 11
	flags : 0,
	portname : NULL,
	proto : P_UNKNOWN,
	baudrate : 1200,
	old_baudrate : 1200,
	rate : MOUSE_RATE_UNKNOWN,
	resolution : MOUSE_RES_UNKNOWN,
	zmap : 0,
	wmode : 0,
	mfd : -1,
	clickthreshold : 500,	/* 0.5 sec */
@


1.20
log
@setjmp.h not used
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.19 2005/08/12 21:13:34 jmc Exp $ */
d358 5
@


1.19
log
@prefer a simpler synopsis: we do not really need a separate case for -i;
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.18 2004/01/04 21:41:12 drahn Exp $ */
a64 1
#include <setjmp.h>
@


1.18
log
@gcc3 doesn't like varargs, it was found that the varargs.h inclusion is
unnecessary for these files, delete. ok espie@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.17 2003/12/22 11:11:27 miod Exp $ */
d491 1
a491 1
	fprintf(stderr, "usage: %s [-2df] [-C thresh] [-I file] [-M N=M] \
a492 1
	fprintf(stderr, "       %s -i [-p device]\n", __progname);
@


1.17
log
@No need to setup a signal handler for SIGKILL as you can't catch it anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.16 2003/11/08 08:49:51 jmc Exp $ */
a71 1
#include <varargs.h>
@


1.16
log
@- correct SYNOPSIS
- sort options
- sync usage()
- new sentence, new line
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.15 2003/09/26 16:09:27 deraadt Exp $ */
a577 1
		signal(SIGKILL, terminate);
@


1.15
log
@check strdup failure; ok anil millert
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.14 2003/04/13 11:20:47 jmc Exp $ */
d492 3
a494 3
	fprintf(stderr, "usage: %s [-2df] [-t protocol] [-C threshold] [-I file] \
[-M N=M] [-p port]", __progname);
	fprintf(stderr, "       %s -i [-p port]\n", __progname);
@


1.14
log
@try to use the X Window System, X11 or XFree86 consistently.

diffs from Paul Weismann, via mickey@@
aided, abetted and ok'd matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.13 2002/05/30 19:09:05 deraadt Exp $ */
d524 2
a525 1
			mouse.portname = strdup(optarg);
@


1.13
log
@minor KNF
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.12 2002/05/26 09:32:44 deraadt Exp $ */
d423 1
a423 1
		/* X-Window won't start using wsmoused(8) with a serial mouse */
@


1.12
log
@pid_t cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.11 2002/03/27 18:54:09 jbm Exp $ */
d332 1
a332 1
	if (event->type == WSCONS_EVENT_WSMOUSED_CLOSE) 
d417 1
a417 1
		if (res != -1) 
d419 1
a419 1
		else 
d449 1
a449 1
				/* close mouse device and sleep until 
d460 1
a460 1
				
d464 1
a464 1
				ioctl(mouse.cfd, WSDISPLAYIO_WSMOUSED, 
d470 3
a472 3
				if ((mouse.mfd = open(mouse.portname, 
				    O_RDONLY | O_NONBLOCK, 0)) == -1) 
					logerr(1, "unable to open %s", 
@


1.11
log
@Add X-Window support to wsmoused(8). This allows running wsmoused(8) and
X-Window at the same time, removing the need to kill wsmoused(8) before
starting X-Window.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.10 2002/03/14 06:51:42 mpech Exp $ */
d401 1
a401 1
				fprintf(fp, "%d\n", getpid());
@


1.10
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.9 2002/02/15 02:18:39 deraadt Exp $ */
d54 1
d224 1
a224 1
		ioctl(mouse.mfd, WSDISPLAYIO_WSMOUSED, &event);
d319 1
a319 1
static void
d326 1
d330 1
d332 4
d392 1
d413 14
d430 1
a430 1
		logerr(1, "this display driver has no support for wsmoused");
d447 29
a475 1
			treat_event(&event);
d477 1
a477 1
			/* serial mouse (not wsmouse supported) */
@


1.9
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.8 2002/01/12 01:15:37 miod Exp $ */
d139 1
a139 1
		warnx("unable to open %s\n", mouse.portname);
d490 1
a490 1
			warnx("no such mouse protocol `%s'\n", optarg);
d498 1
a498 1
				warnx("invalid threshold `%s': max value is %d\n",
d508 1
a508 1
				warnx("invalid mapping `%s'\n", optarg);
@


1.8
log
@Make sure the daemon() call is harmless to file descriptors.
Problem reported by markus@@, fix by me, ok markus@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.7 2001/12/09 14:58:27 miod Exp $ */
d5 1
a5 1
 * 
d9 1
a9 1
 * 
d17 1
a17 1
 * Michael Smith. The FreeBSD moused daemon already contained code from the 
d22 1
a22 1
 * 
d58 1
a58 1
 
d75 1
a75 1
 
d78 1
a78 1
 
d86 11
a96 11
    flags : 0, 
    portname : NULL,
    proto : P_UNKNOWN,
    baudrate : 1200, 
    old_baudrate : 1200,
    rate : MOUSE_RATE_UNKNOWN,
    resolution : MOUSE_RES_UNKNOWN, 
    zmap : 0,
    wmode : 0,
    mfd : -1,
    clickthreshold : 500,	/* 0.5 sec */
d100 1
a100 1
void 
d104 1
a104 1
	
d108 1
a108 1
	       	printf("wsmouse supported mouse: ");
a140 2
				

d147 1
a147 1
	unsigned int rate = WSMOUSE_RATE_DEFAULT;	
d151 1
a151 2
}	

d162 1
a162 1
    
d166 1
a166 1
	while(isspace(*s))
a202 1

d211 1
a211 1
	mapped->value = p2l[orig->value]; 	
d239 3
a241 3
/* 
 * handle button click 
 * Note that an ioctl is sent for each button 
d251 2
a252 2
    
	gettimeofday(&now, &tz); 
d255 2
a256 2
	timersub(&now, &delay, &max_date); 
    
d270 2
a271 2
	    
	/* 
d273 1
a273 1
	 * of multiple clicks 
a285 1

d300 1
a300 1
			two_power++; 
d309 1
a309 1
			two_power++; 
d318 1
a318 1
static void 
a330 1

d332 1
a332 1
static void 
d356 2
a357 2
	/* buttons state */	
	mask = act->flags & MOUSE_BUTTONS; 
a372 1

d403 1
a403 1
    
d410 1
a410 1
    
d414 1
a414 1
    
d425 1
a425 1
			treat_event(&event);	
d429 1
a429 1
	
a436 1
	
d438 2
a439 1
static void 
d448 1
a448 1
int 
d496 1
a496 1
			if (mouse.clickthreshold < 0 || 
d519 1
a519 1
		
d528 2
a529 2
		if ((mouse.mfd = open(mouse.portname, 
		    O_RDONLY | O_NONBLOCK, 0)) == -1) 
d540 1
a540 1
			if (IS_WSMOUSE_DEV(mouse.portname)) 
d542 1
a542 1
			else 
d548 1
a548 1
		mouse_init(); 
@


1.7
log
@Do not use stdio functions after a successfull call to daemon(), use
syslog() instead.
ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.6 2001/11/02 16:19:48 deraadt Exp $ */
a392 3
	if ((mouse.cfd = open("/dev/ttyCcfg", O_RDWR, 0)) == -1)
		logerr(1, "cannot open /dev/ttyCcfg");

d405 3
@


1.6
log
@_exit() in signal handler
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.5 2001/09/20 21:22:16 miod Exp $ */
d415 1
a415 1
		errx(1, "this display driver has no support for wsmoused\n");
d527 3
@


1.5
log
@Jumbo wsmoused cosmeto:
- fix some cosmetic bugs
- improves some code paths
- generalizes the use of stderr, and uses errx/warnx whenevr possible
- converts wsmoused.c to KNF
ok jbm@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.4 2001/08/31 22:34:54 jbm Exp $ */
d234 1
a234 1
	exit(0);
@


1.4
log
@Restore mouse resolution to default value at exit.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.3 2001/08/13 06:32:18 pvalchev Exp $ */
a75 2
extern char *optarg;
extern int optind;
d93 2
a94 2
    zmap: 0,
    wmode: 0,
d105 3
a107 2
	if (mouse.mfd) {
		ioctl(mouse.mfd, WSMOUSEIO_GTYPE, &type);
d110 27
a136 27
			case WSMOUSE_TYPE_VSXXX:
				printf("DEC serial\n");
				break;
			case WSMOUSE_TYPE_PS2:
				printf("PS/2 compatible\n");
				break;
			case WSMOUSE_TYPE_USB:
				printf("USB \n");
				break;
			case WSMOUSE_TYPE_LMS:
				printf("Logitech busmouse\n");
				break;
			case WSMOUSE_TYPE_MMS:
				printf("Microsoft InPort mouse\n");
				break;
			case WSMOUSE_TYPE_TPANEL:
				printf("Generic Touch Panel\n");
				break;
			case WSMOUSE_TYPE_NEXT:
				printf("NeXT\n");
				break;
			case WSMOUSE_TYPE_ARCHIMEDES:
				printf("Archimedes\n");
				break;
			default:
				printf("Unknown\n");
				break;
d138 2
a139 3
	}
	else
		printf("Unable to open %s \n", mouse.portname);
a142 1
	
d162 2
a163 2
    MOUSE_BUTTON1, MOUSE_BUTTON2, MOUSE_BUTTON3, MOUSE_BUTTON4, 
    MOUSE_BUTTON5, MOUSE_BUTTON6, MOUSE_BUTTON7, MOUSE_BUTTON8, 
d169 3
a171 3
    while(isspace(*s))
	++s;
    return s;
d178 28
a205 28
    int pbutton;
    int lbutton;
    char *s;

    while (*arg) {
	arg = skipspace(arg);
	s = arg;
	while (isdigit(*arg))
	    ++arg;
	arg = skipspace(arg);
	if ((arg <= s) || (*arg != '='))
	    return FALSE;
	lbutton = atoi(s);

	arg = skipspace(++arg);
	s = arg;
	while (isdigit(*arg))
	    ++arg;
	if ((arg <= s) || (!isspace(*arg) && (*arg != '\0')))
	    return FALSE;
	pbutton = atoi(s);

	if ((lbutton <= 0) || (lbutton > MOUSE_MAXBUTTON))
	    return FALSE;
	if ((pbutton <= 0) || (pbutton > MOUSE_MAXBUTTON))
	    return FALSE;
	p2l[pbutton - 1] = lbutton - 1;
    }
d207 1
a207 1
    return TRUE;
d239 2
a240 2
    int count;		/* 0: up, 1: single click, 2: double click,... */
    struct timeval tv;	/* timestamp on the last `up' event */
d250 5
a254 5
    struct timeval max_date;
    struct timeval now;
    struct timeval delay;
    struct timezone tz;
    int i = event->value; /* button number */
d256 4
a259 4
    gettimeofday(&now, &tz); 
    delay.tv_sec = mouse.clickthreshold / 1000;
    delay.tv_usec = (mouse.clickthreshold % 1000) * 1000;
    timersub(&now, &delay, &max_date); 
d261 13
a273 14
    if (event->type == WSCONS_EVENT_MOUSE_DOWN) {
	    if (timercmp(&max_date, &buttonstate[i].tv, >)) {
		    buttonstate[i].tv.tv_sec = 0;
		    buttonstate[i].tv.tv_usec = 0;
		    buttonstate[i].count = 1;
	    } 
	    else {
		    buttonstate[i].count++;
	    }
    } else {
	    /* button is up */
	    buttonstate[i].tv.tv_sec = now.tv_sec;
	    buttonstate[i].tv.tv_usec = now.tv_usec;
    }	    
d275 13
a287 14
    /* 
     * we use the time field of wscons_event structure to put the number
     * of multiple clicks 
     */
    if (event->type == WSCONS_EVENT_MOUSE_DOWN) {
	    event->time.tv_sec = buttonstate[i].count;
	    event->time.tv_nsec = 0;
    }
    else {
	   /* button is up */
	   event->time.tv_sec = 0;
	   event->time.tv_nsec = 0;
    }
    ioctl(mouse.cfd, WSDISPLAYIO_WSMOUSED, event);
d301 2
a302 1
	if (event->type == WSCONS_EVENT_MOUSE_DELTA_X) {
d309 2
a310 4
		return ;
	}
	
	if (event->type == WSCONS_EVENT_MOUSE_DELTA_Y) {
d318 1
a319 1
	return ;
d330 1
a330 3
		return ;
	}
	if (IS_BUTTON_EVENT(event->type)) {
a332 1
		return ;
a333 1
	return ;
d371 4
a374 12
			if (act->button & button) {
				/* button is down */
				event.type = WSCONS_EVENT_MOUSE_DOWN;
				event.value = i;
				treat_event(&event);
			}
			else {
				/* button is up */
				event.type = WSCONS_EVENT_MOUSE_UP;
				event.value = i;
				treat_event(&event);
			}
d386 21
a406 20
    mousestatus_t action;
    struct wscons_event event; /* original wscons_event */
    struct pollfd pfd[1];
    int res;
    u_char b;
    FILE *fp;

    if ((mouse.cfd = open("/dev/ttyCcfg", O_RDWR, 0)) == -1)
	logerr(1, "cannot open /dev/ttyCcfg");

    if (!nodaemon && !background) {
	if (daemon(0, 0)) {
	    logerr(1, "failed to become a daemon");
	} else {
	  background = TRUE;
	    fp = fopen(pidfile, "w");
	    if (fp != NULL) {
		fprintf(fp, "%d\n", getpid());
		fclose(fp);
	    }
a407 1
    }
d409 1
a409 1
    /* initialization */
d411 6
a416 8
    event.type = WSCONS_EVENT_WSMOUSED_ON;
    res = ioctl(mouse.cfd, WSDISPLAYIO_WSMOUSED, &event);
    if (res != 0) {
	/* the display driver has no getchar() method */
	fprintf(stderr, 
		"Error: this display driver has no support for wsmoused\n");
	exit(1);    
    }
d418 3
a420 3
    bzero(&action, sizeof(action));
    bzero(&event, sizeof(event));
    bzero(&buttonstate, sizeof(buttonstate));
d422 2
a423 2
    pfd[0].fd = mouse.mfd;
    pfd[0].events = POLLIN;
d425 11
a435 13
    /* process mouse data */
    for (;;) {

	if (poll(pfd, 1, INFTIM) <= 0)
		logwarn("failed to read from mouse");
	if (IS_WSMOUSE_DEV(mouse.portname))  {
		/* wsmouse supported mouse */
		read(mouse.mfd, &event, sizeof(event));
		treat_event(&event);	
	}
	else {	
		/* serial mouse (not wsmouse supported) */
		res = read(mouse.mfd, &b, 1);
d437 6
a442 6
		/* if we have a full mouse event */
		if (mouse_protocol(b, &action))
			/* split it as multiple wscons_event */
			split_event(&action);
	}	
    }
d449 3
a451 3
	printf("usage: %s [-2df] [-t protocol] [-C threshold] [-I file] \
[-M N=M] [-p port]",__progname);
	printf("       %s -i [-p port] \n",__progname);
d464 23
a486 3
			case '2':
				/* on two button mice, right button pastes */
				p2l[MOUSE_BUTTON3] = MOUSE_BUTTON2;
d488 5
a492 20
			case 'd':
				++debug;
				break;
			case 'f':
				nodaemon = TRUE;
				break;
			case 'h':
				usage();
				return 1;
				break;
			case 'i':
				identify = TRUE;	
				break;
			case 'p':
				mouse.portname = strdup(optarg);
				break;
			case 't':
				if (strcmp(optarg, "auto") == 0) {
					mouse.proto = P_UNKNOWN;
					mouse.flags &= ~NoPnP;
d495 1
a495 10
				for (i = 0; mouse_names[i]; i++)
					if (strcmp(optarg,mouse_names[i]) == 0){
						mouse.proto = i;
						mouse.flags |= NoPnP;
						break;
					}
				if (mouse_names[i])
					break;
				printf("no such mouse protocol `%s'\n", optarg);
				usage();
d497 4
a500 1
			case 'C':
d502 14
a515 19
				
				mouse.clickthreshold = atoi(optarg);
				if ((mouse.clickthreshold < 0) || 
				(mouse.clickthreshold > MAX_CLICKTHRESHOLD)) {
					printf("invalid threshold `%s': max value is %d\n"
						, optarg,MAX_CLICKTHRESHOLD);
					usage();
				}
				break;
			case 'I':
				pidfile = optarg;
				break;
			case 'M':
				if (!mouse_installmap(optarg)) {
					warnx("invalid mapping `%s'\n", optarg);
					usage();
				}
				break;
			default:
d517 4
d523 1
a523 1
	if (!mouse.portname)
d525 1
a525 1
		mouse.portname = "/dev/wsmouse";
d533 1
a533 1
					O_RDONLY | O_NONBLOCK, 0)) == -1) 
a536 1
				logwarn("cannot determine mouse type on %s", mouse.portname);
d538 2
a539 1
				mouse.mfd = -1;
d548 2
a549 2
						(char *)mouse_name(mouse.proto));
			return (0);
a551 4
		if (mouse.mfd == -1) {
			exit(1);
		}		
		
a553 1
		
a555 1

@


1.3
log
@Wall cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.2 2001/08/12 17:53:16 fgsch Exp $ */
d226 1
d231 2
@


1.2
log
@Use INFTIM where possible.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.c,v 1.1 2001/04/14 04:47:41 aaron Exp $ */
a85 1
static sigjmp_buf env;
d569 1
a569 1
						mouse_name(mouse.proto));
@


1.1
log
@Userland daemon for wscons console mouse features.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d446 1
a446 1
	if (poll(pfd, 1, -1) <= 0)
@

