head	1.36;
access;
symbols
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.36.0.4
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.28.0.8
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.25.0.4
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.36
date	2016.09.26.17.15.19;	author jca;	state Exp;
branches;
next	1.35;
commitid	cejVwQpY7FYSCLBx;

1.35
date	2016.09.15.16.16.03;	author jca;	state Exp;
branches;
next	1.34;
commitid	GzAm3cnfimMp8ONG;

1.34
date	2016.02.12.08.12.48;	author ajacoutot;	state Exp;
branches;
next	1.33;
commitid	v3CLPfKe85TgKyjv;

1.33
date	2015.12.22.08.35.17;	author mmcc;	state Exp;
branches;
next	1.32;
commitid	k4LuCeILqPBEVbtl;

1.32
date	2015.12.04.19.05.43;	author sebastia;	state Exp;
branches;
next	1.31;
commitid	UjkmZVF7N2AxqjPP;

1.31
date	2015.12.01.07.32.37;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	jEohs636eIVa2Oc1;

1.30
date	2015.01.21.21.50.33;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	3o2AkhiRPQXvG94X;

1.29
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.28;
commitid	jdBY2kKXhfcoQitp;

1.28
date	2013.03.15.13.31.27;	author benno;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.10.21.28.26;	author benno;	state Exp;
branches;
next	1.25;

1.25
date	2012.04.05.19.08.40;	author camield;	state Exp;
branches;
next	1.24;

1.24
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2011.06.21.17.31.07;	author mikeb;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.28.00.17.28;	author mikeb;	state Exp;
branches;
next	1.21;

1.21
date	2011.03.25.14.51.31;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.01.13.46.14;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.13.07.25.26;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.22.02.22.22;	author joel;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.26.18.52.53;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.15.15.18.02;	author camield;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.01.09.31.41;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.30.13.24.00;	author camield;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.30.13.01.54;	author camield;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.12.07.28.41;	author camield;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.15.18.23.44;	author camield;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.25.20.21.42;	author camield;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.22.10.16.03;	author camield;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.18.08.49.32;	author camield;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.17.13.32.05;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.06.07.14.12.07;	author camield;	state Exp;
branches;
next	1.4;

1.4
date	2005.06.07.04.37.32;	author camield;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.30.16.37.57;	author camield;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.27.20.05.17;	author camield;	state Exp;
branches;
next	1.1;

1.1
date	2005.05.26.04.38.35;	author camield;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Exit early from rdaemon() is the passed fd is invalid.

fd == -1 check suggested by deraadt@@, ok florian@@
@
text
@/*	$OpenBSD: ftp-proxy.c,v 1.35 2016/09/15 16:16:03 jca Exp $ */

/*
 * Copyright (c) 2004, 2005 Camiel Dobbelaar, <cd@@sentia.nl>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <net/pfvar.h>

#include <err.h>
#include <errno.h>
#include <event.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <vis.h>

#include "filter.h"

#define CONNECT_TIMEOUT	30
#define MIN_PORT	1024
#define MAX_LINE	500
#define MAX_LOGLINE	300
#define NTOP_BUFS	3
#define TCP_BACKLOG	10

#define CHROOT_DIR	"/var/empty"
#define NOPRIV_USER	"_ftp_proxy"

/* pfctl standard NAT range. */
#define PF_NAT_PROXY_PORT_LOW	50001
#define PF_NAT_PROXY_PORT_HIGH	65535

#define	sstosa(ss)	((struct sockaddr *)(ss))

enum { CMD_NONE = 0, CMD_PORT, CMD_EPRT, CMD_PASV, CMD_EPSV };

struct session {
	u_int32_t		 id;
	struct sockaddr_storage  client_ss;
	struct sockaddr_storage  proxy_ss;
	struct sockaddr_storage  server_ss;
	struct sockaddr_storage  orig_server_ss;
	struct bufferevent	*client_bufev;
	struct bufferevent	*server_bufev;
	int			 client_fd;
	int			 server_fd;
	char			 cbuf[MAX_LINE];
	size_t			 cbuf_valid;
	char			 sbuf[MAX_LINE];
	size_t			 sbuf_valid;
	int			 cmd;
	int			 client_rd;
	u_int16_t		 port;
	u_int16_t		 proxy_port;
	LIST_ENTRY(session)	 entry;
};

LIST_HEAD(, session) sessions = LIST_HEAD_INITIALIZER(sessions);

void	client_error(struct bufferevent *, short, void *);
int	client_parse(struct session *s);
int	client_parse_anon(struct session *s);
int	client_parse_cmd(struct session *s);
void	client_read(struct bufferevent *, void *);
int	drop_privs(void);
void	end_session(struct session *);
void	exit_daemon(void);
int	get_line(char *, size_t *);
void	handle_connection(const int, short, void *);
void	handle_signal(int, short, void *);
struct session * init_session(void);
void	logmsg(int, const char *, ...);
u_int16_t parse_port(int);
u_int16_t pick_proxy_port(void);
void	proxy_reply(int, struct sockaddr *, u_int16_t);
int	rdaemon(int);
void	server_error(struct bufferevent *, short, void *);
int	server_parse(struct session *s);
int	allow_data_connection(struct session *s);
void	server_read(struct bufferevent *, void *);
const char *sock_ntop(struct sockaddr *);
void	usage(void);

char linebuf[MAX_LINE + 1];
size_t linelen;

char ntop_buf[NTOP_BUFS][INET6_ADDRSTRLEN];

struct event listen_ev, pause_accept_ev;
struct sockaddr_storage fixed_server_ss, fixed_proxy_ss;
char *fixed_server, *fixed_server_port, *fixed_proxy, *listen_ip, *listen_port,
    *qname, *tagname;
int anonymous_only, daemonize, id_count, ipv6_mode, loglevel, max_sessions,
    rfc_mode, session_count, timeout, verbose;
extern char *__progname;

void
client_error(struct bufferevent *bufev, short what, void *arg)
{
	struct session *s = arg;

	if (what & EVBUFFER_EOF)
		logmsg(LOG_INFO, "#%d client close", s->id);
	else if (what == (EVBUFFER_ERROR | EVBUFFER_READ))
		logmsg(LOG_ERR, "#%d client reset connection", s->id);
	else if (what & EVBUFFER_TIMEOUT)
		logmsg(LOG_ERR, "#%d client timeout", s->id);
	else if (what & EVBUFFER_WRITE)
		logmsg(LOG_ERR, "#%d client write error: %d", s->id, what);
	else
		logmsg(LOG_ERR, "#%d abnormal client error: %d", s->id, what);

	end_session(s);
}

int
client_parse(struct session *s)
{
	/* Reset any previous command. */
	s->cmd = CMD_NONE;
	s->port = 0;

	/* Commands we are looking for are at least 4 chars long. */
	if (linelen < 4)
		return (1);

	if (linebuf[0] == 'P' || linebuf[0] == 'p' ||
	    linebuf[0] == 'E' || linebuf[0] == 'e') {
		if (!client_parse_cmd(s))
			return (0);

		/*
		 * Allow active mode connections immediately, instead of
		 * waiting for a positive reply from the server.  Some
		 * rare servers/proxies try to probe or setup the data
		 * connection before an actual transfer request.
		 */
		if (s->cmd == CMD_PORT || s->cmd == CMD_EPRT)
			return (allow_data_connection(s));
	}
	
	if (anonymous_only && (linebuf[0] == 'U' || linebuf[0] == 'u'))
		return (client_parse_anon(s));

	return (1);
}

int
client_parse_anon(struct session *s)
{
	if (strcasecmp("USER ftp\r\n", linebuf) != 0 &&
	    strcasecmp("USER anonymous\r\n", linebuf) != 0) {
		snprintf(linebuf, sizeof linebuf,
		    "500 Only anonymous FTP allowed\r\n");
		logmsg(LOG_DEBUG, "#%d proxy: %s", s->id, linebuf);

		/* Talk back to the client ourself. */
		linelen = strlen(linebuf);
		bufferevent_write(s->client_bufev, linebuf, linelen);

		/* Clear buffer so it's not sent to the server. */
		linebuf[0] = '\0';
		linelen = 0;
	}

	return (1);
}

int
client_parse_cmd(struct session *s)
{
	if (strncasecmp("PASV", linebuf, 4) == 0)
		s->cmd = CMD_PASV;
	else if (strncasecmp("PORT ", linebuf, 5) == 0)
		s->cmd = CMD_PORT;
	else if (strncasecmp("EPSV", linebuf, 4) == 0)
		s->cmd = CMD_EPSV;
	else if (strncasecmp("EPRT ", linebuf, 5) == 0)
		s->cmd = CMD_EPRT;
	else
		return (1);

	if (ipv6_mode && (s->cmd == CMD_PASV || s->cmd == CMD_PORT)) {
		logmsg(LOG_CRIT, "PASV and PORT not allowed with IPv6");
		return (0);
	}

	if (s->cmd == CMD_PORT || s->cmd == CMD_EPRT) {
		s->port = parse_port(s->cmd);
		if (s->port < MIN_PORT) {
			logmsg(LOG_CRIT, "#%d bad port in '%s'", s->id,
			    linebuf);
			return (0);
		}
		s->proxy_port = pick_proxy_port();
		proxy_reply(s->cmd, sstosa(&s->proxy_ss), s->proxy_port);
		logmsg(LOG_DEBUG, "#%d proxy: %s", s->id, linebuf);
	}

	return (1);
}

void
client_read(struct bufferevent *bufev, void *arg)
{
	struct session	*s = arg;
	size_t		 buf_avail, read;
	int		 n;

	do {
		buf_avail = sizeof s->cbuf - s->cbuf_valid;
		read = bufferevent_read(bufev, s->cbuf + s->cbuf_valid,
		    buf_avail);
		s->cbuf_valid += read;

		while ((n = get_line(s->cbuf, &s->cbuf_valid)) > 0) {
			logmsg(LOG_DEBUG, "#%d client: %s", s->id, linebuf);
			if (!client_parse(s)) {
				end_session(s);
				return;
			}
			bufferevent_write(s->server_bufev, linebuf, linelen);
		}

		if (n == -1) {
			logmsg(LOG_ERR, "#%d client command too long or not"
			    " clean", s->id);
			end_session(s);
			return;
		}
	} while (read == buf_avail);
}

int
drop_privs(void)
{
	struct passwd *pw;

	pw = getpwnam(NOPRIV_USER);
	if (pw == NULL)
		return (0);

	tzset();
	if (chroot(CHROOT_DIR) != 0 || chdir("/") != 0 ||
	    setgroups(1, &pw->pw_gid) != 0 ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0 ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0)
		return (0);

	return (1);
}

void
end_session(struct session *s)
{
	int err;

	logmsg(LOG_INFO, "#%d ending session", s->id);

	/* Flush output buffers. */
	if (s->client_bufev && s->client_fd != -1)
		evbuffer_write(s->client_bufev->output, s->client_fd);
	if (s->server_bufev && s->server_fd != -1)
		evbuffer_write(s->server_bufev->output, s->server_fd);

	if (s->client_fd != -1)
		close(s->client_fd);
	if (s->server_fd != -1)
		close(s->server_fd);

	if (s->client_bufev)
		bufferevent_free(s->client_bufev);
	if (s->server_bufev)
		bufferevent_free(s->server_bufev);

	/* Remove rulesets by committing empty ones. */
	err = 0;
	if (prepare_commit(s->id) == -1)
		err = errno;
	else if (do_commit() == -1) {
		err = errno;
		do_rollback();
	}
	if (err)
		logmsg(LOG_ERR, "#%d pf rule removal failed: %s", s->id,
		    strerror(err));

	LIST_REMOVE(s, entry);
	free(s);
	session_count--;
}

void
exit_daemon(void)
{
	struct session *s, *next;

	for (s = LIST_FIRST(&sessions); s != NULL; s = next) {
		next = LIST_NEXT(s, entry);
		end_session(s);
	}

	if (daemonize)
		closelog();

	exit(0);
}

int
get_line(char *buf, size_t *valid)
{
	size_t i;

	if (*valid > MAX_LINE)
		return (-1);

	/* Copy to linebuf while searching for a newline. */
	for (i = 0; i < *valid; i++) {
		linebuf[i] = buf[i];
		if (buf[i] == '\0')
			return (-1);
		if (buf[i] == '\n')
			break;
	}

	if (i == *valid) {
		/* No newline found. */
		linebuf[0] = '\0';
		linelen = 0;
		if (i < MAX_LINE)
			return (0);
		return (-1);
	}

	linelen = i + 1;
	linebuf[linelen] = '\0';
	*valid -= linelen;
	
	/* Move leftovers to the start. */
	if (*valid != 0)
		bcopy(buf + linelen, buf, *valid);

	return ((int)linelen);
}

void
handle_connection(const int listen_fd, short event, void *arg)
{
	struct sockaddr_storage tmp_ss;
	struct sockaddr *client_sa, *server_sa, *fixed_server_sa;
	struct sockaddr *proxy_to_server_sa;
	struct session *s;
	socklen_t len;
	int client_fd, fc, on;

	event_add(&listen_ev, NULL);

	if ((event & EV_TIMEOUT))
		/* accept() is no longer paused. */
		return;

	/*
	 * We _must_ accept the connection, otherwise libevent will keep
	 * coming back, and we will chew up all CPU.
	 */
	client_sa = sstosa(&tmp_ss);
	len = sizeof(struct sockaddr_storage);
	if ((client_fd = accept(listen_fd, client_sa, &len)) < 0) {
		logmsg(LOG_CRIT, "accept() failed: %s", strerror(errno));

		/*
		 * Pause accept if we are out of file descriptors, or
		 * libevent will haunt us here too.
		 */
		if (errno == ENFILE || errno == EMFILE) {
			struct timeval pause = { 1, 0 };

			event_del(&listen_ev);
			evtimer_add(&pause_accept_ev, &pause);
		} else if (errno != EWOULDBLOCK && errno != EINTR &&
		    errno != ECONNABORTED)
			logmsg(LOG_CRIT, "accept() failed: %s", strerror(errno));
		return;
	}

	/* Refuse connection if the maximum is reached. */
	if (session_count >= max_sessions) {
		logmsg(LOG_ERR, "client limit (%d) reached, refusing "
		    "connection from %s", max_sessions, sock_ntop(client_sa));
		close(client_fd);
		return;
	}

	/* Allocate session and copy back the info from the accept(). */
	s = init_session();
	if (s == NULL) {
		logmsg(LOG_CRIT, "init_session failed");
		close(client_fd);
		return;
	}
	s->client_fd = client_fd;
	memcpy(sstosa(&s->client_ss), client_sa, client_sa->sa_len);

	/* Cast it once, and be done with it. */
	client_sa = sstosa(&s->client_ss);
	server_sa = sstosa(&s->server_ss);
	proxy_to_server_sa = sstosa(&s->proxy_ss);
	fixed_server_sa = sstosa(&fixed_server_ss);

	/* Log id/client early to ease debugging. */
	logmsg(LOG_DEBUG, "#%d accepted connection from %s", s->id,
	    sock_ntop(client_sa));

	/*
	 * Find out the real server and port that the client wanted.
	 */
	len = sizeof(struct sockaddr_storage);
	if (getsockname(s->client_fd, server_sa, &len) < 0) {
		logmsg(LOG_CRIT, "#%d getsockname failed: %s", s->id,
		    strerror(errno));
		goto fail;
	}
	len = sizeof(s->client_rd);
	if (getsockopt(s->client_fd, SOL_SOCKET, SO_RTABLE, &s->client_rd,
	    &len) && errno != ENOPROTOOPT) {
		logmsg(LOG_CRIT, "#%d getsockopt failed: %s", s->id,
		    strerror(errno));
		goto fail;
	}
	if (fixed_server) {
		memcpy(sstosa(&s->orig_server_ss), server_sa,
		    server_sa->sa_len);
		memcpy(server_sa, fixed_server_sa, fixed_server_sa->sa_len);
	}

	/* XXX: check we are not connecting to ourself. */

	/*
	 * Setup socket and connect to server.
	 */
	if ((s->server_fd = socket(server_sa->sa_family, SOCK_STREAM,
	    IPPROTO_TCP)) < 0) {
		logmsg(LOG_CRIT, "#%d server socket failed: %s", s->id,
		    strerror(errno));
		goto fail;
	}
	if (fixed_proxy && bind(s->server_fd, sstosa(&fixed_proxy_ss),
	    fixed_proxy_ss.ss_len) != 0) {
		logmsg(LOG_CRIT, "#%d cannot bind fixed proxy address: %s",
		    s->id, strerror(errno));
		goto fail;
	}

	/* Use non-blocking connect(), see CONNECT_TIMEOUT below. */
	if ((fc = fcntl(s->server_fd, F_GETFL)) == -1 ||
	    fcntl(s->server_fd, F_SETFL, fc | O_NONBLOCK) == -1) {
		logmsg(LOG_CRIT, "#%d cannot mark socket non-blocking: %s",
		    s->id, strerror(errno));
		goto fail;
	}
	if (connect(s->server_fd, server_sa, server_sa->sa_len) < 0 &&
	    errno != EINPROGRESS) {
		logmsg(LOG_CRIT, "#%d proxy cannot connect to server %s: %s",
		    s->id, sock_ntop(server_sa), strerror(errno));
		goto fail;
	}

	len = sizeof(struct sockaddr_storage);
	if ((getsockname(s->server_fd, proxy_to_server_sa, &len)) < 0) {
		logmsg(LOG_CRIT, "#%d getsockname failed: %s", s->id,
		    strerror(errno));
		goto fail;
	}

	logmsg(LOG_INFO, "#%d FTP session %d/%d started: client %s to server "
	    "%s via proxy %s", s->id, session_count, max_sessions,
	    sock_ntop(client_sa), sock_ntop(server_sa),
	    sock_ntop(proxy_to_server_sa));

	/* Keepalive is nice, but don't care if it fails. */
	on = 1;
	setsockopt(s->client_fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,
	    sizeof on);
	setsockopt(s->server_fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&on,
	    sizeof on);

	/*
	 * Setup buffered events.
	 */
	s->client_bufev = bufferevent_new(s->client_fd, &client_read, NULL,
	    &client_error, s);
	if (s->client_bufev == NULL) {
		logmsg(LOG_CRIT, "#%d bufferevent_new client failed", s->id);
		goto fail;
	}
	bufferevent_settimeout(s->client_bufev, timeout, 0);
	bufferevent_enable(s->client_bufev, EV_READ | EV_TIMEOUT);

	s->server_bufev = bufferevent_new(s->server_fd, &server_read, NULL,
	    &server_error, s);
	if (s->server_bufev == NULL) {
		logmsg(LOG_CRIT, "#%d bufferevent_new server failed", s->id);
		goto fail;
	}
	bufferevent_settimeout(s->server_bufev, CONNECT_TIMEOUT, 0);
	bufferevent_enable(s->server_bufev, EV_READ | EV_TIMEOUT);

	return;

 fail:
	end_session(s);
}

void
handle_signal(int sig, short event, void *arg)
{
	/*
	 * Signal handler rules don't apply, libevent decouples for us.
	 */

	logmsg(LOG_ERR, "exiting on signal %d", sig);

	exit_daemon();
}
	

struct session *
init_session(void)
{
	struct session *s;

	s = calloc(1, sizeof(struct session));
	if (s == NULL)
		return (NULL);

	s->id = id_count++;
	s->client_fd = -1;
	s->server_fd = -1;
	s->cbuf[0] = '\0';
	s->cbuf_valid = 0;
	s->sbuf[0] = '\0';
	s->sbuf_valid = 0;
	s->client_bufev = NULL;
	s->server_bufev = NULL;
	s->cmd = CMD_NONE;
	s->port = 0;

	LIST_INSERT_HEAD(&sessions, s, entry);
	session_count++;

	return (s);
}

void
logmsg(int pri, const char *message, ...)
{
	va_list	ap;

	if (pri > loglevel)
		return;

	va_start(ap, message);

	if (daemonize)
		/* syslog does its own vissing. */
		vsyslog(pri, message, ap);
	else {
		char buf[MAX_LOGLINE];
		char visbuf[2 * MAX_LOGLINE];

		/* We don't care about truncation. */
		vsnprintf(buf, sizeof buf, message, ap);
		strnvis(visbuf, buf, sizeof visbuf, VIS_CSTYLE | VIS_NL);
		fprintf(stderr, "%s\n", visbuf);
	}

	va_end(ap);
}

int
main(int argc, char *argv[])
{
	struct rlimit rlp;
	struct addrinfo hints, *res;
	struct event ev_sighup, ev_sigint, ev_sigterm;
	int ch, devnull, error, listenfd, on;
	const char *errstr;

	/* Defaults. */
	anonymous_only	= 0;
	daemonize	= 1;
	fixed_proxy	= NULL;
	fixed_server	= NULL;
	fixed_server_port = "21";
	ipv6_mode	= 0;
	listen_ip	= NULL;
	listen_port	= "8021";
	loglevel	= LOG_NOTICE;
	max_sessions	= 100;
	qname		= NULL;
	rfc_mode	= 0;
	tagname		= NULL;
	timeout		= 24 * 3600;
	verbose		= 0;

	/* Other initialization. */
	devnull		= -1;
	id_count	= 1;
	session_count	= 0;

	while ((ch = getopt(argc, argv, "6Aa:b:D:dm:P:p:q:R:rT:t:v")) != -1) {
		switch (ch) {
		case '6':
			ipv6_mode = 1;
			break;
		case 'A':
			anonymous_only = 1;
			break;
		case 'a':
			fixed_proxy = optarg;
			break;
		case 'b':
			listen_ip = optarg;
			break;
		case 'D':
			loglevel = strtonum(optarg, LOG_EMERG, LOG_DEBUG,
			    &errstr);
			if (errstr)
				errx(1, "loglevel %s", errstr);
			break;
		case 'd':
			daemonize = 0;
			break;
		case 'm':
			max_sessions = strtonum(optarg, 1, 500, &errstr);
			if (errstr)
				errx(1, "max sessions %s", errstr);
			break;
		case 'P':
			fixed_server_port = optarg;
			break;
		case 'p':
			listen_port = optarg;
			break;
		case 'q':
			if (strlen(optarg) >= PF_QNAME_SIZE)
				errx(1, "queuename too long");
			qname = optarg;
			break;
		case 'R':
			fixed_server = optarg;
			break;
		case 'r':
			rfc_mode = 1;
			break;
		case 'T':
			if (strlen(optarg) >= PF_TAG_NAME_SIZE)
				errx(1, "tagname too long");
			tagname = optarg;
			break;
		case 't':
			timeout = strtonum(optarg, 0, 86400, &errstr);
			if (errstr)
				errx(1, "timeout %s", errstr);
			break;
		case 'v':
			verbose++;
			if (verbose > 2)
				usage();
			break;
		default:
			usage();
		}
	}

	if (listen_ip == NULL)
		listen_ip = ipv6_mode ? "::1" : "127.0.0.1";

	/* Check for root to save the user from cryptic failure messages. */
	if (getuid() != 0)
		errx(1, "needs to start as root");

	if (getpwnam(NOPRIV_USER) == NULL)
		errx(1, "unknown user %s", NOPRIV_USER);

	/* Raise max. open files limit to satisfy max. sessions. */
	rlp.rlim_cur = rlp.rlim_max = (2 * max_sessions) + 10;
	if (setrlimit(RLIMIT_NOFILE, &rlp) == -1)
		err(1, "setrlimit");

	if (fixed_proxy) {
		memset(&hints, 0, sizeof hints);
		hints.ai_flags = AI_NUMERICHOST;
		hints.ai_family = ipv6_mode ? AF_INET6 : AF_INET;
		hints.ai_socktype = SOCK_STREAM;
		error = getaddrinfo(fixed_proxy, NULL, &hints, &res);
		if (error)
			errx(1, "getaddrinfo fixed proxy address failed: %s",
			    gai_strerror(error));
		memcpy(&fixed_proxy_ss, res->ai_addr, res->ai_addrlen);
		logmsg(LOG_INFO, "using %s to connect to servers",
		    sock_ntop(sstosa(&fixed_proxy_ss)));
		freeaddrinfo(res);
	}

	if (fixed_server) {
		memset(&hints, 0, sizeof hints);
		hints.ai_family = ipv6_mode ? AF_INET6 : AF_INET;
		hints.ai_socktype = SOCK_STREAM;
		error = getaddrinfo(fixed_server, fixed_server_port, &hints,
		    &res);
		if (error)
			errx(1, "getaddrinfo fixed server address failed: %s",
			    gai_strerror(error));
		memcpy(&fixed_server_ss, res->ai_addr, res->ai_addrlen);
		logmsg(LOG_INFO, "using fixed server %s",
		    sock_ntop(sstosa(&fixed_server_ss)));
		freeaddrinfo(res);
	}

	/* Setup listener. */
	memset(&hints, 0, sizeof hints);
	hints.ai_flags = AI_NUMERICHOST | AI_PASSIVE;
	hints.ai_family = ipv6_mode ? AF_INET6 : AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	error = getaddrinfo(listen_ip, listen_port, &hints, &res);
	if (error)
		errx(1, "getaddrinfo listen address failed: %s",
		    gai_strerror(error));
	if ((listenfd = socket(res->ai_family, SOCK_STREAM, IPPROTO_TCP)) == -1)
		errx(1, "socket failed");
	on = 1;
	if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (void *)&on,
	    sizeof on) != 0)
		err(1, "setsockopt failed");
	if (bind(listenfd, (struct sockaddr *)res->ai_addr,
	    (socklen_t)res->ai_addrlen) != 0)
	    	err(1, "bind failed");
	if (listen(listenfd, TCP_BACKLOG) != 0)
		err(1, "listen failed");
	freeaddrinfo(res);

	/* Initialize pf. */
	init_filter(qname, tagname, verbose);

	if (daemonize) {
		devnull = open(_PATH_DEVNULL, O_RDWR, 0);
		if (devnull == -1)
			err(1, "open(%s)", _PATH_DEVNULL);
	}

	if (!drop_privs())
		err(1, "cannot drop privileges");

	if (daemonize) {
		if (rdaemon(devnull) == -1)
			err(1, "cannot daemonize");
		openlog(__progname, LOG_PID | LOG_NDELAY, LOG_DAEMON);
	}

	/* Use logmsg for output from here on. */

	event_init();

	/* Setup signal handler. */
	signal(SIGPIPE, SIG_IGN);
	signal_set(&ev_sighup, SIGHUP, handle_signal, NULL);
	signal_set(&ev_sigint, SIGINT, handle_signal, NULL);
	signal_set(&ev_sigterm, SIGTERM, handle_signal, NULL);
	signal_add(&ev_sighup, NULL);
	signal_add(&ev_sigint, NULL);
	signal_add(&ev_sigterm, NULL);

	event_set(&listen_ev, listenfd, EV_READ, handle_connection, NULL);
	event_add(&listen_ev, NULL);
	evtimer_set(&pause_accept_ev, handle_connection, NULL);

	logmsg(LOG_NOTICE, "listening on %s port %s", listen_ip, listen_port);

	/*  Vroom, vroom.  */
	event_dispatch();

	logmsg(LOG_ERR, "event_dispatch error: %s", strerror(errno));
	exit_daemon();

	/* NOTREACHED */
	return (1);
}

u_int16_t
parse_port(int mode)
{
	unsigned int	 port, v[6];
	int		 n;
	char		*p;

	/* Find the last space or left-parenthesis. */
	for (p = linebuf + linelen; p > linebuf; p--)
		if (*p == ' ' || *p == '(')
			break;
	if (p == linebuf)
		return (0);

	switch (mode) {
	case CMD_PORT:
		n = sscanf(p, " %u,%u,%u,%u,%u,%u", &v[0], &v[1], &v[2],
		    &v[3], &v[4], &v[5]);
		if (n == 6 && v[0] < 256 && v[1] < 256 && v[2] < 256 &&
		    v[3] < 256 && v[4] < 256 && v[5] < 256)
			return ((v[4] << 8) | v[5]);
		break;
	case CMD_PASV:
		n = sscanf(p, "(%u,%u,%u,%u,%u,%u)", &v[0], &v[1], &v[2],
		    &v[3], &v[4], &v[5]);
		if (n == 6 && v[0] < 256 && v[1] < 256 && v[2] < 256 &&
		    v[3] < 256 && v[4] < 256 && v[5] < 256)
			return ((v[4] << 8) | v[5]);
		break;
	case CMD_EPSV:
		n = sscanf(p, "(|||%u|)", &port);
		if (n == 1 && port < 65536)
			return (port);
		break;
	case CMD_EPRT:
		n = sscanf(p, " |1|%u.%u.%u.%u|%u|", &v[0], &v[1], &v[2],
		    &v[3], &port);
		if (n == 5 && v[0] < 256 && v[1] < 256 && v[2] < 256 &&
		    v[3] < 256 && port < 65536)
			return (port);
		n = sscanf(p, " |2|%*[a-fA-F0-9:]|%u|", &port);
		if (n == 1 && port < 65536)
			return (port);
		break;
	default:
		return (0);
	}

	return (0);
}

u_int16_t
pick_proxy_port(void)
{
	/* Random should be good enough for avoiding port collisions. */
	return (IPPORT_HIFIRSTAUTO +
	    arc4random_uniform(IPPORT_HILASTAUTO - IPPORT_HIFIRSTAUTO));
}

void
proxy_reply(int cmd, struct sockaddr *sa, u_int16_t port)
{
	int i, r;

	switch (cmd) {
	case CMD_PORT:
		r = snprintf(linebuf, sizeof linebuf,
		    "PORT %s,%u,%u\r\n", sock_ntop(sa), port / 256,
		    port % 256);
		break;
	case CMD_PASV:
		r = snprintf(linebuf, sizeof linebuf,
		    "227 Entering Passive Mode (%s,%u,%u)\r\n", sock_ntop(sa),
		        port / 256, port % 256);
		break;
	case CMD_EPRT:
		if (sa->sa_family == AF_INET)
			r = snprintf(linebuf, sizeof linebuf,
			    "EPRT |1|%s|%u|\r\n", sock_ntop(sa), port);
		else if (sa->sa_family == AF_INET6)
			r = snprintf(linebuf, sizeof linebuf,
			    "EPRT |2|%s|%u|\r\n", sock_ntop(sa), port);
		break;
	case CMD_EPSV:
		r = snprintf(linebuf, sizeof linebuf,
		    "229 Entering Extended Passive Mode (|||%u|)\r\n", port);
		break;
	}

	if (r < 0 || r >= sizeof linebuf) {
		logmsg(LOG_ERR, "proxy_reply failed: %d", r);
		linebuf[0] = '\0';
		linelen = 0;
		return;
	}
	linelen = (size_t)r;

	if (cmd == CMD_PORT || cmd == CMD_PASV) {
		/* Replace dots in IP address with commas. */
		for (i = 0; i < linelen; i++)
			if (linebuf[i] == '.')
				linebuf[i] = ',';
	}
}

void
server_error(struct bufferevent *bufev, short what, void *arg)
{
	struct session *s = arg;

	if (what & EVBUFFER_EOF)
		logmsg(LOG_INFO, "#%d server close", s->id);
	else if (what == (EVBUFFER_ERROR | EVBUFFER_READ))
		logmsg(LOG_ERR, "#%d server refused connection", s->id);
	else if (what & EVBUFFER_WRITE)
		logmsg(LOG_ERR, "#%d server write error: %d", s->id, what);
	else if (what & EVBUFFER_TIMEOUT)
		logmsg(LOG_NOTICE, "#%d server timeout", s->id);
	else
		logmsg(LOG_ERR, "#%d abnormal server error: %d", s->id, what);

	end_session(s);
}

int
server_parse(struct session *s)
{
	if (s->cmd == CMD_NONE || linelen < 4 || linebuf[0] != '2')
		goto out;

	if ((s->cmd == CMD_PASV && strncmp("227 ", linebuf, 4) == 0) ||
	    (s->cmd == CMD_EPSV && strncmp("229 ", linebuf, 4) == 0))
		return (allow_data_connection(s));

 out:
	s->cmd = CMD_NONE;
	s->port = 0;

	return (1);
}

int
allow_data_connection(struct session *s)
{
	struct sockaddr *client_sa, *orig_sa, *proxy_sa, *server_sa;
	int prepared = 0;

	/*
	 * The pf rules below do quite some NAT rewriting, to keep up
	 * appearances.  Points to keep in mind:
	 * 1)  The client must think it's talking to the real server,
	 *     for both control and data connections.  Transparently.
	 * 2)  The server must think that the proxy is the client.
	 * 3)  Source and destination ports are rewritten to minimize
	 *     port collisions, to aid security (some systems pick weak
	 *     ports) or to satisfy RFC requirements (source port 20).
	 */
	
	/* Cast this once, to make code below it more readable. */
	client_sa = sstosa(&s->client_ss);
	server_sa = sstosa(&s->server_ss);
	proxy_sa = sstosa(&s->proxy_ss);
	if (fixed_server)
		/* Fixed server: data connections must appear to come
		   from / go to the original server, not the fixed one. */
		orig_sa = sstosa(&s->orig_server_ss);
	else
		/* Server not fixed: orig_server == server. */
		orig_sa = sstosa(&s->server_ss);

	/* Passive modes. */
	if (s->cmd == CMD_PASV || s->cmd == CMD_EPSV) {
		s->port = parse_port(s->cmd);
		if (s->port < MIN_PORT) {
			logmsg(LOG_CRIT, "#%d bad port in '%s'", s->id,
			    linebuf);
			return (0);
		}
		s->proxy_port = pick_proxy_port();
		logmsg(LOG_INFO, "#%d passive: client to server port %d"
		    " via port %d", s->id, s->port, s->proxy_port);

		if (prepare_commit(s->id) == -1)
			goto fail;
		prepared = 1;

		proxy_reply(s->cmd, orig_sa, s->proxy_port);
		logmsg(LOG_DEBUG, "#%d proxy: %s", s->id, linebuf);

		/* pass in from $client to $orig_server port $proxy_port
		    rdr-to $server port $port */
		if (add_rdr(s->id, client_sa, s->client_rd, orig_sa,
		    s->proxy_port, server_sa, s->port, getrtable()) == -1)
			goto fail;

		/* pass out from $client to $server port $port nat-to $proxy */
		if (add_nat(s->id, client_sa, getrtable(), server_sa,
		    s->port, proxy_sa, PF_NAT_PROXY_PORT_LOW,
		    PF_NAT_PROXY_PORT_HIGH) == -1)
			goto fail;
	}

	/* Active modes. */
	if (s->cmd == CMD_PORT || s->cmd == CMD_EPRT) {
		logmsg(LOG_INFO, "#%d active: server to client port %d"
		    " via port %d", s->id, s->port, s->proxy_port);

		if (prepare_commit(s->id) == -1)
			goto fail;
		prepared = 1;

		/* pass in from $server to $proxy port $proxy_port
		    rdr-to $client port $port */
		if (add_rdr(s->id, server_sa, getrtable(), proxy_sa,
		    s->proxy_port, client_sa, s->port, s->client_rd) == -1)
			goto fail;

		/* pass out from $server to $client port $port
		    nat-to $orig_server port $natport */
		if (rfc_mode && s->cmd == CMD_PORT) {
			/* Rewrite sourceport to RFC mandated 20. */
			if (add_nat(s->id, server_sa, s->client_rd, client_sa,
			    s->port, orig_sa, 20, 20) == -1)
				goto fail;
		} else {
			/* Let pf pick a source port from the standard range. */
			if (add_nat(s->id, server_sa, s->client_rd, client_sa,
			    s->port, orig_sa, PF_NAT_PROXY_PORT_LOW,
			    PF_NAT_PROXY_PORT_HIGH) == -1)
			    	goto fail;
		}
	}

	/* Commit rules if they were prepared. */
	if (prepared && (do_commit() == -1)) {
		if (errno != EBUSY)
			goto fail;
		/* One more try if busy. */
		usleep(5000);
		if (do_commit() == -1)
			goto fail;
	}

	s->cmd = CMD_NONE;
	s->port = 0;

	return (1);

 fail:
	logmsg(LOG_CRIT, "#%d pf operation failed: %s", s->id, strerror(errno));
	if (prepared)
		do_rollback();
	return (0);
}
	
void
server_read(struct bufferevent *bufev, void *arg)
{
	struct session	*s = arg;
	size_t		 buf_avail, read;
	int		 n;

	bufferevent_settimeout(bufev, timeout, 0);

	do {
		buf_avail = sizeof s->sbuf - s->sbuf_valid;
		read = bufferevent_read(bufev, s->sbuf + s->sbuf_valid,
		    buf_avail);
		s->sbuf_valid += read;

		while ((n = get_line(s->sbuf, &s->sbuf_valid)) > 0) {
			logmsg(LOG_DEBUG, "#%d server: %s", s->id, linebuf);
			if (!server_parse(s)) {
				end_session(s);
				return;
			}
			bufferevent_write(s->client_bufev, linebuf, linelen);
		}

		if (n == -1) {
			logmsg(LOG_ERR, "#%d server reply too long or not"
			    " clean", s->id);
			end_session(s);
			return;
		}
	} while (read == buf_avail);
}

const char *
sock_ntop(struct sockaddr *sa)
{
	static int n = 0;

	/* Cycle to next buffer. */
	n = (n + 1) % NTOP_BUFS;
	ntop_buf[n][0] = '\0';

	if (sa->sa_family == AF_INET) {
		struct sockaddr_in *sin = (struct sockaddr_in *)sa;

		return (inet_ntop(AF_INET, &sin->sin_addr, ntop_buf[n],
		    sizeof ntop_buf[0]));
	}

	if (sa->sa_family == AF_INET6) {
		struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;

		return (inet_ntop(AF_INET6, &sin6->sin6_addr, ntop_buf[n],
		    sizeof ntop_buf[0]));
	}

	return (NULL);
}

void
usage(void)
{
	fprintf(stderr, "usage: %s [-6Adrv] [-a address] [-b address]"
	    " [-D level] [-m maxsessions]\n                 [-P port]"
	    " [-p port] [-q queue] [-R address] [-T tag]\n"
            "                 [-t timeout]\n", __progname);
	exit(1);
}

int
rdaemon(int devnull)
{
	if (devnull == -1) {
		errno = EBADF;
		return (-1);
	}
	if (fcntl(devnull, F_GETFL) == -1)
		return (-1);

	switch (fork()) {
	case -1:
		return (-1);
	case 0:
		break;
	default:
		_exit(0);
	}

	if (setsid() == -1)
		return (-1);

	(void)dup2(devnull, STDIN_FILENO);
	(void)dup2(devnull, STDOUT_FILENO);
	(void)dup2(devnull, STDERR_FILENO);
	if (devnull > 2)
		(void)close(devnull);

	return (0);
}
@


1.35
log
@Go in the background later, using rdaemon().

rdaemon() works like daemon(3) but requires its caller to pre-open
/dev/null.  This makes it possible to go in the background after
a chroot(2), allowing for more error checking.  The pattern is basically
- open /dev/null
- chroot
- privdrop
- rdaemon

"design" initialy discussed with semarie@@ a while ago, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.34 2016/02/12 08:12:48 ajacoutot Exp $ */
d636 1
d1146 6
@


1.34
log
@Exit early with an error if the "_ftp_proxy" user does not exist. This prevents
rc.d waiting up to 30 secs when starting ftp-proxy right after updating from 5.8
because at that point sysmerge(8) would not have had a chance to run yet and the
unpriv user would not exist.

issue reported by sthen@@
ok sthen@@ benno@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.33 2015/12/22 08:35:17 mmcc Exp $ */
d35 1
d105 1
d615 1
a615 1
	int ch, error, listenfd, on;
d775 10
a784 1
		if (daemon(0, 0) == -1)
a790 5
	if (!drop_privs()) {
		logmsg(LOG_ERR, "cannot drop privileges: %s", strerror(errno));
		exit(1);
	}
	
d1140 25
@


1.33
log
@commiting -> committing
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.32 2015/12/04 19:05:43 sebastia Exp $ */
d708 3
@


1.32
log
@Make the NOPRIV_USER match that is actually intended to be used for
that. Problem introduced since tftp-proxy and ftp-proxy have separate
nonpriv users.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.31 2015/12/01 07:32:37 deraadt Exp $ */
d303 1
a303 1
	/* Remove rulesets by commiting empty ones. */
@


1.31
log
@switch to new _ftp_proxy user; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.30 2015/01/21 21:50:33 deraadt Exp $ */
d55 1
a55 1
#define NOPRIV_USER	"ftp-proxy"
@


1.30
log
@Include <netinet/in.h> before <net/pfvar.h>.  In a future change when
ports is ready, <net/pfvar.h> will stop including a pile of balony.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.29 2014/09/13 16:06:37 doug Exp $ */
d55 1
a55 1
#define NOPRIV_USER	"proxy"
@


1.29
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.28 2013/03/15 13:31:27 benno Exp $ */
d25 2
a28 2
#include <netinet/in.h>
#include <arpa/inet.h>
@


1.28
log
@camield requested backout of rev 1.26, and indeed ftp-proxy does not
need it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.27 2013/03/11 17:40:11 deraadt Exp $ */
d325 1
a325 1
	for (s = LIST_FIRST(&sessions); s != LIST_END(&sessions); s = next) {
@


1.27
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.26 2013/03/10 21:28:26 benno Exp $ */
a62 3
#define FD_RESERVE	5
volatile int con_inflight = 0;

a96 2
int	accept_reserve(int sockfd, struct sockaddr *addr, socklen_t *addrlen,
		int reserve, volatile int *counter);
d293 1
a293 1
	if (s->client_fd != -1) {
a294 6
		if (s->server_fd == -1) {
			con_inflight--;
			logmsg(LOG_DEBUG, "%s: inflight decremented, now %d",
			    __func__, con_inflight);
		}
	}
a372 19
int
accept_reserve(int sockfd, struct sockaddr *addr, socklen_t *addrlen,
    int reserve, volatile int *counter)
{
	int ret;
	if (getdtablecount() + reserve +
	    *counter >= getdtablesize()) {
		errno = EMFILE;
		return -1;
	}

	if ((ret = accept(sockfd, addr, addrlen)) > -1) {
		(*counter)++;
		logmsg(LOG_DEBUG, "%s: inflight incremented, now %d",__func__,
		    *counter);
	}
	return ret;
}

d395 1
a395 2
	if ((client_fd = accept_reserve(listen_fd, client_sa, &len,
		FD_RESERVE, &con_inflight)) < 0) {
a417 3
		con_inflight--;
		logmsg(LOG_DEBUG, "%s: inflight decremented, now %d",__func__,
                    con_inflight);
a425 3
		con_inflight--;
		logmsg(LOG_DEBUG, "%s: inflight decremented, now %d",__func__,
                    con_inflight);
a493 4
	con_inflight--;
	logmsg(LOG_DEBUG, "%s: connected, inflight decremented, now %d",__func__,
		con_inflight);

a1131 1

@


1.26
log
@reserve a filedescriptor on accept() for subsequent connect() call, as
done in relayd.
ok sthen, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.25 2012/04/05 19:08:40 camield Exp $ */
d438 3
a440 1
		}
@


1.25
log
@Rate-limit accepting of new connections while we are experiencing
fd exhaustion.

ok deraadt mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.24 2012/03/04 04:05:15 fgsch Exp $ */
d63 3
d100 2
d298 1
a298 1
	if (s->client_fd != -1)
d300 6
d384 19
d425 2
a426 1
	if ((client_fd = accept(listen_fd, client_sa, &len)) < 0) {
d447 3
d458 3
d529 4
d1171 1
@


1.24
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.23 2011/06/21 17:31:07 mikeb Exp $ */
d116 1
d374 1
a374 1
handle_connection(const int listen_fd, short event, void *ev)
d383 6
d396 12
a407 1
		logmsg(LOG_CRIT, "accept failed: %s", strerror(errno));
d610 1
a610 1
	struct event ev, ev_sighup, ev_sigint, ev_sigterm;
d791 3
a793 2
	event_set(&ev, listenfd, EV_READ | EV_PERSIST, handle_connection, &ev);
	event_add(&ev, NULL);
@


1.23
log
@Convert SO_RTABLE's protocol level to the SOL_SOCKET;  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.22 2011/04/28 00:17:28 mikeb Exp $ */
d96 1
a96 1
int	getline(char *, size_t *);
d242 1
a242 1
		while ((n = getline(s->cbuf, &s->cbuf_valid)) > 0) {
d336 1
a336 1
getline(char *buf, size_t *valid)
d1058 1
a1058 1
		while ((n = getline(s->sbuf, &s->sbuf_valid)) > 0) {
@


1.22
log
@switch ftp-proxy over to divert-to instead of rdr-to.  this avoids
an expensive state lookup (via natlook ioctl) and shrinks the code.
tested by me and sthen, ok reyk sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.21 2011/03/25 14:51:31 claudio Exp $ */
d431 2
a432 3
	if (client_sa->sa_family == AF_INET &&
	    getsockopt(s->client_fd, IPPROTO_IP, SO_RTABLE, &s->client_rd,
	    &len)) {
@


1.21
log
@Use the rdomain information returned by DIOCNATLOOK to install the
nat-to and rdr-to rules with correct rtable rule attributes. This
allows to use ftp-proxy to proxy accross rdomains.
Tested and OK phessler@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.20 2009/09/01 13:46:14 claudio Exp $ */
d377 1
a377 1
	struct sockaddr *client_to_proxy_sa, *proxy_to_server_sa;
a413 1
	client_to_proxy_sa = sstosa(&tmp_ss);
d425 1
a425 1
	if ((getsockname(s->client_fd, client_to_proxy_sa, &len)) < 0) {
d430 6
a435 3
	if (server_lookup(client_sa, client_to_proxy_sa, server_sa,
	    &s->client_rd) != 0) {
	    	logmsg(LOG_CRIT, "#%d server lookup failed (no rdr?)", s->id);
@


1.20
log
@Bring ftp-proxy in sync with the massive pf change just commited by Henning.
This changes the way the rdr/nat rules are added to pf. Now only a single
anchor is needed (the other ones do no longer exist).
To convert your ruleset you need something like this at the start of your
ruleset:
# filter rules and anchors for ftp-proxy(8)
anchor "ftp-proxy/*"
pass in quick proto tcp to port ftp rdr-to 127.0.0.1 port 8021

This was tested by myself, sthen@@, dlg@@ and I think many more. OK by the same
people plus henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.19 2008/06/13 07:25:26 claudio Exp $ */
d80 1
d431 2
a432 1
	if (server_lookup(client_sa, client_to_proxy_sa, server_sa) != 0) {
d482 1
a482 1
	    "%s via proxy %s ", s->id, session_count, max_sessions,
d978 2
a979 2
		if (add_rdr(s->id, client_sa, orig_sa, s->proxy_port,
		    server_sa, s->port) == -1)
d983 3
a985 2
		if (add_nat(s->id, client_sa, server_sa, s->port, proxy_sa,
		    PF_NAT_PROXY_PORT_LOW, PF_NAT_PROXY_PORT_HIGH) == -1)
d1000 2
a1001 2
		if (add_rdr(s->id, server_sa, proxy_sa, s->proxy_port,
		    client_sa, s->port) == -1)
d1008 2
a1009 2
			if (add_nat(s->id, server_sa, client_sa, s->port,
			    orig_sa, 20, 20) == -1)
d1013 2
a1014 2
			if (add_nat(s->id, server_sa, client_sa, s->port,
			    orig_sa, PF_NAT_PROXY_PORT_LOW,
@


1.19
log
@Better error messages. Include the function causing the problem and do not
include the program name in logmsg() plus exit_daemon() does not return so
make it a void function. OK mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.18 2008/04/22 02:22:22 joel Exp $ */
d974 2
a975 2
		/* rdr from $client to $orig_server port $proxy_port -> $server
		    port $port */
d980 1
a980 1
		/* nat from $client to $server port $port -> $proxy */
a983 10

		/* pass in from $client to $server port $port */
		if (add_filter(s->id, PF_IN, client_sa, server_sa,
		    s->port) == -1)
			goto fail;

		/* pass out from $proxy to $server port $port */
		if (add_filter(s->id, PF_OUT, proxy_sa, server_sa,
		    s->port) == -1)
			goto fail;
d995 2
a996 2
		/* rdr from $server to $proxy port $proxy_port -> $client port
		    $port */
d1001 2
a1002 2
		/* nat from $server to $client port $port -> $orig_server port
		    $natport */
a1014 10

		/* pass in from $server to $client port $port */
		if (add_filter(s->id, PF_IN, server_sa, client_sa, s->port) ==
		    -1)
			goto fail;

		/* pass out from $orig_server to $client port $port */
		if (add_filter(s->id, PF_OUT, orig_sa, client_sa, s->port) ==
		    -1)
			goto fail;
@


1.18
log
@Flush output buffers before closing TCP session.  Fixes the case where
the proxy would eat the 221 response coming from the server towards the
client.

Patch from camield@@. Tested by Camiel and myself.


ok camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.17 2008/04/13 00:22:17 djm Exp $ */
d94 1
a94 1
int	exit_daemon(void);
d318 1
a318 1
int
a331 3

	/* NOTREACHED */
	return (-1);
d525 1
a525 1
	logmsg(LOG_ERR, "%s exiting on signal %d", __progname, sig);
@


1.17
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.16 2008/02/26 18:52:53 henning Exp $ */
d284 6
@


1.16
log
@Don't pass quick when tagging, so the tag can be used outside
the ftp-proxy anchor.  Exotic setups with route-to etc.
can be implemented this way.
from camield, ok reyk beck canacar and manpage polished by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.15 2007/08/15 15:18:02 camield Exp $ */
d837 2
a838 2
	return (IPPORT_HIFIRSTAUTO + (arc4random() %
	    (IPPORT_HILASTAUTO - IPPORT_HIFIRSTAUTO)));
@


1.15
log
@Some servers / proxies out there like to open the data connection
immediately after the client sends the PORT command.  The "normal"
behaviour is to wait for the client to actually request a transfer.
Make ftp-proxy add the active mode rules immediately too, so that
both scenario's work.

ok david pyr

Tested by Frank Denis, Stephan A. Rickauer,  Ingo Schwarze, Stuart
Henderson.  Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.14 2007/08/01 09:31:41 henning Exp $ */
d1120 2
a1121 1
	    " [-p port] [-q queue] [-R address] [-T tag] [-t timeout]\n", __progname);
@


1.14
log
@allow ftp-proxy to add tag statements to teh rules it inserts
clever, nice and easy diff from bsd@@openbsd.rutgers.edu, ok pyr reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.13 2006/12/30 13:24:00 camield Exp $ */
d105 1
d153 13
a165 2
	    linebuf[0] == 'E' || linebuf[0] == 'e')
		return (client_parse_cmd(s));
d909 17
a928 3
	if (s->cmd == CMD_NONE || linelen < 4 || linebuf[0] != '2')
		goto out;

d953 1
a953 2
	if ((s->cmd == CMD_PASV && strncmp("227 ", linebuf, 4) == 0) ||
	    (s->cmd == CMD_EPSV && strncmp("229 ", linebuf, 4) == 0)) {
d994 1
a994 2
	if ((s->cmd == CMD_PORT || s->cmd == CMD_EPRT) &&
	    strncmp("200 ", linebuf, 4) == 0) {
a1043 1
 out:
@


1.13
log
@Remove stub write callback functions now that libevent allows them to be NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.12 2006/12/30 13:01:54 camield Exp $ */
d116 1
a116 1
    *qname;
d591 1
d599 1
a599 1
	while ((ch = getopt(argc, argv, "6Aa:b:D:dm:P:p:q:R:rt:v")) != -1) {
d644 5
d729 1
a729 1
	init_filter(qname, verbose);
d1097 1
a1097 1
	    " [-p port] [-q queue] [-R address] [-t timeout]\n", __progname);
@


1.12
log
@Convert three instances of atoi() to strtonum() and apply sane upper bounds.

Triggered by Rik/harry Bobbaers on bugs@@.

ok mbalmer@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.11 2006/12/12 07:28:41 camield Exp $ */
a91 1
void	client_write(struct bufferevent *, void *);
a105 1
void	server_write(struct bufferevent *, void *);
a246 6
void
client_write(struct bufferevent *bufev, void *arg)
{
	return;
}

d479 2
a480 2
	s->client_bufev = bufferevent_new(s->client_fd, &client_read,
	    &client_write, &client_error, s);
d488 2
a489 2
	s->server_bufev = bufferevent_new(s->server_fd, &server_read,
	    &server_write, &server_error, s);
a1057 6
}

void
server_write(struct bufferevent *bufev, void *arg)
{
	return;
@


1.11
log
@Ignore sigpipe as libevent does not handle that for us.  Confirmed by
provos.

Fixes race condition where ftp-proxy would silently exit if a write was
attempted on a socket that was closed by an RST.  Should fix PR 5260.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.10 2006/10/15 18:23:44 camield Exp $ */
d584 1
d621 4
a624 3
			loglevel = atoi(optarg);
			if (loglevel < LOG_EMERG || loglevel > LOG_DEBUG)
				errx(1, "bad loglevel");
d630 3
a632 3
			max_sessions = atoi(optarg);
			if (max_sessions < 0)
				errx(1, "bad max sessions");
d652 3
a654 3
			timeout = atoi(optarg);
			if (timeout < 0)
				errx(1, "bad timeout");
@


1.10
log
@Close file descriptors before cleaning up the events, might cause a race
otherwise.
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.9 2006/03/25 20:21:42 camield Exp $ */
d747 1
@


1.9
log
@unused variable

from Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.8 2006/03/22 10:16:03 camield Exp $ */
d281 5
a289 5

	if (s->client_fd != -1)
		close(s->client_fd);
	if (s->server_fd != -1)
		close(s->server_fd);
@


1.8
log
@Rework signal handling the idiomatic libevent way.  From ospfd.

ok claudio henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.7 2005/11/18 08:49:32 camield Exp $ */
d119 2
a120 2
int anonymous_only, caught_sig, daemonize, id_count, ipv6_mode, loglevel,
    max_sessions, rfc_mode, session_count, timeout, verbose;
@


1.7
log
@don't assume that close() can fail, from deraadt

ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.6 2005/11/17 13:32:05 deraadt Exp $ */
a86 1
void	catch_signal(int);
d98 1
a123 9
catch_signal(int sig)
{
	extern int event_gotsig;

	event_gotsig = 1;
	caught_sig = sig;
}

void
a312 2
	logmsg(LOG_ERR, "%s exiting on signal %d", __progname, caught_sig);

d511 13
a579 1
	extern int (*event_sigcb)(void);
d582 1
a582 1
	struct event ev;
d745 9
a755 5

	signal(SIGHUP, catch_signal);
	signal(SIGINT, catch_signal);
	signal(SIGTERM, catch_signal);
	event_sigcb = exit_daemon;
@


1.6
log
@buffer overflow
@
text
@d1 1
a1 1
/*	$OpenBSD: ftp-proxy.c,v 1.5 2005/06/07 14:12:07 camield Exp $ */
d296 1
a296 2
		while (close(s->client_fd) != 0 && errno == EINTR)
			;
d298 1
a298 2
		while (close(s->server_fd) != 0 && errno == EINTR)
			;
@


1.5
log
@add OpenBSD cvs tags, prompted by xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d177 1
a177 1
	    	linelen = snprintf(linebuf, sizeof linebuf,
d182 1
@


1.4
log
@Introduce verbose option to control the logging of the pf rules.

ok beck mpf
@
text
@d1 2
@


1.3
log
@Don't call va_start() when we do not log.  From Andrey Matveev.
@
text
@d118 1
a118 1
    max_sessions, rfc_mode, session_count, timeout;
d597 1
d603 1
a603 1
	while ((ch = getopt(argc, argv, "6Aa:b:D:dm:P:p:q:R:rt:")) != -1) {
d652 5
d727 1
a727 1
	init_filter(qname);
d1094 1
a1094 1
	fprintf(stderr, "usage: %s [-6Adr] [-a address] [-b address]"
@


1.2
log
@do not allow nul in the control connection.

ok beck
@
text
@a551 1
	va_start(ap, message);
d555 2
@


1.1
log
@Import new FTP proxy.  Handles IPv6 and all FTP modes.  It was
previously known as pftpx.

Not connected to the builds yet.

ok beck
@
text
@d247 2
a248 1
			logmsg(LOG_ERR, "#%d client command too long", s->id);
d346 5
a350 2
	for (i = 0; i < *valid; i++)
		if ((linebuf[i] = buf[i]) == '\n')
d352 1
d1044 2
a1045 1
			logmsg(LOG_ERR, "#%d server reply too long", s->id);
@

