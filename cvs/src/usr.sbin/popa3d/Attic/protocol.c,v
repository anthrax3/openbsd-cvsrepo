head	1.5;
access;
symbols
	OPENBSD_5_4:1.4.0.34
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.32
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.30
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.28
	OPENBSD_5_0:1.4.0.26
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.24
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.22
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.18
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.20
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.16
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.14
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.12
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.10
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.8
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.6
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.8
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.6
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2013.12.15.17.37.25;	author tedu;	state dead;
branches;
next	1.4;

1.4
date	2005.04.13.02.33.09;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.12.19.28.22;	author camield;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.21.20.22.06;	author camield;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.13.05.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove popa3d. Sorry, no plaintext password only daemons allowed anymore.
ok deraadt and co.
@
text
@/* $OpenBSD: protocol.c,v 1.4 2005/04/13 02:33:09 deraadt Exp $ */

/*
 * POP protocol handling.
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <setjmp.h>
#include <string.h>
#include <stdarg.h>
#include <errno.h>

#include "misc.h"
#include "params.h"
#include "protocol.h"

struct pop_buffer pop_buffer;
static sigjmp_buf pop_timed_out;

void pop_init(void)
{
	pop_buffer.ptr = pop_buffer.size = 0;
}

void pop_clean(void)
{
	memset(pop_buffer.data, 0, pop_buffer.ptr);
	memmove(pop_buffer.data, &pop_buffer.data[pop_buffer.ptr],
		pop_buffer.size -= pop_buffer.ptr);
	pop_buffer.ptr = 0;
}

int pop_sane(void)
{
	return pop_buffer.size <= sizeof(pop_buffer.data) &&
	    pop_buffer.ptr <= pop_buffer.size;
}

static void pop_timeout(int signum)
{
	signal(SIGALRM, SIG_DFL);
	siglongjmp(pop_timed_out, 1);
}

static void pop_fetch(void)
{
	int size;

	signal(SIGALRM, pop_timeout);
	alarm(POP_TIMEOUT);

	size = read(STDIN_FILENO, pop_buffer.data, sizeof(pop_buffer.data));

	alarm(0);
	signal(SIGALRM, SIG_DFL);

	pop_buffer.ptr = 0;
	pop_buffer.size = (size >= 0) ? size : 0;
}

static int pop_get_char(void)
{
	if (pop_buffer.ptr >= pop_buffer.size) {
		pop_fetch();
		if (!pop_buffer.size) return -1;
	}

	return (unsigned char)pop_buffer.data[pop_buffer.ptr++];
}

static char *pop_get_line(char *line, int size)
{
	int pos;
	int seen_cr, seen_nul;
	int c;

	pos = 0;
	seen_cr = seen_nul = 0;
	while ((c = pop_get_char()) >= 0) {
		if (c == '\n') {
			if (seen_cr) line[pos - 1] = 0;
			break;
		}
		if (pos < size - 1)
			seen_cr = ((line[pos++] = c) == '\r');
		else
			seen_cr = 0;
		seen_nul |= !c;
	}
	line[pos] = 0;

	if (seen_nul)
		line[0] = 0;

	if (pos || c >= 0)
		return line;
	else
		return NULL;
}

int pop_handle_state(struct pop_command *commands)
{
	char line[POP_BUFFER_SIZE];
	char *params;
	struct pop_command *command;
	int response;

	if (sigsetjmp(pop_timed_out, 1)) return POP_CRASH_NETTIME;

	while (pop_get_line(line, sizeof(line))) {
		if ((params = strchr(line, ' '))) {
			*params++ = 0;
			if (!*params) params = NULL;
		}

		response = POP_ERROR;
		for (command = commands; command->name; command++)
		if (!strcasecmp(command->name, line)) {
			response = command->handler(params);
			break;
		}

		switch (response) {
		case POP_OK:
			if (pop_reply_ok()) return POP_CRASH_NETFAIL;
			break;

		case POP_ERROR:
			if (pop_reply_error()) return POP_CRASH_NETFAIL;

		case POP_QUIET:
			break;

		case POP_LEAVE:
			if (pop_reply_ok()) return POP_CRASH_NETFAIL;

		default:
			return response;
		}
	}

	return POP_CRASH_NETFAIL;
}

char *pop_get_param(char **params)
{
	char *current, *next;

	if ((current = *params)) {
		if ((next = strchr(current, ' '))) {
			*next++ = 0;
			*params = *next ? next : NULL;
		} else
			*params = NULL;

		if (strlen(current) > 40) current = NULL;
	}

	return current;
}

int pop_get_int(char **params)
{
	char *param, *error;
	long value;

	if ((param = pop_get_param(params))) {
/* SUSv2 says:
 * "Because 0, LONG_MIN and LONG_MAX are returned on error and are also
 * valid returns on success, an application wishing to check for error
 * situations should set errno to 0, then call strtol(), then check errno." */
		errno = 0;
		value = strtol(param, &error, 10);
		if (errno || !*param || *error ||
		    value < 0 || (long)(int)value != value)
			return -1;

		return (int)value;
	}

	return -1;
}

int pop_reply(char *format, ...)
{
	va_list args;

	va_start(args, format);
	vfprintf(stdout, format, args);
	va_end(args);

	putc('\r', stdout);
	putc('\n', stdout);

	switch (format[0]) {
	case '+':
	case '-':
		return fflush(stdout);

	case '.':
		if (!format[1]) return fflush(stdout);
	}

	return ferror(stdout);
}

int pop_reply_ok(void)
{
	return pop_reply("+OK");
}

int pop_reply_error(void)
{
	return pop_reply("-ERR");
}

int pop_reply_multiline(int fd, unsigned long size, int lines)
{
	char *in_buffer, *out_buffer;
	char *in, *out;
	int in_block, out_block;
	int start, body;

	if (lines >= 0) lines++;

	if (pop_reply_ok()) return POP_CRASH_NETFAIL;

	in_buffer = malloc(RETR_BUFFER_SIZE * 3);
	if (!in_buffer) return POP_CRASH_SERVER;
	out_buffer = &in_buffer[RETR_BUFFER_SIZE];

	start = 1;
	body = 0;
	while (size && lines) {
		if (size > RETR_BUFFER_SIZE)
			in_block = read(fd, in_buffer, RETR_BUFFER_SIZE);
		else
			in_block = read(fd, in_buffer, size);
		if (in_block <= 0) {
			free(in_buffer);
			return POP_CRASH_SERVER;
		}

		in = in_buffer;
		out = out_buffer;
		while (in < &in_buffer[in_block] && lines)
		switch (*in) {
		case '\n':
			*out++ = '\r';
			*out++ = *in++;
			if (start) body = 1;
			if (body) lines--;
			start = 1;
			break;

		case '.':
			if (start) *out++ = '.';

		default:
			*out++ = *in++;
			start = 0;
		}

		out_block = out - out_buffer;
		if (write_loop(1, out_buffer, out_block) != out_block) {
			free(in_buffer);
			return POP_CRASH_NETFAIL;
		}

		size -= in_block;
	}

	free(in_buffer);

	if (!start)
	if (pop_reply("%s", "")) return POP_CRASH_NETFAIL;

	return POP_OK;
}

int pop_reply_terminate(void)
{
	return pop_reply(".");
}
@


1.4
log
@use STD{IN,OUT,ERR}_FILENO
@
text
@d1 1
a1 1
/* $OpenBSD: protocol.c,v 1.3 2003/05/12 19:28:22 camield Exp $ */
@


1.3
log
@Sync to 0.6.2

- UIDL digest calculation has been improved
- minor bug fixes
- -V switch to show version
@
text
@d1 1
a1 1
/* $OpenBSD: protocol.c,v 1.2 2001/09/21 20:22:06 camield Exp $ */
d55 1
a55 1
	size = read(0, pop_buffer.data, sizeof(pop_buffer.data));
@


1.2
log
@update to 0.4.9.4:
- stand-alone or inetd selectable from command-line (-D = daemon mode)
- logging priorities more accurate
- chroots to empty dir
- tcp wrappers support
@
text
@d1 1
a1 1
/* $OpenBSD: protocol.c,v 1.1 2001/08/19 13:05:57 deraadt Exp $ */
d14 1
d38 2
a39 2
	return (unsigned int)pop_buffer.size <= sizeof(pop_buffer.data) &&
	    (unsigned int)pop_buffer.ptr <= (unsigned int)pop_buffer.size;
d48 1
a48 1
static int pop_fetch(void)
d50 2
d55 1
a55 1
	pop_buffer.size = read(0, pop_buffer.data, sizeof(pop_buffer.data));
d61 1
a61 1
	return pop_buffer.size <= 0;
d66 4
a69 2
	if (pop_buffer.ptr >= pop_buffer.size)
	if (pop_fetch()) return -1;
d171 5
d177 3
a179 1
		if (!*param || *error || (value & ~0x3FFFFFFFL)) return -1;
d181 1
a181 1
		return value;
d220 1
a220 1
int pop_reply_multiline(int fd, long size, int lines)
d229 1
a229 1
	if (pop_reply_ok()) return 1;
d232 1
a232 1
	if (!in_buffer) return 1;
d244 1
a244 1
			return 1;
d270 1
a270 1
			return 1;
d279 1
a279 1
	if (pop_reply("%s", "")) return 1;
d281 1
a281 1
	return 0;
@


1.1
log
@libexec is the wrong place for popa3d, since it can be started WITHOUT inetd
@
text
@d1 1
a1 1
/* $OpenBSD: protocol.c,v 1.2 2001/08/13 20:19:33 camield Exp $ */
d20 1
a20 1
static jmp_buf pop_timed_out;
d44 1
a44 1
	longjmp(pop_timed_out, 1);
d106 1
a106 1
	if (setjmp(pop_timed_out)) return POP_TIMED_OUT;
d123 1
a123 1
			if (pop_reply_ok()) return POP_CRASH;
d127 1
a127 1
			if (pop_reply_error()) return POP_CRASH;
d133 1
a133 1
			if (pop_reply_ok()) return POP_CRASH;
d140 1
a140 1
	return POP_CRASH;
d210 1
a210 2
	char *in_buffer;
	char *out_buffer;
@

