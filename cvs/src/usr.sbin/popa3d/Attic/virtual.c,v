head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.38
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.36
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.34
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.32
	OPENBSD_5_0:1.6.0.30
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.28
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.26
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.22
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.24
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.20
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.18
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.16
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.14
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.12
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.10
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.8
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2013.12.15.17.37.25;	author tedu;	state dead;
branches;
next	1.6;

1.6
date	2004.06.20.05.18.07;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.19.07.21.20;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.02.00.07.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.27.14.08.43;	author camield;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.21.20.22.06;	author camield;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.13.05.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove popa3d. Sorry, no plaintext password only daemons allowed anymore.
ok deraadt and co.
@
text
@/* $OpenBSD: virtual.c,v 1.6 2004/06/20 05:18:07 itojun Exp $ */

/*
 * Virtual domain support.
 */

#include "params.h"

#if POP_VIRTUAL

#define _XOPEN_SOURCE 4
#define _XOPEN_SOURCE_EXTENDED
#define _XOPEN_VERSION 4
#define _XPG4_2
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <errno.h>
#include <pwd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#ifndef NAME_MAX
#define NAME_MAX			255
#endif

extern int log_error(char *s);

char *virtual_domain;
char *virtual_spool;

int virtual_startup(void)
{
	return 0;
}

static char *lookup(void)
{
	struct sockaddr_storage ss;
	int length;
	int error;
	static char hbuf[NI_MAXHOST];

	length = sizeof(ss);
	if (getsockname(0, (struct sockaddr *)&ss, &length)) {
		if (errno == ENOTSOCK) return "";
		log_error("getsockname");
		return NULL;
	}

	error = getnameinfo((struct sockaddr *)&ss, length, hbuf, sizeof(hbuf),
	    NULL, 0, NI_NUMERICHOST);
	if (error) {
		/* logging? */
		return NULL;
	}

	return hbuf;
}

static int is_valid_user(char *user)
{
	unsigned char *p;

/* This is pretty liberal, but we're going to use direct syscalls only,
 * and they have to accept all the printable characters */
	for (p = (unsigned char *)user; *p; p++)
		if (*p < ' ' || *p > 0x7E || *p == '.' || *p == '/') return 0;

	if (p - (unsigned char *)user > NAME_MAX) return 0;

	return 1;
}

struct passwd *virtual_userpass(char *user, char *pass, int *known)
{
	struct passwd *pw, *result;
	struct stat stat;
	char auth[VIRTUAL_AUTH_SIZE];
	char *address, *pathname;
	char *template, *passwd;
	int fail;
	int fd, size;

	*known = 0;

/* Make sure we don't try to authenticate globally if something fails
 * before we find out whether the virtual domain is known to us */
	virtual_domain = "UNKNOWN";
	virtual_spool = NULL;

	if (!(address = lookup())) return NULL;

/* Authenticate globally (if supported) if run on a non-socket */
	if (!*address) {
		virtual_domain = NULL;
		return NULL;
	}

	fail = 0;
	if (!is_valid_user(user)) {
		user = "INVALID";
		fail = 1;
	}

/* This "can't happen", but is just too critical to not check explicitly */
	if (strchr(address, '/') || strchr(user, '/'))
		return NULL;

	if (asprintf(&pathname, "%s/%s", VIRTUAL_HOME_PATH, address) == -1)
		return NULL;

	if (lstat(pathname, &stat)) {
		if (errno == ENOENT)
			virtual_domain = NULL;
		else
			log_error("lstat");
		free(pathname);
		return NULL;
	}

	if (!(address = strdup(address))) {
		free(pathname);
		return NULL;
	}
	virtual_domain = address;

	free(pathname);
	
	if (asprintf(&pathname, "%s/%s/%s/%s", VIRTUAL_HOME_PATH, address,
	    VIRTUAL_AUTH_PATH, user) == -1)
		return NULL;

	if ((fd = open(pathname, O_RDONLY)) < 0 && errno != ENOENT) {
		log_error("open");
		fail = 1;
	}

	free(pathname);

	if (asprintf(&virtual_spool, "%s/%s/%s", VIRTUAL_HOME_PATH,
	    virtual_domain, VIRTUAL_SPOOL_PATH) == -1) {
		close(fd);
		return NULL;
	}

	size = 0;
	if (fd >= 0) {
		*known = !fail;

		if ((size = read(fd, auth, sizeof(auth))) < 0) {
			log_error("read");
			size = 0;
			fail = 1;
		}

		close(fd);
	}

	if (size >= sizeof(auth)) {
		size = 0;
		fail = 1;
	}

	auth[size] = 0;

	if (!(template = strtok(auth, ":")) || !*template) {
		template = "INVALID";
		fail = 1;
	}
	if (!(passwd = strtok(NULL, ":")) || !*passwd ||
	    *passwd == '*' || *passwd == '!') {
		passwd = AUTH_DUMMY_SALT;
		fail = 1;
	}
	if (!strtok(NULL, ":")) fail = 1;

	if ((pw = getpwnam(template)))
		memset(pw->pw_passwd, 0, strlen(pw->pw_passwd));
	endpwent();

	result = NULL;
	if (!strcmp(crypt(pass, passwd), passwd) && !fail)
		result = pw;

	memset(auth, 0, sizeof(auth));

	return result;
}

#endif
@


1.6
log
@make popa3d (inetd mode) address family neutral (= IPv6 support).
from popa3d patch by kame
@
text
@d1 1
a1 1
/* $OpenBSD: virtual.c,v 1.5 2003/06/19 07:21:20 pvalchev Exp $ */
@


1.5
log
@plug memory leak; ok solar, camield
@
text
@d1 1
a1 1
/* $OpenBSD: virtual.c,v 1.4 2003/04/02 00:07:53 deraadt Exp $ */
d45 1
a45 1
	struct sockaddr_in sin;
d47 2
d50 2
a51 2
	length = sizeof(sin);
	if (getsockname(0, (struct sockaddr *)&sin, &length)) {
a55 1
	if (length != sizeof(sin) || sin.sin_family != AF_INET) return NULL;
d57 8
a64 1
	return inet_ntoa(sin.sin_addr);
@


1.4
log
@asprintf; millert ok
@
text
@d1 1
a1 1
/* $OpenBSD: virtual.c,v 1.3 2002/03/27 14:08:43 camield Exp $ */
d120 4
a123 1
	if (!(address = strdup(address))) return NULL;
@


1.3
log
@Mostly cosmetic update so we can call it 0.5.

ok millert@@, fgsch@@
@
text
@d1 1
a1 1
/* $OpenBSD: virtual.c,v 1.2 2001/09/21 20:22:06 camield Exp $ */
d108 2
a109 4
	pathname = malloc(strlen(VIRTUAL_HOME_PATH) + strlen(address) +
		strlen(VIRTUAL_AUTH_PATH) + strlen(user) + 4);
	if (!pathname) return NULL;
	sprintf(pathname, "%s/%s", VIRTUAL_HOME_PATH, address);
d123 5
a127 2
	sprintf(pathname, "%s/%s/%s/%s", VIRTUAL_HOME_PATH, address,
		VIRTUAL_AUTH_PATH, user);
d136 2
a137 4
	virtual_spool = malloc(strlen(VIRTUAL_HOME_PATH) +
		strlen(virtual_domain) +
		strlen(VIRTUAL_SPOOL_PATH) + 3);
	if (!virtual_spool) {
a140 2
	sprintf(virtual_spool, "%s/%s/%s", VIRTUAL_HOME_PATH, virtual_domain,
		VIRTUAL_SPOOL_PATH);
@


1.2
log
@update to 0.4.9.4:
- stand-alone or inetd selectable from command-line (-D = daemon mode)
- logging priorities more accurate
- chroots to empty dir
- tcp wrappers support
@
text
@d1 1
a1 1
/* $OpenBSD: virtual.c,v 1.1 2001/08/19 13:05:57 deraadt Exp $ */
d28 4
@


1.1
log
@libexec is the wrong place for popa3d, since it can be started WITHOUT inetd
@
text
@d1 1
a1 1
/* $OpenBSD: virtual.c,v 1.2 2001/08/13 20:19:33 camield Exp $ */
d11 1
a11 1
#define _XOPEN_SOURCE
d55 1
a55 1
static int isvaliduser(char *user)
d69 1
a69 1
struct passwd *virtual_userpass(char *user, char *pass, char **mailbox)
d79 2
d95 1
a95 1
	if (!isvaliduser(user)) {
d143 1
a143 1
		if (!fail) *mailbox = user;
d172 1
a172 1
	if ((pw = getpwnam(template))) {
a173 2
		pw->pw_passwd = "*";
	}
@

