head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.4.0.28
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.24
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2013.12.15.17.37.25;	author tedu;	state dead;
branches;
next	1.6;

1.6
date	2009.12.17.11.04.39;	author sobrado;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.16.20.42.26;	author sobrado;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.12.19.28.22;	author camield;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.06.19.17.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.21.20.22.06;	author camield;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.13.05.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove popa3d. Sorry, no plaintext password only daemons allowed anymore.
ok deraadt and co.
@
text
@/* $OpenBSD: pop_trans.c,v 1.6 2009/12/17 11:04:39 sobrado Exp $ */

/*
 * TRANSACTION state handling.
 */

#include <stdio.h>
#include <syslog.h>

#include "params.h"
#include "protocol.h"
#include "database.h"
#include "mailbox.h"

static int pop_trans_quit(char *params)
{
	if (params) return POP_ERROR;
	return POP_STATE;
}

static int pop_trans_noop(char *params)
{
	if (params) return POP_ERROR;
	return POP_OK;
}

static int pop_trans_stat(char *params)
{
	if (params) return POP_ERROR;
	if (pop_reply("+OK %u %lu", db.visible_count, db.visible_size))
		return POP_CRASH_NETFAIL;
	return POP_QUIET;
}

static int pop_trans_list_or_uidl_all(int uidl)
{
	unsigned int number;
	struct db_message *msg;

	if (pop_reply_ok()) return POP_CRASH_NETFAIL;
	for (number = 1; number <= db.total_count; number++) {
		msg = db.array[number - 1];
		if (msg->flags & MSG_DELETED) continue;
		if (uidl) {
			if (pop_reply("%u "
			    "%02x%02x%02x%02x%02x%02x%02x%02x",
			    number,
			    msg->hash[3], msg->hash[2],
			    msg->hash[1], msg->hash[0],
			    msg->hash[7], msg->hash[6],
			    msg->hash[5], msg->hash[4]))
				return POP_CRASH_NETFAIL;
		} else
			if (pop_reply("%u %lu", number, msg->size))
				return POP_CRASH_NETFAIL;
	}
	if (pop_reply_terminate()) return POP_CRASH_NETFAIL;
	return POP_QUIET;
}

static int pop_trans_list_or_uidl(char *params, int uidl)
{
	int number;
	struct db_message *msg;

	if (!params)
		return pop_trans_list_or_uidl_all(uidl);

	number = pop_get_int(&params);
	if (number < 1 || number > db.total_count || params)
		return POP_ERROR;
	msg = db.array[number - 1];
	if (msg->flags & MSG_DELETED) return POP_ERROR;
	if (uidl) {
		if (pop_reply("+OK %d "
		    "%02x%02x%02x%02x%02x%02x%02x%02x",
		    number,
		    msg->hash[3], msg->hash[2],
		    msg->hash[1], msg->hash[0],
		    msg->hash[7], msg->hash[6],
		    msg->hash[5], msg->hash[4]))
			return POP_CRASH_NETFAIL;
	} else
		if (pop_reply("+OK %d %lu", number, msg->size))
			return POP_CRASH_NETFAIL;
	return POP_QUIET;
}

static int pop_trans_list(char *params)
{
	return pop_trans_list_or_uidl(params, 0);
}

static int pop_trans_uidl(char *params)
{
	return pop_trans_list_or_uidl(params, 1);
}

static int pop_trans_retr(char *params)
{
	int number;
	struct db_message *msg;
	int event;

	number = pop_get_int(&params);
	if (number < 1 || number > db.total_count || params) return POP_ERROR;
	msg = db.array[number - 1];
	if (msg->flags & MSG_DELETED) return POP_ERROR;
	if ((event = mailbox_get(msg, -1)) != POP_OK) return event;
#if POP_SUPPORT_LAST
	if (number > db.last) db.last = number;
#endif
	return POP_QUIET;
}

static int pop_trans_top(char *params)
{
	int number, lines;
	struct db_message *msg;
	int event;

	number = pop_get_int(&params);
	if (number < 1 || number > db.total_count) return POP_ERROR;
	lines = pop_get_int(&params);
	if (lines < 0 || params) return POP_ERROR;
	msg = db.array[number - 1];
	if (msg->flags & MSG_DELETED) return POP_ERROR;
	if ((event = mailbox_get(msg, lines)) != POP_OK) return event;
	return POP_QUIET;
}

static int pop_trans_dele(char *params)
{
	int number;
	struct db_message *msg;

	number = pop_get_int(&params);
	if (number < 1 || number > db.total_count || params) return POP_ERROR;
	msg = db.array[number - 1];
	if (db_delete(msg)) return POP_ERROR;
#if POP_SUPPORT_LAST
	if (number > db.last) db.last = number;
#endif
	return POP_OK;
}

static int pop_trans_rset(char *params)
{
	struct db_message *msg;

	if (params) return POP_ERROR;

	if ((msg = db.head))
	do {
		msg->flags &= ~MSG_DELETED;
	} while ((msg = msg->next));

	db.visible_count = db.total_count;
	db.visible_size = db.total_size;
	db.flags &= ~DB_DIRTY;
#if POP_SUPPORT_LAST
	db.last = 0;
#endif

	return POP_OK;
}

#if POP_SUPPORT_LAST
static int pop_trans_last(char *params)
{
	if (params) return POP_ERROR;
	if (pop_reply("+OK %u", db.last)) return POP_CRASH_NETFAIL;
	return POP_QUIET;
}
#endif

static struct pop_command pop_trans_commands[] = {
	{"QUIT", pop_trans_quit},
	{"NOOP", pop_trans_noop},
	{"STAT", pop_trans_stat},
	{"LIST", pop_trans_list},
	{"UIDL", pop_trans_uidl},
	{"RETR", pop_trans_retr},
	{"TOP", pop_trans_top},
	{"DELE", pop_trans_dele},
	{"RSET", pop_trans_rset},
#if POP_SUPPORT_LAST
	{"LAST", pop_trans_last},
#endif
	{NULL, NULL}
};

static int db_load(char *spool, char *mailbox)
{
	db_init();

	if (mailbox_open(spool, mailbox)) return 1;

	if (db_fix()) {
		mailbox_close();
		return 1;
	}

	return 0;
}

int do_pop_trans(char *spool, char *mailbox)
{
	int event;

	if (!pop_sane()) return 1;

	if (db_load(spool, mailbox)) {
		syslog(SYSLOG_PRI_HI,
		    "Failure reading %s/%s or mailbox limits exceeded",
		    spool, mailbox);
		pop_reply_error();
		return 0;
	}

	syslog(SYSLOG_PRI_LO, "%u message%s (%lu byte%s) loaded",
		db.total_count, db.total_count == 1 ? "" : "s",
		db.total_size, db.total_size == 1 ? "" : "s");

	if (pop_reply_ok())
		event = POP_CRASH_NETFAIL;
	else
	switch ((event = pop_handle_state(pop_trans_commands))) {
	case POP_STATE:
		if (mailbox_update()) {
			if (db.flags & DB_STALE) break;
			syslog(SYSLOG_PRI_ERROR,
			    "Failed to update %s/%s",
			    spool, mailbox);
			pop_reply_error();
			break;
		}

		syslog(SYSLOG_PRI_LO, "%u (%lu) deleted, %u (%lu) left",
		    db.total_count - db.visible_count,
		    db.total_size - db.visible_size,
		    db.visible_count,
		    db.visible_size);
		pop_reply_ok();
		break;

	case POP_CRASH_NETFAIL:
		syslog(SYSLOG_PRI_LO, "Premature disconnect");
		break;

	case POP_CRASH_NETTIME:
		syslog(SYSLOG_PRI_LO, "Connection timed out");
	}

	if (db.flags & DB_STALE)
		syslog(SYSLOG_PRI_LO, "Another MUA active, giving up");
	else
	if (event == POP_CRASH_SERVER)
		syslog(SYSLOG_PRI_ERROR,
		    "Server failure accessing %s/%s",
		    spool, mailbox);

	mailbox_close();

	return 0;
}
@


1.6
log
@spacing, no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: pop_trans.c,v 1.5 2009/12/16 20:42:26 sobrado Exp $ */
@


1.5
log
@enforce less restrictive limits to mailbox sizes and improve message
reported on failure conditions; increasing the maximum number of
messages is not required, as the number of messages stored on
mailboxes has not grown over the years as much as the size of their
attachments.

miod@@ has observed that the message reported was too obscure.

"this can go in" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pop_trans.c,v 1.4 2003/05/12 19:28:22 camield Exp $ */
d215 2
a216 2
			"Failure reading %s/%s or mailbox limits exceeded",
			spool, mailbox);
d233 2
a234 2
				"Failed to update %s/%s",
				spool, mailbox);
d240 4
a243 4
			db.total_count - db.visible_count,
			db.total_size - db.visible_size,
			db.visible_count,
			db.visible_size);
d260 2
a261 2
			"Server failure accessing %s/%s",
			spool, mailbox);
@


1.4
log
@Sync to 0.6.2

- UIDL digest calculation has been improved
- minor bug fixes
- -V switch to show version
@
text
@d1 1
a1 1
/* $OpenBSD: pop_trans.c,v 1.3 2002/09/06 19:17:52 deraadt Exp $ */
d215 1
a215 1
			"Failed or refused to load %s/%s",
@


1.3
log
@md5.h needs types.h to be included first
@
text
@d1 1
a1 1
/* $OpenBSD: pop_trans.c,v 1.2 2001/09/21 20:22:06 camield Exp $ */
a6 1
#include <sys/types.h>
d30 1
a30 1
	if (pop_reply("+OK %d %ld", db.visible_count, db.visible_size))
d35 1
a35 1
static int pop_trans_list_or_uidl(char *params, int uidl)
d37 1
a37 1
	int number;
a39 21
	if (params) {
		number = pop_get_int(&params);
		if (number < 1 || number > db.total_count || params)
			return POP_ERROR;
		msg = db.array[number - 1];
		if (msg->flags & MSG_DELETED) return POP_ERROR;
		if (uidl) {
			if (pop_reply("+OK %d "
			    "%02x%02x%02x%02x%02x%02x%02x%02x",
			    number,
			    msg->hash[3], msg->hash[2],
			    msg->hash[1], msg->hash[0],
			    msg->hash[7], msg->hash[6],
			    msg->hash[5], msg->hash[4]))
				return POP_CRASH_NETFAIL;
		} else
			if (pop_reply("+OK %d %ld", number, msg->size))
				return POP_CRASH_NETFAIL;
		return POP_QUIET;
	}

d45 1
a45 1
			if (pop_reply("%d "
d54 1
a54 1
			if (pop_reply("%d %ld", number, msg->size))
d58 2
d61 25
d172 1
a172 1
	if (pop_reply("+OK %d", db.last)) return POP_CRASH_NETFAIL;
d190 1
a190 1
	{NULL}
d209 1
a209 1
	int result;
d221 1
a221 1
	syslog(SYSLOG_PRI_LO, "%d message%s (%ld byte%s) loaded",
d226 1
a226 1
		result = POP_CRASH_NETFAIL;
d228 1
a228 1
	switch ((result = pop_handle_state(pop_trans_commands))) {
d239 1
a239 1
		syslog(SYSLOG_PRI_LO, "%d (%ld) deleted, %d (%ld) left",
d258 1
a258 1
	if (result == POP_CRASH_SERVER)
@


1.2
log
@update to 0.4.9.4:
- stand-alone or inetd selectable from command-line (-D = daemon mode)
- logging priorities more accurate
- chroots to empty dir
- tcp wrappers support
@
text
@d1 1
a1 1
/* $OpenBSD: pop_trans.c,v 1.1 2001/08/19 13:05:57 deraadt Exp $ */
d7 1
@


1.1
log
@libexec is the wrong place for popa3d, since it can be started WITHOUT inetd
@
text
@d1 1
a1 1
/* $OpenBSD: pop_trans.c,v 1.2 2001/08/13 20:19:33 camield Exp $ */
d31 1
a31 1
		return POP_CRASH;
d54 1
a54 1
				return POP_CRASH;
d57 1
a57 1
				return POP_CRASH;
d61 1
a61 1
	if (pop_reply_ok()) return POP_CRASH;
d73 1
a73 1
				return POP_CRASH;
d76 1
a76 1
				return POP_CRASH;
d78 1
a78 1
	if (pop_reply_terminate()) return POP_CRASH;
d97 1
d103 1
a103 1
	if (mailbox_get(msg, -1)) return POP_CRASH;
d114 1
d122 1
a122 1
	if (mailbox_get(msg, lines)) return POP_CRASH;
d166 1
a166 1
	if (pop_reply("+OK %d", db.last)) return POP_CRASH;
d208 3
a210 1
		syslog(SYSLOG_PRIORITY, "Failed to open mailbox");
d215 1
a215 1
	syslog(SYSLOG_PRIORITY, "%d message%s (%ld byte%s) loaded",
d220 1
a220 1
		result = POP_CRASH;
d226 3
a228 1
			syslog(SYSLOG_PRIORITY, "Failed to update mailbox");
d233 1
a233 1
		syslog(SYSLOG_PRIORITY, "%d (%ld) deleted, %d (%ld) left",
d241 6
a246 2
	case POP_TIMED_OUT:
		syslog(SYSLOG_PRIORITY, "Connection timed out");
d250 1
a250 1
		syslog(SYSLOG_PRIORITY, "Another MUA active, giving up");
d252 4
a255 2
	if (result == POP_CRASH)
		syslog(SYSLOG_PRIORITY, "Session crashed");
@

