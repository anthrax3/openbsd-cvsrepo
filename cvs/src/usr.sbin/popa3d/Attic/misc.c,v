head	1.2;
access;
symbols
	OPENBSD_5_4:1.1.0.50
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.48
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.46
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.44
	OPENBSD_5_0:1.1.0.42
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.40
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.38
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.34
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.36
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.32
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.30
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.28
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.26
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.24
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.22
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.20
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.18
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.16
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.14
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.12
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.10
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.8
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.6
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.4
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.12.15.17.37.25;	author tedu;	state dead;
branches;
next	1.1;

1.1
date	2001.08.19.13.05.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove popa3d. Sorry, no plaintext password only daemons allowed anymore.
ok deraadt and co.
@
text
@/* $OpenBSD: misc.c,v 1.1 2001/08/19 13:05:57 deraadt Exp $ */

/*
 * Miscellaneous syscall wrappers. See misc.h for the descriptions.
 */

#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/file.h>

#include "params.h"

int sleep_select(int sec, int usec)
{
	struct timeval timeout;

	timeout.tv_sec = sec;
	timeout.tv_usec = usec;

	return select(0, NULL, NULL, NULL, &timeout);
}

int lock_fd(int fd, int shared)
{
#if LOCK_FCNTL
	struct flock l;

	memset(&l, 0, sizeof(l));
	l.l_whence = SEEK_SET;
	l.l_type = shared ? F_RDLCK : F_WRLCK;
	while (fcntl(fd, F_SETLKW, &l)) {
		if (errno != EBUSY) return -1;
		sleep_select(1, 0);
	}
#endif

#if LOCK_FLOCK
	while (flock(fd, shared ? LOCK_SH : LOCK_EX)) {
		if (errno != EBUSY) return -1;
		sleep_select(1, 0);
	}
#endif

	return 0;
}

int unlock_fd(int fd)
{
#if LOCK_FCNTL
	struct flock l;

	memset(&l, 0, sizeof(l));
	l.l_whence = SEEK_SET;
	l.l_type = F_UNLCK;
	if (fcntl(fd, F_SETLK, &l)) return -1;
#endif

#if LOCK_FLOCK
	if (flock(fd, LOCK_UN)) return -1;
#endif

	return 0;
}

int write_loop(int fd, char *buffer, int count)
{
	int offset, block;

	offset = 0;
	while (count > 0) {
		block = write(fd, &buffer[offset], count);

/* If any write(2) fails, we consider that the entire write_loop() has
 * failed to do its job. We don't even ignore EINTR here. We also don't
 * retry when a write(2) returns zero, as we could start eating up the
 * CPU if we did. */
		if (block < 0) return block;
		if (!block) return offset;

		offset += block;
		count -= block;
	}

/* Should be equal to the requested size, unless our kernel got crazy. */
	return offset;
}
@


1.1
log
@libexec is the wrong place for popa3d, since it can be started WITHOUT inetd
@
text
@d1 1
a1 1
/* $OpenBSD: misc.c,v 1.2 2001/08/13 20:19:33 camield Exp $ */
@

