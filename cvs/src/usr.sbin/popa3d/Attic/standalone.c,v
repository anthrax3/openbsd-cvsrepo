head	1.15;
access;
symbols
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.10
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.8
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.15
date	2013.12.15.17.37.25;	author tedu;	state dead;
branches;
next	1.14;

1.14
date	2009.11.12.11.03.37;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.11.18.11.24;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.24.02.39.23;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.11.01.47.48;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.13.19.29.44;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.12.22.17.35;	author cloder;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.20.17.07.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.17.20.54.24;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.20.20.46.27;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.19.28.22;	author camield;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.06.19.17.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.29.09.45.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.21.20.22.06;	author camield;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.13.05.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@remove popa3d. Sorry, no plaintext password only daemons allowed anymore.
ok deraadt and co.
@
text
@/* $OpenBSD: standalone.c,v 1.14 2009/11/12 11:03:37 jsg Exp $ */

/*
 * Standalone POP server: accepts connections, checks the anti-flood limits,
 * logs and starts the actual POP sessions.
 */

#include "params.h"

#if POP_STANDALONE

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <syslog.h>
#include <time.h>
#include <errno.h>
#include <netdb.h>
#include <poll.h>
#include <sys/times.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#if DAEMON_LIBWRAP
#include <tcpd.h>
int allow_severity = SYSLOG_PRI_LO;
int deny_severity = SYSLOG_PRI_HI;
#endif

/*
 * These are defined in pop_root.c.
 */
extern int log_error(char *s);
extern int do_pop_startup(void);
extern int do_pop_session(void);
extern int af;

typedef volatile sig_atomic_t va_int;

/*
 * Active POP sessions. Those that were started within the last MIN_DELAY
 * seconds are also considered active (regardless of their actual state),
 * to allow for limiting the logging rate without throwing away critical
 * information about sessions that we could have allowed to proceed.
 */
static struct {
	char addr[NI_MAXHOST];		/* Source IP address */
	va_int pid;			/* PID of the server, or 0 for none */
	clock_t start;			/* When the server was started */
	clock_t log;			/* When we've last logged a failure */
} sessions[MAX_SESSIONS];

static va_int child_blocked;		/* We use blocking to avoid races */
static va_int child_pending;		/* Are any dead children waiting? */

int handle(int);

/*
 * SIGCHLD handler.
 */
static void handle_child(int signum)
{
	int saved_errno;
	pid_t pid;
	int i;

	saved_errno = errno;

	if (child_blocked)
		child_pending = 1;
	else {
		child_pending = 0;

		while ((pid = waitpid(0, NULL, WNOHANG)) > 0)
			for (i = 0; i < MAX_SESSIONS; i++)
				if (sessions[i].pid == pid) {
					sessions[i].pid = 0;
					break;
				}
	}

	signal(SIGCHLD, handle_child);

	errno = saved_errno;
}

#if DAEMON_LIBWRAP
static void check_access(int sock)
{
	struct request_info request;

	request_init(&request,
		RQ_DAEMON, DAEMON_LIBWRAP_IDENT,
		RQ_FILE, sock,
		0);
	fromhost(&request);

	if (!hosts_access(&request)) {
/* refuse() shouldn't return... */
		refuse(&request);
/* ...but just in case */
		exit(1);
	}
}
#endif

#if POP_OPTIONS
int do_standalone(void)
#else
int main(void)
#endif
{
	int error, i, n, true = 1;
	struct pollfd *pfds;
	struct addrinfo hints, *res, *res0;
	char sbuf[NI_MAXSERV];

	if (do_pop_startup()) return 1;

	snprintf(sbuf, sizeof(sbuf), "%u", DAEMON_PORT);
	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_family = af;
	hints.ai_flags = AI_PASSIVE;
	error = getaddrinfo(NULL, sbuf, &hints, &res0);
	if (error)
		return log_error("getaddrinfo");

	i = 0;
	for (res = res0; res; res = res->ai_next)
		i++;

	pfds = calloc(i, sizeof(pfds[0]));
	if (!pfds) {
		freeaddrinfo(res0);
		return log_error("malloc");
	}

	i = 0;
	for (res = res0; res; res = res->ai_next) {
		if ((pfds[i].fd = socket(res->ai_family, res->ai_socktype,
		    res->ai_protocol)) < 0)
			continue;

		if (setsockopt(pfds[i].fd, SOL_SOCKET, SO_REUSEADDR,
		    (void *)&true, sizeof(true))) {
			close(pfds[i].fd);
			continue;
		}

#ifdef IPV6_V6ONLY
		if (res->ai_family == AF_INET6)
			(void)setsockopt(pfds[i].fd, IPPROTO_IPV6, IPV6_V6ONLY,
			    (void *)&true, sizeof(true));
#endif

		if (bind(pfds[i].fd, res->ai_addr, res->ai_addrlen)) {
			close(pfds[i].fd);
			continue;
		}

		if (listen(pfds[i].fd, MAX_BACKLOG)) {
			close(pfds[i].fd);
			continue;
		}

		pfds[i].events = POLLIN;
		i++;
	}
	freeaddrinfo(res0);

	if (i == 0) {
		free(pfds);
		return log_error("socket");
	}

	n = i;

	chdir("/");
	setsid();

	switch (fork()) {
	case -1:
		free(pfds);
		return log_error("fork");

	case 0:
		break;

	default:
		free(pfds);
		return 0;
	}

	setsid();

	child_blocked = 1;
	child_pending = 0;
	signal(SIGCHLD, handle_child);

	memset((void *)sessions, 0, sizeof(sessions));

	while (1) {
		child_blocked = 0;
		if (child_pending) raise(SIGCHLD);

		i = poll(pfds, n, INFTIM);
		if (i < 0) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			free(pfds);
			return log_error("poll");
		}

		for (i = 0; i < n; i++)
			if (pfds[i].revents & POLLIN)
				handle(pfds[i].fd);
	}
}

int
handle(int sock)
{
	clock_t now, log;
	int new;
	char hbuf[NI_MAXHOST];
	struct sockaddr_storage addr;
	socklen_t addrlen;
	pid_t pid;
	struct tms buf;
	int error;
	int j, n, i, s;

	log = 0;
	new = 0;

	addrlen = sizeof(addr);
	new = accept(sock, (struct sockaddr *)&addr, &addrlen);
/*
 * I wish there was a portable way to classify errno's... In this case,
 * it appears to be better to risk eating up the CPU on a fatal error
 * rather than risk terminating the entire service because of a minor
 * temporary error having to do with one particular connection attempt.
 */
	if (new < 0)
		return -1;

	error = getnameinfo((struct sockaddr *)&addr, addrlen,
	    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
	if (error) {
		syslog(SYSLOG_PRI_HI,
		    "could not get host address");
		close(new);
		return -1;
	}

	now = times(&buf);
	if (!now)
		now = 1;

	child_blocked = 1;

	j = -1;
	n = 0;
	s = 0;
	for (i = 0; i < MAX_SESSIONS; i++) {
		s = i;
		if (sessions[i].start > now)
			sessions[i].start = 0;
		if (sessions[i].pid ||
		    (sessions[i].start &&
		    now - sessions[i].start < MIN_DELAY * CLK_TCK)) {
			if (strcmp(sessions[i].addr, hbuf) == 0)
				if (++n >= MAX_SESSIONS_PER_SOURCE)
					break;
		} else if (j < 0)
			j = i;
	}

	if (n >= MAX_SESSIONS_PER_SOURCE) {
		if (!sessions[s].log ||
		    now < sessions[s].log ||
		    now - sessions[s].log >= MIN_DELAY * CLK_TCK) {
			syslog(SYSLOG_PRI_HI,
				"%s: per source limit reached",
				hbuf);
			sessions[s].log = now;
		}
		close(new);
		return -1;
	}

	if (j < 0) {
		if (!log ||
		    now < log || now - log >= MIN_DELAY * CLK_TCK) {
			syslog(SYSLOG_PRI_HI,
			    "%s: sessions limit reached", hbuf);
			log = now;
		}
		close(new);
		return -1;
	}

	switch ((pid = fork())) {
	case -1:
		syslog(SYSLOG_PRI_ERROR, "%s: fork: %m", hbuf);
		close(new);
		return -1;

	case 0:
#if DAEMON_LIBWRAP
		check_access(new);
#endif
		syslog(SYSLOG_PRI_LO, "Session from %s",
			hbuf);
		if (dup2(new, 0) < 0 || dup2(new, 1) < 0 || dup2(new, 2) < 0) {
			log_error("dup2");
			_exit(1);
		}
		closefrom(3);
		_exit(do_pop_session());

	default:
		close(new);
		strlcpy(sessions[j].addr, hbuf,
			sizeof(sessions[j].addr));
		sessions[j].pid = (va_int)pid;
		sessions[j].start = now;
		sessions[j].log = 0;
		return 0;
	}
}

#endif
@


1.14
log
@Don't reuse a loop counter specifying the size of an array outside
of the loop to then access an offset in the array as this can lead
to an off by one.

found by parfait

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.13 2009/11/11 18:11:24 deraadt Exp $ */
@


1.13
log
@fix a few memory leaks, found by parfait; ok jsg
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.12 2008/05/24 02:39:23 brad Exp $ */
d237 1
a237 1
	int j, n, i;
d270 1
d272 1
d286 3
a288 3
		if (!sessions[i].log ||
		    now < sessions[i].log ||
		    now - sessions[i].log >= MIN_DELAY * CLK_TCK) {
d292 1
a292 1
			sessions[i].log = now;
@


1.12
log
@Move the setting of the POLLIN flag to the bottom of the for loop
to ensure that the flag is only set when there is a valid fd.

Found by deraadt@@

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.11 2007/05/11 01:47:48 ray Exp $ */
d177 2
a178 1
	if (i == 0)
d180 1
d189 1
d196 1
d216 1
@


1.11
log
@Delinting from tbert <bret dot lambert at gmail dot com>

OK moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.10 2005/03/13 19:29:44 otto Exp $ */
a148 1
		pfds[i].events = POLLIN;
d172 1
@


1.10
log
@Missing return value and fd leak in fork()'s error path. Spotted by mpech@@
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.9 2005/03/12 22:17:35 cloder Exp $ */
d228 1
a228 1
	int addrlen;
@


1.9
log
@Do not leak mem or fd in error paths.  From Andrey Matveev (thanks!).
OK niallo@@
deraadt@@: "stop polishing turds and commit already"
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.8 2004/07/20 17:07:34 millert Exp $ */
d305 2
a306 1
		break;
@


1.8
log
@IPv6 support originally by itojun@@ with standalone mode fixes by me.
Tested by several people in both inetd and standalone mode w/ IPv4 and IPv6.
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.7 2004/07/17 20:54:24 brad Exp $ */
d139 2
a140 1
	if (!pfds)
d142 1
d252 2
a253 1
		    "%s: invalid IP address", hbuf);
@


1.7
log
@the IPv4/IPv6 standalone mode patch has some issues so back it out for now.

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.5 2003/05/12 19:28:22 camield Exp $ */
d20 2
d41 1
d52 2
a53 2
	struct in_addr addr;		/* Source IP address */
	volatile int pid;		/* PID of the server, or 0 for none */
d61 2
d118 4
a121 8
	int true = 1;
	int sock, new;
	struct sockaddr_in addr;
	socklen_t addrlen;
	pid_t pid;
	struct tms buf;
	clock_t now, log;
	int i, j, n;
d125 51
a175 1
	if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
d178 1
a178 13
	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
	    (void *)&true, sizeof(true)))
		return log_error("setsockopt");

	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = inet_addr(DAEMON_ADDR);
	addr.sin_port = htons(DAEMON_PORT);
	if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)))
		return log_error("bind");

	if (listen(sock, MAX_BACKLOG))
		return log_error("listen");
a200 3
	log = 0;

	new = 0;
d206 12
a217 2
		if (new > 0)
		if (close(new)) return log_error("close");
d219 12
a230 2
		addrlen = sizeof(addr);
		new = accept(sock, (struct sockaddr *)&addr, &addrlen);
d232 5
d243 10
a252 1
		if (new < 0) continue;
d254 3
a256 2
		now = times(&buf);
		if (!now) now = 1;
d258 1
a258 1
		child_blocked = 1;
d260 23
a282 24
		j = -1; n = 0;
		for (i = 0; i < MAX_SESSIONS; i++) {
			if (sessions[i].start > now)
				sessions[i].start = 0;
			if (sessions[i].pid ||
			    (sessions[i].start &&
			    now - sessions[i].start < MIN_DELAY * CLK_TCK)) {
				if (sessions[i].addr.s_addr ==
				    addr.sin_addr.s_addr)
				if (++n >= MAX_SESSIONS_PER_SOURCE) break;
			} else
			if (j < 0) j = i;
		}

		if (n >= MAX_SESSIONS_PER_SOURCE) {
			if (!sessions[i].log ||
			    now < sessions[i].log ||
			    now - sessions[i].log >= MIN_DELAY * CLK_TCK) {
				syslog(SYSLOG_PRI_HI,
					"%s: per source limit reached",
					inet_ntoa(addr.sin_addr));
				sessions[i].log = now;
			}
			continue;
d284 3
d288 6
a293 9
		if (j < 0) {
			if (!log ||
			    now < log || now - log >= MIN_DELAY * CLK_TCK) {
				syslog(SYSLOG_PRI_HI,
					"%s: sessions limit reached",
					inet_ntoa(addr.sin_addr));
				log = now;
			}
			continue;
d295 3
d299 4
a302 5
		switch ((pid = fork())) {
		case -1:
			syslog(SYSLOG_PRI_ERROR, "%s: fork: %m",
				inet_ntoa(addr.sin_addr));
			break;
d304 1
a304 2
		case 0:
			if (close(sock)) return log_error("close");
d306 1
a306 1
			check_access(new);
d308 5
a312 13
			syslog(SYSLOG_PRI_LO, "Session from %s",
				inet_ntoa(addr.sin_addr));
			if (dup2(new, 0) < 0) return log_error("dup2");
			if (dup2(new, 1) < 0) return log_error("dup2");
			if (dup2(new, 2) < 0) return log_error("dup2");
			if (close(new)) return log_error("close");
			return do_pop_session();

		default:
			sessions[j].addr = addr.sin_addr;
			sessions[j].pid = pid;
			sessions[j].start = now;
			sessions[j].log = 0;
d314 11
@


1.6
log
@IPv4/v6 support for standalone mode.  brad tested and ok'ed
@
text
@a19 2
#include <netdb.h>
#include <poll.h>
a38 1
extern int af;
d49 1
a49 1
	char addr[NI_MAXHOST];		/* Source IP address */
a57 2
int handle(int);

d64 1
a64 1
	int pid;
d75 5
a79 5
		for (i = 0; i < MAX_SESSIONS; i++)
		if (sessions[i].pid == pid) {
			sessions[i].pid = 0;
			break;
		}
d114 7
a120 6
	int *fds, new, sock;
	struct pollfd *pfds;
	int i, n;
	struct addrinfo hints, *res, *res0;
	char sbuf[NI_MAXSERV];
	int error;
d124 2
a125 55
	snprintf(sbuf, sizeof(sbuf), "%u", DAEMON_PORT);
	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_family = af;
	hints.ai_flags = AI_PASSIVE;
	error = getaddrinfo(NULL, sbuf, &hints, &res0);
	if (error)
		return log_error("getaddrinfo");

	i = 0;
	for (res = res0; res; res = res->ai_next)
		i++;

	fds = malloc(i * sizeof(fds[0]));
	if (!fds)
		return log_error("malloc");
	pfds = malloc(i * sizeof(pfds[0]));
	if (!pfds)
		return log_error("malloc");

	i = 0;
	for (res = res0; res; res = res->ai_next) {
		if ((fds[i] = socket(res->ai_family, res->ai_socktype,
		    res->ai_protocol)) < 0)
			continue;

		if (setsockopt(fds[i], SOL_SOCKET, SO_REUSEADDR,
		    (void *)&true, sizeof(true))) {
			close(fds[i]);
			continue;
		}

#ifdef IPV6_V6ONLY
		if (res->ai_family == AF_INET6)
			(void)setsockopt(fds[i], IPPROTO_IPV6, IPV6_V6ONLY,
			    (void *)&true, sizeof(true));
#endif

		if (bind(fds[i], res->ai_addr, res->ai_addrlen)) {
			close(fds[i]);
			continue;
		}

		if (listen(fds[i], MAX_BACKLOG)) {
			close(fds[i]);
			continue;
		}

		memset(&pfds[i], 0, sizeof(pfds[i]));
		pfds[i].fd = fds[i];
		pfds[i].events = POLLIN;

		i++;
	}
	freeaddrinfo(res0);
d127 10
a136 2
	if (i == 0)
		return log_error("socket");
d138 2
a139 1
	n = i;
d162 1
d168 1
a168 2
		if (child_pending)
			raise(SIGCHLD);
d170 2
a171 30
		i = poll(pfds, n, INFTIM);

		if (i < 0)
			log_error("poll");

		sock = -1;
		for (i = 0; i < n; i++)
			if (pfds[i].revents & POLLIN)
				handle(pfds[i].fd);
	}
}

int
handle(int sock)
{
	clock_t now, log;
	int new;
	char hbuf[NI_MAXHOST];
	struct sockaddr_storage addr;
	int addrlen;
	int pid;
	struct tms buf;
	int error;
	int j, n, i;

	log = 0;
	new = 0;

	addrlen = sizeof(addr);
	new = accept(sock, (struct sockaddr *)&addr, &addrlen);
d173 2
a174 4
	error = getnameinfo((struct sockaddr *)&addr, addrlen,
	    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST);
	if (error)
		; /* XXX */
d182 1
a182 2
	if (new < 0)
		return 0;
d184 2
a185 3
	now = times(&buf);
	if (!now)
		now = 1;
d187 1
a187 1
	child_blocked = 1;
d189 24
a212 23
	j = -1;
	n = 0;
	for (i = 0; i < MAX_SESSIONS; i++) {
		if (sessions[i].start > now)
			sessions[i].start = 0;
		if (sessions[i].pid ||
		    (sessions[i].start &&
		    now - sessions[i].start < MIN_DELAY * CLK_TCK)) {
			if (strcmp(sessions[i].addr, hbuf) == 0)
				if (++n >= MAX_SESSIONS_PER_SOURCE)
					break;
		} else if (j < 0)
			j = i;
	}

	if (n >= MAX_SESSIONS_PER_SOURCE) {
		if (!sessions[i].log ||
		    now < sessions[i].log ||
		    now - sessions[i].log >= MIN_DELAY * CLK_TCK) {
			syslog(SYSLOG_PRI_HI,
				"%s: per source limit reached",
				hbuf);
			sessions[i].log = now;
a213 2
		return 0;
	}
d215 9
a223 6
	if (j < 0) {
		if (!log ||
		    now < log || now - log >= MIN_DELAY * CLK_TCK) {
			syslog(SYSLOG_PRI_HI,
			    "%s: sessions limit reached", hbuf);
			log = now;
a224 2
		return 0;
	}
d226 5
a230 4
	switch ((pid = fork())) {
	case -1:
		syslog(SYSLOG_PRI_ERROR, "%s: fork: %m", hbuf);
		break;
d232 2
a233 2
	case 0:
		if (close(sock)) return log_error("close");
d235 1
a235 1
		check_access(new);
d237 14
a250 14
		syslog(SYSLOG_PRI_LO, "Session from %s",
			hbuf);
		if (dup2(new, 0) < 0) return log_error("dup2");
		if (dup2(new, 1) < 0) return log_error("dup2");
		if (dup2(new, 2) < 0) return log_error("dup2");
		if (close(new)) return log_error("close");
		return do_pop_session();

	default:
		strlcpy(sessions[j].addr, hbuf,
			sizeof(sessions[j].addr));
		(va_int)sessions[j].pid = pid;
		sessions[j].start = now;
		sessions[j].log = 0;
@


1.5
log
@Sync to 0.6.2

- UIDL digest calculation has been improved
- minor bug fixes
- -V switch to show version
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.4 2002/09/06 19:17:40 deraadt Exp $ */
d20 2
d41 1
d52 1
a52 1
	struct in_addr addr;		/* Source IP address */
d61 2
d69 1
a69 1
	pid_t pid;
d80 5
a84 5
			for (i = 0; i < MAX_SESSIONS; i++)
				if (sessions[i].pid == pid) {
					sessions[i].pid = 0;
					break;
				}
d119 6
a124 7
	int sock, new;
	struct sockaddr_in addr;
	socklen_t addrlen;
	pid_t pid;
	struct tms buf;
	clock_t now, log;
	int i, j, n;
d128 57
a184 1
	if ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
d187 1
a187 13
	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
	    (void *)&true, sizeof(true)))
		return log_error("setsockopt");

	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = inet_addr(DAEMON_ADDR);
	addr.sin_port = htons(DAEMON_PORT);
	if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)))
		return log_error("bind");

	if (listen(sock, MAX_BACKLOG))
		return log_error("listen");
a209 1
	log = 0;
d215 30
a244 1
		if (child_pending) raise(SIGCHLD);
d246 2
a247 2
		if (new > 0)
		if (close(new)) return log_error("close");
d249 4
a252 2
		addrlen = sizeof(addr);
		new = accept(sock, (struct sockaddr *)&addr, &addrlen);
d260 2
a261 1
		if (new < 0) continue;
d263 3
a265 2
		now = times(&buf);
		if (!now) now = 1;
d267 16
a282 1
		child_blocked = 1;
d284 8
a291 24
		j = -1; n = 0;
		for (i = 0; i < MAX_SESSIONS; i++) {
			if (sessions[i].start > now)
				sessions[i].start = 0;
			if (sessions[i].pid ||
			    (sessions[i].start &&
			    now - sessions[i].start < MIN_DELAY * CLK_TCK)) {
				if (sessions[i].addr.s_addr ==
				    addr.sin_addr.s_addr)
				if (++n >= MAX_SESSIONS_PER_SOURCE) break;
			} else
			if (j < 0) j = i;
		}

		if (n >= MAX_SESSIONS_PER_SOURCE) {
			if (!sessions[i].log ||
			    now < sessions[i].log ||
			    now - sessions[i].log >= MIN_DELAY * CLK_TCK) {
				syslog(SYSLOG_PRI_HI,
					"%s: per source limit reached",
					inet_ntoa(addr.sin_addr));
				sessions[i].log = now;
			}
			continue;
d293 2
d296 6
a301 9
		if (j < 0) {
			if (!log ||
			    now < log || now - log >= MIN_DELAY * CLK_TCK) {
				syslog(SYSLOG_PRI_HI,
					"%s: sessions limit reached",
					inet_ntoa(addr.sin_addr));
				log = now;
			}
			continue;
d303 2
d306 4
a309 5
		switch ((pid = fork())) {
		case -1:
			syslog(SYSLOG_PRI_ERROR, "%s: fork: %m",
				inet_ntoa(addr.sin_addr));
			break;
d311 2
a312 2
		case 0:
			if (close(sock)) return log_error("close");
d314 1
a314 1
			check_access(new);
d316 14
a329 14
			syslog(SYSLOG_PRI_LO, "Session from %s",
				inet_ntoa(addr.sin_addr));
			if (dup2(new, 0) < 0) return log_error("dup2");
			if (dup2(new, 1) < 0) return log_error("dup2");
			if (dup2(new, 2) < 0) return log_error("dup2");
			if (close(new)) return log_error("close");
			return do_pop_session();

		default:
			sessions[j].addr = addr.sin_addr;
			sessions[j].pid = pid;
			sessions[j].start = now;
			sessions[j].log = 0;
		}
@


1.4
log
@misuse of volatile, not even ansi C
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.3 2002/05/29 09:45:08 deraadt Exp $ */
d40 1
a40 2
typedef sig_atomic_t a_int;
typedef volatile a_int va_int;
d50 1
a50 1
	a_int pid;			/* PID of the server, or 0 for none */
d59 1
a59 1
 * SIGCHLD handler; can also be called directly with a zero signum.
d82 1
a82 1
	if (signum) signal(SIGCHLD, handle_child);
d119 1
a119 1
	clock_t now;
d162 2
d168 1
a168 1
		if (child_pending) handle_child(0);
d185 1
d216 7
a222 2
			syslog(SYSLOG_PRI_HI, "%s: sessions limit reached",
				inet_ntoa(addr.sin_addr));
@


1.3
log
@more sprintf
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.2 2001/09/21 20:22:06 camield Exp $ */
d117 1
a117 1
	int addrlen;
d240 1
a240 1
			(va_int)sessions[j].pid = pid;
@


1.2
log
@update to 0.4.9.4:
- stand-alone or inetd selectable from command-line (-D = daemon mode)
- logging priorities more accurate
- chroots to empty dir
- tcp wrappers support
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.1 2001/08/19 13:05:57 deraadt Exp $ */
d65 1
a65 1
	int pid;
d76 5
a80 5
		for (i = 0; i < MAX_SESSIONS; i++)
		if (sessions[i].pid == pid) {
			sessions[i].pid = 0;
			break;
		}
d118 1
a118 1
	int pid;
@


1.1
log
@libexec is the wrong place for popa3d, since it can be started WITHOUT inetd
@
text
@d1 1
a1 1
/* $OpenBSD: standalone.c,v 1.2 2001/08/13 20:19:33 camield Exp $ */
d27 6
d40 3
d51 1
a51 1
	int pid;			/* PID of the server, or 0 for none */
d56 2
a57 2
static volatile int child_blocked;	/* We use blocking to avoid races */
static volatile int child_pending;	/* Are any dead children waiting? */
d88 23
d112 1
d205 1
a205 1
				syslog(SYSLOG_PRIORITY,
d214 1
a214 1
			syslog(SYSLOG_PRIORITY, "%s: sessions limit reached",
d221 1
a221 1
			syslog(SYSLOG_PRIORITY, "%s: fork: %m",
d226 5
a230 1
			syslog(SYSLOG_PRIORITY, "Session from %s",
a231 1
			if (close(sock)) return log_error("close");
d240 1
a240 1
			(volatile int)sessions[j].pid = pid;
@

