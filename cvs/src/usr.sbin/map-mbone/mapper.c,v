head	1.24;
access;
symbols
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.14
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.12
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.8
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.6
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.4
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.19.0.20
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.18
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.16
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.12
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.14
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.10
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.8
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.6
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.6
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.08.03.23.13.54;	author krw;	state Exp;
branches;
next	1.23;
commitid	BUeKVPoFGPGxtzvD;

1.23
date	2015.08.20.22.39.29;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	z3HrihslRYb4HqW9;

1.22
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	Uu5nFG3wCl0LACBb;

1.21
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.20;
commitid	9QOFSShUOtA0kQLF;

1.20
date	2011.09.21.18.48.43;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.18.20.57.53;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.22.14.50.21;	author robert;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.20.14.42.57;	author robert;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.01.18.32.19;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.26.01.17.12;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.19.19.08.01;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.04.22.38.24;	author avsm;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.09.02.27.16;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.02.19.06.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.27.20.17.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.17.19.42.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.28.04;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.05.22.32.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.31.22.13.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.09.03.24.06;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.11.19.15.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.46.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.45;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Apply fix from mrouted 3.8 via NetBSD. Our mbone support may
be slightly dated.

Spotted by the Echelon team with AppChecker static analyzer.
@
text
@/*	$OpenBSD: mapper.c,v 1.23 2015/08/20 22:39:29 deraadt Exp $	*/
/*	$NetBSD: mapper.c,v 1.3 1995/12/10 11:12:04 mycroft Exp $	*/

/* Mapper for connections between MRouteD multicast routers.
 * Written by Pavel Curtis <Pavel@@PARC.Xerox.Com>
 */

/*
 * Copyright (c) 1992, 2001 Xerox Corporation.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither name of the Xerox, PARC, nor the names of its contributors may be used
 * to endorse or promote products derived from this software 
 * without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE XEROX CORPORATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

#include <string.h>
#include <netdb.h>
#include <sys/time.h>
#include "defs.h"
#include <arpa/inet.h>
#include <stdarg.h>
#include <poll.h>
#include <limits.h>
#include <err.h>

#define DEFAULT_TIMEOUT	2	/* How long to wait before retrying requests */
#define DEFAULT_RETRIES 1	/* How many times to ask each router */


/* All IP addresses are stored in the data structure in NET order. */

typedef struct neighbor {
    struct neighbor    *next;
    u_int32_t		addr;		/* IP address in NET order */
    u_char		metric;		/* TTL cost of forwarding */
    u_char		threshold;	/* TTL threshold to forward */
    u_short		flags;		/* flags on connection */
#define NF_PRESENT 0x8000	/* True if flags are meaningful */
} Neighbor;

typedef struct interface {
    struct interface *next;
    u_int32_t	addr;		/* IP address of the interface in NET order */
    Neighbor   *neighbors;	/* List of neighbors' IP addresses */
} Interface;

typedef struct node {
    u_int32_t	addr;		/* IP address of this entry in NET order */
    u_int32_t	version;	/* which mrouted version is running */
    int		tries;		/* How many requests sent?  -1 for aliases */
    union {
	struct node *alias;		/* If alias, to what? */
	struct interface *interfaces;	/* Else, neighbor data */
    } u;
    struct node *left, *right;
} Node;


Node   *routers = 0;
u_int32_t	our_addr, target_addr = 0;		/* in NET order */
int	debug = 0;
int	retries = DEFAULT_RETRIES;
int	timeout = DEFAULT_TIMEOUT;
int	show_names = TRUE;
vifi_t  numvifs;		/* to keep loader happy */
				/* (see COPY_TABLES macro called in kern.c) */

Node *			find_node(u_int32_t addr, Node **ptr);
Interface *		find_interface(u_int32_t addr, Node *node);
Neighbor *		find_neighbor(u_int32_t addr, Node *node);
int			main(int argc, char *argv[]);
void			ask(u_int32_t dst);
void			ask2(u_int32_t dst);
int			retry_requests(Node *node);
char *			inet_name(u_int32_t addr);
void			print_map(Node *node);
char *			graph_name(u_int32_t addr, char *buf, size_t len);
void			graph_edges(Node *node);
void			elide_aliases(Node *node);
void			graph_map(void);
u_int32_t		host_addr(char *name);
void			usage(void);

Node *find_node(u_int32_t addr, Node **ptr)
{
    Node *n = *ptr;

    if (!n) {
	*ptr = n = malloc(sizeof(Node));
	n->addr = addr;
	n->version = 0;
	n->tries = 0;
	n->u.interfaces = 0;
	n->left = n->right = 0;
	return n;
    } else if (addr == n->addr)
	return n;
    else if (addr < n->addr)
	return find_node(addr, &(n->left));
    else
	return find_node(addr, &(n->right));
}


Interface *find_interface(u_int32_t addr, Node *node)
{
    Interface *ifc;

    for (ifc = node->u.interfaces; ifc; ifc = ifc->next)
	if (ifc->addr == addr)
	    return ifc;

    ifc = malloc(sizeof(Interface));
    ifc->addr = addr;
    ifc->next = node->u.interfaces;
    node->u.interfaces = ifc;
    ifc->neighbors = 0;

    return ifc;
}


Neighbor *find_neighbor(u_int32_t addr, Node *node)
{
    Interface *ifc;

    for (ifc = node->u.interfaces; ifc; ifc = ifc->next) {
	Neighbor *nb;

	for (nb = ifc->neighbors; nb; nb = nb->next)
	    if (nb->addr == addr)
		return nb;
    }

    return 0;
}


/*
 * Log errors and other messages to stderr, according to the severity of the
 * message and the current debug level.  For errors of severity LOG_ERR or
 * worse, terminate the program.
 */
void
logit(int severity, int syserr, char *format, ...)
{
    va_list ap;
    char    fmt[100];

    switch (debug) {
	case 0: if (severity > LOG_WARNING) return;
	case 1: if (severity > LOG_NOTICE ) return;
	case 2: if (severity > LOG_INFO   ) return;
	default:
	    va_start(ap, format);
	    fmt[0] = '\0';
	    if (severity == LOG_WARNING)
		strlcat(fmt, "warning - ", sizeof(fmt));
	    strncat(fmt, format, 80);
	    vfprintf(stderr, fmt, ap);
	    va_end(ap);
	    if (syserr == 0)
		fprintf(stderr, "\n");
	    else if (syserr < sys_nerr)
		fprintf(stderr, ": %s\n", sys_errlist[syserr]);
	    else
		fprintf(stderr, ": errno %d\n", syserr);
    }

    if (severity <= LOG_ERR)
	exit(1);
}


/*
 * Send a neighbors-list request.
 */
void ask(u_int32_t dst)
{
    send_igmp(our_addr, dst, IGMP_DVMRP, DVMRP_ASK_NEIGHBORS,
		htonl(MROUTED_LEVEL), 0);
}

void ask2(u_int32_t dst)
{
    send_igmp(our_addr, dst, IGMP_DVMRP, DVMRP_ASK_NEIGHBORS2,
		htonl(MROUTED_LEVEL), 0);
}


/*
 * Process an incoming group membership report.
 */
void accept_group_report(u_int32_t src, u_int32_t dst, u_int32_t group,
    int r_type)
{
    logit(LOG_INFO, 0, "ignoring IGMP group membership report from %s to %s",
	inet_fmt(src, s1), inet_fmt(dst, s2));
}


/*
 * Process an incoming neighbor probe message.
 */
void accept_probe(u_int32_t src, u_int32_t dst, char *p, int datalen,
    u_int32_t level)
{
    logit(LOG_INFO, 0, "ignoring DVMRP probe from %s to %s",
	inet_fmt(src, s1), inet_fmt(dst, s2));
}


/*
 * Process an incoming route report message.
 */
void accept_report(u_int32_t src, u_int32_t dst, char *p, int datalen,
    u_int32_t level)
{
    logit(LOG_INFO, 0, "ignoring DVMRP routing report from %s to %s",
	inet_fmt(src, s1), inet_fmt(dst, s2));
}


/*
 * Process an incoming neighbor-list request message.
 */
void accept_neighbor_request(u_int32_t src, u_int32_t dst)
{
    if (src != our_addr)
	logit(LOG_INFO, 0,
	    "ignoring spurious DVMRP neighbor request from %s to %s",
	    inet_fmt(src, s1), inet_fmt(dst, s2));
}

void accept_neighbor_request2(u_int32_t src, u_int32_t dst)
{
    if (src != our_addr)
	logit(LOG_INFO, 0,
	    "ignoring spurious DVMRP neighbor request2 from %s to %s",
	    inet_fmt(src, s1), inet_fmt(dst, s2));
}


/*
 * Process an incoming neighbor-list message.
 */
void accept_neighbors(u_int32_t src, u_int32_t dst, u_char *p, int datalen,
    u_int32_t level)
{
    Node       *node = find_node(src, &routers);

    if (node->tries == 0)	/* Never heard of 'em; must have hit them at */
	node->tries = 1;	/* least once, though...*/
    else if (node->tries == -1)	/* follow alias link */
	node = node->u.alias;

#define GET_ADDR(a) (a = ((u_int32_t)*p++ << 24), a += ((u_int32_t)*p++ << 16),\
		     a += ((u_int32_t)*p++ << 8), a += *p++)

    /* if node is running a recent mrouted, ask for additional info */
    if (level != 0) {
	node->version = level;
	node->tries = 1;
	ask2(src);
	return;
    }

    if (debug > 3) {
	int i;

	fprintf(stderr, "    datalen = %d\n", datalen);
	for (i = 0; i < datalen; i++) {
	    if ((i & 0xF) == 0)
		fprintf(stderr, "   ");
	    fprintf(stderr, " %02x", p[i]);
	    if ((i & 0xF) == 0xF)
		fprintf(stderr, "\n");
	}
	if ((datalen & 0xF) != 0xF)
	    fprintf(stderr, "\n");
    }

    while (datalen > 0) {	/* loop through interfaces */
	u_int32_t		ifc_addr;
	u_char		metric, threshold, ncount;
	Node   	       *ifc_node;
	Interface      *ifc;
	Neighbor       *old_neighbors;

	if (datalen < 4 + 3) {
	    logit(LOG_WARNING, 0, "received truncated interface record from %s",
		inet_fmt(src, s1));
	    return;
	}

	GET_ADDR(ifc_addr);
	ifc_addr = htonl(ifc_addr);
	metric = *p++;
	threshold = *p++;
	ncount = *p++;
	datalen -= 4 + 3;

	/* Fix up any alias information */
	ifc_node = find_node(ifc_addr, &routers);
	if (ifc_node->tries == 0) { /* new node */
	    ifc_node->tries = -1;
	    ifc_node->u.alias = node;
	} else if (ifc_node != node
		   && (ifc_node->tries > 0  ||  ifc_node->u.alias != node)) {
	    /* must merge two hosts' nodes */
	    Interface  *ifc_i, *next_ifc_i;

	    if (ifc_node->tries == -1) {
		Node *tmp = ifc_node->u.alias;

		ifc_node->u.alias = node;
		ifc_node = tmp;
	    }

	    /* Merge ifc_node (foo_i) into node (foo_n) */

	    if (ifc_node->tries > node->tries)
		node->tries = ifc_node->tries;

	    for (ifc_i = ifc_node->u.interfaces; ifc_i; ifc_i = next_ifc_i) {
		Neighbor *nb_i, *next_nb_i, *nb_n;
		Interface *ifc_n = find_interface(ifc_i->addr, node);

		old_neighbors = ifc_n->neighbors;
		for (nb_i = ifc_i->neighbors; nb_i; nb_i = next_nb_i) {
		    next_nb_i = nb_i->next;
		    for (nb_n = old_neighbors; nb_n; nb_n = nb_n->next)
			if (nb_i->addr == nb_n->addr) {
			    if (nb_i->metric != nb_n->metric
				|| nb_i->threshold != nb_n->threshold)
				logit(LOG_WARNING, 0,
				    "inconsistent %s for neighbor %s of %s",
				    "metric/threshold",
				    inet_fmt(nb_i->addr, s1),
				    inet_fmt(node->addr, s2));
			    free(nb_i);
			    break;
			}
		    if (!nb_n) { /* no match for this neighbor yet */
			nb_i->next = ifc_n->neighbors;
			ifc_n->neighbors = nb_i;
		    }
		}

		next_ifc_i = ifc_i->next;
		free(ifc_i);
	    }

	    ifc_node->tries = -1;
	    ifc_node->u.alias = node;
	}
	
	ifc = find_interface(ifc_addr, node);
	old_neighbors = ifc->neighbors;
	
	/* Add the neighbors for this interface */
	while (ncount--) {
	    u_int32_t 	neighbor;
	    Neighbor   *nb;
	    Node       *n_node;

	    if (datalen < 4) {
		logit(LOG_WARNING, 0, "received truncated neighbor list from %s",
		    inet_fmt(src, s1));
		return;
	    }

	    GET_ADDR(neighbor);
	    neighbor = htonl(neighbor);
	    datalen -= 4;

	    for (nb = old_neighbors; nb; nb = nb->next)
		if (nb->addr == neighbor) {
		    if (metric != nb->metric || threshold != nb->threshold)
			logit(LOG_WARNING, 0,
			    "inconsistent %s for neighbor %s of %s",
			    "metric/threshold",
			    inet_fmt(nb->addr, s1), inet_fmt(node->addr, s2));
		    goto next_neighbor;
		}

	    nb = malloc(sizeof(Neighbor));
	    nb->next = ifc->neighbors;
	    ifc->neighbors = nb;
	    nb->addr = neighbor;
	    nb->metric = metric;
	    nb->threshold = threshold;
	    nb->flags = 0;

	    n_node = find_node(neighbor, &routers);
	    if (n_node->tries == 0  &&  !target_addr) { /* it's a new router */
		ask(neighbor);
		n_node->tries = 1;
	    }

	  next_neighbor: ;
	}
    }
}

void accept_neighbors2(u_int32_t src, u_int32_t dst, u_char *p, int datalen,
    u_int32_t level)
{
    Node       *node = find_node(src, &routers);
    u_int broken_cisco = ((level & 0xffff) == 0x020a); /* 10.2 */
    /* well, only possibly_broken_cisco, but that's too long to type. */

    if (node->tries == 0)	/* Never heard of 'em; must have hit them at */
	node->tries = 1;	/* least once, though...*/
    else if (node->tries == -1)	/* follow alias link */
	node = node->u.alias;

    while (datalen > 0) {	/* loop through interfaces */
	u_int32_t		ifc_addr;
	u_char		metric, threshold, ncount, flags;
	Node   	       *ifc_node;
	Interface      *ifc;
	Neighbor       *old_neighbors;

	if (datalen < 4 + 4) {
	    logit(LOG_WARNING, 0, "received truncated interface record from %s",
		inet_fmt(src, s1));
	    return;
	}

	ifc_addr = *(u_int32_t*)p;
	p += 4;
	metric = *p++;
	threshold = *p++;
	flags = *p++;
	ncount = *p++;
	datalen -= 4 + 4;

	if (broken_cisco && ncount == 0)	/* dumb Ciscos */
		ncount = 1;
	if (broken_cisco && ncount > 15)	/* dumb Ciscos */
		ncount = ncount & 0xf;

	/* Fix up any alias information */
	ifc_node = find_node(ifc_addr, &routers);
	if (ifc_node->tries == 0) { /* new node */
	    ifc_node->tries = -1;
	    ifc_node->u.alias = node;
	} else if (ifc_node != node
		   && (ifc_node->tries > 0  ||  ifc_node->u.alias != node)) {
	    /* must merge two hosts' nodes */
	    Interface  *ifc_i, *next_ifc_i;

	    if (ifc_node->tries == -1) {
		Node *tmp = ifc_node->u.alias;

		ifc_node->u.alias = node;
		ifc_node = tmp;
	    }

	    /* Merge ifc_node (foo_i) into node (foo_n) */

	    if (ifc_node->tries > node->tries)
		node->tries = ifc_node->tries;

	    for (ifc_i = ifc_node->u.interfaces; ifc_i; ifc_i = next_ifc_i) {
		Neighbor *nb_i, *next_nb_i, *nb_n;
		Interface *ifc_n = find_interface(ifc_i->addr, node);

		old_neighbors = ifc_n->neighbors;
		for (nb_i = ifc_i->neighbors; nb_i; nb_i = next_nb_i) {
		    next_nb_i = nb_i->next;
		    for (nb_n = old_neighbors; nb_n; nb_n = nb_n->next)
			if (nb_i->addr == nb_n->addr) {
			    if (nb_i->metric != nb_n->metric
				|| nb_i->threshold != nb_n->threshold)
				logit(LOG_WARNING, 0,
				    "inconsistent %s for neighbor %s of %s",
				    "metric/threshold",
				    inet_fmt(nb_i->addr, s1),
				    inet_fmt(node->addr, s2));
			    free(nb_i);
			    break;
			}
		    if (!nb_n) { /* no match for this neighbor yet */
			nb_i->next = ifc_n->neighbors;
			ifc_n->neighbors = nb_i;
		    }
		}

		next_ifc_i = ifc_i->next;
		free(ifc_i);
	    }

	    ifc_node->tries = -1;
	    ifc_node->u.alias = node;
	}
	
	ifc = find_interface(ifc_addr, node);
	old_neighbors = ifc->neighbors;
	
	/* Add the neighbors for this interface */
	while (ncount-- && datalen > 0) {
	    u_int32_t 	neighbor;
	    Neighbor   *nb;
	    Node       *n_node;

	    if (datalen < 4) {
		logit(LOG_WARNING, 0, "received truncated neighbor list from %s",
		    inet_fmt(src, s1));
		return;
	    }

	    neighbor = *(u_int32_t*)p;
	    p += 4;
	    datalen -= 4;
	    if (neighbor == 0)
		/* make leaf nets point to themselves */
		neighbor = ifc_addr;

	    for (nb = old_neighbors; nb; nb = nb->next)
		if (nb->addr == neighbor) {
		    if (metric != nb->metric || threshold != nb->threshold)
			logit(LOG_WARNING, 0,
			    "inconsistent %s for neighbor %s of %s",
			    "metric/threshold",
			    inet_fmt(nb->addr, s1), inet_fmt(node->addr, s2));
		    goto next_neighbor;
		}

	    nb = malloc(sizeof(Neighbor));
	    nb->next = ifc->neighbors;
	    ifc->neighbors = nb;
	    nb->addr = neighbor;
	    nb->metric = metric;
	    nb->threshold = threshold;
	    nb->flags = flags | NF_PRESENT;

	    n_node = find_node(neighbor, &routers);
	    if (n_node->tries == 0  &&  !target_addr) { /* it's a new router */
		ask(neighbor);
		n_node->tries = 1;
	    }

	  next_neighbor: ;
	}
    }
}


void check_vif_state(void)
{
    logit(LOG_NOTICE, 0, "network marked down...");
}


int retry_requests(Node *node)
{
    int	result;

    if (node) {
	result = retry_requests(node->left);
	if (node->tries > 0  &&  node->tries < retries) {
	    if (node->version)
		ask2(node->addr);
	    else
		ask(node->addr);
	    node->tries++;
	    result = 1;
	}
	return retry_requests(node->right) || result;
    } else
	return 0;
}


char *inet_name(u_int32_t addr)
{
    struct hostent *e;

    e = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET);

    return e ? e->h_name : 0;
}


void print_map(Node *node)
{
    if (node) {
	char *name, *addr;
	
	print_map(node->left);

	addr = inet_fmt(node->addr, s1);
	if (!target_addr
	    || (node->tries >= 0 && node->u.interfaces)
	    || (node->tries == -1
		&& node->u.alias->tries >= 0
		&& node->u.alias->u.interfaces)) {
	    if (show_names && (name = inet_name(node->addr)))
		printf("%s (%s):", addr, name);
	    else
		printf("%s:", addr);
	    if (node->tries < 0)
		printf(" alias for %s\n\n", inet_fmt(node->u.alias->addr, s1));
	    else if (!node->u.interfaces)
		printf(" no response to query\n\n");
	    else {
		Interface *ifc;

		if (node->version)
		    printf(" <v%d.%d>", node->version & 0xff,
					(node->version >> 8) & 0xff);
		printf("\n");
		for (ifc = node->u.interfaces; ifc; ifc = ifc->next) {
		    Neighbor *nb;
		    char *ifc_name = inet_fmt(ifc->addr, s1);
		    int ifc_len = strlen(ifc_name);
		    int count = 0;

		    printf("    %s:", ifc_name);
		    for (nb = ifc->neighbors; nb; nb = nb->next) {
			if (count > 0)
			    printf("%*s", ifc_len + 5, "");
			printf("  %s", inet_fmt(nb->addr, s1));
			if (show_names  &&  (name = inet_name(nb->addr)))
			    printf(" (%s)", name);
			printf(" [%d/%d", nb->metric, nb->threshold);
			if (nb->flags) {
			    u_short flags = nb->flags;
			    if (flags & DVMRP_NF_TUNNEL)
				    printf("/tunnel");
			    if (flags & DVMRP_NF_SRCRT)
				    printf("/srcrt");
			    if (flags & DVMRP_NF_QUERIER)
				    printf("/querier");
			    if (flags & DVMRP_NF_DISABLED)
				    printf("/disabled");
			    if (flags & DVMRP_NF_DOWN)
				    printf("/down");
			}
                        printf("]\n");
			count++;
		    }
		}
		printf("\n");
	    }
	}
	print_map(node->right);
    }
}


char *graph_name(u_int32_t addr, char *buf, size_t len)
{
    char *name;

    if (show_names  &&  (name = inet_name(addr)))
	strlcpy(buf, name, len);
    else
	inet_fmt(addr, buf);

    return buf;
}


void graph_edges(Node *node)
{
    Interface *ifc;
    Neighbor *nb;
    char name[HOST_NAME_MAX+1];

    if (node) {
	graph_edges(node->left);
	if (node->tries >= 0) {
	    printf("  %d {$ NP %d0 %d0 $} \"%s%s\" \n",
		   (int) node->addr,
		   node->addr & 0xFF, (node->addr >> 8) & 0xFF,
		   graph_name(node->addr, name, sizeof(name)),
		   node->u.interfaces ? "" : "*");
	    for (ifc = node->u.interfaces; ifc; ifc = ifc->next)
		for (nb = ifc->neighbors; nb; nb = nb->next) {
		    Node *nb_node = find_node(nb->addr, &routers);
		    Neighbor *nb2;

		    if (nb_node->tries < 0)
			nb_node = nb_node->u.alias;

		    if (node != nb_node &&
			(!(nb2 = find_neighbor(node->addr, nb_node))
			 || node->addr < nb_node->addr)) {
			printf("    %d \"%d/%d",
			       nb_node->addr, nb->metric, nb->threshold);
			if (nb2 && (nb2->metric != nb->metric
				    || nb2->threshold != nb->threshold))
			    printf(",%d/%d", nb2->metric, nb2->threshold);
			if (nb->flags & NF_PRESENT)
			    printf("%s%s",
				   nb->flags & DVMRP_NF_SRCRT ? "" :
				   nb->flags & DVMRP_NF_TUNNEL ? "E" : "P",
				   nb->flags & DVMRP_NF_DOWN ? "D" : "");
			printf("\"\n");
		    }
		}
	    printf("    ;\n");
	}
	graph_edges(node->right);
    }
}

void elide_aliases(Node *node)
{
    if (node) {
	elide_aliases(node->left);
	if (node->tries >= 0) {
	    Interface *ifc;

	    for (ifc = node->u.interfaces; ifc; ifc = ifc->next) {
		Neighbor *nb;

		for (nb = ifc->neighbors; nb; nb = nb->next) {
		    Node *nb_node = find_node(nb->addr, &routers);

		    if (nb_node->tries < 0)
			nb->addr = nb_node->u.alias->addr;
		}
	    }
	}
	elide_aliases(node->right);
    }
}

void graph_map(void)
{
    time_t now = time(0);
    char *nowstr = ctime(&now);

    nowstr[24] = '\0';		/* Kill the newline at the end */
    elide_aliases(routers);
    printf("GRAPH \"Multicast Router Connectivity: %s\" = UNDIRECTED\n",
	   nowstr);
    graph_edges(routers);
    printf("END\n");
}


u_int32_t host_addr(char *name)
{
    struct hostent *e = gethostbyname(name);
    int addr;

    if (e)
	memcpy(&addr, e->h_addr_list[0], e->h_length);
    else {
	addr = inet_addr(name);
	if (addr == -1)
	    addr = 0;
    }

    return addr;
}

void usage(void)
{
    extern char *__progname;

    fprintf(stderr,
	    "usage: %s [-fgn] [-d level] [-r count] [-t seconds] "
	    "[starting_router]\n\n", __progname);
    fprintf(stderr, "\t-f  Flood the routing graph with queries\n");
    fprintf(stderr, "\t    (True by default unless `router' is given)\n");
    fprintf(stderr, "\t-g  Generate output in GraphEd format\n");
    fprintf(stderr, "\t-n  Don't look up DNS names for routers\n");

    exit(1);
}

int main(int argc, char *argv[])
{
    int flood = FALSE, graph = FALSE;
    int ch;
    const char *errstr;
    
    if (geteuid() != 0) {
      fprintf(stderr, "map-mbone: must be root\n");
      exit(1);
    }

    init_igmp();
    setuid(getuid());

    setvbuf(stderr, NULL, _IOLBF, 0);

    while ((ch = getopt(argc, argv, "d::fgnr:t:")) != -1) {
	    switch (ch) {
	    case 'd':
		    if (!optarg)
			    debug = DEFAULT_DEBUG;
		    else {
			    debug = strtonum(optarg, 0, 3, &errstr);
			    if (errstr) {
				    warnx("debug level %s", errstr);
				    debug = DEFAULT_DEBUG;
			    }
		    }
		    break;
	    case 'f':
		    flood = TRUE;
		    break;
	    case 'g':
		    graph = TRUE;
		    break;
	    case 'n':
		    show_names = FALSE;
		    break;
	    case 'r':
		    retries = strtonum(optarg, 0, INT_MAX, &errstr);
		    if (errstr) {
			    warnx("retries %s", errstr);
			    usage();
		    }
		    break;
	    case 't':
		    timeout = strtonum(optarg, 0, INT_MAX, &errstr);
		    if (errstr) {
			    warnx("timeout %s", errstr);
			    usage();
		    }
		    break;
	    default:
		    usage();
	    }
    }
    argc -= optind;
    argv += optind;
    
    if (argc > 1)
	usage();
    else if (argc == 1 && !(target_addr = host_addr(argv[0]))) {
	fprintf(stderr, "Unknown host: %s\n", argv[0]);
	exit(2);
    }

    if (debug)
	fprintf(stderr, "Debug level %u\n", debug);

    {				/* Find a good local address for us. */
	int udp;
	struct sockaddr_in addr;
	int addrlen = sizeof(addr);

	memset(&addr, 0, sizeof addr);
	addr.sin_family = AF_INET;
	addr.sin_len = sizeof addr;
	addr.sin_addr.s_addr = dvmrp_group;
	addr.sin_port = htons(2000); /* any port over 1024 will do... */
	if ((udp = socket(AF_INET, SOCK_DGRAM, 0)) < 0
	    || connect(udp, (struct sockaddr *) &addr, sizeof(addr)) < 0
	    || getsockname(udp, (struct sockaddr *) &addr, &addrlen) < 0) {
	    perror("Determining local address");
	    exit(1);
	}
	close(udp);
	our_addr = addr.sin_addr.s_addr;
    }

    /* Send initial seed message to all local routers */
    ask(target_addr ? target_addr : allhosts_group);

    if (target_addr) {
	Node *n = find_node(target_addr, &routers);

	n->tries = 1;

	if (flood)
	    target_addr = 0;
    }

    /* Main receive loop */
    for(;;) {
	struct pollfd	pfd[1];
	int 		count, recvlen, dummy = 0;

	pfd[0].fd = igmp_socket;
	pfd[0].events = POLLIN;

	count = poll(pfd, 1, timeout * 1000);

	if (count < 0) {
	    if (errno != EINTR)
		perror("select");
	    continue;
	} else if (count == 0) {
	    logit(LOG_DEBUG, 0, "Timed out receiving neighbor lists");
	    if (retry_requests(routers))
		continue;
	    else
		break;
	}

	recvlen = recvfrom(igmp_socket, recv_buf, RECV_BUF_SIZE,
			   0, NULL, &dummy);
	if (recvlen >= 0)
	    accept_igmp(recvlen);
	else if (errno != EINTR)
	    perror("recvfrom");
    }

    printf("\n");

    if (graph)
	graph_map();
    else {
	if (!target_addr)
	    printf("Multicast Router Connectivity:\n\n");
	print_map(routers);
    }

    exit(0);
}

/* dummies */
void accept_prune(u_int32_t src, u_int32_t dst, char *p, int datalen)
{
}

void accept_graft(u_int32_t src, u_int32_t dst, char *p, int datalen)
{
}

void accept_g_ack(u_int32_t src, u_int32_t dst, char *p, int datalen)
{
}

void add_table_entry(u_int32_t origin, u_int32_t mcastgrp)
{
}

void accept_leave_message(u_int32_t src, u_int32_t dst, u_int32_t group)
{
}

void accept_mtrace(u_int32_t src, u_int32_t dst, u_int32_t group, char *data,
    u_int no, int datalen)
{
}

void accept_membership_query(u_int32_t src, u_int32_t dst, u_int32_t group,
    int tmo)
{
}

void accept_info_request(u_int32_t src, u_int32_t dst, u_char *p, int datalen)
{
}

void accept_info_reply(u_int32_t src, u_int32_t dst, u_char *p, int datalen)
{
}
@


1.23
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: mapper.c,v 1.22 2015/01/16 06:40:18 deraadt Exp $	*/
d498 1
a498 1
				|| nb_i->threshold != nb_i->threshold)
@


1.22
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mapper.c,v 1.21 2014/11/26 18:34:51 millert Exp $	*/
d111 1
a111 1
	*ptr = n = (Node *) malloc(sizeof(Node));
d135 1
a135 1
    ifc = (Interface *) malloc(sizeof(Interface));
d409 1
a409 1
	    nb = (Neighbor *) malloc(sizeof(Neighbor));
d553 1
a553 1
	    nb = (Neighbor *) malloc(sizeof(Neighbor));
@


1.21
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mapper.c,v 1.20 2011/09/21 18:48:43 jsg Exp $	*/
d45 1
d693 1
a693 1
    char name[MAXHOSTNAMELEN];
a875 1
#if (defined(BSD) && (BSD >= 199103))
a876 1
#endif
@


1.20
log
@include err.h for warnx
@
text
@d1 1
a1 1
/*	$OpenBSD: mapper.c,v 1.19 2007/02/18 20:57:53 jmc Exp $	*/
d813 1
a813 1
    setlinebuf(stderr);
@


1.19
log
@tidy up synopsis and usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: mapper.c,v 1.18 2005/06/22 14:50:21 robert Exp $	*/
d45 1
@


1.18
log
@implement and use a real usage(); function instead of using goto usage;
every time it is needed.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mapper.c,v 1.17 2005/06/20 14:42:57 robert Exp $	*/
d788 2
a789 2
	    "Usage: %s [-f] [-g] [-n] [-t timeout] [-r retries] "
	    "[-d [debug-level]] [router]\n\n", __progname);
@


1.17
log
@use getopt(3) for argument list parsing and remove the get_number()
function becasue we use strtonum(3) from now on.

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mapper.c,v 1.16 2004/08/01 18:32:19 deraadt Exp $	*/
d102 1
a102 1

d783 14
d840 1
a840 1
			    goto usage;
d847 1
a847 1
			    goto usage;
d851 1
a851 1
		    goto usage;
d857 3
a859 11
    if (argc > 1) {
      usage:	
	fprintf(stderr,
		"Usage: map-mbone [-f] [-g] [-n] [-t timeout] %s\n\n",
		"[-r retries] [-d [debug-level]] [router]");
        fprintf(stderr, "\t-f  Flood the routing graph with queries\n");
        fprintf(stderr, "\t    (True by default unless `router' is given)\n");
        fprintf(stderr, "\t-g  Generate output in GraphEd format\n");
        fprintf(stderr, "\t-n  Don't look up DNS names for routers\n");
	exit(1);
    } else if (argc == 1 && !(target_addr = host_addr(argv[0]))) {
@


1.16
log
@ansi cleanup; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
a100 2
int			get_number(int *var, int deflt, char ***pargv,
			    int *pargc);
a766 23
int get_number(int *var, int deflt, char ***pargv, int *pargc)
{
    if ((*pargv)[0][2] == '\0') { /* Get the value from the next argument */
	if (*pargc > 1  &&  isdigit((*pargv)[1][0])) {
	    (*pargv)++, (*pargc)--;
	    *var = atoi((*pargv)[0]);
	    return 1;
	} else if (deflt >= 0) {
	    *var = deflt;
	    return 1;
	} else
	    return 0;
    } else {			/* Get value from the rest of this argument */
	if (isdigit((*pargv)[0][2])) {
	    *var = atoi((*pargv)[0] + 2);
	    return 1;
	} else {
	    return 0;
	}
    }
}


d787 2
d800 39
a838 28
    argv++, argc--;
    while (argc > 0 && argv[0][0] == '-') {
	switch (argv[0][1]) {
	  case 'd':
	    if (!get_number(&debug, DEFAULT_DEBUG, &argv, &argc))
		goto usage;
	    break;
	  case 'f':
	    flood = TRUE;
	    break;
	  case 'g':
	    graph = TRUE;
	    break;
	  case 'n':
	    show_names = FALSE;
	    break;
	  case 'r':
	    if (!get_number(&retries, -1, &argv, &argc))
		goto usage;
	    break;
	  case 't':
	    if (!get_number(&timeout, -1, &argv, &argc))
		goto usage;
	    break;
	  default:
	    goto usage;
	}
	argv++, argc--;
d840 3
a842 1

@


1.15
log
@Replace log() with logit() since ISO C reserves log() for the math
library and gcc 3.x will complain.  Replacement name taken from NetBSD.
espie@@ OK.
@
text
@d1 1
d106 1
a106 3
Node *find_node(addr, ptr)
    u_int32_t addr;
    Node **ptr;
d127 1
a127 3
Interface *find_interface(addr, node)
    u_int32_t addr;
    Node *node;
d145 1
a145 3
Neighbor *find_neighbor(addr, node)
    u_int32_t addr;
    Node *node;
d200 1
a200 2
void ask(dst)
    u_int32_t dst;
d206 1
a206 2
void ask2(dst)
    u_int32_t dst;
d216 2
a217 3
void accept_group_report(src, dst, group, r_type)
    u_int32_t src, dst, group;
    int r_type;
d227 2
a228 4
void accept_probe(src, dst, p, datalen, level)
    u_int32_t src, dst, level;
    char *p;
    int datalen;
d238 2
a239 4
void accept_report(src, dst, p, datalen, level)
    u_int32_t src, dst, level;
    char *p;
    int datalen;
d249 1
a249 2
void accept_neighbor_request(src, dst)
    u_int32_t src, dst;
d257 1
a257 2
void accept_neighbor_request2(src, dst)
    u_int32_t src, dst;
d269 2
a270 4
void accept_neighbors(src, dst, p, datalen, level)
    u_int32_t src, dst, level;
    u_char *p;
    int datalen;
d428 2
a429 4
void accept_neighbors2(src, dst, p, datalen, level)
    u_int32_t src, dst, level;
    u_char *p;
    int datalen;
d573 1
a573 1
void check_vif_state()
d579 1
a579 2
int retry_requests(node)
    Node *node;
d599 1
a599 2
char *inet_name(addr)
    u_int32_t addr;
d609 1
a609 2
void print_map(node)
    Node *node;
d676 1
a676 4
char *graph_name(addr, buf, len)
    u_int32_t addr;
    char *buf;
    size_t len;
d689 1
a689 2
void graph_edges(node)
    Node *node;
d733 1
a733 2
void elide_aliases(node)
    Node *node;
d755 1
a755 1
void graph_map()
d769 1
a769 3
int get_number(var, deflt, pargv, pargc)
    int *var, *pargc, deflt;
    char ***pargv;
d792 1
a792 2
u_int32_t host_addr(name)
    char *name;
d809 1
a809 3
int main(argc, argv)
    int argc;
    char *argv[];
d949 1
a949 4
void accept_prune(src, dst, p, datalen)
	u_int32_t src, dst;
	char *p;
	int datalen;
d952 2
a953 4
void accept_graft(src, dst, p, datalen)
	u_int32_t src, dst;
	char *p;
	int datalen;
d956 2
a957 4
void accept_g_ack(src, dst, p, datalen)
	u_int32_t src, dst;
	char *p;
	int datalen;
d960 2
a961 2
void add_table_entry(origin, mcastgrp)
	u_int32_t origin, mcastgrp;
d964 2
a965 2
void accept_leave_message(src, dst, group)
	u_int32_t src, dst, group;
d968 3
a970 5
void accept_mtrace(src, dst, group, data, no, datalen)
	u_int32_t src, dst, group;
	char *data;
	u_int no;
	int datalen;
d973 3
a975 3
void accept_membership_query(src, dst, group, tmo)
	u_int32_t src, dst, group;
	int tmo;
d978 2
a979 4
void accept_info_request(src, dst, p, datalen)
	u_int32_t src, dst;
	u_char *p;
	int datalen;
d982 2
a983 4
void accept_info_reply(src, dst, p, datalen)
	u_int32_t src, dst;
	u_char *p;
	int datalen;
@


1.14
log
@convert to poll; ok dhartmei
@
text
@d172 1
a172 1
log(int severity, int syserr, char *format, ...)
d227 1
a227 1
    log(LOG_INFO, 0, "ignoring IGMP group membership report from %s to %s",
d240 1
a240 1
    log(LOG_INFO, 0, "ignoring DVMRP probe from %s to %s",
d253 1
a253 1
    log(LOG_INFO, 0, "ignoring DVMRP routing report from %s to %s",
d265 1
a265 1
	log(LOG_INFO, 0,
d274 1
a274 1
	log(LOG_INFO, 0,
d329 1
a329 1
	    log(LOG_WARNING, 0, "received truncated interface record from %s",
d374 1
a374 1
				log(LOG_WARNING, 0,
d406 1
a406 1
		log(LOG_WARNING, 0, "received truncated neighbor list from %s",
d418 1
a418 1
			log(LOG_WARNING, 0,
d466 1
a466 1
	    log(LOG_WARNING, 0, "received truncated interface record from %s",
d517 1
a517 1
				log(LOG_WARNING, 0,
d549 1
a549 1
		log(LOG_WARNING, 0, "received truncated neighbor list from %s",
d564 1
a564 1
			log(LOG_WARNING, 0,
d593 1
a593 1
    log(LOG_NOTICE, 0, "network marked down...");
d951 1
a951 1
	    log(LOG_DEBUG, 0, "Timed out receiving neighbor lists");
@


1.13
log
@strlcpy, ok millert@@
@
text
@d43 1
d938 1
a938 2
	fd_set		fds;
	struct timeval 	tv;
d941 2
a942 4
	FD_ZERO(&fds);
	if (igmp_socket >= FD_SETSIZE)
	    log(LOG_ERR, 0, "descriptor too big");
	FD_SET(igmp_socket, &fds);
d944 1
a944 4
	tv.tv_sec = timeout;
	tv.tv_usec = 0;

	count = select(igmp_socket + 1, &fds, 0, 0, &tv);
@


1.12
log
@die if fd_set overruns.
@
text
@d184 1
a184 1
		strcat(fmt, "warning - ");
@


1.11
log
@missing sockaddr inits; ok itojun
@
text
@d942 2
@


1.10
log
@Fix possible buffer overflow in map-mbone's dns resolution; Jose Nazario
@
text
@d906 1
@


1.9
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d95 1
a95 1
char *			graph_name(u_int32_t addr, char *buf);
d696 1
a696 1
char *graph_name(addr, buf)
d699 1
d704 1
a704 1
	strcpy(buf, name);
d717 1
a717 1
    char name[100];
d725 1
a725 1
		   graph_name(node->addr, name),
@


1.8
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@a41 1
#ifdef __STDC__
a42 3
#else
#include <varargs.h>
#endif
a169 1
#ifdef __STDC__
d173 2
a174 17
	va_list ap;
	char    fmt[100];

	va_start(ap, format);
#else
/*VARARGS3*/
void 
log(severity, syserr, format, va_alist)
	int     severity, syserr;
	char   *format;
	va_dcl
{
	va_list ap;
	char    fmt[100];

	va_start(ap);
#endif
d181 1
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d103 3
a105 3
int			get_number __P((int *var, int deflt, char ***pargv,
						int *pargc));
u_int32_t			host_addr(char *name);
@


1.6
log
@make sure that va_start() has matching va_end()
@
text
@d90 13
a102 13
Node *			find_node __P((u_int32_t addr, Node **ptr));
Interface *		find_interface __P((u_int32_t addr, Node *node));
Neighbor *		find_neighbor __P((u_int32_t addr, Node *node));
int			main __P((int argc, char *argv[]));
void			ask __P((u_int32_t dst));
void			ask2 __P((u_int32_t dst));
int			retry_requests __P((Node *node));
char *			inet_name __P((u_int32_t addr));
void			print_map __P((Node *node));
char *			graph_name __P((u_int32_t addr, char *buf));
void			graph_edges __P((Node *node));
void			elide_aliases __P((Node *node));
void			graph_map __P((void));
d105 1
a105 1
u_int32_t			host_addr __P((char *name));
@


1.5
log
@New license from Xerox!  This code is now FREE!  Took a while and a lot of
mails, but it is worth it.
@
text
@d206 1
@


1.4
log
@exit(-#) is wrong
@
text
@d8 27
a34 14
 * Copyright (c) Xerox Corporation 1992. All rights reserved.
 *  
 * License is granted to copy, to use, and to make and to use derivative
 * works for research and evaluation purposes, provided that Xerox is
 * acknowledged in all documentation pertaining to any such copy or derivative
 * work. Xerox grants no other licenses expressed or implied. The Xerox trade
 * name should not be used in any advertising without its written permission.
 *  
 * XEROX CORPORATION MAKES NO REPRESENTATIONS CONCERNING EITHER THE
 * MERCHANTABILITY OF THIS SOFTWARE OR THE SUITABILITY OF THIS SOFTWARE
 * FOR ANY PARTICULAR PURPOSE.  The software is provided "as is" without
 * express or implied warranty of any kind.
 *  
 * These notices must be retained in any copies of any part of this software.
@


1.3
log
@revoke privs at start; tested by fenner@@parc.xerox.com
@
text
@d202 1
a202 1
	exit(-1);
d920 1
a920 1
	    exit(-1);
@


1.2
log
@from netbsd; update to mrouted 3.8
@
text
@a846 2
    setlinebuf(stderr);

d848 2
a849 2
	fprintf(stderr, "must be root\n");
	exit(1);
d852 5
a903 2

    init_igmp();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mapper.c,v 1.2 1995/10/03 23:16:56 thorpej Exp $	*/
d28 6
d77 17
d161 3
a163 4
void log(severity, syserr, format, a, b, c, d, e)
    int severity, syserr;
    char *format;
    int a, b, c, d, e;
d165 17
a181 1
    char fmt[100];
d192 1
a192 1
	    fprintf(stderr, fmt, a, b, c, d, e);
d227 1
a227 1
void accept_group_report(src, dst, group)
d229 1
d239 4
a242 2
void accept_probe(src, dst)
    u_int32_t src, dst;
d252 2
a253 2
void accept_report(src, dst, p, datalen)
    u_int32_t src, dst;
d304 2
a305 2
	node->version = ntohl(level);
	node->tries = 0;
d377 1
a377 1
				|| nb_i->threshold != nb_i->threshold)
d448 2
a449 2
void accept_neighbors2(src, dst, p, datalen)
    u_int32_t src, dst;
d454 2
d483 5
d547 1
a547 1
	while (ncount--) {
a846 3
#ifdef SYSV
    setvbuf(stderr, NULL, _IOLBF, 0);
#else
a847 1
#endif
d984 17
a1000 1
void accept_prune()
d1003 2
a1004 1
void accept_graft()
d1007 2
a1008 1
void accept_g_ack()
d1011 5
a1015 1
void add_table_entry()
d1018 3
a1020 1
void accept_leave_message()
d1023 4
a1026 1
void accept_mtrace()
d1029 4
a1032 1
void accept_membership_query()
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
