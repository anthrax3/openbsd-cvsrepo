head	1.61;
access;
symbols
	OPENBSD_6_2:1.61.0.2
	OPENBSD_6_2_BASE:1.61
	OPENBSD_6_1:1.61.0.4
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.59.0.4
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.52.0.8
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.52.0.4
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.52.0.2
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.51.0.4
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.2
	OPENBSD_5_0:1.49.0.6
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.4
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.46.0.8
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.46.0.4
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.46.0.2
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9;
locks; strict;
comment	@ * @;


1.61
date	2017.03.20.15.31.23;	author bluhm;	state Exp;
branches;
next	1.60;
commitid	MQUBTVsa3plEHpse;

1.60
date	2016.08.27.01.50.07;	author guenther;	state Exp;
branches;
next	1.59;
commitid	ikVlcUgcgDzn9GW3;

1.59
date	2015.12.12.20.04.23;	author mmcc;	state Exp;
branches;
next	1.58;
commitid	qUunq6kWElREuvSB;

1.58
date	2015.11.19.06.08.06;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	wWvaRIM4vn5h2sgc;

1.57
date	2015.11.19.06.06.30;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	rXHk9B5SStfALI3L;

1.56
date	2015.06.15.14.29.52;	author millert;	state Exp;
branches;
next	1.55;
commitid	HVxuTWeVOJUsbM8M;

1.55
date	2015.06.02.23.05.05;	author millert;	state Exp;
branches;
next	1.54;
commitid	wvRclsqHXfHQEnfH;

1.54
date	2015.01.16.06.40.20;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	Uu5nFG3wCl0LACBb;

1.53
date	2014.06.29.00.58.45;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	JPNyzoRAXfnuJx1K;

1.52
date	2012.09.20.20.11.58;	author yuo;	state Exp;
branches;
next	1.51;

1.51
date	2011.09.16.17.45.06;	author yuo;	state Exp;
branches;
next	1.50;

1.50
date	2011.09.16.15.44.31;	author yuo;	state Exp;
branches;
next	1.49;

1.49
date	2010.04.21.04.07.13;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2010.04.20.20.49.36;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2009.08.14.15.29.19;	author cnst;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.14.00.16.10;	author cnst;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.11.21.21.50;	author cnst;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.11.18.40.52;	author cnst;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.11.05.54.22;	author cnst;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.41;

1.41
date	2008.03.16.23.54.01;	author cnst;	state Exp;
branches;
next	1.40;

1.40
date	2008.03.16.03.07.03;	author cnst;	state Exp;
branches;
next	1.39;

1.39
date	2008.03.15.01.08.08;	author cnst;	state Exp;
branches;
next	1.38;

1.38
date	2008.03.14.00.06.18;	author ckuethe;	state Exp;
branches;
next	1.37;

1.37
date	2008.03.13.21.24.45;	author ckuethe;	state Exp;
branches;
next	1.36;

1.36
date	2007.12.05.17.28.06;	author cnst;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.28.17.03.59;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2007.08.14.17.10.02;	author cnst;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.01.22.41.12;	author cnst;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.30.07.49.37;	author cnst;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.29.20.30.40;	author cnst;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.29.02.02.12;	author cnst;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.28.15.28.22;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.23.22.55.40;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.06.18.17.06;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.12.23.17.49.53;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.18.14.13.15;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2006.09.16.10.46.26;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.23.11.18.00;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.01.20.09.13;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.20.15.19.03;	author dhill;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.06.21.32.20;	author moritz;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.31.18.13.39;	author moritz;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.04.13.01.43;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.03.17.30.05;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.03.12.31.28;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.21.00.22.28;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.20.21.08.45;	author hshoexer;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.01.22.15.40;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.01.22.10.23;	author hshoexer;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.14.23.24.41;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.11.20.02.00;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.15.15.53.19;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.07.16.50.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.08.09.18.00;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.22.12.59.45;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.01.02.43.17;	author kevlo;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.30.15.06.29;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.30.00.18.40;	author jose;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.29.16.05.34;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.24.20.32.49;	author henning;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Add command line option -f to specify alternative config file.
from Matthias Pitzl
@
text
@/*	$OpenBSD: sensorsd.c,v 1.60 2016/08/27 01:50:07 guenther Exp $ */

/*
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2005 Matthew Gream <matthew.gream@@pobox.com>
 * Copyright (c) 2006 Constantine A. Murenin <cnst+openbsd@@bugmail.mojo.ru>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/sysctl.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <sys/sensors.h>

#include <err.h>
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>

#define	RFBUFSIZ	28	/* buffer size for print_sensor */
#define	RFBUFCNT	4	/* ring buffers */
#define CHECK_PERIOD	20	/* check every n seconds */

enum sensorsd_s_status {
	SENSORSD_S_UNSPEC,	/* status is unspecified */
	SENSORSD_S_INVALID,	/* status is invalid, per SENSOR_FINVALID */
	SENSORSD_S_WITHIN,	/* status is within limits */
	SENSORSD_S_ABOVE,	/* status is above the higher limit */
	SENSORSD_S_BELOW	/* status is below the lower limit */
};

struct limits_t {
	TAILQ_ENTRY(limits_t)	entries;
	enum sensor_type	type;		/* sensor type */
	int			numt;		/* sensor number */
	int64_t			last_val;
	int64_t			lower;		/* lower limit */
	int64_t			upper;		/* upper limit */
	char			*command;	/* failure command */
	time_t			astatus_changed;
	time_t			ustatus_changed;
	enum sensor_status	astatus;	/* last automatic status */
	enum sensor_status	astatus2;
	enum sensorsd_s_status	ustatus;	/* last user-limit status */
	enum sensorsd_s_status	ustatus2;
	int			acount;		/* stat change counter */
	int			ucount;		/* stat change counter */
	u_int8_t		flags;		/* sensorsd limit flags */
#define SENSORSD_L_USERLIMIT		0x0001	/* user specified limit */
#define SENSORSD_L_ISTATUS		0x0002	/* ignore automatic status */
};

struct sdlim_t {
	TAILQ_ENTRY(sdlim_t)	entries;
	char			dxname[16];	/* device unix name */
	int			dev;		/* device number */
	int			sensor_cnt;
	TAILQ_HEAD(, limits_t)	limits;
};

void		 usage(void);
void		 create(void);
struct sdlim_t	*create_sdlim(struct sensordev *);
void		 destroy_sdlim(struct sdlim_t *);
void		 check(time_t);
void		 check_sdlim(struct sdlim_t *, time_t);
void		 execute(char *);
void		 report(time_t);
void		 report_sdlim(struct sdlim_t *, time_t);
static char	*print_sensor(enum sensor_type, int64_t);
void		 parse_config(char *);
void		 parse_config_sdlim(struct sdlim_t *, char *);
int64_t		 get_val(char *, int, enum sensor_type);
void		 reparse_cfg(int);

TAILQ_HEAD(sdlimhead_t, sdlim_t);
struct sdlimhead_t sdlims = TAILQ_HEAD_INITIALIZER(sdlims);

char			 *configfile;
volatile sig_atomic_t	  reload = 0;
int			  debug = 0;

void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-d] [-c check] [-f file]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	time_t		 last_report = 0, this_check;
	int		 ch, check_period = CHECK_PERIOD;
	const char	*errstr;

	if (pledge("stdio rpath proc exec", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "c:df:")) != -1) {
		switch (ch) {
		case 'c':
			check_period = strtonum(optarg, 1, 600, &errstr);
			if (errstr)
				errx(1, "check %s", errstr);
			break;
		case 'd':
			debug = 1;
			break;
		case 'f':
			configfile = optarg;
			if (access(configfile, R_OK) != 0)
				err(1, "access configuration file %s",
				    configfile);
			break;
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;
	if (argc > 0)
		usage();

	openlog("sensorsd", LOG_PID | LOG_NDELAY, LOG_DAEMON);

	create();

	if (configfile == NULL)
		if (asprintf(&configfile, "/etc/sensorsd.conf") == -1)
			err(1, "out of memory");
	parse_config(configfile);

	if (debug == 0 && daemon(0, 0) == -1)
		err(1, "unable to fork");

	signal(SIGHUP, reparse_cfg);
	signal(SIGCHLD, SIG_IGN);

	for (;;) {
		if (reload) {
			parse_config(configfile);
			syslog(LOG_INFO, "configuration reloaded");
			reload = 0;
		}
		this_check = time(NULL);
		if (!(last_report < this_check))
			this_check = last_report + 1;
		check(this_check);
		report(last_report);
		last_report = this_check;
		sleep(check_period);
	}
}

void
create(void)
{
	struct sensordev sensordev;
	struct sdlim_t	*sdlim;
	size_t		 sdlen = sizeof(sensordev);
	int		 mib[3], dev, sensor_cnt = 0;

	mib[0] = CTL_HW;
	mib[1] = HW_SENSORS;

	for (dev = 0; ; dev++) {
		mib[2] = dev;
		if (sysctl(mib, 3, &sensordev, &sdlen, NULL, 0) == -1) {
			if (errno == ENXIO)
				continue;
			if (errno == ENOENT)
				break;
			warn("sysctl");
		}
		sdlim = create_sdlim(&sensordev);
		TAILQ_INSERT_TAIL(&sdlims, sdlim, entries);
		sensor_cnt += sdlim->sensor_cnt;
	}

	syslog(LOG_INFO, "startup, system has %d sensors", sensor_cnt);
}

struct sdlim_t *
create_sdlim(struct sensordev *snsrdev)
{
	struct sensor	 sensor;
	struct sdlim_t	*sdlim;
	struct limits_t	*limit;
	size_t		 slen = sizeof(sensor);
	int		 mib[5], numt;
	enum sensor_type type;

	if ((sdlim = calloc(1, sizeof(struct sdlim_t))) == NULL)
		err(1, "calloc");

	strlcpy(sdlim->dxname, snsrdev->xname, sizeof(sdlim->dxname));

	mib[0] = CTL_HW;
	mib[1] = HW_SENSORS;
	mib[2] = sdlim->dev = snsrdev->num;

	TAILQ_INIT(&sdlim->limits);

	for (type = 0; type < SENSOR_MAX_TYPES; type++) {
		mib[3] = type;
		for (numt = 0; numt < snsrdev->maxnumt[type]; numt++) {
			mib[4] = numt;
			if (sysctl(mib, 5, &sensor, &slen, NULL, 0) == -1) {
				if (errno != ENOENT)
					warn("sysctl");
				continue;
			}
			if ((limit = calloc(1, sizeof(struct limits_t))) ==
			    NULL)
				err(1, "calloc");
			limit->type = type;
			limit->numt = numt;
			TAILQ_INSERT_TAIL(&sdlim->limits, limit, entries);
			sdlim->sensor_cnt++;
		}
	}

	return (sdlim);
}

void
destroy_sdlim(struct sdlim_t *sdlim)
{
	struct limits_t		*limit;

	while ((limit = TAILQ_FIRST(&sdlim->limits)) != NULL) {
		TAILQ_REMOVE(&sdlim->limits, limit, entries);
		free(limit->command);
		free(limit);
	}
	free(sdlim);
}

void
check(time_t this_check)
{
	struct sensordev	 sensordev;
	struct sdlim_t		*sdlim, *next;
	int			 mib[3];
	int			 h, t, i;
	size_t			 sdlen = sizeof(sensordev);

	if (TAILQ_EMPTY(&sdlims)) {
		h = 0;
		t = -1;
	} else {
		h = TAILQ_FIRST(&sdlims)->dev;
		t = TAILQ_LAST(&sdlims, sdlimhead_t)->dev;
	}
	sdlim = TAILQ_FIRST(&sdlims);

	mib[0] = CTL_HW;
	mib[1] = HW_SENSORS;
	/* look ahead for 4 more sensordevs */
	for (i = h; i <= t + 4; i++) {
		if (sdlim != NULL && i > sdlim->dev)
			sdlim = TAILQ_NEXT(sdlim, entries);
		if (sdlim == NULL && i <= t)
			syslog(LOG_ALERT, "inconsistent sdlim logic");
		mib[2] = i;
		if (sysctl(mib, 3, &sensordev, &sdlen, NULL, 0) == -1) {
			if (errno != ENOENT)
				warn("sysctl");
			if (sdlim != NULL && i == sdlim->dev) {
				next = TAILQ_NEXT(sdlim, entries);
				TAILQ_REMOVE(&sdlims, sdlim, entries);
				syslog(LOG_INFO, "%s has disappeared",
				    sdlim->dxname);
				destroy_sdlim(sdlim);
				sdlim = next;
			}
			continue;
		}
		if (sdlim != NULL && i == sdlim->dev) {
			if (strcmp(sdlim->dxname, sensordev.xname) == 0) {
				check_sdlim(sdlim, this_check);
				continue;
			} else {
				next = TAILQ_NEXT(sdlim, entries);
				TAILQ_REMOVE(&sdlims, sdlim, entries);
				syslog(LOG_INFO, "%s has been replaced",
				    sdlim->dxname);
				destroy_sdlim(sdlim);
				sdlim = next;
			}
		}
		next = create_sdlim(&sensordev);
		/* inserting next before sdlim */
		if (sdlim != NULL)
			TAILQ_INSERT_BEFORE(sdlim, next, entries);
		else
			TAILQ_INSERT_TAIL(&sdlims, next, entries);
		syslog(LOG_INFO, "%s has appeared", next->dxname);
		sdlim = next;
		parse_config_sdlim(sdlim, configfile);
		check_sdlim(sdlim, this_check);
	}

	if (TAILQ_EMPTY(&sdlims))
		return;
	/* Ensure that our queue is consistent. */
	for (sdlim = TAILQ_FIRST(&sdlims);
	    (next = TAILQ_NEXT(sdlim, entries)) != NULL;
	    sdlim = next)
		if (sdlim->dev > next->dev)
			syslog(LOG_ALERT, "inconsistent sdlims queue");
}

void
check_sdlim(struct sdlim_t *sdlim, time_t this_check)
{
	struct sensor		 sensor;
	struct limits_t		*limit;
	size_t		 	 len;
	int		 	 mib[5];

	mib[0] = CTL_HW;
	mib[1] = HW_SENSORS;
	mib[2] = sdlim->dev;
	len = sizeof(sensor);

	TAILQ_FOREACH(limit, &sdlim->limits, entries) {
		if ((limit->flags & SENSORSD_L_ISTATUS) &&
		    !(limit->flags & SENSORSD_L_USERLIMIT))
			continue;

		mib[3] = limit->type;
		mib[4] = limit->numt;
		if (sysctl(mib, 5, &sensor, &len, NULL, 0) == -1)
			err(1, "sysctl");

		if (!(limit->flags & SENSORSD_L_ISTATUS)) {
			enum sensor_status	newastatus = sensor.status;

			if (limit->astatus != newastatus) {
				if (limit->astatus2 != newastatus) {
					limit->astatus2 = newastatus;
					limit->acount = 0;
				} else if (++limit->acount >= 3) {
					limit->last_val = sensor.value;
					limit->astatus2 =
					    limit->astatus = newastatus;
					limit->astatus_changed = this_check;
				}
			}
		}

		if (limit->flags & SENSORSD_L_USERLIMIT) {
			enum sensorsd_s_status 	 newustatus;

			if (sensor.flags & SENSOR_FINVALID)
				newustatus = SENSORSD_S_INVALID;
			else if (sensor.value > limit->upper)
				newustatus = SENSORSD_S_ABOVE;
			else if (sensor.value < limit->lower)
				newustatus = SENSORSD_S_BELOW;
			else
				newustatus = SENSORSD_S_WITHIN;

			if (limit->ustatus != newustatus) {
				if (limit->ustatus2 != newustatus) {
					limit->ustatus2 = newustatus;
					limit->ucount = 0;
				} else if (++limit->ucount >= 3) {
					limit->last_val = sensor.value;
					limit->ustatus2 =
					    limit->ustatus = newustatus;
					limit->ustatus_changed = this_check;
				}
			}
		}
	}
}

void
execute(char *command)
{
	char *argp[] = {"sh", "-c", command, NULL};

	switch (fork()) {
	case -1:
		syslog(LOG_CRIT, "execute: fork() failed");
		break;
	case 0:
		execv("/bin/sh", argp);
		_exit(1);
		/* NOTREACHED */
	default:
		break;
	}
}

void
report(time_t last_report)
{
	struct sdlim_t	*sdlim;

	TAILQ_FOREACH(sdlim, &sdlims, entries)
		report_sdlim(sdlim, last_report);
}

void
report_sdlim(struct sdlim_t *sdlim, time_t last_report)
{
	struct limits_t	*limit;

	TAILQ_FOREACH(limit, &sdlim->limits, entries) {
		if ((limit->astatus_changed <= last_report) &&
		    (limit->ustatus_changed <= last_report))
			continue;

		if (limit->astatus_changed > last_report) {
			const char *as = NULL;

			switch (limit->astatus) {
			case SENSOR_S_UNSPEC:
				as = "";
				break;
			case SENSOR_S_OK:
				as = ", OK";
				break;
			case SENSOR_S_WARN:
				as = ", WARN";
				break;
			case SENSOR_S_CRIT:
				as = ", CRITICAL";
				break;
			case SENSOR_S_UNKNOWN:
				as = ", UNKNOWN";
				break;
			}
			syslog(limit->astatus == SENSOR_S_OK ? LOG_INFO :
			    LOG_ALERT, "%s.%s%d: %s%s",
			    sdlim->dxname, sensor_type_s[limit->type],
			    limit->numt,
			    print_sensor(limit->type, limit->last_val), as);
		}

		if (limit->ustatus_changed > last_report) {
			char us[BUFSIZ];

			switch (limit->ustatus) {
			case SENSORSD_S_UNSPEC:
				snprintf(us, sizeof(us),
				    "ustatus uninitialised");
				break;
			case SENSORSD_S_INVALID:
				snprintf(us, sizeof(us), "marked invalid");
				break;
			case SENSORSD_S_WITHIN:
				snprintf(us, sizeof(us),
				    "within limits: %s",
				    print_sensor(limit->type, limit->last_val));
				break;
			case SENSORSD_S_ABOVE:
				snprintf(us, sizeof(us),
				    "exceeds limits: %s is above %s",
				    print_sensor(limit->type, limit->last_val),
				    print_sensor(limit->type, limit->upper));
				break;
			case SENSORSD_S_BELOW:
				snprintf(us, sizeof(us),
				    "exceeds limits: %s is below %s",
				    print_sensor(limit->type, limit->last_val),
				    print_sensor(limit->type, limit->lower));
				break;
			}
			syslog(limit->ustatus == SENSORSD_S_WITHIN ? LOG_INFO :
			    LOG_ALERT, "%s.%s%d: %s",
			    sdlim->dxname, sensor_type_s[limit->type],
			    limit->numt, us);
		}

		if (limit->command) {
			int i = 0, n = 0, r;
			char *cmd = limit->command;
			char buf[BUFSIZ];
			int len = sizeof(buf);

			buf[0] = '\0';
			for (i = n = 0; n < len; ++i) {
				if (cmd[i] == '\0') {
					buf[n++] = '\0';
					break;
				}
				if (cmd[i] != '%') {
					buf[n++] = limit->command[i];
					continue;
				}
				i++;
				if (cmd[i] == '\0') {
					buf[n++] = '\0';
					break;
				}

				switch (cmd[i]) {
				case 'x':
					r = snprintf(&buf[n], len - n, "%s",
					    sdlim->dxname);
					break;
				case 't':
					r = snprintf(&buf[n], len - n, "%s",
					    sensor_type_s[limit->type]);
					break;
				case 'n':
					r = snprintf(&buf[n], len - n, "%d",
					    limit->numt);
					break;
				case 'l':
				{
					char *s = "";
					switch (limit->ustatus) {
					case SENSORSD_S_UNSPEC:
						s = "uninitialised";
						break;
					case SENSORSD_S_INVALID:
						s = "invalid";
						break;
					case SENSORSD_S_WITHIN:
						s = "within";
						break;
					case SENSORSD_S_ABOVE:
						s = "above";
						break;
					case SENSORSD_S_BELOW:
						s = "below";
						break;
					}
					r = snprintf(&buf[n], len - n, "%s",
					    s);
					break;
				}
				case 's':
				{
					char *s;
					switch (limit->astatus) {
					case SENSOR_S_UNSPEC:
						s = "UNSPEC";
						break;
					case SENSOR_S_OK:
						s = "OK";
						break;
					case SENSOR_S_WARN:
						s = "WARNING";
						break;
					case SENSOR_S_CRIT:
						s = "CRITICAL";
						break;
					default:
						s = "UNKNOWN";
					}
					r = snprintf(&buf[n], len - n, "%s",
					    s);
					break;
				}
				case '2':
					r = snprintf(&buf[n], len - n, "%s",
					    print_sensor(limit->type,
					    limit->last_val));
					break;
				case '3':
					r = snprintf(&buf[n], len - n, "%s",
					    print_sensor(limit->type,
					    limit->lower));
					break;
				case '4':
					r = snprintf(&buf[n], len - n, "%s",
					    print_sensor(limit->type,
					    limit->upper));
					break;
				default:
					r = snprintf(&buf[n], len - n, "%%%c",
					    cmd[i]);
					break;
				}
				if (r < 0 || (r >= len - n)) {
					syslog(LOG_CRIT, "could not parse "
					    "command");
					return;
				}
				if (r > 0)
					n += r;
			}
			if (buf[0])
				execute(buf);
		}
	}
}

const char *drvstat[] = {
	NULL, "empty", "ready", "powerup", "online", "idle", "active",
	"rebuild", "powerdown", "fail", "pfail"
};

static char *
print_sensor(enum sensor_type type, int64_t value)
{
	static char	 rfbuf[RFBUFCNT][RFBUFSIZ];	/* ring buffer */
	static int	 idx;
	char		*fbuf;

	fbuf = rfbuf[idx++];
	if (idx == RFBUFCNT)
		idx = 0;

	switch (type) {
	case SENSOR_TEMP:
		snprintf(fbuf, RFBUFSIZ, "%.2f degC",
		    (value - 273150000) / 1000000.0);
		break;
	case SENSOR_FANRPM:
		snprintf(fbuf, RFBUFSIZ, "%lld RPM", value);
		break;
	case SENSOR_VOLTS_DC:
		snprintf(fbuf, RFBUFSIZ, "%.2f V DC", value / 1000000.0);
		break;
	case SENSOR_VOLTS_AC:
		snprintf(fbuf, RFBUFSIZ, "%.2f V AC", value / 1000000.0);
		break;
	case SENSOR_WATTS:
		snprintf(fbuf, RFBUFSIZ, "%.2f W", value / 1000000.0);
		break;
	case SENSOR_AMPS:
		snprintf(fbuf, RFBUFSIZ, "%.2f A", value / 1000000.0);
		break;
	case SENSOR_WATTHOUR:
		snprintf(fbuf, RFBUFSIZ, "%.2f Wh", value / 1000000.0);
		break;
	case SENSOR_AMPHOUR:
		snprintf(fbuf, RFBUFSIZ, "%.2f Ah", value / 1000000.0);
		break;
	case SENSOR_INDICATOR:
		snprintf(fbuf, RFBUFSIZ, "%s", value? "On" : "Off");
		break;
	case SENSOR_INTEGER:
		snprintf(fbuf, RFBUFSIZ, "%lld", value);
		break;
	case SENSOR_PERCENT:
		snprintf(fbuf, RFBUFSIZ, "%.2f%%", value / 1000.0);
		break;
	case SENSOR_LUX:
		snprintf(fbuf, RFBUFSIZ, "%.2f lx", value / 1000000.0);
		break;
	case SENSOR_DRIVE:
		if (0 < value && value < sizeof(drvstat)/sizeof(drvstat[0]))
			snprintf(fbuf, RFBUFSIZ, "%s", drvstat[value]);
		else
			snprintf(fbuf, RFBUFSIZ, "%lld ???", value);
		break;
	case SENSOR_TIMEDELTA:
		snprintf(fbuf, RFBUFSIZ, "%.6f secs", value / 1000000000.0);
		break;
	case SENSOR_HUMIDITY:
		snprintf(fbuf, RFBUFSIZ, "%.2f%%", value / 1000.0);
		break;
	case SENSOR_FREQ:
		snprintf(fbuf, RFBUFSIZ, "%.2f Hz", value / 1000000.0);
		break;
	case SENSOR_ANGLE:
		snprintf(fbuf, RFBUFSIZ, "%lld", value);
		break;
	case SENSOR_DISTANCE:
		snprintf(fbuf, RFBUFSIZ, "%.2f mm", value / 1000.0);
		break;
	case SENSOR_PRESSURE:
		snprintf(fbuf, RFBUFSIZ, "%.2f Pa", value / 1000.0);
		break;
	case SENSOR_ACCEL:
		snprintf(fbuf, RFBUFSIZ, "%2.4f m/s^2", value / 1000000.0);
		break;
	default:
		snprintf(fbuf, RFBUFSIZ, "%lld ???", value);
	}

	return (fbuf);
}

void
parse_config(char *cf)
{
	struct sdlim_t	 *sdlim;

	TAILQ_FOREACH(sdlim, &sdlims, entries)
		parse_config_sdlim(sdlim, cf);
}

void
parse_config_sdlim(struct sdlim_t *sdlim, char *cf)
{
	struct limits_t	 *p;
	char		 *buf = NULL, *ebuf = NULL;
	char		  node[48];
	char		 *cfa[2];
	
	cfa[0] = cf;
	cfa[1] = NULL;

	TAILQ_FOREACH(p, &sdlim->limits, entries) {
		snprintf(node, sizeof(node), "hw.sensors.%s.%s%d",
		    sdlim->dxname, sensor_type_s[p->type], p->numt);
		p->flags = 0;
		if (cgetent(&buf, cfa, node) != 0)
			if (cgetent(&buf, cfa, sensor_type_s[p->type]) != 0)
				continue;
		if (cgetcap(buf, "istatus", ':'))
			p->flags |= SENSORSD_L_ISTATUS;
		if (cgetstr(buf, "low", &ebuf) < 0)
			ebuf = NULL;
		p->lower = get_val(ebuf, 0, p->type);
		if (cgetstr(buf, "high", &ebuf) < 0)
			ebuf = NULL;
		p->upper = get_val(ebuf, 1, p->type);
		if (cgetstr(buf, "command", &ebuf) < 0)
			ebuf = NULL;
		if (ebuf != NULL) {
			p->command = ebuf;
			ebuf = NULL;
		}
		free(buf);
		buf = NULL;
		if (p->lower != LLONG_MIN || p->upper != LLONG_MAX)
			p->flags |= SENSORSD_L_USERLIMIT;
	}
}

int64_t
get_val(char *buf, int upper, enum sensor_type type)
{
	double	 val;
	int64_t	 rval = 0;
	char	*p;

	if (buf == NULL) {
		if (upper)
			return (LLONG_MAX);
		else
			return (LLONG_MIN);
	}

	val = strtod(buf, &p);
	if (buf == p)
		err(1, "incorrect value: %s", buf);

	switch (type) {
	case SENSOR_TEMP:
		switch (*p) {
		case 'C':
			printf("C");
			rval = val * 1000 * 1000 + 273150000;
			break;
		case 'F':
			printf("F");
			rval = (val * 1000 * 1000 + 459670000) / 9 * 5;
			break;
		default:
			errx(1, "unknown unit %s for temp sensor", p);
		}
		break;
	case SENSOR_FANRPM:
		rval = val;
		break;
	case SENSOR_VOLTS_DC:
	case SENSOR_VOLTS_AC:
		if (*p != 'V')
			errx(1, "unknown unit %s for voltage sensor", p);
		rval = val * 1000 * 1000;
		break;
	case SENSOR_PERCENT:
		rval = val * 1000.0;
		break;
	case SENSOR_INDICATOR:
	case SENSOR_INTEGER:
	case SENSOR_DRIVE:
	case SENSOR_ANGLE:
		rval = val;
		break;
	case SENSOR_WATTS:
	case SENSOR_AMPS:
	case SENSOR_WATTHOUR:
	case SENSOR_AMPHOUR:
	case SENSOR_LUX:
	case SENSOR_FREQ:
	case SENSOR_ACCEL:
		rval = val * 1000 * 1000;
		break;
	case SENSOR_TIMEDELTA:
		rval = val * 1000 * 1000 * 1000;
		break;
	case SENSOR_HUMIDITY:
	case SENSOR_DISTANCE:
	case SENSOR_PRESSURE:
		rval = val * 1000.0;
		break;
	default:
		errx(1, "unsupported sensor type");
		/* not reached */
	}
	free(buf);
	return (rval);
}

/* ARGSUSED */
void
reparse_cfg(int signo)
{
	reload = 1;
}
@


1.60
log
@Pull in <sys/time.h> for struct timespec, timeval, or clockrate

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.59 2015/12/12 20:04:23 mmcc Exp $ */
d105 2
a106 1
	fprintf(stderr, "usage: %s [-d] [-c check]\n", __progname);
d120 1
a120 1
	while ((ch = getopt(argc, argv, "c:d")) != -1) {
d129 6
@


1.59
log
@Remove NULL-checks before free().
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.58 2015/11/19 06:08:06 deraadt Exp $ */
d24 1
@


1.58
log
@pledge "stdio rpath proc exec"
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.56 2015/06/15 14:29:52 millert Exp $ */
d247 1
a247 2
		if (limit->command != NULL)
			free(limit->command);
@


1.57
log
@KNF
@
text
@d115 3
@


1.56
log
@get_val() already frees the buffer passed to it so we don't need to
do it in the caller.
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.55 2015/06/02 23:05:05 millert Exp $ */
d242 1
a242 1
	while((limit = TAILQ_FIRST(&sdlim->limits)) != NULL) {
d468 2
a469 1
				snprintf(us, sizeof(us), "within limits: %s",
d473 2
a474 1
				snprintf(us, sizeof(us), "exceeds limits: %s is above %s",
d479 2
a480 1
				snprintf(us, sizeof(us), "exceeds limits: %s is below %s",
d529 1
a529 1
					switch(limit->ustatus){
d553 1
a553 1
					switch(limit->astatus){
d761 1
a761 1
	switch(type) {
d763 1
a763 1
		switch(*p) {
@


1.55
log
@Don't leak value returned by cgetstr().  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.54 2015/01/16 06:40:20 deraadt Exp $ */
a723 1
		free(ebuf);
a726 1
		free(ebuf);
@


1.54
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.53 2014/06/29 00:58:45 deraadt Exp $ */
d724 1
d728 1
d731 4
a734 2
		if (ebuf)
			asprintf(&(p->command), "%s", ebuf);
@


1.53
log
@If you want <sys/queue.h>, you need to include it.  Don't assume that
<sys/sysctl.h> will pull in the universe (I am working on breaking that
assumption in a gentle fashion)
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.52 2012/09/20 20:11:58 yuo Exp $ */
d21 1
a21 1
#include <sys/param.h>
d35 1
@


1.52
log
@add more sensor types to sensor framework.
 - Pressure (10^-3 Pa)
 - distance (10^-6 m)
 - acceleration (10^-6 m/s^2)

ok deraadt@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.51 2011/09/16 17:45:06 yuo Exp $ */
d23 1
@


1.51
log
@add lacked cases of sensors value, and fix orders.
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.50 2011/09/16 15:44:31 yuo Exp $ */
d674 9
d793 1
d800 2
@


1.50
log
@apply following changes to sensor framework:
- change accuracy of SENSOR_FREQ from Hz to muHz
- add SENSOR_VOLTS_AC entry to userland programs

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.49 2010/04/21 04:07:13 deraadt Exp $ */
d626 3
a631 3
	case SENSOR_VOLTS_DC:
		snprintf(fbuf, RFBUFSIZ, "%.2f V DC", value / 1000000.0);
		break;
d665 2
a666 2
	case SENSOR_ANGLE:
		snprintf(fbuf, RFBUFSIZ, "%lld", value);
d671 3
d764 1
d783 1
d788 3
@


1.49
log
@Add the "angle" sensor, measured in degrees; from Luis Pinto
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.48 2010/04/20 20:49:36 deraadt Exp $ */
d626 3
d667 3
@


1.48
log
@Get rid of MAXSENSORDEVICES.  Gaps in sensordev lists are now handled
by returning ENXIO instead of ENOENT, to essentially indicate hotplug
sensor that has gone away.  Accessing beyond the end of the sensordev
list still returns ENOENT, so that you can see there are no further devices.
ok kettenis oga
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.47 2009/08/14 15:29:19 cnst Exp $ */
d662 3
d765 1
@


1.47
log
@SENSOR_WATTS;  ok canacar deraadt kettenis henning
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.46 2008/06/14 00:16:10 cnst Exp $ */
d175 1
a175 1
	for (dev = 0; dev < MAXSENSORDEVICES; dev++) {
d178 5
a182 3
			if (errno != ENOENT)
				warn("sysctl");
			continue;
@


1.46
log
@When there are no sensors, don't run the hotplugging consistency check,
the logic of which assumes that there is at least one sdlim.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.45 2008/06/11 21:21:50 cnst Exp $ */
d627 3
d762 1
@


1.45
log
@When a hotplugged sensordev appears, load its configuration individually,
instead of reloading the configuration for all sensordevs.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.44 2008/06/11 18:40:52 cnst Exp $ */
d312 2
@


1.44
log
@* Remove the exit condition on no sensors at start-up, since we now support
  hotplugging.
* Factor out some code from main() into a new create() procedure, to save
  some memory and make the code tidier.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.43 2008/06/11 05:54:22 cnst Exp $ */
d87 1
a87 1
void		 parse_config_sdlim(struct sdlim_t *, char **);
d308 1
a308 2
		parse_config(configfile);
		syslog(LOG_INFO, "configuration reloaded");
a665 6
	char		**cfa;

	if ((cfa = calloc(2, sizeof(char *))) == NULL)
		err(1, "calloc");
	cfa[0] = cf;
	cfa[1] = NULL;
d668 1
a668 2
		parse_config_sdlim(sdlim, cfa);
	free(cfa);
d672 1
a672 1
parse_config_sdlim(struct sdlim_t *sdlim, char **cfa)
d677 4
@


1.43
log
@Support hotpluggable sensors (e.g. the post-4.2 ipmi0 created by the
deferred thread, as well as some timedelta sensors).

ok henning, ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.42 2008/05/12 19:15:02 pyr Exp $ */
d77 1
a108 3
	struct sensordev sensordev;
	struct sdlim_t	*sdlim;
	size_t		 sdlen = sizeof(sensordev);
d110 1
a110 3
	int		 mib[3], dev;
	int		 sensor_cnt = 0, ch;
	int		 check_period = CHECK_PERIOD;
d133 1
a133 2
	mib[0] = CTL_HW;
	mib[1] = HW_SENSORS;
d135 1
a135 16
	for (dev = 0; dev < MAXSENSORDEVICES; dev++) {
		mib[2] = dev;
		if (sysctl(mib, 3, &sensordev, &sdlen, NULL, 0) == -1) {
			if (errno != ENOENT)
				warn("sysctl");
			continue;
		}
		sdlim = create_sdlim(&sensordev);
		TAILQ_INSERT_TAIL(&sdlims, sdlim, entries);
		sensor_cnt += sdlim->sensor_cnt;
	}

	if (sensor_cnt == 0)
		errx(1, "no sensors found");

	openlog("sensorsd", LOG_PID | LOG_NDELAY, LOG_DAEMON);
a147 2
	syslog(LOG_INFO, "startup, system has %d sensors", sensor_cnt);

d162 26
@


1.42
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.41 2008/03/16 23:54:01 cnst Exp $ */
d78 1
d90 2
a91 1
TAILQ_HEAD(, sdlim_t) sdlims = TAILQ_HEAD_INITIALIZER(sdlims);
d230 14
d246 14
a259 1
	struct sdlim_t	*sdlim;
d261 45
a305 1
	TAILQ_FOREACH(sdlim, &sdlims, entries)
d307 8
@


1.41
log
@s/273.16/273.15/g, then refactor the formulae to ensure that the
double to int64_t conversions happen sooner rather than later

discussed with / ok by kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.40 2008/03/16 03:07:03 cnst Exp $ */
d129 5
@


1.40
log
@Reduce the number of unnecessary time(3)/gettimeofday(2) calls, and make sure
that the time always goes forward, so reports are neither duplicated nor lost.

Report state changes stabilised through dampening immediately, instead of delay-
ing them until the next reporting window; previously, it was common for check()
to lag one second behind report(), hence the initial report was delayed one
extra minute (this then reduces the number of sleep(3)/nanosleep(2) calls, too).

ok ckuethe;  some man-page suggestions jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.39 2008/03/15 01:08:08 cnst Exp $ */
d645 1
a645 1
			rval = (val + 273.16) * 1000 * 1000;
d649 1
a649 1
			rval = ((val - 32.0) / 9 * 5 + 273.16) * 1000 * 1000;
@


1.39
log
@explicitly report whether the lower or upper limit is exceeded; ok sthen@@ ckuethe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.38 2008/03/14 00:06:18 ckuethe Exp $ */
a36 1
#define REPORT_PERIOD	60	/* report every n seconds */
d78 2
a79 2
void		 check(void);
void		 check_sdlim(struct sdlim_t *);
d99 1
a99 1
	fprintf(stderr, "usage: %s [-d] [-c check] [-r report]\n", __progname);
d109 1
a109 1
	time_t		 next_report, last_report = 0, next_check;
d111 1
a111 1
	int		 sleeptime, sensor_cnt = 0, ch;
a112 1
	int		 report_period = REPORT_PERIOD;
d115 1
a115 1
	while ((ch = getopt(argc, argv, "c:dr:")) != -1) {
a124 5
		case 'r':
			report_period = strtonum(optarg, 1, 600, &errstr);
			if (errstr)
				errx(1, "report %s", errstr);
			break;
a162 2
	next_check = next_report = time(NULL);

d169 7
a175 15
		if (next_check <= time(NULL)) {
			check();
			next_check = time(NULL) + check_period;
		}
		if (next_report <= time(NULL)) {
			report(last_report);
			last_report = next_report;
			next_report = time(NULL) + report_period;
		}
		if (next_report < next_check)
			sleeptime = next_report - time(NULL);
		else
			sleeptime = next_check - time(NULL);
		if (sleeptime > 0)
			sleep(sleeptime);
d223 1
a223 1
check(void)
d228 1
a228 1
		check_sdlim(sdlim);
d232 1
a232 1
check_sdlim(struct sdlim_t *sdlim)
d265 1
a265 1
					limit->astatus_changed = time(NULL);
d290 1
a290 1
					limit->ustatus_changed = time(NULL);
@


1.38
log
@Add a "%l" token to signal whether a sensor value is in or out of bounds,
without regard for the specific value. It's a big heavy binary hammer...
ok & style feedback from cnst
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.37 2008/03/13 21:24:45 ckuethe Exp $ */
d44 2
a45 1
	SENSORSD_S_OUTSIDE	/* status is outside limits */
d292 4
a295 3
			else if (sensor.value > limit->upper ||
				sensor.value < limit->lower)
				newustatus = SENSORSD_S_OUTSIDE;
d393 9
a401 3
			case SENSORSD_S_OUTSIDE:
				snprintf(us, sizeof(us), "exceeds limits: %s",
				    print_sensor(limit->type, limit->last_val));
d458 5
a462 2
					case SENSORSD_S_OUTSIDE:
						s = "exceeds";
@


1.37
log
@Allow a program invoked on state change to receive sensor status. Perhaps
you might want to toggle an error light when a sensor is not OK. Perhaps
you might want to schedule a shutdown if a sensor is reporting bad news.
Now you can do this, and cancel that pending shutdown (or turn off the error
light) if the sensor decides all is well.

ok mbalmer (who came up with an almost identical diff months ago)
useful feedback and generally positive responses from deraadt, henning, msf
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.36 2007/12/05 17:28:06 cnst Exp $ */
d437 21
d479 1
a480 1
					break;
@


1.36
log
@log positive events ('OK', 'within') with LOG_INFO instead of LOG_ALERT;
partly spotted by bluhm@@ grunk@@;  ok grunk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.35 2007/11/28 17:03:59 tedu Exp $ */
d262 1
a262 1
		    !(limit->flags & SENSORSD_L_USERLIMIT)) 
d285 1
a285 1
	
d334 1
a334 1
 
d437 23
d582 1
a582 1
		snprintf(node, sizeof(node), "hw.sensors.%s.%s%d", 
@


1.35
log
@add options to specify the check and report intervals. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.34 2007/08/14 17:10:02 cnst Exp $ */
d369 2
a370 1
			syslog(LOG_ALERT, "%s.%s%d: %s%s",
d396 2
a397 1
			syslog(LOG_ALERT, "%s.%s%d: %s",
@


1.34
log
@sync printing w/ sysctl(8) and add missing sensor types to conf parser;
document how values are parsed in sensorsd.conf(5).

ok deraadt@@; man-page ok/help jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.33 2007/06/01 22:41:12 cnst Exp $ */
d99 1
a99 1
	fprintf(stderr, "usage: %s [-d]\n", __progname);
d112 3
d116 1
a116 1
	while ((ch = getopt(argc, argv, "d")) != -1) {
d118 5
d126 5
d179 1
a179 1
			next_check = time(NULL) + CHECK_PERIOD;
d184 1
a184 1
			next_report = time(NULL) + REPORT_PERIOD;
@


1.33
log
@Convert sensorsd to use two-level data-structures. This makes sensorsd be
more consistent with the current sensors framework, conserves some memory,
and will make it easier to implement hotplugging and other nifty features
in the future. This does not change any other functionality ATM.

OK henning@@, beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.32 2007/05/30 07:49:37 cnst Exp $ */
d486 6
d496 1
a496 1
		snprintf(fbuf, RFBUFSIZ, "%lld raw", value);
d505 1
a505 1
		if (0 < value && value < sizeof(drvstat)/sizeof(drvstat[0])) {
d507 6
a512 3
			break;
		}
		/* FALLTHROUGH */
d618 3
d623 3
@


1.32
log
@Major update to sensorsd.

Improves support for both 'smart' (those providing sensor status) and
'old-style' sensors.

Due to re-design, the following improvements are now present and many
flaws are now gone:


== for smart sensors ==

* automatically monitor all sensors that provide status by themselves,
  with the possibility to ignore certain individual sensors or sensors
  of certain type (appropriate template for sensorsd.conf is included)

* report actual sensor status as provided by the driver. Previously,
  WARN, CRITICAL and UNKNOWN statuses were considered the same, but
  now they are different and will be reported separately. This also
  improves readability of the log-files and consistency with sysctl
  output.

* ability to ignore status provided by the driver with the 'istatus'
  keyword ("ignore automatic status" or "I set the status"), with the
  possibility to set your own settings for acceptable limits.
  Previously, it was not possible to set any kind of user limits for
  those sensors that had their own status facilities.


== for old-style sensors ==

* previously, lm(4)-style fans that were flagged SENSOR_FINVALID during
  sensorsd startup were completely ignored, but now their invalid status
  is appropriately reported, and they are monitored again when they come
  out of their invalid mode

* previously, a sensor that had an empty entry in the configuration file
  was reported to be "within limits", but now it will not be monitored
  at all (unless, of cause, it provides its own status)


As a bonus, sensorsd syslog entries should now be shorter, and the
majority of them will fit on one line on 80-column terminals.


ok beck@@, henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.31 2007/05/29 20:30:40 cnst Exp $ */
a39 9
void		 usage(void);
void		 check_sensors(void);
void		 execute(char *);
void		 report(time_t);
static char	*print_sensor(enum sensor_type, int64_t);
void		 parse_config(char *);
int64_t		 get_val(char *, int, enum sensor_type);
void		 reparse_cfg(int);

a48 2
	char			dxname[16];	/* device unix name */
	int			dev;		/* device number */
d68 22
a89 1
TAILQ_HEAD(limits, limits_t) limits = TAILQ_HEAD_INITIALIZER(limits);
a105 1
	struct sensor	 sensor;
d107 2
a108 2
	struct limits_t	*limit;
	size_t		 slen, sdlen;
d110 2
a111 3
	int		 mib[5], dev, numt;
	enum sensor_type type;
	int		 sleeptime, sensor_cnt, ch;
a124 2
	slen = sizeof(sensor);
	sdlen = sizeof(sensordev);
a125 1
	sensor_cnt = 0;
d133 3
a135 22
		for (type = 0; type < SENSOR_MAX_TYPES; type++) {
			mib[3] = type;
			for (numt = 0; numt < sensordev.maxnumt[type]; numt++) {
				mib[4] = numt;
				if (sysctl(mib, 5, &sensor, &slen, NULL, 0)
				    == -1) {
					if (errno != ENOENT)
						warn("sysctl");
					continue;
				}
				if ((limit = calloc(1, sizeof(struct limits_t)))
				    == NULL)
					err(1, "calloc");
				strlcpy(limit->dxname, sensordev.xname,
				    sizeof(limit->dxname));
				limit->dev = dev;
				limit->type = type;
				limit->numt = numt;
				TAILQ_INSERT_TAIL(&limits, limit, entries);
				sensor_cnt++;
			}
		}
d165 1
a165 1
			check_sensors();
d182 52
d235 1
a235 1
check_sensors(void)
d244 1
d247 1
a247 1
	TAILQ_FOREACH(limit, &limits, entries) {
a251 1
		mib[2] = limit->dev;
d320 5
a324 1
	struct limits_t	*limit = NULL;
d326 6
a331 1
	TAILQ_FOREACH(limit, &limits, entries) {
d357 1
a357 1
			    limit->dxname, sensor_type_s[limit->type],
d383 1
a383 1
			    limit->dxname, sensor_type_s[limit->type],
d412 1
a412 1
					    limit->dxname);
d514 1
a514 3
	struct limits_t	 *p, *next;
	char		 *buf = NULL, *ebuf = NULL;
	char		  node[48];
d522 13
a534 2
	for (p = TAILQ_FIRST(&limits); p != NULL; p = next) {
		next = TAILQ_NEXT(p, entries);
d536 1
a536 1
		    p->dxname, sensor_type_s[p->type], p->numt);
a557 1
	free(cfa);
@


1.31
log
@Remove watch_cnt in preparation for my bigger patch that makes sensorsd
usable by default, where we will monitor all sensors that automatically
provide status, and this watch_cnt won't make much sense. Besides, upon
startup, sensorsd already shows all sensors that it is going to monitor,
making this watch_cnt rather unimportant.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.30 2007/05/29 02:02:12 cnst Exp $ */
d49 7
d66 11
a76 5
	time_t			status_changed;
	enum sensor_status	status;		/* last status */
	enum sensor_status	status2;
	int			count;		/* stat change counter */
	u_int8_t		watch;
a137 2
				if (sensor.flags & SENSOR_FINVALID)
					continue;
a202 1
	enum sensor_status 	 newstatus;
d208 24
a231 19
	TAILQ_FOREACH(limit, &limits, entries)
		if (limit->watch) {
			mib[2] = limit->dev;
			mib[3] = limit->type;
			mib[4] = limit->numt;
			if (sysctl(mib, 5, &sensor, &len, NULL, 0) == -1)
				err(1, "sysctl");

			newstatus = sensor.status;
			/* unknown may as well mean producing valid
			 * status had failed so warn about it */
			if (newstatus == SENSOR_S_UNKNOWN)
				newstatus = SENSOR_S_WARN;
			else if (newstatus == SENSOR_S_UNSPEC) {
				if (sensor.value > limit->upper ||
				    sensor.value < limit->lower)
					newstatus = SENSOR_S_CRIT;
				else
					newstatus = SENSOR_S_OK;
d233 18
a250 6

			if (limit->status != newstatus) {
				if (limit->status2 != newstatus) {
					limit->status2 = newstatus;
					limit->count = 0;
				} else if (++limit->count >= 3) {
d252 3
a254 3
					limit->status2 =
					    limit->status = newstatus;
					limit->status_changed = time(NULL);
d258 1
d285 2
a286 1
		if (limit->status_changed <= last_report)
d289 51
a339 4
		syslog(LOG_ALERT, "hw.sensors.%s.%s%d: %s limits, value: %s",
		    limit->dxname, sensor_type_s[limit->type], limit->numt,
		    (limit->status != SENSOR_S_OK) ? "exceed" : "within",
		    print_sensor(limit->type, limit->last_val));
d481 1
d483 1
a483 2
			if (cgetent(&buf, cfa, sensor_type_s[p->type]) != 0) {
				p->watch = 0;
d485 2
a486 2
			}
		p->watch = 1;
d499 2
@


1.30
log
@for sensorsd.conf entries, let's do matching by sensor type if maching by complete sysctl name does not yield anything;  ok henning, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.29 2007/02/28 15:28:22 henning Exp $ */
d45 1
a45 1
int		 parse_config(char *);
d90 1
a90 1
	int		 sleeptime, sensor_cnt, watch_cnt, ch;
d149 1
a149 5
	if ((watch_cnt = parse_config(configfile)) == -1)
		errx(1, "error in config file");

	if (watch_cnt == 0)
		errx(1, "no watches defined");
d157 1
a157 2
	syslog(LOG_INFO, "startup, %d watches for %d sensors",
	    watch_cnt, sensor_cnt);
d163 2
a164 7
			if ((watch_cnt = parse_config(configfile)) == -1)
				syslog(LOG_CRIT, "error in config file %s",
				    configfile);
			else
				syslog(LOG_INFO,
				    "configuration reloaded, %d watches",
				    watch_cnt);
d388 1
a388 1
int
a394 1
	int		  watch_cnt = 0;
a410 1
		watch_cnt++;
a424 1
	return (watch_cnt);
@


1.29
log
@do status dampening for OK status as well, i. e.
if a sensor is always bad, but sometimes goes OK for only a few seconds,
we want to ignore that bogus change as well
also fix setting if last_val.
from Constantine, ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.28 2007/02/23 22:55:40 deraadt Exp $ */
d417 18
a434 17
			p->watch = 0;
		else {
			p->watch = 1;
			watch_cnt++;
			if (cgetstr(buf, "low", &ebuf) < 0)
				ebuf = NULL;
			p->lower = get_val(ebuf, 0, p->type);
			if (cgetstr(buf, "high", &ebuf) < 0)
				ebuf = NULL;
			p->upper = get_val(ebuf, 1, p->type);
			if (cgetstr(buf, "command", &ebuf) < 0)
				ebuf = NULL;
			if (ebuf)
				asprintf(&(p->command), "%s", ebuf);
			free(buf);
			buf = NULL;
		}
@


1.28
log
@add missing copyright; Constantine
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.27 2007/01/06 18:17:06 deraadt Exp $ */
a215 1
			limit->last_val = sensor.value;
d230 1
a230 5
				if (newstatus == SENSOR_S_OK) {
					limit->status2 =
					    limit->status = newstatus;
					limit->status_changed = time(NULL);
				} else if (limit->status2 != newstatus) {
d234 1
@


1.27
log
@increase buffer size; ie. for hw.sensors.ipmi0.indicator0
from cnst+openbsd@@bugmail.mojo.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.26 2006/12/23 17:49:53 deraadt Exp $ */
d6 1
@


1.26
log
@adapt to new two-level sensor sysctl framework; by Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.25 2006/12/18 14:13:15 mickey Exp $ */
d118 2
a119 1
				if (sysctl(mib, 5, &sensor, &slen, NULL, 0) == -1) {
d406 1
a406 1
	char		  node[24];
@


1.25
log
@it appears some sensors flip duen to bugs or erroneous readings.
provide dampenning for negative events and simultaneously increase
polling frequency accordingly to provide same rate of reporting.
mbalmer@@ beck@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.24 2006/09/16 10:46:26 mickey Exp $ */
d50 4
a58 1
	enum sensor_type	type;		/* sensor type */
a60 1
	int			num;		/* sensor number */
d83 1
d85 1
a85 1
	size_t		 len;
d87 3
a89 1
	int		 mib[3], i, sleeptime, sensor_cnt, watch_cnt, ch;
d103 2
a104 1
	len = sizeof(sensor);
d107 3
a109 3
	for (i = 0; i < 256; i++) {
		mib[2] = i;
		if (sysctl(mib, 3, &sensor, &len, NULL, 0) == -1) {
d114 23
a136 8
		if (sensor.flags & SENSOR_FINVALID)
			continue;
		if ((limit = calloc(1, sizeof(struct limits_t))) == NULL)
			err(1, "calloc");
		limit->num = i;
		limit->type = sensor.type;
		TAILQ_INSERT_TAIL(&limits, limit, entries);
		sensor_cnt++;
d199 1
a199 1
	int		 	 mib[3];
d208 4
a211 2
			mib[2] = limit->num;
			if (sysctl(mib, 3, &sensor, &len, NULL, 0) == -1)
d272 2
a273 2
		syslog(LOG_ALERT, "hw.sensors.%d: %s limits, value: %s",
		    limit->num,
d299 9
a307 1
				case '1':
d309 1
a309 1
					    limit->num);
d416 2
a417 1
		snprintf(node, sizeof(node), "hw.sensors.%d", p->num);
@


1.24
log
@sync printing w/ sysctl and also add missing sensor types to the conf parser; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.23 2006/08/23 11:18:00 mickey Exp $ */
d37 1
a37 1
#define CHECK_PERIOD	60	/* check every n seconds */
d50 10
a60 8
	int			num;			/* sensor number */
	enum sensor_type	type;			/* sensor type */
	int64_t			lower;			/* lower limit */
	int64_t			upper;			/* upper limit */
	char			*command;		/* failure command */
	enum sensor_status	status;			/* last status */
	time_t			status_changed;
	int64_t			last_val;
d206 12
a217 2
				limit->status = newstatus;
				limit->status_changed = time(NULL);
@


1.23
log
@allow monitoring sensors with their own status reporting such as ipmi or raid controllers; marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.22 2006/04/01 20:09:13 henning Exp $ */
d320 2
a321 3
		snprintf(fbuf, RFBUFSIZ, "%.2fC/%.2fF",
		    (value - 273150000) / 1000000.0,
		    (value - 273150000) / 1000000.0 * 9 / 5 + 32);
d327 7
a333 1
		snprintf(fbuf, RFBUFSIZ, "%.2fV", value / 1000.0 / 1000.0);
d336 7
a342 1
		snprintf(fbuf, RFBUFSIZ, "%lld", value);
d438 4
d443 1
d445 3
@


1.22
log
@when I initially hacked sensorsd, sensors started at hw.sensors.0 and
there were no gaps ever. these days, we can have holes or start later.
so on start scan 0..255 and do not abort if there's no entry, probe 'em
all.
found and analyzed by Sam Chill <samchill@@gmail.com>, ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.21 2006/03/20 15:19:03 dhill Exp $ */
a47 5
enum sensorsd_status {
	STATUS_OK,
	STATUS_FAIL
};

d56 1
a56 1
	enum sensorsd_status	status;			/* last status */
d177 1
a177 1
	enum sensorsd_status 	 newstatus;
d190 12
a201 5
			if (sensor.value > limit->upper ||
			    sensor.value < limit->lower)
				newstatus = STATUS_FAIL;
			else
				newstatus = STATUS_OK;
d239 1
a239 1
		    (limit->status == STATUS_FAIL) ? "exceed" : "within",
d302 5
d333 6
@


1.21
log
@add two missing function declarations
change sensor_status to sensorsd_status

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.20 2006/02/06 21:32:20 moritz Exp $ */
d109 1
a109 1
			break;
@


1.20
log
@don't error out but give a warning when sysctl()
fails with something else than ENOENT.

suggested by tedu@@ ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.19 2006/01/31 18:13:39 moritz Exp $ */
d39 1
a39 1
int		 main(int, char *[]);
d41 1
d61 1
a61 1
	enum sensor_status	status;			/* last status */
d178 5
a182 5
	struct sensor	 sensor;
	struct limits_t	*limit;
	size_t		 len;
	int		 mib[3];
	int		 newstatus;
@


1.19
log
@When sysctl(3) fails, check for ENOENT instead of ENXIO to find
the last sensor and don't monitor sensors, which are marked invalid.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.18 2005/08/04 13:01:43 jsg Exp $ */
d106 3
a108 4
			if (errno == ENOENT)
				break;
			else
				err(1, "sysctl");
@


1.18
log
@Support for SENSOR_INTEGER.
ok grange@@, dlg@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.17 2005/08/03 17:30:05 deraadt Exp $ */
d86 1
a86 1
	int		 mib[3], i, sleeptime, watch_cnt, ch;
d102 1
d106 1
a106 1
			if (errno == ENXIO)
d111 2
d118 1
d121 1
a121 1
	if (i == 0)
d141 2
a142 1
	syslog(LOG_INFO, "startup, %d watches for %d sensors", watch_cnt, i);
@


1.17
log
@dlg did not test what he affects; enum clash
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.16 2005/06/03 12:31:28 henning Exp $ */
d318 3
d408 3
@


1.16
log
@print negative values correctly; From: serge rasnikov <747500@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.15 2005/04/21 00:22:28 deraadt Exp $ */
d47 1
a47 1
enum sensor_status {
@


1.15
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.14 2005/04/20 21:08:45 hshoexer Exp $ */
d42 1
a42 1
static char	*print_sensor(enum sensor_type, u_int64_t);
d296 1
a296 1
print_sensor(enum sensor_type type, u_int64_t value)
@


1.14
log
@fix buffer overrun introduced with my previous commit.  Found and fixed by
moritz@@; while around take care of snprintf return values

help and ok moritz@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.13 2005/04/01 22:15:40 deraadt Exp $ */
d208 1
a208 1
	switch (fork ()) {
d387 1
a387 1
			printf ("C");
@


1.13
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.12 2005/04/01 22:10:23 hshoexer Exp $ */
d258 1
a258 1
					r = snprintf(&buf[n], len, "%d",
d262 1
a262 1
					r = snprintf(&buf[n], len, "%s",
d267 1
a267 1
					r = snprintf(&buf[n], len, "%s",
d272 1
a272 1
					r = snprintf(&buf[n], len, "%s",
d277 1
a277 1
					r = snprintf(&buf[n], len, "%%%c",
d281 4
a284 3
				if (r > len) {
					buf[n] = '\0';
					break;
d286 1
a286 2
				if (r > 0) {
					len -= r;
a287 1
				}
@


1.12
log
@sensorsd(8) execute command on exceeding limits
from matthew.gream@@pobox.com, thanks!

cleaning and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.11 2004/09/14 23:24:41 deraadt Exp $ */
d85 2
a86 5
	time_t		 next_report, last_report = 0;
	time_t		 next_check;
	int		 mib[3];
	int		 i, sleeptime, watch_cnt;
	int 		 ch;
d207 1
a207 1
	
d252 1
a252 1
					buf[n++] = '\0'; 
@


1.11
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.10 2004/04/11 20:02:00 otto Exp $ */
d5 1
d59 1
d69 9
d89 11
d134 1
a134 1
	if (daemon(0, 0) == -1)
d138 1
d207 18
d229 66
a294 14
	TAILQ_FOREACH(limit, &limits, entries)
		if (limit->status_changed > last_report) {
			if (limit->status == STATUS_FAIL)
				syslog(LOG_ALERT,
				    "failure for hw.sensors.%d: "
				    "%s not within limits",
				    limit->num,
				    print_sensor(limit->type, limit->last_val));
			else
				syslog(LOG_ALERT,
				    "hw.sensors.%d within limits again, "
				    "current value %s",
				    limit->num,
				    print_sensor(limit->type, limit->last_val));
d296 1
d357 4
@


1.10
log
@Fix accidental busy loop waiting for a second to pass. Also, rename
constants that defined a period of time.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.9 2004/03/15 15:53:19 henning Exp $ */
d320 1
d322 1
a322 1
reparse_cfg(int signum)
@


1.9
log
@add a default: case to the switch (sensor type) in the config file parser
that just errs out if someone tries to configure limits for a sensor type we
do not support, deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.8 2004/02/07 16:50:04 deraadt Exp $ */
d35 2
a36 2
#define REPORT_FREQ	60	/* report every n seconds */
#define CHECK_FREQ	60	/* check every n seconds */
d132 1
a132 1
		if (next_check < time(NULL)) {
d134 1
a134 1
			next_check = time(NULL) + CHECK_FREQ;
d136 1
a136 1
		if (next_report < time(NULL)) {
d139 1
a139 1
			next_report = time(NULL) + REPORT_FREQ;
@


1.8
log
@knf; jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.7 2004/01/08 09:18:00 markus Exp $ */
d312 3
@


1.7
log
@sync with sysctl/drivers + 0K == -273.15C; report grange; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.6 2003/12/22 12:59:45 henning Exp $ */
d39 1
a39 1
void		 check_sensors();
d92 1
a92 1
			err(1, "out of memory");
d151 1
a151 1
check_sensors()
d244 2
a245 1
	cfa = calloc(2, sizeof(char *));
@


1.6
log
@reload is used in signal handler, make it volatile sig_atomic_t
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.5 2003/10/01 02:43:17 kevlo Exp $ */
d219 2
a220 2
			    (value / 1000 / 1000) - 273.16,
			    ((value / 1000 / 1000) - 273.16) * 9 / 5 + 32);
@


1.5
log
@sys/types.h is not really needed with sys/param.h.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.4 2003/09/30 15:06:29 henning Exp $ */
d65 2
a66 2
char	 *configfile;
int	  reload = 0;
@


1.4
log
@o err out on start if no watches are defined
o log how many watches are defined
o on configuration reload also log how many watches we have
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.3 2003/09/30 00:18:40 jose Exp $ */
a18 1
#include <sys/types.h>
@


1.3
log
@
set the log message ident with openlog(), ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.2 2003/09/29 16:05:34 henning Exp $ */
d78 1
a78 1
	int		 i, sleeptime;
d107 1
a107 1
	if (parse_config(configfile))
d110 3
d118 1
a118 1
	syslog(LOG_INFO, "startup, monitoring %d sensors", i);
d124 1
a124 1
			if (parse_config(configfile))
d128 3
a130 1
				syslog(LOG_INFO, "configuration reloaded");
d243 1
d256 1
d268 1
a268 1
	return (0);
@


1.2
log
@uncomment daemon() call; spotted by jose@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensorsd.c,v 1.1 2003/09/24 20:32:49 henning Exp $ */
d101 2
@


1.1
log
@sensorsd monitors the hardware sensors as reported by sysctl in hw.sensors.
limits can be configured, out of range notifications through syslog.
config file parsing based on bob's hints, lots of hints from theo
feedback from grange, otto, mickey as well

ok deraadt@@; grange@@ on an earlier version
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d108 1
a108 1
/*	if (daemon(0, 0) == -1)
d110 1
a110 1
*/
@

