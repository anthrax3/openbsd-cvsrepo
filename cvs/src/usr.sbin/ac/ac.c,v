head	1.24;
access;
symbols
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.8
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.10
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.8
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.10
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.8
	OPENBSD_5_0:1.21.0.6
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.10
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.16
	OPENBSD_2_8:1.7.0.14
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.10.12.02.02.00;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	QoyqQe67bZW3bQU2;

1.23
date	2015.02.09.23.00.14;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	822YD61EeG0Xl9Na;

1.22
date	2012.08.31.19.57.12;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.04.10.17.25;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.17.15.08.57;	author sobrado;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.03.21.32.38;	author dhill;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.18.01.28.40;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.21.07.52.02;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.20.19.39.35;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.11.23.33.24;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.13.09.09.37;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.17.19.42.35;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.28.00;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.24.03.02.32;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.05.07.12.50;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.10.09.15.07.17;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.08.30.19.54.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.01.07.33.57;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.02.09.44.51;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.43.44;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.08.29.03.32.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@pledge to only use "stdio rpath"; rpath is for readig the wtmp files.
ok doug
@
text
@/*-
 * Copyright (c) 1994 Christopher G. Demetriou
 * Copyright (c) 1994 Simon J. Gerraty
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/file.h>
#include <sys/time.h>
#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <utmp.h>
#include <unistd.h>

/*
 * this is for our list of currently logged in sessions
 */
struct utmp_list {
	struct utmp_list *next;
	struct utmp usr;
};

/*
 * this is for our list of users that are accumulating time.
 */
struct user_list {
	struct user_list *next;
	char	name[UT_NAMESIZE+1];
	time_t	secs;
};

/*
 * this is for chosing whether to ignore a login
 */
struct tty_list {
	struct tty_list *next;
	char	name[UT_LINESIZE+3];
	size_t	len;
	int	ret;
};

/*
 * globals - yes yuk
 */
static time_t	Total = 0;
static time_t	FirstTime = 0;
static int	Flags = 0;
static struct user_list *Users = NULL;
static struct tty_list *Ttys = NULL;

#define	AC_W	1				/* not _PATH_WTMP */
#define	AC_D	2				/* daily totals (ignore -p) */
#define	AC_P	4				/* per-user totals */
#define	AC_U	8				/* specified users only */
#define	AC_T	16				/* specified ttys only */

#ifdef DEBUG
static int Debug = 0;
#endif

int			main(int, char **);
int			ac(FILE *);
void			add_tty(char *);
int			do_tty(char *);
FILE			*file(char *);
struct utmp_list	*log_in(struct utmp_list *, struct utmp *);
struct utmp_list	*log_out(struct utmp_list *, struct utmp *);
int			on_console(struct utmp_list *);
void			show(char *, time_t);
void			show_today(struct user_list *, struct utmp_list *,
			    time_t);
void			show_users(struct user_list *);
struct user_list	*update_user(struct user_list *, char *, time_t);
void			usage(void);

/*
 * open wtmp or die
 */
FILE *
file(char *name)
{
	FILE *fp;

	if (strcmp(name, "-") == 0)
		fp = stdin;
	else if ((fp = fopen(name, "r")) == NULL)
		err(1, "%s", name);
	/* in case we want to discriminate */
	if (strcmp(_PATH_WTMP, name))
		Flags |= AC_W;
	return fp;
}

void
add_tty(char *name)
{
	struct tty_list *tp;
	char *rcp;

	Flags |= AC_T;

	if ((tp = malloc(sizeof(struct tty_list))) == NULL)
		err(1, "malloc");
	tp->len = 0;				/* full match */
	tp->ret = 1;				/* do if match */
	if (*name == '!') {			/* don't do if match */
		tp->ret = 0;
		name++;
	}
	strlcpy(tp->name, name, sizeof (tp->name));
	if ((rcp = strchr(tp->name, '*')) != NULL) {	/* wild card */
		*rcp = '\0';
		tp->len = strlen(tp->name);	/* match len bytes only */
	}
	tp->next = Ttys;
	Ttys = tp;
}

/*
 * should we process the named tty?
 */
int
do_tty(char *name)
{
	struct tty_list *tp;
	int def_ret = 0;

	for (tp = Ttys; tp != NULL; tp = tp->next) {
		if (tp->ret == 0)		/* specific don't */
			def_ret = 1;		/* default do */
		if (tp->len != 0) {
			if (strncmp(name, tp->name, tp->len) == 0)
				return tp->ret;
		} else {
			if (strncmp(name, tp->name, sizeof (tp->name)) == 0)
				return tp->ret;
		}
	}
	return def_ret;
}

/*
 * update user's login time
 */
struct user_list *
update_user(struct user_list *head, char *name, time_t secs)
{
	struct user_list *up;

	for (up = head; up != NULL; up = up->next) {
		if (strncmp(up->name, name, sizeof (up->name) - 1) == 0) {
			up->secs += secs;
			Total += secs;
			return head;
		}
	}
	/*
	 * not found so add new user unless specified users only
	 */
	if (Flags & AC_U)
		return head;

	if ((up = malloc(sizeof(struct user_list))) == NULL)
		err(1, "malloc");
	up->next = head;
	strlcpy(up->name, name, sizeof (up->name));
	up->secs = secs;
	Total += secs;
	return up;
}

int
main(int argc, char *argv[])
{
	FILE *fp;
	int c;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	fp = NULL;
	while ((c = getopt(argc, argv, "Ddpt:w:")) != -1) {
		switch (c) {
#ifdef DEBUG
		case 'D':
			Debug = 1;
			break;
#endif
		case 'd':
			Flags |= AC_D;
			break;
		case 'p':
			Flags |= AC_P;
			break;
		case 't':			/* only do specified ttys */
			add_tty(optarg);
			break;
		case 'w':
			fp = file(optarg);
			break;
		case '?':
		default:
			usage();
			break;
		}
	}
	if (optind < argc) {
		/*
		 * initialize user list
		 */
		for (; optind < argc; optind++) {
			Users = update_user(Users, argv[optind], 0L);
		}
		Flags |= AC_U;			/* freeze user list */
	}
	if (Flags & AC_D)
		Flags &= ~AC_P;
	if (fp == NULL) {
		/*
		 * if _PATH_WTMP does not exist, exit quietly
		 */
		if (access(_PATH_WTMP, 0) != 0 && errno == ENOENT)
			return 0;

		fp = file(_PATH_WTMP);
	}
	ac(fp);

	return 0;
}

/*
 * print login time in decimal hours
 */
void
show(char *name, time_t secs)
{
	(void)printf("\t%-*s %8.2f\n", UT_NAMESIZE, name,
	    ((double)secs / 3600));
}

void
show_users(struct user_list *list)
{
	struct user_list *lp;

	for (lp = list; lp; lp = lp->next)
		show(lp->name, lp->secs);
}

/*
 * print total login time for 24hr period in decimal hours
 */
void
show_today(struct user_list *users, struct utmp_list *logins, time_t secs)
{
	struct user_list *up;
	struct utmp_list *lp;
	char date[64];
	time_t yesterday = secs - 1;

	(void)strftime(date, sizeof (date), "%b %e  total",
	    localtime(&yesterday));

	/* restore the missing second */
	yesterday++;

	for (lp = logins; lp != NULL; lp = lp->next) {
		secs = yesterday - lp->usr.ut_time;
		Users = update_user(Users, lp->usr.ut_name, secs);
		lp->usr.ut_time = yesterday;	/* as if they just logged in */
	}
	secs = 0;
	for (up = users; up != NULL; up = up->next) {
		secs += up->secs;
		up->secs = 0;			/* for next day */
	}
	if (secs)
		(void)printf("%s %11.2f\n", date, ((double)secs / 3600));
}

/*
 * log a user out and update their times.
 * if ut_line is "~", we log all users out as the system has
 * been shut down.
 */
struct utmp_list *
log_out(struct utmp_list *head, struct utmp *up)
{
	struct utmp_list *lp, *lp2, *tlp;
	time_t secs;

	for (lp = head, lp2 = NULL; lp != NULL; )
		if (*up->ut_line == '~' || strncmp(lp->usr.ut_line, up->ut_line,
		    sizeof (up->ut_line)) == 0) {
			secs = up->ut_time - lp->usr.ut_time;
			Users = update_user(Users, lp->usr.ut_name, secs);
#ifdef DEBUG
			if (Debug)
				printf("%-.*s %-.*s: %-.*s logged out (%2d:%02d:%02d)\n",
				    19, ctime(&up->ut_time),
				    sizeof (lp->usr.ut_line), lp->usr.ut_line,
				    sizeof (lp->usr.ut_name), lp->usr.ut_name,
				    secs / 3600, (secs % 3600) / 60, secs % 60);
#endif
			/*
			 * now lose it
			 */
			tlp = lp;
			lp = lp->next;
			if (tlp == head)
				head = lp;
			else if (lp2 != NULL)
				lp2->next = lp;
			free(tlp);
		} else {
			lp2 = lp;
			lp = lp->next;
		}
	return head;
}


/*
 * if do_tty says ok, login a user
 */
struct utmp_list *
log_in(struct utmp_list *head, struct utmp *up)
{
	struct utmp_list *lp;

	/*
	 * this could be a login. if we're not dealing with
	 * the console name, say it is.
	 *
	 * If we are, and if ut_host==":0.0" we know that it
	 * isn't a real login. _But_ if we have not yet recorded
	 * someone being logged in on Console - due to the wtmp
	 * file starting after they logged in, we'll pretend they
	 * logged in, at the start of the wtmp file.
	 */

	/*
	 * If we are doing specified ttys only, we ignore
	 * anything else.
	 */
	if (Flags & AC_T)
		if (!do_tty(up->ut_line))
			return head;

	/*
	 * go ahead and log them in
	 */
	if ((lp = malloc(sizeof(struct utmp_list))) == NULL)
		err(1, "malloc");
	lp->next = head;
	head = lp;
	memmove((char *)&lp->usr, (char *)up, sizeof (struct utmp));
#ifdef DEBUG
	if (Debug) {
		printf("%-.*s %-.*s: %-.*s logged in", 19,
		    ctime(&lp->usr.ut_time), sizeof (up->ut_line),
		    up->ut_line, sizeof (up->ut_name), up->ut_name);
		if (*up->ut_host)
			printf(" (%-.*s)", sizeof (up->ut_host), up->ut_host);
		putchar('\n');
	}
#endif
	return head;
}

int
ac(FILE	*fp)
{
	struct utmp_list *lp, *head = NULL;
	struct utmp usr;
	struct tm *ltm;
	time_t secs = 0, prev = 0;
	int day = -1;

	while (fread((char *)&usr, sizeof(usr), 1, fp) == 1) {
		if (!FirstTime)
			FirstTime = usr.ut_time;
		if (usr.ut_time < prev)
			continue;	/* broken record */
		prev = usr.ut_time;
		if (Flags & AC_D) {
			ltm = localtime(&usr.ut_time);
			if (day >= 0 && day != ltm->tm_yday) {
				day = ltm->tm_yday;
				/*
				 * print yesterday's total
				 */
				secs = usr.ut_time;
				secs -= ltm->tm_sec;
				secs -= 60 * ltm->tm_min;
				secs -= 3600 * ltm->tm_hour;
				show_today(Users, head, secs);
			} else
				day = ltm->tm_yday;
		}
		switch(*usr.ut_line) {
		case '|':
			secs = usr.ut_time;
			break;
		case '{':
			secs -= usr.ut_time;
			/*
			 * adjust time for those logged in
			 */
			for (lp = head; lp != NULL; lp = lp->next)
				lp->usr.ut_time -= secs;
			break;
		case '~':			/* reboot or shutdown */
			head = log_out(head, &usr);
			FirstTime = usr.ut_time; /* shouldn't be needed */
			break;
		default:
			/*
			 * if they came in on a pseudo-tty, then it is only
			 * a login session if the ut_host field is non-empty
			 */
			if (*usr.ut_name) {
				if (strncmp(usr.ut_line, "tty", 3) != 0 ||
				    strchr("pqrstuvwxyzPQRST", usr.ut_line[3]) != NULL ||
				    *usr.ut_host != '\0')
					head = log_in(head, &usr);
			} else
				head = log_out(head, &usr);
			break;
		}
	}
	(void)fclose(fp);
	if (!(Flags & AC_W))
		usr.ut_time = time(NULL);
	(void)strlcpy(usr.ut_line, "~", sizeof usr.ut_line);

	if (Flags & AC_D) {
		ltm = localtime(&usr.ut_time);
		if (day >= 0 && day != ltm->tm_yday) {
			/*
			 * print yesterday's total
			 */
			secs = usr.ut_time;
			secs -= ltm->tm_sec;
			secs -= 60 * ltm->tm_min;
			secs -= 3600 * ltm->tm_hour;
			show_today(Users, head, secs);
		}
	}
	/*
	 * anyone still logged in gets time up to now
	 */
	head = log_out(head, &usr);

	if (Flags & AC_D)
		show_today(Users, head, time(NULL));
	else {
		if (Flags & AC_P)
			show_users(Users);
		show("total", Total);
	}
	return 0;
}

void
usage(void)
{
	extern char *__progname;
	(void)fprintf(stderr, "usage: "
	    "%s [-dp] [-t tty] [-w wtmp] [user ...]\n", __progname);
	exit(1);
}
@


1.23
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d203 3
@


1.22
log
@Update license to two-clause BSD.  Permission to do so was granted
by the authors as per Ed Schouten.
@
text
@d208 1
a208 1
			Debug++;
@


1.21
log
@Remove the non-standard, commented out, -c option.
OK tedu@@ jmc@@ deraadt@@
@
text
@d1 4
a4 3
/*
 *      Copyright (c) 1994 Christopher G. Demetriou.
 *      @@(#)Copyright (c) 1994, Simon J. Gerraty.
d6 20
a25 9
 *      This is free software.  It comes with NO WARRANTY.
 *      Permission to use, modify and distribute this source code
 *      is granted subject to the following conditions.
 *      1/ that the above copyright notice and this notice
 *      are preserved in all copies and that due credit be given
 *      to the author.
 *      2/ that any changes to this code are clearly commented
 *      as such so that the author does not get blamed for bugs
 *      other than his own.
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@a57 3
#ifdef CONSOLE_TTY
static char	*Console = CONSOLE_TTY;
#endif
a154 18
#ifdef CONSOLE_TTY
/*
 * is someone logged in on Console?
 */
int
on_console(struct utmp_list *head)
{
	struct utmp_list *up;

	for (up = head; up; up = up->next) {
		if (strncmp(up->usr.ut_line, Console,
		    sizeof (up->usr.ut_line)) == 0)
			return 1;
	}
	return 0;
}
#endif

d192 1
a192 1
	while ((c = getopt(argc, argv, "Dc:dpt:w:")) != -1) {
a198 7
		case 'c':
#ifdef CONSOLE_TTY
			Console = optarg;
#else
			usage();		/* XXX */
#endif
			break;
a352 19
#ifdef CONSOLE_TTY
	if (up->ut_host[0] == ':') {
		/*
		 * SunOS 4.0.2 does not treat ":0.0" as special but we
		 * do.
		 */
		if (on_console(head))
			return head;
		/*
		 * ok, no recorded login, so they were here when wtmp
		 * started!  Adjust ut_time!
		 */
		up->ut_time = FirstTime;
		/*
		 * this allows us to pick the right logout
		 */
		strlcpy(up->ut_line, Console, sizeof (up->ut_line));
	}
#endif
a480 4
#ifdef CONSOLE_TTY
	    "%s [-dp] [-c console] [-t tty] [-w wtmp] [user ...]\n",
	    __progname);
#else
a481 1
#endif
@


1.19
log
@the usage message should start with "usage:";
no need for "users", ellipsis allows various users to be specified;
synchronize synopsis and usage

ok jmc@@
@
text
@a15 4
#ifndef lint
static const char rcsid[] = "$OpenBSD: ac.c,v 1.18 2006/04/03 21:32:38 dhill Exp $";
#endif

@


1.18
log
@Change an int to size_t
Remove NEW()
Remove unused return value of add_tty()

ok moritz@@
@
text
@d17 1
a17 1
static const char rcsid[] = "$OpenBSD: ac.c,v 1.17 2004/03/18 01:28:40 tedu Exp $";
d531 1
a531 1
	(void)fprintf(stderr,
d533 1
a533 1
	    "%s [-d | -p] [-c console] [-t tty] [-w wtmp] [users ...]\n",
d536 1
a536 2
	    "%s [-d | -p] [-t tty] [-w wtmp] [users ...]\n",
	    __progname);
@


1.17
log
@0 vs NULL, from Joris Vink
@
text
@d17 1
a17 1
static const char rcsid[] = "$OpenBSD$";
d55 1
a55 1
	int	len;
a70 2
#define NEW(type) (type *)malloc(sizeof (type))

d83 1
a83 1
struct tty_list		*add_tty(char *);
d114 1
a114 1
struct tty_list *
d122 1
a122 1
	if ((tp = NEW(struct tty_list)) == NULL)
a136 1
	return Ttys;
d201 1
a201 1
	if ((up = NEW(struct user_list)) == NULL)
d415 1
a415 1
	if ((lp = NEW(struct utmp_list)) == NULL)
@


1.16
log
@spacing
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.15 2003/07/20 19:39:35 mickey Exp $";
d489 1
a489 1
				    strchr("pqrstuvwxyzPQRST", usr.ut_line[3]) != 0 ||
d499 1
a499 1
		usr.ut_time = time((time_t *)0);
d521 1
a521 1
		show_today(Users, head, time((time_t *)0));
@


1.15
log
@ignore backwards going entries
@
text
@d4 1
a4 1
 *      
d6 1
a6 1
 *      Permission to use, modify and distribute this source code 
d8 5
a12 5
 *      1/ that the above copyright notice and this notice 
 *      are preserved in all copies and that due credit be given 
 *      to the author.  
 *      2/ that any changes to this code are clearly commented 
 *      as such so that the author does not get blamed for bugs 
d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.14 2003/06/11 23:33:24 deraadt Exp $";
d63 1
a63 1
static char 	*Console = CONSOLE_TTY;
d323 1
a323 1
 	if (secs)
d392 1
a392 1
		 * do. 
d398 1
a398 1
		 * started!  Adjust ut_time! 
d427 1
a427 1
		       up->ut_line, sizeof (up->ut_name), up->ut_name);
@


1.14
log
@some ansification, some de-register
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.13 2003/03/13 09:09:37 deraadt Exp $";
d442 1
a442 1
	time_t secs = 0;
d448 3
@


1.13
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.12 2002/05/30 19:09:05 deraadt Exp $";
d102 1
a102 2
file(name)
	char *name;
d117 1
a117 2
add_tty(name)
	char *name;
d120 1
a120 1
	register char *rcp;
d146 1
a146 2
do_tty(name)
	char *name;
d170 1
a170 2
on_console(head)
	struct utmp_list *head;
d187 1
a187 4
update_user(head, name, secs)
	struct user_list *head;
	char	*name;
	time_t	secs;
d214 1
a214 3
main(argc, argv)
	int	argc;
	char	**argv;
d281 1
a281 3
show(name, secs)
	char *name;
	time_t secs;
d288 1
a288 2
show_users(list)
	struct user_list *list;
d300 1
a300 4
show_today(users, logins, secs)
	struct user_list *users;
	struct utmp_list *logins;
	time_t secs;
d333 1
a333 3
log_out(head, up)
	struct utmp_list *head;
	struct utmp *up;
d373 1
a373 3
log_in(head, up)
	struct utmp_list *head;
	struct utmp *up;
d437 1
a437 2
ac(fp)
	FILE	*fp;
d528 1
a528 1
usage()
@


1.12
log
@minor KNF
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.11 2002/02/17 19:42:35 millert Exp $";
d517 1
a517 1
	(void)strcpy(usr.ut_line, "~");
@


1.11
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.10 2002/02/16 21:28:00 millert Exp $";
d125 1
a125 1
	
d153 1
a153 1
	
d210 1
a210 1
	
d278 1
a278 1
		
d282 1
a282 1
	
d327 1
a327 1
	
d354 1
a354 1
	
d464 1
a464 1
	
d518 1
a518 1
	
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.9 2001/05/24 03:02:32 pvalchev Exp $";
d92 2
a93 2
void			show_today __P((struct user_list *, struct utmp_list *,
			    time_t));
@


1.9
log
@- Let '-' mean stdin.
- Correct usage message: -p and -d cannot be usefully used together.
- Use __progname in usage()
millert@@ ok
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.8 2001/05/05 07:12:50 mickey Exp $";
d83 9
a91 9
int			main __P((int, char **));
int			ac __P((FILE *));
struct tty_list		*add_tty __P((char *));
int			do_tty __P((char *));
FILE			*file __P((char *));
struct utmp_list	*log_in __P((struct utmp_list *, struct utmp *));
struct utmp_list	*log_out __P((struct utmp_list *, struct utmp *));
int			on_console __P((struct utmp_list *));
void			show __P((char *, time_t));
d94 3
a96 3
void			show_users __P((struct user_list *));
struct user_list	*update_user __P((struct user_list *, char *, time_t));
void			usage __P((void));
@


1.8
log
@use strlcpy vs strncpy+a[n-1]='\0'
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.7 1997/10/09 15:07:17 deraadt Exp $";
d107 3
a109 1
	if ((fp = fopen(name, "r")) == NULL)
d550 1
d553 2
a554 1
	    "ac [-dp] [-c console] [-t tty] [-w wtmp] [users ...]\n");
d556 2
a557 1
	    "ac [-dp] [-t tty] [-w wtmp] [users ...]\n");
@


1.7
log
@if user specified wtmp file, use timestamp on final record instead of
current system time for "end of run" time; tim@@pool1.convey.ru
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.6 1997/08/30 19:54:45 deraadt Exp $";
d132 1
a132 2
	(void)strncpy(tp->name, name, sizeof (tp->name) - 1);
	tp->name[sizeof (tp->name) - 1] = '\0';
d212 1
a212 2
	(void)strncpy(up->name, name, sizeof (up->name) - 1);
	up->name[sizeof (up->name) - 1] = '\0';	/* paranoid! */
d421 1
a421 2
		(void)strncpy(up->ut_line, Console, sizeof (up->ut_line) - 1);
		up->ut_line[sizeof (up->ut_line) - 1] = '\0'; /* paranoid! */
@


1.6
log
@incorrect length in comparison; hubert.feyrer@@rz.uni-regensburg.de
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.5 1997/08/01 07:33:57 deraadt Exp $";
d516 2
a517 1
	usr.ut_time = time((time_t *)0);
@


1.5
log
@catch ptys correctly; tolik@@www.tomsk.su
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.4 1997/06/02 09:44:51 deraadt Exp $";
d198 1
a198 1
		if (strncmp(up->name, name, sizeof (up->name)) == 0) {
@


1.4
log
@correct for our pty list
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.3 1997/01/15 23:43:44 millert Exp $";
d507 1
a507 1
				    strchr("pqrstuvwxyzPQRST", usr.ut_line[3]) == 0 ||
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.2 1996/08/29 03:32:19 deraadt Exp $";
d502 1
a502 1
			 * if they came in on tty[p-y]*, then it is only
d507 1
a507 1
				    strchr("pqrstuvwxy", usr.ut_line[3]) == 0 ||
@


1.2
log
@fix warnings
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.1.1.1 1995/10/18 08:47:09 deraadt Exp $";
d229 1
a229 1
	while ((c = getopt(argc, argv, "Dc:dpt:w:")) != EOF) {
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char rcsid[] = "$Id: ac.c,v 1.3 1994/05/01 04:39:35 cgd Exp $";
d463 1
a463 1
	time_t secs;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
