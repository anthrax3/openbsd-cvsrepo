head	1.37;
access;
symbols
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.33.0.14
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.12
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.10
	OPENBSD_5_0:1.33.0.8
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.6
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.14
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.12
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.10
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.8
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.6
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.30.0.4
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.4
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.17.0.4
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.9.0.6
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2014.04.24.14.59.06;	author tedu;	state dead;
branches;
next	1.36;

1.36
date	2014.01.09.05.04.03;	author martynas;	state Exp;
branches;
next	1.35;

1.35
date	2013.04.02.03.06.07;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.21.04.43.17;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.26.09.44.55;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.02.16.29.53;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.16.08.55.00;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.26.07.15.41;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.08.17.05.36;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.05.02.41.35;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.06.19.46.52;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.14.03.52.35;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.16.44.25;	author mpech;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.17.19.42.39;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.28.09;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.17.19.49.40;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.14.21.36.37;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.31.20.07.56;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.08.15.03.20;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.11.23.41.42;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.23.02.19.03;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.28.23.57.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.08.16.21.22.18;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.07.13.02.11.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.04.30.08.45.03;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.04.14.07.01.42;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.13.01.53.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.03.26.00.45.57;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.07.14.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.11.01.06.53.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.11.01.06.53.25;	author imp;	state Exp;
branches;
next	1.3;

1.3
date	96.11.01.06.45.45;	author imp;	state Exp;
branches;
next	1.2;

1.2
date	96.08.16.23.24.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.37
log
@That is strength, boy! That is power! What is steel compared to the hand
that wields it? Look at the strength in your body, the desire in your
heart, I gave you this! Such a waste. Contemplate this on the tree of woe.
@
text
@/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <netinet/in.h>
#include <protocols/rwhod.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <netdb.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <utmp.h>
#include <err.h>

/*
 * Alarm interval. Don't forget to change the down time check in ruptime
 * if this is changed.
 */
#define AL_INTERVAL (3 * 60)

char	myname[MAXHOSTNAMELEN];

int	debug;

/*
 * We communicate with each neighbor in a list constructed at the time we're
 * started up.  Neighbors are currently directly connected via a hardware
 * interface.
 */
struct	neighbor {
	struct	neighbor *n_next;
	char	*n_name;		/* interface name */
	struct	sockaddr *n_addr;	/* who to send to */
	int	n_addrlen;		/* size of address */
	int	n_flags;		/* should forward?, interface flags */
};

struct	neighbor *neighbors;
struct	whod mywd;
struct	servent *sp;
int	s, utmpf;

volatile sig_atomic_t gothup;

#define	WHDRSIZE	(sizeof(mywd) - sizeof(mywd.wd_we))

int	 configure(void);
void	 getboottime(void);
void	 hup(int);
void	 timer(void);
void	 quit(char *);
void	 rt_xaddrs(caddr_t, caddr_t, struct rt_addrinfo *);
int	 verify(char *);
void	 handleread(int s);
int	 Sendto(int, const void *, size_t, int, const struct sockaddr *,
	    socklen_t);
char	*interval(int, char *);

/* ARGSUSED */
void
hup(int signo)
{
	gothup = 1;
}

void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-d]\n", __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct timeval start, next, delta, now;
	struct sockaddr_in sin;
	struct pollfd pfd[1];
	int on = 1, ch;
	char *cp;

	while ((ch = getopt(argc, argv, "d")) != -1) {
		switch (ch) {
		case 'd':
			debug = 1;
			break;
		default:
			usage();
		}
	}

	if (getuid())
		errx(1, "not super user");
	sp = getservbyname("who", "udp");
	if (sp == NULL)
		errx(1, "udp/who: unknown service");
	if (chdir(_PATH_RWHODIR) < 0)
		err(1, "%s", _PATH_RWHODIR);
	if (!debug)
		daemon(1, 0);

	(void) signal(SIGHUP, hup);
	openlog("rwhod", LOG_PID, LOG_DAEMON);
	/*
	 * Establish host name as returned by system.
	 */
	if (gethostname(myname, sizeof(myname)) < 0) {
		syslog(LOG_ERR, "gethostname: %m");
		exit(1);
	}
	if ((cp = strchr(myname, '.')) != NULL)
		*cp = '\0';
	strncpy(mywd.wd_hostname, myname, sizeof(mywd.wd_hostname) - 1);
	mywd.wd_hostname[sizeof(mywd.wd_hostname) - 1] = '\0';
	utmpf = open(_PATH_UTMP, O_RDONLY|O_CREAT, 0644);
	if (utmpf < 0) {
		syslog(LOG_ERR, "%s: %m", _PATH_UTMP);
		exit(1);
	}
	getboottime();
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		syslog(LOG_ERR, "socket: %m");
		exit(1);
	}
	if (setsockopt(s, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on)) < 0) {
		syslog(LOG_ERR, "setsockopt SO_BROADCAST: %m");
		exit(1);
	}
	memset(&sin, 0, sizeof(sin));
	sin.sin_addr.s_addr = INADDR_ANY;
	sin.sin_family = AF_INET;
	sin.sin_port = sp->s_port;
	if (bind(s, (struct sockaddr *)&sin, sizeof(sin)) < 0) {
		syslog(LOG_ERR, "bind: %m");
		exit(1);
	}
	if (!configure())
		exit(1);
	timer();

	gettimeofday(&start, NULL);
	delta.tv_sec = AL_INTERVAL;
	delta.tv_usec = 0;
	timeradd(&start, &delta, &next);

	pfd[0].fd = s;
	pfd[0].events = POLLIN;

	for (;;) {
		int n;

		n = poll(pfd, 1, 1000);

		if (n == 1)
			handleread(s);

		if (gothup) {
			gothup = 0;
			getboottime();
		}

		gettimeofday(&now, NULL);
		if (timercmp(&now, &next, >)) {
			timer();
			timeradd(&now, &delta, &next);
		}
	}
}

void
handleread(int s)
{
	struct sockaddr_in from;
	struct stat st;
	char path[64];
	struct whod wd;
	int cc, whod;
	time_t t;
	socklen_t len = sizeof(from);

	cc = recvfrom(s, (char *)&wd, sizeof(struct whod), 0,
	    (struct sockaddr *)&from, &len);
	if (cc <= 0) {
		if (cc < 0 && errno != EINTR)
			syslog(LOG_WARNING, "recv: %m");
		return;
	}
	if (from.sin_port != sp->s_port) {
		syslog(LOG_WARNING, "%d: bad source port from %s",
		    ntohs(from.sin_port), inet_ntoa(from.sin_addr));
		return;
	}
	if (cc < WHDRSIZE) {
		syslog(LOG_WARNING, "short packet from %s",
		    inet_ntoa(from.sin_addr));
		return;
	}
	if (wd.wd_vers != WHODVERSION)
		return;
	if (wd.wd_type != WHODTYPE_STATUS)
		return;
	wd.wd_hostname[sizeof(wd.wd_hostname)-1] = '\0';
	if (!verify(wd.wd_hostname)) {
		syslog(LOG_WARNING, "malformed host name from %s",
		    inet_ntoa(from.sin_addr));
		return;
	}
	if (debug)
		printf("host %s\n", wd.wd_hostname);

	(void) snprintf(path, sizeof path, "whod.%s", wd.wd_hostname);
	/*
	 * Rather than truncating and growing the file each time,
	 * use ftruncate if size is less than previous size.
	 */
	whod = open(path, O_WRONLY | O_CREAT, 0644);
	if (whod < 0) {
		syslog(LOG_WARNING, "%s: %m", path);
		return;
	}
#if ENDIAN != BIG_ENDIAN
	{
		int i, n = (cc - WHDRSIZE)/sizeof(struct whoent);
		struct whoent *we;

		/* undo header byte swapping before writing to file */
		wd.wd_sendtime = ntohl(wd.wd_sendtime);
		for (i = 0; i < 3; i++)
			wd.wd_loadav[i] = ntohl(wd.wd_loadav[i]);
		wd.wd_boottime = ntohl(wd.wd_boottime);
		we = wd.wd_we;
		for (i = 0; i < n; i++) {
			we->we_idle = ntohl(we->we_idle);
			we->we_utmp.out_time =
			    ntohl(we->we_utmp.out_time);
			we++;
		}
	}
#endif
	(void) time(&t);
	wd.wd_recvtime = t;	/* XXX protocol breaks in 2038 */
	(void) write(whod, (char *)&wd, cc);
	if (fstat(whod, &st) < 0 || st.st_size > cc)
		ftruncate(whod, (off_t)cc);
	(void) close(whod);
}

/*
 * Check out host name for unprintables
 * and other funnies before allowing a file
 * to be created.  Sorry, but blanks aren't allowed.
 */
int
verify(char *p)
{
	char c;

	/*
	 * Many people do not obey RFC 822 and 1035.  The valid
	 * characters are a-z, A-Z, 0-9, '-' and . But the others
	 * tested for below can happen, and we must be more permissive
	 * than the resolver until those idiots clean up their act.
	 */
	if (*p == '.' || *p == '-')
		return 0;
	while ((c = *p++)) {
		if (('a' <= c && c <= 'z') ||
		    ('A' <= c && c <= 'Z') ||
		    ('0' <= c && c <= '9'))
			continue;
		if (c == '.' && *p == '.')
			return 0;
		if (c == '.' || c == '-')
			continue;
		return 0;
	}
	return 1;
}

int	utmptime;
int	utmpent;
int	utmpsize = 0;
struct	utmp *utmp;
int	alarmcount;

void
timer(void)
{
	struct neighbor *np;
	struct whoent *we = mywd.wd_we, *wlast;
	int i;
	struct stat stb;
	double avenrun[3];
	time_t now;
	struct	utmp *nutmp;
	int cc;

	now = time(NULL);
	if (alarmcount % 10 == 0)
		getboottime();
	alarmcount++;
	(void) fstat(utmpf, &stb);

	/* implicitly safe truncation */
	if (stb.st_size > 1024*1024 * sizeof(struct utmp))
		stb.st_size = 1024*1024 * sizeof(struct utmp);

	if ((stb.st_mtime != utmptime) || (stb.st_size > utmpsize)) {
		utmptime = stb.st_mtime;
		if (stb.st_size > utmpsize) {
			int nutmpsize = stb.st_size + 10 * sizeof(struct utmp);
			nutmp = (struct utmp *)realloc(utmp, nutmpsize);
			if (!nutmp) {
				warnx("malloc failed");
				free(utmp);
				utmpsize = 0;
				return;
			}
			utmp = nutmp;
			utmpsize = nutmpsize;
		}
		(void) lseek(utmpf, (off_t)0, SEEK_SET);
		cc = read(utmpf, (char *)utmp, (size_t)stb.st_size);
		if (cc < 0) {
			warnx("%s", _PATH_UTMP);
			return;
		}
		wlast = &mywd.wd_we[1024 / sizeof(struct whoent) - 1];
		utmpent = cc / sizeof(struct utmp);
		for (i = 0; i < utmpent; i++)
			if (utmp[i].ut_name[0]) {
				memcpy(we->we_utmp.out_line, utmp[i].ut_line,
				   sizeof(we->we_utmp.out_line));
				memcpy(we->we_utmp.out_name, utmp[i].ut_name,
				   sizeof(we->we_utmp.out_line));
				we->we_utmp.out_time = htonl(utmp[i].ut_time);
				if (we >= wlast)
					break;
				we++;
			}
		utmpent = we - mywd.wd_we;
	}

	/*
	 * The test on utmpent looks silly---after all, if no one is
	 * logged on, why worry about efficiency?---but is useful on
	 * (e.g.) compute servers.
	 */
	if (utmpent && chdir(_PATH_DEV)) {
		syslog(LOG_ERR, "chdir(%s): %m", _PATH_DEV);
		exit(1);
	}
	we = mywd.wd_we;
	for (i = 0; i < utmpent; i++) {
		if (stat(we->we_utmp.out_line, &stb) >= 0)
			we->we_idle = htonl(now - stb.st_atime);
		we++;
	}
	(void)getloadavg(avenrun, sizeof(avenrun)/sizeof(avenrun[0]));
	for (i = 0; i < 3; i++)
		mywd.wd_loadav[i] = htonl((u_long)(avenrun[i] * 100));
	cc = (char *)we - (char *)&mywd;
	mywd.wd_sendtime = htonl(time(0));
	mywd.wd_vers = WHODVERSION;
	mywd.wd_type = WHODTYPE_STATUS;
	for (np = neighbors; np != NULL; np = np->n_next)
		(void)Sendto(s, &mywd, cc, 0, np->n_addr, np->n_addrlen);
	if (utmpent && chdir(_PATH_RWHODIR)) {
		syslog(LOG_ERR, "chdir(%s): %m", _PATH_RWHODIR);
		exit(1);
	}
}

void
getboottime(void)
{
	int mib[2];
	size_t size;
	struct timeval tm;

	mib[0] = CTL_KERN;
	mib[1] = KERN_BOOTTIME;
	size = sizeof(tm);
	if (sysctl(mib, 2, &tm, &size, NULL, 0) == -1) {
		syslog(LOG_ERR, "cannot get boottime: %m");
		exit(1);
	}
	mywd.wd_boottime = htonl(tm.tv_sec);
}

void
quit(char *msg)
{
	syslog(LOG_ERR, "%s", msg);
	exit(1);
}

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))

void
rt_xaddrs(caddr_t cp, caddr_t cplim, struct rt_addrinfo *rtinfo)
{
	struct sockaddr *sa;
	int i;

	memset(rtinfo->rti_info, 0, sizeof(rtinfo->rti_info));
	for (i = 0; (i < RTAX_MAX) && (cp < cplim); i++) {
		if ((rtinfo->rti_addrs & (1 << i)) == 0)
			continue;
		rtinfo->rti_info[i] = sa = (struct sockaddr *)cp;
		ADVANCE(cp, sa);
	}
}

/*
 * Figure out device configuration and select
 * networks which deserve status information.
 */
int
configure(void)
{
	struct neighbor *np;
	struct if_msghdr *ifm;
	struct ifa_msghdr *ifam;
	struct sockaddr_dl *sdl;
	size_t needed;
	int mib[6], flags = 0, len;
	char *buf = NULL, *lim, *next;
	struct rt_addrinfo info;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = AF_INET;
	mib[4] = NET_RT_IFLIST;
	mib[5] = 0;
	while (1) {
		if (sysctl(mib, 6, NULL, &needed, NULL, 0) == -1)
			quit("route-sysctl-estimate");
		if (needed == 0)
			break;
		if ((buf = realloc(buf, needed)) == NULL)
			quit("realloc");
		if (sysctl(mib, 6, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			quit("actual retrieval of interface table");
		}
		lim = buf + needed;
		break;
	}

	sdl = NULL;		/* XXX just to keep gcc -Wall happy */
	for (next = buf; next < lim; next += ifm->ifm_msglen) {
		ifm = (struct if_msghdr *)next;
		if (ifm->ifm_version != RTM_VERSION)
			continue;
		if (ifm->ifm_type == RTM_IFINFO) {
			sdl = (struct sockaddr_dl *)(ifm + 1);
			flags = ifm->ifm_flags;
			continue;
		}
		if ((flags & IFF_UP) == 0 ||
		    (flags & (IFF_BROADCAST|IFF_POINTOPOINT)) == 0)
			continue;
		if (ifm->ifm_type != RTM_NEWADDR)
			quit("out of sync parsing NET_RT_IFLIST");
		ifam = (struct ifa_msghdr *)ifm;
		info.rti_addrs = ifam->ifam_addrs;
		rt_xaddrs((char *)(ifam + 1), ifam->ifam_msglen + (char *)ifam,
		    &info);
		/* gag, wish we could get rid of Internet dependencies */
#define dstaddr	info.rti_info[RTAX_BRD]
#define IPADDR_SA(x) ((struct sockaddr_in *)(x))->sin_addr.s_addr
#define PORT_SA(x) ((struct sockaddr_in *)(x))->sin_port
		if (dstaddr == 0 || dstaddr->sa_family != AF_INET)
			continue;
		PORT_SA(dstaddr) = sp->s_port;
		for (np = neighbors; np != NULL; np = np->n_next)
			if (memcmp(sdl->sdl_data, np->n_name,
				   sdl->sdl_nlen) == 0 &&
			    IPADDR_SA(np->n_addr) == IPADDR_SA(dstaddr))
				break;
		if (np != NULL)
			continue;
		len = sizeof(*np) + dstaddr->sa_len + sdl->sdl_nlen + 1;
		np = (struct neighbor *)malloc(len);
		if (np == NULL)
			quit("malloc of neighbor structure");
		memset(np, 0, len);
		np->n_flags = flags;
		np->n_addr = (struct sockaddr *)(np + 1);
		np->n_addrlen = dstaddr->sa_len;
		np->n_name = np->n_addrlen + (char *)np->n_addr;
		np->n_next = neighbors;
		neighbors = np;
		memcpy((char *)np->n_addr, (char *)dstaddr, np->n_addrlen);
		memcpy(np->n_name, sdl->sdl_data, sdl->sdl_nlen);
	}
	free(buf);
	return (1);
}

int
Sendto(int s, const void *buf, size_t cc, int flags,
    const struct sockaddr *to, socklen_t tolen)
{
	struct whod *w = (struct whod *)buf;
	struct whoent *we;
	struct sockaddr_in *sin = (struct sockaddr_in *)to;
	int ret;

	ret = sendto(s, buf, cc, flags, to, tolen);
	if (debug) {
		printf("sendto %s.%d\n", inet_ntoa(sin->sin_addr),
		    ntohs(sin->sin_port));
		printf("hostname %s %s\n", w->wd_hostname,
		    interval(ntohl(w->wd_sendtime) - ntohl(w->wd_boottime),
		    "  up"));
		printf("load %4.2f, %4.2f, %4.2f\n",
		    ntohl(w->wd_loadav[0]) / 100.0,
		    ntohl(w->wd_loadav[1]) / 100.0,
		    ntohl(w->wd_loadav[2]) / 100.0);
		cc -= WHDRSIZE;
		for (we = w->wd_we, cc /= sizeof(struct whoent); cc > 0;
		    cc--, we++) {
			time_t t = ntohl(we->we_utmp.out_time);
			printf("%-8.8s %s:%s %.12s",
			    we->we_utmp.out_name,
			    w->wd_hostname, we->we_utmp.out_line,
			    ctime(&t)+4);
			we->we_idle = ntohl(we->we_idle) / 60;
			if (we->we_idle) {
				if (we->we_idle >= 100*60)
					we->we_idle = 100*60 - 1;
				if (we->we_idle >= 60)
					printf(" %2d", we->we_idle / 60);
				else
					printf("   ");
				printf(":%02u", we->we_idle % 60);
			}
			printf("\n");
		}
	}
	return (ret);
}

char *
interval(int time, char *updown)
{
	static char resbuf[32];
	int days, hours, minutes;

	if (time < 0 || time > 3*30*24*60*60) {
		(void) snprintf(resbuf, sizeof(resbuf),
		    "   %s ??:??", updown);
		return (resbuf);
	}
	minutes = (time + 59) / 60;		/* round to minutes */
	hours = minutes / 60; minutes %= 60;
	days = hours / 24; hours %= 24;
	if (days)
		(void) snprintf(resbuf, sizeof(resbuf),
		    "%s %2d+%02d:%02d", updown, days, hours, minutes);
	else
		(void) snprintf(resbuf, sizeof(resbuf),
		    "%s    %2d:%02d", updown, hours, minutes);
	return (resbuf);
}
@


1.36
log
@Use destination bound rather than the source bound for out_line and
out_name.  OK millert@@.
@
text
@@


1.35
log
@handle large time_t at least until 2038.  then chaos breaks out.
ok guenther
note to tedu: 2038 -> rwhod
@
text
@d377 1
a377 1
				   sizeof(utmp[i].ut_line));
d379 1
a379 1
				   sizeof(utmp[i].ut_name));
@


1.34
log
@create realloc() loops around sysctl for array-based mibs, in programs
which want a "full" dump
ok dlg
@
text
@d222 1
d284 2
a285 1
	(void) time((time_t *)&wd.wd_recvtime);
@


1.33
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d472 1
a472 1
	char *buf, *lim, *next;
d481 15
a495 7
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
		quit("route-sysctl-estimate");
	if ((buf = malloc(needed)) == NULL)
		quit("malloc");
	if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
		quit("actual retrieval of interface table");
	lim = buf + needed;
@


1.32
log
@Another daemon needing RTM_VERSION checks. Why rwhod is doing all the hard
work instead of using getifaddrs() and working on this much simpler structure
is beyond my immagination. Looked over by henning@@ and sthen@@
@
text
@a29 11
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
/*static char sccsid[] = "@@(#)rwhod.c	8.1 (Berkeley) 6/6/93";*/
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.31 2006/01/02 16:29:53 millert Exp $";
#endif /* not lint */

@


1.31
log
@#include <signal.h>, not <sys/signal.h>
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.30 2004/09/16 08:55:00 deraadt Exp $";
d503 2
@


1.30
log
@various lint.  ok millert
Important bit: do not long -> int truncate...
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.29 2003/09/26 07:15:41 deraadt Exp $";
a43 1
#include <sys/signal.h>
d60 1
@


1.29
log
@realloc tuning; pvalchev ok
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.28 2003/06/08 17:05:36 mickey Exp $";
d101 1
a101 1
int	 configure(int);
d113 1
d192 1
a192 1
	if (!configure(s))
d297 1
a297 1
		ftruncate(whod, cc);
d356 5
d376 1
a376 1
		cc = read(utmpf, (char *)utmp, stb.st_size);
d475 1
a475 1
configure(int s)
d516 1
a516 1
			&info);
@


1.28
log
@use err/warn
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.27 2003/06/02 23:36:54 millert Exp $";
d358 2
a359 5
			utmpsize = stb.st_size + 10 * sizeof(struct utmp);
			if (utmp)
				nutmp = (struct utmp *)realloc(utmp, utmpsize);
			else
				nutmp = (struct utmp *)malloc(utmpsize);
d362 1
a362 2
				if (utmp)
					free(utmp);
d367 1
@


1.27
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.26 2003/03/05 02:41:35 deraadt Exp $";
d67 1
d122 2
a123 1
	fprintf(stderr, "usage: rwhod [-d]\n");
d146 2
a147 4
	if (getuid()) {
		fprintf(stderr, "rwhod: not super user\n");
		exit(1);
	}
d149 4
a152 9
	if (sp == NULL) {
		fprintf(stderr, "rwhod: udp/who: unknown service\n");
		exit(1);
	}
	if (chdir(_PATH_RWHODIR) < 0) {
		(void)fprintf(stderr, "rwhod: %s: %s\n",
		    _PATH_RWHODIR, strerror(errno));
		exit(1);
	}
d364 1
a364 1
				fprintf(stderr, "rwhod: malloc failed\n");
d375 1
a375 2
			fprintf(stderr, "rwhod: %s: %s\n",
			    _PATH_UTMP, strerror(errno));
@


1.26
log
@delete bogus debug msg
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d38 1
a38 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.25 2002/09/06 19:46:52 deraadt Exp $";
@


1.25
log
@use more socklen_t; pvalchev
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.24 2002/07/14 03:52:35 deraadt Exp $";
a422 1
printf("sending cc = %d\n", cc);
@


1.24
log
@ansi
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.23 2002/05/30 19:09:05 deraadt Exp $";
d240 2
a241 1
	int cc, whod, len = sizeof(from);
@


1.23
log
@minor KNF
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.22 2002/03/14 16:44:25 mpech Exp $";
d117 1
a117 2
hup(signo)
	int signo;
d130 1
a130 3
main(argc, argv)
	int argc;
	char *argv[];
d234 1
a234 2
handleread(s)
	int s;
d314 1
a314 2
verify(p)
	char *p;
d347 1
a347 1
timer()
d435 1
a435 1
getboottime()
d452 1
a452 2
quit(msg)
	char *msg;
d463 1
a463 3
rt_xaddrs(cp, cplim, rtinfo)
	caddr_t cp, cplim;
	struct rt_addrinfo *rtinfo;
d482 1
a482 2
configure(s)
	int s;
d557 2
a558 7
Sendto(s, buf, cc, flags, to, tolen)
	int s;
	const void *buf;
	size_t cc;
	int flags;
	const struct sockaddr *to;
	socklen_t tolen;
d601 1
a601 3
interval(time, updown)
	int time;
	char *updown;
@


1.22
log
@kill more registers.

millert@@ ok
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.21 2002/02/17 19:42:39 millert Exp $";
d140 1
a140 1
	
@


1.21
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.20 2002/02/16 21:28:09 millert Exp $";
d319 1
a319 1
	register char *p;
d354 3
a356 3
	register struct neighbor *np;
	register struct whoent *we = mywd.wd_we, *wlast;
	register int i;
d470 2
a471 2
	register caddr_t cp, cplim;
	register struct rt_addrinfo *rtinfo;
d473 2
a474 2
	register struct sockaddr *sa;
	register int i;
d493 3
a495 3
	register struct neighbor *np;
	register struct if_msghdr *ifm;
	register struct ifa_msghdr *ifam;
d574 2
a575 2
	register struct whod *w = (struct whod *)buf;
	register struct whoent *we;
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.19 2001/11/17 19:49:40 deraadt Exp $";
d112 2
a113 2
int	 Sendto __P((int, const void *, size_t, int,
	    const struct sockaddr *, socklen_t));
@


1.19
log
@use volatile sig_atomic_t where possible; simply volatile i other places
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.18 2001/11/14 21:36:37 millert Exp $";
d104 8
a111 8
int	 configure __P((int));
void	 getboottime __P((void));
void	 hup __P((int));
void	 timer __P((void));
void	 quit __P((char *));
void	 rt_xaddrs __P((caddr_t, caddr_t, struct rt_addrinfo *));
int	 verify __P((char *));
void	 handleread __P((int s));
d114 1
a114 1
char	*interval __P((int, char *));
@


1.18
log
@Move call to daemon() after chdir() so any error message printed
on chdir error doesn't go to /dev/null; Janjaap van Velthooven
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.17 2001/03/31 20:07:56 fgsch Exp $";
d100 1
a100 1
int	gothup;
@


1.17
log
@Log on short packets before discard'em; millert@@ ok.
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.16 2001/02/08 15:03:20 deraadt Exp $";
a159 3
	if (!debug)
		daemon(1, 0);

d165 3
@


1.16
log
@put debug code in by default, and make it work
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.15 2001/01/11 23:41:42 deraadt Exp $";
d258 3
a260 1
	if (cc < WHDRSIZE)
d262 1
@


1.15
log
@nearly a complete rewrite.  use poll(), no more signals, no more races,
no more bullshit.  someone use this?  please run with it.
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.14 2000/12/23 02:19:03 deraadt Exp $";
d57 1
d80 2
d90 1
a90 1
	struct	sockaddr *n_addr;		/* who to send to */
d112 2
a113 1
#ifdef DEBUG
a114 3
void	 Sendto __P((int, char *, int, int, char *, int));
#define	 sendto Sendto
#endif
d123 7
d133 1
a133 1
	char argv[];
d135 2
d138 1
a138 1
	int on = 1;
d140 10
a149 2
	struct sockaddr_in sin;
	struct timeval start, next, delta, now;
d160 3
a162 3
#ifndef DEBUG
	daemon(1, 0);
#endif
d196 1
d213 1
a213 1
	pfd[0].revents = POLLIN;
d220 3
a227 3
		if (n == 1)
			handleread(s);

d270 3
d424 1
d429 1
a429 2
		(void)sendto(s, (char *)&mywd, cc, 0,
		    np->n_addr, np->n_addrlen);
d562 1
a562 2
#ifdef DEBUG
void
d565 5
a569 4
	char *buf;
	int cc, flags;
	char *to;
	int tolen;
d574 1
d576 30
a605 23
	printf("sendto %s.%d\n", inet_ntoa(sin->sin_addr),
	    ntohs(sin->sin_port));
	printf("hostname %s %s\n", w->wd_hostname,
	    interval(ntohl(w->wd_sendtime) - ntohl(w->wd_boottime), "  up"));
	printf("load %4.2f, %4.2f, %4.2f\n",
	    ntohl(w->wd_loadav[0]) / 100.0, ntohl(w->wd_loadav[1]) / 100.0,
	    ntohl(w->wd_loadav[2]) / 100.0);
	cc -= WHDRSIZE;
	for (we = w->wd_we, cc /= sizeof(struct whoent); cc > 0; cc--, we++) {
		time_t t = ntohl(we->we_utmp.out_time);
		printf("%-8.8s %s:%s %.12s",
		    we->we_utmp.out_name,
		    w->wd_hostname, we->we_utmp.out_line,
		    ctime(&t)+4);
		we->we_idle = ntohl(we->we_idle) / 60;
		if (we->we_idle) {
			if (we->we_idle >= 100*60)
				we->we_idle = 100*60 - 1;
			if (we->we_idle >= 60)
				printf(" %2d", we->we_idle / 60);
			else
				printf("   ");
			printf(":%02d", we->we_idle % 60);
a606 1
		printf("\n");
d608 1
a634 1
#endif
@


1.14
log
@if a short rwhod packet arrived on a little endian machine, all stack memory
from a local buffer till it runs into the signal trampoline, is long-word
byte swapped, then it receives SIGSEGV.  and this program has a timer
signal handler, which does WAY too much, completely violating rules as to
what a signal handler may do.  totally sick shit.
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.13 2000/06/28 23:57:36 deraadt Exp $";
d61 1
d97 2
d102 3
a104 2
void	 getboottime __P((int));
void	 onalrm __P((int));
d108 1
d115 7
d127 1
a127 3
	struct sockaddr_in from;
	struct stat st;
	char path[64];
d131 1
d150 1
a150 1
	(void) signal(SIGHUP, getboottime);
d168 1
a168 1
	getboottime(0);
d186 10
a195 2
	signal(SIGALRM, onalrm);
	onalrm(0);
d197 3
a199 2
		struct whod wd;
		int cc, whod, len = sizeof(from);
d201 3
a203 6
		cc = recvfrom(s, (char *)&wd, sizeof(struct whod), 0,
		    (struct sockaddr *)&from, &len);
		if (cc <= 0) {
			if (cc < 0 && errno != EINTR)
				syslog(LOG_WARNING, "recv: %m");
			continue;
d205 8
a212 26
		if (from.sin_port != sp->s_port) {
			syslog(LOG_WARNING, "%d: bad source port from %s",
			    ntohs(from.sin_port), inet_ntoa(from.sin_addr));
			continue;
		}
		if (cc < WHDRSIZE)
			continue;
		if (wd.wd_vers != WHODVERSION)
			continue;
		if (wd.wd_type != WHODTYPE_STATUS)
			continue;
		wd.wd_hostname[sizeof(wd.wd_hostname)-1] = '\0';
		if (!verify(wd.wd_hostname)) {
			syslog(LOG_WARNING, "malformed host name from %s",
			    inet_ntoa(from.sin_addr));
			continue;
		}
		(void) snprintf(path, sizeof path, "whod.%s", wd.wd_hostname);
		/*
		 * Rather than truncating and growing the file each time,
		 * use ftruncate if size is less than previous size.
		 */
		whod = open(path, O_WRONLY | O_CREAT, 0644);
		if (whod < 0) {
			syslog(LOG_WARNING, "%s: %m", path);
			continue;
d214 47
d262 15
a276 16
		{
			int i, n = (cc - WHDRSIZE)/sizeof(struct whoent);
			struct whoent *we;

			/* undo header byte swapping before writing to file */
			wd.wd_sendtime = ntohl(wd.wd_sendtime);
			for (i = 0; i < 3; i++)
				wd.wd_loadav[i] = ntohl(wd.wd_loadav[i]);
			wd.wd_boottime = ntohl(wd.wd_boottime);
			we = wd.wd_we;
			for (i = 0; i < n; i++) {
				we->we_idle = ntohl(we->we_idle);
				we->we_utmp.out_time =
				    ntohl(we->we_utmp.out_time);
				we++;
			}
d278 1
d280 5
a284 6
		(void) time((time_t *)&wd.wd_recvtime);
		(void) write(whod, (char *)&wd, cc);
		if (fstat(whod, &st) < 0 || st.st_size > cc)
			ftruncate(whod, cc);
		(void) close(whod);
	}
d327 1
a327 2
onalrm(signo)
	int signo;
a328 1
	int save_errno = errno;
d340 1
a340 1
		getboottime(0);
d356 1
a356 1
				goto done;
d365 1
a365 1
			goto done;
a411 3
done:
	(void) alarm(AL_INTERVAL);
	errno = save_errno;
d415 1
a415 2
getboottime(signo)
	int signo;
d590 2
a591 1
		(void) sprintf(resbuf, "   %s ??:??", updown);
d598 2
a599 2
		(void) sprintf(resbuf, "%s %2d+%02d:%02d",
		    updown, days, hours, minutes);
d601 2
a602 2
		(void) sprintf(resbuf, "%s    %2d:%02d",
		    updown, hours, minutes);
@


1.13
log
@in quit(), be more careful about possible nasty parameters in the future
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.12 1998/08/16 21:22:18 deraadt Exp $";
d182 1
a182 1
			(struct sockaddr *)&from, &len);
d189 2
a190 2
			syslog(LOG_WARNING, "%d: bad from port",
				ntohs(from.sin_port));
d193 2
d285 1
d364 1
a364 1
				np->n_addr, np->n_addrlen);
d371 1
d514 2
a515 1
	printf("sendto %x.%d\n", ntohl(sin->sin_addr), ntohs(sin->sin_port));
d517 1
a517 1
	   interval(ntohl(w->wd_sendtime) - ntohl(w->wd_boottime), "  up"));
d525 3
a527 3
			we->we_utmp.out_name,
			w->wd_hostname, we->we_utmp.out_line,
			ctime(&t)+4);
@


1.12
log
@fix realloc use
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.11 1998/07/13 02:11:51 millert Exp $";
d392 1
a392 1
	syslog(LOG_ERR, msg);
@


1.11
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.10 1998/04/30 08:45:03 deraadt Exp $";
d289 1
d302 1
a302 1
				utmp = (struct utmp *)realloc(utmp, utmpsize);
d304 2
a305 2
				utmp = (struct utmp *)malloc(utmpsize);
			if (! utmp) {
d307 2
d312 1
@


1.10
log
@use inet_ntoa
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.9 1997/04/14 07:01:42 deraadt Exp $";
d310 1
a310 1
		(void) lseek(utmpf, (off_t)0, L_SET);
@


1.9
log
@i was not the brightest here either
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.8 1997/04/13 01:53:49 deraadt Exp $";
d199 2
a200 2
			syslog(LOG_WARNING, "malformed host name from %x",
				from.sin_addr);
@


1.8
log
@check host information more carefully
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.7 1997/03/26 00:45:57 deraadt Exp $";
d260 3
a262 3
		if (('a' <= c && c >= 'z') ||
		    ('A' <= c && c >= 'Z') ||
		    ('0' <= c && c >= '9'))
d264 1
a264 2
		if (strchr("-_/[]\\", c) || 
		    (c == '.' && *p == '.'))
d266 3
@


1.7
log
@clean; netbsd
@
text
@d42 1
a42 1
static char rcsid[] = "$OpenBSD: rwhod.c,v 1.6 1997/01/17 07:14:28 millert Exp $";
d246 2
a247 2
verify(name)
	register char *name;
d249 1
a249 1
	register int size = 0;
d251 16
a266 4
	while (*name) {
		if (!isascii(*name) || !(isalnum(*name) || ispunct(*name)))
			return (0);
		name++, size++;
d268 1
a268 1
	return (size > 0);
@


1.6
log
@r?index -> strr?chr
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: rwhod.c,v 1.5 1996/11/01 06:53:48 deraadt Exp $";
@


1.5
log
@gethostname correctly
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: rwhod.c,v 1.4 1996/11/01 06:53:25 imp Exp $";
d148 1
a148 1
	if ((cp = index(myname, '.')) != NULL)
@


1.4
log
@Revert obvious comment
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: rwhod.c,v 1.3 1996/11/01 06:45:45 imp Exp $";
d144 1
a144 1
	if (gethostname(myname, sizeof(myname) - 1) < 0) {
@


1.3
log
@Buffer oflow possible, but unlikely
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: rwhod.c,v 1.2 1996/08/16 23:24:58 deraadt Exp $";
d142 1
a142 2
	 * Establish host name as returned by system.  The -1 plus myname
	 * being global ensure that myname is NUL terminated.
@


1.2
log
@buf oflow; from dholland@@hcs.harvard.edu
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: rwhod.c,v 1.1.1.1 1995/10/18 08:48:07 deraadt Exp $";
d142 2
a143 1
	 * Establish host name as returned by system.
d151 2
a152 1
	strncpy(mywd.wd_hostname, myname, sizeof(myname) - 1);
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
static char rcsid[] = "$Id: rwhod.c,v 1.8 1994/05/29 02:53:23 jtc Exp $";
d196 1
d202 1
a202 1
		(void) sprintf(path, "whod.%s", wd.wd_hostname);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
