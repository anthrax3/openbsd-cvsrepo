head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.2
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.8
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.15.0.12
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.8
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.4
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.8
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.10
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.6
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.18
date	2016.08.14.18.34.48;	author guenther;	state Exp;
branches;
next	1.17;
commitid	PKvTittpF6Ut9SpV;

1.17
date	2015.12.21.21.37.09;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	eJHG4MRXdv29IeSj;

1.16
date	2014.04.12.15.57.50;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2011.09.20.08.28.51;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2011.06.06.14.59.16;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.20.16.10.27;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.02.15.19.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.14.19.23.16;	author moritz;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.04.03.08.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.26.16.09.27;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.26.19.47.09;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.13.09.09.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.14.21.01.01;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.30.19.09.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.28.04;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.27.20.34.36;	author pvalchev;	state Exp;
branches;
next	1.2;

1.2
date	99.12.05.06.32.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.11.20.11.22.54;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Convert remaining calls to strtoq/strtouq in base with strtoll/strtoull.
Fix a type mismatch in ftp's "page" command and could make transfers restart
at the wrong position.

ok and a ull->ll tweak from natano@@, ok tedu@@
@
text
@/* $OpenBSD: memconfig.c,v 1.17 2015/12/21 21:37:09 mmcc Exp $ */

/*-
 * Copyright (c) 1999 Michael Smith <msmith@@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: /home/ncvs/src/usr.sbin/memcontrol/memcontrol.c,v 1.8 2002/09/15 15:07:55 dwmalone Exp $
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/memrange.h>

#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

struct {
	const char	*name;
	int		val;
	int		kind;
#define MDF_SETTABLE	(1<<0)
} attrnames[] = {
	{"uncacheable",		MDF_UNCACHEABLE,	MDF_SETTABLE},
	{"write-combine",	MDF_WRITECOMBINE,	MDF_SETTABLE},
	{"write-through",	MDF_WRITETHROUGH,	MDF_SETTABLE},
	{"write-back",		MDF_WRITEBACK,		MDF_SETTABLE},
	{"write-protect",	MDF_WRITEPROTECT,	MDF_SETTABLE},
	{"force",		MDF_FORCE,		MDF_SETTABLE},
	{"unknown",		MDF_UNKNOWN,		0},
	{"fixed-base",		MDF_FIXBASE,		0},
	{"fixed-length",	MDF_FIXLEN,		0},
	{"set-by-firmware",	MDF_FIRMWARE,		0},
	{"active",		MDF_ACTIVE,		MDF_SETTABLE},
	{"fix-active",		MDF_FIXACTIVE,		0},
	{"bogus",		MDF_BOGUS,		0},
	{NULL,			0,			0}
};

static void	listfunc(int, int, char *[]);
static void	setfunc(int, int, char *[]);
static void	clearfunc(int, int, char *[]);
static void	helpfunc(int, int, char *[]);
static void	help(const char *);
static struct mem_range_desc *mrgetall(int, int *);

struct
{
	const char	*cmd;
	const char	*desc;
	void	(*func)(int, int, char *[]);
} functions[] = {
	{"list",
	 "List current memory range attributes\n"
	 "    list [-a]\n"
	 "        -a    list all range slots, even those that are inactive",
	 listfunc},
	{"set",
	 "Set memory range attributes\n"
	 "    set -b <base> -l <length> -o <owner> <attribute>\n"
	 "        <base>      memory range base address\n"
	 "        <length>    length of memory range in bytes, power of 2\n"
	 "        <owner>     text identifier for this setting (7 char max)\n"
	 "        <attribute> attribute(s) to be applied to this range:\n"
	 "                        uncacheable\n"
	 "                        write-combine\n"
	 "                        write-through\n"
	 "                        write-back\n"
	 "                        write-protect",
	 setfunc},
	{"clear",
	 "Clear memory range attributes\n"
	 "    clear -o <owner>\n"
	 "        <owner>     all ranges with this owner will be cleared\n"
	 "    clear -b <base> -l <length>\n"
	 "        <base>      memory range base address\n"
	 "        <length>    length of memory range in bytes, power of 2\n"
	 "                    Base and length must exactly match an existing range",
	 clearfunc},
	{NULL,	NULL,					helpfunc}
};

int
main(int argc, char *argv[])
{
	int	 i, memfd = -1;

	if (argc < 2) {
		help(NULL);
	} else {
		for (i = 0; functions[i].cmd != NULL; i++)
			if (!strcmp(argv[1], functions[i].cmd))
				break;
		
		if ((functions[i].func != helpfunc) &&
		    (memfd = open("/dev/mem", O_RDONLY)) == -1)
			err(1, "can't open /dev/mem");
		functions[i].func(memfd, argc - 1, argv + 1);
		close(memfd);
	}
	return(0);
}

static struct mem_range_desc *
mrgetall(int memfd, int *nmr)
{
	struct mem_range_desc	*mrd;
	struct mem_range_op	mro;

	mro.mo_arg[0] = 0;
	if (ioctl(memfd, MEMRANGE_GET, &mro))
		err(1, "can't size range descriptor array");

	*nmr = mro.mo_arg[0];
	mrd = calloc(*nmr, sizeof(struct mem_range_desc));
	if (mrd == NULL)
		errx(1, "can't allocate %zu bytes for %d range descriptors",
		     *nmr * sizeof(struct mem_range_desc), *nmr);

	mro.mo_arg[0] = *nmr;
	mro.mo_desc = mrd;
	if (ioctl(memfd, MEMRANGE_GET, &mro))
		err(1, "can't fetch range descriptor array");

	return(mrd);
}


static void
listfunc(int memfd, int argc, char *argv[])
{
	int	nd, i, j, k, ch, showall = 0;
	struct mem_range_desc	*mrd;
	char	*owner;

	owner = NULL;
	while ((ch = getopt(argc, argv, "ao:")) != -1)
		switch(ch) {
		case 'a':
			showall = 1;
			break;
		case 'o':
			if (!(owner = strdup(optarg)))
				errx(1, "out of memory");
			break;
		default:
			help("list");
		}

	mrd = mrgetall(memfd, &nd);

	for (i = 0; i < nd; i++) {
		if (!showall && !(mrd[i].mr_flags & MDF_ACTIVE))
			continue;
		if (owner && strcmp(mrd[i].mr_owner, owner))
			continue;
		printf("%llx/%llx %.8s ", mrd[i].mr_base, mrd[i].mr_len,
		       mrd[i].mr_owner[0] ? mrd[i].mr_owner : "-");
		for (j = 0; j < 32; j++) {
			if ( ((1<<j) & mrd[i].mr_flags) == 0)
				continue;
			for (k = 0; attrnames[k].name != NULL; k++)
				if (((1<<j) & mrd[i].mr_flags) & attrnames[k].val) {
					printf("%s ", attrnames[k].name);
					break;
				}
			if (attrnames[k].name == NULL)
				printf("0x%x", (1<<j) & mrd[i].mr_flags);
		}
		printf("\n");
	}
	free(mrd);
	free(owner);
}

static void
setfunc(int memfd, int argc, char *argv[])
{
	struct mem_range_desc	 mrd;
	struct mem_range_op	 mro;
	int	 i, ch;
	char	*ep;

	mrd.mr_base = 0;
	mrd.mr_len = 0;
	mrd.mr_flags = 0;
	strlcpy(mrd.mr_owner, "user", sizeof mrd.mr_owner);

	while ((ch = getopt(argc, argv, "b:l:o:")) != -1)
		switch(ch) {
		case 'b':
			mrd.mr_base = strtoull(optarg, &ep, 0);
			if ((ep == optarg) || (*ep != 0))
				help("set");
			break;
		case 'l':
			mrd.mr_len = strtoull(optarg, &ep, 0);
			if ((ep == optarg) || (*ep != 0))
				help("set");
			break;
		case 'o':
			if (*optarg == 0 ||
			    strlen(optarg) > sizeof(mrd.mr_owner)-1)
				help("set");
			strlcpy(mrd.mr_owner, optarg, sizeof mrd.mr_owner);
			break;
		default:
			help("set");
		}

	if (mrd.mr_len == 0)
		help("set");

	argc -= optind;
	argv += optind;

	while(argc--) {
		for (i = 0; attrnames[i].name != NULL; i++) {
			if (!strcmp(attrnames[i].name, argv[0])) {
				if (!(attrnames[i].kind & MDF_SETTABLE))
					help("flags");
				mrd.mr_flags |= attrnames[i].val;
				break;
			}
		}
		if (attrnames[i].name == NULL)
			help("flags");
		argv++;
	}

	mro.mo_desc = &mrd;
	mro.mo_arg[0] = 0;
	if (ioctl(memfd, MEMRANGE_SET, &mro))
		err(1, "can't set range");
}

static void
clearfunc(int memfd, int argc, char *argv[])
{
	struct mem_range_desc	 mrd, *mrdp;
	struct mem_range_op      mro;
	int	i, nd, ch, got_base = 0;
	char	*ep, *owner;

	mrd.mr_base = 0;
	mrd.mr_len = 0;
	owner = NULL;
	while ((ch = getopt(argc, argv, "b:l:o:")) != -1)
		switch(ch) {
		case 'b':
			mrd.mr_base = strtoull(optarg, &ep, 0);
			if ((ep == optarg) || (*ep != 0))
				help("clear");
			else
				got_base = 1;
			break;
		case 'l':
			mrd.mr_len = strtoull(optarg, &ep, 0);
			if ((ep == optarg) || (*ep != 0))
				help("clear");
			break;
		case 'o':
			if ((*optarg == 0) || (strlen(optarg) > 7))
				help("clear");
			if (!(owner = strdup(optarg)))
				errx(1, "out of memory");
			break;

		default:
			help("clear");
		}

	if (owner != NULL) {
		/* clear-by-owner */
		if (got_base || mrd.mr_len != 0)
			help("clear");

		mrdp = mrgetall(memfd, &nd);
		mro.mo_arg[0] = MEMRANGE_SET_REMOVE;
		for (i = 0; i < nd; i++) {
			if (!strcmp(owner, mrdp[i].mr_owner) &&
			    (mrdp[i].mr_flags & MDF_ACTIVE) &&
			    !(mrdp[i].mr_flags & MDF_FIXACTIVE)) {

				mro.mo_desc = mrdp + i;
				if (ioctl(memfd, MEMRANGE_SET, &mro))
					warn("couldn't clear range owned by '%s'",
					    owner);
			}
		}
	} else if (got_base && mrd.mr_len != 0) {
		/* clear-by-base/len */
		mro.mo_arg[0] = MEMRANGE_SET_REMOVE;
		mro.mo_desc = &mrd;
		if (ioctl(memfd, MEMRANGE_SET, &mro))
			err(1, "couldn't clear range");
	} else {
		help("clear");
	}
}

static void
helpfunc(int memfd, int argc, char *argv[])
{
	help(argv[1]);
}

static void
help(const char *what)
{
	int	 i;

	if (what != NULL) {
		/* find a function that matches */
		for (i = 0; functions[i].cmd != NULL; i++)
			if (!strcmp(what, functions[i].cmd)) {
				fprintf(stderr, "%s\n", functions[i].desc);
				return;
			}
		fprintf(stderr, "Unknown command '%s'\n", what);
	}

	/* print general help */
	fprintf(stderr, "Valid commands are :\n");
	for (i = 0; functions[i].cmd != NULL; i++)
		fprintf(stderr, "    %s\n", functions[i].cmd);
	fprintf(stderr, "Use help <command> for command-specific help\n");
}
@


1.17
log
@remove NULL-check before free()
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.16 2014/04/12 15:57:50 jsg Exp $ */
d181 1
a181 1
		printf("%qx/%qx %.8s ", mrd[i].mr_base, mrd[i].mr_len,
d216 1
a216 1
			mrd.mr_base = strtouq(optarg, &ep, 0);
d221 1
a221 1
			mrd.mr_len = strtouq(optarg, &ep, 0);
d275 1
a275 1
			mrd.mr_base = strtouq(optarg, &ep, 0);
d282 1
a282 1
			mrd.mr_len = strtouq(optarg, &ep, 0);
@


1.16
log
@fix a bit test
from FreeBSD rev 241829
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.15 2011/09/20 08:28:51 deraadt Exp $ */
d197 1
a197 2
	if (owner)
		free(owner);
@


1.15
log
@report the "fix-active" flag, and print any other unknown flags in hex.
ok oga kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.14 2011/06/06 14:59:16 tedu Exp $ */
d245 1
a245 1
				if (!attrnames[i].kind & MDF_SETTABLE)
@


1.14
log
@don't open /dev/mem to print the help, allowing mortals to read it
ok deraadt matthew
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.13 2010/04/20 16:10:27 marco Exp $ */
d59 1
d156 1
a156 1
	int	nd, i, j, ch, showall = 0;
d183 11
a193 3
		for (j = 0; attrnames[j].name != NULL; j++)
			if (mrd[i].mr_flags & attrnames[j].val)
				printf("%s ", attrnames[j].name);
@


1.13
log
@0x0 is a valid base address.

ok oga
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.12 2007/09/02 15:19:39 deraadt Exp $ */
d109 1
a109 1
	int	 i, memfd;
a113 3
		if ((memfd = open("/dev/mem", O_RDONLY)) == -1)
			err(1, "can't open /dev/mem");

d117 4
@


1.12
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.11 2006/03/14 19:23:16 moritz Exp $ */
d257 1
a257 1
	int	i, nd, ch;
d269 2
d290 1
a290 1
		if ((mrd.mr_base != 0) || (mrd.mr_len != 0))
d306 1
a306 1
	} else if ((mrd.mr_base != 0) && (mrd.mr_len != 0)) {
@


1.11
log
@Some more usage of const and correct fmt string for a size_t.
From David Hill. ok ray@@ jaredy@@ otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.10 2003/12/04 03:08:26 deraadt Exp $ */
d137 1
a137 1
	mrd = malloc(*nmr * sizeof(struct mem_range_desc));
@


1.10
log
@ansi
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.9 2003/09/26 16:09:27 deraadt Exp $ */
d43 1
a43 1
	char	*name;
d67 1
a67 1
static void	help(char *);
d72 2
a73 2
	char	*cmd;
	char	*desc;
d139 1
a139 1
		errx(1, "can't allocate %d bytes for %d range descriptors",
d322 1
a322 1
help(char *what)
@


1.9
log
@check strdup failure; ok anil millert
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.8 2003/06/26 19:47:09 deraadt Exp $ */
d42 1
a42 2
struct
{
d130 1
a130 1
	struct mem_range_op		mro;
d152 1
a152 4
listfunc(memfd, argc, argv)
	int	 memfd;
	int	 argc;
	char	*argv[];
d154 1
d156 1
a156 4
	int			 nd, i, j;
	int			 ch;
	int			 showall = 0;
	char			*owner;
a167 1
		case '?':
d192 1
a192 4
setfunc(memfd, argc, argv)
	int	 memfd;
	int	 argc;
	char	*argv[];
d196 2
a197 3
	int			 i;
	int			 ch;
	char			*ep;
d203 1
a221 2

		case '?':
d253 1
a253 4
clearfunc(memfd, argc, argv)
	int	 memfd;
	int	 argc;
	char	*argv[];
d257 2
a258 3
	int			 i, nd;
	int			 ch;
	char			*ep, *owner;
a281 1
		case '?':
d300 2
a301 1
					warn("couldn't clear range owned by '%s'", owner);
d316 1
a316 4
helpfunc(memfd, argc, argv)
	int	 memfd;
	int	 argc;
	char	*argv[];
d322 1
a322 2
help(what)
	char	*what;
@


1.8
log
@strict proto cleanups
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.7 2003/03/13 09:09:48 deraadt Exp $ */
d171 2
a172 1
			owner = strdup(optarg);
d294 2
a295 1
			owner = strdup(optarg);
@


1.7
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.6 2002/10/14 21:01:01 matthieu Exp $ */
d69 1
d108 1
a108 3
main(argc, argv)
	int	 argc;
	char	*argv[];
d128 1
a128 3
mrgetall(memfd, nmr)
	int	 memfd;
	int	*nmr;
@


1.6
log
@Fix from FreeBSD for atlhon problems with mtrr and XFree86. Ok deraadt@@

FreeBSD commit messages say:

Some BIOSs are using MTRR values that are only documented under NDA
to control the mapping of things like the ACPI and APM into memory.

The problem is that starting X changes these values, so if something
was using the bits of BIOS mapped into memory (say ACPI or APM),
then next time they access this memory the machine would hang.

This patch refuse to change MTRR values it doesn't understand,
unless a new "force" option is given. This means X doesn't change
them by accident but someone can override that if they really want
to.

PR:             28418
Tested by:      Christopher Masto <chris at netmonger dot net>,
                David Bushong <david at bushong dot net>,
                Santos <casd at myrealbox dot com>


Make the MTRR code a bit more defensive - this should help people
trying to run X on some Athlon systems where the BIOS does odd things
(mines an ASUS A7A266, but it seems to also help on other systems).

Here's a description of the problem and my fix:

        The problem with the old MTRR code is that it only expects
        to find documented values in the bytes of MTRR registers.
        To convert the MTRR byte into a FreeBSD "Memory Range Type"
        (mrt) it uses the byte value and looks it up in an array.
        If the value is not in range then the mrt value ends up
        containing random junk.

        This isn't an immediate problem. The mrt value is only used
        later when rewriting the MTRR registers. When we finally
        go to write a value back again, the function i686_mtrrtype()
        searches for the junk value and returns -1 when it fails
        to find it. This is converted to a byte (0xff) and written
        back to the register, causing a GPF as 0xff is an illegal
        value for a MTRR byte.

        To work around this problem I've added a new mrt flag
        MDF_UNKNOWN.  We set this when we read a MTRR byte which
        we do not understand.  If we try to convert a MDF_UNKNOWN
        back into a MTRR value, then the new function, i686_mrt2mtrr,
        just returns the old value of the MTRR byte. This leaves
        the memory range type unchanged.

I have seen one side effect of the fix, which is that ACPI calls
after X has been run seem to hang my machine. As running X would
previously panic the machine, this is still an improvement ;-)

PR:             28418, 25958
Tested by:      jkh, Christopher Masto <chris at netmonger dot net>
@
text
@d1 2
a2 1
/* $OpenBSD: memconfig.c,v 1.5 2002/05/30 19:09:05 deraadt Exp $ */
d215 1
a215 1
	strcpy(mrd.mr_owner, "user");
d232 1
a232 1
			strcpy(mrd.mr_owner, optarg);
@


1.5
log
@minor KNF
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.4 2002/02/16 21:28:04 millert Exp $ */
d27 1
a27 1
 * $FreeBSD: src/usr.sbin/memcontrol/memcontrol.c,v 1.3 1999/08/28 01:17:00 peter Exp $
d53 2
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.3 2001/07/27 20:34:36 pvalchev Exp $ */
d67 1
a67 1
struct 
d73 1
a73 1
	{"list",	
d78 1
a78 1
	{"set",	
d91 1
a91 1
	{"clear",	
d105 2
a106 2
	int 	 argc;
	char 	*argv[];
d115 1
a115 1
		
d127 2
a128 2
	int 	 memfd;
	int 	*nmr;
d136 1
a136 1
	
d140 1
a140 1
		errx(1, "can't allocate %d bytes for %d range descriptors", 
d142 1
a142 1
	
d147 1
a147 1
	
d154 3
a156 3
	int 	 memfd;
	int 	 argc;
	char 	*argv[];
d177 1
a177 1
	
d179 1
a179 1
	
d185 1
a185 1
		printf("%qx/%qx %.8s ", mrd[i].mr_base, mrd[i].mr_len, 
d199 3
a201 3
	int 	 memfd;
	int 	 argc; 
	char 	*argv[];
d231 1
a231 1
			
d236 1
a236 1
	
d239 1
a239 1
	
d242 1
a242 1
	
d256 1
a256 1
	
d265 3
a267 3
	int 	 memfd;
	int 	 argc;
	char 	*argv[];
d274 1
a274 1
	
d295 1
a295 1
			
d300 1
a300 1
	
d305 1
a305 1
		
d309 1
a309 1
			if (!strcmp(owner, mrdp[i].mr_owner) && 
d312 1
a312 1
				
d331 3
a333 3
	int 	 memfd; 
	int 	 argc;
	char 	*argv[];
d340 1
a340 1
	char 	*what;
d343 1
a343 1
	
d353 1
a353 1
	
@


1.3
log
@Wall cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.2 1999/12/05 06:32:56 deraadt Exp $ */
d61 5
a65 5
static void	listfunc __P((int, int, char *[]));
static void	setfunc __P((int, int, char *[]));
static void	clearfunc __P((int, int, char *[]));
static void	helpfunc __P((int, int, char *[]));
static void	help __P((char *));
d71 1
a71 1
	void	(*func) __P((int, int, char *[]));
@


1.2
log
@prettier range check
@
text
@d1 1
a1 1
/* $OpenBSD: memconfig.c,v 1.1 1999/11/20 11:22:54 matthieu Exp $ */
a159 1
	int			 error;
@


1.1
log
@add memconfig, an utility to manipulate MTRRs, from FreeBSD
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d227 2
a228 1
			if ((*optarg == 0) || (strlen(optarg) > 7))
@

