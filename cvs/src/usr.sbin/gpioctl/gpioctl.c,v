head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.18
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.10
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.14
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.12
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.14.0.12
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.10
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.6
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.4
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2015.12.26.20.52.03;	author mmcc;	state Exp;
branches;
next	1.16;
commitid	18I79qUe65qFQr5H;

1.16
date	2011.10.04.07.19.13;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2011.10.03.20.24.51;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.03.20.12.44;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.30.10.58.44;	author mbalmer;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.29.09.19.25;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.26.15.02.43;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.26.14.56.10;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.24.15.27.52;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.24.14.11.58;	author mbalmer;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.17.16.55.05;	author mbalmer;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.17.09.05.23;	author mbalmer;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.18.16.16.56;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.17.10.18.18;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.16.16.40.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.08.00.05.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.03.19.13.24;	author grange;	state Exp;
branches;
next	;


desc
@@


1.17
log
@bzero -> memset. No binary change.

ok tb@@
@
text
@/*	$OpenBSD: gpioctl.c,v 1.16 2011/10/04 07:19:13 jmc Exp $	*/
/*
 * Copyright (c) 2008 Marc Balmer <mbalmer@@openbsd.org>
 * Copyright (c) 2004 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Program to control GPIO devices.
 */

#include <sys/types.h>
#include <sys/gpio.h>
#include <sys/ioctl.h>
#include <sys/limits.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>


char *dev;
int devfd = -1;
int quiet = 0;

void	getinfo(void);
void	pinread(int, char *);
void	pinwrite(int, char *, int);
void	pinset(int pin, char *name, int flags, char *alias);
void	unset(int pin, char *name);
void	devattach(char *, int, u_int32_t, u_int32_t);
void	devdetach(char *);

__dead void usage(void);

const struct bitstr {
	unsigned int mask;
	const char *string;
} pinflags[] = {
	{ GPIO_PIN_INPUT, "in" },
	{ GPIO_PIN_OUTPUT, "out" },
	{ GPIO_PIN_INOUT, "inout" },
	{ GPIO_PIN_OPENDRAIN, "od" },
	{ GPIO_PIN_PUSHPULL, "pp" },
	{ GPIO_PIN_TRISTATE, "tri" },
	{ GPIO_PIN_PULLUP, "pu" },
	{ GPIO_PIN_PULLDOWN, "pd" },
	{ GPIO_PIN_INVIN, "iin" },
	{ GPIO_PIN_INVOUT, "iout" },
	{ 0, NULL },
};

int
main(int argc, char *argv[])
{
	const struct bitstr *bs;
	long lval;
	u_int32_t ga_mask = 0, ga_flags = 0;
	int pin, ch, ga_offset = -1, n, fl = 0, value = 0;
	const char *errstr;
	char *ep, *flags, *nam = NULL;
	char devn[32];

	while ((ch = getopt(argc, argv, "q")) != -1)
		switch (ch) {
		case 'q':
			quiet = 1;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	argc -= optind;
	argv += optind;

	if (argc < 1)
		usage();
	dev = argv[0];

	if (strncmp(_PATH_DEV, dev, sizeof(_PATH_DEV) - 1)) {
		(void)snprintf(devn, sizeof(devn), "%s%s", _PATH_DEV, dev);
		dev = devn;
	}

	if ((devfd = open(dev, O_RDWR)) == -1)
		err(1, "%s", dev);

	if (argc == 1) {
		getinfo();
		return 0;
	}

	if (!strcmp(argv[1], "attach")) {
		char *driver, *offset, *mask;

		if (argc != 5 && argc != 6)
			usage();

		driver = argv[2];
		offset = argv[3];
		mask = argv[4];
		flags = argc == 6 ? argv[5] : NULL;

		ga_offset = strtonum(offset, 0, INT_MAX, &errstr);
		if (errstr)
			errx(1, "offset is %s: %s", errstr, offset);

		lval = strtol(mask, &ep, 0);
		if (*mask == '\0' || *ep != '\0')
			errx(1, "invalid mask (not a number)");
		if ((errno == ERANGE && (lval == LONG_MAX
		    || lval == LONG_MIN)) || lval > UINT_MAX)
			errx(1, "mask out of range");
		ga_mask = lval;
		if (flags != NULL) {
			lval = strtonum(flags, 0, UINT_MAX, &errstr);
			if (errstr)
				errx(1, "flags is %s: %s", errstr, flags);
			ga_flags = lval;
		}
		devattach(driver, ga_offset, ga_mask, ga_flags);
		return 0;
	} else if (!strcmp(argv[1], "detach")) {
		if (argc != 3)
			usage();
		devdetach(argv[2]);
	} else {
		char *nm = NULL;

		/* expecting a pin number or name */
		pin = strtonum(argv[1], 0, INT_MAX, &errstr);
		if (errstr)
			nm = argv[1];	/* try named pin */
		if (argc > 2) {
			if (!strcmp(argv[2], "set")) {
				for (n = 3; n < argc; n++) {
					for (bs = pinflags; bs->string != NULL;
					     bs++) {
						if (!strcmp(argv[n],
						    bs->string)) {
							fl |= bs->mask;
							break;
						}
					}
					if (bs->string == NULL)
						nam = argv[n];
				}
				pinset(pin, nm, fl, nam);
			} else if (!strcmp(argv[2], "unset")) {
				unset(pin, nm);
			} else {
				value = strtonum(argv[2], INT_MIN, INT_MAX,
				   &errstr);
				if (errstr) {
					if (!strcmp(argv[2], "on"))
						value = 1;
					else if (!strcmp(argv[2], "off"))
						value = 0;
					else if (!strcmp(argv[2], "toggle"))
						value = 2;
					else
						errx(1, "%s: invalid value",
						    argv[2]);
				}
				pinwrite(pin, nm, value);
			}
		} else
			pinread(pin, nm);
	}

	return (0);
}

void
getinfo(void)
{
	struct gpio_info info;

	memset(&info, 0, sizeof(info));
	if (ioctl(devfd, GPIOINFO, &info) == -1)
		err(1, "GPIOINFO");

	if (quiet)
		return;

	printf("%s: %d pins\n", dev, info.gpio_npins);
}

void
pinread(int pin, char *gp_name)
{
	struct gpio_pin_op op;

	memset(&op, 0, sizeof(op));
	if (gp_name != NULL)
		strlcpy(op.gp_name, gp_name, sizeof(op.gp_name));
	else
		op.gp_pin = pin;

	if (ioctl(devfd, GPIOPINREAD, &op) == -1)
		err(1, "GPIOPINREAD");

	if (quiet)
		return;

	if (gp_name)
		printf("pin %s: state %d\n", gp_name, op.gp_value);
	else
		printf("pin %d: state %d\n", pin, op.gp_value);
}

void
pinwrite(int pin, char *gp_name, int value)
{
	struct gpio_pin_op op;

	if (value < 0 || value > 2)
		errx(1, "%d: invalid value", value);

	memset(&op, 0, sizeof(op));
	if (gp_name != NULL)
		strlcpy(op.gp_name, gp_name, sizeof(op.gp_name));
	else
		op.gp_pin = pin;
	op.gp_value = (value == 0 ? GPIO_PIN_LOW : GPIO_PIN_HIGH);
	if (value < 2) {
		if (ioctl(devfd, GPIOPINWRITE, &op) == -1)
			err(1, "GPIOPINWRITE");
	} else {
		if (ioctl(devfd, GPIOPINTOGGLE, &op) == -1)
			err(1, "GPIOPINTOGGLE");
	}

	if (quiet)
		return;

	if (gp_name)
		printf("pin %s: state %d -> %d\n", gp_name, op.gp_value,
		    (value < 2 ? value : 1 - op.gp_value));
	else
		printf("pin %d: state %d -> %d\n", pin, op.gp_value,
		    (value < 2 ? value : 1 - op.gp_value));
}

void
pinset(int pin, char *name, int fl, char *alias)
{
	struct gpio_pin_set set;
	const struct bitstr *bs;

	memset(&set, 0, sizeof(set));
	if (name != NULL)
		strlcpy(set.gp_name, name, sizeof(set.gp_name));
	else
		set.gp_pin = pin;
	set.gp_flags = fl;

	if (alias != NULL)
		strlcpy(set.gp_name2, alias, sizeof(set.gp_name2));

	if (ioctl(devfd, GPIOPINSET, &set) == -1)
		err(1, "GPIOPINSET");

	if (quiet)
		return;

	if (name != NULL)
		printf("pin %s: caps:", name);
	else
		printf("pin %d: caps:", pin);
	for (bs = pinflags; bs->string != NULL; bs++)
		if (set.gp_caps & bs->mask)
			printf(" %s", bs->string);
	printf(", flags:");
	for (bs = pinflags; bs->string != NULL; bs++)
		if (set.gp_flags & bs->mask)
			printf(" %s", bs->string);
	if (fl > 0) {
		printf(" ->");
		for (bs = pinflags; bs->string != NULL; bs++)
			if (fl & bs->mask)
				printf(" %s", bs->string);
	}
	printf("\n");
}

void
unset(int pin, char *name)
{
	struct gpio_pin_set set;

	memset(&set, 0, sizeof(set));
	if (name != NULL)
		strlcpy(set.gp_name, name, sizeof(set.gp_name));
	else
		set.gp_pin = pin;

	if (ioctl(devfd, GPIOPINUNSET, &set) == -1)
		err(1, "GPIOPINUNSET");
}

void
devattach(char *dvname, int offset, u_int32_t mask, u_int32_t flags)
{
	struct gpio_attach attach;

	memset(&attach, 0, sizeof(attach));
	strlcpy(attach.ga_dvname, dvname, sizeof(attach.ga_dvname));
	attach.ga_offset = offset;
	attach.ga_mask = mask;
	attach.ga_flags = flags;
	if (ioctl(devfd, GPIOATTACH, &attach) == -1)
		err(1, "GPIOATTACH");
}

void
devdetach(char *dvname)
{
	struct gpio_attach attach;

	memset(&attach, 0, sizeof(attach));
	strlcpy(attach.ga_dvname, dvname, sizeof(attach.ga_dvname));
	if (ioctl(devfd, GPIODETACH, &attach) == -1)
		err(1, "GPIODETACH");
}
void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-q] device pin [0 | 1 | 2 | "
	    "on | off | toggle]\n", __progname);
	fprintf(stderr, "       %s [-q] device pin set [flags] [name]\n",
	    __progname);
	fprintf(stderr, "       %s [-q] device pin unset\n", __progname);
	fprintf(stderr, "       %s [-q] device attach device offset mask "
	    "[flag]\n", __progname);
	fprintf(stderr, "       %s [-q] device detach device\n", __progname);

	exit(1);
}
@


1.16
log
@- sync usage() and SYNOPSIS
- document "flag", for I2C devices
- "pin" is not optional

ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.15 2011/10/03 20:24:51 matthieu Exp $	*/
d195 1
a195 1
	bzero(&info, sizeof(info));
d210 1
a210 1
	bzero(&op, sizeof(op));
d236 1
a236 1
	bzero(&op, sizeof(op));
d267 1
a267 1
	bzero(&set, sizeof(set));
d308 1
a308 1
	bzero(&set, sizeof(set));
d323 1
a323 1
	bzero(&attach, sizeof(attach));
d337 1
a337 1
	bzero(&attach, sizeof(attach));
@


1.15
log
@Add a 'flag' locator to gpioiic(4), and define a first flag
value to swap the SDA and SCL pins assigment during attach.
Mostly from work with mbalmer@@NetBSD.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.14 2008/12/03 20:12:44 stevesk Exp $	*/
d347 1
a347 1
	fprintf(stderr, "usage: %s [-q] device [pin] [0 | 1 | 2 | "
@


1.14
log
@delete unused prototype, from lint; ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.13 2008/11/30 10:58:44 mbalmer Exp $	*/
d47 1
a47 1
void	devattach(char *, int, u_int32_t);
d74 1
a74 1
	u_int32_t ga_mask = 0;
d77 1
a77 1
	char *ep, *nam = NULL;
d112 1
a112 1
		if (argc != 5)
d118 1
d131 7
a137 1
		devattach(driver, ga_offset, ga_mask);
d145 1
a145 1
	
d150 1
a150 1
		if (argc > 2) { 
d319 1
a319 1
devattach(char *dvname, int offset, u_int32_t mask)
d327 1
d352 2
a353 2
	fprintf(stderr, "       %s [-q] device attach device offset mask\n",
	    __progname);
@


1.13
log
@Fix output.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.12 2008/11/29 09:19:25 mbalmer Exp $	*/
a44 1
void	pinctl(int, char *, char *[], int);
@


1.12
log
@Allow the words "on", "off", or "toggle" to be used instead of the
numerical values when writing to a pin; fix an error message.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.11 2008/11/26 15:02:43 mbalmer Exp $	*/
d98 1
a98 1
		(void)snprintf(devn, sizeof(devn), "%s/%s", _PATH_DEV, dev);
@


1.11
log
@Reorder variables, add my copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.10 2008/11/26 14:56:10 mbalmer Exp $	*/
d164 11
a174 2
				if (errstr)
					errx(1, "%s: invalid value", argv[2]);
d238 1
a238 1
			err(1, "GPIOPINWR");
d340 2
a341 2
	fprintf(stderr, "usage: %s [-q] device [pin] [0 | 1 | 2]\n",
	    __progname);
d345 1
a345 1
	fprintf(stderr, "       %s [-q] device attach device  offset mask\n",
@


1.10
log
@Use the new gpio(4) semantics and change the command line syntax to a
more readable and straightforward format.  Note that there is no longer
a default GPIO device, but it has to be sepcified on the command line
always (and as Theo mentioned, newfs also does not default to /dev/sd0a...)

You must do a 'make includesi' in /usr/src before building this command or
before your next system build.

ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.9 2008/11/24 15:27:52 jmc Exp $	*/
d3 1
a72 2
	int ch;
	const char *errstr;
a73 3
	char *ep;
	int n, fl = 0, value = 0;
	u_int32_t ga_mask = 0, ga_offset = -1;
d75 4
a79 2
	int pin;
	char *nam = NULL;
@


1.9
log
@- tweak previous
- kill .Tn
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.8 2008/11/24 14:11:58 mbalmer Exp $	*/
d30 1
a35 1
#define _PATH_DEV_GPIO	"/dev/gpio0"
d37 1
a37 1
char *device = _PATH_DEV_GPIO;
d42 5
a46 3
void	pinread(int);
void	pinwrite(int, int);
void	pinctl(int, char *[], int);
d74 3
a76 3
	char *ga_dvname = NULL, *ep;
	int do_ctl = 0;
	int pin = 0, value = 0, attach = 0, detach = 0;
d79 3
d83 1
a83 1
	while ((ch = getopt(argc, argv, "A:cd:D:m:o:q")) != -1)
a84 32
		case 'A':
			if (detach)
				errx(1, "-A and -D are mutual exclusive");
			ga_dvname = optarg;
			attach = 1;
			break;
		case 'c':
			do_ctl = 1;
			break;
		case 'd':
			device = optarg;
			break;
		case 'D':
			if (attach)
				errx(1, "-D and -A are mutual exclusive");
			ga_dvname = optarg;
			detach = 1;
			break;
		case 'm':
			lval = strtol(optarg, &ep, 0);
			if (*optarg == '\0' || *ep != '\0')
				errx(1, "invalid mask (not a number)");
			if ((errno == ERANGE && (lval == LONG_MAX
			    || lval == LONG_MIN)) || lval > UINT_MAX)
				errx(1, "mask out of range");
			ga_mask = lval;
			break;
		case 'o':
			ga_offset = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "offset is %s: %s", errstr, optarg);
			break;
d95 7
a101 4
	if (argc > 0) {
		pin = strtonum(argv[0], 0, INT_MAX, &errstr);
		if (errstr)
			errx(1, "%s: invalid pin", argv[0]);
d104 2
a105 2
	if ((devfd = open(device, O_RDWR)) == -1)
		err(1, "%s", device);
d107 1
a107 7
	if (attach) {
		if (ga_offset == -1 || ga_mask == 0)
			errx(1, "gpio attach needs an offset and a mask");
		devattach(ga_dvname, ga_offset, ga_mask);
	} else if (detach) {
		devdetach(ga_dvname);
	} else if (argc == 0 && !do_ctl) {
d109 30
a138 14
	} else if (argc == 1) {
		if (do_ctl)
			pinctl(pin, NULL, 0);
		else
			pinread(pin);
	} else if (argc > 1) {
		if (do_ctl) {
			pinctl(pin, argv + 1, argc - 1);
		} else {
			value = strtonum(argv[1], INT_MIN, INT_MAX, &errstr);
			if (errstr)
				errx(1, "%s: invalid value", argv[1]);
			pinwrite(pin, value);
		}
d140 32
a171 2
		usage();
		/* NOTREACHED */
d189 1
a189 1
	printf("%s: %d pins\n", device, info.gpio_npins);
d193 1
a193 1
pinread(int pin)
d198 5
a202 1
	op.gp_pin = pin;
d209 4
a212 1
	printf("pin %d: state %d\n", pin, op.gp_value);
d216 1
a216 1
pinwrite(int pin, int value)
d224 4
a227 1
	op.gp_pin = pin;
d231 1
a231 1
			err(1, "GPIOPINWRITE");
d240 6
a245 2
	printf("pin %d: state %d -> %d\n", pin, op.gp_value,
	    (value < 2 ? value : 1 - op.gp_value));
d249 1
a249 1
pinctl(int pin, char *flags[], int nflags)
d251 1
a251 2
	struct gpio_pin_ctl ctl;
	int fl = 0;
a252 1
	int i;
d254 12
a265 13
	bzero(&ctl, sizeof(ctl));
	ctl.gp_pin = pin;
	if (flags != NULL) {
		for (i = 0; i < nflags; i++)
			for (bs = pinflags; bs->string != NULL; bs++)
				if (strcmp(flags[i], bs->string) == 0) {
					fl |= bs->mask;
					break;
				}
	}
	ctl.gp_flags = fl;
	if (ioctl(devfd, GPIOPINCTL, &ctl) == -1)
		err(1, "GPIOPINCTL");
d270 4
a273 1
	printf("pin %d: caps:", pin);
d275 1
a275 1
		if (ctl.gp_caps & bs->mask)
d279 1
a279 1
		if (ctl.gp_flags & bs->mask)
d291 15
d333 1
a333 1
	fprintf(stderr, "usage: %s [-q] [-d device] [pin] [0 | 1 | 2]\n",
d335 1
a335 1
	fprintf(stderr, "       %s [-q] [-d device] -c pin [flags]\n",
d337 2
a338 1
	fprintf(stderr, "       %s -A device -o offset -m mask\n",
d340 1
a340 1
	fprintf(stderr, "       %s -D device\n", __progname);
@


1.8
log
@Add and document -A and -D options to attach or detach devices at
runtime to a gpio bus.

ok uwe, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.7 2007/11/17 16:55:05 mbalmer Exp $	*/
d292 1
a292 1
	fprintf(stderr, "       %s [-A device] -o offset -m mask\n",
d294 1
a294 1
	fprintf(stderr, "       %s [-D device]\n", __progname);
@


1.7
log
@GPIO pins can be programmed to invert input or output on some devices.
Introduce new flags, GPIO_PIN_INVIN and GPIO_PIN_INVOUT, for this.

ok grange
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.6 2007/11/17 09:05:23 mbalmer Exp $	*/
d28 1
d45 2
d72 1
d74 3
a76 1
	int pin = 0, value = 0;
d78 1
a78 1
	while ((ch = getopt(argc, argv, "cd:q")) != -1)
d80 6
d92 20
d131 7
a137 1
	if (argc == 0 && !do_ctl) {
d261 23
d292 3
@


1.6
log
@pull-down (GPIO_PIN_PULLDOWN) is a valid flags for some GPIO devices,
e.g. the AMD Geode C5536 GPIO.

ok grange
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.5 2007/03/18 16:16:56 deraadt Exp $	*/
d59 2
@


1.5
log
@use strtonum() to avoid out of range values, way simpler than the
12-line song and dance that standard functions need; bret.lambert@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.4 2005/11/17 10:18:18 grange Exp $	*/
d58 1
@


1.4
log
@Unbreak; noticed by evol@@online.ptt.ru.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.3 2005/11/16 16:40:28 deraadt Exp $	*/
d25 1
d65 1
a65 1
	char *ep;
d88 2
a89 2
		pin = strtol(argv[0], &ep, 10);
		if (*argv[0] == '\0' || *ep != '\0' || pin < 0)
d107 2
a108 2
			value = strtol(argv[1], &ep, 10);
			if (*argv[1] == '\0' || *ep != '\0')
@


1.3
log
@no need for -h, any illegal option is fine
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.2 2004/08/08 00:05:09 deraadt Exp $	*/
d68 1
a68 1
	while ((ch = getopt(argc, argv, "cd:h")) != -1)
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: gpioctl.c,v 1.1 2004/06/03 19:13:24 grange Exp $	*/
d68 1
a68 1
	while ((ch = getopt(argc, argv, "cd:hq")) != -1)
a78 2
		case 'h':
		case '?':
d223 1
a223 1
	fprintf(stderr, "usage: %s [-hq] [-d device] [pin] [0 | 1 | 2]\n",
d225 1
a225 1
	fprintf(stderr, "       %s [-hq] [-d device] -c pin [flags]\n",
@


1.1
log
@gpioctl -- program to control GPIO devices.
The gpioctl program allows to manipulate GPIO devices pins

Quick start for the Soekris net4801 users:
# gpioctl -c 20 out pp
# gpioctl 20 1
This will turn on the red error led.
If you want to use JP5 I/O pins, just use the /dev/gpio1 device.

Quick start for the PC Engines WRAP.1C users:
# gpioctl 40
This will read the state of the button (0 means pressed).

# gpioctl -c 2 pp out
This will turn the first led on, to turn off write 1 to the pin,
it's reversed. For the second and the third leds use pins 3 and 18.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d145 1
a145 1
	
d225 1
a225 1
	fprintf(stderr, "usage:\t%s [-hq] [-d device] [pin] [0 | 1 | 2]\n",
d227 1
a227 1
	fprintf(stderr, "\t%s [-hq] [-d device] -c pin [flags]\n",
@

