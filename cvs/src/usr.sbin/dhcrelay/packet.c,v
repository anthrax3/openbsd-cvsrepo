head	1.13;
access;
symbols
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.20
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.16
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.14
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.12
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.10
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.6
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.24
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.20
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.18
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.16
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.14
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.12
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.10
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2017.02.13.19.15.39;	author krw;	state Exp;
branches;
next	1.12;
commitid	b8On5ZZgQn2F03X7;

1.12
date	2016.12.08.19.18.15;	author rzalamena;	state Exp;
branches;
next	1.11;
commitid	1Wx2EY9x67fSNeJ6;

1.11
date	2016.02.07.00.49.28;	author krw;	state Exp;
branches;
next	1.10;
commitid	KRCyy1qhM7Xq37Rf;

1.10
date	2016.02.03.14.48.36;	author krw;	state Exp;
branches;
next	1.9;
commitid	IE5ZAwOumxPJ0eHN;

1.9
date	2016.02.02.23.18.16;	author sthen;	state Exp;
branches;
next	1.8;
commitid	cLIn0EqaXMa2UsbQ;

1.8
date	2016.02.02.23.16.58;	author sthen;	state Exp;
branches;
next	1.7;
commitid	7QwH8IJH2g1bpVZ0;

1.7
date	2016.02.02.23.15.15;	author sthen;	state Exp;
branches;
next	1.6;
commitid	QtDOu8xvcWtqgUeT;

1.6
date	2016.01.13.13.41.42;	author sthen;	state Exp;
branches;
next	1.5;
commitid	LnkvTgjFH9iocMTq;

1.5
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.4;
commitid	2uw1UTO4k6erpWzK;

1.4
date	2014.07.28.16.40.32;	author tobias;	state Exp;
branches;
next	1.3;
commitid	9DpOO6mtcRw7JbT5;

1.3
date	2009.09.03.11.56.49;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.20.20.56.47;	author canacar;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.12.21.10.28;	author henning;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@/*	$OpenBSD: packet.c,v 1.12 2016/12/08 19:18:15 rzalamena Exp $	*/

/* Packet assembly code, originally contributed by Archie Cobbs. */

/*
 * Copyright (c) 1995, 1996, 1999 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <arpa/inet.h>

#include <net/if.h>
#include <net/if_enc.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/if_ether.h>

#include <string.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"


u_int32_t	checksum(unsigned char *, unsigned, u_int32_t);
u_int32_t	wrapsum(u_int32_t);

u_int32_t
checksum(unsigned char *buf, unsigned nbytes, u_int32_t sum)
{
	int i;

	/* Checksum all the pairs of bytes first... */
	for (i = 0; i < (nbytes & ~1U); i += 2) {
		sum += (u_int16_t)ntohs(*((u_int16_t *)(buf + i)));
		if (sum > 0xFFFF)
			sum -= 0xFFFF;
	}

	/*
	 * If there's a single byte left over, checksum it, too.
	 * Network byte order is big-endian, so the remaining byte is
	 * the high byte.
	 */
	if (i < nbytes) {
		sum += buf[i] << 8;
		if (sum > 0xFFFF)
			sum -= 0xFFFF;
	}

	return (sum);
}

u_int32_t
wrapsum(u_int32_t sum)
{
	sum = ~sum & 0xFFFF;
	return (htons(sum));
}

void
assemble_hw_header(struct interface_info *interface, unsigned char *buf,
    int *bufix, struct packet_ctx *pc)
{
	struct ether_header eh;

	/* Use the supplied address or let the kernel fill it. */
	memcpy(eh.ether_shost, pc->pc_smac, ETHER_ADDR_LEN);
	memcpy(eh.ether_dhost, pc->pc_dmac, ETHER_ADDR_LEN);

	eh.ether_type = htons(ETHERTYPE_IP);

	memcpy(&buf[*bufix], &eh, ETHER_HDR_LEN);
	*bufix += ETHER_HDR_LEN;
}

void
assemble_udp_ip_header(struct interface_info *interface, unsigned char *buf,
    int *bufix, struct packet_ctx *pc, unsigned char *data, int len)
{
	struct ip ip;
	struct udphdr udp;

	ip.ip_v = 4;
	ip.ip_hl = 5;
	ip.ip_tos = IPTOS_LOWDELAY;
	ip.ip_len = htons(sizeof(ip) + sizeof(udp) + len);
	ip.ip_id = 0;
	ip.ip_off = 0;
	ip.ip_ttl = 16;
	ip.ip_p = IPPROTO_UDP;
	ip.ip_sum = 0;
	ip.ip_src.s_addr = ss2sin(&pc->pc_src)->sin_addr.s_addr;
	ip.ip_dst.s_addr = ss2sin(&pc->pc_dst)->sin_addr.s_addr;

	ip.ip_sum = wrapsum(checksum((unsigned char *)&ip, sizeof(ip), 0));
	memcpy(&buf[*bufix], &ip, sizeof(ip));
	*bufix += sizeof(ip);

	udp.uh_sport = ss2sin(&pc->pc_src)->sin_port;
	udp.uh_dport = ss2sin(&pc->pc_dst)->sin_port;
	udp.uh_ulen = htons(sizeof(udp) + len);
	memset(&udp.uh_sum, 0, sizeof(udp.uh_sum));

	udp.uh_sum = wrapsum(checksum((unsigned char *)&udp, sizeof(udp),
	    checksum(data, len, checksum((unsigned char *)&ip.ip_src,
	    2 * sizeof(ip.ip_src),
	    IPPROTO_UDP + (u_int32_t)ntohs(udp.uh_ulen)))));

	memcpy(&buf[*bufix], &udp, sizeof(udp));
	*bufix += sizeof(udp);
}

ssize_t
decode_hw_header(struct interface_info *interface, unsigned char *buf,
    int bufix, struct packet_ctx *pc)
{
	size_t offset = 0;

	if (interface->hw_address.htype == HTYPE_IPSEC_TUNNEL) {
		u_int32_t ip_len;
		struct ip *ip;

		bufix += ENC_HDRLEN;
		ip_len = (buf[bufix] & 0xf) << 2;
		ip = (struct ip *)(buf + bufix);

		/* Encapsulated IP */
		if (ip->ip_p != IPPROTO_IPIP)
			return (-1);

		memset(pc->pc_dmac, 0xff, ETHER_ADDR_LEN);
		offset = ENC_HDRLEN + ip_len;
	} else {
		memcpy(pc->pc_dmac, buf + bufix, ETHER_ADDR_LEN);
		memcpy(pc->pc_smac, buf + bufix + ETHER_ADDR_LEN,
		    ETHER_ADDR_LEN);
		offset = sizeof(struct ether_header);
	}

	pc->pc_htype = ARPHRD_ETHER;
	pc->pc_hlen = ETHER_ADDR_LEN;

	return (offset);
}

ssize_t
decode_udp_ip_header(struct interface_info *interface, unsigned char *buf,
    int bufix, struct packet_ctx *pc, int buflen)
{
	struct ip *ip;
	struct udphdr *udp;
	unsigned char *data;
	u_int32_t ip_len;
	u_int32_t sum, usum;
	static unsigned int ip_packets_seen;
	static unsigned int ip_packets_bad_checksum;
	static unsigned int udp_packets_seen;
	static unsigned int udp_packets_bad_checksum;
	static unsigned int udp_packets_length_checked;
	static unsigned int udp_packets_length_overflow;
	int len;

	/* Assure that an entire IP header is within the buffer. */
	if (sizeof(*ip) > buflen)
		return (-1);
	ip_len = (buf[bufix] & 0xf) << 2;
	if (ip_len > buflen)
		return (-1);
	ip = (struct ip *)(buf + bufix);
	ip_packets_seen++;

	/* Check the IP header checksum - it should be zero. */
	if (wrapsum(checksum(buf + bufix, ip_len, 0)) != 0) {
		ip_packets_bad_checksum++;
		if (ip_packets_seen > 4 && ip_packets_bad_checksum != 0 &&
		    (ip_packets_seen / ip_packets_bad_checksum) < 2) {
			log_info("%u bad IP checksums seen in %u packets",
			    ip_packets_bad_checksum, ip_packets_seen);
			ip_packets_seen = ip_packets_bad_checksum = 0;
		}
		return (-1);
	}

	pc->pc_src.ss_len = sizeof(struct sockaddr_in);
	pc->pc_src.ss_family = AF_INET;
	memcpy(&ss2sin(&pc->pc_src)->sin_addr, &ip->ip_src,
	    sizeof(ss2sin(&pc->pc_src)->sin_addr));

	pc->pc_dst.ss_len = sizeof(struct sockaddr_in);
	pc->pc_dst.ss_family = AF_INET;
	memcpy(&ss2sin(&pc->pc_dst)->sin_addr, &ip->ip_dst,
	    sizeof(ss2sin(&pc->pc_dst)->sin_addr));

#ifdef DEBUG
	if (ntohs(ip->ip_len) != buflen)
		log_debug("ip length %d disagrees with bytes received %d.",
		    ntohs(ip->ip_len), buflen);
#endif

	/* Assure that the entire IP packet is within the buffer. */
	if (ntohs(ip->ip_len) > buflen)
		return (-1);

	/* Assure that the UDP header is within the buffer. */
	if (ip_len + sizeof(*udp) > buflen)
		return (-1);
	udp = (struct udphdr *)(buf + bufix + ip_len);
	udp_packets_seen++;

	/* Assure that the entire UDP packet is within the buffer. */
	if (ip_len + ntohs(udp->uh_ulen) > buflen)
		return (-1);
	data = buf + bufix + ip_len + sizeof(*udp);

	/*
	 * Compute UDP checksums, including the ``pseudo-header'', the
	 * UDP header and the data. If the UDP checksum field is zero,
	 * we're not supposed to do a checksum.
	 */
	udp_packets_length_checked++;
	len = ntohs(udp->uh_ulen) - sizeof(*udp);
	if ((len < 0) || (len + data > buf + bufix + buflen)) {
		udp_packets_length_overflow++;
		if (udp_packets_length_checked > 4 &&
		    udp_packets_length_overflow != 0 &&
		    (udp_packets_length_checked /
		    udp_packets_length_overflow) < 2) {
			log_info("%u udp packets in %u too long - dropped",
			    udp_packets_length_overflow,
			    udp_packets_length_checked);
			udp_packets_length_overflow =
			    udp_packets_length_checked = 0;
		}
		return (-1);
	}
	if (len + data != buf + bufix + buflen)
		log_debug("accepting packet with data after udp payload.");

	usum = udp->uh_sum;
	udp->uh_sum = 0;

	sum = wrapsum(checksum((unsigned char *)udp, sizeof(*udp),
	    checksum(data, len, checksum((unsigned char *)&ip->ip_src,
	    2 * sizeof(ip->ip_src),
	    IPPROTO_UDP + (u_int32_t)ntohs(udp->uh_ulen)))));

	udp_packets_seen++;
	if (usum && usum != sum) {
		udp_packets_bad_checksum++;
		if (udp_packets_seen > 4 && udp_packets_bad_checksum != 0 &&
		    (udp_packets_seen / udp_packets_bad_checksum) < 2) {
			log_info("%u bad udp checksums in %u packets",
			    udp_packets_bad_checksum, udp_packets_seen);
			udp_packets_seen = udp_packets_bad_checksum = 0;
		}
		return (-1);
	}

	ss2sin(&pc->pc_src)->sin_port = udp->uh_sport;
	ss2sin(&pc->pc_dst)->sin_port = udp->uh_dport;

	return (ip_len + sizeof(*udp));
}
@


1.12
log
@Clean up function prototypes: use a single struct to hold all address
information instead of passing multiple different parameters. This also
prepares the dhcrelay code to receive new features, like: IPv6, layer 2
relaying.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.11 2016/02/07 00:49:28 krw Exp $	*/
d60 1
d216 1
a216 1
			note("%u bad IP checksums seen in %u packets",
d235 1
a235 1
		debug("ip length %d disagrees with bytes received %d.",
d267 1
a267 1
			note("%u udp packets in %u too long - dropped",
d276 1
a276 1
		debug("accepting packet with data after udp payload.");
d291 1
a291 1
			note("%u bad udp checksums in %u packets",
@


1.11
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.10 2016/02/03 14:48:36 krw Exp $	*/
d100 1
a100 1
    int *bufix, struct hardware *to)
d104 3
a106 7
	if (to != NULL && to->hlen == 6) /* XXX */
		memcpy(eh.ether_dhost, to->haddr, sizeof(eh.ether_dhost));
	else
		memset(eh.ether_dhost, 0xff, sizeof(eh.ether_dhost));

	/* source address is filled in by the kernel */
	memset(eh.ether_shost, 0x00, sizeof(eh.ether_shost));
d116 1
a116 2
    int *bufix, u_int32_t from, u_int32_t to, unsigned int port,
    unsigned char *data, int len)
d130 2
a131 2
	ip.ip_src.s_addr = from;
	ip.ip_dst.s_addr = to;
d137 2
a138 2
	udp.uh_sport = server_port;	/* XXX */
	udp.uh_dport = port;			/* XXX */
d153 1
a153 1
    int bufix, struct hardware *from)
a154 1
	struct ether_header eh;
d169 1
a169 1
		bzero(&eh, sizeof(eh));
d171 5
a175 3
	} else {	
		memcpy(&eh, buf + bufix, ETHER_HDR_LEN);
		offset = sizeof(eh);
d178 2
a179 3
	memcpy(from->haddr, eh.ether_shost, sizeof(eh.ether_shost));
	from->htype = ARPHRD_ETHER;
	from->hlen = sizeof(eh.ether_shost);
d186 1
a186 1
    int bufix, struct sockaddr_in *from, int buflen)
d222 9
a230 1
	memcpy(&from->sin_addr, &ip->ip_src, sizeof(from->sin_addr));
d297 2
a298 1
	memcpy(&from->sin_port, &udp->uh_sport, sizeof(udp->uh_sport));
@


1.10
log
@be very careful accepting packets via bpf. First check that the
fixed part of the IP header is completely present before using its
header length field.  Then use the data in the IP header to ensure
the entire IP packet is present. Then check that the entire UDP header
is present. Then use the data in the UDP header to ensure all the
data it thinks is present is actually present.

Started when tj@@ and a few others noticed ISC "DHCP CVE-2015-8605:
UDP payload length not properly checked".

ok sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.9 2016/02/02 23:18:16 sthen Exp $	*/
d43 4
a46 1
#include "dhcpd.h"
d48 1
d50 2
d55 6
@


1.9
log
@Variables to count seen packets should be unsigned.

From dhcpd/packet.c r1.8   ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.8 2016/02/02 23:16:58 sthen Exp $	*/
d184 1
a184 1
	u_int32_t ip_len = (buf[bufix] & 0xf) << 2;
d194 6
d201 1
a201 1
	udp = (struct udphdr *)(buf + bufix + ip_len);
a203 1
	ip_packets_seen++;
d215 3
d221 5
d227 10
a236 1
	memcpy(&from->sin_addr, &ip->ip_src, 4);
d243 1
a243 1
	data = buf + bufix + ip_len + sizeof(*udp);
a244 1
	udp_packets_length_checked++;
@


1.8
log
@Nuke local #define ETHER_HEADER_SIZE and use the identical value'd
ETHER_HDR_LEN from if_ether.h.

From dhcpd packet.c r1.6.  ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.7 2016/02/02 23:15:15 sthen Exp $	*/
d186 6
a191 6
	static int ip_packets_seen;
	static int ip_packets_bad_checksum;
	static int udp_packets_seen;
	static int udp_packets_bad_checksum;
	static int udp_packets_length_checked;
	static int udp_packets_length_overflow;
d203 1
a203 1
			note("%d bad IP checksums seen in %d packets",
d230 1
a230 1
			note("%d udp packets in %d too long - dropped",
d254 1
a254 1
			note("%d bad udp checksums in %d packets",
@


1.7
log
@Remove unused (a.k.a. always passed NULL) parameter 'data' from
decode_udp_ip_header() and the useless check of it. Part of original
diff from pelikan about udp length errors.

From dhcpd: bpf.c r1.9, dhcpd.h r1.46, packet.c r1.5

ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.6 2016/01/13 13:41:42 sthen Exp $	*/
a49 2
#define ETHER_HEADER_SIZE (ETHER_ADDR_LEN * 2 + sizeof(u_int16_t))

d102 2
a103 2
	memcpy(&buf[*bufix], &eh, ETHER_HEADER_SIZE);
	*bufix += ETHER_HEADER_SIZE;
d166 1
a166 1
		memcpy(&eh, buf + bufix, ETHER_HEADER_SIZE);
@


1.6
log
@"Check UDP length for short as well as long values" - apply the fix from
usr.sbin/dhcpd/packet.c r1.4 to dhcrelay.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.5 2014/10/25 03:23:49 lteo Exp $	*/
d181 1
a181 1
    int bufix, struct sockaddr_in *from, unsigned char *data, int buflen)
d185 1
d194 1
a194 1
	int len = 0;
d220 1
a220 1
	 * UDP header and the data.   If the UDP checksum field is zero,
d223 14
a236 17
	if (!data) {
		data = buf + bufix + ip_len + sizeof(*udp);
		len = ntohs(udp->uh_ulen) - sizeof(*udp);
		udp_packets_length_checked++;
		if ((len < 0) || (len + data > buf + bufix + buflen)) {
			udp_packets_length_overflow++;
			if (udp_packets_length_checked > 4 &&
			    udp_packets_length_overflow != 0 &&
			    (udp_packets_length_checked /
			    udp_packets_length_overflow) < 2) {
				note("%d udp packets in %d too long - dropped",
				    udp_packets_length_overflow,
				    udp_packets_length_checked);
				udp_packets_length_overflow =
				    udp_packets_length_checked = 0;
			}
			return (-1);
d238 1
a238 2
		if (len + data != buf + bufix + buflen)
			debug("accepting packet with data after udp payload.");
d240 2
@


1.5
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.4 2014/07/28 16:40:32 tobias Exp $	*/
d226 1
a226 1
		if (len + data > buf + bufix + buflen) {
@


1.4
log
@merge dhcpd's packet.c revision 1.7:

Fix very hard to reach DoS attack vector, which would involve more than
8 billion network packets.  Mixture of many many malformed and proper
packets could result in a division by zero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.3 2009/09/03 11:56:49 reyk Exp $	*/
a45 1
#include <netinet/in_systm.h>
@


1.3
log
@Add support for "DHCP-over-IPsec" by implementing RFC 3046 (DHCP Relay
Agent Information Option) and RFC 3456 (DHCP Configuration of IPsec
Tunnel Mode).  This allows to configure various IPsec clients
dynamically via DHCP; dhcrelay needs to listen on enc0 and forward
requests to a DHCP server that supports RFC 3046, like I recently did
for dhcpd(8).

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.1 2004/04/12 21:10:28 henning Exp $	*/
d203 1
a203 1
		if (ip_packets_seen > 4 &&
d230 1
d256 1
a256 1
		if (udp_packets_seen > 4 &&
@


1.2
log
@get rid of the -p switch, use fixed values for server and client ports,
rename port variables for clarity.
ok henning@@
@
text
@d45 1
d152 1
d154 18
a171 1
	memcpy(&eh, buf + bufix, ETHER_HEADER_SIZE);
d177 1
a177 1
	return (sizeof(eh));
@


1.1
log
@initial cut at split out dhcrelay, whacked from usr.sbin/dhcp/ and sbin/dhclient
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.8 2004/02/25 14:22:12 henning Exp $	*/
a54 5
void	assemble_ethernet_header(struct interface_info *, unsigned char *,
	    int *, struct hardware *);
ssize_t	decode_ethernet_header(struct interface_info *, unsigned char *,
	    int bufix, struct hardware *);

d98 3
a100 5
	if (interface->hw_address.hlen == sizeof(eh.ether_shost))
		memcpy(eh.ether_shost, interface->hw_address.haddr,
		    sizeof(eh.ether_shost));
	else
		memset(eh.ether_shost, 0x00, sizeof(eh.ether_shost));
d132 1
a132 1
	udp.uh_sport = htons(LOCAL_PORT);	/* XXX */
@

