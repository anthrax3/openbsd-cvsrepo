head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.5.0.6
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.20
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.16
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.14
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.12
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.10
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.6
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.24
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.20
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.18
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.16
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.14
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.12
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.10
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2017.04.05.14.40.56;	author reyk;	state Exp;
branches;
next	1.13;
commitid	XTppq5Z4ZcLAkM1F;

1.13
date	2017.02.13.19.15.39;	author krw;	state Exp;
branches;
next	1.12;
commitid	b8On5ZZgQn2F03X7;

1.12
date	2016.12.08.19.18.15;	author rzalamena;	state Exp;
branches;
next	1.11;
commitid	1Wx2EY9x67fSNeJ6;

1.11
date	2016.02.07.00.49.28;	author krw;	state Exp;
branches;
next	1.10;
commitid	KRCyy1qhM7Xq37Rf;

1.10
date	2016.02.03.14.48.36;	author krw;	state Exp;
branches;
next	1.9;
commitid	IE5ZAwOumxPJ0eHN;

1.9
date	2016.02.02.23.18.16;	author sthen;	state Exp;
branches;
next	1.8;
commitid	cLIn0EqaXMa2UsbQ;

1.8
date	2016.02.02.23.16.58;	author sthen;	state Exp;
branches;
next	1.7;
commitid	7QwH8IJH2g1bpVZ0;

1.7
date	2016.02.02.23.15.15;	author sthen;	state Exp;
branches;
next	1.6;
commitid	QtDOu8xvcWtqgUeT;

1.6
date	2016.01.13.13.41.42;	author sthen;	state Exp;
branches;
next	1.5;
commitid	LnkvTgjFH9iocMTq;

1.5
date	2014.10.25.03.23.49;	author lteo;	state Exp;
branches;
next	1.4;
commitid	2uw1UTO4k6erpWzK;

1.4
date	2014.07.28.16.40.32;	author tobias;	state Exp;
branches;
next	1.3;
commitid	9DpOO6mtcRw7JbT5;

1.3
date	2009.09.03.11.56.49;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.20.20.56.47;	author canacar;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.12.21.10.28;	author henning;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Rework the packet.c code for decoding and assembling DHCP messages.

This code suffered from many years of incremental improvements, fix it to:
- verify available buffer space in all cases and don't just trust the caller
- have an API where you always pass the full buffer length and absolute offset
- use consistent types for lengths and buffer offsets (int vs. size_t, ssize_t)
- don't just ignore errors, return and fail when something is wrong

OK rzalamena@@
@
text
@/*	$OpenBSD: packet.c,v 1.13 2017/02/13 19:15:39 krw Exp $	*/

/* Packet assembly code, originally contributed by Archie Cobbs. */

/*
 * Copyright (c) 1995, 1996, 1999 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <arpa/inet.h>

#include <net/if.h>
#include <net/if_enc.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/if_ether.h>

#include <string.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"


u_int32_t	checksum(unsigned char *, u_int32_t, u_int32_t);
u_int32_t	wrapsum(u_int32_t);

u_int32_t
checksum(unsigned char *buf, u_int32_t nbytes, u_int32_t sum)
{
	u_int32_t i;

	/* Checksum all the pairs of bytes first... */
	for (i = 0; i < (nbytes & ~1U); i += 2) {
		sum += (u_int16_t)ntohs(*((u_int16_t *)(buf + i)));
		if (sum > 0xFFFF)
			sum -= 0xFFFF;
	}

	/*
	 * If there's a single byte left over, checksum it, too.
	 * Network byte order is big-endian, so the remaining byte is
	 * the high byte.
	 */
	if (i < nbytes) {
		sum += buf[i] << 8;
		if (sum > 0xFFFF)
			sum -= 0xFFFF;
	}

	return (sum);
}

u_int32_t
wrapsum(u_int32_t sum)
{
	sum = ~sum & 0xFFFF;
	return (htons(sum));
}

ssize_t
assemble_hw_header(unsigned char *buf, size_t buflen,
    size_t offset, struct packet_ctx *pc, unsigned int intfhtype)
{
	struct ether_header eh;

	switch (intfhtype) {
	case HTYPE_ETHER:
		if (buflen < offset + ETHER_HDR_LEN)
			return (-1);

		/* Use the supplied address or let the kernel fill it. */
		memcpy(eh.ether_shost, pc->pc_smac, ETHER_ADDR_LEN);
		memcpy(eh.ether_dhost, pc->pc_dmac, ETHER_ADDR_LEN);

		eh.ether_type = htons(ETHERTYPE_IP);

		memcpy(&buf[offset], &eh, ETHER_HDR_LEN);
		offset += ETHER_HDR_LEN;
		break;
	default:
		return (-1);
	}

	return (offset);
}

ssize_t
assemble_udp_ip_header(unsigned char *buf, size_t buflen, size_t offset,
    struct packet_ctx *pc, unsigned char *data, size_t datalen)
{
	struct ip ip;
	struct udphdr udp;

	if (buflen < offset + sizeof(ip) + sizeof(udp))
		return (-1);

	ip.ip_v = 4;
	ip.ip_hl = 5;
	ip.ip_tos = IPTOS_LOWDELAY;
	ip.ip_len = htons(sizeof(ip) + sizeof(udp) + datalen);
	ip.ip_id = 0;
	ip.ip_off = 0;
	ip.ip_ttl = 16;
	ip.ip_p = IPPROTO_UDP;
	ip.ip_sum = 0;
	ip.ip_src.s_addr = ss2sin(&pc->pc_src)->sin_addr.s_addr;
	ip.ip_dst.s_addr = ss2sin(&pc->pc_dst)->sin_addr.s_addr;

	ip.ip_sum = wrapsum(checksum((unsigned char *)&ip, sizeof(ip), 0));
	memcpy(&buf[offset], &ip, sizeof(ip));
	offset += sizeof(ip);

	udp.uh_sport = ss2sin(&pc->pc_src)->sin_port;
	udp.uh_dport = ss2sin(&pc->pc_dst)->sin_port;
	udp.uh_ulen = htons(sizeof(udp) + datalen);
	memset(&udp.uh_sum, 0, sizeof(udp.uh_sum));

	udp.uh_sum = wrapsum(checksum((unsigned char *)&udp, sizeof(udp),
	    checksum(data, datalen, checksum((unsigned char *)&ip.ip_src,
	    2 * sizeof(ip.ip_src),
	    IPPROTO_UDP + (u_int32_t)ntohs(udp.uh_ulen)))));

	memcpy(&buf[offset], &udp, sizeof(udp));
	offset += sizeof(udp);

	return (offset);
}

ssize_t
decode_hw_header(unsigned char *buf, size_t buflen,
    size_t offset, struct packet_ctx *pc, unsigned int intfhtype)
{
	u_int32_t ip_len;
	struct ip *ip;

	switch (intfhtype) {
	case HTYPE_IPSEC_TUNNEL:
		if (buflen < offset + ENC_HDRLEN + sizeof(*ip))
			return (-1);
		offset += ENC_HDRLEN;
		ip_len = (buf[offset] & 0xf) << 2;
		if (buflen < offset + ip_len)
			return (-1);

		ip = (struct ip *)(buf + offset);

		/* Encapsulated IP */
		if (ip->ip_p != IPPROTO_IPIP)
			return (-1);

		memset(pc->pc_dmac, 0xff, ETHER_ADDR_LEN);
		offset += ip_len;

		pc->pc_htype = ARPHRD_ETHER;
		pc->pc_hlen = ETHER_ADDR_LEN;
		break;
	case HTYPE_ETHER:
		if (buflen < offset + ETHER_HDR_LEN)
			return (-1);

		memcpy(pc->pc_dmac, buf + offset, ETHER_ADDR_LEN);
		memcpy(pc->pc_smac, buf + offset + ETHER_ADDR_LEN,
		    ETHER_ADDR_LEN);
		offset += ETHER_HDR_LEN;

		pc->pc_htype = ARPHRD_ETHER;
		pc->pc_hlen = ETHER_ADDR_LEN;
		break;
	default:
		return (-1);
	}

	return (offset);
}

ssize_t
decode_udp_ip_header(unsigned char *buf, size_t buflen,
    size_t offset, struct packet_ctx *pc)
{
	struct ip *ip;
	struct udphdr *udp;
	unsigned char *data;
	u_int32_t ip_len;
	u_int32_t sum, usum;
	static unsigned int ip_packets_seen;
	static unsigned int ip_packets_bad_checksum;
	static unsigned int udp_packets_seen;
	static unsigned int udp_packets_bad_checksum;
	static unsigned int udp_packets_length_checked;
	static unsigned int udp_packets_length_overflow;
	int len;

	/* Assure that an entire IP header is within the buffer. */
	if (buflen < offset + sizeof(*ip))
		return (-1);
	ip_len = (buf[offset] & 0xf) << 2;
	if (buflen < offset + ip_len)
		return (-1);

	ip = (struct ip *)(buf + offset);
	ip_packets_seen++;

	/* Check the IP header checksum - it should be zero. */
	if (wrapsum(checksum(buf + offset, ip_len, 0)) != 0) {
		ip_packets_bad_checksum++;
		if (ip_packets_seen > 4 && ip_packets_bad_checksum != 0 &&
		    (ip_packets_seen / ip_packets_bad_checksum) < 2) {
			log_info("%u bad IP checksums seen in %u packets",
			    ip_packets_bad_checksum, ip_packets_seen);
			ip_packets_seen = ip_packets_bad_checksum = 0;
		}
		return (-1);
	}

	pc->pc_src.ss_len = sizeof(struct sockaddr_in);
	pc->pc_src.ss_family = AF_INET;
	memcpy(&ss2sin(&pc->pc_src)->sin_addr, &ip->ip_src,
	    sizeof(ss2sin(&pc->pc_src)->sin_addr));

	pc->pc_dst.ss_len = sizeof(struct sockaddr_in);
	pc->pc_dst.ss_family = AF_INET;
	memcpy(&ss2sin(&pc->pc_dst)->sin_addr, &ip->ip_dst,
	    sizeof(ss2sin(&pc->pc_dst)->sin_addr));

#ifdef DEBUG
	if (buflen != offset + ntohs(ip->ip_len))
		log_debug("ip length %d disagrees with bytes received %zd.",
		    ntohs(ip->ip_len), buflen - offset);
#endif

	/* Assure that the entire IP packet is within the buffer. */
	if (buflen < offset + ntohs(ip->ip_len))
		return (-1);

	/* Assure that the UDP header is within the buffer. */
	if (buflen < offset + ip_len + sizeof(*udp))
		return (-1);
	udp = (struct udphdr *)(buf + offset + ip_len);
	udp_packets_seen++;

	/* Assure that the entire UDP packet is within the buffer. */
	if (buflen < offset + ip_len + ntohs(udp->uh_ulen))
		return (-1);
	data = buf + offset + ip_len + sizeof(*udp);

	/*
	 * Compute UDP checksums, including the ``pseudo-header'', the
	 * UDP header and the data. If the UDP checksum field is zero,
	 * we're not supposed to do a checksum.
	 */
	udp_packets_length_checked++;
	len = ntohs(udp->uh_ulen) - sizeof(*udp);
	if ((len < 0) || (len + data > buf + buflen)) {
		udp_packets_length_overflow++;
		if (udp_packets_length_checked > 4 &&
		    udp_packets_length_overflow != 0 &&
		    (udp_packets_length_checked /
		    udp_packets_length_overflow) < 2) {
			log_info("%u udp packets in %u too long - dropped",
			    udp_packets_length_overflow,
			    udp_packets_length_checked);
			udp_packets_length_overflow =
			    udp_packets_length_checked = 0;
		}
		return (-1);
	}
	if (len + data != buf + buflen)
		log_debug("accepting packet with data after udp payload.");

	usum = udp->uh_sum;
	udp->uh_sum = 0;

	sum = wrapsum(checksum((unsigned char *)udp, sizeof(*udp),
	    checksum(data, len, checksum((unsigned char *)&ip->ip_src,
	    2 * sizeof(ip->ip_src),
	    IPPROTO_UDP + (u_int32_t)ntohs(udp->uh_ulen)))));

	udp_packets_seen++;
	if (usum && usum != sum) {
		udp_packets_bad_checksum++;
		if (udp_packets_seen > 4 && udp_packets_bad_checksum != 0 &&
		    (udp_packets_seen / udp_packets_bad_checksum) < 2) {
			log_info("%u bad udp checksums in %u packets",
			    udp_packets_bad_checksum, udp_packets_seen);
			udp_packets_seen = udp_packets_bad_checksum = 0;
		}
		return (-1);
	}

	ss2sin(&pc->pc_src)->sin_port = udp->uh_sport;
	ss2sin(&pc->pc_dst)->sin_port = udp->uh_dport;

	return (offset + ip_len + sizeof(*udp));
}
@


1.13
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.12 2016/12/08 19:18:15 rzalamena Exp $	*/
d63 1
a63 1
u_int32_t	checksum(unsigned char *, unsigned, u_int32_t);
d67 1
a67 1
checksum(unsigned char *buf, unsigned nbytes, u_int32_t sum)
d69 1
a69 1
	int i;
d99 3
a101 3
void
assemble_hw_header(struct interface_info *interface, unsigned char *buf,
    int *bufix, struct packet_ctx *pc)
d105 4
a108 3
	/* Use the supplied address or let the kernel fill it. */
	memcpy(eh.ether_shost, pc->pc_smac, ETHER_ADDR_LEN);
	memcpy(eh.ether_dhost, pc->pc_dmac, ETHER_ADDR_LEN);
d110 12
a121 1
	eh.ether_type = htons(ETHERTYPE_IP);
d123 1
a123 2
	memcpy(&buf[*bufix], &eh, ETHER_HDR_LEN);
	*bufix += ETHER_HDR_LEN;
d126 3
a128 3
void
assemble_udp_ip_header(struct interface_info *interface, unsigned char *buf,
    int *bufix, struct packet_ctx *pc, unsigned char *data, int len)
d133 3
d139 1
a139 1
	ip.ip_len = htons(sizeof(ip) + sizeof(udp) + len);
d149 2
a150 2
	memcpy(&buf[*bufix], &ip, sizeof(ip));
	*bufix += sizeof(ip);
d154 1
a154 1
	udp.uh_ulen = htons(sizeof(udp) + len);
d158 1
a158 1
	    checksum(data, len, checksum((unsigned char *)&ip.ip_src,
d162 4
a165 2
	memcpy(&buf[*bufix], &udp, sizeof(udp));
	*bufix += sizeof(udp);
d169 2
a170 2
decode_hw_header(struct interface_info *interface, unsigned char *buf,
    int bufix, struct packet_ctx *pc)
d172 11
a182 1
	size_t offset = 0;
d184 1
a184 7
	if (interface->hw_address.htype == HTYPE_IPSEC_TUNNEL) {
		u_int32_t ip_len;
		struct ip *ip;

		bufix += ENC_HDRLEN;
		ip_len = (buf[bufix] & 0xf) << 2;
		ip = (struct ip *)(buf + bufix);
d191 11
a201 4
		offset = ENC_HDRLEN + ip_len;
	} else {
		memcpy(pc->pc_dmac, buf + bufix, ETHER_ADDR_LEN);
		memcpy(pc->pc_smac, buf + bufix + ETHER_ADDR_LEN,
d203 7
a209 1
		offset = sizeof(struct ether_header);
a211 3
	pc->pc_htype = ARPHRD_ETHER;
	pc->pc_hlen = ETHER_ADDR_LEN;

d216 2
a217 2
decode_udp_ip_header(struct interface_info *interface, unsigned char *buf,
    int bufix, struct packet_ctx *pc, int buflen)
d233 1
a233 1
	if (sizeof(*ip) > buflen)
d235 2
a236 2
	ip_len = (buf[bufix] & 0xf) << 2;
	if (ip_len > buflen)
d238 2
a239 1
	ip = (struct ip *)(buf + bufix);
d243 1
a243 1
	if (wrapsum(checksum(buf + bufix, ip_len, 0)) != 0) {
d265 3
a267 3
	if (ntohs(ip->ip_len) != buflen)
		log_debug("ip length %d disagrees with bytes received %d.",
		    ntohs(ip->ip_len), buflen);
d271 1
a271 1
	if (ntohs(ip->ip_len) > buflen)
d275 1
a275 1
	if (ip_len + sizeof(*udp) > buflen)
d277 1
a277 1
	udp = (struct udphdr *)(buf + bufix + ip_len);
d281 1
a281 1
	if (ip_len + ntohs(udp->uh_ulen) > buflen)
d283 1
a283 1
	data = buf + bufix + ip_len + sizeof(*udp);
d292 1
a292 1
	if ((len < 0) || (len + data > buf + bufix + buflen)) {
d306 1
a306 1
	if (len + data != buf + bufix + buflen)
d332 1
a332 1
	return (ip_len + sizeof(*udp));
@


1.12
log
@Clean up function prototypes: use a single struct to hold all address
information instead of passing multiple different parameters. This also
prepares the dhcrelay code to receive new features, like: IPv6, layer 2
relaying.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.11 2016/02/07 00:49:28 krw Exp $	*/
d60 1
d216 1
a216 1
			note("%u bad IP checksums seen in %u packets",
d235 1
a235 1
		debug("ip length %d disagrees with bytes received %d.",
d267 1
a267 1
			note("%u udp packets in %u too long - dropped",
d276 1
a276 1
		debug("accepting packet with data after udp payload.");
d291 1
a291 1
			note("%u bad udp checksums in %u packets",
@


1.11
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.10 2016/02/03 14:48:36 krw Exp $	*/
d100 1
a100 1
    int *bufix, struct hardware *to)
d104 3
a106 7
	if (to != NULL && to->hlen == 6) /* XXX */
		memcpy(eh.ether_dhost, to->haddr, sizeof(eh.ether_dhost));
	else
		memset(eh.ether_dhost, 0xff, sizeof(eh.ether_dhost));

	/* source address is filled in by the kernel */
	memset(eh.ether_shost, 0x00, sizeof(eh.ether_shost));
d116 1
a116 2
    int *bufix, u_int32_t from, u_int32_t to, unsigned int port,
    unsigned char *data, int len)
d130 2
a131 2
	ip.ip_src.s_addr = from;
	ip.ip_dst.s_addr = to;
d137 2
a138 2
	udp.uh_sport = server_port;	/* XXX */
	udp.uh_dport = port;			/* XXX */
d153 1
a153 1
    int bufix, struct hardware *from)
a154 1
	struct ether_header eh;
d169 1
a169 1
		bzero(&eh, sizeof(eh));
d171 5
a175 3
	} else {	
		memcpy(&eh, buf + bufix, ETHER_HDR_LEN);
		offset = sizeof(eh);
d178 2
a179 3
	memcpy(from->haddr, eh.ether_shost, sizeof(eh.ether_shost));
	from->htype = ARPHRD_ETHER;
	from->hlen = sizeof(eh.ether_shost);
d186 1
a186 1
    int bufix, struct sockaddr_in *from, int buflen)
d222 9
a230 1
	memcpy(&from->sin_addr, &ip->ip_src, sizeof(from->sin_addr));
d297 2
a298 1
	memcpy(&from->sin_port, &udp->uh_sport, sizeof(udp->uh_sport));
@


1.10
log
@be very careful accepting packets via bpf. First check that the
fixed part of the IP header is completely present before using its
header length field.  Then use the data in the IP header to ensure
the entire IP packet is present. Then check that the entire UDP header
is present. Then use the data in the UDP header to ensure all the
data it thinks is present is actually present.

Started when tj@@ and a few others noticed ISC "DHCP CVE-2015-8605:
UDP payload length not properly checked".

ok sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.9 2016/02/02 23:18:16 sthen Exp $	*/
d43 4
a46 1
#include "dhcpd.h"
d48 1
d50 2
d55 6
@


1.9
log
@Variables to count seen packets should be unsigned.

From dhcpd/packet.c r1.8   ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.8 2016/02/02 23:16:58 sthen Exp $	*/
d184 1
a184 1
	u_int32_t ip_len = (buf[bufix] & 0xf) << 2;
d194 6
d201 1
a201 1
	udp = (struct udphdr *)(buf + bufix + ip_len);
a203 1
	ip_packets_seen++;
d215 3
d221 5
d227 10
a236 1
	memcpy(&from->sin_addr, &ip->ip_src, 4);
d243 1
a243 1
	data = buf + bufix + ip_len + sizeof(*udp);
a244 1
	udp_packets_length_checked++;
@


1.8
log
@Nuke local #define ETHER_HEADER_SIZE and use the identical value'd
ETHER_HDR_LEN from if_ether.h.

From dhcpd packet.c r1.6.  ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.7 2016/02/02 23:15:15 sthen Exp $	*/
d186 6
a191 6
	static int ip_packets_seen;
	static int ip_packets_bad_checksum;
	static int udp_packets_seen;
	static int udp_packets_bad_checksum;
	static int udp_packets_length_checked;
	static int udp_packets_length_overflow;
d203 1
a203 1
			note("%d bad IP checksums seen in %d packets",
d230 1
a230 1
			note("%d udp packets in %d too long - dropped",
d254 1
a254 1
			note("%d bad udp checksums in %d packets",
@


1.7
log
@Remove unused (a.k.a. always passed NULL) parameter 'data' from
decode_udp_ip_header() and the useless check of it. Part of original
diff from pelikan about udp length errors.

From dhcpd: bpf.c r1.9, dhcpd.h r1.46, packet.c r1.5

ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.6 2016/01/13 13:41:42 sthen Exp $	*/
a49 2
#define ETHER_HEADER_SIZE (ETHER_ADDR_LEN * 2 + sizeof(u_int16_t))

d102 2
a103 2
	memcpy(&buf[*bufix], &eh, ETHER_HEADER_SIZE);
	*bufix += ETHER_HEADER_SIZE;
d166 1
a166 1
		memcpy(&eh, buf + bufix, ETHER_HEADER_SIZE);
@


1.6
log
@"Check UDP length for short as well as long values" - apply the fix from
usr.sbin/dhcpd/packet.c r1.4 to dhcrelay.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.5 2014/10/25 03:23:49 lteo Exp $	*/
d181 1
a181 1
    int bufix, struct sockaddr_in *from, unsigned char *data, int buflen)
d185 1
d194 1
a194 1
	int len = 0;
d220 1
a220 1
	 * UDP header and the data.   If the UDP checksum field is zero,
d223 14
a236 17
	if (!data) {
		data = buf + bufix + ip_len + sizeof(*udp);
		len = ntohs(udp->uh_ulen) - sizeof(*udp);
		udp_packets_length_checked++;
		if ((len < 0) || (len + data > buf + bufix + buflen)) {
			udp_packets_length_overflow++;
			if (udp_packets_length_checked > 4 &&
			    udp_packets_length_overflow != 0 &&
			    (udp_packets_length_checked /
			    udp_packets_length_overflow) < 2) {
				note("%d udp packets in %d too long - dropped",
				    udp_packets_length_overflow,
				    udp_packets_length_checked);
				udp_packets_length_overflow =
				    udp_packets_length_checked = 0;
			}
			return (-1);
d238 1
a238 2
		if (len + data != buf + bufix + buflen)
			debug("accepting packet with data after udp payload.");
d240 2
@


1.5
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.4 2014/07/28 16:40:32 tobias Exp $	*/
d226 1
a226 1
		if (len + data > buf + bufix + buflen) {
@


1.4
log
@merge dhcpd's packet.c revision 1.7:

Fix very hard to reach DoS attack vector, which would involve more than
8 billion network packets.  Mixture of many many malformed and proper
packets could result in a division by zero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.3 2009/09/03 11:56:49 reyk Exp $	*/
a45 1
#include <netinet/in_systm.h>
@


1.3
log
@Add support for "DHCP-over-IPsec" by implementing RFC 3046 (DHCP Relay
Agent Information Option) and RFC 3456 (DHCP Configuration of IPsec
Tunnel Mode).  This allows to configure various IPsec clients
dynamically via DHCP; dhcrelay needs to listen on enc0 and forward
requests to a DHCP server that supports RFC 3046, like I recently did
for dhcpd(8).

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.1 2004/04/12 21:10:28 henning Exp $	*/
d203 1
a203 1
		if (ip_packets_seen > 4 &&
d230 1
d256 1
a256 1
		if (udp_packets_seen > 4 &&
@


1.2
log
@get rid of the -p switch, use fixed values for server and client ports,
rename port variables for clarity.
ok henning@@
@
text
@d45 1
d152 1
d154 18
a171 1
	memcpy(&eh, buf + bufix, ETHER_HEADER_SIZE);
d177 1
a177 1
	return (sizeof(eh));
@


1.1
log
@initial cut at split out dhcrelay, whacked from usr.sbin/dhcp/ and sbin/dhclient
@
text
@d1 1
a1 1
/*	$OpenBSD: packet.c,v 1.8 2004/02/25 14:22:12 henning Exp $	*/
a54 5
void	assemble_ethernet_header(struct interface_info *, unsigned char *,
	    int *, struct hardware *);
ssize_t	decode_ethernet_header(struct interface_info *, unsigned char *,
	    int bufix, struct hardware *);

d98 3
a100 5
	if (interface->hw_address.hlen == sizeof(eh.ether_shost))
		memcpy(eh.ether_shost, interface->hw_address.haddr,
		    sizeof(eh.ether_shost));
	else
		memset(eh.ether_shost, 0x00, sizeof(eh.ether_shost));
d132 1
a132 1
	udp.uh_sport = htons(LOCAL_PORT);	/* XXX */
@

