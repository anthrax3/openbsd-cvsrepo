head	1.63;
access;
symbols
	OPENBSD_6_2:1.63.0.2
	OPENBSD_6_2_BASE:1.63
	OPENBSD_6_1:1.61.0.4
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.38.0.12
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.4
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.8
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.6
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.4
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.34.0.4
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.31.0.8
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.4
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.29.0.6
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.4
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21;
locks; strict;
comment	@ * @;


1.63
date	2017.07.05.11.11.56;	author reyk;	state Exp;
branches;
next	1.62;
commitid	c6qYUZRbb5PAwMpz;

1.62
date	2017.04.04.15.50.29;	author reyk;	state Exp;
branches;
next	1.61;
commitid	tvLlcOOrW5yNQM7t;

1.61
date	2017.03.16.09.17.20;	author rzalamena;	state Exp;
branches;
next	1.60;
commitid	R3tclorDRfDgMJCY;

1.60
date	2017.03.15.14.31.49;	author rzalamena;	state Exp;
branches;
next	1.59;
commitid	oAWsNBMdv5xiRKZk;

1.59
date	2017.03.14.09.21.26;	author rzalamena;	state Exp;
branches;
next	1.58;
commitid	GTjvuoIXwdEkH5br;

1.58
date	2017.02.13.22.49.38;	author krw;	state Exp;
branches;
next	1.57;
commitid	FBXczmjzgB4n9tG1;

1.57
date	2017.02.13.22.05.35;	author krw;	state Exp;
branches;
next	1.56;
commitid	QXPg6tDHW3eZ87ZT;

1.56
date	2017.02.13.19.15.39;	author krw;	state Exp;
branches;
next	1.55;
commitid	b8On5ZZgQn2F03X7;

1.55
date	2016.12.16.18.38.39;	author rzalamena;	state Exp;
branches;
next	1.54;
commitid	tVAFTQFdKWUUPmyu;

1.54
date	2016.12.13.17.40.41;	author rzalamena;	state Exp;
branches;
next	1.53;
commitid	Ewt5YkK2ZWEnrccA;

1.53
date	2016.12.13.15.28.19;	author rzalamena;	state Exp;
branches;
next	1.52;
commitid	rjfY37lIoazTr6r0;

1.52
date	2016.12.13.09.29.05;	author rzalamena;	state Exp;
branches;
next	1.51;
commitid	TkMwAd5NpIARHKqh;

1.51
date	2016.12.13.06.55.32;	author jmc;	state Exp;
branches;
next	1.50;
commitid	GtEcGgKu27X3grvb;

1.50
date	2016.12.12.15.41.05;	author rzalamena;	state Exp;
branches;
next	1.49;
commitid	XgJSzaVYU9oklGPD;

1.49
date	2016.12.08.19.18.15;	author rzalamena;	state Exp;
branches;
next	1.48;
commitid	1Wx2EY9x67fSNeJ6;

1.48
date	2016.12.08.09.29.50;	author rzalamena;	state Exp;
branches;
next	1.47;
commitid	YoKu9xDxpQo7BWye;

1.47
date	2016.12.07.20.03.22;	author patrick;	state Exp;
branches;
next	1.46;
commitid	0N9uyDwpUE6oqavi;

1.46
date	2016.12.07.19.51.48;	author patrick;	state Exp;
branches;
next	1.45;
commitid	GhcjnGDuHmaatKbv;

1.45
date	2016.12.07.16.41.17;	author reyk;	state Exp;
branches;
next	1.44;
commitid	gLEJtag815YBXVgJ;

1.44
date	2016.12.07.13.19.18;	author rzalamena;	state Exp;
branches;
next	1.43;
commitid	VDu2qbLl73nAQJ9w;

1.43
date	2016.09.26.17.15.19;	author jca;	state Exp;
branches;
next	1.42;
commitid	cejVwQpY7FYSCLBx;

1.42
date	2016.09.15.16.16.03;	author jca;	state Exp;
branches;
next	1.41;
commitid	GzAm3cnfimMp8ONG;

1.41
date	2016.09.04.10.43.52;	author jca;	state Exp;
branches;
next	1.40;
commitid	hdyPGABm5dRupvJK;

1.40
date	2016.08.27.01.26.22;	author guenther;	state Exp;
branches;
next	1.39;
commitid	mLhDPn5m6RI81k8n;

1.39
date	2016.02.07.00.49.28;	author krw;	state Exp;
branches;
next	1.38;
commitid	KRCyy1qhM7Xq37Rf;

1.38
date	2013.03.04.00.29.56;	author benno;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.15.23.45.03;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2012.06.22.11.28.36;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2011.06.21.17.31.07;	author mikeb;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.03.04.44.52;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.03.10.14.09;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.03.11.56.49;	author reyk;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.09.20.08.13;	author sobrado;	state Exp;
branches;
next	1.30;

1.30
date	2008.07.09.19.41.56;	author sobrado;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.09.16.49.47;	author stevesk;	state Exp;
branches;
next	1.28;

1.28
date	2006.12.18.01.08.58;	author stevesk;	state Exp;
branches;
next	1.27;

1.27
date	2006.11.21.14.57.00;	author stevesk;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.13.20.26.00;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.23.22.54.34;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.02.02.29.27;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.25.16.55.04;	author norby;	state Exp;
branches;
next	1.22;

1.22
date	2004.10.12.16.39.35;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.15.23.24.14;	author jaredy;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.12.10.41.08;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.04.21.23.10;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.04.21.01.46.35;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.20.20.56.47;	author canacar;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.20.04.19.00;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.20.03.52.36;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.15.00.36.37;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.13.23.16.17;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.13.02.00.51;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.13.01.22.30;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.12.23.09.32;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.12.23.08.42;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.12.22.37.42;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.12.22.25.38;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.12.22.24.32;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.12.22.15.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.12.22.01.37;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.12.21.33.15;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.12.21.31.14;	author henning;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.12.21.10.28;	author henning;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Don't stop logging to stderr when running in foreground with -d.

Pointed out by Kapetanakis Giannis
@
text
@/*	$OpenBSD: dhcrelay.c,v 1.62 2017/04/04 15:50:29 reyk Exp $ */

/*
 * Copyright (c) 2004 Henning Brauer <henning@@cvs.openbsd.org>
 * Copyright (c) 1997, 1998, 1999 The Internet Software Consortium.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of The Internet Software Consortium nor the names
 *    of its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INTERNET SOFTWARE CONSORTIUM AND
 * CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE INTERNET SOFTWARE CONSORTIUM OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This software has been written for the Internet Software Consortium
 * by Ted Lemon <mellon@@fugue.com> in cooperation with Vixie
 * Enterprises.  To learn more about the Internet Software Consortium,
 * see ``http://www.vix.com/isc''.  To learn more about Vixie
 * Enterprises, see ``http://www.vix.com''.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <arpa/inet.h>

#include <net/if.h>

#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>

#include "dhcp.h"
#include "dhcpd.h"
#include "log.h"

void	 usage(void);
int	 rdaemon(int);
void	 relay(struct interface_info *, struct dhcp_packet *, int,
	    struct packet_ctx *);
void	 l2relay(struct interface_info *, struct dhcp_packet *, int,
	    struct packet_ctx *);
char	*print_hw_addr(int, int, unsigned char *);
void	 got_response(struct protocol *);
int	 get_rdomain(char *);

void	 relay_agentinfo(struct packet_ctx *, struct interface_info *, int);

int	 relay_agentinfo_cmp(struct packet_ctx *pc, uint8_t *, int);
ssize_t	 relay_agentinfo_append(struct packet_ctx *, struct dhcp_packet *,
	    size_t);
ssize_t	 relay_agentinfo_remove(struct packet_ctx *, struct dhcp_packet *,
	    size_t);

time_t cur_time;

struct interface_info *interfaces = NULL;
struct server_list *servers;
struct iflist intflist;
int server_fd;
int oflag;

enum dhcp_relay_mode	 drm = DRM_UNKNOWN;
const char		*rai_circuit = NULL;
const char		*rai_remote = NULL;
int			 rai_replace = 0;

int
main(int argc, char *argv[])
{
	int			 ch, devnull = -1, daemonize, opt, rdomain;
	struct server_list	*sp = NULL;
	struct passwd		*pw;
	struct sockaddr_in	 laddr;
	int			 optslen;

	daemonize = 1;

	log_init(1, LOG_DAEMON);	/* log to stderr until daemonized */

	setup_iflist();

	while ((ch = getopt(argc, argv, "aC:di:oR:r")) != -1) {
		switch (ch) {
		case 'C':
			rai_circuit = optarg;
			break;
		case 'd':
			daemonize = 0;
			break;
		case 'i':
			if (interfaces != NULL)
				usage();

			interfaces = iflist_getbyname(optarg);
			if (interfaces == NULL)
				fatalx("interface '%s' not found", optarg);
			break;
		case 'o':
			/* add the relay agent information option */
			oflag++;
			break;
		case 'R':
			rai_remote = optarg;
			break;
		case 'r':
			rai_replace = 1;
			break;

		default:
			usage();
			/* not reached */
		}
	}

	argc -= optind;
	argv += optind;

	if (argc < 1)
		usage();

	if (rai_remote != NULL && rai_circuit == NULL)
		fatalx("you must specify a circuit-id with a remote-id");

	/* Validate that we have space for all suboptions. */
	if (rai_circuit != NULL) {
		optslen = 2 + strlen(rai_circuit);
		if (rai_remote != NULL)
			optslen += 2 + strlen(rai_remote);

		if (optslen > DHCP_OPTION_MAXLEN)
			fatalx("relay agent information is too long");
	}

	while (argc > 0) {
		struct hostent		*he;
		struct in_addr		 ia, *iap = NULL;

		if ((sp = calloc(1, sizeof(*sp))) == NULL)
			fatalx("calloc");

		if ((sp->intf = register_interface(argv[0], got_one,
		    1)) != NULL) {
			if (drm == DRM_LAYER3)
				fatalx("don't mix interfaces with hosts");

			if (sp->intf->hw_address.htype == HTYPE_IPSEC_TUNNEL)
				fatalx("can't use IPSec with layer 2");

			sp->next = servers;
			servers = sp;

			drm = DRM_LAYER2;
			argc--;
			argv++;
			continue;
		}

		if (inet_aton(argv[0], &ia))
			iap = &ia;
		else {
			he = gethostbyname(argv[0]);
			if (!he)
				log_warnx("%s: host unknown", argv[0]);
			else
				iap = ((struct in_addr *)he->h_addr_list[0]);
		}
		if (iap) {
			if (drm == DRM_LAYER2)
				fatalx("don't mix interfaces with hosts");

			drm = DRM_LAYER3;
			sp->next = servers;
			servers = sp;
			memcpy(&ss2sin(&sp->to)->sin_addr, iap, sizeof(*iap));
		} else
			free(sp);

		argc--;
		argv++;
	}

	if (daemonize) {
		devnull = open(_PATH_DEVNULL, O_RDWR, 0);
		if (devnull == -1)
			fatal("open(%s)", _PATH_DEVNULL);
	}

	if (interfaces == NULL ||
	    register_interface(interfaces->name, got_one, 0) == NULL)
		fatalx("no interface given");

	/* We need an address for running layer 3 mode. */
	if (drm == DRM_LAYER3 &&
	    (interfaces->hw_address.htype != HTYPE_IPSEC_TUNNEL &&
	    interfaces->primary_address.s_addr == 0))
		fatalx("interface '%s' does not have an address",
		    interfaces->name);

	/* We need at least one server. */
	if (!sp)
		usage();

	rdomain = get_rdomain(interfaces->name);

	/* Enable the relay agent option by default for enc0 */
	if (interfaces->hw_address.htype == HTYPE_IPSEC_TUNNEL)
		oflag++;

	bzero(&laddr, sizeof laddr);
	laddr.sin_len = sizeof laddr;
	laddr.sin_family = AF_INET;
	laddr.sin_port = htons(SERVER_PORT);
	laddr.sin_addr.s_addr = interfaces->primary_address.s_addr;
	/* Set up the server sockaddrs. */
	for (sp = servers; sp; sp = sp->next) {
		if (sp->intf != NULL)
			break;

		ss2sin(&sp->to)->sin_port = htons(SERVER_PORT);
		ss2sin(&sp->to)->sin_family = AF_INET;
		ss2sin(&sp->to)->sin_len = sizeof(struct sockaddr_in);
		sp->fd = socket(AF_INET, SOCK_DGRAM, 0);
		if (sp->fd == -1)
			fatal("socket");
		opt = 1;
		if (setsockopt(sp->fd, SOL_SOCKET, SO_REUSEPORT,
		    &opt, sizeof(opt)) == -1)
			fatal("setsockopt");
		if (setsockopt(sp->fd, SOL_SOCKET, SO_RTABLE, &rdomain,
		    sizeof(rdomain)) == -1)
			fatal("setsockopt");
		if (bind(sp->fd, (struct sockaddr *)&laddr, sizeof laddr) ==
		    -1)
			fatal("bind");
		if (connect(sp->fd, (struct sockaddr *)&sp->to,
		    sp->to.ss_len) == -1)
			fatal("connect");
		add_protocol("server", sp->fd, got_response, sp);
	}

	/* Socket used to forward packets to the DHCP client */
	if (interfaces->hw_address.htype == HTYPE_IPSEC_TUNNEL) {
		laddr.sin_addr.s_addr = INADDR_ANY;
		server_fd = socket(AF_INET, SOCK_DGRAM, 0);
		if (server_fd == -1)
			fatal("socket");
		opt = 1;
		if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEPORT,
		    &opt, sizeof(opt)) == -1)
			fatal("setsockopt");
		if (setsockopt(server_fd, SOL_SOCKET, SO_RTABLE, &rdomain,
		    sizeof(rdomain)) == -1)
			fatal("setsockopt");
		if (bind(server_fd, (struct sockaddr *)&laddr,
		    sizeof(laddr)) == -1)
			fatal("bind");
	}

	tzset();

	time(&cur_time);
	if (drm == DRM_LAYER3)
		bootp_packet_handler = relay;
	else
		bootp_packet_handler = l2relay;

	if ((pw = getpwnam("_dhcp")) == NULL)
		fatalx("user \"_dhcp\" not found");
	if (chroot(_PATH_VAREMPTY) == -1)
		fatal("chroot");
	if (chdir("/") == -1)
		fatal("chdir(\"/\")");
	if (setgroups(1, &pw->pw_gid) ||
	    setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) ||
	    setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid))
		fatal("can't drop privileges");

	if (daemonize) {
		if (rdaemon(devnull) == -1)
			fatal("rdaemon");

		log_init(0, LOG_DAEMON);	/* stop logging to stderr */
	}

	if (pledge("stdio route", NULL) == -1)
		fatalx("pledge");

	dispatch();
	/* not reached */

	exit(0);
}

void
relay(struct interface_info *ip, struct dhcp_packet *packet, int length,
    struct packet_ctx *pc)
{
	struct server_list	*sp;
	struct sockaddr_in	 to;

	if (packet->hlen > sizeof packet->chaddr) {
		log_info("Discarding packet with invalid hlen.");
		return;
	}

	/* If it's a bootreply, forward it to the client. */
	if (packet->op == BOOTREPLY) {
		/* Filter packet that were not meant for us. */
		if (packet->giaddr.s_addr !=
		    interfaces->primary_address.s_addr)
			return;

		bzero(&to, sizeof(to));
		if (!(packet->flags & htons(BOOTP_BROADCAST))) {
			to.sin_addr = packet->yiaddr;
			to.sin_port = htons(CLIENT_PORT);
		} else {
			to.sin_addr.s_addr = htonl(INADDR_BROADCAST);
			to.sin_port = htons(CLIENT_PORT);
		}
		to.sin_family = AF_INET;
		to.sin_len = sizeof to;
		*ss2sin(&pc->pc_dst) = to;

		/*
		 * Set up the hardware destination address.  If it's a reply
		 * with the BROADCAST flag set, we should send an L2 broad-
		 * cast as well.
		 */
		if (!(packet->flags & htons(BOOTP_BROADCAST))) {
			pc->pc_hlen = packet->hlen;
			if (pc->pc_hlen > CHADDR_SIZE)
				pc->pc_hlen = CHADDR_SIZE;
			memcpy(pc->pc_dmac, packet->chaddr, pc->pc_hlen);
			pc->pc_htype = packet->htype;
		} else {
			memset(pc->pc_dmac, 0xff, sizeof(pc->pc_dmac));
		}

		relay_agentinfo(pc, interfaces, packet->op);
		if ((length = relay_agentinfo_remove(pc, packet,
		    length)) == -1) {
			log_info("ignoring BOOTREPLY with invalid "
			    "relay agent information");
			return;
		}

		/*
		 * VMware PXE "ROMs" confuse the DHCP gateway address
		 * with the IP gateway address. This is a problem if your
		 * DHCP relay is running on something that's not your
		 * network gateway.
		 *
		 * It is purely informational from the relay to the client
		 * so we can safely clear it.
		 */
		packet->giaddr.s_addr = 0x0;

		ss2sin(&pc->pc_src)->sin_addr = interfaces->primary_address;
		if (send_packet(interfaces, packet, length, pc) != -1)
			log_debug("forwarded BOOTREPLY for %s to %s",
			    print_hw_addr(packet->htype, packet->hlen,
			    packet->chaddr), inet_ntoa(to.sin_addr));
		return;
	}

	if (ip == NULL) {
		log_info("ignoring non BOOTREPLY from server");
		return;
	}

	if (packet->hops > 16) {
		log_info("ignoring BOOTREQUEST with hop count of %d",
		    packet->hops);
		return;
	}
	packet->hops++;

	/*
	 * Set the giaddr so the server can figure out what net it's
	 * from and so that we can later forward the response to the
	 * correct net.  The RFC specifies that we have to keep the
	 * initial giaddr (in case we relay over multiple hops).
	 */
	if (!packet->giaddr.s_addr)
		packet->giaddr = ip->primary_address;

	relay_agentinfo(pc, interfaces, packet->op);
	if ((length = relay_agentinfo_append(pc, packet, length)) == -1) {
		log_info("ignoring BOOTREQUEST with invalid "
		    "relay agent information");
		return;
	}

	/* Otherwise, it's a BOOTREQUEST, so forward it to all the
	   servers. */
	for (sp = servers; sp; sp = sp->next) {
		if (send(sp->fd, packet, length, 0) != -1) {
			log_debug("forwarded BOOTREQUEST for %s to %s",
			    print_hw_addr(packet->htype, packet->hlen,
			    packet->chaddr),
			    inet_ntoa(ss2sin(&sp->to)->sin_addr));
		}
	}

}

void
usage(void)
{
	extern char	*__progname;

	fprintf(stderr, "usage: %s [-dor] [-C circuit-id] [-R remote-id] "
	    "-i interface\n\tdestination ...\n",
	    __progname);
	exit(1);
}

int
rdaemon(int devnull)
{
	if (devnull == -1) {
		errno = EBADF;
		return (-1);
	}
	if (fcntl(devnull, F_GETFL) == -1)
		return (-1);

	switch (fork()) {
	case -1:
		return (-1);
	case 0:
		break;
	default:
		_exit(0);
	}

	if (setsid() == -1)
		return (-1);

	(void)dup2(devnull, STDIN_FILENO);
	(void)dup2(devnull, STDOUT_FILENO);
	(void)dup2(devnull, STDERR_FILENO);
	if (devnull > 2)
		(void)close(devnull);

	return (0);
}

char *
print_hw_addr(int htype, int hlen, unsigned char *data)
{
	static char	 habuf[49];
	char		*s = habuf;
	int		 i, j, slen = sizeof(habuf);

	if (htype == 0 || hlen == 0) {
bad:
		strlcpy(habuf, "<null>", sizeof habuf);
		return habuf;
	}

	for (i = 0; i < hlen; i++) {
		j = snprintf(s, slen, "%02x", data[i]);
		if (j <= 0 || j >= slen)
			goto bad;
		j = strlen (s);
		s += j;
		slen -= (j + 1);
		*s++ = ':';
	}
	*--s = '\0';
	return habuf;
}

void
got_response(struct protocol *l)
{
	struct packet_ctx pc;
	ssize_t result;
	union {
		/*
		 * Packet input buffer.  Must be as large as largest
		 * possible MTU.
		 */
		unsigned char packbuf[4095];
		struct dhcp_packet packet;
	} u;
	struct server_list *sp = l->local;

	memset(&u, DHO_END, sizeof(u));
	if ((result = recv(l->fd, u.packbuf, sizeof(u), 0)) == -1 &&
	    errno != ECONNREFUSED) {
		/*
		 * Ignore ECONNREFUSED as too many dhcp servers send a bogus
		 * icmp unreach for every request.
		 */
		log_warn("recv failed for %s",
		    inet_ntoa(ss2sin(&sp->to)->sin_addr));
		return;
	}
	if (result == -1 && errno == ECONNREFUSED)
		return;

	if (result == 0)
		return;

	if (result < BOOTP_MIN_LEN) {
		log_info("Discarding packet with invalid size.");
		return;
	}

	memset(&pc, 0, sizeof(pc));
	pc.pc_src.ss_family = AF_INET;
	pc.pc_src.ss_len = sizeof(struct sockaddr_in);
	memcpy(&ss2sin(&pc.pc_src)->sin_addr, &ss2sin(&sp->to)->sin_addr,
	    sizeof(ss2sin(&pc.pc_src)->sin_addr));
	ss2sin(&pc.pc_src)->sin_port = htons(SERVER_PORT);

	pc.pc_dst.ss_family = AF_INET;
	pc.pc_dst.ss_len = sizeof(struct sockaddr_in);
	ss2sin(&pc.pc_dst)->sin_port = htons(CLIENT_PORT);

	if (bootp_packet_handler)
		(*bootp_packet_handler)(NULL, &u.packet, result, &pc);
}

void
relay_agentinfo(struct packet_ctx *pc, struct interface_info *intf,
    int bootop)
{
	static u_int8_t		 buf[8];
	struct sockaddr_in	*sin;

	if (oflag == 0)
		return;

	if (rai_remote != NULL) {
		pc->pc_remote = rai_remote;
		pc->pc_remotelen = strlen(rai_remote);
	} else
		pc->pc_remotelen = 0;

	if (rai_circuit == NULL) {
		buf[0] = (uint8_t)(intf->index << 8);
		buf[1] = intf->index & 0xff;
		pc->pc_circuit = buf;
		pc->pc_circuitlen = 2;

		if (rai_remote == NULL) {
			if (bootop == BOOTREPLY)
				sin = ss2sin(&pc->pc_dst);
			else
				sin = ss2sin(&pc->pc_src);

			pc->pc_remote =
			    (uint8_t *)&sin->sin_addr;
			pc->pc_remotelen =
			    sizeof(sin->sin_addr);
		}
	} else {
		pc->pc_circuit = rai_circuit;
		pc->pc_circuitlen = strlen(rai_circuit);
	}
}

int
relay_agentinfo_cmp(struct packet_ctx *pc, uint8_t *p, int plen)
{
	int		 len;
	char		 buf[256];

	if (oflag == 0)
		return (-1);

	len = *(p + 1);
	if (len > plen)
		return (-1);

	switch (*p) {
	case RAI_CIRCUIT_ID:
		if (pc->pc_circuit == NULL)
			return (-1);
		if (pc->pc_circuitlen != len)
			return (-1);

		memcpy(buf, p + DHCP_OPTION_HDR_LEN, len);
		return (memcmp(pc->pc_circuit, buf, len));

	case RAI_REMOTE_ID:
		if (pc->pc_remote == NULL)
			return (-1);
		if (pc->pc_remotelen != len)
			return (-1);

		memcpy(buf, p + DHCP_OPTION_HDR_LEN, len);
		return (memcmp(pc->pc_remote, buf, len));

	default:
		/* Unmatched type */
		log_info("unmatched relay info %d", *p);
		return (0);
	}
}

ssize_t
relay_agentinfo_append(struct packet_ctx *pc, struct dhcp_packet *dp,
    size_t dplen)
{
	uint8_t		*p, *startp;
	ssize_t		 newtotal = dplen;
	int		 opttotal, optlen, i, hasinfo = 0;
	int		 maxlen, neededlen;

	/* Only append when enabled. */
	if (oflag == 0)
		return (dplen);

	startp = (uint8_t *)dp;
	p = (uint8_t *)&dp->options;
	if (memcmp(p, DHCP_OPTIONS_COOKIE, DHCP_OPTIONS_COOKIE_LEN)) {
		log_info("invalid dhcp options cookie");
		return (-1);
	}

	p += DHCP_OPTIONS_COOKIE_LEN;
	opttotal = dplen - DHCP_FIXED_NON_UDP - DHCP_OPTIONS_COOKIE_LEN;
	maxlen = DHCP_MTU_MAX - DHCP_FIXED_LEN - DHCP_OPTIONS_COOKIE_LEN - 1;
	if (maxlen < 1 || opttotal < 1)
		return (dplen);

	for (i = 0; i < opttotal && *p != DHO_END;) {
		if (*p == DHO_PAD)
			optlen = 1;
		else
			optlen = p[1] + DHCP_OPTION_HDR_LEN;

		if ((i + optlen) > opttotal) {
			log_info("truncated dhcp options");
			return (-1);
		}

		if (*p == DHO_RELAY_AGENT_INFORMATION) {
			if (rai_replace) {
				memmove(p, p + optlen, opttotal - i);
				opttotal -= optlen;
				optlen = 0;
			} else
				hasinfo = 1;
		}

		p += optlen;
		i += optlen;

		/* We reached the end, append the relay agent info. */
		if (i < opttotal && *p == DHO_END) {
			/* We already have the Relay Agent Info, skip it. */
			if (hasinfo)
				continue;

			/* Calculate needed length to append new data. */
			neededlen = newtotal + DHCP_OPTION_HDR_LEN;
			if (pc->pc_circuitlen > 0)
				neededlen += DHCP_OPTION_HDR_LEN +
				    pc->pc_circuitlen;
			if (pc->pc_remotelen > 0)
				neededlen += DHCP_OPTION_HDR_LEN +
				    pc->pc_remotelen;

			/* Save one byte for DHO_END. */
			neededlen += 1;

			/* Check if we have space for the new options. */
			if (neededlen > maxlen) {
				log_warnx("no space for relay agent info");
				return (newtotal);
			}

			/* New option header: 2 bytes. */
			newtotal += DHCP_OPTION_HDR_LEN;

			*p++ = DHO_RELAY_AGENT_INFORMATION;
			*p = 0;
			if (pc->pc_circuitlen > 0) {
				newtotal += DHCP_OPTION_HDR_LEN +
				    pc->pc_circuitlen;
				*p = (*p) + DHCP_OPTION_HDR_LEN +
				    pc->pc_circuitlen;
			}

			if (pc->pc_remotelen > 0) {
				newtotal += DHCP_OPTION_HDR_LEN +
				    pc->pc_remotelen;
				*p = (*p) + DHCP_OPTION_HDR_LEN +
				    pc->pc_remotelen;
			}

			p++;

			/* Sub-option circuit-id header plus value. */
			if (pc->pc_circuitlen > 0) {
				*p++ = RAI_CIRCUIT_ID;
				*p++ = pc->pc_circuitlen;
				memcpy(p, pc->pc_circuit, pc->pc_circuitlen);

				p += pc->pc_circuitlen;
			}

			/* Sub-option remote-id header plus value. */
			if (pc->pc_remotelen > 0) {
				*p++ = RAI_REMOTE_ID;
				*p++ = pc->pc_remotelen;
				memcpy(p, pc->pc_remote, pc->pc_remotelen);

				p += pc->pc_remotelen;
			}

			*p = DHO_END;
		}
	}

	/* Zero the padding so we don't leak anything. */
	p++;
	if (p < (startp + maxlen))
		memset(p, 0, (startp + maxlen) - p);

	return (newtotal);
}

ssize_t
relay_agentinfo_remove(struct packet_ctx *pc, struct dhcp_packet *dp,
    size_t dplen)
{
	uint8_t		*p, *np, *startp, *endp;
	int		 opttotal, optleft;
	int		 suboptlen, optlen, i;
	int		 maxlen, remaining, matched = 0;

	startp = (uint8_t *)dp;
	p = (uint8_t *)&dp->options;
	if (memcmp(p, DHCP_OPTIONS_COOKIE, DHCP_OPTIONS_COOKIE_LEN)) {
		log_info("invalid dhcp options cookie");
		return (-1);
	}

	maxlen = DHCP_MTU_MAX - DHCP_FIXED_LEN - DHCP_OPTIONS_COOKIE_LEN - 1;
	opttotal = dplen - DHCP_FIXED_NON_UDP - DHCP_OPTIONS_COOKIE_LEN;
	optleft = opttotal;

	p += DHCP_OPTIONS_COOKIE_LEN;
	endp = p + opttotal;

	for (i = 0; i < opttotal && *p != DHO_END;) {
		if (*p == DHO_PAD)
			optlen = 1;
		else
			optlen = p[1] + DHCP_OPTION_HDR_LEN;

		if ((i + optlen) > opttotal) {
			log_info("truncated dhcp options");
			return (-1);
		}

		if (*p == DHO_RELAY_AGENT_INFORMATION) {
			/* Fast case: there is no next option. */
			np = p + optlen;
			if (*np == DHO_END) {
				*p = *np;
				endp = p + 1;
				/* Zero the padding so we don't leak data. */
				if (endp < (startp + maxlen))
					memset(endp, 0,
					    (startp + maxlen) - endp);

				return (dplen);
			}

			remaining = optlen;
			while (remaining > 0) {
				suboptlen = *(p + 1);
				remaining -= DHCP_OPTION_HDR_LEN + suboptlen;

				matched = 1;
				if (relay_agentinfo_cmp(pc, p, suboptlen) == 0)
					continue;

				matched = 0;
				break;
			}
			/* It is not ours Relay Agent Info, don't remove it. */
			if (matched == 0)
				break;

			/* Move the other options on top of this one. */
			optleft -= optlen;
			endp -= optlen;

			/* Replace the old agent relay info. */
			memmove(p, dp, optleft);

			endp++;
			/* Zero the padding so we don't leak data. */
			if (endp < (startp + maxlen))
				memset(endp, 0,
				    (startp + maxlen) - endp);

			return (endp - startp);
		}

		p += optlen;
		i += optlen;
		optleft -= optlen;
	}

	return (endp - startp);
}

int
get_rdomain(char *name)
{
	int rv = 0, s;
	struct  ifreq ifr;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		fatal("get_rdomain socket");

	bzero(&ifr, sizeof(ifr));
	strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
	if (ioctl(s, SIOCGIFRDOMAIN, (caddr_t)&ifr) != -1)
		rv = ifr.ifr_rdomainid;

	close(s);
	return rv;
}

void
l2relay(struct interface_info *ip, struct dhcp_packet *dp, int length,
    struct packet_ctx *pc)
{
	struct server_list	*sp;
	ssize_t			 dplen;

	if (dp->hlen > sizeof(dp->chaddr)) {
		log_info("Discarding packet with invalid hlen.");
		return;
	}

	relay_agentinfo(pc, ip, dp->op);

	switch (dp->op) {
	case BOOTREQUEST:
		/* Add the relay agent info asked by the user. */
		if ((dplen = relay_agentinfo_append(pc, dp, length)) == -1)
			return;

		/*
		 * Re-send the packet to every interface except the one
		 * it came in.
		 */
		for (sp = servers; sp != NULL; sp = sp->next) {
			if (sp->intf == ip)
				continue;

			log_debug("forwarded BOOTREQUEST for %s to %s",
			    print_hw_addr(pc->pc_htype, pc->pc_hlen,
			    pc->pc_smac), sp->intf->name);

			send_packet(sp->intf, dp, dplen, pc);
		}
		if (ip != interfaces) {
			log_debug("forwarded BOOTREQUEST for %s to %s",
			    print_hw_addr(pc->pc_htype, pc->pc_hlen,
			    pc->pc_smac), interfaces->name);

			send_packet(interfaces, dp, dplen, pc);
		}
		break;

	case BOOTREPLY:
		/* Remove relay agent info on offer. */
		if ((dplen = relay_agentinfo_remove(pc, dp, length)) == -1)
			return;

		if (ip != interfaces) {
			log_debug("forwarded BOOTREPLY for %s to %s",
			    print_hw_addr(pc->pc_htype, pc->pc_hlen,
			    pc->pc_dmac), interfaces->name);
			send_packet(interfaces, dp, dplen, pc);
		}
		break;

	default:
		log_debug("invalid operation type '%d'", dp->op);
		return;
	}
}
@


1.62
log
@constify pc_remote and pc_circuit

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.61 2017/03/16 09:17:20 rzalamena Exp $ */
a108 1
	log_setverbose(1);
d311 2
a313 2
	log_init(0, LOG_DAEMON);	/* stop loggoing to stderr */
	log_setverbose(0);
@


1.61
log
@Move the server struct to header file and make it compatible with IPv6.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.60 2017/03/15 14:31:49 rzalamena Exp $ */
d570 1
a570 1
		pc->pc_remote = (u_int8_t *)rai_remote;
d593 1
a593 1
		pc->pc_circuit = (u_int8_t *)rai_circuit;
@


1.60
log
@Improve the interface and addresses discovery code and prepare to
receive IPv6 support.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.59 2017/03/14 09:21:26 rzalamena Exp $ */
d87 1
a96 7
struct server_list {
	struct interface_info *intf;
	struct server_list *next;
	struct sockaddr_in to;
	int fd;
} *servers;

d205 1
a205 1
			memcpy(&sp->to.sin_addr, iap, sizeof *iap);
d250 3
a252 3
		sp->to.sin_port = htons(SERVER_PORT);
		sp->to.sin_family = AF_INET;
		sp->to.sin_len = sizeof sp->to;
d267 1
a267 1
		    sizeof sp->to) == -1)
d432 2
a433 1
			    packet->chaddr), inet_ntoa(sp->to.sin_addr));
d529 2
a530 1
		log_warn("recv failed for %s", inet_ntoa(sp->to.sin_addr));
d547 1
a547 1
	memcpy(&ss2sin(&pc.pc_src)->sin_addr, &sp->to.sin_addr,
@


1.59
log
@Remove some global variables that are not being used.

ok gsoares@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.58 2017/02/13 22:49:38 krw Exp $ */
d87 1
d117 2
d131 1
a131 1
			interfaces = get_interface(optarg, got_one, 0);
d178 2
a179 1
		if ((sp->intf = get_interface(argv[0], got_one, 1)) != NULL) {
d225 2
a226 1
	if (interfaces == NULL)
d228 1
@


1.58
log
@Eliminate pointless'%m' (a.k.a. hand rolled strerror()) by using fatal() and
log_warn(). Zap a couple of explicit 'syslog()' calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.57 2017/02/13 22:05:35 krw Exp $ */
a85 5
int log_perror = 1;

u_int16_t server_port;
u_int16_t client_port;
int log_priority;
a229 4
	/* Default DHCP/BOOTP ports. */
	server_port = htons(SERVER_PORT);
	client_port = htons(CLIENT_PORT);

d243 1
a243 1
	laddr.sin_port = server_port;
d250 1
a250 1
		sp->to.sin_port = server_port;
a311 1
		log_perror = 0;
d347 1
a347 1
			to.sin_port = client_port;
d350 1
a350 1
			to.sin_port = client_port;
d547 1
a547 1
	ss2sin(&pc.pc_src)->sin_port = server_port;
d551 1
a551 1
	ss2sin(&pc.pc_dst)->sin_port = client_port;
@


1.57
log
@Adjust some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.56 2017/02/13 19:15:39 krw Exp $ */
d223 1
a223 1
			fatalx("open(%s): %m", _PATH_DEVNULL);
d264 1
a264 1
			fatalx("socket: %m");
d268 1
a268 1
			fatalx("setsockopt: %m");
d271 1
a271 1
			fatalx("setsockopt: %m");
d274 1
a274 1
			fatalx("bind: %m");
d277 1
a277 1
			fatalx("connect: %m");
d286 1
a286 1
			fatalx("socket: %m");
d290 1
a290 1
			fatalx("setsockopt: %m");
d293 1
a293 1
			fatalx("setsockopt: %m");
d296 1
a296 1
			fatalx("bind: %m");
d310 1
a310 1
		fatalx("chroot: %m");
d312 1
a312 1
		fatalx("chdir(\"/\"): %m");
d316 1
a316 1
		fatalx("can't drop privileges: %m");
d320 1
a320 1
			fatalx("rdaemon: %m");
d538 1
a538 2
		log_warnx("recv failed for %s: %m",
		    inet_ntoa(sp->to.sin_addr));
d864 1
a864 1
		fatalx("get_rdomain socket: %m");
@


1.56
log
@Switch from old errwarn.c logging to shiny new log.[ch].

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.55 2016/12/16 18:38:39 rzalamena Exp $ */
d272 2
a273 1
		if (bind(sp->fd, (struct sockaddr *)&laddr, sizeof laddr) == -1)
d713 1
a713 1
			/* Check if we have enough space for the new options. */
@


1.55
log
@Add dhcrelay(8) command-line option for replacing Relay Agent Information
on the incoming packets.

Man page tweaks from jmc@@
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.54 2016/12/13 17:40:41 rzalamena Exp $ */
d64 1
a110 1
	extern char		*__progname;
d118 2
a119 3
	/* Initially, log errors to stderr as well as to syslogd. */
	openlog(__progname, LOG_NDELAY, DHCPD_LOG_FACILITY);
	setlogmask(LOG_UPTO(LOG_INFO));
d135 1
a135 1
				error("interface '%s' not found", optarg);
d161 1
a161 1
		error("you must specify a circuit-id with a remote-id");
d170 1
a170 1
			error("relay agent information is too long");
d178 1
a178 1
			error("calloc");
d182 1
a182 1
				error("don't mix interfaces with hosts");
d185 1
a185 1
				error("can't use IPSec with layer 2");
d201 1
a201 1
				warning("%s: host unknown", argv[0]);
d207 1
a207 1
				error("don't mix interfaces with hosts");
d223 1
a223 1
			error("open(%s): %m", _PATH_DEVNULL);
d227 1
a227 1
		error("no interface given");
d232 1
a232 1
		error("interface '%s' does not have an address",
d264 1
a264 1
			error("socket: %m");
d268 1
a268 1
			error("setsockopt: %m");
d271 1
a271 1
			error("setsockopt: %m");
d273 1
a273 1
			error("bind: %m");
d276 1
a276 1
			error("connect: %m");
d285 1
a285 1
			error("socket: %m");
d289 1
a289 1
			error("setsockopt: %m");
d292 1
a292 1
			error("setsockopt: %m");
d295 1
a295 1
			error("bind: %m");
d307 1
a307 1
		error("user \"_dhcp\" not found");
d309 1
a309 1
		error("chroot: %m");
d311 1
a311 1
		error("chdir(\"/\"): %m");
d315 1
a315 1
		error("can't drop privileges: %m");
d319 1
a319 1
			error("rdaemon: %m");
d322 2
d326 1
a326 1
		error("pledge");
d342 1
a342 1
		note("Discarding packet with invalid hlen.");
d383 1
a383 1
			note("ignoring BOOTREPLY with invalid "
d401 1
a401 1
			debug("forwarded BOOTREPLY for %s to %s",
d408 1
a408 1
		note("ignoring non BOOTREPLY from server");
d413 1
a413 1
		note("ignoring BOOTREQUEST with hop count of %d",
d430 1
a430 1
		note("ignoring BOOTREQUEST with invalid "
d439 1
a439 1
			debug("forwarded BOOTREQUEST for %s to %s",
d537 1
a537 1
		warning("recv failed for %s: %m",
d548 1
a548 1
		note("Discarding packet with invalid size.");
d640 1
a640 1
		note("unmatched relay info %d", *p);
d661 1
a661 1
		note("invalid dhcp options cookie");
d678 1
a678 1
			note("truncated dhcp options");
d714 1
a714 1
				warning("no space for relay agent info");
d781 1
a781 1
		note("invalid dhcp options cookie");
d799 1
a799 1
			note("truncated dhcp options");
d864 1
a864 1
		error("get_rdomain socket: %m");
d883 1
a883 1
		note("Discarding packet with invalid hlen.");
d903 1
a903 1
			debug("forwarded BOOTREQUEST for %s to %s",
d910 1
a910 1
			debug("forwarded BOOTREQUEST for %s to %s",
d924 1
a924 1
			debug("forwarded BOOTREPLY for %s to %s",
d932 1
a932 1
		debug("invalid operation type '%d'", dp->op);
@


1.54
log
@Unbreak the dhcrelay(8) support to run on enc(4) interfaces.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.53 2016/12/13 15:28:19 rzalamena Exp $ */
d97 1
d122 1
a122 1
	while ((ch = getopt(argc, argv, "aC:di:oR:")) != -1) {
d145 3
d451 1
a451 1
	fprintf(stderr, "usage: %s [-do] [-C circuit-id] [-R remote-id] "
d682 6
a687 2
			hasinfo = 1;
			continue;
@


1.53
log
@Unbreak the insertion of Relay Agent Information on layer 3 mode when
using the default values: use the right address for remote-id.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.52 2016/12/13 09:29:05 rzalamena Exp $ */
d227 2
a228 1
	    interfaces->primary_address.s_addr == 0)
@


1.52
log
@Filter DHCP reply messages that were not meant for us by looking at the
gateway set. This happens mostly because we are watching a BPF socket.

Suggested by and ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.51 2016/12/13 06:55:32 jmc Exp $ */
d75 1
a75 1
void	 relay_agentinfo(struct packet_ctx *, struct interface_info *);
a339 2
	relay_agentinfo(pc, ip);

d374 1
d422 1
d562 2
a563 1
relay_agentinfo(struct packet_ctx *pc, struct interface_info *intf)
d565 2
a566 1
	static u_int8_t		buf[8];
d584 5
d590 1
a590 1
			    (uint8_t *)&ss2sin(&pc->pc_dst)->sin_addr;
d592 1
a592 1
			    sizeof(ss2sin(&pc->pc_dst)->sin_addr);
d877 1
a877 1
	relay_agentinfo(pc, ip);
@


1.51
log
@simplify previous; ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.50 2016/12/12 15:41:05 rzalamena Exp $ */
d344 5
@


1.50
log
@Implement support for layer 2 relaying and add further Relay Agent
Information (RFC 3046) options. While at there change the naming of the
remote destination parameters: instead of "server" call it "destination".

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.49 2016/12/08 19:18:15 rzalamena Exp $ */
d442 1
a442 1
	    "-i interface\n\tdestination1 [... destinationN]\n",
@


1.49
log
@Clean up function prototypes: use a single struct to hold all address
information instead of passing multiple different parameters. This also
prepares the dhcrelay code to receive new features, like: IPv6, layer 2
relaying.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.48 2016/12/08 09:29:50 rzalamena Exp $ */
d69 2
d75 7
a81 2
ssize_t	 relay_agentinfo(struct interface_info *, struct dhcp_packet *,
	    size_t, struct in_addr *, struct in_addr *);
d94 4
d99 1
d113 1
d121 1
a121 1
	while ((ch = getopt(argc, argv, "adi:o")) != -1) {
d123 3
d133 1
a133 1
			interfaces = get_interface(optarg, got_one);
d141 3
d157 13
d174 19
d203 4
a206 2
			if ((sp = calloc(1, sizeof *sp)) == NULL)
				error("calloc");
d210 3
a212 1
		}
d225 3
a227 1
	if (interfaces->primary_address.s_addr == 0)
d252 3
d297 4
a300 1
	bootp_packet_handler = relay;
d340 2
d371 2
a372 2
		if ((length = relay_agentinfo(interfaces,
		    packet, length, NULL, &to.sin_addr)) == -1) {
d418 1
a418 2
	if ((length = relay_agentinfo(ip, packet, length,
	    &ss2sin(&pc->pc_src)->sin_addr, NULL)) == -1) {
d441 2
a442 1
	fprintf(stderr, "usage: %s [-do] -i interface server1 [... serverN]\n",
d556 71
d628 2
a629 2
relay_agentinfo(struct interface_info *info, struct dhcp_packet *packet,
    size_t length, struct in_addr *from, struct in_addr *to)
d631 15
a645 3
	u_int8_t	*p;
	u_int		 i, j, railen;
	ssize_t		 optlen, maxlen, grow;
d647 115
a761 2
	if (!oflag)
		return (length);
a762 1
	/* Buffer length vs. received packet length */
d764 2
a765 8
	optlen = length - DHCP_FIXED_NON_UDP - DHCP_OPTIONS_COOKIE_LEN;
	if (maxlen < 1 || optlen < 1)
		return (length);

	if (memcmp(packet->options, DHCP_OPTIONS_COOKIE,
	    DHCP_OPTIONS_COOKIE_LEN) != 0)
		return (length);
	p = packet->options + DHCP_OPTIONS_COOKIE_LEN;
d767 4
a770 1
	for (i = 0; i < (u_int)optlen && *p != DHO_END;) {
d772 1
a772 1
			j = 1;
d774 1
a774 1
			j = p[1] + 2;
d776 3
a778 3
		if ((i + j) > (u_int)optlen) {
			warning("truncated dhcp options");
			break;
a780 1
		/* Revert any other relay agent information */
d782 11
a792 20
			if (to != NULL) {
				/* Check the relay agent information */
				railen = 8 + sizeof(struct in_addr);
				if (j >= railen &&
				    p[1] == (railen - 2) &&
				    p[2] == RAI_CIRCUIT_ID &&
				    p[3] == 2 &&
				    p[4] == (u_int8_t)(info->index << 8) &&
				    p[5] == (info->index & 0xff) &&
				    p[6] == RAI_REMOTE_ID &&
				    p[7] == sizeof(*to))
					memcpy(to, p + 8, sizeof(*to));

				/* It should be the last option */
				memset(p, 0, j);
				*p = DHO_END;
			} else {
				/* Discard invalid option from a client */
				if (!packet->giaddr.s_addr)
					return (-1);
a793 2
			return (length);
		}
d795 8
a802 2
		p += j;
		i += j;
d804 1
a804 4
		if (from != NULL && (*p == DHO_END || (i >= optlen))) {
			j = 8 + sizeof(*from);
			if ((i + j) > (u_int)maxlen) {
				warning("skipping agent information");
d807 3
d811 12
a822 16
			/* Append the relay agent information if it fits */
			p[0] = DHO_RELAY_AGENT_INFORMATION;
			p[1] = j - 2;
			p[2] = RAI_CIRCUIT_ID;
			p[3] = 2;
			p[4] = info->index << 8;
			p[5] = info->index & 0xff;
			p[6] = RAI_REMOTE_ID;
			p[7] = sizeof(*from);
			memcpy(p + 8, from, sizeof(*from));

			/* Do we need to increase the packet length? */
			grow = j + 1 - (optlen - i);
			if (grow > 0)
				length += grow;
			p += j;
d824 1
a824 2
			*p = DHO_END;
			break;
d826 4
d832 1
a832 1
	return (length);
d851 62
@


1.48
log
@Simplify get_interfaces function, make it return NULL if we didn't find
the interface and abort dhcrelay with a more friendly message when we
don't have an address configured in the interface.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.47 2016/12/07 20:03:22 patrick Exp $ */
d68 1
a68 1
	    unsigned int, struct iaddr, struct hardware *);
d267 1
a267 1
    unsigned int from_port, struct iaddr from, struct hardware *hfrom)
a270 1
	struct hardware		 hto;
d289 1
d297 5
a301 5
			hto.hlen = packet->hlen;
			if (hto.hlen > sizeof hto.haddr)
				hto.hlen = sizeof hto.haddr;
			memcpy(hto.haddr, packet->chaddr, hto.hlen);
			hto.htype = packet->htype;
d303 1
a303 1
			bzero(&hto, sizeof(hto));
d324 2
a325 2
		if (send_packet(interfaces, packet, length,
		    interfaces->primary_address, &to, &hto) != -1)
d354 1
a354 1
	    (struct in_addr *)from.iabuf, NULL)) == -1) {
d442 1
a443 1
	struct iaddr ifrom;
d476 10
a485 3
	if (bootp_packet_handler) {
		ifrom.len = 4;
		memcpy(ifrom.iabuf, &sp->to.sin_addr, ifrom.len);
d487 2
a488 3
		(*bootp_packet_handler)(NULL, &u.packet, result,
		    sp->to.sin_port, ifrom, NULL);
	}
@


1.47
log
@DHCP requests can be relayed through multiple relays.  Currently we
drop requests that have already been relayed.  To allow usage in the
middle of a chain, remove this check and only set giaddr if it has not
been set yet.  This giaddr will be used by the DHCP server to identify
which subnet the client is connected to.

RFC 1542 specifies that we should increase the hop counter every time
we relay a request.  If we receive a request whose hop counter exceeds
the value of 16 we must silently drop it.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.46 2016/12/07 19:51:48 patrick Exp $ */
d118 2
d170 3
@


1.46
log
@If the BROADCAST flag is set on a BOOTREPLY, the RFC specifies that
we SHOULD forward the packet not only as L3 broadcast, but also as
L2 broadcast.  Apparently that helps on older machines that can't
handle L2 unicast replies.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.45 2016/12/07 16:41:17 reyk Exp $ */
d332 3
a334 5
	/* If giaddr is set on a BOOTREQUEST, ignore it - it's already
	   been gatewayed. */
	if (packet->giaddr.s_addr) {
		note("ignoring BOOTREQUEST with giaddr of %s",
		    inet_ntoa(packet->giaddr));
d337 1
d339 8
a346 4
	/* Set the giaddr so the server can figure out what net it's
	   from and so that we can later forward the response to the
	   correct net. */
	packet->giaddr = ip->primary_address;
@


1.45
log
@pledge(2) dhcrelay with "stdio route".  route is needed for interface ioctls.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.44 2016/12/07 13:19:18 rzalamena Exp $ */
d286 14
a299 6
		/* Set up the hardware destination address. */
		hto.hlen = packet->hlen;
		if (hto.hlen > sizeof hto.haddr)
			hto.hlen = sizeof hto.haddr;
		memcpy(hto.haddr, packet->chaddr, hto.hlen);
		hto.htype = packet->htype;
@


1.44
log
@Rename function discover_interfaces into get_interface and change its
prototype to be more useful.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.43 2016/09/26 17:15:19 jca Exp $ */
d250 3
@


1.43
log
@Exit early from rdaemon() is the passed fd is invalid.

fd == -1 check suggested by deraadt@@, ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.42 2016/09/15 16:16:03 jca Exp $ */
d116 2
a117 5
			if ((interfaces = calloc(1,
			    sizeof(struct interface_info))) == NULL)
				error("calloc");
			strlcpy(interfaces->name, optarg,
			    sizeof(interfaces->name));
d123 1
a123 1
			
a175 2

	discover_interfaces(interfaces);
@


1.42
log
@Go in the background later, using rdaemon().

rdaemon() works like daemon(3) but requires its caller to pre-open
/dev/null.  This makes it possible to go in the background after
a chroot(2), allowing for more error checking.  The pattern is basically
- open /dev/null
- chroot
- privdrop
- rdaemon

"design" initialy discussed with semarie@@ a while ago, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.41 2016/09/04 10:43:52 jca Exp $ */
d371 6
@


1.41
log
@Avoid double negations in tests.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.40 2016/08/27 01:26:22 guenther Exp $ */
d51 1
d66 1
d96 1
a96 1
	int			 ch, daemonize, opt, rdomain;
d163 5
a167 2
	if (daemonize)
		log_perror = 0;
a237 2
	if (daemonize)
		daemon(0, 0);
d250 6
d366 25
@


1.40
log
@Pull in <time.h> for one or more of gmtime, strftime, strptime, time,
timegm, and tzset

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.39 2016/02/07 00:49:28 krw Exp $ */
d94 1
a94 1
	int			 ch, no_daemon = 0, opt, rdomain;
d100 2
d109 1
a109 1
			no_daemon = 1;
d161 1
a161 1
	if (!no_daemon)
d233 1
a233 1
	if (!no_daemon)
@


1.39
log
@Eliminate #include inside *.h files and include only needed headers in
each *.c file.

Inspired by mention of header silliness by Edgar Pettijohn and mmcc@@
on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.38 2013/03/04 00:29:56 benno Exp $ */
d58 1
@


1.38
log
@typo in comment
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.37 2013/01/15 23:45:03 dlg Exp $ */
d42 19
a61 1
#include <sys/ioctl.h>
@


1.37
log
@VMware PXE "ROMs" confuse the DHCP gateway address with the IP
gateway address. This is a problem if your DHCP relay is running
on something that's not your network gateway.

It is purely informational from the relay to the client so we can
safely clear it.

stupid vmware.

ok krw@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.36 2012/06/22 11:28:36 krw Exp $ */
d383 1
a383 1
		 * Ignore ECONNREFUSED as to many dhcp server send a bogus
@


1.36
log
@'ingnoring' -> 'ignoring' in a couple of note()'s.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.35 2011/06/21 17:31:07 mikeb Exp $ */
d271 11
@


1.35
log
@Convert SO_RTABLE's protocol level to the SOL_SOCKET;  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.34 2010/07/03 04:44:52 guenther Exp $ */
d267 1
a267 1
			note("ingnoring BOOTREPLY with invalid "
d300 1
a300 1
		note("ingnoring BOOTREQUEST with invalid "
@


1.34
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.33 2009/11/03 10:14:09 claudio Exp $ */
d179 1
a179 1
		if (setsockopt(sp->fd, IPPROTO_IP, SO_RTABLE, &rdomain,
d200 1
a200 1
		if (setsockopt(server_fd, IPPROTO_IP, SO_RTABLE, &rdomain,
@


1.33
log
@Pick up the rdomain from the specified interface and use that rdomain for
relaying the packets to the server. If you need to use cross-domain forwarding
us pf to bounce the packets back and forth.
sure deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.32 2009/09/03 11:56:49 reyk Exp $ */
d179 1
a179 1
		if (setsockopt(sp->fd, IPPROTO_IP, SO_RDOMAIN, &rdomain,
d200 1
a200 1
		if (setsockopt(server_fd, IPPROTO_IP, SO_RDOMAIN, &rdomain,
d504 1
a504 1
	if (ioctl(s, SIOCGIFRTABLEID, (caddr_t)&ifr) != -1)
@


1.32
log
@Add support for "DHCP-over-IPsec" by implementing RFC 3046 (DHCP Relay
Agent Information Option) and RFC 3456 (DHCP Configuration of IPsec
Tunnel Mode).  This allows to configure various IPsec clients
dynamically via DHCP; dhcrelay needs to listen on enc0 and forward
requests to a DHCP server that supports RFC 3046, like I recently did
for dhcpd(8).

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.30 2008/07/09 19:41:56 sobrado Exp $ */
d43 1
d50 1
d75 1
a75 1
	int			 ch, no_daemon = 0, opt;
d156 2
d179 3
d190 1
a190 1
	/* Socket used to forward packets to the DHCP server */
d200 3
d491 18
@


1.31
log
@missing new-line character.
@
text
@d50 3
d61 2
d83 1
a83 1
	while ((ch = getopt(argc, argv, "di:")) != -1) {
d97 5
d138 2
a139 1
	log_perror = 0;
d154 4
d183 15
d255 7
d288 7
d312 1
a312 1
	fprintf(stderr, "usage: %s [-d] -i interface server1 [... serverN]\n",
d358 1
d387 94
@


1.30
log
@documentation tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.29 2007/02/09 16:49:47 stevesk Exp $ */
d268 1
a268 1
	fprintf(stderr, "usage: %s [-d] -i interface server1 [... serverN]",
@


1.29
log
@return on ECONNREFUSED so we don't fall through to 'result <
BOOTP_MIN_LEN' and display discarding message.

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.28 2006/12/18 01:08:58 stevesk Exp $ */
d268 2
a269 2
	fprintf(stderr, "Usage: %s [-d] ", __progname);
	fprintf(stderr, "-i interface server1 [... serverN]\n");
@


1.28
log
@warn() -> warning() to not overload with libc function; this has
previously been done to dhclient and dhcpd
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.27 2006/11/21 14:57:00 stevesk Exp $ */
d324 3
@


1.27
log
@no "\n" needed here; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.26 2005/11/13 20:26:00 deraadt Exp $ */
d113 1
a113 1
				warn("%s: host unknown", argv[0]);
d320 1
a320 1
		warn("recv failed for %s: %m",
@


1.26
log
@pretty up print_hw_addr(), and even fix a teeny buffer overflow; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.25 2005/05/23 22:54:34 henning Exp $ */
d241 1
a241 1
		note("ignoring BOOTREQUEST with giaddr of %s\n",
@


1.25
log
@-endpwent
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.24 2005/05/02 02:29:27 djm Exp $ */
d277 2
a278 2
	char		*s;
	int		 i;
d280 14
a293 16
	if (htype == 0 || hlen == 0)
		goto bad;
	else {
		int	slen = sizeof(habuf);
		s = habuf;
		for (i = 0; i < hlen; i++) {
			int	j;
			j = snprintf(s, slen, "%02x", data[i]);
			if (j <= 0)
				goto bad;

			s += strlen (s);
			slen -= (strlen(s) + 1);
			*s++ = ':';
		}
		*--s = 0;
d295 1
a296 4
bad:
	strlcpy(habuf, "<null>", sizeof habuf);
	return habuf;

@


1.24
log
@more setres[ug]id; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.23 2005/01/25 16:55:04 norby Exp $ */
a184 1
	endpwent();
@


1.23
log
@Fixed a typo.

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.22 2004/10/12 16:39:35 claudio Exp $ */
d182 2
a183 2
	    setegid(pw->pw_gid) || setgid(pw->pw_gid) ||
	    seteuid(pw->pw_uid) || setuid(pw->pw_uid))
@


1.22
log
@Use a udp socket to communicate with the dhcp servers. The bpf interface
can't be used to forward the packets. Bpf would relay the packets to wrong
interface. Reports and tests by Hans Kremers and Colin Harford
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.21 2004/08/15 23:24:14 jaredy Exp $ */
d235 1
a235 1
		note("ignoring non BOOTREPLY form server");
@


1.21
log
@-p and -q are no more

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.20 2004/05/12 10:41:08 henning Exp $ */
d48 1
d62 1
d68 1
a68 1
	int			 ch, no_daemon = 0;
d72 1
d141 7
d153 13
a170 1
	discover_interfaces(interfaces);
d234 5
d255 1
a255 2
		if (send_packet(interfaces, packet, length,
		    ip->primary_address, &sp->to, NULL) != -1) {
d303 42
@


1.20
log
@tzset
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.19 2004/05/04 21:23:10 deraadt Exp $ */
d243 1
a243 1
	fprintf(stderr, "Usage: %s [-q] [-d] [-p <port>] ", __progname);
@


1.19
log
@remove unused stuff; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.18 2004/04/21 01:46:35 henning Exp $ */
d144 2
@


1.18
log
@fix _dhcp use nonexistant error message here too
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.17 2004/04/20 20:56:47 canacar Exp $ */
a49 2
time_t default_lease_time = 43200; /* 12 hours... */
time_t max_lease_time = 86400; /* 24 hours... */
@


1.17
log
@get rid of the -p switch, use fixed values for server and client ports,
rename port variables for clarity.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.16 2004/04/20 04:19:00 deraadt Exp $ */
d154 1
a154 1
		error("getpwnam: %m");
@


1.16
log
@more shrinking; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.15 2004/04/20 03:52:36 deraadt Exp $ */
d55 2
a56 2
u_int16_t local_port;
u_int16_t remote_port;
a69 1
	struct servent		*ent;
d77 1
a77 1
	while ((ch = getopt(argc, argv, "di:p:")) != -1) {
a90 3
		case 'p':
			local_port = htons(atoi(optarg));
			break;
d132 3
a134 10
	/* Default to the DHCP/BOOTP port. */
	if (!local_port) {
		ent = getservbyname("dhcps", "udp");
		if (!ent)
			local_port = htons(67);
		else
			local_port = ent->s_port;
		endservent();
	}
	remote_port = htons(ntohs(local_port) + 1);
d142 1
a142 1
		sp->to.sin_port = local_port;
d189 1
a189 1
			to.sin_port = remote_port;
d192 1
a192 1
			to.sin_port = remote_port;
@


1.15
log
@tree.h is not used at all
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.14 2004/04/15 00:36:37 henning Exp $ */
d215 1
a215 1
		if (send_packet(interfaces, NULL, packet, length,
d239 1
a239 1
		if (send_packet(interfaces, NULL, packet, length,
@


1.14
log
@use the shiny new _PATH_VAREMPTY
@
text
@d1 1
a1 1
/*	$OpenBSD: dhcrelay.c,v 1.13 2004/04/13 23:16:17 henning Exp $ */
a51 1
struct tree_cache *global_options [256];
@


1.13
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d167 1
a167 1
	if (chroot("/var/empty") == -1)
@


1.12
log
@remove the quiet option, we're being quiet by default
@
text
@d1 2
@


1.11
log
@chroot to /var/empty and drop privileges, theo ok
@
text
@d67 1
a67 1
	int			 ch, quiet = 0, no_daemon = 0;
d77 1
a77 1
	while ((ch = getopt(argc, argv, "di:p:q")) != -1) {
a93 3
		case 'q':
			quiet = 1;
			break;
d130 1
a130 2
	if (!quiet)
		log_perror = 0;
@


1.10
log
@relaying back bootp answers should work again
@
text
@d71 1
d166 12
@


1.9
log
@remove those overly helpfull comments like explaining that time(3) gets the
current time
@
text
@a177 1
	struct interface_info	*out;
d205 2
a206 17
/* XXX broken */
		/* Find the interface that corresponds to the giaddr
		   in the packet. */
		for (out = interfaces; out; out = out->next) {
			if (!memcmp (&out->primary_address,
				     &packet->giaddr,
				     sizeof packet->giaddr))
				break;
		}
		if (!out) {
			warn("packet to bogus giaddr %s.",
			    inet_ntoa(packet->giaddr));
			return;
		}

		if (send_packet(out, NULL, packet, length, out->primary_address,
		    &to, &hto) != -1)
d209 1
a209 2
			    packet->chaddr), inet_ntoa (to.sin_addr));
/* XXX */
@


1.8
log
@KNF
@
text
@a159 1
	/* Get the current time... */
a160 2

	/* Discover all the network interfaces. */
a161 2

	/* Set up the bootp packet handler... */
a162 2

	/* Become a daemon... */
a165 1
	/* Start dispatching packets and timeouts... */
@


1.7
log
@one big sweep of KNF, ansi and such
@
text
@d74 1
a74 1
	setlogmask (LOG_UPTO (LOG_INFO));
d117 1
a117 1
				warn ("%s: host unknown", argv[0]);
d119 1
a119 2
				iap =
				   ((struct in_addr *)he->h_addr_list[0]);
d126 1
a126 1
			memcpy (&sp->to.sin_addr, iap, sizeof *iap);
d177 1
a177 1
	exit (0);
d224 2
a225 2
			warn ("packet to bogus giaddr %s.",
			      inet_ntoa (packet->giaddr));
d229 3
a231 5
		if (send_packet (out,
				  (struct packet *)0,
				  packet, length, out->primary_address,
				  &to, &hto) != -1)
			debug ("forwarded BOOTREPLY for %s to %s",
d271 1
a271 1
	exit (1);
d294 1
a294 1
 			*s++ = ':';
d300 1
a300 1
	strlcpy (habuf, "<null>", sizeof habuf);
@


1.6
log
@se daemon(3)
@
text
@a0 4
/* dhcrelay.c

   DHCP/BOOTP Relay Agent. */

d2 1
d64 2
a65 3
int main (argc, argv)
	int argc;
	char **argv;
d125 1
a125 1
			sp -> next = servers;
d141 1
a141 1
		ent = getservbyname ("dhcps", "udp");
d143 1
a143 1
			local_port = htons (67);
d145 2
a146 2
			local_port = ent -> s_port;
		endservent ();
d148 1
a148 1
	remote_port = htons (ntohs (local_port) + 1);
d151 1
a151 1
	if (!sp) {
a152 1
	}
d155 4
a158 4
	for (sp = servers; sp; sp = sp -> next) {
		sp -> to.sin_port = local_port;
		sp -> to.sin_family = AF_INET;
		sp -> to.sin_len = sizeof sp -> to;
d175 2
a176 1
	dispatch ();
d178 1
a178 2
	/*NOTREACHED*/
	return 0;
d181 3
a183 7
void relay (ip, packet, length, from_port, from, hfrom)
	struct interface_info *ip;
	struct dhcp_packet *packet;
	int length;
	unsigned int from_port;
	struct iaddr from;
	struct hardware *hfrom;
d185 4
a188 4
	struct server_list *sp;
	struct sockaddr_in to;
	struct interface_info *out;
	struct hardware hto;
d190 2
a191 2
	if (packet -> hlen > sizeof packet -> chaddr) {
		note ("Discarding packet with invalid hlen.");
d196 4
a199 4
	if (packet -> op == BOOTREPLY) {
		memset(&to, 0, sizeof(to));
		if (!(packet -> flags & htons (BOOTP_BROADCAST))) {
			to.sin_addr = packet -> yiaddr;
d202 1
a202 1
			to.sin_addr.s_addr = htonl (INADDR_BROADCAST);
d209 1
a209 1
		hto.hlen = packet -> hlen;
d212 2
a213 2
		memcpy (hto.haddr, packet -> chaddr, hto.hlen);
		hto.htype = packet -> htype;
d215 1
d218 4
a221 4
		for (out = interfaces; out; out = out -> next) {
			if (!memcmp (&out -> primary_address,
				     &packet -> giaddr,
				     sizeof packet -> giaddr))
d226 1
a226 1
			      inet_ntoa (packet -> giaddr));
d232 1
a232 1
				  packet, length, out -> primary_address,
d235 3
a237 4
			       print_hw_addr (packet -> htype, packet -> hlen,
					      packet -> chaddr),
			       inet_ntoa (to.sin_addr));

d243 3
a245 3
	if (packet -> giaddr.s_addr) {
		note ("ignoring BOOTREQUEST with giaddr of %s\n",
		      inet_ntoa (packet -> giaddr));
d252 1
a252 1
	packet -> giaddr = ip -> primary_address;
d256 6
a261 9
	for (sp = servers; sp; sp = sp -> next) {
		if (send_packet (interfaces,
				  (struct packet *)0,
				  packet, length, ip -> primary_address,
				  &sp -> to, (struct hardware *)0) != -1) {
			debug ("forwarded BOOTREQUEST for %s to %s",
			       print_hw_addr (packet -> htype, packet -> hlen,
					      packet -> chaddr),
			       inet_ntoa (sp -> to.sin_addr));
d264 1
d277 2
a278 29
void cleanup ()
{
}

int write_lease (lease)
	struct lease *lease;
{
	return 1;
}

int commit_leases ()
{
	return 1;
}

void bootp (packet)
	struct packet *packet;
{
}

void dhcp (packet)
	struct packet *packet;
{
}

char *print_hw_addr (htype, hlen, data)
	int htype;
	int hlen;
	unsigned char *data;
d280 3
a282 3
	static char habuf [49];
	char *s;
	int i;
d284 1
a284 1
	if (htype == 0 || hlen == 0) {
d286 2
a287 2
	} else {
		int slen = sizeof(habuf);
d290 2
a291 2
			int j;
			j = snprintf (s, slen, "%02x", data [i]);
d297 1
a297 1
			*s++ = ':';
d302 1
a302 1
 bad:
@


1.5
log
@spacing
@
text
@d176 2
a177 15
	if (!no_daemon) {
		int pid;

		log_perror = 0;

		if ((pid = fork()) < 0)
			error ("can't fork daemon: %m");
		else if (pid)
			exit (0);

		close (0);
		close (1);
		close (2);
		pid = setsid ();
	}
@


1.4
log
@the rocket science department suggests: getopt
@
text
@d153 1
a153 1
  
a288 1
				 
d348 1
a348 1
 			*s++ = ':';
d353 1
a353 1
 bad:	
@


1.3
log
@kill pidfile gunk
@
text
@d71 4
a74 12
	int i;
	struct servent *ent;
	struct server_list *sp = (struct server_list *)0;
	int no_daemon = 0;
	int quiet = 0;
	char *s;

	s = strrchr (argv [0], '/');
	if (!s)
		s = argv [0];
	else
		s++;
d77 1
a77 2
	openlog (s, LOG_NDELAY, DHCPD_LOG_FACILITY);

d80 3
a82 8
	for (i = 1; i < argc; i++) {
		if (!strcmp (argv [i], "-p")) {
			if (++i == argc)
				usage();
			local_port = htons (atoi (argv [i]));
			debug ("binding to user-specified port %d",
			       ntohs (local_port));
		} else if (!strcmp (argv [i], "-d")) {
d84 3
a86 2
 		} else if (!strcmp (argv [i], "-i")) {
			if (++i == argc || interfaces != NULL) {
a87 1
			}
d91 1
a91 1
			strlcpy(interfaces -> name, argv [i],
d93 5
a97 1
		} else if (!strcmp (argv [i], "-q")) {
d99 36
a134 26
 		} else if (argv [i][0] == '-') {
 		    usage();
 		} else {
			struct hostent *he;
			struct in_addr ia, *iap = (struct in_addr *)0;
			if (inet_aton (argv [i], &ia)) {
				iap = &ia;
			} else {
				he = gethostbyname (argv [i]);
				if (!he) {
					warn ("%s: host unknown", argv [i]);
				} else {
					iap = ((struct in_addr *)
					       he -> h_addr_list [0]);
				}
			}
			if (iap) {
				sp = calloc(1, sizeof *sp);
				if (!sp)
					error ("no memory for server.\n");
				sp -> next = servers;
				servers = sp;
				memcpy (&sp -> to.sin_addr,
					iap, sizeof *iap);
			}
 		}
@


1.2
log
@less pathetic usage()
@
text
@a56 10
/* Needed to prevent linking against conflex.c. */
#if 0
int lexline;
int lexchar;
char *token_line;
char *tlname;
#endif

char *path_dhcrelay_pid = "/var/run/dhcrelay.pid";

a95 4
		} else if (!strcmp (argv [i], "-pf")) {
			if (++i == argc)
				usage();
			path_dhcrelay_pid = argv [i];
a177 2
		FILE *pf;
		int pfdesc;
a185 16
		pfdesc = open (path_dhcrelay_pid,
			       O_CREAT | O_TRUNC | O_WRONLY, 0644);

		if (pfdesc < 0) {
			warn ("Can't create %s: %m", path_dhcrelay_pid);
		} else {
			pf = fdopen (pfdesc, "w");
			if (!pf)
				warn ("Can't fdopen %s: %m",
				      path_dhcrelay_pid);
			else {
				fprintf (pf, "%ld\n", (long)getpid ());
				fclose (pf);
			}	
		}

d297 2
a298 2
	fprintf(stderr, "Usage: %s [-q] [-d] [-p <port>]", __progname);
	fprintf(stderr, "server1 [... serverN]\n");
@


1.1
log
@initial cut at split out dhcrelay, whacked from usr.sbin/dhcp/ and sbin/dhclient
@
text
@d45 1
a45 1
void	 usage(char *);
a76 7
static char copyright [] =
"Copyright 1997, 1998, 1999 The Internet Software Consortium.";
static char arr [] = "All rights reserved.";
static char message [] = "Internet Software Consortium DHCP Relay Agent";
static char contrib [] = "Please contribute if you find this software useful.";
static char url [] = "For info, please visit http://www.isc.org/dhcp-contrib.html";

d102 1
a102 1
				usage (s);
d108 1
a108 1
				usage (s);
d114 1
a114 1
				usage (s);
d124 1
a124 1
 		    usage (s);
d170 1
a170 1
		usage (s);
d324 2
a325 2
void usage (appname)
	char *appname;
d327 1
a327 7
	note (message);
	note (copyright);
	note (arr);
	note ("%s", "");
	note (contrib);
	note (url);
	note ("%s", "");
d329 3
a331 2
	warn ("Usage: %s [-q] [-d] [-i if0] [...-i ifN] [-p <port>]", appname);
	error ("      [-pf pidfilename] [server1 [... serverN]]");
@

