head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.14
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.6
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.8
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7;
locks; strict;
comment	@ * @;


1.15
date	2014.04.14.12.56.21;	author blambert;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.07.11.40.09;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.01.17.20.39;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2013.10.01.14.16.20;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.01.12.41.48;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.17.16.43.59;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2009.12.16.22.17.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.06.05.52.00;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.18.13.23.02;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.18.13.18.20;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.18.02.15.41;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.18.02.09.30;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.28.17.22.32;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.28.15.57.06;	author thib;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.05.09.22.44;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Adapt snmpctl to use AgentX protocol to send traps

ok reyk@@ benno@@
@
text
@/*	$OpenBSD: parser.c,v 1.14 2013/10/07 11:40:09 reyk Exp $	*/

/*
 * Copyright (c) 2008 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/uio.h>

#include <netinet/in.h>
#include <net/if.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <event.h>

#include "snmpd.h"
#include "snmp.h"
#include "parser.h"

enum token_type {
	NOTOKEN,
	ENDTOKEN,
	KEYWORD,
	TRAPOID,
	ELEMENTOBJECT,
	VALTYPE,
	IPADDRVAL,
	INT32VAL,
	UINT32VAL,
	INT64VAL,
	STRINGVAL,
	SNMPOID,
	SNMPHOST,
	SNMPCOMMUNITY,
	SNMPVERSION
};

struct token {
	enum token_type		 type;
	const char		*keyword;
	int			 value;
	const struct token	*next;
};

static const struct token t_main[];
static const struct token t_show[];
static const struct token t_trap[];
static const struct token t_trapoid[];
static const struct token t_element[];
static const struct token t_oid[];
static const struct token t_type[];
static const struct token t_ipaddr[];
static const struct token t_int32[];
static const struct token t_uint32[];
static const struct token t_int64[];
static const struct token t_string[];
static const struct token t_snmp[];
static const struct token t_snmpclient[];
static const struct token t_snmphost[];
static const struct token t_snmpoid[];
static const struct token t_snmpcommunity[];
static const struct token t_snmpversion[];

static const struct token t_main[] = {
	{KEYWORD,	"monitor",	MONITOR,	NULL},
	{KEYWORD,	"show",		NONE,		t_show},
	{KEYWORD,	"snmp",		NONE,		t_snmp},
	{KEYWORD,	"trap",		NONE,		t_trap},
	{KEYWORD,	"walk",		WALK,		t_snmphost},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show[] = {
	{KEYWORD,	"mib",		SHOW_MIB,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_snmp[] = {
	{KEYWORD,	"bulkwalk",	BULKWALK,	t_snmphost},
	{KEYWORD,	"get",		GET,		t_snmphost},
	{KEYWORD,	"walk",		WALK,		t_snmphost},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_snmphost[] = {
	{SNMPHOST,	"",		NONE,		t_snmpclient},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_snmpclient[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"oid",		NONE,		t_snmpoid},
	{KEYWORD,	"community",	NONE,		t_snmpcommunity},
	{KEYWORD,	"version",	NONE,		t_snmpversion},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_snmpoid[] = {
	{SNMPOID,	"",		NONE,		t_snmpclient},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_snmpcommunity[] = {
	{SNMPCOMMUNITY,	"",		NONE,		t_snmpclient},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_snmpversion[] = {
	{SNMPVERSION,	"",		NONE,		t_snmpclient},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_trap[] = {
	{KEYWORD,	"send",		TRAP,		t_trapoid},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_trapoid[] = {
	{TRAPOID,	"",		NONE,		t_element},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_element[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"oid",		NONE,		t_oid},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_oid[] = {
	{ELEMENTOBJECT,	"",		NONE,		t_type},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_type[] = {
	{VALTYPE,	"ip",		SNMP_IPADDR,	t_ipaddr },
	{VALTYPE,	"counter",	SNMP_COUNTER32,	t_int32 },
	{VALTYPE,	"gauge",	SNMP_GAUGE32,	t_int32 },
	{VALTYPE,	"unsigned",	SNMP_GAUGE32,	t_uint32 },
	{VALTYPE,	"ticks",	SNMP_TIMETICKS,	t_int32 },
	{VALTYPE,	"opaque",	SNMP_OPAQUE,	t_int32 },
	{VALTYPE,	"nsap",		SNMP_NSAPADDR,	t_int32 },
	{VALTYPE,	"counter64",	SNMP_COUNTER64,	t_int64 },
	{VALTYPE,	"uint",		SNMP_UINTEGER32, t_uint32 },
	{VALTYPE,	"int",		SNMP_INTEGER32,	t_int32 },
	{VALTYPE,	"bitstring",	SNMP_BITSTRING,	t_string },
	{VALTYPE,	"string",	SNMP_OCTETSTRING, t_string },
	{VALTYPE,	"null",		SNMP_NULL,	t_element },
	{VALTYPE,	"oid",		SNMP_OBJECT,	t_string },
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_ipaddr[] = {
	{IPADDRVAL,	"",		NONE,		t_element},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_int32[] = {
	{INT32VAL,	"",		NONE,		t_element},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_uint32[] = {
	{UINT32VAL,	"",		NONE,		t_element},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_int64[] = {
	{INT64VAL,	"",		NONE,		t_element},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_string[] = {
	{STRINGVAL,	"",		NONE,		t_element},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static struct parse_result	 res;

const struct token		*match_token(char *, const struct token []);
void				 show_valid_args(const struct token []);

struct parse_result *
parse(int argc, char *argv[])
{
	const struct token	*table = t_main;
	const struct token	*match;

	bzero(&res, sizeof(res));
	res.version = -1;
	TAILQ_INIT(&res.oids);
	TAILQ_INIT(&res.varbinds);

	while (argc >= 0) {
		if ((match = match_token(argv[0], table)) == NULL) {
			fprintf(stderr, "valid commands/args:\n");
			show_valid_args(table);
			return (NULL);
		}

		argc--;
		argv++;

		if (match->type == NOTOKEN || match->next == NULL)
			break;

		table = match->next;
	}

	if (argc > 0) {
		fprintf(stderr, "superfluous argument: %s\n", argv[0]);
		return (NULL);
	}

	return (&res);
}

const struct token *
match_token(char *word, const struct token table[])
{
	u_int			 i, match = 0;
	const struct token	*t = NULL;
	const char		*errs = NULL;
	int			 terminal = 0;
	struct parse_val	*val;
	struct parse_varbind	*vb = NULL;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			if (word == NULL || strlen(word) == 0) {
				match++;
				t = &table[i];
			}
			break;
		case KEYWORD:
			if (word != NULL && strncmp(word, table[i].keyword,
			    strlen(word)) == 0) {
				match++;
				t = &table[i];
				if (t->value)
					res.action = t->value;
			}
			break;
		case SNMPHOST:
			if (!match && word != NULL && strlen(word) > 0 &&
			    res.host == NULL) {
				if ((res.host = strdup(word)) == NULL)
					err(1, "strdup");
				match++;
				t = &table[i];
			}
			break;
		case SNMPOID:
			if (!match && word != NULL && strlen(word) > 0) {
				if ((val = calloc(1, sizeof(*val))) == NULL ||
				    (val->val = strdup(word)) == NULL)
					err(1, "strdup");
				TAILQ_INSERT_TAIL(&res.oids, val, val_entry);
				match++;
				t = &table[i];
			}
			break;
		case SNMPCOMMUNITY:
			if (!match && word != NULL && strlen(word) > 0 &&
			    res.community == NULL) {
				if ((res.community = strdup(word)) == NULL)
					err(1, "strdup");
				match++;
				t = &table[i];
			}
			break;
		case SNMPVERSION:
			if (!match && word != NULL && strlen(word) > 0 &&
			    res.version == -1) {
				if (strcmp("1", word) == 0)
					res.version = SNMP_V1;
				else if (strcmp("2c", word) == 0)
					res.version = SNMP_V2;
				else
					break;
				match++;
				t = &table[i];
			}
			break;
		case VALTYPE:
			if (word != NULL && strncmp(word, table[i].keyword,
			    strlen(word)) == 0) {
				match++;
				t = &table[i];
				vb = TAILQ_LAST(&res.varbinds, parse_varbinds);
				if (vb == NULL)
					errx(1, "inconsistent varbind list");
				vb->sm.snmp_type = t->value;
				if (t->value == SNMP_NULL)
					terminal = 1;
			}
			break;
		case TRAPOID:
			if (word == NULL || strlen(word) == 0)
				break;
			if ((res.trapoid = strdup(word)) == NULL)
				err(1, "malloc");
			match++;
			t = &table[i];
			break;
		case ELEMENTOBJECT:
			if (word == NULL || strlen(word) == 0)
				break;
			if ((vb = calloc(1, sizeof(*vb))) == NULL)
				errx(1, "calloc");
			if (strlcpy(vb->sm.snmp_oid, word,
			    sizeof(vb->sm.snmp_oid)) >= sizeof(vb->sm.snmp_oid))
				errx(1, "oid too long");

			TAILQ_INSERT_TAIL(&res.varbinds, vb, vb_entry);
			match++;
			t = &table[i];
			break;
		case IPADDRVAL:
			if (word == NULL || strlen(word) == 0)
				break;
			vb = TAILQ_LAST(&res.varbinds, parse_varbinds);
			if (vb == NULL)
				errx(1, "inconsistent varbind list");
			if (inet_pton(AF_INET, word, &vb->u.in4) == -1) {
				/* XXX the SNMP_IPADDR type is IPv4-only? */
				if (inet_pton(AF_INET6, word, &vb->u.in6) == -1)
					errx(1, "invalid IP address");
				vb->sm.snmp_len = sizeof(vb->u.in6);
			} else {
				vb->sm.snmp_len = sizeof(vb->u.in4);
			}
			terminal = 1;
			break;
		case INT32VAL:
			if (word == NULL || strlen(word) == 0)
				break;
			vb = TAILQ_LAST(&res.varbinds, parse_varbinds);
			if (vb == NULL)
				errx(1, "inconsistent varbind list");
			vb->u.d = strtonum(word, INT_MIN, INT_MAX, &errs);
			vb->sm.snmp_len = sizeof(vb->u.d);
			terminal = 1;
			break;
		case UINT32VAL:
			if (word == NULL || strlen(word) == 0)
				break;
			vb = TAILQ_LAST(&res.varbinds, parse_varbinds);
			if (vb == NULL)
				errx(1, "inconsistent varbind list");
			vb->u.u = strtonum(word, 0, UINT_MAX, &errs);
			vb->sm.snmp_len = sizeof(vb->u.u);
			terminal = 1;
			break;
		case INT64VAL:
			if (word == NULL || strlen(word) == 0)
				break;
			vb = TAILQ_LAST(&res.varbinds, parse_varbinds);
			if (vb == NULL)
				errx(1, "inconsistent varbind list");
			vb->u.l = strtonum(word, INT64_MIN, INT64_MAX, &errs);
			vb->sm.snmp_len = sizeof(vb->u.l);
			terminal = 1;
			break;
		case STRINGVAL:
			if (word == NULL || strlen(word) == 0)
				break;
			vb = TAILQ_LAST(&res.varbinds, parse_varbinds);
			if (vb == NULL)
				errx(1, "inconsistent varbind list");
			vb->u.str = word;
			vb->sm.snmp_len = strlen(word);
			terminal = 1;
			break;
		case ENDTOKEN:
			break;
		}
		if (terminal)
			break;
	}

	if (terminal) {
		t = &table[i];
	} else if (match != 1) {
		if (word == NULL)
			fprintf(stderr, "missing argument:\n");
		else if (match > 1)
			fprintf(stderr, "ambiguous argument: %s\n", word);
		else if (match < 1)
			fprintf(stderr, "unknown argument: %s\n", word);
		return (NULL);
	}

	return (t);
}

void
show_valid_args(const struct token table[])
{
	int	i;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			fprintf(stderr, "  <cr>\n");
			break;
		case KEYWORD:
			fprintf(stderr, "  %s\n", table[i].keyword);
			break;
		case VALTYPE:
			fprintf(stderr, "  %s <value>\n", table[i].keyword);
			break;
		case SNMPHOST:
			fprintf(stderr, "  <hostname>\n");
			break;
		case SNMPOID:
		case TRAPOID:
		case ELEMENTOBJECT:
			fprintf(stderr, "  <oid-string>\n");
			break;
		case IPADDRVAL:
			fprintf(stderr, "  <ip-address>\n");
			break;
		case INT32VAL:
			fprintf(stderr, "  <int32>\n");
			break;
		case UINT32VAL:
			fprintf(stderr, "  <uint32>\n");
			break;
		case INT64VAL:
			fprintf(stderr, "  <int64>\n");
			break;
		case STRINGVAL:
		case SNMPCOMMUNITY:
			fprintf(stderr, "  <string>\n");
			break;
		case SNMPVERSION:
			fprintf(stderr, "  [1|2c]\n");
			break;
		case ENDTOKEN:
			break;
		}
	}
}
@


1.14
log
@Allow to specify the "oid" option multiple times, eg.
snmpctl walk 127.0.0.1 oid system oid ifName
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.13 2013/10/01 17:20:39 reyk Exp $	*/
a201 2
static struct imsgbuf		*ibuf;
static struct snmp_imsg		 sm;
d215 1
d247 1
a247 7
	u_int32_t		 u;
	int32_t			 d;
	int64_t			 l;
	struct iovec		 iov[2];
	int			 iovcnt = 0;
	struct in_addr		 in4;
	struct in6_addr		 in6;
d249 1
a249 2

	bzero(&iov, sizeof(iov));
d314 4
a317 1
				sm.snmp_type = t->value;
d319 1
a319 1
					iovcnt = 1;
d325 1
a325 2
			if (ibuf == NULL &&
			    (ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
a326 17
			res.ibuf = ibuf;
			imsg_init(ibuf, -1);

			/* Create a new trap */
			imsg_compose(ibuf, IMSG_SNMP_TRAP,
			    0, 0, -1, NULL, 0);

			/* First element must be the trap OID. */
			bzero(&sm, sizeof(sm));
			sm.snmp_type = SNMP_NULL;
			if (strlcpy(sm.snmp_oid, word,
			    sizeof(sm.snmp_oid)) >= sizeof(sm.snmp_oid))
				errx(1, "trap oid too long");
			if (imsg_compose(ibuf, IMSG_SNMP_ELEMENT, 0, 0, -1,
			    &sm, sizeof(sm)) == -1)
				errx(1, "imsg");

d333 4
a336 3
			bzero(&sm, sizeof(sm));
			if (strlcpy(sm.snmp_oid, word,
			    sizeof(sm.snmp_oid)) >= sizeof(sm.snmp_oid))
d338 2
d346 4
a349 1
			if (inet_pton(AF_INET, word, &in4) == -1) {
d351 1
a351 1
				if (inet_pton(AF_INET6, word, &in6) == -1)
d353 1
a353 2
				iov[1].iov_len = sizeof(in6);
				iov[1].iov_base = &in6;
d355 1
a355 2
				iov[1].iov_len = sizeof(in4);
				iov[1].iov_base = &in4;
d357 1
a357 1
			iovcnt = 2;
d362 6
a367 4
			d = strtonum(word, INT_MIN, INT_MAX, &errs);
			iov[1].iov_len = sizeof(d);
			iov[1].iov_base = &d;
			iovcnt = 2;
d372 6
a377 4
			u = strtonum(word, 0, UINT_MAX, &errs);
			iov[1].iov_len = sizeof(u);
			iov[1].iov_base = &u;
			iovcnt = 2;
d382 6
a387 4
			l = strtonum(word, INT64_MIN, INT64_MAX, &errs);
			iov[1].iov_len = sizeof(l);
			iov[1].iov_base = &l;
			iovcnt = 2;
d392 6
a397 3
			iov[1].iov_len = strlen(word);
			iov[1].iov_base = word;
			iovcnt = 2;
d402 1
a402 1
		if (iovcnt)
d406 1
a406 9
	if (iovcnt) {
		/* Write trap varbind element */
		sm.snmp_len = iov[1].iov_len;
		iov[0].iov_len = sizeof(sm);
		iov[0].iov_base = &sm;
		if (imsg_composev(ibuf, IMSG_SNMP_ELEMENT, 0, 0, -1,
		    iov, iovcnt) == -1)
			err(1, "imsg");

@


1.13
log
@Initial support for the "bulkwalk" command.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.12 2013/10/01 14:16:20 reyk Exp $	*/
d216 1
d255 1
d279 2
a280 1
				res.host = strdup(word);
d286 5
a290 3
			if (!match && word != NULL && strlen(word) > 0 &&
			    res.oid == NULL) {
				res.oid = strdup(word);
d298 2
a299 1
				res.community = strdup(word);
@


1.12
log
@Add shorter alias "snmpctl walk".

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.11 2013/10/01 12:41:48 reyk Exp $	*/
d103 1
@


1.11
log
@Add initial SNMP client utility to snmpctl(8).
For example, snmpctl snmp walk 127.0.0.1

commit it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.10 2012/09/17 16:43:59 reyk Exp $	*/
d93 1
@


1.10
log
@Update copyright and my email address in snmpd while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.9 2009/12/16 22:17:53 deraadt Exp $	*/
d55 5
a59 1
	STRINGVAL
d81 6
d91 1
d101 34
d213 1
d272 37
d447 4
d468 1
d470 3
@


1.9
log
@knf and unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.8 2009/06/06 05:52:00 pyr Exp $	*/
d4 1
a4 1
 * Copyright (c) 2008 Reyk Floeter <reyk@@vantronix.net>
@


1.8
log
@sync snmpd with the common imsg code, making it lib ready as well.
ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.7 2008/01/18 13:23:02 reyk Exp $	*/
d158 2
a159 2
const struct token      *match_token(char *, const struct token []);
void                     show_valid_args(const struct token []);
@


1.7
log
@fix description
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.6 2008/01/18 13:18:20 reyk Exp $	*/
d243 1
a243 1
			imsg_init(ibuf, -1, NULL);
@


1.6
log
@parse ip addresses for traps
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.5 2008/01/18 02:15:41 reyk Exp $	*/
d369 1
a369 1
			fprintf(stderr, "  <int32>\n");
@


1.5
log
@fix stringval length
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.4 2008/01/18 02:09:30 reyk Exp $	*/
d51 1
d72 1
d112 1
a112 1
	{VALTYPE,	"ip",		SNMP_IPADDR,	t_int32 },
d129 5
d204 2
d272 15
d367 3
@


1.4
log
@add a snmpctl command to send traps to registered receivers using
snmpd's imsg trap interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.3 2007/12/28 17:22:32 reyk Exp $	*/
d290 1
a290 1
			iov[1].iov_len = strlen(word) + 1;
@


1.3
log
@add "show mib" command to dump compiled-in MIB names
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.2 2007/12/28 15:57:06 thib Exp $	*/
d4 1
d25 1
d36 1
d41 1
d47 8
a54 1
	KEYWORD
d66 9
d79 1
d84 1
a84 1
	{KEYWORD,	"mib"	,	SHOW_MIB,	NULL},
d88 65
a152 1
static struct parse_result	res;
d187 1
a187 1
match_token(const char *word, const struct token table[])
d189 1
a189 1
	u_int			 i, match;
d191 6
d198 1
a198 1
	match = 0;
d217 77
d297 2
d301 11
a311 1
	if (match != 1) {
d336 19
@


1.2
log
@use $OpenBSD$ tags.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 6
@


1.1
log
@Start working on snmpd(8) and snmpctl(8), a lightweight SNMP implementation
for OpenBSD.  SNMP is a necessary evil.  This is work in progress, don't
expect too much from it yet.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$Id: parser.c,v 1.1 2007/11/08 18:05:08 reyk Exp $	*/
@

