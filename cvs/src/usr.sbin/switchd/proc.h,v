head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.1.0.2
	OPENBSD_6_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2017.01.09.14.49.22;	author reyk;	state Exp;
branches;
next	1.5;
commitid	eA8b246voAapPTkX;

1.5
date	2016.11.16.15.32.42;	author rzalamena;	state Exp;
branches;
next	1.4;
commitid	v9MsNGEdZm5uTnia;

1.4
date	2016.10.05.16.58.19;	author reyk;	state Exp;
branches;
next	1.3;
commitid	UGOrmt0fCkvkKrPU;

1.3
date	2016.09.18.13.17.40;	author rzalamena;	state Exp;
branches;
next	1.2;
commitid	1qnAHkVhXOBXTS8D;

1.2
date	2016.09.14.13.46.51;	author rzalamena;	state Exp;
branches;
next	1.1;
commitid	JePtimnIRHuPUx14;

1.1
date	2016.07.19.16.54.26;	author reyk;	state Exp;
branches;
next	;
commitid	NvD0Bp0qm4zs28YJ;


desc
@@


1.6
log
@Stop accessing verbose and debug variables from log.c directly.

This replaces log_verbose() and "extern int verbose" with the two functions
log_setverbose() and log_getverbose().

Pointed out by benno@@
OK krw@@ eric@@ gilles@@ (OK gilles@@ for the snmpd bits as well)
@
text
@/*	$OpenBSD: proc.h,v 1.5 2016/11/16 15:32:42 rzalamena Exp $	*/

/*
 * Copyright (c) 2010-2015 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <imsg.h>
#include <event.h>
#include "types.h"

#ifndef _PROC_H
#define _PROC_H

struct control_sock {
	const char	*cs_name;
	struct event	 cs_ev;
	struct event	 cs_evt;
	int		 cs_fd;
	int		 cs_restricted;
	void		*cs_env;

	TAILQ_ENTRY(control_sock) cs_entry;
};
TAILQ_HEAD(control_socks, control_sock);

struct privsep_pipes {
	int				*pp_pipes[PROC_MAX];
};

struct privsep {
	struct privsep_pipes		*ps_pipes[PROC_MAX];
	struct privsep_pipes		*ps_pp;

	struct imsgev			*ps_ievs[PROC_MAX];
	const char			*ps_title[PROC_MAX];
	pid_t				 ps_pid[PROC_MAX];
	struct passwd			*ps_pw;
	int				 ps_noaction;

	struct control_sock		 ps_csock;
	struct control_socks		 ps_rcsocks;

	unsigned int			 ps_instances[PROC_MAX];
	unsigned int			 ps_instance;

	/* Event and signal handlers */
	struct event			 ps_evsigint;
	struct event			 ps_evsigterm;
	struct event			 ps_evsigchld;
	struct event			 ps_evsighup;
	struct event			 ps_evsigpipe;
	struct event			 ps_evsigusr1;

	void				*ps_env;
};

struct privsep_proc {
	const char		*p_title;
	enum privsep_procid	 p_id;
	int			(*p_cb)(int, struct privsep_proc *,
				    struct imsg *);
	void			(*p_init)(struct privsep *,
				    struct privsep_proc *);
	const char		*p_chroot;
	struct privsep		*p_ps;
	void			(*p_shutdown)(void);
	struct passwd		*p_pw;
};

struct privsep_fd {
	enum privsep_procid		 pf_procid;
	unsigned int			 pf_instance;
};

struct imsgev {
	struct imsgbuf		 ibuf;
	void			(*handler)(int, short, void *);
	struct event		 ev;
	struct privsep_proc	*proc;
	void			*data;
	short			 events;
	const char		*name;
};

#ifndef IMSG_DATA_SIZE
#define	IMSG_DATA_SIZE(_imsg)	((_imsg)->hdr.len - IMSG_HEADER_SIZE)
#endif

#ifndef IMSG_SIZE_CHECK
#define	IMSG_SIZE_CHECK(_imsg, _type)				\
	do {							\
		if (IMSG_DATA_SIZE(_imsg) < sizeof(*(_type)))	\
			fatal("received imsg size was wrong.");	\
	} while (0 /* CONSTCOND */)
#endif

#if DEBUG
#define DPRINTF		log_debug
#else
#define DPRINTF(x...)	do {} while(0)
#endif

#define PROC_PARENT_SOCK_FILENO 3
#define PROC_MAX_INSTANCES      32

struct ctl_conn {
	TAILQ_ENTRY(ctl_conn)		 entry;
	uint8_t				 flags;
#define CTL_CONN_NOTIFY			 0x01
	struct imsgev			 iev;
	int				 restricted;
};
TAILQ_HEAD(ctl_connlist, ctl_conn);
extern  struct ctl_connlist ctl_conns;

/* proc.c */
void	 proc_init(struct privsep *, struct privsep_proc *, unsigned int,
	    int, char **, enum privsep_procid);
void	 proc_kill(struct privsep *);
void	 proc_connect(struct privsep *ps);
void	 proc_dispatch(int, short event, void *);
void	 proc_run(struct privsep *, struct privsep_proc *,
	    struct privsep_proc *, unsigned int,
	    void (*)(struct privsep *, struct privsep_proc *, void *), void *);
void	 imsg_event_add(struct imsgev *);
int	 imsg_compose_event(struct imsgev *, uint16_t, uint32_t,
	    pid_t, int, void *, uint16_t);
int	 imsg_composev_event(struct imsgev *, uint16_t, uint32_t,
	    pid_t, int, const struct iovec *, int);
int	 proc_compose_imsg(struct privsep *, enum privsep_procid, int,
	    uint16_t, uint32_t, int, void *, uint16_t);
int	 proc_compose(struct privsep *, enum privsep_procid,
	    uint16_t, void *data, uint16_t);
int	 proc_composev_imsg(struct privsep *, enum privsep_procid, int,
	    uint16_t, uint32_t, int, const struct iovec *, int);
int	 proc_composev(struct privsep *, enum privsep_procid,
	    uint16_t, const struct iovec *, int);
int	 proc_forward_imsg(struct privsep *, struct imsg *,
	    enum privsep_procid, int);
struct imsgbuf *
	 proc_ibuf(struct privsep *, enum privsep_procid, int);
struct imsgev *
	 proc_iev(struct privsep *, enum privsep_procid, int);
enum privsep_procid
	 proc_getid(struct privsep_proc *, unsigned int, const char *);
int	 proc_flush_imsg(struct privsep *, enum privsep_procid, int);

/* control.c */
int	 control_init(struct privsep *, struct control_sock *);
int	 control_listen(struct control_sock *);
void	 control_cleanup(struct control_sock *);
struct ctl_conn
	*control_connbyfd(int);
void	 control(struct privsep *, struct privsep_proc *);

/* log.c */
void	log_init(int, int);
void	log_procinit(const char *);
void	log_setverbose(int);
int	log_getverbose(void);
void	log_warn(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_warnx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_info(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	log_debug(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
void	logit(int, const char *, ...)
	    __attribute__((__format__ (printf, 2, 3)));
void	vlog(int, const char *, va_list)
	    __attribute__((__format__ (printf, 2, 0)));
__dead void fatal(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));
__dead void fatalx(const char *, ...)
	    __attribute__((__format__ (printf, 1, 2)));

void	 socket_set_blockmode(int, enum blockmodes);

#endif /* _PROC_H */
@


1.5
log
@Sync switchd(8) and vmd(8) with the latest proc.c changes. This sync
basically imports the imsg_flush() fix from reyk@@ in httpd(8).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.4 2016/10/05 16:58:19 reyk Exp $	*/
d171 2
a172 1
void	log_verbose(int);
@


1.4
log
@sync proc.c with vmd: add p_pw to specify a non-standard user for a process.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.3 2016/09/18 13:17:40 rzalamena Exp $	*/
d158 1
@


1.3
log
@Kill p_env from proc.c. The p_env variable was not being used seriously and
it was always a copy of ps->ps_env.

You might access the env variable now with: p->p_ps->ps_env.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.2 2016/09/14 13:46:51 rzalamena Exp $	*/
d79 1
a79 1
	unsigned int		 p_instance;
@


1.2
log
@Teach switchd(8) how to fork+exec.

Note: this daemon has the -Wcast-qual compilation flag which trigger a
warning that wasn't enable in httpd(8) or relayd(8). This will be fixed
in a next diff and then synchronized with other daemons.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.1 2016/07/19 16:54:26 reyk Exp $	*/
a77 1
	void			*p_env;
@


1.1
log
@Import switchd(8), a basic WIP OpenFlow implementation for OpenBSD.

switchd consists of two parts:
1. switchd(8) and switchctl(8), an OpenFlow controller or "vswitch".
2. switch(4), an OpenFlow-aware kernel "bridge".

This the 1st part, the driver will be imported later.  The code will
remain disabled for a while, but it helps development to have it in
the tree.  switchd currently supports partial OpenFlow 1.0, but the
goal is to use OpenFlow 1.3.5 instead (switch(4) already does 1.3.5).

For more background information see:
http://www.openbsd.org/papers/bsdcan2016-switchd.pdf
https://youtu.be/Cuo0qT-lqig

With help from yasuoka@@ goda@@
Import discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iked.h,v 1.83 2015/01/16 06:39:58 deraadt Exp $	*/
a55 1
	unsigned int			 ps_ninstances;
d74 1
a74 1
	pid_t			(*p_init)(struct privsep *,
d83 5
d110 9
d130 2
a131 1
void	 proc_init(struct privsep *, struct privsep_proc *, unsigned int);
d133 1
a133 1
void	 proc_listen(struct privsep *, struct privsep_proc *, size_t);
d135 1
a135 1
pid_t	 proc_run(struct privsep *, struct privsep_proc *,
d157 2
d166 1
a166 1
pid_t	 control(struct privsep *, struct privsep_proc *);
@

