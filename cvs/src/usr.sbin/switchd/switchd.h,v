head	1.28;
access;
symbols
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.28
date	2016.12.22.15.31.43;	author rzalamena;	state Exp;
branches;
next	1.27;
commitid	LN8ENq5eYaE4jXoJ;

1.27
date	2016.12.02.14.39.46;	author rzalamena;	state Exp;
branches;
next	1.26;
commitid	AN66AOZvr15Na6D1;

1.26
date	2016.11.22.17.21.56;	author rzalamena;	state Exp;
branches;
next	1.25;
commitid	xzEfzrsva4b1hxML;

1.25
date	2016.11.18.16.49.35;	author reyk;	state Exp;
branches;
next	1.24;
commitid	wenNEobVmwJZjDoJ;

1.24
date	2016.11.18.16.34.04;	author reyk;	state Exp;
branches;
next	1.23;
commitid	2iF9xGHOrAI2qEQz;

1.23
date	2016.11.17.12.40.56;	author reyk;	state Exp;
branches;
next	1.22;
commitid	w9Wbt6hfN4dz1Tsn;

1.22
date	2016.11.17.10.05.44;	author reyk;	state Exp;
branches;
next	1.21;
commitid	Vk3XSkkJHy7YnM1i;

1.21
date	2016.11.17.09.42.11;	author rzalamena;	state Exp;
branches;
next	1.20;
commitid	YrRgVofwJ9ppC37R;

1.20
date	2016.11.15.09.05.14;	author reyk;	state Exp;
branches;
next	1.19;
commitid	UBskBqk2InW86Lec;

1.19
date	2016.11.11.22.07.40;	author reyk;	state Exp;
branches;
next	1.18;
commitid	F2V65sN0Dga2Ank6;

1.18
date	2016.11.11.16.59.33;	author reyk;	state Exp;
branches;
next	1.17;
commitid	cWNSZ3leBSol93Wr;

1.17
date	2016.11.04.22.27.08;	author reyk;	state Exp;
branches;
next	1.16;
commitid	mk4W3srERHxHiEzi;

1.16
date	2016.10.12.19.07.42;	author reyk;	state Exp;
branches;
next	1.15;
commitid	3O0CWeyo2kl0zVpd;

1.15
date	2016.10.07.08.49.53;	author reyk;	state Exp;
branches;
next	1.14;
commitid	xgJDyBGKZ2b1TKC0;

1.14
date	2016.10.07.08.31.08;	author rzalamena;	state Exp;
branches;
next	1.13;
commitid	Bq0WoHL5EK319aK3;

1.13
date	2016.09.30.12.48.27;	author reyk;	state Exp;
branches;
next	1.12;
commitid	xHMNHfWpPneWqH4E;

1.12
date	2016.09.30.12.33.43;	author reyk;	state Exp;
branches;
next	1.11;
commitid	ABUXivQ0uWyMhb9f;

1.11
date	2016.09.30.11.57.57;	author reyk;	state Exp;
branches;
next	1.10;
commitid	Bk6N1Zmhuj3ewIdN;

1.10
date	2016.09.29.20.46.06;	author reyk;	state Exp;
branches;
next	1.9;
commitid	oSQiRHgGOSEC4Jla;

1.9
date	2016.09.29.18.25.54;	author reyk;	state Exp;
branches;
next	1.8;
commitid	NV4vuVCpPottgEyF;

1.8
date	2016.09.14.13.46.51;	author rzalamena;	state Exp;
branches;
next	1.7;
commitid	JePtimnIRHuPUx14;

1.7
date	2016.07.21.08.39.23;	author reyk;	state Exp;
branches;
next	1.6;
commitid	0hqYlr7r5dsUiBK1;

1.6
date	2016.07.21.07.58.44;	author reyk;	state Exp;
branches;
next	1.5;
commitid	hvjhEQsdPbzSKWjJ;

1.5
date	2016.07.20.21.01.06;	author reyk;	state Exp;
branches;
next	1.4;
commitid	Rumwj01zEH37kIh7;

1.4
date	2016.07.20.20.07.02;	author reyk;	state Exp;
branches;
next	1.3;
commitid	rKaJJTIoQxMi4AE2;

1.3
date	2016.07.20.14.15.08;	author reyk;	state Exp;
branches;
next	1.2;
commitid	r8lT9ieuUAvheQ28;

1.2
date	2016.07.20.11.43.31;	author jsg;	state Exp;
branches;
next	1.1;
commitid	1Ek9ZJK98C6XLZ0H;

1.1
date	2016.07.19.16.54.26;	author reyk;	state Exp;
branches;
next	;
commitid	NvD0Bp0qm4zs28YJ;


desc
@@


1.28
log
@Learn remote switch flow tables properties to find out where to install
the default table-miss flow for OpenFlow 1.3.5. This is enough to make
switchd(8) to work with switch(4) and HP 3800 switch out-of-the-box.

ok reyk@@
@
text
@/*	$OpenBSD: switchd.h,v 1.27 2016/12/02 14:39:46 rzalamena Exp $	*/

/*
 * Copyright (c) 2013-2016 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef SWITCHD_H
#define SWITCHD_H

#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/uio.h>

#include <net/ofp.h>

#include <limits.h>
#include <imsg.h>

#include "ofp10.h"
#include "types.h"
#include "proc.h"
#include "ofp_map.h"

struct switchd;

struct timer {
	struct event	 tmr_ev;
	struct switchd	*tmr_sc;
	void		(*tmr_cb)(struct switchd *, void *);
	void		*tmr_cbarg;
};

struct packet {
	union {
		struct ether_header	*pkt_eh;
		uint8_t			*pkt_buf;
	};
	size_t				 pkt_len;
};

struct macaddr {
	uint8_t			 mac_addr[ETHER_ADDR_LEN];
	uint32_t			 mac_port;
	time_t			 mac_age;
	RB_ENTRY(macaddr)	 mac_entry;
};
RB_HEAD(macaddr_head, macaddr);

struct switch_control {
	unsigned int		 sw_id;
	struct sockaddr_storage	 sw_addr;
	struct macaddr_head	 sw_addrcache;
	struct timer		 sw_timer;
	unsigned int		 sw_cachesize;
	RB_ENTRY(switch_control) sw_entry;
};
RB_HEAD(switch_head, switch_control);

struct switch_table {
	TAILQ_ENTRY(switch_table)	 st_entry;

	int				 st_table;
	unsigned int			 st_entries;
	unsigned int			 st_maxentries;

	uint32_t			 st_actions;
	uint32_t			 st_actionsmiss;

	uint32_t			 st_instructions;
	uint32_t			 st_instructionsmiss;

	uint64_t			 st_setfield;
	uint64_t			 st_setfieldmiss;
	uint64_t			 st_match;
	uint64_t			 st_wildcard;

	/* Maximum of 256 tables (64 * 4). */
	uint64_t			 st_nexttable[4];
	uint64_t			 st_nexttablemiss[4];
};
TAILQ_HEAD(switch_table_list, switch_table);

struct multipart_message {
	SLIST_ENTRY(multipart_message)
				 mm_entry;

	uint32_t		 mm_xid;
	uint8_t			 mm_type;
};
SLIST_HEAD(multipart_list, multipart_message);

struct switch_address {
	enum switch_conn_type	 swa_type;
	struct sockaddr_storage	 swa_addr;
};

struct switch_connection {
	unsigned int		 con_id;
	unsigned int		 con_instance;

	int			 con_fd;
	int			 con_inflight;

	struct sockaddr_storage	 con_peer;
	struct sockaddr_storage	 con_local;
	in_port_t		 con_port;
	uint32_t		 con_xidnxt;
	int			 con_version;
	enum ofp_state		 con_state;

	struct event		 con_ev;
	struct ibuf		*con_rbuf;
	struct msgbuf		 con_wbuf;

	struct switch_control	*con_switch;
	struct switchd		*con_sc;
	struct switch_server	*con_srv;

	struct multipart_list	 con_mmlist;
	struct switch_table_list
				 con_stlist;

	TAILQ_ENTRY(switch_connection)
				 con_entry;
};
TAILQ_HEAD(switch_connections, switch_connection);

struct switch_server {
	int			 srv_fd;
	int			 srv_tls;
	struct sockaddr_storage	 srv_addr;
	struct event		 srv_ev;
	struct event		 srv_evt;
	struct switchd		*srv_sc;
};

struct switch_client {
	struct switch_address	 swc_addr;
	struct switch_address	 swc_target;
	struct event		 swc_ev;
	void			*swc_arg;
	TAILQ_ENTRY(switch_client)
				 swc_next;
};
TAILQ_HEAD(switch_clients, switch_client);

struct switchd {
	struct privsep		 sc_ps;
	struct switch_server	 sc_server;
	int			 sc_tap;
	struct switch_head	 sc_switches;
	uint32_t		 sc_swid;
	unsigned int		 sc_cache_max;
	unsigned int		 sc_cache_timeout;
	char			 sc_conffile[PATH_MAX];
	uint8_t			 sc_opts;
	struct switch_clients	 sc_clients;
	struct switch_connections
				 sc_conns;
};

struct ofp_callback {
	uint8_t		 cb_type;
	int		(*cb)(struct switchd *, struct switch_connection *,
			    struct ofp_header *, struct ibuf *);
	int		(*validate)(struct switchd *, struct sockaddr_storage *,
			    struct sockaddr_storage *, struct ofp_header *,
			    struct ibuf *);
};

#define SWITCHD_OPT_VERBOSE		0x01
#define SWITCHD_OPT_NOACTION		0x04

struct oflowmod_ctx {
	uint8_t				 ctx_flags;
#define OFMCTX_IBUF			 0x01
	enum oflowmod_state		 ctx_state;

	struct ibuf			*ctx_ibuf;
	struct ofp_flow_mod		*ctx_fm;
	size_t				 ctx_start;
	size_t				 ctx_ostart;
	size_t				 ctx_oend;
	size_t				 ctx_istart;
	size_t				 ctx_iend;
	size_t				 ctx_oioff;
	struct ofp_instruction		*ctx_oi;
};

/* switchd.c */
int		 switchd_socket(struct sockaddr *, int);
int		 switchd_listen(struct sockaddr *);
int		 switchd_sockaddr(const char *, in_port_t, struct sockaddr_storage *);
int		 switchd_tap(void);
int		 switchd_open_device(struct privsep *, const char *, size_t);
struct switch_connection *
		 switchd_connbyid(struct switchd *, unsigned int, unsigned int);
struct switch_connection *
		 switchd_connbyaddr(struct switchd *, struct sockaddr *);

/* packet.c */
int		 packet_input(struct switchd *, struct switch_control *,
		    uint32_t, uint32_t *, struct ibuf *, size_t,
		    struct packet *);

/* switch.c */
void		 switch_init(struct switchd *);
int		 switch_dispatch_control(int, struct privsep_proc *,
		    struct imsg *);
struct switch_control
		*switch_add(struct switch_connection *);
void		 switch_remove(struct switchd *, struct switch_control *);
struct switch_control
		*switch_get(struct switch_connection *);
struct macaddr	*switch_learn(struct switchd *, struct switch_control *,
		    uint8_t *, uint32_t);
struct macaddr	*switch_cached(struct switch_control *, uint8_t *);
RB_PROTOTYPE(switch_head, switch_control, sw_entry, switch_cmp);
RB_PROTOTYPE(macaddr_head, macaddr, mac_entry, switch_maccmp);

/* timer.c */
void		 timer_set(struct switchd *, struct timer *,
		    void (*)(struct switchd *, void *), void *);
void		 timer_add(struct switchd *, struct timer *, int);
void		 timer_del(struct switchd *, struct timer *);

/* util.c */
void		 socket_set_blockmode(int, enum blockmodes);
int		 accept4_reserve(int, struct sockaddr *, socklen_t *,
		    int, int, volatile int *);
in_port_t	 socket_getport(struct sockaddr_storage *);
int		 socket_setport(struct sockaddr_storage *, in_port_t);
int		 sockaddr_cmp(struct sockaddr *, struct sockaddr *, int);
struct in6_addr *prefixlen2mask6(uint8_t, uint32_t *);
uint32_t	 prefixlen2mask(uint8_t);
const char	*print_host(struct sockaddr_storage *, char *, size_t);
const char	*print_ether(const uint8_t *)
		    __attribute__ ((__bounded__(__minbytes__,1,ETHER_ADDR_LEN)));
const char	*print_map(unsigned int, struct constmap *);
void		 print_verbose(const char *emsg, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		 print_debug(const char *emsg, ...)
		    __attribute__((__format__ (printf, 1, 2)));
void		 print_hex(uint8_t *, off_t, size_t);
void		 getmonotime(struct timeval *);
int		 parsehostport(const char *, struct sockaddr *, socklen_t);

/* ofrelay.c */
void		 ofrelay(struct privsep *, struct privsep_proc *);
void		 ofrelay_run(struct privsep *, struct privsep_proc *, void *);
int		 ofrelay_attach(struct switch_server *, int,
		    struct sockaddr *);
void		 ofrelay_close(struct switch_connection *);
void		 ofrelay_write(struct switch_connection *, struct ibuf *);

/* ofp.c */
void		 ofp(struct privsep *, struct privsep_proc *);
void		 ofp_close(struct switch_connection *);
int		 ofp_open(struct privsep *, struct switch_connection *);
void		 ofp_accept(int, short, void *);
int		 ofp_input(struct switch_connection *, struct ibuf *);
int		 ofp_nextstate(struct switchd *, struct switch_connection *,
		    enum ofp_state);
struct switch_table *
		 switch_tablelookup(struct switch_connection *, int);
struct switch_table *
		 switch_newtable(struct switch_connection *, int);
void		 switch_deltable(struct switch_connection *,
		    struct switch_table *);
void		 switch_freetables(struct switch_connection *);

/* ofp10.c */
int		 ofp10_hello(struct switchd *, struct switch_connection *,
		    struct ofp_header *, struct ibuf *);
int		 ofp10_validate(struct switchd *,
		    struct sockaddr_storage *, struct sockaddr_storage *,
		    struct ofp_header *, struct ibuf *);
int		 ofp10_input(struct switchd *, struct switch_connection *,
		    struct ofp_header *, struct ibuf *);

/* ofp13.c */
int		 ofp13_input(struct switchd *, struct switch_connection *,
		    struct ofp_header *, struct ibuf *);
int		 ofp13_hello(struct switchd *, struct switch_connection *,
		    struct ofp_header *oh, struct ibuf *);
int		 ofp13_validate(struct switchd *,
		    struct sockaddr_storage *, struct sockaddr_storage *,
		    struct ofp_header *, struct ibuf *);
int		 ofp13_desc(struct switchd *, struct switch_connection *);
int		 ofp13_flow_stats(struct switchd *, struct switch_connection *,
		    uint32_t, uint32_t, uint8_t);
int		 ofp13_table_features(struct switchd *,
		    struct switch_connection *, uint8_t);
int		 ofp13_featuresrequest(struct switchd *,
		    struct switch_connection *);
struct ofp_flow_mod *
		 ofp13_flowmod(struct switch_connection *, struct ibuf *,
		    uint8_t, uint8_t, uint16_t, uint16_t, uint16_t);
int		 ofp13_setconfig(struct switchd *, struct switch_connection *,
		    uint16_t, uint16_t);
int		 ofp13_tablemiss_sendctrl(struct switchd *,
		    struct switch_connection *, uint8_t);

/* ofp_common.c */
int		 ofp_validate_header(struct switchd *,
		    struct sockaddr_storage *, struct sockaddr_storage *,
		    struct ofp_header *, uint8_t);
int		 ofp_validate(struct switchd *,
		    struct sockaddr_storage *, struct sockaddr_storage *,
		    struct ofp_header *, struct ibuf *, uint8_t);
int		 ofp_output(struct switch_connection *, struct ofp_header *,
		    struct ibuf *);
struct multipart_message *
		    ofp_multipart_lookup(struct switch_connection *, uint32_t);
int		 ofp_multipart_add(struct switch_connection *, uint32_t,
		    uint8_t);
void		 ofp_multipart_del(struct switch_connection *, uint32_t);
void		 ofp_multipart_free(struct switch_connection *,
		    struct multipart_message *);
void		 ofp_multipart_clear(struct switch_connection *);
int		 action_new(struct ibuf *, uint16_t);
int		 action_group(struct ibuf *, uint32_t);
int		 action_output(struct ibuf *, uint32_t, uint16_t);
int		 action_push(struct ibuf *, uint16_t, uint16_t);
int		 action_pop_vlan(struct ibuf *);
int		 action_pop_mpls(struct ibuf *, uint16_t);
int		 action_copyttlout(struct ibuf *);
int		 action_copyttlin(struct ibuf *);
int		 action_decnwttl(struct ibuf *);
struct ofp_action_set_field *
		 action_setfield(struct ibuf *ibuf);
struct ofp_ox_match *
		 oxm_get(struct ibuf *, uint16_t, int, uint8_t);
int		 oxm_inport(struct ibuf *, uint32_t);
int		 oxm_inphyport(struct ibuf *, uint32_t);
int		 oxm_metadata(struct ibuf *, int, uint64_t, uint64_t);
int		 oxm_etheraddr(struct ibuf *, int, uint8_t *, uint8_t *);
int		 oxm_ethertype(struct ibuf *, uint16_t);
int		 oxm_vlanvid(struct ibuf *, int, uint16_t, uint16_t);
int		 oxm_vlanpcp(struct ibuf *, uint8_t);
int		 oxm_ipdscp(struct ibuf *, uint8_t);
int		 oxm_ipecn(struct ibuf *, uint8_t);
int		 oxm_ipproto(struct ibuf *, uint8_t);
int		 oxm_ipaddr(struct ibuf *, int, int, uint32_t, uint32_t);
int		 oxm_tcpport(struct ibuf *, int, uint16_t);
int		 oxm_udpport(struct ibuf *, int, uint16_t);
int		 oxm_sctpport(struct ibuf *, int, uint16_t);
int		 oxm_icmpv4type(struct ibuf *, uint8_t);
int		 oxm_icmpv4code(struct ibuf *, uint8_t);
int		 oxm_arpop(struct ibuf *, uint16_t);
int		 oxm_arpaddr(struct ibuf *, int, int, uint32_t, uint32_t);
int		 oxm_arphaddr(struct ibuf *, int, uint8_t *, uint8_t *);
int		 oxm_ipv6addr(struct ibuf *, int, struct in6_addr *,
		    struct in6_addr *);
int		 oxm_ipv6flowlabel(struct ibuf *, int, uint32_t, uint32_t);
int		 oxm_icmpv6type(struct ibuf *, uint8_t);
int		 oxm_icmpv6code(struct ibuf *, uint8_t);
int		 oxm_ipv6ndtarget(struct ibuf *, struct in6_addr *);
int		 oxm_ipv6ndlinkaddr(struct ibuf *, int, uint8_t *);
int		 oxm_mplslabel(struct ibuf *, uint32_t);
int		 oxm_mplstc(struct ibuf *, uint8_t);
int		 oxm_mplsbos(struct ibuf *, uint8_t);
int		 oxm_tunnelid(struct ibuf *, int, uint64_t, uint64_t);
int		 oxm_ipv6exthdr(struct ibuf *, int, uint16_t, uint16_t);
struct ofp_instruction *
		 ofp_instruction(struct ibuf *, uint16_t, uint16_t);
struct ibuf *
		 oflowmod_open(struct oflowmod_ctx *,
		    struct switch_connection *, struct ibuf *, uint8_t);
int		 oflowmod_close(struct oflowmod_ctx *);
int		 oflowmod_mopen(struct oflowmod_ctx *);
int		 oflowmod_mclose(struct oflowmod_ctx *);
int		 oflowmod_iopen(struct oflowmod_ctx *);
int		 oflowmod_iclose(struct oflowmod_ctx *);
int		 oflowmod_instruction(struct oflowmod_ctx *, unsigned int);

int		 oflowmod_instructionclose(struct oflowmod_ctx *);
int		 oflowmod_state(struct oflowmod_ctx *,
		    unsigned int, unsigned int);
int		 oflowmod_err(struct oflowmod_ctx *, const char *, int);
int		 ofp_validate_hello(struct switchd *,
		    struct sockaddr_storage *, struct sockaddr_storage *,
		    struct ofp_header *, struct ibuf *);
int		 ofp_recv_hello(struct switchd *, struct switch_connection *,
		    struct ofp_header *, struct ibuf *);
int		 ofp_send_hello(struct switchd *, struct switch_connection *,
		    int);
int		 ofp_send_featuresrequest(struct switchd *,
		    struct switch_connection *);
/* ofcconn.c */
void		 ofcconn(struct privsep *, struct privsep_proc *);
void		 ofcconn_shutdown(void);

/* imsg_util.c */
struct ibuf	*ibuf_new(void *, size_t);
struct ibuf	*ibuf_static(void);
int		 ibuf_cat(struct ibuf *, struct ibuf *);
void		 ibuf_release(struct ibuf *);
size_t		 ibuf_length(struct ibuf *);
int		 ibuf_setsize(struct ibuf *, size_t);
int		 ibuf_setmax(struct ibuf *, size_t);
uint8_t		*ibuf_data(struct ibuf *);
void		*ibuf_getdata(struct ibuf *, size_t);
ssize_t		 ibuf_dataleft(struct ibuf *);
size_t		 ibuf_dataoffset(struct ibuf *);
struct ibuf	*ibuf_get(struct ibuf *, size_t);
struct ibuf	*ibuf_dup(struct ibuf *);
struct ibuf	*ibuf_random(size_t);
int		 ibuf_prepend(struct ibuf *, void *, size_t);
void		*ibuf_advance(struct ibuf *, size_t);
void		 ibuf_zero(struct ibuf *);
void		 ibuf_reset(struct ibuf *);

/* parse.y */
int		 cmdline_symset(char *);
int		 parse_config(const char *, struct switchd *);

#endif /* SWITCHD_H */
@


1.27
log
@Implement the connection state machine for OpenFlow 1.0 and 1.3 to detect
invalid state transitions and invalid protocol version switching after the
hello messages exchange.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.26 2016/11/22 17:21:56 rzalamena Exp $	*/
d71 24
d132 2
d276 7
d325 2
a401 1

@


1.26
log
@Implement support for version negotiation using hello messages. This
also prevents connections from switching the version in the middle of
the operation.

tweak from and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.25 2016/11/18 16:49:35 reyk Exp $	*/
d97 1
d248 2
d277 5
a281 1
		     uint8_t, uint8_t, uint16_t, uint16_t, uint16_t);
d365 2
@


1.25
log
@Define constmap in ofp_map.h to be shared along with ofp_map.c
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.24 2016/11/18 16:34:04 reyk Exp $	*/
d96 1
d351 7
@


1.24
log
@Remove leading _ from include guards as this violates the reserved space.
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.23 2016/11/17 12:40:56 reyk Exp $	*/
d34 1
@


1.23
log
@Add an abstraction layer / API to create flows including all matches
and instructions.  This makes it easier to integrate flow features in
switchd and switchctl later.

Written and committed during a long flight.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.22 2016/11/17 10:05:44 reyk Exp $	*/
d19 2
a20 2
#ifndef _SWITCHD_H
#define _SWITCHD_H
d378 1
a378 1
#endif /* _SWITCHD_H */
@


1.22
log
@Add ofp_validate() for all supported versions. Will be used by switchctl,
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.21 2016/11/17 09:42:11 rzalamena Exp $	*/
d157 16
d335 14
a348 1

@


1.21
log
@Added the missing code to build flow-mod messages and to install
table-miss by default for switch(4).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.20 2016/11/15 09:05:14 reyk Exp $	*/
d262 3
@


1.20
log
@Add a socket_setport() util function, in addition to socket_getport(),
and use it in switchctl to set a default port for "dump".
No functional change for switchd itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.19 2016/11/11 22:07:40 reyk Exp $	*/
d254 3
d314 3
@


1.19
log
@Move ofp_validate_header() into ofp_common.c.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.18 2016/11/11 16:59:33 reyk Exp $	*/
d199 1
@


1.18
log
@Remove "workarounds" for the read and write path that were needed to
handle /dev/switch connections that didn't quite behave like TCP
connections (no support for writev, no partial reads).  With
rzalamena's changes to switch(4), it now works as expected and doesn't
need any special treatment anymore.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.17 2016/11/04 22:27:08 reyk Exp $	*/
a226 3
int		 ofp_validate_header(struct switchd *,
		    struct sockaddr_storage *, struct sockaddr_storage *,
		    struct ofp_header *, uint8_t);
d255 3
@


1.17
log
@Move ofp_output() into ofp_common.c and few function prototypes into
switchd.h.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.16 2016/10/12 19:07:42 reyk Exp $	*/
a97 1
	struct ibuf		*con_ibuf;
@


1.16
log
@Start reworking the "device" support in switchd: Once connected, a
device is just an fd that is connected to a switch, either via TCP or
via /dev/switch.  Change the switchctl from "device add" to "connect"
etc.  This change is an intermediate step towards other changes,
including the configuration grammar, so a few things will be left
undocumented for now.

switchctl(8) examples,
switchctl connect /dev/switch0
switchctl connect /dev/switch0 forward-to 10.1.1.1
switchctl connect 127.0.0.1
switchctl connect 127.0.0.1 forward-to 10.1.1.1
switchctl disconnect /dev/switch0

Discussed with rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.15 2016/10/07 08:49:53 reyk Exp $	*/
a226 2
int		 ofp_output(struct switch_connection *, struct ofp_header *,
		    struct ibuf *);
d245 12
d259 2
@


1.15
log
@Move some shared code into a new file.

Discussed with rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.14 2016/10/07 08:31:08 rzalamena Exp $	*/
d79 5
d121 7
a127 10
struct switch_controller {
	enum switch_conn_type	 swc_type;
	struct sockaddr_storage	 swc_addr;
};

struct switch_device {
	char			 sdv_device[PATH_MAX];
	struct switch_controller sdv_swc;
	TAILQ_ENTRY(switch_device)
				 sdv_next;
d129 1
a129 1
TAILQ_HEAD(switch_devices, switch_device);
d141 1
a141 1
	struct switch_devices	 sc_devs;
@


1.14
log
@Add support for multipart replies and implement a simple ofp 1.3.5 error
message sending function.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.13 2016/09/30 12:48:27 reyk Exp $	*/
a232 7
int		 ofp_multipart_add(struct switch_connection *, uint32_t,
		    uint8_t);
void		 ofp_multipart_del(struct switch_connection *, uint32_t);
void		 ofp_multipart_free(struct switch_connection *,
		    struct multipart_message *);
void		 ofp_multipart_clear(struct switch_connection *);

d245 52
@


1.13
log
@Remove local copy of ofp.h and use net/ofp.h instead
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.12 2016/09/30 12:33:43 reyk Exp $	*/
d70 9
d100 2
d232 7
@


1.12
log
@Disable write events if there is nothing to write.
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.11 2016/09/30 11:57:57 reyk Exp $	*/
d26 2
a30 1
#include "ofp.h"
@


1.11
log
@Implement socket server code that properly handles async I/O, partial
messages, multiple messages per buffer and important things like
connection limits and file descriptor accounting.  It works with TCP
connections as well as switch(4).  The ofrelay.c part replaces
networking that was in ofp.c and will soon handle all socket
connections of switchd.  It is called "ofrelay" because it will be
used as client, server, and forwarder.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.10 2016/09/29 20:46:06 reyk Exp $	*/
d207 1
@


1.10
log
@Add print_hex() for debugging of received packets (from iked)
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.9 2016/09/29 18:25:54 reyk Exp $	*/
d71 2
d74 2
a77 1
	struct switch_control	*con_switch;
d79 2
d82 5
d88 2
a89 1
	uint32_t		 con_xidnxt;
d91 1
a91 1
				 con_next;
d93 1
d100 1
d115 1
d127 2
a128 1
	TAILQ_HEAD(, switch_device)
d150 4
d183 2
d201 7
d211 1
a211 1
void		 ofp_read(int, short, void *);
d218 1
d244 1
@


1.9
log
@Rename ofp_send to ofp_output
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.8 2016/09/14 13:46:51 rzalamena Exp $	*/
d176 1
@


1.8
log
@Teach switchd(8) how to fork+exec.

Note: this daemon has the -Wcast-qual compilation flag which trigger a
warning that wasn't enable in httpd(8) or relayd(8). This will be fixed
in a next diff and then synchronized with other daemons.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.7 2016/07/21 08:39:23 reyk Exp $	*/
d183 1
a183 1
int		 ofp_send(struct switch_connection *, struct ofp_header *,
@


1.7
log
@With uint32_t ports, we cannot sneak the port into an int anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.6 2016/07/21 07:58:44 reyk Exp $	*/
d180 1
a180 1
pid_t		 ofp(struct privsep *, struct privsep_proc *);
d204 1
a204 1
pid_t		 ofcconn(struct privsep *, struct privsep_proc *);
@


1.6
log
@Turn ofp*_debug functions into ofp*_validate functions to follow a
similar approach like iked: first validate the packet, then parse it,
and execute actions.  debug logging is a side effect of validation.
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.5 2016/07/20 21:01:06 reyk Exp $	*/
d137 3
a139 2
uint32_t	 packet_input(struct switchd *, struct switch_control *,
		    uint32_t, struct ibuf *, size_t, struct packet *);
@


1.5
log
@pledge(2) all the switchd processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.4 2016/07/20 20:07:02 reyk Exp $	*/
d121 1
a121 1
	int		(*debug)(struct switchd *, struct sockaddr_storage *,
d185 3
d192 1
a192 1
void		 ofp10_debug(struct switchd *,
@


1.4
log
@Handle ports as uint32_t instead of in_port_t: OpenFlow 1.0 used 16bit
ports, but later versions switched to 32bit ports (for the case that a
virtual switch has more than 65535 switch ports, of course).
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.3 2016/07/20 14:15:08 reyk Exp $	*/
d200 2
a201 2
pid_t		 ofcconn_proc_init(struct privsep *, struct privsep_proc *);
void		 ofcconn_proc_shutdown(void);
@


1.3
log
@Update OpenFlow 1.3 stub based on the 1.0 code.
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.2 2016/07/20 11:43:31 jsg Exp $	*/
d53 1
a53 1
	long			 mac_port;
d137 2
a138 2
long		 packet_input(struct switchd *, struct switch_control *, long,
		    struct ibuf *, size_t, struct packet *);
d150 1
a150 1
		    uint8_t *, long);
@


1.2
log
@Add a -n flag to check the configuration and exit.  Matches what almost
all the other daemons do.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchd.h,v 1.1 2016/07/19 16:54:26 reyk Exp $	*/
a188 3
void		 ofp10_debug_header(struct switchd *,
		    struct sockaddr_storage *, struct sockaddr_storage *,
		    struct ofp_header *);
a195 3
void		 ofp13_debug(struct switchd *,
		    struct sockaddr_storage *, struct sockaddr_storage *,
		    struct ofp_header *, struct ibuf *);
@


1.1
log
@Import switchd(8), a basic WIP OpenFlow implementation for OpenBSD.

switchd consists of two parts:
1. switchd(8) and switchctl(8), an OpenFlow controller or "vswitch".
2. switch(4), an OpenFlow-aware kernel "bridge".

This the 1st part, the driver will be imported later.  The code will
remain disabled for a while, but it helps development to have it in
the tree.  switchd currently supports partial OpenFlow 1.0, but the
goal is to use OpenFlow 1.3.5 instead (switch(4) already does 1.3.5).

For more background information see:
http://www.openbsd.org/papers/bsdcan2016-switchd.pdf
https://youtu.be/Cuo0qT-lqig

With help from yasuoka@@ goda@@
Import discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 1
d125 3
@

