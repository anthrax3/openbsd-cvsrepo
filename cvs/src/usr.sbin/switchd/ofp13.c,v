head	1.43;
access;
symbols
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.43
date	2017.01.17.09.21.50;	author rzalamena;	state Exp;
branches;
next	1.42;
commitid	kIn621ot1Bfvxnj8;

1.42
date	2016.12.22.15.31.43;	author rzalamena;	state Exp;
branches;
next	1.41;
commitid	LN8ENq5eYaE4jXoJ;

1.41
date	2016.12.02.14.39.46;	author rzalamena;	state Exp;
branches;
next	1.40;
commitid	AN66AOZvr15Na6D1;

1.40
date	2016.11.22.17.21.56;	author rzalamena;	state Exp;
branches;
next	1.39;
commitid	xzEfzrsva4b1hxML;

1.39
date	2016.11.21.19.33.12;	author rzalamena;	state Exp;
branches;
next	1.38;
commitid	QsChfEW5rMnHaLRi;

1.38
date	2016.11.21.19.18.39;	author rzalamena;	state Exp;
branches;
next	1.37;
commitid	Zz12N13TGb3oWZZd;

1.37
date	2016.11.21.18.19.51;	author rzalamena;	state Exp;
branches;
next	1.36;
commitid	hYDrm1UyySJ5OVmv;

1.36
date	2016.11.21.17.58.24;	author rzalamena;	state Exp;
branches;
next	1.35;
commitid	XpyLKNmkddjtZ4Dy;

1.35
date	2016.11.21.12.13.16;	author rzalamena;	state Exp;
branches;
next	1.34;
commitid	t72LABM8QTUZs478;

1.34
date	2016.11.18.20.20.19;	author reyk;	state Exp;
branches;
next	1.33;
commitid	npvylFamnPEfUHT4;

1.33
date	2016.11.18.19.07.44;	author rzalamena;	state Exp;
branches;
next	1.32;
commitid	3LLtjwF5KIhdyFXA;

1.32
date	2016.11.18.16.56.09;	author reyk;	state Exp;
branches;
next	1.31;
commitid	MKmtlnU172JJbpoi;

1.31
date	2016.11.18.13.15.42;	author rzalamena;	state Exp;
branches;
next	1.30;
commitid	qqlrKfMsXE8JqSVI;

1.30
date	2016.11.18.13.05.12;	author reyk;	state Exp;
branches;
next	1.29;
commitid	1zGJaRX54nHsFnZ0;

1.29
date	2016.11.17.16.24.00;	author rzalamena;	state Exp;
branches;
next	1.28;
commitid	H4LgvqdFtRDB6P0B;

1.28
date	2016.11.17.12.40.56;	author reyk;	state Exp;
branches;
next	1.27;
commitid	w9Wbt6hfN4dz1Tsn;

1.27
date	2016.11.17.10.15.05;	author reyk;	state Exp;
branches;
next	1.26;
commitid	ElfOW20VODk259Ut;

1.26
date	2016.11.17.09.42.11;	author rzalamena;	state Exp;
branches;
next	1.25;
commitid	YrRgVofwJ9ppC37R;

1.25
date	2016.11.07.13.27.11;	author rzalamena;	state Exp;
branches;
next	1.24;
commitid	8b86iwNM9YBSGRzP;

1.24
date	2016.11.07.13.18.18;	author rzalamena;	state Exp;
branches;
next	1.23;
commitid	KN1FDuy6gE0j7RK7;

1.23
date	2016.11.04.22.33.04;	author reyk;	state Exp;
branches;
next	1.22;
commitid	fPNVRaEBeWVAhaDJ;

1.22
date	2016.11.04.22.27.08;	author reyk;	state Exp;
branches;
next	1.21;
commitid	mk4W3srERHxHiEzi;

1.21
date	2016.10.13.08.29.14;	author rzalamena;	state Exp;
branches;
next	1.20;
commitid	oNfmsFqtWQxmdV4m;

1.20
date	2016.10.12.15.18.56;	author rzalamena;	state Exp;
branches;
next	1.19;
commitid	ydYc4I8RxJ0TfmVh;

1.19
date	2016.10.07.08.49.53;	author reyk;	state Exp;
branches;
next	1.18;
commitid	xgJDyBGKZ2b1TKC0;

1.18
date	2016.10.07.08.31.08;	author rzalamena;	state Exp;
branches;
next	1.17;
commitid	Bq0WoHL5EK319aK3;

1.17
date	2016.09.30.12.48.27;	author reyk;	state Exp;
branches;
next	1.16;
commitid	xHMNHfWpPneWqH4E;

1.16
date	2016.09.30.11.57.57;	author reyk;	state Exp;
branches;
next	1.15;
commitid	Bk6N1Zmhuj3ewIdN;

1.15
date	2016.09.29.18.25.54;	author reyk;	state Exp;
branches;
next	1.14;
commitid	NV4vuVCpPottgEyF;

1.14
date	2016.09.29.18.16.50;	author rzalamena;	state Exp;
branches;
next	1.13;
commitid	B7m6oOTOaMNVoWL1;

1.13
date	2016.09.29.15.10.23;	author rzalamena;	state Exp;
branches;
next	1.12;
commitid	OA44yNUEqEipW934;

1.12
date	2016.09.29.13.30.48;	author rzalamena;	state Exp;
branches;
next	1.11;
commitid	BWlVdm6FDzySavJI;

1.11
date	2016.09.29.13.04.50;	author rzalamena;	state Exp;
branches;
next	1.10;
commitid	5RpcivaXVFnD0plZ;

1.10
date	2016.09.28.17.48.35;	author rzalamena;	state Exp;
branches;
next	1.9;
commitid	KS6m9toWIECClbg8;

1.9
date	2016.09.27.22.27.38;	author reyk;	state Exp;
branches;
next	1.8;
commitid	aS0O4iLbcjM4W2Z6;

1.8
date	2016.09.27.19.40.43;	author reyk;	state Exp;
branches;
next	1.7;
commitid	FQ6PSxNkWkLhFFxX;

1.7
date	2016.09.26.12.33.04;	author rzalamena;	state Exp;
branches;
next	1.6;
commitid	bWM8ywBh3O41lgoK;

1.6
date	2016.09.26.08.46.00;	author rzalamena;	state Exp;
branches;
next	1.5;
commitid	ksycG9vNPV6QnVEf;

1.5
date	2016.07.21.14.25.36;	author reyk;	state Exp;
branches;
next	1.4;
commitid	XDHdbrohdNgE95Sq;

1.4
date	2016.07.21.07.58.44;	author reyk;	state Exp;
branches;
next	1.3;
commitid	hvjhEQsdPbzSKWjJ;

1.3
date	2016.07.20.19.57.54;	author reyk;	state Exp;
branches;
next	1.2;
commitid	ceRYj8YLTFlwTGBr;

1.2
date	2016.07.20.14.15.08;	author reyk;	state Exp;
branches;
next	1.1;
commitid	r8lT9ieuUAvheQ28;

1.1
date	2016.07.19.16.54.26;	author reyk;	state Exp;
branches;
next	;
commitid	NvD0Bp0qm4zs28YJ;


desc
@@


1.43
log
@Fix OXM parser for set-field messages. Found it the hardway while
testing set-field configuration.
@
text
@/*	$OpenBSD: ofp13.c,v 1.42 2016/12/22 15:31:43 rzalamena Exp $	*/

/*
 * Copyright (c) 2013-2016 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2016 Rafael Zalamena <rzalamena@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_arp.h>
#include <net/ofp.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <netmpls/mpls.h>

#include <endian.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <imsg.h>
#include <event.h>

#include "switchd.h"
#include "ofp_map.h"

int	 ofp13_echo_request(struct switchd *, struct switch_connection *,
	    struct ofp_header *, struct ibuf *);
int	 ofp13_validate_features_reply(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
	    struct ofp_header *, struct ibuf *);
int	 ofp13_features_reply(struct switchd *, struct switch_connection *,
	    struct ofp_header *, struct ibuf *);
int	 ofp13_validate_error(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
	    struct ofp_header *, struct ibuf *);
int	 ofp13_validate_action(struct switchd *, struct ofp_header *,
	    struct ibuf *, off_t *, struct ofp_action_header *);
int	 ofp13_validate_instruction(struct switchd *, struct ofp_header *,
	    struct ibuf *, off_t *, struct ofp_instruction *);
int	 ofp13_validate_flow_mod(struct switchd *, struct sockaddr_storage *,
	    struct sockaddr_storage *, struct ofp_header *, struct ibuf *);
int	 ofp13_validate_oxm_basic(struct ibuf *, off_t, int, uint8_t);
int	 ofp13_validate_oxm(struct switchd *, struct ofp_ox_match *,
	    struct ofp_header *, struct ibuf *, off_t);
int	 ofp13_validate_packet_in(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
	    struct ofp_header *, struct ibuf *);
int	 ofp13_packet_match(struct ibuf *, struct packet *, struct ofp_match *);
int	 ofp13_packet_in(struct switchd *, struct switch_connection *,
	    struct ofp_header *, struct ibuf *);
int	 ofp13_flow_removed(struct switchd *, struct switch_connection *,
	    struct ofp_header *, struct ibuf *);
int	 ofp13_tableproperties(struct switch_connection *, struct ibuf *,
	    off_t, size_t, int);
int	 ofp13_multipart_reply(struct switchd *, struct switch_connection *,
	    struct ofp_header *, struct ibuf *);
int	 ofp13_validate_tableproperty(struct ibuf *, off_t, int);
int	 ofp13_multipart_reply_validate(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
	    struct ofp_header *, struct ibuf *);
int	 ofp13_validate_packet_out(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
	    struct ofp_header *, struct ibuf *);

struct ofp_multipart *
	    ofp13_multipart_request(struct switch_connection *, struct ibuf *,
	    uint16_t, uint16_t);
int	 ofp13_multipart_request_validate(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
	    struct ofp_header *, struct ibuf *);

int	 ofp13_error(struct switchd *, struct switch_connection *,
	    struct ofp_header *, struct ibuf *, uint16_t, uint16_t);

struct ofp_group_mod *
	    ofp13_group(struct switch_connection *, struct ibuf *,
	    uint32_t, uint16_t, uint8_t);
struct ofp_bucket *
	    ofp13_bucket(struct ibuf *, uint16_t, uint32_t, uint32_t);

int	 ofp13_setconfig_validate(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
	    struct ofp_header *, struct ibuf *);

int	 ofp13_switchconfigure(struct switchd *, struct switch_connection *);
int	 ofp13_getflowtable(struct switch_connection *);

struct ofp_callback ofp13_callbacks[] = {
	{ OFP_T_HELLO,			ofp13_hello, ofp_validate_hello },
	{ OFP_T_ERROR,			NULL, ofp13_validate_error },
	{ OFP_T_ECHO_REQUEST,		ofp13_echo_request, NULL },
	{ OFP_T_ECHO_REPLY,		NULL, NULL },
	{ OFP_T_EXPERIMENTER,		NULL, NULL },
	{ OFP_T_FEATURES_REQUEST,	NULL, NULL },
	{ OFP_T_FEATURES_REPLY,		ofp13_features_reply,
					ofp13_validate_features_reply },
	{ OFP_T_GET_CONFIG_REQUEST,	NULL, NULL },
	{ OFP_T_GET_CONFIG_REPLY,	NULL, NULL },
	{ OFP_T_SET_CONFIG,		NULL, ofp13_setconfig_validate },
	{ OFP_T_PACKET_IN,		ofp13_packet_in,
					ofp13_validate_packet_in },
	{ OFP_T_FLOW_REMOVED,		ofp13_flow_removed, NULL },
	{ OFP_T_PORT_STATUS,		NULL, NULL },
	{ OFP_T_PACKET_OUT,		NULL, ofp13_validate_packet_out },
	{ OFP_T_FLOW_MOD,		NULL, ofp13_validate_flow_mod },
	{ OFP_T_GROUP_MOD,		NULL, NULL },
	{ OFP_T_PORT_MOD,		NULL, NULL },
	{ OFP_T_TABLE_MOD,		NULL, NULL },
	{ OFP_T_MULTIPART_REQUEST,	NULL,
					ofp13_multipart_request_validate },
	{ OFP_T_MULTIPART_REPLY,	ofp13_multipart_reply,
					ofp13_multipart_reply_validate },
	{ OFP_T_BARRIER_REQUEST,	NULL, NULL },
	{ OFP_T_BARRIER_REPLY,		NULL, NULL },
	{ OFP_T_QUEUE_GET_CONFIG_REQUEST, NULL, NULL },
	{ OFP_T_QUEUE_GET_CONFIG_REPLY,	NULL, NULL },
	{ OFP_T_ROLE_REQUEST,		NULL, NULL },
	{ OFP_T_ROLE_REPLY,		NULL, NULL },
	{ OFP_T_GET_ASYNC_REQUEST,	NULL, NULL },
	{ OFP_T_GET_ASYNC_REPLY,	NULL, NULL },
	{ OFP_T_SET_ASYNC,		NULL, NULL },
	{ OFP_T_METER_MOD,		NULL, NULL },
};

int
ofp13_validate(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	uint8_t	type;

	if (ofp_validate_header(sc, src, dst, oh, OFP_V_1_3) != 0) {
		log_debug("\tinvalid header");
		return (-1);
	}
	if (ibuf == NULL) {
		/* The response packet buffer is optional */
		return (0);
	}
	type = oh->oh_type;
	if (ofp13_callbacks[type].validate != NULL &&
	    ofp13_callbacks[type].validate(sc, src, dst, oh, ibuf) != 0) {
		log_debug("\tinvalid packet");
		return (-1);
	}
	return (0);
}

int
ofp13_validate_oxm_basic(struct ibuf *ibuf, off_t off, int hasmask,
    uint8_t type)
{
	uint8_t		*ui8;
	uint16_t	*ui16;
	uint32_t	*ui32;
	uint64_t	*ui64;
	int		 i, len;
	char		 hex[8], buf[64], maskbuf[64];

	switch (type) {
	case OFP_XM_T_IN_PORT:
	case OFP_XM_T_IN_PHY_PORT:
	case OFP_XM_T_MPLS_LABEL:
		if (hasmask)
			return (-1);
		if ((ui32 = ibuf_seek(ibuf, off, sizeof(*ui32))) == NULL)
			return (-1);

		log_debug("\t\t%u", ntohl(*ui32));
		break;

	case OFP_XM_T_META:
	case OFP_XM_T_TUNNEL_ID:
		len = sizeof(*ui64);
		if (hasmask)
			len *= 2;

		if ((ui64 = ibuf_seek(ibuf, off, len)) == NULL)
			return (-1);

		if (hasmask)
			log_debug("\t\t%llu mask %#16llx",
			    be64toh(*ui64), be64toh(*(ui64 + 1)));
		else
			log_debug("\t\t%llu", be64toh(*ui64));
		break;

	case OFP_XM_T_ARP_SHA:
	case OFP_XM_T_ARP_THA:
	case OFP_XM_T_IPV6_ND_SLL:
	case OFP_XM_T_IPV6_ND_TLL:
		if (hasmask)
			return (-1);
		if ((ui8 = ibuf_seek(ibuf, off, ETHER_ADDR_LEN)) == NULL)
			return (-1);

		buf[0] = 0;
		for (i = 0; i < ETHER_ADDR_LEN; i++) {
			snprintf(hex, sizeof(hex), "%02x", *(ui8 + i));
			strlcat(buf, hex, sizeof(buf));
		}

		log_debug("\t\t%s", buf);
		break;

	case OFP_XM_T_ETH_DST:
	case OFP_XM_T_ETH_SRC:
		len = ETHER_ADDR_LEN;
		if (hasmask)
			len *= 2;

		if ((ui8 = ibuf_seek(ibuf, off, len)) == NULL)
			return (-1);

		buf[0] = 0;
		for (i = 0; i < ETHER_ADDR_LEN; i++) {
			snprintf(hex, sizeof(hex), "%02x", *(ui8 + i));
			strlcat(buf, hex, sizeof(buf));
		}

		if (hasmask) {
			maskbuf[0] = 0;
			for (i = 0; i < ETHER_ADDR_LEN; i++) {
				snprintf(hex, sizeof(hex), "%02x", *(ui8 +
				    (i + ETHER_ADDR_LEN)));
				strlcat(maskbuf, hex, sizeof(maskbuf));
			}
			log_debug("\t\t%s mask %s", buf, maskbuf);
		} else
			log_debug("\t\t%s", buf);
		break;

	case OFP_XM_T_ETH_TYPE:
		if (hasmask)
			return (-1);
		len = sizeof(*ui16);
		if ((ui16 = ibuf_seek(ibuf, off, len)) == NULL)
			return (-1);
		log_debug("\t\t0x%04x", ntohs(*ui16));
		break;

	case OFP_XM_T_TCP_SRC:
	case OFP_XM_T_TCP_DST:
	case OFP_XM_T_UDP_SRC:
	case OFP_XM_T_UDP_DST:
	case OFP_XM_T_SCTP_SRC:
	case OFP_XM_T_SCTP_DST:
	case OFP_XM_T_ARP_OP:
		if (hasmask)
			return (-1);
		if ((ui16 = ibuf_seek(ibuf, off, sizeof(*ui16))) == NULL)
			return (-1);

		log_debug("\t\t%d", ntohs(*ui16));
		break;

	case OFP_XM_T_VLAN_VID:
	case OFP_XM_T_IPV6_EXTHDR:
		len = sizeof(*ui16);
		if (hasmask)
			len *= 2;

		if ((ui16 = ibuf_seek(ibuf, off, len)) == NULL)
			return (-1);

		if (type == OFP_XM_T_VLAN_VID) {
			/* Remove the VID present bit to display. */
			if (hasmask)
				log_debug("\t\t%d mask %#04x",
				    ntohs(*ui16) & ~OFP_XM_VID_PRESENT,
				    ntohs(*(ui16 + 1)));
			else
				log_debug("\t\t%d",
				    ntohs(*ui16) & ~OFP_XM_VID_PRESENT);
			break;
		}

		if (hasmask)
			log_debug("\t\t%d mask %#04x",
			    ntohs(*ui16), ntohs(*(ui16 + 1)));
		else
			log_debug("\t\t%d", ntohs(*ui16));
		break;

	case OFP_XM_T_IP_DSCP:
	case OFP_XM_T_IP_ECN:
	case OFP_XM_T_IP_PROTO:
	case OFP_XM_T_ICMPV4_TYPE:
	case OFP_XM_T_ICMPV4_CODE:
	case OFP_XM_T_ICMPV6_TYPE:
	case OFP_XM_T_ICMPV6_CODE:
	case OFP_XM_T_MPLS_TC:
	case OFP_XM_T_MPLS_BOS:
		if (hasmask)
			return (-1);
		if ((ui8 = ibuf_seek(ibuf, off, sizeof(*ui8))) == NULL)
			return (-1);

		log_debug("\t\t%#02x", *ui8);
		break;

	case OFP_XM_T_IPV4_SRC:
	case OFP_XM_T_IPV4_DST:
	case OFP_XM_T_ARP_SPA:
	case OFP_XM_T_ARP_TPA:
	case OFP_XM_T_IPV6_FLABEL:
		len = sizeof(*ui32);
		if (hasmask)
			len *= 2;

		if ((ui32 = ibuf_seek(ibuf, off, len)) == NULL)
			return (-1);

		if (hasmask)
			log_debug("\t\t%#08x mask %#08x",
			    ntohl(*ui32), ntohl(*(ui32 + 1)));
		else
			log_debug("\t\t%#08x", ntohl(*ui32));
		break;

	case OFP_XM_T_IPV6_ND_TARGET:
		if (hasmask)
			return (-1);
		if ((ui8 = ibuf_seek(ibuf, off,
		    sizeof(struct in6_addr))) == NULL)
			return (-1);

		buf[0] = 0;
		for (i = 0; i < (int)sizeof(struct in6_addr); i++) {
			snprintf(hex, sizeof(hex), "%02x", *(ui8 + i));
			strlcat(buf, hex, sizeof(buf));
		}

		log_debug("\t\t%s", buf);
		break;

	case OFP_XM_T_IPV6_SRC:
	case OFP_XM_T_IPV6_DST:
		len = sizeof(struct in6_addr);
		if (hasmask)
			len *= 2;

		if ((ui8 = ibuf_seek(ibuf, off, len)) == NULL)
			return (-1);

		buf[0] = 0;
		for (i = 0; i < (int)sizeof(struct in6_addr); i++) {
			snprintf(hex, sizeof(hex), "%02x", *(ui8 + i));
			strlcat(buf, hex, sizeof(buf));
		}

		if (hasmask) {
			maskbuf[0] = 0;
			for (i = 0; i < (int)sizeof(struct in6_addr); i++) {
				snprintf(hex, sizeof(hex), "%02x", *(ui8 +
				    (i + sizeof(struct in6_addr))));
				strlcat(maskbuf, hex, sizeof(maskbuf));
			}
			log_debug("\t\t%s mask %s", buf, maskbuf);
		} else
			log_debug("\t\t%s", buf);
		break;

	case OFP_XM_T_PBB_ISID:
		/* TODO teach me how to read 24 bits and convert to be. */
		break;

	default:
		log_debug("\t\tUnknown type");
		return (-1);
	}

	return (0);
}

int
ofp13_validate_oxm(struct switchd *sc, struct ofp_ox_match *oxm,
    struct ofp_header *oh, struct ibuf *ibuf, off_t off)
{
	uint16_t	 class;
	uint8_t		 type;
	int		 hasmask;

	/* match element is always followed by data */
	if (oxm->oxm_length == 0)
		return (0);

	type = OFP_OXM_GET_FIELD(oxm);
	hasmask = OFP_OXM_GET_HASMASK(oxm);
	class = ntohs(oxm->oxm_class);
	off += sizeof(*oxm);

	log_debug("\tox match class %s type %s hasmask %s length %u",
	    print_map(class, ofp_oxm_c_map),
	    print_map(type, ofp_xm_t_map),
	    hasmask ? "yes" : "no",
	    oxm->oxm_length);

	switch (class) {
	case OFP_OXM_C_NXM_0:
	case OFP_OXM_C_NXM_1:
		/* TODO teach me how to read NXM_*. */
		break;

	case OFP_OXM_C_OPENFLOW_BASIC:
		return (ofp13_validate_oxm_basic(ibuf, off, hasmask, type));

	case OFP_OXM_C_OPENFLOW_EXPERIMENTER:
		/* Implementation dependent: there is nothing to do here. */
		break;

	default:
		return (-1);
	}

	return (0);
}

int
ofp13_validate_packet_in(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	struct ofp_packet_in	*pin;
	struct ofp_match	*om;
	struct ofp_ox_match	*oxm;
	uint8_t			*p;
	ssize_t			 len, mlen, plen;
	off_t			 moff, off;

	off = 0;
	if ((pin = ibuf_seek(ibuf, off, sizeof(*pin))) == NULL)
		return (-1);
	log_debug("\tbuffer %s length %u reason %s table %s cookie 0x%#016llx",
	    print_map(ntohl(pin->pin_buffer_id), ofp_pktout_map),
	    ntohs(pin->pin_total_len),
	    print_map(ntohs(pin->pin_reason), ofp_pktin_map),
	    print_map(pin->pin_table_id, ofp_table_id_map),
	    be64toh(pin->pin_cookie));
	off += offsetof(struct ofp_packet_in, pin_match);

	om = &pin->pin_match;
	mlen = ntohs(om->om_length);
	log_debug("\tmatch type %s length %zu (padded to %zu)",
	    print_map(ntohs(om->om_type), ofp_match_map),
	    mlen, OFP_ALIGN(mlen) + ETHER_ALIGN);
	mlen -= sizeof(*om);

	/* current match offset, aligned offset after all matches */
	moff = off + sizeof(*om);
	off += OFP_ALIGN(mlen) + ETHER_ALIGN;

	switch (htons(om->om_type)) {
	case OFP_MATCH_OXM:
		do {
			if ((oxm = ibuf_seek(ibuf, moff, sizeof(*oxm))) == NULL)
				return (-1);
			if (ofp13_validate_oxm(sc, oxm, oh, ibuf, moff) == -1)
				return (-1);
			moff += sizeof(*oxm) + oxm->oxm_length;
			mlen -= sizeof(*oxm) + oxm->oxm_length;
		} while (mlen > 0 && oxm->oxm_length);
		break;
	case OFP_MATCH_STANDARD:
		/* deprecated */
		break;
	}

	len = ntohs(pin->pin_total_len);
	plen = ibuf_length(ibuf) - off;

	if (plen < len) {
		log_debug("\ttruncated packet %zu < %zu", plen, len);

		/* Buffered packets can be truncated */
		if (pin->pin_buffer_id != OFP_PKTOUT_NO_BUFFER)
			len = plen;
		else
			return (-1);
	}
	if ((p = ibuf_seek(ibuf, off, len)) == NULL)
		return (-1);
	if (sc->sc_tap != -1)
		(void)write(sc->sc_tap, p, len);

	return (0);
}

int
ofp13_validate_packet_out(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	struct ofp_packet_out		*pout;
	size_t				 len, plen, diff;
	off_t				 off, noff;
	struct ofp_action_header	*ah;

	off = 0;
	if ((pout = ibuf_seek(ibuf, off, sizeof(*pout))) == NULL) {
		log_debug("%s: seek failed: length %zd",
		    __func__, ibuf_length(ibuf));
		return (-1);
	}

	off += sizeof(*pout);
	len = ntohs(pout->pout_actions_len);
	log_debug("\tbuffer %s in_port %s actions_len %lu",
	    print_map(ntohl(pout->pout_buffer_id), ofp_pktout_map),
	    print_map(ntohl(pout->pout_in_port), ofp_port_map), len);

	while (len > 0) {
		if ((ah = ibuf_seek(ibuf, off, sizeof(*ah))) == NULL)
			return (-1);

		noff = off;
		ofp13_validate_action(sc, oh, ibuf, &off, ah);

		diff = off - noff;
		/* Loop prevention. */
		if (off < noff || diff == 0)
			return (-1);

		len -= diff;
	}

	/* Check for encapsulated packet truncation. */
	len = ntohs(oh->oh_length) - off;
	plen = ibuf_length(ibuf) - off;

	if (plen < len) {
		log_debug("\ttruncated packet %lu < %lu", plen, len);

		/* Buffered packets can be truncated */
		if (pout->pout_buffer_id != htonl(OFP_PKTOUT_NO_BUFFER))
			len = plen;
		else
			return (-1);
	}
	if (ibuf_seek(ibuf, off, len) == NULL)
		return (-1);

	return (0);
}

int
ofp13_validate_error(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	struct ofp_error		*err;
	off_t				 off;
	const char			*code;

	off = 0;
	if ((err = ibuf_seek(ibuf, off, sizeof(*err))) == NULL) {
		log_debug("%s: seek failed: length %zd",
		    __func__, ibuf_length(ibuf));
		return (-1);
	}

	switch (ntohs(err->err_type)) {
	case OFP_ERRTYPE_FLOW_MOD_FAILED:
		code = print_map(ntohs(err->err_code), ofp_errflowmod_map);
		break;
	case OFP_ERRTYPE_BAD_MATCH:
		code = print_map(ntohs(err->err_code), ofp_errmatch_map);
		break;
	case OFP_ERRTYPE_BAD_INSTRUCTION:
		code = print_map(ntohs(err->err_code), ofp_errinst_map);
		break;
	case OFP_ERRTYPE_BAD_REQUEST:
		code = print_map(ntohs(err->err_code), ofp_errreq_map);
		break;
	default:
		code = NULL;
		break;
	}

	log_debug("\terror type %s code %u%s%s",
	    print_map(ntohs(err->err_type), ofp_errtype_map),
	    ntohs(err->err_code),
	    code == NULL ? "" : ": ",
	    code == NULL ? "" : code);

	return (0);
}

int
ofp13_input(struct switchd *sc, struct switch_connection *con,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	if (ofp13_validate(sc, &con->con_peer, &con->con_local, oh, ibuf) != 0)
		return (-1);

	if (ofp13_callbacks[oh->oh_type].cb == NULL) {
		log_debug("%s: message not supported: %s", __func__,
		    print_map(oh->oh_type, ofp_t_map));
		return (-1);
	}
	if (ofp13_callbacks[oh->oh_type].cb(sc, con, oh, ibuf) != 0) {
		log_debug("%s: message parsing failed: %s", __func__,
		    print_map(oh->oh_type, ofp_t_map));
		return (-1);
	}

	return (0);
}

int
ofp13_hello(struct switchd *sc, struct switch_connection *con,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	if (switch_add(con) == NULL) {
		log_debug("%s: failed to add switch", __func__);
		return (-1);
	}

	if (ofp_recv_hello(sc, con, oh, ibuf) == -1)
		return (-1);

	return (ofp_nextstate(sc, con, OFP_STATE_FEATURE_WAIT));
}

int
ofp13_echo_request(struct switchd *sc, struct switch_connection *con,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	/* Echo reply */
	oh->oh_type = OFP_T_ECHO_REPLY;
	if (ofp13_validate(sc, &con->con_local, &con->con_peer, oh, NULL) != 0)
		return (-1);
	ofp_output(con, oh, NULL);

	return (0);
}

int
ofp13_validate_features_reply(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	struct ofp_switch_features	*swf;

	if ((swf = ibuf_seek(ibuf, 0, sizeof(*swf))) == NULL)
		return (-1);

	log_debug("\tdatapath_id %#016llx nbuffers %u ntables %d aux_id %d "
	    "capabilities %#08x",
	    be64toh(swf->swf_datapath_id), ntohl(swf->swf_nbuffers),
	    swf->swf_ntables, swf->swf_aux_id, ntohl(swf->swf_capabilities));
	return (0);
}

int
ofp13_features_reply(struct switchd *sc, struct switch_connection *con,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	return (ofp_nextstate(sc, con, OFP_STATE_ESTABLISHED));
}

int
ofp13_validate_action(struct switchd *sc, struct ofp_header *oh,
    struct ibuf *ibuf, off_t *off, struct ofp_action_header *ah)
{
	struct ofp_action_output	*ao;
	struct ofp_action_mpls_ttl	*amt;
	struct ofp_action_push		*ap;
	struct ofp_action_pop_mpls	*apm;
	struct ofp_action_group		*ag;
	struct ofp_action_nw_ttl	*ant;
	struct ofp_action_set_field	*asf;
	struct ofp_action_set_queue	*asq;
	struct ofp_ox_match		*oxm;
	size_t				 len;
	int				 type;
	off_t				 moff;

	type = ntohs(ah->ah_type);
	len = ntohs(ah->ah_len);

	switch (type) {
	case OFP_ACTION_OUTPUT:
		if (len != sizeof(*ao))
			return (-1);
		if ((ao = ibuf_seek(ibuf, *off, sizeof(*ao))) == NULL)
			return (-1);

		*off += len;
		log_debug("\t\taction %s len %lu port %s max_len %s",
		    print_map(type, ofp_action_map), len,
		    print_map(ntohl(ao->ao_port), ofp_port_map),
		    print_map(ntohs(ao->ao_max_len),
		    ofp_controller_maxlen_map));
		break;
	case OFP_ACTION_SET_MPLS_TTL:
		if (len != sizeof(*amt))
			return (-1);
		if ((amt = ibuf_seek(ibuf, *off, sizeof(*amt))) == NULL)
			return (-1);

		*off += len;
		log_debug("\t\taction %s len %lu ttl %d",
		    print_map(type, ofp_action_map), len, amt->amt_ttl);
		break;
	case OFP_ACTION_PUSH_VLAN:
	case OFP_ACTION_PUSH_MPLS:
	case OFP_ACTION_PUSH_PBB:
		if (len != sizeof(*ap))
			return (-1);
		if ((ap = ibuf_seek(ibuf, *off, sizeof(*ap))) == NULL)
			return (-1);

		*off += len;
		log_debug("\t\taction %s len %lu ethertype %#04x",
		    print_map(type, ofp_action_map), len,
		    ntohs(ap->ap_ethertype));
		break;
	case OFP_ACTION_POP_MPLS:
		if (len != sizeof(*apm))
			return (-1);
		if ((apm = ibuf_seek(ibuf, *off, sizeof(*apm))) == NULL)
			return (-1);

		*off += len;
		log_debug("\t\taction %s len %lu ethertype %#04x",
		    print_map(type, ofp_action_map), len,
		    ntohs(apm->apm_ethertype));
		break;
	case OFP_ACTION_SET_QUEUE:
		if (len != sizeof(*asq))
			return (-1);
		if ((asq = ibuf_seek(ibuf, *off, sizeof(*asq))) == NULL)
			return (-1);

		*off += len;
		log_debug("\t\taction %s len %lu queue_id %u",
		    print_map(type, ofp_action_map), len,
		    ntohl(asq->asq_queue_id));
		break;
	case OFP_ACTION_GROUP:
		if (len != sizeof(*ag))
			return (-1);
		if ((ag = ibuf_seek(ibuf, *off, sizeof(*ag))) == NULL)
			return (-1);

		*off += len;
		log_debug("\t\taction %s len %lu group_id %s",
		    print_map(type, ofp_action_map), len,
		    print_map(ntohl(ag->ag_group_id), ofp_group_id_map));
		break;
	case OFP_ACTION_SET_NW_TTL:
		if (len != sizeof(*ant))
			return (-1);
		if ((ant = ibuf_seek(ibuf, *off, sizeof(*ant))) == NULL)
			return (-1);

		*off += len;
		log_debug("\t\taction %s len %lu ttl %d",
		    print_map(type, ofp_action_map), len, ant->ant_ttl);
		break;
	case OFP_ACTION_SET_FIELD:
		if (len < sizeof(*asf))
			return (-1);
		if ((asf = ibuf_seek(ibuf, *off, sizeof(*asf))) == NULL)
			return (-1);

		moff = *off + sizeof(*asf) - sizeof(asf->asf_field);
		*off += len;
		log_debug("\t\taction %s len %lu",
		    print_map(type, ofp_action_map), len);

		len -= sizeof(*asf) - sizeof(asf->asf_field);
		while (len > 0) {
			if ((oxm = ibuf_seek(ibuf, moff, sizeof(*oxm)))
			    == NULL)
				return (-1);
			if (ofp13_validate_oxm(sc, oxm, oh, ibuf, moff) == -1)
				return (-1);

			len -= sizeof(*oxm) + oxm->oxm_length;
			moff += sizeof(*oxm) + oxm->oxm_length;
		}
		break;

	default:
		if (len < sizeof(*ah))
			return (-1);

		/* Generic header without information. */
		*off += len;
		log_debug("\t\taction %s len %lu",
		    print_map(type, ofp_action_map), len);
		break;
	}

	return (0);
}

int
ofp13_validate_instruction(struct switchd *sc, struct ofp_header *oh,
    struct ibuf *ibuf, off_t *off, struct ofp_instruction *i)
{
	struct ofp_instruction_actions		*ia;
	struct ofp_instruction_goto_table	*igt;
	struct ofp_instruction_write_metadata	*iwm;
	struct ofp_instruction_meter		*im;
	struct ofp_action_header		*ah;
	int					 type;
	size_t					 len;
	off_t					 oldoff, diff;

	type = ntohs(i->i_type);
	len = ntohs(i->i_len);

	switch (type) {
	case OFP_INSTRUCTION_T_GOTO_TABLE:
		if (len != sizeof(*igt))
			return (-1);
		if ((igt = ibuf_seek(ibuf, *off, sizeof(*igt))) == NULL)
			return (-1);

		*off += len;
		log_debug("\tinstruction %s length %lu table_id %s",
		    print_map(type, ofp_instruction_t_map), len,
		    print_map(igt->igt_table_id, ofp_table_id_map));
		break;
	case OFP_INSTRUCTION_T_WRITE_META:
		if (len != sizeof(*iwm))
			return (-1);
		if ((iwm = ibuf_seek(ibuf, *off, sizeof(*iwm))) == NULL)
			return (-1);

		*off += len;
		log_debug("\tinstruction %s length %lu "
		    "metadata %#016llx mask %#016llx",
		    print_map(type, ofp_instruction_t_map), len,
		    be64toh(iwm->iwm_metadata),
		    be64toh(iwm->iwm_metadata_mask));
		break;
	case OFP_INSTRUCTION_T_METER:
		if (len != sizeof(*im))
			return (-1);
		if ((im = ibuf_seek(ibuf, *off, sizeof(*im))) == NULL)
			return (-1);

		*off += len;
		log_debug("\tinstruction %s length %lu meter_id %d",
		    print_map(type, ofp_instruction_t_map), len,
		    im->im_meter_id);
		break;
	case OFP_INSTRUCTION_T_WRITE_ACTIONS:
	case OFP_INSTRUCTION_T_CLEAR_ACTIONS:
	case OFP_INSTRUCTION_T_APPLY_ACTIONS:
		if (len < sizeof(*ia))
			return (-1);
		if ((ia = ibuf_seek(ibuf, *off, sizeof(*ia))) == NULL)
			return (-1);

		log_debug("\tinstruction %s length %lu",
		    print_map(type, ofp_instruction_t_map), len);

		*off += sizeof(*ia);
		len -= sizeof(*ia);
		while (len) {
			oldoff = *off;
			if ((ah = ibuf_seek(ibuf, *off, sizeof(*ah))) == NULL ||
			    ofp13_validate_action(sc, oh, ibuf, off, ah) == -1)
				return (-1);

			diff = *off - oldoff;
			/* Loop prevention. */
			if (*off < oldoff || diff == 0)
				break;

			len -= diff;
		}
		break;
	default:
		if (len < sizeof(*i))
			return (-1);

		log_debug("\tinstruction %s length %lu",
		    print_map(type, ofp_instruction_t_map), len);
		*off += len;
		break;
	}

	return (0);
}

int
ofp13_validate_flow_mod(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	struct ofp_flow_mod		*fm;
	struct ofp_match		*om;
	struct ofp_instruction		*i;
	struct ofp_ox_match		*oxm;
	off_t				 off, moff, offdiff;
	int				 matchlen, matchtype, left;

	off = 0;
	if ((fm = ibuf_seek(ibuf, off, sizeof(*fm))) == NULL)
		return (-1);

	log_debug("\tcommand %s table %s timeout (idle %d hard %d) "
	    "priority %d buffer_id %s out_port %s out_group %s "
	    "flags %#04x cookie %#016llx mask %#016llx",
	    print_map(fm->fm_command, ofp_flowcmd_map),
	    print_map(fm->fm_table_id, ofp_table_id_map),
	    ntohs(fm->fm_idle_timeout), ntohs(fm->fm_hard_timeout),
	    ntohs(fm->fm_priority),
	    print_map(ntohl(fm->fm_buffer_id), ofp_pktout_map),
	    print_map(ntohl(fm->fm_out_port), ofp_port_map),
	    print_map(ntohl(fm->fm_out_group), ofp_group_id_map),
	    ntohs(fm->fm_flags), be64toh(fm->fm_cookie),
	    be64toh(fm->fm_cookie_mask));

	off += offsetof(struct ofp_flow_mod, fm_match);

	om = &fm->fm_match;
	matchtype = ntohs(om->om_type);
	matchlen = ntohs(om->om_length);

	moff = off + sizeof(*om);
	off += OFP_ALIGN(matchlen);

	matchlen -= sizeof(*om);
	while (matchlen) {
		if ((oxm = ibuf_seek(ibuf, moff, sizeof(*oxm))) == NULL ||
		    ofp13_validate_oxm(sc, oxm, oh, ibuf, moff) == -1)
			return (-1);
		moff += sizeof(*oxm) + oxm->oxm_length;
		matchlen -= sizeof(*oxm) + oxm->oxm_length;
	}

	left = ntohs(oh->oh_length) - off;
	moff = off;
	while (left) {
		if ((i = ibuf_seek(ibuf, moff, sizeof(*i))) == NULL ||
		    ofp13_validate_instruction(sc, oh, ibuf, &moff, i) == -1)
			return (-1);

		offdiff = moff - off;
		/* Loop prevention. */
		if (moff < off || offdiff == 0)
			break;

		left -= offdiff;
		off = moff;
	}

	return (0);
}

int
ofp13_packet_match(struct ibuf *ibuf, struct packet *pkt, struct ofp_match *om)
{
	struct ether_header	*eh = pkt->pkt_eh;
	size_t			 padsize, startpos, endpos, omlen;

	if (eh == NULL)
		return (-1);

	startpos = ibuf->wpos;
	if (oxm_etheraddr(ibuf, 1, eh->ether_shost, NULL) == -1)
		return (-1);
	if (oxm_etheraddr(ibuf, 0, eh->ether_dhost, NULL) == -1)
		return (-1);
	endpos = ibuf->wpos;

	omlen = sizeof(*om) + (endpos - startpos);
	padsize = OFP_ALIGN(omlen) - omlen;

	om->om_type = htons(OFP_MATCH_OXM);
	om->om_length = htons(omlen);
	if (padsize && ibuf_advance(ibuf, padsize) == NULL)
		return (-1);

	return (0);
}

int
ofp13_packet_in(struct switchd *sc, struct switch_connection *con,
    struct ofp_header *ih, struct ibuf *ibuf)
{
	struct ofp_packet_in		*pin;
	struct ofp_packet_out		*pout;
	struct ofp_flow_mod		*fm;
	struct ofp_header		*oh;
	struct ofp_match		*om;
	struct ofp_ox_match		*oxm;
	struct packet			 pkt;
	struct ibuf			*obuf = NULL;
	int				 table, ret = -1;
	ssize_t				 len, mlen;
	uint32_t			 srcport = 0, dstport;
	int				 addflow = 0, sendbuffer = 0;
	off_t				 off, moff;
	void				*ptr;
	struct ofp_instruction_actions	*ia;

	if ((pin = ibuf_getdata(ibuf, sizeof(*pin))) == NULL)
		return (-1);

	/* We only handle no matches right now. */
	if (pin->pin_reason != OFP_PKTIN_REASON_NO_MATCH)
		return (-1);

	bzero(&pkt, sizeof(pkt));
	len = ntohs(pin->pin_total_len);

	/* very basic way of getting the source port */
	om = &pin->pin_match;
	mlen = ntohs(om->om_length);
	off = (OFP_ALIGN(mlen) + ETHER_ALIGN) - sizeof(pin->pin_match);
	moff = ibuf_dataoffset(ibuf);

	do {
		if ((oxm = ibuf_seek(ibuf, moff, sizeof(*oxm))) == NULL)
			return (-1);

		/* Find IN_PORT */
		switch (ntohs(oxm->oxm_class)) {
		case OFP_OXM_C_OPENFLOW_BASIC:
			switch (OFP_OXM_GET_FIELD(oxm)) {
			case OFP_XM_T_IN_PORT:
				moff += sizeof(*oxm);
				if ((ptr = ibuf_seek(ibuf, moff,
				    sizeof(srcport))) == NULL)
					return (-1);
				srcport = htonl(*(uint32_t *)ptr);
				mlen = 0; /* break loop */
				break;
			default:
				/* ignore unsupported match types */
				break;
			}
		default:
			/* ignore unsupported match classes */
			break;
		}
		moff += sizeof(*oxm) + oxm->oxm_length;
		mlen -= sizeof(*oxm) + oxm->oxm_length;
	} while (mlen > 0 && oxm->oxm_length);

	/* Skip all matches and seek to the packet */
	if (ibuf_getdata(ibuf, off) == NULL)
		return (-1);

	if (packet_input(sc, con->con_switch,
	    srcport, &dstport, ibuf, len, &pkt) == -1 ||
	    (dstport > OFP_PORT_MAX &&
	    dstport != OFP_PORT_LOCAL &&
	    dstport != OFP_PORT_CONTROLLER)) {
		/* fallback to flooding */
		dstport = OFP_PORT_FLOOD;
	} else if (srcport == dstport) {
		/*
		 * silently drop looping packet
		 * (don't use OFP_PORT_INPUT here)
		 */
		dstport = OFP_PORT_ANY;
	} else {
		addflow = 1;
	}

	if ((obuf = ibuf_static()) == NULL)
		goto done;

 again:
	if (addflow) {
		table = ofp13_getflowtable(con);
		if (table > OFP_TABLE_ID_MAX || table < 0) {
			/* This switch doesn't support installing flows. */
			addflow = 0;
			goto again;
		}

		if ((fm = ibuf_advance(obuf, sizeof(*fm))) == NULL)
			goto done;

		oh = &fm->fm_oh;
		fm->fm_cookie = 0; /* XXX should we set a cookie? */
		fm->fm_command = OFP_FLOWCMD_ADD;
		fm->fm_idle_timeout = htons(sc->sc_cache_timeout);
		fm->fm_hard_timeout = 0; /* permanent */
		fm->fm_priority = 0;
		fm->fm_buffer_id = pin->pin_buffer_id;
		fm->fm_table_id = table;
		fm->fm_flags = htons(OFP_FLOWFLAG_SEND_FLOW_REMOVED);
		if (pin->pin_buffer_id == htonl(OFP_PKTOUT_NO_BUFFER))
			sendbuffer = 1;

		/* Write flow matches to create an entry. */
		if (ofp13_packet_match(obuf, &pkt, &fm->fm_match) == -1)
			goto done;

		/*
		 * Write the instruction action header and add the output
		 * action.
		 */
		if ((ia = ibuf_advance(obuf, sizeof(*ia))) == NULL ||
		    action_output(obuf, dstport,
		    OFP_CONTROLLER_MAXLEN_NO_BUFFER) == -1)
			goto done;

		ia->ia_type = htons(OFP_INSTRUCTION_T_APPLY_ACTIONS);
		ia->ia_len = htons(sizeof(*ia) +
		    sizeof(struct ofp_action_output));
	} else {
		if ((pout = ibuf_advance(obuf, sizeof(*pout))) == NULL)
			goto done;

		oh = &pout->pout_oh;
		pout->pout_buffer_id = pin->pin_buffer_id;
		pout->pout_in_port = htonl(srcport);
		pout->pout_actions_len =
		    htons(sizeof(struct ofp_action_output));

		if (action_output(obuf, dstport,
		    OFP_CONTROLLER_MAXLEN_NO_BUFFER) == -1)
			goto done;

		/* Add optional packet payload */
		if (pin->pin_buffer_id == htonl(OFP_PKTOUT_NO_BUFFER) &&
		    imsg_add(obuf, pkt.pkt_buf, pkt.pkt_len) == -1)
			goto done;
	}

	/* Set output header */
	oh->oh_version = OFP_V_1_3;
	oh->oh_length = htons(ibuf_length(obuf));
	oh->oh_type = addflow ? OFP_T_FLOW_MOD : OFP_T_PACKET_OUT;
	oh->oh_xid = htonl(con->con_xidnxt++);

	if (ofp13_validate(sc, &con->con_local, &con->con_peer, oh, obuf) != 0)
		goto done;

	ofp_output(con, NULL, obuf);

	if (sendbuffer) {
		ibuf_release(obuf);

		/* loop to output the packet again */
		addflow = sendbuffer = 0;
		if ((obuf = ibuf_static()) == NULL)
			goto done;
		goto again;
	}

	ret = 0;
 done:
	ibuf_release(obuf);
	return (ret);
}

int
ofp13_flow_removed(struct switchd *sc, struct switch_connection *con,
    struct ofp_header *ih, struct ibuf *ibuf)
{
	struct ofp_flow_removed		*fr;

	if ((fr = ibuf_getdata(ibuf, sizeof(*fr))) == NULL)
		return (-1);

	log_debug("cookie %#016llx priority %d reason %s table_id %s "
	    "duration(%u sec, %u nsec) timeout idle %d hard %d "
	    "packet %llu byte %llu",
	    be64toh(fr->fr_cookie), ntohs(fr->fr_priority),
	    print_map(fr->fr_reason, ofp_flowrem_reason_map),
	    print_map(fr->fr_table_id, ofp_table_id_map),
	    ntohl(fr->fr_duration_sec), ntohl(fr->fr_duration_nsec),
	    ntohs(fr->fr_idle_timeout), ntohs(fr->fr_hard_timeout),
	    be64toh(fr->fr_packet_count), be64toh(fr->fr_byte_count));

	return (0);
}

int
ofp13_tableproperties(struct switch_connection *con, struct ibuf *ibuf,
    off_t off, size_t total, int new)
{
	struct ofp_table_features		*tf;
	struct ofp_table_feature_property	*tp;
	struct ofp_instruction			*i;
	struct ofp_action_header		*ah;
	struct ofp_ox_match			*oxm;
	struct switch_table			*st;
	uint8_t					*next_table;
	int					 remaining, type, length;
	int					 hlen, padsize;
	int					 class, dtype, dlen;

	/*
	 * This is a new table features reply, free our previous tables
	 * to get the updated ones.
	 */
	if (new)
		switch_freetables(con);

 next_table:
	if ((tf = ibuf_seek(ibuf, off, sizeof(*tf))) == NULL)
		return (-1);

	hlen = htons(tf->tf_length);
	total -= hlen;
	remaining = hlen - sizeof(*tf);
	off += sizeof(*tf);

	st = switch_tablelookup(con, tf->tf_tableid);
	if (st == NULL) {
		st = switch_newtable(con, tf->tf_tableid);
		if (st == NULL)
			return (-1);
	}

	st->st_maxentries = ntohl(tf->tf_max_entries);

 next_table_property:
	if ((tp = ibuf_seek(ibuf, off, sizeof(*tp))) == NULL) {
		switch_deltable(con, st);
		return (-1);
	}

	type = ntohs(tp->tp_type);
	length = ntohs(tp->tp_length);

	/* Calculate the padding. */
	padsize = OFP_ALIGN(length) - length;
	remaining -= OFP_ALIGN(length);
	length -= sizeof(*tp);
	off += sizeof(*tp);

	switch (type) {
	case OFP_TABLE_FEATPROP_INSTRUCTION:
	case OFP_TABLE_FEATPROP_INSTRUCTION_MISS:
		if (type == OFP_TABLE_FEATPROP_INSTRUCTION)
			st->st_instructions = 0;
		else
			st->st_instructionsmiss = 0;

		while (length) {
			if ((i = ibuf_seek(ibuf, off, sizeof(*i))) == NULL) {
				switch_deltable(con, st);
				return (-1);
			}

			dtype = ntohs(i->i_type);
			dlen = ntohs(i->i_len);
			if (type == OFP_TABLE_FEATPROP_INSTRUCTION)
				st->st_instructions |= 1ULL << dtype;
			else
				st->st_instructionsmiss |= 1ULL << dtype;

			if (dtype == OFP_INSTRUCTION_T_EXPERIMENTER) {
				length -= dlen;
				off += dlen;
			} else {
				length -= sizeof(*i);
				off += sizeof(*i);
			}
		}
		break;

	case OFP_TABLE_FEATPROP_NEXT_TABLES:
	case OFP_TABLE_FEATPROP_NEXT_TABLES_MISS:
		if (type == OFP_TABLE_FEATPROP_NEXT_TABLES)
			memset(st->st_nexttable, 0, sizeof(st->st_nexttable));
		else
			memset(st->st_nexttablemiss, 0,
			    sizeof(st->st_nexttablemiss));

		while (length) {
			if ((next_table = ibuf_seek(ibuf, off,
			    sizeof(*next_table))) == NULL) {
				switch_deltable(con, st);
				return (-1);
			}

			if (type == OFP_TABLE_FEATPROP_NEXT_TABLES)
				st->st_nexttable[(*next_table) / 64] |=
				    1ULL << ((*next_table) % 64);
			else
				st->st_nexttablemiss[(*next_table) / 64] |=
				    1ULL << ((*next_table) % 64);

			length -= sizeof(*next_table);
			off += sizeof(*next_table);
		}
		break;

	case OFP_TABLE_FEATPROP_WRITE_ACTIONS:
	case OFP_TABLE_FEATPROP_WRITE_ACTIONS_MISS:
	case OFP_TABLE_FEATPROP_APPLY_ACTIONS:
	case OFP_TABLE_FEATPROP_APPLY_ACTIONS_MISS:
		if (type == OFP_TABLE_FEATPROP_WRITE_ACTIONS ||
		    type == OFP_TABLE_FEATPROP_APPLY_ACTIONS)
			st->st_actions = 0;
		else
			st->st_actionsmiss = 0;

		while (length) {
			/*
			 * NOTE the OpenFlow 1.3.5 specs says that we only
			 * get 4 bytes here instead of the full action header.
			 */
			if ((ah = ibuf_seek(ibuf, off, 4)) == NULL) {
				switch_deltable(con, st);
				return (-1);
			}

			dtype = ntohs(ah->ah_type);
			dlen = ntohs(ah->ah_len);
			if (type == OFP_TABLE_FEATPROP_WRITE_ACTIONS ||
			    type == OFP_TABLE_FEATPROP_APPLY_ACTIONS)
				st->st_actions |= 1ULL << dtype;
			else
				st->st_actionsmiss |= 1ULL << dtype;

			if (dtype == OFP_ACTION_EXPERIMENTER) {
				length -= dlen;
				off += dlen;
			} else {
				length -= 4;
				off += 4;
			}
		}
		break;

	case OFP_TABLE_FEATPROP_MATCH:
	case OFP_TABLE_FEATPROP_WILDCARDS:
	case OFP_TABLE_FEATPROP_WRITE_SETFIELD:
	case OFP_TABLE_FEATPROP_WRITE_SETFIELD_MISS:
	case OFP_TABLE_FEATPROP_APPLY_SETFIELD:
	case OFP_TABLE_FEATPROP_APPLY_SETFIELD_MISS:
		if (type == OFP_TABLE_FEATPROP_WRITE_SETFIELD ||
		    type == OFP_TABLE_FEATPROP_APPLY_SETFIELD)
			st->st_setfield = 0;
		else if (type == OFP_TABLE_FEATPROP_WRITE_SETFIELD_MISS ||
			type == OFP_TABLE_FEATPROP_APPLY_SETFIELD_MISS)
			st->st_setfieldmiss = 0;
		else if (type == OFP_TABLE_FEATPROP_MATCH)
			st->st_match = 0;
		else
			st->st_wildcard = 0;

		while (length) {
			if ((oxm = ibuf_seek(ibuf, off,
			    sizeof(*oxm))) == NULL) {
				switch_deltable(con, st);
				return (-1);
			}

			class = ntohs(oxm->oxm_class);
			if (class != OFP_OXM_C_OPENFLOW_BASIC) {
				if (class == OFP_OXM_C_OPENFLOW_EXPERIMENTER) {
					length -= sizeof(*oxm) + 4;
					off += sizeof(*oxm) + 4;
				} else {
					length -= sizeof(*oxm);
					off += sizeof(*oxm);
				}
				continue;
			}

			dtype = OFP_OXM_GET_FIELD(oxm);
			if (type == OFP_TABLE_FEATPROP_WRITE_SETFIELD ||
			    type == OFP_TABLE_FEATPROP_APPLY_SETFIELD)
				st->st_setfield |= 1ULL << dtype;
			else if
			    (type == OFP_TABLE_FEATPROP_WRITE_SETFIELD_MISS ||
			    type == OFP_TABLE_FEATPROP_APPLY_SETFIELD_MISS)
				st->st_setfieldmiss |= 1ULL << dtype;
			else if (type == OFP_TABLE_FEATPROP_MATCH)
				st->st_match |= 1ULL << dtype;
			else
				st->st_wildcard |= 1ULL << dtype;

			length -= sizeof(*oxm);
			off += sizeof(*oxm);
		}
		break;

	case OFP_TABLE_FEATPROP_EXPERIMENTER:
	case OFP_TABLE_FEATPROP_EXPERIMENTER_MISS:
		off += length;
		break;

	default:
		log_debug("Unsupported table property %d", type);
		return (-1);
	}

	if (padsize)
		off += padsize;
	if (remaining > 0)
		goto next_table_property;
	if (total > 0)
		goto next_table;

	return (0);
}

int
ofp13_multipart_reply(struct switchd *sc, struct switch_connection *con,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	struct ofp_multipart		*mp;
	int				 type, flags, more, new = 0;
	int				 remaining;
	off_t				 off;

	off = 0;
	if ((mp = ibuf_seek(ibuf, 0, sizeof(*mp))) == NULL)
		return (-1);

	type = ntohs(mp->mp_type);
	flags = ntohs(mp->mp_flags);
	remaining = ntohs(oh->oh_length) - sizeof(*mp);
	off += sizeof(*mp);

	more = (flags & OFP_MP_FLAG_REPLY_MORE) == OFP_MP_FLAG_REPLY_MORE;
	/* Signalize new requests. */
	if (ofp_multipart_lookup(con, oh->oh_xid) == NULL)
		new = 1;

	if (more) {
		if (ofp_multipart_add(con, oh->oh_xid, type) == -1) {
			ofp13_error(sc, con, oh, ibuf,
			    OFP_ERRTYPE_BAD_REQUEST,
			    OFP_ERRREQ_MULTIPART_OVERFLOW);
			ofp_multipart_del(con, oh->oh_xid);
			return (0);
		}

		/*
		 * We don't need to concatenate with other messages,
		 * because the specification says that switches don't
		 * break objects. We should only need this if our parser
		 * requires the whole data before hand, but then we have
		 * better ways to achieve the same thing.
		 */
	} else
		ofp_multipart_del(con, oh->oh_xid);

	switch (type) {
	case OFP_MP_T_TABLE_FEATURES:
		if (ofp13_tableproperties(con, ibuf, off, remaining, new))
			return (-1);

		/* We finished receiving tables, configure the switch. */
		if (more == 0)
			return (ofp13_switchconfigure(sc, con));
		break;
	}

	return (0);
}

int
ofp13_validate_tableproperty(struct ibuf *ibuf, off_t off, int remaining)
{
	struct ofp_table_features		*tf;
	struct ofp_table_feature_property	*tp;
	struct ofp_instruction			*i;
	struct ofp_action_header		*ah;
	struct ofp_ox_match			*oxm;
	uint8_t					*nexttable;
	int					 hlen, htype, tplen;
	int					 type, length, class;
	int					 padsize;

 next_table:
	if ((tf = ibuf_seek(ibuf, off, sizeof(*tf))) == NULL)
		return (-1);

	hlen = ntohs(tf->tf_length);
	log_debug("\t\ttable features length %d tableid %s "
	    " name \"%s\" metadata match %#016llx write %#016llx "
	    "config %u max_entries %u",
	    hlen, print_map(tf->tf_tableid, ofp_table_id_map), tf->tf_name,
	    be64toh(tf->tf_metadata_match),
	    be64toh(tf->tf_metadata_write), ntohl(tf->tf_config),
	    ntohl(tf->tf_max_entries));

	off += sizeof(*tf);
	remaining -= sizeof(*tf);
	hlen -= sizeof(*tf);

 next_property:
	if ((tp = ibuf_seek(ibuf, off, sizeof(*tp))) == NULL)
		return (-1);

	off += sizeof(*tp);
	htype = ntohs(tp->tp_type);
	tplen = ntohs(tp->tp_length);
	padsize = OFP_ALIGN(tplen) - tplen;
	remaining -= tplen;
	hlen -= tplen;

	/* Don't count the header bytes for payload. */
	tplen -= sizeof(*tp);

	log_debug("\t\t%s (length %d):",
	    print_map(htype, ofp_table_featprop_map), tplen);
	if (tplen <= 0)
		goto empty_table;

	switch (htype) {
	case OFP_TABLE_FEATPROP_INSTRUCTION:
	case OFP_TABLE_FEATPROP_INSTRUCTION_MISS:
		while (tplen > 0) {
			if ((i = ibuf_seek(ibuf, off, sizeof(*i))) == NULL)
				return (-1);

			type = ntohs(i->i_type);
			length = ntohs(i->i_len);
			if (type == OFP_INSTRUCTION_T_EXPERIMENTER) {
				tplen -= length;
				off += length;
			} else {
				tplen -= sizeof(*i);
				off += sizeof(*i);
			}

			log_debug("\t\t\ttype %s length %d",
			    print_map(type, ofp_instruction_t_map), length);
		}
		break;

	case OFP_TABLE_FEATPROP_NEXT_TABLES:
	case OFP_TABLE_FEATPROP_NEXT_TABLES_MISS:
		while (tplen > 0) {
			if ((nexttable = ibuf_seek(ibuf, off,
			    sizeof(*nexttable))) == NULL)
				return (-1);

			log_debug("\t\t\t%d", *nexttable);

			off += sizeof(*nexttable);
			tplen -= sizeof(*nexttable);
		}
		break;

	case OFP_TABLE_FEATPROP_WRITE_ACTIONS:
	case OFP_TABLE_FEATPROP_WRITE_ACTIONS_MISS:
	case OFP_TABLE_FEATPROP_APPLY_ACTIONS:
	case OFP_TABLE_FEATPROP_APPLY_ACTIONS_MISS:
		while (tplen > 0) {
			/* NOTE: we read the action header without the pad. */
			if ((ah = ibuf_seek(ibuf, off, 4)) == NULL)
				return (-1);

			type = ntohs(ah->ah_type);
			length = ntohs(ah->ah_len);
			log_debug("\t\t\taction %s length %d",
			    print_map(type, ofp_action_map), length);
			if (type == OFP_ACTION_EXPERIMENTER) {
				tplen -= length;
				off += length;
			} else {
				tplen -= 4;
				off += 4;
			}
		}
		break;

	case OFP_TABLE_FEATPROP_MATCH:
	case OFP_TABLE_FEATPROP_WILDCARDS:
	case OFP_TABLE_FEATPROP_WRITE_SETFIELD:
	case OFP_TABLE_FEATPROP_WRITE_SETFIELD_MISS:
	case OFP_TABLE_FEATPROP_APPLY_SETFIELD:
	case OFP_TABLE_FEATPROP_APPLY_SETFIELD_MISS:
		while (tplen > 0) {
			if ((oxm = ibuf_seek(ibuf, off, sizeof(*oxm))) == NULL)
				return (-1);

			class = ntohs(oxm->oxm_class);
			type = OFP_OXM_GET_FIELD(oxm);
			length = oxm->oxm_length;
			if (class == OFP_OXM_C_OPENFLOW_EXPERIMENTER) {
				off += sizeof(*oxm) + 4;
				tplen -= sizeof(*oxm) + 4;
			} else {
				off += sizeof(*oxm);
				tplen -= sizeof(*oxm);
			}

			log_debug("\t\t\tclass %s type %s length %d",
			    print_map(class, ofp_oxm_c_map),
			    print_map(type, ofp_xm_t_map), length);
		}
		break;

	case OFP_TABLE_FEATPROP_EXPERIMENTER:
	case OFP_TABLE_FEATPROP_EXPERIMENTER_MISS:
		off += tplen;
		break;

	default:
		return (-1);
	}

 empty_table:
	if (padsize) {
		off += padsize;
		remaining -= padsize;
		hlen -= padsize;
	}
	if (hlen > 0)
		goto next_property;
	if (remaining > 0)
		goto next_table;

	return (0);
}

int
ofp13_multipart_reply_validate(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	struct ofp_multipart		*mp;
	struct ofp_flow_stats		*fs;
	struct ofp_desc			*d;
	struct ofp_match		*om;
	struct ofp_ox_match		*oxm;
	struct ofp_instruction		*oi;
	int				 mptype, mpflags, hlen;
	int				 remaining, matchlen, matchtype;
	int				 ilen, padsize;
	off_t				 off, moff, offdiff;

	remaining = ntohs(oh->oh_length);

	off = 0;
	if ((mp = ibuf_seek(ibuf, off, sizeof(*mp))) == NULL)
		return (-1);

	mptype = ntohs(mp->mp_type);
	mpflags = ntohs(mp->mp_flags);
	log_debug("\ttype %s flags %#04x",
	    print_map(mptype, ofp_mp_t_map), mpflags);

	off += sizeof(*mp);
	remaining -= sizeof(*mp);
	if (remaining == 0) {
		log_debug("\tempty reply");
		return (0);
	}

	switch (mptype) {
	case OFP_MP_T_DESC:
		if ((d = ibuf_seek(ibuf, off, sizeof(*d))) == NULL)
			return (-1);

		off += sizeof(*d);
		remaining -= sizeof(*d);
		log_debug("\tmfr_desc \"%s\" hw_desc \"%s\" sw_desc \"%s\" "
		    "serial_num \"%s\" dp_desc \"%s\"",
		    d->d_mfr_desc, d->d_hw_desc, d->d_sw_desc,
		    d->d_serial_num, d->d_dp_desc);
		break;

	case OFP_MP_T_FLOW:
 read_next_flow:
		if ((fs = ibuf_seek(ibuf, off, sizeof(*fs))) == NULL)
			return (-1);

		hlen = ntohs(fs->fs_length);
		remaining -= hlen;
		moff = off + sizeof(*fs);
		off += hlen;

		log_debug("\tflow length %d table_id %s duration sec %u "
		    "nsec %u prio %d timeout idle %d hard %d flags %#04x "
		    "cookie %#016llx packet count %llu byte count %llu",
		    hlen, print_map(fs->fs_table_id, ofp_table_id_map),
		    ntohl(fs->fs_duration_sec), ntohl(fs->fs_duration_nsec),
		    ntohs(fs->fs_priority), ntohs(fs->fs_idle_timeout),
		    ntohs(fs->fs_hard_timeout), ntohs(fs->fs_flags),
		    be64toh(fs->fs_cookie), be64toh(fs->fs_packet_count),
		    be64toh(fs->fs_byte_count));

		om = &fs->fs_match;
		matchtype = ntohs(om->om_type);
		matchlen = ntohs(om->om_length);
		padsize = OFP_ALIGN(matchlen) - matchlen;
		ilen = hlen -
		    ((sizeof(*fs) - sizeof(*om)) + matchlen + padsize);

		/* We don't know how to parse anything else yet. */
		if (matchtype != OFP_MATCH_OXM)
			break;

		matchlen -= sizeof(*om);
		while (matchlen) {
			if ((oxm = ibuf_seek(ibuf, moff, sizeof(*oxm))) == NULL)
				return (-1);
			if (ofp13_validate_oxm(sc, oxm, oh, ibuf, moff) == -1)
				return (-1);
			moff += sizeof(*oxm) + oxm->oxm_length;
			matchlen -= sizeof(*oxm) + oxm->oxm_length;
		}

		moff += padsize;

		while (ilen) {
			offdiff = moff;
			if ((oi = ibuf_seek(ibuf, moff, sizeof(*oi))) == NULL ||
			    ofp13_validate_instruction(sc, oh, ibuf,
			    &moff, oi) == -1)
				return (-1);
			/* Avoid loops. */
			if ((moff - offdiff) == 0)
				return (-1);

			ilen -= moff - offdiff;
		}

		if (remaining)
			goto read_next_flow;
		break;

	case OFP_MP_T_AGGREGATE:
	case OFP_MP_T_TABLE:
	case OFP_MP_T_PORT_STATS:
	case OFP_MP_T_QUEUE:
	case OFP_MP_T_GROUP:
	case OFP_MP_T_GROUP_DESC:
	case OFP_MP_T_GROUP_FEATURES:
	case OFP_MP_T_METER:
	case OFP_MP_T_METER_CONFIG:
	case OFP_MP_T_METER_FEATURES:
		break;

	case OFP_MP_T_TABLE_FEATURES:
		if (ofp13_validate_tableproperty(ibuf, off, remaining))
			return (-1);
		break;

	case OFP_MP_T_PORT_DESC:
	case OFP_MP_T_EXPERIMENTER:
		break;

	default:
		return (-1);
	}

	return (0);
}

/* Don't forget to update mp->mp_oh.oh_length */
struct ofp_multipart *
ofp13_multipart_request(struct switch_connection *con, struct ibuf *ibuf,
    uint16_t type, uint16_t flags)
{
	struct ofp_multipart		*mp;
	struct ofp_header		*oh;

	if ((mp = ibuf_advance(ibuf, sizeof(*mp))) == NULL)
		return (NULL);

	oh = &mp->mp_oh;
	oh->oh_version = OFP_V_1_3;
	oh->oh_type = OFP_T_MULTIPART_REQUEST;
	oh->oh_xid = htonl(con->con_xidnxt++);
	mp->mp_type = htons(type);
	mp->mp_flags = htons(flags);
	return (mp);
}

int
ofp13_multipart_request_validate(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	struct ofp_multipart		*mp;
	struct ofp_match		*om;
	struct ofp_flow_stats_request	*fsr;
	struct ofp_ox_match		*oxm;
	off_t				 off, moff;
	int				 type, flags, totallen;
	int				 matchlen, matchtype;

	off = 0;
	if ((mp = ibuf_seek(ibuf, off, sizeof(*mp))) == NULL)
		return (-1);

	type = ntohs(mp->mp_type);
	flags = ntohs(mp->mp_flags);
	log_debug("\ttype %s flags %#04x",
	    print_map(type, ofp_mp_t_map), flags);

	totallen = ntohs(oh->oh_length);
	off += sizeof(*mp);

	switch (type) {
	case OFP_MP_T_DESC:
		/* This type doesn't use a payload. */
		if (totallen != sizeof(*mp))
			return (-1);
		break;

	case OFP_MP_T_FLOW:
		if ((fsr = ibuf_seek(ibuf, off, sizeof(*fsr))) == NULL)
			return (-1);

		om = &fsr->fsr_match;
		matchtype = ntohs(om->om_type);
		matchlen = ntohs(om->om_length);
		log_debug("\ttable_id %s out_port %s out_group %s "
		    "cookie %#016llx mask %#016llx match type %s length %d "
		    "(padded to %d)",
		    print_map(fsr->fsr_table_id, ofp_table_id_map),
		    print_map(ntohl(fsr->fsr_out_port), ofp_port_map),
		    print_map(ntohl(fsr->fsr_out_group), ofp_group_id_map),
		    be64toh(fsr->fsr_cookie), be64toh(fsr->fsr_cookie_mask),
		    print_map(matchtype, ofp_match_map), matchlen,
		    OFP_ALIGN(matchlen));

		/* Get the first OXM byte offset. */
		moff = off + sizeof(*fsr);

		/* Don't count the header bytes. */
		matchlen -= sizeof(*om);

		/* We don't know how to parse anything else yet. */
		if (matchtype != OFP_MATCH_OXM)
			break;

		while (matchlen) {
			if ((oxm = ibuf_seek(ibuf, moff, sizeof(*oxm))) == NULL)
				return (-1);
			if (ofp13_validate_oxm(sc, oxm, oh, ibuf, moff) == -1)
				return (-1);
			moff += sizeof(*oxm) + oxm->oxm_length;
			matchlen -= sizeof(*oxm) + oxm->oxm_length;
		}
		break;

	case OFP_MP_T_AGGREGATE:
	case OFP_MP_T_TABLE:
	case OFP_MP_T_PORT_STATS:
	case OFP_MP_T_QUEUE:
	case OFP_MP_T_GROUP:
	case OFP_MP_T_GROUP_DESC:
	case OFP_MP_T_GROUP_FEATURES:
	case OFP_MP_T_METER:
	case OFP_MP_T_METER_CONFIG:
	case OFP_MP_T_METER_FEATURES:
		break;

	case OFP_MP_T_TABLE_FEATURES:
		if (totallen == sizeof(*mp)) {
			log_debug("\tempty table properties request");
			break;
		}
		break;

	case OFP_MP_T_PORT_DESC:
	case OFP_MP_T_EXPERIMENTER:
		break;

	default:
		return (-1);
	}

	return (0);
}

int
ofp13_desc(struct switchd *sc, struct switch_connection *con)
{
	struct ofp_header		*oh;
	struct ofp_multipart		*mp;
	struct ibuf			*ibuf;
	int				 rv = -1;

	if ((ibuf = ibuf_static()) == NULL)
		return (-1);

	if ((mp = ofp13_multipart_request(con, ibuf, OFP_MP_T_DESC, 0)) == NULL)
		goto done;

	oh = &mp->mp_oh;
	oh->oh_length = htons(sizeof(*mp));
	if (ofp13_validate(sc, &con->con_local, &con->con_peer, oh, ibuf) != 0)
		goto done;

	rv = ofp_output(con, NULL, ibuf);

 done:
	ibuf_free(ibuf);
	return (rv);
}

int
ofp13_flow_stats(struct switchd *sc, struct switch_connection *con,
    uint32_t out_port, uint32_t out_group, uint8_t table_id)
{
	struct ofp_header		*oh;
	struct ofp_multipart		*mp;
	struct ofp_flow_stats_request	*fsr;
	struct ofp_match		*om;
	struct ibuf			*ibuf;
	int				 padsize, rv = -1;

	if ((ibuf = ibuf_static()) == NULL)
		return (-1);

	if ((mp = ofp13_multipart_request(con, ibuf, OFP_MP_T_FLOW, 0)) == NULL)
		goto done;
	if ((fsr = ibuf_advance(ibuf, sizeof(*fsr))) == NULL)
		goto done;

	oh = &mp->mp_oh;
	fsr->fsr_table_id = table_id;
	fsr->fsr_out_port = htonl(out_port);
	fsr->fsr_out_group = htonl(out_group);

	om = &fsr->fsr_match;
	om->om_type = htons(OFP_MATCH_OXM);
	om->om_length = htons(sizeof(*om));
	padsize = OFP_ALIGN(sizeof(*om)) - sizeof(*om);
	if (padsize && ibuf_advance(ibuf, padsize) == NULL)
		goto done;

	oh->oh_length = htons(ibuf_length(ibuf));
	if (ofp13_validate(sc, &con->con_local, &con->con_peer, oh, ibuf) != 0)
		goto done;

	rv = ofp_output(con, NULL, ibuf);

 done:
	ibuf_free(ibuf);
	return (rv);
}

int
ofp13_table_features(struct switchd *sc, struct switch_connection *con,
    uint8_t tableid)
{
	struct ofp_header		*oh;
	struct ofp_multipart		*mp;
	struct ibuf			*ibuf;
	int				 rv = -1;

	if ((ibuf = ibuf_static()) == NULL)
		return (-1);

	if ((mp = ofp13_multipart_request(con, ibuf,
	    OFP_MP_T_TABLE_FEATURES, 0)) == NULL)
		goto done;

	oh = &mp->mp_oh;
	oh->oh_length = htons(sizeof(*mp));
	if (ofp13_validate(sc, &con->con_local, &con->con_peer, oh, ibuf) != 0)
		goto done;

	rv = ofp_output(con, NULL, ibuf);

 done:
	ibuf_free(ibuf);
	return (rv);
}

int
ofp13_error(struct switchd *sc, struct switch_connection *con,
    struct ofp_header *oh, struct ibuf *ibuf, uint16_t type, uint16_t code)
{
	struct ibuf		*obuf;
	struct ofp_error	*err;
	struct ofp_header	*header;
	int			 dlen, rv = -1;

	if ((obuf = ibuf_static()) == NULL ||
	    (err = ibuf_advance(obuf, sizeof(*err))) == NULL)
		goto done;

	header = &err->err_oh;
	err->err_type = htons(type);
	err->err_code = htons(code);

	/* Copy the first message bytes for the error payload. */
	dlen = ibuf_size(ibuf);
	if (dlen > OFP_ERRDATA_MAX)
		dlen = OFP_ERRDATA_MAX;
	if (ibuf_add(obuf, ibuf_seek(ibuf, 0, dlen), dlen) == -1)
		goto done;

	header->oh_version = OFP_V_1_3;
	header->oh_type = OFP_T_ERROR;
	header->oh_length = htons(ibuf_length(obuf));
	header->oh_xid = oh->oh_xid;
	if (ofp13_validate(sc, &con->con_peer, &con->con_local, header,
	    obuf) == -1)
		goto done;

	rv = ofp_output(con, NULL, obuf);

 done:
	ibuf_free(obuf);
	return (rv);
}

/*
 * The valid commands for groups are:
 * OFP_GROUPCMD_{ADD,MODIFY,DELETE}
 *
 * The valid type for groups are:
 * OFP_GROUP_T_{ALL,SELECT,INDIRECT,FAST_FAILOVER}
 *
 * You have to update the gm->gm_oh.oh_length = htons(ibuf_length(ibuf));
 */
struct ofp_group_mod *
ofp13_group(struct switch_connection *con, struct ibuf *ibuf,
    uint32_t gid, uint16_t cmd, uint8_t type)
{
	struct ofp_group_mod		*gm;
	struct ofp_header		*oh;

	if ((gm = ibuf_advance(ibuf, sizeof(*gm))) == NULL)
		return (NULL);

	oh = &gm->gm_oh;
	oh->oh_version = OFP_V_1_3;
	oh->oh_type = OFP_T_GROUP_MOD;
	oh->oh_xid = htonl(con->con_xidnxt++);
	gm->gm_command = htons(cmd);
	gm->gm_type = type;
	gm->gm_group_id = htonl(gid);
	return (gm);
}

/* Remember to update b->b_len. */
struct ofp_bucket *
ofp13_bucket(struct ibuf *ibuf, uint16_t weight, uint32_t watchport,
    uint32_t watchgroup)
{
	struct ofp_bucket		*b;

	if ((b = ibuf_advance(ibuf, sizeof(*b))) == NULL)
		return (NULL);

	b->b_weight = htons(weight);
	b->b_watch_port = htonl(watchport);
	b->b_watch_group = htonl(watchgroup);
	return (b);
}

int
ofp13_setconfig_validate(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh, struct ibuf *ibuf)
{
	struct ofp_switch_config	*cfg;

	if ((cfg = ibuf_seek(ibuf, 0, sizeof(*cfg))) == NULL)
		return (-1);

	log_debug("\tflags %#04x miss_send_len %s",
	    ntohs(cfg->cfg_flags), print_map(ntohs(cfg->cfg_miss_send_len),
	    ofp_controller_maxlen_map));
	return (0);
}

int
ofp13_setconfig(struct switchd *sc, struct switch_connection *con,
     uint16_t flags, uint16_t misslen)
{
	struct ibuf			*ibuf;
	struct ofp_switch_config	*cfg;
	struct ofp_header		*oh;
	int				 rv = -1;

	if ((ibuf = ibuf_static()) == NULL ||
	    (cfg = ibuf_advance(ibuf, sizeof(*cfg))) == NULL)
		goto done;

	cfg->cfg_flags = htons(flags);
	cfg->cfg_miss_send_len = htons(misslen);

	oh = &cfg->cfg_oh;
	oh->oh_version = OFP_V_1_3;
	oh->oh_type = OFP_T_SET_CONFIG;
	oh->oh_length = htons(ibuf_length(ibuf));
	oh->oh_xid = htonl(con->con_xidnxt++);
	if (ofp13_validate(sc, &con->con_local, &con->con_peer, oh, ibuf) != 0)
		goto done;

	rv = ofp_output(con, NULL, ibuf);

 done:
	ibuf_free(ibuf);
	return (rv);
}

/*
 * Flow modification message.
 *
 * After the flow-mod header we have N OXM filters to match packets, when
 * you finish adding them you must update match header:
 * fm_match.om_length = sizeof(fm_match) + OXM length.
 *
 * Then you must add flow instructions and update the OFP header length:
 * fm_oh.oh_length =
 *     sizeof(*fm) + (fm_match.om_len - sizeof(fm_match)) + instructionslen.
 * or
 * fm_oh.oh_length = ibuf_length(ibuf).
 *
 * Note on match payload:
 * After adding all matches and before starting to insert instructions you
 * must add the mandatory padding to fm_match. You can calculate the padding
 * size with this formula:
 * padsize = OFP_ALIGN(fm_match.om_length) - fm_match.om_length;
 *
 * Note on Table-miss:
 * To make a table miss you need to set priority 0 and don't add any
 * matches, just instructions.
 */
struct ofp_flow_mod *
ofp13_flowmod(struct switch_connection *con, struct ibuf *ibuf,
    uint8_t cmd, uint8_t table, uint16_t idleto, uint16_t hardto,
    uint16_t prio)
{
	struct ofp_flow_mod		*fm;

	if ((fm = ibuf_advance(ibuf, sizeof(*fm))) == NULL)
		return (NULL);

	fm->fm_oh.oh_version = OFP_V_1_3;
	fm->fm_oh.oh_type = OFP_T_FLOW_MOD;
	fm->fm_oh.oh_length = htons(sizeof(*fm));
	fm->fm_oh.oh_xid = htonl(con->con_xidnxt++);

	fm->fm_command = cmd;
	fm->fm_buffer_id = htonl(OFP_PKTOUT_NO_BUFFER);
	fm->fm_flags = htons(OFP_FLOWFLAG_SEND_FLOW_REMOVED);

	fm->fm_match.om_type = htons(OFP_MATCH_OXM);
	fm->fm_match.om_length = htons(sizeof(fm->fm_match));

	return (fm);
}

int
ofp13_tablemiss_sendctrl(struct switchd *sc, struct switch_connection *con,
    uint8_t table)
{
	struct oflowmod_ctx	 ctx;
	struct ibuf		*ibuf;
	int			 ret;

	if ((ibuf = oflowmod_open(&ctx, con, NULL, OFP_V_1_3)) == NULL)
		goto err;

	if (oflowmod_iopen(&ctx) == -1)
		goto err;

	/* Update header */
	ctx.ctx_fm->fm_table_id = table;

	if (oflowmod_instruction(&ctx,
	    OFP_INSTRUCTION_T_APPLY_ACTIONS) == -1)
		goto err;
	if (action_output(ibuf, OFP_PORT_CONTROLLER,
	    OFP_CONTROLLER_MAXLEN_MAX) == -1)
		goto err;

	if (oflowmod_iclose(&ctx) == -1)
		goto err;
	if (oflowmod_close(&ctx) == -1)
		goto err;

	if (ofp13_validate(sc, &con->con_local, &con->con_peer,
	    &ctx.ctx_fm->fm_oh, ibuf) != 0)
		goto err;

	ret = ofp_output(con, NULL, ibuf);
	ibuf_release(ibuf);

	return (ret);

 err:
	(void)oflowmod_err(&ctx, __func__, __LINE__);
	return (-1);
}

int
ofp13_switchconfigure(struct switchd *sc, struct switch_connection *con)
{
	struct switch_table		*st;

	/* Look for a table with 'apply' and 'output' support for miss. */
	TAILQ_FOREACH(st, &con->con_stlist, st_entry) {
		if ((st->st_instructionsmiss &
		    (1ULL << OFP_INSTRUCTION_T_APPLY_ACTIONS)) == 0)
			continue;
		if ((st->st_actionsmiss & (1ULL << OFP_ACTION_OUTPUT)) == 0)
			continue;

		break;
	}
	if (st == NULL) {
		log_warn("No apply output for this switch");
		return (-1);
	}

	/* Install the flow to receive packets from the switch. */
	return (ofp13_tablemiss_sendctrl(sc, con, st->st_table));
}

int
ofp13_getflowtable(struct switch_connection *con)
{
	struct switch_table		*st;

	/* Look for a table with 'apply' and 'output' support. */
	TAILQ_FOREACH(st, &con->con_stlist, st_entry) {
		if ((st->st_instructions &
		    (1ULL << OFP_INSTRUCTION_T_APPLY_ACTIONS)) == 0)
			continue;
		if ((st->st_actions & (1ULL << OFP_ACTION_OUTPUT)) == 0)
			continue;

		break;
	}
	if (st == NULL)
		return (-1);

	return (st->st_table);
}
@


1.42
log
@Learn remote switch flow tables properties to find out where to install
the default table-miss flow for OpenFlow 1.3.5. This is enough to make
switchd(8) to work with switch(4) and HP 3800 switch out-of-the-box.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.41 2016/12/02 14:39:46 rzalamena Exp $	*/
d794 1
a794 1
		while (len) {
d801 2
a802 2
			len -= sizeof(*oxm) - oxm->oxm_length;
			moff += sizeof(*oxm) - oxm->oxm_length;
@


1.41
log
@Implement the connection state machine for OpenFlow 1.0 and 1.3 to detect
invalid state transitions and invalid protocol version switching after the
hello messages exchange.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.40 2016/11/22 17:21:56 rzalamena Exp $	*/
d73 2
a74 4
int	 ofp13_parse_instruction(struct ibuf *, struct ofp_instruction *);
int	 ofp13_parse_action(struct ibuf *, struct ofp_action_header *);
int	 ofp13_parse_oxm(struct ibuf *, struct ofp_ox_match *);
int	 ofp13_parse_tableproperties(struct ibuf *, struct ofp_table_features *);
d105 3
d1017 1
a1017 1
	int				 ret = -1;
d1095 7
d1112 1
d1203 2
a1204 1
ofp13_parse_instruction(struct ibuf *ibuf, struct ofp_instruction *i)
d1206 10
a1215 10
	int			 type;
	int			 len;

	type = ntohs(i->i_type);
	len = ntohs(i->i_len);

	log_debug("\t\t%s", print_map(type, ofp_instruction_t_map));

	return (len);
}
a1216 21
int
ofp13_parse_action(struct ibuf *ibuf, struct ofp_action_header *ah)
{
	int				 len, type;

	len = htons(ah->ah_len);
	type = htons(ah->ah_type);

	log_debug("\t\t%s", print_map(type, ofp_action_map));

	return (len);
}

int
ofp13_parse_oxm(struct ibuf *ibuf, struct ofp_ox_match *oxm)
{
	int			length, type, class, hasmask;

	class = ntohs(oxm->oxm_class);
	type = OFP_OXM_GET_FIELD(oxm);
	hasmask = OFP_OXM_GET_HASMASK(oxm);
d1218 2
a1219 2
	 * XXX the OpenFlow 1.3.5 specification says this field is only
	 * 4 bytes long, however the experimental type is 8 bytes.
d1221 2
a1222 1
	length = sizeof(*oxm);
d1224 3
a1226 3
	log_debug("\t\t%s hasmask %s type %s",
	    print_map(class, ofp_oxm_c_map), hasmask ? "yes" : "no",
	    print_map(type, ofp_xm_t_map));
d1228 9
a1236 3
	if (class == OFP_OXM_C_OPENFLOW_EXPERIMENTER) {
		/* Get the last bytes. */
		if (ibuf_getdata(ibuf, 4) == NULL)
a1237 2

		return (8);
d1240 1
a1240 21
	return (length);
}

int
ofp13_parse_tableproperties(struct ibuf *ibuf, struct ofp_table_features *tf)
{
	struct ofp_table_feature_property	*tp;
	struct ofp_instruction			*i;
	struct ofp_action_header		*ah;
	struct ofp_ox_match			*oxm;
	uint8_t					*next_table;
	int					 remaining, type, length;
	int					 totallen, padsize, rv;

	log_debug("Table %s (%d) max_entries %u config %u "
	    "metadata match %#016llx write %#016llx",
	    tf->tf_name, tf->tf_tableid, ntohl(tf->tf_max_entries),
	    ntohl(tf->tf_config), be64toh(tf->tf_metadata_match),
	    be64toh(tf->tf_metadata_write));
	totallen = htons(tf->tf_length);
	remaining = totallen - sizeof(*tf);
d1243 2
a1244 1
	if ((tp = ibuf_getdata(ibuf, sizeof(*tp))) == NULL)
d1246 1
d1255 1
a1255 4

	log_debug("\t%s:", print_map(type, ofp_table_featprop_map));
	if (length == 0)
		log_debug("\t\tNONE");
d1260 5
d1266 2
a1267 1
			if ((i = ibuf_getdata(ibuf, sizeof(*i))) == NULL)
d1269 16
a1284 3
			if ((rv = ofp13_parse_instruction(ibuf, i)) == -1)
				return (-1);
			length -= rv;
d1290 6
d1297 3
a1299 2
			if ((next_table = ibuf_getdata(ibuf,
			    sizeof(*next_table))) == NULL)
d1301 8
a1309 1
			log_debug("\t\t%d", *next_table);
d1311 1
d1319 6
d1327 2
a1328 2
			 * XXX the OpenFlow 1.3.5 specs says that we only
			 * get 4 bytes here instead of the full OXM.
d1330 2
a1331 1
			if ((ah = ibuf_getdata(ibuf, 4)) == NULL)
d1333 17
a1349 3
			if ((rv = ofp13_parse_action(ibuf, ah)) == -1)
				return (-1);
			length -= rv;
d1359 11
d1371 3
a1373 1
			if ((oxm = ibuf_getdata(ibuf, sizeof(*oxm))) == NULL)
d1375 29
a1403 3
			if ((rv = ofp13_parse_oxm(ibuf, oxm)) == -1)
				return (-1);
			length -= rv;
d1407 5
d1413 2
a1414 7
		log_debug("%s: unsupported property type: %d", __func__, type);

		/* Skip this field and try to continue otherwise fail. */
		if (ibuf_getdata(ibuf, length) == NULL)
			return (-1);

		break;
d1417 3
a1419 4
	/* Skip the padding and read the next property if any. */
	if (padsize && ibuf_getdata(ibuf, padsize) == NULL)
		return (-1);
	if (remaining)
d1421 2
d1424 1
a1424 1
	return (totallen);
d1432 1
a1432 2
	struct ofp_table_features	*tf;
	int				 readlen, type, flags;
d1434 1
d1436 2
a1437 1
	if ((mp = ibuf_getdata(ibuf, sizeof(*mp))) == NULL)
d1443 6
d1450 1
a1450 1
	if (flags & OFP_MP_FLAG_REPLY_MORE) {
d1471 1
a1471 4
 read_next_table:
		if ((tf = ibuf_getdata(ibuf, sizeof(*tf))) == NULL)
			return (-1);
		if ((readlen = ofp13_parse_tableproperties(ibuf, tf)) == -1)
d1474 3
a1476 3
		remaining -= readlen;
		if (remaining)
			goto read_next_table;
d2211 45
@


1.40
log
@Implement support for version negotiation using hello messages. This
also prevents connections from switching the version in the middle of
the operation.

tweak from and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.39 2016/11/21 19:33:12 rzalamena Exp $	*/
a105 4
int	 ofp13_setconfig(struct switchd *, struct switch_connection *,
	    uint16_t, uint16_t);
int	 ofp13_tablemiss_sendctrl(struct switchd *, struct switch_connection *,
	    uint8_t);
d641 1
a641 5
	/* Ask for switch features so we can get more information. */
	if (ofp13_featuresrequest(sc, con) == -1)
		return (-1);

	return (0);
d678 1
a678 14
#if 0
	/* Let's not ask this while we don't use it. */
	ofp13_flow_stats(sc, con, OFP_PORT_ANY, OFP_GROUP_ID_ANY,
	    OFP_TABLE_ID_ALL);
	ofp13_table_features(sc, con, 0);
	ofp13_desc(sc, con);
#endif
	ofp13_setconfig(sc, con, OFP_CONFIG_FRAG_NORMAL,
	    OFP_CONTROLLER_MAXLEN_NO_BUFFER);

	/* Use table '0' for switch(4) and '100' for HP 3800. */
	ofp13_tablemiss_sendctrl(sc, con, 0);

	return (0);
a2037 25
	oh->oh_length = htons(ibuf_length(ibuf));
	oh->oh_xid = htonl(con->con_xidnxt++);
	if (ofp13_validate(sc, &con->con_local, &con->con_peer, oh, ibuf) != 0)
		goto done;

	rv = ofp_output(con, NULL, ibuf);

 done:
	ibuf_free(ibuf);
	return (rv);
}

int
ofp13_featuresrequest(struct switchd *sc, struct switch_connection *con)
{
	struct ibuf			*ibuf;
	struct ofp_header		*oh;
	int				 rv = -1;

	if ((ibuf = ibuf_static()) == NULL ||
	    (oh = ibuf_advance(ibuf, sizeof(*oh))) == NULL)
		goto done;

	oh->oh_version = OFP_V_1_3;
	oh->oh_type = OFP_T_FEATURES_REQUEST;
@


1.39
log
@Do more strict checks of OXM by looking at mask restrictions and add
missing OXM type (IP_PROTO).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.38 2016/11/21 19:18:39 rzalamena Exp $	*/
d112 1
a112 1
	{ OFP_T_HELLO,			ofp13_hello, NULL },
d642 1
a642 5
	/* Echo back the received Hello packet */
	oh->oh_version = OFP_V_1_3;
	oh->oh_length = htons(sizeof(*oh));
	oh->oh_xid = htonl(con->con_xidnxt++);
	if (ofp13_validate(sc, &con->con_local, &con->con_peer, oh, NULL) != 0)
a643 1
	ofp_output(con, oh, NULL);
@


1.38
log
@Add truncation validation for packet-out and reuse the action validation
function instead of manually rolling the code again.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.37 2016/11/21 18:19:51 rzalamena Exp $	*/
d187 2
a210 2
	case OFP_XM_T_ETH_DST:
	case OFP_XM_T_ETH_SRC:
d215 16
a264 3
	case OFP_XM_T_ARP_OP:
	case OFP_XM_T_VLAN_VID:
	case OFP_XM_T_IP_PROTO:
d271 10
d310 1
d317 2
d344 16
a361 1
	case OFP_XM_T_IPV6_ND_TARGET:
@


1.37
log
@Fix jumbo regress test for ofp10.c and use htonl() with OFP_PKTOUT_NO_BUFFER
for consistency.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.36 2016/11/21 17:58:24 rzalamena Exp $	*/
d477 2
a478 2
	size_t				 len;
	off_t				 off;
a479 1
	struct ofp_action_output	*ao;
d488 3
a490 1
	log_debug("\tbuffer %s port %s actions length %u",
d492 23
a514 3
	    print_map(ntohl(pout->pout_in_port), ofp_port_map),
	    ntohs(pout->pout_actions_len));
	len = ntohl(pout->pout_actions_len);
d516 5
a520 23
	off += sizeof(*pout);
	while ((ah = ibuf_seek(ibuf, off, len)) != NULL &&
	    ntohs(ah->ah_len) >= (uint16_t)sizeof(*ah)) {
		switch (ntohs(ah->ah_type)) {
		case OFP_ACTION_OUTPUT:
			ao = (struct ofp_action_output *)ah;
			log_debug("\t\taction type %s length %d "
			    "port %s max length %s",
			    print_map(ntohs(ao->ao_type), ofp_action_map),
			    ntohs(ao->ao_len),
			    print_map(ntohs(ao->ao_port), ofp_port_map),
			    print_map(ntohs(ao->ao_max_len),
			    ofp_controller_maxlen_map));
			break;
		default:
			log_debug("\t\taction type %s length %d",
			    print_map(ntohs(ah->ah_type), ofp_action_map),
			    ntohs(ah->ah_len));
			break;
		}
		if (pout->pout_buffer_id == (uint32_t)-1)
			break;
		off += ntohs(ah->ah_len);
d522 2
@


1.36
log
@Implement better table features validation. With this we get free switchctl
display of table features.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.35 2016/11/21 12:13:16 rzalamena Exp $	*/
d1085 1
a1085 1
		if (pin->pin_buffer_id == OFP_PKTOUT_NO_BUFFER)
d1119 1
a1119 1
		if (pin->pin_buffer_id == OFP_PKTOUT_NO_BUFFER &&
@


1.35
log
@Parse flow-status instructions in multipart replies, so we can see what
instructions are used by the flow.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.34 2016/11/18 20:20:19 reyk Exp $	*/
d79 1
d1392 158
a1554 1
	struct ofp_table_features	*tf;
d1669 1
a1669 2
 read_next_table:
		if ((tf = ibuf_seek(ibuf, off, sizeof(*tf))) == NULL)
a1670 14

		hlen = ntohs(tf->tf_length);
		log_debug("\ttable features length %d tableid %s name \"%s\" "
		    "config %u max_entries %u "
		    "metadata match %#016llx write %#016llx",
		    hlen, print_map(tf->tf_tableid, ofp_table_id_map),
		    tf->tf_name,ntohl(tf->tf_config),
		    ntohl(tf->tf_max_entries),
		    be64toh(tf->tf_metadata_match),
		    be64toh(tf->tf_metadata_write));
		remaining -= hlen;
		off += hlen;
		if (remaining)
			goto read_next_table;
@


1.34
log
@The special LOCAL and CONTROLLER ports are valid source ports that
should be learned by the cache.	 Fixes "addlocal" ports on switch(4).

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.33 2016/11/18 19:07:44 rzalamena Exp $	*/
d1401 1
d1404 2
a1405 1
	off_t				 off, moff;
d1460 4
a1463 1
		matchlen = ntohs(om->om_length) - sizeof(*om);
d1469 1
d1478 16
@


1.33
log
@Make switchd(8) use more strings just like tcpdump(8). While here remove
action field display from features request.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.32 2016/11/18 16:56:09 reyk Exp $	*/
d1053 3
a1055 1
	    dstport > OFP_PORT_MAX) {
d1064 2
a1066 3

	if (dstport <= OFP_PORT_MAX)
		addflow = 1;
@


1.32
log
@Define a group_id map and rename the defines accordingly.

Requested by rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.31 2016/11/18 13:15:42 rzalamena Exp $	*/
d415 2
a416 2
	log_debug("\tbuffer %d length %u reason %s table %u cookie 0x%016llx",
	    ntohl(pin->pin_buffer_id),
d419 1
a419 1
	    pin->pin_table_id,
d488 2
a489 3
	log_debug("\tbuffer %d port %s "
	    "actions length %u",
	    ntohl(pout->pout_buffer_id),
d501 1
a501 1
			    "port %s max length %d",
d505 2
a506 1
			    ntohs(ao->ao_max_len));
d633 2
a634 2
	log_debug("\tdatapath_id %#llx nbuffers %u ntables %d aux_id %d "
	    "capabilities %#08x actions %#08x",
d636 1
a636 2
	    swf->swf_ntables, swf->swf_aux_id, ntohl(swf->swf_capabilities),
	    ntohl(swf->swf_actions));
d688 1
a688 1
		log_debug("\t\taction %s len %lu port %s max_len %d",
d691 2
a692 1
		    ntohs(ao->ao_max_len));
d746 1
a746 1
		log_debug("\t\taction %s len %lu group_id %u",
d748 1
a748 1
		    ntohl(ag->ag_group_id));
d822 1
a822 1
		log_debug("\tinstruction %s length %lu table_id %d",
d824 1
a824 1
		    igt->igt_table_id);
d834 1
a834 1
		    "metadata %llu mask %llu",
d906 3
a908 3
	log_debug("\tcommand %s table %d timeout (idle %d hard %d) "
	    "priority %d buffer_id %u out_port %u out_group %u "
	    "flags %#04x cookie %llu mask %llu",
d910 8
a917 5
	    fm->fm_table_id, ntohs(fm->fm_idle_timeout),
	    ntohs(fm->fm_hard_timeout), ntohs(fm->fm_priority),
	    ntohl(fm->fm_buffer_id), ntohl(fm->fm_out_port),
	    ntohl(fm->fm_out_group), ntohs(fm->fm_flags),
	    be64toh(fm->fm_cookie), be64toh(fm->fm_cookie_mask));
d1158 8
a1165 6
	log_debug("%s: cookie:%llu priority:%d reason:%d tableid:%d "
	    "duration(%u sec, %u nsec) idleto:%d hard:%d packet:%llu byte:%llu",
	    __func__, be64toh(fr->fr_cookie), ntohs(fr->fr_priority),
	    fr->fr_reason, fr->fr_table_id, ntohl(fr->fr_duration_sec),
	    ntohl(fr->fr_duration_nsec), ntohs(fr->fr_idle_timeout),
	    ntohs(fr->fr_hard_timeout),
a1167 18
	switch (fr->fr_reason) {
	case OFP_FLOWREM_REASON_IDLE_TIMEOUT:
		log_debug("\tReason: IDLE TIMEOUT");
		break;
	case OFP_FLOWREM_REASON_HARD_TIMEOUT:
		log_debug("\tReason: HARD TIMEOUT");
		break;
	case OFP_FLOWREM_REASON_DELETE:
		log_debug("\tReason: DELETE");
		break;
	case OFP_FLOWREM_REASON_GROUP_DELETE:
		log_debug("\tReason: GROUP DELETE");
		break;
	default:
		log_debug("\tReason: UNKNOWN");
		break;
	}

d1238 2
a1239 1
	log_debug("Table %s (%d): max_entries %u config %u",
d1241 2
a1242 1
	    ntohl(tf->tf_config));
d1445 1
a1445 1
		log_debug("\tflow length %d table_id %d duration sec %u "
d1447 7
a1453 6
		    "cookie %llu packet count %llu byte count %llu",
		    hlen, fs->fs_table_id, ntohl(fs->fs_duration_sec),
		    ntohl(fs->fs_duration_nsec), ntohs(fs->fs_priority),
		    ntohs(fs->fs_idle_timeout), ntohs(fs->fs_hard_timeout),
		    ntohs(fs->fs_flags), be64toh(fs->fs_cookie),
		    be64toh(fs->fs_packet_count), be64toh(fs->fs_byte_count));
d1493 6
a1498 3
		log_debug("\ttable features length %d tableid %d name \"%s\" "
		    "metadata match %llu write %llu config %u max_entries %u",
		    hlen, tf->tf_tableid, tf->tf_name,
d1500 1
a1500 2
		    be64toh(tf->tf_metadata_write), ntohl(tf->tf_config),
		    ntohl(tf->tf_max_entries));
d1577 2
a1578 2
		log_debug("\ttable_id %d out_port %u out_group %u "
		    "cookie %llu mask %llu match type %s length %d "
d1580 4
a1583 3
		    fsr->fsr_table_id, ntohl(fsr->fsr_out_port),
		    ntohl(fsr->fsr_out_group), be64toh(fsr->fsr_cookie),
		    be64toh(fsr->fsr_cookie_mask),
d1827 3
a1829 2
	log_debug("\tflags %#04x miss_send_len %d",
	    ntohs(cfg->cfg_flags), ntohs(cfg->cfg_miss_send_len));
@


1.31
log
@Small code improvements:
 - Free ibufs on validation failures;
 - Don't use htons() for flow-mod command;

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.30 2016/11/18 13:05:12 reyk Exp $	*/
d647 1
a647 1
	ofp13_flow_stats(sc, con, OFP_PORT_ANY, OFP_GROUP_ANY,
@


1.30
log
@Fix the flowmod header to send the correct command and buffer id.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.29 2016/11/17 16:24:00 rzalamena Exp $	*/
d1074 1
a1074 1
		fm->fm_command = htons(OFP_FLOWCMD_ADD);
d1126 1
a1126 1
		return (-1);
d1650 1
d1656 1
a1656 1
		return (-1);
d1661 3
a1663 1
		return (-1);
d1665 3
a1667 3
	ofp_output(con, NULL, ibuf);
	ibuf_release(ibuf);
	return (0);
d1679 1
a1679 1
	int				 padsize;
d1685 1
a1685 1
		return (-1);
d1687 1
a1687 1
		return (-1);
d1699 1
a1699 1
		return (-1);
d1703 3
a1705 1
		return (-1);
d1707 3
a1709 3
	ofp_output(con, NULL, ibuf);
	ibuf_release(ibuf);
	return (0);
d1719 1
d1726 1
a1726 1
		return (-1);
d1731 3
a1733 1
		return (-1);
d1735 3
a1737 3
	ofp_output(con, NULL, ibuf);
	ibuf_release(ibuf);
	return (0);
d1747 1
a1747 1
	int			 rv, dlen;
d1751 1
a1751 1
		return (-1);
d1762 1
a1762 1
		return (-1);
d1769 2
a1770 4
	    obuf) == -1) {
		ibuf_release(obuf);
		return (-1);
	}
d1773 3
a1775 1
	ibuf_release(obuf);
d1846 1
a1846 1
	int				 rv;
d1850 1
a1850 1
		return (-1);
d1861 1
a1861 1
		return (-1);
d1864 2
d1875 1
a1875 1
	int				 rv;
d1879 1
a1879 1
		return (-1);
d1886 1
a1886 1
		return (-1);
d1889 2
@


1.29
log
@Fix some styles issues: break big lines and remove some useless spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.28 2016/11/17 12:40:56 reyk Exp $	*/
d1920 5
d1927 1
@


1.28
log
@Add an abstraction layer / API to create flows including all matches
and instructions.  This makes it easier to integrate flow features in
switchd and switchctl later.

Written and committed during a long flight.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.27 2016/11/17 10:15:05 reyk Exp $	*/
d996 1
a996 1
	off_t			 	 off, moff;
d1565 2
a1566 1
	log_debug("\ttype %s flags %#04x", print_map(type, ofp_mp_t_map), flags);
d1586 2
a1587 1
		    "cookie %llu mask %llu match type %s length %d (padded to %d)",
@


1.27
log
@Accept OFP_XM_T_ETH_TYPE.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.26 2016/11/17 09:42:11 rzalamena Exp $	*/
d1927 17
a1943 25
	struct ofp_flow_mod		*fm;
	struct ofp_instruction		*oi;
	struct ibuf			*ibuf;
	size_t				 istart, iend;
	int				 padding;
	int				 rv = -1;

	if ((ibuf = ibuf_static()) == NULL)
		return (-1);

	fm = ofp13_flowmod(con, ibuf, OFP_FLOWCMD_ADD, table, 0, 0, 0);
	if (fm == NULL)
		goto done;

	padding = OFP_ALIGN(sizeof(fm->fm_match)) - sizeof(fm->fm_match);
	if (padding && ibuf_advance(ibuf, padding) == NULL)
		goto done;

	istart = ibuf->wpos;
	oi = (struct ofp_instruction *)ofp_instruction(ibuf,
	    OFP_INSTRUCTION_T_APPLY_ACTIONS,
	    sizeof(struct ofp_instruction_actions));

	if (oi == NULL ||
	    action_output(ibuf, OFP_PORT_CONTROLLER,
d1945 1
a1945 2
		goto done;
	iend = ibuf->wpos;
d1947 8
a1954 3
	/* Set header sizes. */
	oi->i_len = htons(iend - istart);
	fm->fm_oh.oh_length = htons(ibuf_length(ibuf));
d1956 2
a1957 3
	if (ofp13_validate(sc, &con->con_local, &con->con_peer, &fm->fm_oh,
	    ibuf) != 0)
		goto done;
d1959 1
a1959 1
	rv = ofp_output(con, NULL, ibuf);
d1961 3
a1963 3
 done:
	ibuf_release(ibuf);
	return (rv);
a1964 1

@


1.26
log
@Added the missing code to build flow-mod messages and to install
table-miss by default for switch(4).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.25 2016/11/07 13:27:11 rzalamena Exp $	*/
d239 9
d1970 1
@


1.25
log
@Implement support for flow-mod messages validation, this includes:
action and instructions validation.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.24 2016/11/07 13:18:18 rzalamena Exp $	*/
d107 2
d646 3
d1869 90
@


1.24
log
@Fix a small parsing error in packet-in: don't count ofp_match header bytes
when iterating over the OXMs. It only works because the last bytes are
either padding or something that looks like OXM.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.23 2016/11/04 22:33:04 reyk Exp $	*/
d56 6
d125 1
a125 1
	{ OFP_T_FLOW_MOD,		NULL, NULL },
d643 292
@


1.23
log
@Empty -> empty in log messages
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.22 2016/11/04 22:27:08 reyk Exp $	*/
d411 1
@


1.22
log
@Move ofp_output() into ofp_common.c and few function prototypes into
switchd.h.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.21 2016/10/13 08:29:14 rzalamena Exp $	*/
d1116 1
a1116 1
		log_debug("\tEmpty reply");
d1313 1
a1313 1
			log_debug("\tEmpty table properties request");
@


1.21
log
@Implement simple feature request/reply support so we can get more
information about the target switch and its datapath id. Also I
commented out some requests that are not currently being used, like
table properties, flow dump and description.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.20 2016/10/12 15:18:56 rzalamena Exp $	*/
a45 6
int	 ofp13_validate(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
	    struct ofp_header *, struct ibuf *);

int	 ofp13_hello(struct switchd *, struct switch_connection *,
	    struct ofp_header *, struct ibuf *);
a86 5
int	 ofp13_desc(struct switchd *, struct switch_connection *);
int	 ofp13_flow_stats(struct switchd *, struct switch_connection *,
	    uint32_t, uint32_t, uint8_t);
int	 ofp13_table_features(struct switchd *, struct switch_connection *,
	    uint8_t);
a100 2
int	 ofp13_featuresrequest(struct switchd *, struct switch_connection *);

@


1.20
log
@Teach switchd(8) how to send set_config to the switch so we can be able
to get packet payloads from switch(4).

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.19 2016/10/07 08:49:53 reyk Exp $	*/
d54 5
d112 2
d122 2
a123 1
	{ OFP_T_FEATURES_REPLY,		NULL, NULL },
d598 3
a600 6
	ofp13_flow_stats(sc, con, OFP_PORT_ANY, OFP_GROUP_ANY,
	    OFP_TABLE_ID_ALL);
	ofp13_table_features(sc, con, 0);
	ofp13_desc(sc, con);
	ofp13_setconfig(sc, con, OFP_CONFIG_FRAG_NORMAL,
	    OFP_CONTROLLER_MAXLEN_NO_BUFFER);
d619 35
d1548 23
@


1.19
log
@Move some shared code into a new file.

Discussed with rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.18 2016/10/07 08:31:08 rzalamena Exp $	*/
d102 6
d118 1
a118 1
	{ OFP_T_SET_CONFIG,		NULL, NULL },
d594 2
d1472 44
@


1.18
log
@Add support for multipart replies and implement a simple ofp 1.3.5 error
message sending function.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.17 2016/09/30 12:48:27 reyk Exp $	*/
a101 45
int	 action_new(struct ibuf *, uint16_t);
int	 action_group(struct ibuf *, uint32_t);
int	 action_output(struct ibuf *, uint32_t, uint16_t);
int	 action_push(struct ibuf *, uint16_t, uint16_t);
int	 action_pop_vlan(struct ibuf *);
int	 action_pop_mpls(struct ibuf *, uint16_t);
int	 action_copyttlout(struct ibuf *);
int	 action_copyttlin(struct ibuf *);
int	 action_decnwttl(struct ibuf *);
struct ofp_action_set_field *
	    action_setfield(struct ibuf *ibuf);

struct ofp_ox_match *
	    oxm_get(struct ibuf *, uint16_t, int, uint8_t);
int	 oxm_inport(struct ibuf *, uint32_t);
int	 oxm_inphyport(struct ibuf *, uint32_t);
int	 oxm_metadata(struct ibuf *, int, uint64_t, uint64_t);
int	 oxm_etheraddr(struct ibuf *, int, uint8_t *, uint8_t *);
int	 oxm_ethertype(struct ibuf *, uint16_t);
int	 oxm_vlanvid(struct ibuf *, int, uint16_t, uint16_t);
int	 oxm_vlanpcp(struct ibuf *, uint8_t);
int	 oxm_ipdscp(struct ibuf *, uint8_t);
int	 oxm_ipecn(struct ibuf *, uint8_t);
int	 oxm_ipproto(struct ibuf *, uint8_t);
int	 oxm_ipaddr(struct ibuf *, int, int, uint32_t, uint32_t);
int	 oxm_tcpport(struct ibuf *, int, uint16_t);
int	 oxm_udpport(struct ibuf *, int, uint16_t);
int	 oxm_sctpport(struct ibuf *, int, uint16_t);
int	 oxm_icmpv4type(struct ibuf *, uint8_t);
int	 oxm_icmpv4code(struct ibuf *, uint8_t);
int	 oxm_arpop(struct ibuf *, uint16_t);
int	 oxm_arpaddr(struct ibuf *, int, int, uint32_t, uint32_t);
int	 oxm_arphaddr(struct ibuf *, int, uint8_t *, uint8_t *);
int	 oxm_ipv6addr(struct ibuf *, int, struct in6_addr *, struct in6_addr *);
int	 oxm_ipv6flowlabel(struct ibuf *, int, uint32_t, uint32_t);
int	 oxm_icmpv6type(struct ibuf *, uint8_t);
int	 oxm_icmpv6code(struct ibuf *, uint8_t);
int	 oxm_ipv6ndtarget(struct ibuf *, struct in6_addr *);
int	 oxm_ipv6ndlinkaddr(struct ibuf *, int, uint8_t *);
int	 oxm_mplslabel(struct ibuf *, uint32_t);
int	 oxm_mplstc(struct ibuf *, uint8_t);
int	 oxm_mplsbos(struct ibuf *, uint8_t);
int	 oxm_tunnelid(struct ibuf *, int, uint64_t, uint64_t);
int	 oxm_ipv6exthdr(struct ibuf *, int, uint16_t, uint16_t);

a1463 838
}

/* Appends an action with just the generic header. */
int
action_new(struct ibuf *ibuf, uint16_t type)
{
	struct ofp_action_header	*ah;

	if ((ah = ibuf_advance(ibuf, sizeof(*ah))) == NULL)
		return (-1);

	ah->ah_type = htons(type);
	ah->ah_len = htons(sizeof(*ah));
	return (0);
}

int
action_group(struct ibuf *ibuf, uint32_t group)
{
	struct ofp_action_group		*ag;

	if ((ag = ibuf_advance(ibuf, sizeof(*ag))) == NULL)
		return (-1);

	ag->ag_type = htons(OFP_ACTION_GROUP);
	ag->ag_len = sizeof(*ag);
	ag->ag_group_id = htonl(group);
	return (0);
}

int
action_output(struct ibuf *ibuf, uint32_t port, uint16_t maxlen)
{
	struct ofp_action_output	*ao;

	if ((ao = ibuf_advance(ibuf, sizeof(*ao))) == NULL)
		return (-1);

	ao->ao_type = htons(OFP_ACTION_OUTPUT);
	ao->ao_len = htons(sizeof(*ao));
	ao->ao_port = htonl(port);
	ao->ao_max_len = htons(maxlen);
	return (0);
}

/*
 * This action pushes VLAN/MPLS/PBB tags into the outermost part of the
 * packet. When the type is X ethertype must be Y:
 * - OFP_ACTION_PUSH_VLAN: ETHERTYPE_VLAN or ETHERTYPE_QINQ.
 * - OFP_ACTION_PUSH_MPLS: ETHERTYPE_MPLS or ETHERTYPE_MPLSCAST.
 * - OFP_ACTION_PUSH_PBB: ETHERTYPE_??? (0x88E7).
 */
int
action_push(struct ibuf *ibuf, uint16_t type, uint16_t ethertype)
{
	struct ofp_action_push		*ap;

	if ((ap = ibuf_advance(ibuf, sizeof(*ap))) == NULL)
		return (-1);

	ap->ap_type = htons(type);
	ap->ap_len = htons(sizeof(*ap));
	ap->ap_ethertype = htons(ethertype);
	return (0);
}

/* 
 * This action only pops the outermost VLAN tag and only one at a time,
 * you can only pop multiple VLANs with an action list that is only
 * availiable for OFP_INSTRUCTION_T_APPLY_ACTIONS.
 */
int
action_pop_vlan(struct ibuf *ibuf)
{
	return (action_new(ibuf, OFP_ACTION_POP_VLAN));
}

/*
 * Use this with caution since this will pop MPLS shim regardless of the
 * BoS bit state.
 */
int
action_pop_mpls(struct ibuf *ibuf, uint16_t ethertype)
{
	struct ofp_action_pop_mpls	*apm;

	if ((apm = ibuf_advance(ibuf, sizeof(*apm))) == NULL)
		return (-1);

	apm->apm_type = htons(OFP_ACTION_POP_MPLS);
	apm->apm_len = htons(sizeof(*apm));
	apm->apm_ethertype = htons(ethertype);
	return (0);
}

int
action_copyttlout(struct ibuf *ibuf)
{
	return (action_new(ibuf, OFP_ACTION_COPY_TTL_OUT));
}

int
action_copyttlin(struct ibuf *ibuf)
{
	return (action_new(ibuf, OFP_ACTION_COPY_TTL_IN));
}

int
action_decnwttl(struct ibuf *ibuf)
{
	return (action_new(ibuf, OFP_ACTION_DEC_NW_TTL));
}

/*
 * This function should be used with the oxm_*() family.
 *
 * After filling the action_setfield() with oxms you have to set the
 * asf_len with htons(size_of_oxms).
 */
struct ofp_action_set_field *
action_setfield(struct ibuf *ibuf)
{
	struct ofp_action_set_field	*asf;

	if ((asf = ibuf_advance(ibuf, sizeof(*asf))) == NULL)
		return (NULL);

	asf->asf_type = htons(OFP_ACTION_SET_FIELD);
	return (asf);
}

struct ofp_ox_match *
oxm_get(struct ibuf *ibuf, uint16_t field, int hasmask, uint8_t len)
{
	struct ofp_ox_match	*oxm;
	size_t			 oxmlen;

	/*
	 * When the mask is used we must always reserve double the space,
	 * because the mask field is the same size of the value.
	 */
	if (hasmask)
		len = len * 2;

	oxmlen = sizeof(*oxm) + len;
	if ((oxm = ibuf_advance(ibuf, oxmlen)) == NULL)
		return (NULL);

	oxm->oxm_class = htons(OFP_OXM_C_OPENFLOW_BASIC);
	oxm->oxm_length = len;
	OFP_OXM_SET_FIELD(oxm, field);
	if (hasmask)
		OFP_OXM_SET_HASMASK(oxm);

	return (oxm);
}

/*
 * OpenFlow port where the packet where received.
 * May be a physical port, a logical port or the reserved port OFPP_LOCAL.
 */
int
oxm_inport(struct ibuf *ibuf, uint32_t in_port)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_IN_PORT, 0,
	    sizeof(in_port))) == NULL)
		return (-1);

	in_port = htonl(in_port);
	memcpy(oxm->oxm_value, &in_port, sizeof(in_port));
	return (0);
}

/*
 * Physical port on which the packet was received.
 * Requires: oxm_inport.
 */
int
oxm_inphyport(struct ibuf *ibuf, uint32_t in_phy_port)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_IN_PHY_PORT, 0,
	    sizeof(in_phy_port))) == NULL)
		return (-1);

	in_phy_port = htonl(in_phy_port);
	memcpy(oxm->oxm_value, &in_phy_port, sizeof(in_phy_port));
	return (0);
}

/* Table metadata. */
int
oxm_metadata(struct ibuf *ibuf, int hasmask, uint64_t metadata, uint64_t mask)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_META, hasmask,
	    sizeof(metadata))) == NULL)
		return (-1);

	metadata = htobe64(metadata);
	memcpy(oxm->oxm_value, &metadata, sizeof(metadata));
	if (hasmask) {
		mask = htobe64(mask);
		memcpy(oxm->oxm_value + sizeof(metadata), &mask, sizeof(mask));
	}

	return (0);
}

int
oxm_etheraddr(struct ibuf *ibuf, int issrc, uint8_t *addr, uint8_t *mask)
{
	struct ofp_ox_match	*oxm;
	int			 type;
	int			 hasmask = (mask != NULL);

	type = issrc ? OFP_XM_T_ETH_SRC : OFP_XM_T_ETH_DST;
	if ((oxm = oxm_get(ibuf, type, hasmask, ETHER_ADDR_LEN)) == NULL)
		return (-1);

	memcpy(oxm->oxm_value, addr, ETHER_ADDR_LEN);
	if (hasmask)
		memcpy(oxm->oxm_value + ETHER_ADDR_LEN, mask, ETHER_ADDR_LEN);

	return (0);
}

int
oxm_ethertype(struct ibuf *ibuf, uint16_t type)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_ETH_TYPE, 0, sizeof(type))) == NULL)
		return (-1);

	type = htons(type);
	memcpy(oxm->oxm_value, &type, sizeof(type));
	return (0);
}

int
oxm_vlanvid(struct ibuf *ibuf, int hasmask, uint16_t vid, uint16_t mask)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_VLAN_VID, hasmask,
	    sizeof(vid))) == NULL)
		return (-1);

	/* VID uses only the 13 least significant bits. */
	vid &= 0x1fff;
	vid = htons(vid);
	memcpy(oxm->oxm_value, &vid, sizeof(vid));
	if (hasmask) {
		mask &= 0x1fff;
		mask = htons(mask);
		memcpy(oxm->oxm_value + sizeof(vid), &mask, sizeof(mask));
	}

	return (0);
}

/*
 * 802.1Q Prio from the outermost tag.
 *
 * Requires: oxm_vlanvid.
 */
int
oxm_vlanpcp(struct ibuf *ibuf, uint8_t pcp)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_VLAN_PCP, 0, sizeof(pcp))) == NULL)
		return (-1);

	/* PCP only uses the lower 3 bits. */
	pcp &= 0x07;
	memcpy(oxm->oxm_value, &pcp, sizeof(pcp));
	return (0);
}

/*
 * The Diff Serv Code Point (DSCP) bits avaliable in IPv4 ToS field or
 * IPv6 Traffic Class field.
 *
 * Requires: oxm_ethertype(ETHERTYPE_IP) or oxm_ethertype(ETHERTYPE_IPV6).
 */
int
oxm_ipdscp(struct ibuf *ibuf, uint8_t dscp)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_IP_DSCP, 0, sizeof(dscp))) == NULL)
		return (-1);

	/* Only the 6 lower bits have meaning. */
	dscp &= 0x3F;
	memcpy(oxm->oxm_value, &dscp, sizeof(dscp));
	return (0);
}

/*
 * The ECN (Explicit Congestion Notification) bits of IP headers.
 *
 * Requires: oxm_ethertype(ETHERTYPE_IP) or oxm_ethertype(ETHERTYPE_IPV6).
 */
int
oxm_ipecn(struct ibuf *ibuf, uint8_t ecn)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_IP_ECN, 0, sizeof(ecn))) == NULL)
		return (-1);

	/* Only the 2 most significant bits have meaning. */
	ecn &= 0x03;
	memcpy(oxm->oxm_value, &ecn, sizeof(ecn));
	return (0);
}

/*
 * The IP protocol byte.
 *
 * Requires: oxm_ethertype(ETHERTYPE_IP) or oxm_ethertype(ETHERTYPE_IPV6).
 */
int
oxm_ipproto(struct ibuf *ibuf, uint8_t proto)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_IP_PROTO, 0, sizeof(proto))) == NULL)
		return (-1);

	memcpy(oxm->oxm_value, &proto, sizeof(proto));
	return (0);
}

/*
 * The IPv4 address source/destination.
 *
 * Requires: oxm_ethertype(ETHERTYPE_IP).
 */
int
oxm_ipaddr(struct ibuf *ibuf, int issrc, int hasmask, uint32_t addr,
    uint32_t mask)
{
	struct ofp_ox_match	*oxm;
	int			 type;

	type = issrc ? OFP_XM_T_IPV4_SRC : OFP_XM_T_IPV4_DST;
	if ((oxm = oxm_get(ibuf, type, hasmask, sizeof(addr))) == NULL)
		return (-1);

	addr = htonl(addr);
	memcpy(oxm->oxm_value, &addr, sizeof(addr));
	if (hasmask) {
		mask = htonl(mask);
		memcpy(oxm->oxm_value + sizeof(addr), &mask, sizeof(mask));
	}

	return (0);
}

/*
 * The TCP source/destination port.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_IP) or oxm_ethertype(ETHERTYPE_IPV6)
 * and oxm_ipproto(IPPROTO_TCP).
 */
int
oxm_tcpport(struct ibuf *ibuf, int issrc, uint16_t port)
{
	struct ofp_ox_match	*oxm;
	int			 type;

	type = issrc ? OFP_XM_T_TCP_SRC : OFP_XM_T_TCP_DST;
	if ((oxm = oxm_get(ibuf, type, 0, sizeof(port))) == NULL)
		return (-1);

	port = htons(port);
	memcpy(oxm->oxm_value, &port, sizeof(port));
	return (0);
}

/*
 * The UDP source/destination port.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_IP) or oxm_ethertype(ETHERTYPE_IPV6)
 * and oxm_ipproto(IPPROTO_UDP).
 */
int
oxm_udpport(struct ibuf *ibuf, int issrc, uint16_t port)
{
	struct ofp_ox_match	*oxm;
	int			 type;

	type = issrc ? OFP_XM_T_UDP_SRC : OFP_XM_T_UDP_DST;
	if ((oxm = oxm_get(ibuf, type, 0, sizeof(port))) == NULL)
		return (-1);

	port = htons(port);
	memcpy(oxm->oxm_value, &port, sizeof(port));
	return (0);
}

/*
 * The SCTP source/destination port.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_IP) or oxm_ethertype(ETHERTYPE_IPV6)
 * and oxm_ipproto(IPPROTO_??? -- 132).
 */
int
oxm_sctpport(struct ibuf *ibuf, int issrc, uint16_t port)
{
	struct ofp_ox_match	*oxm;
	int			 type;

	type = issrc ? OFP_XM_T_SCTP_SRC : OFP_XM_T_SCTP_DST;
	if ((oxm = oxm_get(ibuf, type, 0, sizeof(port))) == NULL)
		return (-1);

	port = htons(port);
	memcpy(oxm->oxm_value, &port, sizeof(port));
	return (0);
}

/*
 * The ICMPv4 type in the ICMP header.
 *
 * Requires: oxm_ethertype(ETHERTYPE_IP) and oxm_ipproto(IPPROTO_ICMP).
 */
int
oxm_icmpv4type(struct ibuf *ibuf, uint8_t type)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_ICMPV4_TYPE, 0,
	    sizeof(type))) == NULL)
		return (-1);

	memcpy(oxm->oxm_value, &type, sizeof(type));
	return (0);
}

/*
 * The ICMPv4 code in the ICMP header.
 *
 * Requires: oxm_ethertype(ETHERTYPE_IP) and oxm_ipproto(IPPROTO_ICMP).
 */
int
oxm_icmpv4code(struct ibuf *ibuf, uint8_t code)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_ICMPV4_CODE, 0,
	    sizeof(code))) == NULL)
		return (-1);

	memcpy(oxm->oxm_value, &code, sizeof(code));
	return (0);
}

/*
 * ARP opcode.
 *
 * Requires: oxm_ethertype(ETHERTYPE_ARP).
 */
int
oxm_arpop(struct ibuf *ibuf, uint16_t op)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_ARP_OP, 0, sizeof(op))) == NULL)
		return (-1);

	op = htons(op);
	memcpy(oxm->oxm_value, &op, sizeof(op));
	return (0);
}

/*
 * ARP source/target protocol address.
 *
 * Requires: oxm_ethertype(ETHERTYPE_ARP).
 */
int
oxm_arpaddr(struct ibuf *ibuf, int issrc, int hasmask, uint32_t addr,
    uint32_t mask)
{
	struct ofp_ox_match	*oxm;
	int			 type;

	type = issrc ? OFP_XM_T_ARP_SPA : OFP_XM_T_ARP_TPA;
	if ((oxm = oxm_get(ibuf, type, hasmask, sizeof(addr))) == NULL)
		return (-1);

	addr = htonl(addr);
	memcpy(oxm->oxm_value, &addr, sizeof(addr));
	if (hasmask) {
		mask = htonl(mask);
		memcpy(oxm->oxm_value + sizeof(addr), &mask, sizeof(mask));
	}

	return (0);
}

/*
 * ARP source/target hardware address.
 *
 * Requires: oxm_ethertype(ETHERTYPE_ARP).
 */
int
oxm_arphaddr(struct ibuf *ibuf, int issrc, uint8_t *addr, uint8_t *mask)
{
	struct ofp_ox_match	*oxm;
	int			 type;
	int			 hasmask = (mask != NULL);

	type = issrc ? OFP_XM_T_ARP_SHA : OFP_XM_T_ARP_THA;
	if ((oxm = oxm_get(ibuf, type, hasmask, ETHER_ADDR_LEN)) == NULL)
		return (-1);

	memcpy(oxm->oxm_value, addr, ETHER_ADDR_LEN);
	if (hasmask)
		memcpy(oxm->oxm_value + ETHER_ADDR_LEN, mask, ETHER_ADDR_LEN);

	return (0);
}

/*
 * The source or destination of the IPv6 address.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_IPV6).
 */
int
oxm_ipv6addr(struct ibuf *ibuf, int issrc, struct in6_addr *addr,
    struct in6_addr *mask)
{
	struct ofp_ox_match	*oxm;
	int			 type;
	int			 hasmask = (mask != NULL);

	type = issrc ? OFP_XM_T_IPV6_SRC : OFP_XM_T_IPV6_DST;
	if ((oxm = oxm_get(ibuf, type, hasmask, sizeof(*addr))) == NULL)
		return (-1);

	memcpy(oxm->oxm_value, addr, sizeof(*addr));
	if (hasmask)
		memcpy(oxm->oxm_value + sizeof(*addr), mask, sizeof(*mask));

	return (0);
}

/*
 * The IPv6 flow label field.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_IPV6).
 */
int
oxm_ipv6flowlabel(struct ibuf *ibuf, int hasmask, uint32_t flowlabel,
    uint32_t mask)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_IPV6_FLABEL, hasmask,
	    sizeof(flowlabel))) == NULL)
		return (-1);

	/*
         * 12 most significants bits forced to 0 and only the 20 lowers
         * bits have meaning.
	 */
	flowlabel &= 0x000FFFFFU;
	flowlabel = htonl(flowlabel);
	memcpy(oxm->oxm_value, &flowlabel, sizeof(flowlabel));
	if (hasmask) {
		mask &= 0x000FFFFFU;
		mask = htonl(mask);
		memcpy(oxm->oxm_value + sizeof(flowlabel), &mask, sizeof(mask));
	}

	return (0);
}

/*
 * The ICMPv6 type in ICMP header.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_IPV6) and oxm_ipproto(IPPROTO_ICMPV6).
 */
int
oxm_icmpv6type(struct ibuf *ibuf, uint8_t type)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_ICMPV6_TYPE, 0,
	    sizeof(type))) == NULL)
		return (-1);

	memcpy(oxm->oxm_value, &type, sizeof(type));
	return (0);
}

/*
 * The ICMPv6 code in ICMP header.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_IPV6) and oxm_ipproto(IPPROTO_ICMPV6).
 */
int
oxm_icmpv6code(struct ibuf *ibuf, uint8_t code)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_ICMPV6_CODE, 0,
	    sizeof(code))) == NULL)
		return (-1);

	memcpy(oxm->oxm_value, &code, sizeof(code));
	return (0);
}

/*
 * The target address in neighbour discovery message.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_IPV6), oxm_ipproto(IPPROTO_ICMPV6)
 * and oxm_icmpv6type(ND_NEIGHBOR_SOLICIT) or
 * oxm_icmpv6type(ND_NEIGHBOR_ADVERT).
 */
int
oxm_ipv6ndtarget(struct ibuf *ibuf, struct in6_addr *addr)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_IPV6_ND_TARGET, 0,
	    sizeof(*addr))) == NULL)
		return (-1);

	memcpy(oxm->oxm_value, addr, sizeof(*addr));
	return (0);
}

/*
 * The source link-layer address in an IPv6 Neighbour discovery.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_IPV6), oxm_ipproto(IPPROTO_ICMPV6)
 * and oxm_icmpv6type(ND_NEIGHBOR_SOLICIT).
 */
int
oxm_ipv6ndlinkaddr(struct ibuf *ibuf, int issrc, uint8_t *addr)
{
	struct ofp_ox_match	*oxm;
	int			 type;

	type = issrc ? OFP_XM_T_IPV6_ND_SLL : OFP_XM_T_IPV6_ND_TLL;
	if ((oxm = oxm_get(ibuf, type, 0, ETHER_ADDR_LEN)) == NULL)
		return (-1);

	memcpy(oxm->oxm_value, addr, ETHER_ADDR_LEN);
	return (0);
}

/*
 * The label in the MPLS shim.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_MPLS) or
 * oxm_ethertype(ETHERTYPE_MPLS_MCAST).
 */
int
oxm_mplslabel(struct ibuf *ibuf, uint32_t label)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_MPLS_LABEL, 0,
	    sizeof(label))) == NULL)
		return (-1);

	label &= MPLS_LABEL_MASK;
	label = htonl(label);
	memcpy(oxm->oxm_value, &label, sizeof(label));
	return (0);
}

/*
 * The TC in the first MPLS shim.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_MPLS) or
 * oxm_ethertype(ETHERTYPE_MPLS_MCAST).
 */
int
oxm_mplstc(struct ibuf *ibuf, uint8_t tc)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_MPLS_TC, 0, sizeof(tc))) == NULL)
		return (-1);

	tc &= 0x07;
	memcpy(oxm->oxm_value, &tc, sizeof(tc));
	return (0);
}

/*
 * The BoS bit in the first MPLS shim.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_MPLS) or
 * oxm_ethertype(ETHERTYPE_MPLS_MCAST).
 */
int
oxm_mplsbos(struct ibuf *ibuf, uint8_t bos)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_MPLS_BOS, 0, sizeof(bos))) == NULL)
		return (-1);

	bos &= 0x01;
	memcpy(oxm->oxm_value, &bos, sizeof(bos));
	return (0);
}

/*
 * Comment shamelessly taken from OpenFlow 1.3.5 specification.
 *
 * Metadata associated with a logical port.
 *
 * If the logical port performs encapsulation and decapsulation, this
 * is the demultiplexing field from the encapsulation header.
 * For example, for a packet received via GRE tunnel including a (32-bit) key,
 * the key is stored in the low 32-bits and the high bits are zeroed.
 * For a MPLS logical port, the low 20 bits represent the MPLS Label.
 * For a VxLAN logical port, the low 24 bits represent the VNI.
 * If the packet is not received through a logical port, the value is 0.
 */
int
oxm_tunnelid(struct ibuf *ibuf, int hasmask, uint64_t id, uint64_t mask)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_TUNNEL_ID, hasmask,
	    sizeof(id))) == NULL)
		return (-1);

	id = htobe64(id);
	memcpy(oxm->oxm_value, &id, sizeof(id));
	if (hasmask) {
		mask = htobe64(mask);
		memcpy(oxm->oxm_value + sizeof(id), &mask, sizeof(mask));
	}
	return (0);
}

/*
 * The IPv6 extension header.
 *
 * Tip: use the OFP_XM_IPV6_EXTHDR_* macros.
 *
 * Requirements: oxm_ethertype(ETHERTYPE_IPV6).
 */
int
oxm_ipv6exthdr(struct ibuf *ibuf, int hasmask, uint16_t exthdr, uint16_t mask)
{
	struct ofp_ox_match	*oxm;

	if ((oxm = oxm_get(ibuf, OFP_XM_T_IPV6_EXTHDR, hasmask,
	    sizeof(exthdr))) == NULL)
		return (-1);

	/* Only the lower 9 bits have meaning. */
	exthdr &= 0x01FF;
	exthdr = htons(exthdr);
	memcpy(oxm->oxm_value, &exthdr, sizeof(exthdr));
	if (hasmask) {
		mask &= 0x01FF;
		mask = htons(mask);
		memcpy(oxm->oxm_value + sizeof(exthdr), &mask, sizeof(mask));
	}
	return (0);
}

int
ofp_multipart_add(struct switch_connection *con, uint32_t xid, uint8_t type)
{
	struct multipart_message	*mm;

	/* A multipart reply have the same xid and type in all parts. */
	SLIST_FOREACH(mm, &con->con_mmlist, mm_entry) {
		if (mm->mm_xid != xid)
			continue;
		if (mm->mm_type != type)
			return (-1);

		return (0);
	}

	if ((mm = calloc(1, sizeof(*mm))) == NULL)
		return (-1);

	mm->mm_xid = xid;
	mm->mm_type = type;
	SLIST_INSERT_HEAD(&con->con_mmlist, mm, mm_entry);
	return (0);
}

void
ofp_multipart_del(struct switch_connection *con, uint32_t xid)
{
	struct multipart_message	*mm;

	SLIST_FOREACH(mm, &con->con_mmlist, mm_entry)
		if (mm->mm_xid == xid)
			break;

	if (mm == NULL)
		return;

	ofp_multipart_free(con, mm);
}

void
ofp_multipart_free(struct switch_connection *con,
    struct multipart_message *mm)
{
	SLIST_REMOVE(&con->con_mmlist, mm, multipart_message, mm_entry);
	free(mm);
}

void
ofp_multipart_clear(struct switch_connection *con)
{
	struct multipart_message	*mm;

	while (!SLIST_EMPTY(&con->con_mmlist)) {
		mm = SLIST_FIRST(&con->con_mmlist);
		ofp_multipart_free(con, mm);
	}
@


1.17
log
@Remove local copy of ofp.h and use net/ofp.h instead
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.16 2016/09/30 11:57:57 reyk Exp $	*/
a56 2
int	 ofp13_error(struct switchd *, struct switch_connection *,
	    struct ofp_header *, struct ibuf *);
d93 2
d1051 1
a1051 1
	int				 readlen, type;
a1056 5
	if (mp->mp_flags & OFP_MP_FLAG_REPLY_MORE) {
		/* TODO support multiple fragments. */
		return (-1);
	}

d1058 1
d1061 19
d1427 39
d2289 58
@


1.16
log
@Implement socket server code that properly handles async I/O, partial
messages, multiple messages per buffer and important things like
connection limits and file descriptor accounting.  It works with TCP
connections as well as switch(4).  The ofrelay.c part replaces
networking that was in ofp.c and will soon handle all socket
connections of switchd.  It is called "ofrelay" because it will be
used as client, server, and forwarder.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.15 2016/09/29 18:25:54 reyk Exp $	*/
d26 2
a42 1
#include "ofp.h"
@


1.15
log
@Rename ofp_send to ofp_output
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.14 2016/09/29 18:16:50 rzalamena Exp $	*/
d598 1
a598 1
		log_debug("message not supported: %s",
d602 3
a604 1
	if (ofp13_callbacks[oh->oh_type].cb(sc, con, oh, ibuf) != 0)
d606 1
a616 1
		ofp_close(con);
@


1.14
log
@Teach switchd(8) how to request flow entries and how to validate the
request/reply. With this we get the OXM type/value printing for all
directions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.13 2016/09/29 15:10:23 rzalamena Exp $	*/
d624 1
a624 1
	ofp_send(con, oh, NULL);
d642 1
a642 1
	ofp_send(con, oh, NULL);
d822 1
a822 1
	ofp_send(con, NULL, obuf);
d1339 1
a1339 1
	ofp_send(con, NULL, ibuf);
d1379 1
a1379 1
	ofp_send(con, NULL, ibuf);
d1404 1
a1404 1
	ofp_send(con, NULL, ibuf);
@


1.13
log
@Use the macro OFP_ALIGN() to find alignment instead of rolling my own way.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.12 2016/09/29 13:30:48 rzalamena Exp $	*/
d58 1
d90 2
d207 177
d389 1
a389 2
	uint32_t	 port;
	void		*ptr;
d396 1
d398 1
d400 1
a400 1
	log_debug("\tox match class %s type %s length %u",
d403 1
d407 5
d413 4
a416 9
		switch (type) {
		case OFP_XM_T_IN_PORT:
			off += sizeof(*oxm);
			if ((ptr = ibuf_seek(ibuf, off, sizeof(port))) == NULL)
				return (-1);
			port = *(uint32_t *)ptr;
			log_debug("\t\tport %u", ntohl(port));
			break;
		}
d418 3
d626 2
d1086 1
d1088 2
d1091 2
a1092 2
	int				 remaining;
	off_t				 off;
d1126 38
d1231 4
a1234 1
	off_t				 off;
d1236 1
d1257 34
d1336 40
@


1.12
log
@Teach switchd(8) how to ask for and debug equipment description
requests / replies.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.11 2016/09/29 13:04:50 rzalamena Exp $	*/
a463 1
	int			 unalignedsize;
d477 1
a477 5
	unalignedsize = (omlen % 8);
	if (unalignedsize)
		padsize = 8 - unalignedsize;
	else
		padsize = 0;
@


1.11
log
@Teach switchd(8) some multipart table properties request/parse code to
handle basic display.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.10 2016/09/28 17:48:35 rzalamena Exp $	*/
d88 1
d442 1
d904 1
d929 11
d1024 5
d1057 23
@


1.10
log
@Always ask the switch to send the whole packet unbuffered so we can
analyze the content of the packet and not truncate it when sending
packet_out.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.9 2016/09/27 22:27:38 reyk Exp $	*/
d68 9
d81 10
d162 4
a165 2
	{ OFP_T_MULTIPART_REQUEST,	NULL, NULL },
	{ OFP_T_MULTIPART_REPLY,	NULL, NULL },
d219 1
a219 1
	    print_map(class, ofp_oxm_map),
d440 2
d691 372
@


1.9
log
@Fix previous: don't attempt to write a NULL packet to the tap device.
Also print a debug message if the packet has been truncated by the switch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.8 2016/09/27 19:40:43 reyk Exp $	*/
d579 2
a580 1
		    action_output(obuf, dstport, 0) == -1)
d596 2
a597 1
		if (action_output(obuf, dstport, 0) == -1)
@


1.8
log
@OpenFlow PACKET_IN can send truncated packets; this only makes sense
if the switch buffers packets, otherwise we might end up forwarding
truncated packets to the network with the PACKET_OUT response.  So,
for now, only close the connection if the packet is not buffered by
the switch but truncated.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.7 2016/09/26 12:33:04 rzalamena Exp $	*/
d228 1
a228 1
	ssize_t			 len, mlen;
a267 1
	/* Calculate offset from the beginning */
d269 6
a274 2
	if ((p = ibuf_seek(ibuf, off, len)) == NULL) {
		/* Buffer packets can be truncated */
d276 1
a276 1
			len = ibuf_length(ibuf) - off;
d280 2
d284 1
@


1.7
log
@Teach switchd(8) how to create flows for new connections using OpenFlow
1.3.5, implement the OXM filters to use with flow matching and Set-Action,
prepare code to receive group management and add dummy flow_removed handler
to avoid closing the connection on idle flows.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.6 2016/09/26 08:46:00 rzalamena Exp $	*/
d270 7
a276 2
	if ((p = ibuf_seek(ibuf, off, len)) == NULL)
		return (-1);
@


1.6
log
@Enable more debug messages to help developing flow modification messages.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.5 2016/07/21 14:25:36 reyk Exp $	*/
d5 1
d29 1
d31 1
a48 2
int	 ofp13_packet_match(struct packet *, struct ofp_match *, unsigned int);

d63 1
d66 2
d72 51
d136 1
a136 1
	{ OFP_T_FLOW_REMOVED,		NULL, NULL },
d425 1
a425 1
ofp13_packet_match(struct packet *pkt, struct ofp_match *m, uint32_t flags)
a426 1
#if 0
d428 5
d434 6
a439 2
	bzero(m, sizeof(*m));
	m->m_wildcards = htonl(~flags);
d441 10
a450 1
	if ((flags & (OFP_WILDCARD_DL_SRC|OFP_WILDCARD_DL_DST)) && (eh == NULL))
a452 5
	if (flags & OFP_WILDCARD_DL_SRC)
		memcpy(m->m_dl_src, eh->ether_shost, ETHER_ADDR_LEN);
	if (flags & OFP_WILDCARD_DL_DST)
		memcpy(m->m_dl_dst, eh->ether_dhost, ETHER_ADDR_LEN);
#endif
a461 2
	struct ofp_action_output	*ao;
#if 0
a462 1
#endif
d471 1
a471 2
	int				 addflow = 0;
	int				 addpacket = 0;
d474 1
d479 4
d538 1
a538 1
		addflow = 0;
a544 1
#if 0
a547 2
		ofp13_packet_match(&pkt, &fm->fm_match, OFP_WILDCARD_DL_DST);

d556 18
a573 3
		if (pin->pin_buffer_id == (uint32_t)-1)
			addpacket = 1;
#endif
d581 5
a585 1
		pout->pout_actions_len = htons(sizeof(*ao));
d587 4
a590 2
		if (pin->pin_buffer_id == (uint32_t)-1)
			addpacket = 1;
a592 12
	if ((ao = ibuf_advance(obuf, sizeof(*ao))) == NULL)
		goto done;
	ao->ao_type = htons(OFP_ACTION_OUTPUT);
	ao->ao_len =  htons(sizeof(*ao));
	ao->ao_port = htonl(dstport);
	ao->ao_max_len = 0;

	/* Add optional packet payload */
	if (addpacket &&
	    imsg_add(obuf, pkt.pkt_buf, pkt.pkt_len) == -1)
		goto done;

d594 1
a594 1
	memcpy(oh, ih, sizeof(*oh));
d604 3
a606 1
	if (addflow && addpacket) {
d608 1
a608 1
		addflow = 0;
d618 863
@


1.5
log
@Add basic support for OpenFlow 1.3 PACKET_IN+PACKET_OUT,
no FLOW_MOD yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.4 2016/07/21 07:58:44 reyk Exp $	*/
d293 9
@


1.4
log
@Turn ofp*_debug functions into ofp*_validate functions to follow a
similar approach like iked: first validate the packet, then parse it,
and execute actions.  debug logging is a side effect of validation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.3 2016/07/20 19:57:54 reyk Exp $	*/
d244 1
a244 1
	    ntohl(pout->pout_actions_len));
a383 1
#if 0
d387 1
d389 1
d391 2
d396 2
a397 2
	size_t				 len;
	long				 srcport, dstport;
d400 2
a407 1
	srcport = ntohs(pin->pin_port);
d409 40
a448 2
	if ((dstport = packet_input(sc, con->con_switch,
	    srcport, ibuf, len, &pkt)) == -1 ||
d461 1
a461 1
		addflow = 1;
d468 1
d484 1
d491 1
a491 1
		pout->pout_port = pin->pin_port;
d502 1
a502 1
	ao->ao_port = htons((uint16_t)dstport);
a532 3
#else
	return (0);
#endif
@


1.3
log
@Parse and print OpenFlow 1.3 PACKET_IN and OXM (Openflow eXtended Match) -
no action yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.2 2016/07/20 14:15:08 reyk Exp $	*/
d42 6
d52 2
a53 1
int	 ofp13_packet_in(struct switchd *, struct switch_connection *,
d57 1
a57 10

int	 ofp13_packet_match(struct packet *, struct ofp_match *, unsigned int);

void	 ofp13_debug(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
	    struct ofp_header *, struct ibuf *);
void	 ofp13_debug_header(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
	    struct ofp_header *);
int	 ofp13_debug_oxm(struct switchd *, struct ofp_ox_match *,
d59 1
a59 1
int	 ofp13_debug_packet_in(struct switchd *,
d62 1
a62 2
int	 ofp13_debug_packet_out(struct switchd *,
	    struct sockaddr_storage *, struct sockaddr_storage *,
d64 1
a64 1
int	 ofp13_debug_error(struct switchd *,
d70 1
a70 1
	{ OFP_T_ERROR,			NULL, ofp13_debug_error },
d79 2
a80 1
	{ OFP_T_PACKET_IN,		ofp13_packet_in, ofp13_debug_packet_in },
d83 1
a83 1
	{ OFP_T_PACKET_OUT,		NULL, ofp13_debug_packet_out },
d102 2
a103 15
void
ofp13_debug_header(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh)
{
	log_debug("%s > %s: version %s type %s length %u xid %u",
	    print_host(src, NULL, 0),
	    print_host(dst, NULL, 0),
	    print_map(oh->oh_version, ofp_v_map),
	    print_map(oh->oh_type, ofp_t_map),
	    ntohs(oh->oh_length), ntohl(oh->oh_xid));
}

void
ofp13_debug(struct switchd *sc,
d107 1
a107 1
	ofp13_debug_header(sc, src, dst, oh);
d109 15
a123 11
	if (ibuf == NULL ||
	    oh->oh_version != OFP_V_1_3 ||
	    oh->oh_type >= OFP_T_TYPE_MAX ||
	    ofp13_callbacks[oh->oh_type].debug == NULL)
		return;
	if (ofp13_callbacks[oh->oh_type].debug(sc, src, dst, oh, ibuf) != 0)
		goto fail;

	return;
 fail:
	log_debug("\tinvalid packet");
d127 2
a128 2
ofp13_debug_oxm(struct switchd *sc, struct ofp_ox_match *oxm,
   struct ofp_header *oh, struct ibuf *ibuf, off_t off)
d165 1
a165 1
ofp13_debug_packet_in(struct switchd *sc,
d202 1
a202 1
			if (ofp13_debug_oxm(sc, oxm, oh, ibuf, moff) == -1)
d223 1
a223 1
ofp13_debug_packet_out(struct switchd *sc,
d275 1
a275 1
ofp13_debug_error(struct switchd *sc,
d312 1
a312 5
	ofp13_debug(sc, &con->con_peer, &con->con_local, oh, ibuf);

	if (oh->oh_version != OFP_V_1_3 ||
	    oh->oh_type >= OFP_T_TYPE_MAX) {
		log_debug("unsupported packet");
a313 1
	}
d330 1
a330 2
	if (oh->oh_version == OFP_V_1_3 &&
	    switch_add(con) == NULL) {
d340 2
a342 1
	ofp13_debug(sc, &con->con_local, &con->con_peer, oh, NULL);
d353 2
a354 1
	ofp13_debug(sc, &con->con_local, &con->con_peer, oh, NULL);
d472 2
a473 1
	ofp13_debug(sc, &con->con_local, &con->con_peer, oh, obuf);
@


1.2
log
@Update OpenFlow 1.3 stub based on the 1.0 code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp13.c,v 1.2 2016/07/19 18:11:08 reyk Exp $	*/
d31 1
d59 2
d138 38
d181 2
d184 2
a185 2
	size_t			 len;
	off_t			 off;
d196 29
a225 1
	off += sizeof(*pin);
@


1.1
log
@Import switchd(8), a basic WIP OpenFlow implementation for OpenBSD.

switchd consists of two parts:
1. switchd(8) and switchctl(8), an OpenFlow controller or "vswitch".
2. switch(4), an OpenFlow-aware kernel "bridge".

This the 1st part, the driver will be imported later.  The code will
remain disabled for a while, but it helps development to have it in
the tree.  switchd currently supports partial OpenFlow 1.0, but the
goal is to use OpenFlow 1.3.5 instead (switch(4) already does 1.3.5).

For more background information see:
http://www.openbsd.org/papers/bsdcan2016-switchd.pdf
https://youtu.be/Cuo0qT-lqig

With help from yasuoka@@ goda@@
Import discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a18 2
/* XXX not implemented, this is just a stub */

d23 2
d26 1
a37 1
#include "ofp10.h"
d39 74
d119 21
a139 2
	struct ofp_packet_in	 pin;
#if 0
a140 2
#endif
	uint8_t			*buf;
d142 37
d180 30
a209 2
	len = ibuf_length(ibuf);
	buf = ibuf_data(ibuf);
d211 2
a212 1
	ofp10_debug_header(sc, src, dst, oh);
d214 15
a228 2
	if (oh->oh_version != OFP_V_1_3)
		return;
d230 6
a235 23
	switch (oh->oh_type) {
	case OFP_T_PACKET_IN:
		if (len < sizeof(pin))
			goto fail;
		memcpy(&pin, buf, sizeof(pin));
#if 0
		log_debug("\tbuffer %d port 0x%08x "
		    "phy port 0x%08x length %u "
		    "reason %u table id %u",
		    ntohl(pin13.pin_buffer_id),
		    ntohl(pin13.pin_port),
		    ntohl(pin13.pin_phy_port),
		    ntohs(pin13.pin_total_len),
		    pin13.pin_reason,
		    pin13.pin_table_id);
		if ((len - sizeof(pin)) < ntohs(pin.pin_total_len))
			goto fail;
		if (sc->sc_tap != -1) {
			p = (uint8_t *)&buf[sizeof(pin)];
			(void)write(sc->sc_tap, p,
			    ntohs(pin.pin_total_len));
		}
#endif
a237 1
	return;
d239 7
a245 2
 fail:
	log_debug("\tinvalid packet\n");
d252 51
a302 2
	uint8_t		*buf;
	ssize_t		 len;
d304 60
a363 2
	len = ibuf_length(ibuf);
	buf = ibuf_data(ibuf);
d365 32
a396 1
	ofp13_debug(sc, &con->con_peer, &con->con_local, oh, ibuf);
d398 28
a425 13
	switch (oh->oh_type) {
	case OFP_T_HELLO:
		/* Echo back the received Hello packet */
		ofp_send(con, oh, NULL);
		break;
	case OFP_T_ECHO_REQUEST:
		/* Echo reply */
		oh->oh_type = OFP_T_ECHO_REPLY;
		ofp_send(con, oh, NULL);
		break;
	default:
		/* not implemented */
		break;
d428 5
d434 1
@

