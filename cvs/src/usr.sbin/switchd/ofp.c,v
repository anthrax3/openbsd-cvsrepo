head	1.18;
access;
symbols
	OPENBSD_6_0:1.6.0.2
	OPENBSD_6_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.18
date	2016.12.22.15.31.43;	author rzalamena;	state Exp;
branches;
next	1.17;
commitid	LN8ENq5eYaE4jXoJ;

1.17
date	2016.12.02.14.39.46;	author rzalamena;	state Exp;
branches;
next	1.16;
commitid	AN66AOZvr15Na6D1;

1.16
date	2016.11.22.17.21.56;	author rzalamena;	state Exp;
branches;
next	1.15;
commitid	xzEfzrsva4b1hxML;

1.15
date	2016.11.04.22.27.08;	author reyk;	state Exp;
branches;
next	1.14;
commitid	mk4W3srERHxHiEzi;

1.14
date	2016.10.12.19.07.42;	author reyk;	state Exp;
branches;
next	1.13;
commitid	3O0CWeyo2kl0zVpd;

1.13
date	2016.10.05.16.40.55;	author reyk;	state Exp;
branches;
next	1.12;
commitid	dD2JdYNdBVvHZmTc;

1.12
date	2016.09.30.12.48.27;	author reyk;	state Exp;
branches;
next	1.11;
commitid	xHMNHfWpPneWqH4E;

1.11
date	2016.09.30.12.33.43;	author reyk;	state Exp;
branches;
next	1.10;
commitid	ABUXivQ0uWyMhb9f;

1.10
date	2016.09.30.11.57.57;	author reyk;	state Exp;
branches;
next	1.9;
commitid	Bk6N1Zmhuj3ewIdN;

1.9
date	2016.09.29.18.25.54;	author reyk;	state Exp;
branches;
next	1.8;
commitid	NV4vuVCpPottgEyF;

1.8
date	2016.09.26.08.48.05;	author rzalamena;	state Exp;
branches;
next	1.7;
commitid	c1eGY6ZZANkr3WB2;

1.7
date	2016.09.14.13.46.51;	author rzalamena;	state Exp;
branches;
next	1.6;
commitid	JePtimnIRHuPUx14;

1.6
date	2016.07.21.07.58.44;	author reyk;	state Exp;
branches;
next	1.5;
commitid	hvjhEQsdPbzSKWjJ;

1.5
date	2016.07.20.21.06.09;	author reyk;	state Exp;
branches;
next	1.4;
commitid	oAt2Z5U4QO5BWOCb;

1.4
date	2016.07.20.21.01.06;	author reyk;	state Exp;
branches;
next	1.3;
commitid	Rumwj01zEH37kIh7;

1.3
date	2016.07.20.14.15.08;	author reyk;	state Exp;
branches;
next	1.2;
commitid	r8lT9ieuUAvheQ28;

1.2
date	2016.07.19.18.11.08;	author reyk;	state Exp;
branches;
next	1.1;
commitid	6hIGkfWtS6dnpc9W;

1.1
date	2016.07.19.16.54.26;	author reyk;	state Exp;
branches;
next	;
commitid	NvD0Bp0qm4zs28YJ;


desc
@@


1.18
log
@Learn remote switch flow tables properties to find out where to install
the default table-miss flow for OpenFlow 1.3.5. This is enough to make
switchd(8) to work with switch(4) and HP 3800 switch out-of-the-box.

ok reyk@@
@
text
@/*	$OpenBSD: ofp.c,v 1.17 2016/12/02 14:39:46 rzalamena Exp $	*/

/*
 * Copyright (c) 2013-2016 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/un.h>
#include <sys/queue.h>

#include <netinet/in.h>
#include <netinet/tcp.h>
#include <net/ofp.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <pwd.h>
#include <event.h>

#include "ofp10.h"
#include "switchd.h"
#include "ofp_map.h"

int	 ofp_dispatch_parent(int, struct privsep_proc *, struct imsg *);
int	 ofp_dispatch_control(int, struct privsep_proc *, struct imsg *);
void	 ofp_run(struct privsep *, struct privsep_proc *, void *);
int	 ofp_add_device(struct switchd *, int, const char *);

static struct privsep_proc procs[] = {
	{ "control",	PROC_CONTROL,	ofp_dispatch_control },
	{ "parent",	PROC_PARENT,	ofp_dispatch_parent }
};

void
ofp(struct privsep *ps, struct privsep_proc *p)
{
	ofrelay(ps, p);
	proc_run(ps, p, procs, nitems(procs), ofp_run, NULL);
}

void
ofp_run(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	struct switchd	*sc = ps->ps_env;

	/*
	 * pledge in the ofp process:
 	 * stdio - for malloc and basic I/O including events.
	 * inet - for handling tcp connections with OpenFlow peers.
	 * recvfd - for receiving new sockets on reload.
	 */
	if (pledge("stdio inet recvfd", NULL) == -1)
		fatal("pledge");

	TAILQ_INIT(&sc->sc_conns);
	sc->sc_tap = -1;

	ofrelay_run(ps, p, NULL);
}

int
ofp_dispatch_control(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_SUM:
		return (switch_dispatch_control(fd, p, imsg));
	default:
		break;
	}

	return (-1);
}

int
ofp_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct privsep			*ps = p->p_ps;
	struct switchd			*sc = ps->ps_env;
	struct switch_client		 swc;
	struct switch_connection	*con;

	switch (imsg->hdr.type) {
	case IMSG_TAPFD:
		if (sc->sc_tap != -1)
			close(sc->sc_tap);
		sc->sc_tap = imsg->fd;
		return (0);
	case IMSG_CTL_CONNECT:
	case IMSG_CTL_DISCONNECT:
		IMSG_SIZE_CHECK(imsg, &swc);
		memcpy(&swc, imsg->data, sizeof(swc));

		if (imsg->hdr.type == IMSG_CTL_CONNECT)
			ofrelay_attach(&sc->sc_server, imsg->fd,
			    (struct sockaddr *)&swc.swc_addr.swa_addr);
		else if ((con = switchd_connbyaddr(sc,
		    (struct sockaddr *)&swc.swc_addr.swa_addr)) != NULL)
			ofp_close(con);
		return (0);
	default:
		break;
	}

	return (-1);
}

int
ofp_input(struct switch_connection *con, struct ibuf *ibuf)
{
	struct switchd		*sc = con->con_sc;
	struct ofp_header	*oh;

	if ((oh = ibuf_seek(ibuf, 0, sizeof(*oh))) == NULL) {
		log_debug("short header");
		return (-1);
	}

	/* Check for message version match. */
	if (con->con_state > OFP_STATE_HELLO_WAIT &&
	    con->con_version != OFP_V_0 &&
	    oh->oh_version != con->con_version) {
		log_debug("wrong version %s, expected %s",
		    print_map(oh->oh_version, ofp_v_map),
		    print_map(con->con_version, ofp_v_map));
		return (-1);
	}

	/* Check the state machine to decide whether or not to allow. */
	if (con->con_state <= OFP_STATE_HELLO_WAIT &&
	    oh->oh_type > OFP_T_ERROR) {
		log_debug("expected hello, got %s",
		    print_map(oh->oh_type, ofp_t_map));
		return (-1);
	}

	switch (oh->oh_version) {
	case OFP_V_1_0:
		if (ofp10_input(sc, con, oh, ibuf) != 0)
			return (-1);
		break;
	case OFP_V_1_3:
		if (ofp13_input(sc, con, oh, ibuf) != 0)
			return (-1);
		break;
	case OFP_V_1_1:
	case OFP_V_1_2:
		/* FALLTHROUGH */
	default:
		(void)ofp10_validate(sc,
		    &con->con_peer, &con->con_local, oh, ibuf);
		ofp10_hello(sc, con, oh, ibuf);
		return (-1);
	}

	return (0);
}

int
ofp_open(struct privsep *ps, struct switch_connection *con)
{
	struct switch_control	*sw;

	/* Get associated switch, if it exists */
	sw = switch_get(con);

	log_info("%s: new connection %u.%u from switch %u",
	    __func__, con->con_id, con->con_instance,
	    sw == NULL ? 0 : sw->sw_id);

	/* Send the hello with the latest version we support. */
	if (ofp_send_hello(ps->ps_env, con, OFP_V_1_3) == -1)
		return (-1);

	if (ofp_nextstate(ps->ps_env, con, OFP_STATE_HELLO_WAIT) == -1)
		return (-1);

	return (0);
}

void
ofp_close(struct switch_connection *con)
{
	ofrelay_close(con);
}

int
ofp_nextstate(struct switchd *sc, struct switch_connection *con,
    enum ofp_state state)
{
	int		rv = 0;

	switch (con->con_state) {
	case OFP_STATE_CLOSED:
		if (state != OFP_STATE_HELLO_WAIT)
			return (-1);

		break;

	case OFP_STATE_HELLO_WAIT:
		if (state != OFP_STATE_FEATURE_WAIT)
			return (-1);

		rv = ofp_send_featuresrequest(sc, con);
		break;

	case OFP_STATE_FEATURE_WAIT:
		if (state != OFP_STATE_ESTABLISHED)
			return (-1);

		if (con->con_version != OFP_V_1_3)
			break;

#if 0
		/* Let's not ask this while we don't use it. */
		ofp13_flow_stats(sc, con, OFP_PORT_ANY, OFP_GROUP_ID_ANY,
		    OFP_TABLE_ID_ALL);
		ofp13_desc(sc, con);
#endif
		rv |= ofp13_table_features(sc, con, 0);
		rv |= ofp13_setconfig(sc, con, OFP_CONFIG_FRAG_NORMAL,
		    OFP_CONTROLLER_MAXLEN_NO_BUFFER);
		break;


	case OFP_STATE_ESTABLISHED:
		if (state != OFP_STATE_CLOSED)
			return (-1);

		break;

	default:
		return (-1);
	}

	/* Set the next state. */
	con->con_state = state;

	return (rv);
}
@


1.17
log
@Implement the connection state machine for OpenFlow 1.0 and 1.3 to detect
invalid state transitions and invalid protocol version switching after the
hello messages exchange.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.16 2016/11/22 17:21:56 rzalamena Exp $	*/
a233 1
		ofp13_table_features(sc, con, 0);
d236 1
a238 3

		/* Use table '0' for switch(4) and '100' for HP 3800. */
		rv |= ofp13_tablemiss_sendctrl(sc, con, 0);
@


1.16
log
@Implement support for version negotiation using hello messages. This
also prevents connections from switching the version in the middle of
the operation.

tweak from and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.15 2016/11/04 22:27:08 reyk Exp $	*/
d135 3
a137 1
	if (con->con_version != OFP_V_0 &&
d139 11
a149 2
		log_debug("wrong version %d, expected %d",
		    oh->oh_version, con->con_version);
d191 3
d201 58
@


1.15
log
@Move ofp_output() into ofp_common.c and few function prototypes into
switchd.h.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.14 2016/10/12 19:07:42 reyk Exp $	*/
d135 7
d175 4
@


1.14
log
@Start reworking the "device" support in switchd: Once connected, a
device is just an fd that is connected to a switch, either via TCP or
via /dev/switch.  Change the switchctl from "device add" to "connect"
etc.  This change is an intermediate step towards other changes,
including the configuration grammar, so a few things will be left
undocumented for now.

switchctl(8) examples,
switchctl connect /dev/switch0
switchctl connect /dev/switch0 forward-to 10.1.1.1
switchctl connect 127.0.0.1
switchctl connect 127.0.0.1 forward-to 10.1.1.1
switchctl disconnect /dev/switch0

Discussed with rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.13 2016/10/05 16:40:55 reyk Exp $	*/
a152 24

	return (0);
}

int
ofp_output(struct switch_connection *con, struct ofp_header *oh,
    struct ibuf *obuf)
{
	struct ibuf	*buf;

	if ((buf = ibuf_static()) == NULL)
		return (-1);
	if ((oh != NULL) &&
	    (ibuf_add(buf, oh, sizeof(*oh)) == -1)) {
		ibuf_release(buf);
		return (-1);
	}
	if ((obuf != NULL) &&
	    (ibuf_cat(buf, obuf) == -1)) {
		ibuf_release(buf);
		return (-1);
	}

	ofrelay_write(con, buf);
@


1.13
log
@Remove ofp_validate_header() here
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.12 2016/09/30 12:48:27 reyk Exp $	*/
d96 1
a96 2
	struct sockaddr_un		 un;
	struct switch_device		*sdv;
d105 10
a114 18
	case IMSG_CTL_DEVICE_CONNECT:
	case IMSG_CTL_DEVICE_DISCONNECT:
		IMSG_SIZE_CHECK(imsg, sdv);
		sdv = imsg->data;

		if (strlcpy(un.sun_path, sdv->sdv_device,
		    sizeof(un.sun_path)) >= sizeof(un.sun_path)) {
			log_warnx("invalid device: %s", sdv->sdv_device);
			return (0);
		}
		un.sun_family = AF_UNIX;
		un.sun_len = sizeof(un);

		if (imsg->hdr.type == IMSG_CTL_DEVICE_CONNECT)
			ofrelay_attach(&sc->sc_server,
			    imsg->fd, (struct sockaddr *)&un);
		else if ((con =
		    switchd_connbyaddr(sc, (struct sockaddr *)&un)) != NULL)
@


1.12
log
@Remove local copy of ofp.h and use net/ofp.h instead
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.11 2016/09/30 12:33:43 reyk Exp $	*/
a130 34
}

int
ofp_validate_header(struct switchd *sc,
    struct sockaddr_storage *src, struct sockaddr_storage *dst,
    struct ofp_header *oh, uint8_t version)
{
	struct constmap	*tmap;

	/* For debug, don't verify the header if the version is unset */
	if (version != OFP_V_0 &&
	    (oh->oh_version != version ||
	    oh->oh_type >= OFP_T_TYPE_MAX))
		return (-1);

	switch (version) {
	case OFP_V_1_0:
	case OFP_V_1_1:
		tmap = ofp10_t_map;
		break;
	case OFP_V_1_3:
	default:
		tmap = ofp_t_map;
		break;
	}

	log_debug("%s > %s: version %s type %s length %u xid %u",
	    print_host(src, NULL, 0),
	    print_host(dst, NULL, 0),
	    print_map(oh->oh_version, ofp_v_map),
	    print_map(oh->oh_type, tmap),
	    ntohs(oh->oh_length), ntohl(oh->oh_xid));

	return (0);
@


1.11
log
@Disable write events if there is nothing to write.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.10 2016/09/30 11:57:57 reyk Exp $	*/
d27 1
a36 1
#include "ofp.h"
@


1.10
log
@Implement socket server code that properly handles async I/O, partial
messages, multiple messages per buffer and important things like
connection limits and file descriptor accounting.  It works with TCP
connections as well as switch(4).  The ofrelay.c part replaces
networking that was in ofp.c and will soon handle all socket
connections of switchd.  It is called "ofrelay" because it will be
used as client, server, and forwarder.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.9 2016/09/29 18:25:54 reyk Exp $	*/
d218 2
a219 1
	ibuf_close(&con->con_wbuf, buf);
@


1.9
log
@Rename ofp_send to ofp_output
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.8 2016/09/26 08:48:05 rzalamena Exp $	*/
d41 1
a42 1
int	 ofp_dispatch_parent(int, struct privsep_proc *, struct imsg *);
a45 2
static unsigned int	 id = 0;

d48 1
a48 2
	{ "parent",	PROC_PARENT,	ofp_dispatch_parent },
	{ "ofcconn",	PROC_OFCCONN,	NULL }
a50 3
static TAILQ_HEAD(, switch_connection) conn_head =
    TAILQ_HEAD_INITIALIZER(conn_head);

d54 1
a54 12
	struct switchd		*sc = ps->ps_env;
	struct switch_server	*srv = &sc->sc_server;

	if ((sc->sc_tap = switchd_tap()) == -1)
		fatal("tap");

	log_info("listen on %s", print_host(&srv->srv_addr, NULL, 0));

	if ((srv->srv_fd = switchd_listen((struct sockaddr *)
	    &srv->srv_addr)) == -1)
		fatal("listen");

d61 1
a61 2
	struct switchd		*sc = ps->ps_env;
	struct switch_server	*srv = &sc->sc_server;
d72 4
a75 2
	event_set(&srv->srv_ev, srv->srv_fd, EV_READ, ofp_accept, srv);
	event_add(&srv->srv_ev, NULL);
d94 3
a96 1
	struct switchd			*sc = p->p_ps->ps_env;
d98 1
a98 1
	struct switch_connection	*c;
d101 5
d108 6
a113 3
		if (IMSG_DATA_SIZE(imsg) < sizeof(*sdv)) {
			log_warnx("%s: IMSG_CTL_DEVICE_CONNECT: "
			    "message size is wrong", __func__);
d116 3
a118 1
		sdv = imsg->data;
d120 5
a124 12
			ofp_add_device(sc, imsg->fd, sdv->sdv_device);
		else {
			TAILQ_FOREACH(c, &conn_head, con_next) {
				if (c->con_peer.ss_family == AF_UNIX &&
				    strcmp(sdv->sdv_device,
				    ((struct sockaddr_un *)&c->con_peer)
				    ->sun_path) == 0)
					break;
			}
			if (c)
				ofp_close(c);
		}
a126 1

a132 10
void
ofp_close(struct switch_connection *con)
{
	log_info("%s: connection %u closed", __func__, con->con_id);
	event_del(&con->con_ev);
	switch_remove(con->con_sc, con->con_switch);
	close(con->con_fd);
	TAILQ_REMOVE(&conn_head, con, con_next);
}

d167 2
a168 2
void
ofp_read(int fd, short event, void *arg)
a169 3
	uint8_t			 buf[SWITCHD_READ_BUFFER];
	struct switch_connection *con = arg;
	struct switch_control	*sw;
a171 18
	ssize_t			 len;
	struct ibuf		*ibuf = NULL;

	event_add(&con->con_ev, NULL);
	if ((event & EV_TIMEOUT))
		goto fail;

	if ((len = read(fd, buf, sizeof(buf))) == -1)
		goto fail;
	if (len == 0)
		goto fail;

	if ((ibuf = ibuf_new(buf, len)) == NULL)
		goto fail;

	sw = con->con_switch;
	log_debug("%s: connection %d: %ld bytes from switch %u", __func__,
	    con->con_id, len, sw == NULL ? 0 : sw->sw_id);
d175 1
a175 1
		goto fail;
d181 1
a181 1
			goto fail;
d185 1
a185 1
			goto fail;
d194 1
a194 1
		goto fail;
d197 1
a197 6
	ibuf_release(ibuf);
	return;

 fail:
	ibuf_release(ibuf);
	ofp_close(con);
d204 1
a204 9
	struct iovec		 iov[2];
	int			 cnt = 0;
	void			*data;
	ssize_t			 len;

	if (oh != NULL) {
		iov[cnt].iov_base = oh;
		iov[cnt++].iov_len = sizeof(*oh);
	}
d206 6
a211 11
	if (ibuf_length(obuf)) {
		if (oh != NULL && (ibuf_seek(obuf, 0, sizeof(*oh)) == NULL))
			return (-1);
		len = ibuf_dataleft(obuf);
		if (len < 0) {
			return (-1);
		} else if (len > 0 &&
		    (data = ibuf_getdata(obuf, len)) != NULL) {
			iov[cnt].iov_base = data;
			iov[cnt++].iov_len = len;
		}
d213 3
a215 6

	if (cnt == 0)
		return (-1);

	/* XXX */
	if (writev(con->con_fd, iov, cnt) == -1)
d217 2
d224 1
a224 1
ofp_add_device(struct switchd *sc, int fd, const char *name)
d226 1
a226 14
	struct switch_connection	*con = NULL;
	struct sockaddr_un		*sun;
	struct switch_control		*sw;

	if ((con = calloc(1, sizeof(*con))) == NULL) {
		log_warn("calloc");
		goto fail;
	}
	con->con_fd = fd;
	con->con_sc = sc;
	con->con_id = ++id;
	sun = (struct sockaddr_un *)&con->con_peer;
	sun->sun_family = AF_LOCAL;
	strlcpy(sun->sun_path, name, sizeof(sun->sun_path));
d231 3
a233 8
	log_info("%s: new device %u (%s) from switch %u",
	    __func__, con->con_id, name, sw == NULL ? 0 : sw->sw_id);

	bzero(&con->con_ev, sizeof(con->con_ev));
	event_set(&con->con_ev, con->con_fd, EV_READ, ofp_read, con);
	event_add(&con->con_ev, NULL);

	TAILQ_INSERT_TAIL(&conn_head, con, con_next);
a235 6
fail:
	if (fd != -1)
		close(fd);
	free(con);

	return (-1);
d239 1
a239 1
ofp_accept(int fd, short event, void *arg)
d241 1
a241 53
	struct switch_server	*server = arg;
	struct switch_connection *con = NULL;
	struct switchd		*sc = server->srv_sc;
	struct switch_control	*sw;
	struct sockaddr_storage	 ss;
	socklen_t		 slen;
	int			 s;

	event_add(&server->srv_ev, NULL);
	if ((event & EV_TIMEOUT))
		return;

	/* XXX accept_reserve() */
	slen = sizeof(ss);
	if ((s = accept(fd, (struct sockaddr *)&ss, &slen)) == -1) {
		log_warn("accept");
		goto fail;
	}

	if ((con = calloc(1, sizeof(*con))) == NULL) {
		log_warn("calloc");
		goto fail;
	}

	slen = sizeof(con->con_local);
	if (getsockname(s, (struct sockaddr *)&con->con_local, &slen) == -1) {
		log_warn("getsockname");
		goto fail;
	}

	con->con_fd = s;
	con->con_sc = sc;
	con->con_id = ++id;
	con->con_port = htons(socket_getport(&ss));
	memcpy(&con->con_peer, &ss, sizeof(ss));

	/* Get associated switch, if it exists */
	sw = switch_get(con);

	log_info("%s: new connection %u from switch %u",
	    __func__, con->con_id, sw == NULL ? 0 : sw->sw_id);

	bzero(&con->con_ev, sizeof(con->con_ev));
	event_set(&con->con_ev, con->con_fd, EV_READ, ofp_read, con);
	event_add(&con->con_ev, NULL);

	TAILQ_INSERT_TAIL(&conn_head, con, con_next);

	return;
 fail:
	if (s != -1)
		close(s);
	free(con);
@


1.8
log
@Fix a memory leak and a loop in the ofp_read() that happens every time a
message is received or a socket is closed.

This is just a temporary fix to avoid switchd(8) from hogging the cpu and
leaking memory while testing.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.7 2016/09/14 13:46:51 rzalamena Exp $	*/
d249 1
a249 1
ofp_send(struct switch_connection *con, struct ofp_header *oh,
@


1.7
log
@Teach switchd(8) how to fork+exec.

Note: this daemon has the -Wcast-qual compilation flag which trigger a
warning that wasn't enable in httpd(8) or relayd(8). This will be fixed
in a next diff and then synchronized with other daemons.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.6 2016/07/21 07:58:44 reyk Exp $	*/
d149 1
d207 1
a207 1
		return;
d240 1
@


1.6
log
@Turn ofp*_debug functions into ofp*_validate functions to follow a
similar approach like iked: first validate the packet, then parse it,
and execute actions.  debug logging is a side effect of validation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.5 2016/07/20 21:06:09 reyk Exp $	*/
d57 1
a57 1
pid_t
a61 1
	pid_t			 pid;
d72 1
a72 5
	pid = proc_run(ps, p, procs, nitems(procs), ofp_run, NULL);
	close(srv->srv_fd);
	close(sc->sc_tap);

	return (pid);
@


1.5
log
@fix typos in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.4 2016/07/20 21:01:06 reyk Exp $	*/
d39 1
d159 34
d227 2
a228 1
		ofp10_input(sc, con, oh, ibuf);
d231 2
a232 1
		ofp13_input(sc, con, oh, ibuf);
a235 1
		ofp10_debug(sc, &con->con_peer, &con->con_local, oh, ibuf);
d238 2
a239 1
		ofp10_debug(sc, &con->con_peer, &con->con_local, oh, ibuf);
d241 1
a241 1
		break;
@


1.4
log
@pledge(2) all the switchd processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.3 2016/07/20 14:15:08 reyk Exp $	*/
d86 1
a86 1
	 * pledge in the control process:
@


1.3
log
@Update OpenFlow 1.3 stub based on the 1.0 code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.2 2016/07/19 18:11:08 reyk Exp $	*/
d42 1
a42 1
void	 ofp_init(struct privsep *, struct privsep_proc *, void *);
d72 1
a72 1
	pid = proc_run(ps, p, procs, nitems(procs), ofp_init, NULL);
d80 1
a80 1
ofp_init(struct privsep *ps, struct privsep_proc *p, void *arg)
d84 9
@


1.2
log
@Correctly use ssize_t instead of size_t for read/write return values.
Pointed out by David Hill and clang.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofp.c,v 1.1 2016/07/19 16:54:26 reyk Exp $	*/
d74 1
@


1.1
log
@Import switchd(8), a basic WIP OpenFlow implementation for OpenBSD.

switchd consists of two parts:
1. switchd(8) and switchctl(8), an OpenFlow controller or "vswitch".
2. switch(4), an OpenFlow-aware kernel "bridge".

This the 1st part, the driver will be imported later.  The code will
remain disabled for a while, but it helps development to have it in
the tree.  switchd currently supports partial OpenFlow 1.0, but the
goal is to use OpenFlow 1.3.5 instead (switch(4) already does 1.3.5).

For more background information see:
http://www.openbsd.org/papers/bsdcan2016-switchd.pdf
https://youtu.be/Cuo0qT-lqig

With help from yasuoka@@ goda@@
Import discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d211 1
a211 1
	size_t			 len;
@

