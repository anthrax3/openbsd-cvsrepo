head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.6.0.2
	OPENBSD_6_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.12
date	2016.10.12.19.07.42;	author reyk;	state Exp;
branches;
next	1.11;
commitid	3O0CWeyo2kl0zVpd;

1.11
date	2016.09.30.12.48.27;	author reyk;	state Exp;
branches;
next	1.10;
commitid	xHMNHfWpPneWqH4E;

1.10
date	2016.09.30.11.57.57;	author reyk;	state Exp;
branches;
next	1.9;
commitid	Bk6N1Zmhuj3ewIdN;

1.9
date	2016.09.14.13.46.51;	author rzalamena;	state Exp;
branches;
next	1.8;
commitid	JePtimnIRHuPUx14;

1.8
date	2016.08.08.08.22.29;	author yasuoka;	state Exp;
branches;
next	1.7;
commitid	saIMyU0hfuuGITIj;

1.7
date	2016.08.08.07.24.27;	author yasuoka;	state Exp;
branches;
next	1.6;
commitid	uRa3zCwB8FcuNdhQ;

1.6
date	2016.07.20.21.06.09;	author reyk;	state Exp;
branches;
next	1.5;
commitid	oAt2Z5U4QO5BWOCb;

1.5
date	2016.07.20.21.01.06;	author reyk;	state Exp;
branches;
next	1.4;
commitid	Rumwj01zEH37kIh7;

1.4
date	2016.07.19.18.11.08;	author reyk;	state Exp;
branches;
next	1.3;
commitid	6hIGkfWtS6dnpc9W;

1.3
date	2016.07.19.18.04.04;	author reyk;	state Exp;
branches;
next	1.2;
commitid	pLmUGIN8moKDoteC;

1.2
date	2016.07.19.17.31.22;	author reyk;	state Exp;
branches;
next	1.1;
commitid	Dny8XXpomcML4q7J;

1.1
date	2016.07.19.16.54.26;	author reyk;	state Exp;
branches;
next	;
commitid	NvD0Bp0qm4zs28YJ;


desc
@@


1.12
log
@Start reworking the "device" support in switchd: Once connected, a
device is just an fd that is connected to a switch, either via TCP or
via /dev/switch.  Change the switchctl from "device add" to "connect"
etc.  This change is an intermediate step towards other changes,
including the configuration grammar, so a few things will be left
undocumented for now.

switchctl(8) examples,
switchctl connect /dev/switch0
switchctl connect /dev/switch0 forward-to 10.1.1.1
switchctl connect 127.0.0.1
switchctl connect 127.0.0.1 forward-to 10.1.1.1
switchctl disconnect /dev/switch0

Discussed with rzalamena@@
@
text
@/*	$OpenBSD: ofcconn.c,v 1.11 2016/09/30 12:48:27 reyk Exp $	*/

/*
 * Copyright (c) 2016 YASUOKA Masahiko <yasuoka@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/uio.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <net/ofp.h>

#include <errno.h>
#include <event.h>
#include <imsg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <imsg.h>

#include "ofp10.h"
#include "types.h"
#include "switchd.h"

int	 ofcconn_dispatch_parent(int, struct privsep_proc *, struct imsg *);

static struct privsep_proc procs[] = {
	{ "parent",	PROC_PARENT,	ofcconn_dispatch_parent },
	{ "control",	PROC_CONTROL,	NULL },
};

struct ofcconn;

/* OpenFlow Switch */
struct ofsw {
	int			 os_fd;
	char			*os_name;
	int			 os_write_ready;
	TAILQ_HEAD(,ofcconn)	 os_ofcconns;
	struct event		 os_evio;
	TAILQ_ENTRY(ofsw)	 os_next;
};
TAILQ_HEAD(, ofsw)	 ofsw_list = TAILQ_HEAD_INITIALIZER(ofsw_list);

/* OpenFlow Channel Connection */
struct ofcconn {
	struct ofsw		*oc_sw;
	char			*oc_name;
	struct sockaddr_storage	 oc_peer;
	int			 oc_sock;
	int			 oc_write_ready;
	int			 oc_connected;
	int			 oc_conn_fails;
	struct ibuf		*oc_buf;
	TAILQ_ENTRY(ofcconn)	 oc_next;
	struct event		 oc_evsock;
	struct event		 oc_evtimer;
};

struct ofsw	*ofsw_create(const char *, int);
void		 ofsw_close(struct ofsw *);
void		 ofsw_free(struct ofsw *);
void		 ofsw_on_io(int, short, void *);
int		 ofsw_write(struct ofsw *, struct ofcconn *);
int		 ofsw_ofc_write_ready(struct ofsw *);
void		 ofsw_reset_event_handlers(struct ofsw *);
int		 ofsw_new_ofcconn(struct ofsw *, struct switch_address *);
int		 ofcconn_connect(struct ofcconn *);
void		 ofcconn_on_sockio(int, short, void *);
void		 ofcconn_connect_again(struct ofcconn *);
void		 ofcconn_on_timer(int, short, void *);
void		 ofcconn_reset_event_handlers(struct ofcconn *);
void		 ofcconn_io_fail(struct ofcconn *);
void		 ofcconn_close(struct ofcconn *);
void		 ofcconn_free(struct ofcconn *);
void		 ofcconn_shutdown_all(void);
int		 ofcconn_send_hello(struct ofcconn *);
void		 ofcconn_run(struct privsep *, struct privsep_proc *, void *);

void
ofcconn(struct privsep *ps, struct privsep_proc *p)
{
	p->p_shutdown = ofcconn_shutdown;
	proc_run(ps, p, procs, nitems(procs), ofcconn_run, NULL);
}

void
ofcconn_run(struct privsep *ps, struct privsep_proc *p, void *arg)
{
	/*
	 * pledge in the ofcconn process:
 	 * stdio - for malloc and basic I/O including events.
	 * inet - for socket operations and OpenFlow connections.
	 * recvfd - for receiving new sockets on reload.
	 */
	if (pledge("stdio inet recvfd", NULL) == -1)
		fatal("pledge");
}

void
ofcconn_shutdown(void)
{
	struct ofsw	*e, *t;

	TAILQ_FOREACH_SAFE(e, &ofsw_list, os_next, t) {
		ofsw_close(e);
		ofsw_free(e);
	}
}

int
ofcconn_dispatch_parent(int fd, struct privsep_proc *p, struct imsg *imsg)
{
	struct ofsw			*os;
	struct switch_client		 swc;
	struct sockaddr_un		*un;

	switch (imsg->hdr.type) {
	case IMSG_CTL_CONNECT:
		if (IMSG_DATA_SIZE(imsg) < sizeof(swc)) {
			log_warnx("%s: IMSG_CTL_CONNECT: "
			    "invalid message size", __func__);
			return (0);
		}
		memcpy(&swc, imsg->data, sizeof(swc));
		un = (struct sockaddr_un *)&swc.swc_addr.swa_addr;

		if ((os = ofsw_create(un->sun_path, imsg->fd)) != NULL)
			ofsw_new_ofcconn(os, &swc.swc_target);
		return (0);
	case IMSG_CTL_DISCONNECT:
		if (IMSG_DATA_SIZE(imsg) < sizeof(swc)) {
			log_warnx("%s: IMSG_CTL_DEVICE_DISCONNECT: "
			    "invalid message size", __func__);
			return (0);
		}
		memcpy(&swc, imsg->data, sizeof(swc));
		un = (struct sockaddr_un *)&swc.swc_addr.swa_addr;

		TAILQ_FOREACH(os, &ofsw_list, os_next) {
			if (!strcmp(os->os_name, un->sun_path))
				break;
		}
		if (os) {
			log_warnx("%s: closed by request", os->os_name);
			ofsw_close(os);
			ofsw_free(os);
		}
		return (0);
	default:
		break;
	}

	return (-1);
}

struct ofsw *
ofsw_create(const char *name, int fd)
{
	struct ofsw	*os = NULL;

	if ((os = calloc(1, sizeof(struct ofsw))) == NULL) {
		log_warn("%s: calloc failed", __func__);
		goto fail;
	}
	if ((os->os_name = strdup(name)) == NULL) {
		log_warn("%s: strdup failed", __func__);
		goto fail;
	}
	os->os_fd = fd;
	TAILQ_INIT(&os->os_ofcconns);
	TAILQ_INSERT_TAIL(&ofsw_list, os, os_next);

	event_set(&os->os_evio, os->os_fd, EV_READ|EV_WRITE, ofsw_on_io, os);
	event_add(&os->os_evio, NULL);

	return (os);

 fail:
	if (os != NULL)
		free(os->os_name);
	free(os);

	return (NULL);
}

void
ofsw_close(struct ofsw *os)
{
	struct ofcconn	*oc, *oct;

	if (os->os_fd >= 0) {
		close(os->os_fd);
		event_del(&os->os_evio);
		os->os_fd = -1;
	}
	TAILQ_FOREACH_SAFE(oc, &os->os_ofcconns, oc_next, oct) {
		ofcconn_close(oc);
		ofcconn_free(oc);
	}
}

void
ofsw_free(struct ofsw *os)
{
	if (os == NULL)
		return;

	TAILQ_REMOVE(&ofsw_list, os, os_next);
	free(os->os_name);
	free(os);
}

void
ofsw_on_io(int fd, short evmask, void *ctx)
{
	struct ofsw		*os = ctx;
	struct ofcconn		*oc, *oct;
	static char		 msg[65536];/* max size of OpenFlow message */
	ssize_t			 msgsz, sz;
	struct ofp_header	*hdr;

	if (evmask & EV_WRITE || os->os_write_ready) {
		os->os_write_ready = 1;
		if (ofsw_write(os, NULL) == -1)
			return;
	}

	if ((evmask & EV_READ) && ofsw_ofc_write_ready(os)) {
		if ((msgsz = read(os->os_fd, msg, sizeof(msg))) <= 0) {
			if (msgsz < 0)
				log_warn("%s: %s read", __func__, os->os_name);
			else
				log_warnx("%s: %s closed", __func__,
				    os->os_name);
			ofsw_close(os);
			ofsw_free(os);
			return;
		}
		hdr = (struct ofp_header *)msg;
		if (hdr->oh_type != OFP_T_HELLO) {
			TAILQ_FOREACH_SAFE(oc, &os->os_ofcconns, oc_next, oct) {
				if ((sz = write(oc->oc_sock, msg, msgsz))
				    != msgsz) {
					log_warn("%s: sending a message to "
					    "%s failed", os->os_name,
					    oc->oc_name);
					ofcconn_io_fail(oc);
					continue;
				}
				oc->oc_write_ready = 0;
				ofcconn_reset_event_handlers(oc);
			}
		}
	}
	ofsw_reset_event_handlers(os);

	return;
}

int
ofsw_write(struct ofsw *os, struct ofcconn *oc0)
{
	struct ofcconn		*oc = oc0;
	struct ofp_header	*hdr;
	u_char			*msg;
	ssize_t			 sz, msglen;
	int			 remain = 0;
	unsigned char		 buf[65536];

	if (!os->os_write_ready)
		return (0);

 again:
	if (oc != NULL) {
		hdr = ibuf_seek(oc->oc_buf, 0, sizeof(*hdr));
		if (hdr == NULL)
			return (0);
		msglen = ntohs(hdr->oh_length);
		msg = ibuf_seek(oc->oc_buf, 0, msglen);
		if (msg == NULL)
			return (0);
	} else {
		TAILQ_FOREACH(oc, &os->os_ofcconns, oc_next) {
			hdr = ibuf_seek(oc->oc_buf, 0, sizeof(*hdr));
			if (hdr == NULL)
				continue;
			msglen = ntohs(hdr->oh_length);
			msg = ibuf_seek(oc->oc_buf, 0, msglen);
			if (msg != NULL)
				break;
		}
		if (oc == NULL)
			return (0);	/* no message to write yet */
	}
	if (hdr->oh_type != OFP_T_HELLO) {
		if ((sz = write(os->os_fd, msg, msglen)) != msglen) {
			if (sz < 0)
				log_warn("%s: %s write failed", __func__,
				    os->os_name);
			else
				log_warn("%s: %s write partially", __func__,
				    os->os_name);
			ofsw_close(os);
			ofsw_free(os);
			return (-1);
		}
		os->os_write_ready = 0;
	}

	/* XXX preserve the remaining part */
	if ((remain = oc->oc_buf->wpos - msglen) > 0)
		memcpy(buf, (caddr_t)msg + msglen, remain);
	ibuf_reset(oc->oc_buf);

	/* XXX put the remaining part again */
	if (remain > 0)
		ibuf_add(oc->oc_buf, buf, remain);

	if (os->os_write_ready) {
		oc = NULL;
		goto again;
	}

	return (0);
}

int
ofsw_ofc_write_ready(struct ofsw *os)
{
	struct ofcconn	*oc;
	int		 write_ready = 0;

	TAILQ_FOREACH(oc, &os->os_ofcconns, oc_next) {
		if (oc->oc_write_ready)
			write_ready = 1;
		else
			break;
	}
	if (oc != NULL)
		return (0);

	return (write_ready);
}

void
ofsw_reset_event_handlers(struct ofsw *os)
{
	short	evmask = 0, oevmask;

	oevmask = event_pending(&os->os_evio, EV_READ|EV_WRITE, NULL);

	if (ofsw_ofc_write_ready(os))
		evmask |= EV_READ;
	if (!os->os_write_ready)
		evmask |= EV_WRITE;

	if (oevmask != evmask) {
		if (oevmask)
			event_del(&os->os_evio);
		event_set(&os->os_evio, os->os_fd, evmask, ofsw_on_io, os);
		event_add(&os->os_evio, NULL);
	}
}

int
ofsw_new_ofcconn(struct ofsw *os, struct switch_address *swa)
{
	struct ofcconn	*oc = NULL;
	char		 buf[128];

	if ((oc = calloc(1, sizeof(struct ofcconn))) == NULL) {
		log_warn("%s: calloc failed", __func__);
		goto fail;
	}

	if (asprintf(&oc->oc_name, "tcp:%s",
	    print_host(&swa->swa_addr, buf, sizeof(buf))) == -1) {
		log_warn("%s: strdup failed", __func__);
		goto fail;
	}
	if ((oc->oc_buf = ibuf_new(NULL, 0)) == NULL) {
		log_warn("%s: failed to get new ibuf", __func__);
		goto fail;
	}
	oc->oc_sw = os;
	oc->oc_sock = -1;
	memcpy(&oc->oc_peer, &swa->swa_addr, sizeof(oc->oc_peer));

	if (ntohs(((struct sockaddr_in *)&oc->oc_peer)->sin_port) == 0)
		((struct sockaddr_in *)&oc->oc_peer)->sin_port =
		    htons(SWITCHD_CTLR_PORT);

	evtimer_set(&oc->oc_evtimer, ofcconn_on_timer, oc);
	TAILQ_INSERT_TAIL(&os->os_ofcconns, oc, oc_next);

	return (ofcconn_connect(oc));

 fail:
	if (oc != NULL) {
		free(oc->oc_name);
		ibuf_release(oc->oc_buf);
	}
	free(oc);

	return (-1);
}

int
ofcconn_connect(struct ofcconn *oc)
{
	int		 sock = -1;
	struct timeval	 tv;

	if ((sock = socket(oc->oc_peer.ss_family, SOCK_STREAM | SOCK_NONBLOCK,
	    IPPROTO_TCP)) == -1) {
		log_warn("%s: failed to open socket for channel with %s",
		    oc->oc_sw->os_name, oc->oc_name);
		goto fail;
	}

	if (connect(sock, (struct sockaddr *)&oc->oc_peer,
	    oc->oc_peer.ss_len) == -1) {
		if (errno != EINPROGRESS) {
			log_warn("%s: failed to connect channel to %s",
			    oc->oc_sw->os_name, oc->oc_name);
			goto fail;
		}
	}

	oc->oc_sock = sock;
	event_set(&oc->oc_evsock, oc->oc_sock, EV_READ|EV_WRITE,
	    ofcconn_on_sockio, oc);
	event_add(&oc->oc_evsock, NULL);

	tv.tv_sec = SWITCHD_CONNECT_TIMEOUT;
	tv.tv_usec = 0;
	event_add(&oc->oc_evtimer, &tv);

	return (0);

 fail:
	if (sock >= 0)
		close(sock);

	oc->oc_conn_fails++;
	ofcconn_connect_again(oc);

	return (-1);
}

void
ofcconn_on_sockio(int fd, short evmask, void *ctx)
{
	struct ofcconn	*oc = ctx;
	ssize_t		 sz;
	size_t		 wpos;
	int		 err;
	socklen_t	 optlen;

	if (evmask & EV_WRITE) {
		if (oc->oc_connected == 0) {
			optlen = sizeof(err);
			getsockopt(oc->oc_sock, SOL_SOCKET, SO_ERROR, &err,
			    &optlen);
			if (err != 0) {
				log_warnx("%s: connection error with %s: %s",
				    oc->oc_sw->os_name, oc->oc_name,
				    strerror(err));
				oc->oc_conn_fails++;
				ofcconn_close(oc);
				ofcconn_connect_again(oc);
				return;
			}
			log_info("%s: OpenFlow channel to %s connected",
			    oc->oc_sw->os_name, oc->oc_name);

			event_del(&oc->oc_evtimer);
			oc->oc_connected = 1;
			oc->oc_conn_fails = 0;
			if (ofcconn_send_hello(oc) != 0)
				return;
		} else
			oc->oc_write_ready = 1;
	}

	if ((evmask & EV_READ) && ibuf_left(oc->oc_buf) > 0) {
		wpos = ibuf_length(oc->oc_buf);

		/* XXX temporally fix not to access unallocated area */
		if (wpos + ibuf_left(oc->oc_buf) > oc->oc_buf->size) {
			ibuf_reserve(oc->oc_buf, ibuf_left(oc->oc_buf));
			ibuf_setsize(oc->oc_buf, wpos);
		}

		if ((sz = read(oc->oc_sock, ibuf_data(oc->oc_buf) + wpos,
		    ibuf_left(oc->oc_buf))) <= 0) {
			if (sz == 0)
				log_warnx("%s: %s: connection closed by peer",
				    oc->oc_sw->os_name, oc->oc_name);
			else
				log_warn("%s: %s: connection read error",
				    oc->oc_sw->os_name, oc->oc_name);
			goto fail;
		}
		if (ibuf_setsize(oc->oc_buf, wpos + sz) == -1)
			goto fail;

		if (ofsw_write(oc->oc_sw, oc) == -1)
			return;	/* oc is already freeed */
	}
	ofcconn_reset_event_handlers(oc);
	ofsw_reset_event_handlers(oc->oc_sw);

	return;

 fail:
	ofcconn_close(oc);
	ofcconn_connect_again(oc);
}

void
ofcconn_connect_again(struct ofcconn *oc)
{
	struct timeval	 tv;
	const int	 ofcconn_backoffs[] = { 1, 2, 4, 8, 16 };

	tv.tv_sec = (oc->oc_conn_fails < (int)nitems(ofcconn_backoffs))
	    ? ofcconn_backoffs[oc->oc_conn_fails]
	    : ofcconn_backoffs[nitems(ofcconn_backoffs) - 1];
	tv.tv_usec = 0;
	event_add(&oc->oc_evtimer, &tv);
}

void
ofcconn_on_timer(int fd, short evmask, void *ctx)
{
	struct ofcconn	*oc = ctx;

	if (oc->oc_sock < 0)
		ofcconn_connect(oc);
	else if (!oc->oc_connected) {
		log_warnx("%s: timeout connecting channel to %s",
		    oc->oc_sw->os_name, oc->oc_name);
		ofcconn_close(oc);
		oc->oc_conn_fails++;
		ofcconn_connect_again(oc);
	}
}

void
ofcconn_reset_event_handlers(struct ofcconn *oc)
{
	short	evmask = 0, oevmask;

	oevmask = event_pending(&oc->oc_evsock, EV_READ|EV_WRITE, NULL);

	if (ibuf_left(oc->oc_buf) > 0)
		evmask |= EV_READ;
	if (!oc->oc_write_ready)
		evmask |= EV_WRITE;

	if (oevmask != evmask) {
		if (oevmask)
			event_del(&oc->oc_evsock);
		if (evmask) {
			event_set(&oc->oc_evsock, oc->oc_sock, evmask,
			    ofcconn_on_sockio, oc);
			event_add(&oc->oc_evsock, NULL);
		}
	}
}

void
ofcconn_io_fail(struct ofcconn *oc)
{
	ofcconn_close(oc);
	ofcconn_connect_again(oc);
}

void
ofcconn_close(struct ofcconn *oc)
{
	if (oc->oc_sock >= 0) {
		event_del(&oc->oc_evsock);
		close(oc->oc_sock);
		oc->oc_sock = -1;
		oc->oc_write_ready = 0;
	}
	event_del(&oc->oc_evtimer);
	oc->oc_connected = 0;
}

void
ofcconn_free(struct ofcconn *oc)
{
	if (oc == NULL)
		return;
	TAILQ_REMOVE(&oc->oc_sw->os_ofcconns, oc, oc_next);
	ibuf_release(oc->oc_buf);
	free(oc->oc_name);
	free(oc);
}

int
ofcconn_send_hello(struct ofcconn *oc)
{
	struct ofp_header	 hdr;
	ssize_t			 sz;

	hdr.oh_version = OFP_V_1_3;
	hdr.oh_type = OFP_T_HELLO;
	hdr.oh_length = htons(sizeof(hdr));
	hdr.oh_xid = htonl(0xffffffffUL);

	sz = sizeof(hdr);
	if (write(oc->oc_sock, &hdr, sz) != sz) {
		log_warn("%s: %s: %s; write", __func__, oc->oc_sw->os_name,
		    oc->oc_name);
		ofcconn_close(oc);
		ofcconn_connect_again(oc);
		return (-1);
	}

	return (0);
}
@


1.11
log
@Remove local copy of ofp.h and use net/ofp.h instead
@
text
@d1 1
a1 1
/*	$OpenBSD: ofcconn.c,v 1.10 2016/09/30 11:57:57 reyk Exp $	*/
d23 1
d82 1
a82 1
int		 ofsw_new_ofcconn(struct ofsw *, struct switch_controller *);
d130 2
a131 2
	struct switch_device		*sdv;
	struct switch_controller	*swc;
d134 3
a136 3
	case IMSG_CTL_DEVICE_CONNECT:
		if (IMSG_DATA_SIZE(imsg) < sizeof(*sdv)) {
			log_warnx("%s: IMSG_CTL_DEVICE_CONNECT: "
d140 5
a144 4
		sdv = imsg->data;
		swc = &sdv->sdv_swc;
		if ((os = ofsw_create(sdv->sdv_device, imsg->fd)) != NULL)
			ofsw_new_ofcconn(os, swc);
d146 2
a147 2
	case IMSG_CTL_DEVICE_DISCONNECT:
		if (IMSG_DATA_SIZE(imsg) < sizeof(*sdv)) {
d152 3
a154 1
		sdv = imsg->data;
d156 1
a156 1
			if (!strcmp(os->os_name, sdv->sdv_device))
d382 1
a382 1
ofsw_new_ofcconn(struct ofsw *os, struct switch_controller *swc)
d393 1
a393 1
	    print_host(&swc->swc_addr, buf, sizeof(buf))) == -1) {
d403 1
a403 1
	memcpy(&oc->oc_peer, &swc->swc_addr, sizeof(oc->oc_peer));
d451 1
a451 1
	tv.tv_sec = SWITCHD_OFCCONN_TIMEOUT;
@


1.10
log
@Implement socket server code that properly handles async I/O, partial
messages, multiple messages per buffer and important things like
connection limits and file descriptor accounting.  It works with TCP
connections as well as switch(4).  The ofrelay.c part replaces
networking that was in ofp.c and will soon handle all socket
connections of switchd.  It is called "ofrelay" because it will be
used as client, server, and forwarder.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofcconn.c,v 1.9 2016/09/14 13:46:51 rzalamena Exp $	*/
d24 2
a34 1
#include "ofp.h"
@


1.9
log
@Teach switchd(8) how to fork+exec.

Note: this daemon has the -Wcast-qual compilation flag which trigger a
warning that wasn't enable in httpd(8) or relayd(8). This will be fixed
in a next diff and then synchronized with other daemons.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ofcconn.c,v 1.8 2016/08/08 08:22:29 yasuoka Exp $	*/
a42 1
	{ "ofp",	PROC_OFP,	NULL }
@


1.8
log
@Fix previous.  Obvously the condition is reversed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofcconn.c,v 1.7 2016/08/08 07:24:27 yasuoka Exp $	*/
d94 1
a94 1
pid_t
d98 1
a98 1
	return (proc_run(ps, p, procs, nitems(procs), ofcconn_run, NULL));
@


1.7
log
@Split ofcconn into switch part and connection part to make the switch
part be able to have multiple connections.

ok reyk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofcconn.c,v 1.6 2016/07/20 21:06:09 reyk Exp $	*/
d217 1
a217 1
	if (os != NULL)
@


1.6
log
@fix typos in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ofcconn.c,v 1.5 2016/07/20 21:01:06 reyk Exp $	*/
d27 1
d46 13
d61 2
a62 1
	char			*oc_device;
d65 1
a65 3
	int			 oc_devf;
	int			 oc_sock_write_ready;
	int			 oc_devf_write_ready;
a70 1
	struct event		 oc_evdevf;
d74 8
a81 3
TAILQ_HEAD(, ofcconn)	 ofcconn_list = TAILQ_HEAD_INITIALIZER(ofcconn_list);

struct ofcconn	*ofcconn_create(const char *, struct switch_controller *, int);
a83 2
void		 ofcconn_on_devfio(int, short, void *);
int		 ofcconn_write(struct ofcconn *);
d86 2
a87 2
void		 ofcconn_reset_evsock(struct ofcconn *);
void		 ofcconn_reset_evdevf(struct ofcconn *);
d117 1
a117 1
	struct ofcconn	*e, *t;
d119 3
a121 3
	TAILQ_FOREACH_SAFE(e, &ofcconn_list, oc_next, t) {
		ofcconn_close(e);
		ofcconn_free(e);
d128 1
a128 1
	struct ofcconn			*conn;
d141 2
a142 3
		if ((conn = ofcconn_create(sdv->sdv_device, swc,
		    imsg->fd)) != NULL)
			ofcconn_connect(conn);
d151 2
a152 2
		TAILQ_FOREACH(conn, &ofcconn_list, oc_next) {
			if (!strcmp(conn->oc_device, sdv->sdv_device))
d155 4
a158 5
		if (conn) {
			log_warnx("%s: closed by request",
			    conn->oc_device);
			ofcconn_close(conn);
			ofcconn_free(conn);
d168 211
a378 2
struct ofcconn *
ofcconn_create(const char *name, struct switch_controller *swc, int fd)
d381 1
d387 4
a390 2
	if ((oc->oc_device = strdup(name)) == NULL) {
		log_warn("%s: calloc failed", __func__);
d397 1
a397 1

a398 3
	oc->oc_devf = fd;
	TAILQ_INSERT_TAIL(&ofcconn_list, oc, oc_next);

d406 1
d408 1
a408 1
	return (oc);
d412 1
a412 1
		free(oc->oc_device);
d417 1
a417 1
	return (NULL);
a423 1
	char		 buf[256];
d429 1
a429 2
		    oc->oc_device,
		    print_host(&oc->oc_peer, buf, sizeof(buf)));
d437 1
a437 2
			    oc->oc_device,
			    print_host(&oc->oc_peer, buf, sizeof(buf)));
a444 3
	event_set(&oc->oc_evdevf, oc->oc_devf, EV_READ|EV_WRITE,
	    ofcconn_on_devfio, oc);
	event_add(&oc->oc_evdevf, NULL);
d466 5
a470 6
	struct ofcconn		*oc = ctx;
	ssize_t			 sz;
	size_t			 wpos;
	char			 buf[256];
	int			 err;
	socklen_t		 optlen;
d478 2
a479 3
				log_warnx("%s: connection error with %s: %s ",
				    oc->oc_device,
				    print_host(&oc->oc_peer, buf, sizeof(buf)),
d487 2
a488 2
			    oc->oc_device,
			    print_host(&oc->oc_peer, buf, sizeof(buf)));
d494 2
a495 5
		} else {
			oc->oc_sock_write_ready = 1;
			/* schedule an event to reset the event handlers */
			event_active(&oc->oc_evdevf, 0, 1);
		}
d498 1
a498 1
	if (evmask & EV_READ && ibuf_left(oc->oc_buf) > 0) {
d507 1
a507 2
		if ((sz = read(oc->oc_sock,
		    ibuf_data(oc->oc_buf) + wpos,
d510 2
a511 2
				log_warnx("%s: connection closed by peer",
				    oc->oc_device);
d513 2
a514 2
				log_warn("%s: connection read error",
				    oc->oc_device);
d519 3
a521 5
		if (oc->oc_devf_write_ready) {
			if (ofcconn_write(oc) == -1)
				goto fail;
			event_active(&oc->oc_evdevf, 0, 1);
		}
d523 2
a524 1
	ofcconn_reset_evsock(oc);
a533 42
ofcconn_on_devfio(int fd, short evmask, void *ctx)
{
	struct ofcconn		*oc = ctx;
	static char		 buf[65536];/* max size of OpenFlow message */
	ssize_t			 sz, sz2;
	struct ofp_header	*hdr;

	if (evmask & EV_WRITE) {
		oc->oc_devf_write_ready = 1;
		if (ofcconn_write(oc) == -1)
			goto fail;
	}

	if (evmask & EV_READ && oc->oc_sock_write_ready) {
		if ((sz = read(oc->oc_devf, buf, sizeof(buf))) <= 0) {
			if (sz < 0)
				log_warn("%s: %s read", __func__,
				    oc->oc_device);
			goto fail;
		}
		hdr = (struct ofp_header *)buf;
		if (hdr->oh_type != OFP_T_HELLO) {
			/* forward packet */
			if ((sz2 = write(oc->oc_sock, buf, sz)) != sz) {
				log_warn("%s: %s write", __func__,
				    oc->oc_device);
				goto fail;
			}
			oc->oc_sock_write_ready = 0;
			/* schedule an event to reset the event handlers */
			event_active(&oc->oc_evsock, 0, 1);
		}
	}
	ofcconn_reset_evdevf(oc);

	return;
 fail:
	ofcconn_close(oc);
	ofcconn_connect_again(oc);
}

void
a549 1
	char		 buf[256];
d555 1
a555 2
		    oc->oc_device,
		    print_host(&oc->oc_peer, buf, sizeof(buf)));
d563 1
a563 1
ofcconn_reset_evsock(struct ofcconn *oc)
d571 1
a571 1
	if (!oc->oc_sock_write_ready)
d577 5
a581 3
		event_set(&oc->oc_evsock, oc->oc_sock, evmask,
		    ofcconn_on_sockio, oc);
		event_add(&oc->oc_evsock, NULL);
d586 1
a586 1
ofcconn_reset_evdevf(struct ofcconn *oc)
d588 2
a589 58
	short	evmask = 0, oevmask;

	oevmask = event_pending(&oc->oc_evdevf, EV_READ|EV_WRITE, NULL);

	if (oc->oc_sock_write_ready)
		evmask |= EV_READ;
	if (!oc->oc_devf_write_ready)
		evmask |= EV_WRITE;

	if (oevmask != evmask) {
		if (oevmask)
			event_del(&oc->oc_evdevf);
		event_set(&oc->oc_evdevf, oc->oc_devf, evmask,
		    ofcconn_on_devfio, oc);
		event_add(&oc->oc_evdevf, NULL);
	}
}

int
ofcconn_write(struct ofcconn *oc)
{
	struct ofp_header	*hdr;
	size_t			 sz, pktlen;
	void			*pkt;
	/* XXX */
	unsigned char		 buf[65536];
	int			 remain = 0;

	/* Try to write if the OFP header has arrived */
	if (!oc->oc_devf_write_ready ||
	    (hdr = ibuf_seek(oc->oc_buf, 0, sizeof(*hdr))) == NULL)
		return (0);

	/* Check the length in the OFP header */
	pktlen = ntohs(hdr->oh_length);

	if ((pkt = ibuf_seek(oc->oc_buf, 0, pktlen)) != NULL) {
		hdr = pkt;
		if (hdr->oh_type != OFP_T_HELLO) {
			/* forward packet; has entire packet already */
			if ((sz = write(oc->oc_devf, pkt, pktlen)) != pktlen) {
				log_debug("%s: %s size %d pktlen %d",
				    __func__,
				    oc->oc_device, (int)sz, (int)pktlen);
				return (-1);
			}
		}
		/* XXX preserve the remaining part */
		if ((remain = oc->oc_buf->wpos - pktlen) > 0)
			memmove(buf, (caddr_t)pkt + pktlen, remain);
		ibuf_reset(oc->oc_buf);
		oc->oc_devf_write_ready = 0;
	}
	/* XXX put the remaining part again */
	if (remain > 0)
		ibuf_add(oc->oc_buf, buf, remain);

	return (0);
d599 1
a599 1
		oc->oc_sock_write_ready = 0;
a600 1
	event_del(&oc->oc_evdevf);
d610 1
a610 2
	close(oc->oc_devf);
	TAILQ_REMOVE(&ofcconn_list, oc, oc_next);
d612 1
a612 1
	free(oc->oc_device);
d629 2
a630 1
		log_warn("%s: %s write", __func__, oc->oc_device);
@


1.5
log
@pledge(2) all the switchd processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofcconn.c,v 1.4 2016/07/19 18:11:08 reyk Exp $	*/
d77 1
a77 1
void		 ofccon_run(struct privsep *, struct privsep_proc *, void *);
d83 1
a83 1
	return (proc_run(ps, p, procs, nitems(procs), ofccon_run, NULL));
d87 1
a87 1
ofccon_run(struct privsep *ps, struct privsep_proc *p, void *arg)
d90 1
a90 1
	 * pledge in the control process:
@


1.4
log
@Correctly use ssize_t instead of size_t for read/write return values.
Pointed out by David Hill and clang.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofcconn.c,v 1.3 2016/07/19 18:04:04 reyk Exp $	*/
d77 1
d80 1
a80 1
ofcconn_proc_init(struct privsep *ps, struct privsep_proc *p)
d82 2
a83 2
	p->p_shutdown = ofcconn_proc_shutdown;
	return (proc_run(ps, p, procs, nitems(procs), NULL, NULL));
d87 14
a100 1
ofcconn_proc_shutdown(void)
@


1.3
log
@A bit of cleanup and style changes. ofcconn needs more work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ofcconn.c,v 1.2 2016/07/19 17:31:22 reyk Exp $	*/
d314 1
a314 1
	size_t			 sz, sz2;
d503 2
a504 1
	if ((sz = write(oc->oc_sock, &hdr, sizeof(hdr))) != sz) {
@


1.2
log
@Don't use .p_shutdown in the proc struct
@
text
@d1 1
a1 1
/*	$OpenBSD: ofcconn.c,v 1.1 2016/07/19 16:54:26 reyk Exp $	*/
d76 1
a76 1
int		 ofcconn_say_hello(struct ofcconn *);
d147 2
a148 2
		log_warn("%s: calloc() failed", __func__);
		goto on_error;
d151 2
a152 2
		log_warn("%s: calloc() failed", __func__);
		goto on_error;
d155 2
a156 2
		log_warn("%s: ibuf_new() failed", __func__);
		goto on_error;
d173 1
a173 1
on_error:
d192 2
a193 2
		log_warn("%s: opening of channel with %s failed.  "
		    "socket()", oc->oc_device,
d195 1
a195 1
		goto on_error;
d201 2
a202 2
			log_warn("%s: opening OpenFlow channel with %s "
			    "failed.  connect()", oc->oc_device,
d204 1
a204 1
			goto on_error;
d222 1
a222 1
on_error:
d248 4
a251 4
				log_warnx("%s: opening OpenFlow channel with "
				    "%s failed: %s",
				    oc->oc_device, print_host(&oc->oc_peer,
				    buf, sizeof(buf)), strerror(err));
d257 1
a257 1
			log_info("%s: OpenFlow channel with %s connected",
d263 1
a263 1
			if (ofcconn_say_hello(oc) != 0)
d285 1
a285 2
				log_warnx("%s: OpenFlow channel is closed by "
				    "peer",
d288 1
a288 1
				log_warn("%s: OpenFlow channel read error",
d290 1
a290 1
			goto on_fail;
d293 1
a293 1
			goto on_fail;
d296 1
a296 1
				goto on_fail;
d303 2
a304 1
on_fail:
d320 1
a320 1
			goto on_fail;
d326 1
a326 1
				log_warn("%s: %s read()", __func__,
d328 1
a328 1
			goto on_fail;
d331 10
a340 5
		if (hdr->oh_type == OFP_T_HELLO)
			goto dont_forward;
		if ((sz2 = write(oc->oc_sock, buf, sz)) != sz) {
			log_warn("%s: %s write()", __func__, oc->oc_device);
			goto on_fail;
a341 4
		oc->oc_sock_write_ready = 0;
		/* schedule an event to reset the event handlers */
		event_active(&oc->oc_evsock, 0, 1);
dont_forward:	;
d346 1
a346 1
on_fail:
d373 2
a374 2
		log_warnx("%s: opening OpenFlow channel with %s failed: "
		    "timeout", oc->oc_device,
d431 2
a432 2
	u_char buf[65535];
	int remain = 0;
d444 8
a451 7
		if (hdr->oh_type == OFP_T_HELLO)
			goto dont_forward;
		/* Has entire packet already */
		if ((sz = write(oc->oc_devf, pkt, pktlen)) != pktlen) {
			log_warn("%s: %s(%d, %d)", __func__, oc->oc_device,
			    (int)sz, (int)pktlen);
			return (-1);
a452 1
dont_forward:
d493 1
a493 1
ofcconn_say_hello(struct ofcconn *oc)
d504 1
a504 1
		log_warn("%s: %s write()", __func__, oc->oc_device);
@


1.1
log
@Import switchd(8), a basic WIP OpenFlow implementation for OpenBSD.

switchd consists of two parts:
1. switchd(8) and switchctl(8), an OpenFlow controller or "vswitch".
2. switch(4), an OpenFlow-aware kernel "bridge".

This the 1st part, the driver will be imported later.  The code will
remain disabled for a while, but it helps development to have it in
the tree.  switchd currently supports partial OpenFlow 1.0, but the
goal is to use OpenFlow 1.3.5 instead (switch(4) already does 1.3.5).

For more background information see:
http://www.openbsd.org/papers/bsdcan2016-switchd.pdf
https://youtu.be/Cuo0qT-lqig

With help from yasuoka@@ goda@@
Import discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 1
@

