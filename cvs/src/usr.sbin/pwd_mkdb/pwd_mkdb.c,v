head	1.53;
access;
symbols
	OPENBSD_6_0:1.53.0.4
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.43.0.20
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.16
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.14
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.12
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.10
	OPENBSD_5_0:1.43.0.8
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.6
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.4
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.40.0.8
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.4
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.40.0.2
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.38.0.16
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.38.0.14
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.38.0.12
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.38.0.10
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.8
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.38.0.6
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.38.0.4
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	OPENBSD_3_5:1.37.0.4
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.37.0.2
	OPENBSD_3_4_BASE:1.37
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.4
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.19.0.4
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.19.0.2
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2015.11.05.15.10.11;	author semarie;	state Exp;
branches;
next	1.52;
commitid	y3ICP5kBCePGycAx;

1.52
date	2015.11.05.13.48.51;	author semarie;	state Exp;
branches;
next	1.51;
commitid	hW5RXqm4TzmXS4Gr;

1.51
date	2015.10.16.22.54.35;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	t5AtSjAHfLEk2zHp;

1.50
date	2015.08.27.19.11.37;	author gsoares;	state Exp;
branches;
next	1.49;
commitid	OJ8lNwqBrXwaTEBi;

1.49
date	2015.08.19.17.58.32;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	GZtv4nKoKWOJ4JXm;

1.48
date	2015.04.24.21.14.48;	author millert;	state Exp;
branches;
next	1.47;
commitid	sldphAql0TT2Ooeu;

1.47
date	2015.04.15.16.43.11;	author millert;	state Exp;
branches;
next	1.46;
commitid	9y9Y7Y3oM4zsEfSc;

1.46
date	2015.01.16.06.40.19;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	Uu5nFG3wCl0LACBb;

1.45
date	2014.08.25.07.50.26;	author doug;	state Exp;
branches;
next	1.44;
commitid	vcwz0sp1JH7QzUmA;

1.44
date	2014.05.20.01.25.24;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.08.13.29.08;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.27.23.59.54;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.04.18.11.35;	author ajacoutot;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.25.14.51.27;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2008.03.17.20.30.16;	author sobrado;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.08.00.05.09;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.28.20.37.29;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.08.21.14.55;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.02.23.36.54;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.13.18.04.07;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.28.16.58.39;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.21.22.13.20;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.21.21.25.19;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.02.06.42.29;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.29.18.39.00;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.22.09.09.32;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.16.21.28.08;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.17.14.30.39;	author mpech;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.16.18.22.04;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.07.16.21.49;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.26.19.35.46;	author millert;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2000.11.26.01.23.12;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.30.16.00.26;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	99.04.21.21.15.12;	author alex;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	98.07.15.19.33.28;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	98.07.15.00.50.19;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.07.14.23.26.33;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	98.07.14.16.13.03;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.06.10.09.00.48;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.04.26.10.10.51;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.04.26.10.08.42;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.12.08.07.34.29;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.09.15.10.15.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.01.16.03.58.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.01.15.23.44.14;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.10.16.09.16.14;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.09.28.05.44.33;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.08.30.14.24.48;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.22.11.35.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.14.01.06.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.04.08.13.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.23.21.55.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.48.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.48.01;	author deraadt;	state Exp;
branches;
next	;

1.20.4.1
date	2000.10.06.21.24.22;	author jason;	state Exp;
branches;
next	;

1.23.2.1
date	2001.06.07.17.06.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.53
log
@revert sys/kern/kern_pledge.c 1.103 and reenable pledge in pwd_mkdb

ok deraadt@@
@
text
@/*	$OpenBSD: pwd_mkdb.c,v 1.52 2015/11/05 13:48:51 semarie Exp $	*/

/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * Portions Copyright (c) 1994, Jason Downs.  All rights reserved.
 * Portions Copyright (c) 1998, Todd C. Miller.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE */
#include <sys/stat.h>

#include <db.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <util.h>

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

#define	INSECURE	1
#define	SECURE		2
#define	PERM_INSECURE	(S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)
#define	PERM_SECURE	(S_IRUSR|S_IWUSR)

#define FILE_SECURE	0x01
#define FILE_INSECURE	0x02
#define FILE_ORIG	0x04

#define	SHADOW_GROUP	"_shadow"

HASHINFO openinfo = {
	4096,		/* bsize */
	32,		/* ffactor */
	256,		/* nelem */
	2048 * 1024,	/* cachesize */
	NULL,		/* hash() */
	0		/* lorder */
};

static char *pname;				/* password file name */
static char *basedir;				/* dir holding master.passwd */
static int clean;				/* what to remove on cleanup */
static int hasyp;				/* are we running YP? */

void		cleanup(void);
__dead void	fatal(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
__dead void	fatalc(int, const char *, ...)
		    __attribute__((__format__ (printf, 2, 3)));
__dead void	fatalx(const char *, ...)
		    __attribute__((__format__ (printf, 1, 2)));
int		write_old_entry(FILE *, const struct passwd *);

void		cp(char *, char *, mode_t);
void		mv(char *, char *);
int		scan(FILE *, struct passwd *, int *);
void		usage(void);
char		*changedir(char *path, char *dir);
void		db_store(FILE *, FILE *, DB *, DB *,struct passwd *, int, char *, uid_t);

int
main(int argc, char **argv)
{
	DB *dp, *edp;
	DBT data, key;
	FILE *fp, *oldfp = NULL;
	struct stat st;
	struct passwd pwd;
	struct group *grp;
	sigset_t set;
	uid_t olduid;
	gid_t shadow;
	int ch, tfd, makeold, secureonly, flags, checkonly;
	char *username, buf[MAX(PATH_MAX, LINE_MAX * 2)];

	flags = checkonly = makeold = secureonly = 0;
	username = NULL;
	while ((ch = getopt(argc, argv, "cd:psu:v")) != -1)
		switch (ch) {
		case 'c':			/* verify only */
			checkonly = 1;
			break;
		case 'd':
			basedir = optarg;
			if (strlen(basedir) > PATH_MAX - 40)
				errx(1, "basedir too long");
			break;
		case 'p':			/* create V7 "file.orig" */
			makeold = 1;
			break;
		case 's':			/* only update spwd.db */
			secureonly = 1;
			break;
		case 'u':			/* only update this record */
			username = optarg;
			if (strlen(username) > _PW_NAME_LEN)
				errx(1, "username too long");
			break;
		case 'v':			/* backward compatible */
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (argc != 1 || (makeold && secureonly) ||
	    (username && (*username == '+' || *username == '-')))
		usage();

	if ((grp = getgrnam(SHADOW_GROUP)) == NULL)
		errx(1, "cannot find `%s' in the group database, aborting",
		    SHADOW_GROUP);
	shadow = grp->gr_gid;

	/*
	 * This could be changed to allow the user to interrupt.
	 * Probably not worth the effort.
	 */
	sigemptyset(&set);
	sigaddset(&set, SIGTSTP);
	sigaddset(&set, SIGHUP);
	sigaddset(&set, SIGINT);
	sigaddset(&set, SIGQUIT);
	sigaddset(&set, SIGTERM);
	(void)sigprocmask(SIG_BLOCK, &set, (sigset_t *)NULL);

	/* We don't care what the user wants. */
	(void)umask(0);

	if (**argv != '/' && basedir == NULL)
		errx(1, "%s must be specified as an absolute path", *argv);

	if ((pname = strdup(changedir(*argv, basedir))) == NULL)
		err(1, NULL);
	/* Open the original password file */
	if (!(fp = fopen(pname, "r")))
		fatal("%s", pname);

	/* Check only if password database is valid */
	if (checkonly) {
		u_int cnt;

		for (cnt = 1; scan(fp, &pwd, &flags); ++cnt)
			;
		exit(0);
	}

	if (fstat(fileno(fp), &st) == -1)
		fatal("%s", pname);

	/* Tweak openinfo values for large passwd files. */
	if (st.st_size > (off_t)100*1024)
		openinfo.cachesize = MINIMUM(st.st_size * 20, (off_t)12*1024*1024);
	if (st.st_size / 128 > openinfo.nelem)
		openinfo.nelem = st.st_size / 128;

	/* If only updating a single record, stash the old uid */
	if (username) {
		dp = dbopen(_PATH_MP_DB, O_RDONLY, 0, DB_HASH, NULL);
		if (dp == NULL)
			fatal(_PATH_MP_DB);
		buf[0] = _PW_KEYBYNAME;
		strlcpy(buf + 1, username, sizeof(buf) - 1);
		key.data = (u_char *)buf;
		key.size = strlen(buf + 1) + 1;
		if ((dp->get)(dp, &key, &data, 0) == 0) {
			char *p = (char *)data.data;
			/* Skip to uid field */
			while (*p++ != '\0')
				;
			while (*p++ != '\0')
				;
			memcpy(&olduid, p, sizeof(olduid));
		} else
			olduid = UID_MAX;
		(dp->close)(dp);
	}

	/* Open the temporary encrypted password database. */
	(void)snprintf(buf, sizeof(buf), "%s.tmp",
	    changedir(_PATH_SMP_DB, basedir));
	if (username) {
		cp(changedir(_PATH_SMP_DB, basedir), buf, PERM_SECURE);
		edp = dbopen(buf,
		    O_RDWR, PERM_SECURE, DB_HASH, &openinfo);
	} else {
		edp = dbopen(buf,
		    O_RDWR|O_CREAT|O_EXCL, PERM_SECURE, DB_HASH, &openinfo);
	}
	if (!edp)
		fatal("%s", buf);
	if (fchown(edp->fd(edp), (uid_t)-1, shadow) != 0)
		warn("%s: unable to set group to %s", _PATH_SMP_DB,
		    SHADOW_GROUP);
	else if (fchmod(edp->fd(edp), PERM_SECURE|S_IRGRP) != 0)
		warn("%s: unable to make group readable", _PATH_SMP_DB);
	clean |= FILE_SECURE;

	if (pledge("stdio rpath wpath cpath getpw fattr flock", NULL) == -1)
		err(1, "pledge");

	/* Open the temporary insecure password database. */
	if (!secureonly) {
		(void)snprintf(buf, sizeof(buf), "%s.tmp",
		    changedir(_PATH_MP_DB, basedir));
		if (username) {
			cp(changedir(_PATH_MP_DB, basedir), buf, PERM_INSECURE);
			dp = dbopen(buf, O_RDWR, PERM_INSECURE, DB_HASH,
			    &openinfo);
		} else {
			dp = dbopen(buf, O_RDWR|O_CREAT|O_EXCL, PERM_INSECURE,
			    DB_HASH, &openinfo);
		}
		if (dp == NULL)
			fatal("%s", buf);
		clean |= FILE_INSECURE;
	} else
		dp = NULL;

	/*
	 * Open file for old password file.  Minor trickiness -- don't want to
	 * change the file already existing, since someone (stupidly) might
	 * still be using this for permission checking.  So, open it first and
	 * fdopen the resulting fd.  The resulting file should be readable by
	 * everyone.
	 */
	if (makeold) {
		(void)snprintf(buf, sizeof(buf), "%s.orig", pname);
		if ((tfd = open(buf,
		    O_WRONLY|O_CREAT|O_EXCL, PERM_INSECURE)) < 0)
			fatal("%s", buf);
		if ((oldfp = fdopen(tfd, "w")) == NULL)
			fatal("%s", buf);
		clean |= FILE_ORIG;
	}

	/*
	 * The databases actually contain three copies of the original data.
	 * Each password file entry is converted into a rough approximation
	 * of a ``struct passwd'', with the strings placed inline.  This
	 * object is then stored as the data for three separate keys.  The
	 * first key * is the pw_name field prepended by the _PW_KEYBYNAME
	 * character.  The second key is the pw_uid field prepended by the
	 * _PW_KEYBYUID character.  The third key is the line number in the
	 * original file prepended by the _PW_KEYBYNUM character.  (The special
	 * characters are prepended to ensure that the keys do not collide.)
	 *
	 * If we see something go by that looks like YP, we save a special
	 * pointer record, which if YP is enabled in the C lib, will speed
	 * things up.
	 */

	/*
	 * Write the .db files.
	 * We do this three times, one per key type (for getpw{nam,uid,ent}).
	 * The first time through we also check for YP, issue warnings
	 * and save the V7 format passwd file if necessary.
	 */
	db_store(fp, oldfp, edp, dp, &pwd, _PW_KEYBYNAME, username, olduid);
	db_store(fp, oldfp, edp, dp, &pwd, _PW_KEYBYUID, username, olduid);
	db_store(fp, oldfp, edp, dp, &pwd, _PW_KEYBYNUM, username, olduid);

	/* Store YP token, if needed. */
	if (hasyp && !username) {
		key.data = (u_char *)_PW_YPTOKEN;
		key.size = strlen(_PW_YPTOKEN);
		data.data = (u_char *)NULL;
		data.size = 0;

		if ((edp->put)(edp, &key, &data, R_NOOVERWRITE) == -1)
			fatal("put");

		if (dp && (dp->put)(dp, &key, &data, R_NOOVERWRITE) == -1)
			fatal("put");
	}

	if ((edp->close)(edp))
		fatal("close edp");
	if (dp && (dp->close)(dp))
		fatal("close dp");
	if (makeold) {
		if (fclose(oldfp) == EOF)
			fatal("close old");
	}

	/* Set master.passwd permissions, in case caller forgot. */
	(void)fchmod(fileno(fp), S_IRUSR|S_IWUSR);
	if (fclose(fp) != 0)
		fatal("fclose");

	/* Install as the real password files. */
	if (!secureonly) {
		(void)snprintf(buf, sizeof(buf), "%s.tmp",
		    changedir(_PATH_MP_DB, basedir));
		mv(buf, changedir(_PATH_MP_DB, basedir));
	}
	(void)snprintf(buf, sizeof(buf), "%s.tmp",
	    changedir(_PATH_SMP_DB, basedir));
	mv(buf, changedir(_PATH_SMP_DB, basedir));
	if (makeold) {
		(void)snprintf(buf, sizeof(buf), "%s.orig", pname);
		mv(buf, changedir(_PATH_PASSWD, basedir));
	}

	/*
	 * Move the master password LAST -- chpass(1), passwd(1) and vipw(8)
	 * all use flock(2) on it to block other incarnations of themselves.
	 * The rename means that everything is unlocked, as the original file
	 * can no longer be accessed.
	 */
	mv(pname, changedir(_PATH_MASTERPASSWD, basedir));
	exit(0);
}

int
scan(FILE *fp, struct passwd *pw, int *flags)
{
	static int lcnt;
	static char line[LINE_MAX];
	char *p;

	if (fgets(line, sizeof(line), fp) == NULL)
		return (0);
	++lcnt;
	/*
	 * ``... if I swallow anything evil, put your fingers down my
	 * throat...''
	 *	-- The Who
	 */
	p = line;
	if (*p != '\0' && *(p += strlen(line) - 1) != '\n') {
		warnx("line too long");
		goto fmt;
	}
	*p = '\0';
	*flags = 0;
	if (!pw_scan(line, pw, flags)) {
		warnx("at line #%d", lcnt);
fmt:		fatalc(EFTYPE, "%s", pname);
	}

	return (1);
}

void
cp(char *from, char *to, mode_t mode)
{
	static char buf[MAXBSIZE];
	int from_fd, rcount, to_fd, wcount;

	if ((from_fd = open(from, O_RDONLY, 0)) < 0)
		fatal("%s", from);
	if ((to_fd = open(to, O_WRONLY|O_CREAT|O_EXCL, mode)) < 0)
		fatal("%s", to);
	while ((rcount = read(from_fd, buf, MAXBSIZE)) > 0) {
		wcount = write(to_fd, buf, rcount);
		if (rcount != wcount || wcount == -1)
			fatal("%s to %s", from, to);
	}
	if (rcount < 0)
		fatal("%s to %s", from, to);
	close(to_fd);
	close(from_fd);
}

void
mv(char *from, char *to)
{
	if (rename(from, to))
		fatal("%s to %s", from, to);
}

void
fatal(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vwarn(fmt, ap);
	va_end(ap);
	cleanup();
	exit(EXIT_FAILURE);
}

void
fatalc(int code, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vwarnc(code, fmt, ap);
	va_end(ap);
	cleanup();
	exit(EXIT_FAILURE);
}

void
fatalx(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vwarnx(fmt, ap);
	va_end(ap);
	cleanup();
	exit(EXIT_FAILURE);
}

void
cleanup(void)
{
	char buf[PATH_MAX];

	if (clean & FILE_ORIG) {
		(void)snprintf(buf, sizeof(buf), "%s.orig", pname);
		(void)unlink(buf);
	}
	if (clean & FILE_SECURE) {
		(void)snprintf(buf, sizeof(buf), "%s.tmp",
		    changedir(_PATH_SMP_DB, basedir));
		(void)unlink(buf);
	}
	if (clean & FILE_INSECURE) {
		(void)snprintf(buf, sizeof(buf), "%s.tmp",
		    changedir(_PATH_MP_DB, basedir));
		(void)unlink(buf);
	}
}

void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: pwd_mkdb [-c] [-p | -s] [-d directory] [-u username] file\n");
	exit(EXIT_FAILURE);
}

char *
changedir(char *path, char *dir)
{
	static char fixed[PATH_MAX];
	char *p;

	if (!dir)
		return (path);

	if ((p = strrchr(path, '/')) != NULL)
		path = p + 1;
	snprintf(fixed, sizeof(fixed), "%s/%s", dir, path);
	return (fixed);
}

int
write_old_entry(FILE *to, const struct passwd *pw)
{
	char gidstr[16], uidstr[16];

	if (to == NULL)
		return (0);

	/* Preserve gid/uid -1 */
	if (pw->pw_gid == (gid_t)-1)
		strlcpy(gidstr, "-1", sizeof(gidstr));
	else
		snprintf(gidstr, sizeof(gidstr), "%u", (u_int)pw->pw_gid);

	if (pw->pw_uid == (uid_t)-1)
		strlcpy(uidstr, "-1", sizeof(uidstr));
	else
		snprintf(uidstr, sizeof(uidstr), "%u", (u_int)pw->pw_uid);

	return (fprintf(to, "%s:*:%s:%s:%s:%s:%s\n", pw->pw_name, uidstr,
	    gidstr, pw->pw_gecos, pw->pw_dir, pw->pw_shell));
}

void
db_store(FILE *fp, FILE *oldfp, DB *edp, DB *dp, struct passwd *pw,
	 int keytype, char *username, uid_t olduid)
{
	char *p, *t, buf[LINE_MAX * 2], tbuf[_PW_BUF_LEN];
	int flags = 0, dbmode, found = 0;
	static int firsttime = 1;
	DBT data, key;
	size_t len;
	u_int cnt;

	/* If given a username just add that record to the existing db. */
	dbmode = username ? 0 : R_NOOVERWRITE;

	rewind(fp);
	data.data = (u_char *)buf;
	key.data = (u_char *)tbuf;
	for (cnt = 1; scan(fp, pw, &flags); ++cnt) {

		if (firsttime) {
			/* Look like YP? */
			if ((pw->pw_name[0] == '+') || (pw->pw_name[0] == '-'))
				hasyp++;

			/* Warn about potentially unsafe uid/gid overrides. */
			if (pw->pw_name[0] == '+') {
				if (!(flags & _PASSWORD_NOUID) && !pw->pw_uid)
					warnx("line %d: superuser override in "
					    "YP inclusion", cnt);
				if (!(flags & _PASSWORD_NOGID) && !pw->pw_gid)
					warnx("line %d: wheel override in "
					    "YP inclusion", cnt);
			}

			/* Create V7 format password file entry. */
			if (write_old_entry(oldfp, pw) == -1)
				fatal("write old");
		}

		/* Are we updating a specific record? */
		if (username) {
			if (strcmp(username, pw->pw_name) != 0)
				continue;
			found = 1;
			/* If the uid changed, remove the old record by uid. */
			if (olduid != UID_MAX && olduid != pw->pw_uid) {
				tbuf[0] = _PW_KEYBYUID;
				memcpy(tbuf + 1, &olduid, sizeof(olduid));
				key.size = sizeof(olduid) + 1;
				(edp->del)(edp, &key, 0);
				if (dp)
					(dp->del)(dp, &key, 0);
			}
			/* XXX - should check to see if line number changed. */
		}

		/* Build the key. */
		tbuf[0] = keytype;
		switch (keytype) {
		case _PW_KEYBYNUM:
			memmove(tbuf + 1, &cnt, sizeof(cnt));
			key.size = sizeof(cnt) + 1;
			break;

		case _PW_KEYBYNAME:
			len = strlen(pw->pw_name);
			memmove(tbuf + 1, pw->pw_name, len);
			key.size = len + 1;
			break;

		case _PW_KEYBYUID:
			memmove(tbuf + 1, &pw->pw_uid, sizeof(pw->pw_uid));
			key.size = sizeof(pw->pw_uid) + 1;
			break;
		}

#define	COMPACT(e)	t = e; while ((*p++ = *t++));
		/* Create the secure record. */
		p = buf;
		COMPACT(pw->pw_name);
		COMPACT(pw->pw_passwd);
		memmove(p, &pw->pw_uid, sizeof(uid_t));
		p += sizeof(uid_t);
		memmove(p, &pw->pw_gid, sizeof(gid_t));
		p += sizeof(gid_t);
		memmove(p, &pw->pw_change, sizeof(time_t));
		p += sizeof(time_t);
		COMPACT(pw->pw_class);
		COMPACT(pw->pw_gecos);
		COMPACT(pw->pw_dir);
		COMPACT(pw->pw_shell);
		memmove(p, &pw->pw_expire, sizeof(time_t));
		p += sizeof(time_t);
		memmove(p, &flags, sizeof(int));
		p += sizeof(int);
		data.size = p - buf;

		/* Write the secure record. */
		if ((edp->put)(edp, &key, &data, dbmode) == -1)
			fatal("put");

		if (dp == NULL)
			continue;

		/* Star out password to make insecure record. */
		p = buf + strlen(pw->pw_name) + 1;	/* skip pw_name */
		len = strlen(pw->pw_passwd);
		explicit_bzero(p, len);			/* zero pw_passwd */
		t = p + len + 1;			/* skip pw_passwd */
		if (len != 0)
			*p++ = '*';
		*p++ = '\0';
		memmove(p, t, data.size - (t - buf));
		data.size -= len - 1;

		/* Write the insecure record. */
		if ((dp->put)(dp, &key, &data, dbmode) == -1)
			fatal("put");
	}
	if (firsttime) {
		firsttime = 0;
		if (username && !found && olduid != UID_MAX)
			fatalx("can't find user in master.passwd");
	}
}
@


1.52
log
@quick fix for a regression introduced by sys/kern/kern_pledge.c 1.103

ok benno phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.51 2015/10/16 22:54:35 deraadt Exp $	*/
a235 1
#if 0
a237 1
#endif
@


1.51
log
@pledge "stdio rpath wpath cpath getpw fattr flock"
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.50 2015/08/27 19:11:37 gsoares Exp $	*/
d236 1
d239 1
@


1.50
log
@missing va_end(); OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.49 2015/08/19 17:58:32 deraadt Exp $	*/
d235 3
@


1.49
log
@add missing prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.48 2015/04/24 21:14:48 millert Exp $	*/
d438 1
@


1.48
log
@Write (uid_t)-1 as -1 instead of UID_MAX in the v7 passwd file.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.47 2015/04/15 16:43:11 millert Exp $	*/
d87 2
@


1.47
log
@Convert error/errorx/errorc functions -> fatal/fatalx/fatalc and
make then take a printf format string instead of requiring the
caller to snprintf into a buffer first.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.46 2015/01/16 06:40:19 deraadt Exp $	*/
d484 23
d542 2
a543 6
			if (oldfp != NULL)
				if (fprintf(oldfp, "%s:*:%u:%u:%s:%s:%s\n",
				    pw->pw_name, pw->pw_uid, pw->pw_gid,
				    pw->pw_gecos, pw->pw_dir, pw->pw_shell)
				    == EOF)
					fatal("write old");
@


1.46
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.45 2014/08/25 07:50:26 doug Exp $	*/
d45 1
d80 13
a92 10
void	cleanup(void);
void	error(char *);
void	errorc(int, char *);
void	errorx(char *);
void	cp(char *, char *, mode_t);
void	mv(char *, char *);
int	scan(FILE *, struct passwd *, int *);
void	usage(void);
char	*changedir(char *path, char *dir);
void	db_store(FILE *, FILE *, DB *, DB *,struct passwd *, int, char *, uid_t);
d172 1
a172 1
		error(pname);
d184 1
a184 1
		error(pname);
d196 1
a196 1
			error(_PATH_MP_DB);
d226 1
a226 1
		error(buf);
d247 1
a247 1
			error(buf);
d263 1
a263 1
			error(buf);
d265 1
a265 1
			error(buf);
d303 1
a303 1
			error("put");
d306 1
a306 1
			error("put");
d310 1
a310 1
		error("close edp");
d312 1
a312 1
		error("close dp");
d315 1
a315 1
			error("close old");
d321 1
a321 1
		error("fclose");
d371 1
a371 1
fmt:		errorc(EFTYPE, pname);
d384 1
a384 1
		error(from);
d386 1
a386 1
		error(to);
d389 2
a390 12
		if (rcount != wcount || wcount == -1) {
			int sverrno = errno;

			(void)snprintf(buf, sizeof(buf), "%s to %s", from, to);
			errorc(sverrno, buf);
		}
	}
	if (rcount < 0) {
		int sverrno = errno;

		(void)snprintf(buf, sizeof(buf), "%s to %s", from, to);
		errorc(sverrno, buf);
d392 2
d401 2
a402 8
	char buf[PATH_MAX * 2];

	if (rename(from, to)) {
		int sverrno = errno;

		(void)snprintf(buf, sizeof(buf), "%s to %s", from, to);
		errorc(sverrno, buf);
	}
d406 1
a406 1
error(char *name)
d408 1
d410 3
a412 1
	warn("%s", name);
d414 1
a414 1
	exit(1);
d418 1
a418 1
errorc(int code, char *name)
d420 1
d422 3
a424 1
	warnc(code, "%s", name);
d426 1
a426 1
	exit(1);
d430 1
a430 1
errorx(char *name)
d432 1
d434 2
a435 1
	warnx("%s", name);
d437 1
a437 1
	exit(1);
d466 1
a466 1
	exit(1);
d524 1
a524 1
					error("write old");
d587 1
a587 1
			error("put");
d605 1
a605 1
			error("put");
d610 1
a610 1
			errorx("can't find user in master.passwd");
@


1.45
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.44 2014/05/20 01:25:24 guenther Exp $	*/
d34 1
a34 1
#include <sys/param.h>
d49 1
d52 2
d103 1
a103 1
	char *username, buf[MAX(MAXPATHLEN, LINE_MAX * 2)];
d114 1
a114 1
			if (strlen(basedir) > MAXPATHLEN - 40)
d184 1
a184 1
		openinfo.cachesize = MIN(st.st_size * 20, (off_t)12*1024*1024);
d405 1
a405 1
	char buf[MAXPATHLEN * 2];
d445 1
a445 1
	char buf[MAXPATHLEN];
d474 1
a474 1
	static char fixed[MAXPATHLEN];
@


1.44
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.43 2010/01/08 13:29:08 oga Exp $	*/
d594 1
a594 1
		memset(p, 0, len);			/* zero pw_passwd */
@


1.43
log
@Don't leak the fds we open in cp() to copy one file from another.

from Igor Zinovik; thanks!

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.42 2009/10/27 23:59:54 deraadt Exp $	*/
d78 1
d364 1
a364 2
fmt:		errno = EFTYPE;	/* XXX */
		error(pname);
d386 1
a386 2
			errno = sverrno;
			error(buf);
d393 1
a393 2
		errno = sverrno;
		error(buf);
d408 1
a408 2
		errno = sverrno;
		error(buf);
d417 9
@


1.42
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.41 2009/10/04 18:11:35 ajacoutot Exp $	*/
d397 2
@


1.41
log
@Typo: chance -> change

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.40 2008/06/25 14:51:27 millert Exp $	*/
a32 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1991, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "from: @@(#)pwd_mkdb.c	8.5 (Berkeley) 4/20/94";
#else
static const char rcsid[] = "$OpenBSD: pwd_mkdb.c,v 1.40 2008/06/25 14:51:27 millert Exp $";
#endif
#endif /* not lint */
@


1.40
log
@Add _PW_BUF_LEN define and use it instead of hard-coding 1024 for
the buffer size.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.39 2008/03/17 20:30:16 sobrado Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: pwd_mkdb.c,v 1.39 2008/03/17 20:30:16 sobrado Exp $";
d260 1
a260 1
	 * chance the file already existing, since someone (stupidly) might
@


1.39
log
@sync the synopsis and usage; "usage:" is lowercase

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.38 2004/08/08 00:05:09 deraadt Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: pwd_mkdb.c,v 1.38 2004/08/08 00:05:09 deraadt Exp $";
d493 1
a493 1
	char *p, *t, buf[LINE_MAX * 2], tbuf[1024];
@


1.38
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.37 2003/06/28 20:37:29 deraadt Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: pwd_mkdb.c,v 1.37 2003/06/28 20:37:29 deraadt Exp $";
a468 1

d470 1
a470 1
	    "usage: pwd_mkdb [-c] [-p | -s] [-d basedir] [-u username] file\n");
@


1.37
log
@() to (void)
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.36 2003/06/08 21:14:55 millert Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: pwd_mkdb.c,v 1.36 2003/06/08 21:14:55 millert Exp $";
d150 1
a150 1
	
d198 1
a198 1
        /* If only updating a single record, stash the old uid */
d384 3
a386 5
void                    
cp(from, to, mode)              
	char *from, *to;
	mode_t mode;    
{               
d414 1
a414 2
mv(from, to)
	char *from, *to;
d428 1
a428 2
error(name)
	char *name;
d437 1
a437 2
errorx(name)
	char *name;
a493 3
	int flags = 0;
	int dbmode, found = 0;
	u_int cnt;
d495 2
d499 1
a499 1
	static int firsttime = 1;
@


1.36
log
@Sanity check username length and convert to ANSI function headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.35 2003/06/02 23:36:54 millert Exp $	*/
d44 1
a44 1
static const char rcsid[] = "$OpenBSD: pwd_mkdb.c,v 1.35 2003/06/02 23:36:54 millert Exp $";
d451 1
a451 1
cleanup()
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.34 2003/04/13 18:04:07 millert Exp $	*/
d35 1
a35 1
static char copyright[] =
d42 1
a42 1
static char sccsid[] = "from: @@(#)pwd_mkdb.c	8.5 (Berkeley) 4/20/94";
d44 1
a44 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.34 2003/04/13 18:04:07 millert Exp $";
d101 1
a101 3
main(argc, argv)
	int argc;
	char *argv[];
d135 2
d293 1
a293 1
	 * We do this three times, one per key type (for getpw{name,uid,ent}).
d354 1
a354 4
scan(fp, pw, flags)
	FILE *fp;
	struct passwd *pw;
	int *flags;
d472 1
a472 1
usage()
d481 1
a481 2
changedir(path, dir)
	char *path, *dir;
d496 2
a497 9
db_store(fp, oldfp, edp, dp, pw, keytype, username, olduid)
	FILE *fp;
	FILE *oldfp;
	DB *edp;
	DB *dp;
	struct passwd *pw;
	int keytype;
	char *username;
	uid_t olduid;
@


1.34
log
@Clarify the -d option and allow the passwd file argument to not be
a fully qualified pathname if -d was specified (since we take the
basename in that case anyway).  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.33 2003/03/28 16:58:39 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d44 1
a44 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.33 2003/03/28 16:58:39 millert Exp $";
@


1.33
log
@Check strdup() rval for NULL; noticed by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.32 2002/11/21 22:13:20 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.32 2002/11/21 22:13:20 millert Exp $";
d175 1
a175 1
	if (**argv != '/')
d497 3
a499 6
	p = strrchr(path, '/');
	strlcpy(fixed, dir, sizeof fixed);
	if (p) {
		strlcat(fixed, "/", sizeof fixed);
		strlcat(fixed, p + 1, sizeof fixed);
	}
@


1.32
log
@Rename shadow group to _shadow
This means the instructions in the previous commit are now wrong
(replace shadow with _shadow and all will be well).
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.31 2002/11/21 21:25:19 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.31 2002/11/21 21:25:19 millert Exp $";
d178 2
a179 1
	pname = strdup(changedir(*argv, basedir));
@


1.31
log
@Add a "shadow" group and make the shadow passwd db readable by that
group.  This changes getpw* to always try the shadow db first and
then fall back to the db w/o password hashes.  In the future,
/usr/libexec/auth/login_passwd (and others) will be setgid shadow
instead of setuid root.  OK deraadt@@

If you track -current you should do the following:
 o add group shadow to /etc/group
 o chgrp shadow /etc/spwd.db
 o chmod 640 /etc/spwd.db
 o rebuild and install src/usr.sbin/pwd_mkdb

You do not need to rebuild libc yet, but it would't hurt to do so.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.30 2002/06/02 06:42:29 deraadt Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.30 2002/06/02 06:42:29 deraadt Exp $";
d78 1
a78 1
#define	SHADOW_GROUP	"shadow"
@


1.30
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.29 2002/05/29 18:39:00 deraadt Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.29 2002/05/29 18:39:00 deraadt Exp $";
d59 1
d78 2
d114 1
d117 1
d154 5
d236 5
@


1.29
log
@more strlcat and strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.28 2002/05/22 09:09:32 deraadt Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.28 2002/05/22 09:09:32 deraadt Exp $";
d119 1
a119 1
		switch(ch) {
@


1.28
log
@more strcpy/sprintf death; mpech ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.27 2002/02/16 21:28:08 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.27 2002/02/16 21:28:08 millert Exp $";
d484 2
a485 2
		strcat(fixed, "/");
		strcat(fixed, p + 1);
@


1.27
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.26 2001/09/17 14:30:39 mpech Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.26 2001/09/17 14:30:39 mpech Exp $";
d482 1
a482 1
	strcpy(fixed, dir);
@


1.26
log
@skip to uid field, not gid

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.25 2001/08/16 18:22:04 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.25 2001/08/16 18:22:04 millert Exp $";
d91 9
a99 9
void	cleanup __P((void));
void	error __P((char *));
void	errorx __P((char *));
void	cp __P((char *, char *, mode_t));
void	mv __P((char *, char *));
int	scan __P((FILE *, struct passwd *, int *));
void	usage __P((void));
char	*changedir __P((char *path, char *dir));
void	db_store __P((FILE *, FILE *, DB *, DB *,struct passwd *, int, char *, uid_t));
@


1.25
log
@Add -s flag to only update secure .db file (/etc/spwd.db).  Can be
used in conjunction with -u user when only the password has changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.24 2001/06/07 16:21:49 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.24 2001/06/07 16:21:49 millert Exp $";
d204 3
a206 2
				while (*p++ != '\0')
					;
@


1.24
log
@Close PR 1854; mpech@@prosoft.org.lv
o use correct db pointers
o don't try to star out an empty password
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.23 2000/11/26 19:35:46 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.23 2000/11/26 19:35:46 millert Exp $";
d113 1
a113 1
	int ch, tfd, makeold, flags = 0, checkonly = 0;
d116 1
a116 1
	makeold = 0;
d118 1
a118 1
	while ((ch = getopt(argc, argv, "cd:pu:v")) != -1)
d131 3
d146 2
a147 1
	if (argc != 1 || (username && (*username == '+' || *username == '-')))
d228 16
a243 13
	(void)snprintf(buf, sizeof(buf), "%s.tmp",
	    changedir(_PATH_MP_DB, basedir));
	if (username) {
		cp(changedir(_PATH_MP_DB, basedir), buf, PERM_INSECURE);
		dp = dbopen(buf,
		    O_RDWR, PERM_INSECURE, DB_HASH, &openinfo);
	} else {
		dp = dbopen(buf,
		    O_RDWR|O_CREAT|O_EXCL, PERM_INSECURE, DB_HASH, &openinfo);
	}
	if (dp == NULL)
		error(buf);
	clean |= FILE_INSECURE;
d297 2
a298 1
		if ((dp->put)(dp, &key, &data, R_NOOVERWRITE) == -1)
d304 1
a304 1
	if ((dp->close)(dp))
a306 1
		(void)fflush(oldfp);
d317 5
a321 3
	(void)snprintf(buf, sizeof(buf), "%s.tmp",
	    changedir(_PATH_MP_DB, basedir));
	mv(buf, changedir(_PATH_MP_DB, basedir));
d466 1
a466 1
	    "usage: pwd_mkdb [-cp] [-d basedir] [-u username] file\n");
d551 2
a552 1
				(dp->del)(dp, &key, 0);
d601 3
@


1.23
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.22 2000/11/26 01:23:12 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.22 2000/11/26 01:23:12 millert Exp $";
d288 1
a288 1
		if ((dp->put)(edp, &key, &data, R_NOOVERWRITE) == -1)
d541 1
a541 1
				(edp->del)(dp, &key, 0);
d589 1
a589 1
		if ((dp->put)(edp, &key, &data, dbmode) == -1)
d597 2
a598 1
		*p++ = '*';
@


1.23.2.1
log
@Pull in patch from current:
Errata (005):
pwd_mkdb(8) corrupts /etc/pwd.db when modifying an existing user.
Fix (millert):
Close PR 1854; mpech@@prosoft.org.lv
o use correct db pointers
o don't try to star out an empty password
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.23 2000/11/26 19:35:46 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.23 2000/11/26 19:35:46 millert Exp $";
d288 1
a288 1
		if ((edp->put)(edp, &key, &data, R_NOOVERWRITE) == -1)
d541 1
a541 1
				(edp->del)(edp, &key, 0);
d589 1
a589 1
		if ((edp->put)(edp, &key, &data, dbmode) == -1)
d597 1
a597 2
		if (len != 0)
			*p++ = '*';
@


1.22
log
@Support -u username option.  Loosely based on FreeBSD's changes.
I've also restructured things a bit to cut the number of master.passwd
parses in half from 6 to 3.  We can't really get away with fewer than
that without sacrificing locality in the .db files.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.21 2000/06/30 16:00:26 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.21 2000/06/30 16:00:26 millert Exp $";
d608 1
a608 1
		if (username && !found)
@


1.21
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.20 1999/04/21 21:15:12 alex Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.20 1999/04/21 21:15:12 alex Exp $";
d73 4
a85 2
static enum state { FILE_INSECURE, FILE_SECURE, FILE_ORIG } clean;
static struct passwd pwd;			/* password structure */
d88 1
d93 2
d99 1
a99 1
void	db_store __P((FILE *, FILE *, DB *, struct passwd *, int, int));
d107 1
a107 1
	DBT ypdata, ypkey;
d110 1
d112 1
d114 1
a114 1
	char buf[MAXPATHLEN];
d117 2
a118 1
	while ((ch = getopt(argc, argv, "cpvd:")) != -1)
d123 5
d131 3
a135 5
		case 'd':
			basedir = optarg;
			if (strlen(basedir) > MAXPATHLEN - 40)
				errx(1, "basedir too long");
			break;
d143 1
a143 1
	if (argc != 1)
d181 1
a181 3
	/*
	 * Tweak openinfo values for large passwd files.
	 */
d187 36
d226 8
a233 2
	dp = dbopen(buf,
	    O_RDWR|O_CREAT|O_EXCL, PERM_INSECURE, DB_HASH, &openinfo);
d236 1
a236 1
	clean = FILE_INSECURE;
d252 1
a252 1
		clean = FILE_ORIG;
d272 1
a272 1
	 * Write "insecure" (no passwd) version of the .db file.
d277 3
a279 3
	db_store(fp, makeold ? oldfp : NULL, dp, &pwd, _PW_KEYBYNAME, 1);
	db_store(fp, makeold ? oldfp : NULL, dp, &pwd, _PW_KEYBYUID, 1);
	db_store(fp, makeold ? oldfp : NULL, dp, &pwd, _PW_KEYBYNUM, 1);
d282 5
a286 5
	if (hasyp) {
		ypkey.data = (u_char *)_PW_YPTOKEN;
		ypkey.size = strlen(_PW_YPTOKEN);
		ypdata.data = (u_char *)NULL;
		ypdata.size = 0;
d288 3
a290 1
		if ((dp->put)(dp, &ypkey, &ypdata, R_NOOVERWRITE) == -1)
d294 2
a303 31
	/* Open the temporary encrypted password database. */
	(void)snprintf(buf, sizeof(buf), "%s.tmp",
	    changedir(_PATH_SMP_DB, basedir));
	edp = dbopen(buf,
	    O_RDWR|O_CREAT|O_EXCL, PERM_SECURE, DB_HASH, &openinfo);
	if (!edp)
		error(buf);
	clean = FILE_SECURE;

	/*
	 * Write "secure" (including passwd) info to the .db file.
	 * We do this three times, one per key type (for getpw{name,uid,ent}).
	 */
	db_store(fp, makeold ? oldfp : NULL, edp, &pwd, _PW_KEYBYNAME, 0);
	db_store(fp, makeold ? oldfp : NULL, edp, &pwd, _PW_KEYBYUID, 0);
	db_store(fp, makeold ? oldfp : NULL, edp, &pwd, _PW_KEYBYNUM, 0);

	/* Store YP token, if needed. */
	if (hasyp) {
		ypkey.data = (u_char *)_PW_YPTOKEN;
		ypkey.size = strlen(_PW_YPTOKEN);
		ypdata.data = (u_char *)NULL;
		ypdata.size = 0;

		if ((edp->put)(edp, &ypkey, &ypdata, R_NOOVERWRITE) == -1)
			error("put");
	}

	if ((edp->close)(edp))
		error("close edp");

d365 31
d400 1
a400 1
	char buf[MAXPATHLEN];
d404 1
d422 10
d436 1
a436 2
	switch(clean) {
	case FILE_ORIG:
d439 2
a440 2
		/* FALLTHROUGH */
	case FILE_SECURE:
d444 2
a445 2
		/* FALLTHROUGH */
	case FILE_INSECURE:
d456 2
a457 1
	(void)fprintf(stderr, "usage: pwd_mkdb [-cp] [-d basedir] file\n");
d481 1
a481 1
db_store(fp, oldfp, dp, pw, keytype, insecure)
d484 1
d488 2
a489 1
	int insecure;
d492 1
d499 3
d531 36
a566 1
		/* Create data (a packed struct passwd). */
d568 1
d571 1
a571 1
		COMPACT(insecure ? "*" : pw->pw_passwd);
d588 3
a590 6
		/* Build the key. */
		switch (keytype) {
		case _PW_KEYBYNUM:
			memmove(tbuf + 1, &cnt, sizeof(cnt));
			key.size = sizeof(cnt) + 1;
			break;
d592 9
a600 12
		case _PW_KEYBYNAME:
			len = strlen(pw->pw_name);
			memmove(tbuf + 1, pw->pw_name, len);
			key.size = len + 1;
			break;

		case _PW_KEYBYUID:
			memmove(tbuf + 1, &pw->pw_uid, sizeof(pw->pw_uid));
			key.size = sizeof(pw->pw_uid) + 1;
			break;
		}
		tbuf[0] = keytype;
d602 2
a603 2
		/* Write the record. */
		if ((dp->put)(dp, &key, &data, R_NOOVERWRITE) == -1)
d606 1
a606 1
	if (firsttime)
d608 3
@


1.20
log
@Don't display the string associated with errno for "basedir too long"
diagnostic.

Issue a diagnostic message if the master.passwd file isn't specified as an
absolute path.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.19 1998/07/15 19:33:28 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.19 1998/07/15 19:33:28 millert Exp $";
d360 1
a360 1
	warn(name);
@


1.20.4.1
log
@Pull in patch from current:
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.21 2000/06/30 16:00:26 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.21 2000/06/30 16:00:26 millert Exp $";
d360 1
a360 1
	warn("%s", name);
@


1.19
log
@Fix a u_int vs. off_t issue and provide an estimate of the number
of elements in the hash based on master.passwd file size, assuming
an average 128bytes per entry.  This is only an estimate so it doesn't
have to be exact.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.18 1998/07/15 00:50:19 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.18 1998/07/15 00:50:19 millert Exp $";
d123 1
a123 1
				error("basedir too long");
d149 3
@


1.18
log
@Move loop that is executed 6 times into its own function to improve readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.17 1998/07/14 23:26:33 millert Exp $	*/
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.17 1998/07/14 23:26:33 millert Exp $";
d167 7
a173 8
	if (st.st_size > (off_t)100*1024) {
		/*
		 * It is a large file. We are going to crank db's cache size.
		 */
		openinfo.cachesize = st.st_size * 20;
		if (openinfo.cachesize > 12*1024*1024)
			openinfo.cachesize = 12*1024*1024;
	}
@


1.17
log
@sizeof(uid_t) and sizeof(gid_t) not sizeof(int)
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.16 1998/07/14 16:13:03 millert Exp $	*/
d6 2
a7 1
 * Portions Copyright(C) 1994, Jason Downs.  All rights reserved.
d48 1
a48 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.16 1998/07/14 16:13:03 millert Exp $";
d85 2
a86 1
static char *basedir;
d94 1
d102 2
a103 2
	DBT data, key;
	FILE *fp, *oldfp;
d106 2
a107 6
	int ch, cnt, len, makeold, tfd, flags = 0;
	char *p, *t;
	char buf[MAX(MAXPATHLEN, LINE_MAX * 2)], tbuf[1024];
	int hasyp = 0;
	int cflag = 0;
	DBT ypdata, ypkey;
d113 1
a113 1
			cflag = 1;
d156 3
a158 1
	if (cflag) {
a216 3
	data.data = (u_char *)buf;
	key.data = (u_char *)tbuf;
#define	COMPACT(e)	t = e; while (*p++ = *t++);
d219 4
a222 6
	 * Write "insecure" (no passwd) info to the .db file.
	 * We do the loop three times, one per key type, to get good
	 * locality in the db file.
	 * 1) Store by name, check for YP, issue warnings and save V7 format.
	 * 2) Store by uid.
	 * 3) Store by number (used for iterative lookups).
d224 3
a226 109
	for (cnt = 1; scan(fp, &pwd, &flags); ++cnt) {

		/* look like YP? */
		if ((pwd.pw_name[0] == '+') || (pwd.pw_name[0] == '-'))
			hasyp++;

		/* Warn about potentially unsafe uid/gid overrides. */
		if (pwd.pw_name[0] == '+') {
			if ((flags & _PASSWORD_NOUID) == 0 && pwd.pw_uid == 0)
				warnx("line %d: superuser override in YP inclusion", cnt);
			if ((flags & _PASSWORD_NOGID) == 0 && pwd.pw_gid == 0)
				warnx("line %d: wheel override in YP inclusion", cnt);
		}

		/* Create insecure data. */
		p = buf;
		COMPACT(pwd.pw_name);
		COMPACT("*");
		memmove(p, &pwd.pw_uid, sizeof(uid_t));
		p += sizeof(uid_t);
		memmove(p, &pwd.pw_gid, sizeof(gid_t));
		p += sizeof(gid_t);
		memmove(p, &pwd.pw_change, sizeof(time_t));
		p += sizeof(time_t);
		COMPACT(pwd.pw_class);
		COMPACT(pwd.pw_gecos);
		COMPACT(pwd.pw_dir);
		COMPACT(pwd.pw_shell);
		memmove(p, &pwd.pw_expire, sizeof(time_t));
		p += sizeof(time_t);
		memmove(p, &flags, sizeof(int));
		p += sizeof(int);
		data.size = p - buf;

		/* Store insecure by name. */
		tbuf[0] = _PW_KEYBYNAME;
		len = strlen(pwd.pw_name);
		memmove(tbuf + 1, pwd.pw_name, len);
		key.size = len + 1;
		if ((dp->put)(dp, &key, &data, R_NOOVERWRITE) == -1)
			error("put");

		/* Create original format password file entry */
		if (makeold)
			if (fprintf(oldfp, "%s:*:%u:%u:%s:%s:%s\n",
			    pwd.pw_name, pwd.pw_uid, pwd.pw_gid, pwd.pw_gecos,
			    pwd.pw_dir, pwd.pw_shell) == EOF)
				error("write old");
	}
	rewind(fp);
	for (cnt = 1; scan(fp, &pwd, &flags); ++cnt) {

		/* Create insecure data. */
		p = buf;
		COMPACT(pwd.pw_name);
		COMPACT("*");
		memmove(p, &pwd.pw_uid, sizeof(uid_t));
		p += sizeof(uid_t);
		memmove(p, &pwd.pw_gid, sizeof(gid_t));
		p += sizeof(gid_t);
		memmove(p, &pwd.pw_change, sizeof(time_t));
		p += sizeof(time_t);
		COMPACT(pwd.pw_class);
		COMPACT(pwd.pw_gecos);
		COMPACT(pwd.pw_dir);
		COMPACT(pwd.pw_shell);
		memmove(p, &pwd.pw_expire, sizeof(time_t));
		p += sizeof(time_t);
		memmove(p, &flags, sizeof(int));
		p += sizeof(int);
		data.size = p - buf;

		/* Store insecure by uid. */
		tbuf[0] = _PW_KEYBYUID;
		memmove(tbuf + 1, &pwd.pw_uid, sizeof(pwd.pw_uid));
		key.size = sizeof(pwd.pw_uid) + 1;
		if ((dp->put)(dp, &key, &data, R_NOOVERWRITE) == -1)
			error("put");
	}
	rewind(fp);
	for (cnt = 1; scan(fp, &pwd, &flags); ++cnt) {

		/* Create insecure data. */
		p = buf;
		COMPACT(pwd.pw_name);
		COMPACT("*");
		memmove(p, &pwd.pw_uid, sizeof(uid_t));
		p += sizeof(uid_t);
		memmove(p, &pwd.pw_gid, sizeof(gid_t));
		p += sizeof(gid_t);
		memmove(p, &pwd.pw_change, sizeof(time_t));
		p += sizeof(time_t);
		COMPACT(pwd.pw_class);
		COMPACT(pwd.pw_gecos);
		COMPACT(pwd.pw_dir);
		COMPACT(pwd.pw_shell);
		memmove(p, &pwd.pw_expire, sizeof(time_t));
		p += sizeof(time_t);
		memmove(p, &flags, sizeof(int));
		p += sizeof(int);
		data.size = p - buf;

		/* Store insecure by number. */
		tbuf[0] = _PW_KEYBYNUM;
		memmove(tbuf + 1, &cnt, sizeof(cnt));
		key.size = sizeof(cnt) + 1;
		if ((dp->put)(dp, &key, &data, R_NOOVERWRITE) == -1)
			error("put");
	}
d258 1
a258 5
	 * We do the loop three times, one per key type, to get good
	 * locality in the db file.
	 * 1) Store by name.
	 * 2) Store by uid.
	 * 3) Store by number (used for iterative lookups).
d260 3
a262 91
	rewind(fp);
	for (cnt = 1; scan(fp, &pwd, &flags); ++cnt) {

		/* Create secure data. */
		p = buf;
		COMPACT(pwd.pw_name);
		COMPACT(pwd.pw_passwd);
		memmove(p, &pwd.pw_uid, sizeof(uid_t));
		p += sizeof(int);
		memmove(p, &pwd.pw_gid, sizeof(gid_t));
		p += sizeof(int);
		memmove(p, &pwd.pw_change, sizeof(time_t));
		p += sizeof(time_t);
		COMPACT(pwd.pw_class);
		COMPACT(pwd.pw_gecos);
		COMPACT(pwd.pw_dir);
		COMPACT(pwd.pw_shell);
		memmove(p, &pwd.pw_expire, sizeof(time_t));
		p += sizeof(time_t);
		memmove(p, &flags, sizeof(int));
		p += sizeof(int);
		data.size = p - buf;

		/* Store secure by name. */
		tbuf[0] = _PW_KEYBYNAME;
		len = strlen(pwd.pw_name);
		memmove(tbuf + 1, pwd.pw_name, len);
		key.size = len + 1;
		if ((edp->put)(edp, &key, &data, R_NOOVERWRITE) == -1)
			error("put");
	}
	rewind(fp);
	for (cnt = 1; scan(fp, &pwd, &flags); ++cnt) {

		/* Create secure data. */
		p = buf;
		COMPACT(pwd.pw_name);
		COMPACT(pwd.pw_passwd);
		memmove(p, &pwd.pw_uid, sizeof(uid_t));
		p += sizeof(int);
		memmove(p, &pwd.pw_gid, sizeof(gid_t));
		p += sizeof(int);
		memmove(p, &pwd.pw_change, sizeof(time_t));
		p += sizeof(time_t);
		COMPACT(pwd.pw_class);
		COMPACT(pwd.pw_gecos);
		COMPACT(pwd.pw_dir);
		COMPACT(pwd.pw_shell);
		memmove(p, &pwd.pw_expire, sizeof(time_t));
		p += sizeof(time_t);
		memmove(p, &flags, sizeof(int));
		p += sizeof(int);
		data.size = p - buf;

		/* Store secure by uid. */
		tbuf[0] = _PW_KEYBYUID;
		memmove(tbuf + 1, &pwd.pw_uid, sizeof(pwd.pw_uid));
		key.size = sizeof(pwd.pw_uid) + 1;
		if ((edp->put)(edp, &key, &data, R_NOOVERWRITE) == -1)
			error("put");
	}
	rewind(fp);
	for (cnt = 1; scan(fp, &pwd, &flags); ++cnt) {

		/* Create secure data. */
		p = buf;
		COMPACT(pwd.pw_name);
		COMPACT(pwd.pw_passwd);
		memmove(p, &pwd.pw_uid, sizeof(uid_t));
		p += sizeof(int);
		memmove(p, &pwd.pw_gid, sizeof(gid_t));
		p += sizeof(int);
		memmove(p, &pwd.pw_change, sizeof(time_t));
		p += sizeof(time_t);
		COMPACT(pwd.pw_class);
		COMPACT(pwd.pw_gecos);
		COMPACT(pwd.pw_dir);
		COMPACT(pwd.pw_shell);
		memmove(p, &pwd.pw_expire, sizeof(time_t));
		p += sizeof(time_t);
		memmove(p, &flags, sizeof(int));
		p += sizeof(int);
		data.size = p - buf;

		/* Store secure by number. */
		tbuf[0] = _PW_KEYBYNUM;
		memmove(tbuf + 1, &cnt, sizeof(cnt));
		key.size = sizeof(cnt) + 1;
		if ((edp->put)(edp, &key, &data, R_NOOVERWRITE) == -1)
			error("put");
	}
d294 1
d410 94
@


1.16
log
@Get rid of unused empty file, pw_scan.h.  Nothing uses it anymore.
When building .db versions of passwd and master.passwd, go split
the loops into three (one per key type) so that we get good locality
withing the .db file for getnext style operations (getpwent).  With
this change I see about a 20% speedup of getpwent() on very large
passwd files.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.15 1998/06/10 09:00:48 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.15 1998/06/10 09:00:48 deraadt Exp $";
d221 1
a221 1
	 * Write "insecure" (V7 style) info to the .db file.
d224 1
a224 1
	 * 1) Store by name, check for yp, issue warnings.
d272 1
a272 1
			if (fprintf(oldfp, "%s:*:%d:%d:%s:%s:%s\n",
a335 1

d367 1
a367 1
	 * Write "secure" (master.passwd) info to the .db file.
d381 1
a381 1
		memmove(p, &pwd.pw_uid, sizeof(int));
d383 1
a383 1
		memmove(p, &pwd.pw_gid, sizeof(int));
d412 1
a412 1
		memmove(p, &pwd.pw_uid, sizeof(int));
d414 1
a414 1
		memmove(p, &pwd.pw_gid, sizeof(int));
d442 1
a442 1
		memmove(p, &pwd.pw_uid, sizeof(int));
d444 1
a444 1
		memmove(p, &pwd.pw_gid, sizeof(int));
@


1.15
log
@clear flag before pw_scan(); lukem
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.14 1998/04/26 10:10:51 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.14 1998/04/26 10:10:51 deraadt Exp $";
d156 1
a156 1
	/* check only if password database is valid */
d218 10
a228 1
#define	COMPACT(e)	t = e; while (*p++ = *t++);
d246 4
a249 4
		memmove(p, &pwd.pw_uid, sizeof(int));
		p += sizeof(int);
		memmove(p, &pwd.pw_gid, sizeof(int));
		p += sizeof(int);
d270 29
a298 6
		/* Store insecure by number. */
		tbuf[0] = _PW_KEYBYNUM;
		memmove(tbuf + 1, &cnt, sizeof(cnt));
		key.size = sizeof(cnt) + 1;
		if ((dp->put)(dp, &key, &data, R_NOOVERWRITE) == -1)
			error("put");
d306 30
a336 6
		/* Create original format password file entry */
		if (makeold)
			if (fprintf(oldfp, "%s:*:%d:%d:%s:%s:%s\n",
			    pwd.pw_name, pwd.pw_uid, pwd.pw_gid, pwd.pw_gecos,
			    pwd.pw_dir, pwd.pw_shell) == EOF)
				error("write old");
d367 8
d405 3
d409 19
a427 6
		/* Store secure by number. */
		tbuf[0] = _PW_KEYBYNUM;
		memmove(tbuf + 1, &cnt, sizeof(cnt));
		key.size = sizeof(cnt) + 1;
		if ((edp->put)(edp, &key, &data, R_NOOVERWRITE) == -1)
			error("put");
d436 30
d517 1
a517 1
	if (!fgets(line, sizeof(line), fp))
d525 2
a526 1
	if (!(p = strchr(line, '\n'))) {
a528 1

@


1.14
log
@use correct db pointer; fair
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.13 1998/04/26 10:08:42 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.13 1998/04/26 10:08:42 deraadt Exp $";
d103 1
a103 1
	int ch, cnt, len, makeold, tfd, flags;
d421 1
@


1.13
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.12 1997/12/08 07:34:29 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.12 1997/12/08 07:34:29 deraadt Exp $";
d339 1
a339 1
		if ((dp->put)(edp, &key, &data, R_NOOVERWRITE) == -1)
d346 1
a346 1
		if ((dp->put)(edp, &key, &data, R_NOOVERWRITE) == -1)
d353 1
a353 1
		if ((dp->put)(edp, &key, &data, R_NOOVERWRITE) == -1)
d364 1
a364 1
		if ((dp->put)(edp, &ypkey, &ypdata, R_NOOVERWRITE) == -1)
@


1.12
log
@first cut at performance enhancing heuristic
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.11 1997/09/15 10:15:27 deraadt Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.11 1997/09/15 10:15:27 deraadt Exp $";
d222 1
a222 1
		if((pwd.pw_name[0] == '+') || (pwd.pw_name[0] == '-'))
d284 1
a284 1
	if(hasyp) {
d358 1
a358 1
	if(hasyp) {
d364 1
a364 1
		if((dp->put)(edp, &ypkey, &ypdata, R_NOOVERWRITE) == -1)
@


1.11
log
@When the disk gets full, abort properly instead of creating empty
passwd databases. I found this while analysing netbsd pr#1328 from
August 10, 1995 by hag@@gnu.ai.mit.edu.  A sample fix was supplied on
14, May 96 by greywolf@@defender.VAS.viewlogic.com.  The PR mentioned
about 6 or 7 places where this could happen.  Greywolf and I had made
all of the fixes ourselves in openbsd a while back (except one subtle
one which he pointed out but I had missed), but not a single one of
the fixes is found in the netbsd source tree...  I wonder if Perry has
an exploit for this problem, and perhaps he's using it?
Another damn good reason for making /tmp and /var seperate partitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.10 1997/01/16 03:58:23 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.10 1997/01/16 03:58:23 millert Exp $";
d101 1
d158 2
a159 1
		for (cnt = 1; scan(fp, &pwd, &flags); ++cnt);
d161 12
@


1.10
log
@From NetBSD: Warn about potentially unsafe uid/gid overrides.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.9 1997/01/15 23:44:14 millert Exp $	*/
d47 1
a47 1
static char *rcsid = "$OpenBSD: pwd_mkdb.c,v 1.9 1997/01/15 23:44:14 millert Exp $";
d359 2
a360 1
	(void)fclose(fp);
@


1.9
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 2
a2 1
/*	$OpenBSD: pwd_mkdb.c,v 1.8 1996/10/16 09:16:14 downsj Exp $	*/
d44 5
a48 2
/*static char sccsid[] = "from: @@(#)pwd_mkdb.c	8.5 (Berkeley) 4/20/94";*/
static char *rcsid = "$Id: pwd_mkdb.c,v 1.8 1996/10/16 09:16:14 downsj Exp $";
d210 8
@


1.8
log
@kill __yp_token.
@
text
@d1 1
a1 1
/*	$OpenBSD: pwd_mkdb.c,v 1.7 1996/09/28 05:44:33 downsj Exp $	*/
d44 1
a44 1
static char *rcsid = "$Id: pwd_mkdb.c,v 1.7 1996/09/28 05:44:33 downsj Exp $";
d106 1
a106 1
	while ((ch = getopt(argc, argv, "cpvd:")) != EOF)
@


1.7
log
@Add -c flag from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
static char *rcsid = "$Id: pwd_mkdb.c,v 1.6 1996/08/30 14:24:48 deraadt Exp $";
a67 3
/* pull this out of the C library. */
extern const char __yp_token[];

d259 2
a260 2
		ypkey.data = (u_char *)__yp_token;
		ypkey.size = strlen(__yp_token);
d333 2
a334 2
		ypkey.data = (u_char *)__yp_token;
		ypkey.size = strlen(__yp_token);
@


1.6
log
@limit basedir length
@
text
@d1 1
d44 1
a44 1
static char *rcsid = "$Id: pwd_mkdb.c,v 1.5 1996/05/22 11:35:54 deraadt Exp $";
d105 1
d109 1
a109 1
	while ((ch = getopt(argc, argv, "pvd:")) != EOF)
d111 3
d154 6
d456 1
a456 1
	(void)fprintf(stderr, "usage: pwd_mkdb [-p] [-d basedir] file\n");
@


1.5
log
@libutil
@
text
@d43 1
a43 1
static char *rcsid = "$Id: pwd_mkdb.c,v 1.4 1996/05/14 01:06:15 deraadt Exp $";
d116 2
@


1.4
log
@looks like greywolf and i fixed netbsd pr#1328. pwd_mkdb on a filled root
filesystem would result in gibbled passwd databases.
@
text
@d43 1
a43 1
static char *rcsid = "$Id: pwd_mkdb.c,v 1.3 1996/05/04 08:13:54 deraadt Exp $";
d60 1
a60 2

#include "pw_scan.h"
@


1.3
log
@strdup re-generated path in pwd_mkdb; "make distribution" passwd files with
proper arguments
@
text
@d43 1
a43 1
static char *rcsid = "$Id: pwd_mkdb.c,v 1.2 1996/04/23 21:55:49 deraadt Exp $";
d242 1
a242 1
			(void)fprintf(oldfp, "%s:*:%d:%d:%s:%s:%s\n",
d244 2
a245 1
			    pwd.pw_dir, pwd.pw_shell);
d259 2
a260 1
	(void)(dp->close)(dp);
d263 2
a264 1
		(void)fclose(oldfp);
d333 2
a334 1
	(void)(edp->close)(edp);
@


1.2
log
@add "-d basedir" flag to pwd_mkdb. the use of "chroot" is incompatible
with our cross compilation/installation goals...
@
text
@d43 1
a43 1
static char *rcsid = "$Id: pwd_mkdb.c,v 1.1.1.1 1995/10/18 08:48:01 deraadt Exp $";
d143 1
a143 1
	pname = *argv;
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
static char *rcsid = "$Id: pwd_mkdb.c,v 1.6 1995/07/28 07:13:52 phil Exp $";
d83 1
d90 1
d108 1
a108 1
	while ((ch = getopt(argc, argv, "pv")) != EOF)
d115 3
d149 2
a150 1
	(void)snprintf(buf, sizeof(buf), "%s.tmp", _PATH_MP_DB);
d265 2
a266 1
	(void)snprintf(buf, sizeof(buf), "%s.tmp", _PATH_SMP_DB);
d337 6
a342 4
	(void)snprintf(buf, sizeof(buf), "%s.tmp", _PATH_MP_DB);
	mv(buf, _PATH_MP_DB);
	(void)snprintf(buf, sizeof(buf), "%s.tmp", _PATH_SMP_DB);
	mv(buf, _PATH_SMP_DB);
d345 1
a345 1
		mv(buf, _PATH_PASSWD);
d353 1
a353 1
	mv(pname, _PATH_MASTERPASSWD);
d425 2
a426 1
		(void)snprintf(buf, sizeof(buf), "%s.tmp", _PATH_SMP_DB);
d430 2
a431 1
		(void)snprintf(buf, sizeof(buf), "%s.tmp", _PATH_MP_DB);
d440 1
a440 1
	(void)fprintf(stderr, "usage: pwd_mkdb [-p] file\n");
d442 19
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
