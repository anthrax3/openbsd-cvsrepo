head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11;
locks; strict;
comment	@ * @;


1.19
date	2015.08.20.22.39.30;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	z3HrihslRYb4HqW9;

1.18
date	2015.01.16.06.40.23;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2014.09.27.06.28.45;	author doug;	state Exp;
branches;
next	1.16;
commitid	f4Emp3aOD3XoUoYk;

1.16
date	2013.12.31.07.16.50;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2009.11.10.04.34.38;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.17.10.07.30;	author robert;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.29.21.13.56;	author robert;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.23.17.50.30;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.21.16.38.55;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.28.17.01.40;	author uwe;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.28.16.44.28;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.28.07.02.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.28.06.58.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.25.02.52.00;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.25.00.28.12;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.24.23.43.15;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.24.23.02.40;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.24.18.50.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.24.18.46.47;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.19
log
@stdlib.h is in scope; do not cast malloc/calloc/realloc*
ok millert krw
@
text
@/*	$OpenBSD: ztsscale.c,v 1.18 2015/01/16 06:40:23 deraadt Exp $	*/

/*
 * Copyright (c) 2005 Matthieu Herrb
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <machine/cpu.h>
#include <dev/wscons/wsconsio.h>

#include <err.h>
#include <fcntl.h>
#include <math.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "message.xbm"

#define TITLE_Y		64
#define MESSAGE_Y	128

#define WIDTH	640
#define HEIGHT	480
#define BLACK	0x0
#define RED	0xf000
#define WHITE	0xffff

#define ADDR(x,y) (HEIGHT*(x)+(y))

u_short		*mapaddr, *save;
int		 orawmode = -1;
int		 fd, mfd;
int		 xc[] = { 25, 25, 320, 615, 615 };
int		 yc[] = { 25, 455, 240, 25, 455 };

struct wsmouse_calibcoords wmcoords;

void		bitmap(u_short *, u_short, u_char[], int, int, int);
void		cross(u_short *, int, int);
void		wait_event(int, int *, int *);
void		save_screen(void);
void		restore_screen(void);
void		cleanup(void);
void		sighandler(int);
int		main(int, char *[]);
__dead void	usage(void);

void
bitmap(u_short *fb, u_short pixel, u_char bits[], int width, int height,
    int y)
{
	int i, j;
	int x;

#define BITADDR(x, y)	((width + 7)/8*(y) + (x)/8)
#define BITMASK(x)	(1 << ((x) % 8))

	for (i = 0; i < height; i++) {
		x = (WIDTH - width)/2;
		for (j = 0; j < width; j++)
			if (bits[BITADDR(j, i)] & BITMASK(j))
				fb[ADDR(x + j, HEIGHT - y - i)] = pixel;
	}
}

void
cross(u_short *fb, int x, int y)
{
	int i;

	y = HEIGHT - y;
	for (i = x - 20; i <= x + 20; i++)
		fb[ADDR(i, y)] = BLACK;
	for (i = y - 20; i <= y + 20; i++)
		fb[ADDR(x, i)] = BLACK;
}

void
wait_event(int mfd, int *x, int *y)
{
	int down;
	ssize_t len;
	struct wscons_event evbuf;

	down = 0;
	*x = *y = -1;
	while (down || *x == -1 || *y == -1) {
		len = read(mfd, &evbuf, sizeof(evbuf));
		if (len != sizeof(evbuf))
			break;
		switch (evbuf.type) {
		case WSCONS_EVENT_MOUSE_DOWN:
			down = 1;
			break;
		case WSCONS_EVENT_MOUSE_UP:
			down = 0;
			break;
		case WSCONS_EVENT_MOUSE_ABSOLUTE_X:
			if (down)
				*x = evbuf.value;
			break;
		case WSCONS_EVENT_MOUSE_ABSOLUTE_Y:
			if (down)
				*y = evbuf.value;
			break;
		}
	}
}

void
save_screen(void)
{
	int mode = WSDISPLAYIO_MODE_DUMBFB;

	if (ioctl(fd, WSDISPLAYIO_SMODE, &mode) == -1)
		warn("ioctl SMODE");
	mapaddr = mmap(0, WIDTH*HEIGHT*sizeof(short),
	    PROT_READ|PROT_WRITE, MAP_SHARED, fd, (off_t)0);
	if (mapaddr == MAP_FAILED)
		err(2, "mmap");
	save = malloc(WIDTH*HEIGHT*sizeof(u_short));
	if (save == NULL)
		err(2, "malloc");
	memcpy(save, mapaddr, WIDTH*HEIGHT*sizeof(u_short));
}

void
restore_screen(void)
{
	int mode = WSDISPLAYIO_MODE_EMUL;

	memcpy(mapaddr, save, WIDTH*HEIGHT*sizeof(u_short));
	if (ioctl(fd, WSDISPLAYIO_SMODE, &mode) == -1)
		warn("ioctl SMODE");
}

void
cleanup(void)
{

	restore_screen();

	wmcoords.samplelen = orawmode;
	if (wmcoords.samplelen != -1 &&
	    ioctl(mfd, WSMOUSEIO_SCALIBCOORDS, &wmcoords) < 0)
		err(1, "WSMOUSEIO_SCALIBCOORDS");

	close(mfd);
}

/* ARGSUSED */
void
sighandler(int sig)
{

	cleanup();
	_exit(2);
}

/*ARGSUSED*/
int
main(int argc, char *argv[])
{
	int i, x[5], y[5];
	double a, a1, a2, b, b1, b2, xerr, yerr;
	struct ztsscale {
		int ts_minx;
		int ts_maxx;
		int ts_miny;
		int ts_maxy;
		int ts_swapxy;
	} ts;

	if (argc != 1)
		usage();

	fd = open("/dev/ttyC0", O_RDWR);
	if (fd < 0)
		err(2, "open /dev/ttyC0");
	save_screen();

	mfd = open("/dev/wsmouse", O_RDWR);
	if (mfd < 0) {
		restore_screen();
		err(2, "open /dev/wsmouse");
	}

	if (ioctl(mfd, WSMOUSEIO_GCALIBCOORDS, &wmcoords) < 0) {
		restore_screen();
                err(1, "WSMOUSEIO_GCALIBCOORDS");
	}

	/* Save the old rawmode value then switch rawmode on */ 
	orawmode = wmcoords.samplelen;
	wmcoords.samplelen = 1;

	if (ioctl(mfd, WSMOUSEIO_SCALIBCOORDS, &wmcoords) < 0) {
		restore_screen();
		err(1, "WSMOUSEIO_SCALIBCOORDS");
	}

again:
	signal(SIGINT, sighandler);
	for (i = 0; i < 5; i++) {
		memset(mapaddr, WHITE, WIDTH*HEIGHT*sizeof(u_short));
		bitmap(mapaddr, BLACK, title_bits, title_width,
		    title_height, TITLE_Y);
		bitmap(mapaddr, BLACK, message_bits, message_width,
		    message_height, MESSAGE_Y);
		cross(mapaddr, xc[i], yc[i]);
		/* printf("waiting for event\n"); */
		wait_event(mfd, &x[i], &y[i]);
	}

	bzero(&ts, sizeof(ts));

	/* get touch pad resolution to screen resolution ratio */
	a1 = (double)(x[4] - x[0])/(double)(xc[4] - xc[0]);
	a2 = (double)(x[3] - x[1])/(double)(xc[3] - xc[1]);
	/* get the minimum pad position on the X-axis */
	b1 = x[0] - a1*xc[0];
	b2 = x[1] - a2*xc[1];
	/* use the average ratio and average minimum position */
	a = (a1+a2)/2.0;
	b = (b1+b2)/2.0;
	xerr = a*WIDTH/2+b - x[2];
	if (fabs(xerr) > (a*WIDTH+b)*.01) {
#ifdef DEBUG
		fprintf(stderr, "X error (%.2f) too high, try again\n",
		    fabs(xerr));
#endif
		goto err;
	}

	ts.ts_minx = (int)(b+0.5);
	ts.ts_maxx = (int)(a*WIDTH+b+0.5);

	/* get touch pad resolution to screen resolution ratio */
	a1 = (double)(y[4] - y[0])/(double)(yc[4] - yc[0]);
	a2 = (double)(y[3] - y[1])/(double)(yc[3] - yc[1]);
	/* get the minimum pad position on the Y-axis */
	b1 = y[0] - a1*yc[0];
	b2 = y[1] - a2*yc[1];
	/* use the average ratio and average minimum position */
	a = (a1+a2)/2.0;
	b = (b1+b2)/2.0;
	yerr = a*HEIGHT/2+b - y[2];
	if (fabs(yerr) > (a*HEIGHT+b)*.01) {
#ifdef DEBUG
		fprintf(stderr, "Y error (%.2f) too high, try again\n",
		    fabs(yerr));
#endif
		goto err;
	}

	ts.ts_miny = (int)(b+0.5);
	ts.ts_maxy = (int)(a*HEIGHT+b+0.5);

	cleanup();

	(void)printf("mouse.scale=%d,%d,%d,%d,%d,%d,%d\n", ts.ts_minx, ts.ts_maxx,
	    ts.ts_miny, ts.ts_maxy, ts.ts_swapxy, WIDTH, HEIGHT);
	return 0;

err:
	memset(mapaddr, WHITE, WIDTH*HEIGHT*sizeof(u_short));
	bitmap(mapaddr, BLACK, title_bits, title_width, title_height,
	    TITLE_Y);
	bitmap(mapaddr, RED, error_bits, error_width, error_height,
	    MESSAGE_Y);
	sleep(2);
	goto again;
}

__dead void
usage(void)
{
	extern char *__progname;

	(void)fprintf(stderr, "usage: %s\n", __progname);
	exit(2);
}
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.17 2014/09/27 06:28:45 doug Exp $	*/
d138 1
a138 1
	save = (u_short *)malloc(WIDTH*HEIGHT*sizeof(u_short));
@


1.17
log
@Fix mmap() calls that check for a result other than MAP_FAILED.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.16 2013/12/31 07:16:50 matthieu Exp $	*/
d19 1
a19 1
#include <sys/param.h>
@


1.16
log
@Fix after struct wscons_event size change.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.15 2009/11/10 04:34:38 deraadt Exp $	*/
d134 1
a134 1
	mapaddr = (void *)mmap(0, WIDTH*HEIGHT*sizeof(short),
d136 1
a136 1
	if (mapaddr == (void *)-1)
@


1.15
log
@lint prompted cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.14 2007/06/17 10:07:30 robert Exp $	*/
d106 1
a106 1
		if (len != 16)
@


1.14
log
@do not try to reopen the wsmouse device when
the calibration was not accurate enough and
keep the device open all the time since there is
no need to close and reopen it if we need to retry.
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.13 2007/05/29 21:13:56 robert Exp $	*/
d161 2
a162 1
	if (wmcoords.samplelen != -1 && ioctl(mfd, WSMOUSEIO_SCALIBCOORDS, &wmcoords) < 0)
d177 1
a182 1
	size_t oldsize;
@


1.13
log
@adapt ztsscale and the installer to use wscons ioctls for calibration;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.12 2007/02/23 17:50:30 deraadt Exp $	*/
a164 1

a197 1
again:
d218 1
a228 7
	}

	/* Restore rawmode state */
	wmcoords.samplelen = orawmode;
	if (ioctl(mfd, WSMOUSEIO_SCALIBCOORDS, &wmcoords) < 0) {
		restore_screen();
		err(1, "WSMOUSEIO_SCALIBCOORDS");
@


1.12
log
@remove some lint
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.11 2005/07/21 16:38:55 fgsch Exp $	*/
a21 1
#include <sys/sysctl.h>
d49 1
a49 1
int		 fd;
d53 1
a53 3
int		mib[2] = { CTL_MACHDEP, CPU_ZTSRAWMODE };
struct ctlname	topname[] = CTL_NAMES;
struct ctlname	machdepname[] = CTL_MACHDEP_NAMES;
d160 6
a165 3
	if (orawmode != -1 && sysctl(mib, sizeof(mib) / sizeof(mib[0]),
	    NULL, NULL, &orawmode, sizeof(orawmode)) == -1)
		err(1, "sysctl");
a179 1
	int mfd;
a181 1
	int rawmode;
d188 1
d200 1
a200 1
	mfd = open("/dev/wsmouse", O_RDONLY);
d206 10
a215 4
	rawmode = 1;
	oldsize = sizeof(orawmode);
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), &orawmode, &oldsize,
	    &rawmode, sizeof(rawmode)) == -1) {
d217 1
a217 1
		err(1, "sysctl");
a230 1
	close(mfd);
d232 3
a234 2
	if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), NULL, NULL,
	    &orawmode, sizeof(orawmode)) == -1) {
d236 1
a236 1
		err(1, "sysctl");
d285 2
a286 3
	(void)printf("%s.%s=%d,%d,%d,%d\n", topname[CTL_MACHDEP].ctl_name,
	    machdepname[CPU_ZTSSCALE].ctl_name, ts.ts_minx, ts.ts_maxx,
	    ts.ts_miny, ts.ts_maxy);
@


1.11
log
@remove trailing newlines from err(3) calls; millert@@ and matthieu@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.10 2005/04/28 17:01:40 uwe Exp $	*/
d168 1
d182 1
a182 1
	double a, a1, a2, b, b1, b2, errx, erry;
d245 2
a246 2
	errx = a*WIDTH/2+b - x[2];
	if (fabs(errx) > (a*WIDTH+b)*.01) {
d249 1
a249 1
		    fabs(errx));
d266 2
a267 2
	erry = a*HEIGHT/2+b - y[2];
	if (fabs(erry) > (a*HEIGHT+b)*.01) {
d270 1
a270 1
		    fabs(erry));
@


1.10
log
@- restore machdep.ztsrawmode when exiting on a signal
- add comments and RCS tag to bitmap file
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.9 2005/04/28 16:44:28 uwe Exp $	*/
d136 1
a136 1
		warn("ioctl SMODE\n");
@


1.9
log
@display a title above the message; suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.8 2005/04/28 07:02:40 deraadt Exp $	*/
d49 1
d54 1
d63 1
d158 11
d171 2
a172 1
	restore_screen();
a181 1
	int mib[2];
a182 1
	int oldval;
a205 2
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_ZTSRAWMODE;
d207 3
a209 3
	oldsize = sizeof(oldval);
	if (sysctl(mib, 2, &oldval, &oldsize, &rawmode,
	    sizeof(rawmode)) == -1) {
d227 2
a228 5
	mib[0] = CTL_MACHDEP;
	mib[1] = CPU_ZTSRAWMODE;
	rawmode = oldval;
	oldsize = sizeof(oldval);
	if (sysctl(mib, 2, NULL, NULL, &rawmode, sizeof(rawmode)) == -1) {
d277 1
a277 1
	restore_screen();
@


1.8
log
@more boring tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.7 2005/04/28 06:58:27 deraadt Exp $	*/
d37 3
d56 1
a56 1
void		bitmap(u_short *, u_short, u_char[], int, int);
d66 2
a67 1
bitmap(u_short *fb, u_short pixel, u_char bits[], int width, int height)
d70 1
a70 1
	int x, y;
a76 1
		y = (HEIGHT/2 - height)/2;
d206 2
d209 1
a209 1
		    message_height);
d278 4
a281 1
	bitmap(mapaddr, RED, error_bits, error_width, error_height);
@


1.7
log
@boring tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.6 2005/04/25 02:52:00 uwe Exp $	*/
d96 1
a96 1
	size_t len;
d129 1
a129 1
	if (ioctl(fd, WSDISPLAYIO_SMODE, &mode) == -1) {
a130 1
	}
a268 1

@


1.6
log
@- don't loop infinitely after a missed "mouse up" event
- display bitmaps correctly if width is not divisible by 8
- display another bitmap on error
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.5 2005/04/25 00:28:12 uwe Exp $	*/
d133 1
a133 1
	    PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
d180 1
a180 1
	if (fd < 0) {
a181 1
	}
@


1.5
log
@- display a message centered on the screen
- undo a signal handler change which slipped in with the previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.4 2005/04/24 23:43:15 uwe Exp $	*/
d40 1
d63 1
a63 1
bitmap(u_short *fb, u_short color, u_char bits[], int width, int height)
d68 3
d72 2
a73 2
		x = (WIDTH - width) / 2;
		y = HEIGHT + (HEIGHT - height)/2 + 60;
d75 2
a76 2
			if (bits[((i * width) + j) / 8] & (1 << (j % 8)))
				fb[ADDR(x + j, y - i - 1)] = BLACK;
d100 2
a101 1
	while (!down) {
a108 9
		}
	}

	*x = *y = -1;
	while (down || *x == -1 || *y == -1) {
		len = read(mfd, &evbuf, sizeof(evbuf));
		if (len != 16)
			break;
		switch (evbuf.type) {
a155 1
	close(fd);
a178 1
again:
d183 3
d187 2
a188 1
	if (mfd < 0)
d190 1
d197 2
a198 1
	    sizeof(rawmode)) == -1)
d200 1
a201 1
	save_screen();
a210 1
	restore_screen();
a211 1
	close(fd);
d217 2
a218 1
	if (sysctl(mib, 2, NULL, NULL, &rawmode, sizeof(rawmode)) == -1)
d220 1
d235 1
d238 2
a239 2
		sleep(2);
		goto again;
d256 1
d259 2
a260 2
		sleep(2);
		goto again;
d266 2
d273 6
@


1.4
log
@use the last position of the pen before it was lifted up
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.3 2005/04/24 23:02:40 uwe Exp $	*/
d35 2
d44 4
a47 4
unsigned short *mapaddr, *save;
int		fd;
int		xc[] = { 25, 25, 320, 615, 615 };
int		yc[] = { 25, 455, 240, 25, 455 };
d52 2
a53 1
void		cross(unsigned short *, int, int);
d62 16
a77 1
cross(unsigned short *fb, int x, int y)
d140 1
a140 1
	save = (unsigned short *)malloc(WIDTH*HEIGHT*sizeof(unsigned short));
d143 1
a143 1
	memcpy(save, mapaddr, WIDTH*HEIGHT*sizeof(unsigned short));
d151 1
a151 1
	memcpy(mapaddr, save, WIDTH*HEIGHT*sizeof(unsigned short));
d160 2
a161 1
	_exit(128 + sig);
d204 3
a206 1
		memset(mapaddr, WHITE, WIDTH*HEIGHT*sizeof(unsigned short));
@


1.3
log
@- indentation
- do ratio calculations in double, not integer
- reduce allowed error to 1% (not more than 6 pixels off)
- add usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.2 2005/04/24 18:50:10 deraadt Exp $	*/
d78 1
a78 2
	*x = *y = -1;
	while (!down || *x == -1 || *y == -1 ) {
a85 6
		case WSCONS_EVENT_MOUSE_ABSOLUTE_X:
			*x = evbuf.value;
			break;
		case WSCONS_EVENT_MOUSE_ABSOLUTE_Y:
			*y = evbuf.value;
			break;
d88 3
a90 1
	while (down) {
d98 8
d142 1
a142 2
	close(fd);
	_exit(2);
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ztsscale.c,v 1.1 2005/04/24 18:46:47 uwe Exp $	*/
d35 4
a38 4
#define WIDTH 640
#define HEIGHT 480
#define BLACK 0x0
#define WHITE 0xffff
d43 14
a56 6
int fd;
int xc[] = { 25, 25, 320, 615, 615 };
int yc[] = { 24, 455, 240, 25, 455 };

struct ctlname topname[] = CTL_NAMES;
struct ctlname machdepname[] = CTL_MACHDEP_NAMES;
d63 1
a63 1
	y = 480 - y;
d65 1
a65 1
		fb[ADDR(i,y)] = BLACK;
d160 4
d189 1
d201 4
a204 1
	a1 = (x[4] - x[0])/(xc[4] - xc[0]);
a205 1
	a2 = (x[3] - x[1])/(xc[3] - xc[1]);
d207 1
d210 2
a211 2
	errx =  a*WIDTH/2+b - x[2];
	if (fabs(errx) > (a*WIDTH+b)*.05) {
d214 2
a215 1
		exit(2);
d221 4
a224 1
	a1 = (y[4] - y[0])/(yc[4] - yc[0]);
a225 1
	a2 = (y[3] - y[1])/(yc[3] - yc[1]);
d227 1
d231 1
a231 1
	if (fabs(erry) > (a*HEIGHT+b)*.05) {
d234 2
a235 1
		exit(2);
d246 9
@


1.1
log
@Import matthieu's touch screen calibration tool for zaurus.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
	for (i = x - 20; i <= x + 20; i++) 
d58 1
a58 1
	for (i = y - 20; i <= y + 20; i++) 
d97 1
a97 1
}	
d107 3
a109 3
	mapaddr = (void *)mmap(0, WIDTH*HEIGHT*sizeof(short), 
		PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
	if (mapaddr == (void *)-1) {
a110 1
	}
d112 1
a112 1
	if (save == NULL) 
d123 1
a123 1
	if (ioctl(fd, WSDISPLAYIO_SMODE, &mode) == -1) {
a124 1
	}
d151 1
a151 1
	
d157 1
a157 1
	if (mfd < 0) 
d167 1
a167 1
	
d197 1
a197 1
			fabs(errx)); 
d213 1
a213 1
			fabs(erry));
@

