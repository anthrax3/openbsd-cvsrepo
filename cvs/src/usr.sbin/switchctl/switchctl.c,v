head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.2
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.2.0.2
	OPENBSD_6_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2017.01.31.05.53.08;	author jsg;	state Exp;
branches;
next	1.6;
commitid	nkf9YY7VvvAELxT1;

1.6
date	2016.11.24.09.23.11;	author reyk;	state Exp;
branches;
next	1.5;
commitid	tD6p5l8O1Xq5NhL2;

1.5
date	2016.11.15.08.15.07;	author reyk;	state Exp;
branches;
next	1.4;
commitid	H5Z6OFhVOmsB5Woy;

1.4
date	2016.10.12.19.07.42;	author reyk;	state Exp;
branches;
next	1.3;
commitid	3O0CWeyo2kl0zVpd;

1.3
date	2016.09.28.09.13.30;	author reyk;	state Exp;
branches;
next	1.2;
commitid	d6OJYhhY7OcWMtPV;

1.2
date	2016.07.20.21.04.44;	author reyk;	state Exp;
branches;
next	1.1;
commitid	wlcguDHGaX7zdZQ8;

1.1
date	2016.07.19.16.54.26;	author reyk;	state Exp;
branches;
next	;
commitid	NvD0Bp0qm4zs28YJ;


desc
@@


1.7
log
@Use the sizeof operator on a struct not a pointer to one.
ok rzalamena@@
@
text
@/*	$OpenBSD: switchctl.c,v 1.6 2016/11/24 09:23:11 reyk Exp $	*/

/*
 * Copyright (c) 2007-2015 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/un.h>
#include <sys/tree.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>
#include <event.h>
#include <pwd.h>

#include "switchd.h"
#include "parser.h"

__dead void	 usage(void);

struct imsgname {
	int type;
	char *name;
	void (*func)(struct imsg *);
};

int		 show_summary_msg(struct imsg *, int);

struct imsgname *monitor_lookup(uint8_t);
void		 monitor_id(struct imsg *);
int		 monitor(struct imsg *);

int		 ca_opt(struct parse_result *);

struct imsgname imsgs[] = {
	{ IMSG_CTL_OK,			"ok",			NULL },
	{ IMSG_CTL_FAIL,		"fail",			NULL },
	{ IMSG_CTL_VERBOSE,		"verbose",		NULL },
	{ IMSG_CTL_RELOAD,		"reload",		NULL },
	{ IMSG_CTL_RESET,		"reset",		NULL },
	{ 0,				NULL,			NULL }

};
struct imsgname imsgunknown = {
	-1,				"<unknown>",		NULL
};

struct imsgbuf	*ibuf;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-q] [-s socket] command [arg ...]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct sockaddr_un	 sun;
	struct parse_result	*res;
	struct imsg		 imsg;
	struct switch_client	 swc;
	struct switch_address	*to;
	struct passwd		*pw;
	int			 ctl_sock;
	int			 done = 1;
	int			 n;
	int			 ch;
	int			 v = 0;
	int			 quiet = 0;
	int			 verbose = 0;
	const char		*sock = SWITCHD_SOCKET;

	while ((ch = getopt(argc, argv, "qs:v")) != -1) {
		switch (ch) {
		case 'q':
			quiet = 1;
			break;
		case 's':
			sock = optarg;
			break;
		case 'v':
			verbose = 2;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	if ((pw = getpwnam(SWITCHD_USER)) == NULL)
		fatal("switchctl: getpwnam");

	/*
	 * pledge in switchctl:
	 * stdio - for malloc and basic I/O including events.
	 * dns - for parsehostport() in the device spec.
	 * inet - for handling tcp connections with OpenFlow peers.
	 * unix - for opening the control socket.
	 */
	if (pledge("stdio dns inet unix", NULL) == -1)
		err(1, "pledge");

	log_init(quiet ? 0 : 2, LOG_USER);

	/* parse options */
	if ((res = parse(argc, argv)) == NULL)
		exit(1);

	res->quiet = quiet;
	res->verbose = verbose;

	if (res->quiet && res->verbose)
		fatal("conflicting -v and -q options");

	switch (res->action) {
	case NONE:
		usage();
		break;
	case DUMP_DESC:
	case DUMP_FEATURES:
	case DUMP_FLOWS:
	case DUMP_TABLES:
	case FLOW_ADD:
	case FLOW_DELETE:
	case FLOW_MODIFY:
		ofpclient(res, pw);
		break;
	default:
		goto connect;
	}

	return (0);

 connect:
	/* connect to sdnflowd control socket */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, sock, sizeof(sun.sun_path));
 reconnect:
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		/* Keep retrying if running in monitor mode */
		if (res->action == MONITOR &&
		    (errno == ENOENT || errno == ECONNREFUSED)) {
			usleep(100);
			goto reconnect;
		}
		err(1, "connect: %s", sock);
	}

	if (res->ibuf != NULL)
		ibuf = res->ibuf;
	else
		if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
			err(1, "malloc");
	imsg_init(ibuf, ctl_sock);

	/* process user request */
	switch (res->action) {
	case RESETALL:
		v = RESET_ALL;
		break;
	case LOG_VERBOSE:
		v = 2;
		break;
	case LOG_BRIEF:
	default:
		v = 0;
		break;
	}

	switch (res->action) {
	case NONE:
		usage();
		/* NOTREACHED */
		break;
	case SHOW_SUM:
	case SHOW_SWITCHES:
	case SHOW_MACS:
		imsg_compose(ibuf, IMSG_CTL_SHOW_SUM, 0, 0, -1, NULL, 0);
		printf("%-4s\t%-4s\t%-8s\t%-24s\t%s\n",
		    "Switch", "Port", "Type", "Name", "Info");
		done = 0;
		break;
	case CONNECT:
	case DISCONNECT:
		memset(&swc, 0, sizeof(swc));
		if (res->addr.ss_family == AF_UNSPEC)
			errx(1, "invalid address");

		memcpy(&swc.swc_addr.swa_addr, &res->addr, sizeof(res->addr));
		if (res->action == DISCONNECT) {
			imsg_compose(ibuf, IMSG_CTL_DISCONNECT, 0, 0, -1,
			    &swc, sizeof(swc));
			break;
		}

		to = &swc.swc_target;
		memcpy(to, &res->uri, sizeof(*to));

		imsg_compose(ibuf, IMSG_CTL_CONNECT, 0, 0, -1,
		    &swc, sizeof(swc));
		break;
	case RESETALL:
		imsg_compose(ibuf, IMSG_CTL_RESET, 0, 0, -1, &v, sizeof(v));
		printf("reset request sent.\n");
		break;
	case LOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1,
		    res->path, strlen(res->path));
		break;
	case RELOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
		break;
	case MONITOR:
		imsg_compose(ibuf, IMSG_CTL_NOTIFY, 0, 0, -1, NULL, 0);
		done = 0;
		break;
	case LOG_VERBOSE:
	case LOG_BRIEF:
		imsg_compose(ibuf, IMSG_CTL_VERBOSE, 0, 0, -1, &v, sizeof(v));
		printf("logging request sent.\n");
		break;
	default:
		break;
	}

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;
			switch (res->action) {
			case SHOW_SUM:
			case SHOW_SWITCHES:
			case SHOW_MACS:
				done = show_summary_msg(&imsg, res->action);
				break;
			case MONITOR:
				done = monitor(&imsg);
				break;
			default:
				break;
			}
			imsg_free(&imsg);
		}
	}
	close(ctl_sock);
	free(ibuf);

	return (0);
}

int
show_summary_msg(struct imsg *imsg, int type)
{
	struct switch_control	*sw;
	struct macaddr		*mac;
	struct timeval		 tv;
	static unsigned int	 sw_id = 0;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SWITCH:
		IMSG_SIZE_CHECK(imsg, sw);
		sw = imsg->data;
		sw_id = sw->sw_id;

		if (!(type == SHOW_SUM || type == SHOW_SWITCHES))
			break;
		printf("%-4u\t%-4s\t%-8s\t%-24s\n",
		    sw->sw_id, "", "switch",
		    print_host(&sw->sw_addr, NULL, 0));
		break;
	case IMSG_CTL_MAC:
		IMSG_SIZE_CHECK(imsg, mac);
		mac = imsg->data;

		if (!(type == SHOW_SUM || type == SHOW_MACS))
			break;

		getmonotime(&tv);
		printf("%-4u\t%-4u\t%-8s\t%-24s\tage %llds\n",
		    sw_id, mac->mac_port, "mac",
		    print_ether(mac->mac_addr),
		    (long long)tv.tv_sec - mac->mac_age);
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		errx(1, "wrong message in summary: %u", imsg->hdr.type);
		break;
	}
	return (0);
}

struct imsgname *
monitor_lookup(uint8_t type)
{
	int i;

	for (i = 0; imsgs[i].name != NULL; i++)
		if (imsgs[i].type == type)
			return (&imsgs[i]);
	return (&imsgunknown);
}

int
monitor(struct imsg *imsg)
{
	time_t			 now;
	int			 done = 0;
	struct imsgname		*imn;

	now = time(NULL);

	imn = monitor_lookup(imsg->hdr.type);
	printf("%s: imsg type %u len %u peerid %u pid %d\n", imn->name,
	    imsg->hdr.type, imsg->hdr.len, imsg->hdr.peerid, imsg->hdr.pid);
	printf("\ttimestamp: %lld, %s", (long long)now, ctime(&now));
	if (imn->type == -1)
		done = 1;
	if (imn->func != NULL)
		(*imn->func)(imsg);

	return (done);
}
@


1.6
log
@Add simple client to add flows from switchctl.  Not finished yet, but
it is better for rzalamena and me to work on it in the tree.

OK rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.5 2016/11/15 08:15:07 reyk Exp $	*/
d230 1
a230 1
		memcpy(&to, &res->uri, sizeof(to));
@


1.5
log
@Add a simple openflow client to dump switch information.  The
implementation re-uses the openflow code from switchd. Not finished
yet, but it is better to continue working on it in the tree.  Later
versions will also include a way to add flows from the command line -
this is being worked on for switchd and some code of the
"ASCII-to-flow" parser will be shared here as well.

As discussed with and lightly tested by rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.4 2016/10/12 19:07:42 reyk Exp $	*/
d97 1
d100 1
a100 1
	while ((ch = getopt(argc, argv, "qs:")) != -1) {
d108 3
d132 2
d139 1
d141 2
a142 1
	log_init(quiet ? 0 : 2, LOG_USER);
d152 3
@


1.4
log
@Start reworking the "device" support in switchd: Once connected, a
device is just an fd that is connected to a switch, either via TCP or
via /dev/switch.  Change the switchctl from "device add" to "connect"
etc.  This change is an intermediate step towards other changes,
including the configuration grammar, so a few things will be left
undocumented for now.

switchctl(8) examples,
switchctl connect /dev/switch0
switchctl connect /dev/switch0 forward-to 10.1.1.1
switchctl connect 127.0.0.1
switchctl connect 127.0.0.1 forward-to 10.1.1.1
switchctl disconnect /dev/switch0

Discussed with rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.3 2016/09/28 09:13:30 reyk Exp $	*/
d33 1
d36 1
d90 1
a97 1
	size_t			 len;
d115 13
d134 2
d140 6
a170 8
	/*
	 * pledge in switchctl:
	 * stdio - for malloc and basic I/O including events.
	 * dns - for parsehostport() in the device spec.
	 */
	if (pledge("stdio dns", NULL) == -1)
		err(1, "pledge");

d219 2
a220 20
		if (res->uri == NULL || res->uri[0] == '\0')
			to->swa_type = SWITCH_CONN_LOCAL;
		else {
			len = 4;
			if (strncmp(res->uri, "tcp:", len) == 0)
				to->swa_type = SWITCH_CONN_TCP;
			else if (strncmp(res->uri, "tls:", len) == 0)
				to->swa_type = SWITCH_CONN_TLS;
			else {
				/* set the default */
				to->swa_type = SWITCH_CONN_TCP;
				len = 0;
			}

			if (parsehostport(res->uri + len,
			    (struct sockaddr *)&to->swa_addr,
			    sizeof(to->swa_addr)) != 0)
				errx(1,
				    "couldn't parse name-or-address and port");
		}
@


1.3
log
@Adjust the mac_port format string since it got upgraded to 32bits
(following OpenFlow 1.3).
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.2 2016/07/20 21:04:44 reyk Exp $	*/
d86 2
a87 2
	struct switch_device	 sdv;
	struct switch_controller *swc;
d95 1
d190 10
a199 13
	case ADD_DEVICE:
	case REMOVE_DEVICE:
		memset(&sdv, 0, sizeof(sdv));
		swc = &sdv.sdv_swc;
		if (res->path[0] != '/')
			strlcpy(sdv.sdv_device, "/dev/",
			    sizeof(sdv.sdv_device));
		if (strlcat(sdv.sdv_device, res->path,
		    sizeof(sdv.sdv_device)) >= sizeof(sdv.sdv_device))
			errx(1, "path is too long");
		if (res->action == REMOVE_DEVICE) {
			imsg_compose(ibuf, IMSG_CTL_DEVICE_DISCONNECT, 0, 0, -1,
			    &sdv, sizeof(sdv));
d202 2
d205 1
a205 1
			swc->swc_type = SWITCH_CONN_LOCAL;
d207 14
a220 10
			if (strncmp(res->uri, "tcp:", 4) == 0)
				swc->swc_type = SWITCH_CONN_TCP;
			else if (strncmp(res->uri, "tls:", 4) == 0)
				swc->swc_type = SWITCH_CONN_TLS;
			else
				errx(1, "protocol field is unknown");

			if (parsehostport(res->uri + 4,
			    (struct sockaddr *)&swc->swc_addr,
			    sizeof(swc->swc_addr)) != 0)
a222 1
			warnx("%s", sdv.sdv_device);
d224 2
a225 2
		imsg_compose(ibuf, IMSG_CTL_DEVICE_CONNECT, 0, 0, -1,
		    &sdv, sizeof(sdv));
@


1.2
log
@pledge switchctl
@
text
@d1 1
a1 1
/*	$OpenBSD: switchctl.c,v 1.1 2016/07/19 16:54:26 reyk Exp $	*/
d312 1
a312 1
		printf("%-4u\t%-4ld\t%-8s\t%-24s\tage %llds\n",
@


1.1
log
@Import switchd(8), a basic WIP OpenFlow implementation for OpenBSD.

switchd consists of two parts:
1. switchd(8) and switchctl(8), an OpenFlow controller or "vswitch".
2. switch(4), an OpenFlow-aware kernel "bridge".

This the 1st part, the driver will be imported later.  The code will
remain disabled for a while, but it helps development to have it in
the tree.  switchd currently supports partial OpenFlow 1.0, but the
goal is to use OpenFlow 1.3.5 instead (switch(4) already does 1.3.5).

For more background information see:
http://www.openbsd.org/papers/bsdcan2016-switchd.pdf
https://youtu.be/Cuo0qT-lqig

With help from yasuoka@@ goda@@
Import discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.19 2015/01/16 06:40:17 deraadt Exp $	*/
d146 8
@

