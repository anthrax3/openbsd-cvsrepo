head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.8
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.24.0.16
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.14
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.10
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.10
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.6
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.10
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.8
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.6
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.19.0.6
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.4.0.16
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.08.21.02.07.32;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Zx2k82IzYwwZaEz9;

1.26
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Uu5nFG3wCl0LACBb;

1.25
date	2014.11.26.18.34.51;	author millert;	state Exp;
branches;
next	1.24;
commitid	9QOFSShUOtA0kQLF;

1.24
date	2011.03.22.10.16.23;	author okan;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.02.15.19.39;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.20.14.48.26;	author robert;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.03.05.42.05;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.26.20.48.29;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.26.01.17.12;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.19.19.09.45;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.11.23.33.28;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.05.21.05.39;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.08.00.28.09;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.02.19.06.39;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.17.19.42.37;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.10.20.30.46;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.05.22.32.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.31.22.13.09;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.09.03.24.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.21.00.33.37;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.06.23.33;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.11.19.15.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.46.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.45;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@since stdlib.h is in scope, don't cast.... you know the drill.
no sneakiness detected by krw
@
text
@/*	$NetBSD: mrinfo.c,v 1.4 1995/12/10 11:00:51 mycroft Exp $	*/

/*
 * This tool requests configuration info from a multicast router
 * and prints the reply (if any).  Invoke it as:
 *
 *	mrinfo router-name-or-address
 *
 * Written Wed Mar 24 1993 by Van Jacobson (adapted from the
 * multicast mapper written by Pavel Curtis).
 *
 * The lawyers insist we include the following UC copyright notice.
 * The mapper from which this is derived contained a Xerox copyright
 * notice which follows the UC one.  Try not to get depressed noting
 * that the legal gibberish is larger than the program.
 *
 * Copyright (c) 1993 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ---------------------------------
 * Copyright (c) 1992, 2001 Xerox Corporation.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.

 * Neither name of the Xerox, PARC, nor the names of its contributors may be used
 * to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE XEROX CORPORATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <string.h>
#include <netdb.h>
#include <sys/time.h>
#include "defs.h"
#include <arpa/inet.h>
#include <stdarg.h>
#include <poll.h>
#include <limits.h>
#include <err.h>

#define DEFAULT_TIMEOUT	4	/* How long to wait before retrying requests */
#define DEFAULT_RETRIES 3	/* How many times to ask each router */

u_int32_t	our_addr, target_addr = 0;	/* in NET order */
int     debug = 0;
int	nflag = 0;
int     retries = DEFAULT_RETRIES;
int     timeout = DEFAULT_TIMEOUT;
int	target_level = 0;
vifi_t  numvifs;		/* to keep loader happy */
				/* (see COPY_TABLES macro called in kern.c) */

char		*inet_name(u_int32_t addr);
void		ask(u_int32_t dst);
void		ask2(u_int32_t dst);
u_int32_t	host_addr(char *name);
void		usage(void);

char *
inet_name(u_int32_t addr)
{
	struct hostent *e;
	struct in_addr in;

	if (addr == 0)
		return "local";

	if (nflag ||
	    (e = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET)) == NULL) {
		in.s_addr = addr;
		return (inet_ntoa(in));
	}
	return (e->h_name);
}

/*
 * Log errors and other messages to stderr, according to the severity of the
 * message and the current debug level.  For errors of severity LOG_ERR or
 * worse, terminate the program.
 */
void
logit(int severity, int syserr, char *format, ...)
{
	va_list ap;

	switch (debug) {
	case 0:
		if (severity > LOG_WARNING)
			return;
	case 1:
		if (severity > LOG_NOTICE)
			return;
	case 2:
		if (severity > LOG_INFO)
			return;
	default:
		if (severity == LOG_WARNING)
			fprintf(stderr, "warning - ");
		va_start(ap, format);
		vfprintf(stderr, format, ap);
		va_end(ap);
		if (syserr == 0)
			fputc('\n', stderr);
		else if (syserr < sys_nerr)
			fprintf(stderr, ": %s\n", sys_errlist[syserr]);
		else
			fprintf(stderr, ": errno %d\n", syserr);
	}

	if (severity <= LOG_ERR)
		exit(1);
}

/*
 * Send a neighbors-list request.
 */
void
ask(u_int32_t dst)
{
	send_igmp(our_addr, dst, IGMP_DVMRP, DVMRP_ASK_NEIGHBORS,
	    htonl(MROUTED_LEVEL), 0);
}

void
ask2(u_int32_t dst)
{
	send_igmp(our_addr, dst, IGMP_DVMRP, DVMRP_ASK_NEIGHBORS2,
	    htonl(MROUTED_LEVEL), 0);
}

/*
 * Process an incoming neighbor-list message.
 */
void
accept_neighbors(u_int32_t src, u_int32_t dst, u_char *p, int datalen,
    u_int32_t level)
{
	u_char *ep = p + datalen;

#define GET_ADDR(a) (a = ((u_int32_t)*p++ << 24), a += ((u_int32_t)*p++ << 16),\
		     a += ((u_int32_t)*p++ << 8), a += *p++)

	printf("%s (%s):\n", inet_fmt(src, s1), inet_name(src));
	while (p < ep) {
		u_char metric, thresh;
		u_int32_t laddr;
		int ncount;

		GET_ADDR(laddr);
		laddr = htonl(laddr);
		metric = *p++;
		thresh = *p++;
		ncount = *p++;
		while (--ncount >= 0) {
			u_int32_t neighbor;

			GET_ADDR(neighbor);
			neighbor = htonl(neighbor);
			printf("  %s -> ", inet_fmt(laddr, s1));
			printf("%s (%s) [%d/%d]\n", inet_fmt(neighbor, s1),
			    inet_name(neighbor), metric, thresh);
		}
	}
}

void
accept_neighbors2(u_int32_t src, u_int32_t dst, u_char *p, int datalen,
    u_int32_t level)
{
	u_char *ep = p + datalen;
	u_int broken_cisco = ((level & 0xffff) == 0x020a); /* 10.2 */
	/* well, only possibly_broken_cisco, but that's too long to type. */

	printf("%s (%s) [version %d.%d", inet_fmt(src, s1), inet_name(src),
	    level & 0xff, (level >> 8) & 0xff);
	if ((level >> 16) & NF_LEAF)
		printf (",leaf");
	if ((level >> 16) & NF_PRUNE)
		printf (",prune");
	if ((level >> 16) & NF_GENID)
		printf (",genid");
	if ((level >> 16) & NF_MTRACE)
		printf (",mtrace");
	printf ("]:\n");

	while (p < ep) {
		u_char metric, thresh, flags;
		u_int32_t laddr = *(u_int32_t*)p;
		int ncount;

		p += 4;
		metric = *p++;
		thresh = *p++;
		flags = *p++;
		ncount = *p++;
		if (broken_cisco && ncount == 0)	/* dumb Ciscos */
			ncount = 1;
		if (broken_cisco && ncount > 15)	/* dumb Ciscos */
			ncount = ncount & 0xf;
		while (--ncount >= 0 && p < ep) {
			u_int32_t neighbor = *(u_int32_t*)p;
			p += 4;
			printf("  %s -> ", inet_fmt(laddr, s1));
			printf("%s (%s) [%d/%d", inet_fmt(neighbor, s1),
			    inet_name(neighbor), metric, thresh);
			if (flags & DVMRP_NF_TUNNEL)
				printf("/tunnel");
			if (flags & DVMRP_NF_SRCRT)
				printf("/srcrt");
			if (flags & DVMRP_NF_PIM)
				printf("/pim");
			if (flags & DVMRP_NF_QUERIER)
				printf("/querier");
			if (flags & DVMRP_NF_DISABLED)
				printf("/disabled");
			if (flags & DVMRP_NF_DOWN)
				printf("/down");
			if (flags & DVMRP_NF_LEAF)
				printf("/leaf");
			printf("]\n");
		}
	}
}

void
usage()
{
	fprintf(stderr,
	    "Usage: mrinfo [-d [debug_level]] [-n] [-t timeout] [-r retries] [router]\n");
	exit(1);
}

int
main(int argc, char *argv[])
{
	int tries, trynew, curaddr, udp, ch;
	struct hostent *hp, bogus;
	struct sockaddr_in addr;
	socklen_t addrlen;
	struct timeval et;
	char *host;
	uid_t uid;
	const char *errstr;

	if (geteuid() != 0) {
		fprintf(stderr, "mrinfo: must be root\n");
		exit(1);
	}

	init_igmp();

	uid = getuid();
	if (setresuid(uid, uid, uid) == -1)
		err(1, "setresuid");

	setvbuf(stderr, NULL, _IOLBF, 0);

	while ((ch = getopt(argc, argv, "d::nr:t:")) != -1) {
		switch (ch) {
		case 'd':
			if (!optarg)
				debug = DEFAULT_DEBUG;
			else {
				debug = strtonum(optarg, 0, 3, &errstr);
				if (errstr) {
					warnx("debug level %s", errstr);
					debug = DEFAULT_DEBUG;
				}
			}
			break;
		case 'n':
			++nflag;
			break;
		case 'r':
			retries = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				warnx("retries %s", errstr);
				usage();
			}
			break;
		case 't':
			timeout = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				warnx("timeout %s", errstr);
				usage();
			}
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
			
	if (argc > 1)
		usage();
	if (argc == 1)
		host = argv[0];
	else
		host = "127.0.0.1";

	if ((target_addr = inet_addr(host)) != -1) {
		hp = &bogus;
		hp->h_length = sizeof(target_addr);
		if (!(hp->h_addr_list = calloc(2, sizeof(char *))))
			err(1, "can't allocate memory");
		if (!(hp->h_addr_list[0] = malloc(hp->h_length)))
			err(1, "can't allocate memory");
		memcpy(hp->h_addr_list[0], &target_addr, hp->h_length);
		hp->h_addr_list[1] = 0;
	} else
		hp = gethostbyname(host);

	if (hp == NULL || hp->h_length != sizeof(target_addr)) {
		fprintf(stderr, "mrinfo: %s: no such host\n", argv[0]);
		exit(1);
	}
	if (debug)
		fprintf(stderr, "Debug level %u\n", debug);

	/* Check all addresses; mrouters often have unreachable interfaces */
	for (curaddr = 0; hp->h_addr_list[curaddr] != NULL; curaddr++) {
		memcpy(&target_addr, hp->h_addr_list[curaddr], hp->h_length);
		/* Find a good local address for us. */
		addrlen = sizeof(addr);
		memset(&addr, 0, sizeof addr);
		addr.sin_family = AF_INET;
		addr.sin_len = sizeof addr;
		addr.sin_addr.s_addr = target_addr;
		addr.sin_port = htons(2000);	/* any port over 1024 will
						 * do... */
		if ((udp = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ||
		    connect(udp, (struct sockaddr *) & addr, sizeof(addr)) < 0 ||
		    getsockname(udp, (struct sockaddr *) & addr, &addrlen) < 0) {
			perror("Determining local address");
			exit(1);
		}
		close(udp);
		our_addr = addr.sin_addr.s_addr;

		tries = 0;
		trynew = 1;
		/*
		 * New strategy: send 'ask2' for two timeouts, then fall back
		 * to 'ask', since it's not very likely that we are going to
		 * find someone who only responds to 'ask' these days
		 */
		ask2(target_addr);

		gettimeofday(&et, 0);
		et.tv_sec += timeout;

		/* Main receive loop */
		for (;;) {
			int count, recvlen, ipdatalen, iphdrlen, igmpdatalen;
			u_int32_t src, dst, group;
			struct timeval tv, now;
			socklen_t dummy = 0;
			struct igmp *igmp;
			struct ip *ip;
			struct pollfd pfd[1];

			pfd[0].fd = igmp_socket;
			pfd[0].events = POLLIN;

			gettimeofday(&now, 0);
			tv.tv_sec = et.tv_sec - now.tv_sec;
			tv.tv_usec = et.tv_usec - now.tv_usec;

			if (tv.tv_usec < 0) {
				tv.tv_usec += 1000000L;
				--tv.tv_sec;
			}
			if (tv.tv_sec < 0)
				timerclear(&tv);

			count = poll(pfd, 1, tv.tv_sec * 1000);

			if (count < 0) {
				if (errno != EINTR)
					perror("select");
				continue;
			} else if (count == 0) {
				logit(LOG_DEBUG, 0,
				    "Timed out receiving neighbor lists");
				if (++tries > retries)
					break;
				/* If we've tried ASK_NEIGHBORS2 twice with
				 * no response, fall back to ASK_NEIGHBORS
				 */
				if (tries == 2 && target_level == 0)
					trynew = 0;
				if (target_level == 0 && trynew == 0)
					ask(target_addr);
				else
					ask2(target_addr);
				gettimeofday(&et, 0);
				et.tv_sec += timeout;
				continue;
			}
			recvlen = recvfrom(igmp_socket, recv_buf, RECV_BUF_SIZE,
			    0, NULL, &dummy);
			if (recvlen <= 0) {
				if (recvlen && errno != EINTR)
					perror("recvfrom");
				continue;
			}

			if (recvlen < sizeof(struct ip)) {
				logit(LOG_WARNING, 0,
				    "packet too short (%u bytes) for IP header",
				    recvlen);
				continue;
			}
			ip = (struct ip *) recv_buf;
			if (ip->ip_p == 0)
				continue;	/* Request to install cache entry */
			src = ip->ip_src.s_addr;
			dst = ip->ip_dst.s_addr;
			iphdrlen = ip->ip_hl << 2;
			ipdatalen = ntohs(ip->ip_len) - iphdrlen;
			if (iphdrlen + ipdatalen != recvlen) {
				logit(LOG_WARNING, 0,
				    "packet shorter (%u bytes) than "
				    "hdr+data length (%u+%u)",
				    recvlen, iphdrlen, ipdatalen);
				continue;
			}
			igmp = (struct igmp *) (recv_buf + iphdrlen);
			group = igmp->igmp_group.s_addr;
			igmpdatalen = ipdatalen - IGMP_MINLEN;
			if (igmpdatalen < 0) {
				logit(LOG_WARNING, 0,
				    "IP data field too short (%u bytes) "
				    "for IGMP, from %s",
				    ipdatalen, inet_fmt(src, s1));
				continue;
			}
			if (igmp->igmp_type != IGMP_DVMRP)
				continue;

			switch (igmp->igmp_code) {
			case DVMRP_NEIGHBORS:
			case DVMRP_NEIGHBORS2:
				if (src != target_addr) {
					fprintf(stderr, "mrinfo: got reply from %s",
					    inet_fmt(src, s1));
					fprintf(stderr, " instead of %s\n",
					    inet_fmt(target_addr, s1));
					/*continue;*/
				}
				break;
			default:
				continue;	/* ignore all other DVMRP messages */
			}

			switch (igmp->igmp_code) {
			case DVMRP_NEIGHBORS:
				if (group) {
					/* knows about DVMRP_NEIGHBORS2 msg */
					if (target_level == 0) {
						target_level = ntohl(group);
						ask2(target_addr);
					}
				} else {
					accept_neighbors(src, dst, (u_char *)(igmp + 1),
					    igmpdatalen, ntohl(group));
					exit(0);
				}
				break;
			case DVMRP_NEIGHBORS2:
				accept_neighbors2(src, dst, (u_char *)(igmp + 1),
				    igmpdatalen, ntohl(group));
				exit(0);
			}
		}
	}
	exit(1);
}

/* dummies */
void
accept_probe(u_int32_t src, u_int32_t dst, char *p, int datalen,
    u_int32_t level)
{
}

void
accept_group_report(u_int32_t src, u_int32_t dst, u_int32_t group, int r_type)
{
}

void
accept_neighbor_request2(u_int32_t src, u_int32_t dst)
{
}

void
accept_report(u_int32_t src, u_int32_t dst, char *p, int datalen,
    u_int32_t level)
{
}

void
accept_neighbor_request(u_int32_t src, u_int32_t dst)
{
}

void
accept_prune(u_int32_t src, u_int32_t dst, char *p, int datalen)
{
}

void
accept_graft(u_int32_t src, u_int32_t dst, char *p, int datalen)
{
}

void
accept_g_ack(u_int32_t src, u_int32_t dst, char *p, int datalen)
{
}

void
add_table_entry(u_int32_t origin, u_int32_t mcastgrp)
{
}

void
check_vif_state(void)
{
}

void
accept_leave_message(u_int32_t src, u_int32_t dst, u_int32_t group)
{
}

void
accept_mtrace(u_int32_t src, u_int32_t dst, u_int32_t group, char *data,
    u_int no, int datalen)
{
}

void
accept_membership_query(u_int32_t src, u_int32_t dst, u_int32_t group, int tmo)
{
}

void
accept_info_request(u_int32_t src, u_int32_t dst, u_char *p, int datalen)
{
}

void
accept_info_reply(u_int32_t src, u_int32_t dst, u_char *p, int datalen)
{
}
@


1.26
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d351 1
a351 1
		if (!(hp->h_addr_list = (char **)calloc(2, sizeof(char *))))
@


1.25
log
@Prefer setvbuf() to setlinebuf() for portability; ok deraadt@@
@
text
@d84 1
a373 1
#if (defined(BSD) && (BSD >= 199103))
a374 1
#endif
@


1.24
log
@use timerclear macro

ok miod@@
@
text
@d301 1
a301 1
	setlinebuf(stderr);
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d422 1
a422 1
				tv.tv_sec = tv.tv_usec = 0;
@


1.22
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@a76 8
#ifndef lint
static char rcsid[] =
    "@@(#) $OpenBSD: mrinfo.c,v 1.21 2005/06/20 14:48:26 robert Exp $";
/*  original rcsid:
    "@@(#) Header: mrinfo.c,v 1.6 93/04/08 15:14:16 van Exp (LBL)";
*/
#endif

@


1.21
log
@use getopt(3) for argument list parsing and remove the get_number()
function becasue we use strtonum(3) from now on.

ok otto@@ millert@@
@
text
@d79 1
a79 1
    "@@(#) $OpenBSD: mrinfo.c,v 1.20 2005/05/03 05:42:05 djm Exp $";
d358 1
a358 1
		if (!(hp->h_addr_list = (char **)malloc(2 * sizeof(char *))))
@


1.20
log
@setresuid; ok deraadt@@
@
text
@d79 1
a79 1
    "@@(#) $OpenBSD: mrinfo.c,v 1.19 2004/02/26 20:48:29 tedu Exp $";
a108 1
int		get_number(int *var, int deflt, char ***pargv, int *pargc);
a277 23
int
get_number(int *var, int deflt, char ***pargv, int *pargc)
{
	if ((*pargv)[0][2] == '\0') {
		/* Get the value from the next argument */
		if (*pargc > 1 && isdigit((*pargv)[1][0])) {
			(*pargv)++, (*pargc)--;
			*var = atoi((*pargv)[0]);
			return 1;
		} else if (deflt >= 0) {
			*var = deflt;
			return 1;
		} else
			return 0;
	} else {		/* Get value from the rest of this argument */
		if (isdigit((*pargv)[0][2])) {
			*var = atoi((*pargv)[0] + 2);
			return 1;
		} else
			return 0;
	}
}

d282 1
a282 1
	    "Usage: mrinfo [-n] [-t timeout] [-r retries] [router]\n");
d289 1
a289 1
	int tries, trynew, curaddr, udp;
d296 1
d311 2
a312 4
	argv++;
	argc--;
	while (argc > 0 && argv[0][0] == '-') {
		switch (argv[0][1]) {
d314 9
a322 2
			if (!get_number(&debug, DEFAULT_DEBUG, &argv, &argc))
				usage();
d328 3
a330 1
			if (!get_number(&retries, -1, &argv, &argc))
d332 1
d335 3
a337 1
			if (!get_number(&timeout, -1, &argv, &argc))
d339 1
a343 1
		argv++, argc--;
d345 3
@


1.19
log
@fix datalen, from Esben Norby.  ok deraadt itojun
@
text
@d79 1
a79 1
    "@@(#) $OpenBSD: mrinfo.c,v 1.18 2003/11/26 01:17:12 millert Exp $";
d319 1
d327 4
a330 2
	seteuid(getuid());
	setuid(getuid());
@


1.18
log
@Replace log() with logit() since ISO C reserves log() for the math
library and gcc 3.x will complain.  Replacement name taken from NetBSD.
espie@@ OK.
@
text
@d79 1
a79 1
    "@@(#) $OpenBSD: mrinfo.c,v 1.17 2003/08/19 19:09:45 deraadt Exp $";
d483 1
a483 1
			ipdatalen = ntohs(ip->ip_len);
@


1.17
log
@convert to poll; ok dhartmei
@
text
@d79 1
a79 1
    "@@(#) $OpenBSD: mrinfo.c,v 1.16 2003/06/11 23:33:28 deraadt Exp $";
d136 1
a136 1
log(int severity, int syserr, char *format, ...)
d446 1
a446 1
				log(LOG_DEBUG, 0,
d472 1
a472 1
				log(LOG_WARNING, 0,
d485 1
a485 1
				log(LOG_WARNING, 0,
d495 1
a495 1
				log(LOG_WARNING, 0,
@


1.16
log
@some ansification, some de-register
@
text
@d79 1
a79 1
    "@@(#) $OpenBSD: mrinfo.c,v 1.15 2003/03/05 21:05:39 deraadt Exp $";
d91 1
d423 1
a423 1
			fd_set  fds;
d425 2
a426 4
			FD_ZERO(&fds);
			if (igmp_socket >= FD_SETSIZE)
				log(LOG_ERR, 0, "descriptor too big");
			FD_SET(igmp_socket, &fds);
d439 1
a439 1
			count = select(igmp_socket + 1, &fds, 0, 0, &tv);
@


1.15
log
@knf
@
text
@d79 1
a79 1
    "@@(#) $OpenBSD: mrinfo.c,v 1.4 1995/12/10 11:00:51 mycroft Exp $";
d208 2
a209 1
			register u_int32_t neighbor;
@


1.14
log
@don't use dynamically-generated printf format string.  more picky
about gethostby* result.  check fd_set overrun.  from xs@@kittenz.org
@
text
@d50 1
a50 1
 * Redistribution and use in source and binary forms, with or without modification, 
d61 2
a62 2
 * to endorse or promote products derived from this software 
 * without specific prior written permission. 
d64 2
a65 2
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
d74 1
a74 1
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
d79 1
a79 1
    "@@(#) $NetBSD: mrinfo.c,v 1.4 1995/12/10 11:00:51 mycroft Exp $";
d91 1
d105 6
a110 10
char *			inet_name(u_int32_t addr);
void			ask(u_int32_t dst);
void			ask2(u_int32_t dst);
int			get_number(int *var, int deflt, char ***pargv,
			    int *pargc);
u_int32_t		host_addr(char *name);
void			usage(void);

/* to shut up -Wstrict-prototypes */
int			main(int argc, char *argv[]);
d112 2
a113 4

char   *
inet_name(addr)
	u_int32_t  addr;
d170 2
a171 3
void 
ask(dst)
	u_int32_t  dst;
d174 1
a174 1
			htonl(MROUTED_LEVEL), 0);
d177 2
a178 3
void 
ask2(dst)
	u_int32_t  dst;
d181 1
a181 1
			htonl(MROUTED_LEVEL), 0);
d187 3
a189 5
void 
accept_neighbors(src, dst, p, datalen, level)
	u_int32_t	src, dst, level;
	u_char	*p;
	int     datalen;
d192 1
d198 3
a200 4
		register u_int32_t laddr;
		register u_char metric;
		register u_char thresh;
		register int ncount;
d213 1
a213 1
			       inet_name(neighbor), metric, thresh);
d218 3
a220 5
void 
accept_neighbors2(src, dst, p, datalen, level)
	u_int32_t	src, dst, level;
	u_char	*p;
	int     datalen;
d227 9
a235 5
	       level & 0xff, (level >> 8) & 0xff);
	if ((level >> 16) & NF_LEAF)   { printf (",leaf"); }
	if ((level >> 16) & NF_PRUNE)  { printf (",prune"); }
	if ((level >> 16) & NF_GENID)  { printf (",genid"); }
	if ((level >> 16) & NF_MTRACE) { printf (",mtrace"); }
d237 1
a237 1
	
d239 3
a241 5
		register u_char metric;
		register u_char thresh;
		register u_char flags;
		register int ncount;
		register u_int32_t laddr = *(u_int32_t*)p;
d253 1
a253 1
			register u_int32_t neighbor = *(u_int32_t*)p;
d257 1
a257 1
			       inet_name(neighbor), metric, thresh);
d277 2
a278 4
int 
get_number(var, deflt, pargv, pargc)
	int    *var, *pargc, deflt;
	char ***pargv;
d280 2
a281 2
	if ((*pargv)[0][2] == '\0') {	/* Get the value from the next
					 * argument */
d295 1
a295 1
		} else {
a296 1
		}
d309 1
a309 3
main(argc, argv)
	int     argc;
	char   *argv[];
d311 4
a314 2
	int tries;
	int trynew;
a315 2
	struct hostent *hp;
	struct hostent bogus;
a316 1
	int curaddr;
d329 2
a330 1
	argv++, argc--;
d381 3
a383 6
	    memcpy(&target_addr, hp->h_addr_list[curaddr], hp->h_length);
	    {			/* Find a good local address for us. */
		int     udp;
		struct sockaddr_in addr;
		int     addrlen = sizeof(addr);

d392 3
a394 3
		if ((udp = socket(AF_INET, SOCK_DGRAM, 0)) < 0
		|| connect(udp, (struct sockaddr *) & addr, sizeof(addr)) < 0
		    || getsockname(udp, (struct sockaddr *) & addr, &addrlen) < 0) {
a399 1
	    }
d401 37
a437 37
	    tries = 0;
	    trynew = 1;
	    /*
	     * New strategy: send 'ask2' for two timeouts, then fall back
	     * to 'ask', since it's not very likely that we are going to
	     * find someone who only responds to 'ask' these days
	     */
	    ask2(target_addr);

	    gettimeofday(&et, 0);
	    et.tv_sec += timeout;

	    /* Main receive loop */
	    for (;;) {
		fd_set  fds;
		struct timeval tv, now;
		int     count, recvlen, dummy = 0;
		register u_int32_t src, dst, group;
		struct ip *ip;
		struct igmp *igmp;
		int     ipdatalen, iphdrlen, igmpdatalen;

		FD_ZERO(&fds);
		if (igmp_socket >= FD_SETSIZE)
			log(LOG_ERR, 0, "descriptor too big");
		FD_SET(igmp_socket, &fds);

		gettimeofday(&now, 0);
		tv.tv_sec = et.tv_sec - now.tv_sec;
		tv.tv_usec = et.tv_usec - now.tv_usec;

		if (tv.tv_usec < 0) {
			tv.tv_usec += 1000000L;
			--tv.tv_sec;
		}
		if (tv.tv_sec < 0)
			tv.tv_sec = tv.tv_usec = 0;
d439 1
a439 1
		count = select(igmp_socket + 1, &fds, 0, 0, &tv);
d441 29
a469 28
		if (count < 0) {
			if (errno != EINTR)
				perror("select");
			continue;
		} else if (count == 0) {
			log(LOG_DEBUG, 0, "Timed out receiving neighbor lists");
			if (++tries > retries)
				break;
			/* If we've tried ASK_NEIGHBORS2 twice with
			 * no response, fall back to ASK_NEIGHBORS
			 */
			if (tries == 2 && target_level == 0)
				trynew = 0;
			if (target_level == 0 && trynew == 0)
				ask(target_addr);
			else
				ask2(target_addr);
			gettimeofday(&et, 0);
			et.tv_sec += timeout;
			continue;
		}
		recvlen = recvfrom(igmp_socket, recv_buf, RECV_BUF_SIZE,
				   0, NULL, &dummy);
		if (recvlen <= 0) {
			if (recvlen && errno != EINTR)
				perror("recvfrom");
			continue;
		}
d471 32
a502 30
		if (recvlen < sizeof(struct ip)) {
			log(LOG_WARNING, 0,
			    "packet too short (%u bytes) for IP header",
			    recvlen);
			continue;
		}
		ip = (struct ip *) recv_buf;
		if (ip->ip_p == 0)
			continue;	/* Request to install cache entry */
		src = ip->ip_src.s_addr;
		dst = ip->ip_dst.s_addr;
		iphdrlen = ip->ip_hl << 2;
		ipdatalen = ntohs(ip->ip_len);
		if (iphdrlen + ipdatalen != recvlen) {
		    log(LOG_WARNING, 0,
		      "packet shorter (%u bytes) than hdr+data length (%u+%u)",
		      recvlen, iphdrlen, ipdatalen);
		    continue;
		}
		igmp = (struct igmp *) (recv_buf + iphdrlen);
		group = igmp->igmp_group.s_addr;
		igmpdatalen = ipdatalen - IGMP_MINLEN;
		if (igmpdatalen < 0) {
		    log(LOG_WARNING, 0,
			"IP data field too short (%u bytes) for IGMP, from %s",
			ipdatalen, inet_fmt(src, s1));
		    continue;
		}
		if (igmp->igmp_type != IGMP_DVMRP)
			continue;
d504 13
a516 9
		switch (igmp->igmp_code) {
		case DVMRP_NEIGHBORS:
		case DVMRP_NEIGHBORS2:
			if (src != target_addr) {
				fprintf(stderr, "mrinfo: got reply from %s",
					inet_fmt(src, s1));
				fprintf(stderr, " instead of %s\n",
					inet_fmt(target_addr, s1));
				/*continue;*/
a517 4
			break;
		default:
			continue;	/* ignore all other DVMRP messages */
		}
d519 12
a530 8
		switch (igmp->igmp_code) {

		case DVMRP_NEIGHBORS:
			if (group) {
				/* knows about DVMRP_NEIGHBORS2 msg */
				if (target_level == 0) {
					target_level = ntohl(group);
					ask2(target_addr);
d532 4
a535 3
			} else {
				accept_neighbors(src, dst, (u_char *)(igmp + 1),
						 igmpdatalen, ntohl(group));
a537 6
			break;

		case DVMRP_NEIGHBORS2:
			accept_neighbors2(src, dst, (u_char *)(igmp + 1),
					  igmpdatalen, ntohl(group));
			exit(0);
a538 1
	    }
d544 3
a546 4
void accept_probe(src, dst, p, datalen, level)
	u_int32_t src, dst, level;
	char *p;
	int datalen;
d549 3
a551 3
void accept_group_report(src, dst, group, r_type)
	u_int32_t src, dst, group;
	int r_type;
d554 3
a556 2
void accept_neighbor_request2(src, dst)
	u_int32_t src, dst;
d559 4
a562 4
void accept_report(src, dst, p, datalen, level)
	u_int32_t src, dst, level;
	char *p;
	int datalen;
d565 3
a567 2
void accept_neighbor_request(src, dst)
	u_int32_t src, dst;
d570 3
a572 4
void accept_prune(src, dst, p, datalen)
	u_int32_t src, dst;
	char *p;
	int datalen;
d575 3
a577 4
void accept_graft(src, dst, p, datalen)
	u_int32_t src, dst;
	char *p;
	int datalen;
d580 3
a582 4
void accept_g_ack(src, dst, p, datalen)
	u_int32_t src, dst;
	char *p;
	int datalen;
d585 3
a587 2
void add_table_entry(origin, mcastgrp)
	u_int32_t origin, mcastgrp;
d590 3
a592 1
void check_vif_state()
d595 3
a597 2
void accept_leave_message(src, dst, group)
	u_int32_t src, dst, group;
d600 4
a603 5
void accept_mtrace(src, dst, group, data, no, datalen)
	u_int32_t src, dst, group;
	char *data;
	u_int no;
	int datalen;
d606 3
a608 3
void accept_membership_query(src, dst, group, tmo)
	u_int32_t src, dst, group;
	int tmo;
d611 3
a613 4
void accept_info_request(src, dst, p, datalen)
	u_int32_t src, dst;
	u_char *p;
	int datalen;
d616 3
a618 4
void accept_info_reply(src, dst, p, datalen)
	u_int32_t src, dst;
	u_char *p;
	int datalen;
@


1.13
log
@missing sockaddr inits; ok itojun
@
text
@a142 1
	char    fmt[100];
a154 1
		fmt[0] = '\0';
d156 1
a156 2
			strcat(fmt, "warning - ");
		strncat(fmt, format, 80);
d158 1
a158 1
		vfprintf(stderr, fmt, ap);
d386 1
a386 1
	if (hp == NULL) {
d442 2
@


1.12
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d404 1
@


1.11
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@a89 1
#ifdef __STDC__
a90 3
#else
#include <varargs.h>
#endif
a138 1
#ifdef __STDC__
a144 13
	va_start(ap, format);
#else
void 
log(severity, syserr, format, va_alist)
	int     severity, syserr;
	char   *format;
	va_dcl
{
	va_list ap;
	char    fmt[100];

	va_start(ap);
#endif
d160 1
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d111 3
a113 3
int			get_number __P((int *var, int deflt, char ***pargv,
					int *pargc));
u_int32_t			host_addr(char *name);
@


1.9
log
@follow post-2.1 ip_off & ip_len byte orders
@
text
@d108 3
a110 3
char *			inet_name __P((u_int32_t addr));
void			ask __P((u_int32_t dst));
void			ask2 __P((u_int32_t dst));
d113 2
a114 2
u_int32_t			host_addr __P((char *name));
void			usage __P((void));
d117 1
a117 1
int			main __P((int argc, char *argv[]));
@


1.8
log
@make sure that va_start() has matching va_end()
@
text
@d517 1
a517 1
		ipdatalen = ip->ip_len;
@


1.7
log
@New license from Xerox!  This code is now FREE!  Took a while and a lot of
mails, but it is worth it.
@
text
@d179 1
@


1.6
log
@exit(-#) is wrong
@
text
@d48 27
a74 14
 * Copyright (c) Xerox Corporation 1992. All rights reserved.
 * 
 * License is granted to copy, to use, and to make and to use derivative works
 * for research and evaluation purposes, provided that Xerox is acknowledged
 * in all documentation pertaining to any such copy or derivative work. Xerox
 * grants no other licenses expressed or implied. The Xerox trade name should
 * not be used in any advertising without its written permission.
 * 
 * XEROX CORPORATION MAKES NO REPRESENTATIONS CONCERNING EITHER THE
 * MERCHANTABILITY OF THIS SOFTWARE OR THE SUITABILITY OF THIS SOFTWARE FOR
 * ANY PARTICULAR PURPOSE.  The software is provided "as is" without express
 * or implied warranty of any kind.
 * 
 * These notices must be retained in any copies of any part of this software.
@


1.5
log
@more careful euid killing
@
text
@d175 1
a175 1
		exit(-1);
d418 1
a418 1
			exit(-1);
@


1.4
log
@check malloc() ret val!
@
text
@d345 1
@


1.3
log
@revoke privs at start; tested by fenner@@parc.xerox.com
@
text
@d167 1
a167 1
			fprintf(stderr, "\n");
d382 4
a385 2
		hp->h_addr_list = (char **)malloc(2 * sizeof(char *));
		hp->h_addr_list[0] = malloc(hp->h_length);
@


1.2
log
@from netbsd; update to mrouted 3.8
@
text
@a338 2
	setlinebuf(stderr);

d343 6
a394 2

	init_igmp();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mrinfo.c,v 1.3 1995/10/03 23:20:45 thorpej Exp $	*/
d66 1
a66 1
    "@@(#) $NetBSD: mrinfo.c,v 1.3 1995/10/03 23:20:45 thorpej Exp $";
d77 5
d91 1
a91 1
int	target_level;
d95 12
d130 9
d140 1
a140 1
log(severity, syserr, format, a, b, c, d, e)
d143 1
a143 1
	int     a, b, c, d, e;
d145 1
d148 2
d165 1
a165 1
		fprintf(stderr, fmt, a, b, c, d, e);
d201 3
a203 3
accept_neighbors(src, dst, p, datalen)
	u_int32_t  src, dst;
	u_char *p;
d234 3
a236 3
accept_neighbors2(src, dst, p, datalen)
	u_int32_t  src, dst;
	u_char *p;
d240 1
a240 1
	u_int broken_cisco = ((target_level & 0xffff) == 0x020a); /* 10.2 */
d243 7
a249 2
	printf("%s (%s) [version %d.%d]:\n", inet_fmt(src, s1), inet_name(src),
	       target_level & 0xff, (target_level >> 8) & 0xff);
a317 17
u_int32_t 
host_addr(name)
	char   *name;
{
	struct hostent *e;
	u_int32_t		addr;

	addr = inet_addr(name);
	if ((int)addr == -1) {
		e = gethostbyname(name);
		if (e == NULL || e->h_length != sizeof(addr))
			return (0);
		memcpy(&addr, e->h_addr_list[0], e->h_length);
	}
	return(addr);
}

d331 8
d371 1
a371 1
		target_addr = host_addr(argv[0]);
d373 11
a383 1
		target_addr = host_addr("127.0.0.1");
d385 1
a385 1
	if (target_addr == 0) {
d394 4
a397 1
	{			/* Find a good local address for us. */
d417 10
a426 1
	}
d428 2
a429 1
	ask(target_addr);
d431 2
a432 2
	/* Main receive loop */
	for (;;) {
d434 1
a434 1
		struct timeval tv;
d444 10
a453 2
		tv.tv_sec = timeout;
		tv.tv_usec = 0;
d463 8
a470 3
			if (--retries < 0)
				exit(1);
			if (target_level == 0)
d474 2
d500 4
a503 4
			log(LOG_WARNING, 0,
			    "packet shorter (%u bytes) than hdr+data length (%u+%u)",
			    recvlen, iphdrlen, ipdatalen);
			continue;
d509 4
a512 4
			log(LOG_WARNING, 0,
			    "IP data field too short (%u bytes) for IGMP, from %s",
			    ipdatalen, inet_fmt(src, s1));
			continue;
d542 2
a543 2
				accept_neighbors(src, dst, (char *)(igmp + 1),
						 igmpdatalen);
d549 2
a550 2
			accept_neighbors2(src, dst, (char *)(igmp + 1),
					  igmpdatalen);
d553 1
d555 1
d559 4
a562 1
void accept_probe()
d565 3
a567 1
void accept_group_report()
d570 2
a571 1
void accept_neighbor_request2()
d574 4
a577 1
void accept_report()
d580 2
a581 1
void accept_neighbor_request()
d584 4
a587 1
void accept_prune()
d590 4
a593 1
void accept_graft()
d596 4
a599 1
void accept_g_ack()
d602 2
a603 1
void add_table_entry()
d609 9
a617 1
void accept_leave_message()
d620 3
a622 1
void accept_mtrace()
d625 10
a634 1
void accept_membership_query()
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
