head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.26
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.22
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.18
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.20
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.12
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.16
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.14
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.20
date	2011.05.09.12.25.35;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.04.21.31.04;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2010.02.19.10.35.52;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.13.20.09.54;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.02.20.23.29;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.14.01.28.08;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.01.13.09.42;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.25.16.40.43;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.25.16.27.00;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.23.18.37.34;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.22.15.37.44;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2005.06.16.18.48.43;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.12.19.10.12;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.26.13.37.16;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.15.22.09.43;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.14.18.21.29;	author norby;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.12.11.03.05;	author norby;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.19.08.42;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.26.05;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.18.46;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.20
log
@ospfctl bits for opaque LSA support.
tested and OK sthen@@
@
text
@/*	$OpenBSD: parser.c,v 1.19 2010/09/04 21:31:04 tedu Exp $ */

/*
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ospfd.h"

#include "parser.h"

enum token_type {
	NOTOKEN,
	ENDTOKEN,
	KEYWORD,
	ADDRESS,
	FLAG,
	PREFIX,
	IFNAME
};

struct token {
	enum token_type		 type;
	const char		*keyword;
	int			 value;
	const struct token	*next;
};

static const struct token t_main[];
static const struct token t_fib[];
static const struct token t_show[];
static const struct token t_show_iface[];
static const struct token t_show_db[];
static const struct token t_show_area[];
static const struct token t_show_nbr[];
static const struct token t_show_rib[];
static const struct token t_show_fib[];
static const struct token t_log[];

static const struct token t_main[] = {
	{KEYWORD,	"reload",	RELOAD,		NULL},
	{KEYWORD,	"fib",		FIB,		t_fib},
	{KEYWORD,	"show",		SHOW,		t_show},
	{KEYWORD,	"log",		NONE,		t_log},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_fib[] = {
	{ KEYWORD,	"couple",	FIB_COUPLE,	NULL},
	{ KEYWORD,	"decouple",	FIB_DECOUPLE,	NULL},
	{ KEYWORD,	"reload",	FIB_RELOAD,	NULL},
	{ ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"interfaces",	SHOW_IFACE,	t_show_iface},
	{KEYWORD,	"database",	SHOW_DB,	t_show_db},
	{KEYWORD,	"neighbor",	SHOW_NBR,	t_show_nbr},
	{KEYWORD,	"rib",		SHOW_RIB,	t_show_rib},
	{KEYWORD,	"fib",		SHOW_FIB,	t_show_fib},
	{KEYWORD,	"summary",	SHOW_SUM,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_iface[] = {
	{NOTOKEN,	"",		NONE,			NULL},
	{KEYWORD,	"detail",	SHOW_IFACE_DTAIL,	NULL},
	{IFNAME,	"",		SHOW_IFACE_DTAIL,	NULL},
	{ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token t_show_db[] = {
	{NOTOKEN,	"",			NONE,		NULL},
	{KEYWORD,	"area",			SHOW_DBBYAREA,	t_show_area},
	{KEYWORD,	"asbr",			SHOW_DBASBR,	NULL},
	{KEYWORD,	"external",		SHOW_DBEXT,	NULL},
	{KEYWORD,	"network",		SHOW_DBNET,	NULL},
	{KEYWORD,	"router",		SHOW_DBRTR,	NULL},
	{KEYWORD,	"self-originated",	SHOW_DBSELF,	NULL},
	{KEYWORD,	"summary",		SHOW_DBSUM,	NULL},
	{KEYWORD,	"opaque",		SHOW_DBOPAQ,	NULL},
	{ENDTOKEN,	"",			NONE,		NULL}
};

static const struct token t_show_area[] = {
	{ADDRESS,	"",		NONE,		NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_nbr[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"detail",	SHOW_NBR_DTAIL,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_rib[] = {
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"detail",	SHOW_RIB_DTAIL,	NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
};

static const struct token t_show_fib[] = {
	{NOTOKEN,	"",		NONE,			NULL},
	{KEYWORD,	"interface",	SHOW_FIB_IFACE,		t_show_iface},
	{FLAG,		"connected",	F_CONNECTED,		t_show_fib},
	{FLAG,		"static",	F_STATIC,		t_show_fib},
	{FLAG,		"ospf",		F_OSPFD_INSERTED,	t_show_fib},
	{ADDRESS,	"",		NONE,			NULL},
	{ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token t_log[] = {
	{KEYWORD,	"verbose",	LOG_VERBOSE,		NULL},
	{KEYWORD,	"brief",	LOG_BRIEF,		NULL},
	{ENDTOKEN,	"",		NONE,			NULL}
};

static const struct token *match_token(const char *, const struct token *,
    struct parse_result *);
static void show_valid_args(const struct token *);

struct parse_result *
parse(int argc, char *argv[])
{
	static struct parse_result	res;
	const struct token	*table = t_main;
	const struct token	*match;

	bzero(&res, sizeof(res));

	while (argc >= 0) {
		if ((match = match_token(argv[0], table, &res)) == NULL) {
			fprintf(stderr, "valid commands/args:\n");
			show_valid_args(table);
			return (NULL);
		}

		argc--;
		argv++;

		if (match->type == NOTOKEN || match->next == NULL)
			break;

		table = match->next;
	}

	if (argc > 0) {
		fprintf(stderr, "superfluous argument: %s\n", argv[0]);
		return (NULL);
	}

	return (&res);
}

static const struct token *
match_token(const char *word, const struct token *table,
    struct parse_result *res)
{
	u_int			 i, match;
	const struct token	*t = NULL;

	match = 0;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			if (word == NULL || strlen(word) == 0) {
				match++;
				t = &table[i];
			}
			break;
		case KEYWORD:
			if (word != NULL && strncmp(word, table[i].keyword,
			    strlen(word)) == 0) {
				match++;
				t = &table[i];
				if (t->value)
					res->action = t->value;
			}
			break;
		case FLAG:
			if (word != NULL && strncmp(word, table[i].keyword,
			    strlen(word)) == 0) {
				match++;
				t = &table[i];
				res->flags |= t->value;
			}
			break;
		case ADDRESS:
			if (parse_addr(word, &res->addr)) {
				match++;
				t = &table[i];
				if (t->value)
					res->action = t->value;
			}
			break;
		case PREFIX:
			if (parse_prefix(word, &res->addr, &res->prefixlen)) {
				match++;
				t = &table[i];
				if (t->value)
					res->action = t->value;
			}
			break;
		case IFNAME:
			if (!match && word != NULL && strlen(word) > 0) {
				if (strlcpy(res->ifname, word,
				    sizeof(res->ifname)) >=
				    sizeof(res->ifname))
					err(1, "interface name too long");
				match++;
				t = &table[i];
				if (t->value)
					res->action = t->value;
			}
			break;

		case ENDTOKEN:
			break;
		}
	}

	if (match != 1) {
		if (word == NULL)
			fprintf(stderr, "missing argument:\n");
		else if (match > 1)
			fprintf(stderr, "ambiguous argument: %s\n", word);
		else if (match < 1)
			fprintf(stderr, "unknown argument: %s\n", word);
		return (NULL);
	}

	return (t);
}

static void
show_valid_args(const struct token *table)
{
	int	i;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			fprintf(stderr, "  <cr>\n");
			break;
		case KEYWORD:
		case FLAG:
			fprintf(stderr, "  %s\n", table[i].keyword);
			break;
		case ADDRESS:
			fprintf(stderr, "  <address>\n");
			break;
		case PREFIX:
			fprintf(stderr, "  <address>[/<len>]\n");
			break;
		case IFNAME:
			fprintf(stderr, "  <interface>\n");
			break;
		case ENDTOKEN:
			break;
		}
	}
}

int
parse_addr(const char *word, struct in_addr *addr)
{
	struct in_addr	ina;

	if (word == NULL)
		return (0);

	bzero(addr, sizeof(struct in_addr));
	bzero(&ina, sizeof(ina));

	if (inet_pton(AF_INET, word, &ina)) {
		addr->s_addr = ina.s_addr;
		return (1);
	}

	return (0);
}

int
parse_prefix(const char *word, struct in_addr *addr, u_int8_t *prefixlen)
{
	struct in_addr	 ina;
	int		 bits = 32;

	if (word == NULL)
		return (0);

	bzero(addr, sizeof(struct in_addr));
	bzero(&ina, sizeof(ina));

	if (strrchr(word, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, word,
		    &ina, sizeof(ina))) == -1)
			return (0);
		addr->s_addr = ina.s_addr & htonl(prefixlen2mask(bits));
		*prefixlen = bits;
		return (1);
	}
	*prefixlen = 32;
	return (parse_addr(word, addr));
}

/* XXX local copy from kroute.c, should go to shared file */
in_addr_t
prefixlen2mask(u_int8_t prefixlen)
{
	if (prefixlen == 0)
		return (0);

	return (0xffffffff << (32 - prefixlen));
}
@


1.19
log
@move some things around to make intentions clear.  not really a functional
change.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.18 2010/02/19 10:35:52 dlg Exp $ */
d105 1
@


1.18
log
@implement ospfctl fib reload.

this tells the daemon to resync the kernels list of interfaces and routes
with the daemons list. this is very useful if the routing socket overflows
and you want to sync things up again.

lots and lots of help from claudio@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.16 2009/11/02 20:23:29 claudio Exp $ */
d141 3
a143 1
static struct parse_result	res;
d148 1
d155 1
a155 1
		if ((match = match_token(argv[0], table)) == NULL) {
d178 3
a180 2
const struct token *
match_token(const char *word, const struct token *table)
d201 1
a201 1
					res.action = t->value;
d209 1
a209 1
				res.flags |= t->value;
d213 1
a213 1
			if (parse_addr(word, &res.addr)) {
d217 1
a217 1
					res.action = t->value;
d221 1
a221 1
			if (parse_prefix(word, &res.addr, &res.prefixlen)) {
d225 1
a225 1
					res.action = t->value;
d230 3
a232 3
				if (strlcpy(res.ifname, word,
				    sizeof(res.ifname)) >=
				    sizeof(res.ifname))
d237 1
a237 1
					res.action = t->value;
d259 1
a259 1
void
@


1.17
log
@Don't use [] in function arguments when dealing with arrays
we don't know the size of, otherwise gcc >= 4 will error.

ok markus@@ deraadt@@
@
text
@d74 1
@


1.16
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging. henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.15 2007/10/14 01:28:08 deraadt Exp $ */
d175 1
a175 1
match_token(const char *word, const struct token table[])
d255 1
a255 1
show_valid_args(const struct token table[])
@


1.15
log
@please lint
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.14 2007/02/01 13:09:42 claudio Exp $ */
d61 1
d67 1
d131 6
@


1.14
log
@Enable reload support in ospfctl. This is still a bit experimental so try
it out in your test lab before using it on the core infrastructure.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.13 2007/01/25 16:40:43 claudio Exp $ */
d268 1
a312 3
	} else {
		*prefixlen = 32;
		return (parse_addr(word, addr));
d314 2
a315 2

	return (0);
@


1.13
log
@No need to check if word is NULL before calling parse_addr/prefix.
The functions do that check already.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.12 2007/01/25 16:27:00 claudio Exp $ */
d63 1
a63 1
/*	{KEYWORD,	"reload",	RELOAD,		NULL}, */
@


1.12
log
@Correctly detect missing arguments like in "ospfctl show data area".
OK henning@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.11 2006/03/23 18:37:34 norby Exp $ */
d200 1
a200 1
			if (word != NULL && parse_addr(word, &res.addr)) {
d208 1
a208 2
			if (word != NULL &&
			    parse_prefix(word, &res.addr, &res.prefixlen)) {
@


1.11
log
@List interfaces they way we list neighbors etc.
This makes it much easier to grep in the output.
The original format of "show interface" can be seen with
"show interface detail".

help and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.10 2006/03/22 15:37:44 claudio Exp $ */
d142 1
a142 1
	while (argc > 0) {
d200 1
a200 1
			if (parse_addr(word, &res.addr)) {
d208 2
a209 1
			if (parse_prefix(word, &res.addr, &res.prefixlen)) {
d235 3
a237 1
		if (match > 1)
d239 1
a239 1
		if (match < 1)
@


1.10
log
@ospfd has the framework to couple and decouple the FIB. Add the needed
functionality to ospfctl for it.
NOTE: decoupling the FIB one a router may totaly fuck up the complete network.
Use it with care!
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.9 2005/06/16 18:48:43 henning Exp $ */
d87 4
a90 3
	{NOTOKEN,	"",		NONE,		NULL},
	{IFNAME,	"",		NONE,		NULL},
	{ENDTOKEN,	"",		NONE,		NULL}
d223 2
@


1.9
log
@use prefixlen2mask which handles zero prefixlens right
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.8 2005/05/12 19:10:12 norby Exp $ */
d53 1
d64 1
d67 6
@


1.8
log
@Add "show database asbr/external/network/router/self-originate/summary"
to ospfctl.

Show detailed information about the LSAs in the Link State Database.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.7 2005/03/26 13:37:16 claudio Exp $ */
d296 1
a296 1
		addr->s_addr = ina.s_addr & htonl(0xffffffff << (32 - bits));
d305 10
@


1.7
log
@ospfctl bits for the "ospfctl show fib interface" part. This will print
the interface status as seen from the parent kroute perspective.
OK henning@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.6 2005/03/15 22:09:43 claudio Exp $ */
d85 9
a93 5
	{NOTOKEN,	"",		NONE,		NULL},
	{KEYWORD,	"area",		SHOW_DBBYAREA,	t_show_area},
/*	{KEYWORD,	"router",	NONE,		NULL},
	{KEYWORD,	"network",	NONE,		NULL}, */
	{ENDTOKEN,	"",		NONE,		NULL}
@


1.6
log
@bgpctl parts for "show fib".
OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.5 2005/03/14 18:21:29 norby Exp $ */
d111 1
@


1.5
log
@Add "show summary" to ospfctl.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.4 2005/03/12 11:03:05 norby Exp $ */
d31 2
d59 1
d73 1
d107 9
@


1.4
log
@Add "show rib" and "show rib detail" to ospfctl.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.3 2005/02/02 19:08:42 henning Exp $ */
a68 1
/*	{KEYWORD,	"summary",	SHOW_SUMMARY,	NULL}, */
d70 1
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.2 2005/01/28 17:26:05 norby Exp $ */
d56 1
d70 1
d96 6
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.1 2005/01/28 14:18:46 claudio Exp $ */
d220 1
a220 1
			break; 
@


1.1
log
@Control program like bgpctl but this time for ospfd.
Currently only basic show commands work.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 2004 Esben Norby <esben.norby@@ericsson.com>
@

