head	1.64;
access;
symbols
	OPENBSD_6_1:1.64.0.2
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.63.0.4
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.58.0.10
	OPENBSD_5_8_BASE:1.58
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.58.0.6
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.56.0.8
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.56.0.6
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.4
	OPENBSD_5_0:1.56.0.2
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.54.0.2
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.41.0.4
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.64
date	2016.12.05.22.39.25;	author jca;	state Exp;
branches;
next	1.63;
commitid	LEnpBLIxChuQwPUt;

1.63
date	2015.12.03.11.42.14;	author claudio;	state Exp;
branches;
next	1.62;
commitid	DyrvCbGbHnfTmG4w;

1.62
date	2015.11.22.13.11.26;	author claudio;	state Exp;
branches;
next	1.61;
commitid	ANgRlPV0w2anI4op;

1.61
date	2015.10.09.23.33.54;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	O5EWBjoZynC5pFcv;

1.60
date	2015.09.27.17.31.50;	author stsp;	state Exp;
branches;
next	1.59;
commitid	kLBPo9HaQrkEaNW3;

1.59
date	2015.09.13.11.13.12;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	HmZqjbpn4mjxGSj3;

1.58
date	2013.11.13.22.52.41;	author sthen;	state Exp;
branches;
next	1.57;

1.57
date	2013.04.09.14.51.33;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2011.05.09.12.25.35;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.25.13.29.56;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2010.06.12.09.44.44;	author bluhm;	state Exp;
branches;
next	1.53;

1.53
date	2010.02.19.10.35.52;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2010.02.16.08.39.05;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2010.02.16.08.22.42;	author dlg;	state Exp;
branches;
next	1.50;

1.50
date	2009.11.02.20.23.29;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2009.09.14.11.49.25;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.06.07.31.26;	author eric;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.05.21.19.11;	author pyr;	state Exp;
branches;
next	1.46;

1.46
date	2009.04.07.14.57.33;	author reyk;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.30.12.43.18;	author norby;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.02.00.09.53;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.12.22.44.07;	author claudio;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.06.13.18.12;	author sobrado;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.14.01.28.08;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.11.12.03.37;	author norby;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.11.16.01.22;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.30.02.21.08;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.23.08.26.03;	author claudio;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.28.10.53.39;	author norby;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.21.16.36.39;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.26.09.47.54;	author norby;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.26.09.45.55;	author norby;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.23.18.37.34;	author norby;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.22.15.37.44;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.09.18.11.33;	author norby;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.09.15.44.07;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.08.15.02.15;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.24.21.06.46;	author norby;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.19.21.48.56;	author norby;	state Exp;
branches;
next	1.23;

1.23
date	2006.02.10.18.31.49;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.27.22.37.30;	author stevesk;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.23.20.21.44;	author stevesk;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.16.19.31.44;	author stevesk;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.16.17.12.30;	author stevesk;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.24.21.10.32;	author msf;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.27.00.51.52;	author norby;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.26.06.07.47;	author norby;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.22.20.01.47;	author norby;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.12.19.10.12;	author norby;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.06.06.59.58;	author norby;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.16.21.52.57;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.29.17.26.35;	author norby;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.26.13.37.16;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.23.20.18.19;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.15.22.09.43;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.14.18.21.29;	author norby;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.12.11.03.05;	author norby;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.12.10.49.12;	author norby;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.02.19.08.42;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.02.18.52.32;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.28.17.26.05;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.14.18.46;	author claudio;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Also print the mtu when showing interface details

ok sthen@@ benno@@
@
text
@/*	$OpenBSD: ospfctl.c,v 1.63 2015/12/03 11:42:14 claudio Exp $ */

/*
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if_media.h>
#include <net/if_types.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "ospf.h"
#include "ospfd.h"
#include "ospfe.h"
#include "parser.h"

__dead void	 usage(void);
int		 show_summary_msg(struct imsg *);
uint64_t	 get_ifms_type(uint8_t);
int		 show_interface_msg(struct imsg *);
int		 show_interface_detail_msg(struct imsg *);
const char	*print_link(int);
const char	*fmt_timeframe(time_t t);
const char	*fmt_timeframe_core(time_t t);
const char	*log_id(u_int32_t );
const char	*log_adv_rtr(u_int32_t);
void		 show_database_head(struct in_addr, char *, u_int8_t);
int		 show_database_msg(struct imsg *);
char		*print_ls_type(u_int8_t);
void		 show_db_hdr_msg_detail(struct lsa_hdr *);
char		*print_rtr_link_type(u_int8_t);
const char	*print_ospf_flags(u_int8_t);
int		 show_db_msg_detail(struct imsg *imsg);
int		 show_nbr_msg(struct imsg *);
const char	*print_ospf_options(u_int8_t);
int		 show_nbr_detail_msg(struct imsg *);
int		 show_rib_msg(struct imsg *);
void		 show_rib_head(struct in_addr, u_int8_t, u_int8_t);
const char	*print_ospf_rtr_flags(u_int8_t);
int		 show_rib_detail_msg(struct imsg *);
void		 show_fib_head(void);
int		 show_fib_msg(struct imsg *);
void		 show_interface_head(void);
const char *	 get_media_descr(uint64_t);
const char *	 get_linkstate(uint8_t, int);
void		 print_baudrate(u_int64_t);
int		 show_fib_interface_msg(struct imsg *);

struct imsgbuf	*ibuf;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-s socket] command [argument ...]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char *argv[])
{
	struct sockaddr_un	 sun;
	struct parse_result	*res;
	struct imsg		 imsg;
	unsigned int		 ifidx = 0;
	int			 ctl_sock;
	int			 done = 0;
	int			 n, verbose = 0;
	int			 ch;
	char			*sockname;

	sockname = OSPFD_SOCKET;
	while ((ch = getopt(argc, argv, "s:")) != -1) {
		switch (ch) {
		case 's':
			sockname = optarg;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	/* parse options */
	if ((res = parse(argc, argv)) == NULL)
		exit(1);

	/* connect to ospfd control socket */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;

	strlcpy(sun.sun_path, sockname, sizeof(sun.sun_path));
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		err(1, "connect: %s", sockname);

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		err(1, NULL);
	imsg_init(ibuf, ctl_sock);
	done = 0;

	/* process user request */
	switch (res->action) {
	case NONE:
		usage();
		/* not reached */
	case SHOW:
	case SHOW_SUM:
		imsg_compose(ibuf, IMSG_CTL_SHOW_SUM, 0, 0, -1, NULL, 0);
		break;
	case SHOW_IFACE:
		printf("%-11s %-18s %-6s %-10s %-10s %-8s %3s %3s\n",
		    "Interface", "Address", "State", "HelloTimer", "Linkstate",
		    "Uptime", "nc", "ac");
		/*FALLTHROUGH*/
	case SHOW_IFACE_DTAIL:
		if (*res->ifname) {
			ifidx = if_nametoindex(res->ifname);
			if (ifidx == 0)
				errx(1, "no such interface %s", res->ifname);
		}
		imsg_compose(ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0, -1,
		    &ifidx, sizeof(ifidx));
		break;
	case SHOW_NBR:
		printf("%-15s %-3s %-12s %-8s %-15s %-9s %s\n", "ID", "Pri",
		    "State", "DeadTime", "Address", "Iface","Uptime");
		/*FALLTHROUGH*/
	case SHOW_NBR_DTAIL:
		imsg_compose(ibuf, IMSG_CTL_SHOW_NBR, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DB:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DATABASE, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBBYAREA:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DATABASE, 0, 0, -1,
		    &res->addr, sizeof(res->addr));
		break;
	case SHOW_DBEXT:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_EXT, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBNET:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_NET, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBRTR:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_RTR, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBSELF:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_SELF, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBSUM:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_SUM, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBASBR:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_ASBR, 0, 0, -1, NULL, 0);
		break;
	case SHOW_DBOPAQ:
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_OPAQ, 0, 0, -1, NULL, 0);
		break;
	case SHOW_RIB:
		printf("%-20s %-17s %-12s %-9s %-7s %-8s\n", "Destination",
		    "Nexthop", "Path Type", "Type", "Cost", "Uptime");
		/*FALLTHROUGH*/
	case SHOW_RIB_DTAIL:
		imsg_compose(ibuf, IMSG_CTL_SHOW_RIB, 0, 0, -1, NULL, 0);
		break;
	case SHOW_FIB:
		if (!res->addr.s_addr)
			imsg_compose(ibuf, IMSG_CTL_KROUTE, 0, 0, -1,
			    &res->flags, sizeof(res->flags));
		else
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0, -1,
			    &res->addr, sizeof(res->addr));
		show_fib_head();
		break;
	case SHOW_FIB_IFACE:
		if (*res->ifname)
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, -1,
			    res->ifname, sizeof(res->ifname));
		else
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, -1, NULL, 0);
		show_interface_head();
		break;
	case FIB:
		errx(1, "fib couple|decouple");
		break;
	case FIB_COUPLE:
		imsg_compose(ibuf, IMSG_CTL_FIB_COUPLE, 0, 0, -1, NULL, 0);
		printf("couple request sent.\n");
		done = 1;
		break;
	case FIB_DECOUPLE:
		imsg_compose(ibuf, IMSG_CTL_FIB_DECOUPLE, 0, 0, -1, NULL, 0);
		printf("decouple request sent.\n");
		done = 1;
		break;
	case FIB_RELOAD:
		imsg_compose(ibuf, IMSG_CTL_FIB_RELOAD, 0, 0, -1, NULL, 0);
		printf("reload request sent.\n");
		done = 1;
		break;
	case LOG_VERBOSE:
		verbose = 1;
		/* FALLTHROUGH */
	case LOG_BRIEF:
		imsg_compose(ibuf, IMSG_CTL_LOG_VERBOSE, 0, 0, -1,
		    &verbose, sizeof(verbose));
		printf("logging request sent.\n");
		done = 1;
		break;
	case RELOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
		printf("reload request sent.\n");
		done = 1;
		break;
	}

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;
			switch (res->action) {
			case SHOW:
			case SHOW_SUM:
				done = show_summary_msg(&imsg);
				break;
			case SHOW_IFACE:
				done = show_interface_msg(&imsg);
				break;
			case SHOW_IFACE_DTAIL:
				done = show_interface_detail_msg(&imsg);
				break;
			case SHOW_NBR:
				done = show_nbr_msg(&imsg);
				break;
			case SHOW_NBR_DTAIL:
				done = show_nbr_detail_msg(&imsg);
				break;
			case SHOW_DB:
			case SHOW_DBBYAREA:
			case SHOW_DBSELF:
				done = show_database_msg(&imsg);
				break;
			case SHOW_DBEXT:
			case SHOW_DBNET:
			case SHOW_DBRTR:
			case SHOW_DBSUM:
			case SHOW_DBASBR:
			case SHOW_DBOPAQ:
				done = show_db_msg_detail(&imsg);
				break;
			case SHOW_RIB:
				done = show_rib_msg(&imsg);
				break;
			case SHOW_RIB_DTAIL:
				done = show_rib_detail_msg(&imsg);
				break;
			case SHOW_FIB:
				done = show_fib_msg(&imsg);
				break;
			case SHOW_FIB_IFACE:
				done = show_fib_interface_msg(&imsg);
				break;
			case NONE:
			case FIB:
			case FIB_COUPLE:
			case FIB_DECOUPLE:
			case FIB_RELOAD:
			case LOG_VERBOSE:
			case LOG_BRIEF:
			case RELOAD:
				break;
			}
			imsg_free(&imsg);
		}
	}
	close(ctl_sock);
	free(ibuf);

	return (0);
}

int
show_summary_msg(struct imsg *imsg)
{
	struct ctl_sum		*sum;
	struct ctl_sum_area	*sumarea;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_SUM:
		sum = imsg->data;
		printf("Router ID: %s\n", inet_ntoa(sum->rtr_id));
		printf("Uptime: %s\n", fmt_timeframe_core(sum->uptime));
		printf("RFC1583 compatibility flag is ");
		if (sum->rfc1583compat)
			printf("enabled\n");
		else
			printf("disabled\n");

		printf("SPF delay is %d msec(s), hold time between two SPFs "
		    "is %d msec(s)\n", sum->spf_delay, sum->spf_hold_time);
		printf("Number of external LSA(s) %d (Checksum sum 0x%x)\n",
		    sum->num_ext_lsa, sum->ext_lsa_cksum);
		printf("Number of areas attached to this router: %d\n",
		    sum->num_area);
		break;
	case IMSG_CTL_SHOW_SUM_AREA:
		sumarea = imsg->data;
		printf("\nArea ID: %s\n", inet_ntoa(sumarea->area));
		printf("  Number of interfaces in this area: %d\n",
		    sumarea->num_iface);
		printf("  Number of fully adjacent neighbors in this "
		    "area: %d\n", sumarea->num_adj_nbr);
		printf("  SPF algorithm executed %d time(s)\n",
		    sumarea->num_spf_calc);
		printf("  Number LSA(s) %d (Checksum sum 0x%x)\n",
		    sumarea->num_lsa, sumarea->lsa_cksum);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

uint64_t
get_ifms_type(uint8_t if_type)
{
	switch (if_type) {
	case IFT_ETHER:
		return (IFM_ETHER);
	case IFT_FDDI:
		return (IFM_FDDI);
	case IFT_CARP:
		return (IFM_CARP);
	case IFT_PPP:
		return (IFM_TDM);
	default:
		return (0);
	}
}

int
show_interface_msg(struct imsg *imsg)
{
	struct ctl_iface	*iface;
	char			*netid;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_INTERFACE:
		iface = imsg->data;

		if (asprintf(&netid, "%s/%d", inet_ntoa(iface->addr),
		    mask2prefixlen(iface->mask.s_addr)) == -1)
			err(1, NULL);
		printf("%-11s %-18s %-6s %-10s %-10s %s %3d %3d\n",
		    iface->name, netid, if_state_name(iface->state),
		    iface->hello_timer.tv_sec < 0 ? "-" :
		    fmt_timeframe_core(iface->hello_timer.tv_sec),
		    get_linkstate(iface->if_type, iface->linkstate),
		    fmt_timeframe_core(iface->uptime),
		    iface->nbr_cnt, iface->adj_cnt);
		free(netid);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_interface_detail_msg(struct imsg *imsg)
{
	struct ctl_iface	*iface;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_INTERFACE:
		iface = imsg->data;
		printf("\n");
		printf("Interface %s, line protocol is %s\n",
		    iface->name, print_link(iface->flags));
		printf("  Internet address %s/%d, ",
		    inet_ntoa(iface->addr),
		    mask2prefixlen(iface->mask.s_addr));
		printf("Area %s\n", inet_ntoa(iface->area));
		printf("  Linkstate %s,",
		    get_linkstate(iface->if_type, iface->linkstate));
		printf(" mtu %d\n", iface->mtu);
		printf("  Router ID %s, network type %s, cost: %d\n",
		    inet_ntoa(iface->rtr_id),
		    if_type_name(iface->type), iface->metric);
		printf("  Transmit delay is %d sec(s), state %s, priority %d\n",
		    iface->transmit_delay, if_state_name(iface->state),
		    iface->priority);
		printf("  Designated Router (ID) %s, ",
		    inet_ntoa(iface->dr_id));
		printf("interface address %s\n", inet_ntoa(iface->dr_addr));
		printf("  Backup Designated Router (ID) %s, ",
		    inet_ntoa(iface->bdr_id));
		printf("interface address %s\n", inet_ntoa(iface->bdr_addr));
		if (iface->dead_interval == FAST_RTR_DEAD_TIME) {
			printf("  Timer intervals configured, "
			    "hello %d msec, dead %d, wait %d, retransmit %d\n",
			     iface->fast_hello_interval, iface->dead_interval,
			     iface->dead_interval, iface->rxmt_interval);

		} else {
			printf("  Timer intervals configured, "
			    "hello %d, dead %d, wait %d, retransmit %d\n",
			     iface->hello_interval, iface->dead_interval,
			     iface->dead_interval, iface->rxmt_interval);
		}
		if (iface->passive)
			printf("    Passive interface (No Hellos)\n");
		else if (iface->hello_timer.tv_sec < 0)
			printf("    Hello timer not running\n");
		else
			printf("    Hello timer due in %s+%ldmsec\n",
			    fmt_timeframe_core(iface->hello_timer.tv_sec),
			    iface->hello_timer.tv_usec / 1000);
		printf("    Uptime %s\n", fmt_timeframe_core(iface->uptime));
		printf("  Neighbor count is %d, adjacent neighbor count is "
		    "%d\n", iface->nbr_cnt, iface->adj_cnt);
		if (iface->auth_type > 0) {
			switch (iface->auth_type) {
			case AUTH_SIMPLE:
				printf("  Simple password authentication "
				    "enabled\n");
				break;
			case AUTH_CRYPT:
				printf("  Message digest authentication "
				    "enabled\n");
				printf("    Primary key id is %d\n",
				    iface->auth_keyid);
				break;
			default:
				break;
			}
		}
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

const char *
print_link(int state)
{
	if (state & IFF_UP)
		return ("UP");
	else
		return ("DOWN");
}

#define TF_BUFS	8
#define TF_LEN	9

const char *
fmt_timeframe(time_t t)
{
	if (t == 0)
		return ("Never");
	else
		return (fmt_timeframe_core(time(NULL) - t));
}

const char *
fmt_timeframe_core(time_t t)
{
	char		*buf;
	static char	 tfbuf[TF_BUFS][TF_LEN];	/* ring buffer */
	static int	 idx = 0;
	unsigned int	 sec, min, hrs, day;
	unsigned long long	week;

	if (t == 0)
		return ("00:00:00");

	buf = tfbuf[idx++];
	if (idx == TF_BUFS)
		idx = 0;

	week = t;

	sec = week % 60;
	week /= 60;
	min = week % 60;
	week /= 60;
	hrs = week % 24;
	week /= 24;
	day = week % 7;
	week /= 7;

	if (week > 0)
		snprintf(buf, TF_LEN, "%02lluw%01ud%02uh", week, day, hrs);
	else if (day > 0)
		snprintf(buf, TF_LEN, "%01ud%02uh%02um", day, hrs, min);
	else
		snprintf(buf, TF_LEN, "%02u:%02u:%02u", hrs, min, sec);

	return (buf);
}

const char *
log_id(u_int32_t id)
{
	static char	buf[48];
	struct in_addr	addr;

	addr.s_addr = id;

	if (inet_ntop(AF_INET, &addr, buf, sizeof(buf)) == NULL)
		return ("?");
	else
		return (buf);
}

const char *
log_adv_rtr(u_int32_t adv_rtr)
{
	static char	buf[48];
	struct in_addr	addr;

	addr.s_addr = adv_rtr;

	if (inet_ntop(AF_INET, &addr, buf, sizeof(buf)) == NULL)
		return ("?");
	else
		return (buf);
}

/* prototype defined in ospfd.h and shared with the kroute.c version */
u_int8_t
mask2prefixlen(in_addr_t ina)
{
	if (ina == 0)
		return (0);
	else
		return (33 - ffs(ntohl(ina)));
}

void
show_database_head(struct in_addr aid, char *ifname, u_int8_t type)
{
	char	*header, *format;
	int	 cleanup = 0;

	switch (type) {
	case LSA_TYPE_ROUTER:
		format = "Router Link States";
		break;
	case LSA_TYPE_NETWORK:
		format = "Net Link States";
		break;
	case LSA_TYPE_SUM_NETWORK:
		format = "Summary Net Link States";
		break;
	case LSA_TYPE_SUM_ROUTER:
		format = "Summary Router Link States";
		break;
	case LSA_TYPE_EXTERNAL:
		format = NULL;
		if ((header = strdup("Type-5 AS External Link States")) == NULL)
			err(1, NULL);
		break;
	case LSA_TYPE_LINK_OPAQ:
		format = "Type-9 Link Local Opaque Link States";
		break;
	case LSA_TYPE_AREA_OPAQ:
		format = "Type-10 Area Local Opaque Link States";
		break;
	case LSA_TYPE_AS_OPAQ:
		format = NULL;
		if ((header = strdup("Type-11 AS Wide Opaque Link States")) ==
		    NULL)
			err(1, NULL);
		break;
	default:
		if (asprintf(&format, "LSA type %x", ntohs(type)) == -1)
			err(1, NULL);
		cleanup = 1;
		break;
	}
	if (type == LSA_TYPE_LINK_OPAQ) {
		if (asprintf(&header, "%s (Area %s Interface %s)", format,
		    inet_ntoa(aid), ifname) == -1)
			err(1, NULL);
	} else if (type != LSA_TYPE_EXTERNAL && type != LSA_TYPE_AS_OPAQ)
		if (asprintf(&header, "%s (Area %s)", format,
		    inet_ntoa(aid)) == -1)
			err(1, NULL);

	printf("\n%-15s %s\n\n", "", header);
	free(header);
	if (cleanup)
		free(format);
}

int
show_database_msg(struct imsg *imsg)
{
	static struct in_addr	 area_id;
	static char		 ifname[IF_NAMESIZE];
	static u_int8_t		 lasttype;
	struct area		*area;
	struct iface		*iface;
	struct lsa_hdr		*lsa;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_DATABASE:
	case IMSG_CTL_SHOW_DB_SELF:
		lsa = imsg->data;
		if (lsa->type != lasttype) {
			show_database_head(area_id, ifname, lsa->type);
			printf("%-15s %-15s %-4s %-10s %-8s\n", "Link ID",
			    "Adv Router", "Age", "Seq#", "Checksum");
		}
		printf("%-15s %-15s %-4d 0x%08x 0x%04x\n",
		    log_id(lsa->ls_id), log_adv_rtr(lsa->adv_rtr),
		    ntohs(lsa->age), ntohl(lsa->seq_num),
		    ntohs(lsa->ls_chksum));
		lasttype = lsa->type;
		break;
	case IMSG_CTL_AREA:
		area = imsg->data;
		area_id = area->id;
		lasttype = 0;
		break;
	case IMSG_CTL_IFACE:
		iface = imsg->data;
		strlcpy(ifname, iface->name, sizeof(ifname));
		lasttype = 0;
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

char *
print_ls_type(u_int8_t type)
{
	switch (type) {
	case LSA_TYPE_ROUTER:
		return ("Router");
	case LSA_TYPE_NETWORK:
		return ("Network");
	case LSA_TYPE_SUM_NETWORK:
		return ("Summary (Network)");
	case LSA_TYPE_SUM_ROUTER:
		return ("Summary (Router)");
	case LSA_TYPE_EXTERNAL:
		return ("AS External");
	case LSA_TYPE_LINK_OPAQ:
		return ("Type-9 Opaque");
	case LSA_TYPE_AREA_OPAQ:
		return ("Type-10 Opaque");
	case LSA_TYPE_AS_OPAQ:
		return ("Type-11 Opaque");
	default:
		return ("Unknown");
	}
}

void
show_db_hdr_msg_detail(struct lsa_hdr *lsa)
{
	printf("LS age: %d\n", ntohs(lsa->age));
	printf("Options: %s\n", print_ospf_options(lsa->opts));
	printf("LS Type: %s\n", print_ls_type(lsa->type));

	switch (lsa->type) {
	case LSA_TYPE_ROUTER:
		printf("Link State ID: %s\n", log_id(lsa->ls_id));
		break;
	case LSA_TYPE_NETWORK:
		printf("Link State ID: %s (address of Designated Router)\n",
		    log_id(lsa->ls_id));
		break;
	case LSA_TYPE_SUM_NETWORK:
		printf("Link State ID: %s (Network ID)\n", log_id(lsa->ls_id));
		break;
	case LSA_TYPE_SUM_ROUTER:
		printf("Link State ID: %s (ASBR Router ID)\n",
		    log_id(lsa->ls_id));
		break;
	case LSA_TYPE_EXTERNAL:
		printf("Link State ID: %s (External Network Number)\n",
		     log_id(lsa->ls_id));
		break;
	case LSA_TYPE_LINK_OPAQ:
	case LSA_TYPE_AREA_OPAQ:
	case LSA_TYPE_AS_OPAQ:
		printf("Link State ID: %s Type %d ID %d\n", log_id(lsa->ls_id),
		    LSA_24_GETHI(ntohl(lsa->ls_id)),
		    LSA_24_GETLO(ntohl(lsa->ls_id)));
		break;
	}

	printf("Advertising Router: %s\n", log_adv_rtr(lsa->adv_rtr));
	printf("LS Seq Number: 0x%08x\n", ntohl(lsa->seq_num));
	printf("Checksum: 0x%04x\n", ntohs(lsa->ls_chksum));
	printf("Length: %d\n", ntohs(lsa->len));
}

char *
print_rtr_link_type(u_int8_t type)
{
	switch (type) {
	case LINK_TYPE_POINTTOPOINT:
		return ("Point-to-Point");
	case LINK_TYPE_TRANSIT_NET:
		return ("Transit Network");
	case LINK_TYPE_STUB_NET:
		return ("Stub Network");
	case LINK_TYPE_VIRTUAL:
		return ("Virtual Link");
	default:
		return ("Unknown");
	}
}

const char *
print_ospf_flags(u_int8_t opts)
{
	static char	optbuf[32];

	snprintf(optbuf, sizeof(optbuf), "*|*|*|*|*|%s|%s|%s",
	    opts & OSPF_RTR_V ? "V" : "-",
	    opts & OSPF_RTR_E ? "E" : "-",
	    opts & OSPF_RTR_B ? "B" : "-");
	return (optbuf);
}

int
show_db_msg_detail(struct imsg *imsg)
{
	static struct in_addr	 area_id;
	static char		 ifname[IF_NAMESIZE];
	static u_int8_t		 lasttype;
	struct in_addr		 addr, data;
	struct area		*area;
	struct iface		*iface;
	struct lsa		*lsa;
	struct lsa_rtr_link	*rtr_link;
	struct lsa_asext	*asext;
	u_int16_t		 i, nlinks, off;

	/* XXX sanity checks! */

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_DB_EXT:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);
		addr.s_addr = lsa->data.asext.mask;
		printf("Network Mask: %s\n", inet_ntoa(addr));

		asext = (struct lsa_asext *)((char *)lsa + sizeof(lsa->hdr));

		printf("    Metric type: ");
		if (ntohl(lsa->data.asext.metric) & LSA_ASEXT_E_FLAG)
			printf("2\n");
		else
			printf("1\n");
		printf("    Metric: %d\n", ntohl(asext->metric)
		    & LSA_METRIC_MASK);
		addr.s_addr = asext->fw_addr;
		printf("    Forwarding Address: %s\n", inet_ntoa(addr));
		printf("    External Route Tag: %d\n\n", ntohl(asext->ext_tag));

		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_SHOW_DB_NET:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);
		addr.s_addr = lsa->data.net.mask;
		printf("Network Mask: %s\n", inet_ntoa(addr));

		nlinks = (ntohs(lsa->hdr.len) - sizeof(struct lsa_hdr)
		    - sizeof(u_int32_t)) / sizeof(struct lsa_net_link);
		off = sizeof(lsa->hdr) + sizeof(u_int32_t);
		printf("Number of Routers: %d\n", nlinks);

		for (i = 0; i < nlinks; i++) {
			addr.s_addr = lsa->data.net.att_rtr[i];
			printf("    Attached Router: %s\n", inet_ntoa(addr));
		}

		printf("\n");
		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_SHOW_DB_RTR:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);
		printf("Flags: %s\n", print_ospf_flags(lsa->data.rtr.flags));
		nlinks = ntohs(lsa->data.rtr.nlinks);
		printf("Number of Links: %d\n\n", nlinks);

		off = sizeof(lsa->hdr) + sizeof(struct lsa_rtr);

		for (i = 0; i < nlinks; i++) {
			rtr_link = (struct lsa_rtr_link *)((char *)lsa + off);

			printf("    Link connected to: %s\n",
			    print_rtr_link_type(rtr_link->type));

			addr.s_addr = rtr_link->id;
			data.s_addr = rtr_link->data;

			switch (rtr_link->type) {
			case LINK_TYPE_POINTTOPOINT:
			case LINK_TYPE_VIRTUAL:
				printf("    Link ID (Neighbors Router ID):"
				    " %s\n", inet_ntoa(addr));
				printf("    Link Data (Router Interface "
				    "address): %s\n", inet_ntoa(data));
				break;
			case LINK_TYPE_TRANSIT_NET:
				printf("    Link ID (Designated Router "
				    "address): %s\n", inet_ntoa(addr));
				printf("    Link Data (Router Interface "
				    "address): %s\n", inet_ntoa(data));
				break;
			case LINK_TYPE_STUB_NET:
				printf("    Link ID (Network ID): %s\n",
				    inet_ntoa(addr));
				printf("    Link Data (Network Mask): %s\n",
				    inet_ntoa(data));
				break;
			default:
				printf("    Link ID (Unknown): %s\n",
				    inet_ntoa(addr));
				printf("    Link Data (Unknown): %s\n",
				    inet_ntoa(data));
				break;
			}

			printf("    Metric: %d\n\n", ntohs(rtr_link->metric));

			off += sizeof(struct lsa_rtr_link) +
			    rtr_link->num_tos * sizeof(u_int32_t);
		}

		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_SHOW_DB_SUM:
	case IMSG_CTL_SHOW_DB_ASBR:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);
		addr.s_addr = lsa->data.sum.mask;
		printf("Network Mask: %s\n", inet_ntoa(addr));
		printf("Metric: %d\n\n", ntohl(lsa->data.sum.metric) &
		    LSA_METRIC_MASK);
		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_SHOW_DB_OPAQ:
		lsa = imsg->data;
		if (lsa->hdr.type != lasttype)
			show_database_head(area_id, ifname, lsa->hdr.type);
		show_db_hdr_msg_detail(&lsa->hdr);
		/* XXX should we hexdump the data? */
		lasttype = lsa->hdr.type;
		break;
	case IMSG_CTL_AREA:
		area = imsg->data;
		area_id = area->id;
		lasttype = 0;
		break;
	case IMSG_CTL_IFACE:
		iface = imsg->data;
		strlcpy(ifname, iface->name, sizeof(ifname));
		lasttype = 0;
		break;
	case IMSG_CTL_END:
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_nbr_msg(struct imsg *imsg)
{
	struct ctl_nbr	*nbr;
	char		*state;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NBR:
		nbr = imsg->data;
		if (asprintf(&state, "%s/%s", nbr_state_name(nbr->nbr_state),
		    if_state_name(nbr->iface_state)) == -1)
			err(1, NULL);
		printf("%-15s %-3d %-12s %-9s", inet_ntoa(nbr->id),
		    nbr->priority, state, fmt_timeframe_core(nbr->dead_timer));
		printf("%-15s %-9s %s\n", inet_ntoa(nbr->addr), nbr->name,
		    nbr->uptime == 0 ? "-" : fmt_timeframe_core(nbr->uptime));
		free(state);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

const char *
print_ospf_options(u_int8_t opts)
{
	static char	optbuf[32];

	snprintf(optbuf, sizeof(optbuf), "%s|%s|%s|%s|%s|%s|%s|%s",
	    opts & OSPF_OPTION_DN ? "DN" : "-",
	    opts & OSPF_OPTION_O ? "O" : "-",
	    opts & OSPF_OPTION_DC ? "DC" : "-",
	    opts & OSPF_OPTION_EA ? "EA" : "-",
	    opts & OSPF_OPTION_NP ? "N/P" : "-",
	    opts & OSPF_OPTION_MC ? "MC" : "-",
	    opts & OSPF_OPTION_E ? "E" : "-",
	    opts & OSPF_OPTION_MT ? "MT" : "-");
	return (optbuf);
}

int
show_nbr_detail_msg(struct imsg *imsg)
{
	struct ctl_nbr	*nbr;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_NBR:
		nbr = imsg->data;
		printf("\nNeighbor %s, ", inet_ntoa(nbr->id));
		printf("interface address %s\n", inet_ntoa(nbr->addr));
		printf("  Area %s, interface %s\n", inet_ntoa(nbr->area),
		    nbr->name);
		printf("  Neighbor priority is %d, "
		    "State is %s, %d state changes\n",
		    nbr->priority, nbr_state_name(nbr->nbr_state),
		    nbr->state_chng_cnt);
		printf("  DR is %s, ", inet_ntoa(nbr->dr));
		printf("BDR is %s\n", inet_ntoa(nbr->bdr));
		printf("  Options %s\n", print_ospf_options(nbr->options));
		printf("  Dead timer due in %s\n",
		    fmt_timeframe_core(nbr->dead_timer));
		printf("  Uptime %s\n", fmt_timeframe_core(nbr->uptime));
		printf("  Database Summary List %d\n", nbr->db_sum_lst_cnt);
		printf("  Link State Request List %d\n", nbr->ls_req_lst_cnt);
		printf("  Link State Retransmission List %d\n",
		    nbr->ls_retrans_lst_cnt);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

int
show_rib_msg(struct imsg *imsg)
{
	struct ctl_rt	*rt;
	char		*dstnet;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_RIB:
		rt = imsg->data;
		switch (rt->d_type) {
		case DT_NET:
			if (asprintf(&dstnet, "%s/%d", inet_ntoa(rt->prefix),
			    rt->prefixlen) == -1)
				err(1, NULL);
			break;
		case DT_RTR:
			if (asprintf(&dstnet, "%s",
			    inet_ntoa(rt->prefix)) == -1)
				err(1, NULL);
			break;
		default:
			errx(1, "Invalid route type");
		}

		printf("%-20s %-16s%s %-12s %-9s %-7d %s\n", dstnet,
		    inet_ntoa(rt->nexthop), rt->connected ? "C" : " ",
		    path_type_name(rt->p_type),
		    dst_type_name(rt->d_type), rt->cost,
		    rt->uptime == 0 ? "-" : fmt_timeframe_core(rt->uptime));
		free(dstnet);
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_rib_head(struct in_addr aid, u_int8_t d_type, u_int8_t p_type)
{
	char	*header, *format, *format2;

	switch (p_type) {
	case PT_INTRA_AREA:
	case PT_INTER_AREA:
		switch (d_type) {
		case DT_NET:
			format = "Network Routing Table";
			format2 = "";
			break;
		case DT_RTR:
			format = "Router Routing Table";
			format2 = "Type";
			break;
		default:
			errx(1, "unknown route type");
		}
		break;
	case PT_TYPE1_EXT:
	case PT_TYPE2_EXT:
		format = NULL;
		format2 = "Cost 2";
		if ((header = strdup("External Routing Table")) == NULL)
			err(1, NULL);
		break;
	default:
		errx(1, "unknown route type");
	}

	if (p_type != PT_TYPE1_EXT && p_type != PT_TYPE2_EXT)
		if (asprintf(&header, "%s (Area %s)", format,
		    inet_ntoa(aid)) == -1)
			err(1, NULL);

	printf("\n%-18s %s\n", "", header);
	free(header);

	printf("\n%-18s %-15s %-15s %-12s %-7s %-7s\n", "Destination",
	    "Nexthop", "Adv Router", "Path type", "Cost", format2);
}

const char *
print_ospf_rtr_flags(u_int8_t opts)
{
	static char	optbuf[32];

	snprintf(optbuf, sizeof(optbuf), "%s%s%s",
	    opts & OSPF_RTR_E ? "AS" : "",
	    opts & OSPF_RTR_E && opts & OSPF_RTR_B ? "+" : "",
	    opts & OSPF_RTR_B ? "ABR" : "");
	return (optbuf);
}

int
show_rib_detail_msg(struct imsg *imsg)
{
	static struct in_addr	 area_id;
	struct ctl_rt		*rt;
	struct area		*area;
	char			*dstnet;
	static u_int8_t		 lasttype;

	switch (imsg->hdr.type) {
	case IMSG_CTL_SHOW_RIB:
		rt = imsg->data;

		switch (rt->p_type) {
		case PT_INTRA_AREA:
		case PT_INTER_AREA:
			switch (rt->d_type) {
			case DT_NET:
				if (lasttype != RIB_NET)
					show_rib_head(rt->area, rt->d_type,
					     rt->p_type);
				if (asprintf(&dstnet, "%s/%d",
				    inet_ntoa(rt->prefix), rt->prefixlen) == -1)
					err(1, NULL);
				lasttype = RIB_NET;
				break;
			case DT_RTR:
				if (lasttype != RIB_RTR)
					show_rib_head(rt->area, rt->d_type,
					     rt->p_type);
				if (asprintf(&dstnet, "%s",
				    inet_ntoa(rt->prefix)) == -1)
					err(1, NULL);
				lasttype = RIB_RTR;
				break;
			default:
				errx(1, "unknown route type");
			}
			printf("%-18s %-15s ", dstnet, inet_ntoa(rt->nexthop));
			printf("%-15s %-12s %-7d", inet_ntoa(rt->adv_rtr),
			    path_type_name(rt->p_type), rt->cost);
			free(dstnet);

			if (rt->d_type == DT_RTR)
				printf(" %-7s",
				    print_ospf_rtr_flags(rt->flags));

			printf("\n");
			break;
		case PT_TYPE1_EXT:
		case PT_TYPE2_EXT:
			if (lasttype != RIB_EXT)
				show_rib_head(rt->area, rt->d_type, rt->p_type);

			if (asprintf(&dstnet, "%s/%d",
			    inet_ntoa(rt->prefix), rt->prefixlen) == -1)
				err(1, NULL);

			printf("%-18s %-15s ", dstnet, inet_ntoa(rt->nexthop));
			printf("%-15s %-12s %-7d %-7d\n",
			    inet_ntoa(rt->adv_rtr), path_type_name(rt->p_type),
			    rt->cost, rt->cost2);
			free(dstnet);

			lasttype = RIB_EXT;
			break;
		default:
			errx(1, "unknown route type");
		}
		break;
	case IMSG_CTL_AREA:
		area = imsg->data;
		area_id = area->id;
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_fib_head(void)
{
	printf("flags: * = valid, O = OSPF, C = Connected, S = Static\n");
	printf("%-6s %-4s %-20s %-17s\n", "Flags", "Prio", "Destination", "Nexthop");
}

int
show_fib_msg(struct imsg *imsg)
{
	struct kroute		*k;
	char			*p;

	switch (imsg->hdr.type) {
	case IMSG_CTL_KROUTE:
		if (imsg->hdr.len < IMSG_HEADER_SIZE + sizeof(struct kroute))
			errx(1, "wrong imsg len");
		k = imsg->data;

		if (k->flags & F_DOWN)
			printf(" ");
		else
			printf("*");

		if (!(k->flags & F_KERNEL))
			printf("O");
		else if (k->flags & F_CONNECTED)
			printf("C");
		else if (k->flags & F_STATIC)
			printf("S");
		else
			printf(" ");

		printf("     ");
		printf("%4d ", k->priority);
		if (asprintf(&p, "%s/%u", inet_ntoa(k->prefix), k->prefixlen) ==
		    -1)
			err(1, NULL);
		printf("%-20s ", p);
		free(p);

		if (k->nexthop.s_addr)
			printf("%s", inet_ntoa(k->nexthop));
		else if (k->flags & F_CONNECTED)
			printf("link#%u", k->ifindex);
		printf("\n");

		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}

void
show_interface_head(void)
{
	printf("%-15s%-15s%s\n", "Interface", "Flags",
	    "Link state");
}

const struct if_status_description
		if_status_descriptions[] = LINK_STATE_DESCRIPTIONS;
const struct ifmedia_description
		ifm_type_descriptions[] = IFM_TYPE_DESCRIPTIONS;

const char *
get_media_descr(uint64_t media_type)
{
	const struct ifmedia_description	*p;

	for (p = ifm_type_descriptions; p->ifmt_string != NULL; p++)
		if (media_type == p->ifmt_word)
			return (p->ifmt_string);

	return ("unknown");
}

const char *
get_linkstate(uint8_t if_type, int link_state)
{
	const struct if_status_description *p;
	static char buf[8];

	for (p = if_status_descriptions; p->ifs_string != NULL; p++) {
		if (LINK_STATE_DESC_MATCH(p, if_type, link_state))
			return (p->ifs_string);
	}
	snprintf(buf, sizeof(buf), "[#%d]", link_state);
	return (buf);
}

void
print_baudrate(u_int64_t baudrate)
{
	if (baudrate > IF_Gbps(1))
		printf("%llu GBit/s", baudrate / IF_Gbps(1));
	else if (baudrate > IF_Mbps(1))
		printf("%llu MBit/s", baudrate / IF_Mbps(1));
	else if (baudrate > IF_Kbps(1))
		printf("%llu KBit/s", baudrate / IF_Kbps(1));
	else
		printf("%llu Bit/s", baudrate);
}

int
show_fib_interface_msg(struct imsg *imsg)
{
	struct kif	*k;
	uint64_t	 ifms_type;

	switch (imsg->hdr.type) {
	case IMSG_CTL_IFINFO:
		k = imsg->data;
		printf("%-15s", k->ifname);
		printf("%-15s", k->flags & IFF_UP ? "UP" : "");
		ifms_type = get_ifms_type(k->if_type);
		if (ifms_type)
			printf("%s, ", get_media_descr(ifms_type));

		printf("%s", get_linkstate(k->if_type, k->link_state));

		if (k->link_state != LINK_STATE_DOWN && k->baudrate > 0) {
			printf(", ");
			print_baudrate(k->baudrate);
		}
		printf("\n");
		break;
	case IMSG_CTL_END:
		printf("\n");
		return (1);
	default:
		break;
	}

	return (0);
}
@


1.63
log
@Another imsg_read EAGAIN check. OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.62 2015/11/22 13:11:26 claudio Exp $ */
d437 1
a437 1
		printf("  Linkstate %s\n",
d439 1
@


1.62
log
@There is still a bit of an issue with connected routes in the RIB. Print
what ospfd thinks is connected by adding a 'C' to the nexthop output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.61 2015/10/09 23:33:54 deraadt Exp $ */
d256 1
a256 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.61
log
@can use pledge "stdio"; ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.60 2015/09/27 17:31:50 stsp Exp $ */
d1056 3
a1058 2
		printf("%-20s %-17s %-12s %-9s %-7d %s\n", dstnet,
		    inet_ntoa(rt->nexthop), path_type_name(rt->p_type),
@


1.60
log
@As done for bgpd recently, rename if_mediatype to if_type in ospfd/ospf6d.
And some ifmedia64 fixes.
"move forward" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.59 2015/09/13 11:13:12 deraadt Exp $ */
d126 3
@


1.59
log
@match a few if_media uint64_t conversions; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.58 2013/11/13 22:52:41 sthen Exp $ */
d43 1
a43 1
int		 get_ifms_type(int);
d69 1
a69 1
const char *	 get_linkstate(uint64_t, int);
d370 2
a371 2
int
get_ifms_type(int mediatype)
d373 1
a373 1
	switch (mediatype) {
d404 1
a404 1
		    get_linkstate(iface->mediatype, iface->linkstate),
d435 1
a435 1
		    get_linkstate(iface->mediatype, iface->linkstate));
d1292 1
a1292 1
get_linkstate(uint64_t media_type, int link_state)
d1298 1
a1298 1
		if (LINK_STATE_DESC_MATCH(p, media_type, link_state))
d1329 1
a1329 1
		ifms_type = get_ifms_type(k->media_type);
d1333 1
a1333 1
		printf("%s", get_linkstate(k->media_type, k->link_state));
@


1.58
log
@handle msgbuf_write() returning EAGAIN, looks right to deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.57 2013/04/09 14:51:33 gilles Exp $ */
d68 2
a69 2
const char *	 get_media_descr(int);
const char *	 get_linkstate(int, int);
d1280 1
a1280 1
get_media_descr(int media_type)
d1292 1
a1292 1
get_linkstate(int media_type, int link_state)
d1322 1
a1322 1
	int		 ifms_type;
@


1.57
log
@do not store a time_t or the result of a time_t division in an int

prompted by deraadt@@, ok claudio@@ chl@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.56 2011/05/09 12:25:35 claudio Exp $ */
d30 1
d249 1
a249 1
		if (msgbuf_write(&ibuf->w) < 0)
@


1.56
log
@ospfctl bits for opaque LSA support.
tested and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.55 2010/09/25 13:29:56 claudio Exp $ */
d524 2
a525 1
	unsigned int	 sec, min, hrs, day, week;
d546 1
a546 1
		snprintf(buf, TF_LEN, "%02uw%01ud%02uh", week, day, hrs);
@


1.55
log
@Print the checksum sum as a simple fingerprint of the LSDB.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.54 2010/06/12 09:44:44 bluhm Exp $ */
d50 1
a50 1
void		 show_database_head(struct in_addr, u_int8_t);
d186 3
d289 1
d593 1
a593 1
show_database_head(struct in_addr aid, u_int8_t type)
d596 1
d616 12
d629 4
a632 1
		errx(1, "unknown LSA type");
d634 5
a638 1
	if (type != LSA_TYPE_EXTERNAL)
d645 2
d653 1
d656 1
d664 1
a664 1
			show_database_head(area_id, lsa->type);
d679 5
d708 6
d745 7
d793 1
d797 1
d809 1
a809 1
			show_database_head(area_id, lsa->hdr.type);
d832 1
a832 1
			show_database_head(area_id, lsa->hdr.type);
d853 1
a853 1
			show_database_head(area_id, lsa->hdr.type);
d910 1
a910 1
			show_database_head(area_id, lsa->hdr.type);
d918 8
d931 5
d978 3
a980 1
	snprintf(optbuf, sizeof(optbuf), "*|*|%s|%s|%s|%s|%s|*",
d985 2
a986 1
	    opts & OSPF_OPTION_E ? "E" : "-");
@


1.54
log
@Print 'Number of Routers' in show database network.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.53 2010/02/19 10:35:52 dlg Exp $ */
d338 2
a339 1
		printf("Number of external LSA(s) %d\n", sum->num_ext_lsa);
d352 2
a353 1
		printf("  Number LSA(s) %d\n", sumarea->num_lsa);
@


1.53
log
@implement ospfctl fib reload.

this tells the daemon to resync the kernels list of interfaces and routes
with the daemons list. this is very useful if the routing socket overflows
and you want to sync things up again.

lots and lots of help from claudio@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.51 2010/02/16 08:22:42 dlg Exp $ */
d790 1
@


1.52
log
@implement support for fast hello packets.

if route-dead-time is set to "minimal" (rather than a number of
seconds), the dead time is set to 1 second and hellos are sent at
the interval specified by fast-hello-interval in msecs. this is non
standard wrt to the ospf rfc, but it does interoperate with at least
one other router vendor.

this allows much better responsiveness to l3 topology changes than
the standard intervals allow. if i yank a cable to one of my
upstreams, the routes adjust in a second rather than the default
of 40 i was running with before. the users dont even notice something
changed.

developed while working with joshua atterbury.
ok claudio@@ as part of a larger diff.
dedicated to zan rowe who thinks she is a bigger nerd than me.
@
text
@d223 5
d304 1
@


1.51
log
@allow spf-delay and spf-holdtime to be specified in msec so ospfd can
better respond to rapid topology changes.

developed while working with joshua atterbury
ok claudio@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.50 2009/11/02 20:23:29 claudio Exp $ */
d389 2
a390 2
		    iface->hello_timer < 0 ? "-" :
		    fmt_timeframe_core(iface->hello_timer),
d435 12
a446 4
		printf("  Timer intervals configured, "
		    "hello %d, dead %d, wait %d, retransmit %d\n",
		     iface->hello_interval, iface->dead_interval,
		     iface->dead_interval, iface->rxmt_interval);
d449 1
a449 1
		else if (iface->hello_timer < 0)
d452 3
a454 2
			printf("    Hello timer due in %s\n",
			    fmt_timeframe_core(iface->hello_timer));
@


1.50
log
@Implement "log verbose" and "log brief" to enable or disable verbose debug
logging. henning, sthen, michele like the idea
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.49 2009/09/14 11:49:25 claudio Exp $ */
d330 2
a331 2
		printf("SPF delay is %d sec(s), hold time between two SPFs "
		    "is %d sec(s)\n", sum->spf_delay, sum->spf_hold_time);
@


1.49
log
@Switch the various link state printing codes to use the new if_media
independent LINK_STATE_DESCRIPTIONS. Code is now more or less a one to
one copy of get_linkstate() in route/route.c.
OK henning, michele, sthen, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.48 2009/06/06 07:31:26 eric Exp $ */
d93 1
a93 1
	int			 n;
d223 9
d299 2
@


1.48
log
@sync ospfctl/ospfd with the common imsg code, making it lib ready as well.

"looks ok" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.47 2009/06/05 21:19:11 pyr Exp $ */
d380 2
a381 2
		    get_linkstate(get_ifms_type(iface->mediatype),
		    iface->linkstate), fmt_timeframe_core(iface->uptime),
d411 1
a411 2
		    get_linkstate(get_ifms_type(iface->mediatype),
		    iface->linkstate));
d1179 2
a1180 3
const int	ifm_status_valid_list[] = IFM_STATUS_VALID_LIST;
const struct ifmedia_status_description
		ifm_status_descriptions[] = IFM_STATUS_DESCRIPTIONS;
d1199 2
a1200 2
	const struct ifmedia_status_description	*p;
	int					 i;
d1202 6
a1207 14
	if (link_state == LINK_STATE_UNKNOWN)
		return ("unknown");

	for (i = 0; ifm_status_valid_list[i] != 0; i++)
		for (p = ifm_status_descriptions; p->ifms_valid != 0; p++) {
			if (p->ifms_type != media_type ||
			    p->ifms_valid != ifm_status_valid_list[i])
				continue;
			if (LINK_STATE_IS_UP(link_state))
				return (p->ifms_string[1]);
			return (p->ifms_string[0]);
		}

	return ("unknown");
d1234 3
a1236 14
		switch (k->media_type) {
		case IFT_ETHER:
			ifms_type = IFM_ETHER;
			break;
		case IFT_FDDI:
			ifms_type = IFM_FDDI;
			break;
		case IFT_CARP:
			ifms_type = IFM_CARP;
			break;
		default:
			ifms_type = 0;
			break;
		}
d1238 1
a1238 7
		if (ifms_type)
			printf("%s, %s", get_media_descr(ifms_type),
			    get_linkstate(ifms_type, k->link_state));
		else if (k->link_state == LINK_STATE_UNKNOWN)
			printf("unknown");
		else
			printf("link state %u", k->link_state);
@


1.47
log
@forgot to commit the ospfctl bits, this unbreaks the tree.
noticed by michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.46 2009/04/07 14:57:33 reyk Exp $ */
d128 1
a128 1
	imsg_init(ibuf, ctl_sock, NULL);
@


1.46
log
@allow to specify an alternate control socket instead of /var/run/ospfd.sock.
this is required to run multiple instances of ospfd.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.45 2009/01/30 12:43:18 norby Exp $ */
a83 7
/* dummy function so that ospfctl does not need libevent */
void
imsg_event_add(struct imsgbuf *i)
{
	/* nothing */
}

d138 1
a138 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_SUM, 0, 0, NULL, 0);
d151 1
a151 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0,
d159 1
a159 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_NBR, 0, 0, NULL, 0);
d162 1
a162 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DATABASE, 0, 0, NULL, 0);
d165 1
a165 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DATABASE, 0, 0,
d169 1
a169 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_EXT, 0, 0, NULL, 0);
d172 1
a172 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_NET, 0, 0, NULL, 0);
d175 1
a175 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_RTR, 0, 0, NULL, 0);
d178 1
a178 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_SELF, 0, 0, NULL, 0);
d181 1
a181 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_SUM, 0, 0, NULL, 0);
d184 1
a184 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_ASBR, 0, 0, NULL, 0);
d191 1
a191 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_RIB, 0, 0, NULL, 0);
d195 1
a195 1
			imsg_compose(ibuf, IMSG_CTL_KROUTE, 0, 0,
d198 1
a198 1
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0,
d204 1
a204 1
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0,
d207 1
a207 1
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, NULL, 0);
d214 1
a214 1
		imsg_compose(ibuf, IMSG_CTL_FIB_COUPLE, 0, 0, NULL, 0);
d219 1
a219 1
		imsg_compose(ibuf, IMSG_CTL_FIB_DECOUPLE, 0, 0, NULL, 0);
d224 1
a224 1
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, NULL, 0);
@


1.45
log
@Add missing free.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.44 2009/01/02 00:09:53 claudio Exp $ */
d79 2
a80 1
	fprintf(stderr, "usage: %s command [argument ...]\n", __progname);
d101 16
d119 1
a119 1
	if ((res = parse(argc - 1, argv + 1)) == NULL)
d128 2
a129 1
	strlcpy(sun.sun_path, OSPFD_SOCKET, sizeof(sun.sun_path));
d131 1
a131 1
		err(1, "connect: %s", OSPFD_SOCKET);
@


1.44
log
@In show interface only print the hello_timer value if valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.43 2008/12/12 22:44:07 claudio Exp $ */
d1082 1
@


1.43
log
@ospfd knows now priorities so let ospfctl know and print them as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.42 2008/12/06 13:18:12 sobrado Exp $ */
d367 1
@


1.42
log
@the ellipsis allows more than one argument being specified.

discussed with gilles@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.41 2007/10/15 02:16:35 deraadt Exp $ */
d1106 1
a1106 1
	printf("%-6s %-20s %-17s\n", "Flags", "Destination", "Nexthop");
d1136 1
@


1.41
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.40 2007/10/14 01:28:08 deraadt Exp $ */
d79 1
a79 1
	fprintf(stderr, "usage: %s <command> [arg [...]]\n", __progname);
@


1.40
log
@please lint
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.39 2007/10/11 12:03:37 norby Exp $ */
d481 1
a481 1
	unsigned	 sec, min, hrs, day, week;
@


1.39
log
@Cleanup the way we display timers.

It does not make sense to display timer = 0 as "Stopped". When a timer is
0 it usually means that it is getting reset very soon. Display the string
"00:00:00" instead.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.38 2007/09/11 16:01:22 claudio Exp $ */
d133 1
d146 1
d178 1
@


1.38
log
@Baudrate is 64bit so use %llu in printf(). Reminded by chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.37 2007/05/30 02:21:08 henning Exp $ */
d298 1
a298 2
		printf("Uptime: %s\n", sum->uptime == 0 ? "00:00:00" :
		    fmt_timeframe_core(sum->uptime));
a363 1
		    iface->hello_timer < 0 ? "stopped" :
d366 2
a367 3
		    iface->linkstate), iface->uptime == 0 ? "00:00:00" :
		    fmt_timeframe_core(iface->uptime), iface->nbr_cnt,
		    iface->adj_cnt);
d421 1
a421 2
		printf("    Uptime %s\n", iface->uptime == 0 ?
		    "00:00:00" : fmt_timeframe_core(iface->uptime));
d481 1
a481 1
		return ("Stopped");
@


1.37
log
@yuck, no cookie for me
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.36 2006/11/28 19:21:15 reyk Exp $ */
d69 1
a69 1
void		 print_baudrate(u_long);
d1208 1
a1208 1
print_baudrate(u_long baudrate)
d1211 1
a1211 1
		printf("%lu GBit/s", baudrate / IF_Gbps(1));
d1213 1
a1213 1
		printf("%lu MBit/s", baudrate / IF_Mbps(1));
d1215 1
a1215 1
		printf("%lu KBit/s", baudrate / IF_Kbps(1));
d1217 1
a1217 1
		printf("%lu Bit/s", baudrate);
@


1.36
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.35 2006/08/23 08:26:03 claudio Exp $ */
a340 2
	case IFT_ISO88025:
		return (IFM_TOKEN);
a1236 3
			break;
		case IFT_ISO88025:
			ifms_type = IFM_TOKEN;
@


1.35
log
@Add a comment about the empty imsg_event_add() function to make it clear
why it is needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.34 2006/06/28 10:53:39 norby Exp $ */
d1201 3
a1203 1
			return (p->ifms_string[link_state == LINK_STATE_UP]);
@


1.34
log
@Track the uptime of the ospfd daemon itself.
It is possible to read the uptime of the daemon with the "ospfctl show"
command.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.33 2006/04/21 16:36:39 claudio Exp $ */
d83 1
d87 1
@


1.33
log
@Add IFT_PPP to the iftype to ifmedia type conversion function. Now P2P links
will show the correct link state. While there do some cleanup and shorten the
output if the media or link state is unknown.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.32 2006/03/26 09:47:54 norby Exp $ */
d296 2
@


1.32
log
@Show the neighbor uptime in "show nei detail".

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.31 2006/03/26 09:45:55 norby Exp $ */
a334 1
		break;
a336 1
		break;
a338 1
		break;
d341 2
a342 1
		break;
a344 1
		break;
d1180 1
a1180 1
	return ("unknown media");
d1200 1
a1200 1
	return ("unknown link state");
@


1.31
log
@Show the link status of interfaces for real, I guess most users don't know
what it means that an interface is in state 2.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.30 2006/03/23 18:37:34 norby Exp $ */
d909 1
@


1.30
log
@List interfaces they way we list neighbors etc.
This makes it much easier to grep in the output.
The original format of "show interface" can be seen with
"show interface detail".

help and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.29 2006/03/22 15:37:44 claudio Exp $ */
d42 1
d330 22
a355 1
	int			 ifms_type;
a360 18
		switch (iface->mediatype) {
		case IFT_ETHER:
			ifms_type = IFM_ETHER;
			break;
		case IFT_FDDI:
			ifms_type = IFM_FDDI;
			break;
		case IFT_ISO88025:
			ifms_type = IFM_TOKEN;
			break;
		case IFT_CARP:
			ifms_type = IFM_CARP;
			break;
		default:
			ifms_type = 0;
			break;
		}

d368 2
a369 2
		    get_linkstate(ifms_type, iface->linkstate),
		    iface->uptime == 0 ? "00:00:00" :
d393 2
a394 2
		printf("Interface %s is %d, line protocol is %s\n",
		    iface->name, iface->linkstate, print_link(iface->flags));
d399 3
@


1.29
log
@ospfd has the framework to couple and decouple the FIB. Add the needed
functionality to ospfctl for it.
NOTE: decoupling the FIB one a router may totaly fuck up the complete network.
Use it with care!
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.28 2006/03/09 18:11:33 norby Exp $ */
d43 1
d127 4
d236 3
d330 52
@


1.28
log
@Track interface uptime.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.27 2006/03/09 15:44:07 claudio Exp $ */
d188 13
d262 3
@


1.27
log
@Start using *_name function that are now shared between ospfd and ospfctl.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.26 2006/03/08 15:02:15 claudio Exp $ */
d342 2
@


1.26
log
@Last kroute.c commit changed the meaning of the flags so check them correctly.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.25 2006/02/24 21:06:46 norby Exp $ */
a42 3
const char	*print_if_type(enum iface_type type);
const char	*print_if_state(int);
const char	*print_nbr_state(int);
d321 1
a321 1
		    print_if_type(iface->type), iface->metric);
d323 1
a323 1
		    iface->transmit_delay, print_if_state(iface->state),
a371 69
print_if_type(enum iface_type type)
{
	switch (type) {
	case IF_TYPE_POINTOPOINT:
		return ("POINTOPOINT");
	case IF_TYPE_BROADCAST:
		return ("BROADCAST");
	case IF_TYPE_NBMA:
		return ("NBMA");
	case IF_TYPE_POINTOMULTIPOINT:
		return ("POINTOMULTIPOINT");
	case IF_TYPE_VIRTUALLINK:
		return ("VIRTUALLINK");
	default:
		return ("UNKNOWN");
	}
}

const char *
print_if_state(int state)
{
	switch (state) {
	case IF_STA_DOWN:
		return ("DOWN");
	case IF_STA_LOOPBACK:
		return ("LOOP");
	case IF_STA_WAITING:
		return ("WAIT");
	case IF_STA_POINTTOPOINT:
		return ("P2P");
	case IF_STA_DROTHER:
		return ("OTHER");
	case IF_STA_BACKUP:
		return ("BCKUP");
	case IF_STA_DR:
		return ("DR");
	default:
		return ("UNKNW");
	}
}

const char *
print_nbr_state(int state)
{
	switch (state) {
	case NBR_STA_DOWN:
		return ("DOWN");
	case NBR_STA_ATTEMPT:
		return ("ATTMP");
	case NBR_STA_INIT:
		return ("INIT");
	case NBR_STA_2_WAY:
		return ("2-WAY");
	case NBR_STA_XSTRT:
		return ("EXSTA");
	case NBR_STA_SNAP:
		return ("SNAP");
	case NBR_STA_XCHNG:
		return ("EXCHG");
	case NBR_STA_LOAD:
		return ("LOAD");
	case NBR_STA_FULL:
		return ("FULL");
	default:
		return ("UNKNW");
	}
}

const char *
d770 2
a771 2
		if (asprintf(&state, "%s/%s", print_nbr_state(nbr->nbr_state),
		    print_if_state(nbr->iface_state)) == -1)
d817 1
a817 1
		    nbr->priority, print_nbr_state(nbr->nbr_state),
d864 2
a865 2
		    inet_ntoa(rt->nexthop), path_type_names[rt->p_type],
		    dst_type_names[rt->d_type], rt->cost,
d975 1
a975 1
			    path_type_names[rt->p_type], rt->cost);
d995 1
a995 1
			    inet_ntoa(rt->adv_rtr), path_type_names[rt->p_type],
@


1.25
log
@Keep track of the uptime of the entries in the RIB.
It is now possible to see the uptime of the individual entries in the RIB.
The uptime can be displayed with "ospfctl show rib"

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.24 2006/02/19 21:48:56 norby Exp $ */
d1114 1
a1114 1
		if (k->flags & F_OSPFD_INSERTED)
@


1.24
log
@Keep track of the duration of our relationships with neighbors.
Displayed in "ospfctl show neighbor".

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.23 2006/02/10 18:31:49 claudio Exp $ */
d169 2
a170 2
		printf("%-20s %-17s %-12s %-9s %-7s\n", "Destination",
		    "Nexthop", "Path Type", "Type", "Cost");
d935 1
a935 1
		printf("%-20s %-17s %-12s %-9s %-7d\n", dstnet,
d937 2
a938 1
		    dst_type_names[rt->d_type], rt->cost);
@


1.23
log
@imsg API changed so adapt to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.22 2005/10/27 22:37:30 stevesk Exp $ */
d138 2
a139 2
		printf("%-15s %-3s %-17s %-9s %-15s %s\n", "ID", "Pri",
		    "State", "DeadTime", "Address", "Interface");
d356 1
a356 1
				printf("    Primary key id is %d\n", 
d400 1
a400 1
		return ("LOOPBACK");
d402 1
a402 1
		return ("WAITING");
d406 1
a406 1
		return ("DROTHER");
d408 1
a408 1
		return ("BACKUP");
d412 1
a412 1
		return ("UNKNOWN");
d423 1
a423 1
		return ("ATTEMPT");
d429 1
a429 1
		return ("EXSTART");
d431 1
a431 1
		return ("SNAPSHOT");
d433 1
a433 1
		return ("EXCHANGE");
d435 1
a435 1
		return ("LOADING");
d439 1
a439 1
		return ("UNKNOWN");
d845 1
a845 1
		printf("%-15s %-3d %-17s %-9s ", inet_ntoa(nbr->id),
d847 2
a848 1
		printf("%-15s %s\n", inet_ntoa(nbr->addr), nbr->name);
@


1.22
log
@indicate passive interface in 'show interface'; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.21 2005/10/23 20:21:44 stevesk Exp $ */
d126 1
a126 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_SUM, 0, 0, -1, NULL, 0);
d134 1
a134 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_INTERFACE, 0, 0, -1,
d141 1
a141 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_NBR, 0, 0, -1, NULL, 0);
d144 1
a144 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DATABASE, 0, 0, -1, NULL, 0);
d147 1
a147 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DATABASE, 0, 0, -1,
d151 1
a151 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_EXT, 0, 0, -1, NULL, 0);
d154 1
a154 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_NET, 0, 0, -1, NULL, 0);
d157 1
a157 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_RTR, 0, 0, -1, NULL, 0);
d160 1
a160 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_SELF, 0, 0, -1, NULL, 0);
d163 1
a163 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_SUM, 0, 0, -1, NULL, 0);
d166 1
a166 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_DB_ASBR, 0, 0, -1, NULL, 0);
d172 1
a172 1
		imsg_compose(ibuf, IMSG_CTL_SHOW_RIB, 0, 0, -1, NULL, 0);
d176 1
a176 1
			imsg_compose(ibuf, IMSG_CTL_KROUTE, 0, 0, -1,
d179 1
a179 1
			imsg_compose(ibuf, IMSG_CTL_KROUTE_ADDR, 0, 0, -1,
d185 1
a185 1
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, -1,
d188 1
a188 1
			imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, -1, NULL, 0);
d192 1
a192 1
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
@


1.21
log
@use err() vs. fatal(); ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.20 2005/10/16 19:31:44 stevesk Exp $ */
d338 3
a340 1
		if (iface->hello_timer < 0)
@


1.20
log
@remove duplicate function declaration; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.19 2005/10/16 17:12:30 stevesk Exp $ */
a38 1
#include "log.h"
d115 1
a115 1
		fatal(NULL);
@


1.19
log
@missing break caused erroneous auth-type crypt enabled in 'sh int'
when simple enabled; ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.18 2005/09/24 21:10:32 msf Exp $ */
a43 1
void		 print_baudrate(u_long);
@


1.18
log
@- add auth_type and auth_keyid to struct ctl_iface
- have ospfctl tell us when we are using authentication with 'show interface'

ok claudio@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.17 2005/05/27 00:51:52 norby Exp $ */
d352 1
d358 1
@


1.17
log
@Small formatting bits in show neighbor detail.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.16 2005/05/26 06:07:47 norby Exp $ */
d347 14
@


1.16
log
@Fix multi area display bug.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.15 2005/05/22 20:01:47 norby Exp $ */
d868 2
a869 2
		printf("  In the area %s via interface %s\n",
		    inet_ntoa(nbr->area), nbr->name);
d876 1
a876 2
		printf("  Options is 0x%x  %s\n", nbr->options,
		    print_ospf_options(nbr->options));
@


1.15
log
@Add missing bits to ospfctl show rib detail.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.14 2005/05/12 19:10:12 norby Exp $ */
d806 1
@


1.14
log
@Add "show database asbr/external/network/router/self-originate/summary"
to ospfctl.

Show detailed information about the LSAs in the Link State Database.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.13 2005/05/06 06:59:58 norby Exp $ */
d65 1
d936 1
a936 1
	char	*header, *format;
d944 1
d948 1
d957 1
d970 1
a970 1
	printf("\n%-15s %s\n", "", header);
d973 3
a975 2
	printf("\n%-20s %-17s %-17s %-12s %-8s\n",
	    "Destination", "Nexthop", "Adv Router", "Path type", "Cost");
d977 10
d1027 2
a1028 2
			printf("%-20s %-17s ", dstnet, inet_ntoa(rt->nexthop));
			printf("%-17s %-12s %-7d\n", inet_ntoa(rt->adv_rtr),
d1031 6
d1040 13
a1052 1
			/* XXX TODO */
a1185 1

@


1.13
log
@Fix a display bug in 'show database', when ospfd is member of more
than one area.

Input from claudio.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.12 2005/04/16 21:52:57 claudio Exp $ */
d55 5
d151 18
d230 1
d233 7
d552 1
a552 1
	printf("\n%-15s %s\n", "", header);
a553 3

	printf("\n%-15s %-15s %-4s %-10s %-8s\n", "Link ID", "Adv Router",
	    "Age", "Seq#", "Checksum");
d566 1
d568 1
a568 1
		if (lsa->type != lasttype)
d570 3
d585 222
a1206 1

@


1.12
log
@Static routes are flagged with F_STATIC and not with F_KERNEL.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.11 2005/03/29 17:26:35 norby Exp $ */
d550 1
@


1.11
log
@The RFC never mentions anything about transfer, this should be transmit.

From Jason Ackley (thanks).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.10 2005/03/26 13:37:16 claudio Exp $ */
d812 1
a812 1
		else if (k->flags & F_KERNEL)
@


1.10
log
@ospfctl bits for the "ospfctl show fib interface" part. This will print
the interface status as seen from the parent kroute perspective.
OK henning@@ norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.9 2005/03/23 20:18:19 claudio Exp $ */
d296 1
a296 1
		    iface->transfer_delay, print_if_state(iface->state),
@


1.9
log
@Sync mask2prefixlen() with the kroute.c version of ospfd because they share
the same prototype definition comming from ospfd.h.
OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.8 2005/03/15 22:09:43 claudio Exp $ */
d162 5
a166 1
		imsg_compose(ibuf, IMSG_CTL_IFINFO, 0, 0, -1, NULL, 0);
d844 1
a844 1
	printf("%-15s%-15s%-15s%s\n", "Interface", "Nexthop state", "Flags",
d907 1
a907 1
	case IMSG_CTL_SHOW_INTERFACE:
a909 1
		printf("%-15s", k->nh_reachable ? "ok" : "invalid");
@


1.8
log
@bgpctl parts for "show fib".
OK norby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.7 2005/03/14 18:21:29 norby Exp $ */
a52 1
u_int8_t	 mask2prefixlen(struct in_addr);
d286 1
a286 1
		    mask2prefixlen(iface->mask));
d476 1
d478 1
a478 1
mask2prefixlen(struct in_addr ina)
d480 1
a480 1
	if (ina.s_addr == 0)
d483 1
a483 1
		return (33 - ffs(ntohl(ina.s_addr)));
@


1.7
log
@Add "show summary" to ospfctl.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.6 2005/03/12 11:03:05 norby Exp $ */
d26 2
d62 7
d153 13
d212 6
d779 171
@


1.6
log
@Add "show rib" and "show rib detail" to ospfctl.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.5 2005/03/12 10:49:12 norby Exp $ */
d40 1
a40 1
int		 show_summary_msg(struct imsg *, int);
a84 1
	int			 nodescr = 0;
d113 2
a114 1
	case SHOW_SUMMARY:
d168 2
a169 2
			case SHOW_SUMMARY:
				done = show_summary_msg(&imsg, nodescr);
d204 1
a204 1
show_summary_msg(struct imsg *imsg, int nodescr)
d206 36
d264 1
a264 1
		printf("  Transmit delay is %d sec, state %s, priority %d\n",
@


1.5
log
@Small K&F.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.4 2005/02/02 19:08:42 henning Exp $ */
d5 1
a5 1
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
d57 3
d138 6
d184 6
d559 146
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.3 2005/02/02 18:52:32 henning Exp $ */
d123 2
a124 2
		printf("%-15s %-3s %-17s %-9s %-15s %s\n",
		    "ID", "Pri", "State", "DeadTime", "Address", "Interface");
d441 2
a442 2
	printf("\n%-15s %-15s %-4s %-10s %-8s\n",
	    "Link ID", "Adv Router", "Age", "Seq#", "Checksum");
@


1.3
log
@usage() is __dead
pt out by Alexander v Gernler
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.2 2005/01/28 17:26:05 norby Exp $ */
d76 1
a76 1
{ 
d210 1
a210 1
		printf("  Router ID %s, network type %s, cost: %d\n", 
d226 1
a226 1
		if (iface->hello_timer < 0) 
d241 1
a241 1
	return (0); 
d474 1
a474 1
	return (0); 
@


1.2
log
@Change my email address to the OpenBSD one since Ericsson has nothing to
do with this software, just happend to be my only valid email address at
the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ospfctl.c,v 1.1 2005/01/28 14:18:46 claudio Exp $ */
d39 1
a39 1
void		 usage(void);
d60 1
a60 1
void
@


1.1
log
@Control program like bgpctl but this time for ospfd.
Currently only basic show commands work.

Not yet connected to the builds.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d5 1
a5 1
 * Copyright (c) 2004 Esben Norby <esben.norby@@ericsson.com>
@

