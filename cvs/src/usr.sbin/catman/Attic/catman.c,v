head	1.9;
access;
symbols
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.20
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.18
	OPENBSD_2_8:1.2.0.16
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2007.05.15.21.45.19;	author jmc;	state dead;
branches;
next	1.8;

1.8
date	2007.03.20.04.00.32;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.28.20.37.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.15.08.32.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.01.20.15.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.29.09.47.20;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.28.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.15.23.43.49;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.29;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.9
log
@nothing uses catman, so kill it; ok millert deraadt
@
text
@/*	$OpenBSD: catman.c,v 1.8 2007/03/20 04:00:32 tedu Exp $	*/
/*
 * Copyright (c) 1993 Winning Strategies, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Winning Strategies, Inc.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef lint
static char rcsid[] = "$Id: catman.c,v 1.8 2007/03/20 04:00:32 tedu Exp $";
#endif /* not lint */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <paths.h>

#include "pathnames.h"

int f_nowhatis;
int f_noaction;
int f_noformat;
int f_ignerr;
int f_noprint;

int dowhatis;

char *mp = _PATH_MAN;
char *sp = _MAN_SECTIONS;

void usage(void);
void catman(const char *, char *);
void makewhatis(const char *);
void dosystem(const char *);

int
main(int argc, char **argv)
{
	int c;

	while ((c = getopt(argc, argv, "knpswM:")) != -1) {
		switch (c) {
		case 'k':
			f_ignerr = 1;
			break;
		case 'n':
			f_nowhatis = 1;
			break;
		case 'p':
			f_noaction = 1;
			break;
		case 's':
			f_noprint = 1;
			break;
		case 'w':
			f_noformat = 1;
			break;
		case 'M':
			mp = optarg;
			break;

		case '?':
		default:
			usage();
		}
	}

	argc -= optind;
	argv += optind;

	if (f_noprint && f_noaction)
		f_noprint = 0;

	if (argc > 1)
		usage();
	if (argc == 1)
		sp = *argv;

	if (f_noformat == 0 || f_nowhatis == 0)
		catman(mp, sp);
	if (f_nowhatis == 0 && dowhatis)
		makewhatis(mp);

	exit(0);
}


void
catman(const char *path, char *section)
{
	char mandir[PATH_MAX];
	char catdir[PATH_MAX];
	char manpage[PATH_MAX];
	char catpage[PATH_MAX];
	char sysbuf[1024];
	struct stat manstat;
	struct stat catstat;
	struct dirent *dp;
	DIR *dirp;
	char *s, *tmp;
	int sectlen, error;

	for (s = section; *s; s += sectlen) {
#ifdef notdef
		tmp = s;
		sectlen = 0;
		if (isdigit(*tmp)) {
			sectlen++;
			tmp++;
			while (isdigit(*tmp) == 0) {
				sectlen++;
				tmp++;
			}
		}
#else
		sectlen = 1;
#endif
		if (sectlen == 0)
			errx(1, "malformed section string");

		snprintf(mandir, sizeof mandir, "%s/%s%.*s", path,
		    _PATH_MANPAGES, sectlen, s);
		snprintf(catdir, sizeof catdir, "%s/%s%.*s", path,
		    _PATH_CATPAGES, sectlen, s);

		if ((dirp = opendir(mandir)) == 0) {
			warn("can't open %s", mandir);
			continue;
		}

		if (stat(catdir, &catstat) < 0) {
			if (errno != ENOENT) {
				warn("can't stat %s", catdir);
				closedir(dirp);
				continue;
			}
			if (f_noprint == 0)
				printf("mkdir %s\n", catdir);
			if (f_noaction == 0 && mkdir(catdir, 0755) < 0) {
				warn("can't create %s", catdir);
				closedir(dirp);
				return;
			}

		}

		while ((dp = readdir(dirp)) != NULL) {
			if (strcmp(dp->d_name, ".") == 0 ||
			    strcmp(dp->d_name, "..") == 0)
				continue;

			snprintf(manpage, sizeof manpage, "%s/%s",
			    mandir, dp->d_name);
			snprintf(catpage, sizeof catpage, "%s/%s",
			    catdir, dp->d_name);
			if ((tmp = strrchr(catpage, '.')) != NULL)
				strlcpy(tmp, ".0", catpage + sizeof catpage - tmp);
			else
				continue;

			if (stat(manpage, &manstat) < 0) {
				warn("can't stat %s", manpage);
				continue;
			}

			if (!S_ISREG(manstat.st_mode)) {
				warnx("not a regular file %s", manpage);
				continue;
			}
			if ((error = stat(catpage, &catstat)) &&
			    errno != ENOENT) {
				warn("can't stat %s", catpage);
				continue;
			}

			if ((error && errno == ENOENT) || 
			    manstat.st_mtime >= catstat.st_mtime) {
				if (f_noformat)
					dowhatis = 1;
				else {
					/*
					 * manpage is out of date,
					 * reformat
					 */
					snprintf(sysbuf, sizeof sysbuf,
					    "nroff -mandoc %s > %s",
					    manpage, catpage);
					if (f_noprint == 0)
						printf("%s\n", sysbuf);
					if (f_noaction == 0)
						dosystem(sysbuf);
					dowhatis = 1;
				}
			}
		}
		closedir(dirp);
	}
}

void
makewhatis(const char *path)
{
	char sysbuf[1024];

	snprintf(sysbuf, sizeof sysbuf, "%s %s", _PATH_MAKEWHATIS, path);
	if (f_noprint == 0)
		printf("%s\n", sysbuf);
	if (f_noaction == 0)
		dosystem(sysbuf);
}

void
dosystem(const char *cmd)
{
	int status;

	if ((status = system(cmd)) == 0)
		return;

	if (status == -1)
		err(1, "cannot execute action");
	if (WIFSIGNALED(status))
		errx(1, "child was signaled to quit. aborting");
	if (WIFSTOPPED(status))
		errx(1, "child was stopped. aborting");
	if (f_ignerr == 0)
		errx(1,"*** Exited %d", status);
	warnx("*** Exited %d (continuing)", status);
}

void
usage(void)
{
	extern char *__progname;

	(void)fprintf(stderr,
	    "usage: %s [-knpsw] [-M manpath] [sections]\n", __progname);
	exit(1);
}
@


1.8
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: catman.c,v 1.7 2003/06/28 20:37:29 deraadt Exp $	*/
d33 1
a33 1
static char rcsid[] = "$Id: catman.c,v 1.7 2003/06/28 20:37:29 deraadt Exp $";
@


1.7
log
@() to (void)
@
text
@d1 1
a1 1
/*	$OpenBSD: catman.c,v 1.6 2003/04/15 08:32:38 deraadt Exp $	*/
d33 1
a33 1
static char rcsid[] = "$Id: catman.c,v 1.6 2003/04/15 08:32:38 deraadt Exp $";
d141 1
a141 1
			while (*tmp && isdigit(*tmp) == 0) {
@


1.6
log
@strlcpy; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: catman.c,v 1.5 2002/06/01 20:15:43 deraadt Exp $	*/
d33 1
a33 1
static char rcsid[] = "$Id: catman.c,v 1.5 2002/06/01 20:15:43 deraadt Exp $";
d263 1
a263 1
usage()
@


1.5
log
@some KNF, and missing param on warnx(); jason@@ackley.net
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 1
a33 1
static char rcsid[] = "$Id: catman.c,v 1.4 2002/05/29 09:47:20 deraadt Exp $";
d188 1
a188 1
				strcpy(tmp, ".0");
@


1.4
log
@more snprintf
@
text
@d1 1
d33 1
a33 1
static char rcsid[] = "$Id: catman.c,v 1.3 2002/02/16 21:28:01 millert Exp $";
d68 1
a68 3
main(argc, argv)
	int argc;
	char **argv;
d120 1
a120 3
catman(path, section)
	const char *path;
	char *section;
d232 1
a232 2
makewhatis(path)
	const char *path;
d244 1
a244 2
dosystem(cmd)
	const char *cmd;
d258 2
a259 2
		errx(1,"*** Exited %d");
	warnx("*** Exited %d (continuing)");
d265 2
d268 1
a268 1
	    "usage: catman [-knpsw] [-M manpath] [sections]\n");
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d32 1
a32 1
static char rcsid[] = "$Id: catman.c,v 1.2 1997/01/15 23:43:49 millert Exp $";
d155 4
a158 2
		sprintf(mandir, "%s/%s%.*s", path, _PATH_MANPAGES, sectlen, s);
		sprintf(catdir, "%s/%s%.*s", path, _PATH_CATPAGES, sectlen, s);
d186 4
a189 2
			sprintf(manpage, "%s/%s", mandir, dp->d_name);
			sprintf(catpage, "%s/%s", catdir, dp->d_name);
d219 2
a220 1
					sprintf(sysbuf, "nroff -mandoc %s > %s",
d240 1
a240 1
	sprintf(sysbuf, "%s %s", _PATH_MAKEWHATIS, path);
@


1.2
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d32 1
a32 1
static char rcsid[] = "$Id: catman.c,v 1.1.1.1 1995/10/18 08:47:29 deraadt Exp $";
d61 4
a64 4
void usage __P((void));
void catman __P((const char *, char *));
void makewhatis __P((const char *));
void dosystem __P((const char *));
@


1.1
log
@Initial revision
@
text
@d32 1
a32 1
static char rcsid[] = "$Id: catman.c,v 1.6 1994/04/27 22:37:12 cgd Exp $";
d73 1
a73 1
	while ((c = getopt(argc, argv, "knpswM:")) != EOF) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
