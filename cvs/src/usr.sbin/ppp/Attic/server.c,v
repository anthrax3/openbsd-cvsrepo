head	1.8;
access;
symbols
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	PPP1_5:1.1.1.1
	BRIAN:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	98.08.31.00.21.34;	author brian;	state dead;
branches;
next	1.7;

1.7
date	98.02.18.20.33.30;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	98.01.21.02.13.40;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	97.12.24.09.30.49;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	97.12.21.14.27.12;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	97.12.21.02.26.55;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	97.12.06.12.09.04;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	97.11.23.20.27.36;	author brian;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.11.23.20.27.36;	author brian;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@/*-
 * Copyright (c) 1997 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$Id: server.c,v 1.7 1998/02/18 20:33:30 brian Exp $
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/in_systm.h>

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/un.h>
#include <unistd.h>

#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "loadalias.h"
#include "defs.h"
#include "vars.h"
#include "server.h"
#include "id.h"

int server = -1;

static struct sockaddr_un ifsun;
static char *rm;

int
ServerLocalOpen(const char *name, mode_t mask)
{
  int s;

  if (VarLocalAuth == LOCAL_DENY) {
    LogPrintf(LogWARN, "Local: Can't open socket %s: No password "
	      "in ppp.secret\n", name);
    return 1;
  }

  if (mode & MODE_INTER) {
    LogPrintf(LogWARN, "Local: Can't open socket in interactive mode\n");
    return 1;
  }

  memset(&ifsun, '\0', sizeof ifsun);
  ifsun.sun_len = strlen(name);
  if (ifsun.sun_len > sizeof ifsun.sun_path - 1) {
    LogPrintf(LogERROR, "Local: %s: Path too long\n", name);
    return 2;
  }
  ifsun.sun_family = AF_LOCAL;
  strcpy(ifsun.sun_path, name);

  s = ID0socket(PF_LOCAL, SOCK_STREAM, 0);
  if (s < 0) {
    LogPrintf(LogERROR, "Local: socket: %s\n", strerror(errno));
    return 3;
  }
  setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &s, sizeof s);
  if (mask != (mode_t)-1)
    mask = umask(mask);
  if (bind(s, (struct sockaddr *)&ifsun, sizeof ifsun) < 0) {
    if (mask != (mode_t)-1)
      umask(mask);
    LogPrintf(LogERROR, "Local: bind: %s\n", strerror(errno));
    if (errno == EADDRINUSE && VarTerm)
      fprintf(VarTerm, "Wait for a while, then try again.\n");
    close(s);
    return 4;
  }
  if (mask != (mode_t)-1)
    umask(mask);
  if (listen(s, 5) != 0) {
    LogPrintf(LogERROR, "Local: Unable to listen to socket - OS overload?\n");
    close(s);
    ID0unlink(name);
    return 5;
  }
  ServerClose();
  server = s;
  rm = ifsun.sun_path;
  LogPrintf(LogPHASE, "Listening at local socket %s.\n", name);
  return 0;
}

int
ServerTcpOpen(int port)
{
  struct sockaddr_in ifsin;
  int s;

  if (VarLocalAuth == LOCAL_DENY) {
    LogPrintf(LogWARN, "Tcp: Can't open socket %d: No password "
	      "in ppp.secret\n", port);
    return 6;
  }

  if (mode & MODE_INTER) {
    LogPrintf(LogWARN, "Tcp: Can't open socket in interactive mode\n");
    return 6;
  }

  s = ID0socket(PF_INET, SOCK_STREAM, 0);
  if (s < 0) {
    LogPrintf(LogERROR, "Tcp: socket: %s\n", strerror(errno));
    return 7;
  }
  memset(&ifsin, '\0', sizeof ifsin);
  ifsin.sin_family = AF_INET;
  ifsin.sin_addr.s_addr = INADDR_ANY;
  ifsin.sin_port = htons(port);
  setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &s, sizeof s);
  if (bind(s, (struct sockaddr *)&ifsin, sizeof ifsin) < 0) {
    LogPrintf(LogERROR, "Tcp: bind: %s\n", strerror(errno));
    if (errno == EADDRINUSE && VarTerm)
      fprintf(VarTerm, "Wait for a while, then try again.\n");
    close(s);
    return 8;
  }
  if (listen(s, 5) != 0) {
    LogPrintf(LogERROR, "Tcp: Unable to listen to socket - OS overload?\n");
    close(s);
    return 9;
  }
  ServerClose();
  server = s;
  LogPrintf(LogPHASE, "Listening at port %d.\n", port);
  return 0;
}

void
ServerClose()
{
  if (server >= 0) {
    close(server);
    if (rm) {
      ID0unlink(rm);
      rm = 0;
    }
  }
  server = -1;
}
@


1.7
log
@LogWARN rather than LogERROR when we can't create
our diagnostic socket.
@
text
@d26 1
a26 1
 *	$Id: server.c,v 1.6 1998/01/21 02:13:40 brian Exp $
@


1.6
log
@Remove unused #includes.
Make various bits static.
Remove unused variables.
Submitted by: eivind
@
text
@d26 1
a26 1
 *	$Id: server.c,v 1.5 1997/12/24 09:30:49 brian Exp $
d62 1
a62 1
    LogPrintf(LogERROR, "Local: Can't open socket %s: No password "
d68 1
a68 1
    LogPrintf(LogERROR, "Local: Can't open socket in interactive mode\n");
d120 1
a120 1
    LogPrintf(LogERROR, "Tcp: Can't open socket %d: No password "
d126 1
a126 1
    LogPrintf(LogERROR, "Tcp: Can't open socket in interactive mode\n");
@


1.5
log
@Cosmetic (style):
  sizeof(var) -> sizeof var
  sizeof type -> sizeof(type)

Suggested by: J Wunsch <j@@uriah.heep.sax.de>
@
text
@d26 1
a26 1
 *	$Id: server.c,v 1.4 1997/12/21 14:27:12 brian Exp $
a33 1
#include <netinet/ip.h>
@


1.4
log
@Add (BSD) copyright headers
@
text
@d26 1
a26 1
 *	$Id$
d90 1
a90 1
  if (bind(s, (struct sockaddr *) & ifsun, sizeof(ifsun)) < 0) {
d141 1
a141 1
  if (bind(s, (struct sockaddr *) & ifsin, sizeof(ifsin)) < 0) {
@


1.3
log
@Zero struct sockaddr_??s before filling them in.
Suggested by: Theo de Raadt <deraadt@@cvs.openbsd.org>
@
text
@d1 26
a26 2
/*
 * $Id: server.c,v 1.2 1997/12/06 12:09:04 brian Exp $
@


1.2
log
@Add DEFLATE capabilities (rfc1979).
@
text
@d2 1
a2 1
 * $Id: server.c,v 1.1.1.1 1997/11/23 20:27:36 brian Exp $
d49 1
d112 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id: server.c,v 1.11 1997/11/22 03:37:45 brian Exp $
a71 1
    ID0unlink(name);
@


1.1.1.1
log
@Import version 1.5 of ppp.

<sales>
This is a user-level ppp implementation that uses the
tun driver.  It was originally created by a Japanese
ISP.  It's now piled with features.  Check the man pages
for details.
</sales>

The sources are identical to the ones in FreeBSD, except
for the Makefile.

IP aliasing (NAT) is disabled, and can be enabled by simply
doing a ``make install'' of libalias, then rebuilding
ppp.  I'll create libalias as a port soon.
@
text
@@
