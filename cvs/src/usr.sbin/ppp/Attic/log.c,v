head	1.6;
access;
symbols
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	PPP1_5:1.1.1.1
	BRIAN:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	98.08.31.00.21.04;	author brian;	state dead;
branches;
next	1.5;

1.5
date	98.03.13.01.50.42;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	98.01.21.02.13.35;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	97.12.24.09.30.40;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	97.12.21.14.27.09;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	97.11.23.20.27.34;	author brian;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.11.23.20.27.34;	author brian;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@/*-
 * Copyright (c) 1997 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$Id: log.c,v 1.5 1998/03/13 01:50:42 brian Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>

#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "loadalias.h"
#include "defs.h"
#include "vars.h"

static const char *LogNames[] = {
  "Async",
  "Carrier",
  "CCP",
  "Chat",
  "Command",
  "Connect",
  "Debug",
  "HDLC",
  "ID0",
  "IPCP",
  "LCP",
  "Link",
  "LQM",
  "Phase",
  "TCP/IP",
  "Tun",
  "Warning",
  "Error",
  "Alert"
};

#define MSK(n) (1<<((n)-1))

static u_long LogMask = MSK(LogLINK) | MSK(LogCARRIER) | MSK(LogPHASE);
static u_long LogMaskLocal = MSK(LogERROR) | MSK(LogALERT) | MSK(LogWARN);
static int LogTunno = -1;

static int
syslogLevel(int lev)
{
  switch (lev) {
    case LogDEBUG:return LOG_DEBUG;
  case LogWARN:
    return LOG_WARNING;
  case LogERROR:
    return LOG_ERR;
  case LogALERT:
    return LOG_ALERT;
  }
  return lev >= LogMIN && lev <= LogMAX ? LOG_INFO : 0;
}

const char *
LogName(int id)
{
  return id < LogMIN || id > LogMAX ? "Unknown" : LogNames[id - 1];
}

void
LogKeep(int id)
{
  if (id >= LogMIN && id <= LogMAXCONF)
    LogMask |= MSK(id);
}

void
LogKeepLocal(int id)
{
  if (id >= LogMIN && id <= LogMAXCONF)
    LogMaskLocal |= MSK(id);
}

void
LogDiscard(int id)
{
  if (id >= LogMIN && id <= LogMAXCONF)
    LogMask &= ~MSK(id);
}

void
LogDiscardLocal(int id)
{
  if (id >= LogMIN && id <= LogMAXCONF)
    LogMaskLocal &= ~MSK(id);
}

void
LogDiscardAll()
{
  LogMask = 0;
}

void
LogDiscardAllLocal()
{
  LogMaskLocal = 0;
}

int
LogIsKept(int id)
{
  if (id < LogMIN || id > LogMAX)
    return 0;
  if (id > LogMAXCONF)
    return LOG_KEPT_LOCAL | LOG_KEPT_SYSLOG;

  return ((LogMaskLocal & MSK(id)) ? LOG_KEPT_LOCAL : 0) |
    ((LogMask & MSK(id)) ? LOG_KEPT_SYSLOG : 0);
}

void
LogOpen(const char *Name)
{
  openlog(Name, LOG_PID, LOG_DAEMON);
}

void
LogSetTun(int tunno)
{
  LogTunno = tunno;
}

void
LogClose()
{
  closelog();
  LogTunno = -1;
}

void
LogPrintf(int lev, const char *fmt,...)
{
  va_list ap;

  va_start(ap, fmt);
  if (LogIsKept(lev)) {
    static char nfmt[200];

    if ((LogIsKept(lev) & LOG_KEPT_LOCAL) && VarTerm) {
      if ((LogIsKept(LogTUN) & LOG_KEPT_LOCAL) && LogTunno != -1)
        snprintf(nfmt, sizeof nfmt, "tun%d: %s: %s",
	         LogTunno, LogName(lev), fmt);
      else
        snprintf(nfmt, sizeof nfmt, "%s: %s", LogName(lev), fmt);
      vfprintf(VarTerm, nfmt, ap);
      fflush(VarTerm);
    }

    if ((LogIsKept(lev) & LOG_KEPT_SYSLOG) && (lev != LogWARN || !VarTerm)) {
      if ((LogIsKept(LogTUN) & LOG_KEPT_SYSLOG) && LogTunno != -1)
        snprintf(nfmt, sizeof nfmt, "tun%d: %s: %s",
	         LogTunno, LogName(lev), fmt);
      else
        snprintf(nfmt, sizeof nfmt, "%s: %s", LogName(lev), fmt);
      vsyslog(syslogLevel(lev), nfmt, ap);
    }
  }
  va_end(ap);
}

void
LogDumpBp(int lev, const char *hdr, const struct mbuf * bp)
{
  if (LogIsKept(lev)) {
    char buf[50];
    char *b;
    u_char *ptr;
    int f;

    if (hdr && *hdr)
      LogPrintf(lev, "%s\n", hdr);

    b = buf;
    do {
      f = bp->cnt;
      ptr = MBUF_CTOP(bp);
      while (f--) {
	sprintf(b, " %02x", (int) *ptr++);
        b += 3;
        if (b == buf + sizeof buf - 2) {
          strcpy(b, "\n");
          LogPrintf(lev, buf);
          b = buf;
        }
      }
    } while ((bp = bp->next) != NULL);

    if (b > buf) {
      strcpy(b, "\n");
      LogPrintf(lev, buf);
    }
  }
}

void
LogDumpBuff(int lev, const char *hdr, const u_char * ptr, int n)
{
  if (LogIsKept(lev)) {
    char buf[50];
    char *b;

    if (hdr && *hdr)
      LogPrintf(lev, "%s\n", hdr);
    while (n > 0) {
      b = buf;
      for (b = buf; b != buf + sizeof buf - 2 && n--; b += 3)
	sprintf(b, " %02x", (int) *ptr++);
      strcpy(b, "\n");
      LogPrintf(lev, buf);
    }
  }
}
@


1.5
log
@Add missing include
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.4 1998/01/21 02:13:35 brian Exp $
@


1.4
log
@Remove unused #includes.
Make various bits static.
Remove unused variables.
Submitted by: eivind
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.3 1997/12/24 09:30:40 brian Exp $
d34 1
@


1.3
log
@Cosmetic (style):
  sizeof(var) -> sizeof var
  sizeof type -> sizeof(type)

Suggested by: J Wunsch <j@@uriah.heep.sax.de>
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.2 1997/12/21 14:27:09 brian Exp $
a30 1
#include <sys/socket.h>
@


1.2
log
@Add (BSD) copyright headers
@
text
@d26 1
a26 1
 *	$Id$
d240 1
a240 1
      for (b = buf; b != buf + sizeof(buf) - 2 && n--; b += 3)
@


1.1
log
@Initial revision
@
text
@d1 26
a26 2
/*
 * $Id: log.c,v 1.22 1997/11/22 03:37:36 brian Exp $
@


1.1.1.1
log
@Import version 1.5 of ppp.

<sales>
This is a user-level ppp implementation that uses the
tun driver.  It was originally created by a Japanese
ISP.  It's now piled with features.  Check the man pages
for details.
</sales>

The sources are identical to the ones in FreeBSD, except
for the Makefile.

IP aliasing (NAT) is disabled, and can be enabled by simply
doing a ``make install'' of libalias, then rebuilding
ppp.  I'll create libalias as a port soon.
@
text
@@

