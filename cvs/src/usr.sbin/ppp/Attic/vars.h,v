head	1.8;
access;
symbols
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	PPP1_5:1.1.1.1
	BRIAN:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	98.08.31.00.21.55;	author brian;	state dead;
branches;
next	1.7;

1.7
date	98.01.21.02.13.44;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	98.01.20.22.46.32;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	98.01.11.17.54.48;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	97.12.29.22.23.09;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	97.12.21.03.15.58;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	97.12.06.12.09.05;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	97.11.23.20.27.37;	author brian;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.11.23.20.27.37;	author brian;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@/*
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
 *
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $Id: vars.h,v 1.7 1998/01/21 02:13:44 brian Exp $
 *
 *	TODO:
 */

struct confdesc {
  const char *name;
  int myside, hisside;
};

#define	CONF_NONE	-1
#define	CONF_DISABLE	0
#define	CONF_ENABLE	1

#define	CONF_DENY	0
#define	CONF_ACCEPT	1

#define	ConfAcfcomp	0
#define	ConfChap	1
#define	ConfDeflate	2
#define	ConfLqr		3
#define	ConfPap		4
#define	ConfPppdDeflate	5
#define	ConfPred1	6
#define	ConfProtocomp	7
#define	ConfVjcomp	8

#define ConfMSExt	9
#define ConfPasswdAuth	10
#define	ConfProxy	11
#define ConfThroughput	12
#define ConfUtmp	13
#define	MAXCONFS	14

#define	Enabled(x)	(pppConfs[x].myside & CONF_ENABLE)
#define	Acceptable(x)	(pppConfs[x].hisside & CONF_ACCEPT)

extern struct confdesc pppConfs[MAXCONFS + 1];

struct pppvars {
  u_short var_mru;		/* Initial MRU value */
  u_short pref_mtu;		/* Preferred MTU value */
  int var_accmap;		/* Initial ACCMAP value */
  int modem_speed;		/* Current modem speed */
  int modem_parity;		/* Parity setting */
  int modem_ctsrts;		/* Use CTS/RTS on modem port? (boolean) */
  int idle_timeout;		/* Idle timeout value */
  int lqr_timeout;		/* LQR timeout value */
  int retry_timeout;		/* Retry timeout value */
  int reconnect_timer;		/* Timeout before reconnect on carrier loss */
  int reconnect_tries;		/* Attempt reconnect on carrier loss */
  int redial_timeout;		/* Redial timeout value */
  int redial_next_timeout;	/* Redial next timeout value */
  int dial_tries;		/* Dial attempts before giving up, 0 == inf */
  int loopback;			/* Turn around packets addressed to me */
  char modem_devlist[LINE_LEN];	/* Comma-separated list of devices */
  char modem_dev[40];		/* Name of device / host:port */
  const char *base_modem_dev;	/* Pointer to base of modem_dev */
  int open_mode;		/* Delay before first LCP REQ (-1 = passive) */
#define LOCAL_AUTH	0x01
#define LOCAL_NO_AUTH	0x02
#define LOCAL_DENY	0x03
  u_char lauth;			/* Local Authorized status */
  FILE *termfp;			/* The terminal */
#define DIALUP_REQ	0x01
#define DIALUP_DONE	0x02
  char dial_script[SCRIPT_LEN];	/* Dial script */
  char login_script[SCRIPT_LEN]; /* Login script */
  char auth_key[50];		/* PAP/CHAP key */
  char auth_name[50];		/* PAP/CHAP system name */
  char local_auth_key[50];		/* Local auth passwd */
  int have_local_auth_key;		/* Local auth passwd specified ? */
#ifdef HAVE_DES
  int use_MSChap;		/* Use MSCHAP encryption */
#endif
  char phone_numbers[200];	/* Telephone Numbers */
  char phone_copy[200];		/* copy for strsep() */
  char *next_phone;		/* Next phone from the list */
  char *alt_phone;		/* Next phone from the list */
  char shostname[MAXHOSTNAMELEN]; /* Local short Host Name */
  char hangup_script[SCRIPT_LEN]; /* Hangup script before modem is closed */
  struct aliasHandlers handler;	/* Alias function pointers */
};

#define VarAccmap		pppVars.var_accmap
#define VarMRU			pppVars.var_mru
#define VarPrefMTU		pppVars.pref_mtu
#define	VarDevice		pppVars.modem_dev
#define	VarDeviceList		pppVars.modem_devlist
#define	VarBaseDevice		pppVars.base_modem_dev
#define	VarSpeed		pppVars.modem_speed
#define	VarParity		pppVars.modem_parity
#define	VarCtsRts		pppVars.modem_ctsrts
#define	VarOpenMode		pppVars.open_mode
#define	VarLocalAuth		pppVars.lauth
#define	VarDialScript		pppVars.dial_script
#define VarHangupScript 	pppVars.hangup_script
#define	VarLoginScript		pppVars.login_script
#define VarIdleTimeout  	pppVars.idle_timeout
#define	VarLqrTimeout		pppVars.lqr_timeout
#define	VarRetryTimeout		pppVars.retry_timeout
#define	VarAuthKey		pppVars.auth_key
#define	VarAuthName		pppVars.auth_name
#define	VarLocalAuthKey		pppVars.local_auth_key
#define	VarHaveLocalAuthKey	pppVars.have_local_auth_key
#ifdef HAVE_DES
#define	VarMSChap		pppVars.use_MSChap
#endif
#define VarPhoneList    	pppVars.phone_numbers
#define VarPhoneCopy    	pppVars.phone_copy
#define VarNextPhone    	pppVars.next_phone
#define VarAltPhone     	pppVars.alt_phone
#define	VarShortHost		pppVars.shostname
#define VarReconnectTimer	pppVars.reconnect_timer
#define VarReconnectTries	pppVars.reconnect_tries
#define VarRedialTimeout	pppVars.redial_timeout
#define VarRedialNextTimeout	pppVars.redial_next_timeout
#define VarDialTries		pppVars.dial_tries
#define VarLoopback		pppVars.loopback
#define VarTerm			pppVars.termfp

#define VarAliasHandlers	   pppVars.handler
#define VarPacketAliasGetFragment  (*pppVars.handler.PacketAliasGetFragment)
#define VarPacketAliasGetFragment  (*pppVars.handler.PacketAliasGetFragment)
#define VarPacketAliasInit	   (*pppVars.handler.PacketAliasInit)
#define VarPacketAliasIn	   (*pppVars.handler.PacketAliasIn)
#define VarPacketAliasOut	   (*pppVars.handler.PacketAliasOut)
#define VarPacketAliasRedirectAddr (*pppVars.handler.PacketAliasRedirectAddr)
#define VarPacketAliasRedirectPort (*pppVars.handler.PacketAliasRedirectPort)
#define VarPacketAliasSaveFragment (*pppVars.handler.PacketAliasSaveFragment)
#define VarPacketAliasSetAddress   (*pppVars.handler.PacketAliasSetAddress)
#define VarPacketAliasSetMode	   (*pppVars.handler.PacketAliasSetMode)
#define VarPacketAliasFragmentIn   (*pppVars.handler.PacketAliasFragmentIn)

#define	DEV_IS_SYNC (VarSpeed == 0)

extern struct pppvars pppVars;
extern char VarVersion[];
extern char VarLocalVersion[];

extern int Utmp;		/* Are we in /etc/utmp ? */
extern int ipKeepAlive;
extern int reconnectState;
extern int reconnectCount;

#define RECON_TRUE (1)
#define RECON_FALSE (2)
#define RECON_UNKNOWN (3)
#define RECON_ENVOKED (4)
#define reconnect(x)                          \
  do                                          \
    if (reconnectState == RECON_UNKNOWN) {    \
      reconnectState = x;                     \
      if (x == RECON_FALSE)                   \
        reconnectCount = 0;                   \
    }                                         \
  while(0)


/*
 * This is the logic behind the reconnect variables:
 * We have four reconnect "states".  We start off not requiring anything
 * from the reconnect code (reconnectState == RECON_UNKNOWN).  If the
 * line is brought down (via LcpClose() or LcpDown()), we have to decide
 * whether to set to RECON_TRUE or RECON_FALSE.  It's only here that we
 * know the correct action.  Once we've decided, we don't want that
 * decision to be overridden (hence the above reconnect() macro) - If we
 * call LcpClose, the ModemTimeout() still gets to "notice" that the line
 * is down.  When it "notice"s, it should only set RECON_TRUE if a decision
 * hasn't already been made.
 *
 * In main.c, when we notice we have RECON_TRUE, we must only action
 * it once.  The fourth "state" is where we're bringing the line up,
 * but if we call LcpClose for any reason (failed PAP/CHAP etc) we
 * don't want to set to RECON_{TRUE,FALSE}.
 *
 * If we get a connection or give up dialing, we go back to RECON_UNKNOWN.
 * If we get give up dialing or reconnecting or if we chose to down the
 * connection, we set reconnectCount back to zero.
 *
 */

extern int EnableCommand(struct cmdargs const *);
extern int DisableCommand(struct cmdargs const *);
extern int AcceptCommand(struct cmdargs const *);
extern int DenyCommand(struct cmdargs const *);
extern int LocalAuthCommand(struct cmdargs const *);
extern int DisplayCommand(struct cmdargs const *);
@


1.7
log
@Remove unused #includes.
Make various bits static.
Remove unused variables.
Submitted by: eivind
@
text
@d18 1
a18 1
 * $Id: vars.h,v 1.6 1998/01/20 22:46:32 brian Exp $
@


1.6
log
@Allow an optional delay when specifying "set openmode active".
The delay defaults to 1 sec (as it always has) unless we've done
a ~p in interactive mode or we've actually detected a HDLC frame.
This is now cleanly implemented (via async timers) so that it is
possible for LCP to come up despite the delay if an LCP REQ is
received.

This will hopefully solve situations with slow servers or slirp
scenarios (where ECHO is left on the port for a second or so before
the peer enters packet mode).

Also, ~p in interactive mode no longer changes the value of the default
openmode delay and -dedicated mode enters packet mode in the right state
according to the value of openmode.
@
text
@d18 1
a18 1
 * $Id: vars.h,v 1.5 1998/01/11 17:54:48 brian Exp $
a158 2
extern int ipInOctets;
extern int ipOutOctets;
a159 1
extern int ipConnectSecs;
@


1.5
log
@Make things work when sizeof(long) != 32 (hopefully)
@
text
@d18 1
a18 1
 * $Id: vars.h,v 1.4 1997/12/29 22:23:09 brian Exp $
d76 1
a76 1
  int open_mode;		/* LCP open mode */
@


1.4
log
@Show how much time is left before timing out in the
`show timeout' output.
Remove ipIdleSecs variable - it's not used.
@
text
@d18 1
a18 1
 * $Id: vars.h,v 1.3 1997/12/21 03:15:58 brian Exp $
d58 2
a59 2
  u_long var_mru;		/* Initial MRU value */
  u_long pref_mtu;		/* Preferred MTU value */
@


1.3
log
@Allow multiple (comma seperated) devices on the "set device" line.
Submitted by: Derek Inksetter <derek@@saidev.com>
@
text
@d18 1
a18 1
 * $Id: vars.h,v 1.2 1997/12/06 12:09:05 brian Exp $
a162 1
extern int ipIdleSecs;
d172 2
a173 2
    if (reconnectState == RECON_UNKNOWN) { \
      reconnectState = x;                  \
@


1.2
log
@Add DEFLATE capabilities (rfc1979).
@
text
@d18 1
a18 1
 * $Id: vars.h,v 1.1.1.1 1997/11/23 20:27:37 brian Exp $
d73 1
d106 1
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
 * $Id: vars.h,v 1.35 1997/11/22 03:37:54 brian Exp $
d35 6
a40 6
#define	ConfVjcomp	0
#define	ConfLqr		1
#define	ConfChap	2
#define	ConfPap		3
#define	ConfAcfcomp	4
#define	ConfProtocomp	5
d42 9
a50 6
#define	ConfProxy	7
#define ConfMSExt	8
#define ConfPasswdAuth	9
#define ConfUtmp	10
#define ConfThroughput	11
#define	MAXCONFS	12
@


1.1.1.1
log
@Import version 1.5 of ppp.

<sales>
This is a user-level ppp implementation that uses the
tun driver.  It was originally created by a Japanese
ISP.  It's now piled with features.  Check the man pages
for details.
</sales>

The sources are identical to the ones in FreeBSD, except
for the Makefile.

IP aliasing (NAT) is disabled, and can be enabled by simply
doing a ``make install'' of libalias, then rebuilding
ppp.  I'll create libalias as a port soon.
@
text
@@
