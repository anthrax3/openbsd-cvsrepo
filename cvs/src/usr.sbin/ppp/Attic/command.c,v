head	1.32;
access;
symbols
	OPENBSD_2_3:1.28.0.2
	OPENBSD_2_3_BASE:1.28
	PPP1_5:1.1.1.1
	BRIAN:1.1.1;
locks; strict;
comment	@ * @;


1.32
date	98.08.31.00.20.32;	author brian;	state dead;
branches;
next	1.31;

1.31
date	98.06.28.09.41.37;	author brian;	state Exp;
branches;
next	1.30;

1.30
date	98.06.07.17.10.33;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	98.04.25.09.23.13;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	98.03.13.01.25.54;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	98.03.12.02.40.40;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	98.01.29.00.34.31;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	98.01.23.04.34.26;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	98.01.20.22.46.23;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	98.01.18.20.47.19;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	98.01.11.17.54.46;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	98.01.10.21.50.56;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	98.01.05.01.39.04;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	97.12.30.23.22.35;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	97.12.30.20.03.03;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	97.12.30.02.45.05;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	97.12.29.22.23.04;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	97.12.27.13.45.18;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	97.12.27.07.22.16;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	97.12.24.09.30.27;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	97.12.23.22.38.01;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	97.12.21.03.15.53;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	97.12.19.18.12.08;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	97.12.18.01.10.25;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	97.12.18.00.28.48;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	97.12.17.21.17.44;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	97.12.17.00.20.36;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	97.12.15.22.50.20;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	97.12.15.22.44.50;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	97.12.08.20.09.06;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	97.12.07.04.09.07;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	97.11.23.20.27.33;	author brian;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.11.23.20.27.33;	author brian;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@/*
 *		PPP User command processing module
 *
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
 *
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $Id: command.c,v 1.31 1998/06/28 09:41:37 brian Exp $
 *
 */
#include <sys/param.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <net/route.h>
#include <netdb.h>

#ifndef NOALIAS
#include <alias.h>
#endif
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "defs.h"
#include "timer.h"
#include "fsm.h"
#include "phase.h"
#include "lcp.h"
#include "iplist.h"
#include "ipcp.h"
#include "modem.h"
#include "filter.h"
#ifndef NOALIAS
#include "alias_cmd.h"
#endif
#include "hdlc.h"
#include "loadalias.h"
#include "vars.h"
#include "systems.h"
#include "chat.h"
#include "os.h"
#include "server.h"
#include "main.h"
#include "route.h"
#include "ccp.h"
#include "ip.h"
#include "slcompress.h"
#include "auth.h"

struct in_addr ifnetmask;
static const char *HIDDEN = "********";

static int ShowCommand(struct cmdargs const *arg);
static int TerminalCommand(struct cmdargs const *arg);
static int QuitCommand(struct cmdargs const *arg);
static int CloseCommand(struct cmdargs const *arg);
static int DialCommand(struct cmdargs const *arg);
static int DownCommand(struct cmdargs const *arg);
static int AllowCommand(struct cmdargs const *arg);
static int SetCommand(struct cmdargs const *arg);
static int AddCommand(struct cmdargs const *arg);
static int DeleteCommand(struct cmdargs const *arg);
static int BgShellCommand(struct cmdargs const *arg);
static int FgShellCommand(struct cmdargs const *arg);
#ifndef NOALIAS
static int AliasCommand(struct cmdargs const *arg);
static int AliasEnable(struct cmdargs const *arg);
static int AliasOption(struct cmdargs const *arg);
#endif

static int
HelpCommand(struct cmdargs const *arg)
{
  struct cmdtab const *cmd;
  int n, cmax, dmax, cols;

  if (!VarTerm)
    return 0;

  if (arg->argc > 0) {
    for (cmd = arg->cmd; cmd->name; cmd++)
      if (strcasecmp(cmd->name, *arg->argv) == 0 &&
          (cmd->lauth & VarLocalAuth)) {
	fprintf(VarTerm, "%s\n", cmd->syntax);
	return 0;
      }
    return -1;
  }
  cmax = dmax = 0;
  for (cmd = arg->cmd; cmd->func; cmd++)
    if (cmd->name && (cmd->lauth & VarLocalAuth)) {
      if ((n = strlen(cmd->name)) > cmax)
        cmax = n;
      if ((n = strlen(cmd->helpmes)) > dmax)
        dmax = n;
    }

  cols = 80 / (dmax + cmax + 3);
  n = 0;
  for (cmd = arg->cmd; cmd->func; cmd++)
    if (cmd->name && (cmd->lauth & VarLocalAuth)) {
      fprintf(VarTerm, " %-*.*s: %-*.*s",
              cmax, cmax, cmd->name, dmax, dmax, cmd->helpmes);
      if (++n % cols == 0)
        fprintf(VarTerm, "\n");
    }
  if (n % cols != 0)
    fprintf(VarTerm, "\n");

  return 0;
}

int
IsInteractive(int Display)
{
  const char *m = NULL;

  if (mode & MODE_DDIAL)
    m = "direct dial";
  else if (mode & MODE_BACKGROUND)
    m = "background";
  else if (mode & MODE_AUTO)
    m = "auto";
  else if (mode & MODE_DIRECT)
    m = "direct";
  else if (mode & MODE_DEDICATED)
    m = "dedicated";
  else if (mode & MODE_INTER)
    m = "interactive";
  if (m) {
    if (Display && VarTerm)
      fprintf(VarTerm, "Working in %s mode\n", m);
  }
  return mode & MODE_INTER;
}

static int
DialCommand(struct cmdargs const *arg)
{
  int tries;
  int res;

  if (LcpFsm.state > ST_CLOSED) {
    if (VarTerm)
      fprintf(VarTerm, "LCP state is [%s]\n", StateNames[LcpFsm.state]);
    return 0;
  }

  if ((mode & MODE_DAEMON) && !(mode & MODE_AUTO)) {
    LogPrintf(LogWARN,
              "Manual dial is only available in auto and interactive mode\n");
    return 1;
  }

  if (arg->argc > 0 && (res = LoadCommand(arg)) != 0)
    return res;

  tries = 0;
  do {
    if (tries) {
      LogPrintf(LogPHASE, "Enter pause (%d) for redialing.\n",
                VarRedialNextTimeout);
      nointr_sleep(VarRedialNextTimeout);
    }
    if (VarTerm)
      fprintf(VarTerm, "Dial attempt %u of %d\n", ++tries, VarDialTries);
    if (OpenModem() < 0) {
      if (VarTerm)
	fprintf(VarTerm, "Failed to open modem.\n");
      break;
    }
    if ((res = DialModem()) == EX_DONE) {
      ModemTimeout(NULL);
      PacketMode(VarOpenMode);
      break;
    } else if (res == EX_SIG)
      return 1;
  } while (VarDialTries == 0 || tries < VarDialTries);

  return 0;
}

static int
SetLoopback(struct cmdargs const *arg)
{
  if (arg->argc == 1) {
    if (!strcasecmp(*arg->argv, "on")) {
      VarLoopback = 1;
      return 0;
    } else if (!strcasecmp(*arg->argv, "off")) {
      VarLoopback = 0;
      return 0;
    }
  }
  return -1;
}

static int
ShellCommand(struct cmdargs const *arg, int bg)
{
  const char *shell;
  pid_t shpid;
  int argc;
  char *argv[MAXARGS];

#ifdef SHELL_ONLY_INTERACTIVELY
  /* we're only allowed to shell when we run ppp interactively */
  if (mode != MODE_INTER) {
    LogPrintf(LogWARN, "Can only start a shell in interactive mode\n");
    return 1;
  }
#endif
#ifdef NO_SHELL_IN_AUTO_INTERACTIVE

  /*
   * we want to stop shell commands when we've got a telnet connection to an
   * auto mode ppp
   */
  if (VarTerm && !(mode & MODE_INTER)) {
    LogPrintf(LogWARN, "Shell is not allowed interactively in auto mode\n");
    return 1;
  }
#endif

  if (arg->argc == 0) {
    if (!(mode & MODE_INTER)) {
      if (VarTerm)
        LogPrintf(LogWARN, "Can't start an interactive shell from"
		  " a telnet session\n");
      else
        LogPrintf(LogWARN, "Can only start an interactive shell in"
		  " interactive mode\n");
      return 1;
    } else if (bg) {
      LogPrintf(LogWARN, "Can only start an interactive shell in"
		" the foreground mode\n");
      return 1;
    }
  }

  if ((shell = getenv("SHELL")) == 0)
    shell = _PATH_BSHELL;

  if ((shpid = fork()) == 0) {
    int dtablesize, i, fd;

    TermTimerService();
    signal(SIGINT, SIG_DFL);
    signal(SIGQUIT, SIG_DFL);
    signal(SIGTERM, SIG_DFL);
    signal(SIGHUP, SIG_DFL);
    signal(SIGALRM, SIG_DFL);

    if (VarTerm)
      fd = fileno(VarTerm);
    else if ((fd = open("/dev/null", O_RDWR)) == -1) {
      LogPrintf(LogALERT, "Failed to open /dev/null: %s\n", strerror(errno));
      exit(1);
    }
    for (i = 0; i < 3; i++)
      dup2(fd, i);

    for (dtablesize = getdtablesize(), i = 3; i < dtablesize; i++)
      close(i);

    TtyOldMode();
    setuid(geteuid());
    if (arg->argc > 0) {
      /* substitute pseudo args */
      argv[0] = strdup(arg->argv[0]);
      for (argc = 1; argc < arg->argc; argc++) {
	if (strcasecmp(arg->argv[argc], "HISADDR") == 0)
	  argv[argc] = strdup(inet_ntoa(IpcpInfo.his_ipaddr));
	else if (strcasecmp(arg->argv[argc], "INTERFACE") == 0)
	  argv[argc] = strdup(IfDevName);
	else if (strcasecmp(arg->argv[argc], "MYADDR") == 0)
	  argv[argc] = strdup(inet_ntoa(IpcpInfo.want_ipaddr));
        else
          argv[argc] = strdup(arg->argv[argc]);
      }
      argv[argc] = NULL;
      if (bg) {
	pid_t p;

	p = getpid();
	if (daemon(1, 1) == -1) {
	  LogPrintf(LogERROR, "%d: daemon: %s\n", p, strerror(errno));
	  exit(1);
	}
      } else if (VarTerm)
        printf("ppp: Pausing until %s finishes\n", arg->argv[0]);
      execvp(argv[0], argv);
    } else {
      if (VarTerm)
        printf("ppp: Pausing until %s finishes\n", shell);
      execl(shell, shell, NULL);
    }

    LogPrintf(LogWARN, "exec() of %s failed\n",
              arg->argc > 0 ? arg->argv[0] : shell);
    exit(255);
  }
  if (shpid == (pid_t) - 1) {
    LogPrintf(LogERROR, "Fork failed: %s\n", strerror(errno));
  } else {
    int status;

    waitpid(shpid, &status, 0);
  }

  TtyCommandMode(0);

  return (0);
}

static int
BgShellCommand(struct cmdargs const *arg)
{
  if (arg->argc == 0)
    return -1;
  return ShellCommand(arg, 1);
}

static int
FgShellCommand(struct cmdargs const *arg)
{
  return ShellCommand(arg, 0);
}

static struct cmdtab const Commands[] = {
  {"accept", NULL, AcceptCommand, LOCAL_AUTH,
  "accept option request", "accept option .."},
  {"add", NULL, AddCommand, LOCAL_AUTH,
  "add route", "add dest mask gateway", NULL},
  {"add!", NULL, AddCommand, LOCAL_AUTH,
  "add or change route", "add! dest mask gateway", (void *)1},
  {"allow", "auth", AllowCommand, LOCAL_AUTH,
  "Allow ppp access", "allow users|modes ...."},
  {"bg", "!bg", BgShellCommand, LOCAL_AUTH,
  "Run a background command", "[!]bg command"},
  {"close", NULL, CloseCommand, LOCAL_AUTH,
  "Close connection", "close"},
  {"delete", NULL, DeleteCommand, LOCAL_AUTH,
  "delete route", "delete dest", NULL},
  {"delete!", NULL, DeleteCommand, LOCAL_AUTH,
  "delete a route if it exists", "delete! dest", (void *)1},
  {"deny", NULL, DenyCommand, LOCAL_AUTH,
  "Deny option request", "deny option .."},
  {"dial", "call", DialCommand, LOCAL_AUTH,
  "Dial and login", "dial|call [remote]"},
  {"disable", NULL, DisableCommand, LOCAL_AUTH,
  "Disable option", "disable option .."},
  {"display", NULL, DisplayCommand, LOCAL_AUTH,
  "Display option configs", "display"},
  {"enable", NULL, EnableCommand, LOCAL_AUTH,
  "Enable option", "enable option .."},
  {"passwd", NULL, LocalAuthCommand, LOCAL_NO_AUTH,
  "Password for manipulation", "passwd LocalPassword"},
  {"load", NULL, LoadCommand, LOCAL_AUTH,
  "Load settings", "load [remote]"},
  {"save", NULL, SaveCommand, LOCAL_AUTH,
  "Save settings", "save"},
  {"set", "setup", SetCommand, LOCAL_AUTH,
  "Set parameters", "set[up] var value"},
  {"shell", "!", FgShellCommand, LOCAL_AUTH,
  "Run a subshell", "shell|! [sh command]"},
  {"show", NULL, ShowCommand, LOCAL_AUTH,
  "Show status and stats", "show var"},
  {"term", NULL, TerminalCommand, LOCAL_AUTH,
  "Enter terminal mode", "term"},
#ifndef NOALIAS
  {"alias", NULL, AliasCommand, LOCAL_AUTH,
  "alias control", "alias option [yes|no]"},
#endif
  {"quit", "bye", QuitCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
  "Quit PPP program", "quit|bye [all]"},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
  "Display this message", "help|? [command]", Commands},
  {NULL, "down", DownCommand, LOCAL_AUTH,
  "Generate down event", "down"},
  {NULL, NULL, NULL},
};

static int
ShowLoopback(struct cmdargs const *arg)
{
  if (VarTerm)
    fprintf(VarTerm, "Local loopback is %s\n", VarLoopback ? "on" : "off");

  return 0;
}

static int
ShowLogLevel(struct cmdargs const *arg)
{
  int i;

  if (!VarTerm)
    return 0;

  fprintf(VarTerm, "Log:  ");
  for (i = LogMIN; i <= LogMAX; i++)
    if (LogIsKept(i) & LOG_KEPT_SYSLOG)
      fprintf(VarTerm, " %s", LogName(i));

  fprintf(VarTerm, "\nLocal:");
  for (i = LogMIN; i <= LogMAX; i++)
    if (LogIsKept(i) & LOG_KEPT_LOCAL)
      fprintf(VarTerm, " %s", LogName(i));

  fprintf(VarTerm, "\n");

  return 0;
}

static int
ShowEscape(struct cmdargs const *arg)
{
  int code, bit;

  if (!VarTerm)
    return 0;
  if (EscMap[32]) {
    for (code = 0; code < 32; code++)
      if (EscMap[code])
	for (bit = 0; bit < 8; bit++)
	  if (EscMap[code] & (1 << bit))
	    fprintf(VarTerm, " 0x%02x", (code << 3) + bit);
    fprintf(VarTerm, "\n");
  }
  return 0;
}

static int
ShowTimeout(struct cmdargs const *arg)
{
  if (VarTerm) {
    int remaining;

    fprintf(VarTerm, " Idle Timer: %d secs   LQR Timer: %d secs"
	    "   Retry Timer: %d secs\n", VarIdleTimeout, VarLqrTimeout,
	    VarRetryTimeout);
    remaining = RemainingIdleTime();
    if (remaining != -1)
    fprintf(VarTerm, " %d secs remaining\n", remaining);
  }
  return 0;
}

static int
ShowStopped(struct cmdargs const *arg)
{
  if (!VarTerm)
    return 0;

  fprintf(VarTerm, " Stopped Timer:  LCP: ");
  if (!LcpFsm.StoppedTimer.load)
    fprintf(VarTerm, "Disabled");
  else
    fprintf(VarTerm, "%ld secs", LcpFsm.StoppedTimer.load / SECTICKS);

  fprintf(VarTerm, ", IPCP: ");
  if (!IpcpFsm.StoppedTimer.load)
    fprintf(VarTerm, "Disabled");
  else
    fprintf(VarTerm, "%ld secs", IpcpFsm.StoppedTimer.load / SECTICKS);

  fprintf(VarTerm, ", CCP: ");
  if (!CcpFsm.StoppedTimer.load)
    fprintf(VarTerm, "Disabled");
  else
    fprintf(VarTerm, "%ld secs", CcpFsm.StoppedTimer.load / SECTICKS);

  fprintf(VarTerm, "\n");

  return 0;
}

static int
ShowAuthKey(struct cmdargs const *arg)
{
  if (!VarTerm)
    return 0;
  fprintf(VarTerm, "AuthName = %s\n", VarAuthName);
  fprintf(VarTerm, "AuthKey  = %s\n", HIDDEN);
#ifdef HAVE_DES
  fprintf(VarTerm, "Encrypt  = %s\n", VarMSChap ? "MSChap" : "MD5" );
#endif
  return 0;
}

static int
ShowVersion(struct cmdargs const *arg)
{
  if (VarTerm)
    fprintf(VarTerm, "%s - %s \n", VarVersion, VarLocalVersion);
  return 0;
}

static int
ShowInitialMRU(struct cmdargs const *arg)
{
  if (VarTerm)
    fprintf(VarTerm, " Initial MRU: %d\n", VarMRU);
  return 0;
}

static int
ShowPreferredMTU(struct cmdargs const *arg)
{
  if (VarTerm) {
    if (VarPrefMTU)
      fprintf(VarTerm, " Preferred MTU: %d\n", VarPrefMTU);
    else
      fprintf(VarTerm, " Preferred MTU: unspecified\n");
  }
  return 0;
}

static int
ShowReconnect(struct cmdargs const *arg)
{
  if (VarTerm)
    fprintf(VarTerm, " Reconnect Timer:  %d,  %d tries\n",
	    VarReconnectTimer, VarReconnectTries);
  return 0;
}

static int
ShowRedial(struct cmdargs const *arg)
{
  if (!VarTerm)
    return 0;
  fprintf(VarTerm, " Redial Timer: ");

  if (VarRedialTimeout >= 0) {
    fprintf(VarTerm, " %d seconds, ", VarRedialTimeout);
  } else {
    fprintf(VarTerm, " Random 0 - %d seconds, ", REDIAL_PERIOD);
  }

  fprintf(VarTerm, " Redial Next Timer: ");

  if (VarRedialNextTimeout >= 0) {
    fprintf(VarTerm, " %d seconds, ", VarRedialNextTimeout);
  } else {
    fprintf(VarTerm, " Random 0 - %d seconds, ", REDIAL_PERIOD);
  }

  if (VarDialTries)
    fprintf(VarTerm, "%d dial tries", VarDialTries);

  fprintf(VarTerm, "\n");

  return 0;
}

#ifndef NOMSEXT
static int
ShowMSExt(struct cmdargs const *arg)
{
  if (VarTerm) {
    fprintf(VarTerm, " MS PPP extention values \n");
    fprintf(VarTerm, "   Primary NS     : %s\n", inet_ntoa(ns_entries[0]));
    fprintf(VarTerm, "   Secondary NS   : %s\n", inet_ntoa(ns_entries[1]));
    fprintf(VarTerm, "   Primary NBNS   : %s\n", inet_ntoa(nbns_entries[0]));
    fprintf(VarTerm, "   Secondary NBNS : %s\n", inet_ntoa(nbns_entries[1]));
  }
  return 0;
}

#endif

static struct cmdtab const ShowCommands[] = {
  {"afilter", NULL, ShowAfilter, LOCAL_AUTH,
  "Show keep-alive filters", "show afilter option .."},
  {"auth", NULL, ShowAuthKey, LOCAL_AUTH,
  "Show auth details", "show auth"},
  {"ccp", NULL, ReportCcpStatus, LOCAL_AUTH,
  "Show CCP status", "show cpp"},
  {"compress", NULL, ReportCompress, LOCAL_AUTH,
  "Show compression stats", "show compress"},
  {"dfilter", NULL, ShowDfilter, LOCAL_AUTH,
  "Show Demand filters", "show dfilteroption .."},
  {"escape", NULL, ShowEscape, LOCAL_AUTH,
  "Show escape characters", "show escape"},
  {"hdlc", NULL, ReportHdlcStatus, LOCAL_AUTH,
  "Show HDLC errors", "show hdlc"},
  {"ifilter", NULL, ShowIfilter, LOCAL_AUTH,
  "Show Input filters", "show ifilter option .."},
  {"ipcp", NULL, ReportIpcpStatus, LOCAL_AUTH,
  "Show IPCP status", "show ipcp"},
  {"lcp", NULL, ReportLcpStatus, LOCAL_AUTH,
  "Show LCP status", "show lcp"},
  {"loopback", NULL, ShowLoopback, LOCAL_AUTH,
  "Show loopback setting", "show loopback"},
  {"log", NULL, ShowLogLevel, LOCAL_AUTH,
  "Show log levels", "show log"},
  {"mem", NULL, ShowMemMap, LOCAL_AUTH,
  "Show memory map", "show mem"},
  {"modem", NULL, ShowModemStatus, LOCAL_AUTH,
  "Show modem setups", "show modem"},
  {"mru", NULL, ShowInitialMRU, LOCAL_AUTH,
  "Show Initial MRU", "show mru"},
#ifndef NOMSEXT
  {"msext", NULL, ShowMSExt, LOCAL_AUTH,
  "Show MS PPP extentions", "show msext"},
#endif
  {"mtu", NULL, ShowPreferredMTU, LOCAL_AUTH,
  "Show Preferred MTU", "show mtu"},
  {"ofilter", NULL, ShowOfilter, LOCAL_AUTH,
  "Show Output filters", "show ofilter option .."},
  {"proto", NULL, ReportProtStatus, LOCAL_AUTH,
  "Show protocol summary", "show proto"},
  {"reconnect", NULL, ShowReconnect, LOCAL_AUTH,
  "Show reconnect timer", "show reconnect"},
  {"redial", NULL, ShowRedial, LOCAL_AUTH,
  "Show Redial timeout", "show redial"},
  {"route", NULL, ShowRoute, LOCAL_AUTH,
  "Show routing table", "show route"},
  {"timeout", NULL, ShowTimeout, LOCAL_AUTH,
  "Show Idle timeout", "show timeout"},
  {"stopped", NULL, ShowStopped, LOCAL_AUTH,
  "Show STOPPED timeout", "show stopped"},
  {"version", NULL, ShowVersion, LOCAL_NO_AUTH | LOCAL_AUTH,
  "Show version string", "show version"},
  {"vj", NULL, ShowInitVJ, LOCAL_AUTH,
  "Show VJ values", "show vj"},
  {"help", "?", HelpCommand, LOCAL_NO_AUTH | LOCAL_AUTH,
  "Display this message", "show help|? [command]", ShowCommands},
  {NULL, NULL, NULL},
};

static struct cmdtab const *
FindCommand(struct cmdtab const *cmds, const char *str, int *pmatch)
{
  int nmatch;
  int len;
  struct cmdtab const *found;

  found = NULL;
  len = strlen(str);
  nmatch = 0;
  while (cmds->func) {
    if (cmds->name && strncasecmp(str, cmds->name, len) == 0) {
      if (cmds->name[len] == '\0') {
	*pmatch = 1;
	return cmds;
      }
      nmatch++;
      found = cmds;
    } else if (cmds->alias && strncasecmp(str, cmds->alias, len) == 0) {
      if (cmds->alias[len] == '\0') {
	*pmatch = 1;
	return cmds;
      }
      nmatch++;
      found = cmds;
    }
    cmds++;
  }
  *pmatch = nmatch;
  return found;
}

static int
FindExec(struct cmdtab const *cmds, int argc, char const *const *argv,
         const char *prefix)
{
  struct cmdtab const *cmd;
  int val = 1;
  int nmatch;
  struct cmdargs arg;

  cmd = FindCommand(cmds, *argv, &nmatch);
  if (nmatch > 1)
    LogPrintf(LogWARN, "%s%s: Ambiguous command\n", prefix, *argv);
  else if (cmd && (cmd->lauth & VarLocalAuth)) {
    arg.cmd = cmds;
    arg.argc = argc-1;
    arg.argv = argv+1;
    arg.data = cmd->args;
    val = (cmd->func) (&arg);
  } else
    LogPrintf(LogWARN, "%s%s: Invalid command\n", prefix, *argv);

  if (val == -1)
    LogPrintf(LogWARN, "Usage: %s\n", cmd->syntax);
  else if (val)
    LogPrintf(LogWARN, "%s%s: Failed %d\n", prefix, *argv, val);

  return val;
}

int aft_cmd = 1;

void
Prompt()
{
  const char *pconnect, *pauth;

  if (!VarTerm || TermMode)
    return;

  if (!aft_cmd)
    fprintf(VarTerm, "\n");
  else
    aft_cmd = 0;

  if (VarLocalAuth == LOCAL_AUTH)
    pauth = " ON ";
  else
    pauth = " on ";
  if (IpcpFsm.state == ST_OPENED && phase == PHASE_NETWORK)
    pconnect = "PPP";
  else
    pconnect = "ppp";
  fprintf(VarTerm, "%s%s%s> ", pconnect, pauth, VarShortHost);
  fflush(VarTerm);
}

void
InterpretCommand(char *buff, int nb, int *argc, char ***argv)
{
  static char *vector[MAXARGS];
  char *cp;

  if (nb > 0) {
    cp = buff + strcspn(buff, "\r\n");
    if (cp)
      *cp = '\0';
    *argc = MakeArgs(buff, vector, VECSIZE(vector));
    *argv = vector;
  } else
    *argc = 0;
}

static int
arghidden(int argc, char const *const *argv, int n)
{
  /* Is arg n of the given command to be hidden from the log ? */

  /* set authkey xxxxx */
  /* set key xxxxx */
  if (n == 2 && !strncasecmp(argv[0], "se", 2) &&
      (!strncasecmp(argv[1], "authk", 5) || !strncasecmp(argv[1], "ke", 2)))
    return 1;

  /* passwd xxxxx */
  if (n == 1 && !strncasecmp(argv[0], "p", 1))
    return 1;

  return 0;
}

void
RunCommand(int argc, char const *const *argv, const char *label)
{
  if (argc > 0) {
    if (LogIsKept(LogCOMMAND)) {
      static char buf[LINE_LEN];
      int f, n;

      *buf = '\0';
      if (label) {
        strncpy(buf, label, sizeof buf - 3);
        buf[sizeof buf - 3] = '\0';
        strcat(buf, ": ");
      }
      n = strlen(buf);
      for (f = 0; f < argc; f++) {
        if (n < sizeof buf - 1 && f)
          buf[n++] = ' ';
        if (arghidden(argc, argv, f))
          strncpy(buf+n, HIDDEN, sizeof buf - n - 1);
        else
          strncpy(buf+n, argv[f], sizeof buf - n - 1);
        n += strlen(buf+n);
      }
      LogPrintf(LogCOMMAND, "%s\n", buf);
    }
    FindExec(Commands, argc, argv, "");
  }
}

void
DecodeCommand(char *buff, int nb, const char *label)
{
  int argc;
  char **argv;

  InterpretCommand(buff, nb, &argc, &argv);
  RunCommand(argc, (char const *const *)argv, label);
}

static int
ShowCommand(struct cmdargs const *arg)
{
  if (arg->argc > 0)
    FindExec(ShowCommands, arg->argc, arg->argv, "show ");
  else if (VarTerm)
    fprintf(VarTerm, "Use ``show ?'' to get a arg->cmd.\n");
  else
    LogPrintf(LogWARN, "show command must have arguments\n");

  return 0;
}

static int
TerminalCommand(struct cmdargs const *arg)
{
  if (LcpFsm.state > ST_CLOSED) {
    if (VarTerm)
      fprintf(VarTerm, "LCP state is [%s]\n", StateNames[LcpFsm.state]);
    return 1;
  }
  if (!IsInteractive(1))
    return (1);
  if (OpenModem() < 0) {
    if (VarTerm)
      fprintf(VarTerm, "Failed to open modem.\n");
    return (1);
  }
  if (VarTerm) {
    fprintf(VarTerm, "Entering terminal mode.\n");
    fprintf(VarTerm, "Type `~?' for help.\n");
  }
  TtyTermMode();
  return (0);
}

static int
QuitCommand(struct cmdargs const *arg)
{
  if (VarTerm) {
    DropClient(1);
    if (mode & MODE_INTER)
      Cleanup(EX_NORMAL);
    else if (arg->argc > 0 && !strcasecmp(*arg->argv, "all") && VarLocalAuth&LOCAL_AUTH)
      Cleanup(EX_NORMAL);
  }

  return 0;
}

static int
CloseCommand(struct cmdargs const *arg)
{
  reconnect(RECON_FALSE);
  LcpClose();
  return 0;
}

static int
DownCommand(struct cmdargs const *arg)
{
  LcpDown();
  return 0;
}

static int
SetModemSpeed(struct cmdargs const *arg)
{
  int speed;

  if (arg->argc > 0) {
    if (strcasecmp(*arg->argv, "sync") == 0) {
      VarSpeed = 0;
      return 0;
    }
    speed = atoi(*arg->argv);
    if (IntToSpeed(speed) != B0) {
      VarSpeed = speed;
      return 0;
    }
    LogPrintf(LogWARN, "%s: Invalid speed\n", *arg->argv);
  }
  return -1;
}

static int
SetReconnect(struct cmdargs const *arg)
{
  if (arg->argc == 2) {
    VarReconnectTimer = atoi(arg->argv[0]);
    VarReconnectTries = atoi(arg->argv[1]);
    return 0;
  }
  return -1;
}

static int
SetRedialTimeout(struct cmdargs const *arg)
{
  int timeout;
  int tries;
  char *dot;

  if (arg->argc == 1 || arg->argc == 2) {
    if (strncasecmp(arg->argv[0], "random", 6) == 0 &&
	(arg->argv[0][6] == '\0' || arg->argv[0][6] == '.')) {
      VarRedialTimeout = -1;
      randinit();
    } else {
      timeout = atoi(arg->argv[0]);

      if (timeout >= 0)
	VarRedialTimeout = timeout;
      else {
	LogPrintf(LogWARN, "Invalid redial timeout\n");
	return -1;
      }
    }

    dot = strchr(arg->argv[0], '.');
    if (dot) {
      if (strcasecmp(++dot, "random") == 0) {
	VarRedialNextTimeout = -1;
	randinit();
      } else {
	timeout = atoi(dot);
	if (timeout >= 0)
	  VarRedialNextTimeout = timeout;
	else {
	  LogPrintf(LogWARN, "Invalid next redial timeout\n");
	  return -1;
	}
      }
    } else
      VarRedialNextTimeout = NEXT_REDIAL_PERIOD;	/* Default next timeout */

    if (arg->argc == 2) {
      tries = atoi(arg->argv[1]);

      if (tries >= 0) {
	VarDialTries = tries;
      } else {
	LogPrintf(LogWARN, "Invalid retry value\n");
	return 1;
      }
    }
    return 0;
  }
  return -1;
}

static int
SetStoppedTimeout(struct cmdargs const *arg)
{
  LcpFsm.StoppedTimer.load = 0;
  IpcpFsm.StoppedTimer.load = 0;
  CcpFsm.StoppedTimer.load = 0;
  if (arg->argc <= 3) {
    if (arg->argc > 0) {
      LcpFsm.StoppedTimer.load = atoi(arg->argv[0]) * SECTICKS;
      if (arg->argc > 1) {
	IpcpFsm.StoppedTimer.load = atoi(arg->argv[1]) * SECTICKS;
	if (arg->argc > 2)
	  CcpFsm.StoppedTimer.load = atoi(arg->argv[2]) * SECTICKS;
      }
    }
    return 0;
  }
  return -1;
}

#define ismask(x) \
  (*x == '0' && strlen(x) == 4 && strspn(x+1, "0123456789.") == 3)

static int
SetServer(struct cmdargs const *arg)
{
  int res = -1;

  if (arg->argc > 0 && arg->argc < 4) {
    const char *port, *passwd, *mask;

    /* What's what ? */
    port = arg->argv[0];
    if (arg->argc == 2) {
      if (ismask(arg->argv[1])) {
        passwd = NULL;
        mask = arg->argv[1];
      } else {
        passwd = arg->argv[1];
        mask = NULL;
      }
    } else if (arg->argc == 3) {
      passwd = arg->argv[1];
      mask = arg->argv[2];
      if (!ismask(mask))
        return -1;
    } else
      passwd = mask = NULL;

    if (passwd == NULL)
      VarHaveLocalAuthKey = 0;
    else {
      strncpy(VarLocalAuthKey, passwd, sizeof VarLocalAuthKey - 1);
      VarLocalAuthKey[sizeof VarLocalAuthKey - 1] = '\0';
      VarHaveLocalAuthKey = 1;
    }
    LocalAuthInit();

    if (strcasecmp(port, "none") == 0) {
      int oserver;

      if (mask != NULL || passwd != NULL)
        return -1;
      oserver = server;
      ServerClose();
      if (oserver != -1)
        LogPrintf(LogPHASE, "Disabling server port.\n");
      res = 0;
    } else if (*port == '/') {
      mode_t imask;

      if (mask != NULL) {
	unsigned m;

	if (sscanf(mask, "%o", &m) == 1)
	  imask = m;
        else
          return -1;
      } else
        imask = (mode_t)-1;
      res = ServerLocalOpen(port, imask);
    } else {
      int iport;

      if (mask != NULL)
        return -1;

      if (strspn(port, "0123456789") != strlen(port)) {
        struct servent *s;

        if ((s = getservbyname(port, "tcp")) == NULL) {
	  iport = 0;
	  LogPrintf(LogWARN, "%s: Invalid port or service\n", port);
	} else
	  iport = ntohs(s->s_port);
      } else
        iport = atoi(port);
      res = iport ? ServerTcpOpen(iport) : -1;
    }
  }

  return res;
}

static int
SetModemParity(struct cmdargs const *arg)
{
  return arg->argc > 0 ? ChangeParity(*arg->argv) : -1;
}

static int
SetLogLevel(struct cmdargs const *arg)
{
  int i;
  int res;
  int argc;
  char const *const *argv, *argp;
  void (*Discard)(int), (*Keep)(int);
  void (*DiscardAll)(void);

  argc = arg->argc;
  argv = arg->argv;
  res = 0;
  if (argc == 0 || strcasecmp(argv[0], "local")) {
    Discard = LogDiscard;
    Keep = LogKeep;
    DiscardAll = LogDiscardAll;
  } else {
    argc--;
    argv++;
    Discard = LogDiscardLocal;
    Keep = LogKeepLocal;
    DiscardAll = LogDiscardAllLocal;
  }

  if (argc == 0 || (argv[0][0] != '+' && argv[0][0] != '-'))
    DiscardAll();
  while (argc--) {
    argp = **argv == '+' || **argv == '-' ? *argv + 1 : *argv;
    for (i = LogMIN; i <= LogMAX; i++)
      if (strcasecmp(argp, LogName(i)) == 0) {
	if (**argv == '-')
	  (*Discard)(i);
	else
	  (*Keep)(i);
	break;
      }
    if (i > LogMAX) {
      LogPrintf(LogWARN, "%s: Invalid log value\n", argp);
      res = -1;
    }
    argv++;
  }
  return res;
}

static int
SetEscape(struct cmdargs const *arg)
{
  int code;
  int argc = arg->argc;
  char const *const *argv = arg->argv;

  for (code = 0; code < 33; code++)
    EscMap[code] = 0;

  while (argc-- > 0) {
    sscanf(*argv++, "%x", &code);
    code &= 0xff;
    EscMap[code >> 3] |= (1 << (code & 7));
    EscMap[32] = 1;
  }
  return 0;
}

static int
SetInitialMRU(struct cmdargs const *arg)
{
  long mru;
  const char *err;

  if (arg->argc > 0) {
    mru = atol(*arg->argv);
    if (mru < MIN_MRU)
      err = "Given MRU value (%ld) is too small.\n";
    else if (mru > MAX_MRU)
      err = "Given MRU value (%ld) is too big.\n";
    else {
      VarMRU = mru;
      return 0;
    }
    LogPrintf(LogWARN, err, mru);
  }
  return -1;
}

static int
SetPreferredMTU(struct cmdargs const *arg)
{
  long mtu;
  const char *err;

  if (arg->argc > 0) {
    mtu = atol(*arg->argv);
    if (mtu == 0) {
      VarPrefMTU = 0;
      return 0;
    } else if (mtu < MIN_MTU)
      err = "Given MTU value (%ld) is too small.\n";
    else if (mtu > MAX_MTU)
      err = "Given MTU value (%ld) is too big.\n";
    else {
      VarPrefMTU = mtu;
      return 0;
    }
    LogPrintf(LogWARN, err, mtu);
  }
  return -1;
}

static int
SetTimeout(struct cmdargs const *arg)
{
  if (arg->argc > 0) {
    VarIdleTimeout = atoi(arg->argv[0]);
    UpdateIdleTimer();		/* If we're connected, restart the idle timer */
    if (arg->argc > 1) {
      VarLqrTimeout = atoi(arg->argv[1]);
      if (VarLqrTimeout < 1)
	VarLqrTimeout = 30;
      if (arg->argc > 2) {
	VarRetryTimeout = atoi(arg->argv[2]);
	if (VarRetryTimeout < 1 || VarRetryTimeout > 10)
	  VarRetryTimeout = 3;
      }
    }
    return 0;
  }
  return -1;
}

static struct in_addr
GetIpAddr(const char *cp)
{
  struct hostent *hp;
  struct in_addr ipaddr;

  if (inet_aton(cp, &ipaddr) == 0) {
    hp = gethostbyname(cp);
    if (hp && hp->h_addrtype == AF_INET)
      memcpy(&ipaddr, hp->h_addr, hp->h_length);
    else
      ipaddr.s_addr = 0;
  }
  return (ipaddr);
}

static int
SetInterfaceAddr(struct cmdargs const *arg)
{
  const char *hisaddr;

  hisaddr = NULL;
  DefMyAddress.ipaddr.s_addr = DefHisAddress.ipaddr.s_addr = 0L;

  if (arg->argc > 4)
    return -1;

  HaveTriggerAddress = 0;
  ifnetmask.s_addr = 0;
  iplist_reset(&DefHisChoice);

  if (arg->argc > 0) {
    if (!ParseAddr(arg->argc, arg->argv, &DefMyAddress.ipaddr,
		   &DefMyAddress.mask, &DefMyAddress.width))
      return 1;
    if (arg->argc > 1) {
      hisaddr = arg->argv[1];
      if (arg->argc > 2) {
	ifnetmask = GetIpAddr(arg->argv[2]);
	if (arg->argc > 3) {
	  TriggerAddress = GetIpAddr(arg->argv[3]);
	  HaveTriggerAddress = 1;
	}
      }
    }
  }

  /*
   * For backwards compatibility, 0.0.0.0 means any address.
   */
  if (DefMyAddress.ipaddr.s_addr == 0) {
    DefMyAddress.mask.s_addr = 0;
    DefMyAddress.width = 0;
  }
  IpcpInfo.want_ipaddr.s_addr = DefMyAddress.ipaddr.s_addr;

  if (hisaddr && !UseHisaddr(hisaddr, mode & MODE_AUTO))
    return 4;

  if (DefHisAddress.ipaddr.s_addr == 0) {
    DefHisAddress.mask.s_addr = 0;
    DefHisAddress.width = 0;
  }

  return 0;
}

#ifndef NOMSEXT

static void
SetMSEXT(struct in_addr * pri_addr,
	 struct in_addr * sec_addr,
	 int argc,
	 char const *const *argv)
{
  int dummyint;
  struct in_addr dummyaddr;

  pri_addr->s_addr = sec_addr->s_addr = 0L;

  if (argc > 0) {
    ParseAddr(argc, argv++, pri_addr, &dummyaddr, &dummyint);
    if (--argc > 0)
      ParseAddr(argc, argv++, sec_addr, &dummyaddr, &dummyint);
    else
      sec_addr->s_addr = pri_addr->s_addr;
  }

  /*
   * if the primary/secondary ns entries are 0.0.0.0 we should set them to
   * either the localhost's ip, or the values in /etc/resolv.conf ??
   * 
   * up to you if you want to implement this...
   */

}

static int
SetNS(struct cmdargs const *arg)
{
  SetMSEXT(&ns_entries[0], &ns_entries[1], arg->argc, arg->argv);
  return 0;
}

static int
SetNBNS(struct cmdargs const *arg)
{
  SetMSEXT(&nbns_entries[0], &nbns_entries[1], arg->argc, arg->argv);
  return 0;
}

#endif				/* MS_EXT */

int
SetVariable(struct cmdargs const *arg)
{
  u_long map;
  const char *argp;
  long param = (long)arg->data;

  if (arg->argc > 0)
    argp = *arg->argv;
  else
    argp = "";

  switch (param) {
  case VAR_AUTHKEY:
    strncpy(VarAuthKey, argp, sizeof VarAuthKey - 1);
    VarAuthKey[sizeof VarAuthKey - 1] = '\0';
    break;
  case VAR_AUTHNAME:
    strncpy(VarAuthName, argp, sizeof VarAuthName - 1);
    VarAuthName[sizeof VarAuthName - 1] = '\0';
    break;
  case VAR_DIAL:
    strncpy(VarDialScript, argp, sizeof VarDialScript - 1);
    VarDialScript[sizeof VarDialScript - 1] = '\0';
    break;
  case VAR_LOGIN:
    strncpy(VarLoginScript, argp, sizeof VarLoginScript - 1);
    VarLoginScript[sizeof VarLoginScript - 1] = '\0';
    break;
  case VAR_DEVICE:
    if (mode & MODE_INTER)
      HangupModem(0);
    if (modem != -1)
      LogPrintf(LogWARN, "Cannot change device to \"%s\" when \"%s\" is open\n",
                argp, VarDevice);
    else {
      strncpy(VarDeviceList, argp, sizeof VarDeviceList - 1);
      VarDeviceList[sizeof VarDeviceList - 1] = '\0';
    }
    break;
  case VAR_ACCMAP:
    sscanf(argp, "%lx", &map);
    VarAccmap = map;
    break;
  case VAR_PHONE:
    strncpy(VarPhoneList, argp, sizeof VarPhoneList - 1);
    VarPhoneList[sizeof VarPhoneList - 1] = '\0';
    strncpy(VarPhoneCopy, VarPhoneList, sizeof VarPhoneCopy - 1);
    VarPhoneCopy[sizeof VarPhoneCopy - 1] = '\0';
    VarNextPhone = VarPhoneCopy;
    VarAltPhone = NULL;
    break;
  case VAR_HANGUP:
    strncpy(VarHangupScript, argp, sizeof VarHangupScript - 1);
    VarHangupScript[sizeof VarHangupScript - 1] = '\0';
    break;
#ifdef HAVE_DES
  case VAR_ENC:
    VarMSChap = !strcasecmp(argp, "mschap");
    break;
#endif
  }
  return 0;
}

static int 
SetCtsRts(struct cmdargs const *arg)
{
  if (arg->argc > 0) {
    if (strcmp(*arg->argv, "on") == 0)
      VarCtsRts = 1;
    else if (strcmp(*arg->argv, "off") == 0)
      VarCtsRts = 0;
    else
      return -1;
    return 0;
  }
  return -1;
}


static int 
SetOpenMode(struct cmdargs const *arg)
{
  if (arg->argc > 0) {
    if (strcasecmp(*arg->argv, "active") == 0)
      VarOpenMode = arg->argc > 1 ? atoi(arg->argv[1]) : 1;
    else if (strcasecmp(*arg->argv, "passive") == 0)
      VarOpenMode = OPEN_PASSIVE;
    else
      return -1;
    return 0;
  }
  return -1;
}

static struct cmdtab const SetCommands[] = {
  {"accmap", NULL, SetVariable, LOCAL_AUTH,
  "Set accmap value", "set accmap hex-value", (const void *) VAR_ACCMAP},
  {"afilter", NULL, SetAfilter, LOCAL_AUTH,
  "Set keep Alive filter", "set afilter ..."},
  {"authkey", "key", SetVariable, LOCAL_AUTH,
  "Set authentication key", "set authkey|key key", (const void *) VAR_AUTHKEY},
  {"authname", NULL, SetVariable, LOCAL_AUTH,
  "Set authentication name", "set authname name", (const void *) VAR_AUTHNAME},
  {"ctsrts", NULL, SetCtsRts, LOCAL_AUTH,
  "Use CTS/RTS modem signalling", "set ctsrts [on|off]"},
  {"device", "line", SetVariable, LOCAL_AUTH, "Set modem device name",
  "set device|line device-name[,device-name]", (const void *) VAR_DEVICE},
  {"dfilter", NULL, SetDfilter, LOCAL_AUTH,
  "Set demand filter", "set dfilter ..."},
  {"dial", NULL, SetVariable, LOCAL_AUTH,
  "Set dialing script", "set dial chat-script", (const void *) VAR_DIAL},
#ifdef HAVE_DES
  {"encrypt", NULL, SetVariable, LOCAL_AUTH, "Set CHAP encryption algorithm",
  "set encrypt MSChap|MD5", (const void *) VAR_ENC},
#endif
  {"escape", NULL, SetEscape, LOCAL_AUTH,
  "Set escape characters", "set escape hex-digit ..."},
  {"hangup", NULL, SetVariable, LOCAL_AUTH,
  "Set hangup script", "set hangup chat-script", (const void *) VAR_HANGUP},
  {"ifaddr", NULL, SetInterfaceAddr, LOCAL_AUTH, "Set destination address",
  "set ifaddr [src-addr [dst-addr [netmask [trg-addr]]]]"},
  {"ifilter", NULL, SetIfilter, LOCAL_AUTH,
  "Set input filter", "set ifilter ..."},
  {"loopback", NULL, SetLoopback, LOCAL_AUTH,
  "Set loopback facility", "set loopback on|off"},
  {"log", NULL, SetLogLevel, LOCAL_AUTH,
  "Set log level", "set log [local] [+|-]value..."},
  {"login", NULL, SetVariable, LOCAL_AUTH,
  "Set login script", "set login chat-script", (const void *) VAR_LOGIN},
  {"mru", NULL, SetInitialMRU, LOCAL_AUTH,
  "Set Initial MRU value", "set mru value"},
  {"mtu", NULL, SetPreferredMTU, LOCAL_AUTH,
  "Set Preferred MTU value", "set mtu value"},
#ifndef NOMSEXT
  {"nbns", NULL, SetNBNS, LOCAL_AUTH,
  "Set NetBIOS NameServer", "set nbns pri-addr [sec-addr]"},
  {"ns", NULL, SetNS, LOCAL_AUTH,
  "Set NameServer", "set ns pri-addr [sec-addr]"},
#endif
  {"ofilter", NULL, SetOfilter, LOCAL_AUTH,
  "Set output filter", "set ofilter ..."},
  {"openmode", NULL, SetOpenMode, LOCAL_AUTH,
  "Set open mode", "set openmode [active|passive]"},
  {"parity", NULL, SetModemParity, LOCAL_AUTH,
  "Set modem parity", "set parity [odd|even|none]"},
  {"phone", NULL, SetVariable, LOCAL_AUTH, "Set telephone number(s)",
  "set phone phone1[:phone2[...]]", (const void *) VAR_PHONE},
  {"reconnect", NULL, SetReconnect, LOCAL_AUTH,
  "Set Reconnect timeout", "set reconnect value ntries"},
  {"redial", NULL, SetRedialTimeout, LOCAL_AUTH, "Set Redial timeout",
  "set redial value|random[.value|random] [dial_attempts]"},
  {"stopped", NULL, SetStoppedTimeout, LOCAL_AUTH, "Set STOPPED timeouts",
  "set stopped [LCPseconds [IPCPseconds [CCPseconds]]]"},
  {"server", "socket", SetServer, LOCAL_AUTH,
  "Set server port", "set server|socket TcpPort|LocalName|none [mask]"},
  {"speed", NULL, SetModemSpeed, LOCAL_AUTH,
  "Set modem speed", "set speed value"},
  {"timeout", NULL, SetTimeout, LOCAL_AUTH,
  "Set Idle timeout", "set timeout idle LQR FSM-resend"},
  {"vj", NULL, SetInitVJ, LOCAL_AUTH,
  "Set vj values", "set vj slots|slotcomp"},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
  "Display this message", "set help|? [command]", SetCommands},
  {NULL, NULL, NULL},
};

static int
SetCommand(struct cmdargs const *arg)
{
  if (arg->argc > 0)
    FindExec(SetCommands, arg->argc, arg->argv, "set ");
  else if (VarTerm)
    fprintf(VarTerm, "Use `set ?' to get a arg->cmd or `set ? <var>' for"
	    " syntax help.\n");
  else
    LogPrintf(LogWARN, "set command must have arguments\n");

  return 0;
}


static int
AddCommand(struct cmdargs const *arg)
{
  struct in_addr dest, gateway, netmask;
  int gw;

  if (arg->argc != 3 && arg->argc != 2)
    return -1;

  if (arg->argc == 2) {
    if (strcasecmp(arg->argv[0], "default"))
      return -1;
    else {
      dest.s_addr = netmask.s_addr = INADDR_ANY;
      gw = 1;
    }
  } else {
    if (strcasecmp(arg->argv[0], "MYADDR") == 0)
      dest = IpcpInfo.want_ipaddr;
    else if (strcasecmp(arg->argv[0], "HISADDR") == 0)
      dest = IpcpInfo.his_ipaddr;
    else
      dest = GetIpAddr(arg->argv[0]);
    netmask = GetIpAddr(arg->argv[1]);
    gw = 2;
  }
  if (strcasecmp(arg->argv[gw], "HISADDR") == 0)
    gateway = IpcpInfo.his_ipaddr;
  else if (strcasecmp(arg->argv[gw], "INTERFACE") == 0)
    gateway.s_addr = INADDR_ANY;
  else
    gateway = GetIpAddr(arg->argv[gw]);
  OsSetRoute(RTM_ADD, dest, gateway, netmask, arg->data ? 1 : 0);
  return 0;
}

static int
DeleteCommand(struct cmdargs const *arg)
{
  struct in_addr dest, none;

  if (arg->argc == 1) {
    if(strcasecmp(arg->argv[0], "all") == 0)
      DeleteIfRoutes(0);
    else {
      if (strcasecmp(arg->argv[0], "MYADDR") == 0)
        dest = IpcpInfo.want_ipaddr;
      else if (strcasecmp(arg->argv[0], "default") == 0)
        dest.s_addr = INADDR_ANY;
      else
        dest = GetIpAddr(arg->argv[0]);
      none.s_addr = INADDR_ANY;
      OsSetRoute(RTM_DELETE, dest, none, none, arg->data ? 1 : 0);
    }
  } else
    return -1;

  return 0;
}

#ifndef NOALIAS
static struct cmdtab const AliasCommands[] =
{
  {"enable", NULL, AliasEnable, LOCAL_AUTH,
  "enable IP aliasing", "alias enable [yes|no]"},
  {"port", NULL, AliasRedirectPort, LOCAL_AUTH,
  "port redirection", "alias port [proto addr_local:port_local  port_alias]"},
  {"addr", NULL, AliasRedirectAddr, LOCAL_AUTH,
  "static address translation", "alias addr [addr_local addr_alias]"},
  {"deny_incoming", NULL, AliasOption, LOCAL_AUTH,
    "stop incoming connections", "alias deny_incoming [yes|no]",
  (const void *) PKT_ALIAS_DENY_INCOMING},
  {"log", NULL, AliasOption, LOCAL_AUTH,
    "log aliasing link creation", "alias log [yes|no]",
  (const void *) PKT_ALIAS_LOG},
  {"same_ports", NULL, AliasOption, LOCAL_AUTH,
    "try to leave port numbers unchanged", "alias same_ports [yes|no]",
  (const void *) PKT_ALIAS_SAME_PORTS},
  {"use_sockets", NULL, AliasOption, LOCAL_AUTH,
    "allocate host sockets", "alias use_sockets [yes|no]",
  (const void *) PKT_ALIAS_USE_SOCKETS},
  {"unregistered_only", NULL, AliasOption, LOCAL_AUTH,
    "alias unregistered (private) IP address space only",
    "alias unregistered_only [yes|no]",
  (const void *) PKT_ALIAS_UNREGISTERED_ONLY},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
    "Display this message", "alias help|? [command]", AliasCommands},
  {NULL, NULL, NULL},
};


static int
AliasCommand(struct cmdargs const *arg)
{
  if (arg->argc > 0)
    FindExec(AliasCommands, arg->argc, arg->argv, "alias ");
  else if (VarTerm)
    fprintf(VarTerm, "Use `alias help' to get a arg->cmd or `alias help <option>'"
	    " for syntax help.\n");
  else
    LogPrintf(LogWARN, "alias command must have arguments\n");

  return 0;
}

static int
AliasEnable(struct cmdargs const *arg)
{
  if (arg->argc == 1) {
    if (strcasecmp(arg->argv[0], "yes") == 0) {
      if (!(mode & MODE_ALIAS)) {
	if (loadAliasHandlers(&VarAliasHandlers) == 0) {
	  mode |= MODE_ALIAS;
	  return 0;
	}
	LogPrintf(LogWARN, "Cannot load alias library\n");
	return 1;
      }
      return 0;
    } else if (strcasecmp(arg->argv[0], "no") == 0) {
      if (mode & MODE_ALIAS) {
	unloadAliasHandlers();
	mode &= ~MODE_ALIAS;
      }
      return 0;
    }
  }
  return -1;
}


static int
AliasOption(struct cmdargs const *arg)
{
  unsigned param = (unsigned)arg->data;
  if (arg->argc == 1) {
    if (strcasecmp(arg->argv[0], "yes") == 0) {
      if (mode & MODE_ALIAS) {
	VarPacketAliasSetMode(param, param);
	return 0;
      }
      LogPrintf(LogWARN, "alias not enabled\n");
    } else if (strcmp(arg->argv[0], "no") == 0) {
      if (mode & MODE_ALIAS) {
	VarPacketAliasSetMode(0, param);
	return 0;
      }
      LogPrintf(LogWARN, "alias not enabled\n");
    }
  }
  return -1;
}
#endif /* #ifndef NOALIAS */

static struct cmdtab const AllowCommands[] = {
  {"users", "user", AllowUsers, LOCAL_AUTH,
  "Allow users access to ppp", "allow users logname..."},
  {"modes", "mode", AllowModes, LOCAL_AUTH,
  "Only allow certain ppp modes", "allow modes mode..."},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
  "Display this message", "allow help|? [command]", AllowCommands},
  {NULL, NULL, NULL},
};

static int
AllowCommand(struct cmdargs const *arg)
{
  if (arg->argc > 0)
    FindExec(AllowCommands, arg->argc, arg->argv, "allow ");
  else if (VarTerm)
    fprintf(VarTerm, "Use `allow ?' to get a arg->cmd or `allow ? <cmd>' for"
	    " syntax help.\n");
  else
    LogPrintf(LogWARN, "allow command must have arguments\n");

  return 0;
}
@


1.31
log
@Don't assume sizeof(long) == 4
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.30 1998/06/07 17:10:33 brian Exp $
@


1.30
log
@Use a width of 0 rather than 32 when HISADDR is 0.0.0.0.
Reported by:      many
Narrowed down by: Lutz Albers <lutz@@muc.de>
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.29 1998/04/25 09:23:13 brian Exp $
d1333 1
a1333 1
  int param = (int)arg->data;
@


1.29
log
@Add libalias and tidy up a few warnings.
libalias does not build by default, you must build and
install it manually (cd ppp/libalias && make && make install).
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.28 1998/03/13 01:25:54 brian Exp $
d1270 4
a1277 3

  if (hisaddr && !UseHisaddr(hisaddr, mode & MODE_AUTO))
    return 4;
@


1.28
log
@Add extraneous braces to stiffle warnings from gcc-2.8
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.27 1998/03/12 02:40:40 brian Exp $
d1618 1
a1618 1
  if (arg->argc == 1)
d1636 1
d1645 1
a1645 1
  if (arg->argc == 1)
d1659 1
@


1.27
log
@o Fix a few comment typos.
o Fix ``set timeout'' usage message and documentation.
o Change ifOutPackets, ifOutOctets and ifOutLQRs to `u_int32_t's
  so that they wrap correctly.
o Put the LQR in network byte order using the correct struct size
  (sizeof u_int32_t, not sizeof u_long).
o Wrap LQR ECHO counters correctly.
o Don't increment OutLQR count if the last LQR hasn't been replied
  to.
o Initialise HisLqrData (last received LQR) in StartLqm.
o Don't start the LQR timer if we're `disabled' and `accepted'.
o Generate LQR responses when both sides are using a timer and
  we're not going to send our next LQR before the peers max timeout.

LQR should now be fully functional.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.26 1998/01/29 00:34:31 brian Exp $
d213 1
a213 1
  if (arg->argc == 1)
d217 1
a217 2
    }
    else if (!strcasecmp(*arg->argv, "off")) {
d221 1
d252 1
a252 1
  if (arg->argc == 0)
d266 2
d538 1
a538 1
  if (VarTerm)
d543 1
d1007 1
a1007 1
    if (arg->argc == 2)
d1015 1
a1015 1
    else if (arg->argc == 3) {
d1519 1
a1519 1
  if (arg->argc == 2)
d1526 1
a1526 1
  else {
d1551 1
a1551 1
  if (arg->argc == 1)
d1564 1
a1564 1
  else
@


1.26
log
@Cosmetic:
  Don't mention the authors name at startup.  He's already credited
  in the man page.  Instead, make the message consistent with the
  one given to the diagnostic port (and fix the grammar when entering
  `term' mode).
  Don't credit the zlib author in the man page as ppp isn't linked
  directly with zlib (it's shared).
  Mention when the OpenBSD port was first made available.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.25 1998/01/23 04:34:26 brian Exp $
d1192 1
a1192 1
SetIdleTimeout(struct cmdargs const *arg)
d1483 2
a1484 2
  {"timeout", NULL, SetIdleTimeout, LOCAL_AUTH,
  "Set Idle timeout", "set timeout value"},
@


1.25
log
@Don't allow manual dialing unless in auto or interactive mode.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.24 1998/01/20 22:46:23 brian Exp $
d143 1
a143 1
  const char *mes = NULL;
d146 1
a146 1
    mes = "Working in dedicated dial mode.";
d148 1
a148 1
    mes = "Working in background mode.";
d150 1
a150 1
    mes = "Working in auto mode.";
d152 1
a152 1
    mes = "Working in direct mode.";
d154 4
a157 2
    mes = "Working in dedicated mode.";
  if (mes) {
d159 1
a159 2
      fprintf(VarTerm, "%s\n", mes);
    return 0;
d161 1
a161 1
  return 1;
d849 1
a849 1
    fprintf(VarTerm, "Enter to terminal mode.\n");
@


1.24
log
@Allow an optional delay when specifying "set openmode active".
The delay defaults to 1 sec (as it always has) unless we've done
a ~p in interactive mode or we've actually detected a HDLC frame.
This is now cleanly implemented (via async timers) so that it is
possible for LCP to come up despite the delay if an LCP REQ is
received.

This will hopefully solve situations with slow servers or slirp
scenarios (where ECHO is left on the port for a second or so before
the peer enters packet mode).

Also, ~p in interactive mode no longer changes the value of the default
openmode delay and -dedicated mode enters packet mode in the right state
according to the value of openmode.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.23 1998/01/18 20:47:19 brian Exp $
d173 6
@


1.23
log
@Allow "set vj" for changing the default number of slots
and whether slot compression is requested.
Don't show current values with "show ipcp" if IPCP isn't
"opened".
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.22 1998/01/11 17:54:46 brian Exp $
a192 1
      nointr_sleep(1);
d194 1
a194 1
      PacketMode();
d1402 3
a1404 3
    if (strcmp(*arg->argv, "active") == 0)
      VarOpenMode = OPEN_ACTIVE;
    else if (strcmp(*arg->argv, "passive") == 0)
@


1.22
log
@Make things work when sizeof(long) != 32 (hopefully)
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.21 1998/01/10 21:50:56 brian Exp $
d623 4
a642 4
#ifndef NOMSEXT
  {"msext", NULL, ShowMSExt, LOCAL_AUTH,
  "Show MS PPP extentions", "show msext"},
#endif
d645 2
d1453 6
d1479 2
a1480 6
#ifndef NOMSEXT
  {"ns", NULL, SetNS, LOCAL_AUTH,
  "Set NameServer", "set ns pri-addr [sec-addr]"},
  {"nbns", NULL, SetNBNS, LOCAL_AUTH,
  "Set NetBIOS NameServer", "set nbns pri-addr [sec-addr]"},
#endif
@


1.21
log
@Pause according to the redial setting when dialing manually.
Pointed out by: Berend de Boer <berend@@compuserve.com>
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.20 1998/01/05 01:39:04 brian Exp $
d523 1
a523 1
    fprintf(VarTerm, " Initial MRU: %ld\n", VarMRU);
d532 1
a532 1
      fprintf(VarTerm, " Preferred MTU: %ld\n", VarPrefMTU);
@


1.20
log
@o Allow the use of HISADDR as the first arg to "add".
o Allow a forth argument in ppp.secret, specifying a new
  label.  This gives control over which section of
  ppp.link{up,down} is used based on the authenticated user.
o Support random address ranges in ppp.secret (not just in ppp.conf).
o Add a AUTHENTICATING INCOMING CONNECTIONS section to the man page.
o Add a bit more about DEFLATE in the man page.
o Fix the incorrect "you must specify a password in interactive
  mode" bit of the manual.
o Space things in the man page consistently.
o Be more precice about where you can use MYADDR, HISADDR and INTERFACE
  in the "add" command documentation.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.19 1997/12/30 23:22:35 brian Exp $
d180 5
@


1.19
log
@Allow "set device" to close the open modem if we're in
interactive mode.
Use `netfd' in fcntl() and tc[gs]etattr() calls rather than
the hard coded descriptor 0.
Use _FILENO constants from unistd.h

This un-breaks things after my recent `close(0)' in interactive
mode.

Close STDIN_FILENO, and open _PATH_TTY O_RDONLY as `netfd'.  This
has the effect of allowing `show route' to output more than about
a page of data (on FreeBSD, not OpenBSD....).  I have no idea why,
except that it was a direct consequence of the tcsetattr() in
TtyCommandMode().  My previous fix (closing descriptor 0) `fixed'
this because all calls to tcsetattr() failed :-(
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.18 1997/12/30 20:03:03 brian Exp $
d1218 3
d1235 1
a1235 5
      if (strpbrk(arg->argv[1], ",-"))
        iplist_setsrc(&DefHisChoice, arg->argv[1]);
      else if (!ParseAddr(arg->argc, arg->argv+1, &DefHisAddress.ipaddr,
		            &DefHisAddress.mask, &DefHisAddress.width))
	return 2;
d1253 1
a1257 13
  IpcpInfo.want_ipaddr.s_addr = DefMyAddress.ipaddr.s_addr;
  if (iplist_isvalid(&DefHisChoice)) {
    iplist_setrandpos(&DefHisChoice);
    IpcpInfo.his_ipaddr = ChooseHisAddr(IpcpInfo.want_ipaddr);
    if (IpcpInfo.his_ipaddr.s_addr == INADDR_ANY) {
      LogPrintf(LogWARN, "%s: None available !\n", DefHisChoice.src);
      return 3;
    }
    DefHisAddress.ipaddr.s_addr = IpcpInfo.his_ipaddr.s_addr;
    DefHisAddress.mask.s_addr = 0xffffffff;
    DefHisAddress.width = 32;
  } else {
    IpcpInfo.his_ipaddr.s_addr = DefHisAddress.ipaddr.s_addr;
d1259 2
a1260 6
    if ((mode & MODE_AUTO) &&
        OsSetIpaddress(DefMyAddress.ipaddr, DefHisAddress.ipaddr) < 0) {
      DefMyAddress.ipaddr.s_addr = DefHisAddress.ipaddr.s_addr = 0L;
      return 4;
    }
  }
d1511 2
@


1.18
log
@Use inet_aton() before gethostbyname()

Suggested by: Christian Sandberg <christian@@yes.no>
              Eivind Eklund <perhaps@@yes.no>
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.17 1997/12/30 02:45:05 brian Exp $
d1358 2
@


1.17
log
@Allow "add! dst mask gw" (note the ``!'') to do an
RTM_CHANGE if the RTM_ADD fails with an EEXIST.
Allow "delete! dst" (note the ``!'') to silently
fail if the RTM_DELETE fails with an ESRCH.
Also, make the ESRCH and EEXIST error conditions
more understandable to the casual observer.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.16 1997/12/29 22:23:04 brian Exp $
d1205 7
a1211 5
  hp = gethostbyname(cp);
  if (hp && hp->h_addrtype == AF_INET)
    memcpy(&ipaddr, hp->h_addr, hp->h_length);
  else if (inet_aton(cp, &ipaddr) == 0)
    ipaddr.s_addr = 0;
@


1.16
log
@Show how much time is left before timing out in the
`show timeout' output.
Remove ipIdleSecs variable - it's not used.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.15 1997/12/27 13:45:18 brian Exp $
d348 3
a350 1
  "add route", "add dest mask gateway"},
d358 3
a360 1
  "delete route", "delete dest"},
d1535 1
a1535 1
  OsSetRoute(RTM_ADD, dest, gateway, netmask);
d1555 1
a1555 1
      OsSetRoute(RTM_DELETE, dest, none, none);
@


1.15
log
@Show who closes the diagnostic connection.
Show the IP range (if specified) in "show ipcp".
Close unused descriptors 0 and 2 in interactive mode.
Pass (size_t *) rather than (int *) to sysctl().
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.14 1997/12/27 07:22:16 brian Exp $
d447 3
a449 1
  if (VarTerm)
d453 4
@


1.14
log
@Allow (and document) execution of commands from within
our chat script.
You can now even run chat(8) - see ppp.conf.sample.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.13 1997/12/24 09:30:27 brian Exp $
d837 1
a837 1
    DropClient();
@


1.13
log
@Cosmetic (style):
  sizeof(var) -> sizeof var
  sizeof type -> sizeof(type)

Suggested by: J Wunsch <j@@uriah.heep.sax.de>
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.12 1997/12/23 22:38:01 brian Exp $
a218 1
  FILE *oVarTerm;
d261 7
a276 9
    if (fd > 2)
      if (VarTerm) {
	oVarTerm = VarTerm;
	VarTerm = 0;
	if (oVarTerm && oVarTerm != stdout)
	  fclose(oVarTerm);
      } else
	close(fd);

d305 1
a305 1
        fprintf(VarTerm, "ppp: Pausing until %s finishes\n", arg->argv[0]);
d309 1
a309 1
        fprintf(VarTerm, "ppp: Pausing until %s finishes\n", shell);
d313 2
a314 1
    LogPrintf(LogWARN, "exec() of %s failed\n", arg->argc > 0 ? arg->argv[0] : shell);
d325 1
a325 1
  TtyCommandMode(1);
@


1.12
log
@strncpy(x,y,sizeof(x)) --> strncpy(x,y,sizeof(x)-1)

Suggested by: Philippe Charnier <charnier@@lirmm.fr>
              Theo de Raadt <deraadt@@cvs.openbsd.org>
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.11 1997/12/21 03:15:53 brian Exp $
d769 2
a770 2
        strncpy(buf, label, sizeof(buf) - 3);
        buf[sizeof(buf)-3] = '\0';
d775 1
a775 1
        if (n < sizeof(buf)-1 && f)
d778 1
a778 1
          strncpy(buf+n, HIDDEN, sizeof(buf)-n-1);
d780 1
a780 1
          strncpy(buf+n, argv[f], sizeof(buf)-n-1);
d1002 1
a1002 1
      strncpy(VarLocalAuthKey, passwd, sizeof(VarLocalAuthKey) - 1);
d1332 2
a1333 2
    strncpy(VarAuthKey, argp, sizeof(VarAuthKey) - 1);
    VarAuthKey[sizeof(VarAuthKey) - 1] = '\0';
d1336 2
a1337 2
    strncpy(VarAuthName, argp, sizeof(VarAuthName) - 1);
    VarAuthName[sizeof(VarAuthName) - 1] = '\0';
d1340 2
a1341 2
    strncpy(VarDialScript, argp, sizeof(VarDialScript) - 1);
    VarDialScript[sizeof(VarDialScript) - 1] = '\0';
d1344 2
a1345 2
    strncpy(VarLoginScript, argp, sizeof(VarLoginScript) - 1);
    VarLoginScript[sizeof(VarLoginScript) - 1] = '\0';
d1352 2
a1353 2
      strncpy(VarDeviceList, argp, sizeof(VarDeviceList) - 1);
      VarDeviceList[sizeof(VarDeviceList) - 1] = '\0';
d1361 4
a1364 4
    strncpy(VarPhoneList, argp, sizeof(VarPhoneList) - 1);
    VarPhoneList[sizeof(VarPhoneList) - 1] = '\0';
    strncpy(VarPhoneCopy, VarPhoneList, sizeof(VarPhoneCopy) - 1);
    VarPhoneCopy[sizeof(VarPhoneCopy) - 1] = '\0';
d1369 2
a1370 2
    strncpy(VarHangupScript, argp, sizeof(VarHangupScript) - 1);
    VarHangupScript[sizeof(VarHangupScript) - 1] = '\0';
@


1.11
log
@Allow multiple (comma seperated) devices on the "set device" line.
Submitted by: Derek Inksetter <derek@@saidev.com>
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.10 1997/12/19 18:12:08 brian Exp $
d769 1
a769 1
        strncpy(buf, label, sizeof buf);
d1002 1
a1002 1
      strncpy(VarLocalAuthKey, passwd, sizeof VarLocalAuthKey);
d1363 1
a1363 1
    strncpy(VarPhoneCopy, VarPhoneList, sizeof(VarPhoneCopy));
@


1.10
log
@Reset our "ifaddr" to zero if the "set ifaddr" fails in
-auto mode.  This makes ppp correctly exit if you kick it
off twice in auto mode with the same label (read: interface).
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.9 1997/12/18 01:10:25 brian Exp $
d1352 2
a1353 4
      strncpy(VarDevice, argp, sizeof(VarDevice) - 1);
      VarDevice[sizeof(VarDevice) - 1] = '\0';
      VarBaseDevice = strrchr(VarDevice, '/');
      VarBaseDevice = VarBaseDevice ? VarBaseDevice + 1 : "";
d1424 1
a1424 1
  "set device|line device-name", (const void *) VAR_DEVICE},
@


1.9
log
@Replace

  strcpy(a, b);  /* a and b are the same size */

with

  strncpy(a, b, sizeof(a));
  a[sizeof(a)-1] = '\0';

Making the code `correct at a glance'.

Suggested by: Theo de Raadt <deraadt@@cvs.openbsd.org>
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.8 1997/12/18 00:28:48 brian Exp $
d1263 2
a1264 1
        OsSetIpaddress(DefMyAddress.ipaddr, DefHisAddress.ipaddr) < 0)
d1266 1
@


1.8
log
@Don't log the actual password when command-logging
"passwd xxxx".
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.7 1997/12/17 21:17:44 brian Exp $
d1363 2
a1364 1
    strcpy(VarPhoneCopy, VarPhoneList);
@


1.7
log
@o Log ******** instead of the actual password for "set authkey"
  when command logging is switched on.
o Display ******** for the authkey for "show auth"
o Document how \P should be used, and document the other chat escapes
  while I'm there.
o Make sure the full command is displayed when a compound command
  fails - ie, "set novar rubbish" should say "set novar: Invalid command"
  rather than "novar: Invalid command"

Problem pointed out by: Theo de Raadt <deraadt@@cvs.openbsd.org> (among others)
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.6 1997/12/17 00:20:36 brian Exp $
d745 3
d750 4
@


1.6
log
@Fix a potential overflow where, if the label passed on the command
line is > LINE_LEN (512 bytes), we scribble (*blush*).

Hinted at by: Theo de Raadt <deraadt@@cvs.openbsd.org>

Change sprintf(buf, "fixedstring") to strcpy(buf, "fixedstring").
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.5 1997/12/15 22:50:20 brian Exp $
d78 1
d491 1
a491 1
  fprintf(VarTerm, "AuthKey  = %s\n", VarAuthKey);
d670 2
a671 1
FindExec(struct cmdtab const *cmds, int argc, char const *const *argv)
d680 1
a680 1
    LogPrintf(LogWARN, "%s: Ambiguous command\n", *argv);
d688 1
a688 1
    LogPrintf(LogWARN, "%s: Invalid command\n", *argv);
d693 1
a693 1
    LogPrintf(LogWARN, "%s: Failed %d\n", *argv, val);
d741 11
d770 4
a773 1
        strncpy(buf+n, argv[f], sizeof(buf)-n-1);
d778 1
a778 1
    FindExec(Commands, argc, argv);
d796 1
a796 1
    FindExec(ShowCommands, arg->argc, arg->argv);
d1478 1
a1478 1
    FindExec(SetCommands, arg->argc, arg->argv);
d1582 1
a1582 1
    FindExec(AliasCommands, arg->argc, arg->argv);
d1653 1
a1653 1
    FindExec(AllowCommands, arg->argc, arg->argv);
@


1.5
log
@Use LogWARN for command usage messages and unrecognised
commands, not LogCOMMAND.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.4 1997/12/15 22:44:50 brian Exp $
d749 2
a750 1
        strcpy(buf, label);
@


1.4
log
@Allow random IP number allocation to peer.
Validate the peers suggested IP by attempting to make a routing table
entry.
Give up IPCP negotiation if the peer NAKs us with an unusable IP.
Always SIOCDIFADDR then SIOCAIFADDR when configuring the tun device.
Using SIOCSIFDSTADDR allows duplicate dst addresses (which we don't
want)!!!
Allow up to 200 interface names (was 50) (now that ppp can play server
properly).

Cosmetic:
  Log unexpected CCP packets in the CCP log rather than the ERROR log.
  Log unexpected Config Reqs in the appropriate LCP/IPCP/CCP log rather
  than the ERROR log.
  Log failed route additions and deletions with WARN, not TCPIP.
  Log the option id and length for unrecognised IPCP options.
  Change some .Sq to .Ar in the man page.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.3 1997/12/08 20:09:06 brian Exp $
d691 1
a691 1
    LogPrintf(LogCOMMAND, "%s: Failed %d\n", *argv, val);
@


1.3
log
@Correct usage of `add' and `delete'.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.2 1997/12/07 04:09:07 brian Exp $
d56 1
d1191 1
d1194 2
a1195 4
    if (ParseAddr(arg->argc, arg->argv,
		  &DefMyAddress.ipaddr,
		  &DefMyAddress.mask,
		  &DefMyAddress.width) == 0)
d1198 4
a1201 4
      if (ParseAddr(arg->argc, arg->argv+1,
		    &DefHisAddress.ipaddr,
		    &DefHisAddress.mask,
		    &DefHisAddress.width) == 0)
d1225 12
a1236 1
  IpcpInfo.his_ipaddr.s_addr = DefHisAddress.ipaddr.s_addr;
d1238 4
a1241 3
  if ((mode & MODE_AUTO) &&
      OsSetIpaddress(DefMyAddress.ipaddr, DefHisAddress.ipaddr, ifnetmask) < 0)
    return 4;
@


1.2
log
@Only allow one arg to `delete' - the mask & gateway aren't necessary.
Delete AF_LINK routes as well as AF_INET.
Allow the word `default' as the arg to `delete' or in place of the
first two args (dest & netmask) to `add'.
Accept INTERFACE as the third arg to `add'.

  You can now say `add default interface' to create a default route
  through the tun interface.  It's reported that subsequent bind()s
  will bind to a broadcast address and not to the address currently
  assigned to the tun device - this is the first step towards
  supporting that first connection that was around from before the
  dynamic IP negotiation....
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.1.1.1 1997/11/23 20:27:33 brian Exp $
d356 1
a356 1
  "delete route", "delete ALL | dest [gateway [mask]]"},
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.105 1997/11/22 03:37:28 brian Exp $
d1464 1
d1466 11
a1476 1
  if (arg->argc == 3) {
d1482 1
a1482 6
    if (strcasecmp(arg->argv[2], "HISADDR") == 0)
      gateway = IpcpInfo.his_ipaddr;
    else
      gateway = GetIpAddr(arg->argv[2]);
    OsSetRoute(RTM_ADD, dest, gateway, netmask);
    return 0;
d1484 8
a1491 1
  return -1;
d1497 1
a1497 1
  struct in_addr dest, gateway, netmask;
d1499 8
a1506 11
  if (arg->argc == 1 && strcasecmp(arg->argv[0], "all") == 0)
    DeleteIfRoutes(0);
  else if (arg->argc > 0 && arg->argc < 4) {
    if (strcasecmp(arg->argv[0], "MYADDR") == 0)
      dest = IpcpInfo.want_ipaddr;
    else
      dest = GetIpAddr(arg->argv[0]);
    netmask.s_addr = INADDR_ANY;
    if (arg->argc > 1) {
      if (strcasecmp(arg->argv[1], "HISADDR") == 0)
	gateway = IpcpInfo.his_ipaddr;
d1508 5
a1512 11
	gateway = GetIpAddr(arg->argv[1]);
      if (arg->argc == 3) {
	if (inet_aton(arg->argv[2], &netmask) == 0) {
	  LogPrintf(LogWARN, "Bad netmask value.\n");
	  return -1;
	}
      }
    } else
      gateway.s_addr = INADDR_ANY;
    OsSetRoute(RTM_DELETE, dest, gateway, netmask);
  } else
@


1.1.1.1
log
@Import version 1.5 of ppp.

<sales>
This is a user-level ppp implementation that uses the
tun driver.  It was originally created by a Japanese
ISP.  It's now piled with features.  Check the man pages
for details.
</sales>

The sources are identical to the ones in FreeBSD, except
for the Makefile.

IP aliasing (NAT) is disabled, and can be enabled by simply
doing a ``make install'' of libalias, then rebuilding
ppp.  I'll create libalias as a port soon.
@
text
@@

