head	1.6;
access;
symbols
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	PPP1_5:1.1.1.1
	BRIAN:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	98.08.31.00.20.19;	author brian;	state dead;
branches;
next	1.5;

1.5
date	98.03.13.01.25.50;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	98.01.21.02.13.29;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.01.05.01.39.03;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	97.12.24.09.30.22;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	97.11.23.20.27.33;	author brian;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.11.23.20.27.33;	author brian;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@/*
 *			PPP Secret Key Module
 *
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
 *
 *   Copyright (C) 1994, Internet Initiative Japan, Inc. All rights reserverd.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $Id: auth.c,v 1.5 1998/03/13 01:25:50 brian Exp $
 *
 *	TODO:
 *		o Implement check against with registered IP addresses.
 */
#include <sys/param.h>
#include <netinet/in.h>

#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "command.h"
#include "mbuf.h"
#include "defs.h"
#include "timer.h"
#include "fsm.h"
#include "ipcp.h"
#include "loadalias.h"
#include "vars.h"
#include "auth.h"
#include "chat.h"
#include "systems.h"

void
LocalAuthInit()
{
  if (!(mode&MODE_DAEMON))
    /* We're allowed in interactive mode */
    VarLocalAuth = LOCAL_AUTH;
  else if (VarHaveLocalAuthKey)
    VarLocalAuth = *VarLocalAuthKey == '\0' ? LOCAL_AUTH : LOCAL_NO_AUTH;
  else
    switch (LocalAuthValidate(SECRETFILE, VarShortHost, "")) {
    case NOT_FOUND:
      VarLocalAuth = LOCAL_DENY;
      break;
    case VALID:
      VarLocalAuth = LOCAL_AUTH;
      break;
    case INVALID:
      VarLocalAuth = LOCAL_NO_AUTH;
      break;
    }
}

LOCAL_AUTH_VALID
LocalAuthValidate(const char *fname, const char *system, const char *key)
{
  FILE *fp;
  int n;
  char *vector[3];
  char buff[LINE_LEN];
  LOCAL_AUTH_VALID rc;

  rc = NOT_FOUND;		/* No system entry */
  fp = OpenSecret(fname);
  if (fp == NULL)
    return (rc);
  while (fgets(buff, sizeof buff, fp)) {
    if (buff[0] == '#')
      continue;
    buff[strlen(buff) - 1] = 0;
    memset(vector, '\0', sizeof vector);
    n = MakeArgs(buff, vector, VECSIZE(vector));
    if (n < 1)
      continue;
    if (strcmp(vector[0], system) == 0) {
      if ((vector[1] == (char *) NULL && (key == NULL || *key == '\0')) ||
          (vector[1] != (char *) NULL && strcmp(vector[1], key) == 0)) {
	rc = VALID;		/* Valid   */
      } else {
	rc = INVALID;		/* Invalid */
      }
      break;
    }
  }
  CloseSecret(fp);
  return (rc);
}

int
AuthValidate(const char *fname, const char *system, const char *key)
{
  FILE *fp;
  int n;
  char *vector[5];
  char buff[LINE_LEN];
  char passwd[100];

  fp = OpenSecret(fname);
  if (fp == NULL)
    return (0);
  while (fgets(buff, sizeof buff, fp)) {
    if (buff[0] == '#')
      continue;
    buff[strlen(buff) - 1] = 0;
    memset(vector, '\0', sizeof vector);
    n = MakeArgs(buff, vector, VECSIZE(vector));
    if (n < 2)
      continue;
    if (strcmp(vector[0], system) == 0) {
      ExpandString(vector[1], passwd, sizeof passwd, 0);
      if (strcmp(passwd, key) == 0) {
	CloseSecret(fp);
	if (n > 2 && !UseHisaddr(vector[2], 1))
	    return (0);
	IpcpInit();
	if (n > 3)
	  SetLabel(vector[3]);
	return (1);		/* Valid */
      }
    }
  }
  CloseSecret(fp);
  return (0);			/* Invalid */
}

char *
AuthGetSecret(const char *fname, const char *system, int len, int setaddr)
{
  FILE *fp;
  int n;
  char *vector[5];
  char buff[LINE_LEN];
  static char passwd[100];

  fp = OpenSecret(fname);
  if (fp == NULL)
    return (NULL);
  while (fgets(buff, sizeof buff, fp)) {
    if (buff[0] == '#')
      continue;
    buff[strlen(buff) - 1] = 0;
    memset(vector, '\0', sizeof vector);
    n = MakeArgs(buff, vector, VECSIZE(vector));
    if (n < 2)
      continue;
    if (strlen(vector[0]) == len && strncmp(vector[0], system, len) == 0) {
      ExpandString(vector[1], passwd, sizeof passwd, 0);
      if (setaddr) {
	memset(&DefHisAddress, '\0', sizeof DefHisAddress);
      }
      if (n > 2 && setaddr) {
	if (UseHisaddr(vector[2], 1))
          IpcpInit();
        else
          return NULL;
      }
      if (n > 3)
        SetLabel(vector[3]);
      return (passwd);
    }
  }
  CloseSecret(fp);
  return (NULL);		/* Invalid */
}

static void
AuthTimeout(void *vauthp)
{
  struct pppTimer *tp;
  struct authinfo *authp = (struct authinfo *)vauthp;

  tp = &authp->authtimer;
  StopTimer(tp);
  if (--authp->retry > 0) {
    StartTimer(tp);
    (authp->ChallengeFunc) (++authp->id);
  }
}

void
StartAuthChallenge(struct authinfo *authp)
{
  struct pppTimer *tp;

  tp = &authp->authtimer;
  StopTimer(tp);
  tp->func = AuthTimeout;
  tp->load = VarRetryTimeout * SECTICKS;
  tp->state = TIMER_STOPPED;
  tp->arg = (void *) authp;
  StartTimer(tp);
  authp->retry = 3;
  authp->id = 1;
  (authp->ChallengeFunc) (authp->id);
}

void
StopAuthTimer(struct authinfo *authp)
{
  StopTimer(&authp->authtimer);
}
@


1.5
log
@Add extraneous braces to stiffle warnings from gcc-2.8
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.4 1998/01/21 02:13:29 brian Exp $
@


1.4
log
@Remove unused #includes.
Make various bits static.
Remove unused variables.
Submitted by: eivind
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.3 1998/01/05 01:39:03 brian Exp $
d163 1
a163 1
      if (n > 2 && setaddr)
d168 1
@


1.3
log
@o Allow the use of HISADDR as the first arg to "add".
o Allow a forth argument in ppp.secret, specifying a new
  label.  This gives control over which section of
  ppp.link{up,down} is used based on the authenticated user.
o Support random address ranges in ppp.secret (not just in ppp.conf).
o Add a AUTHENTICATING INCOMING CONNECTIONS section to the man page.
o Add a bit more about DEFLATE in the man page.
o Fix the incorrect "you must specify a password in interactive
  mode" bit of the manual.
o Space things in the man page consistently.
o Be more precice about where you can use MYADDR, HISADDR and INTERFACE
  in the "add" command documentation.
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.2 1997/12/24 09:30:22 brian Exp $
a33 1
#include "log.h"
a36 1
#include "lcpproto.h"
a39 1
#include "filter.h"
a42 2
#include "iplist.h"
#include "route.h"
@


1.2
log
@Cosmetic (style):
  sizeof(var) -> sizeof var
  sizeof type -> sizeof(type)

Suggested by: J Wunsch <j@@uriah.heep.sax.de>
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.1.1.1 1997/11/23 20:27:33 brian Exp $
d46 2
d111 1
a111 1
  char *vector[4];
d130 2
a131 10
	memset(&DefHisAddress, '\0', sizeof DefHisAddress);
	n -= 2;
	if (n > 0) {
	  if (ParseAddr(n--, (char const *const *)(vector+2),
			&DefHisAddress.ipaddr,
			&DefHisAddress.mask,
			&DefHisAddress.width) == 0) {
	    return (0);		/* Invalid */
	  }
	}
d133 2
d148 1
a148 1
  char *vector[4];
d168 7
a174 9
      n -= 2;
      if (n > 0 && setaddr) {
	LogPrintf(LogDEBUG, "AuthGetSecret: n = %d, %s\n", n, vector[2]);
	if (ParseAddr(n--, (char const *const *)(vector+2),
		      &DefHisAddress.ipaddr,
		      &DefHisAddress.mask,
		      &DefHisAddress.width) != 0)
	  IpcpInit();
      }
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.24 1997/11/22 03:37:24 brian Exp $
d82 1
a82 1
  while (fgets(buff, sizeof(buff), fp)) {
d86 1
a86 1
    memset(vector, '\0', sizeof(vector));
d116 1
a116 1
  while (fgets(buff, sizeof(buff), fp)) {
d120 1
a120 1
    memset(vector, '\0', sizeof(vector));
d125 1
a125 1
      ExpandString(vector[1], passwd, sizeof(passwd), 0);
d128 1
a128 1
	memset(&DefHisAddress, '\0', sizeof(DefHisAddress));
d159 1
a159 1
  while (fgets(buff, sizeof(buff), fp)) {
d163 1
a163 1
    memset(vector, '\0', sizeof(vector));
d168 1
a168 1
      ExpandString(vector[1], passwd, sizeof(passwd), 0);
d170 1
a170 1
	memset(&DefHisAddress, '\0', sizeof(DefHisAddress));
@


1.1.1.1
log
@Import version 1.5 of ppp.

<sales>
This is a user-level ppp implementation that uses the
tun driver.  It was originally created by a Japanese
ISP.  It's now piled with features.  Check the man pages
for details.
</sales>

The sources are identical to the ones in FreeBSD, except
for the Makefile.

IP aliasing (NAT) is disabled, and can be enabled by simply
doing a ``make install'' of libalias, then rebuilding
ppp.  I'll create libalias as a port soon.
@
text
@@

