head	1.6;
access;
symbols
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	PPP1_5:1.1.1.1
	BRIAN:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	98.08.31.00.20.44;	author brian;	state dead;
branches;
next	1.5;

1.5
date	98.01.21.02.13.31;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	98.01.20.22.46.25;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.01.10.01.55.15;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	97.12.06.12.08.57;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	97.11.23.20.27.33;	author brian;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.11.23.20.27.33;	author brian;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@/*
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
 *
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $Id: fsm.h,v 1.5 1998/01/21 02:13:31 brian Exp $
 *
 *	TODO:
 */

/*
 *  State of machine
 */
#define	ST_INITIAL	0
#define	ST_STARTING	1
#define	ST_CLOSED	2
#define	ST_STOPPED	3
#define	ST_CLOSING	4
#define	ST_STOPPING	5
#define	ST_REQSENT	6
#define	ST_ACKRCVD	7
#define	ST_ACKSENT	8
#define	ST_OPENED	9

#define	ST_MAX		10
#define	ST_UNDEF	-1

#define	MODE_REQ	0
#define	MODE_NAK	1
#define	MODE_REJ	2
#define	MODE_NOP	3
#define	MODE_ACK	4	/* pseudo mode for ccp negotiations */

#define	OPEN_PASSIVE	-1

struct fsm {
  const char *name;		/* Name of protocol */
  u_short proto;		/* Protocol number */
  u_short max_code;
  int open_mode;
  int state;			/* State of the machine */
  u_char reqid;			/* Next request id */
  int restart;			/* Restart counter value */
  int maxconfig;

  struct pppTimer FsmTimer;	/* Restart Timer */
  struct pppTimer OpenTimer;	/* Delay before opening */

  /*
   * This timer times the ST_STOPPED state out after the given value
   * (specified via "set stopped ...").  Although this isn't specified in the
   * rfc, the rfc *does* say that "the application may use higher level
   * timers to avoid deadlock". The StoppedTimer takes effect when the other
   * side ABENDs rather than going into ST_ACKSENT (and sending the ACK),
   * causing ppp to time out and drop into ST_STOPPED.  At this point,
   * nothing will change this state :-(
   */
  struct pppTimer StoppedTimer;
  int LogLevel;

  void (*LayerUp) (struct fsm *);
  void (*LayerDown) (struct fsm *);
  void (*LayerStart) (struct fsm *);
  void (*LayerFinish) (struct fsm *);
  void (*InitRestartCounter) (struct fsm *);
  void (*SendConfigReq) (struct fsm *);
  void (*SendTerminateReq) (struct fsm *);
  void (*SendTerminateAck) (struct fsm *);
  void (*DecodeConfig) (u_char *, int, int);
};

struct fsmheader {
  u_char code;			/* Request code */
  u_char id;			/* Identification */
  u_short length;		/* Length of packet */
};

#define	CODE_CONFIGREQ	1
#define	CODE_CONFIGACK	2
#define	CODE_CONFIGNAK	3
#define	CODE_CONFIGREJ	4
#define	CODE_TERMREQ	5
#define	CODE_TERMACK	6
#define	CODE_CODEREJ	7
#define	CODE_PROTOREJ	8
#define	CODE_ECHOREQ	9	/* Used in LCP */
#define	CODE_ECHOREP	10	/* Used in LCP */
#define	CODE_DISCREQ	11
#define	CODE_IDENT	12	/* Used in LCP Extension */
#define	CODE_TIMEREM	13	/* Used in LCP Extension */
#define	CODE_RESETREQ	14	/* Used in CCP */
#define	CODE_RESETACK	15	/* Used in CCP */

struct fsmcodedesc {
  void (*action) (struct fsm *, struct fsmheader *, struct mbuf *);
  const char *name;
};

struct fsmconfig {
  u_char type;
  u_char length;
};

extern u_char AckBuff[200];
extern u_char NakBuff[200];
extern u_char RejBuff[100];
extern u_char ReqBuff[200];
extern u_char *ackp;
extern u_char *nakp;
extern u_char *rejp;

extern char const *StateNames[];

extern void FsmInit(struct fsm *);
extern void FsmOutput(struct fsm *, u_int, u_int, u_char *, int);
extern void FsmOpen(struct fsm *);
extern void FsmUp(struct fsm *);
extern void FsmDown(struct fsm *);
extern void FsmInput(struct fsm *, struct mbuf *);
extern void FsmClose(struct fsm *);
@


1.5
log
@Remove unused #includes.
Make various bits static.
Remove unused variables.
Submitted by: eivind
@
text
@d18 1
a18 1
 * $Id: fsm.h,v 1.4 1998/01/20 22:46:25 brian Exp $
@


1.4
log
@Allow an optional delay when specifying "set openmode active".
The delay defaults to 1 sec (as it always has) unless we've done
a ~p in interactive mode or we've actually detected a HDLC frame.
This is now cleanly implemented (via async timers) so that it is
possible for LCP to come up despite the delay if an LCP REQ is
received.

This will hopefully solve situations with slow servers or slirp
scenarios (where ECHO is left on the port for a second or so before
the peer enters packet mode).

Also, ~p in interactive mode no longer changes the value of the default
openmode delay and -dedicated mode enters packet mode in the right state
according to the value of openmode.
@
text
@d18 1
a18 1
 * $Id: fsm.h,v 1.3 1998/01/10 01:55:15 brian Exp $
a57 1
  int reqcode;			/* Request code sent */
@


1.3
log
@Implement Reset{Req,Ack} properly, as per rfc 1962.
(I completely mis-read the rfc last time 'round!)

This means:
  o Better CCP/WARN Reset diagnostics.
  o After we've sent a REQ and before we've received an ACK, we drop
    incoming compressed data and send another REQ.
  o Before sending an ACK, re-sequence all pending PRI_NORMAL data in
    the modem queue so that pending packets won't get to the peer
    *after* the ResetAck.
  o Send ACKs with the `identifier' from the REQ frame.
  o After we've received a correct ACK, duplicate ACKs are ok (and will
    reset our history).
  o Incorrect ACKs (not matching the last REQ) are moaned about and dropped.

Also,

  o Calculate the correct FCS after compressing a packet.  DEFLATE
    *may* produce an mbuf with more than a single link in the chain,
    but HdlcOutput didn't know how to calculate the FCS :-(
  o Make `struct fsm'::reqid a u_char, not an int.
    This fix will prevent us from sending id `255' 2,000,000,000 times
    before wrapping to `0' for another 2,000,000,000 sends :-/
  o Bump the version number a little (it should already have been at 1.6).

The end result:  DEFLATE now works over an unreliable link layer.
                 I can txfr a 1.5Mb kernel over a (rather bad) null-modem
                 cable at an average of 21679 bytes per second using rcp.
Repeat after me: Don't test compression using a loopback ppp/tcp setup as
                 we never lose packets and therefore never have to reset!
@
text
@d18 1
a18 1
 * $Id: fsm.h,v 1.2 1997/12/06 12:08:57 brian Exp $
d46 1
a46 2
#define	OPEN_ACTIVE	0
#define	OPEN_PASSIVE	1
d60 1
@


1.2
log
@Add DEFLATE capabilities (rfc1979).
@
text
@d18 1
a18 1
 * $Id: fsm.h,v 1.1.1.1 1997/11/23 20:27:33 brian Exp $
d55 1
a55 1
  int reqid;			/* Next request id */
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
 * $Id: fsm.h,v 1.12 1997/11/22 03:37:32 brian Exp $
d44 1
@


1.1.1.1
log
@Import version 1.5 of ppp.

<sales>
This is a user-level ppp implementation that uses the
tun driver.  It was originally created by a Japanese
ISP.  It's now piled with features.  Check the man pages
for details.
</sales>

The sources are identical to the ones in FreeBSD, except
for the Makefile.

IP aliasing (NAT) is disabled, and can be enabled by simply
doing a ``make install'' of libalias, then rebuilding
ppp.  I'll create libalias as a port soon.
@
text
@@
