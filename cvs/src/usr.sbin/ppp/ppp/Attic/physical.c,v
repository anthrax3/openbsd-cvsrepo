head	1.44;
access;
symbols
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.42.0.8
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.42.0.6
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.4
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.2
	OPENBSD_5_0:1.41.0.10
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.8
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.6
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.4
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.40.0.16
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.40.0.14
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.12
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.40.0.10
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.40.0.8
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.40.0.6
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.40.0.4
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.36.0.12
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.10
	OPENBSD_3_6_BASE:1.36
	OPENBSD_3_5:1.36.0.8
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.36.0.6
	OPENBSD_3_4_BASE:1.36
	OPENBSD_3_3:1.36.0.4
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.36.0.2
	OPENBSD_3_2_BASE:1.36
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.44
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.43;

1.43
date	2013.08.20.09.14.34;	author mpi;	state Exp;
branches;
next	1.42;

1.42
date	2012.01.23.09.13.16;	author nicm;	state Exp;
branches;
next	1.41;

1.41
date	2009.06.05.23.03.07;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.17.20.10.53;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.17.20.08.55;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.06.13.56.00;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.15.08.02.01;	author brian;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.27.23.19.38;	author brian;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.21.07.32.55;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.19.10.24.56;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.24.01.06.03;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.28.22.59.53;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	2000.10.09.22.50.57;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.14.22.02.50;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.18.00.02.11;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.15.10.26.37;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.15.10.08.51;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.03.21.52.57;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.27.00.21.09;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	99.08.05.10.32.14;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	99.06.11.13.29.29;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	99.06.05.21.36.00;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.06.02.00.46.55;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.06.01.19.08.52;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.05.24.16.39.19;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.05.18.01.37.51;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.05.13.19.29.37;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.05.12.10.03.52;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.09.20.14.46;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.08.11.06.38;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.04.27.00.21.25;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.22.42;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.01.10.02.23.22;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.25;	author brian;	state Exp;
branches;
next	;


desc
@@


1.44
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*
 * Written by Eivind Eklund <eivind@@yes.no>
 *    for Yes Interactive
 *
 * Copyright (C) 1998, Yes Interactive.  All rights reserved.
 *
 * Redistribution and use in any form is permitted.  Redistribution in
 * source form should include the above copyright and this set of
 * conditions, because large sections american law seems to have been
 * created by a bunch of jerks on drugs that are now illegal, forcing
 * me to include this copyright-stuff instead of placing this in the
 * public domain.  The name of of 'Yes Interactive' or 'Eivind Eklund'
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  $OpenBSD: physical.c,v 1.43 2013/08/20 09:14:34 mpi Exp $
 *
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/tty.h>	/* TIOCOUTQ */
#include <sys/uio.h>
#include <sysexits.h>
#include <time.h>
#include <unistd.h>
#include <utmp.h>
#if defined(__OpenBSD__) || defined(__NetBSD__)
#include <sys/ioctl.h>
#include <util.h>
#else
#include <libutil.h>
#endif

#include "layer.h"
#ifndef NONAT
#include "nat_cmd.h"
#endif
#include "proto.h"
#include "acf.h"
#include "vjcomp.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "id.h"
#include "timer.h"
#include "fsm.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "throughput.h"
#include "sync.h"
#include "async.h"
#include "iplist.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "descriptor.h"
#include "ccp.h"
#include "link.h"
#include "physical.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "prompt.h"
#include "chat.h"
#include "auth.h"
#include "main.h"
#include "chap.h"
#include "cbcp.h"
#include "datalink.h"
#include "tcp.h"
#include "udp.h"
#include "exec.h"
#include "tty.h"
#ifndef NOI4B
#include "i4b.h"
#endif
#ifndef NONETGRAPH
#include "ether.h"
#include "netgraph.h"
#endif
#include "tcpmss.h"

#define PPPOTCPLINE "ppp"

static int physical_DescriptorWrite(struct fdescriptor *, struct bundle *,
                                    const fd_set *);

static int
physical_DeviceSize(void)
{
  return sizeof(struct device);
}

struct {
  struct device *(*create)(struct physical *);
  struct device *(*iov2device)(int, struct physical *, struct iovec *,
                               int *, int, int *, int *);
  int (*DeviceSize)(void);
} devices[] = {
#ifndef NOI4B
  /*
   * This must come before ``tty'' so that the probe routine is
   * able to identify it as a more specific type of terminal device.
   */
  { i4b_Create, i4b_iov2device, i4b_DeviceSize },
#endif
  { tty_Create, tty_iov2device, tty_DeviceSize },
#ifndef NONETGRAPH
  /*
   * This must come before ``udp'' so that the probe routine is
   * able to identify it as a more specific type of SOCK_DGRAM.
   */
  { ether_Create, ether_iov2device, ether_DeviceSize },
#ifdef EXPERIMENTAL_NETGRAPH
  { ng_Create, ng_iov2device, ng_DeviceSize },
#endif
#endif
  { tcp_Create, tcp_iov2device, tcp_DeviceSize },
  { udp_Create, udp_iov2device, udp_DeviceSize },
  { exec_Create, exec_iov2device, exec_DeviceSize }
};

#define NDEVICES (sizeof devices / sizeof devices[0])

static int
physical_UpdateSet(struct fdescriptor *d, fd_set *r, fd_set *w, fd_set *e,
                   int *n)
{
  return physical_doUpdateSet(d, r, w, e, n, 0);
}

void
physical_SetDescriptor(struct physical *p)
{
  p->desc.type = PHYSICAL_DESCRIPTOR;
  p->desc.UpdateSet = physical_UpdateSet;
  p->desc.IsSet = physical_IsSet;
  p->desc.Read = physical_DescriptorRead;
  p->desc.Write = physical_DescriptorWrite;
}

struct physical *
physical_Create(struct datalink *dl, int type)
{
  struct physical *p;

  p = (struct physical *)malloc(sizeof(struct physical));
  if (!p)
    return NULL;

  p->link.type = PHYSICAL_LINK;
  p->link.name = dl->name;
  p->link.len = sizeof *p;

  /* The sample period is fixed - see physical2iov() & iov2physical() */
  throughput_init(&p->link.stats.total, SAMPLE_PERIOD);
  p->link.stats.parent = dl->bundle->ncp.mp.active ?
    &dl->bundle->ncp.mp.link.stats.total : NULL;
  p->link.stats.gather = 1;

  memset(p->link.Queue, '\0', sizeof p->link.Queue);
  memset(p->link.proto_in, '\0', sizeof p->link.proto_in);
  memset(p->link.proto_out, '\0', sizeof p->link.proto_out);
  link_EmptyStack(&p->link);

  p->handler = NULL;
  physical_SetDescriptor(p);
  p->type = type;

  hdlc_Init(&p->hdlc, &p->link.lcp);
  async_Init(&p->async);

  p->fd = -1;
  p->out = NULL;
  p->connect_count = 0;
  p->dl = dl;
  p->input.sz = 0;
  *p->name.full = '\0';
  p->name.base = p->name.full;

  p->Utmp = 0;
  p->session_owner = (pid_t)-1;

  p->cfg.rts_cts = MODEM_CTSRTS;
  p->cfg.speed = MODEM_SPEED;
  p->cfg.parity = CS8;
  memcpy(p->cfg.devlist, MODEM_LIST, sizeof MODEM_LIST);
  p->cfg.ndev = NMODEMS;
  p->cfg.cd.necessity = CD_DEFAULT;
  p->cfg.cd.delay = 0;		/* reconfigured or device specific default */

  lcp_Init(&p->link.lcp, dl->bundle, &p->link, &dl->fsmp);
  ccp_Init(&p->link.ccp, dl->bundle, &p->link, &dl->fsmp);

  return p;
}

static const struct parity {
  const char *name;
  const char *name1;
  int set;
} validparity[] = {
  { "even", "P_EVEN", CS7 | PARENB },
  { "odd", "P_ODD", CS7 | PARENB | PARODD },
  { "none", "P_ZERO", CS8 },
  { NULL, 0 },
};

static int
GetParityValue(const char *str)
{
  const struct parity *pp;

  for (pp = validparity; pp->name; pp++) {
    if (strcasecmp(pp->name, str) == 0 ||
	strcasecmp(pp->name1, str) == 0) {
      return pp->set;
    }
  }
  return (-1);
}

int
physical_SetParity(struct physical *p, const char *str)
{
  struct termios rstio;
  int val;

  val = GetParityValue(str);
  if (val > 0) {
    p->cfg.parity = val;
    if (p->fd >= 0) {
      tcgetattr(p->fd, &rstio);
      rstio.c_cflag &= ~(CSIZE | PARODD | PARENB);
      rstio.c_cflag |= val;
      tcsetattr(p->fd, TCSADRAIN, &rstio);
    }
    return 0;
  }
  log_Printf(LogWARN, "%s: %s: Invalid parity\n", p->link.name, str);
  return -1;
}

int
physical_GetSpeed(struct physical *p)
{
  if (p->handler && p->handler->speed)
    return (*p->handler->speed)(p);

  return 0;
}

int
physical_SetSpeed(struct physical *p, int speed)
{
  if (IntToSpeed(speed) != B0) {
      p->cfg.speed = speed;
      return 1;
  }

  return 0;
}

int
physical_Raw(struct physical *p)
{
  if (p->handler && p->handler->raw)
    return (*p->handler->raw)(p);

  return 1;
}

void
physical_Offline(struct physical *p)
{
  if (p->handler && p->handler->offline)
    (*p->handler->offline)(p);
  log_Printf(LogPHASE, "%s: Disconnected!\n", p->link.name);
}

static int
physical_Lock(struct physical *p)
{
  int res;

  if (*p->name.full == '/' && p->type != PHYS_DIRECT &&
      (res = ID0uu_lock(p->name.base)) != UU_LOCK_OK) {
    if (res == UU_LOCK_INUSE)
      log_Printf(LogPHASE, "%s: %s is in use\n", p->link.name, p->name.full);
    else
      log_Printf(LogPHASE, "%s: %s is in use: uu_lock: %s\n",
                 p->link.name, p->name.full, uu_lockerr(res));
    return 0;
  }

  return 1;
}

static void
physical_Unlock(struct physical *p)
{
  if (*p->name.full == '/' && p->type != PHYS_DIRECT &&
      ID0uu_unlock(p->name.base) == -1)
    log_Printf(LogALERT, "%s: Can't uu_unlock %s\n", p->link.name,
               p->name.base);
}

void
physical_Close(struct physical *p)
{
  int newsid;
  char fn[PATH_MAX];

  if (p->fd < 0)
    return;

  log_Printf(LogDEBUG, "%s: Close\n", p->link.name);

  if (p->handler && p->handler->cooked)
    (*p->handler->cooked)(p);

  physical_StopDeviceTimer(p);
  if (p->Utmp) {
    if (p->handler && (p->handler->type == TCP_DEVICE ||
                       p->handler->type == UDP_DEVICE))
      /* Careful - we logged in on line ``ppp'' with IP as our host */
      ID0logout(PPPOTCPLINE, 1);
    else
      ID0logout(p->name.base, 0);
    p->Utmp = 0;
  }
  newsid = tcgetpgrp(p->fd) == getpgrp();
  close(p->fd);
  p->fd = -1;
  log_SetTtyCommandMode(p->dl);

  throughput_stop(&p->link.stats.total);
  throughput_log(&p->link.stats.total, LogPHASE, p->link.name);

  if (p->session_owner != (pid_t)-1) {
    log_Printf(LogPHASE, "%s: HUPing %ld\n", p->link.name,
               (long)p->session_owner);
    ID0kill(p->session_owner, SIGHUP);
    p->session_owner = (pid_t)-1;
  }

  if (newsid)
    bundle_setsid(p->dl->bundle, 0);

  if (*p->name.full == '/') {
    snprintf(fn, sizeof fn, "%s%s.if", _PATH_VARRUN, p->name.base);
#ifndef RELEASE_CRUNCH
    if (ID0unlink(fn) == -1)
      log_Printf(LogALERT, "%s: Can't remove %s: %s\n",
                 p->link.name, fn, strerror(errno));
#else
    ID0unlink(fn);
#endif
  }
  physical_Unlock(p);
  if (p->handler && p->handler->destroy)
    (*p->handler->destroy)(p);
  p->handler = NULL;
  p->name.base = p->name.full;
  *p->name.full = '\0';
}

void
physical_Destroy(struct physical *p)
{
  physical_Close(p);
  throughput_destroy(&p->link.stats.total);
  free(p);
}

static int
physical_DescriptorWrite(struct fdescriptor *d, struct bundle *bundle,
                         const fd_set *fdset)
{
  struct physical *p = descriptor2physical(d);
  int nw, result = 0;

  if (p->out == NULL)
    p->out = link_Dequeue(&p->link);

  if (p->out) {
    nw = physical_Write(p, MBUF_CTOP(p->out), p->out->m_len);
    log_Printf(LogDEBUG, "%s: DescriptorWrite: wrote %d(%lu) to %d\n",
               p->link.name, nw, (unsigned long)p->out->m_len, p->fd);
    if (nw > 0) {
      p->out->m_len -= nw;
      p->out->m_offset += nw;
      if (p->out->m_len == 0)
	p->out = m_free(p->out);
      result = 1;
    } else if (nw < 0) {
      if (errno == EAGAIN)
        result = 1;
      else if (errno != ENOBUFS) {
	log_Printf(LogPHASE, "%s: write (fd %d, len %zd): %s\n", p->link.name,
                   p->fd, p->out->m_len, strerror(errno));
        datalink_Down(p->dl, CLOSE_NORMAL);
      }
    }
    /* else we shouldn't really have been called !  select() is broken ! */
  }

  return result;
}

int
physical_ShowStatus(struct cmdargs const *arg)
{
  struct physical *p = arg->cx->physical;
  struct cd *cd;
  const char *dev;
  int n, slot;

  prompt_Printf(arg->prompt, "Name: %s\n", p->link.name);
  prompt_Printf(arg->prompt, " State:           ");
  if (p->fd < 0)
    prompt_Printf(arg->prompt, "closed\n");
  else {
    slot = physical_Slot(p);
    if (p->handler && p->handler->openinfo) {
      if (slot == -1)
        prompt_Printf(arg->prompt, "open (%s)\n", (*p->handler->openinfo)(p));
      else
        prompt_Printf(arg->prompt, "open (%s, port %d)\n",
                      (*p->handler->openinfo)(p), slot);
    } else if (slot == -1)
      prompt_Printf(arg->prompt, "open\n");
    else
      prompt_Printf(arg->prompt, "open (port %d)\n", slot);
  }

  prompt_Printf(arg->prompt, " Device:          %s",
                *p->name.full ?  p->name.full :
                p->type == PHYS_DIRECT ? "unknown" : "N/A");
  if (p->session_owner != (pid_t)-1)
    prompt_Printf(arg->prompt, " (session owner: %ld)", (long)p->session_owner);

  prompt_Printf(arg->prompt, "\n Link Type:       %s\n", mode2Nam(p->type));
  prompt_Printf(arg->prompt, " Connect Count:   %d\n", p->connect_count);
#ifdef TIOCOUTQ
  if (p->fd >= 0 && ioctl(p->fd, TIOCOUTQ, &n) >= 0)
      prompt_Printf(arg->prompt, " Physical outq:   %d\n", n);
#endif

  prompt_Printf(arg->prompt, " Queued Packets:  %lu\n",
                (u_long)link_QueueLen(&p->link));
  prompt_Printf(arg->prompt, " Phone Number:    %s\n", arg->cx->phone.chosen);

  prompt_Printf(arg->prompt, "\nDefaults:\n");

  prompt_Printf(arg->prompt, " Device List:     ");
  dev = p->cfg.devlist;
  for (n = 0; n < p->cfg.ndev; n++) {
    if (n)
      prompt_Printf(arg->prompt, ", ");
    prompt_Printf(arg->prompt, "\"%s\"", dev);
    dev += strlen(dev) + 1;
  }

  prompt_Printf(arg->prompt, "\n Characteristics: ");
  if (physical_IsSync(arg->cx->physical))
    prompt_Printf(arg->prompt, "sync");
  else
    prompt_Printf(arg->prompt, "%dbps", p->cfg.speed);

  switch (p->cfg.parity & CSIZE) {
  case CS7:
    prompt_Printf(arg->prompt, ", cs7");
    break;
  case CS8:
    prompt_Printf(arg->prompt, ", cs8");
    break;
  }
  if (p->cfg.parity & PARENB) {
    if (p->cfg.parity & PARODD)
      prompt_Printf(arg->prompt, ", odd parity");
    else
      prompt_Printf(arg->prompt, ", even parity");
  } else
    prompt_Printf(arg->prompt, ", no parity");

  prompt_Printf(arg->prompt, ", CTS/RTS %s\n", (p->cfg.rts_cts ? "on" : "off"));

  prompt_Printf(arg->prompt, " CD check delay:  ");
  cd = p->handler ? &p->handler->cd : &p->cfg.cd;
  if (cd->necessity == CD_NOTREQUIRED)
    prompt_Printf(arg->prompt, "no cd");
  else if (p->cfg.cd.necessity == CD_DEFAULT) {
    prompt_Printf(arg->prompt, "device specific");
  } else {
    prompt_Printf(arg->prompt, "%d second%s", p->cfg.cd.delay,
                  p->cfg.cd.delay == 1 ? "" : "s");
    if (p->cfg.cd.necessity == CD_REQUIRED)
      prompt_Printf(arg->prompt, " (required!)");
  }
  prompt_Printf(arg->prompt, "\n\n");

  throughput_disp(&p->link.stats.total, arg->prompt);

  return 0;
}

void
physical_DescriptorRead(struct fdescriptor *d, struct bundle *bundle,
                     const fd_set *fdset)
{
  struct physical *p = descriptor2physical(d);
  u_char *rbuff;
  int n, found;

  rbuff = p->input.buf + p->input.sz;

  /* something to read */
  n = physical_Read(p, rbuff, sizeof p->input.buf - p->input.sz);
  log_Printf(LogDEBUG, "%s: DescriptorRead: read %d/%d from %d\n",
             p->link.name, n, (int)(sizeof p->input.buf - p->input.sz), p->fd);
  if (n <= 0) {
    if (n < 0)
      log_Printf(LogPHASE, "%s: read (%d): %s\n", p->link.name, p->fd,
                 strerror(errno));
    else
      log_Printf(LogPHASE, "%s: read (%d): Got zero bytes\n",
                 p->link.name, p->fd);
    datalink_Down(p->dl, CLOSE_NORMAL);
    return;
  }

  rbuff -= p->input.sz;
  n += p->input.sz;

  if (p->link.lcp.fsm.state <= ST_CLOSED) {
    if (p->type != PHYS_DEDICATED) {
      found = hdlc_Detect((u_char const **)&rbuff, n, physical_IsSync(p));
      if (rbuff != p->input.buf)
        log_WritePrompts(p->dl, "%.*s", (int)(rbuff - p->input.buf),
                         p->input.buf);
      p->input.sz = n - (rbuff - p->input.buf);

      if (found) {
        /* LCP packet is detected. Turn ourselves into packet mode */
        log_Printf(LogPHASE, "%s: PPP packet detected, coming up\n",
                   p->link.name);
        log_SetTtyCommandMode(p->dl);
        datalink_Up(p->dl, 0, 1);
        link_PullPacket(&p->link, rbuff, p->input.sz, bundle);
        p->input.sz = 0;
      } else
        bcopy(rbuff, p->input.buf, p->input.sz);
    } else
      /* In -dedicated mode, we just discard input until LCP is started */
      p->input.sz = 0;
  } else if (n > 0)
    link_PullPacket(&p->link, rbuff, n, bundle);
}

struct physical *
iov2physical(struct datalink *dl, struct iovec *iov, int *niov, int maxiov,
             int fd, int *auxfd, int *nauxfd)
{
  struct physical *p;
  int h, type;

  p = (struct physical *)iov[(*niov)++].iov_base;
  p->link.name = dl->name;
  memset(p->link.Queue, '\0', sizeof p->link.Queue);

  p->desc.UpdateSet = physical_UpdateSet;
  p->desc.IsSet = physical_IsSet;
  p->desc.Read = physical_DescriptorRead;
  p->desc.Write = physical_DescriptorWrite;
  p->type = PHYS_DIRECT;
  p->dl = dl;
  p->out = NULL;
  p->connect_count = 1;

  physical_SetDevice(p, p->name.full);

  p->link.lcp.fsm.bundle = dl->bundle;
  p->link.lcp.fsm.link = &p->link;
  memset(&p->link.lcp.fsm.FsmTimer, '\0', sizeof p->link.lcp.fsm.FsmTimer);
  memset(&p->link.lcp.fsm.OpenTimer, '\0', sizeof p->link.lcp.fsm.OpenTimer);
  memset(&p->link.lcp.fsm.StoppedTimer, '\0',
         sizeof p->link.lcp.fsm.StoppedTimer);
  p->link.lcp.fsm.parent = &dl->fsmp;
  lcp_SetupCallbacks(&p->link.lcp);

  p->link.ccp.fsm.bundle = dl->bundle;
  p->link.ccp.fsm.link = &p->link;
  /* Our in.state & out.state are NULL (no link-level ccp yet) */
  memset(&p->link.ccp.fsm.FsmTimer, '\0', sizeof p->link.ccp.fsm.FsmTimer);
  memset(&p->link.ccp.fsm.OpenTimer, '\0', sizeof p->link.ccp.fsm.OpenTimer);
  memset(&p->link.ccp.fsm.StoppedTimer, '\0',
         sizeof p->link.ccp.fsm.StoppedTimer);
  p->link.ccp.fsm.parent = &dl->fsmp;
  ccp_SetupCallbacks(&p->link.ccp);

  p->hdlc.lqm.owner = &p->link.lcp;
  p->hdlc.ReportTimer.state = TIMER_STOPPED;
  p->hdlc.lqm.timer.state = TIMER_STOPPED;

  p->fd = fd;
  p->link.stats.total.in.SampleOctets = (long long *)iov[(*niov)++].iov_base;
  p->link.stats.total.out.SampleOctets = (long long *)iov[(*niov)++].iov_base;
  p->link.stats.parent = dl->bundle->ncp.mp.active ?
    &dl->bundle->ncp.mp.link.stats.total : NULL;
  p->link.stats.gather = 1;

  type = (long)p->handler;
  p->handler = NULL;
  for (h = 0; h < NDEVICES && p->handler == NULL; h++)
    p->handler = (*devices[h].iov2device)(type, p, iov, niov, maxiov,
                                          auxfd, nauxfd);
  if (p->handler == NULL) {
    log_Printf(LogPHASE, "%s: Unknown link type\n", p->link.name);
    free(iov[(*niov)++].iov_base);
    physical_SetupStack(p, "unknown", PHYSICAL_NOFORCE);
  } else
    log_Printf(LogPHASE, "%s: Device %s, link type is %s\n",
               p->link.name, p->name.full, p->handler->name);

  if (p->hdlc.lqm.method && p->hdlc.lqm.timer.load)
    lqr_reStart(&p->link.lcp);
  hdlc_StartTimer(&p->hdlc);

  throughput_restart(&p->link.stats.total, "physical throughput",
                     Enabled(dl->bundle, OPT_THROUGHPUT));

  return p;
}

int
physical_MaxDeviceSize()
{
  int biggest, sz, n;

  biggest = sizeof(struct device);
  for (sz = n = 0; n < NDEVICES; n++)
    if (devices[n].DeviceSize) {
      sz = (*devices[n].DeviceSize)();
      if (biggest < sz)
        biggest = sz;
    }

  return biggest;
}

int
physical2iov(struct physical *p, struct iovec *iov, int *niov, int maxiov,
             int *auxfd, int *nauxfd)
{
  struct device *h;
  int sz;

  h = NULL;
  if (p) {
    hdlc_StopTimer(&p->hdlc);
    lqr_StopTimer(p);
    timer_Stop(&p->link.lcp.fsm.FsmTimer);
    timer_Stop(&p->link.ccp.fsm.FsmTimer);
    timer_Stop(&p->link.lcp.fsm.OpenTimer);
    timer_Stop(&p->link.ccp.fsm.OpenTimer);
    timer_Stop(&p->link.lcp.fsm.StoppedTimer);
    timer_Stop(&p->link.ccp.fsm.StoppedTimer);
    if (p->handler) {
      h = p->handler;
      p->handler = (struct device *)(long)p->handler->type;
    }

    if (Enabled(p->dl->bundle, OPT_KEEPSESSION) ||
        tcgetpgrp(p->fd) == getpgrp())
      p->session_owner = getpid();      /* So I'll eventually get HUP'd */
    else
      p->session_owner = (pid_t)-1;
    timer_Stop(&p->link.stats.total.Timer);
  }

  if (*niov + 2 >= maxiov) {
    log_Printf(LogERROR, "physical2iov: No room for physical + throughput"
               " + device !\n");
    if (p)
      free(p);
    return -1;
  }

  iov[*niov].iov_base = (void *)p;
  iov[*niov].iov_len = sizeof *p;
  (*niov)++;

  iov[*niov].iov_base = p ? (void *)p->link.stats.total.in.SampleOctets : NULL;
  iov[*niov].iov_len = SAMPLE_PERIOD * sizeof(long long);
  (*niov)++;
  iov[*niov].iov_base = p ? (void *)p->link.stats.total.out.SampleOctets : NULL;
  iov[*niov].iov_len = SAMPLE_PERIOD * sizeof(long long);
  (*niov)++;

  sz = physical_MaxDeviceSize();
  if (p) {
    if (h && h->device2iov)
      (*h->device2iov)(h, iov, niov, maxiov, auxfd, nauxfd);
    else {
      if ((iov[*niov].iov_base = malloc(sz)) == NULL) {
	log_Printf(LogALERT, "physical2iov: Out of memory (%d bytes)\n", sz);
	AbortProgram(EX_OSERR);
      }
      if (h)
        memcpy(iov[*niov].iov_base, h, sizeof *h);
      iov[*niov].iov_len = sz;
      (*niov)++;
    }
  } else {
    iov[*niov].iov_base = NULL;
    iov[*niov].iov_len = sz;
    (*niov)++;
  }

  return p ? p->fd : 0;
}

const char *
physical_LockedDevice(struct physical *p)
{
  if (p->fd >= 0 && *p->name.full == '/' && p->type != PHYS_DIRECT)
    return p->name.base;

  return NULL;
}

void
physical_ChangedPid(struct physical *p, pid_t newpid)
{
  if (physical_LockedDevice(p)) {
    int res;

    if ((res = ID0uu_lock_txfr(p->name.base, newpid)) != UU_LOCK_OK)
      log_Printf(LogPHASE, "uu_lock_txfr: %s\n", uu_lockerr(res));
  }
}

int
physical_IsSync(struct physical *p)
{
   return p->cfg.speed == 0;
}

u_short
physical_DeviceMTU(struct physical *p)
{
  return p->handler ? p->handler->mtu : 0;
}

const char *physical_GetDevice(struct physical *p)
{
   return p->name.full;
}

void
physical_SetDeviceList(struct physical *p, int argc, const char *const *argv)
{
  int f, pos;

  p->cfg.devlist[sizeof p->cfg.devlist - 1] = '\0';
  for (f = 0, pos = 0; f < argc && pos < sizeof p->cfg.devlist - 1; f++) {
    if (pos)
      p->cfg.devlist[pos++] = '\0';
    strncpy(p->cfg.devlist + pos, argv[f], sizeof p->cfg.devlist - pos - 1);
    pos += strlen(p->cfg.devlist + pos);
  }
  p->cfg.ndev = f;
}

void
physical_SetSync(struct physical *p)
{
   p->cfg.speed = 0;
}

int
physical_SetRtsCts(struct physical *p, int enable)
{
   p->cfg.rts_cts = enable ? 1 : 0;
   return 1;
}

ssize_t
physical_Read(struct physical *p, void *buf, size_t nbytes)
{
  ssize_t ret;

  if (p->handler && p->handler->read)
    ret = (*p->handler->read)(p, buf, nbytes);
  else
    ret = read(p->fd, buf, nbytes);

  log_DumpBuff(LogPHYSICAL, "read", buf, ret);

  return ret;
}

ssize_t
physical_Write(struct physical *p, const void *buf, size_t nbytes)
{
  log_DumpBuff(LogPHYSICAL, "write", buf, nbytes);

  if (p->handler && p->handler->write)
    return (*p->handler->write)(p, buf, nbytes);

  return write(p->fd, buf, nbytes);
}

int
physical_doUpdateSet(struct fdescriptor *d, fd_set *r, fd_set *w, fd_set *e,
                     int *n, int force)
{
  struct physical *p = descriptor2physical(d);
  int sets;

  sets = 0;
  if (p->fd >= 0) {
    if (r) {
      FD_SET(p->fd, r);
      log_Printf(LogTIMER, "%s: fdset(r) %d\n", p->link.name, p->fd);
      sets++;
    }
    if (e) {
      FD_SET(p->fd, e);
      log_Printf(LogTIMER, "%s: fdset(e) %d\n", p->link.name, p->fd);
      sets++;
    }
    if (w && (force || link_QueueLen(&p->link) || p->out)) {
      FD_SET(p->fd, w);
      log_Printf(LogTIMER, "%s: fdset(w) %d\n", p->link.name, p->fd);
      sets++;
    }
    if (sets && *n < p->fd + 1)
      *n = p->fd + 1;
  }

  return sets;
}

int
physical_RemoveFromSet(struct physical *p, fd_set *r, fd_set *w, fd_set *e)
{
  if (p->handler && p->handler->removefromset)
    return (*p->handler->removefromset)(p, r, w, e);
  else {
    int sets;

    sets = 0;
    if (p->fd >= 0) {
      if (r && FD_ISSET(p->fd, r)) {
        FD_CLR(p->fd, r);
        log_Printf(LogTIMER, "%s: fdunset(r) %d\n", p->link.name, p->fd);
        sets++;
      }
      if (e && FD_ISSET(p->fd, e)) {
        FD_CLR(p->fd, e);
        log_Printf(LogTIMER, "%s: fdunset(e) %d\n", p->link.name, p->fd);
        sets++;
      }
      if (w && FD_ISSET(p->fd, w)) {
        FD_CLR(p->fd, w);
        log_Printf(LogTIMER, "%s: fdunset(w) %d\n", p->link.name, p->fd);
        sets++;
      }
    }

    return sets;
  }
}

int
physical_IsSet(struct fdescriptor *d, const fd_set *fdset)
{
  struct physical *p = descriptor2physical(d);
  return p->fd >= 0 && FD_ISSET(p->fd, fdset);
}

void
physical_Login(struct physical *p, const char *name)
{
  if (p->type == PHYS_DIRECT && *p->name.base && !p->Utmp) {
    struct utmp ut;
    const char *connstr;
    char *colon;

    memset(&ut, 0, sizeof ut);
    time(&ut.ut_time);
    strncpy(ut.ut_name, name, sizeof ut.ut_name);
    if (p->handler && (p->handler->type == TCP_DEVICE ||
                       p->handler->type == UDP_DEVICE)) {
      strncpy(ut.ut_line, PPPOTCPLINE, sizeof ut.ut_line);
      strncpy(ut.ut_host, p->name.base, sizeof ut.ut_host);
      colon = memchr(ut.ut_host, ':', sizeof ut.ut_host);
      if (colon)
        *colon = '\0';
    } else
      strncpy(ut.ut_line, p->name.base, sizeof ut.ut_line);
    if ((connstr = getenv("CONNECT")))
      /* mgetty sets this to the connection speed */
      strncpy(ut.ut_host, connstr, sizeof ut.ut_host);
    ID0login(&ut);
    p->Utmp = ut.ut_time;
  }
}

int
physical_SetMode(struct physical *p, int mode)
{
  if ((p->type & (PHYS_DIRECT|PHYS_DEDICATED) ||
       mode & (PHYS_DIRECT|PHYS_DEDICATED)) &&
      (!(p->type & PHYS_DIRECT) || !(mode & PHYS_BACKGROUND))) {
    /* Note:  The -direct -> -background is for callback ! */
    log_Printf(LogWARN, "%s: Cannot change mode %s to %s\n", p->link.name,
               mode2Nam(p->type), mode2Nam(mode));
    return 0;
  }
  p->type = mode;
  return 1;
}

void
physical_DeleteQueue(struct physical *p)
{
  if (p->out) {
    m_freem(p->out);
    p->out = NULL;
  }
  link_DeleteQueue(&p->link);
}

void
physical_SetDevice(struct physical *p, const char *name)
{
  int len = strlen(_PATH_DEV);

  if (name != p->name.full) {
    strncpy(p->name.full, name, sizeof p->name.full - 1);
    p->name.full[sizeof p->name.full - 1] = '\0';
  }
  p->name.base = *p->name.full == '!' ?  p->name.full + 1 :
                 strncmp(p->name.full, _PATH_DEV, len) ?
                 p->name.full : p->name.full + len;
}

static void
physical_Found(struct physical *p)
{
  FILE *lockfile;
  char fn[PATH_MAX];

  if (*p->name.full == '/') {
    snprintf(fn, sizeof fn, "%s%s.if", _PATH_VARRUN, p->name.base);
    lockfile = ID0fopen(fn, "w");
    if (lockfile != NULL) {
      fprintf(lockfile, "%s%d\n", TUN_NAME, p->dl->bundle->unit);
      fclose(lockfile);
    }
#ifndef RELEASE_CRUNCH
    else
      log_Printf(LogALERT, "%s: Can't create %s: %s\n",
                 p->link.name, fn, strerror(errno));
#endif
  }

  throughput_start(&p->link.stats.total, "physical throughput",
                   Enabled(p->dl->bundle, OPT_THROUGHPUT));
  p->connect_count++;
  p->input.sz = 0;

  log_Printf(LogPHASE, "%s: Connected!\n", p->link.name);
}

int
physical_Open(struct physical *p, struct bundle *bundle)
{
  int devno, h, wasfd, err;
  char *dev;

  if (p->fd >= 0)
    log_Printf(LogDEBUG, "%s: Open: Modem is already open!\n", p->link.name);
    /* We're going back into "term" mode */
  else if (p->type == PHYS_DIRECT) {
    physical_SetDevice(p, "");
    p->fd = STDIN_FILENO;
    for (h = 0; h < NDEVICES && p->handler == NULL && p->fd >= 0; h++)
      p->handler = (*devices[h].create)(p);
    if (p->fd >= 0) {
      if (p->handler == NULL) {
        physical_SetupStack(p, "unknown", PHYSICAL_NOFORCE);
        log_Printf(LogDEBUG, "%s: stdin is unidentified\n", p->link.name);
      }
      physical_Found(p);
    }
  } else {
    dev = p->cfg.devlist;
    devno = 0;
    while (devno < p->cfg.ndev && p->fd < 0) {
      physical_SetDevice(p, dev);
      if (physical_Lock(p)) {
        err = 0;

        if (*p->name.full == '/') {
          p->fd = ID0open(p->name.full, O_RDWR | O_NONBLOCK);
          if (p->fd < 0)
            err = errno;
        }

        wasfd = p->fd;
        for (h = 0; h < NDEVICES && p->handler == NULL; h++)
          if ((p->handler = (*devices[h].create)(p)) == NULL && wasfd != p->fd)
            break;

        if (p->fd < 0) {
          if (h == NDEVICES) {
            if (err)
	      log_Printf(LogWARN, "%s: %s: %s\n", p->link.name, p->name.full,
                         strerror(errno));
            else
	      log_Printf(LogWARN, "%s: Device (%s) must begin with a '/',"
                         " a '!' or contain at least one ':'\n", p->link.name,
                         p->name.full);
          }
          physical_Unlock(p);
        } else
          physical_Found(p);
      }
      dev += strlen(dev) + 1;
      devno++;
    }
  }

  return p->fd;
}

void
physical_SetupStack(struct physical *p, const char *who, int how)
{
  link_EmptyStack(&p->link);
  if (how == PHYSICAL_FORCE_SYNC || how == PHYSICAL_FORCE_SYNCNOACF ||
      (how == PHYSICAL_NOFORCE && physical_IsSync(p)))
    link_Stack(&p->link, &synclayer);
  else {
    link_Stack(&p->link, &asynclayer);
    link_Stack(&p->link, &hdlclayer);
  }
  if (how != PHYSICAL_FORCE_SYNCNOACF)
    link_Stack(&p->link, &acflayer);
  link_Stack(&p->link, &protolayer);
  link_Stack(&p->link, &lqrlayer);
  link_Stack(&p->link, &ccplayer);
  link_Stack(&p->link, &vjlayer);
  link_Stack(&p->link, &tcpmsslayer);
#ifndef NONAT
  link_Stack(&p->link, &natlayer);
#endif
  if (how == PHYSICAL_FORCE_ASYNC && physical_IsSync(p)) {
    log_Printf(LogWARN, "Sync device setting ignored for ``%s'' device\n", who);
    p->cfg.speed = MODEM_SPEED;
  } else if (how == PHYSICAL_FORCE_SYNC && !physical_IsSync(p)) {
    log_Printf(LogWARN, "Async device setting ignored for ``%s'' device\n",
               who);
    physical_SetSync(p);
  }
}

void
physical_StopDeviceTimer(struct physical *p)
{
  if (p->handler && p->handler->stoptimer)
    (*p->handler->stoptimer)(p);
}

int
physical_AwaitCarrier(struct physical *p)
{
  if (p->handler && p->handler->awaitcarrier)
    return (*p->handler->awaitcarrier)(p);

  return CARRIER_OK;
}


void
physical_SetAsyncParams(struct physical *p, u_int32_t mymap, u_int32_t hismap)
{
  if (p->handler && p->handler->setasyncparams)
    return (*p->handler->setasyncparams)(p, mymap, hismap);

  async_SetLinkParams(&p->async, mymap, hismap);
}

int
physical_Slot(struct physical *p)
{
  if (p->handler && p->handler->slot)
    return (*p->handler->slot)(p);

  return -1;
}
@


1.43
log
@tedu netnatm and ueagle(4).

ok mikeb@@, sthen@@, tedu@@ (implied), doc bits ok jmc@@
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.42 2012/01/23 09:13:16 nicm Exp $
@


1.42
log
@Trim unused variables, from Michael W. Bombardieri.

ok yasuoka
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.41 2009/06/05 23:03:07 deraadt Exp $
a103 3
#ifndef NOATM
#include "atm.h"
#endif
a139 4
#endif
#ifndef NOATM
  /* Ditto for ATM devices */
  { atm_Create, atm_iov2device, atm_DeviceSize },
@


1.41
log
@correct a format string type
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.40 2005/07/17 20:10:53 brad Exp $
d596 1
a596 1
  int len, h, type;
a607 1
  len = strlen(_PATH_DEV);
@


1.40
log
@rev 1.55

Report the number of bytes not written when complaining about failed writes

From brian FreeBSD
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.39 2005/07/17 20:08:55 brad Exp $
d430 1
a430 1
	log_Printf(LogPHASE, "%s: write (fd %d, len %d): %s\n", p->link.name,
@


1.39
log
@rev 1.52

Show the port number (tty slot, pppoe session id etc) under
``show physical''.

From brian FreeBSD
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.38 2005/07/17 19:13:25 brad Exp $
d430 2
a431 2
	log_Printf(LogPHASE, "%s: write (%d): %s\n", p->link.name,
                   p->fd, strerror(errno));
@


1.38
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.37 2005/07/06 13:56:00 brad Exp $
d447 1
a447 1
  int n;
d453 13
a465 4
  else if (p->handler && p->handler->openinfo)
    prompt_Printf(arg->prompt, "open (%s)\n", (*p->handler->openinfo)(p));
  else
    prompt_Printf(arg->prompt, "open\n");
@


1.37
log
@Add a bunch of malloc() return checks

From brian FreeBSD

ok deraadt@@ tdeval@@
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.36 2002/06/15 08:02:01 brian Exp $
d33 1
@


1.36
log
@Tidy up end of line whitespace
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.35 2002/05/27 23:19:38 brian Exp $
d38 1
d88 1
d727 4
a730 1
      iov[*niov].iov_base = malloc(sz);
@


1.35
log
@Coerce pid_t to long rather than int for better portability; theo
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.34 2002/05/16 01:13:39 brian Exp $
d482 1
a482 1
  
@


1.34
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.33 2002/03/31 02:38:49 brian Exp $
d368 2
a369 2
    log_Printf(LogPHASE, "%s: HUPing %d\n", p->link.name,
               (int)p->session_owner);
d459 1
a459 1
    prompt_Printf(arg->prompt, " (session owner: %d)", (int)p->session_owner);
@


1.33
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.32 2002/02/21 07:32:55 fgsch Exp $
a32 3
#ifdef NOSUID
#include <signal.h>
#endif
a70 1
#include "ip.h"
d1112 9
@


1.32
log
@use sizeof w/ defines; niklas@@ millert@@ ok.
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.31 2001/08/19 23:22:18 brian Exp $
d103 1
d141 3
d600 1
a600 1
  len = sizeof(_PATH_DEV) - 1;
d960 1
a960 1
  int len = sizeof(_PATH_DEV) - 1;
d1106 10
@


1.31
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.30 2001/06/19 10:24:56 brian Exp $
d596 1
a596 1
  len = strlen(_PATH_DEV);
d956 1
a956 1
  int len = strlen(_PATH_DEV);
@


1.30
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.29 2001/03/24 01:06:03 brian Exp $
d27 1
d73 2
d85 2
@


1.29
log
@Remove some unprotected prototype variable names
MAXPATHLEN -> PATH_MAX
Handle ENOENT from opening /dev/tun* properly
Rename _PATH_PPP -> PPP_CONFDIR and allow it to be redefined at compile time
Reduce MIN_LQRPERIOD and MIN_FSMRETRY to 1 second
Be smarter about identifying sockets on stdin
Allow primary DNS IP negotiation when the secondary IP has been rejected
Fix the call to PacketAliasProxyRule() properly.
Add/fix some comments
Fix man page markups; ru@@FreeBSD.org
Use localhost when no hostname is configured
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.28 2000/11/28 22:59:53 brian Exp $
d759 6
@


1.28
log
@Add ``enable/disable'' tcpmssfixup - enabled by default.
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.27 2000/10/09 22:50:57 brian Exp $
d122 4
d130 4
a133 1
  /* This must come before ``udp'' & ``tcp'' */
d137 1
a137 1
  /* and so must this */
a323 1
  char fn[MAXPATHLEN];
d326 2
a327 1
    log_Printf(LogALERT, "%s: Can't uu_unlock %s\n", p->link.name, fn);
d334 1
a334 1
  char fn[MAXPATHLEN];
d960 1
a960 1
  char fn[MAXPATHLEN];
@


1.27
log
@If write() gives -1/ENOBUFS, keep the packet and sleep for 1/10th
of a second before attempting to write it again (unless there's
something else to do instead).
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.26 2000/09/14 22:02:50 brian Exp $
d102 1
d1056 1
@


1.26
log
@Support PPPoATM, disabled for now as /usr/include/netnatm doesn't exist

Submitted by: Jakob Stoklund Olesen <stoklund@@taxidriver.dk>
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.25 2000/08/18 00:02:11 brian Exp $
d411 3
a413 1
      if (errno != EAGAIN) {
a417 1
      result = 1;
@


1.25
log
@Make -DNOSUID (or -DPPP_NOSUID) possible to build ppp without SUID
capabilities.
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.24 2000/08/15 10:26:37 brian Exp $
d99 3
a101 1

d127 4
@


1.24
log
@Maintain input and output throughput averages and choose the highest
of the two when calculating the MP throughput average for the ``set
autoload'' implementation.

This makes more sense as all links I know of are full-duplex.  This
also means that people may need to adjust their autoload settings
as 100% bandwidth is now the theoretical maximum rather than 200%
(but of course, halfing the current settings is probably not the
correct answer either!).

This involves a ppp version bump as we need to pass an extra
throughput array through the MP local domain socket.
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.23 2000/08/15 10:08:51 brian Exp $
d32 3
@


1.23
log
@Calculate the average link throughput using a counter based on the
cumulative total of all active links rather than basing it on the
total of PROTO_MP traffic.

This fixes a problem whereby Cisco routers send PROTO_IP packets only
when there's only one link (hmm, what a good idea!).
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.22 2000/06/13 09:57:51 brian Exp $
d603 2
a604 1
  p->link.stats.total.SampleOctets = (long long *)iov[(*niov)++].iov_base;
d690 4
a693 1
  iov[*niov].iov_base = p ? (void *)p->link.stats.total.SampleOctets : NULL;
@


1.22
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.21 2000/03/03 21:52:57 brian Exp $
d161 4
a164 1
  throughput_init(&p->link.throughput, SAMPLE_PERIOD);
d342 2
a343 2
  throughput_stop(&p->link.throughput);
  throughput_log(&p->link.throughput, LogPHASE, p->link.name);
d377 1
a377 1
  throughput_destroy(&p->link.throughput);
d498 1
a498 1
  throughput_disp(&p->link.throughput, arg->prompt);
d603 4
a606 1
  p->link.throughput.SampleOctets = (long long *)iov[(*niov)++].iov_base;
d625 1
a625 1
  throughput_restart(&p->link.throughput, "physical throughput",
d674 1
a674 1
    timer_Stop(&p->link.throughput.Timer);
d689 1
a689 1
  iov[*niov].iov_base = p ? (void *)p->link.throughput.SampleOctets : NULL;
d954 1
a954 1
  throughput_start(&p->link.throughput, "physical throughput",
@


1.21
log
@Fix some printf-type argument bugs
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.20 2000/02/27 01:38:27 brian Exp $
d343 2
@


1.20
log
@$Id$ -> $OpenBSD$
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.c,v 1.19 2000/02/27 00:21:09 brian Exp $
d388 2
a389 2
    log_Printf(LogDEBUG, "%s: DescriptorWrite: wrote %d(%d) to %d\n",
               p->link.name, nw, p->out->m_len, p->fd);
@


1.19
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.18 2000/01/07 03:26:55 brian Exp $
@


1.18
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.17 1999/08/05 10:32:14 brian Exp $
d100 1
a100 1
static int physical_DescriptorWrite(struct descriptor *, struct bundle *,
d131 1
a131 1
physical_UpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e,
d377 1
a377 1
physical_DescriptorWrite(struct descriptor *d, struct bundle *bundle,
d499 1
a499 1
physical_DescriptorRead(struct descriptor *d, struct bundle *bundle,
d791 1
a791 1
physical_doUpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e,
d853 1
a853 1
physical_IsSet(struct descriptor *d, const fd_set *fdset)
@


1.17
log
@o Obsolete the undocumented ``set weight'' command.
o If we're using RADIUS and the RADIUS mtu is less than our
  peers mru/mrru, reduce our mtu to this value for NetBSD too.
o Make struct throughput's sample period dynamic and tweak the ppp
  version number to reflect the extra stuff being passed through
  the local domain socket as a result (MP mode).
o Measure the current throughput based on the number of samples actually
  taken rather than on the full sample period.
o Keep the throughput statisics persistent while being passed to
  another ppp invocation through the local domain socket.
o When showing throughput statistics after the timer has stopped, use
  the stopped time for overall calculations, not the current time.
  Also show the stopped time and how long the current throughput has
  been sampled for.
o Use time() consistently in throughput.c
o Tighten up the ``show bundle'' output.
o Introduce the ``set bandwidth'' command.
o Rewrite the ``set autoload'' command.  It now takes three arguments
  and works based on a rolling bundle throughput average compared against
  the theoretical bundle bandwidth over a given period (read: it's now
  functional).
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.16 1999/07/15 02:10:32 brian Exp $
a23 1
#include <sys/socket.h>
a24 2
#include <arpa/inet.h>
#include <netdb.h>
a36 1
#include <sys/wait.h>
d48 2
a49 2
#ifndef NOALIAS
#include "alias_cmd.h"
d90 6
d98 2
a101 2
static void physical_DescriptorRead(struct descriptor *, struct bundle *,
                                    const fd_set *);
d111 2
a112 2
  struct device *(*iov2device)(int, struct physical *, struct iovec *iov,
                               int *niov, int maxiov);
d115 3
d119 4
d137 10
d169 1
a169 5
  p->desc.type = PHYSICAL_DESCRIPTOR;
  p->desc.UpdateSet = physical_UpdateSet;
  p->desc.IsSet = physical_IsSet;
  p->desc.Read = physical_DescriptorRead;
  p->desc.Write = physical_DescriptorWrite;
d191 2
a192 2
  p->cfg.cd.required = 0;
  p->cfg.cd.delay = DEF_CDDELAY;
d326 6
a331 1
    ID0logout(p->name.base);
d387 1
a387 1
    nw = physical_Write(p, MBUF_CTOP(p->out), p->out->cnt);
d389 1
a389 1
               p->link.name, nw, p->out->cnt, p->fd);
d391 4
a394 4
      p->out->cnt -= nw;
      p->out->offset += nw;
      if (p->out->cnt == 0)
	p->out = mbuf_FreeSeg(p->out);
d414 1
d440 2
a441 2
  prompt_Printf(arg->prompt, " Queued Packets:  %d\n",
                link_QueueLen(&p->link));
d479 13
a491 6
  prompt_Printf(arg->prompt, " CD check delay:  %d second%s",
                p->cfg.cd.delay, p->cfg.cd.delay == 1 ? "" : "s");
  if (p->cfg.cd.required)
    prompt_Printf(arg->prompt, " (required!)\n\n");
  else
    prompt_Printf(arg->prompt, "\n\n");
d498 1
a498 1
static void
d553 1
a553 1
             int fd)
d603 2
a604 2
    p->handler = (*devices[h].iov2device)(type, p, iov, niov, maxiov);

d606 1
a606 2
    log_Printf(LogPHASE, "%s: Device %s, unknown link type\n",
               p->link.name, p->name.full);
d641 1
a641 1
             pid_t newpid)
d657 1
a657 2
      if (p->handler->device2iov)
        h = p->handler;
a666 1
    physical_ChangedPid(p, newpid);
d677 1
a677 1
  iov[*niov].iov_base = p ? (void *)p : malloc(sizeof *p);
d681 1
a681 2
  iov[*niov].iov_base = p ? (void *)p->link.throughput.SampleOctets :
                            malloc(SAMPLE_PERIOD * sizeof(long long));
d687 2
a688 2
    if (h)
      (*h->device2iov)(h, iov, niov, maxiov, newpid);
d691 2
a692 2
      if (p->handler)
        memcpy(iov[*niov].iov_base, p->handler, sizeof *p->handler);
d697 1
a697 1
    iov[*niov].iov_base = malloc(sz);
d705 9
d717 1
a717 1
  if (p->fd >= 0 && *p->name.full == '/' && p->type != PHYS_DIRECT) {
d824 4
a827 1
  int sets;
d829 17
a845 16
  sets = 0;
  if (p->fd >= 0) {
    if (r && FD_ISSET(p->fd, r)) {
      FD_CLR(p->fd, r);
      log_Printf(LogTIMER, "%s: fdunset(r) %d\n", p->link.name, p->fd);
      sets++;
    }
    if (e && FD_ISSET(p->fd, e)) {
      FD_CLR(p->fd, e);
      log_Printf(LogTIMER, "%s: fdunset(e) %d\n", p->link.name, p->fd);
      sets++;
    }
    if (w && FD_ISSET(p->fd, w)) {
      FD_CLR(p->fd, w);
      log_Printf(LogTIMER, "%s: fdunset(w) %d\n", p->link.name, p->fd);
      sets++;
d847 2
a849 2
  
  return sets;
d865 1
d870 9
a878 1
    strncpy(ut.ut_line, p->name.base, sizeof ut.ut_line);
d883 1
a883 1
    p->Utmp = 1;
d893 1
d906 1
a906 1
    mbuf_Free(p->out);
d957 1
a957 1
  int devno, h, wasopen, err;
d967 1
a967 1
        p->handler = (*devices[h].create)(p);
d989 1
a989 1
        wasopen = p->fd >= 0;
d991 1
a991 2
          if ((p->handler = (*devices[h].create)(p)) == NULL &&
              wasopen && p->fd == -1)
d1001 1
a1001 1
                         " a '!' or be a host:port pair\n", p->link.name,
d1020 1
a1020 1
  if (how == PHYSICAL_FORCE_SYNC ||
d1027 2
a1028 1
  link_Stack(&p->link, &acflayer);
d1033 2
a1034 2
#ifndef NOALIAS
  link_Stack(&p->link, &aliaslayer);
d1051 9
@


1.16
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.14 1999/06/11 13:29:29 brian Exp $
d140 3
a142 1
  throughput_init(&p->link.throughput);
d237 1
a237 1
  return 115200;
d352 1
a531 1
  throughput_init(&p->link.throughput);
d570 1
d590 2
a591 2
  throughput_start(&p->link.throughput, "physical throughput",
                   Enabled(dl->bundle, OPT_THROUGHPUT));
d644 3
a646 2
  if (*niov + 1 >= maxiov) {
    log_Printf(LogERROR, "physical2iov: No room for physical + device !\n");
d654 5
@


1.15
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d24 1
a24 1
/* #include <sys/socket.h> (auto-remove) */
d26 2
a27 2
/* #include <arpa/inet.h> (auto-remove) */
/* #include <netdb.h> (auto-remove) */
d40 1
a40 1
/* #include <sys/wait.h> (auto-remove) */
a93 3
#ifndef NOI4B
#include "i4b.h"
#endif
a112 3
#ifndef NOI4B
  { i4b_Create, i4b_iov2device, i4b_DeviceSize },
#endif
a994 9
}

int
physical_AwaitCarrier(struct physical *p)
{
  if (p->handler && p->handler->awaitcarrier)
    return (*p->handler->awaitcarrier)(p);

  return CARRIER_OK;
@


1.14
log
@Show the correct error if we fail to open a device.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.13 1999/06/05 21:36:00 brian Exp $
d24 1
a24 1
#include <sys/socket.h>
d26 2
a27 2
#include <arpa/inet.h>
#include <netdb.h>
d40 1
a40 1
#include <sys/wait.h>
d94 3
d116 3
d1001 9
@


1.13
log
@Correct the way ppp transfers links on the server side in MP
mode by padding out the ``struct device'' to the maximum
device size.
Bump the ppp version number to indicate the transfer format
change.

This should make MP over tty and udp devices functional again.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.12 1999/06/02 00:46:55 brian Exp $
d901 1
a901 1
  int devno, h, wasopen;
d925 3
a927 1
        if (*p->name.full == '/')
d929 3
d940 9
a948 4
          if (h == NDEVICES)
	    log_Printf(LogWARN, "%s: Device (%s) must begin with a '/',"
                       " a '!' or be a host:port pair\n", p->link.name,
                       p->name.full);
@


1.12
log
@Introduce the ``keep-session'' option.  Refer to the man
page for details.  This allows MP over non-tty devices where
the original ppp process must not exit (such as sshd-spawned
ppp sessions).
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.11 1999/06/01 19:08:52 brian Exp $
d101 6
d111 1
d113 4
a116 4
  { tty_Create, tty_iov2device },
  { tcp_Create, tcp_iov2device },
  { udp_Create, udp_iov2device },
  { exec_Create, exec_iov2device }
d569 14
d590 7
a596 3
  type = (long)p->handler;
  for (h = 0; h < NDEVICES && p->handler == NULL; h++)
    p->handler = (*devices[h].iov2device)(type, p, iov, niov, maxiov);
d598 7
a604 2
  if (p->handler == NULL)
    physical_SetupStack(p, "unknown", PHYSICAL_NOFORCE);
d606 1
a606 1
  return p;
d613 4
d628 1
a628 1
        (*p->handler->device2iov)(p, iov, niov, maxiov, newpid);
d641 2
a642 2
  if (*niov >= maxiov) {
    log_Printf(LogERROR, "physical2iov: No room for physical !\n");
d648 1
a648 1
  iov[*niov].iov_base = p ? p : malloc(sizeof *p);
d651 17
@


1.11
log
@Increase the length of an individual device name to LINE_LEN.
Adjust the base physical device name correctly after a link
transfer (allowing correct multilink callbacks).
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.10 1999/05/24 16:39:19 brian Exp $
d598 2
a599 1
    if (tcgetpgrp(p->fd) == getpgrp())
d601 2
d624 1
a624 1
  if (p->fd >= 0 && p->type != PHYS_DIRECT) {
@


1.10
log
@Correct the ``ignoring sync/async'' warnings so that they show
up with the correct device type.
Reassign the correct tcpdevice or execdevice after transfering
a link in MP server mode.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.9 1999/05/18 01:37:51 brian Exp $
a531 2
  p->name.base = strncmp(p->name.full, _PATH_DEV, len) ?
                        p->name.full : p->name.full + len;
d535 2
d807 4
a810 2
  strncpy(p->name.full, name, sizeof p->name.full - 1);
  p->name.full[sizeof p->name.full - 1] = '\0';
@


1.9
log
@Move the tty locking stuff back out to physical.c so
that we lock the device *before* we open it.
We still open the device only once - and then ask all
our handlers if they know how to handle it.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.8 1999/05/13 19:29:37 brian Exp $
d574 1
a574 1
    physical_SetupStack(p, PHYSICAL_NOFORCE);
d858 1
a858 1
        physical_SetupStack(p, PHYSICAL_NOFORCE);
d896 1
a896 1
physical_SetupStack(struct physical *p, int how)
d915 1
a915 2
    log_Printf(LogWARN, "Sync device setting ignored for ``%s'' device\n",
               p->handler ? p->handler->name : "unknown");
d919 1
a919 1
               p->handler ? p->handler->name : "unknown");
@


1.8
log
@Initialise the struct device part of struct ttydevice.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.7 1999/05/12 10:03:52 brian Exp $
d259 2
a260 2
static void
physical_ReallyClose(struct physical *p)
d262 1
a262 1
  int newsid;
d264 8
a271 22
  log_Printf(LogDEBUG, "%s: Really close %d\n", p->link.name, p->fd);
  if (p->fd >= 0) {
    physical_StopDeviceTimer(p);
    if (p->Utmp) {
      ID0logout(p->name.base);
      p->Utmp = 0;
    }
    newsid = tcgetpgrp(p->fd) == getpgrp();
    close(p->fd);
    p->fd = -1;
    log_SetTtyCommandMode(p->dl);
    throughput_stop(&p->link.throughput);
    throughput_log(&p->link.throughput, LogPHASE, p->link.name);
    if (p->session_owner != (pid_t)-1) {
      ID0kill(p->session_owner, SIGHUP);
      p->session_owner = (pid_t)-1;
    }
    if (newsid)
      bundle_setsid(p->dl->bundle, 0);
    if (p->handler && p->handler->destroy)
      (*p->handler->destroy)(p);
    p->handler = NULL;
d273 11
a283 2
  *p->name.full = '\0';
  p->name.base = p->name.full;
d289 3
d300 37
a336 1
  physical_ReallyClose(p);
d817 17
d845 1
a845 1
  int devno, h;
d868 19
a886 13

      if (*p->name.full == '/')
        p->fd = ID0open(p->name.full, O_RDWR | O_NONBLOCK);

      for (h = 0; h < NDEVICES && p->handler == NULL; h++)
        p->handler = (*devices[h].create)(p);

      if (p->fd < 0)
	log_Printf(LogWARN, "%s: Device (%s) must begin with a '/',"
                   " a '!' or be a host:port pair\n", p->link.name,
                   p->name.full);
      else
        physical_Found(p);
@


1.7
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.6 1999/05/09 20:14:46 brian Exp $
d806 1
a806 1
      if (p->handler == NULL)
d808 2
a810 3
      if (p->handler == NULL)
        log_Printf(LogDEBUG, "%s: stdin is unidentified\n",
                   p->link.name);
@


1.6
log
@Revert to the previous behaviour of only doing a utmp
login if we're -direct on a tty device.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.5 1999/05/08 11:06:38 brian Exp $
d91 1
d101 9
a109 2
static const struct device *handlers[] = {
  &ttydevice, &tcpdevice, &execdevice
d112 1
a112 1
#define NHANDLERS (sizeof handlers / sizeof handlers[0])
a139 1
  memset(&p->Timer, '\0', sizeof p->Timer);
d266 1
a266 1
    timer_Stop(&p->Timer);
d283 2
a284 2
    if (p->handler && p->handler->postclose)
      (*p->handler->postclose)(p);
a450 1
  log_DumpBuff(LogASYNC, "ReadFromModem", rbuff, n);
d484 1
a484 1
  int len, h;
a488 1
  memset(&p->Timer, '\0', sizeof p->Timer);
a502 12
  if (p->handler) {
    for (h = 0; h < NHANDLERS; h++)
      if (p->handler == (const struct device *)(long)handlers[h]->type) {
        p->handler = handlers[h];
        break;
      }
    if (h == NHANDLERS) {
      log_Printf(LogERROR, "iov2physical: Can't find device hander !\n");
      p->handler = NULL;
    }
  }

d534 7
a540 2
  if (p->handler && p->handler->restored)
    (*p->handler->restored)(p);
d558 4
a561 5
    if (p->handler)
      p->handler = (const struct device *)(long)p->handler->type;
    if (p->Timer.state != TIMER_STOPPED) {
      timer_Stop(&p->Timer);
      p->Timer.state = TIMER_RUNNING;	/* Special - see iov2physical() */
d563 1
a633 2
/* Encapsulation for a read on the FD.  Avoids some exposure, and
   concentrates control. */
d637 10
a646 1
   return read(p->fd, buf, nbytes);
d652 6
a657 1
   return write(p->fd, buf, nbytes);
d801 7
a807 1
    if (tty_OpenStdin(p)) {
d809 3
a811 8
      p->handler = &ttydevice;
    } else {
      log_Printf(LogDEBUG, "%s: physical_Open: stdin is not a tty\n",
                 p->link.name);
      physical_SetDevice(p, "");
      physical_SetupStack(p, 0);
      physical_Found(p);
      return p->fd = STDIN_FILENO;
d819 5
a823 5
      for (h = 0; h < NHANDLERS; h++)
        if (handlers[h]->open && (*handlers[h]->open)(p)) {
          p->handler = handlers[h];
          physical_Found(p);
        }
d829 2
d840 1
a840 1
physical_SetupStack(struct physical *p, int forceasync)
d843 2
a844 1
  if (!forceasync && physical_IsSync(p))
d858 1
a858 1
  if (forceasync && physical_IsSync(p))
d861 13
@


1.5
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.4 1999/04/27 00:21:25 brian Exp $
d718 1
a718 1
  if (p->type == PHYS_DIRECT && !p->Utmp) {
@


1.4
log
@Change ``set device'' so that it parses its arguments as one
device per argument rather than the old way of concatenating
everything then splitting the result at commas and whitespace.

Old syntax of ``set device /dev/cuaa0, /dev/cuaa1''
may no longer contain the comma, but syntax such as
``set device "!ssh host ppp -direct label"'' is now
possible.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.3 1999/02/06 03:22:42 brian Exp $
d23 12
d38 3
d44 14
a57 2
#include <sys/tty.h>

d59 1
d61 2
d64 1
d67 1
d69 1
a69 2
#include "fsm.h"
#include "lcp.h"
d71 5
a77 1
#include "descriptor.h"
d79 430
a508 2
#include "log.h"
#include "id.h"
d510 33
a542 2
/* External calls - should possibly be moved inline */
extern int IntToSpeed(int);
d544 2
d548 47
a594 2
physical_GetFD(struct physical *phys) {
   return phys->fd;
d598 3
a600 2
physical_IsSync(struct physical *phys) {
   return phys->cfg.speed == 0;
d603 1
a603 1
const char *physical_GetDevice(struct physical *phys)
d605 1
a605 1
   return phys->name.full;
a622 11

int
physical_SetSpeed(struct physical *phys, int speed) {
   if (IntToSpeed(speed) != B0) {
      phys->cfg.speed = speed;
      return 1;
   } else {
      return 0;
   }
}

d624 3
a626 2
physical_SetSync(struct physical *phys) {
   phys->cfg.speed = 0;
a628 1

d630 3
a632 2
physical_SetRtsCts(struct physical *phys, int enable) {
   phys->cfg.rts_cts = enable ? 1 : 0;
d639 3
a641 2
physical_Read(struct physical *phys, void *buf, size_t nbytes) {
   return read(phys->fd, buf, nbytes);
d645 3
a647 2
physical_Write(struct physical *phys, const void *buf, size_t nbytes) {
   return write(phys->fd, buf, nbytes);
d651 2
a652 2
physical_UpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e,
                   int *n, int force)
d716 1
a716 24
physical_Login(struct physical *phys, const char *name)
{
  if (phys->type == PHYS_DIRECT && phys->isatty) {
    if (phys->Utmp)
      log_Printf(LogERROR, "Oops, already logged in on %s\n", phys->name.base);
    else {
      struct utmp ut;
      const char *connstr;

      memset(&ut, 0, sizeof ut);
      time(&ut.ut_time);
      strncpy(ut.ut_name, name, sizeof ut.ut_name);
      strncpy(ut.ut_line, phys->name.base, sizeof ut.ut_line);
      if ((connstr = getenv("CONNECT")))
        /* mgetty sets this to the connection speed */
        strncpy(ut.ut_host, connstr, sizeof ut.ut_host);
      ID0login(&ut);
      phys->Utmp = 1;
    }
  }
}

void
physical_Logout(struct physical *phys)
d718 13
a730 3
  if (phys->Utmp) {
    ID0logout(phys->name.base);
    phys->Utmp = 0;
d756 91
@


1.3
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.7 1999/01/10 01:26:29 brian Exp $
d74 1
a74 1
      p->cfg.devlist[pos++] = ' ';
d78 1
@


1.2
log
@Only call isatty() when we open our descriptor, and remember
the answer.

If we later get a descriptor exception from select(), we know
that it's a tty (isatty() returns 0 after the exception on a
tty) and remember to call modem_LogicalClose().

The upshot of it all is that descriptor exceptions dont leave
the tty locked any more.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.1 1998/08/31 00:22:25 brian Exp $
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d19 1
a19 1
 *  $Id: physical.c,v 1.6 1998/08/25 17:48:43 brian Exp $
a56 5
physical_IsATTY(struct physical *phys) {
   return isatty(phys->fd);
}

int
d183 1
a183 1
  if (phys->type == PHYS_DIRECT && physical_IsATTY(phys)) {
@

