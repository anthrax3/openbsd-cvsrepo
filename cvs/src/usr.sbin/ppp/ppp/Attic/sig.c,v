head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.44
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.40
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.38
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.36
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.34
	OPENBSD_5_0:1.8.0.32
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.30
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.28
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.24
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.26
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.22
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.20
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.18
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.16
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.14
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.8;

1.8
date	2003.09.22.21.39.40;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.21.04.09.20;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.27.01.38.28;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.30.00.45.31;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.47;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.28;	author brian;	state Exp;
branches;
next	;


desc
@@


1.9
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1997 - 1999, 2001 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: sig.c,v 1.8 2003/09/22 21:39:40 miod Exp $
 */

#include <sys/types.h>

#include <signal.h>

#include "log.h"
#include "sig.h"

static int caused[NSIG];	/* An array of pending signals */
static int necessary;		/* Anything set ? */
static sig_type handler[NSIG];	/* all start at SIG_DFL */


/*
 * Record a signal in the "caused" array
 *
 * This function is the only thing actually called in signal context.  It
 * records that a signal has been caused and that sig_Handle() should be
 * called (in non-signal context) as soon as possible to process that
 * signal.
 */
static void
signal_recorder(int sig)
{
  caused[sig - 1]++;
  necessary = 1;
}


/*
 * Set up signal_recorder to handle the given sig and record ``fn'' as
 * the function to ultimately call in sig_Handle().  ``fn'' will not be
 * called in signal context (as sig_Handle() is not called in signal
 * context).
 */
sig_type
sig_signal(int sig, sig_type fn)
{
  sig_type Result;

  if (sig <= 0 || sig >= NSIG) {
    /* Oops - we must be a bit out of date (too many sigs ?) */
    log_Printf(LogALERT, "Eeek! %s:%d: I must be out of date!\n",
	      __FILE__, __LINE__);
    return signal(sig, fn);
  }
  Result = handler[sig - 1];
  if (fn == SIG_DFL || fn == SIG_IGN) {
    signal(sig, fn);
    handler[sig - 1] = (sig_type) 0;
  } else {
    handler[sig - 1] = fn;
    signal(sig, signal_recorder);
  }
  caused[sig - 1] = 0;
  return Result;
}


/*
 * Call the handlers for any pending signals
 *
 * This function is called from a non-signal context - in fact, it's
 * called every time select() in DoLoop() returns - just in case
 * select() returned due to a signal being recorded by signal_recorder().
 */
int
sig_Handle()
{
  int sig;
  int got;
  int result;

  result = 0;
  if (necessary) {
    /* We've *probably* got something in `caused' set */
    necessary = 0;
    /* `necessary' might go back to 1 while we're in here.... */
    do {
      got = 0;
      for (sig = 0; sig < NSIG; sig++)
        if (caused[sig]) {
	  caused[sig]--;
	  got++;
	  result++;
	  (*handler[sig])(sig + 1);
        }
    } while (got);
  }

  return result;
}
@


1.8
log
@Off-by-ones, from aaron@@
@
text
@d26 1
a26 1
 *	$OpenBSD: sig.c,v 1.7 2002/06/15 01:33:23 brian Exp $
@


1.7
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d26 1
a26 1
 *	$OpenBSD: sig.c,v 1.6 2002/05/16 01:13:39 brian Exp $
d68 1
a68 1
  if (sig <= 0 || sig > NSIG) {
@


1.6
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: sig.c,v 1.5 2001/08/21 04:09:20 brian Exp $
d28 2
@


1.5
log
@Add some comments to make it clearer how we're handling signals.
@
text
@d26 1
a26 1
 *	$OpenBSD: sig.c,v 1.4 2000/02/27 01:38:28 brian Exp $
a27 2

#include <sys/types.h>
@


1.4
log
@$Id$ -> $OpenBSD$
@
text
@d2 1
a2 1
 * Copyright (c) 1997 Brian Somers <brian@@Awfulhak.org>
d26 1
a26 1
 *	$OpenBSD: sig.c,v 1.3 1999/03/30 00:45:31 brian Exp $
d41 8
a48 2
/* Record a signal in the "caused" array */

d58 5
a62 4
 * Set up signal_recorder, and record handler as the function to ultimately
 * call in handle_signal()
*/

d87 7
a93 2
/* Call the handlers for any pending signals */

@


1.3
log
@Maintain a `necessary' marker to indicate that we *probably*
need to process a signal (usually a SIGALRM).  Check to see
if we need to process a signal both before *and* after calling
select() as older (pre-2.0) versions of ppp used to.

This handles the possibility that ppp may block at some
point (maybe due to an open() of a misconfigured device).
Previously, we'd potentially lock up in select().

The `necessary' marker reduces the increased signal checking
overhead so that at full speed with no compression transferring
an 83Mb file via a ``!ppp -direct'' device, we get a 1%
throughput gain.
@
text
@d26 1
a26 1
 *	$Id: sig.c,v 1.2 1999/02/06 03:22:47 brian Exp $
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: sig.c,v 1.13 1998/05/21 21:48:20 brian Exp $
d37 1
d47 1
d82 1
a82 1
void
d87 1
d89 18
a106 9
  do {
    got = 0;
    for (sig = 0; sig < NSIG; sig++)
      if (caused[sig]) {
	caused[sig]--;
	got++;
	(*handler[sig]) (sig + 1);
      }
  } while (got);
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

