head	1.11;
access;
symbols
	OPENBSD_5_4:1.10.0.40
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.38
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.36
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.34
	OPENBSD_5_0:1.10.0.32
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.30
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.28
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.24
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.26
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.22
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.20
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.18
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.16
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.14
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.11
date	2013.08.20.09.14.32;	author mpi;	state dead;
branches;
next	1.10;

1.10
date	2003.10.20.03.15.37;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.16.14.13.06;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.16.13.20.23;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.19.10.24.49;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.08.47.43;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.14.22.03.23;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.14.22.02.50;	author brian;	state Exp;
branches;
next	;


desc
@@


1.11
log
@tedu netnatm and ueagle(4).

ok mikeb@@, sthen@@, tedu@@ (implied), doc bits ok jmc@@
@
text
@/*-
 * Copyright (c) 2000 Jakob Stoklund Olesen <stoklund@@taxidriver.dk>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: atm.c,v 1.10 2003/10/20 03:15:37 deraadt Exp $
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netnatm/natm.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>
#include <sys/uio.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "defs.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "fsm.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "async.h"
#include "descriptor.h"
#include "physical.h"
#include "main.h"
#include "atm.h"

/* String identifying PPPoA */
#define PPPOA		"PPPoA"
#define PPPOA_LEN	(sizeof(PPPOA) - 1)

struct atmdevice {
  struct device dev;		/* What struct physical knows about */
};

#define device2atm(d) ((d)->type == ATM_DEVICE ? (struct atmdevice *)d : NULL)

int
atm_DeviceSize(void)
{
  return sizeof(struct atmdevice);
}

static ssize_t
atm_Sendto(struct physical *p, const void *v, size_t n)
{
  ssize_t ret = write(p->fd, v, n);
  if (ret < 0) {
    log_Printf(LogDEBUG, "atm_Sendto(%ld): %s\n", (long)n, strerror(errno));
    return ret;
  }
  return ret;
}

static ssize_t
atm_Recvfrom(struct physical *p, void *v, size_t n)
{
    ssize_t ret = read(p->fd, (char*)v, n);
    if (ret < 0) {
      log_Printf(LogDEBUG, "atm_Recvfrom(%ld): %s\n", (long)n, strerror(errno));
      return ret;
    }
    return ret;
}

static void
atm_Free(struct physical *p)
{
  struct atmdevice *dev = device2atm(p->handler);

  free(dev);
}

static void
atm_device2iov(struct device *d, struct iovec *iov, int *niov,
               int maxiov, int *auxfd, int *nauxfd)
{
  int sz = physical_MaxDeviceSize();

  iov[*niov].iov_base = realloc(d, sz);
  if (iov[*niov].iov_base == NULL) {
    log_Printf(LogALERT, "Failed to allocate memory: %d\n", sz);
    AbortProgram(EX_OSERR);
  }
  iov[*niov].iov_len = sz;
  (*niov)++;
}

static const struct device baseatmdevice = {
  ATM_DEVICE,
  "atm",
  0,
  { CD_NOTREQUIRED, 0 },
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  atm_Free,
  atm_Recvfrom,
  atm_Sendto,
  atm_device2iov,
  NULL,
  NULL,
  NULL
};

struct device *
atm_iov2device(int type, struct physical *p, struct iovec *iov, int *niov,
               int maxiov, int *auxfd, int *nauxfd)
{
  if (type == ATM_DEVICE) {
    struct atmdevice *dev = (struct atmdevice *)iov[(*niov)++].iov_base;
    struct atmdevice *newdev;

    newdev = realloc(dev, sizeof *dev);	/* Reduce to the correct size */
    if (newdev == NULL) {
      log_Printf(LogALERT, "Failed to allocate memory: %d\n",
                 (int)(sizeof *dev));
      AbortProgram(EX_OSERR);
    }
    dev = newdev;

    /* Refresh function pointers etc */
    memcpy(&dev->dev, &baseatmdevice, sizeof dev->dev);

    physical_SetupStack(p, dev->dev.name, PHYSICAL_FORCE_SYNCNOACF);
    return &dev->dev;
  }

  return NULL;
}

static struct atmdevice *
atm_CreateDevice(struct physical *p, const char *iface, unsigned vpi,
                 unsigned vci)
{
  struct atmdevice *dev;
  struct sockaddr_natm sock;

  if ((dev = calloc(1, sizeof *dev)) == NULL) {
    log_Printf(LogWARN, "%s: Cannot allocate an atm device: %s\n",
               p->link.name, strerror(errno));
    return NULL;
  }

  sock.snatm_len = sizeof sock;
  sock.snatm_family = AF_NATM;
  strncpy(sock.snatm_if, iface, IFNAMSIZ);
  sock.snatm_vpi = vpi;
  sock.snatm_vci = vci;

  log_Printf(LogPHASE, "%s: Connecting to %s:%u.%u\n", p->link.name,
             iface, vpi, vci);

  p->fd = socket(PF_NATM, SOCK_DGRAM, PROTO_NATMAAL5);
  if (p->fd >= 0) {
    log_Printf(LogDEBUG, "%s: Opened atm socket %s\n", p->link.name,
               p->name.full);
    if (connect(p->fd, (struct sockaddr *)&sock, sizeof sock) == 0)
      return dev;
    else
      log_Printf(LogWARN, "%s: connect: %s\n", p->name.full, strerror(errno));
  } else
    log_Printf(LogWARN, "%s: socket: %s\n", p->name.full, strerror(errno));

  close(p->fd);
  p->fd = -1;
  free(dev);

  return NULL;
}

struct device *
atm_Create(struct physical *p)
{
  struct atmdevice *dev;

  dev = NULL;
  if (p->fd < 0 && !strncasecmp(p->name.full, PPPOA, PPPOA_LEN)
      && p->name.full[PPPOA_LEN] == ':') {
    char iface[25];
    unsigned vci, vpi;

    if (sscanf(p->name.full + PPPOA_LEN + 1, "%25[A-Za-z0-9]:%u.%u", iface,
               &vpi, &vci) != 3) {
      log_Printf(LogWARN, "Malformed ATM device name \'%s\', "
                 "PPPoA:if:vpi.vci expected\n", p->name.full);
      return NULL;
    }

    dev = atm_CreateDevice(p, iface, vpi, vci);
  }

  if (dev) {
    memcpy(&dev->dev, &baseatmdevice, sizeof dev->dev);
    physical_SetupStack(p, dev->dev.name, PHYSICAL_FORCE_SYNCNOACF);
    if (p->cfg.cd.necessity != CD_DEFAULT)
      log_Printf(LogWARN, "Carrier settings ignored\n");
    return &dev->dev;
  }

  return NULL;
}
@


1.10
log
@realloc fixes
@
text
@d26 1
a26 1
 *	$OpenBSD: atm.c,v 1.9 2002/06/15 08:02:00 brian Exp $
@


1.9
log
@Tidy up end of line whitespace
@
text
@d26 1
a26 1
 *	$OpenBSD: atm.c,v 1.8 2002/05/16 01:13:39 brian Exp $
d149 1
d151 2
a152 2
    dev = realloc(dev, sizeof *dev);	/* Reduce to the correct size */
    if (dev == NULL) {
d157 1
@


1.8
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: atm.c,v 1.7 2002/03/31 02:38:49 brian Exp $
d173 1
a173 1
  
d217 1
a217 1
    
d224 1
a224 1
    
@


1.7
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d26 1
a26 1
 *	$OpenBSD: atm.c,v 1.6 2002/01/16 14:13:06 brian Exp $
d138 1
@


1.6
log
@socket()s first argument should be a protocol family rather than an
address family.
@
text
@d26 1
a26 1
 *	$OpenBSD: atm.c,v 1.5 2002/01/16 13:20:23 brian Exp $
d127 1
@


1.5
log
@socket's first argument is an address family, not a protocol family.
@
text
@d26 1
a26 1
 *	$OpenBSD: atm.c,v 1.4 2001/06/19 10:24:49 brian Exp $
d187 1
a187 1
  p->fd = socket(AF_NATM, SOCK_DGRAM, PROTO_NATMAAL5);
@


1.4
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d26 1
a26 1
 *	$OpenBSD: atm.c,v 1.3 2001/01/29 08:47:43 brian Exp $
d187 1
a187 1
  p->fd = socket(PF_NATM, SOCK_DGRAM, PROTO_NATMAAL5);
@


1.3
log
@Fix some log_Printf() casting; NetBSD (pkgsrc)
@
text
@d26 1
a26 1
 *	$OpenBSD: atm.c,v 1.2 2000/09/14 22:03:23 brian Exp $
d125 1
@


1.2
log
@Fix some style nits
@
text
@d26 1
a26 1
 *	$OpenBSD: atm.c,v 1.1 2000/09/14 22:02:50 brian Exp $
d82 1
a82 1
    log_Printf(LogDEBUG, "atm_Sendto(%d): %s\n", n, strerror(errno));
d93 1
a93 1
      log_Printf(LogDEBUG, "atm_Recvfrom(%d): %s\n", n, strerror(errno));
@


1.1
log
@Support PPPoATM, disabled for now as /usr/include/netnatm doesn't exist

Submitted by: Jakob Stoklund Olesen <stoklund@@taxidriver.dk>
@
text
@d26 1
a26 1
 *	$OpenBSD$
d62 2
a63 2
#define PPPOA "PPPoA"
#define PPPOA_LEN (sizeof(PPPOA)-1)
d81 1
a81 1
  if (ret<0) {
d92 1
a92 1
    if (ret<0) {
d165 2
a166 1
atm_CreateDevice(struct physical *p, const char *iface, unsigned vpi, unsigned vci)
d171 1
a171 1
  if ((dev = calloc (1, sizeof *dev)) == NULL) {
d179 1
a179 1
  strncpy (sock.snatm_if, iface, IFNAMSIZ);
d210 1
a210 1
  if (p->fd < 0 && !strncasecmp (p->name.full, PPPOA, PPPOA_LEN)
d215 4
a218 3
    if (sscanf (p->name.full + PPPOA_LEN + 1, "%25[A-Za-z0-9]:%u.%u", iface,
		&vpi, &vci) != 3) {
      log_Printf (LogWARN, "Malformed ATM device name \'%s\', PPPoA:if:vpi.vci expected\n", p->name.full);
@

