head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.46
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.42
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.40
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.38
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.36
	OPENBSD_5_0:1.16.0.34
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.32
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.30
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.26
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.28
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.24
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.22
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.20
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.18
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.16
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.14
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.12
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.10
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.17
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.16;

1.16
date	2003.04.07.23.58.53;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.03.22.23.56;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.19.10.24.51;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.04.22.53.13;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.19.11.06.33;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.27.01.38.25;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.07.03.26.53;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.02.15.58.40;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.34;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.11.01.50.04;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.35;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.19;	author brian;	state Exp;
branches;
next	;


desc
@@


1.17
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1997 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: deflate.c,v 1.16 2003/04/07 23:58:53 deraadt Exp $
 */

#include <sys/types.h>

#include <stdio.h>
#include <stdlib.h>
#include <zlib.h>

#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "ccp.h"
#include "deflate.h"

/* Our state */
struct deflate_state {
    u_short seqno;
    int uncomp_rec;
    int winsize;
    z_stream cx;
};

static char garbage[10];
static u_char EMPTY_BLOCK[4] = { 0x00, 0x00, 0xff, 0xff };

#define DEFLATE_CHUNK_LEN (1536 - sizeof(struct mbuf))

static int
DeflateResetOutput(void *v)
{
  struct deflate_state *state = (struct deflate_state *)v;

  state->seqno = 0;
  state->uncomp_rec = 0;
  deflateReset(&state->cx);
  log_Printf(LogCCP, "Deflate: Output channel reset\n");

  return 1;		/* Ask FSM to ACK */
}

static struct mbuf *
DeflateOutput(void *v, struct ccp *ccp, struct link *l, int pri, u_short *proto,
              struct mbuf *mp)
{
  struct deflate_state *state = (struct deflate_state *)v;
  u_char *wp, *rp;
  int olen, ilen, len, res, flush;
  struct mbuf *mo_head, *mo, *mi_head, *mi;

  ilen = m_length(mp);
  log_Printf(LogDEBUG, "DeflateOutput: Proto %02x (%d bytes)\n", *proto, ilen);
  log_DumpBp(LogDEBUG, "DeflateOutput: Compress packet:", mp);

  /* Stuff the protocol in front of the input */
  mi_head = mi = m_get(2, MB_CCPOUT);
  mi->m_next = mp;
  rp = MBUF_CTOP(mi);
  if (*proto < 0x100) {			/* Compress the protocol */
    rp[0] = *proto & 0377;
    mi->m_len = 1;
  } else {				/* Don't compress the protocol */
    rp[0] = *proto >> 8;
    rp[1] = *proto & 0377;
    mi->m_len = 2;
  }

  /* Allocate the initial output mbuf */
  mo_head = mo = m_get(DEFLATE_CHUNK_LEN, MB_CCPOUT);
  mo->m_len = 2;
  wp = MBUF_CTOP(mo);
  *wp++ = state->seqno >> 8;
  *wp++ = state->seqno & 0377;
  log_Printf(LogDEBUG, "DeflateOutput: Seq %d\n", state->seqno);
  state->seqno++;

  /* Set up the deflation context */
  state->cx.next_out = wp;
  state->cx.avail_out = DEFLATE_CHUNK_LEN - 2;
  state->cx.next_in = MBUF_CTOP(mi);
  state->cx.avail_in = mi->m_len;
  flush = Z_NO_FLUSH;

  olen = 0;
  while (1) {
    if ((res = deflate(&state->cx, flush)) != Z_OK) {
      if (res == Z_STREAM_END)
        break;			/* Done */
      log_Printf(LogWARN, "DeflateOutput: deflate returned %d (%s)\n",
                res, state->cx.msg ? state->cx.msg : "");
      m_freem(mo_head);
      m_free(mi_head);
      state->seqno--;
      return mp;		/* Our dictionary's probably dead now :-( */
    }

    if (flush == Z_SYNC_FLUSH && state->cx.avail_out != 0)
      break;

    if (state->cx.avail_in == 0 && mi->m_next != NULL) {
      mi = mi->m_next;
      state->cx.next_in = MBUF_CTOP(mi);
      state->cx.avail_in = mi->m_len;
      if (mi->m_next == NULL)
        flush = Z_SYNC_FLUSH;
    }

    if (state->cx.avail_out == 0) {
      mo->m_next = m_get(DEFLATE_CHUNK_LEN, MB_CCPOUT);
      olen += (mo->m_len = DEFLATE_CHUNK_LEN);
      mo = mo->m_next;
      mo->m_len = 0;
      state->cx.next_out = MBUF_CTOP(mo);
      state->cx.avail_out = DEFLATE_CHUNK_LEN;
    }
  }

  olen += (mo->m_len = DEFLATE_CHUNK_LEN - state->cx.avail_out);
  olen -= 4;		/* exclude the trailing EMPTY_BLOCK */

  /*
   * If the output packet (including seqno and excluding the EMPTY_BLOCK)
   * got bigger, send the original.
   */
  if (olen >= ilen) {
    m_freem(mo_head);
    m_free(mi_head);
    log_Printf(LogDEBUG, "DeflateOutput: %d => %d: Uncompressible (0x%04x)\n",
              ilen, olen, *proto);
    ccp->uncompout += ilen;
    ccp->compout += ilen;	/* We measure this stuff too */
    return mp;
  }

  m_freem(mi_head);

  /*
   * Lose the last four bytes of our output.
   * XXX: We should probably assert that these are the same as the
   *      contents of EMPTY_BLOCK.
   */
  mo = mo_head;
  for (len = mo->m_len; len < olen; mo = mo->m_next, len += mo->m_len)
    ;
  mo->m_len -= len - olen;
  if (mo->m_next != NULL) {
    m_freem(mo->m_next);
    mo->m_next = NULL;
  }

  ccp->uncompout += ilen;
  ccp->compout += olen;

  log_Printf(LogDEBUG, "DeflateOutput: %d => %d bytes, proto 0x%04x\n",
            ilen, olen, *proto);

  *proto = ccp_Proto(ccp);
  return mo_head;
}

static void
DeflateResetInput(void *v)
{
  struct deflate_state *state = (struct deflate_state *)v;

  state->seqno = 0;
  state->uncomp_rec = 0;
  inflateReset(&state->cx);
  log_Printf(LogCCP, "Deflate: Input channel reset\n");
}

static struct mbuf *
DeflateInput(void *v, struct ccp *ccp, u_short *proto, struct mbuf *mi)
{
  struct deflate_state *state = (struct deflate_state *)v;
  struct mbuf *mo, *mo_head, *mi_head;
  u_char *wp;
  int ilen, olen;
  int seq, flush, res, first;
  u_char hdr[2];

  log_DumpBp(LogDEBUG, "DeflateInput: Decompress packet:", mi);
  mi_head = mi = mbuf_Read(mi, hdr, 2);
  ilen = 2;

  /* Check the sequence number. */
  seq = (hdr[0] << 8) + hdr[1];
  log_Printf(LogDEBUG, "DeflateInput: Seq %d\n", seq);
  if (seq != state->seqno) {
    if (seq <= state->uncomp_rec)
      /*
       * So the peer's started at zero again - fine !  If we're wrong,
       * inflate() will fail.  This is better than getting into a loop
       * trying to get a ResetReq to a busy sender.
       */
      state->seqno = seq;
    else {
      log_Printf(LogCCP, "DeflateInput: Seq error: Got %d, expected %d\n",
                seq, state->seqno);
      m_freem(mi_head);
      ccp_SendResetReq(&ccp->fsm);
      return NULL;
    }
  }
  state->seqno++;
  state->uncomp_rec = 0;

  /* Allocate an output mbuf */
  mo_head = mo = m_get(DEFLATE_CHUNK_LEN, MB_CCPIN);

  /* Our proto starts with 0 if it's compressed */
  wp = MBUF_CTOP(mo);
  wp[0] = '\0';

  /*
   * We set avail_out to 1 initially so we can look at the first
   * byte of the output and decide whether we have a compressed
   * proto field.
   */
  state->cx.next_in = MBUF_CTOP(mi);
  state->cx.avail_in = mi->m_len;
  state->cx.next_out = wp + 1;
  state->cx.avail_out = 1;
  ilen += mi->m_len;

  flush = mi->m_next ? Z_NO_FLUSH : Z_SYNC_FLUSH;
  first = 1;
  olen = 0;

  while (1) {
    if ((res = inflate(&state->cx, flush)) != Z_OK) {
      if (res == Z_STREAM_END)
        break;			/* Done */
      log_Printf(LogCCP, "DeflateInput: inflate returned %d (%s)\n",
                res, state->cx.msg ? state->cx.msg : "");
      m_freem(mo_head);
      m_freem(mi);
      ccp_SendResetReq(&ccp->fsm);
      return NULL;
    }

    if (flush == Z_SYNC_FLUSH && state->cx.avail_out != 0)
      break;

    if (state->cx.avail_in == 0 && mi && (mi = m_free(mi)) != NULL) {
      /* underflow */
      state->cx.next_in = MBUF_CTOP(mi);
      ilen += (state->cx.avail_in = mi->m_len);
      if (mi->m_next == NULL)
        flush = Z_SYNC_FLUSH;
    }

    if (state->cx.avail_out == 0) {
      /* overflow */
      if (first) {
        if (!(wp[1] & 1)) {
          /* 2 byte proto, shuffle it back in output */
          wp[0] = wp[1];
          state->cx.next_out--;
          state->cx.avail_out = DEFLATE_CHUNK_LEN-1;
        } else
          state->cx.avail_out = DEFLATE_CHUNK_LEN-2;
        first = 0;
      } else {
        olen += (mo->m_len = DEFLATE_CHUNK_LEN);
        mo->m_next = m_get(DEFLATE_CHUNK_LEN, MB_CCPIN);
        mo = mo->m_next;
        state->cx.next_out = MBUF_CTOP(mo);
        state->cx.avail_out = DEFLATE_CHUNK_LEN;
      }
    }
  }

  if (mi != NULL)
    m_freem(mi);

  if (first) {
    log_Printf(LogCCP, "DeflateInput: Length error\n");
    m_freem(mo_head);
    ccp_SendResetReq(&ccp->fsm);
    return NULL;
  }

  olen += (mo->m_len = DEFLATE_CHUNK_LEN - state->cx.avail_out);

  *proto = ((u_short)wp[0] << 8) | wp[1];
  mo_head->m_offset += 2;
  mo_head->m_len -= 2;
  olen -= 2;

  ccp->compin += ilen;
  ccp->uncompin += olen;

  log_Printf(LogDEBUG, "DeflateInput: %d => %d bytes, proto 0x%04x\n",
            ilen, olen, *proto);

  /*
   * Simulate an EMPTY_BLOCK so that our dictionary stays in sync.
   * The peer will have silently removed this!
   */
  state->cx.next_out = garbage;
  state->cx.avail_out = sizeof garbage;
  state->cx.next_in = EMPTY_BLOCK;
  state->cx.avail_in = sizeof EMPTY_BLOCK;
  inflate(&state->cx, Z_SYNC_FLUSH);

  return mo_head;
}

static void
DeflateDictSetup(void *v, struct ccp *ccp, u_short proto, struct mbuf *mi)
{
  struct deflate_state *state = (struct deflate_state *)v;
  int res, flush, expect_error;
  u_char *rp;
  struct mbuf *mi_head;
  short len;

  log_Printf(LogDEBUG, "DeflateDictSetup: Got seq %d\n", state->seqno);

  /*
   * Stuff an ``uncompressed data'' block header followed by the
   * protocol in front of the input
   */
  mi_head = m_get(7, MB_CCPOUT);
  mi_head->m_next = mi;
  len = m_length(mi);
  mi = mi_head;
  rp = MBUF_CTOP(mi);
  if (proto < 0x100) {			/* Compress the protocol */
    rp[5] = proto & 0377;
    mi->m_len = 6;
    len++;
  } else {				/* Don't compress the protocol */
    rp[5] = proto >> 8;
    rp[6] = proto & 0377;
    mi->m_len = 7;
    len += 2;
  }
  rp[0] = 0x80;				/* BITS: 100xxxxx */
  rp[1] = len & 0377;			/* The length */
  rp[2] = len >> 8;
  rp[3] = (~len) & 0377;		/* One's compliment of the length */
  rp[4] = (~len) >> 8;

  state->cx.next_in = rp;
  state->cx.avail_in = mi->m_len;
  state->cx.next_out = garbage;
  state->cx.avail_out = sizeof garbage;
  flush = Z_NO_FLUSH;
  expect_error = 0;

  while (1) {
    if ((res = inflate(&state->cx, flush)) != Z_OK) {
      if (res == Z_STREAM_END)
        break;			/* Done */
      if (expect_error && res == Z_BUF_ERROR)
        break;
      log_Printf(LogCCP, "DeflateDictSetup: inflate returned %d (%s)\n",
                res, state->cx.msg ? state->cx.msg : "");
      log_Printf(LogCCP, "DeflateDictSetup: avail_in %d, avail_out %d\n",
                state->cx.avail_in, state->cx.avail_out);
      ccp_SendResetReq(&ccp->fsm);
      m_free(mi_head);		/* lose our allocated ``head'' buf */
      return;
    }

    if (flush == Z_SYNC_FLUSH && state->cx.avail_out != 0)
      break;

    if (state->cx.avail_in == 0 && mi && (mi = mi->m_next) != NULL) {
      /* underflow */
      state->cx.next_in = MBUF_CTOP(mi);
      state->cx.avail_in = mi->m_len;
      if (mi->m_next == NULL)
        flush = Z_SYNC_FLUSH;
    }

    if (state->cx.avail_out == 0) {
      if (state->cx.avail_in == 0)
        /*
         * This seems to be a bug in libz !  If inflate() finished
         * with 0 avail_in and 0 avail_out *and* this is the end of
         * our input *and* inflate() *has* actually written all the
         * output it's going to, it *doesn't* return Z_STREAM_END !
         * When we subsequently call it with no more input, it gives
         * us Z_BUF_ERROR :-(  It seems pretty safe to ignore this
         * error (the dictionary seems to stay in sync).  In the worst
         * case, we'll drop the next compressed packet and do a
         * CcpReset() then.
         */
        expect_error = 1;
      /* overflow */
      state->cx.next_out = garbage;
      state->cx.avail_out = sizeof garbage;
    }
  }

  ccp->compin += len;
  ccp->uncompin += len;

  state->seqno++;
  state->uncomp_rec++;
  m_free(mi_head);		/* lose our allocated ``head'' buf */
}

static const char *
DeflateDispOpts(struct fsm_opt *o)
{
  static char disp[7];		/* Must be used immediately */

  snprintf(disp, sizeof disp, "win %d", (o->data[0]>>4) + 8);
  return disp;
}

static void
DeflateInitOptsOutput(struct bundle *bundle, struct fsm_opt *o,
                      const struct ccp_config *cfg)
{
  o->hdr.len = 4;
  o->data[0] = ((cfg->deflate.out.winsize - 8) << 4) + 8;
  o->data[1] = '\0';
}

static int
DeflateSetOptsOutput(struct bundle *bundle, struct fsm_opt *o,
                     const struct ccp_config *cfg)
{
  if (o->hdr.len != 4 || (o->data[0] & 15) != 8 || o->data[1] != '\0')
    return MODE_REJ;

  if ((o->data[0] >> 4) + 8 > 15) {
    o->data[0] = ((15 - 8) << 4) + 8;
    return MODE_NAK;
  }

  return MODE_ACK;
}

static int
DeflateSetOptsInput(struct bundle *bundle, struct fsm_opt *o,
                    const struct ccp_config *cfg)
{
  int want;

  if (o->hdr.len != 4 || (o->data[0] & 15) != 8 || o->data[1] != '\0')
    return MODE_REJ;

  want = (o->data[0] >> 4) + 8;
  if (cfg->deflate.in.winsize == 0) {
    if (want < 8 || want > 15) {
      o->data[0] = ((15 - 8) << 4) + 8;
    }
  } else if (want != cfg->deflate.in.winsize) {
    o->data[0] = ((cfg->deflate.in.winsize - 8) << 4) + 8;
    return MODE_NAK;
  }

  return MODE_ACK;
}

static void *
DeflateInitInput(struct bundle *bundle, struct fsm_opt *o)
{
  struct deflate_state *state;

  state = (struct deflate_state *)malloc(sizeof(struct deflate_state));
  if (state != NULL) {
    state->winsize = (o->data[0] >> 4) + 8;
    state->cx.zalloc = NULL;
    state->cx.opaque = NULL;
    state->cx.zfree = NULL;
    state->cx.next_out = NULL;
    if (inflateInit2(&state->cx, -state->winsize) == Z_OK)
      DeflateResetInput(state);
    else {
      free(state);
      state = NULL;
    }
  }

  return state;
}

static void *
DeflateInitOutput(struct bundle *bundle, struct fsm_opt *o)
{
  struct deflate_state *state;

  state = (struct deflate_state *)malloc(sizeof(struct deflate_state));
  if (state != NULL) {
    state->winsize = (o->data[0] >> 4) + 8;
    state->cx.zalloc = NULL;
    state->cx.opaque = NULL;
    state->cx.zfree = NULL;
    state->cx.next_in = NULL;
    if (deflateInit2(&state->cx, Z_DEFAULT_COMPRESSION, 8,
                     -state->winsize, 8, Z_DEFAULT_STRATEGY) == Z_OK)
      DeflateResetOutput(state);
    else {
      free(state);
      state = NULL;
    }
  }

  return state;
}

static void
DeflateTermInput(void *v)
{
  struct deflate_state *state = (struct deflate_state *)v;

  inflateEnd(&state->cx);
  free(state);
}

static void
DeflateTermOutput(void *v)
{
  struct deflate_state *state = (struct deflate_state *)v;

  deflateEnd(&state->cx);
  free(state);
}

const struct ccp_algorithm PppdDeflateAlgorithm = {
  TY_PPPD_DEFLATE,	/* Older versions of pppd expected this ``type'' */
  CCP_NEG_DEFLATE24,
  DeflateDispOpts,
  ccp_DefaultUsable,
  ccp_DefaultRequired,
  {
    DeflateSetOptsInput,
    DeflateInitInput,
    DeflateTermInput,
    DeflateResetInput,
    DeflateInput,
    DeflateDictSetup
  },
  {
    0,
    DeflateInitOptsOutput,
    DeflateSetOptsOutput,
    DeflateInitOutput,
    DeflateTermOutput,
    DeflateResetOutput,
    DeflateOutput
  },
};

const struct ccp_algorithm DeflateAlgorithm = {
  TY_DEFLATE,		/* rfc 1979 */
  CCP_NEG_DEFLATE,
  DeflateDispOpts,
  ccp_DefaultUsable,
  ccp_DefaultRequired,
  {
    DeflateSetOptsInput,
    DeflateInitInput,
    DeflateTermInput,
    DeflateResetInput,
    DeflateInput,
    DeflateDictSetup
  },
  {
    0,
    DeflateInitOptsOutput,
    DeflateSetOptsOutput,
    DeflateInitOutput,
    DeflateTermOutput,
    DeflateResetOutput,
    DeflateOutput
  },
};
@


1.16
log
@more string cleaning; ok tedu
@
text
@d26 1
a26 1
 *	$OpenBSD: deflate.c,v 1.15 2002/06/15 01:33:23 brian Exp $
@


1.15
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d26 1
a26 1
 *	$OpenBSD: deflate.c,v 1.14 2002/05/16 01:13:39 brian Exp $
d438 1
a438 1
  sprintf(disp, "win %d", (o->data[0]>>4) + 8);
@


1.14
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: deflate.c,v 1.13 2001/07/03 22:23:56 brian Exp $
d443 2
a444 1
DeflateInitOptsOutput(struct fsm_opt *o, const struct ccp_config *cfg)
d452 2
a453 1
DeflateSetOptsOutput(struct fsm_opt *o, const struct ccp_config *cfg)
d467 2
a468 1
DeflateSetOptsInput(struct fsm_opt *o, const struct ccp_config *cfg)
d489 1
a489 1
DeflateInitInput(struct fsm_opt *o)
d512 1
a512 1
DeflateInitOutput(struct fsm_opt *o)
@


1.13
log
@Reduce the interface MTU by 2 when MPPE has been successfully negotiated.

This is necessary because MPPE will combine the protocol id with the
payload received on the tun interface, encrypt it, then prepend its
own protocol id, effectively increasing the payload by two bytes.
@
text
@d26 1
a26 1
 *	$OpenBSD: deflate.c,v 1.12 2001/06/19 10:24:51 brian Exp $
a32 1
#include <termios.h>
a34 1
#include "defs.h"
a38 3
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
d434 1
a434 1
DeflateDispOpts(struct lcp_opt *o)
d443 1
a443 1
DeflateInitOptsOutput(struct lcp_opt *o, const struct ccp_config *cfg)
d445 1
a445 1
  o->len = 4;
d451 1
a451 1
DeflateSetOptsOutput(struct lcp_opt *o, const struct ccp_config *cfg)
d453 1
a453 1
  if (o->len != 4 || (o->data[0] & 15) != 8 || o->data[1] != '\0')
d465 1
a465 1
DeflateSetOptsInput(struct lcp_opt *o, const struct ccp_config *cfg)
d469 1
a469 1
  if (o->len != 4 || (o->data[0] & 15) != 8 || o->data[1] != '\0')
d486 1
a486 1
DeflateInitInput(struct lcp_opt *o)
d509 1
a509 1
DeflateInitOutput(struct lcp_opt *o)
@


1.12
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d26 1
a26 1
 *	$OpenBSD: deflate.c,v 1.11 2001/02/04 22:53:13 brian Exp $
d570 1
d595 1
@


1.11
log
@Add a ``Usable'' function to the ccp switch.  The function
is called prior to sending a CCP configure request for a
given protocol.  The default is to send the request, but
this is overridden for MPPE which checks to see if the lcp
negotiations agreed CHAP81, and if not fails.

Use the same function to decide if we should reject peer
requests for MPPE.

This should get rid of those boring messages about not being
able to initialise MPPE when we don't negotiate CHAP81.
@
text
@d26 1
a26 1
 *	$OpenBSD: deflate.c,v 1.10 2000/07/19 11:06:33 brian Exp $
d60 1
a60 1
static void
d69 2
d456 1
a456 1
DeflateSetOptsOutput(struct lcp_opt *o)
d559 2
a560 1
  ccp_IsUsable,
d583 2
a584 1
  ccp_IsUsable,
@


1.10
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d26 1
a26 1
 *	$OpenBSD: deflate.c,v 1.9 2000/02/27 01:38:25 brian Exp $
d554 1
a554 1
  TY_PPPD_DEFLATE,	/* pppd (wrongly) expects this ``type'' field */
d557 1
d580 1
@


1.9
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: deflate.c,v 1.8 2000/01/07 03:26:53 brian Exp $
d41 2
@


1.8
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: deflate.c,v 1.7 1999/07/15 02:10:32 brian Exp $
@


1.7
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d26 1
a26 1
 *	$Id: deflate.c,v 1.5 1999/06/02 15:58:40 brian Exp $
a39 2
#include "lqr.h"
#include "hdlc.h"
d56 1
a56 1
#define DEFLATE_CHUNK_LEN 1600		/* Allocate mbufs this size */
d78 1
a78 1
  ilen = mbuf_Length(mp);
d83 2
a84 2
  mi_head = mi = mbuf_Alloc(2, MB_CCPOUT);
  mi->next = mp;
d88 1
a88 1
    mi->cnt = 1;
d92 1
a92 1
    mi->cnt = 2;
d96 2
a97 2
  mo_head = mo = mbuf_Alloc(DEFLATE_CHUNK_LEN, MB_CCPOUT);
  mo->cnt = 2;
d108 1
a108 1
  state->cx.avail_in = mi->cnt;
d118 2
a119 2
      mbuf_Free(mo_head);
      mbuf_FreeSeg(mi_head);
d127 2
a128 2
    if (state->cx.avail_in == 0 && mi->next != NULL) {
      mi = mi->next;
d130 2
a131 2
      state->cx.avail_in = mi->cnt;
      if (mi->next == NULL)
d136 4
a139 4
      mo->next = mbuf_Alloc(DEFLATE_CHUNK_LEN, MB_CCPOUT);
      olen += (mo->cnt = DEFLATE_CHUNK_LEN);
      mo = mo->next;
      mo->cnt = 0;
d145 1
a145 1
  olen += (mo->cnt = DEFLATE_CHUNK_LEN - state->cx.avail_out);
d153 2
a154 2
    mbuf_Free(mo_head);
    mbuf_FreeSeg(mi_head);
d162 1
a162 1
  mbuf_Free(mi_head);
d169 2
a170 1
  for (mo = mo_head, len = mo->cnt; len < olen; mo = mo->next, len += mo->cnt)
d172 4
a175 4
  mo->cnt -= len - olen;
  if (mo->next != NULL) {
    mbuf_Free(mo->next);
    mo->next = NULL;
d227 1
a227 1
      mbuf_Free(mi_head);
d236 1
a236 1
  mo_head = mo = mbuf_Alloc(DEFLATE_CHUNK_LEN, MB_CCPIN);
d248 1
a248 1
  state->cx.avail_in = mi->cnt;
d251 1
a251 1
  ilen += mi->cnt;
d253 1
a253 1
  flush = mi->next ? Z_NO_FLUSH : Z_SYNC_FLUSH;
d263 2
a264 2
      mbuf_Free(mo_head);
      mbuf_Free(mi);
d272 1
a272 1
    if (state->cx.avail_in == 0 && mi && (mi = mbuf_FreeSeg(mi)) != NULL) {
d275 2
a276 2
      ilen += (state->cx.avail_in = mi->cnt);
      if (mi->next == NULL)
d292 3
a294 3
        olen += (mo->cnt = DEFLATE_CHUNK_LEN);
        mo->next = mbuf_Alloc(DEFLATE_CHUNK_LEN, MB_CCPIN);
        mo = mo->next;
d302 1
a302 1
    mbuf_Free(mi);
d306 1
a306 1
    mbuf_Free(mo_head);
d311 1
a311 1
  olen += (mo->cnt = DEFLATE_CHUNK_LEN - state->cx.avail_out);
d314 2
a315 2
  mo_head->offset += 2;
  mo_head->cnt -= 2;
d352 3
a354 3
  mi_head = mbuf_Alloc(7, MB_CCPOUT);
  mi_head->next = mi;
  len = mbuf_Length(mi);
d359 1
a359 1
    mi->cnt = 6;
d364 1
a364 1
    mi->cnt = 7;
d374 1
a374 1
  state->cx.avail_in = mi->cnt;
d391 1
a391 1
      mbuf_FreeSeg(mi_head);		/* lose our allocated ``head'' buf */
d398 1
a398 1
    if (state->cx.avail_in == 0 && mi && (mi = mi->next) != NULL) {
d401 2
a402 2
      state->cx.avail_in = mi->cnt;
      if (mi->next == NULL)
d431 1
a431 1
  mbuf_FreeSeg(mi_head);		/* lose our allocated ``head'' buf */
@


1.6
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d40 2
@


1.5
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d26 1
a26 1
 *	$Id: deflate.c,v 1.4 1999/05/08 11:06:34 brian Exp $
a39 2
#include "lqr.h"
#include "hdlc.h"
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: deflate.c,v 1.3 1999/03/11 01:50:04 brian Exp $
d85 1
a85 1
  mi_head = mi = mbuf_Alloc(2, MB_HDLCOUT);
d98 1
a98 1
  mo_head = mo = mbuf_Alloc(DEFLATE_CHUNK_LEN, MB_HDLCOUT);
d138 1
a138 1
      mo->next = mbuf_Alloc(DEFLATE_CHUNK_LEN, MB_HDLCOUT);
d237 1
a237 1
  mo_head = mo = mbuf_Alloc(DEFLATE_CHUNK_LEN, MB_IPIN);
d294 1
a294 1
        mo->next = mbuf_Alloc(DEFLATE_CHUNK_LEN, MB_IPIN);
d353 1
a353 1
  mi_head = mbuf_Alloc(7, MB_HDLCOUT);
@


1.3
log
@Tone down the log levels (Log{ERROR,WARN} -> LogCCP)
when we've simply missed a packet.

When our Predictor1 CRC is wrong (implying we've dropped
a packet), don't send a ResetReq().  Instead, send another
CCP ConfigReq().  *shrug*  My tests show this as being far
worse than the ResetReq as we may have further Nak/Rejs etc
and we're basically resetting both our incoming and outgoing
compression dictionaries, but rfc1978 says the ConfigReq is
correct, so we'd better go along...
@
text
@d26 1
a26 1
 *	$Id: deflate.c,v 1.2 1999/02/06 03:22:35 brian Exp $
d33 1
d58 1
a58 1
#define DEFLATE_CHUNK_LEN 1024		/* Allocate mbufs this size */
d71 2
a72 2
static int
DeflateOutput(void *v, struct ccp *ccp, struct link *l, int pri, u_short proto,
d81 1
a81 1
  log_Printf(LogDEBUG, "DeflateOutput: Proto %02x (%d bytes)\n", proto, ilen);
d88 2
a89 2
  if (proto < 0x100) {			/* Compress the protocol */
    rp[0] = proto & 0377;
d92 2
a93 2
    rp[0] = proto >> 8;
    rp[1] = proto & 0377;
d123 1
a123 1
      return 1;			/* packet dropped */
d158 1
a158 1
              ilen, olen, proto);
d161 1
a161 1
    return 0;
d183 1
a183 1
            ilen, olen, proto);
d185 2
a186 2
  hdlc_Output(l, PRI_NORMAL, ccp_Proto(ccp), mo_head);
  return 1;
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: deflate.c,v 1.11 1998/08/07 18:42:48 brian Exp $
d225 1
a225 1
      log_Printf(LogWARN, "DeflateInput: Seq error: Got %d, expected %d\n",
d261 1
a261 1
      log_Printf(LogWARN, "DeflateInput: inflate returned %d (%s)\n",
d305 1
a305 1
    log_Printf(LogWARN, "DeflateInput: Length error\n");
d386 1
a386 1
      log_Printf(LogERROR, "DeflateDictSetup: inflate returned %d (%s)\n",
d388 1
a388 1
      log_Printf(LogERROR, "DeflateDictSetup: avail_in %d, avail_out %d\n",
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

