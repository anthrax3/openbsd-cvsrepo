head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.38
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.34
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.32
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.30
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.28
	OPENBSD_5_0:1.17.0.26
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.24
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.22
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.18
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.20
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.16
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.14
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.12
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.10
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.8
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.17;

1.17
date	2005.07.17.20.24.45;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.11.22.36.17;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.07.23.58.53;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.04.20.25.06;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.15.08.02.01;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.24.01.06.05;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.26.01.41.04;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.19.11.06.37;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.27.01.38.28;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.27.00.21.09;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.39;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.04.19.16.59.42;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.43;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.27;	author brian;	state Exp;
branches;
next	;


desc
@@


1.18
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1998 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: prompt.c,v 1.17 2005/07/17 20:24:45 brad Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/fcntl.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "defs.h"
#include "timer.h"
#include "command.h"
#include "log.h"
#include "descriptor.h"
#include "prompt.h"
#include "fsm.h"
#include "auth.h"
#include "iplist.h"
#include "throughput.h"
#include "slcompress.h"
#include "mbuf.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "async.h"
#include "ccp.h"
#include "link.h"
#include "physical.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "chat.h"
#include "chap.h"
#include "cbcp.h"
#include "datalink.h"
#include "server.h"
#include "main.h"

static void
prompt_Display(struct prompt *p)
{
  /* XXX: See Index2Nam() - should we only figure this out once ? */
  static char shostname[MAXHOSTNAMELEN];
  const char *pconnect, *pauth;

  if (p->TermMode || !p->needprompt)
    return;

  p->needprompt = 0;

  if (p->nonewline)
    p->nonewline = 0;
  else
    fprintf(p->Term, "\n");

  if (p->auth == LOCAL_AUTH)
    pauth = " ON ";
  else
    pauth = " on ";

  if (p->bundle->ncp.ipcp.fsm.state == ST_OPENED)
    pconnect = "PPP";
#ifndef NOINET6
  else if (!Enabled(p->bundle, OPT_IPCP) &&
	   p->bundle->ncp.ipv6cp.fsm.state == ST_OPENED)
    pconnect = "PPP";
#endif
  else if (bundle_Phase(p->bundle) == PHASE_NETWORK)
    pconnect = "PPp";
  else if (bundle_Phase(p->bundle) == PHASE_AUTHENTICATE)
    pconnect = "Ppp";
  else
    pconnect = "ppp";

  if (*shostname == '\0') {
    char *dot;

    if (gethostname(shostname, sizeof shostname) || *shostname == '\0')
      strlcpy(shostname, "localhost", sizeof shostname);
    else if ((dot = strchr(shostname, '.')))
      *dot = '\0';
  }

  fprintf(p->Term, "%s%s%s> ", pconnect, pauth, shostname);
  fflush(p->Term);
}

static int
prompt_UpdateSet(struct fdescriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
{
  struct prompt *p = descriptor2prompt(d);
  int sets;

  sets = 0;

  if (!p->active)
    return sets;

  if (p->fd_in >= 0) {
    if (r) {
      FD_SET(p->fd_in, r);
      log_Printf(LogTIMER, "prompt %s: fdset(r) %d\n", p->src.from, p->fd_in);
      sets++;
    }
    if (e) {
      FD_SET(p->fd_in, e);
      log_Printf(LogTIMER, "prompt %s: fdset(e) %d\n", p->src.from, p->fd_in);
      sets++;
    }
    if (sets && *n < p->fd_in + 1)
      *n = p->fd_in + 1;
  }

  prompt_Display(p);

  return sets;
}

static int
prompt_IsSet(struct fdescriptor *d, const fd_set *fdset)
{
  struct prompt *p = descriptor2prompt(d);
  return p->fd_in >= 0 && FD_ISSET(p->fd_in, fdset);
}


static void
prompt_ShowHelp(struct prompt *p)
{
  prompt_Printf(p, "The following commands are available:\n");
  prompt_Printf(p, " ~p\tEnter Packet mode\n");
  prompt_Printf(p, " ~t\tShow timers\n");
  prompt_Printf(p, " ~m\tShow memory map\n");
  prompt_Printf(p, " ~.\tTerminate program\n");
  prompt_Printf(p, " ~?\tThis help\n");
}

static void
prompt_Read(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  struct prompt *p = descriptor2prompt(d);
  struct prompt *op;
  int n;
  char ch;
  char linebuff[LINE_LEN];

  if (p->TermMode == NULL) {
    n = read(p->fd_in, linebuff, sizeof linebuff - 1);
    if (n > 0) {
      if (linebuff[n-1] == '\n')
        linebuff[--n] = '\0';
      else
        linebuff[n] = '\0';
      p->nonewline = 1;		/* Maybe command_Decode does a prompt */
      prompt_Required(p);
      if (n) {
        if ((op = log_PromptContext) == NULL)
          log_PromptContext = p;
        if (!command_Decode(bundle, linebuff, n, p, p->src.from))
          prompt_Printf(p, "Syntax error\n");
        log_PromptContext = op;
      }
    } else if (n <= 0) {
      log_Printf(LogPHASE, "%s: Client connection closed.\n", p->src.from);
      if (!p->owner)
        Cleanup(EX_NORMAL);
      prompt_Destroy(p, 0);
    }
    return;
  }

  switch (p->TermMode->state) {
    case DATALINK_CLOSED:
      prompt_Printf(p, "Link lost, terminal mode.\n");
      prompt_TtyCommandMode(p);
      p->nonewline = 0;
      prompt_Required(p);
      return;

    case DATALINK_READY:
      break;

    case DATALINK_OPEN:
      prompt_Printf(p, "\nPacket mode detected.\n");
      prompt_TtyCommandMode(p);
      p->nonewline = 0;
      /* We'll get a prompt because of our status change */
      /* FALLTHROUGH */

    default:
      /* Wait 'till we're in a state we care about */
      return;
  }

  /*
   * We are in terminal mode, decode special sequences
   */
  n = read(p->fd_in, &ch, 1);
  log_Printf(LogDEBUG, "Got %d bytes (reading from the terminal)\n", n);

  if (n > 0) {
    switch (p->readtilde) {
    case 0:
      if (ch == '~')
        p->readtilde = 1;
      else
	if (physical_Write(p->TermMode->physical, &ch, n) < 0) {
	  log_Printf(LogWARN, "error writing to modem: %s\n", strerror(errno));
          prompt_TtyCommandMode(p);
        }
      break;
    case 1:
      switch (ch) {
      case '?':
	prompt_ShowHelp(p);
	break;
      case 'p':
        datalink_Up(p->TermMode, 0, 1);
        prompt_Printf(p, "\nPacket mode.\n");
	prompt_TtyCommandMode(p);
        break;
      case '.':
	prompt_TtyCommandMode(p);
        p->nonewline = 0;
        prompt_Required(p);
	break;
      case 't':
	timer_Show(0, p);
	break;
      case 'm':
        {
          struct cmdargs arg;

          arg.cmdtab = NULL;
          arg.cmd = NULL;
          arg.argc = 0;
          arg.argn = 0;
          arg.argv = NULL;
          arg.bundle = bundle;
          arg.cx = p->TermMode;
          arg.prompt = p;

	  mbuf_Show(&arg);
        }
	break;
      default:
	if (physical_Write(p->TermMode->physical, &ch, n) < 0) {
	  log_Printf(LogWARN, "error writing to modem: %s\n", strerror(errno));
          prompt_TtyCommandMode(p);
        }
	break;
      }
      p->readtilde = 0;
      break;
    }
  }
}

static int
prompt_Write(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  /* We never want to write here ! */
  log_Printf(LogALERT, "prompt_Write: Internal error: Bad call !\n");
  return 0;
}

struct prompt *
prompt_Create(struct server *s, struct bundle *bundle, int fd)
{
  struct prompt *p = (struct prompt *)malloc(sizeof(struct prompt));

  if (p != NULL) {
    p->desc.type = PROMPT_DESCRIPTOR;
    p->desc.UpdateSet = prompt_UpdateSet;
    p->desc.IsSet = prompt_IsSet;
    p->desc.Read = prompt_Read;
    p->desc.Write = prompt_Write;

    if (fd == PROMPT_STD) {
      char *tty = ttyname(STDIN_FILENO);

      if (!tty) {
        free(p);
        return NULL;
      }
      p->fd_in = STDIN_FILENO;
      p->fd_out = STDOUT_FILENO;
      p->Term = stdout;
      p->owner = NULL;
      p->auth = LOCAL_AUTH;
      p->src.type = "Controller";
      strncpy(p->src.from, tty, sizeof p->src.from - 1);
      p->src.from[sizeof p->src.from - 1] = '\0';
      tcgetattr(p->fd_in, &p->oldtio);	/* Save original tty mode */
    } else {
      p->fd_in = p->fd_out = fd;
      p->Term = fdopen(fd, "a+");
      p->owner = s;
      p->auth = *s->cfg.passwd ? LOCAL_NO_AUTH : LOCAL_AUTH;
      p->src.type = "unknown";
      *p->src.from = '\0';
    }
    p->TermMode = NULL;
    p->nonewline = 1;
    p->needprompt = 1;
    p->readtilde = 0;
    p->bundle = bundle;
    log_RegisterPrompt(p);
  }

  return p;
}

void
prompt_Destroy(struct prompt *p, int verbose)
{
  if (p) {
    if (p->Term != stdout) {
      fclose(p->Term);
      close(p->fd_in);
      if (p->fd_out != p->fd_in)
        close(p->fd_out);
      if (verbose)
        log_Printf(LogPHASE, "%s: Client connection dropped.\n", p->src.from);
    } else
      prompt_TtyOldMode(p);

    log_UnRegisterPrompt(p);
    free(p);
  }
}

void
prompt_Printf(struct prompt *p, const char *fmt,...)
{
  if (p && p->active) {
    va_list ap;

    va_start(ap, fmt);
    prompt_vPrintf(p, fmt, ap);
    va_end(ap);
  }
}

void
prompt_vPrintf(struct prompt *p, const char *fmt, va_list ap)
{
  if (p && p->active) {
    char nfmt[LINE_LEN];
    const char *pfmt;

    if (p->TermMode) {
      /* Stuff '\r' in front of '\n' 'cos we're in raw mode */
      int len = strlen(fmt);

      if (len && len < sizeof nfmt - 1 && fmt[len-1] == '\n' &&
          (len == 1 || fmt[len-2] != '\r')) {
        strlcpy(nfmt, fmt, sizeof nfmt);
        strlcpy(nfmt + len - 1, "\r\n", sizeof nfmt - (len - 1));
        pfmt = nfmt;
      } else
        pfmt = fmt;
    } else
      pfmt = fmt;
    vfprintf(p->Term, pfmt, ap);
    fflush(p->Term);
    p->nonewline = 1;
  }
}

void
prompt_TtyInit(struct prompt *p)
{
  int stat, fd = p ? p->fd_in : STDIN_FILENO;
  struct termios newtio;

  stat = fcntl(fd, F_GETFL, 0);
  if (stat > 0) {
    stat |= O_NONBLOCK;
    fcntl(fd, F_SETFL, stat);
  }

  if (p)
    newtio = p->oldtio;
  else
    tcgetattr(fd, &newtio);

  newtio.c_lflag &= ~(ECHO | ISIG | ICANON);
  newtio.c_iflag = 0;
  newtio.c_oflag &= ~OPOST;
  if (!p)
    newtio.c_cc[VINTR] = _POSIX_VDISABLE;
  newtio.c_cc[VMIN] = 1;
  newtio.c_cc[VTIME] = 0;
  newtio.c_cflag |= CS8;
  tcsetattr(fd, TCSANOW, &newtio);
  if (p)
    p->comtio = newtio;
}

/*
 *  Set tty into command mode. We allow canonical input and echo processing.
 */
void
prompt_TtyCommandMode(struct prompt *p)
{
  struct termios newtio;
  int stat;

  tcgetattr(p->fd_in, &newtio);
  newtio.c_lflag |= (ECHO | ISIG | ICANON);
  newtio.c_iflag = p->oldtio.c_iflag;
  newtio.c_oflag |= OPOST;
  tcsetattr(p->fd_in, TCSADRAIN, &newtio);

  stat = fcntl(p->fd_in, F_GETFL, 0);
  if (stat > 0) {
    stat |= O_NONBLOCK;
    fcntl(p->fd_in, F_SETFL, stat);
  }

  p->TermMode = NULL;
}

/*
 * Set tty into terminal mode which is used while we invoke term command.
 */
void
prompt_TtyTermMode(struct prompt *p, struct datalink *dl)
{
  int stat;

  if (p->Term == stdout)
    tcsetattr(p->fd_in, TCSADRAIN, &p->comtio);

  stat = fcntl(p->fd_in, F_GETFL, 0);
  if (stat > 0) {
    stat &= ~O_NONBLOCK;
    fcntl(p->fd_in, F_SETFL, stat);
  }
  p->TermMode = dl;
}

void
prompt_TtyOldMode(struct prompt *p)
{
  int stat;

  stat = fcntl(p->fd_in, F_GETFL, 0);
  if (stat > 0) {
    stat &= ~O_NONBLOCK;
    fcntl(p->fd_in, F_SETFL, stat);
  }

  if (p->Term == stdout)
    tcsetattr(p->fd_in, TCSADRAIN, &p->oldtio);
}

pid_t
prompt_pgrp(struct prompt *p)
{
  return tcgetpgrp(p->fd_in);
}

int
PasswdCommand(struct cmdargs const *arg)
{
  const char *pass;

  if (!arg->prompt) {
    log_Printf(LogWARN, "passwd: Cannot specify without a prompt\n");
    return 0;
  }

  if (arg->prompt->owner == NULL) {
    log_Printf(LogWARN, "passwd: Not required\n");
    return 0;
  }

  if (arg->argc == arg->argn)
    pass = "";
  else if (arg->argc > arg->argn+1)
    return -1;
  else
    pass = arg->argv[arg->argn];

  if (!strcmp(arg->prompt->owner->cfg.passwd, pass))
    arg->prompt->auth = LOCAL_AUTH;
  else
    arg->prompt->auth = LOCAL_NO_AUTH;

  return 0;
}

static struct pppTimer bgtimer;

static void
prompt_TimedContinue(void *v)
{
  prompt_Continue((struct prompt *)v);
}

void
prompt_Continue(struct prompt *p)
{
  timer_Stop(&bgtimer);
  if (getpgrp() == prompt_pgrp(p)) {
    prompt_TtyCommandMode(p);
    p->nonewline = 1;
    prompt_Required(p);
    log_ActivatePrompt(p);
  } else if (!p->owner) {
    bgtimer.func = prompt_TimedContinue;
    bgtimer.name = "prompt bg";
    bgtimer.load = SECTICKS;
    bgtimer.arg = p;
    timer_Start(&bgtimer);
  }
}

void
prompt_Suspend(struct prompt *p)
{
  if (getpgrp() == prompt_pgrp(p)) {
    prompt_TtyOldMode(p);
    log_DeactivatePrompt(p);
  }
}
@


1.17
log
@Replace various spelling with FALLTHROUGH which is lint()able

From charnier FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.16 2005/07/11 22:36:17 brad Exp $
@


1.16
log
@rev 1.30

If IPCP is disabled, susccess of IPV6CP negotiation is sufficient
to communicate by IPv6.  So, the prompt should be `PPP' rather
than `PPp'.

From ume FreeBSD

ok deraadt@@
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.15 2003/04/07 23:58:53 deraadt Exp $
d231 1
a231 1
      /* Fall through */
@


1.15
log
@more string cleaning; ok tedu
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.14 2003/04/04 20:25:06 deraadt Exp $
d106 5
@


1.14
log
@strlcpy and snprintf; various people ok
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.13 2002/06/15 08:02:01 brian Exp $
d397 1
a397 1
        strcpy(nfmt + len - 1, "\r\n");
@


1.13
log
@Tidy up end of line whitespace
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.12 2002/05/16 01:13:39 brian Exp $
d117 1
a117 1
      strcpy(shostname, "localhost");
d396 1
a396 1
        strcpy(nfmt, fmt);
@


1.12
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.11 2001/08/19 23:22:18 brian Exp $
d280 1
a280 1
        
@


1.11
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.10 2001/03/24 01:06:05 brian Exp $
a61 1
#include "ip.h"
@


1.10
log
@Remove some unprotected prototype variable names
MAXPATHLEN -> PATH_MAX
Handle ENOENT from opening /dev/tun* properly
Rename _PATH_PPP -> PPP_CONFDIR and allow it to be redefined at compile time
Reduce MIN_LQRPERIOD and MIN_FSMRETRY to 1 second
Be smarter about identifying sockets on stdin
Allow primary DNS IP negotiation when the secondary IP has been rejected
Fix the call to PacketAliasProxyRule() properly.
Add/fix some comments
Fix man page markups; ru@@FreeBSD.org
Use localhost when no hostname is configured
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.9 2001/01/26 01:41:04 brian Exp $
d33 1
d61 2
d73 2
@


1.9
log
@Allow ``set server closed'' to close the diagnostic socket.
Allow ``set server open'' to re-open the diagnostic socket.
Handle SIGUSR1 by re-opening the diagnostic socket
When receiving SIGUSR2 (and in ``set server none''), don't forget the
socket details so that ``set server open'' and SIGUSR1 open it again.

Don't create the diagnostic socket as uid 0 !  It's far to dangerous.
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.8 2000/07/19 11:06:37 brian Exp $
d112 1
a112 1
    if (gethostname(shostname, sizeof shostname))
@


1.8
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.7 2000/02/27 01:38:28 brian Exp $
d333 1
a333 1
      p->auth = *s->passwd ? LOCAL_NO_AUTH : LOCAL_AUTH;
d521 1
a521 1
  if (!strcmp(arg->prompt->owner->passwd, pass))
@


1.7
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: prompt.c,v 1.6 2000/02/27 00:21:09 brian Exp $
a51 1
#include "lcp.h"
d59 1
@


1.6
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: prompt.c,v 1.5 2000/01/07 03:26:55 brian Exp $
@


1.5
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: prompt.c,v 1.4 1999/05/08 11:06:39 brian Exp $
d123 1
a123 1
prompt_UpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
d154 1
a154 1
prompt_IsSet(struct descriptor *d, const fd_set *fdset)
d173 1
a173 1
prompt_Read(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
d294 1
a294 1
prompt_Write(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: prompt.c,v 1.3 1999/04/19 16:59:42 brian Exp $
d176 1
d190 7
a196 2
      if (n)
        command_Decode(bundle, linebuff, n, p, p->src.from);
@


1.3
log
@Escape stuff in the peers accmap as well as our own when async
encoding, and back out the negotiation strategy that didn't
quite have the right effect with some (bad?) ppp implementations.

Drop unexpected PAP/CHAP packets (if not in NETWORK or ESTABLISH
phase).

Make sure that we enter PHASE_ESTABLISH when we need to.

Detect HDLC frames correctly, not just when the whole header
is obtained by a single read().

Don't convert \r\n to \r\r\n in tty raw mode.

Use the correct macros for `', ``'', () and [].
@
text
@d26 1
a26 1
 *	$Id: prompt.c,v 1.2 1999/02/06 03:22:43 brian Exp $
d44 1
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: prompt.c,v 1.13 1999/01/28 01:56:34 brian Exp $
d383 2
a384 1
      if (len && len < sizeof nfmt - 1 && fmt[len-1] == '\n') {
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d26 1
a26 1
 *	$Id: prompt.c,v 1.12 1998/08/26 17:39:37 brian Exp $
d66 3
@

