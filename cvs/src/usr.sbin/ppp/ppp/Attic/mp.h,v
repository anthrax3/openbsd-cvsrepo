head	1.10;
access;
symbols
	OPENBSD_5_5:1.9.0.54
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.50
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.48
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.46
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.44
	OPENBSD_5_0:1.9.0.42
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.40
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.38
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.34
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.36
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.32
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.30
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.28
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.26
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.24
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.22
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.20
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.18
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.16
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.14
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.12
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.10
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.8
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.6
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.9;

1.9
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.27.00.21.08;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.17.12.27.52;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.08.05.10.32.14;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.09.16.55.26;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.05.08.11.06.38;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.42;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.25;	author brian;	state Exp;
branches;
next	;


desc
@@


1.10
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1998 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: mp.h,v 1.9 2001/08/19 23:22:18 brian Exp $
 */

struct mbuf;
struct physical;
struct bundle;
struct cmdargs;
struct datalink;

#define ENDDISC_NULL	0
#define ENDDISC_LOCAL	1
#define ENDDISC_IP	2
#define ENDDISC_MAC	3
#define ENDDISC_MAGIC	4
#define ENDDISC_PSN	5

#define MP_LINKSENT	0	/* We attached the link to another ppp */
#define MP_UP		1	/* We've started MP */
#define MP_ADDED	2	/* We've added the link to our MP */
#define MP_FAILED	3	/* No go */

#define MPSERVER_CONNECTED	0
#define MPSERVER_LISTENING	1
#define MPSERVER_FAILED		2

struct enddisc {
  u_char class;
  char address[50];
  int len;
};

struct peerid {
  struct enddisc enddisc;	/* Peers endpoint discriminator */
  char authname[AUTHLEN];	/* Peers name (authenticated) */
};

struct mpserver {
  struct fdescriptor desc;
  int fd;			/* listen()ing or connect()ing here */
  struct sockaddr_un socket;	/* On this socket */

  struct {
    struct datalink *dl;	/* Send this datalink */
  } send;			/* (in UpdateSet()) */
};

struct mp {
  struct link link;

  unsigned active : 1;
  unsigned peer_is12bit : 1;	/* 12/24bit seq nos */
  unsigned local_is12bit : 1;
  u_short peer_mrru;
  u_short local_mrru;

  struct peerid peer;		/* Who are we talking to */
  struct mpserver server;	/* Our ``sharing'' socket */

  struct {
    u_int32_t seq;		/* next outgoing seq */
    int link;			/* Next link to send on */
    int af;			/* Next address family to send */
  } out;

  struct {
    u_int32_t min_in;		/* minimum received incoming seq */
    u_int32_t next_in;		/* next incoming seq to process */
  } seq;

  struct {
    u_short mrru;		/* Max Reconstructed Receive Unit */
    unsigned shortseq : 2;	/* I want short Sequence Numbers */
    unsigned negenddisc : 2;	/* I want an endpoint discriminator */
    struct enddisc enddisc;	/* endpoint discriminator */
    struct {
      int min;			/* Lowest percent of bundle->bandwidth */
      int max;			/* Highest percent of bundle->bandwidth out */
      int period;		/* link->throughput sample period */
    } autoload;
  } cfg;

  struct mbuf *inbufs;		/* Received fragments */
  struct fsm_parent fsmp;	/* Our callback functions */
  struct bundle *bundle;	/* Parent */
};

struct mp_link {
  u_int32_t seq;		/* 12 or 24 bit incoming seq */
  unsigned bandwidth;		/* Our link bandwidth (or zero) */
};

struct mp_header {
  unsigned begin : 1;
  unsigned end : 1;
  u_int32_t seq;
};

#define descriptor2mpserver(d) \
  ((d)->type == MPSERVER_DESCRIPTOR ? (struct mpserver *)(d) : NULL)
#define mpserver_IsOpen(s) ((s)->fd != -1)

extern void peerid_Init(struct peerid *);
extern int peerid_Equal(const struct peerid *, const struct peerid *);
extern void mpserver_Init(struct mpserver *);
extern int mpserver_Open(struct mpserver *, struct peerid *);
extern void mpserver_Close(struct mpserver *);
extern void mp_Init(struct mp *, struct bundle *);
extern void mp_linkInit(struct mp_link *);
extern int mp_Up(struct mp *, struct datalink *);
extern void mp_Down(struct mp *);
extern struct mbuf *mp_Input(struct bundle *, struct link *, struct mbuf *);
extern int mp_FillPhysicalQueues(struct bundle *);
extern int mp_SetDatalinkBandwidth(struct cmdargs const *);
extern int mp_ShowStatus(struct cmdargs const *);
extern const char *mp_Enddisc(u_char, const char *, int);
extern int mp_SetEnddisc(struct cmdargs const *);
extern void mp_LinkLost(struct mp *, struct datalink *);
extern void mp_RestartAutoloadTimer(struct mp *);
extern void mp_CheckAutoloadTimer(struct mp *);
extern void mp_StopAutoloadTimer(struct mp *);
extern size_t mp_QueueLen(struct mp *);
@


1.9
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.h,v 1.8 2000/02/27 01:38:27 brian Exp $
@


1.8
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.h,v 1.7 2000/02/27 00:21:08 brian Exp $
d87 1
d137 1
a137 1
extern int mp_FillQueues(struct bundle *);
a142 1
extern void mp_DeleteQueue(struct mp *);
d146 1
@


1.7
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: mp.h,v 1.6 2000/01/17 12:27:52 brian Exp $
@


1.6
log
@Use AUTHLEN for the length of authname
@
text
@d26 1
a26 1
 *	$Id: mp.h,v 1.5 1999/08/05 10:32:14 brian Exp $
d63 1
a63 1
  struct descriptor desc;
@


1.5
log
@o Obsolete the undocumented ``set weight'' command.
o If we're using RADIUS and the RADIUS mtu is less than our
  peers mru/mrru, reduce our mtu to this value for NetBSD too.
o Make struct throughput's sample period dynamic and tweak the ppp
  version number to reflect the extra stuff being passed through
  the local domain socket as a result (MP mode).
o Measure the current throughput based on the number of samples actually
  taken rather than on the full sample period.
o Keep the throughput statisics persistent while being passed to
  another ppp invocation through the local domain socket.
o When showing throughput statistics after the timer has stopped, use
  the stopped time for overall calculations, not the current time.
  Also show the stopped time and how long the current throughput has
  been sampled for.
o Use time() consistently in throughput.c
o Tighten up the ``show bundle'' output.
o Introduce the ``set bandwidth'' command.
o Rewrite the ``set autoload'' command.  It now takes three arguments
  and works based on a rolling bundle throughput average compared against
  the theoretical bundle bandwidth over a given period (read: it's now
  functional).
@
text
@d26 1
a26 1
 *	$Id: mp.h,v 1.4 1999/06/09 16:55:26 brian Exp $
d59 1
a59 1
  char authname[50];		/* Peers name (authenticated) */
@


1.4
log
@Allow our endpoint discriminator to be enabled, disabled, accepted
and denied.  This is necessary for some MP implementations that
get confused if you accept their endpoint discriminator but reject
their MRRU.
@
text
@d26 1
a26 1
 *	$Id: mp.h,v 1.3 1999/05/08 11:06:38 brian Exp $
d99 5
d113 1
a113 1
  int weight;			/* bytes to send with each write */
d137 1
a137 1
extern int mp_SetDatalinkWeight(struct cmdargs const *);
d143 3
@


1.3
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: mp.h,v 1.2 1999/02/06 03:22:42 brian Exp $
d97 1
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: mp.h,v 1.4 1998/08/25 17:48:43 brian Exp $
d129 1
a129 1
extern void mp_Input(struct mp *, struct mbuf *, struct physical *);
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

