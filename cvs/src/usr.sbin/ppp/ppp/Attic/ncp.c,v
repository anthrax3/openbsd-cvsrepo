head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.38
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.34
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.32
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.30
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.28
	OPENBSD_5_0:1.4.0.26
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.24
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.22
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.18
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.20
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.16
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.14
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.12
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.10
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.8
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.6
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.2.0.12
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.10
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.8
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.6
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.1.0.4
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.06.20.37.27;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	;


desc
@@


1.5
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 2001 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: ncp.c,v 1.4 2005/07/17 19:13:25 brad Exp $
 */

#include <sys/param.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <net/route.h>
#include <sys/un.h>

#include <errno.h>
#include <resolv.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>

#include "layer.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "iplist.h"
#include "throughput.h"
#include "slcompress.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "descriptor.h"
#include "async.h"
#include "ccp.h"
#include "link.h"
#include "physical.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "prompt.h"
#include "route.h"
#include "iface.h"
#include "chat.h"
#include "auth.h"
#include "chap.h"
#include "cbcp.h"
#include "datalink.h"


static u_short default_urgent_tcp_ports[] = {
  21,	/* ftp */
  22,	/* ssh */
  23,	/* telnet */
  513,	/* login */
  514,	/* shell */
  543,	/* klogin */
  544	/* kshell */
};

static u_short default_urgent_udp_ports[] = { };

#define NDEFTCPPORTS \
  (sizeof default_urgent_tcp_ports / sizeof default_urgent_tcp_ports[0])
#define NDEFUDPPORTS \
  (sizeof default_urgent_udp_ports / sizeof default_urgent_udp_ports[0])

void
ncp_Init(struct ncp *ncp, struct bundle *bundle)
{
  ncp->afq = AF_INET;
  ncp->route = NULL;

  ncp->cfg.urgent.tcp.port = (u_short *)malloc(NDEFTCPPORTS * sizeof(u_short));
  if (ncp->cfg.urgent.tcp.port == NULL) {
    log_Printf(LogERROR, "ncp_Init: Out of memory allocating urgent ports\n");
    ncp->cfg.urgent.tcp.nports = ncp->cfg.urgent.tcp.maxports = 0;
  } else {
    ncp->cfg.urgent.tcp.nports = ncp->cfg.urgent.tcp.maxports = NDEFTCPPORTS;
    memcpy(ncp->cfg.urgent.tcp.port, default_urgent_tcp_ports,
	   NDEFTCPPORTS * sizeof(u_short));
  }
  ncp->cfg.urgent.tos = 1;

  ncp->cfg.urgent.udp.nports = ncp->cfg.urgent.udp.maxports = NDEFUDPPORTS;
  ncp->cfg.urgent.udp.port = (u_short *)malloc(NDEFUDPPORTS * sizeof(u_short));
  memcpy(ncp->cfg.urgent.udp.port, default_urgent_udp_ports,
         NDEFUDPPORTS * sizeof(u_short));


  mp_Init(&ncp->mp, bundle);

  /* Send over the first physical link by default */
  ipcp_Init(&ncp->ipcp, bundle, &bundle->links->physical->link,
            &bundle->fsm);
#ifndef NOINET6
  ipv6cp_Init(&ncp->ipv6cp, bundle, &bundle->links->physical->link,
              &bundle->fsm);
#endif
}

void
ncp_Destroy(struct ncp *ncp)
{
  ipcp_Destroy(&ncp->ipcp);
#ifndef NOINET6
  ipv6cp_Destroy(&ncp->ipv6cp);
#endif

  if (ncp->cfg.urgent.tcp.maxports) {
    ncp->cfg.urgent.tcp.nports = ncp->cfg.urgent.tcp.maxports = 0;
    free(ncp->cfg.urgent.tcp.port);
    ncp->cfg.urgent.tcp.port = NULL;
  }
  if (ncp->cfg.urgent.udp.maxports) {
    ncp->cfg.urgent.udp.nports = ncp->cfg.urgent.udp.maxports = 0;
    free(ncp->cfg.urgent.udp.port);
    ncp->cfg.urgent.udp.port = NULL;
  }
}

int
ncp_fsmStart(struct ncp *ncp, struct bundle *bundle)
{
  int res = 0;

#ifndef NOINET6
  if (Enabled(bundle, OPT_IPCP)) {
#endif
    fsm_Up(&ncp->ipcp.fsm);
    fsm_Open(&ncp->ipcp.fsm);
    res++;
#ifndef NOINET6
  }

  if (Enabled(bundle, OPT_IPV6CP)) {
    fsm_Up(&ncp->ipv6cp.fsm);
    fsm_Open(&ncp->ipv6cp.fsm);
    res++;
  }
#endif

  return res;
}

void
ncp_IfaceAddrAdded(struct ncp *ncp, const struct iface_addr *addr)
{
  switch (ncprange_family(&addr->ifa)) {
  case AF_INET:
    ipcp_IfaceAddrAdded(&ncp->ipcp, addr);
    break;
#ifndef NOINET6
  case AF_INET6:
    ipv6cp_IfaceAddrAdded(&ncp->ipv6cp, addr);
    break;
#endif
  }
}

void
ncp_IfaceAddrDeleted(struct ncp *ncp, const struct iface_addr *addr)
{
  if (ncprange_family(&addr->ifa) == AF_INET)
    ipcp_IfaceAddrDeleted(&ncp->ipcp, addr);
}

void
ncp_SetLink(struct ncp *ncp, struct link *l)
{
  ipcp_SetLink(&ncp->ipcp, l);
#ifndef NOINET6
  ipv6cp_SetLink(&ncp->ipv6cp, l);
#endif
}

/*
 * Enqueue a packet of the given address family.  Nothing will make it
 * down to the physical link level 'till ncp_FillPhysicalQueues() is used.
 */
void
ncp_Enqueue(struct ncp *ncp, int af, int pri, char *ptr, int count)
{
#ifndef NOINET6
  struct ipv6cp *ipv6cp = &ncp->ipv6cp;
#endif
  struct ipcp *ipcp = &ncp->ipcp;
  struct mbuf *bp;

  /*
   * We allocate an extra 6 bytes, four at the front and two at the end.
   * This is an optimisation so that we need to do less work in
   * m_prepend() in acf_LayerPush() and proto_LayerPush() and
   * appending in hdlc_LayerPush().
   */

  switch (af) {
  case AF_INET:
    if (pri < 0 || pri >= IPCP_QUEUES(ipcp)) {
      log_Printf(LogERROR, "Can't store in ip queue %d\n", pri);
      break;
    }

    bp = m_get(count + 6, MB_IPOUT);
    bp->m_offset += 4;
    bp->m_len -= 6;
    memcpy(MBUF_CTOP(bp), ptr, count);
    m_enqueue(ipcp->Queue + pri, bp);
    break;

#ifndef NOINET6
  case AF_INET6:
    if (pri < 0 || pri >= IPV6CP_QUEUES(ipcp)) {
      log_Printf(LogERROR, "Can't store in ipv6 queue %d\n", pri);
      break;
    }

    bp = m_get(count + 6, MB_IPOUT);
    bp->m_offset += 4;
    bp->m_len -= 6;
    memcpy(MBUF_CTOP(bp), ptr, count);
    m_enqueue(ipv6cp->Queue + pri, bp);
    break;
#endif

  default:
      log_Printf(LogERROR, "Can't enqueue protocol family %d\n", af);
  }
}

/*
 * How many packets are queued to go out ?
 */
size_t
ncp_QueueLen(struct ncp *ncp)
{
  size_t result;

  result = ipcp_QueueLen(&ncp->ipcp);
#ifndef NOINET6
  result += ipv6cp_QueueLen(&ncp->ipv6cp);
#endif
  result += mp_QueueLen(&ncp->mp);	/* Usually empty */

  return result;
}

/*
 * Ditch all queued packets.  This is usually done after our choked timer
 * has fired - which happens because we couldn't send any traffic over
 * any links for some time.
 */
void
ncp_DeleteQueues(struct ncp *ncp)
{
#ifndef NOINET6
  struct ipv6cp *ipv6cp = &ncp->ipv6cp;
#endif
  struct ipcp *ipcp = &ncp->ipcp;
  struct mp *mp = &ncp->mp;
  struct mqueue *q;

  for (q = ipcp->Queue; q < ipcp->Queue + IPCP_QUEUES(ipcp); q++)
    while (q->top)
      m_freem(m_dequeue(q));

#ifndef NOINET6
  for (q = ipv6cp->Queue; q < ipv6cp->Queue + IPV6CP_QUEUES(ipv6cp); q++)
    while (q->top)
      m_freem(m_dequeue(q));
#endif

  link_DeleteQueue(&mp->link);	/* Usually empty anyway */
}

/*
 * Arrange that each of our links has at least one packet.  We keep the
 * number of packets queued at the link level to a minimum so that the
 * loss of a link in multi-link mode results in the minimum number of
 * dropped packets.
 */
size_t
ncp_FillPhysicalQueues(struct ncp *ncp, struct bundle *bundle)
{
  size_t total;

  if (bundle->ncp.mp.active)
    total = mp_FillPhysicalQueues(bundle);
  else {
    struct datalink *dl;
    size_t add;

    for (total = 0, dl = bundle->links; dl; dl = dl->next)
      if (dl->state == DATALINK_OPEN) {
        add = link_QueueLen(&dl->physical->link);
        if (add == 0 && dl->physical->out == NULL)
          add = ncp_PushPacket(ncp, &ncp->afq, &dl->physical->link);
        total += add;
      }
  }

  return total + ncp_QueueLen(&bundle->ncp);
}

/*
 * Push a packet into the given link.  ``af'' is used as a persistent record
 * of what is to be pushed next, coming either from mp->out or ncp->afq.
 */
int
ncp_PushPacket(struct ncp *ncp, int *af, struct link *l)
{
  struct bundle *bundle = l->lcp.fsm.bundle;
  int res;

#ifndef NOINET6
  if (*af == AF_INET) {
    if ((res = ipcp_PushPacket(&bundle->ncp.ipcp, l)))
      *af = AF_INET6;
    else
      res = ipv6cp_PushPacket(&bundle->ncp.ipv6cp, l);
  } else {
    if ((res = ipv6cp_PushPacket(&bundle->ncp.ipv6cp, l)))
      *af = AF_INET;
    else
      res = ipcp_PushPacket(&bundle->ncp.ipcp, l);
  }
#else
  res = ipcp_PushPacket(&bundle->ncp.ipcp, l);
#endif

  return res;
}

int
ncp_IsUrgentPort(struct port_range *range, u_short src, u_short dst)
{
  int f;

  for (f = 0; f < range->nports; f++)
    if (range->port[f] == src || range->port[f] == dst)
      return 1;

  return 0;
}

void
ncp_AddUrgentPort(struct port_range *range, u_short port)
{
  u_short *newport;
  int p;

  if (range->nports == range->maxports) {
    range->maxports += 10;
    newport = (u_short *)realloc(range->port,
                                 range->maxports * sizeof(u_short));
    if (newport == NULL) {
      log_Printf(LogERROR, "ncp_AddUrgentPort: realloc: %s\n",
                 strerror(errno));
      range->maxports -= 10;
      return;
    }
    range->port = newport;
  }

  for (p = 0; p < range->nports; p++)
    if (range->port[p] == port) {
      log_Printf(LogWARN, "%u: Port already set to urgent\n", port);
      break;
    } else if (range->port[p] > port) {
      memmove(range->port + p + 1, range->port + p,
              (range->nports - p) * sizeof(u_short));
      range->port[p] = port;
      range->nports++;
      break;
    }

  if (p == range->nports)
    range->port[range->nports++] = port;
}

void
ncp_RemoveUrgentPort(struct port_range *range, u_short port)
{
  int p;

  for (p = 0; p < range->nports; p++)
    if (range->port[p] == port) {
      if (p != range->nports - 1)
        memmove(range->port + p, range->port + p + 1,
                (range->nports - p - 1) * sizeof(u_short));
      range->nports--;
      return;
    }

  if (p == range->nports)
    log_Printf(LogWARN, "%u: Port not set to urgent\n", port);
}

void
ncp_ClearUrgentPorts(struct port_range *range)
{
  range->nports = 0;
}

int
ncp_Show(struct cmdargs const *arg)
{
  struct ncp *ncp = &arg->bundle->ncp;
  int p;

#ifndef NOINET6
  prompt_Printf(arg->prompt, "Next queued AF: %s\n",
                ncp->afq == AF_INET6 ? "inet6" : "inet");
#endif

  if (ncp->route) {
    prompt_Printf(arg->prompt, "\n");
    route_ShowSticky(arg->prompt, ncp->route, "Sticky routes", 1);
  }

  prompt_Printf(arg->prompt, "\nDefaults:\n");
  prompt_Printf(arg->prompt, "  sendpipe:      ");
  if (ncp->cfg.sendpipe > 0)
    prompt_Printf(arg->prompt, "%-20ld\n", ncp->cfg.sendpipe);
  else
    prompt_Printf(arg->prompt, "unspecified\n");
  prompt_Printf(arg->prompt, "  recvpipe:      ");
  if (ncp->cfg.recvpipe > 0)
    prompt_Printf(arg->prompt, "%ld\n", ncp->cfg.recvpipe);
  else
    prompt_Printf(arg->prompt, "unspecified\n");

  prompt_Printf(arg->prompt, "\n  Urgent ports\n");
  prompt_Printf(arg->prompt, "         TCP:    ");
  if (ncp->cfg.urgent.tcp.nports == 0)
    prompt_Printf(arg->prompt, "none");
  else
    for (p = 0; p < ncp->cfg.urgent.tcp.nports; p++) {
      if (p)
        prompt_Printf(arg->prompt, ", ");
      prompt_Printf(arg->prompt, "%u", ncp->cfg.urgent.tcp.port[p]);
    }

  prompt_Printf(arg->prompt, "\n         UDP:    ");
  if (ncp->cfg.urgent.udp.nports == 0)
    prompt_Printf(arg->prompt, "none");
  else
    for (p = 0; p < ncp->cfg.urgent.udp.nports; p++) {
      if (p)
        prompt_Printf(arg->prompt, ", ");
      prompt_Printf(arg->prompt, "%u", ncp->cfg.urgent.udp.port[p]);
    }
  prompt_Printf(arg->prompt, "\n         TOS:    %s\n\n",
                ncp->cfg.urgent.tos ? "yes" : "no");

  return 0;
}

int
ncp_LayersOpen(struct ncp *ncp)
{
  int n;

  n = !!(ncp->ipcp.fsm.state == ST_OPENED);
#ifndef NOINET6
  n += !!(ncp->ipv6cp.fsm.state == ST_OPENED);
#endif

  return n;
}

int
ncp_LayersUnfinished(struct ncp *ncp)
{
  int n = 0;

  if (ncp->ipcp.fsm.state > ST_CLOSED ||
      ncp->ipcp.fsm.state == ST_STARTING)
    n++;

#ifndef NOINET6
  if (ncp->ipv6cp.fsm.state > ST_CLOSED ||
      ncp->ipv6cp.fsm.state == ST_STARTING)
    n++;
#endif

  return n;
}

void
ncp_Close(struct ncp *ncp)
{
  if (ncp->ipcp.fsm.state > ST_CLOSED ||
      ncp->ipcp.fsm.state == ST_STARTING)
    fsm_Close(&ncp->ipcp.fsm);

#ifndef NOINET6
  if (ncp->ipv6cp.fsm.state > ST_CLOSED ||
      ncp->ipv6cp.fsm.state == ST_STARTING)
    fsm_Close(&ncp->ipv6cp.fsm);
#endif
}

void
ncp2initial(struct ncp *ncp)
{
  fsm2initial(&ncp->ipcp.fsm);
#ifndef NOINET6
  fsm2initial(&ncp->ipv6cp.fsm);
#endif
}
@


1.4
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d26 1
a26 1
 * $OpenBSD: ncp.c,v 1.3 2005/07/06 20:37:27 brad Exp $
@


1.3
log
@rev 1.8

Handle a malloc() failure when allocating urgent ports

From brian FreeBSD

ok deraadt@@
@
text
@d26 1
a26 1
 * $OpenBSD: ncp.c,v 1.2 2002/05/16 01:13:39 brian Exp $
d39 1
@


1.2
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 * $OpenBSD$
a103 1
  ncp->cfg.urgent.tcp.nports = ncp->cfg.urgent.tcp.maxports = NDEFTCPPORTS;
d105 8
a112 2
  memcpy(ncp->cfg.urgent.tcp.port, default_urgent_tcp_ports,
         NDEFTCPPORTS * sizeof(u_short));
@


1.1
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 * $FreeBSD$
a32 1
#include <arpa/inet.h>
a33 1
#include <net/if.h>
a34 1
#include <netdb.h>
a37 1
#include <fcntl.h>
a40 1
#include <sys/stat.h>
a41 1
#include <unistd.h>
a43 1
#include "ua.h"
a49 1
#include "proto.h"
a56 1
#include "ip.h"
a59 1
#include "vjcomp.h"
a70 3
#include "id.h"
#include "arp.h"
#include "systems.h"
a76 1
#include "pap.h"
@

