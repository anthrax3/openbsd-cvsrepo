head	1.37;
access;
symbols
	OPENBSD_5_5:1.36.0.36
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.32
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.30
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.28
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.26
	OPENBSD_5_0:1.36.0.24
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.22
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.20
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.16
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.18
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.14
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.12
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.10
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.8
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.6
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.36.0.4
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.36.0.2
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.24.0.8
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.6
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.37
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.36;

1.36
date	2005.09.21.16.58.34;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2005.09.21.16.28.47;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.21.15.04.29;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.21.14.08.51;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.21.13.58.30;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.21.13.44.55;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.21.02.07.25;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.21.01.59.26;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.21.01.43.07;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.21.01.16.05;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.06.13.56.00;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.06.21.08.08;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.04.23.35.08;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.03.20.52.24;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.01.11.14.34;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.17.01.14.08;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.15.08.02.01;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.02.14.28.40;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.27.23.22.20;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.16.14.27.21;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.01.22.41.23;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.04.01.14.30;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.26.01.41.04;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.02.00.54.34;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.28.22.44.41;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.27.01.38.28;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.27.00.21.09;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.39;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.04.21.08.12.16;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.03.03.23.01.12;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	99.02.06.03.22.44;	author brian;	state Exp;
branches;
next	;


desc
@@


1.37
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*
 * Copyright 1999 Internet Business Solutions Ltd., Switzerland
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: radius.c,v 1.36 2005/09/21 16:58:34 brad Exp $
 *
 */

#include <sys/param.h>

#include <sys/socket.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <net/route.h>

#ifdef LOCALRAD
#include "radlib.h"
#include "radlib_vs.h"
#else
#include <radlib.h>
#include <radlib_vs.h>
#endif

#include <errno.h>
#ifndef NODES
#include <md5.h>
#endif
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <termios.h>
#include <unistd.h>
#include <netdb.h>

#include "layer.h"
#include "defs.h"
#include "log.h"
#include "descriptor.h"
#include "prompt.h"
#include "timer.h"
#include "fsm.h"
#include "iplist.h"
#include "slcompress.h"
#include "throughput.h"
#include "lqr.h"
#include "hdlc.h"
#include "mbuf.h"
#include "ncpaddr.h"
#include "ip.h"
#include "ipcp.h"
#include "ipv6cp.h"
#include "route.h"
#include "command.h"
#include "filter.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "mp.h"
#include "radius.h"
#include "auth.h"
#include "async.h"
#include "physical.h"
#include "chat.h"
#include "cbcp.h"
#include "chap.h"
#include "datalink.h"
#include "ncp.h"
#include "bundle.h"
#include "proto.h"

#if !defined(UINT32_MAX)
#define	UINT32_MAX	0xffffffffU
#endif

#ifndef NODES
struct mschap_response {
  u_char ident;
  u_char flags;
  u_char lm_response[24];
  u_char nt_response[24];
};

struct mschap2_response {
  u_char ident;
  u_char flags;
  u_char pchallenge[16];
  u_char reserved[8];
  u_char response[24];
};

#define	AUTH_LEN	16
#define	SALT_LEN	2
#endif

static const char *
radius_policyname(int policy)
{
  switch(policy) {
  case MPPE_POLICY_ALLOWED:
    return "Allowed";
  case MPPE_POLICY_REQUIRED:
    return "Required";
  }
  return NumStr(policy, NULL, 0);
}

static const char *
radius_typesname(int types)
{
  switch(types) {
  case MPPE_TYPE_40BIT:
    return "40 bit";
  case MPPE_TYPE_128BIT:
    return "128 bit";
  case MPPE_TYPE_40BIT|MPPE_TYPE_128BIT:
    return "40 or 128 bit";
  }
  return NumStr(types, NULL, 0);
}

#ifndef NODES
static void
demangle(struct radius *r, const void *mangled, size_t mlen,
         char **buf, size_t *len)
{
  char R[AUTH_LEN];		/* variable names as per rfc2548 */
  const char *S;
  u_char b[16];
  const u_char *A, *C;
  MD5_CTX Context;
  int Slen, i, Clen, Ppos;
  u_char *P;

  if (mlen % 16 != SALT_LEN) {
    log_Printf(LogWARN, "Cannot interpret mangled data of length %ld\n",
               (u_long)mlen);
    *buf = NULL;
    *len = 0;
    return;
  }

  /* We need the RADIUS Request-Authenticator */
  if (rad_request_authenticator(r->cx.rad, R, sizeof R) != AUTH_LEN) {
    log_Printf(LogWARN, "Cannot obtain the RADIUS request authenticator\n");
    *buf = NULL;
    *len = 0;
    return;
  }

  A = (const u_char *)mangled;			/* Salt comes first */
  C = (const u_char *)mangled + SALT_LEN;	/* Then the ciphertext */
  Clen = mlen - SALT_LEN;
  S = rad_server_secret(r->cx.rad);		/* We need the RADIUS secret */
  Slen = strlen(S);
  P = alloca(Clen);				/* We derive our plaintext */

  MD5Init(&Context);
  MD5Update(&Context, S, Slen);
  MD5Update(&Context, R, AUTH_LEN);
  MD5Update(&Context, A, SALT_LEN);
  MD5Final(b, &Context);
  Ppos = 0;

  while (Clen) {
    Clen -= 16;

    for (i = 0; i < 16; i++)
      P[Ppos++] = C[i] ^ b[i];

    if (Clen) {
      MD5Init(&Context);
      MD5Update(&Context, S, Slen);
      MD5Update(&Context, C, 16);
      MD5Final(b, &Context);
    }

    C += 16;
  }

  /*
   * The resulting plain text consists of a one-byte length, the text and
   * maybe some padding.
   */
  *len = *P;
  if (*len > mlen - 1) {
    log_Printf(LogWARN, "Mangled data seems to be garbage\n");
    *buf = NULL;
    *len = 0;
    return;
  }

  if ((*buf = malloc(*len)) == NULL) {
    log_Printf(LogWARN, "demangle: Out of memory (%lu bytes)\n", (u_long)*len);
    *len = 0;
  } else
    memcpy(*buf, P + 1, *len);
}
#endif

/* XXX: This should go into librarius. */
#ifndef NOINET6
static uint8_t *
rad_cvt_ipv6prefix(const void *data, size_t len)
{
	const size_t ipv6len = sizeof(struct in6_addr) + 2;
	uint8_t *s;

	if (len > ipv6len)
		return NULL;
	s = malloc(ipv6len);
	if (s != NULL) {
		memset(s, 0, ipv6len);
		memcpy(s, data, len);
	}
	return s;
}
#endif

/*
 * rad_continue_send_request() has given us `got' (non-zero).  Deal with it.
 */
static void
radius_Process(struct radius *r, int got)
{
  char *argv[MAXARGS], *nuke;
  struct bundle *bundle;
  int argc, addrs, res, width;
  size_t len;
  struct ncprange dest;
  struct ncpaddr gw;
  const void *data;
  const char *stype;
  u_int32_t ipaddr, vendor;
  struct in_addr ip;
#ifndef NOINET6
  uint8_t ipv6addr[INET6_ADDRSTRLEN];
  struct in6_addr ip6;
#endif

  r->cx.fd = -1;		/* Stop select()ing */
  stype = r->cx.auth ? "auth" : "acct";

  switch (got) {
    case RAD_ACCESS_ACCEPT:
      log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		 "Radius(%s): ACCEPT received\n", stype);
      if (!r->cx.auth) {
        rad_close(r->cx.rad);
        return;
      }
      break;

    case RAD_ACCESS_REJECT:
      log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		 "Radius(%s): REJECT received\n", stype);
      if (!r->cx.auth) {
        rad_close(r->cx.rad);
        return;
      }
      break;

    case RAD_ACCESS_CHALLENGE:
      /* we can't deal with this (for now) ! */
      log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		 "Radius: CHALLENGE received (can't handle yet)\n");
      if (r->cx.auth)
        auth_Failure(r->cx.auth);
      rad_close(r->cx.rad);
      return;

    case RAD_ACCOUNTING_RESPONSE:
      /*
       * It's probably not ideal to log this at PHASE level as we'll see
       * too much stuff going to the log when ``set rad_alive'' is used.
       * So we differ from older behaviour (ppp version 3.1 and before)
       * and just log accounting responses to LogRADIUS.
       */
      log_Printf(LogRADIUS, "Radius(%s): Accounting response received\n",
		 stype);
      if (r->cx.auth)
        auth_Failure(r->cx.auth);		/* unexpected !!! */

      /* No further processing for accounting requests, please */
      rad_close(r->cx.rad);
      return;

    case -1:
      log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		 "radius(%s): %s\n", stype, rad_strerror(r->cx.rad));
      if (r->cx.auth)
        auth_Failure(r->cx.auth);
      rad_close(r->cx.rad);
      return;

    default:
      log_Printf(LogERROR, "rad_send_request(%s): Failed %d: %s\n", stype,
                 got, rad_strerror(r->cx.rad));
      if (r->cx.auth)
        auth_Failure(r->cx.auth);
      rad_close(r->cx.rad);
      return;
  }

  /* Let's see what we've got in our reply */
  r->ip.s_addr = r->mask.s_addr = INADDR_NONE;
  r->mtu = 0;
  r->vj = 0;
  while ((res = rad_get_attr(r->cx.rad, &data, &len)) > 0) {
    switch (res) {
      case RAD_FRAMED_IP_ADDRESS:
        r->ip = rad_cvt_addr(data);
	log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		   " IP %s\n", inet_ntoa(r->ip));
        break;

      case RAD_FILTER_ID:
        free(r->filterid);
        if ((r->filterid = rad_cvt_string(data, len)) == NULL) {
          log_Printf(LogERROR, "rad_cvt_string: %s\n", rad_strerror(r->cx.rad));
          auth_Failure(r->cx.auth);
          rad_close(r->cx.rad);
          return;
        }
	log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		   " Filter \"%s\"\n", r->filterid);
        break;

      case RAD_SESSION_TIMEOUT:
        r->sessiontime = rad_cvt_int(data);
	log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		   " Session-Timeout %lu\n", r->sessiontime);
        break;

      case RAD_FRAMED_IP_NETMASK:
        r->mask = rad_cvt_addr(data);
	log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		   " Netmask %s\n", inet_ntoa(r->mask));
        break;

      case RAD_FRAMED_MTU:
        r->mtu = rad_cvt_int(data);
	log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		   " MTU %lu\n", r->mtu);
        break;

      case RAD_FRAMED_ROUTING:
        /* Disabled for now - should we automatically set up some filters ? */
        /* rad_cvt_int(data); */
        /* bit 1 = Send routing packets */
        /* bit 2 = Receive routing packets */
        break;

      case RAD_FRAMED_COMPRESSION:
        r->vj = rad_cvt_int(data) == 1 ? 1 : 0;
	log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		   " VJ %sabled\n", r->vj ? "en" : "dis");
        break;

      case RAD_FRAMED_ROUTE:
        /*
         * We expect a string of the format ``dest[/bits] gw [metrics]''
         * Any specified metrics are ignored.  MYADDR and HISADDR are
         * understood for ``dest'' and ``gw'' and ``0.0.0.0'' is the same
         * as ``HISADDR''.
         */

        if ((nuke = rad_cvt_string(data, len)) == NULL) {
          log_Printf(LogERROR, "rad_cvt_string: %s\n", rad_strerror(r->cx.rad));
          auth_Failure(r->cx.auth);
          rad_close(r->cx.rad);
          return;
        }

	log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		   " Route: %s\n", nuke);
        bundle = r->cx.auth->physical->dl->bundle;
        ip.s_addr = INADDR_ANY;
        ncpaddr_setip4(&gw, ip);
        ncprange_setip4host(&dest, ip);
        argc = command_Interpret(nuke, strlen(nuke), argv);
        if (argc < 0)
          log_Printf(LogWARN, "radius: %s: Syntax error\n",
                     argc == 1 ? argv[0] : "\"\"");
        else if (argc < 2)
          log_Printf(LogWARN, "radius: %s: Invalid route\n",
                     argc == 1 ? argv[0] : "\"\"");
        else if ((strcasecmp(argv[0], "default") != 0 &&
                  !ncprange_aton(&dest, &bundle->ncp, argv[0])) ||
                 !ncpaddr_aton(&gw, &bundle->ncp, argv[1]))
          log_Printf(LogWARN, "radius: %s %s: Invalid route\n",
                     argv[0], argv[1]);
        else {
          ncprange_getwidth(&dest, &width);
          if (width == 32 && strchr(argv[0], '/') == NULL) {
            /* No mask specified - use the natural mask */
            ncprange_getip4addr(&dest, &ip);
            ncprange_setip4mask(&dest, addr2mask(ip));
          }
          addrs = 0;

          if (!strncasecmp(argv[0], "HISADDR", 7))
            addrs = ROUTE_DSTHISADDR;
          else if (!strncasecmp(argv[0], "MYADDR", 6))
            addrs = ROUTE_DSTMYADDR;

          if (ncpaddr_getip4addr(&gw, &ipaddr) && ipaddr == INADDR_ANY) {
            addrs |= ROUTE_GWHISADDR;
            ncpaddr_setip4(&gw, bundle->ncp.ipcp.peer_ip);
          } else if (strcasecmp(argv[1], "HISADDR") == 0)
            addrs |= ROUTE_GWHISADDR;

          route_Add(&r->routes, addrs, &dest, &gw);
        }
        free(nuke);
        break;

      case RAD_REPLY_MESSAGE:
        free(r->repstr);
        if ((r->repstr = rad_cvt_string(data, len)) == NULL) {
          log_Printf(LogERROR, "rad_cvt_string: %s\n", rad_strerror(r->cx.rad));
          auth_Failure(r->cx.auth);
          rad_close(r->cx.rad);
          return;
        }
	log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		   " Reply-Message \"%s\"\n", r->repstr);
        break;

#ifndef NOINET6
      case RAD_FRAMED_IPV6_PREFIX:
	free(r->ipv6prefix);
        r->ipv6prefix = rad_cvt_ipv6prefix(data, len);
	inet_ntop(AF_INET6, &r->ipv6prefix[2], ipv6addr, sizeof(ipv6addr));
	log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		   " IPv6 %s/%d\n", ipv6addr, r->ipv6prefix[1]);
        break;

      case RAD_FRAMED_IPV6_ROUTE:
        /*
         * We expect a string of the format ``dest[/bits] gw [metrics]''
         * Any specified metrics are ignored.  MYADDR6 and HISADDR6 are
         * understood for ``dest'' and ``gw'' and ``::'' is the same
         * as ``HISADDR6''.
         */

        if ((nuke = rad_cvt_string(data, len)) == NULL) {
          log_Printf(LogERROR, "rad_cvt_string: %s\n", rad_strerror(r->cx.rad));
          auth_Failure(r->cx.auth);
          rad_close(r->cx.rad);
          return;
        }

	log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
		   " IPv6 Route: %s\n", nuke);
        bundle = r->cx.auth->physical->dl->bundle;
	ncpaddr_setip6(&gw, &in6addr_any);
	ncprange_set(&dest, &gw, 0);
        argc = command_Interpret(nuke, strlen(nuke), argv);
        if (argc < 0)
          log_Printf(LogWARN, "radius: %s: Syntax error\n",
                     argc == 1 ? argv[0] : "\"\"");
        else if (argc < 2)
          log_Printf(LogWARN, "radius: %s: Invalid route\n",
                     argc == 1 ? argv[0] : "\"\"");
        else if ((strcasecmp(argv[0], "default") != 0 &&
                  !ncprange_aton(&dest, &bundle->ncp, argv[0])) ||
                 !ncpaddr_aton(&gw, &bundle->ncp, argv[1]))
          log_Printf(LogWARN, "radius: %s %s: Invalid route\n",
                     argv[0], argv[1]);
        else {
          addrs = 0;

          if (!strncasecmp(argv[0], "HISADDR6", 8))
            addrs = ROUTE_DSTHISADDR6;
          else if (!strncasecmp(argv[0], "MYADDR6", 7))
            addrs = ROUTE_DSTMYADDR6;

          if (ncpaddr_getip6(&gw, &ip6) && IN6_IS_ADDR_UNSPECIFIED(&ip6)) {
            addrs |= ROUTE_GWHISADDR6;
            ncpaddr_copy(&gw, &bundle->ncp.ipv6cp.hisaddr);
          } else if (strcasecmp(argv[1], "HISADDR6") == 0)
            addrs |= ROUTE_GWHISADDR6;

          route_Add(&r->ipv6routes, addrs, &dest, &gw);
        }
        free(nuke);
        break;
#endif

      case RAD_VENDOR_SPECIFIC:
        if ((res = rad_get_vendor_attr(&vendor, &data, &len)) <= 0) {
          log_Printf(LogERROR, "rad_get_vendor_attr: %s (failing!)\n",
                     rad_strerror(r->cx.rad));
          auth_Failure(r->cx.auth);
          rad_close(r->cx.rad);
          return;
        }

	switch (vendor) {
          case RAD_VENDOR_MICROSOFT:
            switch (res) {
#ifndef NODES
              case RAD_MICROSOFT_MS_CHAP_ERROR:
                free(r->errstr);
                if (len == 0)
                  r->errstr = NULL;
                else {
                  if (len < 3 || ((const char *)data)[1] != '=') {
                    /*
                     * Only point at the String field if we don't think the
                     * peer has misformatted the response.
                     */
                    data = (const char *)data + 1;
                    len--;
                  } else
                    log_Printf(LogWARN, "Warning: The MS-CHAP-Error "
                               "attribute is mis-formatted.  Compensating\n");
                  if ((r->errstr = rad_cvt_string((const char *)data,
                                                  len)) == NULL) {
                    log_Printf(LogERROR, "rad_cvt_string: %s\n",
                               rad_strerror(r->cx.rad));
                    auth_Failure(r->cx.auth);
                    rad_close(r->cx.rad);
                    return;
                  }
		  log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
			     " MS-CHAP-Error \"%s\"\n", r->errstr);
                }
                break;

              case RAD_MICROSOFT_MS_CHAP2_SUCCESS:
                free(r->msrepstr);
                if (len == 0)
                  r->msrepstr = NULL;
                else {
                  if (len < 3 || ((const char *)data)[1] != '=') {
                    /*
                     * Only point at the String field if we don't think the
                     * peer has misformatted the response.
                     */
                    data = (const char *)data + 1;
                    len--;
                  } else
                    log_Printf(LogWARN, "Warning: The MS-CHAP2-Success "
                               "attribute is mis-formatted.  Compensating\n");
                  if ((r->msrepstr = rad_cvt_string((const char *)data,
                                                    len)) == NULL) {
                    log_Printf(LogERROR, "rad_cvt_string: %s\n",
                               rad_strerror(r->cx.rad));
                    auth_Failure(r->cx.auth);
                    rad_close(r->cx.rad);
                    return;
                  }
		  log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
			     " MS-CHAP2-Success \"%s\"\n", r->msrepstr);
                }
                break;

              case RAD_MICROSOFT_MS_MPPE_ENCRYPTION_POLICY:
                r->mppe.policy = rad_cvt_int(data);
		log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
			   " MS-MPPE-Encryption-Policy %s\n",
                           radius_policyname(r->mppe.policy));
                break;

              case RAD_MICROSOFT_MS_MPPE_ENCRYPTION_TYPES:
                r->mppe.types = rad_cvt_int(data);
		log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
			   " MS-MPPE-Encryption-Types %s\n",
                           radius_typesname(r->mppe.types));
                break;

              case RAD_MICROSOFT_MS_MPPE_RECV_KEY:
                free(r->mppe.recvkey);
		demangle(r, data, len, &r->mppe.recvkey, &r->mppe.recvkeylen);
		log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
			   " MS-MPPE-Recv-Key ********\n");
                break;

              case RAD_MICROSOFT_MS_MPPE_SEND_KEY:
		demangle(r, data, len, &r->mppe.sendkey, &r->mppe.sendkeylen);
		log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
			   " MS-MPPE-Send-Key ********\n");
                break;
#endif

              default:
                log_Printf(LogDEBUG, "Dropping MICROSOFT vendor specific "
                           "RADIUS attribute %d\n", res);
                break;
            }
            break;

          default:
            log_Printf(LogDEBUG, "Dropping vendor %lu RADIUS attribute %d\n",
                       (unsigned long)vendor, res);
            break;
        }
        break;

      default:
        log_Printf(LogDEBUG, "Dropping RADIUS attribute %d\n", res);
        break;
    }
  }

  if (res == -1) {
    log_Printf(LogERROR, "rad_get_attr: %s (failing!)\n",
               rad_strerror(r->cx.rad));
    auth_Failure(r->cx.auth);
  } else if (got == RAD_ACCESS_REJECT)
    auth_Failure(r->cx.auth);
  else {
    r->valid = 1;
    auth_Success(r->cx.auth);
  }
  rad_close(r->cx.rad);
}

/*
 * We've either timed out or select()ed on the read descriptor
 */
static void
radius_Continue(struct radius *r, int sel)
{
  struct timeval tv;
  int got;

  timer_Stop(&r->cx.timer);
  if ((got = rad_continue_send_request(r->cx.rad, sel, &r->cx.fd, &tv)) == 0) {
    log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
	       "Radius: Request re-sent\n");
    r->cx.timer.load = tv.tv_usec / TICKUNIT + tv.tv_sec * SECTICKS;
    timer_Start(&r->cx.timer);
    return;
  }

  radius_Process(r, got);
}

/*
 * Time to call rad_continue_send_request() - timed out.
 */
static void
radius_Timeout(void *v)
{
  radius_Continue((struct radius *)v, 0);
}

/*
 * Time to call rad_continue_send_request() - something to read.
 */
static void
radius_Read(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  radius_Continue(descriptor2radius(d), 1);
}

/*
 * Flush any pending transactions
 */
void
radius_Flush(struct radius *r)
{
  struct timeval tv;
  fd_set s;

  while (r->cx.fd != -1) {
    FD_ZERO(&s);
    FD_SET(r->cx.fd, &s);
    tv.tv_sec = 0;
    tv.tv_usec = TICKUNIT;
    select(r->cx.fd + 1, &s, NULL, NULL, &tv);
    radius_Continue(r, 1);
  }
}

/*
 * Behave as a struct fdescriptor (descriptor.h)
 */
static int
radius_UpdateSet(struct fdescriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
{
  struct radius *rad = descriptor2radius(d);

  if (r && rad->cx.fd != -1) {
    FD_SET(rad->cx.fd, r);
    if (*n < rad->cx.fd + 1)
      *n = rad->cx.fd + 1;
    log_Printf(LogTIMER, "Radius: fdset(r) %d\n", rad->cx.fd);
    return 1;
  }

  return 0;
}

/*
 * Behave as a struct fdescriptor (descriptor.h)
 */
static int
radius_IsSet(struct fdescriptor *d, const fd_set *fdset)
{
  struct radius *r = descriptor2radius(d);

  return r && r->cx.fd != -1 && FD_ISSET(r->cx.fd, fdset);
}

/*
 * Behave as a struct fdescriptor (descriptor.h)
 */
static int
radius_Write(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  /* We never want to write here ! */
  log_Printf(LogALERT, "radius_Write: Internal error: Bad call !\n");
  return 0;
}

/*
 * Initialise ourselves
 */
void
radius_Init(struct radius *r)
{
  r->desc.type = RADIUS_DESCRIPTOR;
  r->desc.UpdateSet = radius_UpdateSet;
  r->desc.IsSet = radius_IsSet;
  r->desc.Read = radius_Read;
  r->desc.Write = radius_Write;
  r->cx.fd = -1;
  r->cx.rad = NULL;
  memset(&r->cx.timer, '\0', sizeof r->cx.timer);
  r->cx.auth = NULL;
  r->valid = 0;
  r->vj = 0;
  r->ip.s_addr = INADDR_ANY;
  r->mask.s_addr = INADDR_NONE;
  r->routes = NULL;
  r->mtu = DEF_MTU;
  r->msrepstr = NULL;
  r->repstr = NULL;
#ifndef NOINET6
  r->ipv6prefix = NULL;
  r->ipv6routes = NULL;
#endif
  r->errstr = NULL;
  r->mppe.policy = 0;
  r->mppe.types = 0;
  r->mppe.recvkey = NULL;
  r->mppe.recvkeylen = 0;
  r->mppe.sendkey = NULL;
  r->mppe.sendkeylen = 0;
  *r->cfg.file = '\0';
  log_Printf(LogDEBUG, "Radius: radius_Init\n");
}

/*
 * Forget everything and go back to initialised state.
 */
void
radius_Destroy(struct radius *r)
{
  r->valid = 0;
  log_Printf(LogDEBUG, "Radius: radius_Destroy\n");
  timer_Stop(&r->cx.timer);
  route_DeleteAll(&r->routes);
#ifndef NOINET6
  route_DeleteAll(&r->ipv6routes);
#endif
  free(r->filterid);
  r->filterid = NULL;
  free(r->msrepstr);
  r->msrepstr = NULL;
  free(r->repstr);
  r->repstr = NULL;
#ifndef NOINET6
  free(r->ipv6prefix);
  r->ipv6prefix = NULL;
#endif
  free(r->errstr);
  r->errstr = NULL;
  free(r->mppe.recvkey);
  r->mppe.recvkey = NULL;
  r->mppe.recvkeylen = 0;
  free(r->mppe.sendkey);
  r->mppe.sendkey = NULL;
  r->mppe.sendkeylen = 0;
  if (r->cx.fd != -1) {
    r->cx.fd = -1;
    rad_close(r->cx.rad);
  }
}

static int
radius_put_physical_details(struct rad_handle *rad, struct physical *p)
{
  int slot, type;

  type = RAD_VIRTUAL;
  if (p->handler)
    switch (p->handler->type) {
      case I4B_DEVICE:
        type = RAD_ISDN_SYNC;
        break;

      case TTY_DEVICE:
        type = RAD_ASYNC;
        break;

      case ETHER_DEVICE:
        type = RAD_ETHERNET;
        break;

      case TCP_DEVICE:
      case UDP_DEVICE:
      case EXEC_DEVICE:
      case ATM_DEVICE:
      case NG_DEVICE:
        type = RAD_VIRTUAL;
        break;
    }

  if (rad_put_int(rad, RAD_NAS_PORT_TYPE, type) != 0) {
    log_Printf(LogERROR, "rad_put: rad_put_int: %s\n", rad_strerror(rad));
    rad_close(rad);
    return 0;
  }

  if ((slot = physical_Slot(p)) >= 0)
    if (rad_put_int(rad, RAD_NAS_PORT, slot) != 0) {
      log_Printf(LogERROR, "rad_put: rad_put_int: %s\n", rad_strerror(rad));
      rad_close(rad);
      return 0;
    }

  return 1;
}

/*
 * Start an authentication request to the RADIUS server.
 */
int
radius_Authenticate(struct radius *r, struct authinfo *authp, const char *name,
                    const char *key, int klen, const char *nchallenge,
                    int nclen)
{
  struct timeval tv;
  int got;
  char hostname[MAXHOSTNAMELEN];
  char *mac_addr, *what;
  struct hostent *hp;
  struct in_addr hostaddr;
#ifndef NODES
  struct mschap_response msresp;
  struct mschap2_response msresp2;
  const struct MSCHAPv2_resp *keyv2;
#endif

  if (!*r->cfg.file)
    return 0;

  if (r->cx.fd != -1)
    /*
     * We assume that our name/key/challenge is the same as last time,
     * and just continue to wait for the RADIUS server(s).
     */
    return 1;

  radius_Destroy(r);

  if ((r->cx.rad = rad_auth_open()) == NULL) {
    log_Printf(LogERROR, "rad_auth_open: %s\n", strerror(errno));
    return 0;
  }

  if (rad_config(r->cx.rad, r->cfg.file) != 0) {
    log_Printf(LogERROR, "rad_config: %s\n", rad_strerror(r->cx.rad));
    rad_close(r->cx.rad);
    return 0;
  }

  if (rad_create_request(r->cx.rad, RAD_ACCESS_REQUEST) != 0) {
    log_Printf(LogERROR, "rad_create_request: %s\n", rad_strerror(r->cx.rad));
    rad_close(r->cx.rad);
    return 0;
  }

  if (rad_put_string(r->cx.rad, RAD_USER_NAME, name) != 0 ||
      rad_put_int(r->cx.rad, RAD_SERVICE_TYPE, RAD_FRAMED) != 0 ||
      rad_put_int(r->cx.rad, RAD_FRAMED_PROTOCOL, RAD_PPP) != 0) {
    log_Printf(LogERROR, "rad_put: %s\n", rad_strerror(r->cx.rad));
    rad_close(r->cx.rad);
    return 0;
  }

  switch (authp->physical->link.lcp.want_auth) {
  case PROTO_PAP:
    /* We're talking PAP */
    if (rad_put_attr(r->cx.rad, RAD_USER_PASSWORD, key, klen) != 0) {
      log_Printf(LogERROR, "PAP: rad_put_string: %s\n",
                 rad_strerror(r->cx.rad));
      rad_close(r->cx.rad);
      return 0;
    }
    what = "PAP";
    break;

  case PROTO_CHAP:
    switch (authp->physical->link.lcp.want_authtype) {
    case 0x5:
      if (rad_put_attr(r->cx.rad, RAD_CHAP_PASSWORD, key, klen) != 0 ||
          rad_put_attr(r->cx.rad, RAD_CHAP_CHALLENGE, nchallenge, nclen) != 0) {
        log_Printf(LogERROR, "CHAP: rad_put_string: %s\n",
                   rad_strerror(r->cx.rad));
        rad_close(r->cx.rad);
        return 0;
      }
      what = "CHAP";
      break;

#ifndef NODES
    case 0x80:
      if (klen != 50) {
        log_Printf(LogERROR, "CHAP80: Unrecognised key length %d\n", klen);
        rad_close(r->cx.rad);
        return 0;
      }

      rad_put_vendor_attr(r->cx.rad, RAD_VENDOR_MICROSOFT,
                          RAD_MICROSOFT_MS_CHAP_CHALLENGE, nchallenge, nclen);
      msresp.ident = *key;
      msresp.flags = 0x01;
      memcpy(msresp.lm_response, key + 1, 24);
      memcpy(msresp.nt_response, key + 25, 24);
      rad_put_vendor_attr(r->cx.rad, RAD_VENDOR_MICROSOFT,
                          RAD_MICROSOFT_MS_CHAP_RESPONSE, &msresp,
                          sizeof msresp);
      what = "MSCHAP";
      break;

    case 0x81:
      if (klen != sizeof(*keyv2) + 1) {
        log_Printf(LogERROR, "CHAP81: Unrecognised key length %d\n", klen);
        rad_close(r->cx.rad);
        return 0;
      }

      keyv2 = (const struct MSCHAPv2_resp *)(key + 1);
      rad_put_vendor_attr(r->cx.rad, RAD_VENDOR_MICROSOFT,
                          RAD_MICROSOFT_MS_CHAP_CHALLENGE, nchallenge, nclen);
      msresp2.ident = *key;
      msresp2.flags = keyv2->Flags;
      memcpy(msresp2.response, keyv2->NTResponse, sizeof msresp2.response);
      memset(msresp2.reserved, '\0', sizeof msresp2.reserved);
      memcpy(msresp2.pchallenge, keyv2->PeerChallenge,
             sizeof msresp2.pchallenge);
      rad_put_vendor_attr(r->cx.rad, RAD_VENDOR_MICROSOFT,
                          RAD_MICROSOFT_MS_CHAP2_RESPONSE, &msresp2,
                          sizeof msresp2);
      what = "MSCHAPv2";
      break;
#endif
    default:
      log_Printf(LogERROR, "CHAP: Unrecognised type 0x%02x\n",
                 authp->physical->link.lcp.want_authtype);
      rad_close(r->cx.rad);
      return 0;
    }
  }

  if (gethostname(hostname, sizeof hostname) != 0)
    log_Printf(LogERROR, "rad_put: gethostname(): %s\n", strerror(errno));
  else {
    if (Enabled(authp->physical->dl->bundle, OPT_NAS_IP_ADDRESS) &&
        (hp = gethostbyname(hostname)) != NULL) {
      hostaddr.s_addr = *(u_long *)hp->h_addr;
      if (rad_put_addr(r->cx.rad, RAD_NAS_IP_ADDRESS, hostaddr) != 0) {
        log_Printf(LogERROR, "rad_put: rad_put_string: %s\n",
                   rad_strerror(r->cx.rad));
        rad_close(r->cx.rad);
        return 0;
      }
    }
    if (Enabled(authp->physical->dl->bundle, OPT_NAS_IDENTIFIER) &&
        rad_put_string(r->cx.rad, RAD_NAS_IDENTIFIER, hostname) != 0) {
      log_Printf(LogERROR, "rad_put: rad_put_string: %s\n",
                 rad_strerror(r->cx.rad));
      rad_close(r->cx.rad);
      return 0;
    }
  }

  if ((mac_addr = getenv("HISMACADDR")) != NULL &&
      rad_put_string(r->cx.rad, RAD_CALLING_STATION_ID, mac_addr) != 0) {
    log_Printf(LogERROR, "rad_put: %s\n", rad_strerror(r->cx.rad));
    rad_close(r->cx.rad);
    return 0;
  }

  radius_put_physical_details(r->cx.rad, authp->physical);

  log_Printf(LogRADIUS, "Radius(auth): %s data sent for %s\n", what, name);

  r->cx.auth = authp;
  if ((got = rad_init_send_request(r->cx.rad, &r->cx.fd, &tv)))
    radius_Process(r, got);
  else {
    log_Printf(log_IsKept(LogRADIUS) ? LogRADIUS : LogPHASE,
	       "Radius: Request sent\n");
    log_Printf(LogDEBUG, "Using radius_Timeout [%p]\n", radius_Timeout);
    r->cx.timer.load = tv.tv_usec / TICKUNIT + tv.tv_sec * SECTICKS;
    r->cx.timer.func = radius_Timeout;
    r->cx.timer.name = "radius auth";
    r->cx.timer.arg = r;
    timer_Start(&r->cx.timer);
  }

  return 1;
}

/* Fetch IP, netmask from IPCP */
void
radius_Account_Set_Ip(struct radacct *ac, struct in_addr *peer_ip,
		      struct in_addr *netmask)
{
  ac->proto = PROTO_IPCP;
  memcpy(&ac->peer.ip.addr, peer_ip, sizeof(ac->peer.ip.addr));
  memcpy(&ac->peer.ip.mask, netmask, sizeof(ac->peer.ip.mask));
}

#ifndef NOINET6
/* Fetch interface-id from IPV6CP */
void
radius_Account_Set_Ipv6(struct radacct *ac, u_char *ifid)
{
  ac->proto = PROTO_IPV6CP;
  memcpy(&ac->peer.ipv6.ifid, ifid, sizeof(ac->peer.ipv6.ifid));
}
#endif

/*
 * Send an accounting request to the RADIUS server
 */
void
radius_Account(struct radius *r, struct radacct *ac, struct datalink *dl,
               int acct_type, struct pppThroughput *stats)
{
  struct timeval tv;
  int got;
  char hostname[MAXHOSTNAMELEN];
  char *mac_addr;
  struct hostent *hp;
  struct in_addr hostaddr;

  if (!*r->cfg.file)
    return;

  if (r->cx.fd != -1)
    /*
     * We assume that our name/key/challenge is the same as last time,
     * and just continue to wait for the RADIUS server(s).
     */
    return;

  timer_Stop(&r->cx.timer);

  if ((r->cx.rad = rad_acct_open()) == NULL) {
    log_Printf(LogERROR, "rad_auth_open: %s\n", strerror(errno));
    return;
  }

  if (rad_config(r->cx.rad, r->cfg.file) != 0) {
    log_Printf(LogERROR, "rad_config: %s\n", rad_strerror(r->cx.rad));
    rad_close(r->cx.rad);
    return;
  }

  if (rad_create_request(r->cx.rad, RAD_ACCOUNTING_REQUEST) != 0) {
    log_Printf(LogERROR, "rad_create_request: %s\n", rad_strerror(r->cx.rad));
    rad_close(r->cx.rad);
    return;
  }

  /* Grab some accounting data and initialize structure */
  if (acct_type == RAD_START) {
    ac->rad_parent = r;
    /* Fetch username from datalink */
    strncpy(ac->user_name, dl->peer.authname, sizeof ac->user_name);
    ac->user_name[AUTHLEN-1] = '\0';

    ac->authentic = 2;		/* Assume RADIUS verified auth data */

    /* Generate a session ID */
    snprintf(ac->session_id, sizeof ac->session_id, "%s%ld-%s%lu",
             dl->bundle->cfg.auth.name, (long)getpid(),
             dl->peer.authname, (unsigned long)stats->uptime);

    /* And grab our MP socket name */
    snprintf(ac->multi_session_id, sizeof ac->multi_session_id, "%s",
             dl->bundle->ncp.mp.active ?
             dl->bundle->ncp.mp.server.socket.sun_path : "");
  };

  if (rad_put_string(r->cx.rad, RAD_USER_NAME, ac->user_name) != 0 ||
      rad_put_int(r->cx.rad, RAD_SERVICE_TYPE, RAD_FRAMED) != 0 ||
      rad_put_int(r->cx.rad, RAD_FRAMED_PROTOCOL, RAD_PPP) != 0) {
    log_Printf(LogERROR, "rad_put: %s\n", rad_strerror(r->cx.rad));
    rad_close(r->cx.rad);
    return;
  }
  switch (ac->proto) {
  case PROTO_IPCP:
    if (rad_put_addr(r->cx.rad, RAD_FRAMED_IP_ADDRESS,
		     ac->peer.ip.addr) != 0 ||
	rad_put_addr(r->cx.rad, RAD_FRAMED_IP_NETMASK,
		     ac->peer.ip.mask) != 0) {
      log_Printf(LogERROR, "rad_put: %s\n", rad_strerror(r->cx.rad));
      rad_close(r->cx.rad);
      return;
    }
    break;
#ifndef NOINET6
  case PROTO_IPV6CP:
    if (rad_put_attr(r->cx.rad, RAD_FRAMED_INTERFACE_ID, ac->peer.ipv6.ifid,
		     sizeof(ac->peer.ipv6.ifid)) != 0) {
      log_Printf(LogERROR, "rad_put_attr: %s\n", rad_strerror(r->cx.rad));
      rad_close(r->cx.rad);
      return;
    }
    if (r->ipv6prefix) {
      /*
       * Since PPP doesn't delegate an IPv6 prefix to a peer,
       * Framed-IPv6-Prefix may be not used, actually.
       */
      if (rad_put_attr(r->cx.rad, RAD_FRAMED_IPV6_PREFIX, r->ipv6prefix,
		       sizeof(struct in6_addr) + 2) != 0) {
	log_Printf(LogERROR, "rad_put_attr: %s\n", rad_strerror(r->cx.rad));
	rad_close(r->cx.rad);
	return;
      }
    }
    break;
#endif
  default:
    /* We don't log any protocol specific information */
    break;
   }

  if ((mac_addr = getenv("HISMACADDR")) != NULL &&
      rad_put_string(r->cx.rad, RAD_CALLING_STATION_ID, mac_addr) != 0) {
    log_Printf(LogERROR, "rad_put: %s\n", rad_strerror(r->cx.rad));
    rad_close(r->cx.rad);
    return;
  }

  if (gethostname(hostname, sizeof hostname) != 0)
    log_Printf(LogERROR, "rad_put: gethostname(): %s\n", strerror(errno));
  else {
    if (Enabled(dl->bundle, OPT_NAS_IP_ADDRESS) &&
        (hp = gethostbyname(hostname)) != NULL) {
      hostaddr.s_addr = *(u_long *)hp->h_addr;
      if (rad_put_addr(r->cx.rad, RAD_NAS_IP_ADDRESS, hostaddr) != 0) {
        log_Printf(LogERROR, "rad_put: rad_put_string: %s\n",
                   rad_strerror(r->cx.rad));
        rad_close(r->cx.rad);
        return;
      }
    }
    if (Enabled(dl->bundle, OPT_NAS_IDENTIFIER) &&
        rad_put_string(r->cx.rad, RAD_NAS_IDENTIFIER, hostname) != 0) {
      log_Printf(LogERROR, "rad_put: rad_put_string: %s\n",
                 rad_strerror(r->cx.rad));
      rad_close(r->cx.rad);
      return;
    }
  }

  radius_put_physical_details(r->cx.rad, dl->physical);

  if (rad_put_int(r->cx.rad, RAD_ACCT_STATUS_TYPE, acct_type) != 0 ||
      rad_put_string(r->cx.rad, RAD_ACCT_SESSION_ID, ac->session_id) != 0 ||
      rad_put_string(r->cx.rad, RAD_ACCT_MULTI_SESSION_ID,
                     ac->multi_session_id) != 0 ||
      rad_put_int(r->cx.rad, RAD_ACCT_DELAY_TIME, 0) != 0) {
/* XXX ACCT_DELAY_TIME should be increased each time a packet is waiting */
    log_Printf(LogERROR, "rad_put: %s\n", rad_strerror(r->cx.rad));
    rad_close(r->cx.rad);
    return;
  }

  if (acct_type == RAD_STOP || acct_type == RAD_ALIVE)
    /* Show some statistics */
    if (rad_put_int(r->cx.rad, RAD_ACCT_INPUT_OCTETS, stats->OctetsIn % UINT32_MAX) != 0 ||
        rad_put_int(r->cx.rad, RAD_ACCT_INPUT_GIGAWORDS, stats->OctetsIn / UINT32_MAX) != 0 ||
        rad_put_int(r->cx.rad, RAD_ACCT_INPUT_PACKETS, stats->PacketsIn) != 0 ||
        rad_put_int(r->cx.rad, RAD_ACCT_OUTPUT_OCTETS, stats->OctetsOut % UINT32_MAX) != 0 ||
        rad_put_int(r->cx.rad, RAD_ACCT_OUTPUT_GIGAWORDS, stats->OctetsOut / UINT32_MAX) != 0 ||
        rad_put_int(r->cx.rad, RAD_ACCT_OUTPUT_PACKETS, stats->PacketsOut)
        != 0 ||
        rad_put_int(r->cx.rad, RAD_ACCT_SESSION_TIME, throughput_uptime(stats))
        != 0) {
      log_Printf(LogERROR, "rad_put: %s\n", rad_strerror(r->cx.rad));
      rad_close(r->cx.rad);
      return;
    }

  if (log_IsKept(LogPHASE) || log_IsKept(LogRADIUS)) {
    char *what;
    int level;

    switch (acct_type) {
    case RAD_START:
      what = "START";
      level = log_IsKept(LogPHASE) ? LogPHASE : LogRADIUS;
      break;
    case RAD_STOP:
      what = "STOP";
      level = log_IsKept(LogPHASE) ? LogPHASE : LogRADIUS;
      break;
    case RAD_ALIVE:
      what = "ALIVE";
      level = LogRADIUS;
      break;
    default:
      what = "<unknown>";
      level = log_IsKept(LogPHASE) ? LogPHASE : LogRADIUS;
      break;
    }
    log_Printf(level, "Radius(acct): %s data sent\n", what);
  }

  r->cx.auth = NULL;			/* Not valid for accounting requests */
  if ((got = rad_init_send_request(r->cx.rad, &r->cx.fd, &tv)))
    radius_Process(r, got);
  else {
    log_Printf(LogDEBUG, "Using radius_Timeout [%p]\n", radius_Timeout);
    r->cx.timer.load = tv.tv_usec / TICKUNIT + tv.tv_sec * SECTICKS;
    r->cx.timer.func = radius_Timeout;
    r->cx.timer.name = "radius acct";
    r->cx.timer.arg = r;
    timer_Start(&r->cx.timer);
  }
}

/*
 * How do things look at the moment ?
 */
void
radius_Show(struct radius *r, struct prompt *p)
{
  prompt_Printf(p, " Radius config:     %s",
                *r->cfg.file ? r->cfg.file : "none");
  if (r->valid) {
    prompt_Printf(p, "\n                IP: %s\n", inet_ntoa(r->ip));
    prompt_Printf(p, "           Netmask: %s\n", inet_ntoa(r->mask));
    prompt_Printf(p, "               MTU: %lu\n", r->mtu);
    prompt_Printf(p, "                VJ: %sabled\n", r->vj ? "en" : "dis");
    prompt_Printf(p, "           Message: %s\n", r->repstr ? r->repstr : "");
    prompt_Printf(p, "   MPPE Enc Policy: %s\n",
                  radius_policyname(r->mppe.policy));
    prompt_Printf(p, "    MPPE Enc Types: %s\n",
                  radius_typesname(r->mppe.types));
    prompt_Printf(p, "     MPPE Recv Key: %seceived\n",
                  r->mppe.recvkey ? "R" : "Not r");
    prompt_Printf(p, "     MPPE Send Key: %seceived\n",
                  r->mppe.sendkey ? "R" : "Not r");
    prompt_Printf(p, " MS-CHAP2-Response: %s\n",
                  r->msrepstr ? r->msrepstr : "");
    prompt_Printf(p, "     Error Message: %s\n", r->errstr ? r->errstr : "");
    if (r->routes)
      route_ShowSticky(p, r->routes, "            Routes", 16);
#ifndef NOINET6
    if (r->ipv6routes)
      route_ShowSticky(p, r->ipv6routes, "            IPv6 Routes", 16);
#endif
  } else
    prompt_Printf(p, " (not authenticated)\n");
}

static void
radius_alive(void *v)
{
  struct bundle *bundle = (struct bundle *)v;

  timer_Stop(&bundle->radius.alive.timer);
  bundle->radius.alive.timer.load = bundle->radius.alive.interval * SECTICKS;
  if (bundle->radius.alive.timer.load) {
    radius_Account(&bundle->radius, &bundle->radacct,
                   bundle->links, RAD_ALIVE, &bundle->ncp.ipcp.throughput);
    timer_Start(&bundle->radius.alive.timer);
  }
}

void
radius_StartTimer(struct bundle *bundle)
{
  if (bundle->radius.cfg.file && bundle->radius.alive.interval) {
    bundle->radius.alive.timer.func = radius_alive;
    bundle->radius.alive.timer.name = "radius alive";
    bundle->radius.alive.timer.load = bundle->radius.alive.interval * SECTICKS;
    bundle->radius.alive.timer.arg = bundle;
    radius_alive(bundle);
  }
}

void
radius_StopTimer(struct radius *r)
{
  timer_Stop(&r->alive.timer);
}
@


1.36
log
@Add a radius_Flush() function that waits for the response (or timeout) to
any pending RADIUS transaction.  Use this before sending RAD_STOP RADIUS
messages so that we definitely ``stop'' the session.

It was discovered that sometimes when the link timed out, we got lucky
enough to have an un-ACK'd RADIUS accounting transaction in progress,
resulting in the RAD_STOP message failing to send.

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.35 2005/09/21 16:28:47 brad Exp $
@


1.35
log
@Support a ``set rad_alive N'' command to enable periodic RADIUS accounting
information being sent to the RADIUS server.

Logging of RADIUS accounting information moves to a ``set log [+-]radius''
level, along with the RADIUS alive info.

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.34 2005/09/21 15:04:29 brad Exp $
d683 19
@


1.34
log
@Send NAS-IP-Address as well as NAS-Identifier
Add ``disable NAS-IP-Address'' and ``disable NAS-Identifier'' options to
support pre-rfc2865 RADIUS servers.
This pushes our enable/disable items over the 32 bit limit, so reoganise
things to allow a bunch more options.

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.33 2005/09/21 14:08:51 brad Exp $
d271 2
a272 1
      log_Printf(LogPHASE, "Radius(%s): ACCEPT received\n", stype);
d280 2
a281 1
      log_Printf(LogPHASE, "Radius(%s): REJECT received\n", stype);
d290 2
a291 1
      log_Printf(LogPHASE, "Radius: CHALLENGE received (can't handle yet)\n");
d298 8
a305 1
      log_Printf(LogPHASE, "Radius(%s): Accounting response received\n", stype);
d314 2
a315 1
      log_Printf(LogPHASE, "radius(%s): %s\n", stype, rad_strerror(r->cx.rad));
d338 2
a339 1
        log_Printf(LogPHASE, " IP %s\n", inet_ntoa(r->ip));
d350 2
a351 1
        log_Printf(LogPHASE, " Filter \"%s\"\n", r->filterid);
d356 2
a357 1
        log_Printf(LogPHASE, " Session-Timeout %lu\n", r->sessiontime);
d362 2
a363 1
        log_Printf(LogPHASE, " Netmask %s\n", inet_ntoa(r->mask));
d368 2
a369 1
        log_Printf(LogPHASE, " MTU %lu\n", r->mtu);
d381 2
a382 1
        log_Printf(LogPHASE, " VJ %sabled\n", r->vj ? "en" : "dis");
d400 2
a401 1
        log_Printf(LogPHASE, " Route: %s\n", nuke);
d451 2
a452 1
        log_Printf(LogPHASE, " Reply-Message \"%s\"\n", r->repstr);
d460 2
a461 1
        log_Printf(LogPHASE, " IPv6 %s/%d\n", ipv6addr, r->ipv6prefix[1]);
d479 2
a480 1
        log_Printf(LogPHASE, " IPv6 Route: %s\n", nuke);
d552 2
a553 1
                  log_Printf(LogPHASE, " MS-CHAP-Error \"%s\"\n", r->errstr);
d580 2
a581 2
                  log_Printf(LogPHASE, " MS-CHAP2-Success \"%s\"\n",
                             r->msrepstr);
d587 2
a588 1
                log_Printf(LogPHASE, " MS-MPPE-Encryption-Policy %s\n",
d594 2
a595 1
                log_Printf(LogPHASE, " MS-MPPE-Encryption-Types %s\n",
d602 2
a603 1
                log_Printf(LogPHASE, " MS-MPPE-Recv-Key ********\n");
d608 2
a609 1
                log_Printf(LogPHASE, " MS-MPPE-Send-Key ********\n");
d657 2
a658 1
    log_Printf(LogPHASE, "Radius: Request re-sent\n");
d857 1
a857 1
  char *mac_addr;
d912 1
d925 1
d945 1
d967 1
d1009 2
d1015 2
a1016 1
    log_Printf(LogPHASE, "Radius: Request sent\n");
d1176 2
a1177 1
    if (rad_put_string(r->cx.rad, RAD_NAS_IDENTIFIER, hostname) != 0) {
d1198 2
a1199 2
  if (acct_type == RAD_STOP)
  /* Show some statistics */
d1214 25
d1285 32
@


1.33
log
@Avoid casts as lvalues.

From kan FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.32 2005/09/21 13:58:30 brad Exp $
a830 1
#if 0
a832 1
#endif
d950 2
a951 2
#if 0
    if ((hp = gethostbyname(hostname)) != NULL) {
d960 2
a961 2
#endif
    if (rad_put_string(r->cx.rad, RAD_NAS_IDENTIFIER, hostname) != 0) {
a1024 1
#if 0
a1026 1
#endif
d1132 2
a1133 2
#if 0
    if ((hp = gethostbyname(hostname)) != NULL) {
a1141 1
#endif
@


1.32
log
@If HISMACADDR is set in the environment, pass the value to
the RADIUS server as RAD_CALLING_STATION_ID.

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.31 2005/09/21 13:44:55 brad Exp $
d518 1
a518 1
                    ((const char *)data)++;
d545 1
a545 1
                    ((const char *)data)++;
@


1.31
log
@Send RADIUS gigaword data when OctetsIn or OctetsOut go over UINT32_MAX.

From dds FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.30 2005/09/21 02:07:25 brad Exp $
d830 1
d971 7
d1026 1
d1091 1
a1091 1
		     ac->peer.ip.addr) != 0 || \
d1125 7
@


1.30
log
@name union.

From ume FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.29 2005/09/21 01:59:26 brad Exp $
d97 4
d1154 2
a1155 1
    if (rad_put_int(r->cx.rad, RAD_ACCT_INPUT_OCTETS, stats->OctetsIn) != 0 ||
d1157 2
a1158 1
        rad_put_int(r->cx.rad, RAD_ACCT_OUTPUT_OCTETS, stats->OctetsOut) != 0 ||
@


1.29
log
@IPV6PREFIX is set when Framed-IPv6-Prefix is defined,  You may
want to pass the value to upper layer protocol such as DHCPv6
for prefix delegation.

From ume FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.28 2005/09/21 01:43:07 brad Exp $
d990 2
a991 2
  memcpy(&ac->ip.addr, peer_ip, sizeof(ac->ip.addr));
  memcpy(&ac->ip.mask, netmask, sizeof(ac->ip.mask));
d1000 1
a1000 1
  memcpy(&ac->ipv6.ifid, ifid, sizeof(ac->ipv6.ifid));
d1077 4
a1080 2
    if (rad_put_addr(r->cx.rad, RAD_FRAMED_IP_ADDRESS, ac->ip.addr) != 0 ||
	rad_put_addr(r->cx.rad, RAD_FRAMED_IP_NETMASK, ac->ip.mask) != 0) {
d1088 2
a1089 2
    if (rad_put_attr(r->cx.rad, RAD_FRAMED_INTERFACE_ID, ac->ipv6.ifid,
		     sizeof(ac->ipv6.ifid)) != 0) {
@


1.28
log
@Do RADIUS accounting on IPV6CP.

From ume FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.27 2005/09/21 01:16:05 brad Exp $
d222 19
d258 1
d433 7
d719 1
d752 4
d1091 12
@


1.27
log
@Install routes specified by Framed-IPv6-Route.  Since the format
of Framed-IPv6-Route is user defined, it follows Framed-IP-route.

From ume FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.26 2005/07/17 19:13:25 brad Exp $
d952 20
d977 1
a977 2
               int acct_type, struct in_addr *peer_ip, struct in_addr *netmask,
               struct pppThroughput *stats)
a1033 4

    /* Fetch IP, netmask from IPCP */
    memcpy(&ac->ip, peer_ip, sizeof(ac->ip));
    memcpy(&ac->mask, netmask, sizeof(ac->mask));
d1038 1
a1038 3
      rad_put_int(r->cx.rad, RAD_FRAMED_PROTOCOL, RAD_PPP) != 0 ||
      rad_put_addr(r->cx.rad, RAD_FRAMED_IP_ADDRESS, ac->ip) != 0 ||
      rad_put_addr(r->cx.rad, RAD_FRAMED_IP_NETMASK, ac->mask) != 0) {
d1043 23
@


1.26
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.25 2005/07/06 13:56:00 brad Exp $
d238 3
d362 1
d412 52
d691 3
d715 3
d1120 4
@


1.25
log
@Add a bunch of malloc() return checks

From brian FreeBSD

ok deraadt@@ tdeval@@
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.24 2003/08/06 21:08:08 millert Exp $
d52 1
@


1.24
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.23 2002/07/04 23:35:08 brian Exp $
d213 5
a217 2
  *buf = malloc(*len);
  memcpy(*buf, P + 1, *len);
@


1.23
log
@Back out the previous revision

Objected to by: Andre Oppermann <oppermann@@pipeline.ch>

After Andre's objection, I've re-examined rfc 2759 and noted that it
says that the domain name shouldn't be used when generating the
NT-Response field.  So it looks like the bug is in freeradius rather
than in ppp.
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.22 2002/07/03 20:52:24 brian Exp $
d638 1
a638 1
  *r->cfg.file = '\0';;
@


1.22
log
@If we've given a domain name prefix as the authentication name, strip
it off before passing it on to the RADIUS server for authentication.
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.21 2002/07/01 11:14:34 brian Exp $
a727 1
  const char *basename;
d767 1
a767 4
  /* Don't give any domain\ prefix from the name to the RADIUS server */
  basename = strchr(name, '\\');
  basename = basename ? basename + 1 : name;
  if (rad_put_string(r->cx.rad, RAD_USER_NAME, basename) != 0 ||
a896 1
  const char *name;
a932 4
    /* Don't give any domain\ prefix from the authname to the RADIUS server */
    name = strchr(dl->peer.authname, '\\');
    name = name ? name + 1 : dl->peer.authname;

d935 1
a935 1
    strncpy(ac->user_name, name, sizeof ac->user_name);
d943 1
a943 1
             name, (unsigned long)stats->uptime);
@


1.21
log
@Handle mis-formatted messages from RADIATOR (now fixed in RADIATOR)
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.20 2002/06/17 01:14:08 brian Exp $
d728 1
d768 4
a771 1
  if (rad_put_string(r->cx.rad, RAD_USER_NAME, name) != 0 ||
d901 1
d938 4
d944 1
a944 1
    strncpy(ac->user_name, dl->peer.authname, sizeof ac->user_name);
d952 1
a952 1
             dl->peer.authname, (unsigned long)stats->uptime);
@


1.20
log
@Compensate for dodgy Win98/WinME MSCHAPv2 responses later in the code
path... after we've talked to any RADIUS servers involved, so that we
haven't touched the data before it gets to the server.
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.19 2002/06/15 08:02:01 brian Exp $
d422 12
a433 2
                  if ((r->errstr = rad_cvt_string((const char *)data + 1,
                                                  len - 1)) == NULL) {
d449 12
a460 2
                  if ((r->msrepstr = rad_cvt_string((const char *)data + 1,
                                                    len - 1)) == NULL) {
@


1.19
log
@Tidy up end of line whitespace
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.18 2002/06/15 01:33:23 brian Exp $
d703 1
a703 1
                    int nclen, const char *pchallenge, int pclen)
d715 1
d798 1
a798 1
      if (klen != 50) {
d804 1
a804 7
      if (pclen != sizeof msresp2.pchallenge) {
        log_Printf(LogERROR, "CHAP81: Unrecognised peer challenge length %d\n",
                   pclen);
        rad_close(r->cx.rad);
        return 0;
      }

d808 2
a809 2
      msresp2.flags = 0x00;
      memcpy(msresp2.response, key + 25, 24);
d811 2
a812 1
      memcpy(msresp2.pchallenge, pchallenge, pclen);
@


1.18
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.17 2002/06/02 14:28:40 brian Exp $
d451 1
a451 1
 
d823 1
a823 1
      log_Printf(LogERROR, "CHAP: Unrecognised type 0x%02x\n", 
d874 1
a874 1
radius_Account(struct radius *r, struct radacct *ac, struct datalink *dl, 
d923 1
a923 1
 
d941 2
a942 2
      rad_put_int(r->cx.rad, RAD_FRAMED_PROTOCOL, RAD_PPP) != 0 || 
      rad_put_addr(r->cx.rad, RAD_FRAMED_IP_ADDRESS, ac->ip) != 0 || 
d974 1
a974 1
      rad_put_string(r->cx.rad, RAD_ACCT_SESSION_ID, ac->session_id) != 0 || 
d977 1
a977 1
      rad_put_int(r->cx.rad, RAD_ACCT_DELAY_TIME, 0) != 0) { 
@


1.17
log
@Don't send a RAD_NAS_IP_ADDRESS attribute as RAD_NAS_IDENTIFIER is
sufficient.
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.16 2002/05/27 23:22:20 deraadt Exp $
d31 1
d49 3
d111 105
d416 1
d419 12
a430 6
                if ((r->errstr = rad_cvt_string(data, len)) == NULL) {
                  log_Printf(LogERROR, "rad_cvt_string: %s\n",
                             rad_strerror(r->cx.rad));
                  auth_Failure(r->cx.auth);
                  rad_close(r->cx.rad);
                  return;
a431 1
                log_Printf(LogPHASE, " MS-CHAP-Error \"%s\"\n", r->errstr);
d436 13
a448 6
                if ((r->msrepstr = rad_cvt_string(data, len)) == NULL) {
                  log_Printf(LogERROR, "rad_cvt_string: %s\n",
                             rad_strerror(r->cx.rad));
                  auth_Failure(r->cx.auth);
                  rad_close(r->cx.rad);
                  return;
a449 1
                log_Printf(LogPHASE, " MS-CHAP2-Success \"%s\"\n", r->msrepstr);
d452 24
d612 6
d640 6
d710 1
a711 1
  struct in_addr hostaddr;
d883 1
a884 1
  struct in_addr hostaddr;
d896 1
a896 1
  radius_Destroy(r);
d1025 8
@


1.16
log
@and this one, brian
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.15 2002/05/16 14:27:21 brian Exp $
d551 1
d553 1
d676 1
d686 1
d724 1
d726 1
d795 1
d805 1
@


1.15
log
@Handle MS-CHAPv2 authentication correctly via the RADIUS server (if it's
configured).

This doesn't yet work with MPPE.  More to follow.
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.14 2002/05/16 01:13:39 brian Exp $
d762 2
a763 2
    snprintf(ac->session_id, sizeof ac->session_id, "%s%d-%s%lu",
             dl->bundle->cfg.auth.name, (int)getpid(),
@


1.14
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.13 2001/08/19 23:22:18 brian Exp $
d93 1
a93 1
struct mschap_request {
d99 8
d318 12
d464 1
d483 2
d543 1
a543 1
void
d545 2
a546 1
                    const char *key, int klen, const char *challenge, int clen)
d554 2
a555 1
  struct mschap_request msreq;
d559 1
a559 1
    return;
d566 1
a566 1
    return;
d572 1
a572 1
    return;
d578 1
a578 1
    return;
d584 1
a584 1
    return;
d592 1
a592 1
    return;
d602 1
a602 1
      return;
d610 1
a610 1
          rad_put_attr(r->cx.rad, RAD_CHAP_CHALLENGE, challenge, clen) != 0) {
d614 1
a614 1
        return;
d621 1
a621 1
        log_Printf(LogERROR, "CHAP80: Unrecognised length %d\n", klen);
d623 1
a623 1
        return;
d625 1
d627 5
a631 5
                          RAD_MICROSOFT_MS_CHAP_CHALLENGE, challenge, clen);
      msreq.ident = *key;
      msreq.flags = 0x01;
      memcpy(msreq.lm_response, key + 1, 24);
      memcpy(msreq.nt_response, key + 25, 24);
d633 2
a634 1
                          RAD_MICROSOFT_MS_CHAP_RESPONSE, &msreq, 50);
d638 24
d667 1
a667 1
      return;
d680 1
a680 1
        return;
d687 1
a687 1
      return;
d705 2
d860 2
@


1.13
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.12 2001/04/01 22:41:23 brian Exp $
d41 1
d44 1
a52 1
#include <ttyent.h>
d90 10
d109 1
a109 1
  int argc, addrs, width;
d115 1
a115 1
  u_int32_t ipaddr;
d132 5
a136 4
      if (r->cx.auth)
        auth_Failure(r->cx.auth);
      rad_close(r->cx.rad);
      return;
d171 1
a171 1
  /* So we've been accepted !  Let's see what we've got in our reply :-I */
d175 2
a176 2
  while ((got = rad_get_attr(r->cx.rad, &data, &len)) > 0) {
    switch (got) {
d179 17
a195 1
        log_Printf(LogPHASE, "        IP %s\n", inet_ntoa(r->ip));
d200 1
a200 1
        log_Printf(LogPHASE, "        Netmask %s\n", inet_ntoa(r->mask));
d205 1
a205 1
        log_Printf(LogPHASE, "        MTU %lu\n", r->mtu);
d217 1
a217 1
        log_Printf(LogPHASE, "        VJ %sabled\n", r->vj ? "en" : "dis");
d230 1
d235 1
a235 1
        log_Printf(LogPHASE, "        Route: %s\n", nuke);
d275 53
d331 1
a331 1
  if (got == -1) {
d335 3
a337 2
    rad_close(r->cx.rad);
  } else {
a339 1
    rad_close(r->cx.rad);
d341 1
a428 3
  r->valid = 0;
  r->cx.fd = -1;
  *r->cfg.file = '\0';;
d434 2
d437 10
d460 6
d472 45
a523 1
  struct ttyent *ttyp;
d525 1
a525 1
  int got, slot;
d529 3
d570 5
a574 5
  if (challenge != NULL) {
    /* We're talking CHAP */
    if (rad_put_attr(r->cx.rad, RAD_CHAP_PASSWORD, key, klen) != 0 ||
        rad_put_attr(r->cx.rad, RAD_CHAP_CHALLENGE, challenge, clen) != 0) {
      log_Printf(LogERROR, "CHAP: rad_put_string: %s\n",
d579 39
a617 5
  } else if (rad_put_attr(r->cx.rad, RAD_USER_PASSWORD, key, klen) != 0) {
    /* We're talking PAP */
    log_Printf(LogERROR, "PAP: rad_put_string: %s\n", rad_strerror(r->cx.rad));
    rad_close(r->cx.rad);
    return;
d640 1
a640 17
  if (authp->physical->handler &&
      authp->physical->handler->type == TTY_DEVICE) {
    setttyent();
    for (slot = 1; (ttyp = getttyent()); ++slot)
      if (!strcmp(ttyp->ty_name, authp->physical->name.base)) {
        if(rad_put_int(r->cx.rad, RAD_NAS_PORT, slot) != 0) {
          log_Printf(LogERROR, "rad_put: rad_put_string: %s\n",
                      rad_strerror(r->cx.rad));
          rad_close(r->cx.rad);
          endttyent();
          return;
        }
        break;
      }
    endttyent();
  }

a663 1
  struct ttyent *ttyp;
d665 1
a665 1
  int got, slot;
d753 1
a753 16
  if (dl->physical->handler &&
      dl->physical->handler->type == TTY_DEVICE) {
    setttyent();
    for (slot = 1; (ttyp = getttyent()); ++slot)
      if (!strcmp(ttyp->ty_name, dl->physical->name.base)) {
        if(rad_put_int(r->cx.rad, RAD_NAS_PORT, slot) != 0) {
          log_Printf(LogERROR, "rad_put: rad_put_string: %s\n",
                      rad_strerror(r->cx.rad));
          rad_close(r->cx.rad);
          endttyent();
          return;
        }
        break;
      }
    endttyent();
  }
d806 2
@


1.12
log
@Don't assume challenges and responses don't contain embedded '\0's.

Mschapv2 response generation may produce embedded NULs... causing
us to send a bogus response to the radius server and end up
failing the client's valid response.

Problem pointed out by: Eugene Vigovskiy <vigov@@com2com.ru>
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.11 2001/02/04 01:14:30 brian Exp $
d68 2
d71 1
d87 1
d98 1
a98 1
  int argc, addrs;
d100 2
a101 2
  struct in_range dest;
  struct in_addr gw;
d104 2
d208 2
a209 2
        dest.ipaddr.s_addr = dest.mask.s_addr = INADDR_ANY;
        dest.width = 0;
d218 2
a219 3
                  !ParseAddr(&bundle->ncp.ipcp, argv[0], &dest.ipaddr,
                             &dest.mask, &dest.width)) ||
                 !ParseAddr(&bundle->ncp.ipcp, argv[1], &gw, NULL, NULL))
d223 2
a224 1
          if (dest.width == 32 && strchr(argv[0], '/') == NULL)
d226 3
a228 1
            dest.mask = addr2mask(dest.ipaddr);
d236 1
a236 1
          if (gw.s_addr == INADDR_ANY) {
d238 1
a238 1
            gw = bundle->ncp.ipcp.peer_ip;
d242 1
a242 1
          route_Add(&r->routes, addrs, dest.ipaddr, dest.mask, gw);
@


1.11
log
@Don't send an authentication failure response if we fail sending
a radius accounting packet.
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.10 2001/01/26 01:41:04 brian Exp $
d371 1
a371 1
                    const char *key, const char *challenge)
d419 2
a420 2
    if (rad_put_string(r->cx.rad, RAD_CHAP_PASSWORD, key) != 0 ||
        rad_put_string(r->cx.rad, RAD_CHAP_CHALLENGE, challenge) != 0) {
d426 1
a426 1
  } else if (rad_put_string(r->cx.rad, RAD_USER_PASSWORD, key) != 0) {
@


1.10
log
@Allow ``set server closed'' to close the diagnostic socket.
Allow ``set server open'' to re-open the diagnostic socket.
Handle SIGUSR1 by re-opening the diagnostic socket
When receiving SIGUSR2 (and in ``set server none''), don't forget the
socket details so that ``set server open'' and SIGUSR1 open it again.

Don't create the diagnostic socket as uid 0 !  It's far to dangerous.
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.9 2000/11/02 00:54:34 brian Exp $
d99 1
d102 1
d106 5
a110 1
      log_Printf(LogPHASE, "Radius: ACCEPT received\n");
d114 3
a116 2
      log_Printf(LogPHASE, "Radius: REJECT received\n");
      auth_Failure(r->cx.auth);
d123 2
a124 1
      auth_Failure(r->cx.auth);
d129 4
a132 1
      log_Printf(LogPHASE, "Radius: Accounting response received\n");
d138 3
a140 2
      log_Printf(LogPHASE, "radius: %s\n", rad_strerror(r->cx.rad));
      auth_Failure(r->cx.auth);
d145 1
a145 1
      log_Printf(LogERROR, "rad_send_request: Failed %d: %s\n",
d147 2
a148 1
      auth_Failure(r->cx.auth);
d471 1
d479 1
a479 1
    r->cx.timer.name = "radius";
a480 1
    r->cx.auth = authp;
d625 1
d632 1
a632 1
    r->cx.timer.name = "radius";
a633 1
    r->cx.auth = NULL; /* Not valid for accounting requests */
@


1.9
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.8 2000/08/28 22:44:41 brian Exp $
d631 2
a632 1
  prompt_Printf(p, " Radius config: %s", *r->cfg.file ? r->cfg.file : "none");
d634 4
a637 4
    prompt_Printf(p, "\n            IP: %s\n", inet_ntoa(r->ip));
    prompt_Printf(p, "       Netmask: %s\n", inet_ntoa(r->mask));
    prompt_Printf(p, "           MTU: %lu\n", r->mtu);
    prompt_Printf(p, "            VJ: %sabled\n", r->vj ? "en" : "dis");
d639 1
a639 1
      route_ShowSticky(p, r->routes, "        Routes", 16);
@


1.8
log
@Support radius accounting, and add a packet count to throughput
statistics as a side effect.

Submitted by: Marcin Cieslak <saper@@system.pl>

with some tweaks to RAD_ACCT_SESSION_ID and
RAD_ACCT_MULTI_SESSION_ID generation by me.
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.7 2000/02/27 01:38:28 brian Exp $
d499 1
a499 1
  if ((r->cx.rad = rad_auth_open()) == NULL) {
@


1.7
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: radius.c,v 1.6 2000/02/27 00:21:09 brian Exp $
d120 6
d334 1
d344 1
d379 2
a380 2
  if ((r->cx.rad = rad_open()) == NULL) {
    log_Printf(LogERROR, "rad_open: %s\n", strerror(errno));
d468 153
@


1.6
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: radius.c,v 1.5 2000/01/07 03:26:55 brian Exp $
@


1.5
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: radius.c,v 1.4 1999/05/08 11:06:39 brian Exp $
d31 1
d37 7
a45 1
#include "radlib.h"
d267 1
a267 1
radius_Read(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
d273 1
a273 1
 * Behave as a struct descriptor (descriptor.h)
d276 1
a276 1
radius_UpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
d292 1
a292 1
 * Behave as a struct descriptor (descriptor.h)
d295 1
a295 1
radius_IsSet(struct descriptor *d, const fd_set *fdset)
d303 1
a303 1
 * Behave as a struct descriptor (descriptor.h)
d306 1
a306 1
radius_Write(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: radius.c,v 1.3 1999/04/21 08:12:16 brian Exp $
d44 3
d179 4
a182 1
        if (argc < 2)
d345 1
d347 4
a350 1
  int got;
d404 38
@


1.3
log
@int -> size_t
@
text
@d26 1
a26 1
 *	$Id: radius.c,v 1.2 1999/03/03 23:01:12 brian Exp $
d45 1
@


1.2
log
@Correct some ntohl/htonl bogons in the netmask handling.
This was pretty harmless as netmasks on a POINTOPOINT
interface are pretty much ignored, but it looked funny.

Mention the configured netmask in ``show ipcp''.

Describe in more detail what a proxy arp entry is.
@
text
@d26 1
a26 1
 *	$Id: radius.c,v 1.1 1999/02/06 03:22:44 brian Exp $
d83 2
a84 1
  int len, argc, addrs;
@


1.1
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: radius.c,v 1.2 1999/01/29 22:46:31 brian Exp $
d186 1
a186 1
            dest.mask.s_addr = addr2mask(dest.ipaddr.s_addr);
@

