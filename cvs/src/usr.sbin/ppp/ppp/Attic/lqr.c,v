head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.12
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.8
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.6
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.26
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.24
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.22
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.18
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.20
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.16
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.14
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.12
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.10
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.8
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.6
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.10
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.8
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.4
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.17;

1.17
date	2012.01.23.09.13.16;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.17.07.33.22;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.16.14.47.02;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.19.11.06.35;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.20.09.13.31;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.02.15.58.41;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.14.09.35.27;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.09.20.04.02;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.37;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.29.08.20.32;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.41;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.23;	author brian;	state Exp;
branches;
next	;


desc
@@


1.18
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: lqr.c,v 1.17 2012/01/23 09:13:16 nicm Exp $
 */

#include <sys/param.h>

#ifdef __FreeBSD__
#include <netinet/in.h>
#endif
#include <sys/un.h>

#include <string.h>
#include <termios.h>

#include "layer.h"
#include "mbuf.h"
#include "log.h"
#include "defs.h"
#include "timer.h"
#include "fsm.h"
#include "acf.h"
#include "proto.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "async.h"
#include "throughput.h"
#include "ccp.h"
#include "link.h"
#include "descriptor.h"
#include "physical.h"
#include "mp.h"
#include "chat.h"
#include "auth.h"
#include "chap.h"
#include "command.h"
#include "cbcp.h"
#include "datalink.h"

struct echolqr {
  u_int32_t magic;
  u_int32_t signature;
  u_int32_t sequence;
};

#define	SIGNATURE  0x594e4f54

static void
SendEchoReq(struct lcp *lcp)
{
  struct hdlc *hdlc = &link2physical(lcp->fsm.link)->hdlc;
  struct echolqr echo;

  echo.magic = htonl(lcp->want_magic);
  echo.signature = htonl(SIGNATURE);
  echo.sequence = htonl(hdlc->lqm.echo.seq_sent);
  fsm_Output(&lcp->fsm, CODE_ECHOREQ, hdlc->lqm.echo.seq_sent++,
            (u_char *)&echo, sizeof echo, MB_ECHOOUT);
}

struct mbuf *
lqr_RecvEcho(struct fsm *fp, struct mbuf *bp)
{
  struct hdlc *hdlc = &link2physical(fp->link)->hdlc;
  struct lcp *lcp = fsm2lcp(fp);
  struct echolqr lqr;

  if (m_length(bp) >= sizeof lqr) {
    m_freem(mbuf_Read(bp, &lqr, sizeof lqr));
    bp = NULL;
    lqr.magic = ntohl(lqr.magic);
    lqr.signature = ntohl(lqr.signature);
    lqr.sequence = ntohl(lqr.sequence);

    /* Tolerate echo replies with either magic number */
    if (lqr.magic != 0 && lqr.magic != lcp->his_magic &&
        lqr.magic != lcp->want_magic) {
      log_Printf(LogWARN, "%s: lqr_RecvEcho: Bad magic: expected 0x%08x,"
                 " got 0x%08x\n", fp->link->name, lcp->his_magic, lqr.magic);
      /*
       * XXX: We should send a terminate request. But poor implementations may
       *      die as a result.
       */
    }
    if (lqr.signature == SIGNATURE) {
      /* careful not to update lqm.echo.seq_recv with older values */
      if ((hdlc->lqm.echo.seq_recv > (u_int32_t)0 - 5 && lqr.sequence < 5) ||
          (hdlc->lqm.echo.seq_recv <= (u_int32_t)0 - 5 &&
           lqr.sequence > hdlc->lqm.echo.seq_recv))
        hdlc->lqm.echo.seq_recv = lqr.sequence;
    } else
      log_Printf(LogWARN, "lqr_RecvEcho: Got sig 0x%08lx, not 0x%08lx !\n",
                (u_long)lqr.signature, (u_long)SIGNATURE);
  } else
    log_Printf(LogWARN, "lqr_RecvEcho: Got packet size %d, expecting %ld !\n",
              m_length(bp), (long)sizeof(struct echolqr));
  return bp;
}

void
lqr_ChangeOrder(struct lqrdata *src, struct lqrdata *dst)
{
  u_int32_t *sp, *dp;
  int n;

  sp = (u_int32_t *) src;
  dp = (u_int32_t *) dst;
  for (n = 0; n < sizeof(struct lqrdata) / sizeof(u_int32_t); n++, sp++, dp++)
    *dp = ntohl(*sp);
}

static void
SendLqrData(struct lcp *lcp)
{
  struct mbuf *bp;
  int extra;

  extra = proto_WrapperOctets(lcp, PROTO_LQR) +
          acf_WrapperOctets(lcp, PROTO_LQR);
  bp = m_get(sizeof(struct lqrdata) + extra, MB_LQROUT);
  bp->m_len -= extra;
  bp->m_offset += extra;

  /*
   * Send on the highest priority queue.  We send garbage - the real data
   * is written by lqr_LayerPush() where we know how to fill in all the
   * fields.  Note, lqr_LayerPush() ``knows'' that we're pushing onto the
   * highest priority queue, and factors out packet & octet values from
   * other queues!
   */
  link_PushPacket(lcp->fsm.link, bp, lcp->fsm.bundle,
                  LINK_QUEUES(lcp->fsm.link) - 1, PROTO_LQR);
}

static void
SendLqrReport(void *v)
{
  struct lcp *lcp = (struct lcp *)v;
  struct physical *p = link2physical(lcp->fsm.link);

  timer_Stop(&p->hdlc.lqm.timer);

  if (p->hdlc.lqm.method & LQM_LQR) {
    if (p->hdlc.lqm.lqr.resent > 5) {
      /* XXX: Should implement LQM strategy */
      log_Printf(LogPHASE, "%s: ** Too many LQR packets lost **\n",
                lcp->fsm.link->name);
      log_Printf(LogLQM, "%s: Too many LQR packets lost\n",
                lcp->fsm.link->name);
      p->hdlc.lqm.method = 0;
      datalink_Down(p->dl, CLOSE_NORMAL);
    } else {
      SendLqrData(lcp);
      p->hdlc.lqm.lqr.resent++;
    }
  } else if (p->hdlc.lqm.method & LQM_ECHO) {
    if ((p->hdlc.lqm.echo.seq_sent > 5 &&
         p->hdlc.lqm.echo.seq_sent - 5 > p->hdlc.lqm.echo.seq_recv) ||
        (p->hdlc.lqm.echo.seq_sent <= 5 &&
         p->hdlc.lqm.echo.seq_sent > p->hdlc.lqm.echo.seq_recv + 5)) {
      log_Printf(LogPHASE, "%s: ** Too many LCP ECHO packets lost **\n",
                lcp->fsm.link->name);
      log_Printf(LogLQM, "%s: Too many LCP ECHO packets lost\n",
                lcp->fsm.link->name);
      p->hdlc.lqm.method = 0;
      datalink_Down(p->dl, CLOSE_NORMAL);
    } else
      SendEchoReq(lcp);
  }
  if (p->hdlc.lqm.method && p->hdlc.lqm.timer.load)
    timer_Start(&p->hdlc.lqm.timer);
}

struct mbuf *
lqr_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
{
  struct physical *p = link2physical(l);
  struct lcp *lcp = p->hdlc.lqm.owner;
  int len;

  if (p == NULL) {
    log_Printf(LogERROR, "lqr_Input: Not a physical link - dropped\n");
    m_freem(bp);
    return NULL;
  }

  len = m_length(bp);
  if (len != sizeof(struct lqrdata))
    log_Printf(LogWARN, "lqr_Input: Got packet size %d, expecting %ld !\n",
              len, (long)sizeof(struct lqrdata));
  else if (!IsAccepted(l->lcp.cfg.lqr) && !(p->hdlc.lqm.method & LQM_LQR)) {
    bp = m_pullup(proto_Prepend(bp, PROTO_LQR, 0, 0));
    lcp_SendProtoRej(lcp, MBUF_CTOP(bp), bp->m_len);
  } else {
    struct lqrdata *lqr;

    bp = m_pullup(bp);
    lqr = (struct lqrdata *)MBUF_CTOP(bp);
    if (ntohl(lqr->MagicNumber) != lcp->his_magic)
      log_Printf(LogWARN, "lqr_Input: magic 0x%08lx is wrong,"
                 " expecting 0x%08lx\n",
		 (u_long)ntohl(lqr->MagicNumber), (u_long)lcp->his_magic);
    else {
      struct lqrdata lastlqr;
 
      memcpy(&lastlqr, &p->hdlc.lqm.lqr.peer, sizeof lastlqr);
      lqr_ChangeOrder(lqr, &p->hdlc.lqm.lqr.peer);
      lqr_Dump(l->name, "Input", &p->hdlc.lqm.lqr.peer);
      /* we have received an LQR from our peer */
      p->hdlc.lqm.lqr.resent = 0;

      /* Snapshot our state when the LQR packet was received */
      memcpy(&p->hdlc.lqm.lqr.prevSave, &p->hdlc.lqm.lqr.Save,
             sizeof p->hdlc.lqm.lqr.prevSave);
      p->hdlc.lqm.lqr.Save.InLQRs = ++p->hdlc.lqm.lqr.InLQRs;
      p->hdlc.lqm.lqr.Save.InPackets = p->hdlc.lqm.ifInUniPackets;
      p->hdlc.lqm.lqr.Save.InDiscards = p->hdlc.lqm.ifInDiscards;
      p->hdlc.lqm.lqr.Save.InErrors = p->hdlc.lqm.ifInErrors;
      p->hdlc.lqm.lqr.Save.InOctets = p->hdlc.lqm.lqr.InGoodOctets;

      lqr_Analyse(&p->hdlc, &lastlqr, &p->hdlc.lqm.lqr.peer);

      /*
       * Generate an LQR response if we're not running an LQR timer OR
       * two successive LQR's PeerInLQRs are the same.
       */
      if (p->hdlc.lqm.timer.load == 0 || !(p->hdlc.lqm.method & LQM_LQR) ||
          (lastlqr.PeerInLQRs &&
           lastlqr.PeerInLQRs == p->hdlc.lqm.lqr.peer.PeerInLQRs))
        SendLqrData(lcp);
    }
  }
  m_freem(bp);
  return NULL;
}

/*
 *  When LCP is reached to opened state, We'll start LQM activity.
 */
static void
lqr_Setup(struct lcp *lcp)
{
  struct physical *physical = link2physical(lcp->fsm.link);
  int period;

  physical->hdlc.lqm.lqr.resent = 0;
  physical->hdlc.lqm.echo.seq_sent = 0;
  physical->hdlc.lqm.echo.seq_recv = 0;
  memset(&physical->hdlc.lqm.lqr.peer, '\0',
         sizeof physical->hdlc.lqm.lqr.peer);

  physical->hdlc.lqm.method = lcp->cfg.echo ? LQM_ECHO : 0;
  if (IsEnabled(lcp->cfg.lqr) && !REJECTED(lcp, TY_QUALPROTO))
    physical->hdlc.lqm.method |= LQM_LQR;
  timer_Stop(&physical->hdlc.lqm.timer);

  physical->hdlc.lqm.lqr.peer_timeout = lcp->his_lqrperiod;
  if (lcp->his_lqrperiod)
    log_Printf(LogLQM, "%s: Expecting LQR every %d.%02d secs\n",
              physical->link.name, lcp->his_lqrperiod / 100,
              lcp->his_lqrperiod % 100);

  period = lcp->want_lqrperiod ?
    lcp->want_lqrperiod : lcp->cfg.lqrperiod * 100;
  physical->hdlc.lqm.timer.func = SendLqrReport;
  physical->hdlc.lqm.timer.name = "lqm";
  physical->hdlc.lqm.timer.arg = lcp;

  if (lcp->want_lqrperiod || physical->hdlc.lqm.method & LQM_ECHO) {
    log_Printf(LogLQM, "%s: Will send %s every %d.%02d secs\n",
              physical->link.name, lcp->want_lqrperiod ? "LQR" : "LCP ECHO",
              period / 100, period % 100);
    physical->hdlc.lqm.timer.load = period * SECTICKS / 100;
  } else {
    physical->hdlc.lqm.timer.load = 0;
    if (!lcp->his_lqrperiod)
      log_Printf(LogLQM, "%s: LQR/LCP ECHO not negotiated\n",
                 physical->link.name);
  }
}

void
lqr_Start(struct lcp *lcp)
{
  struct physical *p = link2physical(lcp->fsm.link);

  lqr_Setup(lcp);
  if (p->hdlc.lqm.timer.load)
    SendLqrReport(lcp);
}

void
lqr_reStart(struct lcp *lcp)
{
  struct physical *p = link2physical(lcp->fsm.link);

  lqr_Setup(lcp);
  if (p->hdlc.lqm.timer.load)
    timer_Start(&p->hdlc.lqm.timer);
}

void
lqr_StopTimer(struct physical *physical)
{
  timer_Stop(&physical->hdlc.lqm.timer);
}

void
lqr_Stop(struct physical *physical, int method)
{
  if (method == LQM_LQR)
    log_Printf(LogLQM, "%s: Stop sending LQR, Use LCP ECHO instead.\n",
               physical->link.name);
  if (method == LQM_ECHO)
    log_Printf(LogLQM, "%s: Stop sending LCP ECHO.\n",
               physical->link.name);
  physical->hdlc.lqm.method &= ~method;
  if (physical->hdlc.lqm.method)
    SendLqrReport(physical->hdlc.lqm.owner);
  else
    timer_Stop(&physical->hdlc.lqm.timer);
}

void
lqr_Dump(const char *link, const char *message, const struct lqrdata *lqr)
{
  if (log_IsKept(LogLQM)) {
    log_Printf(LogLQM, "%s: %s:\n", link, message);
    log_Printf(LogLQM, "  Magic:          %08x   LastOutLQRs:    %08x\n",
	      lqr->MagicNumber, lqr->LastOutLQRs);
    log_Printf(LogLQM, "  LastOutPackets: %08x   LastOutOctets:  %08x\n",
	      lqr->LastOutPackets, lqr->LastOutOctets);
    log_Printf(LogLQM, "  PeerInLQRs:     %08x   PeerInPackets:  %08x\n",
	      lqr->PeerInLQRs, lqr->PeerInPackets);
    log_Printf(LogLQM, "  PeerInDiscards: %08x   PeerInErrors:   %08x\n",
	      lqr->PeerInDiscards, lqr->PeerInErrors);
    log_Printf(LogLQM, "  PeerInOctets:   %08x   PeerOutLQRs:    %08x\n",
	      lqr->PeerInOctets, lqr->PeerOutLQRs);
    log_Printf(LogLQM, "  PeerOutPackets: %08x   PeerOutOctets:  %08x\n",
	      lqr->PeerOutPackets, lqr->PeerOutOctets);
  }
}

void
lqr_Analyse(const struct hdlc *hdlc, const struct lqrdata *oldlqr,
            const struct lqrdata *newlqr)
{
  u_int32_t LQRs, transitLQRs, pkts, octets, disc, err;

  if (!newlqr->PeerInLQRs)	/* No analysis possible yet! */
    return;

  log_Printf(LogLQM, "Analysis:\n");

  LQRs = (newlqr->LastOutLQRs - oldlqr->LastOutLQRs) -
         (newlqr->PeerInLQRs - oldlqr->PeerInLQRs);
  transitLQRs = hdlc->lqm.lqr.OutLQRs - newlqr->LastOutLQRs;
  pkts = (newlqr->LastOutPackets - oldlqr->LastOutPackets) -
         (newlqr->PeerInPackets - oldlqr->PeerInPackets);
  octets = (newlqr->LastOutOctets - oldlqr->LastOutOctets) -
           (newlqr->PeerInOctets - oldlqr->PeerInOctets);
  log_Printf(LogLQM, "  Outbound lossage: %d LQR%s (%d en route), %d packet%s,"
             " %d octet%s\n", (int)LQRs, LQRs == 1 ? "" : "s", (int)transitLQRs,
	     (int)pkts, pkts == 1 ? "" : "s",
	     (int)octets, octets == 1 ? "" : "s");

  pkts = (newlqr->PeerOutPackets - oldlqr->PeerOutPackets) -
    (hdlc->lqm.lqr.Save.InPackets - hdlc->lqm.lqr.prevSave.InPackets);
  octets = (newlqr->PeerOutOctets - oldlqr->PeerOutOctets) -
    (hdlc->lqm.lqr.Save.InOctets - hdlc->lqm.lqr.prevSave.InOctets);
  log_Printf(LogLQM, "  Inbound lossage: %d packet%s, %d octet%s\n",
	     (int)pkts, pkts == 1 ? "" : "s",
	     (int)octets, octets == 1 ? "" : "s");

  disc = newlqr->PeerInDiscards - oldlqr->PeerInDiscards;
  err = newlqr->PeerInErrors - oldlqr->PeerInErrors;
  if (disc && err)
    log_Printf(LogLQM, "                   Likely due to both peer congestion"
               " and physical errors\n");
  else if (disc)
    log_Printf(LogLQM, "                   Likely due to peer congestion\n");
  else if (err)
    log_Printf(LogLQM, "                   Likely due to physical errors\n");
  else if (pkts)
    log_Printf(LogLQM, "                   Likely due to transport "
	       "congestion\n");
}

static struct mbuf *
lqr_LayerPush(struct bundle *b, struct link *l, struct mbuf *bp,
              int pri, u_short *proto)
{
  struct physical *p = link2physical(l);
  int len, layer;

  if (!p) {
    /* Oops - can't happen :-] */
    m_freem(bp);
    return NULL;
  }

  bp = m_pullup(bp);
  len = m_length(bp);

  /*-
   * From rfc1989:
   *
   *  All octets which are included in the FCS calculation MUST be counted,
   *  including the packet header, the information field, and any padding.
   *  The FCS octets MUST also be counted, and one flag octet per frame
   *  MUST be counted.  All other octets (such as additional flag
   *  sequences, and escape bits or octets) MUST NOT be counted.
   *
   * As we're stacked higher than the HDLC layer (otherwise HDLC wouldn't be
   * able to calculate the FCS), we must not forget about these additional
   * bytes when we're asynchronous.
   *
   * We're also expecting to be stacked *before* the likes of the proto and
   * acf layers (to avoid alignment issues), so deal with this too.
   */

  p->hdlc.lqm.ifOutUniPackets++;
  p->hdlc.lqm.ifOutOctets += len + 1;		/* plus 1 flag octet! */
  for (layer = 0; layer < l->nlayers; layer++)
    switch (l->layer[layer]->type) {
      case LAYER_ACF:
        p->hdlc.lqm.ifOutOctets += acf_WrapperOctets(&l->lcp, *proto);
        break;
      case LAYER_ASYNC:
        /* Not included - see rfc1989 */
        break;
      case LAYER_HDLC:
        p->hdlc.lqm.ifOutOctets += hdlc_WrapperOctets(&l->lcp, *proto);
        break;
      case LAYER_LQR:
        layer = l->nlayers;
        break;
      case LAYER_PROTO:
        p->hdlc.lqm.ifOutOctets += proto_WrapperOctets(&l->lcp, *proto);
        break;
      case LAYER_SYNC:
        /* Nothing to add on */
        break;
      default:
        log_Printf(LogWARN, "Oops, don't know how to do octets for %s layer\n",
                   l->layer[layer]->name);
        break;
    }

  if (*proto == PROTO_LQR) {
    /* Overwrite the entire packet (created in SendLqrData()) */
    struct lqrdata lqr;
    size_t pending_pkts, pending_octets;
 
    p->hdlc.lqm.lqr.OutLQRs++;

    /*
     * We need to compensate for the fact that we're pushing our data
     * onto the highest priority queue by factoring out packet & octet
     * values from other queues!
     */
    link_PendingLowPriorityData(l, &pending_pkts, &pending_octets);

    memset(&lqr, '\0', sizeof lqr);
    lqr.MagicNumber = p->link.lcp.want_magic;
    lqr.LastOutLQRs = p->hdlc.lqm.lqr.peer.PeerOutLQRs;
    lqr.LastOutPackets = p->hdlc.lqm.lqr.peer.PeerOutPackets;
    lqr.LastOutOctets = p->hdlc.lqm.lqr.peer.PeerOutOctets;
    lqr.PeerInLQRs = p->hdlc.lqm.lqr.Save.InLQRs;
    lqr.PeerInPackets = p->hdlc.lqm.lqr.Save.InPackets;
    lqr.PeerInDiscards = p->hdlc.lqm.lqr.Save.InDiscards;
    lqr.PeerInErrors = p->hdlc.lqm.lqr.Save.InErrors;
    lqr.PeerInOctets = p->hdlc.lqm.lqr.Save.InOctets;
    lqr.PeerOutLQRs = p->hdlc.lqm.lqr.OutLQRs;
    lqr.PeerOutPackets = p->hdlc.lqm.ifOutUniPackets - pending_pkts;
    /* Don't forget our ``flag'' octets.... */
    lqr.PeerOutOctets = p->hdlc.lqm.ifOutOctets - pending_octets - pending_pkts;
    lqr_Dump(l->name, "Output", &lqr);
    lqr_ChangeOrder(&lqr, (struct lqrdata *)MBUF_CTOP(bp));
  }

  return bp;
}

static struct mbuf *
lqr_LayerPull(struct bundle *b, struct link *l, struct mbuf *bp, u_short *proto)
{
  /*
   * This is the ``Rx'' process from rfc1989, although a part of it is
   * actually performed by sync_LayerPull() & hdlc_LayerPull() so that
   * our octet counts are correct.
   */

  if (*proto == PROTO_LQR)
    m_settype(bp, MB_LQRIN);
  return bp;
}

/*
 * Statistics for pulled packets are recorded either in hdlc_PullPacket()
 * or sync_PullPacket()
 */

struct layer lqrlayer = { LAYER_LQR, "lqr", lqr_LayerPush, lqr_LayerPull };
@


1.17
log
@Trim unused variables, from Michael W. Bombardieri.

ok yasuoka
@
text
@d28 1
a28 1
 * $OpenBSD: lqr.c,v 1.16 2005/07/17 07:33:22 brad Exp $
@


1.16
log
@Implement an ``enable/disable echo'' option, defaults to off.
This allows LCP ECHOs to be enabled independently of LQR reports.

Note: This introduces a change in the default behaviour (search for lqr and
echo in the man page).

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: lqr.c,v 1.15 2004/11/16 14:47:02 brad Exp $
d420 1
a420 1
  int len, layer, extra_async_bytes;
a447 1
  extra_async_bytes = 0;
@


1.15
log
@Re-implement LQM, this time according to the rfc.

From FreeBSD

ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: lqr.c,v 1.14 2002/06/15 08:02:00 brian Exp $
d187 1
a187 1
      log_Printf(LogPHASE, "%s: ** Too many ECHO LQR packets lost **\n",
d189 1
a189 1
      log_Printf(LogLQM, "%s: Too many ECHO LQR packets lost\n",
a265 1

d270 1
d278 1
a278 1
  physical->hdlc.lqm.method = LQM_ECHO;
d289 7
a295 1
  if (lcp->want_lqrperiod) {
d297 3
a299 7
              physical->link.name,
              physical->hdlc.lqm.method & LQM_LQR ? "LQR" : "ECHO LQR",
              lcp->want_lqrperiod / 100, lcp->want_lqrperiod % 100);
    physical->hdlc.lqm.timer.load = lcp->want_lqrperiod * SECTICKS / 100;
    physical->hdlc.lqm.timer.func = SendLqrReport;
    physical->hdlc.lqm.timer.name = "lqm";
    physical->hdlc.lqm.timer.arg = lcp;
d303 1
a303 1
      log_Printf(LogLQM, "%s: LQR/ECHO LQR not negotiated\n",
@


1.14
log
@Tidy up end of line whitespace
@
text
@d28 1
a28 1
 * $OpenBSD: lqr.c,v 1.13 2002/05/16 01:13:39 brian Exp $
d149 8
a212 2
  p->hdlc.lqm.lqr.SaveInLQRs++;

a221 1
    u_int32_t lastLQR;
d230 3
a232 5
      /*
       * Remember our PeerInLQRs, then convert byte order and save
       */
      lastLQR = p->hdlc.lqm.lqr.peer.PeerInLQRs;

d235 1
a235 1
      /* we have received an LQR from peer */
d238 11
d251 1
a251 2
       * two successive LQR's PeerInLQRs are the same OR we're not going to
       * send our next one before the peers max timeout.
d253 3
a255 6
      if (p->hdlc.lqm.timer.load == 0 ||
          !(p->hdlc.lqm.method & LQM_LQR) ||
          (lastLQR && lastLQR == p->hdlc.lqm.lqr.peer.PeerInLQRs) ||
          (p->hdlc.lqm.lqr.peer_timeout &&
           p->hdlc.lqm.timer.rest * 100 / SECTICKS >
           p->hdlc.lqm.lqr.peer_timeout))
d368 45
d418 1
a418 1
  int len;
d426 4
a429 1
  /*
d438 1
a438 1
   * As we're stacked before the HDLC layer (otherwise HDLC wouldn't be
d442 2
a443 3
   * We're also expecting to be stacked *before* the proto and acf layers.
   * If we were after these, it makes alignment more of a pain, and we
   * don't do LQR without these layers.
d446 28
a473 8
  bp = m_pullup(bp);
  len = m_length(bp);

  if (!physical_IsSync(p))
    p->hdlc.lqm.OutOctets += hdlc_WrapperOctets(&l->lcp, *proto);
  p->hdlc.lqm.OutOctets += acf_WrapperOctets(&l->lcp, *proto) +
                           proto_WrapperOctets(&l->lcp, *proto) + len + 1;
  p->hdlc.lqm.OutPackets++;
d478 10
d489 1
d494 10
a503 18
    lqr.PeerInLQRs = p->hdlc.lqm.lqr.SaveInLQRs;
    lqr.PeerInPackets = p->hdlc.lqm.SaveInPackets;
    lqr.PeerInDiscards = p->hdlc.lqm.SaveInDiscards;
    lqr.PeerInErrors = p->hdlc.lqm.SaveInErrors;
    lqr.PeerInOctets = p->hdlc.lqm.SaveInOctets;
    lqr.PeerOutPackets = p->hdlc.lqm.OutPackets;
    lqr.PeerOutOctets = p->hdlc.lqm.OutOctets;
    if (p->hdlc.lqm.lqr.peer.LastOutLQRs == p->hdlc.lqm.lqr.OutLQRs) {
      /*
       * only increment if it's the first time or we've got a reply
       * from the last one
       */
      lqr.PeerOutLQRs = ++p->hdlc.lqm.lqr.OutLQRs;
      lqr_Dump(l->name, "Output", &lqr);
    } else {
      lqr.PeerOutLQRs = p->hdlc.lqm.lqr.OutLQRs;
      lqr_Dump(l->name, "Output (again)", &lqr);
    }
d514 3
a516 2
   * We mark the packet as ours but don't do anything 'till it's dispatched
   * to lqr_Input()
d518 1
@


1.13
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: lqr.c,v 1.12 2001/06/13 21:33:41 brian Exp $
d243 1
a243 1
          (p->hdlc.lqm.lqr.peer_timeout && 
@


1.12
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d32 4
@


1.11
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d1 26
a26 2
/*
 *	      PPP Line Quality Monitoring (LQM) Module
d28 1
a28 23
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
 *
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: lqr.c,v 1.10 2000/06/20 09:13:31 brian Exp $
 *
 *	o LQR based on RFC1333
 *
 * TODO:
 *	o LQM policy
 *	o Allow user to configure LQM method and interval.
@


1.10
log
@Allow padding in LQR ECHO requests

Problem found by: Tomaz Borstnar <tomaz.borstnar@@over.net>
@
text
@d20 1
a20 1
 * $OpenBSD: lqr.c,v 1.9 2000/02/27 01:38:27 brian Exp $
a42 1
#include "lcp.h"
d45 1
@


1.9
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: lqr.c,v 1.8 2000/01/07 03:26:54 brian Exp $
d88 3
a90 2
  if (m_length(bp) == sizeof lqr) {
    bp = mbuf_Read(bp, &lqr, sizeof lqr);
@


1.8
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: lqr.c,v 1.7 1999/06/02 15:58:41 brian Exp $
@


1.7
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d20 1
a20 1
 * $Id: lqr.c,v 1.6 1999/05/14 09:35:27 brian Exp $
d88 1
a88 1
  if (mbuf_Length(bp) == sizeof lqr) {
d112 1
a112 1
                (u_long)ntohl(lqr.signature), (u_long)SIGNATURE);
d115 1
a115 1
              mbuf_Length(bp), (long)sizeof(struct echolqr));
d139 5
a143 4
  bp = mbuf_Alloc(sizeof(struct lqrdata) + extra, MB_LQROUT);
  bp->cnt -= extra;
  bp->offset += extra;
  link_PushPacket(lcp->fsm.link, bp, lcp->fsm.bundle, PRI_LINK, PROTO_LQR);
d194 1
a194 1
    mbuf_Free(bp);
d200 1
a200 1
  len = mbuf_Length(bp);
d205 2
a206 2
    bp = mbuf_Contiguous(proto_Prepend(bp, PROTO_LQR, 0, 0));
    lcp_SendProtoRej(lcp, MBUF_CTOP(bp), bp->cnt);
d211 1
a211 1
    bp = mbuf_Contiguous(bp);
d242 1
a242 1
  mbuf_Free(bp);
d360 1
a360 1
    mbuf_Free(bp);
d382 2
a383 2
  bp = mbuf_Contiguous(bp);
  len = mbuf_Length(bp);
d431 1
a431 1
    mbuf_SetType(bp, MB_LQRIN);
@


1.6
log
@Handle LCP echo reqs properly again (broken with the
layering changes).
@
text
@d20 1
a20 1
 * $Id: lqr.c,v 1.5 1999/05/09 20:04:02 brian Exp $
d78 1
a78 1
            (u_char *)&echo, sizeof echo);
d135 1
d137 5
a141 1
  bp = mbuf_Alloc(sizeof(struct lqrdata), MB_LQR);
d391 1
a391 1
    /* Overwrite the entire packet */
d422 12
d439 1
a439 1
struct layer lqrlayer = { LAYER_LQR, "lqr", lqr_LayerPush, NULL };
@


1.5
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d20 1
a20 1
 * $Id: lqr.c,v 1.4 1999/05/08 11:06:37 brian Exp $
d85 1
a86 1
  u_int32_t seq;
d89 16
a104 3
    mbuf_Read(bp, &lqr, sizeof lqr);
    if (ntohl(lqr.signature) == SIGNATURE) {
      seq = ntohl(lqr.sequence);
d106 1
a106 1
      if ((hdlc->lqm.echo.seq_recv > (u_int32_t)0 - 5 && seq < 5) ||
d108 2
a109 2
           seq > hdlc->lqm.echo.seq_recv))
        hdlc->lqm.echo.seq_recv = seq;
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: lqr.c,v 1.3 1999/03/29 08:20:32 brian Exp $
d81 2
a82 2
void
lqr_RecvEcho(struct fsm *fp, struct mbuf * bp)
d85 1
a85 1
  struct echolqr *lqr;
d88 4
a91 4
  if (mbuf_Length(bp) == sizeof(struct echolqr)) {
    lqr = (struct echolqr *) MBUF_CTOP(bp);
    if (ntohl(lqr->signature) == SIGNATURE) {
      seq = ntohl(lqr->sequence);
d99 1
a99 1
                (u_long)ntohl(lqr->signature), (u_long)SIGNATURE);
d103 1
d107 1
a107 1
lqr_ChangeOrder(struct lqrdata * src, struct lqrdata * dst)
@


1.3
log
@Ensure that the thing we're casting to struct ip
is aligned for non-i386 architectures.
@
text
@d20 1
a20 1
 * $Id: lqr.c,v 1.2 1999/02/06 03:22:41 brian Exp $
d35 1
d41 2
a42 1
#include "lcpproto.h"
d113 2
a114 2
  for (n = 0; n < sizeof(struct lqrdata) / sizeof(u_int32_t); n++)
    *dp++ = ntohl(*sp++);
d123 1
a123 1
  hdlc_Output(lcp->fsm.link, PRI_LINK, PROTO_LQR, bp);
d165 2
a166 2
void
lqr_Input(struct physical *physical, struct mbuf *bp)
d168 2
d172 8
d184 3
a186 5
  else if (!IsAccepted(physical->link.lcp.cfg.lqr) &&
           !(physical->hdlc.lqm.method & LQM_LQR)) {
    bp->offset -= 2;	/* XXX: We have a bit too much knowledge here ! */
    bp->cnt += 2;
    lcp_SendProtoRej(physical->hdlc.lqm.owner, MBUF_CTOP(bp), bp->cnt);
a188 1
    struct lcp *lcp;
d193 1
a193 2
    lcp = physical->hdlc.lqm.owner;
    if (ntohl(lqr->MagicNumber) != physical->hdlc.lqm.owner->his_magic)
d196 1
a196 2
		 (u_long)ntohl(lqr->MagicNumber),
                 (u_long)physical->hdlc.lqm.owner->his_magic);
d201 1
a201 1
      lastLQR = physical->hdlc.lqm.lqr.peer.PeerInLQRs;
d203 2
a204 2
      lqr_ChangeOrder(lqr, &physical->hdlc.lqm.lqr.peer);
      lqr_Dump(physical->link.name, "Input", &physical->hdlc.lqm.lqr.peer);
d206 1
a206 1
      physical->hdlc.lqm.lqr.resent = 0;
d213 7
a219 7
      if (physical->hdlc.lqm.timer.load == 0 ||
          !(physical->hdlc.lqm.method & LQM_LQR) ||
          (lastLQR && lastLQR == physical->hdlc.lqm.lqr.peer.PeerInLQRs) ||
          (physical->hdlc.lqm.lqr.peer_timeout && 
           physical->hdlc.lqm.timer.rest * 100 / SECTICKS >
           physical->hdlc.lqm.lqr.peer_timeout))
        SendLqrData(physical->hdlc.lqm.owner);
d223 1
d330 79
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: lqr.c,v 1.31 1999/01/28 01:56:33 brian Exp $
d174 1
a174 1
    bp->offset -= 2;
d182 1
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: lqr.c,v 1.30 1998/08/07 18:42:49 brian Exp $
d29 1
a29 1
#include <sys/types.h>
@

