head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.44
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.40
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.38
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.36
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.34
	OPENBSD_5_0:1.20.0.32
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.30
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.28
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.24
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.26
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.22
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.20
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.18
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.16
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.14
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.12
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.10
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.8
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.6
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.4
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12;
locks; strict;
comment	@ * @;


1.21
date	2014.03.17.17.15.52;	author deraadt;	state dead;
branches;
next	1.20;

1.20
date	2003.10.20.03.15.38;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.04.20.25.06;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.19.10.25.00;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.02.00.54.35;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.27.01.38.29;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.07.03.26.56;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.08.10.10.50.44;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.07.15.02.04.07;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.06.05.21.36.03;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.05.27.08.44.59;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.05.24.16.39.19;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.18.01.37.51;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.16.11.58.38;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.13.19.29.37;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.05.13.16.33.56;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.12.10.03.54;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.08.11.06.40;	author brian;	state Exp;
branches;
next	;


desc
@@


1.21
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1999 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: tty.c,v 1.20 2003/10/20 03:15:38 deraadt Exp $
 */

#include <sys/param.h>
#include <sys/un.h>
#if defined(__OpenBSD__) || defined(__NetBSD__)
#include <sys/ioctl.h>
#endif

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>
#include <sys/uio.h>
#include <termios.h>
#include <ttyent.h>
#include <unistd.h>
#ifndef NONETGRAPH
#include <netgraph.h>
#include <netgraph/ng_async.h>
#include <netgraph/ng_message.h>
#include <netgraph/ng_ppp.h>
#include <netgraph/ng_tty.h>
#endif

#include "layer.h"
#include "defs.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "fsm.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "async.h"
#include "descriptor.h"
#include "physical.h"
#include "mp.h"
#include "chat.h"
#include "auth.h"
#include "chap.h"
#include "cbcp.h"
#include "datalink.h"
#include "main.h"
#include "id.h"
#include "tty.h"

#if defined(__mac68k__) || defined(__macppc__)
#undef	CRTS_IFLOW
#undef	CCTS_OFLOW
#define	CRTS_IFLOW	CDTRCTS
#define	CCTS_OFLOW	CDTRCTS
#endif

#define	Online(dev)	((dev)->mbits & TIOCM_CD)

struct ttydevice {
  struct device dev;		/* What struct physical knows about */
  struct pppTimer Timer;	/* CD checks */
  int mbits;			/* Current DCD status */
  int carrier_seconds;		/* seconds before CD is *required* */
#ifndef NONETGRAPH
  struct {
    int speed;			/* Pre-line-discipline speed */
    int fd;			/* Pre-line-discipline fd */
    int disc;			/* Old line-discipline */
  } real;
  char hook[sizeof NG_ASYNC_HOOK_SYNC]; /* our ng_socket hook */
  int cs;			/* A netgraph control socket (maybe) */
#endif
  struct termios ios;		/* To be able to reset from raw mode */
};

#define device2tty(d) ((d)->type == TTY_DEVICE ? (struct ttydevice *)d : NULL)

int
tty_DeviceSize(void)
{
  return sizeof(struct ttydevice);
}

/*
 * tty_Timeout() watches the DCD signal and mentions it if it's status
 * changes.
 */
static void
tty_Timeout(void *data)
{
  struct physical *p = data;
  struct ttydevice *dev = device2tty(p->handler);
  int ombits, change;

  timer_Stop(&dev->Timer);
  dev->Timer.load = SECTICKS;		/* Once a second please */
  timer_Start(&dev->Timer);
  ombits = dev->mbits;

  if (p->fd >= 0) {
    if (ioctl(p->fd, TIOCMGET, &dev->mbits) < 0) {
      /* we must be a pty ? */
      if (p->cfg.cd.necessity != CD_DEFAULT)
        log_Printf(LogWARN, "%s: Carrier ioctl not supported, "
                   "using ``set cd off''\n", p->link.name);
      timer_Stop(&dev->Timer);
      dev->mbits = TIOCM_CD;
      return;
    }
  } else
    dev->mbits = 0;

  if (ombits == -1) {
    /* First time looking for carrier */
    if (Online(dev))
      log_Printf(LogPHASE, "%s: %s: CD detected\n", p->link.name, p->name.full);
    else if (++dev->carrier_seconds >= dev->dev.cd.delay) {
      if (dev->dev.cd.necessity == CD_REQUIRED)
        log_Printf(LogPHASE, "%s: %s: Required CD not detected\n",
                   p->link.name, p->name.full);
      else {
        log_Printf(LogPHASE, "%s: %s doesn't support CD\n",
                   p->link.name, p->name.full);
        dev->mbits = TIOCM_CD;		/* Dodgy null-modem cable ? */
      }
      timer_Stop(&dev->Timer);
      /* tty_AwaitCarrier() will notice */
    } else {
      /* Keep waiting */
      log_Printf(LogDEBUG, "%s: %s: Still no carrier (%d/%d)\n",
                 p->link.name, p->name.full, dev->carrier_seconds,
                 dev->dev.cd.delay);
      dev->mbits = -1;
    }
  } else {
    change = ombits ^ dev->mbits;
    if (change & TIOCM_CD) {
      if (dev->mbits & TIOCM_CD)
        log_Printf(LogDEBUG, "%s: offline -> online\n", p->link.name);
      else {
        log_Printf(LogDEBUG, "%s: online -> offline\n", p->link.name);
        log_Printf(LogPHASE, "%s: Carrier lost\n", p->link.name);
        datalink_Down(p->dl, CLOSE_NORMAL);
        timer_Stop(&dev->Timer);
      }
    } else
      log_Printf(LogDEBUG, "%s: Still %sline\n", p->link.name,
                 Online(dev) ? "on" : "off");
  }
}

static void
tty_StartTimer(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);

  timer_Stop(&dev->Timer);
  dev->Timer.load = SECTICKS;
  dev->Timer.func = tty_Timeout;
  dev->Timer.name = "tty CD";
  dev->Timer.arg = p;
  log_Printf(LogDEBUG, "%s: Using tty_Timeout [%p]\n",
             p->link.name, tty_Timeout);
  timer_Start(&dev->Timer);
}

static int
tty_AwaitCarrier(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);

  if (dev->dev.cd.necessity == CD_NOTREQUIRED || physical_IsSync(p))
    return CARRIER_OK;

  if (dev->mbits == -1) {
    if (dev->Timer.state == TIMER_STOPPED) {
      dev->carrier_seconds = 0;
      tty_StartTimer(p);
    }
    return CARRIER_PENDING;			/* Not yet ! */
  }

  return Online(dev) ? CARRIER_OK : CARRIER_LOST;
}

#ifdef NONETGRAPH
#define tty_SetAsyncParams	NULL
#define tty_Write		NULL
#define tty_Read		NULL
#else

static int
isngtty(struct ttydevice *dev)
{
  return dev->real.fd != -1;
}

static void
tty_SetAsyncParams(struct physical *p, u_int32_t mymap, u_int32_t hismap)
{
  struct ttydevice *dev = device2tty(p->handler);
  char asyncpath[NG_PATHLEN + 1];
  struct ng_async_cfg cfg;

  if (isngtty(dev)) {
    /* Configure the async converter node */

    snprintf(asyncpath, sizeof asyncpath, ".:%s", dev->hook);
    memset(&cfg, 0, sizeof cfg);
    cfg.enabled = 1;
    cfg.accm = mymap | hismap;
    cfg.amru = MAX_MTU;
    cfg.smru = MAX_MRU;
    log_Printf(LogDEBUG, "Configure async node at %s\n", asyncpath);
    if (NgSendMsg(dev->cs, asyncpath, NGM_ASYNC_COOKIE,
                  NGM_ASYNC_CMD_SET_CONFIG, &cfg, sizeof cfg) < 0)
      log_Printf(LogWARN, "%s: Can't configure async node at %s\n",
                 p->link.name, asyncpath);
  } else
    /* No netgraph node, just config the async layer */
    async_SetLinkParams(&p->async, mymap, hismap);
}

static int
LoadLineDiscipline(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);
  u_char rbuf[sizeof(struct ng_mesg) + sizeof(struct nodeinfo)];
  struct ng_mesg *reply;
  struct nodeinfo *info;
  char ttypath[NG_NODELEN + 1];
  struct ngm_mkpeer ngm;
  struct ngm_connect ngc;
  int ldisc, cs, ds, hot, speed;

  /*
   * Don't use the netgraph line discipline for now.  Using it works, but
   * carrier cannot be detected via TIOCMGET and the device doesn't become
   * selectable with 0 bytes to read when carrier is lost :(
   */
  return 0;

  reply = (struct ng_mesg *)rbuf;
  info = (struct nodeinfo *)reply->data;

  loadmodules(LOAD_VERBOSLY, "netgraph", "ng_tty", "ng_async", "ng_socket",
              NULL);

  /* Get the speed before loading the line discipline */
  speed = physical_GetSpeed(p);

  if (ioctl(p->fd, TIOCGETD, &dev->real.disc) < 0) {
    log_Printf(LogDEBUG, "%s: Couldn't get tty line discipline\n",
               p->link.name);
    return 0;
  }
  ldisc = NETGRAPHDISC;
  if (ID0ioctl(p->fd, TIOCSETD, &ldisc) < 0) {
    log_Printf(LogDEBUG, "%s: Couldn't set NETGRAPHDISC line discipline\n",
               p->link.name);
    return 0;
  }

  /* Get the name of the tty node */
  if (ioctl(p->fd, NGIOCGINFO, info) < 0) {
    log_Printf(LogWARN, "%s: ioctl(NGIOCGINFO): %s\n", p->link.name,
               strerror(errno));
    ID0ioctl(p->fd, TIOCSETD, &dev->real.disc);
    return 0;
  }
  snprintf(ttypath, sizeof ttypath, "%s:", info->name);

  /* Create a socket node for our endpoint (and to send messages via) */
  if (ID0NgMkSockNode(NULL, &cs, &ds) == -1) {
    log_Printf(LogWARN, "%s: NgMkSockNode: %s\n", p->link.name,
               strerror(errno));
    ID0ioctl(p->fd, TIOCSETD, &dev->real.disc);
    return 0;
  }

  /* Set the ``hot char'' on the TTY node */
  hot = HDLC_SYN;
  log_Printf(LogDEBUG, "%s: Set tty hotchar to 0x%02x\n", p->link.name, hot);
  if (NgSendMsg(cs, ttypath, NGM_TTY_COOKIE,
      NGM_TTY_SET_HOTCHAR, &hot, sizeof hot) < 0) {
    log_Printf(LogWARN, "%s: Can't set hot char\n", p->link.name);
    goto failed;
  }

  /* Attach an async converter node */
  snprintf(ngm.type, sizeof ngm.type, "%s", NG_ASYNC_NODE_TYPE);
  snprintf(ngm.ourhook, sizeof ngm.ourhook, "%s", NG_TTY_HOOK);
  snprintf(ngm.peerhook, sizeof ngm.peerhook, "%s", NG_ASYNC_HOOK_ASYNC);
  log_Printf(LogDEBUG, "%s: Send mkpeer async:%s to %s:%s\n", p->link.name,
             ngm.peerhook, ttypath, ngm.ourhook);
  if (NgSendMsg(cs, ttypath, NGM_GENERIC_COOKIE,
      NGM_MKPEER, &ngm, sizeof ngm) < 0) {
    log_Printf(LogWARN, "%s: Can't create %s node\n", p->link.name,
               NG_ASYNC_NODE_TYPE);
    goto failed;
  }

  /* Connect the async node to our socket */
  snprintf(ngc.path, sizeof ngc.path, "%s%s", ttypath, NG_TTY_HOOK);
  snprintf(ngc.peerhook, sizeof ngc.peerhook, "%s", NG_ASYNC_HOOK_SYNC);
  memcpy(ngc.ourhook, ngc.peerhook, sizeof ngc.ourhook);
  log_Printf(LogDEBUG, "%s: Send connect %s:%s to .:%s\n", p->link.name,
             ngc.path, ngc.peerhook, ngc.ourhook);
  if (NgSendMsg(cs, ".:", NGM_GENERIC_COOKIE, NGM_CONNECT,
      &ngc, sizeof ngc) < 0) {
    log_Printf(LogWARN, "%s: Can't connect .:%s -> %s.%s: %s\n",
               p->link.name, ngc.ourhook, ngc.path, ngc.peerhook,
               strerror(errno));
    goto failed;
  }

  /* Get the async node id */
  if (NgSendMsg(cs, ngc.path, NGM_GENERIC_COOKIE, NGM_NODEINFO, NULL, 0) < 0) {
    log_Printf(LogWARN, "%s: Can't request async node info at %s: %s\n",
               p->link.name, ngc.path, strerror(errno));
    goto failed;
  }
  if (NgRecvMsg(cs, reply, sizeof rbuf, NULL) < 0) {
    log_Printf(LogWARN, "%s: Can't obtain async node info at %s: %s\n",
               p->link.name, ngc.path, strerror(errno));
    goto failed;
  }

  /* All done, set up our device state */
  snprintf(dev->hook, sizeof dev->hook, "%s", ngc.ourhook);
  dev->cs = cs;
  dev->real.fd = p->fd;
  p->fd = ds;
  dev->real.speed = speed;
  physical_SetSync(p);

  tty_SetAsyncParams(p, 0xffffffff, 0xffffffff);
  physical_SetupStack(p, dev->dev.name, PHYSICAL_NOFORCE);
  log_Printf(LogPHASE, "%s: Loaded netgraph tty line discipline\n",
             p->link.name);

  return 1;

failed:
  ID0ioctl(p->fd, TIOCSETD, &dev->real.disc);
  close(ds);
  close(cs);

  return 0;
}

static void
UnloadLineDiscipline(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);

  if (isngtty(dev)) {
log_Printf(LogPHASE, "back to speed %d\n", dev->real.speed);
    if (!physical_SetSpeed(p, dev->real.speed))
      log_Printf(LogWARN, "Couldn't reset tty speed to %d\n", dev->real.speed);
    dev->real.speed = 0;
    close(p->fd);
    p->fd = dev->real.fd;
    dev->real.fd = -1;
    close(dev->cs);
    dev->cs = -1;
    *dev->hook = '\0';
    if (ID0ioctl(p->fd, TIOCSETD, &dev->real.disc) == 0) {
      physical_SetupStack(p, dev->dev.name, PHYSICAL_NOFORCE);
      log_Printf(LogPHASE, "%s: Unloaded netgraph tty line discipline\n",
                 p->link.name);
    } else
      log_Printf(LogWARN, "%s: Failed to unload netgraph tty line discipline\n",
                 p->link.name);
  }
}

static ssize_t
tty_Write(struct physical *p, const void *v, size_t n)
{
  struct ttydevice *dev = device2tty(p->handler);

  if (isngtty(dev))
    return NgSendData(p->fd, dev->hook, v, n) == -1 ? -1 : n;
  else
    return write(p->fd, v, n);
}

static ssize_t
tty_Read(struct physical *p, void *v, size_t n)
{
  struct ttydevice *dev = device2tty(p->handler);
  char hook[sizeof NG_ASYNC_HOOK_SYNC];

  if (isngtty(dev))
    return NgRecvData(p->fd, v, n, hook);
  else
    return read(p->fd, v, n);
}

#endif /* NETGRAPH */

static int
tty_Raw(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);
  struct termios ios;
  int oldflag;

  log_Printf(LogDEBUG, "%s: Entering tty_Raw\n", p->link.name);

  if (p->type != PHYS_DIRECT && p->fd >= 0 && !Online(dev))
    log_Printf(LogDEBUG, "%s: Raw: descriptor = %d, mbits = %x\n",
              p->link.name, p->fd, dev->mbits);

  if (!physical_IsSync(p)) {
#ifndef NONETGRAPH
    if (!LoadLineDiscipline(p))
#endif
    {
      tcgetattr(p->fd, &ios);
      cfmakeraw(&ios);
      if (p->cfg.rts_cts)
        ios.c_cflag |= CLOCAL | CCTS_OFLOW | CRTS_IFLOW;
      else
        ios.c_cflag |= CLOCAL;

      if (p->type != PHYS_DEDICATED)
        ios.c_cflag |= HUPCL;

      if (tcsetattr(p->fd, TCSANOW, &ios) == -1)
        log_Printf(LogWARN, "%s: tcsetattr: Failed configuring device\n",
                   p->link.name);
    }
  }

  oldflag = fcntl(p->fd, F_GETFL, 0);
  if (oldflag < 0)
    return 0;
  fcntl(p->fd, F_SETFL, oldflag | O_NONBLOCK);

  return 1;
}

static void
tty_Offline(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);

  if (p->fd >= 0) {
    timer_Stop(&dev->Timer);
    dev->mbits &= ~TIOCM_DTR;	/* XXX: Hmm, what's this supposed to do ? */
    if (Online(dev)) {
      struct termios tio;

      tcgetattr(p->fd, &tio);
      if (cfsetspeed(&tio, B0) == -1 || tcsetattr(p->fd, TCSANOW, &tio) == -1)
        log_Printf(LogWARN, "%s: Unable to set physical to speed 0\n",
                   p->link.name);
    }
  }
}

static void
tty_Cooked(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);
  int oldflag;

  tty_Offline(p);	/* In case of emergency close()s */

  tcflush(p->fd, TCIOFLUSH);

  if (!physical_IsSync(p) && tcsetattr(p->fd, TCSAFLUSH, &dev->ios) == -1)
    log_Printf(LogWARN, "%s: tcsetattr: Unable to restore device settings\n",
               p->link.name);

#ifndef NONETGRAPH
  UnloadLineDiscipline(p);
#endif

  if ((oldflag = fcntl(p->fd, F_GETFL, 0)) != -1)
    fcntl(p->fd, F_SETFL, oldflag & ~O_NONBLOCK);
}

static void
tty_StopTimer(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);

  timer_Stop(&dev->Timer);
}

static void
tty_Free(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);

  tty_Offline(p);	/* In case of emergency close()s */
  free(dev);
}

static int
tty_Speed(struct physical *p)
{
  struct termios ios;

  if (tcgetattr(p->fd, &ios) == -1)
    return 0;

  return SpeedToInt(cfgetispeed(&ios));
}

static const char *
tty_OpenInfo(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);
  static char buf[13];

  if (Online(dev))
    strlcpy(buf, "with", sizeof buf);
  else
    strlcpy(buf, "no", sizeof buf);
  strlcat(buf, " carrier", sizeof buf);

  return buf;
}

static int
tty_Slot(struct physical *p)
{
  struct ttyent *ttyp;
  int slot;

  setttyent();
  for (slot = 1; (ttyp = getttyent()); ++slot)
    if (!strcmp(ttyp->ty_name, p->name.base)) {
      endttyent();
      return slot;
    }

  endttyent();
  return -1;
}

static void
tty_device2iov(struct device *d, struct iovec *iov, int *niov,
               int maxiov, int *auxfd, int *nauxfd)
{
  struct ttydevice *dev = device2tty(d);
  int sz = physical_MaxDeviceSize();

  iov[*niov].iov_base = realloc(d, sz);
  if (iov[*niov].iov_base == NULL) {
    log_Printf(LogALERT, "Failed to allocate memory: %d\n", sz);
    AbortProgram(EX_OSERR);
  }
  iov[*niov].iov_len = sz;
  (*niov)++;

#ifndef NONETGRAPH
  if (dev->cs >= 0) {
    *auxfd = dev->cs;
    (*nauxfd)++;
  }
#endif

  if (dev->Timer.state != TIMER_STOPPED) {
    timer_Stop(&dev->Timer);
    dev->Timer.state = TIMER_RUNNING;
  }
}

static struct device basettydevice = {
  TTY_DEVICE,
  "tty",
  0,
  { CD_VARIABLE, DEF_TTYCDDELAY },
  tty_AwaitCarrier,
  NULL,
  tty_Raw,
  tty_Offline,
  tty_Cooked,
  tty_SetAsyncParams,
  tty_StopTimer,
  tty_Free,
  tty_Read,
  tty_Write,
  tty_device2iov,
  tty_Speed,
  tty_OpenInfo,
  tty_Slot
};

struct device *
tty_iov2device(int type, struct physical *p, struct iovec *iov, int *niov,
               int maxiov, int *auxfd, int *nauxfd)
{
  if (type == TTY_DEVICE) {
    struct ttydevice *dev = (struct ttydevice *)iov[(*niov)++].iov_base;
    struct ttydevice *newdev;

    newdev = realloc(dev, sizeof *dev);	/* Reduce to the correct size */
    if (newdev == NULL) {
      log_Printf(LogALERT, "Failed to allocate memory: %d\n",
                 (int)(sizeof *dev));
      AbortProgram(EX_OSERR);
    }
    dev = newdev;

#ifndef NONETGRAPH
    if (*nauxfd) {
      dev->cs = *auxfd;
      (*nauxfd)--;
    } else
      dev->cs = -1;
#endif

    /* Refresh function pointers etc */
    memcpy(&dev->dev, &basettydevice, sizeof dev->dev);

    physical_SetupStack(p, dev->dev.name, PHYSICAL_NOFORCE);
    if (dev->Timer.state != TIMER_STOPPED) {
      dev->Timer.state = TIMER_STOPPED;
      p->handler = &dev->dev;		/* For the benefit of StartTimer */
      tty_StartTimer(p);
    }
    return &dev->dev;
  }

  return NULL;
}

struct device *
tty_Create(struct physical *p)
{
  struct ttydevice *dev;
  struct termios ios;
  int oldflag;

  if (p->fd < 0 || !isatty(p->fd))
    /* Don't want this */
    return NULL;

  if (*p->name.full == '\0') {
    physical_SetDevice(p, ttyname(p->fd));
    log_Printf(LogDEBUG, "%s: Input is a tty (%s)\n",
               p->link.name, p->name.full);
  } else
    log_Printf(LogDEBUG, "%s: Opened %s\n", p->link.name, p->name.full);

  /* We're gonna return a ttydevice (unless something goes horribly wrong) */

  if ((dev = malloc(sizeof *dev)) == NULL) {
    /* Complete failure - parent doesn't continue trying to ``create'' */
    close(p->fd);
    p->fd = -1;
    return NULL;
  }

  memcpy(&dev->dev, &basettydevice, sizeof dev->dev);
  memset(&dev->Timer, '\0', sizeof dev->Timer);
  dev->mbits = -1;
#ifndef NONETGRAPH
  dev->real.speed = 0;
  dev->real.fd = -1;
  dev->real.disc = -1;
  *dev->hook = '\0';
#endif
  tcgetattr(p->fd, &ios);
  dev->ios = ios;

  if (p->cfg.cd.necessity != CD_DEFAULT)
    /* Any override is ok for the tty device */
    dev->dev.cd = p->cfg.cd;

  log_Printf(LogDEBUG, "%s: tty_Create: physical (get): fd = %d,"
             " iflag = %lx, oflag = %lx, cflag = %lx\n", p->link.name, p->fd,
             (u_long)ios.c_iflag, (u_long)ios.c_oflag, (u_long)ios.c_cflag);

  cfmakeraw(&ios);
  if (p->cfg.rts_cts)
    ios.c_cflag |= CLOCAL | CCTS_OFLOW | CRTS_IFLOW;
  else {
    ios.c_cflag |= CLOCAL;
    ios.c_iflag |= IXOFF;
  }
  ios.c_iflag |= IXON;
  if (p->type != PHYS_DEDICATED)
    ios.c_cflag |= HUPCL;

  if (p->type != PHYS_DIRECT) {
      /* Change tty speed when we're not in -direct mode */
      ios.c_cflag &= ~(CSIZE | PARODD | PARENB);
      ios.c_cflag |= p->cfg.parity;
      if (cfsetspeed(&ios, IntToSpeed(p->cfg.speed)) == -1)
	log_Printf(LogWARN, "%s: %s: Unable to set speed to %d\n",
		  p->link.name, p->name.full, p->cfg.speed);
  }

  if (tcsetattr(p->fd, TCSADRAIN, &ios) == -1) {
    log_Printf(LogWARN, "%s: tcsetattr: Failed configuring device\n",
               p->link.name);
    if (p->type != PHYS_DIRECT && p->cfg.speed > 115200)
      log_Printf(LogWARN, "%.*s             Perhaps the speed is unsupported\n",
                 (int)strlen(p->link.name), "");
  }

  log_Printf(LogDEBUG, "%s: physical (put): iflag = %lx, oflag = %lx, "
            "cflag = %lx\n", p->link.name, (u_long)ios.c_iflag,
            (u_long)ios.c_oflag, (u_long)ios.c_cflag);

  oldflag = fcntl(p->fd, F_GETFL, 0);
  if (oldflag < 0) {
    /* Complete failure - parent doesn't continue trying to ``create'' */

    log_Printf(LogWARN, "%s: Open: Cannot get physical flags: %s\n",
               p->link.name, strerror(errno));
    tty_Cooked(p);
    close(p->fd);
    p->fd = -1;
    free(dev);
    return NULL;
  } else
    fcntl(p->fd, F_SETFL, oldflag & ~O_NONBLOCK);

  physical_SetupStack(p, dev->dev.name, PHYSICAL_NOFORCE);

  return &dev->dev;
}
@


1.20
log
@realloc fixes
@
text
@d26 1
a26 1
 *	$OpenBSD: tty.c,v 1.19 2003/04/04 20:25:06 deraadt Exp $
@


1.19
log
@strlcpy and snprintf; various people ok
@
text
@d26 1
a26 1
 *	$OpenBSD: tty.c,v 1.18 2002/05/16 01:13:39 brian Exp $
d629 1
d631 2
a632 2
    dev = realloc(dev, sizeof *dev);	/* Reduce to the correct size */
    if (dev == NULL) {
d637 1
@


1.18
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: tty.c,v 1.17 2002/03/31 02:38:49 brian Exp $
d549 1
a549 1
    strcpy(buf, "with");
d551 2
a552 2
    strcpy(buf, "no");
  strcat(buf, " carrier");
@


1.17
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d26 1
a26 1
 *	$OpenBSD: tty.c,v 1.16 2001/06/19 10:25:00 brian Exp $
d43 1
d264 7
d557 17
d619 2
a620 1
  tty_OpenInfo
@


1.16
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d26 1
a26 1
 *	$OpenBSD: tty.c,v 1.15 2000/11/02 00:54:35 brian Exp $
d37 1
d44 7
d74 1
d91 9
d213 210
d437 10
a446 6
    tcgetattr(p->fd, &ios);
    cfmakeraw(&ios);
    if (p->cfg.rts_cts)
      ios.c_cflag |= CLOCAL | CCTS_OFLOW | CRTS_IFLOW;
    else
      ios.c_cflag |= CLOCAL;
d448 2
a449 2
    if (p->type != PHYS_DEDICATED)
      ios.c_cflag |= HUPCL;
d451 4
a454 3
    if (tcsetattr(p->fd, TCSANOW, &ios) == -1)
      log_Printf(LogWARN, "%s: tcsetattr: Failed configuring device\n",
                 p->link.name);
d498 4
d564 7
d587 1
d590 2
a591 2
  NULL,
  NULL,
d611 8
d664 6
@


1.15
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d26 1
a26 1
 *	$OpenBSD: tty.c,v 1.14 2000/02/27 01:38:29 brian Exp $
d336 1
@


1.14
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: tty.c,v 1.13 2000/01/07 03:26:56 brian Exp $
d219 3
a221 1
    tcsetattr(p->fd, TCSANOW, &ios);
d244 1
a244 1
      if (cfsetspeed(&tio, B0) == -1)
a246 2
      else
        tcsetattr(p->fd, TCSANOW, &tio);
d261 3
a263 2
  if (!physical_IsSync(p))
    tcsetattr(p->fd, TCSAFLUSH, &dev->ios);
d440 9
a448 1
  tcsetattr(p->fd, TCSADRAIN, &ios);
@


1.13
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.12 1999/08/10 10:50:44 brian Exp $
@


1.12
log
@If we receive an IPCP protocol reject, bring it down.
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.11 1999/07/15 02:10:32 brian Exp $
a29 6
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a32 3
#include <util.h>
#else
#include <libutil.h>
a36 2
#include <paths.h>
#include <stdio.h>
a39 1
#include <sys/wait.h>
a47 2
#include "id.h"
#include "sync.h"
a56 4
#include "slcompress.h"
#include "iplist.h"
#include "ipcp.h"
#include "filter.h"
a59 3
#ifndef NORADIUS
#include "radius.h"
#endif
a60 3
#include "command.h"
#include "bundle.h"
#include "prompt.h"
d68 7
d81 1
d111 4
a114 3
      log_Printf(LogPHASE, "%s: ioctl error (%s)!\n", p->link.name,
                 strerror(errno));
      datalink_Down(p->dl, CLOSE_NORMAL);
d116 1
d125 12
a136 5
      log_Printf(LogDEBUG, "%s: %s: CD detected\n", p->link.name, p->name.full);
    else if (p->cfg.cd.required) {
      log_Printf(LogPHASE, "%s: %s: Required CD not detected\n",
                 p->link.name, p->name.full);
      datalink_Down(p->dl, CLOSE_NORMAL);
d138 5
a142 4
      log_Printf(LogPHASE, "%s: %s doesn't support CD\n",
                 p->link.name, p->name.full);
      timer_Stop(&dev->Timer);
      dev->mbits = TIOCM_CD;
d167 1
a167 1
  dev->Timer.load = SECTICKS * p->cfg.cd.delay;
a172 1
  dev->mbits = -1;		/* So we know it's the first time */
d177 19
d202 1
a202 4
  if (physical_IsSync(p))
    return 1;

  log_Printf(LogDEBUG, "%s: Entering physical_Raw\n", p->link.name);
d208 7
a214 6
  tcgetattr(p->fd, &ios);
  cfmakeraw(&ios);
  if (p->cfg.rts_cts)
    ios.c_cflag |= CLOCAL | CCTS_OFLOW | CRTS_IFLOW;
  else
    ios.c_cflag |= CLOCAL;
d216 2
a217 2
  if (p->type != PHYS_DEDICATED)
    ios.c_cflag |= HUPCL;
d219 2
a220 1
  tcsetattr(p->fd, TCSANOW, &ios);
a226 3
  if (ioctl(p->fd, TIOCMGET, &dev->mbits) == 0)
    tty_StartTimer(p);

d237 1
a237 1
    dev->mbits &= ~TIOCM_DTR;
d260 2
a261 1
  if (!physical_IsSync(p)) {
d263 3
a265 4
    oldflag = fcntl(p->fd, F_GETFL, 0);
    if (oldflag == 0)
      fcntl(p->fd, F_SETFL, oldflag & ~O_NONBLOCK);
  }
d307 1
d313 1
a313 1
               int maxiov, pid_t newpid)
d335 3
d352 1
a352 1
               int maxiov)
d408 1
d412 4
d428 1
a428 1
  if (p->type != PHYS_DEDICATED) {
a429 2
    ios.c_cflag &= ~CLOCAL;
  }
a443 16
  if (ioctl(p->fd, TIOCMGET, &dev->mbits) == -1) {
    if (p->type != PHYS_DIRECT) {
      /* Complete failure - parent doesn't continue trying to ``create'' */

      log_Printf(LogWARN, "%s: Open: Cannot get physical status: %s\n",
                 p->link.name, strerror(errno));
      tty_Cooked(p);
      close(p->fd);
      p->fd = -1;
      return NULL;
    } else
      dev->mbits = TIOCM_CD;
  }
  log_Printf(LogDEBUG, "%s: Open: physical control = %o\n",
             p->link.name, dev->mbits);

d453 1
@


1.11
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.9 1999/06/05 21:36:03 brian Exp $
d411 1
a411 1
  if (p->type != PHYS_DEDICATED)
d413 2
@


1.10
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d30 6
a35 6
/* #include <sys/socket.h> (auto-remove) */
/* #include <netinet/in.h> (auto-remove) */
/* #include <arpa/inet.h> (auto-remove) */
/* #include <netdb.h> (auto-remove) */
/* #include <netinet/in_systm.h> (auto-remove) */
/* #include <netinet/ip.h> (auto-remove) */
d39 1
a39 1
/* #include <util.h> (auto-remove) */
d41 1
a41 1
/* #include <libutil.h> (auto-remove) */
d46 2
a47 2
/* #include <paths.h> (auto-remove) */
/* #include <stdio.h> (auto-remove) */
d51 1
a51 1
/* #include <sys/wait.h> (auto-remove) */
d60 2
a61 2
/* #include "id.h" (auto-remove) */
/* #include "sync.h" (auto-remove) */
d71 4
a74 4
/* #include "slcompress.h" (auto-remove) */
/* #include "iplist.h" (auto-remove) */
/* #include "ipcp.h" (auto-remove) */
/* #include "filter.h" (auto-remove) */
d79 1
a79 1
/* #include "radius.h" (auto-remove) */
d82 3
a84 3
/* #include "command.h" (auto-remove) */
/* #include "bundle.h" (auto-remove) */
/* #include "prompt.h" (auto-remove) */
a97 1
  int carrier_seconds;		/* seconds before CD is *required* */
d127 1
a127 2
      /* we must be a pty ? */
      log_Printf(LogDEBUG, "%s: ioctl error (%s)!\n", p->link.name,
d129 1
d133 1
a133 2
  } else {
log_Printf(LogPHASE, "timeout ?\n");
a134 1
}
d139 8
a146 10
      log_Printf(LogPHASE, "%s: %s: CD detected\n", p->link.name, p->name.full);
    else if (++dev->carrier_seconds >= p->cfg.cd.delay) {
      if (p->cfg.cd.required)
        log_Printf(LogPHASE, "%s: %s: Required CD not detected\n",
                   p->link.name, p->name.full);
      else {
        log_Printf(LogPHASE, "%s: %s doesn't support CD\n",
                   p->link.name, p->name.full);
        dev->mbits = TIOCM_CD;		/* Dodgy null-modem cable ? */
      }
d148 2
a149 4
      /* tty_AwaitCarrier() will notice */
    } else
      /* Keep waiting */
      dev->mbits = -1;
d173 1
a173 1
  dev->Timer.load = SECTICKS;
d179 1
a183 19
tty_AwaitCarrier(struct physical *p)
{
  struct ttydevice *dev = device2tty(p->handler);

  if (physical_IsSync(p))
    return CARRIER_OK;

  if (dev->mbits == -1) {
    if (dev->Timer.state == TIMER_STOPPED) {
      dev->carrier_seconds = 0;
      tty_StartTimer(p);
    }
    return CARRIER_PENDING;			/* Not yet ! */
  }

  return Online(dev) || !p->cfg.cd.required ? CARRIER_OK : CARRIER_LOST;
}

static int
d190 4
a193 1
  log_Printf(LogDEBUG, "%s: Entering tty_Raw\n", p->link.name);
d199 6
a204 7
  if (!physical_IsSync(p)) {
    tcgetattr(p->fd, &ios);
    cfmakeraw(&ios);
    if (p->cfg.rts_cts)
      ios.c_cflag |= CLOCAL | CCTS_OFLOW | CRTS_IFLOW;
    else
      ios.c_cflag |= CLOCAL;
d206 2
a207 2
    if (p->type != PHYS_DEDICATED)
      ios.c_cflag |= HUPCL;
d209 1
a209 2
    tcsetattr(p->fd, TCSANOW, &ios);
  }
d216 3
d229 1
a229 1
    dev->mbits &= ~TIOCM_DTR;	/* XXX: Hmm, what's this supposed to do ? */
d252 1
a252 2

  if (!physical_IsSync(p))
d254 4
a257 3

  if ((oldflag = fcntl(p->fd, F_GETFL, 0)) != -1)
    fcntl(p->fd, F_SETFL, oldflag & ~O_NONBLOCK);
a298 1

a325 1
  tty_AwaitCarrier,
a395 1
  dev->mbits = -1;
d427 16
a451 1
    free(dev);
@


1.9
log
@Correct the way ppp transfers links on the server side in MP
mode by padding out the ``struct device'' to the maximum
device size.
Bump the ppp version number to indicate the transfer format
change.

This should make MP over tty and udp devices functional again.
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.8 1999/05/27 08:44:59 brian Exp $
d30 6
a35 6
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
d39 1
a39 1
#include <util.h>
d41 1
a41 1
#include <libutil.h>
d46 2
a47 2
#include <paths.h>
#include <stdio.h>
d51 1
a51 1
#include <sys/wait.h>
d60 2
a61 2
#include "id.h"
#include "sync.h"
d71 4
a74 4
#include "slcompress.h"
#include "iplist.h"
#include "ipcp.h"
#include "filter.h"
d79 1
a79 1
#include "radius.h"
d82 3
a84 3
#include "command.h"
#include "bundle.h"
#include "prompt.h"
d98 1
d128 2
a129 1
      log_Printf(LogPHASE, "%s: ioctl error (%s)!\n", p->link.name,
a130 1
      datalink_Down(p->dl, CLOSE_NORMAL);
d134 2
a135 1
  } else
d137 1
d142 10
a151 8
      log_Printf(LogDEBUG, "%s: %s: CD detected\n", p->link.name, p->name.full);
    else if (p->cfg.cd.required) {
      log_Printf(LogPHASE, "%s: %s: Required CD not detected\n",
                 p->link.name, p->name.full);
      datalink_Down(p->dl, CLOSE_NORMAL);
    } else {
      log_Printf(LogPHASE, "%s: %s doesn't support CD\n",
                 p->link.name, p->name.full);
d153 4
a156 2
      dev->mbits = TIOCM_CD;
    }
d180 1
a180 1
  dev->Timer.load = SECTICKS * p->cfg.cd.delay;
a185 1
  dev->mbits = -1;		/* So we know it's the first time */
d190 19
d215 1
a215 4
  if (physical_IsSync(p))
    return 1;

  log_Printf(LogDEBUG, "%s: Entering physical_Raw\n", p->link.name);
d221 7
a227 6
  tcgetattr(p->fd, &ios);
  cfmakeraw(&ios);
  if (p->cfg.rts_cts)
    ios.c_cflag |= CLOCAL | CCTS_OFLOW | CRTS_IFLOW;
  else
    ios.c_cflag |= CLOCAL;
d229 2
a230 2
  if (p->type != PHYS_DEDICATED)
    ios.c_cflag |= HUPCL;
d232 2
a233 1
  tcsetattr(p->fd, TCSANOW, &ios);
a239 3
  if (ioctl(p->fd, TIOCMGET, &dev->mbits) == 0)
    tty_StartTimer(p);

d250 1
a250 1
    dev->mbits &= ~TIOCM_DTR;
d273 2
a274 1
  if (!physical_IsSync(p)) {
d276 3
a278 4
    oldflag = fcntl(p->fd, F_GETFL, 0);
    if (oldflag == 0)
      fcntl(p->fd, F_SETFL, oldflag & ~O_NONBLOCK);
  }
d320 1
d348 1
d419 1
a450 16
  if (ioctl(p->fd, TIOCMGET, &dev->mbits) == -1) {
    if (p->type != PHYS_DIRECT) {
      /* Complete failure - parent doesn't continue trying to ``create'' */

      log_Printf(LogWARN, "%s: Open: Cannot get physical status: %s\n",
                 p->link.name, strerror(errno));
      tty_Cooked(p);
      close(p->fd);
      p->fd = -1;
      return NULL;
    } else
      dev->mbits = TIOCM_CD;
  }
  log_Printf(LogDEBUG, "%s: Open: physical control = %o\n",
             p->link.name, dev->mbits);

d460 1
@


1.8
log
@Call tty_Offline() from tty_Cooked() and tty_Free(), just in
case ppp is abending and hasn't called physical_Offline()
already.
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.7 1999/05/24 16:39:19 brian Exp $
d50 1
d89 1
d103 6
d303 1
a303 1
tty_device2iov(struct physical *p, struct iovec *iov, int *niov,
d306 2
a307 1
  struct ttydevice *dev = p ? device2tty(p->handler) : NULL;
d309 6
a314 2
  iov[*niov].iov_base = p ? p->handler : malloc(sizeof(struct ttydevice));
  iov[*niov].iov_len = sizeof(struct ttydevice);
d345 7
d358 1
@


1.7
log
@Correct the ``ignoring sync/async'' warnings so that they show
up with the correct device type.
Reassign the correct tcpdevice or execdevice after transfering
a link in MP server mode.
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.6 1999/05/18 01:37:51 brian Exp $
d241 2
d265 1
@


1.6
log
@Move the tty locking stuff back out to physical.c so
that we lock the device *before* we open it.
We still open the device only once - and then ask all
our handlers if they know how to handle it.
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.5 1999/05/16 11:58:38 brian Exp $
d327 1
a327 1
    struct ttydevice *dev;
a328 3
    /* It's one of ours !  Let's create the device */

    dev = (struct ttydevice *)iov[(*niov)++].iov_base;
d332 1
a332 1
    physical_SetupStack(p, PHYSICAL_NOFORCE);
d432 1
a432 1
  physical_SetupStack(p, PHYSICAL_NOFORCE);
@


1.5
log
@Initialise ttydevice::Timer
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.4 1999/05/13 19:29:37 brian Exp $
a100 56
static int
tty_Lock(struct physical *p, int tunno)
{
  int res;
  FILE *lockfile;
  char fn[MAXPATHLEN];

  if (*p->name.full != '/')
    return 0;

  if (p->type != PHYS_DIRECT &&
      (res = ID0uu_lock(p->name.base)) != UU_LOCK_OK) {
    if (res == UU_LOCK_INUSE)
      log_Printf(LogPHASE, "%s: %s is in use\n", p->link.name, p->name.full);
    else
      log_Printf(LogPHASE, "%s: %s is in use: uu_lock: %s\n",
                 p->link.name, p->name.full, uu_lockerr(res));
    return (-1);
  }

  snprintf(fn, sizeof fn, "%s%s.if", _PATH_VARRUN, p->name.base);
  lockfile = ID0fopen(fn, "w");
  if (lockfile != NULL) {
    fprintf(lockfile, "%s%d\n", TUN_NAME, tunno);
    fclose(lockfile);
  }
#ifndef RELEASE_CRUNCH
  else
    log_Printf(LogALERT, "%s: Can't create %s: %s\n",
               p->link.name, fn, strerror(errno));
#endif

  return 0;
}

static void
tty_Unlock(struct physical *p)
{
  char fn[MAXPATHLEN];

  if (*p->name.full != '/')
    return;

  snprintf(fn, sizeof fn, "%s%s.if", _PATH_VARRUN, p->name.base);
#ifndef RELEASE_CRUNCH
  if (ID0unlink(fn) == -1)
    log_Printf(LogALERT, "%s: Can't remove %s: %s\n",
               p->link.name, fn, strerror(errno));
#else
  ID0unlink(fn);
#endif

  if (p->type != PHYS_DIRECT && ID0uu_unlock(p->name.base) == -1)
    log_Printf(LogALERT, "%s: Can't uu_unlock %s\n", p->link.name, fn);
}

a262 1
  tty_Unlock(p);
d322 26
a347 2
static struct device *
tty_SetupDevice(struct physical *p)
d353 2
a354 1
  if ((dev = malloc(sizeof *dev)) == NULL)
d357 16
d378 1
a378 1
  log_Printf(LogDEBUG, "%s: tty_SetupDevice: physical (get): fd = %d,"
d408 2
d412 3
a414 1
      physical_Close(p);
d424 2
d428 3
a430 1
    physical_Close(p);
a437 45
}

struct device *
tty_iov2device(int type, struct physical *p, struct iovec *iov, int *niov,
               int maxiov)
{
  if (type == TTY_DEVICE) {
    struct ttydevice *dev;

    /* It's one of ours !  Let's create the device */

    dev = (struct ttydevice *)iov[(*niov)++].iov_base;
    /* Refresh function pointers etc */
    memcpy(&dev->dev, &basettydevice, sizeof dev->dev);

    physical_SetupStack(p, PHYSICAL_NOFORCE);
    if (dev->Timer.state != TIMER_STOPPED) {
      dev->Timer.state = TIMER_STOPPED;
      tty_StartTimer(p);
    }
    return &dev->dev;
  }

  return NULL;
}

struct device *
tty_Create(struct physical *p)
{
  if (p->fd >= 0 && isatty(p->fd)) {
    if (*p->name.full == '\0') {
      log_Printf(LogDEBUG, "%s: Input is a tty\n", p->link.name);
      physical_SetDevice(p, ttyname(p->fd));
      if (tty_Lock(p, p->dl->bundle->unit) == -1) {
        close(p->fd);
        p->fd = -1;
      } else
        return tty_SetupDevice(p);
    } else if (tty_Lock(p, p->dl->bundle->unit) != -1) {
      log_Printf(LogDEBUG, "%s: Opened %s\n", p->link.name, p->name.full);
      return tty_SetupDevice(p);
    }
  }

  return NULL;
@


1.4
log
@Initialise the struct device part of struct ttydevice.
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.3 1999/05/13 16:33:56 brian Exp $
d390 1
@


1.3
log
@Fix a bum pointer dereference and make some variable
names more consistent.
Stack trace supplied by: Joe Clarke <jclarke@@cisco.com>
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.2 1999/05/12 10:03:54 brian Exp $
a156 67
static struct device *
tty_SetupDevice(struct physical *p)
{
  struct ttydevice *dev;
  struct termios ios;
  int oldflag;

  if ((dev = malloc(sizeof *dev)) == NULL)
    return NULL;

  tcgetattr(p->fd, &ios);
  dev->ios = ios;

  log_Printf(LogDEBUG, "%s: tty_SetupDevice: physical (get): fd = %d,"
             " iflag = %lx, oflag = %lx, cflag = %lx\n", p->link.name, p->fd,
             (u_long)ios.c_iflag, (u_long)ios.c_oflag, (u_long)ios.c_cflag);

  cfmakeraw(&ios);
  if (p->cfg.rts_cts)
    ios.c_cflag |= CLOCAL | CCTS_OFLOW | CRTS_IFLOW;
  else {
    ios.c_cflag |= CLOCAL;
    ios.c_iflag |= IXOFF;
  }
  ios.c_iflag |= IXON;
  if (p->type != PHYS_DEDICATED)
    ios.c_cflag |= HUPCL;

  if (p->type != PHYS_DIRECT) {
      /* Change tty speed when we're not in -direct mode */
      ios.c_cflag &= ~(CSIZE | PARODD | PARENB);
      ios.c_cflag |= p->cfg.parity;
      if (cfsetspeed(&ios, IntToSpeed(p->cfg.speed)) == -1)
	log_Printf(LogWARN, "%s: %s: Unable to set speed to %d\n",
		  p->link.name, p->name.full, p->cfg.speed);
  }
  tcsetattr(p->fd, TCSADRAIN, &ios);
  log_Printf(LogDEBUG, "%s: physical (put): iflag = %lx, oflag = %lx, "
            "cflag = %lx\n", p->link.name, (u_long)ios.c_iflag,
            (u_long)ios.c_oflag, (u_long)ios.c_cflag);

  if (ioctl(p->fd, TIOCMGET, &dev->mbits) == -1) {
    if (p->type != PHYS_DIRECT) {
      log_Printf(LogWARN, "%s: Open: Cannot get physical status: %s\n",
                 p->link.name, strerror(errno));
      physical_Close(p);
      return NULL;
    } else
      dev->mbits = TIOCM_CD;
  }
  log_Printf(LogDEBUG, "%s: Open: physical control = %o\n",
             p->link.name, dev->mbits);

  oldflag = fcntl(p->fd, F_GETFL, 0);
  if (oldflag < 0) {
    log_Printf(LogWARN, "%s: Open: Cannot get physical flags: %s\n",
               p->link.name, strerror(errno));
    physical_Close(p);
    return NULL;
  } else
    fcntl(p->fd, F_SETFL, oldflag & ~O_NONBLOCK);

  physical_SetupStack(p, PHYSICAL_NOFORCE);

  return &dev->dev;
}

d378 68
@


1.2
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d26 1
a26 1
 *	$Id: tty.c,v 1.1 1999/05/08 11:06:40 brian Exp $
d157 1
a157 1
static void
d160 2
a161 2
  struct ttydevice *dev = device2tty(p->handler);
  struct termios rstio;
d164 5
a168 2
  tcgetattr(p->fd, &rstio);
  dev->ios = rstio;
d172 1
a172 2
             (u_long)rstio.c_iflag, (u_long)rstio.c_oflag,
             (u_long)rstio.c_cflag);
d174 1
a174 1
  cfmakeraw(&rstio);
d176 1
a176 1
    rstio.c_cflag |= CLOCAL | CCTS_OFLOW | CRTS_IFLOW;
d178 2
a179 2
    rstio.c_cflag |= CLOCAL;
    rstio.c_iflag |= IXOFF;
d181 1
a181 1
  rstio.c_iflag |= IXON;
d183 1
a183 1
    rstio.c_cflag |= HUPCL;
d187 3
a189 3
      rstio.c_cflag &= ~(CSIZE | PARODD | PARENB);
      rstio.c_cflag |= p->cfg.parity;
      if (cfsetspeed(&rstio, IntToSpeed(p->cfg.speed)) == -1)
d193 1
a193 1
  tcsetattr(p->fd, TCSADRAIN, &rstio);
d195 2
a196 2
            "cflag = %lx\n", p->link.name, (u_long)rstio.c_iflag,
            (u_long)rstio.c_oflag, (u_long)rstio.c_cflag);
d203 1
a203 1
      return;
d215 1
a215 1
    return;
d220 2
d302 1
a302 1
  struct termios rstio;
d314 2
a315 2
  tcgetattr(p->fd, &rstio);
  cfmakeraw(&rstio);
d317 1
a317 1
    rstio.c_cflag |= CLOCAL | CCTS_OFLOW | CRTS_IFLOW;
d319 1
a319 1
    rstio.c_cflag |= CLOCAL;
d322 1
a322 1
    rstio.c_cflag |= HUPCL;
d324 1
a324 1
  tcsetattr(p->fd, TCSANOW, &rstio);
d393 1
a393 1
  struct termios rstio;
d395 1
a395 1
  if (tcgetattr(p->fd, &rstio) == -1)
d398 1
a398 1
  return SpeedToInt(cfgetispeed(&rstio));
d480 2
a481 8
      } else {
        struct ttydevice *dev = malloc(sizeof *dev);

        if (dev != NULL)
          tty_SetupDevice(p);

        return &dev->dev;
      }
a482 1
      struct ttydevice *dev = malloc(sizeof *dev);
d484 1
a484 5

      if (dev != NULL)
        tty_SetupDevice(p);

      return &dev->dev;
@


1.1
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id:$
d51 1
d90 10
a99 1
#define	Online(p)	((p)->mbits & TIOCM_CD)
d160 1
d165 1
a165 1
  p->ios = rstio;
d196 1
a196 1
  if (ioctl(p->fd, TIOCMGET, &p->mbits) == -1) {
d203 1
a203 1
      p->mbits = TIOCM_CD;
d206 1
a206 1
             p->link.name, p->mbits);
d217 1
a217 46
  physical_SetupStack(p, 0);
}

static int
tty_Open(struct physical *p)
{
  if (*p->name.full == '/') {
    p->mbits = 0;
    if (tty_Lock(p, p->dl->bundle->unit) != -1) {
      p->fd = ID0open(p->name.full, O_RDWR | O_NONBLOCK);
      if (p->fd < 0) {
        log_Printf(LogPHASE, "%s: Open(\"%s\"): %s\n",
                   p->link.name, p->name.full, strerror(errno));
        tty_Unlock(p);
      } else if (!isatty(p->fd)) {
        log_Printf(LogPHASE, "%s: Open(\"%s\"): Not a tty\n",
                   p->link.name, p->name.full);
        close(p->fd);
        p->fd = -1;
        tty_Unlock(p);
      } else {
        log_Printf(LogDEBUG, "%s: Opened %s\n", p->link.name, p->name.full);
        tty_SetupDevice(p);
      }
    }
  }

  return p->fd >= 0;
}

int
tty_OpenStdin(struct physical *p)
{
  if (isatty(STDIN_FILENO)) {
    p->mbits = 0;
    log_Printf(LogDEBUG, "%s: tty_Open: stdin is a tty\n", p->link.name);
    physical_SetDevice(p, ttyname(STDIN_FILENO));
    if (tty_Lock(p, p->dl->bundle->unit) == -1)
      close(STDIN_FILENO);
    else {
      p->fd = STDIN_FILENO;
      tty_SetupDevice(p);
    }
  }

  return p->fd >= 0;
d228 1
d231 4
a234 4
  timer_Stop(&p->Timer);
  p->Timer.load = SECTICKS;		/* Once a second please */
  timer_Start(&p->Timer);
  ombits = p->mbits;
d237 1
a237 1
    if (ioctl(p->fd, TIOCMGET, &p->mbits) < 0) {
d241 1
a241 1
      timer_Stop(&p->Timer);
d245 1
a245 1
    p->mbits = 0;
d249 1
a249 1
    if (Online(p))
d258 2
a259 2
      timer_Stop(&p->Timer);
      p->mbits = TIOCM_CD;
d262 1
a262 1
    change = ombits ^ p->mbits;
d264 1
a264 1
      if (p->mbits & TIOCM_CD)
d270 1
a270 1
        timer_Stop(&p->Timer);
d274 1
a274 1
                 Online(p) ? "on" : "off");
d281 7
a287 5
  timer_Stop(&p->Timer);
  p->Timer.load = SECTICKS * p->cfg.cd.delay;
  p->Timer.func = tty_Timeout;
  p->Timer.name = "tty CD";
  p->Timer.arg = p;
d290 2
a291 2
  p->mbits = -1;		/* So we know it's the first time */
  timer_Start(&p->Timer);
d297 1
d306 1
a306 1
  if (p->type != PHYS_DIRECT && p->fd >= 0 && !Online(p))
d308 1
a308 1
              p->link.name, p->fd, p->mbits);
d327 1
a327 1
  if (ioctl(p->fd, TIOCMGET, &p->mbits) == 0)
d336 2
d339 3
a341 3
    timer_Stop(&p->Timer);
    p->mbits &= ~TIOCM_DTR;
    if (Online(p)) {
d357 1
d362 1
a362 1
    tcsetattr(p->fd, TCSAFLUSH, &p->ios);
d370 1
a370 1
tty_Close(struct physical *p)
d372 3
a374 1
  tty_Unlock(p);
d378 1
a378 1
tty_Restored(struct physical *p)
d380 4
a383 4
  if (p->Timer.state != TIMER_STOPPED) {
    p->Timer.state = TIMER_STOPPED;	/* Special - see physical2iov() */
    tty_StartTimer(p);
  }
d400 1
d403 1
a403 1
  if (Online(p))
d411 17
a427 1
const struct device ttydevice = {
a429 1
  tty_Open,
d433 5
a437 2
  tty_Close,
  tty_Restored,
d441 56
@

