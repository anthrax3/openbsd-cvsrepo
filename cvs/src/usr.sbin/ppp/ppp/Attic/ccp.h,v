head	1.15;
access;
symbols
	OPENBSD_5_5:1.14.0.50
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.46
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.44
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.42
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.40
	OPENBSD_5_0:1.14.0.38
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.36
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.34
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.30
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.32
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.28
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.26
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.24
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.22
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.20
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.18
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.16
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.14
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.12
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.10
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.8
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.14;

1.14
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.03.22.23.56;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.19.10.24.50;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.13.21.33.40;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.04.22.53.12;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.07.23.32.04;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.02.00.54.33;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.27.01.38.25;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.34;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.26.21.28.20;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.32;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.17;	author brian;	state Exp;
branches;
next	;


desc
@@


1.15
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: ccp.h,v 1.14 2002/06/15 01:33:23 brian Exp $
 */

#define	CCP_MAXCODE	CODE_RESETACK

#define	TY_OUI		0	/* OUI */
#define	TY_PRED1	1	/* Predictor type 1 */
#define	TY_PRED2	2	/* Predictor type 2 */
#define	TY_PUDDLE	3	/* Puddle Jumper */
#define	TY_HWPPC	16	/* Hewlett-Packard PPC */
#define	TY_STAC		17	/* Stac Electronics LZS */
#define	TY_MSPPC	18	/* Microsoft PPC */
#define	TY_MPPE		18	/* Microsoft PPE */
#define	TY_GAND		19	/* Gandalf FZA */
#define	TY_V42BIS	20	/* V.42bis compression */
#define	TY_BSD		21	/* BSD LZW Compress */
#define	TY_PPPD_DEFLATE	24	/* Deflate (gzip) - (mis) numbered by pppd */
#define	TY_DEFLATE	26	/* Deflate (gzip) - rfc 1979 */

#define CCP_NEG_DEFLATE		0
#define CCP_NEG_PRED1		1
#define CCP_NEG_DEFLATE24	2
#ifndef NODES
#define CCP_NEG_MPPE		3
#define CCP_NEG_TOTAL		4
#else
#define CCP_NEG_TOTAL		3
#endif

#ifndef NODES
enum mppe_negstate {
  MPPE_ANYSTATE,
  MPPE_STATELESS,
  MPPE_STATEFUL
};
#endif

struct mbuf;
struct link;

struct ccp_config {
  struct {
    struct {
      int winsize;
    } in, out;
  } deflate;
#ifndef NODES
  struct {
    int keybits;
    enum mppe_negstate state;
    unsigned required : 1;
  } mppe;
#endif
  struct fsm_retry fsm;	/* How often/frequently to resend requests */
  unsigned neg[CCP_NEG_TOTAL];
};

struct ccp_opt {
  struct ccp_opt *next;
  int algorithm;
  struct fsm_opt val;
};

struct ccp {
  struct fsm fsm;		/* The finite state machine */

  int his_proto;		/* peer's compression protocol */
  int my_proto;			/* our compression protocol */

  int reset_sent;		/* If != -1, ignore compressed 'till ack */
  int last_reset;		/* We can receive more (dups) w/ this id */

  struct {
    int algorithm;		/* Algorithm in use */
    void *state;		/* Returned by implementations Init() */
    struct fsm_opt opt;		/* Set by implementation's OptInit() */
  } in;

  struct {
    int algorithm;		/* Algorithm in use */
    void *state;		/* Returned by implementations Init() */
    struct ccp_opt *opt;	/* Set by implementation's OptInit() */
  } out;

  u_int32_t his_reject;		/* Request codes rejected by peer */
  u_int32_t my_reject;		/* Request codes I have rejected */

  u_long uncompout, compout;	/* Outgoing bytes before/after compression */
  u_long uncompin, compin;	/* Incoming bytes after/before decompression */

  struct ccp_config cfg;
};

#define fsm2ccp(fp) (fp->proto == PROTO_CCP ? (struct ccp *)fp : NULL)

struct ccp_algorithm {
  int id;
  int Neg;					/* ccp_config neg array item */
  const char *(*Disp)(struct fsm_opt *);	/* Use result immediately !  */
  int (*Usable)(struct fsm *);			/* Ok to negotiate ? */
  int (*Required)(struct fsm *);		/* Must negotiate ? */
  struct {
    int (*Set)(struct bundle *, struct fsm_opt *, const struct ccp_config *);
    void *(*Init)(struct bundle *, struct fsm_opt *);
    void (*Term)(void *);
    void (*Reset)(void *);
    struct mbuf *(*Read)(void *, struct ccp *, u_short *, struct mbuf *);
    void (*DictSetup)(void *, struct ccp *, u_short, struct mbuf *);
  } i;
  struct {
    int MTUOverhead;
    void (*OptInit)(struct bundle *, struct fsm_opt *,
                    const struct ccp_config *);
    int (*Set)(struct bundle *, struct fsm_opt *, const struct ccp_config *);
    void *(*Init)(struct bundle *, struct fsm_opt *);
    void (*Term)(void *);
    int (*Reset)(void *);
    struct mbuf *(*Write)(void *, struct ccp *, struct link *, int, u_short *,
                          struct mbuf *);
  } o;
};

extern void ccp_Init(struct ccp *, struct bundle *, struct link *,
                     const struct fsm_parent *);
extern void ccp_Setup(struct ccp *);
extern int ccp_Required(struct ccp *);
extern int ccp_MTUOverhead(struct ccp *);

extern void ccp_SendResetReq(struct fsm *);
extern struct mbuf *ccp_Input(struct bundle *, struct link *, struct mbuf *);
extern int ccp_ReportStatus(struct cmdargs const *);
extern u_short ccp_Proto(struct ccp *);
extern void ccp_SetupCallbacks(struct ccp *);
extern int ccp_SetOpenMode(struct ccp *);
extern int ccp_DefaultUsable(struct fsm *);
extern int ccp_DefaultRequired(struct fsm *);

extern struct layer ccplayer;
@


1.14
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.h,v 1.13 2002/05/16 01:13:39 brian Exp $
@


1.13
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.h,v 1.12 2002/03/31 02:38:49 brian Exp $
d130 2
a131 2
    int (*Set)(struct fsm_opt *, const struct ccp_config *);
    void *(*Init)(struct fsm_opt *);
d139 4
a142 3
    void (*OptInit)(struct fsm_opt *, const struct ccp_config *);
    int (*Set)(struct fsm_opt *, const struct ccp_config *);
    void *(*Init)(struct fsm_opt *);
@


1.12
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.h,v 1.11 2001/07/03 22:23:56 brian Exp $
d88 1
a88 1
  struct lcp_opt val;
d103 1
a103 1
    struct lcp_opt opt;		/* Set by implementation's OptInit() */
d126 1
a126 1
  const char *(*Disp)(struct lcp_opt *);	/* Use result immediately !  */
d130 2
a131 2
    int (*Set)(struct lcp_opt *, const struct ccp_config *);
    void *(*Init)(struct lcp_opt *);
d139 3
a141 3
    void (*OptInit)(struct lcp_opt *, const struct ccp_config *);
    int (*Set)(struct lcp_opt *, const struct ccp_config *);
    void *(*Init)(struct lcp_opt *);
@


1.11
log
@Reduce the interface MTU by 2 when MPPE has been successfully negotiated.

This is necessary because MPPE will combine the protocol id with the
payload received on the tun interface, encrypt it, then prepend its
own protocol id, effectively increasing the payload by two bytes.
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.h,v 1.10 2001/06/19 10:24:50 brian Exp $
d50 1
a50 1
#ifdef HAVE_DES
d57 1
a57 1
#ifdef HAVE_DES
d74 1
a74 1
#ifdef HAVE_DES
@


1.10
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.h,v 1.9 2001/06/13 21:33:40 brian Exp $
d138 1
d153 1
@


1.9
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d57 8
d77 2
d128 1
d139 1
a139 1
    int (*Set)(struct lcp_opt *);
d142 1
a142 1
    void (*Reset)(void *);
d151 1
d159 2
a160 1
extern int ccp_IsUsable(struct fsm *);
@


1.8
log
@Add a ``Usable'' function to the ccp switch.  The function
is called prior to sending a CCP configure request for a
given protocol.  The default is to send the request, but
this is overridden for MPPE which checks to see if the lcp
negotiations agreed CHAP81, and if not fails.

Use the same function to decide if we should reject peer
requests for MPPE.

This should get rid of those boring messages about not being
able to initialise MPPE when we don't negotiate CHAP81.
@
text
@d1 5
a5 2
/*
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d7 8
a14 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d16 11
a26 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d28 1
a28 3
 * $OpenBSD: ccp.h,v 1.7 2000/11/07 23:32:04 brian Exp $
 *
 *	TODO:
@


1.7
log
@Pass the correct option data to the compression modules Init function
rather than the data associated with the first protocol REQuested.

Initiate MPPE session keys correctly based on whether we're client
or server
@
text
@d18 1
a18 1
 * $OpenBSD: ccp.h,v 1.6 2000/11/02 00:54:33 brian Exp $
d109 1
d139 1
@


1.6
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d18 1
a18 1
 * $OpenBSD: ccp.h,v 1.5 2000/02/27 01:38:25 brian Exp $
d85 1
a85 1
    struct lcp_opt opt;		/* Set by implementations OptInit() */
d91 1
a91 1
    struct ccp_opt *opt;	/* Set by implementations OptInit() */
@


1.5
log
@$Id$ -> $OpenBSD$
@
text
@d18 1
a18 1
 * $OpenBSD: ccp.h,v 1.4 1999/05/08 11:06:34 brian Exp $
d32 1
d42 4
d47 1
d58 5
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d18 1
a18 1
 * $Id: ccp.h,v 1.3 1999/02/26 21:28:20 brian Exp $
@


1.3
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d18 1
a18 1
 * $Id: ccp.h,v 1.2 1999/02/06 03:22:32 brian Exp $
d112 2
a113 2
    int (*Write)(void *, struct ccp *, struct link *, int, u_short,
                 struct mbuf *);
d122 1
a122 1
extern void ccp_Input(struct ccp *, struct bundle *, struct mbuf *);
a123 2
extern int ccp_Compress(struct ccp *, struct link *, int, u_short, struct mbuf *);
extern struct mbuf *ccp_Decompress(struct ccp *, u_short *, struct mbuf *);
d127 2
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d18 1
a18 1
 * $Id: ccp.h,v 1.19 1998/06/30 23:04:12 brian Exp $
d52 1
a52 1
  u_int fsmretry;		/* FSM retry frequency */
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

