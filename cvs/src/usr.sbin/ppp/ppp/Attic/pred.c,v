head	1.15;
access;
symbols
	OPENBSD_5_5:1.14.0.50
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.46
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.44
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.42
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.40
	OPENBSD_5_0:1.14.0.38
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.36
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.34
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.30
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.32
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.28
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.26
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.24
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.22
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.20
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.18
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.16
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.14
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.12
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.10
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.8
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.4
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.14;

1.14
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.03.22.23.56;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.19.10.24.57;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.04.22.53.13;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.27.01.38.28;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.02.15.58.41;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.09.20.04.03;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.08.11.06.39;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.03.16.01.21.52;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.11.01.50.04;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.43;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.26;	author brian;	state Exp;
branches;
next	;


desc
@@


1.15
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1997 Brian Somers <brian@@Awfulhak.org>
 *                    Ian Donaldson <iand@@labtam.labtam.oz.au>
 *                    Carsten Bormann <cabo@@cs.tu-berlin.de>
 *                    Dave Rand <dlr@@bungi.com>/<dave_rand@@novell.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: pred.c,v 1.14 2002/06/15 01:33:23 brian Exp $
 */

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <termios.h>

#include "defs.h"
#include "layer.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "ccp.h"
#include "throughput.h"
#include "link.h"
#include "pred.h"

/* The following hash code is the heart of the algorithm:
 * It builds a sliding hash sum of the previous 3-and-a-bit characters
 * which will be used to index the guess table.
 * A better hash function would result in additional compression,
 * at the expense of time.
 */
#define HASH(state, x) state->hash = (state->hash << 4) ^ (x)
#define GUESS_TABLE_SIZE 65536

struct pred1_state {
  u_short hash;
  u_char dict[GUESS_TABLE_SIZE];
};

static int
compress(struct pred1_state *state, u_char *source, u_char *dest, int len)
{
  int i, bitmask;
  unsigned char *flagdest, flags, *orgdest;

  orgdest = dest;
  while (len) {
    flagdest = dest++;
    flags = 0;			/* All guess wrong initially */
    for (bitmask = 1, i = 0; i < 8 && len; i++, bitmask <<= 1) {
      if (state->dict[state->hash] == *source) {
	flags |= bitmask;	/* Guess was right - don't output */
      } else {
	state->dict[state->hash] = *source;
	*dest++ = *source;	/* Guess wrong, output char */
      }
      HASH(state, *source++);
      len--;
    }
    *flagdest = flags;
  }
  return (dest - orgdest);
}

static void
SyncTable(struct pred1_state *state, u_char *source, u_char *dest, int len)
{
  while (len--) {
    *dest++ = state->dict[state->hash] = *source;
    HASH(state, *source++);
  }
}

static int
decompress(struct pred1_state *state, u_char *source, u_char *dest, int len)
{
  int i, bitmask;
  unsigned char flags, *orgdest;

  orgdest = dest;
  while (len) {
    flags = *source++;
    len--;
    for (i = 0, bitmask = 1; i < 8; i++, bitmask <<= 1) {
      if (flags & bitmask) {
	*dest = state->dict[state->hash];	/* Guess correct */
      } else {
	if (!len)
	  break;		/* we seem to be really done -- cabo */
	state->dict[state->hash] = *source;	/* Guess wrong */
	*dest = *source++;	/* Read from source */
	len--;
      }
      HASH(state, *dest++);
    }
  }
  return (dest - orgdest);
}

static void
Pred1Term(void *v)
{
  struct pred1_state *state = (struct pred1_state *)v;
  free(state);
}

static void
Pred1ResetInput(void *v)
{
  struct pred1_state *state = (struct pred1_state *)v;
  state->hash = 0;
  memset(state->dict, '\0', sizeof state->dict);
  log_Printf(LogCCP, "Predictor1: Input channel reset\n");
}

static int
Pred1ResetOutput(void *v)
{
  struct pred1_state *state = (struct pred1_state *)v;
  state->hash = 0;
  memset(state->dict, '\0', sizeof state->dict);
  log_Printf(LogCCP, "Predictor1: Output channel reset\n");

  return 1;		/* Ask FSM to ACK */
}

static void *
Pred1InitInput(struct bundle *bundle, struct fsm_opt *o)
{
  struct pred1_state *state;
  state = (struct pred1_state *)malloc(sizeof(struct pred1_state));
  if (state != NULL)
    Pred1ResetInput(state);
  return state;
}

static void *
Pred1InitOutput(struct bundle *bundle, struct fsm_opt *o)
{
  struct pred1_state *state;
  state = (struct pred1_state *)malloc(sizeof(struct pred1_state));
  if (state != NULL)
    Pred1ResetOutput(state);
  return state;
}

static struct mbuf *
Pred1Output(void *v, struct ccp *ccp, struct link *l, int pri, u_short *proto,
            struct mbuf *bp)
{
  struct pred1_state *state = (struct pred1_state *)v;
  struct mbuf *mwp;
  u_char *cp, *wp, *hp;
  int orglen, len;
  u_char bufp[MAX_MTU + 2];
  u_short fcs;

  orglen = m_length(bp) + 2;	/* add count of proto */
  mwp = m_get((orglen + 2) / 8 * 9 + 12, MB_CCPOUT);
  hp = wp = MBUF_CTOP(mwp);
  cp = bufp;
  *wp++ = *cp++ = orglen >> 8;
  *wp++ = *cp++ = orglen & 0377;
  *cp++ = *proto >> 8;
  *cp++ = *proto & 0377;
  mbuf_Read(bp, cp, orglen - 2);
  fcs = hdlc_Fcs(bufp, 2 + orglen);
  fcs = ~fcs;

  len = compress(state, bufp + 2, wp, orglen);
  log_Printf(LogDEBUG, "Pred1Output: orglen (%d) --> len (%d)\n", orglen, len);
  ccp->uncompout += orglen;
  if (len < orglen) {
    *hp |= 0x80;
    wp += len;
    ccp->compout += len;
  } else {
    memcpy(wp, bufp + 2, orglen);
    wp += orglen;
    ccp->compout += orglen;
  }

  *wp++ = fcs & 0377;
  *wp++ = fcs >> 8;
  mwp->m_len = wp - MBUF_CTOP(mwp);
  *proto = ccp_Proto(ccp);
  return mwp;
}

static struct mbuf *
Pred1Input(void *v, struct ccp *ccp, u_short *proto, struct mbuf *bp)
{
  struct pred1_state *state = (struct pred1_state *)v;
  u_char *cp, *pp;
  int len, olen, len1;
  struct mbuf *wp;
  u_char *bufp;
  u_short fcs;

  wp = m_get(MAX_MRU + 2, MB_CCPIN);
  cp = MBUF_CTOP(bp);
  olen = m_length(bp);
  pp = bufp = MBUF_CTOP(wp);
  *pp++ = *cp & 0177;
  len = *cp++ << 8;
  *pp++ = *cp;
  len += *cp++;
  ccp->uncompin += len & 0x7fff;
  if (len & 0x8000) {
    len1 = decompress(state, cp, pp, olen - 4);
    ccp->compin += olen;
    len &= 0x7fff;
    if (len != len1) {		/* Error is detected. Send reset request */
      log_Printf(LogCCP, "Pred1: Length error (got %d, not %d)\n", len1, len);
      fsm_Reopen(&ccp->fsm);
      m_freem(bp);
      m_freem(wp);
      return NULL;
    }
    cp += olen - 4;
    pp += len1;
  } else if (len + 4 != olen) {
    log_Printf(LogCCP, "Pred1: Length error (got %d, not %d)\n", len + 4, olen);
    fsm_Reopen(&ccp->fsm);
    m_freem(wp);
    m_freem(bp);
    return NULL;
  } else {
    ccp->compin += len;
    SyncTable(state, cp, pp, len);
    cp += len;
    pp += len;
  }
  *pp++ = *cp++;		/* CRC */
  *pp++ = *cp++;
  fcs = hdlc_Fcs(bufp, wp->m_len = pp - bufp);
  if (fcs == GOODFCS) {
    wp->m_offset += 2;		/* skip length */
    wp->m_len -= 4;		/* skip length & CRC */
    pp = MBUF_CTOP(wp);
    *proto = *pp++;
    if (*proto & 1) {
      wp->m_offset++;
      wp->m_len--;
    } else {
      wp->m_offset += 2;
      wp->m_len -= 2;
      *proto = (*proto << 8) | *pp++;
    }
    m_freem(bp);
    return wp;
  } else {
    const char *pre = *MBUF_CTOP(bp) & 0x80 ? "" : "un";
    log_Printf(LogDEBUG, "Pred1Input: fcs = 0x%04x (%scompressed), len = 0x%x,"
	      " olen = 0x%x\n", fcs, pre, len, olen);
    log_Printf(LogCCP, "%s: Bad %scompressed CRC-16\n",
               ccp->fsm.link->name, pre);
    fsm_Reopen(&ccp->fsm);
    m_freem(wp);
  }
  m_freem(bp);
  return NULL;
}

static void
Pred1DictSetup(void *v, struct ccp *ccp, u_short proto, struct mbuf *bp)
{
}

static const char *
Pred1DispOpts(struct fsm_opt *o)
{
  return NULL;
}

static void
Pred1InitOptsOutput(struct bundle *bundle, struct fsm_opt *o,
                    const struct ccp_config *cfg)
{
  o->hdr.len = 2;
}

static int
Pred1SetOpts(struct bundle *bundle, struct fsm_opt *o,
             const struct ccp_config *cfg)
{
  if (o->hdr.len != 2) {
    o->hdr.len = 2;
    return MODE_NAK;
  }
  return MODE_ACK;
}

const struct ccp_algorithm Pred1Algorithm = {
  TY_PRED1,
  CCP_NEG_PRED1,
  Pred1DispOpts,
  ccp_DefaultUsable,
  ccp_DefaultRequired,
  {
    Pred1SetOpts,
    Pred1InitInput,
    Pred1Term,
    Pred1ResetInput,
    Pred1Input,
    Pred1DictSetup
  },
  {
    0,
    Pred1InitOptsOutput,
    Pred1SetOpts,
    Pred1InitOutput,
    Pred1Term,
    Pred1ResetOutput,
    Pred1Output
  },
};
@


1.14
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d29 1
a29 1
 *	$OpenBSD: pred.c,v 1.13 2002/05/16 01:13:39 brian Exp $
@


1.13
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d29 1
a29 1
 *	$OpenBSD: pred.c,v 1.12 2001/07/03 22:23:56 brian Exp $
d154 1
a154 1
Pred1InitInput(struct fsm_opt *o)
d164 1
a164 1
Pred1InitOutput(struct fsm_opt *o)
d303 2
a304 1
Pred1InitOptsOutput(struct fsm_opt *o, const struct ccp_config *cfg)
d310 2
a311 1
Pred1SetOpts(struct fsm_opt *o, const struct ccp_config *cfg)
@


1.12
log
@Reduce the interface MTU by 2 when MPPE has been successfully negotiated.

This is necessary because MPPE will combine the protocol id with the
payload received on the tun interface, encrypt it, then prepend its
own protocol id, effectively increasing the payload by two bytes.
@
text
@d29 1
a29 1
 *	$OpenBSD: pred.c,v 1.11 2001/06/19 10:24:57 brian Exp $
d154 1
a154 1
Pred1InitInput(struct lcp_opt *o)
d164 1
a164 1
Pred1InitOutput(struct lcp_opt *o)
d297 1
a297 1
Pred1DispOpts(struct lcp_opt *o)
d303 1
a303 1
Pred1InitOptsOutput(struct lcp_opt *o, const struct ccp_config *cfg)
d305 1
a305 1
  o->len = 2;
d309 1
a309 1
Pred1SetOptsOutput(struct lcp_opt *o, const struct ccp_config *cfg)
d311 2
a312 12
  if (o->len != 2) {
    o->len = 2;
    return MODE_NAK;
  }
  return MODE_ACK;
}

static int
Pred1SetOptsInput(struct lcp_opt *o, const struct ccp_config *cfg)
{
  if (o->len != 2) {
    o->len = 2;
d325 1
a325 1
    Pred1SetOptsInput,
d335 1
a335 1
    Pred1SetOptsOutput,
@


1.11
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d29 1
a29 1
 *	$OpenBSD: pred.c,v 1.10 2001/02/04 22:53:13 brian Exp $
d343 1
@


1.10
log
@Add a ``Usable'' function to the ccp switch.  The function
is called prior to sending a CCP configure request for a
given protocol.  The default is to send the request, but
this is overridden for MPPE which checks to see if the lcp
negotiations agreed CHAP81, and if not fails.

Use the same function to decide if we should reject peer
requests for MPPE.

This should get rid of those boring messages about not being
able to initialise MPPE when we don't negotiate CHAP81.
@
text
@d29 1
a29 1
 *	$OpenBSD: pred.c,v 1.9 2000/02/27 01:38:28 brian Exp $
d142 1
a142 1
static void
d149 2
d309 1
a309 1
Pred1SetOptsOutput(struct lcp_opt *o)
d321 5
a325 1
  return Pred1SetOptsOutput(o);
d332 2
a333 1
  ccp_IsUsable,
@


1.9
log
@$Id$ -> $OpenBSD$
@
text
@d29 1
a29 1
 *	$OpenBSD: pred.c,v 1.8 2000/01/07 03:26:55 brian Exp $
d326 1
@


1.8
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d29 1
a29 1
 *	$Id: pred.c,v 1.7 1999/06/02 15:58:41 brian Exp $
@


1.7
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d29 1
a29 1
 *	$Id: pred.c,v 1.6 1999/05/09 20:04:03 brian Exp $
d182 2
a183 2
  orglen = mbuf_Length(bp) + 2;	/* add count of proto */
  mwp = mbuf_Alloc((orglen + 2) / 8 * 9 + 12, MB_CCPOUT);
d209 1
a209 1
  mwp->cnt = wp - MBUF_CTOP(mwp);
d224 1
a224 1
  wp = mbuf_Alloc(MAX_MRU + 2, MB_CCPIN);
d226 1
a226 1
  olen = mbuf_Length(bp);
d240 2
a241 2
      mbuf_Free(bp);
      mbuf_Free(wp);
d249 2
a250 2
    mbuf_Free(wp);
    mbuf_Free(bp);
d260 1
a260 1
  fcs = hdlc_Fcs(bufp, wp->cnt = pp - bufp);
d262 2
a263 2
    wp->offset += 2;		/* skip length */
    wp->cnt -= 4;		/* skip length & CRC */
d267 2
a268 2
      wp->offset++;
      wp->cnt--;
d270 2
a271 2
      wp->offset += 2;
      wp->cnt -= 2;
d274 1
a274 1
    mbuf_Free(bp);
d283 1
a283 1
    mbuf_Free(wp);
d285 1
a285 1
  mbuf_Free(bp);
@


1.6
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d29 1
a29 1
 *	$Id: pred.c,v 1.5 1999/05/08 11:06:39 brian Exp $
d183 1
a183 1
  mwp = mbuf_Alloc((orglen + 2) / 8 * 9 + 12, MB_HDLCOUT);
d224 1
a224 1
  wp = mbuf_Alloc(MAX_MRU + 2, MB_IPIN);
@


1.5
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d29 1
a29 1
 *	$Id: pred.c,v 1.4 1999/03/16 01:21:52 brian Exp $
d290 1
a290 1
Pred1DictSetup(void *v, struct ccp *ccp, u_short proto, struct mbuf * bp)
@


1.4
log
@Detect pred1 packets where the length != the packet length
Use a maximum of MAX_MRU + 2 bytes for incoming packets, not
MAX_MTU + 2.
Tidy up some diagnostics.
@
text
@d29 1
a29 1
 *	$Id: pred.c,v 1.3 1999/03/11 01:50:04 brian Exp $
d36 1
d39 1
d171 2
a172 2
static int
Pred1Output(void *v, struct ccp *ccp, struct link *l, int pri, u_short proto,
d188 2
a189 2
  *cp++ = proto >> 8;
  *cp++ = proto & 0377;
d191 1
a191 1
  fcs = hdlc_Fcs(INITFCS, bufp, 2 + orglen);
d210 2
a211 2
  hdlc_Output(l, PRI_NORMAL, ccp_Proto(ccp), mwp);
  return 1;
d260 1
a260 1
  fcs = hdlc_Fcs(INITFCS, bufp, wp->cnt = pp - bufp);
@


1.3
log
@Tone down the log levels (Log{ERROR,WARN} -> LogCCP)
when we've simply missed a packet.

When our Predictor1 CRC is wrong (implying we've dropped
a packet), don't send a ResetReq().  Instead, send another
CCP ConfigReq().  *shrug*  My tests show this as being far
worse than the ResetReq as we may have further Nak/Rejs etc
and we're basically resetting both our incoming and outgoing
compression dictionaries, but rfc1978 says the ConfigReq is
correct, so we'd better go along...
@
text
@d29 1
a29 1
 *	$Id: pred.c,v 1.2 1999/02/06 03:22:43 brian Exp $
d90 1
a90 1
SyncTable(struct pred1_state *state, u_char * source, u_char * dest, int len)
d93 2
a94 3
    if (state->dict[state->hash] != *source)
      state->dict[state->hash] = *source;
    HASH(state, *dest++ = *source++);
d99 1
a99 1
decompress(struct pred1_state *state, u_char * source, u_char * dest, int len)
d222 1
a222 1
  wp = mbuf_Alloc(MAX_MTU + 2, MB_IPIN);
d244 6
a258 4
  if (fcs != GOODFCS)
    log_Printf(LogDEBUG, "Pred1Input: fcs = 0x%04x (%s), len = 0x%x,"
	      " olen = 0x%x\n", fcs, (fcs == GOODFCS) ? "good" : "bad",
	      len, olen);
d275 5
a279 1
    log_Printf(LogCCP, "%s: Bad CRC-16\n", ccp->fsm.link->name);
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d29 1
a29 1
 *	$Id: pred.c,v 1.22 1998/08/07 18:42:50 brian Exp $
d46 2
d237 2
a238 2
      log_Printf(LogCCP, "Pred1: Length error\n");
      ccp_SendResetReq(&ccp->fsm);
d274 2
a275 2
    log_DumpBp(LogHDLC, "Bad FCS", wp);
    ccp_SendResetReq(&ccp->fsm);
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

