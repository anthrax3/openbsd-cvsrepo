head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.50
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.46
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.44
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.42
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.40
	OPENBSD_5_0:1.20.0.38
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.36
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.34
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.30
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.32
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.28
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.26
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.24
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.22
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.20
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.18
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.16
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.14
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.12
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.10
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.8
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.6
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.17.0.4
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.20;

1.20
date	2002.06.17.01.14.08;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.16.14.27.21;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.01.22.41.23;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.19.11.06.35;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.06.02.15.58.41;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.05.08.11.06.38;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.04.19.16.59.40;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.03.31.14.22.11;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.02.20.01.15.13;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.02.06.03.22.42;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.02.09.49.57;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.01.13.50.27;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.25;	author brian;	state Exp;
branches;
next	;


desc
@@


1.21
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: pap.c,v 1.20 2002/06/17 01:14:08 brian Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <stdlib.h>
#include <string.h>		/* strlen/memcpy */
#include <termios.h>

#include "layer.h"
#include "mbuf.h"
#include "log.h"
#include "defs.h"
#include "timer.h"
#include "fsm.h"
#include "auth.h"
#include "pap.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "proto.h"
#include "async.h"
#include "throughput.h"
#include "ccp.h"
#include "link.h"
#include "descriptor.h"
#include "physical.h"
#include "iplist.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "chat.h"
#include "chap.h"
#include "cbcp.h"
#include "datalink.h"

static const char * const papcodes[] = {
  "???", "REQUEST", "SUCCESS", "FAILURE"
};
#define MAXPAPCODE (sizeof papcodes / sizeof papcodes[0] - 1)

static void
pap_Req(struct authinfo *authp)
{
  struct bundle *bundle = authp->physical->dl->bundle;
  struct fsmheader lh;
  struct mbuf *bp;
  u_char *cp;
  int namelen, keylen, plen;

  namelen = strlen(bundle->cfg.auth.name);
  keylen = strlen(bundle->cfg.auth.key);
  plen = namelen + keylen + 2;
  log_Printf(LogDEBUG, "pap_Req: namelen = %d, keylen = %d\n", namelen, keylen);
  log_Printf(LogPHASE, "Pap Output: %s ********\n", bundle->cfg.auth.name);
  if (*bundle->cfg.auth.name == '\0')
    log_Printf(LogWARN, "Sending empty PAP authname!\n");
  lh.code = PAP_REQUEST;
  lh.id = authp->id;
  lh.length = htons(plen + sizeof(struct fsmheader));
  bp = m_get(plen + sizeof(struct fsmheader), MB_PAPOUT);
  memcpy(MBUF_CTOP(bp), &lh, sizeof(struct fsmheader));
  cp = MBUF_CTOP(bp) + sizeof(struct fsmheader);
  *cp++ = namelen;
  memcpy(cp, bundle->cfg.auth.name, namelen);
  cp += namelen;
  *cp++ = keylen;
  memcpy(cp, bundle->cfg.auth.key, keylen);
  link_PushPacket(&authp->physical->link, bp, bundle,
                  LINK_QUEUES(&authp->physical->link) - 1, PROTO_PAP);
}

static void
SendPapCode(struct authinfo *authp, int code, const char *message)
{
  struct fsmheader lh;
  struct mbuf *bp;
  u_char *cp;
  int plen, mlen;

  lh.code = code;
  lh.id = authp->id;
  mlen = strlen(message);
  plen = mlen + 1;
  lh.length = htons(plen + sizeof(struct fsmheader));
  bp = m_get(plen + sizeof(struct fsmheader), MB_PAPOUT);
  memcpy(MBUF_CTOP(bp), &lh, sizeof(struct fsmheader));
  cp = MBUF_CTOP(bp) + sizeof(struct fsmheader);
  /*
   * If our message is longer than 255 bytes, truncate the length to
   * 255 and send the entire message anyway.  Maybe the other end will
   * display it... (see pap_Input() !)
   */
  *cp++ = mlen > 255 ? 255 : mlen;
  memcpy(cp, message, mlen);
  log_Printf(LogPHASE, "Pap Output: %s\n", papcodes[code]);

  link_PushPacket(&authp->physical->link, bp, authp->physical->dl->bundle,
                  LINK_QUEUES(&authp->physical->link) - 1, PROTO_PAP);
}

static void
pap_Success(struct authinfo *authp)
{
  struct bundle *bundle = authp->physical->dl->bundle;

  datalink_GotAuthname(authp->physical->dl, authp->in.name);
#ifndef NORADIUS
  if (*bundle->radius.cfg.file && bundle->radius.repstr)
    SendPapCode(authp, PAP_ACK, bundle->radius.repstr);
  else
#endif
    SendPapCode(authp, PAP_ACK, "Greetings!!");
  authp->physical->link.lcp.auth_ineed = 0;
  if (Enabled(bundle, OPT_UTMP))
    physical_Login(authp->physical, authp->in.name);

  if (authp->physical->link.lcp.auth_iwait == 0)
    /*
     * Either I didn't need to authenticate, or I've already been
     * told that I got the answer right.
     */
    datalink_AuthOk(authp->physical->dl);
}

static void
pap_Failure(struct authinfo *authp)
{
  SendPapCode(authp, PAP_NAK, "Login incorrect");
  datalink_AuthNotOk(authp->physical->dl);
}

void
pap_Init(struct authinfo *pap, struct physical *p)
{
  auth_Init(pap, p, pap_Req, pap_Success, pap_Failure);
}

struct mbuf *
pap_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
{
  struct physical *p = link2physical(l);
  struct authinfo *authp = &p->dl->pap;
  u_char nlen, klen, *key;
  const char *txt;
  int txtlen;

  if (p == NULL) {
    log_Printf(LogERROR, "pap_Input: Not a physical link - dropped\n");
    m_freem(bp);
    return NULL;
  }

  if (bundle_Phase(bundle) != PHASE_NETWORK &&
      bundle_Phase(bundle) != PHASE_AUTHENTICATE) {
    log_Printf(LogPHASE, "Unexpected pap input - dropped !\n");
    m_freem(bp);
    return NULL;
  }

  if ((bp = auth_ReadHeader(authp, bp)) == NULL &&
      ntohs(authp->in.hdr.length) == 0) {
    log_Printf(LogWARN, "Pap Input: Truncated header !\n");
    return NULL;
  }

  if (authp->in.hdr.code == 0 || authp->in.hdr.code > MAXPAPCODE) {
    log_Printf(LogPHASE, "Pap Input: %d: Bad PAP code !\n", authp->in.hdr.code);
    m_freem(bp);
    return NULL;
  }

  if (authp->in.hdr.code != PAP_REQUEST && authp->id != authp->in.hdr.id &&
      Enabled(bundle, OPT_IDCHECK)) {
    /* Wrong conversation dude ! */
    log_Printf(LogPHASE, "Pap Input: %s dropped (got id %d, not %d)\n",
               papcodes[authp->in.hdr.code], authp->in.hdr.id, authp->id);
    m_freem(bp);
    return NULL;
  }
  m_settype(bp, MB_PAPIN);
  authp->id = authp->in.hdr.id;		/* We respond with this id */

  if (bp) {
    bp = mbuf_Read(bp, &nlen, 1);
    if (authp->in.hdr.code == PAP_ACK) {
      /*
       * Don't restrict the length of our acknowledgement freetext to
       * nlen (a one-byte length).  Show the rest of the ack packet
       * instead.  This isn't really part of the protocol.....
       */
      bp = m_pullup(bp);
      txt = MBUF_CTOP(bp);
      txtlen = m_length(bp);
    } else {
      bp = auth_ReadName(authp, bp, nlen);
      txt = authp->in.name;
      txtlen = strlen(authp->in.name);
    }
  } else {
    txt = "";
    txtlen = 0;
  }

  log_Printf(LogPHASE, "Pap Input: %s (%.*s)\n",
             papcodes[authp->in.hdr.code], txtlen, txt);

  switch (authp->in.hdr.code) {
    case PAP_REQUEST:
      if (bp == NULL) {
        log_Printf(LogPHASE, "Pap Input: No key given !\n");
        break;
      }
      bp = mbuf_Read(bp, &klen, 1);
      if (m_length(bp) < klen) {
        log_Printf(LogERROR, "Pap Input: Truncated key !\n");
        break;
      }
      if ((key = malloc(klen+1)) == NULL) {
        log_Printf(LogERROR, "Pap Input: Out of memory !\n");
        break;
      }
      bp = mbuf_Read(bp, key, klen);
      key[klen] = '\0';

#ifndef NORADIUS
      if (*bundle->radius.cfg.file) {
        if (!radius_Authenticate(&bundle->radius, authp, authp->in.name,
                                 key, strlen(key), NULL, 0))
          pap_Failure(authp);
      } else
#endif
      if (auth_Validate(bundle, authp->in.name, key, p))
        pap_Success(authp);
      else
        pap_Failure(authp);

      free(key);
      break;

    case PAP_ACK:
      auth_StopTimer(authp);
      if (p->link.lcp.auth_iwait == PROTO_PAP) {
        p->link.lcp.auth_iwait = 0;
        if (p->link.lcp.auth_ineed == 0)
          /*
           * We've succeeded in our ``login''
           * If we're not expecting  the peer to authenticate (or he already
           * has), proceed to network phase.
           */
          datalink_AuthOk(p->dl);
      }
      break;

    case PAP_NAK:
      auth_StopTimer(authp);
      datalink_AuthNotOk(p->dl);
      break;
  }

  m_freem(bp);
  return NULL;
}
@


1.20
log
@Compensate for dodgy Win98/WinME MSCHAPv2 responses later in the code
path... after we've talked to any RADIUS servers involved, so that we
haven't touched the data before it gets to the server.
@
text
@d28 1
a28 1
 * $OpenBSD: pap.c,v 1.19 2002/05/16 14:27:21 brian Exp $
@


1.19
log
@Handle MS-CHAPv2 authentication correctly via the RADIUS server (if it's
configured).

This doesn't yet work with MPPE.  More to follow.
@
text
@d28 1
a28 1
 * $OpenBSD: pap.c,v 1.18 2002/05/16 01:13:39 brian Exp $
d269 1
a269 1
                                 key, strlen(key), NULL, 0, NULL, 0))
@


1.18
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: pap.c,v 1.17 2001/08/19 23:22:18 brian Exp $
d267 5
a271 4
      if (*bundle->radius.cfg.file)
        radius_Authenticate(&bundle->radius, authp, authp->in.name,
                            key, strlen(key), NULL, 0);
      else
@


1.17
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: pap.c,v 1.16 2001/06/13 21:33:41 brian Exp $
a62 1
#include "ip.h"
d145 2
d148 6
a153 1
  SendPapCode(authp, PAP_ACK, "Greetings!!");
d155 1
a155 1
  if (Enabled(authp->physical->dl->bundle, OPT_UTMP))
@


1.16
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d35 1
d62 2
d70 2
@


1.15
log
@Don't assume challenges and responses don't contain embedded '\0's.

Mschapv2 response generation may produce embedded NULs... causing
us to send a bogus response to the radius server and end up
failing the client's valid response.

Problem pointed out by: Eugene Vigovskiy <vigov@@com2com.ru>
@
text
@d1 5
a5 2
/*
 *			PPP PAP Module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 2
 *   Copyright (C) 1993-94, Internet Initiative Japan, Inc.
 *		     All rights reserverd.
d28 1
a28 15
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: pap.c,v 1.14 2000/07/19 11:06:35 brian Exp $
 *
 *	TODO:
d30 1
@


1.14
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d21 1
a21 1
 * $OpenBSD: pap.c,v 1.13 2000/02/27 01:38:27 brian Exp $
d252 1
a252 1
                            key, NULL);
@


1.13
log
@$Id$ -> $OpenBSD$
@
text
@d21 1
a21 1
 * $OpenBSD: pap.c,v 1.12 2000/01/07 03:26:55 brian Exp $
a40 1
#include "lcp.h"
d45 1
@


1.12
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.11 1999/07/15 02:10:32 brian Exp $
@


1.11
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.9 1999/06/02 15:58:41 brian Exp $
d32 1
a32 1
#include <string.h>
d67 3
a69 1
static const char *papcodes[] = { "???", "REQUEST", "SUCCESS", "FAILURE" };
d91 1
a91 1
  bp = mbuf_Alloc(plen + sizeof(struct fsmheader), MB_PAPOUT);
d99 2
a100 1
  link_PushPacket(&authp->physical->link, bp, bundle, PRI_LINK, PROTO_PAP);
d116 1
a116 1
  bp = mbuf_Alloc(plen + sizeof(struct fsmheader), MB_PAPOUT);
d119 6
a124 1
  *cp++ = mlen;
d129 1
a129 1
                  PRI_LINK, PROTO_PAP);
d168 2
d173 1
a173 1
    mbuf_Free(bp);
d180 1
a180 1
    mbuf_Free(bp);
d192 1
a192 1
    mbuf_Free(bp);
d201 1
a201 1
    mbuf_Free(bp);
d204 1
a204 1
  mbuf_SetType(bp, MB_PAPIN);
d209 17
a225 1
    bp = auth_ReadName(authp, bp, nlen);
d228 2
a229 2
  log_Printf(LogPHASE, "Pap Input: %s (%s)\n",
             papcodes[authp->in.hdr.code], authp->in.name);
d238 1
a238 1
      if (mbuf_Length(bp) < klen) {
d283 1
a283 1
  mbuf_Free(bp);
@


1.10
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d32 1
a32 1
/* #include <string.h> (auto-remove) */
@


1.9
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.8 1999/05/08 11:06:38 brian Exp $
d32 1
a32 1
#include <string.h>
@


1.8
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.7 1999/04/19 16:59:40 brian Exp $
d89 1
a89 1
  bp = mbuf_Alloc(plen + sizeof(struct fsmheader), MB_FSM);
d113 1
a113 1
  bp = mbuf_Alloc(plen + sizeof(struct fsmheader), MB_FSM);
d194 1
@


1.7
log
@Escape stuff in the peers accmap as well as our own when async
encoding, and back out the negotiation strategy that didn't
quite have the right effect with some (bad?) ppp implementations.

Drop unexpected PAP/CHAP packets (if not in NETWORK or ESTABLISH
phase).

Make sure that we enter PHASE_ESTABLISH when we need to.

Detect HDLC frames correctly, not just when the whole header
is obtained by a single read().

Don't convert \r\n to \r\r\n in tty raw mode.

Use the correct macros for `', ``'', () and [].
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.6 1999/03/31 14:22:11 brian Exp $
d35 1
d46 1
a46 1
#include "lcpproto.h"
d97 1
a97 2

  hdlc_Output(&authp->physical->link, PRI_LINK, PROTO_PAP, bp);
d120 2
a121 1
  hdlc_Output(&authp->physical->link, PRI_LINK, PROTO_PAP, bp);
d154 2
a155 2
void
pap_Input(struct physical *p, struct mbuf *bp)
d157 1
d161 8
a168 2
  if (bundle_Phase(p->dl->bundle) != PHASE_NETWORK &&
      bundle_Phase(p->dl->bundle) != PHASE_AUTHENTICATE) {
d171 1
a171 1
    return;
d177 1
a177 1
    return;
d183 1
a183 1
    return;
d187 1
a187 1
      Enabled(p->dl->bundle, OPT_IDCHECK)) {
d192 1
a192 1
    return;
d223 2
a224 2
      if (*p->dl->bundle->radius.cfg.file)
        radius_Authenticate(&p->dl->bundle->radius, authp, authp->in.name,
d228 1
a228 1
      if (auth_Validate(p->dl->bundle, authp->in.name, key, p))
d257 1
@


1.6
log
@Avoid a few warnings on the alpha
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.5 1999/02/20 01:15:13 brian Exp $
d158 7
@


1.5
log
@Handle empty PAP & CHAP packets (containing only an FSM header).
Some CHAP implementations send no welcome message with their
SUCCESS/FAILURE packets.  This was being mis-identified as
a truncated packet by the new authentication code :-(
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.4 1999/02/06 03:22:42 brian Exp $
d32 1
@


1.4
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.30 1999/02/02 09:35:17 brian Exp $
d158 3
a160 1
  if ((bp = auth_ReadHeader(authp, bp)) == NULL)
d162 1
@


1.3
log
@Reimplement the previous fix (no response to PAP requests)
at the authentication layer rather than at the PAP layer
so that it also applies to CHAP (no response to CHAP
challenges).
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.2 1999/02/01 13:50:27 brian Exp $
d25 1
a25 1
#include <sys/types.h>
d31 1
a31 1
#include <string.h>
d56 3
d66 1
d68 2
a69 2
void
pap_SendChallenge(struct authinfo *auth, int papid, struct physical *physical)
d71 1
d77 2
a78 2
  namelen = strlen(physical->dl->bundle->cfg.auth.name);
  keylen = strlen(physical->dl->bundle->cfg.auth.key);
d80 3
a82 5
  log_Printf(LogDEBUG, "pap_SendChallenge: namelen = %d, keylen = %d\n",
	    namelen, keylen);
  log_Printf(LogPHASE, "Pap Output: %s ********\n",
             physical->dl->bundle->cfg.auth.name);
  if (*physical->dl->bundle->cfg.auth.name == '\0')
d85 1
a85 1
  lh.id = papid;
d91 1
a91 1
  memcpy(cp, physical->dl->bundle->cfg.auth.name, namelen);
d94 1
a94 1
  memcpy(cp, physical->dl->bundle->cfg.auth.key, keylen);
d96 1
a96 1
  hdlc_Output(&physical->link, PRI_LINK, PROTO_PAP, bp);
d100 1
a100 1
SendPapCode(int id, int code, const char *message, struct physical *physical)
d108 1
a108 1
  lh.id = id;
d118 19
a136 1
  hdlc_Output(&physical->link, PRI_LINK, PROTO_PAP, bp);
d139 6
a144 15
/*
 * Validate given username and passwrd against with secret table
 */
static int
PapValidate(struct bundle *bundle, u_char *name, u_char *key,
            struct physical *physical)
{
  int nlen, klen;

  nlen = *name++;
  klen = *key;
  *key++ = 0;
  key[klen] = 0;
  log_Printf(LogDEBUG, "PapValidate: name %s (%d), key %s (%d)\n",
	    name, nlen, key, klen);
d146 4
a149 1
  return auth_Validate(bundle, name, key, physical);
d153 1
a153 1
pap_Input(struct bundle *bundle, struct mbuf *bp, struct physical *physical)
d155 47
a201 3
  int len = mbuf_Length(bp);
  struct fsmheader *php;
  u_char *cp;
d203 25
a227 53
  if (len >= sizeof(struct fsmheader)) {
    php = (struct fsmheader *) MBUF_CTOP(bp);
    if (len >= ntohs(php->length)) {
      if (php->code < PAP_REQUEST || php->code > PAP_NAK)
	php->code = 0;
      switch (php->code) {
      case PAP_REQUEST:
	cp = (u_char *) (php + 1);
        log_Printf(LogPHASE, "Pap Input: %s (%.*s)\n",
                   papcodes[php->code], *cp, cp + 1);
	if (PapValidate(bundle, cp, cp + *cp + 1, physical)) {
          datalink_GotAuthname(physical->dl, cp+1, *cp);
	  SendPapCode(php->id, PAP_ACK, "Greetings!!", physical);
	  physical->link.lcp.auth_ineed = 0;
          if (Enabled(bundle, OPT_UTMP))
            physical_Login(physical, cp + 1);

          if (physical->link.lcp.auth_iwait == 0)
            /*
             * Either I didn't need to authenticate, or I've already been
             * told that I got the answer right.
             */
            datalink_AuthOk(physical->dl);
	} else {
	  SendPapCode(php->id, PAP_NAK, "Login incorrect", physical);
          datalink_AuthNotOk(physical->dl);
	}
	break;
      case PAP_ACK:
	auth_StopTimer(&physical->dl->pap);
	cp = (u_char *) (php + 1);
	len = *cp++;
	cp[len] = 0;
	log_Printf(LogPHASE, "Pap Input: %s (%s)\n", papcodes[php->code], cp);
	if (physical->link.lcp.auth_iwait == PROTO_PAP) {
	  physical->link.lcp.auth_iwait = 0;
	  if (physical->link.lcp.auth_ineed == 0)
            /*
             * We've succeeded in our ``login''
             * If we're not expecting  the peer to authenticate (or he already
             * has), proceed to network phase.
             */
            datalink_AuthOk(physical->dl);
	}
	break;
      case PAP_NAK:
	auth_StopTimer(&physical->dl->pap);
	cp = (u_char *) (php + 1);
	len = *cp++;
	cp[len] = 0;
	log_Printf(LogPHASE, "Pap Input: %s (%s)\n", papcodes[php->code], cp);
        datalink_AuthNotOk(physical->dl);
	break;
d229 6
a234 1
    }
d236 1
@


1.2
log
@If we receive no answer from the server when sending PAP
requests, give up (don't sit there indefinitely).
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.1 1998/08/31 00:22:25 brian Exp $
a134 8
}

void
pap_Failed(struct physical *p)
{
  auth_StopTimer(&p->dl->pap);
  log_Printf(LogPHASE, "Pap: No response from server\n");
  datalink_AuthNotOk(p->dl);
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d21 1
a21 1
 * $Id: pap.c,v 1.27 1998/08/26 18:07:57 brian Exp $
d138 8
a174 1

@

