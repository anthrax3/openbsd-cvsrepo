head	1.13;
access;
symbols
	OPENBSD_5_5:1.12.0.40
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.36
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.34
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.32
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.30
	OPENBSD_5_0:1.12.0.28
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.26
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.24
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.20
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.22
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.18
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.16
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.14
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.14
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.12
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.10
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.8
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.6
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.12;

1.12
date	2004.11.16.14.47.02;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.11.01.29.57;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.02.15.58.41;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.09.20.04.03;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.37;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.29.08.20.33;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.42;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.24;	author brian;	state Exp;
branches;
next	;


desc
@@


1.13
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: mbuf.h,v 1.12 2004/11/16 14:47:02 brad Exp $
 */

struct mbuf {
  size_t m_size;		/* size allocated (excluding header) */
  short m_offset;		/* offset from header end to start position */
  size_t m_len;			/* available byte count in buffer */
  short m_type;			/* MB_* below */
  struct mbuf *m_next;		/* link to next mbuf */
  struct mbuf *m_nextpkt;	/* link to next packet */
  unsigned long priv;		/* private data - holds HDLC escape count */
  /* buffer space is malloc()d directly after the header */
};

struct mqueue {
  struct mbuf *top;
  struct mbuf *last;
  size_t len;
};

#define MBUF_CTOP(bp) \
	((bp) ? (u_char *)((bp)+1) + (bp)->m_offset : NULL)

#define CONST_MBUF_CTOP(bp) \
	((bp) ? (const u_char *)((bp)+1) + (bp)->m_offset : NULL)

#define MB_IPIN		0
#define MB_IPOUT	1
#define MB_IPV6IN	2
#define MB_IPV6OUT	3
#define MB_NATIN	4
#define MB_NATOUT	5
#define MB_MPIN		6
#define MB_MPOUT	7
#define MB_VJIN		8
#define MB_VJOUT	9
#define MB_ICOMPDIN	10
#define MB_ICOMPDOUT	11
#define MB_COMPDIN	12
#define MB_COMPDOUT	13
#define MB_LQRIN	14
#define MB_LQROUT	15
#define MB_ECHOIN	16
#define MB_ECHOOUT	17
#define MB_PROTOIN	18
#define MB_PROTOOUT	19
#define MB_ACFIN	20
#define MB_ACFOUT	21
#define MB_SYNCIN	22
#define MB_SYNCOUT	23
#define MB_HDLCIN	24
#define MB_HDLCOUT	25
#define MB_ASYNCIN	26
#define MB_ASYNCOUT	27
#define MB_CBCPIN	28
#define MB_CBCPOUT	29
#define MB_CHAPIN	30
#define MB_CHAPOUT	31
#define MB_PAPIN	32
#define MB_PAPOUT	33
#define MB_CCPIN	34
#define MB_CCPOUT	35
#define MB_IPCPIN	36
#define MB_IPCPOUT	37
#define MB_IPV6CPIN	38
#define MB_IPV6CPOUT	39
#define MB_LCPIN	40
#define MB_LCPOUT	41
#define MB_UNKNOWN	42
#define MB_MAX		MB_UNKNOWN

#define M_MAXLEN	(4352 - sizeof(struct mbuf))	/* > HDLCSIZE */

struct cmdargs;

extern int m_length(struct mbuf *);
extern struct mbuf *m_get(size_t, int);
extern struct mbuf *m_free(struct mbuf *);
extern void m_freem(struct mbuf *);
extern void mbuf_Write(struct mbuf *, const void *, size_t);
extern struct mbuf *mbuf_Read(struct mbuf *, void *, size_t);
extern size_t mbuf_View(struct mbuf *, void *, size_t);
extern struct mbuf *m_prepend(struct mbuf *, const void *, size_t, size_t);
extern struct mbuf *m_adj(struct mbuf *, ssize_t);
extern struct mbuf *m_pullup(struct mbuf *);
extern void m_settype(struct mbuf *, int);
extern struct mbuf *m_append(struct mbuf *, const void *, size_t);

extern int mbuf_Show(struct cmdargs const *);

extern void m_enqueue(struct mqueue *, struct mbuf *);
extern struct mbuf *m_dequeue(struct mqueue *);
@


1.12
log
@Re-implement LQM, this time according to the rfc.

From FreeBSD

ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: mbuf.h,v 1.11 2001/08/19 23:22:18 brian Exp $
@


1.11
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: mbuf.h,v 1.10 2001/06/13 21:33:41 brian Exp $
d38 1
@


1.10
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d55 41
a95 37
#define MB_NATIN	2
#define MB_NATOUT	3
#define MB_MPIN		4
#define MB_MPOUT	5
#define MB_VJIN		6
#define MB_VJOUT	7
#define MB_ICOMPDIN	8
#define MB_ICOMPDOUT	9
#define MB_COMPDIN	10
#define MB_COMPDOUT	11
#define MB_LQRIN	12
#define MB_LQROUT	13
#define MB_ECHOIN	14
#define MB_ECHOOUT	15
#define MB_PROTOIN	16
#define MB_PROTOOUT	17
#define MB_ACFIN	18
#define MB_ACFOUT	19
#define MB_SYNCIN	20
#define MB_SYNCOUT	21
#define MB_HDLCIN	22
#define MB_HDLCOUT	23
#define MB_ASYNCIN	24
#define MB_ASYNCOUT	25
#define MB_CBCPIN	26
#define MB_CBCPOUT	27
#define MB_CHAPIN	28
#define MB_CHAPOUT	29
#define MB_PAPIN	30
#define MB_PAPOUT	31
#define MB_CCPIN	32
#define MB_CCPOUT	33
#define MB_IPCPIN	34
#define MB_IPCPOUT	35
#define MB_LCPIN	36
#define MB_LCPOUT	37
#define MB_UNKNOWN	38
@


1.9
log
@Increase M_MAXBUF so that it's greater than HDLCSIZE
@
text
@d1 5
a5 2
/*
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d7 8
a14 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d16 11
a26 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d28 1
a28 3
 * $OpenBSD: mbuf.h,v 1.8 2000/02/27 01:38:27 brian Exp $
 *
 *	TODO:
@


1.8
log
@$Id$ -> $OpenBSD$
@
text
@d18 1
a18 1
 * $OpenBSD: mbuf.h,v 1.7 2000/01/07 03:26:55 brian Exp $
d86 1
a86 1
#define M_MAXLEN	(4096 - sizeof(struct mbuf))
@


1.7
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d18 1
a18 1
 * $Id: mbuf.h,v 1.6 1999/06/02 15:58:41 brian Exp $
@


1.6
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d18 1
a18 1
 * $Id: mbuf.h,v 1.5 1999/05/09 20:04:03 brian Exp $
d24 6
a29 6
  short size;			/* size allocated (excluding header) */
  short offset;			/* offset from header end to start position */
  short cnt;			/* available byte count in buffer */
  short type;			/* MB_* below */
  struct mbuf *next;		/* link to next mbuf */
  struct mbuf *pnext;		/* link to next packet */
d36 1
a36 1
  int qlen;
d40 1
a40 1
	((bp) ? (u_char *)((bp)+1) + (bp)->offset : NULL)
d43 1
a43 1
	((bp) ? (const u_char *)((bp)+1) + (bp)->offset : NULL)
d47 2
a48 2
#define MB_ALIASIN	2
#define MB_ALIASOUT	3
d86 2
d90 4
a93 4
extern int mbuf_Length(struct mbuf *);
extern struct mbuf *mbuf_Alloc(int, int);
extern struct mbuf *mbuf_FreeSeg(struct mbuf *);
extern void mbuf_Free(struct mbuf *);
d97 6
a102 2
extern struct mbuf *mbuf_Prepend(struct mbuf *, const void *, size_t, size_t);
extern struct mbuf *mbuf_Truncate(struct mbuf *, size_t);
d104 3
a106 4
extern void mbuf_Enqueue(struct mqueue *, struct mbuf *);
extern struct mbuf *mbuf_Dequeue(struct mqueue *);
extern struct mbuf *mbuf_Contiguous(struct mbuf *);
extern void mbuf_SetType(struct mbuf *, int);
@


1.5
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d18 1
a18 1
 * $Id: mbuf.h,v 1.4 1999/05/08 11:06:37 brian Exp $
d45 40
a84 11
#define MB_ASYNC	1
#define MB_FSM		2
#define MB_CBCP		3
#define MB_HDLCOUT	4
#define MB_IPIN		5
#define MB_ECHO		6
#define MB_LQR		7
#define MB_VJCOMP	8
#define	MB_IPQ		9
#define	MB_MP		10
#define	MB_MAX		MB_MP
a96 1
extern void mbuf_Log(void);
d101 1
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d18 1
a18 1
 * $Id: mbuf.h,v 1.3 1999/03/29 08:20:33 brian Exp $
d39 5
a43 2
#define MBUF_CTOP(bp)		((u_char *)((bp)+1) + (bp)->offset)
#define CONST_MBUF_CTOP(bp)	((const u_char *)((bp)+1) + (bp)->offset)
@


1.3
log
@Ensure that the thing we're casting to struct ip
is aligned for non-i386 architectures.
@
text
@d18 1
a18 1
 * $Id: mbuf.h,v 1.2 1999/02/06 03:22:42 brian Exp $
d49 3
a51 4
#define MB_LINK		8
#define MB_VJCOMP	9
#define	MB_IPQ		10
#define	MB_MP		11
d60 5
a64 2
extern void mbuf_Write(struct mbuf *, u_char *, int);
extern struct mbuf *mbuf_Read(struct mbuf *, u_char *, int);
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d18 1
a18 1
 * $Id: mbuf.h,v 1.14 1998/08/21 18:10:15 brian Exp $
d67 1
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

