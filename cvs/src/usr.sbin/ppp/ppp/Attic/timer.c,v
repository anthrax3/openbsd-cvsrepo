head	1.15;
access;
symbols
	OPENBSD_5_5:1.14.0.38
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.34
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.32
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.30
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.28
	OPENBSD_5_0:1.14.0.26
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.24
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.22
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.18
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.20
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.16
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.14
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.12
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.10
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.12
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.10
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.8
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.6
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2014.03.17.17.15.52;	author deraadt;	state dead;
branches;
next	1.14;

1.14
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.15.08.02.01;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.13.21.33.42;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.27.01.38.29;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.27.00.21.10;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.07.03.26.56;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.12.19.11.06;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.09.20.04.04;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.22.49;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.04.11.54.48;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.29;	author brian;	state Exp;
branches;
next	;


desc
@@


1.15
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: timer.c,v 1.14 2005/07/17 19:13:25 brad Exp $
 */

#include <errno.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <sys/time.h>
#include <termios.h>

#include "log.h"
#include "sig.h"
#include "timer.h"
#include "descriptor.h"
#include "prompt.h"


#define RESTVAL(t) \
    ((t).it_value.tv_sec * SECTICKS + (t).it_value.tv_usec / TICKUNIT + \
     ((((t).it_value.tv_usec % TICKUNIT) >= (TICKUNIT >> 1)) ? 1 : 0))

static struct pppTimer *TimerList = NULL, *ExpiredList = NULL;

static void StopTimerNoBlock(struct pppTimer *);

static const char *
tState2Nam(u_int state)
{
  static const char * const StateNames[] = { "stopped", "running", "expired" };

  if (state >= sizeof StateNames / sizeof StateNames[0])
    return "unknown";
  return StateNames[state];
}

void
timer_Stop(struct pppTimer *tp)
{
  sigset_t mask, omask;

  sigemptyset(&mask);
  sigaddset(&mask, SIGALRM);
  sigprocmask(SIG_BLOCK, &mask, &omask);
  StopTimerNoBlock(tp);
  sigprocmask(SIG_SETMASK, &omask, NULL);
}

void
timer_Start(struct pppTimer *tp)
{
  struct itimerval itimer;
  struct pppTimer *t, *pt;
  u_long ticks = 0;
  sigset_t mask, omask;

  sigemptyset(&mask);
  sigaddset(&mask, SIGALRM);
  sigprocmask(SIG_BLOCK, &mask, &omask);

  if (tp->state != TIMER_STOPPED)
    StopTimerNoBlock(tp);

  if (tp->load == 0) {
    log_Printf(LogTIMER, "%s timer[%p] has 0 load!\n", tp->name, tp);
    sigprocmask(SIG_SETMASK, &omask, NULL);
    return;
  }

  /* Adjust our first delta so that it reflects what's really happening */
  if (TimerList && getitimer(ITIMER_REAL, &itimer) == 0)
    TimerList->rest = RESTVAL(itimer);

  pt = NULL;
  for (t = TimerList; t; t = t->next) {
    if (ticks + t->rest >= tp->load)
      break;
    ticks += t->rest;
    pt = t;
  }

  tp->state = TIMER_RUNNING;
  tp->rest = tp->load - ticks;

  if (t)
    log_Printf(LogTIMER, "timer_Start: Inserting %s timer[%p] before %s "
              "timer[%p], delta = %ld\n", tp->name, tp, t->name, t, tp->rest);
  else
    log_Printf(LogTIMER, "timer_Start: Inserting %s timer[%p]\n", tp->name, tp);

  /* Insert given *tp just before *t */
  tp->next = t;
  if (pt) {
    pt->next = tp;
  } else {
    TimerList = tp;
    timer_InitService(t != NULL);	/* [re]Start the Timer Service */
  }
  if (t)
    t->rest -= tp->rest;

  sigprocmask(SIG_SETMASK, &omask, NULL);
}

static void
StopTimerNoBlock(struct pppTimer *tp)
{
  struct pppTimer *t, *pt;

  /*
   * A RUNNING timer must be removed from TimerList (->next list).
   * A STOPPED timer isn't in any list, but may have a bogus [e]next field.
   * An EXPIRED timer is in the ->enext list.
   */

  if (tp->state == TIMER_STOPPED)
    return;

  pt = NULL;
  for (t = TimerList; t != tp && t != NULL; t = t->next)
    pt = t;

  if (t) {
    if (pt)
      pt->next = t->next;
    else {
      TimerList = t->next;
      if (TimerList == NULL)	/* Last one ? */
	timer_TermService();	/* Terminate Timer Service */
    }
    if (t->next) {
      if (!pt) {		/* t (tp) was the first in the list */
        struct itimerval itimer;

        if (getitimer(ITIMER_REAL, &itimer) == 0)
          t->rest = RESTVAL(itimer);
      }
      t->next->rest += t->rest;
      if (!pt)			/* t->next is now the first in the list */
        timer_InitService(1);
    }
  } else {
    /* Search for any pending expired timers */
    pt = NULL;
    for (t = ExpiredList; t != tp && t != NULL; t = t->enext)
      pt = t;

    if (t) {
      if (pt)
        pt->enext = t->enext;
      else
        ExpiredList = t->enext;
    } else if (tp->state == TIMER_RUNNING)
      log_Printf(LogERROR, "Oops, %s timer not found!!\n", tp->name);
  }

  tp->next = tp->enext = NULL;
  tp->state = TIMER_STOPPED;
}

static void
TimerService(void)
{
  struct pppTimer *tp, *exp, *next;

  if (log_IsKept(LogTIMER)) {
    static time_t t;		/* Only show timers globally every second */
    time_t n = time(NULL);

    if (n > t)
      timer_Show(LogTIMER, NULL);
    t = n;
  }

  tp = TimerList;
  if (tp) {
    tp->rest = 0;

    /* Multiple timers might expire at once. Create a list of expired timers */
    exp = NULL;
    do {
      tp->state = TIMER_EXPIRED;
      next = tp->next;
      tp->enext = exp;
      exp = tp;
      tp = next;
    } while (tp && tp->rest == 0);

    TimerList = tp;
    if (TimerList != NULL)	/* Any timers remaining ? */
      timer_InitService(1);	/* Restart the Timer Service */
    else
      timer_TermService();	/* Stop the Timer Service */

    /* Process all expired timers */
    while (exp) {
      ExpiredList = exp->enext;
      exp->enext = NULL;
      if (exp->func)
        (*exp->func)(exp->arg);
      exp = ExpiredList;
    }
  }
}

void
timer_Show(int LogLevel, struct prompt *prompt)
{
  struct itimerval itimer;
  struct pppTimer *pt;
  u_long rest = 0;

  /* Adjust our first delta so that it reflects what's really happening */
  if (TimerList && getitimer(ITIMER_REAL, &itimer) == 0)
    TimerList->rest = RESTVAL(itimer);

#define SECS(val)	((val) / SECTICKS)
#define HSECS(val)	(((val) % SECTICKS) * 100 / SECTICKS)
#define DISP								\
  "%s timer[%p]: freq = %ld.%02lds, next = %lu.%02lus, state = %s\n",	\
  pt->name, pt, SECS(pt->load), HSECS(pt->load), SECS(rest),		\
  HSECS(rest), tState2Nam(pt->state)

  if (!prompt)
    log_Printf(LogLevel, "---- Begin of Timer Service List---\n");

  for (pt = TimerList; pt; pt = pt->next) {
    rest += pt->rest;
    if (prompt)
      prompt_Printf(prompt, DISP);
    else
      log_Printf(LogLevel, DISP);
  }

  if (!prompt)
    log_Printf(LogLevel, "---- End of Timer Service List ---\n");
}

void
timer_InitService(int restart)
{
  struct itimerval itimer;

  if (TimerList) {
    if (!restart)
      sig_signal(SIGALRM, (void (*)(int))TimerService);
    itimer.it_interval.tv_sec = 0;
    itimer.it_interval.tv_usec = 0;
    itimer.it_value.tv_sec = TimerList->rest / SECTICKS;
    itimer.it_value.tv_usec = (TimerList->rest % SECTICKS) * TICKUNIT;
    if (setitimer(ITIMER_REAL, &itimer, NULL) == -1)
      log_Printf(LogERROR, "Unable to set itimer (%s)\n", strerror(errno));
  }
}

void
timer_TermService(void)
{
  struct itimerval itimer;

  itimer.it_interval.tv_usec = itimer.it_interval.tv_sec = 0;
  itimer.it_value.tv_usec = itimer.it_value.tv_sec = 0;
  if (setitimer(ITIMER_REAL, &itimer, NULL) == -1)
    log_Printf(LogERROR, "Unable to set itimer (%s)\n", strerror(errno));
  sig_signal(SIGALRM, SIG_IGN);
}
@


1.14
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: timer.c,v 1.13 2002/06/15 08:02:01 brian Exp $
@


1.13
log
@Tidy up end of line whitespace
@
text
@d28 1
a28 1
 * $OpenBSD: timer.c,v 1.12 2002/06/15 01:33:23 brian Exp $
d33 1
@


1.12
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d28 1
a28 1
 * $OpenBSD: timer.c,v 1.11 2002/05/16 01:13:39 brian Exp $
d214 1
a214 1
  
d220 1
a220 1
  
d265 1
a265 1
void 
d282 1
a282 1
void 
@


1.11
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: timer.c,v 1.10 2001/09/04 23:35:59 millert Exp $
a34 1
#ifdef __NetBSD__
a35 1
#endif
@


1.10
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d28 1
a28 1
 * $OpenBSD: timer.c,v 1.9 2001/06/13 21:33:42 brian Exp $
d35 1
d37 1
@


1.9
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d66 1
a66 1
  int omask;
d68 3
a70 1
  omask = sigblock(sigmask(SIGALRM));
d72 1
a72 1
  sigsetmask(omask);
d81 1
a81 1
  int omask;
d83 3
a85 1
  omask = sigblock(sigmask(SIGALRM));
d92 1
a92 1
    sigsetmask(omask);
d128 1
a128 1
  sigsetmask(omask);
@


1.8
log
@$Id$ -> $OpenBSD$
@
text
@d1 5
a5 2
/*
 *		PPP Timer Processing Module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 15
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: timer.c,v 1.7 2000/02/27 00:21:10 brian Exp $
 *
 *  TODO:
@


1.7
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d20 1
a20 1
 * $Id: timer.c,v 1.6 2000/01/07 03:26:56 brian Exp $
@


1.6
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: timer.c,v 1.5 1999/05/12 19:11:06 brian Exp $
d38 5
d88 1
a88 2
    TimerList->rest = itimer.it_value.tv_sec * SECTICKS +
                      itimer.it_value.tv_usec / TICKUNIT;
d140 1
a140 1
    if (pt) {
d142 1
a142 1
    } else {
d147 11
a157 2
    if (t->next)
      t->next->rest += tp->rest;
d231 1
a231 2
    TimerList->rest = itimer.it_value.tv_sec * SECTICKS +
                      itimer.it_value.tv_usec / TICKUNIT;
@


1.5
log
@Adjust our first timer delta according to the return
from getitimer() so that times are correct for
``show timer''.
@
text
@d20 1
a20 1
 * $Id: timer.c,v 1.4 1999/05/09 20:04:04 brian Exp $
d38 1
a38 1
static struct pppTimer *TimerList = NULL;
d45 1
a45 1
  static const char *StateNames[] = { "stopped", "running", "expired" };
d65 1
d80 6
d109 1
a109 1
    timer_InitService(0);	/* Start the Timer Service */
d127 2
a128 3
  if (tp->state != TIMER_RUNNING) {
    tp->next = NULL;
    tp->state = TIMER_STOPPED;
d130 1
a130 1
  }
d134 1
d145 14
a158 2
  } else
    log_Printf(LogERROR, "Oops, %s timer not found!!\n", tp->name);
d160 1
a160 1
  tp->next = NULL;
d200 1
a200 1
      next = exp->enext;
d204 1
a204 1
      exp = next;
@


1.4
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d20 1
a20 1
 * $Id: timer.c,v 1.3 1999/02/06 03:22:49 brian Exp $
d28 1
d193 1
d195 6
a200 1
  int rest = 0;
d205 1
a205 1
  "%s timer[%p]: freq = %ld.%02lds, next = %d.%02ds, state = %s\n",	\
d237 1
a237 1
      log_Printf(LogERROR, "Unable to set itimer (%s)\n", sys_errlist[errno]);
d249 1
a249 1
    log_Printf(LogERROR, "Unable to set itimer (%s)\n", sys_errlist[errno]);
@


1.3
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: timer.c,v 1.32 1998/12/14 19:24:29 brian Exp $
d52 1
a52 1
timer_Stop(struct pppTimer * tp)
d62 1
a62 1
timer_Start(struct pppTimer * tp)
d110 1
a110 1
StopTimerNoBlock(struct pppTimer * tp)
@


1.2
log
@Change the timer routines so that they interrupt when the next
item is scheduled rather than interrupting 10 times per second
and finding that there's nothing to do most of the time.
This change reduces interrupt overheads but will expose any
(previously small) latency problems.

Be more careful about building VJ compression requests - we
can't htonl/ntohl the entire four bytes !  Also, when we get
a NAK, try to get as close as possible to what the peer NAKs
with when sending our next REQ.  Similarily when we send a NAK,
pick values as close as possible to what the peer REQd.

Fix a couple of man page typos (compliments of billf@@FreeBSD.org)
@
text
@@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: timer.c,v 1.31 1998/06/27 14:18:11 brian Exp $
d25 1
a99 1
    timer_InitService();
d101 1
d147 1
a147 1
  struct pppTimer *tp, *exp, *wt;
d157 1
d160 1
a160 2
    tp->rest--;
    if (tp->rest == 0) {
d162 23
a184 32
      /*
       * Multiple timers may expires at once. Create list of expired timers.
       */
      exp = NULL;
      do {
	tp->state = TIMER_EXPIRED;
	wt = tp->next;
	tp->enext = exp;
	exp = tp;
	tp = wt;
      } while (tp && (tp->rest == 0));

      TimerList = tp;
      if (TimerList == NULL)	/* No timers ? */
	timer_TermService();	/* Terminate Timer Service */

      /*
       * Process all expired timers.
       */
      while (exp) {
#ifdef notdef
	timer_Stop(exp);
#endif
	if (exp->func)
	  (*exp->func) (exp->arg);

	/*
	 * Just Removing each item from expired list And exp->enext will be
	 * intialized at next expire in this funtion.
	 */
	exp = exp->enext;
      }
d218 1
a218 1
timer_InitService()
d222 10
a231 5
  sig_signal(SIGALRM, (void (*) (int)) TimerService);
  itimer.it_interval.tv_sec = itimer.it_value.tv_sec = 0;
  itimer.it_interval.tv_usec = itimer.it_value.tv_usec = TICKUNIT;
  if (setitimer(ITIMER_REAL, &itimer, NULL) == -1)
    log_Printf(LogERROR, "Unable to set itimer.\n");
d242 1
a242 1
    log_Printf(LogERROR, "Unable to set itimer.\n");
@

