head	1.28;
access;
symbols
	OPENBSD_5_5:1.27.0.20
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.16
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.14
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.12
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.10
	OPENBSD_5_0:1.27.0.8
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.6
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.26.0.20
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.16
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.14
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.12
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.10
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.8
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.6
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.23.0.8
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.6
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10;
locks; strict;
comment	@ * @;


1.28
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.27;

1.27
date	2009.08.31.08.01.33;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.26.01.32.25;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.06.13.56.00;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.07.23.58.53;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.23.11.17.03;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.09.00.08.55;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.07.09.32.55;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.24.01.06.02;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.28.21.56.35;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.02.00.54.34;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.11.22.13.03;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.07.14.47.54;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.23.09.47.05;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.02.01.36.20;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.31.14.32.51;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.29.09.32.37;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.29.00.14.20;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.19.12.38.19;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.04.02.21.58;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.03.21.52.57;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.27.00.21.08;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	;


desc
@@


1.28
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 2001 Charles Mott <cm@@linktel.net>
 *                    Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: nat_cmd.c,v 1.27 2009/08/31 08:01:33 claudio Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>

#ifdef LOCALNAT
#include "alias.h"
#else
#include <alias.h>
#endif

#include "layer.h"
#include "proto.h"
#include "defs.h"
#include "command.h"
#include "log.h"
#include "nat_cmd.h"
#include "descriptor.h"
#include "prompt.h"
#include "timer.h"
#include "fsm.h"
#include "slcompress.h"
#include "throughput.h"
#include "iplist.h"
#include "mbuf.h"
#include "lqr.h"
#include "hdlc.h"
#include "ncpaddr.h"
#include "ip.h"
#include "ipcp.h"
#include "ipv6cp.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "mp.h"
#include "filter.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ncp.h"
#include "bundle.h"


#define NAT_EXTRABUF (13)

static int StrToAddr(const char *, struct in_addr *);
static int StrToPortRange(const char *, u_short *, u_short *, const char *);
static int StrToAddrAndPort(const char *, struct in_addr *, u_short *,
                            u_short *, const char *);

static void
lowhigh(u_short *a, u_short *b)
{
  if (a > b) {
    u_short c;

    c = *b;
    *b = *a;
    *a = c;
  }
}

int
nat_RedirectPort(struct cmdargs const *arg)
{
  if (!arg->bundle->NatEnabled) {
    prompt_Printf(arg->prompt, "Alias not enabled\n");
    return 1;
  } else if (arg->argc == arg->argn + 3 || arg->argc == arg->argn + 4) {
    char proto_constant;
    const char *proto;
    struct in_addr localaddr;
    u_short hlocalport, llocalport;
    struct in_addr aliasaddr;
    u_short haliasport, laliasport;
    struct in_addr remoteaddr;
    u_short hremoteport, lremoteport;
    struct alias_link *link;
    int error;

    proto = arg->argv[arg->argn];
    if (strcmp(proto, "tcp") == 0) {
      proto_constant = IPPROTO_TCP;
    } else if (strcmp(proto, "udp") == 0) {
      proto_constant = IPPROTO_UDP;
    } else {
      prompt_Printf(arg->prompt, "port redirect: protocol must be"
                    " tcp or udp\n");
      return -1;
    }

    error = StrToAddrAndPort(arg->argv[arg->argn+1], &localaddr, &llocalport,
                             &hlocalport, proto);
    if (error) {
      prompt_Printf(arg->prompt, "nat port: error reading localaddr:port\n");
      return -1;
    }

    error = StrToPortRange(arg->argv[arg->argn+2], &laliasport, &haliasport,
                           proto);
    if (error) {
      prompt_Printf(arg->prompt, "nat port: error reading alias port\n");
      return -1;
    }
    aliasaddr.s_addr = INADDR_ANY;

    if (arg->argc == arg->argn + 4) {
      error = StrToAddrAndPort(arg->argv[arg->argn+3], &remoteaddr,
                               &lremoteport, &hremoteport, proto);
      if (error) {
        prompt_Printf(arg->prompt, "nat port: error reading "
                      "remoteaddr:port\n");
        return -1;
      }
    } else {
      remoteaddr.s_addr = INADDR_ANY;
      lremoteport = hremoteport = 0;
    }

    lowhigh(&llocalport, &hlocalport);
    lowhigh(&laliasport, &haliasport);
    lowhigh(&lremoteport, &hremoteport);

    if (haliasport - laliasport != hlocalport - llocalport) {
      prompt_Printf(arg->prompt, "nat port: local & alias port ranges "
                    "are not equal\n");
      return -1;
    }

    if (hremoteport && hremoteport - lremoteport != hlocalport - llocalport) {
      prompt_Printf(arg->prompt, "nat port: local & remote port ranges "
                    "are not equal\n");
      return -1;
    }

    do {
      link = PacketAliasRedirectPort(localaddr, htons(llocalport),
				     remoteaddr, htons(lremoteport),
                                     aliasaddr, htons(laliasport),
				     proto_constant);

      if (link == NULL) {
        prompt_Printf(arg->prompt, "nat port: %d: error %d\n", laliasport,
                      error);
        return 1;
      }
      llocalport++;
      if (hremoteport)
        lremoteport++;
    } while (laliasport++ < haliasport);

    return 0;
  }

  return -1;
}


int
nat_RedirectAddr(struct cmdargs const *arg)
{
  if (!arg->bundle->NatEnabled) {
    prompt_Printf(arg->prompt, "nat not enabled\n");
    return 1;
  } else if (arg->argc == arg->argn+2) {
    int error;
    struct in_addr localaddr, aliasaddr;
    struct alias_link *link;

    error = StrToAddr(arg->argv[arg->argn], &localaddr);
    if (error) {
      prompt_Printf(arg->prompt, "address redirect: invalid local address\n");
      return 1;
    }
    error = StrToAddr(arg->argv[arg->argn+1], &aliasaddr);
    if (error) {
      prompt_Printf(arg->prompt, "address redirect: invalid alias address\n");
      prompt_Printf(arg->prompt, "usage: nat %s %s\n", arg->cmd->name,
                    arg->cmd->syntax);
      return 1;
    }
    link = PacketAliasRedirectAddr(localaddr, aliasaddr);
    if (link == NULL) {
      prompt_Printf(arg->prompt, "address redirect: packet aliasing"
                    " engine error\n");
      prompt_Printf(arg->prompt, "usage: nat %s %s\n", arg->cmd->name,
                    arg->cmd->syntax);
    }
  } else
    return -1;

  return 0;
}


int
nat_RedirectProto(struct cmdargs const *arg)
{
  if (!arg->bundle->NatEnabled) {
    prompt_Printf(arg->prompt, "nat not enabled\n");
    return 1;
  } else if (arg->argc >= arg->argn + 2 && arg->argc <= arg->argn + 4) {
    struct in_addr localIP, publicIP, remoteIP;
    struct alias_link *link;
    struct protoent *pe;
    int error, len;

    len = strlen(arg->argv[arg->argn]);
    if (len == 0) {
      prompt_Printf(arg->prompt, "proto redirect: invalid protocol\n");
      return 1;
    }
    if (strspn(arg->argv[arg->argn], "01234567") == len)
      pe = getprotobynumber(atoi(arg->argv[arg->argn]));
    else
      pe = getprotobyname(arg->argv[arg->argn]);
    if (pe == NULL) {
      prompt_Printf(arg->prompt, "proto redirect: invalid protocol\n");
      return 1;
    }

    error = StrToAddr(arg->argv[arg->argn + 1], &localIP);
    if (error) {
      prompt_Printf(arg->prompt, "proto redirect: invalid src address\n");
      return 1;
    }

    if (arg->argc >= arg->argn + 3) {
      error = StrToAddr(arg->argv[arg->argn + 2], &publicIP);
      if (error) {
        prompt_Printf(arg->prompt, "proto redirect: invalid alias address\n");
        prompt_Printf(arg->prompt, "usage: nat %s %s\n", arg->cmd->name,
                      arg->cmd->syntax);
        return 1;
      }
    } else
      publicIP.s_addr = INADDR_ANY;

    if (arg->argc == arg->argn + 4) {
      error = StrToAddr(arg->argv[arg->argn + 2], &remoteIP);
      if (error) {
        prompt_Printf(arg->prompt, "proto redirect: invalid dst address\n");
        prompt_Printf(arg->prompt, "usage: nat %s %s\n", arg->cmd->name,
                      arg->cmd->syntax);
        return 1;
      }
    } else
      remoteIP.s_addr = INADDR_ANY;

    link = PacketAliasRedirectProto(localIP, remoteIP, publicIP, pe->p_proto);
    if (link == NULL) {
      prompt_Printf(arg->prompt, "proto redirect: packet aliasing"
                    " engine error\n");
      prompt_Printf(arg->prompt, "usage: nat %s %s\n", arg->cmd->name,
                    arg->cmd->syntax);
    }
  } else
    return -1;

  return 0;
}


static int
StrToAddr(const char *str, struct in_addr *addr)
{
  struct hostent *hp;

  if (inet_aton(str, addr))
    return 0;

  hp = gethostbyname(str);
  if (!hp) {
    log_Printf(LogWARN, "StrToAddr: Unknown host %s.\n", str);
    return -1;
  }
  *addr = *((struct in_addr *) hp->h_addr);
  return 0;
}


static int
StrToPort(const char *str, u_short *port, const char *proto)
{
  struct servent *sp;
  char *end;

  *port = strtol(str, &end, 10);
  if (*end != '\0') {
    sp = getservbyname(str, proto);
    if (sp == NULL) {
      log_Printf(LogWARN, "StrToAddr: Unknown port or service %s/%s.\n",
	        str, proto);
      return -1;
    }
    *port = ntohs(sp->s_port);
  }

  return 0;
}

static int
StrToPortRange(const char *str, u_short *low, u_short *high, const char *proto)
{
  char *minus;
  int res;

  minus = strchr(str, '-');
  if (minus)
    *minus = '\0';		/* Cheat the const-ness ! */

  res = StrToPort(str, low, proto);

  if (minus)
    *minus = '-';		/* Cheat the const-ness ! */

  if (res == 0) {
    if (minus)
      res = StrToPort(minus + 1, high, proto);
    else
      *high = *low;
  }

  return res;
}

static int
StrToAddrAndPort(const char *str, struct in_addr *addr, u_short *low,
                 u_short *high, const char *proto)
{
  char *colon;
  int res;

  colon = strchr(str, ':');
  if (!colon) {
    log_Printf(LogWARN, "StrToAddrAndPort: %s is missing port number.\n", str);
    return -1;
  }

  *colon = '\0';		/* Cheat the const-ness ! */
  res = StrToAddr(str, addr);
  *colon = ':';			/* Cheat the const-ness ! */
  if (res != 0)
    return -1;

  return StrToPortRange(colon + 1, low, high, proto);
}

int
nat_ProxyRule(struct cmdargs const *arg)
{
  char cmd[LINE_LEN];
  int f, pos;
  size_t len;

  if (arg->argn >= arg->argc)
    return -1;

  for (f = arg->argn, pos = 0; f < arg->argc; f++) {
    len = strlen(arg->argv[f]);
    if (sizeof cmd - pos < len + (len ? 1 : 0))
      break;
    if (len)
      cmd[pos++] = ' ';
    strlcpy(cmd + pos, arg->argv[f], sizeof cmd - pos);
    pos += len;
  }

  return PacketAliasProxyRule(cmd);
}

int
nat_SetTarget(struct cmdargs const *arg)
{
  struct in_addr addr;

  if (arg->argc == arg->argn) {
    addr.s_addr = INADDR_ANY;
    PacketAliasSetTarget(addr);
    return 0;
  }

  if (arg->argc != arg->argn + 1)
    return -1;

  if (!strcasecmp(arg->argv[arg->argn], "MYADDR")) {
    addr.s_addr = INADDR_ANY;
    PacketAliasSetTarget(addr);
    return 0;
  }

  addr = GetIpAddr(arg->argv[arg->argn]);
  if (addr.s_addr == INADDR_NONE) {
    log_Printf(LogWARN, "%s: invalid address\n", arg->argv[arg->argn]);
    return 1;
  }

  PacketAliasSetTarget(addr);
  return 0;
}

#ifndef NO_FW_PUNCH
int
nat_PunchFW(struct cmdargs const *arg)
{
  char *end;
  long base, count;

  if (arg->argc == arg->argn) {
    PacketAliasSetMode(0, PKT_ALIAS_PUNCH_FW);
    return 0;
  }

  if (arg->argc != arg->argn + 2)
    return -1;

  base = strtol(arg->argv[arg->argn], &end, 10);
  if (*end != '\0' || base < 0)
    return -1;

  count = strtol(arg->argv[arg->argn + 1], &end, 10);
  if (*end != '\0' || count < 0)
    return -1;

  PacketAliasSetFWBase(base, count);
  PacketAliasSetMode(PKT_ALIAS_PUNCH_FW, PKT_ALIAS_PUNCH_FW);

  return 0;
}
#endif

int
nat_SkinnyPort(struct cmdargs const *arg)
{
  char *end;
  long port;

  if (arg->argc == arg->argn) {
    PacketAliasSetSkinnyPort(0);
    return 0;
  }

  if (arg->argc != arg->argn + 1)
    return -1;

  port = strtol(arg->argv[arg->argn], &end, 10);
  if (*end != '\0' || port < 0)
    return -1;

  PacketAliasSetSkinnyPort(port);

  return 0;
}

static struct mbuf *
nat_LayerPush(struct bundle *bundle, struct link *l, struct mbuf *bp,
                int pri, u_short *proto)
{
  if (!bundle->NatEnabled || *proto != PROTO_IP)
    return bp;

  log_Printf(LogDEBUG, "nat_LayerPush: PROTO_IP -> PROTO_IP\n");
  m_settype(bp, MB_NATOUT);
  /* Ensure there's a bit of extra buffer for the NAT code... */
  bp = m_pullup(m_append(bp, NULL, NAT_EXTRABUF));
  PacketAliasOut(MBUF_CTOP(bp), bp->m_len);
  bp->m_len = ntohs(((struct ip *)MBUF_CTOP(bp))->ip_len);

  return bp;
}

static struct mbuf *
nat_LayerPull(struct bundle *bundle, struct link *l, struct mbuf *bp,
                u_short *proto)
{
  static int gfrags;
  int ret, len, nfrags;
  struct mbuf **last;
  char *fptr;

  if (!bundle->NatEnabled || *proto != PROTO_IP)
    return bp;

  log_Printf(LogDEBUG, "nat_LayerPull: PROTO_IP -> PROTO_IP\n");
  m_settype(bp, MB_NATIN);
  /* Ensure there's a bit of extra buffer for the NAT code... */
  bp = m_pullup(m_append(bp, NULL, NAT_EXTRABUF));
  ret = PacketAliasIn(MBUF_CTOP(bp), bp->m_len);

  bp->m_len = ntohs(((struct ip *)MBUF_CTOP(bp))->ip_len);
  if (bp->m_len > MAX_MRU) {
    log_Printf(LogWARN, "nat_LayerPull: Problem with IP header length (%lu)\n",
               (unsigned long)bp->m_len);
    m_freem(bp);
    return NULL;
  }

  switch (ret) {
    case PKT_ALIAS_OK:
      break;

    case PKT_ALIAS_UNRESOLVED_FRAGMENT:
      /* Save the data for later */
      if ((fptr = malloc(bp->m_len)) == NULL) {
	log_Printf(LogWARN, "nat_LayerPull: Dropped unresolved fragment -"
		   " out of memory!\n");
	m_freem(bp);
	bp = NULL;
      } else {
	bp = mbuf_Read(bp, fptr, bp->m_len);
	PacketAliasSaveFragment(fptr);
	log_Printf(LogDEBUG, "Store another frag (%lu) - now %d\n",
		   (unsigned long)((struct ip *)fptr)->ip_id, ++gfrags);
      }
      break;

    case PKT_ALIAS_FOUND_HEADER_FRAGMENT:
      /* Fetch all the saved fragments and chain them on the end of `bp' */
      last = &bp->m_nextpkt;
      nfrags = 0;
      while ((fptr = PacketAliasGetFragment(MBUF_CTOP(bp))) != NULL) {
        nfrags++;
        PacketAliasFragmentIn(MBUF_CTOP(bp), fptr);
        len = ntohs(((struct ip *)fptr)->ip_len);
        *last = m_get(len, MB_NATIN);
        memcpy(MBUF_CTOP(*last), fptr, len);
        free(fptr);
        last = &(*last)->m_nextpkt;
      }
      gfrags -= nfrags;
      log_Printf(LogDEBUG, "Found a frag header (%lu) - plus %d more frags (no"
                 "w %d)\n", (unsigned long)((struct ip *)MBUF_CTOP(bp))->ip_id,
                 nfrags, gfrags);
      break;

    case PKT_ALIAS_IGNORED:
      if (PacketAliasSetMode(0, 0) & PKT_ALIAS_DENY_INCOMING) {
        log_Printf(LogTCPIP, "NAT engine denied data:\n");
        m_freem(bp);
        bp = NULL;
      } else if (log_IsKept(LogTCPIP)) {
        log_Printf(LogTCPIP, "NAT engine ignored data:\n");
        PacketCheck(bundle, AF_INET, MBUF_CTOP(bp), bp->m_len, NULL,
                    NULL, NULL);
      }
      break;

    default:
      log_Printf(LogWARN, "nat_LayerPull: Dropped a packet (%d)....\n", ret);
      m_freem(bp);
      bp = NULL;
      break;
  }

  return bp;
}

struct layer natlayer =
  { LAYER_NAT, "nat", nat_LayerPush, nat_LayerPull };
@


1.27
log
@Don't get stuck in an infinite loop comparing u_short <= USHRT_MAX which
can happen if a nat port command with a end range of 65535 is used.
See also http://www.freebsd.org/cgi/query-pr.cgi?pr=136893
From FreeBSD via brad.
@
text
@d27 1
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.26 2005/07/26 01:32:25 brad Exp $
@


1.26
log
@Add Cisco Skinny Station Protocol translation support to libalias
and supporting applications (ppp).

From marcus FreeBSD
@
text
@d27 1
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.25 2005/07/17 19:13:25 brad Exp $
d176 1
a176 1
    while (laliasport <= haliasport) {
a187 1
      laliasport++;
d190 1
a190 1
    }
@


1.25
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d27 1
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.24 2005/07/06 13:56:00 brad Exp $
d472 23
@


1.24
log
@Add a bunch of malloc() return checks

From brian FreeBSD

ok deraadt@@ tdeval@@
@
text
@d27 1
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.23 2003/04/07 23:58:53 deraadt Exp $
d40 1
@


1.23
log
@more string cleaning; ok tedu
@
text
@d27 1
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.22 2002/05/16 01:13:39 brian Exp $
d521 11
a531 5
      fptr = malloc(bp->m_len);
      bp = mbuf_Read(bp, fptr, bp->m_len);
      PacketAliasSaveFragment(fptr);
      log_Printf(LogDEBUG, "Store another frag (%lu) - now %d\n",
                 (unsigned long)((struct ip *)fptr)->ip_id, ++gfrags);
@


1.22
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d27 1
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.21 2001/11/23 11:17:03 brian Exp $
d405 1
a405 1
    strcpy(cmd + pos, arg->argv[f]);
@


1.21
log
@cmott@@scientech.com -> cm@@linktel.net
Add the UPTIME variable
CCP protocol ``0xffffffff'' -> ``none''
Don't leak memory when expanding command arguments and not exec()ing
Make some functions static
Add the ``log'' command for manual logging
Fix some log text bogons
@
text
@d27 1
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.20 2001/08/19 23:22:18 brian Exp $
d218 1
a218 1
      prompt_Printf(arg->prompt, "Usage: nat %s %s\n", arg->cmd->name,
d226 1
a226 1
      prompt_Printf(arg->prompt, "Usage: nat %s %s\n", arg->cmd->name,
d272 1
a272 1
        prompt_Printf(arg->prompt, "Usage: nat %s %s\n", arg->cmd->name,
d283 1
a283 1
        prompt_Printf(arg->prompt, "Usage: nat %s %s\n", arg->cmd->name,
d294 1
a294 1
      prompt_Printf(arg->prompt, "Usage: nat %s %s\n", arg->cmd->name,
@


1.20
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Charles Mott <cmott@@scientech.com>
d27 1
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.19 2001/07/09 00:08:55 brian Exp $
@


1.19
log
@Add a ``nat proto'' command -- similar to natd(8)'s -redirect_proto switch.
@
text
@d27 1
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.18 2001/06/07 09:32:55 brian Exp $
d37 1
d67 2
d70 1
d79 1
a79 1
#include "ip.h"
d442 30
d554 2
a555 1
        PacketCheck(bundle, MBUF_CTOP(bp), bp->m_len, NULL, NULL, NULL);
@


1.18
log
@Depricate the -alias option (it's been -nat for a long time)
Handle carriage-return/line-feed stuff for ftp natting more generically
Fix an alignment bug when logging DNS traffic
Fix/add some copyrights
@
text
@d27 1
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.17 2001/03/24 01:06:02 brian Exp $
d221 68
@


1.17
log
@Remove some unprotected prototype variable names
MAXPATHLEN -> PATH_MAX
Handle ENOENT from opening /dev/tun* properly
Rename _PATH_PPP -> PPP_CONFDIR and allow it to be redefined at compile time
Reduce MIN_LQRPERIOD and MIN_FSMRETRY to 1 second
Be smarter about identifying sockets on stdin
Allow primary DNS IP negotiation when the secondary IP has been rejected
Fix the call to PacketAliasProxyRule() properly.
Add/fix some comments
Fix man page markups; ru@@FreeBSD.org
Use localhost when no hostname is configured
@
text
@d2 3
a4 2
 * The code in this file was written by Eivind Eklund <perhaps@@yes.no>,
 * who places it in the public domain without restriction.
d6 22
a27 1
 *	$OpenBSD: nat_cmd.c,v 1.16 2001/01/28 21:56:35 brian Exp $
@


1.16
log
@Don't pass a buffer with leading spaces to PacketAliasProxyRule()
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.15 2000/11/02 00:54:34 brian Exp $
d307 1
a307 1
    if (sizeof cmd - pos < len + (f ? 1 : 0))
d309 1
a309 1
    if (f)
d315 1
a315 1
  return PacketAliasProxyRule(cmd + strspn(cmd, " \t"));
@


1.15
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.14 2000/07/11 22:13:03 brian Exp $
d315 1
a315 1
  return PacketAliasProxyRule(cmd);
@


1.14
log
@Allow a ``timeout secs'' filter option to let specific packet types
effect the idle timer in different ways.

Submitted by: Stefan Esser <se@@freebsd.org>

With adjustments by me to document the option in the man page and to
give the same semantics for outgoing traffic as incoming.

I made the style more consistent in ip.c - this should really have
been done as a separate commit.
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.13 2000/07/07 14:47:54 brian Exp $
d424 5
a428 1
      if (log_IsKept(LogTCPIP)) {
@


1.13
log
@o  Log the (payload/size) of all packet types, not just TCP packets

o  If the new ``filter-decapsulation'' is enabled, delve into UDP packets
   that contain 0xff 0x03 as the first two bytes, and if we recognise it
   as PROTO_IP, decapsulate it for the purpose of filter checking.

   If we recognise it as PROTO_<anything else> mention this for logging
   purposes only.

This change is aimed at people running PPPoUDP where the UDP traffic is
being sent over another PPP link.  It's desireable to have the top level
link connected all the time, but to have the bottom level link capable
of decapsulating the traffic and comparing the payload against the filters,
thus allowing ``set filter dial ...'' to work in tunnelled environments.

The caveat here is that the top ppp cannot employ any compression layers
without making the data unreadable for the bottom ppp.  ``disable deflate
pred1 vj'' and ``deny deflate pred1 vj'' is suggested.
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.12 2000/06/23 09:47:05 brian Exp $
d426 1
a426 1
        PacketCheck(bundle, MBUF_CTOP(bp), bp->m_len, NULL, NULL);
@


1.12
log
@Improved 227, 229 and EPRT support in the nat code; FreeBSD
Moved security checks into one place; FreeBSD
Remove ``nat pptp'' now that it's transparent
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.11 2000/06/13 09:57:51 brian Exp $
d426 1
a426 1
        PacketCheck(bundle, MBUF_CTOP(bp), bp->m_len, NULL);
@


1.11
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.10 2000/04/02 01:36:20 brian Exp $
a315 24
}

int
nat_Pptp(struct cmdargs const *arg)
{
  struct in_addr addr;

  if (arg->argc == arg->argn) {
    addr.s_addr = INADDR_NONE;
    PacketAliasPptp(addr);
    return 0;
  }

  if (arg->argc != arg->argn + 1)
    return -1;

  addr = GetIpAddr(arg->argv[arg->argn]);
  if (addr.s_addr == INADDR_NONE) {
    log_Printf(LogWARN, "%s: invalid address\n", arg->argv[arg->argn]);
    return 1;
  }

  PacketAliasPptp(addr);
  return 0;
@


1.10
log
@Make the default ``nat target'' address INADDR_NONE, meaning
incoming connections go to the NAT address.  Make a ``nat target''
address of INADDR_ANY allow connections from outside directly into
the internal network.

Change some s_addr == 0 to s_addr == INADDR_ANY
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.9 2000/03/31 14:32:51 brian Exp $
d348 1
a348 1
    addr.s_addr = INADDR_NONE;
d356 6
a393 1
  struct ip *pip, *piip;
a402 8
  bp = m_pullup(bp);
  pip = (struct ip *)MBUF_CTOP(bp);
  piip = (struct ip *)((char *)pip + (pip->ip_hl << 2));

  if (pip->ip_p == IPPROTO_IGMP ||
      (pip->ip_p == IPPROTO_IPIP && IN_CLASSD(ntohl(piip->ip_dst.s_addr))))
    return bp;

a405 1
  pip = (struct ip *)MBUF_CTOP(bp);
d407 1
a407 1
  bp->m_len = ntohs(pip->ip_len);
d450 1
a450 1
        PacketCheck(bundle, (char *)pip, ntohs(pip->ip_len), NULL);
a451 2
      m_freem(bp);
      bp = NULL;
@


1.9
log
@Add the ``nat target'' command.
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.8 2000/03/29 09:32:37 brian Exp $
d348 1
a348 1
    addr.s_addr = INADDR_ANY;
@


1.8
log
@Log information about packets being dropped (probably due to
``nat deny_incoming yes'') by libalias.
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.7 2000/03/29 00:14:20 brian Exp $
d339 24
@


1.7
log
@Mention the value of the unexpected return code in nat_LayerPull()
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.6 2000/03/19 12:38:19 brian Exp $
d53 1
d425 9
@


1.6
log
@Add some diagnostics to prove that incoming IP fragments are
being dealt with correctly.
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.5 2000/03/04 02:21:58 brian Exp $
d427 1
a427 1
      log_Printf(LogWARN, "nat_LayerPull: Dropped a packet....\n");
@


1.5
log
@Refresh the NAT IP pointer after a potential mbuf reallocation.  This
caused frequent lock-ups for individual sessions over a NAT'd ppp link
when MTU sizes ended up more or less exactly wrong.
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.4 2000/03/03 21:52:57 brian Exp $
d362 1
d364 1
a364 1
  int ret, len;
d403 2
d410 1
d412 2
a413 1
	PacketAliasFragmentIn(MBUF_CTOP(bp), fptr);
d420 4
d427 1
@


1.4
log
@Fix some printf-type argument bugs
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.3 2000/02/27 01:38:27 brian Exp $
d383 1
@


1.3
log
@$Id$ -> $OpenBSD$
@
text
@d5 1
a5 1
 *	$OpenBSD: nat_cmd.c,v 1.2 2000/02/27 00:21:08 brian Exp $
d386 2
a387 2
    log_Printf(LogWARN, "nat_LayerPull: Problem with IP header length (%d)\n",
               bp->m_len);
@


1.2
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d5 1
a5 1
 *	$Id: nat_cmd.c,v 1.1 2000/01/07 03:26:55 brian Exp $
@


1.1
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d5 1
a5 1
 *	$Id$
d22 3
a24 1
#ifdef __FreeBSD__
a25 2
#else
#include "alias.h"
d27 1
@

