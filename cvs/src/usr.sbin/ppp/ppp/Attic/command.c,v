head	1.95;
access;
symbols
	OPENBSD_5_5:1.94.0.4
	OPENBSD_5_5_BASE:1.94
	OPENBSD_5_4:1.93.0.2
	OPENBSD_5_4_BASE:1.93
	OPENBSD_5_3:1.92.0.22
	OPENBSD_5_3_BASE:1.92
	OPENBSD_5_2:1.92.0.20
	OPENBSD_5_2_BASE:1.92
	OPENBSD_5_1_BASE:1.92
	OPENBSD_5_1:1.92.0.18
	OPENBSD_5_0:1.92.0.16
	OPENBSD_5_0_BASE:1.92
	OPENBSD_4_9:1.92.0.14
	OPENBSD_4_9_BASE:1.92
	OPENBSD_4_8:1.92.0.12
	OPENBSD_4_8_BASE:1.92
	OPENBSD_4_7:1.92.0.8
	OPENBSD_4_7_BASE:1.92
	OPENBSD_4_6:1.92.0.10
	OPENBSD_4_6_BASE:1.92
	OPENBSD_4_5:1.92.0.6
	OPENBSD_4_5_BASE:1.92
	OPENBSD_4_4:1.92.0.4
	OPENBSD_4_4_BASE:1.92
	OPENBSD_4_3:1.92.0.2
	OPENBSD_4_3_BASE:1.92
	OPENBSD_4_2:1.91.0.8
	OPENBSD_4_2_BASE:1.91
	OPENBSD_4_1:1.91.0.6
	OPENBSD_4_1_BASE:1.91
	OPENBSD_4_0:1.91.0.4
	OPENBSD_4_0_BASE:1.91
	OPENBSD_3_9:1.91.0.2
	OPENBSD_3_9_BASE:1.91
	OPENBSD_3_8:1.88.0.2
	OPENBSD_3_8_BASE:1.88
	OPENBSD_3_7:1.80.0.2
	OPENBSD_3_7_BASE:1.80
	OPENBSD_3_6:1.79.0.4
	OPENBSD_3_6_BASE:1.79
	OPENBSD_3_5:1.79.0.2
	OPENBSD_3_5_BASE:1.79
	OPENBSD_3_4:1.78.0.2
	OPENBSD_3_4_BASE:1.78
	OPENBSD_3_3:1.77.0.4
	OPENBSD_3_3_BASE:1.77
	OPENBSD_3_2:1.77.0.2
	OPENBSD_3_2_BASE:1.77
	OPENBSD_3_1:1.72.0.2
	OPENBSD_3_1_BASE:1.72
	OPENBSD_3_0:1.69.0.2
	OPENBSD_3_0_BASE:1.69
	OPENBSD_2_9_BASE:1.58
	OPENBSD_2_9:1.58.0.2
	OPENBSD_2_8:1.52.0.2
	OPENBSD_2_8_BASE:1.52
	OPENBSD_2_7:1.41.0.2
	OPENBSD_2_7_BASE:1.41
	OPENBSD_2_6:1.35.0.2
	OPENBSD_2_6_BASE:1.35
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.95
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.94;

1.94
date	2013.11.24.00.54.30;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.92;

1.92
date	2008.03.02.18.46.32;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2005.09.21.16.28.47;	author brad;	state Exp;
branches
	1.91.6.1
	1.91.8.1;
next	1.90;

1.90
date	2005.09.21.15.04.28;	author brad;	state Exp;
branches;
next	1.89;

1.89
date	2005.09.21.01.59.26;	author brad;	state Exp;
branches;
next	1.88;

1.88
date	2005.07.26.01.32.25;	author brad;	state Exp;
branches;
next	1.87;

1.87
date	2005.07.18.22.51.03;	author brad;	state Exp;
branches;
next	1.86;

1.86
date	2005.07.17.19.13.24;	author brad;	state Exp;
branches;
next	1.85;

1.85
date	2005.07.17.07.33.22;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2005.07.12.03.08.12;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2005.07.12.03.01.12;	author brad;	state Exp;
branches;
next	1.82;

1.82
date	2005.07.12.01.28.10;	author brad;	state Exp;
branches;
next	1.81;

1.81
date	2005.07.11.22.34.56;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2005.02.17.03.00.12;	author mbalmer;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.23.03.48.43;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2003.04.04.20.28.57;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.76;

1.76
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.75;

1.75
date	2002.05.27.23.19.38;	author brian;	state Exp;
branches;
next	1.74;

1.74
date	2002.05.17.22.15.56;	author brian;	state Exp;
branches;
next	1.73;

1.73
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.72;

1.72
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.71;

1.71
date	2001.11.23.11.17.03;	author brian;	state Exp;
branches;
next	1.70;

1.70
date	2001.10.24.10.01.12;	author brian;	state Exp;
branches;
next	1.69;

1.69
date	2001.08.21.04.09.18;	author brian;	state Exp;
branches;
next	1.68;

1.68
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.67;

1.67
date	2001.08.18.19.41.09;	author brian;	state Exp;
branches;
next	1.66;

1.66
date	2001.08.18.19.34.33;	author brian;	state Exp;
branches;
next	1.65;

1.65
date	2001.07.26.11.36.51;	author brian;	state Exp;
branches;
next	1.64;

1.64
date	2001.07.09.07.05.03;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2001.07.09.00.08.54;	author brian;	state Exp;
branches;
next	1.62;

1.62
date	2001.07.07.03.08.49;	author brian;	state Exp;
branches;
next	1.61;

1.61
date	2001.07.03.22.23.52;	author brian;	state Exp;
branches;
next	1.60;

1.60
date	2001.06.19.10.24.51;	author brian;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.13.21.33.40;	author brian;	state Exp;
branches;
next	1.58;

1.58
date	2001.04.05.02.24.05;	author brian;	state Exp;
branches;
next	1.57;

1.57
date	2001.02.04.01.14.24;	author brian;	state Exp;
branches;
next	1.56;

1.56
date	2001.01.29.01.34.38;	author brian;	state Exp;
branches;
next	1.55;

1.55
date	2001.01.26.01.41.03;	author brian;	state Exp;
branches;
next	1.54;

1.54
date	2000.11.28.22.59.53;	author brian;	state Exp;
branches;
next	1.53;

1.53
date	2000.11.02.00.54.33;	author brian;	state Exp;
branches;
next	1.52;

1.52
date	2000.09.06.21.03.38;	author brian;	state Exp;
branches;
next	1.51;

1.51
date	2000.08.30.22.04.35;	author brian;	state Exp;
branches;
next	1.50;

1.50
date	2000.08.18.00.02.10;	author brian;	state Exp;
branches;
next	1.49;

1.49
date	2000.08.18.00.02.02;	author brian;	state Exp;
branches;
next	1.48;

1.48
date	2000.08.16.09.07.27;	author brian;	state Exp;
branches;
next	1.47;

1.47
date	2000.08.15.10.26.35;	author brian;	state Exp;
branches;
next	1.46;

1.46
date	2000.08.15.10.08.48;	author brian;	state Exp;
branches;
next	1.45;

1.45
date	2000.07.19.11.06.32;	author brian;	state Exp;
branches;
next	1.44;

1.44
date	2000.07.07.14.47.54;	author brian;	state Exp;
branches;
next	1.43;

1.43
date	2000.06.23.09.47.05;	author brian;	state Exp;
branches;
next	1.42;

1.42
date	2000.06.13.09.57.50;	author brian;	state Exp;
branches;
next	1.41;

1.41
date	2000.04.02.01.36.25;	author brian;	state Exp;
branches;
next	1.40;

1.40
date	2000.03.31.14.32.50;	author brian;	state Exp;
branches;
next	1.39;

1.39
date	2000.03.19.10.33.32;	author brian;	state Exp;
branches;
next	1.38;

1.38
date	2000.02.27.01.38.25;	author brian;	state Exp;
branches;
next	1.37;

1.37
date	2000.02.27.00.21.07;	author brian;	state Exp;
branches;
next	1.36;

1.36
date	2000.01.07.03.26.53;	author brian;	state Exp;
branches;
next	1.35;

1.35
date	99.08.22.01.33.15;	author brian;	state Exp;
branches;
next	1.34;

1.34
date	99.08.17.17.25.34;	author brian;	state Exp;
branches;
next	1.33;

1.33
date	99.08.17.15.00.38;	author brian;	state Exp;
branches;
next	1.32;

1.32
date	99.08.05.10.32.13;	author brian;	state Exp;
branches;
next	1.31;

1.31
date	99.08.02.21.45.45;	author brian;	state Exp;
branches;
next	1.30;

1.30
date	99.06.23.16.49.03;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	99.06.10.09.34.42;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	99.06.09.16.55.25;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	99.06.09.08.47.23;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	99.06.08.20.12.28;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	99.06.05.21.35.58;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	99.06.02.21.27.54;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	99.06.02.00.46.55;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	99.05.31.23.57.36;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	99.05.15.02.25.22;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	99.05.12.10.03.49;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	99.05.08.11.06.34;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	99.04.26.08.55.01;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	99.03.25.23.36.52;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	99.03.19.00.08.12;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	99.03.08.01.40.23;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	99.03.04.17.42.25;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	99.03.03.23.01.09;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.02.26.21.28.20;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.02.25.20.07.34;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.02.18.00.50.45;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.02.16.00.18.01;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.02.11.10.14.49;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.02.06.03.22.33;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	98.12.14.01.23.48;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	98.11.05.22.00.11;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	98.10.31.17.38.50;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.10.29.02.21.44;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.08.31.08.16.36;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.18;	author brian;	state Exp;
branches;
next	;

1.91.6.1
date	2008.03.07.12.50.24;	author henning;	state Exp;
branches;
next	;

1.91.8.1
date	2008.03.07.12.49.27;	author henning;	state Exp;
branches;
next	;


desc
@@


1.95
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: command.c,v 1.94 2013/11/24 00:54:30 deraadt Exp $
 */

#include <sys/param.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <net/route.h>
#include <netdb.h>
#include <sys/un.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <termios.h>
#include <unistd.h>

#ifndef NONAT
#ifdef LOCALNAT
#include "alias.h"
#else
#include <alias.h>
#endif
#endif

#include "layer.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "iplist.h"
#include "throughput.h"
#include "slcompress.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "ncpaddr.h"
#include "ipcp.h"
#ifndef NONAT
#include "nat_cmd.h"
#endif
#include "systems.h"
#include "filter.h"
#include "descriptor.h"
#include "main.h"
#include "route.h"
#include "ccp.h"
#include "auth.h"
#include "async.h"
#include "link.h"
#include "physical.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "server.h"
#include "prompt.h"
#include "chat.h"
#include "chap.h"
#include "cbcp.h"
#include "datalink.h"
#include "iface.h"
#include "id.h"
#include "probe.h"

/* ``set'' values */
#define	VAR_AUTHKEY	0
#define	VAR_DIAL	1
#define	VAR_LOGIN	2
#define	VAR_AUTHNAME	3
#define	VAR_AUTOLOAD	4
#define	VAR_WINSIZE	5
#define	VAR_DEVICE	6
#define	VAR_ACCMAP	7
#define	VAR_MRRU	8
#define	VAR_MRU		9
#define	VAR_MTU		10
#define	VAR_OPENMODE	11
#define	VAR_PHONE	12
#define	VAR_HANGUP	13
#define	VAR_IDLETIMEOUT	14
#define	VAR_LQRPERIOD	15
#define	VAR_LCPRETRY	16
#define	VAR_CHAPRETRY	17
#define	VAR_PAPRETRY	18
#define	VAR_CCPRETRY	19
#define	VAR_IPCPRETRY	20
#define	VAR_DNS		21
#define	VAR_NBNS	22
#define	VAR_MODE	23
#define	VAR_CALLBACK	24
#define	VAR_CBCP	25
#define	VAR_CHOKED	26
#define	VAR_SENDPIPE	27
#define	VAR_RECVPIPE	28
#define	VAR_RADIUS	29
#define	VAR_CD		30
#define	VAR_PARITY	31
#define VAR_CRTSCTS	32
#define VAR_URGENTPORTS	33
#define	VAR_LOGOUT	34
#define	VAR_IFQUEUE	35
#define	VAR_MPPE	36
#define	VAR_IPV6CPRETRY	37
#define	VAR_RAD_ALIVE	38

/* ``accept|deny|disable|enable'' masks */
#define NEG_HISMASK (1)
#define NEG_MYMASK (2)

/* ``accept|deny|disable|enable'' values */
#define NEG_ACFCOMP	40
#define NEG_CHAP05	41
#define NEG_CHAP80	42
#define NEG_CHAP80LM	43
#define NEG_DEFLATE	44
#define NEG_DNS		45
#define NEG_ECHO	46
#define NEG_ENDDISC	47
#define NEG_LQR		48
#define NEG_PAP		49
#define NEG_PPPDDEFLATE	50
#define NEG_PRED1	51
#define NEG_PROTOCOMP	52
#define NEG_SHORTSEQ	53
#define NEG_VJCOMP	54
#define NEG_MPPE	55
#define NEG_CHAP81	56

const char Version[] = "3.4.2";

static int ShowCommand(struct cmdargs const *);
static int TerminalCommand(struct cmdargs const *);
static int QuitCommand(struct cmdargs const *);
static int OpenCommand(struct cmdargs const *);
static int CloseCommand(struct cmdargs const *);
static int DownCommand(struct cmdargs const *);
static int SetCommand(struct cmdargs const *);
static int LinkCommand(struct cmdargs const *);
static int AddCommand(struct cmdargs const *);
static int DeleteCommand(struct cmdargs const *);
static int NegotiateCommand(struct cmdargs const *);
static int ClearCommand(struct cmdargs const *);
static int RunListCommand(struct cmdargs const *);
static int IfaceAddCommand(struct cmdargs const *);
static int IfaceDeleteCommand(struct cmdargs const *);
static int IfaceClearCommand(struct cmdargs const *);
static int SetProcTitle(struct cmdargs const *);
#ifndef NONAT
static int NatEnable(struct cmdargs const *);
static int NatOption(struct cmdargs const *);
#endif

static const char *
showcx(struct cmdtab const *cmd)
{
  if (cmd->lauth & LOCAL_CX)
    return "(c)";
  else if (cmd->lauth & LOCAL_CX_OPT)
    return "(o)";

  return "";
}

static int
HelpCommand(struct cmdargs const *arg)
{
  struct cmdtab const *cmd;
  int n, cmax, dmax, cols, cxlen;
  const char *cx;

  if (!arg->prompt) {
    log_Printf(LogWARN, "help: Cannot help without a prompt\n");
    return 0;
  }

  if (arg->argc > arg->argn) {
    for (cmd = arg->cmdtab; cmd->name || cmd->alias; cmd++)
      if ((cmd->lauth & arg->prompt->auth) &&
          ((cmd->name && !strcasecmp(cmd->name, arg->argv[arg->argn])) ||
           (cmd->alias && !strcasecmp(cmd->alias, arg->argv[arg->argn])))) {
	prompt_Printf(arg->prompt, "%s %s\n", cmd->syntax, showcx(cmd));
	return 0;
      }
    return -1;
  }

  cmax = dmax = 0;
  for (cmd = arg->cmdtab; cmd->func; cmd++)
    if (cmd->name && (cmd->lauth & arg->prompt->auth)) {
      if ((n = strlen(cmd->name) + strlen(showcx(cmd))) > cmax)
        cmax = n;
      if ((n = strlen(cmd->helpmes)) > dmax)
        dmax = n;
    }

  cols = 80 / (dmax + cmax + 3);
  n = 0;
  prompt_Printf(arg->prompt, "(o) = Optional context,"
                " (c) = Context required\n");
  for (cmd = arg->cmdtab; cmd->func; cmd++)
    if (cmd->name && (cmd->lauth & arg->prompt->auth)) {
      cx = showcx(cmd);
      cxlen = cmax - strlen(cmd->name);
      if (n % cols != 0)
        prompt_Printf(arg->prompt, " ");
      prompt_Printf(arg->prompt, "%s%-*.*s: %-*.*s",
              cmd->name, cxlen, cxlen, cx, dmax, dmax, cmd->helpmes);
      if (++n % cols == 0)
        prompt_Printf(arg->prompt, "\n");
    }
  if (n % cols != 0)
    prompt_Printf(arg->prompt, "\n");

  return 0;
}

static int
IdentCommand(struct cmdargs const *arg)
{
  Concatinate(arg->cx->physical->link.lcp.cfg.ident,
              sizeof arg->cx->physical->link.lcp.cfg.ident,
              arg->argc - arg->argn, arg->argv + arg->argn);
  return 0;
}

static int
SendIdentification(struct cmdargs const *arg)
{
  if (arg->cx->state < DATALINK_LCP) {
    log_Printf(LogWARN, "sendident: link has not reached LCP\n");
    return 2;
  }
  return lcp_SendIdentification(&arg->cx->physical->link.lcp) ? 0 : 1;
}

static int
CloneCommand(struct cmdargs const *arg)
{
  char namelist[LINE_LEN];
  char *name;
  int f;

  if (arg->argc == arg->argn)
    return -1;

  namelist[sizeof namelist - 1] = '\0';
  for (f = arg->argn; f < arg->argc; f++) {
    strncpy(namelist, arg->argv[f], sizeof namelist - 1);
    for(name = strtok(namelist, ", "); name; name = strtok(NULL,", "))
      bundle_DatalinkClone(arg->bundle, arg->cx, name);
  }

  return 0;
}

static int
RemoveCommand(struct cmdargs const *arg)
{
  if (arg->argc != arg->argn)
    return -1;

  if (arg->cx->state != DATALINK_CLOSED) {
    log_Printf(LogWARN, "remove: Cannot delete links that aren't closed\n");
    return 2;
  }

  bundle_DatalinkRemove(arg->bundle, arg->cx);
  return 0;
}

static int
RenameCommand(struct cmdargs const *arg)
{
  if (arg->argc != arg->argn + 1)
    return -1;

  if (bundle_RenameDatalink(arg->bundle, arg->cx, arg->argv[arg->argn]))
    return 0;

  log_Printf(LogWARN, "%s -> %s: target name already exists\n",
             arg->cx->name, arg->argv[arg->argn]);
  return 1;
}

static int
LoadCommand(struct cmdargs const *arg)
{
  const char *err;
  int n, mode;

  mode = arg->bundle->phys_type.all;

  if (arg->argn < arg->argc) {
    for (n = arg->argn; n < arg->argc; n++)
      if ((err = system_IsValid(arg->argv[n], arg->prompt, mode)) != NULL) {
        log_Printf(LogWARN, "%s: %s\n", arg->argv[n], err);
        return 1;
      }

    for (n = arg->argn; n < arg->argc; n++) {
      bundle_SetLabel(arg->bundle, arg->argv[arg->argc - 1]);
      system_Select(arg->bundle, arg->argv[n], CONFFILE, arg->prompt, arg->cx);
    }
    bundle_SetLabel(arg->bundle, arg->argv[arg->argc - 1]);
  } else if ((err = system_IsValid("default", arg->prompt, mode)) != NULL) {
    log_Printf(LogWARN, "default: %s\n", err);
    return 1;
  } else {
    bundle_SetLabel(arg->bundle, "default");
    system_Select(arg->bundle, "default", CONFFILE, arg->prompt, arg->cx);
    bundle_SetLabel(arg->bundle, "default");
  }

  return 0;
}

static int
LogCommand(struct cmdargs const *arg)
{
  char buf[LINE_LEN];

  if (arg->argn < arg->argc) {
    char *argv[MAXARGS];
    int argc = arg->argc - arg->argn;

    if (argc >= sizeof argv / sizeof argv[0]) {
      argc = sizeof argv / sizeof argv[0] - 1;
      log_Printf(LogWARN, "Truncating log command to %d args\n", argc);
    }
    command_Expand(argv, argc, arg->argv + arg->argn, arg->bundle, 1, getpid());
    Concatinate(buf, sizeof buf, argc, (const char *const *)argv);
    log_Printf(LogLOG, "%s\n", buf);
    command_Free(argc, argv);
    return 0;
  }

  return -1;
}

static int
SaveCommand(struct cmdargs const *arg)
{
  log_Printf(LogWARN, "save command is not yet implemented.\n");
  return 1;
}

static int
DialCommand(struct cmdargs const *arg)
{
  int res;

  if ((arg->cx && !(arg->cx->physical->type & (PHYS_INTERACTIVE|PHYS_AUTO)))
      || (!arg->cx &&
          (arg->bundle->phys_type.all & ~(PHYS_INTERACTIVE|PHYS_AUTO)))) {
    log_Printf(LogWARN, "Manual dial is only available for auto and"
              " interactive links\n");
    return 1;
  }

  if (arg->argc > arg->argn && (res = LoadCommand(arg)) != 0)
    return res;

  bundle_Open(arg->bundle, arg->cx ? arg->cx->name : NULL, PHYS_ALL, 1);

  return 0;
}

#define isinword(ch) (isalnum(ch) || (ch) == '_')

static char *
strstrword(char *big, const char *little)
{
  /* Get the first occurance of the word ``little'' in ``big'' */
  char *pos;
  int len;

  pos = big;
  len = strlen(little);

  while ((pos = strstr(pos, little)) != NULL)
    if ((pos != big && isinword(pos[-1])) || isinword(pos[len]))
      pos++;
    else if (pos != big && pos[-1] == '\\')
      memmove(pos - 1, pos, strlen(pos) + 1);
    else
      break;

  return pos;
}

static char *
subst(char *tgt, const char *oldstr, const char *newstr)
{
  /* tgt is a malloc()d area... realloc() as necessary */
  char *word, *ntgt;
  int ltgt, loldstr, lnewstr, pos;

  if ((word = strstrword(tgt, oldstr)) == NULL)
    return tgt;

  ltgt = strlen(tgt) + 1;
  loldstr = strlen(oldstr);
  lnewstr = strlen(newstr);
  do {
    pos = word - tgt;
    if (loldstr > lnewstr)
      bcopy(word + loldstr, word + lnewstr, ltgt - pos - loldstr);
    if (loldstr != lnewstr) {
      ntgt = realloc(tgt, ltgt += lnewstr - loldstr);
      if (ntgt == NULL)
        break;			/* Oh wonderful ! */
      word = ntgt + pos;
      tgt = ntgt;
    }
    if (lnewstr > loldstr)
      bcopy(word + loldstr, word + lnewstr, ltgt - pos - lnewstr);
    bcopy(newstr, word, lnewstr);
  } while ((word = strstrword(word, oldstr)));

  return tgt;
}

static char *
substip(char *tgt, const char *oldstr, struct in_addr ip)
{
  return subst(tgt, oldstr, inet_ntoa(ip));
}

static char *
substlong(char *tgt, const char *oldstr, long l)
{
  char buf[23];

  snprintf(buf, sizeof buf, "%ld", l);

  return subst(tgt, oldstr, buf);
}

static char *
substull(char *tgt, const char *oldstr, unsigned long long ull)
{
  char buf[21];

  snprintf(buf, sizeof buf, "%llu", ull);

  return subst(tgt, oldstr, buf);
}


#ifndef NOINET6
static char *
substipv6(char *tgt, const char *oldstr, const struct ncpaddr *ip)
{
    return subst(tgt, oldstr, ncpaddr_ntoa(ip));
}

#ifndef NORADIUS
static char *
substipv6prefix(char *tgt, const char *oldstr, const uint8_t *ipv6prefix)
{
  uint8_t ipv6addr[INET6_ADDRSTRLEN];
  uint8_t prefix[INET6_ADDRSTRLEN + sizeof("/128") - 1];

  if (ipv6prefix) {
    inet_ntop(AF_INET6, &ipv6prefix[2], ipv6addr, sizeof(ipv6addr));
    snprintf(prefix, sizeof(prefix), "%s/%d", ipv6addr, ipv6prefix[1]);
  } else
    prefix[0] = '\0';
  return subst(tgt, oldstr, prefix);
}
#endif
#endif

void
command_Expand(char **nargv, int argc, char const *const *oargv,
               struct bundle *bundle, int inc0, pid_t pid)
{
  int arg, secs;
  char uptime[20];
  unsigned long long oin, oout, pin, pout;

  if (inc0)
    arg = 0;		/* Start at arg 0 */
  else {
    nargv[0] = strdup(oargv[0]);
    arg = 1;
  }

  secs = bundle_Uptime(bundle);
  snprintf(uptime, sizeof uptime, "%d:%02d:%02d",
           secs / 3600, (secs / 60) % 60, secs % 60);
  oin = bundle->ncp.ipcp.throughput.OctetsIn;
  oout = bundle->ncp.ipcp.throughput.OctetsOut;
  pin = bundle->ncp.ipcp.throughput.PacketsIn;
  pout = bundle->ncp.ipcp.throughput.PacketsOut;
#ifndef NOINET6
  oin += bundle->ncp.ipv6cp.throughput.OctetsIn;
  oout += bundle->ncp.ipv6cp.throughput.OctetsOut;
  pin += bundle->ncp.ipv6cp.throughput.PacketsIn;
  pout += bundle->ncp.ipv6cp.throughput.PacketsOut;
#endif

  for (; arg < argc; arg++) {
    nargv[arg] = strdup(oargv[arg]);
    nargv[arg] = subst(nargv[arg], "AUTHNAME", bundle->cfg.auth.name);
    nargv[arg] = substip(nargv[arg], "DNS0", bundle->ncp.ipcp.ns.dns[0]);
    nargv[arg] = substip(nargv[arg], "DNS1", bundle->ncp.ipcp.ns.dns[1]);
    nargv[arg] = subst(nargv[arg], "ENDDISC",
                       mp_Enddisc(bundle->ncp.mp.cfg.enddisc.class,
                                  bundle->ncp.mp.cfg.enddisc.address,
                                  bundle->ncp.mp.cfg.enddisc.len));
    nargv[arg] = substip(nargv[arg], "HISADDR", bundle->ncp.ipcp.peer_ip);
#ifndef NOINET6
    nargv[arg] = substipv6(nargv[arg], "HISADDR6", &bundle->ncp.ipv6cp.hisaddr);
#endif
    nargv[arg] = subst(nargv[arg], "INTERFACE", bundle->iface->name);
    nargv[arg] = substull(nargv[arg], "IPOCTETSIN",
                          bundle->ncp.ipcp.throughput.OctetsIn);
    nargv[arg] = substull(nargv[arg], "IPOCTETSOUT",
                          bundle->ncp.ipcp.throughput.OctetsOut);
    nargv[arg] = substull(nargv[arg], "IPPACKETSIN",
                          bundle->ncp.ipcp.throughput.PacketsIn);
    nargv[arg] = substull(nargv[arg], "IPPACKETSOUT",
                          bundle->ncp.ipcp.throughput.PacketsOut);
#ifndef NOINET6
    nargv[arg] = substull(nargv[arg], "IPV6OCTETSIN",
                          bundle->ncp.ipv6cp.throughput.OctetsIn);
    nargv[arg] = substull(nargv[arg], "IPV6OCTETSOUT",
                          bundle->ncp.ipv6cp.throughput.OctetsOut);
    nargv[arg] = substull(nargv[arg], "IPV6PACKETSIN",
                          bundle->ncp.ipv6cp.throughput.PacketsIn);
    nargv[arg] = substull(nargv[arg], "IPV6PACKETSOUT",
                          bundle->ncp.ipv6cp.throughput.PacketsOut);
#endif
    nargv[arg] = subst(nargv[arg], "LABEL", bundle_GetLabel(bundle));
    nargv[arg] = substip(nargv[arg], "MYADDR", bundle->ncp.ipcp.my_ip);
#ifndef NOINET6
    nargv[arg] = substipv6(nargv[arg], "MYADDR6", &bundle->ncp.ipv6cp.myaddr);
#ifndef NORADIUS
    nargv[arg] = substipv6prefix(nargv[arg], "IPV6PREFIX",
				 bundle->radius.ipv6prefix);
#endif
#endif
    nargv[arg] = substull(nargv[arg], "OCTETSIN", oin);
    nargv[arg] = substull(nargv[arg], "OCTETSOUT", oout);
    nargv[arg] = substull(nargv[arg], "PACKETSIN", pin);
    nargv[arg] = substull(nargv[arg], "PACKETSOUT", pout);
    nargv[arg] = subst(nargv[arg], "PEER_ENDDISC",
                       mp_Enddisc(bundle->ncp.mp.peer.enddisc.class,
                                  bundle->ncp.mp.peer.enddisc.address,
                                  bundle->ncp.mp.peer.enddisc.len));
    nargv[arg] = substlong(nargv[arg], "PROCESSID", pid);
    if (server.cfg.port)
      nargv[arg] = substlong(nargv[arg], "SOCKNAME", server.cfg.port);
    else
      nargv[arg] = subst(nargv[arg], "SOCKNAME", server.cfg.sockname);
    nargv[arg] = subst(nargv[arg], "UPTIME", uptime);
    nargv[arg] = subst(nargv[arg], "USER", bundle->ncp.mp.peer.authname);
    nargv[arg] = subst(nargv[arg], "VERSION", Version);
  }
  nargv[arg] = NULL;
}

void
command_Free(int argc, char **argv)
{
  while (argc) {
    free(*argv);
    argc--;
    argv++;
  }
}

static int
ShellCommand(struct cmdargs const *arg, int bg)
{
  const char *shell;
  pid_t shpid, pid;

#ifdef SHELL_ONLY_INTERACTIVELY
  /* we're only allowed to shell when we run ppp interactively */
  if (arg->prompt && arg->prompt->owner) {
    log_Printf(LogWARN, "Can't start a shell from a network connection\n");
    return 1;
  }
#endif

  if (arg->argc == arg->argn) {
    if (!arg->prompt) {
      log_Printf(LogWARN, "Can't start an interactive shell from"
                " a config file\n");
      return 1;
    } else if (arg->prompt->owner) {
      log_Printf(LogWARN, "Can't start an interactive shell from"
                " a socket connection\n");
      return 1;
    } else if (bg) {
      log_Printf(LogWARN, "Can only start an interactive shell in"
		" the foreground mode\n");
      return 1;
    }
  }

  pid = getpid();
  if ((shpid = fork()) == 0) {
    int i, fd;

    if ((shell = getenv("SHELL")) == 0)
      shell = _PATH_BSHELL;

    timer_TermService();

    if (arg->prompt)
      fd = arg->prompt->fd_out;
    else if ((fd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
      log_Printf(LogALERT, "Failed to open %s: %s\n",
                _PATH_DEVNULL, strerror(errno));
      exit(1);
    }
    dup2(fd, STDIN_FILENO);
    dup2(fd, STDOUT_FILENO);
    dup2(fd, STDERR_FILENO);
/* fwalk */
    for (i = getdtablesize(); i > STDERR_FILENO; i--)
      fcntl(i, F_SETFD, FD_CLOEXEC);

#ifndef NOSUID
    setuid(ID0realuid());
#endif
    if (arg->argc > arg->argn) {
      /* substitute pseudo args */
      char *argv[MAXARGS];
      int argc = arg->argc - arg->argn;

      if (argc >= sizeof argv / sizeof argv[0]) {
        argc = sizeof argv / sizeof argv[0] - 1;
        log_Printf(LogWARN, "Truncating shell command to %d args\n", argc);
      }
      command_Expand(argv, argc, arg->argv + arg->argn, arg->bundle, 0, pid);
      if (bg) {
	pid_t p;

	p = getpid();
	if (daemon(1, 1) == -1) {
	  log_Printf(LogERROR, "%ld: daemon: %s\n", (long)p, strerror(errno));
	  exit(1);
	}
      } else if (arg->prompt)
        printf("ppp: Pausing until %s finishes\n", arg->argv[arg->argn]);
      execvp(argv[0], argv);
    } else {
      if (arg->prompt)
        printf("ppp: Pausing until %s finishes\n", shell);
      prompt_TtyOldMode(arg->prompt);
      execl(shell, shell, (char *)NULL);
    }

    log_Printf(LogWARN, "exec() of %s failed: %s\n",
              arg->argc > arg->argn ? arg->argv[arg->argn] : shell,
              strerror(errno));
    _exit(255);
  }

  if (shpid == (pid_t)-1)
    log_Printf(LogERROR, "Fork failed: %s\n", strerror(errno));
  else {
    int status;
    waitpid(shpid, &status, 0);
  }

  if (arg->prompt && !arg->prompt->owner)
    prompt_TtyCommandMode(arg->prompt);

  return 0;
}

static int
BgShellCommand(struct cmdargs const *arg)
{
  if (arg->argc == arg->argn)
    return -1;
  return ShellCommand(arg, 1);
}

static int
FgShellCommand(struct cmdargs const *arg)
{
  return ShellCommand(arg, 0);
}

static int
ResolvCommand(struct cmdargs const *arg)
{
  if (arg->argc == arg->argn + 1) {
    if (!strcasecmp(arg->argv[arg->argn], "reload"))
      ipcp_LoadDNS(&arg->bundle->ncp.ipcp);
    else if (!strcasecmp(arg->argv[arg->argn], "restore"))
      ipcp_RestoreDNS(&arg->bundle->ncp.ipcp);
    else if (!strcasecmp(arg->argv[arg->argn], "rewrite"))
      ipcp_WriteDNS(&arg->bundle->ncp.ipcp);
    else if (!strcasecmp(arg->argv[arg->argn], "readonly"))
      arg->bundle->ncp.ipcp.ns.writable = 0;
    else if (!strcasecmp(arg->argv[arg->argn], "writable"))
      arg->bundle->ncp.ipcp.ns.writable = 1;
    else
      return -1;

    return 0;
  }

  return -1;
}

#ifndef NONAT
static struct cmdtab const NatCommands[] =
{
  {"addr", NULL, nat_RedirectAddr, LOCAL_AUTH,
   "static address translation", "nat addr [addr_local addr_alias]"},
  {"deny_incoming", NULL, NatOption, LOCAL_AUTH,
   "stop incoming connections", "nat deny_incoming yes|no",
   (const void *) PKT_ALIAS_DENY_INCOMING},
  {"enable", NULL, NatEnable, LOCAL_AUTH,
   "enable NAT", "nat enable yes|no"},
  {"log", NULL, NatOption, LOCAL_AUTH,
   "log NAT link creation", "nat log yes|no",
   (const void *) PKT_ALIAS_LOG},
  {"port", NULL, nat_RedirectPort, LOCAL_AUTH, "port redirection",
   "nat port proto localaddr:port[-port] aliasport[-aliasport]"},
  {"proto", NULL, nat_RedirectProto, LOCAL_AUTH, "protocol redirection",
   "nat proto proto localIP [publicIP [remoteIP]]"},
  {"proxy", NULL, nat_ProxyRule, LOCAL_AUTH,
   "proxy control", "nat proxy server host[:port] ..."},
#ifndef NO_FW_PUNCH
  {"punch_fw", NULL, nat_PunchFW, LOCAL_AUTH,
   "firewall control", "nat punch_fw [base count]"},
#endif
  {"skinny_port", NULL, nat_SkinnyPort, LOCAL_AUTH,
   "TCP port used by Skinny Station protocol", "nat skinny_port [port]"},
  {"same_ports", NULL, NatOption, LOCAL_AUTH,
   "try to leave port numbers unchanged", "nat same_ports yes|no",
   (const void *) PKT_ALIAS_SAME_PORTS},
  {"target", NULL, nat_SetTarget, LOCAL_AUTH,
   "Default address for incoming connections", "nat target addr" },
  {"unregistered_only", NULL, NatOption, LOCAL_AUTH,
   "translate unregistered (private) IP address space only",
   "nat unregistered_only yes|no",
   (const void *) PKT_ALIAS_UNREGISTERED_ONLY},
  {"use_sockets", NULL, NatOption, LOCAL_AUTH,
   "allocate host sockets", "nat use_sockets yes|no",
   (const void *) PKT_ALIAS_USE_SOCKETS},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
   "Display this message", "nat help|? [command]", NatCommands},
  {NULL, NULL, NULL},
};
#endif

static struct cmdtab const AllowCommands[] = {
  {"modes", "mode", AllowModes, LOCAL_AUTH,
  "Only allow certain ppp modes", "allow modes mode..."},
  {"users", "user", AllowUsers, LOCAL_AUTH,
  "Only allow ppp access to certain users", "allow users logname..."},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
  "Display this message", "allow help|? [command]", AllowCommands},
  {NULL, NULL, NULL},
};

static struct cmdtab const IfaceCommands[] =
{
  {"add", NULL, IfaceAddCommand, LOCAL_AUTH,
   "Add iface address", "iface add addr[/bits| mask] peer", NULL},
  {NULL, "add!", IfaceAddCommand, LOCAL_AUTH,
   "Add or change an iface address", "iface add! addr[/bits| mask] peer",
   (void *)1},
  {"clear", NULL, IfaceClearCommand, LOCAL_AUTH,
   "Clear iface address(es)", "iface clear [INET | INET6]"},
  {"delete", "rm", IfaceDeleteCommand, LOCAL_AUTH,
   "Delete iface address", "iface delete addr", NULL},
  {NULL, "rm!", IfaceDeleteCommand, LOCAL_AUTH,
   "Delete iface address", "iface delete addr", (void *)1},
  {NULL, "delete!", IfaceDeleteCommand, LOCAL_AUTH,
   "Delete iface address", "iface delete addr", (void *)1},
  {"show", NULL, iface_Show, LOCAL_AUTH,
   "Show iface address(es)", "iface show"},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
   "Display this message", "nat help|? [command]", IfaceCommands},
  {NULL, NULL, NULL},
};

static struct cmdtab const Commands[] = {
  {"accept", NULL, NegotiateCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "accept option request", "accept option .."},
  {"add", NULL, AddCommand, LOCAL_AUTH,
  "add route", "add dest mask gateway", NULL},
  {NULL, "add!", AddCommand, LOCAL_AUTH,
  "add or change route", "add! dest mask gateway", (void *)1},
  {"allow", "auth", RunListCommand, LOCAL_AUTH,
  "Allow ppp access", "allow users|modes ....", AllowCommands},
  {"bg", "!bg", BgShellCommand, LOCAL_AUTH,
  "Run a background command", "[!]bg command"},
  {"clear", NULL, ClearCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Clear throughput statistics",
  "clear ipcp|ipv6cp|physical [current|overall|peak]..."},
  {"clone", NULL, CloneCommand, LOCAL_AUTH | LOCAL_CX,
  "Clone a link", "clone newname..."},
  {"close", NULL, CloseCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Close an FSM", "close [lcp|ccp]"},
  {"delete", NULL, DeleteCommand, LOCAL_AUTH,
  "delete route", "delete dest", NULL},
  {NULL, "delete!", DeleteCommand, LOCAL_AUTH,
  "delete a route if it exists", "delete! dest", (void *)1},
  {"deny", NULL, NegotiateCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Deny option request", "deny option .."},
  {"dial", "call", DialCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Dial and login", "dial|call [system ...]", NULL},
  {"disable", NULL, NegotiateCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Disable option", "disable option .."},
  {"down", NULL, DownCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Generate a down event", "down [ccp|lcp]"},
  {"enable", NULL, NegotiateCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Enable option", "enable option .."},
  {"ident", NULL, IdentCommand, LOCAL_AUTH | LOCAL_CX,
  "Set the link identity", "ident text..."},
  {"iface", "interface", RunListCommand, LOCAL_AUTH,
  "interface control", "iface option ...", IfaceCommands},
  {"link", "datalink", LinkCommand, LOCAL_AUTH,
  "Link specific commands", "link name command ..."},
  {"load", NULL, LoadCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Load settings", "load [system ...]"},
  {"log", NULL, LogCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "log information", "log word ..."},
#ifndef NONAT
  {"nat", "alias", RunListCommand, LOCAL_AUTH,
  "NAT control", "nat option yes|no", NatCommands},
#endif
  {"open", NULL, OpenCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Open an FSM", "open! [lcp|ccp|ipcp]", (void *)1},
  {"passwd", NULL, PasswdCommand, LOCAL_NO_AUTH,
  "Password for manipulation", "passwd LocalPassword"},
  {"quit", "bye", QuitCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
  "Quit PPP program", "quit|bye [all]"},
  {"remove", "rm", RemoveCommand, LOCAL_AUTH | LOCAL_CX,
  "Remove a link", "remove"},
  {"rename", "mv", RenameCommand, LOCAL_AUTH | LOCAL_CX,
  "Rename a link", "rename name"},
  {"resolv", NULL, ResolvCommand, LOCAL_AUTH,
  "Manipulate resolv.conf", "resolv readonly|reload|restore|rewrite|writable"},
  {"save", NULL, SaveCommand, LOCAL_AUTH,
  "Save settings", "save"},
  {"sendident", NULL, SendIdentification, LOCAL_AUTH | LOCAL_CX,
  "Transmit the link identity", "sendident"},
  {"set", "setup", SetCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Set parameters", "set[up] var value"},
  {"shell", "!", FgShellCommand, LOCAL_AUTH,
  "Run a subshell", "shell|! [sh command]"},
  {"show", NULL, ShowCommand, LOCAL_AUTH | LOCAL_CX_OPT,
  "Show status and stats", "show var"},
  {"term", NULL, TerminalCommand, LOCAL_AUTH | LOCAL_CX,
  "Enter terminal mode", "term"},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
  "Display this message", "help|? [command]", Commands},
  {NULL, NULL, NULL},
};

static int
ShowEscape(struct cmdargs const *arg)
{
  if (arg->cx->physical->async.cfg.EscMap[32]) {
    int code, bit;
    const char *sep = "";

    for (code = 0; code < 32; code++)
      if (arg->cx->physical->async.cfg.EscMap[code])
	for (bit = 0; bit < 8; bit++)
	  if (arg->cx->physical->async.cfg.EscMap[code] & (1 << bit)) {
	    prompt_Printf(arg->prompt, "%s0x%02x", sep, (code << 3) + bit);
            sep = ", ";
          }
    prompt_Printf(arg->prompt, "\n");
  }
  return 0;
}

static int
ShowTimerList(struct cmdargs const *arg)
{
  timer_Show(0, arg->prompt);
  return 0;
}

static int
ShowStopped(struct cmdargs const *arg)
{
  prompt_Printf(arg->prompt, " Stopped Timer:  LCP: ");
  if (!arg->cx->physical->link.lcp.fsm.StoppedTimer.load)
    prompt_Printf(arg->prompt, "Disabled");
  else
    prompt_Printf(arg->prompt, "%ld secs",
                  arg->cx->physical->link.lcp.fsm.StoppedTimer.load / SECTICKS);

  prompt_Printf(arg->prompt, ", CCP: ");
  if (!arg->cx->physical->link.ccp.fsm.StoppedTimer.load)
    prompt_Printf(arg->prompt, "Disabled");
  else
    prompt_Printf(arg->prompt, "%ld secs",
                  arg->cx->physical->link.ccp.fsm.StoppedTimer.load / SECTICKS);

  prompt_Printf(arg->prompt, "\n");

  return 0;
}

static int
ShowVersion(struct cmdargs const *arg)
{
  prompt_Printf(arg->prompt, "PPP Version %s\n", Version);
  return 0;
}

static int
ShowProtocolStats(struct cmdargs const *arg)
{
  struct link *l = command_ChooseLink(arg);

  prompt_Printf(arg->prompt, "%s:\n", l->name);
  link_ReportProtocolStatus(l, arg->prompt);
  return 0;
}

static struct cmdtab const ShowCommands[] = {
  {"bundle", NULL, bundle_ShowStatus, LOCAL_AUTH,
  "bundle details", "show bundle"},
  {"ccp", NULL, ccp_ReportStatus, LOCAL_AUTH | LOCAL_CX_OPT,
  "CCP status", "show cpp"},
  {"compress", NULL, sl_Show, LOCAL_AUTH,
  "VJ compression stats", "show compress"},
  {"escape", NULL, ShowEscape, LOCAL_AUTH | LOCAL_CX,
  "escape characters", "show escape"},
  {"filter", NULL, filter_Show, LOCAL_AUTH,
  "packet filters", "show filter [in|out|dial|alive]"},
  {"hdlc", NULL, hdlc_ReportStatus, LOCAL_AUTH | LOCAL_CX,
  "HDLC errors", "show hdlc"},
  {"iface", "interface", iface_Show, LOCAL_AUTH,
  "Interface status", "show iface"},
  {"ipcp", NULL, ipcp_Show, LOCAL_AUTH,
  "IPCP status", "show ipcp"},
#ifndef NOINET6
  {"ipv6cp", NULL, ipv6cp_Show, LOCAL_AUTH,
  "IPV6CP status", "show ipv6cp"},
#endif
  {"layers", NULL, link_ShowLayers, LOCAL_AUTH | LOCAL_CX_OPT,
  "Protocol layers", "show layers"},
  {"lcp", NULL, lcp_ReportStatus, LOCAL_AUTH | LOCAL_CX,
  "LCP status", "show lcp"},
  {"link", "datalink", datalink_Show, LOCAL_AUTH | LOCAL_CX,
  "(high-level) link info", "show link"},
  {"links", NULL, bundle_ShowLinks, LOCAL_AUTH,
  "available link names", "show links"},
  {"log", NULL, log_ShowLevel, LOCAL_AUTH,
  "log levels", "show log"},
  {"mem", NULL, mbuf_Show, LOCAL_AUTH,
  "mbuf allocations", "show mem"},
  {"ncp", NULL, ncp_Show, LOCAL_AUTH,
  "NCP status", "show ncp"},
  {"physical", NULL, physical_ShowStatus, LOCAL_AUTH | LOCAL_CX,
  "(low-level) link info", "show physical"},
  {"mp", "multilink", mp_ShowStatus, LOCAL_AUTH,
  "multilink setup", "show mp"},
  {"proto", NULL, ShowProtocolStats, LOCAL_AUTH | LOCAL_CX_OPT,
  "protocol summary", "show proto"},
  {"route", NULL, route_Show, LOCAL_AUTH,
  "routing table", "show route"},
  {"stopped", NULL, ShowStopped, LOCAL_AUTH | LOCAL_CX,
  "STOPPED timeout", "show stopped"},
  {"timers", NULL, ShowTimerList, LOCAL_AUTH,
  "alarm timers", "show timers"},
  {"version", NULL, ShowVersion, LOCAL_NO_AUTH | LOCAL_AUTH,
  "version string", "show version"},
  {"who", NULL, log_ShowWho, LOCAL_AUTH,
  "client list", "show who"},
  {"help", "?", HelpCommand, LOCAL_NO_AUTH | LOCAL_AUTH,
  "Display this message", "show help|? [command]", ShowCommands},
  {NULL, NULL, NULL},
};

static struct cmdtab const *
FindCommand(struct cmdtab const *cmds, const char *str, int *pmatch)
{
  int nmatch;
  int len;
  struct cmdtab const *found;

  found = NULL;
  len = strlen(str);
  nmatch = 0;
  while (cmds->func) {
    if (cmds->name && strncasecmp(str, cmds->name, len) == 0) {
      if (cmds->name[len] == '\0') {
	*pmatch = 1;
	return cmds;
      }
      nmatch++;
      found = cmds;
    } else if (cmds->alias && strncasecmp(str, cmds->alias, len) == 0) {
      if (cmds->alias[len] == '\0') {
	*pmatch = 1;
	return cmds;
      }
      nmatch++;
      found = cmds;
    }
    cmds++;
  }
  *pmatch = nmatch;
  return found;
}

static const char *
mkPrefix(int argc, char const *const *argv, char *tgt, int sz)
{
  int f, tlen, len;

  tlen = 0;
  for (f = 0; f < argc && tlen < sz - 2; f++) {
    if (f)
      tgt[tlen++] = ' ';
    len = strlen(argv[f]);
    if (len > sz - tlen - 1)
      len = sz - tlen - 1;
    strncpy(tgt+tlen, argv[f], len);
    tlen += len;
  }
  tgt[tlen] = '\0';
  return tgt;
}

static int
FindExec(struct bundle *bundle, struct cmdtab const *cmds, int argc, int argn,
         char const *const *argv, struct prompt *prompt, struct datalink *cx)
{
  struct cmdtab const *cmd;
  int val = 1;
  int nmatch;
  struct cmdargs arg;
  char prefix[100];

  cmd = FindCommand(cmds, argv[argn], &nmatch);
  if (nmatch > 1)
    log_Printf(LogWARN, "%s: Ambiguous command\n",
              mkPrefix(argn+1, argv, prefix, sizeof prefix));
  else if (cmd && (!prompt || (cmd->lauth & prompt->auth))) {
    if ((cmd->lauth & LOCAL_CX) && !cx)
      /* We've got no context, but we require it */
      cx = bundle2datalink(bundle, NULL);

    if ((cmd->lauth & LOCAL_CX) && !cx)
      log_Printf(LogWARN, "%s: No context (use the `link' command)\n",
                mkPrefix(argn+1, argv, prefix, sizeof prefix));
    else {
      if (cx && !(cmd->lauth & (LOCAL_CX|LOCAL_CX_OPT))) {
        log_Printf(LogWARN, "%s: Redundant context (%s) ignored\n",
                  mkPrefix(argn+1, argv, prefix, sizeof prefix), cx->name);
        cx = NULL;
      }
      arg.cmdtab = cmds;
      arg.cmd = cmd;
      arg.argc = argc;
      arg.argn = argn+1;
      arg.argv = argv;
      arg.bundle = bundle;
      arg.cx = cx;
      arg.prompt = prompt;
      val = (*cmd->func) (&arg);
    }
  } else
    log_Printf(LogWARN, "%s: Invalid command\n",
              mkPrefix(argn+1, argv, prefix, sizeof prefix));

  if (val == -1)
    log_Printf(LogWARN, "usage: %s\n", cmd->syntax);
  else if (val)
    log_Printf(LogWARN, "%s: Failed %d\n",
              mkPrefix(argn+1, argv, prefix, sizeof prefix), val);

  return val;
}

int
command_Expand_Interpret(char *buff, int nb, char *argv[MAXARGS], int offset)
{
  char buff2[LINE_LEN-offset];

  if (InterpretArg(buff, buff2, sizeof buff2) == NULL) {
    log_Printf(LogWARN, "Failed to expand command '%s': too long for the destination buffer\n", buff);
    return -1;
  }
  strncpy(buff, buff2, LINE_LEN - offset - 1);
  buff[LINE_LEN - offset - 1] = '\0';

  return command_Interpret(buff, nb, argv);
}

int
command_Interpret(char *buff, int nb, char *argv[MAXARGS])
{
  char *cp;

  if (nb > 0) {
    cp = buff + strcspn(buff, "\r\n");
    if (cp)
      *cp = '\0';
    return MakeArgs(buff, argv, MAXARGS, PARSE_REDUCE);
  }
  return 0;
}

static int
arghidden(int argc, char const *const *argv, int n)
{
  /* Is arg n of the given command to be hidden from the log ? */

  /* set authkey xxxxx */
  /* set key xxxxx */
  if (n == 2 && !strncasecmp(argv[0], "se", 2) &&
      (!strncasecmp(argv[1], "authk", 5) || !strncasecmp(argv[1], "ke", 2)))
    return 1;

  /* passwd xxxxx */
  if (n == 1 && !strncasecmp(argv[0], "p", 1))
    return 1;

  /* set server port xxxxx .... */
  if (n == 3 && !strncasecmp(argv[0], "se", 2) &&
      !strncasecmp(argv[1], "se", 2))
    return 1;

  return 0;
}

void
command_Run(struct bundle *bundle, int argc, char const *const *argv,
           struct prompt *prompt, const char *label, struct datalink *cx)
{
  if (argc > 0) {
    if (log_IsKept(LogCOMMAND)) {
      char buf[LINE_LEN];
      int f, n;

      if (label) {
        strncpy(buf, label, sizeof buf - 3);
        buf[sizeof buf - 3] = '\0';
        strlcat(buf, ": ", sizeof buf);
        n = strlen(buf);
      } else {
        *buf = '\0';
        n = 0;
      }
      buf[sizeof buf - 1] = '\0';	/* In case we run out of room in buf */

      for (f = 0; f < argc; f++) {
        if (n < sizeof buf - 1 && f)
          buf[n++] = ' ';
        if (arghidden(argc, argv, f))
          strncpy(buf+n, "********", sizeof buf - n - 1);
        else
          strncpy(buf+n, argv[f], sizeof buf - n - 1);
        n += strlen(buf+n);
      }
      log_Printf(LogCOMMAND, "%s\n", buf);
    }
    FindExec(bundle, Commands, argc, 0, argv, prompt, cx);
  }
}

int
command_Decode(struct bundle *bundle, char *buff, int nb, struct prompt *prompt,
              const char *label)
{
  int argc;
  char *argv[MAXARGS];

  if ((argc = command_Expand_Interpret(buff, nb, argv, 0)) < 0)
    return 0;

  command_Run(bundle, argc, (char const *const *)argv, prompt, label, NULL);
  return 1;
}

static int
ShowCommand(struct cmdargs const *arg)
{
  if (!arg->prompt)
    log_Printf(LogWARN, "show: Cannot show without a prompt\n");
  else if (arg->argc > arg->argn)
    FindExec(arg->bundle, ShowCommands, arg->argc, arg->argn, arg->argv,
             arg->prompt, arg->cx);
  else
    prompt_Printf(arg->prompt, "Use ``show ?'' to get a list.\n");

  return 0;
}

static int
TerminalCommand(struct cmdargs const *arg)
{
  if (!arg->prompt) {
    log_Printf(LogWARN, "term: Need a prompt\n");
    return 1;
  }

  if (arg->cx->physical->link.lcp.fsm.state > ST_CLOSED) {
    prompt_Printf(arg->prompt, "LCP state is [%s]\n",
                  State2Nam(arg->cx->physical->link.lcp.fsm.state));
    return 1;
  }

  datalink_Up(arg->cx, 0, 0);
  prompt_TtyTermMode(arg->prompt, arg->cx);
  return 0;
}

static int
QuitCommand(struct cmdargs const *arg)
{
  if (!arg->prompt || prompt_IsController(arg->prompt) ||
      (arg->argc > arg->argn && !strcasecmp(arg->argv[arg->argn], "all") &&
       (arg->prompt->auth & LOCAL_AUTH)))
    Cleanup(EX_NORMAL);
  if (arg->prompt)
    prompt_Destroy(arg->prompt, 1);

  return 0;
}

static int
OpenCommand(struct cmdargs const *arg)
{
  if (arg->argc == arg->argn)
    bundle_Open(arg->bundle, arg->cx ? arg->cx->name : NULL, PHYS_ALL, 1);
  else if (arg->argc == arg->argn + 1) {
    if (!strcasecmp(arg->argv[arg->argn], "lcp")) {
      struct datalink *cx = arg->cx ?
        arg->cx : bundle2datalink(arg->bundle, NULL);
      if (cx) {
        if (cx->physical->link.lcp.fsm.state == ST_OPENED)
          fsm_Reopen(&cx->physical->link.lcp.fsm);
        else
          bundle_Open(arg->bundle, cx->name, PHYS_ALL, 1);
      } else
        log_Printf(LogWARN, "open lcp: You must specify a link\n");
    } else if (!strcasecmp(arg->argv[arg->argn], "ccp")) {
      struct fsm *fp;

      fp = &command_ChooseLink(arg)->ccp.fsm;
      if (fp->link->lcp.fsm.state != ST_OPENED)
        log_Printf(LogWARN, "open: LCP must be open before opening CCP\n");
      else if (fp->state == ST_OPENED)
        fsm_Reopen(fp);
      else {
        fp->open_mode = 0;	/* Not passive any more */
        if (fp->state == ST_STOPPED) {
          fsm_Down(fp);
          fsm_Up(fp);
        } else {
          fsm_Up(fp);
          fsm_Open(fp);
        }
      }
    } else if (!strcasecmp(arg->argv[arg->argn], "ipcp")) {
      if (arg->cx)
        log_Printf(LogWARN, "open ipcp: You need not specify a link\n");
      if (arg->bundle->ncp.ipcp.fsm.state == ST_OPENED)
        fsm_Reopen(&arg->bundle->ncp.ipcp.fsm);
      else
        bundle_Open(arg->bundle, NULL, PHYS_ALL, 1);
    } else
      return -1;
  } else
    return -1;

  return 0;
}

static int
CloseCommand(struct cmdargs const *arg)
{
  if (arg->argc == arg->argn)
    bundle_Close(arg->bundle, arg->cx ? arg->cx->name : NULL, CLOSE_STAYDOWN);
  else if (arg->argc == arg->argn + 1) {
    if (!strcasecmp(arg->argv[arg->argn], "lcp"))
      bundle_Close(arg->bundle, arg->cx ? arg->cx->name : NULL, CLOSE_LCP);
    else if (!strcasecmp(arg->argv[arg->argn], "ccp") ||
             !strcasecmp(arg->argv[arg->argn], "ccp!")) {
      struct fsm *fp;

      fp = &command_ChooseLink(arg)->ccp.fsm;
      if (fp->state == ST_OPENED) {
        fsm_Close(fp);
        if (arg->argv[arg->argn][3] == '!')
          fp->open_mode = 0;		/* Stay ST_CLOSED */
        else
          fp->open_mode = OPEN_PASSIVE;	/* Wait for the peer to start */
      }
    } else
      return -1;
  } else
    return -1;

  return 0;
}

static int
DownCommand(struct cmdargs const *arg)
{
  if (arg->argc == arg->argn) {
      if (arg->cx)
        datalink_Down(arg->cx, CLOSE_STAYDOWN);
      else
        bundle_Down(arg->bundle, CLOSE_STAYDOWN);
  } else if (arg->argc == arg->argn + 1) {
    if (!strcasecmp(arg->argv[arg->argn], "lcp")) {
      if (arg->cx)
        datalink_Down(arg->cx, CLOSE_LCP);
      else
        bundle_Down(arg->bundle, CLOSE_LCP);
    } else if (!strcasecmp(arg->argv[arg->argn], "ccp")) {
      struct fsm *fp = arg->cx ? &arg->cx->physical->link.ccp.fsm :
                                 &arg->bundle->ncp.mp.link.ccp.fsm;
      fsm2initial(fp);
    } else
      return -1;
  } else
    return -1;

  return 0;
}

static int
SetModemSpeed(struct cmdargs const *arg)
{
  long speed;
  char *end;

  if (arg->argc > arg->argn && *arg->argv[arg->argn]) {
    if (arg->argc > arg->argn+1) {
      log_Printf(LogWARN, "SetModemSpeed: Too many arguments\n");
      return -1;
    }
    if (strcasecmp(arg->argv[arg->argn], "sync") == 0) {
      physical_SetSync(arg->cx->physical);
      return 0;
    }
    end = NULL;
    speed = strtol(arg->argv[arg->argn], &end, 10);
    if (*end) {
      log_Printf(LogWARN, "SetModemSpeed: Bad argument \"%s\"",
                arg->argv[arg->argn]);
      return -1;
    }
    if (physical_SetSpeed(arg->cx->physical, speed))
      return 0;
    log_Printf(LogWARN, "%s: Invalid speed\n", arg->argv[arg->argn]);
  } else
    log_Printf(LogWARN, "SetModemSpeed: No speed specified\n");

  return -1;
}

static int
SetStoppedTimeout(struct cmdargs const *arg)
{
  struct link *l = &arg->cx->physical->link;

  l->lcp.fsm.StoppedTimer.load = 0;
  l->ccp.fsm.StoppedTimer.load = 0;
  if (arg->argc <= arg->argn+2) {
    if (arg->argc > arg->argn) {
      l->lcp.fsm.StoppedTimer.load = atoi(arg->argv[arg->argn]) * SECTICKS;
      if (arg->argc > arg->argn+1)
        l->ccp.fsm.StoppedTimer.load = atoi(arg->argv[arg->argn+1]) * SECTICKS;
    }
    return 0;
  }
  return -1;
}

static int
SetServer(struct cmdargs const *arg)
{
  int res = -1;

  if (arg->argc > arg->argn && arg->argc < arg->argn+4) {
    const char *port, *passwd, *mask;
    int mlen;

    /* What's what ? */
    port = arg->argv[arg->argn];
    if (arg->argc == arg->argn + 2) {
      passwd = arg->argv[arg->argn+1];
      mask = NULL;
    } else if (arg->argc == arg->argn + 3) {
      passwd = arg->argv[arg->argn+1];
      mask = arg->argv[arg->argn+2];
      mlen = strlen(mask);
      if (mlen == 0 || mlen > 4 || strspn(mask, "01234567") != mlen ||
          (mlen == 4 && *mask != '0')) {
        log_Printf(LogWARN, "%s %s: %s: Invalid mask\n",
                   arg->argv[arg->argn - 2], arg->argv[arg->argn - 1], mask);
        return -1;
      }
    } else if (arg->argc != arg->argn + 1)
      return -1;
    else if (strcasecmp(port, "none") == 0) {
      if (server_Clear(arg->bundle))
        log_Printf(LogPHASE, "Disabled server socket\n");
      return 0;
    } else if (strcasecmp(port, "open") == 0) {
      switch (server_Reopen(arg->bundle)) {
        case SERVER_OK:
          return 0;
        case SERVER_FAILED:
          log_Printf(LogWARN, "Failed to reopen server port\n");
          return 1;
        case SERVER_UNSET:
          log_Printf(LogWARN, "Cannot reopen unset server socket\n");
          return 1;
        default:
          break;
      }
      return -1;
    } else if (strcasecmp(port, "closed") == 0) {
      if (server_Close(arg->bundle))
        log_Printf(LogPHASE, "Closed server socket\n");
      else
        log_Printf(LogWARN, "Server socket not open\n");

      return 0;
    } else
      return -1;

    strncpy(server.cfg.passwd, passwd, sizeof server.cfg.passwd - 1);
    server.cfg.passwd[sizeof server.cfg.passwd - 1] = '\0';

    if (*port == '/') {
      mode_t imask;
      char *ptr, name[LINE_LEN + 12];

      if (mask == NULL)
        imask = (mode_t)-1;
      else for (imask = mlen = 0; mask[mlen]; mlen++)
        imask = (imask * 8) + mask[mlen] - '0';

      ptr = strstr(port, "%d");
      if (ptr) {
        snprintf(name, sizeof name, "%.*s%d%s",
                 (int)(ptr - port), port, arg->bundle->unit, ptr + 2);
        port = name;
      }
      res = server_LocalOpen(arg->bundle, port, imask);
    } else {
      int iport, add = 0;

      if (mask != NULL)
        return -1;

      if (*port == '+') {
        port++;
        add = 1;
      }
      if (strspn(port, "0123456789") != strlen(port)) {
        struct servent *s;

        if ((s = getservbyname(port, "tcp")) == NULL) {
	  iport = 0;
	  log_Printf(LogWARN, "%s: Invalid port or service\n", port);
	} else
	  iport = ntohs(s->s_port);
      } else
        iport = atoi(port);

      if (iport) {
        if (add)
          iport += arg->bundle->unit;
        res = server_TcpOpen(arg->bundle, iport);
      } else
        res = -1;
    }
  }

  return res;
}

static int
SetEscape(struct cmdargs const *arg)
{
  int code;
  int argc = arg->argc - arg->argn;
  char const *const *argv = arg->argv + arg->argn;

  for (code = 0; code < 33; code++)
    arg->cx->physical->async.cfg.EscMap[code] = 0;

  while (argc-- > 0) {
    sscanf(*argv++, "%x", &code);
    code &= 0xff;
    arg->cx->physical->async.cfg.EscMap[code >> 3] |= (1 << (code & 7));
    arg->cx->physical->async.cfg.EscMap[32] = 1;
  }
  return 0;
}

static int
SetInterfaceAddr(struct cmdargs const *arg)
{
  struct ncp *ncp = &arg->bundle->ncp;
  struct ncpaddr ncpaddr;
  const char *hisaddr;

  if (arg->argc > arg->argn + 4)
    return -1;

  hisaddr = NULL;
  memset(&ncp->ipcp.cfg.my_range, '\0', sizeof ncp->ipcp.cfg.my_range);
  memset(&ncp->ipcp.cfg.peer_range, '\0', sizeof ncp->ipcp.cfg.peer_range);
  ncp->ipcp.cfg.HaveTriggerAddress = 0;
  ncp->ipcp.cfg.netmask.s_addr = INADDR_ANY;
  iplist_reset(&ncp->ipcp.cfg.peer_list);

  if (arg->argc > arg->argn) {
    if (!ncprange_aton(&ncp->ipcp.cfg.my_range, ncp, arg->argv[arg->argn]))
      return 1;
    if (arg->argc > arg->argn+1) {
      hisaddr = arg->argv[arg->argn+1];
      if (arg->argc > arg->argn+2) {
        ncp->ipcp.ifmask = ncp->ipcp.cfg.netmask =
          GetIpAddr(arg->argv[arg->argn+2]);
	if (arg->argc > arg->argn+3) {
	  ncp->ipcp.cfg.TriggerAddress = GetIpAddr(arg->argv[arg->argn+3]);
	  ncp->ipcp.cfg.HaveTriggerAddress = 1;
	}
      }
    }
  }

  /* 0.0.0.0 means any address (0 bits) */
  ncprange_getaddr(&ncp->ipcp.cfg.my_range, &ncpaddr);
  ncpaddr_getip4(&ncpaddr, &ncp->ipcp.my_ip);
  if (ncp->ipcp.my_ip.s_addr == INADDR_ANY)
    ncprange_setwidth(&ncp->ipcp.cfg.my_range, 0);
  bundle_AdjustFilters(arg->bundle, &ncpaddr, NULL);

  if (hisaddr && !ipcp_UseHisaddr(arg->bundle, hisaddr,
                                  arg->bundle->phys_type.all & PHYS_AUTO))
    return 4;

  return 0;
}

static int
SetRetry(int argc, char const *const *argv, u_int *timeout, u_int *maxreq,
          u_int *maxtrm, int def)
{
  if (argc == 0) {
    *timeout = DEF_FSMRETRY;
    *maxreq = def;
    if (maxtrm != NULL)
      *maxtrm = def;
  } else {
    long l = atol(argv[0]);

    if (l < MIN_FSMRETRY) {
      log_Printf(LogWARN, "%ld: Invalid FSM retry period - min %d\n",
                 l, MIN_FSMRETRY);
      return 1;
    } else
      *timeout = l;

    if (argc > 1) {
      l = atol(argv[1]);
      if (l < 1) {
        log_Printf(LogWARN, "%ld: Invalid FSM REQ tries - changed to 1\n", l);
        l = 1;
      }
      *maxreq = l;

      if (argc > 2 && maxtrm != NULL) {
        l = atol(argv[2]);
        if (l < 1) {
          log_Printf(LogWARN, "%ld: Invalid FSM TRM tries - changed to 1\n", l);
          l = 1;
        }
        *maxtrm = l;
      }
    }
  }

  return 0;
}

static int
SetVariable(struct cmdargs const *arg)
{
  long long_val, param = (long)arg->cmd->args;
  int mode, dummyint, f, first, res;
  u_short *change;
  const char *argp;
  struct datalink *cx = arg->cx;	/* LOCAL_CX uses this */
  struct link *l = command_ChooseLink(arg);	/* LOCAL_CX_OPT uses this */
  struct in_addr *ipaddr;
  struct ncpaddr ncpaddr[2];

  if (arg->argc > arg->argn)
    argp = arg->argv[arg->argn];
  else
    argp = "";

  res = 0;

  if ((arg->cmd->lauth & LOCAL_CX) && !cx) {
    log_Printf(LogWARN, "set %s: No context (use the `link' command)\n",
              arg->cmd->name);
    return 1;
  } else if (cx && !(arg->cmd->lauth & (LOCAL_CX|LOCAL_CX_OPT))) {
    log_Printf(LogWARN, "set %s: Redundant context (%s) ignored\n",
              arg->cmd->name, cx->name);
    cx = NULL;
  }

  switch (param) {
  case VAR_AUTHKEY:
    strncpy(arg->bundle->cfg.auth.key, argp,
            sizeof arg->bundle->cfg.auth.key - 1);
    arg->bundle->cfg.auth.key[sizeof arg->bundle->cfg.auth.key - 1] = '\0';
    break;

  case VAR_AUTHNAME:
    switch (bundle_Phase(arg->bundle)) {
      default:
        log_Printf(LogWARN, "Altering authname while at phase %s\n",
                   bundle_PhaseName(arg->bundle));
        /* drop through */
      case PHASE_DEAD:
      case PHASE_ESTABLISH:
        strncpy(arg->bundle->cfg.auth.name, argp,
                sizeof arg->bundle->cfg.auth.name - 1);
        arg->bundle->cfg.auth.name[sizeof arg->bundle->cfg.auth.name-1] = '\0';
        break;
    }
    break;

  case VAR_AUTOLOAD:
    if (arg->argc == arg->argn + 3) {
      int v1, v2, v3;
      char *end;

      v1 = strtol(arg->argv[arg->argn], &end, 0);
      if (v1 < 0 || *end) {
        log_Printf(LogWARN, "autoload: %s: Invalid min percentage\n",
                   arg->argv[arg->argn]);
        res = 1;
        break;
      }

      v2 = strtol(arg->argv[arg->argn + 1], &end, 0);
      if (v2 < 0 || *end) {
        log_Printf(LogWARN, "autoload: %s: Invalid max percentage\n",
                   arg->argv[arg->argn + 1]);
        res = 1;
        break;
      }
      if (v2 < v1) {
        v3 = v1;
        v1 = v2;
        v2 = v3;
      }

      v3 = strtol(arg->argv[arg->argn + 2], &end, 0);
      if (v3 <= 0 || *end) {
        log_Printf(LogWARN, "autoload: %s: Invalid throughput period\n",
                   arg->argv[arg->argn + 2]);
        res = 1;
        break;
      }

      arg->bundle->ncp.mp.cfg.autoload.min = v1;
      arg->bundle->ncp.mp.cfg.autoload.max = v2;
      arg->bundle->ncp.mp.cfg.autoload.period = v3;
      mp_RestartAutoloadTimer(&arg->bundle->ncp.mp);
    } else {
      log_Printf(LogWARN, "Set autoload requires three arguments\n");
      res = 1;
    }
    break;

  case VAR_DIAL:
    strncpy(cx->cfg.script.dial, argp, sizeof cx->cfg.script.dial - 1);
    cx->cfg.script.dial[sizeof cx->cfg.script.dial - 1] = '\0';
    break;

  case VAR_LOGIN:
    strncpy(cx->cfg.script.login, argp, sizeof cx->cfg.script.login - 1);
    cx->cfg.script.login[sizeof cx->cfg.script.login - 1] = '\0';
    break;

  case VAR_WINSIZE:
    if (arg->argc > arg->argn) {
      l->ccp.cfg.deflate.out.winsize = atoi(arg->argv[arg->argn]);
      if (l->ccp.cfg.deflate.out.winsize < 8 ||
          l->ccp.cfg.deflate.out.winsize > 15) {
          log_Printf(LogWARN, "%d: Invalid outgoing window size\n",
                    l->ccp.cfg.deflate.out.winsize);
          l->ccp.cfg.deflate.out.winsize = 15;
      }
      if (arg->argc > arg->argn+1) {
        l->ccp.cfg.deflate.in.winsize = atoi(arg->argv[arg->argn+1]);
        if (l->ccp.cfg.deflate.in.winsize < 8 ||
            l->ccp.cfg.deflate.in.winsize > 15) {
            log_Printf(LogWARN, "%d: Invalid incoming window size\n",
                      l->ccp.cfg.deflate.in.winsize);
            l->ccp.cfg.deflate.in.winsize = 15;
        }
      } else
        l->ccp.cfg.deflate.in.winsize = 0;
    } else {
      log_Printf(LogWARN, "No window size specified\n");
      res = 1;
    }
    break;

#ifndef NODES
  case VAR_MPPE:
    if (arg->argc > arg->argn + 2) {
      res = -1;
      break;
    }

    if (arg->argc == arg->argn) {
      l->ccp.cfg.mppe.keybits = 0;
      l->ccp.cfg.mppe.state = MPPE_ANYSTATE;
      l->ccp.cfg.mppe.required = 0;
      break;
    }

    if (!strcmp(argp, "*"))
      long_val = 0;
    else {
      long_val = atol(argp);
      if (long_val != 40 && long_val != 56 && long_val != 128) {
        log_Printf(LogWARN, "%s: Invalid bits value\n", argp);
        res = -1;
        break;
      }
    }

    if (arg->argc == arg->argn + 2) {
      if (!strcmp(arg->argv[arg->argn + 1], "*"))
        l->ccp.cfg.mppe.state = MPPE_ANYSTATE;
      else if (!strcasecmp(arg->argv[arg->argn + 1], "stateless"))
        l->ccp.cfg.mppe.state = MPPE_STATELESS;
      else if (!strcasecmp(arg->argv[arg->argn + 1], "stateful"))
        l->ccp.cfg.mppe.state = MPPE_STATEFUL;
      else {
        log_Printf(LogWARN, "%s: Invalid state value\n",
                   arg->argv[arg->argn + 1]);
        res = -1;
        break;
      }
    } else
      l->ccp.cfg.mppe.state = MPPE_ANYSTATE;
    l->ccp.cfg.mppe.keybits = long_val;
    l->ccp.cfg.mppe.required = 1;
    break;
#endif

  case VAR_DEVICE:
    physical_SetDeviceList(cx->physical, arg->argc - arg->argn,
                           arg->argv + arg->argn);
    break;

  case VAR_ACCMAP:
    if (arg->argc > arg->argn) {
      u_long ulong_val;
      sscanf(argp, "%lx", &ulong_val);
      cx->physical->link.lcp.cfg.accmap = (u_int32_t)ulong_val;
    } else {
      log_Printf(LogWARN, "No accmap specified\n");
      res = 1;
    }
    break;

  case VAR_MODE:
    mode = Nam2mode(argp);
    if (mode == PHYS_NONE || mode == PHYS_ALL) {
      log_Printf(LogWARN, "%s: Invalid mode\n", argp);
      res = -1;
      break;
    }
    bundle_SetMode(arg->bundle, cx, mode);
    break;

  case VAR_MRRU:
    switch (bundle_Phase(arg->bundle)) {
      case PHASE_DEAD:
        break;
      case PHASE_ESTABLISH:
        /* Make sure none of our links are DATALINK_LCP or greater */
        if (bundle_HighestState(arg->bundle) >= DATALINK_LCP) {
          log_Printf(LogWARN, "mrru: Only changable before LCP negotiations\n");
          res = 1;
          break;
        }
        break;
      default:
        log_Printf(LogWARN, "mrru: Only changable at phase DEAD/ESTABLISH\n");
        res = 1;
        break;
    }
    if (res != 0)
      break;
    long_val = atol(argp);
    if (long_val && long_val < MIN_MRU) {
      log_Printf(LogWARN, "MRRU %ld: too small - min %d\n", long_val, MIN_MRU);
      res = 1;
      break;
    } else if (long_val > MAX_MRU) {
      log_Printf(LogWARN, "MRRU %ld: too big - max %d\n", long_val, MAX_MRU);
      res = 1;
      break;
    } else
      arg->bundle->ncp.mp.cfg.mrru = long_val;
    break;

  case VAR_MRU:
    long_val = 0;	/* silence gcc */
    change = NULL;	/* silence gcc */
    switch(arg->argc - arg->argn) {
    case 1:
      if (argp[strspn(argp, "0123456789")] != '\0') {
        res = -1;
        break;
      }
      /*FALLTHRU*/
    case 0:
      long_val = atol(argp);
      change = &l->lcp.cfg.mru;
      if (long_val > l->lcp.cfg.max_mru) {
        log_Printf(LogWARN, "MRU %ld: too large - max set to %d\n", long_val,
                   l->lcp.cfg.max_mru);
        res = 1;
        break;
      }
      break;
    case 2:
      if (strcasecmp(argp, "max") && strcasecmp(argp, "maximum")) {
        res = -1;
        break;
      }
      long_val = atol(arg->argv[arg->argn + 1]);
      change = &l->lcp.cfg.max_mru;
      if (long_val > MAX_MRU) {
        log_Printf(LogWARN, "MRU %ld: too large - maximum is %d\n", long_val,
                   MAX_MRU);
        res = 1;
        break;
      }
      break;
    default:
      res = -1;
      break;
    }
    if (res != 0)
      break;

    if (long_val == 0)
      *change = 0;
    else if (long_val < MIN_MRU) {
      log_Printf(LogWARN, "MRU %ld: too small - min %d\n", long_val, MIN_MRU);
      res = 1;
      break;
    } else if (long_val > MAX_MRU) {
      log_Printf(LogWARN, "MRU %ld: too big - max %d\n", long_val, MAX_MRU);
      res = 1;
      break;
    } else
      *change = long_val;
    if (l->lcp.cfg.mru > *change)
      l->lcp.cfg.mru = *change;
    break;

  case VAR_MTU:
    long_val = 0;	/* silence gcc */
    change = NULL;	/* silence gcc */
    switch(arg->argc - arg->argn) {
    case 1:
      if (argp[strspn(argp, "0123456789")] != '\0') {
        res = -1;
        break;
      }
      /*FALLTHRU*/
    case 0:
      long_val = atol(argp);
      change = &l->lcp.cfg.mtu;
      if (long_val > l->lcp.cfg.max_mtu) {
        log_Printf(LogWARN, "MTU %ld: too large - max set to %d\n", long_val,
                   l->lcp.cfg.max_mtu);
        res = 1;
        break;
      }
      break;
    case 2:
      if (strcasecmp(argp, "max") && strcasecmp(argp, "maximum")) {
        res = -1;
        break;
      }
      long_val = atol(arg->argv[arg->argn + 1]);
      change = &l->lcp.cfg.max_mtu;
      if (long_val > MAX_MTU) {
        log_Printf(LogWARN, "MTU %ld: too large - maximum is %d\n", long_val,
                   MAX_MTU);
        res = 1;
        break;
      }
      break;
    default:
      res = -1;
      break;
    }

    if (res != 0)
      break;

    if (long_val && long_val < MIN_MTU) {
      log_Printf(LogWARN, "MTU %ld: too small - min %d\n", long_val, MIN_MTU);
      res = 1;
      break;
    } else if (long_val > MAX_MTU) {
      log_Printf(LogWARN, "MTU %ld: too big - max %d\n", long_val, MAX_MTU);
      res = 1;
      break;
    } else
      *change = long_val;
    if (l->lcp.cfg.mtu > *change)
      l->lcp.cfg.mtu = *change;
    break;

  case VAR_OPENMODE:
    if (strcasecmp(argp, "active") == 0)
      cx->physical->link.lcp.cfg.openmode = arg->argc > arg->argn+1 ?
        atoi(arg->argv[arg->argn+1]) : 1;
    else if (strcasecmp(argp, "passive") == 0)
      cx->physical->link.lcp.cfg.openmode = OPEN_PASSIVE;
    else {
      log_Printf(LogWARN, "%s: Invalid openmode\n", argp);
      res = 1;
    }
    break;

  case VAR_PHONE:
    strncpy(cx->cfg.phone.list, argp, sizeof cx->cfg.phone.list - 1);
    cx->cfg.phone.list[sizeof cx->cfg.phone.list - 1] = '\0';
    cx->phone.alt = cx->phone.next = NULL;
    break;

  case VAR_HANGUP:
    strncpy(cx->cfg.script.hangup, argp, sizeof cx->cfg.script.hangup - 1);
    cx->cfg.script.hangup[sizeof cx->cfg.script.hangup - 1] = '\0';
    break;

  case VAR_IFQUEUE:
    long_val = atol(argp);
    arg->bundle->cfg.ifqueue = long_val < 0 ? 0 : long_val;
    break;

  case VAR_LOGOUT:
    strncpy(cx->cfg.script.logout, argp, sizeof cx->cfg.script.logout - 1);
    cx->cfg.script.logout[sizeof cx->cfg.script.logout - 1] = '\0';
    break;

  case VAR_IDLETIMEOUT:
    if (arg->argc > arg->argn+2) {
      log_Printf(LogWARN, "Too many idle timeout values\n");
      res = 1;
    } else if (arg->argc == arg->argn) {
      log_Printf(LogWARN, "Too few idle timeout values\n");
      res = 1;
    } else {
      int timeout, min;

      timeout = atoi(argp);
      min = arg->argc == arg->argn + 2 ? atoi(arg->argv[arg->argn + 1]) : -1;
      bundle_SetIdleTimer(arg->bundle, timeout, min);
    }
    break;

#ifndef NORADIUS
  case VAR_RAD_ALIVE:
    if (arg->argc > arg->argn + 2) {
      log_Printf(LogWARN, "Too many RADIUS alive interval values\n");
      res = 1;
    } else if (arg->argc == arg->argn) {
      log_Printf(LogWARN, "Too few RADIUS alive interval values\n");
      res = 1;
    } else {
      arg->bundle->radius.alive.interval = atoi(argp);
      if (arg->bundle->radius.alive.interval && !arg->bundle->radius.cfg.file) {
        log_Printf(LogWARN, "rad_alive requires radius to be configured\n");
	res = 1;
      } else if (arg->bundle->ncp.ipcp.fsm.state == ST_OPENED) {
	if (arg->bundle->radius.alive.interval)
	  radius_StartTimer(arg->bundle);
	else
	  radius_StopTimer(&arg->bundle->radius);
      }
    }
    break;
#endif

  case VAR_LQRPERIOD:
    long_val = atol(argp);
    if (long_val < MIN_LQRPERIOD) {
      log_Printf(LogWARN, "%ld: Invalid lqr period - min %d\n",
                 long_val, MIN_LQRPERIOD);
      res = 1;
    } else
      l->lcp.cfg.lqrperiod = long_val;
    break;

  case VAR_LCPRETRY:
    res = SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                   &cx->physical->link.lcp.cfg.fsm.timeout,
                   &cx->physical->link.lcp.cfg.fsm.maxreq,
                   &cx->physical->link.lcp.cfg.fsm.maxtrm, DEF_FSMTRIES);
    break;

  case VAR_CHAPRETRY:
    res = SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                   &cx->chap.auth.cfg.fsm.timeout,
                   &cx->chap.auth.cfg.fsm.maxreq, NULL, DEF_FSMAUTHTRIES);
    break;

  case VAR_PAPRETRY:
    res = SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                   &cx->pap.cfg.fsm.timeout, &cx->pap.cfg.fsm.maxreq,
                   NULL, DEF_FSMAUTHTRIES);
    break;

  case VAR_CCPRETRY:
    res = SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                   &l->ccp.cfg.fsm.timeout, &l->ccp.cfg.fsm.maxreq,
                   &l->ccp.cfg.fsm.maxtrm, DEF_FSMTRIES);
    break;

  case VAR_IPCPRETRY:
    res = SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                   &arg->bundle->ncp.ipcp.cfg.fsm.timeout,
                   &arg->bundle->ncp.ipcp.cfg.fsm.maxreq,
                   &arg->bundle->ncp.ipcp.cfg.fsm.maxtrm, DEF_FSMTRIES);
    break;

#ifndef NOINET6
  case VAR_IPV6CPRETRY:
    res = SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                   &arg->bundle->ncp.ipv6cp.cfg.fsm.timeout,
                   &arg->bundle->ncp.ipv6cp.cfg.fsm.maxreq,
                   &arg->bundle->ncp.ipv6cp.cfg.fsm.maxtrm, DEF_FSMTRIES);
    break;
#endif

  case VAR_NBNS:
  case VAR_DNS:
    if (param == VAR_DNS) {
      ipaddr = arg->bundle->ncp.ipcp.cfg.ns.dns;
      ipaddr[0].s_addr = ipaddr[1].s_addr = INADDR_NONE;
    } else {
      ipaddr = arg->bundle->ncp.ipcp.cfg.ns.nbns;
      ipaddr[0].s_addr = ipaddr[1].s_addr = INADDR_ANY;
    }

    if (arg->argc > arg->argn) {
      ncpaddr_aton(ncpaddr, &arg->bundle->ncp, arg->argv[arg->argn]);
      if (!ncpaddr_getip4(ncpaddr, ipaddr))
        return -1;
      if (arg->argc > arg->argn+1) {
        ncpaddr_aton(ncpaddr + 1, &arg->bundle->ncp, arg->argv[arg->argn + 1]);
        if (!ncpaddr_getip4(ncpaddr + 1, ipaddr + 1))
          return -1;
      }

      if (ipaddr[0].s_addr == INADDR_ANY) {
        ipaddr[0] = ipaddr[1];
        ipaddr[1].s_addr = INADDR_ANY;
      }
      if (ipaddr[0].s_addr == INADDR_NONE) {
        ipaddr[0] = ipaddr[1];
        ipaddr[1].s_addr = INADDR_NONE;
      }
    }
    break;

  case VAR_CALLBACK:
    cx->cfg.callback.opmask = 0;
    for (dummyint = arg->argn; dummyint < arg->argc; dummyint++) {
      if (!strcasecmp(arg->argv[dummyint], "auth"))
        cx->cfg.callback.opmask |= CALLBACK_BIT(CALLBACK_AUTH);
      else if (!strcasecmp(arg->argv[dummyint], "cbcp"))
        cx->cfg.callback.opmask |= CALLBACK_BIT(CALLBACK_CBCP);
      else if (!strcasecmp(arg->argv[dummyint], "e.164")) {
        if (dummyint == arg->argc - 1)
          log_Printf(LogWARN, "No E.164 arg (E.164 ignored) !\n");
        else {
          cx->cfg.callback.opmask |= CALLBACK_BIT(CALLBACK_E164);
          strncpy(cx->cfg.callback.msg, arg->argv[++dummyint],
                  sizeof cx->cfg.callback.msg - 1);
          cx->cfg.callback.msg[sizeof cx->cfg.callback.msg - 1] = '\0';
        }
      } else if (!strcasecmp(arg->argv[dummyint], "none"))
        cx->cfg.callback.opmask |= CALLBACK_BIT(CALLBACK_NONE);
      else {
        res = -1;
        break;
      }
    }
    if (cx->cfg.callback.opmask == CALLBACK_BIT(CALLBACK_NONE))
      cx->cfg.callback.opmask = 0;
    break;

  case VAR_CBCP:
    cx->cfg.cbcp.delay = 0;
    *cx->cfg.cbcp.phone = '\0';
    cx->cfg.cbcp.fsmretry = DEF_FSMRETRY;
    if (arg->argc > arg->argn) {
      strncpy(cx->cfg.cbcp.phone, arg->argv[arg->argn],
              sizeof cx->cfg.cbcp.phone - 1);
      cx->cfg.cbcp.phone[sizeof cx->cfg.cbcp.phone - 1] = '\0';
      if (arg->argc > arg->argn + 1) {
        cx->cfg.cbcp.delay = atoi(arg->argv[arg->argn + 1]);
        if (arg->argc > arg->argn + 2) {
          long_val = atol(arg->argv[arg->argn + 2]);
          if (long_val < MIN_FSMRETRY)
            log_Printf(LogWARN, "%ld: Invalid CBCP FSM retry period - min %d\n",
                       long_val, MIN_FSMRETRY);
          else
            cx->cfg.cbcp.fsmretry = long_val;
        }
      }
    }
    break;

  case VAR_CHOKED:
    arg->bundle->cfg.choked.timeout = atoi(argp);
    if (arg->bundle->cfg.choked.timeout <= 0)
      arg->bundle->cfg.choked.timeout = CHOKED_TIMEOUT;
    break;

  case VAR_SENDPIPE:
    long_val = atol(argp);
    arg->bundle->ncp.cfg.sendpipe = long_val;
    break;

  case VAR_RECVPIPE:
    long_val = atol(argp);
    arg->bundle->ncp.cfg.recvpipe = long_val;
    break;

#ifndef NORADIUS
  case VAR_RADIUS:
    if (!*argp)
      *arg->bundle->radius.cfg.file = '\0';
    else if (access(argp, R_OK)) {
      log_Printf(LogWARN, "%s: %s\n", argp, strerror(errno));
      res = 1;
      break;
    } else {
      strncpy(arg->bundle->radius.cfg.file, argp,
              sizeof arg->bundle->radius.cfg.file - 1);
      arg->bundle->radius.cfg.file
        [sizeof arg->bundle->radius.cfg.file - 1] = '\0';
    }
    break;
#endif

  case VAR_CD:
    if (*argp) {
      if (strcasecmp(argp, "off")) {
        long_val = atol(argp);
        if (long_val < 0)
          long_val = 0;
        cx->physical->cfg.cd.delay = long_val;
        cx->physical->cfg.cd.necessity = argp[strlen(argp)-1] == '!' ?
          CD_REQUIRED : CD_VARIABLE;
      } else
        cx->physical->cfg.cd.necessity = CD_NOTREQUIRED;
    } else {
      cx->physical->cfg.cd.delay = 0;
      cx->physical->cfg.cd.necessity = CD_DEFAULT;
    }
    break;

  case VAR_PARITY:
    if (arg->argc == arg->argn + 1)
      res = physical_SetParity(arg->cx->physical, argp);
    else {
      log_Printf(LogWARN, "Parity value must be odd, even or none\n");
      res = 1;
    }
    break;

  case VAR_CRTSCTS:
    if (strcasecmp(argp, "on") == 0)
      physical_SetRtsCts(arg->cx->physical, 1);
    else if (strcasecmp(argp, "off") == 0)
      physical_SetRtsCts(arg->cx->physical, 0);
    else {
      log_Printf(LogWARN, "RTS/CTS value must be on or off\n");
      res = 1;
    }
    break;

  case VAR_URGENTPORTS:
    if (arg->argn == arg->argc) {
      ncp_SetUrgentTOS(&arg->bundle->ncp);
      ncp_ClearUrgentTcpPorts(&arg->bundle->ncp);
      ncp_ClearUrgentUdpPorts(&arg->bundle->ncp);
    } else if (!strcasecmp(arg->argv[arg->argn], "udp")) {
      ncp_SetUrgentTOS(&arg->bundle->ncp);
      if (arg->argn == arg->argc - 1)
        ncp_ClearUrgentUdpPorts(&arg->bundle->ncp);
      else for (f = arg->argn + 1; f < arg->argc; f++)
        if (*arg->argv[f] == '+')
          ncp_AddUrgentUdpPort(&arg->bundle->ncp, atoi(arg->argv[f] + 1));
        else if (*arg->argv[f] == '-')
          ncp_RemoveUrgentUdpPort(&arg->bundle->ncp, atoi(arg->argv[f] + 1));
        else {
          if (f == arg->argn)
            ncp_ClearUrgentUdpPorts(&arg->bundle->ncp);
          ncp_AddUrgentUdpPort(&arg->bundle->ncp, atoi(arg->argv[f]));
        }
    } else if (arg->argn == arg->argc - 1 &&
               !strcasecmp(arg->argv[arg->argn], "none")) {
      ncp_ClearUrgentTcpPorts(&arg->bundle->ncp);
      ncp_ClearUrgentUdpPorts(&arg->bundle->ncp);
      ncp_ClearUrgentTOS(&arg->bundle->ncp);
    } else {
      ncp_SetUrgentTOS(&arg->bundle->ncp);
      first = arg->argn;
      if (!strcasecmp(arg->argv[first], "tcp") && ++first == arg->argc)
        ncp_ClearUrgentTcpPorts(&arg->bundle->ncp);

      for (f = first; f < arg->argc; f++)
        if (*arg->argv[f] == '+')
          ncp_AddUrgentTcpPort(&arg->bundle->ncp, atoi(arg->argv[f] + 1));
        else if (*arg->argv[f] == '-')
          ncp_RemoveUrgentTcpPort(&arg->bundle->ncp, atoi(arg->argv[f] + 1));
        else {
          if (f == first)
            ncp_ClearUrgentTcpPorts(&arg->bundle->ncp);
          ncp_AddUrgentTcpPort(&arg->bundle->ncp, atoi(arg->argv[f]));
        }
    }
    break;
  }

  return res;
}

static struct cmdtab const SetCommands[] = {
  {"accmap", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "accmap value", "set accmap hex-value", (const void *)VAR_ACCMAP},
  {"authkey", "key", SetVariable, LOCAL_AUTH,
  "authentication key", "set authkey|key key", (const void *)VAR_AUTHKEY},
  {"authname", NULL, SetVariable, LOCAL_AUTH,
  "authentication name", "set authname name", (const void *)VAR_AUTHNAME},
  {"autoload", NULL, SetVariable, LOCAL_AUTH,
  "auto link [de]activation", "set autoload maxtime maxload mintime minload",
  (const void *)VAR_AUTOLOAD},
  {"bandwidth", NULL, mp_SetDatalinkBandwidth, LOCAL_AUTH | LOCAL_CX,
  "datalink bandwidth", "set bandwidth value"},
  {"callback", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "callback control", "set callback [none|auth|cbcp|"
  "E.164 *|number[,number]...]...", (const void *)VAR_CALLBACK},
  {"cbcp", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "CBCP control", "set cbcp [*|phone[,phone...] [delay [timeout]]]",
  (const void *)VAR_CBCP},
  {"ccpretry", "ccpretries", SetVariable, LOCAL_AUTH | LOCAL_CX_OPT,
   "CCP retries", "set ccpretry value [attempts]", (const void *)VAR_CCPRETRY},
  {"cd", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX, "Carrier delay requirement",
   "set cd value[!]", (const void *)VAR_CD},
  {"chapretry", "chapretries", SetVariable, LOCAL_AUTH | LOCAL_CX,
   "CHAP retries", "set chapretry value [attempts]",
   (const void *)VAR_CHAPRETRY},
  {"choked", NULL, SetVariable, LOCAL_AUTH,
  "choked timeout", "set choked [secs]", (const void *)VAR_CHOKED},
  {"ctsrts", "crtscts", SetVariable, LOCAL_AUTH | LOCAL_CX,
   "Use hardware flow control", "set ctsrts [on|off]",
   (const char *)VAR_CRTSCTS},
  {"deflate", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX_OPT,
  "deflate window sizes", "set deflate out-winsize in-winsize",
  (const void *) VAR_WINSIZE},
#ifndef NODES
  {"mppe", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX_OPT,
  "MPPE key size and state", "set mppe [40|56|128|* [stateful|stateless|*]]",
  (const void *) VAR_MPPE},
#endif
  {"device", "line", SetVariable, LOCAL_AUTH | LOCAL_CX,
  "physical device name", "set device|line device-name[,device-name]",
  (const void *) VAR_DEVICE},
  {"dial", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "dialing script", "set dial chat-script", (const void *) VAR_DIAL},
  {"dns", NULL, SetVariable, LOCAL_AUTH, "Domain Name Server",
  "set dns pri-addr [sec-addr]", (const void *)VAR_DNS},
  {"enddisc", NULL, mp_SetEnddisc, LOCAL_AUTH,
  "Endpoint Discriminator", "set enddisc [IP|magic|label|psn value]"},
  {"escape", NULL, SetEscape, LOCAL_AUTH | LOCAL_CX,
  "escape characters", "set escape hex-digit ..."},
  {"filter", NULL, filter_Set, LOCAL_AUTH,
  "packet filters", "set filter alive|dial|in|out rule-no permit|deny "
  "[src_addr[/width]] [dst_addr[/width]] [proto "
  "[src [lt|eq|gt port]] [dst [lt|eq|gt port]] [estab] [syn] [finrst]]"},
  {"hangup", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "hangup script", "set hangup chat-script", (const void *) VAR_HANGUP},
  {"ifaddr", NULL, SetInterfaceAddr, LOCAL_AUTH, "destination address",
  "set ifaddr [src-addr [dst-addr [netmask [trg-addr]]]]"},
  {"ifqueue", NULL, SetVariable, LOCAL_AUTH, "interface queue",
  "set ifqueue packets", (const void *)VAR_IFQUEUE},
  {"ipcpretry", "ipcpretries", SetVariable, LOCAL_AUTH, "IPCP retries",
   "set ipcpretry value [attempts]", (const void *)VAR_IPCPRETRY},
  {"ipv6cpretry", "ipv6cpretries", SetVariable, LOCAL_AUTH, "IPV6CP retries",
   "set ipv6cpretry value [attempts]", (const void *)VAR_IPV6CPRETRY},
  {"lcpretry", "lcpretries", SetVariable, LOCAL_AUTH | LOCAL_CX, "LCP retries",
   "set lcpretry value [attempts]", (const void *)VAR_LCPRETRY},
  {"log", NULL, log_SetLevel, LOCAL_AUTH, "log level",
  "set log [local] [+|-]all|async|cbcp|ccp|chat|command|connect|debug|dns|hdlc|"
  "id0|ipcp|lcp|lqm|phase|physical|radius|sync|tcp/ip|timer|tun..."},
  {"login", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "login script", "set login chat-script", (const void *) VAR_LOGIN},
  {"logout", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "logout script", "set logout chat-script", (const void *) VAR_LOGOUT},
  {"lqrperiod", "echoperiod", SetVariable, LOCAL_AUTH | LOCAL_CX_OPT,
  "LQR period", "set lqr/echo period value", (const void *)VAR_LQRPERIOD},
  {"mode", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX, "mode value",
  "set mode interactive|auto|ddial|background", (const void *)VAR_MODE},
  {"mrru", NULL, SetVariable, LOCAL_AUTH, "MRRU value",
  "set mrru value", (const void *)VAR_MRRU},
  {"mru", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "MRU value", "set mru [max[imum]] [value]", (const void *)VAR_MRU},
  {"mtu", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "interface MTU value", "set mtu [max[imum]] [value]", (const void *)VAR_MTU},
  {"nbns", NULL, SetVariable, LOCAL_AUTH, "NetBIOS Name Server",
  "set nbns pri-addr [sec-addr]", (const void *)VAR_NBNS},
  {"openmode", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX, "open mode",
  "set openmode active|passive [secs]", (const void *)VAR_OPENMODE},
  {"papretry", "papretries", SetVariable, LOCAL_AUTH | LOCAL_CX, "PAP retries",
   "set papretry value [attempts]", (const void *)VAR_PAPRETRY},
  {"parity", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX, "serial parity",
   "set parity [odd|even|none]", (const void *)VAR_PARITY},
  {"phone", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX, "telephone number(s)",
  "set phone phone1[:phone2[...]]", (const void *)VAR_PHONE},
  {"proctitle", "title", SetProcTitle, LOCAL_AUTH,
  "Process title", "set proctitle [value]"},
#ifndef NORADIUS
  {"radius", NULL, SetVariable, LOCAL_AUTH,
  "RADIUS Config", "set radius cfgfile", (const void *)VAR_RADIUS},
  {"rad_alive", NULL, SetVariable, LOCAL_AUTH,
  "Raduis alive interval", "set rad_alive value",
  (const void *)VAR_RAD_ALIVE},  
#endif
  {"reconnect", NULL, datalink_SetReconnect, LOCAL_AUTH | LOCAL_CX,
  "Reconnect timeout", "set reconnect value ntries"},
  {"recvpipe", NULL, SetVariable, LOCAL_AUTH,
  "RECVPIPE value", "set recvpipe value", (const void *)VAR_RECVPIPE},
  {"redial", NULL, datalink_SetRedial, LOCAL_AUTH | LOCAL_CX,
  "Redial timeout", "set redial secs[+inc[-incmax]][.next] [attempts]"},
  {"sendpipe", NULL, SetVariable, LOCAL_AUTH,
  "SENDPIPE value", "set sendpipe value", (const void *)VAR_SENDPIPE},
  {"server", "socket", SetServer, LOCAL_AUTH, "diagnostic port",
  "set server|socket TcpPort|LocalName|none|open|closed [password [mask]]"},
  {"speed", NULL, SetModemSpeed, LOCAL_AUTH | LOCAL_CX,
  "physical speed", "set speed value|sync"},
  {"stopped", NULL, SetStoppedTimeout, LOCAL_AUTH | LOCAL_CX,
  "STOPPED timeouts", "set stopped [LCPseconds [CCPseconds]]"},
  {"timeout", NULL, SetVariable, LOCAL_AUTH, "Idle timeout",
  "set timeout idletime", (const void *)VAR_IDLETIMEOUT},
  {"urgent", NULL, SetVariable, LOCAL_AUTH, "urgent ports",
  "set urgent [tcp|udp] [+|-]port...", (const void *)VAR_URGENTPORTS},
  {"vj", NULL, ipcp_vjset, LOCAL_AUTH,
  "vj values", "set vj slots|slotcomp [value]"},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
  "Display this message", "set help|? [command]", SetCommands},
  {NULL, NULL, NULL},
};

static int
SetCommand(struct cmdargs const *arg)
{
  if (arg->argc > arg->argn)
    FindExec(arg->bundle, SetCommands, arg->argc, arg->argn, arg->argv,
             arg->prompt, arg->cx);
  else if (arg->prompt)
    prompt_Printf(arg->prompt, "Use `set ?' to get a list or `set ? <var>' for"
	          " syntax help.\n");
  else
    log_Printf(LogWARN, "set command must have arguments\n");

  return 0;
}

static int
AddCommand(struct cmdargs const *arg)
{
  struct ncpaddr gw;
  struct ncprange dest;
  struct in_addr host;
#ifndef NOINET6
  struct in6_addr host6;
#endif
  int dest_default, gw_arg, addrs;

  if (arg->argc != arg->argn+3 && arg->argc != arg->argn+2)
    return -1;

  addrs = 0;
  dest_default = 0;
  if (arg->argc == arg->argn + 2) {
    if (!strcasecmp(arg->argv[arg->argn], "default"))
      dest_default = 1;
    else {
      if (!ncprange_aton(&dest, &arg->bundle->ncp, arg->argv[arg->argn]))
        return -1;
      if (!strncasecmp(arg->argv[arg->argn], "MYADDR", 6))
        addrs = ROUTE_DSTMYADDR;
      else if (!strncasecmp(arg->argv[arg->argn], "MYADDR6", 7))
        addrs = ROUTE_DSTMYADDR6;
      else if (!strncasecmp(arg->argv[arg->argn], "HISADDR", 7))
        addrs = ROUTE_DSTHISADDR;
      else if (!strncasecmp(arg->argv[arg->argn], "HISADDR6", 8))
        addrs = ROUTE_DSTHISADDR6;
      else if (!strncasecmp(arg->argv[arg->argn], "DNS0", 4))
        addrs = ROUTE_DSTDNS0;
      else if (!strncasecmp(arg->argv[arg->argn], "DNS1", 4))
        addrs = ROUTE_DSTDNS1;
    }
    gw_arg = 1;
  } else {
    if (strcasecmp(arg->argv[arg->argn], "MYADDR") == 0) {
      addrs = ROUTE_DSTMYADDR;
      host = arg->bundle->ncp.ipcp.my_ip;
    } else if (strcasecmp(arg->argv[arg->argn], "HISADDR") == 0) {
      addrs = ROUTE_DSTHISADDR;
      host = arg->bundle->ncp.ipcp.peer_ip;
    } else if (strcasecmp(arg->argv[arg->argn], "DNS0") == 0) {
      addrs = ROUTE_DSTDNS0;
      host = arg->bundle->ncp.ipcp.ns.dns[0];
    } else if (strcasecmp(arg->argv[arg->argn], "DNS1") == 0) {
      addrs = ROUTE_DSTDNS1;
      host = arg->bundle->ncp.ipcp.ns.dns[1];
    } else {
      host = GetIpAddr(arg->argv[arg->argn]);
      if (host.s_addr == INADDR_NONE) {
        log_Printf(LogWARN, "%s: Invalid destination address\n",
                   arg->argv[arg->argn]);
        return -1;
      }
    }
    ncprange_setip4(&dest, host, GetIpAddr(arg->argv[arg->argn + 1]));
    gw_arg = 2;
  }

  if (strcasecmp(arg->argv[arg->argn + gw_arg], "HISADDR") == 0) {
    ncpaddr_setip4(&gw, arg->bundle->ncp.ipcp.peer_ip);
    addrs |= ROUTE_GWHISADDR;
#ifndef NOINET6
  } else if (strcasecmp(arg->argv[arg->argn + gw_arg], "HISADDR6") == 0) {
    if (!ncpaddr_getip6(&arg->bundle->ncp.ipv6cp.hisaddr, &host6))
      memset(&host6, '\0', sizeof host6);
    ncpaddr_setip6(&gw, &host6);
    addrs |= ROUTE_GWHISADDR6;
#endif
  } else {
    if (!ncpaddr_aton(&gw, &arg->bundle->ncp, arg->argv[arg->argn + gw_arg])) {
      log_Printf(LogWARN, "%s: Invalid gateway address\n",
                 arg->argv[arg->argn + gw_arg]);
      return -1;
    }
  }

  if (dest_default)
    ncprange_setdefault(&dest, ncpaddr_family(&gw));

  if (rt_Set(arg->bundle, RTM_ADD, &dest, &gw, arg->cmd->args ? 1 : 0,
             ((addrs & ROUTE_GWHISADDR) || (addrs & ROUTE_GWHISADDR6)) ? 1 : 0)
      && addrs != ROUTE_STATIC)
    route_Add(&arg->bundle->ncp.route, addrs, &dest, &gw);

  return 0;
}

static int
DeleteCommand(struct cmdargs const *arg)
{
  struct ncprange dest;
  int addrs;

  if (arg->argc == arg->argn+1) {
    if(strcasecmp(arg->argv[arg->argn], "all") == 0) {
      route_IfDelete(arg->bundle, 0);
      route_DeleteAll(&arg->bundle->ncp.route);
    } else {
      addrs = 0;
      if (strcasecmp(arg->argv[arg->argn], "MYADDR") == 0) {
        ncprange_setip4host(&dest, arg->bundle->ncp.ipcp.my_ip);
        addrs = ROUTE_DSTMYADDR;
#ifndef NOINET6
      } else if (strcasecmp(arg->argv[arg->argn], "MYADDR6") == 0) {
        ncprange_sethost(&dest, &arg->bundle->ncp.ipv6cp.myaddr);
        addrs = ROUTE_DSTMYADDR6;
#endif
      } else if (strcasecmp(arg->argv[arg->argn], "HISADDR") == 0) {
        ncprange_setip4host(&dest, arg->bundle->ncp.ipcp.peer_ip);
        addrs = ROUTE_DSTHISADDR;
#ifndef NOINET6
      } else if (strcasecmp(arg->argv[arg->argn], "HISADDR6") == 0) {
        ncprange_sethost(&dest, &arg->bundle->ncp.ipv6cp.hisaddr);
        addrs = ROUTE_DSTHISADDR6;
#endif
      } else if (strcasecmp(arg->argv[arg->argn], "DNS0") == 0) {
        ncprange_setip4host(&dest, arg->bundle->ncp.ipcp.ns.dns[0]);
        addrs = ROUTE_DSTDNS0;
      } else if (strcasecmp(arg->argv[arg->argn], "DNS1") == 0) {
        ncprange_setip4host(&dest, arg->bundle->ncp.ipcp.ns.dns[1]);
        addrs = ROUTE_DSTDNS1;
      } else {
        ncprange_aton(&dest, &arg->bundle->ncp, arg->argv[arg->argn]);
        addrs = ROUTE_STATIC;
      }
      rt_Set(arg->bundle, RTM_DELETE, &dest, NULL, arg->cmd->args ? 1 : 0, 0);
      route_Delete(&arg->bundle->ncp.route, addrs, &dest);
    }
  } else
    return -1;

  return 0;
}

#ifndef NONAT
static int
NatEnable(struct cmdargs const *arg)
{
  if (arg->argc == arg->argn+1) {
    if (strcasecmp(arg->argv[arg->argn], "yes") == 0) {
      if (!arg->bundle->NatEnabled) {
        if (arg->bundle->ncp.ipcp.fsm.state == ST_OPENED)
          PacketAliasSetAddress(arg->bundle->ncp.ipcp.my_ip);
        arg->bundle->NatEnabled = 1;
      }
      return 0;
    } else if (strcasecmp(arg->argv[arg->argn], "no") == 0) {
      arg->bundle->NatEnabled = 0;
      opt_disable(arg->bundle, OPT_IFACEALIAS);
      /* Don't iface_Clear() - there may be manually configured addresses */
      return 0;
    }
  }

  return -1;
}


static int
NatOption(struct cmdargs const *arg)
{
  long param = (long)arg->cmd->args;

  if (arg->argc == arg->argn+1) {
    if (strcasecmp(arg->argv[arg->argn], "yes") == 0) {
      if (arg->bundle->NatEnabled) {
	PacketAliasSetMode(param, param);
	return 0;
      }
      log_Printf(LogWARN, "nat not enabled\n");
    } else if (strcmp(arg->argv[arg->argn], "no") == 0) {
      if (arg->bundle->NatEnabled) {
	PacketAliasSetMode(0, param);
	return 0;
      }
      log_Printf(LogWARN, "nat not enabled\n");
    }
  }
  return -1;
}
#endif /* #ifndef NONAT */

static int
LinkCommand(struct cmdargs const *arg)
{
  if (arg->argc > arg->argn+1) {
    char namelist[LINE_LEN];
    struct datalink *cx;
    char *name;
    int result = 0;

    if (!strcmp(arg->argv[arg->argn], "*")) {
      struct datalink *dl;

      cx = arg->bundle->links;
      while (cx) {
        /* Watch it, the command could be a ``remove'' */
        dl = cx->next;
        FindExec(arg->bundle, Commands, arg->argc, arg->argn+1, arg->argv,
                 arg->prompt, cx);
        for (cx = arg->bundle->links; cx; cx = cx->next)
          if (cx == dl)
            break;		/* Pointer's still valid ! */
      }
    } else {
      strncpy(namelist, arg->argv[arg->argn], sizeof namelist - 1);
      namelist[sizeof namelist - 1] = '\0';
      for(name = strtok(namelist, ", "); name; name = strtok(NULL,", "))
        if (!bundle2datalink(arg->bundle, name)) {
          log_Printf(LogWARN, "link: %s: Invalid link name\n", name);
          return 1;
        }

      strncpy(namelist, arg->argv[arg->argn], sizeof namelist - 1);
      namelist[sizeof namelist - 1] = '\0';
      for(name = strtok(namelist, ", "); name; name = strtok(NULL,", ")) {
        cx = bundle2datalink(arg->bundle, name);
        if (cx)
          FindExec(arg->bundle, Commands, arg->argc, arg->argn+1, arg->argv,
                   arg->prompt, cx);
        else {
          log_Printf(LogWARN, "link: %s: Invalidated link name !\n", name);
          result++;
        }
      }
    }
    return result;
  }

  log_Printf(LogWARN, "usage: %s\n", arg->cmd->syntax);
  return 2;
}

struct link *
command_ChooseLink(struct cmdargs const *arg)
{
  if (arg->cx)
    return &arg->cx->physical->link;
  else if (!arg->bundle->ncp.mp.cfg.mrru) {
    struct datalink *dl = bundle2datalink(arg->bundle, NULL);
    if (dl)
      return &dl->physical->link;
  }
  return &arg->bundle->ncp.mp.link;
}

static const char *
ident_cmd(const char *cmd, unsigned *keep, unsigned *add)
{
  const char *result;

  switch (*cmd) {
    case 'A':
    case 'a':
      result = "accept";
      *keep = NEG_MYMASK;
      *add = NEG_ACCEPTED;
      break;
    case 'D':
    case 'd':
      switch (cmd[1]) {
        case 'E':
        case 'e':
          result = "deny";
          *keep = NEG_MYMASK;
          *add = 0;
          break;
        case 'I':
        case 'i':
          result = "disable";
          *keep = NEG_HISMASK;
          *add = 0;
          break;
        default:
          return NULL;
      }
      break;
    case 'E':
    case 'e':
      result = "enable";
      *keep = NEG_HISMASK;
      *add = NEG_ENABLED;
      break;
    default:
      return NULL;
  }

  return result;
}

static int
OptSet(struct cmdargs const *arg)
{
  int opt = (int)(long)arg->cmd->args;
  unsigned keep;			/* Keep this opt */
  unsigned add;				/* Add this opt */

  if (ident_cmd(arg->argv[arg->argn - 2], &keep, &add) == NULL)
    return 1;

#ifndef NOINET6
  if (add == NEG_ENABLED && opt == OPT_IPV6CP && !probe.ipv6_available) {
    log_Printf(LogWARN, "IPv6 is not available on this machine\n");
    return 1;
  }
#endif
  if (!add && ((opt == OPT_NAS_IP_ADDRESS &&
                !Enabled(arg->bundle, OPT_NAS_IDENTIFIER)) ||
               (opt == OPT_NAS_IDENTIFIER &&
                !Enabled(arg->bundle, OPT_NAS_IP_ADDRESS)))) {
    log_Printf(LogWARN,
               "Cannot disable both NAS-IP-Address and NAS-Identifier\n");
    return 1;
  }

  if (add)
    opt_enable(arg->bundle, opt);
  else
    opt_disable(arg->bundle, opt);

  return 0;
}

static int
IfaceAliasOptSet(struct cmdargs const *arg)
{
  unsigned long long save = arg->bundle->cfg.optmask;
  int result = OptSet(arg);

  if (result == 0)
    if (Enabled(arg->bundle, OPT_IFACEALIAS) && !arg->bundle->NatEnabled) {
      arg->bundle->cfg.optmask = save;
      log_Printf(LogWARN, "Cannot enable iface-alias without NAT\n");
      result = 2;
    }

  return result;
}

static int
NegotiateSet(struct cmdargs const *arg)
{
  long param = (long)arg->cmd->args;
  struct link *l = command_ChooseLink(arg);	/* LOCAL_CX_OPT uses this */
  struct datalink *cx = arg->cx;	/* LOCAL_CX uses this */
  const char *cmd;
  unsigned keep;			/* Keep these bits */
  unsigned add;				/* Add these bits */

  if ((cmd = ident_cmd(arg->argv[arg->argn-2], &keep, &add)) == NULL)
    return 1;

  if ((arg->cmd->lauth & LOCAL_CX) && !cx) {
    log_Printf(LogWARN, "%s %s: No context (use the `link' command)\n",
              cmd, arg->cmd->name);
    return 2;
  } else if (cx && !(arg->cmd->lauth & (LOCAL_CX|LOCAL_CX_OPT))) {
    log_Printf(LogWARN, "%s %s: Redundant context (%s) ignored\n",
              cmd, arg->cmd->name, cx->name);
    cx = NULL;
  }

  switch (param) {
    case NEG_ACFCOMP:
      cx->physical->link.lcp.cfg.acfcomp &= keep;
      cx->physical->link.lcp.cfg.acfcomp |= add;
      break;
    case NEG_CHAP05:
      cx->physical->link.lcp.cfg.chap05 &= keep;
      cx->physical->link.lcp.cfg.chap05 |= add;
      break;
#ifndef NODES
    case NEG_CHAP80:
      cx->physical->link.lcp.cfg.chap80nt &= keep;
      cx->physical->link.lcp.cfg.chap80nt |= add;
      break;
    case NEG_CHAP80LM:
      cx->physical->link.lcp.cfg.chap80lm &= keep;
      cx->physical->link.lcp.cfg.chap80lm |= add;
      break;
    case NEG_CHAP81:
      cx->physical->link.lcp.cfg.chap81 &= keep;
      cx->physical->link.lcp.cfg.chap81 |= add;
      break;
    case NEG_MPPE:
      l->ccp.cfg.neg[CCP_NEG_MPPE] &= keep;
      l->ccp.cfg.neg[CCP_NEG_MPPE] |= add;
      break;
#endif
    case NEG_DEFLATE:
      l->ccp.cfg.neg[CCP_NEG_DEFLATE] &= keep;
      l->ccp.cfg.neg[CCP_NEG_DEFLATE] |= add;
      break;
    case NEG_DNS:
      arg->bundle->ncp.ipcp.cfg.ns.dns_neg &= keep;
      arg->bundle->ncp.ipcp.cfg.ns.dns_neg |= add;
      break;
    case NEG_ECHO:	/* probably misplaced in this function ! */
      if (cx->physical->link.lcp.cfg.echo && !add) {
        cx->physical->link.lcp.cfg.echo = 0;
        cx->physical->hdlc.lqm.method &= ~LQM_ECHO;
        if (cx->physical->hdlc.lqm.method & LQM_ECHO &&
            !cx->physical->link.lcp.want_lqrperiod && 
            cx->physical->hdlc.lqm.timer.load) {
          cx->physical->hdlc.lqm.timer.load = 0;
          lqr_StopTimer(cx->physical);
        }
      } else if (!cx->physical->link.lcp.cfg.echo && add) {
        cx->physical->link.lcp.cfg.echo = 1;
        cx->physical->hdlc.lqm.method |= LQM_ECHO;
        cx->physical->hdlc.lqm.timer.load =
	    cx->physical->link.lcp.cfg.lqrperiod * SECTICKS;
        if (cx->physical->link.lcp.fsm.state == ST_OPENED)
          (*cx->physical->hdlc.lqm.timer.func)(&cx->physical->link.lcp);
      }
      break;
    case NEG_ENDDISC:
      arg->bundle->ncp.mp.cfg.negenddisc &= keep;
      arg->bundle->ncp.mp.cfg.negenddisc |= add;
      break;
    case NEG_LQR:
      cx->physical->link.lcp.cfg.lqr &= keep;
      cx->physical->link.lcp.cfg.lqr |= add;
      break;
    case NEG_PAP:
      cx->physical->link.lcp.cfg.pap &= keep;
      cx->physical->link.lcp.cfg.pap |= add;
      break;
    case NEG_PPPDDEFLATE:
      l->ccp.cfg.neg[CCP_NEG_DEFLATE24] &= keep;
      l->ccp.cfg.neg[CCP_NEG_DEFLATE24] |= add;
      break;
    case NEG_PRED1:
      l->ccp.cfg.neg[CCP_NEG_PRED1] &= keep;
      l->ccp.cfg.neg[CCP_NEG_PRED1] |= add;
      break;
    case NEG_PROTOCOMP:
      cx->physical->link.lcp.cfg.protocomp &= keep;
      cx->physical->link.lcp.cfg.protocomp |= add;
      break;
    case NEG_SHORTSEQ:
      switch (bundle_Phase(arg->bundle)) {
        case PHASE_DEAD:
          break;
        case PHASE_ESTABLISH:
          /* Make sure none of our links are DATALINK_LCP or greater */
          if (bundle_HighestState(arg->bundle) >= DATALINK_LCP) {
            log_Printf(LogWARN, "shortseq: Only changable before"
                       " LCP negotiations\n");
            return 1;
          }
          break;
        default:
          log_Printf(LogWARN, "shortseq: Only changable at phase"
                     " DEAD/ESTABLISH\n");
          return 1;
      }
      arg->bundle->ncp.mp.cfg.shortseq &= keep;
      arg->bundle->ncp.mp.cfg.shortseq |= add;
      break;
    case NEG_VJCOMP:
      arg->bundle->ncp.ipcp.cfg.vj.neg &= keep;
      arg->bundle->ncp.ipcp.cfg.vj.neg |= add;
      break;
  }

  return 0;
}

static struct cmdtab const NegotiateCommands[] = {
  {"echo", NULL, NegotiateSet, LOCAL_AUTH | LOCAL_CX, "Send echo requests",
  "disable|enable", (const void *)NEG_ECHO},
  {"filter-decapsulation", NULL, OptSet, LOCAL_AUTH,
  "filter on PPPoUDP payloads", "disable|enable",
  (const void *)OPT_FILTERDECAP},
  {"force-scripts", NULL, OptSet, LOCAL_AUTH,
  "Force execution of the configured chat scripts", "disable|enable",
  (const void *)OPT_FORCE_SCRIPTS},
  {"idcheck", NULL, OptSet, LOCAL_AUTH, "Check FSM reply ids",
  "disable|enable", (const void *)OPT_IDCHECK},
  {"iface-alias", NULL, IfaceAliasOptSet, LOCAL_AUTH,
  "retain interface addresses", "disable|enable",
  (const void *)OPT_IFACEALIAS},
#ifndef NOINET6
  {"ipcp", NULL, OptSet, LOCAL_AUTH, "IP Network Control Protocol",
  "disable|enable", (const void *)OPT_IPCP},
  {"ipv6cp", NULL, OptSet, LOCAL_AUTH, "IPv6 Network Control Protocol",
  "disable|enable", (const void *)OPT_IPV6CP},
#endif
  {"keep-session", NULL, OptSet, LOCAL_AUTH, "Retain device session leader",
  "disable|enable", (const void *)OPT_KEEPSESSION},
  {"loopback", NULL, OptSet, LOCAL_AUTH, "Loop packets for local iface",
  "disable|enable", (const void *)OPT_LOOPBACK},
  {"nas-ip-address", NULL, OptSet, LOCAL_AUTH, "Send NAS-IP-Address to RADIUS",
  "disable|enable", (const void *)OPT_NAS_IP_ADDRESS},
  {"nas-identifier", NULL, OptSet, LOCAL_AUTH, "Send NAS-Identifier to RADIUS",
  "disable|enable", (const void *)OPT_NAS_IDENTIFIER},
  {"passwdauth", NULL, OptSet, LOCAL_AUTH, "Use passwd file",
  "disable|enable", (const void *)OPT_PASSWDAUTH},
  {"proxy", NULL, OptSet, LOCAL_AUTH, "Create a proxy ARP entry",
  "disable|enable", (const void *)OPT_PROXY},
  {"proxyall", NULL, OptSet, LOCAL_AUTH, "Proxy ARP for all remote hosts",
  "disable|enable", (const void *)OPT_PROXYALL},
  {"sroutes", NULL, OptSet, LOCAL_AUTH, "Use sticky routes",
  "disable|enable", (const void *)OPT_SROUTES},
  {"tcpmssfixup", "mssfixup", OptSet, LOCAL_AUTH, "Modify MSS options",
  "disable|enable", (const void *)OPT_TCPMSSFIXUP},
  {"throughput", NULL, OptSet, LOCAL_AUTH, "Rolling throughput",
  "disable|enable", (const void *)OPT_THROUGHPUT},
  {"utmp", NULL, OptSet, LOCAL_AUTH, "Log connections in utmp",
  "disable|enable", (const void *)OPT_UTMP},

#ifndef NOINET6
#define NEG_OPT_MAX 17	/* accept/deny allowed below and not above */
#else
#define NEG_OPT_MAX 15
#endif

  {"acfcomp", NULL, NegotiateSet, LOCAL_AUTH | LOCAL_CX,
  "Address & Control field compression", "accept|deny|disable|enable",
  (const void *)NEG_ACFCOMP},
  {"chap", "chap05", NegotiateSet, LOCAL_AUTH | LOCAL_CX,
  "Challenge Handshake Authentication Protocol", "accept|deny|disable|enable",
  (const void *)NEG_CHAP05},
#ifndef NODES
  {"mschap", "chap80nt", NegotiateSet, LOCAL_AUTH | LOCAL_CX,
  "Microsoft (NT) CHAP", "accept|deny|disable|enable",
  (const void *)NEG_CHAP80},
  {"LANMan", "chap80lm", NegotiateSet, LOCAL_AUTH | LOCAL_CX,
  "Microsoft (NT) CHAP", "accept|deny|disable|enable",
  (const void *)NEG_CHAP80LM},
  {"mschapv2", "chap81", NegotiateSet, LOCAL_AUTH | LOCAL_CX,
  "Microsoft CHAP v2", "accept|deny|disable|enable",
  (const void *)NEG_CHAP81},
  {"mppe", NULL, NegotiateSet, LOCAL_AUTH | LOCAL_CX_OPT,
  "MPPE encryption", "accept|deny|disable|enable",
  (const void *)NEG_MPPE},
#endif
  {"deflate", NULL, NegotiateSet, LOCAL_AUTH | LOCAL_CX_OPT,
  "Deflate compression", "accept|deny|disable|enable",
  (const void *)NEG_DEFLATE},
  {"deflate24", NULL, NegotiateSet, LOCAL_AUTH | LOCAL_CX_OPT,
  "Deflate (type 24) compression", "accept|deny|disable|enable",
  (const void *)NEG_PPPDDEFLATE},
  {"dns", NULL, NegotiateSet, LOCAL_AUTH,
  "DNS specification", "accept|deny|disable|enable", (const void *)NEG_DNS},
  {"enddisc", NULL, NegotiateSet, LOCAL_AUTH, "ENDDISC negotiation",
  "accept|deny|disable|enable", (const void *)NEG_ENDDISC},
  {"lqr", NULL, NegotiateSet, LOCAL_AUTH | LOCAL_CX,
  "Link Quality Reports", "accept|deny|disable|enable",
  (const void *)NEG_LQR},
  {"pap", NULL, NegotiateSet, LOCAL_AUTH | LOCAL_CX,
  "Password Authentication protocol", "accept|deny|disable|enable",
  (const void *)NEG_PAP},
  {"pred1", "predictor1", NegotiateSet, LOCAL_AUTH | LOCAL_CX_OPT,
  "Predictor 1 compression", "accept|deny|disable|enable",
  (const void *)NEG_PRED1},
  {"protocomp", NULL, NegotiateSet, LOCAL_AUTH | LOCAL_CX,
  "Protocol field compression", "accept|deny|disable|enable",
  (const void *)NEG_PROTOCOMP},
  {"shortseq", NULL, NegotiateSet, LOCAL_AUTH,
  "MP Short Sequence Numbers", "accept|deny|disable|enable",
  (const void *)NEG_SHORTSEQ},
  {"vjcomp", NULL, NegotiateSet, LOCAL_AUTH,
  "Van Jacobson header compression", "accept|deny|disable|enable",
  (const void *)NEG_VJCOMP},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
  "Display this message", "accept|deny|disable|enable help|? [value]",
  NegotiateCommands},
  {NULL, NULL, NULL},
};

static int
NegotiateCommand(struct cmdargs const *arg)
{
  if (arg->argc > arg->argn) {
    char const *argv[3];
    unsigned keep, add;
    int n;

    if ((argv[0] = ident_cmd(arg->argv[arg->argn-1], &keep, &add)) == NULL)
      return -1;
    argv[2] = NULL;

    for (n = arg->argn; n < arg->argc; n++) {
      argv[1] = arg->argv[n];
      FindExec(arg->bundle, NegotiateCommands + (keep == NEG_HISMASK ?
               0 : NEG_OPT_MAX), 2, 1, argv, arg->prompt, arg->cx);
    }
  } else if (arg->prompt)
    prompt_Printf(arg->prompt, "Use `%s ?' to get a list.\n",
	    arg->argv[arg->argn-1]);
  else
    log_Printf(LogWARN, "%s command must have arguments\n",
              arg->argv[arg->argn] );

  return 0;
}

const char *
command_ShowNegval(unsigned val)
{
  switch (val&3) {
    case 1: return "disabled & accepted";
    case 2: return "enabled & denied";
    case 3: return "enabled & accepted";
  }
  return "disabled & denied";
}

static int
ClearCommand(struct cmdargs const *arg)
{
  struct pppThroughput *t;
  struct datalink *cx;
  int i, clear_type;

  if (arg->argc < arg->argn + 1)
    return -1;

  if (strcasecmp(arg->argv[arg->argn], "physical") == 0) {
    cx = arg->cx;
    if (!cx)
      cx = bundle2datalink(arg->bundle, NULL);
    if (!cx) {
      log_Printf(LogWARN, "A link must be specified for ``clear physical''\n");
      return 1;
    }
    t = &cx->physical->link.stats.total;
  } else if (strcasecmp(arg->argv[arg->argn], "ipcp") == 0)
    t = &arg->bundle->ncp.ipcp.throughput;
#ifndef NOINET6
  else if (strcasecmp(arg->argv[arg->argn], "ipv6cp") == 0)
    t = &arg->bundle->ncp.ipv6cp.throughput;
#endif
  else
    return -1;

  if (arg->argc > arg->argn + 1) {
    clear_type = 0;
    for (i = arg->argn + 1; i < arg->argc; i++)
      if (strcasecmp(arg->argv[i], "overall") == 0)
        clear_type |= THROUGHPUT_OVERALL;
      else if (strcasecmp(arg->argv[i], "current") == 0)
        clear_type |= THROUGHPUT_CURRENT;
      else if (strcasecmp(arg->argv[i], "peak") == 0)
        clear_type |= THROUGHPUT_PEAK;
      else
        return -1;
  } else
    clear_type = THROUGHPUT_ALL;

  throughput_clear(t, clear_type, arg->prompt);
  return 0;
}

static int
RunListCommand(struct cmdargs const *arg)
{
  const char *cmd = arg->argc ? arg->argv[arg->argc - 1] : "???";

#ifndef NONAT
  if (arg->cmd->args == NatCommands &&
      tolower((unsigned char)*arg->argv[arg->argn - 1]) == 'a') {
    if (arg->prompt)
      prompt_Printf(arg->prompt, "The alias command is deprecated\n");
    else
      log_Printf(LogWARN, "The alias command is deprecated\n");
  }
#endif

  if (arg->argc > arg->argn)
    FindExec(arg->bundle, arg->cmd->args, arg->argc, arg->argn, arg->argv,
             arg->prompt, arg->cx);
  else if (arg->prompt)
    prompt_Printf(arg->prompt, "Use `%s help' to get a list or `%s help"
                  " <option>' for syntax help.\n", cmd, cmd);
  else
    log_Printf(LogWARN, "%s command must have arguments\n", cmd);

  return 0;
}

static int
IfaceAddCommand(struct cmdargs const *arg)
{
  struct ncpaddr peer, addr;
  struct ncprange ifa;
  struct in_addr mask;
  int n, how;

  if (arg->argc == arg->argn + 1) {
    if (!ncprange_aton(&ifa, NULL, arg->argv[arg->argn]))
      return -1;
    ncpaddr_init(&peer);
  } else {
    if (arg->argc == arg->argn + 2) {
      if (!ncprange_aton(&ifa, NULL, arg->argv[arg->argn]))
        return -1;
      n = 1;
    } else if (arg->argc == arg->argn + 3) {
      if (!ncpaddr_aton(&addr, NULL, arg->argv[arg->argn]))
        return -1;
      if (ncpaddr_family(&addr) != AF_INET)
        return -1;
      ncprange_sethost(&ifa, &addr);
      if (!ncpaddr_aton(&addr, NULL, arg->argv[arg->argn + 1]))
        return -1;
      if (!ncpaddr_getip4(&addr, &mask))
        return -1;
      if (!ncprange_setip4mask(&ifa, mask))
        return -1;
      n = 2;
    } else
      return -1;

    if (!ncpaddr_aton(&peer, NULL, arg->argv[arg->argn + n]))
      return -1;

    if (ncprange_family(&ifa) != ncpaddr_family(&peer)) {
      log_Printf(LogWARN, "IfaceAddCommand: src and dst address families"
                 " differ\n");
      return -1;
    }
  }

  how = IFACE_ADD_LAST;
  if (arg->cmd->args)
    how |= IFACE_FORCE_ADD;

  return !iface_Add(arg->bundle->iface, &arg->bundle->ncp, &ifa, &peer, how);
}

static int
IfaceDeleteCommand(struct cmdargs const *arg)
{
  struct ncpaddr ifa;
  struct in_addr ifa4;
  int ok;

  if (arg->argc != arg->argn + 1)
    return -1;

  if (!ncpaddr_aton(&ifa, NULL, arg->argv[arg->argn]))
    return -1;

  if (arg->bundle->ncp.ipcp.fsm.state == ST_OPENED &&
      ncpaddr_getip4(&ifa, &ifa4) &&
      arg->bundle->ncp.ipcp.my_ip.s_addr == ifa4.s_addr) {
    log_Printf(LogWARN, "%s: Cannot remove active interface address\n",
               ncpaddr_ntoa(&ifa));
    return 1;
  }

  ok = iface_Delete(arg->bundle->iface, &arg->bundle->ncp, &ifa);
  if (!ok) {
    if (arg->cmd->args)
      ok = 1;
    else if (arg->prompt)
      prompt_Printf(arg->prompt, "%s: No such interface address\n",
                    ncpaddr_ntoa(&ifa));
    else
      log_Printf(LogWARN, "%s: No such interface address\n",
                 ncpaddr_ntoa(&ifa));
  }

  return !ok;
}

static int
IfaceClearCommand(struct cmdargs const *arg)
{
  int family, how;

  family = 0;
  if (arg->argc == arg->argn + 1) {
    if (strcasecmp(arg->argv[arg->argn], "inet") == 0)
      family = AF_INET;
#ifndef NOINET6
    else if (strcasecmp(arg->argv[arg->argn], "inet6") == 0)
      family = AF_INET6;
#endif
    else
      return -1;
  } else if (arg->argc != arg->argn)
    return -1;

  how = arg->bundle->ncp.ipcp.fsm.state == ST_OPENED ||
        arg->bundle->phys_type.all & PHYS_AUTO ?
        IFACE_CLEAR_ALIASES : IFACE_CLEAR_ALL;
  iface_Clear(arg->bundle->iface, &arg->bundle->ncp, family, how);

  return 0;
}

static int
SetProcTitle(struct cmdargs const *arg)
{
  static char title[LINE_LEN];
  char *argv[MAXARGS];
  int argc = arg->argc - arg->argn;

  if (arg->argc == arg->argn) {
    SetTitle(NULL);
    return 0;
  }

  if (argc >= sizeof argv / sizeof argv[0]) {
    argc = sizeof argv / sizeof argv[0] - 1;
    log_Printf(LogWARN, "Truncating proc title to %d args\n", argc);
  }
  command_Expand(argv, argc, arg->argv + arg->argn, arg->bundle, 1, getpid());
  Concatinate(title, sizeof title, argc, (const char *const *)argv);
  SetTitle(title);
  command_Free(argc, argv);

  return 0;
}
@


1.94
log
@fairly obvious ctype cleanup dealing with argv
ok jca
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.93 2013/04/29 00:28:23 okan Exp $
@


1.93
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.92 2008/03/02 18:46:32 miod Exp $
d3113 1
a3113 1
      tolower(*arg->argv[arg->argn - 1]) == 'a') {
@


1.92
log
@Pass a buffer size to InterpretArg() and do not let it overflow it, saves
propolice some work in command_Expand_Interpret().

Inspired by FreeBSD; ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.91 2005/09/21 16:28:47 brad Exp $
d666 1
a666 1
      fcntl(i, F_SETFD, 1);
@


1.91
log
@Support a ``set rad_alive N'' command to enable periodic RADIUS accounting
information being sent to the RADIUS server.

Logging of RADIUS accounting information moves to a ``set log [+-]radius''
level, along with the RADIUS alive info.

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.90 2005/09/21 15:04:28 brad Exp $
d1133 4
a1136 1
  InterpretArg(buff, buff2);
@


1.91.6.1
log
@MFC (miod):
Pass a buffer size to InterpretArg() and do not let it overflow it, saves
propolice some work in command_Expand_Interpret().
Inspired by FreeBSD; ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.92 2008/03/02 18:46:32 miod Exp $
d1133 1
a1133 4
  if (InterpretArg(buff, buff2, sizeof buff2) == NULL) {
    log_Printf(LogWARN, "Failed to expand command '%s': too long for the destination buffer\n", buff);
    return -1;
  }
@


1.91.8.1
log
@MFC (miod):
Pass a buffer size to InterpretArg() and do not let it overflow it, saves
propolice some work in command_Expand_Interpret().
Inspired by FreeBSD; ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.92 2008/03/02 18:46:32 miod Exp $
d1133 1
a1133 4
  if (InterpretArg(buff, buff2, sizeof buff2) == NULL) {
    log_Printf(LogWARN, "Failed to expand command '%s': too long for the destination buffer\n", buff);
    return -1;
  }
@


1.90
log
@Send NAS-IP-Address as well as NAS-Identifier
Add ``disable NAS-IP-Address'' and ``disable NAS-Identifier'' options to
support pre-rfc2865 RADIUS servers.
This pushes our enable/disable items over the 32 bit limit, so reoganise
things to allow a bunch more options.

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.89 2005/09/21 01:59:26 brad Exp $
d145 1
d2032 23
d2370 1
a2370 1
  "id0|ipcp|lcp|lqm|phase|physical|sync|tcp/ip|timer|tun..."},
d2400 3
@


1.89
log
@IPV6PREFIX is set when Framed-IPv6-Prefix is defined,  You may
want to pass the value to upper layer protocol such as DHCPv6
for prefix delegation.

From ume FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.88 2005/07/26 01:32:25 brad Exp $
d2568 1
a2568 1
      arg->bundle->cfg.opt &= ~OPT_IFACEALIAS;
d2713 3
a2715 3
  int bit = (int)(long)arg->cmd->args;
  unsigned keep;			/* Keep these bits */
  unsigned add;				/* Add these bits */
d2721 1
a2721 1
  if (add == NEG_ENABLED && bit == OPT_IPV6CP && !probe.ipv6_available) {
d2726 8
d2736 1
a2736 1
    arg->bundle->cfg.opt |= bit;
d2738 1
a2738 1
    arg->bundle->cfg.opt &= ~bit;
d2746 1
a2746 1
  unsigned save = arg->bundle->cfg.opt;
d2751 1
a2751 1
      arg->bundle->cfg.opt = save;
d2913 4
d2933 1
a2933 1
#define OPT_MAX 15	/* accept/deny allowed below and not above */
d2935 1
a2935 1
#define OPT_MAX 13
d3007 1
a3007 1
               0 : OPT_MAX), 2, 1, argv, arg->prompt, arg->cx);
@


1.88
log
@Add Cisco Skinny Station Protocol translation support to libalias
and supporting applications (ppp).

From marcus FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.87 2005/07/18 22:51:03 brad Exp $
d496 16
d579 4
@


1.87
log
@Add a ``force-scripts'' option for using chat scripts with -direct and
-dedicated links.

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.86 2005/07/17 19:13:24 brad Exp $
d757 2
@


1.86
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.85 2005/07/17 07:33:22 brad Exp $
d2865 3
d2899 1
a2899 1
#define OPT_MAX 14	/* accept/deny allowed below and not above */
d2901 1
a2901 1
#define OPT_MAX 12
@


1.85
log
@Implement an ``enable/disable echo'' option, defaults to off.
This allows LCP ECHOs to be enabled independently of LQR reports.

Note: This introduces a change in the default behaviour (search for lqr and
echo in the man page).

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.84 2005/07/12 03:08:12 brad Exp $
d45 1
@


1.84
log
@rev 1.305

Use the correct length when copying trailing data!!

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.83 2005/07/12 03:01:12 brad Exp $
d156 11
a166 10
#define NEG_ENDDISC	46
#define NEG_LQR		47
#define NEG_PAP		48
#define NEG_PPPDDEFLATE	49
#define NEG_PRED1	50
#define NEG_PROTOCOMP	51
#define NEG_SHORTSEQ	52
#define NEG_VJCOMP	53
#define NEG_MPPE	54
#define NEG_CHAP81	55
d168 1
a168 1
const char Version[] = "3.1";
d2328 2
a2329 2
  {"lqrperiod", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX_OPT,
  "LQR period", "set lqrperiod value", (const void *)VAR_LQRPERIOD},
d2786 19
d2859 2
d2895 1
a2895 1
#define OPT_MAX 13	/* accept/deny allowed below and not above */
d2897 1
a2897 1
#define OPT_MAX 11
@


1.83
log
@rev 1.298

Fix ``set ifaddr''.  The code was actually using an uninitialised variable,
but conveniently, because ncpaddr.ncpaddr_family != AF_INET, the call to
ncpaddr_getip4addr() became a no-op leaving the local address as it was
(defaulting to whatever my hostname resolves to).

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.82 2005/07/12 01:28:10 brad Exp $
d454 1
a454 1
      bcopy(word + loldstr, word + lnewstr, ltgt - pos - loldstr);
@


1.82
log
@- support ipv6cpretry and ipv6cpretries, which are IPv6 versions
  of ipcpretry and ipcpretries.
- improve handling of IPv6 link-local addresses

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.81 2005/07/11 22:34:56 brad Exp $
d1558 1
a1559 1
  ncprange_getaddr(&ncp->ipcp.cfg.my_range, &ncpaddr);
d2049 1
d2056 1
@


1.81
log
@Don't install wrong IPv6 route by add command.

From ume FreeBSD

ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.80 2005/02/17 03:00:12 mbalmer Exp $
d143 1
d2049 7
d2314 2
@


1.80
log
@zap compilation date from binary, ok deraadt@@, ian@@
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.79 2004/01/23 03:48:43 deraadt Exp $
d2387 3
d2447 3
a2449 1
    ncpaddr_copy(&gw, &arg->bundle->ncp.ipv6cp.hisaddr);
@


1.79
log
@Use closefrom(); ok millert tedu
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.78 2003/04/04 20:28:57 deraadt Exp $
a526 1
    nargv[arg] = subst(nargv[arg], "COMPILATIONDATE", __DATE__);
d930 1
a930 1
  prompt_Printf(arg->prompt, "PPP Version %s - %s\n", Version, __DATE__);
@


1.78
log
@strlcat; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.77 2002/06/15 08:02:00 brian Exp $
d641 1
@


1.77
log
@Tidy up end of line whitespace
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.76 2002/06/15 01:33:23 brian Exp $
d1163 1
a1163 1
        strcat(buf, ": ");
@


1.76
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.75 2002/05/27 23:19:38 brian Exp $
d317 1
a317 1
  log_Printf(LogWARN, "%s -> %s: target name already exists\n", 
d530 1
a530 1
    nargv[arg] = subst(nargv[arg], "ENDDISC", 
d541 1
a541 1
    nargv[arg] = substull(nargv[arg], "IPOCTETSOUT", 
d543 1
a543 1
    nargv[arg] = substull(nargv[arg], "IPPACKETSIN", 
d545 1
a545 1
    nargv[arg] = substull(nargv[arg], "IPPACKETSOUT", 
d548 1
a548 1
    nargv[arg] = substull(nargv[arg], "IPV6OCTETSIN", 
d550 1
a550 1
    nargv[arg] = substull(nargv[arg], "IPV6OCTETSOUT", 
d552 1
a552 1
    nargv[arg] = substull(nargv[arg], "IPV6PACKETSIN", 
d554 1
a554 1
    nargv[arg] = substull(nargv[arg], "IPV6PACKETSOUT", 
d1664 1
a1664 1
      int v1, v2, v3; 
d2261 1
a2261 1
  "CBCP control", "set cbcp [*|phone[,phone...] [delay [timeout]]]", 
d2280 1
a2280 1
  "MPPE key size and state", "set mppe [40|56|128|* [stateful|stateless|*]]", 
d2992 1
a2992 1
  } else 
@


1.75
log
@Coerce pid_t to long rather than int for better portability; theo
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.74 2002/05/17 22:15:56 brian Exp $
d166 1
a166 1
const char Version[] = "3.0.5";
@


1.74
log
@Bump the version number to reflect the latest MS-CHAP2 changes
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.73 2002/05/16 01:13:39 brian Exp $
d467 1
a467 1
substint(char *tgt, const char *oldstr, int i)
d469 1
a469 1
  char buf[12];
d471 1
a471 1
  snprintf(buf, sizeof buf, "%d", i);
d570 1
a570 1
    nargv[arg] = substint(nargv[arg], "PROCESSID", pid);
d572 1
a572 1
      nargv[arg] = substint(nargv[arg], "SOCKNAME", server.cfg.port);
d662 1
a662 1
	  log_Printf(LogERROR, "%d: daemon: %s\n", (int)p, strerror(errno));
d681 1
a681 1
  if (shpid == (pid_t) - 1)
@


1.73
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.72 2002/03/31 02:38:49 brian Exp $
d166 1
a166 1
const char Version[] = "3.0.4";
@


1.72
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.71 2001/11/23 11:17:03 brian Exp $
a73 1
#include "ip.h"
d166 1
a166 1
const char Version[] = "3.0.1";
d460 35
d500 2
a501 2
  char buf[20];
  char pidstr[12];
d509 15
a523 1
  snprintf(pidstr, sizeof pidstr, "%d", (int)pid);
d526 9
a534 2
    nargv[arg] = subst(nargv[arg], "HISADDR",
                       inet_ntoa(bundle->ncp.ipcp.peer_ip));
d536 1
a536 2
    nargv[arg] = subst(nargv[arg], "HISADDR6",
                       ncpaddr_ntoa(&bundle->ncp.ipv6cp.hisaddr));
a537 1
    nargv[arg] = subst(nargv[arg], "AUTHNAME", bundle->cfg.auth.name);
d539 8
a546 1
    nargv[arg] = subst(nargv[arg], "MYADDR", inet_ntoa(bundle->ncp.ipcp.my_ip));
d548 8
a555 2
    nargv[arg] = subst(nargv[arg], "MYADDR6",
                       ncpaddr_ntoa(&bundle->ncp.ipv6cp.myaddr));
d557 9
a565 1
    nargv[arg] = subst(nargv[arg], "USER", bundle->ncp.mp.peer.authname);
d570 7
a576 10
    nargv[arg] = subst(nargv[arg], "ENDDISC", 
                       mp_Enddisc(bundle->ncp.mp.cfg.enddisc.class,
                                  bundle->ncp.mp.cfg.enddisc.address,
                                  bundle->ncp.mp.cfg.enddisc.len));
    nargv[arg] = subst(nargv[arg], "PROCESSID", pidstr);
    nargv[arg] = subst(nargv[arg], "LABEL", bundle_GetLabel(bundle));
    nargv[arg] = subst(nargv[arg], "DNS0",
                       inet_ntoa(bundle->ncp.ipcp.ns.dns[0]));
    nargv[arg] = subst(nargv[arg], "DNS1",
                       inet_ntoa(bundle->ncp.ipcp.ns.dns[1]));
a577 6
    nargv[arg] = subst(nargv[arg], "COMPILATIONDATE", __DATE__);

    secs = bundle_Uptime(bundle);
    snprintf(buf, sizeof buf, "%d:%02d:%02d", secs / 3600, (secs / 60) % 60,
             secs % 60);
    nargv[arg] = subst(nargv[arg], "UPTIME", buf);
d1094 1
a1094 1
    log_Printf(LogWARN, "Usage: %s\n", cmd->syntax);
d2321 1
a2321 1
  {"mru", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX_OPT,
d2608 1
a2608 1
  log_Printf(LogWARN, "Usage: %s\n", arg->cmd->syntax);
@


1.71
log
@cmott@@scientech.com -> cm@@linktel.net
Add the UPTIME variable
CCP protocol ``0xffffffff'' -> ``none''
Don't leak memory when expanding command arguments and not exec()ing
Make some functions static
Add the ``log'' command for manual logging
Fix some log text bogons
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.70 2001/10/24 10:01:12 brian Exp $
d1676 1
a1676 1
#ifdef HAVE_DES
d2213 1
a2213 1
#ifdef HAVE_DES
d2677 1
a2677 1
#ifdef HAVE_DES
d2802 1
a2802 1
#ifdef HAVE_DES
@


1.70
log
@Handle ``set reconnect 0 0'' properly in -ddial mode.
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.69 2001/08/21 04:09:18 brian Exp $
d258 3
a260 16
  int f, max, n, pos;

  *arg->cx->physical->link.lcp.cfg.ident = '\0';
  max = sizeof arg->cx->physical->link.lcp.cfg.ident;

  for (pos = 0, f = arg->argn; f < arg->argc && pos < max; f++) {
    n = snprintf(arg->cx->physical->link.lcp.cfg.ident + pos, max - pos,
                 "%s%s", f == arg->argn ? "" : " ", arg->argv[f]);
    if (n < 0) {
      arg->cx->physical->link.lcp.cfg.ident[pos] = '\0';
      break;
    }
    if ((pos += n) >= max)
      break;
  }

d323 1
a323 1
int
d355 24
a378 1
int
d381 1
a381 1
  log_Printf(LogWARN, "save command is not implemented (yet).\n");
d465 2
a466 1
  int arg;
d508 5
d517 10
d779 2
d3077 2
a3078 2
  char *argv[MAXARGS], *ptr;
  int len, remaining, f, argc = arg->argc - arg->argn;
d3090 1
a3090 17

  ptr = title;
  remaining = sizeof title - 1;
  for (f = 0; f < argc && remaining; f++) {
    if (f) {
      *ptr++ = ' ';
      remaining--;
    }
    len = strlen(argv[f]);
    if (len > remaining)
      len = remaining;
    memcpy(ptr, argv[f], len);
    remaining -= len;
    ptr += len;
  }
  *ptr = '\0';

d3092 1
@


1.69
log
@Handle snprintf() returning < -1
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.68 2001/08/19 23:22:17 brian Exp $
d167 1
a167 1
const char Version[] = "3.0.0";
@


1.68
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.67 2001/08/18 19:41:09 brian Exp $
d266 5
a270 1
    if (n == -1 || (pos += n) >= max)
@


1.67
log
@A better fix
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.66 2001/08/18 19:34:33 brian Exp $
d73 2
d93 2
d104 1
d167 1
a167 1
const char Version[] = "2.3.2";
d465 4
d472 4
d655 4
d695 1
a695 1
   "Clear iface address(es)", "iface clear"},
d722 1
a722 1
  "clear ipcp|physical [current|overall|peak]..."},
d864 4
d880 2
d1429 2
a1430 1
  struct ipcp *ipcp = &arg->bundle->ncp.ipcp;
d1437 5
a1441 5
  memset(&ipcp->cfg.my_range, '\0', sizeof ipcp->cfg.my_range);
  memset(&ipcp->cfg.peer_range, '\0', sizeof ipcp->cfg.peer_range);
  ipcp->cfg.HaveTriggerAddress = 0;
  ipcp->cfg.netmask.s_addr = INADDR_ANY;
  iplist_reset(&ipcp->cfg.peer_list);
d1444 1
a1444 3
    if (!ParseAddr(ipcp, arg->argv[arg->argn],
                   &ipcp->cfg.my_range.ipaddr, &ipcp->cfg.my_range.mask,
                   &ipcp->cfg.my_range.width))
d1449 2
a1450 1
        ipcp->ifmask = ipcp->cfg.netmask = GetIpAddr(arg->argv[arg->argn+2]);
d1452 2
a1453 2
	  ipcp->cfg.TriggerAddress = GetIpAddr(arg->argv[arg->argn+3]);
	  ipcp->cfg.HaveTriggerAddress = 1;
d1460 5
a1464 6
  if (ipcp->cfg.my_range.ipaddr.s_addr == INADDR_ANY) {
    ipcp->cfg.my_range.mask.s_addr = INADDR_ANY;
    ipcp->cfg.my_range.width = 0;
  }
  ipcp->my_ip.s_addr = ipcp->cfg.my_range.ipaddr.s_addr;
  bundle_AdjustFilters(arg->bundle, &ipcp->my_ip, NULL);
d1518 1
a1518 1
  int mode, dummyint, f, first;
a1521 1
  const char *err = NULL;
d1523 2
a1524 1
  struct in_addr dummyaddr, *addr;
d1531 2
d1574 2
a1575 1
        return 1;
d1582 2
a1583 1
        return 1;
d1595 2
a1596 1
        return 1;
d1604 2
a1605 2
      err = "Set autoload requires three arguments\n";
      log_Printf(LogWARN, err);
d1639 2
a1640 2
      err = "No window size specified\n";
      log_Printf(LogWARN, err);
d1646 4
a1649 2
    if (arg->argc > arg->argn + 2)
      return -1;
d1664 2
a1665 1
        return -1;
d1679 2
a1680 1
        return -1;
d1700 2
a1701 2
      err = "No accmap specified\n";
      log_Printf(LogWARN, err);
d1709 2
a1710 1
      return -1;
d1723 2
a1724 1
          return 1;
d1729 2
a1730 1
        return 1;
d1732 2
d1737 2
a1738 1
      return 1;
d1741 2
a1742 1
      return 1;
d1752 5
a1756 2
      if (argp[strspn(argp, "0123456789")] != '\0')
        return -1;
d1763 2
a1764 1
        return 1;
d1768 4
a1771 2
      if (strcasecmp(argp, "max") && strcasecmp(argp, "maximum"))
        return -1;
d1777 2
a1778 1
        return 1;
d1782 2
a1783 1
      return -1;
d1785 2
d1792 2
a1793 1
      return 1;
d1796 2
a1797 1
      return 1;
d1809 5
a1813 2
      if (argp[strspn(argp, "0123456789")] != '\0')
        return -1;
d1820 2
a1821 1
        return 1;
d1825 4
a1828 2
      if (strcasecmp(argp, "max") && strcasecmp(argp, "maximum"))
        return -1;
d1834 2
a1835 1
        return 1;
d1839 2
a1840 1
      return -1;
d1843 3
d1848 2
a1849 1
      return 1;
d1852 2
a1853 1
      return 1;
d1867 2
a1868 2
      err = "%s: Invalid openmode\n";
      log_Printf(LogWARN, err, argp);
d1894 7
a1900 5
    if (arg->argc > arg->argn+2)
      err = "Too many idle timeout values\n";
    else if (arg->argc == arg->argn)
      err = "Too few idle timeout values\n";
    else {
a1906 2
    if (err)
      log_Printf(LogWARN, err);
d1914 1
a1914 1
      return 1;
d1920 4
a1923 4
    return SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                    &cx->physical->link.lcp.cfg.fsm.timeout,
                    &cx->physical->link.lcp.cfg.fsm.maxreq,
                    &cx->physical->link.lcp.cfg.fsm.maxtrm, DEF_FSMTRIES);
d1927 3
a1929 3
    return SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                    &cx->chap.auth.cfg.fsm.timeout,
                    &cx->chap.auth.cfg.fsm.maxreq, NULL, DEF_FSMAUTHTRIES);
d1933 3
a1935 3
    return SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                    &cx->pap.cfg.fsm.timeout, &cx->pap.cfg.fsm.maxreq,
                    NULL, DEF_FSMAUTHTRIES);
d1939 3
a1941 3
    return SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                    &l->ccp.cfg.fsm.timeout, &l->ccp.cfg.fsm.maxreq,
                    &l->ccp.cfg.fsm.maxtrm, DEF_FSMTRIES);
d1945 4
a1948 4
    return SetRetry(arg->argc - arg->argn, arg->argv + arg->argn,
                    &arg->bundle->ncp.ipcp.cfg.fsm.timeout,
                    &arg->bundle->ncp.ipcp.cfg.fsm.maxreq,
                    &arg->bundle->ncp.ipcp.cfg.fsm.maxtrm, DEF_FSMTRIES);
d1954 2
a1955 2
      addr = arg->bundle->ncp.ipcp.cfg.ns.dns;
      addr[0].s_addr = addr[1].s_addr = INADDR_NONE;
d1957 2
a1958 2
      addr = arg->bundle->ncp.ipcp.cfg.ns.nbns;
      addr[0].s_addr = addr[1].s_addr = INADDR_ANY;
d1962 8
a1969 5
      ParseAddr(&arg->bundle->ncp.ipcp, arg->argv[arg->argn],
                addr, &dummyaddr, &dummyint);
      if (arg->argc > arg->argn+1)
        ParseAddr(&arg->bundle->ncp.ipcp, arg->argv[arg->argn + 1],
                  addr + 1, &dummyaddr, &dummyint);
d1971 7
a1977 7
      if (addr[0].s_addr == INADDR_ANY) {
        addr[0].s_addr = addr[1].s_addr;
        addr[1].s_addr = INADDR_ANY;
      }
      if (addr[0].s_addr == INADDR_NONE) {
        addr[0].s_addr = addr[1].s_addr;
        addr[1].s_addr = INADDR_NONE;
d2000 4
a2003 2
      else
        return -1;
d2039 1
a2039 1
    arg->bundle->ncp.ipcp.cfg.sendpipe = long_val;
d2044 1
a2044 1
    arg->bundle->ncp.ipcp.cfg.recvpipe = long_val;
d2053 2
a2054 1
      return 1;
d2083 1
a2083 1
      return physical_SetParity(arg->cx->physical, argp);
d2085 2
a2086 2
      err = "Parity value must be odd, even or none\n";
      log_Printf(LogWARN, err);
d2096 2
a2097 2
      err = "RTS/CTS value must be on or off\n";
      log_Printf(LogWARN, err);
d2103 3
a2105 3
      ipcp_SetUrgentTOS(&arg->bundle->ncp.ipcp);
      ipcp_ClearUrgentTcpPorts(&arg->bundle->ncp.ipcp);
      ipcp_ClearUrgentUdpPorts(&arg->bundle->ncp.ipcp);
d2107 1
a2107 1
      ipcp_SetUrgentTOS(&arg->bundle->ncp.ipcp);
d2109 1
a2109 1
        ipcp_ClearUrgentUdpPorts(&arg->bundle->ncp.ipcp);
d2112 1
a2112 1
          ipcp_AddUrgentUdpPort(&arg->bundle->ncp.ipcp, atoi(arg->argv[f] + 1));
d2114 1
a2114 2
          ipcp_RemoveUrgentUdpPort(&arg->bundle->ncp.ipcp,
                                   atoi(arg->argv[f] + 1));
d2117 2
a2118 2
            ipcp_ClearUrgentUdpPorts(&arg->bundle->ncp.ipcp);
          ipcp_AddUrgentUdpPort(&arg->bundle->ncp.ipcp, atoi(arg->argv[f]));
d2122 3
a2124 3
      ipcp_ClearUrgentTcpPorts(&arg->bundle->ncp.ipcp);
      ipcp_ClearUrgentUdpPorts(&arg->bundle->ncp.ipcp);
      ipcp_ClearUrgentTOS(&arg->bundle->ncp.ipcp);
d2126 1
a2126 1
      ipcp_SetUrgentTOS(&arg->bundle->ncp.ipcp);
d2129 1
a2129 1
        ipcp_ClearUrgentTcpPorts(&arg->bundle->ncp.ipcp);
d2133 1
a2133 1
          ipcp_AddUrgentTcpPort(&arg->bundle->ncp.ipcp, atoi(arg->argv[f] + 1));
d2135 1
a2135 2
          ipcp_RemoveUrgentTcpPort(&arg->bundle->ncp.ipcp,
                                   atoi(arg->argv[f] + 1));
d2138 2
a2139 2
            ipcp_ClearUrgentTcpPorts(&arg->bundle->ncp.ipcp);
          ipcp_AddUrgentTcpPort(&arg->bundle->ncp.ipcp, atoi(arg->argv[f]));
d2145 1
a2145 1
  return err ? 1 : 0;
d2199 1
a2199 1
  "[src_addr[/width]] [dst_addr[/width]] [tcp|udp|icmp|ospf|igmp "
d2287 4
a2290 2
  struct in_addr dest, gateway, netmask;
  int gw, addrs;
d2296 2
a2297 1
  if (arg->argc == arg->argn+2) {
d2299 1
a2299 1
      dest.s_addr = netmask.s_addr = INADDR_ANY;
d2301 1
a2301 4
      int width;

      if (!ParseAddr(&arg->bundle->ncp.ipcp, arg->argv[arg->argn],
	             &dest, &netmask, &width))
d2305 2
d2309 2
d2316 1
a2316 1
    gw = 1;
d2320 1
a2320 1
      dest = arg->bundle->ncp.ipcp.my_ip;
d2323 1
a2323 1
      dest = arg->bundle->ncp.ipcp.peer_ip;
d2326 1
a2326 1
      dest = arg->bundle->ncp.ipcp.ns.dns[0];
d2329 1
a2329 1
      dest = arg->bundle->ncp.ipcp.ns.dns[1];
d2331 2
a2332 2
      dest = GetIpAddr(arg->argv[arg->argn]);
      if (dest.s_addr == INADDR_NONE) {
d2338 2
a2339 2
    netmask = GetIpAddr(arg->argv[arg->argn+1]);
    gw = 2;
d2342 2
a2343 2
  if (strcasecmp(arg->argv[arg->argn+gw], "HISADDR") == 0) {
    gateway = arg->bundle->ncp.ipcp.peer_ip;
d2345 5
d2351 1
a2351 2
    gateway = GetIpAddr(arg->argv[arg->argn+gw]);
    if (gateway.s_addr == INADDR_NONE) {
d2353 1
a2353 1
                 arg->argv[arg->argn + gw]);
d2358 5
a2362 2
  if (rt_Set(arg->bundle, RTM_ADD, dest, gateway, netmask,
                  arg->cmd->args ? 1 : 0, (addrs & ROUTE_GWHISADDR) ? 1 : 0)
d2364 1
a2364 1
    route_Add(&arg->bundle->ncp.ipcp.route, addrs, dest, netmask, gateway);
d2372 1
a2372 1
  struct in_addr dest, none;
d2378 1
a2378 1
      route_DeleteAll(&arg->bundle->ncp.ipcp.route);
d2382 1
a2382 1
        dest = arg->bundle->ncp.ipcp.my_ip;
d2384 5
d2390 1
a2390 1
        dest = arg->bundle->ncp.ipcp.peer_ip;
d2392 5
d2398 1
a2398 1
        dest = arg->bundle->ncp.ipcp.ns.dns[0];
d2401 1
a2401 1
        dest = arg->bundle->ncp.ipcp.ns.dns[1];
d2404 1
a2404 5
        dest = GetIpAddr(arg->argv[arg->argn]);
        if (dest.s_addr == INADDR_NONE) {
          log_Printf(LogWARN, "%s: Invalid IP address\n", arg->argv[arg->argn]);
          return -1;
        }
d2407 2
a2408 4
      none.s_addr = INADDR_ANY;
      rt_Set(arg->bundle, RTM_DELETE, dest, none, none,
                      arg->cmd->args ? 1 : 0, 0);
      route_Delete(&arg->bundle->ncp.ipcp.route, addrs, dest);
a2575 1
  const char *cmd;
d2579 1
a2579 1
  if ((cmd = ident_cmd(arg->argv[arg->argn-2], &keep, &add)) == NULL)
d2582 7
d2593 1
d2733 6
d2758 5
a2762 1
#define OPT_MAX 11	/* accept/deny allowed below and not above */
d2877 4
d2932 4
a2935 2
  int bits, n, how;
  struct in_addr ifa, mask, brd;
d2938 1
a2938 1
    if (!ParseAddr(NULL, arg->argv[arg->argn], &ifa, NULL, NULL))
d2940 1
a2940 1
    mask.s_addr = brd.s_addr = INADDR_BROADCAST;
d2943 1
a2943 1
      if (!ParseAddr(NULL, arg->argv[arg->argn], &ifa, &mask, &bits))
d2947 3
a2949 1
      if (!ParseAddr(NULL, arg->argv[arg->argn], &ifa, NULL, NULL))
d2951 6
a2956 1
      if (!ParseAddr(NULL, arg->argv[arg->argn + 1], &mask, NULL, NULL))
d2962 6
a2967 1
    if (!ParseAddr(NULL, arg->argv[arg->argn + n], &brd, NULL, NULL))
d2969 1
d2976 1
a2976 1
  return !iface_inAdd(arg->bundle->iface, ifa, mask, brd, how);
d2982 2
a2983 1
  struct in_addr ifa;
d2989 1
a2989 1
  if (!ParseAddr(NULL, arg->argv[arg->argn], &ifa, NULL, NULL))
d2993 2
a2994 1
      arg->bundle->ncp.ipcp.my_ip.s_addr == ifa.s_addr) {
d2996 1
a2996 1
               inet_ntoa(ifa));
d3000 1
a3000 1
  ok = iface_inDelete(arg->bundle->iface, ifa);
d3005 2
a3006 1
      prompt_Printf(arg->prompt, "%s: No such address\n", inet_ntoa(ifa));
d3008 2
a3009 1
      log_Printf(LogWARN, "%s: No such address\n", inet_ntoa(ifa));
d3018 1
a3018 1
  int how;
d3020 11
a3030 1
  if (arg->argc != arg->argn)
d3036 1
a3036 1
  iface_Clear(arg->bundle->iface, how);
@


1.66
log
@Fix a possible buffer overflow; theo
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.65 2001/07/26 11:36:51 brian Exp $
d253 1
a253 1
  int f, max, pos;
d258 6
a263 3
  for (pos = 0, f = arg->argn; f < arg->argc && pos < max; f++)
    pos += snprintf(arg->cx->physical->link.lcp.cfg.ident + pos, max - pos,
                    "%s%s", f == arg->argn ? "" : " ", arg->argv[f]);
@


1.65
log
@Handle peer REQ/NAKs of >1500 byte MRUs when we have no preference.
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.64 2001/07/09 07:05:03 deraadt Exp $
d253 1
a253 1
  int f, pos;
d256 1
d258 3
a260 4
  for (pos = 0, f = arg->argn; f < arg->argc; f++)
    pos += snprintf(arg->cx->physical->link.lcp.cfg.ident + pos,
                    sizeof arg->cx->physical->link.lcp.cfg.ident - pos, "%s%s",
                    f == arg->argn ? "" : " ", arg->argv[f]);
@


1.64
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.63 2001/07/09 00:08:54 brian Exp $
d1738 1
a1738 1
      *change = DEF_MRU;
@


1.63
log
@Add a ``nat proto'' command -- similar to natd(8)'s -redirect_proto switch.
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.62 2001/07/07 03:08:49 brian Exp $
d561 1
a561 1
      execl(shell, shell, NULL);
@


1.62
log
@When we miss one or more packets in stateful mode *and* need to
perform a key change, *and* our sequence numbers have wrapped,
ensure that the number of key changes is calculated correctly.

The previous code counted down from a negative number to zero,
re-encrypting the current key on each iteration - this took some
time and strangely enough got the answer wrong !!!

Spell stateful correctly while I'm here.
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.61 2001/07/03 22:23:52 brian Exp $
d635 2
@


1.61
log
@Silence some gcc warnings
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.60 2001/06/19 10:24:51 brian Exp $
d1639 1
a1639 1
      else if (!strcasecmp(arg->argv[arg->argn + 1], "statefull"))
d2111 1
a2111 1
  "MPPE key size and state", "set mppe [40|56|128|* [statefull|stateless|*]]", 
@


1.60
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d28 1
a28 1
 * $OpenBSD: command.c,v 1.59 2001/06/13 21:33:40 brian Exp $
d1705 2
d1750 2
@


1.59
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d138 1
a138 1
#define	VAR_KEYBITS	36
d162 1
a162 1
const char Version[] = "2.3.1";
d1492 1
d1613 18
a1630 9
  case VAR_KEYBITS:
    if (arg->argc > arg->argn) {
      l->ccp.cfg.mppe.keybits = atoi(arg->argv[arg->argn]);
      if (l->ccp.cfg.mppe.keybits != 40 &&
          l->ccp.cfg.mppe.keybits != 56 &&
          l->ccp.cfg.mppe.keybits != 128 ) {
        log_Printf(LogWARN, "%d: Invalid bits number\n",
                  l->ccp.cfg.mppe.keybits);
        l->ccp.cfg.mppe.keybits = 40;
a1631 3
    } else {
      err = "No bits number pecified\n";
      log_Printf(LogWARN, err);
d1633 17
d1705 28
a1732 1
    long_val = atol(argp);
d1734 1
a1734 1
      l->lcp.cfg.mru = DEF_MRU;
d1742 3
a1744 1
      l->lcp.cfg.mru = long_val;
d1748 28
a1775 1
    long_val = atol(argp);
d1783 3
a1785 1
      arg->bundle->cfg.mtu = long_val;
d2107 2
a2108 2
  "MPPE key size", "set mppe {40|56|128}", 
  (const void *) VAR_KEYBITS},
d2149 3
a2151 3
  "MRU value", "set mru value", (const void *)VAR_MRU},
  {"mtu", NULL, SetVariable, LOCAL_AUTH,
  "interface MTU value", "set mtu value", (const void *)VAR_MTU},
@


1.58
log
@When we change the interface MTU, run through the routing table and tweak
all route MTUs too.
@
text
@d1 5
a5 2
/*
 *		PPP User command processing module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 15
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: command.c,v 1.57 2001/02/04 01:14:24 brian Exp $
d28 1
d30 1
@


1.57
log
@Untangle some cunfusion between the CLOSE_STAYDOWN, CLOSE_LCP and
CLOSE_NORMAL meanings.  CLOSE_NORMAL doesn't change the currently
required state, the others do.  This should stop ppp from entering
DATALINK_READY when LCP shutdown doesn't end up happening cleanly.

Bump our version number to reflect this change.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.56 2001/01/29 01:34:38 brian Exp $
d2184 1
a2184 1
  if (bundle_SetRoute(arg->bundle, RTM_ADD, dest, gateway, netmask,
d2225 1
a2225 1
      bundle_SetRoute(arg->bundle, RTM_DELETE, dest, none, none,
@


1.56
log
@Only remove socket files with ``set server open''.
Only show the mask in ``show bundle'' when it's been specified.
Complain about unexpected arguments after ``set server {none,open,closed}''
Log re-open failures as warnings rather than phase messages.
Fix some markup for the ``set server'' man page description.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.55 2001/01/26 01:41:03 brian Exp $
d154 1
a154 1
const char Version[] = "2.3";
@


1.55
log
@Allow ``set server closed'' to close the diagnostic socket.
Allow ``set server open'' to re-open the diagnostic socket.
Handle SIGUSR1 by re-opening the diagnostic socket
When receiving SIGUSR2 (and in ``set server none''), don't forget the
socket details so that ``set server open'' and SIGUSR1 open it again.

Don't create the diagnostic socket as uid 0 !  It's far to dangerous.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.54 2000/11/28 22:59:53 brian Exp $
d1289 3
a1291 1
    } else if (strcasecmp(port, "none") == 0) {
d1300 1
a1300 1
          log_Printf(LogPHASE, "Failed to reopen server port\n");
d1303 1
a1303 1
          log_Printf(LogPHASE, "Cannot reopen unset server socket\n");
@


1.54
log
@Add ``enable/disable'' tcpmssfixup - enabled by default.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.53 2000/11/02 00:54:33 brian Exp $
d1290 18
d1309 4
a1312 1
        log_Printf(LogPHASE, "Disabled server port.\n");
d1317 2
a1318 2
    strncpy(server.passwd, passwd, sizeof server.passwd - 1);
    server.passwd[sizeof server.passwd - 1] = '\0';
d2084 2
a2085 2
  {"server", "socket", SetServer, LOCAL_AUTH,
  "server port", "set server|socket TcpPort|LocalName|none password [mask]"},
@


1.53
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.52 2000/09/06 21:03:38 brian Exp $
d2534 2
d2541 1
a2541 1
#define OPT_MAX 10	/* accept/deny allowed below and not above */
@


1.52
log
@Correct a typo; Dag-Erling Smorgrav <des@@ofug.org>
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.51 2000/08/30 22:04:35 brian Exp $
d130 1
d151 2
d154 1
a154 1
const char Version[] = "2.27";
d1580 18
d1992 5
d2023 1
a2023 1
  "set log [local] [+|-]async|cbcp|ccp|chat|command|connect|debug|dns|hdlc|"
d2443 8
d2554 6
@


1.51
log
@Complain about invalid arguments passed to ``set ifaddr''
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.50 2000/08/18 00:02:10 brian Exp $
d2644 1
a2644 1
      prompt_Printf(arg->prompt, "The alias command is depricated\n");
d2646 1
a2646 1
      log_Printf(LogWARN, "The alias command is depricated\n");
@


1.50
log
@Make -DNOSUID (or -DPPP_NOSUID) possible to build ppp without SUID
capabilities.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.49 2000/08/18 00:02:02 brian Exp $
d2111 1
a2111 1
    } else
d2113 6
d2126 1
a2126 1
  } else
d2128 6
@


1.49
log
@Warn that the ``alias'' command is depricated.
We still process it for now though.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.48 2000/08/16 09:07:27 brian Exp $
d522 1
d524 1
@


1.48
log
@setproctitle() doesn't need to be called with root privs, so move
it from id.c into defs.c
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.47 2000/08/15 10:26:35 brian Exp $
d2625 10
@


1.47
log
@Maintain input and output throughput averages and choose the highest
of the two when calculating the MP throughput average for the ``set
autoload'' implementation.

This makes more sense as all links I know of are full-duplex.  This
also means that people may need to adjust their autoload settings
as 100% bandwidth is now the theoretical maximum rather than 200%
(but of course, halfing the current settings is probably not the
correct answer either!).

This involves a ppp version bump as we need to pass an extra
throughput array through the MP local domain socket.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.46 2000/08/15 10:08:48 brian Exp $
a35 5
#ifdef __OpenBSD__
#include <util.h>
#else
#include <libutil.h>
#endif
d2729 1
a2729 1
    ID0setproctitle(NULL);
d2755 1
a2755 1
  ID0setproctitle(title);
@


1.46
log
@Calculate the average link throughput using a counter based on the
cumulative total of all active links rather than basing it on the
total of PROTO_MP traffic.

This fixes a problem whereby Cisco routers send PROTO_IP packets only
when there's only one link (hmm, what a good idea!).
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.45 2000/07/19 11:06:32 brian Exp $
d156 1
a156 1
const char Version[] = "2.26";
@


1.45
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.44 2000/07/07 14:47:54 brian Exp $
d2602 1
a2602 1
    t = &cx->physical->link.throughput;
@


1.44
log
@o  Log the (payload/size) of all packet types, not just TCP packets

o  If the new ``filter-decapsulation'' is enabled, delve into UDP packets
   that contain 0xff 0x03 as the first two bytes, and if we recognise it
   as PROTO_IP, decapsulate it for the purpose of filter checking.

   If we recognise it as PROTO_<anything else> mention this for logging
   purposes only.

This change is aimed at people running PPPoUDP where the UDP traffic is
being sent over another PPP link.  It's desireable to have the top level
link connected all the time, but to have the bottom level link capable
of decapsulating the traffic and comparing the payload against the filters,
thus allowing ``set filter dial ...'' to work in tunnelled environments.

The caveat here is that the top ppp cannot employ any compression layers
without making the data unreadable for the bottom ppp.  ``disable deflate
pred1 vj'' and ``deny deflate pred1 vj'' is suggested.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.43 2000/06/23 09:47:05 brian Exp $
a63 1
#include "lcp.h"
d69 1
d245 25
d469 2
d711 2
d737 2
@


1.43
log
@Improved 227, 229 and EPRT support in the nat code; FreeBSD
Moved security checks into one place; FreeBSD
Remove ``nat pptp'' now that it's transparent
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.42 2000/06/13 09:57:50 brian Exp $
d2440 3
d2446 2
a2447 2
   "retain interface addresses", "disable|enable",
   (const void *)OPT_IFACEALIAS},
@


1.42
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.41 2000/04/02 01:36:25 brian Exp $
a599 1
  {"pptp", NULL, nat_Pptp, LOCAL_AUTH, "Set the PPTP address", "nat pptp IP"},
@


1.41
log
@Allow ``set authname'' in any phase, just warn if we're not
in DEAD or ESTABLISH.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.40 2000/03/31 14:32:50 brian Exp $
d134 1
d1650 5
d1864 1
d1868 1
d1882 5
d1888 1
d1963 2
@


1.40
log
@Add the ``nat target'' command.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.39 2000/03/19 10:33:32 brian Exp $
d1460 4
a1468 4
        break;
      default:
        err = "set authname: Only available at phase DEAD/ESTABLISH\n";
        log_Printf(LogWARN, err);
@


1.39
log
@Allow environment variables on command/config lines; markk@@knigma.org
Add the ``resolv'' command so that when ``enable dns''
is used, it's possible to restore the file.
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.38 2000/02/27 01:38:25 brian Exp $
d175 2
a176 2
static int AliasEnable(struct cmdargs const *);
static int AliasOption(struct cmdargs const *);
d585 1
a585 1
static struct cmdtab const AliasCommands[] =
d589 1
a589 1
  {"deny_incoming", NULL, AliasOption, LOCAL_AUTH,
d592 1
a592 1
  {"enable", NULL, AliasEnable, LOCAL_AUTH,
d594 1
a594 1
  {"log", NULL, AliasOption, LOCAL_AUTH,
d599 1
a599 2
  {"pptp", NULL, nat_Pptp, LOCAL_AUTH,
   "Set the PPTP address", "nat pptp IP"},
d602 1
a602 1
  {"same_ports", NULL, AliasOption, LOCAL_AUTH,
d605 3
a607 1
  {"unregistered_only", NULL, AliasOption, LOCAL_AUTH,
d611 1
a611 1
  {"use_sockets", NULL, AliasOption, LOCAL_AUTH,
d615 1
a615 1
   "Display this message", "nat help|? [command]", AliasCommands},
d692 1
a692 1
  "NAT control", "nat option yes|no", AliasCommands},
d2133 1
a2133 1
AliasEnable(struct cmdargs const *arg)
d2156 1
a2156 1
AliasOption(struct cmdargs const *arg)
@


1.38
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: command.c,v 1.37 2000/02/27 00:21:07 brian Exp $
d439 4
d561 23
d703 2
d938 12
d1028 1
a1028 1
  if ((argc = command_Interpret(buff, nb, argv)) < 0)
d1713 1
a1713 1
    if (param == VAR_DNS)
d1715 2
a1716 1
    else
d1718 2
a1719 2

    addr[0].s_addr = addr[1].s_addr = INADDR_ANY;
d1728 1
a1728 3
      if (addr[1].s_addr == INADDR_ANY)
        addr[1].s_addr = addr[0].s_addr;
      if (addr[0].s_addr == INADDR_ANY)
d1730 6
d2018 1
a2018 1
	    " syntax help.\n");
d2048 4
d2061 6
d2105 6
@


1.37
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.36 2000/01/07 03:26:53 brian Exp $
@


1.36
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.35 1999/08/22 01:33:15 brian Exp $
d50 3
a52 1
#ifdef __FreeBSD__
a53 2
#else
#include "alias.h"
d56 1
d1907 2
a1908 2
  "set log [local] [+|-]async|cbcp|ccp|chat|command|connect|debug|hdlc|id0|"
  "ipcp|lcp|lqm|phase|physical|sync|tcp/ip|timer|tun..."},
@


1.35
log
@Allow authkey to be changed independently of the current phase.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.34 1999/08/17 17:25:34 brian Exp $
d36 5
d49 1
a49 1
#ifndef NOALIAS
d70 2
a71 2
#ifndef NOALIAS
#include "alias_cmd.h"
d95 1
d131 2
d154 1
a154 2
const char Version[] = "2.23";
const char VersionDate[] = "$Date: 1999/08/17 17:25:34 $";
d173 1
a173 1
#ifndef NOALIAS
d494 1
a494 1
    setuid(geteuid());
d556 1
a556 1
#ifndef NOALIAS
d559 2
a560 2
  {"addr", NULL, alias_RedirectAddr, LOCAL_AUTH,
   "static address translation", "alias addr [addr_local addr_alias]"},
d562 1
a562 1
   "stop incoming connections", "alias deny_incoming [yes|no]",
d565 1
a565 1
   "enable IP aliasing", "alias enable [yes|no]"},
d567 1
a567 1
   "log aliasing link creation", "alias log [yes|no]",
d569 6
a574 6
  {"port", NULL, alias_RedirectPort, LOCAL_AUTH, "port redirection",
   "alias port proto localaddr:port[-port] aliasport[-aliasport]"},
  {"pptp", NULL, alias_Pptp, LOCAL_AUTH,
   "Set the PPTP address", "alias pptp IP"},
  {"proxy", NULL, alias_ProxyRule, LOCAL_AUTH,
   "proxy control", "alias proxy server host[:port] ..."},
d576 1
a576 1
   "try to leave port numbers unchanged", "alias same_ports [yes|no]",
d579 2
a580 2
   "alias unregistered (private) IP address space only",
   "alias unregistered_only [yes|no]",
d583 1
a583 1
   "allocate host sockets", "alias use_sockets [yes|no]",
d586 1
a586 1
   "Display this message", "alias help|? [command]", AliasCommands},
d619 1
a619 1
   "Display this message", "alias help|? [command]", IfaceCommands},
a629 4
#ifndef NOALIAS
  {"alias", NULL, RunListCommand, LOCAL_AUTH,
  "alias control", "alias option [yes|no]", AliasCommands},
#endif
d661 4
d741 1
a741 1
  prompt_Printf(arg->prompt, "PPP Version %s - %s\n", Version, VersionDate);
d916 1
a916 1
    return MakeArgs(buff, argv, MAXARGS);
d979 1
a979 1
void
d986 3
a988 1
  argc = command_Interpret(buff, nb, argv);
d990 1
d1150 1
a1150 1
      log_Printf(LogWARN, "SetModemSpeed: Too many arguments");
a1190 3
#define ismask(x) \
  (*x == '0' && strlen(x) == 4 && strspn(x+1, "0123456789.") == 3)

d1198 1
d1208 5
a1212 1
      if (!ismask(mask))
d1214 1
d1229 1
a1229 8
      if (mask != NULL) {
	unsigned m;

	if (sscanf(mask, "%o", &m) == 1)
	  imask = m;
        else
          return -1;
      } else
d1231 2
d1386 1
a1386 1
  int mode, dummyint;
d1606 5
d1773 9
a1781 5
      long_val = atol(argp);
      if (long_val < 0)
        long_val = 0;
      cx->physical->cfg.cd.delay = long_val;
      cx->physical->cfg.cd.required = argp[strlen(argp)-1] == '!';
d1783 2
a1784 2
      cx->physical->cfg.cd.delay = DEF_CDDELAY;
      cx->physical->cfg.cd.required = 0;
d1807 37
d1859 2
d1910 2
d1954 2
a1957 2
  {"bandwidth", NULL, mp_SetDatalinkBandwidth, LOCAL_AUTH | LOCAL_CX,
  "datalink bandwidth", "set bandwidth value"},
d2067 1
a2067 1
#ifndef NOALIAS
d2073 1
a2073 1
      if (!arg->bundle->AliasEnabled) {
d2076 1
a2076 1
        arg->bundle->AliasEnabled = 1;
d2080 1
a2080 1
      arg->bundle->AliasEnabled = 0;
d2098 1
a2098 1
      if (arg->bundle->AliasEnabled) {
d2102 1
a2102 1
      log_Printf(LogWARN, "alias not enabled\n");
d2104 1
a2104 1
      if (arg->bundle->AliasEnabled) {
d2108 1
a2108 1
      log_Printf(LogWARN, "alias not enabled\n");
d2113 1
a2113 1
#endif /* #ifndef NOALIAS */
d2248 1
a2248 1
    if (Enabled(arg->bundle, OPT_IFACEALIAS) && !arg->bundle->AliasEnabled) {
d2250 1
a2250 1
      log_Printf(LogWARN, "Cannot enable iface-alias without IP aliasing\n");
d2621 1
a2621 2
    arg->bundle->argv[0] = arg->bundle->argv0;
    arg->bundle->argv[1] = arg->bundle->argv1;
d2647 1
a2647 2
  arg->bundle->argv[0] = title;
  arg->bundle->argv[1] = NULL;
@


1.34
log
@Implement a minimum idle time value as an optional second argument
to ``set timeout''.
This is useful for situations where your minimum call charge is (say)
5 minutes (like mine is)
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.33 1999/08/17 15:00:38 brian Exp $
d147 1
a147 1
const char VersionDate[] = "$Date: 1999/08/17 15:00:38 $";
d1402 3
a1404 12
    switch (bundle_Phase(arg->bundle)) {
      case PHASE_DEAD:
      case PHASE_ESTABLISH:
        strncpy(arg->bundle->cfg.auth.key, argp,
                sizeof arg->bundle->cfg.auth.key - 1);
        arg->bundle->cfg.auth.key[sizeof arg->bundle->cfg.auth.key - 1] = '\0';
        break;
      default:
        err = "set authkey: Only available at phase DEAD/ESTABLISH\n";
        log_Printf(LogWARN, err);
        break;
    }
@


1.33
log
@Set the close-on-exec flag for all unused descriptors when
exec()ing other programs.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.32 1999/08/05 10:32:13 brian Exp $
d147 1
a147 1
const char VersionDate[] = "$Date: 1999/08/05 10:32:13 $";
d1608 1
a1608 1
    if (arg->argc > arg->argn+1)
d1610 9
a1618 2
    else if (arg->argc == arg->argn+1)
      bundle_SetIdleTimer(arg->bundle, atoi(argp));
@


1.32
log
@o Obsolete the undocumented ``set weight'' command.
o If we're using RADIUS and the RADIUS mtu is less than our
  peers mru/mrru, reduce our mtu to this value for NetBSD too.
o Make struct throughput's sample period dynamic and tweak the ppp
  version number to reflect the extra stuff being passed through
  the local domain socket as a result (MP mode).
o Measure the current throughput based on the number of samples actually
  taken rather than on the full sample period.
o Keep the throughput statisics persistent while being passed to
  another ppp invocation through the local domain socket.
o When showing throughput statistics after the timer has stopped, use
  the stopped time for overall calculations, not the current time.
  Also show the stopped time and how long the current throughput has
  been sampled for.
o Use time() consistently in throughput.c
o Tighten up the ``show bundle'' output.
o Introduce the ``set bandwidth'' command.
o Rewrite the ``set autoload'' command.  It now takes three arguments
  and works based on a rolling bundle throughput average compared against
  the theoretical bundle bandwidth over a given period (read: it's now
  functional).
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.31 1999/08/02 21:45:45 brian Exp $
d147 1
a147 1
const char VersionDate[] = "$Date: 1999/08/02 21:45:45 $";
d481 5
a485 4
    for (i = 0; i < 3; i++)
      dup2(fd, i);

    fcntl(3, F_SETFD, 1);	/* Set close-on-exec flag */
d519 1
a519 1
    exit(255);
@


1.31
log
@Mention that ospf is a possible filter protocol.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.30 1999/06/23 16:49:03 brian Exp $
d146 2
a147 2
const char Version[] = "2.22";
const char VersionDate[] = "$Date: 1999/06/23 16:49:03 $";
d1431 28
a1458 10
    if (arg->argc == arg->argn + 2 || arg->argc == arg->argn + 4) {
      arg->bundle->autoload.running = 1;
      arg->bundle->cfg.autoload.max.timeout = atoi(arg->argv[arg->argn]);
      arg->bundle->cfg.autoload.max.packets = atoi(arg->argv[arg->argn + 1]);
      if (arg->argc == arg->argn + 4) {
        arg->bundle->cfg.autoload.min.timeout = atoi(arg->argv[arg->argn + 2]);
        arg->bundle->cfg.autoload.min.packets = atoi(arg->argv[arg->argn + 3]);
      } else {
        arg->bundle->cfg.autoload.min.timeout = 0;
        arg->bundle->cfg.autoload.min.packets = 0;
d1460 5
d1466 1
a1466 1
      err = "Set autoload requires two or four arguments\n";
d1899 2
a1900 2
  {"weight", NULL, mp_SetDatalinkWeight, LOCAL_AUTH | LOCAL_CX,
  "datalink weighting", "set weight n"},
@


1.30
log
@Support `igmp' filters.
Mostly submitted by: Timo Geusch <freebsd@@sleepycat.ukpeople.net>
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.29 1999/06/10 09:34:42 brian Exp $
d147 1
a147 1
const char VersionDate[] = "$Date: 1999/06/10 09:34:42 $";
d1817 1
a1817 1
  "[src_addr[/width]] [dst_addr[/width]] [tcp|udp|icmp|igmp "
@


1.29
log
@Allow reserved substitution strings to be escaped by preceeding them
with a backslash.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.28 1999/06/09 16:55:25 brian Exp $
d147 1
a147 1
const char VersionDate[] = "$Date: 1999/06/09 16:55:25 $";
d1817 2
a1818 2
  "[src_addr[/width]] [dst_addr[/width]] [tcp|udp|icmp [src [lt|eq|gt port]] "
  "[dst [lt|eq|gt port]] [estab] [syn] [finrst]]"},
@


1.28
log
@Allow our endpoint discriminator to be enabled, disabled, accepted
and denied.  This is necessary for some MP implementations that
get confused if you accept their endpoint discriminator but reject
their MRRU.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.27 1999/06/09 08:47:23 brian Exp $
d147 1
a147 1
const char VersionDate[] = "$Date: 1999/06/09 08:47:23 $";
d357 5
a361 1
    if ((pos == big || !isinword(pos[-1])) && !isinword(pos[len]))
a362 2
    else
      pos++;
@


1.27
log
@Use the correct pid when substituting PROCESSID.
Problem reported by: Amedeo Beck Peccoz <gea@@gressoney.it>
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.26 1999/06/08 20:12:28 brian Exp $
d136 9
a144 8
#define NEG_LQR		45
#define NEG_PAP		46
#define NEG_PPPDDEFLATE	47
#define NEG_PRED1	48
#define NEG_PROTOCOMP	49
#define NEG_SHORTSEQ	50
#define NEG_VJCOMP	51
#define NEG_DNS		52
d147 1
a147 1
const char VersionDate[] = "$Date: 1999/06/08 20:12:28 $";
d2225 4
d2325 2
@


1.26
log
@Don't use static variables if we don't have to.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.25 1999/06/05 21:35:58 brian Exp $
d146 1
a146 1
const char VersionDate[] = "$Date: 1999/06/05 21:35:58 $";
d398 1
a398 1
               struct bundle *bundle, int inc0)
d401 1
a401 1
  char pid[12];
d409 1
a409 1
  snprintf(pid, sizeof pid, "%d", getpid());
d426 1
a426 1
    nargv[arg] = subst(nargv[arg], "PROCESSID", pid);
d436 1
a436 1
  pid_t shpid;
d462 1
d493 1
a493 1
      command_Expand(argv, argc, arg->argv + arg->argn, arg->bundle, 0);
d2541 1
a2541 1
  command_Expand(argv, argc, arg->argv + arg->argn, arg->bundle, 1);
@


1.25
log
@Correct the way ppp transfers links on the server side in MP
mode by padding out the ``struct device'' to the maximum
device size.
Bump the ppp version number to indicate the transfer format
change.

This should make MP over tty and udp devices functional again.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.24 1999/06/02 21:27:54 brian Exp $
d146 1
a146 1
const char VersionDate[] = "$Date: 1999/06/02 21:27:54 $";
d938 1
a938 1
      static char buf[LINE_LEN];
a940 1
      *buf = '\0';
d945 4
d950 2
a951 1
      n = strlen(buf);
@


1.24
log
@Mention physical and sync logging in the ``set log''
usage message.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.23 1999/06/02 00:46:55 brian Exp $
d145 2
a146 2
const char Version[] = "2.21";
const char VersionDate[] = "$Date: 1999/06/02 00:46:55 $";
@


1.23
log
@Introduce the ``keep-session'' option.  Refer to the man
page for details.  This allows MP over non-tty devices where
the original ppp process must not exit (such as sshd-spawned
ppp sessions).
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.22 1999/05/31 23:57:36 brian Exp $
d146 1
a146 1
const char VersionDate[] = "$Date: 1999/05/31 23:57:36 $";
d1821 1
a1821 1
  "ipcp|lcp|lqm|phase|tcp/ip|timer|tun..."},
@


1.22
log
@Remember if MYADDR or HISADDR is used in a filter add tweak all
filters any time either value changes.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.21 1999/05/15 02:25:22 brian Exp $
d146 1
a146 1
const char VersionDate[] = "$Date: 1999/05/15 02:25:22 $";
d2274 2
d2291 1
a2291 1
#define OPT_MAX 9	/* accept/deny allowed below and not above */
@


1.21
log
@Add ``show layers'' to see the protocol layering for a link.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.20 1999/05/12 10:03:49 brian Exp $
d146 1
a146 1
const char VersionDate[] = "$Date: 1999/05/12 10:03:49 $";
d1315 1
@


1.20
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.19 1999/05/08 11:06:34 brian Exp $
d146 1
a146 1
const char VersionDate[] = "$Date: 1999/05/08 11:06:34 $";
d760 2
@


1.19
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.18 1999/04/26 08:55:01 brian Exp $
d145 2
a146 2
const char Version[] = "2.2";
const char VersionDate[] = "$Date: 1999/04/26 08:55:01 $";
@


1.18
log
@Add support for NetBSD
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.17 1999/03/25 23:36:52 brian Exp $
d51 1
a64 1
#include "modem.h"
d123 2
d145 2
a146 2
const char Version[] = "2.11";
const char VersionDate[] = "$Date: 1999/03/25 23:36:52 $";
d627 2
a628 1
  "Clear throughput statistics", "clear ipcp|modem [current|overall|peak]..."},
d644 1
a644 1
  "Generate a down event", "down"},
d770 2
a771 2
  {"modem", NULL, modem_ShowStatus, LOCAL_AUTH | LOCAL_CX,
  "(low-level) link info", "show modem"},
a1255 7
SetModemParity(struct cmdargs const *arg)
{
  return arg->argc > arg->argn ? modem_SetParity(arg->cx->physical,
                                                 arg->argv[arg->argn]) : -1;
}

static int
a1736 1
  }
d1738 8
a1745 2
  return err ? 1 : 0;
}
d1747 2
a1748 5
static int 
SetCtsRts(struct cmdargs const *arg)
{
  if (arg->argc == arg->argn+1) {
    if (strcmp(arg->argv[arg->argn], "on") == 0)
d1750 1
a1750 1
    else if (strcmp(arg->argv[arg->argn], "off") == 0)
d1752 5
a1756 3
    else
      return -1;
    return 0;
d1758 2
a1759 1
  return -1;
d1787 3
a1789 2
  {"ctsrts", "crtscts", SetCtsRts, LOCAL_AUTH | LOCAL_CX,
  "Use hardware flow control", "set ctsrts [on|off]"},
d1794 1
a1794 1
  "modem device name", "set device|line device-name[,device-name]",
d1837 2
a1838 2
  {"parity", NULL, SetModemParity, LOCAL_AUTH | LOCAL_CX,
  "modem parity", "set parity [odd|even|none]"},
d1858 1
a1858 1
  "modem speed", "set speed value"},
d1982 5
a1986 1
      arg->bundle->AliasEnabled = 1;
d2382 1
a2382 1
  if (strcasecmp(arg->argv[arg->argn], "modem") == 0) {
d2387 1
a2387 1
      log_Printf(LogWARN, "A link must be specified for ``clear modem''\n");
@


1.17
log
@Allow port ranges in ``alias port''.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.16 1999/03/19 00:08:12 brian Exp $
d45 3
a47 1
#ifdef __OpenBSD__
a48 2
#else
#include <alias.h>
d144 1
a144 1
const char VersionDate[] = "$Date: 1999/03/19 00:08:12 $";
@


1.16
log
@Don't forget to fully initialise the configured values
for MYADDR and HISADDR in ``set ifaddr'' so that unspecified
values don't end up retaining their `width'.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.15 1999/03/08 01:40:23 brian Exp $
d144 1
a144 1
const char VersionDate[] = "$Date: 1999/03/08 01:40:23 $";
d555 2
a556 2
  {"port", NULL, alias_RedirectPort, LOCAL_AUTH,
   "port redirection", "alias port [proto addr_local:port_local  port_alias]"},
@


1.15
log
@Add proxying & transparent proxying support (``alias proxy'').
Add PPTP packet aliasing (GRE fixed address) support (``alias pptp'').
Add a 0 to the front of the mode to signify octal.
Thanks to: Charles Mott <cmott@@srv.net> & Dru Nelson <dnelson@@redwoodsoft.com>
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.14 1999/03/04 17:42:25 brian Exp $
d144 1
a144 1
const char VersionDate[] = "$Date: 1999/03/04 17:42:25 $";
d1288 2
a1289 2
  ipcp->cfg.my_range.ipaddr.s_addr = INADDR_ANY;
  ipcp->cfg.peer_range.ipaddr.s_addr = INADDR_ANY;
@


1.14
log
@Extend the ``set redial'' command to allow incremental
redial timeouts.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.13 1999/03/03 23:01:09 brian Exp $
d144 1
a144 1
const char VersionDate[] = "$Date: 1999/03/03 23:01:09 $";
d557 4
@


1.13
log
@Correct some ntohl/htonl bogons in the netmask handling.
This was pretty harmless as netmasks on a POINTOPOINT
interface are pretty much ignored, but it looked funny.

Mention the configured netmask in ``show ipcp''.

Describe in more detail what a proxy arp entry is.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.12 1999/02/26 21:28:20 brian Exp $
d144 1
a144 1
const char VersionDate[] = "$Date: 1999/02/26 21:28:20 $";
d1846 1
a1846 1
  "Redial timeout", "set redial value|random[.value|random] [attempts]"},
@


1.12
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.11 1999/02/25 20:07:34 brian Exp $
d144 1
a144 1
const char VersionDate[] = "$Date: 1999/02/25 20:07:34 $";
d1298 1
a1298 1
        ipcp->cfg.netmask = GetIpAddr(arg->argv[arg->argn+2]);
@


1.11
log
@Parse IP addresses more securely - specifically, don't allow
a bum name to return as 0.0.0.0... we don't want ``delete xxx''
to delete the default route when xxx doesn't resolve.

Support IP number specifications as the host when specifying
a tcp-style device (rather than *just* hostnames).
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.10 1999/02/18 00:50:45 brian Exp $
d144 1
a144 1
const char VersionDate[] = "$Date: 1999/02/18 00:50:45 $";
d1322 41
d1592 4
a1595 7
    long_val = atol(argp);
    if (long_val < MIN_FSMRETRY) {
      log_Printf(LogWARN, "%ld: Invalid LCP FSM retry period - min %d\n",
                 long_val, MIN_FSMRETRY);
      return 1;
    } else
      cx->physical->link.lcp.cfg.fsmretry = long_val;
d1599 3
a1601 7
    long_val = atol(argp);
    if (long_val < MIN_FSMRETRY) {
      log_Printf(LogWARN, "%ld: Invalid CHAP FSM retry period - min %d\n",
                 long_val, MIN_FSMRETRY);
      return 1;
    } else
      cx->chap.auth.cfg.fsmretry = long_val;
d1605 3
a1607 7
    long_val = atol(argp);
    if (long_val < MIN_FSMRETRY) {
      log_Printf(LogWARN, "%ld: Invalid PAP FSM retry period - min %d\n",
                 long_val, MIN_FSMRETRY);
      return 1;
    } else
      cx->pap.cfg.fsmretry = long_val;
d1611 3
a1613 7
    long_val = atol(argp);
    if (long_val < MIN_FSMRETRY) {
      log_Printf(LogWARN, "%ld: Invalid CCP FSM retry period - min %d\n",
                 long_val, MIN_FSMRETRY);
      return 1;
    } else
      l->ccp.cfg.fsmretry = long_val;
d1617 4
a1620 7
    long_val = atol(argp);
    if (long_val < MIN_FSMRETRY) {
      log_Printf(LogWARN, "%ld: Invalid IPCP FSM retry period - min %d\n",
                 long_val, MIN_FSMRETRY);
      return 1;
    } else
      arg->bundle->ncp.ipcp.cfg.fsmretry = long_val;
d1773 2
a1774 2
  {"ccpretry", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX_OPT,
  "FSM retry period", "set ccpretry value", (const void *)VAR_CCPRETRY},
d1777 3
a1779 2
  {"chapretry", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "CHAP retry period", "set chapretry value", (const void *)VAR_CHAPRETRY},
d1806 4
a1809 4
  {"ipcpretry", NULL, SetVariable, LOCAL_AUTH,
  "FSM retry period", "set ipcpretry value", (const void *)VAR_IPCPRETRY},
  {"lcpretry", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "FSM retry period", "set lcpretry value", (const void *)VAR_LCPRETRY},
d1829 2
a1830 2
  {"papretry", NULL, SetVariable, LOCAL_AUTH | LOCAL_CX,
  "PAP retry period", "set papretry value", (const void *)VAR_PAPRETRY},
@


1.10
log
@Fully support both NT and LANMan CHAP type 0x80 as both
authenticator and authenticatee.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.9 1999/02/16 00:18:01 brian Exp $
d144 1
a144 1
const char VersionDate[] = "$Date: 1999/02/16 00:18:01 $";
a1273 16
static struct in_addr
GetIpAddr(const char *cp)
{
  struct hostent *hp;
  struct in_addr ipaddr;

  if (inet_aton(cp, &ipaddr) == 0) {
    hp = gethostbyname(cp);
    if (hp && hp->h_addrtype == AF_INET)
      memcpy(&ipaddr, hp->h_addr, hp->h_length);
    else
      ipaddr.s_addr = 0;
  }
  return (ipaddr);
}

d1928 5
a1932 4
        if (strcasecmp(arg->argv[arg->argn], "default") == 0)
          dest.s_addr = INADDR_ANY;
        else
          dest = GetIpAddr(arg->argv[arg->argn]);
@


1.9
log
@Wait by default for one second after the login script
is complete before checking carrier.  If it's there,
the device supports carrier.  If it's not it doesn't.

Add the ``set cd'' command for deciding how soon to check
for carrier, and for deciding if carrier is REQUIRED.

The default has changed:  Pre 2.0 versions of ppp waited
for 1 second.  Version 2 didn't wait, but this causes
problems with some (few?) modems that don't assert carrier
immediately on reporting CONNECT.  The one second delay
is back now and can be removed with ``set cd 0''.

Bump the ppp version number in case this needs to be changed
again....
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.8 1999/02/11 10:14:49 brian Exp $
d130 12
a141 10
#define NEG_CHAP	41
#define NEG_DEFLATE	42
#define NEG_LQR		43
#define NEG_PAP		44
#define NEG_PPPDDEFLATE	45
#define NEG_PRED1	46
#define NEG_PROTOCOMP	47
#define NEG_SHORTSEQ	48
#define NEG_VJCOMP	49
#define NEG_DNS		50
d144 1
a144 1
const char VersionDate[] = "$Date: 1999/02/11 10:14:49 $";
d2175 3
a2177 3
    case NEG_CHAP:
      cx->physical->link.lcp.cfg.chap &= keep;
      cx->physical->link.lcp.cfg.chap |= add;
d2179 10
d2272 1
a2272 1
  {"chap", NULL, NegotiateSet, LOCAL_AUTH | LOCAL_CX,
d2274 9
a2282 1
  (const void *)NEG_CHAP},
@


1.8
log
@When resending chap challenges, resend the same challenge
each time rather than making up a new one.

Increase the authname/authkey max sizes to 100 characters.

Allow ``authkey'' specifications beginning with ``!''.
When a challenge is received, the text following the
``!'' is executed as a program (expanding stuff in the same
way that ``sh'' and ``!bg'' do).  The program is passed the
peer name, peer challenge and local ``authname'' on standard
input and is expected to output the name/key combination that
should be used to build the CHAP response.

This provides support for Secure ID cards (guess what I was
given at work recently!) using CHAP.

Examples will follow.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.7 1999/02/06 03:22:33 brian Exp $
d122 1
d141 2
a142 2
const char Version[] = "2.1";
const char VersionDate[] = "$Date: 1999/02/06 03:22:33 $";
d1715 13
d1766 2
@


1.7
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.179 1999/01/28 09:40:15 brian Exp $
d141 1
a141 1
const char VersionDate[] = "$Date: 1999/01/28 09:40:15 $";
d391 3
a393 3
static void
expand(char **nargv, int argc, char const *const *oargv, struct bundle *bundle,
       int inc0)
d487 1
a487 1
      expand(argv, argc, arg->argv + arg->argn, arg->bundle, 0);
d2476 1
a2476 1
  expand(argv, argc, arg->argv + arg->argn, arg->bundle, 1);
@


1.6
log
@Allow a variable as the first arg to ``set proctitle''.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.5 1998/11/05 22:00:11 brian Exp $
d23 1
a23 1
#include <sys/types.h>
d79 3
d121 1
d140 2
a141 2
const char Version[] = "2.0";
const char VersionDate[] = "$Date: 1998/11/05 22:00:11 $";
d1304 1
a1304 1
    if (!ParseAddr(ipcp, arg->argc - arg->argn, arg->argv + arg->argn,
d1623 1
a1623 1
      ParseAddr(&arg->bundle->ncp.ipcp, 1, arg->argv + arg->argn,
d1626 1
a1626 1
        ParseAddr(&arg->bundle->ncp.ipcp, 1, arg->argv + arg->argn + 1,
d1698 16
d1811 4
d1871 1
a1871 1
      if (!ParseAddr(&arg->bundle->ncp.ipcp, 1, arg->argv + arg->argn,
d1900 2
a1901 1
                  arg->cmd->args ? 1 : 0, (addrs & ROUTE_GWHISADDR) ? 1 : 0))
d2383 1
a2383 1
    if (!ParseAddr(NULL, 1, arg->argv + arg->argn, &ifa, NULL, NULL))
d2388 1
a2388 1
      if (!ParseAddr(NULL, 1, arg->argv + arg->argn, &ifa, &mask, &bits))
d2392 1
a2392 1
      if (!ParseAddr(NULL, 1, arg->argv + arg->argn, &ifa, NULL, NULL))
d2394 1
a2394 1
      if (!ParseAddr(NULL, 1, arg->argv + arg->argn + 1, &mask, NULL, NULL))
d2400 1
a2400 1
    if (!ParseAddr(NULL, 1, arg->argv + arg->argn + n, &brd, NULL, NULL))
d2420 1
a2420 1
  if (!ParseAddr(NULL, 1, arg->argv + arg->argn, &ifa, NULL, NULL))
@


1.5
log
@Don't delete the primary interface address when
``iface clean'' is used in auto mode while there
are no active links.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.4 1998/10/31 17:38:50 brian Exp $
d137 1
a137 1
const char VersionDate[] = "$Date: 1998/10/31 17:38:50 $";
d388 2
a389 1
expand(char **nargv, int argc, char const *const *oargv, struct bundle *bundle)
d394 6
a399 1
  nargv[0] = strdup(oargv[0]);
d401 1
a401 1
  for (arg = 1; arg < argc; arg++) {
d483 1
a483 1
      expand(argv, argc, arg->argv + arg->argn, arg->bundle);
d2451 1
a2451 1
  expand(argv, argc, arg->argv + arg->argn, arg->bundle);
@


1.4
log
@Allow multiple systems (config labels) on the command
line and in the ``load'' & ``dial'' commands.  The last
label loaded becomes the current label name.
Only require a label for -auto mode.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.3 1998/10/29 02:21:44 brian Exp $
d137 1
a137 1
const char VersionDate[] = "$Date: 1998/10/29 02:21:44 $";
d2420 2
a2421 1
  how = arg->bundle->ncp.ipcp.fsm.state == ST_OPENED ?
@


1.3
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.2 1998/08/31 08:16:36 brian Exp $
d137 1
a137 1
const char VersionDate[] = "$Date: 1998/10/27 22:53:22 $";
d277 2
a278 1
  const char *name;
d280 1
a280 4
  if (arg->argc > arg->argn)
    name = arg->argv[arg->argn];
  else
    name = "default";
d282 14
a295 2
  if (!system_IsValid(name, arg->prompt, arg->bundle->phys_type.all)) {
    log_Printf(LogWARN, "%s: Label not allowed\n", name);
d298 3
a300 11
    /*
     * Set the label before & after so that `set enddisc' works and
     * we handle nested `load' commands.
     */
    bundle_SetLabel(arg->bundle, arg->argc > arg->argn ? name : NULL);
    if (system_Select(arg->bundle, name, CONFFILE, arg->prompt, arg->cx) < 0) {
      bundle_SetLabel(arg->bundle, NULL);
      log_Printf(LogWARN, "%s: label not found.\n", name);
      return -1;
    }
    bundle_SetLabel(arg->bundle, arg->argc > arg->argn ? name : NULL);
d302 1
d620 1
a620 1
  "Dial and login", "dial|call [remote]", NULL},
d632 1
a632 1
  "Load settings", "load [remote]"},
@


1.2
log
@Move libalias sources into the ppp directory.
Suggested (many times) by: Theo
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.1 1998/08/31 00:22:18 brian Exp $
d86 1
d116 2
d137 1
a137 1
const char VersionDate[] = "$Date: 1998/08/31 00:22:18 $";
a144 1
static int AllowCommand(struct cmdargs const *);
d151 5
a156 1
static int AliasCommand(struct cmdargs const *);
d212 3
a214 1
      prompt_Printf(arg->prompt, " %s%-*.*s: %-*.*s",
d388 1
d391 1
d397 1
a397 1
    nargv[arg] = subst(nargv[arg], "INTERFACE", bundle->ifp.Name);
d408 1
d493 3
a495 2
    log_Printf(LogWARN, "exec() of %s failed\n",
              arg->argc > arg->argn ? arg->argv[arg->argn] : shell);
d526 63
d597 2
a598 2
  {"alias", NULL, AliasCommand, LOCAL_AUTH,
  "alias control", "alias option [yes|no]"},
d600 2
a601 2
  {"allow", "auth", AllowCommand, LOCAL_AUTH,
  "Allow ppp access", "allow users|modes ...."},
d624 2
d733 2
d1280 3
a1285 4

  if (arg->argc > arg->argn + 4)
    return -1;

d1307 1
a1307 3
  /*
   * For backwards compatibility, 0.0.0.0 means any address.
   */
a1313 5
  if (ipcp->cfg.peer_range.ipaddr.s_addr == INADDR_ANY) {
    ipcp->cfg.peer_range.mask.s_addr = INADDR_ANY;
    ipcp->cfg.peer_range.width = 0;
  }

d1349 11
a1359 7
    if (bundle_Phase(arg->bundle) == PHASE_DEAD) {
      strncpy(arg->bundle->cfg.auth.key, argp,
              sizeof arg->bundle->cfg.auth.key - 1);
      arg->bundle->cfg.auth.key[sizeof arg->bundle->cfg.auth.key - 1] = '\0';
    } else {
      err = "set authkey: Only available at phase DEAD\n";
      log_Printf(LogWARN, err);
d1364 11
a1374 7
    if (bundle_Phase(arg->bundle) == PHASE_DEAD) {
      strncpy(arg->bundle->cfg.auth.name, argp,
              sizeof arg->bundle->cfg.auth.name - 1);
      arg->bundle->cfg.auth.name[sizeof arg->bundle->cfg.auth.name - 1] = '\0';
    } else {
      err = "set authname: Only available at phase DEAD\n";
      log_Printf(LogWARN, err);
d1457 13
a1469 3
    if (bundle_Phase(arg->bundle) != PHASE_DEAD) {
      log_Printf(LogWARN, "mrru: Only changable at phase DEAD\n");
      return 1;
d1675 10
a1684 1
 
d1780 2
d1784 2
d1788 2
a1821 1

d1863 1
a1863 3
  } else if (strcasecmp(arg->argv[arg->argn+gw], "INTERFACE") == 0)
    gateway.s_addr = INADDR_ANY;
  else
a1909 45
static struct cmdtab const AliasCommands[] =
{
  {"addr", NULL, alias_RedirectAddr, LOCAL_AUTH,
   "static address translation", "alias addr [addr_local addr_alias]"},
  {"deny_incoming", NULL, AliasOption, LOCAL_AUTH,
   "stop incoming connections", "alias deny_incoming [yes|no]",
   (const void *) PKT_ALIAS_DENY_INCOMING},
  {"enable", NULL, AliasEnable, LOCAL_AUTH,
   "enable IP aliasing", "alias enable [yes|no]"},
  {"log", NULL, AliasOption, LOCAL_AUTH,
   "log aliasing link creation", "alias log [yes|no]",
   (const void *) PKT_ALIAS_LOG},
  {"port", NULL, alias_RedirectPort, LOCAL_AUTH,
   "port redirection", "alias port [proto addr_local:port_local  port_alias]"},
  {"same_ports", NULL, AliasOption, LOCAL_AUTH,
   "try to leave port numbers unchanged", "alias same_ports [yes|no]",
   (const void *) PKT_ALIAS_SAME_PORTS},
  {"unregistered_only", NULL, AliasOption, LOCAL_AUTH,
   "alias unregistered (private) IP address space only",
   "alias unregistered_only [yes|no]",
   (const void *) PKT_ALIAS_UNREGISTERED_ONLY},
  {"use_sockets", NULL, AliasOption, LOCAL_AUTH,
   "allocate host sockets", "alias use_sockets [yes|no]",
   (const void *) PKT_ALIAS_USE_SOCKETS},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
   "Display this message", "alias help|? [command]", AliasCommands},
  {NULL, NULL, NULL},
};


static int
AliasCommand(struct cmdargs const *arg)
{
  if (arg->argc > arg->argn)
    FindExec(arg->bundle, AliasCommands, arg->argc, arg->argn, arg->argv,
             arg->prompt, arg->cx);
  else if (arg->prompt)
    prompt_Printf(arg->prompt, "Use `alias help' to get a list or `alias help"
            " <option>' for syntax help.\n");
  else
    log_Printf(LogWARN, "alias command must have arguments\n");

  return 0;
}

d1919 2
a1952 26
static struct cmdtab const AllowCommands[] = {
  {"modes", "mode", AllowModes, LOCAL_AUTH,
  "Only allow certain ppp modes", "allow modes mode..."},
  {"users", "user", AllowUsers, LOCAL_AUTH,
  "Allow users access to ppp", "allow users logname..."},
  {"help", "?", HelpCommand, LOCAL_AUTH | LOCAL_NO_AUTH,
  "Display this message", "allow help|? [command]", AllowCommands},
  {NULL, NULL, NULL},
};

static int
AllowCommand(struct cmdargs const *arg)
{
  /* arg->bundle may be NULL (see system_IsValid()) ! */
  if (arg->argc > arg->argn)
    FindExec(arg->bundle, AllowCommands, arg->argc, arg->argn, arg->argv,
             arg->prompt, arg->cx);
  else if (arg->prompt)
    prompt_Printf(arg->prompt, "Use `allow ?' to get a list or `allow ? <cmd>'"
                  " for syntax help.\n");
  else
    log_Printf(LogWARN, "allow command must have arguments\n");

  return 0;
}

d2080 16
d2156 15
a2170 5
      if (bundle_Phase(arg->bundle) != PHASE_DEAD)
        log_Printf(LogWARN, "shortseq: Only changable at phase DEAD\n");
      else {
        arg->bundle->ncp.mp.cfg.shortseq &= keep;
        arg->bundle->ncp.mp.cfg.shortseq |= add;
d2172 2
d2187 3
d2194 1
a2194 1
  {"proxy", NULL, OptSet, LOCAL_AUTH, "Create proxy ARP entry",
d2196 2
d2205 1
a2205 1
#define OPT_MAX 7	/* accept/deny allowed below and not above */
d2322 140
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: command.c,v 1.165 1998/08/29 23:02:42 brian Exp $
a32 3
#ifndef NOALIAS
#include <alias.h>
#endif
d44 7
d134 1
a134 1
const char VersionDate[] = "$Date: 1998/08/29 23:02:42 $";
@

