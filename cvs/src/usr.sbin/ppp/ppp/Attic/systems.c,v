head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.28
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.24
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.22
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.20
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.18
	OPENBSD_5_0:1.20.0.16
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.14
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.12
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.8
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.10
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.18.0.22
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.20
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.18
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.16
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.14
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.12
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.10
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.8
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.6
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.4
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.20;

1.20
date	2008.03.02.19.31.43;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.02.18.46.33;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches
	1.18.20.1
	1.18.22.1;
next	1.17;

1.17
date	2001.06.13.21.33.42;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.24.01.06.06;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.12.23.14.32;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.03.19.56.35;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.28.15.13.09;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.19.10.33.34;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.27.01.38.29;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.05.24.09.05.39;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.05.09.20.04.03;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.05.08.11.06.40;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.03.09.20.37.39;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.02.06.03.22.48;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.02.02.09.50.14;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.10.31.17.38.51;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.10.29.02.21.46;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.28;	author brian;	state Exp;
branches;
next	;

1.18.20.1
date	2008.03.07.12.50.24;	author henning;	state Exp;
branches;
next	;

1.18.22.1
date	2008.03.07.12.49.27;	author henning;	state Exp;
branches;
next	;


desc
@@


1.21
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: systems.c,v 1.20 2008/03/02 19:31:43 deraadt Exp $
 */

#include <sys/param.h>

#include <ctype.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>

#include "defs.h"
#include "command.h"
#include "log.h"
#include "id.h"
#include "systems.h"

#define issep(ch) ((ch) == ' ' || (ch) == '\t')

FILE *
OpenSecret(const char *file)
{
  FILE *fp;
  char line[100];

  snprintf(line, sizeof line, "%s/%s", PPP_CONFDIR, file);
  fp = ID0fopen(line, "r");
  if (fp == NULL)
    log_Printf(LogWARN, "OpenSecret: Can't open %s.\n", line);
  return (fp);
}

void
CloseSecret(FILE *fp)
{
  fclose(fp);
}

/*
 * Move string from ``from'' to ``to'', interpreting ``~'' and $....
 * Returns NULL if string expansion failed due to lack of buffer space.
 */
const char *
InterpretArg(const char *from, char *to, size_t tosiz)
{
  char *ptr, *startto, *endto;
  struct passwd *pwd;
  int len, instring;
  const char *env;

  instring = 0;
  startto = to;
  endto = to + tosiz - 1;

  while(issep(*from))
    from++;

  while (*from != '\0') {
    if (to >= endto)
      return NULL;
    switch (*from) {
      case '"':
        instring = !instring;
        *to++ = *from++;
        break;
      case '\\':
        switch (*++from) {
          case '$':
          case '~':
            break;		/* Swallow the escapes */

          default:
            *to++ = '\\';	/* Pass the escapes on, maybe skipping \# */
            break;
        }
        if (to >= endto)
          return NULL;
        *to++ = *from++;
        break;
      case '$':
        if (from[1] == '$') {
          *to = '\0';	/* For an empty var name below */
          from += 2;
        } else if (from[1] == '{') {
          ptr = strchr(from+2, '}');
          if (ptr) {
            len = ptr - from - 2;
            if (endto - to < len)
              return NULL;
            if (len) {
              strncpy(to, from+2, len);
              to[len] = '\0';
              from = ptr+1;
            } else {
              *to++ = *from++;
              continue;
            }
          } else {
            *to++ = *from++;
            continue;
          }
        } else {
          ptr = to;
          for (from++; (isalnum(*from) || *from == '_') && ptr < endto; from++)
            *ptr++ = *from;
          *ptr = '\0';
        }
        if (to >= endto)
          return NULL;
        if (*to == '\0')
          *to++ = '$';
        else if ((env = getenv(to)) != NULL) {
          if (endto - to < strlen(env))
            return NULL;
          strncpy(to, env, endto - to);
          *endto = '\0';
          to += strlen(to);
        }
        break;

      case '~':
        ptr = strchr(++from, '/');
        len = ptr ? ptr - from : strlen(from);
        if (len == 0)
          pwd = getpwuid(ID0realuid());
        else {
          if (endto - to < len)
            return NULL;
          strncpy(to, from, len);
          to[len] = '\0';
          pwd = getpwnam(to);
        }
        if (to >= endto)
          return NULL;
        if (pwd == NULL)
          *to++ = '~';
        else {
          if (endto - to < strlen(pwd->pw_dir))
            return NULL;
          strncpy(to, pwd->pw_dir, endto - to);
          *endto = '\0';
          to += strlen(to);
          from += len;
        }
        break;

      default:
        *to++ = *from++;
        break;
    }
  }

  while (to > startto) {
    to--;
    if (!issep(*to)) {
      to++;
      break;
    }
  }
  *to = '\0';

  return from;
}

#define CTRL_UNKNOWN (0)
#define CTRL_INCLUDE (1)

static int
DecodeCtrlCommand(char *line, char *arg, size_t argsiz)
{
  const char *end;

  if (!strncasecmp(line, "include", 7) && issep(line[7])) {
    end = InterpretArg(line+8, arg, argsiz);
    if (end == NULL) {
      log_Printf(LogWARN, "Failed to expand command '%s': too long for the destination buffer\n", line);
      return CTRL_UNKNOWN;
    }
    if (*end && *end != '#')
      log_Printf(LogWARN, "usage: !include filename\n");
    else
      return CTRL_INCLUDE;
  }
  return CTRL_UNKNOWN;
}

/*
 * Initialised in system_IsValid(), set in ReadSystem(),
 * used by system_IsValid()
 */
static int modeok;
static int userok;
static int modereq;

int
AllowUsers(struct cmdargs const *arg)
{
  /* arg->bundle may be NULL (see system_IsValid()) ! */
  int f;
  struct passwd *pwd;

  if (userok == -1)
    userok = 0;

  pwd = getpwuid(ID0realuid());
  if (pwd != NULL)
    for (f = arg->argn; f < arg->argc; f++)
      if (!strcmp("*", arg->argv[f]) || !strcmp(pwd->pw_name, arg->argv[f])) {
        userok = 1;
        break;
      }

  return 0;
}

int
AllowModes(struct cmdargs const *arg)
{
  /* arg->bundle may be NULL (see system_IsValid()) ! */
  int f, mode, allowed;

  allowed = 0;
  for (f = arg->argn; f < arg->argc; f++) {
    mode = Nam2mode(arg->argv[f]);
    if (mode == PHYS_NONE || mode == PHYS_ALL)
      log_Printf(LogWARN, "allow modes: %s: Invalid mode\n", arg->argv[f]);
    else
      allowed |= mode;
  }

  modeok = modereq & allowed ? 1 : 0;
  return 0;
}

static char *
strip(char *line)
{
  int len;

  len = strlen(line);
  while (len && (line[len-1] == '\n' || line[len-1] == '\r' ||
                 issep(line[len-1])))
    line[--len] = '\0';

  while (issep(*line))
    line++;

  if (*line == '#')
    *line = '\0';

  return line;
}

static int
xgets(char *buf, int buflen, FILE *fp)
{
  int len, n;

  n = 0;
  while (fgets(buf, buflen-1, fp)) {
    n++;
    buf[buflen-1] = '\0';
    len = strlen(buf);
    while (len && (buf[len-1] == '\n' || buf[len-1] == '\r'))
      buf[--len] = '\0';
    if (len && buf[len-1] == '\\') {
      buf += len - 1;
      buflen -= len - 1;
      if (!buflen)        /* No buffer space */
        break;
    } else
      break;
  }
  return n;
}

/* Values for ``how'' in ReadSystem */
#define SYSTEM_EXISTS	1
#define SYSTEM_VALIDATE	2
#define SYSTEM_EXEC	3

static char *
GetLabel(char *line, const char *filename, int linenum)
{
  char *argv[MAXARGS];
  int argc, len;

  argc = MakeArgs(line, argv, MAXARGS, PARSE_REDUCE);

  if (argc == 2 && !strcmp(argv[1], ":"))
    return argv[0];

  if (argc != 1 || (len = strlen(argv[0])) < 2 || argv[0][len-1] != ':') {
      log_Printf(LogWARN, "Bad label in %s (line %d) - missing colon\n",
                 filename, linenum);
      return NULL;
  }
  argv[0][len-1] = '\0';	/* Lose the ':' */

  return argv[0];
}

/* Returns -2 for ``file not found'' and -1 for ``label not found'' */

static int
ReadSystem(struct bundle *bundle, const char *name, const char *file,
           struct prompt *prompt, struct datalink *cx, int how)
{
  FILE *fp;
  char *cp;
  int n, len;
  char line[LINE_LEN];
  char filename[PATH_MAX];
  int linenum;
  int argc;
  char *argv[MAXARGS];
  int allowcmd;
  int indent;
  char arg[LINE_LEN];
  struct prompt *op;

  if (*file == '/')
    snprintf(filename, sizeof filename, "%s", file);
  else
    snprintf(filename, sizeof filename, "%s/%s", PPP_CONFDIR, file);
  fp = ID0fopen(filename, "r");
  if (fp == NULL) {
    log_Printf(LogDEBUG, "ReadSystem: Can't open %s.\n", filename);
    return -2;
  }
  log_Printf(LogDEBUG, "ReadSystem: Checking %s (%s).\n", name, filename);

  linenum = 0;
  while ((n = xgets(line, sizeof line, fp))) {
    linenum += n;
    if (issep(*line))
      continue;

    cp = strip(line);

    switch (*cp) {
    case '\0':			/* empty/comment */
      break;

    case '!':
      switch (DecodeCtrlCommand(cp+1, arg, LINE_LEN)) {
      case CTRL_INCLUDE:
        log_Printf(LogCOMMAND, "%s: Including \"%s\"\n", filename, arg);
        n = ReadSystem(bundle, name, arg, prompt, cx, how);
        log_Printf(LogCOMMAND, "%s: Done include of \"%s\"\n", filename, arg);
        if (!n) {
          fclose(fp);
          return 0;	/* got it */
        }
        break;
      default:
        log_Printf(LogWARN, "%s: %s: Invalid command\n", filename, cp);
        break;
      }
      break;

    default:
      if ((cp = GetLabel(cp, filename, linenum)) == NULL)
        continue;

      if (strcmp(cp, name) == 0) {
        /* We're in business */
        if (how == SYSTEM_EXISTS) {
          fclose(fp);
	  return 0;
	}
	while ((n = xgets(line, sizeof line, fp))) {
          linenum += n;
          indent = issep(*line);
          cp = strip(line);

          if (*cp == '\0')			/* empty / comment */
            continue;

          if (!indent) {			/* start of next section */
            if (*cp != '!' && how == SYSTEM_EXEC)
              cp = GetLabel(cp, filename, linenum);
            break;
          }

          len = strlen(cp);
          if ((argc = command_Expand_Interpret(cp, len, argv, cp - line)) < 0)
            log_Printf(LogWARN, "%s: %d: Syntax error\n", filename, linenum);
          else {
            allowcmd = argc > 0 && !strcasecmp(argv[0], "allow");
            if ((how != SYSTEM_EXEC && allowcmd) ||
                (how == SYSTEM_EXEC && !allowcmd)) {
              /*
               * Disable any context so that warnings are given to everyone,
               * including syslog.
               */
              op = log_PromptContext;
              log_PromptContext = NULL;
	      command_Run(bundle, argc, (char const *const *)argv, prompt,
                          name, cx);
              log_PromptContext = op;
            }
          }
        }

	fclose(fp);  /* everything read - get out */
	return 0;
      }
      break;
    }
  }
  fclose(fp);
  return -1;
}

const char *
system_IsValid(const char *name, struct prompt *prompt, int mode)
{
  /*
   * Note:  The ReadSystem() calls only result in calls to the Allow*
   * functions.  arg->bundle will be set to NULL for these commands !
   */
  int def, how, rs;
  int defuserok;

  def = !strcmp(name, "default");
  how = ID0realuid() == 0 ? SYSTEM_EXISTS : SYSTEM_VALIDATE;
  userok = -1;
  modeok = 1;
  modereq = mode;

  rs = ReadSystem(NULL, "default", CONFFILE, prompt, NULL, how);

  defuserok = userok;
  userok = -1;

  if (!def) {
    if (rs == -1)
      rs = 0;		/* we don't care that ``default'' doesn't exist */

    if (rs == 0)
      rs = ReadSystem(NULL, name, CONFFILE, prompt, NULL, how);

    if (rs == -1)
      return "Configuration label not found";

    if (rs == -2)
      return PPP_CONFDIR "/" CONFFILE " : File not found";
  }

  if (userok == -1)
    userok = defuserok;

  if (how == SYSTEM_EXISTS)
    userok = modeok = 1;

  if (!userok)
    return "User access denied";

  if (!modeok)
    return "Mode denied for this label";

  return NULL;
}

int
system_Select(struct bundle *bundle, const char *name, const char *file,
             struct prompt *prompt, struct datalink *cx)
{
  userok = modeok = 1;
  modereq = PHYS_ALL;
  return ReadSystem(bundle, name, file, prompt, cx, SYSTEM_EXEC);
}
@


1.20
log
@another extra endpwent() not needed
@
text
@d28 1
a28 1
 * $OpenBSD: systems.c,v 1.19 2008/03/02 18:46:33 miod Exp $
@


1.19
log
@Pass a buffer size to InterpretArg() and do not let it overflow it, saves
propolice some work in command_Expand_Interpret().

Inspired by FreeBSD; ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: systems.c,v 1.18 2002/05/16 01:13:39 brian Exp $
a239 1
  endpwent();
@


1.18
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: systems.c,v 1.17 2001/06/13 21:33:42 brian Exp $
d67 4
a70 1
/* Move string from ``from'' to ``to'', interpreting ``~'' and $.... */
d72 1
a72 1
InterpretArg(const char *from, char *to)
d81 1
a81 1
  endto = to + LINE_LEN - 1;
d87 2
d104 2
d116 2
a117 2
            if (endto - to < len )
              len = endto - to;
d136 2
d141 2
d155 2
d161 2
d166 2
a172 1
        endpwent();
d197 1
a197 1
DecodeCtrlCommand(char *line, char *arg)
d202 5
a206 1
    end = InterpretArg(line+8, arg);
d375 1
a375 1
      switch (DecodeCtrlCommand(cp+1, arg)) {
@


1.18.20.1
log
@MFC (miod):
Pass a buffer size to InterpretArg() and do not let it overflow it, saves
propolice some work in command_Expand_Interpret().
Inspired by FreeBSD; ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: systems.c,v 1.20 2008/03/02 19:31:43 deraadt Exp $
d67 1
a67 4
/*
 * Move string from ``from'' to ``to'', interpreting ``~'' and $....
 * Returns NULL if string expansion failed due to lack of buffer space.
 */
d69 1
a69 1
InterpretArg(const char *from, char *to, size_t tosiz)
d78 1
a78 1
  endto = to + tosiz - 1;
a83 2
    if (to >= endto)
      return NULL;
a98 2
        if (to >= endto)
          return NULL;
d109 2
a110 2
            if (endto - to < len)
              return NULL;
a128 2
        if (to >= endto)
          return NULL;
a131 2
          if (endto - to < strlen(env))
            return NULL;
a143 2
          if (endto - to < len)
            return NULL;
a147 2
        if (to >= endto)
          return NULL;
a150 2
          if (endto - to < strlen(pwd->pw_dir))
            return NULL;
d156 1
d181 1
a181 1
DecodeCtrlCommand(char *line, char *arg, size_t argsiz)
d186 1
a186 5
    end = InterpretArg(line+8, arg, argsiz);
    if (end == NULL) {
      log_Printf(LogWARN, "Failed to expand command '%s': too long for the destination buffer\n", line);
      return CTRL_UNKNOWN;
    }
d220 1
d355 1
a355 1
      switch (DecodeCtrlCommand(cp+1, arg, LINE_LEN)) {
@


1.18.22.1
log
@MFC (miod):
Pass a buffer size to InterpretArg() and do not let it overflow it, saves
propolice some work in command_Expand_Interpret().
Inspired by FreeBSD; ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: systems.c,v 1.20 2008/03/02 19:31:43 deraadt Exp $
d67 1
a67 4
/*
 * Move string from ``from'' to ``to'', interpreting ``~'' and $....
 * Returns NULL if string expansion failed due to lack of buffer space.
 */
d69 1
a69 1
InterpretArg(const char *from, char *to, size_t tosiz)
d78 1
a78 1
  endto = to + tosiz - 1;
a83 2
    if (to >= endto)
      return NULL;
a98 2
        if (to >= endto)
          return NULL;
d109 2
a110 2
            if (endto - to < len)
              return NULL;
a128 2
        if (to >= endto)
          return NULL;
a131 2
          if (endto - to < strlen(env))
            return NULL;
a143 2
          if (endto - to < len)
            return NULL;
a147 2
        if (to >= endto)
          return NULL;
a150 2
          if (endto - to < strlen(pwd->pw_dir))
            return NULL;
d156 1
d181 1
a181 1
DecodeCtrlCommand(char *line, char *arg, size_t argsiz)
d186 1
a186 5
    end = InterpretArg(line+8, arg, argsiz);
    if (end == NULL) {
      log_Printf(LogWARN, "Failed to expand command '%s': too long for the destination buffer\n", line);
      return CTRL_UNKNOWN;
    }
d220 1
d355 1
a355 1
      switch (DecodeCtrlCommand(cp+1, arg, LINE_LEN)) {
@


1.17
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
a38 1
#include <unistd.h>
d188 1
a188 1
      log_Printf(LogWARN, "Usage: !include filename\n");
@


1.16
log
@Remove some unprotected prototype variable names
MAXPATHLEN -> PATH_MAX
Handle ENOENT from opening /dev/tun* properly
Rename _PATH_PPP -> PPP_CONFDIR and allow it to be redefined at compile time
Reduce MIN_LQRPERIOD and MIN_FSMRETRY to 1 second
Be smarter about identifying sockets on stdin
Allow primary DNS IP negotiation when the secondary IP has been rejected
Fix the call to PacketAliasProxyRule() properly.
Add/fix some comments
Fix man page markups; ru@@FreeBSD.org
Use localhost when no hostname is configured
@
text
@d1 5
a5 2
/*
 *	          System configuration routines
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 15
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: systems.c,v 1.15 2000/07/12 23:14:32 brian Exp $
 *
 *  TODO:
d30 1
@


1.15
log
@Permit multiple ``allow user'' lines in any given section
This avoids line length limits when large numbers of users are allowed
access to ppp.
@
text
@d20 1
a20 1
 * $OpenBSD: systems.c,v 1.14 2000/04/03 19:56:35 brian Exp $
d48 1
a48 1
  snprintf(line, sizeof line, "%s/%s", _PATH_PPP, file);
d316 1
a316 1
  char filename[MAXPATHLEN];
d328 1
a328 1
    snprintf(filename, sizeof filename, "%s/%s", _PATH_PPP, file);
d451 1
a451 1
      return _PATH_PPP "/" CONFFILE ": File not found";
@


1.14
log
@Plug two file descriptor leaks
@
text
@d20 1
a20 1
 * $OpenBSD: systems.c,v 1.13 2000/03/28 15:13:09 brian Exp $
d204 3
a206 1
  userok = 0;
d427 1
d431 1
a431 1
  userok = 0;
d437 3
d453 3
@


1.13
log
@Don't treat # specially here
@
text
@d20 1
a20 1
 * $OpenBSD: systems.c,v 1.12 2000/03/19 10:33:34 brian Exp $
d352 2
a353 1
        if (!n)
d355 1
d369 2
a370 1
        if (how == SYSTEM_EXISTS)
d372 1
@


1.12
log
@Allow environment variables on command/config lines; markk@@knigma.org
Add the ``resolv'' command so that when ``enable dns''
is used, it's possible to restore the file.
@
text
@d20 1
a20 1
 * $OpenBSD: systems.c,v 1.11 2000/02/27 01:38:29 brian Exp $
a150 6
        break;

      case '#':
        if (!instring)
          while (*from != '\0')
            *to++ = *from++;
@


1.11
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: systems.c,v 1.10 2000/01/07 03:26:55 brian Exp $
d62 1
a62 1
static const char *
d65 3
a68 2
  char *ptr, *startto, *endto;
  int len;
d70 1
d77 11
a87 2
  if (*from == '~') {
    struct passwd *pwd;
d89 24
a112 32
    ptr = strchr(++from, '/');
    len = ptr ? ptr - from : strlen(from);
    if (len == 0) {
      pwd = getpwuid(ID0realuid());
    } else {
      strncpy(to, from, len);
      to[len] = '\0';
      pwd = getpwnam(to);
    }
    strncpy(to, pwd ? pwd->pw_dir : _PATH_PPP, endto - to);
    endpwent();

    *endto = '\0';
    to += strlen(to);
    from += len;
  }

  while (to < endto && !issep(*from) && *from != '#' && *from != '\0') {
    if (*from == '$') {
      if (from[1] == '$') {
        *to = '\0';	/* For an empty var name below */
        from += 2;
      } else if (from[1] == '{') {
        ptr = strchr(from+2, '}');
        if (ptr) {
          len = ptr - from - 2;
          if (endto - to < len )
            len = endto - to;
          if (len) {
            strncpy(to, from+2, len);
            to[len] = '\0';
            from = ptr+1;
d118 23
a140 2
          *to++ = *from++;
          continue;
d142 20
a161 17
      } else {
        ptr = to;
        for (from++; (isalnum(*from) || *from == '_') && ptr < endto; from++)
          *ptr++ = *from;
        *ptr = '\0';
      }
      if (*to == '\0')
        *to++ = '$';
      else if ((env = getenv(to)) != NULL) {
        strncpy(to, env, endto - to);
        *endto = '\0';
        to += strlen(to);
      }
    } else {
      if (*from == '\\')
        from++;
      *to++ = *from++;
a173 3
  while (issep(*from))
    from++;

d390 1
a390 1
          if ((argc = command_Interpret(cp, len, argv)) < 0)
@


1.10
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: systems.c,v 1.9 1999/05/24 09:05:39 brian Exp $
@


1.9
log
@Don't warn about ``!'' lines being unindented commands in ppp.conf.
@
text
@d20 1
a20 1
 * $Id: systems.c,v 1.8 1999/05/09 20:04:03 brian Exp $
d62 2
a63 2
static void
InterpretArg(char *from, char *to)
d74 1
d76 2
d81 1
a81 3
      if ((env = getenv("HOME")) == NULL)
        env = _PATH_PPP;
      strncpy(to, env, endto - to);
a82 2
      struct passwd *pwd;

a85 5
      if (pwd)
        strncpy(to, pwd->pw_dir, endto-to);
      else
        strncpy(to, _PATH_PPP, endto - to);
      endpwent();
d87 3
d95 1
a95 1
  while (to < endto && *from != '\0') {
d131 3
a133 1
    } else
d135 1
d137 1
d146 5
d159 2
d162 5
a166 2
    InterpretArg(line+8, arg);
    return CTRL_INCLUDE;
d184 1
a184 1
  char *user;
d187 2
a188 2
  user = getlogin();
  if (user && *user)
d190 1
a190 1
      if (!strcmp("*", arg->argv[f]) || !strcmp(user, arg->argv[f])) {
d194 1
d265 21
d293 1
a293 1
  char *cp, *wp;
d303 1
d344 2
a345 8
      wp = strchr(cp, ':');
      if (wp == NULL || wp[1] != '\0') {
	log_Printf(LogWARN, "Bad rule in %s (line %d) - missing colon.\n",
		  filename, linenum);
	continue;
      }
      *wp = '\0';
      cp = strip(cp);  /* lose any spaces between the label and the ':' */
d356 1
a356 1
          if (*cp == '\0')  /* empty / comment */
d359 3
a361 7
          if (!indent) {    /* start of next section */
            if (*cp != '!') {
              wp = strchr(cp, ':');
              if ((how == SYSTEM_EXEC) && (wp == NULL || wp[1] != '\0'))
	        log_Printf(LogWARN, "Unindented command (%s line %d) -"
                           " ignored\n", filename, linenum);
            }
d366 17
a382 6
          argc = command_Interpret(cp, len, argv);
          allowcmd = argc > 0 && !strcasecmp(argv[0], "allow");
          if ((!(how == SYSTEM_EXEC) && allowcmd) ||
              ((how == SYSTEM_EXEC) && !allowcmd))
	    command_Run(bundle, argc, (char const *const *)argv, prompt,
                        name, cx);
@


1.8
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d20 1
a20 1
 * $Id: systems.c,v 1.7 1999/05/08 11:06:40 brian Exp $
d332 6
a337 4
            wp = strchr(cp, ':');
            if ((how == SYSTEM_EXEC) && (wp == NULL || wp[1] != '\0'))
	      log_Printf(LogWARN, "Unindented command (%s line %d) - ignored\n",
		         filename, linenum);
@


1.7
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: systems.c,v 1.6 1999/03/09 20:37:39 brian Exp $
d56 1
a56 1
CloseSecret(FILE * fp)
@


1.6
log
@If /etc/ppp/ppp.conf doesn't exist, mention that the
configuration file can't be found rather than saying
that the label can't be found.
Pointed out by: Greg Black <gjb@@comkey.com.au>
@
text
@d20 1
a20 1
 * $Id: systems.c,v 1.5 1999/02/06 03:22:48 brian Exp $
d31 1
@


1.5
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: systems.c,v 1.41 1999/02/02 09:35:30 brian Exp $
d252 2
d277 1
a277 1
    return (-1);
d364 1
a364 1
  int def, how;
d372 8
a379 2
  if (ReadSystem(NULL, "default", CONFFILE, prompt, NULL, how) != 0 && def)
    return "Configuration label not found";
d381 6
a386 2
  if (!def && ReadSystem(NULL, name, CONFFILE, prompt, NULL, how) != 0)
    return "Configuration label not found";
@


1.4
log
@Don't allow root to specify non-existent labels on
the command line.
Revise the error diagnostics so that invalid labels
are reported immediately.
@
text
@d20 1
a20 1
 * $Id: systems.c,v 1.3 1998/10/31 17:38:51 brian Exp $
@


1.3
log
@Allow multiple systems (config labels) on the command
line and in the ``load'' & ``dial'' commands.  The last
label loaded becomes the current label name.
Only require a label for -auto mode.
@
text
@d20 1
a20 1
 * $Id: systems.c,v 1.2 1998/10/29 02:21:46 brian Exp $
d247 5
d254 1
a254 1
           int doexec, struct prompt *prompt, struct datalink *cx)
d295 1
a295 1
        n = ReadSystem(bundle, name, arg, doexec, prompt, cx);
d318 2
d330 1
a330 1
            if (doexec && (wp == NULL || wp[1] != '\0'))
d339 2
a340 1
          if ((!doexec && allowcmd) || (doexec && !allowcmd))
d362 1
a362 6
  int def;

  if (ID0realuid() == 0) {
    userok = modeok = 1;
    return NULL;
  }
d365 1
d370 5
a374 2
  if (ReadSystem(NULL, "default", CONFFILE, 0, prompt, NULL) != 0 && def)
    return "System not found";
d376 2
a377 2
  if (!def && ReadSystem(NULL, name, CONFFILE, 0, prompt, NULL) != 0)
    return "System not found";
d380 1
a380 1
    return "Invalid user id";
d383 1
a383 1
    return "Invalid mode";
d394 1
a394 1
  return ReadSystem(bundle, name, file, 1, prompt, cx);
@


1.2
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d20 1
a20 1
 * $Id: systems.c,v 1.1 1998/08/31 00:22:28 brian Exp $
d159 4
a162 1
/* Initialised in system_IsValid(), set in ReadSystem(), used by system_IsValid() */
d347 1
a347 1
int
d354 8
a361 2
  if (ID0realuid() == 0)
    return userok = modeok = 1;
d365 14
a378 4
  ReadSystem(NULL, "default", CONFFILE, 0, prompt, NULL);
  if (name != NULL)
    ReadSystem(NULL, name, CONFFILE, 0, prompt, NULL);
  return userok && modeok;
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: systems.c,v 1.38 1998/06/15 19:06:25 brian Exp $
d318 5
a322 1
          if (!indent)      /* start of next section */
d324 1
@

