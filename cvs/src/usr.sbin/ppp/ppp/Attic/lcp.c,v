head	1.44;
access;
symbols
	OPENBSD_5_5:1.43.0.20
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.16
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.14
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.12
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.10
	OPENBSD_5_0:1.43.0.8
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.6
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.4
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.42.0.14
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.10
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.42.0.8
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.42.0.6
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.42.0.4
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.6
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.41.0.4
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.39.0.4
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.38.0.4
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	OPENBSD_3_3:1.37.0.4
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	OPENBSD_3_0:1.32.0.2
	OPENBSD_3_0_BASE:1.32
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.44
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.43;

1.43
date	2009.12.11.18.15.17;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2006.12.11.16.31.35;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.17.19.13.24;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.17.07.33.22;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.26.20.12.48;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.07.23.58.53;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.23.11.17.03;	author brian;	state Exp;
branches;
next	1.33;

1.33
date	2001.10.24.10.01.15;	author brian;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.30.18.59.20;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.26.11.36.51;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.17.01.07.00;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.03.22.23.54;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.19.10.24.55;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.14.13.24.02;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.22.02.13.09;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.02.00.54.34;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.19.11.06.34;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.24.23.38.30;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.27.00.21.08;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	99.06.09.20.32.37;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	99.06.09.16.55.25;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	99.06.02.15.58.40;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	99.05.09.20.04.01;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.05.08.11.06.36;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.04.19.16.59.39;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.03.29.08.20.44;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.03.01.13.47.58;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.02.26.21.28.23;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.02.18.00.50.45;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.02.06.03.22.40;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.01.13.17.39.57;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	98.10.29.02.21.45;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.09.09.00.07.10;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.09.04.18.27.46;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.22;	author brian;	state Exp;
branches;
next	;


desc
@@


1.44
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: lcp.c,v 1.43 2009/12/11 18:15:17 oga Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "ua.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "iplist.h"
#include "throughput.h"
#include "proto.h"
#include "descriptor.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "ccp.h"
#include "async.h"
#include "link.h"
#include "physical.h"
#include "prompt.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "mp.h"
#include "chat.h"
#include "auth.h"
#include "chap.h"
#include "cbcp.h"
#include "datalink.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"

/* for received LQRs */
struct lqrreq {
  struct fsm_opt_hdr hdr;
  u_short proto;		/* Quality protocol */
  u_int32_t period;		/* Reporting interval */
};

static int LcpLayerUp(struct fsm *);
static void LcpLayerDown(struct fsm *);
static void LcpLayerStart(struct fsm *);
static void LcpLayerFinish(struct fsm *);
static void LcpInitRestartCounter(struct fsm *, int);
static void LcpSendConfigReq(struct fsm *);
static void LcpSentTerminateReq(struct fsm *);
static void LcpSendTerminateAck(struct fsm *, u_char);
static void LcpDecodeConfig(struct fsm *, u_char *, u_char *, int,
                            struct fsm_decode *);

static struct fsm_callbacks lcp_Callbacks = {
  LcpLayerUp,
  LcpLayerDown,
  LcpLayerStart,
  LcpLayerFinish,
  LcpInitRestartCounter,
  LcpSendConfigReq,
  LcpSentTerminateReq,
  LcpSendTerminateAck,
  LcpDecodeConfig,
  fsm_NullRecvResetReq,
  fsm_NullRecvResetAck
};

static const char * const lcp_TimerNames[] =
  {"LCP restart", "LCP openmode", "LCP stopped"};

static const char *
protoname(int proto)
{
  static const char * const cftypes[] = {
    /* Check out the latest ``Assigned numbers'' rfc (1700) */
    NULL,
    "MRU",		/* 1: Maximum-Receive-Unit */
    "ACCMAP",		/* 2: Async-Control-Character-Map */
    "AUTHPROTO",	/* 3: Authentication-Protocol */
    "QUALPROTO",	/* 4: Quality-Protocol */
    "MAGICNUM",		/* 5: Magic-Number */
    "RESERVED",		/* 6: RESERVED */
    "PROTOCOMP",	/* 7: Protocol-Field-Compression */
    "ACFCOMP",		/* 8: Address-and-Control-Field-Compression */
    "FCSALT",		/* 9: FCS-Alternatives */
    "SDP",		/* 10: Self-Describing-Pad */
    "NUMMODE",		/* 11: Numbered-Mode */
    "MULTIPROC",	/* 12: Multi-Link-Procedure */
    "CALLBACK",		/* 13: Callback */
    "CONTIME",		/* 14: Connect-Time */
    "COMPFRAME",	/* 15: Compound-Frames */
    "NDE",		/* 16: Nominal-Data-Encapsulation */
    "MRRU",		/* 17: Multilink-MRRU */
    "SHORTSEQ",		/* 18: Multilink-Short-Sequence-Number-Header */
    "ENDDISC",		/* 19: Multilink-Endpoint-Discriminator */
    "PROPRIETRY",	/* 20: Proprietary */
    "DCEID",		/* 21: DCE-Identifier */
    "MULTIPP",		/* 22: Multi-Link-Plus-Procedure */
    "LDBACP",		/* 23: Link Discriminator for BACP */
  };

  if (proto < 0 || proto >= sizeof cftypes / sizeof *cftypes ||
      cftypes[proto] == NULL)
    return HexStr(proto, NULL, 0);

  return cftypes[proto];
}

int
lcp_ReportStatus(struct cmdargs const *arg)
{
  struct link *l;
  struct lcp *lcp;

  l = command_ChooseLink(arg);
  lcp = &l->lcp;

  prompt_Printf(arg->prompt, "%s: %s [%s]\n", l->name, lcp->fsm.name,
                State2Nam(lcp->fsm.state));
  prompt_Printf(arg->prompt,
                " his side: MRU %d, ACCMAP %08lx, PROTOCOMP %s, ACFCOMP %s,\n"
                "           MAGIC %08lx, MRRU %u, SHORTSEQ %s, REJECT %04x\n",
                lcp->his_mru, (u_long)lcp->his_accmap,
                lcp->his_protocomp ? "on" : "off",
                lcp->his_acfcomp ? "on" : "off",
                (u_long)lcp->his_magic, lcp->his_mrru,
                lcp->his_shortseq ? "on" : "off", lcp->his_reject);
  prompt_Printf(arg->prompt,
                " my  side: MRU %d, ACCMAP %08lx, PROTOCOMP %s, ACFCOMP %s,\n"
                "           MAGIC %08lx, MRRU %u, SHORTSEQ %s, REJECT %04x\n",
                lcp->want_mru, (u_long)lcp->want_accmap,
                lcp->want_protocomp ? "on" : "off",
                lcp->want_acfcomp ? "on" : "off",
                (u_long)lcp->want_magic, lcp->want_mrru,
                lcp->want_shortseq ? "on" : "off", lcp->my_reject);

  if (lcp->cfg.mru)
    prompt_Printf(arg->prompt, "\n Defaults: MRU = %d (max %d), ",
                  lcp->cfg.mru, lcp->cfg.max_mru);
  else
    prompt_Printf(arg->prompt, "\n Defaults: MRU = any (max %d), ",
                  lcp->cfg.max_mru);
  if (lcp->cfg.mtu)
    prompt_Printf(arg->prompt, "MTU = %d (max %d), ",
                  lcp->cfg.mtu, lcp->cfg.max_mtu);
  else
    prompt_Printf(arg->prompt, "MTU = any (max %d), ", lcp->cfg.max_mtu);
  prompt_Printf(arg->prompt, "ACCMAP = %08lx\n", (u_long)lcp->cfg.accmap);
  prompt_Printf(arg->prompt, "           LQR period = %us, ",
                lcp->cfg.lqrperiod);
  prompt_Printf(arg->prompt, "Open Mode = %s",
                lcp->cfg.openmode == OPEN_PASSIVE ? "passive" : "active");
  if (lcp->cfg.openmode > 0)
    prompt_Printf(arg->prompt, " (delay %ds)", lcp->cfg.openmode);
  prompt_Printf(arg->prompt, "\n           FSM retry = %us, max %u Config"
                " REQ%s, %u Term REQ%s\n", lcp->cfg.fsm.timeout,
                lcp->cfg.fsm.maxreq, lcp->cfg.fsm.maxreq == 1 ? "" : "s",
                lcp->cfg.fsm.maxtrm, lcp->cfg.fsm.maxtrm == 1 ? "" : "s");
  prompt_Printf(arg->prompt, "    Ident: %s\n", lcp->cfg.ident);
  prompt_Printf(arg->prompt, "\n Negotiation:\n");
  prompt_Printf(arg->prompt, "           ACFCOMP =   %s\n",
                command_ShowNegval(lcp->cfg.acfcomp));
  prompt_Printf(arg->prompt, "           CHAP =      %s\n",
                command_ShowNegval(lcp->cfg.chap05));
#ifndef NODES
  prompt_Printf(arg->prompt, "           CHAP80 =    %s\n",
                command_ShowNegval(lcp->cfg.chap80nt));
  prompt_Printf(arg->prompt, "           LANMan =    %s\n",
                command_ShowNegval(lcp->cfg.chap80lm));
  prompt_Printf(arg->prompt, "           CHAP81 =    %s\n",
                command_ShowNegval(lcp->cfg.chap81));
#endif
  prompt_Printf(arg->prompt, "           LQR =       %s\n",
                command_ShowNegval(lcp->cfg.lqr));
  prompt_Printf(arg->prompt, "           LCP ECHO =  %s\n",
                lcp->cfg.echo ? "enabled" : "disabled");
  prompt_Printf(arg->prompt, "           PAP =       %s\n",
                command_ShowNegval(lcp->cfg.pap));
  prompt_Printf(arg->prompt, "           PROTOCOMP = %s\n",
                command_ShowNegval(lcp->cfg.protocomp));

  return 0;
}

static u_int32_t
GenerateMagic(void)
{
  /* Generate random number which will be used as magic number */
  randinit();
  return random();
}

void
lcp_SetupCallbacks(struct lcp *lcp)
{
  lcp->fsm.fn = &lcp_Callbacks;
  lcp->fsm.FsmTimer.name = lcp_TimerNames[0];
  lcp->fsm.OpenTimer.name = lcp_TimerNames[1];
  lcp->fsm.StoppedTimer.name = lcp_TimerNames[2];
}

void
lcp_Init(struct lcp *lcp, struct bundle *bundle, struct link *l,
         const struct fsm_parent *parent)
{
  /* Initialise ourselves */
  int mincode = parent ? 1 : LCP_MINMPCODE;

  fsm_Init(&lcp->fsm, "LCP", PROTO_LCP, mincode, LCP_MAXCODE, LogLCP,
           bundle, l, parent, &lcp_Callbacks, lcp_TimerNames);

  lcp->cfg.mru = 0;
  lcp->cfg.max_mru = MAX_MRU;
  lcp->cfg.mtu = 0;
  lcp->cfg.max_mtu = MAX_MTU;
  lcp->cfg.accmap = 0;
  lcp->cfg.openmode = 1;
  lcp->cfg.lqrperiod = DEF_LQRPERIOD;
  lcp->cfg.fsm.timeout = DEF_FSMRETRY;
  lcp->cfg.fsm.maxreq = DEF_FSMTRIES;
  lcp->cfg.fsm.maxtrm = DEF_FSMTRIES;

  lcp->cfg.acfcomp = NEG_ENABLED|NEG_ACCEPTED;
  lcp->cfg.chap05 = NEG_ACCEPTED;
#ifndef NODES
  lcp->cfg.chap80nt = NEG_ACCEPTED;
  lcp->cfg.chap80lm = 0;
  lcp->cfg.chap81 = NEG_ACCEPTED;
#endif
  lcp->cfg.lqr = NEG_ACCEPTED;
  lcp->cfg.echo = 0;
  lcp->cfg.pap = NEG_ACCEPTED;
  lcp->cfg.protocomp = NEG_ENABLED|NEG_ACCEPTED;
  *lcp->cfg.ident = '\0';

  lcp_Setup(lcp, lcp->cfg.openmode);
}

void
lcp_Setup(struct lcp *lcp, int openmode)
{
  struct physical *p = link2physical(lcp->fsm.link);

  lcp->fsm.open_mode = openmode;

  lcp->his_mru = DEF_MRU;
  lcp->his_mrru = 0;
  lcp->his_magic = 0;
  lcp->his_lqrperiod = 0;
  lcp->his_acfcomp = 0;
  lcp->his_auth = 0;
  lcp->his_authtype = 0;
  lcp->his_callback.opmask = 0;
  lcp->his_shortseq = 0;
  lcp->mru_req = 0;

  if ((lcp->want_mru = lcp->cfg.mru) == 0)
    lcp->want_mru = DEF_MRU;
  lcp->want_mrru = lcp->fsm.bundle->ncp.mp.cfg.mrru;
  lcp->want_shortseq = IsEnabled(lcp->fsm.bundle->ncp.mp.cfg.shortseq) ? 1 : 0;
  lcp->want_acfcomp = IsEnabled(lcp->cfg.acfcomp) ? 1 : 0;

  if (lcp->fsm.parent) {
    lcp->his_accmap = 0xffffffff;
    lcp->want_accmap = lcp->cfg.accmap;
    lcp->his_protocomp = 0;
    lcp->want_protocomp = IsEnabled(lcp->cfg.protocomp) ? 1 : 0;
    lcp->want_magic = GenerateMagic();

    if (IsEnabled(lcp->cfg.chap05)) {
      lcp->want_auth = PROTO_CHAP;
      lcp->want_authtype = 0x05;
#ifndef NODES
    } else if (IsEnabled(lcp->cfg.chap80nt) ||
               IsEnabled(lcp->cfg.chap80lm)) {
      lcp->want_auth = PROTO_CHAP;
      lcp->want_authtype = 0x80;
    } else if (IsEnabled(lcp->cfg.chap81)) {
      lcp->want_auth = PROTO_CHAP;
      lcp->want_authtype = 0x81;
#endif
    } else if (IsEnabled(lcp->cfg.pap)) {
      lcp->want_auth = PROTO_PAP;
      lcp->want_authtype = 0;
    } else {
      lcp->want_auth = 0;
      lcp->want_authtype = 0;
    }

    if (p->type != PHYS_DIRECT)
      memcpy(&lcp->want_callback, &p->dl->cfg.callback,
             sizeof(struct callback));
    else
      lcp->want_callback.opmask = 0;
    lcp->want_lqrperiod = IsEnabled(lcp->cfg.lqr) ?
                          lcp->cfg.lqrperiod * 100 : 0;
  } else {
    lcp->his_accmap = lcp->want_accmap = 0;
    lcp->his_protocomp = lcp->want_protocomp = 1;
    lcp->want_magic = 0;
    lcp->want_auth = 0;
    lcp->want_authtype = 0;
    lcp->want_callback.opmask = 0;
    lcp->want_lqrperiod = 0;
  }

  lcp->his_reject = lcp->my_reject = 0;
  lcp->auth_iwait = lcp->auth_ineed = 0;
  lcp->LcpFailedMagic = 0;
}

static void
LcpInitRestartCounter(struct fsm *fp, int what)
{
  /* Set fsm timer load */
  struct lcp *lcp = fsm2lcp(fp);

  fp->FsmTimer.load = lcp->cfg.fsm.timeout * SECTICKS;
  switch (what) {
    case FSM_REQ_TIMER:
      fp->restart = lcp->cfg.fsm.maxreq;
      break;
    case FSM_TRM_TIMER:
      fp->restart = lcp->cfg.fsm.maxtrm;
      break;
    default:
      fp->restart = 1;
      break;
  }
}

static void
LcpSendConfigReq(struct fsm *fp)
{
  /* Send config REQ please */
  struct physical *p = link2physical(fp->link);
  struct lcp *lcp = fsm2lcp(fp);
  u_char buff[200];
  struct fsm_opt *o;
  struct mp *mp;
  u_int16_t proto;
  u_short maxmru;

  if (!p) {
    log_Printf(LogERROR, "%s: LcpSendConfigReq: Not a physical link !\n",
              fp->link->name);
    return;
  }

  o = (struct fsm_opt *)buff;
  if (!physical_IsSync(p)) {
    if (lcp->want_acfcomp && !REJECTED(lcp, TY_ACFCOMP))
      INC_FSM_OPT(TY_ACFCOMP, 2, o);

    if (lcp->want_protocomp && !REJECTED(lcp, TY_PROTOCOMP))
      INC_FSM_OPT(TY_PROTOCOMP, 2, o);

    if (!REJECTED(lcp, TY_ACCMAP)) {
      ua_htonl(&lcp->want_accmap, o->data);
      INC_FSM_OPT(TY_ACCMAP, 6, o);
    }
  }

  maxmru = p ? physical_DeviceMTU(p) : 0;
  if (lcp->cfg.max_mru && (!maxmru || maxmru > lcp->cfg.max_mru))
    maxmru = lcp->cfg.max_mru;
  if (maxmru && lcp->want_mru > maxmru) {
    log_Printf(LogWARN, "%s: Reducing configured MRU from %u to %u\n",
               fp->link->name, lcp->want_mru, maxmru);
    lcp->want_mru = maxmru;
  }
  if (!REJECTED(lcp, TY_MRU)) {
    ua_htons(&lcp->want_mru, o->data);
    INC_FSM_OPT(TY_MRU, 4, o);
  }

  if (lcp->want_magic && !REJECTED(lcp, TY_MAGICNUM)) {
    ua_htonl(&lcp->want_magic, o->data);
    INC_FSM_OPT(TY_MAGICNUM, 6, o);
  }

  if (lcp->want_lqrperiod && !REJECTED(lcp, TY_QUALPROTO)) {
    proto = PROTO_LQR;
    ua_htons(&proto, o->data);
    ua_htonl(&lcp->want_lqrperiod, o->data + 2);
    INC_FSM_OPT(TY_QUALPROTO, 8, o);
  }

  switch (lcp->want_auth) {
  case PROTO_PAP:
    proto = PROTO_PAP;
    ua_htons(&proto, o->data);
    INC_FSM_OPT(TY_AUTHPROTO, 4, o);
    break;

  case PROTO_CHAP:
    proto = PROTO_CHAP;
    ua_htons(&proto, o->data);
    o->data[2] = lcp->want_authtype;
    INC_FSM_OPT(TY_AUTHPROTO, 5, o);
    break;
  }

  if (!REJECTED(lcp, TY_CALLBACK)) {
    if (lcp->want_callback.opmask & CALLBACK_BIT(CALLBACK_AUTH)) {
      *o->data = CALLBACK_AUTH;
      INC_FSM_OPT(TY_CALLBACK, 3, o);
    } else if (lcp->want_callback.opmask & CALLBACK_BIT(CALLBACK_CBCP)) {
      *o->data = CALLBACK_CBCP;
      INC_FSM_OPT(TY_CALLBACK, 3, o);
    } else if (lcp->want_callback.opmask & CALLBACK_BIT(CALLBACK_E164)) {
      int sz = strlen(lcp->want_callback.msg);

      if (sz > sizeof o->data - 1) {
        sz = sizeof o->data - 1;
        log_Printf(LogWARN, "Truncating E164 data to %d octets (oops!)\n", sz);
      }
      *o->data = CALLBACK_E164;
      memcpy(o->data + 1, lcp->want_callback.msg, sz);
      INC_FSM_OPT(TY_CALLBACK, sz + 3, o);
    }
  }

  if (lcp->want_mrru && !REJECTED(lcp, TY_MRRU)) {
    ua_htons(&lcp->want_mrru, o->data);
    INC_FSM_OPT(TY_MRRU, 4, o);

    if (lcp->want_shortseq && !REJECTED(lcp, TY_SHORTSEQ))
      INC_FSM_OPT(TY_SHORTSEQ, 2, o);
  }

  mp = &lcp->fsm.bundle->ncp.mp;
  if (mp->cfg.enddisc.class != 0 && IsEnabled(mp->cfg.negenddisc) &&
      !REJECTED(lcp, TY_ENDDISC)) {
    *o->data = mp->cfg.enddisc.class;
    memcpy(o->data+1, mp->cfg.enddisc.address, mp->cfg.enddisc.len);
    INC_FSM_OPT(TY_ENDDISC, mp->cfg.enddisc.len + 3, o);
  }

  fsm_Output(fp, CODE_CONFIGREQ, fp->reqid, buff, (u_char *)o - buff,
             MB_LCPOUT);
}

void
lcp_SendProtoRej(struct lcp *lcp, u_char *option, int count)
{
  /* Don't understand `option' */
  fsm_Output(&lcp->fsm, CODE_PROTOREJ, lcp->fsm.reqid, option, count,
             MB_LCPOUT);
}

int
lcp_SendIdentification(struct lcp *lcp)
{
  static u_char id;		/* Use a private id */
  u_char msg[DEF_MRU - 3];
  const char *argv[2];
  char *exp[2];

  if (*lcp->cfg.ident == '\0')
    return 0;

  argv[0] = lcp->cfg.ident;
  argv[1] = NULL;

  command_Expand(exp, 1, argv, lcp->fsm.bundle, 1, getpid());

  ua_htonl(&lcp->want_magic, msg);
  strncpy(msg + 4, exp[0], sizeof msg - 5);
  msg[sizeof msg - 1] = '\0';

  fsm_Output(&lcp->fsm, CODE_IDENT, id++, msg, 4 + strlen(msg + 4), MB_LCPOUT);
  log_Printf(LogLCP, " MAGICNUM %08x\n", lcp->want_magic);
  log_Printf(LogLCP, " TEXT %s\n", msg + 4);

  command_Free(1, exp);
  return 1;
}

void
lcp_RecvIdentification(struct lcp *lcp, char *data)
{
  log_Printf(LogLCP, " MAGICNUM %08x\n", lcp->his_magic);
  log_Printf(LogLCP, " TEXT %s\n", data);
}

static void
LcpSentTerminateReq(struct fsm *fp)
{
  /* Term REQ just sent by FSM */
}

static void
LcpSendTerminateAck(struct fsm *fp, u_char id)
{
  /* Send Term ACK please */
  struct physical *p = link2physical(fp->link);

  if (p && p->dl->state == DATALINK_CBCP)
    cbcp_ReceiveTerminateReq(p);

  fsm_Output(fp, CODE_TERMACK, id, NULL, 0, MB_LCPOUT);
}

static void
LcpLayerStart(struct fsm *fp)
{
  /* We're about to start up ! */
  struct lcp *lcp = fsm2lcp(fp);

  log_Printf(LogLCP, "%s: LayerStart\n", fp->link->name);
  lcp->LcpFailedMagic = 0;
  fp->more.reqs = fp->more.naks = fp->more.rejs = lcp->cfg.fsm.maxreq * 3;
  lcp->mru_req = 0;
}

static void
LcpLayerFinish(struct fsm *fp)
{
  /* We're now down */
  log_Printf(LogLCP, "%s: LayerFinish\n", fp->link->name);
}

static int
LcpLayerUp(struct fsm *fp)
{
  /* We're now up */
  struct physical *p = link2physical(fp->link);
  struct lcp *lcp = fsm2lcp(fp);

  log_Printf(LogLCP, "%s: LayerUp\n", fp->link->name);
  physical_SetAsyncParams(p, lcp->want_accmap, lcp->his_accmap);
  lqr_Start(lcp);
  hdlc_StartTimer(&p->hdlc);
  fp->more.reqs = fp->more.naks = fp->more.rejs = lcp->cfg.fsm.maxreq * 3;

  lcp_SendIdentification(lcp);

  return 1;
}

static void
LcpLayerDown(struct fsm *fp)
{
  /* About to come down */
  struct physical *p = link2physical(fp->link);

  log_Printf(LogLCP, "%s: LayerDown\n", fp->link->name);
  hdlc_StopTimer(&p->hdlc);
  lqr_StopTimer(p);
  lcp_Setup(fsm2lcp(fp), 0);
}

static int
E164ok(struct callback *cb, char *req, int sz)
{
  char list[sizeof cb->msg], *next;
  int len;

  if (!strcmp(cb->msg, "*"))
    return 1;

  strncpy(list, cb->msg, sizeof list - 1);
  list[sizeof list - 1] = '\0';
  for (next = strtok(list, ","); next; next = strtok(NULL, ",")) {
    len = strlen(next);
    if (sz == len && !memcmp(list, req, sz))
      return 1;
  }
  return 0;
}

static int
lcp_auth_nak(struct lcp *lcp, struct fsm_decode *dec)
{
  struct fsm_opt nak;

  nak.hdr.id = TY_AUTHPROTO;

  if (IsAccepted(lcp->cfg.pap)) {
    nak.hdr.len = 4;
    nak.data[0] = (unsigned char)(PROTO_PAP >> 8);
    nak.data[1] = (unsigned char)PROTO_PAP;
    fsm_nak(dec, &nak);
    return 1;
  }

  nak.hdr.len = 5;
  nak.data[0] = (unsigned char)(PROTO_CHAP >> 8);
  nak.data[1] = (unsigned char)PROTO_CHAP;

  if (IsAccepted(lcp->cfg.chap05)) {
    nak.data[2] = 0x05;
    fsm_nak(dec, &nak);
#ifndef NODES
  } else if (IsAccepted(lcp->cfg.chap80nt) ||
             IsAccepted(lcp->cfg.chap80lm)) {
    nak.data[2] = 0x80;
    fsm_nak(dec, &nak);
  } else if (IsAccepted(lcp->cfg.chap81)) {
    nak.data[2] = 0x81;
    fsm_nak(dec, &nak);
#endif
  } else {
    return 0;
  }

  return 1;
}

static void
LcpDecodeConfig(struct fsm *fp, u_char *cp, u_char *end, int mode_type,
                struct fsm_decode *dec)
{
  /* Deal with incoming PROTO_LCP */
  struct lcp *lcp = fsm2lcp(fp);
  int sz, pos, op, callback_req, chap_type;
  u_int32_t magic, accmap;
  u_short mru, phmtu, maxmtu, maxmru, wantmtu, wantmru, proto;
  struct lqrreq *req, reqbuff;
  char request[20], desc[22];
  struct mp *mp;
  struct physical *p = link2physical(fp->link);
  struct fsm_opt *opt, nak;

  sz = op = callback_req = 0;

  while (end - cp >= sizeof(opt->hdr)) {
    if ((opt = fsm_readopt(&cp)) == NULL)
      break;

    snprintf(request, sizeof request, " %s[%d]", protoname(opt->hdr.id),
             opt->hdr.len);

    switch (opt->hdr.id) {
    case TY_MRRU:
      mp = &lcp->fsm.bundle->ncp.mp;
      ua_ntohs(opt->data, &mru);
      log_Printf(LogLCP, "%s %u\n", request, mru);

      switch (mode_type) {
      case MODE_REQ:
        if (mp->cfg.mrru) {
          if (REJECTED(lcp, TY_MRRU))
            /* Ignore his previous reject so that we REQ next time */
            lcp->his_reject &= ~(1 << opt->hdr.id);

          if (mru > MAX_MRU) {
            /* Push him down to MAX_MRU */
            lcp->his_mrru = MAX_MRU;
            nak.hdr.id = TY_MRRU;
            nak.hdr.len = 4;
            ua_htons(&lcp->his_mrru, nak.data);
            fsm_nak(dec, &nak);
          } else if (mru < MIN_MRU) {
            /* Push him up to MIN_MRU */
            lcp->his_mrru = MIN_MRU;
            nak.hdr.id = TY_MRRU;
            nak.hdr.len = 4;
            ua_htons(&lcp->his_mrru, nak.data);
            fsm_nak(dec, &nak);
          } else {
            lcp->his_mrru = mru;
            fsm_ack(dec, opt);
          }
          break;
        } else {
          fsm_rej(dec, opt);
          lcp->my_reject |= (1 << opt->hdr.id);
        }
        break;
      case MODE_NAK:
        if (mp->cfg.mrru) {
          if (REJECTED(lcp, TY_MRRU))
            /* Must have changed his mind ! */
            lcp->his_reject &= ~(1 << opt->hdr.id);

          if (mru > MAX_MRU)
            lcp->want_mrru = MAX_MRU;
          else if (mru < MIN_MRU)
            lcp->want_mrru = MIN_MRU;
          else
            lcp->want_mrru = mru;
        }
        /* else we honour our config and don't send the suggested REQ */
        break;
      case MODE_REJ:
        lcp->his_reject |= (1 << opt->hdr.id);
        lcp->want_mrru = 0;		/* Ah well, no multilink :-( */
        break;
      }
      break;

    case TY_MRU:
      lcp->mru_req = 1;
      ua_ntohs(opt->data, &mru);
      log_Printf(LogLCP, "%s %d\n", request, mru);

      switch (mode_type) {
      case MODE_REQ:
        maxmtu = p ? physical_DeviceMTU(p) : 0;
        if (lcp->cfg.max_mtu && (!maxmtu || maxmtu > lcp->cfg.max_mtu))
          maxmtu = lcp->cfg.max_mtu;
        wantmtu = lcp->cfg.mtu;
        if (maxmtu && wantmtu > maxmtu) {
          log_Printf(LogWARN, "%s: Reducing configured MTU from %u to %u\n",
                     fp->link->name, wantmtu, maxmtu);
          wantmtu = maxmtu;
        }

        if (maxmtu && mru > maxmtu) {
          lcp->his_mru = maxmtu;
          nak.hdr.id = TY_MRU;
          nak.hdr.len = 4;
          ua_htons(&lcp->his_mru, nak.data);
          fsm_nak(dec, &nak);
        } else if (wantmtu && mru < wantmtu) {
          /* Push him up to MTU or MIN_MRU */
          lcp->his_mru = wantmtu;
          nak.hdr.id = TY_MRU;
          nak.hdr.len = 4;
          ua_htons(&lcp->his_mru, nak.data);
          fsm_nak(dec, &nak);
        } else {
          lcp->his_mru = mru;
          fsm_ack(dec, opt);
        }
        break;
      case MODE_NAK:
        maxmru = p ? physical_DeviceMTU(p) : 0;
        if (lcp->cfg.max_mru && (!maxmru || maxmru > lcp->cfg.max_mru))
          maxmru = lcp->cfg.max_mru;
        wantmru = lcp->cfg.mru > maxmru ? maxmru : lcp->cfg.mru;

        if (wantmru && mru > wantmru)
          lcp->want_mru = wantmru;
        else if (mru > maxmru)
          lcp->want_mru = maxmru;
        else if (mru < MIN_MRU)
          lcp->want_mru = MIN_MRU;
        else
          lcp->want_mru = mru;
        break;
      case MODE_REJ:
        lcp->his_reject |= (1 << opt->hdr.id);
	/* Set the MRU to what we want anyway - the peer won't care! */
	if (lcp->his_mru > lcp->want_mru)
	  lcp->his_mru = lcp->want_mru;
        break;
      }
      break;

    case TY_ACCMAP:
      ua_ntohl(opt->data, &accmap);
      log_Printf(LogLCP, "%s 0x%08lx\n", request, (u_long)accmap);

      switch (mode_type) {
      case MODE_REQ:
        lcp->his_accmap = accmap;
        fsm_ack(dec, opt);
        break;
      case MODE_NAK:
        lcp->want_accmap = accmap;
        break;
      case MODE_REJ:
        lcp->his_reject |= (1 << opt->hdr.id);
        break;
      }
      break;

    case TY_AUTHPROTO:
      ua_ntohs(opt->data, &proto);
      chap_type = opt->hdr.len == 5 ? opt->data[2] : 0;

      log_Printf(LogLCP, "%s 0x%04x (%s)\n", request, proto,
                 Auth2Nam(proto, chap_type));

      switch (mode_type) {
      case MODE_REQ:
        switch (proto) {
        case PROTO_PAP:
          if (opt->hdr.len == 4 && IsAccepted(lcp->cfg.pap)) {
            lcp->his_auth = proto;
            lcp->his_authtype = 0;
            fsm_ack(dec, opt);
          } else if (!lcp_auth_nak(lcp, dec)) {
            lcp->my_reject |= (1 << opt->hdr.id);
            fsm_rej(dec, opt);
          }
          break;

        case PROTO_CHAP:
          if ((chap_type == 0x05 && IsAccepted(lcp->cfg.chap05))
#ifndef NODES
              || (chap_type == 0x80 && (IsAccepted(lcp->cfg.chap80nt) ||
                                   (IsAccepted(lcp->cfg.chap80lm))))
              || (chap_type == 0x81 && IsAccepted(lcp->cfg.chap81))
#endif
             ) {
            lcp->his_auth = proto;
            lcp->his_authtype = chap_type;
            fsm_ack(dec, opt);
          } else {
#ifdef NODES
            if (chap_type == 0x80) {
              log_Printf(LogWARN, "CHAP 0x80 not available without DES\n");
            } else if (chap_type == 0x81) {
              log_Printf(LogWARN, "CHAP 0x81 not available without DES\n");
            } else
#endif
            if (chap_type != 0x05)
              log_Printf(LogWARN, "%s not supported\n",
                         Auth2Nam(PROTO_CHAP, chap_type));

            if (!lcp_auth_nak(lcp, dec)) {
              lcp->my_reject |= (1 << opt->hdr.id);
              fsm_rej(dec, opt);
            }
          }
          break;

        default:
          log_Printf(LogLCP, "%s 0x%04x - not recognised\n",
                    request, proto);
          if (!lcp_auth_nak(lcp, dec)) {
            lcp->my_reject |= (1 << opt->hdr.id);
            fsm_rej(dec, opt);
          }
          break;
        }
        break;

      case MODE_NAK:
        switch (proto) {
        case PROTO_PAP:
          if (IsEnabled(lcp->cfg.pap)) {
            lcp->want_auth = PROTO_PAP;
            lcp->want_authtype = 0;
          } else {
            log_Printf(LogLCP, "Peer will only send PAP (not enabled)\n");
            lcp->his_reject |= (1 << opt->hdr.id);
          }
          break;
        case PROTO_CHAP:
          if (chap_type == 0x05 && IsEnabled(lcp->cfg.chap05)) {
            lcp->want_auth = PROTO_CHAP;
            lcp->want_authtype = 0x05;
#ifndef NODES
          } else if (chap_type == 0x80 && (IsEnabled(lcp->cfg.chap80nt) ||
                                           IsEnabled(lcp->cfg.chap80lm))) {
            lcp->want_auth = PROTO_CHAP;
            lcp->want_authtype = 0x80;
          } else if (chap_type == 0x81 && IsEnabled(lcp->cfg.chap81)) {
            lcp->want_auth = PROTO_CHAP;
            lcp->want_authtype = 0x81;
#endif
          } else {
#ifdef NODES
            if (chap_type == 0x80) {
              log_Printf(LogLCP, "Peer will only send MSCHAP (not available"
                         " without DES)\n");
            } else if (chap_type == 0x81) {
              log_Printf(LogLCP, "Peer will only send MSCHAPV2 (not available"
                         " without DES)\n");
            } else
#endif
            log_Printf(LogLCP, "Peer will only send %s (not %s)\n",
                       Auth2Nam(PROTO_CHAP, chap_type),
#ifndef NODES
                       (chap_type == 0x80 || chap_type == 0x81) ? "configured" :
#endif
                       "supported");
            lcp->his_reject |= (1 << opt->hdr.id);
          }
          break;
        default:
          /* We've been NAK'd with something we don't understand :-( */
          lcp->his_reject |= (1 << opt->hdr.id);
          break;
        }
        break;

      case MODE_REJ:
        lcp->his_reject |= (1 << opt->hdr.id);
        break;
      }
      break;

    case TY_QUALPROTO:
      req = &reqbuff;
      memcpy(req, opt, sizeof(reqbuff));
      log_Printf(LogLCP, "%s proto %x, interval %lums\n",
                request, ntohs(req->proto), (u_long)ntohl(req->period) * 10);
      switch (mode_type) {
      case MODE_REQ:
        if (ntohs(req->proto) != PROTO_LQR || !IsAccepted(lcp->cfg.lqr)) {
          fsm_rej(dec, opt);
          lcp->my_reject |= (1 << opt->hdr.id);
        } else {
          lcp->his_lqrperiod = ntohl(req->period);
          if (lcp->his_lqrperiod < MIN_LQRPERIOD * 100)
            lcp->his_lqrperiod = MIN_LQRPERIOD * 100;
          req->period = htonl(lcp->his_lqrperiod);
          fsm_ack(dec, opt);
        }
        break;
      case MODE_NAK:
        lcp->want_lqrperiod = ntohl(req->period);
        break;
      case MODE_REJ:
        lcp->his_reject |= (1 << opt->hdr.id);
        break;
      }
      break;

    case TY_MAGICNUM:
      ua_ntohl(opt->data, &magic);
      log_Printf(LogLCP, "%s 0x%08lx\n", request, (u_long)magic);

      switch (mode_type) {
      case MODE_REQ:
        if (lcp->want_magic) {
          /* Validate magic number */
          if (magic == lcp->want_magic) {
            sigset_t emptyset;

            log_Printf(LogLCP, "Magic is same (%08lx) - %d times\n",
                      (u_long)magic, ++lcp->LcpFailedMagic);
            lcp->want_magic = GenerateMagic();
            fsm_nak(dec, opt);
            ualarm(TICKUNIT * (4 + 4 * lcp->LcpFailedMagic), 0);
            sigemptyset(&emptyset);
            sigsuspend(&emptyset);
          } else {
            lcp->his_magic = magic;
            lcp->LcpFailedMagic = 0;
            fsm_ack(dec, opt);
          }
        } else {
          lcp->my_reject |= (1 << opt->hdr.id);
          fsm_rej(dec, opt);
        }
        break;
      case MODE_NAK:
        log_Printf(LogLCP, " Magic 0x%08lx is NAKed!\n", (u_long)magic);
        lcp->want_magic = GenerateMagic();
        break;
      case MODE_REJ:
        log_Printf(LogLCP, " Magic 0x%08x is REJected!\n", magic);
        lcp->want_magic = 0;
        lcp->his_reject |= (1 << opt->hdr.id);
        break;
      }
      break;

    case TY_PROTOCOMP:
      log_Printf(LogLCP, "%s\n", request);

      switch (mode_type) {
      case MODE_REQ:
        if (IsAccepted(lcp->cfg.protocomp)) {
          lcp->his_protocomp = 1;
          fsm_ack(dec, opt);
        } else {
#ifdef OLDMST
          /* MorningStar before v1.3 needs NAK */
          fsm_nak(dec, opt);
#else
          fsm_rej(dec, opt);
          lcp->my_reject |= (1 << opt->hdr.id);
#endif
        }
        break;
      case MODE_NAK:
      case MODE_REJ:
        lcp->want_protocomp = 0;
        lcp->his_reject |= (1 << opt->hdr.id);
        break;
      }
      break;

    case TY_ACFCOMP:
      log_Printf(LogLCP, "%s\n", request);
      switch (mode_type) {
      case MODE_REQ:
        if (IsAccepted(lcp->cfg.acfcomp)) {
          lcp->his_acfcomp = 1;
          fsm_ack(dec, opt);
        } else {
#ifdef OLDMST
          /* MorningStar before v1.3 needs NAK */
          fsm_nak(dec, opt);
#else
          fsm_rej(dec, opt);
          lcp->my_reject |= (1 << opt->hdr.id);
#endif
        }
        break;
      case MODE_NAK:
      case MODE_REJ:
        lcp->want_acfcomp = 0;
        lcp->his_reject |= (1 << opt->hdr.id);
        break;
      }
      break;

    case TY_SDP:
      log_Printf(LogLCP, "%s\n", request);
      switch (mode_type) {
      case MODE_REQ:
      case MODE_NAK:
      case MODE_REJ:
        break;
      }
      break;

    case TY_CALLBACK:
      if (opt->hdr.len == 2)
        op = CALLBACK_NONE;
      else
        op = (int)opt->data[0];
      sz = opt->hdr.len - 3;
      switch (op) {
        case CALLBACK_AUTH:
          log_Printf(LogLCP, "%s Auth\n", request);
          break;
        case CALLBACK_DIALSTRING:
          log_Printf(LogLCP, "%s Dialstring %.*s\n", request, sz,
                     opt->data + 1);
          break;
        case CALLBACK_LOCATION:
          log_Printf(LogLCP, "%s Location %.*s\n", request, sz, opt->data + 1);
          break;
        case CALLBACK_E164:
          log_Printf(LogLCP, "%s E.164 (%.*s)\n", request, sz, opt->data + 1);
          break;
        case CALLBACK_NAME:
          log_Printf(LogLCP, "%s Name %.*s\n", request, sz, opt->data + 1);
          break;
        case CALLBACK_CBCP:
          log_Printf(LogLCP, "%s CBCP\n", request);
          break;
        default:
          log_Printf(LogLCP, "%s ???\n", request);
          break;
      }

      switch (mode_type) {
      case MODE_REQ:
        callback_req = 1;
        if (p->type != PHYS_DIRECT) {
          fsm_rej(dec, opt);
          lcp->my_reject |= (1 << opt->hdr.id);
        }
        nak.hdr.id = opt->hdr.id;
        nak.hdr.len = 3;
        if ((p->dl->cfg.callback.opmask & CALLBACK_BIT(op)) &&
            (op != CALLBACK_AUTH || p->link.lcp.want_auth) &&
            (op != CALLBACK_E164 ||
             E164ok(&p->dl->cfg.callback, opt->data + 1, sz))) {
          lcp->his_callback.opmask = CALLBACK_BIT(op);
          if (sz > sizeof lcp->his_callback.msg - 1) {
            sz = sizeof lcp->his_callback.msg - 1;
            log_Printf(LogWARN, "Truncating option arg to %d octets\n", sz);
          }
          memcpy(lcp->his_callback.msg, opt->data + 1, sz);
          lcp->his_callback.msg[sz] = '\0';
          fsm_ack(dec, opt);
        } else if ((p->dl->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_AUTH)) &&
                    p->link.lcp.auth_ineed) {
          nak.data[0] = CALLBACK_AUTH;
          fsm_nak(dec, &nak);
        } else if (p->dl->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_CBCP)) {
          nak.data[0] = CALLBACK_CBCP;
          fsm_nak(dec, &nak);
        } else if (p->dl->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_E164)) {
          nak.data[0] = CALLBACK_E164;
          fsm_nak(dec, &nak);
        } else if (p->dl->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_AUTH)) {
          log_Printf(LogWARN, "Cannot insist on auth callback without"
                     " PAP or CHAP enabled !\n");
          nak.data[0] = 2;
          fsm_nak(dec, &nak);
        } else {
          lcp->my_reject |= (1 << opt->hdr.id);
          fsm_rej(dec, opt);
        }
        break;
      case MODE_NAK:
        /* We don't do what he NAKs with, we do things in our preferred order */
        if (lcp->want_callback.opmask & CALLBACK_BIT(CALLBACK_AUTH))
          lcp->want_callback.opmask &= ~CALLBACK_BIT(CALLBACK_AUTH);
        else if (lcp->want_callback.opmask & CALLBACK_BIT(CALLBACK_CBCP))
          lcp->want_callback.opmask &= ~CALLBACK_BIT(CALLBACK_CBCP);
        else if (lcp->want_callback.opmask & CALLBACK_BIT(CALLBACK_E164))
          lcp->want_callback.opmask &= ~CALLBACK_BIT(CALLBACK_E164);
        if (lcp->want_callback.opmask == CALLBACK_BIT(CALLBACK_NONE)) {
          log_Printf(LogPHASE, "Peer NAKd all callbacks, trying none\n");
          lcp->want_callback.opmask = 0;
        } else if (!lcp->want_callback.opmask) {
          log_Printf(LogPHASE, "Peer NAKd last configured callback\n");
          fsm_Close(&lcp->fsm);
        }
        break;
      case MODE_REJ:
        if (lcp->want_callback.opmask & CALLBACK_BIT(CALLBACK_NONE)) {
          lcp->his_reject |= (1 << opt->hdr.id);
          lcp->want_callback.opmask = 0;
        } else {
          log_Printf(LogPHASE, "Peer rejected *required* callback\n");
          fsm_Close(&lcp->fsm);
        }
        break;
      }
      break;

    case TY_SHORTSEQ:
      mp = &lcp->fsm.bundle->ncp.mp;
      log_Printf(LogLCP, "%s\n", request);

      switch (mode_type) {
      case MODE_REQ:
        if (lcp->want_mrru && IsAccepted(mp->cfg.shortseq)) {
          lcp->his_shortseq = 1;
          fsm_ack(dec, opt);
        } else {
          fsm_rej(dec, opt);
          lcp->my_reject |= (1 << opt->hdr.id);
        }
        break;
      case MODE_NAK:
        /*
         * He's trying to get us to ask for short sequence numbers.
         * We ignore the NAK and honour our configuration file instead.
         */
        break;
      case MODE_REJ:
        lcp->his_reject |= (1 << opt->hdr.id);
        lcp->want_shortseq = 0;		/* For when we hit MP */
        break;
      }
      break;

    case TY_ENDDISC:
      mp = &lcp->fsm.bundle->ncp.mp;
      log_Printf(LogLCP, "%s %s\n", request,
                 mp_Enddisc(opt->data[0], opt->data + 1, opt->hdr.len - 3));
      switch (mode_type) {
      case MODE_REQ:
        if (!p) {
          log_Printf(LogLCP, " ENDDISC rejected - not a physical link\n");
          fsm_rej(dec, opt);
          lcp->my_reject |= (1 << opt->hdr.id);
        } else if (!IsAccepted(mp->cfg.negenddisc)) {
          lcp->my_reject |= (1 << opt->hdr.id);
          fsm_rej(dec, opt);
        } else if (opt->hdr.len - 3 < sizeof p->dl->peer.enddisc.address &&
                   opt->data[0] <= MAX_ENDDISC_CLASS) {
          p->dl->peer.enddisc.class = opt->data[0];
          p->dl->peer.enddisc.len = opt->hdr.len - 3;
          memcpy(p->dl->peer.enddisc.address, opt->data + 1, opt->hdr.len - 3);
          p->dl->peer.enddisc.address[opt->hdr.len - 3] = '\0';
          /* XXX: If mp->active, compare and NAK with mp->peer ? */
          fsm_ack(dec, opt);
        } else {
          if (opt->data[0] > MAX_ENDDISC_CLASS)
            log_Printf(LogLCP, " ENDDISC rejected - unrecognised class %d\n",
                      opt->data[0]);
          else
            log_Printf(LogLCP, " ENDDISC rejected - local max length is %ld\n",
                      (long)(sizeof p->dl->peer.enddisc.address - 1));
          fsm_rej(dec, opt);
          lcp->my_reject |= (1 << opt->hdr.id);
        }
        break;

      case MODE_NAK:	/* Treat this as a REJ, we don't vary our disc (yet) */
      case MODE_REJ:
        lcp->his_reject |= (1 << opt->hdr.id);
        break;
      }
      break;

    default:
      sz = (sizeof desc - 2) / 2;
      if (sz > opt->hdr.len - 2)
        sz = opt->hdr.len - 2;
      pos = 0;
      desc[0] = sz ? ' ' : '\0';
      for (pos = 0; sz--; pos++)
        snprintf(desc+(pos<<1)+1, sizeof desc - ((pos<<1)+1),
	  "%02x", opt->data[pos]);

      log_Printf(LogLCP, "%s%s\n", request, desc);

      if (mode_type == MODE_REQ) {
        fsm_rej(dec, opt);
        lcp->my_reject |= (1 << opt->hdr.id);
      }
      break;
    }
  }

  if (mode_type != MODE_NOP) {
    if (mode_type == MODE_REQ && p && p->type == PHYS_DIRECT &&
        p->dl->cfg.callback.opmask && !callback_req &&
        !(p->dl->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_NONE))) {
      /* We *REQUIRE* that the peer requests callback */
      nak.hdr.id = TY_CALLBACK;
      nak.hdr.len = 3;
      if ((p->dl->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_AUTH)) &&
          p->link.lcp.want_auth)
        nak.data[0] = CALLBACK_AUTH;
      else if (p->dl->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_CBCP))
        nak.data[0] = CALLBACK_CBCP;
      else if (p->dl->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_E164))
        nak.data[0] = CALLBACK_E164;
      else {
        log_Printf(LogWARN, "Cannot insist on auth callback without"
                   " PAP or CHAP enabled !\n");
        nak.hdr.len = 2;	/* XXX: Silly ! */
      }
      fsm_nak(dec, &nak);
    }
    if (mode_type == MODE_REQ && !lcp->mru_req) {
      mru = DEF_MRU;
      phmtu = p ? physical_DeviceMTU(p) : 0;
      if (phmtu && mru > phmtu)
        mru = phmtu;
      if (mru > lcp->cfg.max_mtu)
        mru = lcp->cfg.max_mtu;
      if (mru < DEF_MRU) {
        /* Don't let the peer use the default MRU */
        lcp->his_mru = lcp->cfg.mtu && lcp->cfg.mtu < mru ? lcp->cfg.mtu : mru;
        nak.hdr.id = TY_MRU;
        nak.hdr.len = 4;
        ua_htons(&lcp->his_mru, nak.data);
        fsm_nak(dec, &nak);
        lcp->mru_req = 1;	/* Don't keep NAK'ing this */
      }
    }
    fsm_opt_normalise(dec);
  }
}

extern struct mbuf *
lcp_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
{
  /* Got PROTO_LCP from link */
  m_settype(bp, MB_LCPIN);
  fsm_Input(&l->lcp.fsm, bp);
  return NULL;
}
@


1.43
log
@Fix two identical buffer overruns.

found by parfait, my stupid mistake pointed out by miod, who also oked
this.
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.42 2006/12/11 16:31:35 claudio Exp $
@


1.42
log
@If the peer rejects my MRU request and our request is smaller then what
the peer accepts, set the MRU anyway. Smaller packets are always accepted.

From brian@@FreeBSD via brad@@ ok canacar@@
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.41 2005/07/17 19:13:24 brad Exp $
d149 1
a149 1
  if (proto < 0 || proto > sizeof cftypes / sizeof *cftypes ||
@


1.41
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.40 2005/07/17 07:33:22 brad Exp $
d793 3
@


1.40
log
@Implement an ``enable/disable echo'' option, defaults to off.
This allows LCP ECHOs to be enabled independently of LQR reports.

Note: This introduces a change in the default behaviour (search for lqr and
echo in the man page).

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.39 2004/06/26 20:12:48 claudio Exp $
d39 1
@


1.39
log
@Fix strict aligenment issues in ppp lcp and ipcp handling.
More cleanup is needed. OK henning@@ canacar@@
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.38 2003/04/07 23:58:53 deraadt Exp $
d221 2
d277 1
@


1.38
log
@more string cleaning; ok tedu
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.37 2002/06/15 08:02:00 brian Exp $
d663 1
a663 1
  struct lqrreq *req;
d930 2
a931 1
      req = (struct lqrreq *)opt;
@


1.37
log
@Tidy up end of line whitespace
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.36 2002/05/16 01:13:39 brian Exp $
d1230 2
a1231 1
        sprintf(desc+(pos<<1)+1, "%02x", opt->data[pos]);
@


1.36
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.35 2002/03/31 02:38:49 brian Exp $
d1222 1
a1222 1
      
@


1.35
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.34 2001/11/23 11:17:03 brian Exp $
a66 1
#include "ip.h"
d84 1
a84 2
  u_char type;
  u_char length;
d97 1
a97 1
static void LcpDecodeConfig(struct fsm *, u_char *, int, int,
d167 3
a169 3
	        " his side: MRU %d, ACCMAP %08lx, PROTOCOMP %s, ACFCOMP %s,\n"
	        "           MAGIC %08lx, MRRU %u, SHORTSEQ %s, REJECT %04x\n",
	        lcp->his_mru, (u_long)lcp->his_accmap,
d175 1
a175 1
	        " my  side: MRU %d, ACCMAP %08lx, PROTOCOMP %s, ACFCOMP %s,\n"
d382 1
a382 1
  struct lcp_opt *o;
d393 1
a393 1
  o = (struct lcp_opt *)buff;
d396 1
a396 1
      INC_LCP_OPT(TY_ACFCOMP, 2, o);
d399 1
a399 1
      INC_LCP_OPT(TY_PROTOCOMP, 2, o);
d403 1
a403 1
      INC_LCP_OPT(TY_ACCMAP, 6, o);
d417 1
a417 1
    INC_LCP_OPT(TY_MRU, 4, o);
d422 1
a422 1
    INC_LCP_OPT(TY_MAGICNUM, 6, o);
d429 1
a429 1
    INC_LCP_OPT(TY_QUALPROTO, 8, o);
d436 1
a436 1
    INC_LCP_OPT(TY_AUTHPROTO, 4, o);
d443 1
a443 1
    INC_LCP_OPT(TY_AUTHPROTO, 5, o);
d450 1
a450 1
      INC_LCP_OPT(TY_CALLBACK, 3, o);
d453 1
a453 1
      INC_LCP_OPT(TY_CALLBACK, 3, o);
d463 1
a463 1
      INC_LCP_OPT(TY_CALLBACK, sz + 3, o);
d469 1
a469 1
    INC_LCP_OPT(TY_MRRU, 4, o);
d472 1
a472 1
      INC_LCP_OPT(TY_SHORTSEQ, 2, o);
d480 1
a480 1
    INC_LCP_OPT(TY_ENDDISC, mp->cfg.enddisc.len + 3, o);
a514 2
  log_Printf(LogLCP, "Sending ident magic %08x text %s\n", lcp->want_magic,
             msg + 4);
d516 2
d526 2
a527 1
  log_Printf(LogLCP, "Received ident: %s\n", data);
d616 38
d655 1
a655 1
LcpDecodeConfig(struct fsm *fp, u_char *cp, int plen, int mode_type,
d660 1
a660 1
  int type, length, sz, pos, op, callback_req;
d667 1
d671 3
a673 5
  while (plen >= sizeof(struct fsmconfig)) {
    type = *cp;
    length = cp[1];

    snprintf(request, sizeof request, " %s[%d]", protoname(type), length);
d675 2
a676 4
    if (length < 2) {
      log_Printf(LogLCP, "%s:%s: Bad LCP length\n", fp->link->name, request);
      break;
    }
d678 1
a678 1
    switch (type) {
d681 1
a681 1
      ua_ntohs(cp + 2, &mru);
d689 1
a689 1
	    lcp->his_reject &= ~(1 << type);
d694 4
a697 3
	    memcpy(dec->nakend, cp, 2);
            ua_htons(&lcp->his_mrru, dec->nakend + 2);
	    dec->nakend += 4;
d701 5
a705 4
	    memcpy(dec->nakend, cp, 2);
            ua_htons(&lcp->his_mrru, dec->nakend + 2);
	    dec->nakend += 4;
	  } else {
d707 7
a713 6
	    memcpy(dec->ackend, cp, 4);
	    dec->ackend += 4;
	  }
	  break;
        } else
	  goto reqreject;
d719 1
a719 1
	    lcp->his_reject &= ~(1 << type);
d731 1
a731 1
	lcp->his_reject |= (1 << type);
d733 1
a733 1
	break;
d739 1
a739 1
      ua_ntohs(cp + 2, &mru);
d756 4
a759 3
          memcpy(dec->nakend, cp, 2);
          ua_htons(&lcp->his_mru, dec->nakend + 2);
          dec->nakend += 4;
d763 4
a766 3
          memcpy(dec->nakend, cp, 2);
          ua_htons(&lcp->his_mru, dec->nakend + 2);
          dec->nakend += 4;
d769 1
a769 2
          memcpy(dec->ackend, cp, 4);
          dec->ackend += 4;
d771 1
a771 1
	break;
d786 1
a786 1
	break;
d788 2
a789 2
	lcp->his_reject |= (1 << type);
	break;
d794 1
a794 1
      ua_ntohl(cp + 2, &accmap);
d799 3
a801 4
	lcp->his_accmap = accmap;
	memcpy(dec->ackend, cp, 6);
	dec->ackend += 6;
	break;
d803 2
a804 2
	lcp->want_accmap = accmap;
	break;
d806 2
a807 2
	lcp->his_reject |= (1 << type);
	break;
d812 3
a814 1
      ua_ntohs(cp + 2, &proto);
d816 1
a816 1
                 Auth2Nam(proto, length > 4 ? cp[4] : 0));
d820 14
a833 17
	switch (proto) {
	case PROTO_PAP:
	  if (length != 4) {
	    log_Printf(LogLCP, " Bad length!\n");
	    goto reqreject;
	  }
	  if (IsAccepted(lcp->cfg.pap)) {
	    lcp->his_auth = proto;
	    lcp->his_authtype = 0;
	    memcpy(dec->ackend, cp, length);
	    dec->ackend += length;
	  } else if (IsAccepted(lcp->cfg.chap05)) {
	    *dec->nakend++ = *cp;
	    *dec->nakend++ = 5;
	    *dec->nakend++ = (unsigned char) (PROTO_CHAP >> 8);
	    *dec->nakend++ = (unsigned char) PROTO_CHAP;
	    *dec->nakend++ = 0x05;
d835 1
a835 26
	  } else if (IsAccepted(lcp->cfg.chap80nt) ||
	             IsAccepted(lcp->cfg.chap80lm)) {
	    *dec->nakend++ = *cp;
	    *dec->nakend++ = 5;
	    *dec->nakend++ = (unsigned char) (PROTO_CHAP >> 8);
	    *dec->nakend++ = (unsigned char) PROTO_CHAP;
	    *dec->nakend++ = 0x80;
	  } else if (IsAccepted(lcp->cfg.chap81)) {
	    *dec->nakend++ = *cp;
	    *dec->nakend++ = 5;
	    *dec->nakend++ = (unsigned char) (PROTO_CHAP >> 8);
	    *dec->nakend++ = (unsigned char) PROTO_CHAP;
	    *dec->nakend++ = 0x81;
#endif
	  } else
	    goto reqreject;
	  break;

	case PROTO_CHAP:
	  if (length != 5) {
	    log_Printf(LogLCP, " Bad length!\n");
	    goto reqreject;
	  }
          if ((cp[4] == 0x05 && IsAccepted(lcp->cfg.chap05))
#ifndef NODES
              || (cp[4] == 0x80 && (IsAccepted(lcp->cfg.chap80nt) ||
d837 1
a837 1
              || (cp[4] == 0x81 && IsAccepted(lcp->cfg.chap81))
d840 6
a845 7
	    lcp->his_auth = proto;
	    lcp->his_authtype = cp[4];
	    memcpy(dec->ackend, cp, length);
	    dec->ackend += length;
	  } else {
#ifndef HAVE_DES
            if (cp[4] == 0x80) {
d847 1
a847 1
            } else if (cp[4] == 0x81) {
d851 1
a851 1
            if (cp[4] != 0x05)
d853 1
a853 1
                         Auth2Nam(PROTO_CHAP, cp[4]));
d855 4
a858 28
            if (IsAccepted(lcp->cfg.chap05)) {
	      *dec->nakend++ = *cp;
	      *dec->nakend++ = 5;
	      *dec->nakend++ = (unsigned char) (PROTO_CHAP >> 8);
	      *dec->nakend++ = (unsigned char) PROTO_CHAP;
	      *dec->nakend++ = 0x05;
#ifndef NODES
            } else if (IsAccepted(lcp->cfg.chap80nt) ||
                       IsAccepted(lcp->cfg.chap80lm)) {
	      *dec->nakend++ = *cp;
	      *dec->nakend++ = 5;
	      *dec->nakend++ = (unsigned char) (PROTO_CHAP >> 8);
	      *dec->nakend++ = (unsigned char) PROTO_CHAP;
	      *dec->nakend++ = 0x80;
            } else if (IsAccepted(lcp->cfg.chap81)) {
	      *dec->nakend++ = *cp;
	      *dec->nakend++ = 5;
	      *dec->nakend++ = (unsigned char) (PROTO_CHAP >> 8);
	      *dec->nakend++ = (unsigned char) PROTO_CHAP;
	      *dec->nakend++ = 0x81;
#endif
            } else if (IsAccepted(lcp->cfg.pap)) {
	      *dec->nakend++ = *cp;
	      *dec->nakend++ = 4;
	      *dec->nakend++ = (unsigned char) (PROTO_PAP >> 8);
	      *dec->nakend++ = (unsigned char) PROTO_PAP;
	    } else
	      goto reqreject;
d860 1
a860 1
	  break;
d862 2
a863 2
	default:
          log_Printf(LogLCP, "%s 0x%04x - not recognised, NAK\n",
d865 8
a872 5
	  memcpy(dec->nakend, cp, length);
	  dec->nakend += length;
	  break;
	}
	break;
d874 2
a875 2
	switch (proto) {
	case PROTO_PAP:
d881 1
a881 1
	    lcp->his_reject |= (1 << type);
d884 2
a885 2
	case PROTO_CHAP:
          if (cp[4] == 0x05 && IsEnabled(lcp->cfg.chap05)) {
d889 2
a890 2
          } else if (cp[4] == 0x80 && (IsEnabled(lcp->cfg.chap80nt) ||
                                       IsEnabled(lcp->cfg.chap80lm))) {
d893 1
a893 1
          } else if (cp[4] == 0x81 && IsEnabled(lcp->cfg.chap81)) {
d898 2
a899 2
#ifndef HAVE_DES
            if (cp[4] == 0x80) {
d902 1
a902 1
            } else if (cp[4] == 0x81) {
d908 1
a908 1
                       Auth2Nam(PROTO_CHAP, cp[4]),
d910 1
a910 1
                       (cp[4] == 0x80 || cp[4] == 0x81) ? "configured" :
d913 1
a913 1
	    lcp->his_reject |= (1 << type);
d918 1
a918 1
	  lcp->his_reject |= (1 << type);
d921 2
a922 1
	break;
d924 2
a925 2
	lcp->his_reject |= (1 << type);
	break;
d930 1
a930 1
      req = (struct lqrreq *)cp;
d935 11
a945 11
	if (ntohs(req->proto) != PROTO_LQR || !IsAccepted(lcp->cfg.lqr))
	  goto reqreject;
	else {
	  lcp->his_lqrperiod = ntohl(req->period);
	  if (lcp->his_lqrperiod < MIN_LQRPERIOD * 100)
	    lcp->his_lqrperiod = MIN_LQRPERIOD * 100;
	  req->period = htonl(lcp->his_lqrperiod);
	  memcpy(dec->ackend, cp, length);
	  dec->ackend += length;
	}
	break;
d947 2
a948 1
	break;
d950 2
a951 2
	lcp->his_reject |= (1 << type);
	break;
d956 1
a956 1
      ua_ntohl(cp + 2, &magic);
d961 4
a964 4
	if (lcp->want_magic) {
	  /* Validate magic number */
	  if (magic == lcp->want_magic) {
	    sigset_t emptyset;
d966 1
a966 1
	    log_Printf(LogLCP, "Magic is same (%08lx) - %d times\n",
d968 2
a969 3
	    lcp->want_magic = GenerateMagic();
	    memcpy(dec->nakend, cp, 6);
	    dec->nakend += 6;
d971 4
a974 6
	    sigemptyset(&emptyset);
	    sigsuspend(&emptyset);
	  } else {
	    lcp->his_magic = magic;
	    memcpy(dec->ackend, cp, length);
	    dec->ackend += length;
d976 7
a982 5
	  }
	} else {
	  goto reqreject;
	}
	break;
d984 3
a986 3
	log_Printf(LogLCP, " Magic 0x%08lx is NAKed!\n", (u_long)magic);
	lcp->want_magic = GenerateMagic();
	break;
d988 4
a991 4
	log_Printf(LogLCP, " Magic 0x%08x is REJected!\n", magic);
	lcp->want_magic = 0;
	lcp->his_reject |= (1 << type);
	break;
d1000 4
a1003 5
	if (IsAccepted(lcp->cfg.protocomp)) {
	  lcp->his_protocomp = 1;
	  memcpy(dec->ackend, cp, 2);
	  dec->ackend += 2;
	} else {
d1005 2
a1006 3
	  /* MorningStar before v1.3 needs NAK */
	  memcpy(dec->nakend, cp, 2);
	  dec->nakend += 2;
d1008 2
a1009 1
	  goto reqreject;
d1011 2
a1012 2
	}
	break;
d1015 3
a1017 3
	lcp->want_protocomp = 0;
	lcp->his_reject |= (1 << type);
	break;
d1025 4
a1028 5
	if (IsAccepted(lcp->cfg.acfcomp)) {
	  lcp->his_acfcomp = 1;
	  memcpy(dec->ackend, cp, 2);
	  dec->ackend += 2;
	} else {
d1030 2
a1031 3
	  /* MorningStar before v1.3 needs NAK */
	  memcpy(dec->nakend, cp, 2);
	  dec->nakend += 2;
d1033 2
a1034 1
	  goto reqreject;
d1036 2
a1037 2
	}
	break;
d1040 3
a1042 3
	lcp->want_acfcomp = 0;
	lcp->his_reject |= (1 << type);
	break;
d1052 1
a1052 1
	break;
d1057 1
a1057 1
      if (length == 2)
d1060 2
a1061 2
        op = (int)cp[2];
      sz = length - 3;
d1067 2
a1068 1
          log_Printf(LogLCP, "%s Dialstring %.*s\n", request, sz, cp + 3);
d1071 1
a1071 1
          log_Printf(LogLCP, "%s Location %.*s\n", request, sz, cp + 3);
d1074 1
a1074 1
          log_Printf(LogLCP, "%s E.164 (%.*s)\n", request, sz, cp + 3);
d1077 1
a1077 1
          log_Printf(LogLCP, "%s Name %.*s\n", request, sz, cp + 3);
d1090 6
a1095 2
        if (p->type != PHYS_DIRECT)
	  goto reqreject;
d1099 2
a1100 2
             E164ok(&p->dl->cfg.callback, cp + 3, sz))) {
	  lcp->his_callback.opmask = CALLBACK_BIT(op);
d1105 3
a1107 4
	  memcpy(lcp->his_callback.msg, cp + 3, sz);
	  lcp->his_callback.msg[sz] = '\0';
	  memcpy(dec->ackend, cp, sz + 3);
	  dec->ackend += sz + 3;
d1110 2
a1111 3
          *dec->nakend++ = *cp;
          *dec->nakend++ = 3;
          *dec->nakend++ = CALLBACK_AUTH;
d1113 2
a1114 3
          *dec->nakend++ = *cp;
          *dec->nakend++ = 3;
          *dec->nakend++ = CALLBACK_CBCP;
d1116 2
a1117 3
          *dec->nakend++ = *cp;
          *dec->nakend++ = 3;
          *dec->nakend++ = CALLBACK_E164;
d1121 6
a1126 4
          *dec->nakend++ = *cp;
          *dec->nakend++ = 2;
        } else
	  goto reqreject;
d1146 1
a1146 1
	  lcp->his_reject |= (1 << type);
d1152 1
a1152 1
	break;
d1164 5
a1168 4
	  memcpy(dec->ackend, cp, length);
	  dec->ackend += length;
        } else
	  goto reqreject;
d1177 1
a1177 1
	lcp->his_reject |= (1 << type);
d1179 1
a1179 1
	break;
d1186 1
a1186 1
                mp_Enddisc(cp[2], cp + 3, length - 3));
d1191 11
a1201 9
	  goto reqreject;
        } else if (!IsAccepted(mp->cfg.negenddisc))
	  goto reqreject;
        else if (length-3 < sizeof p->dl->peer.enddisc.address &&
                   cp[2] <= MAX_ENDDISC_CLASS) {
          p->dl->peer.enddisc.class = cp[2];
          p->dl->peer.enddisc.len = length-3;
          memcpy(p->dl->peer.enddisc.address, cp + 3, length - 3);
          p->dl->peer.enddisc.address[length - 3] = '\0';
d1203 1
a1203 2
	  memcpy(dec->ackend, cp, length);
	  dec->ackend += length;
d1205 1
a1205 1
          if (cp[2] > MAX_ENDDISC_CLASS)
d1207 1
a1207 1
                      cp[2]);
d1211 2
a1212 1
	  goto reqreject;
d1214 1
a1214 1
	break;
d1218 2
a1219 2
	lcp->his_reject |= (1 << type);
	break;
d1225 2
a1226 2
      if (sz > length - 2)
        sz = length - 2;
d1230 1
a1230 1
        sprintf(desc+(pos<<1)+1, "%02x", cp[pos+2]);
d1235 2
a1236 11
reqreject:
        if (length > sizeof dec->rej - (dec->rejend - dec->rej)) {
          length = sizeof dec->rej - (dec->rejend - dec->rej);
          log_Printf(LogLCP, "Can't REJ length %d - trunating to %d\n",
		    cp[1], length);
        }
	memcpy(dec->rejend, cp, length);
	dec->rejend += length;
	lcp->my_reject |= (1 << type);
        if (length != cp[1])
          length = 0;		/* force our way out of the loop */
a1239 2
    plen -= length;
    cp += length;
d1247 2
a1248 2
      *dec->nakend++ = TY_CALLBACK;
      *dec->nakend++ = 3;
d1251 1
a1251 1
        *dec->nakend++ = CALLBACK_AUTH;
d1253 1
a1253 1
        *dec->nakend++ = CALLBACK_CBCP;
d1255 1
a1255 1
        *dec->nakend++ = CALLBACK_E164;
d1259 1
a1259 1
        dec->nakend[-1] = 2;	/* XXX: Silly ! */
d1261 1
d1273 4
a1276 4
        *dec->nakend++ = TY_MRU;
        *dec->nakend++ = 4;
        ua_htons(&lcp->his_mru, dec->nakend);
        dec->nakend += 2;
d1280 1
a1280 7
    if (dec->rejend != dec->rej) {
      /* rejects are preferred */
      dec->ackend = dec->ack;
      dec->nakend = dec->nak;
    } else if (dec->nakend != dec->nak)
      /* then NAKs */
      dec->ackend = dec->ack;
@


1.34
log
@cmott@@scientech.com -> cm@@linktel.net
Add the UPTIME variable
CCP protocol ``0xffffffff'' -> ``none''
Don't leak memory when expanding command arguments and not exec()ing
Make some functions static
Add the ``log'' command for manual logging
Fix some log text bogons
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.33 2001/10/24 10:01:15 brian Exp $
d213 1
a213 1
#ifdef HAVE_DES
d271 1
a271 1
#ifdef HAVE_DES
d318 1
a318 1
#ifdef HAVE_DES
d576 1
a576 1
  async_SetLinkParams(&p->async, lcp);
d798 1
a798 1
#ifdef HAVE_DES
d823 1
a823 1
#ifdef HAVE_DES
d851 1
a851 1
#ifdef HAVE_DES
d899 1
a899 1
#ifdef HAVE_DES
d920 1
a920 1
#ifdef HAVE_DES
@


1.33
log
@If the peer refuses to provide an MRU, don't insist (even if 1500 is
too big).
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.32 2001/09/04 23:35:59 millert Exp $
d521 1
a521 1
  free(exp[0]);
@


1.32
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.31 2001/08/19 23:22:18 brian Exp $
d300 1
d558 1
d623 1
a623 1
  int type, length, sz, pos, op, callback_req, mru_req;
d631 1
a631 1
  sz = op = callback_req = mru_req = 0;
d701 1
a701 1
      mru_req = 1;
d1104 1
a1104 1
            (op != CALLBACK_AUTH || p->link.lcp.auth_ineed) &&
d1267 1
a1267 1
          p->link.lcp.auth_ineed)
d1279 1
a1279 1
    if (mode_type == MODE_REQ && !mru_req) {
d1293 1
@


1.31
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.30 2001/07/30 18:59:20 brian Exp $
d971 2
d979 2
a980 1
            sigpause(0);
@


1.30
log
@If the peer REJects our MRU REQ, stop REQing it -- *EVEN* if we're
doing PPPoE and the default MRU is therefore too big.
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.29 2001/07/26 11:36:51 brian Exp $
d35 1
d66 2
d79 2
@


1.29
log
@Handle peer REQ/NAKs of >1500 byte MRUs when we have no preference.
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.28 2001/07/17 01:07:00 brian Exp $
d411 1
a411 1
  if (!REJECTED(lcp, TY_MRU) || lcp->want_mru < DEF_MRU) {
@


1.28
log
@Ignore (with a warning message) mtu/mru configurations that are greater
than the maximum physical values.
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.27 2001/07/03 22:23:54 brian Exp $
d180 6
a185 2
  prompt_Printf(arg->prompt, "\n Defaults: MRU = %d (max %d), ",
                lcp->cfg.mru, lcp->cfg.max_mru);
d253 1
a253 1
  lcp->cfg.mru = DEF_MRU;
d296 2
a297 1
  lcp->want_mru = lcp->cfg.mru;
d703 1
a703 2
        if ((wantmtu = lcp->cfg.mtu) == 0 && (wantmtu = maxmtu) == 0)
            wantmtu = DEF_MRU;
a708 2
        if (wantmtu < MIN_MRU)
          wantmtu = MIN_MRU;
d715 1
a715 1
        } else if (mru < wantmtu) {
d722 1
a722 1
          lcp->his_mru = wantmtu;
d733 1
a733 1
        if (mru > wantmru)
d735 2
@


1.27
log
@Don't accept chap80lm by default - it doesn't work.
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.26 2001/06/19 10:24:55 brian Exp $
a278 1
  int phmtu = p ? physical_DeviceMTU(p) : 0;
a292 2
  if (phmtu && lcp->want_mru > phmtu)
    lcp->want_mru = phmtu;
d376 1
d398 9
a406 1
  if (!REJECTED(lcp, TY_MRU)) {
d613 1
a613 1
  u_short mru, phmtu, proto;
d695 15
a709 8
        phmtu = p ? physical_DeviceMTU(p) : 0;
        if (phmtu && mru > phmtu) {
          lcp->his_mru = lcp->cfg.mtu ? lcp->cfg.mtu : phmtu;
          memcpy(dec->nakend, cp, 2);
          ua_htons(&lcp->his_mru, dec->nakend + 2);
          dec->nakend += 4;
        } if (mru > lcp->cfg.max_mtu) {
          lcp->his_mru = lcp->cfg.mtu ? lcp->cfg.mtu : lcp->cfg.max_mtu;
d713 1
a713 1
        } else if (mru < MIN_MRU || mru < lcp->cfg.mtu) {
d715 1
a715 1
          lcp->his_mru = mru < lcp->cfg.mtu ? lcp->cfg.mtu : MIN_MRU;
d720 1
a720 1
          lcp->his_mru = lcp->cfg.mtu ? lcp->cfg.mtu : mru;
d726 8
a733 5
        if (mru > lcp->cfg.max_mru) {
          lcp->want_mru = lcp->cfg.max_mru;
          if (p && lcp->want_mru > physical_DeviceMTU(p))
            lcp->want_mru = physical_DeviceMTU(p);
        } else if (mru < MIN_MRU)
@


1.26
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d28 1
a28 1
 * $OpenBSD: lcp.c,v 1.25 2001/06/13 21:33:41 brian Exp $
d264 1
a264 1
  lcp->cfg.chap80lm = NEG_ACCEPTED;
@


1.25
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d180 7
a186 1
  prompt_Printf(arg->prompt, "\n Defaults: MRU = %d, ", lcp->cfg.mru);
d250 3
d278 3
d283 1
a283 3
  lcp->his_mru = lcp->fsm.bundle->cfg.mtu;
  if (!lcp->his_mru || lcp->his_mru > DEF_MRU)
    lcp->his_mru = DEF_MRU;
d294 2
a300 2
    struct physical *p = link2physical(lcp->fsm.link);

d605 1
a605 1
  int type, length, sz, pos, op, callback_req;
d607 1
a607 1
  u_short mtu, mru, proto;
d613 1
a613 1
  sz = op = callback_req = 0;
d639 7
a645 1
          if (mru < MIN_MRU) {
d683 1
d689 12
a700 2
        mtu = lcp->fsm.bundle->cfg.mtu;
        if (mru < MIN_MRU || (!lcp->want_mrru && mru < mtu)) {
d702 1
a702 1
          lcp->his_mru = mru < mtu ? mtu : MIN_MRU;
d707 1
a707 1
          lcp->his_mru = mtu ? mtu : mru;
d713 5
a717 3
        if (mru > MAX_MRU)
          lcp->want_mru = MAX_MRU;
        else if (mru < MIN_MRU)
d1247 16
@


1.24
log
@Display MSCHAP as CHAP80 in ``show cpp''
Display the interface mtu in ``show iface''
@
text
@d1 5
a5 2
/*
 *	      PPP Link Control Protocol (LCP) Module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 15
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: lcp.c,v 1.23 2000/11/22 02:13:09 brian Exp $
d28 1
@


1.23
log
@Enable and accept MPPE by default (deflate & pred1 are preferred)
Accept MSCHAPv2 by default.
Hard sentence breaks
Describe tunneling more clearly
Some cosmetic netgraph fixes (Not used in OpenBSD)
@
text
@d20 1
a20 1
 * $OpenBSD: lcp.c,v 1.22 2000/11/02 00:54:34 brian Exp $
d192 1
a192 1
  prompt_Printf(arg->prompt, "           MSCHAP =    %s\n",
@


1.22
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d20 1
a20 1
 * $OpenBSD: lcp.c,v 1.21 2000/07/19 11:06:34 brian Exp $
d249 1
a249 1
  lcp->cfg.chap81 = 0;
@


1.21
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d20 1
a20 1
 * $OpenBSD: lcp.c,v 1.20 2000/06/24 23:38:30 brian Exp $
d196 2
d249 1
d298 3
d311 2
a312 1
      memcpy(&lcp->want_callback, &p->dl->cfg.callback, sizeof(struct callback));
d743 6
d763 1
d772 1
a772 1
            if (cp[4] == 0x80)
d774 3
a776 1
            else
d796 6
d841 3
d847 1
a847 1
            if (cp[4] == 0x80)
d850 4
a853 1
            else
d858 1
a858 1
                       cp[4] == 0x80 ? "configured" :
@


1.20
log
@Don't assign an MTU based on the peers first-link MRU in MP mode.
Use the peers MRRU as we're supposed to.
@
text
@d20 1
a20 1
 * $OpenBSD: lcp.c,v 1.19 2000/02/27 01:38:27 brian Exp $
a45 1
#include "lcp.h"
d51 1
d185 1
d251 1
d456 34
d538 2
@


1.19
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: lcp.c,v 1.18 2000/02/27 00:21:08 brian Exp $
d577 3
a579 4
          mtu = lcp->fsm.bundle->cfg.mtu;
          if (mru < MIN_MRU || mru < mtu) {
            /* Push him up to MTU or MIN_MRU */
            lcp->his_mrru = mru < mtu ? mtu : MIN_MRU;
d584 1
a584 1
            lcp->his_mrru = mtu ? mtu : mru;
@


1.18
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.17 2000/01/07 03:26:54 brian Exp $
@


1.17
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.16 1999/06/09 20:32:37 brian Exp $
d107 34
a140 27
static const char * const cftypes[] = {
  /* Check out the latest ``Assigned numbers'' rfc (rfc1700.txt) */
  "???",
  "MRU",	/* 1: Maximum-Receive-Unit */
  "ACCMAP",	/* 2: Async-Control-Character-Map */
  "AUTHPROTO",	/* 3: Authentication-Protocol */
  "QUALPROTO",	/* 4: Quality-Protocol */
  "MAGICNUM",	/* 5: Magic-Number */
  "RESERVED",	/* 6: RESERVED */
  "PROTOCOMP",	/* 7: Protocol-Field-Compression */
  "ACFCOMP",	/* 8: Address-and-Control-Field-Compression */
  "FCSALT",	/* 9: FCS-Alternatives */
  "SDP",	/* 10: Self-Describing-Pad */
  "NUMMODE",	/* 11: Numbered-Mode */
  "MULTIPROC",	/* 12: Multi-Link-Procedure */
  "CALLBACK",	/* 13: Callback */
  "CONTIME",	/* 14: Connect-Time */
  "COMPFRAME",	/* 15: Compound-Frames */
  "NDE",	/* 16: Nominal-Data-Encapsulation */
  "MRRU",	/* 17: Multilink-MRRU */
  "SHORTSEQ",	/* 18: Multilink-Short-Sequence-Number-Header */
  "ENDDISC",	/* 19: Multilink-Endpoint-Discriminator */
  "PROPRIETRY",	/* 20: Proprietary */
  "DCEID",	/* 21: DCE-Identifier */
  "MULTIPP",	/* 22: Multi-Link-Plus-Procedure */
  "LDBACP",	/* 23: Link Discriminator for BACP */
};
d142 2
a143 1
#define NCFTYPES (sizeof cftypes/sizeof cftypes[0])
d557 1
a557 4
    if (type < 0 || type >= NCFTYPES)
      snprintf(request, sizeof request, " <%d>[%d]", type, length);
    else
      snprintf(request, sizeof request, " %s[%d]", cftypes[type], length);
@


1.16
log
@Initialise `mp'.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.15 1999/06/09 16:55:25 brian Exp $
d104 1
a104 1
static const char *lcp_TimerNames[] =
d107 1
a107 1
static const char *cftypes[] = {
d543 1
a543 1
  callback_req = 0;
d1157 1
a1157 1
  mbuf_SetType(bp, MB_LCPIN);
@


1.15
log
@Allow our endpoint discriminator to be enabled, disabled, accepted
and denied.  This is necessary for some MP implementations that
get confused if you accept their endpoint discriminator but reject
their MRRU.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.14 1999/06/02 15:58:40 brian Exp $
d1056 1
@


1.14
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.13 1999/05/09 20:04:01 brian Exp $
d427 2
a428 1
  if (mp->cfg.enddisc.class != 0 && !REJECTED(lcp, TY_ENDDISC)) {
d1063 3
a1065 1
        } else if (length-3 < sizeof p->dl->peer.enddisc.address &&
d1085 1
a1085 1
      case MODE_NAK:	/* Treat this as a REJ, we don't vary our disc */
@


1.13
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.12 1999/05/08 11:06:36 brian Exp $
d433 2
a434 1
  fsm_Output(fp, CODE_CONFIGREQ, fp->reqid, buff, (u_char *)o - buff);
d441 2
a442 1
  fsm_Output(&lcp->fsm, CODE_PROTOREJ, lcp->fsm.reqid, option, count);
d460 1
a460 1
  fsm_Output(fp, CODE_TERMACK, id, NULL, 0);
d1153 1
@


1.12
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.11 1999/04/19 16:59:39 brian Exp $
d877 1
a877 3
	  /*
	   * MorningStar before v1.3 needs NAK
	   */
d903 1
a903 3
	  /*
	   * MorningStar before v1.3 needs NAK
	   */
@


1.11
log
@Escape stuff in the peers accmap as well as our own when async
encoding, and back out the negotiation strategy that didn't
quite have the right effect with some (bad?) ppp implementations.

Drop unexpected PAP/CHAP packets (if not in NETWORK or ESTABLISH
phase).

Make sure that we enter PHASE_ESTABLISH when we need to.

Detect HDLC frames correctly, not just when the whole header
is obtained by a single read().

Don't convert \r\n to \r\r\n in tty raw mode.

Use the correct macros for `', ``'', () and [].
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.72 1999/04/11 08:51:04 brian Exp $
d37 1
d48 1
a48 1
#include "lcpproto.h"
d1151 2
a1152 2
void
lcp_Input(struct lcp *lcp, struct mbuf *bp)
d1155 2
a1156 1
  fsm_Input(&lcp->fsm, bp);
@


1.10
log
@If we adjust our required ACCMAP due to a more restrictive
ACCMAP being REQuested by the peer, also increment our FSM
id so that we don't end up sending out a new REQ with the
same ID and different data (the changed ACCMAP).
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.9 1999/03/01 13:47:58 brian Exp $
a21 2
 * TODO:
 *	o Limit data field length by MRU
d646 2
a647 27
        if ((lcp->want_accmap | accmap) != lcp->want_accmap) {
          lcp->want_accmap |= accmap;	/* restrict our requested map */
          lcp->fsm.reqid++;		/* Invalidate the current REQ */
          /*
           * If we've already sent a REQ, we want to make sure that
           * we don't end up sending out a new REQ that doesn't contain
           * the data that the last one with the same id contained.
           * This also means that we ignore the peers response to our
           * last REQ due to an invalid fsm id (even though it's really
           * correct), probably resulting in a REQ timeout and a resend
           * with the new accmap and the new id.
           * If we're already in ST_ACKRCVD at this point, we simply end
           * up thinking that we negotiated the new accmap - which is ok
           * as we just end up escaping stuff that the peer probably
           * can't receive anyway.
           */
        }
        if (lcp->want_accmap == accmap) {
	  memcpy(dec->ackend, cp, 6);
	  dec->ackend += 6;
        } else {
          /* NAK with what we now want */
          *dec->nakend++ = *cp;
          *dec->nakend++ = 6;
          ua_htonl(&lcp->want_accmap, dec->nakend);
          dec->nakend += 4;
        }
d650 1
a650 1
	lcp->want_accmap |= accmap;
d653 1
a653 4
        if (lcp->want_accmap)
          log_Printf(LogWARN, "Peer is rejecting our ACCMAP.... bad news !\n");
        else
	  lcp->his_reject |= (1 << type);
@


1.9
log
@When negotiating ACCMAPs, sync our ACCMAP with the
peers by ORing the two together and NAKing or REQing
the result rather than allowing seperate local/peer
values.
If the peer REJs our ACCMAP and our ACCMAP isn't 0,
warn about it and ignore the rejection.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.8 1999/02/26 21:28:23 brian Exp $
d648 17
a664 1
        lcp->want_accmap |= accmap;	/* restrict our requested map */
@


1.8
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.7 1999/02/18 00:50:45 brian Exp $
d648 11
a658 2
	memcpy(dec->ackend, cp, 6);
	dec->ackend += 6;
d661 1
a661 1
	lcp->want_accmap = accmap;
d664 4
a667 1
	lcp->his_reject |= (1 << type);
@


1.7
log
@Fully support both NT and LANMan CHAP type 0x80 as both
authenticator and authenticatee.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.6 1999/02/06 03:22:40 brian Exp $
d84 1
a84 1
static void LcpInitRestartCounter(struct fsm *);
d174 4
a177 2
  prompt_Printf(arg->prompt, "\n           FSM retry = %us\n",
                lcp->cfg.fsmretry);
d223 1
a223 1
  fsm_Init(&lcp->fsm, "LCP", PROTO_LCP, mincode, LCP_MAXCODE, 10, LogLCP,
d230 3
a232 1
  lcp->cfg.fsmretry = DEF_FSMRETRY;
a250 1
  lcp->fsm.maxconfig = 10;
d317 1
a317 1
LcpInitRestartCounter(struct fsm * fp)
d322 12
a333 2
  fp->FsmTimer.load = lcp->cfg.fsmretry * SECTICKS;
  fp->restart = DEF_REQs;
d445 1
a445 1
LcpSentTerminateReq(struct fsm * fp)
d470 1
d491 2
d783 6
a788 2
            log_Printf(LogLCP, "Peer will only send %s (not supported)\n",
                       Auth2Nam(PROTO_CHAP, cp[4]));
d1085 1
a1085 1
      case MODE_NAK:	/* Treat this as a REJ, we don't vary or disc */
d1153 1
a1153 1
lcp_Input(struct lcp *lcp, struct mbuf * bp)
@


1.6
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.67 1999/01/28 01:56:32 brian Exp $
d180 7
a186 1
                command_ShowNegval(lcp->cfg.chap));
d231 5
a235 1
  lcp->cfg.chap = NEG_ACCEPTED;
d257 1
d274 18
a291 2
    lcp->want_auth = IsEnabled(lcp->cfg.chap) ? PROTO_CHAP :
                     IsEnabled(lcp->cfg.pap) ?  PROTO_PAP : 0;
d303 1
d381 1
a381 1
    o->data[2] = 0x05;
d646 2
a647 11
      switch (proto) {
      case PROTO_PAP:
        log_Printf(LogLCP, "%s 0x%04x (PAP)\n", request, proto);
        break;
      case PROTO_CHAP:
        log_Printf(LogLCP, "%s 0x%04x (CHAP 0x%02x)\n", request, proto, cp[4]);
        break;
      default:
        log_Printf(LogLCP, "%s 0x%04x\n", request, proto);
        break;
      }
d659 1
d662 1
a662 1
	  } else if (IsAccepted(lcp->cfg.chap)) {
d668 9
d682 1
a682 1
	  if (length < 5) {
d686 1
d688 2
a689 3
          if (IsAccepted(lcp->cfg.chap) && (cp[4] == 0x05 || cp[4] == 0x80))
#else
          if (IsAccepted(lcp->cfg.chap) && cp[4] == 0x05)
d691 1
a691 1
	  {
d693 1
a695 3
#ifdef HAVE_DES
            link2physical(fp->link)->dl->chap.using_MSChap = cp[4] == 0x80;
#endif
a696 1
            if (IsAccepted(lcp->cfg.chap)) {
d698 3
a700 3
              if (cp[4] == 0x80)
                log_Printf(LogWARN, "Chap 0x80 not available without DES\n");
              else
d702 20
a721 4
                log_Printf(LogWARN, "Chap 0x%02x not supported\n",
                           (unsigned)cp[4]);
            }
            if (IsAccepted(lcp->cfg.pap)) {
d742 1
a742 1
          if (IsEnabled(lcp->cfg.pap))
d744 2
a745 1
          else {
d751 6
a756 1
          if (IsEnabled(lcp->cfg.chap))
d758 11
a768 2
          else {
            log_Printf(LogLCP, "Peer will only send CHAP (not enabled)\n");
@


1.5
log
@If we've configured CBCP *and* another not-so-important
CALLBACK protocol and end up agreeing CBCP, DTRT and go
into CBCP phase rather than mistakenly terminating as
if CBCP wasn't agreed.
Problem reported by: Alexander Dubinin <alex@@nstl.nnov.ru>
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.4 1998/10/29 02:21:45 brian Exp $
d26 1
a26 1
#include <sys/types.h>
d67 3
@


1.4
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.3 1998/09/09 00:07:10 brian Exp $
d924 1
a924 1
        /* We don't do what he NAKs want, we do things in our preferred order */
@


1.3
log
@Initialise lcp::his_mru to the ``set mtu'' value if it's less
than DEF_MRU, allowing our interface mtu to be decreased
despite negotiation with the peer.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.2 1998/09/04 18:27:46 brian Exp $
d666 18
a683 7
	  } else if (IsAccepted(lcp->cfg.pap)) {
	    *dec->nakend++ = *cp;
	    *dec->nakend++ = 4;
	    *dec->nakend++ = (unsigned char) (PROTO_PAP >> 8);
	    *dec->nakend++ = (unsigned char) PROTO_PAP;
	  } else
	    goto reqreject;
@


1.2
log
@Don't cast potentially unaligned addresses to pointers to
non-char types on non-i386 architectures.
On Alpha and Sparc we get a bus error if we do.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.1 1998/08/31 00:22:22 brian Exp $
d236 3
a238 1
  lcp->his_mru = DEF_MRU;
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: lcp.c,v 1.62 1998/08/07 18:42:49 brian Exp $
d39 1
d299 1
d316 1
a316 1
      *(u_int32_t *)o->data = htonl(lcp->want_accmap);
d322 1
a322 1
    *(u_int16_t *)o->data = htons(lcp->want_mru);
d327 1
a327 1
    *(u_int32_t *)o->data = htonl(lcp->want_magic);
d332 3
a334 2
    *(u_int16_t *)o->data = htons(PROTO_LQR);
    *(u_int32_t *)(o->data + 2) = htonl(lcp->want_lqrperiod);
d340 2
a341 1
    *(u_int16_t *)o->data = htons(PROTO_PAP);
d346 2
a347 1
    *(u_int16_t *)o->data = htons(PROTO_CHAP);
d374 1
a374 1
    *(u_int16_t *)o->data = htons(lcp->want_mrru);
a486 1
  u_int16_t *sp;
d511 1
a511 2
      sp = (u_int16_t *)(cp + 2);
      mru = htons(*sp);
d525 2
a526 2
	    *sp = htons((u_int16_t)lcp->his_mrru);
	    memcpy(dec->nakend, cp, 4);
d560 1
a560 2
      sp = (u_int16_t *) (cp + 2);
      mru = htons(*sp);
d569 2
a570 2
          *sp = htons((u_int16_t)lcp->his_mru);
          memcpy(dec->nakend, cp, 4);
d593 1
a593 1
      accmap = htonl(*(u_int32_t *)(cp + 2));
d612 1
a612 2
      sp = (u_int16_t *) (cp + 2);
      proto = ntohs(*sp);
d737 1
a737 1
      magic = ntohl(*(u_int32_t *)(cp + 2));
@

