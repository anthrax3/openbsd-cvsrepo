head	1.16;
access;
symbols
	OPENBSD_5_5:1.15.0.38
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.34
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.32
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.30
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.28
	OPENBSD_5_0:1.15.0.26
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.24
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.22
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.18
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.20
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.16
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.14
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.12
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.10
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.14
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.12
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.10
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.8
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.6
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.6
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.15;

1.15
date	2005.07.17.19.13.24;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.16.14.47.02;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.27.01.38.26;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.02.15.58.40;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.08.11.06.35;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.04.19.16.59.39;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.03.29.08.20.32;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.11.10.14.50;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.36;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.20;	author brian;	state Exp;
branches;
next	;


desc
@@


1.16
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: hdlc.c,v 1.15 2005/07/17 19:13:24 brad Exp $
 */

#include <sys/param.h>
#include <sys/un.h>

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <termios.h>

#include "defs.h"
#include "layer.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "auth.h"
#include "lcp.h"
#include "async.h"
#include "ccp.h"
#include "link.h"
#include "descriptor.h"
#include "chap.h"
#include "physical.h"
#include "prompt.h"
#include "chat.h"
#include "mp.h"
#include "cbcp.h"
#include "datalink.h"

static u_int16_t const fcstab[256] = {
   /* 00 */ 0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
   /* 08 */ 0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
   /* 10 */ 0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
   /* 18 */ 0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
   /* 20 */ 0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
   /* 28 */ 0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
   /* 30 */ 0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
   /* 38 */ 0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
   /* 40 */ 0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
   /* 48 */ 0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
   /* 50 */ 0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
   /* 58 */ 0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
   /* 60 */ 0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
   /* 68 */ 0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
   /* 70 */ 0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
   /* 78 */ 0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
   /* 80 */ 0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
   /* 88 */ 0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
   /* 90 */ 0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
   /* 98 */ 0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
   /* a0 */ 0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
   /* a8 */ 0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
   /* b0 */ 0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
   /* b8 */ 0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
   /* c0 */ 0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
   /* c8 */ 0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
   /* d0 */ 0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
   /* d8 */ 0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
   /* e0 */ 0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
   /* e8 */ 0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
   /* f0 */ 0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
   /* f8 */ 0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

void
hdlc_Init(struct hdlc *hdlc, struct lcp *lcp)
{
  memset(hdlc, '\0', sizeof(struct hdlc));
  hdlc->lqm.owner = lcp;
}

/*
 *  HDLC FCS computation. Read RFC 1171 Appendix B and CCITT X.25 section
 *  2.27 for further details.
 */
u_short
hdlc_Fcs(u_char *cp, size_t len)
{
  u_short fcs = INITFCS;

  while (len--)
    fcs = (fcs >> 8) ^ fcstab[(fcs ^ *cp++) & 0xff];

  return fcs;
}

static inline u_short
HdlcFcsBuf(u_short fcs, struct mbuf *m)
{
  int len;
  u_char *pos, *end;

  len = m_length(m);
  pos = MBUF_CTOP(m);
  end = pos + m->m_len;
  while (len--) {
    fcs = (fcs >> 8) ^ fcstab[(fcs ^ *pos++) & 0xff];
    if (pos == end && len) {
      m = m->m_next;
      pos = MBUF_CTOP(m);
      end = pos + m->m_len;
    }
  }
  return (fcs);
}

int
hdlc_WrapperOctets(struct lcp *lcp, u_short proto)
{
  return 2;
}

static struct mbuf *
hdlc_LayerPush(struct bundle *bundle, struct link *l, struct mbuf *bp,
               int pri, u_short *proto)
{
  struct mbuf *last;
  u_char *cp;
  u_short fcs;

  m_settype(bp, MB_HDLCOUT);
  fcs = HdlcFcsBuf(INITFCS, bp);
  fcs = ~fcs;

  for (last = bp; last->m_next; last = last->m_next)
    ;

  if (last->m_size - last->m_offset - last->m_len >= 2) {
    cp = MBUF_CTOP(last) + last->m_len;
    last->m_len += 2;
  } else {
    struct mbuf *tail = m_get(2, MB_HDLCOUT);
    last->m_next = tail;
    cp = MBUF_CTOP(tail);
  }

  *cp++ = fcs & 0377;		/* Low byte first (nothing like consistency) */
  *cp++ = fcs >> 8;

  log_DumpBp(LogHDLC, "hdlc_Output", bp);

  return bp;
}

/* Check out the latest ``Assigned numbers'' rfc (rfc1700.txt) */
static struct {
  u_short from;
  u_short to;
  const char *name;
} protocols[] = {
  { 0x0001, 0x0001, "Padding Protocol" },
  { 0x0003, 0x001f, "reserved (transparency inefficient)" },
  { 0x0021, 0x0021, "Internet Protocol" },
  { 0x0023, 0x0023, "OSI Network Layer" },
  { 0x0025, 0x0025, "Xerox NS IDP" },
  { 0x0027, 0x0027, "DECnet Phase IV" },
  { 0x0029, 0x0029, "Appletalk" },
  { 0x002b, 0x002b, "Novell IPX" },
  { 0x002d, 0x002d, "Van Jacobson Compressed TCP/IP" },
  { 0x002f, 0x002f, "Van Jacobson Uncompressed TCP/IP" },
  { 0x0031, 0x0031, "Bridging PDU" },
  { 0x0033, 0x0033, "Stream Protocol (ST-II)" },
  { 0x0035, 0x0035, "Banyan Vines" },
  { 0x0037, 0x0037, "reserved (until 1993)" },
  { 0x0039, 0x0039, "AppleTalk EDDP" },
  { 0x003b, 0x003b, "AppleTalk SmartBuffered" },
  { 0x003d, 0x003d, "Multi-Link" },
  { 0x003f, 0x003f, "NETBIOS Framing" },
  { 0x0041, 0x0041, "Cisco Systems" },
  { 0x0043, 0x0043, "Ascom Timeplex" },
  { 0x0045, 0x0045, "Fujitsu Link Backup and Load Balancing (LBLB)" },
  { 0x0047, 0x0047, "DCA Remote Lan" },
  { 0x0049, 0x0049, "Serial Data Transport Protocol (PPP-SDTP)" },
  { 0x004b, 0x004b, "SNA over 802.2" },
  { 0x004d, 0x004d, "SNA" },
  { 0x004f, 0x004f, "IP6 Header Compression" },
  { 0x0051, 0x0051, "KNX Bridging Data" },
  { 0x0053, 0x0053, "Encryption" },
  { 0x0055, 0x0055, "Individual Link Encryption" },
  { 0x0057, 0x0057, "Internet Protocol V6" },
  { 0x006f, 0x006f, "Stampede Bridging" },
  { 0x0071, 0x0071, "BAP Bandwidth Allocation Protocol" },
  { 0x0073, 0x0073, "MP+ Protocol" },
  { 0x007d, 0x007d, "reserved (Control Escape)" },
  { 0x007f, 0x007f, "reserved (compression inefficient)" },
  { 0x00cf, 0x00cf, "reserved (PPP NLPID)" },
  { 0x00fb, 0x00fb, "compression on single link in multilink group" },
  { 0x00fd, 0x00fd, "1st choice compression" },
  { 0x00ff, 0x00ff, "reserved (compression inefficient)" },
  { 0x0200, 0x02ff, "(compression inefficient)" },
  { 0x0201, 0x0201, "802.1d Hello Packets" },
  { 0x0203, 0x0203, "IBM Source Routing BPDU" },
  { 0x0205, 0x0205, "DEC LANBridge100 Spanning Tree" },
  { 0x0207, 0x0207, "Cisco Discovery Protocol" },
  { 0x0209, 0x0209, "Netcs Twin Routing" },
  { 0x0231, 0x0231, "Luxcom" },
  { 0x0233, 0x0233, "Sigma Network Systems" },
  { 0x0235, 0x0235, "Apple Client Server Protocol" },
  { 0x1e00, 0x1eff, "(compression inefficient)" },
  { 0x4001, 0x4001, "Cray Communications Control Protocol" },
  { 0x4003, 0x4003, "CDPD Mobile Network Registration Protocol" },
  { 0x4021, 0x4021, "Stacker LZS" },
  { 0x8001, 0x801f, "Not Used - reserved" },
  { 0x8021, 0x8021, "Internet Protocol Control Protocol" },
  { 0x8023, 0x8023, "OSI Network Layer Control Protocol" },
  { 0x8025, 0x8025, "Xerox NS IDP Control Protocol" },
  { 0x8027, 0x8027, "DECnet Phase IV Control Protocol" },
  { 0x8029, 0x8029, "Appletalk Control Protocol" },
  { 0x802b, 0x802b, "Novell IPX Control Protocol" },
  { 0x802d, 0x802d, "reserved" },
  { 0x802f, 0x802f, "reserved" },
  { 0x8031, 0x8031, "Bridging NCP" },
  { 0x8033, 0x8033, "Stream Protocol Control Protocol" },
  { 0x8035, 0x8035, "Banyan Vines Control Protocol" },
  { 0x8037, 0x8037, "reserved till 1993" },
  { 0x8039, 0x8039, "reserved" },
  { 0x803b, 0x803b, "reserved" },
  { 0x803d, 0x803d, "Multi-Link Control Protocol" },
  { 0x803f, 0x803f, "NETBIOS Framing Control Protocol" },
  { 0x8041, 0x8041, "Cisco Systems Control Protocol" },
  { 0x8043, 0x8043, "Ascom Timeplex" },
  { 0x8045, 0x8045, "Fujitsu LBLB Control Protocol" },
  { 0x8047, 0x8047, "DCA Remote Lan Network Control Protocol (RLNCP)" },
  { 0x8049, 0x8049, "Serial Data Control Protocol (PPP-SDCP)" },
  { 0x804b, 0x804b, "SNA over 802.2 Control Protocol" },
  { 0x804d, 0x804d, "SNA Control Protocol" },
  { 0x804f, 0x804f, "IP6 Header Compression Control Protocol" },
  { 0x8051, 0x8051, "KNX Bridging Control Protocol" },
  { 0x8053, 0x8053, "Encryption Control Protocol" },
  { 0x8055, 0x8055, "Individual Link Encryption Control Protocol" },
  { 0x8057, 0x8057, "Internet Protocol V6 Control Protocol" },
  { 0x806f, 0x806f, "Stampede Bridging Control Protocol" },
  { 0x8073, 0x8073, "MP+ Control Protocol" },
  { 0x8071, 0x8071, "BACP Bandwidth Allocation Control Protocol" },
  { 0x807d, 0x807d, "Not Used - reserved" },
  { 0x80cf, 0x80cf, "Not Used - reserved" },
  { 0x80fb, 0x80fb, "compression on single link in multilink group control" },
  { 0x80fd, 0x80fd, "Compression Control Protocol" },
  { 0x80ff, 0x80ff, "Not Used - reserved" },
  { 0x8207, 0x8207, "Cisco Discovery Protocol Control" },
  { 0x8209, 0x8209, "Netcs Twin Routing" },
  { 0x8235, 0x8235, "Apple Client Server Protocol Control" },
  { 0xc021, 0xc021, "Link Control Protocol" },
  { 0xc023, 0xc023, "Password Authentication Protocol" },
  { 0xc025, 0xc025, "Link Quality Report" },
  { 0xc027, 0xc027, "Shiva Password Authentication Protocol" },
  { 0xc029, 0xc029, "CallBack Control Protocol (CBCP)" },
  { 0xc081, 0xc081, "Container Control Protocol" },
  { 0xc223, 0xc223, "Challenge Handshake Authentication Protocol" },
  { 0xc225, 0xc225, "RSA Authentication Protocol" },
  { 0xc227, 0xc227, "Extensible Authentication Protocol" },
  { 0xc26f, 0xc26f, "Stampede Bridging Authorization Protocol" },
  { 0xc281, 0xc281, "Proprietary Authentication Protocol" },
  { 0xc283, 0xc283, "Proprietary Authentication Protocol" },
  { 0xc481, 0xc481, "Proprietary Node ID Authentication Protocol" }
};

#define NPROTOCOLS (sizeof protocols/sizeof protocols[0])

const char *
hdlc_Protocol2Nam(u_short proto)
{
  int f;

  for (f = 0; f < NPROTOCOLS; f++)
    if (proto >= protocols[f].from && proto <= protocols[f].to)
      return protocols[f].name;
    else if (proto < protocols[f].from)
      break;
  return "unrecognised protocol";
}

static struct mbuf *
hdlc_LayerPull(struct bundle *b, struct link *l, struct mbuf *bp,
               u_short *proto)
{
  struct physical *p = link2physical(l);
  u_short fcs;
  int len;

  if (!p) {
    log_Printf(LogERROR, "Can't Pull a hdlc packet from a logical link\n");
    return bp;
  }

  log_DumpBp(LogHDLC, "hdlc_LayerPull:", bp);

  bp = m_pullup(bp);
  len = m_length(bp);
  fcs = hdlc_Fcs(MBUF_CTOP(bp), len);

  log_Printf(LogDEBUG, "%s: hdlc_LayerPull: fcs = %04x (%s)\n",
             p->link.name, fcs, (fcs == GOODFCS) ? "good" : "BAD!");

  p->hdlc.lqm.ifInOctets += len + 1;			/* plus 1 flag octet! */

  if (fcs != GOODFCS) {
    p->hdlc.lqm.ifInErrors++;
    p->hdlc.stats.badfcs++;
    m_freem(bp);
    return NULL;
  }

  /* Either done here or by the sync layer */
  p->hdlc.lqm.lqr.InGoodOctets += len + 1;		/* plus 1 flag octet! */
  p->hdlc.lqm.ifInUniPackets++;

  if (len < 4) {			/* rfc1662 section 4.3 */
    m_freem(bp);
    bp = NULL;
  }

  bp = m_adj(bp, -2);			/* discard the FCS */
  m_settype(bp, MB_HDLCIN);

  return bp;
}

/* Detect a HDLC frame */

static const struct frameheader {
  const u_char *data;
  int len;
} FrameHeaders[] = {
  { "\176\377\003\300\041", 5 },
  { "\176\377\175\043\300\041", 6 },
  { "\176\177\175\043\100\041", 6 },
  { "\176\175\337\175\043\300\041", 7 },
  { "\176\175\137\175\043\100\041", 7 },
  { NULL, 0 }
};

int
hdlc_Detect(u_char const **cp, int n, int issync)
{
  const struct frameheader *fh;
  const u_char *h;
  size_t len, cmp;

  while (n) {
    for (fh = FrameHeaders; fh->len; fh++) {
      h = issync ? fh->data + 1 : fh->data;
      len = issync ? fh->len - 1 : fh->len;
      cmp = n >= len ? len : n;
      if (memcmp(*cp, h, cmp) == 0)
        return cmp == len;
    }
    n--;
    (*cp)++;
  }

  return 0;
}

int
hdlc_ReportStatus(struct cmdargs const *arg)
{
  struct hdlc *hdlc = &arg->cx->physical->hdlc;

  prompt_Printf(arg->prompt, "%s HDLC level errors:\n", arg->cx->name);
  prompt_Printf(arg->prompt, " Bad Frame Check Sequence fields: %u\n",
	        hdlc->stats.badfcs);
  prompt_Printf(arg->prompt, " Bad address (!= 0x%02x) fields:    %u\n",
	        HDLC_ADDR, hdlc->stats.badaddr);
  prompt_Printf(arg->prompt, " Bad command (!= 0x%02x) fields:    %u\n",
	        HDLC_UI, hdlc->stats.badcommand);
  prompt_Printf(arg->prompt, " Unrecognised protocol fields:    %u\n",
	        hdlc->stats.unknownproto);
  return 0;
}

static void
hdlc_ReportTime(void *v)
{
  /* Moan about HDLC errors */
  struct hdlc *hdlc = (struct hdlc *)v;

  timer_Stop(&hdlc->ReportTimer);

  if (memcmp(&hdlc->laststats, &hdlc->stats, sizeof hdlc->stats)) {
    log_Printf(LogPHASE,
              "%s: HDLC errors -> FCS: %u, ADDR: %u, COMD: %u, PROTO: %u\n",
              hdlc->lqm.owner->fsm.link->name,
	      hdlc->stats.badfcs - hdlc->laststats.badfcs,
              hdlc->stats.badaddr - hdlc->laststats.badaddr,
              hdlc->stats.badcommand - hdlc->laststats.badcommand,
              hdlc->stats.unknownproto - hdlc->laststats.unknownproto);
    hdlc->laststats = hdlc->stats;
  }

  timer_Start(&hdlc->ReportTimer);
}

void
hdlc_StartTimer(struct hdlc *hdlc)
{
  timer_Stop(&hdlc->ReportTimer);
  hdlc->ReportTimer.load = 60 * SECTICKS;
  hdlc->ReportTimer.arg = hdlc;
  hdlc->ReportTimer.func = hdlc_ReportTime;
  hdlc->ReportTimer.name = "hdlc";
  timer_Start(&hdlc->ReportTimer);
}

void
hdlc_StopTimer(struct hdlc *hdlc)
{
  timer_Stop(&hdlc->ReportTimer);
}

struct layer hdlclayer = { LAYER_HDLC, "hdlc", hdlc_LayerPush, hdlc_LayerPull };
@


1.15
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: hdlc.c,v 1.14 2004/11/16 14:47:02 brad Exp $
@


1.14
log
@Re-implement LQM, this time according to the rfc.

From FreeBSD

ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: hdlc.c,v 1.13 2001/08/19 23:22:17 brian Exp $
d34 1
@


1.13
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: hdlc.c,v 1.12 2001/06/13 21:33:41 brian Exp $
d320 3
a322 1
  fcs = hdlc_Fcs(MBUF_CTOP(bp), bp->m_len);
d327 2
d330 1
a330 1
    p->hdlc.lqm.SaveInErrors++;
d336 3
a338 2
  p->hdlc.lqm.SaveInOctets += bp->m_len + 1;
  p->hdlc.lqm.SaveInPackets++;
a339 1
  len = m_length(bp);
@


1.12
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d212 1
d263 1
@


1.11
log
@$Id$ -> $OpenBSD$
@
text
@d1 5
a5 2
/*
 *	     PPP High Level Link Control (HDLC) Module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 15
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: hdlc.c,v 1.10 2000/01/07 03:26:54 brian Exp $
 *
 *	TODO:
d30 1
@


1.10
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: hdlc.c,v 1.9 1999/07/15 02:10:32 brian Exp $
@


1.9
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d20 1
a20 1
 * $Id: hdlc.c,v 1.7 1999/06/02 15:58:40 brian Exp $
a24 3
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a39 2
#include "proto.h"
#include "iplist.h"
a40 4
#include "slcompress.h"
#include "ipcp.h"
#include "ip.h"
#include "vjcomp.h"
a41 1
#include "pap.h"
a53 5
#include "filter.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "bundle.h"
d118 1
a118 1
  len = mbuf_Length(m);
d120 1
a120 1
  end = pos + m->cnt;
d124 1
a124 1
      m = m->next;
d126 1
a126 1
      end = pos + m->cnt;
d146 1
a146 1
  mbuf_SetType(bp, MB_HDLCOUT);
d150 1
a150 1
  for (last = bp; last->next; last = last->next)
d153 3
a155 3
  if (last->size - last->offset - last->cnt >= 2) {
    cp = MBUF_CTOP(last) + last->cnt;
    last->cnt += 2;
d157 2
a158 2
    struct mbuf *tail = mbuf_Alloc(2, MB_HDLCOUT);
    last->next = tail;
d309 1
a309 1
  log_DumpBp(LogHDLC, "hdlc_Input:", bp);
d311 1
a311 1
  fcs = hdlc_Fcs(MBUF_CTOP(bp), bp->cnt);
d313 1
a313 1
  log_Printf(LogDEBUG, "%s: hdlc_Input: fcs = %04x (%s)\n",
d319 1
a319 1
    mbuf_Free(bp);
d323 1
a323 1
  p->hdlc.lqm.SaveInOctets += bp->cnt + 1;
d326 1
a326 1
  len = mbuf_Length(bp);
d328 1
a328 1
    mbuf_Free(bp);
d332 2
a333 2
  bp = mbuf_Truncate(bp, len - 2);	/* discard the FCS */
  mbuf_SetType(bp, MB_HDLCIN);
@


1.8
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d25 3
a27 3
/* #include <netinet/in.h> (auto-remove) */
/* #include <netinet/in_systm.h> (auto-remove) */
/* #include <netinet/ip.h> (auto-remove) */
d43 2
a44 2
/* #include "proto.h" (auto-remove) */
/* #include "iplist.h" (auto-remove) */
d46 4
a49 4
/* #include "slcompress.h" (auto-remove) */
/* #include "ipcp.h" (auto-remove) */
/* #include "ip.h" (auto-remove) */
/* #include "vjcomp.h" (auto-remove) */
d51 1
a51 1
/* #include "pap.h" (auto-remove) */
d64 1
a64 1
/* #include "filter.h" (auto-remove) */
d66 1
a66 1
/* #include "radius.h" (auto-remove) */
d68 1
a68 1
/* #include "bundle.h" (auto-remove) */
@


1.7
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d20 1
a20 1
 * $Id: hdlc.c,v 1.6 1999/05/08 11:06:35 brian Exp $
d25 3
a27 3
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
d43 2
a44 2
#include "proto.h"
#include "iplist.h"
d46 4
a49 4
#include "slcompress.h"
#include "ipcp.h"
#include "ip.h"
#include "vjcomp.h"
d51 1
a51 1
#include "pap.h"
d64 1
a64 1
#include "filter.h"
d66 1
a66 1
#include "radius.h"
d68 1
a68 1
#include "bundle.h"
@


1.6
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: hdlc.c,v 1.5 1999/04/19 16:59:39 brian Exp $
d161 1
d348 1
d353 1
a353 3
/*
 * Detect a HDLC frame
 */
@


1.5
log
@Escape stuff in the peers accmap as well as our own when async
encoding, and back out the negotiation strategy that didn't
quite have the right effect with some (bad?) ppp implementations.

Drop unexpected PAP/CHAP packets (if not in NETWORK or ESTABLISH
phase).

Make sure that we enter PHASE_ESTABLISH when we need to.

Detect HDLC frames correctly, not just when the whole header
is obtained by a single read().

Don't convert \r\n to \r\r\n in tty raw mode.

Use the correct macros for `', ``'', () and [].
@
text
@d20 1
a20 1
 * $Id: hdlc.c,v 1.4 1999/03/29 08:20:32 brian Exp $
d35 1
d43 1
a43 1
#include "lcpproto.h"
d116 2
a117 2
inline u_short
hdlc_Fcs(u_short fcs, u_char * cp, int len)
d119 2
d123 2
a124 1
  return (fcs);
d147 9
a155 2
void
hdlc_Output(struct link *l, int pri, u_short proto, struct mbuf *bp)
d157 1
a157 2
  struct physical *p = link2physical(l);
  struct mbuf *mhp, *mfcs;
d161 5
a165 13
  if (!p || physical_IsSync(p))
    mfcs = NULL;
  else
    mfcs = mbuf_Alloc(2, MB_HDLCOUT);

  mhp = mbuf_Alloc(4, MB_HDLCOUT);
  mhp->cnt = 0;
  cp = MBUF_CTOP(mhp);
  if (p && (proto == PROTO_LCP || l->lcp.his_acfcomp == 0)) {
    *cp++ = HDLC_ADDR;
    *cp++ = HDLC_UI;
    mhp->cnt += 2;
  }
d167 3
a169 6
  /*
   * If possible, compress protocol field.
   */
  if (l->lcp.his_protocomp && (proto & 0xff00) == 0) {
    *cp++ = proto;
    mhp->cnt++;
d171 3
a173 61
    *cp++ = proto >> 8;
    *cp = proto & 0377;
    mhp->cnt += 2;
  }

  mhp->next = bp = mbuf_Contiguous(bp);

  if (!p) {
    /*
     * This is where we multiplex the data over our available physical
     * links.  We don't frame our logical link data.  Instead we wait
     * for the logical link implementation to chop our data up and pile
     * it into the physical links by re-calling this function with the
     * encapsulated fragments.
     */
    link_Output(l, pri, mhp);
    return;
  }

  bp->next = mfcs;		/* Tack mfcs onto the end */

  p->hdlc.lqm.OutOctets += mbuf_Length(mhp) + 1;
  p->hdlc.lqm.OutPackets++;

  if (proto == PROTO_LQR) {
    /* Overwrite the entire packet */
    struct lqrdata lqr;

    lqr.MagicNumber = p->link.lcp.want_magic;
    lqr.LastOutLQRs = p->hdlc.lqm.lqr.peer.PeerOutLQRs;
    lqr.LastOutPackets = p->hdlc.lqm.lqr.peer.PeerOutPackets;
    lqr.LastOutOctets = p->hdlc.lqm.lqr.peer.PeerOutOctets;
    lqr.PeerInLQRs = p->hdlc.lqm.lqr.SaveInLQRs;
    lqr.PeerInPackets = p->hdlc.lqm.SaveInPackets;
    lqr.PeerInDiscards = p->hdlc.lqm.SaveInDiscards;
    lqr.PeerInErrors = p->hdlc.lqm.SaveInErrors;
    lqr.PeerInOctets = p->hdlc.lqm.SaveInOctets;
    lqr.PeerOutPackets = p->hdlc.lqm.OutPackets;
    lqr.PeerOutOctets = p->hdlc.lqm.OutOctets;
    if (p->hdlc.lqm.lqr.peer.LastOutLQRs == p->hdlc.lqm.lqr.OutLQRs) {
      /*
       * only increment if it's the first time or we've got a reply
       * from the last one
       */
      lqr.PeerOutLQRs = ++p->hdlc.lqm.lqr.OutLQRs;
      lqr_Dump(l->name, "Output", &lqr);
    } else {
      lqr.PeerOutLQRs = p->hdlc.lqm.lqr.OutLQRs;
      lqr_Dump(l->name, "Output (again)", &lqr);
    }
    lqr_ChangeOrder(&lqr, (struct lqrdata *)MBUF_CTOP(bp));
  }

  if (mfcs) {
    mfcs->cnt = 0;
    fcs = HdlcFcsBuf(INITFCS, mhp);
    fcs = ~fcs;
    cp = MBUF_CTOP(mfcs);
    *cp++ = fcs & 0377;		/* Low byte first!! */
    *cp++ = fcs >> 8;
    mfcs->cnt = 2;
d176 2
a177 1
  log_DumpBp(LogHDLC, "hdlc_Output", mhp);
d179 1
a179 2
  link_ProtocolRecord(l, proto, PROTO_OUT);
  log_Printf(LogDEBUG, "hdlc_Output: proto = 0x%04x\n", proto);
d181 1
a181 4
  if (physical_IsSync(p))
    link_Output(l, pri, mhp);          /* Send it raw */
  else
    async_Output(pri, mhp, proto, p);
d310 3
a312 3
void
hdlc_DecodePacket(struct bundle *bundle, u_short proto, struct mbuf * bp,
                  struct link *l)
d315 2
a316 2
  u_char *cp;
  const char *type;
d318 3
a320 92
  log_Printf(LogDEBUG, "DecodePacket: proto = 0x%04x\n", proto);

  /* decompress everything.  CCP needs uncompressed data too */
  if ((bp = ccp_Decompress(&l->ccp, &proto, bp)) == NULL)
    return;

  switch (proto) {
  case PROTO_LCP:
    lcp_Input(&l->lcp, bp);
    break;
  case PROTO_PAP:
    if (p)
      pap_Input(p, bp);
    else {
      log_Printf(LogERROR, "DecodePacket: PAP: Not a physical link !\n");
      mbuf_Free(bp);
    }
    break;
  case PROTO_CBCP:
    if (p)
      cbcp_Input(p, bp);
    else {
      log_Printf(LogERROR, "DecodePacket: CBCP: Not a physical link !\n");
      mbuf_Free(bp);
    }
    break;
  case PROTO_LQR:
    if (p) {
      p->hdlc.lqm.lqr.SaveInLQRs++;
      lqr_Input(p, bp);
    } else {
      log_Printf(LogERROR, "DecodePacket: LQR: Not a physical link !\n");
      mbuf_Free(bp);
    }
    break;
  case PROTO_CHAP:
    if (p)
      chap_Input(p, bp);
    else {
      log_Printf(LogERROR, "DecodePacket: CHAP: Not a physical link !\n");
      mbuf_Free(bp);
    }
    break;
  case PROTO_VJUNCOMP:
  case PROTO_VJCOMP:
    bp = vj_Input(&bundle->ncp.ipcp, bp, proto);
    if (bp == NULL)
      break;
    /* fall down */
  case PROTO_IP:
    ip_Input(bundle, bp);
    break;
  case PROTO_IPCP:
    ipcp_Input(&bundle->ncp.ipcp, bundle, bp);
    break;
  case PROTO_CCP:
    ccp_Input(&l->ccp, bundle, bp);
    break;
  case PROTO_MP:
    if (bundle->ncp.mp.active) {
      if (p)
        mp_Input(&bundle->ncp.mp, bp, p);
      else {
        log_Printf(LogWARN, "DecodePacket: Can't do MP inside MP !\n");
        mbuf_Free(bp);
      }
      break;
    }
    /* Fall through */
  default:
    switch (proto) {
      case PROTO_MP:
      case PROTO_COMPD:
      case PROTO_ICOMPD:
        type = "Unexpected";
        break;
      default:
        type = "Unknown";
        break;
    }
    log_Printf(LogPHASE, "%s protocol 0x%04x (%s)\n", type, proto,
               hdlc_Protocol2Nam(proto));
    bp->offset -= 2;
    bp->cnt += 2;
    cp = MBUF_CTOP(bp);
    lcp_SendProtoRej(&l->lcp, cp, bp->cnt);
    if (p) {
      p->hdlc.lqm.SaveInDiscards++;
      p->hdlc.stats.unknownproto++;
    }
    mbuf_Free(bp);
    break;
a321 1
}
d323 1
a323 10
static int
hdlc_GetProto(const u_char *cp, u_short *proto)
{
  *proto = *cp;
  if (!(*proto & 1)) {
    *proto = (*proto << 8) | cp[1];
    return 2;
  }
  return 1;
}
d325 1
a325 6
void
hdlc_Input(struct bundle *bundle, struct mbuf * bp, struct physical *physical)
{
  u_short fcs, proto;
  u_char *cp, addr, ctrl;
  int n;
d327 2
a328 6
  log_DumpBp(LogHDLC, "hdlc_Input:", bp);
  if (physical_IsSync(physical))
    fcs = GOODFCS;
  else
    fcs = hdlc_Fcs(INITFCS, MBUF_CTOP(bp), bp->cnt);
  physical->hdlc.lqm.SaveInOctets += bp->cnt + 1;
a329 2
  log_Printf(LogDEBUG, "%s: hdlc_Input: fcs = %04x (%s)\n",
            physical->link.name, fcs, (fcs == GOODFCS) ? "good" : "BAD!");
d331 2
a332 2
    physical->hdlc.lqm.SaveInErrors++;
    physical->hdlc.stats.badfcs++;
d334 1
a334 1
    return;
a335 2
  if (!physical_IsSync(physical))
    bp->cnt -= 2;		/* discard FCS part */
d337 5
a341 1
  if (bp->cnt < 2) {		/* XXX: raise this bar ? */
d343 1
a343 1
    return;
a344 1
  cp = MBUF_CTOP(bp);
d346 1
a346 29
  if (!physical->link.lcp.want_acfcomp) {
    /* We expect the packet not to be compressed */
    addr = *cp++;
    if (addr != HDLC_ADDR) {
      physical->hdlc.lqm.SaveInErrors++;
      physical->hdlc.stats.badaddr++;
      log_Printf(LogDEBUG, "hdlc_Input: addr %02x\n", *cp);
      mbuf_Free(bp);
      return;
    }
    ctrl = *cp++;
    if (ctrl != HDLC_UI) {
      physical->hdlc.lqm.SaveInErrors++;
      physical->hdlc.stats.badcommand++;
      log_Printf(LogDEBUG, "hdlc_Input: %02x\n", *cp);
      mbuf_Free(bp);
      return;
    }
    bp->offset += 2;
    bp->cnt -= 2;
  } else if (cp[0] == HDLC_ADDR && cp[1] == HDLC_UI) {
    /*
     * We can receive compressed packets, but the peer still sends
     * uncompressed packets !
     */
    cp += 2;
    bp->offset += 2;
    bp->cnt -= 2;
  }
d348 1
a348 11
  n = hdlc_GetProto(cp, &proto);
  bp->offset += n;
  bp->cnt -= n;
  if (!physical->link.lcp.want_protocomp && n == 1)
    log_Printf(LogHDLC, "%s: Warning: received a proto-compressed packet !\n",
               physical->link.name);

  link_ProtocolRecord(&physical->link, proto, PROTO_IN);
  physical->hdlc.lqm.SaveInPackets++;

  hdlc_DecodePacket(bundle, proto, bp, &physical->link);
d444 2
@


1.4
log
@Ensure that the thing we're casting to struct ip
is aligned for non-i386 architectures.
@
text
@d20 1
a20 1
 * $Id: hdlc.c,v 1.3 1999/02/11 10:14:50 brian Exp $
d561 1
a561 1
 *  Detect a HDLC frame
d564 10
a573 7
static const char *FrameHeaders[] = {
  "\176\377\003\300\041",
  "\176\377\175\043\300\041",
  "\176\177\175\043\100\041",
  "\176\175\337\175\043\300\041",
  "\176\175\137\175\043\100\041",
  NULL,
d576 2
a577 2
u_char *
hdlc_Detect(struct physical *physical, u_char *cp, int n)
d579 15
a593 2
  const char *fp, **hp;
  char *ptr;
d595 1
a595 11
  cp[n] = '\0';				/* be sure to null terminate */
  ptr = NULL;
  for (hp = FrameHeaders; *hp; hp++) {
    fp = *hp;
    if (physical_IsSync(physical))
      fp++;
    ptr = strstr((char *)cp, fp);	/* XXX: cp may have embedded NULs */
    if (ptr)
      break;
  }
  return (u_char *)ptr;
@


1.3
log
@When resending chap challenges, resend the same challenge
each time rather than making up a new one.

Increase the authname/authkey max sizes to 100 characters.

Allow ``authkey'' specifications beginning with ``!''.
When a challenge is received, the text following the
``!'' is executed as a program (expanding stuff in the same
way that ``sh'' and ``!bg'' do).  The program is passed the
peer name, peer challenge and local ``authname'' on standard
input and is expected to output the name/key combination that
should be used to build the CHAP response.

This provides support for Secure ID cards (guess what I was
given at work recently!) using CHAP.

Examples will follow.
@
text
@d20 1
a20 1
 * $Id: hdlc.c,v 1.2 1999/02/06 03:22:36 brian Exp $
d177 1
a177 1
  mhp->next = bp;
d191 1
a191 5
  /* Tack mfcs onto the end, then set bp back to the start of the data */
  while (bp->next != NULL)
    bp = bp->next;
  bp->next = mfcs;
  bp = mhp->next;
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: hdlc.c,v 1.37 1999/01/28 01:56:32 brian Exp $
a50 1
#include "chap.h"
d56 1
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: hdlc.c,v 1.36 1998/08/07 18:42:48 brian Exp $
d24 1
a24 1
#include <sys/types.h>
d64 3
d396 1
a396 1
      pap_Input(bundle, bp, p);
d421 1
a421 1
      chap_Input(bundle, bp, p);
@

