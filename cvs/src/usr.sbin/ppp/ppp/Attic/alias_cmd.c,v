head	1.13;
access;
symbols
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2000.01.07.03.26.52;	author brian;	state dead;
branches;
next	1.12;

1.12
date	99.07.28.19.39.17;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.07.24.03.20.00;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.06.10.00.17.26;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.06.02.15.58.39;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.05.12.10.03.48;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.05.08.11.06.33;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.04.26.08.55.00;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.03.25.23.36.52;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.03.08.01.40.22;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.22.30;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.08.31.08.16.27;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.15;	author brian;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@/*-
 * The code in this file was written by Eivind Eklund <perhaps@@yes.no>,
 * who places it in the public domain without restriction.
 *
 *	$Id: alias_cmd.c,v 1.12 1999/07/28 19:39:17 brian Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <sys/un.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>

#ifdef __FreeBSD__
#include <alias.h>
#else
#include "alias.h"
#endif
#include "layer.h"
#include "proto.h"
#include "defs.h"
#include "command.h"
#include "log.h"
#include "alias_cmd.h"
#include "descriptor.h"
#include "prompt.h"
#include "timer.h"
#include "fsm.h"
#include "slcompress.h"
#include "throughput.h"
#include "iplist.h"
#include "mbuf.h"
#include "lqr.h"
#include "hdlc.h"
#include "ipcp.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "mp.h"
#include "filter.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "bundle.h"


static int StrToAddr(const char *, struct in_addr *);
static int StrToPortRange(const char *, u_short *, u_short *, const char *);
static int StrToAddrAndPort(const char *, struct in_addr *, u_short *,
                            u_short *, const char *);

static void
lowhigh(u_short *a, u_short *b)
{
  if (a > b) {
    u_short c;

    c = *b;
    *b = *a;
    *a = c;
  }
}

int
alias_RedirectPort(struct cmdargs const *arg)
{
  if (!arg->bundle->AliasEnabled) {
    prompt_Printf(arg->prompt, "Alias not enabled\n");
    return 1;
  } else if (arg->argc == arg->argn + 3 || arg->argc == arg->argn + 4) {
    char proto_constant;
    const char *proto;
    struct in_addr localaddr;
    u_short hlocalport, llocalport;
    struct in_addr aliasaddr;
    u_short haliasport, laliasport;
    struct in_addr remoteaddr;
    u_short hremoteport, lremoteport;
    struct alias_link *link;
    int error;

    proto = arg->argv[arg->argn];
    if (strcmp(proto, "tcp") == 0) {
      proto_constant = IPPROTO_TCP;
    } else if (strcmp(proto, "udp") == 0) {
      proto_constant = IPPROTO_UDP;
    } else {
      prompt_Printf(arg->prompt, "port redirect: protocol must be"
                    " tcp or udp\n");
      return -1;
    }

    error = StrToAddrAndPort(arg->argv[arg->argn+1], &localaddr, &llocalport,
                             &hlocalport, proto);
    if (error) {
      prompt_Printf(arg->prompt, "alias port: error reading localaddr:port\n");
      return -1;
    }

    error = StrToPortRange(arg->argv[arg->argn+2], &laliasport, &haliasport,
                           proto);
    if (error) {
      prompt_Printf(arg->prompt, "alias port: error reading alias port\n");
      return -1;
    }
    aliasaddr.s_addr = INADDR_ANY;

    if (arg->argc == arg->argn + 4) {
      error = StrToAddrAndPort(arg->argv[arg->argn+3], &remoteaddr,
                               &lremoteport, &hremoteport, proto);
      if (error) {
        prompt_Printf(arg->prompt, "alias port: error reading "
                      "remoteaddr:port\n");
        return -1;
      }
    } else {
      remoteaddr.s_addr = INADDR_ANY;
      lremoteport = hremoteport = 0;
    }

    lowhigh(&llocalport, &hlocalport);
    lowhigh(&laliasport, &haliasport);
    lowhigh(&lremoteport, &hremoteport);

    if (haliasport - laliasport != hlocalport - llocalport) {
      prompt_Printf(arg->prompt, "alias port: local & alias port ranges "
                    "are not equal\n");
      return -1;
    }

    if (hremoteport && hremoteport - lremoteport != hlocalport - llocalport) {
      prompt_Printf(arg->prompt, "alias port: local & remote port ranges "
                    "are not equal\n");
      return -1;
    }

    while (laliasport <= haliasport) {
      link = PacketAliasRedirectPort(localaddr, htons(llocalport),
				     remoteaddr, htons(lremoteport),
                                     aliasaddr, htons(laliasport),
				     proto_constant);

      if (link == NULL) {
        prompt_Printf(arg->prompt, "alias port: %d: error %d\n", laliasport,
                      error);
        return 1;
      }
      llocalport++;
      laliasport++;
      if (hremoteport)
        lremoteport++;
    }

    return 0;
  }

  return -1;
}


int
alias_RedirectAddr(struct cmdargs const *arg)
{
  if (!arg->bundle->AliasEnabled) {
    prompt_Printf(arg->prompt, "alias not enabled\n");
    return 1;
  } else if (arg->argc == arg->argn+2) {
    int error;
    struct in_addr localaddr, aliasaddr;
    struct alias_link *link;

    error = StrToAddr(arg->argv[arg->argn], &localaddr);
    if (error) {
      prompt_Printf(arg->prompt, "address redirect: invalid local address\n");
      return 1;
    }
    error = StrToAddr(arg->argv[arg->argn+1], &aliasaddr);
    if (error) {
      prompt_Printf(arg->prompt, "address redirect: invalid alias address\n");
      prompt_Printf(arg->prompt, "Usage: alias %s %s\n", arg->cmd->name,
                    arg->cmd->syntax);
      return 1;
    }
    link = PacketAliasRedirectAddr(localaddr, aliasaddr);
    if (link == NULL) {
      prompt_Printf(arg->prompt, "address redirect: packet aliasing"
                    " engine error\n");
      prompt_Printf(arg->prompt, "Usage: alias %s %s\n", arg->cmd->name,
                    arg->cmd->syntax);
    }
  } else
    return -1;

  return 0;
}


static int
StrToAddr(const char *str, struct in_addr *addr)
{
  struct hostent *hp;

  if (inet_aton(str, addr))
    return 0;

  hp = gethostbyname(str);
  if (!hp) {
    log_Printf(LogWARN, "StrToAddr: Unknown host %s.\n", str);
    return -1;
  }
  *addr = *((struct in_addr *) hp->h_addr);
  return 0;
}


static int
StrToPort(const char *str, u_short *port, const char *proto)
{
  struct servent *sp;
  char *end;

  *port = strtol(str, &end, 10);
  if (*end != '\0') {
    sp = getservbyname(str, proto);
    if (sp == NULL) {
      log_Printf(LogWARN, "StrToAddr: Unknown port or service %s/%s.\n",
	        str, proto);
      return -1;
    }
    *port = ntohs(sp->s_port);
  }

  return 0;
}

static int
StrToPortRange(const char *str, u_short *low, u_short *high, const char *proto)
{
  char *minus;
  int res;

  minus = strchr(str, '-');
  if (minus)
    *minus = '\0';		/* Cheat the const-ness ! */

  res = StrToPort(str, low, proto);

  if (minus)
    *minus = '-';		/* Cheat the const-ness ! */

  if (res == 0) {
    if (minus)
      res = StrToPort(minus + 1, high, proto);
    else
      *high = *low;
  }

  return res;
}

static int
StrToAddrAndPort(const char *str, struct in_addr *addr, u_short *low,
                 u_short *high, const char *proto)
{
  char *colon;
  int res;

  colon = strchr(str, ':');
  if (!colon) {
    log_Printf(LogWARN, "StrToAddrAndPort: %s is missing port number.\n", str);
    return -1;
  }

  *colon = '\0';		/* Cheat the const-ness ! */
  res = StrToAddr(str, addr);
  *colon = ':';			/* Cheat the const-ness ! */
  if (res != 0)
    return -1;

  return StrToPortRange(colon + 1, low, high, proto);
}

int
alias_ProxyRule(struct cmdargs const *arg)
{
  char cmd[LINE_LEN];
  int f, pos;
  size_t len;

  if (arg->argn >= arg->argc)
    return -1;

  for (f = arg->argn, pos = 0; f < arg->argc; f++) {
    len = strlen(arg->argv[f]);
    if (sizeof cmd - pos < len + (f ? 1 : 0))
      break;
    if (f)
      cmd[pos++] = ' ';
    strcpy(cmd + pos, arg->argv[f]);
    pos += len;
  }

  return PacketAliasProxyRule(cmd);
}

int
alias_Pptp(struct cmdargs const *arg)
{
  struct in_addr addr;

  if (arg->argc == arg->argn) {
    addr.s_addr = INADDR_NONE;
    PacketAliasPptp(addr);
    return 0;
  }

  if (arg->argc != arg->argn + 1)
    return -1;

  addr = GetIpAddr(arg->argv[arg->argn]);
  if (addr.s_addr == INADDR_NONE) {
    log_Printf(LogWARN, "%s: invalid address\n", arg->argv[arg->argn]);
    return 1;
  }

  PacketAliasPptp(addr);
  return 0;
}

static struct mbuf *
alias_PadMbuf(struct mbuf *bp, int type)
{
  struct mbuf **last;
  int len;

  mbuf_SetType(bp, type);
  for (last = &bp, len = 0; *last != NULL; last = &(*last)->next)
    len += (*last)->cnt;

  len = MAX_MRU - len;
  *last = mbuf_Alloc(len, type);

  return bp;
}

static struct mbuf *
alias_LayerPush(struct bundle *bundle, struct link *l, struct mbuf *bp,
                int pri, u_short *proto)
{
  if (!bundle->AliasEnabled || *proto != PROTO_IP)
    return bp;

  log_Printf(LogDEBUG, "alias_LayerPush: PROTO_IP -> PROTO_IP\n");
  bp = mbuf_Contiguous(alias_PadMbuf(bp, MB_ALIASOUT));
  PacketAliasOut(MBUF_CTOP(bp), bp->cnt);
  bp->cnt = ntohs(((struct ip *)MBUF_CTOP(bp))->ip_len);

  return bp;
}

static struct mbuf *
alias_LayerPull(struct bundle *bundle, struct link *l, struct mbuf *bp,
                u_short *proto)
{
  struct ip *pip, *piip;
  int ret, len;
  struct mbuf **last;
  char *fptr;

  if (!bundle->AliasEnabled || *proto != PROTO_IP)
    return bp;

  log_Printf(LogDEBUG, "alias_LayerPull: PROTO_IP -> PROTO_IP\n");
  bp = mbuf_Contiguous(alias_PadMbuf(bp, MB_ALIASIN));
  pip = (struct ip *)MBUF_CTOP(bp);
  piip = (struct ip *)((char *)pip + (pip->ip_hl << 2));

  if (pip->ip_p == IPPROTO_IGMP ||
      (pip->ip_p == IPPROTO_IPIP && IN_CLASSD(ntohl(piip->ip_dst.s_addr))))
    return bp;

  ret = PacketAliasIn(MBUF_CTOP(bp), bp->cnt);

  bp->cnt = ntohs(pip->ip_len);
  if (bp->cnt > MAX_MRU) {
    log_Printf(LogWARN, "alias_LayerPull: Problem with IP header length\n");
    mbuf_Free(bp);
    return NULL;
  }

  switch (ret) {
    case PKT_ALIAS_OK:
      break;

    case PKT_ALIAS_UNRESOLVED_FRAGMENT:
      /* Save the data for later */
      fptr = malloc(bp->cnt);
      bp = mbuf_Read(bp, fptr, bp->cnt);
      PacketAliasSaveFragment(fptr);
      break;

    case PKT_ALIAS_FOUND_HEADER_FRAGMENT:
      /* Fetch all the saved fragments and chain them on the end of `bp' */
      last = &bp->pnext;
      while ((fptr = PacketAliasGetFragment(MBUF_CTOP(bp))) != NULL) {
	PacketAliasFragmentIn(MBUF_CTOP(bp), fptr);
        len = ntohs(((struct ip *)fptr)->ip_len);
        *last = mbuf_Alloc(len, MB_ALIASIN);
        memcpy(MBUF_CTOP(*last), fptr, len);
        free(fptr);
        last = &(*last)->pnext;
      }
      break;

    default:
      mbuf_Free(bp);
      bp = NULL;
      break;
  }

  return bp;
}

struct layer aliaslayer =
  { LAYER_ALIAS, "alias", alias_LayerPush, alias_LayerPull };
@


1.12
log
@Don't return a garbage mbuf pointer after storing it
as an unresolved fragment.
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.11 1999/07/24 03:20:00 brian Exp $
@


1.11
log
@When we fetch previously retrieved IP fragments from the alias
tables, copy them correctly back into our mbuf rather than giving
a bzero'd count to memcpy() and ending up with a 0 byte fragment.

The old code resulted in a 0 byte write to the tun device which
tickled a bug that resulted in a panic :-(
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.10 1999/06/10 00:17:26 brian Exp $
d406 1
a406 1
      mbuf_Read(bp, fptr, bp->cnt);
@


1.10
log
@Allow a remote IP and port range specification in the
``alias port'' command.
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.9 1999/06/02 15:58:39 brian Exp $
d374 1
a374 1
  int ret;
d415 3
a417 2
        *last = mbuf_Alloc(ntohs(((struct ip *)fptr)->ip_len), MB_ALIASIN);
        memcpy(MBUF_CTOP(*last), fptr, (*last)->cnt);
@


1.9
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.8 1999/05/12 10:03:48 brian Exp $
d60 11
d78 1
a78 1
  } else if (arg->argc == arg->argn + 3) {
d81 7
a87 5
    u_short hlocalport;
    u_short llocalport;
    u_short haliasport;
    u_short laliasport;
    u_short port;
a88 3
    struct in_addr local_addr;
    struct in_addr null_addr;
    struct alias_link *link;
d101 1
a101 1
    error = StrToAddrAndPort(arg->argv[arg->argn+1], &local_addr, &llocalport,
d107 1
d114 1
a114 1
    null_addr.s_addr = INADDR_ANY;
d116 11
a126 4
    if (llocalport > hlocalport) {
      port = llocalport;
      llocalport = hlocalport;
      hlocalport = port;
d129 8
a136 4
    if (laliasport > haliasport) {
      port = laliasport;
      laliasport = haliasport;
      haliasport = port;
d139 3
a141 2
    if (haliasport - laliasport != hlocalport - llocalport) {
      prompt_Printf(arg->prompt, "alias port: Port ranges must be equal\n");
d145 4
a148 4
    for (port = laliasport; port <= haliasport; port++) {
      link = PacketAliasRedirectPort(local_addr,
                                     htons(llocalport + (port - laliasport)),
				     null_addr, 0, null_addr, htons(port),
d152 2
a153 1
        prompt_Printf(arg->prompt, "alias port: %d: error %d\n", port, error);
d156 4
a160 2
  } else
    return -1;
d162 4
a165 1
  return 0;
d177 1
a177 2
    struct in_addr local_addr;
    struct in_addr alias_addr;
d180 1
a180 1
    error = StrToAddr(arg->argv[arg->argn], &local_addr);
d185 1
a185 1
    error = StrToAddr(arg->argv[arg->argn+1], &alias_addr);
d192 1
a192 1
    link = PacketAliasRedirectAddr(local_addr, alias_addr);
@


1.8
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.7 1999/05/08 11:06:33 brian Exp $
d316 1
d334 1
a334 1
  bp = mbuf_Contiguous(alias_PadMbuf(bp, MB_IPQ));
d354 1
a354 1
  bp = mbuf_Contiguous(alias_PadMbuf(bp, MB_IPIN));
d387 1
a387 1
        *last = mbuf_Alloc(ntohs(((struct ip *)fptr)->ip_len), MB_IPIN);
@


1.7
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.6 1999/04/26 08:55:00 brian Exp $
d331 2
a332 1
  
d352 1
@


1.6
log
@Add support for NetBSD
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.5 1999/03/25 23:36:52 brian Exp $
d27 2
d309 93
@


1.5
log
@Allow port ranges in ``alias port''.
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.4 1999/03/08 01:40:22 brian Exp $
d22 3
a24 1
#ifdef __OpenBSD__
a25 2
#else
#include <alias.h>
@


1.4
log
@Add proxying & transparent proxying support (``alias proxy'').
Add PPTP packet aliasing (GRE fixed address) support (``alias pptp'').
Add a 0 to the front of the mode to signify octal.
Thanks to: Charles Mott <cmott@@srv.net> & Dru Nelson <dnelson@@redwoodsoft.com>
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.3 1999/02/06 03:22:30 brian Exp $
d54 3
a56 2
static int StrToPort(const char *, u_short *, const char *);
static int StrToAddrAndPort(const char *, struct in_addr *, u_short *, const char *);
d65 1
a65 1
  } else if (arg->argc == arg->argn+3) {
d68 5
a72 2
    u_short local_port;
    u_short alias_port;
d86 1
a86 3
      prompt_Printf(arg->prompt, "Usage: alias %s %s\n", arg->cmd->name,
		    arg->cmd->syntax);
      return 1;
d89 2
a90 2
    error = StrToAddrAndPort(arg->argv[arg->argn+1], &local_addr, &local_port,
                             proto);
d92 2
a93 5
      prompt_Printf(arg->prompt, "port redirect: error reading"
                    " local addr:port\n");
      prompt_Printf(arg->prompt, "Usage: alias %s %s\n", arg->cmd->name,
                    arg->cmd->syntax);
      return 1;
d95 2
a96 1
    error = StrToPort(arg->argv[arg->argn+2], &alias_port, proto);
d98 2
a99 4
      prompt_Printf(arg->prompt, "port redirect: error reading alias port\n");
      prompt_Printf(arg->prompt, "Usage: alias %s %s\n", arg->cmd->name,
                    arg->cmd->syntax);
      return 1;
d103 28
a130 8
    link = PacketAliasRedirectPort(local_addr, local_port,
				   null_addr, 0,
				   null_addr, alias_port,
				   proto_constant);

    if (link == NULL)
      prompt_Printf(arg->prompt, "port redirect: error returned by packed"
	      " aliasing engine (code=%d)\n", error);
a196 1
  int iport;
d200 9
a208 4
  iport = strtol(str, &end, 10);
  if (end != str) {
    *port = htons(iport);
    return 0;
d210 1
a210 7
  sp = getservbyname(str, proto);
  if (!sp) {
    log_Printf(LogWARN, "StrToAddr: Unknown port or service %s/%s.\n",
	      str, proto);
    return -1;
  }
  *port = sp->s_port;
d214 24
d240 2
a241 1
StrToAddrAndPort(const char *str, struct in_addr *addr, u_short *port, const char *proto)
d258 1
a258 1
  return StrToPort(colon+1, port, proto);
@


1.3
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.19 1999/01/28 01:56:30 brian Exp $
d218 47
@


1.2
log
@Move libalias sources into the ppp directory.
Suggested (many times) by: Theo
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.1 1998/08/31 00:22:15 brian Exp $
d8 1
a8 1
#include <sys/types.h>
d47 3
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d5 1
a5 1
 *	$Id: alias_cmd.c,v 1.17 1998/08/26 17:39:36 brian Exp $
a16 1
#include <alias.h>
d22 5
@

