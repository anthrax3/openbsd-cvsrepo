head	1.20;
access;
symbols
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.26
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.24
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.22
	OPENBSD_5_0:1.18.0.20
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.18
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.16
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.12
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.14
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2013.03.11.17.40.11;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.09.25.05.59.28;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.04.20.25.06;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.16.14.13.06;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.16.13.20.23;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.13.23.56.18;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.29.01.34.38;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.26.01.41.04;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.02.00.54.35;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.27.01.38.28;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.27.00.21.09;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.03.08.22.35.37;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.07.11.55.27;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.47;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.27;	author brian;	state Exp;
branches;
next	;


desc
@@


1.20
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1997 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: server.c,v 1.19 2013/03/11 17:40:11 deraadt Exp $
 */

#include <sys/param.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/un.h>

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <termios.h>
#include <unistd.h>

#include "log.h"
#include "descriptor.h"
#include "server.h"
#include "prompt.h"
#include "ncpaddr.h"
#include "probe.h"

static int
server_UpdateSet(struct fdescriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
{
  struct server *s = descriptor2server(d);
  struct prompt *p;
  int sets;

  sets = 0;
  if (r && s->fd >= 0) {
    if (*n < s->fd + 1)
      *n = s->fd + 1;
    FD_SET(s->fd, r);
    log_Printf(LogTIMER, "server: fdset(r) %d\n", s->fd);
    sets++;
  }

  for (p = log_PromptList(); p; p = p->next)
    sets += descriptor_UpdateSet(&p->desc, r, w, e, n);

  return sets;
}

static int
server_IsSet(struct fdescriptor *d, const fd_set *fdset)
{
  struct server *s = descriptor2server(d);
  struct prompt *p;

  if (s->fd >= 0 && FD_ISSET(s->fd, fdset))
    return 1;

  for (p = log_PromptList(); p; p = p->next)
    if (descriptor_IsSet(&p->desc, fdset))
      return 1;

  return 0;
}

static void
server_Read(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  struct server *s = descriptor2server(d);
  struct sockaddr_storage ss;
  struct sockaddr *sa = (struct sockaddr *)&ss;
  struct sockaddr_in *sin = (struct sockaddr_in *)&ss;
#ifndef NOINET6
  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&ss;
#endif
  int ssize = sizeof ss, wfd;
  struct prompt *p;
  struct ncpaddr addr;

  if (s->fd >= 0 && FD_ISSET(s->fd, fdset)) {
    wfd = accept(s->fd, sa, &ssize);
    if (wfd < 0) {
      if (errno != EINTR && errno != EWOULDBLOCK &&
        errno != ECONNABORTED)
         log_Printf(LogERROR, "server_Read: accept(): %s\n", strerror(errno));
    } else if (sa->sa_len == 0) {
      close(wfd);
      wfd = -1;
    }
  } else
    wfd = -1;

  if (wfd >= 0)
    switch (sa->sa_family) {
      case AF_LOCAL:
        log_Printf(LogPHASE, "Connected to local client.\n");
        break;

      case AF_INET:
        ncpaddr_setsa(&addr, sa);
        if (ntohs(sin->sin_port) < 1024) {
          log_Printf(LogALERT, "Rejected client connection from %s:%u"
                    "(invalid port number) !\n",
                    ncpaddr_ntoa(&addr), ntohs(sin->sin_port));
          close(wfd);
          wfd = -1;
          break;
        }
        log_Printf(LogPHASE, "Connected to client from %s:%u\n",
                  ncpaddr_ntoa(&addr), ntohs(sin->sin_port));
        break;

#ifndef NOINET6
      case AF_INET6:
        ncpaddr_setsa(&addr, sa);
        if (ntohs(sin6->sin6_port) < 1024) {
          log_Printf(LogALERT, "Rejected client connection from %s:%u"
                    "(invalid port number) !\n",
                    ncpaddr_ntoa(&addr), ntohs(sin6->sin6_port));
          close(wfd);
          wfd = -1;
          break;
        }
        log_Printf(LogPHASE, "Connected to client from %s:%u\n",
                  ncpaddr_ntoa(&addr), ntohs(sin6->sin6_port));
        break;
#endif

      default:
        write(wfd, "Unrecognised access !\n", 22);
        close(wfd);
        wfd = -1;
        break;
    }

  if (wfd >= 0) {
    if ((p = prompt_Create(s, bundle, wfd)) == NULL) {
      write(wfd, "Connection refused.\n", 20);
      close(wfd);
    } else {
      switch (sa->sa_family) {
        case AF_LOCAL:
          p->src.type = "local";
          strncpy(p->src.from, s->cfg.sockname, sizeof p->src.from - 1);
          p->src.from[sizeof p->src.from - 1] = '\0';
          break;
        case AF_INET:
          p->src.type = "ip";
          snprintf(p->src.from, sizeof p->src.from, "%s:%u",
                   ncpaddr_ntoa(&addr), ntohs(sin->sin_port));
          break;
#ifndef NOINET6
        case AF_INET6:
          p->src.type = "ip6";
          snprintf(p->src.from, sizeof p->src.from, "%s:%u",
                   ncpaddr_ntoa(&addr), ntohs(sin6->sin6_port));
          break;
#endif
      }
      prompt_TtyCommandMode(p);
      prompt_Required(p);
    }
  }

  log_PromptListChanged = 0;
  for (p = log_PromptList(); p; p = p->next)
    if (descriptor_IsSet(&p->desc, fdset)) {
      descriptor_Read(&p->desc, bundle, fdset);
      if (log_PromptListChanged)
        break;
    }
}

static int
server_Write(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  /* We never want to write here ! */
  log_Printf(LogALERT, "server_Write: Internal error: Bad call !\n");
  return 0;
}

struct server server = {
  {
    SERVER_DESCRIPTOR,
    server_UpdateSet,
    server_IsSet,
    server_Read,
    server_Write
  },
  -1
};

enum server_stat
server_Reopen(struct bundle *bundle)
{
  char name[sizeof server.cfg.sockname];
  struct stat st;
  u_short port;
  mode_t mask;
  enum server_stat ret;

  if (server.cfg.sockname[0] != '\0') {
    strlcpy(name, server.cfg.sockname, sizeof name);
    mask = server.cfg.mask;
    server_Close(bundle);
    if (server.cfg.sockname[0] != '\0' && stat(server.cfg.sockname, &st) == 0)
      if (!S_ISSOCK(st.st_mode) || unlink(server.cfg.sockname) != 0)
        return SERVER_FAILED;
    ret = server_LocalOpen(bundle, name, mask);
  } else if (server.cfg.port != 0) {
    port = server.cfg.port;
    server_Close(bundle);
    ret = server_TcpOpen(bundle, port);
  } else
    ret = SERVER_UNSET;

  return ret;
}

enum server_stat
server_LocalOpen(struct bundle *bundle, const char *name, mode_t mask)
{
  struct sockaddr_un ifsun;
  mode_t oldmask;
  int s;

  oldmask = (mode_t)-1;		/* Silence compiler */

  if (server.cfg.sockname && !strcmp(server.cfg.sockname, name))
    server_Close(bundle);

  memset(&ifsun, '\0', sizeof ifsun);
  ifsun.sun_len = strlen(name);
  if (ifsun.sun_len > sizeof ifsun.sun_path - 1) {
    log_Printf(LogERROR, "Local: %s: Path too long\n", name);
    return SERVER_INVALID;
  }
  ifsun.sun_family = AF_LOCAL;
  strlcpy(ifsun.sun_path, name, sizeof ifsun.sun_path);

  s = socket(PF_LOCAL, SOCK_STREAM, 0);
  if (s < 0) {
    log_Printf(LogERROR, "Local: socket: %s\n", strerror(errno));
    goto failed;
  }
  setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &s, sizeof s);
  if (mask != (mode_t)-1)
    oldmask = umask(mask);
  if (bind(s, (struct sockaddr *)&ifsun, sizeof ifsun) < 0) {
    if (mask != (mode_t)-1)
      umask(oldmask);
    log_Printf(LogWARN, "Local: bind: %s\n", strerror(errno));
    close(s);
    goto failed;
  }
  if (mask != (mode_t)-1)
    umask(oldmask);
  if (listen(s, 5) != 0) {
    log_Printf(LogERROR, "Local: Unable to listen to socket -"
               " BUNDLE overload?\n");
    close(s);
    unlink(name);
    goto failed;
  }
  server_Close(bundle);
  server.fd = s;
  server.cfg.port = 0;
  strncpy(server.cfg.sockname, ifsun.sun_path, sizeof server.cfg.sockname - 1);
  server.cfg.sockname[sizeof server.cfg.sockname - 1] = '\0';
  server.cfg.mask = mask;
  log_Printf(LogPHASE, "Listening at local socket %s.\n", name);

  return SERVER_OK;

failed:
  if (server.fd == -1) {
    server.fd = -1;
    server.cfg.port = 0;
    strncpy(server.cfg.sockname, ifsun.sun_path,
            sizeof server.cfg.sockname - 1);
    server.cfg.sockname[sizeof server.cfg.sockname - 1] = '\0';
    server.cfg.mask = mask;
  }
  return SERVER_FAILED;
}

enum server_stat
server_TcpOpen(struct bundle *bundle, u_short port)
{
  struct sockaddr_storage ss;
  struct sockaddr_in *sin = (struct sockaddr_in *)&ss;
#ifndef NOINET6
  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&ss;
#endif
  int s, sz;

  if (server.cfg.port == port)
    server_Close(bundle);

  if (port == 0)
    return SERVER_INVALID;

  memset(&ss, '\0', sizeof ss);
#ifndef NOINET6
  if (probe.ipv6_available) {
    sin6->sin6_family = AF_INET6;
    sin6->sin6_port = htons(port);
    sin6->sin6_len = (u_int8_t)sizeof ss;
    sz = sizeof *sin6;
    s = socket(PF_INET6, SOCK_STREAM, 0);
  } else
#endif
  {
    sin->sin_family = AF_INET;
    sin->sin_port = htons(port);
    sin->sin_len = (u_int8_t)sizeof ss;
    sin->sin_addr.s_addr = INADDR_ANY;
    sz = sizeof *sin;
    s = socket(PF_INET, SOCK_STREAM, 0);
  }

  if (s < 0) {
    log_Printf(LogERROR, "Tcp: socket: %s\n", strerror(errno));
    goto failed;
  }

  setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &s, sizeof s);
  if (bind(s, (struct sockaddr *)&ss, sz) < 0) {
    log_Printf(LogWARN, "Tcp: bind: %s\n", strerror(errno));
    close(s);
    goto failed;
  }
  if (listen(s, 5) != 0) {
    log_Printf(LogERROR, "Tcp: Unable to listen to socket: %s\n",
               strerror(errno));
    close(s);
    goto failed;
  }
  server_Close(bundle);
  server.fd = s;
  server.cfg.port = port;
  *server.cfg.sockname = '\0';
  server.cfg.mask = 0;
  log_Printf(LogPHASE, "Listening at port %d.\n", port);
  return SERVER_OK;

failed:
  if (server.fd == -1) {
    server.fd = -1;
    server.cfg.port = port;
    *server.cfg.sockname = '\0';
    server.cfg.mask = 0;
  }
  return SERVER_FAILED;
}

int
server_Close(struct bundle *bundle)
{
  if (server.fd >= 0) {
    if (*server.cfg.sockname != '\0') {
      struct sockaddr_un un;
      int sz = sizeof un;

      if (getsockname(server.fd, (struct sockaddr *)&un, &sz) == 0 &&
          un.sun_family == AF_LOCAL && sz == sizeof un)
        unlink(un.sun_path);
    }
    close(server.fd);
    server.fd = -1;
    /* Drop associated prompts */
    log_DestroyPrompts(&server);

    return 1;
  }

  return 0;
}

int
server_Clear(struct bundle *bundle)
{
  int ret;

  ret = server_Close(bundle);

  server.fd = -1;
  server.cfg.port = 0;
  *server.cfg.sockname = '\0';
  server.cfg.mask = 0;

  return ret;
}
@


1.19
log
@handle ECONNABORTED errors from accept().  In many code blocks they can be
ignored silently and without aborting, much like EINTR and EWOULDBLOCK are.
ok's from various maintainers of these directories...
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.18 2006/09/25 05:59:28 otto Exp $
@


1.18
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by
from Paul Stoeber, more to come. ok jaredy@@
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.17 2005/07/17 19:13:25 brad Exp $
d104 5
a108 3
    if (wfd < 0)
      log_Printf(LogERROR, "server_Read: accept(): %s\n", strerror(errno));
    else if (sa->sa_len == 0) {
@


1.17
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.16 2003/04/04 20:25:06 deraadt Exp $
d227 1
a227 1
      if (!(st.st_mode & S_IFSOCK) || unlink(server.cfg.sockname) != 0)
@


1.16
log
@strlcpy and snprintf; various people ok
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.15 2002/05/16 01:13:39 brian Exp $
d36 1
@


1.15
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.14 2002/01/16 14:13:06 brian Exp $
d222 1
a222 1
    strcpy(name, server.cfg.sockname);
d258 1
a258 1
  strcpy(ifsun.sun_path, name);
@


1.14
log
@socket()s first argument should be a protocol family rather than an
address family.
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.13 2002/01/16 13:20:23 brian Exp $
a32 1
#include <arpa/inet.h>
a44 1
#include "id.h"
@


1.13
log
@socket's first argument is an address family, not a protocol family.
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.12 2001/08/19 23:22:18 brian Exp $
d262 1
a262 1
  s = socket(AF_LOCAL, SOCK_STREAM, 0);
d331 1
a331 1
    s = socket(AF_INET6, SOCK_STREAM, 0);
d340 1
a340 1
    s = socket(AF_INET, SOCK_STREAM, 0);
@


1.12
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.11 2001/02/13 23:56:18 brian Exp $
d262 1
a262 1
  s = socket(PF_LOCAL, SOCK_STREAM, 0);
d331 1
a331 1
    s = socket(PF_INET6, SOCK_STREAM, 0);
d340 1
a340 1
    s = socket(PF_INET, SOCK_STREAM, 0);
@


1.11
log
@Don't even look at af_family if accept() returns sa->sa_len == 0
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.10 2001/01/29 01:34:38 brian Exp $
d48 2
a88 4
#define IN_SIZE sizeof(struct sockaddr_in)
#define UN_SIZE sizeof(struct sockaddr_un)
#define ADDRSZ (IN_SIZE > UN_SIZE ? IN_SIZE : UN_SIZE)

d93 7
a99 4
  char hisaddr[ADDRSZ];
  struct sockaddr *sa = (struct sockaddr *)hisaddr;
  struct sockaddr_in *in = (struct sockaddr_in *)hisaddr;
  int ssize = ADDRSZ, wfd;
d101 1
d121 17
a137 1
        if (ntohs(in->sin_port) < 1024) {
d140 1
a140 1
                    inet_ntoa(in->sin_addr), ntohs(in->sin_port));
d146 1
a146 1
                  inet_ntoa(in->sin_addr), in->sin_port);
d148 1
d169 7
a175 1
          p->src.type = "tcp";
d177 1
a177 1
                   inet_ntoa(in->sin_addr), in->sin_port);
d179 1
d311 6
a316 2
  struct sockaddr_in ifsin;
  int s;
d324 19
a342 1
  s = socket(PF_INET, SOCK_STREAM, 0);
d347 1
a347 4
  memset(&ifsin, '\0', sizeof ifsin);
  ifsin.sin_family = AF_INET;
  ifsin.sin_addr.s_addr = INADDR_ANY;
  ifsin.sin_port = htons(port);
d349 1
a349 1
  if (bind(s, (struct sockaddr *)&ifsin, sizeof ifsin) < 0) {
@


1.10
log
@Only remove socket files with ``set server open''.
Only show the mask in ``show bundle'' when it's been specified.
Complain about unexpected arguments after ``set server {none,open,closed}''
Log re-open failures as warnings rather than phase messages.
Fix some markup for the ``set server'' man page description.
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.9 2001/01/26 01:41:04 brian Exp $
d105 4
@


1.9
log
@Allow ``set server closed'' to close the diagnostic socket.
Allow ``set server open'' to re-open the diagnostic socket.
Handle SIGUSR1 by re-opening the diagnostic socket
When receiving SIGUSR2 (and in ``set server none''), don't forget the
socket details so that ``set server open'' and SIGUSR1 open it again.

Don't create the diagnostic socket as uid 0 !  It's far to dangerous.
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.8 2000/11/02 00:54:35 brian Exp $
d188 1
d197 3
a199 3
    if (server.cfg.sockname[0] != '\0')
      /* blow it away - and hope nobody else is using it */
      unlink(server.cfg.sockname);
@


1.8
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.7 2000/06/13 09:57:51 brian Exp $
d29 2
a30 1
#include <sys/types.h>
d142 1
a142 1
          strncpy(p->src.from, s->rm, sizeof p->src.from - 1);
d184 27
a210 1
int
d213 2
d217 4
a220 5
  if (server.rm && !strcmp(server.rm, name)) {
    if (chmod(server.rm, 0777 & ~mask))
      log_Printf(LogERROR, "Local: chmod: %s\n", strerror(errno));
    return 0;
  }
d222 3
a224 3
  memset(&server.ifsun, '\0', sizeof server.ifsun);
  server.ifsun.sun_len = strlen(name);
  if (server.ifsun.sun_len > sizeof server.ifsun.sun_path - 1) {
d226 1
a226 1
    return 2;
d228 2
a229 2
  server.ifsun.sun_family = AF_LOCAL;
  strcpy(server.ifsun.sun_path, name);
d231 1
a231 1
  s = ID0socket(PF_LOCAL, SOCK_STREAM, 0);
d234 1
a234 1
    return 3;
d238 2
a239 2
    mask = umask(mask);
  if (bind(s, (struct sockaddr *)&server.ifsun, sizeof server.ifsun) < 0) {
d241 1
a241 1
      umask(mask);
d244 1
a244 1
    return 4;
d247 1
a247 1
    umask(mask);
d252 2
a253 2
    ID0unlink(name);
    return 5;
d257 4
a260 1
  server.rm = server.ifsun.sun_path;
d262 13
a274 1
  return 0;
d277 2
a278 2
int
server_TcpOpen(struct bundle *bundle, int port)
d283 2
a284 2
  if (server.port == port)
    return 0;
d286 4
a289 1
  s = ID0socket(PF_INET, SOCK_STREAM, 0);
d292 1
a292 1
    return 7;
d302 1
a302 1
    return 8;
d308 1
a308 1
    return 9;
d312 3
a314 1
  server.port = port;
d316 10
a325 1
  return 0;
d332 1
a332 1
    if (server.rm) {
d338 1
a338 2
        ID0unlink(un.sun_path);
      server.rm = NULL;
a341 1
    server.port = 0;
d344 1
d347 1
d349 15
@


1.7
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.6 2000/02/27 01:38:28 brian Exp $
d221 2
a222 1
    log_Printf(LogERROR, "Local: Unable to listen to socket - BUNDLE overload?\n");
@


1.6
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: server.c,v 1.5 2000/02/27 00:21:09 brian Exp $
d189 1
a189 1
    if (chmod(server.rm, mask))
@


1.5
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: server.c,v 1.4 1999/03/08 22:35:37 brian Exp $
@


1.4
log
@Don't destroy the old server socket another ``set server''
call fails.
@
text
@d26 1
a26 1
 *	$Id: server.c,v 1.3 1999/03/07 11:55:27 brian Exp $
d49 1
a49 1
server_UpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
d71 1
a71 1
server_IsSet(struct descriptor *d, const fd_set *fdset)
d87 1
a87 1
#define UN_SIZE sizeof(struct sockaddr_in)
d91 1
a91 1
server_Read(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
d165 1
a165 1
server_Write(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
@


1.3
log
@Correctly drop existing connections when reopening the diagnostic
socket.
@
text
@d26 1
a26 1
 *	$Id: server.c,v 1.2 1999/02/06 03:22:47 brian Exp $
a193 1
  server_Close(bundle);
d226 1
d258 2
a259 1
    log_Printf(LogERROR, "Tcp: Unable to listen to socket - BUNDLE overload?\n");
a273 1
    close(server.fd);
d275 6
a280 1
      ID0unlink(server.rm);
d283 1
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: server.c,v 1.23 1998/08/02 13:01:16 brian Exp $
d194 1
a226 1
  server_Close(bundle);
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

