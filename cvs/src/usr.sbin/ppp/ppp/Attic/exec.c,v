head	1.20;
access;
symbols
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.44
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.42
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.40
	OPENBSD_5_0:1.18.0.38
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.36
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.34
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.30
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.32
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.28
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.26
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.24
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.22
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.20
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.18
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.16
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.14
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.12
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.10
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.8
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.6
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.4
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9;
locks; strict;
comment	@ * @;


1.20
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.19.10.24.52;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.18.00.02.11;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.22.20.50.44;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.02.01.36.26;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.27.01.38.25;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.07.03.26.53;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.08.17.15.00.39;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.09.08.47.23;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.05.21.35.59;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.01.19.08.52;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.05.24.16.39.19;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.12.10.03.50;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.08.11.06.35;	author brian;	state Exp;
branches;
next	;


desc
@@


1.20
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1999 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: exec.c,v 1.19 2013/04/29 00:28:23 okan Exp $
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/uio.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "defs.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "fsm.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "async.h"
#include "descriptor.h"
#include "physical.h"
#include "mp.h"
#include "chat.h"
#include "command.h"
#include "auth.h"
#include "chap.h"
#include "cbcp.h"
#include "datalink.h"
#include "id.h"
#include "exec.h"

static struct device execdevice = {
  EXEC_DEVICE,
  "exec",
  0,
  { CD_NOTREQUIRED, 0 },
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
};

struct device *
exec_iov2device(int type, struct physical *p, struct iovec *iov,
                int *niov, int maxiov, int *auxfd, int *nauxfd)
{
  if (type == EXEC_DEVICE) {
    free(iov[(*niov)++].iov_base);
    physical_SetupStack(p, execdevice.name, PHYSICAL_NOFORCE);
    return &execdevice;
  }

  return NULL;
}

struct device *
exec_Create(struct physical *p)
{
  if (p->fd < 0 && *p->name.full == '!') {
    int fids[2], type;

    p->fd--;	/* We own the device but maybe can't use it - change fd */
    type = physical_IsSync(p) ? SOCK_DGRAM : SOCK_STREAM;

    if (socketpair(AF_UNIX, type, PF_UNSPEC, fids) < 0)
      log_Printf(LogPHASE, "Unable to create pipe for line exec: %s\n",
                 strerror(errno));
    else {
      static int child_status;		/* This variable is abused ! */
      int stat, argc, i, ret, wret, pidpipe[2];
      pid_t pid, realpid;
      char *argv[MAXARGS];

      stat = fcntl(fids[0], F_GETFL, 0);
      if (stat > 0) {
        stat |= O_NONBLOCK;
        fcntl(fids[0], F_SETFL, stat);
      }
      realpid = getpid();
      if (pipe(pidpipe) == -1) {
        log_Printf(LogPHASE, "Unable to pipe for line exec: %s\n",
                   strerror(errno));
        close(fids[1]);
      } else switch ((pid = fork())) {
        case -1:
          log_Printf(LogPHASE, "Unable to fork for line exec: %s\n",
                     strerror(errno));
          close(pidpipe[0]);
          close(pidpipe[1]);
          close(fids[1]);
          break;

        case  0:
          close(pidpipe[0]);
          close(fids[0]);
          timer_TermService();
#ifndef NOSUID
          setuid(ID0realuid());
#endif

          child_status = 0;
          switch ((pid = vfork())) {
            case 0:
              close(pidpipe[1]);
              break;

            case -1:
              ret = errno;
              log_Printf(LogPHASE, "Unable to vfork to drop parent: %s\n",
                         strerror(errno));
              close(pidpipe[1]);
              _exit(ret);

            default:
              write(pidpipe[1], &pid, sizeof pid);
              close(pidpipe[1]);
              _exit(child_status);	/* The error from exec() ! */
          }

          log_Printf(LogDEBUG, "Exec'ing ``%s''\n", p->name.base);

          if ((argc = MakeArgs(p->name.base, argv, VECSIZE(argv),
                               PARSE_REDUCE|PARSE_NOHASH)) < 0) {
            log_Printf(LogWARN, "Syntax error in exec command\n");
            _exit(ESRCH);
          }

          command_Expand(argv, argc, (char const *const *)argv,
                         p->dl->bundle, 0, realpid);

          dup2(fids[1], STDIN_FILENO);
          dup2(fids[1], STDOUT_FILENO);
          dup2(fids[1], STDERR_FILENO);
          for (i = getdtablesize(); i > STDERR_FILENO; i--)
            fcntl(i, F_SETFD, FD_CLOEXEC);

          execvp(*argv, argv);
          child_status = errno;		/* Only works for vfork() */
          printf("execvp failed: %s: %s\r\n", *argv, strerror(child_status));
          _exit(child_status);
          break;

        default:
          close(pidpipe[1]);
          close(fids[1]);
          if (read(pidpipe[0], &p->session_owner, sizeof p->session_owner) !=
              sizeof p->session_owner)
            p->session_owner = (pid_t)-1;
          close(pidpipe[0]);
          while ((wret = waitpid(pid, &stat, 0)) == -1 && errno == EINTR)
            ;
          if (wret == -1) {
            log_Printf(LogWARN, "Waiting for child process: %s\n",
                       strerror(errno));
            close(fids[0]);
            p->session_owner = (pid_t)-1;
            break;
          } else if (WIFSIGNALED(stat)) {
            log_Printf(LogWARN, "Child process received sig %d !\n",
                       WTERMSIG(stat));
            close(fids[0]);
            p->session_owner = (pid_t)-1;
            break;
          } else if (WIFSTOPPED(stat)) {
            log_Printf(LogWARN, "Child process received stop sig %d !\n",
                       WSTOPSIG(stat));
            /* I guess that's ok.... */
          } else if ((ret = WEXITSTATUS(stat))) {
            log_Printf(LogWARN, "Cannot exec \"%s\": %s\n", p->name.base,
                       strerror(ret));
            close(fids[0]);
            p->session_owner = (pid_t)-1;
            break;
          }
          p->fd = fids[0];
          log_Printf(LogDEBUG, "Using descriptor %d for child\n", p->fd);
          physical_SetupStack(p, execdevice.name, PHYSICAL_NOFORCE);
          if (p->cfg.cd.necessity != CD_DEFAULT)
            log_Printf(LogWARN, "Carrier settings ignored\n");
          return &execdevice;
      }
      close(fids[0]);
    }
  }

  return NULL;
}
@


1.19
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d26 1
a26 1
 *	$OpenBSD: exec.c,v 1.18 2002/05/16 01:13:39 brian Exp $
@


1.18
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: exec.c,v 1.17 2002/03/31 02:38:49 brian Exp $
d181 1
a181 1
            fcntl(i, F_SETFD, 1);
@


1.17
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d26 1
a26 1
 *	$OpenBSD: exec.c,v 1.16 2001/06/19 10:24:52 brian Exp $
d73 1
@


1.16
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d26 1
a26 1
 *	$OpenBSD: exec.c,v 1.15 2000/08/18 00:02:11 brian Exp $
d73 1
@


1.15
log
@Make -DNOSUID (or -DPPP_NOSUID) possible to build ppp without SUID
capabilities.
@
text
@d26 1
a26 1
 *	$OpenBSD: exec.c,v 1.14 2000/06/22 20:50:44 brian Exp $
d71 1
@


1.14
log
@Correct PPPoE in multi-link mode; jason@@
@
text
@d26 1
a26 1
 *	$OpenBSD: exec.c,v 1.13 2000/06/13 09:57:51 brian Exp $
d140 1
d142 1
@


1.13
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d26 1
a26 1
 *	$OpenBSD: exec.c,v 1.12 2000/04/02 01:36:26 brian Exp $
d92 1
a92 1
    physical_SetupStack(p, execdevice.name, PHYSICAL_FORCE_ASYNC);
@


1.12
log
@When a link is ``!program'', realise when the process we're
exec()ing couldn't be exec'd and fail the device open rather
than thinking the open succeeded but the first read() got zero.
@
text
@d26 1
a26 1
 *	$OpenBSD: exec.c,v 1.11 2000/02/27 01:38:25 brian Exp $
d103 1
a103 1
    int fids[2];
d106 1
d108 1
a108 1
    if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, fids) < 0)
d110 1
a110 1
	         strerror(errno));
d112 2
a113 2
      static int child_status;
      int stat, argc, i, ret, wret;
d123 5
a127 1
      switch ((pid = fork())) {
d129 4
a132 2
          log_Printf(LogPHASE, "Unable to create pipe for line exec: %s\n",
	             strerror(errno));
d137 1
d143 1
a143 1
          switch (vfork()) {
d145 1
d150 3
a152 2
              log_Printf(LogPHASE, "Unable to fork to drop parent: %s\n",
	                 strerror(errno));
a153 1
              break;
d156 2
d185 1
d187 4
d197 1
d203 1
d213 1
d218 1
a218 1
          physical_SetupStack(p, execdevice.name, PHYSICAL_FORCE_ASYNC);
@


1.11
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: exec.c,v 1.10 2000/01/07 03:26:53 brian Exp $
d111 2
a112 1
      int stat, argc, i;
d126 1
d134 2
a135 1
          switch (fork()) {
d140 1
d143 3
d147 1
a147 1
              _exit(127);
d155 1
a155 1
            _exit(127);
d168 3
a170 2
          printf("execvp failed: %s: %s\r\n", *argv, strerror(errno));
          _exit(127);
d175 22
a197 1
          waitpid(pid, &stat, 0);
d204 1
@


1.10
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: exec.c,v 1.9 1999/08/17 15:00:39 brian Exp $
@


1.9
log
@Set the close-on-exec flag for all unused descriptors when
exec()ing other programs.
@
text
@d26 1
a26 1
 *	$Id: exec.c,v 1.8 1999/07/15 02:10:32 brian Exp $
a30 5
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a46 1
#include "sync.h"
a55 4
#include "slcompress.h"
#include "iplist.h"
#include "ipcp.h"
#include "filter.h"
a58 3
#ifndef NORADIUS
#include "radius.h"
#endif
a60 2
#include "bundle.h"
#include "prompt.h"
d65 1
d71 3
d88 1
a88 1
                int *niov, int maxiov)
d105 2
d130 1
a130 1
          setuid(geteuid());
d145 9
a159 3
          argc = MakeArgs(p->name.base, argv, VECSIZE(argv));
          command_Expand(argv, argc, (char const *const *)argv,
                         p->dl->bundle, 0, realpid);
d171 2
@


1.8
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d26 1
a26 1
 *	$Id: exec.c,v 1.6 1999/06/09 08:47:23 brian Exp $
d120 1
a120 1
      int stat, argc;
d152 2
a153 1
          fids[1] = fcntl(fids[1], F_DUPFD, 3);
d157 2
a159 1
          log_Printf(LogDEBUG, "Exec'ing ``%s''\n", p->name.base);
d164 1
a164 1
          fprintf(stderr, "execvp failed: %s: %s\r\n", *argv, strerror(errno));
@


1.7
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d31 5
a35 5
/* #include <netinet/in.h> (auto-remove) */
/* #include <arpa/inet.h> (auto-remove) */
/* #include <netdb.h> (auto-remove) */
/* #include <netinet/in_systm.h> (auto-remove) */
/* #include <netinet/ip.h> (auto-remove) */
d52 1
a52 1
/* #include "sync.h" (auto-remove) */
d62 4
a65 4
/* #include "slcompress.h" (auto-remove) */
/* #include "iplist.h" (auto-remove) */
/* #include "ipcp.h" (auto-remove) */
/* #include "filter.h" (auto-remove) */
d70 1
a70 1
/* #include "radius.h" (auto-remove) */
d74 2
a75 2
/* #include "bundle.h" (auto-remove) */
/* #include "prompt.h" (auto-remove) */
a84 1
  NULL,
@


1.6
log
@Use the correct pid when substituting PROCESSID.
Problem reported by: Amedeo Beck Peccoz <gea@@gressoney.it>
@
text
@d26 1
a26 1
 *	$Id: exec.c,v 1.5 1999/06/05 21:35:59 brian Exp $
d31 5
a35 5
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
d52 1
a52 1
#include "sync.h"
d62 4
a65 4
#include "slcompress.h"
#include "iplist.h"
#include "ipcp.h"
#include "filter.h"
d70 1
a70 1
#include "radius.h"
d74 2
a75 2
#include "bundle.h"
#include "prompt.h"
d85 1
@


1.5
log
@Correct the way ppp transfers links on the server side in MP
mode by padding out the ``struct device'' to the maximum
device size.
Bump the ppp version number to indicate the transfer format
change.

This should make MP over tty and udp devices functional again.
@
text
@d26 1
a26 1
 *	$Id: exec.c,v 1.4 1999/06/01 19:08:52 brian Exp $
d121 1
a121 1
      pid_t pid;
d129 1
d160 1
a160 1
                         p->dl->bundle, 0);
@


1.4
log
@Increase the length of an individual device name to LINE_LEN.
Adjust the base physical device name correctly after a link
transfer (allowing correct multilink callbacks).
@
text
@d26 1
a26 1
 *	$Id: exec.c,v 1.3 1999/05/24 16:39:19 brian Exp $
d44 1
d102 1
@


1.3
log
@Correct the ``ignoring sync/async'' warnings so that they show
up with the correct device type.
Reassign the correct tcpdevice or execdevice after transfering
a link in MP server mode.
@
text
@d26 1
a26 1
 *	$Id: exec.c,v 1.2 1999/05/12 10:03:50 brian Exp $
d154 1
@


1.2
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d26 1
a26 1
 *	$Id: exec.c,v 1.1 1999/05/08 11:06:35 brian Exp $
d100 2
a101 1
  if (type == EXEC_DEVICE)
d103 1
d167 1
a167 1
          physical_SetupStack(p, PHYSICAL_FORCE_ASYNC);
@


1.1
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id:$
d81 18
a98 2
static int
exec_Open(struct physical *p)
d100 10
a109 1
  if (*p->name.full == '!') {
d165 2
a166 2
          physical_SetupStack(p, 1);
          return 1;
d171 1
a171 1
  return 0;
a172 13

const struct device execdevice = {
  EXEC_DEVICE,
  "exec",
  exec_Open,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
};
@

