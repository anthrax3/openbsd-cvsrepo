head	1.11;
access;
symbols
	OPENBSD_5_5:1.10.0.50
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.46
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.44
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.42
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.40
	OPENBSD_5_0:1.10.0.38
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.36
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.34
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.30
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.32
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.28
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.26
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.24
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.22
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.20
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.18
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.16
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.14
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.12
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.10
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.8
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.6
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.19.10.24.53;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.27.01.38.26;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.02.15.58.40;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.26.21.28.22;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.36;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.20;	author brian;	state Exp;
branches;
next	;


desc
@@


1.11
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: fsm.h,v 1.10 2002/06/15 01:33:23 brian Exp $
 */

/*
 *  State of machine
 */
#define	ST_INITIAL	0
#define	ST_STARTING	1
#define	ST_CLOSED	2
#define	ST_STOPPED	3
#define	ST_CLOSING	4
#define	ST_STOPPING	5
#define	ST_REQSENT	6
#define	ST_ACKRCVD	7
#define	ST_ACKSENT	8
#define	ST_OPENED	9

#define	ST_MAX		10
#define	ST_UNDEF	-1

#define	MODE_REQ	0
#define	MODE_NAK	1
#define	MODE_REJ	2
#define	MODE_NOP	3
#define	MODE_ACK	4	/* pseudo mode for ccp negotiations */

#define	OPEN_PASSIVE	-1

#define FSM_REQ_TIMER	1
#define FSM_TRM_TIMER	2

#define FSM_OPTLEN	100

struct fsm;

struct fsm_retry {
  u_int timeout;                             /* FSM retry frequency */
  u_int maxreq;                              /* Max Config REQ retries */
  u_int maxtrm;                              /* Max Term REQ retries */
};

struct fsm_decode {
  u_char ack[FSM_OPTLEN], *ackend;
  u_char nak[FSM_OPTLEN], *nakend;
  u_char rej[FSM_OPTLEN], *rejend;
};

struct fsm_callbacks {
  int (*LayerUp)(struct fsm *);                 /* Layer is now up (tlu) */
  void (*LayerDown)(struct fsm *);              /* About to come down (tld) */
  void (*LayerStart)(struct fsm *);             /* Layer about to start (tls) */
  void (*LayerFinish)(struct fsm *);            /* Layer now down (tlf) */
  void (*InitRestartCounter)(struct fsm *, int);/* Set fsm timer load */
  void (*SendConfigReq)(struct fsm *);          /* Send REQ please */
  void (*SentTerminateReq)(struct fsm *);       /* Term REQ just sent */
  void (*SendTerminateAck)(struct fsm *, u_char); /* Send Term ACK please */
  void (*DecodeConfig)(struct fsm *, u_char *, u_char *, int,
                       struct fsm_decode *);    /* Deal with incoming data */
  int (*RecvResetReq)(struct fsm *fp);          /* Reset output */
  void (*RecvResetAck)(struct fsm *fp, u_char); /* Reset input */
};

struct fsm_parent {
  void (*LayerStart) (void *, struct fsm *);         /* tls */
  void (*LayerUp) (void *, struct fsm *);            /* tlu */
  void (*LayerDown) (void *, struct fsm *);          /* tld */
  void (*LayerFinish) (void *, struct fsm *);        /* tlf */
  void *object;
};

struct link;
struct bundle;

struct fsm {
  const char *name;		/* Name of protocol */
  u_short proto;		/* Protocol number */
  u_short min_code;
  u_short max_code;
  int open_mode;		/* Delay before config REQ (-1 forever) */
  int state;			/* State of the machine */
  u_char reqid;			/* Next request id */
  int restart;			/* Restart counter value */

  struct {
    int reqs;			/* Max config REQs before a close() */
    int naks;			/* Max config NAKs before a close() */
    int rejs;			/* Max config REJs before a close() */
  } more;

  struct pppTimer FsmTimer;	/* Restart Timer */
  struct pppTimer OpenTimer;	/* Delay before opening */

  /*
   * This timer times the ST_STOPPED state out after the given value
   * (specified via "set stopped ...").  Although this isn't specified in the
   * rfc, the rfc *does* say that "the application may use higher level
   * timers to avoid deadlock". The StoppedTimer takes effect when the other
   * side ABENDs rather than going into ST_ACKSENT (and sending the ACK),
   * causing ppp to time out and drop into ST_STOPPED.  At this point,
   * nothing will change this state :-(
   */
  struct pppTimer StoppedTimer;
  int LogLevel;

  /* The link layer active with this FSM (may be our bundle below) */
  struct link *link;

  /* Our high-level link */
  struct bundle *bundle;

  const struct fsm_parent *parent;
  const struct fsm_callbacks *fn;
};

struct fsmheader {
  u_char code;			/* Request code */
  u_char id;			/* Identification */
  u_short length;		/* Length of packet */
};

#define	CODE_CONFIGREQ	1
#define	CODE_CONFIGACK	2
#define	CODE_CONFIGNAK	3
#define	CODE_CONFIGREJ	4
#define	CODE_TERMREQ	5
#define	CODE_TERMACK	6
#define	CODE_CODEREJ	7
#define	CODE_PROTOREJ	8
#define	CODE_ECHOREQ	9	/* Used in LCP */
#define	CODE_ECHOREP	10	/* Used in LCP */
#define	CODE_DISCREQ	11
#define	CODE_IDENT	12	/* Used in LCP Extension */
#define	CODE_TIMEREM	13	/* Used in LCP Extension */
#define	CODE_RESETREQ	14	/* Used in CCP */
#define	CODE_RESETACK	15	/* Used in CCP */

struct fsm_opt_hdr {
  u_char id;
  u_char len;
};

#define MAX_FSM_OPT_LEN 52
struct fsm_opt {
  struct fsm_opt_hdr hdr;
  u_char data[MAX_FSM_OPT_LEN-2];
};

#define INC_FSM_OPT(ty, length, o)                      \
  do {                                                  \
    (o)->hdr.id = (ty);                                 \
    (o)->hdr.len = (length);                            \
    (o) = (struct fsm_opt *)((u_char *)(o) + (length)); \
  } while (0)


extern void fsm_Init(struct fsm *, const char *, u_short, int, int, int,
                     struct bundle *, struct link *, const  struct fsm_parent *,
                     struct fsm_callbacks *, const char * const [3]);
extern void fsm_Output(struct fsm *, u_int, u_int, u_char *, int, int);
extern void fsm_Open(struct fsm *);
extern void fsm_Up(struct fsm *);
extern void fsm_Down(struct fsm *);
extern void fsm_Input(struct fsm *, struct mbuf *);
extern void fsm_Close(struct fsm *);
extern int fsm_NullRecvResetReq(struct fsm *);
extern void fsm_NullRecvResetAck(struct fsm *, u_char);
extern void fsm_Reopen(struct fsm *);
extern void fsm2initial(struct fsm *);
extern const char *State2Nam(u_int);
extern struct fsm_opt *fsm_readopt(u_char **);
extern void fsm_rej(struct fsm_decode *, const struct fsm_opt *);
extern void fsm_ack(struct fsm_decode *, const struct fsm_opt *);
extern void fsm_nak(struct fsm_decode *, const struct fsm_opt *);
extern void fsm_opt_normalise(struct fsm_decode *);
@


1.10
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d28 1
a28 1
 * $OpenBSD: fsm.h,v 1.9 2002/05/16 01:13:39 brian Exp $
@


1.9
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: fsm.h,v 1.8 2001/06/19 10:24:53 brian Exp $
d169 1
a169 1
#define MAX_FSM_OPT_LEN 20
@


1.8
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d28 1
a28 1
 * $OpenBSD: fsm.h,v 1.7 2001/06/13 21:33:41 brian Exp $
d59 2
d70 3
a72 3
  u_char ack[100], *ackend;
  u_char nak[100], *nakend;
  u_char rej[100], *rejend;
d76 12
a87 12
  int (*LayerUp) (struct fsm *);             /* Layer is now up (tlu) */
  void (*LayerDown) (struct fsm *);          /* About to come down (tld) */
  void (*LayerStart) (struct fsm *);         /* Layer about to start up (tls) */
  void (*LayerFinish) (struct fsm *);        /* Layer now down (tlf) */
  void (*InitRestartCounter) (struct fsm *, int); /* Set fsm timer load */
  void (*SendConfigReq) (struct fsm *);      /* Send REQ please */
  void (*SentTerminateReq) (struct fsm *);   /* Term REQ just sent */
  void (*SendTerminateAck) (struct fsm *, u_char); /* Send Term ACK please */
  void (*DecodeConfig) (struct fsm *, u_char *, int, int, struct fsm_decode *);
                                             /* Deal with incoming data */
  int (*RecvResetReq) (struct fsm *fp);         /* Reset output */
  void (*RecvResetAck) (struct fsm *fp, u_char); /* Reset input */
d164 18
a181 5
/* Minimum config req size.  This struct is *only* used for it's size */
struct fsmconfig {
  u_char type;
  u_char length;
};
d197 5
@


1.7
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d84 1
a84 1
  void (*RecvResetReq) (struct fsm *fp);         /* Reset output */
d177 1
a177 1
extern void fsm_NullRecvResetReq(struct fsm *);
@


1.6
log
@$Id$ -> $OpenBSD$
@
text
@d1 5
a5 2
/*
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d7 8
a14 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d16 11
a26 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d28 1
a28 3
 * $OpenBSD: fsm.h,v 1.5 2000/01/07 03:26:54 brian Exp $
 *
 *	TODO:
@


1.5
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d18 1
a18 1
 * $Id: fsm.h,v 1.4 1999/06/02 15:58:40 brian Exp $
@


1.4
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d18 1
a18 1
 * $Id: fsm.h,v 1.3 1999/02/26 21:28:22 brian Exp $
d162 1
a162 1
                     struct fsm_callbacks *, const char *[3]);
@


1.3
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d18 1
a18 1
 * $Id: fsm.h,v 1.2 1999/02/06 03:22:36 brian Exp $
d163 1
a163 1
extern void fsm_Output(struct fsm *, u_int, u_int, u_char *, int);
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d18 1
a18 1
 * $Id: fsm.h,v 1.19 1998/06/25 22:33:24 brian Exp $
d48 3
d53 6
d70 1
a70 1
  void (*InitRestartCounter) (struct fsm *); /* Set fsm timer load */
d100 6
a105 1
  int maxconfig;		/* Max config REQ before a close() */
d160 1
a160 1
extern void fsm_Init(struct fsm *, const char *, u_short, int, int, int, int,
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

