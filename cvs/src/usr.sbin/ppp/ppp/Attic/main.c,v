head	1.38;
access;
symbols
	OPENBSD_5_5:1.37.0.24
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.37.0.20
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.18
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.16
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.14
	OPENBSD_5_0:1.37.0.12
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.10
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.8
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.4
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.12
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.10
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.8
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.36.0.6
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.36.0.4
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.36.0.2
	OPENBSD_3_9_BASE:1.36
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.34.0.12
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.34.0.10
	OPENBSD_3_6_BASE:1.34
	OPENBSD_3_5:1.34.0.8
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.34.0.6
	OPENBSD_3_4_BASE:1.34
	OPENBSD_3_3:1.34.0.4
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_9:1.26.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.38
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.37;

1.37
date	2008.11.12.16.01.08;	author sobrado;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.21.15.04.28;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.28.09.34.24;	author brian;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.04.09.32.08;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.04.03.33.41;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.03.08.23.12;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.24.01.06.02;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.26.01.41.04;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.02.00.54.34;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.09.21.18.57;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.09.18.27.25;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.07.23.46.39;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.02.01.36.22;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2000.02.27.01.34.05;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.27.00.21.08;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	99.08.09.23.01.36;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	99.05.13.16.33.32;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.05.08.11.06.37;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.04.26.08.55.01;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.03.30.00.45.30;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.03.07.01.03.04;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.02.06.03.22.41;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.02.02.09.50.14;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.01.25.10.33.32;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	98.12.10.18.40.41;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	98.10.31.17.38.50;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.10.29.02.21.45;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.08.31.08.16.41;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.24;	author brian;	state Exp;
branches;
next	;


desc
@@


1.38
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: main.c,v 1.37 2008/11/12 16:01:08 sobrado Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/un.h>
#include <sys/socket.h>
#include <net/route.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <termios.h>
#include <unistd.h>
#include <sys/stat.h>

#ifndef NONAT
#ifdef LOCALNAT
#include "alias.h"
#else
#include <alias.h>
#endif
#endif

#include "layer.h"
#include "probe.h"
#include "mbuf.h"
#include "log.h"
#include "defs.h"
#include "id.h"
#include "timer.h"
#include "fsm.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "ccp.h"
#include "iplist.h"
#include "throughput.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "descriptor.h"
#include "link.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "auth.h"
#include "systems.h"
#include "sig.h"
#include "main.h"
#include "server.h"
#include "prompt.h"
#include "chat.h"
#include "chap.h"
#include "cbcp.h"
#include "datalink.h"
#include "iface.h"

#ifndef O_NONBLOCK
#ifdef O_NDELAY
#define	O_NONBLOCK O_NDELAY
#endif
#endif

static void DoLoop(struct bundle *);
static void TerminalStop(int);

static struct bundle *SignalBundle;
static struct prompt *SignalPrompt;

void
Cleanup(int excode)
{
  SignalBundle->CleaningUp = 1;
  bundle_Close(SignalBundle, NULL, CLOSE_STAYDOWN);
}

void
AbortProgram(int excode)
{
  if (SignalBundle)
    server_Close(SignalBundle);
  log_Printf(LogPHASE, "PPP Terminated (%s).\n", ex_desc(excode));
  if (SignalBundle) {
    bundle_Close(SignalBundle, NULL, CLOSE_STAYDOWN);
    bundle_Destroy(SignalBundle);
  }
  log_Close();
  exit(excode);
}

static void
CloseConnection(int signo)
{
  /* NOTE, these are manual, we've done a setsid() */
  sig_signal(SIGINT, SIG_IGN);
  log_Printf(LogPHASE, "Caught signal %d, abort connection(s)\n", signo);
  bundle_Down(SignalBundle, CLOSE_STAYDOWN);
  sig_signal(SIGINT, CloseConnection);
}

static void
CloseSession(int signo)
{
  log_Printf(LogPHASE, "Signal %d, terminate.\n", signo);
  Cleanup(EX_TERM);
}

static pid_t BGPid = 0;

static void
KillChild(int signo)
{
  signal(signo, SIG_IGN);
  log_Printf(LogPHASE, "Parent: Signal %d\n", signo);
  kill(BGPid, SIGINT);
}

static void
TerminalCont(int signo)
{
  signal(SIGCONT, SIG_DFL);
  prompt_Continue(SignalPrompt);
}

static void
TerminalStop(int signo)
{
  prompt_Suspend(SignalPrompt);
  signal(SIGCONT, TerminalCont);
  raise(SIGSTOP);
}

static void
BringDownServer(int signo)
{
  /* Drops all child prompts too ! */
  if (server_Close(SignalBundle))
    log_Printf(LogPHASE, "Closed server socket\n");
}

static void
RestartServer(int signo)
{
  /* Drops all child prompts and re-opens the socket */
  server_Reopen(SignalBundle);
}

static void
Usage(void)
{
  fprintf(stderr, "usage: ppp [-mode]"
#ifndef NOALIAS
          " [-nat]"
#endif
          " [-quiet] [-unitN] [system ...]\n");
  exit(EX_START);
}

struct switches {
  unsigned nat : 1;
  unsigned fg : 1;
  unsigned quiet : 1;
  int mode;
  int unit;
};

static int
ProcessArgs(int argc, char **argv, struct switches *sw)
{
  int optc, newmode, arg;
  char *cp;

  optc = 0;
  memset(sw, '\0', sizeof *sw);
  sw->mode = PHYS_INTERACTIVE;
  sw->unit = -1;

  for (arg = 1; arg < argc && *argv[arg] == '-'; arg++, optc++) {
    cp = argv[arg] + 1;
    newmode = Nam2mode(cp);
    switch (newmode) {
      case PHYS_NONE:
        if (strcmp(cp, "nat") == 0) {
#ifdef NONAT
          log_Printf(LogWARN, "%s ignored: NAT is compiled out\n", argv[arg]);
#else
          sw->nat = 1;
#endif
          optc--;			/* this option isn't exclusive */
        } else if (strcmp(cp, "alias") == 0) {
#ifdef NONAT
          log_Printf(LogWARN, "%s ignored: NAT is compiled out\n", argv[arg]);
          fprintf(stderr, "%s ignored: NAT is compiled out\n", argv[arg]);
#else
          log_Printf(LogWARN, "%s is deprecated\n", argv[arg]);
          fprintf(stderr, "%s is deprecated\n", argv[arg]);
          sw->nat = 1;
#endif
          optc--;			/* this option isn't exclusive */
        } else if (strncmp(cp, "unit", 4) == 0) {
          optc--;			/* this option isn't exclusive */
          if (cp[4] == '\0') {
            optc--;			/* nor is the argument */
            if (++arg == argc) {
              fprintf(stderr, "-unit: Expected unit number\n");
              Usage();
            } else
              sw->unit = atoi(argv[arg]);
          } else
            sw->unit = atoi(cp + 4);
        } else if (strcmp(cp, "quiet") == 0) {
          sw->quiet = 1;
          optc--;			/* this option isn't exclusive */
        } else
          Usage();
        break;

      case PHYS_ALL:
        Usage();
        break;

      default:
        sw->mode = newmode;
        if (newmode == PHYS_FOREGROUND)
          sw->fg = 1;
    }
  }

  if (optc > 1) {
    fprintf(stderr, "You may specify only one mode.\n");
    exit(EX_START);
  }

  if (sw->mode == PHYS_AUTO && arg == argc) {
    fprintf(stderr, "A system must be specified in auto mode.\n");
    exit(EX_START);
  }

  return arg;		/* Don't SetLabel yet ! */
}

static void
CheckLabel(const char *label, struct prompt *prompt, int mode)
{
  const char *err;

  if ((err = system_IsValid(label, prompt, mode)) != NULL) {
    fprintf(stderr, "%s: %s\n", label, err);
    if (mode == PHYS_DIRECT)
      log_Printf(LogWARN, "Label %s rejected -direct connection: %s\n",
                 label, err);
    log_Close();
    exit(1);
  }
}


int
main(int argc, char **argv)
{
  char *name;
  const char *lastlabel;
  int arg, f, holdfd[3], label;
  struct bundle *bundle;
  struct prompt *prompt;
  struct switches sw;

  probe_Init();

  /*
   * We open 3 descriptors to ensure that STDIN_FILENO, STDOUT_FILENO and
   * STDERR_FILENO are always open.  These are closed before DoLoop(),
   * but *after* we've avoided the possibility of erroneously closing
   * an important descriptor with close(STD{IN,OUT,ERR}_FILENO).
   */
  if ((holdfd[0] = open(_PATH_DEVNULL, O_RDWR)) == -1) {
    fprintf(stderr, "Cannot open %s !\n", _PATH_DEVNULL);
    return 2;
  }
  for (f = 1; f < sizeof holdfd / sizeof *holdfd; f++)
    holdfd[f] = dup(holdfd[0]);

  name = strrchr(argv[0], '/');
  log_Open(name ? name + 1 : argv[0]);

#ifndef NONAT
  PacketAliasInit();
#endif
  label = ProcessArgs(argc, argv, &sw);

  /*
   * A FreeBSD & OpenBSD hack to dodge a bug in the tty driver that drops
   * output occasionally.... I must find the real reason some time.  To
   * display the dodgy behaviour, comment out this bit, make yourself a large
   * routing table and then run ppp in interactive mode.  The `show route'
   * command will drop chunks of data !!!
   */
  if (sw.mode == PHYS_INTERACTIVE) {
    close(STDIN_FILENO);
    if (open(_PATH_TTY, O_RDONLY) != STDIN_FILENO) {
      fprintf(stderr, "Cannot open %s for input !\n", _PATH_TTY);
      return 2;
    }
  }

  /* Allow output for the moment (except in direct mode) */
  if (sw.mode == PHYS_DIRECT)
    prompt = NULL;
  else
    SignalPrompt = prompt = prompt_Create(NULL, NULL, PROMPT_STD);

  ID0init();
  if (ID0realuid() != 0) {
    char conf[200], *ptr;

    snprintf(conf, sizeof conf, "%s/%s", PPP_CONFDIR, CONFFILE);
    do {
      struct stat sb;

      if (stat(conf, &sb) == 0 && sb.st_mode & S_IWOTH) {
        log_Printf(LogALERT, "ppp: Access violation: Please protect %s\n",
                   conf);
        return -1;
      }
      ptr = conf + strlen(conf)-2;
      while (ptr > conf && *ptr != '/')
        *ptr-- = '\0';
    } while (ptr >= conf);
  }

  if (label < argc)
    for (arg = label; arg < argc; arg++)
      CheckLabel(argv[arg], prompt, sw.mode);
  else
    CheckLabel("default", prompt, sw.mode);

  if (!sw.quiet)
    prompt_Printf(prompt, "Working in %s mode\n", mode2Nam(sw.mode));

  if ((bundle = bundle_Create(TUN_PREFIX, sw.mode, sw.unit)) == NULL)
    return EX_START;

  /* NOTE:  We may now have changed argv[1] via a ``set proctitle'' */

  if (prompt) {
    prompt->bundle = bundle;	/* couldn't do it earlier */
    if (!sw.quiet)
      prompt_Printf(prompt, "Using interface: %s\n", bundle->iface->name);
  }
  SignalBundle = bundle;
  bundle->NatEnabled = sw.nat;
  if (sw.nat)
    opt_enable(bundle, OPT_IFACEALIAS);

  if (system_Select(bundle, "default", CONFFILE, prompt, NULL) < 0)
    prompt_Printf(prompt, "Warning: No default entry found in config file.\n");

  sig_signal(SIGHUP, CloseSession);
  sig_signal(SIGTERM, CloseSession);
  sig_signal(SIGINT, CloseConnection);
  sig_signal(SIGQUIT, CloseSession);
  sig_signal(SIGALRM, SIG_IGN);
  signal(SIGPIPE, SIG_IGN);

  if (sw.mode == PHYS_INTERACTIVE)
    sig_signal(SIGTSTP, TerminalStop);

  sig_signal(SIGUSR1, RestartServer);
  sig_signal(SIGUSR2, BringDownServer);

  lastlabel = argv[argc - 1];
  for (arg = label; arg < argc; arg++) {
    /* In case we use LABEL or ``set enddisc label'' */
    bundle_SetLabel(bundle, lastlabel);
    system_Select(bundle, argv[arg], CONFFILE, prompt, NULL);
  }

  if (label < argc)
    /* In case the last label did a ``load'' */
    bundle_SetLabel(bundle, lastlabel);

  if (sw.mode == PHYS_AUTO &&
      ncprange_family(&bundle->ncp.ipcp.cfg.peer_range) == AF_UNSPEC) {
    prompt_Printf(prompt, "You must ``set ifaddr'' with a peer address "
                  "in auto mode.\n");
    AbortProgram(EX_START);
  }

  if (sw.mode != PHYS_INTERACTIVE) {
    if (sw.mode != PHYS_DIRECT) {
      if (!sw.fg) {
        int bgpipe[2];
        pid_t bgpid;

        if (sw.mode == PHYS_BACKGROUND && pipe(bgpipe)) {
          log_Printf(LogERROR, "pipe: %s\n", strerror(errno));
	  AbortProgram(EX_SOCK);
        }

        bgpid = fork();
        if (bgpid == -1) {
	  log_Printf(LogERROR, "fork: %s\n", strerror(errno));
	  AbortProgram(EX_SOCK);
        }

        if (bgpid) {
	  char c = EX_NORMAL;
          int ret;

	  if (sw.mode == PHYS_BACKGROUND) {
	    close(bgpipe[1]);
	    BGPid = bgpid;
            /* If we get a signal, kill the child */
            signal(SIGHUP, KillChild);
            signal(SIGTERM, KillChild);
            signal(SIGINT, KillChild);
            signal(SIGQUIT, KillChild);

	    /* Wait for our child to close its pipe before we exit */
            while ((ret = read(bgpipe[0], &c, 1)) == 1) {
              switch (c) {
                case EX_NORMAL:
                  if (!sw.quiet) {
	            prompt_Printf(prompt, "PPP enabled\n");
	            log_Printf(LogPHASE, "Parent: PPP enabled\n");
                  }
	          break;
                case EX_REDIAL:
                  if (!sw.quiet)
	            prompt_Printf(prompt, "Attempting redial\n");
                  continue;
                case EX_RECONNECT:
                  if (!sw.quiet)
	            prompt_Printf(prompt, "Attempting reconnect\n");
                  continue;
	        default:
	          prompt_Printf(prompt, "Child failed (%s)\n",
                                ex_desc((int)c));
	          log_Printf(LogPHASE, "Parent: Child failed (%s)\n",
		             ex_desc((int) c));
	      }
	      break;
            }
            if (ret != 1) {
	      prompt_Printf(prompt, "Child exit, no status.\n");
	      log_Printf(LogPHASE, "Parent: Child exit, no status.\n");
	    }
	    close(bgpipe[0]);
	  }
	  return c;
        } else if (sw.mode == PHYS_BACKGROUND) {
	  close(bgpipe[0]);
          bundle->notify.fd = bgpipe[1];
        }

        bundle_ChangedPID(bundle);
        bundle_LockTun(bundle);	/* we have a new pid */
      }

      /* -auto, -dedicated, -ddial, -foreground & -background */
      prompt_Destroy(prompt, 0);
      close(STDOUT_FILENO);
      close(STDERR_FILENO);
      close(STDIN_FILENO);
      if (!sw.fg)
        setsid();
    } else {
      /* -direct - STDIN_FILENO gets used by physical_Open */
      prompt_TtyInit(NULL);
      close(STDOUT_FILENO);
      close(STDERR_FILENO);
    }
  } else {
    /* -interactive */
    close(STDERR_FILENO);
    prompt_TtyInit(prompt);
    prompt_TtyCommandMode(prompt);
    prompt_Required(prompt);
  }

  /* We can get rid of these now */
  for (f = 0; f < sizeof holdfd / sizeof *holdfd; f++)
    close(holdfd[f]);

  log_Printf(LogPHASE, "PPP Started (%s mode).\n", mode2Nam(sw.mode));
  DoLoop(bundle);
  AbortProgram(EX_NORMAL);

  return EX_NORMAL;
}

static void
DoLoop(struct bundle *bundle)
{
  fd_set *rfds, *wfds, *efds;
  int i, nfds, nothing_done;

  if ((rfds = mkfdset()) == NULL) {
    log_Printf(LogERROR, "DoLoop: Cannot create fd_set\n");
    return;
  }

  if ((wfds = mkfdset()) == NULL) {
    log_Printf(LogERROR, "DoLoop: Cannot create fd_set\n");
    free(rfds);
    return;
  }

  if ((efds = mkfdset()) == NULL) {
    log_Printf(LogERROR, "DoLoop: Cannot create fd_set\n");
    free(rfds);
    free(wfds);
    return;
  }

  for (; !bundle_IsDead(bundle); bundle_CleanDatalinks(bundle)) {
    nfds = 0;
    zerofdset(rfds);
    zerofdset(wfds);
    zerofdset(efds);

    /* All our datalinks, the tun device and the MP socket */
    descriptor_UpdateSet(&bundle->desc, rfds, wfds, efds, &nfds);

    /* All our prompts and the diagnostic socket */
    descriptor_UpdateSet(&server.desc, rfds, NULL, NULL, &nfds);

    bundle_CleanDatalinks(bundle);
    if (bundle_IsDead(bundle))
      /* Don't select - we'll be here forever */
      break;

    /*
     * It's possible that we've had a signal since we last checked.  If
     * we don't check again before calling select(), we may end up stuck
     * after having missed the event.... sig_Handle() tries to be as
     * quick as possible if nothing is likely to have happened.
     * This is only really likely if we block in open(... O_NONBLOCK)
     * which will happen with a misconfigured device.
     */
    if (sig_Handle())
      continue;

    i = select(nfds, rfds, wfds, efds, NULL);

    if (i < 0 && errno != EINTR) {
      log_Printf(LogERROR, "DoLoop: select(): %s\n", strerror(errno));
      if (log_IsKept(LogTIMER)) {
        struct timeval t;

        for (i = 0; i <= nfds; i++) {
          if (FD_ISSET(i, rfds)) {
            log_Printf(LogTIMER, "Read set contains %d\n", i);
            FD_CLR(i, rfds);
            t.tv_sec = t.tv_usec = 0;
            if (select(nfds, rfds, wfds, efds, &t) != -1) {
              log_Printf(LogTIMER, "The culprit !\n");
              break;
            }
          }
          if (FD_ISSET(i, wfds)) {
            log_Printf(LogTIMER, "Write set contains %d\n", i);
            FD_CLR(i, wfds);
            t.tv_sec = t.tv_usec = 0;
            if (select(nfds, rfds, wfds, efds, &t) != -1) {
              log_Printf(LogTIMER, "The culprit !\n");
              break;
            }
          }
          if (FD_ISSET(i, efds)) {
            log_Printf(LogTIMER, "Error set contains %d\n", i);
            FD_CLR(i, efds);
            t.tv_sec = t.tv_usec = 0;
            if (select(nfds, rfds, wfds, efds, &t) != -1) {
              log_Printf(LogTIMER, "The culprit !\n");
              break;
            }
          }
        }
      }
      break;
    }

    log_Printf(LogTIMER, "Select returns %d\n", i);

    sig_Handle();

    if (i <= 0)
      continue;

    for (i = 0; i <= nfds; i++)
      if (FD_ISSET(i, efds)) {
        log_Printf(LogPHASE, "Exception detected on descriptor %d\n", i);
        /* We deal gracefully with link descriptor exceptions */
        if (!bundle_Exception(bundle, i)) {
          log_Printf(LogERROR, "Exception cannot be handled !\n");
          break;
        }
      }

    if (i <= nfds)
      break;

    nothing_done = 1;

    if (descriptor_IsSet(&server.desc, rfds)) {
      descriptor_Read(&server.desc, bundle, rfds);
      nothing_done = 0;
    }

    if (descriptor_IsSet(&bundle->desc, rfds)) {
      descriptor_Read(&bundle->desc, bundle, rfds);
      nothing_done = 0;
    }

    if (descriptor_IsSet(&bundle->desc, wfds))
      if (descriptor_Write(&bundle->desc, bundle, wfds) <= 0 && nothing_done) {
        /*
         * This is disastrous.  The OS has told us that something is
         * writable, and all our write()s have failed.  Rather than
         * going back immediately to do our UpdateSet()s and select(),
         * we sleep for a bit to avoid gobbling up all cpu time.
         */
        struct timeval t;

        t.tv_sec = 0;
        t.tv_usec = 100000;
        select(0, NULL, NULL, NULL, &t);
      }
  }

  log_Printf(LogDEBUG, "DoLoop done.\n");
}
@


1.37
log
@we should not document each operand in the usage of a command,
it is an usual practice on BSDs and make the synopsis and usage
more robust when operands are added or removed; synchronize the
usage with the synopsis on the manual page; while here, remove
superfluous information from the usage.

ok jmc@@
@
text
@d28 1
a28 1
 * $OpenBSD: main.c,v 1.36 2005/09/21 15:04:28 brad Exp $
@


1.36
log
@Send NAS-IP-Address as well as NAS-Identifier
Add ``disable NAS-IP-Address'' and ``disable NAS-Identifier'' options to
support pre-rfc2865 RADIUS servers.
This pushes our enable/disable items over the 32 bit limit, so reoganise
things to allow a bunch more options.

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: main.c,v 1.35 2005/07/17 19:13:25 brad Exp $
d192 1
a192 2
  fprintf(stderr, "usage: ppp [-auto | -foreground | -background | -direct |"
          " -dedicated | -ddial | -interactive]"
d196 1
a196 1
          " [-quiet] [-unit N] [system ...]\n");
@


1.35
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: main.c,v 1.34 2002/06/28 09:34:24 brian Exp $
d395 1
a395 1
    bundle->cfg.opt |= OPT_IFACEALIAS;
@


1.34
log
@Don't use SignalBundle if it's not set

Submitted by: Federico G. Schwindt <fgsch@@olimpo.com.br>
@
text
@d28 1
a28 1
 * $OpenBSD: main.c,v 1.33 2002/06/15 01:33:23 brian Exp $
d43 1
@


1.33
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d28 1
a28 1
 * $OpenBSD: main.c,v 1.32 2002/05/16 01:13:39 brian Exp $
d120 2
a121 1
  server_Close(SignalBundle);
d123 4
a126 2
  bundle_Close(SignalBundle, NULL, CLOSE_STAYDOWN);
  bundle_Destroy(SignalBundle);
@


1.32
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: main.c,v 1.31 2002/03/31 02:38:49 brian Exp $
d46 1
@


1.31
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d28 1
a28 1
 * $OpenBSD: main.c,v 1.30 2001/08/19 23:22:18 brian Exp $
a45 1
#include <sys/time.h>
a73 1
#include "ip.h"
d187 1
a187 1
  fprintf(stderr, "Usage: ppp [-auto | -foreground | -background | -direct |"
@


1.30
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: main.c,v 1.29 2001/07/04 09:32:08 brian Exp $
d656 1
a656 1
      if (!descriptor_Write(&bundle->desc, bundle, wfds) && nothing_done) {
d658 1
a658 1
         * This is disasterous.  The OS has told us that something is
@


1.29
log
@Make the last fix work properly on descriptors 1 and 2 (not just 0)
@
text
@d28 1
a28 1
 * $OpenBSD: main.c,v 1.28 2001/07/04 03:33:41 brian Exp $
d74 2
d84 2
d307 2
d422 1
a422 1
      bundle->ncp.ipcp.cfg.peer_range.ipaddr.s_addr == INADDR_ANY) {
a535 3
  struct probe probe;

  probe_Init(&probe);
@


1.28
log
@Handle any of descriptors 0, 1 or 2 being closed when we're
envoked -- don't use them (as return values from open()), then
(say) close(STDIN_FILENO) when daemonising.

This is done by grabbing 3 descriptors to /dev/null at startup and
releasing them after we've daemonised.
@
text
@d28 1
a28 1
 * $OpenBSD: main.c,v 1.27 2001/06/13 21:33:41 brian Exp $
d314 1
a314 1
    dup2(holdfd[0], holdfd[f]);
@


1.27
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d298 1
a298 1
  int label, arg;
d303 13
d513 4
@


1.26
log
@Don't say ``PPP enabled'' if we're given the -quiet switch
@
text
@d1 5
a5 2
/*
 *			User Process PPP
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 15
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: main.c,v 1.25 2001/03/24 01:06:02 brian Exp $
 *
 *	TODO:
@


1.25
log
@Remove some unprotected prototype variable names
MAXPATHLEN -> PATH_MAX
Handle ENOENT from opening /dev/tun* properly
Rename _PATH_PPP -> PPP_CONFDIR and allow it to be redefined at compile time
Reduce MIN_LQRPERIOD and MIN_FSMRETRY to 1 second
Be smarter about identifying sockets on stdin
Allow primary DNS IP negotiation when the secondary IP has been rejected
Fix the call to PacketAliasProxyRule() properly.
Add/fix some comments
Fix man page markups; ru@@FreeBSD.org
Use localhost when no hostname is configured
@
text
@d20 1
a20 1
 * $OpenBSD: main.c,v 1.24 2001/01/26 01:41:04 brian Exp $
d437 4
a440 2
	          prompt_Printf(prompt, "PPP enabled\n");
	          log_Printf(LogPHASE, "Parent: PPP enabled\n");
@


1.24
log
@Allow ``set server closed'' to close the diagnostic socket.
Allow ``set server open'' to re-open the diagnostic socket.
Handle SIGUSR1 by re-opening the diagnostic socket
When receiving SIGUSR2 (and in ``set server none''), don't forget the
socket details so that ``set server open'' and SIGUSR1 open it again.

Don't create the diagnostic socket as uid 0 !  It's far to dangerous.
@
text
@d20 1
a20 1
 * $OpenBSD: main.c,v 1.23 2000/11/02 00:54:34 brian Exp $
d330 1
a330 1
    snprintf(conf, sizeof conf, "%s/%s", _PATH_PPP, CONFFILE);
@


1.23
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d20 1
a20 1
 * $OpenBSD: main.c,v 1.22 2000/10/09 21:18:57 brian Exp $
d165 9
a173 1
  server_Close(SignalBundle);
d382 1
@


1.22
log
@Create fd_sets big enough to handle getdtablesize() descriptors.
@
text
@d20 1
a20 1
 * $OpenBSD: main.c,v 1.21 2000/04/09 18:27:25 brian Exp $
d171 2
a172 2
  fprintf(stderr,
	  "Usage: ppp [-auto | -foreground | -background | -direct | -dedicated | -ddial | -interactive]"
@


1.21
log
@Add a missing ``break''
@
text
@d20 1
a20 1
 * $OpenBSD: main.c,v 1.20 2000/04/07 23:46:39 brian Exp $
d284 1
a284 1
  int nfds, label, arg;
a288 10
  nfds = getdtablesize();
  if (nfds >= FD_SETSIZE)
    /*
     * If we've got loads of file descriptors, make sure they're all
     * closed.  If they aren't, we may end up with a seg fault when our
     * `fd_set's get too big when select()ing !
     */
    while (--nfds > 2)
      close(nfds);

d494 1
a494 1
  fd_set rfds, wfds, efds;
d500 18
d520 3
a522 3
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    FD_ZERO(&efds);
d525 1
a525 1
    descriptor_UpdateSet(&bundle->desc, &rfds, &wfds, &efds, &nfds);
d528 1
a528 1
    descriptor_UpdateSet(&server.desc, &rfds, NULL, NULL, &nfds);
d546 1
a546 1
    i = select(nfds, &rfds, &wfds, &efds, NULL);
d554 1
a554 1
          if (FD_ISSET(i, &rfds)) {
d556 1
a556 1
            FD_CLR(i, &rfds);
d558 1
a558 1
            if (select(nfds, &rfds, &wfds, &efds, &t) != -1) {
d563 1
a563 1
          if (FD_ISSET(i, &wfds)) {
d565 1
a565 1
            FD_CLR(i, &wfds);
d567 1
a567 1
            if (select(nfds, &rfds, &wfds, &efds, &t) != -1) {
d572 1
a572 1
          if (FD_ISSET(i, &efds)) {
d574 1
a574 1
            FD_CLR(i, &efds);
d576 1
a576 1
            if (select(nfds, &rfds, &wfds, &efds, &t) != -1) {
d594 1
a594 1
      if (FD_ISSET(i, &efds)) {
d608 2
a609 2
    if (descriptor_IsSet(&server.desc, &rfds)) {
      descriptor_Read(&server.desc, bundle, &rfds);
d613 2
a614 2
    if (descriptor_IsSet(&bundle->desc, &rfds)) {
      descriptor_Read(&bundle->desc, bundle, &rfds);
d618 2
a619 2
    if (descriptor_IsSet(&bundle->desc, &wfds))
      if (!descriptor_Write(&bundle->desc, bundle, &wfds) && nothing_done) {
@


1.20
log
@When running ppp -background, show comfort messages showing
when we're redialing/reconnecting.

While we're here, log redial, reconnect and phone number
announcements to LogCHAT, and reduce some other logging to
LogDEBUG.
@
text
@d20 1
a20 1
 * $OpenBSD: main.c,v 1.19 2000/04/02 01:36:22 brian Exp $
d440 1
@


1.19
log
@Don't wait for the redial timer before exiting due to the last
background/direct link closing.
@
text
@d20 1
a20 1
 * $OpenBSD: main.c,v 1.18 2000/02/27 01:38:27 brian Exp $
a96 1
static const char *ex_desc(int);
a167 15
static const char *
ex_desc(int ex)
{
  static char num[12];		/* Used immediately if returned */
  static const char * const desc[] = {
    "normal", "start", "sock", "modem", "dial", "dead", "done",
    "reboot", "errdead", "hangup", "term", "nodial", "nologin"
  };

  if (ex >= 0 && ex < sizeof desc / sizeof *desc)
    return desc[ex];
  snprintf(num, sizeof num, "%d", ex);
  return num;
}

d423 1
d435 22
a456 1
	    if (read(bgpipe[0], &c, 1) != 1) {
a458 7
	    } else if (c == EX_NORMAL) {
	      prompt_Printf(prompt, "PPP enabled.\n");
	      log_Printf(LogPHASE, "Parent: PPP enabled.\n");
	    } else {
	      prompt_Printf(prompt, "Child failed (%s).\n", ex_desc((int) c));
	      log_Printf(LogPHASE, "Parent: Child failed (%s).\n",
		         ex_desc((int) c));
@


1.18
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: main.c,v 1.17 2000/02/27 01:34:05 brian Exp $
d522 1
@


1.17
log
@Fix a bug in end-of-line comment parsing.
Fix callback (don't ``forget'' to call back).
Restructure how we add/remove the address family when
writing/reading the tun device.
Notify the tun device that we've changed PID under FreeBSD.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.16 2000/02/27 00:21:08 brian Exp $
@


1.16
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.15 2000/01/07 03:26:54 brian Exp $
d469 1
@


1.15
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.14 1999/08/09 23:01:36 brian Exp $
d30 2
d46 3
a48 1
#ifdef __FreeBSD__
a49 2
#else
#include "alias.h"
d52 1
@


1.14
log
@Insist that ppp.conf and it's parent directories aren't `other'
writable rather than not being writable at all.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.13 1999/05/13 16:33:32 brian Exp $
d36 1
d43 1
a43 1
#ifndef NOALIAS
d170 1
a170 1
  static const char *desc[] = {
d185 1
a185 1
	  "Usage: ppp [-auto | -background | -direct | -dedicated | -ddial ]"
d187 1
a187 1
          " [ -alias ]"
d189 1
a189 1
          " [system ...]\n");
d193 8
d202 1
a202 1
ProcessArgs(int argc, char **argv, int *mode, int *alias)
d208 4
a211 2
  *mode = PHYS_INTERACTIVE;
  *alias = 0;
d217 3
a219 3
        if (strcmp(cp, "alias") == 0) {
#ifdef NOALIAS
          log_Printf(LogWARN, "Cannot load alias library (compiled out)\n");
d221 1
a221 1
          *alias = 1;
d224 24
d257 3
a259 1
        *mode = newmode;
d268 1
a268 1
  if (*mode == PHYS_AUTO && arg == argc) {
d297 1
a297 1
  int nfds, mode, alias, label, arg;
d300 1
d315 1
a315 1
#ifndef NOALIAS
d318 1
a318 1
  label = ProcessArgs(argc, argv, &mode, &alias);
d327 1
a327 1
  if (mode == PHYS_INTERACTIVE) {
d336 1
a336 1
  if (mode == PHYS_DIRECT)
d362 1
a362 1
      CheckLabel(argv[arg], prompt, mode);
d364 1
a364 1
    CheckLabel("default", prompt, mode);
d366 2
a367 1
  prompt_Printf(prompt, "Working in %s mode\n", mode2Nam(mode));
d369 1
a369 2
  if ((bundle = bundle_Create(TUN_PREFIX, mode, (const char **)argv)) == NULL) {
    log_Printf(LogWARN, "bundle_Create: %s\n", strerror(errno));
a370 1
  }
d376 2
a377 1
    prompt_Printf(prompt, "Using interface: %s\n", bundle->iface->name);
d380 2
a381 2
  bundle->AliasEnabled = alias;
  if (alias)
d394 1
a394 1
  if (mode == PHYS_INTERACTIVE)
d399 1
a399 1
  lastlabel = argc == 2 ? bundle->argv1 : argv[argc - 1];
d403 1
a403 2
    system_Select(bundle, arg == 1 ? bundle->argv1 : argv[arg],
                  CONFFILE, prompt, NULL);
d410 1
a410 1
  if (mode == PHYS_AUTO &&
d417 10
a426 9
  if (mode != PHYS_INTERACTIVE) {
    if (mode != PHYS_DIRECT) {
      int bgpipe[2];
      pid_t bgpid;

      if (mode == PHYS_BACKGROUND && pipe(bgpipe)) {
        log_Printf(LogERROR, "pipe: %s\n", strerror(errno));
	AbortProgram(EX_SOCK);
      }
d428 5
a432 5
      bgpid = fork();
      if (bgpid == -1) {
	log_Printf(LogERROR, "fork: %s\n", strerror(errno));
	AbortProgram(EX_SOCK);
      }
d434 2
a435 2
      if (bgpid) {
	char c = EX_NORMAL;
d437 22
a458 20
	if (mode == PHYS_BACKGROUND) {
	  close(bgpipe[1]);
	  BGPid = bgpid;
          /* If we get a signal, kill the child */
          signal(SIGHUP, KillChild);
          signal(SIGTERM, KillChild);
          signal(SIGINT, KillChild);
          signal(SIGQUIT, KillChild);

	  /* Wait for our child to close its pipe before we exit */
	  if (read(bgpipe[0], &c, 1) != 1) {
	    prompt_Printf(prompt, "Child exit, no status.\n");
	    log_Printf(LogPHASE, "Parent: Child exit, no status.\n");
	  } else if (c == EX_NORMAL) {
	    prompt_Printf(prompt, "PPP enabled.\n");
	    log_Printf(LogPHASE, "Parent: PPP enabled.\n");
	  } else {
	    prompt_Printf(prompt, "Child failed (%s).\n", ex_desc((int) c));
	    log_Printf(LogPHASE, "Parent: Child failed (%s).\n",
		      ex_desc((int) c));
d460 2
d463 4
a466 5
	}
	return c;
      } else if (mode == PHYS_BACKGROUND) {
	close(bgpipe[0]);
        bundle->notify.fd = bgpipe[1];
d469 1
a469 3
      bundle_LockTun(bundle);	/* we have a new pid */

      /* -auto, -dedicated, -ddial & -background */
d474 2
a475 1
      setsid();
d477 1
a477 1
      /* -direct: STDIN_FILENO gets used by modem_Open */
d483 1
a483 1
    /* Interactive mode */
d490 1
a490 1
  log_Printf(LogPHASE, "PPP Started (%s mode).\n", mode2Nam(mode));
d506 1
a506 1
  do {
d619 1
a619 1
  } while (bundle_CleanDatalinks(bundle), !bundle_IsDead(bundle));
@


1.13
log
@Ignore repeated signals sent to the parent in background
mode.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.12 1999/05/08 11:06:37 brian Exp $
d40 1
d309 3
a311 1
      if (!access(conf, W_OK)) {
@


1.12
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.11 1999/04/26 08:55:01 brian Exp $
d137 1
@


1.11
log
@Add support for NetBSD
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.10 1999/03/30 00:45:30 brian Exp $
d48 1
a574 1

@


1.10
log
@Maintain a `necessary' marker to indicate that we *probably*
need to process a signal (usually a SIGALRM).  Check to see
if we need to process a signal both before *and* after calling
select() as older (pre-2.0) versions of ppp used to.

This handles the possibility that ppp may block at some
point (maybe due to an open() of a misconfigured device).
Previously, we'd potentially lock up in select().

The `necessary' marker reduces the increased signal checking
overhead so that at full speed with no compression transferring
an 83Mb file via a ``!ppp -direct'' device, we get a 1%
throughput gain.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.9 1999/03/07 01:03:04 brian Exp $
d42 3
a44 1
#ifdef __OpenBSD__
a45 2
#else
#include <alias.h>
@


1.9
log
@Reopen descriptor 0 as /dev/tty when in interactive mode
in OpenBSD as well as FreeBSD (I still don't know why).
Add a debug diagnostic when creating a child process as
a link.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.8 1999/02/06 03:22:41 brian Exp $
d476 11
@


1.8
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.149 1999/02/02 09:35:29 brian Exp $
a278 1
#ifdef __FreeBSD__
d280 3
a282 3
   * A FreeBSD hack to dodge a bug in the tty driver that drops output
   * occasionally.... I must find the real reason some time.  To display
   * the dodgy behaviour, comment out this bit, make yourself a large
a292 1
#endif
@


1.7
log
@Don't allow root to specify non-existent labels on
the command line.
Revise the error diagnostics so that invalid labels
are reported immediately.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.6 1999/01/25 10:33:32 brian Exp $
d25 1
a25 1
#include <sys/types.h>
d67 3
d518 2
@


1.6
log
@Don't SEGV when ``set proctitle'' is used in the default
section.
Submitted by:	Dan Lukes <dan@@obluda.cz>
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.5 1998/12/10 18:40:41 brian Exp $
a238 1
    fprintf(stderr, "You may not use ppp in this mode with this label\n");
d296 1
a296 1
  else {
a297 2
    prompt_Printf(prompt, "Working in %s mode\n", mode2Nam(mode));
  }
d321 2
@


1.5
log
@When using ``set device !someprogram'', when ``someprogram''
exits, it causes a select() exception.
Handle these select() exceptions on link descriptors in pretty
much the same way as loss of carrier rather than dropping out
in confusion.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.4 1998/10/31 17:38:50 brian Exp $
d254 1
d329 3
d356 1
d359 3
a361 2
    bundle_SetLabel(bundle, argv[argc - 1]);
    system_Select(bundle, argv[arg], CONFFILE, prompt, NULL);
d366 1
a366 1
    bundle_SetLabel(bundle, argv[argc - 1]);
@


1.4
log
@Allow multiple systems (config labels) on the command
line and in the ``load'' & ``dial'' commands.  The last
label loaded becomes the current label name.
Only require a label for -auto mode.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.3 1998/10/29 02:21:45 brian Exp $
d518 6
a523 2
        log_Printf(LogERROR, "Exception detected on descriptor %d\n", i);
        break;
@


1.3
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.2 1998/08/31 08:16:41 brian Exp $
d182 1
a182 1
          " [system]\n");
d186 1
a186 1
static char *
d189 1
a189 1
  int optc, labelrequired, newmode;
d192 1
a192 1
  optc = labelrequired = 0;
d195 2
a196 2
  while (argc > 0 && **argv == '-') {
    cp = *argv + 1;
d202 1
a202 1
          log_Printf(LogWARN, "Cannot load alias library\n");
a214 6
      case PHYS_AUTO:
      case PHYS_BACKGROUND:
      case PHYS_DDIAL:
        labelrequired = 1;
        /* fall through */

a217 8
    optc++;
    argv++;
    argc--;
  }

  if (argc > 1) {
    fprintf(stderr, "You may specify only one system label.\n");
    exit(EX_START);
d225 2
a226 3
  if (labelrequired && argc != 1) {
    fprintf(stderr, "Destination system must be specified in"
            " auto, background or ddial mode.\n");
d230 17
a246 1
  return argc == 1 ? *argv : NULL;	/* Don't SetLabel yet ! */
d249 1
d253 2
a254 2
  char *name, *label;
  int nfds, mode, alias;
d274 1
a274 1
  label = ProcessArgs(argc - 1, argv + 1, &mode, &alias);
d318 5
a322 10
  if (!system_IsValid(label, prompt, mode)) {
    fprintf(stderr, "You may not use ppp in this mode with this label\n");
    if (mode == PHYS_DIRECT) {
      const char *l;
      l = label ? label : "default";
      log_Printf(LogWARN, "Label %s rejected -direct connection\n", l);
    }
    log_Close();
    return 1;
  }
d352 15
a366 19
  if (label) {
    /*
     * Set label both before and after system_Select !
     * This way, "set enddisc label" works during system_Select, and we
     * also end up with the correct label if we have embedded load
     * commands.
     */
    bundle_SetLabel(bundle, label);
    if (system_Select(bundle, label, CONFFILE, prompt, NULL) < 0) {
      prompt_Printf(prompt, "Destination system (%s) not found.\n", label);
      AbortProgram(EX_START);
    }
    bundle_SetLabel(bundle, label);
    if (mode == PHYS_AUTO &&
	bundle->ncp.ipcp.cfg.peer_range.ipaddr.s_addr == INADDR_ANY) {
      prompt_Printf(prompt, "You must \"set ifaddr\" with a peer address "
                    "in label %s for auto mode.\n", label);
      AbortProgram(EX_START);
    }
@


1.2
log
@Move libalias sources into the ppp directory.
Suggested (many times) by: Theo
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.1 1998/08/31 00:22:24 brian Exp $
d78 1
d333 1
a333 1
    prompt_Printf(prompt, "Using interface: %s\n", bundle->ifp.Name);
d337 2
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: main.c,v 1.142 1998/08/09 09:13:54 brian Exp $
a30 3
#ifndef NOALIAS
#include <alias.h>
#endif
d41 7
@

