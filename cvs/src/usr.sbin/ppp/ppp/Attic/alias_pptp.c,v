head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.56
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.52
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.50
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.48
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.46
	OPENBSD_5_0:1.4.0.44
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.42
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.40
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.36
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.38
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.34
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.32
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.30
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.28
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.26
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.24
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.22
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.20
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.18
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.16
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.14
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.12
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.10
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.8
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2001.03.25.12.33.06;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.02.00.53.47;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.13.22.05.47;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.23.09.47.05;	author brian;	state Exp;
branches;
next	;


desc
@@


1.5
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*
 * alias_pptp.c
 *
 * Copyright (c) 2000 Whistle Communications, Inc.
 * All rights reserved.
 *
 * Subject to the following obligations and disclaimer of warranty, use and
 * redistribution of this software, in source or object code forms, with or
 * without modifications are expressly permitted by Whistle Communications;
 * provided, however, that:
 * 1. Any and all reproductions of the source or object code must include the
 *    copyright notice above and the following disclaimer of warranties; and
 * 2. No rights are granted, in any manner or form, to use Whistle
 *    Communications, Inc. trademarks, including the mark "WHISTLE
 *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as
 *    such appears in the above copyright notice or in the software.
 *
 * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND
 * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO
 * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,
 * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
 * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY
 * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS
 * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.
 * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES
 * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING
 * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 * Author: Erik Salander <erik@@whistle.com>
 *
 *	$OpenBSD: alias_pptp.c,v 1.4 2001/03/25 12:33:06 brian Exp $
 */

/*
   Alias_pptp.c performs special processing for PPTP sessions under TCP.
   Specifically, watch PPTP control messages and alias the Call ID or the
   Peer's Call ID in the appropriate messages.  Note, PPTP requires
   "de-aliasing" of incoming packets, this is different than any other
   TCP applications that are currently (ie. FTP, IRC and RTSP) aliased.

   For Call IDs encountered for the first time, a PPTP alias link is created.
   The PPTP alias link uses the Call ID in place of the original port number.
   An alias Call ID is created.

   For this routine to work, the PPTP control messages must fit entirely
   into a single TCP packet.  This is typically the case, but is not
   required by the spec.

   Unlike some of the other TCP applications that are aliased (ie. FTP,
   IRC and RTSP), the PPTP control messages that need to be aliased are
   guaranteed to remain the same length.  The aliased Call ID is a fixed
   length field.

   Reference: RFC 2637

   Initial version:  May, 2000 (eds)

*/

/* Includes */
#include <sys/types.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <stdio.h>

#include "alias_local.h"

/*
 * PPTP definitions
 */

struct grehdr			/* Enhanced GRE header. */
{
    u_int16_t gh_flags;		/* Flags. */
    u_int16_t gh_protocol;	/* Protocol type. */
    u_int16_t gh_length;	/* Payload length. */
    u_int16_t gh_call_id;	/* Call ID. */
    u_int32_t gh_seq_no;	/* Sequence number (optional). */
    u_int32_t gh_ack_no;	/* Acknowledgment number (optional). */
};
typedef struct grehdr		GreHdr;

/* The PPTP protocol ID used in the GRE 'proto' field. */
#define PPTP_GRE_PROTO          0x880b

/* Bits that must be set a certain way in all PPTP/GRE packets. */
#define PPTP_INIT_VALUE		((0x2001 << 16) | PPTP_GRE_PROTO)
#define PPTP_INIT_MASK		0xef7fffff

#define PPTP_MAGIC		0x1a2b3c4d
#define PPTP_CTRL_MSG_TYPE	1

enum {
  PPTP_StartCtrlConnRequest = 1,
  PPTP_StartCtrlConnReply = 2,
  PPTP_StopCtrlConnRequest = 3,
  PPTP_StopCtrlConnReply = 4,
  PPTP_EchoRequest = 5,
  PPTP_EchoReply = 6,
  PPTP_OutCallRequest = 7,
  PPTP_OutCallReply = 8,
  PPTP_InCallRequest = 9,
  PPTP_InCallReply = 10,
  PPTP_InCallConn = 11,
  PPTP_CallClearRequest = 12,
  PPTP_CallDiscNotify = 13,
  PPTP_WanErrorNotify = 14,
  PPTP_SetLinkInfo = 15
};

  /* Message structures */
  struct pptpMsgHead {
    u_int16_t   length;         /* total length */
    u_int16_t   msgType;        /* PPTP message type */
    u_int32_t   magic;          /* magic cookie */
    u_int16_t   type;           /* control message type */
    u_int16_t   resv0;          /* reserved */
  };
  typedef struct pptpMsgHead    *PptpMsgHead;

  struct pptpCodes {
    u_int8_t    resCode;        /* Result Code */
    u_int8_t    errCode;        /* Error Code */
  };
  typedef struct pptpCodes      *PptpCode;

  struct pptpCallIds {
    u_int16_t   cid1;           /* Call ID field #1 */
    u_int16_t   cid2;           /* Call ID field #2 */
  };
  typedef struct pptpCallIds    *PptpCallId;

static PptpCallId AliasVerifyPptp(struct ip *, u_int16_t *);


void
AliasHandlePptpOut(struct ip *pip,	    /* IP packet to examine/patch */
                   struct alias_link *link) /* The PPTP control link */
{
    struct alias_link   *pptp_link;
    PptpCallId    	cptr;
    PptpCode            codes;
    u_int16_t           ctl_type;           /* control message type */
    struct tcphdr 	*tc;

    /* Verify valid PPTP control message */
    if ((cptr = AliasVerifyPptp(pip, &ctl_type)) == NULL)
      return;

    /* Modify certain PPTP messages */
    switch (ctl_type) {
    case PPTP_OutCallRequest:
    case PPTP_OutCallReply:
    case PPTP_InCallRequest:
    case PPTP_InCallReply:
	/* Establish PPTP link for address and Call ID found in control message. */
	pptp_link = AddPptp(GetOriginalAddress(link), GetDestAddress(link),
			    GetAliasAddress(link), cptr->cid1);
	break;
    case PPTP_CallClearRequest:
    case PPTP_CallDiscNotify:
	/* Find PPTP link for address and Call ID found in control message. */
	pptp_link = FindPptpOutByCallId(GetOriginalAddress(link),
					GetDestAddress(link),
					cptr->cid1);
	break;
    default:
	return;
    }

      if (pptp_link != NULL) {
	int accumulate = cptr->cid1;

	/* alias the Call Id */
	cptr->cid1 = GetAliasPort(pptp_link);

	/* Compute TCP checksum for revised packet */
	tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));
	accumulate -= cptr->cid1;
	ADJUST_CHECKSUM(accumulate, tc->th_sum);

	switch (ctl_type) {
	case PPTP_OutCallReply:
	case PPTP_InCallReply:
	    codes = (PptpCode)(cptr + 1);
	    if (codes->resCode == 1)		/* Connection established, */
		SetDestCallId(pptp_link,	/* note the Peer's Call ID. */
			      cptr->cid2);
	    else
		SetExpire(pptp_link, 0);	/* Connection refused. */
	    break;
	case PPTP_CallDiscNotify:		/* Connection closed. */
	    SetExpire(pptp_link, 0);
	    break;
	}
      }
}

void
AliasHandlePptpIn(struct ip *pip,	   /* IP packet to examine/patch */
                  struct alias_link *link) /* The PPTP control link */
{
    struct alias_link   *pptp_link;
    PptpCallId    	cptr;
    u_int16_t     	*pcall_id;
    u_int16_t           ctl_type;           /* control message type */
    struct tcphdr 	*tc;

    /* Verify valid PPTP control message */
    if ((cptr = AliasVerifyPptp(pip, &ctl_type)) == NULL)
      return;

    /* Modify certain PPTP messages */
    switch (ctl_type)
    {
    case PPTP_InCallConn:
    case PPTP_WanErrorNotify:
    case PPTP_SetLinkInfo:
      pcall_id = &cptr->cid1;
      break;
    case PPTP_OutCallReply:
    case PPTP_InCallReply:
      pcall_id = &cptr->cid2;
      break;
    case PPTP_CallDiscNotify:			/* Connection closed. */
      pptp_link = FindPptpInByCallId(GetDestAddress(link),
				     GetAliasAddress(link),
				     cptr->cid1);
      if (pptp_link != NULL)
	    SetExpire(pptp_link, 0);
      return;
    default:
      return;
    }

    /* Find PPTP link for address and Call ID found in PPTP Control Msg */
    pptp_link = FindPptpInByPeerCallId(GetDestAddress(link),
				       GetAliasAddress(link),
				       *pcall_id);

    if (pptp_link != NULL) {
      int accumulate = *pcall_id;

      /* De-alias the Peer's Call Id. */
      *pcall_id = GetOriginalPort(pptp_link);

      /* Compute TCP checksum for modified packet */
      tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));
      accumulate -= *pcall_id;
      ADJUST_CHECKSUM(accumulate, tc->th_sum);

      if (ctl_type == PPTP_OutCallReply || ctl_type == PPTP_InCallReply) {
	    PptpCode codes = (PptpCode)(cptr + 1);

	    if (codes->resCode == 1)		/* Connection established, */
		SetDestCallId(pptp_link,	/* note the Call ID. */
			      cptr->cid1);
	    else
		SetExpire(pptp_link, 0);	/* Connection refused. */
      }
    }
}

static PptpCallId
AliasVerifyPptp(struct ip *pip, u_int16_t *ptype) /* IP packet to examine/patch */
{
    int           	hlen, tlen, dlen;
    PptpMsgHead   	hptr;
    struct tcphdr 	*tc;

    /* Calculate some lengths */
    tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));
    hlen = (pip->ip_hl + tc->th_off) << 2;
    tlen = ntohs(pip->ip_len);
    dlen = tlen - hlen;

    /* Verify data length */
    if (dlen < (sizeof(struct pptpMsgHead) + sizeof(struct pptpCallIds)))
      return(NULL);

    /* Move up to PPTP message header */
    hptr = (PptpMsgHead)(((char *) pip) + hlen);

    /* Return the control message type */
    *ptype = ntohs(hptr->type);

    /* Verify PPTP Control Message */
    if ((ntohs(hptr->msgType) != PPTP_CTRL_MSG_TYPE) ||
        (ntohl(hptr->magic) != PPTP_MAGIC))
      return(NULL);

    /* Verify data length. */
    if ((*ptype == PPTP_OutCallReply || *ptype == PPTP_InCallReply) &&
	(dlen < sizeof(struct pptpMsgHead) + sizeof(struct pptpCallIds) +
		sizeof(struct pptpCodes)))
	return (NULL);
    else
	return (PptpCallId)(hptr + 1);
}


int
AliasHandlePptpGreOut(struct ip *pip)
{
    GreHdr		*gr;
    struct alias_link	*link;

    gr = (GreHdr *)((char *)pip + (pip->ip_hl << 2));

    /* Check GRE header bits. */
    if ((ntohl(*((u_int32_t *)gr)) & PPTP_INIT_MASK) != PPTP_INIT_VALUE)
	return (-1);

    link = FindPptpOutByPeerCallId(pip->ip_src, pip->ip_dst, gr->gh_call_id);
    if (link != NULL) {
	struct in_addr alias_addr = GetAliasAddress(link);

	/* Change source IP address. */
	DifferentialChecksum(&pip->ip_sum,
			     (u_short *)&alias_addr,
			     (u_short *)&pip->ip_src,
			     2);
	pip->ip_src = alias_addr;
    }

    return (0);
}


int
AliasHandlePptpGreIn(struct ip *pip)
{
    GreHdr		*gr;
    struct alias_link	*link;

    gr = (GreHdr *)((char *)pip + (pip->ip_hl << 2));

    /* Check GRE header bits. */
    if ((ntohl(*((u_int32_t *)gr)) & PPTP_INIT_MASK) != PPTP_INIT_VALUE)
	return (-1);

    link = FindPptpInByPeerCallId(pip->ip_src, pip->ip_dst, gr->gh_call_id);
    if (link != NULL) {
	struct in_addr src_addr = GetOriginalAddress(link);

	/* De-alias the Peer's Call Id. */
	gr->gh_call_id = GetOriginalPort(link);

	/* Restore original IP address. */
	DifferentialChecksum(&pip->ip_sum,
			     (u_short *)&src_addr,
			     (u_short *)&pip->ip_dst,
			     2);
	pip->ip_dst = src_addr;
    }

    return (0);
}
@


1.4
log
@Add some style(9) to alias*.h
@
text
@d38 1
a38 1
 *	$OpenBSD: alias_pptp.c,v 1.3 2000/11/02 00:53:47 brian Exp $
@


1.3
log
@Improvements for ICMP and GRE/PPTP; FreeBSD
@
text
@d38 1
a38 1
 *	$OpenBSD: alias_pptp.c,v 1.2 2000/08/13 22:05:47 brian Exp $
d73 2
@


1.2
log
@Add support for streaming media; FreeBSD
Add support for radius accounting in radlib.c (not yet working in ppp); FreeBSD
@
text
@d38 1
a38 1
 *	$OpenBSD: alias_pptp.c,v 1.1 2000/06/23 09:47:05 brian Exp $
a67 3
#include <ctype.h>
#include <stdio.h>
#include <string.h>
d82 4
a85 12
    u_char    gh_recursion:3,	/* Recursion control. */
              gh_ssr_flag:1,	/* Strict source route present. */
              gh_seq_no_flag:1,	/* Sequence number present. */
              gh_key_flag:1,	/* Key present. */
              gh_rt_flag:1,	/* Routing present. */
              gh_cksum_flag:1;	/* Checksum present. */
    u_char    gh_version:3,	/* GRE version. */
              gh_flags:4,	/* Flags. */
              gh_ack_no_flag:1;	/* Acknowledgment sequence number present. */
    u_short   gh_protocol;	/* Protocol type. */
    u_short   gh_length;	/* Payload length. */
    u_short   gh_call_id;	/* Call ID. */
d89 1
d116 1
a116 1
  PPTP_SetLinkInfo = 15,
d129 6
a142 23
int
PptpGetCallID(struct ip *pip,
              u_short *call_id)
{
    struct grehdr *gr;

    gr = (struct grehdr *)((char *)pip + (pip->ip_hl << 2));

    /* Check GRE header bits. */
    if ((ntohl(*((u_int32_t *)gr)) & PPTP_INIT_MASK) == PPTP_INIT_VALUE) {
	*call_id = gr->gh_call_id;
	return 1;
    } else
	return 0;
};

void PptpSetCallID(struct ip *pip, u_short call_id)
{
    struct grehdr *gr;

    gr = (struct grehdr *)((char *)pip + (pip->ip_hl << 2));
    gr->gh_call_id = call_id;
};
d150 1
d164 4
d170 8
a177 4

      /* Establish PPTP link for address and Call ID found in PPTP Control Msg */
      pptp_link = FindPptpOut(GetOriginalAddress(link), GetDestAddress(link),
                              cptr->cid1);
d189 15
a204 4
      break;
    default:
      return;
    }
d233 7
d245 3
a247 2
    pptp_link = FindPptpIn(GetDestAddress(link), GetAliasAddress(link),
                           *pcall_id);
d252 1
a252 1
      /* alias the Call Id */
d259 10
d272 1
a272 1
PptpCallId
d299 6
d306 60
a365 1
      return((PptpCallId)(((char *)hptr) + sizeof(struct pptpMsgHead)));
@


1.1
log
@Improved 227, 229 and EPRT support in the nat code; FreeBSD
Moved security checks into one place; FreeBSD
Remove ``nat pptp'' now that it's transparent
@
text
@d38 1
a38 1
 *	$OpenBSD$
d48 2
a49 2
   For Call IDs encountered for the first time, a GRE alias link is created.
   The GRE alias link uses the Call ID in place of the original port number.
d117 1
a117 1
  PPTP_statoReply = 6,
d175 1
a175 1
    struct alias_link   *gre_link;
d185 7
a191 2
    if ((ctl_type >= PPTP_OutCallRequest) &&
       (ctl_type <= PPTP_CallDiscNotify)) {
d193 6
a198 3
      /* Establish GRE link for address and Call ID found in PPTP Control Msg */
      gre_link = FindPptpOut(GetOriginalAddress(link), GetDestAddress(link),
                             cptr->cid1);
a199 1
      if (gre_link != NULL) {
d201 1
a201 1
	cptr->cid1 = GetAliasPort(gre_link);
d205 2
a206 2
	tc->th_sum = 0;
	tc->th_sum = TcpChecksum(pip);
d208 3
d218 1
a218 1
    struct alias_link   *gre_link;
a241 1
      break;
d244 6
a249 3
    /* Find GRE link for address and Call ID found in PPTP Control Msg */
    gre_link = FindPptpIn(GetDestAddress(link), GetAliasAddress(link),
	                  *pcall_id);
a250 1
    if (gre_link != NULL) {
d252 1
a252 1
      *pcall_id = GetOriginalPort(gre_link);
d256 2
a257 2
      tc->th_sum = 0;
      tc->th_sum = TcpChecksum(pip);
@

