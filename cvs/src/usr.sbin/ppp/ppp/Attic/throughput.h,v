head	1.8;
access;
symbols
	OPENBSD_5_5:1.7.0.58
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.54
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.52
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.50
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.48
	OPENBSD_5_0:1.7.0.46
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.44
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.42
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.38
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.40
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.36
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.34
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.32
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.30
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.28
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.26
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.24
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.22
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.20
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.18
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.16
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.14
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.12
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.10
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.8
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.03.17.17.15.52;	author deraadt;	state dead;
branches;
next	1.7;

1.7
date	2000.08.28.22.44.42;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.15.10.26.39;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.27.01.38.29;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.08.05.10.32.14;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.05.08.11.06.40;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.49;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.29;	author brian;	state Exp;
branches;
next	;


desc
@@


1.8
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1997 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: throughput.h,v 1.7 2000/08/28 22:44:42 brian Exp $
 */

#define SAMPLE_PERIOD 5		/* Default sample period */

#define THROUGHPUT_OVERALL 0x0001
#define THROUGHPUT_CURRENT 0x0002
#define THROUGHPUT_PEAK    0x0004
#define THROUGHPUT_ALL     0x0007

struct pppThroughput {
  time_t uptime, downtime;
  unsigned long long OctetsIn;
  unsigned long long OctetsOut;
  unsigned long long PacketsIn;
  unsigned long long PacketsOut;
  int SamplePeriod;
  struct {
    unsigned long long *SampleOctets;
    unsigned long long OctetsPerSecond;
  } in, out;
  unsigned long long BestOctetsPerSecond;
  time_t BestOctetsPerSecondTime;
  int nSample;
  unsigned rolling : 1;
  struct pppTimer Timer;
  struct {
    void *data;
    void (*fn)(void *v);
  } callback;
};

extern void throughput_init(struct pppThroughput *, int);
extern void throughput_destroy(struct pppThroughput *);
extern void throughput_disp(struct pppThroughput *, struct prompt *);
extern void throughput_log(struct pppThroughput *, int, const char *);
extern void throughput_start(struct pppThroughput *, const char *, int);
extern void throughput_restart(struct pppThroughput *, const char *, int);
extern void throughput_stop(struct pppThroughput *);
extern void throughput_addin(struct pppThroughput *, long long);
extern void throughput_addout(struct pppThroughput *, long long);
extern void throughput_clear(struct pppThroughput *, int, struct prompt *);
extern void throughput_callback(struct pppThroughput *, void (*)(void *),
                                void *);
extern int throughput_uptime(struct pppThroughput *);
@


1.7
log
@Support radius accounting, and add a packet count to throughput
statistics as a side effect.

Submitted by: Marcin Cieslak <saper@@system.pl>

with some tweaks to RAD_ACCT_SESSION_ID and
RAD_ACCT_MULTI_SESSION_ID generation by me.
@
text
@d26 1
a26 1
 *	$OpenBSD: throughput.h,v 1.6 2000/08/15 10:26:39 brian Exp $
@


1.6
log
@Maintain input and output throughput averages and choose the highest
of the two when calculating the MP throughput average for the ``set
autoload'' implementation.

This makes more sense as all links I know of are full-duplex.  This
also means that people may need to adjust their autoload settings
as 100% bandwidth is now the theoretical maximum rather than 200%
(but of course, halfing the current settings is probably not the
correct answer either!).

This involves a ppp version bump as we need to pass an extra
throughput array through the MP local domain socket.
@
text
@d26 1
a26 1
 *	$OpenBSD: throughput.h,v 1.5 2000/02/27 01:38:29 brian Exp $
d40 2
@


1.5
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: throughput.h,v 1.4 1999/08/05 10:32:14 brian Exp $
d41 4
a44 2
  unsigned long long *SampleOctets;
  unsigned long long OctetsPerSecond;
@


1.4
log
@o Obsolete the undocumented ``set weight'' command.
o If we're using RADIUS and the RADIUS mtu is less than our
  peers mru/mrru, reduce our mtu to this value for NetBSD too.
o Make struct throughput's sample period dynamic and tweak the ppp
  version number to reflect the extra stuff being passed through
  the local domain socket as a result (MP mode).
o Measure the current throughput based on the number of samples actually
  taken rather than on the full sample period.
o Keep the throughput statisics persistent while being passed to
  another ppp invocation through the local domain socket.
o When showing throughput statistics after the timer has stopped, use
  the stopped time for overall calculations, not the current time.
  Also show the stopped time and how long the current throughput has
  been sampled for.
o Use time() consistently in throughput.c
o Tighten up the ``show bundle'' output.
o Introduce the ``set bandwidth'' command.
o Rewrite the ``set autoload'' command.  It now takes three arguments
  and works based on a rolling bundle throughput average compared against
  the theoretical bundle bandwidth over a given period (read: it's now
  functional).
@
text
@d26 1
a26 1
 *	$Id: throughput.h,v 1.3 1999/05/08 11:06:40 brian Exp $
@


1.3
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: throughput.h,v 1.2 1999/02/06 03:22:49 brian Exp $
d29 1
a29 1
#define SAMPLE_PERIOD 5
d34 1
a34 2
#define THROUGHPUT_ALL     THROUGHPUT_OVERALL | THROUGHPUT_CURRENT \
                           | THROUGHPUT_PEAK	
d37 1
a37 1
  time_t uptime;
d40 2
a41 1
  unsigned long long SampleOctets[SAMPLE_PERIOD];
d48 4
d54 2
a55 1
extern void throughput_init(struct pppThroughput *);
d59 1
d64 3
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: throughput.h,v 1.5 1998/06/12 20:12:26 brian Exp $
d39 5
a43 5
  u_long OctetsIn;
  u_long OctetsOut;
  u_long SampleOctets[SAMPLE_PERIOD];
  int OctetsPerSecond;
  int BestOctetsPerSecond;
d55 2
a56 2
extern void throughput_addin(struct pppThroughput *, int);
extern void throughput_addout(struct pppThroughput *, int);
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

