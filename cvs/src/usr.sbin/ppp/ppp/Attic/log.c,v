head	1.20;
access;
symbols
	OPENBSD_5_5:1.19.0.30
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.26
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.24
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.22
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.20
	OPENBSD_5_0:1.19.0.18
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.16
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.14
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.10
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.12
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.8
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.10
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2007.06.02.01.29.11;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.21.16.28.47;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.07.23.58.53;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.23.11.17.03;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.13.11.46.14;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.02.00.54.34;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.28.23.25.28;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.27.00.21.08;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.08.08.15.19.54;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.01.16.01.39;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.12.10.03.51;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.09.20.04.01;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.07.11.55.26;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.41;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.23;	author brian;	state Exp;
branches;
next	;


desc
@@


1.20
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1997 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: log.c,v 1.19 2007/06/02 01:29:11 pvalchev Exp $
 */

#include <sys/types.h>

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <termios.h>

#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "descriptor.h"
#include "prompt.h"

static const char *const LogNames[] = {
  "Async",
  "CBCP",
  "CCP",
  "Chat",
  "Command",
  "Connect",
  "Debug",
  "DNS",
  "Filter",			/* Log discarded packets */
  "HDLC",
  "ID0",
  "IPCP",
  "IPV6CP",
  "LCP",
  "LQM",
  "Phase",
  "Physical",
  "Radius",
  "Sync",
  "TCP/IP",
  "Timer",
  "Tun",
  "Warning",
  "Error",
  "Alert"
};

#define MSK(n) (1<<((n)-1))

static u_long LogMask = MSK(LogPHASE);
static u_long LogMaskLocal = MSK(LogERROR) | MSK(LogALERT) | MSK(LogWARN);
static int LogTunno = -1;
static struct prompt *promptlist;	/* Where to log local stuff */
struct prompt *log_PromptContext;
int log_PromptListChanged;

struct prompt *
log_PromptList()
{
  return promptlist;
}

void
log_RegisterPrompt(struct prompt *prompt)
{
  prompt->next = promptlist;
  promptlist = prompt;
  prompt->active = 1;
  log_DiscardAllLocal(&prompt->logmask);
}

void
log_ActivatePrompt(struct prompt *prompt)
{
  prompt->active = 1;
  LogMaskLocal |= prompt->logmask;
}

static void
LogSetMaskLocal(void)
{
  struct prompt *p;

  LogMaskLocal = MSK(LogERROR) | MSK(LogALERT) | MSK(LogWARN);
  for (p = promptlist; p; p = p->next)
    LogMaskLocal |= p->logmask;
}

void
log_DeactivatePrompt(struct prompt *prompt)
{
  if (prompt->active) {
    prompt->active = 0;
    LogSetMaskLocal();
  }
}

void
log_UnRegisterPrompt(struct prompt *prompt)
{
  if (prompt) {
    struct prompt **p;

    for (p = &promptlist; *p; p = &(*p)->next)
      if (*p == prompt) {
        *p = prompt->next;
        prompt->next = NULL;
        break;
      }
    LogSetMaskLocal();
    log_PromptListChanged++;
  }
}

void
log_DestroyPrompts(struct server *s)
{
  struct prompt *p, *pn, *pl;

  p = promptlist;
  pl = NULL;
  while (p) {
    pn = p->next;
    if (s && p->owner == s) {
      if (pl)
        pl->next = p->next;
      else
        promptlist = p->next;
      p->next = NULL;
      prompt_Destroy(p, 1);
    } else
      pl = p;
    p = pn;
  }
}

void
log_DisplayPrompts()
{
  struct prompt *p;

  for (p = promptlist; p; p = p->next)
    prompt_Required(p);
}

void
log_WritePrompts(struct datalink *dl, const char *fmt,...)
{
  va_list ap;
  struct prompt *p;

  va_start(ap, fmt);
  for (p = promptlist; p; p = p->next)
    if (prompt_IsTermMode(p, dl))
      prompt_vPrintf(p, fmt, ap);
  va_end(ap);
}

void
log_SetTtyCommandMode(struct datalink *dl)
{
  struct prompt *p;

  for (p = promptlist; p; p = p->next)
    if (prompt_IsTermMode(p, dl))
      prompt_TtyCommandMode(p);
}

static int
syslogLevel(int lev)
{
  switch (lev) {
  case LogLOG:
    return LOG_INFO;
  case LogDEBUG:
  case LogTIMER:
    return LOG_DEBUG;
  case LogWARN:
    return LOG_WARNING;
  case LogERROR:
    return LOG_ERR;
  case LogALERT:
    return LOG_ALERT;
  }
  return lev >= LogMIN && lev <= LogMAX ? LOG_INFO : 0;
}

const char *
log_Name(int id)
{
  if (id == LogLOG)
    return "LOG";
  return id < LogMIN || id > LogMAX ? "Unknown" : LogNames[id - 1];
}

void
log_Keep(int id)
{
  if (id >= LogMIN && id <= LogMAXCONF)
    LogMask |= MSK(id);
}

void
log_KeepLocal(int id, u_long *mask)
{
  if (id >= LogMIN && id <= LogMAXCONF) {
    LogMaskLocal |= MSK(id);
    *mask |= MSK(id);
  }
}

void
log_Discard(int id)
{
  if (id >= LogMIN && id <= LogMAXCONF)
    LogMask &= ~MSK(id);
}

void
log_DiscardLocal(int id, u_long *mask)
{
  if (id >= LogMIN && id <= LogMAXCONF) {
    *mask &= ~MSK(id);
    LogSetMaskLocal();
  }
}

void
log_DiscardAll()
{
  LogMask = 0;
}

void
log_DiscardAllLocal(u_long *mask)
{
  *mask = MSK(LogERROR) | MSK(LogALERT) | MSK(LogWARN);
  LogSetMaskLocal();
}

int
log_IsKept(int id)
{
  if (id == LogLOG)
    return LOG_KEPT_SYSLOG;
  if (id < LogMIN || id > LogMAX)
    return 0;
  if (id > LogMAXCONF)
    return LOG_KEPT_LOCAL | LOG_KEPT_SYSLOG;

  return ((LogMaskLocal & MSK(id)) ? LOG_KEPT_LOCAL : 0) |
    ((LogMask & MSK(id)) ? LOG_KEPT_SYSLOG : 0);
}

int
log_IsKeptLocal(int id, u_long mask)
{
  if (id < LogMIN || id > LogMAX)
    return 0;
  if (id > LogMAXCONF)
    return LOG_KEPT_LOCAL | LOG_KEPT_SYSLOG;

  return ((mask & MSK(id)) ? LOG_KEPT_LOCAL : 0) |
    ((LogMask & MSK(id)) ? LOG_KEPT_SYSLOG : 0);
}

void
log_Open(const char *Name)
{
  openlog(Name, LOG_PID, LOG_DAEMON);
}

void
log_SetTun(int tunno)
{
  LogTunno = tunno;
}

void
log_Close()
{
  closelog();
  LogTunno = -1;
}

void
log_Printf(int lev, const char *fmt,...)
{
  va_list ap;
  struct prompt *prompt;

  if (log_IsKept(lev)) {
    char nfmt[200];

    va_start(ap, fmt);
    if (promptlist && (log_IsKept(lev) & LOG_KEPT_LOCAL)) {
      if ((log_IsKept(LogTUN) & LOG_KEPT_LOCAL) && LogTunno != -1)
        snprintf(nfmt, sizeof nfmt, "%s%d: %s: %s", TUN_NAME,
	         LogTunno, log_Name(lev), fmt);
      else
        snprintf(nfmt, sizeof nfmt, "%s: %s", log_Name(lev), fmt);

      if (log_PromptContext && lev == LogWARN)
        /* Warnings just go to the current prompt */
        prompt_vPrintf(log_PromptContext, nfmt, ap);
      else for (prompt = promptlist; prompt; prompt = prompt->next)
        if (lev > LogMAXCONF || (prompt->logmask & MSK(lev)))
          prompt_vPrintf(prompt, nfmt, ap);
    }
    va_end(ap);

    va_start(ap, fmt);
    if ((log_IsKept(lev) & LOG_KEPT_SYSLOG) &&
        (lev != LogWARN || !log_PromptContext)) {
      if ((log_IsKept(LogTUN) & LOG_KEPT_SYSLOG) && LogTunno != -1)
        snprintf(nfmt, sizeof nfmt, "%s%d: %s: %s", TUN_NAME,
	         LogTunno, log_Name(lev), fmt);
      else
        snprintf(nfmt, sizeof nfmt, "%s: %s", log_Name(lev), fmt);
      vsyslog(syslogLevel(lev), nfmt, ap);
    }
    va_end(ap);
  }
}

void
log_DumpBp(int lev, const char *hdr, const struct mbuf *bp)
{
  if (log_IsKept(lev)) {
    char buf[68];
    char *b, *c;
    const u_char *ptr;
    int f;

    if (hdr && *hdr)
      log_Printf(lev, "%s\n", hdr);

    b = buf;
    c = b + 50;
    do {
      f = bp->m_len;
      ptr = CONST_MBUF_CTOP(bp);
      while (f--) {
	snprintf(b, buf + sizeof buf - b, " %02x", (int) *ptr);
        *c++ = isprint(*ptr) ? *ptr : '.';
        ptr++;
        b += strlen(b);
        if (b == buf + 48) {
          memset(b, ' ', 2);
          *c = '\0';
          log_Printf(lev, "%s\n", buf);
          b = buf;
          c = b + 50;
        }
      }
    } while ((bp = bp->m_next) != NULL);

    if (b > buf) {
      memset(b, ' ', 50 - (b - buf));
      *c = '\0';
      log_Printf(lev, "%s\n", buf);
    }
  }
}

void
log_DumpBuff(int lev, const char *hdr, const u_char *ptr, int n)
{
  if (log_IsKept(lev)) {
    char buf[68];
    char *b, *c;

    if (hdr && *hdr)
      log_Printf(lev, "%s\n", hdr);
    while (n > 0) {
      b = buf;
      c = b + 50;
      for (b = buf; b != buf + 48 && n--; b += 3, ptr++) {
	snprintf(b, buf + sizeof buf - b, " %02x", (int) *ptr);
        *c++ = isprint(*ptr) ? *ptr : '.';
      }
      memset(b, ' ', 50 - (b - buf));
      *c = '\0';
      log_Printf(lev, "%s\n", buf);
    }
  }
}

int
log_ShowLevel(struct cmdargs const *arg)
{
  int i;

  prompt_Printf(arg->prompt, "Log:  ");
  for (i = LogMIN; i <= LogMAX; i++)
    if (log_IsKept(i) & LOG_KEPT_SYSLOG)
      prompt_Printf(arg->prompt, " %s", log_Name(i));

  prompt_Printf(arg->prompt, "\nLocal:");
  for (i = LogMIN; i <= LogMAX; i++)
    if (log_IsKeptLocal(i, arg->prompt->logmask) & LOG_KEPT_LOCAL)
      prompt_Printf(arg->prompt, " %s", log_Name(i));

  prompt_Printf(arg->prompt, "\n");

  return 0;
}

int
log_SetLevel(struct cmdargs const *arg)
{
  int i, res, argc, local;
  char const *const *argv, *argp;

  argc = arg->argc - arg->argn;
  argv = arg->argv + arg->argn;
  res = 0;

  if (argc == 0 || strcasecmp(argv[0], "local"))
    local = 0;
  else {
    if (arg->prompt == NULL) {
      log_Printf(LogWARN, "set log local: Only available on the"
                 " command line\n");
      return 1;
    }
    argc--;
    argv++;
    local = 1;
  }

  if (argc == 0 || (argv[0][0] != '+' && argv[0][0] != '-')) {
    if (local)
      log_DiscardAllLocal(&arg->prompt->logmask);
    else
      log_DiscardAll();
  }

  while (argc--) {
    argp = **argv == '+' || **argv == '-' ? *argv + 1 : *argv;
    /* Special case 'all' */
    if (strcasecmp(argp, "all") == 0) {
        if (**argv == '-') {
          if (local)
            for (i = LogMIN; i <= LogMAX; i++)
              log_DiscardLocal(i, &arg->prompt->logmask);
          else
            for (i = LogMIN; i <= LogMAX; i++)
              log_Discard(i);
        } else if (local)
          for (i = LogMIN; i <= LogMAX; i++)
            log_KeepLocal(i, &arg->prompt->logmask);
        else
          for (i = LogMIN; i <= LogMAX; i++)
            log_Keep(i);
        argv++;
        continue;
    }
    for (i = LogMIN; i <= LogMAX; i++)
      if (strcasecmp(argp, log_Name(i)) == 0) {
	if (**argv == '-') {
          if (local)
            log_DiscardLocal(i, &arg->prompt->logmask);
          else
	    log_Discard(i);
	} else if (local)
          log_KeepLocal(i, &arg->prompt->logmask);
        else
          log_Keep(i);
	break;
      }
    if (i > LogMAX) {
      log_Printf(LogWARN, "%s: Invalid log value\n", argp);
      res = -1;
    }
    argv++;
  }
  return res;
}

int
log_ShowWho(struct cmdargs const *arg)
{
  struct prompt *p;

  for (p = promptlist; p; p = p->next) {
    prompt_Printf(arg->prompt, "%s (%s)", p->src.type, p->src.from);
    if (p == arg->prompt)
      prompt_Printf(arg->prompt, " *");
    if (!p->active)
      prompt_Printf(arg->prompt, " ^Z");
    prompt_Printf(arg->prompt, "\n");
  }

  return 0;
}
@


1.19
log
@safer snprintf construct with more paranoid length calculation
ok millert
@
text
@d26 1
a26 1
 *	$OpenBSD: log.c,v 1.18 2005/09/21 16:28:47 brad Exp $
@


1.18
log
@Support a ``set rad_alive N'' command to enable periodic RADIUS accounting
information being sent to the RADIUS server.

Logging of RADIUS accounting information moves to a ``set log [+-]radius''
level, along with the RADIUS alive info.

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: log.c,v 1.17 2003/04/07 23:58:53 deraadt Exp $
d372 1
a372 1
        b += 3;
@


1.17
log
@more string cleaning; ok tedu
@
text
@d26 1
a26 1
 *	$OpenBSD: log.c,v 1.16 2002/06/15 08:02:00 brian Exp $
d63 1
@


1.16
log
@Tidy up end of line whitespace
@
text
@d26 1
a26 1
 *	$OpenBSD: log.c,v 1.15 2001/11/23 11:17:03 brian Exp $
d368 1
a368 1
	sprintf(b, " %02x", (int) *ptr);
d403 1
a403 1
	sprintf(b, " %02x", (int) *ptr);
@


1.15
log
@cmott@@scientech.com -> cm@@linktel.net
Add the UPTIME variable
CCP protocol ``0xffffffff'' -> ``none''
Don't leak memory when expanding command arguments and not exec()ing
Make some functions static
Add the ``log'' command for manual logging
Fix some log text bogons
@
text
@d26 1
a26 1
 *	$OpenBSD: log.c,v 1.14 2001/08/19 23:22:18 brian Exp $
d326 1
a326 1
  
@


1.14
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *	$OpenBSD: log.c,v 1.13 2001/06/13 11:46:14 markus Exp $
d197 2
d215 2
d268 2
@


1.13
log
@va_start/end for every call to vfprintf, ok brian@@
@
text
@d26 1
a26 1
 *	$OpenBSD: log.c,v 1.12 2000/11/02 00:54:34 brian Exp $
d45 1
a45 1
static const char * const LogNames[] = {
d58 1
@


1.12
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d26 1
a26 1
 *	$OpenBSD: log.c,v 1.11 2000/08/28 23:25:28 brian Exp $
a308 1
  va_start(ap, fmt);
d312 1
d327 1
d329 1
d339 1
a340 1
  va_end(ap);
@


1.11
log
@Add LogFILTER logging to log packets allowed by the dial filter and
dropped by any filter.

Submitted by: Mark Hannon <markhannon@@one.net.au>

with some small tweaks by me.
@
text
@d26 1
a26 1
 *	$OpenBSD: log.c,v 1.10 2000/02/27 01:38:27 brian Exp $
d438 2
a439 1
      log_Printf(LogWARN, "set log local: Only available on the command line\n");
d456 18
@


1.10
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: log.c,v 1.9 2000/02/27 00:21:08 brian Exp $
d54 1
@


1.9
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.8 2000/01/07 03:26:54 brian Exp $
@


1.8
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.7 1999/08/08 15:19:54 brian Exp $
d53 1
@


1.7
log
@Don't log_Printf(..., buf) in case buf contains %s

Info provided by: Ollivier Robert <roberto@@keltia.freenix.fr>
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.6 1999/06/01 16:01:39 brian Exp $
d45 1
a45 1
static const char *LogNames[] = {
d75 1
d311 1
a311 1
    if ((log_IsKept(lev) & LOG_KEPT_LOCAL) && promptlist) {
d318 4
a321 1
      for (prompt = promptlist; prompt; prompt = prompt->next)
d327 1
a327 1
        (lev != LogWARN || !promptlist)) {
d354 1
a354 1
      f = bp->cnt;
d369 1
a369 1
    } while ((bp = bp->next) != NULL);
@


1.6
log
@Make async/sync/physical/hdlc dumps prettier by showing printable
characters at the end of the line in hexdump style.
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.5 1999/05/12 10:03:51 brian Exp $
d359 2
a360 2
          strcpy(c, "\n");
          log_Printf(lev, buf);
d369 2
a370 2
      strcpy(c, "\n");
      log_Printf(lev, buf);
d392 2
a393 2
      strcpy(c, "\n");
      log_Printf(lev, buf);
@


1.5
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.4 1999/05/09 20:04:01 brian Exp $
d31 1
d339 2
a340 2
    char buf[50];
    char *b;
d348 1
d353 3
a355 1
	sprintf(b, " %02x", (int) *ptr++);
d357 3
a359 2
        if (b == buf + sizeof buf - 2) {
          strcpy(b, "\n");
d362 1
d368 2
a369 1
      strcpy(b, "\n");
d379 2
a380 2
    char buf[50];
    char *b;
d386 7
a392 3
      for (b = buf; b != buf + sizeof buf - 2 && n--; b += 3)
	sprintf(b, " %02x", (int) *ptr++);
      strcpy(b, "\n");
@


1.4
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.3 1999/03/07 11:55:26 brian Exp $
d58 2
@


1.3
log
@Correctly drop existing connections when reopening the diagnostic
socket.
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.2 1999/02/06 03:22:41 brian Exp $
d367 1
a367 1
log_DumpBuff(int lev, const char *hdr, const u_char * ptr, int n)
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: log.c,v 1.35 1998/08/21 18:10:14 brian Exp $
d135 1
a135 1
  struct prompt *p, *pn;
d138 1
d141 5
a145 1
    if (s && p->owner != s) {
d148 2
a149 1
    }
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

