head	1.34;
access;
symbols
	OPENBSD_5_5:1.33.0.20
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.16
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.14
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.12
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.10
	OPENBSD_5_0:1.33.0.8
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.6
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.20
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.16
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.14
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.12
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.10
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.8
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.6
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.4
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.30.0.12
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.10
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.30.0.8
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.30.0.6
	OPENBSD_3_4_BASE:1.30
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.34
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.33;

1.33
date	2009.12.11.18.15.17;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.17.19.13.24;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.06.13.56.00;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.02.00.13.19;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.23.11.17.03;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.07.13.12.57;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.07.03.08.49;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.03.22.23.56;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.19.10.24.50;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.13.21.33.40;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.04.22.53.12;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.22.02.13.08;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.07.23.32.04;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.02.00.54.33;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.19.11.06.31;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.27.01.38.25;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.27.00.21.06;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.07.03.26.53;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.06.02.15.58.40;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.05.12.10.03.49;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.05.09.20.03.59;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.05.08.11.06.34;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.02.14.34.02;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.03.31.14.22.10;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.03.11.01.50.04;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.26.21.28.20;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.32;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.17;	author brian;	state Exp;
branches;
next	;


desc
@@


1.34
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: ccp.c,v 1.33 2009/12/11 18:15:17 oga Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>	/* memcpy() on some archs */
#include <termios.h>

#include "layer.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "proto.h"
#include "pred.h"
#include "deflate.h"
#include "throughput.h"
#include "iplist.h"
#include "slcompress.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "ccp.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "descriptor.h"
#include "prompt.h"
#include "link.h"
#include "mp.h"
#include "async.h"
#include "physical.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#ifndef NODES
#include "mppe.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"

static void CcpSendConfigReq(struct fsm *);
static void CcpSentTerminateReq(struct fsm *);
static void CcpSendTerminateAck(struct fsm *, u_char);
static void CcpDecodeConfig(struct fsm *, u_char *, u_char *, int,
                            struct fsm_decode *);
static void CcpLayerStart(struct fsm *);
static void CcpLayerFinish(struct fsm *);
static int CcpLayerUp(struct fsm *);
static void CcpLayerDown(struct fsm *);
static void CcpInitRestartCounter(struct fsm *, int);
static int CcpRecvResetReq(struct fsm *);
static void CcpRecvResetAck(struct fsm *, u_char);

static struct fsm_callbacks ccp_Callbacks = {
  CcpLayerUp,
  CcpLayerDown,
  CcpLayerStart,
  CcpLayerFinish,
  CcpInitRestartCounter,
  CcpSendConfigReq,
  CcpSentTerminateReq,
  CcpSendTerminateAck,
  CcpDecodeConfig,
  CcpRecvResetReq,
  CcpRecvResetAck
};

static const char * const ccp_TimerNames[] =
  {"CCP restart", "CCP openmode", "CCP stopped"};

static const char *
protoname(int proto)
{
  static char const * const cftypes[] = {
    /* Check out the latest ``Compression Control Protocol'' rfc (1962) */
    "OUI",		/* 0: OUI */
    "PRED1",		/* 1: Predictor type 1 */
    "PRED2",		/* 2: Predictor type 2 */
    "PUDDLE",		/* 3: Puddle Jumber */
    NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL, NULL, NULL,
    "HWPPC",		/* 16: Hewlett-Packard PPC */
    "STAC",		/* 17: Stac Electronics LZS (rfc1974) */
    "MPPE",		/* 18: Microsoft PPC (rfc2118) and */
			/*     Microsoft PPE (draft-ietf-pppext-mppe) */
    "GAND",		/* 19: Gandalf FZA (rfc1993) */
    "V42BIS",		/* 20: ARG->DATA.42bis compression */
    "BSD",		/* 21: BSD LZW Compress */
    NULL,
    "LZS-DCP",		/* 23: LZS-DCP Compression Protocol (rfc1967) */
    "MAGNALINK/DEFLATE",/* 24: Magnalink Variable Resource (rfc1975) */
			/* 24: Deflate (according to pppd-2.3.*) */
    "DCE",		/* 25: Data Circuit-Terminating Equip (rfc1976) */
    "DEFLATE",		/* 26: Deflate (rfc1979) */
  };

  if (proto < 0 || proto >= sizeof cftypes / sizeof *cftypes ||
      cftypes[proto] == NULL) {
    if (proto == -1)
      return "none";
    return HexStr(proto, NULL, 0);
  }

  return cftypes[proto];
}

/* We support these algorithms, and Req them in the given order */
static const struct ccp_algorithm * const algorithm[] = {
  &DeflateAlgorithm,
  &Pred1Algorithm,
  &PppdDeflateAlgorithm
#ifndef NODES
  , &MPPEAlgorithm
#endif
};

#define NALGORITHMS (sizeof algorithm/sizeof algorithm[0])

int
ccp_ReportStatus(struct cmdargs const *arg)
{
  struct ccp_opt **o;
  struct link *l;
  struct ccp *ccp;
  int f;

  l = command_ChooseLink(arg);
  ccp = &l->ccp;

  prompt_Printf(arg->prompt, "%s: %s [%s]\n", l->name, ccp->fsm.name,
                State2Nam(ccp->fsm.state));
  if (ccp->fsm.state == ST_OPENED) {
    prompt_Printf(arg->prompt, " My protocol = %s, His protocol = %s\n",
                  protoname(ccp->my_proto), protoname(ccp->his_proto));
    prompt_Printf(arg->prompt, " Output: %ld --> %ld,  Input: %ld --> %ld\n",
                  ccp->uncompout, ccp->compout,
                  ccp->compin, ccp->uncompin);
  }

  if (ccp->in.algorithm != -1)
    prompt_Printf(arg->prompt, "\n Input Options:  %s\n",
                  (*algorithm[ccp->in.algorithm]->Disp)(&ccp->in.opt));

  if (ccp->out.algorithm != -1) {
    o = &ccp->out.opt;
    for (f = 0; f < ccp->out.algorithm; f++)
      if (IsEnabled(ccp->cfg.neg[algorithm[f]->Neg]))
        o = &(*o)->next;
    prompt_Printf(arg->prompt, " Output Options: %s\n",
                  (*algorithm[ccp->out.algorithm]->Disp)(&(*o)->val));
  }

  prompt_Printf(arg->prompt, "\n Defaults: ");
  prompt_Printf(arg->prompt, "FSM retry = %us, max %u Config"
                " REQ%s, %u Term REQ%s\n", ccp->cfg.fsm.timeout,
                ccp->cfg.fsm.maxreq, ccp->cfg.fsm.maxreq == 1 ? "" : "s",
                ccp->cfg.fsm.maxtrm, ccp->cfg.fsm.maxtrm == 1 ? "" : "s");
  prompt_Printf(arg->prompt, "           deflate windows: ");
  prompt_Printf(arg->prompt, "incoming = %d, ", ccp->cfg.deflate.in.winsize);
  prompt_Printf(arg->prompt, "outgoing = %d\n", ccp->cfg.deflate.out.winsize);
#ifndef NODES
  prompt_Printf(arg->prompt, "           MPPE: ");
  if (ccp->cfg.mppe.keybits)
    prompt_Printf(arg->prompt, "%d bits, ", ccp->cfg.mppe.keybits);
  else
    prompt_Printf(arg->prompt, "any bits, ");
  switch (ccp->cfg.mppe.state) {
  case MPPE_STATEFUL:
    prompt_Printf(arg->prompt, "stateful");
    break;
  case MPPE_STATELESS:
    prompt_Printf(arg->prompt, "stateless");
    break;
  case MPPE_ANYSTATE:
    prompt_Printf(arg->prompt, "any state");
    break;
  }
  prompt_Printf(arg->prompt, "%s\n",
                ccp->cfg.mppe.required ? ", required" : "");
#endif

  prompt_Printf(arg->prompt, "\n           DEFLATE:    %s\n",
                command_ShowNegval(ccp->cfg.neg[CCP_NEG_DEFLATE]));
  prompt_Printf(arg->prompt, "           PREDICTOR1: %s\n",
                command_ShowNegval(ccp->cfg.neg[CCP_NEG_PRED1]));
  prompt_Printf(arg->prompt, "           DEFLATE24:  %s\n",
                command_ShowNegval(ccp->cfg.neg[CCP_NEG_DEFLATE24]));
#ifndef NODES
  prompt_Printf(arg->prompt, "           MPPE:       %s\n",
                command_ShowNegval(ccp->cfg.neg[CCP_NEG_MPPE]));
#endif
  return 0;
}

void
ccp_SetupCallbacks(struct ccp *ccp)
{
  ccp->fsm.fn = &ccp_Callbacks;
  ccp->fsm.FsmTimer.name = ccp_TimerNames[0];
  ccp->fsm.OpenTimer.name = ccp_TimerNames[1];
  ccp->fsm.StoppedTimer.name = ccp_TimerNames[2];
}

void
ccp_Init(struct ccp *ccp, struct bundle *bundle, struct link *l,
         const struct fsm_parent *parent)
{
  /* Initialise ourselves */

  fsm_Init(&ccp->fsm, "CCP", PROTO_CCP, 1, CCP_MAXCODE, LogCCP,
           bundle, l, parent, &ccp_Callbacks, ccp_TimerNames);

  ccp->cfg.deflate.in.winsize = 0;
  ccp->cfg.deflate.out.winsize = 15;
  ccp->cfg.fsm.timeout = DEF_FSMRETRY;
  ccp->cfg.fsm.maxreq = DEF_FSMTRIES;
  ccp->cfg.fsm.maxtrm = DEF_FSMTRIES;
  ccp->cfg.neg[CCP_NEG_DEFLATE] = NEG_ENABLED|NEG_ACCEPTED;
  ccp->cfg.neg[CCP_NEG_PRED1] = NEG_ENABLED|NEG_ACCEPTED;
  ccp->cfg.neg[CCP_NEG_DEFLATE24] = 0;
#ifndef NODES
  ccp->cfg.mppe.keybits = 0;
  ccp->cfg.mppe.state = MPPE_ANYSTATE;
  ccp->cfg.mppe.required = 0;
  ccp->cfg.neg[CCP_NEG_MPPE] = NEG_ENABLED|NEG_ACCEPTED;
#endif

  ccp_Setup(ccp);
}

void
ccp_Setup(struct ccp *ccp)
{
  /* Set ourselves up for a startup */
  ccp->fsm.open_mode = 0;
  ccp->his_proto = ccp->my_proto = -1;
  ccp->reset_sent = ccp->last_reset = -1;
  ccp->in.algorithm = ccp->out.algorithm = -1;
  ccp->in.state = ccp->out.state = NULL;
  ccp->in.opt.hdr.id = -1;
  ccp->out.opt = NULL;
  ccp->his_reject = ccp->my_reject = 0;
  ccp->uncompout = ccp->compout = 0;
  ccp->uncompin = ccp->compin = 0;
}

/*
 * Is ccp *REQUIRED* ?
 * We ask each of the configured ccp protocols if they're required and
 * return TRUE if they are.
 *
 * It's not possible for the peer to reject a required ccp protocol
 * without our state machine bringing the supporting lcp layer down.
 *
 * If ccp is required but not open, the NCP layer should not push
 * any data into the link.
 */
int
ccp_Required(struct ccp *ccp)
{
  int f;

  for (f = 0; f < NALGORITHMS; f++)
    if (IsEnabled(ccp->cfg.neg[algorithm[f]->Neg]) &&
        (*algorithm[f]->Required)(&ccp->fsm))
      return 1;

  return 0;
}

/*
 * Report whether it's possible to increase a packet's size after
 * compression (and by how much).
 */
int
ccp_MTUOverhead(struct ccp *ccp)
{
  if (ccp->fsm.state == ST_OPENED && ccp->out.algorithm >= 0)
    return algorithm[ccp->out.algorithm]->o.MTUOverhead;

  return 0;
}

static void
CcpInitRestartCounter(struct fsm *fp, int what)
{
  /* Set fsm timer load */
  struct ccp *ccp = fsm2ccp(fp);

  fp->FsmTimer.load = ccp->cfg.fsm.timeout * SECTICKS;
  switch (what) {
    case FSM_REQ_TIMER:
      fp->restart = ccp->cfg.fsm.maxreq;
      break;
    case FSM_TRM_TIMER:
      fp->restart = ccp->cfg.fsm.maxtrm;
      break;
    default:
      fp->restart = 1;
      break;
  }
}

static void
CcpSendConfigReq(struct fsm *fp)
{
  /* Send config REQ please */
  struct ccp *ccp = fsm2ccp(fp);
  struct ccp_opt **o;
  u_char *cp, buff[100];
  int f, alloc;

  cp = buff;
  o = &ccp->out.opt;
  alloc = ccp->his_reject == 0 && ccp->out.opt == NULL;
  ccp->my_proto = -1;
  ccp->out.algorithm = -1;
  for (f = 0; f < NALGORITHMS; f++)
    if (IsEnabled(ccp->cfg.neg[algorithm[f]->Neg]) &&
        !REJECTED(ccp, algorithm[f]->id) &&
        (*algorithm[f]->Usable)(fp)) {

      if (!alloc)
        for (o = &ccp->out.opt; *o != NULL; o = &(*o)->next)
          if ((*o)->val.hdr.id == algorithm[f]->id && (*o)->algorithm == f)
            break;

      if (alloc || *o == NULL) {
        if ((*o = (struct ccp_opt *)malloc(sizeof(struct ccp_opt))) == NULL) {
	  log_Printf(LogERROR, "%s: Not enough memory for CCP REQ !\n",
		     fp->link->name);
	  break;
	}
        (*o)->val.hdr.id = algorithm[f]->id;
        (*o)->val.hdr.len = 2;
        (*o)->next = NULL;
        (*o)->algorithm = f;
        (*algorithm[f]->o.OptInit)(fp->bundle, &(*o)->val, &ccp->cfg);
      }

      if (cp + (*o)->val.hdr.len > buff + sizeof buff) {
        log_Printf(LogERROR, "%s: CCP REQ buffer overrun !\n", fp->link->name);
        break;
      }
      memcpy(cp, &(*o)->val, (*o)->val.hdr.len);
      cp += (*o)->val.hdr.len;

      ccp->my_proto = (*o)->val.hdr.id;
      ccp->out.algorithm = f;

      if (alloc)
        o = &(*o)->next;
    }

  fsm_Output(fp, CODE_CONFIGREQ, fp->reqid, buff, cp - buff, MB_CCPOUT);
}

void
ccp_SendResetReq(struct fsm *fp)
{
  /* We can't read our input - ask peer to reset */
  struct ccp *ccp = fsm2ccp(fp);

  ccp->reset_sent = fp->reqid;
  ccp->last_reset = -1;
  fsm_Output(fp, CODE_RESETREQ, fp->reqid, NULL, 0, MB_CCPOUT);
}

static void
CcpSentTerminateReq(struct fsm *fp)
{
  /* Term REQ just sent by FSM */
}

static void
CcpSendTerminateAck(struct fsm *fp, u_char id)
{
  /* Send Term ACK please */
  fsm_Output(fp, CODE_TERMACK, id, NULL, 0, MB_CCPOUT);
}

static int
CcpRecvResetReq(struct fsm *fp)
{
  /* Got a reset REQ, reset outgoing dictionary */
  struct ccp *ccp = fsm2ccp(fp);
  if (ccp->out.state == NULL)
    return 1;
  return (*algorithm[ccp->out.algorithm]->o.Reset)(ccp->out.state);
}

static void
CcpLayerStart(struct fsm *fp)
{
  /* We're about to start up ! */
  struct ccp *ccp = fsm2ccp(fp);

  log_Printf(LogCCP, "%s: LayerStart.\n", fp->link->name);
  fp->more.reqs = fp->more.naks = fp->more.rejs = ccp->cfg.fsm.maxreq * 3;
}

static void
CcpLayerDown(struct fsm *fp)
{
  /* About to come down */
  struct ccp *ccp = fsm2ccp(fp);
  struct ccp_opt *next;

  log_Printf(LogCCP, "%s: LayerDown.\n", fp->link->name);
  if (ccp->in.state != NULL) {
    (*algorithm[ccp->in.algorithm]->i.Term)(ccp->in.state);
    ccp->in.state = NULL;
    ccp->in.algorithm = -1;
  }
  if (ccp->out.state != NULL) {
    (*algorithm[ccp->out.algorithm]->o.Term)(ccp->out.state);
    ccp->out.state = NULL;
    ccp->out.algorithm = -1;
  }
  ccp->his_reject = ccp->my_reject = 0;

  while (ccp->out.opt) {
    next = ccp->out.opt->next;
    free(ccp->out.opt);
    ccp->out.opt = next;
  }
  ccp_Setup(ccp);
}

static void
CcpLayerFinish(struct fsm *fp)
{
  /* We're now down */
  struct ccp *ccp = fsm2ccp(fp);
  struct ccp_opt *next;

  log_Printf(LogCCP, "%s: LayerFinish.\n", fp->link->name);

  /*
   * Nuke options that may be left over from sending a REQ but never
   * coming up.
   */
  while (ccp->out.opt) {
    next = ccp->out.opt->next;
    free(ccp->out.opt);
    ccp->out.opt = next;
  }

  if (ccp_Required(ccp)) {
    if (fp->link->lcp.fsm.state == ST_OPENED)
      log_Printf(LogLCP, "%s: Closing due to CCP completion\n", fp->link->name);
    fsm_Close(&fp->link->lcp.fsm);
  }
}

/*  Called when CCP has reached the OPEN state */
static int
CcpLayerUp(struct fsm *fp)
{
  /* We're now up */
  struct ccp *ccp = fsm2ccp(fp);
  struct ccp_opt **o;
  int f, fail;

  for (f = fail = 0; f < NALGORITHMS; f++)
    if (IsEnabled(ccp->cfg.neg[algorithm[f]->Neg]) &&
        (*algorithm[f]->Required)(&ccp->fsm) &&
        (ccp->in.algorithm != f || ccp->out.algorithm != f)) {
      /* Blow it all away - we haven't negotiated a required algorithm */
      log_Printf(LogWARN, "%s: Failed to negotiate (required) %s\n",
                 fp->link->name, protoname(algorithm[f]->id));
      fail = 1;
    }

  if (fail) {
    ccp->his_proto = ccp->my_proto = -1;
    fsm_Close(fp);
    fsm_Close(&fp->link->lcp.fsm);
    return 0;
  }

  log_Printf(LogCCP, "%s: LayerUp.\n", fp->link->name);

  if (ccp->in.state == NULL && ccp->in.algorithm >= 0 &&
      ccp->in.algorithm < NALGORITHMS) {
    ccp->in.state = (*algorithm[ccp->in.algorithm]->i.Init)
      (fp->bundle, &ccp->in.opt);
    if (ccp->in.state == NULL) {
      log_Printf(LogERROR, "%s: %s (in) initialisation failure\n",
                fp->link->name, protoname(ccp->his_proto));
      ccp->his_proto = ccp->my_proto = -1;
      fsm_Close(fp);
      return 0;
    }
  }

  o = &ccp->out.opt;
  for (f = 0; f < ccp->out.algorithm; f++)
    if (IsEnabled(ccp->cfg.neg[algorithm[f]->Neg]))
      o = &(*o)->next;

  if (ccp->out.state == NULL && ccp->out.algorithm >= 0 &&
      ccp->out.algorithm < NALGORITHMS) {
    ccp->out.state = (*algorithm[ccp->out.algorithm]->o.Init)
      (fp->bundle, &(*o)->val);
    if (ccp->out.state == NULL) {
      log_Printf(LogERROR, "%s: %s (out) initialisation failure\n",
                fp->link->name, protoname(ccp->my_proto));
      ccp->his_proto = ccp->my_proto = -1;
      fsm_Close(fp);
      return 0;
    }
  }

  fp->more.reqs = fp->more.naks = fp->more.rejs = ccp->cfg.fsm.maxreq * 3;

  log_Printf(LogCCP, "%s: Out = %s[%d], In = %s[%d]\n",
            fp->link->name, protoname(ccp->my_proto), ccp->my_proto,
            protoname(ccp->his_proto), ccp->his_proto);

  return 1;
}

static void
CcpDecodeConfig(struct fsm *fp, u_char *cp, u_char *end, int mode_type,
                struct fsm_decode *dec)
{
  /* Deal with incoming data */
  struct ccp *ccp = fsm2ccp(fp);
  int f;
  const char *disp;
  struct fsm_opt *opt;

  if (mode_type == MODE_REQ)
    ccp->in.algorithm = -1;	/* In case we've received two REQs in a row */

  while (end - cp >= sizeof(opt->hdr)) {
    if ((opt = fsm_readopt(&cp)) == NULL)
      break;

    for (f = NALGORITHMS-1; f > -1; f--)
      if (algorithm[f]->id == opt->hdr.id)
        break;

    disp = f == -1 ? "" : (*algorithm[f]->Disp)(opt);
    if (disp == NULL)
      disp = "";

    log_Printf(LogCCP, " %s[%d] %s\n", protoname(opt->hdr.id),
               opt->hdr.len, disp);

    if (f == -1) {
      /* Don't understand that :-( */
      if (mode_type == MODE_REQ) {
        ccp->my_reject |= (1 << opt->hdr.id);
        fsm_rej(dec, opt);
      }
    } else {
      struct ccp_opt *o;

      switch (mode_type) {
      case MODE_REQ:
        if (IsAccepted(ccp->cfg.neg[algorithm[f]->Neg]) &&
            (*algorithm[f]->Usable)(fp) &&
            ccp->in.algorithm == -1) {
          memcpy(&ccp->in.opt, opt, opt->hdr.len);
          switch ((*algorithm[f]->i.Set)(fp->bundle, &ccp->in.opt, &ccp->cfg)) {
          case MODE_REJ:
            fsm_rej(dec, &ccp->in.opt);
            break;
          case MODE_NAK:
            fsm_nak(dec, &ccp->in.opt);
            break;
          case MODE_ACK:
            fsm_ack(dec, &ccp->in.opt);
            ccp->his_proto = opt->hdr.id;
            ccp->in.algorithm = f;		/* This one'll do :-) */
            break;
          }
        } else {
          fsm_rej(dec, opt);
        }
        break;
      case MODE_NAK:
        for (o = ccp->out.opt; o != NULL; o = o->next)
          if (o->val.hdr.id == opt->hdr.id)
            break;
        if (o == NULL)
          log_Printf(LogCCP, "%s: Warning: Ignoring peer NAK of unsent"
                     " option\n", fp->link->name);
        else {
          memcpy(&o->val, opt, opt->hdr.len);
          if ((*algorithm[f]->o.Set)(fp->bundle, &o->val, &ccp->cfg) ==
              MODE_ACK)
            ccp->my_proto = algorithm[f]->id;
          else {
            ccp->his_reject |= (1 << opt->hdr.id);
            ccp->my_proto = -1;
            if (algorithm[f]->Required(fp)) {
              log_Printf(LogWARN, "%s: Cannot understand peers (required)"
                         " %s negotiation\n", fp->link->name,
                         protoname(algorithm[f]->id));
              fsm_Close(&fp->link->lcp.fsm);
            }
          }
        }
        break;
      case MODE_REJ:
        ccp->his_reject |= (1 << opt->hdr.id);
        ccp->my_proto = -1;
        if (algorithm[f]->Required(fp)) {
          log_Printf(LogWARN, "%s: Peer rejected (required) %s negotiation\n",
                     fp->link->name, protoname(algorithm[f]->id));
          fsm_Close(&fp->link->lcp.fsm);
        }
        break;
      }
    }
  }

  if (mode_type != MODE_NOP) {
    fsm_opt_normalise(dec);
    if (dec->rejend != dec->rej || dec->nakend != dec->nak) {
      if (ccp->in.state == NULL) {
        ccp->his_proto = -1;
        ccp->in.algorithm = -1;
      }
    }
  }
}

extern struct mbuf *
ccp_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
{
  /* Got PROTO_CCP from link */
  m_settype(bp, MB_CCPIN);
  if (bundle_Phase(bundle) == PHASE_NETWORK)
    fsm_Input(&l->ccp.fsm, bp);
  else {
    if (bundle_Phase(bundle) < PHASE_NETWORK)
      log_Printf(LogCCP, "%s: Error: Unexpected CCP in phase %s (ignored)\n",
                 l->ccp.fsm.link->name, bundle_PhaseName(bundle));
    m_freem(bp);
  }
  return NULL;
}

static void
CcpRecvResetAck(struct fsm *fp, u_char id)
{
  /* Got a reset ACK, reset incoming dictionary */
  struct ccp *ccp = fsm2ccp(fp);

  if (ccp->reset_sent != -1) {
    if (id != ccp->reset_sent) {
      log_Printf(LogCCP, "%s: Incorrect ResetAck (id %d, not %d)"
                " ignored\n", fp->link->name, id, ccp->reset_sent);
      return;
    }
    /* Whaddaya know - a correct reset ack */
  } else if (id == ccp->last_reset)
    log_Printf(LogCCP, "%s: Duplicate ResetAck (resetting again)\n",
               fp->link->name);
  else {
    log_Printf(LogCCP, "%s: Unexpected ResetAck (id %d) ignored\n",
               fp->link->name, id);
    return;
  }

  ccp->last_reset = ccp->reset_sent;
  ccp->reset_sent = -1;
  if (ccp->in.state != NULL)
    (*algorithm[ccp->in.algorithm]->i.Reset)(ccp->in.state);
}

static struct mbuf *
ccp_LayerPush(struct bundle *b, struct link *l, struct mbuf *bp,
              int pri, u_short *proto)
{
  if (PROTO_COMPRESSIBLE(*proto)) {
    if (l->ccp.fsm.state != ST_OPENED) {
      if (ccp_Required(&l->ccp)) {
        /* The NCP layer shouldn't have let this happen ! */
        log_Printf(LogERROR, "%s: Unexpected attempt to use an unopened and"
                   " required CCP layer\n", l->name);
        m_freem(bp);
        bp = NULL;
      }
    } else if (l->ccp.out.state != NULL) {
      bp = (*algorithm[l->ccp.out.algorithm]->o.Write)
             (l->ccp.out.state, &l->ccp, l, pri, proto, bp);
      switch (*proto) {
        case PROTO_ICOMPD:
          m_settype(bp, MB_ICOMPDOUT);
          break;
        case PROTO_COMPD:
          m_settype(bp, MB_COMPDOUT);
          break;
      }
    }
  }

  return bp;
}

static struct mbuf *
ccp_LayerPull(struct bundle *b, struct link *l, struct mbuf *bp, u_short *proto)
{
  /*
   * If proto isn't PROTO_[I]COMPD, we still want to pass it to the
   * decompression routines so that the dictionary's updated
   */
  if (l->ccp.fsm.state == ST_OPENED) {
    if (*proto == PROTO_COMPD || *proto == PROTO_ICOMPD) {
      /* Decompress incoming data */
      if (l->ccp.reset_sent != -1)
        /* Send another REQ and put the packet in the bit bucket */
        fsm_Output(&l->ccp.fsm, CODE_RESETREQ, l->ccp.reset_sent, NULL, 0,
                   MB_CCPOUT);
      else if (l->ccp.in.state != NULL) {
        bp = (*algorithm[l->ccp.in.algorithm]->i.Read)
               (l->ccp.in.state, &l->ccp, proto, bp);
        switch (*proto) {
          case PROTO_ICOMPD:
            m_settype(bp, MB_ICOMPDIN);
            break;
          case PROTO_COMPD:
            m_settype(bp, MB_COMPDIN);
            break;
        }
        return bp;
      }
      m_freem(bp);
      bp = NULL;
    } else if (PROTO_COMPRESSIBLE(*proto) && l->ccp.in.state != NULL) {
      /* Add incoming Network Layer traffic to our dictionary */
      (*algorithm[l->ccp.in.algorithm]->i.DictSetup)
        (l->ccp.in.state, &l->ccp, *proto, bp);
    }
  }

  return bp;
}

u_short
ccp_Proto(struct ccp *ccp)
{
  return !link2physical(ccp->fsm.link) || !ccp->fsm.bundle->ncp.mp.active ?
         PROTO_COMPD : PROTO_ICOMPD;
}

int
ccp_SetOpenMode(struct ccp *ccp)
{
  int f;

  for (f = 0; f < CCP_NEG_TOTAL; f++)
    if (IsEnabled(ccp->cfg.neg[f])) {
      ccp->fsm.open_mode = 0;
      return 1;
    }

  ccp->fsm.open_mode = OPEN_PASSIVE;	/* Go straight to ST_STOPPED ? */

  for (f = 0; f < CCP_NEG_TOTAL; f++)
    if (IsAccepted(ccp->cfg.neg[f]))
      return 1;

  return 0;				/* No CCP at all */
}

int
ccp_DefaultUsable(struct fsm *fp)
{
  return 1;
}

int
ccp_DefaultRequired(struct fsm *fp)
{
  return 0;
}

struct layer ccplayer = { LAYER_CCP, "ccp", ccp_LayerPush, ccp_LayerPull };
@


1.33
log
@Fix two identical buffer overruns.

found by parfait, my stupid mistake pointed out by miod, who also oked
this.
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.32 2005/07/17 19:13:24 brad Exp $
@


1.32
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.31 2005/07/06 13:56:00 brad Exp $
d136 1
a136 1
  if (proto < 0 || proto > sizeof cftypes / sizeof *cftypes ||
@


1.31
log
@Add a bunch of malloc() return checks

From brian FreeBSD

ok deraadt@@ tdeval@@
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.30 2002/07/02 00:13:19 brian Exp $
d38 1
@


1.30
log
@Remove some misleading/wrong diagnostics
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.29 2002/06/15 08:02:00 brian Exp $
d367 5
a371 1
        *o = (struct ccp_opt *)malloc(sizeof(struct ccp_opt));
@


1.29
log
@Tidy up end of line whitespace
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.28 2002/06/15 01:33:23 brian Exp $
a748 2
      log_Printf(LogDEBUG, "ccp_LayerPull: PROTO_%sCOMPDP -> PROTO_IP\n",
                 *proto == PROTO_ICOMPD ? "I" : "");
a769 1
      log_Printf(LogDEBUG, "ccp_LayerPull: Ignore packet (dict only)\n");
d773 1
a773 2
    } else
      log_Printf(LogDEBUG, "ccp_LayerPull: Ignore packet\n");
@


1.28
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.27 2002/05/16 01:13:39 brian Exp $
d455 1
a455 1
  
@


1.27
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.26 2002/03/31 02:38:49 brian Exp $
d372 1
a372 1
        (*algorithm[f]->o.OptInit)(&(*o)->val, &ccp->cfg);
d520 2
a521 1
    ccp->in.state = (*algorithm[ccp->in.algorithm]->i.Init)(&ccp->in.opt);
d538 2
a539 1
    ccp->out.state = (*algorithm[ccp->out.algorithm]->o.Init)(&(*o)->val);
d601 1
a601 1
          switch ((*algorithm[f]->i.Set)(&ccp->in.opt, &ccp->cfg)) {
d627 2
a628 1
          if ((*algorithm[f]->o.Set)(&o->val, &ccp->cfg) == MODE_ACK)
@


1.26
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.25 2001/11/23 11:17:03 brian Exp $
a60 1
#include "ip.h"
d82 1
a82 1
static void CcpDecodeConfig(struct fsm *, u_char *, int, int,
d278 1
a278 1
  ccp->in.opt.id = -1;
d363 1
a363 1
          if ((*o)->val.id == algorithm[f]->id && (*o)->algorithm == f)
d368 2
a369 2
        (*o)->val.id = algorithm[f]->id;
        (*o)->val.len = 2;
d375 1
a375 1
      if (cp + (*o)->val.len > buff + sizeof buff) {
d379 2
a380 2
      memcpy(cp, &(*o)->val, (*o)->val.len);
      cp += (*o)->val.len;
d382 1
a382 1
      ccp->my_proto = (*o)->val.id;
d557 1
a557 1
CcpDecodeConfig(struct fsm *fp, u_char *cp, int plen, int mode_type,
d562 3
a564 2
  int type, length, f;
  const char *end;
d569 2
a570 6
  while (plen >= sizeof(struct fsmconfig)) {
    type = *cp;
    length = cp[1];

    if (length == 0) {
      log_Printf(LogCCP, "%s: CCP size zero\n", fp->link->name);
a571 7
    }

    if (length > sizeof(struct lcp_opt)) {
      length = sizeof(struct lcp_opt);
      log_Printf(LogCCP, "%s: Warning: Truncating length to %d\n",
                fp->link->name, length);
    }
d574 1
a574 1
      if (algorithm[f]->id == type)
d577 3
a579 3
    end = f == -1 ? "" : (*algorithm[f]->Disp)((struct lcp_opt *)cp);
    if (end == NULL)
      end = "";
d581 2
a582 1
    log_Printf(LogCCP, " %s[%d] %s\n", protoname(type), length, end);
d587 2
a588 3
        ccp->my_reject |= (1 << type);
        memcpy(dec->rejend, cp, length);
        dec->rejend += length;
d595 1
a595 1
	if (IsAccepted(ccp->cfg.neg[algorithm[f]->Neg]) &&
d598 1
a598 1
	  memcpy(&ccp->in.opt, cp, length);
d601 1
a601 2
	    memcpy(dec->rejend, &ccp->in.opt, ccp->in.opt.len);
	    dec->rejend += ccp->in.opt.len;
d604 1
a604 2
	    memcpy(dec->nakend, &ccp->in.opt, ccp->in.opt.len);
	    dec->nakend += ccp->in.opt.len;
d607 2
a608 3
	    memcpy(dec->ackend, cp, length);
	    dec->ackend += length;
	    ccp->his_proto = type;
d612 4
a615 5
	} else {
	  memcpy(dec->rejend, cp, length);
	  dec->rejend += length;
	}
	break;
d618 1
a618 1
          if (o->val.id == cp[0])
d624 1
a624 1
	  memcpy(&o->val, cp, length);
d628 2
a629 2
	    ccp->his_reject |= (1 << type);
	    ccp->my_proto = -1;
d640 2
a641 2
	ccp->his_reject |= (1 << type);
	ccp->my_proto = -1;
d647 1
a647 1
	break;
a649 3

    plen -= cp[1];
    cp += cp[1];
d653 2
a654 11
    if (dec->rejend != dec->rej) {
      /* rejects are preferred */
      dec->ackend = dec->ack;
      dec->nakend = dec->nak;
      if (ccp->in.state == NULL) {
        ccp->his_proto = -1;
        ccp->in.algorithm = -1;
      }
    } else if (dec->nakend != dec->nak) {
      /* then NAKs */
      dec->ackend = dec->ack;
@


1.25
log
@cmott@@scientech.com -> cm@@linktel.net
Add the UPTIME variable
CCP protocol ``0xffffffff'' -> ``none''
Don't leak memory when expanding command arguments and not exec()ing
Make some functions static
Add the ``log'' command for manual logging
Fix some log text bogons
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.24 2001/08/19 23:22:17 brian Exp $
d73 1
a73 1
#ifdef HAVE_DES
d151 1
a151 1
#ifdef HAVE_DES
d200 1
a200 1
#ifdef HAVE_DES
d227 1
a227 1
#ifdef HAVE_DES
d260 1
a260 1
#ifdef HAVE_DES
@


1.24
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.23 2001/07/07 13:12:57 brian Exp $
d137 3
a139 1
      cftypes[proto] == NULL)
d141 1
@


1.23
log
@Don't try to dereference the -1th ccp algorithm array entry when we
open CCP with no algorithm.
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.22 2001/07/07 03:08:49 brian Exp $
d35 1
d60 2
d76 2
@


1.22
log
@When we miss one or more packets in stateful mode *and* need to
perform a key change, *and* our sequence numbers have wrapped,
ensure that the number of key changes is calculated correctly.

The previous code counted down from a negative number to zero,
re-encrypting the current key on each iteration - this took some
time and strangely enough got the answer wrong !!!

Spell stateful correctly while I'm here.
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.21 2001/07/03 22:23:56 brian Exp $
d309 1
a309 1
  if (ccp->fsm.state == ST_OPENED)
@


1.21
log
@Reduce the interface MTU by 2 when MPPE has been successfully negotiated.

This is necessary because MPPE will combine the protocol id with the
payload received on the tun interface, encrypt it, then prepend its
own protocol id, effectively increasing the payload by two bytes.
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.20 2001/06/19 10:24:50 brian Exp $
d200 1
a200 1
    prompt_Printf(arg->prompt, "statefull");
@


1.20
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d28 1
a28 1
 * $OpenBSD: ccp.c,v 1.19 2001/06/13 21:33:40 brian Exp $
d302 13
d490 18
a507 1
  int f;
@


1.19
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d85 1
a85 1
static void CcpRecvResetReq(struct fsm *);
d153 1
d156 1
d171 13
d192 22
a213 1
  prompt_Printf(arg->prompt, "           DEFLATE:    %s\n",
d220 1
a220 1
  prompt_Printf(arg->prompt, "           MPPE:       %s",
a221 1
  prompt_Printf(arg->prompt, " (Key Size = %d-bits)\n", ccp->cfg.mppe.keybits);
d253 3
a255 1
  ccp->cfg.mppe.keybits = 128;
d278 24
d396 1
a396 1
static void
d401 3
a403 2
  if (ccp->out.state != NULL)
    (*algorithm[ccp->out.algorithm]->o.Reset)(ccp->out.state);
d462 6
d602 1
a602 1
          if ((*algorithm[f]->o.Set)(&o->val) == MODE_ACK)
d607 6
d619 5
d700 20
a719 11
  if (PROTO_COMPRESSIBLE(*proto) && l->ccp.fsm.state == ST_OPENED &&
      l->ccp.out.state != NULL) {
    bp = (*algorithm[l->ccp.out.algorithm]->o.Write)
           (l->ccp.out.state, &l->ccp, l, pri, proto, bp);
    switch (*proto) {
      case PROTO_ICOMPD:
        m_settype(bp, MB_ICOMPDOUT);
        break;
      case PROTO_COMPD:
        m_settype(bp, MB_COMPDOUT);
        break;
d797 1
a797 1
ccp_IsUsable(struct fsm *fp)
d800 6
@


1.18
log
@Add a ``Usable'' function to the ccp switch.  The function
is called prior to sending a CCP configure request for a
given protocol.  The default is to send the request, but
this is overridden for MPPE which checks to see if the lcp
negotiations agreed CHAP81, and if not fails.

Use the same function to decide if we should reject peer
requests for MPPE.

This should get rid of those boring messages about not being
able to initialise MPPE when we don't negotiate CHAP81.
@
text
@d1 5
a5 2
/*
 *	   PPP Compression Control Protocol (CCP) Module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1994, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 16
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: ccp.c,v 1.17 2000/11/22 02:13:08 brian Exp $
 *
 *	TODO:
 *		o Support other compression protocols
d30 1
@


1.17
log
@Enable and accept MPPE by default (deflate & pred1 are preferred)
Accept MSCHAPv2 by default.
Hard sentence breaks
Describe tunneling more clearly
Some cosmetic netgraph fixes (Not used in OpenBSD)
@
text
@d20 1
a20 1
 * $OpenBSD: ccp.c,v 1.16 2000/11/07 23:32:04 brian Exp $
d271 2
a272 1
        !REJECTED(ccp, algorithm[f]->id)) {
d495 1
d700 6
@


1.16
log
@Pass the correct option data to the compression modules Init function
rather than the data associated with the first protocol REQuested.

Initiate MPPE session keys correctly based on whether we're client
or server
@
text
@d20 1
a20 1
 * $OpenBSD: ccp.c,v 1.15 2000/11/02 00:54:33 brian Exp $
d213 1
a213 1
  ccp->cfg.neg[CCP_NEG_MPPE] = 0;
@


1.15
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d20 1
a20 1
 * $OpenBSD: ccp.c,v 1.14 2000/07/19 11:06:31 brian Exp $
d379 3
d383 10
d401 2
d418 5
d425 1
a425 2
    ccp->out.state = (*algorithm[ccp->out.algorithm]->o.Init)
                       (&ccp->out.opt->val);
@


1.14
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d20 1
a20 1
 * $OpenBSD: ccp.c,v 1.13 2000/02/27 01:38:25 brian Exp $
d64 3
d112 2
a113 1
    "MPPC",		/* 18: Microsoft PPC (rfc2118) */
d137 3
d177 5
d211 4
d503 2
a504 2
          log_Printf(LogCCP, "%s: Warning: Ignoring peer NAK of unsent option\n",
                    fp->link->name);
@


1.13
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: ccp.c,v 1.12 2000/02/27 00:21:06 brian Exp $
a43 2
#include "lcp.h"
#include "ccp.h"
d51 2
@


1.12
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.11 2000/01/07 03:26:53 brian Exp $
@


1.11
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.10 1999/06/02 15:58:40 brian Exp $
a95 24
static char const * const cftypes[] = {
  /* Check out the latest ``Compression Control Protocol'' rfc (rfc1962.txt) */
  "OUI",		/* 0: OUI */
  "PRED1",		/* 1: Predictor type 1 */
  "PRED2",		/* 2: Predictor type 2 */
  "PUDDLE",		/* 3: Puddle Jumber */
  "???", "???", "???", "???", "???", "???",
  "???", "???", "???", "???", "???", "???",
  "HWPPC",		/* 16: Hewlett-Packard PPC */
  "STAC",		/* 17: Stac Electronics LZS (rfc1974) */
  "MPPC",		/* 18: Microsoft PPC (rfc2118) */
  "GAND",		/* 19: Gandalf FZA (rfc1993) */
  "V42BIS",		/* 20: ARG->DATA.42bis compression */
  "BSD",		/* 21: BSD LZW Compress */
  "???",
  "LZS-DCP",		/* 23: LZS-DCP Compression Protocol (rfc1967) */
  "MAGNALINK/DEFLATE",	/* 24: Magnalink Variable Resource (rfc1975) */
			/* 24: Deflate (according to pppd-2.3.*) */
  "DCE",		/* 25: Data Circuit-Terminating Equip (rfc1976) */
  "DEFLATE",		/* 26: Deflate (rfc1979) */
};

#define NCFTYPES (sizeof cftypes/sizeof cftypes[0])

d99 26
a124 2
  if (proto < 0 || proto > NCFTYPES)
    return "none";
d444 1
a444 4
    if (type < NCFTYPES)
      log_Printf(LogCCP, " %s[%d] %s\n", cftypes[type], length, end);
    else
      log_Printf(LogCCP, " ???[%d] %s\n", length, end);
@


1.10
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.9 1999/05/12 10:03:49 brian Exp $
d33 1
a33 1
#include <string.h>
d93 1
a93 1
static const char *ccp_TimerNames[] =
d96 1
a96 1
static char const *cftypes[] = {
d129 1
a129 1
static const struct ccp_algorithm *algorithm[] = {
d537 1
a537 1
  mbuf_SetType(bp, MB_CCPIN);
d544 1
a544 1
    mbuf_Free(bp);
d587 1
a587 1
        mbuf_SetType(bp, MB_ICOMPDOUT);
d590 1
a590 1
        mbuf_SetType(bp, MB_COMPDOUT);
d619 1
a619 1
            mbuf_SetType(bp, MB_ICOMPDIN);
d622 1
a622 1
            mbuf_SetType(bp, MB_COMPDIN);
d627 1
a627 1
      mbuf_Free(bp);
@


1.9
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.8 1999/05/09 20:03:59 brian Exp $
d285 1
a285 1
  fsm_Output(fp, CODE_CONFIGREQ, fp->reqid, buff, cp - buff);
d296 1
a296 1
  fsm_Output(fp, CODE_RESETREQ, fp->reqid, NULL, 0);
d309 1
a309 1
  fsm_Output(fp, CODE_TERMACK, id, NULL, 0);
d537 1
d582 12
a593 3
      l->ccp.out.state != NULL)
    return (*algorithm[l->ccp.out.algorithm]->o.Write)
             (l->ccp.out.state, &l->ccp, l, pri, proto, bp);
d612 15
a626 4
        fsm_Output(&l->ccp.fsm, CODE_RESETREQ, l->ccp.reset_sent, NULL, 0);
      else if (l->ccp.in.state != NULL)
        return (*algorithm[l->ccp.in.algorithm]->i.Read)
                 (l->ccp.in.state, &l->ccp, proto, bp);
@


1.8
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.7 1999/05/08 11:06:34 brian Exp $
d597 2
d608 2
a609 1
    } else if (PROTO_COMPRESSIBLE(*proto) && l->ccp.in.state != NULL)
d613 2
@


1.7
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.6 1999/05/02 14:34:02 brian Exp $
d366 1
a366 3
/*
 *  Called when CCP has reached the OPEN state
 */
@


1.6
log
@Handle receiving more than one acceptable CCP REQ
during one negotiation session without REJecting
everything from the second REQuest.
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.5 1999/03/31 14:22:10 brian Exp $
d36 1
d43 1
a43 1
#include "lcpproto.h"
d148 7
a154 5
  prompt_Printf(arg->prompt, " My protocol = %s, His protocol = %s\n",
                protoname(ccp->my_proto), protoname(ccp->his_proto));
  prompt_Printf(arg->prompt, " Output: %ld --> %ld,  Input: %ld --> %ld\n",
                ccp->uncompout, ccp->compout,
                ccp->compin, ccp->uncompin);
d535 2
a536 2
void
ccp_Input(struct ccp *ccp, struct bundle *bundle, struct mbuf *bp)
d540 1
a540 1
    fsm_Input(&ccp->fsm, bp);
d544 1
a544 1
                 ccp->fsm.link->name, bundle_PhaseName(bundle));
d547 1
d578 10
a587 12
int
ccp_Compress(struct ccp *ccp, struct link *l, int pri, u_short proto,
             struct mbuf *m)
{
  /*
   * Compress outgoing data.  It's already deemed to be suitable Network
   * Layer data.
   */
  if (ccp->fsm.state == ST_OPENED && ccp->out.state != NULL)
    return (*algorithm[ccp->out.algorithm]->o.Write)
             (ccp->out.state, ccp, l, pri, proto, m);
  return 0;
d590 2
a591 2
struct mbuf *
ccp_Decompress(struct ccp *ccp, u_short *proto, struct mbuf *bp)
d597 1
a597 1
  if (ccp->fsm.state == ST_OPENED) {
d600 1
a600 1
      if (ccp->reset_sent != -1)
d602 4
a605 4
        fsm_Output(&ccp->fsm, CODE_RESETREQ, ccp->reset_sent, NULL, 0);
      else if (ccp->in.state != NULL)
        return (*algorithm[ccp->in.algorithm]->i.Read)
                 (ccp->in.state, ccp, proto, bp);
d608 1
a608 1
    } else if (PROTO_COMPRESSIBLE(*proto) && ccp->in.state != NULL)
d610 2
a611 2
      (*algorithm[ccp->in.algorithm]->i.DictSetup)
        (ccp->in.state, ccp, *proto, bp);
d643 2
@


1.5
log
@Avoid a few warnings on the alpha
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.4 1999/03/11 01:50:04 brian Exp $
d414 1
a414 2
  int type, length;
  int f;
d416 3
@


1.4
log
@Tone down the log levels (Log{ERROR,WARN} -> LogCCP)
when we've simply missed a packet.

When our Predictor1 CRC is wrong (implying we've dropped
a packet), don't send a ResetReq().  Instead, send another
CCP ConfigReq().  *shrug*  My tests show this as being far
worse than the ResetReq as we may have further Nak/Rejs etc
and we're basically resetting both our incoming and outgoing
compression dictionaries, but rfc1978 says the ConfigReq is
correct, so we'd better go along...
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.3 1999/02/26 21:28:20 brian Exp $
d33 1
@


1.3
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.2 1999/02/06 03:22:32 brian Exp $
d551 1
a551 1
      log_Printf(LogWARN, "CCP: %s: Incorrect ResetAck (id %d, not %d)"
d558 1
a558 1
              fp->link->name);
d560 2
a561 2
    log_Printf(LogWARN, "CCP: %s: Unexpected ResetAck (id %d) ignored\n",
              fp->link->name, id);
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.41 1999/01/28 01:56:30 brian Exp $
d73 1
a73 1
static void CcpInitRestartCounter(struct fsm *);
d153 4
a156 1
  prompt_Printf(arg->prompt, "FSM retry = %us\n", ccp->cfg.fsmretry);
d184 1
a184 1
  fsm_Init(&ccp->fsm, "CCP", PROTO_CCP, 1, CCP_MAXCODE, 10, LogCCP,
d189 3
a191 1
  ccp->cfg.fsmretry = DEF_FSMRETRY;
a203 1
  ccp->fsm.maxconfig = 10;
d216 1
a216 1
CcpInitRestartCounter(struct fsm *fp)
d221 12
a232 2
  fp->FsmTimer.load = ccp->cfg.fsmretry * SECTICKS;
  fp->restart = DEF_REQs;
d321 2
d324 1
d370 1
d372 1
d381 1
d394 1
d398 2
d403 1
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: ccp.c,v 1.40 1998/08/26 18:07:56 brian Exp $
d25 1
a25 1
#include <sys/types.h>
a32 1
#include <string.h>
d59 3
@

