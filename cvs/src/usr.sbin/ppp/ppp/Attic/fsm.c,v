head	1.25;
access;
symbols
	OPENBSD_5_5:1.24.0.38
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.34
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.32
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.30
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.28
	OPENBSD_5_0:1.24.0.26
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.24
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.22
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.18
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.20
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.16
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.14
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.12
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.10
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.8
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.6
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.4
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.12
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.10
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.8
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.6
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.24;

1.24
date	2005.07.17.20.24.45;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.15.08.02.41;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.19.10.24.52;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.26.01.40.43;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.19.11.06.33;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.27.01.38.26;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.08.10.10.50.44;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.06.02.15.58.40;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.05.14.09.35.27;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.05.09.20.03.59;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.05.08.11.06.35;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.03.29.08.20.32;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.03.01.02.52.19;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.21.28.22;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.22.36;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.09.04.18.27.45;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.20;	author brian;	state Exp;
branches;
next	;


desc
@@


1.25
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: fsm.c,v 1.24 2005/07/17 20:24:45 brad Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <string.h>
#include <termios.h>

#include "layer.h"
#include "ua.h"
#include "mbuf.h"
#include "log.h"
#include "defs.h"
#include "timer.h"
#include "fsm.h"
#include "iplist.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "descriptor.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "async.h"
#include "physical.h"
#include "proto.h"

static void FsmSendConfigReq(struct fsm *);
static void FsmSendTerminateReq(struct fsm *);
static void FsmInitRestartCounter(struct fsm *, int);

typedef void (recvfn)(struct fsm *, struct fsmheader *, struct mbuf *);
static recvfn FsmRecvConfigReq, FsmRecvConfigAck, FsmRecvConfigNak,
              FsmRecvConfigRej, FsmRecvTermReq, FsmRecvTermAck,
              FsmRecvCodeRej, FsmRecvProtoRej, FsmRecvEchoReq,
              FsmRecvEchoRep, FsmRecvDiscReq, FsmRecvIdent,
              FsmRecvTimeRemain, FsmRecvResetReq, FsmRecvResetAck;

static const struct fsmcodedesc {
  recvfn *recv;
  unsigned check_reqid : 1;
  unsigned inc_reqid : 1;
  const char *name;
} FsmCodes[] = {
  { FsmRecvConfigReq, 0, 0, "ConfigReq"    },
  { FsmRecvConfigAck, 1, 1, "ConfigAck"    },
  { FsmRecvConfigNak, 1, 1, "ConfigNak"    },
  { FsmRecvConfigRej, 1, 1, "ConfigRej"    },
  { FsmRecvTermReq,   0, 0, "TerminateReq" },
  { FsmRecvTermAck,   1, 1, "TerminateAck" },
  { FsmRecvCodeRej,   0, 0, "CodeRej"      },
  { FsmRecvProtoRej,  0, 0, "ProtocolRej"  },
  { FsmRecvEchoReq,   0, 0, "EchoRequest"  },
  { FsmRecvEchoRep,   0, 0, "EchoReply"    },
  { FsmRecvDiscReq,   0, 0, "DiscardReq"   },
  { FsmRecvIdent,     0, 1, "Ident"        },
  { FsmRecvTimeRemain,0, 0, "TimeRemain"   },
  { FsmRecvResetReq,  0, 0, "ResetReq"     },
  { FsmRecvResetAck,  0, 1, "ResetAck"     }
};

static const char *
Code2Nam(u_int code)
{
  if (code == 0 || code > sizeof FsmCodes / sizeof FsmCodes[0])
    return "Unknown";
  return FsmCodes[code-1].name;
}

const char *
State2Nam(u_int state)
{
  static const char * const StateNames[] = {
    "Initial", "Starting", "Closed", "Stopped", "Closing", "Stopping",
    "Req-Sent", "Ack-Rcvd", "Ack-Sent", "Opened",
  };

  if (state >= sizeof StateNames / sizeof StateNames[0])
    return "unknown";
  return StateNames[state];
}

static void
StoppedTimeout(void *v)
{
  struct fsm *fp = (struct fsm *)v;

  log_Printf(fp->LogLevel, "%s: Stopped timer expired\n", fp->link->name);
  if (fp->OpenTimer.state == TIMER_RUNNING) {
    log_Printf(LogWARN, "%s: %s: aborting open delay due to stopped timer\n",
              fp->link->name, fp->name);
    timer_Stop(&fp->OpenTimer);
  }
  if (fp->state == ST_STOPPED)
    fsm2initial(fp);
}

void
fsm_Init(struct fsm *fp, const char *name, u_short proto, int mincode,
         int maxcode, int LogLevel, struct bundle *bundle,
         struct link *l, const struct fsm_parent *parent,
         struct fsm_callbacks *fn, const char * const timer_names[3])
{
  fp->name = name;
  fp->proto = proto;
  fp->min_code = mincode;
  fp->max_code = maxcode;
  fp->state = fp->min_code > CODE_TERMACK ? ST_OPENED : ST_INITIAL;
  fp->reqid = 1;
  fp->restart = 1;
  fp->more.reqs = fp->more.naks = fp->more.rejs = 3;
  memset(&fp->FsmTimer, '\0', sizeof fp->FsmTimer);
  memset(&fp->OpenTimer, '\0', sizeof fp->OpenTimer);
  memset(&fp->StoppedTimer, '\0', sizeof fp->StoppedTimer);
  fp->LogLevel = LogLevel;
  fp->link = l;
  fp->bundle = bundle;
  fp->parent = parent;
  fp->fn = fn;
  fp->FsmTimer.name = timer_names[0];
  fp->OpenTimer.name = timer_names[1];
  fp->StoppedTimer.name = timer_names[2];
}

static void
NewState(struct fsm *fp, int new)
{
  log_Printf(fp->LogLevel, "%s: State change %s --> %s\n",
             fp->link->name, State2Nam(fp->state), State2Nam(new));
  if (fp->state == ST_STOPPED && fp->StoppedTimer.state == TIMER_RUNNING)
    timer_Stop(&fp->StoppedTimer);
  fp->state = new;
  if ((new >= ST_INITIAL && new <= ST_STOPPED) || (new == ST_OPENED)) {
    timer_Stop(&fp->FsmTimer);
    if (new == ST_STOPPED && fp->StoppedTimer.load) {
      timer_Stop(&fp->StoppedTimer);
      fp->StoppedTimer.func = StoppedTimeout;
      fp->StoppedTimer.arg = (void *) fp;
      timer_Start(&fp->StoppedTimer);
    }
  }
}

void
fsm_Output(struct fsm *fp, u_int code, u_int id, u_char *ptr, int count,
           int mtype)
{
  int plen;
  struct fsmheader lh;
  struct mbuf *bp;

  if (log_IsKept(fp->LogLevel)) {
    log_Printf(fp->LogLevel, "%s: Send%s(%d) state = %s\n",
              fp->link->name, Code2Nam(code), id, State2Nam(fp->state));
    switch (code) {
      case CODE_CONFIGREQ:
      case CODE_CONFIGACK:
      case CODE_CONFIGREJ:
      case CODE_CONFIGNAK:
        (*fp->fn->DecodeConfig)(fp, ptr, ptr + count, MODE_NOP, NULL);
        if (count < sizeof(struct fsm_opt_hdr))
          log_Printf(fp->LogLevel, "  [EMPTY]\n");
        break;
    }
  }

  plen = sizeof(struct fsmheader) + count;
  lh.code = code;
  lh.id = id;
  lh.length = htons(plen);
  bp = m_get(plen, mtype);
  memcpy(MBUF_CTOP(bp), &lh, sizeof(struct fsmheader));
  if (count)
    memcpy(MBUF_CTOP(bp) + sizeof(struct fsmheader), ptr, count);
  log_DumpBp(LogDEBUG, "fsm_Output", bp);
  link_PushPacket(fp->link, bp, fp->bundle, LINK_QUEUES(fp->link) - 1,
                  fp->proto);

  if (code == CODE_CONFIGREJ)
    lcp_SendIdentification(&fp->link->lcp);
}

static void
FsmOpenNow(void *v)
{
  struct fsm *fp = (struct fsm *)v;

  timer_Stop(&fp->OpenTimer);
  if (fp->state <= ST_STOPPED) {
    if (fp->state != ST_STARTING) {
      /*
       * In practice, we're only here in ST_STOPPED (when delaying the
       * first config request) or ST_CLOSED (when openmode == 0).
       *
       * The ST_STOPPED bit is breaking the RFC already :-(
       *
       * According to the RFC (1661) state transition table, a TLS isn't
       * required for an Open event when state == Closed, but the RFC
       * must be wrong as TLS hasn't yet been called (since the last TLF)
       * ie, Initial gets an `Up' event, Closing gets a RTA etc.
       */
      (*fp->fn->LayerStart)(fp);
      (*fp->parent->LayerStart)(fp->parent->object, fp);
    }
    FsmInitRestartCounter(fp, FSM_REQ_TIMER);
    FsmSendConfigReq(fp);
    NewState(fp, ST_REQSENT);
  }
}

void
fsm_Open(struct fsm *fp)
{
  switch (fp->state) {
  case ST_INITIAL:
    NewState(fp, ST_STARTING);
    (*fp->fn->LayerStart)(fp);
    (*fp->parent->LayerStart)(fp->parent->object, fp);
    break;
  case ST_CLOSED:
    if (fp->open_mode == OPEN_PASSIVE) {
      NewState(fp, ST_STOPPED);		/* XXX: This is a hack ! */
    } else if (fp->open_mode > 0) {
      if (fp->open_mode > 1)
        log_Printf(LogPHASE, "%s: Entering STOPPED state for %d seconds\n",
                  fp->link->name, fp->open_mode);
      NewState(fp, ST_STOPPED);		/* XXX: This is a not-so-bad hack ! */
      timer_Stop(&fp->OpenTimer);
      fp->OpenTimer.load = fp->open_mode * SECTICKS;
      fp->OpenTimer.func = FsmOpenNow;
      fp->OpenTimer.arg = (void *)fp;
      timer_Start(&fp->OpenTimer);
    } else
      FsmOpenNow(fp);
    break;
  case ST_STOPPED:		/* XXX: restart option */
  case ST_REQSENT:
  case ST_ACKRCVD:
  case ST_ACKSENT:
  case ST_OPENED:		/* XXX: restart option */
    break;
  case ST_CLOSING:		/* XXX: restart option */
  case ST_STOPPING:		/* XXX: restart option */
    NewState(fp, ST_STOPPING);
    break;
  }
}

void
fsm_Up(struct fsm *fp)
{
  switch (fp->state) {
  case ST_INITIAL:
    log_Printf(fp->LogLevel, "FSM: Using \"%s\" as a transport\n",
              fp->link->name);
    NewState(fp, ST_CLOSED);
    break;
  case ST_STARTING:
    FsmInitRestartCounter(fp, FSM_REQ_TIMER);
    FsmSendConfigReq(fp);
    NewState(fp, ST_REQSENT);
    break;
  default:
    log_Printf(fp->LogLevel, "%s: Oops, Up at %s\n",
              fp->link->name, State2Nam(fp->state));
    break;
  }
}

void
fsm_Down(struct fsm *fp)
{
  switch (fp->state) {
  case ST_CLOSED:
    NewState(fp, ST_INITIAL);
    break;
  case ST_CLOSING:
    /* This TLF contradicts the RFC (1661), which ``misses it out'' ! */
    (*fp->fn->LayerFinish)(fp);
    NewState(fp, ST_INITIAL);
    (*fp->parent->LayerFinish)(fp->parent->object, fp);
    break;
  case ST_STOPPED:
    NewState(fp, ST_STARTING);
    (*fp->fn->LayerStart)(fp);
    (*fp->parent->LayerStart)(fp->parent->object, fp);
    break;
  case ST_STOPPING:
  case ST_REQSENT:
  case ST_ACKRCVD:
  case ST_ACKSENT:
    NewState(fp, ST_STARTING);
    break;
  case ST_OPENED:
    (*fp->fn->LayerDown)(fp);
    NewState(fp, ST_STARTING);
    (*fp->parent->LayerDown)(fp->parent->object, fp);
    break;
  }
}

void
fsm_Close(struct fsm *fp)
{
  switch (fp->state) {
  case ST_STARTING:
    (*fp->fn->LayerFinish)(fp);
    NewState(fp, ST_INITIAL);
    (*fp->parent->LayerFinish)(fp->parent->object, fp);
    break;
  case ST_STOPPED:
    NewState(fp, ST_CLOSED);
    break;
  case ST_STOPPING:
    NewState(fp, ST_CLOSING);
    break;
  case ST_OPENED:
    (*fp->fn->LayerDown)(fp);
    if (fp->state == ST_OPENED) {
      FsmInitRestartCounter(fp, FSM_TRM_TIMER);
      FsmSendTerminateReq(fp);
      NewState(fp, ST_CLOSING);
      (*fp->parent->LayerDown)(fp->parent->object, fp);
    }
    break;
  case ST_REQSENT:
  case ST_ACKRCVD:
  case ST_ACKSENT:
    FsmInitRestartCounter(fp, FSM_TRM_TIMER);
    FsmSendTerminateReq(fp);
    NewState(fp, ST_CLOSING);
    break;
  }
}

/*
 *	Send functions
 */
static void
FsmSendConfigReq(struct fsm *fp)
{
  if (fp->more.reqs-- > 0 && fp->restart-- > 0) {
    (*fp->fn->SendConfigReq)(fp);
    timer_Start(&fp->FsmTimer);		/* Start restart timer */
  } else {
    if (fp->more.reqs < 0)
      log_Printf(LogPHASE, "%s: Too many %s REQs sent - abandoning "
                 "negotiation\n", fp->link->name, fp->name);
    lcp_SendIdentification(&fp->link->lcp);
    fsm_Close(fp);
  }
}

static void
FsmSendTerminateReq(struct fsm *fp)
{
  fsm_Output(fp, CODE_TERMREQ, fp->reqid, NULL, 0, MB_UNKNOWN);
  (*fp->fn->SentTerminateReq)(fp);
  timer_Start(&fp->FsmTimer);	/* Start restart timer */
  fp->restart--;		/* Decrement restart counter */
}

/*
 *	Timeout actions
 */
static void
FsmTimeout(void *v)
{
  struct fsm *fp = (struct fsm *)v;

  if (fp->restart) {
    switch (fp->state) {
    case ST_CLOSING:
    case ST_STOPPING:
      FsmSendTerminateReq(fp);
      break;
    case ST_REQSENT:
    case ST_ACKSENT:
      FsmSendConfigReq(fp);
      break;
    case ST_ACKRCVD:
      FsmSendConfigReq(fp);
      NewState(fp, ST_REQSENT);
      break;
    }
    timer_Start(&fp->FsmTimer);
  } else {
    switch (fp->state) {
    case ST_CLOSING:
      (*fp->fn->LayerFinish)(fp);
      NewState(fp, ST_CLOSED);
      (*fp->parent->LayerFinish)(fp->parent->object, fp);
      break;
    case ST_STOPPING:
      (*fp->fn->LayerFinish)(fp);
      NewState(fp, ST_STOPPED);
      (*fp->parent->LayerFinish)(fp->parent->object, fp);
      break;
    case ST_REQSENT:		/* XXX: 3p */
    case ST_ACKSENT:
    case ST_ACKRCVD:
      (*fp->fn->LayerFinish)(fp);
      NewState(fp, ST_STOPPED);
      (*fp->parent->LayerFinish)(fp->parent->object, fp);
      break;
    }
  }
}

static void
FsmInitRestartCounter(struct fsm *fp, int what)
{
  timer_Stop(&fp->FsmTimer);
  fp->FsmTimer.func = FsmTimeout;
  fp->FsmTimer.arg = (void *)fp;
  (*fp->fn->InitRestartCounter)(fp, what);
}

/*
 * Actions when receive packets
 */
static void
FsmRecvConfigReq(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
/* RCR */
{
  struct fsm_decode dec;
  int plen, flen;
  int ackaction = 0;
  u_char *cp;

  bp = m_pullup(bp);
  plen = m_length(bp);
  flen = ntohs(lhp->length) - sizeof *lhp;
  if (plen < flen) {
    log_Printf(LogWARN, "%s: FsmRecvConfigReq: plen (%d) < flen (%d)\n",
               fp->link->name, plen, flen);
    m_freem(bp);
    return;
  }

  /* Some things must be done before we Decode the packet */
  switch (fp->state) {
  case ST_OPENED:
    (*fp->fn->LayerDown)(fp);
  }

  dec.ackend = dec.ack;
  dec.nakend = dec.nak;
  dec.rejend = dec.rej;
  cp = MBUF_CTOP(bp);
  (*fp->fn->DecodeConfig)(fp, cp, cp + flen, MODE_REQ, &dec);
  if (flen < sizeof(struct fsm_opt_hdr))
    log_Printf(fp->LogLevel, "  [EMPTY]\n");

  if (dec.nakend == dec.nak && dec.rejend == dec.rej)
    ackaction = 1;

  /* Check and process easy case */
  switch (fp->state) {
  case ST_INITIAL:
    if (fp->proto == PROTO_CCP && fp->link->lcp.fsm.state == ST_OPENED) {
      /*
       * ccp_SetOpenMode() leaves us in initial if we're disabling
       * & denying everything.
       */
      bp = m_prepend(bp, lhp, sizeof *lhp, 2);
      bp = proto_Prepend(bp, fp->proto, 0, 0);
      bp = m_pullup(bp);
      lcp_SendProtoRej(&fp->link->lcp, MBUF_CTOP(bp), bp->m_len);
      m_freem(bp);
      return;
    }
    /* Drop through */
  case ST_STARTING:
    log_Printf(fp->LogLevel, "%s: Oops, RCR in %s.\n",
              fp->link->name, State2Nam(fp->state));
    m_freem(bp);
    return;
  case ST_CLOSED:
    (*fp->fn->SendTerminateAck)(fp, lhp->id);
    m_freem(bp);
    return;
  case ST_CLOSING:
    log_Printf(fp->LogLevel, "%s: Error: Got ConfigReq while state = %s\n",
              fp->link->name, State2Nam(fp->state));
  case ST_STOPPING:
    m_freem(bp);
    return;
  case ST_STOPPED:
    FsmInitRestartCounter(fp, FSM_REQ_TIMER);
    /* Drop through */
  case ST_OPENED:
    FsmSendConfigReq(fp);
    break;
  }

  if (dec.rejend != dec.rej)
    fsm_Output(fp, CODE_CONFIGREJ, lhp->id, dec.rej, dec.rejend - dec.rej,
               MB_UNKNOWN);
  if (dec.nakend != dec.nak)
    fsm_Output(fp, CODE_CONFIGNAK, lhp->id, dec.nak, dec.nakend - dec.nak,
               MB_UNKNOWN);
  if (ackaction)
    fsm_Output(fp, CODE_CONFIGACK, lhp->id, dec.ack, dec.ackend - dec.ack,
               MB_UNKNOWN);

  switch (fp->state) {
  case ST_STOPPED:
      /*
       * According to the RFC (1661) state transition table, a TLS isn't
       * required for a RCR when state == ST_STOPPED, but the RFC
       * must be wrong as TLS hasn't yet been called (since the last TLF)
       */
    (*fp->fn->LayerStart)(fp);
    (*fp->parent->LayerStart)(fp->parent->object, fp);
    /* FALLTHROUGH */

  case ST_OPENED:
    if (ackaction)
      NewState(fp, ST_ACKSENT);
    else
      NewState(fp, ST_REQSENT);
    (*fp->parent->LayerDown)(fp->parent->object, fp);
    break;
  case ST_REQSENT:
    if (ackaction)
      NewState(fp, ST_ACKSENT);
    break;
  case ST_ACKRCVD:
    if (ackaction) {
      NewState(fp, ST_OPENED);
      if ((*fp->fn->LayerUp)(fp))
        (*fp->parent->LayerUp)(fp->parent->object, fp);
      else {
        (*fp->fn->LayerDown)(fp);
        FsmInitRestartCounter(fp, FSM_TRM_TIMER);
        FsmSendTerminateReq(fp);
        NewState(fp, ST_CLOSING);
        lcp_SendIdentification(&fp->link->lcp);
      }
    }
    break;
  case ST_ACKSENT:
    if (!ackaction)
      NewState(fp, ST_REQSENT);
    break;
  }
  m_freem(bp);

  if (dec.rejend != dec.rej && --fp->more.rejs <= 0) {
    log_Printf(LogPHASE, "%s: Too many %s REJs sent - abandoning negotiation\n",
               fp->link->name, fp->name);
    lcp_SendIdentification(&fp->link->lcp);
    fsm_Close(fp);
  }

  if (dec.nakend != dec.nak && --fp->more.naks <= 0) {
    log_Printf(LogPHASE, "%s: Too many %s NAKs sent - abandoning negotiation\n",
               fp->link->name, fp->name);
    lcp_SendIdentification(&fp->link->lcp);
    fsm_Close(fp);
  }
}

static void
FsmRecvConfigAck(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
/* RCA */
{
  struct fsm_decode dec;
  int plen, flen;
  u_char *cp;

  plen = m_length(bp);
  flen = ntohs(lhp->length) - sizeof *lhp;
  if (plen < flen) {
    m_freem(bp);
    return;
  }

  bp = m_pullup(bp);
  dec.ackend = dec.ack;
  dec.nakend = dec.nak;
  dec.rejend = dec.rej;
  cp = MBUF_CTOP(bp);
  (*fp->fn->DecodeConfig)(fp, cp, cp + flen, MODE_ACK, &dec);
  if (flen < sizeof(struct fsm_opt_hdr))
    log_Printf(fp->LogLevel, "  [EMPTY]\n");

  switch (fp->state) {
    case ST_CLOSED:
    case ST_STOPPED:
    (*fp->fn->SendTerminateAck)(fp, lhp->id);
    break;
  case ST_CLOSING:
  case ST_STOPPING:
    break;
  case ST_REQSENT:
    FsmInitRestartCounter(fp, FSM_REQ_TIMER);
    NewState(fp, ST_ACKRCVD);
    break;
  case ST_ACKRCVD:
    FsmSendConfigReq(fp);
    NewState(fp, ST_REQSENT);
    break;
  case ST_ACKSENT:
    FsmInitRestartCounter(fp, FSM_REQ_TIMER);
    NewState(fp, ST_OPENED);
    if ((*fp->fn->LayerUp)(fp))
      (*fp->parent->LayerUp)(fp->parent->object, fp);
    else {
      (*fp->fn->LayerDown)(fp);
      FsmInitRestartCounter(fp, FSM_TRM_TIMER);
      FsmSendTerminateReq(fp);
      NewState(fp, ST_CLOSING);
      lcp_SendIdentification(&fp->link->lcp);
    }
    break;
  case ST_OPENED:
    (*fp->fn->LayerDown)(fp);
    FsmSendConfigReq(fp);
    NewState(fp, ST_REQSENT);
    (*fp->parent->LayerDown)(fp->parent->object, fp);
    break;
  }
  m_freem(bp);
}

static void
FsmRecvConfigNak(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
/* RCN */
{
  struct fsm_decode dec;
  int plen, flen;
  u_char *cp;

  plen = m_length(bp);
  flen = ntohs(lhp->length) - sizeof *lhp;
  if (plen < flen) {
    m_freem(bp);
    return;
  }

  /*
   * Check and process easy case
   */
  switch (fp->state) {
  case ST_INITIAL:
  case ST_STARTING:
    log_Printf(fp->LogLevel, "%s: Oops, RCN in %s.\n",
              fp->link->name, State2Nam(fp->state));
    m_freem(bp);
    return;
  case ST_CLOSED:
  case ST_STOPPED:
    (*fp->fn->SendTerminateAck)(fp, lhp->id);
    m_freem(bp);
    return;
  case ST_CLOSING:
  case ST_STOPPING:
    m_freem(bp);
    return;
  }

  bp = m_pullup(bp);
  dec.ackend = dec.ack;
  dec.nakend = dec.nak;
  dec.rejend = dec.rej;
  cp = MBUF_CTOP(bp);
  (*fp->fn->DecodeConfig)(fp, cp, cp + flen, MODE_NAK, &dec);
  if (flen < sizeof(struct fsm_opt_hdr))
    log_Printf(fp->LogLevel, "  [EMPTY]\n");

  switch (fp->state) {
  case ST_REQSENT:
  case ST_ACKSENT:
    FsmInitRestartCounter(fp, FSM_REQ_TIMER);
    FsmSendConfigReq(fp);
    break;
  case ST_OPENED:
    (*fp->fn->LayerDown)(fp);
    FsmSendConfigReq(fp);
    NewState(fp, ST_REQSENT);
    (*fp->parent->LayerDown)(fp->parent->object, fp);
    break;
  case ST_ACKRCVD:
    FsmSendConfigReq(fp);
    NewState(fp, ST_REQSENT);
    break;
  }

  m_freem(bp);
}

static void
FsmRecvTermReq(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
/* RTR */
{
  switch (fp->state) {
  case ST_INITIAL:
  case ST_STARTING:
    log_Printf(fp->LogLevel, "%s: Oops, RTR in %s\n",
              fp->link->name, State2Nam(fp->state));
    break;
  case ST_CLOSED:
  case ST_STOPPED:
  case ST_CLOSING:
  case ST_STOPPING:
  case ST_REQSENT:
    (*fp->fn->SendTerminateAck)(fp, lhp->id);
    break;
  case ST_ACKRCVD:
  case ST_ACKSENT:
    (*fp->fn->SendTerminateAck)(fp, lhp->id);
    NewState(fp, ST_REQSENT);
    break;
  case ST_OPENED:
    (*fp->fn->LayerDown)(fp);
    (*fp->fn->SendTerminateAck)(fp, lhp->id);
    FsmInitRestartCounter(fp, FSM_TRM_TIMER);
    timer_Start(&fp->FsmTimer);			/* Start restart timer */
    fp->restart = 0;
    NewState(fp, ST_STOPPING);
    (*fp->parent->LayerDown)(fp->parent->object, fp);
    /* A delayed ST_STOPPED is now scheduled */
    break;
  }
  m_freem(bp);
}

static void
FsmRecvTermAck(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
/* RTA */
{
  switch (fp->state) {
  case ST_CLOSING:
    (*fp->fn->LayerFinish)(fp);
    NewState(fp, ST_CLOSED);
    (*fp->parent->LayerFinish)(fp->parent->object, fp);
    break;
  case ST_STOPPING:
    (*fp->fn->LayerFinish)(fp);
    NewState(fp, ST_STOPPED);
    (*fp->parent->LayerFinish)(fp->parent->object, fp);
    break;
  case ST_ACKRCVD:
    NewState(fp, ST_REQSENT);
    break;
  case ST_OPENED:
    (*fp->fn->LayerDown)(fp);
    FsmSendConfigReq(fp);
    NewState(fp, ST_REQSENT);
    (*fp->parent->LayerDown)(fp->parent->object, fp);
    break;
  }
  m_freem(bp);
}

static void
FsmRecvConfigRej(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
/* RCJ */
{
  struct fsm_decode dec;
  int plen, flen;
  u_char *cp;

  plen = m_length(bp);
  flen = ntohs(lhp->length) - sizeof *lhp;
  if (plen < flen) {
    m_freem(bp);
    return;
  }

  lcp_SendIdentification(&fp->link->lcp);

  /*
   * Check and process easy case
   */
  switch (fp->state) {
  case ST_INITIAL:
  case ST_STARTING:
    log_Printf(fp->LogLevel, "%s: Oops, RCJ in %s.\n",
              fp->link->name, State2Nam(fp->state));
    m_freem(bp);
    return;
  case ST_CLOSED:
  case ST_STOPPED:
    (*fp->fn->SendTerminateAck)(fp, lhp->id);
    m_freem(bp);
    return;
  case ST_CLOSING:
  case ST_STOPPING:
    m_freem(bp);
    return;
  }

  bp = m_pullup(bp);
  dec.ackend = dec.ack;
  dec.nakend = dec.nak;
  dec.rejend = dec.rej;
  cp = MBUF_CTOP(bp);
  (*fp->fn->DecodeConfig)(fp, cp, cp + flen, MODE_REJ, &dec);
  if (flen < sizeof(struct fsm_opt_hdr))
    log_Printf(fp->LogLevel, "  [EMPTY]\n");

  switch (fp->state) {
  case ST_REQSENT:
  case ST_ACKSENT:
    FsmInitRestartCounter(fp, FSM_REQ_TIMER);
    FsmSendConfigReq(fp);
    break;
  case ST_OPENED:
    (*fp->fn->LayerDown)(fp);
    FsmSendConfigReq(fp);
    NewState(fp, ST_REQSENT);
    (*fp->parent->LayerDown)(fp->parent->object, fp);
    break;
  case ST_ACKRCVD:
    FsmSendConfigReq(fp);
    NewState(fp, ST_REQSENT);
    break;
  }
  m_freem(bp);
}

static void
FsmRecvCodeRej(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
{
  m_freem(bp);
}

static void
FsmRecvProtoRej(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
{
  struct physical *p = link2physical(fp->link);
  u_short proto;

  if (m_length(bp) < 2) {
    m_freem(bp);
    return;
  }
  bp = mbuf_Read(bp, &proto, 2);
  proto = ntohs(proto);
  log_Printf(fp->LogLevel, "%s: -- Protocol 0x%04x (%s) was rejected!\n",
            fp->link->name, proto, hdlc_Protocol2Nam(proto));

  switch (proto) {
  case PROTO_LQR:
    if (p)
      lqr_Stop(p, LQM_LQR);
    else
      log_Printf(LogERROR, "%s: FsmRecvProtoRej: Not a physical link !\n",
                fp->link->name);
    break;
  case PROTO_CCP:
    if (fp->proto == PROTO_LCP) {
      fp = &fp->link->ccp.fsm;
      /* Despite the RFC (1661), don't do an out-of-place TLF */
      /* (*fp->fn->LayerFinish)(fp); */
      switch (fp->state) {
      case ST_CLOSED:
      case ST_CLOSING:
        NewState(fp, ST_CLOSED);
        break;
      default:
        NewState(fp, ST_STOPPED);
        break;
      }
      /* See above */
      /* (*fp->parent->LayerFinish)(fp->parent->object, fp); */
    }
    break;
  case PROTO_IPCP:
    if (fp->proto == PROTO_LCP) {
      log_Printf(LogPHASE, "%s: IPCP protocol reject closes IPCP !\n",
                fp->link->name);
      fsm_Close(&fp->bundle->ncp.ipcp.fsm);
    }
    break;
#ifndef NOINET6
  case PROTO_IPV6CP:
    if (fp->proto == PROTO_LCP) {
      log_Printf(LogPHASE, "%s: IPV6CP protocol reject closes IPV6CP !\n",
                fp->link->name);
      fsm_Close(&fp->bundle->ncp.ipv6cp.fsm);
    }
    break;
#endif
  case PROTO_MP:
    if (fp->proto == PROTO_LCP) {
      struct lcp *lcp = fsm2lcp(fp);

      if (lcp->want_mrru && lcp->his_mrru) {
        log_Printf(LogPHASE, "%s: MP protocol reject is fatal !\n",
                  fp->link->name);
        fsm_Close(fp);
      }
    }
    break;
  }
  m_freem(bp);
}

static void
FsmRecvEchoReq(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
{
  struct lcp *lcp = fsm2lcp(fp);
  u_char *cp;
  u_int32_t magic;

  bp = m_pullup(bp);
  m_settype(bp, MB_ECHOIN);

  if (lcp && ntohs(lhp->length) - sizeof *lhp >= 4) {
    cp = MBUF_CTOP(bp);
    ua_ntohl(cp, &magic);
    if (magic != lcp->his_magic) {
      log_Printf(fp->LogLevel, "%s: RecvEchoReq: magic 0x%08lx is wrong,"
                 " expecting 0x%08lx\n", fp->link->name, (u_long)magic,
                 (u_long)lcp->his_magic);
      /* XXX: We should send terminate request */
    }
    if (fp->state == ST_OPENED) {
      ua_htonl(&lcp->want_magic, cp);		/* local magic */
      fsm_Output(fp, CODE_ECHOREP, lhp->id, cp,
                 ntohs(lhp->length) - sizeof *lhp, MB_ECHOOUT);
    }
  }
  m_freem(bp);
}

static void
FsmRecvEchoRep(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
{
  if (fsm2lcp(fp))
    bp = lqr_RecvEcho(fp, bp);

  m_freem(bp);
}

static void
FsmRecvDiscReq(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
{
  m_freem(bp);
}

static void
FsmRecvIdent(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
{
  u_int32_t magic;
  u_short len;
  u_char *cp;

  len = ntohs(lhp->length) - sizeof *lhp;
  if (len >= 4) {
    bp = m_pullup(m_append(bp, "", 1));
    cp = MBUF_CTOP(bp);
    ua_ntohl(cp, &magic);
    if (magic != fp->link->lcp.his_magic)
      log_Printf(fp->LogLevel, "%s: RecvIdent: magic 0x%08lx is wrong,"
                 " expecting 0x%08lx\n", fp->link->name, (u_long)magic,
                 (u_long)fp->link->lcp.his_magic);
    cp[len] = '\0';
    lcp_RecvIdentification(&fp->link->lcp, cp + 4);
  }
  m_freem(bp);
}

static void
FsmRecvTimeRemain(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
{
  m_freem(bp);
}

static void
FsmRecvResetReq(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
{
  if ((*fp->fn->RecvResetReq)(fp)) {
    /*
     * All sendable compressed packets are queued in the first (lowest
     * priority) modem output queue.... dump 'em to the priority queue
     * so that they arrive at the peer before our ResetAck.
     */
    link_SequenceQueue(fp->link);
    fsm_Output(fp, CODE_RESETACK, lhp->id, NULL, 0, MB_CCPOUT);
  }
  m_freem(bp);
}

static void
FsmRecvResetAck(struct fsm *fp, struct fsmheader *lhp, struct mbuf *bp)
{
  (*fp->fn->RecvResetAck)(fp, lhp->id);
  m_freem(bp);
}

void
fsm_Input(struct fsm *fp, struct mbuf *bp)
{
  int len;
  struct fsmheader lh;
  const struct fsmcodedesc *codep;

  len = m_length(bp);
  if (len < sizeof(struct fsmheader)) {
    m_freem(bp);
    return;
  }
  bp = mbuf_Read(bp, &lh, sizeof lh);

  if (ntohs(lh.length) > len) {
    log_Printf(LogWARN, "%s: Oops: Got %d bytes but %d byte payload "
               "- dropped\n", fp->link->name, len, (int)ntohs(lh.length));
    m_freem(bp);
    return;
  }

  if (lh.code < fp->min_code || lh.code > fp->max_code ||
      lh.code > sizeof FsmCodes / sizeof *FsmCodes) {
    /*
     * Use a private id.  This is really a response-type packet, but we
     * MUST send a unique id for each REQ....
     */
    static u_char id;

    bp = m_prepend(bp, &lh, sizeof lh, 0);
    bp = m_pullup(bp);
    fsm_Output(fp, CODE_CODEREJ, id++, MBUF_CTOP(bp), bp->m_len, MB_UNKNOWN);
    m_freem(bp);
    return;
  }

  codep = FsmCodes + lh.code - 1;
  if (lh.id != fp->reqid && codep->check_reqid &&
      Enabled(fp->bundle, OPT_IDCHECK)) {
    log_Printf(fp->LogLevel, "%s: Recv%s(%d), dropped (expected %d)\n",
               fp->link->name, codep->name, lh.id, fp->reqid);
    return;
  }

  log_Printf(fp->LogLevel, "%s: Recv%s(%d) state = %s\n",
             fp->link->name, codep->name, lh.id, State2Nam(fp->state));

  if (codep->inc_reqid && (lh.id == fp->reqid ||
      (!Enabled(fp->bundle, OPT_IDCHECK) && codep->check_reqid)))
    fp->reqid++;	/* That's the end of that ``exchange''.... */

  (*codep->recv)(fp, &lh, bp);
}

int
fsm_NullRecvResetReq(struct fsm *fp)
{
  log_Printf(fp->LogLevel, "%s: Oops - received unexpected reset req\n",
            fp->link->name);
  return 1;
}

void
fsm_NullRecvResetAck(struct fsm *fp, u_char id)
{
  log_Printf(fp->LogLevel, "%s: Oops - received unexpected reset ack\n",
            fp->link->name);
}

void
fsm_Reopen(struct fsm *fp)
{
  if (fp->state == ST_OPENED) {
    (*fp->fn->LayerDown)(fp);
    FsmInitRestartCounter(fp, FSM_REQ_TIMER);
    FsmSendConfigReq(fp);
    NewState(fp, ST_REQSENT);
    (*fp->parent->LayerDown)(fp->parent->object, fp);
  }
}

void
fsm2initial(struct fsm *fp)
{
  timer_Stop(&fp->FsmTimer);
  timer_Stop(&fp->OpenTimer);
  timer_Stop(&fp->StoppedTimer);
  if (fp->state == ST_STOPPED)
    fsm_Close(fp);
  if (fp->state > ST_INITIAL)
    fsm_Down(fp);
  if (fp->state > ST_INITIAL)
    fsm_Close(fp);
}

struct fsm_opt *
fsm_readopt(u_char **cp)
{
  struct fsm_opt *o = (struct fsm_opt *)*cp;

  if (o->hdr.len < sizeof(struct fsm_opt_hdr)) {
    log_Printf(LogERROR, "Bad option length %d (out of phase?)\n", o->hdr.len);
    return NULL;
  }

  *cp += o->hdr.len;

  if (o->hdr.len > sizeof(struct fsm_opt)) {
    log_Printf(LogERROR, "Warning: Truncating option length from %d to %d\n",
               o->hdr.len, (int)sizeof(struct fsm_opt));
    o->hdr.len = sizeof(struct fsm_opt);
  }

  return o;
}

static int
fsm_opt(u_char *opt, int optlen, const struct fsm_opt *o)
{
  int cplen = o->hdr.len;

  if (optlen < sizeof(struct fsm_opt_hdr))
    optlen = 0;

  if (cplen > optlen) {
    log_Printf(LogERROR, "Can't REJ length %d - trunating to %d\n",
      cplen, optlen);
    cplen = optlen;
  }
  memcpy(opt, o, cplen);
  if (cplen)
    opt[1] = cplen;

  return cplen;
}

void
fsm_rej(struct fsm_decode *dec, const struct fsm_opt *o)
{
  if (!dec)
    return;
  dec->rejend += fsm_opt(dec->rejend, FSM_OPTLEN - (dec->rejend - dec->rej), o);
}

void
fsm_ack(struct fsm_decode *dec, const struct fsm_opt *o)
{
  if (!dec)
    return;
  dec->ackend += fsm_opt(dec->ackend, FSM_OPTLEN - (dec->ackend - dec->ack), o);
}

void
fsm_nak(struct fsm_decode *dec, const struct fsm_opt *o)
{
  if (!dec)
    return;
  dec->nakend += fsm_opt(dec->nakend, FSM_OPTLEN - (dec->nakend - dec->nak), o);
}

void
fsm_opt_normalise(struct fsm_decode *dec)
{
  if (dec->rejend != dec->rej) {
    /* rejects are preferred */
    dec->ackend = dec->ack;
    dec->nakend = dec->nak;
  } else if (dec->nakend != dec->nak)
    /* then NAKs */
    dec->ackend = dec->ack;
}
@


1.24
log
@Replace various spelling with FALLTHROUGH which is lint()able

From charnier FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: fsm.c,v 1.23 2002/06/15 08:02:41 brian Exp $
@


1.23
log
@Cast a format param
@
text
@d28 1
a28 1
 * $OpenBSD: fsm.c,v 1.22 2002/06/15 01:33:23 brian Exp $
d559 1
a559 1
    /* Fall through */
@


1.22
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d28 1
a28 1
 * $OpenBSD: fsm.c,v 1.21 2002/05/16 01:13:39 brian Exp $
d1147 2
a1148 2
    log_Printf(LogERROR, "Warning: Truncating option length from %d to %ld\n",
               o->hdr.len, sizeof(struct fsm_opt));
@


1.21
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: fsm.c,v 1.20 2002/03/31 02:38:49 brian Exp $
d1147 2
a1149 2
    log_Printf(LogERROR, "Warning: Truncating option length to %d\n",
               o->hdr.len);
@


1.20
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d28 1
a28 1
 * $OpenBSD: fsm.c,v 1.19 2001/08/19 23:22:17 brian Exp $
a53 1
#include "ip.h"
d172 1
a172 1
	    fp->link->name, State2Nam(fp->state), State2Nam(new));
d203 2
a204 2
        (*fp->fn->DecodeConfig)(fp, ptr, count, MODE_NOP, NULL);
        if (count < sizeof(struct fsmconfig))
d472 1
d474 1
d479 1
a479 1
	      fp->link->name, plen, flen);
d484 17
a531 17
  case ST_OPENED:
    (*fp->fn->LayerDown)(fp);
    break;
  }

  bp = m_pullup(bp);
  dec.ackend = dec.ack;
  dec.nakend = dec.nak;
  dec.rejend = dec.rej;
  (*fp->fn->DecodeConfig)(fp, MBUF_CTOP(bp), flen, MODE_REQ, &dec);
  if (flen < sizeof(struct fsmconfig))
    log_Printf(fp->LogLevel, "  [EMPTY]\n");

  if (dec.nakend == dec.nak && dec.rejend == dec.rej)
    ackaction = 1;

  switch (fp->state) {
d534 1
a534 2
    /* Fall through */

d612 20
d677 1
d711 3
a713 2
  (*fp->fn->DecodeConfig)(fp, MBUF_CTOP(bp), flen, MODE_NAK, &dec);
  if (flen < sizeof(struct fsmconfig))
d807 1
d843 3
a845 2
  (*fp->fn->DecodeConfig)(fp, MBUF_CTOP(bp), flen, MODE_REJ, &dec);
  if (flen < sizeof(struct fsmconfig))
d1079 1
a1079 1
	      fp->link->name, codep->name, lh.id, fp->reqid);
d1084 1
a1084 1
	    fp->link->name, codep->name, lh.id, State2Nam(fp->state));
d1132 77
@


1.19
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: fsm.c,v 1.18 2001/06/19 10:24:52 brian Exp $
d882 1
@


1.18
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d28 1
a28 1
 * $OpenBSD: fsm.c,v 1.17 2001/06/13 21:33:41 brian Exp $
d35 1
d53 2
d65 2
a515 1
    (*fp->parent->LayerDown)(fp->parent->object, fp);
d566 1
d897 9
@


1.17
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d981 9
a989 8
  (*fp->fn->RecvResetReq)(fp);
  /*
   * All sendable compressed packets are queued in the first (lowest
   * priority) modem output queue.... dump 'em to the priority queue
   * so that they arrive at the peer before our ResetAck.
   */
  link_SequenceQueue(fp->link);
  fsm_Output(fp, CODE_RESETACK, lhp->id, NULL, 0, MB_CCPOUT);
d1054 1
a1054 1
void
d1059 1
@


1.16
log
@If executing the stuff from ppp.linkdown results in a state change,
don't continue adjusting the ipcp state machine.

This allows ``down'' to work in ppp.linkdown - useful for a tunnel
setup.
@
text
@d1 5
a5 2
/*
 *		PPP Finite State Machine for LCP/IPCP
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 15
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: fsm.c,v 1.15 2000/07/19 11:06:33 brian Exp $
 *
 *  TODO:
@


1.15
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d20 1
a20 1
 * $OpenBSD: fsm.c,v 1.14 2000/06/13 09:57:51 brian Exp $
d352 6
a357 4
    FsmInitRestartCounter(fp, FSM_TRM_TIMER);
    FsmSendTerminateReq(fp);
    NewState(fp, ST_CLOSING);
    (*fp->parent->LayerDown)(fp->parent->object, fp);
@


1.14
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d20 1
a20 1
 * $OpenBSD: fsm.c,v 1.13 2000/02/27 01:38:26 brian Exp $
d89 1
a89 1
  { FsmRecvIdent,     0, 0, "Ident"        },
d211 3
d380 1
d569 1
d583 1
d590 1
d625 1
d780 2
d945 16
d1005 5
a1009 7
  if (ntohs(lh.length) != len) {
    if (ntohs(lh.length) > len) {
      log_Printf(LogWARN, "%s: Oops: Got %d bytes but %d byte payload "
                 "- dropped\n", fp->link->name, len, (int)ntohs(lh.length));
      m_freem(bp);
      return;
    }
@


1.13
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: fsm.c,v 1.12 2000/01/07 03:26:54 brian Exp $
d979 8
a986 3
  if (ntohs(lh.length) != len)
    log_Printf(LogWARN, "%s: Oops: Got %d bytes but %d byte payload\n",
               fp->link->name, len, (int)ntohs(lh.length));
@


1.12
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.11 1999/08/10 10:50:44 brian Exp $
@


1.11
log
@If we receive an IPCP protocol reject, bring it down.
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.10 1999/06/02 15:58:40 brian Exp $
d106 1
a106 1
  static const char *StateNames[] = {
d135 1
a135 1
         struct fsm_callbacks *fn, const char *timer_names[3])
d204 1
a204 1
  bp = mbuf_Alloc(plen, mtype);
d209 2
a210 1
  link_PushPacket(fp->link, bp, fp->bundle, PRI_LINK, fp->proto);
d457 1
a457 1
  plen = mbuf_Length(bp);
d462 1
a462 1
    mbuf_Free(bp);
d474 1
a474 1
      bp = mbuf_Prepend(bp, lhp, sizeof *lhp, 2);
d476 3
a478 3
      bp = mbuf_Contiguous(bp);
      lcp_SendProtoRej(&fp->link->lcp, MBUF_CTOP(bp), bp->cnt);
      mbuf_Free(bp);
d485 1
a485 1
    mbuf_Free(bp);
d489 1
a489 1
    mbuf_Free(bp);
d495 1
a495 1
    mbuf_Free(bp);
d503 1
a503 1
  bp = mbuf_Contiguous(bp);
d573 1
a573 1
  mbuf_Free(bp);
d627 1
a627 1
  mbuf_Free(bp);
d637 1
a637 1
  plen = mbuf_Length(bp);
d640 1
a640 1
    mbuf_Free(bp);
d652 1
a652 1
    mbuf_Free(bp);
d657 1
a657 1
    mbuf_Free(bp);
d661 1
a661 1
    mbuf_Free(bp);
d665 1
a665 1
  bp = mbuf_Contiguous(bp);
d691 1
a691 1
  mbuf_Free(bp);
d727 1
a727 1
  mbuf_Free(bp);
d755 1
a755 1
  mbuf_Free(bp);
d765 1
a765 1
  plen = mbuf_Length(bp);
d768 1
a768 1
    mbuf_Free(bp);
d780 1
a780 1
    mbuf_Free(bp);
d785 1
a785 1
    mbuf_Free(bp);
d789 1
a789 1
    mbuf_Free(bp);
d793 1
a793 1
  bp = mbuf_Contiguous(bp);
d818 1
a818 1
  mbuf_Free(bp);
d824 1
a824 1
  mbuf_Free(bp);
d833 2
a834 2
  if (mbuf_Length(bp) < 2) {
    mbuf_Free(bp);
d886 1
a886 1
  mbuf_Free(bp);
d896 4
a899 2
  mbuf_SetType(bp, MB_ECHOIN);
  if (lcp && mbuf_Length(bp) >= 4) {
d903 3
a905 2
      log_Printf(fp->LogLevel, "%s: RecvEchoReq: Error: His magic is bad!!\n",
                fp->link->name);
d910 2
a911 1
      fsm_Output(fp, CODE_ECHOREP, lhp->id, cp, mbuf_Length(bp), MB_ECHOOUT);
d914 1
a914 1
  mbuf_Free(bp);
d923 1
a923 1
  mbuf_Free(bp);
d929 1
a929 1
  mbuf_Free(bp);
d935 1
a935 1
  mbuf_Free(bp);
d941 1
a941 1
  mbuf_Free(bp);
d949 3
a951 3
   * All sendable compressed packets are queued in the PRI_NORMAL modem
   * output queue.... dump 'em to the priority queue so that they arrive
   * at the peer before our ResetAck.
d955 1
a955 1
  mbuf_Free(bp);
d962 1
a962 1
  mbuf_Free(bp);
d972 1
a972 1
  len = mbuf_Length(bp);
d974 1
a974 1
    mbuf_Free(bp);
d978 5
d991 4
a994 4
    bp = mbuf_Prepend(bp, &lh, sizeof lh, 0);
    bp = mbuf_Contiguous(bp);
    fsm_Output(fp, CODE_CODEREJ, id++, MBUF_CTOP(bp), bp->cnt, MB_UNKNOWN);
    mbuf_Free(bp);
@


1.10
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.9 1999/05/14 09:35:27 brian Exp $
d864 7
@


1.9
log
@Handle LCP echo reqs properly again (broken with the
layering changes).
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.8 1999/05/09 20:03:59 brian Exp $
d178 2
a179 1
fsm_Output(struct fsm *fp, u_int code, u_int id, u_char *ptr, int count)
d204 1
a204 1
  bp = mbuf_Alloc(plen, MB_FSM);
d383 1
a383 1
  fsm_Output(fp, CODE_TERMREQ, fp->reqid, NULL, 0);
d524 2
a525 1
    fsm_Output(fp, CODE_CONFIGREJ, lhp->id, dec.rej, dec.rejend - dec.rej);
d527 2
a528 1
    fsm_Output(fp, CODE_CONFIGNAK, lhp->id, dec.nak, dec.nakend - dec.nak);
d530 2
a531 1
    fsm_Output(fp, CODE_CONFIGACK, lhp->id, dec.ack, dec.ackend - dec.ack);
d888 1
d899 1
a899 1
      fsm_Output(fp, CODE_ECHOREP, lhp->id, cp, mbuf_Length(bp));
d942 1
a942 1
  fsm_Output(fp, CODE_RESETACK, lhp->id, NULL, 0);
d976 1
a976 1
    fsm_Output(fp, CODE_CODEREJ, id++, MBUF_CTOP(bp), bp->cnt);
a991 3
  if (log_IsKept(LogDEBUG))
    mbuf_Log();

a996 3

  if (log_IsKept(LogDEBUG))
    mbuf_Log();
@


1.8
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.7 1999/05/08 11:06:35 brian Exp $
d903 2
a904 2
  struct lcp *lcp = fsm2lcp(fp);
  u_int32_t magic;
a905 14
  if (lcp && mbuf_Length(bp) >= 4) {
    mbuf_Read(bp, &magic, 4);
    magic = ntohl(magic);
    /* Tolerate echo replies with either magic number */
    if (magic != 0 && magic != lcp->his_magic && magic != lcp->want_magic) {
      log_Printf(LogWARN, "%s: RecvEchoRep: Bad magic: expected 0x%08x,"
                 " got 0x%08x\n", fp->link->name, lcp->his_magic, magic);
      /*
       * XXX: We should send terminate request. But poor implementations may
       * die as a result.
       */
    }
    bp = lqr_RecvEcho(fp, bp);
  }
@


1.7
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.6 1999/03/29 08:20:32 brian Exp $
d159 1
a159 1
NewState(struct fsm * fp, int new)
d240 1
a240 1
fsm_Open(struct fsm * fp)
d278 1
a278 1
fsm_Up(struct fsm * fp)
d366 1
a366 1
FsmSendConfigReq(struct fsm * fp)
d445 1
a445 1
 *   Actions when receive packets
d464 1
a464 3
  /*
   * Check and process easy case
   */
a470 2
       *
       * this is a bit smelly... we know that bp has a leading fsmheader.
a501 1

d660 1
d726 1
a726 1
FsmRecvTermAck(struct fsm * fp, struct fsmheader * lhp, struct mbuf * bp)
d788 1
d826 1
a826 1
  u_short *sp, proto;
d828 6
a833 3
  bp = mbuf_Contiguous(bp);
  sp = (u_short *)MBUF_CTOP(bp);
  proto = ntohs(*sp);
d884 1
a884 1
  if (lcp) {
d906 3
a908 2
  if (lcp) {
    ua_ntohl(MBUF_CTOP(bp), &magic);
d911 2
a912 3
      log_Printf(LogWARN,
                "%s: RecvEchoRep: Bad magic: expected 0x%08x, got: 0x%08x\n",
	        fp->link->name, lcp->his_magic, magic);
d918 1
a918 1
    lqr_RecvEcho(fp, bp);
d924 1
a924 1
FsmRecvDiscReq(struct fsm * fp, struct fsmheader * lhp, struct mbuf * bp)
d930 1
a930 1
FsmRecvIdent(struct fsm * fp, struct fsmheader * lhp, struct mbuf * bp)
d936 1
a936 1
FsmRecvTimeRemain(struct fsm * fp, struct fsmheader * lhp, struct mbuf * bp)
@


1.6
log
@Ensure that the thing we're casting to struct ip
is aligned for non-i386 architectures.
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.5 1999/03/01 02:52:19 brian Exp $
d34 1
d59 1
a59 1
#include "lcpproto.h"
d91 1
a91 1
  { FsmRecvResetReq,  0, 0, "ResetReqt"    },
d144 1
a144 1
  fp->more.reqs = fp->more.naks = fp->more.rejs = 1;
d208 1
a208 1
  hdlc_Output(fp->link, PRI_LINK, fp->proto, bp);
d472 3
a474 4
       * & denying everything.  This is a bit smelly, we know that
       * ``bp'' really has ``fsmheader'' in front of it, and CCP_PROTO
       * in front of that.  CCP_PROTO isn't compressed either 'cos it
       * doesn't begin with 0x00....
d476 3
a478 2
      bp->offset -= sizeof(struct fsmheader) + 2;
      bp->cnt += sizeof(struct fsmheader) + 2;
d505 2
a581 1
    fsm_Close(fp);
d966 1
a966 1
  struct fsmheader *lhp;
d974 3
a976 3
  lhp = (struct fsmheader *) MBUF_CTOP(bp);
  if (lhp->code < fp->min_code || lhp->code > fp->max_code ||
      lhp->code > sizeof FsmCodes / sizeof *FsmCodes) {
d983 2
a988 2
  bp->offset += sizeof(struct fsmheader);
  bp->cnt -= sizeof(struct fsmheader);
d990 2
a991 2
  codep = FsmCodes + lhp->code - 1;
  if (lhp->id != fp->reqid && codep->check_reqid &&
d994 1
a994 1
	      fp->link->name, codep->name, lhp->id, fp->reqid);
d999 1
a999 1
	    fp->link->name, codep->name, lhp->id, State2Nam(fp->state));
d1004 1
a1004 1
  if (codep->inc_reqid && (lhp->id == fp->reqid ||
d1008 1
a1008 1
  (*codep->recv)(fp, lhp, bp);
@


1.5
log
@Comment why we do a TLF when we get a ``Down'' event in state
``closing''.

Pointed out by: archie

Don't do a TLF when we get a ``Catastrphic Protocol Reject'' event
in state ``closed'' or ``stopped''.

Pointed out but not suggested by: archie

This makes no difference in the current implementation as
LcpLayerFinish() does nothing but log the event, but I disagree
in principle because it unbalances the TLF/TLS calls which
(IMHO) doesn't fit with the intentions of the RFC.

Maybe the RFC author had a reason for this.  It can only happen
in two circumstances:

- if LCP has already been negotiated then stopped or closed and we
  receive a protocol reject, then we must already have done a TLF.
  Why do one again and stay in the same state ?

- if LCP hasn't yet been started and we receive an unsolicted
  protocol reject, why should we TLF when we haven't done a TLS ?
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.4 1999/02/26 21:28:22 brian Exp $
d829 1
@


1.4
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.3 1999/02/06 03:22:36 brian Exp $
d305 1
d845 2
a846 1
      (*fp->fn->LayerFinish)(fp);
d855 2
a856 1
      (*fp->parent->LayerFinish)(fp->parent->object, fp);
@


1.3
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.38 1999/01/28 01:56:31 brian Exp $
d62 1
a62 1
static void FsmInitRestartCounter(struct fsm *);
d132 1
a132 1
         int maxcode, int maxcfg, int LogLevel, struct bundle *bundle,
d143 1
a143 1
  fp->maxconfig = maxcfg;
d232 1
a232 1
    FsmInitRestartCounter(fp);
d286 1
a286 1
    FsmInitRestartCounter(fp);
d345 1
a345 1
    FsmInitRestartCounter(fp);
d353 1
a353 1
    FsmInitRestartCounter(fp);
d366 1
a366 1
  if (--fp->maxconfig > 0) {
d368 1
a368 2
    timer_Start(&fp->FsmTimer);	/* Start restart timer */
    fp->restart--;		/* Decrement restart counter */
d370 3
d434 1
a434 1
FsmInitRestartCounter(struct fsm * fp)
d438 2
a439 2
  fp->FsmTimer.arg = (void *) fp;
  (*fp->fn->InitRestartCounter)(fp);
d515 1
a515 1
    FsmInitRestartCounter(fp);
d531 10
a541 1
  case ST_STOPPED:
d558 1
a558 1
        FsmInitRestartCounter(fp);
d570 13
d598 1
a598 1
    FsmInitRestartCounter(fp);
d606 1
a606 1
    FsmInitRestartCounter(fp);
d612 1
a612 1
      FsmInitRestartCounter(fp);
d672 1
a672 1
    FsmInitRestartCounter(fp);
d715 2
a716 2
    FsmInitRestartCounter(fp);
    timer_Start(&fp->FsmTimer);	/* Start restart timer */
d720 1
d799 1
a799 1
    FsmInitRestartCounter(fp);
d1027 1
a1027 1
    FsmInitRestartCounter(fp);
d1037 3
@


1.2
log
@Don't cast potentially unaligned addresses to pointers to
non-char types on non-i386 architectures.
On Alpha and Sparc we get a bus error if we do.
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.1 1998/08/31 00:22:20 brian Exp $
d25 1
a25 1
#include <sys/types.h>
d52 3
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: fsm.c,v 1.36 1998/08/01 01:02:41 brian Exp $
d34 1
d852 1
a852 1
    magic = ntohl(*(u_int32_t *)cp);
d859 1
a859 1
      *(u_int32_t *)cp = htonl(lcp->want_magic); /* local magic */
d873 1
a873 1
    magic = ntohl(*(u_int32_t *)MBUF_CTOP(bp));
@

