head	1.22;
access;
symbols
	OPENBSD_5_5:1.21.0.28
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.24
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.22
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.20
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.18
	OPENBSD_5_0:1.21.0.16
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.14
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.12
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.8
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.10
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.14
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.12
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.10
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.8
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.6
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.6
	OPENBSD_2_8:1.14.0.4
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.21;

1.21
date	2007.09.11.16.30.59;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.02.18.27.29;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.07.01.36.02;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.13.21.33.40;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.27.01.38.24;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.07.03.26.52;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.06.08.20.12.23;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.05.08.11.06.33;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.03.31.14.22.10;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.02.26.21.28.18;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.02.20.01.15.12;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.02.19.10.49.20;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.02.18.00.50.44;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.02.06.03.22.31;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.02.02.09.49.57;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.01.13.50.27;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.12.17.00.28.39;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.16;	author brian;	state Exp;
branches;
next	;


desc
@@


1.22
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: auth.c,v 1.21 2007/09/11 16:30:59 gilles Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "mbuf.h"
#include "defs.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "iplist.h"
#include "throughput.h"
#include "slcompress.h"
#include "lqr.h"
#include "hdlc.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "auth.h"
#include "systems.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "descriptor.h"
#include "chat.h"
#include "proto.h"
#include "filter.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "cbcp.h"
#include "chap.h"
#include "async.h"
#include "physical.h"
#include "datalink.h"
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"

const char *
Auth2Nam(u_short auth, u_char type)
{
  static char chap[10];

  switch (auth) {
  case PROTO_PAP:
    return "PAP";
  case PROTO_CHAP:
    snprintf(chap, sizeof chap, "CHAP 0x%02x", type);
    return chap;
  case 0:
    return "none";
  }
  return "unknown";
}

static int
auth_CheckPasswd(const char *name, const char *data, const char *key)
{
  if (!strcmp(data, "*")) {
    /* Then look up the real password database */
    struct passwd *pw;
    int result;

    result = (pw = getpwnam(name)) &&
             !strcmp(crypt(key, pw->pw_passwd), pw->pw_passwd);
    endpwent();
    return result;
  }

  return !strcmp(data, key);
}

int
auth_SetPhoneList(const char *name, char *phone, int phonelen)
{
  FILE *fp;
  int n, lineno;
  char *vector[6], buff[LINE_LEN];
  const char *slash;

  fp = OpenSecret(SECRETFILE);
  if (fp != NULL) {
again:
    lineno = 0;
    while (fgets(buff, sizeof buff, fp)) {
      lineno++;
      if (buff[0] == '#')
        continue;
      buff[strcspn(buff, "\n")] = '\0';
      memset(vector, '\0', sizeof vector);
      if ((n = MakeArgs(buff, vector, VECSIZE(vector), PARSE_REDUCE)) < 0)
        log_Printf(LogWARN, "%s: %d: Invalid line\n", SECRETFILE, lineno);
      if (n < 5)
        continue;
      if (strcmp(vector[0], name) == 0) {
        CloseSecret(fp);
        if (*vector[4] == '\0')
          return 0;
        strncpy(phone, vector[4], phonelen - 1);
        phone[phonelen - 1] = '\0';
        return 1;		/* Valid */
      }
    }

    if ((slash = strrchr(name, '\\')) != NULL && slash[1]) {
      /* Look for the name without the leading domain */
      name = slash + 1;
      rewind(fp);
      goto again;
    }

    CloseSecret(fp);
  }
  *phone = '\0';
  return 0;
}

int
auth_Select(struct bundle *bundle, const char *name)
{
  FILE *fp;
  int n, lineno;
  char *vector[5], buff[LINE_LEN];
  const char *slash;

  if (*name == '\0') {
    ipcp_Setup(&bundle->ncp.ipcp, INADDR_NONE);
    return 1;
  }

#ifndef NORADIUS
  if (bundle->radius.valid && bundle->radius.ip.s_addr != INADDR_NONE &&
	bundle->radius.ip.s_addr != RADIUS_INADDR_POOL) {
    /* We've got a radius IP - it overrides everything */
    if (!ipcp_UseHisIPaddr(bundle, bundle->radius.ip))
      return 0;
    ipcp_Setup(&bundle->ncp.ipcp, bundle->radius.mask.s_addr);
    /* Continue with ppp.secret in case we've got a new label */
  }
#endif

  fp = OpenSecret(SECRETFILE);
  if (fp != NULL) {
again:
    lineno = 0;
    while (fgets(buff, sizeof buff, fp)) {
      lineno++;
      if (buff[0] == '#')
        continue;
      buff[strcspn(buff, "\n")] = '\0';
      memset(vector, '\0', sizeof vector);
      if ((n = MakeArgs(buff, vector, VECSIZE(vector), PARSE_REDUCE)) < 0)
        log_Printf(LogWARN, "%s: %d: Invalid line\n", SECRETFILE, lineno);
      if (n < 2)
        continue;
      if (strcmp(vector[0], name) == 0) {
        CloseSecret(fp);
#ifndef NORADIUS
        if (!bundle->radius.valid || bundle->radius.ip.s_addr == INADDR_NONE) {
#endif
          if (n > 2 && *vector[2] && strcmp(vector[2], "*") &&
              !ipcp_UseHisaddr(bundle, vector[2], 1))
            return 0;
          ipcp_Setup(&bundle->ncp.ipcp, INADDR_NONE);
#ifndef NORADIUS
        }
#endif
        if (n > 3 && *vector[3] && strcmp(vector[3], "*"))
          bundle_SetLabel(bundle, vector[3]);
        return 1;		/* Valid */
      }
    }

    if ((slash = strrchr(name, '\\')) != NULL && slash[1]) {
      /* Look for the name without the leading domain */
      name = slash + 1;
      rewind(fp);
      goto again;
    }

    CloseSecret(fp);
  }

#ifndef NOPASSWDAUTH
  /* Let 'em in anyway - they must have been in the passwd file */
  ipcp_Setup(&bundle->ncp.ipcp, INADDR_NONE);
  return 1;
#else
#ifndef NORADIUS
  if (bundle->radius.valid)
    return 1;
#endif

  /* Disappeared from ppp.secret ??? */
  return 0;
#endif
}

int
auth_Validate(struct bundle *bundle, const char *name,
             const char *key, struct physical *physical)
{
  /* Used by PAP routines */

  FILE *fp;
  int n, lineno;
  char *vector[5], buff[LINE_LEN];
  const char *slash;

  fp = OpenSecret(SECRETFILE);
again:
  lineno = 0;
  if (fp != NULL) {
    while (fgets(buff, sizeof buff, fp)) {
      lineno++;
      if (buff[0] == '#')
        continue;
      buff[strcspn(buff, "\n")] = '\0';
      memset(vector, '\0', sizeof vector);
      if ((n = MakeArgs(buff, vector, VECSIZE(vector), PARSE_REDUCE)) < 0)
        log_Printf(LogWARN, "%s: %d: Invalid line\n", SECRETFILE, lineno);
      if (n < 2)
        continue;
      if (strcmp(vector[0], name) == 0) {
        CloseSecret(fp);
        return auth_CheckPasswd(name, vector[1], key);
      }
    }
  }

  if ((slash = strrchr(name, '\\')) != NULL && slash[1]) {
    /* Look for the name without the leading domain */
    name = slash + 1;
    if (fp != NULL) {
      rewind(fp);
      goto again;
    }
  }

  if (fp != NULL)
    CloseSecret(fp);

#ifndef NOPASSWDAUTH
  if (Enabled(bundle, OPT_PASSWDAUTH))
    return auth_CheckPasswd(name, "*", key);
#endif

  return 0;			/* Invalid */
}

char *
auth_GetSecret(struct bundle *bundle, const char *name, int len,
              struct physical *physical)
{
  /* Used by CHAP routines */

  FILE *fp;
  int n, lineno;
  char *vector[5];
  const char *slash;
  static char buff[LINE_LEN];	/* vector[] will point here when returned */

  fp = OpenSecret(SECRETFILE);
  if (fp == NULL)
    return (NULL);

again:
  lineno = 0;
  while (fgets(buff, sizeof buff, fp)) {
    lineno++;
    if (buff[0] == '#')
      continue;
    /* Trim the '\n' */
    buff[strcspn(buff, "\n")] = '\0';
    memset(vector, '\0', sizeof vector);
    if ((n = MakeArgs(buff, vector, VECSIZE(vector), PARSE_REDUCE)) < 0)
      log_Printf(LogWARN, "%s: %d: Invalid line\n", SECRETFILE, lineno);
    if (n < 2)
      continue;
    if (strlen(vector[0]) == len && strncmp(vector[0], name, len) == 0) {
      CloseSecret(fp);
      return vector[1];
    }
  }

  if ((slash = strrchr(name, '\\')) != NULL && slash[1]) {
    /* Go back and look for the name without the leading domain */
    len -= slash - name + 1;
    name = slash + 1;
    rewind(fp);
    goto again;
  }

  CloseSecret(fp);
  return (NULL);		/* Invalid */
}

static void
AuthTimeout(void *vauthp)
{
  struct authinfo *authp = (struct authinfo *)vauthp;

  timer_Stop(&authp->authtimer);
  if (--authp->retry > 0) {
    authp->id++;
    (*authp->fn.req)(authp);
    timer_Start(&authp->authtimer);
  } else {
    log_Printf(LogPHASE, "Auth: No response from server\n");
    datalink_AuthNotOk(authp->physical->dl);
  }
}

void
auth_Init(struct authinfo *authp, struct physical *p, auth_func req,
          auth_func success, auth_func failure)
{
  memset(authp, '\0', sizeof(struct authinfo));
  authp->cfg.fsm.timeout = DEF_FSMRETRY;
  authp->cfg.fsm.maxreq = DEF_FSMAUTHTRIES;
  authp->cfg.fsm.maxtrm = 0;	/* not used */
  authp->fn.req = req;
  authp->fn.success = success;
  authp->fn.failure = failure;
  authp->physical = p;
}

void
auth_StartReq(struct authinfo *authp)
{
  timer_Stop(&authp->authtimer);
  authp->authtimer.func = AuthTimeout;
  authp->authtimer.name = "auth";
  authp->authtimer.load = authp->cfg.fsm.timeout * SECTICKS;
  authp->authtimer.arg = (void *)authp;
  authp->retry = authp->cfg.fsm.maxreq;
  authp->id = 1;
  (*authp->fn.req)(authp);
  timer_Start(&authp->authtimer);
}

void
auth_StopTimer(struct authinfo *authp)
{
  timer_Stop(&authp->authtimer);
}

struct mbuf *
auth_ReadHeader(struct authinfo *authp, struct mbuf *bp)
{
  int len;

  len = m_length(bp);
  if (len >= sizeof authp->in.hdr) {
    bp = mbuf_Read(bp, (u_char *)&authp->in.hdr, sizeof authp->in.hdr);
    if (len >= ntohs(authp->in.hdr.length))
      return bp;
    authp->in.hdr.length = htons(0);
    log_Printf(LogWARN, "auth_ReadHeader: Short packet (%d > %d) !\n",
               ntohs(authp->in.hdr.length), len);
  } else {
    authp->in.hdr.length = htons(0);
    log_Printf(LogWARN, "auth_ReadHeader: Short packet header (%d > %d) !\n",
               (int)(sizeof authp->in.hdr), len);
  }

  m_freem(bp);
  return NULL;
}

struct mbuf *
auth_ReadName(struct authinfo *authp, struct mbuf *bp, int len)
{
  if (len > sizeof authp->in.name - 1)
    log_Printf(LogWARN, "auth_ReadName: Name too long (%d) !\n", len);
  else {
    int mlen = m_length(bp);

    if (len > mlen)
      log_Printf(LogWARN, "auth_ReadName: Short packet (%d > %d) !\n",
                 len, mlen);
    else {
      bp = mbuf_Read(bp, (u_char *)authp->in.name, len);
      authp->in.name[len] = '\0';
      return bp;
    }
  }

  *authp->in.name = '\0';
  m_freem(bp);
  return NULL;
}
@


1.21
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d28 1
a28 1
 * $OpenBSD: auth.c,v 1.20 2006/11/02 18:27:29 ray Exp $
@


1.20
log
@Check that last character is a newline before truncating; prevents
negative index array access.

OK moritz@@.
@
text
@d28 1
a28 1
 * $OpenBSD: auth.c,v 1.19 2005/09/07 01:36:02 brad Exp $
a126 2
      char *p;

d130 1
a130 2
      if ((p = strchr(buff, '\n')) != NULL)
	*p = '\0';
a187 2
      char *p;

d191 1
a191 2
      if ((p = strchr(buff, '\n')) != NULL)
	*p = '\0';
a255 2
      char *p;

d259 1
a259 2
      if ((p = strchr(buff, '\n')) != NULL)
	*p = '\0';
a310 2
    char *p;

d315 1
a315 2
    if ((p = strchr(buff, '\n')) != NULL)
      *p = '\0';
@


1.19
log
@add stdlib.h
@
text
@d28 1
a28 1
 * $OpenBSD: auth.c,v 1.18 2002/05/16 01:13:39 brian Exp $
d127 2
d132 2
a133 1
      buff[strlen(buff) - 1] = '\0';
d191 2
d196 2
a197 1
      buff[strlen(buff) - 1] = '\0';
d262 2
d267 2
a268 1
      buff[strlen(buff) - 1] = 0;
d320 2
d325 3
a327 3
    n = strlen(buff) - 1;
    if (buff[n] == '\n')
      buff[n] = '\0';	/* Trim the '\n' */
@


1.18
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: auth.c,v 1.17 2002/03/31 02:38:49 brian Exp $
d40 1
@


1.17
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d28 1
a28 1
 * $OpenBSD: auth.c,v 1.16 2001/08/19 23:22:17 brian Exp $
a55 1
#include "ip.h"
d172 2
a173 1
  if (bundle->radius.valid && bundle->radius.ip.s_addr != INADDR_NONE) {
@


1.16
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: auth.c,v 1.15 2001/06/13 21:33:40 brian Exp $
d119 2
a120 2
  char *vector[6];
  char buff[LINE_LEN];
a122 1
  lineno = 0;
d124 2
d145 8
d164 2
a165 2
  char *vector[5];
  char buff[LINE_LEN];
a182 1
  lineno = 0;
d184 2
d213 8
d247 2
a248 2
  char *vector[5];
  char buff[LINE_LEN];
d251 1
d269 12
a281 1
  }
d300 1
d307 1
d326 9
@


1.15
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d35 1
d55 2
d76 2
@


1.14
log
@$Id$ -> $OpenBSD$
@
text
@d1 5
a5 2
/*
 *			PPP Secret Key Module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1994, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 16
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: auth.c,v 1.13 2000/01/07 03:26:52 brian Exp $
 *
 *	TODO:
 *		o Implement check against with registered IP addresses.
d30 1
@


1.13
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.12 1999/06/08 20:12:23 brian Exp $
@


1.12
log
@Don't drop the last character from lines in ppp.secret unless it's '\n'.
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.11 1999/05/08 11:06:33 brian Exp $
d107 1
a107 1
  int n;
d112 1
d115 1
d120 2
a121 1
      n = MakeArgs(buff, vector, VECSIZE(vector));
d143 1
a143 1
  int n;
d163 1
d166 1
d171 2
a172 1
      n = MakeArgs(buff, vector, VECSIZE(vector));
d217 1
a217 1
  int n;
d222 1
d225 1
d230 2
a231 1
      n = MakeArgs(buff, vector, VECSIZE(vector));
d257 1
a257 1
  int n;
d265 1
d267 1
d274 2
a275 1
    n = MakeArgs(buff, vector, VECSIZE(vector));
d342 1
a342 1
  len = mbuf_Length(bp);
d356 1
a356 1
  mbuf_Free(bp);
d366 1
a366 1
    int mlen = mbuf_Length(bp);
d379 1
a379 1
  mbuf_Free(bp);
@


1.11
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.10 1999/03/31 14:22:10 brian Exp $
d250 1
a250 1
  static char buff[LINE_LEN];
d259 3
a261 1
    buff[strlen(buff) - 1] = 0;
@


1.10
log
@Avoid a few warnings on the alpha
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.9 1999/02/26 21:28:18 brian Exp $
d37 1
d56 1
a56 1
#include "lcpproto.h"
@


1.9
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.8 1999/02/20 01:15:12 brian Exp $
d338 1
a338 1
               sizeof authp->in.hdr, len);
@


1.8
log
@Handle empty PAP & CHAP packets (containing only an FSM header).
Some CHAP implementations send no welcome message with their
SUCCESS/FAILURE packets.  This was being mis-identified as
a truncated packet by the new authentication code :-(
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.7 1999/02/19 10:49:20 brian Exp $
d293 3
a295 1
  authp->cfg.fsmretry = DEF_FSMRETRY;
d308 1
a308 1
  authp->authtimer.load = authp->cfg.fsmretry * SECTICKS;
d310 1
a310 1
  authp->retry = 3;
@


1.7
log
@Be a little more verbose about dodgy looking authentication
packets before dropping them in the bit-bucket.
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.6 1999/02/18 00:50:44 brian Exp $
d330 1
d333 2
a334 1
  } else
d337 1
@


1.6
log
@Fully support both NT and LANMan CHAP type 0x80 as both
authenticator and authenticatee.
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.5 1999/02/06 03:22:31 brian Exp $
d330 5
a334 1
  }
d344 1
a344 1
    log_Printf(LogERROR, "auth_ReadName: Name too long (%d) !\n", len);
d349 2
a350 1
      log_Printf(LogERROR, "auth_ReadName: Short packet !\n");
@


1.5
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.37 1999/02/02 09:35:17 brian Exp $
d69 1
a69 1
Auth2Nam(u_short auth)
d71 2
d77 2
a78 1
    return "CHAP";
@


1.4
log
@Reimplement the previous fix (no response to PAP requests)
at the authentication layer rather than at the PAP layer
so that it also applies to CHAP (no response to CHAP
challenges).
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.3 1999/02/01 13:50:27 brian Exp $
d25 1
a25 1
#include <sys/types.h>
d58 3
d118 2
a119 2
	CloseSecret(fp);
	if (*vector[4] == '\0')
d123 1
a123 1
	return 1;		/* Valid */
d141 1
a141 1
    ipcp_Setup(&bundle->ncp.ipcp);
d145 10
d166 14
a179 8
	CloseSecret(fp);
	if (n > 2 && *vector[2] && strcmp(vector[2], "*") &&
            !ipcp_UseHisaddr(bundle, vector[2], 1))
	  return 0;
	ipcp_Setup(&bundle->ncp.ipcp);
	if (n > 3 && *vector[3] && strcmp(vector[3], "*"))
	  bundle_SetLabel(bundle, vector[3]);
	return 1;		/* Valid */
d187 1
a187 1
  ipcp_Setup(&bundle->ncp.ipcp);
d190 6
a195 1
  /* Disappeared from ppp.secret ? */
d201 1
a201 1
auth_Validate(struct bundle *bundle, const char *system,
d221 3
a223 3
      if (strcmp(vector[0], system) == 0) {
	CloseSecret(fp);
        return auth_CheckPasswd(vector[0], vector[1], key);
d231 1
a231 1
    return auth_CheckPasswd(system, "*", key);
d238 1
a238 1
auth_GetSecret(struct bundle *bundle, const char *system, int len,
d260 1
a260 1
    if (strlen(vector[0]) == len && strncmp(vector[0], system, len) == 0) {
d276 2
a278 1
    (*authp->ChallengeFunc)(authp, ++authp->id, authp->physical);
d286 2
a287 1
auth_Init(struct authinfo *authinfo)
d289 6
a294 2
  memset(authinfo, '\0', sizeof(struct authinfo));
  authinfo->cfg.fsmretry = DEF_FSMRETRY;
d298 1
a298 2
auth_StartChallenge(struct authinfo *authp, struct physical *physical,
                   void (*chal)(struct authinfo *, int, struct physical *))
a299 2
  authp->ChallengeFunc = chal;
  authp->physical = physical;
d304 1
a304 1
  authp->authtimer.arg = (void *) authp;
d307 1
a307 1
  (*authp->ChallengeFunc)(authp, authp->id, physical);
d315 38
a352 1
  authp->physical = NULL;
@


1.3
log
@If we receive no answer from the server when sending PAP
requests, give up (don't sit there indefinitely).
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.2 1998/12/17 00:28:39 brian Exp $
d34 1
d39 1
d58 5
d254 4
a257 2
  } else if (authp->FailedFunc)
    (*authp->FailedFunc)(authp->physical);
d269 1
a269 2
                   void (*chal)(struct authinfo *, int, struct physical *),
                   void (*fail)(struct physical *))
a271 1
  authp->FailedFunc = fail;
@


1.2
log
@Don't return stack-based data.  This may have caused
server-side CHAP authentication problems in the past :-/
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.1 1998/08/31 00:22:16 brian Exp $
d247 2
a248 1
  }
d260 2
a261 1
                   void (*fn)(struct authinfo *, int, struct physical *))
d263 2
a264 1
  authp->ChallengeFunc = fn;
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: auth.c,v 1.33 1998/08/26 17:39:36 brian Exp $
d215 1
a215 1
  char buff[LINE_LEN];
@

