head	1.46;
access;
symbols
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.44.0.32
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.30
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.28
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.26
	OPENBSD_5_0:1.44.0.24
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.44.0.22
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.20
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.16
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.18
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.14
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.12
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.44.0.10
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.44.0.8
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.44.0.6
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.44.0.4
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.39.0.4
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.2
	OPENBSD_3_6_BASE:1.39
	OPENBSD_3_5:1.38.0.4
	OPENBSD_3_5_BASE:1.38
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	OPENBSD_3_3:1.37.0.4
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.34.0.2
	OPENBSD_3_1_BASE:1.34
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.46
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.45;

1.45
date	2014.01.17.23.13.49;	author tobias;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.21.16.58.34;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2005.09.21.16.28.47;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.21.01.43.07;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.17.19.13.24;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.12.01.47.21;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.26.20.12.48;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.28.17.36.56;	author beck;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.16.14.13.06;	author brian;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.28.11.33.05;	author brian;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.04.16.09.29;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.05.02.24.05;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.24.01.06.00;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.02.22.12.41;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.28.22.44.41;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.19.11.06.34;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.19.10.33.33;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.03.21.52.57;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.27.01.38.26;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.27.00.21.08;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	99.08.05.10.32.14;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	99.06.08.20.12.30;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	99.06.08.11.59.00;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	99.06.02.15.58.40;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	99.05.31.23.57.37;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	99.05.09.20.04.00;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.05.08.11.06.35;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.04.26.08.55.01;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.04.26.08.54.50;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.03.03.23.01.10;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.02.26.21.28.22;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.02.06.03.22.39;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.02.04.11.54.47;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	98.10.29.02.21.45;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	98.09.04.18.42.08;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.09.04.18.27.46;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.08.31.08.16.39;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.21;	author brian;	state Exp;
branches;
next	;


desc
@@


1.46
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: ipcp.c,v 1.45 2014/01/17 23:13:49 tobias Exp $
 */

#include <sys/param.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <net/if.h>
#include <net/route.h>
#include <netdb.h>
#include <sys/un.h>

#include <errno.h>
#include <fcntl.h>
#include <resolv.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <termios.h>
#include <unistd.h>

#ifndef NONAT
#ifdef LOCALNAT
#include "alias.h"
#else
#include <alias.h>
#endif
#endif

#include "layer.h"
#include "ua.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "proto.h"
#include "iplist.h"
#include "throughput.h"
#include "slcompress.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "ncpaddr.h"
#include "ip.h"
#include "ipcp.h"
#include "filter.h"
#include "descriptor.h"
#include "vjcomp.h"
#include "async.h"
#include "ccp.h"
#include "link.h"
#include "physical.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "id.h"
#include "arp.h"
#include "systems.h"
#include "prompt.h"
#include "route.h"
#include "iface.h"

#undef REJECTED
#define	REJECTED(p, x)	((p)->peer_reject & (1<<(x)))
#define issep(ch) ((ch) == ' ' || (ch) == '\t')
#define isip(ch) (((ch) >= '0' && (ch) <= '9') || (ch) == '.')

struct compreq {
  u_short proto;
  u_char slots;
  u_char compcid;
};

static int IpcpLayerUp(struct fsm *);
static void IpcpLayerDown(struct fsm *);
static void IpcpLayerStart(struct fsm *);
static void IpcpLayerFinish(struct fsm *);
static void IpcpInitRestartCounter(struct fsm *, int);
static void IpcpSendConfigReq(struct fsm *);
static void IpcpSentTerminateReq(struct fsm *);
static void IpcpSendTerminateAck(struct fsm *, u_char);
static void IpcpDecodeConfig(struct fsm *, u_char *, u_char *, int,
                             struct fsm_decode *);

static struct fsm_callbacks ipcp_Callbacks = {
  IpcpLayerUp,
  IpcpLayerDown,
  IpcpLayerStart,
  IpcpLayerFinish,
  IpcpInitRestartCounter,
  IpcpSendConfigReq,
  IpcpSentTerminateReq,
  IpcpSendTerminateAck,
  IpcpDecodeConfig,
  fsm_NullRecvResetReq,
  fsm_NullRecvResetAck
};

static const char *
protoname(int proto)
{
  static struct {
    int id;
    const char *txt;
  } cftypes[] = {
    /* Check out the latest ``Assigned numbers'' rfc (rfc1700.txt) */
    { 1, "IPADDRS" },		/* IP-Addresses */	/* deprecated */
    { 2, "COMPPROTO" },		/* IP-Compression-Protocol */
    { 3, "IPADDR" },		/* IP-Address */
    { 129, "PRIDNS" },		/* 129: Primary DNS Server Address */
    { 130, "PRINBNS" },		/* 130: Primary NBNS Server Address */
    { 131, "SECDNS" },		/* 131: Secondary DNS Server Address */
    { 132, "SECNBNS" }		/* 132: Secondary NBNS Server Address */
  };
  int f;

  for (f = 0; f < sizeof cftypes / sizeof *cftypes; f++)
    if (cftypes[f].id == proto)
      return cftypes[f].txt;

  return NumStr(proto, NULL, 0);
}

void
ipcp_AddInOctets(struct ipcp *ipcp, int n)
{
  throughput_addin(&ipcp->throughput, n);
}

void
ipcp_AddOutOctets(struct ipcp *ipcp, int n)
{
  throughput_addout(&ipcp->throughput, n);
}

void
ipcp_LoadDNS(struct ipcp *ipcp)
{
  int fd;

  ipcp->ns.dns[0].s_addr = ipcp->ns.dns[1].s_addr = INADDR_NONE;

  if (ipcp->ns.resolv != NULL) {
    free(ipcp->ns.resolv);
    ipcp->ns.resolv = NULL;
  }
  if (ipcp->ns.resolv_nons != NULL) {
    free(ipcp->ns.resolv_nons);
    ipcp->ns.resolv_nons = NULL;
  }
  ipcp->ns.resolver = 0;

  if ((fd = open(_PATH_RESCONF, O_RDONLY)) != -1) {
    struct stat st;

    if (fstat(fd, &st) == 0) {
      ssize_t got;

      if (st.st_size >= SIZE_MAX)
        log_Printf(LogERROR, "%s is too large: %llu\n",
                   _PATH_RESCONF, (unsigned long long)st.st_size);
      else if ((ipcp->ns.resolv_nons = (char *)malloc(st.st_size + 1)) == NULL)
        log_Printf(LogERROR, "Failed to malloc %lu for %s: %s\n",
                   (unsigned long)st.st_size, _PATH_RESCONF, strerror(errno));
      else if ((ipcp->ns.resolv = (char *)malloc(st.st_size + 1)) == NULL) {
        log_Printf(LogERROR, "Failed(2) to malloc %lu for %s: %s\n",
                   (unsigned long)st.st_size, _PATH_RESCONF, strerror(errno));
        free(ipcp->ns.resolv_nons);
        ipcp->ns.resolv_nons = NULL;
      } else if ((got = read(fd, ipcp->ns.resolv, st.st_size)) != st.st_size) {
        if (got == -1)
          log_Printf(LogERROR, "Failed to read %s: %s\n",
                     _PATH_RESCONF, strerror(errno));
        else
          log_Printf(LogERROR, "Failed to read %s, got %lu not %lu\n",
                     _PATH_RESCONF, (unsigned long)got,
                     (unsigned long)st.st_size);
        free(ipcp->ns.resolv_nons);
        ipcp->ns.resolv_nons = NULL;
        free(ipcp->ns.resolv);
        ipcp->ns.resolv = NULL;
      } else {
        char *cp, *cp_nons, *ncp, ch;
        int n;

        ipcp->ns.resolv[st.st_size] = '\0';
        ipcp->ns.resolver = 1;

        cp_nons = ipcp->ns.resolv_nons;
        cp = ipcp->ns.resolv;
        n = 0;

        while ((ncp = strstr(cp, "nameserver")) != NULL) {
          if (ncp != cp) {
            memcpy(cp_nons, cp, ncp - cp);
            cp_nons += ncp - cp;
          }
          if ((ncp != cp && ncp[-1] != '\n') || !issep(ncp[10])) {
            memcpy(cp_nons, ncp, 9);
            cp_nons += 9;
            cp = ncp + 9;	/* Can't match "nameserver" at cp... */
            continue;
          }

          for (cp = ncp + 11; issep(*cp); cp++)	/* Skip whitespace */
            ;

          for (ncp = cp; isip(*ncp); ncp++)		/* Jump over IP */
            ;

          ch = *ncp;
          *ncp = '\0';
          if (n < 2 && inet_aton(cp, ipcp->ns.dns))
            n++;
          *ncp = ch;

          if ((cp = strchr(ncp, '\n')) == NULL)	/* Point at next line */
            cp = ncp + strlen(ncp);
          else
            cp++;
        }
        strlcpy(cp_nons, cp, st.st_size + 1 - (cp_nons - 
	    ipcp->ns.resolv_nons)); /* Copy the end - including the NUL */
        cp_nons += strlen(cp_nons) - 1;
        while (cp_nons >= ipcp->ns.resolv_nons && *cp_nons == '\n')
          *cp_nons-- = '\0';
        if (n == 2 && ipcp->ns.dns[0].s_addr == INADDR_ANY) {
          ipcp->ns.dns[0].s_addr = ipcp->ns.dns[1].s_addr;
          ipcp->ns.dns[1].s_addr = INADDR_ANY;
        }
        bundle_AdjustDNS(ipcp->fsm.bundle);
      }
    } else
      log_Printf(LogERROR, "Failed to stat opened %s: %s\n",
                 _PATH_RESCONF, strerror(errno));

    close(fd);
  }
}

int
ipcp_WriteDNS(struct ipcp *ipcp)
{
  const char *paddr;
  mode_t mask;
  FILE *fp;

  if (ipcp->ns.dns[0].s_addr == INADDR_ANY &&
      ipcp->ns.dns[1].s_addr == INADDR_ANY) {
    log_Printf(LogIPCP, "%s not modified: All nameservers NAKd\n",
              _PATH_RESCONF);
    return 0;
  }

  if (ipcp->ns.dns[0].s_addr == INADDR_ANY) {
    ipcp->ns.dns[0].s_addr = ipcp->ns.dns[1].s_addr;
    ipcp->ns.dns[1].s_addr = INADDR_ANY;
  }

  mask = umask(022);
  if ((fp = ID0fopen(_PATH_RESCONF, "w")) != NULL) {
    umask(mask);
    if (ipcp->ns.resolv_nons)
      fputs(ipcp->ns.resolv_nons, fp);
    paddr = inet_ntoa(ipcp->ns.dns[0]);
    log_Printf(LogIPCP, "Primary nameserver set to %s\n", paddr);
    fprintf(fp, "\nnameserver %s\n", paddr);
    if (ipcp->ns.dns[1].s_addr != INADDR_ANY &&
        ipcp->ns.dns[1].s_addr != INADDR_NONE &&
        ipcp->ns.dns[1].s_addr != ipcp->ns.dns[0].s_addr) {
      paddr = inet_ntoa(ipcp->ns.dns[1]);
      log_Printf(LogIPCP, "Secondary nameserver set to %s\n", paddr);
      fprintf(fp, "nameserver %s\n", paddr);
    }
    if (fclose(fp) == EOF) {
      log_Printf(LogERROR, "write(): Failed updating %s: %s\n", _PATH_RESCONF,
                 strerror(errno));
      return 0;
    }
  } else
    umask(mask);

  return 1;
}

void
ipcp_RestoreDNS(struct ipcp *ipcp)
{
  if (ipcp->ns.resolver) {
    ssize_t got;
    size_t len;
    int fd;

    if ((fd = ID0open(_PATH_RESCONF, O_WRONLY|O_TRUNC, 0644)) != -1) {
      len = strlen(ipcp->ns.resolv);
      if ((got = write(fd, ipcp->ns.resolv, len)) != len) {
        if (got == -1)
          log_Printf(LogERROR, "Failed rewriting %s: write: %s\n",
                     _PATH_RESCONF, strerror(errno));
        else
          log_Printf(LogERROR, "Failed rewriting %s: wrote %lu of %lu\n",
                     _PATH_RESCONF, (unsigned long)got, (unsigned long)len);
      }
      close(fd);
    } else
      log_Printf(LogERROR, "Failed rewriting %s: open: %s\n", _PATH_RESCONF,
                 strerror(errno));
  } else if (remove(_PATH_RESCONF) == -1)
    log_Printf(LogERROR, "Failed removing %s: %s\n", _PATH_RESCONF,
               strerror(errno));

}

int
ipcp_Show(struct cmdargs const *arg)
{
  struct ipcp *ipcp = &arg->bundle->ncp.ipcp;

  prompt_Printf(arg->prompt, "%s [%s]\n", ipcp->fsm.name,
                State2Nam(ipcp->fsm.state));
  if (ipcp->fsm.state == ST_OPENED) {
    prompt_Printf(arg->prompt, " His side:        %s, %s\n",
                  inet_ntoa(ipcp->peer_ip), vj2asc(ipcp->peer_compproto));
    prompt_Printf(arg->prompt, " My side:         %s, %s\n",
                  inet_ntoa(ipcp->my_ip), vj2asc(ipcp->my_compproto));
    prompt_Printf(arg->prompt, " Queued packets:  %lu\n",
                  (unsigned long)ipcp_QueueLen(ipcp));
  }

  prompt_Printf(arg->prompt, "\nDefaults:\n");
  prompt_Printf(arg->prompt, " FSM retry = %us, max %u Config"
                " REQ%s, %u Term REQ%s\n", ipcp->cfg.fsm.timeout,
                ipcp->cfg.fsm.maxreq, ipcp->cfg.fsm.maxreq == 1 ? "" : "s",
                ipcp->cfg.fsm.maxtrm, ipcp->cfg.fsm.maxtrm == 1 ? "" : "s");
  prompt_Printf(arg->prompt, " My Address:      %s\n",
                ncprange_ntoa(&ipcp->cfg.my_range));
  if (ipcp->cfg.HaveTriggerAddress)
    prompt_Printf(arg->prompt, " Trigger address: %s\n",
                  inet_ntoa(ipcp->cfg.TriggerAddress));

  prompt_Printf(arg->prompt, " VJ compression:  %s (%d slots %s slot "
                "compression)\n", command_ShowNegval(ipcp->cfg.vj.neg),
                ipcp->cfg.vj.slots, ipcp->cfg.vj.slotcomp ? "with" : "without");

  if (iplist_isvalid(&ipcp->cfg.peer_list))
    prompt_Printf(arg->prompt, " His Address:     %s\n",
                  ipcp->cfg.peer_list.src);
  else
    prompt_Printf(arg->prompt, " His Address:     %s\n",
                  ncprange_ntoa(&ipcp->cfg.peer_range));

  prompt_Printf(arg->prompt, " DNS:             %s",
                ipcp->cfg.ns.dns[0].s_addr == INADDR_NONE ?
                "none" : inet_ntoa(ipcp->cfg.ns.dns[0]));
  if (ipcp->cfg.ns.dns[1].s_addr != INADDR_NONE)
    prompt_Printf(arg->prompt, ", %s",
                  inet_ntoa(ipcp->cfg.ns.dns[1]));
  prompt_Printf(arg->prompt, ", %s\n",
                command_ShowNegval(ipcp->cfg.ns.dns_neg));
  prompt_Printf(arg->prompt, " Resolver DNS:    %s",
                ipcp->ns.dns[0].s_addr == INADDR_NONE ?
                "none" : inet_ntoa(ipcp->ns.dns[0]));
  if (ipcp->ns.dns[1].s_addr != INADDR_NONE &&
      ipcp->ns.dns[1].s_addr != ipcp->ns.dns[0].s_addr)
    prompt_Printf(arg->prompt, ", %s",
                  inet_ntoa(ipcp->ns.dns[1]));
  prompt_Printf(arg->prompt, "\n NetBIOS NS:      %s, ",
                inet_ntoa(ipcp->cfg.ns.nbns[0]));
  prompt_Printf(arg->prompt, "%s\n\n",
                inet_ntoa(ipcp->cfg.ns.nbns[1]));

  throughput_disp(&ipcp->throughput, arg->prompt);

  return 0;
}

int
ipcp_vjset(struct cmdargs const *arg)
{
  if (arg->argc != arg->argn+2)
    return -1;
  if (!strcasecmp(arg->argv[arg->argn], "slots")) {
    int slots;

    slots = atoi(arg->argv[arg->argn+1]);
    if (slots < 4 || slots > 16)
      return 1;
    arg->bundle->ncp.ipcp.cfg.vj.slots = slots;
    return 0;
  } else if (!strcasecmp(arg->argv[arg->argn], "slotcomp")) {
    if (!strcasecmp(arg->argv[arg->argn+1], "on"))
      arg->bundle->ncp.ipcp.cfg.vj.slotcomp = 1;
    else if (!strcasecmp(arg->argv[arg->argn+1], "off"))
      arg->bundle->ncp.ipcp.cfg.vj.slotcomp = 0;
    else
      return 2;
    return 0;
  }
  return -1;
}

void
ipcp_Init(struct ipcp *ipcp, struct bundle *bundle, struct link *l,
          const struct fsm_parent *parent)
{
  struct hostent *hp;
  struct in_addr host;
  char name[MAXHOSTNAMELEN];
  static const char * const timer_names[] =
    {"IPCP restart", "IPCP openmode", "IPCP stopped"};

  fsm_Init(&ipcp->fsm, "IPCP", PROTO_IPCP, 1, IPCP_MAXCODE, LogIPCP,
           bundle, l, parent, &ipcp_Callbacks, timer_names);

  ipcp->cfg.vj.slots = DEF_VJ_STATES;
  ipcp->cfg.vj.slotcomp = 1;
  memset(&ipcp->cfg.my_range, '\0', sizeof ipcp->cfg.my_range);

  host.s_addr = htonl(INADDR_LOOPBACK);
  ipcp->cfg.netmask.s_addr = INADDR_ANY;
  if (gethostname(name, sizeof name) == 0) {
    hp = gethostbyname(name);
    if (hp && hp->h_addrtype == AF_INET && hp->h_length == sizeof host.s_addr)
      memcpy(&host.s_addr, hp->h_addr, sizeof host.s_addr);
  }
  ncprange_setip4(&ipcp->cfg.my_range, host, ipcp->cfg.netmask);
  ncprange_setip4(&ipcp->cfg.peer_range, ipcp->cfg.netmask, ipcp->cfg.netmask);

  iplist_setsrc(&ipcp->cfg.peer_list, "");
  ipcp->cfg.HaveTriggerAddress = 0;

  ipcp->cfg.ns.dns[0].s_addr = INADDR_NONE;
  ipcp->cfg.ns.dns[1].s_addr = INADDR_NONE;
  ipcp->cfg.ns.dns_neg = 0;
  ipcp->cfg.ns.nbns[0].s_addr = INADDR_ANY;
  ipcp->cfg.ns.nbns[1].s_addr = INADDR_ANY;

  ipcp->cfg.fsm.timeout = DEF_FSMRETRY;
  ipcp->cfg.fsm.maxreq = DEF_FSMTRIES;
  ipcp->cfg.fsm.maxtrm = DEF_FSMTRIES;
  ipcp->cfg.vj.neg = NEG_ENABLED|NEG_ACCEPTED;

  memset(&ipcp->vj, '\0', sizeof ipcp->vj);

  ipcp->ns.resolv = NULL;
  ipcp->ns.resolv_nons = NULL;
  ipcp->ns.writable = 1;
  ipcp_LoadDNS(ipcp);

  throughput_init(&ipcp->throughput, SAMPLE_PERIOD);
  memset(ipcp->Queue, '\0', sizeof ipcp->Queue);
  ipcp_Setup(ipcp, INADDR_NONE);
}

void
ipcp_Destroy(struct ipcp *ipcp)
{
  throughput_destroy(&ipcp->throughput);

  if (ipcp->ns.resolv != NULL) {
    free(ipcp->ns.resolv);
    ipcp->ns.resolv = NULL;
  }
  if (ipcp->ns.resolv_nons != NULL) {
    free(ipcp->ns.resolv_nons);
    ipcp->ns.resolv_nons = NULL;
  }
}

void
ipcp_SetLink(struct ipcp *ipcp, struct link *l)
{
  ipcp->fsm.link = l;
}

void
ipcp_Setup(struct ipcp *ipcp, u_int32_t mask)
{
  struct iface *iface = ipcp->fsm.bundle->iface;
  struct ncpaddr ipaddr;
  struct in_addr peer;
  int pos, n;

  ipcp->fsm.open_mode = 0;
  ipcp->ifmask.s_addr = mask == INADDR_NONE ? ipcp->cfg.netmask.s_addr : mask;

  if (iplist_isvalid(&ipcp->cfg.peer_list)) {
    /* Try to give the peer a previously configured IP address */
    for (n = 0; n < iface->addrs; n++) {
      if (!ncpaddr_getip4(&iface->addr[n].peer, &peer))
        continue;
      if ((pos = iplist_ip2pos(&ipcp->cfg.peer_list, peer)) != -1) {
        ncpaddr_setip4(&ipaddr, iplist_setcurpos(&ipcp->cfg.peer_list, pos));
        break;
      }
    }
    if (n == iface->addrs)
      /* Ok, so none of 'em fit.... pick a random one */
      ncpaddr_setip4(&ipaddr, iplist_setrandpos(&ipcp->cfg.peer_list));

    ncprange_sethost(&ipcp->cfg.peer_range, &ipaddr);
  }

  ipcp->heis1172 = 0;
  ipcp->peer_req = 0;
  ncprange_getip4addr(&ipcp->cfg.peer_range, &ipcp->peer_ip);
  ipcp->peer_compproto = 0;

  if (ipcp->cfg.HaveTriggerAddress) {
    /*
     * Some implementations of PPP require that we send a
     * *special* value as our address, even though the rfc specifies
     * full negotiation (e.g. "0.0.0.0" or Not "0.0.0.0").
     */
    ipcp->my_ip = ipcp->cfg.TriggerAddress;
    log_Printf(LogIPCP, "Using trigger address %s\n",
              inet_ntoa(ipcp->cfg.TriggerAddress));
  } else {
    /*
     * Otherwise, if we've used an IP number before and it's still within
     * the network specified on the ``set ifaddr'' line, we really
     * want to keep that IP number so that we can keep any existing
     * connections that are bound to that IP.
     */
    for (n = 0; n < iface->addrs; n++) {
      ncprange_getaddr(&iface->addr[n].ifa, &ipaddr);
      if (ncprange_contains(&ipcp->cfg.my_range, &ipaddr)) {
        ncpaddr_getip4(&ipaddr, &ipcp->my_ip);
        break;
      }
    }
    if (n == iface->addrs)
      ncprange_getip4addr(&ipcp->cfg.my_range, &ipcp->my_ip);
  }

  if (IsEnabled(ipcp->cfg.vj.neg)
#ifndef NORADIUS
      || (ipcp->fsm.bundle->radius.valid && ipcp->fsm.bundle->radius.vj)
#endif
     )
    ipcp->my_compproto = (PROTO_VJCOMP << 16) +
                         ((ipcp->cfg.vj.slots - 1) << 8) +
                         ipcp->cfg.vj.slotcomp;
  else
    ipcp->my_compproto = 0;
  sl_compress_init(&ipcp->vj.cslc, ipcp->cfg.vj.slots - 1);

  ipcp->peer_reject = 0;
  ipcp->my_reject = 0;

  /* Copy startup values into ipcp->ns.dns */
  if (ipcp->cfg.ns.dns[0].s_addr != INADDR_NONE)
    memcpy(ipcp->ns.dns, ipcp->cfg.ns.dns, sizeof ipcp->ns.dns);
}

static int
numaddresses(struct in_addr mask)
{
  u_int32_t bit, haddr;
  int n;

  haddr = ntohl(mask.s_addr);
  bit = 1;
  n = 1;

  do {
    if (!(haddr & bit))
      n <<= 1;
  } while (bit <<= 1);

  return n;
}

static int
ipcp_proxyarp(struct ipcp *ipcp,
              int (*proxyfun)(struct bundle *, struct in_addr, int),
              const struct iface_addr *addr)
{
  struct bundle *bundle = ipcp->fsm.bundle;
  struct in_addr peer, mask, ip;
  int n, ret, s;

  if (!ncpaddr_getip4(&addr->peer, &peer)) {
    log_Printf(LogERROR, "Oops, ipcp_proxyarp() called with unexpected addr\n");
    return 0;
  }

  if ((s = ID0socket(PF_INET, SOCK_DGRAM, 0)) == -1) {
    log_Printf(LogERROR, "ipcp_proxyarp: socket: %s\n",
               strerror(errno));
    return 0;
  }

  ret = 0;

  if (Enabled(bundle, OPT_PROXYALL)) {
    ncprange_getip4mask(&addr->ifa, &mask);
    if ((n = numaddresses(mask)) > 256) {
      log_Printf(LogWARN, "%s: Too many addresses for proxyall\n",
                 ncprange_ntoa(&addr->ifa));
      return 0;
    }
    ip.s_addr = peer.s_addr & mask.s_addr;
    if (n >= 4) {
      ip.s_addr = htonl(ntohl(ip.s_addr) + 1);
      n -= 2;
    }
    while (n) {
      if (!((ip.s_addr ^ peer.s_addr) & mask.s_addr)) {
        if (!(ret = (*proxyfun)(bundle, ip, s)))
          break;
        n--;
      }
      ip.s_addr = htonl(ntohl(ip.s_addr) + 1);
    }
    ret = !n;
  } else if (Enabled(bundle, OPT_PROXY))
    ret = (*proxyfun)(bundle, peer, s);

  close(s);

  return ret;
}

static int
ipcp_SetIPaddress(struct ipcp *ipcp, struct in_addr myaddr,
                  struct in_addr hisaddr)
{
  struct bundle *bundle = ipcp->fsm.bundle;
  struct ncpaddr myncpaddr, hisncpaddr;
  struct ncprange myrange;
  struct in_addr mask;
  struct sockaddr_storage ssdst, ssgw, ssmask;
  struct sockaddr *sadst, *sagw, *samask;

  sadst = (struct sockaddr *)&ssdst;
  sagw = (struct sockaddr *)&ssgw;
  samask = (struct sockaddr *)&ssmask;

  ncpaddr_setip4(&hisncpaddr, hisaddr);
  ncpaddr_setip4(&myncpaddr, myaddr);
  ncprange_sethost(&myrange, &myncpaddr);

  mask = addr2mask(myaddr);

  if (ipcp->ifmask.s_addr != INADDR_ANY &&
      (ipcp->ifmask.s_addr & mask.s_addr) == mask.s_addr)
    ncprange_setip4mask(&myrange, ipcp->ifmask);

  if (!iface_Add(bundle->iface, &bundle->ncp, &myrange, &hisncpaddr,
                 IFACE_ADD_FIRST|IFACE_FORCE_ADD|IFACE_SYSTEM))
    return 0;

  if (!Enabled(bundle, OPT_IFACEALIAS))
    iface_Clear(bundle->iface, &bundle->ncp, AF_INET,
                IFACE_CLEAR_ALIASES|IFACE_SYSTEM);

  if (bundle->ncp.cfg.sendpipe > 0 || bundle->ncp.cfg.recvpipe > 0) {
    ncprange_getsa(&myrange, &ssgw, &ssmask);
    ncpaddr_getsa(&hisncpaddr, &ssdst);
    rt_Update(bundle, sadst, sagw, samask);
  }

  if (Enabled(bundle, OPT_SROUTES))
    route_Change(bundle, bundle->ncp.route, &myncpaddr, &hisncpaddr);

#ifndef NORADIUS
  if (bundle->radius.valid)
    route_Change(bundle, bundle->radius.routes, &myncpaddr, &hisncpaddr);
#endif

  return 1;	/* Ok */
}

static struct in_addr
ChooseHisAddr(struct bundle *bundle, struct in_addr gw)
{
  struct in_addr try;
  u_long f;

  for (f = 0; f < bundle->ncp.ipcp.cfg.peer_list.nItems; f++) {
    try = iplist_next(&bundle->ncp.ipcp.cfg.peer_list);
    log_Printf(LogDEBUG, "ChooseHisAddr: Check item %ld (%s)\n",
              f, inet_ntoa(try));
    if (ipcp_SetIPaddress(&bundle->ncp.ipcp, gw, try)) {
      log_Printf(LogIPCP, "Selected IP address %s\n", inet_ntoa(try));
      break;
    }
  }

  if (f == bundle->ncp.ipcp.cfg.peer_list.nItems) {
    log_Printf(LogDEBUG, "ChooseHisAddr: All addresses in use !\n");
    try.s_addr = INADDR_ANY;
  }

  return try;
}

static void
IpcpInitRestartCounter(struct fsm *fp, int what)
{
  /* Set fsm timer load */
  struct ipcp *ipcp = fsm2ipcp(fp);

  fp->FsmTimer.load = ipcp->cfg.fsm.timeout * SECTICKS;
  switch (what) {
    case FSM_REQ_TIMER:
      fp->restart = ipcp->cfg.fsm.maxreq;
      break;
    case FSM_TRM_TIMER:
      fp->restart = ipcp->cfg.fsm.maxtrm;
      break;
    default:
      fp->restart = 1;
      break;
  }
}

static void
IpcpSendConfigReq(struct fsm *fp)
{
  /* Send config REQ please */
  struct physical *p = link2physical(fp->link);
  struct ipcp *ipcp = fsm2ipcp(fp);
  u_char buff[MAX_FSM_OPT_LEN];
  struct fsm_opt *o;

  o = (struct fsm_opt *)buff;

  if ((p && !physical_IsSync(p)) || !REJECTED(ipcp, TY_IPADDR)) {
    memcpy(o->data, &ipcp->my_ip.s_addr, 4);
    INC_FSM_OPT(TY_IPADDR, 6, o);
  }

  if (ipcp->my_compproto && !REJECTED(ipcp, TY_COMPPROTO)) {
    if (ipcp->heis1172) {
      u_int16_t proto = PROTO_VJCOMP;

      ua_htons(&proto, o->data);
      INC_FSM_OPT(TY_COMPPROTO, 4, o);
    } else {
      struct compreq req;

      req.proto = htons(ipcp->my_compproto >> 16);
      req.slots = (ipcp->my_compproto >> 8) & 255;
      req.compcid = ipcp->my_compproto & 1;
      memcpy(o->data, &req, 4);
      INC_FSM_OPT(TY_COMPPROTO, 6, o);
    }
  }

  if (IsEnabled(ipcp->cfg.ns.dns_neg)) {
    if (!REJECTED(ipcp, TY_PRIMARY_DNS - TY_ADJUST_NS)) {
      memcpy(o->data, &ipcp->ns.dns[0].s_addr, 4);
      INC_FSM_OPT(TY_PRIMARY_DNS, 6, o);
    }

    if (!REJECTED(ipcp, TY_SECONDARY_DNS - TY_ADJUST_NS)) {
      memcpy(o->data, &ipcp->ns.dns[1].s_addr, 4);
      INC_FSM_OPT(TY_SECONDARY_DNS, 6, o);
    }
  }

  fsm_Output(fp, CODE_CONFIGREQ, fp->reqid, buff, (u_char *)o - buff,
             MB_IPCPOUT);
}

static void
IpcpSentTerminateReq(struct fsm *fp)
{
  /* Term REQ just sent by FSM */
}

static void
IpcpSendTerminateAck(struct fsm *fp, u_char id)
{
  /* Send Term ACK please */
  fsm_Output(fp, CODE_TERMACK, id, NULL, 0, MB_IPCPOUT);
}

static void
IpcpLayerStart(struct fsm *fp)
{
  /* We're about to start up ! */
  struct ipcp *ipcp = fsm2ipcp(fp);

  log_Printf(LogIPCP, "%s: LayerStart.\n", fp->link->name);
  throughput_start(&ipcp->throughput, "IPCP throughput",
                   Enabled(fp->bundle, OPT_THROUGHPUT));
  fp->more.reqs = fp->more.naks = fp->more.rejs = ipcp->cfg.fsm.maxreq * 3;
  ipcp->peer_req = 0;
}

static void
IpcpLayerFinish(struct fsm *fp)
{
  /* We're now down */
  struct ipcp *ipcp = fsm2ipcp(fp);

  log_Printf(LogIPCP, "%s: LayerFinish.\n", fp->link->name);
  throughput_stop(&ipcp->throughput);
  throughput_log(&ipcp->throughput, LogIPCP, NULL);
}

/*
 * Called from iface_Add() via ncp_IfaceAddrAdded()
 */
void
ipcp_IfaceAddrAdded(struct ipcp *ipcp, const struct iface_addr *addr)
{
  struct bundle *bundle = ipcp->fsm.bundle;

  if (Enabled(bundle, OPT_PROXY) || Enabled(bundle, OPT_PROXYALL))
    ipcp_proxyarp(ipcp, arp_SetProxy, addr);
}

/*
 * Called from iface_Clear() and iface_Delete() via ncp_IfaceAddrDeleted()
 */
void
ipcp_IfaceAddrDeleted(struct ipcp *ipcp, const struct iface_addr *addr)
{
  struct bundle *bundle = ipcp->fsm.bundle;

  if (Enabled(bundle, OPT_PROXY) || Enabled(bundle, OPT_PROXYALL))
    ipcp_proxyarp(ipcp, arp_ClearProxy, addr);
}

static void
IpcpLayerDown(struct fsm *fp)
{
  /* About to come down */
  struct ipcp *ipcp = fsm2ipcp(fp);
  static int recursing;
  char addr[16];

  if (!recursing++) {
    snprintf(addr, sizeof addr, "%s", inet_ntoa(ipcp->my_ip));
    log_Printf(LogIPCP, "%s: LayerDown: %s\n", fp->link->name, addr);

#ifndef NORADIUS
    radius_Flush(&fp->bundle->radius);
    radius_Account(&fp->bundle->radius, &fp->bundle->radacct,
                   fp->bundle->links, RAD_STOP, &ipcp->throughput);

    if (fp->bundle->radius.cfg.file && fp->bundle->radius.filterid)
      system_Select(fp->bundle, fp->bundle->radius.filterid, LINKDOWNFILE,
                    NULL, NULL);
    radius_StopTimer(&fp->bundle->radius);
#endif

    /*
     * XXX this stuff should really live in the FSM.  Our config should
     * associate executable sections in files with events.
     */
    if (system_Select(fp->bundle, addr, LINKDOWNFILE, NULL, NULL) < 0) {
      if (bundle_GetLabel(fp->bundle)) {
         if (system_Select(fp->bundle, bundle_GetLabel(fp->bundle),
                          LINKDOWNFILE, NULL, NULL) < 0)
         system_Select(fp->bundle, "MYADDR", LINKDOWNFILE, NULL, NULL);
      } else
        system_Select(fp->bundle, "MYADDR", LINKDOWNFILE, NULL, NULL);
    }

    ipcp_Setup(ipcp, INADDR_NONE);
  }
  recursing--;
}

int
ipcp_InterfaceUp(struct ipcp *ipcp)
{
  if (!ipcp_SetIPaddress(ipcp, ipcp->my_ip, ipcp->peer_ip)) {
    log_Printf(LogERROR, "ipcp_InterfaceUp: unable to set ip address\n");
    return 0;
  }

  if (!iface_SetFlags(ipcp->fsm.bundle->iface->name, IFF_UP)) {
    log_Printf(LogERROR, "ipcp_InterfaceUp: Can't set the IFF_UP flag on %s\n",
               ipcp->fsm.bundle->iface->name);
    return 0;
  }

#ifndef NONAT
  if (ipcp->fsm.bundle->NatEnabled)
    PacketAliasSetAddress(ipcp->my_ip);
#endif

  return 1;
}

static int
IpcpLayerUp(struct fsm *fp)
{
  /* We're now up */
  struct ipcp *ipcp = fsm2ipcp(fp);
  char tbuff[16];

  log_Printf(LogIPCP, "%s: LayerUp.\n", fp->link->name);
  snprintf(tbuff, sizeof tbuff, "%s", inet_ntoa(ipcp->my_ip));
  log_Printf(LogIPCP, "myaddr %s hisaddr = %s\n",
             tbuff, inet_ntoa(ipcp->peer_ip));

  if (ipcp->peer_compproto >> 16 == PROTO_VJCOMP)
    sl_compress_init(&ipcp->vj.cslc, (ipcp->peer_compproto >> 8) & 255);

  if (!ipcp_InterfaceUp(ipcp))
    return 0;

#ifndef NORADIUS
  radius_Account_Set_Ip(&fp->bundle->radacct, &ipcp->peer_ip, &ipcp->ifmask);
  radius_Account(&fp->bundle->radius, &fp->bundle->radacct, fp->bundle->links,
                 RAD_START, &ipcp->throughput);

  if (fp->bundle->radius.cfg.file && fp->bundle->radius.filterid)
    system_Select(fp->bundle, fp->bundle->radius.filterid, LINKUPFILE,
                  NULL, NULL);
  radius_StartTimer(fp->bundle);
#endif

  /*
   * XXX this stuff should really live in the FSM.  Our config should
   * associate executable sections in files with events.
   */
  if (system_Select(fp->bundle, tbuff, LINKUPFILE, NULL, NULL) < 0) {
    if (bundle_GetLabel(fp->bundle)) {
      if (system_Select(fp->bundle, bundle_GetLabel(fp->bundle),
                       LINKUPFILE, NULL, NULL) < 0)
        system_Select(fp->bundle, "MYADDR", LINKUPFILE, NULL, NULL);
    } else
      system_Select(fp->bundle, "MYADDR", LINKUPFILE, NULL, NULL);
  }

  fp->more.reqs = fp->more.naks = fp->more.rejs = ipcp->cfg.fsm.maxreq * 3;
  log_DisplayPrompts();

  return 1;
}

static void
ipcp_ValidateReq(struct ipcp *ipcp, struct in_addr ip, struct fsm_decode *dec)
{
  struct bundle *bundle = ipcp->fsm.bundle;
  struct iface *iface = bundle->iface;
  struct in_addr myaddr, peer;
  int n;

  if (iplist_isvalid(&ipcp->cfg.peer_list)) {
    ncprange_getip4addr(&ipcp->cfg.my_range, &myaddr);
    if (ip.s_addr == INADDR_ANY ||
        iplist_ip2pos(&ipcp->cfg.peer_list, ip) < 0 ||
        !ipcp_SetIPaddress(ipcp, myaddr, ip)) {
      log_Printf(LogIPCP, "%s: Address invalid or already in use\n",
                 inet_ntoa(ip));
      /*
       * If we've already had a valid address configured for the peer,
       * try NAKing with that so that we don't have to upset things
       * too much.
       */
      for (n = 0; n < iface->addrs; n++) {
        if (!ncpaddr_getip4(&iface->addr[n].peer, &peer))
          continue;
        if (iplist_ip2pos(&ipcp->cfg.peer_list, peer) >= 0) {
          ipcp->peer_ip = peer;
          break;
        }
      }

      if (n == iface->addrs) {
        /* Just pick an IP number from our list */
        ipcp->peer_ip = ChooseHisAddr(bundle, myaddr);
      }

      if (ipcp->peer_ip.s_addr == INADDR_ANY) {
        *dec->rejend++ = TY_IPADDR;
        *dec->rejend++ = 6;
        memcpy(dec->rejend, &ip.s_addr, 4);
        dec->rejend += 4;
      } else {
        *dec->nakend++ = TY_IPADDR;
        *dec->nakend++ = 6;
        memcpy(dec->nakend, &ipcp->peer_ip.s_addr, 4);
        dec->nakend += 4;
      }
      return;
    }
  } else if (ip.s_addr == INADDR_ANY ||
             !ncprange_containsip4(&ipcp->cfg.peer_range, ip)) {
    /*
     * If the destination address is not acceptable, NAK with what we
     * want to use.
     */
    *dec->nakend++ = TY_IPADDR;
    *dec->nakend++ = 6;
    for (n = 0; n < iface->addrs; n++)
      if (ncprange_contains(&ipcp->cfg.peer_range, &iface->addr[n].peer)) {
        /* We prefer the already-configured address */
        ncpaddr_getip4addr(&iface->addr[n].peer, (u_int32_t *)dec->nakend);
        break;
      }

    if (n == iface->addrs)
      memcpy(dec->nakend, &ipcp->peer_ip.s_addr, 4);

    dec->nakend += 4;
    return;
  }

  ipcp->peer_ip = ip;
  *dec->ackend++ = TY_IPADDR;
  *dec->ackend++ = 6;
  memcpy(dec->ackend, &ip.s_addr, 4);
  dec->ackend += 4;
}

static void
IpcpDecodeConfig(struct fsm *fp, u_char *cp, u_char *end, int mode_type,
                 struct fsm_decode *dec)
{
  /* Deal with incoming PROTO_IPCP */
  struct ncpaddr ncpaddr;
  struct ipcp *ipcp = fsm2ipcp(fp);
  int gotdnsnak;
  u_int32_t compproto;
  struct compreq *pcomp, pcompbuff;
  struct in_addr ipaddr, dstipaddr, have_ip;
  char tbuff[100], tbuff2[100];
  struct fsm_opt *opt, nak;

  gotdnsnak = 0;

  while (end - cp >= sizeof(opt->hdr)) {
    if ((opt = fsm_readopt(&cp)) == NULL)
      break;

    snprintf(tbuff, sizeof tbuff, " %s[%d]", protoname(opt->hdr.id),
             opt->hdr.len);

    switch (opt->hdr.id) {
    case TY_IPADDR:		/* RFC1332 */
      memcpy(&ipaddr.s_addr, opt->data, 4);
      log_Printf(LogIPCP, "%s %s\n", tbuff, inet_ntoa(ipaddr));

      switch (mode_type) {
      case MODE_REQ:
        ipcp->peer_req = 1;
        ipcp_ValidateReq(ipcp, ipaddr, dec);
        break;

      case MODE_NAK:
        if (ncprange_containsip4(&ipcp->cfg.my_range, ipaddr)) {
          /* Use address suggested by peer */
          snprintf(tbuff2, sizeof tbuff2, "%s changing address: %s ", tbuff,
                   inet_ntoa(ipcp->my_ip));
          log_Printf(LogIPCP, "%s --> %s\n", tbuff2, inet_ntoa(ipaddr));
          ipcp->my_ip = ipaddr;
          ncpaddr_setip4(&ncpaddr, ipcp->my_ip);
          bundle_AdjustFilters(fp->bundle, &ncpaddr, NULL);
        } else {
          log_Printf(log_IsKept(LogIPCP) ? LogIPCP : LogPHASE,
                    "%s: Unacceptable address!\n", inet_ntoa(ipaddr));
          fsm_Close(&ipcp->fsm);
        }
        break;

      case MODE_REJ:
        ipcp->peer_reject |= (1 << opt->hdr.id);
        break;
      }
      break;

    case TY_COMPPROTO:
      pcomp = &pcompbuff;
      memcpy(pcomp, opt->data, sizeof(pcompbuff));
      compproto = (ntohs(pcomp->proto) << 16) + (pcomp->slots << 8) +
                  pcomp->compcid;
      log_Printf(LogIPCP, "%s %s\n", tbuff, vj2asc(compproto));

      switch (mode_type) {
      case MODE_REQ:
        if (!IsAccepted(ipcp->cfg.vj.neg))
          fsm_rej(dec, opt);
        else {
          switch (opt->hdr.len) {
          case 4:		/* RFC1172 */
            if (ntohs(pcomp->proto) == PROTO_VJCOMP) {
              log_Printf(LogWARN, "Peer is speaking RFC1172 compression "
                         "protocol !\n");
              ipcp->heis1172 = 1;
              ipcp->peer_compproto = compproto;
              fsm_ack(dec, opt);
            } else {
              pcomp->proto = htons(PROTO_VJCOMP);
              nak.hdr.id = TY_COMPPROTO;
              nak.hdr.len = 4;
              memcpy(nak.data, &pcomp, 2);
              fsm_nak(dec, &nak);
            }
            break;
          case 6:		/* RFC1332 */
            if (ntohs(pcomp->proto) == PROTO_VJCOMP) {
              if (pcomp->slots <= MAX_VJ_STATES
                  && pcomp->slots >= MIN_VJ_STATES) {
                /* Ok, we can do that */
                ipcp->peer_compproto = compproto;
                ipcp->heis1172 = 0;
                fsm_ack(dec, opt);
              } else {
                /* Get as close as we can to what he wants */
                ipcp->heis1172 = 0;
                pcomp->slots = pcomp->slots < MIN_VJ_STATES ?
                               MIN_VJ_STATES : MAX_VJ_STATES;
                nak.hdr.id = TY_COMPPROTO;
                nak.hdr.len = 4;
                memcpy(nak.data, &pcomp, 2);
                fsm_nak(dec, &nak);
              }
            } else {
              /* What we really want */
              pcomp->proto = htons(PROTO_VJCOMP);
              pcomp->slots = DEF_VJ_STATES;
              pcomp->compcid = 1;
              nak.hdr.id = TY_COMPPROTO;
              nak.hdr.len = 6;
              memcpy(nak.data, &pcomp, sizeof pcomp);
              fsm_nak(dec, &nak);
            }
            break;
          default:
            fsm_rej(dec, opt);
            break;
          }
        }
        break;

      case MODE_NAK:
        if (ntohs(pcomp->proto) == PROTO_VJCOMP) {
          if (pcomp->slots > MAX_VJ_STATES)
            pcomp->slots = MAX_VJ_STATES;
          else if (pcomp->slots < MIN_VJ_STATES)
            pcomp->slots = MIN_VJ_STATES;
          compproto = (ntohs(pcomp->proto) << 16) + (pcomp->slots << 8) +
                      pcomp->compcid;
        } else
          compproto = 0;
        log_Printf(LogIPCP, "%s changing compproto: %08x --> %08x\n",
                   tbuff, ipcp->my_compproto, compproto);
        ipcp->my_compproto = compproto;
        break;

      case MODE_REJ:
        ipcp->peer_reject |= (1 << opt->hdr.id);
        break;
      }
      break;

    case TY_IPADDRS:		/* RFC1172 */
      memcpy(&ipaddr.s_addr, opt->data, 4);
      memcpy(&dstipaddr.s_addr, opt->data + 4, 4);
      snprintf(tbuff2, sizeof tbuff2, "%s %s,", tbuff, inet_ntoa(ipaddr));
      log_Printf(LogIPCP, "%s %s\n", tbuff2, inet_ntoa(dstipaddr));

      switch (mode_type) {
      case MODE_REQ:
        fsm_rej(dec, opt);
        break;

      case MODE_NAK:
      case MODE_REJ:
        break;
      }
      break;

    case TY_PRIMARY_DNS:	/* DNS negotiation (rfc1877) */
    case TY_SECONDARY_DNS:
      memcpy(&ipaddr.s_addr, opt->data, 4);
      log_Printf(LogIPCP, "%s %s\n", tbuff, inet_ntoa(ipaddr));

      switch (mode_type) {
      case MODE_REQ:
        if (!IsAccepted(ipcp->cfg.ns.dns_neg)) {
          ipcp->my_reject |= (1 << (opt->hdr.id - TY_ADJUST_NS));
          fsm_rej(dec, opt);
          break;
        }
        have_ip = ipcp->ns.dns[opt->hdr.id == TY_PRIMARY_DNS ? 0 : 1];

        if (opt->hdr.id == TY_PRIMARY_DNS && ipaddr.s_addr != have_ip.s_addr &&
            ipaddr.s_addr == ipcp->ns.dns[1].s_addr) {
          /* Swap 'em 'round */
          ipcp->ns.dns[0] = ipcp->ns.dns[1];
          ipcp->ns.dns[1] = have_ip;
          have_ip = ipcp->ns.dns[0];
        }

        if (ipaddr.s_addr != have_ip.s_addr) {
          /*
           * The client has got the DNS stuff wrong (first request) so
           * we'll tell 'em how it is
           */
          nak.hdr.id = opt->hdr.id;
          nak.hdr.len = 6;
          memcpy(nak.data, &have_ip.s_addr, 4);
          fsm_nak(dec, &nak);
        } else {
          /*
           * Otherwise they have it right (this time) so we send a ack packet
           * back confirming it... end of story
           */
          fsm_ack(dec, opt);
        }
        break;

      case MODE_NAK:
        if (IsEnabled(ipcp->cfg.ns.dns_neg)) {
          gotdnsnak = 1;
          memcpy(&ipcp->ns.dns[opt->hdr.id == TY_PRIMARY_DNS ? 0 : 1].s_addr,
                 opt->data, 4);
        }
        break;

      case MODE_REJ:		/* Can't do much, stop asking */
        ipcp->peer_reject |= (1 << (opt->hdr.id - TY_ADJUST_NS));
        break;
      }
      break;

    case TY_PRIMARY_NBNS:	/* M$ NetBIOS nameserver hack (rfc1877) */
    case TY_SECONDARY_NBNS:
      memcpy(&ipaddr.s_addr, opt->data, 4);
      log_Printf(LogIPCP, "%s %s\n", tbuff, inet_ntoa(ipaddr));

      switch (mode_type) {
      case MODE_REQ:
        have_ip.s_addr =
          ipcp->cfg.ns.nbns[opt->hdr.id == TY_PRIMARY_NBNS ? 0 : 1].s_addr;

        if (have_ip.s_addr == INADDR_ANY) {
          log_Printf(LogIPCP, "NBNS REQ - rejected - nbns not set\n");
          ipcp->my_reject |= (1 << (opt->hdr.id - TY_ADJUST_NS));
          fsm_rej(dec, opt);
          break;
        }

        if (ipaddr.s_addr != have_ip.s_addr) {
          nak.hdr.id = opt->hdr.id;
          nak.hdr.len = 6;
          memcpy(nak.data, &have_ip.s_addr, 4);
          fsm_nak(dec, &nak);
        } else
          fsm_ack(dec, opt);
        break;

      case MODE_NAK:
        log_Printf(LogIPCP, "MS NBNS req %d - NAK??\n", opt->hdr.id);
        break;

      case MODE_REJ:
        log_Printf(LogIPCP, "MS NBNS req %d - REJ??\n", opt->hdr.id);
        break;
      }
      break;

    default:
      if (mode_type != MODE_NOP) {
        ipcp->my_reject |= (1 << opt->hdr.id);
        fsm_rej(dec, opt);
      }
      break;
    }
  }

  if (gotdnsnak) {
    if (ipcp->ns.writable) {
      log_Printf(LogDEBUG, "Updating resolver\n");
      if (!ipcp_WriteDNS(ipcp)) {
        ipcp->peer_reject |= (1 << (TY_PRIMARY_DNS - TY_ADJUST_NS));
        ipcp->peer_reject |= (1 << (TY_SECONDARY_DNS - TY_ADJUST_NS));
      } else
        bundle_AdjustDNS(fp->bundle);
    } else {
      log_Printf(LogDEBUG, "Not updating resolver (readonly)\n");
      bundle_AdjustDNS(fp->bundle);
    }
  }

  if (mode_type != MODE_NOP) {
    if (mode_type == MODE_REQ && !ipcp->peer_req) {
      if (dec->rejend == dec->rej && dec->nakend == dec->nak) {
        /*
         * Pretend the peer has requested an IP.
         * We do this to ensure that we only send one NAK if the only
         * reason for the NAK is because the peer isn't sending a
         * TY_IPADDR REQ.  This stops us from repeatedly trying to tell
         * the peer that we have to have an IP address on their end.
         */
        ipcp->peer_req = 1;
      }
      ipaddr.s_addr = INADDR_ANY;
      ipcp_ValidateReq(ipcp, ipaddr, dec);
    }
    fsm_opt_normalise(dec);
  }
}

extern struct mbuf *
ipcp_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
{
  /* Got PROTO_IPCP from link */
  m_settype(bp, MB_IPCPIN);
  if (bundle_Phase(bundle) == PHASE_NETWORK)
    fsm_Input(&bundle->ncp.ipcp.fsm, bp);
  else {
    if (bundle_Phase(bundle) < PHASE_NETWORK)
      log_Printf(LogIPCP, "%s: Error: Unexpected IPCP in phase %s (ignored)\n",
                 l->name, bundle_PhaseName(bundle));
    m_freem(bp);
  }
  return NULL;
}

int
ipcp_UseHisIPaddr(struct bundle *bundle, struct in_addr hisaddr)
{
  struct ipcp *ipcp = &bundle->ncp.ipcp;
  struct in_addr myaddr;

  memset(&ipcp->cfg.peer_range, '\0', sizeof ipcp->cfg.peer_range);
  iplist_reset(&ipcp->cfg.peer_list);
  ipcp->peer_ip = hisaddr;
  ncprange_setip4host(&ipcp->cfg.peer_range, hisaddr);
  ncprange_getip4addr(&ipcp->cfg.my_range, &myaddr);

  return ipcp_SetIPaddress(ipcp, myaddr, hisaddr);
}

int
ipcp_UseHisaddr(struct bundle *bundle, const char *hisaddr, int setaddr)
{
  struct in_addr myaddr;
  struct ncp *ncp = &bundle->ncp;
  struct ipcp *ipcp = &ncp->ipcp;
  struct ncpaddr ncpaddr;

  /* Use `hisaddr' for the peers address (set iface if `setaddr') */
  memset(&ipcp->cfg.peer_range, '\0', sizeof ipcp->cfg.peer_range);
  iplist_reset(&ipcp->cfg.peer_list);
  if (strpbrk(hisaddr, ",-")) {
    iplist_setsrc(&ipcp->cfg.peer_list, hisaddr);
    if (iplist_isvalid(&ipcp->cfg.peer_list)) {
      iplist_setrandpos(&ipcp->cfg.peer_list);
      ipcp->peer_ip = ChooseHisAddr(bundle, ipcp->my_ip);
      if (ipcp->peer_ip.s_addr == INADDR_ANY) {
        log_Printf(LogWARN, "%s: None available !\n", ipcp->cfg.peer_list.src);
        return 0;
      }
      ncprange_setip4host(&ipcp->cfg.peer_range, ipcp->peer_ip);
    } else {
      log_Printf(LogWARN, "%s: Invalid range !\n", hisaddr);
      return 0;
    }
  } else if (ncprange_aton(&ipcp->cfg.peer_range, ncp, hisaddr) != 0) {
    if (ncprange_family(&ipcp->cfg.my_range) != AF_INET) {
      log_Printf(LogWARN, "%s: Not an AF_INET address !\n", hisaddr);
      return 0;
    }
    ncprange_getip4addr(&ipcp->cfg.my_range, &myaddr);
    ncprange_getip4addr(&ipcp->cfg.peer_range, &ipcp->peer_ip);

    if (setaddr && !ipcp_SetIPaddress(ipcp, myaddr, ipcp->peer_ip))
      return 0;
  } else
    return 0;

  ncpaddr_setip4(&ncpaddr, ipcp->peer_ip);
  bundle_AdjustFilters(bundle, NULL, &ncpaddr);

  return 1;	/* Ok */
}

struct in_addr
addr2mask(struct in_addr addr)
{
  u_int32_t haddr = ntohl(addr.s_addr);

  haddr = IN_CLASSA(haddr) ? IN_CLASSA_NET :
          IN_CLASSB(haddr) ? IN_CLASSB_NET :
          IN_CLASSC_NET;
  addr.s_addr = htonl(haddr);

  return addr;
}

size_t
ipcp_QueueLen(struct ipcp *ipcp)
{
  struct mqueue *q;
  size_t result;

  result = 0;
  for (q = ipcp->Queue; q < ipcp->Queue + IPCP_QUEUES(ipcp); q++)
    result += q->len;

  return result;
}

int
ipcp_PushPacket(struct ipcp *ipcp, struct link *l)
{
  struct bundle *bundle = ipcp->fsm.bundle;
  struct mqueue *queue;
  struct mbuf *bp;
  int m_len;
  u_int32_t secs = 0;
  unsigned alivesecs = 0;

  if (ipcp->fsm.state != ST_OPENED)
    return 0;

  /*
   * If ccp is not open but is required, do nothing.
   */
  if (l->ccp.fsm.state != ST_OPENED && ccp_Required(&l->ccp)) {
    log_Printf(LogPHASE, "%s: Not transmitting... waiting for CCP\n", l->name);
    return 0;
  }

  queue = ipcp->Queue + IPCP_QUEUES(ipcp) - 1;
  do {
    if (queue->top) {
      bp = m_dequeue(queue);
      bp = mbuf_Read(bp, &secs, sizeof secs);
      bp = m_pullup(bp);
      m_len = m_length(bp);
      if (!FilterCheck(MBUF_CTOP(bp), AF_INET, &bundle->filter.alive,
                       &alivesecs)) {
        if (secs == 0)
          secs = alivesecs;
        bundle_StartIdleTimer(bundle, secs);
      }
      link_PushPacket(l, bp, bundle, 0, PROTO_IP);
      ipcp_AddOutOctets(ipcp, m_len);
      return 1;
    }
  } while (queue-- != ipcp->Queue);

  return 0;
}
@


1.45
log
@Validate file size before loading content into memory.

ok millert@@
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.44 2005/09/21 16:58:34 brad Exp $
@


1.44
log
@Add a radius_Flush() function that waits for the response (or timeout) to
any pending RADIUS transaction.  Use this before sending RAD_STOP RADIUS
messages so that we definitely ``stop'' the session.

It was discovered that sometimes when the link timed out, we got lucky
enough to have an un-ACK'd RADIUS accounting transaction in progress,
resulting in the RAD_STOP message failing to send.

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.43 2005/09/21 16:28:47 brad Exp $
d195 4
a198 1
      if ((ipcp->ns.resolv_nons = (char *)malloc(st.st_size + 1)) == NULL)
@


1.43
log
@Support a ``set rad_alive N'' command to enable periodic RADIUS accounting
information being sent to the RADIUS server.

Logging of RADIUS accounting information moves to a ``set log [+-]radius''
level, along with the RADIUS alive info.

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.42 2005/09/21 01:43:07 brad Exp $
d875 1
@


1.42
log
@Do RADIUS accounting on IPV6CP.

From ume FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.41 2005/07/17 19:13:24 brad Exp $
d878 4
a881 3
  if (fp->bundle->radius.cfg.file && fp->bundle->radius.filterid)
    system_Select(fp->bundle, fp->bundle->radius.filterid, LINKDOWNFILE,
                  NULL, NULL);
d950 1
@


1.41
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.40 2005/07/12 01:47:21 brad Exp $
d876 1
a876 2
                   fp->bundle->links, RAD_STOP, &ipcp->peer_ip, &ipcp->ifmask,
                   &ipcp->throughput);
d942 1
d944 1
a944 1
                 RAD_START, &ipcp->peer_ip, &ipcp->ifmask, &ipcp->throughput);
@


1.40
log
@rev 1.117

If the peer gives us 0.0.0.0 as his IP number, NAK it rather than accepting
it as being in range.

  set ifaddr 1.2.3.4/0 5.6.7.8/0

no longer allows 0.0.0.0 as a valid IP.

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.39 2004/06/26 20:12:48 claudio Exp $
d45 1
@


1.39
log
@Fix strict aligenment issues in ppp lcp and ipcp handling.
More cleanup is needed. OK henning@@ canacar@@
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.38 2003/04/28 17:36:56 beck Exp $
d1016 2
a1017 1
  } else if (!ncprange_containsip4(&ipcp->cfg.peer_range, ip)) {
@


1.38
log
@strings. tdeval and I finally agree on this :)
ok tdeval@@
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.37 2002/06/15 08:02:00 brian Exp $
d757 1
a757 1
  u_char buff[24];
d1053 1
a1053 1
  struct compreq *pcomp;
d1101 2
a1102 1
      pcomp = (struct compreq *)opt->data;
@


1.37
log
@Tidy up end of line whitespace
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.36 2002/06/15 01:33:23 brian Exp $
d254 2
a255 1
        strcpy(cp_nons, cp);	/* Copy the end - including the NUL */
@


1.36
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.35 2002/05/16 01:13:39 brian Exp $
d342 1
a342 1
  
d941 1
a941 1
  radius_Account(&fp->bundle->radius, &fp->bundle->radacct, fp->bundle->links, 
@


1.35
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.34 2002/01/16 14:13:06 brian Exp $
d876 4
d943 4
@


1.34
log
@socket()s first argument should be a protocol family rather than an
address family.
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.33 2001/08/19 23:22:17 brian Exp $
d117 1
a117 1
static void IpcpDecodeConfig(struct fsm *, u_char *, int, int,
d354 1
a354 1
	          inet_ntoa(ipcp->peer_ip), vj2asc(ipcp->peer_compproto));
d356 1
a356 1
	          inet_ntoa(ipcp->my_ip), vj2asc(ipcp->my_compproto));
d367 1
a367 1
	        ncprange_ntoa(&ipcp->cfg.my_range));
d381 1
a381 1
	          ncprange_ntoa(&ipcp->cfg.peer_range));
d399 1
a399 1
	        inet_ntoa(ipcp->cfg.ns.nbns[0]));
d757 1
a757 1
  struct lcp_opt *o;
d759 1
a759 1
  o = (struct lcp_opt *)buff;
d763 1
a763 1
    INC_LCP_OPT(TY_IPADDR, 6, o);
d771 1
a771 1
      INC_LCP_OPT(TY_COMPPROTO, 4, o);
d779 1
a779 1
      INC_LCP_OPT(TY_COMPPROTO, 6, o);
d786 1
a786 1
      INC_LCP_OPT(TY_PRIMARY_DNS, 6, o);
d791 1
a791 1
      INC_LCP_OPT(TY_SECONDARY_DNS, 6, o);
d1036 1
a1036 1
IpcpDecodeConfig(struct fsm *fp, u_char *cp, int plen, int mode_type,
d1042 1
a1042 1
  int type, length, gotdnsnak;
d1047 1
d1051 2
a1052 6
  while (plen >= sizeof(struct fsmconfig)) {
    type = *cp;
    length = cp[1];

    if (length == 0) {
      log_Printf(LogIPCP, "%s: IPCP size zero\n", fp->link->name);
a1053 1
    }
d1055 2
a1056 1
    snprintf(tbuff, sizeof tbuff, " %s[%d] ", protoname(type), length);
d1058 1
a1058 1
    switch (type) {
d1060 1
a1060 1
      memcpy(&ipaddr.s_addr, cp + 2, 4);
d1067 1
a1067 1
	break;
d1071 5
a1075 5
	  /* Use address suggested by peer */
	  snprintf(tbuff2, sizeof tbuff2, "%s changing address: %s ", tbuff,
		   inet_ntoa(ipcp->my_ip));
	  log_Printf(LogIPCP, "%s --> %s\n", tbuff2, inet_ntoa(ipaddr));
	  ipcp->my_ip = ipaddr;
d1078 2
a1079 2
	} else {
	  log_Printf(log_IsKept(LogIPCP) ? LogIPCP : LogPHASE,
d1082 2
a1083 2
	}
	break;
d1086 2
a1087 2
	ipcp->peer_reject |= (1 << type);
	break;
d1092 1
a1092 1
      pcomp = (struct compreq *)(cp + 2);
d1099 7
a1105 8
	if (!IsAccepted(ipcp->cfg.vj.neg)) {
	  memcpy(dec->rejend, cp, length);
	  dec->rejend += length;
	} else {
	  switch (length) {
	  case 4:		/* RFC1172 */
	    if (ntohs(pcomp->proto) == PROTO_VJCOMP) {
	      log_Printf(LogWARN, "Peer is speaking RFC1172 compression "
d1107 13
a1119 13
	      ipcp->heis1172 = 1;
	      ipcp->peer_compproto = compproto;
	      memcpy(dec->ackend, cp, length);
	      dec->ackend += length;
	    } else {
	      memcpy(dec->nakend, cp, 2);
	      pcomp->proto = htons(PROTO_VJCOMP);
	      memcpy(dec->nakend+2, &pcomp, 2);
	      dec->nakend += length;
	    }
	    break;
	  case 6:		/* RFC1332 */
	    if (ntohs(pcomp->proto) == PROTO_VJCOMP) {
d1123 4
a1126 5
	        ipcp->peer_compproto = compproto;
	        ipcp->heis1172 = 0;
	        memcpy(dec->ackend, cp, length);
	        dec->ackend += length;
	      } else {
d1128 2
a1129 3
	        ipcp->heis1172 = 0;
	        memcpy(dec->nakend, cp, 2);
	        pcomp->slots = pcomp->slots < MIN_VJ_STATES ?
d1131 4
a1134 2
	        memcpy(dec->nakend+2, &pcomp, sizeof pcomp);
	        dec->nakend += length;
d1136 1
a1136 1
	    } else {
d1138 15
a1152 15
	      memcpy(dec->nakend, cp, 2);
	      pcomp->proto = htons(PROTO_VJCOMP);
	      pcomp->slots = DEF_VJ_STATES;
	      pcomp->compcid = 1;
	      memcpy(dec->nakend+2, &pcomp, sizeof pcomp);
	      dec->nakend += length;
	    }
	    break;
	  default:
	    memcpy(dec->rejend, cp, length);
	    dec->rejend += length;
	    break;
	  }
	}
	break;
d1155 1
a1155 1
	if (ntohs(pcomp->proto) == PROTO_VJCOMP) {
d1164 2
a1165 2
	log_Printf(LogIPCP, "%s changing compproto: %08x --> %08x\n",
		  tbuff, ipcp->my_compproto, compproto);
d1167 1
a1167 1
	break;
d1170 2
a1171 2
	ipcp->peer_reject |= (1 << type);
	break;
d1176 2
a1177 2
      memcpy(&ipaddr.s_addr, cp + 2, 4);
      memcpy(&dstipaddr.s_addr, cp + 6, 4);
d1183 2
a1184 3
	memcpy(dec->rejend, cp, length);
	dec->rejend += length;
	break;
d1188 1
a1188 1
	break;
d1194 1
a1194 1
      memcpy(&ipaddr.s_addr, cp + 2, 4);
d1200 3
a1202 4
          ipcp->my_reject |= (1 << (type - TY_ADJUST_NS));
	  memcpy(dec->rejend, cp, length);
	  dec->rejend += length;
	  break;
d1204 1
a1204 1
        have_ip = ipcp->ns.dns[type == TY_PRIMARY_DNS ? 0 : 1];
d1206 1
a1206 1
        if (type == TY_PRIMARY_DNS && ipaddr.s_addr != have_ip.s_addr &&
d1214 15
a1228 15
	if (ipaddr.s_addr != have_ip.s_addr) {
	  /*
	   * The client has got the DNS stuff wrong (first request) so
	   * we'll tell 'em how it is
	   */
	  memcpy(dec->nakend, cp, 2);	/* copy first two (type/length) */
	  memcpy(dec->nakend + 2, &have_ip.s_addr, length - 2);
	  dec->nakend += length;
	} else {
	  /*
	   * Otherwise they have it right (this time) so we send a ack packet
	   * back confirming it... end of story
	   */
	  memcpy(dec->ackend, cp, length);
	  dec->ackend += length;
d1230 1
a1230 1
	break;
d1235 4
a1238 4
          memcpy(&ipcp->ns.dns[type == TY_PRIMARY_DNS ? 0 : 1].s_addr,
                 cp + 2, 4);
	}
	break;
d1241 2
a1242 2
        ipcp->peer_reject |= (1 << (type - TY_ADJUST_NS));
	break;
d1248 1
a1248 1
      memcpy(&ipaddr.s_addr, cp + 2, 4);
d1253 2
a1254 2
	have_ip.s_addr =
          ipcp->cfg.ns.nbns[type == TY_PRIMARY_NBNS ? 0 : 1].s_addr;
d1257 4
a1260 5
	  log_Printf(LogIPCP, "NBNS REQ - rejected - nbns not set\n");
          ipcp->my_reject |= (1 << (type - TY_ADJUST_NS));
	  memcpy(dec->rejend, cp, length);
	  dec->rejend += length;
	  break;
d1263 8
a1270 9
	if (ipaddr.s_addr != have_ip.s_addr) {
	  memcpy(dec->nakend, cp, 2);
	  memcpy(dec->nakend+2, &have_ip.s_addr, length);
	  dec->nakend += length;
	} else {
	  memcpy(dec->ackend, cp, length);
	  dec->ackend += length;
        }
	break;
d1273 2
a1274 2
	log_Printf(LogIPCP, "MS NBNS req %d - NAK??\n", type);
	break;
d1277 2
a1278 2
	log_Printf(LogIPCP, "MS NBNS req %d - REJ??\n", type);
	break;
d1284 2
a1285 3
        ipcp->my_reject |= (1 << type);
        memcpy(dec->rejend, cp, length);
        dec->rejend += length;
a1288 2
    plen -= length;
    cp += length;
d1320 1
a1320 7
    if (dec->rejend != dec->rej) {
      /* rejects are preferred */
      dec->ackend = dec->ack;
      dec->nakend = dec->nak;
    } else if (dec->nakend != dec->nak)
      /* then NAKs */
      dec->ackend = dec->ack;
@


1.33
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.32 2001/07/28 11:33:05 brian Exp $
d619 1
a619 1
  if ((s = ID0socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
@


1.32
log
@If the peer sends a REQ without the IPADDR option, only reject it
once.  If they repeat the request (again without the IPADDR option)
ACK it.
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.c,v 1.31 2001/06/13 21:33:41 brian Exp $
d74 2
d88 2
a96 1
#include "ip.h"
a102 88
static u_short default_urgent_tcp_ports[] = {
  21,	/* ftp */
  22,	/* ssh */
  23,	/* telnet */
  513,	/* login */
  514,	/* shell */
  543,	/* klogin */
  544	/* kshell */
};

static u_short default_urgent_udp_ports[] = { };

#define NDEFTCPPORTS \
  (sizeof default_urgent_tcp_ports / sizeof default_urgent_tcp_ports[0])
#define NDEFUDPPORTS \
  (sizeof default_urgent_udp_ports / sizeof default_urgent_udp_ports[0])

int
ipcp_IsUrgentPort(struct port_range *range, u_short src, u_short dst)
{
  int f;

  for (f = 0; f < range->nports; f++)
    if (range->port[f] == src || range->port[f] == dst)
      return 1;

  return 0;
}

void
ipcp_AddUrgentPort(struct port_range *range, u_short port)
{
  u_short *newport;
  int p;

  if (range->nports == range->maxports) {
    range->maxports += 10;
    newport = (u_short *)realloc(range->port,
                                 range->maxports * sizeof(u_short));
    if (newport == NULL) {
      log_Printf(LogERROR, "ipcp_AddUrgentPort: realloc: %s\n",
                 strerror(errno));
      range->maxports -= 10;
      return;
    }
    range->port = newport;
  }

  for (p = 0; p < range->nports; p++)
    if (range->port[p] == port) {
      log_Printf(LogWARN, "%u: Port already set to urgent\n", port);
      break;
    } else if (range->port[p] > port) {
      memmove(range->port + p + 1, range->port + p,
              (range->nports - p) * sizeof(u_short));
      range->port[p] = port;
      range->nports++;
      break;
    }

  if (p == range->nports)
    range->port[range->nports++] = port;
}

void
ipcp_RemoveUrgentPort(struct port_range *range, u_short port)
{
  int p;

  for (p = 0; p < range->nports; p++)
    if (range->port[p] == port) {
      if (p != range->nports - 1)
        memmove(range->port + p, range->port + p + 1,
                (range->nports - p - 1) * sizeof(u_short));
      range->nports--;
      return;
    }

  if (p == range->nports)
    log_Printf(LogWARN, "%u: Port not set to urgent\n", port);
}

void
ipcp_ClearUrgentPorts(struct port_range *range)
{
  range->nports = 0;
}

d245 1
a245 1
          if (n < 2 && inet_aton(cp, ipcp->ns.dns + n))
d262 1
a262 1
        bundle_AdjustDNS(ipcp->fsm.bundle, ipcp->ns.dns);
a348 1
  int p;
d358 1
a358 6
                  (unsigned long)ip_QueueLen(ipcp));
  }

  if (ipcp->route) {
    prompt_Printf(arg->prompt, "\n");
    route_ShowSticky(arg->prompt, ipcp->route, "Sticky routes", 1);
d366 2
a367 3
  prompt_Printf(arg->prompt, " My Address:      %s/%d",
	        inet_ntoa(ipcp->cfg.my_range.ipaddr), ipcp->cfg.my_range.width);
  prompt_Printf(arg->prompt, ", netmask %s\n", inet_ntoa(ipcp->cfg.netmask));
d380 2
a381 3
    prompt_Printf(arg->prompt, " His Address:     %s/%d\n",
	          inet_ntoa(ipcp->cfg.peer_range.ipaddr),
                  ipcp->cfg.peer_range.width);
d387 2
a388 1
    prompt_Printf(arg->prompt, ", %s", inet_ntoa(ipcp->cfg.ns.dns[1]));
d396 2
a397 1
    prompt_Printf(arg->prompt, ", %s", inet_ntoa(ipcp->ns.dns[1]));
d400 2
a401 23
  prompt_Printf(arg->prompt, "%s\n", inet_ntoa(ipcp->cfg.ns.nbns[1]));

  prompt_Printf(arg->prompt, " Urgent ports\n");
  prompt_Printf(arg->prompt, "          TCP:    ");
  if (ipcp->cfg.urgent.tcp.nports == 0)
    prompt_Printf(arg->prompt, "none");
  else
    for (p = 0; p < ipcp->cfg.urgent.tcp.nports; p++) {
      if (p)
        prompt_Printf(arg->prompt, ", ");
      prompt_Printf(arg->prompt, "%u", ipcp->cfg.urgent.tcp.port[p]);
    }
  prompt_Printf(arg->prompt, "\n          UDP:    ");
  if (ipcp->cfg.urgent.udp.nports == 0)
    prompt_Printf(arg->prompt, "none");
  else
    for (p = 0; p < ipcp->cfg.urgent.udp.nports; p++) {
      if (p)
        prompt_Printf(arg->prompt, ", ");
      prompt_Printf(arg->prompt, "%u", ipcp->cfg.urgent.udp.port[p]);
    }
  prompt_Printf(arg->prompt, "\n          TOS:    %s\n\n",
                ipcp->cfg.urgent.tos ? "yes" : "no");
d438 1
a445 1
  ipcp->route = NULL;
d449 3
d454 2
a455 2
    if (hp && hp->h_addrtype == AF_INET)
      memcpy(&ipcp->cfg.my_range.ipaddr.s_addr, hp->h_addr, hp->h_length);
d457 3
a459 2
  ipcp->cfg.netmask.s_addr = INADDR_ANY;
  memset(&ipcp->cfg.peer_range, '\0', sizeof ipcp->cfg.peer_range);
a468 11
  ipcp->cfg.urgent.tcp.nports = ipcp->cfg.urgent.tcp.maxports = NDEFTCPPORTS;
  ipcp->cfg.urgent.tcp.port = (u_short *)malloc(NDEFTCPPORTS * sizeof(u_short));
  memcpy(ipcp->cfg.urgent.tcp.port, default_urgent_tcp_ports,
         NDEFTCPPORTS * sizeof(u_short));
  ipcp->cfg.urgent.tos = 1;

  ipcp->cfg.urgent.udp.nports = ipcp->cfg.urgent.udp.maxports = NDEFUDPPORTS;
  ipcp->cfg.urgent.udp.port = (u_short *)malloc(NDEFUDPPORTS * sizeof(u_short));
  memcpy(ipcp->cfg.urgent.udp.port, default_urgent_udp_ports,
         NDEFUDPPORTS * sizeof(u_short));

d489 2
a490 10
  if (ipcp->cfg.urgent.tcp.maxports) {
    ipcp->cfg.urgent.tcp.nports = ipcp->cfg.urgent.tcp.maxports = 0;
    free(ipcp->cfg.urgent.tcp.port);
    ipcp->cfg.urgent.tcp.port = NULL;
  }
  if (ipcp->cfg.urgent.udp.maxports) {
    ipcp->cfg.urgent.udp.nports = ipcp->cfg.urgent.udp.maxports = 0;
    free(ipcp->cfg.urgent.udp.port);
    ipcp->cfg.urgent.udp.port = NULL;
  }
d511 2
d520 5
a524 5
    for (n = 0; n < iface->in_addrs; n++) {
      pos = iplist_ip2pos(&ipcp->cfg.peer_list, iface->in_addr[n].brd);
      if (pos != -1) {
        ipcp->cfg.peer_range.ipaddr =
          iplist_setcurpos(&ipcp->cfg.peer_list, pos);
d528 1
a528 1
    if (n == iface->in_addrs)
d530 1
a530 1
      ipcp->cfg.peer_range.ipaddr = iplist_setrandpos(&ipcp->cfg.peer_list);
d532 1
a532 2
    ipcp->cfg.peer_range.mask.s_addr = INADDR_BROADCAST;
    ipcp->cfg.peer_range.width = 32;
d537 1
a537 1
  ipcp->peer_ip = ipcp->cfg.peer_range.ipaddr;
d554 1
a554 2
     * connections that are bound to that IP (assuming we're not
     * ``iface-alias''ing).
d556 4
a559 4
    for (n = 0; n < iface->in_addrs; n++)
      if ((iface->in_addr[n].ifa.s_addr & ipcp->cfg.my_range.mask.s_addr) ==
          (ipcp->cfg.my_range.ipaddr.s_addr & ipcp->cfg.my_range.mask.s_addr)) {
        ipcp->my_ip = iface->in_addr[n].ifa;
d562 3
a564 2
    if (n == iface->in_addrs)
      ipcp->my_ip = ipcp->cfg.my_range.ipaddr;
d582 1
a582 1
  /* Copy startup values into ipcp->dns? */
d584 17
a600 5
    memcpy(ipcp->dns, ipcp->cfg.ns.dns, sizeof ipcp->dns);
  else if (ipcp->ns.dns[0].s_addr != INADDR_NONE)
    memcpy(ipcp->dns, ipcp->ns.dns, sizeof ipcp->dns);
  else
    ipcp->dns[0].s_addr = ipcp->dns[1].s_addr = INADDR_ANY;
d602 1
a602 2
  if (ipcp->dns[1].s_addr == INADDR_NONE)
    ipcp->dns[1] = ipcp->dns[0];
d606 3
a608 2
ipcp_doproxyall(struct bundle *bundle,
                int (*proxyfun)(struct bundle *, struct in_addr, int), int s)
d610 34
a643 18
  int n, ret;
  struct sticky_route *rp;
  struct in_addr addr;
  struct ipcp *ipcp;

  ipcp = &bundle->ncp.ipcp;
  for (rp = ipcp->route; rp != NULL; rp = rp->next) {
    if (rp->mask.s_addr == INADDR_BROADCAST)
        continue;
    n = ntohl(INADDR_BROADCAST) - ntohl(rp->mask.s_addr) - 1;
    if (n > 0 && n <= 254 && rp->dst.s_addr != INADDR_ANY) {
      addr = rp->dst;
      while (n--) {
        addr.s_addr = htonl(ntohl(addr.s_addr) + 1);
	log_Printf(LogDEBUG, "ipcp_doproxyall: %s\n", inet_ntoa(addr));
	ret = (*proxyfun)(bundle, addr, s);
	if (!ret)
	  return ret;
d645 1
d647 5
a651 1
  }
d653 1
a653 1
  return 0;
d657 2
a658 2
ipcp_SetIPaddress(struct bundle *bundle, struct in_addr myaddr,
                  struct in_addr hisaddr, int silent)
d660 14
a673 1
  struct in_addr mask, oaddr;
d677 3
a679 9
  if (bundle->ncp.ipcp.ifmask.s_addr != INADDR_ANY &&
      (bundle->ncp.ipcp.ifmask.s_addr & mask.s_addr) == mask.s_addr)
    mask.s_addr = bundle->ncp.ipcp.ifmask.s_addr;

  oaddr.s_addr = bundle->iface->in_addrs ?
                 bundle->iface->in_addr[0].ifa.s_addr : INADDR_ANY;
  if (!iface_inAdd(bundle->iface, myaddr, mask, hisaddr,
                 IFACE_ADD_FIRST|IFACE_FORCE_ADD))
    return -1;
d681 3
a683 4
  if (!Enabled(bundle, OPT_IFACEALIAS) && bundle->iface->in_addrs > 1
      && myaddr.s_addr != oaddr.s_addr)
    /* Nuke the old one */
    iface_inDelete(bundle->iface, oaddr);
d685 9
a693 2
  if (bundle->ncp.ipcp.cfg.sendpipe > 0 || bundle->ncp.ipcp.cfg.recvpipe > 0)
    rt_Update(bundle, hisaddr, myaddr);
d696 1
a696 2
    route_Change(bundle, bundle->ncp.ipcp.route, myaddr, hisaddr,
                 bundle->ncp.ipcp.ns.dns);
d700 1
a700 2
    route_Change(bundle, bundle->radius.routes, myaddr, hisaddr,
                 bundle->ncp.ipcp.ns.dns);
d703 1
a703 15
  if (Enabled(bundle, OPT_PROXY) || Enabled(bundle, OPT_PROXYALL)) {
    int s = ID0socket(AF_INET, SOCK_DGRAM, 0);
    if (s < 0)
      log_Printf(LogERROR, "ipcp_SetIPaddress: socket(): %s\n",
                 strerror(errno));
    else {
      if (Enabled(bundle, OPT_PROXYALL))
        ipcp_doproxyall(bundle, arp_SetProxy, s);
      else if (Enabled(bundle, OPT_PROXY))
        arp_SetProxy(bundle, hisaddr, s);
      close(s);
    }
  }

  return 0;
d716 1
a716 1
    if (ipcp_SetIPaddress(bundle, gw, try, 1) == 0) {
d783 5
a787 5
  if (IsEnabled(ipcp->cfg.ns.dns_neg) &&
      !REJECTED(ipcp, TY_PRIMARY_DNS - TY_ADJUST_NS)) {
    memcpy(o->data, &ipcp->dns[0].s_addr, 4);
    INC_LCP_OPT(TY_PRIMARY_DNS, 6, o);
  }
d789 4
a792 4
  if (IsEnabled(ipcp->cfg.ns.dns_neg) &&
      !REJECTED(ipcp, TY_SECONDARY_DNS - TY_ADJUST_NS)) {
    memcpy(o->data, &ipcp->dns[1].s_addr, 4);
    INC_LCP_OPT(TY_SECONDARY_DNS, 6, o);
d836 3
d840 1
a840 1
ipcp_CleanInterface(struct ipcp *ipcp)
d842 5
a846 1
  struct iface *iface = ipcp->fsm.bundle->iface;
d848 7
a854 14
  if (iface->in_addrs && (Enabled(ipcp->fsm.bundle, OPT_PROXY) ||
                          Enabled(ipcp->fsm.bundle, OPT_PROXYALL))) {
    int s = ID0socket(AF_INET, SOCK_DGRAM, 0);
    if (s < 0)
      log_Printf(LogERROR, "ipcp_CleanInterface: socket: %s\n",
                 strerror(errno));
    else {
      if (Enabled(ipcp->fsm.bundle, OPT_PROXYALL))
        ipcp_doproxyall(ipcp->fsm.bundle, arp_ClearProxy, s);
      else if (Enabled(ipcp->fsm.bundle, OPT_PROXY))
        arp_ClearProxy(ipcp->fsm.bundle, iface->in_addr[0].brd, s);
      close(s);
    }
  }
d856 2
a857 1
  iface_inClear(ipcp->fsm.bundle->iface, IFACE_CLEAR_ALL);
d864 1
d866 1
a866 2
  struct ipcp *ipcp = fsm2ipcp(fp);
  const char *s;
d869 2
a870 5
    if (ipcp->fsm.bundle->iface->in_addrs)
      s = inet_ntoa(ipcp->fsm.bundle->iface->in_addr[0].ifa);
    else
      s = "Interface configuration error !";
    log_Printf(LogIPCP, "%s: LayerDown: %s\n", fp->link->name, s);
d882 1
a882 1
    if (system_Select(fp->bundle, s, LINKDOWNFILE, NULL, NULL) < 0) {
d899 1
a899 1
  if (ipcp_SetIPaddress(ipcp->fsm.bundle, ipcp->my_ip, ipcp->peer_ip, 0) < 0) {
a959 8
static int
AcceptableAddr(const struct in_range *prange, struct in_addr ipaddr)
{
  /* Is the given IP in the given range ? */
  return (prange->ipaddr.s_addr & prange->mask.s_addr) ==
    (ipaddr.s_addr & prange->mask.s_addr) && ipaddr.s_addr;
}

d965 1
d969 1
d972 1
a972 1
        ipcp_SetIPaddress(bundle, ipcp->cfg.my_range.ipaddr, ip, 1)) {
d980 5
a984 3
      for (n = 0; n < iface->in_addrs; n++)
        if (iplist_ip2pos(&ipcp->cfg.peer_list, iface->in_addr[n].brd) >= 0) {
          ipcp->peer_ip = iface->in_addr[n].brd;
d987 1
d989 1
a989 1
      if (n == iface->in_addrs)
d991 2
a992 1
        ipcp->peer_ip = ChooseHisAddr(bundle, ipcp->cfg.my_range.ipaddr);
d1007 1
a1007 1
  } else if (!AcceptableAddr(&ipcp->cfg.peer_range, ip)) {
d1014 2
a1015 4
    for (n = 0; n < iface->in_addrs; n++)
      if ((iface->in_addr[n].brd.s_addr & ipcp->cfg.peer_range.mask.s_addr)
          == (ipcp->cfg.peer_range.ipaddr.s_addr &
              ipcp->cfg.peer_range.mask.s_addr)) {
d1017 1
a1017 1
        memcpy(dec->nakend, &iface->in_addr[n].brd.s_addr, 4);
d1021 1
a1021 1
    if (n == iface->in_addrs)
d1040 1
d1073 1
a1073 1
	if (AcceptableAddr(&ipcp->cfg.my_range, ipaddr)) {
d1079 2
a1080 1
          bundle_AdjustFilters(fp->bundle, &ipcp->my_ip, NULL);
d1210 1
a1210 1
        have_ip = ipcp->dns[type == TY_PRIMARY_DNS ? 0 : 1];
d1213 1
a1213 1
            ipaddr.s_addr == ipcp->dns[1].s_addr) {
d1215 3
a1217 3
          ipcp->dns[0] = ipcp->dns[1];
          ipcp->dns[1] = have_ip;
          have_ip = ipcp->dns[0];
d1241 2
a1242 1
          memcpy(&ipcp->dns[type == TY_PRIMARY_DNS ? 0 : 1].s_addr, cp + 2, 4);
a1302 1
    memcpy(ipcp->ns.dns, ipcp->dns, sizeof ipcp->ns.dns);
d1309 1
a1309 1
        bundle_AdjustDNS(fp->bundle, ipcp->dns);
d1312 1
a1312 1
      bundle_AdjustDNS(fp->bundle, ipcp->dns);
d1361 1
d1365 3
a1367 6
  ipcp->peer_ip = ipcp->cfg.peer_range.ipaddr = hisaddr;
  ipcp->cfg.peer_range.mask.s_addr = INADDR_BROADCAST;
  ipcp->cfg.peer_range.width = 32;

  if (ipcp_SetIPaddress(bundle, ipcp->cfg.my_range.ipaddr, hisaddr, 0) < 0)
    return 0;
d1369 1
a1369 1
  return 1;	/* Ok */
d1375 4
a1378 1
  struct ipcp *ipcp = &bundle->ncp.ipcp;
d1392 1
a1392 3
      ipcp->cfg.peer_range.ipaddr.s_addr = ipcp->peer_ip.s_addr;
      ipcp->cfg.peer_range.mask.s_addr = INADDR_BROADCAST;
      ipcp->cfg.peer_range.width = 32;
d1397 7
a1403 4
  } else if (ParseAddr(ipcp, hisaddr, &ipcp->cfg.peer_range.ipaddr,
		       &ipcp->cfg.peer_range.mask,
                       &ipcp->cfg.peer_range.width) != 0) {
    ipcp->peer_ip.s_addr = ipcp->cfg.peer_range.ipaddr.s_addr;
d1405 1
a1405 2
    if (setaddr && ipcp_SetIPaddress(bundle, ipcp->cfg.my_range.ipaddr,
                                     ipcp->cfg.peer_range.ipaddr, 0) < 0)
d1410 2
a1411 1
  bundle_AdjustFilters(bundle, NULL, &ipcp->peer_ip);
d1427 56
@


1.31
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d662 1
a662 1

d918 1
d1143 1
a1143 1
  int type, length, gotdnsnak, ipaddr_req;
a1149 1
  ipaddr_req = 0;
d1169 1
a1169 1
        ipaddr_req = 1;
d1417 11
a1427 2
    if (mode_type == MODE_REQ && !ipaddr_req) {
      /* We *REQUIRE* that the peer requests an IP address */
@


1.30
log
@Show the correct dial timeout when a random pause is configured
Understand ipencap traffic properly
Optimise out SIOCIFADDR ioctls that aren't necessary
Handle peers that don't send an initial IFADDR option during IPCP negotiations
Fix markup for the /etc/ttys example
Always use 4 arguments in examples of ``set ifaddr''
@
text
@d1 5
a5 2
/*
 *	PPP IP Control Protocol (IPCP) Module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 17
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: ipcp.c,v 1.29 2001/04/05 02:24:05 brian Exp $
 *
 *	TODO:
 *		o Support IPADDRS properly
 *		o Validate the length in IpcpDecodeConfig
d30 1
@


1.29
log
@When we change the interface MTU, run through the routing table and tweak
all route MTUs too.
@
text
@d20 1
a20 1
 * $OpenBSD: ipcp.c,v 1.28 2001/03/24 01:06:00 brian Exp $
d32 1
d996 6
d1061 71
a1135 1
  struct iface *iface = fp->bundle->iface;
d1137 1
a1137 1
  int type, length, gotdnsnak, n;
d1144 1
d1164 2
a1165 60
        if (iplist_isvalid(&ipcp->cfg.peer_list)) {
          if (ipaddr.s_addr == INADDR_ANY ||
              iplist_ip2pos(&ipcp->cfg.peer_list, ipaddr) < 0 ||
              ipcp_SetIPaddress(fp->bundle, ipcp->cfg.my_range.ipaddr,
                                ipaddr, 1)) {
            log_Printf(LogIPCP, "%s: Address invalid or already in use\n",
                      inet_ntoa(ipaddr));
            /*
             * If we've already had a valid address configured for the peer,
             * try NAKing with that so that we don't have to upset things
             * too much.
             */
            for (n = 0; n < iface->in_addrs; n++)
              if (iplist_ip2pos(&ipcp->cfg.peer_list, iface->in_addr[n].brd)
                  >=0) {
                ipcp->peer_ip = iface->in_addr[n].brd;
                break;
              }

            if (n == iface->in_addrs)
              /* Just pick an IP number from our list */
              ipcp->peer_ip = ChooseHisAddr
                (fp->bundle, ipcp->cfg.my_range.ipaddr);

            if (ipcp->peer_ip.s_addr == INADDR_ANY) {
	      memcpy(dec->rejend, cp, length);
	      dec->rejend += length;
            } else {
	      memcpy(dec->nakend, cp, 2);
	      memcpy(dec->nakend + 2, &ipcp->peer_ip.s_addr, length - 2);
	      dec->nakend += length;
            }
	    break;
          }
	} else if (!AcceptableAddr(&ipcp->cfg.peer_range, ipaddr)) {
	  /*
	   * If destination address is not acceptable, NAK with what we
	   * want to use.
	   */
	  memcpy(dec->nakend, cp, 2);
          for (n = 0; n < iface->in_addrs; n++)
            if ((iface->in_addr[n].brd.s_addr &
                 ipcp->cfg.peer_range.mask.s_addr)
                == (ipcp->cfg.peer_range.ipaddr.s_addr &
                    ipcp->cfg.peer_range.mask.s_addr)) {
              /* We prefer the already-configured address */
	      memcpy(dec->nakend + 2, &iface->in_addr[n].brd.s_addr,
                     length - 2);
              break;
            }

          if (n == iface->in_addrs)
	    memcpy(dec->nakend + 2, &ipcp->peer_ip.s_addr, length - 2);

	  dec->nakend += length;
	  break;
	}
	ipcp->peer_ip = ipaddr;
	memcpy(dec->ackend, cp, length);
	dec->ackend += length;
d1412 5
@


1.28
log
@Remove some unprotected prototype variable names
MAXPATHLEN -> PATH_MAX
Handle ENOENT from opening /dev/tun* properly
Rename _PATH_PPP -> PPP_CONFDIR and allow it to be redefined at compile time
Reduce MIN_LQRPERIOD and MIN_FSMRETRY to 1 second
Be smarter about identifying sockets on stdin
Allow primary DNS IP negotiation when the secondary IP has been rejected
Fix the call to PacketAliasProxyRule() properly.
Add/fix some comments
Fix man page markups; ru@@FreeBSD.org
Use localhost when no hostname is configured
@
text
@d20 1
a20 1
 * $OpenBSD: ipcp.c,v 1.27 2000/09/02 22:12:41 brian Exp $
d747 1
a747 1
  struct in_addr mask, oaddr, none = { INADDR_ANY };
d767 1
a767 1
    bundle_SetRoute(bundle, RTM_CHANGE, hisaddr, myaddr, none, 0, 0);
@


1.27
log
@Don't delete sticky routes on exit as we may not have successfully
added them yet.  Instead just rely on our deleting all routes
associated with our interface.
@
text
@d20 1
a20 1
 * $OpenBSD: ipcp.c,v 1.26 2000/08/28 22:44:41 brian Exp $
d874 1
a874 2
      !REJECTED(ipcp, TY_PRIMARY_DNS - TY_ADJUST_NS) &&
      !REJECTED(ipcp, TY_SECONDARY_DNS - TY_ADJUST_NS)) {
d877 4
@


1.26
log
@Support radius accounting, and add a packet count to throughput
statistics as a side effect.

Submitted by: Marcin Cieslak <saper@@system.pl>

with some tweaks to RAD_ACCT_SESSION_ID and
RAD_ACCT_MULTI_SESSION_ID generation by me.
@
text
@d20 1
a20 1
 * $OpenBSD: ipcp.c,v 1.25 2000/07/19 11:06:34 brian Exp $
a925 2

  route_Clean(ipcp->fsm.bundle, ipcp->route);
@


1.25
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d20 1
a20 1
 * $OpenBSD: ipcp.c,v 1.24 2000/06/13 09:57:51 brian Exp $
d962 6
d1019 5
@


1.24
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d20 1
a20 1
 * $OpenBSD: ipcp.c,v 1.23 2000/03/19 10:33:33 brian Exp $
a61 1
#include "lcp.h"
d67 1
@


1.23
log
@Allow environment variables on command/config lines; markk@@knigma.org
Add the ``resolv'' command so that when ``enable dns''
is used, it's possible to restore the file.
@
text
@d20 1
a20 1
 * $OpenBSD: ipcp.c,v 1.22 2000/03/03 21:52:57 brian Exp $
d370 1
a370 1
  mask = umask(0644);
d373 2
a374 1
    fputs(ipcp->ns.resolv_nons, fp);
d506 2
a508 1
  prompt_Printf(arg->prompt, "\n\n");
d575 1
@


1.22
log
@Fix some printf-type argument bugs
@
text
@d20 1
a20 1
 * $OpenBSD: ipcp.c,v 1.21 2000/02/27 01:38:26 brian Exp $
d41 1
d250 2
a251 2
static void
getdns(struct ipcp *ipcp, struct in_addr addr[2])
d253 68
a320 1
  FILE *fp;
d322 20
a341 16
  addr[0].s_addr = addr[1].s_addr = INADDR_ANY;
  if ((fp = fopen(_PATH_RESCONF, "r")) != NULL) {
    char buf[LINE_LEN], *cp, *end;
    int n;

    n = 0;
    buf[sizeof buf - 1] = '\0';
    while (fgets(buf, sizeof buf - 1, fp)) {
      if (!strncmp(buf, "nameserver", 10) && issep(buf[10])) {
        for (cp = buf + 11; issep(*cp); cp++)
          ;
        for (end = cp; isip(*end); end++)
          ;
        *end = '\0';
        if (inet_aton(cp, addr+n) && ++n == 2)
          break;
d343 5
a347 4
    }
    if (n == 1)
      addr[1] = addr[0];
    fclose(fp);
d351 2
a352 2
static int
setdns(struct ipcp *ipcp, struct in_addr addr[2])
d354 2
a356 5
  char wbuf[LINE_LEN + 54];
  int wlen;

  if (addr[0].s_addr == INADDR_ANY || addr[1].s_addr == INADDR_ANY) {
    struct in_addr old[2];
d358 3
a360 9
    getdns(ipcp, old);
    if (addr[0].s_addr == INADDR_ANY)
      addr[0] = old[0];
    if (addr[1].s_addr == INADDR_ANY)
      addr[1] = old[1];
  }

  if (addr[0].s_addr == INADDR_ANY && addr[1].s_addr == INADDR_ANY) {
    log_Printf(LogWARN, "%s not modified: All nameservers NAKd\n",
d365 23
a387 18
  wlen = 0;
  if ((fp = fopen(_PATH_RESCONF, "r")) != NULL) {
    char buf[LINE_LEN];
    int len;

    buf[sizeof buf - 1] = '\0';
    while (fgets(buf, sizeof buf - 1, fp)) {
      if (strncmp(buf, "nameserver", 10) || !issep(buf[10])) {
        len = strlen(buf);
        if (len > sizeof wbuf - wlen) {
          log_Printf(LogWARN, "%s: Can only cope with max file size %d\n",
                    _PATH_RESCONF, LINE_LEN);
          fclose(fp);
          return 0;
        }
        memcpy(wbuf + wlen, buf, len);
        wlen += len;
      }
d389 2
a390 2
    fclose(fp);
  }
d392 2
a393 6
  if (addr[0].s_addr != INADDR_ANY) {
    snprintf(wbuf + wlen, sizeof wbuf - wlen, "nameserver %s\n",
             inet_ntoa(addr[0]));
    log_Printf(LogIPCP, "Primary nameserver set to %s", wbuf + wlen + 11);
    wlen += strlen(wbuf + wlen);
  }
d395 6
a400 8
  if (addr[1].s_addr != INADDR_ANY && addr[1].s_addr != addr[0].s_addr) {
    snprintf(wbuf + wlen, sizeof wbuf - wlen, "nameserver %s\n",
             inet_ntoa(addr[1]));
    log_Printf(LogIPCP, "Secondary nameserver set to %s", wbuf + wlen + 11);
    wlen += strlen(wbuf + wlen);
  }

  if (wlen) {
d403 9
a411 10
    if ((fd = ID0open(_PATH_RESCONF, O_WRONLY|O_CREAT, 0644)) != -1) {
      if (write(fd, wbuf, wlen) != wlen) {
        log_Printf(LogERROR, "setdns: write(): %s\n", strerror(errno));
        close(fd);
        return 0;
      }
      if (ftruncate(fd, wlen) == -1) {
        log_Printf(LogERROR, "setdns: truncate(): %s\n", strerror(errno));
        close(fd);
        return 0;
d414 7
a420 7
    } else {
      log_Printf(LogERROR, "setdns: open(): %s\n", strerror(errno));
      return 0;
    }
  }

  return 1;
d469 6
a474 3
  prompt_Printf(arg->prompt, " DNS:             %s, ",
                inet_ntoa(ipcp->cfg.ns.dns[0]));
  prompt_Printf(arg->prompt, "%s, %s\n", inet_ntoa(ipcp->cfg.ns.dns[1]),
d476 7
a482 1
  prompt_Printf(arg->prompt, " NetBIOS NS:      %s, ",
d563 2
a564 2
  ipcp->cfg.ns.dns[0].s_addr = INADDR_ANY;
  ipcp->cfg.ns.dns[1].s_addr = INADDR_ANY;
d586 5
d609 8
d698 11
d767 2
a768 1
    route_Change(bundle, bundle->ncp.ipcp.route, myaddr, hisaddr);
d772 2
a773 1
    route_Change(bundle, bundle->radius.routes, myaddr, hisaddr);
d873 1
a873 3
    struct in_addr dns[2];
    getdns(ipcp, dns);
    memcpy(o->data, &dns[0].s_addr, 4);
d875 1
a875 1
    memcpy(o->data, &dns[1].s_addr, 4);
d1045 1
a1045 1
  int type, length, gotdns, gotdnsnak, n;
d1048 1
a1048 1
  struct in_addr ipaddr, dstipaddr, have_ip, dns[2], dnsnak[2];
a1050 1
  gotdns = 0;
a1051 1
  dnsnak[0].s_addr = dnsnak[1].s_addr = INADDR_ANY;
d1270 8
a1277 6
        if (!gotdns) {
          dns[0] = ipcp->cfg.ns.dns[0];
          dns[1] = ipcp->cfg.ns.dns[1];
          if (dns[0].s_addr == INADDR_ANY && dns[1].s_addr == INADDR_ANY)
            getdns(ipcp, dns);
          gotdns = 1;
a1278 1
        have_ip = dns[type == TY_PRIMARY_DNS ? 0 : 1];
d1298 1
a1298 1
      case MODE_NAK:		/* what does this mean?? */
d1301 1
a1301 1
          memcpy(&dnsnak[type == TY_PRIMARY_DNS ? 0 : 1].s_addr, cp + 2, 4);
d1361 12
a1372 4
  if (gotdnsnak)
    if (!setdns(ipcp, dnsnak)) {
      ipcp->peer_reject |= (1 << (TY_PRIMARY_DNS - TY_ADJUST_NS));
      ipcp->peer_reject |= (1 << (TY_SECONDARY_DNS - TY_ADJUST_NS));
d1374 1
@


1.21
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: ipcp.c,v 1.20 2000/02/27 00:21:08 brian Exp $
d374 2
a375 1
    prompt_Printf(arg->prompt, " Queued packets:  %d\n", ip_QueueLen(ipcp));
@


1.20
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.19 2000/01/07 03:26:54 brian Exp $
@


1.19
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.18 1999/08/05 10:32:14 brian Exp $
d45 3
a47 1
#ifdef __FreeBSD__
a48 2
#else
#include "alias.h"
d51 1
d212 17
a228 7
static const char * const cftypes[] = {
  /* Check out the latest ``Assigned numbers'' rfc (rfc1700.txt) */
  "???",
  "IPADDRS",	/* 1: IP-Addresses */	/* deprecated */
  "COMPPROTO",	/* 2: IP-Compression-Protocol */
  "IPADDR",	/* 3: IP-Address */
};
d230 3
a232 1
#define NCFTYPES (sizeof cftypes/sizeof cftypes[0])
d234 2
a235 10
static const char * const cftypes128[] = {
  /* Check out the latest ``Assigned numbers'' rfc (rfc1700.txt) */
  "???",
  "PRIDNS",	/* 129: Primary DNS Server Address */
  "PRINBNS",	/* 130: Primary NBNS Server Address */
  "SECDNS",	/* 131: Secondary DNS Server Address */
  "SECNBNS",	/* 132: Secondary NBNS Server Address */
};

#define NCFTYPES128 (sizeof cftypes128/sizeof cftypes128[0])
d968 1
a968 6
    if (type < NCFTYPES)
      snprintf(tbuff, sizeof tbuff, " %s[%d] ", cftypes[type], length);
    else if (type > 128 && type < 128 + NCFTYPES128)
      snprintf(tbuff, sizeof tbuff, " %s[%d] ", cftypes128[type-128], length);
    else
      snprintf(tbuff, sizeof tbuff, " <%d>[%d] ", type, length);
@


1.18
log
@o Obsolete the undocumented ``set weight'' command.
o If we're using RADIUS and the RADIUS mtu is less than our
  peers mru/mrru, reduce our mtu to this value for NetBSD too.
o Make struct throughput's sample period dynamic and tweak the ppp
  version number to reflect the extra stuff being passed through
  the local domain socket as a result (MP mode).
o Measure the current throughput based on the number of samples actually
  taken rather than on the full sample period.
o Keep the throughput statisics persistent while being passed to
  another ppp invocation through the local domain socket.
o When showing throughput statistics after the timer has stopped, use
  the stopped time for overall calculations, not the current time.
  Also show the stopped time and how long the current throughput has
  been sampled for.
o Use time() consistently in throughput.c
o Tighten up the ``show bundle'' output.
o Introduce the ``set bandwidth'' command.
o Rewrite the ``set autoload'' command.  It now takes three arguments
  and works based on a rolling bundle throughput average compared against
  the theoretical bundle bandwidth over a given period (read: it's now
  functional).
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.17 1999/06/08 20:12:30 brian Exp $
d44 1
a44 1
#ifndef NOALIAS
d85 1
d92 88
d211 1
a211 1
static const char *cftypes[] = {
d221 1
a221 1
static const char *cftypes128[] = {
d360 1
d369 1
d409 21
a429 1
  prompt_Printf(arg->prompt, "\n");
d466 1
a466 1
  static const char *timer_names[] =
d492 10
d515 15
d884 2
a885 2
#ifndef NOALIAS
  if (ipcp->fsm.bundle->AliasEnabled)
d1287 1
a1287 1
  mbuf_SetType(bp, MB_IPCPIN);
d1294 1
a1294 1
    mbuf_Free(bp);
@


1.17
log
@Don't use static variables if we don't have to.
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.16 1999/06/08 11:59:00 brian Exp $
d388 1
a388 1
  throughput_init(&ipcp->throughput);
@


1.16
log
@Don't IPCP TLD if we're already doing it.  This prevents
recursion by doing something like ``down'' or ``quit all''
in ppp.linkdown.
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.15 1999/06/02 15:58:40 brian Exp $
d507 1
a507 2
  static struct in_addr none = { INADDR_ANY };
  struct in_addr mask, oaddr;
@


1.15
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.14 1999/05/31 23:57:37 brian Exp $
d712 1
d716 19
a734 5
  if (ipcp->fsm.bundle->iface->in_addrs)
    s = inet_ntoa(ipcp->fsm.bundle->iface->in_addr[0].ifa);
  else
    s = "Interface configuration error !";
  log_Printf(LogIPCP, "%s: LayerDown: %s\n", fp->link->name, s);
d736 1
a736 11
  /*
   * XXX this stuff should really live in the FSM.  Our config should
   * associate executable sections in files with events.
   */
  if (system_Select(fp->bundle, s, LINKDOWNFILE, NULL, NULL) < 0) {
    if (bundle_GetLabel(fp->bundle)) {
       if (system_Select(fp->bundle, bundle_GetLabel(fp->bundle),
                        LINKDOWNFILE, NULL, NULL) < 0)
       system_Select(fp->bundle, "MYADDR", LINKDOWNFILE, NULL, NULL);
    } else
      system_Select(fp->bundle, "MYADDR", LINKDOWNFILE, NULL, NULL);
d738 1
a738 2

  ipcp_Setup(ipcp, INADDR_NONE);
@


1.14
log
@Remember if MYADDR or HISADDR is used in a filter add tweak all
filters any time either value changes.
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.13 1999/05/09 20:04:00 brian Exp $
d643 2
a644 1
  fsm_Output(fp, CODE_CONFIGREQ, fp->reqid, buff, (u_char *)o - buff);
d657 1
a657 1
  fsm_Output(fp, CODE_TERMACK, id, NULL, 0);
d1148 1
@


1.13
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.12 1999/05/08 11:06:35 brian Exp $
d906 1
d1190 1
a1190 1
        return(0);
d1210 3
a1212 1
  return 1;
@


1.12
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.11 1999/04/26 08:55:01 brian Exp $
d798 1
a798 1
IpcpDecodeConfig(struct fsm *fp, u_char * cp, int plen, int mode_type,
@


1.11
log
@Add support for NetBSD
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.10 1999/04/26 08:54:50 brian Exp $
d23 2
a24 1
 *		o More RFC1772 backward compatibility
d51 1
d59 1
a59 1
#include "lcpproto.h"
d1012 2
a1013 4
	ipcp->peer_ip = ipaddr;
	ipcp->my_ip = dstipaddr;
	memcpy(dec->ackend, cp, length);
	dec->ackend += length;
a1016 7
        snprintf(tbuff2, sizeof tbuff2, "%s changing address: %s", tbuff,
		 inet_ntoa(ipcp->my_ip));
	log_Printf(LogIPCP, "%s --> %s\n", tbuff2, inet_ntoa(ipaddr));
	ipcp->my_ip = ipaddr;
	ipcp->peer_ip = dstipaddr;
	break;

a1017 1
	ipcp->peer_reject |= (1 << type);
d1142 2
a1143 2
void
ipcp_Input(struct ipcp *ipcp, struct bundle *bundle, struct mbuf *bp)
d1147 1
a1147 1
    fsm_Input(&ipcp->fsm, bp);
d1151 1
a1151 1
                 ipcp->fsm.link->name, bundle_PhaseName(bundle));
d1154 1
@


1.10
log
@#include <errno.h>, not <sys/errno.h>
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.9 1999/03/03 23:01:10 brian Exp $
d44 3
a46 1
#ifdef __OpenBSD__
a47 2
#else
#include <alias.h>
@


1.9
log
@Correct some ntohl/htonl bogons in the netmask handling.
This was pretty harmless as netmasks on a POINTOPOINT
interface are pretty much ignored, but it looked funny.

Mention the configured netmask in ``show ipcp''.

Describe in more detail what a proxy arp entry is.
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.8 1999/02/26 21:28:22 brian Exp $
d35 1
a39 1
#include <sys/errno.h>
@


1.8
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.7 1999/02/06 03:22:39 brian Exp $
d291 1
a291 1

d293 1
a293 1
    prompt_Printf(arg->prompt, " (trigger with %s)",
d295 2
a296 1
  prompt_Printf(arg->prompt, "\n VJ compression:  %s (%d slots %s slot "
d483 1
a483 1
    if (ntohl(rp->mask.s_addr) == INADDR_BROADCAST)
d485 1
a485 1
    n = INADDR_BROADCAST - ntohl(rp->mask.s_addr) - 1;
a506 1
  u_int32_t addr;
d508 1
a508 2
  addr = htonl(myaddr.s_addr);
  mask.s_addr = addr2mask(addr);
d511 2
a512 2
      (ntohl(bundle->ncp.ipcp.ifmask.s_addr) & mask.s_addr) == mask.s_addr)
    mask.s_addr = htonl(bundle->ncp.ipcp.ifmask.s_addr);
d1217 13
@


1.7
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.70 1999/02/02 20:27:12 brian Exp $
d99 1
a99 1
static void IpcpInitRestartCounter(struct fsm *);
d285 4
d355 1
a355 1
  fsm_Init(&ipcp->fsm, "IPCP", PROTO_IPCP, 1, IPCP_MAXCODE, 10, LogIPCP,
d378 3
a380 1
  ipcp->cfg.fsmretry = DEF_FSMRETRY;
a402 1
  ipcp->fsm.maxconfig = 10;
d579 1
a579 1
IpcpInitRestartCounter(struct fsm * fp)
d584 12
a595 2
  fp->FsmTimer.load = ipcp->cfg.fsmretry * SECTICKS;
  fp->restart = DEF_REQs;
d646 1
a646 1
IpcpSentTerminateReq(struct fsm * fp)
d667 1
a667 2

  /* This is where we should be setting up the interface in AUTO mode */
d782 1
d784 1
@


1.6
log
@Change the timer routines so that they interrupt when the next
item is scheduled rather than interrupting 10 times per second
and finding that there's nothing to do most of the time.
This change reduces interrupt overheads but will expose any
(previously small) latency problems.

Be more careful about building VJ compression requests - we
can't htonl/ntohl the entire four bytes !  Also, when we get
a NAK, try to get as close as possible to what the peer NAKs
with when sending our next REQ.  Similarily when we send a NAK,
pick values as close as possible to what the peer REQd.

Fix a couple of man page typos (compliments of billf@@FreeBSD.org)
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.5 1998/10/29 02:21:45 brian Exp $
a32 2
#include <net/if.h>
#include <sys/sockio.h>
a33 1
#include <arpa/nameser.h>
d73 3
d281 1
a281 1
    route_ShowSticky(arg->prompt, ipcp->route);
d381 1
a381 1
  ipcp_Setup(ipcp);
d391 1
a391 1
ipcp_Setup(struct ipcp *ipcp)
d398 1
d450 5
a454 1
  if (IsEnabled(ipcp->cfg.vj.neg))
d504 1
a504 6
  if (IN_CLASSA(addr))
    mask.s_addr = htonl(IN_CLASSA_NET);
  else if (IN_CLASSB(addr))
    mask.s_addr = htonl(IN_CLASSB_NET);
  else
    mask.s_addr = htonl(IN_CLASSC_NET);
d506 3
a508 3
  if (bundle->ncp.ipcp.cfg.netmask.s_addr != INADDR_ANY &&
      (ntohl(bundle->ncp.ipcp.cfg.netmask.s_addr) & mask.s_addr) == mask.s_addr)
    mask.s_addr = htonl(bundle->ncp.ipcp.cfg.netmask.s_addr);
d527 5
d718 1
a718 1
  ipcp_Setup(ipcp);
d1150 17
d1190 1
a1190 1
  } else if (ParseAddr(ipcp, 1, &hisaddr, &ipcp->cfg.peer_range.ipaddr,
@


1.5
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.4 1998/09/04 18:42:08 brian Exp $
d601 6
a606 1
      ua_htonl(&ipcp->my_compproto, o->data);
d898 3
a900 1
      memcpy(&compproto, cp + 2, 4);
a908 1
	  pcomp = (struct compreq *) (cp + 2);
d912 2
a913 1
	      log_Printf(LogWARN, "Peer is speaking RFC1172 compression protocol !\n");
d926 17
a942 7
	    if (ntohs(pcomp->proto) == PROTO_VJCOMP
		&& pcomp->slots <= MAX_VJ_STATES
                && pcomp->slots >= MIN_VJ_STATES) {
	      ipcp->peer_compproto = compproto;
	      ipcp->heis1172 = 0;
	      memcpy(dec->ackend, cp, length);
	      dec->ackend += length;
d944 1
d948 1
a948 1
	      pcomp->compcid = 0;
d962 9
d973 1
a973 1
	ipcp->my_compproto = compproto;
@


1.4
log
@Add a missing #include
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.3 1998/09/04 18:27:46 brian Exp $
d31 1
d36 1
d82 1
d360 1
a360 1
    if (hp && hp->h_addrtype == AF_INET) {
a361 3
      ipcp->cfg.peer_range.mask.s_addr = INADDR_BROADCAST;
      ipcp->cfg.peer_range.width = 32;
    }
a378 3
  ipcp->my_ifip.s_addr = INADDR_ANY;
  ipcp->peer_ifip.s_addr = INADDR_ANY;

d393 2
a394 1
  int pos;
d400 11
a410 4
    if (ipcp->my_ifip.s_addr != INADDR_ANY &&
        (pos = iplist_ip2pos(&ipcp->cfg.peer_list, ipcp->my_ifip)) != -1)
      ipcp->cfg.peer_range.ipaddr = iplist_setcurpos(&ipcp->cfg.peer_list, pos);
    else
d412 1
d431 1
a431 3
  } else if ((ipcp->my_ifip.s_addr & ipcp->cfg.my_range.mask.s_addr) ==
             (ipcp->cfg.my_range.ipaddr.s_addr &
              ipcp->cfg.my_range.mask.s_addr))
d433 5
a437 3
     * Otherwise, if we've been assigned an IP number before, we really
     * want to keep the same IP number so that we can keep any existing
     * connections that are bound to that IP.
d439 9
a447 3
    ipcp->my_ip = ipcp->my_ifip;
  else
    ipcp->my_ip = ipcp->cfg.my_range.ipaddr;
d462 29
d494 3
a496 9
  struct sockaddr_in *sock_in;
  int s;
  u_int32_t mask, addr;
  struct ifaliasreq ifra;

  /* If given addresses are alreay set, then ignore this request */
  if (bundle->ncp.ipcp.my_ifip.s_addr == myaddr.s_addr &&
      bundle->ncp.ipcp.peer_ifip.s_addr == hisaddr.s_addr)
    return 0;
d498 1
a498 25
  ipcp_CleanInterface(&bundle->ncp.ipcp);

  s = ID0socket(AF_INET, SOCK_DGRAM, 0);
  if (s < 0) {
    log_Printf(LogERROR, "SetIPaddress: socket(): %s\n", strerror(errno));
    return (-1);
  }

  memset(&ifra, '\0', sizeof ifra);
  strncpy(ifra.ifra_name, bundle->ifp.Name, sizeof ifra.ifra_name - 1);
  ifra.ifra_name[sizeof ifra.ifra_name - 1] = '\0';

  /* Set interface address */
  sock_in = (struct sockaddr_in *)&ifra.ifra_addr;
  sock_in->sin_family = AF_INET;
  sock_in->sin_addr = myaddr;
  sock_in->sin_len = sizeof *sock_in;

  /* Set destination address */
  sock_in = (struct sockaddr_in *)&ifra.ifra_broadaddr;
  sock_in->sin_family = AF_INET;
  sock_in->sin_addr = hisaddr;
  sock_in->sin_len = sizeof *sock_in;

  addr = ntohl(myaddr.s_addr);
d500 1
a500 1
    mask = IN_CLASSA_NET;
d502 1
a502 1
    mask = IN_CLASSB_NET;
d504 1
a504 1
    mask = IN_CLASSC_NET;
a505 1
  /* if subnet mask is given, use it instead of class mask */
d507 13
a519 2
      (ntohl(bundle->ncp.ipcp.cfg.netmask.s_addr) & mask) == mask)
    mask = ntohl(bundle->ncp.ipcp.cfg.netmask.s_addr);
d521 2
a522 12
  sock_in = (struct sockaddr_in *)&ifra.ifra_mask;
  sock_in->sin_family = AF_INET;
  sock_in->sin_addr.s_addr = htonl(mask);
  sock_in->sin_len = sizeof *sock_in;

  if (ID0ioctl(s, SIOCAIFADDR, &ifra) < 0) {
    if (!silent)
      log_Printf(LogERROR, "SetIPaddress: ioctl(SIOCAIFADDR): %s\n",
		strerror(errno));
    close(s);
    return (-1);
  }
d527 13
a539 2
  bundle->ncp.ipcp.peer_ifip.s_addr = hisaddr.s_addr;
  bundle->ncp.ipcp.my_ifip.s_addr = myaddr.s_addr;
d541 1
a541 5
  if (Enabled(bundle, OPT_PROXY))
    arp_SetProxy(bundle, bundle->ncp.ipcp.peer_ifip, s);

  close(s);
  return (0);
d545 1
a545 1
ChooseHisAddr(struct bundle *bundle, const struct in_addr gw)
d660 1
a660 9
  struct ifaliasreq ifra;
  struct sockaddr_in *me, *peer;
  int s;

  s = ID0socket(AF_INET, SOCK_DGRAM, 0);
  if (s < 0) {
    log_Printf(LogERROR, "ipcp_CleanInterface: socket: %s\n", strerror(errno));
    return;
  }
d664 13
a676 19
  if (Enabled(ipcp->fsm.bundle, OPT_PROXY))
    arp_ClearProxy(ipcp->fsm.bundle, ipcp->peer_ifip, s);

  if (ipcp->my_ifip.s_addr != INADDR_ANY ||
      ipcp->peer_ifip.s_addr != INADDR_ANY) {
    memset(&ifra, '\0', sizeof ifra);
    strncpy(ifra.ifra_name, ipcp->fsm.bundle->ifp.Name,
            sizeof ifra.ifra_name - 1);
    ifra.ifra_name[sizeof ifra.ifra_name - 1] = '\0';
    me = (struct sockaddr_in *)&ifra.ifra_addr;
    peer = (struct sockaddr_in *)&ifra.ifra_broadaddr;
    me->sin_family = peer->sin_family = AF_INET;
    me->sin_len = peer->sin_len = sizeof(struct sockaddr_in);
    me->sin_addr = ipcp->my_ifip;
    peer->sin_addr = ipcp->peer_ifip;
    if (ID0ioctl(s, SIOCDIFADDR, &ifra) < 0)
      log_Printf(LogERROR, "ipcp_CleanInterface: ioctl(SIOCDIFADDR): %s\n",
                strerror(errno));
    ipcp->my_ifip.s_addr = ipcp->peer_ifip.s_addr = INADDR_ANY;
d679 1
a679 1
  close(s);
d689 4
a692 1
  s = inet_ntoa(ipcp->peer_ifip);
a707 3
  if (!(ipcp->fsm.bundle->phys_type.all & PHYS_AUTO))
    ipcp_CleanInterface(ipcp);

d732 1
a732 1
  char tbuff[100];
d735 3
a737 2
  snprintf(tbuff, sizeof tbuff, "myaddr = %s ", inet_ntoa(ipcp->my_ip));
  log_Printf(LogIPCP, " %s hisaddr = %s\n", tbuff, inet_ntoa(ipcp->peer_ip));
d749 1
a749 2
  if (system_Select(fp->bundle, inet_ntoa(ipcp->my_ifip), LINKUPFILE,
                    NULL, NULL) < 0) {
d763 1
a763 1
AcceptableAddr(struct in_range *prange, struct in_addr ipaddr)
d775 1
d777 1
a777 1
  int type, length;
a781 1
  int gotdns, gotdnsnak;
d817 13
a829 8
            if (iplist_ip2pos(&ipcp->cfg.peer_list, ipcp->peer_ifip) >= 0)
              /*
               * If we've already got a valid address configured for the peer
               * (in AUTO mode), try NAKing with that so that we don't
               * have to upset things too much.
               */
              ipcp->peer_ip = ipcp->peer_ifip;
            else
d839 1
a839 1
	      memcpy(dec->nakend+2, &ipcp->peer_ip.s_addr, length - 2);
d850 14
a863 7
          if ((ipcp->peer_ifip.s_addr & ipcp->cfg.peer_range.mask.s_addr) ==
             (ipcp->cfg.peer_range.ipaddr.s_addr &
              ipcp->cfg.peer_range.mask.s_addr))
            /* We prefer the already-configured address */
	    memcpy(dec->nakend+2, &ipcp->peer_ifip.s_addr, length - 2);
          else
	    memcpy(dec->nakend+2, &ipcp->peer_ip.s_addr, length - 2);
d871 1
d885 1
d891 1
d942 1
d948 1
d954 1
d968 1
d976 1
d1022 1
d1029 1
d1063 1
d1067 1
d1147 1
a1147 3
                                     ipcp->cfg.peer_range.ipaddr, 0) < 0) {
      ipcp->cfg.my_range.ipaddr.s_addr = INADDR_ANY;
      ipcp->cfg.peer_range.ipaddr.s_addr = INADDR_ANY;
a1148 1
    }
@


1.3
log
@Don't cast potentially unaligned addresses to pointers to
non-char types on non-i386 architectures.
On Alpha and Sparc we get a bus error if we do.
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.2 1998/08/31 08:16:39 brian Exp $
d51 1
@


1.2
log
@Move libalias sources into the ppp directory.
Suggested (many times) by: Theo
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.1 1998/08/31 00:22:21 brian Exp $
d571 1
a571 1
    *(u_int32_t *)o->data = ipcp->my_ip.s_addr;
d577 3
a579 1
      *(u_int32_t *)o->data = htons(PROTO_VJCOMP);
d582 1
a582 1
      *(u_int32_t *)o->data = htonl(ipcp->my_compproto);
d592 1
a592 1
    *(u_int32_t *)o->data = dns[0].s_addr;
d594 1
a594 1
    *(u_int32_t *)o->data = dns[1].s_addr;
d800 1
a800 1
      ipaddr.s_addr = *(u_int32_t *)(cp + 2);
d873 1
a873 1
      compproto = htonl(*(u_int32_t *)(cp + 2));
d933 2
a934 2
      ipaddr.s_addr = *(u_int32_t *)(cp + 2);
      dstipaddr.s_addr = *(u_int32_t *)(cp + 6);
d960 1
a960 1
      ipaddr.s_addr = *(u_int32_t *)(cp + 2);
d1000 1
a1000 2
          dnsnak[type == TY_PRIMARY_DNS ? 0 : 1].s_addr =
            *(u_int32_t *)(cp + 2);
d1011 1
a1011 1
      ipaddr.s_addr = *(u_int32_t *)(cp + 2);
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: ipcp.c,v 1.64 1998/08/26 17:39:37 brian Exp $
a35 3
#ifndef NOALIAS
#include <alias.h>
#endif
d44 7
@

