head	1.32;
access;
symbols
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.8
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.6
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.29.0.10
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.8
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.6
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.27.0.16
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.14
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.12
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.10
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.8
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.6
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.10
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.8
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.6
	OPENBSD_3_4_BASE:1.25
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.32
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.31;

1.31
date	2013.10.17.16.27.47;	author bluhm;	state Exp;
branches;
next	1.30;

1.30
date	2012.01.23.09.13.16;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.02.16.08.29;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.25.15.59.28;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.17.19.13.24;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.23.15.55.21;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.16.14.13.06;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.23.11.17.03;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.21.11.06.04;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.21.04.09.19;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.19.10.24.54;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.04.16.09.28;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.03.08.23.27;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.28.09.52.56;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.25.01.38.13;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.14.13.24.02;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.19.21.43.41;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.27.01.38.26;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.27.00.21.07;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.07.03.47.12;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.31.23.57.37;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.27.08.44.48;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.35;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.04.26.08.54.50;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.37;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.10.29.02.21.45;	author brian;	state Exp;
branches;
next	;


desc
@@


1.32
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1998 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: iface.c,v 1.31 2013/10/17 16:27:47 bluhm Exp $
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <net/if_dl.h>
#ifdef __FreeBSD__
#include <net/if_var.h>
#endif
#include <net/route.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#ifndef NOINET6
#include <netinet6/in6_var.h>
#include <netinet6/nd6.h>
#endif
#include <sys/un.h>

#include <errno.h>
#include <ifaddrs.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "id.h"
#include "timer.h"
#include "fsm.h"
#include "iplist.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "slcompress.h"
#include "descriptor.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "prompt.h"
#include "iface.h"

#define IN6MASK128	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
			    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}}
static const struct in6_addr in6mask128 = IN6MASK128;

struct iface *
iface_Create(const char *name)
{
  struct ifaddrs *ifap, *ifa;
  struct iface *iface;
  struct iface_addr *addr;

  if (getifaddrs(&ifap) != 0) {
    fprintf(stderr, "iface_Create: getifaddrs: %s\n", strerror(errno));
    return NULL;
  }

  iface = NULL;

  for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
    if (strcmp(name, ifa->ifa_name))
      continue;
    if (ifa->ifa_addr->sa_family == AF_LINK) {
      iface = (struct iface *)malloc(sizeof *iface);
      if (iface == NULL) {
        fprintf(stderr, "iface_Create: malloc: %s\n", strerror(errno));
        freeifaddrs(ifap);
        return NULL;
      }
      iface->name = strdup(name);
      iface->index = if_nametoindex(name);
      iface->flags = ifa->ifa_flags;
      iface->mtu = 0;
      iface->addrs = 0;
      iface->addr = NULL;
    }

    if (ifa->ifa_addr->sa_family == AF_INET
#ifndef NOINET6
        || ifa->ifa_addr->sa_family == AF_INET6
#endif
       ) {
      /* Record the address */

      addr = (struct iface_addr *)
        realloc(iface->addr, (iface->addrs + 1) * sizeof iface->addr[0]);
      if (addr == NULL)
        break;
      iface->addr = addr;

      addr += iface->addrs;
      iface->addrs++;

      ncprange_setsa(&addr->ifa, ifa->ifa_addr, ifa->ifa_netmask);
      if (ifa->ifa_broadaddr)
        ncpaddr_setsa(&addr->peer, ifa->ifa_broadaddr);
      else
        ncpaddr_init(&addr->peer);
    }
  }

  freeifaddrs(ifap);

  return iface;
}

static int
iface_addr_Zap(const char *name, struct iface_addr *addr, int s)
{
  struct ifaliasreq ifra;
#ifndef NOINET6
  struct in6_aliasreq ifra6;
#endif
  struct sockaddr_in *me4, *msk4, *peer4;
  struct sockaddr_storage ssme, sspeer, ssmsk;
  int res;

  ncprange_getsa(&addr->ifa, &ssme, &ssmsk);
  ncpaddr_getsa(&addr->peer, &sspeer);
  res = 0;

  switch (ncprange_family(&addr->ifa)) {
  case AF_INET:
    memset(&ifra, '\0', sizeof ifra);
    strncpy(ifra.ifra_name, name, sizeof ifra.ifra_name - 1);

    me4 = (struct sockaddr_in *)&ifra.ifra_addr;
    memcpy(me4, &ssme, sizeof *me4);

    msk4 = (struct sockaddr_in *)&ifra.ifra_mask;
    memcpy(msk4, &ssmsk, sizeof *msk4);

    peer4 = (struct sockaddr_in *)&ifra.ifra_broadaddr;
    if (ncpaddr_family(&addr->peer) == AF_UNSPEC) {
      peer4->sin_family = AF_INET;
      peer4->sin_len = sizeof(*peer4);
      peer4->sin_addr.s_addr = INADDR_NONE;
    } else
      memcpy(peer4, &sspeer, sizeof *peer4);

    res = ID0ioctl(s, SIOCDIFADDR, &ifra);
    if (log_IsKept(LogDEBUG)) {
      char buf[100];

      snprintf(buf, sizeof buf, "%s", ncprange_ntoa(&addr->ifa));
      log_Printf(LogWARN, "%s: DIFADDR %s -> %s returns %d\n",
                 ifra.ifra_name, buf, ncpaddr_ntoa(&addr->peer), res);
    }
    break;

#ifndef NOINET6
  case AF_INET6:
    memset(&ifra6, '\0', sizeof ifra6);
    strncpy(ifra6.ifra_name, name, sizeof ifra6.ifra_name - 1);

    memcpy(&ifra6.ifra_addr, &ssme, sizeof ifra6.ifra_addr);
    memcpy(&ifra6.ifra_prefixmask, &ssmsk, sizeof ifra6.ifra_prefixmask);
    ifra6.ifra_prefixmask.sin6_family = AF_UNSPEC;
    if (ncpaddr_family(&addr->peer) == AF_UNSPEC)
      ifra6.ifra_dstaddr.sin6_family = AF_UNSPEC;
    else
      memcpy(&ifra6.ifra_dstaddr, &sspeer, sizeof ifra6.ifra_dstaddr);
    ifra6.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME;
    ifra6.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME;

    res = ID0ioctl(s, SIOCDIFADDR_IN6, &ifra6);
    break;
#endif
  }

  if (res == -1) {
    char dst[40];
    const char *end =
#ifndef NOINET6
      ncprange_family(&addr->ifa) == AF_INET6 ? "_IN6" :
#endif
      "";

    if (ncpaddr_family(&addr->peer) == AF_UNSPEC)
      log_Printf(LogWARN, "iface rm: ioctl(SIOCDIFADDR%s, %s): %s\n",
                 end, ncprange_ntoa(&addr->ifa), strerror(errno));
    else {
      snprintf(dst, sizeof dst, "%s", ncpaddr_ntoa(&addr->peer));
      log_Printf(LogWARN, "iface rm: ioctl(SIOCDIFADDR%s, %s -> %s): %s\n",
                 end, ncprange_ntoa(&addr->ifa), dst, strerror(errno));
    }
  }

  return res != -1;
}

static int
iface_addr_Add(const char *name, struct iface_addr *addr, int s)
{
  struct ifaliasreq ifra;
#ifndef NOINET6
  struct in6_aliasreq ifra6;
#endif
  struct sockaddr_in *me4, *msk4, *peer4;
  struct sockaddr_storage ssme, sspeer, ssmsk;
  int res;

  ncprange_getsa(&addr->ifa, &ssme, &ssmsk);
  ncpaddr_getsa(&addr->peer, &sspeer);
  res = 0;

  switch (ncprange_family(&addr->ifa)) {
  case AF_INET:
    memset(&ifra, '\0', sizeof ifra);
    strncpy(ifra.ifra_name, name, sizeof ifra.ifra_name - 1);

    me4 = (struct sockaddr_in *)&ifra.ifra_addr;
    memcpy(me4, &ssme, sizeof *me4);

    msk4 = (struct sockaddr_in *)&ifra.ifra_mask;
    memcpy(msk4, &ssmsk, sizeof *msk4);

    peer4 = (struct sockaddr_in *)&ifra.ifra_broadaddr;
    if (ncpaddr_family(&addr->peer) == AF_UNSPEC) {
      peer4->sin_family = AF_INET;
      peer4->sin_len = sizeof(*peer4);
      peer4->sin_addr.s_addr = INADDR_NONE;
    } else
      memcpy(peer4, &sspeer, sizeof *peer4);

    res = ID0ioctl(s, SIOCAIFADDR, &ifra);
    if (log_IsKept(LogDEBUG)) {
      char buf[100];

      snprintf(buf, sizeof buf, "%s", ncprange_ntoa(&addr->ifa));
      log_Printf(LogWARN, "%s: AIFADDR %s -> %s returns %d\n",
                 ifra.ifra_name, buf, ncpaddr_ntoa(&addr->peer), res);
    }
    break;

#ifndef NOINET6
  case AF_INET6:
    memset(&ifra6, '\0', sizeof ifra6);
    strncpy(ifra6.ifra_name, name, sizeof ifra6.ifra_name - 1);

    memcpy(&ifra6.ifra_addr, &ssme, sizeof ifra6.ifra_addr);
    memcpy(&ifra6.ifra_prefixmask, &ssmsk, sizeof ifra6.ifra_prefixmask);
    if (ncpaddr_family(&addr->peer) == AF_UNSPEC)
      ifra6.ifra_dstaddr.sin6_family = AF_UNSPEC;
    else if (memcmp(&((struct sockaddr_in6 *)&ssmsk)->sin6_addr, &in6mask128,
		    sizeof in6mask128) == 0)
      memcpy(&ifra6.ifra_dstaddr, &sspeer, sizeof ifra6.ifra_dstaddr);
    ifra6.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME;
    ifra6.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME;

    res = ID0ioctl(s, SIOCAIFADDR_IN6, &ifra6);
    break;
#endif
  }

  if (res == -1) {
    char dst[40];
    const char *end =
#ifndef NOINET6
      ncprange_family(&addr->ifa) == AF_INET6 ? "_IN6" :
#endif
      "";

    if (ncpaddr_family(&addr->peer) == AF_UNSPEC)
      log_Printf(LogWARN, "iface add: ioctl(SIOCAIFADDR%s, %s): %s\n",
                 end, ncprange_ntoa(&addr->ifa), strerror(errno));
    else {
      snprintf(dst, sizeof dst, "%s", ncpaddr_ntoa(&addr->peer));
      log_Printf(LogWARN, "iface add: ioctl(SIOCAIFADDR%s, %s -> %s): %s\n",
                 end, ncprange_ntoa(&addr->ifa), dst, strerror(errno));
    }
  }

  return res != -1;
}


void
iface_Clear(struct iface *iface, struct ncp *ncp, int family, int how)
{
  int af, inskip, in6skip, n, s4 = -1, s6 = -1, *s;

  if (iface->addrs) {
    inskip = in6skip = how == IFACE_CLEAR_ALL ? 0 : 1;

    for (n = 0; n < iface->addrs; n++) {
      af = ncprange_family(&iface->addr[n].ifa);
      if (family == 0 || family == af) {
        if (!iface->addr[n].system && (how & IFACE_SYSTEM))
          continue;
        switch (af) {
        case AF_INET:
          if (inskip) {
            inskip = 0;
            continue;
          }
          s = &s4;
          break;

#ifndef NOINET6
        case AF_INET6:
          if (in6skip) {
            in6skip = 0;
            continue;
          }
          s = &s6;
          break;
#endif
        default:
          continue;
        }

        if (*s == -1 && (*s = ID0socket(af, SOCK_DGRAM, 0)) == -1)
          log_Printf(LogERROR, "iface_Clear: socket(): %s\n", strerror(errno));
        else if (iface_addr_Zap(iface->name, iface->addr + n, *s)) {
          ncp_IfaceAddrDeleted(ncp, iface->addr + n);
          bcopy(iface->addr + n + 1, iface->addr + n,
                (iface->addrs - n - 1) * sizeof *iface->addr);
          iface->addrs--;
          n--;
        }
      }
    }

    /* Don't bother realloc()ing - we have little to gain */

    if (s4)
      close(s4);
    if (s6)
      close(s6);
  }
}

int
iface_Add(struct iface *iface, struct ncp *ncp, const struct ncprange *ifa,
          const struct ncpaddr *peer, int how)
{
  int af, n, removed, s;
  struct ncpaddr ncplocal;
  struct iface_addr *addr, newaddr;

  af = ncprange_family(ifa);
  if ((s = ID0socket(af, SOCK_DGRAM, 0)) == -1) {
    log_Printf(LogERROR, "iface_Add: socket(): %s\n", strerror(errno));
    return 0;
  }
  ncprange_getaddr(ifa, &ncplocal);

  for (n = 0; n < iface->addrs; n++) {
    if (ncprange_contains(&iface->addr[n].ifa, &ncplocal) ||
        ncpaddr_equal(&iface->addr[n].peer, peer)) {
      /* Replace this sockaddr */
      if (!(how & IFACE_FORCE_ADD)) {
        close(s);
        return 0;	/* errno = EEXIST; */
      }

      if (ncprange_equal(&iface->addr[n].ifa, ifa) &&
          ncpaddr_equal(&iface->addr[n].peer, peer)) {
        close(s);
        return 1;	/* Already there */
      }

      removed = iface_addr_Zap(iface->name, iface->addr + n, s);
      if (removed)
        ncp_IfaceAddrDeleted(ncp, iface->addr + n);
      ncprange_copy(&iface->addr[n].ifa, ifa);
      ncpaddr_copy(&iface->addr[n].peer, peer);
      if (!iface_addr_Add(iface->name, iface->addr + n, s)) {
        if (removed) {
          bcopy(iface->addr + n + 1, iface->addr + n,
                (iface->addrs - n - 1) * sizeof *iface->addr);
          iface->addrs--;
          n--;
        }
        close(s);
        return 0;
      }
      close(s);
      ncp_IfaceAddrAdded(ncp, iface->addr + n);
      return 1;
    }
  }

  addr = (struct iface_addr *)realloc
    (iface->addr, (iface->addrs + 1) * sizeof iface->addr[0]);
  if (addr == NULL) {
    log_Printf(LogERROR, "iface_inAdd: realloc: %s\n", strerror(errno));
    close(s);
    return 0;
  }
  iface->addr = addr;

  ncprange_copy(&newaddr.ifa, ifa);
  ncpaddr_copy(&newaddr.peer, peer);
  newaddr.system = !!(how & IFACE_SYSTEM);
  if (!iface_addr_Add(iface->name, &newaddr, s)) {
    close(s);
    return 0;
  }

  if (how & IFACE_ADD_FIRST) {
    /* Stuff it at the start of our list */
    n = 0;
    bcopy(iface->addr, iface->addr + 1, iface->addrs * sizeof *iface->addr);
  } else
    n = iface->addrs;

  iface->addrs++;
  memcpy(iface->addr + n, &newaddr, sizeof(*iface->addr));

  close(s);
  ncp_IfaceAddrAdded(ncp, iface->addr + n);

  return 1;
}

int
iface_Delete(struct iface *iface, struct ncp *ncp, const struct ncpaddr *del)
{
  struct ncpaddr found;
  int n, res, s;

  if ((s = ID0socket(ncpaddr_family(del), SOCK_DGRAM, 0)) == -1) {
    log_Printf(LogERROR, "iface_Delete: socket(): %s\n", strerror(errno));
    return 0;
  }

  for (n = res = 0; n < iface->addrs; n++) {
    ncprange_getaddr(&iface->addr[n].ifa, &found);
    if (ncpaddr_equal(&found, del)) {
      if (iface_addr_Zap(iface->name, iface->addr + n, s)) {
        ncp_IfaceAddrDeleted(ncp, iface->addr + n);
        bcopy(iface->addr + n + 1, iface->addr + n,
              (iface->addrs - n - 1) * sizeof *iface->addr);
        iface->addrs--;
        res = 1;
      }
      break;
    }
  }

  close(s);

  return res;
}

#define IFACE_ADDFLAGS 1
#define IFACE_DELFLAGS 2

static int
iface_ChangeFlags(const char *ifname, int flags, int how)
{
  struct ifreq ifrq;
  int s;

  s = ID0socket(PF_INET, SOCK_DGRAM, 0);
  if (s < 0) {
    log_Printf(LogERROR, "iface_ChangeFlags: socket: %s\n", strerror(errno));
    return 0;
  }

  memset(&ifrq, '\0', sizeof ifrq);
  strncpy(ifrq.ifr_name, ifname, sizeof ifrq.ifr_name - 1);
  ifrq.ifr_name[sizeof ifrq.ifr_name - 1] = '\0';
  if (ID0ioctl(s, SIOCGIFFLAGS, &ifrq) < 0) {
    log_Printf(LogERROR, "iface_ChangeFlags: ioctl(SIOCGIFFLAGS): %s\n",
       strerror(errno));
    close(s);
    return 0;
  }

  if (how == IFACE_ADDFLAGS)
    ifrq.ifr_flags |= flags;
  else
    ifrq.ifr_flags &= ~flags;

  if (ID0ioctl(s, SIOCSIFFLAGS, &ifrq) < 0) {
    log_Printf(LogERROR, "iface_ChangeFlags: ioctl(SIOCSIFFLAGS): %s\n",
       strerror(errno));
    close(s);
    return 0;
  }
  close(s);

  return 1;	/* Success */
}

int
iface_SetFlags(const char *ifname, int flags)
{
  return iface_ChangeFlags(ifname, flags, IFACE_ADDFLAGS);
}

int
iface_ClearFlags(const char *ifname, int flags)
{
  return iface_ChangeFlags(ifname, flags, IFACE_DELFLAGS);
}

void
iface_Destroy(struct iface *iface)
{
  /*
   * iface_Clear(iface, IFACE_CLEAR_ALL) must be called manually
   * if that's what the user wants.  It's better to leave the interface
   * allocated so that existing connections can continue to work.
   */

  if (iface != NULL) {
    free(iface->name);
    free(iface->addr);
    free(iface);
  }
}

#define if_entry(x) { IFF_##x, #x }

struct {
  int flag;
  const char *value;
} if_flags[] = {
  if_entry(UP),
  if_entry(BROADCAST),
  if_entry(DEBUG),
  if_entry(LOOPBACK),
  if_entry(POINTOPOINT),
  if_entry(RUNNING),
  if_entry(NOARP),
  if_entry(PROMISC),
  if_entry(ALLMULTI),
  if_entry(OACTIVE),
  if_entry(SIMPLEX),
  if_entry(LINK0),
  if_entry(LINK1),
  if_entry(LINK2),
  if_entry(MULTICAST),
  { 0, "???" }
};

int
iface_Show(struct cmdargs const *arg)
{
  struct ncpaddr ncpaddr;
  struct iface *iface = arg->bundle->iface, *current;
  int f, flags;
#ifndef NOINET6
  int scopeid, width;
#endif
  struct in_addr mask;

  current = iface_Create(iface->name);
  flags = iface->flags = current->flags;
  iface_Destroy(current);

  prompt_Printf(arg->prompt, "%s (idx %d) <", iface->name, iface->index);
  for (f = 0; f < sizeof if_flags / sizeof if_flags[0]; f++)
    if ((if_flags[f].flag & flags)) {
      prompt_Printf(arg->prompt, "%s%s", flags == iface->flags ? "" : ",",
                    if_flags[f].value);
      flags &= ~if_flags[f].flag;
    }

#if 0
  if (flags)
    prompt_Printf(arg->prompt, "%s0x%x", flags == iface->flags ? "" : ",",
                  flags);
#endif

  prompt_Printf(arg->prompt, "> mtu %d has %d address%s:\n", iface->mtu,
                iface->addrs, iface->addrs == 1 ? "" : "es");

  for (f = 0; f < iface->addrs; f++) {
    ncprange_getaddr(&iface->addr[f].ifa, &ncpaddr);
    switch (ncprange_family(&iface->addr[f].ifa)) {
    case AF_INET:
      prompt_Printf(arg->prompt, "  inet %s --> ", ncpaddr_ntoa(&ncpaddr));
      if (ncpaddr_family(&iface->addr[f].peer) == AF_UNSPEC)
        prompt_Printf(arg->prompt, "255.255.255.255");
      else
        prompt_Printf(arg->prompt, "%s", ncpaddr_ntoa(&iface->addr[f].peer));
      ncprange_getip4mask(&iface->addr[f].ifa, &mask);
      prompt_Printf(arg->prompt, " netmask 0x%08lx", (long)ntohl(mask.s_addr));
      break;

#ifndef NOINET6
    case AF_INET6:
      prompt_Printf(arg->prompt, "  inet6 %s", ncpaddr_ntoa(&ncpaddr));
      if (ncpaddr_family(&iface->addr[f].peer) != AF_UNSPEC)
        prompt_Printf(arg->prompt, " --> %s",
                      ncpaddr_ntoa(&iface->addr[f].peer));
      ncprange_getwidth(&iface->addr[f].ifa, &width);
      if (ncpaddr_family(&iface->addr[f].peer) == AF_UNSPEC)
        prompt_Printf(arg->prompt, " prefixlen %d", width);
      if ((scopeid = ncprange_scopeid(&iface->addr[f].ifa)) != -1)
        prompt_Printf(arg->prompt, " scopeid 0x%x", (unsigned)scopeid);
      break;
#endif
    }
    prompt_Printf(arg->prompt, "\n");
  }

  return 0;
}
@


1.31
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.30 2012/01/23 09:13:16 nicm Exp $
@


1.30
log
@Trim unused variables, from Michael W. Bombardieri.

ok yasuoka
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.29 2009/07/02 16:08:29 claudio Exp $
d42 1
@


1.29
log
@Rewrite the sysctl handlers to use libc functions (getifaddrs and
if_indextoname) instead of looking at the sysctl data directly. This makes
the code a lot simpler and actually work. Tested by many (todd@@, sthen@@, and
a few people on tech@@). OK sthen@@, deraadt@@
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.28 2009/06/25 15:59:28 claudio Exp $
a93 2
  size_t namelen;
  struct sockaddr_dl *dl;
a103 1
  namelen = strlen(name);
a108 1
      dl = (struct sockaddr_dl *)ifa->ifa_addr;
d326 1
a326 1
  int addrs, af, inskip, in6skip, n, s4 = -1, s6 = -1, *s;
a329 1
    addrs = 0;
@


1.28
log
@At least try to check for the RTM_VERSION here even so part of this code
escaped from a horror story and robs you're sanity. This needs major cleanup.
OK sthen@@, OK henning@@
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.27 2005/07/17 19:13:24 brad Exp $
d47 1
d94 1
a94 5
  int mib[6], maxtries, err;
  size_t needed, namelen;
  char *buf, *ptr, *end;
  struct if_msghdr *ifm;
  struct ifa_msghdr *ifam;
d96 1
a96 1
  struct sockaddr *sa[RTAX_MAX];
d100 4
a103 32
  mib[0] = CTL_NET;
  mib[1] = PF_ROUTE;
  mib[2] = 0;
  mib[3] = 0;
  mib[4] = NET_RT_IFLIST;
  mib[5] = 0;

  maxtries = 20;
  err = 0;
  do {
    if (maxtries-- == 0 || (err && err != ENOMEM)) {
      fprintf(stderr, "iface_Create: sysctl: %s\n", strerror(err));
      return NULL;
    }

    if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
      fprintf(stderr, "iface_Create: sysctl: estimate: %s\n",
                strerror(errno));
      return NULL;
    }

    if ((buf = (char *)malloc(needed)) == NULL) {
      fprintf(stderr, "iface_Create: malloc failed: %s\n", strerror(errno));
      return NULL;
    }

    if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
      err = errno;
      free(buf);
      buf = NULL;
    }
  } while (buf == NULL);
a104 2
  ptr = buf;
  end = buf + needed;
d108 2
a109 3
  while (ptr < end && iface == NULL) {
    ifm = (struct if_msghdr *)ptr;			/* On if_msghdr */
    if (ifm->ifm_version != RTM_VERSION)
d111 2
a112 4
    if (ifm->ifm_type != RTM_IFINFO)
      break;
    dl = (struct sockaddr_dl *)(ifm + 1);		/* Single _dl at end */
    if (dl->sdl_nlen == namelen && !strncmp(name, dl->sdl_data, namelen)) {
d116 1
d120 2
a121 2
      iface->index = ifm->ifm_index;
      iface->flags = ifm->ifm_flags;
a125 3
    ptr += ifm->ifm_msglen;				/* First ifa_msghdr */
    for (; ptr < end; ptr += ifam->ifam_msglen) {
      ifam = (struct ifa_msghdr *)ptr;			/* Next if address */
d127 10
a136 1
      if (ifam->ifam_type != RTM_NEWADDR)		/* finished this if */
d138 4
a141 2
      if (ifm->ifm_version != RTM_VERSION)
        continue;
d143 5
a147 27
      if (iface != NULL && ifam->ifam_addrs & RTA_IFA) {
        /* Found a configured interface ! */
        iface_ParseHdr(ifam, sa);

        if (sa[RTAX_IFA] && (sa[RTAX_IFA]->sa_family == AF_INET
#ifndef NOINET6
                             || sa[RTAX_IFA]->sa_family == AF_INET6
#endif
                             )) {
          /* Record the address */

          addr = (struct iface_addr *)
            realloc(iface->addr, (iface->addrs + 1) * sizeof iface->addr[0]);
          if (addr == NULL)
            break;
          iface->addr = addr;

          addr += iface->addrs;
          iface->addrs++;

          ncprange_setsa(&addr->ifa, sa[RTAX_IFA], sa[RTAX_NETMASK]);
          if (sa[RTAX_BRD])
            ncpaddr_setsa(&addr->peer, sa[RTAX_BRD]);
          else
            ncpaddr_init(&addr->peer);
        }
      }
d151 1
a151 1
  free(buf);
a653 16
}

void
iface_ParseHdr(struct ifa_msghdr *ifam, struct sockaddr *sa[RTAX_MAX])
{
  char *wp;
  int rtax;

  wp = (char *)(ifam + 1);

  for (rtax = 0; rtax < RTAX_MAX; rtax++)
    if (ifam->ifam_addrs & (1 << rtax)) {
      sa[rtax] = (struct sockaddr *)wp;
      wp += ROUNDUP(sa[rtax]->sa_len);
    } else
      sa[rtax] = NULL;
@


1.27
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.26 2004/11/23 15:55:21 brad Exp $
d143 2
d167 2
@


1.26
log
@Set link-local address of tun interface with prefixlen = 64
instead of 128.

From FreeBSD

ok deraadt@@ todd@@
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.25 2002/06/15 08:02:00 brian Exp $
d48 1
@


1.25
log
@Tidy up end of line whitespace
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.24 2002/05/16 01:13:39 brian Exp $
d85 3
d338 2
a339 1
    else
d432 1
a432 1
  int af, n, removed, s, width;
a457 5
      width =
#ifndef NOINET6
        (af == AF_INET6) ? 128 :
#endif
      32;
@


1.24
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.23 2002/03/31 02:38:49 brian Exp $
d255 1
a255 1
    
d389 1
a389 1
          
@


1.23
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.22 2002/01/16 14:13:06 brian Exp $
a37 1
#include <arpa/inet.h>
a69 1
#include "ip.h"
@


1.22
log
@socket()s first argument should be a protocol family rather than an
address family.
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.21 2001/11/23 11:17:03 brian Exp $
d234 7
d284 1
a284 1
static void
d319 7
d364 2
d430 3
a432 3
  int af, n, s, width;
  struct ncpaddr ifaddr, ncplocal;
  struct iface_addr *addr;
d444 1
d461 12
a472 9
      iface_addr_Zap(iface->name, iface->addr + n, s);
      ncprange_setwidth(&iface->addr[n].ifa, width);
      ncprange_getaddr(&iface->addr[n].ifa, &ifaddr);
      if (ncpaddr_equal(&ifaddr, &ncplocal))
        ncpaddr_copy(&iface->addr[n].peer, peer);
      else
        ncpaddr_init(&iface->addr[n].peer);
      iface_addr_Add(iface->name, iface->addr + n, s);
      if (ncpaddr_equal(&ifaddr, &ncplocal)) {
d474 1
a474 2
        ncp_IfaceAddrAdded(ncp, iface->addr + n);
        return 1;
d476 3
d491 8
d507 1
a507 4
  ncprange_copy(&iface->addr[n].ifa, ifa);
  ncpaddr_copy(&iface->addr[n].peer, peer);
  iface->addr[n].system = !!(how & IFACE_SYSTEM);
  iface_addr_Add(iface->name, iface->addr + n, s);
d529 7
a535 6
      iface_addr_Zap(iface->name, iface->addr + n, s);
      ncp_IfaceAddrDeleted(ncp, iface->addr + n);
      bcopy(iface->addr + n + 1, iface->addr + n,
            (iface->addrs - n - 1) * sizeof *iface->addr);
      iface->addrs--;
      res = 1;
@


1.21
log
@cmott@@scientech.com -> cm@@linktel.net
Add the UPTIME variable
CCP protocol ``0xffffffff'' -> ``none''
Don't leak memory when expanding command arguments and not exec()ing
Make some functions static
Add the ``log'' command for manual logging
Fix some log text bogons
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.20 2001/08/21 11:06:04 brian Exp $
d526 1
a526 1
  s = ID0socket(AF_INET, SOCK_DGRAM, 0);
@


1.20
log
@Enable IFF_MULTICAST when first opening the tun device
Don't bring the interface up immediately
Don't complain about unrecognised interface flags in ``show iface''.
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.19 2001/08/21 04:09:19 brian Exp $
d346 1
a346 1
      log_Printf(LogWARN, "iface add: ioctl(SIOCDIFADDR%s, %s -> %s): %s\n",
@


1.19
log
@Treat an interface address as conflicting if it's destination address
matches any existing destination addresses on the interface.  This
unbreaks ``enable iface-alias''.
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.18 2001/08/19 23:22:17 brian Exp $
d627 1
a627 1
    if ((if_flags[f].flag & flags) || (!if_flags[f].flag && flags)) {
d632 7
@


1.18
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.17 2001/06/19 10:24:54 brian Exp $
d426 2
a427 1
    if (ncprange_contains(&iface->addr[n].ifa, &ncplocal)) {
@


1.17
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.16 2001/06/04 16:09:28 brian Exp $
d34 3
d40 1
d42 3
d70 2
d81 2
a87 17
static int
bitsinmask(struct in_addr mask)
{
  u_int32_t bitmask, maskaddr;
  int bits;

  bitmask = 0xffffffff;
  maskaddr = ntohl(mask.s_addr);
  for (bits = 32; bits >= 0; bits--) {
    if (maskaddr == bitmask)
      break;
    bitmask &= ~(1 << (32 - bits));
  }

  return bits;
}

d91 1
a91 1
  int mib[6], s, maxtries, err;
a100 6
  s = socket(AF_INET, SOCK_DGRAM, 0);
  if (s < 0) {
    fprintf(stderr, "iface_Create: socket(): %s\n", strerror(errno));
    return NULL;
  }

a112 1
      close(s);
a118 1
      close(s);
a123 1
      close(s);
d154 2
a155 2
      iface->in_addrs = 0;
      iface->in_addr = NULL;
d168 5
a172 1
        if (sa[RTAX_IFA] && sa[RTAX_IFA]->sa_family == AF_INET) {
d175 2
a176 2
          addr = (struct iface_addr *)realloc
            (iface->in_addr, (iface->in_addrs + 1) * sizeof iface->in_addr[0]);
d179 1
a179 4
          iface->in_addr = addr;

          addr += iface->in_addrs;
          iface->in_addrs++;
d181 2
a182 1
          addr->ifa = ((struct sockaddr_in *)sa[RTAX_IFA])->sin_addr;
d184 1
d186 1
a186 6
            addr->brd = ((struct sockaddr_in *)sa[RTAX_BRD])->sin_addr;
          else
            addr->brd.s_addr = INADDR_ANY;

          if (sa[RTAX_NETMASK])
            addr->mask = ((struct sockaddr_in *)sa[RTAX_NETMASK])->sin_addr;
d188 1
a188 3
            addr->mask.s_addr = INADDR_ANY;

          addr->bits = bitsinmask(addr->mask);
a194 1
  close(s);
d199 78
d278 1
a278 1
iface_addr_Zap(const char *name, struct iface_addr *addr)
d281 10
a290 2
  struct sockaddr_in *me, *peer;
  int s;
d292 2
a293 4
  s = ID0socket(AF_INET, SOCK_DGRAM, 0);
  if (s < 0)
    log_Printf(LogERROR, "iface_addr_Zap: socket(): %s\n", strerror(errno));
  else {
d296 53
a348 11
    me = (struct sockaddr_in *)&ifra.ifra_addr;
    peer = (struct sockaddr_in *)&ifra.ifra_broadaddr;
    me->sin_family = peer->sin_family = AF_INET;
    me->sin_len = peer->sin_len = sizeof(struct sockaddr_in);
    me->sin_addr = addr->ifa;
    peer->sin_addr = addr->brd;
    log_Printf(LogDEBUG, "Delete %s\n", inet_ntoa(addr->ifa));
    if (ID0ioctl(s, SIOCDIFADDR, &ifra) < 0)
      log_Printf(LogWARN, "iface_addr_Zap: ioctl(SIOCDIFADDR, %s): %s\n",
                 inet_ntoa(addr->ifa), strerror(errno));
    close(s);
d352 1
d354 1
a354 1
iface_inClear(struct iface *iface, int how)
d356 1
a356 1
  int n, addrs;
d358 42
a399 4
  if (iface->in_addrs) {
    addrs = n = how == IFACE_CLEAR_ALL ? 0 : 1;
    for (; n < iface->in_addrs; n++)
      iface_addr_Zap(iface->name, iface->in_addr + n);
a400 1
    iface->in_addrs = addrs;
d402 5
d411 2
a412 2
iface_inAdd(struct iface *iface, struct in_addr ifa, struct in_addr mask,
            struct in_addr brd, int how)
d414 2
a415 3
  int slot, s, chg, nochange;
  struct ifaliasreq ifra;
  struct sockaddr_in *me, *peer, *msk;
d418 3
a420 13
  for (slot = 0; slot < iface->in_addrs; slot++)
    if (iface->in_addr[slot].ifa.s_addr == ifa.s_addr) {
      if (how & IFACE_FORCE_ADD)
        break;
      else
        /* errno = EEXIST; */
        return 0;
    }

  addr = (struct iface_addr *)realloc
    (iface->in_addr, (iface->in_addrs + 1) * sizeof iface->in_addr[0]);
  if (addr == NULL) {
    log_Printf(LogERROR, "iface_inAdd: realloc: %s\n", strerror(errno));
d423 1
a423 1
  iface->in_addr = addr;
d425 5
a429 27
  /*
   * We've gotta be careful here.  If we try to add an address with the
   * same destination as an existing interface, nothing will work.
   * Instead, we tweak all previous address entries that match the
   * to-be-added destination to 255.255.255.255 (w/ a similar netmask).
   * There *may* be more than one - if the user has ``iface add''ed
   * stuff previously.
   */
  nochange = 0;
  s = -1;
  for (chg = 0; chg < iface->in_addrs; chg++) {
    if ((iface->in_addr[chg].brd.s_addr == brd.s_addr &&
         brd.s_addr != INADDR_BROADCAST) || chg == slot) {
      /*
       * If we've found an entry that exactly matches what we want to add,
       * don't remove it and then add it again.  If we do, it's possible
       * that the kernel will (correctly) ``tidy up'' any routes that use
       * the IP number as a destination.
       */
      if (chg == slot && iface->in_addr[chg].mask.s_addr == mask.s_addr) {
        if (brd.s_addr == iface->in_addr[slot].brd.s_addr)
          nochange = 1;
        /*
         * If only the destination address has changed, the SIOCAIFADDR
         * we do after the current loop will change it.
         */
        continue;
d431 5
a435 3
      if (s == -1 && (s = ID0socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        log_Printf(LogERROR, "iface_inAdd: socket(): %s\n", strerror(errno));
        return 0;
d438 17
a454 30
      memset(&ifra, '\0', sizeof ifra);
      strncpy(ifra.ifra_name, iface->name, sizeof ifra.ifra_name - 1);
      me = (struct sockaddr_in *)&ifra.ifra_addr;
      msk = (struct sockaddr_in *)&ifra.ifra_mask;
      peer = (struct sockaddr_in *)&ifra.ifra_broadaddr;
      me->sin_family = msk->sin_family = peer->sin_family = AF_INET;
      me->sin_len = msk->sin_len = peer->sin_len = sizeof(struct sockaddr_in);
      me->sin_addr = iface->in_addr[chg].ifa;
      msk->sin_addr = iface->in_addr[chg].mask;
      peer->sin_addr = iface->in_addr[chg].brd;
      log_Printf(LogDEBUG, "Delete %s\n", inet_ntoa(me->sin_addr));
      ID0ioctl(s, SIOCDIFADDR, &ifra);	/* Don't care if it fails... */
      if (chg != slot) {
        peer->sin_addr.s_addr = iface->in_addr[chg].brd.s_addr =
          msk->sin_addr.s_addr = iface->in_addr[chg].mask.s_addr =
            INADDR_BROADCAST;
        iface->in_addr[chg].bits = 32;
        log_Printf(LogDEBUG, "Add %s -> 255.255.255.255\n",
                   inet_ntoa(me->sin_addr));
        if (ID0ioctl(s, SIOCAIFADDR, &ifra) < 0 && errno != EEXIST) {
          /* Oops - that's bad(ish) news !  We've lost an alias ! */
          log_Printf(LogERROR, "iface_inAdd: ioctl(SIOCAIFADDR): %s: %s\n",
               inet_ntoa(me->sin_addr), strerror(errno));
          iface->in_addrs--;
          bcopy(iface->in_addr + chg + 1, iface->in_addr + chg,
                (iface->in_addrs - chg) * sizeof iface->in_addr[0]);
          if (slot > chg)
            slot--;
          chg--;
        }
d459 6
a464 33
  if (!nochange) {
    if (s == -1 && (s = ID0socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
      log_Printf(LogERROR, "iface_inAdd: socket(): %s\n", strerror(errno));
      return 0;
    }
    memset(&ifra, '\0', sizeof ifra);
    strncpy(ifra.ifra_name, iface->name, sizeof ifra.ifra_name - 1);
    me = (struct sockaddr_in *)&ifra.ifra_addr;
    msk = (struct sockaddr_in *)&ifra.ifra_mask;
    peer = (struct sockaddr_in *)&ifra.ifra_broadaddr;
    me->sin_family = msk->sin_family = peer->sin_family = AF_INET;
    me->sin_len = msk->sin_len = peer->sin_len = sizeof(struct sockaddr_in);
    me->sin_addr = ifa;
    msk->sin_addr = mask;
    peer->sin_addr = brd;

    if (log_IsKept(LogDEBUG)) {
      char buf[16];

      strncpy(buf, inet_ntoa(brd), sizeof buf-1);
      buf[sizeof buf - 1] = '\0';
      log_Printf(LogDEBUG, "Add %s -> %s\n", inet_ntoa(ifa), buf);
    }

    /* An EEXIST failure w/ brd == INADDR_BROADCAST is ok (and works!) */
    if (ID0ioctl(s, SIOCAIFADDR, &ifra) < 0 &&
        (brd.s_addr != INADDR_BROADCAST || errno != EEXIST)) {
      log_Printf(LogERROR, "iface_inAdd: ioctl(SIOCAIFADDR): %s: %s\n",
                 inet_ntoa(ifa), strerror(errno));
      ID0ioctl(s, SIOCDIFADDR, &ifra);	/* EEXIST ? */
      close(s);
      return 0;
    }
d466 1
d468 12
a479 2
  if (s != -1)
    close(s);
d481 2
a482 21
  if (slot == iface->in_addrs) {
    /* We're adding a new interface address */

    if (how & IFACE_ADD_FIRST) {
      /* Stuff it at the start of our list */
      slot = 0;
      bcopy(iface->in_addr, iface->in_addr + 1,
            iface->in_addrs * sizeof iface->in_addr[0]);
    }

    iface->in_addrs++;
  } else if (how & IFACE_ADD_FIRST) {
    /* Shift it up to the first slot */
    bcopy(iface->in_addr, iface->in_addr + 1, slot * sizeof iface->in_addr[0]);
    slot = 0;
  }

  iface->in_addr[slot].ifa = ifa;
  iface->in_addr[slot].mask = mask;
  iface->in_addr[slot].brd = brd;
  iface->in_addr[slot].bits = bitsinmask(iface->in_addr[slot].mask);
d488 1
a488 1
iface_inDelete(struct iface *iface, struct in_addr ip)
d490 2
a491 1
  int n;
d493 15
a507 7
  for (n = 0; n < iface->in_addrs; n++)
    if (iface->in_addr[n].ifa.s_addr == ip.s_addr) {
      iface_addr_Zap(iface->name, iface->in_addr + n);
      bcopy(iface->in_addr + n + 1, iface->in_addr + n,
            (iface->in_addrs - n - 1) * sizeof iface->in_addr[0]);
      iface->in_addrs--;
      return 1;
d509 1
d511 3
a513 1
  return 0;
d580 1
a580 1
    free(iface->in_addr);
d612 1
d615 4
d632 1
a632 1
                iface->in_addrs, iface->in_addrs == 1 ? "" : "es");
d634 27
a660 12
  for (f = 0; f < iface->in_addrs; f++) {
    prompt_Printf(arg->prompt, "  %s", inet_ntoa(iface->in_addr[f].ifa));
    if (iface->in_addr[f].bits >= 0)
      prompt_Printf(arg->prompt, "/%d", iface->in_addr[f].bits);
    if (iface->flags & IFF_POINTOPOINT)
      prompt_Printf(arg->prompt, " -> %s", inet_ntoa(iface->in_addr[f].brd));
    else if (iface->flags & IFF_BROADCAST)
      prompt_Printf(arg->prompt, " broadcast %s",
                    inet_ntoa(iface->in_addr[f].brd));
    if (iface->in_addr[f].bits < 0)
      prompt_Printf(arg->prompt, " (mask %s)",
                    inet_ntoa(iface->in_addr[f].mask));
@


1.16
log
@Show the correct dial timeout when a random pause is configured
Understand ipencap traffic properly
Optimise out SIOCIFADDR ioctls that aren't necessary
Handle peers that don't send an initial IFADDR option during IPCP negotiations
Fix markup for the /etc/ttys example
Always use 4 arguments in examples of ``set ifaddr''
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.15 2001/04/03 08:23:27 brian Exp $
d166 1
d168 1
a168 1
      iface->index = ifm->ifm_index;
d544 1
a544 1
  prompt_Printf(arg->prompt, "> mtu %d has %d address%s:\n", arg->bundle->mtu,
@


1.15
log
@Be a bit more persistent when the NET_RT_IFLIST sysctl returns ENOMEM
rather than dropping out immediately.
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.14 2001/03/28 09:52:56 brian Exp $
d306 6
a311 1
        nochange = 1;
@


1.14
log
@Bring the netgraph PPPoE interface UP if required (only applies to FreeBSD)
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.13 2001/03/25 01:38:13 brian Exp $
d97 1
a97 1
  int mib[6], s;
d120 28
a147 19
  if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
    fprintf(stderr, "iface_Create: sysctl: estimate: %s\n",
              strerror(errno));
    close(s);
    return NULL;
  }

  if ((buf = (char *)malloc(needed)) == NULL) {
    fprintf(stderr, "iface_Create: malloc failed: %s\n", strerror(errno));
    close(s);
    return NULL;
  }

  if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
    fprintf(stderr, "iface_Create: sysctl: %s\n", strerror(errno));
    free(buf);
    close(s);
    return NULL;
  }
@


1.13
log
@If we're adding an interface address that is already one of the interface's
aliases with the same netmask and destination, don't remove it and then
re-add exactly the same thing.
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.12 2000/12/14 13:24:02 brian Exp $
d423 1
a423 1
iface_ChangeFlags(struct iface *iface, int flags, int how)
d435 1
a435 1
  strncpy(ifrq.ifr_name, iface->name, sizeof ifrq.ifr_name - 1);
d461 1
a461 1
iface_SetFlags(struct iface *iface, int flags)
d463 1
a463 1
  return iface_ChangeFlags(iface, flags, IFACE_ADDFLAGS);
d467 1
a467 1
iface_ClearFlags(struct iface *iface, int flags)
d469 1
a469 1
  return iface_ChangeFlags(iface, flags, IFACE_DELFLAGS);
@


1.12
log
@Display MSCHAP as CHAP80 in ``show cpp''
Display the interface mtu in ``show iface''
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.11 2000/06/19 21:43:41 brian Exp $
d255 1
a255 1
  int slot, s, chg;
a276 6
  s = ID0socket(AF_INET, SOCK_DGRAM, 0);
  if (s < 0) {
    log_Printf(LogERROR, "iface_inAdd: socket(): %s\n", strerror(errno));
    return 0;
  }

d285 2
d290 15
d339 36
a374 25
  memset(&ifra, '\0', sizeof ifra);
  strncpy(ifra.ifra_name, iface->name, sizeof ifra.ifra_name - 1);
  me = (struct sockaddr_in *)&ifra.ifra_addr;
  msk = (struct sockaddr_in *)&ifra.ifra_mask;
  peer = (struct sockaddr_in *)&ifra.ifra_broadaddr;
  me->sin_family = msk->sin_family = peer->sin_family = AF_INET;
  me->sin_len = msk->sin_len = peer->sin_len = sizeof(struct sockaddr_in);
  me->sin_addr = ifa;
  msk->sin_addr = mask;
  peer->sin_addr = brd;

  if (log_IsKept(LogDEBUG)) {
    char buf[16];

    strncpy(buf, inet_ntoa(brd), sizeof buf-1);
    buf[sizeof buf - 1] = '\0';
    log_Printf(LogDEBUG, "Add %s -> %s\n", inet_ntoa(ifa), buf);
  }

  /* An EEXIST failure w/ brd == INADDR_BROADCAST is ok (and works!) */
  if (ID0ioctl(s, SIOCAIFADDR, &ifra) < 0 &&
      (brd.s_addr != INADDR_BROADCAST || errno != EEXIST)) {
    log_Printf(LogERROR, "iface_inAdd: ioctl(SIOCAIFADDR): %s: %s\n",
               inet_ntoa(ifa), strerror(errno));
    ID0ioctl(s, SIOCDIFADDR, &ifra);	/* EEXIST ? */
a375 3
    return 0;
  }
  close(s);
@


1.11
log
@Don't mis-match interface names in iface_Create()

Submitted by: Adrian Penisoara <ady@@freebsd.ady.ro>
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.10 2000/02/27 01:38:26 brian Exp $
d510 2
a511 2
  prompt_Printf(arg->prompt, "> has %d address%s:\n", iface->in_addrs,
                iface->in_addrs == 1 ? "" : "es");
@


1.10
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: iface.c,v 1.9 2000/02/27 00:21:07 brian Exp $
d98 1
a98 1
  size_t needed;
d143 1
d150 1
a150 1
    if (!strncmp(name, dl->sdl_data, dl->sdl_nlen)) {
@


1.9
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: iface.c,v 1.8 2000/01/07 03:47:12 brian Exp $
@


1.8
log
@Don't set ifaddr::in_addrs to 1 after an ``iface clear'' on an interface
with no addresses.
@
text
@d26 1
a26 1
 *	$Id: iface.c,v 1.7 2000/01/07 03:26:54 brian Exp $
d97 1
a97 1
  int mib[6], i, s;
d99 1
a99 1
  char *buf, *ptr, *end, *cp, *lim;
d103 1
a103 1
  struct rt_addrinfo rti;
d168 3
a170 2
      if (iface == NULL)				/* Keep wading */
        continue;
d172 2
a173 20
      /* Found an address ! */

      if (ifam->ifam_addrs & (1 << RTAX_IFA)) {
        /* *And* it's configured ! */
        rti.rti_addrs = ifam->ifam_addrs;
        lim = (char *)ifam + ifam->ifam_msglen;
        cp = (char *)(ifam + 1);
        memset(rti.rti_info, '\0', sizeof(rti.rti_info));
        for (i = 0; i < RTAX_MAX && cp < lim; i++) {
          if ((rti.rti_addrs & (1 << i)) == 0)
            continue;
          rti.rti_info[i] = (struct sockaddr *)cp;
#define ROUNDUP(x) \
          ((x) > 0 ? (1 + (((x) - 1) | (sizeof(long) - 1))) : sizeof(long))
          cp += ROUNDUP(rti.rti_info[i]->sa_len);
        }

        if (rti.rti_info[RTAX_IFA] &&
            rti.rti_info[RTAX_IFA]->sa_family == AF_INET) {
          /* Record the iface address rti */
d184 11
a194 8
          addr->ifa.s_addr = ((struct sockaddr_in *)rti.rti_info[RTAX_IFA])->
            sin_addr.s_addr;
          addr->brd.s_addr = rti.rti_info[RTAX_BRD] ?
            ((struct sockaddr_in *)rti.rti_info[RTAX_BRD])->sin_addr.s_addr :
            INADDR_ANY;
          addr->mask.s_addr = rti.rti_info[RTAX_NETMASK] ?
            ((struct sockaddr_in *)rti.rti_info[RTAX_NETMASK])->sin_addr.s_addr:
            INADDR_ANY;
d528 16
@


1.7
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: iface.c,v 1.6 1999/05/31 23:57:37 brian Exp $
d254 4
a257 3
  addrs = n = how == IFACE_CLEAR_ALL ? 0 : 1;
  for (; n < iface->in_addrs; n++)
    iface_addr_Zap(iface->name, iface->in_addr + n);
d259 3
a261 2
  iface->in_addrs = addrs;
  /* Don't bother realloc()ing - we have little to gain */
@


1.6
log
@Remember if MYADDR or HISADDR is used in a filter add tweak all
filters any time either value changes.
@
text
@d26 1
a26 1
 *	$Id: iface.c,v 1.5 1999/05/27 08:44:48 brian Exp $
d121 1
a121 1
    fprintf(stderr, "clean: sysctl: estimate: %s\n",
d128 1
d134 1
d422 1
a422 1
    log_Printf(LogERROR, "iface_ClearFlags: socket: %s\n", strerror(errno));
d430 1
a430 1
    log_Printf(LogERROR, "iface_ClearFlags: ioctl(SIOCGIFFLAGS): %s\n",
d442 1
a442 1
    log_Printf(LogERROR, "iface_ClearFlags: ioctl(SIOCSIFFLAGS): %s\n",
@


1.5
log
@Move the code for tweaking interface flags into one function.
@
text
@d26 1
a26 1
 *	$Id: iface.c,v 1.4 1999/05/08 11:06:35 brian Exp $
a61 1
#include "filter.h"
d64 1
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: iface.c,v 1.3 1999/04/26 08:54:50 brian Exp $
d407 53
@


1.3
log
@#include <errno.h>, not <sys/errno.h>
@
text
@d26 1
a26 1
 *	$Id: iface.c,v 1.2 1999/02/06 03:22:37 brian Exp $
d49 1
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: iface.c,v 1.3 1999/01/28 01:56:32 brian Exp $
d40 1
a40 3
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>
d44 2
@


1.1
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d26 1
a26 1
 *	$Id: iface.c,v 1.2 1998/10/26 19:07:36 brian Exp $
d29 1
a29 1
#include <sys/types.h>
d68 3
@

