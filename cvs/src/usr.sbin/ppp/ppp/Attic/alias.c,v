head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.38
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.34
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.32
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.30
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.28
	OPENBSD_5_0:1.20.0.26
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.24
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.22
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.18
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.20
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.16
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.14
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.12
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.10
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.8
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.6
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.12
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.10
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.8
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.6
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.20;

1.20
date	2005.07.26.01.32.24;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.15.08.01.59;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.23.11.17.03;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.13.10.32.54;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.21.04.09.15;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.07.09.32.55;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.25.12.33.04;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.02.00.53.47;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.06.00.26.43;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.02.22.12.26;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.13.22.05.47;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.23.09.47.04;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.11.14.40.26;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.27.01.38.24;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.07.03.26.52;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.11.23.29;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.24.20.42.15;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.03.08.01.40.22;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.08.16.27;	author brian;	state Exp;
branches;
next	;


desc
@@


1.21
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/* -*- mode: c; tab-width: 8; c-basic-indent: 4; -*- */

/*-
 * Copyright (c) 2001 Charles Mott <cm@@linktel.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: alias.c,v 1.20 2005/07/26 01:32:24 brad Exp $
 */

/*
    Alias.c provides supervisory control for the functions of the
    packet aliasing software.  It consists of routines to monitor
    TCP connection state, protocol-specific aliasing routines,
    fragment handling and the following outside world functional
    interfaces: SaveFragmentPtr, GetFragmentPtr, FragmentAliasIn,
    PacketAliasIn and PacketAliasOut.

    The other C program files are briefly described. The data
    structure framework which holds information needed to translate
    packets is encapsulated in alias_db.c.  Data is accessed by
    function calls, so other segments of the program need not know
    about the underlying data structures.  Alias_ftp.c contains
    special code for modifying the ftp PORT command used to establish
    data connections, while alias_irc.c does the same for IRC
    DCC. Alias_util.c contains a few utility routines.

    Version 1.0 August, 1996  (cjm)

    Version 1.1 August 20, 1996  (cjm)
        PPP host accepts incoming connections for ports 0 to 1023.
        (Gary Roberts pointed out the need to handle incoming
         connections.)

    Version 1.2 September 7, 1996 (cjm)
        Fragment handling error in alias_db.c corrected.
        (Tom Torrance helped fix this problem.)

    Version 1.4 September 16, 1996 (cjm)
        - A more generalized method for handling incoming
          connections, without the 0-1023 restriction, is
          implemented in alias_db.c
        - Improved ICMP support in alias.c.  Traceroute
          packet streams can now be correctly aliased.
        - TCP connection closing logic simplified in
          alias.c and now allows for additional 1 minute
          "grace period" after FIN or RST is observed.

    Version 1.5 September 17, 1996 (cjm)
        Corrected error in handling incoming UDP packets with 0 checksum.
        (Tom Torrance helped fix this problem.)

    Version 1.6 September 18, 1996 (cjm)
        Simplified ICMP aliasing scheme.  Should now support
        traceroute from Win95 as well as FreeBSD.

    Version 1.7 January 9, 1997 (cjm)
        - Out-of-order fragment handling.
        - IP checksum error fixed for ftp transfers
          from aliasing host.
        - Integer return codes added to all
          aliasing/de-aliasing functions.
        - Some obsolete comments cleaned up.
        - Differential checksum computations for
          IP header (TCP, UDP and ICMP were already
          differential).

    Version 2.1 May 1997 (cjm)
        - Added support for outgoing ICMP error
          messages.
        - Added two functions PacketAliasIn2()
          and PacketAliasOut2() for dynamic address
          control (e.g. round-robin allocation of
          incoming packets).

    Version 2.2 July 1997 (cjm)
        - Rationalized API function names to begin
          with "PacketAlias..."
        - Eliminated PacketAliasIn2() and
          PacketAliasOut2() as poorly conceived.

    Version 2.3 Dec 1998 (dillon)
	- Major bounds checking additions, see FreeBSD/CVS

    Version 3.1 May, 2000 (salander)
	- Added hooks to handle PPTP.

    Version 3.2 July, 2000 (salander and satoh)
	- Added PacketUnaliasOut routine.
	- Added hooks to handle RTSP/RTP.

    See HISTORY file for additional revisions.
*/

#include <sys/types.h>

#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#include <stdio.h>

#include "alias_local.h"
#include "alias.h"

#define NETBIOS_NS_PORT_NUMBER 137
#define NETBIOS_DGM_PORT_NUMBER 138
#define FTP_CONTROL_PORT_NUMBER 21
#define IRC_CONTROL_PORT_NUMBER_1 6667
#define IRC_CONTROL_PORT_NUMBER_2 6668
#define CUSEEME_PORT_NUMBER 7648
#define RTSP_CONTROL_PORT_NUMBER_1 554
#define RTSP_CONTROL_PORT_NUMBER_2 7070
#define TFTP_PORT_NUMBER 69
#define PPTP_CONTROL_PORT_NUMBER 1723
#define SKINNY_PORT_NUMBER 2000




/* TCP Handling Routines

    TcpMonitorIn()  -- These routines monitor TCP connections, and
    TcpMonitorOut()    delete a link when a connection is closed.

These routines look for SYN, FIN and RST flags to determine when TCP
connections open and close.  When a TCP connection closes, the data
structure containing packet aliasing information is deleted after
a timeout period.
*/

/* Local prototypes */
static void TcpMonitorIn(struct ip *, struct alias_link *);

static void TcpMonitorOut(struct ip *, struct alias_link *);


static void
TcpMonitorIn(struct ip *pip, struct alias_link *link)
{
    struct tcphdr *tc;

    tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));

    switch (GetStateIn(link))
    {
        case ALIAS_TCP_STATE_NOT_CONNECTED:
            if (tc->th_flags & TH_RST)
                SetStateIn(link, ALIAS_TCP_STATE_DISCONNECTED);
            else if (tc->th_flags & TH_SYN)
                SetStateIn(link, ALIAS_TCP_STATE_CONNECTED);
            break;
        case ALIAS_TCP_STATE_CONNECTED:
            if (tc->th_flags & (TH_FIN | TH_RST))
                SetStateIn(link, ALIAS_TCP_STATE_DISCONNECTED);
            break;
    }
}

static void
TcpMonitorOut(struct ip *pip, struct alias_link *link)
{
    struct tcphdr *tc;

    tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));

    switch (GetStateOut(link))
    {
        case ALIAS_TCP_STATE_NOT_CONNECTED:
            if (tc->th_flags & TH_RST)
                SetStateOut(link, ALIAS_TCP_STATE_DISCONNECTED);
            else if (tc->th_flags & TH_SYN)
                SetStateOut(link, ALIAS_TCP_STATE_CONNECTED);
            break;
        case ALIAS_TCP_STATE_CONNECTED:
            if (tc->th_flags & (TH_FIN | TH_RST))
                SetStateOut(link, ALIAS_TCP_STATE_DISCONNECTED);
            break;
    }
}





/* Protocol Specific Packet Aliasing Routines

    IcmpAliasIn(), IcmpAliasIn1(), IcmpAliasIn2()
    IcmpAliasOut(), IcmpAliasOut1(), IcmpAliasOut2()
    ProtoAliasIn(), ProtoAliasOut()
    UdpAliasIn(), UdpAliasOut()
    TcpAliasIn(), TcpAliasOut()

These routines handle protocol specific details of packet aliasing.
One may observe a certain amount of repetitive arithmetic in these
functions, the purpose of which is to compute a revised checksum
without actually summing over the entire data packet, which could be
unnecessarily time consuming.

The purpose of the packet aliasing routines is to replace the source
address of the outgoing packet and then correctly put it back for
any incoming packets.  For TCP and UDP, ports are also re-mapped.

For ICMP echo/timestamp requests and replies, the following scheme
is used: the ID number is replaced by an alias for the outgoing
packet.

ICMP error messages are handled by looking at the IP fragment
in the data section of the message.

For TCP and UDP protocols, a port number is chosen for an outgoing
packet, and then incoming packets are identified by IP address and
port numbers.  For TCP packets, there is additional logic in the event
that sequence and ACK numbers have been altered (as in the case for
FTP data port commands).

The port numbers used by the packet aliasing module are not true
ports in the Unix sense.  No sockets are actually bound to ports.
They are more correctly thought of as placeholders.

All packets go through the aliasing mechanism, whether they come from
the gateway machine or other machines on a local area network.
*/


/* Local prototypes */
static int IcmpAliasIn1(struct ip *);
static int IcmpAliasIn2(struct ip *);
static int IcmpAliasIn (struct ip *);

static int IcmpAliasOut1(struct ip *);
static int IcmpAliasOut2(struct ip *);
static int IcmpAliasOut (struct ip *);

static int ProtoAliasIn(struct ip *);
static int ProtoAliasOut(struct ip *);

static int UdpAliasOut(struct ip *);
static int UdpAliasIn (struct ip *);

static int TcpAliasOut(struct ip *, int);
static int TcpAliasIn (struct ip *);


static int
IcmpAliasIn1(struct ip *pip)
{
/*
    De-alias incoming echo and timestamp replies.
    Alias incoming echo and timestamp requests.
*/
    struct alias_link *link;
    struct icmp *ic;

    ic = (struct icmp *) ((char *) pip + (pip->ip_hl << 2));

/* Get source address from ICMP data field and restore original data */
    link = FindIcmpIn(pip->ip_src, pip->ip_dst, ic->icmp_id, 1);
    if (link != NULL)
    {
        u_short original_id;
        int accumulate;

        original_id = GetOriginalPort(link);

/* Adjust ICMP checksum */
        accumulate  = ic->icmp_id;
        accumulate -= original_id;
        ADJUST_CHECKSUM(accumulate, ic->icmp_cksum);

/* Put original sequence number back in */
        ic->icmp_id = original_id;

/* Put original address back into IP header */
        {
            struct in_addr original_address;

            original_address = GetOriginalAddress(link);
            DifferentialChecksum(&pip->ip_sum,
                                 (u_short *) &original_address,
                                 (u_short *) &pip->ip_dst,
                                 2);
            pip->ip_dst = original_address;
        }

        return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_IGNORED);
}

static int
IcmpAliasIn2(struct ip *pip)
{
/*
    Alias incoming ICMP error messages containing
    IP header and first 64 bits of datagram.
*/
    struct ip *ip;
    struct icmp *ic, *ic2;
    struct udphdr *ud;
    struct tcphdr *tc;
    struct alias_link *link;

    ic = (struct icmp *) ((char *) pip + (pip->ip_hl << 2));
    ip = &ic->icmp_ip;

    ud = (struct udphdr *) ((char *) ip + (ip->ip_hl <<2));
    tc = (struct tcphdr *) ud;
    ic2 = (struct icmp *) ud;

    if (ip->ip_p == IPPROTO_UDP)
        link = FindUdpTcpIn(ip->ip_dst, ip->ip_src,
                            ud->uh_dport, ud->uh_sport,
                            IPPROTO_UDP, 0);
    else if (ip->ip_p == IPPROTO_TCP)
        link = FindUdpTcpIn(ip->ip_dst, ip->ip_src,
                            tc->th_dport, tc->th_sport,
                            IPPROTO_TCP, 0);
    else if (ip->ip_p == IPPROTO_ICMP) {
        if (ic2->icmp_type == ICMP_ECHO || ic2->icmp_type == ICMP_TSTAMP)
            link = FindIcmpIn(ip->ip_dst, ip->ip_src, ic2->icmp_id, 0);
        else
            link = NULL;
    } else
        link = NULL;

    if (link != NULL)
    {
        if (ip->ip_p == IPPROTO_UDP || ip->ip_p == IPPROTO_TCP)
        {
            u_short *sptr;
            int accumulate;
            struct in_addr original_address;
            u_short original_port;

            original_address = GetOriginalAddress(link);
            original_port = GetOriginalPort(link);

/* Adjust ICMP checksum */
            sptr = (u_short *) &(ip->ip_src);
            accumulate  = *sptr++;
            accumulate += *sptr;
            sptr = (u_short *) &original_address;
            accumulate -= *sptr++;
            accumulate -= *sptr;
            accumulate += ud->uh_sport;
            accumulate -= original_port;
            ADJUST_CHECKSUM(accumulate, ic->icmp_cksum);

/* Un-alias address in IP header */
            DifferentialChecksum(&pip->ip_sum,
                                 (u_short *) &original_address,
                                 (u_short *) &pip->ip_dst,
                                 2);
            pip->ip_dst = original_address;

/* Un-alias address and port number of original IP packet
fragment contained in ICMP data section */
            ip->ip_src = original_address;
            ud->uh_sport = original_port;
        }
        else if (ip->ip_p == IPPROTO_ICMP)
        {
            u_short *sptr;
            int accumulate;
            struct in_addr original_address;
            u_short original_id;

            original_address = GetOriginalAddress(link);
            original_id = GetOriginalPort(link);

/* Adjust ICMP checksum */
            sptr = (u_short *) &(ip->ip_src);
            accumulate  = *sptr++;
            accumulate += *sptr;
            sptr = (u_short *) &original_address;
            accumulate -= *sptr++;
            accumulate -= *sptr;
            accumulate += ic2->icmp_id;
            accumulate -= original_id;
            ADJUST_CHECKSUM(accumulate, ic->icmp_cksum);

/* Un-alias address in IP header */
            DifferentialChecksum(&pip->ip_sum,
                                 (u_short *) &original_address,
                                 (u_short *) &pip->ip_dst,
                                 2);
            pip->ip_dst = original_address;

/* Un-alias address of original IP packet and sequence number of
   embedded ICMP datagram */
            ip->ip_src = original_address;
            ic2->icmp_id = original_id;
        }
        return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_IGNORED);
}


static int
IcmpAliasIn(struct ip *pip)
{
    int iresult;
    struct icmp *ic;

/* Return if proxy-only mode is enabled */
    if (packetAliasMode & PKT_ALIAS_PROXY_ONLY)
        return PKT_ALIAS_OK;

    ic = (struct icmp *) ((char *) pip + (pip->ip_hl << 2));

    iresult = PKT_ALIAS_IGNORED;
    switch (ic->icmp_type)
    {
        case ICMP_ECHOREPLY:
        case ICMP_TSTAMPREPLY:
            if (ic->icmp_code == 0)
            {
                iresult = IcmpAliasIn1(pip);
            }
            break;
        case ICMP_UNREACH:
        case ICMP_SOURCEQUENCH:
        case ICMP_TIMXCEED:
        case ICMP_PARAMPROB:
            iresult = IcmpAliasIn2(pip);
            break;
        case ICMP_ECHO:
        case ICMP_TSTAMP:
            iresult = IcmpAliasIn1(pip);
            break;
    }
    return(iresult);
}


static int
IcmpAliasOut1(struct ip *pip)
{
/*
    Alias outgoing echo and timestamp requests.
    De-alias outgoing echo and timestamp replies.
*/
    struct alias_link *link;
    struct icmp *ic;

    ic = (struct icmp *) ((char *) pip + (pip->ip_hl << 2));

/* Save overwritten data for when echo packet returns */
    link = FindIcmpOut(pip->ip_src, pip->ip_dst, ic->icmp_id, 1);
    if (link != NULL)
    {
        u_short alias_id;
        int accumulate;

        alias_id = GetAliasPort(link);

/* Since data field is being modified, adjust ICMP checksum */
        accumulate  = ic->icmp_id;
        accumulate -= alias_id;
        ADJUST_CHECKSUM(accumulate, ic->icmp_cksum);

/* Alias sequence number */
        ic->icmp_id = alias_id;

/* Change source address */
        {
            struct in_addr alias_address;

            alias_address = GetAliasAddress(link);
            DifferentialChecksum(&pip->ip_sum,
                                 (u_short *) &alias_address,
                                 (u_short *) &pip->ip_src,
                                 2);
            pip->ip_src = alias_address;
        }

        return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_IGNORED);
}


static int
IcmpAliasOut2(struct ip *pip)
{
/*
    Alias outgoing ICMP error messages containing
    IP header and first 64 bits of datagram.
*/
    struct ip *ip;
    struct icmp *ic, *ic2;
    struct udphdr *ud;
    struct tcphdr *tc;
    struct alias_link *link;

    ic = (struct icmp *) ((char *) pip + (pip->ip_hl << 2));
    ip = &ic->icmp_ip;

    ud = (struct udphdr *) ((char *) ip + (ip->ip_hl <<2));
    tc = (struct tcphdr *) ud;
    ic2 = (struct icmp *) ud;

    if (ip->ip_p == IPPROTO_UDP)
        link = FindUdpTcpOut(ip->ip_dst, ip->ip_src,
                            ud->uh_dport, ud->uh_sport,
                            IPPROTO_UDP, 0);
    else if (ip->ip_p == IPPROTO_TCP)
        link = FindUdpTcpOut(ip->ip_dst, ip->ip_src,
                            tc->th_dport, tc->th_sport,
                            IPPROTO_TCP, 0);
    else if (ip->ip_p == IPPROTO_ICMP) {
        if (ic2->icmp_type == ICMP_ECHO || ic2->icmp_type == ICMP_TSTAMP)
            link = FindIcmpOut(ip->ip_dst, ip->ip_src, ic2->icmp_id, 0);
        else
            link = NULL;
    } else
        link = NULL;

    if (link != NULL)
    {
        if (ip->ip_p == IPPROTO_UDP || ip->ip_p == IPPROTO_TCP)
        {
            u_short *sptr;
            int accumulate;
            struct in_addr alias_address;
            u_short alias_port;

            alias_address = GetAliasAddress(link);
            alias_port = GetAliasPort(link);

/* Adjust ICMP checksum */
            sptr = (u_short *) &(ip->ip_dst);
            accumulate  = *sptr++;
            accumulate += *sptr;
            sptr = (u_short *) &alias_address;
            accumulate -= *sptr++;
            accumulate -= *sptr;
            accumulate += ud->uh_dport;
            accumulate -= alias_port;
            ADJUST_CHECKSUM(accumulate, ic->icmp_cksum);

/*
 * Alias address in IP header if it comes from the host
 * the original TCP/UDP packet was destined for.
 */
	    if (pip->ip_src.s_addr == ip->ip_dst.s_addr) {
		DifferentialChecksum(&pip->ip_sum,
				     (u_short *) &alias_address,
				     (u_short *) &pip->ip_src,
				     2);
		pip->ip_src = alias_address;
	    }

/* Alias address and port number of original IP packet
fragment contained in ICMP data section */
            ip->ip_dst = alias_address;
            ud->uh_dport = alias_port;
        }
        else if (ip->ip_p == IPPROTO_ICMP)
        {
            u_short *sptr;
            int accumulate;
            struct in_addr alias_address;
            u_short alias_id;

            alias_address = GetAliasAddress(link);
            alias_id = GetAliasPort(link);

/* Adjust ICMP checksum */
            sptr = (u_short *) &(ip->ip_dst);
            accumulate  = *sptr++;
            accumulate += *sptr;
            sptr = (u_short *) &alias_address;
            accumulate -= *sptr++;
            accumulate -= *sptr;
            accumulate += ic2->icmp_id;
            accumulate -= alias_id;
            ADJUST_CHECKSUM(accumulate, ic->icmp_cksum);

/*
 * Alias address in IP header if it comes from the host
 * the original ICMP message was destined for.
 */
	    if (pip->ip_src.s_addr == ip->ip_dst.s_addr) {
		DifferentialChecksum(&pip->ip_sum,
				     (u_short *) &alias_address,
				     (u_short *) &pip->ip_src,
				     2);
		pip->ip_src = alias_address;
	    }

/* Alias address of original IP packet and sequence number of
   embedded ICMP datagram */
            ip->ip_dst = alias_address;
            ic2->icmp_id = alias_id;
        }
        return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_IGNORED);
}


static int
IcmpAliasOut(struct ip *pip)
{
    int iresult;
    struct icmp *ic;

/* Return if proxy-only mode is enabled */
    if (packetAliasMode & PKT_ALIAS_PROXY_ONLY)
        return PKT_ALIAS_OK;

    ic = (struct icmp *) ((char *) pip + (pip->ip_hl << 2));

    iresult = PKT_ALIAS_IGNORED;
    switch (ic->icmp_type)
    {
        case ICMP_ECHO:
        case ICMP_TSTAMP:
            if (ic->icmp_code == 0)
            {
                iresult = IcmpAliasOut1(pip);
            }
            break;
        case ICMP_UNREACH:
        case ICMP_SOURCEQUENCH:
        case ICMP_TIMXCEED:
        case ICMP_PARAMPROB:
            iresult = IcmpAliasOut2(pip);
            break;
        case ICMP_ECHOREPLY:
        case ICMP_TSTAMPREPLY:
            iresult = IcmpAliasOut1(pip);
    }
    return(iresult);
}



static int
ProtoAliasIn(struct ip *pip)
{
/*
  Handle incoming IP packets. The
  only thing which is done in this case is to alias
  the dest IP address of the packet to our inside
  machine.
*/
    struct alias_link *link;

/* Return if proxy-only mode is enabled */
    if (packetAliasMode & PKT_ALIAS_PROXY_ONLY)
        return PKT_ALIAS_OK;

    link = FindProtoIn(pip->ip_src, pip->ip_dst, pip->ip_p);
    if (link != NULL)
    {
        struct in_addr original_address;

        original_address = GetOriginalAddress(link);

/* Restore original IP address */
        DifferentialChecksum(&pip->ip_sum,
                             (u_short *) &original_address,
                             (u_short *) &pip->ip_dst,
                             2);
        pip->ip_dst = original_address;

	return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_IGNORED);
}


static int
ProtoAliasOut(struct ip *pip)
{
/*
  Handle outgoing IP packets. The
  only thing which is done in this case is to alias
  the source IP address of the packet.
*/
    struct alias_link *link;

/* Return if proxy-only mode is enabled */
    if (packetAliasMode & PKT_ALIAS_PROXY_ONLY)
        return PKT_ALIAS_OK;

    link = FindProtoOut(pip->ip_src, pip->ip_dst, pip->ip_p);
    if (link != NULL)
    {
        struct in_addr alias_address;

        alias_address = GetAliasAddress(link);

/* Change source address */
        DifferentialChecksum(&pip->ip_sum,
                             (u_short *) &alias_address,
                             (u_short *) &pip->ip_src,
                             2);
        pip->ip_src = alias_address;

        return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_IGNORED);
}


static int
UdpAliasIn(struct ip *pip)
{
    struct udphdr *ud;
    struct alias_link *link;

/* Return if proxy-only mode is enabled */
    if (packetAliasMode & PKT_ALIAS_PROXY_ONLY)
        return PKT_ALIAS_OK;

    ud = (struct udphdr *) ((char *) pip + (pip->ip_hl << 2));

    link = FindUdpTcpIn(pip->ip_src, pip->ip_dst,
                        ud->uh_sport, ud->uh_dport,
                        IPPROTO_UDP, 1);
    if (link != NULL)
    {
        struct in_addr alias_address;
        struct in_addr original_address;
        u_short alias_port;
        int accumulate;
        u_short *sptr;
	int r = 0;

        alias_address = GetAliasAddress(link);
        original_address = GetOriginalAddress(link);
        alias_port = ud->uh_dport;
        ud->uh_dport = GetOriginalPort(link);

/* Special processing for IP encoding protocols */
	if (ntohs(ud->uh_dport) == CUSEEME_PORT_NUMBER)
	    AliasHandleCUSeeMeIn(pip, original_address);
/* If NETBIOS Datagram, It should be alias address in UDP Data, too */
	else if (ntohs(ud->uh_dport) == NETBIOS_DGM_PORT_NUMBER
	      || ntohs(ud->uh_sport) == NETBIOS_DGM_PORT_NUMBER)
	    r = AliasHandleUdpNbt(pip, link, &original_address, ud->uh_dport);
	else if (ntohs(ud->uh_dport) == NETBIOS_NS_PORT_NUMBER
	      || ntohs(ud->uh_sport) == NETBIOS_NS_PORT_NUMBER)
	    r = AliasHandleUdpNbtNS(pip, link, &alias_address, &alias_port,
				    &original_address, &ud->uh_dport);

/* If UDP checksum is not zero, then adjust since destination port */
/* is being unaliased and destination address is being altered.    */
        if (ud->uh_sum != 0)
        {
            accumulate  = alias_port;
            accumulate -= ud->uh_dport;
            sptr = (u_short *) &alias_address;
            accumulate += *sptr++;
            accumulate += *sptr;
            sptr = (u_short *) &original_address;
            accumulate -= *sptr++;
            accumulate -= *sptr;
            ADJUST_CHECKSUM(accumulate, ud->uh_sum);
        }

/* Restore original IP address */
        DifferentialChecksum(&pip->ip_sum,
                             (u_short *) &original_address,
                             (u_short *) &pip->ip_dst,
                             2);
        pip->ip_dst = original_address;

	/*
	 * If we cannot figure out the packet, ignore it.
	 */
	if (r < 0)
	    return(PKT_ALIAS_IGNORED);
	else
	    return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_IGNORED);
}

static int
UdpAliasOut(struct ip *pip)
{
    struct udphdr *ud;
    struct alias_link *link;

/* Return if proxy-only mode is enabled */
    if (packetAliasMode & PKT_ALIAS_PROXY_ONLY)
        return PKT_ALIAS_OK;

    ud = (struct udphdr *) ((char *) pip + (pip->ip_hl << 2));

    link = FindUdpTcpOut(pip->ip_src, pip->ip_dst,
                         ud->uh_sport, ud->uh_dport,
                         IPPROTO_UDP, 1);
    if (link != NULL)
    {
        u_short alias_port;
        struct in_addr alias_address;

        alias_address = GetAliasAddress(link);
        alias_port = GetAliasPort(link);

/* Special processing for IP encoding protocols */
	if (ntohs(ud->uh_dport) == CUSEEME_PORT_NUMBER)
	    AliasHandleCUSeeMeOut(pip, link);
/* If NETBIOS Datagram, It should be alias address in UDP Data, too */
	else if (ntohs(ud->uh_dport) == NETBIOS_DGM_PORT_NUMBER
	      || ntohs(ud->uh_sport) == NETBIOS_DGM_PORT_NUMBER)
	    AliasHandleUdpNbt(pip, link, &alias_address, alias_port);
	else if (ntohs(ud->uh_dport) == NETBIOS_NS_PORT_NUMBER
	      || ntohs(ud->uh_sport) == NETBIOS_NS_PORT_NUMBER)
	    AliasHandleUdpNbtNS(pip, link, &pip->ip_src, &ud->uh_sport,
				&alias_address, &alias_port);
/*
 * We don't know in advance what TID the TFTP server will choose,
 * so we create a wilcard link (destination port is unspecified)
 * that will match any TID from a given destination.
 */
	else if (ntohs(ud->uh_dport) == TFTP_PORT_NUMBER)
	    FindRtspOut(pip->ip_src, pip->ip_dst,
			ud->uh_sport, alias_port, IPPROTO_UDP);

/* If UDP checksum is not zero, adjust since source port is */
/* being aliased and source address is being altered        */
        if (ud->uh_sum != 0)
        {
            int accumulate;
            u_short *sptr;

            accumulate  = ud->uh_sport;
            accumulate -= alias_port;
            sptr = (u_short *) &(pip->ip_src);
            accumulate += *sptr++;
            accumulate += *sptr;
            sptr = (u_short *) &alias_address;
            accumulate -= *sptr++;
            accumulate -= *sptr;
            ADJUST_CHECKSUM(accumulate, ud->uh_sum);
        }

/* Put alias port in UDP header */
        ud->uh_sport = alias_port;

/* Change source address */
        DifferentialChecksum(&pip->ip_sum,
                             (u_short *) &alias_address,
                             (u_short *) &pip->ip_src,
                             2);
        pip->ip_src = alias_address;

        return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_IGNORED);
}



static int
TcpAliasIn(struct ip *pip)
{
    struct tcphdr *tc;
    struct alias_link *link;

    tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));

    link = FindUdpTcpIn(pip->ip_src, pip->ip_dst,
                        tc->th_sport, tc->th_dport,
                        IPPROTO_TCP,
                        !(packetAliasMode & PKT_ALIAS_PROXY_ONLY));
    if (link != NULL)
    {
        struct in_addr alias_address;
        struct in_addr original_address;
        struct in_addr proxy_address;
        u_short alias_port;
        u_short proxy_port;
        int accumulate;
        u_short *sptr;

/* Special processing for IP encoding protocols */
        if (ntohs(tc->th_dport) == PPTP_CONTROL_PORT_NUMBER
         || ntohs(tc->th_sport) == PPTP_CONTROL_PORT_NUMBER)
            AliasHandlePptpIn(pip, link);
        else if (skinnyPort != 0 && (ntohs(tc->th_dport) == skinnyPort
         || ntohs(tc->th_sport) == skinnyPort))
            AliasHandleSkinny(pip, link);

        alias_address = GetAliasAddress(link);
        original_address = GetOriginalAddress(link);
        proxy_address = GetProxyAddress(link);
        alias_port = tc->th_dport;
        tc->th_dport = GetOriginalPort(link);
        proxy_port = GetProxyPort(link);

/* Adjust TCP checksum since destination port is being unaliased */
/* and destination port is being altered.                        */
        accumulate  = alias_port;
        accumulate -= tc->th_dport;
        sptr = (u_short *) &alias_address;
        accumulate += *sptr++;
        accumulate += *sptr;
        sptr = (u_short *) &original_address;
        accumulate -= *sptr++;
        accumulate -= *sptr;

/* If this is a proxy, then modify the TCP source port and
   checksum accumulation */
        if (proxy_port != 0)
        {
            accumulate += tc->th_sport;
            tc->th_sport = proxy_port;
            accumulate -= tc->th_sport;

            sptr = (u_short *) &pip->ip_src;
            accumulate += *sptr++;
            accumulate += *sptr;
            sptr = (u_short *) &proxy_address;
            accumulate -= *sptr++;
            accumulate -= *sptr;
        }

/* See if ACK number needs to be modified */
        if (GetAckModified(link) == 1)
        {
            int delta;

            delta = GetDeltaAckIn(pip, link);
            if (delta != 0)
            {
                sptr = (u_short *) &tc->th_ack;
                accumulate += *sptr++;
                accumulate += *sptr;
                tc->th_ack = htonl(ntohl(tc->th_ack) - delta);
                sptr = (u_short *) &tc->th_ack;
                accumulate -= *sptr++;
                accumulate -= *sptr;
            }
        }

        ADJUST_CHECKSUM(accumulate, tc->th_sum);

/* Restore original IP address */
        sptr = (u_short *) &pip->ip_dst;
        accumulate  = *sptr++;
        accumulate += *sptr;
        pip->ip_dst = original_address;
        sptr = (u_short *) &pip->ip_dst;
        accumulate -= *sptr++;
        accumulate -= *sptr;

/* If this is a transparent proxy packet, then modify the source
   address */
        if (proxy_address.s_addr != 0)
        {
            sptr = (u_short *) &pip->ip_src;
            accumulate += *sptr++;
            accumulate += *sptr;
            pip->ip_src = proxy_address;
            sptr = (u_short *) &pip->ip_src;
            accumulate -= *sptr++;
            accumulate -= *sptr;
        }

        ADJUST_CHECKSUM(accumulate, pip->ip_sum);

/* Monitor TCP connection state */
        TcpMonitorIn(pip, link);

        return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_IGNORED);
}

static int
TcpAliasOut(struct ip *pip, int maxpacketsize)
{
    int proxy_type;
    u_short dest_port;
    u_short proxy_server_port;
    struct in_addr dest_address;
    struct in_addr proxy_server_address;
    struct tcphdr *tc;
    struct alias_link *link;

    tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));

    proxy_type = ProxyCheck(pip, &proxy_server_address, &proxy_server_port);

    if (proxy_type == 0 && (packetAliasMode & PKT_ALIAS_PROXY_ONLY))
        return PKT_ALIAS_OK;

/* If this is a transparent proxy, save original destination,
   then alter the destination and adjust checksums */
    dest_port = tc->th_dport;
    dest_address = pip->ip_dst;
    if (proxy_type != 0)
    {
        int accumulate;
        u_short *sptr;

        accumulate = tc->th_dport;
        tc->th_dport = proxy_server_port;
        accumulate -= tc->th_dport;

        sptr = (u_short *) &(pip->ip_dst);
        accumulate += *sptr++;
        accumulate += *sptr;
        sptr = (u_short *) &proxy_server_address;
        accumulate -= *sptr++;
        accumulate -= *sptr;

        ADJUST_CHECKSUM(accumulate, tc->th_sum);

        sptr = (u_short *) &(pip->ip_dst);
        accumulate  = *sptr++;
        accumulate += *sptr;
        pip->ip_dst = proxy_server_address;
        sptr = (u_short *) &(pip->ip_dst);
        accumulate -= *sptr++;
        accumulate -= *sptr;

        ADJUST_CHECKSUM(accumulate, pip->ip_sum);
    }

    link = FindUdpTcpOut(pip->ip_src, pip->ip_dst,
                         tc->th_sport, tc->th_dport,
                         IPPROTO_TCP, 1);
    if (link !=NULL)
    {
        u_short alias_port;
        struct in_addr alias_address;
        int accumulate;
        u_short *sptr;

/* Save original destination address, if this is a proxy packet.
   Also modify packet to include destination encoding.  This may
   change the size of IP header. */
        if (proxy_type != 0)
        {
            SetProxyPort(link, dest_port);
            SetProxyAddress(link, dest_address);
            ProxyModify(link, pip, maxpacketsize, proxy_type);
            tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));
        }

/* Get alias address and port */
        alias_port = GetAliasPort(link);
        alias_address = GetAliasAddress(link);

/* Monitor TCP connection state */
        TcpMonitorOut(pip, link);

/* Special processing for IP encoding protocols */
        if (ntohs(tc->th_dport) == FTP_CONTROL_PORT_NUMBER
         || ntohs(tc->th_sport) == FTP_CONTROL_PORT_NUMBER)
            AliasHandleFtpOut(pip, link, maxpacketsize);
        else if (ntohs(tc->th_dport) == IRC_CONTROL_PORT_NUMBER_1
         || ntohs(tc->th_dport) == IRC_CONTROL_PORT_NUMBER_2)
            AliasHandleIrcOut(pip, link, maxpacketsize);
        else if (ntohs(tc->th_dport) == RTSP_CONTROL_PORT_NUMBER_1
         || ntohs(tc->th_sport) == RTSP_CONTROL_PORT_NUMBER_1
         || ntohs(tc->th_dport) == RTSP_CONTROL_PORT_NUMBER_2
         || ntohs(tc->th_sport) == RTSP_CONTROL_PORT_NUMBER_2)
            AliasHandleRtspOut(pip, link, maxpacketsize);
        else if (ntohs(tc->th_dport) == PPTP_CONTROL_PORT_NUMBER
         || ntohs(tc->th_sport) == PPTP_CONTROL_PORT_NUMBER)
            AliasHandlePptpOut(pip, link);
        else if (skinnyPort != 0 && (ntohs(tc->th_sport) == skinnyPort
         || ntohs(tc->th_dport) == skinnyPort))
            AliasHandleSkinny(pip, link);

/* Adjust TCP checksum since source port is being aliased */
/* and source address is being altered                    */
        accumulate  = tc->th_sport;
        tc->th_sport = alias_port;
        accumulate -= tc->th_sport;

        sptr = (u_short *) &(pip->ip_src);
        accumulate += *sptr++;
        accumulate += *sptr;
        sptr = (u_short *) &alias_address;
        accumulate -= *sptr++;
        accumulate -= *sptr;

/* Modify sequence number if necessary */
        if (GetAckModified(link) == 1)
        {
            int delta;

            delta = GetDeltaSeqOut(pip, link);
            if (delta != 0)
            {
                sptr = (u_short *) &tc->th_seq;
                accumulate += *sptr++;
                accumulate += *sptr;
                tc->th_seq = htonl(ntohl(tc->th_seq) + delta);
                sptr = (u_short *) &tc->th_seq;
                accumulate -= *sptr++;
                accumulate -= *sptr;
            }
        }

        ADJUST_CHECKSUM(accumulate, tc->th_sum);

/* Change source address */
        sptr = (u_short *) &(pip->ip_src);
        accumulate  = *sptr++;
        accumulate += *sptr;
        pip->ip_src = alias_address;
        sptr = (u_short *) &(pip->ip_src);
        accumulate -= *sptr++;
        accumulate -= *sptr;

        ADJUST_CHECKSUM(accumulate, pip->ip_sum);

        return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_IGNORED);
}




/* Fragment Handling

    FragmentIn()
    FragmentOut()

The packet aliasing module has a limited ability for handling IP
fragments.  If the ICMP, TCP or UDP header is in the first fragment
received, then the ID number of the IP packet is saved, and other
fragments are identified according to their ID number and IP address
they were sent from.  Pointers to unresolved fragments can also be
saved and recalled when a header fragment is seen.
*/

/* Local prototypes */
static int FragmentIn(struct ip *);
static int FragmentOut(struct ip *);


static int
FragmentIn(struct ip *pip)
{
    struct alias_link *link;

    link = FindFragmentIn2(pip->ip_src, pip->ip_dst, pip->ip_id);
    if (link != NULL)
    {
        struct in_addr original_address;

        GetFragmentAddr(link, &original_address);
        DifferentialChecksum(&pip->ip_sum,
                             (u_short *) &original_address,
                             (u_short *) &pip->ip_dst,
                             2);
        pip->ip_dst = original_address;

        return(PKT_ALIAS_OK);
    }
    return(PKT_ALIAS_UNRESOLVED_FRAGMENT);
}


static int
FragmentOut(struct ip *pip)
{
    struct in_addr alias_address;

    alias_address = FindAliasAddress(pip->ip_src);
    DifferentialChecksum(&pip->ip_sum,
                         (u_short *) &alias_address,
                         (u_short *) &pip->ip_src,
                          2);
    pip->ip_src = alias_address;

    return(PKT_ALIAS_OK);
}






/* Outside World Access

        PacketAliasSaveFragment()
        PacketAliasGetFragment()
        PacketAliasFragmentIn()
        PacketAliasIn()
        PacketAliasOut()
        PacketUnaliasOut()

(prototypes in alias.h)
*/


int
PacketAliasSaveFragment(char *ptr)
{
    int iresult;
    struct alias_link *link;
    struct ip *pip;

    pip = (struct ip *) ptr;
    link = AddFragmentPtrLink(pip->ip_src, pip->ip_id);
    iresult = PKT_ALIAS_ERROR;
    if (link != NULL)
    {
        SetFragmentPtr(link, ptr);
        iresult = PKT_ALIAS_OK;
    }
    return(iresult);
}


char *
PacketAliasGetFragment(char *ptr)
{
    struct alias_link *link;
    char *fptr;
    struct ip *pip;

    pip = (struct ip *) ptr;
    link = FindFragmentPtr(pip->ip_src, pip->ip_id);
    if (link != NULL)
    {
        GetFragmentPtr(link, &fptr);
        SetFragmentPtr(link, NULL);
        SetExpire(link, 0); /* Deletes link */

        return(fptr);
    }
    else
    {
        return(NULL);
    }
}


void
PacketAliasFragmentIn(char *ptr,          /* Points to correctly de-aliased
                                             header fragment */
                      char *ptr_fragment  /* Points to fragment which must
                                             be de-aliased   */
                     )
{
    struct ip *pip;
    struct ip *fpip;

    pip = (struct ip *) ptr;
    fpip = (struct ip *) ptr_fragment;

    DifferentialChecksum(&fpip->ip_sum,
                         (u_short *) &pip->ip_dst,
                         (u_short *) &fpip->ip_dst,
                         2);
    fpip->ip_dst = pip->ip_dst;
}


int
PacketAliasIn(char *ptr, int maxpacketsize)
{
    struct in_addr alias_addr;
    struct ip *pip;
    int iresult;

    if (packetAliasMode & PKT_ALIAS_REVERSE) {
        packetAliasMode &= ~PKT_ALIAS_REVERSE;
        iresult = PacketAliasOut(ptr, maxpacketsize);
        packetAliasMode |= PKT_ALIAS_REVERSE;
        return iresult;
    }

    HouseKeeping();
    ClearCheckNewLink();
    pip = (struct ip *) ptr;
    alias_addr = pip->ip_dst;

    /* Defense against mangled packets */
    if (ntohs(pip->ip_len) > maxpacketsize
     || (pip->ip_hl<<2) > maxpacketsize)
        return PKT_ALIAS_IGNORED;

    iresult = PKT_ALIAS_IGNORED;
    if ( (ntohs(pip->ip_off) & IP_OFFMASK) == 0 )
    {
        switch (pip->ip_p)
        {
            case IPPROTO_ICMP:
                iresult = IcmpAliasIn(pip);
                break;
            case IPPROTO_UDP:
                iresult = UdpAliasIn(pip);
                break;
            case IPPROTO_TCP:
                iresult = TcpAliasIn(pip);
                break;
            case IPPROTO_GRE:
		if (packetAliasMode & PKT_ALIAS_PROXY_ONLY ||
		    AliasHandlePptpGreIn(pip) == 0)
		    iresult = PKT_ALIAS_OK;
		else
		    iresult = ProtoAliasIn(pip);
		break;
	    default:
		iresult = ProtoAliasIn(pip);
                break;
        }

        if (ntohs(pip->ip_off) & IP_MF)
        {
            struct alias_link *link;

            link = FindFragmentIn1(pip->ip_src, alias_addr, pip->ip_id);
            if (link != NULL)
            {
                iresult = PKT_ALIAS_FOUND_HEADER_FRAGMENT;
                SetFragmentAddr(link, pip->ip_dst);
            }
            else
            {
                iresult = PKT_ALIAS_ERROR;
            }
        }
    }
    else
    {
        iresult = FragmentIn(pip);
    }

    return(iresult);
}



/* Unregistered address ranges */

/* 10.0.0.0   ->   10.255.255.255 */
#define UNREG_ADDR_A_LOWER 0x0a000000
#define UNREG_ADDR_A_UPPER 0x0affffff

/* 172.16.0.0  ->  172.31.255.255 */
#define UNREG_ADDR_B_LOWER 0xac100000
#define UNREG_ADDR_B_UPPER 0xac1fffff

/* 192.168.0.0 -> 192.168.255.255 */
#define UNREG_ADDR_C_LOWER 0xc0a80000
#define UNREG_ADDR_C_UPPER 0xc0a8ffff

int
PacketAliasOut(char *ptr,           /* valid IP packet */
               int  maxpacketsize   /* How much the packet data may grow
                                       (FTP and IRC inline changes) */
              )
{
    int iresult;
    struct in_addr addr_save;
    struct ip *pip;

    if (packetAliasMode & PKT_ALIAS_REVERSE) {
        packetAliasMode &= ~PKT_ALIAS_REVERSE;
        iresult = PacketAliasIn(ptr, maxpacketsize);
        packetAliasMode |= PKT_ALIAS_REVERSE;
        return iresult;
    }

    HouseKeeping();
    ClearCheckNewLink();
    pip = (struct ip *) ptr;

    /* Defense against mangled packets */
    if (ntohs(pip->ip_len) > maxpacketsize
     || (pip->ip_hl<<2) > maxpacketsize)
        return PKT_ALIAS_IGNORED;

    addr_save = GetDefaultAliasAddress();
    if (packetAliasMode & PKT_ALIAS_UNREGISTERED_ONLY)
    {
        u_long addr;
        int iclass;

        iclass = 0;
        addr = ntohl(pip->ip_src.s_addr);
        if      (addr >= UNREG_ADDR_C_LOWER && addr <= UNREG_ADDR_C_UPPER)
            iclass = 3;
        else if (addr >= UNREG_ADDR_B_LOWER && addr <= UNREG_ADDR_B_UPPER)
            iclass = 2;
        else if (addr >= UNREG_ADDR_A_LOWER && addr <= UNREG_ADDR_A_UPPER)
            iclass = 1;

        if (iclass == 0)
        {
            SetDefaultAliasAddress(pip->ip_src);
        }
    }

    iresult = PKT_ALIAS_IGNORED;
    if ((ntohs(pip->ip_off) & IP_OFFMASK) == 0)
    {
        switch (pip->ip_p)
        {
            case IPPROTO_ICMP:
                iresult = IcmpAliasOut(pip);
                break;
            case IPPROTO_UDP:
                iresult = UdpAliasOut(pip);
                break;
            case IPPROTO_TCP:
                iresult = TcpAliasOut(pip, maxpacketsize);
                break;
	    case IPPROTO_GRE:
		if (AliasHandlePptpGreOut(pip) == 0)
		    iresult = PKT_ALIAS_OK;
		else
		    iresult = ProtoAliasOut(pip);
		break;
	    default:
		iresult = ProtoAliasOut(pip);
                break;
        }
    }
    else
    {
        iresult = FragmentOut(pip);
    }

    SetDefaultAliasAddress(addr_save);
    return(iresult);
}

int
PacketUnaliasOut(char *ptr,           /* valid IP packet */
                 int  maxpacketsize   /* for error checking */
                )
{
    struct ip		*pip;
    struct icmp 	*ic;
    struct udphdr	*ud;
    struct tcphdr 	*tc;
    struct alias_link 	*link;
    int 		iresult = PKT_ALIAS_IGNORED;

    pip = (struct ip *) ptr;

    /* Defense against mangled packets */
    if (ntohs(pip->ip_len) > maxpacketsize
     || (pip->ip_hl<<2) > maxpacketsize)
        return(iresult);

    ud = (struct udphdr *) ((char *) pip + (pip->ip_hl << 2));
    tc = (struct tcphdr *) ud;
    ic = (struct icmp *) ud;

    /* Find a link */
    if (pip->ip_p == IPPROTO_UDP)
        link = FindUdpTcpIn(pip->ip_dst, pip->ip_src,
                            ud->uh_dport, ud->uh_sport,
                            IPPROTO_UDP, 0);
    else if (pip->ip_p == IPPROTO_TCP)
        link = FindUdpTcpIn(pip->ip_dst, pip->ip_src,
                            tc->th_dport, tc->th_sport,
                            IPPROTO_TCP, 0);
    else if (pip->ip_p == IPPROTO_ICMP)
        link = FindIcmpIn(pip->ip_dst, pip->ip_src, ic->icmp_id, 0);
    else
        link = NULL;

    /* Change it from an aliased packet to an unaliased packet */
    if (link != NULL)
    {
        if (pip->ip_p == IPPROTO_UDP || pip->ip_p == IPPROTO_TCP)
        {
            u_short        *sptr;
            int 	   accumulate;
            struct in_addr original_address;
            u_short        original_port;

            original_address = GetOriginalAddress(link);
            original_port = GetOriginalPort(link);

            /* Adjust TCP/UDP checksum */
            sptr = (u_short *) &(pip->ip_src);
            accumulate  = *sptr++;
            accumulate += *sptr;
            sptr = (u_short *) &original_address;
            accumulate -= *sptr++;
            accumulate -= *sptr;

            if (pip->ip_p == IPPROTO_UDP) {
                accumulate += ud->uh_sport;
                accumulate -= original_port;
                ADJUST_CHECKSUM(accumulate, ud->uh_sum);
	    } else {
                accumulate += tc->th_sport;
                accumulate -= original_port;
                ADJUST_CHECKSUM(accumulate, tc->th_sum);
	    }

            /* Adjust IP checksum */
            DifferentialChecksum(&pip->ip_sum,
                                 (u_short *) &original_address,
                                 (u_short *) &pip->ip_src,
                                 2);

            /* Un-alias source address and port number */
            pip->ip_src = original_address;
            if (pip->ip_p == IPPROTO_UDP)
                ud->uh_sport = original_port;
	    else
                tc->th_sport = original_port;

	    iresult = PKT_ALIAS_OK;

        } else if (pip->ip_p == IPPROTO_ICMP) {

            u_short        *sptr;
            int            accumulate;
            struct in_addr original_address;
            u_short        original_id;

            original_address = GetOriginalAddress(link);
            original_id = GetOriginalPort(link);

            /* Adjust ICMP checksum */
            sptr = (u_short *) &(pip->ip_src);
            accumulate  = *sptr++;
            accumulate += *sptr;
            sptr = (u_short *) &original_address;
            accumulate -= *sptr++;
            accumulate -= *sptr;
            accumulate += ic->icmp_id;
            accumulate -= original_id;
            ADJUST_CHECKSUM(accumulate, ic->icmp_cksum);

            /* Adjust IP checksum */
            DifferentialChecksum(&pip->ip_sum,
                                 (u_short *) &original_address,
                                 (u_short *) &pip->ip_src,
                                 2);

            /* Un-alias source address and port number */
            pip->ip_src = original_address;
            ic->icmp_id = original_id;

	    iresult = PKT_ALIAS_OK;
        }
    }
    return(iresult);

}
@


1.20
log
@Add Cisco Skinny Station Protocol translation support to libalias
and supporting applications (ppp).

From marcus FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: alias.c,v 1.19 2002/06/15 08:01:59 brian Exp $
@


1.19
log
@Tidy up end of line whitespace
@
text
@d28 1
a28 1
 * $OpenBSD: alias.c,v 1.18 2002/03/31 02:38:49 brian Exp $
d139 1
d912 3
d1096 3
@


1.18
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d28 1
a28 1
 * $OpenBSD: alias.c,v 1.17 2001/11/23 11:17:03 brian Exp $
d105 1
a105 1
    Version 3.1 May, 2000 (salander) 
d188 1
a188 1
     
d208 1
a208 1
/* Protocol Specific Packet Aliasing Routines 
d360 1
a360 1
    
d382 1
a382 1
            ud->uh_sport = original_port; 
d412 1
a412 1
/* Un-alias address of original IP packet and sequence number of 
d554 1
a554 1
    
d581 1
a581 1
            ud->uh_dport = alias_port; 
d616 1
a616 1
/* Alias address of original IP packet and sequence number of 
d1087 1
a1087 1
         || ntohs(tc->th_sport) == RTSP_CONTROL_PORT_NUMBER_2) 
d1178 2
a1179 2
        pip->ip_dst = original_address; 
   
d1301 1
a1301 1
        
d1306 1
a1306 1
        
d1486 1
a1486 1
    else if (pip->ip_p == IPPROTO_ICMP) 
d1503 1
a1503 1
    
d1516 1
a1516 1
	    } else { 
d1528 1
a1528 1
            /* Un-alias source address and port number */ 
d1530 5
a1534 5
            if (pip->ip_p == IPPROTO_UDP) 
                ud->uh_sport = original_port; 
	    else   
                tc->th_sport = original_port; 
            
@


1.17
log
@cmott@@scientech.com -> cm@@linktel.net
Add the UPTIME variable
CCP protocol ``0xffffffff'' -> ``none''
Don't leak memory when expanding command arguments and not exec()ing
Make some functions static
Add the ``log'' command for manual logging
Fix some log text bogons
@
text
@d28 1
a28 1
 * $OpenBSD: alias.c,v 1.16 2001/09/13 10:32:54 brian Exp $
d1060 2
a1061 1
   Also modify packet to include destination encoding. */
d1067 1
@


1.16
log
@Add TFTP support; FreeBSD
@
text
@d4 1
a4 1
 * Copyright (c) 2001 Charles Mott <cmott@@scientech.com>
d28 1
a28 1
 * $OpenBSD: alias.c,v 1.15 2001/08/21 04:09:15 brian Exp $
@


1.15
log
@Remove some conflicting copyright lines.
@
text
@d28 1
a28 1
 * $OpenBSD: alias.c,v 1.14 2001/06/07 09:32:55 brian Exp $
d137 1
d841 8
@


1.14
log
@Depricate the -alias option (it's been -nat for a long time)
Handle carriage-return/line-feed stuff for ftp natting more generically
Fix an alignment bug when logging DNS traffic
Fix/add some copyrights
@
text
@d28 1
a28 1
 * $OpenBSD$
a46 3

    This software is placed into the public domain with no restrictions
    on its distribution.
@


1.13
log
@Add some style(9) to alias*.h
@
text
@d2 29
a115 2

    $OpenBSD: alias.c,v 1.12 2000/11/02 00:53:47 brian Exp $
@


1.12
log
@Improvements for ICMP and GRE/PPTP; FreeBSD
@
text
@d88 1
a88 1
    $OpenBSD: alias.c,v 1.11 2000/10/06 00:26:43 brian Exp $
d100 2
d266 1
a266 1
        ADJUST_CHECKSUM(accumulate, ic->icmp_cksum)
d345 1
a345 1
            ADJUST_CHECKSUM(accumulate, ic->icmp_cksum)
d378 1
a378 1
            ADJUST_CHECKSUM(accumulate, ic->icmp_cksum)
d459 1
a459 1
        ADJUST_CHECKSUM(accumulate, ic->icmp_cksum)
d539 1
a539 1
            ADJUST_CHECKSUM(accumulate, ic->icmp_cksum)
d577 1
a577 1
            ADJUST_CHECKSUM(accumulate, ic->icmp_cksum)
d761 1
a761 1
            ADJUST_CHECKSUM(accumulate, ud->uh_sum)
d832 1
a832 1
            ADJUST_CHECKSUM(accumulate, ud->uh_sum)
d1089 1
a1089 1
        ADJUST_CHECKSUM(accumulate, tc->th_sum)
d1100 1
a1100 1
        ADJUST_CHECKSUM(accumulate, pip->ip_sum)
d1480 1
a1480 1
                ADJUST_CHECKSUM(accumulate, ud->uh_sum)
d1484 1
a1484 1
                ADJUST_CHECKSUM(accumulate, tc->th_sum)
d1521 1
a1521 1
            ADJUST_CHECKSUM(accumulate, ic->icmp_cksum)
@


1.11
log
@Fix byte ordering for CuSeeMe and add some tidy-ups; FreeBSD
@
text
@d88 1
a88 1
    $OpenBSD: alias.c,v 1.10 2000/09/02 22:12:26 brian Exp $
a187 1
    GreAliasIn()
a238 2
static int GreAliasIn(struct ip *);

d253 1
a253 1
    link = FindIcmpIn(pip->ip_src, pip->ip_dst, ic->icmp_id);
d309 1
a309 1
                            IPPROTO_UDP);
d313 1
a313 1
                            IPPROTO_TCP);
d316 1
a316 1
            link = FindIcmpIn(ip->ip_dst, ip->ip_src, ic2->icmp_id);
d446 1
a446 1
    link = FindIcmpOut(pip->ip_src, pip->ip_dst, ic->icmp_id);
d503 1
a503 1
                            IPPROTO_UDP);
d507 1
a507 1
                            IPPROTO_TCP);
d510 1
a510 1
            link = FindIcmpOut(ip->ip_dst, ip->ip_src, ic2->icmp_id);
a706 34
GreAliasIn(struct ip *pip)
{
    u_short call_id;
    struct alias_link *link;

/* Return if proxy-only mode is enabled. */
    if (packetAliasMode & PKT_ALIAS_PROXY_ONLY)
        return (PKT_ALIAS_OK);

    if (PptpGetCallID(pip, &call_id)) {
	if ((link = FindPptpIn(pip->ip_src, pip->ip_dst, call_id)) != NULL) {
	    struct in_addr alias_address;
	    struct in_addr original_address;

	    alias_address = GetAliasAddress(link);
	    original_address = GetOriginalAddress(link);
	    PptpSetCallID(pip, GetOriginalPort(link));

	    /* Restore original IP address. */
	    DifferentialChecksum(&pip->ip_sum,
				 (u_short *)&original_address,
				 (u_short *)&pip->ip_dst,
				 2);
	    pip->ip_dst = original_address;

	    return (PKT_ALIAS_OK);
	} else
	    return (PKT_ALIAS_IGNORED);
    } else
	return ProtoAliasIn(pip);
}


static int
d720 1
a720 1
                        IPPROTO_UDP);
d794 1
a794 1
                         IPPROTO_UDP);
d860 2
a861 1
                        IPPROTO_TCP);
d1016 1
a1016 1
                         IPPROTO_TCP);
d1285 6
a1290 2
                iresult = GreAliasIn(pip);
                break;
d1397 6
d1442 1
a1442 1
        link = QueryUdpTcpIn(pip->ip_dst, pip->ip_src,
d1444 1
a1444 1
                            IPPROTO_UDP);
d1446 1
a1446 1
        link = QueryUdpTcpIn(pip->ip_dst, pip->ip_src,
d1448 1
a1448 1
                            IPPROTO_TCP);
d1450 1
a1450 1
        link = FindIcmpIn(pip->ip_dst, pip->ip_src, ic->icmp_id);
@


1.10
log
@Some misc tidyups
strtok() -> strsep()
Handle icmp replies for requests originating outside the
``public'' interface correctly

Obtained from: FreeBSD
@
text
@d88 1
a88 1
    $OpenBSD: alias.c,v 1.9 2000/08/13 22:05:47 brian Exp $
d772 3
d776 7
a782 16
		if (ntohs(ud->uh_dport) == NETBIOS_DGM_PORT_NUMBER
         || ntohs(ud->uh_sport) == NETBIOS_DGM_PORT_NUMBER )
		{
            r = AliasHandleUdpNbt(pip, link, &original_address, ud->uh_dport);
		} else if (ntohs(ud->uh_dport) == NETBIOS_NS_PORT_NUMBER
         || ntohs(ud->uh_sport) == NETBIOS_NS_PORT_NUMBER )
		{
            r = AliasHandleUdpNbtNS(pip, link, 
								&alias_address,
								&alias_port,
								&original_address, 
								&ud->uh_dport );
		}

        if (ntohs(ud->uh_dport) == CUSEEME_PORT_NUMBER)
            AliasHandleCUSeeMeIn(pip, original_address);
d785 1
a785 1
/* is being unaliased and destination port is being altered.       */
d840 3
a842 3
        if (ntohs(ud->uh_dport) == CUSEEME_PORT_NUMBER)
            AliasHandleCUSeeMeOut(pip, link);

d844 7
a850 13
		if (ntohs(ud->uh_dport) == NETBIOS_DGM_PORT_NUMBER
         || ntohs(ud->uh_sport) == NETBIOS_DGM_PORT_NUMBER )
		{
            AliasHandleUdpNbt(pip, link, &alias_address, alias_port);
		} else if (ntohs(ud->uh_dport) == NETBIOS_NS_PORT_NUMBER
         || ntohs(ud->uh_sport) == NETBIOS_NS_PORT_NUMBER )
		{
            AliasHandleUdpNbtNS(pip, link,
								&pip->ip_src,
								&ud->uh_sport,
							    &alias_address,
							 	&alias_port); 
		}
@


1.9
log
@Add support for streaming media; FreeBSD
Add support for radius accounting in radlib.c (not yet working in ppp); FreeBSD
@
text
@d88 1
a88 1
    $OpenBSD: alias.c,v 1.8 2000/06/23 09:47:04 brian Exp $
d183 2
a184 2
    IcmpAliasIn(), IcmpAliasIn1(), IcmpAliasIn2(), IcmpAliasIn3()
    IcmpAliasOut(), IcmpAliasOut1(), IcmpAliasOut2(), IcmpAliasOut3()
a224 1
static int IcmpAliasIn3(struct ip *);
a228 1
static int IcmpAliasOut3(struct ip *);
d247 2
a248 1
    De-alias incoming echo and timestamp replies
d303 1
a303 1
    ip = (struct ip *) ic->icmp_data;
d360 1
a360 1
        else if (pip->ip_p == IPPROTO_ICMP)
a397 15
static int
IcmpAliasIn3(struct ip *pip)
{
    struct in_addr original_address;

    original_address = FindOriginalAddress(pip->ip_dst);
    DifferentialChecksum(&pip->ip_sum,
                         (u_short *) &original_address,
                         (u_short *) &pip->ip_dst,
                         2);
    pip->ip_dst = original_address;

    return PKT_ALIAS_OK;
}

d429 1
a429 1
            iresult = IcmpAliasIn3(pip);
d440 2
a441 1
    Alias ICMP echo and timestamp packets
d497 1
a497 1
    ip = (struct ip *) ic->icmp_data;
d542 11
a552 6
/* Alias address in IP header */
            DifferentialChecksum(&pip->ip_sum,
                                 (u_short *) &alias_address,
                                 (u_short *) &pip->ip_src,
                                 2);
            pip->ip_src = alias_address;
d559 1
a559 1
        else if (pip->ip_p == IPPROTO_ICMP)
d580 11
a590 6
/* Alias address in IP header */
            DifferentialChecksum(&pip->ip_sum,
                                 (u_short *) &alias_address,
                                 (u_short *) &pip->ip_src,
                                 2);
            pip->ip_src = alias_address;
a603 21
IcmpAliasOut3(struct ip *pip)
{
/*
  Handle outgoing echo and timestamp replies.  The
  only thing which is done in this case is to alias
  the source IP address of the packet.
*/
    struct in_addr alias_addr;

    alias_addr = FindAliasAddress(pip->ip_src);
    DifferentialChecksum(&pip->ip_sum,
                         (u_short *) &alias_addr,
                         (u_short *) &pip->ip_src,
                         2);
    pip->ip_src = alias_addr;

    return PKT_ALIAS_OK;
}


static int
d633 1
a633 1
            iresult = IcmpAliasOut3(pip);
@


1.8
log
@Improved 227, 229 and EPRT support in the nat code; FreeBSD
Moved security checks into one place; FreeBSD
Remove ``nat pptp'' now that it's transparent
@
text
@d79 1
a79 1
    Version 3.1 May, 2000 (eds)
d82 4
d88 1
a88 1
    $OpenBSD: alias.c,v 1.7 2000/06/11 14:40:26 brian Exp $
d109 2
d1121 5
d1250 1
d1479 121
@


1.7
log
@Merge libalias stuff from FreeBSD:
Ppp only really benefits from a bunch of typo fixes, transparent pptp
support and ftp/EPRT support.
@
text
@d79 3
d84 1
a84 1
    $OpenBSD: alias.c,v 1.6 2000/02/27 01:38:24 brian Exp $
a95 6
#ifndef IPPROTO_GRE
#define IPPROTO_GRE 47
#define IPPROTO_ESP 50
#define IPPROTO_AH  51
#endif

d105 1
d182 1
d236 2
d729 33
d940 5
d1112 1
a1112 1
        if (ntohs(tc->th_dport) == IRC_CONTROL_PORT_NUMBER_1
d1115 3
d1345 3
@


1.6
log
@$Id$ -> $OpenBSD$
@
text
@d16 1
a16 1
    data connections, while alias_irc.c do the same for IRC
d81 1
a81 1
    $OpenBSD: alias.c,v 1.5 2000/01/07 03:26:52 brian Exp $
a83 4
#include <stdio.h>
#include <unistd.h>

#include <sys/param.h>
d181 1
d196 1
a196 1
is used: the id number is replaced by an alias for the outgoing
d205 1
a205 1
that sequence and ack numbers have been altered (as is the case for
d228 3
d314 1
a314 1
         else
d382 2
a383 2
/* Un-alias address of original IP packet and seqence number of 
   embedded icmp datagram */
a497 1
    struct in_addr alias_addr;
d499 4
a502 1
    struct icmp *ic;
d507 28
a534 1
    alias_addr = FindAliasAddress(ip->ip_src);
d536 46
a581 6
/* Alias destination address in IP fragment */
    DifferentialChecksum(&ic->icmp_cksum,
                         (u_short *) &alias_addr,
                         (u_short *) &ip->ip_dst,
                         2);
    ip->ip_dst = alias_addr;
d583 6
a588 6
/* alias source address in IP header */
    DifferentialChecksum(&pip->ip_sum,
                         (u_short *) &alias_addr,
                         (u_short *) &pip->ip_src,
                         2);
    pip->ip_src = alias_addr;
d590 8
a597 1
    return PKT_ALIAS_OK;
d660 1
a660 1
PptpAliasIn(struct ip *pip)
d663 1
a663 1
  Handle incoming PPTP packets. The
d668 10
a677 1
    struct in_addr alias_addr;
d679 1
a679 2
    if (!GetPptpAlias (&alias_addr))
	return PKT_ALIAS_IGNORED;
d681 6
a686 1
    if (pip->ip_src.s_addr != alias_addr.s_addr) {
d688 1
a688 5
	    DifferentialChecksum(&pip->ip_sum,
				 (u_short *) &alias_addr,
				 (u_short *) &pip->ip_dst,
				 2);
	    pip->ip_dst = alias_addr;
d690 1
a690 2

    return PKT_ALIAS_OK;
d695 1
a695 1
PptpAliasOut(struct ip *pip)
d698 1
a698 1
  Handle outgoing PPTP packets. The
d702 10
a711 1
    struct in_addr alias_addr;
d713 1
a713 2
    if (!GetPptpAlias (&alias_addr))
	return PKT_ALIAS_IGNORED;
d715 6
a720 1
    if (pip->ip_src.s_addr == alias_addr.s_addr) {
d722 1
a722 6
	    alias_addr = FindAliasAddress(pip->ip_src);
	    DifferentialChecksum(&pip->ip_sum,
				 (u_short *) &alias_addr,
				 (u_short *) &pip->ip_src,
				 2);
	    pip->ip_src = alias_addr;
d724 1
a724 2

    return PKT_ALIAS_OK;
d924 1
a924 1
/* If this is a proxy, then modify the tcp source port  and
d940 1
a940 1
/* See if ack number needs to be modified */
d1011 1
a1011 1
   then alter the destination and adust checksums */
d1066 1
a1066 1
/* Monitor tcp connection state */
d1136 1
a1136 1
received, then the id number of the IP packet is saved, and other
d1304 2
a1305 4
            case IPPROTO_GRE:
            case IPPROTO_ESP:
            case IPPROTO_AH:
		iresult = PptpAliasIn(pip);
d1378 1
a1378 1
        unsigned int addr;
d1410 2
a1411 4
            case IPPROTO_GRE:
            case IPPROTO_ESP:
            case IPPROTO_AH:
		iresult = PptpAliasOut(pip);
@


1.5
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d81 1
a81 1
    $Id$
@


1.4
log
@Fix the unused REVERSE stuff in the packet aliasing code.
@
text
@d81 1
d99 2
d121 1
a121 1
These routines look for SYN, ACK and RST flags to determine when TCP
d143 3
a145 1
            if (tc->th_flags & TH_SYN)
d149 1
a149 2
            if (tc->th_flags & TH_FIN
                || tc->th_flags & TH_RST)
d165 3
a167 1
            if (tc->th_flags & TH_SYN)
d171 1
a171 2
            if (tc->th_flags & TH_FIN
                || tc->th_flags & TH_RST)
d1214 2
d1322 2
@


1.3
log
@Remove duplicate line; FreeBSD
@
text
@d1177 6
a1182 2
    if (packetAliasMode & PKT_ALIAS_REVERSE)
        return PacketAliasOut(ptr, maxpacketsize);
d1263 6
a1268 2
    if (packetAliasMode & PKT_ALIAS_REVERSE)
        return PacketAliasIn(ptr, maxpacketsize);
@


1.2
log
@Add proxying & transparent proxying support (``alias proxy'').
Add PPTP packet aliasing (GRE fixed address) support (``alias pptp'').
Add a 0 to the front of the mode to signify octal.
Thanks to: Charles Mott <cmott@@srv.net> & Dru Nelson <dnelson@@redwoodsoft.com>
@
text
@a105 1
#define FTP_CONTROL_PORT_NUMBER 21
@


1.1
log
@Move libalias sources into the ppp directory.
Suggested (many times) by: Theo
@
text
@d76 3
d96 4
a110 25
/*
   The following macro is used to update an
   internet checksum.  "delta" is a 32-bit
   accumulation of all the changes to the
   checksum (adding in new 16-bit words and
   subtracting out old words), and "cksum"
   is the checksum value to be updated.
*/
#define ADJUST_CHECKSUM(acc, cksum) { \
    acc += cksum; \
    if (acc < 0) \
    { \
        acc = -acc; \
        acc = (acc >> 16) + (acc & 0xffff); \
        acc += acc >> 16; \
        cksum = (u_short) ~acc; \
    } \
    else \
    { \
        acc = (acc >> 16) + (acc & 0xffff); \
        acc += acc >> 16; \
        cksum = (u_short) acc; \
    } \
}

d117 1
a117 1
    TcpMonitorOut() -- delete a link node when a connection is closed.
a387 1

d410 4
d548 4
d577 57
d640 4
d656 1
d667 1
a667 1
            AliasHandleUdpNbt(pip, link, &original_address, ud->uh_dport);
d671 1
a671 1
            AliasHandleUdpNbtNS(pip, link, 
d702 8
a709 1
        return(PKT_ALIAS_OK);
d720 4
d805 1
d807 1
d813 1
d816 1
d829 16
d866 3
a868 4
        DifferentialChecksum(&pip->ip_sum,
                             (u_short *) &original_address,
                             (u_short *) &pip->ip_dst,
                             2);
d870 18
d900 5
d910 38
d953 1
a954 1
        u_short alias_port;
d958 10
d974 1
a974 1
/* Special processing for ftp connection */
d979 1
a979 1
                        || ntohs(tc->th_dport) == IRC_CONTROL_PORT_NUMBER_2)
d985 3
a987 1
        accumulate -= alias_port;
a1014 3
/* Put alias address in TCP header */
        tc->th_sport = alias_port;

d1016 3
a1018 4
        DifferentialChecksum(&pip->ip_sum,
                             (u_short *) &alias_address,
                             (u_short *) &pip->ip_src,
                             2);
d1020 5
d1178 3
d1205 3
a1249 2


d1260 3
d1306 3
@

