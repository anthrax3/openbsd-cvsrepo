head	1.16;
access;
symbols
	OPENBSD_5_5:1.15.0.38
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.34
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.32
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.30
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.28
	OPENBSD_5_0:1.15.0.26
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.24
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.22
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.18
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.20
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.16
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.14
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.12
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.10
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.14
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.12
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.10
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.8
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.6
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.15;

1.15
date	2005.07.17.19.13.24;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.16.14.47.02;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.15.10.08.49;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.02.15.58.41;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.15.02.25.23;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.12.10.03.51;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.36;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.31.14.22.11;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.41;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.23;	author brian;	state Exp;
branches;
next	;


desc
@@


1.16
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1998 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *  $OpenBSD: link.c,v 1.15 2005/07/17 19:13:24 brad Exp $
 *
 */

#include <sys/types.h>
#include <netinet/in_systm.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <netinet/ip.h>

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <termios.h>

#include "defs.h"
#include "layer.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "proto.h"
#include "fsm.h"
#include "descriptor.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "prompt.h"
#include "async.h"
#include "physical.h"
#include "mp.h"
#include "iplist.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ip.h"
#include "ipcp.h"
#include "ipv6cp.h"
#include "auth.h"
#include "pap.h"
#include "chap.h"
#include "cbcp.h"
#include "command.h"

static void Despatch(struct bundle *, struct link *, struct mbuf *, u_short);

static inline void
link_AddInOctets(struct link *l, int n)
{
  if (l->stats.gather) {
    throughput_addin(&l->stats.total, n);
    if (l->stats.parent)
      throughput_addin(l->stats.parent, n);
  }
}

static inline void
link_AddOutOctets(struct link *l, int n)
{
  if (l->stats.gather) {
    throughput_addout(&l->stats.total, n);
    if (l->stats.parent)
      throughput_addout(l->stats.parent, n);
  }
}

void
link_SequenceQueue(struct link *l)
{
  struct mqueue *queue, *highest;

  log_Printf(LogDEBUG, "link_SequenceQueue\n");

  highest = LINK_HIGHQ(l);
  for (queue = l->Queue; queue < highest; queue++)
    while (queue->len)
      m_enqueue(highest, m_dequeue(queue));
}

void
link_DeleteQueue(struct link *l)
{
  struct mqueue *queue, *highest;

  highest = LINK_HIGHQ(l);
  for (queue = l->Queue; queue <= highest; queue++)
    while (queue->top)
      m_freem(m_dequeue(queue));
}

size_t
link_QueueLen(struct link *l)
{
  int i;
  size_t len;

  for (i = 0, len = 0; i < LINK_QUEUES(l); i++)
    len += l->Queue[i].len;

  return len;
}

size_t
link_QueueBytes(struct link *l)
{
  int i;
  size_t len, bytes;
  struct mbuf *m;

  bytes = 0;
  for (i = 0, len = 0; i < LINK_QUEUES(l); i++) {
    len = l->Queue[i].len;
    m = l->Queue[i].top;
    while (len--) {
      bytes += m_length(m);
      m = m->m_nextpkt;
    }
  }

  return bytes;
}

void
link_PendingLowPriorityData(struct link *l, size_t *pkts, size_t *octets)
{
  struct mqueue *queue, *highest;
  struct mbuf *m;
  size_t len;

  /*
   * This is all rfc1989 stuff... because our LQR packet is going to bypass
   * everything that's not in the highest priority queue, we must be able to
   * subtract that data from our outgoing packet/octet counts.  However,
   * we've already async-encoded our data at this point, but the async
   * encodings MUSTn't be a part of the LQR-reported payload :(  So, we have
   * the async layer record how much it's padded the packet in the mbuf's
   * priv field, and when we calculate our outgoing LQR values we subtract
   * this value for each packet from the octet count sent.
   */

  highest = LINK_HIGHQ(l);
  *pkts = *octets = 0;
  for (queue = l->Queue; queue < highest; queue++) {
    len = queue->len;
    *pkts += len;
    for (m = queue->top; len--; m = m->m_nextpkt)
      *octets += m_length(m) - m->priv;
  }
}

struct mbuf *
link_Dequeue(struct link *l)
{
  int pri;
  struct mbuf *bp;

  for (bp = NULL, pri = LINK_QUEUES(l) - 1; pri >= 0; pri--)
    if (l->Queue[pri].len) {
      bp = m_dequeue(l->Queue + pri);
      log_Printf(LogDEBUG, "link_Dequeue: Dequeued from queue %d,"
                " containing %lu more packets\n", pri,
                (u_long)l->Queue[pri].len);
      break;
    }

  return bp;
}

static struct protostatheader {
  u_short number;
  const char *name;
} ProtocolStat[NPROTOSTAT] = {
  { PROTO_IP, "IP" },
  { PROTO_VJUNCOMP, "VJ_UNCOMP" },
  { PROTO_VJCOMP, "VJ_COMP" },
  { PROTO_COMPD, "COMPD" },
  { PROTO_ICOMPD, "ICOMPD" },
  { PROTO_LCP, "LCP" },
  { PROTO_IPCP, "IPCP" },
  { PROTO_CCP, "CCP" },
  { PROTO_PAP, "PAP" },
  { PROTO_LQR, "LQR" },
  { PROTO_CHAP, "CHAP" },
  { PROTO_MP, "MULTILINK" },
  { 0, "Others" }
};

void
link_ProtocolRecord(struct link *l, u_short proto, int type)
{
  int i;

  for (i = 0; i < NPROTOSTAT; i++)
    if (ProtocolStat[i].number == proto)
      break;

  if (type == PROTO_IN)
    l->proto_in[i]++;
  else
    l->proto_out[i]++;
}

void
link_ReportProtocolStatus(struct link *l, struct prompt *prompt)
{
  int i;

  prompt_Printf(prompt, "    Protocol     in        out      "
                "Protocol      in       out\n");
  for (i = 0; i < NPROTOSTAT; i++) {
    prompt_Printf(prompt, "   %-9s: %8lu, %8lu",
	    ProtocolStat[i].name, l->proto_in[i], l->proto_out[i]);
    if ((i % 2) == 0)
      prompt_Printf(prompt, "\n");
  }
  if (!(i % 2))
    prompt_Printf(prompt, "\n");
}

void
link_PushPacket(struct link *l, struct mbuf *bp, struct bundle *b, int pri,
                u_short proto)
{
  int layer;

  /*
   * When we ``push'' a packet into the link, it gets processed by the
   * ``push'' function in each layer starting at the top.
   * We never expect the result of a ``push'' to be more than one
   * packet (as we do with ``pull''s).
   */

  if(pri < 0 || pri >= LINK_QUEUES(l))
    pri = 0;

  bp->priv = 0;		/* Adjusted by the async layer ! */
  for (layer = l->nlayers; layer && bp; layer--)
    if (l->layer[layer - 1]->push != NULL)
      bp = (*l->layer[layer - 1]->push)(b, l, bp, pri, &proto);

  if (bp) {
    link_AddOutOctets(l, m_length(bp));
    log_Printf(LogDEBUG, "link_PushPacket: Transmit proto 0x%04x\n", proto);
    m_enqueue(l->Queue + pri, m_pullup(bp));
  }
}

void
link_PullPacket(struct link *l, char *buf, size_t len, struct bundle *b)
{
  struct mbuf *bp, *lbp[LAYER_MAX], *next;
  u_short lproto[LAYER_MAX], proto;
  int layer;

  /*
   * When we ``pull'' a packet from the link, it gets processed by the
   * ``pull'' function in each layer starting at the bottom.
   * Each ``pull'' may produce multiple packets, chained together using
   * bp->m_nextpkt.
   * Each packet that results from each pull has to be pulled through
   * all of the higher layers before the next resulting packet is pulled
   * through anything; this ensures that packets that depend on the
   * fsm state resulting from the receipt of the previous packet aren't
   * surprised.
   */

  link_AddInOctets(l, len);

  memset(lbp, '\0', sizeof lbp);
  lbp[0] = m_get(len, MB_UNKNOWN);
  memcpy(MBUF_CTOP(lbp[0]), buf, len);
  lproto[0] = 0;
  layer = 0;

  while (layer || lbp[layer]) {
    if (lbp[layer] == NULL) {
      layer--;
      continue;
    }
    bp = lbp[layer];
    lbp[layer] = bp->m_nextpkt;
    bp->m_nextpkt = NULL;
    proto = lproto[layer];

    if (l->layer[layer]->pull != NULL)
      bp = (*l->layer[layer]->pull)(b, l, bp, &proto);

    if (layer == l->nlayers - 1) {
      /* We've just done the top layer, despatch the packet(s) */
      while (bp) {
        next = bp->m_nextpkt;
        bp->m_nextpkt = NULL;
        log_Printf(LogDEBUG, "link_PullPacket: Despatch proto 0x%04x\n", proto);
        Despatch(b, l, bp, proto);
        bp = next;
      }
    } else {
      lbp[++layer] = bp;
      lproto[layer] = proto;
    }
  }
}

int
link_Stack(struct link *l, struct layer *layer)
{
  if (l->nlayers == sizeof l->layer / sizeof l->layer[0]) {
    log_Printf(LogERROR, "%s: Oops, cannot stack a %s layer...\n",
               l->name, layer->name);
    return 0;
  }
  l->layer[l->nlayers++] = layer;
  return 1;
}

void
link_EmptyStack(struct link *l)
{
  l->nlayers = 0;
}

static const struct {
  u_short proto;
  struct mbuf *(*fn)(struct bundle *, struct link *, struct mbuf *);
} despatcher[] = {
  { PROTO_IP, ipv4_Input },
#ifndef NOINET6
  { PROTO_IPV6, ipv6_Input },
#endif
  { PROTO_MP, mp_Input },
  { PROTO_LCP, lcp_Input },
  { PROTO_IPCP, ipcp_Input },
#ifndef NOINET6
  { PROTO_IPV6CP, ipv6cp_Input },
#endif
  { PROTO_PAP, pap_Input },
  { PROTO_CHAP, chap_Input },
  { PROTO_CCP, ccp_Input },
  { PROTO_LQR, lqr_Input },
  { PROTO_CBCP, cbcp_Input }
};

#define DSIZE (sizeof despatcher / sizeof despatcher[0])

static void
Despatch(struct bundle *bundle, struct link *l, struct mbuf *bp, u_short proto)
{
  int f;

  for (f = 0; f < DSIZE; f++)
    if (despatcher[f].proto == proto) {
      bp = (*despatcher[f].fn)(bundle, l, bp);
      break;
    }

  if (bp) {
    struct physical *p = link2physical(l);

    log_Printf(LogPHASE, "%s protocol 0x%04x (%s)\n",
               f == DSIZE ? "Unknown" : "Unexpected", proto,
               hdlc_Protocol2Nam(proto));
    bp = m_pullup(proto_Prepend(bp, proto, 0, 0));
    lcp_SendProtoRej(&l->lcp, MBUF_CTOP(bp), bp->m_len);
    if (p) {
      p->hdlc.lqm.ifInDiscards++;
      p->hdlc.stats.unknownproto++;
    }
    m_freem(bp);
  }
}

int
link_ShowLayers(struct cmdargs const *arg)
{
  struct link *l = command_ChooseLink(arg);
  int layer;

  for (layer = l->nlayers; layer; layer--)
    prompt_Printf(arg->prompt, "%s%s", layer == l->nlayers ? "" : ", ",
                  l->layer[layer - 1]->name);
  if (l->nlayers)
    prompt_Printf(arg->prompt, "\n");

  return 0;
}
@


1.15
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d26 1
a26 1
 *  $OpenBSD: link.c,v 1.14 2004/11/16 14:47:02 brad Exp $
@


1.14
log
@Re-implement LQM, this time according to the rfc.

From FreeBSD

ok deraadt@@
@
text
@d26 1
a26 1
 *  $OpenBSD: link.c,v 1.13 2001/08/19 23:22:18 brian Exp $
d37 1
@


1.13
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *  $OpenBSD: link.c,v 1.12 2000/08/15 10:08:49 brian Exp $
d149 28
d262 1
d391 1
a391 1
      p->hdlc.lqm.SaveInDiscards++;
@


1.12
log
@Calculate the average link throughput using a counter based on the
cumulative total of all active links rather than basing it on the
total of PROTO_MP traffic.

This fixes a problem whereby Cisco routers send PROTO_IP packets only
when there's only one link (hmm, what a good idea!).
@
text
@d26 1
a26 1
 *  $OpenBSD: link.c,v 1.11 2000/02/27 01:38:27 brian Exp $
d32 1
d61 2
d64 1
a64 1
#include "ip.h"
d323 4
a326 1
  { PROTO_IP, ip_Input },
d330 3
@


1.11
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *  $OpenBSD: link.c,v 1.10 2000/01/07 03:26:54 brian Exp $
d70 1
a70 1
void
d73 5
a77 1
  throughput_addin(&l->throughput, n);
d80 1
a80 1
void
d83 5
a87 1
  throughput_addout(&l->throughput, n);
@


1.10
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *  $Id: link.c,v 1.9 1999/07/15 02:10:32 brian Exp $
@


1.9
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d26 1
a26 1
 *  $Id: link.c,v 1.7 1999/06/02 15:58:41 brian Exp $
a31 1
#include <netdb.h>
d85 2
d88 5
a92 2
  while (l->Queue[PRI_NORMAL].qlen)
    mbuf_Enqueue(l->Queue + PRI_LINK, mbuf_Dequeue(l->Queue + PRI_NORMAL));
d98 1
a98 1
  struct mqueue *queue;
d100 2
a101 1
  for (queue = l->Queue; queue < l->Queue + LINK_QUEUES; queue++)
d103 1
a103 1
      mbuf_Free(mbuf_Dequeue(queue));
d106 1
a106 1
int
d109 2
a110 1
  int i, len;
d112 2
a113 2
  for (i = 0, len = 0; i < LINK_QUEUES; i++)
    len += l->Queue[i].qlen;
d118 1
a118 1
int
d121 2
a122 1
  int i, len, bytes;
d126 2
a127 2
  for (i = 0, len = 0; i < LINK_QUEUES; i++) {
    len = l->Queue[i].qlen;
d130 2
a131 2
      bytes += mbuf_Length(m);
      m = m->pnext;
d144 3
a146 3
  for (bp = (struct mbuf *)0, pri = LINK_QUEUES - 1; pri >= 0; pri--)
    if (l->Queue[pri].qlen) {
      bp = mbuf_Dequeue(l->Queue + pri);
d148 2
a149 1
                " containing %d more packets\n", pri, l->Queue[pri].qlen);
d220 1
a220 1
  if(pri < 0 || pri >= LINK_QUEUES)
d228 1
a228 1
    link_AddOutOctets(l, mbuf_Length(bp));
d230 1
a230 1
    mbuf_Enqueue(l->Queue + pri, mbuf_Contiguous(bp));
d245 1
a245 1
   * bp->pnext.
d256 1
a256 1
  lbp[0] = mbuf_Alloc(len, MB_UNKNOWN);
d267 2
a268 2
    lbp[layer] = bp->pnext;
    bp->pnext = NULL;
d277 2
a278 2
        next = bp->pnext;
        bp->pnext = NULL;
d342 2
a343 2
    bp = mbuf_Contiguous(proto_Prepend(bp, proto, 0, 0));
    lcp_SendProtoRej(&l->lcp, MBUF_CTOP(bp), bp->cnt);
d348 1
a348 1
    mbuf_Free(bp);
@


1.8
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d32 1
a32 1
/* #include <netdb.h> (auto-remove) */
@


1.7
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d26 1
a26 1
 *  $Id: link.c,v 1.6 1999/05/15 02:25:23 brian Exp $
d32 1
a32 1
#include <netdb.h>
@


1.6
log
@Add ``show layers'' to see the protocol layering for a link.
@
text
@d26 1
a26 1
 *  $Id: link.c,v 1.5 1999/05/12 10:03:51 brian Exp $
d248 1
a248 1
  lbp[0] = mbuf_Alloc(len, MB_ASYNC);
@


1.5
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d26 1
a26 1
 *  $Id: link.c,v 1.4 1999/05/08 11:06:36 brian Exp $
d67 1
d342 15
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *  $Id: link.c,v 1.3 1999/03/31 14:22:11 brian Exp $
a218 1
    log_Printf(LogDEBUG, "link_PushPacket: proto = 0x%04x\n", proto);
d220 1
d270 1
@


1.3
log
@Avoid a few warnings on the alpha
@
text
@d26 1
a26 1
 *  $Id: link.c,v 1.2 1999/02/06 03:22:41 brian Exp $
d31 5
d42 1
d49 1
a49 1
#include "lcpproto.h"
d56 13
a146 33
/*
 * Write to the link. Actualy, requested packets are queued, and go out
 * at some later time depending on the physical link implementation.
 */
void
link_Write(struct link *l, int pri, const char *ptr, int count)
{
  struct mbuf *bp;

  if(pri < 0 || pri >= LINK_QUEUES)
    pri = 0;

  bp = mbuf_Alloc(count, MB_LINK);
  memcpy(MBUF_CTOP(bp), ptr, count);

  mbuf_Enqueue(l->Queue + pri, bp);
}

void
link_Output(struct link *l, int pri, struct mbuf *bp)
{
  struct mbuf *wp;
  int len;

  if(pri < 0 || pri >= LINK_QUEUES)
    pri = 0;

  len = mbuf_Length(bp);
  wp = mbuf_Alloc(len, MB_LINK);
  mbuf_Read(bp, MBUF_CTOP(wp), len);
  mbuf_Enqueue(l->Queue + pri, wp);
}

d196 144
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *  $Id: link.c,v 1.6 1998/08/26 18:07:56 brian Exp $
d33 1
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@a32 1
#include <string.h>
@

