head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.32
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.28
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.26
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.24
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.22
	OPENBSD_5_0:1.18.0.20
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.18
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.16
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.12
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.14
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.12
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.10
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.6
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.19
date	2014.03.17.17.15.52;	author deraadt;	state dead;
branches;
next	1.18;

1.18
date	2006.09.25.05.59.28;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.20.03.15.38;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.18.18.52.36;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.23.23.41.32;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.16.14.13.06;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.16.13.20.23;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.19.10.25.01;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.24.01.06.09;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.07.23.32.18;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.27.01.38.29;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.07.03.26.56;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.07.15.02.04.07;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.05.21.36.04;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.24.16.39.19;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.12.10.03.55;	author brian;	state Exp;
branches;
next	;


desc
@@


1.19
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1999 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: udp.c,v 1.18 2006/09/25 05:59:28 otto Exp $
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "defs.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "fsm.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "async.h"
#include "descriptor.h"
#include "physical.h"
#include "main.h"
#include "udp.h"


#define UDP_CONNECTED		1
#define UDP_UNCONNECTED		2
#define UDP_MAYBEUNCONNECTED	3

struct udpdevice {
  struct device dev;		/* What struct physical knows about */
  struct sockaddr_in sock;	/* peer address */
  unsigned connected : 2;	/* Have we connect()d ? */
};

#define device2udp(d) ((d)->type == UDP_DEVICE ? (struct udpdevice *)d : NULL)

int
udp_DeviceSize(void)
{
  return sizeof(struct udpdevice);
}

static ssize_t
udp_Sendto(struct physical *p, const void *v, size_t n)
{
  struct udpdevice *dev = device2udp(p->handler);
  int ret;

  switch (dev->connected) {
    case UDP_CONNECTED:
      ret = write(p->fd, v, n);
      break;

    case UDP_UNCONNECTED:
    default:
      ret = sendto(p->fd, v, n, 0, (struct sockaddr *)&dev->sock,
                   sizeof dev->sock);
      break;
  }
  if (dev->connected == UDP_MAYBEUNCONNECTED) {
    if (ret == -1 && errno == EISCONN) {
      dev->connected = UDP_CONNECTED;
      ret = write(p->fd, v, n);
    } else
      dev->connected = UDP_UNCONNECTED;
  }

  return ret;
}

static ssize_t
udp_Recvfrom(struct physical *p, void *v, size_t n)
{
  struct udpdevice *dev = device2udp(p->handler);
  int sz, ret;

  if (dev->connected == UDP_CONNECTED)
    return read(p->fd, v, n);

  sz = sizeof dev->sock;
  ret = recvfrom(p->fd, v, n, 0, (struct sockaddr *)&dev->sock, &sz);

  if (*p->name.full == '\0') {
    snprintf(p->name.full, sizeof p->name.full, "%s:%d/udp",
             inet_ntoa(dev->sock.sin_addr), ntohs(dev->sock.sin_port));
    p->name.base = p->name.full;
  }

  return ret;
}

static void
udp_Free(struct physical *p)
{
  struct udpdevice *dev = device2udp(p->handler);

  free(dev);
}

static void
udp_device2iov(struct device *d, struct iovec *iov, int *niov,
               int maxiov, int *auxfd, int *nauxfd)
{
  int sz = physical_MaxDeviceSize();

  iov[*niov].iov_base = realloc(d, sz);
  if (iov[*niov].iov_base == NULL) {
    log_Printf(LogALERT, "Failed to allocate memory: %d\n", sz);
    AbortProgram(EX_OSERR);
  }
  iov[*niov].iov_len = sz;
  (*niov)++;
}

static const struct device baseudpdevice = {
  UDP_DEVICE,
  "udp",
  0,
  { CD_NOTREQUIRED, 0 },
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  udp_Free,
  udp_Recvfrom,
  udp_Sendto,
  udp_device2iov,
  NULL,
  NULL,
  NULL
};

struct device *
udp_iov2device(int type, struct physical *p, struct iovec *iov, int *niov,
               int maxiov, int *auxfd, int *nauxfd)
{
  if (type == UDP_DEVICE) {
    struct udpdevice *dev = (struct udpdevice *)iov[(*niov)++].iov_base;
    struct udpdevice *newdev;

    newdev = realloc(dev, sizeof *dev);	/* Reduce to the correct size */
    if (newdev == NULL) {
      log_Printf(LogALERT, "Failed to allocate memory: %d\n",
                 (int)(sizeof *dev));
      AbortProgram(EX_OSERR);
    }
    dev = newdev;

    /* Refresh function pointers etc */
    memcpy(&dev->dev, &baseudpdevice, sizeof dev->dev);

    physical_SetupStack(p, dev->dev.name, PHYSICAL_FORCE_SYNC);
    return &dev->dev;
  }

  return NULL;
}

static struct udpdevice *
udp_CreateDevice(struct physical *p, char *host, char *port)
{
  struct udpdevice *dev;
  struct servent *sp;

  if ((dev = malloc(sizeof *dev)) == NULL) {
    log_Printf(LogWARN, "%s: Cannot allocate a udp device: %s\n",
               p->link.name, strerror(errno));
    return NULL;
  }

  dev->sock.sin_family = AF_INET;
  dev->sock.sin_addr = GetIpAddr(host);
  if (dev->sock.sin_addr.s_addr == INADDR_NONE) {
    log_Printf(LogWARN, "%s: %s: unknown host\n", p->link.name, host);
    free(dev);
    return NULL;
  }
  dev->sock.sin_port = htons(atoi(port));
  if (dev->sock.sin_port == 0) {
    sp = getservbyname(port, "udp");
    if (sp)
      dev->sock.sin_port = sp->s_port;
    else {
      log_Printf(LogWARN, "%s: %s: unknown service\n", p->link.name, port);
      free(dev);
      return NULL;
    }
  }

  log_Printf(LogPHASE, "%s: Connecting to %s:%s/udp\n", p->link.name,
             host, port);

  p->fd = socket(PF_INET, SOCK_DGRAM, 0);
  if (p->fd >= 0) {
    log_Printf(LogDEBUG, "%s: Opened udp socket %s\n", p->link.name,
               p->name.full);
    if (connect(p->fd, (struct sockaddr *)&dev->sock, sizeof dev->sock) == 0) {
      dev->connected = UDP_CONNECTED;
      return dev;
    } else
      log_Printf(LogWARN, "%s: connect: %s\n", p->name.full, strerror(errno));
  } else
    log_Printf(LogWARN, "%s: socket: %s\n", p->name.full, strerror(errno));

  close(p->fd);
  p->fd = -1;
  free(dev);

  return NULL;
}

struct device *
udp_Create(struct physical *p)
{
  char *cp, *host, *port, *svc;
  struct udpdevice *dev;

  dev = NULL;
  if (p->fd < 0) {
    if ((cp = strchr(p->name.full, ':')) != NULL && !strchr(cp + 1, ':')) {
      *cp = '\0';
      host = p->name.full;
      port = cp + 1;
      svc = strchr(port, '/');
      if (svc && strcasecmp(svc, "/udp")) {
        *cp = ':';
        return NULL;
      }
      if (svc) {
        p->fd--;     /* We own the device but maybe can't use it - change fd */
        *svc = '\0';
      }

      if (*host && *port)
        dev = udp_CreateDevice(p, host, port);

      *cp = ':';
      if (svc)
        *svc = '/';
    }
  } else {
    /* See if we're a connected udp socket */
    struct stat st;

    if (fstat(p->fd, &st) != -1 && S_ISSOCK(st.st_mode)) {
      int type, sz;

      sz = sizeof type;
      if (getsockopt(p->fd, SOL_SOCKET, SO_TYPE, &type, &sz) == -1) {
        log_Printf(LogPHASE, "%s: Link is a closed socket !\n", p->link.name);
        close(p->fd);
        p->fd = -1;
        return NULL;
      }

      if (sz == sizeof type && type == SOCK_DGRAM) {
        struct sockaddr_in sock;
        struct sockaddr *sockp = (struct sockaddr *)&sock;

        if ((dev = malloc(sizeof *dev)) == NULL) {
          log_Printf(LogWARN, "%s: Cannot allocate a udp device: %s\n",
                     p->link.name, strerror(errno));
          return NULL;
        }

        if (getpeername(p->fd, sockp, &sz) == 0) {
          log_Printf(LogPHASE, "%s: Link is a connected udp socket\n",
                     p->link.name);
          dev->connected = UDP_CONNECTED;
	} else {
          log_Printf(LogPHASE, "%s: Link is a disconnected udp socket\n",
                     p->link.name);

          dev->connected = UDP_MAYBEUNCONNECTED;

          if (p->link.lcp.cfg.openmode != OPEN_PASSIVE) {
            log_Printf(LogPHASE, "%s:   Changing openmode to PASSIVE\n",
                       p->link.name);
            p->link.lcp.cfg.openmode = OPEN_PASSIVE;
          }
        }
      }
    }
  }

  if (dev) {
    memcpy(&dev->dev, &baseudpdevice, sizeof dev->dev);
    physical_SetupStack(p, dev->dev.name, PHYSICAL_FORCE_SYNC);
    if (p->cfg.cd.necessity != CD_DEFAULT)
      log_Printf(LogWARN, "Carrier settings ignored\n");
    return &dev->dev;
  }

  return NULL;
}
@


1.18
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by
from Paul Stoeber, more to come. ok jaredy@@
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.17 2003/10/20 03:15:38 deraadt Exp $
@


1.17
log
@realloc fixes
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.16 2002/07/18 18:52:36 brian Exp $
d287 1
a287 1
    if (fstat(p->fd, &st) != -1 && (st.st_mode & S_IFSOCK)) {
@


1.16
log
@Remove unused calls to inet_addr()
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.15 2002/05/16 01:13:39 brian Exp $
d181 1
d183 2
a184 2
    dev = realloc(dev, sizeof *dev);	/* Reduce to the correct size */
    if (dev == NULL) {
d189 1
@


1.15
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.14 2002/03/31 02:38:49 brian Exp $
a211 1
  dev->sock.sin_addr.s_addr = inet_addr(host);
@


1.14
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.13 2002/01/23 23:41:32 brian Exp $
d170 1
@


1.13
log
@Detect if a udp socket on STDIN_FILENO is connected by calling
getpeername() and don't set PASSIVE mode if it's is.
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.12 2002/01/16 14:13:06 brian Exp $
d159 1
@


1.12
log
@socket()s first argument should be a protocol family rather than an
address family.
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.11 2002/01/16 13:20:23 brian Exp $
d296 3
d305 7
a311 2
        /* We can't getpeername().... */
        dev->connected = UDP_MAYBEUNCONNECTED;
d313 1
a313 1
        log_Printf(LogPHASE, "%s: Link is a udp socket\n", p->link.name);
d315 5
a319 4
        if (p->link.lcp.cfg.openmode != OPEN_PASSIVE) {
          log_Printf(LogPHASE, "%s:   Changing openmode to PASSIVE\n",
                     p->link.name);
          p->link.lcp.cfg.openmode = OPEN_PASSIVE;
@


1.11
log
@socket's first argument is an address family, not a protocol family.
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.10 2001/06/19 10:25:01 brian Exp $
d232 1
a232 1
  p->fd = socket(AF_INET, SOCK_DGRAM, 0);
@


1.10
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.9 2001/03/24 01:06:09 brian Exp $
d232 1
a232 1
  p->fd = socket(PF_INET, SOCK_DGRAM, 0);
@


1.9
log
@Remove some unprotected prototype variable names
MAXPATHLEN -> PATH_MAX
Handle ENOENT from opening /dev/tun* properly
Rename _PATH_PPP -> PPP_CONFDIR and allow it to be redefined at compile time
Reduce MIN_LQRPERIOD and MIN_FSMRETRY to 1 second
Be smarter about identifying sockets on stdin
Allow primary DNS IP negotiation when the secondary IP has been rejected
Fix the call to PacketAliasProxyRule() properly.
Add/fix some comments
Fix man page markups; ru@@FreeBSD.org
Use localhost when no hostname is configured
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.8 2000/11/07 23:32:18 brian Exp $
d157 1
@


1.8
log
@Don't assume that a SOCK_DGRAM descriptor in -direct mode is an
unconnected socket.
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.7 2000/02/27 01:38:29 brian Exp $
d40 1
d281 1
a281 1
    int type, sz, err;
d283 8
a290 6
    sz = sizeof type;
    if ((err = getsockopt(p->fd, SOL_SOCKET, SO_TYPE, &type, &sz)) == 0 &&
        sz == sizeof type && type == SOCK_DGRAM) {
      if ((dev = malloc(sizeof *dev)) == NULL) {
        log_Printf(LogWARN, "%s: Cannot allocate a udp device: %s\n",
                   p->link.name, strerror(errno));
d294 17
a310 9
      /* We can't getpeername().... */
      dev->connected = UDP_MAYBEUNCONNECTED;

      log_Printf(LogPHASE, "%s: Link is a udp socket\n", p->link.name);

      if (p->link.lcp.cfg.openmode != OPEN_PASSIVE) {
        log_Printf(LogPHASE, "%s:   Changing openmode to PASSIVE\n",
                   p->link.name);
        p->link.lcp.cfg.openmode = OPEN_PASSIVE;
@


1.7
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: udp.c,v 1.6 2000/01/07 03:26:56 brian Exp $
d62 5
d70 1
a70 1
  unsigned connected : 1;	/* Have we connect()d ? */
d85 1
d87 18
a104 2
  if (dev->connected)
    return write(p->fd, v, n);
d106 1
a106 2
  return sendto(p->fd, v, n, 0, (struct sockaddr *)&dev->sock,
                sizeof dev->sock);
d115 1
a115 1
  if (dev->connected)
d235 1
a235 1
      dev->connected = 1;
d291 2
a292 2
      /* We can't getpeername().... hence we stay un-connect()ed */
      dev->connected = 0;
@


1.6
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: udp.c,v 1.5 1999/07/15 02:10:32 brian Exp $
@


1.5
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d26 1
a26 1
 *	$Id: udp.c,v 1.3 1999/06/05 21:36:04 brian Exp $
a47 1
#include "sync.h"
d119 1
a119 1
               int maxiov, pid_t newpid)
d135 3
d152 1
a152 1
               int maxiov)
d236 1
a236 1
    if ((cp = strchr(p->name.full, ':')) != NULL) {
d245 2
a246 1
      if (svc)
d248 1
d286 2
@


1.4
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d48 1
a135 1
  NULL,
@


1.3
log
@Correct the way ppp transfers links on the server side in MP
mode by padding out the ``struct device'' to the maximum
device size.
Bump the ppp version number to indicate the transfer format
change.

This should make MP over tty and udp devices functional again.
@
text
@d26 1
a26 1
 *	$Id: udp.c,v 1.2 1999/05/24 16:39:19 brian Exp $
a47 1
#include "sync.h"
d135 1
@


1.2
log
@Correct the ``ignoring sync/async'' warnings so that they show
up with the correct device type.
Reassign the correct tcpdevice or execdevice after transfering
a link in MP server mode.
@
text
@d26 1
a26 1
 *	$Id: udp.c,v 1.1 1999/05/12 10:03:55 brian Exp $
d39 1
d60 1
d71 6
d119 1
a119 1
udp_device2iov(struct physical *p, struct iovec *iov, int *niov,
d122 8
a129 2
  iov[*niov].iov_base = p ? p->handler : malloc(sizeof(struct udpdevice));
  iov[*niov].iov_len = sizeof(struct udpdevice);
d154 7
@


1.1
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d26 1
a26 1
 *	$Id: tcp.c,v 1.1 1999/05/08 11:07:45 brian Exp $
a137 2
  struct device *dev;

d139 1
a139 1
    /* It's one of ours !  Let's create the device */
a140 1
    dev = (struct device *)iov[(*niov)++].iov_base;
d142 1
a142 2
    memcpy(dev, &baseudpdevice, sizeof *dev);
    /* Remember, there's really more than (sizeof *dev) there */
d144 3
a146 3
    physical_SetupStack(p, PHYSICAL_FORCE_SYNC);
  } else
    dev = NULL;
d148 1
a148 1
  return dev;
d260 1
a260 1
    physical_SetupStack(p, PHYSICAL_FORCE_SYNC);
@

