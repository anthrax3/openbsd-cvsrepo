head	1.49;
access;
symbols
	OPENBSD_5_5:1.48.0.24
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.48.0.20
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.18
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.16
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.14
	OPENBSD_5_0:1.48.0.12
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.10
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.8
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.48.0.4
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.48.0.6
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.48.0.2
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.47.0.14
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.12
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.47.0.10
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.47.0.8
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.47.0.6
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.47.0.4
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.47.0.2
	OPENBSD_3_8_BASE:1.47
	OPENBSD_3_7:1.43.0.8
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.43.0.6
	OPENBSD_3_6_BASE:1.43
	OPENBSD_3_5:1.43.0.4
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	OPENBSD_3_3:1.42.0.4
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.42.0.2
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.40.0.2
	OPENBSD_3_1_BASE:1.40
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9_BASE:1.34
	OPENBSD_2_9:1.34.0.2
	OPENBSD_2_8:1.32.0.2
	OPENBSD_2_8_BASE:1.32
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.49
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.48;

1.48
date	2008.10.02.23.19.19;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.18.22.51.03;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.17.20.24.45;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.17.19.13.24;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.06.13.56.00;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2003.04.07.23.58.53;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.04.10.17.40;	author brian;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.24.10.01.12;	author brian;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.03.22.23.56;	author brian;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.04.16.09.28;	author brian;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.04.01.14.24;	author brian;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.02.00.54.33;	author brian;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.19.11.06.32;	author brian;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.30;

1.30
date	2000.04.07.23.46.39;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.02.01.36.22;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.27.01.38.25;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.27.01.34.04;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	2000.02.27.00.21.07;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.07.03.26.53;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	99.08.05.10.32.13;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	99.06.18.13.49.19;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	99.06.10.09.06.27;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	99.05.12.10.03.50;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	99.05.08.11.06.34;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	99.04.19.16.59.39;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	99.03.04.17.42.25;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	99.02.26.21.28.21;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	99.02.25.12.07.23;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	99.02.18.00.50.45;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.02.17.02.11.34;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.02.11.10.14.50;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.02.06.03.22.34;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.02.02.09.49.57;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.02.01.13.50.27;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.01.20.18.07.11;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.01.13.17.39.57;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.01.08.17.26.45;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	98.12.15.19.16.30;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.12.10.18.40.56;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.10.29.02.21.44;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.19;	author brian;	state Exp;
branches;
next	;


desc
@@


1.49
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1998 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: datalink.c,v 1.48 2008/10/02 23:19:19 deraadt Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/uio.h>
#include <termios.h>

#include "layer.h"
#include "mbuf.h"
#include "log.h"
#include "defs.h"
#include "timer.h"
#include "fsm.h"
#include "descriptor.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "async.h"
#include "throughput.h"
#include "ccp.h"
#include "link.h"
#include "physical.h"
#include "iplist.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "chat.h"
#include "auth.h"
#include "prompt.h"
#include "proto.h"
#include "pap.h"
#include "chap.h"
#include "command.h"
#include "cbcp.h"
#include "datalink.h"

static void datalink_LoginDone(struct datalink *);
static void datalink_NewState(struct datalink *, int);
static char *datalink_NextName(struct datalink *);

static void
datalink_OpenTimeout(void *v)
{
  struct datalink *dl = (struct datalink *)v;

  timer_Stop(&dl->dial.timer);
  if (dl->state == DATALINK_OPENING)
    log_Printf(LogCHAT, "%s: Redial timer expired.\n", dl->name);
}

static int
datalink_StartDialTimer(struct datalink *dl, int Timeout)
{
  int result = Timeout;

  timer_Stop(&dl->dial.timer);
  if (Timeout < 0)
    result = (random() % DIAL_TIMEOUT) + 1;
  dl->dial.timer.load = result ? result * SECTICKS : 1;
  dl->dial.timer.func = datalink_OpenTimeout;
  dl->dial.timer.name = "dial";
  dl->dial.timer.arg = dl;
  timer_Start(&dl->dial.timer);
  if (dl->state == DATALINK_OPENING)
    log_Printf(LogPHASE, "%s: Enter pause (%d) for redialing.\n",
               dl->name, result);
  return result;
}

static void
datalink_HangupDone(struct datalink *dl)
{
  if (dl->physical->type == PHYS_DEDICATED && !dl->bundle->CleaningUp &&
      dl->physical->fd != -1) {
    /* Don't close our device if the link is dedicated */
    datalink_LoginDone(dl);
    return;
  }

  chat_Finish(&dl->chat);
  physical_Close(dl->physical);
  dl->phone.chosen = "N/A";

  if (dl->cbcp.required) {
    log_Printf(LogPHASE, "Call peer back on %s\n", dl->cbcp.fsm.phone);
    dl->cfg.callback.opmask = 0;
    strncpy(dl->cfg.phone.list, dl->cbcp.fsm.phone,
            sizeof dl->cfg.phone.list - 1);
    dl->cfg.phone.list[sizeof dl->cfg.phone.list - 1] = '\0';
    dl->phone.alt = dl->phone.next = NULL;
    dl->reconnect_tries = dl->cfg.reconnect.max;
    dl->dial.tries = dl->cfg.dial.max;
    dl->dial.incs = 0;
    dl->script.run = 1;
    dl->script.packetmode = 1;
    if (!physical_SetMode(dl->physical, PHYS_BACKGROUND))
      log_Printf(LogERROR, "Oops - can't change mode to BACKGROUND (gulp) !\n");
    bundle_LinksRemoved(dl->bundle);
    /* if dial.timeout is < 0 (random), we don't override fsm.delay */
    if (dl->cbcp.fsm.delay < dl->cfg.dial.timeout)
      dl->cbcp.fsm.delay = dl->cfg.dial.timeout;
    datalink_StartDialTimer(dl, dl->cbcp.fsm.delay);
    cbcp_Down(&dl->cbcp);
    datalink_NewState(dl, DATALINK_OPENING);
    if (bundle_Phase(dl->bundle) == PHASE_DEAD ||
        bundle_Phase(dl->bundle) == PHASE_TERMINATE)
      bundle_NewPhase(dl->bundle, PHASE_ESTABLISH);
  } else if (dl->bundle->CleaningUp ||
      (dl->physical->type == PHYS_DIRECT) ||
      ((!dl->dial.tries || (dl->dial.tries < 0 && !dl->reconnect_tries)) &&
       !(dl->physical->type & (PHYS_DDIAL|PHYS_DEDICATED)))) {
    datalink_NewState(dl, DATALINK_CLOSED);
    dl->dial.tries = -1;
    dl->dial.incs = 0;
    dl->reconnect_tries = 0;
    bundle_LinkClosed(dl->bundle, dl);
    if (!dl->bundle->CleaningUp &&
        !(dl->physical->type & (PHYS_DIRECT|PHYS_BACKGROUND|PHYS_FOREGROUND)))
      datalink_StartDialTimer(dl, datalink_GetDialTimeout(dl));
  } else {
    datalink_NewState(dl, DATALINK_OPENING);
    if (bundle_Phase(dl->bundle) == PHASE_DEAD ||
        bundle_Phase(dl->bundle) == PHASE_TERMINATE)
      bundle_NewPhase(dl->bundle, PHASE_ESTABLISH);
    if (dl->dial.tries < 0) {
      datalink_StartDialTimer(dl, dl->cfg.reconnect.timeout);
      dl->dial.tries = dl->cfg.dial.max;
      dl->dial.incs = 0;
      dl->reconnect_tries--;
      log_Printf(LogCHAT, "%s: Reconnect try %d of %d\n",
                 dl->name, dl->cfg.reconnect.max - dl->reconnect_tries,
                 dl->cfg.reconnect.max);
      bundle_Notify(dl->bundle, EX_RECONNECT);
    } else {
      if (dl->phone.next == NULL)
        datalink_StartDialTimer(dl, datalink_GetDialTimeout(dl));
      else
        datalink_StartDialTimer(dl, dl->cfg.dial.next_timeout);
      bundle_Notify(dl->bundle, EX_REDIAL);
    }
  }
}

const char *
datalink_ChoosePhoneNumber(struct datalink *dl)
{
  char *phone;

  if (dl->phone.alt == NULL) {
    if (dl->phone.next == NULL) {
      strncpy(dl->phone.list, dl->cfg.phone.list, sizeof dl->phone.list - 1);
      dl->phone.list[sizeof dl->phone.list - 1] = '\0';
      if (*dl->phone.list == '\0')
        return "";
      dl->phone.next = dl->phone.list;
    }
    dl->phone.alt = strsep(&dl->phone.next, ":");
  }
  phone = strsep(&dl->phone.alt, "|");
  dl->phone.chosen = *phone ? phone : "[NONE]";
  if (*phone)
    log_Printf(LogCHAT, "Phone: %s\n", phone);
  return phone;
}

static void
datalink_LoginDone(struct datalink *dl)
{
  chat_Finish(&dl->chat);

  if (!dl->script.packetmode) {
    dl->dial.tries = -1;
    dl->dial.incs = 0;
    datalink_NewState(dl, DATALINK_READY);
  } else if (!physical_Raw(dl->physical)) {
    dl->dial.tries = 0;
    log_Printf(LogWARN, "datalink_LoginDone: Not connected.\n");
    if (dl->script.run) {
      datalink_NewState(dl, DATALINK_LOGOUT);
      if (!chat_Setup(&dl->chat, dl->cfg.script.logout, NULL))
        log_Printf(LogWARN, "Invalid logout script\n");
    } else {
      physical_StopDeviceTimer(dl->physical);
      if (dl->physical->type == PHYS_DEDICATED)
        /* force a redial timeout */
        physical_Close(dl->physical);
      datalink_HangupDone(dl);
    }
  } else {
    dl->dial.tries = -1;
    dl->dial.incs = 0;

    hdlc_Init(&dl->physical->hdlc, &dl->physical->link.lcp);
    async_Setup(&dl->physical->async);

    lcp_Setup(&dl->physical->link.lcp, dl->state == DATALINK_READY ?
              0 : dl->physical->link.lcp.cfg.openmode);
    ccp_Setup(&dl->physical->link.ccp);

    datalink_NewState(dl, DATALINK_LCP);
    fsm_Up(&dl->physical->link.lcp.fsm);
    fsm_Open(&dl->physical->link.lcp.fsm);
  }
}

static int
datalink_UpdateSet(struct fdescriptor *d, fd_set *r, fd_set *w, fd_set *e,
                   int *n)
{
  struct datalink *dl = descriptor2datalink(d);
  int result;

  result = 0;
  switch (dl->state) {
    case DATALINK_CLOSED:
      if ((dl->physical->type & (PHYS_DIRECT|PHYS_DEDICATED|PHYS_BACKGROUND|
                                 PHYS_FOREGROUND|PHYS_DDIAL)) &&
          !dl->bundle->CleaningUp)
        /*
         * Our first time in - DEDICATED & DDIAL never come down, and
         * DIRECT, FOREGROUND & BACKGROUND get deleted when they enter
         * DATALINK_CLOSED.  Go to DATALINK_OPENING via datalink_Up()
         * and fall through.
         */
        datalink_Up(dl, 1, 1);
      else
        break;
      /* FALLTHROUGH */

    case DATALINK_OPENING:
      if (dl->dial.timer.state != TIMER_RUNNING) {
        if (--dl->dial.tries < 0)
          dl->dial.tries = 0;
        if (physical_Open(dl->physical, dl->bundle) >= 0) {
          log_WritePrompts(dl, "%s: Entering terminal mode on %s\r\n"
                           "Type `~?' for help\r\n", dl->name,
                           dl->physical->name.full);
          if (dl->script.run) {
            datalink_NewState(dl, DATALINK_DIAL);
            if (!chat_Setup(&dl->chat, dl->cfg.script.dial,
                            *dl->cfg.script.dial ?
                            datalink_ChoosePhoneNumber(dl) : ""))
              log_Printf(LogWARN, "Invalid dial script\n");
            if (!(dl->physical->type & (PHYS_DDIAL|PHYS_DEDICATED)) &&
                dl->cfg.dial.max)
              log_Printf(LogCHAT, "%s: Dial attempt %u of %d\n",
                        dl->name, dl->cfg.dial.max - dl->dial.tries,
                        dl->cfg.dial.max);
          } else
            datalink_NewState(dl, DATALINK_CARRIER);
          return datalink_UpdateSet(d, r, w, e, n);
        } else {
          if (!(dl->physical->type & (PHYS_DDIAL|PHYS_DEDICATED)) &&
              dl->cfg.dial.max)
            log_Printf(LogCHAT, "Failed to open device (attempt %u of %d)\n",
                       dl->cfg.dial.max - dl->dial.tries, dl->cfg.dial.max);
          else
            log_Printf(LogCHAT, "Failed to open device\n");

          if (dl->bundle->CleaningUp ||
              (!(dl->physical->type & (PHYS_DDIAL|PHYS_DEDICATED)) &&
               dl->cfg.dial.max && dl->dial.tries == 0)) {
            datalink_NewState(dl, DATALINK_CLOSED);
            dl->reconnect_tries = 0;
            dl->dial.tries = -1;
            log_WritePrompts(dl, "Failed to open %s\n",
                             dl->physical->name.full);
            bundle_LinkClosed(dl->bundle, dl);
          }
          if (!dl->bundle->CleaningUp) {
            int timeout;

            timeout = datalink_StartDialTimer(dl, datalink_GetDialTimeout(dl));
            bundle_Notify(dl->bundle, EX_REDIAL);
            log_WritePrompts(dl, "Failed to open %s, pause %d seconds\n",
                             dl->physical->name.full, timeout);
          }
        }
      }
      break;

    case DATALINK_CARRIER:
      /* Wait for carrier on the device */
      switch (physical_AwaitCarrier(dl->physical)) {
        case CARRIER_PENDING:
          log_Printf(LogDEBUG, "Waiting for carrier\n");
          return 0;	/* A device timer is running to wake us up again */

        case CARRIER_OK:
          if (dl->script.run) {
            datalink_NewState(dl, DATALINK_LOGIN);
            if (!chat_Setup(&dl->chat, dl->cfg.script.login, NULL))
              log_Printf(LogWARN, "Invalid login script\n");
          } else
            datalink_LoginDone(dl);
          return datalink_UpdateSet(d, r, w, e, n);

        case CARRIER_LOST:
          physical_Offline(dl->physical);	/* Is this required ? */
          if (dl->script.run) {
            datalink_NewState(dl, DATALINK_HANGUP);
            if (!chat_Setup(&dl->chat, dl->cfg.script.hangup, NULL))
              log_Printf(LogWARN, "Invalid hangup script\n");
            return datalink_UpdateSet(d, r, w, e, n);
          } else {
            datalink_HangupDone(dl);
            return 0;	/* Maybe bundle_CleanDatalinks() has something to do */
          }
      }

    case DATALINK_HANGUP:
    case DATALINK_DIAL:
    case DATALINK_LOGOUT:
    case DATALINK_LOGIN:
      result = descriptor_UpdateSet(&dl->chat.desc, r, w, e, n);
      switch (dl->chat.state) {
        case CHAT_DONE:
          /* script succeeded */
          switch(dl->state) {
            case DATALINK_HANGUP:
              datalink_HangupDone(dl);
              break;
            case DATALINK_DIAL:
              datalink_NewState(dl, DATALINK_CARRIER);
              return datalink_UpdateSet(d, r, w, e, n);
            case DATALINK_LOGOUT:
              datalink_NewState(dl, DATALINK_HANGUP);
              physical_Offline(dl->physical);
              if (!chat_Setup(&dl->chat, dl->cfg.script.hangup, NULL))
                log_Printf(LogWARN, "Invalid hangup script\n");
              return datalink_UpdateSet(d, r, w, e, n);
            case DATALINK_LOGIN:
              dl->phone.alt = NULL;
              datalink_LoginDone(dl);
              return datalink_UpdateSet(d, r, w, e, n);
          }
          break;
        case CHAT_FAILED:
          /* Going down - script failed */
          log_Printf(LogWARN, "Chat script failed\n");
          switch(dl->state) {
            case DATALINK_HANGUP:
              datalink_HangupDone(dl);
              break;
            case DATALINK_DIAL:
            case DATALINK_LOGOUT:
            case DATALINK_LOGIN:
              datalink_NewState(dl, DATALINK_HANGUP);
              physical_Offline(dl->physical);
              if (!chat_Setup(&dl->chat, dl->cfg.script.hangup, NULL))
                log_Printf(LogWARN, "Invalid hangup script\n");
              return datalink_UpdateSet(d, r, w, e, n);
          }
          break;
      }
      break;

    case DATALINK_READY:
    case DATALINK_LCP:
    case DATALINK_AUTH:
    case DATALINK_CBCP:
    case DATALINK_OPEN:
      result = descriptor_UpdateSet(&dl->chap.desc, r, w, e, n) +
               descriptor_UpdateSet(&dl->physical->desc, r, w, e, n);
      break;
  }
  return result;
}

int
datalink_RemoveFromSet(struct datalink *dl, fd_set *r, fd_set *w, fd_set *e)
{
  return physical_RemoveFromSet(dl->physical, r, w, e);
}

static int
datalink_IsSet(struct fdescriptor *d, const fd_set *fdset)
{
  struct datalink *dl = descriptor2datalink(d);

  switch (dl->state) {
    case DATALINK_CLOSED:
    case DATALINK_OPENING:
      break;

    case DATALINK_HANGUP:
    case DATALINK_DIAL:
    case DATALINK_LOGOUT:
    case DATALINK_LOGIN:
      return descriptor_IsSet(&dl->chat.desc, fdset);

    case DATALINK_READY:
    case DATALINK_LCP:
    case DATALINK_AUTH:
    case DATALINK_CBCP:
    case DATALINK_OPEN:
      return descriptor_IsSet(&dl->chap.desc, fdset) ? 1 :
             descriptor_IsSet(&dl->physical->desc, fdset);
  }
  return 0;
}

static void
datalink_Read(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  struct datalink *dl = descriptor2datalink(d);

  switch (dl->state) {
    case DATALINK_CLOSED:
    case DATALINK_OPENING:
      break;

    case DATALINK_HANGUP:
    case DATALINK_DIAL:
    case DATALINK_LOGOUT:
    case DATALINK_LOGIN:
      descriptor_Read(&dl->chat.desc, bundle, fdset);
      break;

    case DATALINK_READY:
    case DATALINK_LCP:
    case DATALINK_AUTH:
    case DATALINK_CBCP:
    case DATALINK_OPEN:
      if (descriptor_IsSet(&dl->chap.desc, fdset))
        descriptor_Read(&dl->chap.desc, bundle, fdset);
      if (descriptor_IsSet(&dl->physical->desc, fdset))
        descriptor_Read(&dl->physical->desc, bundle, fdset);
      break;
  }
}

static int
datalink_Write(struct fdescriptor *d, struct bundle *bundle,
               const fd_set *fdset)
{
  struct datalink *dl = descriptor2datalink(d);
  int result = 0;

  switch (dl->state) {
    case DATALINK_CLOSED:
    case DATALINK_OPENING:
      break;

    case DATALINK_HANGUP:
    case DATALINK_DIAL:
    case DATALINK_LOGOUT:
    case DATALINK_LOGIN:
      if ((result = descriptor_Write(&dl->chat.desc, bundle, fdset)) == -1) {
        datalink_ComeDown(dl, CLOSE_NORMAL);
        result = 0;
      }
      break;

    case DATALINK_READY:
    case DATALINK_LCP:
    case DATALINK_AUTH:
    case DATALINK_CBCP:
    case DATALINK_OPEN:
      if (descriptor_IsSet(&dl->chap.desc, fdset))
        switch (descriptor_Write(&dl->chap.desc, bundle, fdset)) {
        case -1:
          datalink_ComeDown(dl, CLOSE_NORMAL);
          break;
        case 1:
          result++;
        }
      if (descriptor_IsSet(&dl->physical->desc, fdset))
        switch (descriptor_Write(&dl->physical->desc, bundle, fdset)) {
        case -1:
          datalink_ComeDown(dl, CLOSE_NORMAL);
          break;
        case 1:
          result++;
        }
      break;
  }

  return result;
}

void
datalink_ComeDown(struct datalink *dl, int how)
{
  int stayonline;

  if (how == CLOSE_LCP)
    datalink_DontHangup(dl);
  else if (how == CLOSE_STAYDOWN)
    datalink_StayDown(dl);

  stayonline = dl->stayonline;
  dl->stayonline = 0;

  if (dl->state >= DATALINK_READY && stayonline) {
    physical_StopDeviceTimer(dl->physical);
    datalink_NewState(dl, DATALINK_READY);
  } else if (dl->state != DATALINK_CLOSED && dl->state != DATALINK_HANGUP) {
    physical_Offline(dl->physical);
    if (dl->script.run && dl->state != DATALINK_OPENING) {
      if (dl->state == DATALINK_LOGOUT) {
        datalink_NewState(dl, DATALINK_HANGUP);
        if (!chat_Setup(&dl->chat, dl->cfg.script.hangup, NULL))
          log_Printf(LogWARN, "Invalid hangup script\n");
      } else {
        datalink_NewState(dl, DATALINK_LOGOUT);
        if (!chat_Setup(&dl->chat, dl->cfg.script.logout, NULL))
          log_Printf(LogWARN, "Invalid logout script\n");
      }
    } else
      datalink_HangupDone(dl);
  }
}

static void
datalink_LayerStart(void *v, struct fsm *fp)
{
  /* The given FSM is about to start up ! */
  struct datalink *dl = (struct datalink *)v;

  if (fp->proto == PROTO_LCP)
    (*dl->parent->LayerStart)(dl->parent->object, fp);
}

static void
datalink_LayerUp(void *v, struct fsm *fp)
{
  /* The given fsm is now up */
  struct datalink *dl = (struct datalink *)v;
  struct lcp *lcp = &dl->physical->link.lcp;

  if (fp->proto == PROTO_LCP) {
    datalink_GotAuthname(dl, "");
    lcp->auth_ineed = lcp->want_auth;
    lcp->auth_iwait = lcp->his_auth;
    if (lcp->his_auth || lcp->want_auth) {
      if (bundle_Phase(dl->bundle) != PHASE_NETWORK)
        bundle_NewPhase(dl->bundle, PHASE_AUTHENTICATE);
      log_Printf(LogPHASE, "%s: his = %s, mine = %s\n", dl->name,
                Auth2Nam(lcp->his_auth, lcp->his_authtype),
                Auth2Nam(lcp->want_auth, lcp->want_authtype));
      if (lcp->his_auth == PROTO_PAP)
        auth_StartReq(&dl->pap);
      if (lcp->want_auth == PROTO_CHAP)
        auth_StartReq(&dl->chap.auth);
    } else
      datalink_AuthOk(dl);
  } else if (fp->proto == PROTO_CCP)
    (*dl->parent->LayerUp)(dl->parent->object, &dl->physical->link.ccp.fsm);
}

static void
datalink_AuthReInit(struct datalink *dl)
{
  auth_StopTimer(&dl->pap);
  auth_StopTimer(&dl->chap.auth);
  chap_ReInit(&dl->chap);
}

void
datalink_GotAuthname(struct datalink *dl, const char *name)
{
  strncpy(dl->peer.authname, name, sizeof dl->peer.authname - 1);
  dl->peer.authname[sizeof dl->peer.authname - 1] = '\0';
}

void
datalink_NCPUp(struct datalink *dl)
{
  int ccpok = ccp_SetOpenMode(&dl->physical->link.ccp);

  if (dl->physical->link.lcp.want_mrru && dl->physical->link.lcp.his_mrru) {
    /* we've authenticated in multilink mode ! */
    switch (mp_Up(&dl->bundle->ncp.mp, dl)) {
      case MP_LINKSENT:
        /* We've handed the link off to another ppp (well, we will soon) ! */
        return;
      case MP_UP:
        /* First link in the bundle */
        auth_Select(dl->bundle, dl->peer.authname);
        bundle_CalculateBandwidth(dl->bundle);
        /* FALLTHROUGH */
      case MP_ADDED:
        /* We're in multilink mode ! */
        dl->physical->link.ccp.fsm.open_mode = OPEN_PASSIVE;	/* override */
        bundle_CalculateBandwidth(dl->bundle);
        break;
      case MP_FAILED:
        datalink_AuthNotOk(dl);
        return;
    }
  } else if (bundle_Phase(dl->bundle) == PHASE_NETWORK) {
    log_Printf(LogPHASE, "%s: Already in NETWORK phase\n", dl->name);
    datalink_NewState(dl, DATALINK_OPEN);
    bundle_CalculateBandwidth(dl->bundle);
    (*dl->parent->LayerUp)(dl->parent->object, &dl->physical->link.lcp.fsm);
    return;
  } else {
    dl->bundle->ncp.mp.peer = dl->peer;
    ncp_SetLink(&dl->bundle->ncp, &dl->physical->link);
    auth_Select(dl->bundle, dl->peer.authname);
  }

  if (ccpok) {
    fsm_Up(&dl->physical->link.ccp.fsm);
    fsm_Open(&dl->physical->link.ccp.fsm);
  }
  datalink_NewState(dl, DATALINK_OPEN);
  bundle_NewPhase(dl->bundle, PHASE_NETWORK);
  (*dl->parent->LayerUp)(dl->parent->object, &dl->physical->link.lcp.fsm);
}

void
datalink_CBCPComplete(struct datalink *dl)
{
  datalink_NewState(dl, DATALINK_LCP);
  datalink_AuthReInit(dl);
  fsm_Close(&dl->physical->link.lcp.fsm);
}

void
datalink_CBCPFailed(struct datalink *dl)
{
  cbcp_Down(&dl->cbcp);
  datalink_CBCPComplete(dl);
}

void
datalink_AuthOk(struct datalink *dl)
{
  if ((dl->physical->link.lcp.his_callback.opmask &
       CALLBACK_BIT(CALLBACK_CBCP) ||
       dl->physical->link.lcp.want_callback.opmask &
       CALLBACK_BIT(CALLBACK_CBCP)) &&
      !(dl->physical->link.lcp.want_callback.opmask &
        CALLBACK_BIT(CALLBACK_AUTH))) {
    /* We must have agreed CBCP if AUTH isn't there any more */
    datalink_NewState(dl, DATALINK_CBCP);
    cbcp_Up(&dl->cbcp);
  } else if (dl->physical->link.lcp.want_callback.opmask) {
    /* It's not CBCP */
    log_Printf(LogPHASE, "%s: Shutdown and await peer callback\n", dl->name);
    datalink_NewState(dl, DATALINK_LCP);
    datalink_AuthReInit(dl);
    fsm_Close(&dl->physical->link.lcp.fsm);
  } else
    switch (dl->physical->link.lcp.his_callback.opmask) {
      case 0:
        datalink_NCPUp(dl);
        break;

      case CALLBACK_BIT(CALLBACK_AUTH):
        auth_SetPhoneList(dl->peer.authname, dl->cbcp.fsm.phone,
                          sizeof dl->cbcp.fsm.phone);
        if (*dl->cbcp.fsm.phone == '\0' || !strcmp(dl->cbcp.fsm.phone, "*")) {
          log_Printf(LogPHASE, "%s: %s cannot be called back\n", dl->name,
                     dl->peer.authname);
          *dl->cbcp.fsm.phone = '\0';
        } else {
          char *ptr = strchr(dl->cbcp.fsm.phone, ',');
          if (ptr)
            *ptr = '\0';	/* Call back on the first number */
          log_Printf(LogPHASE, "%s: Calling peer back on %s\n", dl->name,
                     dl->cbcp.fsm.phone);
          dl->cbcp.required = 1;
        }
        dl->cbcp.fsm.delay = 0;
        datalink_NewState(dl, DATALINK_LCP);
        datalink_AuthReInit(dl);
        fsm_Close(&dl->physical->link.lcp.fsm);
        break;

      case CALLBACK_BIT(CALLBACK_E164):
        strncpy(dl->cbcp.fsm.phone, dl->physical->link.lcp.his_callback.msg,
                sizeof dl->cbcp.fsm.phone - 1);
        dl->cbcp.fsm.phone[sizeof dl->cbcp.fsm.phone - 1] = '\0';
        log_Printf(LogPHASE, "%s: Calling peer back on %s\n", dl->name,
                   dl->cbcp.fsm.phone);
        dl->cbcp.required = 1;
        dl->cbcp.fsm.delay = 0;
        datalink_NewState(dl, DATALINK_LCP);
        datalink_AuthReInit(dl);
        fsm_Close(&dl->physical->link.lcp.fsm);
        break;

      default:
        log_Printf(LogPHASE, "%s: Oops - Should have NAK'd peer callback !\n",
                   dl->name);
        datalink_NewState(dl, DATALINK_LCP);
        datalink_AuthReInit(dl);
        fsm_Close(&dl->physical->link.lcp.fsm);
        break;
    }
}

void
datalink_AuthNotOk(struct datalink *dl)
{
  datalink_NewState(dl, DATALINK_LCP);
  datalink_AuthReInit(dl);
  fsm_Close(&dl->physical->link.lcp.fsm);
}

static void
datalink_LayerDown(void *v, struct fsm *fp)
{
  /* The given FSM has been told to come down */
  struct datalink *dl = (struct datalink *)v;

  if (fp->proto == PROTO_LCP) {
    switch (dl->state) {
      case DATALINK_OPEN:
        peerid_Init(&dl->peer);
        fsm2initial(&dl->physical->link.ccp.fsm);
        datalink_NewState(dl, DATALINK_LCP);  /* before parent TLD */
        (*dl->parent->LayerDown)(dl->parent->object, fp);
        /* FALLTHROUGH (just in case) */

      case DATALINK_CBCP:
        if (!dl->cbcp.required)
          cbcp_Down(&dl->cbcp);
        /* FALLTHROUGH (just in case) */

      case DATALINK_AUTH:
        timer_Stop(&dl->pap.authtimer);
        timer_Stop(&dl->chap.auth.authtimer);
    }
    datalink_NewState(dl, DATALINK_LCP);
    datalink_AuthReInit(dl);
  }
}

static void
datalink_LayerFinish(void *v, struct fsm *fp)
{
  /* The given fsm is now down */
  struct datalink *dl = (struct datalink *)v;

  if (fp->proto == PROTO_LCP) {
    fsm2initial(fp);
    (*dl->parent->LayerFinish)(dl->parent->object, fp);
    datalink_ComeDown(dl, CLOSE_NORMAL);
  } else if (fp->state == ST_CLOSED && fp->open_mode == OPEN_PASSIVE)
    fsm_Open(fp);		/* CCP goes to ST_STOPPED */
}

struct datalink *
datalink_Create(const char *name, struct bundle *bundle, int type)
{
  struct datalink *dl;

  dl = (struct datalink *)malloc(sizeof(struct datalink));
  if (dl == NULL)
    return dl;

  dl->desc.type = DATALINK_DESCRIPTOR;
  dl->desc.UpdateSet = datalink_UpdateSet;
  dl->desc.IsSet = datalink_IsSet;
  dl->desc.Read = datalink_Read;
  dl->desc.Write = datalink_Write;

  dl->state = DATALINK_CLOSED;

  *dl->cfg.script.dial = '\0';
  *dl->cfg.script.login = '\0';
  *dl->cfg.script.logout = '\0';
  *dl->cfg.script.hangup = '\0';
  *dl->cfg.phone.list = '\0';
  *dl->phone.list = '\0';
  dl->phone.next = NULL;
  dl->phone.alt = NULL;
  dl->phone.chosen = "N/A";
  dl->stayonline = 0;
  dl->script.run = 1;
  dl->script.packetmode = 1;
  mp_linkInit(&dl->mp);

  dl->bundle = bundle;
  dl->next = NULL;

  memset(&dl->dial.timer, '\0', sizeof dl->dial.timer);

  dl->dial.tries = 0;
  dl->cfg.dial.max = 1;
  dl->cfg.dial.next_timeout = DIAL_NEXT_TIMEOUT;
  dl->cfg.dial.timeout = DIAL_TIMEOUT;
  dl->cfg.dial.inc = 0;
  dl->cfg.dial.maxinc = 10;

  dl->reconnect_tries = 0;
  dl->cfg.reconnect.max = 0;
  dl->cfg.reconnect.timeout = RECONNECT_TIMEOUT;

  dl->cfg.callback.opmask = 0;
  dl->cfg.cbcp.delay = 0;
  *dl->cfg.cbcp.phone = '\0';
  dl->cfg.cbcp.fsmretry = DEF_FSMRETRY;

  dl->name = strdup(name);
  peerid_Init(&dl->peer);
  dl->parent = &bundle->fsm;
  dl->fsmp.LayerStart = datalink_LayerStart;
  dl->fsmp.LayerUp = datalink_LayerUp;
  dl->fsmp.LayerDown = datalink_LayerDown;
  dl->fsmp.LayerFinish = datalink_LayerFinish;
  dl->fsmp.object = dl;

  if ((dl->physical = physical_Create(dl, type)) == NULL) {
    free(dl->name);
    free(dl);
    return NULL;
  }

  pap_Init(&dl->pap, dl->physical);
  chap_Init(&dl->chap, dl->physical);
  cbcp_Init(&dl->cbcp, dl->physical);

  memset(&dl->chat, '\0', sizeof dl->chat);	/* Force buf{start,end} reset */
  chat_Init(&dl->chat, dl->physical);

  log_Printf(LogPHASE, "%s: Created in %s state\n",
             dl->name, datalink_State(dl));

  return dl;
}

struct datalink *
datalink_Clone(struct datalink *odl, const char *name)
{
  struct datalink *dl;

  dl = (struct datalink *)malloc(sizeof(struct datalink));
  if (dl == NULL)
    return dl;

  dl->desc.type = DATALINK_DESCRIPTOR;
  dl->desc.UpdateSet = datalink_UpdateSet;
  dl->desc.IsSet = datalink_IsSet;
  dl->desc.Read = datalink_Read;
  dl->desc.Write = datalink_Write;

  dl->state = DATALINK_CLOSED;

  memcpy(&dl->cfg, &odl->cfg, sizeof dl->cfg);
  mp_linkInit(&dl->mp);
  *dl->phone.list = '\0';
  dl->phone.next = NULL;
  dl->phone.alt = NULL;
  dl->phone.chosen = "N/A";
  dl->bundle = odl->bundle;
  dl->next = NULL;
  memset(&dl->dial.timer, '\0', sizeof dl->dial.timer);
  dl->dial.tries = 0;
  dl->reconnect_tries = 0;
  dl->name = strdup(name);
  peerid_Init(&dl->peer);
  dl->parent = odl->parent;
  memcpy(&dl->fsmp, &odl->fsmp, sizeof dl->fsmp);
  dl->fsmp.object = dl;

  if ((dl->physical = physical_Create(dl, PHYS_INTERACTIVE)) == NULL) {
    free(dl->name);
    free(dl);
    return NULL;
  }
  pap_Init(&dl->pap, dl->physical);
  dl->pap.cfg = odl->pap.cfg;

  chap_Init(&dl->chap, dl->physical);
  dl->chap.auth.cfg = odl->chap.auth.cfg;

  memcpy(&dl->physical->cfg, &odl->physical->cfg, sizeof dl->physical->cfg);
  memcpy(&dl->physical->link.lcp.cfg, &odl->physical->link.lcp.cfg,
         sizeof dl->physical->link.lcp.cfg);
  memcpy(&dl->physical->link.ccp.cfg, &odl->physical->link.ccp.cfg,
         sizeof dl->physical->link.ccp.cfg);
  memcpy(&dl->physical->async.cfg, &odl->physical->async.cfg,
         sizeof dl->physical->async.cfg);

  cbcp_Init(&dl->cbcp, dl->physical);

  memset(&dl->chat, '\0', sizeof dl->chat);	/* Force buf{start,end} reset */
  chat_Init(&dl->chat, dl->physical);

  log_Printf(LogPHASE, "%s: Cloned in %s state\n",
             dl->name, datalink_State(dl));

  return dl;
}

struct datalink *
datalink_Destroy(struct datalink *dl)
{
  struct datalink *result;

  if (dl->state != DATALINK_CLOSED) {
    log_Printf(LogERROR, "Oops, destroying a datalink in state %s\n",
              datalink_State(dl));
    switch (dl->state) {
      case DATALINK_HANGUP:
      case DATALINK_DIAL:
      case DATALINK_LOGIN:
        chat_Finish(&dl->chat);		/* Gotta blat the timers ! */
        break;
    }
  }

  chat_Destroy(&dl->chat);
  timer_Stop(&dl->dial.timer);
  result = dl->next;
  physical_Destroy(dl->physical);
  free(dl->name);
  free(dl);

  return result;
}

void
datalink_Up(struct datalink *dl, int runscripts, int packetmode)
{
  if (!Enabled(dl->bundle, OPT_FORCE_SCRIPTS) &&
      (dl->physical->type & (PHYS_DIRECT|PHYS_DEDICATED)))
    /* Ignore scripts */
    runscripts = 0;

  switch (dl->state) {
    case DATALINK_CLOSED:
      if (bundle_Phase(dl->bundle) == PHASE_DEAD ||
          bundle_Phase(dl->bundle) == PHASE_TERMINATE)
        bundle_NewPhase(dl->bundle, PHASE_ESTABLISH);
      datalink_NewState(dl, DATALINK_OPENING);
      dl->reconnect_tries =
        dl->physical->type == PHYS_DIRECT ? 0 : dl->cfg.reconnect.max;
      dl->dial.tries = dl->cfg.dial.max;
      dl->script.run = runscripts;
      dl->script.packetmode = packetmode;
      break;

    case DATALINK_OPENING:
      if (!dl->script.run && runscripts)
        dl->script.run = 1;
      /* FALLTHROUGH */

    case DATALINK_DIAL:
    case DATALINK_LOGIN:
    case DATALINK_READY:
      if (!dl->script.packetmode && packetmode) {
        dl->script.packetmode = 1;
        if (dl->state == DATALINK_READY) {
          dl->script.run = 0;
          datalink_NewState(dl, DATALINK_CARRIER);
        }
      }
      break;
  }
}

void
datalink_Close(struct datalink *dl, int how)
{
  /* Please close */
  switch (dl->state) {
    case DATALINK_OPEN:
      peerid_Init(&dl->peer);
      fsm2initial(&dl->physical->link.ccp.fsm);
      /* FALLTHROUGH */

    case DATALINK_CBCP:
    case DATALINK_AUTH:
    case DATALINK_LCP:
      datalink_AuthReInit(dl);
      if (how == CLOSE_LCP)
        datalink_DontHangup(dl);
      else if (how == CLOSE_STAYDOWN)
        datalink_StayDown(dl);
      fsm_Close(&dl->physical->link.lcp.fsm);
      break;

    default:
      datalink_ComeDown(dl, how);
  }
}

void
datalink_Down(struct datalink *dl, int how)
{
  /* Carrier is lost */
  switch (dl->state) {
    case DATALINK_OPEN:
      peerid_Init(&dl->peer);
      fsm2initial(&dl->physical->link.ccp.fsm);
      /* FALLTHROUGH */

    case DATALINK_CBCP:
    case DATALINK_AUTH:
    case DATALINK_LCP:
      fsm2initial(&dl->physical->link.lcp.fsm);
      if (dl->state == DATALINK_OPENING)
        return;			/* we're doing a callback... */
      /* FALLTHROUGH */

    default:
      datalink_ComeDown(dl, how);
  }
}

void
datalink_StayDown(struct datalink *dl)
{
  dl->dial.tries = -1;
  dl->reconnect_tries = 0;
  dl->stayonline = 0;
}

void
datalink_DontHangup(struct datalink *dl)
{
  dl->dial.tries = -1;
  dl->reconnect_tries = 0;
  dl->stayonline = dl->state >= DATALINK_LCP ? 1 : 0;
}

int
datalink_Show(struct cmdargs const *arg)
{
  prompt_Printf(arg->prompt, "Name: %s\n", arg->cx->name);
  prompt_Printf(arg->prompt, " State:              %s\n",
                datalink_State(arg->cx));
  prompt_Printf(arg->prompt, " Peer name:          ");
  if (*arg->cx->peer.authname)
    prompt_Printf(arg->prompt, "%s\n", arg->cx->peer.authname);
  else if (arg->cx->state == DATALINK_OPEN)
    prompt_Printf(arg->prompt, "None requested\n");
  else
    prompt_Printf(arg->prompt, "N/A\n");
  prompt_Printf(arg->prompt, " Discriminator:      %s\n",
                mp_Enddisc(arg->cx->peer.enddisc.class,
                           arg->cx->peer.enddisc.address,
                           arg->cx->peer.enddisc.len));

  prompt_Printf(arg->prompt, "\nDefaults:\n");
  prompt_Printf(arg->prompt, " Phone List:         %s\n",
                arg->cx->cfg.phone.list);
  if (arg->cx->cfg.dial.max)
    prompt_Printf(arg->prompt, " Dial tries:         %d, delay ",
                  arg->cx->cfg.dial.max);
  else
    prompt_Printf(arg->prompt, " Dial tries:         infinite, delay ");
  if (arg->cx->cfg.dial.next_timeout >= 0)
    prompt_Printf(arg->prompt, "%ds/", arg->cx->cfg.dial.next_timeout);
  else
    prompt_Printf(arg->prompt, "random/");
  if (arg->cx->cfg.dial.timeout >= 0)
    prompt_Printf(arg->prompt, "%ds\n", arg->cx->cfg.dial.timeout);
  else
    prompt_Printf(arg->prompt, "random\n");
  prompt_Printf(arg->prompt, " Reconnect tries:    %d, delay ",
                arg->cx->cfg.reconnect.max);
  if (arg->cx->cfg.reconnect.timeout > 0)
    prompt_Printf(arg->prompt, "%ds\n", arg->cx->cfg.reconnect.timeout);
  else
    prompt_Printf(arg->prompt, "random\n");
  prompt_Printf(arg->prompt, " Callback %s ", arg->cx->physical->type ==
                PHYS_DIRECT ?  "accepted: " : "requested:");
  if (!arg->cx->cfg.callback.opmask)
    prompt_Printf(arg->prompt, "none\n");
  else {
    int comma = 0;

    if (arg->cx->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_NONE)) {
      prompt_Printf(arg->prompt, "none");
      comma = 1;
    }
    if (arg->cx->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_AUTH)) {
      prompt_Printf(arg->prompt, "%sauth", comma ? ", " : "");
      comma = 1;
    }
    if (arg->cx->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_E164)) {
      prompt_Printf(arg->prompt, "%sE.164", comma ? ", " : "");
      if (arg->cx->physical->type != PHYS_DIRECT)
        prompt_Printf(arg->prompt, " (%s)", arg->cx->cfg.callback.msg);
      comma = 1;
    }
    if (arg->cx->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_CBCP)) {
      prompt_Printf(arg->prompt, "%scbcp\n", comma ? ", " : "");
      prompt_Printf(arg->prompt, " CBCP:               delay: %ds\n",
                    arg->cx->cfg.cbcp.delay);
      prompt_Printf(arg->prompt, "                     phone: ");
      if (!strcmp(arg->cx->cfg.cbcp.phone, "*")) {
        if (arg->cx->physical->type & PHYS_DIRECT)
          prompt_Printf(arg->prompt, "Caller decides\n");
        else
          prompt_Printf(arg->prompt, "Dialback server decides\n");
      } else
        prompt_Printf(arg->prompt, "%s\n", arg->cx->cfg.cbcp.phone);
      prompt_Printf(arg->prompt, "                     timeout: %lds\n",
                    arg->cx->cfg.cbcp.fsmretry);
    } else
      prompt_Printf(arg->prompt, "\n");
  }

  prompt_Printf(arg->prompt, " Dial Script:        %s\n",
                arg->cx->cfg.script.dial);
  prompt_Printf(arg->prompt, " Login Script:       %s\n",
                arg->cx->cfg.script.login);
  prompt_Printf(arg->prompt, " Logout Script:      %s\n",
                arg->cx->cfg.script.logout);
  prompt_Printf(arg->prompt, " Hangup Script:      %s\n",
                arg->cx->cfg.script.hangup);
  return 0;
}

int
datalink_SetReconnect(struct cmdargs const *arg)
{
  if (arg->argc == arg->argn+2) {
    if (strncasecmp(arg->argv[arg->argn], "random", 6) == 0 &&
       (arg->argv[arg->argn][6] == '\0')) {
      arg->cx->cfg.reconnect.timeout = -1;
      randinit();
    } else {
      arg->cx->cfg.reconnect.timeout = atoi(arg->argv[arg->argn]);
    }
    arg->cx->cfg.reconnect.max = atoi(arg->argv[arg->argn+1]);
    return 0;
  }
  return -1;
}

int
datalink_SetRedial(struct cmdargs const *arg)
{
  const char *sep, *osep;
  int timeout, inc, maxinc, tries;

  if (arg->argc == arg->argn+1 || arg->argc == arg->argn+2) {
    if (strncasecmp(arg->argv[arg->argn], "random", 6) == 0 &&
	(arg->argv[arg->argn][6] == '\0' || arg->argv[arg->argn][6] == '.')) {
      arg->cx->cfg.dial.timeout = -1;
      randinit();
    } else {
      timeout = atoi(arg->argv[arg->argn]);

      if (timeout >= 0)
	arg->cx->cfg.dial.timeout = timeout;
      else {
	log_Printf(LogWARN, "Invalid redial timeout\n");
	return -1;
      }
    }

    sep = strchr(arg->argv[arg->argn], '+');
    if (sep) {
      inc = atoi(++sep);
      osep = sep;
      if (inc >= 0)
        arg->cx->cfg.dial.inc = inc;
      else {
        log_Printf(LogWARN, "Invalid timeout increment\n");
        return -1;
      }
      sep = strchr(sep, '-');
      if (sep) {
        maxinc = atoi(++sep);
        if (maxinc >= 0)
          arg->cx->cfg.dial.maxinc = maxinc;
        else {
          log_Printf(LogWARN, "Invalid maximum timeout increments\n");
          return -1;
        }
      } else {
        /* Default timeout increment */
        arg->cx->cfg.dial.maxinc = 10;
        sep = osep;
      }
    } else {
      /* Default timeout increment & max increment */
      arg->cx->cfg.dial.inc = 0;
      arg->cx->cfg.dial.maxinc = 10;
      sep = arg->argv[arg->argn];
    }

    sep = strchr(sep, '.');
    if (sep) {
      if (strcasecmp(++sep, "random") == 0) {
	arg->cx->cfg.dial.next_timeout = -1;
	randinit();
      } else {
	timeout = atoi(sep);
	if (timeout >= 0)
	  arg->cx->cfg.dial.next_timeout = timeout;
	else {
	  log_Printf(LogWARN, "Invalid next redial timeout\n");
	  return -1;
	}
      }
    } else
      /* Default next timeout */
      arg->cx->cfg.dial.next_timeout = DIAL_NEXT_TIMEOUT;

    if (arg->argc == arg->argn+2) {
      tries = atoi(arg->argv[arg->argn+1]);

      if (tries >= 0) {
	arg->cx->cfg.dial.max = tries;
      } else {
	log_Printf(LogWARN, "Invalid retry value\n");
	return 1;
      }
    }
    return 0;
  }

  return -1;
}

static const char * const states[] = {
  "closed",
  "opening",
  "hangup",
  "dial",
  "carrier",
  "logout",
  "login",
  "ready",
  "lcp",
  "auth",
  "cbcp",
  "open"
};

const char *
datalink_State(struct datalink *dl)
{
  if (dl->state < 0 || dl->state >= sizeof states / sizeof states[0])
    return "unknown";
  return states[dl->state];
}

static void
datalink_NewState(struct datalink *dl, int state)
{
  if (state != dl->state) {
    if (state >= 0 && state < sizeof states / sizeof states[0]) {
      log_Printf(LogPHASE, "%s: %s -> %s\n", dl->name, datalink_State(dl),
                 states[state]);
      dl->state = state;
    } else
      log_Printf(LogERROR, "%s: Can't enter state %d !\n", dl->name, state);
  }
}

struct datalink *
iov2datalink(struct bundle *bundle, struct iovec *iov, int *niov, int maxiov,
             int fd, int *auxfd, int *nauxfd)
{
  struct datalink *dl, *cdl;
  struct fsm_retry copy;
  char *oname, *pname;

  dl = (struct datalink *)iov[(*niov)++].iov_base;
  dl->name = iov[*niov].iov_base;

  if (dl->name[DATALINK_MAXNAME-1]) {
    dl->name[DATALINK_MAXNAME-1] = '\0';
    if (strlen(dl->name) == DATALINK_MAXNAME - 1)
      log_Printf(LogWARN, "Datalink name truncated to \"%s\"\n", dl->name);
  }

  /* Make sure the name is unique ! */
  oname = NULL;
  do {
    for (cdl = bundle->links; cdl; cdl = cdl->next)
      if (!strcasecmp(dl->name, cdl->name)) {
        if ((pname = datalink_NextName(dl)) == NULL) {
	  for ((*niov)--; *niov < maxiov; (*niov)++)
	    free(iov[*niov].iov_base);
	  return NULL;
	} else if (oname)
          free(pname);
        else
          oname = pname;
        break;	/* Keep renaming 'till we have no conflicts */
      }
  } while (cdl);

  if (oname) {
    log_Printf(LogPHASE, "Rename link %s to %s\n", oname, dl->name);
    free(oname);
  } else {
    dl->name = strdup(dl->name);
    free(iov[*niov].iov_base);
  }
  (*niov)++;

  dl->desc.type = DATALINK_DESCRIPTOR;
  dl->desc.UpdateSet = datalink_UpdateSet;
  dl->desc.IsSet = datalink_IsSet;
  dl->desc.Read = datalink_Read;
  dl->desc.Write = datalink_Write;

  mp_linkInit(&dl->mp);
  *dl->phone.list = '\0';
  dl->phone.next = NULL;
  dl->phone.alt = NULL;
  dl->phone.chosen = "N/A";

  dl->bundle = bundle;
  dl->next = NULL;
  memset(&dl->dial.timer, '\0', sizeof dl->dial.timer);
  dl->dial.tries = 0;
  dl->reconnect_tries = 0;
  dl->parent = &bundle->fsm;
  dl->fsmp.LayerStart = datalink_LayerStart;
  dl->fsmp.LayerUp = datalink_LayerUp;
  dl->fsmp.LayerDown = datalink_LayerDown;
  dl->fsmp.LayerFinish = datalink_LayerFinish;
  dl->fsmp.object = dl;

  dl->physical = iov2physical(dl, iov, niov, maxiov, fd, auxfd, nauxfd);

  if (!dl->physical) {
    free(dl->name);
    free(dl);
    dl = NULL;
  } else {
    copy = dl->pap.cfg.fsm;
    pap_Init(&dl->pap, dl->physical);
    dl->pap.cfg.fsm = copy;

    copy = dl->chap.auth.cfg.fsm;
    chap_Init(&dl->chap, dl->physical);
    dl->chap.auth.cfg.fsm = copy;

    cbcp_Init(&dl->cbcp, dl->physical);

    memset(&dl->chat, '\0', sizeof dl->chat);	/* Force buf{start,end} reset */
    chat_Init(&dl->chat, dl->physical);

    log_Printf(LogPHASE, "%s: Transferred in %s state\n",
              dl->name, datalink_State(dl));
  }

  return dl;
}

int
datalink2iov(struct datalink *dl, struct iovec *iov, int *niov, int maxiov,
             int *auxfd, int *nauxfd)
{
  /* If `dl' is NULL, we're allocating before a Fromiov() */
  int link_fd;

  if (dl) {
    timer_Stop(&dl->dial.timer);
    /* The following is purely for the sake of paranoia */
    cbcp_Down(&dl->cbcp);
    timer_Stop(&dl->pap.authtimer);
    timer_Stop(&dl->chap.auth.authtimer);
  }

  if (*niov >= maxiov - 1) {
    log_Printf(LogERROR, "Toiov: No room for datalink !\n");
    if (dl) {
      free(dl->name);
      free(dl);
    }
    return -1;
  }

  iov[*niov].iov_base = (void *)dl;
  iov[(*niov)++].iov_len = sizeof *dl;
  iov[*niov].iov_base = dl ? realloc(dl->name, DATALINK_MAXNAME) : NULL;
  iov[(*niov)++].iov_len = DATALINK_MAXNAME;

  link_fd = physical2iov(dl ? dl->physical : NULL, iov, niov, maxiov, auxfd,
                         nauxfd);

  if (link_fd == -1 && dl) {
    free(dl->name);
    free(dl);
  }

  return link_fd;
}

void
datalink_Rename(struct datalink *dl, const char *name)
{
  free(dl->name);
  dl->physical->link.name = dl->name = strdup(name);
}

static char *
datalink_NextName(struct datalink *dl)
{
  int f, n;
  char *name, *oname;
  size_t len;

  len = strlen(dl->name);
  if ((name = (char *)malloc(len+3)) == NULL) {
    log_Printf(LogERROR, "datalink_NextName: Out of memory !\n");
    return NULL;
  }
  for (f = len - 1; f >= 0; f--)
    if (!isdigit(dl->name[f]))
      break;
  snprintf(name, len+3, "%.*s-", dl->name[f] == '-' ? f : f + 1, dl->name);
  n = strlen(name);
  snprintf(name + n, len+3 - n, "%d", atoi(dl->name + f + 1) + 1);
  oname = dl->name;
  dl->name = name;
  /* our physical link name isn't updated (it probably isn't created yet) */
  return oname;
}

int
datalink_SetMode(struct datalink *dl, int mode)
{
  if (!physical_SetMode(dl->physical, mode))
    return 0;
  if (dl->physical->type & (PHYS_DIRECT|PHYS_DEDICATED))
    dl->script.run = 0;
  if (dl->physical->type == PHYS_DIRECT)
    dl->reconnect_tries = 0;
  if (mode & (PHYS_DDIAL|PHYS_BACKGROUND|PHYS_FOREGROUND) &&
      dl->state <= DATALINK_READY)
    datalink_Up(dl, 1, 1);
  return 1;
}

int
datalink_GetDialTimeout(struct datalink *dl)
{
  int result = dl->cfg.dial.timeout + dl->dial.incs * dl->cfg.dial.inc;

  if (dl->dial.incs < dl->cfg.dial.maxinc)
    dl->dial.incs++;

  return result;
}
@


1.48
log
@Repair "set reconnect random 0" from PR 5368.  This bug report was ignored
since Feb 2007, even though it had a patch.  How did this happen??
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.47 2005/07/18 22:51:03 brad Exp $
@


1.47
log
@Add a ``force-scripts'' option for using chat scripts with -direct and
-dedicated links.

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.46 2005/07/17 20:24:45 brad Exp $
d1161 7
a1167 1
    arg->cx->cfg.reconnect.timeout = atoi(arg->argv[arg->argn]);
@


1.46
log
@Replace various spelling with FALLTHROUGH which is lint()able

From charnier FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.45 2005/07/17 19:13:24 brad Exp $
d965 2
a966 1
  if (dl->physical->type & (PHYS_DIRECT|PHYS_DEDICATED))
@


1.45
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.44 2005/07/06 13:56:00 brad Exp $
d272 1
a272 1
      /* fall through */
d626 1
a626 1
        /* fall through */
d761 1
a761 1
        /* fall through (just in case) */
d766 1
a766 1
        /* fall through (just in case) */
d985 1
a985 1
      /* fall through */
d1009 1
a1009 1
      /* fall through */
d1035 1
a1035 1
      /* fall through */
d1043 1
a1043 1
      /* fall through */
@


1.44
log
@Add a bunch of malloc() return checks

From brian FreeBSD

ok deraadt@@ tdeval@@
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.43 2003/04/07 23:58:53 deraadt Exp $
d37 1
@


1.43
log
@more string cleaning; ok tedu
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.42 2002/06/15 08:02:00 brian Exp $
d82 1
d1295 1
a1295 1
  char *oname;
d1311 6
a1316 2
        if (oname)
          free(datalink_NextName(dl));
d1318 1
a1318 1
          oname = datalink_NextName(dl);
d1430 1
a1430 1
char *
d1438 4
a1441 1
  name = (char *)malloc(len+3);
@


1.42
log
@Tidy up end of line whitespace
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.41 2002/05/16 01:13:39 brian Exp $
d1430 1
d1432 3
a1434 3
  n = strlen(dl->name);
  name = (char *)malloc(n+3);
  for (f = n - 1; f >= 0; f--)
d1437 3
a1439 2
  n = sprintf(name, "%.*s-", dl->name[f] == '-' ? f : f + 1, dl->name);
  sprintf(name + n, "%d", atoi(dl->name + f + 1) + 1);
@


1.41
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.40 2002/03/31 02:38:49 brian Exp $
d213 1
a213 1
  if (!dl->script.packetmode) { 
d220 1
a220 1
    if (dl->script.run) { 
d342 1
a342 1
          if (dl->script.run) { 
@


1.40
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.39 2002/03/04 10:17:40 brian Exp $
a60 1
#include "ip.h"
@


1.39
log
@Don't blow away ``set escape'' settings when we've completed the
login phase.  Just initialise the correct parts
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.38 2001/10/24 10:01:12 brian Exp $
d492 4
a495 1
      result = descriptor_Write(&dl->chat.desc, bundle, fdset);
d504 7
a510 1
        result += descriptor_Write(&dl->chap.desc, bundle, fdset);
d512 7
a518 1
        result += descriptor_Write(&dl->physical->desc, bundle, fdset);
d525 1
a525 1
static void
@


1.38
log
@Handle ``set reconnect 0 0'' properly in -ddial mode.
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.37 2001/08/19 23:22:17 brian Exp $
d237 1
a237 1
    async_Init(&dl->physical->async);
@


1.37
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.36 2001/07/03 22:23:56 brian Exp $
d100 10
a109 12
  if (Timeout) {
    if (Timeout < 0)
      result = (random() % DIAL_TIMEOUT) + 1;
    dl->dial.timer.load = result * SECTICKS;
    dl->dial.timer.func = datalink_OpenTimeout;
    dl->dial.timer.name = "dial";
    dl->dial.timer.arg = dl;
    timer_Start(&dl->dial.timer);
    if (dl->state == DATALINK_OPENING)
      log_Printf(LogPHASE, "%s: Enter pause (%d) for redialing.\n",
                dl->name, result);
  }
@


1.36
log
@Reduce the interface MTU by 2 when MPPE has been successfully negotiated.

This is necessary because MPPE will combine the protocol id with the
payload received on the tun interface, encrypt it, then prepend its
own protocol id, effectively increasing the payload by two bytes.
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.35 2001/06/04 16:09:28 brian Exp $
d33 1
d60 2
d68 2
d630 1
a630 1
    ipcp_SetLink(&dl->bundle->ncp.ipcp, &dl->physical->link);
@


1.35
log
@Show the correct dial timeout when a random pause is configured
Understand ipencap traffic properly
Optimise out SIOCIFADDR ioctls that aren't necessary
Handle peers that don't send an initial IFADDR option during IPCP negotiations
Fix markup for the /etc/ttys example
Always use 4 arguments in examples of ``set ifaddr''
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.34 2001/02/04 01:14:24 brian Exp $
d573 2
a574 1
  }
@


1.34
log
@Untangle some cunfusion between the CLOSE_STAYDOWN, CLOSE_LCP and
CLOSE_NORMAL meanings.  CLOSE_NORMAL doesn't change the currently
required state, the others do.  This should stop ppp from entering
DATALINK_READY when LCP shutdown doesn't end up happening cleanly.

Bump our version number to reflect this change.
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.33 2000/11/02 00:54:33 brian Exp $
d96 1
a96 3
    if (Timeout > 0)
      dl->dial.timer.load = Timeout * SECTICKS;
    else {
d98 1
a98 2
      dl->dial.timer.load = result * SECTICKS;
    }
d105 1
a105 1
                dl->name, Timeout);
@


1.33
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.32 2000/07/19 11:06:32 brian Exp $
d513 9
a521 6
  if (how != CLOSE_NORMAL) {
    dl->dial.tries = -1;
    dl->reconnect_tries = 0;
    if (dl->state >= DATALINK_READY && how == CLOSE_LCP)
      dl->stayonline = 1;
  }
d523 1
a523 2
  if (dl->state >= DATALINK_READY && dl->stayonline) {
    dl->stayonline = 0;
d998 4
a1002 6
      if (how != CLOSE_NORMAL) {
        dl->dial.tries = -1;
        dl->reconnect_tries = 0;
        if (how == CLOSE_LCP)
          dl->stayonline = 1;
      }
d1036 1
d1038 1
d1044 3
a1046 2
  if (dl->state >= DATALINK_LCP)
    dl->stayonline = 1;
@


1.32
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.31 2000/06/13 09:57:51 brian Exp $
d477 2
a478 1
datalink_Write(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
@


1.31
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.30 2000/04/07 23:46:39 brian Exp $
a47 1
#include "lcp.h"
d51 1
@


1.30
log
@When running ppp -background, show comfort messages showing
when we're redialing/reconnecting.

While we're here, log redial, reconnect and phone number
announcements to LogCHAT, and reduce some other logging to
LogDEBUG.
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.29 2000/04/02 01:36:22 brian Exp $
d972 4
a975 2
        if (dl->state == DATALINK_READY)
          datalink_LoginDone(dl);
@


1.29
log
@Don't wait for the redial timer before exiting due to the last
background/direct link closing.
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.28 2000/02/27 01:38:25 brian Exp $
d86 1
a86 1
    log_Printf(LogPHASE, "%s: Redial timer expired.\n", dl->name);
d173 4
d182 1
d205 1
a205 1
    log_Printf(LogPHASE, "Phone: %s\n", phone);
d317 1
@


1.28
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: datalink.c,v 1.27 2000/02/27 01:34:04 brian Exp $
d160 2
a161 1
    if (!dl->bundle->CleaningUp)
@


1.27
log
@Fix a bug in end-of-line comment parsing.
Fix callback (don't ``forget'' to call back).
Restructure how we add/remove the address family when
writing/reading the tun device.
Notify the tun device that we've changed PID under FreeBSD.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.26 2000/02/27 00:21:07 brian Exp $
@


1.26
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.25 2000/01/07 03:26:53 brian Exp $
d1014 2
@


1.25
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.24 1999/08/05 10:32:13 brian Exp $
d244 1
a244 1
datalink_UpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e,
d413 1
a413 1
datalink_IsSet(struct descriptor *d, const fd_set *fdset)
d440 1
a440 1
datalink_Read(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
d470 1
a470 1
datalink_Write(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
@


1.24
log
@o Obsolete the undocumented ``set weight'' command.
o If we're using RADIUS and the RADIUS mtu is less than our
  peers mru/mrru, reduce our mtu to this value for NetBSD too.
o Make struct throughput's sample period dynamic and tweak the ppp
  version number to reflect the extra stuff being passed through
  the local domain socket as a result (MP mode).
o Measure the current throughput based on the number of samples actually
  taken rather than on the full sample period.
o Keep the throughput statisics persistent while being passed to
  another ppp invocation through the local domain socket.
o When showing throughput statistics after the timer has stopped, use
  the stopped time for overall calculations, not the current time.
  Also show the stopped time and how long the current throughput has
  been sampled for.
o Use time() consistently in throughput.c
o Tighten up the ``show bundle'' output.
o Introduce the ``set bandwidth'' command.
o Rewrite the ``set autoload'' command.  It now takes three arguments
  and works based on a rolling bundle throughput average compared against
  the theoretical bundle bandwidth over a given period (read: it's now
  functional).
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.23 1999/07/15 02:10:32 brian Exp $
d123 1
d148 2
a149 1
    if (bundle_Phase(dl->bundle) != PHASE_TERMINATE)
d164 2
a165 1
    if (bundle_Phase(dl->bundle) != PHASE_TERMINATE)
d181 1
a181 1
static const char *
d206 2
d216 3
a218 3
      datalink_NewState(dl, DATALINK_HANGUP);
      physical_Offline(dl->physical);
      chat_Init(&dl->chat, dl->physical, dl->cfg.script.hangup, 1, NULL);
d253 2
a254 2
      if ((dl->physical->type &
           (PHYS_DIRECT|PHYS_DEDICATED|PHYS_BACKGROUND|PHYS_DDIAL)) &&
d258 3
a260 2
         * DIRECT & BACKGROUND get deleted when they enter DATALINK_CLOSED.
         * Go to DATALINK_OPENING via datalink_Up() and fall through.
d277 4
a280 2
            chat_Init(&dl->chat, dl->physical, dl->cfg.script.dial, 1,
                      datalink_ChoosePhoneNumber(dl));
d287 1
a287 1
            datalink_LoginDone(dl);
d318 29
d349 1
a354 1
          chat_Destroy(&dl->chat);
d360 7
a366 2
              datalink_NewState(dl, DATALINK_LOGIN);
              chat_Init(&dl->chat, dl->physical, dl->cfg.script.login, 0, NULL);
a376 1
          chat_Destroy(&dl->chat);
d382 1
d385 3
a387 2
              physical_Offline(dl->physical);	/* Is this required ? */
              chat_Init(&dl->chat, dl->physical, dl->cfg.script.hangup, 1, NULL);
d424 1
d451 1
d482 1
a517 1
    chat_Destroy(&dl->chat);
d519 9
a527 2
      datalink_NewState(dl, DATALINK_HANGUP);
      chat_Init(&dl->chat, dl->physical, dl->cfg.script.hangup, 1, NULL);
d783 1
d834 3
a836 1
  chat_Init(&dl->chat, dl->physical, NULL, 1, NULL);
d898 3
a900 1
  chat_Init(&dl->chat, dl->physical, NULL, 1, NULL);
d920 1
a920 1
        chat_Destroy(&dl->chat);	/* Gotta blat the timers ! */
d925 1
d1117 2
d1222 1
a1222 1
static const char *states[] = {
d1227 2
d1260 1
a1260 1
             int fd)
d1321 1
a1321 1
  dl->physical = iov2physical(dl, iov, niov, maxiov, fd);
d1337 3
a1339 1
    chat_Init(&dl->chat, dl->physical, NULL, 1, NULL);
d1350 1
a1350 1
             pid_t newpid)
d1372 1
a1372 1
  iov[*niov].iov_base = dl ? dl : malloc(sizeof *dl);
d1374 1
a1374 2
  iov[*niov].iov_base =
    dl ? realloc(dl->name, DATALINK_MAXNAME) : malloc(DATALINK_MAXNAME);
d1377 2
a1378 1
  link_fd = physical2iov(dl ? dl->physical : NULL, iov, niov, maxiov, newpid);
d1423 2
a1424 1
  if (mode & (PHYS_DDIAL|PHYS_BACKGROUND) && dl->state <= DATALINK_READY)
@


1.23
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.21 1999/06/18 13:49:19 brian Exp $
d546 1
d551 1
d560 1
@


1.22
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d178 1
a178 1
const char *
d272 1
a272 2
                      *dl->cfg.script.dial ?
                      datalink_ChoosePhoneNumber(dl) : "");
a309 19
    case DATALINK_CARRIER:
      /* Wait for carrier on the device */
      switch (physical_AwaitCarrier(dl->physical)) {
        case CARRIER_PENDING:
          log_Printf(LogDEBUG, "Waiting for carrier\n");
          return 0;	/* A device timer is running to wake us up again */

        case CARRIER_OK:
          datalink_NewState(dl, DATALINK_LOGIN);
          chat_Init(&dl->chat, dl->physical, dl->cfg.script.login, 0, NULL);
          return datalink_UpdateSet(d, r, w, e, n);

        case CARRIER_LOST:
          datalink_NewState(dl, DATALINK_HANGUP);
          physical_Offline(dl->physical);	/* Is this required ? */
          chat_Init(&dl->chat, dl->physical, dl->cfg.script.hangup, 1, NULL);
          return datalink_UpdateSet(d, r, w, e, n);
      }

d323 2
a324 1
              datalink_NewState(dl, DATALINK_CARRIER);
d344 1
a344 2
              chat_Init(&dl->chat, dl->physical, dl->cfg.script.hangup,
                        1, NULL);
a1163 1
  "carrier",
@


1.21
log
@Don't use the ``next'' redial timer if we have no phone number at all.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.20 1999/06/10 09:06:27 brian Exp $
d178 1
a178 1
static const char *
d272 2
a273 1
                      datalink_ChoosePhoneNumber(dl));
d311 19
d343 1
a343 2
              datalink_NewState(dl, DATALINK_LOGIN);
              chat_Init(&dl->chat, dl->physical, dl->cfg.script.login, 0, NULL);
d363 2
a364 1
              chat_Init(&dl->chat, dl->physical, dl->cfg.script.hangup, 1, NULL);
d1184 1
@


1.20
log
@Never bring a link back up after receiving a terminating signal,
don't rely on already being in PHASE_DEAD.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.19 1999/05/12 10:03:50 brian Exp $
d187 2
@


1.19
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.18 1999/05/08 11:06:34 brian Exp $
d248 1
a248 1
          !bundle_IsDead(dl->bundle))
@


1.18
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.17 1999/04/19 16:59:39 brian Exp $
d213 1
a213 1
      timer_Stop(&dl->physical->Timer);
d466 1
a466 1
    timer_Stop(&dl->physical->Timer);
@


1.17
log
@Escape stuff in the peers accmap as well as our own when async
encoding, and back out the negotiation strategy that didn't
quite have the right effect with some (bad?) ppp implementations.

Drop unexpected PAP/CHAP packets (if not in NETWORK or ESTABLISH
phase).

Make sure that we enter PHASE_ESTABLISH when we need to.

Detect HDLC frames correctly, not just when the whole header
is obtained by a single read().

Don't convert \r\n to \r\r\n in tty raw mode.

Use the correct macros for `', ``'', () and [].
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.16 1999/03/04 17:42:25 brian Exp $
d42 1
a67 1
#include "modem.h"
d69 1
a69 1
#include "lcpproto.h"
d117 2
a118 2
      physical_GetFD(dl->physical) != -1) {
    /* Don't close our modem if the link is dedicated */
d123 1
a123 1
  modem_Close(dl->physical);
d205 1
a205 1
  } else if (modem_Raw(dl->physical, dl->bundle) < 0) {
d210 1
a210 1
      modem_Offline(dl->physical);
d216 1
a216 1
        modem_Close(dl->physical);
d263 1
a263 1
        if (modem_Open(dl->physical, dl->bundle) >= 0) {
d282 1
a282 1
            log_Printf(LogCHAT, "Failed to open modem (attempt %u of %d)\n",
d285 1
a285 1
            log_Printf(LogCHAT, "Failed to open modem\n");
d341 1
a341 1
              modem_Offline(dl->physical);	/* Is this required ? */
d469 1
a469 1
    modem_Offline(dl->physical);
d767 1
a767 1
  if ((dl->physical = modem_Create(dl, type)) == NULL) {
d818 1
a818 1
  if ((dl->physical = modem_Create(dl, PHYS_INTERACTIVE)) == NULL) {
d865 1
a865 1
  modem_Destroy(dl->physical);
d1254 1
a1254 1
  dl->physical = iov2modem(dl, iov, niov, maxiov, fd);
d1309 1
a1309 1
  link_fd = modem2iov(dl ? dl->physical : NULL, iov, niov, maxiov, newpid);
@


1.16
log
@Extend the ``set redial'' command to allow incremental
redial timeouts.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.15 1999/02/26 21:28:21 brian Exp $
d147 2
d162 2
d501 1
a501 1
      if (bundle_Phase(dl->bundle) == PHASE_ESTABLISH)
@


1.15
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.14 1999/02/25 12:07:23 brian Exp $
d84 1
a84 1
  timer_Stop(&dl->dial_timer);
d94 1
a94 1
  timer_Stop(&dl->dial_timer);
d97 1
a97 1
      dl->dial_timer.load = Timeout * SECTICKS;
d100 1
a100 1
      dl->dial_timer.load = result * SECTICKS;
d102 4
a105 4
    dl->dial_timer.func = datalink_OpenTimeout;
    dl->dial_timer.name = "dial";
    dl->dial_timer.arg = dl;
    timer_Start(&dl->dial_timer);
d134 2
a135 1
    dl->dial_tries = dl->cfg.dial.max;
d141 1
a141 1
    /* if dial.timeout is < 0 (random), don't override fsm.delay */
d149 1
a149 1
      ((!dl->dial_tries || (dl->dial_tries < 0 && !dl->reconnect_tries)) &&
d152 2
a153 1
    dl->dial_tries = -1;
d157 1
a157 1
      datalink_StartDialTimer(dl, dl->cfg.dial.timeout);
d160 1
a160 1
    if (dl->dial_tries < 0) {
d162 2
a163 1
      dl->dial_tries = dl->cfg.dial.max;
d167 1
a167 1
        datalink_StartDialTimer(dl, dl->cfg.dial.timeout);
d198 2
a199 1
    dl->dial_tries = -1;
d202 1
a202 1
    dl->dial_tries = 0;
d216 2
a217 1
    dl->dial_tries = -1;
d256 3
a258 3
      if (dl->dial_timer.state != TIMER_RUNNING) {
        if (--dl->dial_tries < 0)
          dl->dial_tries = 0;
d270 1
a270 1
                        dl->name, dl->cfg.dial.max - dl->dial_tries,
d279 1
a279 1
                       dl->cfg.dial.max - dl->dial_tries, dl->cfg.dial.max);
d285 1
a285 1
               dl->cfg.dial.max && dl->dial_tries == 0)) {
d288 1
a288 1
            dl->dial_tries = -1;
d294 3
a296 1
            int timeout = datalink_StartDialTimer(dl, dl->cfg.dial.timeout);
d454 1
a454 1
    dl->dial_tries = -1;
d736 1
a736 1
  memset(&dl->dial_timer, '\0', sizeof dl->dial_timer);
d738 1
a738 1
  dl->dial_tries = 0;
d742 2
d805 2
a806 2
  memset(&dl->dial_timer, '\0', sizeof dl->dial_timer);
  dl->dial_tries = 0;
d859 1
a859 1
  timer_Stop(&dl->dial_timer);
d883 1
a883 1
      dl->dial_tries = dl->cfg.dial.max;
d921 1
a921 1
        dl->dial_tries = -1;
d1069 2
a1070 3
  int timeout;
  int tries;
  char *dot;
d1088 34
a1121 3
    dot = strchr(arg->argv[arg->argn], '.');
    if (dot) {
      if (strcasecmp(++dot, "random") == 0) {
d1125 1
a1125 1
	timeout = atoi(dot);
d1149 1
d1240 2
a1241 2
  memset(&dl->dial_timer, '\0', sizeof dl->dial_timer);
  dl->dial_tries = 0;
d1283 1
a1283 1
    timer_Stop(&dl->dial_timer);
d1353 11
@


1.14
log
@When our dial timeout is ``random'', display its value
correctly by invoking the timer to get the value before
displaying the message.
Don't assume that a value of 0 is ``random'' in
``show datalink''.
Make the random value between 1 and DIAL_TIMEOUT rather
than between 0 and DIAL_TIMEOUT-1
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.13 1999/02/18 00:50:45 brian Exp $
d811 1
a811 1
  dl->pap.cfg.fsmretry = odl->pap.cfg.fsmretry;
d814 1
a814 1
  dl->chap.auth.cfg.fsmretry = odl->chap.auth.cfg.fsmretry;
d1152 1
a1152 1
  u_int retry;
d1217 1
a1217 1
    retry = dl->pap.cfg.fsmretry;
d1219 1
a1219 1
    dl->pap.cfg.fsmretry = retry;
d1221 1
a1221 1
    retry = dl->chap.auth.cfg.fsmretry;
d1223 1
a1223 1
    dl->chap.auth.cfg.fsmretry = retry;
@


1.13
log
@Fully support both NT and LANMan CHAP type 0x80 as both
authenticator and authenticatee.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.12 1999/02/17 02:11:34 brian Exp $
d89 1
a89 1
static void
d92 2
a94 1
 
d98 4
a101 2
    else
      dl->dial_timer.load = (random() % DIAL_TIMEOUT) * SECTICKS;
d110 1
d140 1
d289 1
d291 1
a291 2
                             dl->physical->name.full, dl->cfg.dial.timeout);
            datalink_StartDialTimer(dl, dl->cfg.dial.timeout);
d984 1
a984 1
  if (arg->cx->cfg.dial.next_timeout > 0)
d988 1
a988 1
  if (arg->cx->cfg.dial.timeout > 0)
@


1.12
log
@Nuke any remaining auth timers when datalinks come back down
to DATALINK_LCP.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.11 1999/02/11 10:14:50 brian Exp $
d478 1
d482 3
a484 3
    dl->physical->link.lcp.auth_ineed = dl->physical->link.lcp.want_auth;
    dl->physical->link.lcp.auth_iwait = dl->physical->link.lcp.his_auth;
    if (dl->physical->link.lcp.his_auth || dl->physical->link.lcp.want_auth) {
d488 3
a490 3
                Auth2Nam(dl->physical->link.lcp.his_auth),
                Auth2Nam(dl->physical->link.lcp.want_auth));
      if (dl->physical->link.lcp.his_auth == PROTO_PAP)
d492 1
a492 1
      if (dl->physical->link.lcp.want_auth == PROTO_CHAP)
a958 2
  prompt_Printf(arg->prompt, " CHAP Encryption:    %s\n",
                arg->cx->chap.using_MSChap ? "MSChap" : "MD5" );
@


1.11
log
@When resending chap challenges, resend the same challenge
each time rather than making up a new one.

Increase the authname/authkey max sizes to 100 characters.

Allow ``authkey'' specifications beginning with ``!''.
When a challenge is received, the text following the
``!'' is executed as a program (expanding stuff in the same
way that ``sh'' and ``!bg'' do).  The program is passed the
peer name, peer challenge and local ``authname'' on standard
input and is expected to output the name/key combination that
should be used to build the CHAP response.

This provides support for Secure ID cards (guess what I was
given at work recently!) using CHAP.

Examples will follow.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.10 1999/02/06 03:22:34 brian Exp $
d498 8
d560 1
a560 1
  chap_ReInit(&dl->chap);
d587 1
a587 1
    chap_ReInit(&dl->chap);
d612 1
a612 1
        chap_ReInit(&dl->chap);
d625 1
a625 1
        chap_ReInit(&dl->chap);
d633 1
a633 1
        chap_ReInit(&dl->chap);
d643 1
a643 1
  chap_ReInit(&dl->chap);
d672 1
a672 1
    chap_ReInit(&dl->chap);
d903 1
a903 1
      chap_ReInit(&dl->chap);
@


1.10
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.28 1999/02/02 09:35:17 brian Exp $
d338 2
a339 1
      result = descriptor_UpdateSet(&dl->physical->desc, r, w, e, n);
d371 2
a372 1
      return descriptor_IsSet(&dl->physical->desc, fdset);
d398 4
a401 1
      descriptor_Read(&dl->physical->desc, bundle, fdset);
d428 4
a431 1
      result = descriptor_Write(&dl->physical->desc, bundle, fdset);
d552 1
d579 1
d604 1
d617 1
d625 1
d635 1
d664 1
d895 1
@


1.9
log
@Reimplement the previous fix (no response to PAP requests)
at the authentication layer rather than at the PAP layer
so that it also applies to CHAP (no response to CHAP
challenges).
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.8 1999/02/01 13:50:27 brian Exp $
d29 1
a29 1
#include <sys/types.h>
d61 3
d472 1
a472 1
    datalink_GotAuthname(dl, "", 0);
d482 1
a482 1
        auth_StartChallenge(&dl->pap, dl->physical, pap_SendChallenge);
d484 1
a484 1
        auth_StartChallenge(&dl->chap.auth, dl->physical, chap_SendChallenge);
d491 1
a491 1
datalink_GotAuthname(struct datalink *dl, const char *name, int len)
d493 2
a494 4
  if (len >= sizeof dl->peer.authname)
    len = sizeof dl->peer.authname - 1;
  strncpy(dl->peer.authname, name, len);
  dl->peer.authname[len] = '\0';
a724 3
  auth_Init(&dl->pap);
  auth_Init(&dl->chap.auth);

d730 3
a774 5
  auth_Init(&dl->pap);
  dl->pap.cfg.fsmretry = odl->pap.cfg.fsmretry;

  auth_Init(&dl->chap.auth);
  dl->chap.auth.cfg.fsmretry = odl->chap.auth.cfg.fsmretry;
d781 6
a1181 8
  retry = dl->pap.cfg.fsmretry;
  auth_Init(&dl->pap);
  dl->pap.cfg.fsmretry = retry;

  retry = dl->chap.auth.cfg.fsmretry;
  auth_Init(&dl->chap.auth);
  dl->chap.auth.cfg.fsmretry = retry;

d1189 8
@


1.8
log
@If we receive no answer from the server when sending PAP
requests, give up (don't sit there indefinitely).
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.7 1999/01/20 18:07:11 brian Exp $
d479 1
a479 2
        auth_StartChallenge(&dl->pap, dl->physical, pap_SendChallenge,
                            pap_Failed);
d481 1
a481 2
        auth_StartChallenge(&dl->chap.auth, dl->physical, chap_SendChallenge,
                            NULL);
@


1.7
log
@Recurse when we've switched state via LoginDone().  If we've
got an open link, we want it to be select()d on - otherwise
we get a freeze when ``openmode'' is passive.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.6 1999/01/13 17:39:57 brian Exp $
d479 2
a480 1
        auth_StartChallenge(&dl->pap, dl->physical, pap_SendChallenge);
d482 2
a483 1
        auth_StartChallenge(&dl->chap.auth, dl->physical, chap_SendChallenge);
@


1.6
log
@If we've configured CBCP *and* another not-so-important
CALLBACK protocol and end up agreeing CBCP, DTRT and go
into CBCP phase rather than mistakenly terminating as
if CBCP wasn't agreed.
Problem reported by: Alexander Dubinin <alex@@nstl.nnov.ru>
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.5 1999/01/08 17:26:45 brian Exp $
d308 1
a308 1
              break;
@


1.5
log
@Don't use the next phone number after the ``|'' if the
dial & login are successful.
Submitted by:   Toshiomi Moriki <Toshiomi.Moriki@@ma1.seikyou.ne.jp>
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.4 1998/12/15 19:16:30 brian Exp $
d556 7
a562 4
  if (dl->physical->link.lcp.his_callback.opmask ==
      CALLBACK_BIT(CALLBACK_CBCP) ||
      dl->physical->link.lcp.want_callback.opmask ==
      CALLBACK_BIT(CALLBACK_CBCP)) {
d566 1
@


1.4
log
@Fix a potentially bad latency problem.
Problem reported by: Christopher Hall <hsw@@acm.org>
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.3 1998/12/10 18:40:56 brian Exp $
d306 1
@


1.3
log
@Boy, this was tricky to find:
  Remove any dial timer that might be hanging around at
  datalink_Destroy() time.  This timer may be left running
  after the link is closed (making sure it's not automatically
  opened again too soon).
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.2 1998/10/29 02:21:44 brian Exp $
a258 1
            return datalink_UpdateSet(d, r, w, e, n);
d261 1
@


1.2
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.1 1998/08/31 00:22:19 brian Exp $
d814 1
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d26 1
a26 1
 *	$Id: datalink.c,v 1.19 1998/08/18 00:53:48 brian Exp $
d987 8
a994 2
      prompt_Printf(arg->prompt, "                     phone: %s\n",
                    arg->cx->cfg.cbcp.phone);
@

