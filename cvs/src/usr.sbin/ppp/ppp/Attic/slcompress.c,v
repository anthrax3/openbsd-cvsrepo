head	1.21;
access;
symbols
	OPENBSD_5_5:1.20.0.38
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.34
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.32
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.30
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.28
	OPENBSD_5_0:1.20.0.26
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.24
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.22
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.18
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.20
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.16
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.14
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.12
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.10
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.8
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.6
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.6
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.20;

1.20
date	2005.07.17.20.24.45;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.06.17.36.31;	author cloder;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.04.16.08.08;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.04.29.23;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.15.08.02.01;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.03.21.52.57;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.27.01.38.28;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.10.13.07.51.38;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.07.10.00.08.52;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.05.09.20.04.03;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.08.11.06.39;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.03.31.13.44.02;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.03.31.13.33.02;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.30.07.57.38;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.47;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.28;	author brian;	state Exp;
branches;
next	;


desc
@@


1.21
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)slcompress.c	8.2 (Berkeley) 4/16/94
 */

/*
 * Routines to compress and uncompess tcp packets (for transmission
 * over low speed serial lines.
 *
 * Van Jacobson (van@@helios.ee.lbl.gov), Dec 31, 1989:
 *	- Initial distribution.
 *
 * $OpenBSD: slcompress.c,v 1.20 2005/07/17 20:24:45 brad Exp $
 */

#include <sys/param.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <termios.h>

#include "layer.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "slcompress.h"
#include "descriptor.h"
#include "prompt.h"
#include "timer.h"
#include "fsm.h"
#include "throughput.h"
#include "iplist.h"
#include "lqr.h"
#include "hdlc.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"

void
sl_compress_init(struct slcompress *comp, int max_state)
{
  register u_int i;
  register struct cstate *tstate = comp->tstate;

  memset(comp, '\0', sizeof *comp);
  for (i = max_state; i > 0; --i) {
    tstate[i].cs_id = i;
    tstate[i].cs_next = &tstate[i - 1];
  }
  tstate[0].cs_next = &tstate[max_state];
  tstate[0].cs_id = 0;
  comp->last_cs = &tstate[0];
  comp->last_recv = 255;
  comp->last_xmit = 255;
  comp->flags = SLF_TOSS;
}


/* ENCODE encodes a number that is known to be non-zero.  ENCODEZ
 * checks for zero (since zero has to be encoded in the 32-bit, 3 byte
 * form).
 */
#define ENCODE(n) { \
	if ((u_short)(n) >= 256) { \
		*cp++ = 0; \
		cp[1] = (n); \
		cp[0] = (n) >> 8; \
		cp += 2; \
	} else { \
		*cp++ = (n); \
	} \
}
#define ENCODEZ(n) { \
	if ((u_short)(n) >= 256 || (u_short)(n) == 0) { \
		*cp++ = 0; \
		cp[1] = (n); \
		cp[0] = (n) >> 8; \
		cp += 2; \
	} else { \
		*cp++ = (n); \
	} \
}

#define DECODEL(f) { \
	if (*cp == 0) {\
		(f) = htonl(ntohl(f) + ((cp[1] << 8) | cp[2])); \
		cp += 3; \
	} else { \
		(f) = htonl(ntohl(f) + (u_int32_t)*cp++); \
	} \
}

#define DECODES(f) { \
	if (*cp == 0) {\
		(f) = htons(ntohs(f) + ((cp[1] << 8) | cp[2])); \
		cp += 3; \
	} else { \
		(f) = htons(ntohs(f) + (u_int32_t)*cp++); \
	} \
}

#define DECODEU(f) { \
	if (*cp == 0) {\
		(f) = htons((cp[1] << 8) | cp[2]); \
		cp += 3; \
	} else { \
		(f) = htons((u_int32_t)*cp++); \
	} \
}


u_char
sl_compress_tcp(struct mbuf * m,
		struct ip * ip,
		struct slcompress *comp,
                struct slstat *slstat,
		int compress_cid)
{
  register struct cstate *cs = comp->last_cs->cs_next;
  register u_int hlen = ip->ip_hl;
  register struct tcphdr *oth;
  register struct tcphdr *th;
  register u_int deltaS, deltaA;
  register u_int changes = 0;
  u_char new_seq[16];
  register u_char *cp = new_seq;

  /*
   * Bail if this is an IP fragment or if the TCP packet isn't `compressible'
   * (i.e., ACK isn't set or some other control bit is set).  (We assume that
   * the caller has already made sure the packet is IP proto TCP).
   */
  if ((ip->ip_off & htons(0x3fff)) || m->m_len < 40) {
    log_Printf(LogDEBUG, "??? 1 ip_off = %x, m_len = %lu\n",
	      ntohs(ip->ip_off), (unsigned long)m->m_len);
    log_DumpBp(LogDEBUG, "", m);
    return (TYPE_IP);
  }
  th = (struct tcphdr *) & ((int *) ip)[hlen];
  if ((th->th_flags & (TH_SYN | TH_FIN | TH_RST | TH_ACK)) != TH_ACK) {
    log_Printf(LogDEBUG, "??? 2 th_flags = %x\n", th->th_flags);
    log_DumpBp(LogDEBUG, "", m);
    return (TYPE_IP);
  }

  /*
   * Packet is compressible -- we're going to send either a COMPRESSED_TCP or
   * UNCOMPRESSED_TCP packet.  Either way we need to locate (or create) the
   * connection state.  Special case the most recently used connection since
   * it's most likely to be used again & we don't have to do any reordering
   * if it's used.
   */
  slstat->sls_packets++;
  if (ip->ip_src.s_addr != cs->cs_ip.ip_src.s_addr ||
      ip->ip_dst.s_addr != cs->cs_ip.ip_dst.s_addr ||
      *(int *) th != ((int *) &cs->cs_ip)[cs->cs_ip.ip_hl]) {

    /*
     * Wasn't the first -- search for it.
     *
     * States are kept in a circularly linked list with last_cs pointing to the
     * end of the list.  The list is kept in lru order by moving a state to
     * the head of the list whenever it is referenced.  Since the list is
     * short and, empirically, the connection we want is almost always near
     * the front, we locate states via linear search.  If we don't find a
     * state for the datagram, the oldest state is (re-)used.
     */
    register struct cstate *lcs;
    register struct cstate *lastcs = comp->last_cs;

    do {
      lcs = cs;
      cs = cs->cs_next;
      slstat->sls_searches++;
      if (ip->ip_src.s_addr == cs->cs_ip.ip_src.s_addr
	  && ip->ip_dst.s_addr == cs->cs_ip.ip_dst.s_addr
	  && *(int *) th == ((int *) &cs->cs_ip)[cs->cs_ip.ip_hl])
	goto found;
    } while (cs != lastcs);

    /*
     * Didn't find it -- re-use oldest cstate.  Send an uncompressed packet
     * that tells the other side what connection number we're using for this
     * conversation. Note that since the state list is circular, the oldest
     * state points to the newest and we only need to set last_cs to update
     * the lru linkage.
     */
    slstat->sls_misses++;
      comp->last_cs = lcs;
#define	THOFFSET(th)	(th->th_off)
    hlen += th->th_off;
    hlen <<= 2;
    if (hlen > m->m_len)
      return (TYPE_IP);
    goto uncompressed;

found:

    /*
     * Found it -- move to the front on the connection list.
     */
    if (cs == lastcs)
      comp->last_cs = lcs;
    else {
      lcs->cs_next = cs->cs_next;
      cs->cs_next = lastcs->cs_next;
      lastcs->cs_next = cs;
    }
  }

  /*
   * Make sure that only what we expect to change changed. The first line of
   * the `if' checks the IP protocol version, header length & type of
   * service.  The 2nd line checks the "Don't fragment" bit. The 3rd line
   * checks the time-to-live and protocol (the protocol check is unnecessary
   * but costless).  The 4th line checks the TCP header length.  The 5th line
   * checks IP options, if any.  The 6th line checks TCP options, if any.  If
   * any of these things are different between the previous & current
   * datagram, we send the current datagram `uncompressed'.
   */
  oth = (struct tcphdr *) & ((int *) &cs->cs_ip)[hlen];
  deltaS = hlen;
  hlen += th->th_off;
  hlen <<= 2;
  if (hlen > m->m_len)
    return (TYPE_IP);

  if (((u_short *) ip)[0] != ((u_short *) & cs->cs_ip)[0] ||
      ((u_short *) ip)[3] != ((u_short *) & cs->cs_ip)[3] ||
      ((u_short *) ip)[4] != ((u_short *) & cs->cs_ip)[4] ||
      THOFFSET(th) != THOFFSET(oth) ||
      (deltaS > 5 &&
       memcmp(ip + 1, &cs->cs_ip + 1, (deltaS - 5) << 2)) ||
      (THOFFSET(th) > 5 &&
       memcmp(th + 1, oth + 1, (THOFFSET(th) - 5) << 2))) {
    goto uncompressed;
  }

  /*
   * Figure out which of the changing fields changed.  The receiver expects
   * changes in the order: urgent, window, ack, seq (the order minimizes the
   * number of temporaries needed in this section of code).
   */
  if (th->th_flags & TH_URG) {
    deltaS = ntohs(th->th_urp);
    ENCODEZ(deltaS);
    changes |= NEW_U;
  } else if (th->th_urp != oth->th_urp) {

    /*
     * argh! URG not set but urp changed -- a sensible implementation should
     * never do this but RFC793 doesn't prohibit the change so we have to
     * deal with it.
     */
    goto uncompressed;
  }
  deltaS = (u_short) (ntohs(th->th_win) - ntohs(oth->th_win));
  if (deltaS) {
    ENCODE(deltaS);
    changes |= NEW_W;
  }
  deltaA = ntohl(th->th_ack) - ntohl(oth->th_ack);
  if (deltaA) {
    if (deltaA > 0xffff) {
      goto uncompressed;
    }
    ENCODE(deltaA);
    changes |= NEW_A;
  }
  deltaS = ntohl(th->th_seq) - ntohl(oth->th_seq);
  if (deltaS) {
    if (deltaS > 0xffff) {
      goto uncompressed;
    }
    ENCODE(deltaS);
    changes |= NEW_S;
  }
  switch (changes) {

  case 0:

    /*
     * Nothing changed. If this packet contains data and the last one didn't,
     * this is probably a data packet following an ack (normal on an
     * interactive connection) and we send it compressed.  Otherwise it's
     * probably a retransmit, retransmitted ack or window probe.  Send it
     * uncompressed in case the other side missed the compressed version.
     */
    if (ip->ip_len != cs->cs_ip.ip_len &&
	ntohs(cs->cs_ip.ip_len) == hlen)
      break;

    /* FALLTHROUGH */

  case SPECIAL_I:
  case SPECIAL_D:

    /*
     * actual changes match one of our special case encodings -- send packet
     * uncompressed.
     */
    goto uncompressed;

  case NEW_S | NEW_A:
    if (deltaS == deltaA &&
	deltaS == ntohs(cs->cs_ip.ip_len) - hlen) {
      /* special case for echoed terminal traffic */
      changes = SPECIAL_I;
      cp = new_seq;
    }
    break;

  case NEW_S:
    if (deltaS == ntohs(cs->cs_ip.ip_len) - hlen) {
      /* special case for data xfer */
      changes = SPECIAL_D;
      cp = new_seq;
    }
    break;
  }

  deltaS = ntohs(ip->ip_id) - ntohs(cs->cs_ip.ip_id);
  if (deltaS != 1) {
    ENCODEZ(deltaS);
    changes |= NEW_I;
  }
  if (th->th_flags & TH_PUSH)
    changes |= TCP_PUSH_BIT;

  /*
   * Grab the cksum before we overwrite it below.  Then update our state with
   * this packet's header.
   */
  deltaA = ntohs(th->th_sum);
  memcpy(&cs->cs_ip, ip, hlen);

  /*
   * We want to use the original packet as our compressed packet. (cp -
   * new_seq) is the number of bytes we need for compressed sequence numbers.
   * In addition we need one byte for the change mask, one for the connection
   * id and two for the tcp checksum. So, (cp - new_seq) + 4 bytes of header
   * are needed.  hlen is how many bytes of the original packet to toss so
   * subtract the two to get the new packet size.
   */
  deltaS = cp - new_seq;
  cp = (u_char *) ip;

  /*
   * Since fastq traffic can jump ahead of the background traffic, we don't
   * know what order packets will go on the line.  In this case, we always
   * send a "new" connection id so the receiver state stays synchronized.
   */
  if (comp->last_xmit == cs->cs_id && compress_cid) {
    hlen -= deltaS + 3;
    cp += hlen;
    *cp++ = changes;
  } else {
    comp->last_xmit = cs->cs_id;
    hlen -= deltaS + 4;
    cp += hlen;
    *cp++ = changes | NEW_C;
    *cp++ = cs->cs_id;
  }
  m->m_len -= hlen;
  m->m_offset += hlen;
  *cp++ = deltaA >> 8;
  *cp++ = deltaA;
  memcpy(cp, new_seq, deltaS);
  slstat->sls_compressed++;
  return (TYPE_COMPRESSED_TCP);

  /*
   * Update connection state cs & send uncompressed packet ('uncompressed'
   * means a regular ip/tcp packet but with the 'conversation id' we hope to
   * use on future compressed packets in the protocol field).
   */
uncompressed:
  memcpy(&cs->cs_ip, ip, hlen);
  ip->ip_p = cs->cs_id;
  comp->last_xmit = cs->cs_id;
  return (TYPE_UNCOMPRESSED_TCP);
}


int
sl_uncompress_tcp(u_char ** bufp, int len, u_int type, struct slcompress *comp,
                  struct slstat *slstat, int max_state)
{
  register u_char *cp;
  register u_int hlen, changes;
  register struct tcphdr *th;
  register struct cstate *cs;
  register struct ip *ip;
  u_short *bp;

  switch (type) {

  case TYPE_UNCOMPRESSED_TCP:
    ip = (struct ip *) * bufp;
    if (ip->ip_p > max_state)
      goto bad;
    cs = &comp->rstate[comp->last_recv = ip->ip_p];
    comp->flags &= ~SLF_TOSS;
    ip->ip_p = IPPROTO_TCP;

    /*
     * Calculate the size of the TCP/IP header and make sure that we don't
     * overflow the space we have available for it.
     */
    hlen = ip->ip_hl << 2;
    if (hlen + sizeof(struct tcphdr) > len)
      goto bad;
    th = (struct tcphdr *) & ((char *) ip)[hlen];
    hlen += THOFFSET(th) << 2;
    if (hlen > MAX_HDR)
      goto bad;
    memcpy(&cs->cs_ip, ip, hlen);
    cs->cs_hlen = hlen;
    slstat->sls_uncompressedin++;
    return (len);

  default:
    goto bad;

  case TYPE_COMPRESSED_TCP:
    break;
  }

  /* We've got a compressed packet. */
  slstat->sls_compressedin++;
  cp = *bufp;
  changes = *cp++;
  log_Printf(LogDEBUG, "compressed: changes = %02x\n", changes);

  if (changes & NEW_C) {
    /*
     * Make sure the state index is in range, then grab the state. If we have
     * a good state index, clear the 'discard' flag.
     */
    if (*cp > max_state || comp->last_recv == 255)
      goto bad;

    comp->flags &= ~SLF_TOSS;
    comp->last_recv = *cp++;
  } else {
    /*
     * this packet has an implicit state index.  If we've had a line error
     * since the last time we got an explicit state index, we have to toss
     * the packet.
     */
    if (comp->flags & SLF_TOSS) {
      slstat->sls_tossed++;
      return (0);
    }
  }
  cs = &comp->rstate[comp->last_recv];
  hlen = cs->cs_ip.ip_hl << 2;
  th = (struct tcphdr *) & ((u_char *) & cs->cs_ip)[hlen];
  th->th_sum = htons((*cp << 8) | cp[1]);
  cp += 2;
  if (changes & TCP_PUSH_BIT)
    th->th_flags |= TH_PUSH;
  else
    th->th_flags &= ~TH_PUSH;

  switch (changes & SPECIALS_MASK) {
  case SPECIAL_I:
    {
      register u_int i = ntohs(cs->cs_ip.ip_len) - cs->cs_hlen;

      th->th_ack = htonl(ntohl(th->th_ack) + i);
      th->th_seq = htonl(ntohl(th->th_seq) + i);
    }
    break;

  case SPECIAL_D:
    th->th_seq = htonl(ntohl(th->th_seq) + ntohs(cs->cs_ip.ip_len)
		       - cs->cs_hlen);
    break;

  default:
    if (changes & NEW_U) {
      th->th_flags |= TH_URG;
      DECODEU(th->th_urp)
    } else
      th->th_flags &= ~TH_URG;
    if (changes & NEW_W)
      DECODES(th->th_win)
	if (changes & NEW_A)
	DECODEL(th->th_ack)
	  if (changes & NEW_S) {
	  log_Printf(LogDEBUG, "NEW_S: %02x, %02x, %02x\n",
		    *cp, cp[1], cp[2]);
	  DECODEL(th->th_seq)
	}
    break;
  }
  if (changes & NEW_I) {
    DECODES(cs->cs_ip.ip_id)
  } else
    cs->cs_ip.ip_id = htons(ntohs(cs->cs_ip.ip_id) + 1);

  log_Printf(LogDEBUG, "Uncompress: id = %04x, seq = %08lx\n",
	    cs->cs_ip.ip_id, (u_long)ntohl(th->th_seq));

  /*
   * At this point, cp points to the first byte of data in the packet.
   * Back up cp by the tcp/ip header length to make room for the
   * reconstructed header (we assume the packet we were handed has enough
   * space to prepend 128 bytes of header).  Adjust the length to account
   * for the new header & fill in the IP total length.
   */
  len -= (cp - *bufp);
  if (len < 0)
    /*
     * we must have dropped some characters (crc should detect this but the
     * old slip framing won't)
     */
    goto bad;

  *bufp = cp - cs->cs_hlen;
  len += cs->cs_hlen;
  cs->cs_ip.ip_len = htons(len);

  /* recompute the ip header checksum */
  cs->cs_ip.ip_sum = 0;
  bp = (u_short *)&cs->cs_ip;
  for (changes = 0; hlen > 0; hlen -= 2)
    changes += *bp++;
  changes = (changes & 0xffff) + (changes >> 16);
  changes = (changes & 0xffff) + (changes >> 16);
  cs->cs_ip.ip_sum = ~changes;

  /* And copy the result into our buffer */
  memcpy(*bufp, &cs->cs_ip, cs->cs_hlen);

  return (len);
bad:
  comp->flags |= SLF_TOSS;
  slstat->sls_errorin++;
  return (0);
}

int
sl_Show(struct cmdargs const *arg)
{
  prompt_Printf(arg->prompt, "VJ compression statistics:\n");
  prompt_Printf(arg->prompt, "  Out:  %d (compress) / %d (total)",
	        arg->bundle->ncp.ipcp.vj.slstat.sls_compressed,
                arg->bundle->ncp.ipcp.vj.slstat.sls_packets);
  prompt_Printf(arg->prompt, "  %d (miss) / %d (search)\n",
	        arg->bundle->ncp.ipcp.vj.slstat.sls_misses,
                arg->bundle->ncp.ipcp.vj.slstat.sls_searches);
  prompt_Printf(arg->prompt, "  In:  %d (compress), %d (uncompress)",
	        arg->bundle->ncp.ipcp.vj.slstat.sls_compressedin,
                arg->bundle->ncp.ipcp.vj.slstat.sls_uncompressedin);
  prompt_Printf(arg->prompt, "  %d (error),  %d (tossed)\n",
	        arg->bundle->ncp.ipcp.vj.slstat.sls_errorin,
                arg->bundle->ncp.ipcp.vj.slstat.sls_tossed);
  return 0;
}
@


1.20
log
@Replace various spelling with FALLTHROUGH which is lint()able

From charnier FreeBSD
@
text
@d39 1
a39 1
 * $OpenBSD: slcompress.c,v 1.19 2005/07/17 19:13:25 brad Exp $
@


1.19
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d39 1
a39 1
 * $OpenBSD: slcompress.c,v 1.18 2005/03/06 17:36:31 cloder Exp $
d337 1
a337 1
    /* (fall through) */
@


1.18
log
@Use correct byte order when logging port numbers.
OK tdeval, markus
@
text
@d39 1
a39 1
 * $OpenBSD: slcompress.c,v 1.17 2003/06/04 16:08:08 deraadt Exp $
d50 1
@


1.17
log
@fix some more UCB term 3
@
text
@d39 1
a39 1
 * $OpenBSD: slcompress.c,v 1.16 2003/06/02 04:29:23 millert Exp $
d178 1
a178 1
	      ip->ip_off, (unsigned long)m->m_len);
@


1.16
log
@Update old UCB license w/ new one based on /sys/net/slcompress.[ch]
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
 * $OpenBSD: slcompress.c,v 1.15 2002/06/15 08:02:01 brian Exp $
@


1.15
log
@Tidy up end of line whitespace
@
text
@d1 35
d40 2
a41 2
 * Copyright (c) 1989 Regents of the University of California.
 * All rights reserved.
d43 1
a43 16
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: slcompress.c,v 1.14 2002/05/16 01:13:39 brian Exp $
 *
 *	Van Jacobson (van@@helios.ee.lbl.gov), Dec 31, 1989:
 *	- Initial distribution.
@


1.14
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d20 1
a20 1
 * $OpenBSD: slcompress.c,v 1.13 2001/08/19 23:22:18 brian Exp $
d187 1
a187 1
     * 
@


1.13
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d20 1
a20 1
 * $OpenBSD: slcompress.c,v 1.12 2000/03/03 21:52:57 brian Exp $
a52 1
#include "ip.h"
@


1.12
log
@Fix some printf-type argument bugs
@
text
@d20 1
a20 1
 * $OpenBSD: slcompress.c,v 1.11 2000/02/27 01:38:28 brian Exp $
d31 1
d52 2
d63 2
@


1.11
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: slcompress.c,v 1.10 2000/01/07 03:26:55 brian Exp $
d157 2
a158 2
    log_Printf(LogDEBUG, "??? 1 ip_off = %x, m_len = %d\n",
	      ip->ip_off, m->m_len);
@


1.10
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: slcompress.c,v 1.9 1999/10/13 07:51:38 brian Exp $
@


1.9
log
@When uncompressing VJ-compressed frames, fix the ip_sum directly
in struct cstate rather than copying the stored header slot into a
potentially mis-aligned buffer then trying to update the ip_sum
without causing an exception on non-i386 hardware.

I've never been able to reproduce this problem, but it has been
reported by many people... besides, the code is now a bit cleaner.

Testing & patience by: Anthony Solovjoff <asolovjoff@@hotmail.com>
@
text
@d20 1
a20 1
 * $Id: slcompress.c,v 1.8 1999/07/10 00:08:52 brian Exp $
d156 3
a158 3
  if ((ip->ip_off & htons(0x3fff)) || m->cnt < 40) {
    log_Printf(LogDEBUG, "??? 1 ip_off = %x, cnt = %d\n",
	      ip->ip_off, m->cnt);
d216 1
a216 1
    if (hlen > m->cnt)
d248 1
a248 1
  if (hlen > m->cnt)
d387 2
a388 2
  m->cnt -= hlen;
  m->offset += hlen;
@


1.8
log
@Leap through one more hoop to avoid alignment problems.
@
text
@d20 1
a20 1
 * $Id: slcompress.c,v 1.7 1999/05/09 20:04:03 brian Exp $
d417 1
a440 1
    cs->cs_ip.ip_sum = 0;
d544 1
a544 1
  cp -= cs->cs_hlen;
a546 2
  memcpy(cp, &cs->cs_ip, cs->cs_hlen);
  *bufp = cp;
d549 10
a558 2
  {
    u_short sum, *bp = (u_short *)&cs->cs_ip;
a559 10
    for (changes = 0; hlen > 0; hlen -= 2)
      changes += *bp++;
    changes = (changes & 0xffff) + (changes >> 16);
    changes = (changes & 0xffff) + (changes >> 16);

    /* Watch out for alighment problems.... */
    sum = ~changes;
    bp = (u_short *)(cp + (int)&((struct ip *)0)->ip_sum);
    memcpy(bp, &sum, sizeof *bp);
  }
@


1.7
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d20 1
a20 1
 * $Id: slcompress.c,v 1.6 1999/05/08 11:06:39 brian Exp $
d561 1
a561 1
    bp = &((struct ip *)cp)->ip_sum;
@


1.6
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: slcompress.c,v 1.5 1999/03/31 13:44:02 brian Exp $
d63 1
a63 1
sl_compress_init(struct slcompress * comp, int max_state)
@


1.5
log
@Oops - remove register keyword
@
text
@d20 1
a20 1
 * $Id: slcompress.c,v 1.4 1999/03/31 13:33:02 brian Exp $
d37 1
d463 1
a463 1
    if (*cp > max_state || comp->last_recv == 255) {
a464 1
    }
a480 2
  if (hlen == 0)
    goto bad;    /* We've been pointed at a not-yet-used slot ! */
@


1.4
log
@Another alignment bogon.
@
text
@d20 1
a20 1
 * $Id: slcompress.c,v 1.3 1999/03/30 07:57:38 brian Exp $
d554 1
a554 1
    register u_short sum, *bp = (u_short *)&cs->cs_ip;
@


1.3
log
@Point at cs.slcs_u.csu_ip instead of the just-copied ``cp''
when recalculating the ip checksum.  cp is not guaranteed to
be aligned.  It now doesn't matter that cp isn't aligned as
the caller does another mbuf_Alloc() regardless.
@
text
@d20 1
a20 1
 * $Id: slcompress.c,v 1.2 1999/02/06 03:22:47 brian Exp $
d554 1
a554 1
    register u_short *bp = (u_short *)&cs->cs_ip;
d560 5
a564 1
    ((struct ip *) cp)->ip_sum = ~changes;
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: slcompress.c,v 1.21 1999/01/28 01:56:34 brian Exp $
d450 1
d456 1
a457 1

a468 1

d532 5
a536 6
   * At this point, cp points to the first byte of data in the packet.  If
   * we're not aligned on a 4-byte boundary, copy the data down so the ip &
   * tcp headers will be aligned.  Then back up cp by the tcp/ip header
   * length to make room for the reconstructed header (we assume the packet
   * we were handed has enough space to prepend 128 bytes of header).  Adjust
   * the length to account for the new header & fill in the IP total length.
a539 1

a545 8
#ifdef notdef
  if ((int) cp & 3) {
    if (len > 0)
      (void) bcopy(cp, (caddr_t) ((int) cp & ~3), len);
    cp = (u_char *) ((int) cp & ~3);
  }
#endif

d554 1
a554 1
    register u_short *bp = (u_short *) cp;
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: slcompress.c,v 1.20 1998/08/26 17:39:37 brian Exp $
d26 1
a26 1
#include <sys/types.h>
d56 3
@

