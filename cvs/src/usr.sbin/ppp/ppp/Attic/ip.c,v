head	1.39;
access;
symbols
	OPENBSD_5_5:1.38.0.36
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.32
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.30
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.28
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.26
	OPENBSD_5_0:1.38.0.24
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.22
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.20
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.16
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.18
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.14
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.12
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.10
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.38.0.8
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.38.0.6
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.38.0.4
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.6
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.37.0.4
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.37.0.2
	OPENBSD_3_6_BASE:1.37
	OPENBSD_3_5:1.36.0.8
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.36.0.6
	OPENBSD_3_4_BASE:1.36
	OPENBSD_3_3:1.36.0.4
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.36.0.2
	OPENBSD_3_2_BASE:1.36
	OPENBSD_3_1:1.34.0.4
	OPENBSD_3_1_BASE:1.34
	OPENBSD_3_0:1.34.0.2
	OPENBSD_3_0_BASE:1.34
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.22.0.2
	OPENBSD_2_7_BASE:1.22
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.39
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.38;

1.38
date	2006.02.06.17.51.30;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.30.22.23.53;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.19.10.24.54;	author brian;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.07.09.32.55;	author brian;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.04.16.09.28;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.24.01.06.00;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.29.08.47.43;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.14.18.04.14;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.28.23.25.28;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.11.22.13.03;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.07.14.47.54;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.29.09.32.37;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.27.01.38.26;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.27.01.34.04;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.27.00.21.08;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	99.08.02.15.28.47;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	99.07.27.23.47.21;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	99.06.23.16.49.04;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.06.02.15.58.40;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.05.31.23.57.37;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.05.14.09.35.14;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.05.09.20.04.00;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.05.08.11.06.35;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.05.01.11.31.19;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.04.26.08.55.01;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.03.29.08.20.32;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.02.06.03.22.38;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.11.10.00.32.23;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.08.31.08.16.38;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.21;	author brian;	state Exp;
branches;
next	;


desc
@@


1.39
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: ip.c,v 1.38 2006/02/06 17:51:30 jmc Exp $
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#ifndef NOINET6
#include <netinet/icmp6.h>
#include <netinet/ip6.h>
#endif
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <sys/un.h>

#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "proto.h"
#include "mbuf.h"
#include "log.h"
#include "defs.h"
#include "timer.h"
#include "fsm.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "iplist.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ip.h"
#include "ipcp.h"
#include "filter.h"
#include "descriptor.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "tun.h"


#define OPCODE_QUERY	0
#define OPCODE_IQUERY	1
#define OPCODE_STATUS	2

struct dns_header {
  u_short id;
  unsigned qr : 1;
  unsigned opcode : 4;
  unsigned aa : 1;
  unsigned tc : 1;
  unsigned rd : 1;
  unsigned ra : 1;
  unsigned z : 3;
  unsigned rcode : 4;
  u_short qdcount;
  u_short ancount;
  u_short nscount;
  u_short arcount;
};

static const char *
dns_Qclass2Txt(u_short qclass)
{
  static char failure[6];
  struct {
    u_short id;
    const char *txt;
  } qtxt[] = {
    /* rfc1035 */
    { 1, "IN" }, { 2, "CS" }, { 3, "CH" }, { 4, "HS" }, { 255, "*" }
  };
  int f;

  for (f = 0; f < sizeof qtxt / sizeof *qtxt; f++)
    if (qtxt[f].id == qclass)
      return qtxt[f].txt;

  return HexStr(qclass, failure, sizeof failure);
}

static const char *
dns_Qtype2Txt(u_short qtype)
{
  static char failure[6];
  struct {
    u_short id;
    const char *txt;
  } qtxt[] = {
    /* rfc1035/rfc1700 */
    { 1, "A" }, { 2, "NS" }, { 3, "MD" }, { 4, "MF" }, { 5, "CNAME" },
    { 6, "SOA" }, { 7, "MB" }, { 8, "MG" }, { 9, "MR" }, { 10, "NULL" },
    { 11, "WKS" }, { 12, "PTR" }, { 13, "HINFO" }, { 14, "MINFO" },
    { 15, "MX" }, { 16, "TXT" }, { 17, "RP" }, { 18, "AFSDB" },
    { 19, "X25" }, { 20, "ISDN" }, { 21, "RT" }, { 22, "NSAP" },
    { 23, "NSAP-PTR" }, { 24, "SIG" }, { 25, "KEY" }, { 26, "PX" },
    { 27, "GPOS" }, { 28, "AAAA" }, { 252, "AXFR" }, { 253, "MAILB" },
    { 254, "MAILA" }, { 255, "*" }
  };
  int f;

  for (f = 0; f < sizeof qtxt / sizeof *qtxt; f++)
    if (qtxt[f].id == qtype)
      return qtxt[f].txt;

  return HexStr(qtype, failure, sizeof failure);
}

static __inline int
PortMatch(int op, u_short pport, u_short rport)
{
  switch (op) {
  case OP_EQ:
    return pport == rport;
  case OP_GT:
    return pport > rport;
  case OP_LT:
    return pport < rport;
  default:
    return 0;
  }
}

/*
 * Return a text string representing the cproto protocol number.
 *
 * The purpose of this routine is calculate this result, for
 * the many times it is needed in FilterCheck, only on demand
 * (i.e. when the corresponding logging functions are invoked).
 *
 * This optimization saves, over the previous implementation, which
 * calculated prototxt at the beginning of FilterCheck, an
 * open/read/close system call sequence per packet, approximately
 * halving the ppp system overhead and reducing the overall (u + s)
 * time by 38%.
 *
 * The caching performed here is just a side effect.
 */
static const char *
prototxt(int cproto)
{
  static int oproto = -1;
  static char protobuff[16] = "-1";
  struct protoent *pe;

  if (cproto == oproto)
    return protobuff;
  if ((pe = getprotobynumber(cproto)) == NULL)
    snprintf(protobuff, sizeof protobuff, "%d", cproto);
  else
    snprintf(protobuff, sizeof protobuff, "%s", pe->p_name);
  oproto = cproto;
  return (protobuff);
}

/*
 * Check a packet against the given filter
 * Returns 0 to accept the packet, non-zero to drop the packet.
 * If psecs is not NULL, populate it with the timeout associated
 * with the filter rule matched.
 *
 * If filtering is enabled, the initial fragment of a datagram must
 * contain the complete protocol header, and subsequent fragments
 * must not attempt to over-write it.
 *
 * One (and only one) of pip or pip6 must be set.
 */
int
FilterCheck(const unsigned char *packet, u_int32_t family,
            const struct filter *filter, unsigned *psecs)
{
  int gotinfo;			/* true if IP payload decoded */
  int cproto;			/* IPPROTO_* protocol number if (gotinfo) */
  int estab, syn, finrst;	/* TCP state flags if (gotinfo) */
  u_short sport, dport;		/* src, dest port from packet if (gotinfo) */
  int n;			/* filter rule to process */
  int len;			/* bytes used in dbuff */
  int didname;			/* true if filter header printed */
  int match;			/* true if condition matched */
  int mindata;			/* minimum data size or zero */
  const struct filterent *fp = filter->rule;
  char dbuff[100], dstip[16];
  struct ncpaddr srcaddr, dstaddr;
  const char *payload;		/* IP payload */
  int datalen;			/* IP datagram length */

  if (fp->f_action == A_NONE)
    return 0;		/* No rule is given. Permit this packet */

#ifndef NOINET6
  if (family == AF_INET6) {
    const struct ip6_hdr *pip6 = (const struct ip6_hdr *)packet;

    ncpaddr_setip6(&srcaddr, &pip6->ip6_src);
    ncpaddr_setip6(&dstaddr, &pip6->ip6_dst);
    datalen = ntohs(pip6->ip6_plen);
    payload = packet + sizeof *pip6;
    cproto = pip6->ip6_nxt;
  } else
#endif
  {
    /*
     * Deny any packet fragment that tries to over-write the header.
     * Since we no longer have the real header available, punt on the
     * largest normal header - 20 bytes for TCP without options, rounded
     * up to the next possible fragment boundary.  Since the smallest
     * `legal' MTU is 576, and the smallest recommended MTU is 296, any
     * fragmentation within this range is dubious at best
     */
    const struct ip *pip = (const struct ip *)packet;

    len = ntohs(pip->ip_off) & IP_OFFMASK;	/* fragment offset */
    if (len > 0) {		/* Not first fragment within datagram */
      if (len < (24 >> 3)) {	/* don't allow fragment to over-write header */
        log_Printf(LogFILTER, " error: illegal header\n");
        return 1;
      }
      /* permit fragments on in and out filter */
      if (!filter->fragok) {
        log_Printf(LogFILTER, " error: illegal fragmentation\n");
        return 1;
      } else
        return 0;
    }

    ncpaddr_setip4(&srcaddr, pip->ip_src);
    ncpaddr_setip4(&dstaddr, pip->ip_dst);
    datalen = ntohs(pip->ip_len) - (pip->ip_hl << 2);
    payload = packet + (pip->ip_hl << 2);
    cproto = pip->ip_p;
  }

  gotinfo = estab = syn = finrst = didname = 0;
  sport = dport = 0;

  for (n = 0; n < MAXFILTERS; ) {
    if (fp->f_action == A_NONE) {
      n++;
      fp++;
      continue;
    }

    if (!didname) {
      log_Printf(LogDEBUG, "%s filter:\n", filter->name);
      didname = 1;
    }

    match = 0;

    if ((ncprange_family(&fp->f_src) == AF_UNSPEC ||
         ncprange_contains(&fp->f_src, &srcaddr)) &&
        (ncprange_family(&fp->f_dst) == AF_UNSPEC ||
         ncprange_contains(&fp->f_dst, &dstaddr))) {
      if (fp->f_proto != 0) {
        if (!gotinfo) {
          const struct tcphdr *th;
          const struct udphdr *uh;
          const struct icmp *ih;
#ifndef NOINET6
          const struct icmp6_hdr *ih6;
#endif
          mindata = 0;
          sport = dport = 0;
          estab = syn = finrst = -1;

          switch (cproto) {
          case IPPROTO_ICMP:
            mindata = 8;	/* ICMP must be at least 8 octets */
            ih = (const struct icmp *)payload;
            sport = ntohs(ih->icmp_type);
            if (log_IsKept(LogDEBUG))
              snprintf(dbuff, sizeof dbuff, "sport = %d", sport);
            break;

#ifndef NOINET6
          case IPPROTO_ICMPV6:
            mindata = 8;	/* ICMP must be at least 8 octets */
            ih6 = (const struct icmp6_hdr *)payload;
            sport = ntohs(ih6->icmp6_type);
            if (log_IsKept(LogDEBUG))
              snprintf(dbuff, sizeof dbuff, "sport = %d", sport);
            break;
#endif

          case IPPROTO_IGMP:
            mindata = 8;	/* IGMP uses 8-octet messages */
            break;

#ifdef IPPROTO_GRE
          case IPPROTO_GRE:
            mindata = 2;	/* GRE uses 2-octet+ messages */
            break;
#endif
#ifdef IPPROTO_OSPFIGP
          case IPPROTO_OSPFIGP:
            mindata = 8;	/* IGMP uses 8-octet messages */
            break;
#endif
#ifndef NOINET6
          case IPPROTO_IPV6:
            mindata = 20;	/* RFC2893 Section 3.5: 5 * 32bit words */
            break;
#endif

          case IPPROTO_UDP:
            mindata = 8;	/* UDP header is 8 octets */
            uh = (const struct udphdr *)payload;
            sport = ntohs(uh->uh_sport);
            dport = ntohs(uh->uh_dport);
            if (log_IsKept(LogDEBUG))
              snprintf(dbuff, sizeof dbuff, "sport = %d, dport = %d",
                       sport, dport);
            break;

          case IPPROTO_TCP:
            th = (const struct tcphdr *)payload;
            /*
             * TCP headers are variable length.  The following code
             * ensures that the TCP header length isn't de-referenced if
             * the datagram is too short
             */
            if (datalen < 20 || datalen < (th->th_off << 2)) {
              log_Printf(LogFILTER, " error: TCP header incorrect\n");
              return 1;
            }
            sport = ntohs(th->th_sport);
            dport = ntohs(th->th_dport);
            estab = (th->th_flags & TH_ACK);
            syn = (th->th_flags & TH_SYN);
            finrst = (th->th_flags & (TH_FIN|TH_RST));
            if (log_IsKept(LogDEBUG)) {
              if (!estab)
                snprintf(dbuff, sizeof dbuff,
                         "flags = %02x, sport = %d, dport = %d",
                         th->th_flags, sport, dport);
              else
                *dbuff = '\0';
            }
            break;
          default:
            break;
          }

          if (datalen < mindata) {
            log_Printf(LogFILTER, " error: proto %s must be at least"
                       " %d octets\n", prototxt(cproto), mindata);
            return 1;
          }

          if (log_IsKept(LogDEBUG)) {
            if (estab != -1) {
              len = strlen(dbuff);
              snprintf(dbuff + len, sizeof dbuff - len,
                       ", estab = %d, syn = %d, finrst = %d",
                       estab, syn, finrst);
            }
            log_Printf(LogDEBUG, " Filter: proto = %s, %s\n", prototxt(cproto),
		dbuff);
          }
          gotinfo = 1;
        }

        if (log_IsKept(LogDEBUG)) {
          if (fp->f_srcop != OP_NONE) {
            snprintf(dbuff, sizeof dbuff, ", src %s %d",
                     filter_Op2Nam(fp->f_srcop), fp->f_srcport);
            len = strlen(dbuff);
          } else
            len = 0;
          if (fp->f_dstop != OP_NONE) {
            snprintf(dbuff + len, sizeof dbuff - len,
                     ", dst %s %d", filter_Op2Nam(fp->f_dstop),
                     fp->f_dstport);
          } else if (!len)
            *dbuff = '\0';

          log_Printf(LogDEBUG, "  rule = %d: Address match, "
                     "check against proto %d%s, action = %s\n",
                     n, fp->f_proto, dbuff, filter_Action2Nam(fp->f_action));
        }

        if (cproto == fp->f_proto) {
          if ((fp->f_srcop == OP_NONE ||
               PortMatch(fp->f_srcop, sport, fp->f_srcport)) &&
              (fp->f_dstop == OP_NONE ||
               PortMatch(fp->f_dstop, dport, fp->f_dstport)) &&
              (fp->f_estab == 0 || estab) &&
              (fp->f_syn == 0 || syn) &&
              (fp->f_finrst == 0 || finrst)) {
            match = 1;
          }
        }
      } else {
        /* Address is matched and no protocol specified. Make a decision. */
        log_Printf(LogDEBUG, "  rule = %d: Address match, action = %s\n", n,
                   filter_Action2Nam(fp->f_action));
        match = 1;
      }
    } else
      log_Printf(LogDEBUG, "  rule = %d: Address mismatch\n", n);

    if (match != fp->f_invert) {
      /* Take specified action */
      if (fp->f_action < A_NONE)
        fp = &filter->rule[n = fp->f_action];
      else {
        if (fp->f_action == A_PERMIT) {
          if (psecs != NULL)
            *psecs = fp->timeout;
          if (strcmp(filter->name, "DIAL") == 0) {
            /* If dial filter then even print out accept packets */
            if (log_IsKept(LogFILTER)) {
              snprintf(dstip, sizeof dstip, "%s", ncpaddr_ntoa(&dstaddr));
              log_Printf(LogFILTER, "%sbound rule = %d accept %s "
                         "src = %s:%d dst = %s:%d\n", filter->name, n,
			 prototxt(cproto), ncpaddr_ntoa(&srcaddr),
			 sport, dstip, dport);
            }
          }
          return 0;
        } else {
          if (log_IsKept(LogFILTER)) {
            snprintf(dstip, sizeof dstip, "%s", ncpaddr_ntoa(&dstaddr));
            log_Printf(LogFILTER,
                       "%sbound rule = %d deny %s src = %s/%d dst = %s/%d\n",
                       filter->name, n, prototxt(cproto),
                       ncpaddr_ntoa(&srcaddr), sport, dstip, dport);
          }
          return 1;
        }		/* Explicit match.  Deny this packet */
      }
    } else {
      n++;
      fp++;
    }
  }

  if (log_IsKept(LogFILTER)) {
    snprintf(dstip, sizeof dstip, "%s", ncpaddr_ntoa(&dstaddr));
    log_Printf(LogFILTER,
               "%sbound rule = implicit deny %s src = %s/%d dst = %s/%d\n",
               filter->name, prototxt(cproto), ncpaddr_ntoa(&srcaddr), sport,
               dstip, dport);
  }

  return 1;		/* No rule matched, deny this packet */
}

static void
ip_LogDNS(const struct udphdr *uh, const char *direction)
{
  struct dns_header header;
  const u_short *pktptr;
  const u_char *ptr;
  u_short *hptr, tmp;
  int len;

  ptr = (const char *)uh + sizeof *uh;
  len = ntohs(uh->uh_ulen) - sizeof *uh;
  if (len < sizeof header + 5)		/* rfc1024 */
    return;

  pktptr = (const u_short *)ptr;
  hptr = (u_short *)&header;
  ptr += sizeof header;
  len -= sizeof header;

  while (pktptr < (const u_short *)ptr) {
    *hptr++ = ntohs(*pktptr);		/* Careful of macro side-effects ! */
    pktptr++;
  }

  if (header.opcode == OPCODE_QUERY && header.qr == 0) {
    /* rfc1035 */
    char namewithdot[MAXHOSTNAMELEN + 1], *n;
    const char *qtype, *qclass;
    const u_char *end;

    n = namewithdot;
    end = ptr + len - 4;
    if (end - ptr >= sizeof namewithdot)
      end = ptr + sizeof namewithdot - 1;
    while (ptr < end) {
      len = *ptr++;
      if (len > end - ptr)
        len = end - ptr;
      if (n != namewithdot)
        *n++ = '.';
      memcpy(n, ptr, len);
      ptr += len;
      n += len;
    }
    *n = '\0';

    if (log_IsKept(LogDNS)) {
      memcpy(&tmp, end, sizeof tmp);
      qtype = dns_Qtype2Txt(ntohs(tmp));
      memcpy(&tmp, end + 2, sizeof tmp);
      qclass = dns_Qclass2Txt(ntohs(tmp));

      log_Printf(LogDNS, "%sbound query %s %s %s\n",
                 direction, qclass, qtype, namewithdot);
    }
  }
}

/*
 * Check if the given packet matches the given filter.
 * One of pip or pip6 must be set.
 */
int
PacketCheck(struct bundle *bundle, u_int32_t family,
            const unsigned char *packet, int nb, struct filter *filter,
            const char *prefix, unsigned *psecs)
{
  static const char *const TcpFlags[] = {
    "FIN", "SYN", "RST", "PSH", "ACK", "URG"
  };
  const struct tcphdr *th;
  const struct udphdr *uh;
  const struct icmp *icmph;
#ifndef NOINET6
  const struct icmp6_hdr *icmp6h;
#endif
  const unsigned char *payload;
  struct ncpaddr srcaddr, dstaddr;
  int cproto, mask, len, n, pri, logit, loglen, result;
  char logbuf[200];
  int datalen, frag;
  u_char tos;

  logit = (log_IsKept(LogTCPIP) || log_IsKept(LogDNS)) &&
          (!filter || filter->logok);
  loglen = 0;
  pri = 0;

#ifndef NOINET6
  if (family == AF_INET6) {
    const struct ip6_hdr *pip6 = (const struct ip6_hdr *)packet;

    ncpaddr_setip6(&srcaddr, &pip6->ip6_src);
    ncpaddr_setip6(&dstaddr, &pip6->ip6_dst);
    datalen = ntohs(pip6->ip6_plen);
    payload = packet + sizeof *pip6;
    cproto = pip6->ip6_nxt;
    tos = 0;					/* XXX: pip6->ip6_vfc >> 4 ? */
    frag = 0;					/* XXX: ??? */
  } else
#endif
  {
    const struct ip *pip = (const struct ip *)packet;

    ncpaddr_setip4(&srcaddr, pip->ip_src);
    ncpaddr_setip4(&dstaddr, pip->ip_dst);
    datalen = ntohs(pip->ip_len) - (pip->ip_hl << 2);
    payload = packet + (pip->ip_hl << 2);
    cproto = pip->ip_p;
    tos = pip->ip_tos;
    frag = ntohs(pip->ip_off) & IP_OFFMASK;
  }

  uh = NULL;

  if (logit && loglen < sizeof logbuf) {
    if (prefix)
      snprintf(logbuf + loglen, sizeof logbuf - loglen, "%s", prefix);
    else if (filter)
      snprintf(logbuf + loglen, sizeof logbuf - loglen, "%s ", filter->name);
    else
      snprintf(logbuf + loglen, sizeof logbuf - loglen, "  ");
    loglen += strlen(logbuf + loglen);
  }

  switch (cproto) {
  case IPPROTO_ICMP:
    if (logit && loglen < sizeof logbuf) {
      len = datalen - sizeof *icmph;
      icmph = (const struct icmp *)payload;
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "ICMP: %s:%d ---> ", ncpaddr_ntoa(&srcaddr), icmph->icmp_type);
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s (%d/%d)", ncpaddr_ntoa(&dstaddr), len, nb);
      loglen += strlen(logbuf + loglen);
    }
    break;

#ifndef NOINET6
  case IPPROTO_ICMPV6:
    if (logit && loglen < sizeof logbuf) {
      len = datalen - sizeof *icmp6h;
      icmp6h = (const struct icmp6_hdr *)payload;
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "ICMP: %s:%d ---> ", ncpaddr_ntoa(&srcaddr), icmp6h->icmp6_type);
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s (%d/%d)", ncpaddr_ntoa(&dstaddr), len, nb);
      loglen += strlen(logbuf + loglen);
    }
    break;
#endif

  case IPPROTO_UDP:
    uh = (const struct udphdr *)payload;
    if (tos == IPTOS_LOWDELAY && bundle->ncp.cfg.urgent.tos)
      pri++;

    if (!frag && ncp_IsUrgentUdpPort(&bundle->ncp, ntohs(uh->uh_sport),
                                     ntohs(uh->uh_dport)))
      pri++;

    if (logit && loglen < sizeof logbuf) {
      len = datalen - sizeof *uh;
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "UDP: %s:%d ---> ", ncpaddr_ntoa(&srcaddr), ntohs(uh->uh_sport));
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s:%d (%d/%d)", ncpaddr_ntoa(&dstaddr), ntohs(uh->uh_dport),
               len, nb);
      loglen += strlen(logbuf + loglen);
    }

    if (Enabled(bundle, OPT_FILTERDECAP) &&
        payload[sizeof *uh] == HDLC_ADDR &&
        payload[sizeof *uh + 1] == HDLC_UI) {
      u_short proto;
      const char *type;

      memcpy(&proto, payload + sizeof *uh + 2, sizeof proto);
      type = NULL;

      switch (ntohs(proto)) {
        case PROTO_IP:
          snprintf(logbuf + loglen, sizeof logbuf - loglen, " contains ");
          result = PacketCheck(bundle, AF_INET, payload + sizeof *uh + 4,
                               nb - (payload - packet) - sizeof *uh - 4, filter,
                               logbuf, psecs);
          if (result != -2)
              return result;
          type = "IP";
          break;

        case PROTO_VJUNCOMP: type = "compressed VJ";   break;
        case PROTO_VJCOMP:   type = "uncompressed VJ"; break;
        case PROTO_MP:       type = "Multi-link"; break;
        case PROTO_ICOMPD:   type = "Individual link CCP"; break;
        case PROTO_COMPD:    type = "CCP"; break;
        case PROTO_IPCP:     type = "IPCP"; break;
        case PROTO_LCP:      type = "LCP"; break;
        case PROTO_PAP:      type = "PAP"; break;
        case PROTO_CBCP:     type = "CBCP"; break;
        case PROTO_LQR:      type = "LQR"; break;
        case PROTO_CHAP:     type = "CHAP"; break;
      }
      if (type) {
        snprintf(logbuf + loglen, sizeof logbuf - loglen,
                 " - %s data", type);
        loglen += strlen(logbuf + loglen);
      }
    }

    break;

#ifdef IPPROTO_GRE
  case IPPROTO_GRE:
    if (logit && loglen < sizeof logbuf) {
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
          "GRE: %s ---> ", ncpaddr_ntoa(&srcaddr));
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
              "%s (%d/%d)", ncpaddr_ntoa(&dstaddr), datalen, nb);
      loglen += strlen(logbuf + loglen);
    }
    break;
#endif

#ifdef IPPROTO_OSPFIGP
  case IPPROTO_OSPFIGP:
    if (logit && loglen < sizeof logbuf) {
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "OSPF: %s ---> ", ncpaddr_ntoa(&srcaddr));
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s (%d/%d)", ncpaddr_ntoa(&dstaddr), datalen, nb);
      loglen += strlen(logbuf + loglen);
    }
    break;
#endif

#ifndef NOINET6
  case IPPROTO_IPV6:
    if (logit && loglen < sizeof logbuf) {
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "IPv6: %s ---> ", ncpaddr_ntoa(&srcaddr));
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s (%d/%d)", ncpaddr_ntoa(&dstaddr), datalen, nb);
      loglen += strlen(logbuf + loglen);
    }

    if (Enabled(bundle, OPT_FILTERDECAP)) {
      snprintf(logbuf + loglen, sizeof logbuf - loglen, " contains ");
      result = PacketCheck(bundle, AF_INET6, payload, nb - (payload - packet),
                           filter, logbuf, psecs);
      if (result != -2)
        return result;
    }
    break;
#endif

  case IPPROTO_IPIP:
    if (logit && loglen < sizeof logbuf) {
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "IPIP: %s ---> ", ncpaddr_ntoa(&srcaddr));
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s", ncpaddr_ntoa(&dstaddr));
      loglen += strlen(logbuf + loglen);
    }

    if (Enabled(bundle, OPT_FILTERDECAP) &&
        ((const struct ip *)payload)->ip_v == 4) {
      snprintf(logbuf + loglen, sizeof logbuf - loglen, " contains ");
      result = PacketCheck(bundle, AF_INET, payload, nb - (payload - packet),
                           filter, logbuf, psecs);
      if (result != -2)
        return result;
    }
    break;

  case IPPROTO_ESP:
    if (logit && loglen < sizeof logbuf) {
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "ESP: %s ---> ", ncpaddr_ntoa(&srcaddr));
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen, "%s, spi %p",
               ncpaddr_ntoa(&dstaddr), payload);
      loglen += strlen(logbuf + loglen);
    }
    break;

  case IPPROTO_AH:
    if (logit && loglen < sizeof logbuf) {
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "AH: %s ---> ", ncpaddr_ntoa(&srcaddr));
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen, "%s, spi %p",
               ncpaddr_ntoa(&dstaddr), payload + sizeof(u_int32_t));
      loglen += strlen(logbuf + loglen);
    }
    break;

  case IPPROTO_IGMP:
    if (logit && loglen < sizeof logbuf) {
      uh = (const struct udphdr *)payload;
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "IGMP: %s:%d ---> ", ncpaddr_ntoa(&srcaddr),
               ntohs(uh->uh_sport));
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s:%d", ncpaddr_ntoa(&dstaddr), ntohs(uh->uh_dport));
      loglen += strlen(logbuf + loglen);
    }
    break;

  case IPPROTO_TCP:
    th = (const struct tcphdr *)payload;
    if (tos == IPTOS_LOWDELAY && bundle->ncp.cfg.urgent.tos)
      pri++;

    if (!frag && ncp_IsUrgentTcpPort(&bundle->ncp, ntohs(th->th_sport),
                                     ntohs(th->th_dport)))
      pri++;

    if (logit && loglen < sizeof logbuf) {
      len = datalen - (th->th_off << 2);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
           "TCP: %s:%d ---> ", ncpaddr_ntoa(&srcaddr), ntohs(th->th_sport));
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s:%d", ncpaddr_ntoa(&dstaddr), ntohs(th->th_dport));
      loglen += strlen(logbuf + loglen);
      n = 0;
      for (mask = TH_FIN; mask != 0x40; mask <<= 1) {
        if (th->th_flags & mask) {
          snprintf(logbuf + loglen, sizeof logbuf - loglen, " %s", TcpFlags[n]);
          loglen += strlen(logbuf + loglen);
        }
        n++;
      }
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "  seq:%lx  ack:%lx (%d/%d)",
               (u_long)ntohl(th->th_seq), (u_long)ntohl(th->th_ack), len, nb);
      loglen += strlen(logbuf + loglen);
      if ((th->th_flags & TH_SYN) && nb > 40) {
        const u_short *sp;

        sp = (const u_short *)(payload + 20);
        if (ntohs(sp[0]) == 0x0204) {
          snprintf(logbuf + loglen, sizeof logbuf - loglen,
                   " MSS = %d", ntohs(sp[1]));
          loglen += strlen(logbuf + loglen);
        }
      }
    }
    break;

  default:
    if (prefix)
      return -2;

    if (logit && loglen < sizeof logbuf) {
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "<%d>: %s ---> ", cproto, ncpaddr_ntoa(&srcaddr));
      loglen += strlen(logbuf + loglen);
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s (%d)", ncpaddr_ntoa(&dstaddr), nb);
      loglen += strlen(logbuf + loglen);
    }
    break;
  }

  if (filter && FilterCheck(packet, family, filter, psecs)) {
    if (logit)
      log_Printf(LogTCPIP, "%s - BLOCKED\n", logbuf);
    result = -1;
  } else {
    /* Check Keep Alive filter */
    if (logit && log_IsKept(LogTCPIP)) {
      unsigned alivesecs;

      alivesecs = 0;
      if (filter &&
          FilterCheck(packet, family, &bundle->filter.alive, &alivesecs))
        log_Printf(LogTCPIP, "%s - NO KEEPALIVE\n", logbuf);
      else if (psecs != NULL) {
        if(*psecs == 0)
          *psecs = alivesecs;
        if (*psecs) {
          if (*psecs != alivesecs)
            log_Printf(LogTCPIP, "%s - (timeout = %d / ALIVE = %d secs)\n",
                       logbuf, *psecs, alivesecs);
          else
            log_Printf(LogTCPIP, "%s - (timeout = %d secs)\n", logbuf, *psecs);
        } else
          log_Printf(LogTCPIP, "%s\n", logbuf);
      }
    }
    result = pri;
  }

  if (filter && uh && ntohs(uh->uh_dport) == 53 && log_IsKept(LogDNS))
    ip_LogDNS(uh, filter->name);

  return result;
}

static int
ip_Input(struct bundle *bundle, struct link *l, struct mbuf *bp, u_int32_t af)
{
  int nb, nw;
  struct tun_data tun;
  char *data;
  unsigned secs, alivesecs;

  nb = m_length(bp);
  if (nb > sizeof tun.data) {
    log_Printf(LogWARN, "ip_Input: %s: Packet too large (got %d, max %d)\n",
               l->name, nb, (int)(sizeof tun.data));
    m_freem(bp);
    return 0;
  }
  mbuf_Read(bp, tun.data, nb);

  secs = 0;
  if (PacketCheck(bundle, af, tun.data, nb, &bundle->filter.in,
                  NULL, &secs) < 0)
    return 0;

  alivesecs = 0;
  if (!FilterCheck(tun.data, af, &bundle->filter.alive, &alivesecs)) {
    if (secs == 0)
      secs = alivesecs;
    bundle_StartIdleTimer(bundle, secs);
  }

  if (bundle->dev.header) {
    tun.header.family = htonl(af);
    nb += sizeof tun - sizeof tun.data;
    data = (char *)&tun;
  } else
    data = tun.data;

  nw = write(bundle->dev.fd, data, nb);
  if (nw != nb) {
    if (nw == -1)
      log_Printf(LogERROR, "ip_Input: %s: wrote %d, got %s\n",
                 l->name, nb, strerror(errno));
    else
      log_Printf(LogERROR, "ip_Input: %s: wrote %d, got %d\n", l->name, nb, nw);
  }

  return nb;
}

struct mbuf *
ipv4_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
{
  int nb;

  if (bundle->ncp.ipcp.fsm.state != ST_OPENED) {
    log_Printf(LogWARN, "ipv4_Input: IPCP not open - packet dropped\n");
    m_freem(bp);
    return NULL;
  }

  m_settype(bp, MB_IPIN);

  nb = ip_Input(bundle, l, bp, AF_INET);
  ipcp_AddInOctets(&bundle->ncp.ipcp, nb);

  return NULL;
}

#ifndef NOINET6
struct mbuf *
ipv6_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
{
  int nb;

  if (bundle->ncp.ipv6cp.fsm.state != ST_OPENED) {
    log_Printf(LogWARN, "ipv6_Input: IPV6CP not open - packet dropped\n");
    m_freem(bp);
    return NULL;
  }

  m_settype(bp, MB_IPV6IN);

  nb = ip_Input(bundle, l, bp, AF_INET6);
  ipv6cp_AddInOctets(&bundle->ncp.ipv6cp, nb);

  return NULL;
}
#endif
@


1.38
log
@typos from alexey dobriyan;
@
text
@d28 1
a28 1
 * $OpenBSD: ip.c,v 1.37 2004/05/30 22:23:53 tedu Exp $
@


1.37
log
@only call getprotobynumber() when necessary.  from freebsd (dds@@)
testing jmc todd.  ok deraadt
@
text
@d28 1
a28 1
 * $OpenBSD: ip.c,v 1.36 2002/06/15 08:02:00 brian Exp $
d470 1
a470 1
        }		/* Explict match.  Deny this packet */
@


1.36
log
@Tidy up end of line whitespace
@
text
@d28 1
a28 1
 * $OpenBSD: ip.c,v 1.35 2002/05/16 01:13:39 brian Exp $
d165 32
d222 1
a222 2
  char dbuff[100], dstip[16], prototxt[16];
  struct protoent *pe;
a272 4
  if ((pe = getprotobynumber(cproto)) == NULL)
    snprintf(prototxt, sizeof prototxt, "%d", cproto);
  else
    snprintf(prototxt, sizeof prototxt, "%s", pe->p_name);
d386 1
a386 1
                       " %d octets\n", prototxt, mindata);
d397 2
a398 1
            log_Printf(LogDEBUG, " Filter: proto = %s, %s\n", prototxt, dbuff);
d455 3
a457 2
                         "src = %s:%d dst = %s:%d\n", filter->name, n, prototxt,
                         ncpaddr_ntoa(&srcaddr), sport, dstip, dport);
d466 1
a466 1
                       filter->name, n, prototxt,
d482 1
a482 1
               filter->name, prototxt, ncpaddr_ntoa(&srcaddr), sport,
@


1.35
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: ip.c,v 1.34 2001/08/19 23:22:17 brian Exp $
d221 1
a221 1
    len = ntohs(pip->ip_off) & IP_OFFMASK;	/* fragment offset */ 
d234 1
a234 1
  
d435 2
a436 2
            log_Printf(LogFILTER, 
                       "%sbound rule = %d deny %s src = %s/%d dst = %s/%d\n", 
d440 1
a440 1
          return 1;	
d451 2
a452 2
    log_Printf(LogFILTER, 
               "%sbound rule = implicit deny %s src = %s/%d dst = %s/%d\n", 
d852 1
a852 1
            log_Printf(LogTCPIP, "%s - (timeout = %d / ALIVE = %d secs)\n", 
@


1.34
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: ip.c,v 1.33 2001/06/19 10:24:54 brian Exp $
a42 1
#include <arpa/inet.h>
a47 1
#include <stdlib.h>
@


1.33
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d28 1
a28 1
 * $OpenBSD: ip.c,v 1.32 2001/06/13 21:33:41 brian Exp $
d36 4
d47 1
d49 1
d66 2
d78 2
a81 1
#include "ip.h"
d167 4
a170 2
 *  Check a packet against a defined filter
 *  Returns 0 to accept the packet, non-zero to drop the packet
d172 5
a176 3
 *  If filtering is enabled, the initial fragment of a datagram must
 *  contain the complete protocol header, and subsequent fragments
 *  must not attempt to over-write it.
d178 3
a180 2
static int
FilterCheck(const struct ip *pip, const struct filter *filter, unsigned *psecs)
d183 1
a183 1
  int cproto;			/* P_* protocol type if (gotinfo) */
d190 1
d192 5
a196 1
  char dbuff[100], dstip[16];
d201 41
a241 20
  /*
   * Deny any packet fragment that tries to over-write the header.
   * Since we no longer have the real header available, punt on the
   * largest normal header - 20 bytes for TCP without options, rounded
   * up to the next possible fragment boundary.  Since the smallest
   * `legal' MTU is 576, and the smallest recommended MTU is 296, any
   * fragmentation within this range is dubious at best
   */
  len = ntohs(pip->ip_off) & IP_OFFMASK;	/* fragment offset */ 
  if (len > 0) {		/* Not first fragment within datagram */
    if (len < (24 >> 3)) {	/* don't allow fragment to over-write header */
      log_Printf(LogFILTER, " error: illegal header\n");
      return 1;
    }
    /* permit fragments on in and out filter */
    if (!filter->fragok) {
      log_Printf(LogFILTER, " error: illegal fragmentation\n");
      return 1;
    } else
      return 0;
d243 6
a248 2
  
  cproto = gotinfo = estab = syn = finrst = didname = 0;
d250 1
d264 6
a269 5
    if (!((pip->ip_src.s_addr ^ fp->f_src.ipaddr.s_addr) &
          fp->f_src.mask.s_addr) &&
        !((pip->ip_dst.s_addr ^ fp->f_dst.ipaddr.s_addr) &
          fp->f_dst.mask.s_addr)) {
      if (fp->f_proto != P_NONE) {
a270 1
          const char *ptop = (const char *) pip + (pip->ip_hl << 2);
d274 6
a279 1
          int datalen;	/* IP datagram length */
d281 1
a281 2
          datalen = ntohs(pip->ip_len) - (pip->ip_hl << 2);
          switch (pip->ip_p) {
d283 6
a288 5
            cproto = P_ICMP;
            if (datalen < 8) {	/* ICMP must be at least 8 octets */
              log_Printf(LogFILTER, " error: ICMP must be at least 8 octets\n");
              return 1;
            }
d290 5
a294 3
            ih = (const struct icmp *) ptop;
            sport = ih->icmp_type;
            estab = syn = finrst = -1;
d298 2
d301 1
a301 7
            cproto = P_IGMP;
            if (datalen < 8) {	/* IGMP uses 8-octet messages */
              log_Printf(LogFILTER, " error: IGMP must be at least 8 octets\n");
              return 1;
            }
            estab = syn = finrst = -1;
            sport = ntohs(0);
d303 1
d306 1
a306 7
            cproto = P_GRE;
            if (datalen < 2) {    /* GRE uses 2-octet+ messages */
              log_Printf(LogFILTER, " error: GRE must be at least 2 octets\n");
              return 1;
            }
            estab = syn = finrst = -1;
            sport = ntohs(0);
d311 1
a311 7
            cproto = P_OSPF;
            if (datalen < 8) {	/* IGMP uses 8-octet messages */
              log_Printf(LogFILTER, " error: IGMP must be at least 8 octets\n");
              return 1;
            }
            estab = syn = finrst = -1;
            sport = ntohs(0);
d314 3
a316 14
          case IPPROTO_ESP:
            cproto = P_ESP;
            estab = syn = finrst = -1;
            sport = ntohs(0);
            break;
          case IPPROTO_AH:
            cproto = P_AH;
            estab = syn = finrst = -1;
            sport = ntohs(0);
            break;
          case IPPROTO_IPIP:
            cproto = P_IPIP;
            sport = dport = 0;
            estab = syn = finrst = -1;
d318 2
d321 2
a322 8
            cproto = P_UDP;
            if (datalen < 8) {	/* UDP header is 8 octets */
              log_Printf(LogFILTER, " error: UDP/IPIP"
                         " must be at least 8 octets\n");
              return 1;
            }

            uh = (const struct udphdr *) ptop;
a324 1
            estab = syn = finrst = -1;
d329 1
d331 3
a333 3
            cproto = P_TCP;
            th = (const struct tcphdr *) ptop;
            /* TCP headers are variable length.  The following code
d356 7
a362 2
            log_Printf(LogFILTER, " error: unknown protocol\n");
            return 1;		/* We'll block unknown type of packet */
d372 1
a372 2
            log_Printf(LogDEBUG, " Filter: proto = %s, %s\n",
                       filter_Proto2Nam(cproto), dbuff);
d376 1
d392 2
a393 3
                     "check against proto %s%s, action = %s\n",
                     n, filter_Proto2Nam(fp->f_proto),
                     dbuff, filter_Action2Nam(fp->f_action));
d427 1
a427 1
              snprintf(dstip, sizeof dstip, "%s", inet_ntoa(pip->ip_dst));
d429 2
a430 3
                         "src = %s/%d dst = %s/%d\n", 
                         filter->name, n, filter_Proto2Nam(cproto),
                         inet_ntoa(pip->ip_src), sport, dstip, dport);
d436 1
a436 1
            snprintf(dstip, sizeof dstip, "%s", inet_ntoa(pip->ip_dst));
d439 2
a440 2
                       filter->name, n, filter_Proto2Nam(cproto),
                       inet_ntoa(pip->ip_src), sport, dstip, dport);
d443 1
a443 1
        }		/* Explict math.  Deny this packet */
d452 1
a452 1
    snprintf(dstip, sizeof dstip, "%s", inet_ntoa(pip->ip_dst));
d455 2
a456 2
               filter->name, filter_Proto2Nam(cproto), 
               inet_ntoa(pip->ip_src), sport, dstip, dport);
d459 1
a459 15
  return 1;		/* No rule is mached. Deny this packet */
}

#ifdef notdef
static void
IcmpError(struct ip *pip, int code)
{
  struct mbuf *bp;

  if (pip->ip_p != IPPROTO_ICMP) {
    bp = m_get(m_len, MB_IPIN);
    memcpy(MBUF_CTOP(bp), ptr, m_len);
    vj_SendFrame(bp);
    ipcp_AddOutOctets(m_len);
  }
a460 1
#endif
d521 2
a522 1
 *  For debugging aid.
d525 3
a527 2
PacketCheck(struct bundle *bundle, unsigned char *cp, int nb,
            struct filter *filter, const char *prefix, unsigned *psecs)
d532 9
a540 6
  struct ip *pip;
  struct tcphdr *th;
  struct udphdr *uh;
  struct icmp *icmph;
  unsigned char *ptop;
  int mask, len, n, pri, logit, loglen, result;
d542 2
d550 25
a574 1
  pip = (struct ip *)cp;
a585 1
  ptop = (cp + (pip->ip_hl << 2));
d587 1
a587 1
  switch (pip->ip_p) {
d590 2
a591 2
      len = ntohs(pip->ip_len) - (pip->ip_hl << 2) - sizeof *icmph;
      icmph = (struct icmp *) ptop;
d593 1
a593 1
               "ICMP: %s:%d ---> ", inet_ntoa(pip->ip_src), icmph->icmp_type);
d596 1
a596 2
               "%s:%d (%d/%d)", inet_ntoa(pip->ip_dst), icmph->icmp_type,
               len, nb);
d601 15
d617 2
a618 2
    uh = (struct udphdr *) ptop;
    if (pip->ip_tos == IPTOS_LOWDELAY && bundle->ncp.ipcp.cfg.urgent.tos)
d621 2
a622 3
    if ((ntohs(pip->ip_off) & IP_OFFMASK) == 0 &&
        ipcp_IsUrgentUdpPort(&bundle->ncp.ipcp, ntohs(uh->uh_sport),
                          ntohs(uh->uh_dport)))
d626 1
a626 1
      len = ntohs(pip->ip_len) - (pip->ip_hl << 2) - sizeof *uh;
d628 1
a628 1
               "UDP: %s:%d ---> ", inet_ntoa(pip->ip_src), ntohs(uh->uh_sport));
d631 1
a631 1
               "%s:%d (%d/%d)", inet_ntoa(pip->ip_dst), ntohs(uh->uh_dport),
d637 2
a638 1
        ptop[sizeof *uh] == HDLC_ADDR && ptop[sizeof *uh + 1] == HDLC_UI) {
d642 1
a642 1
      memcpy(&proto, ptop + sizeof *uh + 2, sizeof proto);
d648 2
a649 2
          result = PacketCheck(bundle, ptop + sizeof *uh + 4,
                               nb - (ptop - cp) - sizeof *uh - 4, filter,
a679 1
      len = ntohs(pip->ip_len) - (pip->ip_hl << 2);
d681 1
a681 1
          "GRE: %s ---> ", inet_ntoa(pip->ip_src));
d684 1
a684 1
              "%s (%d/%d)", inet_ntoa(pip->ip_dst), len, nb);
a692 1
      len = ntohs(pip->ip_len) - (pip->ip_hl << 2);
d694 1
a694 1
               "OSPF: %s ---> ", inet_ntoa(pip->ip_src));
d697 1
a697 1
               "%s (%d/%d)", inet_ntoa(pip->ip_dst), len, nb);
d703 21
d727 1
a727 1
               "IPIP: %s ---> ", inet_ntoa(pip->ip_src));
d730 1
a730 1
               "%s", inet_ntoa(pip->ip_dst));
d732 1
d734 7
a740 7
      if (((struct ip *)ptop)->ip_v == 4) {
        snprintf(logbuf + loglen, sizeof logbuf - loglen, " contains ");
        result = PacketCheck(bundle, ptop, nb - (ptop - cp), filter,
                             logbuf, psecs);
        if (result != -2)
          return result;
      }
d747 1
a747 1
               "ESP: %s ---> ", inet_ntoa(pip->ip_src));
d750 1
a750 1
               inet_ntoa(pip->ip_dst), ptop);
d758 1
a758 1
               "AH: %s ---> ", inet_ntoa(pip->ip_src));
d761 1
a761 1
               inet_ntoa(pip->ip_dst), ptop + sizeof(u_int32_t));
d768 1
a768 1
      uh = (struct udphdr *) ptop;
d770 1
a770 1
               "IGMP: %s:%d ---> ", inet_ntoa(pip->ip_src),
d774 1
a774 1
               "%s:%d", inet_ntoa(pip->ip_dst), ntohs(uh->uh_dport));
d780 2
a781 2
    th = (struct tcphdr *) ptop;
    if (pip->ip_tos == IPTOS_LOWDELAY && bundle->ncp.ipcp.cfg.urgent.tos)
d784 2
a785 3
    if ((ntohs(pip->ip_off) & IP_OFFMASK) == 0 &&
        ipcp_IsUrgentTcpPort(&bundle->ncp.ipcp, ntohs(th->th_sport),
                          ntohs(th->th_dport)))
d789 1
a789 1
      len = ntohs(pip->ip_len) - (pip->ip_hl << 2) - (th->th_off << 2);
d791 1
a791 1
           "TCP: %s:%d ---> ", inet_ntoa(pip->ip_src), ntohs(th->th_sport));
d794 1
a794 1
               "%s:%d", inet_ntoa(pip->ip_dst), ntohs(th->th_dport));
d809 1
a809 1
        u_short *sp;
d811 1
a811 2
        ptop += 20;
        sp = (u_short *) ptop;
d824 10
d836 1
a836 1
  if (filter && FilterCheck(pip, filter, psecs)) {
a838 4
#ifdef notdef
    if (direction == 0)
      IcmpError(pip, pri);
#endif
d846 2
a847 1
      if (filter && FilterCheck(pip, &bundle->filter.alive, &alivesecs))
d871 2
a872 2
struct mbuf *
ip_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
a875 1
  struct ip *pip;
a878 7
  if (bundle->ncp.ipcp.fsm.state != ST_OPENED) {
    log_Printf(LogWARN, "ip_Input: IPCP not open - packet dropped\n");
    m_freem(bp);
    return NULL;
  }

  m_settype(bp, MB_IPIN);
d884 1
a884 1
    return NULL;
d889 3
a891 2
  if (PacketCheck(bundle, tun.data, nb, &bundle->filter.in, NULL, &secs) < 0)
    return NULL;
a892 1
  pip = (struct ip *)tun.data;
d894 1
a894 1
  if (!FilterCheck(pip, &bundle->filter.alive, &alivesecs)) {
a899 2
  ipcp_AddInOctets(&bundle->ncp.ipcp, nb);

d901 1
a901 1
    tun.header.family = htonl(AF_INET);
d916 1
a916 1
  return NULL;
d919 2
a920 2
void
ip_Enqueue(struct ipcp *ipcp, int pri, char *ptr, int count)
d922 1
a922 1
  struct mbuf *bp;
d924 4
a927 14
  if (pri < 0 || pri >= IPCP_QUEUES(ipcp))
    log_Printf(LogERROR, "Can't store in ip queue %d\n", pri);
  else {
    /*
     * We allocate an extra 6 bytes, four at the front and two at the end.
     * This is an optimisation so that we need to do less work in
     * m_prepend() in acf_LayerPush() and proto_LayerPush() and
     * appending in hdlc_LayerPush().
     */
    bp = m_get(count + 6, MB_IPOUT);
    bp->m_offset += 4;
    bp->m_len -= 6;
    memcpy(MBUF_CTOP(bp), ptr, count);
    m_enqueue(ipcp->Queue + pri, bp);
a928 1
}
d930 1
a930 4
void
ip_DeleteQueue(struct ipcp *ipcp)
{
  struct mqueue *queue;
d932 2
a933 4
  for (queue = ipcp->Queue; queue < ipcp->Queue + IPCP_QUEUES(ipcp); queue++)
    while (queue->top)
      m_freem(m_dequeue(queue));
}
d935 1
a935 11
size_t
ip_QueueLen(struct ipcp *ipcp)
{
  struct mqueue *queue;
  size_t result;

  result = 0;
  for (queue = ipcp->Queue; queue < ipcp->Queue + IPCP_QUEUES(ipcp); queue++)
    result += queue->len;

  return result;
d938 3
a940 2
int
ip_PushPacket(struct link *l, struct bundle *bundle)
d942 1
a942 7
  struct ipcp *ipcp = &bundle->ncp.ipcp;
  struct mqueue *queue;
  struct mbuf *bp;
  struct ip *pip;
  int m_len;
  u_int32_t secs = 0;
  unsigned alivesecs = 0;
d944 5
a948 2
  if (ipcp->fsm.state != ST_OPENED)
    return 0;
d950 1
a950 7
  /*
   * If ccp is not open but is required, do nothing.
   */
  if (l->ccp.fsm.state != ST_OPENED && ccp_Required(&l->ccp)) {
    log_Printf(LogPHASE, "%s: Not transmitting... waiting for CCP\n", l->name);
    return 0;
  }
d952 2
a953 18
  queue = ipcp->Queue + IPCP_QUEUES(ipcp) - 1;
  do {
    if (queue->top) {
      bp = m_dequeue(queue);
      bp = mbuf_Read(bp, &secs, sizeof secs);
      bp = m_pullup(bp);
      m_len = m_length(bp);
      pip = (struct ip *)MBUF_CTOP(bp);
      if (!FilterCheck(pip, &bundle->filter.alive, &alivesecs)) {
        if (secs == 0)
          secs = alivesecs;
        bundle_StartIdleTimer(bundle, secs);
      }
      link_PushPacket(l, bp, bundle, 0, PROTO_IP);
      ipcp_AddOutOctets(ipcp, m_len);
      return 1;
    }
  } while (queue-- != ipcp->Queue);
d955 1
a955 1
  return 0;
d957 1
@


1.32
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d908 8
@


1.31
log
@Depricate the -alias option (it's been -nat for a long time)
Handle carriage-return/line-feed stuff for ftp natting more generically
Fix an alignment bug when logging DNS traffic
Fix/add some copyrights
@
text
@d1 5
a5 2
/*
 *		PPP IP Protocol Interface
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 17
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: ip.c,v 1.30 2001/06/04 16:09:28 brian Exp $
 *
 *	TODO:
 *		o Return ICMP message for filterd packet
 *		  and optionaly record it into log.
d30 1
@


1.30
log
@Show the correct dial timeout when a random pause is configured
Understand ipencap traffic properly
Optimise out SIOCIFADDR ioctls that aren't necessary
Handle peers that don't send an initial IFADDR option during IPCP negotiations
Fix markup for the /etc/ttys example
Always use 4 arguments in examples of ``set ifaddr''
@
text
@d20 1
a20 1
 * $OpenBSD: ip.c,v 1.29 2001/03/24 01:06:00 brian Exp $
d453 1
a453 1
  u_short *hptr;
a491 2
    qtype = dns_Qtype2Txt(ntohs(*(const u_short *)end));
    qclass = dns_Qclass2Txt(ntohs(*(const u_short *)(end + 2)));
d493 9
a501 2
    log_Printf(LogDNS, "%sbound query %s %s %s\n",
               direction, qclass, qtype, namewithdot);
@


1.29
log
@Remove some unprotected prototype variable names
MAXPATHLEN -> PATH_MAX
Handle ENOENT from opening /dev/tun* properly
Rename _PATH_PPP -> PPP_CONFDIR and allow it to be redefined at compile time
Reduce MIN_LQRPERIOD and MIN_FSMRETRY to 1 second
Be smarter about identifying sockets on stdin
Allow primary DNS IP negotiation when the secondary IP has been rejected
Fix the call to PacketAliasProxyRule() properly.
Add/fix some comments
Fix man page markups; ru@@FreeBSD.org
Use localhost when no hostname is configured
@
text
@d20 1
a20 1
 * $OpenBSD: ip.c,v 1.28 2001/01/29 08:47:43 brian Exp $
d282 5
a287 1
          case IPPROTO_IPIP:
d290 2
a291 1
              log_Printf(LogFILTER, " error: UDP must be at least 8 octets\n");
a642 1
      uh = (struct udphdr *) ptop;
d644 1
a644 2
               "IPIP: %s:%d ---> ", inet_ntoa(pip->ip_src),
               ntohs(uh->uh_sport));
d647 1
a647 1
               "%s:%d", inet_ntoa(pip->ip_dst), ntohs(uh->uh_dport));
d649 8
@


1.28
log
@Fix some log_Printf() casting; NetBSD (pkgsrc)
@
text
@d20 1
a20 1
 * $OpenBSD: ip.c,v 1.27 2000/09/14 18:04:14 brian Exp $
d468 1
a468 1
    char name[MAXHOSTNAMELEN + 1], *n;
d472 1
a472 1
    n = name;
d474 2
a475 2
    if (end - ptr > MAXHOSTNAMELEN)
      end = ptr + MAXHOSTNAMELEN;
d480 1
a480 1
      if (n != name)
d491 1
a491 1
               direction, qclass, qtype, name);
@


1.27
log
@Understand IPPROTO_ESP and IPPROTO_AH packets

Submitted by: Angelos D. Keromytis <angelos@@dsl.cis.upenn.edu>
@
text
@d20 1
a20 1
 * $OpenBSD: ip.c,v 1.26 2000/08/28 23:25:28 brian Exp $
d654 2
a655 3
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s, spi %08x", inet_ntoa(pip->ip_dst),
               (u_int32_t) ptop);
d665 2
a666 3
      snprintf(logbuf + loglen, sizeof logbuf - loglen,
               "%s, spi %08x", inet_ntoa(pip->ip_dst),
               (u_int32_t) (ptop + sizeof(u_int32_t)));
@


1.26
log
@Add LogFILTER logging to log packets allowed by the dial filter and
dropped by any filter.

Submitted by: Mark Hannon <markhannon@@one.net.au>

with some small tweaks by me.
@
text
@d20 1
a20 1
 * $OpenBSD: ip.c,v 1.25 2000/07/11 22:13:03 brian Exp $
d272 10
d645 24
@


1.25
log
@Allow a ``timeout secs'' filter option to let specific packet types
effect the idle timer in different ways.

Submitted by: Stefan Esser <se@@freebsd.org>

With adjustments by me to document the option in the man page and to
give the same semantics for outgoing traffic as incoming.

I made the style more consistent in ip.c - this should really have
been done as a separate commit.
@
text
@d20 1
a20 1
 * $OpenBSD: ip.c,v 1.24 2000/07/07 14:47:54 brian Exp $
d172 1
a172 1
  char dbuff[100];
d187 2
a188 1
    if (len < (24 >> 3))	/* don't allow fragment to over-write header */
d190 1
d192 5
a196 1
    return !filter->fragok;
d230 2
a231 1
            if (datalen < 8)	/* ICMP must be at least 8 octets */
d233 2
d243 2
a244 1
            if (datalen < 8)	/* IGMP uses 8-octet messages */
d246 1
d253 2
a254 1
            if (datalen < 2)    /* GRE uses 2-octet+ messages */
d256 1
d264 2
a265 1
            if (datalen < 8)	/* IGMP uses 8-octet messages */
d267 1
d275 2
a276 1
            if (datalen < 8)	/* UDP header is 8 octets */
d278 2
d295 2
a296 1
            if (datalen < 20 || datalen < (th->th_off << 2))
d298 1
d314 1
d374 1
a374 1
      else
d378 10
d389 11
a399 2
        } else
          return 1;
d405 9
@


1.24
log
@o  Log the (payload/size) of all packet types, not just TCP packets

o  If the new ``filter-decapsulation'' is enabled, delve into UDP packets
   that contain 0xff 0x03 as the first two bytes, and if we recognise it
   as PROTO_IP, decapsulate it for the purpose of filter checking.

   If we recognise it as PROTO_<anything else> mention this for logging
   purposes only.

This change is aimed at people running PPPoUDP where the UDP traffic is
being sent over another PPP link.  It's desireable to have the top level
link connected all the time, but to have the bottom level link capable
of decapsulating the traffic and comparing the payload against the filters,
thus allowing ``set filter dial ...'' to work in tunnelled environments.

The caveat here is that the top ppp cannot employ any compression layers
without making the data unreadable for the bottom ppp.  ``disable deflate
pred1 vj'' and ``deny deflate pred1 vj'' is suggested.
@
text
@d20 1
a20 1
 * $OpenBSD: ip.c,v 1.23 2000/06/13 09:57:51 brian Exp $
d142 1
a142 1
    return (pport == rport);
d144 1
a144 1
    return (pport > rport);
d146 1
a146 1
    return (pport < rport);
d148 1
a148 1
    return (0);
d161 1
a161 1
FilterCheck(const struct ip *pip, const struct filter *filter)
d175 1
a175 1
    return (0);		/* No rule is given. Permit this packet */
d177 2
a178 1
  /* Deny any packet fragment that tries to over-write the header.
d183 2
a184 1
   * fragmentation within this range is dubious at best */
d188 1
a188 1
      return (1);
d190 1
a190 1
    return (!filter->fragok);
d209 3
a211 3
	  fp->f_src.mask.s_addr) &&
	!((pip->ip_dst.s_addr ^ fp->f_dst.ipaddr.s_addr) &
	  fp->f_dst.mask.s_addr)) {
d213 26
a238 26
	if (!gotinfo) {
	  const char *ptop = (const char *) pip + (pip->ip_hl << 2);
	  const struct tcphdr *th;
	  const struct udphdr *uh;
	  const struct icmp *ih;
	  int datalen;	/* IP datagram length */

	  datalen = ntohs(pip->ip_len) - (pip->ip_hl << 2);
	  switch (pip->ip_p) {
	  case IPPROTO_ICMP:
	    cproto = P_ICMP;
	    if (datalen < 8)	/* ICMP must be at least 8 octets */
	      return (1);
	    ih = (const struct icmp *) ptop;
	    sport = ih->icmp_type;
	    estab = syn = finrst = -1;
	    if (log_IsKept(LogDEBUG))
	      snprintf(dbuff, sizeof dbuff, "sport = %d", sport);
	    break;
	  case IPPROTO_IGMP:
	    cproto = P_IGMP;
	    if (datalen < 8)	/* IGMP uses 8-octet messages */
	      return (1);
	    estab = syn = finrst = -1;
	    sport = ntohs(0);
	    break;
d243 1
a243 1
              return (1);
d249 7
a255 7
	  case IPPROTO_OSPFIGP:
	    cproto = P_OSPF;
	    if (datalen < 8)	/* IGMP uses 8-octet messages */
	      return (1);
	    estab = syn = finrst = -1;
	    sport = ntohs(0);
	    break;
d257 83
a339 83
	  case IPPROTO_UDP:
	  case IPPROTO_IPIP:
	    cproto = P_UDP;
	    if (datalen < 8)	/* UDP header is 8 octets */
	      return (1);
	    uh = (const struct udphdr *) ptop;
	    sport = ntohs(uh->uh_sport);
	    dport = ntohs(uh->uh_dport);
	    estab = syn = finrst = -1;
	    if (log_IsKept(LogDEBUG))
	      snprintf(dbuff, sizeof dbuff, "sport = %d, dport = %d",
		       sport, dport);
	    break;
	  case IPPROTO_TCP:
	    cproto = P_TCP;
	    th = (const struct tcphdr *) ptop;
	    /* TCP headers are variable length.  The following code
	     * ensures that the TCP header length isn't de-referenced if
	     * the datagram is too short
	     */
	    if (datalen < 20 || datalen < (th->th_off << 2))
	      return (1);
	    sport = ntohs(th->th_sport);
	    dport = ntohs(th->th_dport);
	    estab = (th->th_flags & TH_ACK);
	    syn = (th->th_flags & TH_SYN);
	    finrst = (th->th_flags & (TH_FIN|TH_RST));
	    if (log_IsKept(LogDEBUG)) {
	      if (!estab)
		snprintf(dbuff, sizeof dbuff,
			 "flags = %02x, sport = %d, dport = %d",
			 th->th_flags, sport, dport);
	      else
		*dbuff = '\0';
	    }
	    break;
	  default:
	    return (1);	/* We'll block unknown type of packet */
	  }

	  if (log_IsKept(LogDEBUG)) {
	    if (estab != -1) {
	      len = strlen(dbuff);
	      snprintf(dbuff + len, sizeof dbuff - len,
		       ", estab = %d, syn = %d, finrst = %d",
		       estab, syn, finrst);
	    }
	    log_Printf(LogDEBUG, " Filter: proto = %s, %s\n",
		       filter_Proto2Nam(cproto), dbuff);
	  }
	  gotinfo = 1;
	}
	if (log_IsKept(LogDEBUG)) {
	  if (fp->f_srcop != OP_NONE) {
	    snprintf(dbuff, sizeof dbuff, ", src %s %d",
		     filter_Op2Nam(fp->f_srcop), fp->f_srcport);
	    len = strlen(dbuff);
	  } else
	    len = 0;
	  if (fp->f_dstop != OP_NONE) {
	    snprintf(dbuff + len, sizeof dbuff - len,
		     ", dst %s %d", filter_Op2Nam(fp->f_dstop),
		     fp->f_dstport);
	  } else if (!len)
	    *dbuff = '\0';

	  log_Printf(LogDEBUG, "  rule = %d: Address match, "
		     "check against proto %s%s, action = %s\n",
		     n, filter_Proto2Nam(fp->f_proto),
		     dbuff, filter_Action2Nam(fp->f_action));
	}

	if (cproto == fp->f_proto) {
	  if ((fp->f_srcop == OP_NONE ||
	       PortMatch(fp->f_srcop, sport, fp->f_srcport)) &&
	      (fp->f_dstop == OP_NONE ||
	       PortMatch(fp->f_dstop, dport, fp->f_dstport)) &&
	      (fp->f_estab == 0 || estab) &&
	      (fp->f_syn == 0 || syn) &&
	      (fp->f_finrst == 0 || finrst)) {
	    match = 1;
	  }
	}
d341 4
a344 4
	/* Address is matched and no protocol specified. Make a decision. */
	log_Printf(LogDEBUG, "  rule = %d: Address match, action = %s\n", n,
		   filter_Action2Nam(fp->f_action));
	match = 1;
d352 1
a352 1
	fp = &filter->rule[n = fp->f_action];
d354 6
a359 1
	return (fp->f_action != A_PERMIT);
d365 1
a365 1
  return (1);		/* No rule is mached. Deny this packet */
d403 1
a403 1
    *hptr++ = ntohs(*pktptr);	/* Careful of macro side-effects ! */
d441 1
a441 1
            struct filter *filter, const char *prefix)
d479 1
a479 1
	     "ICMP: %s:%d ---> ", inet_ntoa(pip->ip_src), icmph->icmp_type);
d482 1
a482 1
	       "%s:%d (%d/%d)", inet_ntoa(pip->ip_dst), icmph->icmp_type,
d501 1
a501 1
	   "UDP: %s:%d ---> ", inet_ntoa(pip->ip_src), ntohs(uh->uh_sport));
d504 2
a505 2
	       "%s:%d (%d/%d)", inet_ntoa(pip->ip_dst), ntohs(uh->uh_dport),
	       len, nb);
d522 1
a522 1
                               logbuf);
d568 1
a568 1
	   "OSPF: %s ---> ", inet_ntoa(pip->ip_src));
d571 1
a571 1
	       "%s (%d/%d)", inet_ntoa(pip->ip_dst), len, nb);
d581 2
a582 1
	   "IPIP: %s:%d ---> ", inet_ntoa(pip->ip_src), ntohs(uh->uh_sport));
d585 1
a585 1
	       "%s:%d", inet_ntoa(pip->ip_dst), ntohs(uh->uh_dport));
d594 2
a595 1
	   "IGMP: %s:%d ---> ", inet_ntoa(pip->ip_src), ntohs(uh->uh_sport));
d598 1
a598 1
	       "%s:%d", inet_ntoa(pip->ip_dst), ntohs(uh->uh_dport));
d616 1
a616 1
	   "TCP: %s:%d ---> ", inet_ntoa(pip->ip_src), ntohs(th->th_sport));
d619 1
a619 1
	       "%s:%d", inet_ntoa(pip->ip_dst), ntohs(th->th_dport));
d623 5
a627 5
	if (th->th_flags & mask) {
	  snprintf(logbuf + loglen, sizeof logbuf - loglen, " %s", TcpFlags[n]);
	  loglen += strlen(logbuf + loglen);
	}
	n++;
d630 2
a631 2
	       "  seq:%lx  ack:%lx (%d/%d)",
	       (u_long)ntohl(th->th_seq), (u_long)ntohl(th->th_ack), len, nb);
d634 1
a634 1
	u_short *sp;
d636 7
a642 7
	ptop += 20;
	sp = (u_short *) ptop;
	if (ntohs(sp[0]) == 0x0204) {
	  snprintf(logbuf + loglen, sizeof logbuf - loglen,
		   " MSS = %d", ntohs(sp[1]));
	  loglen += strlen(logbuf + loglen);
	}
d652 1
a652 1
  if (filter && FilterCheck(pip, filter)) {
d663 4
a666 1
      if (filter && FilterCheck(pip, &bundle->filter.alive))
d668 12
a679 2
      else
        log_Printf(LogTCPIP, "%s\n", logbuf);
d697 1
d715 2
a716 1
  if (PacketCheck(bundle, tun.data, nb, &bundle->filter.in, NULL) < 0)
d720 6
a725 2
  if (!FilterCheck(pip, &bundle->filter.alive))
    bundle_StartIdleTimer(bundle);
d730 1
a730 1
    tun.family = htonl(AF_INET);
d801 2
d810 3
a812 1
      bp = m_pullup(m_dequeue(queue));
d815 5
a819 2
      if (!FilterCheck(pip, &bundle->filter.alive))
        bundle_StartIdleTimer(bundle);
@


1.23
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d20 1
a20 1
 * $OpenBSD: ip.c,v 1.22 2000/03/29 09:32:37 brian Exp $
d433 2
a434 1
PacketCheck(struct bundle *bundle, char *cp, int nb, struct filter *filter)
d443 1
a443 1
  char *ptop;
d456 3
a458 1
    if (filter)
d469 1
d475 2
a476 1
	       "%s:%d", inet_ntoa(pip->ip_dst), icmph->icmp_type);
d492 1
d497 2
a498 1
	       "%s:%d", inet_ntoa(pip->ip_dst), ntohs(uh->uh_dport));
d501 39
d545 1
d550 1
a550 1
              "%s", inet_ntoa(pip->ip_dst));
d559 1
d564 1
a564 1
	       "%s", inet_ntoa(pip->ip_dst));
d637 4
d692 1
a692 1
  if (PacketCheck(bundle, tun.data, nb, &bundle->filter.in) < 0)
@


1.22
log
@Log information about packets being dropped (probably due to
``nat deny_incoming yes'') by libalias.
@
text
@d20 1
a20 1
 * $OpenBSD: ip.c,v 1.21 2000/02/27 01:38:26 brian Exp $
d478 1
a478 1
    if (pip->ip_tos == IPTOS_LOWDELAY)
d548 1
a548 1
    if (pip->ip_tos == IPTOS_LOWDELAY)
@


1.21
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: ip.c,v 1.20 2000/02/27 01:34:04 brian Exp $
d446 2
a447 1
  logit = (log_IsKept(LogTCPIP) || log_IsKept(LogDNS)) && filter->logok;
d455 4
a458 1
    snprintf(logbuf + loglen, sizeof logbuf - loglen, "%s ", filter->name);
d591 1
a591 1
  if (FilterCheck(pip, filter)) {
d602 1
a602 1
      if (FilterCheck(pip, &bundle->filter.alive))
d610 1
a610 1
  if (uh && ntohs(uh->uh_dport) == 53 && log_IsKept(LogDNS))
@


1.20
log
@Fix a bug in end-of-line comment parsing.
Fix callback (don't ``forget'' to call back).
Restructure how we add/remove the address family when
writing/reading the tun device.
Notify the tun device that we've changed PID under FreeBSD.
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.19 2000/02/27 00:21:08 brian Exp $
@


1.19
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.18 2000/01/07 03:26:54 brian Exp $
a26 1
#if defined(__OpenBSD__) || defined(__NetBSD__)
a27 1
#endif
d618 1
a626 1
  tun_fill_header(tun, AF_INET);
d645 8
a652 2
  nb += sizeof tun - sizeof tun.data;
  nw = write(bundle->dev.fd, &tun, nb);
@


1.18
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.17 1999/08/02 15:28:47 brian Exp $
d71 19
a89 2
static const char * const TcpFlags[] = {
  "FIN", "SYN", "RST", "PSH", "ACK", "URG"
d92 47
d378 53
d437 3
d445 1
a445 3
  int mask, len, n;
  int pri = 0;
  int logit, loglen;
d448 1
a448 1
  logit = log_IsKept(LogTCPIP) && filter->logok;
d450 1
d452 2
a453 1
  pip = (struct ip *) cp;
d596 1
a596 1
    return (-1);
d599 1
a599 1
    if (logit) {
d605 1
a605 1
    return (pri);
d607 5
@


1.17
log
@Filter ospf and igmp separately.

Kind-of submitted by: phk@@FreeBSD.org
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.16 1999/07/27 23:47:21 brian Exp $
a40 1
#include <stdlib.h>
a67 1
#include "vjcomp.h"
d71 2
a72 3
static const u_short interactive_ports[32] = {
  544, 513, 514, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  80, 81, 0, 0, 0, 21, 22, 23, 0, 0, 0, 0, 0, 0, 0, 543,
a74 4
#define	INTERACTIVE(p)	(interactive_ports[(p) & 0x1F] == (p))

static const char *TcpFlags[] = { "FIN", "SYN", "RST", "PSH", "ACK", "URG" };

d126 1
a126 1
    return (filter->fragok);
d175 9
d306 2
a307 2
    bp = mbuf_Alloc(cnt, MB_IPIN);
    memcpy(MBUF_CTOP(bp), ptr, cnt);
d309 1
a309 1
    ipcp_AddOutOctets(cnt);
d326 1
a326 1
  int pri = PRI_NORMAL;
d353 1
d355 9
a364 1
      uh = (struct udphdr *) ptop;
d373 14
d399 1
d411 1
d423 1
d427 7
a433 5
      pri = PRI_FAST;
    else if ((ntohs(pip->ip_off) & IP_OFFMASK) == 0) {
      if (INTERACTIVE(ntohs(th->th_sport)) || INTERACTIVE(ntohs(th->th_dport)))
	pri = PRI_FAST;
    }
d498 1
a498 1
    mbuf_Free(bp);
d502 1
a502 1
  mbuf_SetType(bp, MB_IPIN);
d504 1
a504 1
  nb = mbuf_Length(bp);
d508 1
a508 1
    mbuf_Free(bp);
d540 1
a540 1
  if (pri < 0 || pri > sizeof ipcp->Queue / sizeof ipcp->Queue[0])
d546 1
a546 1
     * mbuf_Prepend() in acf_LayerPush() and proto_LayerPush() and
d549 3
a551 3
    bp = mbuf_Alloc(count + 6, MB_IPOUT);
    bp->offset += 4;
    bp->cnt -= 6;
d553 1
a553 1
    mbuf_Enqueue(&ipcp->Queue[pri], bp);
d562 1
a562 1
  for (queue = ipcp->Queue; queue < ipcp->Queue + PRI_MAX; queue++)
d564 1
a564 1
      mbuf_Free(mbuf_Dequeue(queue));
d567 1
a567 1
int
d571 1
a571 1
  int result = 0;
d573 3
a575 2
  for (queue = ipcp->Queue; queue < ipcp->Queue + PRI_MAX; queue++)
    result += queue->qlen;
d587 1
a587 1
  int cnt;
d592 2
a593 1
  for (queue = &ipcp->Queue[PRI_FAST]; queue >= ipcp->Queue; queue--)
d595 2
a596 2
      bp = mbuf_Contiguous(mbuf_Dequeue(queue));
      cnt = mbuf_Length(bp);
d600 2
a601 2
      link_PushPacket(l, bp, bundle, PRI_NORMAL, PROTO_IP);
      ipcp_AddOutOctets(ipcp, cnt);
d604 1
@


1.16
log
@o Overhaul filtering, adding facilities to jump over rules and to
  negate the sense of rules.
o Remove the redundant (and undocumented) ``host'' and ``port''
  words (README.changes updated).
o Don't permit (and ignore) garbage instead of the protocol.

Mostly submitted by:  Peter Jeremy <jeremyp@@gsmx07.alcatel.com.au>
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.15 1999/07/15 02:10:32 brian Exp $
d182 9
d362 12
@


1.15
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.13 1999/06/23 16:49:04 brian Exp $
d82 1
a82 1
static int
d86 1
a86 1
    case OP_EQ:
d99 5
d106 1
a106 1
FilterCheck(struct ip *pip, struct filter *filter)
d108 9
a116 7
  int gotinfo, cproto, estab, syn, finrst, n, len, didname;
  struct tcphdr *th;
  struct udphdr *uh;
  struct icmp *ih;
  char *ptop;
  u_short sport, dport;
  struct filterent *fp = filter->rule;
d119 97
a215 77
  if (fp->action) {
    cproto = gotinfo = estab = syn = finrst = didname = 0;
    sport = dport = 0;
    for (n = 0; n < MAXFILTERS; n++) {
      if (fp->action != A_NONE) {
	/* permit fragments on in and out filter */
        if (filter->fragok && (ntohs(pip->ip_off) & IP_OFFMASK) != 0)
	  return (A_PERMIT);

        if (!didname)
          log_Printf(LogDEBUG, "%s filter:\n", filter->name);
        didname = 1;

	if ((pip->ip_src.s_addr & fp->src.mask.s_addr) ==
	    (fp->src.ipaddr.s_addr & fp->src.mask.s_addr) &&
	    (pip->ip_dst.s_addr & fp->dst.mask.s_addr) ==
	    (fp->dst.ipaddr.s_addr & fp->dst.mask.s_addr)) {
	  if (fp->proto) {
	    if (!gotinfo) {
	      ptop = (char *) pip + (pip->ip_hl << 2);

	      switch (pip->ip_p) {
	      case IPPROTO_ICMP:
		cproto = P_ICMP;
		ih = (struct icmp *) ptop;
		sport = ih->icmp_type;
		estab = syn = finrst = -1;
                if (log_IsKept(LogDEBUG))
		  snprintf(dbuff, sizeof dbuff, "sport = %d", sport);
		break;
	      case IPPROTO_IGMP:
		cproto = P_IGMP;
		estab = syn = finrst = -1;
		sport = ntohs(0);
		break;
	      case IPPROTO_UDP:
	      case IPPROTO_IPIP:
		cproto = P_UDP;
		uh = (struct udphdr *) ptop;
		sport = ntohs(uh->uh_sport);
		dport = ntohs(uh->uh_dport);
		estab = syn = finrst = -1;
                if (log_IsKept(LogDEBUG))
		  snprintf(dbuff, sizeof dbuff, "sport = %d, dport = %d",
                           sport, dport);
		break;
	      case IPPROTO_TCP:
		cproto = P_TCP;
		th = (struct tcphdr *) ptop;
		sport = ntohs(th->th_sport);
		dport = ntohs(th->th_dport);
		estab = (th->th_flags & TH_ACK);
		syn = (th->th_flags & TH_SYN);
		finrst = (th->th_flags & (TH_FIN|TH_RST));
                if (log_IsKept(LogDEBUG)) {
                  if (!estab)
		    snprintf(dbuff, sizeof dbuff,
                             "flags = %02x, sport = %d, dport = %d",
                             th->th_flags, sport, dport);
                  else
                    *dbuff = '\0';
                }
		break;
	      default:
		return (A_DENY);       /* We'll block unknown type of packet */
	      }
              if (log_IsKept(LogDEBUG)) {
                if (estab != -1) {
                  len = strlen(dbuff);
                  snprintf(dbuff + len, sizeof dbuff - len,
                           ", estab = %d, syn = %d, finrst = %d",
                           estab, syn, finrst);
                }
	        log_Printf(LogDEBUG, " Filter: proto = %s, %s\n",
                          filter_Proto2Nam(cproto), dbuff);
              }
	      gotinfo = 1;
d217 11
a227 30
            if (log_IsKept(LogDEBUG)) {
	      if (fp->opt.srcop != OP_NONE) {
                snprintf(dbuff, sizeof dbuff, ", src %s %d",
                         filter_Op2Nam(fp->opt.srcop), fp->opt.srcport);
                len = strlen(dbuff);
              } else
                len = 0;
	      if (fp->opt.dstop != OP_NONE) {
                snprintf(dbuff + len, sizeof dbuff - len,
                         ", dst %s %d", filter_Op2Nam(fp->opt.dstop),
                         fp->opt.dstport);
              } else if (!len)
                *dbuff = '\0';

	      log_Printf(LogDEBUG, "  rule = %d: Address match, "
                        "check against proto %s%s, action = %s\n",
                        n, filter_Proto2Nam(fp->proto),
                        dbuff, filter_Action2Nam(fp->action));
            }

	    if (cproto == fp->proto) {
	      if ((fp->opt.srcop == OP_NONE ||
		   PortMatch(fp->opt.srcop, sport, fp->opt.srcport)) &&
		  (fp->opt.dstop == OP_NONE ||
		   PortMatch(fp->opt.dstop, dport, fp->opt.dstport)) &&
		  (fp->opt.estab == 0 || estab) &&
		  (fp->opt.syn == 0 || syn) &&
		  (fp->opt.finrst == 0 || finrst)) {
		return (fp->action);
	      }
d229 34
a262 5
	  } else {
	    /* Address is mached. Make a decision. */
	    log_Printf(LogDEBUG, "  rule = %d: Address match, action = %s\n", n,
                      filter_Action2Nam(fp->action));
	    return (fp->action);
d264 6
a269 2
	} else
	  log_Printf(LogDEBUG, "  rule = %d: Address mismatch\n", n);
d271 11
a283 1
    return (A_DENY);		/* No rule is mached. Deny this packet */
d285 1
a285 1
  return (A_PERMIT);		/* No rule is given. Permit this packet */
d418 1
a418 1
  if ((FilterCheck(pip, filter) & A_DENY)) {
d429 1
a429 1
      if (FilterCheck(pip, &bundle->filter.alive) & A_DENY)
d466 1
a466 1
  if (!(FilterCheck(pip, &bundle->filter.alive) & A_DENY))
d545 1
a545 1
      if (!(FilterCheck(pip, &bundle->filter.alive) & A_DENY))
@


1.14
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d41 1
a41 1
/* #include <stdlib.h> (auto-remove) */
d69 1
a69 1
/* #include "vjcomp.h" (auto-remove) */
@


1.13
log
@Support `igmp' filters.
Mostly submitted by: Timo Geusch <freebsd@@sleepycat.ukpeople.net>
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.12 1999/06/02 15:58:40 brian Exp $
d41 1
a41 1
#include <stdlib.h>
d69 1
a69 1
#include "vjcomp.h"
@


1.12
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.11 1999/05/31 23:57:37 brian Exp $
d142 5
a147 1
	      case IPPROTO_IGMP:
@


1.11
log
@Remember if MYADDR or HISADDR is used in a filter add tweak all
filters any time either value changes.
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.10 1999/05/14 09:35:14 brian Exp $
d396 1
d443 1
a443 1
    bp = mbuf_Alloc(count + 6, MB_IPQ);
@


1.10
log
@Ensure that we're not going to overflow our ``struct tun''
when we mbuf_Read() into it.
Add the link name to a few diagnostics.
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.9 1999/05/09 20:04:00 brian Exp $
d116 1
a116 1
      if (fp->action) {
d125 4
a128 4
	if ((pip->ip_src.s_addr & fp->smask.s_addr) ==
	    (fp->saddr.s_addr & fp->smask.s_addr) &&
	    (pip->ip_dst.s_addr & fp->dmask.s_addr) ==
	    (fp->daddr.s_addr & fp->dmask.s_addr)) {
@


1.9
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.8 1999/05/08 11:06:35 brian Exp $
d398 6
d419 2
a420 1
      log_Printf(LogERROR, "ip_Input: wrote %d, got %s\n", nb, strerror(errno));
d422 1
a422 1
      log_Printf(LogERROR, "ip_Input: wrote %d, got %d\n", nb, nw);
@


1.8
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.7 1999/05/01 11:31:19 brian Exp $
d235 1
a235 1
IcmpError(struct ip * pip, int code)
@


1.7
log
@Make ports 80 & 81 ``interactive''.
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.6 1999/04/26 08:55:01 brian Exp $
d43 1
d46 2
a47 7
#ifndef NOALIAS
#ifdef __FreeBSD__
#include <alias.h>
#else
#include "alias.h"
#endif
#endif
d98 1
a98 1
 *  Check a packet against with defined filters
d383 2
a384 2
void
ip_Input(struct bundle *bundle, struct mbuf * bp)
a385 2
  u_char *cp;
  struct mbuf *wp;
d388 1
a388 4
  struct ip *pip = (struct ip *)tun.data;
#ifndef NOALIAS
  struct ip *piip = (struct ip *)((char *)pip + (pip->ip_hl << 2));
#endif
d390 4
a393 13
  tun_fill_header(tun, AF_INET);
  cp = tun.data;
  nb = 0;
  for (wp = bp; wp; wp = wp->next) {	/* Copy to contiguous region */
    if (sizeof tun.data - (cp - tun.data) < wp->cnt) {
      log_Printf(LogWARN, "ip_Input: Packet too large (%d) - dropped\n",
                mbuf_Length(bp));
      mbuf_Free(bp);
      return;
    }
    memcpy(cp, MBUF_CTOP(wp), wp->cnt);
    cp += wp->cnt;
    nb += wp->cnt;
d396 3
a398 24
#ifndef NOALIAS
  if (bundle->AliasEnabled && pip->ip_p != IPPROTO_IGMP &&
      (pip->ip_p != IPPROTO_IPIP || !IN_CLASSD(ntohl(piip->ip_dst.s_addr)))) {
    struct tun_data *frag;
    int iresult;
    char *fptr;

    iresult = PacketAliasIn(tun.data, sizeof tun.data);
    nb = ntohs(((struct ip *) tun.data)->ip_len);

    if (nb > MAX_MRU) {
      log_Printf(LogWARN, "ip_Input: Problem with IP header length\n");
      mbuf_Free(bp);
      return;
    }
    if (iresult == PKT_ALIAS_OK
	|| iresult == PKT_ALIAS_FOUND_HEADER_FRAGMENT) {
      if (PacketCheck(bundle, tun.data, nb, &bundle->filter.in) < 0) {
	mbuf_Free(bp);
	return;
      }

      if (!(FilterCheck(pip, &bundle->filter.alive) & A_DENY))
        bundle_StartIdleTimer(bundle);
d400 2
a401 1
      ipcp_AddInOctets(&bundle->ncp.ipcp, nb);
d403 14
a416 10
      nb = ntohs(((struct ip *) tun.data)->ip_len);
      nb += sizeof tun - sizeof tun.data;
      nw = write(bundle->dev.fd, &tun, nb);
      if (nw != nb) {
        if (nw == -1)
	  log_Printf(LogERROR, "ip_Input: wrote %d, got %s\n", nb,
                    strerror(errno));
        else
	  log_Printf(LogERROR, "ip_Input: wrote %d, got %d\n", nb, nw);
      }
d418 1
a418 53
      if (iresult == PKT_ALIAS_FOUND_HEADER_FRAGMENT) {
	while ((fptr = PacketAliasGetFragment(tun.data)) != NULL) {
	  PacketAliasFragmentIn(tun.data, fptr);
	  nb = ntohs(((struct ip *) fptr)->ip_len);
          frag = (struct tun_data *)
	    ((char *)fptr - sizeof tun + sizeof tun.data);
          nb += sizeof tun - sizeof tun.data;
	  nw = write(bundle->dev.fd, frag, nb);
	  if (nw != nb) {
            if (nw == -1)
	      log_Printf(LogERROR, "ip_Input: wrote %d, got %s\n", nb,
                        strerror(errno));
            else
	      log_Printf(LogERROR, "ip_Input: wrote %d, got %d\n", nb, nw);
          }
	  free(frag);
	}
      }
    } else if (iresult == PKT_ALIAS_UNRESOLVED_FRAGMENT) {
      nb = ntohs(((struct ip *) tun.data)->ip_len);
      nb += sizeof tun - sizeof tun.data;
      frag = (struct tun_data *)malloc(nb);
      if (frag == NULL)
	log_Printf(LogALERT, "ip_Input: Cannot allocate memory for fragment\n");
      else {
        tun_fill_header(*frag, AF_INET);
	memcpy(frag->data, tun.data, nb - sizeof tun + sizeof tun.data);
	PacketAliasSaveFragment(frag->data);
      }
    }
  } else
#endif /* #ifndef NOALIAS */
  {			/* no aliasing */
    if (PacketCheck(bundle, tun.data, nb, &bundle->filter.in) < 0) {
      mbuf_Free(bp);
      return;
    }

    if (!(FilterCheck(pip, &bundle->filter.alive) & A_DENY))
      bundle_StartIdleTimer(bundle);

    ipcp_AddInOctets(&bundle->ncp.ipcp, nb);

    nb += sizeof tun - sizeof tun.data;
    nw = write(bundle->dev.fd, &tun, nb);
    if (nw != nb) {
      if (nw == -1)
	log_Printf(LogERROR, "ip_Input: wrote %d, got %s\n", nb, strerror(errno));
      else
        log_Printf(LogERROR, "ip_Input: wrote %d, got %d\n", nb, nw);
    }
  }
  mbuf_Free(bp);
d429 9
a437 1
    bp = mbuf_Alloc(count, MB_IPQ);
d466 1
a466 1
ip_FlushPacket(struct link *l, struct bundle *bundle)
d471 1
d480 7
a486 10
      if (bp) {
        struct ip *pip = (struct ip *)MBUF_CTOP(bp);

	cnt = mbuf_Length(bp);
        if (!(FilterCheck(pip, &bundle->filter.alive) & A_DENY))
          bundle_StartIdleTimer(bundle);
	vj_SendFrame(l, bp, bundle);
        ipcp_AddOutOctets(ipcp, cnt);
	return 1;
      }
@


1.6
log
@Add support for NetBSD
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.5 1999/03/29 08:20:32 brian Exp $
d79 1
a79 1
  0, 0, 0, 0, 0, 21, 22, 23, 0, 0, 0, 0, 0, 0, 0, 543,
@


1.5
log
@Ensure that the thing we're casting to struct ip
is aligned for non-i386 architectures.
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.4 1999/02/06 03:22:38 brian Exp $
d27 1
a27 1
#ifdef __OpenBSD__
d46 3
a48 1
#ifdef __OpenBSD__
a49 2
#else
#include <alias.h>
@


1.4
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.55 1999/01/28 01:56:32 brian Exp $
d556 1
a556 1
      bp = mbuf_Dequeue(queue);
@


1.3
log
@Don't forget to initialise dbuff when debugging.
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.2 1998/08/31 08:16:38 brian Exp $
d26 1
a26 1
#include <sys/types.h>
d69 3
@


1.2
log
@Move libalias sources into the ppp directory.
Suggested (many times) by: Theo
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.1 1998/08/31 00:22:21 brian Exp $
d163 8
a170 4
                if (log_IsKept(LogDEBUG) && !estab)
		  snprintf(dbuff, sizeof dbuff,
                           "flags = %02x, sport = %d, dport = %d",
                           th->th_flags, sport, dport);
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: ip.c,v 1.52 1998/08/26 17:39:37 brian Exp $
a38 3
#ifndef NOALIAS
#include <alias.h>
#endif
d45 7
@

