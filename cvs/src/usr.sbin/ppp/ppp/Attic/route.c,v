head	1.39;
access;
symbols
	OPENBSD_5_5:1.38.0.22
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.18
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.16
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.14
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.12
	OPENBSD_5_0:1.38.0.10
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.8
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.6
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.35.0.6
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.4
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.34.0.10
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.8
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.6
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.34.0.4
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.26.0.4
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.39
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.38;

1.38
date	2009.07.02.16.08.29;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.25.15.59.28;	author claudio;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.05.22.40.24;	author chris;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.02.15.19.39;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.17.20.43.14;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.17.18.34.09;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.06.13.56.00;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.20.14.58.14;	author markus;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.15.16.26.37;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.07.23.58.53;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.04.04.20.25.06;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.16.14.13.06;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.16.13.20.23;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.23.19.21.36;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.23.17.12.20;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.23.17.12.10;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.23.15.46.10;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.23.12.38.52;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.04.22.12.46;	author brian;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.08.20.00.48.14;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.15.23.35.37;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.19.10.24.58;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.13.21.33.42;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.05.02.24.05;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.02.22.12.41;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.20.10.39.10;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.19.10.33.34;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.27.01.38.28;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.27.00.21.09;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.39;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.22.46;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.10.29.02.21.46;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.27;	author brian;	state Exp;
branches;
next	;

1.17.2.1
date	2001.12.06.13.43.19;	author brian;	state Exp;
branches;
next	;


desc
@@


1.39
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: route.c,v 1.38 2009/07/02 16:08:29 claudio Exp $
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <net/if_types.h>
#include <net/route.h>
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if_dl.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/un.h>

#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/sysctl.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "iplist.h"
#include "timer.h"
#include "throughput.h"
#include "lqr.h"
#include "hdlc.h"
#include "fsm.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "descriptor.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "route.h"
#include "prompt.h"
#include "iface.h"
#include "id.h"


static void
p_sockaddr(struct prompt *prompt, struct sockaddr *phost,
           struct sockaddr *pmask, int width)
{
  struct ncprange range;
  char buf[29];
  struct sockaddr_dl *dl = (struct sockaddr_dl *)phost;

  if (log_IsKept(LogDEBUG)) {
    char tmp[50];

    log_Printf(LogDEBUG, "Found the following sockaddr:\n");
    log_Printf(LogDEBUG, "  Family %d, len %d\n",
               (int)phost->sa_family, (int)phost->sa_len);
    inet_ntop(phost->sa_family, phost->sa_data, tmp, sizeof tmp);
    log_Printf(LogDEBUG, "  Addr %s\n", tmp);
    if (pmask) {
      inet_ntop(pmask->sa_family, pmask->sa_data, tmp, sizeof tmp);
      log_Printf(LogDEBUG, "  Mask %s\n", tmp);
    }
  }

  switch (phost->sa_family) {
  case AF_INET:
#ifndef NOINET6
  case AF_INET6:
#endif
    ncprange_setsa(&range, phost, pmask);
    if (ncprange_isdefault(&range))
      prompt_Printf(prompt, "%-*s ", width - 1, "default");
    else
      prompt_Printf(prompt, "%-*s ", width - 1, ncprange_ntoa(&range));
    return;

  case AF_LINK:
    if (dl->sdl_nlen)
      snprintf(buf, sizeof buf, "%.*s", dl->sdl_nlen, dl->sdl_data);
    else if (dl->sdl_alen) {
      if (dl->sdl_type == IFT_ETHER) {
        if (dl->sdl_alen < sizeof buf / 3) {
          int f;
          u_char *MAC;

          MAC = (u_char *)dl->sdl_data + dl->sdl_nlen;
          for (f = 0; f < dl->sdl_alen; f++)
            snprintf(buf+f*3, sizeof buf - (f*3), "%02x:", MAC[f]);
          buf[f*3-1] = '\0';
        } else
          strlcpy(buf, "??:??:??:??:??:??", sizeof buf);
      } else
        snprintf(buf, sizeof buf, "<IFT type %d>", dl->sdl_type);
    }  else if (dl->sdl_slen)
      snprintf(buf, sizeof buf, "<slen %d?>", dl->sdl_slen);
    else
      snprintf(buf, sizeof buf, "link#%d", dl->sdl_index);
    break;

  default:
    snprintf(buf, sizeof buf, "<AF type %d>", phost->sa_family);
    break;
  }

  prompt_Printf(prompt, "%-*s ", width-1, buf);
}

static struct bits {
  u_int32_t b_mask;
  char b_val;
} bits[] = {
  { RTF_UP, 'U' },
  { RTF_GATEWAY, 'G' },
  { RTF_HOST, 'H' },
  { RTF_REJECT, 'R' },
  { RTF_DYNAMIC, 'D' },
  { RTF_MODIFIED, 'M' },
  { RTF_DONE, 'd' },
  { RTF_CLONING, 'C' },
  { RTF_XRESOLVE, 'X' },
  { RTF_LLINFO, 'L' },
  { RTF_STATIC, 'S' },
  { RTF_PROTO1, '1' },
  { RTF_PROTO2, '2' },
  { RTF_BLACKHOLE, 'B' },
#ifdef RTF_WASCLONED
  { RTF_WASCLONED, 'W' },
#endif
#ifdef RTF_PRCLONING
  { RTF_PRCLONING, 'c' },
#endif
#ifdef RTF_PROTO3
  { RTF_PROTO3, '3' },
#endif
#ifdef RTF_BROADCAST
  { RTF_BROADCAST, 'b' },
#endif
  { 0, '\0' }
};

#ifndef RTF_WASCLONED
#define RTF_WASCLONED (0)
#endif

static void
p_flags(struct prompt *prompt, u_int32_t f, int max)
{
  char name[33], *flags;
  register struct bits *p = bits;

  if (max > sizeof name - 1)
    max = sizeof name - 1;

  for (flags = name; p->b_mask && flags - name < max; p++)
    if (p->b_mask & f)
      *flags++ = p->b_val;
  *flags = '\0';
  prompt_Printf(prompt, "%-*.*s", max, max, name);
}

static int route_nifs = -1;

const char *
Index2Nam(int idx)
{
  static char ifname[IF_NAMESIZE];
  char *ifn;

  ifn = if_indextoname(idx, ifname);

  if (idx < 1 || ifn == NULL)
    return NumStr(idx, NULL, 0);

  return ifn;
}

void
route_ParseHdr(struct rt_msghdr *rtm, struct sockaddr *sa[RTAX_MAX])
{
  char *wp;
  int rtax;

  wp = (char *)((char *)rtm + rtm->rtm_hdrlen);

  for (rtax = 0; rtax < RTAX_MAX; rtax++)
    if (rtm->rtm_addrs & (1 << rtax)) {
      sa[rtax] = (struct sockaddr *)wp;
      wp += ROUNDUP(sa[rtax]->sa_len);
      if (sa[rtax]->sa_family == 0)
        sa[rtax] = NULL;	/* ??? */
    } else
      sa[rtax] = NULL;
}

int
route_Show(struct cmdargs const *arg)
{
  struct rt_msghdr *rtm;
  struct sockaddr *sa[RTAX_MAX];
  char *sp, *ep, *cp;
  size_t needed;
  int mib[6];

  mib[0] = CTL_NET;
  mib[1] = PF_ROUTE;
  mib[2] = 0;
  mib[3] = 0;
  mib[4] = NET_RT_DUMP;
  mib[5] = 0;
  if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
    log_Printf(LogERROR, "route_Show: sysctl: estimate: %s\n", strerror(errno));
    return (1);
  }
  sp = malloc(needed);
  if (sp == NULL)
    return (1);
  if (sysctl(mib, 6, sp, &needed, NULL, 0) < 0) {
    log_Printf(LogERROR, "route_Show: sysctl: getroute: %s\n", strerror(errno));
    free(sp);
    return (1);
  }
  ep = sp + needed;

  prompt_Printf(arg->prompt, "%-20s%-20sFlags  Netif\n",
                "Destination", "Gateway");
  for (cp = sp; cp < ep; cp += rtm->rtm_msglen) {
    rtm = (struct rt_msghdr *)cp;

    if (rtm->rtm_version != RTM_VERSION)
      continue;

    route_ParseHdr(rtm, sa);

    if (sa[RTAX_DST] && sa[RTAX_GATEWAY]) {
      p_sockaddr(arg->prompt, sa[RTAX_DST], sa[RTAX_NETMASK], 20);
      p_sockaddr(arg->prompt, sa[RTAX_GATEWAY], NULL, 20);

      p_flags(arg->prompt, rtm->rtm_flags, 6);
      prompt_Printf(arg->prompt, " %s\n", Index2Nam(rtm->rtm_index));
    } else
      prompt_Printf(arg->prompt, "<can't parse routing entry>\n");
  }
  free(sp);
  return 0;
}

/*
 *  Delete routes associated with our interface
 */
void
route_IfDelete(struct bundle *bundle, int all)
{
  struct rt_msghdr *rtm;
  struct sockaddr *sa[RTAX_MAX];
  struct ncprange range;
  int pass;
  size_t needed;
  char *sp, *cp, *ep;
  int mib[6];

  log_Printf(LogDEBUG, "route_IfDelete (%d)\n", bundle->iface->index);

  mib[0] = CTL_NET;
  mib[1] = PF_ROUTE;
  mib[2] = 0;
  mib[3] = 0;
  mib[4] = NET_RT_DUMP;
  mib[5] = 0;
  if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
    log_Printf(LogERROR, "route_IfDelete: sysctl: estimate: %s\n",
              strerror(errno));
    return;
  }

  sp = malloc(needed);
  if (sp == NULL)
    return;

  if (sysctl(mib, 6, sp, &needed, NULL, 0) < 0) {
    log_Printf(LogERROR, "route_IfDelete: sysctl: getroute: %s\n",
              strerror(errno));
    free(sp);
    return;
  }
  ep = sp + needed;

  for (pass = 0; pass < 2; pass++) {
    /*
     * We do 2 passes.  The first deletes all cloned routes.  The second
     * deletes all non-cloned routes.  This is done to avoid
     * potential errors from trying to delete route X after route Y where
     * route X was cloned from route Y (and is no longer there 'cos it
     * may have gone with route Y).
     */
    if (RTF_WASCLONED == 0 && pass == 0)
      /* So we can't tell ! */
      continue;
    for (cp = sp; cp < ep; cp += rtm->rtm_msglen) {
      rtm = (struct rt_msghdr *)cp;
      if (rtm->rtm_version != RTM_VERSION)
        continue;

      route_ParseHdr(rtm, sa);
      if (rtm->rtm_index == bundle->iface->index &&
          sa[RTAX_DST] && sa[RTAX_GATEWAY] &&
          (sa[RTAX_DST]->sa_family == AF_INET
#ifndef NOINET6
           || sa[RTAX_DST]->sa_family == AF_INET6
#endif
           ) &&
          (all || (rtm->rtm_flags & RTF_GATEWAY))) {
        if (log_IsKept(LogDEBUG)) {
          char gwstr[41];
          struct ncpaddr gw;
          ncprange_setsa(&range, sa[RTAX_DST], sa[RTAX_NETMASK]);
          ncpaddr_setsa(&gw, sa[RTAX_GATEWAY]);
          snprintf(gwstr, sizeof gwstr, "%s", ncpaddr_ntoa(&gw));
          log_Printf(LogDEBUG, "Found %s %s\n", ncprange_ntoa(&range), gwstr);
        }
        if (sa[RTAX_GATEWAY]->sa_family == AF_INET ||
#ifndef NOINET6
            sa[RTAX_GATEWAY]->sa_family == AF_INET6 ||
#endif
            sa[RTAX_GATEWAY]->sa_family == AF_LINK) {
          if ((pass == 0 && (rtm->rtm_flags & RTF_WASCLONED)) ||
              (pass == 1 && !(rtm->rtm_flags & RTF_WASCLONED))) {
            ncprange_setsa(&range, sa[RTAX_DST], sa[RTAX_NETMASK]);
            rt_Set(bundle, RTM_DELETE, &range, NULL, 0, 0);
          } else
            log_Printf(LogDEBUG, "route_IfDelete: Skip it (pass %d)\n", pass);
        } else
          log_Printf(LogDEBUG,
                    "route_IfDelete: Can't remove routes for family %d\n",
                    sa[RTAX_GATEWAY]->sa_family);
      }
    }
  }
  free(sp);
}


/*
 *  Update the MTU on all routes for the given interface
 */
void
route_UpdateMTU(struct bundle *bundle)
{
  struct rt_msghdr *rtm;
  struct sockaddr *sa[RTAX_MAX];
  struct ncprange dst;
  size_t needed;
  char *sp, *cp, *ep;
  int mib[6];

  log_Printf(LogDEBUG, "route_UpdateMTU (%d)\n", bundle->iface->index);

  mib[0] = CTL_NET;
  mib[1] = PF_ROUTE;
  mib[2] = 0;
  mib[3] = 0;
  mib[4] = NET_RT_DUMP;
  mib[5] = 0;
  if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
    log_Printf(LogERROR, "route_IfDelete: sysctl: estimate: %s\n",
              strerror(errno));
    return;
  }

  sp = malloc(needed);
  if (sp == NULL)
    return;

  if (sysctl(mib, 6, sp, &needed, NULL, 0) < 0) {
    log_Printf(LogERROR, "route_IfDelete: sysctl: getroute: %s\n",
              strerror(errno));
    free(sp);
    return;
  }
  ep = sp + needed;

  for (cp = sp; cp < ep; cp += rtm->rtm_msglen) {
    rtm = (struct rt_msghdr *)cp;
    if (rtm->rtm_version != RTM_VERSION)
      continue;
    route_ParseHdr(rtm, sa);
    if (sa[RTAX_DST] && (sa[RTAX_DST]->sa_family == AF_INET
#ifndef NOINET6
                         || sa[RTAX_DST]->sa_family == AF_INET6
#endif
                        ) &&
        sa[RTAX_GATEWAY] && rtm->rtm_index == bundle->iface->index) {
      if (log_IsKept(LogTCPIP)) {
        ncprange_setsa(&dst, sa[RTAX_DST], sa[RTAX_NETMASK]);
        log_Printf(LogTCPIP, "route_UpdateMTU: Netif: %d (%s), dst %s,"
                   " mtu %d\n", rtm->rtm_index, Index2Nam(rtm->rtm_index),
                   ncprange_ntoa(&dst), bundle->iface->mtu);
      }
      rt_Update(bundle, sa[RTAX_DST], sa[RTAX_GATEWAY], sa[RTAX_NETMASK]);
    }
  }

  free(sp);
}

int
GetIfIndex(char *name)
{
  int idx;

  idx = 1;
  while (route_nifs == -1 || idx < route_nifs)
    if (strcmp(Index2Nam(idx), name) == 0)
      return idx;
    else
      idx++;
  return -1;
}

void
route_Change(struct bundle *bundle, struct sticky_route *r,
             const struct ncpaddr *me, const struct ncpaddr *peer)
{
  struct ncpaddr dst;

  for (; r; r = r->next) {
    ncprange_getaddr(&r->dst, &dst);
    if (ncpaddr_family(me) == AF_INET) {
      if ((r->type & ROUTE_DSTMYADDR) && !ncpaddr_equal(&dst, me)) {
        rt_Set(bundle, RTM_DELETE, &r->dst, NULL, 1, 0);
        ncprange_sethost(&r->dst, me);
        if (r->type & ROUTE_GWHISADDR)
          ncpaddr_copy(&r->gw, peer);
      } else if ((r->type & ROUTE_DSTHISADDR) && !ncpaddr_equal(&dst, peer)) {
        rt_Set(bundle, RTM_DELETE, &r->dst, NULL, 1, 0);
        ncprange_sethost(&r->dst, peer);
        if (r->type & ROUTE_GWHISADDR)
          ncpaddr_copy(&r->gw, peer);
      } else if ((r->type & ROUTE_DSTDNS0) && !ncpaddr_equal(&dst, peer)) {
        if (bundle->ncp.ipcp.ns.dns[0].s_addr == INADDR_NONE)
          continue;
        rt_Set(bundle, RTM_DELETE, &r->dst, NULL, 1, 0);
        if (r->type & ROUTE_GWHISADDR)
          ncpaddr_copy(&r->gw, peer);
      } else if ((r->type & ROUTE_DSTDNS1) && !ncpaddr_equal(&dst, peer)) {
        if (bundle->ncp.ipcp.ns.dns[1].s_addr == INADDR_NONE)
          continue;
        rt_Set(bundle, RTM_DELETE, &r->dst, NULL, 1, 0);
        if (r->type & ROUTE_GWHISADDR)
          ncpaddr_copy(&r->gw, peer);
      } else if ((r->type & ROUTE_GWHISADDR) && !ncpaddr_equal(&r->gw, peer))
        ncpaddr_copy(&r->gw, peer);
#ifndef NOINET6
    } else if (ncpaddr_family(me) == AF_INET6) {
      if ((r->type & ROUTE_DSTMYADDR6) && !ncpaddr_equal(&dst, me)) {
        rt_Set(bundle, RTM_DELETE, &r->dst, NULL, 1, 0);
        ncprange_sethost(&r->dst, me);
        if (r->type & ROUTE_GWHISADDR)
          ncpaddr_copy(&r->gw, peer);
      } else if ((r->type & ROUTE_DSTHISADDR6) && !ncpaddr_equal(&dst, peer)) {
        rt_Set(bundle, RTM_DELETE, &r->dst, NULL, 1, 0);
        ncprange_sethost(&r->dst, peer);
        if (r->type & ROUTE_GWHISADDR)
          ncpaddr_copy(&r->gw, peer);
      } else if ((r->type & ROUTE_GWHISADDR6) && !ncpaddr_equal(&r->gw, peer))
        ncpaddr_copy(&r->gw, peer);
#endif
    }
    rt_Set(bundle, RTM_ADD, &r->dst, &r->gw, 1, 0);
  }
}

void
route_Add(struct sticky_route **rp, int type, const struct ncprange *dst,
          const struct ncpaddr *gw)
{
  struct sticky_route *r;
  int dsttype = type & ROUTE_DSTANY;

  r = NULL;
  while (*rp) {
    if ((dsttype && dsttype == ((*rp)->type & ROUTE_DSTANY)) ||
        (!dsttype && ncprange_equal(&(*rp)->dst, dst))) {
      /* Oops, we already have this route - unlink it */
      free(r);			/* impossible really  */
      r = *rp;
      *rp = r->next;
    } else
      rp = &(*rp)->next;
  }

  if (r == NULL) {
    r = (struct sticky_route *)malloc(sizeof(struct sticky_route));
    if (r == NULL) {
      log_Printf(LogERROR, "route_Add: Out of memory!\n");
      return;
    }
  }
  r->type = type;
  r->next = NULL;
  ncprange_copy(&r->dst, dst);
  ncpaddr_copy(&r->gw, gw);
  *rp = r;
}

void
route_Delete(struct sticky_route **rp, int type, const struct ncprange *dst)
{
  struct sticky_route *r;
  int dsttype = type & ROUTE_DSTANY;

  for (; *rp; rp = &(*rp)->next) {
    if ((dsttype && dsttype == ((*rp)->type & ROUTE_DSTANY)) ||
        (!dsttype && ncprange_equal(dst, &(*rp)->dst))) {
      r = *rp;
      *rp = r->next;
      free(r);
      break;
    }
  }
}

void
route_DeleteAll(struct sticky_route **rp)
{
  struct sticky_route *r, *rn;

  for (r = *rp; r; r = rn) {
    rn = r->next;
    free(r);
  }
  *rp = NULL;
}

void
route_ShowSticky(struct prompt *p, struct sticky_route *r, const char *tag,
                 int indent)
{
  int tlen = strlen(tag);

  if (tlen + 2 > indent)
    prompt_Printf(p, "%s:\n%*s", tag, indent, "");
  else
    prompt_Printf(p, "%s:%*s", tag, indent - tlen - 1, "");

  for (; r; r = r->next) {
    prompt_Printf(p, "%*sadd ", tlen ? 0 : indent, "");
    tlen = 0;
    if (r->type & ROUTE_DSTMYADDR)
      prompt_Printf(p, "MYADDR");
    else if (r->type & ROUTE_DSTMYADDR6)
      prompt_Printf(p, "MYADDR6");
    else if (r->type & ROUTE_DSTHISADDR)
      prompt_Printf(p, "HISADDR");
    else if (r->type & ROUTE_DSTHISADDR6)
      prompt_Printf(p, "HISADDR6");
    else if (r->type & ROUTE_DSTDNS0)
      prompt_Printf(p, "DNS0");
    else if (r->type & ROUTE_DSTDNS1)
      prompt_Printf(p, "DNS1");
    else if (ncprange_isdefault(&r->dst))
      prompt_Printf(p, "default");
    else
      prompt_Printf(p, "%s", ncprange_ntoa(&r->dst));

    if (r->type & ROUTE_GWHISADDR)
      prompt_Printf(p, " HISADDR\n");
    else if (r->type & ROUTE_GWHISADDR6)
      prompt_Printf(p, " HISADDR6\n");
    else
      prompt_Printf(p, " %s\n", ncpaddr_ntoa(&r->gw));
  }
}

struct rtmsg {
  struct rt_msghdr m_rtm;
  char m_space[256];
};

static size_t
memcpy_roundup(char *cp, const void *data, size_t len)
{
  size_t padlen;

  padlen = ROUNDUP(len);
  memcpy(cp, data, len);
  if (padlen > len)
    memset(cp + len, '\0', padlen - len);

  return padlen;
}

#if defined(__KAME__) && !defined(NOINET6)
static void
add_scope(struct sockaddr *sa, int ifindex)
{
  struct sockaddr_in6 *sa6;

  if (sa->sa_family != AF_INET6)
    return;
  sa6 = (struct sockaddr_in6 *)sa;
  if (!IN6_IS_ADDR_LINKLOCAL(&sa6->sin6_addr) &&
      !IN6_IS_ADDR_MC_LINKLOCAL(&sa6->sin6_addr))
    return;
  if (*(u_int16_t *)&sa6->sin6_addr.s6_addr[2] != 0)
    return;
  *(u_int16_t *)&sa6->sin6_addr.s6_addr[2] = htons(ifindex);
}
#endif

int
rt_Set(struct bundle *bundle, int cmd, const struct ncprange *dst,
       const struct ncpaddr *gw, int bang, int quiet)
{
  struct rtmsg rtmes;
  int s, nb, wb;
  char *cp;
  const char *cmdstr;
  struct sockaddr_storage sadst, samask, sagw;
  int result = 1;

  if (bang)
    cmdstr = (cmd == RTM_ADD ? "Add!" : "Delete!");
  else
    cmdstr = (cmd == RTM_ADD ? "Add" : "Delete");
  s = ID0socket(PF_ROUTE, SOCK_RAW, 0);
  if (s < 0) {
    log_Printf(LogERROR, "rt_Set: socket(): %s\n", strerror(errno));
    return result;
  }
  memset(&rtmes, '\0', sizeof rtmes);
  rtmes.m_rtm.rtm_version = RTM_VERSION;
  rtmes.m_rtm.rtm_type = cmd;
  rtmes.m_rtm.rtm_addrs = RTA_DST;
  rtmes.m_rtm.rtm_seq = ++bundle->routing_seq;
  rtmes.m_rtm.rtm_pid = getpid();
  rtmes.m_rtm.rtm_flags = RTF_UP | RTF_GATEWAY | RTF_STATIC;

  if (cmd == RTM_ADD) {
    if (bundle->ncp.cfg.sendpipe > 0) {
      rtmes.m_rtm.rtm_rmx.rmx_sendpipe = bundle->ncp.cfg.sendpipe;
      rtmes.m_rtm.rtm_inits |= RTV_SPIPE;
    }
    if (bundle->ncp.cfg.recvpipe > 0) {
      rtmes.m_rtm.rtm_rmx.rmx_recvpipe = bundle->ncp.cfg.recvpipe;
      rtmes.m_rtm.rtm_inits |= RTV_RPIPE;
    }
  }

  ncprange_getsa(dst, &sadst, &samask);
#if defined(__KAME__) && !defined(NOINET6)
  add_scope((struct sockaddr *)&sadst, bundle->iface->index);
#endif

  cp = rtmes.m_space;
  cp += memcpy_roundup(cp, &sadst, sadst.ss_len);
  if (cmd == RTM_ADD) {
    if (gw == NULL) {
      log_Printf(LogERROR, "rt_Set: Program error\n");
      close(s);
      return result;
    }
    ncpaddr_getsa(gw, &sagw);
#if defined(__KAME__) && !defined(NOINET6)
    add_scope((struct sockaddr *)&sagw, bundle->iface->index);
#endif
    if (ncpaddr_isdefault(gw)) {
      if (!quiet)
        log_Printf(LogERROR, "rt_Set: Cannot add a route with"
                   " gateway 0.0.0.0\n");
      close(s);
      return result;
    } else {
      cp += memcpy_roundup(cp, &sagw, sagw.ss_len);
      rtmes.m_rtm.rtm_addrs |= RTA_GATEWAY;
    }
  }

  if (!ncprange_ishost(dst)) {
    cp += memcpy_roundup(cp, &samask, samask.ss_len);
    rtmes.m_rtm.rtm_addrs |= RTA_NETMASK;
  }

  nb = cp - (char *)&rtmes;
  rtmes.m_rtm.rtm_msglen = nb;
  wb = ID0write(s, &rtmes, nb);
  if (wb < 0) {
    log_Printf(LogTCPIP, "rt_Set failure:\n");
    log_Printf(LogTCPIP, "rt_Set:  Cmd = %s\n", cmdstr);
    log_Printf(LogTCPIP, "rt_Set:  Dst = %s\n", ncprange_ntoa(dst));
    if (gw != NULL)
      log_Printf(LogTCPIP, "rt_Set:  Gateway = %s\n", ncpaddr_ntoa(gw));
failed:
    if (cmd == RTM_ADD && (rtmes.m_rtm.rtm_errno == EEXIST ||
                           (rtmes.m_rtm.rtm_errno == 0 && errno == EEXIST))) {
      if (!bang) {
        log_Printf(LogWARN, "Add route failed: %s already exists\n",
		   ncprange_ntoa(dst));
        result = 0;	/* Don't add to our dynamic list */
      } else {
        rtmes.m_rtm.rtm_type = cmd = RTM_CHANGE;
        if ((wb = ID0write(s, &rtmes, nb)) < 0)
          goto failed;
      }
    } else if (cmd == RTM_DELETE &&
             (rtmes.m_rtm.rtm_errno == ESRCH ||
              (rtmes.m_rtm.rtm_errno == 0 && errno == ESRCH))) {
      if (!bang)
        log_Printf(LogWARN, "Del route failed: %s: Non-existent\n",
                  ncprange_ntoa(dst));
    } else if (rtmes.m_rtm.rtm_errno == 0) {
      if (!quiet || errno != ENETUNREACH)
        log_Printf(LogWARN, "%s route failed: %s: errno: %s\n", cmdstr,
                   ncprange_ntoa(dst), strerror(errno));
    } else
      log_Printf(LogWARN, "%s route failed: %s: %s\n",
		 cmdstr, ncprange_ntoa(dst), strerror(rtmes.m_rtm.rtm_errno));
  }

  if (log_IsKept(LogDEBUG)) {
    char gwstr[40];

    if (gw)
      snprintf(gwstr, sizeof gwstr, "%s", ncpaddr_ntoa(gw));
    else
      snprintf(gwstr, sizeof gwstr, "<none>");
    log_Printf(LogDEBUG, "wrote %d: cmd = %s, dst = %s, gateway = %s\n",
               wb, cmdstr, ncprange_ntoa(dst), gwstr);
  }
  close(s);

  return result;
}

void
rt_Update(struct bundle *bundle, const struct sockaddr *dst,
          const struct sockaddr *gw, const struct sockaddr *mask)
{
  struct ncprange ncpdst;
  struct rtmsg rtmes;
  char *p;
  int s, wb;

  s = ID0socket(PF_ROUTE, SOCK_RAW, 0);
  if (s < 0) {
    log_Printf(LogERROR, "rt_Update: socket(): %s\n", strerror(errno));
    return;
  }

  memset(&rtmes, '\0', sizeof rtmes);
  rtmes.m_rtm.rtm_version = RTM_VERSION;
  rtmes.m_rtm.rtm_type = RTM_CHANGE;
  rtmes.m_rtm.rtm_addrs = 0;
  rtmes.m_rtm.rtm_seq = ++bundle->routing_seq;
  rtmes.m_rtm.rtm_pid = getpid();
  rtmes.m_rtm.rtm_flags = RTF_UP | RTF_STATIC;

  if (bundle->ncp.cfg.sendpipe > 0) {
    rtmes.m_rtm.rtm_rmx.rmx_sendpipe = bundle->ncp.cfg.sendpipe;
    rtmes.m_rtm.rtm_inits |= RTV_SPIPE;
  }

  if (bundle->ncp.cfg.recvpipe > 0) {
    rtmes.m_rtm.rtm_rmx.rmx_recvpipe = bundle->ncp.cfg.recvpipe;
    rtmes.m_rtm.rtm_inits |= RTV_RPIPE;
  }

  rtmes.m_rtm.rtm_rmx.rmx_mtu = bundle->iface->mtu;
  rtmes.m_rtm.rtm_inits |= RTV_MTU;
  p = rtmes.m_space;

  if (dst) {
    rtmes.m_rtm.rtm_addrs |= RTA_DST;
    p += memcpy_roundup(p, dst, dst->sa_len);
  }

  rtmes.m_rtm.rtm_addrs |= RTA_GATEWAY;
  p += memcpy_roundup(p, gw, gw->sa_len);
  if (mask) {
    rtmes.m_rtm.rtm_addrs |= RTA_NETMASK;
    p += memcpy_roundup(p, mask, mask->sa_len);
  }

  rtmes.m_rtm.rtm_msglen = p - (char *)&rtmes;

  wb = ID0write(s, &rtmes, rtmes.m_rtm.rtm_msglen);
  if (wb < 0) {
    ncprange_setsa(&ncpdst, dst, mask);

    log_Printf(LogTCPIP, "rt_Update failure:\n");
    log_Printf(LogTCPIP, "rt_Update:  Dst = %s\n", ncprange_ntoa(&ncpdst));

    if (rtmes.m_rtm.rtm_errno == 0)
      log_Printf(LogWARN, "%s: Change route failed: errno: %s\n",
                 ncprange_ntoa(&ncpdst), strerror(errno));
    else
      log_Printf(LogWARN, "%s: Change route failed: %s\n",
		 ncprange_ntoa(&ncpdst), strerror(rtmes.m_rtm.rtm_errno));
  }
  close(s);
}
@


1.38
log
@Rewrite the sysctl handlers to use libc functions (getifaddrs and
if_indextoname) instead of looking at the sysctl data directly. This makes
the code a lot simpler and actually work. Tested by many (todd@@, sthen@@, and
a few people on tech@@). OK sthen@@, deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.37 2009/06/25 15:59:28 claudio Exp $
@


1.37
log
@At least try to check for the RTM_VERSION here even so part of this code
escaped from a horror story and robs you're sanity. This needs major cleanup.
OK sthen@@, OK henning@@
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.36 2009/06/05 22:40:24 chris Exp $
d207 2
a208 22
  /*
   * XXX: Maybe we should select() on the routing socket so that we can
   *      notice interfaces that come & go (PCCARD support).
   *      Or we could even support a signal that resets these so that
   *      the PCCARD insert/remove events can signal ppp.
   */
  static char **ifs;		/* Figure these out once */
  static int debug_done;	/* Debug once */

  if (idx > route_nifs || (idx > 0 && ifs[idx-1] == NULL)) {
    int mib[6], have, had;
    size_t needed;
    char *buf, *ptr, *end;
    struct sockaddr_dl *dl;
    struct if_msghdr *ifm;

    if (ifs) {
      free(ifs);
      ifs = NULL;
      route_nifs = 0;
    }
    debug_done = 0;
d210 1
a210 79
    mib[0] = CTL_NET;
    mib[1] = PF_ROUTE;
    mib[2] = 0;
    mib[3] = 0;
    mib[4] = NET_RT_IFLIST;
    mib[5] = 0;

    if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
      log_Printf(LogERROR, "Index2Nam: sysctl: estimate: %s\n",
                 strerror(errno));
      return NumStr(idx, NULL, 0);
    }
    if ((buf = malloc(needed)) == NULL)
      return NumStr(idx, NULL, 0);
    if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
      free(buf);
      return NumStr(idx, NULL, 0);
    }
    end = buf + needed;

    have = 0;
    for (ptr = buf; ptr < end; ptr += ifm->ifm_msglen) {
      ifm = (struct if_msghdr *)ptr;
      if (ifm->ifm_version != RTM_VERSION)
        continue;
      if (ifm->ifm_type != RTM_IFINFO)
        continue;
      dl = (struct sockaddr_dl *)(ifm + 1);
      if (ifm->ifm_index > 0) {
        if (ifm->ifm_index > have) {
          char **newifs;

          had = have;
          have = ifm->ifm_index + 5;
          if (had)
            newifs = (char **)realloc(ifs, sizeof(char *) * have);
          else
            newifs = (char **)calloc(sizeof(char *), have);
          if (!newifs) {
            log_Printf(LogDEBUG, "Index2Nam: %s\n", strerror(errno));
            route_nifs = 0;
            if (ifs) {
              free(ifs);
              ifs = NULL;
            }
            free(buf);
            return NumStr(idx, NULL, 0);
          }
          ifs = newifs;
          memset(ifs + had, '\0', sizeof(char *) * (have - had));
        }
        if (ifs[ifm->ifm_index-1] == NULL) {
          ifs[ifm->ifm_index-1] = (char *)malloc(dl->sdl_nlen+1);
          if (ifs[ifm->ifm_index-1] == NULL)
	    log_Printf(LogDEBUG, "Skipping interface %d: Out of memory\n",
                  ifm->ifm_index);
	  else {
	    memcpy(ifs[ifm->ifm_index-1], dl->sdl_data, dl->sdl_nlen);
	    ifs[ifm->ifm_index-1][dl->sdl_nlen] = '\0';
	    if (route_nifs < ifm->ifm_index)
	      route_nifs = ifm->ifm_index;
	  }
        }
      } else if (log_IsKept(LogDEBUG))
        log_Printf(LogDEBUG, "Skipping out-of-range interface %d!\n",
                  ifm->ifm_index);
    }
    free(buf);
  }

  if (log_IsKept(LogDEBUG) && !debug_done) {
    int f;

    log_Printf(LogDEBUG, "Found the following interfaces:\n");
    for (f = 0; f < route_nifs; f++)
      if (ifs[f] != NULL)
        log_Printf(LogDEBUG, " Index %d, name \"%s\"\n", f+1, ifs[f]);
    debug_done = 1;
  }
d212 1
a212 1
  if (idx < 1 || idx > route_nifs || ifs[idx-1] == NULL)
d215 1
a215 1
  return ifs[idx-1];
@


1.36
log
@rtm->rtm_hdrlen conversion

ok claudio@@, henning@@
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.35 2007/09/02 15:19:39 deraadt Exp $
d253 2
d368 3
d439 3
d522 2
@


1.35
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.34 2005/07/17 20:43:14 brad Exp $
d320 1
a320 1
  wp = (char *)(rtm + 1);
@


1.34
log
@another malloc() check.

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.33 2005/07/17 19:13:25 brad Exp $
d265 1
a265 1
            newifs = (char **)malloc(sizeof(char *) * have);
@


1.33
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.32 2005/07/17 18:34:09 brad Exp $
d620 1
a620 1
  if (!r)
d622 5
@


1.32
log
@rev 1.91

We need filling scopeid to install routes for link-local
scope addresses.

From ume FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.31 2005/07/06 13:56:00 brad Exp $
d44 1
@


1.31
log
@Add a bunch of malloc() return checks

From brian FreeBSD

ok deraadt@@ tdeval@@
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.30 2005/01/20 14:58:14 markus Exp $
d715 18
d773 3
d786 3
@


1.30
log
@backout workaround from rev 1.29 as it breaks host routes and is not
required because multipath routes require RTF_MPATH; ok claudio
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.28 2003/04/07 23:58:53 deraadt Exp $
d280 9
a288 4
          memcpy(ifs[ifm->ifm_index-1], dl->sdl_data, dl->sdl_nlen);
          ifs[ifm->ifm_index-1][dl->sdl_nlen] = '\0';
          if (route_nifs < ifm->ifm_index)
            route_nifs = ifm->ifm_index;
@


1.29
log
@Workaround to work with the new multipath support. Do a RTM_GET first to
decide if a RTM_ADD or a RTM_CHANGE needs to be done when adding new routes.
tested and OK henning@@
@
text
@a710 44
rt_Check(struct bundle *bundle, const struct ncprange *dst)
{
  struct rtmsg rtmes;
  int s, nb, wb, e;
  char *cp;
  struct sockaddr_storage sadst, samask;

  s = ID0socket(PF_ROUTE, SOCK_RAW, 0);
  if (s < 0) {
    log_Printf(LogERROR, "rt_Set: socket(): %s\n", strerror(errno));
    return (-1);
  }
  memset(&rtmes, '\0', sizeof rtmes);
  rtmes.m_rtm.rtm_version = RTM_VERSION;
  rtmes.m_rtm.rtm_type = RTM_GET;
  rtmes.m_rtm.rtm_addrs = RTA_DST;
  rtmes.m_rtm.rtm_seq = ++bundle->routing_seq;
  rtmes.m_rtm.rtm_pid = getpid();
  rtmes.m_rtm.rtm_flags = RTF_UP | RTF_GATEWAY | RTF_STATIC;
 
  ncprange_getsa(dst, &sadst, &samask);
  cp = rtmes.m_space;
  cp += memcpy_roundup(cp, &sadst, sadst.ss_len);

  if (!ncprange_ishost(dst)) {
    cp += memcpy_roundup(cp, &samask, samask.ss_len);
    rtmes.m_rtm.rtm_addrs |= RTA_NETMASK;
  }

  nb = cp - (char *)&rtmes;
  rtmes.m_rtm.rtm_msglen = nb;
  wb = ID0write(s, &rtmes, nb);
  e = errno;
  close(s);
  if (wb == -1) {
    if (rtmes.m_rtm.rtm_errno == ESRCH ||
        (rtmes.m_rtm.rtm_errno == 0 && e == ESRCH))
      return (0);
    return (-1);
  }
  return (1);
}

int
a724 5

  /* check if route is already present */
  if (cmd == RTM_ADD && rt_Check(bundle, dst) == 1)
    cmd = RTM_CHANGE;

d738 1
a738 1
  if (cmd == RTM_ADD || cmd == RTM_CHANGE) {
d753 1
a753 1
  if (cmd == RTM_ADD || cmd == RTM_CHANGE) {
@


1.28
log
@more string cleaning; ok tedu
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.27 2003/04/04 20:25:06 deraadt Exp $
d711 44
d769 5
d787 1
a787 1
  if (cmd == RTM_ADD) {
d802 1
a802 1
  if (cmd == RTM_ADD) {
@


1.27
log
@strlcpy and snprintf; various people ok
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.26 2002/05/16 01:13:39 brian Exp $
d128 1
a128 1
            sprintf(buf+f*3, "%02x:", MAC[f]);
@


1.26
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.25 2002/03/31 02:38:49 brian Exp $
d131 1
a131 1
          strcpy(buf, "??:??:??:??:??:??");
d133 1
a133 1
        sprintf(buf, "<IFT type %d>", dl->sdl_type);
d135 1
a135 1
      sprintf(buf, "<slen %d?>", dl->sdl_slen);
d137 1
a137 1
      sprintf(buf, "link#%d", dl->sdl_index);
d141 1
a141 1
    sprintf(buf, "<AF type %d>", phost->sa_family);
@


1.25
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.24 2002/01/16 14:13:06 brian Exp $
a41 1
#include <netdb.h>
a66 1
#include "ip.h"
d201 2
d213 1
a213 1
  static int nifs, debug_done;	/* Figure out how many once, and debug once */
d215 1
a215 1
  if (idx > nifs || (idx > 0 && ifs[idx-1] == NULL)) {
d225 1
a225 1
      nifs = 0;
d267 1
a267 1
            nifs = 0;
d282 2
a283 2
          if (nifs < ifm->ifm_index)
            nifs = ifm->ifm_index;
d296 1
a296 1
    for (f = 0; f < nifs; f++)
d302 1
a302 1
  if (idx < 1 || idx > nifs || ifs[idx-1] == NULL)
a531 1
  const char *got;
d534 2
a535 2
  while (strcmp(got = Index2Nam(idx), "???"))
    if (!strcmp(got, name))
@


1.24
log
@socket()s first argument should be a protocol family rather than an
address family.
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.23 2002/01/16 13:20:23 brian Exp $
d850 1
a850 1
  rtmes.m_rtm.rtm_flags = RTF_UP | RTF_GATEWAY | RTF_STATIC;
d870 1
@


1.23
log
@socket's first argument is an address family, not a protocol family.
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.22 2001/11/23 19:21:36 brian Exp $
d726 1
a726 1
  s = ID0socket(AF_ROUTE, SOCK_RAW, 0);
d838 1
a838 1
  s = ID0socket(AF_ROUTE, SOCK_RAW, 0);
@


1.22
log
@Remove the hack that ensures that rt_Update() works on FreeBSD.  Now
that the ncpaddr code doesn't create default routes with non-zero
masks, everything works as it should.
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.21 2001/11/23 17:12:20 brian Exp $
d726 1
a726 1
  s = ID0socket(PF_ROUTE, SOCK_RAW, 0);
d838 1
a838 1
  s = ID0socket(PF_ROUTE, SOCK_RAW, 0);
@


1.21
log
@When writing messages to the routing socket, round sockaddr sizes
up in the same way that we expect them to be when we read them.

This is a no-op on i386 and probably on alphas, as we currently
only support AF_INET and AF_INET6.
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.20 2001/11/23 17:12:10 brian Exp $
d870 5
a874 23

#ifdef __FreeBSD__
  /*
   * In order to update the default route under FreeBSD, only the destination
   * address should be specified.  If the (empty) mask or the gateway
   * address are used, the update fails...
   * Conversely, if the gateway and mask are omitted under OpenBSD, the
   * update will fail.
   */
  if (dst)
    ncprange_setsa(&ncpdst, dst, mask);
  else
    ncprange_init(&ncpdst);

  if (!ncprange_isdefault(&ncpdst))
#endif
  {
    rtmes.m_rtm.rtm_addrs |= RTA_GATEWAY;
    p += memcpy_roundup(p, gw, gw->sa_len);
    if (mask) {
      rtmes.m_rtm.rtm_addrs |= RTA_NETMASK;
      p += memcpy_roundup(p, mask, mask->sa_len);
    }
@


1.20
log
@Be paranoid about non-zero netmasks being associated with INET addresses
of 0.0.0.0.

The OpenBSD PF_ROUTE/NET_RT_DUMP sysctl is sending back routes with
RTAX_NETMASK set, but the corresponding sockaddr being 4 zero bytes
(with an address family of zero).  ppp was getting confused by this
and ending up interpreting it as a 0.0.0.0/32 routing table
destination and subsequently failing to do anything with the route.

Specifically, after this fix, ppp under OpenBSD can successfully
change and delete the default route again !
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.19 2001/11/23 15:46:10 brian Exp $
d698 13
d753 1
a753 2
  memcpy(cp, &sadst, sadst.ss_len);
  cp += sadst.ss_len;
d768 1
a768 2
      memcpy(cp, &sagw, sagw.ss_len);
      cp += sagw.ss_len;
d774 1
a774 2
    memcpy(cp, &samask, samask.ss_len);
    cp += samask.ss_len;
d868 1
a868 2
    memcpy(p, dst, dst->sa_len);
    p += dst->sa_len;
d888 1
a888 2
    memcpy(p, gw, gw->sa_len);
    p += gw->sa_len;
d891 1
a891 2
      memcpy(p, mask, mask->sa_len);
      p += mask->sa_len;
@


1.19
log
@Removed an unsed variable (oops)
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.18 2001/11/23 12:38:52 brian Exp $
d320 2
@


1.18
log
@Don't adjust_linklocal() when pulling a sockaddr out of an ncpaddr or
ncprange structure.

Don't write() the netmask for IPv6 sockaddrs to the routing socket if
the prefixlen is 128.


It seems that messages written to the routing socket with the scopeid
set for link local addresses are not understood.  Instead, we have to
put the scopeid in the 5th and 6th bytes of the address (see
adjust_linklocal() in ncpaddr.c).  I think this may be a bug in the
KAME implementation - it should really understand both forms.
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.17 2001/09/04 22:12:46 brian Exp $
d701 1
a701 1
  int s, nb, wb, width;
@


1.17
log
@Fix a diagnostic
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.16 2001/08/20 00:48:14 brian Exp $
d701 1
a701 1
  int domask, s, nb, wb, width;
d760 1
a760 7
  domask = 1;
  if (ncprange_family(dst) == AF_INET) {
    ncprange_getwidth(dst, &width);
    if (width == 32)
      domask = 0;
  }
  if (domask) {
@


1.17.2.1
log
@pullup to 3.0:

Don't call adjust_linklocal() when creating INET6 sockaddrs, and
recognise IPv6 host routes as not requiring a netmask when
writing to the routing table socket.
This gets rid of the warning messages about failing to delete
routes at ppp startup and exit.

Ignore sockaddrs with sa_len of 0 returned by the PF_ROUTE/
NET_RT_DUMP sysctl.  The default route's netmask sockaddr always
has a sa_len of zero.

Ensure that when ppp stores a range with an IP address of 0.0.0.0,
it always has a netmask of 0.0.0.0 too.
This prevents ppp from mis-reading the default route as 0.0.0.0/32.

Pad sockaddrs written to the routing socket to sizeof(long).
This is a no-op on all archs for sockaddr_in and sockaddr_in6.
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.17 2001/09/04 22:12:46 brian Exp $
a319 2
      if (sa[rtax]->sa_family == 0)
        sa[rtax] = NULL;	/* ??? */
a695 13
static size_t
memcpy_roundup(char *cp, const void *data, size_t len)
{
  size_t padlen;

  padlen = ROUNDUP(len);
  memcpy(cp, data, len);
  if (padlen > len)
    memset(cp + len, '\0', padlen - len);

  return padlen;
}

d701 1
a701 1
  int s, nb, wb;
d738 2
a739 1
  cp += memcpy_roundup(cp, &sadst, sadst.ss_len);
d754 2
a755 1
      cp += memcpy_roundup(cp, &sagw, sagw.ss_len);
d760 9
a768 2
  if (!ncprange_ishost(dst)) {
    cp += memcpy_roundup(cp, &samask, samask.ss_len);
d862 2
a863 1
    p += memcpy_roundup(p, dst, dst->sa_len);
d883 2
a884 1
    p += memcpy_roundup(p, gw, gw->sa_len);
d887 2
a888 1
      p += memcpy_roundup(p, mask, mask->sa_len);
@


1.16
log
@When attempting to change the default route under FreeBSD, don't write
the gateway and mask to the routing socket, otherwise the update fails.

The code here was broken for FreeBSD when IPv6 support was added, but
worked for OpenBSD.  OpenBSD expects the gateway and mask to be
supplied and fails the update otherwise.
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.15 2001/08/19 23:22:18 brian Exp $
d750 1
a750 1
                   " destination 0.0.0.0\n");
@


1.15
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.14 2001/08/15 23:35:37 brian Exp $
d841 1
a841 1
  rtmes.m_rtm.rtm_addrs = RTA_GATEWAY;
d865 25
a889 6
  memcpy(p, gw, gw->sa_len);
  p += gw->sa_len;
  if (mask) {
    rtmes.m_rtm.rtm_addrs |= RTA_NETMASK;
    memcpy(p, mask, mask->sa_len);
    p += mask->sa_len;
@


1.14
log
@When updating the MTU for the default route, pass the mask and gateway
to the routing socket.

Submitted by: Russell T Hunt <alaric@@MIT.EDU>
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.13 2001/06/19 10:24:58 brian Exp $
d67 2
d76 2
d89 1
a90 2
  struct sockaddr_in *ihost4 = (struct sockaddr_in *)phost;
  struct sockaddr_in *mask4 = (struct sockaddr_in *)pmask;
d109 9
a117 33
    if (!phost)
      buf[0] = '\0';
    else if (ihost4->sin_addr.s_addr == INADDR_ANY)
      strcpy(buf, "default");
    else if (!pmask) 
      strcpy(buf, inet_ntoa(ihost4->sin_addr));
    else {
      u_int32_t msk = ntohl(mask4->sin_addr.s_addr);
      u_int32_t tst;
      int bits;
      int len;
      struct sockaddr_in net;

      for (tst = 1, bits = 32; tst; tst <<= 1, bits--)
        if (msk & tst)
          break;

      for (tst <<= 1; tst; tst <<= 1)
        if (!(msk & tst))
          break;

      net.sin_addr.s_addr = ihost4->sin_addr.s_addr & mask4->sin_addr.s_addr;
      strcpy(buf, inet_ntoa(net.sin_addr));
      for (len = strlen(buf); len > 3; buf[len -= 2] = '\0')
        if (strcmp(buf + len - 2, ".0"))
          break;

      if (tst)    /* non-contiguous :-( */
        sprintf(buf + strlen(buf),"&0x%08lx", (u_long)msk);
      else
        sprintf(buf + strlen(buf), "/%d", bits);
    }
    break;
a141 49
#ifndef NOINET6
  case AF_INET6:
    if (!phost)
      buf[0] = '\0';
    else {
      const u_char masks[] = { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };
      struct sockaddr_in6 *ihost6 = (struct sockaddr_in6 *)phost;
      struct sockaddr_in6 *mask6 = (struct sockaddr_in6 *)pmask;
      int masklen, len;
      const u_char *c;

      /* XXX: ?????!?!?!!!!!  This is horrible ! */
      if (IN6_IS_ADDR_LINKLOCAL(&ihost6->sin6_addr) ||
          IN6_IS_ADDR_MC_LINKLOCAL(&ihost6->sin6_addr)) {
        ihost6->sin6_scope_id =
          ntohs(*(u_short *)&ihost6->sin6_addr.s6_addr[2]);
        *(u_short *)&ihost6->sin6_addr.s6_addr[2] = 0;
      }

      if (mask6) {
        const u_char *p, *end;

        p = (const u_char *)&mask6->sin6_addr;
        end = p + 16;
        for (masklen = 0, end = p + 16; p < end && *p == 0xff; p++)
          masklen += 8;

        if (p < end) {
          for (c = masks; c < masks + sizeof masks; c++)
            if (*c == *p) {
              masklen += c - masks;
              break;
            }
        }
      } else
        masklen = 128;

      if (masklen == 0 && IN6_IS_ADDR_UNSPECIFIED(&ihost6->sin6_addr))
        snprintf(buf, sizeof buf, "default");
      else {
        getnameinfo(phost, ihost6->sin6_len, buf, sizeof buf,
                    NULL, 0, NI_WITHSCOPEID | NI_NUMERICHOST);
        if (mask6 && (len = strlen(buf)) < sizeof buf - 1)
          snprintf(buf + len, sizeof buf - len, "/%d", masklen);
      }
    }
    break;
#endif

d381 1
a381 2
  struct sockaddr_in **in;
  struct in_addr sa_none;
a387 2
  sa_none.s_addr = INADDR_ANY;
  in = (struct sockaddr_in **)sa;
d427 25
a451 17
      if (sa[RTAX_DST] && sa[RTAX_DST]->sa_family == AF_INET) {
        log_Printf(LogDEBUG, "route_IfDelete: addrs: %x, Netif: %d (%s),"
                   " flags: %x, dst: %s ?\n", rtm->rtm_addrs, rtm->rtm_index,
                   Index2Nam(rtm->rtm_index), rtm->rtm_flags,
                   inet_ntoa(((struct sockaddr_in *)sa[RTAX_DST])->sin_addr));
        if (sa[RTAX_GATEWAY] && rtm->rtm_index == bundle->iface->index &&
            (all || (rtm->rtm_flags & RTF_GATEWAY))) {
          if (sa[RTAX_GATEWAY]->sa_family == AF_INET ||
              sa[RTAX_GATEWAY]->sa_family == AF_LINK) {
            if ((pass == 0 && (rtm->rtm_flags & RTF_WASCLONED)) ||
                (pass == 1 && !(rtm->rtm_flags & RTF_WASCLONED))) {
              log_Printf(LogDEBUG, "route_IfDelete: Remove it (pass %d)\n",
                         pass);
              rt_Set(bundle, RTM_DELETE, in[RTAX_DST]->sin_addr,
                              sa_none, sa_none, 0, 0);
            } else
              log_Printf(LogDEBUG, "route_IfDelete: Skip it (pass %d)\n", pass);
d453 5
a457 4
            log_Printf(LogDEBUG,
                      "route_IfDelete: Can't remove routes of %d family !\n",
                      sa[RTAX_GATEWAY]->sa_family);
        }
d473 1
a473 1
  struct sockaddr_in **in;
a478 1
  in = (struct sockaddr_in **)sa;
d507 13
a519 10
    if (sa[RTAX_DST] && sa[RTAX_DST]->sa_family == AF_INET &&
        sa[RTAX_GATEWAY] && /* sa[RTAX_NETMASK] && */
        rtm->rtm_index == bundle->iface->index &&
        (sa[RTAX_GATEWAY]->sa_family == AF_INET ||
         sa[RTAX_GATEWAY]->sa_family == AF_LINK)) {
      log_Printf(LogTCPIP, "route_UpdateMTU: Netif: %d (%s), dst %s, mtu %d\n",
                 rtm->rtm_index, Index2Nam(rtm->rtm_index),
                 inet_ntoa(((struct sockaddr_in *)sa[RTAX_DST])->sin_addr),
                 bundle->iface->mtu);
      rt_Update(bundle, in[RTAX_DST]->sin_addr, in[RTAX_GATEWAY]->sin_addr);
d543 1
a543 1
             struct in_addr me, struct in_addr peer, struct in_addr dns[2])
d545 1
a545 1
  struct in_addr none, del;
a546 1
  none.s_addr = INADDR_ANY;
d548 43
a590 27
    if ((r->type & ROUTE_DSTMYADDR) && r->dst.s_addr != me.s_addr) {
      del.s_addr = r->dst.s_addr & r->mask.s_addr;
      rt_Set(bundle, RTM_DELETE, del, none, none, 1, 0);
      r->dst = me;
      if (r->type & ROUTE_GWHISADDR)
        r->gw = peer;
    } else if ((r->type & ROUTE_DSTHISADDR) && r->dst.s_addr != peer.s_addr) {
      del.s_addr = r->dst.s_addr & r->mask.s_addr;
      rt_Set(bundle, RTM_DELETE, del, none, none, 1, 0);
      r->dst = peer;
      if (r->type & ROUTE_GWHISADDR)
        r->gw = peer;
    } else if ((r->type & ROUTE_DSTDNS0) && r->dst.s_addr != peer.s_addr) {
      del.s_addr = r->dst.s_addr & r->mask.s_addr;
      rt_Set(bundle, RTM_DELETE, del, none, none, 1, 0);
      r->dst = dns[0];
      if (r->type & ROUTE_GWHISADDR)
        r->gw = peer;
    } else if ((r->type & ROUTE_DSTDNS1) && r->dst.s_addr != peer.s_addr) {
      del.s_addr = r->dst.s_addr & r->mask.s_addr;
      rt_Set(bundle, RTM_DELETE, del, none, none, 1, 0);
      r->dst = dns[1];
      if (r->type & ROUTE_GWHISADDR)
        r->gw = peer;
    } else if ((r->type & ROUTE_GWHISADDR) && r->gw.s_addr != peer.s_addr)
      r->gw = peer;
    rt_Set(bundle, RTM_ADD, r->dst, r->gw, r->mask, 1, 0);
d595 2
a596 2
route_Add(struct sticky_route **rp, int type, struct in_addr dst,
          struct in_addr mask, struct in_addr gw)
d604 1
a604 1
        (!dsttype && (*rp)->dst.s_addr == dst.s_addr)) {
d617 2
a618 3
  r->dst = dst;
  r->mask = mask;
  r->gw = gw;
d623 1
a623 1
route_Delete(struct sticky_route **rp, int type, struct in_addr dst)
d630 1
a630 1
        (!dsttype && dst.s_addr == ((*rp)->dst.s_addr & (*rp)->mask.s_addr))) {
a654 1
  int def;
a662 2
    def = r->dst.s_addr == INADDR_ANY && r->mask.s_addr == INADDR_ANY;

d667 2
d671 2
d677 2
a678 5
    else if (!def)
      prompt_Printf(p, "%s", inet_ntoa(r->dst));

    if (def)
      prompt_Printf(p, "default ");
d680 1
a680 1
      prompt_Printf(p, " %s ", inet_ntoa(r->mask));
d683 3
a685 1
      prompt_Printf(p, "HISADDR\n");
d687 1
a687 1
      prompt_Printf(p, "%s\n", inet_ntoa(r->gw));
d693 1
a693 1
  char m_space[64];
d697 2
a698 2
rt_Set(struct bundle *bundle, int cmd, struct in_addr dst,
                struct in_addr gateway, struct in_addr mask, int bang, int ssh)
d701 1
a701 1
  int s, nb, wb;
d704 1
a704 1
  struct sockaddr_in rtdata;
d725 2
a726 2
    if (bundle->ncp.ipcp.cfg.sendpipe > 0) {
      rtmes.m_rtm.rtm_rmx.rmx_sendpipe = bundle->ncp.ipcp.cfg.sendpipe;
d729 2
a730 2
    if (bundle->ncp.ipcp.cfg.recvpipe > 0) {
      rtmes.m_rtm.rtm_rmx.rmx_recvpipe = bundle->ncp.ipcp.cfg.recvpipe;
d735 1
a735 5
  memset(&rtdata, '\0', sizeof rtdata);
  rtdata.sin_len = sizeof rtdata;
  rtdata.sin_family = AF_INET;
  rtdata.sin_port = 0;
  rtdata.sin_addr = dst;
d738 2
a739 2
  memcpy(cp, &rtdata, rtdata.sin_len);
  cp += rtdata.sin_len;
d741 8
a748 2
    if (gateway.s_addr == INADDR_ANY) {
      if (!ssh)
d754 2
a755 3
      rtdata.sin_addr = gateway;
      memcpy(cp, &rtdata, rtdata.sin_len);
      cp += rtdata.sin_len;
d760 9
a768 7
  if (dst.s_addr == INADDR_ANY)
    mask.s_addr = INADDR_ANY;

  if (cmd == RTM_ADD || dst.s_addr == INADDR_ANY) {
    rtdata.sin_addr = mask;
    memcpy(cp, &rtdata, rtdata.sin_len);
    cp += rtdata.sin_len;
d778 3
a780 4
    log_Printf(LogTCPIP, "rt_Set:  Dst = %s\n", inet_ntoa(dst));
    log_Printf(LogTCPIP, "rt_Set:  Gateway = %s\n",
               inet_ntoa(gateway));
    log_Printf(LogTCPIP, "rt_Set:  Mask = %s\n", inet_ntoa(mask));
d786 1
a786 1
		  dst.s_addr == 0 ? "default" : inet_ntoa(dst));
d798 1
a798 1
                  inet_ntoa(dst));
d800 1
a800 1
      if (!ssh || errno != ENETUNREACH)
d802 1
a802 1
                   inet_ntoa(dst), strerror(errno));
d805 1
a805 1
		 cmdstr, inet_ntoa(dst), strerror(rtmes.m_rtm.rtm_errno));
d808 10
a817 2
  log_Printf(LogDEBUG, "wrote %d: cmd = %s, dst = %x, gateway = %x\n",
            wb, cmdstr, (unsigned)dst.s_addr, (unsigned)gateway.s_addr);
d824 2
a825 1
rt_Update(struct bundle *bundle, struct in_addr dst, struct in_addr gw)
d827 1
d829 1
a830 1
  struct sockaddr_in rtdata;
d841 1
a841 1
  rtmes.m_rtm.rtm_addrs = RTA_DST;
d846 2
a847 2
  if (bundle->ncp.ipcp.cfg.sendpipe > 0) {
    rtmes.m_rtm.rtm_rmx.rmx_sendpipe = bundle->ncp.ipcp.cfg.sendpipe;
d851 2
a852 2
  if (bundle->ncp.ipcp.cfg.recvpipe > 0) {
    rtmes.m_rtm.rtm_rmx.rmx_recvpipe = bundle->ncp.ipcp.cfg.recvpipe;
d858 1
d860 11
a870 16
  memset(&rtdata, '\0', sizeof rtdata);
  rtdata.sin_len = sizeof rtdata;
  rtdata.sin_family = AF_INET;
  rtdata.sin_port = 0;
  rtdata.sin_addr = dst;

  memcpy(rtmes.m_space, &rtdata, rtdata.sin_len);
  rtmes.m_rtm.rtm_msglen = rtmes.m_space + rtdata.sin_len - (char *)&rtmes;

  if (dst.s_addr == INADDR_ANY) {
    rtdata.sin_addr = gw;
    memcpy(&rtmes.m_space[rtdata.sin_len], &rtdata, rtdata.sin_len);
    rtdata.sin_addr.s_addr = INADDR_ANY;
    memcpy(&rtmes.m_space[2 * rtdata.sin_len], &rtdata, rtdata.sin_len);
    rtmes.m_rtm.rtm_addrs |= RTA_GATEWAY | RTA_NETMASK;
    rtmes.m_rtm.rtm_msglen += 2 * rtdata.sin_len;
d873 2
d877 2
d880 1
a880 2
    log_Printf(LogTCPIP, "rt_Update:  Dst = %s\n", inet_ntoa(dst));
    log_Printf(LogTCPIP, "rt_Update:  Gateway = %s\n", inet_ntoa(gw));
d884 1
a884 1
                 inet_ntoa(dst), strerror(errno));
d887 1
a887 1
		 inet_ntoa(dst), strerror(rtmes.m_rtm.rtm_errno));
a888 2
  log_Printf(LogDEBUG, "wrote %d: cmd = Change, dst = %x, gateway = %x\n",
            wb, (unsigned)dst.s_addr, (unsigned)gw.s_addr);
@


1.13
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d28 1
a28 1
 * $OpenBSD: route.c,v 1.12 2001/06/13 21:33:42 brian Exp $
d903 9
@


1.12
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d580 2
a581 3
                 bundle->mtu);
      rt_Update(bundle, in[RTAX_DST]->sin_addr,
                         in[RTAX_GATEWAY]->sin_addr);
d892 1
a892 1
  rtmes.m_rtm.rtm_rmx.rmx_mtu = bundle->mtu;
@


1.11
log
@When we change the interface MTU, run through the routing table and tweak
all route MTUs too.
@
text
@d1 5
a5 2
/*
 *	      PPP Routing related Module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 15
 *   Copyright (C) 1994, Internet Initiative Japan, Inc. All rights reserverd.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: route.c,v 1.10 2000/09/02 22:12:41 brian Exp $
d28 1
@


1.10
log
@Don't delete sticky routes on exit as we may not have successfully
added them yet.  Instead just rely on our deleting all routes
associated with our interface.
@
text
@d20 1
a20 1
 * $OpenBSD: route.c,v 1.9 2000/07/20 10:39:10 brian Exp $
d43 1
d71 1
d147 1
a147 1
	  strcpy(buf, "??:??:??:??:??:??");
d463 1
a463 1
	      strerror(errno));
d473 1
a473 1
	      strerror(errno));
d495 3
a497 3
                  " flags: %x, dst: %s ?\n", rtm->rtm_addrs, rtm->rtm_index,
                  Index2Nam(rtm->rtm_index), rtm->rtm_flags,
	          inet_ntoa(((struct sockaddr_in *)sa[RTAX_DST])->sin_addr));
d499 1
a499 1
	    (all || (rtm->rtm_flags & RTF_GATEWAY))) {
d506 1
a506 1
              bundle_SetRoute(bundle, RTM_DELETE, in[RTAX_DST]->sin_addr,
d521 61
d607 1
a607 1
      bundle_SetRoute(bundle, RTM_DELETE, del, none, none, 1, 0);
d613 1
a613 1
      bundle_SetRoute(bundle, RTM_DELETE, del, none, none, 1, 0);
d619 1
a619 1
      bundle_SetRoute(bundle, RTM_DELETE, del, none, none, 1, 0);
d625 1
a625 1
      bundle_SetRoute(bundle, RTM_DELETE, del, none, none, 1, 0);
d631 1
a631 1
    bundle_SetRoute(bundle, RTM_ADD, r->dst, r->gw, r->mask, 1, 0);
d731 183
@


1.9
log
@Don't mis-interpret sockaddr_in6 structures as sockaddr_in structures
when purging routes.
@
text
@d20 1
a20 1
 * $OpenBSD: route.c,v 1.8 2000/03/19 10:33:34 brian Exp $
a568 12
  }
}

void
route_Clean(struct bundle *bundle, struct sticky_route *r)
{
  struct in_addr none, del;

  none.s_addr = INADDR_ANY;
  for (; r; r = r->next) {
    del.s_addr = r->dst.s_addr & r->mask.s_addr;
    bundle_SetRoute(bundle, RTM_DELETE, del, none, none, 1, 0);
@


1.8
log
@Allow environment variables on command/config lines; markk@@knigma.org
Add the ``resolv'' command so that when ``enable dns''
is used, it's possible to restore the file.
@
text
@d20 1
a20 1
 * $OpenBSD: route.c,v 1.7 2000/02/27 01:38:28 brian Exp $
d491 1
a491 1
      if (sa[RTAX_DST]) {
@


1.7
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: route.c,v 1.6 2000/02/27 00:21:09 brian Exp $
d536 1
a536 1
             struct in_addr me, struct in_addr peer)
d554 12
d663 4
@


1.6
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d20 1
a20 1
 * $Id: route.c,v 1.5 2000/01/07 03:26:55 brian Exp $
@


1.5
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: route.c,v 1.4 1999/05/08 11:06:39 brian Exp $
d35 1
d71 1
d77 2
a78 2
  struct sockaddr_in *ihost = (struct sockaddr_in *)phost;
  struct sockaddr_in *mask = (struct sockaddr_in *)pmask;
d81 14
d99 1
a99 1
    else if (ihost->sin_addr.s_addr == INADDR_ANY)
d101 2
a102 2
    else if (!mask) 
      strcpy(buf, inet_ntoa(ihost->sin_addr));
d104 1
a104 1
      u_int32_t msk = ntohl(mask->sin_addr.s_addr);
d110 1
a110 1
      for (tst = 1, bits=32; tst; tst <<= 1, bits--)
d118 1
a118 1
      net.sin_addr.s_addr = ihost->sin_addr.s_addr & mask->sin_addr.s_addr;
d154 49
d300 1
a300 1
      return "???";
d303 1
a303 1
      return "???";
d306 1
a306 1
      return "???";
d313 2
d334 1
a334 1
            return "???";
d364 1
a364 1
    return "???";
d369 16
d389 2
a390 2
  struct sockaddr *sa_dst, *sa_gw, *sa_mask;
  char *sp, *ep, *cp, *wp;
d417 1
a417 2
    rtm = (struct rt_msghdr *) cp;
    wp = (char *)(rtm+1);
d419 1
a419 5
    if (rtm->rtm_addrs & RTA_DST) {
      sa_dst = (struct sockaddr *)wp;
      wp += sa_dst->sa_len;
    } else
      sa_dst = NULL;
d421 3
a423 5
    if (rtm->rtm_addrs & RTA_GATEWAY) {
      sa_gw = (struct sockaddr *)wp;
      wp += sa_gw->sa_len;
    } else
      sa_gw = NULL;
d425 2
a426 3
    if (rtm->rtm_addrs & RTA_NETMASK) {
      sa_mask = (struct sockaddr *)wp;
      wp += sa_mask->sa_len;
d428 1
a428 7
      sa_mask = NULL;

    p_sockaddr(arg->prompt, sa_dst, sa_mask, 20);
    p_sockaddr(arg->prompt, sa_gw, NULL, 20);

    p_flags(arg->prompt, rtm->rtm_flags, 6);
    prompt_Printf(arg->prompt, " %s\n", Index2Nam(rtm->rtm_index));
d441 3
a443 2
  struct sockaddr *sa;
  struct in_addr sa_dst, sa_none;
d451 1
d480 1
a480 1
     * deletes all non-cloned routes.  This is necessary to avoid
d489 19
a507 16
      rtm = (struct rt_msghdr *) cp;
      sa = (struct sockaddr *) (rtm + 1);
      log_Printf(LogDEBUG, "route_IfDelete: addrs: %x, Netif: %d (%s),"
                " flags: %x, dst: %s ?\n", rtm->rtm_addrs, rtm->rtm_index,
                Index2Nam(rtm->rtm_index), rtm->rtm_flags,
	        inet_ntoa(((struct sockaddr_in *) sa)->sin_addr));
      if (rtm->rtm_addrs & RTA_DST && rtm->rtm_addrs & RTA_GATEWAY &&
	  rtm->rtm_index == bundle->iface->index &&
	  (all || (rtm->rtm_flags & RTF_GATEWAY))) {
        sa_dst.s_addr = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
        sa = (struct sockaddr *)((char *)sa + sa->sa_len);
        if (sa->sa_family == AF_INET || sa->sa_family == AF_LINK) {
          if ((pass == 0 && (rtm->rtm_flags & RTF_WASCLONED)) ||
              (pass == 1 && !(rtm->rtm_flags & RTF_WASCLONED))) {
            log_Printf(LogDEBUG, "route_IfDelete: Remove it (pass %d)\n", pass);
            bundle_SetRoute(bundle, RTM_DELETE, sa_dst, sa_none, sa_none, 0, 0);
d509 4
a512 5
            log_Printf(LogDEBUG, "route_IfDelete: Skip it (pass %d)\n", pass);
        } else
          log_Printf(LogDEBUG,
                    "route_IfDelete: Can't remove routes of %d family !\n",
                    sa->sa_family);
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: route.c,v 1.3 1999/02/06 03:22:46 brian Exp $
d211 1
a211 1
  if (!nifs) {
d218 7
d262 1
a262 1
            if (ifs)
d264 3
@


1.3
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: route.c,v 1.55 1999/01/28 01:56:34 brian Exp $
d43 1
@


1.2
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d20 1
a20 1
 * $Id: route.c,v 1.1 1998/08/31 00:22:27 brian Exp $
d24 1
a24 1
#include <sys/types.h>
d61 3
d492 2
a493 13
  if (type != ROUTE_STATIC) {
    struct sticky_route *r;
    int dsttype = type & ROUTE_DSTANY;

    r = NULL;
    while (*rp) {
      if ((dsttype && dsttype == ((*rp)->type & ROUTE_DSTANY)) ||
          (!dsttype && (*rp)->dst.s_addr == dst.s_addr)) {
        r = *rp;
        *rp = r->next;
      } else
        rp = &(*rp)->next;
    }
d495 10
a504 8
    if (!r)
      r = (struct sticky_route *)malloc(sizeof(struct sticky_route));
    r->type = type;
    r->next = NULL;
    r->dst = dst;
    r->mask = mask;
    r->gw = gw;
    *rp = r;
d506 9
d547 2
a548 1
route_ShowSticky(struct prompt *p, struct sticky_route *r)
d551 6
a557 1
  prompt_Printf(p, "Sticky routes:\n");
d561 2
a562 1
    prompt_Printf(p, " add ");
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: route.c,v 1.53 1998/08/17 06:42:40 brian Exp $
d64 1
d365 1
a365 1
  log_Printf(LogDEBUG, "route_IfDelete (%d)\n", bundle->ifp.Index);
d411 1
a411 1
	  rtm->rtm_index == bundle->ifp.Index &&
@

