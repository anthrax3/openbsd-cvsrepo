head	1.23;
access;
symbols
	OPENBSD_5_5:1.22.0.6
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.32
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.30
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.28
	OPENBSD_5_0:1.21.0.26
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.24
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.22
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.18
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.20
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.16
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.14
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.12
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.10
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.8
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.6
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.12
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.10
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.8
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.6
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.4
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.22;

1.22
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.21;

1.21
date	2005.07.06.13.56.00;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.23.11.17.03;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.18.00.02.10;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.09.19.31.25;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.27.01.38.25;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.27.00.21.06;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.07.03.26.53;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.08.17.15.00.38;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.06.26.02.57.01;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.06.26.02.56.52;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.09.08.47.23;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.27.09.51.12;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.08.11.06.34;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.02.12.00.53.08;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.22.33;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.10.29.02.21.44;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.18;	author brian;	state Exp;
branches;
next	;


desc
@@


1.23
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1998 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: chat.c,v 1.22 2013/04/29 00:28:23 okan Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "mbuf.h"
#include "log.h"
#include "defs.h"
#include "timer.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "fsm.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "async.h"
#include "descriptor.h"
#include "physical.h"
#include "chat.h"
#include "mp.h"
#include "auth.h"
#include "chap.h"
#include "slcompress.h"
#include "iplist.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "cbcp.h"
#include "command.h"
#include "datalink.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "id.h"

#define BUFLEFT(c) (sizeof (c)->buf - ((c)->bufend - (c)->buf))

static void ExecStr(struct physical *, char *, char *, int);
static char *ExpandString(struct chat *, const char *, char *, int, int);

static void
chat_PauseTimer(void *v)
{
  struct chat *c = (struct chat *)v;
  timer_Stop(&c->pause);
  c->pause.load = 0;
}

static void
chat_Pause(struct chat *c, u_long load)
{
  timer_Stop(&c->pause);
  c->pause.load += load;
  c->pause.func = chat_PauseTimer;
  c->pause.name = "chat pause";
  c->pause.arg = c;
  timer_Start(&c->pause);
}

static void
chat_TimeoutTimer(void *v)
{
  struct chat *c = (struct chat *)v;
  timer_Stop(&c->timeout);
  c->TimedOut = 1;
}

static void
chat_SetTimeout(struct chat *c)
{
  timer_Stop(&c->timeout);
  if (c->TimeoutSec > 0) {
    c->timeout.load = SECTICKS * c->TimeoutSec;
    c->timeout.func = chat_TimeoutTimer;
    c->timeout.name = "chat timeout";
    c->timeout.arg = c;
    timer_Start(&c->timeout);
  }
}

static char *
chat_NextChar(char *ptr, char ch)
{
  for (; *ptr; ptr++)
    if (*ptr == ch)
      return ptr;
    else if (*ptr == '\\')
      if (*++ptr == '\0')
        return NULL;

  return NULL;
}

static int
chat_UpdateSet(struct fdescriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
{
  struct chat *c = descriptor2chat(d);
  int special, gotabort, gottimeout, needcr;
  int TimedOut = c->TimedOut;
  static char arg_term;		/* An empty string */

  if (c->pause.state == TIMER_RUNNING)
    return 0;

  if (TimedOut) {
    log_Printf(LogCHAT, "Expect timeout\n");
    if (c->nargptr == NULL)
      c->state = CHAT_FAILED;
    else {
      /* c->state = CHAT_EXPECT; */
      c->argptr = &arg_term;
    }
    c->TimedOut = 0;
  }

  if (c->state != CHAT_EXPECT && c->state != CHAT_SEND)
    return 0;

  gottimeout = gotabort = 0;

  if (c->arg < c->argc && (c->arg < 0 || *c->argptr == '\0')) {
    /* Go get the next string */
    if (c->arg < 0 || c->state == CHAT_SEND)
      c->state = CHAT_EXPECT;
    else
      c->state = CHAT_SEND;

    special = 1;
    while (special && (c->nargptr || c->arg < c->argc - 1)) {
      if (c->arg < 0 || (!TimedOut && c->state == CHAT_SEND))
        c->nargptr = NULL;

      if (c->nargptr != NULL) {
        /* We're doing expect-send-expect.... */
        c->argptr = c->nargptr;
        /* Put the '-' back in case we ever want to rerun our script */
        c->nargptr[-1] = '-';
        c->nargptr = chat_NextChar(c->nargptr, '-');
        if (c->nargptr != NULL)
          *c->nargptr++ = '\0';
      } else {
        int minus;

        if ((c->argptr = c->argv[++c->arg]) == NULL) {
          /* End of script - all ok */
          c->state = CHAT_DONE;
          return 0;
        }

        if (c->state == CHAT_EXPECT) {
          /* Look for expect-send-expect sequence */
          c->nargptr = c->argptr;
          minus = 0;
          while ((c->nargptr = chat_NextChar(c->nargptr, '-'))) {
            c->nargptr++;
            minus++;
          }

          if (minus % 2)
            log_Printf(LogWARN, "chat_UpdateSet: \"%s\": Uneven number of"
                      " '-' chars, all ignored\n", c->argptr);
          else if (minus) {
            c->nargptr = chat_NextChar(c->argptr, '-');
            *c->nargptr++ = '\0';
          }
        }
      }

      /*
       * c->argptr now temporarily points into c->script (via c->argv)
       * If it's an expect-send-expect sequence, we've just got the correct
       * portion of that sequence.
       */

      needcr = c->state == CHAT_SEND &&
               (*c->argptr != '!' || c->argptr[1] == '!');

      /* We leave room for a potential HDLC header in the target string */
      ExpandString(c, c->argptr, c->exp + 2, sizeof c->exp - 2, needcr);

      /*
       * Now read our string.  If it's not a special string, we unset
       * ``special'' to break out of the loop.
       */
      if (gotabort) {
        if (c->abort.num < MAXABORTS) {
          int len, i;

          len = strlen(c->exp+2);
          for (i = 0; i < c->abort.num; i++)
            if (len > c->abort.string[i].len) {
              int last;

              for (last = c->abort.num; last > i; last--) {
                c->abort.string[last].data = c->abort.string[last-1].data;
                c->abort.string[last].len = c->abort.string[last-1].len;
              }
              break;
            }
          c->abort.string[i].len = len;
          if ((c->abort.string[i].data = (char *)malloc(len+1)) != NULL) {
            memcpy(c->abort.string[i].data, c->exp+2, len+1);
            c->abort.num++;
	  }
        } else
          log_Printf(LogERROR, "chat_UpdateSet: too many abort strings\n");
        gotabort = 0;
      } else if (gottimeout) {
        c->TimeoutSec = atoi(c->exp + 2);
        if (c->TimeoutSec <= 0)
          c->TimeoutSec = 30;
        gottimeout = 0;
      } else if (c->nargptr == NULL && !strcmp(c->exp+2, "ABORT"))
        gotabort = 1;
      else if (c->nargptr == NULL && !strcmp(c->exp+2, "TIMEOUT"))
        gottimeout = 1;
      else {
        if (c->exp[2] == '!' && c->exp[3] != '!')
          ExecStr(c->physical, c->exp + 3, c->exp + 3, sizeof c->exp - 3);

        if (c->exp[2] == '\0') {
          /* Empty string, reparse (this may be better as a `goto start') */
          c->argptr = &arg_term;
          return chat_UpdateSet(d, r, w, e, n);
        }

        special = 0;
      }
    }

    if (special) {
      if (gottimeout)
        log_Printf(LogWARN, "chat_UpdateSet: TIMEOUT: Argument expected\n");
      else if (gotabort)
        log_Printf(LogWARN, "chat_UpdateSet: ABORT: Argument expected\n");

      /* End of script - all ok */
      c->state = CHAT_DONE;
      return 0;
    }

    /* set c->argptr to point in the right place */
    c->argptr = c->exp + (c->exp[2] == '!' ? 3 : 2);
    c->arglen = strlen(c->argptr);

    if (c->state == CHAT_EXPECT) {
      /* We must check to see if the string's already been found ! */
      char *begin, *end;

      end = c->bufend - c->arglen + 1;
      if (end < c->bufstart)
        end = c->bufstart;
      for (begin = c->bufstart; begin < end; begin++)
        if (!strncmp(begin, c->argptr, c->arglen)) {
          c->bufstart = begin + c->arglen;
          c->argptr += c->arglen;
          c->arglen = 0;
          /* Continue - we've already read our expect string */
          return chat_UpdateSet(d, r, w, e, n);
        }

      log_Printf(LogCHAT, "Expect(%d): %s\n", c->TimeoutSec, c->argptr);
      chat_SetTimeout(c);
    }
  }

  /*
   * We now have c->argptr pointing at what we want to expect/send and
   * c->state saying what we want to do... we now know what to put in
   * the fd_set :-)
   */

  if (c->state == CHAT_EXPECT)
    return physical_doUpdateSet(&c->physical->desc, r, NULL, e, n, 1);
  else
    return physical_doUpdateSet(&c->physical->desc, NULL, w, e, n, 1);
}

static int
chat_IsSet(struct fdescriptor *d, const fd_set *fdset)
{
  struct chat *c = descriptor2chat(d);
  return c->argptr && physical_IsSet(&c->physical->desc, fdset);
}

static void
chat_UpdateLog(struct chat *c, int in)
{
  if (log_IsKept(LogCHAT) || log_IsKept(LogCONNECT)) {
    /*
     * If a linefeed appears in the last `in' characters of `c's input
     * buffer, output from there, all the way back to the last linefeed.
     * This is called for every read of `in' bytes.
     */
    char *ptr, *end, *stop, ch;
    int level;

    level = log_IsKept(LogCHAT) ? LogCHAT : LogCONNECT;
    if (in == -1)
      end = ptr = c->bufend;
    else {
      ptr = c->bufend - in;
      for (end = c->bufend - 1; end >= ptr; end--)
        if (*end == '\n')
          break;
    }

    if (end >= ptr) {
      for (ptr = c->bufend - (in == -1 ? 1 : in + 1); ptr >= c->bufstart; ptr--)
        if (*ptr == '\n')
          break;
      ptr++;
      stop = NULL;
      while (stop < end) {
        if ((stop = memchr(ptr, '\n', end - ptr)) == NULL)
          stop = end;
        ch = *stop;
        *stop = '\0';
        if (level == LogCHAT || strstr(ptr, "CONNECT"))
          log_Printf(level, "Received: %s\n", ptr);
        *stop = ch;
        ptr = stop + 1;
      }
    }
  }
}

static void
chat_Read(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  struct chat *c = descriptor2chat(d);

  if (c->state == CHAT_EXPECT) {
    ssize_t in;
    char *abegin, *ebegin, *begin, *aend, *eend, *end;
    int n;

    /*
     * XXX - should this read only 1 byte to guarantee that we don't
     * swallow any ppp talk from the peer ?
     */
    in = BUFLEFT(c);
    if (in > sizeof c->buf / 2)
      in = sizeof c->buf / 2;

    in = physical_Read(c->physical, c->bufend, in);
    if (in <= 0)
      return;

    /* `begin' and `end' delimit where we're going to strncmp() from */
    ebegin = c->bufend - c->arglen + 1;
    eend = ebegin + in;
    if (ebegin < c->bufstart)
      ebegin = c->bufstart;

    if (c->abort.num) {
      abegin = c->bufend - c->abort.string[0].len + 1;
      aend = c->bufend - c->abort.string[c->abort.num-1].len + in + 1;
      if (abegin < c->bufstart)
        abegin = c->bufstart;
    } else {
      abegin = ebegin;
      aend = eend;
    }
    begin = abegin < ebegin ? abegin : ebegin;
    end = aend < eend ? eend : aend;

    c->bufend += in;

    chat_UpdateLog(c, in);

    if (c->bufend > c->buf + sizeof c->buf / 2) {
      /* Shuffle our receive buffer back a bit */
      int chop;

      for (chop = begin - c->buf; chop; chop--)
        if (c->buf[chop] == '\n')
          /* found some already-logged garbage to remove :-) */
          break;

      if (!chop)
        chop = begin - c->buf;

      if (chop) {
        char *from, *to;

        to = c->buf;
        from = to + chop;
        while (from < c->bufend)
          *to++ = *from++;
        c->bufstart -= chop;
        c->bufend -= chop;
        begin -= chop;
        end -= chop;
        abegin -= chop;
        aend -= chop;
        ebegin -= chop;
        eend -= chop;
      }
    }

    for (; begin < end; begin++)
      if (begin >= ebegin && begin < eend &&
          !strncmp(begin, c->argptr, c->arglen)) {
        /* Got it ! */
        timer_Stop(&c->timeout);
        if (memchr(begin + c->arglen - 1, '\n',
            c->bufend - begin - c->arglen + 1) == NULL) {
          /* force it into the log */
          end = c->bufend;
          c->bufend = begin + c->arglen;
          chat_UpdateLog(c, -1);
          c->bufend = end;
        }
        c->bufstart = begin + c->arglen;
        c->argptr += c->arglen;
        c->arglen = 0;
        break;
      } else if (begin >= abegin && begin < aend) {
        for (n = c->abort.num - 1; n >= 0; n--) {
          if (begin + c->abort.string[n].len > c->bufend)
            break;
          if (!strncmp(begin, c->abort.string[n].data,
                       c->abort.string[n].len)) {
            if (memchr(begin + c->abort.string[n].len - 1, '\n',
                c->bufend - begin - c->abort.string[n].len + 1) == NULL) {
              /* force it into the log */
              end = c->bufend;
              c->bufend = begin + c->abort.string[n].len;
              chat_UpdateLog(c, -1);
              c->bufend = end;
            }
            c->bufstart = begin + c->abort.string[n].len;
            c->state = CHAT_FAILED;
            return;
          }
        }
      }
  }
}

static int
chat_Write(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  struct chat *c = descriptor2chat(d);
  int result = 0;

  if (c->state == CHAT_SEND) {
    int wrote;

    if (strstr(c->argv[c->arg], "\\P"))            /* Don't log the password */
      log_Printf(LogCHAT, "Send: %s\n", c->argv[c->arg]);
    else {
      int sz;

      sz = c->arglen - 1;
      while (sz >= 0 && c->argptr[sz] == '\n')
        sz--;
      log_Printf(LogCHAT, "Send: %.*s\n", sz + 1, c->argptr);
    }

    if (physical_IsSync(c->physical)) {
      /*
       * XXX: Fix me
       * This data should be stuffed down through the link layers
       */
      /* There's always room for the HDLC header */
      c->argptr -= 2;
      c->arglen += 2;
      memcpy(c->argptr, "\377\003", 2);	/* Prepend HDLC header */
    }

    wrote = physical_Write(c->physical, c->argptr, c->arglen);
    result = wrote > 0 ? 1 : 0;
    if (wrote == -1) {
      if (errno != EINTR) {
        log_Printf(LogWARN, "chat_Write: %s\n", strerror(errno));
	result = -1;
      }
      if (physical_IsSync(c->physical)) {
        c->argptr += 2;
        c->arglen -= 2;
      }
    } else if (wrote < 2 && physical_IsSync(c->physical)) {
      /* Oops - didn't even write our HDLC header ! */
      c->argptr += 2;
      c->arglen -= 2;
    } else {
      c->argptr += wrote;
      c->arglen -= wrote;
    }
  }

  return result;
}

void
chat_Init(struct chat *c, struct physical *p)
{
  c->desc.type = CHAT_DESCRIPTOR;
  c->desc.UpdateSet = chat_UpdateSet;
  c->desc.IsSet = chat_IsSet;
  c->desc.Read = chat_Read;
  c->desc.Write = chat_Write;
  c->physical = p;
  *c->script = '\0';
  c->argc = 0;
  c->arg = -1;
  c->argptr = NULL;
  c->nargptr = NULL;
  c->bufstart = c->bufend = c->buf;

  memset(&c->pause, '\0', sizeof c->pause);
  memset(&c->timeout, '\0', sizeof c->timeout);
}

int
chat_Setup(struct chat *c, const char *data, const char *phone)
{
  c->state = CHAT_EXPECT;

  if (data == NULL) {
    *c->script = '\0';
    c->argc = 0;
  } else {
    strncpy(c->script, data, sizeof c->script - 1);
    c->script[sizeof c->script - 1] = '\0';
    c->argc = MakeArgs(c->script, c->argv, VECSIZE(c->argv), PARSE_NOHASH);
  }

  c->arg = -1;
  c->argptr = NULL;
  c->nargptr = NULL;

  c->TimeoutSec = 30;
  c->TimedOut = 0;
  c->phone = phone;
  c->abort.num = 0;

  timer_Stop(&c->pause);
  timer_Stop(&c->timeout);

  return c->argc >= 0;
}

void
chat_Finish(struct chat *c)
{
  timer_Stop(&c->pause);
  timer_Stop(&c->timeout);
  while (c->abort.num)
    free(c->abort.string[--c->abort.num].data);
  c->abort.num = 0;
}

void
chat_Destroy(struct chat *c)
{
  chat_Finish(c);
}

/*
 *  \c	don't add a cr
 *  \d  Sleep a little (delay 2 seconds
 *  \n  Line feed character
 *  \P  Auth Key password
 *  \p  pause 0.25 sec
 *  \r	Carrige return character
 *  \s  Space character
 *  \T  Telephone number(s) (defined via `set phone')
 *  \t  Tab character
 *  \U  Auth User
 */
static char *
ExpandString(struct chat *c, const char *str, char *result, int reslen, int cr)
{
  int len;

  result[--reslen] = '\0';
  while (*str && reslen > 0) {
    switch (*str) {
    case '\\':
      str++;
      switch (*str) {
      case 'c':
	cr = 0;
	break;
      case 'd':		/* Delay 2 seconds */
        chat_Pause(c, 2 * SECTICKS);
	break;
      case 'p':
        chat_Pause(c, SECTICKS / 4);
	break;		/* Delay 0.25 seconds */
      case 'n':
	*result++ = '\n';
	reslen--;
	break;
      case 'r':
	*result++ = '\r';
	reslen--;
	break;
      case 's':
	*result++ = ' ';
	reslen--;
	break;
      case 't':
	*result++ = '\t';
	reslen--;
	break;
      case 'P':
	strncpy(result, c->physical->dl->bundle->cfg.auth.key, reslen);
        len = strlen(result);
	reslen -= len;
	result += len;
	break;
      case 'T':
        if (c->phone) {
          strncpy(result, c->phone, reslen);
          len = strlen(result);
          reslen -= len;
          result += len;
        }
	break;
      case 'U':
	strncpy(result, c->physical->dl->bundle->cfg.auth.name, reslen);
        len = strlen(result);
	reslen -= len;
	result += len;
	break;
      default:
	reslen--;
	*result++ = *str;
	break;
      }
      if (*str)
	str++;
      break;
    case '^':
      str++;
      if (*str) {
	*result++ = *str++ & 0x1f;
	reslen--;
      }
      break;
    default:
      *result++ = *str++;
      reslen--;
      break;
    }
  }
  if (--reslen > 0) {
    if (cr)
      *result++ = '\r';
  }
  if (--reslen > 0)
    *result++ = '\0';
  return (result);
}

static void
ExecStr(struct physical *physical, char *command, char *out, int olen)
{
  pid_t pid;
  int fids[2];
  char *argv[MAXARGS], *vector[MAXARGS], *startout, *endout;
  int stat, nb, argc, i;

  log_Printf(LogCHAT, "Exec: %s\n", command);
  if ((argc = MakeArgs(command, vector, VECSIZE(vector),
                       PARSE_REDUCE|PARSE_NOHASH)) <= 0) {
    if (argc < 0)
      log_Printf(LogWARN, "Syntax error in exec command\n");
    *out = '\0';
    return;
  }

  if (pipe(fids) < 0) {
    log_Printf(LogCHAT, "Unable to create pipe in ExecStr: %s\n",
	      strerror(errno));
    *out = '\0';
    return;
  }
  if ((pid = fork()) == 0) {
    command_Expand(argv, argc, (char const *const *)vector,
                   physical->dl->bundle, 0, getpid());
    close(fids[0]);
    timer_TermService();
    if (fids[1] == STDIN_FILENO)
      fids[1] = dup(fids[1]);
    dup2(physical->fd, STDIN_FILENO);
    dup2(fids[1], STDERR_FILENO);
    dup2(STDIN_FILENO, STDOUT_FILENO);
    close(3);
    if (open(_PATH_TTY, O_RDWR) != 3)
      open(_PATH_DEVNULL, O_RDWR);	/* Leave it closed if it fails... */
    for (i = getdtablesize(); i > 3; i--)
      fcntl(i, F_SETFD, FD_CLOEXEC);
#ifndef NOSUID
    setuid(ID0realuid());
#endif
    execvp(argv[0], argv);
    fprintf(stderr, "execvp: %s: %s\n", argv[0], strerror(errno));
    _exit(127);
  } else {
    char *name = strdup(vector[0]);

    close(fids[1]);
    endout = out + olen - 1;
    startout = out;
    while (out < endout) {
      nb = read(fids[0], out, 1);
      if (nb <= 0)
	break;
      out++;
    }
    *out = '\0';
    close(fids[0]);
    close(fids[1]);
    waitpid(pid, &stat, WNOHANG);
    if (WIFSIGNALED(stat)) {
      log_Printf(LogWARN, "%s: signal %d\n", name, WTERMSIG(stat));
      free(name);
      *out = '\0';
      return;
    } else if (WIFEXITED(stat)) {
      switch (WEXITSTATUS(stat)) {
        case 0:
          free(name);
          break;
        case 127:
          log_Printf(LogWARN, "%s: %s\n", name, startout);
          free(name);
          *out = '\0';
          return;
          break;
        default:
          log_Printf(LogWARN, "%s: exit %d\n", name, WEXITSTATUS(stat));
          free(name);
          *out = '\0';
          return;
          break;
      }
    } else {
      log_Printf(LogWARN, "%s: Unexpected exit result\n", name);
      free(name);
      *out = '\0';
      return;
    }
  }
}
@


1.22
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d26 1
a26 1
 *	$OpenBSD: chat.c,v 1.21 2005/07/06 13:56:00 brad Exp $
@


1.21
log
@Add a bunch of malloc() return checks

From brian FreeBSD

ok deraadt@@ tdeval@@
@
text
@d26 1
a26 1
 *	$OpenBSD: chat.c,v 1.20 2002/06/15 08:02:00 brian Exp $
d742 1
a742 1
      fcntl(i, F_SETFD, 1);
@


1.20
log
@Tidy up end of line whitespace
@
text
@d26 1
a26 1
 *	$OpenBSD: chat.c,v 1.19 2002/05/16 01:13:39 brian Exp $
d246 4
a249 3
          c->abort.string[i].data = (char *)malloc(len+1);
          memcpy(c->abort.string[i].data, c->exp+2, len+1);
          c->abort.num++;
@


1.19
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: chat.c,v 1.18 2002/03/31 02:38:49 brian Exp $
d452 1
a452 1
            c->bufend - begin - c->arglen + 1) == NULL) { 
d470 1
a470 1
                c->bufend - begin - c->abort.string[n].len + 1) == NULL) { 
@


1.18
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d26 1
a26 1
 *	$OpenBSD: chat.c,v 1.17 2001/11/23 11:17:03 brian Exp $
a67 1
#include "ip.h"
@


1.17
log
@cmott@@scientech.com -> cm@@linktel.net
Add the UPTIME variable
CCP protocol ``0xffffffff'' -> ``none''
Don't leak memory when expanding command arguments and not exec()ing
Make some functions static
Add the ``log'' command for manual logging
Fix some log text bogons
@
text
@d26 1
a26 1
 *	$OpenBSD: chat.c,v 1.16 2001/08/19 23:22:17 brian Exp $
d519 1
a519 1
    result = wrote ? 1 : 0;
d521 4
a524 2
      if (errno != EINTR)
        log_Printf(LogERROR, "chat_Write: %s\n", strerror(errno));
@


1.16
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *	$OpenBSD: chat.c,v 1.15 2000/08/18 00:02:10 brian Exp $
a718 2
  command_Expand(argv, argc, (char const *const *)vector,
                 physical->dl->bundle, 0, getpid());
d727 2
@


1.15
log
@Make -DNOSUID (or -DPPP_NOSUID) possible to build ppp without SUID
capabilities.
@
text
@d26 1
a26 1
 *	$OpenBSD: chat.c,v 1.14 2000/08/09 19:31:25 brian Exp $
d33 1
d67 2
d77 2
@


1.14
log
@Allow leading ``!'' characters in authkeys and chat scripts to
be doubled up to mean a single literaly ``!''.
@
text
@d26 1
a26 1
 *	$OpenBSD: chat.c,v 1.13 2000/02/27 01:38:25 brian Exp $
d736 1
d738 1
@


1.13
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: chat.c,v 1.12 2000/02/27 00:21:06 brian Exp $
d216 2
a217 1
      needcr = c->state == CHAT_SEND && *c->argptr != '!';
d258 2
a259 2
        if (c->exp[2] == '!')
          ExecStr(c->physical, c->exp + 3, c->exp + 2, sizeof c->exp - 2);
d283 1
a283 1
    c->argptr = c->exp + 2;
@


1.12
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.11 2000/01/07 03:26:53 brian Exp $
@


1.11
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.10 1999/08/17 15:00:38 brian Exp $
d136 1
a136 1
chat_UpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
d319 1
a319 1
chat_IsSet(struct descriptor *d, const fd_set *fdset)
d368 1
a368 1
chat_Read(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
d482 1
a482 1
chat_Write(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
@


1.10
log
@Set the close-on-exec flag for all unused descriptors when
exec()ing other programs.
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.9 1999/06/26 02:57:01 brian Exp $
d75 1
d535 1
a535 2
chat_Init(struct chat *c, struct physical *p, const char *data, int emptybuf,
          const char *phone)
d543 10
d554 3
d565 1
a565 1
    c->argc =  MakeArgs(c->script, c->argv, VECSIZE(c->argv));
a571 3
  if (emptybuf)
    c->bufstart = c->bufend = c->buf;

d577 4
a580 2
  memset(&c->pause, '\0', sizeof c->pause);
  memset(&c->timeout, '\0', sizeof c->timeout);
d584 1
a584 1
chat_Destroy(struct chat *c)
d593 6
d706 7
a712 1
  argc = MakeArgs(command, vector, VECSIZE(vector));
d735 1
a735 1
    setuid(geteuid());
@


1.9
log
@Don't bother read()ing if we ``expect'' nothing in our chat script.
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.8 1999/06/26 02:56:52 brian Exp $
d685 1
a685 1
  int stat, nb, argc;
d701 2
a702 1
    fids[1] = fcntl(fids[1], F_DUPFD, 4);
d704 1
a705 1
    dup2(fids[1], STDERR_FILENO);
d707 4
a710 4
    if (open(_PATH_TTY, O_RDWR) == 3)
      fcntl(3, F_SETFD, 0);	/* Clear close-on-exec flag */
    else
      fcntl(3, F_SETFD, 1);	/* Set close-on-exec flag */
d714 1
a714 1
    exit(127);
@


1.8
log
@If we run out of chat script immediately after a successfully executed
expect-send-expect sequence, finish gracefully, don't core dump.
This bug has been there for over a year - I could never reproduce it !

Straw provided by: Andre Albsmeier <andre.albsmeier@@mchp.siemens.de>
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.7 1999/06/09 08:47:23 brian Exp $
d321 1
a321 1
  return physical_IsSet(&c->physical->desc, fdset);
@


1.7
log
@Use the correct pid when substituting PROCESSID.
Problem reported by: Amedeo Beck Peccoz <gea@@gressoney.it>
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.6 1999/05/27 09:51:12 brian Exp $
d184 5
a188 1
        c->argptr = c->argv[++c->arg];
@


1.6
log
@Add some comments, optimise out a few strlen()s and
remove a few extraneous assignments.
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.5 1999/05/08 11:06:34 brian Exp $
d686 1
a686 1
                 physical->dl->bundle, 0);
@


1.5
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.4 1999/02/12 00:53:08 brian Exp $
d216 4
d497 4
d590 1
a590 2
ExpandString(struct chat *c, const char *str, char *result, int reslen,
                  int sendmode)
d592 1
a592 1
  int addcr = 0;
a594 2
  if (sendmode)
    addcr = 1;
d601 1
a601 2
	if (sendmode)
	  addcr = 0;
d608 1
a608 1
	break;			/* Pause 0.25 sec */
d627 3
a629 2
	reslen -= strlen(result);
	result += strlen(result);
d634 3
a636 2
          reslen -= strlen(result);
          result += strlen(result);
d641 3
a643 2
	reslen -= strlen(result);
	result += strlen(result);
d667 1
a667 1
    if (addcr)
@


1.4
log
@When executing a command as part of a dial/login/hangup
script, expand words in the same way as !bg does.
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.3 1999/02/06 03:22:33 brian Exp $
d45 1
a76 1
#define	issep(c)	((c) == '\t' || (c) == ' ')
d304 1
a304 1
    return physical_UpdateSet(&c->physical->desc, r, NULL, e, n, 1);
d306 1
a306 1
    return physical_UpdateSet(&c->physical->desc, NULL, w, e, n, 1);
a568 55
static char *
findblank(char *p, int instring)
{
  if (instring) {
    while (*p) {
      if (*p == '\\') {
	strcpy(p, p + 1);
	if (!*p)
	  break;
      } else if (*p == '"')
	return (p);
      p++;
    }
  } else {
    while (*p) {
      if (issep(*p))
	return (p);
      p++;
    }
  }
  return p;
}

int
MakeArgs(char *script, char **pvect, int maxargs)
{
  int nargs, nb;
  int instring;

  nargs = 0;
  while (*script) {
    nb = strspn(script, " \t");
    script += nb;
    if (*script) {
      if (*script == '"') {
	instring = 1;
	script++;
	if (*script == '\0')
	  break;		/* Shouldn't return here. Need to null
				 * terminate below */
      } else
	instring = 0;
      if (nargs >= maxargs - 1)
	break;
      *pvect++ = script;
      nargs++;
      script = findblank(script, instring);
      if (*script)
	*script++ = '\0';
    }
  }
  *pvect = NULL;
  return nargs;
}

d691 1
a691 1
    dup2(physical_GetFD(physical), STDIN_FILENO);
@


1.3
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.53 1999/01/28 01:56:31 brian Exp $
d68 1
d728 2
a729 2
  char *vector[MAXARGS], *startout, *endout;
  int stat, nb;
d732 3
a734 1
  MakeArgs(command, vector, VECSIZE(vector));
d755 2
a756 2
    execvp(vector[0], vector);
    fprintf(stderr, "execvp failed: %s: %s\n", vector[0], strerror(errno));
@


1.2
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.1 1998/08/31 00:22:18 brian Exp $
d29 1
a29 1
#include <sys/types.h>
d69 3
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d26 1
a26 1
 *	$Id: chat.c,v 1.51 1998/08/07 18:42:47 brian Exp $
d432 1
@

