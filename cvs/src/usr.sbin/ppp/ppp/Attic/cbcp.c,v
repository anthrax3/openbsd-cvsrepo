head	1.20;
access;
symbols
	OPENBSD_5_5:1.19.0.46
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.42
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.40
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.38
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.36
	OPENBSD_5_0:1.19.0.34
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.32
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.30
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.26
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.28
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.24
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.22
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.20
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.18
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.16
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.14
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.12
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.10
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.8
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.14.0.6
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.19;

1.19
date	2003.04.28.21.31.36;	author tdeval;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.28.19.35.56;	author tdeval;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.07.23.58.53;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.19.11.06.31;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.27.01.38.24;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.27.00.21.06;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.07.03.26.53;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.07.27.13.50.20;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.06.02.15.58.40;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.05.08.11.06.33;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.03.29.08.20.32;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.02.26.21.28.19;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.02.06.03.22.31;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.01.19.22.17.13;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.10.31.17.40.10;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.10.29.02.21.44;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.16;	author brian;	state Exp;
branches;
next	;


desc
@@


1.20
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1998 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: cbcp.c,v 1.19 2003/04/28 21:31:36 tdeval Exp $
 */

#include <sys/param.h>

#ifdef __FreeBSD__
#include <netinet/in.h>
#endif
#include <sys/un.h>

#include <string.h>
#include <termios.h>

#include "layer.h"
#include "defs.h"
#include "log.h"
#include "timer.h"
#include "descriptor.h"
#include "lqr.h"
#include "mbuf.h"
#include "fsm.h"
#include "throughput.h"
#include "hdlc.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "async.h"
#include "physical.h"
#include "proto.h"
#include "cbcp.h"
#include "mp.h"
#include "chat.h"
#include "auth.h"
#include "chap.h"
#include "datalink.h"

void
cbcp_Init(struct cbcp *cbcp, struct physical *p)
{
  cbcp->required = 0;
  cbcp->fsm.state = CBCP_CLOSED;
  cbcp->fsm.id = 0;
  cbcp->fsm.delay = 0;
  *cbcp->fsm.phone = '\0';
  memset(&cbcp->fsm.timer, '\0', sizeof cbcp->fsm.timer);
  cbcp->p = p;
}

static void cbcp_SendReq(struct cbcp *);
static void cbcp_SendResponse(struct cbcp *);
static void cbcp_SendAck(struct cbcp *);

static void
cbcp_Timeout(void *v)
{
  struct cbcp *cbcp = (struct cbcp *)v;

  timer_Stop(&cbcp->fsm.timer);
  if (cbcp->fsm.restart) {
    switch (cbcp->fsm.state) {
      case CBCP_CLOSED:
      case CBCP_STOPPED:
        log_Printf(LogCBCP, "%s: Urk - unexpected CBCP timeout !\n",
                   cbcp->p->dl->name);
        break;

      case CBCP_REQSENT:
        cbcp_SendReq(cbcp);
        break;
      case CBCP_RESPSENT:
        cbcp_SendResponse(cbcp);
        break;
      case CBCP_ACKSENT:
        cbcp_SendAck(cbcp);
        break;
    }
  } else {
    const char *missed;

    switch (cbcp->fsm.state) {
      case CBCP_STOPPED:
        missed = "REQ";
        break;
      case CBCP_REQSENT:
        missed = "RESPONSE";
        break;
      case CBCP_RESPSENT:
        missed = "ACK";
        break;
      case CBCP_ACKSENT:
        missed = "Terminate REQ";
        break;
      default:
        log_Printf(LogCBCP, "%s: Urk - unexpected CBCP timeout !\n",
                   cbcp->p->dl->name);
        missed = NULL;
        break;
    }
    if (missed)
      log_Printf(LogCBCP, "%s: Timeout waiting for peer %s\n",
                 cbcp->p->dl->name, missed);
    datalink_CBCPFailed(cbcp->p->dl);
  }
}

static void
cbcp_StartTimer(struct cbcp *cbcp, int timeout)
{
  timer_Stop(&cbcp->fsm.timer);
  cbcp->fsm.timer.func = cbcp_Timeout;
  cbcp->fsm.timer.name = "cbcp";
  cbcp->fsm.timer.load = timeout * SECTICKS;
  cbcp->fsm.timer.arg = cbcp;
  timer_Start(&cbcp->fsm.timer);
}

#define CBCP_CLOSED	(0)	/* Not in use */
#define CBCP_STOPPED	(1)	/* Waiting for a REQ */
#define CBCP_REQSENT	(2)	/* Waiting for a RESP */
#define CBCP_RESPSENT	(3)	/* Waiting for an ACK */
#define CBCP_ACKSENT	(4)	/* Waiting for an LCP Term REQ */

static const char * const cbcpname[] = {
  "closed", "stopped", "req-sent", "resp-sent", "ack-sent"
};

static const char *
cbcpstate(int s)
{
  if (s < sizeof cbcpname / sizeof cbcpname[0])
    return cbcpname[s];
  return HexStr(s, NULL, 0);
}

static void
cbcp_NewPhase(struct cbcp *cbcp, int new)
{
  if (cbcp->fsm.state != new) {
    log_Printf(LogCBCP, "%s: State change %s --> %s\n", cbcp->p->dl->name,
               cbcpstate(cbcp->fsm.state), cbcpstate(new));
    cbcp->fsm.state = new;
  }
}

struct cbcp_header {
  u_char code;
  u_char id;
  u_int16_t length;	/* Network byte order */
};


/* cbcp_header::code values */
#define CBCP_REQ	(1)
#define CBCP_RESPONSE	(2)
#define CBCP_ACK	(3)

struct cbcp_data {
  u_char type;
  u_char length;
  u_char delay;
  char addr_start[253];	/* max cbcp_data length 255 + 1 for NULL */
};

/* cbcp_data::type values */
#define CBCP_NONUM	(1)
#define CBCP_CLIENTNUM	(2)
#define CBCP_SERVERNUM	(3)
#define CBCP_LISTNUM	(4)

static void
cbcp_Output(struct cbcp *cbcp, u_char code, struct cbcp_data *data)
{
  struct cbcp_header *head;
  struct mbuf *bp;

  bp = m_get(sizeof *head + data->length, MB_CBCPOUT);
  head = (struct cbcp_header *)MBUF_CTOP(bp);
  head->code = code;
  head->id = cbcp->fsm.id;
  head->length = htons(sizeof *head + data->length);
  memcpy(MBUF_CTOP(bp) + sizeof *head, data, data->length);
  log_DumpBp(LogDEBUG, "cbcp_Output", bp);
  link_PushPacket(&cbcp->p->link, bp, cbcp->p->dl->bundle,
                  LINK_QUEUES(&cbcp->p->link) - 1, PROTO_CBCP);
}

static const char *
cbcp_data_Type(int type)
{
  static const char * const types[] = {
    "No callback", "User-spec", "Server-spec", "list"
  };

  if (type < 1 || type > sizeof types / sizeof types[0])
    return HexStr(type, NULL, 0);
  return types[type-1];
}

struct cbcp_addr {
  u_char type;
  char addr[1];		/* Really ASCIIZ */
};

/* cbcp_data::type values */
#define CBCP_ADDR_PSTN	(1)

static void
cbcp_data_Show(struct cbcp_data *data)
{
  struct cbcp_addr *addr;
  char *end;

  addr = (struct cbcp_addr *)data->addr_start;
  end = (char *)data + data->length;
  *end = '\0';

  log_Printf(LogCBCP, " TYPE %s\n", cbcp_data_Type(data->type));
  if ((char *)&data->delay < end) {
    log_Printf(LogCBCP, " DELAY %d\n", data->delay);
    while (addr->addr < end) {
      if (addr->type == CBCP_ADDR_PSTN)
        log_Printf(LogCBCP, " ADDR %s\n", addr->addr);
      else
        log_Printf(LogCBCP, " ADDR type %d ??\n", (int)addr->type);
      addr = (struct cbcp_addr *)(addr->addr + strlen(addr->addr) + 1);
    }
  }
}

static void
cbcp_SendReq(struct cbcp *cbcp)
{
  struct cbcp_data data;
  struct cbcp_addr *addr;
  char list[sizeof cbcp->fsm.phone], *tok, *next;
  size_t len, max;

  /* Only callees send REQs */

  log_Printf(LogCBCP, "%s: SendReq(%d) state = %s\n", cbcp->p->dl->name,
             cbcp->fsm.id, cbcpstate(cbcp->fsm.state));
  data.type = cbcp->fsm.type;
  data.delay = 0;
  strncpy(list, cbcp->fsm.phone, sizeof list - 1);
  list[sizeof list - 1] = '\0';

  switch (data.type) {
    case CBCP_CLIENTNUM:
      addr = (struct cbcp_addr *)data.addr_start;
      addr->type = CBCP_ADDR_PSTN;
      *addr->addr = '\0';
      data.length = addr->addr - (char *)&data;
      break;

    case CBCP_LISTNUM:
      addr = (struct cbcp_addr *)data.addr_start;
      for (next = list;;) {
        if ((tok = strsep(&next, ",")) == NULL)
          break;
        max = data.addr_start + sizeof data.addr_start - addr->addr;
        if ((len = strlcpy(addr->addr, tok, max)) < max) {
          bzero(addr->addr + len, max - len);
          addr->type = CBCP_ADDR_PSTN;
          addr = (struct cbcp_addr *)((char *)addr + len + 2);
        } else
          log_Printf(LogWARN, "CBCP ADDR \"%s\" skipped - packet too large\n",
                     tok);
      }
      data.length = (char *)addr - (char *)&data;
      break;

    case CBCP_SERVERNUM:
      data.length = data.addr_start - (char *)&data;
      break;

    default:
      data.length = (char *)&data.delay - (char *)&data;
      break;
  }

  cbcp_data_Show(&data);
  cbcp_Output(cbcp, CBCP_REQ, &data);
  cbcp->fsm.restart--;
  cbcp_StartTimer(cbcp, cbcp->fsm.delay);
  cbcp_NewPhase(cbcp, CBCP_REQSENT);		/* Wait for a RESPONSE */
}

void
cbcp_Up(struct cbcp *cbcp)
{
  struct lcp *lcp = &cbcp->p->link.lcp;

  cbcp->fsm.delay = cbcp->p->dl->cfg.cbcp.delay;
  if (*cbcp->p->dl->peer.authname == '\0' ||
      !auth_SetPhoneList(cbcp->p->dl->peer.authname, cbcp->fsm.phone,
                         sizeof cbcp->fsm.phone)) {
    strncpy(cbcp->fsm.phone, cbcp->p->dl->cfg.cbcp.phone,
            sizeof cbcp->fsm.phone - 1);
    cbcp->fsm.phone[sizeof cbcp->fsm.phone - 1] = '\0';
  }

  if (lcp->want_callback.opmask) {
    if (*cbcp->fsm.phone == '\0')
      cbcp->fsm.type = CBCP_NONUM;
    else if (!strcmp(cbcp->fsm.phone, "*")) {
      cbcp->fsm.type = CBCP_SERVERNUM;
      *cbcp->fsm.phone = '\0';
    } else
      cbcp->fsm.type = CBCP_CLIENTNUM;
    cbcp_NewPhase(cbcp, CBCP_STOPPED);		/* Wait for a REQ */
    cbcp_StartTimer(cbcp, cbcp->fsm.delay * DEF_FSMTRIES);
  } else {
    if (*cbcp->fsm.phone == '\0')
      cbcp->fsm.type = CBCP_NONUM;
    else if (!strcmp(cbcp->fsm.phone, "*")) {
      cbcp->fsm.type = CBCP_CLIENTNUM;
      *cbcp->fsm.phone = '\0';
    } else if (strchr(cbcp->fsm.phone, ','))
      cbcp->fsm.type = CBCP_LISTNUM;
    else
      cbcp->fsm.type = CBCP_SERVERNUM;
    cbcp->fsm.restart = DEF_FSMTRIES;
    cbcp_SendReq(cbcp);
  }
}

static int
cbcp_AdjustResponse(struct cbcp *cbcp, struct cbcp_data *data)
{
  /*
   * We've received a REQ (data).  Adjust our reponse (cbcp->fsm.*)
   * so that we (hopefully) agree with the peer
   */
  struct cbcp_addr *addr;

  switch (data->type) {
    case CBCP_NONUM:
      if (cbcp->p->dl->cfg.callback.opmask & CALLBACK_BIT(CALLBACK_NONE))
        /*
         * if ``none'' is a configured callback possibility
         * (ie, ``set callback cbcp none''), go along with the callees
         * request
         */
        cbcp->fsm.type = CBCP_NONUM;

      /*
       * Otherwise, we send our desired response anyway.  This seems to be
       * what Win95 does - although I can't find this behaviour documented
       * in the CBCP spec....
       */

      return 1;

    case CBCP_CLIENTNUM:
      if (cbcp->fsm.type == CBCP_CLIENTNUM) {
        char *ptr;

        if (data->length > data->addr_start - (char *)data) {
          /*
           * The peer has given us an address type spec - make sure we
           * understand !
           */
          addr = (struct cbcp_addr *)data->addr_start;
          if (addr->type != CBCP_ADDR_PSTN) {
            log_Printf(LogPHASE, "CBCP: Unrecognised address type %d !\n",
                       (int)addr->type);
            return 0;
          }
        }
        /* we accept the REQ even if the peer didn't specify an addr->type */
        ptr = strchr(cbcp->fsm.phone, ',');
        if (ptr)
          *ptr = '\0';		/* Just use the first number in our list */
        return 1;
      }
      log_Printf(LogPHASE, "CBCP: no number to pass to the peer !\n");
      return 0;

    case CBCP_SERVERNUM:
      if (cbcp->fsm.type == CBCP_SERVERNUM) {
        *cbcp->fsm.phone = '\0';
        return 1;
      }
      if (data->length > data->addr_start - (char *)data) {
        /*
         * This violates the spec, but if the peer has told us the
         * number it wants to call back, take advantage of this fact
         * and allow things to proceed if we've specified the same
         * number
         */
        addr = (struct cbcp_addr *)data->addr_start;
        if (addr->type != CBCP_ADDR_PSTN) {
          log_Printf(LogPHASE, "CBCP: Unrecognised address type %d !\n",
                     (int)addr->type);
          return 0;
        } else if (cbcp->fsm.type == CBCP_CLIENTNUM) {
          /*
           * If the peer's insisting on deciding the number, make sure
           * it's one of the ones in our list.  If it is, let the peer
           * think it's in control :-)
           */
          char list[sizeof cbcp->fsm.phone], *next;

          strncpy(list, cbcp->fsm.phone, sizeof list - 1);
          list[sizeof list - 1] = '\0';
          for (next = strtok(list, ","); next; next = strtok(NULL, ","))
            if (!strcmp(next, addr->addr)) {
              cbcp->fsm.type = CBCP_SERVERNUM;
              strlcpy(cbcp->fsm.phone, next, sizeof cbcp->fsm.phone);
              return 1;
            }
        }
      }
      log_Printf(LogPHASE, "CBCP: Peer won't allow local decision !\n");
      return 0;

    case CBCP_LISTNUM:
      if (cbcp->fsm.type == CBCP_CLIENTNUM || cbcp->fsm.type == CBCP_LISTNUM) {
        /*
         * Search through ``data''s addresses and see if cbcp->fsm.phone
         * contains any of them
         */
        char list[sizeof cbcp->fsm.phone], *next, *end;

        addr = (struct cbcp_addr *)data->addr_start;
        end = (char *)data + data->length;

        while (addr->addr < end) {
          if (addr->type == CBCP_ADDR_PSTN) {
            strncpy(list, cbcp->fsm.phone, sizeof list - 1);
            list[sizeof list - 1] = '\0';
            for (next = strtok(list, ","); next; next = strtok(NULL, ","))
              if (!strcmp(next, addr->addr)) {
                cbcp->fsm.type = CBCP_LISTNUM;
                strlcpy(cbcp->fsm.phone, next, sizeof cbcp->fsm.phone);
                return 1;
              }
          } else
            log_Printf(LogCBCP, "Warning: Unrecognised address type %d !\n",
                       (int)addr->type);
          addr = (struct cbcp_addr *)(addr->addr + strlen(addr->addr) + 1);
        }
      }
      log_Printf(LogPHASE, "CBCP: no good number to pass to the peer !\n");
      return 0;
  }

  log_Printf(LogCBCP, "Unrecognised REQ type %d !\n", (int)data->type);
  return 0;
}

static void
cbcp_SendResponse(struct cbcp *cbcp)
{
  struct cbcp_data data;
  struct cbcp_addr *addr;
  size_t len, max;

  /* Only callers send RESPONSEs */

  log_Printf(LogCBCP, "%s: SendResponse(%d) state = %s\n", cbcp->p->dl->name,
             cbcp->fsm.id, cbcpstate(cbcp->fsm.state));

  data.type = cbcp->fsm.type;
  data.delay = cbcp->fsm.delay;
  addr = (struct cbcp_addr *)data.addr_start;
  if (data.type == CBCP_NONUM)
    data.length = (char *)&data.delay - (char *)&data;
  else if (*cbcp->fsm.phone) {
    addr->type = CBCP_ADDR_PSTN;
    max = data.addr_start + sizeof data.addr_start - addr->addr;
    if ((len = strlcpy(addr->addr, cbcp->fsm.phone, max)) >= max)
      len = max - 1;
    bzero(addr->addr + len, max - len);
    data.length = addr->addr + len + 1 - (char *)&data;
  } else
    data.length = data.addr_start - (char *)&data;

  cbcp_data_Show(&data);
  cbcp_Output(cbcp, CBCP_RESPONSE, &data);
  cbcp->fsm.restart--;
  cbcp_StartTimer(cbcp, cbcp->fsm.delay);
  cbcp_NewPhase(cbcp, CBCP_RESPSENT);	/* Wait for an ACK */
}

/* What to do after checking an incoming response */
#define CBCP_ACTION_DOWN (0)
#define CBCP_ACTION_REQ (1)
#define CBCP_ACTION_ACK (2)

static int
cbcp_CheckResponse(struct cbcp *cbcp, struct cbcp_data *data)
{
  /*
   * We've received a RESPONSE (data).  Check if it agrees with
   * our REQ (cbcp->fsm)
   */
  struct cbcp_addr *addr;

  addr = (struct cbcp_addr *)data->addr_start;

  if (data->type == cbcp->fsm.type) {
    switch (cbcp->fsm.type) {
      case CBCP_NONUM:
        return CBCP_ACTION_ACK;

      case CBCP_CLIENTNUM:
        if ((char *)data + data->length <= addr->addr)
          log_Printf(LogPHASE, "CBCP: peer didn't respond with a number !\n");
        else if (addr->type != CBCP_ADDR_PSTN)
          log_Printf(LogPHASE, "CBCP: Unrecognised address type %d !\n",
                     addr->type);
        else {
          strlcpy(cbcp->fsm.phone, addr->addr, sizeof cbcp->fsm.phone);
          cbcp->fsm.delay = data->delay;
          return CBCP_ACTION_ACK;
        }
        return CBCP_ACTION_DOWN;

      case CBCP_SERVERNUM:
        cbcp->fsm.delay = data->delay;
        return CBCP_ACTION_ACK;

      case CBCP_LISTNUM:
        if ((char *)data + data->length <= addr->addr)
          log_Printf(LogPHASE, "CBCP: peer didn't respond with a number !\n");
        else if (addr->type != CBCP_ADDR_PSTN)
          log_Printf(LogPHASE, "CBCP: Unrecognised address type %d !\n",
                     addr->type);
        else {
          char list[sizeof cbcp->fsm.phone], *next;

          strncpy(list, cbcp->fsm.phone, sizeof list - 1);
          list[sizeof list - 1] = '\0';
          for (next = strtok(list, ","); next; next = strtok(NULL, ","))
            if (!strcmp(addr->addr, next)) {
              strlcpy(cbcp->fsm.phone, next, sizeof cbcp->fsm.phone);
              cbcp->fsm.delay = data->delay;
              return CBCP_ACTION_ACK;
            }
          log_Printf(LogPHASE, "CBCP: peer didn't respond with a "
                     "valid number !\n");
        }
        return CBCP_ACTION_DOWN;
    }
    log_Printf(LogPHASE, "Internal CBCP error - agreed on %d !\n",
               (int)cbcp->fsm.type);
    return CBCP_ACTION_DOWN;
  } else if (data->type == CBCP_NONUM && cbcp->fsm.type == CBCP_CLIENTNUM) {
    /*
     * Client doesn't want CBCP after all....
     * We only allow this when ``set cbcp *'' has been specified.
     */
    cbcp->fsm.type = CBCP_NONUM;
    return CBCP_ACTION_ACK;
  }
  log_Printf(LogCBCP, "Invalid peer RESPONSE\n");
  return CBCP_ACTION_REQ;
}

static void
cbcp_SendAck(struct cbcp *cbcp)
{
  struct cbcp_data data;
  struct cbcp_addr *addr;
  size_t len, max;

  /* Only callees send ACKs */

  log_Printf(LogCBCP, "%s: SendAck(%d) state = %s\n", cbcp->p->dl->name,
             cbcp->fsm.id, cbcpstate(cbcp->fsm.state));

  data.type = cbcp->fsm.type;
  switch (data.type) {
    case CBCP_NONUM:
      data.length = (char *)&data.delay - (char *)&data;
      break;
    case CBCP_CLIENTNUM:
      addr = (struct cbcp_addr *)data.addr_start;
      addr->type = CBCP_ADDR_PSTN;
      max = data.addr_start + sizeof data.addr_start - addr->addr;
      if ((len = strlcpy(addr->addr, cbcp->fsm.phone, max)) >= max)
        len = max - 1;
      bzero(addr->addr + len, max - len);
      data.delay = cbcp->fsm.delay;
      data.length = addr->addr + len + 1 - (char *)&data;
      break;
    default:
      data.delay = cbcp->fsm.delay;
      data.length = data.addr_start - (char *)&data;
      break;
  }

  cbcp_data_Show(&data);
  cbcp_Output(cbcp, CBCP_ACK, &data);
  cbcp->fsm.restart--;
  cbcp_StartTimer(cbcp, cbcp->fsm.delay);
  cbcp_NewPhase(cbcp, CBCP_ACKSENT);	/* Wait for an ACK */
}

extern struct mbuf *
cbcp_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
{
  struct physical *p = link2physical(l);
  struct cbcp_header *head;
  struct cbcp_data *data;
  struct cbcp *cbcp = &p->dl->cbcp;
  int len;

  if (p == NULL) {
    log_Printf(LogERROR, "cbcp_Input: Not a physical link - dropped\n");
    m_freem(bp);
    return NULL;
  }

  bp = m_pullup(bp);
  len = m_length(bp);
  if (len < sizeof(struct cbcp_header)) {
    m_freem(bp);
    return NULL;
  }
  head = (struct cbcp_header *)MBUF_CTOP(bp);
  if (ntohs(head->length) != len) {
    log_Printf(LogWARN, "Corrupt CBCP packet (code %d, length %d not %d)"
               " - ignored\n", head->code, ntohs(head->length), len);
    m_freem(bp);
    return NULL;
  }
  m_settype(bp, MB_CBCPIN);

  /* XXX check the id */

  bp->m_offset += sizeof(struct cbcp_header);
  bp->m_len -= sizeof(struct cbcp_header);
  data = (struct cbcp_data *)MBUF_CTOP(bp);

  switch (head->code) {
    case CBCP_REQ:
      log_Printf(LogCBCP, "%s: RecvReq(%d) state = %s\n",
                 p->dl->name, head->id, cbcpstate(cbcp->fsm.state));
      cbcp_data_Show(data);
      if (cbcp->fsm.state == CBCP_STOPPED || cbcp->fsm.state == CBCP_RESPSENT) {
        timer_Stop(&cbcp->fsm.timer);
        if (cbcp_AdjustResponse(cbcp, data)) {
          cbcp->fsm.restart = DEF_FSMTRIES;
          cbcp->fsm.id = head->id;
          cbcp_SendResponse(cbcp);
        } else
          datalink_CBCPFailed(cbcp->p->dl);
      } else
        log_Printf(LogCBCP, "%s: unexpected REQ dropped\n", p->dl->name);
      break;

    case CBCP_RESPONSE:
      log_Printf(LogCBCP, "%s: RecvResponse(%d) state = %s\n",
	         p->dl->name, head->id, cbcpstate(cbcp->fsm.state));
      cbcp_data_Show(data);
      if (cbcp->fsm.id != head->id) {
        log_Printf(LogCBCP, "Warning: Expected id was %d, not %d\n",
                   cbcp->fsm.id, head->id);
        cbcp->fsm.id = head->id;
      }
      if (cbcp->fsm.state == CBCP_REQSENT || cbcp->fsm.state == CBCP_ACKSENT) {
        timer_Stop(&cbcp->fsm.timer);
        switch (cbcp_CheckResponse(cbcp, data)) {
          case CBCP_ACTION_REQ:
            cbcp_SendReq(cbcp);
            break;

          case CBCP_ACTION_ACK:
            cbcp->fsm.restart = DEF_FSMTRIES;
            cbcp_SendAck(cbcp);
            if (cbcp->fsm.type == CBCP_NONUM) {
              /*
               * Don't change state in case the peer doesn't get our ACK,
               * just bring the layer up.
               */
              timer_Stop(&cbcp->fsm.timer);
              datalink_NCPUp(cbcp->p->dl);
            }
            break;

          default:
            datalink_CBCPFailed(cbcp->p->dl);
            break;
        }
      } else
        log_Printf(LogCBCP, "%s: unexpected RESPONSE dropped\n", p->dl->name);
      break;

    case CBCP_ACK:
      log_Printf(LogCBCP, "%s: RecvAck(%d) state = %s\n",
	         p->dl->name, head->id, cbcpstate(cbcp->fsm.state));
      cbcp_data_Show(data);
      if (cbcp->fsm.id != head->id) {
        log_Printf(LogCBCP, "Warning: Expected id was %d, not %d\n",
                   cbcp->fsm.id, head->id);
        cbcp->fsm.id = head->id;
      }
      if (cbcp->fsm.type == CBCP_NONUM) {
        /*
         * Don't change state in case the peer doesn't get our ACK,
         * just bring the layer up.
         */
        timer_Stop(&cbcp->fsm.timer);
        datalink_NCPUp(cbcp->p->dl);
      } else if (cbcp->fsm.state == CBCP_RESPSENT) {
        timer_Stop(&cbcp->fsm.timer);
        datalink_CBCPComplete(cbcp->p->dl);
        log_Printf(LogPHASE, "%s: CBCP: Peer will dial back\n", p->dl->name);
      } else
        log_Printf(LogCBCP, "%s: unexpected ACK dropped\n", p->dl->name);
      break;

    default:
      log_Printf(LogWARN, "Unrecognised CBCP packet (code %d, length %d)\n",
               head->code, len);
      break;
  }

  m_freem(bp);
  return NULL;
}

void
cbcp_Down(struct cbcp *cbcp)
{
  timer_Stop(&cbcp->fsm.timer);
  cbcp_NewPhase(cbcp, CBCP_CLOSED);
  cbcp->required = 0;
}

void
cbcp_ReceiveTerminateReq(struct physical *p)
{
  if (p->dl->cbcp.fsm.state == CBCP_ACKSENT) {
    /* Don't change our state in case the peer doesn't get the ACK */
    p->dl->cbcp.required = 1;
    log_Printf(LogPHASE, "%s: CBCP: Will dial back on %s\n", p->dl->name,
               p->dl->cbcp.fsm.phone);
  } else
    cbcp_NewPhase(&p->dl->cbcp, CBCP_CLOSED);
}
@


1.19
log
@strncpy IS NOT strlcpy
blame from deraadt@@, krw@@
@
text
@d26 1
a26 1
 *	$OpenBSD: cbcp.c,v 1.18 2003/04/28 19:35:56 tdeval Exp $
@


1.18
log
@String cleanup, from beck@@
With some personal enhancements.

ok beck@@
@
text
@d26 1
a26 1
 *	$OpenBSD: cbcp.c,v 1.17 2003/04/07 23:58:53 deraadt Exp $
d285 3
a287 2
        max = data.addr_start + sizeof data.addr_start - addr->addr - 1;
        if ((len = strncpy(addr->addr, tok, max)) <= max) {
a288 1
	  addr->addr[max] = '\0';
d496 4
a499 4
    max = data.addr_start + sizeof data.addr_start - addr->addr - 1;
    if ((len = strncpy(addr->addr, cbcp->fsm.phone, max)) > max)
      len = max;
    addr->addr[max] = '\0';
d606 4
a609 3
      max = data.addr_start + sizeof data.addr_start - addr->addr - 1;
      if ((len = strncpy(addr->addr, cbcp->fsm.phone, max)) > max)
        len = max;
@


1.17
log
@more string cleaning; ok tedu
@
text
@d26 1
a26 1
 *	$OpenBSD: cbcp.c,v 1.16 2002/06/15 08:02:00 brian Exp $
d260 2
a261 2
  char list[sizeof cbcp->fsm.phone], *next;
  int len, max;
d282 3
a284 2
      for (next = strtok(list, ","); next; next = strtok(NULL, ",")) {
        len = strlen(next);
d286 1
a286 1
        if (len <= max) {
d288 1
a288 1
          strcpy(addr->addr, next);
d292 1
a292 1
                     next);
d482 1
d496 5
a500 2
    strcpy(addr->addr, cbcp->fsm.phone);
    data.length = (addr->addr + strlen(addr->addr) + 1) - (char *)&data;
d591 1
d606 3
a608 1
      strcpy(addr->addr, cbcp->fsm.phone);
d610 1
a610 1
      data.length = addr->addr + strlen(addr->addr) + 1 - (char *)&data;
@


1.16
log
@Tidy up end of line whitespace
@
text
@d26 1
a26 1
 *	$OpenBSD: cbcp.c,v 1.15 2002/05/16 01:13:39 brian Exp $
d433 1
a433 1
              strcpy(cbcp->fsm.phone, next);
d459 1
a459 1
                strcpy(cbcp->fsm.phone, next);
d534 1
a534 1
          strcpy(cbcp->fsm.phone, addr->addr);
d557 1
a557 1
              strcpy(cbcp->fsm.phone, next);
@


1.15
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: cbcp.c,v 1.14 2000/07/19 11:06:31 brian Exp $
d78 1
a78 1
static void 
@


1.14
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d26 1
a26 1
 *	$OpenBSD: cbcp.c,v 1.13 2000/02/27 01:38:24 brian Exp $
d31 3
d566 1
a566 1
    log_Printf(LogPHASE, "Internal CBCP error - agreed on %d ??!?\n",
@


1.13
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: cbcp.c,v 1.12 2000/02/27 00:21:06 brian Exp $
a43 1
#include "lcp.h"
d46 1
@


1.12
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.11 2000/01/07 03:26:53 brian Exp $
@


1.11
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.10 1999/07/27 13:50:20 brian Exp $
d154 1
a154 1
  return "???";
d217 1
a217 1
    return "???";
@


1.10
log
@If we've negotiated CBCP and have also specified ``none'' as a possible
callback option, and the server sends us CBCP_NONUM, proceed directly
to the network phase rather than insisting on our configured CBCP
option.

Mostly submitted by: kkphang <phang@@dgate.po.my>
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.9 1999/06/02 15:58:40 brian Exp $
d145 1
a145 1
static const char *cbcpname[] = {
d198 1
a198 1
  bp = mbuf_Alloc(sizeof *head + data->length, MB_CBCPOUT);
d206 1
a206 1
                  PRI_LINK, PROTO_CBCP);
d212 1
a212 1
  static const char *types[] = {
d625 1
a625 1
    mbuf_Free(bp);
d629 2
a630 2
  bp = mbuf_Contiguous(bp);
  len = mbuf_Length(bp);
d632 1
a632 1
    mbuf_Free(bp);
d639 1
a639 1
    mbuf_Free(bp);
d642 1
a642 1
  mbuf_SetType(bp, MB_CBCPIN);
d646 2
a647 2
  bp->offset += sizeof(struct cbcp_header);
  bp->cnt -= sizeof(struct cbcp_header);
d734 1
a734 1
  mbuf_Free(bp);
@


1.9
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.8 1999/05/08 11:06:33 brian Exp $
d359 8
d368 3
a370 3
       * If the callee offers no callback, we send our desired response
       * anyway.  This is what Win95 does - although I can't find this
       * behaviour documented in the spec....
d372 1
d713 8
a720 1
      if (cbcp->fsm.state == CBCP_RESPSENT) {
@


1.8
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.7 1999/03/29 08:20:32 brian Exp $
d198 1
a198 1
  bp = mbuf_Alloc(sizeof *head + data->length, MB_CBCP);
d633 1
@


1.7
log
@Ensure that the thing we're casting to struct ip
is aligned for non-i386 architectures.
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.6 1999/02/26 21:28:19 brian Exp $
d36 1
d51 1
a51 1
#include "lcpproto.h"
d205 2
a206 1
  hdlc_Output(&cbcp->p->link, PRI_LINK, PROTO_CBCP, bp);
d605 2
a606 2
void
cbcp_Input(struct physical *p, struct mbuf *bp)
d608 1
d614 6
d624 1
a624 1
    return;
d631 1
a631 1
    return;
d718 1
@


1.6
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.5 1999/02/06 03:22:31 brian Exp $
d611 1
@


1.5
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.9 1999/01/28 01:56:30 brian Exp $
d330 1
a330 1
    cbcp_StartTimer(cbcp, cbcp->fsm.delay * DEF_REQs);
d341 1
a341 1
    cbcp->fsm.restart = DEF_REQs;
d638 1
a638 1
          cbcp->fsm.restart = DEF_REQs;
d664 1
a664 1
            cbcp->fsm.restart = DEF_REQs;
@


1.4
log
@Send the peer-decided PSTN address with the CBCP Ack,
otherwise windows clients will keep resending the
response :-/
It'd be nice if M$ would document this sort of thing !
Problem reported by: Andrzej Tobola <san@@tmp.iem.pw.edu.pl>
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.3 1998/10/31 17:40:10 brian Exp $
d29 1
a29 1
#include <sys/types.h>
@


1.3
log
@If the CBCP callee offsers no callback, send our configured
response anyway.  This is what Win95 does, despite it not
being documented in the cbcp spec....
Reported by: Bill <petheram@@acm.org>
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.2 1998/10/29 02:21:44 brian Exp $
d571 1
a571 1
  char *end;
d579 16
a594 3
  data.delay = cbcp->fsm.delay;
  end = data.type == CBCP_NONUM ? (char *)&data.delay : data.addr_start;
  data.length = end - (char *)&data;
@


1.2
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.1 1998/08/31 00:22:16 brian Exp $
d357 6
a362 4
      if (cbcp->fsm.type == CBCP_NONUM)
          return 1;
      log_Printf(LogPHASE, "CBCP: server wants no callback !\n");
      return 0;
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d26 1
a26 1
 *	$Id: cbcp.c,v 1.2 1998/08/26 17:39:38 brian Exp $
d296 1
a296 1
      data.length = 2;
d474 3
a476 1
  if (*cbcp->fsm.phone) {
d553 7
d569 1
d578 2
a579 1
  data.length = data.addr_start - (char *)&data;
d624 1
d636 5
d673 5
@

