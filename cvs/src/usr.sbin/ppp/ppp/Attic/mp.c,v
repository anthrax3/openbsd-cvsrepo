head	1.35;
access;
symbols
	OPENBSD_5_5:1.34.0.38
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.34
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.32
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.30
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.28
	OPENBSD_5_0:1.34.0.26
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.24
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.22
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.18
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.34.0.20
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.16
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.14
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.34.0.12
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.10
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.8
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.6
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.34.0.4
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.32.0.8
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.6
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.32.0.4
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.35
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.34;

1.34
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.22.03.27.28;	author cloder;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.07.23.58.53;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.04.20.25.06;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.14.01.38.46;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.14.01.37.12;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.16.14.13.06;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.16.13.20.23;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.18.22.15.28;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.31.15.20.19;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.03.22.23.56;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.02.00.54.34;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.17.14.14.55;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.15.10.26.37;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.15.10.08.51;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.12.15.07.45;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.27.00.21.08;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.08.05.10.32.14;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.06.09.16.55.25;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.06.03.13.50.53;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.06.02.23.06.59;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.06.02.15.58.41;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.05.28.08.03.53;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.12.10.03.52;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.08.11.06.38;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.02.06.03.22.42;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.10.29.02.21.46;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.09.04.18.27.47;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.25;	author brian;	state Exp;
branches;
next	;


desc
@@


1.35
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1998 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: mp.c,v 1.34 2005/07/17 19:13:25 brad Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <net/if_dl.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <errno.h>
#include <paths.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#ifndef NONAT
#include "nat_cmd.h"
#endif
#include "vjcomp.h"
#include "ua.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "iplist.h"
#include "throughput.h"
#include "slcompress.h"
#include "lqr.h"
#include "hdlc.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "auth.h"
#include "lcp.h"
#include "async.h"
#include "ccp.h"
#include "link.h"
#include "descriptor.h"
#include "physical.h"
#include "chat.h"
#include "proto.h"
#include "filter.h"
#include "mp.h"
#include "chap.h"
#include "cbcp.h"
#include "datalink.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "prompt.h"
#include "id.h"
#include "arp.h"

void
peerid_Init(struct peerid *peer)
{
  peer->enddisc.class = 0;
  *peer->enddisc.address = '\0';
  peer->enddisc.len = 0;
  *peer->authname = '\0';
}

int
peerid_Equal(const struct peerid *p1, const struct peerid *p2)
{
  return !strcmp(p1->authname, p2->authname) &&
         p1->enddisc.class == p2->enddisc.class &&
         p1->enddisc.len == p2->enddisc.len &&
         !memcmp(p1->enddisc.address, p2->enddisc.address, p1->enddisc.len);
}

static u_int32_t
inc_seq(unsigned is12bit, u_int32_t seq)
{
  seq++;
  if (is12bit) {
    if (seq & 0xfffff000)
      seq = 0;
  } else if (seq & 0xff000000)
    seq = 0;
  return seq;
}

static int
isbefore(unsigned is12bit, u_int32_t seq1, u_int32_t seq2)
{
  u_int32_t max = (is12bit ? 0xfff : 0xffffff) - 0x200;

  if (seq1 > max) {
    if (seq2 < 0x200 || seq2 > seq1)
      return 1;
  } else if ((seq1 > 0x200 || seq2 <= max) && seq1 < seq2)
    return 1;

  return 0;
}

static int
mp_ReadHeader(struct mp *mp, struct mbuf *m, struct mp_header *header)
{
  if (mp->local_is12bit) {
    u_int16_t val;

    ua_ntohs(MBUF_CTOP(m), &val);
    if (val & 0x3000) {
      log_Printf(LogWARN, "Oops - MP header without required zero bits\n");
      return 0;
    }
    header->begin = val & 0x8000 ? 1 : 0;
    header->end = val & 0x4000 ? 1 : 0;
    header->seq = val & 0x0fff;
    return 2;
  } else {
    ua_ntohl(MBUF_CTOP(m), &header->seq);
    if (header->seq & 0x3f000000) {
      log_Printf(LogWARN, "Oops - MP header without required zero bits\n");
      return 0;
    }
    header->begin = header->seq & 0x80000000 ? 1 : 0;
    header->end = header->seq & 0x40000000 ? 1 : 0;
    header->seq &= 0x00ffffff;
    return 4;
  }
}

static void
mp_LayerStart(void *v, struct fsm *fp)
{
  /* The given FSM (ccp) is about to start up ! */
}

static void
mp_LayerUp(void *v, struct fsm *fp)
{
  /* The given fsm (ccp) is now up */

  bundle_CalculateBandwidth(fp->bundle);	/* Against ccp_MTUOverhead */
}

static void
mp_LayerDown(void *v, struct fsm *fp)
{
  /* The given FSM (ccp) has been told to come down */
}

static void
mp_LayerFinish(void *v, struct fsm *fp)
{
  /* The given fsm (ccp) is now down */
  if (fp->state == ST_CLOSED && fp->open_mode == OPEN_PASSIVE)
    fsm_Open(fp);		/* CCP goes to ST_STOPPED */
}

static void
mp_UpDown(void *v)
{
  struct mp *mp = (struct mp *)v;
  int percent;

  percent = MAX(mp->link.stats.total.in.OctetsPerSecond,
                mp->link.stats.total.out.OctetsPerSecond) * 800 /
            mp->bundle->bandwidth;
  if (percent >= mp->cfg.autoload.max) {
    log_Printf(LogDEBUG, "%d%% saturation - bring a link up ?\n", percent);
    bundle_AutoAdjust(mp->bundle, percent, AUTO_UP);
  } else if (percent <= mp->cfg.autoload.min) {
    log_Printf(LogDEBUG, "%d%% saturation - bring a link down ?\n", percent);
    bundle_AutoAdjust(mp->bundle, percent, AUTO_DOWN);
  }
}

void
mp_StopAutoloadTimer(struct mp *mp)
{
  throughput_stop(&mp->link.stats.total);
}

void
mp_CheckAutoloadTimer(struct mp *mp)
{
  if (mp->link.stats.total.SamplePeriod != mp->cfg.autoload.period) {
    throughput_destroy(&mp->link.stats.total);
    throughput_init(&mp->link.stats.total, mp->cfg.autoload.period);
    throughput_callback(&mp->link.stats.total, mp_UpDown, mp);
  }

  if (bundle_WantAutoloadTimer(mp->bundle))
    throughput_start(&mp->link.stats.total, "MP throughput", 1);
  else
    mp_StopAutoloadTimer(mp);
}

void
mp_RestartAutoloadTimer(struct mp *mp)
{
  if (mp->link.stats.total.SamplePeriod != mp->cfg.autoload.period)
    mp_CheckAutoloadTimer(mp);
  else
    throughput_clear(&mp->link.stats.total, THROUGHPUT_OVERALL, NULL);
}

void
mp_Init(struct mp *mp, struct bundle *bundle)
{
  mp->peer_is12bit = mp->local_is12bit = 0;
  mp->peer_mrru = mp->local_mrru = 0;

  peerid_Init(&mp->peer);

  mp->out.seq = 0;
  mp->out.link = 0;
  mp->out.af = AF_INET;
  mp->seq.min_in = 0;
  mp->seq.next_in = 0;
  mp->inbufs = NULL;
  mp->bundle = bundle;

  mp->link.type = LOGICAL_LINK;
  mp->link.name = "mp";
  mp->link.len = sizeof *mp;

  mp->cfg.autoload.period = SAMPLE_PERIOD;
  mp->cfg.autoload.min = mp->cfg.autoload.max = 0;
  throughput_init(&mp->link.stats.total, mp->cfg.autoload.period);
  throughput_callback(&mp->link.stats.total, mp_UpDown, mp);
  mp->link.stats.parent = NULL;
  mp->link.stats.gather = 0;	/* Let the physical links gather stats */
  memset(mp->link.Queue, '\0', sizeof mp->link.Queue);
  memset(mp->link.proto_in, '\0', sizeof mp->link.proto_in);
  memset(mp->link.proto_out, '\0', sizeof mp->link.proto_out);

  mp->fsmp.LayerStart = mp_LayerStart;
  mp->fsmp.LayerUp = mp_LayerUp;
  mp->fsmp.LayerDown = mp_LayerDown;
  mp->fsmp.LayerFinish = mp_LayerFinish;
  mp->fsmp.object = mp;

  mpserver_Init(&mp->server);

  mp->cfg.mrru = 0;
  mp->cfg.shortseq = NEG_ENABLED|NEG_ACCEPTED;
  mp->cfg.negenddisc = NEG_ENABLED|NEG_ACCEPTED;
  mp->cfg.enddisc.class = 0;
  *mp->cfg.enddisc.address = '\0';
  mp->cfg.enddisc.len = 0;

  lcp_Init(&mp->link.lcp, mp->bundle, &mp->link, NULL);
  ccp_Init(&mp->link.ccp, mp->bundle, &mp->link, &mp->fsmp);

  link_EmptyStack(&mp->link);
  link_Stack(&mp->link, &protolayer);
  link_Stack(&mp->link, &ccplayer);
  link_Stack(&mp->link, &vjlayer);
#ifndef NONAT
  link_Stack(&mp->link, &natlayer);
#endif
}

int
mp_Up(struct mp *mp, struct datalink *dl)
{
  struct lcp *lcp = &dl->physical->link.lcp;

  if (mp->active) {
    /* We're adding a link - do a last validation on our parameters */
    if (!peerid_Equal(&dl->peer, &mp->peer)) {
      log_Printf(LogPHASE, "%s: Inappropriate peer !\n", dl->name);
      log_Printf(LogPHASE, "  Attached to peer %s/%s\n", mp->peer.authname,
                 mp_Enddisc(mp->peer.enddisc.class, mp->peer.enddisc.address,
                            mp->peer.enddisc.len));
      log_Printf(LogPHASE, "  New link is peer %s/%s\n", dl->peer.authname,
                 mp_Enddisc(dl->peer.enddisc.class, dl->peer.enddisc.address,
                            dl->peer.enddisc.len));
      return MP_FAILED;
    }
    if (mp->local_mrru != lcp->want_mrru ||
        mp->peer_mrru != lcp->his_mrru ||
        mp->local_is12bit != lcp->want_shortseq ||
        mp->peer_is12bit != lcp->his_shortseq) {
      log_Printf(LogPHASE, "%s: Invalid MRRU/SHORTSEQ MP parameters !\n",
                dl->name);
      return MP_FAILED;
    }
    return MP_ADDED;
  } else {
    /* First link in multilink mode */

    mp->local_mrru = lcp->want_mrru;
    mp->peer_mrru = lcp->his_mrru;
    mp->local_is12bit = lcp->want_shortseq;
    mp->peer_is12bit = lcp->his_shortseq;
    mp->peer = dl->peer;

    throughput_destroy(&mp->link.stats.total);
    throughput_init(&mp->link.stats.total, mp->cfg.autoload.period);
    throughput_callback(&mp->link.stats.total, mp_UpDown, mp);
    memset(mp->link.Queue, '\0', sizeof mp->link.Queue);
    memset(mp->link.proto_in, '\0', sizeof mp->link.proto_in);
    memset(mp->link.proto_out, '\0', sizeof mp->link.proto_out);

    /* Tell the link who it belongs to */
    dl->physical->link.stats.parent = &mp->link.stats.total;

    mp->out.seq = 0;
    mp->out.link = 0;
    mp->out.af = AF_INET;
    mp->seq.min_in = 0;
    mp->seq.next_in = 0;

    /*
     * Now we create our server socket.
     * If it already exists, join it.  Otherwise, create and own it
     */
    switch (mpserver_Open(&mp->server, &mp->peer)) {
    case MPSERVER_CONNECTED:
      log_Printf(LogPHASE, "mp: Transfer link on %s\n",
                mp->server.socket.sun_path);
      mp->server.send.dl = dl;		/* Defer 'till it's safe to send */
      return MP_LINKSENT;
    case MPSERVER_FAILED:
      return MP_FAILED;
    case MPSERVER_LISTENING:
      log_Printf(LogPHASE, "mp: Listening on %s\n", mp->server.socket.sun_path);
      log_Printf(LogPHASE, "    First link: %s\n", dl->name);

      /* Re-point our NCP layers at our MP link */
      ncp_SetLink(&mp->bundle->ncp, &mp->link);

      /* Our lcp's already up 'cos of the NULL parent */
      if (ccp_SetOpenMode(&mp->link.ccp)) {
        fsm_Up(&mp->link.ccp.fsm);
        fsm_Open(&mp->link.ccp.fsm);
      }

      mp->active = 1;
      break;
    }
  }

  return MP_UP;
}

void
mp_Down(struct mp *mp)
{
  if (mp->active) {
    struct mbuf *next;

    /* Stop that ! */
    mp_StopAutoloadTimer(mp);

    /* Don't want any more of these */
    mpserver_Close(&mp->server);

    /* CCP goes down with a bang */
    fsm2initial(&mp->link.ccp.fsm);

    /* Received fragments go in the bit-bucket */
    while (mp->inbufs) {
      next = mp->inbufs->m_nextpkt;
      m_freem(mp->inbufs);
      mp->inbufs = next;
    }

    peerid_Init(&mp->peer);
    mp->active = 0;
  }
}

void
mp_linkInit(struct mp_link *mplink)
{
  mplink->seq = 0;
  mplink->bandwidth = 0;
}

static void
mp_Assemble(struct mp *mp, struct mbuf *m, struct physical *p)
{
  struct mp_header mh, h;
  struct mbuf *q, *last;
  int32_t seq;

  /*
   * When `m' and `p' are NULL, it means our oldest link has gone down.
   * We want to determine a new min, and process any intermediate stuff
   * as normal
   */

  if (m && mp_ReadHeader(mp, m, &mh) == 0) {
    m_freem(m);
    return;
  }

  if (p) {
    seq = p->dl->mp.seq;
    p->dl->mp.seq = mh.seq;
  } else
    seq = mp->seq.min_in;

  if (mp->seq.min_in == seq) {
    /*
     * We've received new data on the link that has our min (oldest) seq.
     * Figure out which link now has the smallest (oldest) seq.
     */
    struct datalink *dl;

    mp->seq.min_in = (u_int32_t)-1;
    for (dl = mp->bundle->links; dl; dl = dl->next)
      if (dl->state == DATALINK_OPEN &&
          (mp->seq.min_in == -1 ||
           isbefore(mp->local_is12bit, dl->mp.seq, mp->seq.min_in)))
        mp->seq.min_in = dl->mp.seq;
  }

  /*
   * Now process as many of our fragments as we can, adding our new
   * fragment in as we go, and ordering with the oldest at the top of
   * the queue.
   */

  last = NULL;
  seq = mp->seq.next_in;
  q = mp->inbufs;
  while (q || m) {
    if (!q) {
      if (last)
        last->m_nextpkt = m;
      else
        mp->inbufs = m;
      q = m;
      m = NULL;
      h = mh;
    } else {
      mp_ReadHeader(mp, q, &h);

      if (m && isbefore(mp->local_is12bit, mh.seq, h.seq)) {
        /* Our received fragment fits in before this one, so link it in */
        if (last)
          last->m_nextpkt = m;
        else
          mp->inbufs = m;
        m->m_nextpkt = q;
        q = m;
        h = mh;
        m = NULL;
      }
    }

    if (h.seq != seq) {
      /* we're missing something :-( */
      if (isbefore(mp->local_is12bit, seq, mp->seq.min_in)) {
        /* we're never gonna get it */
        struct mbuf *next;

        /* Zap all older fragments */
        while (mp->inbufs != q) {
          log_Printf(LogDEBUG, "Drop frag\n");
          next = mp->inbufs->m_nextpkt;
          m_freem(mp->inbufs);
          mp->inbufs = next;
        }

        /*
         * Zap everything until the next `end' fragment OR just before
         * the next `begin' fragment OR 'till seq.min_in - whichever
         * comes first.
         */
        do {
          mp_ReadHeader(mp, mp->inbufs, &h);
          if (h.begin) {
            /* We might be able to process this ! */
            h.seq--;  /* We're gonna look for fragment with h.seq+1 */
            break;
          }
          next = mp->inbufs->m_nextpkt;
          log_Printf(LogDEBUG, "Drop frag %u\n", h.seq);
          m_freem(mp->inbufs);
          mp->inbufs = next;
        } while (mp->inbufs && (isbefore(mp->local_is12bit, mp->seq.min_in,
                                         h.seq) || h.end));

        /*
         * Continue processing things from here.
         * This deals with the possibility that we received a fragment
         * on the slowest link that invalidates some of our data (because
         * of the hole at `q'), but where there are subsequent `whole'
         * packets that have already been received.
         */

        mp->seq.next_in = seq = inc_seq(mp->local_is12bit, h.seq);
        last = NULL;
        q = mp->inbufs;
      } else
        /* we may still receive the missing fragment */
        break;
    } else if (h.end) {
      /* We've got something, reassemble */
      struct mbuf **frag = &q;
      int len;
      u_long first = -1;

      do {
        *frag = mp->inbufs;
        mp->inbufs = mp->inbufs->m_nextpkt;
        len = mp_ReadHeader(mp, *frag, &h);
        if (first == -1)
          first = h.seq;
        if (frag == &q && !h.begin) {
          log_Printf(LogWARN, "Oops - MP frag %lu should have a begin flag\n",
                    (u_long)h.seq);
          m_freem(q);
          q = NULL;
        } else if (frag != &q && h.begin) {
          log_Printf(LogWARN, "Oops - MP frag %lu should have an end flag\n",
                    (u_long)h.seq - 1);
          /*
           * Stuff our fragment back at the front of the queue and zap
           * our half-assembled packet.
           */
          (*frag)->m_nextpkt = mp->inbufs;
          mp->inbufs = *frag;
          *frag = NULL;
          m_freem(q);
          q = NULL;
          frag = &q;
          h.end = 0;	/* just in case it's a whole packet */
        } else {
          (*frag)->m_offset += len;
          (*frag)->m_len -= len;
          (*frag)->m_nextpkt = NULL;
          do
            frag = &(*frag)->m_next;
          while (*frag != NULL);
        }
      } while (!h.end);

      if (q) {
        q = m_pullup(q);
        log_Printf(LogDEBUG, "MP: Reassembled frags %ld-%lu, length %d\n",
                   first, (u_long)h.seq, m_length(q));
        link_PullPacket(&mp->link, MBUF_CTOP(q), q->m_len, mp->bundle);
        m_freem(q);
      }

      mp->seq.next_in = seq = inc_seq(mp->local_is12bit, h.seq);
      last = NULL;
      q = mp->inbufs;
    } else {
      /* Look for the next fragment */
      seq = inc_seq(mp->local_is12bit, seq);
      last = q;
      q = q->m_nextpkt;
    }
  }

  if (m) {
    /* We still have to find a home for our new fragment */
    last = NULL;
    for (q = mp->inbufs; q; last = q, q = q->m_nextpkt) {
      mp_ReadHeader(mp, q, &h);
      if (isbefore(mp->local_is12bit, mh.seq, h.seq))
        break;
    }
    /* Our received fragment fits in here */
    if (last)
      last->m_nextpkt = m;
    else
      mp->inbufs = m;
    m->m_nextpkt = q;
  }
}

struct mbuf *
mp_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
{
  struct physical *p = link2physical(l);

  if (!bundle->ncp.mp.active)
    /* Let someone else deal with it ! */
    return bp;

  if (p == NULL) {
    log_Printf(LogWARN, "DecodePacket: Can't do MP inside MP !\n");
    m_freem(bp);
  } else {
    m_settype(bp, MB_MPIN);
    mp_Assemble(&bundle->ncp.mp, bp, p);
  }

  return NULL;
}

static void
mp_Output(struct mp *mp, struct bundle *bundle, struct link *l,
          struct mbuf *m, u_int32_t begin, u_int32_t end)
{
  char prepend[4];

  /* Stuff an MP header on the front of our packet and send it */

  if (mp->peer_is12bit) {
    u_int16_t val;

    val = (begin << 15) | (end << 14) | (u_int16_t)mp->out.seq;
    ua_htons(&val, prepend);
    m = m_prepend(m, prepend, 2, 0);
  } else {
    u_int32_t val;

    val = (begin << 31) | (end << 30) | (u_int32_t)mp->out.seq;
    ua_htonl(&val, prepend);
    m = m_prepend(m, prepend, 4, 0);
  }
  if (log_IsKept(LogDEBUG))
    log_Printf(LogDEBUG, "MP[frag %d]: Send %d bytes on link `%s'\n",
               mp->out.seq, m_length(m), l->name);
  mp->out.seq = inc_seq(mp->peer_is12bit, mp->out.seq);

  if (l->ccp.fsm.state != ST_OPENED && ccp_Required(&l->ccp)) {
    log_Printf(LogPHASE, "%s: Not transmitting... waiting for CCP\n", l->name);
    return;
  }

  link_PushPacket(l, m, bundle, LINK_QUEUES(l) - 1, PROTO_MP);
}

int
mp_FillPhysicalQueues(struct bundle *bundle)
{
  struct mp *mp = &bundle->ncp.mp;
  struct datalink *dl, *fdl;
  size_t total, add, len;
  int thislink, nlinks, nopenlinks, sendasip;
  u_int32_t begin, end;
  struct mbuf *m, *mo;
  struct link *bestlink;

  thislink = nlinks = nopenlinks = 0;
  for (fdl = NULL, dl = bundle->links; dl; dl = dl->next) {
    /* Include non-open links here as mp->out.link will stay more correct */
    if (!fdl) {
      if (thislink == mp->out.link)
        fdl = dl;
      else
        thislink++;
    }
    nlinks++;
    if (dl->state == DATALINK_OPEN)
      nopenlinks++;
  }

  if (!fdl) {
    fdl = bundle->links;
    if (!fdl)
      return 0;
    thislink = 0;
  }

  total = 0;
  for (dl = fdl; nlinks > 0; dl = dl->next, nlinks--, thislink++) {
    if (!dl) {
      dl = bundle->links;
      thislink = 0;
    }

    if (dl->state != DATALINK_OPEN)
      continue;

    if (dl->physical->out)
      /* this link has suffered a short write.  Let it continue */
      continue;

    add = link_QueueLen(&dl->physical->link);
    if (add) {
      /* this link has got stuff already queued.  Let it continue */
      total += add;
      continue;
    }

    if (!mp_QueueLen(mp)) {
      int mrutoosmall;

      /*
       * If there's only a single open link in our bundle and we haven't got
       * MP level link compression, queue outbound traffic directly via that
       * link's protocol stack rather than using the MP link.  This results
       * in the outbound traffic going out as PROTO_IP or PROTO_IPV6 rather
       * than PROTO_MP.
       */

      mrutoosmall = 0;
      sendasip = nopenlinks < 2;
      if (sendasip) {
        if (dl->physical->link.lcp.his_mru < mp->peer_mrru) {
          /*
           * Actually, forget it.  This test is done against the MRRU rather
           * than the packet size so that we don't end up sending some data
           * in MP fragments and some data in PROTO_IP packets.  That's just
           * too likely to upset some ppp implementations.
           */
          mrutoosmall = 1;
          sendasip = 0;
        }
      }

      bestlink = sendasip ? &dl->physical->link : &mp->link;
      if (!ncp_PushPacket(&bundle->ncp, &mp->out.af, bestlink))
        break;	/* Nothing else to send */

      if (mrutoosmall)
        log_Printf(LogDEBUG, "Don't send data as PROTO_IP, MRU < MRRU\n");
      else if (sendasip)
        log_Printf(LogDEBUG, "Sending data as PROTO_IP, not PROTO_MP\n");

      if (sendasip) {
        add = link_QueueLen(&dl->physical->link);
        if (add) {
          /* this link has got stuff already queued.  Let it continue */
          total += add;
          continue;
        }
      }
    }

    m = link_Dequeue(&mp->link);
    if (m) {
      len = m_length(m);
      begin = 1;
      end = 0;

      while (!end) {
        if (dl->state == DATALINK_OPEN) {
          /* Write at most his_mru bytes to the physical link */
          if (len <= dl->physical->link.lcp.his_mru) {
            mo = m;
            end = 1;
            m_settype(mo, MB_MPOUT);
          } else {
            /* It's > his_mru, chop the packet (`m') into bits */
            mo = m_get(dl->physical->link.lcp.his_mru, MB_MPOUT);
            len -= mo->m_len;
            m = mbuf_Read(m, MBUF_CTOP(mo), mo->m_len);
          }
          mp_Output(mp, bundle, &dl->physical->link, mo, begin, end);
          begin = 0;
        }

        if (!end) {
          nlinks--;
          dl = dl->next;
          if (!dl) {
            dl = bundle->links;
            thislink = 0;
          } else
            thislink++;
        }
      }
    }
  }
  mp->out.link = thislink;		/* Start here next time */

  return total;
}

int
mp_SetDatalinkBandwidth(struct cmdargs const *arg)
{
  int val;

  if (arg->argc != arg->argn+1)
    return -1;

  val = atoi(arg->argv[arg->argn]);
  if (val <= 0) {
    log_Printf(LogWARN, "The link bandwidth must be greater than zero\n");
    return 1;
  }
  arg->cx->mp.bandwidth = val;

  if (arg->cx->state == DATALINK_OPEN)
    bundle_CalculateBandwidth(arg->bundle);

  return 0;
}

int
mp_ShowStatus(struct cmdargs const *arg)
{
  struct mp *mp = &arg->bundle->ncp.mp;

  prompt_Printf(arg->prompt, "Multilink is %sactive\n", mp->active ? "" : "in");
  if (mp->active) {
    struct mbuf *m, *lm;
    int bufs = 0;

    lm = NULL;
    prompt_Printf(arg->prompt, "Socket:         %s\n",
                  mp->server.socket.sun_path);
    for (m = mp->inbufs; m; m = m->m_nextpkt) {
      bufs++;
      lm = m;
    }
    prompt_Printf(arg->prompt, "Pending frags:  %d", bufs);
    if (bufs) {
      struct mp_header mh;
      unsigned long first, last;

      first = mp_ReadHeader(mp, mp->inbufs, &mh) ? mh.seq : 0;
      last = mp_ReadHeader(mp, lm, &mh) ? mh.seq : 0;
      prompt_Printf(arg->prompt, " (Have %lu - %lu, want %lu, lowest %lu)\n",
                    first, last, (unsigned long)mp->seq.next_in,
                    (unsigned long)mp->seq.min_in);
      prompt_Printf(arg->prompt, "                First has %sbegin bit and "
                    "%send bit", mh.begin ? "" : "no ", mh.end ? "" : "no ");
    }
    prompt_Printf(arg->prompt, "\n");
  }

  prompt_Printf(arg->prompt, "\nMy Side:\n");
  if (mp->active) {
    prompt_Printf(arg->prompt, " Output SEQ:    %u\n", mp->out.seq);
    prompt_Printf(arg->prompt, " MRRU:          %u\n", mp->local_mrru);
    prompt_Printf(arg->prompt, " Short Seq:     %s\n",
                  mp->local_is12bit ? "on" : "off");
  }
  prompt_Printf(arg->prompt, " Discriminator: %s\n",
                mp_Enddisc(mp->cfg.enddisc.class, mp->cfg.enddisc.address,
                           mp->cfg.enddisc.len));

  prompt_Printf(arg->prompt, "\nHis Side:\n");
  if (mp->active) {
    prompt_Printf(arg->prompt, " Auth Name:     %s\n", mp->peer.authname);
    prompt_Printf(arg->prompt, " Input SEQ:     %u\n", mp->seq.next_in);
    prompt_Printf(arg->prompt, " MRRU:          %u\n", mp->peer_mrru);
    prompt_Printf(arg->prompt, " Short Seq:     %s\n",
                  mp->peer_is12bit ? "on" : "off");
  }
  prompt_Printf(arg->prompt,   " Discriminator: %s\n",
                mp_Enddisc(mp->peer.enddisc.class, mp->peer.enddisc.address,
                           mp->peer.enddisc.len));

  prompt_Printf(arg->prompt, "\nDefaults:\n");

  prompt_Printf(arg->prompt, " MRRU:          ");
  if (mp->cfg.mrru)
    prompt_Printf(arg->prompt, "%d (multilink enabled)\n", mp->cfg.mrru);
  else
    prompt_Printf(arg->prompt, "disabled\n");
  prompt_Printf(arg->prompt, " Short Seq:     %s\n",
                  command_ShowNegval(mp->cfg.shortseq));
  prompt_Printf(arg->prompt, " Discriminator: %s\n",
                  command_ShowNegval(mp->cfg.negenddisc));
  prompt_Printf(arg->prompt, " AutoLoad:      min %d%%, max %d%%,"
                " period %d secs\n", mp->cfg.autoload.min,
                mp->cfg.autoload.max, mp->cfg.autoload.period);

  return 0;
}

const char *
mp_Enddisc(u_char c, const char *address, int len)
{
  static char result[100];	/* Used immediately after it's returned */
  int f, header;

  switch (c) {
    case ENDDISC_NULL:
      snprintf(result, sizeof result, "Null Class");
      break;

    case ENDDISC_LOCAL:
      snprintf(result, sizeof result, "Local Addr: %.*s", len, address);
      break;

    case ENDDISC_IP:
      if (len == 4)
        snprintf(result, sizeof result, "IP %s",
                 inet_ntoa(*(const struct in_addr *)address));
      else
        snprintf(result, sizeof result, "IP[%d] ???", len);
      break;

    case ENDDISC_MAC:
      if (len == 6) {
        const u_char *m = (const u_char *)address;
        snprintf(result, sizeof result, "MAC %02x:%02x:%02x:%02x:%02x:%02x",
                 m[0], m[1], m[2], m[3], m[4], m[5]);
      } else
        snprintf(result, sizeof result, "MAC[%d] ???", len);
      break;

    case ENDDISC_MAGIC:
      snprintf(result, sizeof result, "Magic: 0x");
      header = strlen(result);
      if (len > sizeof result - header - 1)
        len = sizeof result - header - 1;
      for (f = 0; f < len; f++)
        snprintf(result + header + 2 * f, sizeof result - (header + 2 * f),
	  "%02x", address[f]);
      break;

    case ENDDISC_PSN:
      snprintf(result, sizeof result, "PSN: %.*s", len, address);
      break;

     default:
      snprintf(result, sizeof result, "%d: ", (int)c);
      header = strlen(result);
      if (len > sizeof result - header - 1)
        len = sizeof result - header - 1;
      for (f = 0; f < len; f++)
        snprintf(result + header + 2 * f, sizeof result - (header + 2 * f),
	  "%02x", address[f]);
      break;
  }
  return result;
}

int
mp_SetEnddisc(struct cmdargs const *arg)
{
  struct mp *mp = &arg->bundle->ncp.mp;
  struct in_addr addr;

  switch (bundle_Phase(arg->bundle)) {
    case PHASE_DEAD:
      break;
    case PHASE_ESTABLISH:
      /* Make sure none of our links are DATALINK_LCP or greater */
      if (bundle_HighestState(arg->bundle) >= DATALINK_LCP) {
        log_Printf(LogWARN, "enddisc: Only changable before"
                   " LCP negotiations\n");
        return 1;
      }
      break;
    default:
      log_Printf(LogWARN, "enddisc: Only changable at phase DEAD/ESTABLISH\n");
      return 1;
  }

  if (arg->argc == arg->argn) {
    mp->cfg.enddisc.class = 0;
    *mp->cfg.enddisc.address = '\0';
    mp->cfg.enddisc.len = 0;
  } else if (arg->argc > arg->argn) {
    if (!strcasecmp(arg->argv[arg->argn], "label")) {
      mp->cfg.enddisc.class = ENDDISC_LOCAL;
      strlcpy(mp->cfg.enddisc.address, arg->bundle->cfg.label,
	sizeof mp->cfg.enddisc.address);
      mp->cfg.enddisc.len = strlen(mp->cfg.enddisc.address);
    } else if (!strcasecmp(arg->argv[arg->argn], "ip")) {
      if (arg->bundle->ncp.ipcp.my_ip.s_addr == INADDR_ANY)
        ncprange_getip4addr(&arg->bundle->ncp.ipcp.cfg.my_range, &addr);
      else
        addr = arg->bundle->ncp.ipcp.my_ip;
      memcpy(mp->cfg.enddisc.address, &addr.s_addr, sizeof addr.s_addr);
      mp->cfg.enddisc.class = ENDDISC_IP;
      mp->cfg.enddisc.len = sizeof arg->bundle->ncp.ipcp.my_ip.s_addr;
    } else if (!strcasecmp(arg->argv[arg->argn], "mac")) {
      struct sockaddr_dl hwaddr;
      int s;

      if (arg->bundle->ncp.ipcp.my_ip.s_addr == INADDR_ANY)
        ncprange_getip4addr(&arg->bundle->ncp.ipcp.cfg.my_range, &addr);
      else
        addr = arg->bundle->ncp.ipcp.my_ip;

      s = ID0socket(PF_INET, SOCK_DGRAM, 0);
      if (s < 0) {
        log_Printf(LogERROR, "set enddisc: socket(): %s\n", strerror(errno));
        return 2;
      }
      if (arp_EtherAddr(s, addr, &hwaddr, 1)) {
        mp->cfg.enddisc.class = ENDDISC_MAC;
        memcpy(mp->cfg.enddisc.address, hwaddr.sdl_data + hwaddr.sdl_nlen,
               hwaddr.sdl_alen);
        mp->cfg.enddisc.len = hwaddr.sdl_alen;
      } else {
        log_Printf(LogWARN, "set enddisc: Can't locate MAC address for %s\n",
                  inet_ntoa(addr));
        close(s);
        return 4;
      }
      close(s);
    } else if (!strcasecmp(arg->argv[arg->argn], "magic")) {
      int f;

      randinit();
      for (f = 0; f < 20; f += sizeof(long))
        *(long *)(mp->cfg.enddisc.address + f) = random();
      mp->cfg.enddisc.class = ENDDISC_MAGIC;
      mp->cfg.enddisc.len = 20;
    } else if (!strcasecmp(arg->argv[arg->argn], "psn")) {
      if (arg->argc > arg->argn+1) {
        mp->cfg.enddisc.class = ENDDISC_PSN;
        strlcpy(mp->cfg.enddisc.address, arg->argv[arg->argn+1],
	  sizeof mp->cfg.enddisc.address);
        mp->cfg.enddisc.len = strlen(mp->cfg.enddisc.address);
      } else {
        log_Printf(LogWARN, "PSN endpoint requires additional data\n");
        return 5;
      }
    } else {
      log_Printf(LogWARN, "%s: Unrecognised endpoint type\n",
                arg->argv[arg->argn]);
      return 6;
    }
  }

  return 0;
}

static int
mpserver_UpdateSet(struct fdescriptor *d, fd_set *r, fd_set *w, fd_set *e,
                   int *n)
{
  struct mpserver *s = descriptor2mpserver(d);
  int result;

  result = 0;
  if (s->send.dl != NULL) {
    /* We've connect()ed */
    if (!link_QueueLen(&s->send.dl->physical->link) &&
        !s->send.dl->physical->out) {
      /* Only send if we've transmitted all our data (i.e. the ConfigAck) */
      result -= datalink_RemoveFromSet(s->send.dl, r, w, e);
      bundle_SendDatalink(s->send.dl, s->fd, &s->socket);
      s->send.dl = NULL;
      s->fd = -1;
    } else
      /* Never read from a datalink that's on death row ! */
      result -= datalink_RemoveFromSet(s->send.dl, r, NULL, NULL);
  } else if (r && s->fd >= 0) {
    if (*n < s->fd + 1)
      *n = s->fd + 1;
    FD_SET(s->fd, r);
    log_Printf(LogTIMER, "mp: fdset(r) %d\n", s->fd);
    result++;
  }
  return result;
}

static int
mpserver_IsSet(struct fdescriptor *d, const fd_set *fdset)
{
  struct mpserver *s = descriptor2mpserver(d);
  return s->fd >= 0 && FD_ISSET(s->fd, fdset);
}

static void
mpserver_Read(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  struct mpserver *s = descriptor2mpserver(d);

  bundle_ReceiveDatalink(bundle, s->fd);
}

static int
mpserver_Write(struct fdescriptor *d, struct bundle *bundle,
               const fd_set *fdset)
{
  /* We never want to write here ! */
  log_Printf(LogALERT, "mpserver_Write: Internal error: Bad call !\n");
  return 0;
}

void
mpserver_Init(struct mpserver *s)
{
  s->desc.type = MPSERVER_DESCRIPTOR;
  s->desc.UpdateSet = mpserver_UpdateSet;
  s->desc.IsSet = mpserver_IsSet;
  s->desc.Read = mpserver_Read;
  s->desc.Write = mpserver_Write;
  s->send.dl = NULL;
  s->fd = -1;
  memset(&s->socket, '\0', sizeof s->socket);
}

int
mpserver_Open(struct mpserver *s, struct peerid *peer)
{
  int f, l, n;
  mode_t mask;

  if (s->fd != -1) {
    log_Printf(LogALERT, "Internal error !  mpserver already open\n");
    mpserver_Close(s);
  }

  l = snprintf(s->socket.sun_path, sizeof s->socket.sun_path, "%sppp-%s-%02x-",
               _PATH_VARRUN, peer->authname, peer->enddisc.class);
  if (l < 0) {
    log_Printf(LogERROR, "mpserver: snprintf(): %s\n", strerror(errno));
    return MPSERVER_FAILED;
  }

  if (l >= sizeof s->socket.sun_path) {
    log_Printf(LogERROR, "mpserver: snprintf() not enough room in buffer");
    return MPSERVER_FAILED;
  }

  for (f = 0; f < peer->enddisc.len && l < sizeof s->socket.sun_path - 2; f++) {
    n = snprintf(s->socket.sun_path + l, sizeof s->socket.sun_path - l,
             "%02x", *(u_char *)(peer->enddisc.address+f));
    if (n < 0 || n >= (sizeof s->socket.sun_path - l)) {
      log_Printf(LogERROR, "mpserver: snprintf() not enough room in buffer");
      return MPSERVER_FAILED;
    }
    l += n;
  }

  s->socket.sun_family = AF_LOCAL;
  s->socket.sun_len = sizeof s->socket;
  s->fd = ID0socket(PF_LOCAL, SOCK_DGRAM, 0);
  if (s->fd < 0) {
    log_Printf(LogERROR, "mpserver: socket(): %s\n", strerror(errno));
    return MPSERVER_FAILED;
  }

  setsockopt(s->fd, SOL_SOCKET, SO_REUSEADDR, (struct sockaddr *)&s->socket,
             sizeof s->socket);
  mask = umask(0177);

  /*
   * Try to bind the socket.  If we succeed we play server, if we fail
   * we connect() and hand the link off.
   */

  if (ID0bind_un(s->fd, &s->socket) < 0) {
    if (errno != EADDRINUSE) {
      log_Printf(LogPHASE, "mpserver: can't create bundle socket %s (%s)\n",
                s->socket.sun_path, strerror(errno));
      umask(mask);
      close(s->fd);
      s->fd = -1;
      return MPSERVER_FAILED;
    }

    /* So we're the sender */
    umask(mask);
    if (ID0connect_un(s->fd, &s->socket) < 0) {
      log_Printf(LogPHASE, "mpserver: can't connect to bundle socket %s (%s)\n",
                s->socket.sun_path, strerror(errno));
      if (errno == ECONNREFUSED)
        log_Printf(LogPHASE, "          The previous server died badly !\n");
      close(s->fd);
      s->fd = -1;
      return MPSERVER_FAILED;
    }

    /* Donate our link to the other guy */
    return MPSERVER_CONNECTED;
  }

  return MPSERVER_LISTENING;
}

void
mpserver_Close(struct mpserver *s)
{
  if (s->send.dl != NULL) {
    bundle_SendDatalink(s->send.dl, s->fd, &s->socket);
    s->send.dl = NULL;
    s->fd = -1;
  } else if (s->fd >= 0) {
    close(s->fd);
    if (ID0unlink(s->socket.sun_path) == -1)
      log_Printf(LogERROR, "%s: Failed to remove: %s\n", s->socket.sun_path,
                strerror(errno));
    memset(&s->socket, '\0', sizeof s->socket);
    s->fd = -1;
  }
}

void
mp_LinkLost(struct mp *mp, struct datalink *dl)
{
  if (mp->seq.min_in == dl->mp.seq)
    /* We've lost the link that's holding everything up ! */
    mp_Assemble(mp, NULL, NULL);
}

size_t
mp_QueueLen(struct mp *mp)
{
  return link_QueueLen(&mp->link);
}
@


1.34
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.33 2005/04/22 03:27:28 cloder Exp $
@


1.33
log
@snprintf cleanup. OK deraadt@@, moritz@@
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.32 2003/04/07 23:58:53 deraadt Exp $
d40 2
a42 1
#include <stdio.h>
@


1.32
log
@more string cleaning; ok tedu
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.31 2003/04/04 20:25:06 deraadt Exp $
d1120 1
a1120 1
  int f, l;
d1135 5
d1141 1
a1141 1
    snprintf(s->socket.sun_path + l, sizeof s->socket.sun_path - l,
d1143 5
a1147 1
    l += 2;
@


1.31
log
@strlcpy and snprintf; various people ok
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.30 2002/05/16 01:13:39 brian Exp $
d935 2
a936 1
        sprintf(result + header + 2 * f, "%02x", address[f]);
d949 2
a950 1
        sprintf(result + header + 2 * f, "%02x", address[f]);
d985 2
a986 1
      strcpy(mp->cfg.enddisc.address, arg->bundle->cfg.label);
d1033 2
a1034 1
        strcpy(mp->cfg.enddisc.address, arg->argv[arg->argn+1]);
@


1.30
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.29 2002/05/14 01:38:46 brian Exp $
d905 1
a905 1
      sprintf(result, "Null Class");
d917 1
a917 1
        sprintf(result, "IP[%d] ???", len);
d926 1
a926 1
        sprintf(result, "MAC[%d] ???", len);
d930 1
a930 1
      sprintf(result, "Magic: 0x");
d943 1
a943 1
      sprintf(result, "%d: ", (int)c);
@


1.29
log
@Don't corrupt MP fragments when they're put back on the front of our
inbound queue; Amit K. Rao <arao@@niksun.com>
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.28 2002/05/14 01:37:12 brian Exp $
a64 1
#include "ip.h"
@


1.28
log
@Calculate the number of open links properly when deciding on whether to
just send PROTO_IP packets when we've got only one link up in multi-link
mode.
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.27 2002/01/16 14:13:06 brian Exp $
a545 3
        (*frag)->m_offset += len;
        (*frag)->m_len -= len;
        (*frag)->m_nextpkt = NULL;
d556 1
a556 1
           * our half-assembed packet.
d565 4
a568 1
        } else
d572 1
@


1.27
log
@socket()s first argument should be a protocol family rather than an
address family.
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.26 2002/01/16 13:20:23 brian Exp $
d670 1
a670 1
  int thislink, nlinks;
d675 1
a675 1
  thislink = nlinks = 0;
d685 2
a717 1
      struct datalink *other;
a726 3
      for (other = dl->next; other; other = other->next)
        if (other->state == DATALINK_OPEN)
          break;
d729 2
a730 1
      if (!other) {
d739 1
a739 1
          other = dl;
d743 1
a743 1
      bestlink = other ? &mp->link : &dl->physical->link;
d749 1
a749 1
      else if (!other)
d752 1
a752 1
      if (!other) {
@


1.26
log
@socket's first argument is an address family, not a protocol family.
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.25 2001/08/19 23:22:18 brian Exp $
d1003 1
a1003 1
      s = ID0socket(AF_INET, SOCK_DGRAM, 0);
d1140 1
a1140 1
  s->fd = ID0socket(AF_LOCAL, SOCK_DGRAM, 0);
@


1.25
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.24 2001/08/18 22:15:28 brian Exp $
d1140 1
a1140 1
  s->fd = ID0socket(PF_LOCAL, SOCK_DGRAM, 0);
@


1.24
log
@Deal with snprintf returns properly
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.23 2001/07/31 15:20:19 brian Exp $
d64 2
d84 2
a86 1
#include "ip.h"
d249 1
d343 1
d363 2
a364 2
      /* Re-point our IPCP layer at our MP link */
      ipcp_SetLink(&mp->bundle->ncp.ipcp, &mp->link);
d665 1
a665 1
mp_FillQueues(struct bundle *bundle)
d673 1
d715 1
a715 1
    if (!link_QueueLen(&mp->link)) {
d723 2
a724 1
       * in the outbound traffic going out as PROTO_IP rather than PROTO_MP.
d744 3
a746 3
      if (!ip_PushPacket(other ? &mp->link : &dl->physical->link, bundle))
        /* Nothing else to send */
        break;
d988 1
a988 1
        addr = arg->bundle->ncp.ipcp.cfg.my_range.ipaddr;
d999 1
a999 1
        addr = arg->bundle->ncp.ipcp.cfg.my_range.ipaddr;
d1209 2
a1210 2
void
mp_DeleteQueue(struct mp *mp)
d1212 1
a1212 1
  link_DeleteQueue(&mp->link);
@


1.23
log
@Remove an irritating diagnostic emitted to LogPHASE when a
static proxy arp entry is deleted.

Rename a function (for consistency) and remove some whitespace
(for readability).
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.22 2001/07/03 22:23:56 brian Exp $
d1120 4
@


1.22
log
@Reduce the interface MTU by 2 when MPPE has been successfully negotiated.

This is necessary because MPPE will combine the protocol id with the
payload received on the tun interface, encrypt it, then prepend its
own protocol id, effectively increasing the payload by two bytes.
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.21 2000/11/02 00:54:34 brian Exp $
d1001 1
a1001 1
      if (get_ether_addr(s, addr, &hwaddr)) {
@


1.21
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.20 2000/08/17 14:14:55 brian Exp $
d170 2
d650 5
@


1.20
log
@If we're in MP mode with a single open link, MP link level compression
isn't open and the links MRU >= our MRRU, send outbound traffic as
PROTO_IP rather than PROTO_MP.  This shaves some bytes off the front
of each packet 'till the second link is brought up.

Idea obtained from: Cisco
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.19 2000/08/15 10:26:37 brian Exp $
d1079 2
a1080 1
mpserver_Write(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
@


1.19
log
@Maintain input and output throughput averages and choose the highest
of the two when calculating the MP throughput average for the ``set
autoload'' implementation.

This makes more sense as all links I know of are full-duplex.  This
also means that people may need to adjust their autoload settings
as 100% bandwidth is now the theoretical maximum rather than 200%
(but of course, halfing the current settings is probably not the
correct answer either!).

This involves a ppp version bump as we need to pass an extra
throughput array through the MP local domain socket.
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.18 2000/08/15 10:08:51 brian Exp $
d696 1
a696 2
    total += add;
    if (add)
d698 1
d700 1
d702 46
a747 3
    if (!link_QueueLen(&mp->link) && !ip_PushPacket(&mp->link, bundle))
      /* Nothing else to send */
      break;
d750 20
a769 16
    len = m_length(m);
    begin = 1;
    end = 0;

    while (!end) {
      if (dl->state == DATALINK_OPEN) {
        /* Write at most his_mru bytes to the physical link */
        if (len <= dl->physical->link.lcp.his_mru) {
          mo = m;
          end = 1;
          m_settype(mo, MB_MPOUT);
        } else {
          /* It's > his_mru, chop the packet (`m') into bits */
          mo = m_get(dl->physical->link.lcp.his_mru, MB_MPOUT);
          len -= mo->m_len;
          m = mbuf_Read(m, MBUF_CTOP(mo), mo->m_len);
a770 3
        mp_Output(mp, bundle, &dl->physical->link, mo, begin, end);
        begin = 0;
      }
d772 9
a780 8
      if (!end) {
        nlinks--;
        dl = dl->next;
        if (!dl) {
          dl = bundle->links;
          thislink = 0;
        } else
          thislink++;
d796 1
a796 1
  
d867 1
a867 1
  
@


1.18
log
@Calculate the average link throughput using a counter based on the
cumulative total of all active links rather than basing it on the
total of PROTO_MP traffic.

This fixes a problem whereby Cisco routers send PROTO_IP packets only
when there's only one link (hmm, what a good idea!).
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.17 2000/07/12 15:07:45 brian Exp $
d192 3
a194 1
  percent = mp->link.stats.total.OctetsPerSecond * 800 / mp->bundle->bandwidth;
@


1.17
log
@Fix a rather nasty latency problem that occurs with single tcp sessions
thorough an MP setup with only a single link.
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.16 2000/06/13 09:57:51 brian Exp $
d192 1
a192 1
  percent = mp->link.throughput.OctetsPerSecond * 800 / mp->bundle->bandwidth;
d205 1
a205 1
  throughput_stop(&mp->link.throughput);
d211 4
a214 4
  if (mp->link.throughput.SamplePeriod != mp->cfg.autoload.period) {
    throughput_destroy(&mp->link.throughput);
    throughput_init(&mp->link.throughput, mp->cfg.autoload.period);
    throughput_callback(&mp->link.throughput, mp_UpDown, mp);
d218 1
a218 1
    throughput_start(&mp->link.throughput, "MP throughput", 1);
d226 1
a226 1
  if (mp->link.throughput.SamplePeriod != mp->cfg.autoload.period)
d229 1
a229 1
    throughput_clear(&mp->link.throughput, THROUGHPUT_OVERALL, NULL);
d253 4
a256 2
  throughput_init(&mp->link.throughput, mp->cfg.autoload.period);
  throughput_callback(&mp->link.throughput, mp_UpDown, mp);
d323 3
a325 3
    throughput_destroy(&mp->link.throughput);
    throughput_init(&mp->link.throughput, mp->cfg.autoload.period);
    throughput_callback(&mp->link.throughput, mp_UpDown, mp);
d329 3
@


1.16
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.15 2000/02/27 01:38:27 brian Exp $
a444 5
  if (!mp->inbufs) {
    mp->inbufs = m;
    m = NULL;
  }

d448 2
a449 4
  while (q) {
    mp_ReadHeader(mp, q, &h);
    if (m && isbefore(mp->local_is12bit, mh.seq, h.seq)) {
      /* Our received fragment fits in before this one, so link it in */
a453 1
      m->m_nextpkt = q;
d455 1
d457 14
a470 1
      m = NULL;
@


1.15
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: mp.c,v 1.14 2000/02/27 00:21:08 brian Exp $
d295 6
@


1.14
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.13 2000/01/07 03:26:55 brian Exp $
@


1.13
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.12 1999/08/05 10:32:14 brian Exp $
d969 1
a969 1
mpserver_UpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e,
d999 1
a999 1
mpserver_IsSet(struct descriptor *d, const fd_set *fdset)
d1006 1
a1006 1
mpserver_Read(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
d1014 1
a1014 1
mpserver_Write(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
@


1.12
log
@o Obsolete the undocumented ``set weight'' command.
o If we're using RADIUS and the RADIUS mtu is less than our
  peers mru/mrru, reduce our mtu to this value for NetBSD too.
o Make struct throughput's sample period dynamic and tweak the ppp
  version number to reflect the extra stuff being passed through
  the local domain socket as a result (MP mode).
o Measure the current throughput based on the number of samples actually
  taken rather than on the full sample period.
o Keep the throughput statisics persistent while being passed to
  another ppp invocation through the local domain socket.
o When showing throughput statistics after the timer has stopped, use
  the stopped time for overall calculations, not the current time.
  Also show the stopped time and how long the current throughput has
  been sampled for.
o Use time() consistently in throughput.c
o Tighten up the ``show bundle'' output.
o Introduce the ``set bandwidth'' command.
o Rewrite the ``set autoload'' command.  It now takes three arguments
  and works based on a rolling bundle throughput average compared against
  the theoretical bundle bandwidth over a given period (read: it's now
  functional).
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.11 1999/06/09 16:55:25 brian Exp $
d48 2
a49 2
#ifndef NOALIAS
#include "alias_cmd.h"
d281 2
a282 2
#ifndef NOALIAS
  link_Stack(&mp->link, &aliaslayer);
d377 2
a378 2
      next = mp->inbufs->pnext;
      mbuf_Free(mp->inbufs);
d408 1
a408 1
    mbuf_Free(m);
d452 1
a452 1
        last->pnext = m;
d455 1
a455 1
      m->pnext = q;
d470 2
a471 2
          next = mp->inbufs->pnext;
          mbuf_Free(mp->inbufs);
d487 1
a487 1
          next = mp->inbufs->pnext;
d489 1
a489 1
          mbuf_Free(mp->inbufs);
d516 1
a516 1
        mp->inbufs = mp->inbufs->pnext;
d520 3
a522 3
        (*frag)->offset += len;
        (*frag)->cnt -= len;
        (*frag)->pnext = NULL;
d526 1
a526 1
          mbuf_Free(q);
d535 1
a535 1
          (*frag)->pnext = mp->inbufs;
d538 1
a538 1
          mbuf_Free(q);
d544 1
a544 1
            frag = &(*frag)->next;
d549 1
a549 1
        q = mbuf_Contiguous(q);
d551 3
a553 3
                   first, (u_long)h.seq, mbuf_Length(q));
        link_PullPacket(&mp->link, MBUF_CTOP(q), q->cnt, mp->bundle);
        mbuf_Free(q);
d563 1
a563 1
      q = q->pnext;
d570 1
a570 1
    for (q = mp->inbufs; q; last = q, q = q->pnext) {
d577 1
a577 1
      last->pnext = m;
d580 1
a580 1
    m->pnext = q;
d595 1
a595 1
    mbuf_Free(bp);
d597 1
a597 1
    mbuf_SetType(bp, MB_MPIN);
d608 1
a608 1
  struct mbuf *mo;
d611 1
a611 2
  mo = mbuf_Alloc(4, MB_MPOUT);
  mo->next = m;
d616 2
a617 2
    ua_htons(&val, MBUF_CTOP(mo));
    mo->cnt = 2;
d622 2
a623 2
    ua_htonl(&val, MBUF_CTOP(mo));
    mo->cnt = 4;
d627 1
a627 1
               mp->out.seq, mbuf_Length(mo), l->name);
d630 1
a630 1
  link_PushPacket(l, mo, bundle, PRI_NORMAL, PROTO_MP);
d638 2
a639 1
  int total, add, len, thislink, nlinks;
d687 1
a687 1
    len = mbuf_Length(m);
d697 1
a697 1
          mbuf_SetType(mo, MB_MPOUT);
d700 3
a702 3
          mo = mbuf_Alloc(dl->physical->link.lcp.his_mru, MB_MPOUT);
          len -= mo->cnt;
          m = mbuf_Read(m, MBUF_CTOP(mo), mo->cnt);
d758 1
a758 1
    for (m = mp->inbufs; m; m = m->pnext) {
a1008 9
  struct sockaddr in;
  int fd, size;

  size = sizeof in;
  fd = accept(s->fd, &in, &size);
  if (fd < 0) {
    log_Printf(LogERROR, "mpserver_Read: accept(): %s\n", strerror(errno));
    return;
  }
d1010 1
a1010 4
  if (in.sa_family == AF_LOCAL)
    bundle_ReceiveDatalink(bundle, fd, (struct sockaddr_un *)&in);
  else
    close(fd);
d1056 1
a1056 1
  s->fd = ID0socket(PF_LOCAL, SOCK_STREAM, 0);
d1058 1
a1058 1
    log_Printf(LogERROR, "mpserver: socket: %s\n", strerror(errno));
d1065 6
d1080 2
d1087 1
a1087 1
        log_Printf(LogPHASE, "          Has the previous server died badly ?\n");
a1094 7
  }

  /* Listen for other ppp invocations that want to donate links */
  if (listen(s->fd, 5) != 0) {
    log_Printf(LogERROR, "mpserver: Unable to listen to socket"
              " - BUNDLE overload?\n");
    mpserver_Close(s);
@


1.11
log
@Allow our endpoint discriminator to be enabled, disabled, accepted
and denied.  This is necessary for some MP implementations that
get confused if you accept their endpoint discriminator but reject
their MRRU.
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.10 1999/06/03 13:50:53 brian Exp $
d186 46
d251 4
a254 1
  throughput_init(&mp->link.throughput);
d315 3
a317 1
    throughput_init(&mp->link.throughput);
d366 3
d391 1
a391 1
  mplink->weight = 1500;
d693 2
a694 5
        if (len <= dl->mp.weight + LINK_MINWEIGHT) {
          /*
           * XXX: Should we remember how much of our `weight' wasn't sent
           *      so that we can compensate next time ?
           */
d699 2
a700 2
          mo = mbuf_Alloc(dl->mp.weight, MB_MPOUT);
          mo->cnt = dl->mp.weight;
d725 1
a725 1
mp_SetDatalinkWeight(struct cmdargs const *arg)
d733 2
a734 3
  if (val < LINK_MINWEIGHT) {
    log_Printf(LogWARN, "Link weights must not be less than %d\n",
              LINK_MINWEIGHT);
d737 5
a741 1
  arg->cx->mp.weight = val;
d780 1
d792 1
a792 1
    prompt_Printf(arg->prompt, " Next SEQ:      %u\n", mp->out.seq);
d812 3
@


1.10
log
@Fix some MP sequence number comparison bogons that are tickled by
having different speed links in a bundle.  This would manifest itself
by having the link occasionally hang, but revive when a new connection
is made....
Make ``show mp'' a bit prettier.
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.9 1999/06/02 23:06:59 brian Exp $
d220 1
d755 2
@


1.9
log
@Oops, quieten a compiler warning.
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.8 1999/06/02 15:58:41 brian Exp $
d408 1
a408 1
      if (mp->seq.min_in > seq) {
d436 2
a437 1
        } while (mp->inbufs && (h.seq >= mp->seq.min_in || h.end));
d573 1
a573 1
              mp->out.seq, mbuf_Length(mo), l->name);
d714 1
a714 1
      prompt_Printf(arg->prompt, " (Have %lu - %lu, want %lu, lowest %lu)",
d717 2
a718 1
      prompt_Printf(arg->prompt, " first is %d, %d", mh.begin ? 1 : 0, mh.end ? 1 : 0);
@


1.8
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.7 1999/05/28 08:03:53 brian Exp $
d699 1
@


1.7
log
@Don't forget to free the mbufs that get processed by
mp_Assemble().
Leak spotted by: louqi
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.6 1999/05/12 10:03:52 brian Exp $
d540 2
a541 1
  } else
d543 1
d555 1
a555 1
  mo = mbuf_Alloc(4, MB_MP);
d644 1
d646 1
a646 1
          mo = mbuf_Alloc(dl->mp.weight, MB_MP);
d696 1
a696 1
    struct mbuf *m;
d701 1
a701 1
    for (m = mp->inbufs; m; m = m->pnext)
d703 15
a717 1
    prompt_Printf(arg->prompt, "Pending frags:  %d\n", bufs);
@


1.6
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.5 1999/05/08 11:06:38 brian Exp $
d497 1
@


1.5
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.4 1999/02/06 03:22:42 brian Exp $
a492 13
        u_short proto;
        u_char ch;

        q = mbuf_Read(q, &ch, 1);
        proto = ch;
        if (!(proto & 1)) {
          q = mbuf_Read(q, &ch, 1);
          proto <<= 8;
          proto += ch;
        }
        if (log_IsKept(LogDEBUG))
          log_Printf(LogDEBUG, "MP: Reassembled frags %ld-%lu, length %d\n",
                    first, (u_long)h.seq, mbuf_Length(q));
d494 2
@


1.4
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.18 1999/01/28 01:56:33 brian Exp $
d47 5
d73 1
a73 1
#include "lcpproto.h"
d201 1
a201 1
  mp->link.type = MP_LINK;
d226 8
d339 2
a340 2
void
mp_Input(struct mp *mp, struct mbuf *m, struct physical *p)
d506 2
a507 1
        hdlc_DecodePacket(mp->bundle, proto, q, &mp->link);
d538 18
d557 2
a558 2
mp_Output(struct mp *mp, struct link *l, struct mbuf *m, u_int32_t begin,
          u_int32_t end)
d583 1
a583 2
  if (!ccp_Compress(&l->ccp, l, PRI_NORMAL, PROTO_MP, mo))
    hdlc_Output(l, PRI_NORMAL, PROTO_MP, mo);
d634 1
a634 1
    if (!link_QueueLen(&mp->link) && !ip_FlushPacket(&mp->link, bundle))
d658 1
a658 1
        mp_Output(mp, &dl->physical->link, mo, begin, end);
d1062 1
a1062 1
    mp_Input(mp, NULL, NULL);
@


1.3
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.2 1998/09/04 18:27:47 brian Exp $
d29 1
a29 1
#include <sys/types.h>
d74 3
@


1.2
log
@Don't cast potentially unaligned addresses to pointers to
non-char types on non-i386 architectures.
On Alpha and Sparc we get a bus error if we do.
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.1 1998/08/31 00:22:25 brian Exp $
d777 14
a790 3
  if (bundle_Phase(arg->bundle) != PHASE_DEAD) {
    log_Printf(LogWARN, "set enddisc: Only available at phase DEAD\n");
    return 1;
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d26 1
a26 1
 *	$Id: mp.c,v 1.15 1998/08/26 17:39:37 brian Exp $
d47 1
d128 4
a131 2
    header->seq = ntohs(*(u_int16_t *)MBUF_CTOP(m));
    if (header->seq & 0x3000) {
d135 3
a137 3
    header->begin = header->seq & 0x8000 ? 1 : 0;
    header->end = header->seq & 0x4000 ? 1 : 0;
    header->seq &= 0x0fff;
d140 1
a140 1
    header->seq = ntohl(*(u_int32_t *)MBUF_CTOP(m));
d531 1
a531 1
    u_int16_t *seq16;
d533 2
a534 2
    seq16 = (u_int16_t *)MBUF_CTOP(mo);
    *seq16 = htons((begin << 15) | (end << 14) | (u_int16_t)mp->out.seq);
d537 1
a537 1
    u_int32_t *seq32;
d539 2
a540 2
    seq32 = (u_int32_t *)MBUF_CTOP(mo);
    *seq32 = htonl((begin << 31) | (end << 30) | (u_int32_t)mp->out.seq);
@

