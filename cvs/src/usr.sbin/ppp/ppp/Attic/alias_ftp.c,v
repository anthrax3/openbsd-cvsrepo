head	1.16;
access;
symbols
	OPENBSD_5_5:1.15.0.46
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.42
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.40
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.38
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.36
	OPENBSD_5_0:1.15.0.34
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.32
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.30
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.26
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.28
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.24
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.22
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.20
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.18
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.16
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.14
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.15;

1.15
date	2003.04.04.20.25.06;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.23.11.17.03;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.24.10.01.07;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.21.04.09.15;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.27.16.15.13;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.07.09.32.55;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.02.00.53.47;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.23.09.47.05;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.15.09.37.08;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.11.14.40.26;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.27.01.38.24;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.07.03.26.52;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.03.09.23.43.01;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.08.16.33;	author brian;	state Exp;
branches;
next	;


desc
@@


1.16
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 2001 Charles Mott <cm@@linktel.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: alias_ftp.c,v 1.15 2003/04/04 20:25:06 deraadt Exp $
 */

/*
    Alias_ftp.c performs special processing for FTP sessions under
    TCP.  Specifically, when a PORT/EPRT command from the client
    side or 227/229 reply from the server is sent, it is intercepted
    and modified.  The address is changed to the gateway machine
    and an aliasing port is used.

    For this routine to work, the message must fit entirely into a
    single TCP packet.  This is typically the case, but exceptions
    can easily be envisioned under the actual specifications.

    Probably the most troubling aspect of the approach taken here is
    that the new message will typically be a different length, and
    this causes a certain amount of bookkeeping to keep track of the
    changes of sequence and acknowledgment numbers, since the client
    machine is totally unaware of the modification to the TCP stream.


    References: RFC 959, RFC 2428.

    Initial version:  August, 1996  (cjm)

    Version 1.6
         Brian Somers and Martin Renters identified an IP checksum
         error for modified IP packets.

    Version 1.7:  January 9, 1996 (cjm)
         Differential checksum computation for change
         in IP packet length.

    Version 2.1:  May, 1997 (cjm)
         Very minor changes to conform with
         local/global/function naming conventions
         within the packet aliasing module.

    Version 3.1:  May, 2000 (eds)
	 Add support for passive mode, alias the 227 replies.

    See HISTORY file for record of revisions.
*/

/* Includes */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include "alias_local.h"

#define FTP_CONTROL_PORT_NUMBER 21
#define MAX_MESSAGE_SIZE	128

/* FTP protocol flags. */
#define WAIT_CRLF		0x01

enum ftp_message_type {
    FTP_PORT_COMMAND,
    FTP_EPRT_COMMAND,
    FTP_227_REPLY,
    FTP_229_REPLY,
    FTP_UNKNOWN_MESSAGE
};

static int ParseFtpPortCommand(char *, int);
static int ParseFtpEprtCommand(char *, int);
static int ParseFtp227Reply(char *, int);
static int ParseFtp229Reply(char *, int);
static void NewFtpMessage(struct ip *, struct alias_link *, int, int);

static struct in_addr true_addr;	/* in network byte order. */
static u_short true_port;		/* in host byte order. */

void
AliasHandleFtpOut(
struct ip *pip,	  /* IP packet to examine/patch */
struct alias_link *link, /* The link to go through (aliased port) */
int maxpacketsize  /* The maximum size this packet can grow to (including headers) */)
{
    int hlen, tlen, dlen, pflags;
    char *sptr;
    struct tcphdr *tc;
    int ftp_message_type;

/* Calculate data length of TCP packet */
    tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));
    hlen = (pip->ip_hl + tc->th_off) << 2;
    tlen = ntohs(pip->ip_len);
    dlen = tlen - hlen;

/* Place string pointer and beginning of data */
    sptr = (char *) pip;
    sptr += hlen;

/*
 * Check that data length is not too long and previous message was
 * properly terminated with CRLF.
 */
    pflags = GetProtocolFlags(link);
    if (dlen <= MAX_MESSAGE_SIZE && !(pflags & WAIT_CRLF)) {
	ftp_message_type = FTP_UNKNOWN_MESSAGE;

	if (ntohs(tc->th_dport) == FTP_CONTROL_PORT_NUMBER) {
/*
 * When aliasing a client, check for the PORT/EPRT command.
 */
	    if (ParseFtpPortCommand(sptr, dlen))
		ftp_message_type = FTP_PORT_COMMAND;
	    else if (ParseFtpEprtCommand(sptr, dlen))
		ftp_message_type = FTP_EPRT_COMMAND;
	} else {
/*
 * When aliasing a server, check for the 227/229 reply.
 */
	    if (ParseFtp227Reply(sptr, dlen))
		ftp_message_type = FTP_227_REPLY;
	    else if (ParseFtp229Reply(sptr, dlen)) {
		ftp_message_type = FTP_229_REPLY;
		true_addr.s_addr = pip->ip_src.s_addr;
	    }
	}

	if (ftp_message_type != FTP_UNKNOWN_MESSAGE)
	    NewFtpMessage(pip, link, maxpacketsize, ftp_message_type);
    }

/* Track the msgs which are CRLF term'd for PORT/PASV FW breach */

    if (dlen) {                  /* only if there's data */
      sptr = (char *) pip; 	 /* start over at beginning */
      tlen = ntohs(pip->ip_len); /* recalc tlen, pkt may have grown */
      if (sptr[tlen-2] == '\r' && sptr[tlen-1] == '\n')
	pflags &= ~WAIT_CRLF;
      else
	pflags |= WAIT_CRLF;
      SetProtocolFlags(link, pflags);
    }
}

static int
ParseFtpPortCommand(char *sptr, int dlen)
{
    char ch;
    int i, state;
    u_int32_t addr;
    u_short port;
    u_int8_t octet;

    /* Format: "PORT A,D,D,R,PO,RT". */

    /* Return if data length is too short. */
    if (dlen < 18)
	return 0;

    addr = port = octet = 0;
    state = -4;
    for (i = 0; i < dlen; i++) {
	ch = sptr[i];
	switch (state) {
	case -4: if (ch == 'P') state++; else return 0; break;
	case -3: if (ch == 'O') state++; else return 0; break;
	case -2: if (ch == 'R') state++; else return 0; break;
	case -1: if (ch == 'T') state++; else return 0; break;

	case 0:
	    if (isspace(ch))
		break;
	    else
		state++;
	case 1: case 3: case 5: case 7: case 9: case 11:
	    if (isdigit(ch)) {
		octet = ch - '0';
		state++;
	    } else
		return 0;
	    break;
	case 2: case 4: case 6: case 8:
	    if (isdigit(ch))
		octet = 10 * octet + ch - '0';
            else if (ch == ',') {
		addr = (addr << 8) + octet;
		state++;
	    } else
		return 0;
	    break;
	case 10: case 12:
	    if (isdigit(ch))
		octet = 10 * octet + ch - '0';
	    else if (ch == ',' || state == 12) {
		port = (port << 8) + octet;
		state++;
	    } else
		return 0;
	    break;
	}
    }

    if (state == 13) {
	true_addr.s_addr = htonl(addr);
	true_port = port;
	return 1;
    } else
	return 0;
}

static int
ParseFtpEprtCommand(char *sptr, int dlen)
{
    char ch, delim;
    int i, state;
    u_int32_t addr;
    u_short port;
    u_int8_t octet;

    /* Format: "EPRT |1|A.D.D.R|PORT|". */

    /* Return if data length is too short. */
    if (dlen < 18)
	return 0;

    addr = port = octet = 0;
    delim = '|';			/* XXX gcc -Wuninitialized */
    state = -4;
    for (i = 0; i < dlen; i++) {
	ch = sptr[i];
	switch (state)
	{
	case -4: if (ch == 'E') state++; else return 0; break;
	case -3: if (ch == 'P') state++; else return 0; break;
	case -2: if (ch == 'R') state++; else return 0; break;
	case -1: if (ch == 'T') state++; else return 0; break;

	case 0:
	    if (!isspace(ch)) {
		delim = ch;
		state++;
	    }
	    break;
	case 1:
	    if (ch == '1')	/* IPv4 address */
		state++;
	    else
		return 0;
	    break;
	case 2:
	    if (ch == delim)
		state++;
	    else
		return 0;
	    break;
	case 3: case 5: case 7: case 9:
	    if (isdigit(ch)) {
		octet = ch - '0';
		state++;
	    } else
		return 0;
	    break;
	case 4: case 6: case 8: case 10:
	    if (isdigit(ch))
		octet = 10 * octet + ch - '0';
            else if (ch == '.' || state == 10) {
		addr = (addr << 8) + octet;
		state++;
	    } else
		return 0;
	    break;
	case 11:
	    if (isdigit(ch)) {
		port = ch - '0';
		state++;
	    } else
		return 0;
	    break;
	case 12:
	    if (isdigit(ch))
		port = 10 * port + ch - '0';
	    else if (ch == delim)
		state++;
	    else
		return 0;
	    break;
	}
    }

    if (state == 13) {
	true_addr.s_addr = htonl(addr);
	true_port = port;
	return 1;
    } else
	return 0;
}

static int
ParseFtp227Reply(char *sptr, int dlen)
{
    char ch;
    int i, state;
    u_int32_t addr;
    u_short port;
    u_int8_t octet;

    /* Format: "227 Entering Passive Mode (A,D,D,R,PO,RT)" */

    /* Return if data length is too short. */
    if (dlen < 17)
	return 0;

    addr = port = octet = 0;

    state = -3;
    for (i = 0; i < dlen; i++) {
        ch = sptr[i];
        switch (state)
        {
        case -3: if (ch == '2') state++; else return 0; break;
        case -2: if (ch == '2') state++; else return 0; break;
        case -1: if (ch == '7') state++; else return 0; break;

	case 0:
	    if (ch == '(')
		state++;
	    break;
	case 1: case 3: case 5: case 7: case 9: case 11:
	    if (isdigit(ch)) {
		octet = ch - '0';
		state++;
	    } else
		return 0;
	    break;
	case 2: case 4: case 6: case 8:
	    if (isdigit(ch))
		octet = 10 * octet + ch - '0';
            else if (ch == ',') {
		addr = (addr << 8) + octet;
		state++;
	    } else
		return 0;
	    break;
	case 10: case 12:
	    if (isdigit(ch))
		octet = 10 * octet + ch - '0';
	    else if (ch == ',' || (state == 12 && ch == ')')) {
		port = (port << 8) + octet;
		state++;
	    } else
		return 0;
	    break;
	}
    }

    if (state == 13) {
        true_port = port;
        true_addr.s_addr = htonl(addr);
	return 1;
    } else
	return 0;
}

static int
ParseFtp229Reply(char *sptr, int dlen)
{
    char ch, delim;
    int i, state;
    u_short port;

    /* Format: "229 Entering Extended Passive Mode (|||PORT|)" */

    /* Return if data length is too short. */
    if (dlen < 11)
	return 0;

    port = 0;
    delim = '|';			/* XXX gcc -Wuninitialized */

    state = -3;
    for (i = 0; i < dlen; i++) {
	ch = sptr[i];
	switch (state)
	{
	case -3: if (ch == '2') state++; else return 0; break;
	case -2: if (ch == '2') state++; else return 0; break;
	case -1: if (ch == '9') state++; else return 0; break;

	case 0:
	    if (ch == '(')
		state++;
	    break;
	case 1:
	    delim = ch;
	    state++;
	    break;
	case 2: case 3:
	    if (ch == delim)
		state++;
	    else
		return 0;
	    break;
	case 4:
	    if (isdigit(ch)) {
		port = ch - '0';
		state++;
	    } else
		return 0;
	    break;
	case 5:
	    if (isdigit(ch))
		port = 10 * port + ch - '0';
	    else if (ch == delim)
		state++;
	    else
		return 0;
	    break;
	case 6:
	    if (ch == ')')
		state++;
	    else
		return 0;
	    break;
	}
    }

    if (state == 7) {
	true_port = port;
	return 1;
    } else
	return 0;
}

static void
NewFtpMessage(struct ip *pip,
              struct alias_link *link,
              int maxpacketsize,
              int ftp_message_type)
{
    struct alias_link *ftp_link;

/* Security checks. */
    if (pip->ip_src.s_addr != true_addr.s_addr)
	return;

    if (true_port < IPPORT_RESERVED)
	return;

/* Establish link to address and port found in FTP control message. */
    ftp_link = FindUdpTcpOut(true_addr, GetDestAddress(link),
                             htons(true_port), 0, IPPROTO_TCP, 1);

    if (ftp_link != NULL)
    {
        int slen, hlen, tlen, dlen;
        struct tcphdr *tc;

#ifndef NO_FW_PUNCH
	/* Punch hole in firewall */
	PunchFWHole(ftp_link);
#endif

/* Calculate data length of TCP packet */
        tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));
        hlen = (pip->ip_hl + tc->th_off) << 2;
        tlen = ntohs(pip->ip_len);
        dlen = tlen - hlen;

/* Create new FTP message. */
        {
            char stemp[MAX_MESSAGE_SIZE + 1];
            char *sptr;
            u_short alias_port;
            u_char *ptr;
            int a1, a2, a3, a4, p1, p2;
            struct in_addr alias_address;

/* Decompose alias address into quad format */
            alias_address = GetAliasAddress(link);
            ptr = (u_char *) &alias_address.s_addr;
            a1 = *ptr++; a2=*ptr++; a3=*ptr++; a4=*ptr;

	    alias_port = GetAliasPort(ftp_link);

	    switch (ftp_message_type)
	    {
	    case FTP_PORT_COMMAND:
	    case FTP_227_REPLY:
		/* Decompose alias port into pair format. */
		ptr = (char *) &alias_port;
		p1 = *ptr++; p2=*ptr;

		if (ftp_message_type == FTP_PORT_COMMAND) {
		    /* Generate PORT command string. */
		    snprintf(stemp, sizeof stemp, "PORT %d,%d,%d,%d,%d,%d\r\n",
			    a1,a2,a3,a4,p1,p2);
		} else {
		    /* Generate 227 reply string. */
		    snprintf(stemp, sizeof stemp,
			    "227 Entering Passive Mode (%d,%d,%d,%d,%d,%d)\r\n",
			    a1,a2,a3,a4,p1,p2);
		}
		break;
	    case FTP_EPRT_COMMAND:
		/* Generate EPRT command string. */
		snprintf(stemp, sizeof stemp, "EPRT |1|%d.%d.%d.%d|%d|\r\n",
			a1,a2,a3,a4,ntohs(alias_port));
		break;
	    case FTP_229_REPLY:
		/* Generate 229 reply string. */
		snprintf(stemp, sizeof stemp,
			"229 Entering Extended Passive Mode (|||%d|)\r\n",
			ntohs(alias_port));
		break;
	    }

/* Save string length for IP header modification */
            slen = strlen(stemp);

/* Copy modified buffer into IP packet. */
            sptr = (char *) pip; sptr += hlen;
            strncpy(sptr, stemp, maxpacketsize-hlen);
        }

/* Save information regarding modified seq and ack numbers */
        {
            int delta;

            SetAckModified(link);
            delta = GetDeltaSeqOut(pip, link);
            AddSeq(pip, link, delta+slen-dlen);
        }

/* Revise IP header */
        {
            u_short new_len;

            new_len = htons(hlen + slen);
            DifferentialChecksum(&pip->ip_sum,
                                 &new_len,
                                 &pip->ip_len,
                                 1);
            pip->ip_len = new_len;
        }

/* Compute TCP checksum for revised packet */
        tc->th_sum = 0;
        tc->th_sum = TcpChecksum(pip);
    }
    else
    {
#ifdef DEBUG
        fprintf(stderr,
        "PacketAlias/HandleFtpOut: Cannot allocate FTP data port\n");
#endif
    }
}
@


1.15
log
@strlcpy and snprintf; various people ok
@
text
@d26 1
a26 1
 * $OpenBSD: alias_ftp.c,v 1.14 2002/03/31 02:38:49 brian Exp $
@


1.14
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d26 1
a26 1
 * $OpenBSD: alias_ftp.c,v 1.13 2001/11/23 11:17:03 brian Exp $
d521 1
a521 1
		    sprintf(stemp, "PORT %d,%d,%d,%d,%d,%d\r\n",
d525 1
a525 1
		    sprintf(stemp,
d532 1
a532 1
		sprintf(stemp, "EPRT |1|%d.%d.%d.%d|%d|\r\n",
d537 2
a538 1
		sprintf(stemp, "229 Entering Extended Passive Mode (|||%d|)\r\n",
@


1.13
log
@cmott@@scientech.com -> cm@@linktel.net
Add the UPTIME variable
CCP protocol ``0xffffffff'' -> ``none''
Don't leak memory when expanding command arguments and not exec()ing
Make some functions static
Add the ``log'' command for manual logging
Fix some log text bogons
@
text
@d26 1
a26 1
 * $OpenBSD: alias_ftp.c,v 1.12 2001/10/24 10:01:07 brian Exp $
d485 2
a486 5
	if (ftp_message_type == FTP_PORT_COMMAND ||
	    ftp_message_type == FTP_EPRT_COMMAND) {
	    /* Punch hole in firewall */
	    PunchFWHole(ftp_link);
	}
@


1.12
log
@Fix a PASV bug; FreeBSD
@
text
@d2 1
a2 1
 * Copyright (c) 2001 Charles Mott <cmott@@scientech.com>
d26 1
a26 1
 * $OpenBSD: alias_ftp.c,v 1.11 2001/08/21 04:09:15 brian Exp $
@


1.11
log
@Remove some conflicting copyright lines.
@
text
@d26 1
a26 1
 * $OpenBSD: alias_ftp.c,v 1.10 2001/06/27 16:15:13 brian Exp $
d148 1
a148 1
	    else if (ParseFtp229Reply(sptr, dlen))
d150 2
d469 1
a469 2
    if (ftp_message_type != FTP_229_REPLY &&
	pip->ip_src.s_addr != true_addr.s_addr)
@


1.10
log
@Fix an inverted test; FreeBSD
@
text
@d26 1
a26 1
 * $OpenBSD: alias_ftp.c,v 1.9 2001/06/07 09:32:55 brian Exp $
a45 3

    This software is placed into the public domain with no restrictions
    on its distribution.
@


1.9
log
@Depricate the -alias option (it's been -nat for a long time)
Handle carriage-return/line-feed stuff for ftp natting more generically
Fix an alignment bug when logging DNS traffic
Fix/add some copyrights
@
text
@d26 1
a26 1
 * $OpenBSD$
d134 1
a134 1
    if (dlen <= MAX_MESSAGE_SIZE && (pflags & WAIT_CRLF)) {
@


1.8
log
@Improvements for ICMP and GRE/PPTP; FreeBSD
@
text
@d1 28
a70 2

    $OpenBSD: alias_ftp.c,v 1.7 2000/06/23 09:47:05 brian Exp $
d88 3
d114 1
a114 1
    int hlen, tlen, dlen;
d133 2
a134 1
    if (dlen <= MAX_MESSAGE_SIZE && GetLastLineCrlfTermed(link)) {
d164 5
a168 2
      SetLastLineCrlfTermed(link,
			    (sptr[tlen-2] == '\r') && (sptr[tlen-1] == '\n'));
@


1.7
log
@Improved 227, 229 and EPRT support in the nat code; FreeBSD
Moved security checks into one place; FreeBSD
Remove ``nat pptp'' now that it's transparent
@
text
@d44 1
a44 1
    $OpenBSD: alias_ftp.c,v 1.6 2000/06/15 09:37:08 brian Exp $
d446 1
a446 1
                             htons(true_port), 0, IPPROTO_TCP);
@


1.6
log
@Full support for passive mode FTP
Ensure that the segment preceding a PORT/227 segment terminates with
a \r\n, the IP address in the PORT/227 matches the source IP address
of the packet and the port number in the PORT command or 277 reply is
greater than or equal to 1024.

Obtained from: FreeBSD
@
text
@d3 2
a4 2
    TCP.  Specifically, when a PORT command from the client side
    or PASV/227 reply from the server is sent, it is intercepted
d8 2
a9 2
    For this routine to work, the PORT/227 must fit entirely
    into a single TCP packet.  This is typically the case, but exceptions
d13 1
a13 1
    that the new PORT/227 will typically be a different length, and
a17 4
    This version also supports the EPRT command, which is functionally
    equivalent to the PORT command, but was designed to support both
    IPv4 and IPv6 addresses.  See RFC 2428 for specifications.

d22 2
d33 1
a33 1
   
d44 1
a44 1
    $OpenBSD: alias_ftp.c,v 1.5 2000/06/11 14:40:26 brian Exp $
d49 1
a49 1
#include <stdio.h> 
d59 2
a60 7
#define FTP_CONTROL_PORT_NUMBER 21 
#define MIN_227_REPLY	16
#define MAX_227_REPLY	128

static int  ParseFtpPortCommand(char *, int, struct ip *, struct alias_link *, int);
static void ParseFtpEprtCommand(char *, int, struct ip *, struct alias_link *, int);
static void NewFtpPortCommand(struct ip *, struct alias_link *, struct in_addr, u_short, int, int);
d62 13
a74 2
static int  ParseFtp227Reply(char *, int, struct ip *, struct alias_link *, int);
static void NewFtp227Reply(struct ip *, struct alias_link *, struct in_addr, u_short, int);
d76 2
d88 2
a89 1
        
d97 1
a97 1
    sptr = (char *) pip;  
d100 27
a126 7
/* When aliasing a client, check for the PORT/EPRT command */
    if (ntohs(tc->th_dport) == FTP_CONTROL_PORT_NUMBER) { 
/* Parse through string using state diagram method */
        if (!ParseFtpPortCommand(sptr, dlen, pip, link, maxpacketsize))
            ParseFtpEprtCommand(sptr, dlen, pip, link, maxpacketsize);
    } else {
        ParseFtp227Reply(sptr, dlen, pip, link, maxpacketsize);
d131 2
a132 2
    if (dlen) {                  /* only if there's data */ 
      sptr = (char *) pip; 	 /* start over at beginning */ 
d140 1
a140 6
ParseFtpPortCommand(
char *sptr,
int dlen,
struct ip *pip,	  /* IP packet to examine/patch */
struct alias_link *link, /* The link to go through (aliased port) */
int maxpacketsize  /* The maximum size this packet can grow to (including headers) */)
a141 2
    struct in_addr true_addr;
    u_short true_port;
d144 5
a148 2
    u_long a1, a2, a3, a4;
    u_short p1, p2; 
d150 2
a151 2
    /* Return if data length is too long or too short */
    if (dlen<10 || dlen>80) 
d154 3
a156 4
    a1=0; a2=0; a3=0; a4=0; p1=0; p2=0;
    state=-4;
    for (i=0; i<dlen; i++)
    {
d158 1
a158 2
	switch (state)
	{
d164 30
a193 24
	case 0 :
	    if (isdigit(ch)) {a1=ch-'0'; state++;} break;
	case 1 :
	    if (isdigit(ch)) a1=10*a1+ch-'0'; else state++; break;
	case 2 :
	    if (isdigit(ch)) {a2=ch-'0'; state++;} break;
	case 3 :
	    if (isdigit(ch)) a2=10*a2+ch-'0'; else state++; break;
	case 4 :
	    if (isdigit(ch)) {a3=ch-'0'; state++;} break;
	case 5 :
	    if (isdigit(ch)) a3=10*a3+ch-'0'; else state++; break;
	case 6 :
	    if (isdigit(ch)) {a4=ch-'0'; state++;} break;
	case 7 :
	    if (isdigit(ch)) a4=10*a4+ch-'0'; else state++; break;
	case 8 :
	    if (isdigit(ch)) {p1=ch-'0'; state++;} break;
	case 9 :
	    if (isdigit(ch)) p1=10*p1+ch-'0'; else state++; break;
	case 10:
	    if (isdigit(ch)) {p2=ch-'0'; state++;} break;
	case 11:
	    if (isdigit(ch)) p2=10*p2+ch-'0'; break;
d197 3
a199 7
    if (state == 11 && GetLastLineCrlfTermed(link))
    {
	true_port = htons((p1<<8) + p2);
	true_addr.s_addr = htonl((a1<<24) + (a2<<16) +(a3<<8) + a4);
	if ((pip->ip_src.s_addr == true_addr.s_addr) &&
	    ((p1<<8) >= IPPORT_RESERVED))
		NewFtpPortCommand(pip, link, true_addr, true_port, maxpacketsize, 0);
d201 1
a201 2
    }
    else
d205 2
a206 7
static void
ParseFtpEprtCommand(
char *sptr,
int dlen,
struct ip *pip,	  /* IP packet to examine/patch */
struct alias_link *link, /* The link to go through (aliased port) */
int maxpacketsize  /* The maximum size this packet can grow to (including headers) */)
a207 2
    struct in_addr true_addr;
    u_short true_port;
d210 3
a212 2
    u_long a1, a2, a3, a4;
    u_short pt;
d214 5
a218 3
    /* Return if data length is too long or too short */
    if (dlen<10 || dlen>80) 
	return;
d220 4
a223 5
    a1=0; a2=0; a3=0; a4=0; pt=0;
    delim='|';				/* XXX gcc -Wuninitialized */
    state=-4;
    for (i=0; i<dlen; i++)
    {
d227 38
a264 38
	case -4: if (ch == 'E') state++; else return; break;
	case -3: if (ch == 'P') state++; else return; break;
	case -2: if (ch == 'R') state++; else return; break;
	case -1: if (ch == 'T') state++; else return; break;

	case 0 :
	    if (!isspace(ch)) {delim=ch; state++;} break;
	case 1 :
	    if (ch=='1') /* IPv4 address */ state++; else return; break;
	case 2 :
	    if (ch==delim) state++; else return; break;
	case 3 :
	    if (isdigit(ch)) {a1=ch-'0'; state++;} else return; break;
	case 4 :
	    if (isdigit(ch)) a1=10*a1+ch-'0';
	    else if (ch=='.') state++;
	    else return;
	    break;
	case 5 :
	    if (isdigit(ch)) {a2=ch-'0'; state++;} else return; break;
	case 6 :
	    if (isdigit(ch)) a2=10*a2+ch-'0';
	    else if (ch=='.') state++;
	    else return;
	    break;
	case 7:
	    if (isdigit(ch)) {a3=ch-'0'; state++;} else return; break;
	case 8 :
	    if (isdigit(ch)) a3=10*a3+ch-'0';
	    else if (ch=='.') state++;
	    else return;
	    break;
	case 9 :
	    if (isdigit(ch)) {a4=ch-'0'; state++;} else return; break;
	case 10:
	    if (isdigit(ch)) a4=10*a4+ch-'0';
	    else if (ch==delim) state++;
	    else return;
d267 6
a272 1
	    if (isdigit(ch)) {pt=ch-'0'; state++;} else return; break;
d274 6
a279 3
	    if (isdigit(ch)) pt=10*pt+ch-'0';
	    else if (ch==delim) state++;
	    else return;
d284 6
a289 8
    if (state == 13 && GetLastLineCrlfTermed(link))
    {
	true_port = htons(pt);
	true_addr.s_addr = htonl((a1<<24) + (a2<<16) +(a3<<8) + a4);
	if ((pip->ip_src.s_addr == true_addr.s_addr) &&
	    (pt >= IPPORT_RESERVED))
		NewFtpPortCommand(pip, link, true_addr, true_port, maxpacketsize, 1);
    }
d293 1
a293 6
ParseFtp227Reply(char *sptr,
                 int dlen,
                 struct ip *pip, 	  /* IP packet to examine/patch */
                 struct alias_link *link, /* The link to go through (aliased port) */
                 int maxpacketsize)	  /* The maximum size this packet can grow */
					  /* to (including headers) */
a294 2
    struct in_addr true_addr;
    u_short true_port;
d297 3
a299 2
    u_long a1, a2, a3, a4;
    u_short p1, p2; 
d301 5
d307 1
a307 3
    /* Return if wrong size, in case more packet types added later */ 
    if (dlen<MIN_227_REPLY || dlen>MAX_227_REPLY) 
        return 0;
d309 2
a310 4
    a1=0; a2=0; a3=0; a4=0; p1=0; p2=0;
    state=-3;
    for (i=0; i<dlen; i++)
    {
d318 30
a347 25
        case 0 :
            if (isdigit(ch)) {a1=ch-'0'; state++;} break;
        case 1 :
            if (isdigit(ch)) a1=10*a1+ch-'0'; else state++; break;
        case 2 :
            if (isdigit(ch)) {a2=ch-'0'; state++;} break;
        case 3 :
            if (isdigit(ch)) a2=10*a2+ch-'0'; else state++; break;
        case 4 :
            if (isdigit(ch)) {a3=ch-'0'; state++;} break;
        case 5 :
            if (isdigit(ch)) a3=10*a3+ch-'0'; else state++; break;
        case 6 :
            if (isdigit(ch)) {a4=ch-'0'; state++;} break;
        case 7 :
            if (isdigit(ch)) a4=10*a4+ch-'0'; else state++; break;
        case 8 :
            if (isdigit(ch)) {p1=ch-'0'; state++;} break;
        case 9 :
            if (isdigit(ch)) p1=10*p1+ch-'0'; else state++; break;
        case 10:
            if (isdigit(ch)) {p2=ch-'0'; state++;} break;
        case 11:
            if (isdigit(ch)) p2=10*p2+ch-'0'; break;
        }
d350 3
a352 7
    if (state == 11 && GetLastLineCrlfTermed(link))
    {
        true_port = htons((p1<<8) + p2);
        true_addr.s_addr = htonl((a1<<24) + (a2<<16) +(a3<<8) + a4);
	if ((pip->ip_src.s_addr == true_addr.s_addr) &&
	    ((p1<<8) >= IPPORT_RESERVED))
		NewFtp227Reply(pip, link, true_addr, true_port, maxpacketsize);
d354 65
d420 5
a424 1
    else
d429 5
a433 7
NewFtpPortCommand(struct ip *pip,
                  struct alias_link *link,
                  struct in_addr true_addr,
                  u_short true_port,
                  int maxpacketsize,
                  int is_eprt)
{ 
d436 9
a444 1
/* Establish link to address and port found in PORT command */
d446 1
a446 1
                             true_port, 0, IPPROTO_TCP);
d454 5
a458 2
/* Punch hole in firewall */
        PunchFWHole(ftp_link);
d467 1
a467 1
/* Create new PORT command */
d469 1
a469 1
            char stemp[80];
d473 1
a473 1
            int a1, a2, a3, a4, p1, p2; 
d475 1
a475 1
        
d483 5
a487 6
	    if (is_eprt) {
/* Generate EPRT command string */
		sprintf(stemp, "EPRT |1|%d.%d.%d.%d|%d|\r\n",
			a1,a2,a3,a4,ntohs(alias_port));
	    } else {
/* Decompose alias port into pair format */
d491 21
a511 3
/* Generate PORT command string */
		sprintf(stemp, "PORT %d,%d,%d,%d,%d,%d\r\n",
			a1,a2,a3,a4,p1,p2);
d517 1
a517 90
/* Copy into IP packet */
            sptr = (char *) pip; sptr += hlen;
            strncpy(sptr, stemp, maxpacketsize-hlen);
        }

/* Save information regarding modified seq and ack numbers */
        {
            int delta;

            SetAckModified(link);
            delta = GetDeltaSeqOut(pip, link);
            AddSeq(pip, link, delta+slen-dlen);
        }

/* Revise IP header */
        {
            u_short new_len;

            new_len = htons(hlen + slen);
            DifferentialChecksum(&pip->ip_sum,
                                 &new_len,
                                 &pip->ip_len,
                                 1);
            pip->ip_len = new_len;
        }

/* Compute TCP checksum for revised packet */
        tc->th_sum = 0;
        tc->th_sum = TcpChecksum(pip);
    }
    else
    {
#ifdef DEBUG
        fprintf(stderr,
        "PacketAlias/HandleFtpOut, PORT: Cannot allocate FTP data port\n");
#endif
    }
}

static void
NewFtp227Reply(struct ip 	*pip,
            struct alias_link 	*link,
            struct in_addr 	true_addr,
            u_short 		true_port,
            int 		maxpacketsize)
{ 
    struct alias_link *ftp_link;

/* Establish link to address and port found in 227 reply */
    ftp_link = FindUdpTcpOut(true_addr, GetDestAddress(link),
                             true_port, 0, IPPROTO_TCP);

    if (ftp_link != NULL)
    {
        int slen, hlen, tlen, dlen;
        struct tcphdr *tc;

/* Calculate data length of TCP packet */
        tc = (struct tcphdr *) ((char *) pip + (pip->ip_hl << 2));
        hlen = (pip->ip_hl + tc->th_off) << 2;
        tlen = ntohs(pip->ip_len);
        dlen = tlen - hlen;

/* Create new 227 reply */
        {
            char stemp[MAX_227_REPLY+1];
            char *sptr;
            u_short alias_port;
            u_char *ptr;
            int a1, a2, a3, a4, p1, p2; 
            struct in_addr alias_address;
        
/* Decompose alias address into quad format */
            alias_address = GetAliasAddress(link);
            ptr = (u_char *) &alias_address.s_addr;
            a1 = *ptr++; a2=*ptr++; a3=*ptr++; a4=*ptr;

/* Decompose alias port into pair format */
            alias_port = GetAliasPort(ftp_link);
            ptr = (char *) &alias_port;
            p1 = *ptr++; p2=*ptr;

/* Generate command string */
            sprintf(stemp, "227 Entering Passive Mode (%d,%d,%d,%d,%d,%d)\r\n",
                     a1,a2,a3,a4,p1,p2);

/* Save string length for IP header modification */
            slen = strlen(stemp);

/* Copy modified buffer into IP packet */
d551 1
a551 1
        "PacketAlias/HandleFtpOut, 227: Cannot allocate FTP data port\n");
@


1.5
log
@Merge libalias stuff from FreeBSD:
Ppp only really benefits from a bunch of typo fixes, transparent pptp
support and ftp/EPRT support.
@
text
@d4 3
a6 2
    is sent, it is intercepted and modified.  The address is changed
    to the gateway machine and an aliasing port is used.
d8 1
a8 1
    For this routine to work, the PORT command must fit entirely
d13 1
a13 1
    that the new PORT command will typically be a different length, and
d41 3
d46 1
a46 1
    $OpenBSD: alias_ftp.c,v 1.4 2000/02/27 01:38:24 brian Exp $
d61 4
d69 2
a88 4
/* Return if data length is too long or too short */
    if (dlen<10 || dlen>80)
        return;

d93 2
d96 14
a109 2
    if (!ParseFtpPortCommand(sptr, dlen, pip, link, maxpacketsize))
	ParseFtpEprtCommand(sptr, dlen, pip, link, maxpacketsize);
d127 4
d170 1
a170 1
    if (state == 11)
d174 3
a176 1
	NewFtpPortCommand(pip, link, true_addr, true_port, maxpacketsize, 0);
d198 4
d259 1
a259 1
    if (state == 13)
d263 62
a324 1
	NewFtpPortCommand(pip, link, true_addr, true_port, maxpacketsize, 1);
d326 12
d437 90
a526 1
        "PacketAlias/HandleFtpOut: Cannot allocate FTP data port\n");
@


1.4
log
@$Id$ -> $OpenBSD$
@
text
@d17 4
d32 1
a32 1
         Differental checksum computation for change
d38 1
a38 1
         withing the packet alising module.
d42 1
a42 1
    $OpenBSD: alias_ftp.c,v 1.3 2000/01/07 03:26:52 brian Exp $
d57 3
a59 1
static void NewFtpPortCommand(struct ip *, struct alias_link *, struct in_addr, u_short, int);
a69 2
    struct in_addr true_addr;
    u_short true_port;
d79 1
a79 1
/* Return is data length is too long or too short */
d88 59
d148 80
a227 44
        char ch, zero;
        int i, state;
        u_long a1, a2, a3, a4;
        u_short p1, p2; 

        a1=0; a2=0; a3=0; a4=0; p1=0; p2=0;
        zero = '0';
        state=-4;
        for (i=0; i<dlen; i++)
        {
            ch = sptr[i];
            switch (state)
            {
                case -4: if (ch == 'P') state=-3; else return; break;
                case -3: if (ch == 'O') state=-2; else return; break;
                case -2: if (ch == 'R') state=-1; else return; break;
                case -1: if (ch == 'T') state= 0; else return; break;

                case 0 :
                    if (isdigit(ch)) {a1=ch-zero; state=1 ;} break;
                case 1 :
                    if (isdigit(ch)) a1=10*a1+ch-zero; else state=2 ; break;
                case 2 :
                    if (isdigit(ch)) {a2=ch-zero; state=3 ;} break;
                case 3 :
                    if (isdigit(ch)) a2=10*a2+ch-zero; else state=4 ; break;
                case 4 :
                    if (isdigit(ch)) {a3=ch-zero; state=5 ;} break;
                case 5 :
                    if (isdigit(ch)) a3=10*a3+ch-zero; else state=6 ; break;
                case 6 :
                    if (isdigit(ch)) {a4=ch-zero; state=7 ;} break;
                case 7 :
                    if (isdigit(ch)) a4=10*a4+ch-zero; else state=8 ; break;
                case 8 :
                    if (isdigit(ch)) {p1=ch-zero; state=9 ;} break;
                case 9 :
                    if (isdigit(ch)) p1=10*p1+ch-zero; else state=10; break;
                case 10:
                    if (isdigit(ch)) {p2=ch-zero; state=11;} break;
                case 11:
                    if (isdigit(ch)) p2=10*p2+ch-zero; break;
            }
        }
d229 5
a233 6
        if (state == 11)
        {
            true_port = htons((p1<<8) + p2);
            true_addr.s_addr = htonl((a1<<24) + (a2<<16) +(a3<<8) + a4);
            NewFtpPortCommand(pip, link, true_addr, true_port, maxpacketsize);
        }
d242 2
a243 1
                  int maxpacketsize)
d281 7
d289 7
a295 7
            alias_port = GetAliasPort(ftp_link);
            ptr = (char *) &alias_port;
            p1 = *ptr++; p2=*ptr;

/* Generate command string */
            sprintf(stemp, "PORT %d,%d,%d,%d,%d,%d\r\n",
                     a1,a2,a3,a4,p1,p2);
@


1.3
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d38 1
a38 1
    $Id$
@


1.2
log
@Remove all PacketAlias diagnostics to stdout/stderr with
#ifdef DEBUG.  Statify functions in alias_nbt.c
@
text
@d37 2
@


1.1
log
@Move libalias sources into the ppp directory.
Suggested (many times) by: Theo
@
text
@d224 1
d227 1
@

