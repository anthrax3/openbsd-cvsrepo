head	1.13;
access;
symbols
	OPENBSD_5_5:1.12.0.38
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.34
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.32
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.30
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.28
	OPENBSD_5_0:1.12.0.26
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.24
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.22
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.18
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.20
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.16
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.14
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.12
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.10
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.8
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.12
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.10
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.8
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.6
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2014.03.17.17.15.52;	author deraadt;	state dead;
branches;
next	1.12;

1.12
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.15.08.02.01;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.28.22.44.42;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.15.10.26.39;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.27.01.38.29;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.08.09.23.01.53;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.08.06.01.34.52;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.08.05.10.32.14;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.05.08.11.06.40;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.49;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.29;	author brian;	state Exp;
branches;
next	;


desc
@@


1.13
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1997 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: throughput.c,v 1.12 2005/07/17 19:13:25 brad Exp $
 */

#include <sys/types.h>

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <time.h>

#include "log.h"
#include "timer.h"
#include "throughput.h"
#include "descriptor.h"
#include "prompt.h"


void
throughput_init(struct pppThroughput *t, int period)
{
  t->OctetsIn = t->OctetsOut = t->PacketsIn = t->PacketsOut = 0;
  t->SamplePeriod = period;
  t->in.SampleOctets = (long long *)
    calloc(period, sizeof *t->in.SampleOctets);
  t->in.OctetsPerSecond = 0;
  t->out.SampleOctets = (long long *)
    calloc(period, sizeof *t->out.SampleOctets);
  t->out.OctetsPerSecond = 0;
  t->BestOctetsPerSecond = 0;
  t->nSample = 0;
  time(&t->BestOctetsPerSecondTime);
  memset(&t->Timer, '\0', sizeof t->Timer);
  t->Timer.name = "throughput";
  t->uptime = 0;
  t->downtime = 0;
  t->rolling = 0;
  t->callback.data = NULL;
  t->callback.fn = NULL;
  throughput_stop(t);
}

void
throughput_destroy(struct pppThroughput *t)
{
  if (t && t->in.SampleOctets) {
    throughput_stop(t);
    free(t->in.SampleOctets);
    free(t->out.SampleOctets);
    t->in.SampleOctets = NULL;
    t->out.SampleOctets = NULL;
  }
}

int
throughput_uptime(struct pppThroughput *t)
{
  time_t downat;

  downat = t->downtime ? t->downtime : time(NULL);
  if (t->uptime && downat < t->uptime) {
    /* Euch !  The clock's gone back ! */
    int i;

    for (i = 0; i < t->SamplePeriod; i++)
      t->in.SampleOctets[i] = t->out.SampleOctets[i] = 0;
    t->nSample = 0;
    t->uptime = downat;
  }
  return t->uptime ? downat - t->uptime : 0;
}

void
throughput_disp(struct pppThroughput *t, struct prompt *prompt)
{
  int secs_up, divisor;

  secs_up = throughput_uptime(t);
  prompt_Printf(prompt, "Connect time: %d:%02d:%02d", secs_up / 3600,
                (secs_up / 60) % 60, secs_up % 60);
  if (t->downtime)
    prompt_Printf(prompt, " - down at %s", ctime(&t->downtime));
  else
    prompt_Printf(prompt, "\n");

  divisor = secs_up ? secs_up : 1;
  prompt_Printf(prompt, "%llu octets in, %llu octets out\n",
                t->OctetsIn, t->OctetsOut);
  prompt_Printf(prompt, "%llu packets in, %llu packets out\n",
                t->PacketsIn, t->PacketsOut);
  if (t->rolling) {
    prompt_Printf(prompt, "  overall   %6qu bytes/sec\n",
                  (t->OctetsIn + t->OctetsOut) / divisor);
    prompt_Printf(prompt, "  %s %6qu bytes/sec in, %6qu bytes/sec out "
                  "(over the last %d secs)\n",
                  t->downtime ? "average  " : "currently",
                  t->in.OctetsPerSecond, t->out.OctetsPerSecond,
                  secs_up > t->SamplePeriod ? t->SamplePeriod : secs_up);
    prompt_Printf(prompt, "  peak      %6qu bytes/sec on %s",
                  t->BestOctetsPerSecond, ctime(&t->BestOctetsPerSecondTime));
  } else
    prompt_Printf(prompt, "Overall %llu bytes/sec\n",
                  (t->OctetsIn + t->OctetsOut) / divisor);
}


void
throughput_log(struct pppThroughput *t, int level, const char *title)
{
  if (t->uptime) {
    int secs_up;

    secs_up = throughput_uptime(t);
    if (title == NULL)
      title = "";
    log_Printf(level, "%s%sConnect time: %d secs: %llu octets in, %llu octets"
               " out\n", title, *title ? ": " : "", secs_up, t->OctetsIn,
               t->OctetsOut);
    log_Printf(level, "%s%s%llu packets in, %llu packets out\n",
               title, *title ? ": " : "",  t->PacketsIn, t->PacketsOut);
    if (secs_up == 0)
      secs_up = 1;
    if (t->rolling)
      log_Printf(level, " total %llu bytes/sec, peak %llu bytes/sec on %s",
                 (t->OctetsIn + t->OctetsOut) / secs_up, t->BestOctetsPerSecond,
                 ctime(&t->BestOctetsPerSecondTime));
    else
      log_Printf(level, " total %llu bytes/sec\n",
                 (t->OctetsIn + t->OctetsOut) / secs_up);
  }
}

static void
throughput_sampler(void *v)
{
  struct pppThroughput *t = (struct pppThroughput *)v;
  unsigned long long old;
  int uptime, divisor;
  unsigned long long octets;

  timer_Stop(&t->Timer);

  uptime = throughput_uptime(t);
  divisor = uptime < t->SamplePeriod ? uptime + 1 : t->SamplePeriod;

  old = t->in.SampleOctets[t->nSample];
  t->in.SampleOctets[t->nSample] = t->OctetsIn;
  t->in.OctetsPerSecond = (t->in.SampleOctets[t->nSample] - old) / divisor;

  old = t->out.SampleOctets[t->nSample];
  t->out.SampleOctets[t->nSample] = t->OctetsOut;
  t->out.OctetsPerSecond = (t->out.SampleOctets[t->nSample] - old) / divisor;

  octets = t->in.OctetsPerSecond + t->out.OctetsPerSecond;
  if (t->BestOctetsPerSecond < octets) {
    t->BestOctetsPerSecond = octets;
    time(&t->BestOctetsPerSecondTime);
  }

  if (++t->nSample == t->SamplePeriod)
    t->nSample = 0;

  if (t->callback.fn != NULL && uptime >= t->SamplePeriod)
    (*t->callback.fn)(t->callback.data);

  timer_Start(&t->Timer);
}

void
throughput_start(struct pppThroughput *t, const char *name, int rolling)
{
  int i;
  timer_Stop(&t->Timer);

  for (i = 0; i < t->SamplePeriod; i++)
    t->in.SampleOctets[i] = t->out.SampleOctets[i] = 0;
  t->nSample = 0;
  t->OctetsIn = t->OctetsOut = 0;
  t->in.OctetsPerSecond = t->out.OctetsPerSecond = t->BestOctetsPerSecond = 0;
  time(&t->BestOctetsPerSecondTime);
  t->downtime = 0;
  time(&t->uptime);
  throughput_restart(t, name, rolling);
}

void
throughput_restart(struct pppThroughput *t, const char *name, int rolling)
{
  timer_Stop(&t->Timer);
  t->rolling = rolling ? 1 : 0;
  if (t->rolling) {
    t->Timer.load = SECTICKS;
    t->Timer.func = throughput_sampler;
    t->Timer.name = name;
    t->Timer.arg = t;
    timer_Start(&t->Timer);
  } else {
    t->Timer.load = 0;
    t->Timer.func = NULL;
    t->Timer.name = NULL;
    t->Timer.arg = NULL;
  }
}

void
throughput_stop(struct pppThroughput *t)
{
  if (t->Timer.state != TIMER_STOPPED)
    time(&t->downtime);
  timer_Stop(&t->Timer);
}

void
throughput_addin(struct pppThroughput *t, long long n)
{
  t->OctetsIn += n;
  t->PacketsIn++;
}

void
throughput_addout(struct pppThroughput *t, long long n)
{
  t->OctetsOut += n;
  t->PacketsOut++;
}

void
throughput_clear(struct pppThroughput *t, int clear_type, struct prompt *prompt)
{
  if (clear_type & (THROUGHPUT_OVERALL|THROUGHPUT_CURRENT)) {
    int i;

    for (i = 0; i < t->SamplePeriod; i++)
      t->in.SampleOctets[i] = t->out.SampleOctets[i] = 0;
    t->nSample = 0;
  }

  if (clear_type & THROUGHPUT_OVERALL) {
    int divisor;

    if ((divisor = throughput_uptime(t)) == 0)
      divisor = 1;
    prompt_Printf(prompt, "overall cleared (was %6qu bytes/sec)\n",
                  (t->OctetsIn + t->OctetsOut) / divisor);
    t->OctetsIn = t->OctetsOut = 0;
    t->downtime = 0;
    time(&t->uptime);
  }

  if (clear_type & THROUGHPUT_CURRENT) {
    prompt_Printf(prompt, "current cleared (was %6qu bytes/sec in,"
                  " %6qu bytes/sec out)\n",
                  t->in.OctetsPerSecond, t->out.OctetsPerSecond);
    t->in.OctetsPerSecond = t->out.OctetsPerSecond = 0;
  }

  if (clear_type & THROUGHPUT_PEAK) {
    char *time_buf, *last;

    time_buf = ctime(&t->BestOctetsPerSecondTime);
    last = time_buf + strlen(time_buf);
    if (last > time_buf && *--last == '\n')
      *last = '\0';
    prompt_Printf(prompt, "peak    cleared (was %6qu bytes/sec on %s)\n",
                  t->BestOctetsPerSecond, time_buf);
    t->BestOctetsPerSecond = 0;
    time(&t->BestOctetsPerSecondTime);
  }
}

void
throughput_callback(struct pppThroughput *t, void (*fn)(void *), void *data)
{
  t->callback.fn = fn;
  t->callback.data = data;
}
@


1.12
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: throughput.c,v 1.11 2002/06/15 08:02:01 brian Exp $
@


1.11
log
@Tidy up end of line whitespace
@
text
@d26 1
a26 1
 *	$OpenBSD: throughput.c,v 1.10 2002/05/16 01:13:39 brian Exp $
d31 1
@


1.10
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: throughput.c,v 1.9 2000/08/28 22:44:42 brian Exp $
d88 2
a89 2
    int i; 
 
d273 1
a273 1
  } 
d290 1
a290 1
                  t->BestOctetsPerSecond, time_buf); 
@


1.9
log
@Support radius accounting, and add a packet count to throughput
statistics as a side effect.

Submitted by: Marcin Cieslak <saper@@system.pl>

with some tweaks to RAD_ACCT_SESSION_ID and
RAD_ACCT_MULTI_SESSION_ID generation by me.
@
text
@d26 1
a26 1
 *	$OpenBSD: throughput.c,v 1.8 2000/08/15 10:26:39 brian Exp $
d144 1
a144 1
    log_Printf(level, "%s%s: %llu packets in, %llu packets out\n",
@


1.8
log
@Maintain input and output throughput averages and choose the highest
of the two when calculating the MP throughput average for the ``set
autoload'' implementation.

This makes more sense as all links I know of are full-duplex.  This
also means that people may need to adjust their autoload settings
as 100% bandwidth is now the theoretical maximum rather than 200%
(but of course, halfing the current settings is probably not the
correct answer either!).

This involves a ppp version bump as we need to pass an extra
throughput array through the MP local domain socket.
@
text
@d26 1
a26 1
 *	$OpenBSD: throughput.c,v 1.7 2000/02/27 01:38:29 brian Exp $
d47 1
a47 1
  t->OctetsIn = t->OctetsOut = 0;
d114 2
d142 4
a145 2
                " out\n", title, *title ? ": " : "", secs_up, t->OctetsIn,
                t->OctetsOut);
d242 1
d249 1
@


1.7
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: throughput.c,v 1.6 1999/08/09 23:01:53 brian Exp $
d43 1
d49 7
a55 2
  t->SampleOctets = (long long *)calloc(period, sizeof *t->SampleOctets);
  t->OctetsPerSecond = t->BestOctetsPerSecond = 0;
d71 1
a71 1
  if (t && t->SampleOctets) {
d73 4
a76 2
    free(t->SampleOctets);
    t->SampleOctets = 0;
d91 1
a91 1
      t->SampleOctets[i] = 0;
d117 4
a120 3
    prompt_Printf(prompt, "  %s %6qu bytes/sec (over the last"
                  " %d secs)\n", t->downtime ? "average  " : "currently",
                  t->OctetsPerSecond,
d137 5
a141 6
    if (title)
      log_Printf(level, "%s: Connect time: %d secs: %llu octets in, %llu octets"
                " out\n", title, secs_up, t->OctetsIn, t->OctetsOut);
    else
      log_Printf(level, "Connect time: %d secs: %llu octets in,"
                 " %llu octets out\n", secs_up, t->OctetsIn, t->OctetsOut);
d160 1
d166 12
a177 5
  old = t->SampleOctets[t->nSample];
  t->SampleOctets[t->nSample] = t->OctetsIn + t->OctetsOut;
  t->OctetsPerSecond = (t->SampleOctets[t->nSample] - old) / divisor;
  if (t->BestOctetsPerSecond < t->OctetsPerSecond) {
    t->BestOctetsPerSecond = t->OctetsPerSecond;
d180 1
d197 1
a197 1
    t->SampleOctets[i] = 0;
d200 1
a200 1
  t->OctetsPerSecond = t->BestOctetsPerSecond = 0;
d253 1
a253 1
      t->SampleOctets[i] = 0;
d270 4
a273 3
    prompt_Printf(prompt, "current cleared (was %6qu bytes/sec)\n",
                  t->OctetsPerSecond);
    t->OctetsPerSecond = 0;
@


1.6
log
@Change printf formats %q[du] -> %ll[du]
@
text
@d26 1
a26 1
 *	$Id: throughput.c,v 1.5 1999/08/06 01:34:52 brian Exp $
@


1.5
log
@If the clock is put back, ensure that we don't end up dividing by
zero when calculating our throughput
@
text
@d26 1
a26 1
 *	$Id: throughput.c,v 1.4 1999/08/05 10:32:14 brian Exp $
d104 1
a104 1
  prompt_Printf(prompt, "%qu octets in, %qu octets out\n",
d116 1
a116 1
    prompt_Printf(prompt, "Overall %qu bytes/sec\n",
d129 1
a129 1
      log_Printf(level, "%s: Connect time: %d secs: %qu octets in, %qu octets"
d132 2
a133 2
      log_Printf(level, "Connect time: %d secs: %qu octets in,"
                 " %qu octets out\n", secs_up, t->OctetsIn, t->OctetsOut);
d137 1
a137 1
      log_Printf(level, " total %qu bytes/sec, peak %qu bytes/sec on %s",
d141 1
a141 1
      log_Printf(level, " total %qu bytes/sec\n",
@


1.4
log
@o Obsolete the undocumented ``set weight'' command.
o If we're using RADIUS and the RADIUS mtu is less than our
  peers mru/mrru, reduce our mtu to this value for NetBSD too.
o Make struct throughput's sample period dynamic and tweak the ppp
  version number to reflect the extra stuff being passed through
  the local domain socket as a result (MP mode).
o Measure the current throughput based on the number of samples actually
  taken rather than on the full sample period.
o Keep the throughput statisics persistent while being passed to
  another ppp invocation through the local domain socket.
o When showing throughput statistics after the timer has stopped, use
  the stopped time for overall calculations, not the current time.
  Also show the stopped time and how long the current throughput has
  been sampled for.
o Use time() consistently in throughput.c
o Tighten up the ``show bundle'' output.
o Introduce the ``set bandwidth'' command.
o Rewrite the ``set autoload'' command.  It now takes three arguments
  and works based on a rolling bundle throughput average compared against
  the theoretical bundle bandwidth over a given period (read: it's now
  functional).
@
text
@d26 1
a26 1
 *	$Id: throughput.c,v 1.3 1999/05/08 11:06:40 brian Exp $
d78 9
@


1.3
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: throughput.c,v 1.2 1999/02/06 03:22:49 brian Exp $
d32 1
d44 1
a44 1
throughput_init(struct pppThroughput *t)
a45 2
  int f;

d47 5
a51 4
  for (f = 0; f < SAMPLE_PERIOD; f++)
    t->SampleOctets[f] = 0;
  t->OctetsPerSecond = t->BestOctetsPerSecond = t->nSample = 0;
  t->BestOctetsPerSecondTime = time(NULL);
d55 1
d57 2
d63 19
d84 1
a84 1
  int secs_up;
d86 9
a94 4
  secs_up = t->uptime ? time(NULL) - t->uptime : 0;
  prompt_Printf(prompt, "Connect time: %d secs\n", secs_up);
  if (secs_up == 0)
    secs_up = 1;
d99 5
a103 2
                  (t->OctetsIn+t->OctetsOut)/secs_up);
    prompt_Printf(prompt, "  currently %6qu bytes/sec\n", t->OctetsPerSecond);
d108 1
a108 1
                  (t->OctetsIn+t->OctetsOut)/secs_up);
d118 1
a118 1
    secs_up = t->uptime ? time(NULL) - t->uptime : 0;
d123 2
a124 2
      log_Printf(level, "Connect time: %d secs: %qu octets in, %qu octets out\n",
                secs_up, t->OctetsIn, t->OctetsOut);
d129 2
a130 2
                (t->OctetsIn+t->OctetsOut)/secs_up, t->BestOctetsPerSecond,
                ctime(&t->BestOctetsPerSecondTime));
d133 1
a133 1
                (t->OctetsIn+t->OctetsOut)/secs_up);
d142 1
d146 2
d150 1
a150 1
  t->OctetsPerSecond = (t->SampleOctets[t->nSample] - old) / SAMPLE_PERIOD;
d153 1
a153 1
    t->BestOctetsPerSecondTime = time(NULL);
d155 1
a155 1
  if (++t->nSample == SAMPLE_PERIOD)
d158 3
d167 17
a184 1
  throughput_init(t);
a185 1
  time(&t->uptime);
d192 5
d203 2
d226 1
a226 1
    for (i = 0; i < SAMPLE_PERIOD; i++)
d232 1
a232 1
    int secs_up;
d234 2
a235 1
    secs_up = t->uptime ? time(NULL) - t->uptime : 1;
d237 1
a237 1
                  (t->OctetsIn + t->OctetsOut)/secs_up);
d239 2
a240 1
    t->uptime = time(NULL);
d257 1
a257 1
                   t->BestOctetsPerSecond, time_buf); 
d259 1
a259 1
    t->BestOctetsPerSecondTime = time(NULL);
d261 7
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: throughput.c,v 1.8 1998/06/12 20:12:26 brian Exp $
d68 1
a68 1
  prompt_Printf(prompt, "%ld octets in, %ld octets out\n",
d71 1
a71 1
    prompt_Printf(prompt, "  overall   %5ld bytes/sec\n",
d73 2
a74 2
    prompt_Printf(prompt, "  currently %5d bytes/sec\n", t->OctetsPerSecond);
    prompt_Printf(prompt, "  peak      %5d bytes/sec on %s",
d77 1
a77 1
    prompt_Printf(prompt, "Overall %ld bytes/sec\n",
d90 1
a90 1
      log_Printf(level, "%s: Connect time: %d secs: %ld octets in, %ld octets"
d93 1
a93 1
      log_Printf(level, "Connect time: %d secs: %ld octets in, %ld octets out\n",
d98 1
a98 1
      log_Printf(level, " total %ld bytes/sec, peak %d bytes/sec on %s",
d102 1
a102 1
      log_Printf(level, " total %ld bytes/sec\n",
d111 1
a111 1
  u_long old;
d151 1
a151 1
throughput_addin(struct pppThroughput *t, int n)
d157 1
a157 1
throughput_addout(struct pppThroughput *t, int n)
d177 1
a177 1
    prompt_Printf(prompt, "overall cleared (was %5ld bytes/sec)\n",
d184 1
a184 1
    prompt_Printf(prompt, "current cleared (was %5d bytes/sec)\n",
d196 1
a196 1
    prompt_Printf(prompt, "peak    cleared (was %5d bytes/sec on %s)\n",
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@@

