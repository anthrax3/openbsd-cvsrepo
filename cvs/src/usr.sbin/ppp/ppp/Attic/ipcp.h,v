head	1.14;
access;
symbols
	OPENBSD_5_5:1.13.0.54
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.50
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.48
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.46
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.44
	OPENBSD_5_0:1.13.0.42
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.40
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.38
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.34
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.36
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.32
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.30
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.28
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.26
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.24
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.22
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.20
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.18
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.16
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.14
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.12
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.10
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.8
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.6
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.13;

1.13
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.28.11.33.05;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.19.10.33.33;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.27.01.38.26;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.07.03.26.54;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.05.08.11.06.36;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.03.03.23.01.11;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.21.28.23;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.22.39;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.10.29.02.21.45;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.22;	author brian;	state Exp;
branches;
next	;


desc
@@


1.14
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: ipcp.h,v 1.13 2001/08/19 23:22:17 brian Exp $
 */

#define	IPCP_MAXCODE	CODE_CODEREJ

#define	TY_IPADDRS	1
#define	TY_COMPPROTO	2
#define	TY_IPADDR	3

/* Domain NameServer and NetBIOS NameServer options */

#define TY_PRIMARY_DNS		129
#define TY_PRIMARY_NBNS		130
#define TY_SECONDARY_DNS	131
#define TY_SECONDARY_NBNS	132
#define TY_ADJUST_NS		119 /* subtract from NS val for REJECT bit */

struct ipcp {
  struct fsm fsm;			/* The finite state machine */

  struct {
    struct {
      int slots;			/* Maximum VJ slots */
      unsigned slotcomp : 1;		/* Slot compression */
      unsigned neg : 2;			/* VJ negotiation */
    } vj;

    struct ncprange  my_range;		/* MYADDR spec */
    struct in_addr   netmask;		/* Iface netmask (unused by most OSs) */
    struct ncprange  peer_range;	/* HISADDR spec */
    struct iplist    peer_list;		/* Ranges of HISADDR values */

    struct in_addr   TriggerAddress;	/* Address to suggest in REQ */
    unsigned HaveTriggerAddress : 1;	/* Trigger address specified */

    struct {
      struct in_addr dns[2];		/* DNS addresses offered */
      unsigned dns_neg : 2;		/* dns negotiation */
      struct in_addr nbns[2];		/* NetBIOS NS addresses offered */
    } ns;

    struct fsm_retry fsm;		/* frequency to resend requests */
  } cfg;

  struct {
    struct slcompress cslc;		/* VJ state */
    struct slstat slstat;		/* VJ statistics */
  } vj;

  struct {
    unsigned resolver : 1;		/* Found resolv.conf ? */
    unsigned writable : 1;		/* Can write resolv.conf ? */
    struct in_addr dns[2];		/* Current DNS addresses */
    char *resolv;			/* Contents of resolv.conf */
    char *resolv_nons;			/* Contents of resolv.conf without ns */
  } ns;

  unsigned heis1172 : 1;		/* True if he is speaking rfc1172 */

  unsigned peer_req : 1;		/* Any TY_IPADDR REQs from the peer ? */
  struct in_addr peer_ip;		/* IP address he's willing to use */
  u_int32_t peer_compproto;		/* VJ params he's willing to use */

  struct in_addr ifmask;		/* Interface netmask */

  struct in_addr my_ip;			/* IP address I'm willing to use */
  u_int32_t my_compproto;		/* VJ params I'm willing to use */

  u_int32_t peer_reject;		/* Request codes rejected by peer */
  u_int32_t my_reject;			/* Request codes I have rejected */

  struct pppThroughput throughput;	/* throughput statistics */
  struct mqueue Queue[3];		/* Output packet queues */
};

#define fsm2ipcp(fp) (fp->proto == PROTO_IPCP ? (struct ipcp *)fp : NULL)
#define IPCP_QUEUES(ipcp) (sizeof ipcp->Queue / sizeof ipcp->Queue[0])

struct bundle;
struct link;
struct cmdargs;
struct iface_addr;

extern void ipcp_Init(struct ipcp *, struct bundle *, struct link *,
                      const struct fsm_parent *);
extern void ipcp_Destroy(struct ipcp *);
extern void ipcp_Setup(struct ipcp *, u_int32_t);
extern void ipcp_SetLink(struct ipcp *, struct link *);

extern int  ipcp_Show(struct cmdargs const *);
extern struct mbuf *ipcp_Input(struct bundle *, struct link *, struct mbuf *);
extern void ipcp_AddInOctets(struct ipcp *, int);
extern void ipcp_AddOutOctets(struct ipcp *, int);
extern int  ipcp_UseHisIPaddr(struct bundle *, struct in_addr);
extern int  ipcp_UseHisaddr(struct bundle *, const char *, int);
extern int  ipcp_vjset(struct cmdargs const *);
extern void ipcp_IfaceAddrAdded(struct ipcp *, const struct iface_addr *);
extern void ipcp_IfaceAddrDeleted(struct ipcp *, const struct iface_addr *);
extern int  ipcp_InterfaceUp(struct ipcp *);
extern struct in_addr addr2mask(struct in_addr);
extern int ipcp_WriteDNS(struct ipcp *);
extern void ipcp_RestoreDNS(struct ipcp *);
extern void ipcp_LoadDNS(struct ipcp *);
extern size_t ipcp_QueueLen(struct ipcp *);
extern int ipcp_PushPacket(struct ipcp *, struct link *);
@


1.13
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.h,v 1.12 2001/07/28 11:33:05 brian Exp $
@


1.12
log
@If the peer sends a REQ without the IPADDR option, only reject it
once.  If they repeat the request (again without the IPADDR option)
ACK it.
@
text
@d28 1
a28 1
 * $OpenBSD: ipcp.h,v 1.11 2001/06/13 21:33:41 brian Exp $
a44 14
struct sticky_route;

struct in_range {
  struct in_addr ipaddr;
  struct in_addr mask;
  int width;
};

struct port_range {
  unsigned nports;		/* How many ports */
  unsigned maxports;		/* How many allocated (malloc) ports */
  u_short *port;		/* The actual ports */
};

d55 1
a55 1
    struct in_range  my_range;		/* MYADDR spec */
d57 1
a57 1
    struct in_range  peer_range;	/* HISADDR spec */
a59 3
    u_long sendpipe;			/* route sendpipe size */
    u_long recvpipe;			/* route recvpipe size */

d69 1
a69 6
    struct {
      struct port_range tcp, udp;	/* The range of urgent ports */
      unsigned tos : 1;			/* Urgent IPTOS_LOWDELAY packets ? */
    } urgent;

    struct fsm_retry fsm;	/* How often/frequently to resend requests */
a84 2
  struct sticky_route *route;		/* List of dynamic routes */

a95 2
  struct in_addr dns[2];		/* DNSs to REQ/ACK */

d109 1
d124 2
a125 1
extern void ipcp_CleanInterface(struct ipcp *);
a126 4
extern int  ipcp_IsUrgentPort(struct port_range *, u_short, u_short);
extern void ipcp_AddUrgentPort(struct port_range *, u_short);
extern void ipcp_RemoveUrgentPort(struct port_range *, u_short);
extern void ipcp_ClearUrgentPorts(struct port_range *);
d131 2
a132 19

#define ipcp_IsUrgentTcpPort(ipcp, p1, p2) \
          ipcp_IsUrgentPort(&(ipcp)->cfg.urgent.tcp, p1, p2)
#define ipcp_IsUrgentUdpPort(ipcp, p1, p2) \
          ipcp_IsUrgentPort(&(ipcp)->cfg.urgent.udp, p1, p2)
#define ipcp_AddUrgentTcpPort(ipcp, p) \
          ipcp_AddUrgentPort(&(ipcp)->cfg.urgent.tcp, p)
#define ipcp_AddUrgentUdpPort(ipcp, p) \
          ipcp_AddUrgentPort(&(ipcp)->cfg.urgent.udp, p)
#define ipcp_RemoveUrgentTcpPort(ipcp, p) \
          ipcp_RemoveUrgentPort(&(ipcp)->cfg.urgent.tcp, p)
#define ipcp_RemoveUrgentUdpPort(ipcp, p) \
          ipcp_RemoveUrgentPort(&(ipcp)->cfg.urgent.udp, p)
#define ipcp_ClearUrgentTcpPorts(ipcp) \
          ipcp_ClearUrgentPorts(&(ipcp)->cfg.urgent.tcp)
#define ipcp_ClearUrgentUdpPorts(ipcp) \
          ipcp_ClearUrgentPorts(&(ipcp)->cfg.urgent.udp)
#define ipcp_ClearUrgentTOS(ipcp) (ipcp)->cfg.urgent.tos = 0;
#define ipcp_SetUrgentTOS(ipcp) (ipcp)->cfg.urgent.tos = 1;
@


1.11
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d111 1
@


1.10
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d1 5
a5 2
/*
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d7 8
a14 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d16 11
a26 11
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d28 1
a28 3
 * $OpenBSD: ipcp.h,v 1.9 2000/03/19 10:33:33 brian Exp $
 *
 *	TODO:
@


1.9
log
@Allow environment variables on command/config lines; markk@@knigma.org
Add the ``resolv'' command so that when ``enable dns''
is used, it's possible to restore the file.
@
text
@d18 1
a18 1
 * $OpenBSD: ipcp.h,v 1.8 2000/02/27 01:38:26 brian Exp $
d80 1
d167 2
@


1.8
log
@$Id$ -> $OpenBSD$
@
text
@d18 1
a18 1
 * $OpenBSD: ipcp.h,v 1.7 2000/01/07 03:26:54 brian Exp $
d90 8
d110 2
d146 3
@


1.7
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d18 1
a18 1
 * $Id: ipcp.h,v 1.6 1999/05/08 11:06:36 brian Exp $
@


1.6
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d18 1
a18 1
 * $Id: ipcp.h,v 1.5 1999/03/03 23:01:11 brian Exp $
d45 6
d78 4
d106 1
a106 1
  struct mqueue Queue[PRI_FAST + 1];	/* Output packet queues */
d110 1
d118 1
d131 4
d136 17
@


1.5
log
@Correct some ntohl/htonl bogons in the netmask handling.
This was pretty harmless as netmasks on a POINTOPOINT
interface are pretty much ignored, but it looked funny.

Mention the configured netmask in ``show ipcp''.

Describe in more detail what a proxy arp entry is.
@
text
@d18 1
a18 1
 * $Id: ipcp.h,v 1.4 1999/02/26 21:28:23 brian Exp $
d111 1
a111 1
extern void ipcp_Input(struct ipcp *, struct bundle *, struct mbuf *);
@


1.4
log
@Allow control over the number of ConfigREQ & TermREQ attempts
that are made in each of the FSMs (LCP, CCP & IPCP) and the
number of REQs/Challenges for PAP/CHAP by accepting more arguments
in the ``set {c,ip,l}cpretry'' and ``set {ch,p}apretry'' commands.

Change the non-convergence thresholds to 3 times the number of configured
REQ tries (rather than the previous fixed ``10'').  We now notice
repeated NAKs and REJs rather than just REQs.

Don't suggest that CHAP 0x05 isn't supported when it's not configured.

Fix some bugs that expose themselves with smaller numbers of retries:
o Handle instantaneous disconnects (set device /dev/null) correctly
  by stopping all fsm timers in fsm2initial.
o Don't forget to uu_unlock() devices that are files but are not
  ttys (set device /dev/zero).

Fix a *HORRENDOUS* bug in RFC1661 (already fixed for an Open event in state
``Closed''):
  According to the state transition table, a RCR+ or RCR- received in
  the ``Stopped'' state are supposed to InitRestartCounter, SendConfigReq
  and SendConfig{Ack,Nak}.  However, in ``Stopped'', we haven't yet
  done a TLS (or the last thing we did is a TLF).  We must therefore
  do the TLS at this point !

  This was never noticed before because LCP and CCP used not use
  LayerStart() for anything interesting, and IPCP tends to go into
  Stopped then get a Down because of an LCP RTR rather than getting a
  RCR again.
@
text
@d18 1
a18 1
 * $Id: ipcp.h,v 1.3 1999/02/06 03:22:39 brian Exp $
a36 8
#define addr2mask(addr) (			\
  IN_CLASSA(addr) ?				\
    htonl(IN_CLASSA_NET) :			\
  IN_CLASSB(addr) ?				\
    htonl(IN_CLASSB_NET) : htonl(IN_CLASSC_NET)	\
)


d119 1
@


1.3
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d18 1
a18 1
 * $Id: ipcp.h,v 1.23 1999/01/28 01:56:32 brian Exp $
d80 1
a80 1
    u_int fsmretry;			/* FSM retry frequency */
@


1.2
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d18 1
a18 1
 * $Id: ipcp.h,v 1.1 1998/08/31 00:22:22 brian Exp $
d37 8
d64 1
a64 1
    struct in_addr   netmask;		/* netmask (unused by most OSs) */
d95 2
d115 1
a115 1
extern void ipcp_Setup(struct ipcp *);
d122 1
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d18 1
a18 1
 * $Id: ipcp.h,v 1.20 1998/08/26 17:39:37 brian Exp $
d60 3
a91 3

  struct in_addr my_ifip;		/* My configured interface address */
  struct in_addr peer_ifip;		/* My congigured destination address */
@

