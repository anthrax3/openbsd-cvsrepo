head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.38
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.34
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.32
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.30
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.28
	OPENBSD_5_0:1.17.0.26
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.24
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.22
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.18
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.20
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.16
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.14
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.12
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.10
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.8
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.12
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.10
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.8
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.6
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2;
locks; strict;
comment	@ * @;


1.18
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.17;

1.17
date	2005.04.20.21.07.55;	author moritz;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.02.00.48.30;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.01.11.14.35;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.17.00.43.46;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.13.10.34.46;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.04.22.12.32;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.27.17.54.35;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.07.03.08.49;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.03.22.23.56;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.19.10.24.56;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.04.22.53.13;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.04.01.14.28;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.29.22.37.25;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.07.23.32.04;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.02.00.54.34;	author brian;	state Exp;
branches;
next	;


desc
@@


1.18
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 2000 Semen Ustimenko <semenu@@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: mppe.c,v 1.17 2005/04/20 21:07:55 moritz Exp $
 */

#include <sys/param.h>

#include <sys/socket.h>
#include <netinet/in_systm.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <sys/un.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <openssl/rc4.h>

#include "defs.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "fsm.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "ccp.h"
#include "throughput.h"
#include "layer.h"
#include "link.h"
#include "chap_ms.h"
#include "proto.h"
#include "mppe.h"
#include "ua.h"
#include "descriptor.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ncpaddr.h"
#include "iplist.h"
#include "slcompress.h"
#include "ipcp.h"
#include "ipv6cp.h"
#include "filter.h"
#include "mp.h"
#include "ncp.h"
#include "bundle.h"

/*
 * Documentation:
 *
 * draft-ietf-pppext-mppe-04.txt
 * draft-ietf-pppext-mppe-keys-02.txt
 */

#define	MPPE_OPT_STATELESS	0x1000000
#define	MPPE_OPT_COMPRESSED	0x01
#define	MPPE_OPT_40BIT		0x20
#define	MPPE_OPT_56BIT		0x80
#define	MPPE_OPT_128BIT		0x40
#define	MPPE_OPT_BITMASK	0xe0
#define	MPPE_OPT_MASK		(MPPE_OPT_STATELESS | MPPE_OPT_BITMASK)

#define	MPPE_FLUSHED			0x8000
#define	MPPE_ENCRYPTED			0x1000
#define	MPPE_HEADER_BITMASK		0xf000
#define	MPPE_HEADER_FLAG		0x00ff
#define	MPPE_HEADER_FLAGMASK		0x00ff
#define	MPPE_HEADER_FLAGSHIFT		8
#define	MPPE_HEADER_STATEFUL_KEYCHANGES	16

struct mppe_state {
  unsigned	stateless : 1;
  unsigned	flushnext : 1;
  unsigned	flushrequired : 1;
  int		cohnum;
  int		keylen;			/* 8 or 16 bytes */
  int 		keybits;		/* 40, 56 or 128 bits */
  char		sesskey[MPPE_KEY_LEN];
  char		mastkey[MPPE_KEY_LEN];
  RC4_KEY	rc4key;
};

int MPPE_MasterKeyValid = 0;
int MPPE_IsServer = 0;
char MPPE_MasterKey[MPPE_KEY_LEN];

/*
 * The peer has missed a packet.  Mark the next output frame to be FLUSHED
 */
static int
MPPEResetOutput(void *v)
{
  struct mppe_state *mop = (struct mppe_state *)v;

  if (mop->stateless)
    log_Printf(LogCCP, "MPPE: Unexpected output channel reset\n");
  else {
    log_Printf(LogCCP, "MPPE: Output channel reset\n");
    mop->flushnext = 1;
  }

  return 0;		/* Ask FSM not to ACK */
}

static void
MPPEReduceSessionKey(struct mppe_state *mp)
{
  switch(mp->keybits) {
  case 40:
    mp->sesskey[2] = 0x9e;
    mp->sesskey[1] = 0x26;
  case 56:
    mp->sesskey[0] = 0xd1;
  case 128:
    break;
  }
}

static void
MPPEKeyChange(struct mppe_state *mp)
{
  char InterimKey[MPPE_KEY_LEN];
  RC4_KEY RC4Key;

  GetNewKeyFromSHA(mp->mastkey, mp->sesskey, mp->keylen, InterimKey);
  RC4_set_key(&RC4Key, mp->keylen, InterimKey);
  RC4(&RC4Key, mp->keylen, InterimKey, mp->sesskey);

  MPPEReduceSessionKey(mp);
}

static struct mbuf *
MPPEOutput(void *v, struct ccp *ccp, struct link *l, int pri, u_short *proto,
           struct mbuf *mp)
{
  struct mppe_state *mop = (struct mppe_state *)v;
  struct mbuf *mo;
  u_short nproto, prefix;
  int dictinit, ilen, len;
  char *rp;

  ilen = m_length(mp);
  dictinit = 0;

  log_Printf(LogDEBUG, "MPPE: Output: Proto %02x (%d bytes)\n", *proto, ilen);
  if (*proto < 0x21 && *proto > 0xFA) {
    log_Printf(LogDEBUG, "MPPE: Output: Not encrypting\n");
    ccp->compout += ilen;
    ccp->uncompout += ilen;
    return mp;
  }

  log_DumpBp(LogDEBUG, "MPPE: Output: Encrypt packet:", mp);

  /* Get mbuf for prefixes */
  mo = m_get(4, MB_CCPOUT);
  mo->m_next = mp;

  rp = MBUF_CTOP(mo);
  prefix = MPPE_ENCRYPTED | mop->cohnum;

  if (mop->stateless ||
      (mop->cohnum & MPPE_HEADER_FLAGMASK) == MPPE_HEADER_FLAG) {
    /* Change our key */
    log_Printf(LogDEBUG, "MPPEOutput: Key changed [%d]\n", mop->cohnum);
    MPPEKeyChange(mop);
    dictinit = 1;
  }

  if (mop->stateless || mop->flushnext) {
    prefix |= MPPE_FLUSHED;
    dictinit = 1;
    mop->flushnext = 0;
  }

  if (dictinit) {
    /* Initialise our dictionary */
    log_Printf(LogDEBUG, "MPPEOutput: Dictionary initialised [%d]\n",
               mop->cohnum);
    RC4_set_key(&mop->rc4key, mop->keylen, mop->sesskey);
  }

  /* Set MPPE packet prefix */
  ua_htons(&prefix, rp);

  /* Save encrypted protocol number */
  nproto = htons(*proto);
  RC4(&mop->rc4key, 2, (char *)&nproto, rp + 2);

  /* Encrypt main packet */
  rp = MBUF_CTOP(mp);
  RC4(&mop->rc4key, ilen, rp, rp);

  mop->cohnum++;
  mop->cohnum &= ~MPPE_HEADER_BITMASK;

  /* Set the protocol number */
  *proto = ccp_Proto(ccp);
  len = m_length(mo);
  ccp->uncompout += ilen;
  ccp->compout += len;

  log_Printf(LogDEBUG, "MPPE: Output: Encrypted: Proto %02x (%d bytes)\n",
             *proto, len);

  return mo;
}

static void
MPPEResetInput(void *v)
{
  log_Printf(LogCCP, "MPPE: Unexpected input channel ack\n");
}

static struct mbuf *
MPPEInput(void *v, struct ccp *ccp, u_short *proto, struct mbuf *mp)
{
  struct mppe_state *mip = (struct mppe_state *)v;
  u_short prefix;
  char *rp;
  int dictinit, flushed, ilen, len, n;

  ilen = m_length(mp);
  dictinit = 0;
  ccp->compin += ilen;

  log_Printf(LogDEBUG, "MPPE: Input: Proto %02x (%d bytes)\n", *proto, ilen);
  log_DumpBp(LogDEBUG, "MPPE: Input: Packet:", mp);

  mp = mbuf_Read(mp, &prefix, 2);
  prefix = ntohs(prefix);
  flushed = prefix & MPPE_FLUSHED;
  prefix &= ~flushed;
  if ((prefix & MPPE_HEADER_BITMASK) != MPPE_ENCRYPTED) {
    log_Printf(LogERROR, "MPPE: Input: Invalid packet (flags = 0x%x)\n",
               (prefix & MPPE_HEADER_BITMASK) | flushed);
    m_freem(mp);
    return NULL;
  }

  prefix &= ~MPPE_HEADER_BITMASK;

  if (!flushed && mip->stateless) {
    log_Printf(LogCCP, "MPPEInput: Packet without MPPE_FLUSHED set"
               " in stateless mode\n");
    flushed = MPPE_FLUSHED;
    /* Should we really continue ? */
  }

  if (mip->stateless) {
    /* Change our key for each missed packet in stateless mode */
    while (prefix != mip->cohnum) {
      log_Printf(LogDEBUG, "MPPEInput: Key changed [%u]\n", prefix);
      MPPEKeyChange(mip);
      /*
       * mip->cohnum contains what we received last time in stateless
       * mode.
       */
      mip->cohnum++;
      mip->cohnum &= ~MPPE_HEADER_BITMASK;
    }
    dictinit = 1;
  } else {
    if (flushed) {
      /*
       * We can always process a flushed packet.
       * Catch up on any outstanding key changes.
       */
      n = (prefix >> MPPE_HEADER_FLAGSHIFT) -
          (mip->cohnum >> MPPE_HEADER_FLAGSHIFT);
      if (n < 0)
        n += MPPE_HEADER_STATEFUL_KEYCHANGES;
      while (n--) {
        log_Printf(LogDEBUG, "MPPEInput: Key changed during catchup [%u]\n",
                   prefix);
        MPPEKeyChange(mip);
      }
      mip->flushrequired = 0;
      mip->cohnum = prefix;
      dictinit = 1;
    }

    if (mip->flushrequired) {
      /*
       * Perhaps we should be lenient if
       * (prefix & MPPE_HEADER_FLAGMASK) == MPPE_HEADER_FLAG
       * The spec says that we shouldn't be though....
       */
      log_Printf(LogDEBUG, "MPPE: Not flushed - discarded\n");
      fsm_Output(&ccp->fsm, CODE_RESETREQ, ccp->fsm.reqid++, NULL, 0,
                 MB_CCPOUT);
      m_freem(mp);
      return NULL;
    }

    if (prefix != mip->cohnum) {
      /*
       * We're in stateful mode and didn't receive the expected
       * packet.  Send a reset request, but don't tell the CCP layer
       * about it as we don't expect to receive a Reset ACK !
       * Guess what... M$ invented this !
       */
      log_Printf(LogCCP, "MPPE: Input: Got seq %u, not %u\n",
                 prefix, mip->cohnum);
      fsm_Output(&ccp->fsm, CODE_RESETREQ, ccp->fsm.reqid++, NULL, 0,
                 MB_CCPOUT);
      mip->flushrequired = 1;
      m_freem(mp);
      return NULL;
    }

    if ((prefix & MPPE_HEADER_FLAGMASK) == MPPE_HEADER_FLAG) {
      log_Printf(LogDEBUG, "MPPEInput: Key changed [%u]\n", prefix);
      MPPEKeyChange(mip);
      dictinit = 1;
    } else if (flushed)
      dictinit = 1;

    /*
     * mip->cohnum contains what we expect to receive next time in stateful
     * mode.
     */
    mip->cohnum++;
    mip->cohnum &= ~MPPE_HEADER_BITMASK;
  }

  if (dictinit) {
    log_Printf(LogDEBUG, "MPPEInput: Dictionary initialised [%u]\n", prefix);
    RC4_set_key(&mip->rc4key, mip->keylen, mip->sesskey);
  }

  mp = mbuf_Read(mp, proto, 2);
  RC4(&mip->rc4key, 2, (char *)proto, (char *)proto);
  *proto = ntohs(*proto);

  rp = MBUF_CTOP(mp);
  len = m_length(mp);
  RC4(&mip->rc4key, len, rp, rp);

  log_Printf(LogDEBUG, "MPPEInput: Decrypted: Proto %02x (%d bytes)\n",
             *proto, len);
  log_DumpBp(LogDEBUG, "MPPEInput: Decrypted: Packet:", mp);

  ccp->uncompin += len;

  return mp;
}

static void
MPPEDictSetup(void *v, struct ccp *ccp, u_short proto, struct mbuf *mi)
{
}

static const char *
MPPEDispOpts(struct fsm_opt *o)
{
  static char buf[70];
  u_int32_t val;
  char ch;
  int len, n;

  ua_ntohl(o->data, &val);
  len = 0;
  n = snprintf(buf, sizeof buf, "value 0x%08x ", (unsigned)val);
  if (n == 0)
    return buf;
  if (n >= sizeof buf)
    n = sizeof buf - 1;
  if (n > 0)
    len += n;
  if (!(val & MPPE_OPT_BITMASK)) {
    n = snprintf(buf + len, sizeof buf - len, "(0");
    if (n == 0)
      return buf;
    if (n >= sizeof buf - len)
      n = sizeof buf - len - 1;
    if (n > 0)
      len += n;
  } else {
    ch = '(';
    if (val & MPPE_OPT_128BIT) {
      n = snprintf(buf + len, sizeof buf - len, "%c128", ch);
      if (n == 0)
        return buf;
      if (n >= sizeof buf - len)
        n = sizeof buf - len - 1;
      if (n > 0)
        len += n;
      ch = '/';
    }
    if (val & MPPE_OPT_56BIT) {
      n = snprintf(buf + len, sizeof buf - len, "%c56", ch);
      if (n == 0)
        return buf;
      if (n >= sizeof buf - len)
        n = sizeof buf - len - 1;
      if (n > 0)
        len += n;
      ch = '/';
    }
    if (val & MPPE_OPT_40BIT) {
      n = snprintf(buf + len, sizeof buf - len, "%c40", ch);
      if (n == 0)
        return buf;
      if (n >= sizeof buf - len)
        n = sizeof buf - len - 1;
      if (n > 0)
        len += n;
      ch = '/';
    }
  }

  n = snprintf(buf + len, sizeof buf - len, " bits, state%s",
                    (val & MPPE_OPT_STATELESS) ? "less" : "ful");
  if (n == 0)
    return buf;
  if (n >= sizeof buf - len)
    n = sizeof buf - len - 1;
  if (n > 0)
    len += n;

  if (val & MPPE_OPT_COMPRESSED) {
    n = snprintf(buf + len, sizeof buf - len, ", compressed");
    if (n == 0)
      return buf;
    if (n >= sizeof buf - len)
      n = sizeof buf - len - 1;
    if (n > 0)
      len += n;
  }

  snprintf(buf + len, sizeof buf - len, ")");

  return buf;
}

static int
MPPEUsable(struct fsm *fp)
{
  int ok;
#ifndef NORADIUS
  struct radius *r = &fp->bundle->radius;

  /*
   * If the radius server gave us RAD_MICROSOFT_MS_MPPE_ENCRYPTION_TYPES,
   * use that instead of our configuration value.
   */
  if (*r->cfg.file) {
    ok = r->mppe.sendkeylen && r->mppe.recvkeylen;
    if (!ok)
      log_Printf(LogCCP, "MPPE: Not permitted by RADIUS server\n");
  } else
#endif
  {
    struct lcp *lcp = &fp->link->lcp;
    ok = (lcp->want_auth == PROTO_CHAP && lcp->want_authtype == 0x81) ||
         (lcp->his_auth == PROTO_CHAP && lcp->his_authtype == 0x81);
    if (!ok)
      log_Printf(LogCCP, "MPPE: Not usable without CHAP81\n");
  }

  return ok;
}

static int
MPPERequired(struct fsm *fp)
{
#ifndef NORADIUS
  /*
   * If the radius server gave us RAD_MICROSOFT_MS_MPPE_ENCRYPTION_POLICY,
   * use that instead of our configuration value.
   */
  if (*fp->bundle->radius.cfg.file && fp->bundle->radius.mppe.policy)
    return fp->bundle->radius.mppe.policy == MPPE_POLICY_REQUIRED ? 1 : 0;
#endif

  return fp->link->ccp.cfg.mppe.required;
}

static u_int32_t
MPPE_ConfigVal(struct bundle *bundle, const struct ccp_config *cfg)
{
  u_int32_t val;

  val = cfg->mppe.state == MPPE_STATELESS ? MPPE_OPT_STATELESS : 0;
#ifndef NORADIUS
  /*
   * If the radius server gave us RAD_MICROSOFT_MS_MPPE_ENCRYPTION_TYPES,
   * use that instead of our configuration value.
   */
  if (*bundle->radius.cfg.file && bundle->radius.mppe.types) {
    if (bundle->radius.mppe.types & MPPE_TYPE_40BIT)
      val |= MPPE_OPT_40BIT;
    if (bundle->radius.mppe.types & MPPE_TYPE_128BIT)
      val |= MPPE_OPT_128BIT;
  } else
#endif
    switch(cfg->mppe.keybits) {
    case 128:
      val |= MPPE_OPT_128BIT;
      break;
    case 56:
      val |= MPPE_OPT_56BIT;
      break;
    case 40:
      val |= MPPE_OPT_40BIT;
      break;
    case 0:
      val |= MPPE_OPT_128BIT | MPPE_OPT_56BIT | MPPE_OPT_40BIT;
      break;
    }

  return val;
}

/*
 * What options should we use for our first configure request
 */
static void
MPPEInitOptsOutput(struct bundle *bundle, struct fsm_opt *o,
                   const struct ccp_config *cfg)
{
  u_int32_t mval;

  o->hdr.len = 6;

  if (!MPPE_MasterKeyValid) {
    log_Printf(LogCCP, "MPPE: MasterKey is invalid,"
               " MPPE is available only with CHAP81 authentication\n");
    ua_htonl(0x0, o->data);
    return;
  }


  mval = MPPE_ConfigVal(bundle, cfg);
  ua_htonl(&mval, o->data);
}

/*
 * Our CCP request was NAK'd with the given options
 */
static int
MPPESetOptsOutput(struct bundle *bundle, struct fsm_opt *o,
                  const struct ccp_config *cfg)
{
  u_int32_t mval, peer;

  ua_ntohl(o->data, &peer);

  if (!MPPE_MasterKeyValid)
    /* Treat their NAK as a REJ */
    return MODE_NAK;

  mval = MPPE_ConfigVal(bundle, cfg);

  /*
   * If we haven't been configured with a specific number of keybits, allow
   * whatever the peer asks for.
   */
  if (!cfg->mppe.keybits) {
    mval &= ~MPPE_OPT_BITMASK;
    mval |= (peer & MPPE_OPT_BITMASK);
    if (!(mval & MPPE_OPT_BITMASK))
      mval |= MPPE_OPT_128BIT;
  }

  /* Adjust our statelessness */
  if (cfg->mppe.state == MPPE_ANYSTATE) {
    mval &= ~MPPE_OPT_STATELESS;
    mval |= (peer & MPPE_OPT_STATELESS);
  }

  ua_htonl(&mval, o->data);

  return MODE_ACK;
}

/*
 * The peer has requested the given options
 */
static int
MPPESetOptsInput(struct bundle *bundle, struct fsm_opt *o,
                 const struct ccp_config *cfg)
{
  u_int32_t mval, peer;
  int res = MODE_ACK;

  ua_ntohl(o->data, &peer);
  if (!MPPE_MasterKeyValid) {
    if (peer != 0) {
      peer = 0;
      ua_htonl(&peer, o->data);
      return MODE_NAK;
    } else
      return MODE_ACK;
  }

  mval = MPPE_ConfigVal(bundle, cfg);

  if (peer & ~MPPE_OPT_MASK)
    /* He's asking for bits we don't know about */
    res = MODE_NAK;

  if (peer & MPPE_OPT_STATELESS) {
    if (cfg->mppe.state == MPPE_STATEFUL)
      /* Peer can't have stateless */
      res = MODE_NAK;
    else
      /* Peer wants stateless, that's ok */
      mval |= MPPE_OPT_STATELESS;
  } else {
    if (cfg->mppe.state == MPPE_STATELESS)
      /* Peer must have stateless */
      res = MODE_NAK;
    else
      /* Peer doesn't want stateless, that's ok */
      mval &= ~MPPE_OPT_STATELESS;
  }

  /* If we've got a configured number of keybits - the peer must use that */
  if (cfg->mppe.keybits) {
    ua_htonl(&mval, o->data);
    return peer == mval ? res : MODE_NAK;
  }

  /* If a specific number of bits hasn't been requested, we'll need to NAK */
  switch (peer & MPPE_OPT_BITMASK) {
  case MPPE_OPT_128BIT:
  case MPPE_OPT_56BIT:
  case MPPE_OPT_40BIT:
    break;
  default:
    res = MODE_NAK;
  }

  /* Suggest the best number of bits */
  mval &= ~MPPE_OPT_BITMASK;
  if (peer & MPPE_OPT_128BIT)
    mval |= MPPE_OPT_128BIT;
  else if (peer & MPPE_OPT_56BIT)
    mval |= MPPE_OPT_56BIT;
  else if (peer & MPPE_OPT_40BIT)
    mval |= MPPE_OPT_40BIT;
  else
    mval |= MPPE_OPT_128BIT;
  ua_htonl(&mval, o->data);

  return res;
}

static struct mppe_state *
MPPE_InitState(struct fsm_opt *o)
{
  struct mppe_state *mp;
  u_int32_t val;

  if ((mp = calloc(1, sizeof *mp)) != NULL) {
    ua_ntohl(o->data, &val);

    switch (val & MPPE_OPT_BITMASK) {
    case MPPE_OPT_128BIT:
      mp->keylen = 16;
      mp->keybits = 128;
      break;
    case MPPE_OPT_56BIT:
      mp->keylen = 8;
      mp->keybits = 56;
      break;
    case MPPE_OPT_40BIT:
      mp->keylen = 8;
      mp->keybits = 40;
      break;
    default:
      log_Printf(LogWARN, "Unexpected MPPE options 0x%08x\n", val);
      free(mp);
      return NULL;
    }

    mp->stateless = !!(val & MPPE_OPT_STATELESS);
  }

  return mp;
}

static void *
MPPEInitInput(struct bundle *bundle, struct fsm_opt *o)
{
  struct mppe_state *mip;

  if (!MPPE_MasterKeyValid) {
    log_Printf(LogWARN, "MPPE: Cannot initialise without CHAP81\n");
    return NULL;
  }

  if ((mip = MPPE_InitState(o)) == NULL) {
    log_Printf(LogWARN, "MPPEInput: Cannot initialise - unexpected options\n");
    return NULL;
  }

  log_Printf(LogDEBUG, "MPPE: InitInput: %d-bits\n", mip->keybits);

#ifndef NORADIUS
  if (*bundle->radius.cfg.file && bundle->radius.mppe.recvkey) {
    if (mip->keylen > bundle->radius.mppe.recvkeylen)
      mip->keylen = bundle->radius.mppe.recvkeylen;
    if (mip->keylen > sizeof mip->mastkey)
      mip->keylen = sizeof mip->mastkey;
    memcpy(mip->mastkey, bundle->radius.mppe.recvkey, mip->keylen);
  } else
#endif
    GetAsymetricStartKey(MPPE_MasterKey, mip->mastkey, mip->keylen, 0,
                         MPPE_IsServer);

  GetNewKeyFromSHA(mip->mastkey, mip->mastkey, mip->keylen, mip->sesskey);

  MPPEReduceSessionKey(mip);

  log_Printf(LogCCP, "MPPE: Input channel initiated\n");

  if (!mip->stateless) {
    /*
     * We need to initialise our dictionary here as the first packet we
     * receive is unlikely to have the FLUSHED bit set.
     */
    log_Printf(LogDEBUG, "MPPEInitInput: Dictionary initialised [%d]\n",
               mip->cohnum);
    RC4_set_key(&mip->rc4key, mip->keylen, mip->sesskey);
  } else {
    /*
     * We do the first key change here as the first packet is expected
     * to have a sequence number of 0 and we'll therefore not expect
     * to have to change the key at that point.
     */
    log_Printf(LogDEBUG, "MPPEInitInput: Key changed [%d]\n", mip->cohnum);
    MPPEKeyChange(mip);
  }

  return mip;
}

static void *
MPPEInitOutput(struct bundle *bundle, struct fsm_opt *o)
{
  struct mppe_state *mop;

  if (!MPPE_MasterKeyValid) {
    log_Printf(LogWARN, "MPPE: Cannot initialise without CHAP81\n");
    return NULL;
  }

  if ((mop = MPPE_InitState(o)) == NULL) {
    log_Printf(LogWARN, "MPPEOutput: Cannot initialise - unexpected options\n");
    return NULL;
  }

  log_Printf(LogDEBUG, "MPPE: InitOutput: %d-bits\n", mop->keybits);

#ifndef NORADIUS
  if (*bundle->radius.cfg.file && bundle->radius.mppe.sendkey) {
    if (mop->keylen > bundle->radius.mppe.sendkeylen)
      mop->keylen = bundle->radius.mppe.sendkeylen;
    if (mop->keylen > sizeof mop->mastkey)
      mop->keylen = sizeof mop->mastkey;
    memcpy(mop->mastkey, bundle->radius.mppe.sendkey, mop->keylen);
  } else
#endif
    GetAsymetricStartKey(MPPE_MasterKey, mop->mastkey, mop->keylen, 1,
                         MPPE_IsServer);

  GetNewKeyFromSHA(mop->mastkey, mop->mastkey, mop->keylen, mop->sesskey);

  MPPEReduceSessionKey(mop);

  log_Printf(LogCCP, "MPPE: Output channel initiated\n");

  if (!mop->stateless) {
    /*
     * We need to initialise our dictionary now as the first packet we
     * send won't have the FLUSHED bit set.
     */
    log_Printf(LogDEBUG, "MPPEInitOutput: Dictionary initialised [%d]\n",
               mop->cohnum);
    RC4_set_key(&mop->rc4key, mop->keylen, mop->sesskey);
  }

  return mop;
}

static void
MPPETermInput(void *v)
{
  free(v);
}

static void
MPPETermOutput(void *v)
{
  free(v);
}

const struct ccp_algorithm MPPEAlgorithm = {
  TY_MPPE,
  CCP_NEG_MPPE,
  MPPEDispOpts,
  MPPEUsable,
  MPPERequired,
  {
    MPPESetOptsInput,
    MPPEInitInput,
    MPPETermInput,
    MPPEResetInput,
    MPPEInput,
    MPPEDictSetup
  },
  {
    2,
    MPPEInitOptsOutput,
    MPPESetOptsOutput,
    MPPEInitOutput,
    MPPETermOutput,
    MPPEResetOutput,
    MPPEOutput
  },
};
@


1.17
log
@be more careful with snprintf. ok cloder@@ deraadt@@
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.16 2002/07/02 00:48:30 brian Exp $
@


1.16
log
@Don't trust the MPPE key lengths passed back from the RADIUS server.
Instead, use the correct values based on the number of bits actually
negotiated.
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.15 2002/07/01 11:14:35 brian Exp $
d389 6
a394 1
  if ((n = snprintf(buf, sizeof buf, "value 0x%08x ", (unsigned)val)) > 0)
d397 6
a402 1
    if ((n = snprintf(buf + len, sizeof buf - len, "(0")) > 0)
d407 6
a412 1
      if ((n = snprintf(buf + len, sizeof buf - len, "%c128", ch)) > 0)
d417 6
a422 1
      if ((n = snprintf(buf + len, sizeof buf - len, "%c56", ch)) > 0)
d427 6
a432 1
      if ((n = snprintf(buf + len, sizeof buf - len, "%c40", ch)) > 0)
d438 7
a444 2
  if ((n = snprintf(buf + len, sizeof buf - len, " bits, state%s",
                    (val & MPPE_OPT_STATELESS) ? "less" : "ful")) > 0)
d448 6
a453 1
    if ((n = snprintf(buf + len, sizeof buf - len, ", compressed")) > 0)
@


1.15
log
@Don't allow the use of MPPE with RADIUS unless the RADIUS server has provided
keys.
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.14 2002/06/15 01:33:23 brian Exp $
d694 2
a695 1
    mip->keylen = bundle->radius.mppe.recvkeylen;
d750 2
a751 1
    mop->keylen = bundle->radius.mppe.sendkeylen;
@


1.14
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.13 2002/05/17 00:43:46 brian Exp $
a429 1
  struct lcp *lcp;
d431 2
d434 17
a450 5
  lcp = &fp->link->lcp;
  ok = (lcp->want_auth == PROTO_CHAP && lcp->want_authtype == 0x81) ||
       (lcp->his_auth == PROTO_CHAP && lcp->his_authtype == 0x81);
  if (!ok)
    log_Printf(LogCCP, "MPPE: Not usable without CHAP81\n");
@


1.13
log
@Put back <string.h>
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.12 2002/05/16 01:13:39 brian Exp $
d29 1
a29 1
#include <sys/types.h>
d31 2
a32 1
#ifdef __FreeBSD__
d34 2
a35 1
#endif
d59 13
d445 9
d458 1
a458 1
MPPE_ConfigVal(const struct ccp_config *cfg)
d463 26
a488 14
  switch(cfg->mppe.keybits) {
  case 128:
    val |= MPPE_OPT_128BIT;
    break;
  case 56:
    val |= MPPE_OPT_56BIT;
    break;
  case 40:
    val |= MPPE_OPT_40BIT;
    break;
  case 0:
    val |= MPPE_OPT_128BIT | MPPE_OPT_56BIT | MPPE_OPT_40BIT;
    break;
  }
d497 2
a498 1
MPPEInitOptsOutput(struct fsm_opt *o, const struct ccp_config *cfg)
d511 2
a512 1
  mval = MPPE_ConfigVal(cfg);
d520 2
a521 1
MPPESetOptsOutput(struct fsm_opt *o, const struct ccp_config *cfg)
d531 1
a531 1
  mval = MPPE_ConfigVal(cfg);
d559 2
a560 1
MPPESetOptsInput(struct fsm_opt *o, const struct ccp_config *cfg)
d575 1
a575 1
  mval = MPPE_ConfigVal(cfg);
d663 1
a663 1
MPPEInitInput(struct fsm_opt *o)
d679 11
a689 2
  GetAsymetricStartKey(MPPE_MasterKey, mip->mastkey, mip->keylen, 0,
                       MPPE_IsServer);
d718 1
a718 1
MPPEInitOutput(struct fsm_opt *o)
d734 11
a744 2
  GetAsymetricStartKey(MPPE_MasterKey, mop->mastkey, mop->keylen, 1,
                       MPPE_IsServer);
@


1.12
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.11 2002/03/13 10:34:46 brian Exp $
d37 1
@


1.11
log
@Use the return value from snprintf() to keep a track of the length of
the display string in MPPEDispOpts.
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.10 2001/09/04 22:12:32 brian Exp $
d31 4
a36 1
#include <string.h>
a37 5
#ifdef __FreeBSD__
#include <sha.h>
#else
#include <openssl/sha.h>
#endif
d124 1
d364 1
a364 1
MPPEDispOpts(struct lcp_opt *o)
d460 1
a460 1
MPPEInitOptsOutput(struct lcp_opt *o, const struct ccp_config *cfg)
d464 1
a464 1
  o->len = 6;
d481 1
a481 1
MPPESetOptsOutput(struct lcp_opt *o, const struct ccp_config *cfg)
d519 1
a519 1
MPPESetOptsInput(struct lcp_opt *o, const struct ccp_config *cfg)
d588 1
a588 1
MPPE_InitState(struct lcp_opt *o)
d622 1
a622 1
MPPEInitInput(struct lcp_opt *o)
d668 1
a668 1
MPPEInitOutput(struct lcp_opt *o)
@


1.10
log
@Consider alignment requirements when moving data about.

Mostly submitted by:	kamath@@cesa.opbu.xerox.com
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.9 2001/08/27 17:54:35 brian Exp $
d370 1
a370 1
  int len;
d373 3
a375 2
  snprintf(buf, sizeof buf, "value 0x%08x ", (unsigned)val);
  len = strlen(buf);
d377 2
a378 2
    snprintf(buf + len, sizeof buf - len, "(0");
    len++;
d382 2
a383 2
      snprintf(buf + len, sizeof buf - len, "%c128", ch);
      len += strlen(buf + len);
d387 2
a388 2
      snprintf(buf + len, sizeof buf - len, "%c56", ch);
      len += strlen(buf + len);
d392 2
a393 2
      snprintf(buf + len, sizeof buf - len, "%c40", ch);
      len += strlen(buf + len);
d398 3
a400 3
  snprintf(buf + len, sizeof buf - len, " bits, state%s",
           (val & MPPE_OPT_STATELESS) ? "less" : "ful");
  len += strlen(buf + len);
d403 2
a404 2
    snprintf(buf + len, sizeof buf - len, ", compressed");
    len += strlen(buf + len);
@


1.9
log
@Send a reset request for every packet received when our encryption
dictionaries are out of sync.

This avoids the complications that happen when our original reset
request gets lost in transit (quite likely in hind sight, given a
lossy link) when we end up ignoring the peer for the next (up to)
256 packets.
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.8 2001/07/07 03:08:49 brian Exp $
d57 1
d194 1
a194 1
  *(u_short *)rp = htons(prefix);
d368 1
a368 1
  u_int32_t val = ntohl(*(u_int32_t *)o->data);
d372 1
d462 1
a462 1
  u_int32_t *p = (u_int32_t *)o->data;
d469 1
a469 1
    *p = htonl(0x0);
d473 2
a474 1
  *p = htonl(MPPE_ConfigVal(cfg));
d483 3
a485 3
  u_int32_t *p = (u_int32_t *)o->data;
  u_int32_t peer = ntohl(*p);
  u_int32_t mval;
d510 1
a510 1
  *p = htonl(mval);
d521 1
a521 3
  u_int32_t *p = (u_int32_t *)(o->data);
  u_int32_t peer = ntohl(*p);
  u_int32_t mval;
d524 1
d526 3
a528 2
    if (*p != 0x0) {
      *p = 0x0;
d558 1
a558 1
    *p = htonl(mval);
d582 1
a582 1
  *p = htonl(mval);
d594 1
a594 1
    val = ntohl(*(u_int32_t *)o->data);
@


1.8
log
@When we miss one or more packets in stateful mode *and* need to
perform a key change, *and* our sequence numbers have wrapped,
ensure that the number of key changes is calculated correctly.

The previous code counted down from a negative number to zero,
re-encrypting the current key on each iteration - this took some
time and strangely enough got the answer wrong !!!

Spell stateful correctly while I'm here.
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.7 2001/07/03 22:23:56 brian Exp $
d299 2
@


1.7
log
@Reduce the interface MTU by 2 when MPPE has been successfully negotiated.

This is necessary because MPPE will combine the protocol id with the
payload received on the tun interface, encrypt it, then prepend its
own protocol id, effectively increasing the payload by two bytes.
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.6 2001/06/19 10:24:56 brian Exp $
d73 7
a79 6
#define	MPPE_FLUSHED		0x8000
#define	MPPE_ENCRYPTED		0x1000
#define	MPPE_HEADER_BITMASK	0xf000
#define	MPPE_HEADER_FLAG	0x00ff
#define	MPPE_HEADER_FLAGMASK	0x00ff
#define	MPPE_HEADER_FLAGSHIFT	8
d280 2
d394 1
a394 1
           (val & MPPE_OPT_STATELESS) ? "less" : "full");
@


1.6
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.5 2001/02/04 22:53:13 brian Exp $
d724 1
@


1.5
log
@Add a ``Usable'' function to the ccp switch.  The function
is called prior to sending a CCP configure request for a
given protocol.  The default is to send the request, but
this is overridden for MPPE which checks to see if the lcp
negotiations agreed CHAP81, and if not fails.

Use the same function to decide if we should reject peer
requests for MPPE.

This should get rid of those boring messages about not being
able to initialise MPPE when we don't negotiate CHAP81.
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.4 2001/02/04 01:14:28 brian Exp $
d33 1
d65 15
d81 9
a89 6
	int	cohnum;
	int	keylen;			/* 8 or 16 bytes */
	int 	keybits;		/* 40, 56 or 128 bits */
	char	sesskey[MPPE_KEY_LEN];
	char	mastkey[MPPE_KEY_LEN];
	RC4_KEY	rc4key;
d96 4
a99 1
static void
d102 10
a111 1
  log_Printf(LogCCP, "MPPE: Output channel reset\n");
d146 2
a147 2
  u_short nproto;
  int ilen;
a149 2
  log_Printf(LogCCP, "MPPE: Output\n");

d151 1
d156 2
d167 23
a189 2
  /* Init RC4 keys */
  RC4_set_key(&mop->rc4key, mop->keylen, mop->sesskey);
d192 1
a192 2
  rp = MBUF_CTOP(mo);
  *(u_short *)rp = htons(0x9000 | mop->cohnum);
d202 2
a203 3
  /* Rotate keys */
  MPPEKeyChange(mop);
  mop->cohnum ++; mop->cohnum &= 0xFFF;
d205 1
a205 1
  /* Chage protocol number */
d207 3
d212 1
a212 1
             *proto, m_length(mo));
d220 1
a220 1
  log_Printf(LogCCP, "MPPE: Input channel reset\n");
d229 1
a229 3
  int ilen;

  log_Printf(LogCCP, "MPPE: Input\n");
d232 2
a235 1

d240 5
a244 2
  if ((prefix & 0xF000) != 0x9000) {
    log_Printf(LogERROR, "MPPE: Input: Invalid packet\n");
d249 85
a333 4
  prefix &= 0xFFF;
  while (prefix != mip->cohnum) {
    MPPEKeyChange(mip);
    mip->cohnum ++; mip->cohnum &= 0xFFF;
a335 2
  RC4_set_key(&mip->rc4key, mip->keylen, mip->sesskey);

d341 2
a342 1
  RC4(&mip->rc4key, m_length(mp), rp, rp);
d344 3
a346 2
  log_Printf(LogDEBUG, "MPPE: Input: Decrypted: Proto %02x (%d bytes)\n",
             *proto, m_length(mp));
d348 1
a348 1
  log_DumpBp(LogDEBUG, "MPPE: Input: Decrypted: Packet:", mp);
a355 1
  log_Printf(LogCCP, "MPPE: DictSetup\n");
d361 40
a400 2
  static char buf[32];
  sprintf(buf, "value 0x%08x", (int)ntohl(*(u_int32_t *)(o->data)));
d419 33
d455 1
a455 1
  u_long val;
a458 2
  log_Printf(LogCCP, "MPPE: InitOptsOutput\n");

d462 1
a462 1
    *(u_int32_t *)o->data = htonl(0x0);
d466 1
a466 10
  val = 0x1000000;
  switch(cfg->mppe.keybits) {
  case 128:
    val |= 0x40; break;
  case 56:
    val |= 0x80; break;
  case 40:
    val |= 0x20; break;
  }
  *(u_int32_t *)o->data = htonl(val);
d469 3
d473 1
a473 1
MPPESetOptsOutput(struct lcp_opt *o)
d475 25
a499 12
  u_long *p = (u_long *)(o->data);
  u_long val = ntohl(*p);

  log_Printf(LogCCP, "MPPE: SetOptsOutput\n");

  if (!MPPE_MasterKeyValid) {
    if (*p != 0x0) {
      *p = 0x0;
      return MODE_NAK;
    } else {
      return MODE_ACK;
    }
d502 1
a502 4
  if (val == 0x01000020 ||
      val == 0x01000040 ||
      val == 0x01000080)
    return MODE_ACK;
d504 1
a504 1
  return MODE_NAK;
d507 3
d513 4
a516 5
  u_long *p = (u_long *)(o->data);
  u_long val = ntohl(*p);
  u_long mval;

  log_Printf(LogCCP, "MPPE: SetOptsInput\n");
d522 1
a522 1
    } else {
a523 1
    }
d526 58
a583 9
  mval = 0x01000000;
  switch(cfg->mppe.keybits) {
  case 128:
    mval |= 0x40; break;
  case 56:
    mval |= 0x80; break;
  case 40:
    mval |= 0x20; break;
  }
d585 21
a605 2
  if (val == mval)
    return MODE_ACK;
d607 2
a608 1
  *p = htonl(mval);
d610 1
a610 1
  return MODE_NAK;
a616 3
  u_int32_t val = ntohl(*(unsigned long *)o->data);

  log_Printf(LogCCP, "MPPE: InitInput\n");
d623 3
a625 12
  mip = malloc(sizeof(*mip));
  memset(mip, 0, sizeof(*mip));

  if (val & 0x20) {		/* 40-bits */
    mip->keylen = 8;
    mip->keybits = 40;
  } else if (val & 0x80) {	/* 56-bits */
    mip->keylen = 8;
    mip->keybits = 56;
  } else {			/* 128-bits */
    mip->keylen = 16;
    mip->keybits = 128;
d636 1
a636 1
  MPPEKeyChange(mip);
d638 17
a654 1
  mip->cohnum = 0;
a662 3
  u_int32_t val = ntohl(*(unsigned long *)o->data);

  log_Printf(LogCCP, "MPPE: InitOutput\n");
d669 3
a671 12
  mop = malloc(sizeof(*mop));
  memset(mop, 0, sizeof(*mop));

  if (val & 0x20) {		/* 40-bits */
    mop->keylen = 8;
    mop->keybits = 40;
  } else if (val & 0x80) {	/* 56-bits */
    mop->keylen = 8;
    mop->keybits = 56;
  } else {			/* 128-bits */
    mop->keylen = 16;
    mop->keybits = 128;
d682 1
a682 1
  MPPEKeyChange(mop);
d684 9
a692 1
  mop->cohnum = 0;
a699 1
  log_Printf(LogCCP, "MPPE: TermInput\n");
a705 1
  log_Printf(LogCCP, "MPPE: TermOutput\n");
d714 1
@


1.4
log
@Make the MPPE MasterKey Invalid messages a bit clearer (it now
complains that you can't do MPPE without CHAP81).

Reset MasterKeyValid to zero when we hit phase DEAD.
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.3 2000/12/29 22:37:25 brian Exp $
d50 3
d54 1
d230 15
d436 1
@


1.3
log
@Log the ``MPPE: MasterKey is invalid...'' message as a CCP
diagnostic rather than a warning.
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.2 2000/11/07 23:32:04 brian Exp $
d237 1
a237 1
               " MPPE is capable only with CHAP81 authentication\n");
d324 1
a324 1
    log_Printf(LogERROR, "MPPE: InitInput: MasterKey is invalid!!!!\n");
d366 1
a366 1
    log_Printf(LogERROR, "MPPE: InitOutput: MasterKey is invalid!!!!\n");
@


1.2
log
@Pass the correct option data to the compression modules Init function
rather than the data associated with the first protocol REQuested.

Initiate MPPE session keys correctly based on whether we're client
or server
@
text
@d26 1
a26 1
 * $OpenBSD: mppe.c,v 1.1 2000/11/02 00:54:34 brian Exp $
d236 1
a236 1
    log_Printf(LogWARN, "MPPE: MasterKey is invalid,"
@


1.1
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d26 1
a26 1
 * $OpenBSD$
d70 1
d344 2
a345 1
  GetAsymetricStartKey(MPPE_MasterKey, mip->mastkey, mip->keylen, 0, 0);
d386 2
a387 1
  GetAsymetricStartKey(MPPE_MasterKey, mop->mastkey, mop->keylen, 1, 0);
@

