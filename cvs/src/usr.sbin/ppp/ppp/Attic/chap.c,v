head	1.43;
access;
symbols
	OPENBSD_5_5:1.42.0.6
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.41.0.32
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.30
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.28
	OPENBSD_5_0:1.41.0.26
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.24
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.22
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.18
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.20
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.41.0.16
	OPENBSD_4_5_BASE:1.41
	OPENBSD_4_4:1.41.0.14
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.12
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.10
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.41.0.8
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.41.0.6
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.41.0.4
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.40.0.6
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.40.0.4
	OPENBSD_3_6_BASE:1.40
	OPENBSD_3_5:1.40.0.2
	OPENBSD_3_5_BASE:1.40
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	OPENBSD_3_3:1.36.0.4
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.36.0.2
	OPENBSD_3_2_BASE:1.36
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_9:1.26.0.2
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.43
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.42;

1.42
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.09.01.45.08;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.23.03.48.43;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.08.19.55.52;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.07.23.58.53;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.04.20.25.06;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.17.01.14.08;	author brian;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.15.01.33.23;	author brian;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.16.14.27.21;	author brian;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.31.21.37.15;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.31.12.11.28;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.13.21.33.40;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.01.22.41.23;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.07.23.32.04;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.02.00.54.33;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.18.00.02.10;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.09.19.31.25;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.19.11.06.31;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.27.01.38.25;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.27.00.21.06;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.07.03.26.53;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	99.08.17.15.00.38;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	99.07.15.02.10.31;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	99.06.09.08.47.23;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	99.06.02.15.58.40;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.05.08.11.06.34;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.04.21.08.07.24;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.04.19.16.59.39;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.02.20.01.15.12;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.02.18.19.46.19;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.02.18.19.12.10;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.02.18.00.50.44;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.02.11.10.14.49;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.02.07.13.56.19;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.07.13.48.33;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.32;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.17;	author brian;	state Exp;
branches;
next	;


desc
@@


1.43
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: chap.c,v 1.42 2013/04/29 00:28:23 okan Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#ifndef NODES
#include <md4.h>
#endif
#include <md5.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "mbuf.h"
#include "log.h"
#include "defs.h"
#include "timer.h"
#include "fsm.h"
#include "proto.h"
#include "lqr.h"
#include "hdlc.h"
#include "lcp.h"
#include "auth.h"
#include "async.h"
#include "throughput.h"
#include "descriptor.h"
#include "chap.h"
#include "iplist.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "ccp.h"
#include "link.h"
#include "physical.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "chat.h"
#include "cbcp.h"
#include "command.h"
#include "datalink.h"
#ifndef NODES
#include "chap_ms.h"
#include "mppe.h"
#endif
#include "id.h"

static const char * const chapcodes[] = {
  "???", "CHALLENGE", "RESPONSE", "SUCCESS", "FAILURE"
};
#define MAXCHAPCODE (sizeof chapcodes / sizeof chapcodes[0] - 1)

static void
ChapOutput(struct physical *physical, u_int code, u_int id,
	   const u_char *ptr, int count, const char *text)
{
  int plen;
  struct fsmheader lh;
  struct mbuf *bp;

  plen = sizeof(struct fsmheader) + count;
  lh.code = code;
  lh.id = id;
  lh.length = htons(plen);
  bp = m_get(plen, MB_CHAPOUT);
  memcpy(MBUF_CTOP(bp), &lh, sizeof(struct fsmheader));
  if (count)
    memcpy(MBUF_CTOP(bp) + sizeof(struct fsmheader), ptr, count);
  log_DumpBp(LogDEBUG, "ChapOutput", bp);
  if (text == NULL)
    log_Printf(LogPHASE, "Chap Output: %s\n", chapcodes[code]);
  else
    log_Printf(LogPHASE, "Chap Output: %s (%s)\n", chapcodes[code], text);
  link_PushPacket(&physical->link, bp, physical->dl->bundle,
                  LINK_QUEUES(&physical->link) - 1, PROTO_CHAP);
}

static char *
chap_BuildAnswer(char *name, char *key, u_char id, char *challenge, u_char type
#ifndef NODES
                 , char *peerchallenge, char *authresponse, int lanman
#endif
                )
{
  char *result, *digest;
  size_t nlen, klen;

  nlen = strlen(name);
  klen = strlen(key);

#ifndef NODES
  if (type == 0x80) {
    char expkey[AUTHLEN << 2];
    MD4_CTX MD4context;
    int f;

    if ((result = malloc(1 + nlen + MS_CHAP_RESPONSE_LEN)) == NULL)
      return result;

    digest = result;					/* the response */
    *digest++ = MS_CHAP_RESPONSE_LEN;			/* 49 */
    memcpy(digest + MS_CHAP_RESPONSE_LEN, name, nlen);
    if (lanman) {
      memset(digest + 24, '\0', 25);
      mschap_LANMan(digest, challenge + 1, key);	/* LANMan response */
    } else {
      memset(digest, '\0', 25);
      digest += 24;

      for (f = 0; f < klen; f++) {
        expkey[2*f] = key[f];
        expkey[2*f+1] = '\0';
      }
      /*
       *           -----------
       * expkey = | k\0e\0y\0 |
       *           -----------
       */
      MD4Init(&MD4context);
      MD4Update(&MD4context, expkey, klen << 1);
      MD4Final(digest, &MD4context);

      /*
       *           ---- -------- ---------------- ------- ------
       * result = | 49 | LANMan | 16 byte digest | 9 * ? | name |
       *           ---- -------- ---------------- ------- ------
       */
      mschap_NT(digest, challenge + 1);
    }
    /*
     *           ---- -------- ------------- ----- ------
     *          |    |  struct MS_ChapResponse24  |      |
     * result = | 49 | LANMan  |  NT digest | 0/1 | name |
     *           ---- -------- ------------- ----- ------
     * where only one of LANMan & NT digest are set.
     */
  } else if (type == 0x81) {
    char expkey[AUTHLEN << 2];
    char pwdhash[CHAP81_HASH_LEN];
    char pwdhashhash[CHAP81_HASH_LEN];
    char *ntresponse;
    int f;

    if ((result = malloc(1 + nlen + CHAP81_RESPONSE_LEN)) == NULL)
      return result;

    memset(result, 0, 1 + nlen + CHAP81_RESPONSE_LEN);

    digest = result;
    *digest++ = CHAP81_RESPONSE_LEN;		/* value size */

    /* Copy our challenge */
    memcpy(digest, peerchallenge + 1, CHAP81_CHALLENGE_LEN);

    /* Expand password to Unicode XXX */
    for (f = 0; f < klen; f++) {
      expkey[2*f] = key[f];
      expkey[2*f+1] = '\0';
    }

    ntresponse = digest + CHAP81_NTRESPONSE_OFF;

    /* Get some needed hashes */
    NtPasswordHash(expkey, klen * 2, pwdhash);
    HashNtPasswordHash(pwdhash, pwdhashhash);

    /* Generate NTRESPONSE to respond on challenge call */
    GenerateNTResponse(challenge + 1, peerchallenge + 1, name, nlen,
                       expkey, klen * 2, ntresponse);

    /* Generate MPPE MASTERKEY */
    GetMasterKey(pwdhashhash, ntresponse, MPPE_MasterKey);    /* XXX Global ! */

    /* Generate AUTHRESPONSE to verify on auth success */
    GenerateAuthenticatorResponse(expkey, klen * 2, ntresponse,
                                  peerchallenge + 1, challenge + 1, name, nlen,
                                  authresponse);

    authresponse[CHAP81_AUTHRESPONSE_LEN] = 0;

    memcpy(digest + CHAP81_RESPONSE_LEN, name, nlen);
  } else
#endif
  if ((result = malloc(nlen + 17)) != NULL) {
    /* Normal MD5 stuff */
    MD5_CTX MD5context;

    digest = result;
    *digest++ = 16;				/* value size */

    MD5Init(&MD5context);
    MD5Update(&MD5context, &id, 1);
    MD5Update(&MD5context, key, klen);
    MD5Update(&MD5context, challenge + 1, *challenge);
    MD5Final(digest, &MD5context);

    memcpy(digest + 16, name, nlen);
    /*
     *           ---- -------- ------
     * result = | 16 | digest | name |
     *           ---- -------- ------
     */
  }

  return result;
}

static void
chap_StartChild(struct chap *chap, char *prog, const char *name)
{
  char *argv[MAXARGS], *nargv[MAXARGS];
  int argc, fd;
  int in[2], out[2];
  pid_t pid;

  if (chap->child.fd != -1) {
    log_Printf(LogWARN, "Chap: %s: Program already running\n", prog);
    return;
  }

  if (pipe(in) == -1) {
    log_Printf(LogERROR, "Chap: pipe: %s\n", strerror(errno));
    return;
  }

  if (pipe(out) == -1) {
    log_Printf(LogERROR, "Chap: pipe: %s\n", strerror(errno));
    close(in[0]);
    close(in[1]);
    return;
  }

  pid = getpid();
  switch ((chap->child.pid = fork())) {
    case -1:
      log_Printf(LogERROR, "Chap: fork: %s\n", strerror(errno));
      close(in[0]);
      close(in[1]);
      close(out[0]);
      close(out[1]);
      chap->child.pid = 0;
      return;

    case 0:
      timer_TermService();

      if ((argc = command_Interpret(prog, strlen(prog), argv)) <= 0) {
        if (argc < 0) {
          log_Printf(LogWARN, "CHAP: Invalid command syntax\n");
          _exit(255);
        }
        _exit(0);
      }

      close(in[1]);
      close(out[0]);
      if (out[1] == STDIN_FILENO)
        out[1] = dup(out[1]);
      dup2(in[0], STDIN_FILENO);
      dup2(out[1], STDOUT_FILENO);
      close(STDERR_FILENO);
      if (open(_PATH_DEVNULL, O_RDWR) != STDERR_FILENO) {
        log_Printf(LogALERT, "Chap: Failed to open %s: %s\n",
                  _PATH_DEVNULL, strerror(errno));
        exit(1);
      }
      /* XXX using an fwalk()-like thing would be safer */
      for (fd = getdtablesize(); fd > STDERR_FILENO; fd--)
        fcntl(fd, F_SETFD, FD_CLOEXEC);
#ifndef NOSUID
      setuid(ID0realuid());
#endif
      command_Expand(nargv, argc, (char const *const *)argv,
                     chap->auth.physical->dl->bundle, 0, pid);
      execvp(nargv[0], nargv);
      printf("exec() of %s failed: %s\n", nargv[0], strerror(errno));
      _exit(255);

    default:
      close(in[0]);
      close(out[1]);
      chap->child.fd = out[0];
      chap->child.buf.len = 0;
      write(in[1], chap->auth.in.name, strlen(chap->auth.in.name));
      write(in[1], "\n", 1);
      write(in[1], chap->challenge.peer + 1, *chap->challenge.peer);
      write(in[1], "\n", 1);
      write(in[1], name, strlen(name));
      write(in[1], "\n", 1);
      close(in[1]);
      break;
  }
}

static void
chap_Cleanup(struct chap *chap, int sig)
{
  if (chap->child.pid) {
    int status;

    close(chap->child.fd);
    chap->child.fd = -1;
    if (sig)
      kill(chap->child.pid, SIGTERM);
    chap->child.pid = 0;
    chap->child.buf.len = 0;

    if (wait(&status) == -1)
      log_Printf(LogERROR, "Chap: wait: %s\n", strerror(errno));
    else if (WIFSIGNALED(status))
      log_Printf(LogWARN, "Chap: Child received signal %d\n", WTERMSIG(status));
    else if (WIFEXITED(status) && WEXITSTATUS(status))
      log_Printf(LogERROR, "Chap: Child exited %d\n", WEXITSTATUS(status));
  }
  *chap->challenge.local = *chap->challenge.peer = '\0';
#ifndef NODES
  chap->peertries = 0;
#endif
}

static void
chap_Respond(struct chap *chap, char *name, char *key, u_char type
#ifndef NODES
             , int lm
#endif
            )
{
  u_char *ans;

  ans = chap_BuildAnswer(name, key, chap->auth.id, chap->challenge.peer, type
#ifndef NODES
                         , chap->challenge.local, chap->authresponse, lm
#endif
                        );

  if (ans) {
    ChapOutput(chap->auth.physical, CHAP_RESPONSE, chap->auth.id,
               ans, *ans + 1 + strlen(name), name);
#ifndef NODES
    chap->NTRespSent = !lm;
    MPPE_IsServer = 0;		/* XXX Global ! */
#endif
    free(ans);
  } else
    ChapOutput(chap->auth.physical, CHAP_FAILURE, chap->auth.id,
               "Out of memory!", 14, NULL);
}

static int
chap_UpdateSet(struct fdescriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
{
  struct chap *chap = descriptor2chap(d);

  if (r && chap && chap->child.fd != -1) {
    FD_SET(chap->child.fd, r);
    if (*n < chap->child.fd + 1)
      *n = chap->child.fd + 1;
    log_Printf(LogTIMER, "Chap: fdset(r) %d\n", chap->child.fd);
    return 1;
  }

  return 0;
}

static int
chap_IsSet(struct fdescriptor *d, const fd_set *fdset)
{
  struct chap *chap = descriptor2chap(d);

  return chap && chap->child.fd != -1 && FD_ISSET(chap->child.fd, fdset);
}

static void
chap_Read(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  struct chap *chap = descriptor2chap(d);
  int got;

  got = read(chap->child.fd, chap->child.buf.ptr + chap->child.buf.len,
             sizeof chap->child.buf.ptr - chap->child.buf.len - 1);
  if (got == -1) {
    log_Printf(LogERROR, "Chap: Read: %s\n", strerror(errno));
    chap_Cleanup(chap, SIGTERM);
  } else if (got == 0) {
    log_Printf(LogWARN, "Chap: Read: Child terminated connection\n");
    chap_Cleanup(chap, SIGTERM);
  } else {
    char *name, *key, *end;

    chap->child.buf.len += got;
    chap->child.buf.ptr[chap->child.buf.len] = '\0';
    name = chap->child.buf.ptr;
    name += strspn(name, " \t");
    if ((key = strchr(name, '\n')) == NULL)
      end = NULL;
    else
      end = strchr(++key, '\n');

    if (end == NULL) {
      if (chap->child.buf.len == sizeof chap->child.buf.ptr - 1) {
        log_Printf(LogWARN, "Chap: Read: Input buffer overflow\n");
        chap_Cleanup(chap, SIGTERM);
      }
    } else {
#ifndef NODES
      int lanman = chap->auth.physical->link.lcp.his_authtype == 0x80 &&
                   ((chap->NTRespSent &&
                     IsAccepted(chap->auth.physical->link.lcp.cfg.chap80lm)) ||
                    !IsAccepted(chap->auth.physical->link.lcp.cfg.chap80nt));
#endif

      while (end >= name && strchr(" \t\r\n", *end))
        *end-- = '\0';
      end = key - 1;
      while (end >= name && strchr(" \t\r\n", *end))
        *end-- = '\0';
      key += strspn(key, " \t");

      chap_Respond(chap, name, key, chap->auth.physical->link.lcp.his_authtype
#ifndef NODES
                   , lanman
#endif
                  );
      chap_Cleanup(chap, 0);
    }
  }
}

static int
chap_Write(struct fdescriptor *d, struct bundle *bundle, const fd_set *fdset)
{
  /* We never want to write here ! */
  log_Printf(LogALERT, "chap_Write: Internal error: Bad call !\n");
  return 0;
}

static void
chap_ChallengeInit(struct authinfo *authp)
{
  struct chap *chap = auth2chap(authp);
  int len, i;
  char *cp;

  len = strlen(authp->physical->dl->bundle->cfg.auth.name);

  if (!*chap->challenge.local) {
    randinit();
    cp = chap->challenge.local;

#ifndef NORADIUS
    if (*authp->physical->dl->bundle->radius.cfg.file) {
      /* For radius, our challenge is 16 readable NUL terminated bytes :*/
      *cp++ = 16;
      for (i = 0; i < 16; i++)
        *cp++ = (random() % 10) + '0';
    } else
#endif
    {
#ifndef NODES
      if (authp->physical->link.lcp.want_authtype == 0x80)
        *cp++ = 8;	/* MS does 8 byte callenges :-/ */
      else if (authp->physical->link.lcp.want_authtype == 0x81)
        *cp++ = 16;	/* MS-CHAP-V2 does 16 bytes challenges */
      else
#endif
        *cp++ = random() % (CHAPCHALLENGELEN-16) + 16;
      for (i = 0; i < *chap->challenge.local; i++)
        *cp++ = random() & 0xff;
    }
    memcpy(cp, authp->physical->dl->bundle->cfg.auth.name, len);
  }
}

static void
chap_Challenge(struct authinfo *authp)
{
  struct chap *chap = auth2chap(authp);
  int len;

  log_Printf(LogDEBUG, "CHAP%02X: Challenge\n",
             authp->physical->link.lcp.want_authtype);

  len = strlen(authp->physical->dl->bundle->cfg.auth.name);

  /* Generate new local challenge value */
  if (!*chap->challenge.local)
    chap_ChallengeInit(authp);

#ifndef NODES
  if (authp->physical->link.lcp.want_authtype == 0x81)
    ChapOutput(authp->physical, CHAP_CHALLENGE, authp->id,
             chap->challenge.local, 1 + *chap->challenge.local, NULL);
  else
#endif
    ChapOutput(authp->physical, CHAP_CHALLENGE, authp->id,
             chap->challenge.local, 1 + *chap->challenge.local + len, NULL);
}

static void
chap_Success(struct authinfo *authp)
{
  struct bundle *bundle = authp->physical->dl->bundle;
  const char *msg;

  datalink_GotAuthname(authp->physical->dl, authp->in.name);
#ifndef NODES
  if (authp->physical->link.lcp.want_authtype == 0x81) {
#ifndef NORADIUS
    if (*bundle->radius.cfg.file && bundle->radius.msrepstr)
      msg = bundle->radius.msrepstr;
    else
#endif
      msg = auth2chap(authp)->authresponse;
    MPPE_MasterKeyValid = 1;		/* XXX Global ! */
  } else
#endif
#ifndef NORADIUS
  if (*bundle->radius.cfg.file && bundle->radius.repstr)
    msg = bundle->radius.repstr;
  else
#endif
    msg = "Welcome!!";

  ChapOutput(authp->physical, CHAP_SUCCESS, authp->id, msg, strlen(msg),
             NULL);

  authp->physical->link.lcp.auth_ineed = 0;
  if (Enabled(bundle, OPT_UTMP))
    physical_Login(authp->physical, authp->in.name);

  if (authp->physical->link.lcp.auth_iwait == 0)
    /*
     * Either I didn't need to authenticate, or I've already been
     * told that I got the answer right.
     */
    datalink_AuthOk(authp->physical->dl);
}

static void
chap_Failure(struct authinfo *authp)
{
#ifndef NODES
  char buf[1024], *ptr;
#endif
  const char *msg;

#ifndef NORADIUS
  struct bundle *bundle = authp->physical->link.lcp.fsm.bundle;
  if (*bundle->radius.cfg.file && bundle->radius.errstr)
    msg = bundle->radius.errstr;
  else
#endif
#ifndef NODES
  if (authp->physical->link.lcp.want_authtype == 0x80) {
    snprintf(buf, sizeof buf, "E=691 R=1 M=Invalid!");
    msg = buf;
  } else if (authp->physical->link.lcp.want_authtype == 0x81) {
    int i;

    ptr = buf;
    snprintf(buf, sizeof(buf), "E=691 R=0 C=");
    ptr += strlen(ptr);
    for (i=0; i<16; i++) {
      snprintf(ptr, buf + sizeof buf - ptr, "%02X", *(auth2chap(authp)->challenge.local+1+i));
      ptr += strlen(ptr);
      if (ptr > buf + sizeof buf)
        break;
    }

    snprintf(ptr, buf + sizeof buf - ptr, " V=3 M=Invalid!");
    msg = buf;
  } else
#endif
    msg = "Invalid!!";

  ChapOutput(authp->physical, CHAP_FAILURE, authp->id, msg, strlen(msg) + 1,
             NULL);
  datalink_AuthNotOk(authp->physical->dl);
}

static int
chap_Cmp(u_char type, char *myans, int mylen, char *hisans, int hislen
#ifndef NODES
         , int lm
#endif
        )
{
  int off;

  if (mylen != hislen)
    return 0;

  off = 0;

#ifndef NODES
  if (type == 0x80) {
    off = lm ? 0 : 24;
    mylen = 24;
  }
#endif

  for (; mylen; off++, mylen--)
    if (toupper(myans[off]) != toupper(hisans[off]))
      return 0;

  return 1;
}

#ifndef NODES
static int
chap_HaveAnotherGo(struct chap *chap)
{
  if (++chap->peertries < 3) {
    /* Give the peer another shot */
    *chap->challenge.local = '\0';
    chap_Challenge(&chap->auth);
    return 1;
  }

  return 0;
}
#endif

void
chap_Init(struct chap *chap, struct physical *p)
{
  chap->desc.type = CHAP_DESCRIPTOR;
  chap->desc.UpdateSet = chap_UpdateSet;
  chap->desc.IsSet = chap_IsSet;
  chap->desc.Read = chap_Read;
  chap->desc.Write = chap_Write;
  chap->child.pid = 0;
  chap->child.fd = -1;
  auth_Init(&chap->auth, p, chap_Challenge, chap_Success, chap_Failure);
  *chap->challenge.local = *chap->challenge.peer = '\0';
#ifndef NODES
  chap->NTRespSent = 0;
  chap->peertries = 0;
#endif
}

void
chap_ReInit(struct chap *chap)
{
  chap_Cleanup(chap, SIGTERM);
}

struct mbuf *
chap_Input(struct bundle *bundle, struct link *l, struct mbuf *bp)
{
  struct physical *p = link2physical(l);
  struct chap *chap = &p->dl->chap;
  char *name, *key, *ans;
  int len, nlen;
  u_char alen;
#ifndef NODES
  int lanman;
#endif

  if (p == NULL) {
    log_Printf(LogERROR, "chap_Input: Not a physical link - dropped\n");
    m_freem(bp);
    return NULL;
  }

  if (bundle_Phase(bundle) != PHASE_NETWORK &&
      bundle_Phase(bundle) != PHASE_AUTHENTICATE) {
    log_Printf(LogPHASE, "Unexpected chap input - dropped !\n");
    m_freem(bp);
    return NULL;
  }

  m_settype(bp, MB_CHAPIN);
  if ((bp = auth_ReadHeader(&chap->auth, bp)) == NULL &&
      ntohs(chap->auth.in.hdr.length) == 0)
    log_Printf(LogWARN, "Chap Input: Truncated header !\n");
  else if (chap->auth.in.hdr.code == 0 || chap->auth.in.hdr.code > MAXCHAPCODE)
    log_Printf(LogPHASE, "Chap Input: %d: Bad CHAP code !\n",
               chap->auth.in.hdr.code);
  else {
    len = m_length(bp);
    ans = NULL;

    if (chap->auth.in.hdr.code != CHAP_CHALLENGE &&
        chap->auth.id != chap->auth.in.hdr.id &&
        Enabled(bundle, OPT_IDCHECK)) {
      /* Wrong conversation dude ! */
      log_Printf(LogPHASE, "Chap Input: %s dropped (got id %d, not %d)\n",
                 chapcodes[chap->auth.in.hdr.code], chap->auth.in.hdr.id,
                 chap->auth.id);
      m_freem(bp);
      return NULL;
    }
    chap->auth.id = chap->auth.in.hdr.id;	/* We respond with this id */

#ifndef NODES
    lanman = 0;
#endif
    switch (chap->auth.in.hdr.code) {
      case CHAP_CHALLENGE:
        bp = mbuf_Read(bp, &alen, 1);
        len -= alen + 1;
        if (len < 0) {
          log_Printf(LogERROR, "Chap Input: Truncated challenge !\n");
          m_freem(bp);
          return NULL;
        }
        *chap->challenge.peer = alen;
        bp = mbuf_Read(bp, chap->challenge.peer + 1, alen);
        bp = auth_ReadName(&chap->auth, bp, len);
#ifndef NODES
        lanman = p->link.lcp.his_authtype == 0x80 &&
                 ((chap->NTRespSent && IsAccepted(p->link.lcp.cfg.chap80lm)) ||
                  !IsAccepted(p->link.lcp.cfg.chap80nt));

        /* Generate local challenge value */
        chap_ChallengeInit(&chap->auth);
#endif
        break;

      case CHAP_RESPONSE:
        auth_StopTimer(&chap->auth);
        bp = mbuf_Read(bp, &alen, 1);
        len -= alen + 1;
        if (len < 0) {
          log_Printf(LogERROR, "Chap Input: Truncated response !\n");
          m_freem(bp);
          return NULL;
        }
        if ((ans = malloc(alen + 1)) == NULL) {
          log_Printf(LogERROR, "Chap Input: Out of memory !\n");
          m_freem(bp);
          return NULL;
        }
        *ans = chap->auth.id;
        bp = mbuf_Read(bp, ans + 1, alen);
        bp = auth_ReadName(&chap->auth, bp, len);
#ifndef NODES
        lanman = p->link.lcp.want_authtype == 0x80 &&
                 alen == 49 && ans[alen] == 0;
#endif
        break;

      case CHAP_SUCCESS:
      case CHAP_FAILURE:
        /* chap->auth.in.name is already set up at CHALLENGE time */
        if ((ans = malloc(len + 1)) == NULL) {
          log_Printf(LogERROR, "Chap Input: Out of memory !\n");
          m_freem(bp);
          return NULL;
        }
        bp = mbuf_Read(bp, ans, len);
        ans[len] = '\0';
        break;
    }

    switch (chap->auth.in.hdr.code) {
      case CHAP_CHALLENGE:
      case CHAP_RESPONSE:
        if (*chap->auth.in.name)
          log_Printf(LogPHASE, "Chap Input: %s (%d bytes from %s%s)\n",
                     chapcodes[chap->auth.in.hdr.code], alen,
                     chap->auth.in.name,
#ifndef NODES
                     lanman && chap->auth.in.hdr.code == CHAP_RESPONSE ?
                     " - lanman" :
#endif
                     "");
        else
          log_Printf(LogPHASE, "Chap Input: %s (%d bytes%s)\n",
                     chapcodes[chap->auth.in.hdr.code], alen,
#ifndef NODES
                     lanman && chap->auth.in.hdr.code == CHAP_RESPONSE ?
                     " - lanman" :
#endif
                     "");
        break;

      case CHAP_SUCCESS:
      case CHAP_FAILURE:
        if (*ans)
          log_Printf(LogPHASE, "Chap Input: %s (%s)\n",
                     chapcodes[chap->auth.in.hdr.code], ans);
        else
          log_Printf(LogPHASE, "Chap Input: %s\n",
                     chapcodes[chap->auth.in.hdr.code]);
        break;
    }

    switch (chap->auth.in.hdr.code) {
      case CHAP_CHALLENGE:
        if (*bundle->cfg.auth.key == '!' && bundle->cfg.auth.key[1] != '!')
          chap_StartChild(chap, bundle->cfg.auth.key + 1,
                          bundle->cfg.auth.name);
        else
          chap_Respond(chap, bundle->cfg.auth.name, bundle->cfg.auth.key +
                       (*bundle->cfg.auth.key == '!' ? 1 : 0),
                       p->link.lcp.his_authtype
#ifndef NODES
                       , lanman
#endif
                      );
        break;

      case CHAP_RESPONSE:
        name = chap->auth.in.name;
        nlen = strlen(name);
#ifndef NODES
        if (p->link.lcp.want_authtype == 0x81) {
          struct MSCHAPv2_resp *resp = (struct MSCHAPv2_resp *)(ans + 1);

          chap->challenge.peer[0] = sizeof resp->PeerChallenge;
          memcpy(chap->challenge.peer + 1, resp->PeerChallenge,
                 sizeof resp->PeerChallenge);
        }
#endif

#ifndef NORADIUS
        if (*bundle->radius.cfg.file) {
          if (!radius_Authenticate(&bundle->radius, &chap->auth,
                                   chap->auth.in.name, ans, alen + 1,
                                   chap->challenge.local + 1,
                                   *chap->challenge.local))
            chap_Failure(&chap->auth);
        } else
#endif
        {
          if (p->link.lcp.want_authtype == 0x81 && ans[alen] != '\0' &&
              alen == sizeof(struct MSCHAPv2_resp)) {
            struct MSCHAPv2_resp *resp = (struct MSCHAPv2_resp *)(ans + 1);

            log_Printf(LogWARN, "%s: Compensating for corrupt (Win98/WinME?) "
                       "CHAP81 RESPONSE\n", l->name);
            resp->Flags = '\0';	/* rfc2759 says it *MUST* be zero */
          }
          key = auth_GetSecret(bundle, name, nlen, p);
          if (key) {
#ifndef NODES
            if (p->link.lcp.want_authtype == 0x80 &&
                lanman && !IsEnabled(p->link.lcp.cfg.chap80lm)) {
              log_Printf(LogPHASE, "Auth failure: LANMan not enabled\n");
              if (chap_HaveAnotherGo(chap))
                break;
              key = NULL;
            } else if (p->link.lcp.want_authtype == 0x80 &&
                !lanman && !IsEnabled(p->link.lcp.cfg.chap80nt)) {
              log_Printf(LogPHASE, "Auth failure: mschap not enabled\n");
              if (chap_HaveAnotherGo(chap))
                break;
              key = NULL;
            } else if (p->link.lcp.want_authtype == 0x81 &&
                !IsEnabled(p->link.lcp.cfg.chap81)) {
              log_Printf(LogPHASE, "Auth failure: CHAP81 not enabled\n");
              key = NULL;
            } else
#endif
            {
              char *myans = chap_BuildAnswer(name, key, chap->auth.id,
                                             chap->challenge.local,
                                       p->link.lcp.want_authtype
#ifndef NODES
                                       , chap->challenge.peer,
                                       chap->authresponse, lanman);
              MPPE_IsServer = 1;		/* XXX Global ! */
#else
                                      );
#endif
              if (myans == NULL)
                key = NULL;
              else {
                if (!chap_Cmp(p->link.lcp.want_authtype, myans + 1, *myans,
                              ans + 1, alen
#ifndef NODES
                              , lanman
#endif
                             ))
                  key = NULL;
                free(myans);
              }
            }
          }

          if (key)
            chap_Success(&chap->auth);
          else
            chap_Failure(&chap->auth);
        }

        break;

      case CHAP_SUCCESS:
        if (p->link.lcp.auth_iwait == PROTO_CHAP) {
          p->link.lcp.auth_iwait = 0;
          if (p->link.lcp.auth_ineed == 0) {
#ifndef NODES
            if (p->link.lcp.his_authtype == 0x81) {
              if (strncasecmp(ans, chap->authresponse, 42)) {
                datalink_AuthNotOk(p->dl);
	        log_Printf(LogWARN, "CHAP81: AuthenticatorResponse: (%.42s)"
                           " != ans: (%.42s)\n", chap->authresponse, ans);

              } else {
                /* Successful login */
                MPPE_MasterKeyValid = 1;		/* XXX Global ! */
                datalink_AuthOk(p->dl);
              }
            } else
#endif
            /*
             * We've succeeded in our ``login''
             * If we're not expecting  the peer to authenticate (or he already
             * has), proceed to network phase.
             */
            datalink_AuthOk(p->dl);
          }
        }
        break;

      case CHAP_FAILURE:
        datalink_AuthNotOk(p->dl);
        break;
    }
    free(ans);
  }

  m_freem(bp);
  return NULL;
}
@


1.42
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.41 2005/07/09 01:45:08 brad Exp $
@


1.41
log
@rev 1.85

Ignore case when comparing CHAP/CHAP81 responses

rev 1.84

Do a case insensitive comparison when comparing the ms-chap response
string.

From brian FreeBSD

ok canacar@@
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.40 2004/01/23 03:48:43 deraadt Exp $
d315 1
a315 1
        fcntl(fd, F_SETFD, 1);
@


1.40
log
@Use closefrom(); ok millert tedu
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.39 2003/04/08 19:55:52 tedu Exp $
d38 1
d634 2
d638 3
d642 5
a646 2
  else if (type == 0x80) {
    int off = lm ? 0 : 24;
d648 2
a649 1
    if (memcmp(myans + off, hisans + off, 24))
a650 4
  }
#endif
  else if (memcmp(myans, hisans, mylen))
    return 0;
d943 1
a943 1
              if (strncmp(ans, chap->authresponse, 42)) {
@


1.39
log
@more correct snprintf bound.  ok deraadt@@
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.38 2003/04/07 23:58:53 deraadt Exp $
d312 1
@


1.38
log
@more string cleaning; ok tedu
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.37 2003/04/04 20:25:06 deraadt Exp $
d608 1
a608 1
      snprintf(ptr, 3, "%02X", *(auth2chap(authp)->challenge.local+1+i));
d610 2
@


1.37
log
@strlcpy and snprintf; various people ok
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.36 2002/06/17 01:14:08 brian Exp $
d612 1
a612 1
    sprintf(ptr, " V=3 M=Invalid!");
@


1.36
log
@Compensate for dodgy Win98/WinME MSCHAPv2 responses later in the code
path... after we've talked to any RADIUS servers involved, so that we
haven't touched the data before it gets to the server.
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.35 2002/06/15 08:02:00 brian Exp $
d599 1
a599 1
    sprintf(buf, "E=691 R=1 M=Invalid!");
d605 6
a610 3
    ptr += sprintf(buf, "E=691 R=0 C=");
    for (i=0; i<16; i++)
      ptr += sprintf(ptr, "%02X", *(auth2chap(authp)->challenge.local+1+i));
@


1.35
log
@Tidy up end of line whitespace
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.34 2002/06/15 01:33:23 brian Exp $
d764 1
a764 1
        if ((ans = malloc(alen + 2)) == NULL) {
a770 6
        if (p->link.lcp.want_authtype == 0x81 && ans[alen] != '\0') {
          log_Printf(LogWARN, "%s: Compensating for corrupt (Win98/WinME?) "
                     "CHAP81 RESPONSE\n", l->name);
          ans[alen] = '\0';
        }
        ans[alen+1] = '\0';
d844 5
a848 2
          chap->challenge.peer[0] = CHAP81_CHALLENGE_LEN;
          memcpy(chap->challenge.peer + 1, ans + 1, CHAP81_CHALLENGE_LEN);
d857 1
a857 3
                                   *chap->challenge.local,
                                   chap->challenge.peer + 1,
                                   *chap->challenge.peer))
d862 8
a871 1
            char *myans;
d892 2
a893 2
              myans = chap_BuildAnswer(name, key, chap->auth.id,
                                       chap->challenge.local,
@


1.34
log
@Understand MS-MPPE-Encryption-Policy, MS-MPPE-Encryption-Types,
MS-MPPE-Recv-Key and MS-MPPE-Send-Key RADIUS attributes, making
MPPE work properly with RADIUS & MSCHAPv2.

Do something with the Filter-Id RADIUS attribute.

Handle MS-CHAP-Error and MS-CHAP2-Success correctly rather than
bogusly including the Ident field in the text passed back to the
client.

Bump the max FSM option length to 52 (was 20)

Add some missing includes.
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.33 2002/05/16 14:27:21 brian Exp $
d220 1
a220 1
    GenerateAuthenticatorResponse(expkey, klen * 2, ntresponse, 
d608 1
a608 1
    
d779 1
a779 1
        lanman = p->link.lcp.want_authtype == 0x80 && 
d933 1
a933 1
                
@


1.33
log
@Handle MS-CHAPv2 authentication correctly via the RADIUS server (if it's
configured).

This doesn't yet work with MPPE.  More to follow.
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.32 2002/05/16 01:13:39 brian Exp $
d929 1
a929 2
              if (strncmp(ans, chap->authresponse, 42) &&
                  (*ans != 1 || strncmp(ans + 1, chap->authresponse, 41))) {
@


1.32
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.31 2002/03/31 02:38:49 brian Exp $
d552 6
a557 1
    msg = auth2chap(authp)->authresponse;
d848 7
d856 9
a864 6
        if (*bundle->radius.cfg.file)
          radius_Authenticate(&bundle->radius, &chap->auth,
                              chap->auth.in.name, ans, alen + 1,
                              chap->challenge.local + 1,
                              *chap->challenge.local);
        else
a889 8
#ifndef NODES
              /* Get peer's challenge */
              if (p->link.lcp.want_authtype == 0x81) {
                chap->challenge.peer[0] = CHAP81_CHALLENGE_LEN;
                memcpy(chap->challenge.peer + 1, ans + 1, CHAP81_CHALLENGE_LEN);
              }
#endif

d929 2
a930 1
              if (strncmp(ans, chap->authresponse, 42)) {
@


1.31
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.30 2001/08/19 23:22:17 brian Exp $
a70 1
#include "ip.h"
d546 1
d548 1
d556 5
d567 1
a567 1
  if (Enabled(authp->physical->dl->bundle, OPT_UTMP))
d582 1
a582 1
  char buf[1024];
d586 6
d593 4
a596 2
  if (authp->physical->link.lcp.want_authtype == 0x81) {
    char *ptr;
@


1.30
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.29 2001/07/31 21:37:15 brian Exp $
d40 1
a40 1
#ifdef HAVE_DES
d88 1
a88 1
#ifdef HAVE_DES
d126 1
a126 1
#ifdef HAVE_DES
d137 1
a137 1
#ifdef HAVE_DES
d361 1
a361 1
#ifdef HAVE_DES
d368 1
a368 1
#ifdef HAVE_DES
d376 1
a376 1
#ifdef HAVE_DES
d384 1
a384 1
#ifdef HAVE_DES
d450 1
a450 1
#ifdef HAVE_DES
d465 1
a465 1
#ifdef HAVE_DES
d504 1
a504 1
#ifdef HAVE_DES
d534 1
a534 1
#ifdef HAVE_DES
d549 1
a549 1
#ifdef HAVE_DES
d575 1
a575 1
#ifdef HAVE_DES
d580 1
a580 1
#ifdef HAVE_DES
d603 1
a603 1
#ifdef HAVE_DES
d610 1
a610 1
#ifdef HAVE_DES
d624 1
a624 1
#ifdef HAVE_DES
d651 1
a651 1
#ifdef HAVE_DES
d671 1
a671 1
#ifdef HAVE_DES
d711 1
a711 1
#ifdef HAVE_DES
d726 1
a726 1
#ifdef HAVE_DES
d759 1
a759 1
#ifdef HAVE_DES
d785 1
a785 1
#ifdef HAVE_DES
d793 1
a793 1
#ifdef HAVE_DES
d820 1
a820 1
#ifdef HAVE_DES
d841 1
a841 1
#ifdef HAVE_DES
d861 1
a861 1
#ifdef HAVE_DES
d872 1
a872 1
#ifdef HAVE_DES
d884 1
a884 1
#ifdef HAVE_DES
d906 1
a906 1
#ifdef HAVE_DES
@


1.29
log
@Don't include a NUL at the end of our CHAP SUCCESS packet.

When encryption (MPPE) is enabled, WindowsME and Windows98 both
fail because of the extra byte, suggesting that they autheticated
successfully in their log and then dropping the connection, telling
the user that the peer doesn't support compatible encryption
options.
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.28 2001/07/31 12:11:28 brian Exp $
d35 1
d70 2
d81 2
d753 1
a753 1
          log_Printf(LogWARN, "%s: Compensating for corrupt (Win98?) "
d910 2
a911 2
	        log_Printf(LogDEBUG, "CHAP81: AuthenticatorResponse: (%s)"
                           " != ans: (%s)\n", chap->authresponse, ans);
@


1.28
log
@When we receive a CHAP81 challenge response, we always expect the last
byte of the packet to contain '\0'.

Windows 98 gets this wrong, dropping garbage into the last byte and
failing authentication.

Now, we notice this and whinge to our log file that we're compensating
for the corrupt data.
@
text
@d28 1
a28 1
 * $OpenBSD: chap.c,v 1.27 2001/06/13 21:33:40 brian Exp $
d552 1
a552 1
  ChapOutput(authp->physical, CHAP_SUCCESS, authp->id, msg, strlen(msg) + 1,
@


1.27
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d747 5
@


1.26
log
@Don't assume challenges and responses don't contain embedded '\0's.

Mschapv2 response generation may produce embedded NULs... causing
us to send a bogus response to the radius server and end up
failing the client's valid response.

Problem pointed out by: Eugene Vigovskiy <vigov@@com2com.ru>
@
text
@d1 5
a5 2
/*
 *			PPP CHAP Module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 15
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: chap.c,v 1.25 2000/11/07 23:32:04 brian Exp $
 *
 *	TODO:
d30 1
@


1.25
log
@Pass the correct option data to the compression modules Init function
rather than the data associated with the first protocol REQuested.

Initiate MPPE session keys correctly based on whether we're client
or server
@
text
@d20 1
a20 1
 * $OpenBSD: chap.c,v 1.24 2000/11/02 00:54:33 brian Exp $
d813 1
a813 5
        if (*bundle->radius.cfg.file) {
          u_char end;

          end = chap->challenge.local[*chap->challenge.local+1];
          chap->challenge.local[*chap->challenge.local+1] = '\0';
d815 4
a818 4
                              chap->auth.in.name, ans,
                              chap->challenge.local + 1);
          chap->challenge.local[*chap->challenge.local+1] = end;
        } else
@


1.24
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d20 1
a20 1
 * $OpenBSD: chap.c,v 1.23 2000/08/18 00:02:10 brian Exp $
d206 1
a206 1
    GetMasterKey(pwdhashhash, ntresponse, MPPE_MasterKey);
d374 1
d540 1
a540 1
    MPPE_MasterKeyValid = 1;
d861 4
a864 1
                                       chap->authresponse, lanman
a865 1
                                      );
d902 1
a902 1
                MPPE_MasterKeyValid = 1;
@


1.23
log
@Make -DNOSUID (or -DPPP_NOSUID) possible to build ppp without SUID
capabilities.
@
text
@d20 1
a20 1
 * $OpenBSD: chap.c,v 1.22 2000/08/09 19:31:25 brian Exp $
d78 1
d115 1
a115 1
                 , int lanman
d171 45
d365 1
a365 1
                         , lm
d470 1
a470 1
chap_Challenge(struct authinfo *authp)
d494 2
d504 25
a528 2
  ChapOutput(authp->physical, CHAP_CHALLENGE, authp->id, chap->challenge.local,
	     1 + *chap->challenge.local + len, NULL);
d534 1
d536 11
a546 1
  ChapOutput(authp->physical, CHAP_SUCCESS, authp->id, "Welcome!!", 10, NULL);
d562 23
a584 1
  ChapOutput(authp->physical, CHAP_FAILURE, authp->id, "Invalid!!", 9, NULL);
d717 3
d742 2
a743 1
        lanman = alen == 49 && ans[alen] == 0;
d828 2
a829 1
            if (lanman && !IsEnabled(p->link.lcp.cfg.chap80lm)) {
d834 2
a835 2
            } else if (!lanman && !IsEnabled(p->link.lcp.cfg.chap80nt) &&
                       p->link.lcp.want_authtype == 0x80) {
d840 4
d847 8
d859 2
a860 1
                                       , lanman
d889 15
a903 1
          if (p->link.lcp.auth_ineed == 0)
d910 1
@


1.22
log
@Allow leading ``!'' characters in authkeys and chat scripts to
be doubled up to mean a single literaly ``!''.
@
text
@d20 1
a20 1
 * $OpenBSD: chap.c,v 1.21 2000/07/19 11:06:31 brian Exp $
d257 1
d259 1
@


1.21
log
@Support link identification from rfc1570
Add VERSION and COMPILATIONDATE macros
Two new commands are available; ``ident'' and ``sendident''.
@
text
@d20 1
a20 1
 * $OpenBSD: chap.c,v 1.20 2000/02/27 01:38:25 brian Exp $
d685 1
a685 1
        if (*bundle->cfg.auth.key == '!')
d689 3
a691 2
          chap_Respond(chap, bundle->cfg.auth.name,
                       bundle->cfg.auth.key, p->link.lcp.his_authtype
@


1.20
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: chap.c,v 1.19 2000/02/27 00:21:06 brian Exp $
a51 1
#include "lcp.h"
d54 1
@


1.19
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.18 2000/01/07 03:26:53 brian Exp $
@


1.18
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.17 1999/08/17 15:00:38 brian Exp $
d334 1
a334 1
chap_UpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
d350 1
a350 1
chap_IsSet(struct descriptor *d, const fd_set *fdset)
d358 1
a358 1
chap_Read(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
d414 1
a414 1
chap_Write(struct descriptor *d, struct bundle *bundle, const fd_set *fdset)
@


1.17
log
@Set the close-on-exec flag for all unused descriptors when
exec()ing other programs.
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.16 1999/07/15 02:10:31 brian Exp $
d79 1
d81 1
a81 1
static const char *chapcodes[] = {
d98 1
a98 1
  bp = mbuf_Alloc(plen, MB_CHAPOUT);
d108 1
a108 1
                  PRI_LINK, PROTO_CHAP);
d234 9
d257 1
a257 2
      setuid(geteuid());
      argc = command_Interpret(prog, strlen(prog), argv);
d558 1
a558 1
    mbuf_Free(bp);
d565 1
a565 1
    mbuf_Free(bp);
d569 1
a569 1
  mbuf_SetType(bp, MB_CHAPIN);
d577 1
a577 1
    len = mbuf_Length(bp);
d587 1
a587 1
      mbuf_Free(bp);
d601 1
a601 1
          mbuf_Free(bp);
d620 1
a620 1
          mbuf_Free(bp);
d625 1
a625 1
          mbuf_Free(bp);
d642 1
a642 1
          mbuf_Free(bp);
d781 1
a781 1
  mbuf_Free(bp);
@


1.16
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.14 1999/06/09 08:47:23 brian Exp $
d38 1
d235 2
a236 5
      if (out[1] == STDIN_FILENO) {
        fd = dup(out[1]);
        close(out[1]);
        out[1] = fd;
      }
d239 2
a240 1
      if ((fd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
d245 2
a246 3
      dup2(fd, STDERR_FILENO);
      fcntl(3, F_SETFD, 1);		/* Set close-on-exec flag */

d252 2
a253 4

      log_Printf(LogWARN, "exec() of %s failed: %s\n",
                nargv[0], strerror(errno));
      exit(255);
@


1.15
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@@


1.14
log
@Use the correct pid when substituting PROCESSID.
Problem reported by: Amedeo Beck Peccoz <gea@@gressoney.it>
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.13 1999/06/02 15:58:40 brian Exp $
d546 1
a546 1
  u_char alen, end;
d697 2
@


1.13
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.12 1999/05/08 11:06:34 brian Exp $
d200 1
d219 1
d252 1
a252 1
                     chap->auth.physical->dl->bundle, 0);
@


1.12
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.11 1999/04/21 08:07:24 brian Exp $
d96 1
a96 1
  bp = mbuf_Alloc(plen, MB_FSM);
d562 1
@


1.11
log
@Split the recorded chap challenge into two - one for the
receiver and one for the sender.  This allows two simultaneous
chap conversations - something that I *thought* I was already
doing on a daily basis myself until the existence of the
problem was
Beaten into me by: sos@@FreeBSD.org
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.10 1999/04/19 16:59:39 brian Exp $
d44 1
d50 1
a50 1
#include "lcpproto.h"
d105 2
a106 1
  hdlc_Output(&physical->link, PRI_LINK, PROTO_CHAP, bp);
d537 2
a538 2
void
chap_Input(struct physical *p, struct mbuf *bp)
d540 1
d549 8
a556 2
  if (bundle_Phase(p->dl->bundle) != PHASE_NETWORK &&
      bundle_Phase(p->dl->bundle) != PHASE_AUTHENTICATE) {
d559 1
a559 1
    return;
d574 1
a574 1
        Enabled(p->dl->bundle, OPT_IDCHECK)) {
d580 1
a580 1
      return;
d594 1
a594 1
          return;
d613 1
a613 1
          return;
d618 1
a618 1
          return;
d635 1
a635 1
          return;
d677 3
a679 3
        if (*p->dl->bundle->cfg.auth.key == '!')
          chap_StartChild(chap, p->dl->bundle->cfg.auth.key + 1,
                          p->dl->bundle->cfg.auth.name);
d681 2
a682 2
          chap_Respond(chap, p->dl->bundle->cfg.auth.name,
                       p->dl->bundle->cfg.auth.key, p->link.lcp.his_authtype
d693 1
a693 1
        if (*p->dl->bundle->radius.cfg.file) {
d696 1
a696 1
          radius_Authenticate(&p->dl->bundle->radius, &chap->auth,
d703 1
a703 1
          key = auth_GetSecret(p->dl->bundle, name, nlen, p);
d772 1
@


1.10
log
@Escape stuff in the peers accmap as well as our own when async
encoding, and back out the negotiation strategy that didn't
quite have the right effect with some (bad?) ppp implementations.

Drop unexpected PAP/CHAP packets (if not in NETWORK or ESTABLISH
phase).

Make sure that we enter PHASE_ESTABLISH when we need to.

Detect HDLC frames correctly, not just when the whole header
is obtained by a single read().

Don't convert \r\n to \r\r\n in tty raw mode.

Use the correct macros for `', ``'', () and [].
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.9 1999/02/20 01:15:12 brian Exp $
d262 1
a262 1
      write(in[1], chap->challenge + 1, *chap->challenge);
d291 1
a291 1
  *chap->challenge = 0;
d306 1
a306 1
  ans = chap_BuildAnswer(name, key, chap->auth.id, chap->challenge, type
d421 1
a421 1
  if (!*chap->challenge) {
d423 1
a423 1
    cp = chap->challenge;
d440 1
a440 1
      for (i = 0; i < *chap->challenge; i++)
d445 2
a446 2
  ChapOutput(authp->physical, CHAP_CHALLENGE, authp->id, chap->challenge,
	     1 + *chap->challenge + len, NULL);
d502 1
a502 1
    *chap->challenge = '\0';
d522 1
a522 1
  *chap->challenge = 0;
d541 1
a541 1
  u_char alen;
d587 2
a588 2
        *chap->challenge = alen;
        bp = mbuf_Read(bp, chap->challenge + 1, alen);
d685 2
a686 1
          chap->challenge[*chap->challenge+1] = '\0';
d688 3
a690 1
                              chap->auth.in.name, ans, chap->challenge + 1);
d713 1
a713 1
                                       chap->challenge,
@


1.9
log
@Handle empty PAP & CHAP packets (containing only an FSM header).
Some CHAP implementations send no welcome message with their
SUCCESS/FAILURE packets.  This was being mis-identified as
a truncated packet by the new authentication code :-(
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.8 1999/02/18 19:46:19 brian Exp $
d545 7
@


1.8
log
@Build correctly when -DNOCRYPT is used.
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.7 1999/02/18 19:12:10 brian Exp $
d546 3
a548 2
  if ((bp = auth_ReadHeader(&chap->auth, bp)) == NULL)
    log_Printf(LogERROR, "Chap Input: Truncated header !\n");
@


1.7
log
@Don't expect a chap response if we haven't negotiated
chap 0x80.
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.6 1999/02/18 00:50:44 brian Exp $
d108 5
a112 2
chap_BuildAnswer(char *name, char *key, u_char id, char *challenge,
                 u_char type, int lanman)
d292 1
d294 1
d298 5
a302 1
chap_Respond(struct chap *chap, char *name, char *key, u_char type, int lm)
d306 5
a310 1
  ans = chap_BuildAnswer(name, key, chap->auth.id, chap->challenge, type, lm);
d315 1
d317 1
d380 1
d385 1
d394 5
a398 2
      chap_Respond(chap, name, key,
                   chap->auth.physical->link.lcp.his_authtype, lanman);
d474 5
a478 1
chap_Cmp(u_char type, int lm, char *myans, int mylen, char *hisans, int hislen)
d482 1
d488 3
a490 1
  } else if (memcmp(myans, hisans, mylen))
d496 1
d509 1
d523 1
d526 1
d540 1
a540 1
  int len, nlen, lanman;
d542 3
d567 1
d569 1
d582 1
d586 1
d607 1
d609 1
d632 1
d634 3
a636 1
                     " - lanman" : "");
d640 1
d642 3
a644 1
                     " - lanman" : "");
d665 5
a669 2
                       p->dl->bundle->cfg.auth.key,
                       p->link.lcp.his_authtype, lanman);
d686 1
d698 3
a700 1
            } else {
d703 5
a707 1
                                       p->link.lcp.want_authtype, lanman);
d711 6
a716 2
                if (!chap_Cmp(p->link.lcp.want_authtype, lanman,
                              myans + 1, *myans, ans + 1, alen))
@


1.6
log
@Fully support both NT and LANMan CHAP type 0x80 as both
authenticator and authenticatee.
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.5 1999/02/11 10:14:49 brian Exp $
d642 2
a643 1
            } else if (!lanman && !IsEnabled(p->link.lcp.cfg.chap80nt)) {
@


1.5
log
@When resending chap challenges, resend the same challenge
each time rather than making up a new one.

Increase the authname/authkey max sizes to 100 characters.

Allow ``authkey'' specifications beginning with ``!''.
When a challenge is received, the text following the
``!'' is executed as a program (expanding stuff in the same
way that ``sh'' and ``!bg'' do).  The program is passed the
peer name, peer challenge and local ``authname'' on standard
input and is expected to output the name/key combination that
should be used to build the CHAP response.

This provides support for Secure ID cards (guess what I was
given at work recently!) using CHAP.

Examples will follow.
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.4 1999/02/07 13:56:19 brian Exp $
a33 1
#include <string.h>
d39 1
d108 2
a109 1
chap_BuildAnswer(char *name, char *key, u_char id, char *challenge, int MSChap)
d118 1
a118 1
  if (MSChap) {
d126 29
a154 8
    digest = result;				/* this is the response */
    *digest++ = MS_CHAP_RESPONSE_LEN;		/* 49 */
    memset(digest, '\0', 24);
    digest += 24;

    for (f = klen; f; f--) {
      expkey[2*f-2] = key[f-1];
      expkey[2*f-1] = 0;
a155 11

    /*
     *           -----------
     * answer = | k\0e\0y\0 |
     *           -----------
     */
    MD4Init(&MD4context);
    MD4Update(&MD4context, expkey, klen << 1);
    MD4Final(digest, &MD4context);
    memcpy(digest + 25, name, nlen);

d157 5
a161 11
     * ``result'' is:
     *           ---- --------- -------------------- ------
     * result = | 49 | 24 * \0 | digest (pad to 25) | name |
     *           ---- --------- -------------------- ------
     */
    chap_MS(digest, challenge + 1, *challenge);

    /*
     *           ---- --------- ---------------- --- ----------
     * result = | 49 | 24 * \0 | 24 byte digest | 1 | authname |
     *           ---- --------- ---------------- --- ----------
d289 1
d293 1
a293 1
chap_SendResponse(struct chap *chap, char *name, char *key)
d295 1
a295 1
  char *ans;
d297 1
a297 1
  ans = chap_BuildAnswer(name, key, chap->auth.id, chap->challenge, 0);
d302 1
d365 5
d377 2
a378 1
      chap_SendResponse(chap, name, key);
d414 6
a419 1
      *cp++ = random() % (CHAPCHALLENGELEN-16) + 16;
d453 29
d494 2
a495 1
  chap->using_MSChap = 0;
d508 2
a509 2
  char *name, *key, *ans, *myans;
  int len, nlen;
d533 1
d536 2
a537 2
        bp = mbuf_Read(bp, chap->challenge, 1);
        len -= *chap->challenge + 1;
d543 2
a544 1
        bp = mbuf_Read(bp, chap->challenge + 1, *chap->challenge);
d546 3
d569 1
d589 5
a593 2
          log_Printf(LogPHASE, "Chap Input: %s (from %s)\n",
                     chapcodes[chap->auth.in.hdr.code], chap->auth.in.name);
d595 4
a598 2
          log_Printf(LogPHASE, "Chap Input: %s\n",
                     chapcodes[chap->auth.in.hdr.code]);
d618 3
a620 2
          chap_SendResponse(chap, p->dl->bundle->cfg.auth.name,
                            p->dl->bundle->cfg.auth.key);
d636 10
a645 3
            myans = chap_BuildAnswer(name, key, chap->auth.id, chap->challenge,
                                     chap->using_MSChap);
            if (myans == NULL)
d647 5
a651 2
            else {
              if (*myans != alen || memcmp(myans + 1, ans + 1, *myans))
d653 6
a658 1
              free(myans);
@


1.4
log
@Correct server-side chap authentication comparison
(broken with last commit).
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.3 1999/02/07 13:48:33 brian Exp $
d30 2
d37 2
d40 1
d42 1
a53 1
#include "chap.h"
d57 1
d72 1
d185 195
d386 5
a390 2
  randinit();
  cp = chap->challenge;
d393 6
a398 6
  if (*authp->physical->dl->bundle->radius.cfg.file) {
    /* For radius, our challenge is 16 readable NUL terminated bytes :*/
    *cp++ = 16;
    for (i = 0; i < 16; i++)
      *cp++ = (random() % 10) + '0';
  } else
d400 6
a405 4
  {
    *cp++ = random() % (CHAPCHALLENGELEN-16) + 16;
    for (i = 0; i < *chap->challenge; i++)
      *cp++ = random() & 0xff;
a406 4

  len = strlen(authp->physical->dl->bundle->cfg.auth.name);
  memcpy(cp, authp->physical->dl->bundle->cfg.auth.name, len);
  cp += len;
d408 1
a408 1
	     cp - chap->challenge, NULL);
d438 7
d451 6
d555 6
a560 11
        name = p->dl->bundle->cfg.auth.name;
        nlen = strlen(name);
        key = p->dl->bundle->cfg.auth.key;
        myans = chap_BuildAnswer(name, key, chap->auth.id, chap->challenge, 0);
        if (myans) {
          ChapOutput(p, CHAP_RESPONSE, chap->auth.id, myans,
                     *myans + 1 + nlen, name);
          free(myans);
        } else
          ChapOutput(p, CHAP_FAILURE, chap->auth.id, "Out of memory!",
                     14, NULL);
@


1.3
log
@Remove forgotten diagnostics
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.2 1999/02/06 03:22:32 brian Exp $
d370 1
a370 1
              if (memcmp(myans, ans, 1 + *myans))
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.39 1999/01/29 22:46:31 brian Exp $
a160 1
log_Printf(LogPHASE, "Build with 0x%x, %s & %.*s\n", id, key, *challenge, challenge+1);
a357 1
log_Printf(LogPHASE, "Challenge %s, answer is %d bytes starting with %d\n", chap->challenge+1, alen+1, *ans);
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: chap.c,v 1.37 1998/08/26 18:07:56 brian Exp $
d24 1
a24 1
#include <sys/types.h>
d32 1
a35 1
#include <string.h>
d60 3
d74 1
d78 1
a78 1
	   const u_char * ptr, int count, const char *text)
d100 2
a101 2
void
chap_SendChallenge(struct authinfo *auth, int chapid, struct physical *physical)
d103 71
a173 3
  struct chap *chap = auth2chap(auth);
  int len, i;
  char *cp;
d175 1
a175 10
  randinit();
  cp = chap->challenge_data;
  *cp++ = chap->challenge_len = random() % 32 + 16;
  for (i = 0; i < chap->challenge_len; i++)
    *cp++ = random() & 0xff;
  len = strlen(physical->dl->bundle->cfg.auth.name);
  memcpy(cp, physical->dl->bundle->cfg.auth.name, len);
  cp += len;
  ChapOutput(physical, CHAP_CHALLENGE, chapid, chap->challenge_data,
	     cp - chap->challenge_data, NULL);
d179 1
a179 2
RecvChapTalk(struct bundle *bundle, struct fsmheader *chp, struct mbuf *bp,
             struct physical *physical)
d181 3
a183 11
  int valsize, len;
  int arglen, keylen, namelen;
  char *cp, *argp, *ap, *name, *digest;
  char *keyp;
  MD5_CTX MD5context;		/* context for MD5 */
  char answer[100];
  char cdigest[16];
#ifdef HAVE_DES
  int ix;
  MD4_CTX MD4context;		/* context for MD4 */
#endif
d185 2
a186 18
  len = ntohs(chp->length);
  log_Printf(LogDEBUG, "RecvChapTalk: length: %d\n", len);
  arglen = len - sizeof(struct fsmheader);
  cp = (char *) MBUF_CTOP(bp);
  valsize = *cp++ & 255;
  name = cp + valsize;
  namelen = arglen - valsize - 1;
  name[namelen] = 0;

  log_Printf(LogPHASE, "Chap Input: %s (from %s)\n",
             chapcodes[chp->code], name);

  switch (chp->code) {
  case CHAP_CHALLENGE:
    keyp = bundle->cfg.auth.key;
    keylen = strlen(bundle->cfg.auth.key);
    name = bundle->cfg.auth.name;
    namelen = strlen(bundle->cfg.auth.name);
d188 7
a194 4
#ifdef HAVE_DES
    if (physical->dl->chap.using_MSChap)
      argp = malloc(1 + namelen + MS_CHAP_RESPONSE_LEN);
    else
d196 5
a200 1
      argp = malloc(1 + valsize + namelen + 16);
d202 6
a207 94
    if (argp == NULL) {
      ChapOutput(physical, CHAP_FAILURE, chp->id, "Out of memory!", 14, NULL);
      return;
    }
#ifdef HAVE_DES
    if (physical->dl->chap.using_MSChap) {
      digest = argp;     /* this is the response */
      *digest++ = MS_CHAP_RESPONSE_LEN;   /* 49 */
      memset(digest, '\0', 24);
      digest += 24;

      ap = answer;       /* this is the challenge */
      memcpy(ap, keyp, keylen);
      ap += 2 * keylen;
      memcpy(ap, cp, valsize);
      log_DumpBuff(LogDEBUG, "recv", ap, valsize);
      ap += valsize;
      for (ix = keylen; ix > 0 ; ix--) {
          answer[2*ix-2] = answer[ix-1];
          answer[2*ix-1] = 0;
      }
      MD4Init(&MD4context);
      MD4Update(&MD4context, answer, 2 * keylen);
      MD4Final(digest, &MD4context);
      memcpy(digest + 25, name, namelen);
      ap += 2 * keylen;
      chap_MS(digest, answer + 2 * keylen, valsize);
      log_DumpBuff(LogDEBUG, "answer", digest, 24);
      ChapOutput(physical, CHAP_RESPONSE, chp->id, argp,
		 namelen + MS_CHAP_RESPONSE_LEN + 1, name);
    } else {
#endif
      digest = argp;
      *digest++ = 16;		/* value size */
      ap = answer;
      *ap++ = chp->id;
      memcpy(ap, keyp, keylen);
      ap += keylen;
      memcpy(ap, cp, valsize);
      log_DumpBuff(LogDEBUG, "recv", ap, valsize);
      ap += valsize;
      MD5Init(&MD5context);
      MD5Update(&MD5context, answer, ap - answer);
      MD5Final(digest, &MD5context);
      log_DumpBuff(LogDEBUG, "answer", digest, 16);
      memcpy(digest + 16, name, namelen);
      ap += namelen;
      /* Send answer to the peer */
      ChapOutput(physical, CHAP_RESPONSE, chp->id, argp, namelen + 17, name);
#ifdef HAVE_DES
    }
#endif
    free(argp);
    if (*name == '\0')
      log_Printf(LogWARN, "Sending empty CHAP authname!\n");
    break;
  case CHAP_RESPONSE:
    /*
     * Get a secret key corresponds to the peer
     */
    keyp = auth_GetSecret(bundle, name, namelen, physical);
    if (keyp) {
      /*
       * Compute correct digest value
       */
      keylen = strlen(keyp);
      ap = answer;
      *ap++ = chp->id;
      memcpy(ap, keyp, keylen);
      ap += keylen;
      MD5Init(&MD5context);
      MD5Update(&MD5context, answer, ap - answer);
      MD5Update(&MD5context, physical->dl->chap.challenge_data + 1,
                physical->dl->chap.challenge_len);
      MD5Final(cdigest, &MD5context);
      log_DumpBuff(LogDEBUG, "got", cp, 16);
      log_DumpBuff(LogDEBUG, "expect", cdigest, 16);

      /*
       * Compare with the response
       */
      if (memcmp(cp, cdigest, 16) == 0) {
        datalink_GotAuthname(physical->dl, name, namelen);
	ChapOutput(physical, CHAP_SUCCESS, chp->id, "Welcome!!", 10, NULL);
	physical->link.lcp.auth_ineed = 0;
        if (Enabled(bundle, OPT_UTMP))
          physical_Login(physical, name);

        if (physical->link.lcp.auth_iwait == 0)
          /*
           * Either I didn't need to authenticate, or I've already been
           * told that I got the answer right.
           */
          datalink_AuthOk(physical->dl);
d209 8
a216 3
	break;
      }
    }
d218 1
d220 2
a221 1
     * Peer is not registerd, or response digest is wrong.
d223 1
a223 4
    ChapOutput(physical, CHAP_FAILURE, chp->id, "Invalid!!", 9, NULL);
    datalink_AuthNotOk(physical->dl);
    break;
  }
d227 1
a227 2
RecvChapResult(struct bundle *bundle, struct fsmheader *chp, struct mbuf *bp,
	       struct physical *physical)
d229 3
a231 1
  int len;
d233 6
a238 18
  len = ntohs(chp->length);
  log_Printf(LogDEBUG, "RecvChapResult: length: %d\n", len);
  if (chp->code == CHAP_SUCCESS) {
    if (physical->link.lcp.auth_iwait == PROTO_CHAP) {
      physical->link.lcp.auth_iwait = 0;
      if (physical->link.lcp.auth_ineed == 0)
        /*
         * We've succeeded in our ``login''
         * If we're not expecting  the peer to authenticate (or he already
         * has), proceed to network phase.
         */
        datalink_AuthOk(physical->dl);
    }
  } else {
    /* CHAP failed - it's not going to get any better */
    log_Printf(LogPHASE, "Chap Input: Giving up after name/key FAILURE\n");
    datalink_AuthNotOk(physical->dl);
  }
d242 1
a242 1
chap_Input(struct bundle *bundle, struct mbuf *bp, struct physical *physical)
d244 25
a268 2
  int len = mbuf_Length(bp);
  struct fsmheader *chp;
d270 12
a281 7
  if (len >= sizeof(struct fsmheader)) {
    chp = (struct fsmheader *) MBUF_CTOP(bp);
    if (len >= ntohs(chp->length)) {
      if (chp->code < 1 || chp->code > 4)
	chp->code = 0;
      bp->offset += sizeof(struct fsmheader);
      bp->cnt -= sizeof(struct fsmheader);
a282 1
      switch (chp->code) {
d284 55
a338 2
	auth_StopTimer(&physical->dl->chap.auth);
	/* Fall into.. */
d340 46
a385 2
	RecvChapTalk(bundle, chp, bp, physical);
	break;
d387 12
d400 2
a401 4
        log_Printf(LogPHASE, "Chap Input: %s\n", chapcodes[chp->code]);
	RecvChapResult(bundle, chp, bp, physical);
	break;
      }
d403 1
d405 1
@

