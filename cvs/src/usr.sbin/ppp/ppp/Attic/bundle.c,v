head	1.75;
access;
symbols
	OPENBSD_5_5:1.74.0.26
	OPENBSD_5_5_BASE:1.74
	OPENBSD_5_4:1.74.0.22
	OPENBSD_5_4_BASE:1.74
	OPENBSD_5_3:1.74.0.20
	OPENBSD_5_3_BASE:1.74
	OPENBSD_5_2:1.74.0.18
	OPENBSD_5_2_BASE:1.74
	OPENBSD_5_1_BASE:1.74
	OPENBSD_5_1:1.74.0.16
	OPENBSD_5_0:1.74.0.14
	OPENBSD_5_0_BASE:1.74
	OPENBSD_4_9:1.74.0.12
	OPENBSD_4_9_BASE:1.74
	OPENBSD_4_8:1.74.0.10
	OPENBSD_4_8_BASE:1.74
	OPENBSD_4_7:1.74.0.6
	OPENBSD_4_7_BASE:1.74
	OPENBSD_4_6:1.74.0.8
	OPENBSD_4_6_BASE:1.74
	OPENBSD_4_5:1.74.0.4
	OPENBSD_4_5_BASE:1.74
	OPENBSD_4_4:1.74.0.2
	OPENBSD_4_4_BASE:1.74
	OPENBSD_4_3:1.71.0.10
	OPENBSD_4_3_BASE:1.71
	OPENBSD_4_2:1.71.0.8
	OPENBSD_4_2_BASE:1.71
	OPENBSD_4_1:1.71.0.6
	OPENBSD_4_1_BASE:1.71
	OPENBSD_4_0:1.71.0.4
	OPENBSD_4_0_BASE:1.71
	OPENBSD_3_9:1.71.0.2
	OPENBSD_3_9_BASE:1.71
	OPENBSD_3_8:1.70.0.2
	OPENBSD_3_8_BASE:1.70
	OPENBSD_3_7:1.69.0.6
	OPENBSD_3_7_BASE:1.69
	OPENBSD_3_6:1.69.0.4
	OPENBSD_3_6_BASE:1.69
	OPENBSD_3_5:1.69.0.2
	OPENBSD_3_5_BASE:1.69
	OPENBSD_3_4:1.67.0.2
	OPENBSD_3_4_BASE:1.67
	OPENBSD_3_3:1.66.0.4
	OPENBSD_3_3_BASE:1.66
	OPENBSD_3_2:1.66.0.2
	OPENBSD_3_2_BASE:1.66
	OPENBSD_3_1:1.63.0.2
	OPENBSD_3_1_BASE:1.63
	OPENBSD_3_0:1.60.0.2
	OPENBSD_3_0_BASE:1.60
	OPENBSD_2_9_BASE:1.56
	OPENBSD_2_9:1.56.0.2
	OPENBSD_2_8:1.47.0.2
	OPENBSD_2_8_BASE:1.47
	OPENBSD_2_7:1.36.0.2
	OPENBSD_2_7_BASE:1.36
	OPENBSD_2_6:1.26.0.2
	OPENBSD_2_6_BASE:1.26
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.75
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.74;

1.74
date	2008.03.24.16.11.04;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2008.03.15.16.25.00;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2008.03.13.01.49.53;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2005.09.21.15.04.28;	author brad;	state Exp;
branches;
next	1.70;

1.70
date	2005.07.17.19.13.24;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.28.01.35.16;	author kevlo;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.23.03.48.43;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2003.04.04.20.25.06;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.65;

1.65
date	2002.05.27.23.19.38;	author brian;	state Exp;
branches;
next	1.64;

1.64
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.63;

1.63
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.62;

1.62
date	2001.11.23.11.17.03;	author brian;	state Exp;
branches;
next	1.61;

1.61
date	2001.10.24.10.01.10;	author brian;	state Exp;
branches;
next	1.60;

1.60
date	2001.08.21.11.06.04;	author brian;	state Exp;
branches;
next	1.59;

1.59
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.58;

1.58
date	2001.07.03.22.23.56;	author brian;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.19.10.24.49;	author brian;	state Exp;
branches;
next	1.56;

1.56
date	2001.04.05.02.24.04;	author brian;	state Exp;
branches;
next	1.55;

1.55
date	2001.03.28.09.52.54;	author brian;	state Exp;
branches;
next	1.54;

1.54
date	2001.03.24.01.05.58;	author brian;	state Exp;
branches;
next	1.53;

1.53
date	2001.02.04.01.19.53;	author brian;	state Exp;
branches;
next	1.52;

1.52
date	2001.02.04.01.14.27;	author brian;	state Exp;
branches;
next	1.51;

1.51
date	2001.02.04.01.14.23;	author brian;	state Exp;
branches;
next	1.50;

1.50
date	2001.01.29.01.34.38;	author brian;	state Exp;
branches;
next	1.49;

1.49
date	2001.01.26.01.41.03;	author brian;	state Exp;
branches;
next	1.48;

1.48
date	2000.11.28.22.59.52;	author brian;	state Exp;
branches;
next	1.47;

1.47
date	2000.08.28.22.44.41;	author brian;	state Exp;
branches;
next	1.46;

1.46
date	2000.08.18.00.02.10;	author brian;	state Exp;
branches;
next	1.45;

1.45
date	2000.08.16.09.07.26;	author brian;	state Exp;
branches;
next	1.44;

1.44
date	2000.08.15.10.26.34;	author brian;	state Exp;
branches;
next	1.43;

1.43
date	2000.08.15.10.08.46;	author brian;	state Exp;
branches;
next	1.42;

1.42
date	2000.07.11.22.13.02;	author brian;	state Exp;
branches;
next	1.41;

1.41
date	2000.07.11.09.27.32;	author brian;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.07.14.47.53;	author brian;	state Exp;
branches;
next	1.39;

1.39
date	2000.06.23.09.47.30;	author brian;	state Exp;
branches;
next	1.38;

1.38
date	2000.06.18.10.08.59;	author brian;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.13.09.57.50;	author brian;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.07.23.46.39;	author brian;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.06.10.09.57;	author brian;	state Exp;
branches;
next	1.34;

1.34
date	2000.04.02.01.36.24;	author brian;	state Exp;
branches;
next	1.33;

1.33
date	2000.04.02.01.36.23;	author brian;	state Exp;
branches;
next	1.32;

1.32
date	2000.03.19.10.33.32;	author brian;	state Exp;
branches;
next	1.31;

1.31
date	2000.03.03.21.52.56;	author brian;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.27.01.38.24;	author brian;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.27.01.34.04;	author brian;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.27.00.21.05;	author brian;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.07.03.26.53;	author brian;	state Exp;
branches;
next	1.26;

1.26
date	99.08.17.17.25.34;	author brian;	state Exp;
branches;
next	1.25;

1.25
date	99.08.09.23.01.52;	author brian;	state Exp;
branches;
next	1.24;

1.24
date	99.08.05.10.32.13;	author brian;	state Exp;
branches;
next	1.23;

1.23
date	99.07.27.23.47.21;	author brian;	state Exp;
branches;
next	1.22;

1.22
date	99.07.15.02.10.31;	author brian;	state Exp;
branches;
next	1.21;

1.21
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	99.06.22.11.32.44;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	99.06.02.00.46.55;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	99.05.31.23.57.35;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	99.05.27.08.44.48;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	99.05.12.10.03.48;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	99.05.08.11.06.33;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	99.04.26.08.55.00;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	99.03.25.11.37.16;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.03.07.01.42.14;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.03.04.17.42.25;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.03.01.00.45.14;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.02.25.12.06.51;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.02.06.03.22.31;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.02.04.11.54.47;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.01.06.00.10.02;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	98.12.10.18.40.41;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	98.10.29.23.48.19;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.10.29.02.21.44;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.08.31.08.16.34;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.16;	author brian;	state Exp;
branches;
next	;


desc
@@


1.75
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1998 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: bundle.c,v 1.74 2008/03/24 16:11:04 deraadt Exp $
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <net/if_tun.h>		/* For TUNS* ioctls */
#include <net/route.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/un.h>

#include <errno.h>
#include <fcntl.h>
#ifdef __OpenBSD__
#include <util.h>
#else
#include <libutil.h>
#endif
#include <paths.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "id.h"
#include "timer.h"
#include "fsm.h"
#include "iplist.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ip.h"
#include "ipcp.h"
#include "filter.h"
#include "descriptor.h"
#include "route.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"
#include "async.h"
#include "physical.h"
#include "auth.h"
#include "proto.h"
#include "chap.h"
#include "tun.h"
#include "prompt.h"
#include "chat.h"
#include "cbcp.h"
#include "datalink.h"
#include "iface.h"
#include "server.h"
#include "probe.h"
#ifndef NODES
#include "mppe.h"
#endif

#define SCATTER_SEGMENTS 7  /* version, datalink, name, physical,
                               throughput, throughput, device       */

#define SEND_MAXFD 3        /* Max file descriptors passed through
                               the local domain socket              */

static int bundle_RemainingIdleTime(struct bundle *);

static const char * const PhaseNames[] = {
  "Dead", "Establish", "Authenticate", "Network", "Terminate"
};

const char *
bundle_PhaseName(struct bundle *bundle)
{
  return bundle->phase <= PHASE_TERMINATE ?
    PhaseNames[bundle->phase] : "unknown";
}

void
bundle_NewPhase(struct bundle *bundle, u_int new)
{
  if (new == bundle->phase)
    return;

  if (new <= PHASE_TERMINATE)
    log_Printf(LogPHASE, "bundle: %s\n", PhaseNames[new]);

  switch (new) {
  case PHASE_DEAD:
    bundle->phase = new;
#ifndef NODES
    MPPE_MasterKeyValid = 0;
#endif
    log_DisplayPrompts();
    break;

  case PHASE_ESTABLISH:
    bundle->phase = new;
    break;

  case PHASE_AUTHENTICATE:
    bundle->phase = new;
    log_DisplayPrompts();
    break;

  case PHASE_NETWORK:
    if (ncp_fsmStart(&bundle->ncp, bundle)) {
      bundle->phase = new;
      log_DisplayPrompts();
    } else {
      log_Printf(LogPHASE, "bundle: All NCPs are disabled\n");
      bundle_Close(bundle, NULL, CLOSE_STAYDOWN);
    }
    break;

  case PHASE_TERMINATE:
    bundle->phase = new;
    mp_Down(&bundle->ncp.mp);
    log_DisplayPrompts();
    break;
  }
}

static void
bundle_LayerStart(void *v, struct fsm *fp)
{
  /* The given FSM is about to start up ! */
}


void
bundle_Notify(struct bundle *bundle, char c)
{
  if (bundle->notify.fd != -1) {
    int ret;

    ret = write(bundle->notify.fd, &c, 1);
    if (c != EX_REDIAL && c != EX_RECONNECT) {
      if (ret == 1)
        log_Printf(LogCHAT, "Parent notified of %s\n",
                   c == EX_NORMAL ? "success" : "failure");
      else
        log_Printf(LogERROR, "Failed to notify parent of success\n");
      close(bundle->notify.fd);
      bundle->notify.fd = -1;
    } else if (ret == 1)
      log_Printf(LogCHAT, "Parent notified of %s\n", ex_desc(c));
    else
      log_Printf(LogERROR, "Failed to notify parent of %s\n", ex_desc(c));
  }
}

static void
bundle_ClearQueues(void *v)
{
  struct bundle *bundle = (struct bundle *)v;
  struct datalink *dl;

  log_Printf(LogPHASE, "Clearing choked output queue\n");
  timer_Stop(&bundle->choked.timer);

  /*
   * Emergency time:
   *
   * We've had a full queue for PACKET_DEL_SECS seconds without being
   * able to get rid of any of the packets.  We've probably given up
   * on the redials at this point, and the queued data has almost
   * definitely been timed out by the layer above.  As this is preventing
   * us from reading the TUN_NAME device (we don't want to buffer stuff
   * indefinitely), we may as well nuke this data and start with a clean
   * slate !
   *
   * Unfortunately, this has the side effect of shafting any compression
   * dictionaries in use (causing the relevant RESET_REQ/RESET_ACK).
   */

  ncp_DeleteQueues(&bundle->ncp);
  for (dl = bundle->links; dl; dl = dl->next)
    physical_DeleteQueue(dl->physical);
}

static void
bundle_LinkAdded(struct bundle *bundle, struct datalink *dl)
{
  bundle->phys_type.all |= dl->physical->type;
  if (dl->state == DATALINK_OPEN)
    bundle->phys_type.open |= dl->physical->type;

#ifndef NORADIUS
  if ((bundle->phys_type.open & (PHYS_DEDICATED|PHYS_DDIAL))
      != bundle->phys_type.open && bundle->session.timer.state == TIMER_STOPPED)
    if (bundle->radius.sessiontime)
      bundle_StartSessionTimer(bundle, 0);
#endif

  if ((bundle->phys_type.open & (PHYS_DEDICATED|PHYS_DDIAL))
      != bundle->phys_type.open && bundle->idle.timer.state == TIMER_STOPPED)
    /* We may need to start our idle timer */
    bundle_StartIdleTimer(bundle, 0);
}

void
bundle_LinksRemoved(struct bundle *bundle)
{
  struct datalink *dl;

  bundle->phys_type.all = bundle->phys_type.open = 0;
  for (dl = bundle->links; dl; dl = dl->next)
    bundle_LinkAdded(bundle, dl);

  bundle_CalculateBandwidth(bundle);
  mp_CheckAutoloadTimer(&bundle->ncp.mp);

  if ((bundle->phys_type.open & (PHYS_DEDICATED|PHYS_DDIAL))
      == bundle->phys_type.open) {
#ifndef NORADIUS
    if (bundle->radius.sessiontime)
      bundle_StopSessionTimer(bundle);
#endif
    bundle_StopIdleTimer(bundle);
   }
}

static void
bundle_LayerUp(void *v, struct fsm *fp)
{
  /*
   * The given fsm is now up
   * If it's an LCP, adjust our phys_mode.open value and check the
   * autoload timer.
   * If it's the first NCP, calculate our bandwidth
   * If it's the first NCP, set our ``upat'' time
   * If it's the first NCP, start the idle timer.
   * If it's an NCP, tell our -background parent to go away.
   * If it's the first NCP, start the autoload timer
   */
  struct bundle *bundle = (struct bundle *)v;

  if (fp->proto == PROTO_LCP) {
    struct physical *p = link2physical(fp->link);

    bundle_LinkAdded(bundle, p->dl);
    mp_CheckAutoloadTimer(&bundle->ncp.mp);
  } else if (isncp(fp->proto)) {
    if (ncp_LayersOpen(&fp->bundle->ncp) == 1) {
      bundle_CalculateBandwidth(fp->bundle);
      time(&bundle->upat);
#ifndef NORADIUS
      if (bundle->radius.sessiontime)
        bundle_StartSessionTimer(bundle, 0);
#endif
      bundle_StartIdleTimer(bundle, 0);
      mp_CheckAutoloadTimer(&fp->bundle->ncp.mp);
    }
    bundle_Notify(bundle, EX_NORMAL);
  } else if (fp->proto == PROTO_CCP)
    bundle_CalculateBandwidth(fp->bundle);	/* Against ccp_MTUOverhead */
}

static void
bundle_LayerDown(void *v, struct fsm *fp)
{
  /*
   * The given FSM has been told to come down.
   * If it's our last NCP, stop the idle timer.
   * If it's our last NCP, clear our ``upat'' value.
   * If it's our last NCP, stop the autoload timer
   * If it's an LCP, adjust our phys_type.open value and any timers.
   * If it's an LCP and we're in multilink mode, adjust our tun
   * If it's the last LCP, down all NCPs
   * speed and make sure our minimum sequence number is adjusted.
   */

  struct bundle *bundle = (struct bundle *)v;

  if (isncp(fp->proto)) {
    if (ncp_LayersOpen(&fp->bundle->ncp) == 0) {
#ifndef NORADIUS
      if (bundle->radius.sessiontime)
        bundle_StopSessionTimer(bundle);
#endif
      bundle_StopIdleTimer(bundle);
      bundle->upat = 0;
      mp_StopAutoloadTimer(&bundle->ncp.mp);
    }
  } else if (fp->proto == PROTO_LCP) {
    struct datalink *dl;
    struct datalink *lost;
    int others_active;

    bundle_LinksRemoved(bundle);  /* adjust timers & phys_type values */

    lost = NULL;
    others_active = 0;
    for (dl = bundle->links; dl; dl = dl->next) {
      if (fp == &dl->physical->link.lcp.fsm)
        lost = dl;
      else if (dl->state != DATALINK_CLOSED && dl->state != DATALINK_HANGUP)
        others_active++;
    }

    if (bundle->ncp.mp.active) {
      bundle_CalculateBandwidth(bundle);

      if (lost)
        mp_LinkLost(&bundle->ncp.mp, lost);
      else
        log_Printf(LogALERT, "Oops, lost an unrecognised datalink (%s) !\n",
                   fp->link->name);
    }

    if (!others_active) {
      /* Down the NCPs.  We don't expect to get fsm_Close()d ourself ! */
      ncp2initial(&bundle->ncp);
      mp_Down(&bundle->ncp.mp);
    }
  }
}

static void
bundle_LayerFinish(void *v, struct fsm *fp)
{
  /* The given fsm is now down (fp cannot be NULL)
   *
   * If it's the last NCP, fsm_Close all LCPs
   * If it's the last NCP, bring any MP layer down
   */

  struct bundle *bundle = (struct bundle *)v;
  struct datalink *dl;

  if (isncp(fp->proto) && !ncp_LayersUnfinished(&bundle->ncp)) {
    if (bundle_Phase(bundle) != PHASE_DEAD)
      bundle_NewPhase(bundle, PHASE_TERMINATE);
    for (dl = bundle->links; dl; dl = dl->next)
      if (dl->state == DATALINK_OPEN)
        datalink_Close(dl, CLOSE_STAYDOWN);
    fsm2initial(fp);
    mp_Down(&bundle->ncp.mp);
  }
}

void
bundle_Close(struct bundle *bundle, const char *name, int how)
{
  /*
   * Please close the given datalink.
   * If name == NULL or name is the last datalink, fsm_Close all NCPs
   * (except our MP)
   * If it isn't the last datalink, just Close that datalink.
   */

  struct datalink *dl, *this_dl;
  int others_active;

  others_active = 0;
  this_dl = NULL;

  for (dl = bundle->links; dl; dl = dl->next) {
    if (name && !strcasecmp(name, dl->name))
      this_dl = dl;
    if (name == NULL || this_dl == dl) {
      switch (how) {
        case CLOSE_LCP:
          datalink_DontHangup(dl);
          break;
        case CLOSE_STAYDOWN:
          datalink_StayDown(dl);
          break;
      }
    } else if (dl->state != DATALINK_CLOSED && dl->state != DATALINK_HANGUP)
      others_active++;
  }

  if (name && this_dl == NULL) {
    log_Printf(LogWARN, "%s: Invalid datalink name\n", name);
    return;
  }

  if (!others_active) {
#ifndef NORADIUS
    if (bundle->radius.sessiontime)
      bundle_StopSessionTimer(bundle);
#endif
    bundle_StopIdleTimer(bundle);
    if (ncp_LayersUnfinished(&bundle->ncp))
      ncp_Close(&bundle->ncp);
    else {
      ncp2initial(&bundle->ncp);
      mp_Down(&bundle->ncp.mp);
      for (dl = bundle->links; dl; dl = dl->next)
        datalink_Close(dl, how);
    }
  } else if (this_dl && this_dl->state != DATALINK_CLOSED &&
             this_dl->state != DATALINK_HANGUP)
    datalink_Close(this_dl, how);
}

void
bundle_Down(struct bundle *bundle, int how)
{
  struct datalink *dl;

  for (dl = bundle->links; dl; dl = dl->next)
    datalink_Down(dl, how);
}

static int
bundle_UpdateSet(struct fdescriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
{
  struct bundle *bundle = descriptor2bundle(d);
  struct datalink *dl;
  int result, nlinks;
  u_short ifqueue;
  size_t queued;

  result = 0;

  /* If there are aren't many packets queued, look for some more. */
  for (nlinks = 0, dl = bundle->links; dl; dl = dl->next)
    nlinks++;

  if (nlinks) {
    queued = r ? ncp_FillPhysicalQueues(&bundle->ncp, bundle) :
                 ncp_QueueLen(&bundle->ncp);

    if (r && (bundle->phase == PHASE_NETWORK ||
              bundle->phys_type.all & PHYS_AUTO)) {
      /* enough surplus so that we can tell if we're getting swamped */
      ifqueue = nlinks > bundle->cfg.ifqueue ? nlinks : bundle->cfg.ifqueue;
      if (queued < ifqueue) {
        /* Not enough - select() for more */
        if (bundle->choked.timer.state == TIMER_RUNNING)
          timer_Stop(&bundle->choked.timer);	/* Not needed any more */
        FD_SET(bundle->dev.fd, r);
        if (*n < bundle->dev.fd + 1)
          *n = bundle->dev.fd + 1;
        log_Printf(LogTIMER, "%s: fdset(r) %d\n", TUN_NAME, bundle->dev.fd);
        result++;
      } else if (bundle->choked.timer.state == TIMER_STOPPED) {
        bundle->choked.timer.func = bundle_ClearQueues;
        bundle->choked.timer.name = "output choke";
        bundle->choked.timer.load = bundle->cfg.choked.timeout * SECTICKS;
        bundle->choked.timer.arg = bundle;
        timer_Start(&bundle->choked.timer);
      }
    }
  }

#ifndef NORADIUS
  result += descriptor_UpdateSet(&bundle->radius.desc, r, w, e, n);
#endif

  /* Which links need a select() ? */
  for (dl = bundle->links; dl; dl = dl->next)
    result += descriptor_UpdateSet(&dl->desc, r, w, e, n);

  /*
   * This *MUST* be called after the datalink UpdateSet()s as it
   * might be ``holding'' one of the datalinks (death-row) and
   * wants to be able to de-select() it from the descriptor set.
   */
  result += descriptor_UpdateSet(&bundle->ncp.mp.server.desc, r, w, e, n);

  return result;
}

static int
bundle_IsSet(struct fdescriptor *d, const fd_set *fdset)
{
  struct bundle *bundle = descriptor2bundle(d);
  struct datalink *dl;

  for (dl = bundle->links; dl; dl = dl->next)
    if (descriptor_IsSet(&dl->desc, fdset))
      return 1;

#ifndef NORADIUS
  if (descriptor_IsSet(&bundle->radius.desc, fdset))
    return 1;
#endif

  if (descriptor_IsSet(&bundle->ncp.mp.server.desc, fdset))
    return 1;

  return FD_ISSET(bundle->dev.fd, fdset);
}

static void
bundle_DescriptorRead(struct fdescriptor *d, struct bundle *bundle,
                      const fd_set *fdset)
{
  struct datalink *dl;
  unsigned secs;
  u_int32_t af;

  if (descriptor_IsSet(&bundle->ncp.mp.server.desc, fdset))
    descriptor_Read(&bundle->ncp.mp.server.desc, bundle, fdset);

  for (dl = bundle->links; dl; dl = dl->next)
    if (descriptor_IsSet(&dl->desc, fdset))
      descriptor_Read(&dl->desc, bundle, fdset);

#ifndef NORADIUS
  if (descriptor_IsSet(&bundle->radius.desc, fdset))
    descriptor_Read(&bundle->radius.desc, bundle, fdset);
#endif

  if (FD_ISSET(bundle->dev.fd, fdset)) {
    struct tun_data tun;
    int n, pri;
    u_char *data;
    size_t sz;

    if (bundle->dev.header) {
      data = (u_char *)&tun;
      sz = sizeof tun;
    } else {
      data = tun.data;
      sz = sizeof tun.data;
    }

    /* something to read from tun */

    n = read(bundle->dev.fd, data, sz);
    if (n < 0) {
      log_Printf(LogWARN, "%s: read: %s\n", bundle->dev.Name, strerror(errno));
      return;
    }

    if (bundle->dev.header) {
      n -= sz - sizeof tun.data;
      if (n <= 0) {
        log_Printf(LogERROR, "%s: read: Got only %d bytes of data !\n",
                   bundle->dev.Name, n);
        return;
      }
      af = ntohl(tun.header.family);
#ifndef NOINET6
      if (af != AF_INET && af != AF_INET6)
#else
      if (af != AF_INET)
#endif
        /* XXX: Should be maintaining drop/family counts ! */
        return;
    } else
      af = AF_INET;

    if (af == AF_INET && ((struct ip *)tun.data)->ip_dst.s_addr ==
        bundle->ncp.ipcp.my_ip.s_addr) {
      /* we've been asked to send something addressed *to* us :( */
      if (Enabled(bundle, OPT_LOOPBACK)) {
        pri = PacketCheck(bundle, af, tun.data, n, &bundle->filter.in,
                          NULL, NULL);
        if (pri >= 0) {
          n += sz - sizeof tun.data;
          write(bundle->dev.fd, data, n);
          log_Printf(LogDEBUG, "Looped back packet addressed to myself\n");
        }
        return;
      } else
        log_Printf(LogDEBUG, "Oops - forwarding packet addressed to myself\n");
    }

    /*
     * Process on-demand dialup. Output packets are queued within the tunnel
     * device until the appropriate NCP is opened.
     */

    if (bundle_Phase(bundle) == PHASE_DEAD) {
      /*
       * Note, we must be in AUTO mode :-/ otherwise our interface should
       * *not* be UP and we can't receive data
       */
      pri = PacketCheck(bundle, af, tun.data, n, &bundle->filter.dial,
                        NULL, NULL);
      if (pri >= 0)
        bundle_Open(bundle, NULL, PHYS_AUTO, 0);
      else
        /*
         * Drop the packet.  If we were to queue it, we'd just end up with
         * a pile of timed-out data in our output queue by the time we get
         * around to actually dialing.  We'd also prematurely reach the
         * threshold at which we stop select()ing to read() the tun
         * device - breaking auto-dial.
         */
        return;
    }

    secs = 0;
    pri = PacketCheck(bundle, af, tun.data, n, &bundle->filter.out,
                      NULL, &secs);
    if (pri >= 0) {
      /* Prepend the number of seconds timeout given in the filter */
      tun.header.timeout = secs;
      ncp_Enqueue(&bundle->ncp, af, pri, (char *)&tun, n + sizeof tun.header);
    }
  }
}

static int
bundle_DescriptorWrite(struct fdescriptor *d, struct bundle *bundle,
                       const fd_set *fdset)
{
  struct datalink *dl;
  int result = 0;

  /* This is not actually necessary as struct mpserver doesn't Write() */
  if (descriptor_IsSet(&bundle->ncp.mp.server.desc, fdset))
    if (descriptor_Write(&bundle->ncp.mp.server.desc, bundle, fdset) == 1)
      result++;

  for (dl = bundle->links; dl; dl = dl->next)
    if (descriptor_IsSet(&dl->desc, fdset))
      switch (descriptor_Write(&dl->desc, bundle, fdset)) {
      case -1:
        datalink_ComeDown(dl, CLOSE_NORMAL);
        break;
      case 1:
        result++;
      }

  return result;
}

void
bundle_LockTun(struct bundle *bundle)
{
  FILE *lockfile;
  char pidfile[PATH_MAX];

  snprintf(pidfile, sizeof pidfile, "%stun%d.pid", _PATH_VARRUN, bundle->unit);
  lockfile = ID0fopen(pidfile, "w");
  if (lockfile != NULL) {
    fprintf(lockfile, "%d\n", (int)getpid());
    fclose(lockfile);
  }
#ifndef RELEASE_CRUNCH
  else
    log_Printf(LogERROR, "Warning: Can't create %s: %s\n",
               pidfile, strerror(errno));
#endif
}

static void
bundle_UnlockTun(struct bundle *bundle)
{
  char pidfile[PATH_MAX];

  snprintf(pidfile, sizeof pidfile, "%stun%d.pid", _PATH_VARRUN, bundle->unit);
  ID0unlink(pidfile);
}

struct bundle *
bundle_Create(const char *prefix, int type, int unit)
{
  static struct bundle bundle;		/* there can be only one */
  int enoentcount, err, minunit, maxunit;
  const char *ifname;
#if defined(__FreeBSD__) && !defined(NOKLDLOAD)
  int kldtried;
#endif
#if defined(TUNSIFMODE) || defined(TUNSLMODE) || defined(TUNSIFHEAD)
  int iff;
#endif

  if (bundle.iface != NULL) {	/* Already allocated ! */
    log_Printf(LogALERT, "bundle_Create:  There's only one BUNDLE !\n");
    return NULL;
  }

  if (unit == -1) {
    minunit = 0;
    maxunit = -1;
  } else {
    minunit = unit;
    maxunit = unit + 1;
  }
  err = ENOENT;
  enoentcount = 0;
#if defined(__FreeBSD__) && !defined(NOKLDLOAD)
  kldtried = 0;
#endif
  for (bundle.unit = minunit; bundle.unit != maxunit; bundle.unit++) {
    snprintf(bundle.dev.Name, sizeof bundle.dev.Name, "%s%d",
             prefix, bundle.unit);
    bundle.dev.fd = ID0open(bundle.dev.Name, O_RDWR);
    if (bundle.dev.fd >= 0)
      break;
    else if (errno == ENXIO || errno == ENOENT) {
#if defined(__FreeBSD__) && !defined(NOKLDLOAD)
      if (bundle.unit == minunit && !kldtried++) {
        /*
         * Attempt to load the tunnel interface KLD if it isn't loaded
         * already.
         */
        if (loadmodules(LOAD_VERBOSLY, "if_tun", NULL))
          bundle.unit--;
        continue;
      }
#endif
      if (errno != ENOENT || ++enoentcount > 2) {
        err = errno;
	break;
      }
    } else
      err = errno;
  }

  if (bundle.dev.fd < 0) {
    if (unit == -1)
      log_Printf(LogWARN, "No available tunnel devices found (%s)\n",
                strerror(err));
    else
      log_Printf(LogWARN, "%s%d: %s\n", prefix, unit, strerror(err));
    return NULL;
  }

  log_SetTun(bundle.unit);

  ifname = strrchr(bundle.dev.Name, '/');
  if (ifname == NULL)
    ifname = bundle.dev.Name;
  else
    ifname++;

  bundle.iface = iface_Create(ifname);
  if (bundle.iface == NULL) {
    close(bundle.dev.fd);
    return NULL;
  }

#ifdef TUNSIFMODE
  /* Make sure we're POINTOPOINT & IFF_MULTICAST */
  iff = IFF_POINTOPOINT | IFF_MULTICAST;
  if (ID0ioctl(bundle.dev.fd, TUNSIFMODE, &iff) < 0)
    log_Printf(LogERROR, "bundle_Create: ioctl(TUNSIFMODE): %s\n",
	       strerror(errno));
#endif

#ifdef TUNSLMODE
  /* Make sure we're not prepending sockaddrs */
  iff = 0;
  if (ID0ioctl(bundle.dev.fd, TUNSLMODE, &iff) < 0)
    log_Printf(LogERROR, "bundle_Create: ioctl(TUNSLMODE): %s\n",
	       strerror(errno));
#endif

#ifdef TUNSIFHEAD
  /* We want the address family please ! */
  iff = 1;
  if (ID0ioctl(bundle.dev.fd, TUNSIFHEAD, &iff) < 0) {
    log_Printf(LogERROR, "bundle_Create: ioctl(TUNSIFHEAD): %s\n",
	       strerror(errno));
    bundle.dev.header = 0;
  } else
    bundle.dev.header = 1;
#else
#ifdef __OpenBSD__
  /* Always present for OpenBSD */
  bundle.dev.header = 1;
#else
  /*
   * If TUNSIFHEAD isn't available and we're not OpenBSD, assume
   * everything's AF_INET (hopefully the tun device won't pass us
   * anything else !).
   */
  bundle.dev.header = 0;
#endif
#endif

  log_Printf(LogPHASE, "Using interface: %s\n", ifname);

  bundle.bandwidth = 0;
  bundle.routing_seq = 0;
  bundle.phase = PHASE_DEAD;
  bundle.CleaningUp = 0;
  bundle.NatEnabled = 0;

  bundle.fsm.LayerStart = bundle_LayerStart;
  bundle.fsm.LayerUp = bundle_LayerUp;
  bundle.fsm.LayerDown = bundle_LayerDown;
  bundle.fsm.LayerFinish = bundle_LayerFinish;
  bundle.fsm.object = &bundle;

  bundle.cfg.idle.timeout = NCP_IDLE_TIMEOUT;
  bundle.cfg.idle.min_timeout = 0;
  *bundle.cfg.auth.name = '\0';
  *bundle.cfg.auth.key = '\0';
  bundle.cfg.optmask = (1ull << OPT_IDCHECK) | (1ull << OPT_LOOPBACK) |
                       (1ull << OPT_SROUTES) | (1ull << OPT_TCPMSSFIXUP) |
                       (1ull << OPT_THROUGHPUT) | (1ull << OPT_UTMP) |
                       (1ull << OPT_NAS_IP_ADDRESS) |
                       (1ull << OPT_NAS_IDENTIFIER);
#ifndef NOINET6
  opt_enable(&bundle, OPT_IPCP);
  if (probe.ipv6_available)
    opt_enable(&bundle, OPT_IPV6CP);
#endif
  *bundle.cfg.label = '\0';
  bundle.cfg.ifqueue = DEF_IFQUEUE;
  bundle.cfg.choked.timeout = CHOKED_TIMEOUT;
  bundle.phys_type.all = type;
  bundle.phys_type.open = 0;
  bundle.upat = 0;

  bundle.links = datalink_Create("deflink", &bundle, type);
  if (bundle.links == NULL) {
    log_Printf(LogALERT, "Cannot create data link: %s\n", strerror(errno));
    iface_Destroy(bundle.iface);
    bundle.iface = NULL;
    close(bundle.dev.fd);
    return NULL;
  }

  bundle.desc.type = BUNDLE_DESCRIPTOR;
  bundle.desc.UpdateSet = bundle_UpdateSet;
  bundle.desc.IsSet = bundle_IsSet;
  bundle.desc.Read = bundle_DescriptorRead;
  bundle.desc.Write = bundle_DescriptorWrite;

  ncp_Init(&bundle.ncp, &bundle);

  memset(&bundle.filter, '\0', sizeof bundle.filter);
  bundle.filter.in.fragok = bundle.filter.in.logok = 1;
  bundle.filter.in.name = "IN";
  bundle.filter.out.fragok = bundle.filter.out.logok = 1;
  bundle.filter.out.name = "OUT";
  bundle.filter.dial.name = "DIAL";
  bundle.filter.dial.logok = 1;
  bundle.filter.alive.name = "ALIVE";
  bundle.filter.alive.logok = 1;
  {
    int	i;
    for (i = 0; i < MAXFILTERS; i++) {
        bundle.filter.in.rule[i].f_action = A_NONE;
        bundle.filter.out.rule[i].f_action = A_NONE;
        bundle.filter.dial.rule[i].f_action = A_NONE;
        bundle.filter.alive.rule[i].f_action = A_NONE;
    }
  }
  memset(&bundle.idle.timer, '\0', sizeof bundle.idle.timer);
  bundle.idle.done = 0;
  bundle.notify.fd = -1;
  memset(&bundle.choked.timer, '\0', sizeof bundle.choked.timer);
#ifndef NORADIUS
  radius_Init(&bundle.radius);
#endif

  /* Clean out any leftover crud */
  iface_Clear(bundle.iface, &bundle.ncp, 0, IFACE_CLEAR_ALL);

  bundle_LockTun(&bundle);

  return &bundle;
}

static void
bundle_DownInterface(struct bundle *bundle)
{
  route_IfDelete(bundle, 1);
  iface_ClearFlags(bundle->iface->name, IFF_UP);
}

void
bundle_Destroy(struct bundle *bundle)
{
  struct datalink *dl;

  /*
   * Clean up the interface.  We don't really need to do the timer_Stop()s,
   * mp_Down(), iface_Clear() and bundle_DownInterface() unless we're getting
   * out under exceptional conditions such as a descriptor exception.
   */
  timer_Stop(&bundle->idle.timer);
  timer_Stop(&bundle->choked.timer);
  mp_Down(&bundle->ncp.mp);
  iface_Clear(bundle->iface, &bundle->ncp, 0, IFACE_CLEAR_ALL);
  bundle_DownInterface(bundle);

#ifndef NORADIUS
  /* Tell the radius server the bad news */
  radius_Destroy(&bundle->radius);
#endif

  /* Again, these are all DATALINK_CLOSED unless we're abending */
  dl = bundle->links;
  while (dl)
    dl = datalink_Destroy(dl);

  ncp_Destroy(&bundle->ncp);

  close(bundle->dev.fd);
  bundle_UnlockTun(bundle);

  /* In case we never made PHASE_NETWORK */
  bundle_Notify(bundle, EX_ERRDEAD);

  iface_Destroy(bundle->iface);
  bundle->iface = NULL;
}

void
bundle_LinkClosed(struct bundle *bundle, struct datalink *dl)
{
  /*
   * Our datalink has closed.
   * CleanDatalinks() (called from DoLoop()) will remove closed
   * BACKGROUND, FOREGROUND and DIRECT links.
   * If it's the last data link, enter phase DEAD.
   *
   * NOTE: dl may not be in our list (bundle_SendDatalink()) !
   */

  struct datalink *odl;
  int other_links;

  log_SetTtyCommandMode(dl);

  other_links = 0;
  for (odl = bundle->links; odl; odl = odl->next)
    if (odl != dl && odl->state != DATALINK_CLOSED)
      other_links++;

  if (!other_links) {
    if (dl->physical->type != PHYS_AUTO)	/* Not in -auto mode */
      bundle_DownInterface(bundle);
    ncp2initial(&bundle->ncp);
    mp_Down(&bundle->ncp.mp);
    bundle_NewPhase(bundle, PHASE_DEAD);
#ifndef NORADIUS
    if (bundle->radius.sessiontime)
      bundle_StopSessionTimer(bundle);
#endif
    bundle_StopIdleTimer(bundle);
  }
}

void
bundle_Open(struct bundle *bundle, const char *name, int mask, int force)
{
  /*
   * Please open the given datalink, or all if name == NULL
   */
  struct datalink *dl;

  for (dl = bundle->links; dl; dl = dl->next)
    if (name == NULL || !strcasecmp(dl->name, name)) {
      if ((mask & dl->physical->type) &&
          (dl->state == DATALINK_CLOSED ||
           (force && dl->state == DATALINK_OPENING &&
            dl->dial.timer.state == TIMER_RUNNING) ||
           dl->state == DATALINK_READY)) {
        timer_Stop(&dl->dial.timer);	/* We're finished with this */
        datalink_Up(dl, 1, 1);
        if (mask & PHYS_AUTO)
          break;			/* Only one AUTO link at a time */
      }
      if (name != NULL)
        break;
    }
}

struct datalink *
bundle2datalink(struct bundle *bundle, const char *name)
{
  struct datalink *dl;

  if (name != NULL) {
    for (dl = bundle->links; dl; dl = dl->next)
      if (!strcasecmp(dl->name, name))
        return dl;
  } else if (bundle->links && !bundle->links->next)
    return bundle->links;

  return NULL;
}

int
bundle_ShowLinks(struct cmdargs const *arg)
{
  struct datalink *dl;
  struct pppThroughput *t;
  unsigned long long octets;
  int secs;

  for (dl = arg->bundle->links; dl; dl = dl->next) {
    octets = MAX(dl->physical->link.stats.total.in.OctetsPerSecond,
                 dl->physical->link.stats.total.out.OctetsPerSecond);

    prompt_Printf(arg->prompt, "Name: %s [%s, %s]",
                  dl->name, mode2Nam(dl->physical->type), datalink_State(dl));
    if (dl->physical->link.stats.total.rolling && dl->state == DATALINK_OPEN)
      prompt_Printf(arg->prompt, " bandwidth %d, %llu bps (%llu bytes/sec)",
                    dl->mp.bandwidth ? dl->mp.bandwidth :
                                       physical_GetSpeed(dl->physical),
                    octets * 8, octets);
    prompt_Printf(arg->prompt, "\n");
  }

  t = &arg->bundle->ncp.mp.link.stats.total;
  octets = MAX(t->in.OctetsPerSecond, t->out.OctetsPerSecond);
  secs = t->downtime ? 0 : throughput_uptime(t);
  if (secs > t->SamplePeriod)
    secs = t->SamplePeriod;
  if (secs)
    prompt_Printf(arg->prompt, "Currently averaging %llu bps (%llu bytes/sec)"
                  " over the last %d secs\n", octets * 8, octets, secs);

  return 0;
}

static const char *
optval(struct bundle *bundle, int opt)
{
  return Enabled(bundle, opt) ? "enabled" : "disabled";
}

int
bundle_ShowStatus(struct cmdargs const *arg)
{
  int remaining;

  prompt_Printf(arg->prompt, "Phase %s\n", bundle_PhaseName(arg->bundle));
  prompt_Printf(arg->prompt, " Device:        %s\n", arg->bundle->dev.Name);
  prompt_Printf(arg->prompt, " Interface:     %s @@ %lubps",
                arg->bundle->iface->name, arg->bundle->bandwidth);

  if (arg->bundle->upat) {
    int secs = bundle_Uptime(arg->bundle);

    prompt_Printf(arg->prompt, ", up time %d:%02d:%02d", secs / 3600,
                  (secs / 60) % 60, secs % 60);
  }
  prompt_Printf(arg->prompt, "\n Queued:        %lu of %u\n",
                (unsigned long)ncp_QueueLen(&arg->bundle->ncp),
                arg->bundle->cfg.ifqueue);

  prompt_Printf(arg->prompt, "\nDefaults:\n");
  prompt_Printf(arg->prompt, " Label:             %s\n",
                arg->bundle->cfg.label);
  prompt_Printf(arg->prompt, " Auth name:         %s\n",
                arg->bundle->cfg.auth.name);
  prompt_Printf(arg->prompt, " Diagnostic socket: ");
  if (*server.cfg.sockname != '\0') {
    prompt_Printf(arg->prompt, "%s", server.cfg.sockname);
    if (server.cfg.mask != (mode_t)-1)
      prompt_Printf(arg->prompt, ", mask 0%03o", (int)server.cfg.mask);
    prompt_Printf(arg->prompt, "%s\n", server.fd == -1 ? " (not open)" : "");
  } else if (server.cfg.port != 0)
    prompt_Printf(arg->prompt, "TCP port %d%s\n", server.cfg.port,
                  server.fd == -1 ? " (not open)" : "");
  else
    prompt_Printf(arg->prompt, "none\n");

  prompt_Printf(arg->prompt, " Choked Timer:      %ds\n",
                arg->bundle->cfg.choked.timeout);

#ifndef NORADIUS
  radius_Show(&arg->bundle->radius, arg->prompt);
#endif

  prompt_Printf(arg->prompt, " Idle Timer:        ");
  if (arg->bundle->cfg.idle.timeout) {
    prompt_Printf(arg->prompt, "%ds", arg->bundle->cfg.idle.timeout);
    if (arg->bundle->cfg.idle.min_timeout)
      prompt_Printf(arg->prompt, ", min %ds",
                    arg->bundle->cfg.idle.min_timeout);
    remaining = bundle_RemainingIdleTime(arg->bundle);
    if (remaining != -1)
      prompt_Printf(arg->prompt, " (%ds remaining)", remaining);
    prompt_Printf(arg->prompt, "\n");
  } else
    prompt_Printf(arg->prompt, "disabled\n");

  prompt_Printf(arg->prompt, " Filter Decap:      %-20.20s",
                optval(arg->bundle, OPT_FILTERDECAP));
  prompt_Printf(arg->prompt, " ID check:          %s\n",
                optval(arg->bundle, OPT_IDCHECK));
  prompt_Printf(arg->prompt, " Iface-Alias:       %-20.20s",
                optval(arg->bundle, OPT_IFACEALIAS));
#ifndef NOINET6
  prompt_Printf(arg->prompt, " IPCP:              %s\n",
                optval(arg->bundle, OPT_IPCP));
  prompt_Printf(arg->prompt, " IPV6CP:            %-20.20s",
                optval(arg->bundle, OPT_IPV6CP));
#endif
  prompt_Printf(arg->prompt, " Keep-Session:      %s\n",
                optval(arg->bundle, OPT_KEEPSESSION));
  prompt_Printf(arg->prompt, " Loopback:          %-20.20s",
                optval(arg->bundle, OPT_LOOPBACK));
  prompt_Printf(arg->prompt, " PasswdAuth:        %s\n",
                optval(arg->bundle, OPT_PASSWDAUTH));
  prompt_Printf(arg->prompt, " Proxy:             %-20.20s",
                optval(arg->bundle, OPT_PROXY));
  prompt_Printf(arg->prompt, " Proxyall:          %s\n",
                optval(arg->bundle, OPT_PROXYALL));
  prompt_Printf(arg->prompt, " Sticky Routes:     %-20.20s",
                optval(arg->bundle, OPT_SROUTES));
  prompt_Printf(arg->prompt, " TCPMSS Fixup:      %s\n",
                optval(arg->bundle, OPT_TCPMSSFIXUP));
  prompt_Printf(arg->prompt, " Throughput:        %-20.20s",
                optval(arg->bundle, OPT_THROUGHPUT));
  prompt_Printf(arg->prompt, " Utmp Logging:      %s\n",
                optval(arg->bundle, OPT_UTMP));
  prompt_Printf(arg->prompt, " NAS-IP-Address:    %-20.20s",
                optval(arg->bundle, OPT_NAS_IP_ADDRESS));
  prompt_Printf(arg->prompt, " NAS-Identifier:    %s\n",
                optval(arg->bundle, OPT_NAS_IDENTIFIER));

  return 0;
}

static void
bundle_IdleTimeout(void *v)
{
  struct bundle *bundle = (struct bundle *)v;

  log_Printf(LogPHASE, "Idle timer expired\n");
  bundle_StopIdleTimer(bundle);
  bundle_Close(bundle, NULL, CLOSE_STAYDOWN);
}

/*
 *  Start Idle timer. If timeout is reached, we call bundle_Close() to
 *  close LCP and link.
 */
void
bundle_StartIdleTimer(struct bundle *bundle, unsigned secs)
{
  timer_Stop(&bundle->idle.timer);
  if ((bundle->phys_type.open & (PHYS_DEDICATED|PHYS_DDIAL)) !=
      bundle->phys_type.open && bundle->cfg.idle.timeout) {
    time_t now = time(NULL);

    if (secs == 0)
      secs = bundle->cfg.idle.timeout;

    /* We want at least `secs' */
    if (bundle->cfg.idle.min_timeout > secs && bundle->upat) {
      int up = now - bundle->upat;

      if ((long long)bundle->cfg.idle.min_timeout - up > (long long)secs)
        /* Only increase from the current `remaining' value */
        secs = bundle->cfg.idle.min_timeout - up;
    }
    bundle->idle.timer.func = bundle_IdleTimeout;
    bundle->idle.timer.name = "idle";
    bundle->idle.timer.load = secs * SECTICKS;
    bundle->idle.timer.arg = bundle;
    timer_Start(&bundle->idle.timer);
    bundle->idle.done = now + secs;
  }
}

void
bundle_SetIdleTimer(struct bundle *bundle, int timeout, int min_timeout)
{
  bundle->cfg.idle.timeout = timeout;
  if (min_timeout >= 0)
    bundle->cfg.idle.min_timeout = min_timeout;
  if (ncp_LayersOpen(&bundle->ncp))
    bundle_StartIdleTimer(bundle, 0);
}

void
bundle_StopIdleTimer(struct bundle *bundle)
{
  timer_Stop(&bundle->idle.timer);
  bundle->idle.done = 0;
}

static int
bundle_RemainingIdleTime(struct bundle *bundle)
{
  if (bundle->idle.done)
    return bundle->idle.done - time(NULL);
  return -1;
}

#ifndef NORADIUS

static void
bundle_SessionTimeout(void *v)
{
  struct bundle *bundle = (struct bundle *)v;

  log_Printf(LogPHASE, "Session-Timeout timer expired\n");
  bundle_StopSessionTimer(bundle);
  bundle_Close(bundle, NULL, CLOSE_STAYDOWN);
}

void
bundle_StartSessionTimer(struct bundle *bundle, unsigned secs)
{
  timer_Stop(&bundle->session.timer);
  if ((bundle->phys_type.open & (PHYS_DEDICATED|PHYS_DDIAL)) !=
      bundle->phys_type.open && bundle->radius.sessiontime) {
    time_t now = time(NULL);

    if (secs == 0)
      secs = bundle->radius.sessiontime;

    bundle->session.timer.func = bundle_SessionTimeout;
    bundle->session.timer.name = "session";
    bundle->session.timer.load = secs * SECTICKS;
    bundle->session.timer.arg = bundle;
    timer_Start(&bundle->session.timer);
    bundle->session.done = now + secs;
  }
}

void
bundle_StopSessionTimer(struct bundle *bundle)
{
  timer_Stop(&bundle->session.timer);
  bundle->session.done = 0;
}

#endif

int
bundle_IsDead(struct bundle *bundle)
{
  return !bundle->links || (bundle->phase == PHASE_DEAD && bundle->CleaningUp);
}

static struct datalink *
bundle_DatalinkLinkout(struct bundle *bundle, struct datalink *dl)
{
  struct datalink **dlp;

  for (dlp = &bundle->links; *dlp; dlp = &(*dlp)->next)
    if (*dlp == dl) {
      *dlp = dl->next;
      dl->next = NULL;
      bundle_LinksRemoved(bundle);
      return dl;
    }

  return NULL;
}

static void
bundle_DatalinkLinkin(struct bundle *bundle, struct datalink *dl)
{
  struct datalink **dlp = &bundle->links;

  while (*dlp)
    dlp = &(*dlp)->next;

  *dlp = dl;
  dl->next = NULL;

  bundle_LinkAdded(bundle, dl);
  mp_CheckAutoloadTimer(&bundle->ncp.mp);
}

void
bundle_CleanDatalinks(struct bundle *bundle)
{
  struct datalink **dlp = &bundle->links;
  int found = 0;

  while (*dlp)
    if ((*dlp)->state == DATALINK_CLOSED &&
        (*dlp)->physical->type &
        (PHYS_DIRECT|PHYS_BACKGROUND|PHYS_FOREGROUND)) {
      *dlp = datalink_Destroy(*dlp);
      found++;
    } else
      dlp = &(*dlp)->next;

  if (found)
    bundle_LinksRemoved(bundle);
}

int
bundle_DatalinkClone(struct bundle *bundle, struct datalink *dl,
                     const char *name)
{
  if (bundle2datalink(bundle, name)) {
    log_Printf(LogWARN, "Clone: %s: name already exists\n", name);
    return 0;
  }

  bundle_DatalinkLinkin(bundle, datalink_Clone(dl, name));
  return 1;
}

void
bundle_DatalinkRemove(struct bundle *bundle, struct datalink *dl)
{
  dl = bundle_DatalinkLinkout(bundle, dl);
  if (dl)
    datalink_Destroy(dl);
}

void
bundle_SetLabel(struct bundle *bundle, const char *label)
{
  if (label)
    strncpy(bundle->cfg.label, label, sizeof bundle->cfg.label - 1);
  else
    *bundle->cfg.label = '\0';
}

const char *
bundle_GetLabel(struct bundle *bundle)
{
  return *bundle->cfg.label ? bundle->cfg.label : NULL;
}

int
bundle_LinkSize()
{
  struct iovec iov[SCATTER_SEGMENTS];
  int niov, expect, f;

  iov[0].iov_len = strlen(Version) + 1;
  iov[0].iov_base = NULL;
  niov = 1;
  if (datalink2iov(NULL, iov, &niov, SCATTER_SEGMENTS, NULL, NULL) == -1) {
    log_Printf(LogERROR, "Cannot determine space required for link\n");
    return 0;
  }

  for (f = expect = 0; f < niov; f++)
    expect += iov[f].iov_len;

  return expect;
}

void
bundle_ReceiveDatalink(struct bundle *bundle, int s)
{
  union {
    struct cmsghdr hdr;
    char buf[sizeof(struct cmsghdr) + sizeof(int) * SEND_MAXFD];
  } cmsgbuf;
  int niov, expect, f, *fd, nfd, onfd, got;
  struct iovec iov[SCATTER_SEGMENTS];
  struct cmsghdr *cmsg;
  struct msghdr msg;
  struct datalink *dl;
  pid_t pid;

  log_Printf(LogPHASE, "Receiving datalink\n");

  /*
   * Create our scatter/gather array - passing NULL gets the space
   * allocation requirement rather than actually flattening the
   * structures.
   */
  iov[0].iov_len = strlen(Version) + 1;
  iov[0].iov_base = NULL;
  niov = 1;
  if (datalink2iov(NULL, iov, &niov, SCATTER_SEGMENTS, NULL, NULL) == -1) {
    log_Printf(LogERROR, "Cannot determine space required for link\n");
    return;
  }

  /* Allocate the scatter/gather array for recvmsg() */
  for (f = expect = 0; f < niov; f++) {
    if ((iov[f].iov_base = malloc(iov[f].iov_len)) == NULL) {
      log_Printf(LogERROR, "Cannot allocate space to receive link\n");
      return;
    }
    if (f)
      expect += iov[f].iov_len;
  }

  memset(&msg, '\0', sizeof msg);
  msg.msg_name = NULL;
  msg.msg_namelen = 0;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1;		/* Only send the version at the first pass */
  msg.msg_control = cmsgbuf.buf;
  msg.msg_controllen = sizeof(cmsgbuf.buf);
  cmsg = CMSG_FIRSTHDR(&msg);
  cmsg->cmsg_len = sizeof cmsgbuf.buf;
  cmsg->cmsg_level = SOL_SOCKET;
  cmsg->cmsg_type = 0;

  log_Printf(LogDEBUG, "Expecting %u scatter/gather bytes\n",
             (unsigned)iov[0].iov_len);

  if ((got = recvmsg(s, &msg, MSG_WAITALL)) != iov[0].iov_len) {
    if (got == -1)
      log_Printf(LogERROR, "Failed recvmsg: %s\n", strerror(errno));
    else
      log_Printf(LogERROR, "Failed recvmsg: Got %d, not %u\n",
                 got, (unsigned)iov[0].iov_len);
    while (niov--)
      free(iov[niov].iov_base);
    return;
  }

  if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {
    log_Printf(LogERROR, "Recvmsg: no descriptors received !\n");
    while (niov--)
      free(iov[niov].iov_base);
    return;
  }

  fd = (int *)CMSG_DATA(cmsg);
  nfd = ((caddr_t)cmsg + cmsg->cmsg_len - (caddr_t)fd) / sizeof(int);

  if (nfd < 2) {
    log_Printf(LogERROR, "Recvmsg: %d descriptor%s received (too few) !\n",
               nfd, nfd == 1 ? "" : "s");
    while (nfd--)
      close(fd[nfd]);
    while (niov--)
      free(iov[niov].iov_base);
    return;
  }

  /*
   * We've successfully received two or more open file descriptors
   * through our socket, plus a version string.  Make sure it's the
   * correct version, and drop the connection if it's not.
   */
  if (strncmp(Version, iov[0].iov_base, iov[0].iov_len)) {
    log_Printf(LogWARN, "Cannot receive datalink, incorrect version"
               " (\"%.*s\", not \"%s\")\n", (int)iov[0].iov_len,
               (char *)iov[0].iov_base, Version);
    while (nfd--)
      close(fd[nfd]);
    while (niov--)
      free(iov[niov].iov_base);
    return;
  }

  /*
   * Everything looks good.  Send the other side our process id so that
   * they can transfer lock ownership, and wait for them to send the
   * actual link data.
   */
  pid = getpid();
  if ((got = write(fd[1], &pid, sizeof pid)) != sizeof pid) {
    if (got == -1)
      log_Printf(LogERROR, "Failed write: %s\n", strerror(errno));
    else
      log_Printf(LogERROR, "Failed write: Got %d, not %d\n", got,
                 (int)(sizeof pid));
    while (nfd--)
      close(fd[nfd]);
    while (niov--)
      free(iov[niov].iov_base);
    return;
  }

  if ((got = readv(fd[1], iov + 1, niov - 1)) != expect) {
    if (got == -1)
      log_Printf(LogERROR, "Failed write: %s\n", strerror(errno));
    else
      log_Printf(LogERROR, "Failed write: Got %d, not %d\n", got, expect);
    while (nfd--)
      close(fd[nfd]);
    while (niov--)
      free(iov[niov].iov_base);
    return;
  }
  close(fd[1]);

  onfd = nfd;	/* We've got this many in our array */
  nfd -= 2;	/* Don't include p->fd and our reply descriptor */
  niov = 1;	/* Skip the version id */
  dl = iov2datalink(bundle, iov, &niov, sizeof iov / sizeof *iov, fd[0],
                    fd + 2, &nfd);
  if (dl) {

    if (nfd) {
      log_Printf(LogERROR, "bundle_ReceiveDatalink: Failed to handle %d "
                 "auxiliary file descriptors (%d remain)\n", onfd, nfd);
      datalink_Destroy(dl);
      while (nfd--)
        close(fd[onfd--]);
      close(fd[0]);
    } else {
      bundle_DatalinkLinkin(bundle, dl);
      datalink_AuthOk(dl);
      bundle_CalculateBandwidth(dl->bundle);
    }
  } else {
    while (nfd--)
      close(fd[onfd--]);
    close(fd[0]);
    close(fd[1]);
  }

  free(iov[0].iov_base);
}

void
bundle_SendDatalink(struct datalink *dl, int s, struct sockaddr_un *sun)
{
  union {
    struct cmsghdr hdr;
    char buf[CMSG_SPACE(sizeof(int) * SEND_MAXFD)];
  } cmsgbuf;
  const char *constlock;
  char *lock;
  struct cmsghdr *cmsg;
  struct msghdr msg;
  struct iovec iov[SCATTER_SEGMENTS];
  int niov, f, expect, newsid, fd[SEND_MAXFD], nfd, reply[2], got;
  pid_t newpid;

  log_Printf(LogPHASE, "Transmitting datalink %s\n", dl->name);

  /* Record the base device name for a lock transfer later */
  constlock = physical_LockedDevice(dl->physical);
  if (constlock) {
    lock = alloca(strlen(constlock) + 1);
    strlcpy(lock, constlock, strlen(constlock) + 1);
  } else
    lock = NULL;

  bundle_LinkClosed(dl->bundle, dl);
  bundle_DatalinkLinkout(dl->bundle, dl);

  /* Build our scatter/gather array */
  iov[0].iov_len = strlen(Version) + 1;
  iov[0].iov_base = strdup(Version);
  niov = 1;
  nfd = 0;

  fd[0] = datalink2iov(dl, iov, &niov, SCATTER_SEGMENTS, fd + 2, &nfd);

  if (fd[0] != -1 && socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, reply) != -1) {
    /*
     * fd[1] is used to get the peer process id back, then to confirm that
     * we've transferred any device locks to that process id.
     */
    fd[1] = reply[1];

    nfd += 2;			/* Include fd[0] and fd[1] */
    memset(&msg, '\0', sizeof msg);

    msg.msg_name = NULL;
    msg.msg_namelen = 0;
    /*
     * Only send the version to start...  We used to send the whole lot, but
     * this caused problems with our RECVBUF size as a single link is about
     * 22k !  This way, we should bump into no limits.
     */
    msg.msg_iovlen = 1;
    msg.msg_iov = iov;
    msg.msg_control = &cmsgbuf.buf;
    msg.msg_controllen = CMSG_SPACE(sizeof(int) * nfd);
    msg.msg_flags = 0;
    cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_len = msg.msg_controllen;
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;

    for (f = 0; f < nfd; f++)
      *((int *)CMSG_DATA(cmsg) + f) = fd[f];

    for (f = 1, expect = 0; f < niov; f++)
      expect += iov[f].iov_len;

    if (setsockopt(reply[0], SOL_SOCKET, SO_SNDBUF, &expect, sizeof(int)) == -1)
      log_Printf(LogERROR, "setsockopt(SO_RCVBUF, %d): %s\n", expect,
                 strerror(errno));
    if (setsockopt(reply[1], SOL_SOCKET, SO_RCVBUF, &expect, sizeof(int)) == -1)
      log_Printf(LogERROR, "setsockopt(SO_RCVBUF, %d): %s\n", expect,
                 strerror(errno));

    log_Printf(LogDEBUG, "Sending %d descriptor%s and %u bytes in scatter"
               "/gather array\n", nfd, nfd == 1 ? "" : "s",
               (unsigned)iov[0].iov_len);

    if ((got = sendmsg(s, &msg, 0)) == -1)
      log_Printf(LogERROR, "Failed sendmsg: %s: %s\n",
                 sun->sun_path, strerror(errno));
    else if (got != iov[0].iov_len)
      log_Printf(LogERROR, "%s: Failed initial sendmsg: Only sent %d of %u\n",
                 sun->sun_path, got, (unsigned)iov[0].iov_len);
    else {
      /* We must get the ACK before closing the descriptor ! */
      int res;

      if ((got = read(reply[0], &newpid, sizeof newpid)) == sizeof newpid) {
        log_Printf(LogDEBUG, "Received confirmation from pid %ld\n",
                   (long)newpid);
        if (lock && (res = ID0uu_lock_txfr(lock, newpid)) != UU_LOCK_OK)
            log_Printf(LogERROR, "uu_lock_txfr: %s\n", uu_lockerr(res));

        log_Printf(LogDEBUG, "Transmitting link (%d bytes)\n", expect);
        if ((got = writev(reply[0], iov + 1, niov - 1)) != expect) {
          if (got == -1)
            log_Printf(LogERROR, "%s: Failed writev: %s\n",
                       sun->sun_path, strerror(errno));
          else
            log_Printf(LogERROR, "%s: Failed writev: Wrote %d of %d\n",
                       sun->sun_path, got, expect);
        }
      } else if (got == -1)
        log_Printf(LogERROR, "%s: Failed socketpair read: %s\n",
                   sun->sun_path, strerror(errno));
      else
        log_Printf(LogERROR, "%s: Failed socketpair read: Got %d of %d\n",
                   sun->sun_path, got, (int)(sizeof newpid));
    }

    close(reply[0]);
    close(reply[1]);

    newsid = Enabled(dl->bundle, OPT_KEEPSESSION) ||
             tcgetpgrp(fd[0]) == getpgrp();
    while (nfd)
      close(fd[--nfd]);
    if (newsid)
      bundle_setsid(dl->bundle, got != -1);
  }
  close(s);

  while (niov--)
    free(iov[niov].iov_base);
}

int
bundle_RenameDatalink(struct bundle *bundle, struct datalink *ndl,
                      const char *name)
{
  struct datalink *dl;

  if (!strcasecmp(ndl->name, name))
    return 1;

  for (dl = bundle->links; dl; dl = dl->next)
    if (!strcasecmp(dl->name, name))
      return 0;

  datalink_Rename(ndl, name);
  return 1;
}

int
bundle_SetMode(struct bundle *bundle, struct datalink *dl, int mode)
{
  int omode;

  omode = dl->physical->type;
  if (omode == mode)
    return 1;

  if (mode == PHYS_AUTO && !(bundle->phys_type.all & PHYS_AUTO))
    /* First auto link */
    if (bundle->ncp.ipcp.peer_ip.s_addr == INADDR_ANY) {
      log_Printf(LogWARN, "You must `set ifaddr' or `open' before"
                 " changing mode to %s\n", mode2Nam(mode));
      return 0;
    }

  if (!datalink_SetMode(dl, mode))
    return 0;

  if (mode == PHYS_AUTO && !(bundle->phys_type.all & PHYS_AUTO) &&
      bundle->phase != PHASE_NETWORK)
    /* First auto link, we need an interface */
    ipcp_InterfaceUp(&bundle->ncp.ipcp);

  /* Regenerate phys_type and adjust idle timer */
  bundle_LinksRemoved(bundle);

  return 1;
}

void
bundle_setsid(struct bundle *bundle, int holdsession)
{
  /*
   * Lose the current session.  This means getting rid of our pid
   * too so that the tty device will really go away, and any getty
   * etc will be allowed to restart.
   */
  pid_t pid, orig;
  int fds[2];
  char done;
  struct datalink *dl;

  if (!holdsession && bundle_IsDead(bundle)) {
    /*
     * No need to lose our session after all... we're going away anyway
     *
     * We should really stop the timer and pause if holdsession is set and
     * the bundle's dead, but that leaves other resources lying about :-(
     */
    return;
  }

  orig = getpid();
  if (pipe(fds) == -1) {
    log_Printf(LogERROR, "pipe: %s\n", strerror(errno));
    return;
  }
  switch ((pid = fork())) {
    case -1:
      log_Printf(LogERROR, "fork: %s\n", strerror(errno));
      close(fds[0]);
      close(fds[1]);
      return;
    case 0:
      close(fds[1]);
      read(fds[0], &done, 1);		/* uu_locks are mine ! */
      close(fds[0]);
      if (pipe(fds) == -1) {
        log_Printf(LogERROR, "pipe(2): %s\n", strerror(errno));
        return;
      }
      switch ((pid = fork())) {
        case -1:
          log_Printf(LogERROR, "fork(2): %s\n", strerror(errno));
          close(fds[0]);
          close(fds[1]);
          return;
        case 0:
          close(fds[1]);
          bundle_LockTun(bundle);	/* update pid */
          read(fds[0], &done, 1);	/* uu_locks are mine ! */
          close(fds[0]);
          setsid();
          bundle_ChangedPID(bundle);
          log_Printf(LogDEBUG, "%ld -> %ld: %s session control\n",
                     (long)orig, (long)getpid(),
                     holdsession ? "Passed" : "Dropped");
          timer_InitService(0);		/* Start the Timer Service */
          break;
        default:
          close(fds[0]);
          /* Give away all our physical locks (to the final process) */
          for (dl = bundle->links; dl; dl = dl->next)
            if (dl->state != DATALINK_CLOSED)
              physical_ChangedPid(dl->physical, pid);
          write(fds[1], "!", 1);	/* done */
          close(fds[1]);
          _exit(0);
          break;
      }
      break;
    default:
      close(fds[0]);
      /* Give away all our physical locks (to the intermediate process) */
      for (dl = bundle->links; dl; dl = dl->next)
        if (dl->state != DATALINK_CLOSED)
          physical_ChangedPid(dl->physical, pid);
      write(fds[1], "!", 1);	/* done */
      close(fds[1]);
      if (holdsession) {
        int status;

        timer_TermService();
        signal(SIGPIPE, SIG_DFL);
        signal(SIGALRM, SIG_DFL);
        signal(SIGHUP, SIG_DFL);
        signal(SIGTERM, SIG_DFL);
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
	closefrom(0);

        /*
         * Reap the intermediate process.  As we're not exiting but the
         * intermediate is, we don't want it to become defunct.
         */
        waitpid(pid, &status, 0);
        /* Tweak our process arguments.... */
        SetTitle("session owner");
#ifndef NOSUID
        setuid(ID0realuid());
#endif
        /*
         * Hang around for a HUP.  This should happen as soon as the
         * ppp that we passed our ctty descriptor to closes it.
         * NOTE: If this process dies, the passed descriptor becomes
         *       invalid and will give a select() error by setting one
         *       of the error fds, aborting the other ppp.  We don't
         *       want that to happen !
         */
        pause();
      }
      _exit(0);
      break;
  }
}

int
bundle_HighestState(struct bundle *bundle)
{
  struct datalink *dl;
  int result = DATALINK_CLOSED;

  for (dl = bundle->links; dl; dl = dl->next)
    if (result < dl->state)
      result = dl->state;

  return result;
}

int
bundle_Exception(struct bundle *bundle, int fd)
{
  struct datalink *dl;

  for (dl = bundle->links; dl; dl = dl->next)
    if (dl->physical->fd == fd) {
      datalink_Down(dl, CLOSE_NORMAL);
      return 1;
    }

  return 0;
}

void
bundle_AdjustFilters(struct bundle *bundle, struct ncpaddr *local,
                     struct ncpaddr *remote)
{
  filter_AdjustAddr(&bundle->filter.in, local, remote, NULL);
  filter_AdjustAddr(&bundle->filter.out, local, remote, NULL);
  filter_AdjustAddr(&bundle->filter.dial, local, remote, NULL);
  filter_AdjustAddr(&bundle->filter.alive, local, remote, NULL);
}

void
bundle_AdjustDNS(struct bundle *bundle)
{
  struct in_addr *dns = bundle->ncp.ipcp.ns.dns;

  filter_AdjustAddr(&bundle->filter.in, NULL, NULL, dns);
  filter_AdjustAddr(&bundle->filter.out, NULL, NULL, dns);
  filter_AdjustAddr(&bundle->filter.dial, NULL, NULL, dns);
  filter_AdjustAddr(&bundle->filter.alive, NULL, NULL, dns);
}

void
bundle_CalculateBandwidth(struct bundle *bundle)
{
  struct datalink *dl;
  int sp, overhead, maxoverhead;

  bundle->bandwidth = 0;
  bundle->iface->mtu = 0;
  maxoverhead = 0;

  for (dl = bundle->links; dl; dl = dl->next) {
    overhead = ccp_MTUOverhead(&dl->physical->link.ccp);
    if (maxoverhead < overhead)
      maxoverhead = overhead;
    if (dl->state == DATALINK_OPEN) {
      if ((sp = dl->mp.bandwidth) == 0 &&
          (sp = physical_GetSpeed(dl->physical)) == 0)
        log_Printf(LogDEBUG, "%s: %s: Cannot determine bandwidth\n",
                   dl->name, dl->physical->name.full);
      else
        bundle->bandwidth += sp;
      if (!bundle->ncp.mp.active) {
        bundle->iface->mtu = dl->physical->link.lcp.his_mru;
        break;
      }
    }
  }

  if (bundle->bandwidth == 0)
    bundle->bandwidth = 115200;		/* Shrug */

  if (bundle->ncp.mp.active) {
    bundle->iface->mtu = bundle->ncp.mp.peer_mrru;
    overhead = ccp_MTUOverhead(&bundle->ncp.mp.link.ccp);
    if (maxoverhead < overhead)
      maxoverhead = overhead;
  } else if (!bundle->iface->mtu)
    bundle->iface->mtu = DEF_MRU;

#ifndef NORADIUS
  if (bundle->radius.valid && bundle->radius.mtu &&
      bundle->radius.mtu < bundle->iface->mtu) {
    log_Printf(LogLCP, "Reducing MTU to radius value %lu\n",
               bundle->radius.mtu);
    bundle->iface->mtu = bundle->radius.mtu;
  }
#endif

  if (maxoverhead) {
    log_Printf(LogLCP, "Reducing MTU from %d to %d (CCP requirement)\n",
               bundle->iface->mtu, bundle->iface->mtu - maxoverhead);
    bundle->iface->mtu -= maxoverhead;
  }

  tun_configure(bundle);

  route_UpdateMTU(bundle);
}

void
bundle_AutoAdjust(struct bundle *bundle, int percent, int what)
{
  struct datalink *dl, *choice, *otherlinkup;

  choice = otherlinkup = NULL;
  for (dl = bundle->links; dl; dl = dl->next)
    if (dl->physical->type == PHYS_AUTO) {
      if (dl->state == DATALINK_OPEN) {
        if (what == AUTO_DOWN) {
          if (choice)
            otherlinkup = choice;
          choice = dl;
        }
      } else if (dl->state == DATALINK_CLOSED) {
        if (what == AUTO_UP) {
          choice = dl;
          break;
        }
      } else {
        /* An auto link in an intermediate state - forget it for the moment */
        choice = NULL;
        break;
      }
    } else if (dl->state == DATALINK_OPEN && what == AUTO_DOWN)
      otherlinkup = dl;

  if (choice) {
    if (what == AUTO_UP) {
      log_Printf(LogPHASE, "%d%% saturation -> Opening link ``%s''\n",
                 percent, choice->name);
      datalink_Up(choice, 1, 1);
      mp_CheckAutoloadTimer(&bundle->ncp.mp);
    } else if (otherlinkup) {	/* Only bring the second-last link down */
      log_Printf(LogPHASE, "%d%% saturation -> Closing link ``%s''\n",
                 percent, choice->name);
      datalink_Close(choice, CLOSE_STAYDOWN);
      mp_CheckAutoloadTimer(&bundle->ncp.mp);
    }
  }
}

int
bundle_WantAutoloadTimer(struct bundle *bundle)
{
  struct datalink *dl;
  int autolink, opened;

  if (bundle->phase == PHASE_NETWORK) {
    for (autolink = opened = 0, dl = bundle->links; dl; dl = dl->next)
      if (dl->physical->type == PHYS_AUTO) {
        if (++autolink == 2 || (autolink == 1 && opened))
          /* Two auto links or one auto and one open in NETWORK phase */
          return 1;
      } else if (dl->state == DATALINK_OPEN) {
        opened++;
        if (autolink)
          /* One auto and one open link in NETWORK phase */
          return 1;
      }
  }

  return 0;
}

void
bundle_ChangedPID(struct bundle *bundle)
{
#ifdef TUNSIFPID
  ioctl(bundle->dev.fd, TUNSIFPID, 0);
#endif
}

int
bundle_Uptime(struct bundle *bundle)
{
  if (bundle->upat)
    return time(NULL) - bundle->upat;

  return 0;
}
@


1.74
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.73 2008/03/15 16:25:00 deraadt Exp $
@


1.73
log
@Repair more msg_controllen dealing with structures or arrays of
descriptors; ok hshoexer, also looked at by kettenis and henning
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.72 2008/03/13 01:49:53 deraadt Exp $
d1421 1
a1421 1
  msg.msg_controllen = CMSG_LEN(sizeof(int) * SEND_MAXFD);
d1594 1
a1594 1
    msg.msg_controllen = CMSG_LEN(sizeof(int) * nfd);
@


1.72
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.71 2005/09/21 15:04:28 brad Exp $
d1421 1
a1421 1
  msg.msg_controllen = sizeof cmsgbuf.buf;
d1594 1
a1594 1
    msg.msg_controllen = CMSG_SPACE(sizeof(int) * nfd);
@


1.71
log
@Send NAS-IP-Address as well as NAS-Identifier
Add ``disable NAS-IP-Address'' and ``disable NAS-Identifier'' options to
support pre-rfc2865 RADIUS servers.
This pushes our enable/disable items over the 32 bit limit, so reoganise
things to allow a bunch more options.

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.70 2005/07/17 19:13:24 brad Exp $
d1379 4
a1382 1
  char cmsgbuf[sizeof(struct cmsghdr) + sizeof(int) * SEND_MAXFD];
a1414 6
  /* Set up our message */
  cmsg = (struct cmsghdr *)cmsgbuf;
  cmsg->cmsg_len = sizeof cmsgbuf;
  cmsg->cmsg_level = SOL_SOCKET;
  cmsg->cmsg_type = 0;

d1420 6
a1425 2
  msg.msg_control = cmsgbuf;
  msg.msg_controllen = sizeof cmsgbuf;
d1541 4
a1544 1
  char cmsgbuf[CMSG_SPACE(sizeof(int) * SEND_MAXFD)];
d1593 1
a1593 1
    msg.msg_control = cmsgbuf;
d1596 1
a1596 2

    cmsg = (struct cmsghdr *)cmsgbuf;
@


1.70
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.69 2004/01/28 01:35:16 kevlo Exp $
d832 5
a836 2
  bundle.cfg.opt = OPT_IDCHECK | OPT_LOOPBACK | OPT_SROUTES | OPT_TCPMSSFIXUP |
                   OPT_THROUGHPUT | OPT_UTMP;
d838 1
a838 1
  bundle.cfg.opt |= OPT_IPCP;
d840 1
a840 1
    bundle.cfg.opt |= OPT_IPV6CP;
d1056 1
a1056 1
optval(struct bundle *bundle, int bit)
d1058 1
a1058 1
  return (bundle->cfg.opt & bit) ? "enabled" : "disabled";
d1148 4
@


1.69
log
@remove unused variable. ok millert@@
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.68 2004/01/23 03:48:43 deraadt Exp $
d47 1
@


1.68
log
@Use closefrom(); ok millert tedu
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.67 2003/04/04 20:25:06 deraadt Exp $
d1785 1
a1785 1
        int fd, status;
@


1.67
log
@strlcpy and snprintf; various people ok
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.66 2002/06/15 08:02:00 brian Exp $
d1794 2
a1795 2
        for (fd = getdtablesize(); fd >= 0; fd--)
          close(fd);
@


1.66
log
@Tidy up end of line whitespace
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.65 2002/05/27 23:19:38 brian Exp $
d1547 1
a1547 1
    strcpy(lock, constlock);
@


1.65
log
@Coerce pid_t to long rather than int for better portability; theo
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.64 2002/05/16 01:13:39 brian Exp $
d194 1
a194 1
static void 
d292 1
a292 1
#endif    
d624 1
a624 1
         * around to actually dialing.  We'd also prematurely reach the 
d1148 1
a1148 1
static void 
d1217 1
a1217 1
static void 
@


1.64
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.63 2002/03/31 02:38:49 brian Exp $
d1618 2
a1619 2
        log_Printf(LogDEBUG, "Received confirmation from pid %d\n",
                   (int)newpid);
d1759 2
a1760 2
          log_Printf(LogDEBUG, "%d -> %d: %s session control\n",
                     (int)orig, (int)getpid(),
@


1.63
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.62 2001/11/23 11:17:03 brian Exp $
d230 7
d256 5
a260 1
      == bundle->phys_type.open)
d262 1
d289 4
d319 4
d422 4
d553 1
a553 1
    char *data;
d557 1
a557 1
      data = (char *)&tun;
d735 2
a736 2
	 * Attempt to load the tunnel interface KLD if it isn't loaded
	 * already.
d738 2
a739 1
        loadmodules(LOAD_VERBOSLY, "if_tun", NULL);
d969 4
d1215 41
d1897 1
a1897 1
  if(bundle->bandwidth == 0)
@


1.62
log
@cmott@@scientech.com -> cm@@linktel.net
Add the UPTIME variable
CCP protocol ``0xffffffff'' -> ``none''
Don't leak memory when expanding command arguments and not exec()ing
Make some functions static
Add the ``log'' command for manual logging
Fix some log text bogons
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.61 2001/10/24 10:01:10 brian Exp $
a51 6
#if defined(__FreeBSD__) && !defined(NOKLDLOAD)
#ifdef NOSUID
#include <sys/linker.h>
#endif
#include <sys/module.h>
#endif
d97 1
a97 1
#ifdef HAVE_DES
d132 1
a132 1
#ifdef HAVE_DES
d333 1
a333 1
    if (!others_active)
d336 2
d347 1
d360 1
d407 1
d627 2
a628 1
    descriptor_Write(&bundle->ncp.mp.server.desc, bundle, fdset);
d632 7
a638 1
      result += descriptor_Write(&dl->desc, bundle, fdset);
d714 2
a715 7
        if (modfind("if_tun") == -1) {
          if (ID0kldload("if_tun") != -1) {
            bundle.unit--;
            continue;
          }
          log_Printf(LogWARN, "kldload: if_tun: %s\n", strerror(errno));
        }
d942 1
@


1.61
log
@Use CMSG_DATA and CMSG_SPACE macros; FreeBSD
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.60 2001/08/21 11:06:04 brian Exp $
d1037 1
a1037 1
    int secs = time(NULL) - arg->bundle->upat;
d1927 9
@


1.60
log
@Enable IFF_MULTICAST when first opening the tun device
Don't bring the interface up immediately
Don't complain about unrecognised interface flags in ``show iface''.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.59 2001/08/19 23:22:17 brian Exp $
d1367 2
a1368 2
  fd = (int *)(cmsg + 1);
  nfd = (cmsg->cmsg_len - sizeof *cmsg) / sizeof(int);
d1460 1
a1460 1
  char cmsgbuf[sizeof(struct cmsghdr) + sizeof(int) * SEND_MAXFD];
d1510 1
a1510 1
    msg.msg_controllen = sizeof *cmsg + sizeof(int) * nfd;
d1519 1
a1519 1
      *((int *)(cmsg + 1) + f) = fd[f];
@


1.59
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.58 2001/07/03 22:23:56 brian Exp $
d749 2
a750 2
  /* Make sure we're POINTOPOINT */
  iff = IFF_POINTOPOINT;
a785 7

  if (!iface_SetFlags(bundle.iface->name, IFF_UP)) {
    iface_Destroy(bundle.iface);
    bundle.iface = NULL;
    close(bundle.dev.fd);
    return NULL;
  }
@


1.58
log
@Reduce the interface MTU by 2 when MPPE has been successfully negotiated.

This is necessary because MPPE will combine the protocol id with the
payload received on the tun interface, encrypt it, then prepend its
own protocol id, effectively increasing the payload by two bytes.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.57 2001/06/19 10:24:49 brian Exp $
d74 2
d87 2
a99 1
#include "ip.h"
d102 1
d154 7
a160 4
    fsm_Up(&bundle->ncp.ipcp.fsm);
    fsm_Open(&bundle->ncp.ipcp.fsm);
    bundle->phase = new;
    log_DisplayPrompts();
d224 1
a224 2
  ip_DeleteQueue(&bundle->ncp.ipcp);
  mp_DeleteQueue(&bundle->ncp.mp);
d279 7
a285 4
  } else if (fp->proto == PROTO_IPCP) {
    bundle_CalculateBandwidth(fp->bundle);
    time(&bundle->upat);
    bundle_StartIdleTimer(bundle, 0);
a286 1
    mp_CheckAutoloadTimer(&fp->bundle->ncp.mp);
d307 6
a312 4
  if (fp->proto == PROTO_IPCP) {
    bundle_StopIdleTimer(bundle);
    bundle->upat = 0;
    mp_StopAutoloadTimer(&bundle->ncp.mp);
d341 1
a341 1
      fsm2initial(&bundle->ncp.ipcp.fsm);
d356 1
a356 1
  if (fp->proto == PROTO_IPCP) {
a365 6
int
bundle_LinkIsUp(const struct bundle *bundle)
{
  return bundle->ncp.ipcp.fsm.state == ST_OPENED;
}

d405 2
a406 3
    if (bundle->ncp.ipcp.fsm.state > ST_CLOSED ||
        bundle->ncp.ipcp.fsm.state == ST_STARTING)
      fsm_Close(&bundle->ncp.ipcp.fsm);
d408 1
a408 1
      fsm2initial(&bundle->ncp.ipcp.fsm);
a425 23
static size_t
bundle_FillQueues(struct bundle *bundle)
{
  size_t total;

  if (bundle->ncp.mp.active)
    total = mp_FillQueues(bundle);
  else {
    struct datalink *dl;
    size_t add;

    for (total = 0, dl = bundle->links; dl; dl = dl->next)
      if (dl->state == DATALINK_OPEN) {
        add = link_QueueLen(&dl->physical->link);
        if (add == 0 && dl->physical->out == NULL)
          add = ip_PushPacket(&dl->physical->link, bundle);
        total += add;
      }
  }

  return total + ip_QueueLen(&bundle->ncp.ipcp);
}

d442 2
a443 1
    queued = r ? bundle_FillQueues(bundle) : ip_QueueLen(&bundle->ncp.ipcp);
d513 1
d556 6
a561 1
      if (ntohl(tun.header.family) != AF_INET)
d564 2
a565 1
    }
d567 1
a567 1
    if (((struct ip *)tun.data)->ip_dst.s_addr ==
d571 2
a572 1
        pri = PacketCheck(bundle, tun.data, n, &bundle->filter.in, NULL, NULL);
d584 2
a585 2
     * Process on-demand dialup. Output packets are queued within tunnel
     * device until IPCP is opened.
d593 2
a594 1
      pri = PacketCheck(bundle, tun.data, n, &bundle->filter.dial, NULL, NULL);
d609 2
a610 1
    pri = PacketCheck(bundle, tun.data, n, &bundle->filter.out, NULL, &secs);
d614 1
a614 1
      ip_Enqueue(&bundle->ncp.ipcp, pri, (char *)&tun, n + sizeof tun.header);
d812 1
a812 1
  bundle.cfg.opt = OPT_SROUTES | OPT_IDCHECK | OPT_LOOPBACK | OPT_TCPMSSFIXUP |
d814 5
d841 1
a841 5
  mp_Init(&bundle.ncp.mp, &bundle);

  /* Send over the first physical link by default */
  ipcp_Init(&bundle.ncp.ipcp, &bundle, &bundle.links->physical->link,
            &bundle.fsm);
d870 1
a870 1
  iface_Clear(bundle.iface, IFACE_CLEAR_ALL);
d890 2
a891 2
   * Clean up the interface.  We don't need to timer_Stop()s, mp_Down(),
   * ipcp_CleanInterface() and bundle_DownInterface() unless we're getting
d897 1
a897 1
  ipcp_CleanInterface(&bundle->ncp.ipcp);
a901 1
  log_Printf(LogDEBUG, "Radius: Destroy called from bundle_Destroy\n");
d910 1
a910 1
  ipcp_Destroy(&bundle->ncp.ipcp);
d947 1
a947 1
    fsm2initial(&bundle->ncp.ipcp.fsm);
d1050 1
a1050 1
                (unsigned long)ip_QueueLen(&arg->bundle->ncp.ipcp),
d1090 1
a1090 14
  prompt_Printf(arg->prompt, " sendpipe:          ");
  if (arg->bundle->ncp.ipcp.cfg.sendpipe > 0)
    prompt_Printf(arg->prompt, "%-20ld", arg->bundle->ncp.ipcp.cfg.sendpipe);
  else
    prompt_Printf(arg->prompt, "unspecified         ");
  prompt_Printf(arg->prompt, " recvpipe:      ");
  if (arg->bundle->ncp.ipcp.cfg.recvpipe > 0)
    prompt_Printf(arg->prompt, "%ld\n", arg->bundle->ncp.ipcp.cfg.recvpipe);
  else
    prompt_Printf(arg->prompt, "unspecified\n");

  prompt_Printf(arg->prompt, " Sticky Routes:     %-20.20s",
                optval(arg->bundle, OPT_SROUTES));
  prompt_Printf(arg->prompt, " Filter Decap:      %s\n",
d1092 1
a1092 1
  prompt_Printf(arg->prompt, " ID check:          %-20.20s",
d1094 8
d1112 3
a1114 1
  prompt_Printf(arg->prompt, " TCPMSS Fixup:      %-20.20s",
d1116 1
a1116 1
  prompt_Printf(arg->prompt, " Throughput:        %s\n",
d1118 1
a1118 1
  prompt_Printf(arg->prompt, " Utmp Logging:      %-20.20s",
a1119 2
  prompt_Printf(arg->prompt, " Iface-Alias:       %s\n",
                optval(arg->bundle, OPT_IFACEALIAS));
d1172 1
a1172 1
  if (bundle_LinkIsUp(bundle))
d1784 2
a1785 2
bundle_AdjustFilters(struct bundle *bundle, struct in_addr *my_ip,
                     struct in_addr *peer_ip)
d1787 4
a1790 4
  filter_AdjustAddr(&bundle->filter.in, my_ip, peer_ip, NULL);
  filter_AdjustAddr(&bundle->filter.out, my_ip, peer_ip, NULL);
  filter_AdjustAddr(&bundle->filter.dial, my_ip, peer_ip, NULL);
  filter_AdjustAddr(&bundle->filter.alive, my_ip, peer_ip, NULL);
d1794 1
a1794 1
bundle_AdjustDNS(struct bundle *bundle, struct in_addr dns[2])
d1796 2
@


1.57
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.56 2001/04/05 02:24:04 brian Exp $
d279 2
a280 1
  }
d1820 1
a1820 1
  int sp;
d1824 6
a1829 1
  for (dl = bundle->links; dl; dl = dl->next)
d1842 1
d1847 1
a1847 1
  if (bundle->ncp.mp.active)
d1849 4
a1852 1
  else if (!bundle->iface->mtu)
d1863 6
@


1.56
log
@When we change the interface MTU, run through the routing table and tweak
all route MTUs too.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.55 2001/03/28 09:52:54 brian Exp $
a804 1
  bundle.mtu = 1500;
a822 1
  bundle.cfg.mtu = DEF_MTU;
a1096 5
  prompt_Printf(arg->prompt, " MTU:               ");
  if (arg->bundle->cfg.mtu)
    prompt_Printf(arg->prompt, "%d\n", arg->bundle->cfg.mtu);
  else
    prompt_Printf(arg->prompt, "unspecified\n");
d1822 1
a1822 1
  bundle->mtu = 0;
d1832 1
a1832 1
        bundle->mtu = dl->physical->link.lcp.his_mru;
d1841 3
a1843 3
    bundle->mtu = bundle->ncp.mp.peer_mrru;
  else if (!bundle->mtu)
    bundle->mtu = 1500;
d1847 1
a1847 1
      bundle->radius.mtu < bundle->mtu) {
d1850 1
a1850 1
    bundle->mtu = bundle->radius.mtu;
@


1.55
log
@Bring the netgraph PPPoE interface UP if required (only applies to FreeBSD)
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.54 2001/03/24 01:05:58 brian Exp $
a33 1
#include <arpa/inet.h>
d99 1
d101 1
a931 121
struct rtmsg {
  struct rt_msghdr m_rtm;
  char m_space[64];
};

int
bundle_SetRoute(struct bundle *bundle, int cmd, struct in_addr dst,
                struct in_addr gateway, struct in_addr mask, int bang, int ssh)
{
  struct rtmsg rtmes;
  int s, nb, wb;
  char *cp;
  const char *cmdstr;
  struct sockaddr_in rtdata;
  int result = 1;

  if (bang)
    cmdstr = (cmd == RTM_ADD ? "Add!" : "Delete!");
  else
    cmdstr = (cmd == RTM_ADD ? "Add" : "Delete");
  s = ID0socket(PF_ROUTE, SOCK_RAW, 0);
  if (s < 0) {
    log_Printf(LogERROR, "bundle_SetRoute: socket(): %s\n", strerror(errno));
    return result;
  }
  memset(&rtmes, '\0', sizeof rtmes);
  rtmes.m_rtm.rtm_version = RTM_VERSION;
  rtmes.m_rtm.rtm_type = cmd;
  rtmes.m_rtm.rtm_addrs = RTA_DST;
  rtmes.m_rtm.rtm_seq = ++bundle->routing_seq;
  rtmes.m_rtm.rtm_pid = getpid();
  rtmes.m_rtm.rtm_flags = RTF_UP | RTF_GATEWAY | RTF_STATIC;

  if (cmd == RTM_ADD || cmd == RTM_CHANGE) {
    if (bundle->ncp.ipcp.cfg.sendpipe > 0) {
      rtmes.m_rtm.rtm_rmx.rmx_sendpipe = bundle->ncp.ipcp.cfg.sendpipe;
      rtmes.m_rtm.rtm_inits |= RTV_SPIPE;
    }
    if (bundle->ncp.ipcp.cfg.recvpipe > 0) {
      rtmes.m_rtm.rtm_rmx.rmx_recvpipe = bundle->ncp.ipcp.cfg.recvpipe;
      rtmes.m_rtm.rtm_inits |= RTV_RPIPE;
    }
  }

  memset(&rtdata, '\0', sizeof rtdata);
  rtdata.sin_len = sizeof rtdata;
  rtdata.sin_family = AF_INET;
  rtdata.sin_port = 0;
  rtdata.sin_addr = dst;

  cp = rtmes.m_space;
  memcpy(cp, &rtdata, rtdata.sin_len);
  cp += rtdata.sin_len;
  if (cmd == RTM_ADD) {
    if (gateway.s_addr == INADDR_ANY) {
      if (!ssh)
        log_Printf(LogERROR, "bundle_SetRoute: Cannot add a route with"
                   " destination 0.0.0.0\n");
      close(s);
      return result;
    } else {
      rtdata.sin_addr = gateway;
      memcpy(cp, &rtdata, rtdata.sin_len);
      cp += rtdata.sin_len;
      rtmes.m_rtm.rtm_addrs |= RTA_GATEWAY;
    }
  }

  if (dst.s_addr == INADDR_ANY)
    mask.s_addr = INADDR_ANY;

  if (cmd == RTM_ADD || dst.s_addr == INADDR_ANY) {
    rtdata.sin_addr = mask;
    memcpy(cp, &rtdata, rtdata.sin_len);
    cp += rtdata.sin_len;
    rtmes.m_rtm.rtm_addrs |= RTA_NETMASK;
  }

  nb = cp - (char *) &rtmes;
  rtmes.m_rtm.rtm_msglen = nb;
  wb = ID0write(s, &rtmes, nb);
  if (wb < 0) {
    log_Printf(LogTCPIP, "bundle_SetRoute failure:\n");
    log_Printf(LogTCPIP, "bundle_SetRoute:  Cmd = %s\n", cmdstr);
    log_Printf(LogTCPIP, "bundle_SetRoute:  Dst = %s\n", inet_ntoa(dst));
    log_Printf(LogTCPIP, "bundle_SetRoute:  Gateway = %s\n",
               inet_ntoa(gateway));
    log_Printf(LogTCPIP, "bundle_SetRoute:  Mask = %s\n", inet_ntoa(mask));
failed:
    if (cmd == RTM_ADD && (rtmes.m_rtm.rtm_errno == EEXIST ||
                           (rtmes.m_rtm.rtm_errno == 0 && errno == EEXIST))) {
      if (!bang) {
        log_Printf(LogWARN, "Add route failed: %s already exists\n",
		  dst.s_addr == 0 ? "default" : inet_ntoa(dst));
        result = 0;	/* Don't add to our dynamic list */
      } else {
        rtmes.m_rtm.rtm_type = cmd = RTM_CHANGE;
        if ((wb = ID0write(s, &rtmes, nb)) < 0)
          goto failed;
      }
    } else if (cmd == RTM_DELETE &&
             (rtmes.m_rtm.rtm_errno == ESRCH ||
              (rtmes.m_rtm.rtm_errno == 0 && errno == ESRCH))) {
      if (!bang)
        log_Printf(LogWARN, "Del route failed: %s: Non-existent\n",
                  inet_ntoa(dst));
    } else if (rtmes.m_rtm.rtm_errno == 0) {
      if (!ssh || errno != ENETUNREACH)
        log_Printf(LogWARN, "%s route failed: %s: errno: %s\n", cmdstr,
                   inet_ntoa(dst), strerror(errno));
    } else
      log_Printf(LogWARN, "%s route failed: %s: %s\n",
		 cmdstr, inet_ntoa(dst), strerror(rtmes.m_rtm.rtm_errno));
  }
  log_Printf(LogDEBUG, "wrote %d: cmd = %s, dst = %x, gateway = %x\n",
            wb, cmdstr, (unsigned)dst.s_addr, (unsigned)gateway.s_addr);
  close(s);

  return result;
}

d1862 2
@


1.54
log
@Remove some unprotected prototype variable names
MAXPATHLEN -> PATH_MAX
Handle ENOENT from opening /dev/tun* properly
Rename _PATH_PPP -> PPP_CONFDIR and allow it to be redefined at compile time
Reduce MIN_LQRPERIOD and MIN_FSMRETRY to 1 second
Be smarter about identifying sockets on stdin
Allow primary DNS IP negotiation when the secondary IP has been rejected
Fix the call to PacketAliasProxyRule() properly.
Add/fix some comments
Fix man page markups; ru@@FreeBSD.org
Use localhost when no hostname is configured
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.53 2001/02/04 01:19:53 brian Exp $
d794 1
a794 1
  if (!iface_SetFlags(bundle.iface, IFF_UP)) {
d889 1
a889 1
  iface_ClearFlags(bundle->iface, IFF_UP);
@


1.53
log
@MPPE_MasterKeyValid is only there if HAVE_DES is defined
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.52 2001/02/04 01:14:27 brian Exp $
d648 1
a648 1
  char pidfile[MAXPATHLEN];
d666 1
a666 1
  char pidfile[MAXPATHLEN];
d708 1
a708 1
    else if (errno == ENXIO) {
d724 2
a725 4
      err = errno;
      break;
    } else if (errno == ENOENT) {
      if (++enoentcount > 2)
d727 1
@


1.52
log
@Make the MPPE MasterKey Invalid messages a bit clearer (it now
complains that you can't do MPPE without CHAP81).

Reset MasterKeyValid to zero when we hit phase DEAD.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.51 2001/02/04 01:14:23 brian Exp $
d133 1
d135 1
@


1.51
log
@Untangle some cunfusion between the CLOSE_STAYDOWN, CLOSE_LCP and
CLOSE_NORMAL meanings.  CLOSE_NORMAL doesn't change the currently
required state, the others do.  This should stop ppp from entering
DATALINK_READY when LCP shutdown doesn't end up happening cleanly.

Bump our version number to reflect this change.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.50 2001/01/29 01:34:38 brian Exp $
d100 1
d132 2
a134 1
    bundle->phase = new;
@


1.50
log
@Only remove socket files with ``set server open''.
Only show the mask in ``show bundle'' when it's been specified.
Complain about unexpected arguments after ``set server {none,open,closed}''
Log re-open failures as warnings rather than phase messages.
Fix some markup for the ``set server'' man page description.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.49 2001/01/26 01:41:03 brian Exp $
d379 1
a379 1
          /* fall through */
@


1.49
log
@Allow ``set server closed'' to close the diagnostic socket.
Allow ``set server open'' to re-open the diagnostic socket.
Handle SIGUSR1 by re-opening the diagnostic socket
When receiving SIGUSR2 (and in ``set server none''), don't forget the
socket details so that ``set server open'' and SIGUSR1 open it again.

Don't create the diagnostic socket as uid 0 !  It's far to dangerous.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.48 2000/11/28 22:59:52 brian Exp $
d1186 6
a1191 5
  if (*server.cfg.sockname != '\0')
    prompt_Printf(arg->prompt, "%s, mask 0%03o%s\n",
                  server.cfg.sockname, (int)server.cfg.mask,
                  server.fd == -1 ? " (not open)" : "");
  else if (server.cfg.port != 0)
@


1.48
log
@Add ``enable/disable'' tcpmssfixup - enabled by default.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.47 2000/08/28 22:44:41 brian Exp $
d99 1
d1181 3
a1183 2
  prompt_Printf(arg->prompt, " Label:         %s\n", arg->bundle->cfg.label);
  prompt_Printf(arg->prompt, " Auth name:     %s\n",
d1185 10
d1196 1
a1196 1
  prompt_Printf(arg->prompt, " Choked Timer:  %ds\n",
d1203 1
a1203 1
  prompt_Printf(arg->prompt, " Idle Timer:    ");
d1215 1
a1215 1
  prompt_Printf(arg->prompt, " MTU:           ");
d1221 1
a1221 1
  prompt_Printf(arg->prompt, " sendpipe:      ");
d1232 1
a1232 1
  prompt_Printf(arg->prompt, " Sticky Routes: %-20.20s",
d1234 1
a1234 1
  prompt_Printf(arg->prompt, " Filter Decap:  %s\n",
d1236 1
a1236 1
  prompt_Printf(arg->prompt, " ID check:      %-20.20s",
d1238 1
a1238 1
  prompt_Printf(arg->prompt, " Keep-Session:  %s\n",
d1240 1
a1240 1
  prompt_Printf(arg->prompt, " Loopback:      %-20.20s",
d1242 1
a1242 1
  prompt_Printf(arg->prompt, " PasswdAuth:    %s\n",
d1244 1
a1244 1
  prompt_Printf(arg->prompt, " Proxy:         %-20.20s",
d1246 1
a1246 1
  prompt_Printf(arg->prompt, " Proxyall:      %s\n",
d1248 1
a1248 1
  prompt_Printf(arg->prompt, " TCPMSS Fixup:  %-20.20s",
d1250 1
a1250 1
  prompt_Printf(arg->prompt, " Throughput:    %s\n",
d1252 1
a1252 1
  prompt_Printf(arg->prompt, " Utmp Logging:  %-20.20s",
d1254 1
a1254 1
  prompt_Printf(arg->prompt, " Iface-Alias:   %s\n",
@


1.47
log
@Support radius accounting, and add a packet count to throughput
statistics as a side effect.

Submitted by: Marcin Cieslak <saper@@system.pl>

with some tweaks to RAD_ACCT_SESSION_ID and
RAD_ACCT_MULTI_SESSION_ID generation by me.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.46 2000/08/18 00:02:10 brian Exp $
d800 1
d816 1
a816 1
  bundle.cfg.opt = OPT_SROUTES | OPT_IDCHECK | OPT_LOOPBACK |
d1236 3
a1238 1
  prompt_Printf(arg->prompt, " Throughput:    %-20.20s",
d1240 1
a1240 1
  prompt_Printf(arg->prompt, " Utmp Logging:  %s\n",
d1930 1
a1930 1
  int mtu, sp;
d1933 1
a1933 1
  mtu = 0;
d1943 1
a1943 1
        mtu = dl->physical->link.lcp.his_mru;
d1952 3
a1954 3
    mtu = bundle->ncp.mp.peer_mrru;
  else if (!mtu)
    mtu = 1500;
d1957 2
a1958 1
  if (bundle->radius.valid && bundle->radius.mtu && bundle->radius.mtu < mtu) {
d1961 1
a1961 1
    mtu = bundle->radius.mtu;
d1965 1
a1965 1
  tun_configure(bundle, mtu);
@


1.46
log
@Make -DNOSUID (or -DPPP_NOSUID) possible to build ppp without SUID
capabilities.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.45 2000/08/16 09:07:26 brian Exp $
d905 1
@


1.45
log
@setproctitle() doesn't need to be called with root privs, so move
it from id.c into defs.c
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.44 2000/08/15 10:26:34 brian Exp $
d54 3
d1858 1
d1860 1
@


1.44
log
@Maintain input and output throughput averages and choose the highest
of the two when calculating the MP throughput average for the ``set
autoload'' implementation.

This makes more sense as all links I know of are full-duplex.  This
also means that people may need to adjust their autoload settings
as 100% bandwidth is now the theoretical maximum rather than 200%
(but of course, halfing the current settings is probably not the
correct answer either!).

This involves a ppp version bump as we need to pass an extra
throughput array through the MP local domain socket.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.43 2000/08/15 10:08:46 brian Exp $
a53 1
#include <sys/linker.h>
d1854 1
a1854 1
        ID0setproctitle("session owner");
@


1.43
log
@Calculate the average link throughput using a counter based on the
cumulative total of all active links rather than basing it on the
total of PROTO_MP traffic.

This fixes a problem whereby Cisco routers send PROTO_IP packets only
when there's only one link (hmm, what a good idea!).
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.42 2000/07/11 22:13:02 brian Exp $
d98 2
a99 2
#define SCATTER_SEGMENTS 6  /* version, datalink, name, physical,
                               throughput, device                   */
d1120 1
d1124 3
d1133 1
a1133 2
                    dl->physical->link.stats.total.OctetsPerSecond * 8,
                    dl->physical->link.stats.total.OctetsPerSecond);
d1138 1
d1144 1
a1144 2
                  " over the last %d secs\n", t->OctetsPerSecond * 8,
                  t->OctetsPerSecond, secs);
@


1.42
log
@Allow a ``timeout secs'' filter option to let specific packet types
effect the idle timer in different ways.

Submitted by: Stefan Esser <se@@freebsd.org>

With adjustments by me to document the option in the man page and to
give the same semantics for outgoing traffic as incoming.

I made the style more consistent in ip.c - this should really have
been done as a separate commit.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.41 2000/07/11 09:27:32 brian Exp $
d1125 1
a1125 1
    if (dl->physical->link.throughput.rolling && dl->state == DATALINK_OPEN)
d1129 2
a1130 2
                    dl->physical->link.throughput.OctetsPerSecond * 8,
                    dl->physical->link.throughput.OctetsPerSecond);
d1134 1
a1134 1
  t = &arg->bundle->ncp.mp.link.throughput;
@


1.41
log
@Fix -auto breakage introduced with the last commit
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.40 2000/07/07 14:47:53 brian Exp $
d225 1
a225 1
    bundle_StartIdleTimer(bundle);
d268 1
a268 1
    bundle_StartIdleTimer(bundle);
d522 1
d565 1
a565 1
      if (ntohl(tun.family) != AF_INET)
d574 1
a574 1
        pri = PacketCheck(bundle, tun.data, n, &bundle->filter.in, NULL);
d595 1
a595 1
      pri = PacketCheck(bundle, tun.data, n, &bundle->filter.dial, NULL);
d609 7
a615 3
    pri = PacketCheck(bundle, tun.data, n, &bundle->filter.out, NULL);
    if (pri >= 0)
      ip_Enqueue(&bundle->ncp.ipcp, pri, tun.data, n);
d1254 1
a1254 1
bundle_StartIdleTimer(struct bundle *bundle)
d1259 4
a1262 1
    int secs;
d1264 1
a1264 1
    secs = bundle->cfg.idle.timeout;
d1266 1
a1266 1
      int up = time(NULL) - bundle->upat;
d1269 1
d1277 1
a1277 1
    bundle->idle.done = time(NULL) + secs;
d1288 1
a1288 1
    bundle_StartIdleTimer(bundle);
@


1.40
log
@o  Log the (payload/size) of all packet types, not just TCP packets

o  If the new ``filter-decapsulation'' is enabled, delve into UDP packets
   that contain 0xff 0x03 as the first two bytes, and if we recognise it
   as PROTO_IP, decapsulate it for the purpose of filter checking.

   If we recognise it as PROTO_<anything else> mention this for logging
   purposes only.

This change is aimed at people running PPPoUDP where the UDP traffic is
being sent over another PPP link.  It's desireable to have the top level
link connected all the time, but to have the bottom level link capable
of decapsulating the traffic and comparing the payload against the filters,
thus allowing ``set filter dial ...'' to work in tunnelled environments.

The caveat here is that the top ppp cannot employ any compression layers
without making the data unreadable for the bottom ppp.  ``disable deflate
pred1 vj'' and ``deny deflate pred1 vj'' is suggested.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.39 2000/06/23 09:47:30 brian Exp $
d595 1
a595 1
      if (pri > 0)
@


1.39
log
@Fix a printf-style arg cast (again)
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.38 2000/06/18 10:08:59 brian Exp $
d573 1
a573 1
        pri = PacketCheck(bundle, tun.data, n, &bundle->filter.in);
d594 2
a595 1
      if ((pri = PacketCheck(bundle, tun.data, n, &bundle->filter.dial)) >= 0)
d608 1
a608 1
    pri = PacketCheck(bundle, tun.data, n, &bundle->filter.out);
d1210 3
a1212 1
  prompt_Printf(arg->prompt, " ID check:      %s\n",
d1214 1
a1214 1
  prompt_Printf(arg->prompt, " Keep-Session:  %-20.20s",
d1216 1
a1216 1
  prompt_Printf(arg->prompt, " Loopback:      %s\n",
d1218 1
a1218 1
  prompt_Printf(arg->prompt, " PasswdAuth:    %-20.20s",
d1220 1
a1220 1
  prompt_Printf(arg->prompt, " Proxy:         %s\n",
d1222 1
a1222 1
  prompt_Printf(arg->prompt, " Proxyall:      %-20.20s",
d1224 1
a1224 1
  prompt_Printf(arg->prompt, " Throughput:    %s\n",
d1226 1
a1226 1
  prompt_Printf(arg->prompt, " Utmp Logging:  %-20.20s",
@


1.38
log
@Fix a printf-style format error
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.37 2000/06/13 09:57:50 brian Exp $
d1163 2
a1164 1
                ip_QueueLen(&arg->bundle->ncp.ipcp), arg->bundle->cfg.ifqueue);
@


1.37
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.36 2000/04/07 23:46:39 brian Exp $
d1162 1
a1162 1
  prompt_Printf(arg->prompt, "\n Queued:        %u of %u\n",
@


1.36
log
@When running ppp -background, show comfort messages showing
when we're redialing/reconnecting.

While we're here, log redial, reconnect and phone number
announcements to LogCHAT, and reduce some other logging to
LogDEBUG.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.35 2000/04/06 10:09:57 brian Exp $
d443 1
d458 2
a459 1
      if (queued < 30) {
d811 1
d1082 3
a1084 3
            dl->dial.timer.state == TIMER_RUNNING))) {
        if (force)	/* Ignore redial timeout ? */
          timer_Stop(&dl->dial.timer);
d1087 1
a1087 2
          /* Only one AUTO link at a time */
          break;
d1162 2
d1165 1
a1165 1
  prompt_Printf(arg->prompt, "\n\nDefaults:\n");
d1975 1
a1975 1
      mp_StopAutoloadTimer(&bundle->ncp.mp);
d1980 1
a1980 1
      mp_StopAutoloadTimer(&bundle->ncp.mp);
@


1.35
log
@I didn't get this right the last time....

When an NCP reaches TLF, *ONLY* datalink_Close() links that are
in DATALINK_OPEN.

When the last link reaches TLD, DOWN all NCPs (as we used to in the
links TLF (which was the wrong place anyway)), as the NCPs aren't
now going to datalink_Close() us unexpectedly, we get to continue
doing what we were told to do in the first place.

The result:  When we lose a link, the IPCP layer goes down and
we actually call the stuff in ppp.linkdown !
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.34 2000/04/02 01:36:24 brian Exp $
d163 1
a163 1
static void
d167 13
a179 3
    if (write(bundle->notify.fd, &c, 1) == 1)
      log_Printf(LogPHASE, "Parent notified of %s\n",
                 c == EX_NORMAL ? "success" : "failure");
d181 1
a181 3
      log_Printf(LogPHASE, "Failed to notify parent of success.\n");
    close(bundle->notify.fd);
    bundle->notify.fd = -1;
d1231 1
a1231 1
  log_Printf(LogPHASE, "Idle timer expired.\n");
d1654 1
a1654 1
            log_Printf(LogPHASE, "uu_lock_txfr: %s\n", uu_lockerr(res));
d1792 1
a1792 1
          log_Printf(LogPHASE, "%d -> %d: %s session control\n",
@


1.34
log
@Don't ``down'' all NCPs when the last LCP reaches TLD.  Instead,
wait for bundle_LinkClosed() to be called.  This allows the correct
redial decision to be made (un-breaking ``set redial'').
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.33 2000/04/02 01:36:23 brian Exp $
d276 1
d287 4
a291 3
    if (bundle->ncp.mp.active) {
      struct datalink *dl;
      struct datalink *lost;
d293 8
a300 4
      lost = NULL;
      for (dl = bundle->links; dl; dl = dl->next)
        if (fp == &dl->physical->link.lcp.fsm)
          lost = dl;
d302 1
d311 4
d333 2
a334 1
      datalink_Close(dl, CLOSE_STAYDOWN);
a336 5
  /*
   * If it's an LCP, don't try to murder any NCPs, let bundle_LinkClosed()
   * do that side of things (at a time when a call to fsm2initial() on the
   * NCP isn't going to take charge of bringing down this link).
   */
@


1.33
log
@Don't claim (in the log file) that the parent was notified
of success if the child process in -background mode failed
to connect.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.32 2000/03/19 10:33:32 brian Exp $
a311 1
   * If it's the last LCP, fsm_Down all NCPs
a323 11
  } else if (fp->proto == PROTO_LCP) {
    int others_active;

    others_active = 0;
    for (dl = bundle->links; dl; dl = dl->next)
      if (fp != &dl->physical->link.lcp.fsm &&
          dl->state != DATALINK_CLOSED && dl->state != DATALINK_HANGUP)
        others_active++;

    if (!others_active)
      fsm2initial(&bundle->ncp.ipcp.fsm);
d325 5
@


1.32
log
@Allow environment variables on command/config lines; markk@@knigma.org
Add the ``resolv'' command so that when ``enable dns''
is used, it's possible to restore the file.
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.31 2000/03/03 21:52:56 brian Exp $
d168 2
a169 1
      log_Printf(LogPHASE, "Parent notified of success.\n");
@


1.31
log
@Fix some printf-type argument bugs
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.30 2000/02/27 01:38:24 brian Exp $
d1874 13
a1886 4
  filter_AdjustAddr(&bundle->filter.in, my_ip, peer_ip);
  filter_AdjustAddr(&bundle->filter.out, my_ip, peer_ip);
  filter_AdjustAddr(&bundle->filter.dial, my_ip, peer_ip);
  filter_AdjustAddr(&bundle->filter.alive, my_ip, peer_ip);
@


1.30
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: bundle.c,v 1.29 2000/02/27 01:34:04 brian Exp $
d1442 2
a1443 1
  log_Printf(LogDEBUG, "Expecting %d scatter/gather bytes\n", iov[0].iov_len);
d1449 2
a1450 2
      log_Printf(LogERROR, "Failed recvmsg: Got %d, not %d\n",
                 got, iov[0].iov_len);
d1627 3
a1629 2
    log_Printf(LogDEBUG, "Sending %d descriptor%s and %d bytes in scatter"
               "/gather array\n", nfd, nfd == 1 ? "" : "s", iov[0].iov_len);
d1635 2
a1636 2
      log_Printf(LogERROR, "%s: Failed initial sendmsg: Only sent %d of %d\n",
                 sun->sun_path, got, iov[0].iov_len);
@


1.29
log
@Fix a bug in end-of-line comment parsing.
Fix callback (don't ``forget'' to call back).
Restructure how we add/remove the address family when
writing/reading the tun device.
Notify the tun device that we've changed PID under FreeBSD.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.28 2000/02/27 00:21:05 brian Exp $
@


1.28
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.27 2000/01/07 03:26:53 brian Exp $
d33 1
a33 1
#include <net/if_tun.h>		/* For TUNSIFMODE & TUNSLMODE */
d527 10
d539 2
a540 1
    n = read(bundle->dev.fd, &tun, sizeof tun);
d542 1
a542 1
      log_Printf(LogWARN, "read from %s: %s\n", TUN_NAME, strerror(errno));
d545 11
a555 4
    n -= sizeof tun - sizeof tun.data;
    if (n <= 0) {
      log_Printf(LogERROR, "read from %s: Only %d bytes read ?\n", TUN_NAME, n);
      return;
a556 2
    if (!tun_check_header(tun, AF_INET))
      return;
d564 2
a565 2
          n += sizeof tun - sizeof tun.data;
          write(bundle->dev.fd, &tun, n);
d657 1
a657 1
#if defined(TUNSIFMODE) || defined(TUNSLMODE)
d741 1
a741 1
  /* Make sure we're POINTOPOINT */
d748 23
d1780 1
d1982 8
@


1.27
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.26 1999/08/17 17:25:34 brian Exp $
d429 1
a429 1
bundle_UpdateSet(struct descriptor *d, fd_set *r, fd_set *w, fd_set *e, int *n)
d486 1
a486 1
bundle_IsSet(struct descriptor *d, const fd_set *fdset)
d507 1
a507 1
bundle_DescriptorRead(struct descriptor *d, struct bundle *bundle,
d587 1
a587 1
bundle_DescriptorWrite(struct descriptor *d, struct bundle *bundle,
@


1.26
log
@Implement a minimum idle time value as an optional second argument
to ``set timeout''.
This is useful for situations where your minimum call charge is (say)
5 minutes (like mine is)
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.25 1999/08/09 23:01:52 brian Exp $
d33 1
a33 1
#include <net/if_tun.h>
d42 5
a50 1
#include <sys/ioctl.h>
d53 4
d98 5
a102 4
#define SCATTER_SEGMENTS 6	/* version, datalink, name, physical,
                                   throughput, device */
#define SOCKET_OVERHEAD	100	/* additional buffer space for large */
                                /* {recv,send}msg() calls            */
d106 1
a106 1
static const char *PhaseNames[] = {
d322 1
a322 1
      datalink_Close(dl, CLOSE_NORMAL);
d405 23
d433 2
a434 1
  int result, queued, nlinks;
d448 1
a448 1
      if (queued < 20) {
d633 1
a633 1
bundle_Create(const char *prefix, int type, const char **argv)
d636 1
a636 1
  int enoentcount, err;
d638 3
d650 7
d659 4
a662 1
  for (bundle.unit = 0; ; bundle.unit++) {
d669 15
d694 5
a698 2
    log_Printf(LogWARN, "No available tunnel devices found (%s).\n",
              strerror(err));
a702 3
  bundle.argv = argv;
  bundle.argv0 = argv[0];
  bundle.argv1 = argv[1];
d745 1
a745 1
  bundle.AliasEnabled = 0;
d854 2
d951 2
a952 1
    log_Printf(LogTCPIP, "bundle_SetRoute:  Gateway = %s\n", inet_ntoa(gateway));
d993 1
a993 1
   * BACKGROUND and DIRECT links.
a1059 23
bundle_FillQueues(struct bundle *bundle)
{
  int total;

  if (bundle->ncp.mp.active)
    total = mp_FillQueues(bundle);
  else {
    struct datalink *dl;
    int add;

    for (total = 0, dl = bundle->links; dl; dl = dl->next)
      if (dl->state == DATALINK_OPEN) {
        add = link_QueueLen(&dl->physical->link);
        if (add == 0 && dl->physical->out == NULL)
          add = ip_PushPacket(&dl->physical->link, bundle);
        total += add;
      }
  }

  return total + ip_QueueLen(&bundle->ncp.ipcp);
}

int
a1101 1
  prompt_Printf(arg->prompt, " Title:         %s\n", arg->bundle->argv[0]);
d1286 2
a1287 1
        (*dlp)->physical->type & (PHYS_DIRECT|PHYS_BACKGROUND)) {
d1333 20
d1354 1
a1354 1
bundle_ReceiveDatalink(struct bundle *bundle, int s, struct sockaddr_un *sun)
d1356 4
a1359 2
  char cmsgbuf[sizeof(struct cmsghdr) + sizeof(int)];
  struct cmsghdr *cmsg = (struct cmsghdr *)cmsgbuf;
a1360 1
  struct iovec iov[SCATTER_SEGMENTS];
a1361 1
  int niov, link_fd, expect, f;
d1366 7
a1372 1
  /* Create our scatter/gather array */
d1374 2
a1375 4
  iov[0].iov_len = strlen(Version) + 1;
  iov[0].iov_base = (char *)malloc(iov[0].iov_len);
  if (datalink2iov(NULL, iov, &niov, sizeof iov / sizeof *iov, 0) == -1) {
    close(s);
d1379 9
a1387 5
  pid = getpid();
  write(s, &pid, sizeof pid);

  for (f = expect = 0; f < niov; f++)
    expect += iov[f].iov_len;
d1390 1
d1396 2
a1397 2
  msg.msg_name = (caddr_t)sun;
  msg.msg_namelen = sizeof *sun;
d1399 1
a1399 1
  msg.msg_iovlen = niov;
d1403 4
a1406 5
  log_Printf(LogDEBUG, "Expecting %d scatter/gather bytes\n", expect);
  f = expect + 100;
  setsockopt(s, SOL_SOCKET, SO_RCVBUF, &f, sizeof f);
  if ((f = recvmsg(s, &msg, MSG_WAITALL)) != expect) {
    if (f == -1)
d1409 2
a1410 1
      log_Printf(LogERROR, "Failed recvmsg: Got %d, not %d\n", f, expect);
a1412 1
    close(s);
d1416 9
a1424 2
  write(s, "!", 1);	/* ACK */
  close(s);
d1426 5
a1430 2
  if (cmsg->cmsg_type != SCM_RIGHTS) {
    log_Printf(LogERROR, "Recvmsg: no descriptor received !\n");
d1436 5
a1440 4
  /* We've successfully received an open file descriptor through our socket */
  log_Printf(LogDEBUG, "Receiving device descriptor\n");
  link_fd = *(int *)CMSG_DATA(cmsg);

d1445 21
a1465 1
    close(link_fd);
d1471 18
a1488 2
  niov = 1;
  dl = iov2datalink(bundle, iov, &niov, sizeof iov / sizeof *iov, link_fd);
d1490 19
a1508 5
    bundle_DatalinkLinkin(bundle, dl);
    datalink_AuthOk(dl);
    bundle_CalculateBandwidth(dl->bundle);
  } else
    close(link_fd);
d1516 4
a1519 2
  char cmsgbuf[sizeof(struct cmsghdr) + sizeof(int)], ack;
  struct cmsghdr *cmsg = (struct cmsghdr *)cmsgbuf;
d1522 1
a1522 1
  int niov, link_fd, f, expect, newsid;
d1527 8
d1542 1
d1544 1
a1544 2
  read(s, &newpid, sizeof newpid);
  link_fd = datalink2iov(dl, iov, &niov, sizeof iov / sizeof *iov, newpid);
d1546 8
a1553 1
  if (link_fd != -1) {
d1556 8
a1563 2
    msg.msg_name = (caddr_t)sun;
    msg.msg_namelen = sizeof *sun;
d1565 3
a1567 1
    msg.msg_iovlen = niov;
d1569 2
a1570 1
    cmsg->cmsg_len = sizeof cmsgbuf;
a1572 3
    *(int *)CMSG_DATA(cmsg) = link_fd;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof cmsgbuf;
d1574 4
a1577 1
    for (f = expect = 0; f < niov; f++)
d1580 42
a1621 1
    log_Printf(LogDEBUG, "Sending %d bytes in scatter/gather array\n", expect);
d1623 2
a1624 6
    f = expect + SOCKET_OVERHEAD;
    setsockopt(s, SOL_SOCKET, SO_SNDBUF, &f, sizeof f);
    if (sendmsg(s, &msg, 0) == -1)
      log_Printf(LogERROR, "Failed sendmsg: %s\n", strerror(errno));
    /* We must get the ACK before closing the descriptor ! */
    read(s, &ack, 1);
d1627 3
a1629 2
             tcgetpgrp(link_fd) == getpgrp();
    close(link_fd);
d1631 1
a1631 1
      bundle_setsid(dl->bundle, 1);
d1700 10
d1754 1
a1754 1
          exit(0);
a1777 1
        setuid(geteuid());
d1784 2
a1785 2
        bundle->argv[0] = "session owner";
        bundle->argv[1] = NULL;
d1796 1
a1796 1
      exit(0);
d1915 1
a1915 1
      datalink_Down(choice, CLOSE_NORMAL);
@


1.25
log
@Change printf formats %q[du] -> %ll[du]
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.24 1999/08/05 10:32:13 brian Exp $
d235 1
d249 1
d262 1
d273 1
d692 2
a693 1
  bundle.cfg.idle_timeout = NCP_IDLE_TIMEOUT;
d703 1
d1063 1
a1063 1
  prompt_Printf(arg->prompt, " Interface:     %s @@ %lubps\n",
d1066 8
a1073 1
  prompt_Printf(arg->prompt, "\nDefaults:\n");
d1086 5
a1090 2
  if (arg->bundle->cfg.idle_timeout) {
    prompt_Printf(arg->prompt, "%ds", arg->bundle->cfg.idle_timeout);
d1157 10
a1166 1
      bundle->phys_type.open && bundle->cfg.idle_timeout) {
d1169 1
a1169 1
    bundle->idle.timer.load = bundle->cfg.idle_timeout * SECTICKS;
d1172 1
a1172 1
    bundle->idle.done = time(NULL) + bundle->cfg.idle_timeout;
d1177 1
a1177 1
bundle_SetIdleTimer(struct bundle *bundle, int value)
d1179 3
a1181 1
  bundle->cfg.idle_timeout = value;
@


1.24
log
@o Obsolete the undocumented ``set weight'' command.
o If we're using RADIUS and the RADIUS mtu is less than our
  peers mru/mrru, reduce our mtu to this value for NetBSD too.
o Make struct throughput's sample period dynamic and tweak the ppp
  version number to reflect the extra stuff being passed through
  the local domain socket as a result (MP mode).
o Measure the current throughput based on the number of samples actually
  taken rather than on the full sample period.
o Keep the throughput statisics persistent while being passed to
  another ppp invocation through the local domain socket.
o When showing throughput statistics after the timer has stopped, use
  the stopped time for overall calculations, not the current time.
  Also show the stopped time and how long the current throughput has
  been sampled for.
o Use time() consistently in throughput.c
o Tighten up the ``show bundle'' output.
o Introduce the ``set bandwidth'' command.
o Rewrite the ``set autoload'' command.  It now takes three arguments
  and works based on a rolling bundle throughput average compared against
  the theoretical bundle bandwidth over a given period (read: it's now
  functional).
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.23 1999/07/27 23:47:21 brian Exp $
d1023 1
a1023 1
      prompt_Printf(arg->prompt, " bandwidth %d, %qu bps (%qu bytes/sec)",
d1036 1
a1036 1
    prompt_Printf(arg->prompt, "Currently averaging %qu bps (%qu bytes/sec)"
@


1.23
log
@o Overhaul filtering, adding facilities to jump over rules and to
  negate the sense of rules.
o Remove the redundant (and undocumented) ``host'' and ``port''
  words (README.changes updated).
o Don't permit (and ignore) garbage instead of the protocol.

Mostly submitted by:  Peter Jeremy <jeremyp@@gsmx07.alcatel.com.au>
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.22 1999/07/15 02:10:31 brian Exp $
d90 2
a91 1
#define SCATTER_SEGMENTS 5	/* version, datalink, name, physical, device */
a95 1
static int bundle_RemainingAutoLoadTime(struct bundle *);
a197 91
bundle_AutoLoadTimeout(void *v)
{
  struct bundle *bundle = (struct bundle *)v;

  if (bundle->autoload.comingup) {
    log_Printf(LogPHASE, "autoload: Another link is required\n");
    /* bundle_Open() stops the timer */
    bundle_Open(bundle, NULL, PHYS_AUTO, 0);
  } else {
    struct datalink *dl, *last;

    timer_Stop(&bundle->autoload.timer);
    for (last = NULL, dl = bundle->links; dl; dl = dl->next)
      if (dl->physical->type == PHYS_AUTO && dl->state == DATALINK_OPEN)
        last = dl;

    if (last)
      datalink_Close(last, CLOSE_STAYDOWN);
  }
}

static void
bundle_StartAutoLoadTimer(struct bundle *bundle, int up)
{
  struct datalink *dl;

  timer_Stop(&bundle->autoload.timer);
  bundle->autoload.comingup = up ? 1 : 0;

  if (bundle->CleaningUp || bundle->phase != PHASE_NETWORK) {
    dl = NULL;
    bundle->autoload.running = 0;
  } else if (up) {
    for (dl = bundle->links; dl; dl = dl->next)
      if (dl->state == DATALINK_CLOSED && dl->physical->type == PHYS_AUTO) {
        if (bundle->cfg.autoload.max.timeout) {
          bundle->autoload.timer.func = bundle_AutoLoadTimeout;
          bundle->autoload.timer.name = "autoload up";
          bundle->autoload.timer.load =
            bundle->cfg.autoload.max.timeout * SECTICKS;
          bundle->autoload.timer.arg = bundle;
          timer_Start(&bundle->autoload.timer);
          bundle->autoload.done = time(NULL) + bundle->cfg.autoload.max.timeout;
        } else
          bundle_AutoLoadTimeout(bundle);
        break;
      }
    bundle->autoload.running = (dl || bundle->cfg.autoload.min.timeout) ? 1 : 0;
  } else {
    int nlinks;
    struct datalink *adl;

    for (nlinks = 0, adl = NULL, dl = bundle->links; dl; dl = dl->next)
      if (dl->state == DATALINK_OPEN) {
        if (dl->physical->type == PHYS_AUTO)
          adl = dl;
        if (++nlinks > 1 && adl) {
          if (bundle->cfg.autoload.min.timeout) {
            bundle->autoload.timer.func = bundle_AutoLoadTimeout;
            bundle->autoload.timer.name = "autoload down";
            bundle->autoload.timer.load =
              bundle->cfg.autoload.min.timeout * SECTICKS;
            bundle->autoload.timer.arg = bundle;
            timer_Start(&bundle->autoload.timer);
            bundle->autoload.done =
              time(NULL) + bundle->cfg.autoload.min.timeout;
          }
          break;
        }
      }

    bundle->autoload.running = 1;
  }
}

static void
bundle_StopAutoLoadTimer(struct bundle *bundle)
{
  timer_Stop(&bundle->autoload.timer);
  bundle->autoload.done = 0;
}

static int
bundle_RemainingAutoLoadTime(struct bundle *bundle)
{
  if (bundle->autoload.done)
    return bundle->autoload.done - time(NULL);
  return -1;
}

static void
a203 7
  /* Note: We only re-add links that are DATALINK_OPEN */
  if (dl->physical->type == PHYS_AUTO &&
      bundle->autoload.timer.state == TIMER_STOPPED &&
      dl->state != DATALINK_OPEN &&
      bundle->phase == PHASE_NETWORK)
    bundle->autoload.running = 1;

d219 3
d232 4
a235 3
   * If it's an LCP, adjust our phys_mode.open value.
   * If it's an LCP set our mtu (if we're multilink, add up the link
   * speeds and set the MRRU) and start our autoload timer.
d237 1
a237 1
   * If it's the first NCP, start the idle timer.
d245 1
a245 13
    if (bundle->ncp.mp.active) {
      struct datalink *dl;

      bundle->ifSpeed = 0;
      for (dl = bundle->links; dl; dl = dl->next)
        if (dl->state == DATALINK_OPEN)
          bundle->ifSpeed += physical_GetSpeed(dl->physical);
      tun_configure(bundle, bundle->ncp.mp.peer_mrru);
      bundle->autoload.running = 1;
    } else {
      bundle->ifSpeed = physical_GetSpeed(p);
      tun_configure(bundle, fsm2lcp(fp)->his_mru);
    }
d247 1
d250 1
d260 1
d268 1
a268 1
  if (fp->proto == PROTO_IPCP)
d270 2
a271 1
  else if (fp->proto == PROTO_LCP) {
a276 1
      bundle->ifSpeed = 0;
a280 2
        else if (dl->state == DATALINK_OPEN)
          bundle->ifSpeed += physical_GetSpeed(dl->physical);
d282 1
a282 3
      if (bundle->ifSpeed)
        /* Don't configure down to a speed of 0 */
        tun_configure(bundle, bundle->ncp.mp.link.lcp.his_mru);
a369 1
    bundle_StopAutoLoadTimer(bundle);
d397 1
a397 1
  int result, want, queued, nlinks;
a406 12
    if (bundle->autoload.running) {
      if (queued < bundle->cfg.autoload.max.packets) {
        if (queued > bundle->cfg.autoload.min.packets)
          bundle_StopAutoLoadTimer(bundle);
        else if (bundle->autoload.timer.state != TIMER_RUNNING ||
                 bundle->autoload.comingup)
          bundle_StartAutoLoadTimer(bundle, 0);
      } else if ((bundle_Phase(bundle) == PHASE_NETWORK || queued) &&
                 (bundle->autoload.timer.state != TIMER_RUNNING ||
                  !bundle->autoload.comingup))
        bundle_StartAutoLoadTimer(bundle, 1);
    }
d411 1
a411 5
      want = bundle->cfg.autoload.max.packets + nlinks * 2;
      /* but at least 20 packets ! */
      if (want < 20)
        want = 20;
      if (queued < want) {
d676 1
a676 1
  bundle.ifSpeed = 0;
a694 4
  bundle.cfg.autoload.max.packets = 0;
  bundle.cfg.autoload.max.timeout = 0;
  bundle.cfg.autoload.min.packets = 0;
  bundle.cfg.autoload.min.timeout = 0;
a740 3
  memset(&bundle.autoload.timer, '\0', sizeof bundle.autoload.timer);
  bundle.autoload.done = 0;
  bundle.autoload.running = 0;
a772 1
  timer_Stop(&bundle->autoload.timer);
d945 1
a945 4
    bundle_StopAutoLoadTimer(bundle);
    bundle->autoload.running = 0;
  } else
    bundle->autoload.running = 1;
a955 1
  timer_Stop(&bundle->autoload.timer);
d965 2
a966 2
        if (mask == PHYS_AUTO)
          /* Only one AUTO link at a time (see the AutoLoad timer) */
d1016 2
d1023 4
a1026 2
      prompt_Printf(arg->prompt, " weight %d, %Ld bytes/sec",
                    dl->mp.weight,
d1031 9
d1058 1
a1058 1
                arg->bundle->iface->name, arg->bundle->ifSpeed);
a1063 15
  prompt_Printf(arg->prompt, " Auto Load:     Up after %ds of >= %d packets\n",
                arg->bundle->cfg.autoload.max.timeout,
                arg->bundle->cfg.autoload.max.packets);
  prompt_Printf(arg->prompt, "                Down after %ds of <= %d"
                " packets\n", arg->bundle->cfg.autoload.min.timeout,
                arg->bundle->cfg.autoload.min.packets);
  if (arg->bundle->autoload.timer.state == TIMER_RUNNING)
    prompt_Printf(arg->prompt, "                %ds remaining 'till "
                  "a link comes %s\n",
                  bundle_RemainingAutoLoadTime(arg->bundle),
                  arg->bundle->autoload.comingup ? "up" : "down");
  else
    prompt_Printf(arg->prompt, "                %srunning with %d"
                  " packets queued\n", arg->bundle->autoload.running ?
                  "" : "not ", ip_QueueLen(&arg->bundle->ncp.ipcp));
d1089 1
a1089 1
    prompt_Printf(arg->prompt, "%ld\n", arg->bundle->ncp.ipcp.cfg.sendpipe);
d1091 1
a1091 1
    prompt_Printf(arg->prompt, "unspecified\n");
d1098 1
a1098 1
  prompt_Printf(arg->prompt, " Sticky Routes: %s\n",
d1102 1
a1102 1
  prompt_Printf(arg->prompt, " Keep-Session:  %s\n",
d1106 1
a1106 1
  prompt_Printf(arg->prompt, " PasswdAuth:    %s\n",
d1110 1
a1110 1
  prompt_Printf(arg->prompt, " Proxyall:      %s\n",
d1114 1
a1114 1
  prompt_Printf(arg->prompt, " Utmp Logging:  %s\n",
d1208 1
d1349 1
d1460 1
a1460 1
  /* Regenerate phys_type and adjust autoload & idle timers */
d1606 106
@


1.22
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.20 1999/06/22 11:32:44 brian Exp $
d857 9
@


1.21
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d33 1
a33 1
#include <net/if_tun.h>		/* For TUNSIFMODE & TUNSLMODE */
d46 1
a46 1
/* #include <sys/ioctl.h> (auto-remove) */
@


1.20
log
@Disable TUNSLMODE when we first open the tun device (FreeBSD only).

Submitted by: Ian West <ian@@niw.com.au>
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.19 1999/06/02 00:46:55 brian Exp $
d33 1
a33 1
#include <net/if_tun.h>
d46 1
a46 1
#include <sys/ioctl.h>
@


1.19
log
@Introduce the ``keep-session'' option.  Refer to the man
page for details.  This allows MP over non-tty devices where
the original ppp process must not exit (such as sshd-spawned
ppp sessions).
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.18 1999/05/31 23:57:35 brian Exp $
d725 1
a725 1
#ifdef TUNSIFMODE
d780 8
@


1.18
log
@Remember if MYADDR or HISADDR is used in a filter add tweak all
filters any time either value changes.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.17 1999/05/27 08:44:48 brian Exp $
d1223 2
d1525 2
a1526 1
    newsid = tcgetpgrp(link_fd) == getpgrp();
@


1.17
log
@Move the code for tweaking interface flags into one function.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.16 1999/05/12 10:03:48 brian Exp $
d1712 10
@


1.16
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.15 1999/05/08 11:06:33 brian Exp $
d722 2
a723 1
  int s, enoentcount, err;
a724 2
  struct ifreq ifrq;
  static struct bundle bundle;		/* there can be only one */
a762 7
  s = socket(AF_INET, SOCK_DGRAM, 0);
  if (s < 0) {
    log_Printf(LogERROR, "bundle_Create: socket(): %s\n", strerror(errno));
    close(bundle.dev.fd);
    return NULL;
  }

a770 1
    close(s);
d783 1
a783 20
  /*
   * Now, bring up the interface.
   */
  memset(&ifrq, '\0', sizeof ifrq);
  strncpy(ifrq.ifr_name, ifname, sizeof ifrq.ifr_name - 1);
  ifrq.ifr_name[sizeof ifrq.ifr_name - 1] = '\0';
  if (ID0ioctl(s, SIOCGIFFLAGS, &ifrq) < 0) {
    log_Printf(LogERROR, "bundle_Create: ioctl(SIOCGIFFLAGS): %s\n",
	      strerror(errno));
    close(s);
    iface_Destroy(bundle.iface);
    bundle.iface = NULL;
    close(bundle.dev.fd);
    return NULL;
  }
  ifrq.ifr_flags |= IFF_UP;
  if (ID0ioctl(s, SIOCSIFFLAGS, &ifrq) < 0) {
    log_Printf(LogERROR, "bundle_Create: ioctl(SIOCSIFFLAGS): %s\n",
	      strerror(errno));
    close(s);
a789 2
  close(s);

a792 1

a870 3
  struct ifreq ifrq;
  int s;

d872 1
a872 24

  s = ID0socket(AF_INET, SOCK_DGRAM, 0);
  if (s < 0) {
    log_Printf(LogERROR, "bundle_DownInterface: socket: %s\n", strerror(errno));
    return;
  }

  memset(&ifrq, '\0', sizeof ifrq);
  strncpy(ifrq.ifr_name, bundle->iface->name, sizeof ifrq.ifr_name - 1);
  ifrq.ifr_name[sizeof ifrq.ifr_name - 1] = '\0';
  if (ID0ioctl(s, SIOCGIFFLAGS, &ifrq) < 0) {
    log_Printf(LogERROR, "bundle_DownInterface: ioctl(SIOCGIFFLAGS): %s\n",
       strerror(errno));
    close(s);
    return;
  }
  ifrq.ifr_flags &= ~IFF_UP;
  if (ID0ioctl(s, SIOCSIFFLAGS, &ifrq) < 0) {
    log_Printf(LogERROR, "bundle_DownInterface: ioctl(SIOCSIFFLAGS): %s\n",
       strerror(errno));
    close(s);
    return;
  }
  close(s);
@


1.15
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.14 1999/04/26 08:55:00 brian Exp $
d90 1
a90 1
#define SCATTER_SEGMENTS 4	/* version, datalink, name, physical */
@


1.14
log
@Add support for NetBSD
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.13 1999/03/25 11:37:16 brian Exp $
d52 1
a52 7
#ifndef NOALIAS
#ifdef __FreeBSD__
#include <alias.h>
#else
#include "alias.h"
#endif
#endif
a78 1
#include "modem.h"
d80 1
a80 1
#include "lcpproto.h"
d345 1
a345 1
          bundle->ifSpeed += modem_Speed(dl->physical);
d349 1
a349 1
      bundle->ifSpeed = modem_Speed(p);
d385 1
a385 1
          bundle->ifSpeed += modem_Speed(dl->physical);
d635 2
a636 5
          struct mbuf *bp;

          bp = mbuf_Alloc(n, MB_IPIN);
          memcpy(MBUF_CTOP(bp), tun.data, n);
          ip_Input(bundle, bp);
d668 1
a668 7
    if (pri >= 0) {
#ifndef NOALIAS
      if (bundle->AliasEnabled) {
        PacketAliasOut(tun.data, sizeof tun.data);
        n = ntohs(((struct ip *)tun.data)->ip_len);
      }
#endif
a669 1
    }
d1180 1
a1180 1
          add = ip_FlushPacket(&dl->physical->link, bundle);
d1197 1
a1197 1
      prompt_Printf(arg->prompt, " weight %d, %d bytes/sec",
d1690 1
a1690 1
          /* Give away all our modem locks (to the final process) */
d1693 1
a1693 1
              modem_ChangedPid(dl->physical, pid);
d1702 1
a1702 1
      /* Give away all our modem locks (to the intermediate process) */
d1705 1
a1705 1
          modem_ChangedPid(dl->physical, pid);
@


1.13
log
@Undo possible damage done by the new TUNSIFMODE ioctl
in FreeBSD-current.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.12 1999/03/07 01:42:14 brian Exp $
d53 3
a55 1
#ifdef __OpenBSD__
a56 2
#else
#include <alias.h>
@


1.12
log
@Read from fd[0] and write to fd[1] where `fd' is the
result of a pipe().  This matters under OpenBSD.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.11 1999/03/04 17:42:25 brian Exp $
d33 1
d743 3
d800 8
@


1.11
log
@Extend the ``set redial'' command to allow incremental
redial timeouts.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.10 1999/03/01 00:45:14 brian Exp $
d1669 2
a1671 2
      read(fds[1], &done, 1);		/* uu_locks are mine ! */
      close(fds[1]);
d1683 3
a1686 3
          bundle_LockTun(bundle);	/* update pid */
          read(fds[1], &done, 1);	/* uu_locks are mine ! */
          close(fds[1]);
d1694 1
a1694 1
          close(fds[1]);
d1699 2
a1700 2
          write(fds[0], "!", 1);	/* done */
          close(fds[0]);
d1706 1
a1706 1
      close(fds[1]);
d1711 2
a1712 2
      write(fds[0], "!", 1);	/* done */
      close(fds[0]);
@


1.10
log
@Bring up auto links despite there being no data queued if
we're already in network phase and our autoload values
are set with no minimum threshold (the default).

Tell the autoload timer that it's ``coming up'' *before*
calling AutoLoadTimeout() directly... not after.  This
prevents the very first demand-dial connection from
immediately disconnecting when there are other auto links.

Problem diagnosis:  Ted Mittelstaedt <tedm@@toybox.placo.com>
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.9 1999/02/25 12:06:51 brian Exp $
d1142 3
a1144 3
            dl->dial_timer.state == TIMER_RUNNING))) {
        if (force)
          timer_Stop(&dl->dial_timer);
@


1.9
log
@Don't immediately bring auto links back up in multilink
mode (when there is more than one auto link) if there is
no data queued to go out.
Reviewed by: Tom Torrance <tom@@tomqnx.com>
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.8 1999/02/06 03:22:31 brian Exp $
d231 1
a276 2

  bundle->autoload.comingup = up ? 1 : 0;
d528 3
a530 2
      } else if (queued && (bundle->autoload.timer.state != TIMER_RUNNING ||
                            !bundle->autoload.comingup))
@


1.8
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.44 1999/01/28 01:56:30 brian Exp $
d529 2
a530 2
      } else if (bundle->autoload.timer.state != TIMER_RUNNING ||
                 !bundle->autoload.comingup)
@


1.7
log
@Change the timer routines so that they interrupt when the next
item is scheduled rather than interrupting 10 times per second
and finding that there's nothing to do most of the time.
This change reduces interrupt overheads but will expose any
(previously small) latency problems.

Be more careful about building VJ compression requests - we
can't htonl/ntohl the entire four bytes !  Also, when we get
a NAK, try to get as close as possible to what the peer NAKs
with when sending our next REQ.  Similarily when we send a NAK,
pick values as close as possible to what the peer REQd.

Fix a couple of man page typos (compliments of billf@@FreeBSD.org)
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.6 1999/01/06 00:10:02 brian Exp $
a34 1
#include <net/if_dl.h>
d78 3
a138 1
    ipcp_Setup(&bundle->ncp.ipcp);
d560 4
d588 5
d612 5
d892 3
d954 5
d1250 5
@


1.6
log
@Don't warn when ``add xxxx HISADDR'' fails because HISADDR
is 0.0.0.0.  This isn't a problem as the sticky route is still
added.
Suggested by: Chris Timmons <skynyrd@@opus.cts.cwu.edu>
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.5 1998/12/10 18:40:41 brian Exp $
d1663 1
a1663 1
          timer_InitService();
@


1.5
log
@When using ``set device !someprogram'', when ``someprogram''
exits, it causes a select() exception.
Handle these select() exceptions on link descriptors in pretty
much the same way as loss of carrier rather than dropping out
in confusion.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.4 1998/10/29 23:48:19 brian Exp $
d1006 3
a1008 2
      log_Printf(LogERROR, "bundle_SetRoute: Cannot add a route with"
                 " destination 0.0.0.0\n");
@


1.4
log
@Don't call PacketAliasIn() when we turn around packets destined
for our interface address.  We're about to call ip_Input()
anyway, and ip_Input() does the PacketAliasIn().
Stack trace provided by: Cameron Grant <gandalf@@vilnya.demon.co.uk>
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.3 1998/10/29 02:21:44 brian Exp $
d1731 14
@


1.3
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.2 1998/08/31 08:16:34 brian Exp $
a627 6
#ifndef NOALIAS
          if (bundle->AliasEnabled) {
            PacketAliasIn(tun.data, sizeof tun.data);
            n = ntohs(((struct ip *)tun.data)->ip_len);
          }
#endif
@


1.2
log
@Move libalias sources into the ppp directory.
Suggested (many times) by: Theo
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.1 1998/08/31 00:22:16 brian Exp $
d92 1
a151 43
static int
bundle_CleanInterface(const struct bundle *bundle)
{
  int s;
  struct ifreq ifrq;
  struct ifaliasreq ifra;

  s = ID0socket(AF_INET, SOCK_DGRAM, 0);
  if (s < 0) {
    log_Printf(LogERROR, "bundle_CleanInterface: socket(): %s\n",
              strerror(errno));
    return (-1);
  }
  strncpy(ifrq.ifr_name, bundle->ifp.Name, sizeof ifrq.ifr_name - 1);
  ifrq.ifr_name[sizeof ifrq.ifr_name - 1] = '\0';
  while (ID0ioctl(s, SIOCGIFADDR, &ifrq) == 0) {
    memset(&ifra.ifra_mask, '\0', sizeof ifra.ifra_mask);
    strncpy(ifra.ifra_name, bundle->ifp.Name, sizeof ifra.ifra_name - 1);
    ifra.ifra_name[sizeof ifra.ifra_name - 1] = '\0';
    ifra.ifra_addr = ifrq.ifr_addr;
    if (ID0ioctl(s, SIOCGIFDSTADDR, &ifrq) < 0) {
      if (ifra.ifra_addr.sa_family == AF_INET)
        log_Printf(LogERROR, "Can't get dst for %s on %s !\n",
                  inet_ntoa(((struct sockaddr_in *)&ifra.ifra_addr)->sin_addr),
                  bundle->ifp.Name);
      close(s);
      return 0;
    }
    ifra.ifra_broadaddr = ifrq.ifr_dstaddr;
    if (ID0ioctl(s, SIOCDIFADDR, &ifra) < 0) {
      if (ifra.ifra_addr.sa_family == AF_INET)
        log_Printf(LogERROR, "Can't delete %s address on %s !\n",
                  inet_ntoa(((struct sockaddr_in *)&ifra.ifra_addr)->sin_addr),
                  bundle->ifp.Name);
      close(s);
      return 0;
    }
  }
  close(s);

  return 1;
}

d348 1
a348 1
      bundle->ifp.Speed = 0;
d351 1
a351 1
          bundle->ifp.Speed += modem_Speed(dl->physical);
d355 1
a355 1
      bundle->ifp.Speed = modem_Speed(p);
d385 1
a385 1
      bundle->ifp.Speed = 0;
d391 1
a391 1
          bundle->ifp.Speed += modem_Speed(dl->physical);
d393 1
a393 1
      if (bundle->ifp.Speed)
d730 1
d734 1
a734 1
  if (bundle.ifp.Name != NULL) {	/* Already allocated ! */
d765 2
d775 3
a777 3
  bundle.ifp.Name = strrchr(bundle.dev.Name, '/');
  if (bundle.ifp.Name == NULL)
    bundle.ifp.Name = bundle.dev.Name;
d779 8
a786 1
    bundle.ifp.Name++;
d792 1
a792 1
  strncpy(ifrq.ifr_name, bundle.ifp.Name, sizeof ifrq.ifr_name - 1);
d798 2
a800 1
    bundle.ifp.Name = NULL;
d808 2
a810 1
    bundle.ifp.Name = NULL;
d816 1
a816 7
  if ((bundle.ifp.Index = GetIfIndex(bundle.ifp.Name)) < 0) {
    log_Printf(LogERROR, "Can't find interface index.\n");
    close(bundle.dev.fd);
    bundle.ifp.Name = NULL;
    return NULL;
  }
  log_Printf(LogPHASE, "Using interface: %s\n", bundle.ifp.Name);
d818 1
a818 1
  bundle.ifp.Speed = 0;
d849 2
a851 1
    bundle.ifp.Name = NULL;
d885 1
a885 1
  bundle_CleanInterface(&bundle);
d907 1
a907 1
  strncpy(ifrq.ifr_name, bundle->ifp.Name, sizeof ifrq.ifr_name - 1);
d953 2
a954 1
  bundle->ifp.Name = NULL;
d990 11
d1012 4
a1015 18
      /* Add a route through the interface */
      struct sockaddr_dl dl;
      const char *iname;
      int ilen;

      iname = Index2Nam(bundle->ifp.Index);
      ilen = strlen(iname);
      dl.sdl_len = sizeof dl - sizeof dl.sdl_data + ilen;
      dl.sdl_family = AF_LINK;
      dl.sdl_index = bundle->ifp.Index;
      dl.sdl_type = 0;
      dl.sdl_nlen = ilen;
      dl.sdl_alen = 0;
      dl.sdl_slen = 0;
      strncpy(dl.sdl_data, iname, sizeof dl.sdl_data);
      memcpy(cp, &dl, dl.sdl_len);
      cp += dl.sdl_len;
      rtmes.m_rtm.rtm_addrs |= RTA_GATEWAY;
d1048 1
a1048 1
                  inet_ntoa(dst));
d1205 1
d1208 1
a1208 1
                arg->bundle->ifp.Name, arg->bundle->ifp.Speed);
d1247 11
d1268 2
d1274 2
a1617 5
  if (omode == PHYS_AUTO && !(bundle->phys_type.all & PHYS_AUTO) &&
      bundle->phase != PHASE_NETWORK)
    /* No auto links left */
    ipcp_CleanInterface(&bundle->ncp.ipcp);

d1724 13
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d26 1
a26 1
 *	$Id: bundle.c,v 1.34 1998/08/26 17:39:36 brian Exp $
a39 3
#ifndef NOALIAS
#include <alias.h>
#endif
d52 7
@

