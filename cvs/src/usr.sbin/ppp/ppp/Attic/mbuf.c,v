head	1.19;
access;
symbols
	OPENBSD_5_5:1.18.0.38
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.34
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.32
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.30
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.28
	OPENBSD_5_0:1.18.0.26
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.24
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.22
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.18
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.20
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.16
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.14
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.12
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.10
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.8
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.6
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.16.0.12
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.10
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.8
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.6
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.4
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.18;

1.18
date	2005.07.17.19.13.25;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.12.02.47.19;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.15.08.02.00;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.19.23.22.18;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.13.21.33.41;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.02.00.54.34;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.07.10.12.14;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.03.21.52.57;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.08.26.06.39.19;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.08.09.23.01.52;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.02.15.58.41;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.09.20.04.02;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.37;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.03.29.08.20.32;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.02.06.03.22.42;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.24;	author brian;	state Exp;
branches;
next	;


desc
@@


1.19
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: mbuf.c,v 1.18 2005/07/17 19:13:25 brad Exp $
 */

#include <sys/types.h>

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>
#include <termios.h>

#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "descriptor.h"
#include "prompt.h"
#include "main.h"

#define BUCKET_CHUNK	20
#define BUCKET_HASH	256

struct mbucket;

struct mfree {
  struct mbucket *next;
  size_t count;
};

static struct mbucket {
  union {
    struct mbuf m;
    struct mfree f;
  } u;
} *bucket[(M_MAXLEN + sizeof(struct mbuf)) / BUCKET_HASH];

#define M_BINDEX(sz)	(((sz) + sizeof(struct mbuf) - 1) / BUCKET_HASH)
#define M_BUCKET(sz)	(bucket + M_BINDEX(sz))
#define M_ROUNDUP(sz)	((M_BINDEX(sz) + 1) * BUCKET_HASH)

static struct memmap {
  struct mbuf *queue;
  size_t fragments;
  size_t octets;
} MemMap[MB_MAX + 1];

static unsigned long long mbuf_Mallocs, mbuf_Frees;

int
m_length(struct mbuf *bp)
{
  int len;

  for (len = 0; bp; bp = bp->m_next)
    len += bp->m_len;
  return len;
}

static const char *
mbuftype(int type)
{
  static const char * const mbufdesc[MB_MAX] = {
    "ip in", "ip out", "ipv6 in", "ipv6 out", "nat in", "nat out",
    "mp in", "mp out", "vj in", "vj out", "icompd in", "icompd out",
    "compd in", "compd out", "lqr in", "lqr out", "echo in", "echo out",
    "proto in", "proto out", "acf in", "acf out", "sync in", "sync out",
    "hdlc in", "hdlc out", "async in", "async out", "cbcp in", "cbcp out",
    "chap in", "chap out", "pap in", "pap out", "ccp in", "ccp out",
    "ipcp in", "ipcp out", "ipv6cp in", "ipv6cp out", "lcp in", "lcp out"
  };

  return type < 0 || type >= MB_MAX ? "unknown" : mbufdesc[type];
}

struct mbuf *
m_get(size_t m_len, int type)
{
  struct mbucket **mb;
  struct mbuf *bp;
  size_t size;

  if (type > MB_MAX) {
    log_Printf(LogERROR, "Bad mbuf type %d\n", type);
    type = MB_UNKNOWN;
  }

  if (m_len > M_MAXLEN || m_len == 0) {
    log_Printf(LogERROR, "Request for mbuf size %lu (\"%s\") denied !\n",
               (u_long)m_len, mbuftype(type));
    AbortProgram(EX_OSERR);
  }

  mb = M_BUCKET(m_len);
  size = M_ROUNDUP(m_len);

  if (*mb) {
    /* We've got some free blocks of the right size */
    bp = &(*mb)->u.m;
    if (--(*mb)->u.f.count == 0)
      *mb = (*mb)->u.f.next;
    else {
      ((struct mbucket *)((char *)*mb + size))->u.f.count = (*mb)->u.f.count;
      *mb = (struct mbucket *)((char *)*mb + size);
      (*mb)->u.f.next = NULL;
    }
  } else {
    /*
     * Allocate another chunk of mbufs, use the first and put the rest on
     * the free list
     */
    *mb = (struct mbucket *)malloc(BUCKET_CHUNK * size);
    if (*mb == NULL) {
      log_Printf(LogALERT, "Failed to allocate memory (%lu)\n",
                 (unsigned long)BUCKET_CHUNK * size);
      AbortProgram(EX_OSERR);
    }
    bp = &(*mb)->u.m;
    *mb = (struct mbucket *)((char *)*mb + size);
    (*mb)->u.f.count = BUCKET_CHUNK - 1;
    (*mb)->u.f.next = NULL;
  }

  mbuf_Mallocs++;

  memset(bp, '\0', sizeof(struct mbuf));
  bp->m_size = size - sizeof *bp;
  bp->m_len = m_len;
  bp->m_type = type;

  MemMap[type].fragments++;
  MemMap[type].octets += bp->m_size;

  return bp;
}

struct mbuf *
m_free(struct mbuf *bp)
{
  struct mbucket **mb, *f;
  struct mbuf *nbp;

  if ((f = (struct mbucket *)bp) != NULL) {
    MemMap[bp->m_type].fragments--;
    MemMap[bp->m_type].octets -= bp->m_size;

    nbp = bp->m_next;
    mb = M_BUCKET(bp->m_size);
    f->u.f.next = *mb;
    f->u.f.count = 1;
    *mb = f;

    mbuf_Frees++;
    bp = nbp;
  }

  return bp;
}

void
m_freem(struct mbuf *bp)
{
  while (bp)
    bp = m_free(bp);
}

struct mbuf *
mbuf_Read(struct mbuf *bp, void *v, size_t len)
{
  int nb;
  u_char *ptr = v;

  while (bp && len > 0) {
    if (len > bp->m_len)
      nb = bp->m_len;
    else
      nb = len;
    if (nb) {
      memcpy(ptr, MBUF_CTOP(bp), nb);
      ptr += nb;
      bp->m_len -= nb;
      len -= nb;
      bp->m_offset += nb;
    }
    if (bp->m_len == 0)
      bp = m_free(bp);
  }

  while (bp && bp->m_len == 0)
    bp = m_free(bp);

  return bp;
}

size_t
mbuf_View(struct mbuf *bp, void *v, size_t len)
{
  size_t nb, l = len;
  u_char *ptr = v;

  while (bp && l > 0) {
    if (l > bp->m_len)
      nb = bp->m_len;
    else
      nb = l;
    memcpy(ptr, MBUF_CTOP(bp), nb);
    ptr += nb;
    l -= nb;
    bp = bp->m_next;
  }

  return len - l;
}

struct mbuf *
m_prepend(struct mbuf *bp, const void *ptr, size_t len, size_t extra)
{
  struct mbuf *head;

  if (bp && bp->m_offset) {
    if (bp->m_offset >= len) {
      bp->m_offset -= len;
      bp->m_len += len;
      if (ptr)
        memcpy(MBUF_CTOP(bp), ptr, len);
      return bp;
    }
    len -= bp->m_offset;
    if (ptr)
      memcpy(bp + 1, (const char *)ptr + len, bp->m_offset);
    bp->m_len += bp->m_offset;
    bp->m_offset = 0;
  }

  head = m_get(len + extra, bp ? bp->m_type : MB_UNKNOWN);
  head->m_offset = extra;
  head->m_len -= extra;
  if (ptr)
    memcpy(MBUF_CTOP(head), ptr, len);
  head->m_next = bp;

  return head;
}

struct mbuf *
m_adj(struct mbuf *bp, ssize_t n)
{
  if (n > 0) {
    while (bp) {
      if (n < bp->m_len) {
        bp->m_len = n;
        bp->m_offset += n;
        return bp;
      }
      n -= bp->m_len;
      bp = m_free(bp);
    }
  } else {
    if ((n = m_length(bp) + n) <= 0) {
      m_freem(bp);
      return NULL;
    }
    for (; bp; bp = bp->m_next, n -= bp->m_len)
      if (n < bp->m_len) {
        bp->m_len = n;
        m_freem(bp->m_next);
        bp->m_next = NULL;
        break;
      }
  }

  return bp;
}

void
mbuf_Write(struct mbuf *bp, const void *ptr, size_t m_len)
{
  int plen;
  int nb;

  plen = m_length(bp);
  if (plen < m_len)
    m_len = plen;

  while (m_len > 0) {
    nb = (m_len < bp->m_len) ? m_len : bp->m_len;
    memcpy(MBUF_CTOP(bp), ptr, nb);
    m_len -= bp->m_len;
    bp = bp->m_next;
  }
}

int
mbuf_Show(struct cmdargs const *arg)
{
  int i;

  prompt_Printf(arg->prompt, "Fragments (octets) in use:\n");
  for (i = 0; i < MB_MAX; i += 2)
    prompt_Printf(arg->prompt, "%10.10s: %04lu (%06lu)\t"
                  "%10.10s: %04lu (%06lu)\n",
	          mbuftype(i), (u_long)MemMap[i].fragments,
                  (u_long)MemMap[i].octets, mbuftype(i+1),
                  (u_long)MemMap[i+1].fragments, (u_long)MemMap[i+1].octets);

  if (i == MB_MAX)
    prompt_Printf(arg->prompt, "%10.10s: %04lu (%06lu)\n",
                  mbuftype(i), (u_long)MemMap[i].fragments,
                  (u_long)MemMap[i].octets);

  prompt_Printf(arg->prompt, "Mallocs: %llu,   Frees: %llu\n",
                mbuf_Mallocs, mbuf_Frees);

  return 0;
}

struct mbuf *
m_dequeue(struct mqueue *q)
{
  struct mbuf *bp;

  log_Printf(LogDEBUG, "m_dequeue: queue len = %lu\n", (u_long)q->len);
  bp = q->top;
  if (bp) {
    q->top = q->top->m_nextpkt;
    q->len--;
    if (q->top == NULL) {
      q->last = q->top;
      if (q->len)
	log_Printf(LogERROR, "m_dequeue: Not zero (%lu)!!!\n",
                   (u_long)q->len);
    }
    bp->m_nextpkt = NULL;
  }

  return bp;
}

void
m_enqueue(struct mqueue *queue, struct mbuf *bp)
{
  if (bp != NULL) {
    if (queue->last) {
      queue->last->m_nextpkt = bp;
      queue->last = bp;
    } else
      queue->last = queue->top = bp;
    queue->len++;
    log_Printf(LogDEBUG, "m_enqueue: len = %lu\n", (unsigned long)queue->len);
  }
}

struct mbuf *
m_pullup(struct mbuf *bp)
{
  /* Put it all in one contigous (aligned) mbuf */

  if (bp != NULL) {
    if (bp->m_next != NULL) {
      struct mbuf *nbp;
      u_char *cp;

      nbp = m_get(m_length(bp), bp->m_type);

      for (cp = MBUF_CTOP(nbp); bp; bp = m_free(bp)) {
        memcpy(cp, MBUF_CTOP(bp), bp->m_len);
        cp += bp->m_len;
      }
      bp = nbp;
    }
#ifndef __i386__	/* Do any other archs not care about alignment ? */
    else if ((bp->m_offset & (sizeof(long) - 1)) != 0) {
      bcopy(MBUF_CTOP(bp), bp + 1, bp->m_len);
      bp->m_offset = 0;
    }
#endif
  }

  return bp;
}

void
m_settype(struct mbuf *bp, int type)
{
  for (; bp; bp = bp->m_next)
    if (type != bp->m_type) {
      MemMap[bp->m_type].fragments--;
      MemMap[bp->m_type].octets -= bp->m_size;
      bp->m_type = type;
      MemMap[type].fragments++;
      MemMap[type].octets += bp->m_size;
    }
}

struct mbuf *
m_append(struct mbuf *bp, const void *v, size_t sz)
{
  struct mbuf *m = bp;

  if (m) {
    while (m->m_next)
      m = m->m_next;
    if (m->m_size - m->m_len >= sz) {
      if (v)
        memcpy((char *)(m + 1) + m->m_len, v, sz);
      m->m_len += sz;
    } else
      m->m_next = m_prepend(NULL, v, sz, 0);
  } else
    bp = m_prepend(NULL, v, sz, 0);

  return bp;
}
@


1.18
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: mbuf.c,v 1.17 2005/07/12 02:47:19 brad Exp $
@


1.17
log
@rev 1.45

Add a missing memcpy

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: mbuf.c,v 1.16 2002/06/15 08:02:00 brian Exp $
d33 1
@


1.16
log
@Tidy up end of line whitespace
@
text
@d28 1
a28 1
 * $OpenBSD: mbuf.c,v 1.15 2001/08/19 23:22:18 brian Exp $
d250 2
a251 1
      memcpy(MBUF_CTOP(bp), ptr, len);
d255 2
a256 1
    memcpy(bp + 1, (const char *)ptr + len, bp->m_offset);
d429 3
a431 1
    if (m->m_size - m->m_len > sz)
d433 1
a433 1
    else
@


1.15
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: mbuf.c,v 1.14 2001/06/13 21:33:41 brian Exp $
d89 1
a89 1
  static const char * const mbufdesc[MB_MAX] = { 
d113 1
a113 1
  
d345 1
a345 1
  
@


1.14
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d90 7
a96 7
    "ip in", "ip out", "nat in", "nat out", "mp in", "mp out",
    "vj in", "vj out", "icompd in", "icompd out", "compd in", "compd out",
    "lqr in", "lqr out", "echo in", "echo out", "proto in", "proto out",
    "acf in", "acf out", "sync in", "sync out", "hdlc in", "hdlc out",
    "async in", "async out", "cbcp in", "cbcp out", "chap in", "chap out",
    "pap in", "pap out", "ccp in", "ccp out", "ipcp in", "ipcp out",
    "lcp in", "lcp out"
@


1.13
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d1 5
a5 2
/*
 *	      PPP Memory handling module
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 15
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan, Inc.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: mbuf.c,v 1.12 2000/05/07 10:12:14 brian Exp $
d28 1
d30 1
@


1.12
log
@Correct a bad bug in m_prepend()

Submitted by: luoqi@@FreeBSD.org
@
text
@d20 1
a20 1
 * $OpenBSD: mbuf.c,v 1.11 2000/03/03 21:52:57 brian Exp $
d78 16
d107 2
a108 1
    log_Printf(LogERROR, "Request for mbuf size %lu denied\n", (u_long)m_len);
a312 9
  static const char * const mbuftype[] = { 
    "ip in", "ip out", "nat in", "nat out", "mp in", "mp out",
    "vj in", "vj out", "icompd in", "icompd out", "compd in", "compd out",
    "lqr in", "lqr out", "echo in", "echo out", "proto in", "proto out",
    "acf in", "acf out", "sync in", "sync out", "hdlc in", "hdlc out",
    "async in", "async out", "cbcp in", "cbcp out", "chap in", "chap out",
    "pap in", "pap out", "ccp in", "ccp out", "ipcp in", "ipcp out",
    "lcp in", "lcp out", "unknown"
  };
d318 2
a319 2
	          mbuftype[i], (u_long)MemMap[i].fragments,
                  (u_long)MemMap[i].octets, mbuftype[i+1],
d324 1
a324 1
                  mbuftype[i], (u_long)MemMap[i].fragments,
@


1.11
log
@Fix some printf-type argument bugs
@
text
@d20 1
a20 1
 * $OpenBSD: mbuf.c,v 1.10 2000/02/27 01:38:27 brian Exp $
d404 1
a404 1
m_append(struct mbuf *m, const void *v, size_t sz)
d406 2
d416 1
a416 1
    m = m_prepend(NULL, v, sz, 0);
d418 1
a418 1
  return m;
@


1.10
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: mbuf.c,v 1.9 2000/01/07 03:26:55 brian Exp $
d115 2
a116 2
      log_Printf(LogALERT, "Failed to allocate memory (%u)\n",
                 BUCKET_CHUNK * size);
d357 1
a357 1
    log_Printf(LogDEBUG, "m_enqueue: len = %d\n", queue->len);
@


1.9
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: mbuf.c,v 1.8 1999/08/26 06:39:19 brian Exp $
@


1.8
log
@Align mbufs to sizeof(long), not 4
@
text
@d20 1
a20 1
 * $Id: mbuf.c,v 1.7 1999/08/09 23:01:52 brian Exp $
d39 21
d62 2
a63 1
  int fragments, octets;
a65 1
static int totalalloced;
d69 1
a69 1
mbuf_Length(struct mbuf *bp)
d73 2
a74 2
  for (len = 0; bp; bp = bp->next)
    len += bp->cnt;
d79 1
a79 1
mbuf_Alloc(int cnt, int type)
d81 1
d83 1
d89 3
a91 4
  bp = malloc(sizeof(struct mbuf) + cnt);
  if (bp == NULL) {
    log_Printf(LogALERT, "failed to allocate memory: %ld\n",
               (long)sizeof(struct mbuf));
d94 31
d126 1
d128 4
d133 2
a134 4
  MemMap[type].octets += cnt;
  totalalloced += cnt;
  bp->size = bp->cnt = cnt;
  bp->type = type;
d139 1
a139 1
mbuf_FreeSeg(struct mbuf *bp)
d141 1
d144 10
a153 6
  if (bp) {
    nbp = bp->next;
    MemMap[bp->type].fragments--;
    MemMap[bp->type].octets -= bp->size;
    totalalloced -= bp->size;
    free(bp);
d162 1
a162 1
mbuf_Free(struct mbuf *bp)
d165 1
a165 1
    bp = mbuf_FreeSeg(bp);
d175 2
a176 2
    if (len > bp->cnt)
      nb = bp->cnt;
d182 1
a182 1
      bp->cnt -= nb;
d184 1
a184 1
      bp->offset += nb;
d186 2
a187 2
    if (bp->cnt == 0)
      bp = mbuf_FreeSeg(bp);
d190 2
a191 2
  while (bp && bp->cnt == 0)
    bp = mbuf_FreeSeg(bp);
d203 2
a204 2
    if (l > bp->cnt)
      nb = bp->cnt;
d210 1
a210 1
    bp = bp->next;
d217 1
a217 1
mbuf_Prepend(struct mbuf *bp, const void *ptr, size_t len, size_t extra)
d221 4
a224 4
  if (bp && bp->offset) {
    if (bp->offset >= len) {
      bp->offset -= len;
      bp->cnt += len;
d228 4
a231 4
    len -= bp->offset;
    memcpy(bp + sizeof *bp, (const char *)ptr + len, bp->offset);
    bp->cnt += bp->offset;
    bp->offset = 0;
d234 6
a239 5
  head = mbuf_Alloc(len + extra, bp ? bp->type : MB_UNKNOWN);
  head->offset = extra;
  head->cnt -= extra;
  memcpy(MBUF_CTOP(head), ptr, len);
  head->next = bp;
d245 1
a245 1
mbuf_Truncate(struct mbuf *bp, size_t n)
d247 22
a268 3
  if (n == 0) {
    mbuf_Free(bp);
    return NULL;
a270 8
  for (; bp; bp = bp->next, n -= bp->cnt)
    if (n < bp->cnt) {
      bp->cnt = n;
      mbuf_Free(bp->next);
      bp->next = NULL;
      break;
    }

d275 1
a275 1
mbuf_Write(struct mbuf *bp, const void *ptr, size_t cnt)
d280 3
a282 3
  plen = mbuf_Length(bp);
  if (plen < cnt)
    cnt = plen;
d284 2
a285 2
  while (cnt > 0) {
    nb = (cnt < bp->cnt) ? cnt : bp->cnt;
d287 2
a288 2
    cnt -= bp->cnt;
    bp = bp->next;
d296 2
a297 2
  static const char *mbuftype[] = { 
    "ip in", "ip out", "alias in", "alias out", "mp in", "mp out",
d308 5
a312 3
    prompt_Printf(arg->prompt, "%10.10s: %04d (%06d)\t%10.10s: %04d (%06d)\n",
	    mbuftype[i], MemMap[i].fragments, MemMap[i].octets,
            mbuftype[i+1], MemMap[i+1].fragments, MemMap[i+1].octets);
d315 3
a317 2
    prompt_Printf(arg->prompt, "%10.10s: %04d (%06d)\n",
                  mbuftype[i], MemMap[i].fragments, MemMap[i].octets);
d326 1
a326 1
mbuf_Dequeue(struct mqueue *q)
d330 1
a330 1
  log_Printf(LogDEBUG, "mbuf_Dequeue: queue len = %d\n", q->qlen);
d333 2
a334 2
    q->top = q->top->pnext;
    q->qlen--;
d337 3
a339 2
      if (q->qlen)
	log_Printf(LogERROR, "mbuf_Dequeue: Not zero (%d)!!!\n", q->qlen);
d341 1
a341 1
    bp->pnext = NULL;
d348 1
a348 1
mbuf_Enqueue(struct mqueue *queue, struct mbuf *bp)
d352 1
a352 1
      queue->last->pnext = bp;
d356 2
a357 2
    queue->qlen++;
    log_Printf(LogDEBUG, "mbuf_Enqueue: len = %d\n", queue->qlen);
d362 1
a362 1
mbuf_Contiguous(struct mbuf *bp)
d367 1
a367 1
    if (bp->next != NULL) {
d371 1
a371 1
      nbp = mbuf_Alloc(mbuf_Length(bp), bp->type);
d373 3
a375 3
      for (cp = MBUF_CTOP(nbp); bp; bp = mbuf_FreeSeg(bp)) {
        memcpy(cp, MBUF_CTOP(bp), bp->cnt);
        cp += bp->cnt;
d380 3
a382 3
    else if ((bp->offset & (sizeof(long) - 1)) != 0) {
      bcopy(MBUF_CTOP(bp), bp + 1, bp->cnt);
      bp->offset = 0;
d391 1
a391 1
mbuf_SetType(struct mbuf *bp, int type)
d393 5
a397 5
  for (; bp; bp = bp->next)
    if (type != bp->type) {
      MemMap[bp->type].fragments--;
      MemMap[bp->type].octets -= bp->size;
      bp->type = type;
d399 1
a399 1
      MemMap[type].octets += bp->size;
d401 16
@


1.7
log
@Change printf formats %q[du] -> %ll[du]
@
text
@d20 1
a20 1
 * $Id: mbuf.c,v 1.6 1999/06/02 15:58:41 brian Exp $
d303 1
a303 1
    else if ((bp->offset & 0x03) != 0) {
@


1.6
log
@o Alter the mbuf type as it's processed by different layers.
o Show more information about missing MP fragments in ``show mp''.
o Do away with mbuf_Log().  It was showing mbuf stats twice on
  receipt of LCP/CCP/IPCP packets.... ???!!?
o Pre-allocate a bit extra when creating LQR packets to avoid having
  to allocate another mbuf in mbuf_Prepend().
@
text
@d20 1
a20 1
 * $Id: mbuf.c,v 1.5 1999/05/09 20:04:02 brian Exp $
d243 1
a243 1
  prompt_Printf(arg->prompt, "Mallocs: %qu,   Frees: %qu\n",
@


1.5
log
@Deal with the fact that as we now mbuf_Read the fsm
header in fsm_Input() we often end up with a NULL mbuf.

Deal with a possible NULL mbuf being passed into
mbuf_Prepend().

Adjust some spacing to make things more consistent.
@
text
@d20 1
a20 1
 * $Id: mbuf.c,v 1.4 1999/05/08 11:06:37 brian Exp $
d42 1
a42 1
} MemMap[MB_MAX + 2];
d62 1
a62 1
  if (type > MB_MAX)
d64 2
d173 1
a173 1
  head = mbuf_Alloc(len + extra, bp ? bp->type : MB_FSM);
d224 8
a231 2
    "async", "fsm", "cbcp", "hdlcout", "ipin", "echo", "lqr", "vjcomp",
    "ipq", "mp" };
d234 1
a234 1
  for (i = 1; i < MB_MAX; i += 2)
d236 2
a237 2
	    mbuftype[i-1], MemMap[i].fragments, MemMap[i].octets, mbuftype[i],
            MemMap[i+1].fragments, MemMap[i+1].octets);
d241 1
a241 1
                  mbuftype[i-1], MemMap[i].fragments, MemMap[i].octets);
a248 12
void
mbuf_Log()
{
  log_Printf(LogDEBUG, "mbuf_Log: mem alloced: %d\n", totalalloced);
  log_Printf(LogDEBUG, "mbuf_Log:  1: %d  2: %d   3: %d   4: %d\n",
	MemMap[1].octets, MemMap[2].octets, MemMap[3].octets, MemMap[4].octets);
  log_Printf(LogDEBUG, "mbuf_Log:  5: %d  6: %d   7: %d   8: %d\n",
	MemMap[5].octets, MemMap[6].octets, MemMap[7].octets, MemMap[8].octets);
  log_Printf(LogDEBUG, "mbuf_Log:  9: %d 10: %d  11: %d\n",
	MemMap[9].octets, MemMap[10].octets, MemMap[11].octets);
}

d311 13
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: mbuf.c,v 1.3 1999/03/29 08:20:32 brian Exp $
d48 1
a48 1
mbuf_Length(struct mbuf * bp)
d54 1
a54 1
  return (len);
d158 1
a158 1
  if (bp->offset) {
d171 1
a171 1
  head = mbuf_Alloc(len + extra, bp->type);
d277 9
a285 7
  if (queue->last) {
    queue->last->pnext = bp;
    queue->last = bp;
  } else
    queue->last = queue->top = bp;
  queue->qlen++;
  log_Printf(LogDEBUG, "mbuf_Enqueue: len = %d\n", queue->qlen);
d293 12
a304 9
  if (bp->next != NULL) {
    struct mbuf *nbp;
    u_char *cp;

    nbp = mbuf_Alloc(mbuf_Length(bp), bp->type);

    for (cp = MBUF_CTOP(nbp); bp; bp = mbuf_FreeSeg(bp)) {
      memcpy(cp, MBUF_CTOP(bp), bp->cnt);
      cp += bp->cnt;
a305 2
    bp = nbp;
  }
d307 5
a311 3
  else if ((bp->offset & 0x03) != 0) {
    bcopy(MBUF_CTOP(bp), bp + 1, bp->cnt);
    bp->offset = 0;
a312 1
#endif
@


1.3
log
@Ensure that the thing we're casting to struct ip
is aligned for non-i386 architectures.
@
text
@d20 1
a20 1
 * $Id: mbuf.c,v 1.2 1999/02/06 03:22:42 brian Exp $
d45 1
d70 1
d81 1
a81 1
mbuf_FreeSeg(struct mbuf * bp)
d91 1
d99 1
a99 1
mbuf_Free(struct mbuf * bp)
d106 1
a106 1
mbuf_Read(struct mbuf * bp, u_char * ptr, int len)
d109 1
d116 28
d146 40
a185 5
    bp->cnt -= nb;
    len -= nb;
    bp->offset += nb;
    if (bp->cnt == 0)
      bp = mbuf_FreeSeg(bp);
d187 10
a196 1
  return (bp);
d200 1
a200 1
mbuf_Write(struct mbuf * bp, u_char * ptr, int cnt)
d222 2
a223 2
    "async", "fsm", "cbcp", "hdlcout", "ipin", "echo", "lqr", "link",
    "vjcomp", "ipq", "mp" };
d234 3
@


1.2
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: mbuf.c,v 1.22 1998/08/25 17:48:42 brian Exp $
d75 1
a75 2
  bp->pnext = NULL;
  return (bp);
d89 1
a89 1
    return (nbp);
d91 2
a92 1
  return (bp);
a194 1

d205 27
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d117 1
a117 4
    if (bp->cnt == 0) {
#ifdef notdef
      bp = bp->next;
#else
a118 2
#endif
    }
@

