head	1.22;
access;
symbols
	OPENBSD_5_5:1.21.0.14
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.10
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.8
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.36
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.34
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.30
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.32
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.28
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.26
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.24
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.22
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.20
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.18
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.16
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.14
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.12
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.10
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.8
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.6
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.4
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.21;

1.21
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.19.10.24.56;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.14.22.02.50;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.27.01.38.27;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.27.00.21.09;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	99.07.15.02.04.06;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	99.06.05.21.36.01;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.06.01.19.08.52;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.05.24.16.39.19;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.05.12.10.03.52;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.05.08.11.06.38;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.04.27.00.21.25;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.04.19.16.59.40;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.02.16.00.18.03;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.22.42;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.01.10.02.23.22;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.25;	author brian;	state Exp;
branches;
next	;


desc
@@


1.22
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*
 * Written by Eivind Eklund <eivind@@yes.no>
 *    for Yes Interactive
 *
 * Copyright (C) 1998, Yes Interactive.  All rights reserved.
 *
 * Redistribution and use in any form is permitted.  Redistribution in
 * source form should include the above copyright and this set of
 * conditions, because large sections american law seems to have been
 * created by a bunch of jerks on drugs that are now illegal, forcing
 * me to include this copyright-stuff instead of placing this in the
 * public domain.  The name of of 'Yes Interactive' or 'Eivind Eklund'
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  $OpenBSD: physical.h,v 1.21 2011/04/06 11:36:26 miod Exp $
 *
 */

struct datalink;
struct bundle;
struct iovec;
struct physical;
struct bundle;
struct ccp;
struct cmdargs;

/* Device types (don't use zero, it'll be confused with NULL in physical2iov */
#define I4B_DEVICE	1
#define TTY_DEVICE	2
#define TCP_DEVICE	3
#define UDP_DEVICE	4
#define ETHER_DEVICE	5
#define EXEC_DEVICE	6
#define ATM_DEVICE	7
#define NG_DEVICE	8

/* Returns from awaitcarrier() */
#define CARRIER_PENDING	1
#define CARRIER_OK	2
#define CARRIER_LOST	3

/* A cd ``necessity'' value */
#define CD_VARIABLE	0
#define CD_REQUIRED	1
#define CD_NOTREQUIRED	2
#define CD_DEFAULT	3

struct cd {
  unsigned necessity : 2;  /* A CD_ value */
  int delay;               /* Wait this many seconds after login script */
};

struct device {
  int type;
  const char *name;
  u_short mtu;
  struct cd cd;

  int (*awaitcarrier)(struct physical *);
  int (*removefromset)(struct physical *, fd_set *, fd_set *, fd_set *);
  int (*raw)(struct physical *);
  void (*offline)(struct physical *);
  void (*cooked)(struct physical *);
  void (*setasyncparams)(struct physical *, u_int32_t, u_int32_t);
  void (*stoptimer)(struct physical *);
  void (*destroy)(struct physical *);
  ssize_t (*read)(struct physical *, void *, size_t);
  ssize_t (*write)(struct physical *, const void *, size_t);
  void (*device2iov)(struct device *, struct iovec *, int *, int, int *, int *);
  int (*speed)(struct physical *);
  const char *(*openinfo)(struct physical *);
  int (*slot)(struct physical *);
};

struct physical {
  struct link link;
  struct fdescriptor desc;
  int type;                    /* What sort of PHYS_* link are we ? */
  struct async async;          /* Our async state */
  struct hdlc hdlc;            /* Our hdlc state */
  int fd;                      /* File descriptor for this device */
  struct mbuf *out;            /* mbuf that suffered a short write */
  int connect_count;
  struct datalink *dl;         /* my owner */

  struct {
    u_char buf[MAX_MRU];       /* Our input data buffer */
    size_t sz;
  } input;

  struct {
    char full[DEVICE_LEN];     /* Our current device name */
    char *base;
  } name;

  time_t Utmp;                 /* Are we in utmp ? */
  pid_t session_owner;         /* HUP this when closing the link */

  struct device *handler;      /* device specific handler */

  struct {
    unsigned rts_cts : 1;      /* Is rts/cts enabled ? */
    unsigned parity;           /* What parity is enabled? (tty flags) */
    unsigned speed;            /* tty speed */

    char devlist[LINE_LEN];    /* NUL separated list of devices */
    int ndev;                  /* number of devices in list */
    struct cd cd;
  } cfg;
};

#define field2phys(fp, name) \
  ((struct physical *)((char *)fp - (int)(&((struct physical *)NULL)->name)))

#define link2physical(l) \
  ((l)->type == PHYSICAL_LINK ? field2phys(l, link) : NULL)

#define descriptor2physical(d) \
  ((d)->type == PHYSICAL_DESCRIPTOR ? field2phys(d, desc) : NULL)

#define PHYSICAL_NOFORCE		1
#define PHYSICAL_FORCE_ASYNC		2
#define PHYSICAL_FORCE_SYNC		3
#define PHYSICAL_FORCE_SYNCNOACF	4

extern struct physical *physical_Create(struct datalink *, int);
extern int physical_Open(struct physical *, struct bundle *);
extern int physical_Raw(struct physical *);
extern int physical_GetSpeed(struct physical *);
extern int physical_SetSpeed(struct physical *, int);
extern int physical_SetParity(struct physical *, const char *);
extern int physical_SetRtsCts(struct physical *, int);
extern void physical_SetSync(struct physical *);
extern int physical_ShowStatus(struct cmdargs const *);
extern void physical_Offline(struct physical *);
extern void physical_Close(struct physical *);
extern void physical_Destroy(struct physical *);
extern struct physical *iov2physical(struct datalink *, struct iovec *, int *,
                                     int, int, int *, int *);
extern int physical2iov(struct physical *, struct iovec *, int *, int, int *,
                        int *);
extern const char *physical_LockedDevice(struct physical *);
extern void physical_ChangedPid(struct physical *, pid_t);

extern int physical_IsSync(struct physical *);
extern u_short physical_DeviceMTU(struct physical *);
extern const char *physical_GetDevice(struct physical *);
extern void physical_SetDeviceList(struct physical *, int, const char *const *);
extern void physical_SetDevice(struct physical *, const char *);

extern ssize_t physical_Read(struct physical *, void *, size_t);
extern ssize_t physical_Write(struct physical *, const void *, size_t);
extern int physical_doUpdateSet(struct fdescriptor *, fd_set *, fd_set *,
                                fd_set *, int *, int);
extern int physical_IsSet(struct fdescriptor *, const fd_set *);
extern void physical_DescriptorRead(struct fdescriptor *, struct bundle *,
                                    const fd_set *);
extern void physical_Login(struct physical *, const char *);
extern int physical_RemoveFromSet(struct physical *, fd_set *, fd_set *,
                                  fd_set *);
extern int physical_SetMode(struct physical *, int);
extern void physical_DeleteQueue(struct physical *);
extern void physical_SetupStack(struct physical *, const char *, int);
extern void physical_StopDeviceTimer(struct physical *);
extern int physical_MaxDeviceSize(void);
extern int physical_AwaitCarrier(struct physical *);
extern void physical_SetDescriptor(struct physical *);
extern void physical_SetAsyncParams(struct physical *, u_int32_t, u_int32_t);
extern int physical_Slot(struct physical *);
@


1.21
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.h,v 1.20 2002/05/16 01:13:39 brian Exp $
@


1.20
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.h,v 1.19 2002/03/31 02:38:49 brian Exp $
d117 1
a117 1
  ((struct physical *)((char *)fp - (int)(&((struct physical *)0)->name)))
@


1.19
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.h,v 1.18 2001/06/19 10:24:56 brian Exp $
d76 1
d173 1
@


1.18
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.h,v 1.17 2000/09/14 22:02:50 brian Exp $
d39 1
d68 1
d171 1
@


1.17
log
@Support PPPoATM, disabled for now as /usr/include/netnatm doesn't exist

Submitted by: Jakob Stoklund Olesen <stoklund@@taxidriver.dk>
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.h,v 1.16 2000/02/27 01:38:27 brian Exp $
d59 1
d147 1
@


1.16
log
@$Id$ -> $OpenBSD$
@
text
@d19 1
a19 1
 *  $OpenBSD: physical.h,v 1.15 2000/02/27 00:21:09 brian Exp $
d38 1
@


1.15
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.14 2000/01/07 03:26:55 brian Exp $
@


1.14
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.13 1999/07/15 02:10:32 brian Exp $
d76 1
a76 1
  struct descriptor desc;
d151 1
a151 1
extern int physical_doUpdateSet(struct descriptor *, fd_set *, fd_set *,
d153 2
a154 2
extern int physical_IsSet(struct descriptor *, const fd_set *);
extern void physical_DescriptorRead(struct descriptor *, struct bundle *,
@


1.13
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.11 1999/06/05 21:36:01 brian Exp $
d31 23
a53 4
#define TTY_DEVICE	1
#define TCP_DEVICE	2
#define UDP_DEVICE	3
#define EXEC_DEVICE	4
d58 1
d60 2
d69 1
a69 1
  void (*device2iov)(struct device *, struct iovec *, int *, int, pid_t);
d95 1
a95 1
  unsigned Utmp : 1;           /* Are we in utmp ? (move to ttydevice ?) */
d107 1
a107 4
    struct {
      unsigned required : 1;   /* Is cd *REQUIRED* on this device */
      int delay;               /* Wait this many seconds after login script */
    } cd;
d120 4
a123 3
#define PHYSICAL_NOFORCE	1
#define PHYSICAL_FORCE_ASYNC	2
#define PHYSICAL_FORCE_SYNC	3
d138 4
a141 2
                                     int, int);
extern int physical2iov(struct physical *, struct iovec *, int *, int, pid_t);
d154 2
d164 2
@


1.12
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d31 4
a34 11
/* Device types */
#define I4B_DEVICE	1
#define TTY_DEVICE	2
#define TCP_DEVICE	3
#define UDP_DEVICE	4
#define EXEC_DEVICE	5

/* Returns from awaitcarrier() */
#define CARRIER_PENDING	1
#define CARRIER_OK	2
#define CARRIER_LOST	3
a39 1
  int (*awaitcarrier)(struct physical *);
a139 1
extern int physical_AwaitCarrier(struct physical *);
@


1.11
log
@Correct the way ppp transfers links on the server side in MP
mode by padding out the ``struct device'' to the maximum
device size.
Bump the ppp version number to indicate the transfer format
change.

This should make MP over tty and udp devices functional again.
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.10 1999/06/01 19:08:52 brian Exp $
d31 11
a41 4
#define TTY_DEVICE	1
#define TCP_DEVICE	2
#define UDP_DEVICE	3
#define EXEC_DEVICE	4
d47 1
d148 1
@


1.10
log
@Increase the length of an individual device name to LINE_LEN.
Adjust the base physical device name correctly after a link
transfer (allowing correct multilink callbacks).
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.9 1999/05/24 16:39:19 brian Exp $
d47 1
a47 1
  void (*device2iov)(struct physical *, struct iovec *, int *, int, pid_t);
d139 1
@


1.9
log
@Correct the ``ignoring sync/async'' warnings so that they show
up with the correct device type.
Reassign the correct tcpdevice or execdevice after transfering
a link in MP server mode.
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.8 1999/05/12 10:03:52 brian Exp $
d69 1
a69 1
    char full[40];             /* Our current device name */
@


1.8
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.7 1999/05/08 11:06:38 brian Exp $
d137 1
a137 1
extern void physical_SetupStack(struct physical *, int);
@


1.7
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.6 1999/04/27 00:21:25 brian Exp $
d33 2
a34 1
#define EXEC_DEVICE	3
d39 1
a39 1
  int (*open)(struct physical *);
d43 5
a47 2
  void (*postclose)(struct physical *);
  void (*restored)(struct physical *);
a58 1
  int mbits;                   /* Current DCD status */
d73 1
a73 1
  unsigned Utmp : 1;           /* Are we in utmp ? */
d76 2
a89 6

  struct termios ios;          /* To be able to reset from raw mode */

  struct pppTimer Timer;       /* CD checks */

  const struct device *handler; /* device specific handlers */
d101 4
d138 1
@


1.6
log
@Change ``set device'' so that it parses its arguments as one
device per argument rather than the old way of concatenating
everything then splitting the result at commas and whitespace.

Old syntax of ``set device /dev/cuaa0, /dev/cuaa1''
may no longer contain the comma, but syntax such as
``set device "!ssh host ppp -direct label"'' is now
possible.
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.5 1999/04/19 16:59:40 brian Exp $
d23 1
d25 22
a55 1
  unsigned isatty : 1;
d66 1
a66 1
    char full[40];
d73 4
a76 2
  /* XXX-ML Most of the below is device specific, and probably do not
      belong in the generic physical struct. It comes from modem.c. */
a77 4
  struct {
    unsigned rts_cts : 1;      /* Is rts/cts enabled? */
    unsigned parity;           /* What parity is enabled? (TTY flags) */
    unsigned speed;            /* Modem speed */
d89 2
d102 17
a118 1
extern int physical_GetFD(struct physical *);
d122 1
a122 13
extern int physical_SetSpeed(struct physical *, int);

/*
 * XXX-ML I'm not certain this is the right way to handle this, but we
 * can solve that later.
 */
extern void physical_SetSync(struct physical *);

/*
 * Can this be set?  (Might not be a relevant attribute for this
 * device, for instance)
 */
extern int physical_SetRtsCts(struct physical *, int);
d126 2
a127 2
extern int physical_UpdateSet(struct descriptor *, fd_set *, fd_set *,
                              fd_set *, int *, int);
a129 1
extern void physical_Logout(struct physical *);
d134 1
@


1.5
log
@Escape stuff in the peers accmap as well as our own when async
encoding, and back out the negotiation strategy that didn't
quite have the right effect with some (bad?) ppp implementations.

Drop unexpected PAP/CHAP packets (if not in NETWORK or ESTABLISH
phase).

Make sure that we enter PHASE_ESTABLISH when we need to.

Detect HDLC frames correctly, not just when the whole header
is obtained by a single read().

Don't convert \r\n to \r\r\n in tty raw mode.

Use the correct macros for `', ``'', () and [].
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.4 1999/02/16 00:18:03 brian Exp $
d58 2
a59 1
    char devlist[LINE_LEN];    /* Comma-separated list of devices */
@


1.4
log
@Wait by default for one second after the login script
is complete before checking carrier.  If it's there,
the device supports carrier.  If it's not it doesn't.

Add the ``set cd'' command for deciding how soon to check
for carrier, and for deciding if carrier is REQUIRED.

The default has changed:  Pre 2.0 versions of ppp waited
for 1 second.  Version 2 didn't wait, but this causes
problems with some (few?) modems that don't assert carrier
immediately on reporting CONNECT.  The one second delay
is back now and can be removed with ``set cd 0''.

Bump the ppp version number in case this needs to be changed
again....
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.3 1999/02/06 03:22:42 brian Exp $
d37 5
@


1.3
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.5 1999/01/10 01:26:30 brian Exp $
d54 4
@


1.2
log
@Only call isatty() when we open our descriptor, and remember
the answer.

If we later get a descriptor exception from select(), we know
that it's a tty (isatty() returns 0 after the exception on a
tty) and remember to call modem_LogicalClose().

The upshot of it all is that descriptor exceptions dont leave
the tty locked any more.
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.1 1998/08/31 00:22:25 brian Exp $
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d19 1
a19 1
 *  $Id: physical.h,v 1.4 1998/08/25 17:48:43 brian Exp $
d33 1
a33 5
  unsigned dev_is_modem : 1;   /* Is the device an actual modem?
                                  Faked for sync devices, though...
                                  (Possibly this should be
                                  dev_is_not_tcp?) XXX-ML */

a70 1
extern int physical_IsATTY(struct physical *);
@

