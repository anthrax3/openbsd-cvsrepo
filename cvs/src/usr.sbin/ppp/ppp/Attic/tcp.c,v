head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.32
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.28
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.26
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.24
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.22
	OPENBSD_5_0:1.17.0.20
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.18
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.16
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.12
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.14
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.10
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.8
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.18
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.16
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.14
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.12
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.10
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.8
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.6
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.18
date	2014.03.17.17.15.52;	author deraadt;	state dead;
branches;
next	1.17;

1.17
date	2006.09.25.05.59.28;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.18.18.52.36;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.31.02.38.49;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.16.14.13.06;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.16.13.20.23;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.19.10.24.59;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.24.01.06.08;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.13.09.57.51;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.27.01.38.29;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.07.03.26.55;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.07.15.02.10.32;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.07.15.02.04.07;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.05.21.36.01;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.05.24.16.39.19;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.12.10.03.54;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.08.11.06.40;	author brian;	state Exp;
branches;
next	;


desc
@@


1.18
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1999 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$OpenBSD: tcp.c,v 1.17 2006/09/25 05:59:28 otto Exp $
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "defs.h"
#include "mbuf.h"
#include "log.h"
#include "timer.h"
#include "lqr.h"
#include "hdlc.h"
#include "throughput.h"
#include "fsm.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "async.h"
#include "descriptor.h"
#include "physical.h"
#include "tcp.h"

static int
tcp_OpenConnection(const char *name, char *host, char *port)
{
  struct sockaddr_in dest;
  int sock;
  struct servent *sp;

  dest.sin_family = AF_INET;
  dest.sin_addr = GetIpAddr(host);
  if (dest.sin_addr.s_addr == INADDR_NONE) {
    log_Printf(LogWARN, "%s: %s: unknown host\n", name, host);
    return -2;
  }
  dest.sin_port = htons(atoi(port));
  if (dest.sin_port == 0) {
    sp = getservbyname(port, "tcp");
    if (sp)
      dest.sin_port = sp->s_port;
    else {
      log_Printf(LogWARN, "%s: %s: unknown service\n", name, port);
      return -2;
    }
  }
  log_Printf(LogPHASE, "%s: Connecting to %s:%s/tcp\n", name, host, port);

  sock = socket(PF_INET, SOCK_STREAM, 0);
  if (sock < 0)
    return -2;

  if (connect(sock, (struct sockaddr *)&dest, sizeof dest) < 0) {
    log_Printf(LogWARN, "%s: connect: %s\n", name, strerror(errno));
    close(sock);
    return -2;
  }

  return sock;
}

static struct device tcpdevice = {
  TCP_DEVICE,
  "tcp",
  0,
  { CD_NOTREQUIRED, 0 },
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
};

struct device *
tcp_iov2device(int type, struct physical *p, struct iovec *iov,
               int *niov, int maxiov, int *auxfd, int *nauxfd)
{
  if (type == TCP_DEVICE) {
    free(iov[(*niov)++].iov_base);
    physical_SetupStack(p, tcpdevice.name, PHYSICAL_FORCE_ASYNC);
    return &tcpdevice;
  }

  return NULL;
}

struct device *
tcp_Create(struct physical *p)
{
  char *cp, *host, *port, *svc;

  if (p->fd < 0) {
    if ((cp = strchr(p->name.full, ':')) != NULL && !strchr(cp + 1, ':')) {
      *cp = '\0';
      host = p->name.full;
      port = cp + 1;
      svc = strchr(port, '/');
      if (svc && strcasecmp(svc, "/tcp")) {
        *cp = ':';
        return 0;
      }
      if (svc) {
        p->fd--;     /* We own the device but maybe can't use it - change fd */
        *svc = '\0';
      }
      if (*host && *port) {
        p->fd = tcp_OpenConnection(p->link.name, host, port);
        *cp = ':';
        if (svc)
          *svc = '/';
        if (p->fd >= 0)
          log_Printf(LogDEBUG, "%s: Opened tcp socket %s\n", p->link.name,
                     p->name.full);
      } else {
        if (svc)
          *svc = '/';
        *cp = ':';
      }
    }
  }

  if (p->fd >= 0) {
    /* See if we're a tcp socket */
    struct stat st;

    if (fstat(p->fd, &st) != -1 && S_ISSOCK(st.st_mode)) {
      int type, sz;

      sz = sizeof type;
      if (getsockopt(p->fd, SOL_SOCKET, SO_TYPE, &type, &sz) == -1) {
        log_Printf(LogPHASE, "%s: Link is a closed socket !\n", p->link.name);
        close(p->fd);
        p->fd = -1;
        return NULL;
      }

      if (sz == sizeof type && type == SOCK_STREAM) {
        struct sockaddr_in sock;
        struct sockaddr *sockp = (struct sockaddr *)&sock;

        if (*p->name.full == '\0') {
          sz = sizeof sock;
          if (getpeername(p->fd, sockp, &sz) != 0 ||
              sz != sizeof(struct sockaddr_in) || sock.sin_family != AF_INET) {
            log_Printf(LogDEBUG, "%s: Link is SOCK_STREAM, but not inet\n",
                       p->link.name);
            return NULL;
          }

          log_Printf(LogPHASE, "%s: Link is a tcp socket\n", p->link.name);

          snprintf(p->name.full, sizeof p->name.full, "%s:%d/tcp",
                   inet_ntoa(sock.sin_addr), ntohs(sock.sin_port));
          p->name.base = p->name.full;
        }
        physical_SetupStack(p, tcpdevice.name, PHYSICAL_FORCE_ASYNC);
        if (p->cfg.cd.necessity != CD_DEFAULT)
          log_Printf(LogWARN, "Carrier settings ignored\n");
        return &tcpdevice;
      }
    }
  }

  return NULL;
}
@


1.17
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by
from Paul Stoeber, more to come. ok jaredy@@
@
text
@d26 1
a26 1
 *	$OpenBSD: tcp.c,v 1.16 2002/07/18 18:52:36 brian Exp $
@


1.16
log
@Remove unused calls to inet_addr()
@
text
@d26 1
a26 1
 *	$OpenBSD: tcp.c,v 1.15 2002/05/16 01:13:39 brian Exp $
d172 1
a172 1
    if (fstat(p->fd, &st) != -1 && (st.st_mode & S_IFSOCK)) {
@


1.15
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d26 1
a26 1
 *	$OpenBSD: tcp.c,v 1.14 2002/03/31 02:38:49 brian Exp $
a68 1
  dest.sin_addr.s_addr = inet_addr(host);
@


1.14
log
@Change ``ifdef HAVE_DES'' to ``ifndef NODES'' for consistency.
Notice if the IP header length changes when doing transparent proxying; FreeBSD
Handle domain\\user entries in ppp.secret
Add some mp_Down() calls to ensure that our multi-link NCP goes away properly
Miscellaneous #ifdef'd out FreeBSD changes (mostly netgraph stuff).
@
text
@d26 1
a26 1
 *	$OpenBSD: tcp.c,v 1.13 2002/01/16 14:13:06 brian Exp $
d105 1
@


1.13
log
@socket()s first argument should be a protocol family rather than an
address family.
@
text
@d26 1
a26 1
 *	$OpenBSD: tcp.c,v 1.12 2002/01/16 13:20:23 brian Exp $
d105 1
@


1.12
log
@socket's first argument is an address family, not a protocol family.
@
text
@d26 1
a26 1
 *	$OpenBSD: tcp.c,v 1.11 2001/06/19 10:24:59 brian Exp $
d87 1
a87 1
  sock = socket(AF_INET, SOCK_STREAM, 0);
@


1.11
log
@Handle hardware-imposed MTU/MRU limitations.

Add an optional ``max'' specifier to ``set m[rt]u'', ie.
``set mtu max 1492'' for PPPoE.

Bump the ppp version number.

Add support for stateful MPPE (microsoft encryption) providing
encryption compatibility with Windows 2000.  Stateful encryption
uses less CPU but is bad on lossy transports.

The ``set mppe'' command has been expanded.  If it's used with any
arguments, ppp will insist on encryption, closing LCP if the other
end refuses.

Sponsored by:	Monzoon Networks AG and FreeBSD Services Limited
@
text
@d26 1
a26 1
 *	$OpenBSD: tcp.c,v 1.10 2001/03/24 01:06:08 brian Exp $
d87 1
a87 1
  sock = socket(PF_INET, SOCK_STREAM, 0);
@


1.10
log
@Remove some unprotected prototype variable names
MAXPATHLEN -> PATH_MAX
Handle ENOENT from opening /dev/tun* properly
Rename _PATH_PPP -> PPP_CONFDIR and allow it to be redefined at compile time
Reduce MIN_LQRPERIOD and MIN_FSMRETRY to 1 second
Be smarter about identifying sockets on stdin
Allow primary DNS IP negotiation when the secondary IP has been rejected
Fix the call to PacketAliasProxyRule() properly.
Add/fix some comments
Fix man page markups; ru@@FreeBSD.org
Use localhost when no hostname is configured
@
text
@d26 1
a26 1
 *	$OpenBSD: tcp.c,v 1.9 2000/06/13 09:57:51 brian Exp $
d103 1
@


1.9
log
@Add ``set ifqueue'' to adjust the number of packets ppp buffers.
Handle an ``open'' correctly from state DATALINK_READY.
Don't disable the autoload timer when bringing down the second last auto
link or bringing up the last auto link.
Allow ``set urgent none'' to disable IPTOS_LOWDELAY prioritisation.
Honour ``set speed sync'' for ``!program'' links and use a udp socketpair
between ppp and ``program''.
HUP ``program'' when a ``!program'' link comes down.
Don't complain about valid padded ppp frames, but complain and drop the
data if the length claims to be more than the payload.
Correct the umask when creating a new /etc/resolv.conf (when dns is enabled),
and don't segfault when trying to rewrite the previous (non-existent) contents.
Be more verbose about ``inappropriate peer'' messages in MP mode.
Allow ``nat target MYADDR'' (to redirect incoming connections to the gateway).
Pass everything through the NAT engine - let it decide if it wants it.
Fix the return code when failing to create a tcp link
@
text
@d26 1
a26 1
 *	$OpenBSD: tcp.c,v 1.8 2000/02/27 01:38:29 brian Exp $
d39 1
d168 1
a168 1
    int type, sz, err;
d170 2
a171 14
    sz = sizeof type;
    if ((err = getsockopt(p->fd, SOL_SOCKET, SO_TYPE, &type, &sz)) == 0 &&
        sz == sizeof type && type == SOCK_STREAM) {
      struct sockaddr_in sock;
      struct sockaddr *sockp = (struct sockaddr *)&sock;

      if (*p->name.full == '\0') {
        sz = sizeof sock;
        if (getpeername(p->fd, sockp, &sz) != 0 ||
            sz != sizeof(struct sockaddr_in) || sock.sin_family != AF_INET) {
          log_Printf(LogDEBUG, "%s: Link is SOCK_STREAM, but not inet\n",
                     p->link.name);
          return NULL;
        }
d173 7
a179 1
        log_Printf(LogPHASE, "%s: Link is a tcp socket\n", p->link.name);
d181 23
a203 3
        snprintf(p->name.full, sizeof p->name.full, "%s:%d/tcp",
                 inet_ntoa(sock.sin_addr), ntohs(sock.sin_port));
        p->name.base = p->name.full;
a204 4
      physical_SetupStack(p, tcpdevice.name, PHYSICAL_FORCE_ASYNC);
      if (p->cfg.cd.necessity != CD_DEFAULT)
        log_Printf(LogWARN, "Carrier settings ignored\n");
      return &tcpdevice;
@


1.8
log
@$Id$ -> $OpenBSD$
@
text
@d26 1
a26 1
 *	$OpenBSD: tcp.c,v 1.7 2000/01/07 03:26:55 brian Exp $
d72 1
a72 1
    return -1;
d81 1
a81 1
      return -1;
d88 1
a88 1
    return sock;
d93 1
a93 1
    return -1;
@


1.7
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d26 1
a26 1
 *	$Id: tcp.c,v 1.6 1999/07/15 02:10:32 brian Exp $
@


1.6
log
@Back out the mis-commit of my development ISDN modifications.
@
text
@d26 1
a26 1
 *	$Id: tcp.c,v 1.4 1999/06/05 21:36:01 brian Exp $
a46 1
#include "sync.h"
d102 3
d119 1
a119 1
               int *niov, int maxiov)
d136 1
a136 1
    if ((cp = strchr(p->name.full, ':')) != NULL) {
d145 2
a146 1
      if (svc)
d148 1
d191 2
@


1.5
log
@Don't declare `end' if we aren't compiling radius support.
@
text
@d47 1
a102 1
  NULL,
@


1.4
log
@Correct the way ppp transfers links on the server side in MP
mode by padding out the ``struct device'' to the maximum
device size.
Bump the ppp version number to indicate the transfer format
change.

This should make MP over tty and udp devices functional again.
@
text
@d26 1
a26 1
 *	$Id: tcp.c,v 1.3 1999/05/24 16:39:19 brian Exp $
a46 1
#include "sync.h"
d102 1
@


1.3
log
@Correct the ``ignoring sync/async'' warnings so that they show
up with the correct device type.
Reassign the correct tcpdevice or execdevice after transfering
a link in MP server mode.
@
text
@d26 1
a26 1
 *	$Id: tcp.c,v 1.2 1999/05/12 10:03:54 brian Exp $
d39 1
d120 1
@


1.2
log
@Allow ``host:port/udp'' devices and support ``host:port/tcp'' as
being the same as the previous (still supported) ``host:port''
syntax for tcp socket devices.

A udp device uses synchronous ppp rather than async, and avoids
the double-retransmit overhead that comes with ppp over tcp (it's
usually a bad idea to transport IP over a reliable transport that
itself is using an unreliable transport).  PPP over UDP provides
througput of ** 1.5Mb per second ** with all compression disabled,
maxing out a PPro/200 when running ppp twice, back-to-back.

This proves that PPPoE is plausable in userland....

This change adds a few more handler functions to struct device and
allows derivations of struct device (which may contain their own
data etc) to pass themselves through the unix domain socket for MP.
** At last **, struct physical has lost all the tty crud !

iov2physical() is now smart enough to restore the correct stack of
layers so that MP servers will work again.

The version number has bumped as our MP link transfer contents have
changed (they now may contain a `struct device').

Don't extract the protocol twice in MP mode (resulting in protocol
rejects for every MP packet).  This was broken with my original
layering changes.

Add ``Physical'' and ``Sync'' log levels for logging the relevent
raw packets and add protocol-tracking LogDEBUG stuff in various
LayerPush & LayerPull functions.

Assign our physical device name for incoming tcp connections by
calling getpeername().

Assign our physical device name for incoming udp connections from
the address retrieved by the first recvfrom().
@
text
@d26 1
a26 1
 *	$Id: tcp.c,v 1.1 1999/05/08 11:06:40 brian Exp $
d118 2
a119 1
  if (type == TCP_DEVICE)
d121 1
d184 1
a184 1
      physical_SetupStack(p, PHYSICAL_FORCE_ASYNC);
@


1.1
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d26 1
a26 1
 *	$Id:$
d61 1
a61 1
OpenConnection(const char *name, char *host, char *port)
d72 1
a72 1
    return (-1);
d77 1
a77 1
    if (sp) {
d79 1
a79 1
    } else {
d81 1
a81 1
      return (-1);
d84 1
a84 1
  log_Printf(LogPHASE, "%s: Connecting to %s:%s\n", name, host, port);
d87 3
a89 3
  if (sock < 0) {
    return (sock);
  }
d93 1
a93 1
    return (-1);
a94 7
  return (sock);
}

static int
tcp_Open(struct physical *p)
{
  char *cp, *host, *port;
d96 1
a96 18
  if ((cp = strchr(p->name.full, ':')) != NULL) {
    *cp = '\0';
    host = p->name.full;
    port = cp + 1;
    if (*host && *port) {
      p->fd = OpenConnection(p->link.name, host, port);
      *cp = ':';		/* Don't destroy name.full */
      if (p->fd >= 0) {
        log_Printf(LogDEBUG, "%s: Opened socket %s\n", p->link.name,
                   p->name.full);
        physical_SetupStack(p, 1);
        return 1;
      }
    } else
      *cp = ':';		/* Don't destroy name.full */
  }

  return 0;
d99 2
a100 2
const struct device tcpdevice = {
  TTY_DEVICE,
d102 3
a104 1
  tcp_Open,
d113 76
@

