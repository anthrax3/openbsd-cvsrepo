head	1.23;
access;
symbols
	OPENBSD_5_5:1.22.0.38
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.34
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.32
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.30
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.28
	OPENBSD_5_0:1.22.0.26
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.24
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.22
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.18
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.20
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.16
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.14
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.12
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.10
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.8
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.6
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.4
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.12
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.10
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.8
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.6
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.20.0.4
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.22;

1.22
date	2005.07.17.19.13.24;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.16.01.13.39;	author brian;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.13.21.33.40;	author brian;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.04.16.09.28;	author brian;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.02.00.54.33;	author brian;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.11.22.13.03;	author brian;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.30.10.46.18;	author brian;	state Exp;
branches;
next	1.14;

1.14
date	2000.03.29.09.32.26;	author brian;	state Exp;
branches;
next	1.13;

1.13
date	2000.03.19.10.33.33;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.27.01.38.26;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.07.03.26.53;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	99.08.02.15.28.47;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	99.07.28.03.02.01;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	99.07.27.23.47.21;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	99.07.26.11.18.11;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.23.16.49.03;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.31.23.57.36;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.05.08.11.06.35;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.22.36;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.10.29.02.21.45;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.20;	author brian;	state Exp;
branches;
next	;


desc
@@


1.23
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1996 - 2001 Brian Somers <brian@@Awfulhak.org>
 *          based on work by Toshiharu OHNO <tony-o@@iij.ad.jp>
 *                           Internet Initiative Japan, Inc (IIJ)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $OpenBSD: filter.c,v 1.22 2005/07/17 19:13:24 brad Exp $
 */

#include <sys/param.h>
#include <netinet/in.h>
#include <netdb.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/socket.h>
#include <sys/un.h>

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>

#include "layer.h"
#include "defs.h"
#include "command.h"
#include "mbuf.h"
#include "log.h"
#include "iplist.h"
#include "timer.h"
#include "throughput.h"
#include "lqr.h"
#include "hdlc.h"
#include "fsm.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "slcompress.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "filter.h"
#include "descriptor.h"
#include "prompt.h"
#include "mp.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "ipv6cp.h"
#include "ncp.h"
#include "bundle.h"

static int filter_Nam2Op(const char *);

static int
ParsePort(const char *service, const char *proto)
{
  struct servent *servent;
  char *cp;
  int port;

  servent = getservbyname(service, proto);
  if (servent != 0)
    return ntohs(servent->s_port);

  port = strtol(service, &cp, 0);
  if (cp == service) {
    log_Printf(LogWARN, "ParsePort: %s is not a port name or number.\n",
	      service);
    return 0;
  }
  return port;
}

/*
 *	ICMP Syntax:	src eq icmp_message_type
 */
static int
ParseIcmp(int argc, char const *const *argv, const struct protoent *pe,
          struct filterent *tgt)
{
  int type;
  char *cp;

  switch (argc) {
  case 0:
    /* permit/deny all ICMP types */
    tgt->f_srcop = tgt->f_dstop = OP_NONE;
    break;

  case 3:
    if (!strcmp(*argv, "src") && !strcmp(argv[1], "eq")) {
      type = strtol(argv[2], &cp, 0);
      if (cp == argv[2]) {
	log_Printf(LogWARN, "ParseIcmp: type is expected.\n");
	return 0;
      }
      tgt->f_srcop = OP_EQ;
      tgt->f_srcport = type;
      tgt->f_dstop = OP_NONE;
    }
    break;

  default:
    log_Printf(LogWARN, "ParseIcmp: bad icmp syntax.\n");
    return 0;
  }
  return 1;
}

/*
 *	UDP Syntax: [src op port] [dst op port]
 */
static int
ParseUdpOrTcp(int argc, char const *const *argv, const struct protoent *pe,
              struct filterent *tgt)
{
  tgt->f_srcop = tgt->f_dstop = OP_NONE;
  tgt->f_estab = tgt->f_syn = tgt->f_finrst = 0;

  if (argc >= 3 && !strcmp(*argv, "src")) {
    tgt->f_srcop = filter_Nam2Op(argv[1]);
    if (tgt->f_srcop == OP_NONE) {
      log_Printf(LogWARN, "ParseUdpOrTcp: bad operator\n");
      return 0;
    }
    if (pe == NULL)
      return 0;
    tgt->f_srcport = ParsePort(argv[2], pe->p_name);
    if (tgt->f_srcport == 0)
      return 0;
    argc -= 3;
    argv += 3;
  }

  if (argc >= 3 && !strcmp(argv[0], "dst")) {
    tgt->f_dstop = filter_Nam2Op(argv[1]);
    if (tgt->f_dstop == OP_NONE) {
      log_Printf(LogWARN, "ParseUdpOrTcp: bad operator\n");
      return 0;
    }
    if (pe == NULL)
      return 0;
    tgt->f_dstport = ParsePort(argv[2], pe->p_name);
    if (tgt->f_dstport == 0)
      return 0;
    argc -= 3;
    argv += 3;
  }

  if (pe && pe->p_proto == IPPROTO_TCP) {
    for (; argc > 0; argc--, argv++)
      if (!strcmp(*argv, "estab"))
        tgt->f_estab = 1;
      else if (!strcmp(*argv, "syn"))
        tgt->f_syn = 1;
      else if (!strcmp(*argv, "finrst"))
        tgt->f_finrst = 1;
      else
        break;
  }

  if (argc > 0) {
    log_Printf(LogWARN, "ParseUdpOrTcp: bad src/dst port syntax: %s\n", *argv);
    return 0;
  }

  return 1;
}

static int
ParseGeneric(int argc, char const * const *argv, const struct protoent *pe,
             struct filterent *tgt)
{
  /*
   * Filter currently is a catch-all. Requests are either permitted or
   * dropped.
   */
  if (argc != 0) {
    log_Printf(LogWARN, "ParseGeneric: Too many parameters\n");
    return 0;
  } else
    tgt->f_srcop = tgt->f_dstop = OP_NONE;

  return 1;
}

static unsigned
addrtype(const char *addr)
{
  if (!strncasecmp(addr, "MYADDR", 6) && (addr[6] == '\0' || addr[6] == '/'))
    return T_MYADDR;
  if (!strncasecmp(addr, "MYADDR6", 7) && (addr[7] == '\0' || addr[7] == '/'))
    return T_MYADDR6;
  if (!strncasecmp(addr, "HISADDR", 7) && (addr[7] == '\0' || addr[7] == '/'))
    return T_HISADDR;
  if (!strncasecmp(addr, "HISADDR6", 8) && (addr[8] == '\0' || addr[8] == '/'))
    return T_HISADDR6;
  if (!strncasecmp(addr, "DNS0", 4) && (addr[4] == '\0' || addr[4] == '/'))
    return T_DNS0;
  if (!strncasecmp(addr, "DNS1", 4) && (addr[4] == '\0' || addr[4] == '/'))
    return T_DNS1;

  return T_ADDR;
}

static const char *
addrstr(struct ncprange *addr, unsigned type)
{
  switch (type) {
    case T_MYADDR:
      return "MYADDR";
    case T_HISADDR:
      return "HISADDR";
    case T_DNS0:
      return "DNS0";
    case T_DNS1:
      return "DNS1";
  }
  return ncprange_ntoa(addr);
}

static int
filter_Parse(struct ncp *ncp, int argc, char const *const *argv,
             struct filterent *ofp)
{
  struct filterent fe;
  struct protoent *pe;
  char *wp;
  int action, family, ruleno, val, width;

  ruleno = strtol(*argv, &wp, 0);
  if (*argv == wp || ruleno >= MAXFILTERS) {
    log_Printf(LogWARN, "Parse: invalid filter number.\n");
    return 0;
  }
  if (ruleno < 0) {
    for (ruleno = 0; ruleno < MAXFILTERS; ruleno++) {
      ofp->f_action = A_NONE;
      ofp++;
    }
    log_Printf(LogWARN, "Parse: filter cleared.\n");
    return 1;
  }
  ofp += ruleno;

  if (--argc == 0) {
    log_Printf(LogWARN, "Parse: missing action.\n");
    return 0;
  }
  argv++;

  memset(&fe, '\0', sizeof fe);

  val = strtol(*argv, &wp, 0);
  if (!*wp && val >= 0 && val < MAXFILTERS) {
    if (val <= ruleno) {
      log_Printf(LogWARN, "Parse: Can only jump forward from rule %d\n",
                 ruleno);
      return 0;
    }
    action = val;
  } else if (!strcmp(*argv, "permit")) {
    action = A_PERMIT;
  } else if (!strcmp(*argv, "deny")) {
    action = A_DENY;
  } else if (!strcmp(*argv, "clear")) {
    ofp->f_action = A_NONE;
    return 1;
  } else {
    log_Printf(LogWARN, "Parse: %s: bad action\n", *argv);
    return 0;
  }
  fe.f_action = action;

  argc--;
  argv++;

  if (argc && argv[0][0] == '!' && !argv[0][1]) {
    fe.f_invert = 1;
    argc--;
    argv++;
  }

  ncprange_init(&fe.f_src);
  ncprange_init(&fe.f_dst);

  if (argc == 0)
    pe = NULL;
  else if ((pe = getprotobyname(*argv)) == NULL && strcmp(*argv, "all") != 0) {
    if (argc < 2) {
      log_Printf(LogWARN, "Parse: Protocol or address pair expected\n");
      return 0;
    } else if (strcasecmp(*argv, "any") == 0 ||
               ncprange_aton(&fe.f_src, ncp, *argv)) {
      family = ncprange_family(&fe.f_src);
      if (!ncprange_getwidth(&fe.f_src, &width))
        width = 0;
      if (width == 0)
        ncprange_init(&fe.f_src);
      fe.f_srctype = addrtype(*argv);
      argc--;
      argv++;

      if (strcasecmp(*argv, "any") == 0 ||
          ncprange_aton(&fe.f_dst, ncp, *argv)) {
        if (ncprange_family(&fe.f_dst) != AF_UNSPEC &&
            ncprange_family(&fe.f_src) != AF_UNSPEC &&
            family != ncprange_family(&fe.f_dst)) {
          log_Printf(LogWARN, "Parse: src and dst address families differ\n");
          return 0;
        }
        if (!ncprange_getwidth(&fe.f_dst, &width))
          width = 0;
        if (width == 0)
          ncprange_init(&fe.f_dst);
        fe.f_dsttype = addrtype(*argv);
        argc--;
        argv++;
      } else {
        log_Printf(LogWARN, "Parse: Protocol or address pair expected\n");
        return 0;
      }

      if (argc) {
        if ((pe = getprotobyname(*argv)) == NULL && strcmp(*argv, "all") != 0) {
          log_Printf(LogWARN, "Parse: %s: Protocol expected\n", *argv);
          return 0;
        } else {
          argc--;
          argv++;
        }
      }
    } else {
      log_Printf(LogWARN, "Parse: Protocol or address pair expected\n");
      return 0;
    }
  } else {
    argc--;
    argv++;
  }

  if (argc >= 2 && strcmp(*argv, "timeout") == 0) {
    fe.timeout = strtoul(argv[1], NULL, 10);
    argc -= 2;
    argv += 2;
  }

  val = 1;
  fe.f_proto = (pe == NULL) ? 0 : pe->p_proto;

  switch (fe.f_proto) {
  case IPPROTO_TCP:
  case IPPROTO_UDP:
  case IPPROTO_IPIP:
#ifndef NOINET6
  case IPPROTO_IPV6:
#endif
    val = ParseUdpOrTcp(argc, argv, pe, &fe);
    break;
  case IPPROTO_ICMP:
#ifndef NOINET6
  case IPPROTO_ICMPV6:
#endif
    val = ParseIcmp(argc, argv, pe, &fe);
    break;
  default:
    val = ParseGeneric(argc, argv, pe, &fe);
    break;
  }

  log_Printf(LogDEBUG, "Parse: Src: %s\n", ncprange_ntoa(&fe.f_src));
  log_Printf(LogDEBUG, "Parse: Dst: %s\n", ncprange_ntoa(&fe.f_dst));
  log_Printf(LogDEBUG, "Parse: Proto: %d\n", fe.f_proto);

  log_Printf(LogDEBUG, "Parse: src:  %s (%d)\n",
            filter_Op2Nam(fe.f_srcop), fe.f_srcport);
  log_Printf(LogDEBUG, "Parse: dst:  %s (%d)\n",
            filter_Op2Nam(fe.f_dstop), fe.f_dstport);
  log_Printf(LogDEBUG, "Parse: estab: %u\n", fe.f_estab);
  log_Printf(LogDEBUG, "Parse: syn: %u\n", fe.f_syn);
  log_Printf(LogDEBUG, "Parse: finrst: %u\n", fe.f_finrst);

  if (val)
    *ofp = fe;

  return val;
}

int
filter_Set(struct cmdargs const *arg)
{
  struct filter *filter;

  if (arg->argc < arg->argn+2)
    return -1;

  if (!strcmp(arg->argv[arg->argn], "in"))
    filter = &arg->bundle->filter.in;
  else if (!strcmp(arg->argv[arg->argn], "out"))
    filter = &arg->bundle->filter.out;
  else if (!strcmp(arg->argv[arg->argn], "dial"))
    filter = &arg->bundle->filter.dial;
  else if (!strcmp(arg->argv[arg->argn], "alive"))
    filter = &arg->bundle->filter.alive;
  else {
    log_Printf(LogWARN, "filter_Set: %s: Invalid filter name.\n",
              arg->argv[arg->argn]);
    return -1;
  }

  filter_Parse(&arg->bundle->ncp, arg->argc - arg->argn - 1,
        arg->argv + arg->argn + 1, filter->rule);
  return 0;
}

const char *
filter_Action2Nam(int act)
{
  static const char * const actname[] = { "  none ", "permit ", "  deny " };
  static char	buf[8];

  if (act >= 0 && act < MAXFILTERS) {
    snprintf(buf, sizeof buf, "%6d ", act);
    return buf;
  } else if (act >= A_NONE && act < A_NONE + sizeof(actname)/sizeof(char *))
    return actname[act - A_NONE];
  else
    return "?????? ";
}

static void
doShowFilter(struct filterent *fp, struct prompt *prompt)
{
  struct protoent *pe;
  int n;

  for (n = 0; n < MAXFILTERS; n++, fp++) {
    if (fp->f_action != A_NONE) {
      prompt_Printf(prompt, "  %2d %s", n, filter_Action2Nam(fp->f_action));
      prompt_Printf(prompt, "%c ", fp->f_invert ? '!' : ' ');

      if (ncprange_isset(&fp->f_src))
        prompt_Printf(prompt, "%s ", addrstr(&fp->f_src, fp->f_srctype));
      else
        prompt_Printf(prompt, "any ");

      if (ncprange_isset(&fp->f_dst))
        prompt_Printf(prompt, "%s ", addrstr(&fp->f_dst, fp->f_dsttype));
      else
        prompt_Printf(prompt, "any ");

      if (fp->f_proto) {
        if ((pe = getprotobynumber(fp->f_proto)) == NULL)
	  prompt_Printf(prompt, "P:%d", fp->f_proto);
        else
	  prompt_Printf(prompt, "%s", pe->p_name);

	if (fp->f_srcop)
	  prompt_Printf(prompt, " src %s %d", filter_Op2Nam(fp->f_srcop),
		  fp->f_srcport);
	if (fp->f_dstop)
	  prompt_Printf(prompt, " dst %s %d", filter_Op2Nam(fp->f_dstop),
		  fp->f_dstport);
	if (fp->f_estab)
	  prompt_Printf(prompt, " estab");
	if (fp->f_syn)
	  prompt_Printf(prompt, " syn");
	if (fp->f_finrst)
	  prompt_Printf(prompt, " finrst");
      } else
	prompt_Printf(prompt, "all");
      if (fp->timeout != 0)
	  prompt_Printf(prompt, " timeout %u", fp->timeout);
      prompt_Printf(prompt, "\n");
    }
  }
}

int
filter_Show(struct cmdargs const *arg)
{
  if (arg->argc > arg->argn+1)
    return -1;

  if (arg->argc == arg->argn+1) {
    struct filter *filter;

    if (!strcmp(arg->argv[arg->argn], "in"))
      filter = &arg->bundle->filter.in;
    else if (!strcmp(arg->argv[arg->argn], "out"))
      filter = &arg->bundle->filter.out;
    else if (!strcmp(arg->argv[arg->argn], "dial"))
      filter = &arg->bundle->filter.dial;
    else if (!strcmp(arg->argv[arg->argn], "alive"))
      filter = &arg->bundle->filter.alive;
    else
      return -1;
    doShowFilter(filter->rule, arg->prompt);
  } else {
    struct filter *filter[4];
    int f;

    filter[0] = &arg->bundle->filter.in;
    filter[1] = &arg->bundle->filter.out;
    filter[2] = &arg->bundle->filter.dial;
    filter[3] = &arg->bundle->filter.alive;
    for (f = 0; f < 4; f++) {
      if (f)
        prompt_Printf(arg->prompt, "\n");
      prompt_Printf(arg->prompt, "%s:\n", filter[f]->name);
      doShowFilter(filter[f]->rule, arg->prompt);
    }
  }

  return 0;
}

static const char * const opname[] = {"none", "eq", "gt", "lt"};

const char *
filter_Op2Nam(int op)
{
  if (op >= sizeof opname / sizeof opname[0])
    return "unknown";
  return opname[op];

}

static int
filter_Nam2Op(const char *cp)
{
  int op;

  for (op = sizeof opname / sizeof opname[0] - 1; op; op--)
    if (!strcasecmp(cp, opname[op]))
      break;

  return op;
}

void
filter_AdjustAddr(struct filter *filter, struct ncpaddr *local,
                  struct ncpaddr *remote, struct in_addr *dns)
{
  struct filterent *fp;
  int n;

  for (fp = filter->rule, n = 0; n < MAXFILTERS; fp++, n++)
    if (fp->f_action != A_NONE) {
      if (local) {
        if (fp->f_srctype == T_MYADDR && ncpaddr_family(local) == AF_INET)
          ncprange_sethost(&fp->f_src, local);
        if (fp->f_dsttype == T_MYADDR && ncpaddr_family(local) == AF_INET)
          ncprange_sethost(&fp->f_dst, local);
#ifndef NOINET6
        if (fp->f_srctype == T_MYADDR6 && ncpaddr_family(local) == AF_INET6)
          ncprange_sethost(&fp->f_src, local);
        if (fp->f_dsttype == T_MYADDR6 && ncpaddr_family(local) == AF_INET6)
          ncprange_sethost(&fp->f_dst, local);
#endif
      }
      if (remote) {
        if (fp->f_srctype == T_HISADDR && ncpaddr_family(remote) == AF_INET)
          ncprange_sethost(&fp->f_src, remote);
        if (fp->f_dsttype == T_HISADDR && ncpaddr_family(remote) == AF_INET)
          ncprange_sethost(&fp->f_dst, remote);
#ifndef NOINET6
        if (fp->f_srctype == T_HISADDR6 && ncpaddr_family(remote) == AF_INET6)
          ncprange_sethost(&fp->f_src, remote);
        if (fp->f_dsttype == T_HISADDR6 && ncpaddr_family(remote) == AF_INET6)
          ncprange_sethost(&fp->f_dst, remote);
#endif
      }
      if (dns) {
        if (fp->f_srctype == T_DNS0)
          ncprange_setip4host(&fp->f_src, dns[0]);
        if (fp->f_dsttype == T_DNS0)
          ncprange_setip4host(&fp->f_dst, dns[0]);
        if (fp->f_srctype == T_DNS1)
          ncprange_setip4host(&fp->f_src, dns[1]);
        if (fp->f_dsttype == T_DNS1)
          ncprange_setip4host(&fp->f_dst, dns[1]);
      }
    }
}
@


1.22
log
@Include the correct file (stdarg.h) and use va_list rather than _BSD_VA_LIST_

From brian FreeBSD
@
text
@d28 1
a28 1
 * $OpenBSD: filter.c,v 1.21 2002/05/16 01:13:39 brian Exp $
@


1.21
log
@o Bump the version number
o Tidy up includes
o Fix macros in auth.h
o Insist on context for ``set mru'' in MP mode
o Usage -> usage
o Don't intialise after processing config requests
o Show FSM values for ConfigAcks
o Make ident output prettier
o Fix some Id keywords
o Handle RADIUS pool address 255.255.255.254
o Support RADIUS Session-Timeout attributes
o Support RADIUS Reply-Message attributes
o Support RADIUS CHAP-Error attributes
o Store RADIUS Filter-Id attributes
o Provide a NAS-Port-Type attribute to RADIUS servers
o Provide a better NAS-Port attribute to RADIUS servers
o Support MS-CHAP with RADIUS
o Improve FSM decode functions
o Support an OCTETSIN variable
o Support an OCTETSOUT variable
o Support an PACKETSIN variable
o Support an PACKETSOUT variable
o Support an IPOCTETSIN variable
o Support an IPOCTETSOUT variable
o Support an IPPACKETSIN variable
o Support an IPPACKETSOUT variable
o Support an IPV6OCTETSIN variable
o Support an IPV6OCTETSOUT variable
o Support an IPV6PACKETSIN variable
o Support an IPV6PACKETSOUT variable
o Support a SOCKNAME variable
@
text
@d28 1
a28 1
 * $OpenBSD: filter.c,v 1.20 2001/08/19 23:22:17 brian Exp $
d39 1
@


1.20
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d28 1
a28 1
 * $OpenBSD: filter.c,v 1.19 2001/06/13 21:33:40 brian Exp $
a32 1
#include <arpa/inet.h>
d41 1
a41 1
#include <strings.h>
a59 1
#include "ip.h"
@


1.19
log
@Convert IIJ copyrights to BSD copyrights; ok tohno@@sirius.ocn.ne.jp
@
text
@d28 1
a28 1
 * $OpenBSD$
d37 1
d60 2
d70 2
a73 1
static int filter_Nam2Proto(int, char const *const *);
a75 81
static const u_int32_t netmasks[33] = {
  0x00000000,
  0x80000000, 0xC0000000, 0xE0000000, 0xF0000000,
  0xF8000000, 0xFC000000, 0xFE000000, 0xFF000000,
  0xFF800000, 0xFFC00000, 0xFFE00000, 0xFFF00000,
  0xFFF80000, 0xFFFC0000, 0xFFFE0000, 0xFFFF0000,
  0xFFFF8000, 0xFFFFC000, 0xFFFFE000, 0xFFFFF000,
  0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00, 0xFFFFFF00,
  0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0, 0xFFFFFFF0,
  0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE, 0xFFFFFFFF,
};

struct in_addr
bits2mask(int bits)
{
  struct in_addr result;

  result.s_addr = htonl(netmasks[bits]);
  return result;
}

int
ParseAddr(struct ipcp *ipcp, const char *data,
	  struct in_addr *paddr, struct in_addr *pmask, int *pwidth)
{
  int bits, len;
  char *wp;
  const char *cp;

  if (pmask)
    pmask->s_addr = INADDR_BROADCAST;	/* Assume 255.255.255.255 as default */

  cp = pmask || pwidth ? strchr(data, '/') : NULL;
  len = cp ? cp - data : strlen(data);

  if (ipcp && strncasecmp(data, "HISADDR", len) == 0)
    *paddr = ipcp->peer_ip;
  else if (ipcp && strncasecmp(data, "MYADDR", len) == 0)
    *paddr = ipcp->my_ip;
  else if (ipcp && strncasecmp(data, "DNS0", len) == 0)
    *paddr = ipcp->ns.dns[0];
  else if (ipcp && strncasecmp(data, "DNS1", len) == 0)
    *paddr = ipcp->ns.dns[1];
  else {
    char *s;

    s = (char *)alloca(len + 1);
    strncpy(s, data, len);
    s[len] = '\0';
    *paddr = GetIpAddr(s);
    if (paddr->s_addr == INADDR_NONE) {
      log_Printf(LogWARN, "ParseAddr: %s: Bad address\n", s);
      return 0;
    }
  }
  if (cp && *++cp) {
    bits = strtol(cp, &wp, 0);
    if (cp == wp || bits < 0 || bits > 32) {
      log_Printf(LogWARN, "ParseAddr: bad mask width.\n");
      return 0;
    }
  } else if (paddr->s_addr == INADDR_ANY)
    /* An IP of 0.0.0.0 without a width is anything */
    bits = 0;
  else
    /* If a valid IP is given without a width, assume 32 bits */
    bits = 32;

  if (pwidth)
    *pwidth = bits;

  if (pmask) {
    if (paddr->s_addr == INADDR_ANY)
      pmask->s_addr = INADDR_ANY;
    else
      *pmask = bits2mask(bits);
  }

  return 1;
}

d77 1
a77 1
ParsePort(const char *service, int proto)
d79 1
a79 1
  const char *protocol_name;
a80 1
  struct servent *servent;
d83 1
a83 15
  switch (proto) {
  case P_IPIP:
    protocol_name = "ipip";
    break;
  case P_UDP:
    protocol_name = "udp";
    break;
  case P_TCP:
    protocol_name = "tcp";
    break;
  default:
    protocol_name = 0;
  }

  servent = getservbyname(service, protocol_name);
d100 2
a101 1
ParseIcmp(int argc, char const *const *argv, struct filterent *tgt)
d109 1
a109 1
    tgt->f_srcop = OP_NONE;
d121 1
d136 1
a136 1
ParseUdpOrTcp(int argc, char const *const *argv, int proto,
d145 1
a145 1
      log_Printf(LogWARN, "ParseUdpOrTcp: bad operation\n");
d148 3
a150 1
    tgt->f_srcport = ParsePort(argv[2], proto);
d160 1
a160 1
      log_Printf(LogWARN, "ParseUdpOrTcp: bad operation\n");
d163 3
a165 1
    tgt->f_dstport = ParsePort(argv[2], proto);
d172 1
a172 1
  if (proto == P_TCP) {
d193 2
a194 36
ParseIgmp(int argc, char const * const *argv, struct filterent *tgt)
{
  /*
   * Filter currently is a catch-all. Requests are either permitted or
   * dropped.
   */
  if (argc != 0) {
    log_Printf(LogWARN, "ParseIgmp: Too many parameters\n");
    return 0;
  } else
    tgt->f_srcop = OP_NONE;

  return 1;
}

#ifdef P_GRE
static int
ParseGRE(int argc, char const * const *argv, struct filterent *tgt)
{
  /*
   * Filter currently is a catch-all. Requests are either permitted or
   * dropped.
   */
  if (argc != 0) {
    log_Printf(LogWARN, "ParseGRE: Too many parameters\n");
    return 0;
  } else
    tgt->f_srcop = OP_NONE;

  return 1;
}
#endif

#ifdef P_OSPF
static int
ParseOspf(int argc, char const * const *argv, struct filterent *tgt)
d201 1
a201 1
    log_Printf(LogWARN, "ParseOspf: Too many parameters\n");
d204 1
a204 1
    tgt->f_srcop = OP_NONE;
a207 1
#endif
d214 2
d218 2
d229 1
a229 1
addrstr(struct in_addr addr, unsigned type)
d241 1
a241 14
  return inet_ntoa(addr);
}

static const char *
maskstr(int bits)
{
  static char str[4];

  if (bits == 32)
    *str = '\0';
  else
    snprintf(str, sizeof str, "/%d", bits);

  return str;
d245 2
a246 2
Parse(struct ipcp *ipcp, int argc, char const *const *argv,
      struct filterent *ofp)
d248 2
a249 2
  int action, proto;
  int val, ruleno;
d251 1
a251 1
  struct filterent filterdata;
d274 1
a274 2
  proto = P_NONE;
  memset(&filterdata, '\0', sizeof filterdata);
d292 1
a292 1
    log_Printf(LogWARN, "Parse: bad action: %s\n", *argv);
d295 1
a295 1
  filterdata.f_action = action;
d301 1
a301 1
    filterdata.f_invert = 1;
d306 17
a322 7
  proto = filter_Nam2Proto(argc, argv);
  if (proto == P_NONE) {
    if (!argc)
      log_Printf(LogWARN, "Parse: address/mask is expected.\n");
    else if (ParseAddr(ipcp, *argv, &filterdata.f_src.ipaddr,
                       &filterdata.f_src.mask, &filterdata.f_src.width)) {
      filterdata.f_srctype = addrtype(*argv);
d325 16
a340 21
      proto = filter_Nam2Proto(argc, argv);
      if (!argc)
        log_Printf(LogWARN, "Parse: address/mask is expected.\n");
      else if (proto == P_NONE) {
	if (ParseAddr(ipcp, *argv, &filterdata.f_dst.ipaddr,
		      &filterdata.f_dst.mask, &filterdata.f_dst.width)) {
          filterdata.f_dsttype = addrtype(*argv);
	  argc--;
	  argv++;
	} else
          filterdata.f_dsttype = T_ADDR;
        if (argc) {
	  proto = filter_Nam2Proto(argc, argv);
	  if (proto == P_NONE) {
            log_Printf(LogWARN, "Parse: %s: Invalid protocol\n", *argv);
            return 0;
          } else {
	    argc--;
	    argv++;
	  }
	}
d342 12
a353 2
	argc--;
	argv++;
d356 1
a356 1
      log_Printf(LogWARN, "Parse: Address/protocol expected.\n");
d364 2
a365 2
  if (argc >= 2 && strcmp(argv[argc - 2], "timeout") == 0) {
    filterdata.timeout = strtoul(argv[argc - 1], NULL, 10);
d367 1
d371 1
a371 1
  filterdata.f_proto = proto;
d373 8
a380 3
  switch (proto) {
  case P_TCP:
    val = ParseUdpOrTcp(argc, argv, P_TCP, &filterdata);
d382 5
a386 2
  case P_UDP:
    val = ParseUdpOrTcp(argc, argv, P_UDP, &filterdata);
d388 2
a389 8
  case P_IPIP:
    val = ParseUdpOrTcp(argc, argv, P_IPIP, &filterdata);
    break;
  case P_ICMP:
    val = ParseIcmp(argc, argv, &filterdata);
    break;
  case P_IGMP:
    val = ParseIgmp(argc, argv, &filterdata);
a390 10
#ifdef P_OSPF
  case P_OSPF:
    val = ParseOspf(argc, argv, &filterdata);
    break;
#endif
#ifdef P_GRE
  case P_GRE:
    val = ParseGRE(argc, argv, &filterdata);
    break;
#endif
d393 3
a395 7
  log_Printf(LogDEBUG, "Parse: Src: %s\n", inet_ntoa(filterdata.f_src.ipaddr));
  log_Printf(LogDEBUG, "Parse: Src mask: %s\n",
             inet_ntoa(filterdata.f_src.mask));
  log_Printf(LogDEBUG, "Parse: Dst: %s\n", inet_ntoa(filterdata.f_dst.ipaddr));
  log_Printf(LogDEBUG, "Parse: Dst mask: %s\n",
             inet_ntoa(filterdata.f_dst.mask));
  log_Printf(LogDEBUG, "Parse: Proto = %d\n", proto);
d398 1
a398 1
            filter_Op2Nam(filterdata.f_srcop), filterdata.f_srcport);
d400 4
a403 4
            filter_Op2Nam(filterdata.f_dstop), filterdata.f_dstport);
  log_Printf(LogDEBUG, "Parse: estab: %u\n", filterdata.f_estab);
  log_Printf(LogDEBUG, "Parse: syn: %u\n", filterdata.f_syn);
  log_Printf(LogDEBUG, "Parse: finrst: %u\n", filterdata.f_finrst);
d406 1
a406 1
    *ofp = filterdata;
d433 1
a433 1
  Parse(&arg->bundle->ncp.ipcp, arg->argc - arg->argn - 1,
d456 1
d463 11
a473 4
      prompt_Printf(prompt, "%s%s ", addrstr(fp->f_src.ipaddr, fp->f_srctype),
                    maskstr(fp->f_src.width));
      prompt_Printf(prompt, "%s%s ", addrstr(fp->f_dst.ipaddr, fp->f_dsttype),
                    maskstr(fp->f_dst.width));
d475 4
a478 1
	prompt_Printf(prompt, "%s", filter_Proto2Nam(fp->f_proto));
d492 2
a493 1
      }
a539 27
static const char * const protoname[] = {
  "none", "tcp", "udp", "icmp", "ospf", "igmp", "gre", "ipip"
};

const char *
filter_Proto2Nam(int proto)
{
  if (proto >= sizeof protoname / sizeof protoname[0])
    return "unknown";
  return protoname[proto];
}

static int
filter_Nam2Proto(int argc, char const *const *argv)
{
  int proto;

  if (argc == 0)
    proto = 0;
  else
    for (proto = sizeof protoname / sizeof protoname[0] - 1; proto; proto--)
      if (!strcasecmp(*argv, protoname[proto]))
        break;

  return proto;
}

d564 2
a565 2
filter_AdjustAddr(struct filter *filter, struct in_addr *my_ip,
                  struct in_addr *peer_ip, struct in_addr dns[2])
d572 11
a582 5
      if (my_ip) {
        if (fp->f_srctype == T_MYADDR)
          fp->f_src.ipaddr = *my_ip;
        if (fp->f_dsttype == T_MYADDR)
          fp->f_dst.ipaddr = *my_ip;
d584 11
a594 5
      if (peer_ip) {
        if (fp->f_srctype == T_HISADDR)
          fp->f_src.ipaddr = *peer_ip;
        if (fp->f_dsttype == T_HISADDR)
          fp->f_dst.ipaddr = *peer_ip;
d598 1
a598 1
          fp->f_src.ipaddr = dns[0];
d600 1
a600 1
          fp->f_dst.ipaddr = dns[0];
d602 1
a602 1
          fp->f_src.ipaddr = dns[1];
d604 1
a604 1
          fp->f_dst.ipaddr = dns[1];
@


1.18
log
@Show the correct dial timeout when a random pause is configured
Understand ipencap traffic properly
Optimise out SIOCIFADDR ioctls that aren't necessary
Handle peers that don't send an initial IFADDR option during IPCP negotiations
Fix markup for the /etc/ttys example
Always use 4 arguments in examples of ``set ifaddr''
@
text
@d1 5
a5 2
/*
 *		PPP Filter command Interface
d7 8
a14 1
 *	    Written by Toshiharu OHNO (tony-o@@iij.ad.jp)
d16 11
a26 1
 *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.
d28 1
a28 15
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the Internet Initiative Japan.  The name of the
 * IIJ may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: filter.c,v 1.17 2000/11/02 00:54:33 brian Exp $
 *
 *	TODO: Should send ICMP error message when we discard packets.
@


1.17
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d20 1
a20 1
 * $OpenBSD: filter.c,v 1.16 2000/07/11 22:13:03 brian Exp $
d156 3
d489 3
d650 1
a650 1
  "none", "tcp", "udp", "icmp", "ospf", "igmp", "gre"
@


1.16
log
@Allow a ``timeout secs'' filter option to let specific packet types
effect the idle timer in different ways.

Submitted by: Stefan Esser <se@@freebsd.org>

With adjustments by me to document the option in the man page and to
give the same semantics for outgoing traffic as incoming.

I made the style more consistent in ip.c - this should really have
been done as a separate commit.
@
text
@d20 1
a20 1
 * $OpenBSD: filter.c,v 1.15 2000/03/30 10:46:18 brian Exp $
d505 2
a506 1
  log_Printf(LogDEBUG, "Parse: Src mask: %s\n", inet_ntoa(filterdata.f_src.mask));
d508 2
a509 1
  log_Printf(LogDEBUG, "Parse: Dst mask: %s\n", inet_ntoa(filterdata.f_dst.mask));
@


1.15
log
@Correct address parsing

Pointed out by: Maxim Sobolev <sobomax@@altavista.net>
@
text
@d20 1
a20 1
 * $OpenBSD: filter.c,v 1.14 2000/03/29 09:32:26 brian Exp $
d471 5
d595 2
@


1.14
log
@Allow the use of hostnames instead of (and as well as) IP
numbers in all commands.
If people use hostnames and have dodgy resolvers or try to resolve
the hostname before the link is up, they get what they deserve....

Requested by: ru
@
text
@d20 1
a20 1
 * $OpenBSD: filter.c,v 1.13 2000/03/19 10:33:33 brian Exp $
d116 1
a116 1
    if (paddr->s_addr == INADDR_ANY || paddr->s_addr == INADDR_NONE) {
@


1.13
log
@Allow environment variables on command/config lines; markk@@knigma.org
Add the ``resolv'' command so that when ``enable dns''
is used, it's possible to restore the file.
@
text
@d20 1
a20 1
 * $OpenBSD: filter.c,v 1.12 2000/02/27 01:38:26 brian Exp $
a108 2
  else if (len > 15)
    log_Printf(LogWARN, "ParseAddr: %s: Bad address\n", data);
d110 3
a112 1
    char s[16];
d115 2
a116 1
    if (inet_aton(s, paddr) == 0) {
@


1.12
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: filter.c,v 1.11 2000/01/07 03:26:53 brian Exp $
d105 4
d327 4
d343 4
d685 1
a685 1
                  struct in_addr *peer_ip)
d703 10
@


1.11
log
@Upgrade from 2.23 -> 2.26
I'll follow up with a list of changes (too big for a commit message IMHO)
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.10 1999/08/02 15:28:47 brian Exp $
@


1.10
log
@Filter ospf and igmp separately.

Kind-of submitted by: phk@@FreeBSD.org
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.9 1999/07/28 03:02:01 brian Exp $
d22 1
a22 1
 *	TODO: Shoud send ICMP error message when we discard packets.
d280 18
d479 5
d536 1
a536 1
  static const char *actname[] = { "  none ", "permit ", "  deny " };
d621 2
a622 2
static const char *protoname[] = {
  "none", "tcp", "udp", "icmp", "ospf", "igmp"
d648 1
a648 1
static const char *opname[] = {"none", "eq", "gt", "unknown", "lt"};
@


1.9
log
@Fix a load of typos
Use sizeof, not a hardcode value.

Some of it submitted by:  Peter Jeremy <jeremyp@@gsmx07.alcatel.com.au>
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.8 1999/07/27 23:47:21 brian Exp $
d264 2
a265 1
static int ParseIgmp(int argc, char const * const *argv, struct filterent *tgt)
d267 4
a270 2
  /* Filter currently is a catch-all. Requests are either permitted or
     dropped. */
d280 18
d456 5
d598 3
a600 1
static const char *protoname[] = { "none", "tcp", "udp", "icmp", "igmp" };
@


1.8
log
@o Overhaul filtering, adding facilities to jump over rules and to
  negate the sense of rules.
o Remove the redundant (and undocumented) ``host'' and ``port''
  words (README.changes updated).
o Don't permit (and ignore) garbage instead of the protocol.

Mostly submitted by:  Peter Jeremy <jeremyp@@gsmx07.alcatel.com.au>
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.7 1999/07/26 11:18:11 brian Exp $
d491 1
a491 1
    snprintf(buf, 8, "%6d ", act);
@


1.7
log
@Fix an off-by-one error and correct the man page WRT clearing
filters.

Submitted by:	Peter Jeremy <peter.jeremy@@alcatel.com.au>
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.6 1999/06/23 16:49:03 brian Exp $
d113 1
a113 1
      return (0);
d120 1
a120 1
      return (0);
d139 1
a139 1
  return (1);
d163 1
a163 1
    return (ntohs(servent->s_port));
d169 1
a169 1
    return (0);
d171 1
a171 1
  return (port);
d186 1
a186 1
    tgt->opt.srcop = OP_NONE;
d194 1
a194 1
	return (0);
d196 2
a197 2
      tgt->opt.srcop = OP_EQ;
      tgt->opt.srcport = type;
d203 1
a203 1
    return (0);
d205 1
a205 1
  return (1);
d215 2
a216 2
  tgt->opt.srcop = tgt->opt.dstop = OP_NONE;
  tgt->opt.estab = tgt->opt.syn = tgt->opt.finrst = 0;
d219 2
a220 2
    tgt->opt.srcop = filter_Nam2Op(argv[1]);
    if (tgt->opt.srcop == OP_NONE) {
d222 1
a222 1
      return (0);
d224 3
a226 3
    tgt->opt.srcport = ParsePort(argv[2], proto);
    if (tgt->opt.srcport == 0)
      return (0);
d232 2
a233 2
    tgt->opt.dstop = filter_Nam2Op(argv[1]);
    if (tgt->opt.dstop == OP_NONE) {
d235 1
a235 1
      return (0);
d237 3
a239 3
    tgt->opt.dstport = ParsePort(argv[2], proto);
    if (tgt->opt.dstport == 0)
      return (0);
d247 1
a247 1
        tgt->opt.estab = 1;
d249 1
a249 1
        tgt->opt.syn = 1;
d251 1
a251 1
        tgt->opt.finrst = 1;
d264 2
a265 1
static int ParseIgmp(int argc, char const * const *argv, struct filterent *tgt) {
d272 1
a272 1
    tgt->opt.srcop = OP_NONE;
d300 13
d318 1
a318 1
  int val;
d322 2
a323 2
  val = strtol(*argv, &wp, 0);
  if (*argv == wp || val >= MAXFILTERS) {
d325 1
a325 1
    return (0);
d327 3
a329 3
  if (val < 0) {
    for (val = 0; val < MAXFILTERS; val++) {
      ofp->action = A_NONE;
d333 1
a333 1
    return (1);
d335 1
a335 1
  ofp += val;
d339 1
a339 1
    return (0);
d346 9
a354 1
  if (!strcmp(*argv, "permit")) {
d359 2
a360 2
    ofp->action = A_NONE;
    return (1);
d363 1
a363 1
    return (0);
d365 1
a365 1
  filterdata.action = action;
d370 4
a373 10
  if (argc && filterdata.action == A_DENY) {
    if (!strcmp(*argv, "host")) {
      filterdata.action |= A_UHOST;
      argc--;
      argv++;
    } else if (!strcmp(*argv, "port")) {
      filterdata.action |= A_UPORT;
      argc--;
      argv++;
    }
d380 3
a382 3
    else if (ParseAddr(ipcp, *argv, &filterdata.src.ipaddr,
                       &filterdata.src.mask, &filterdata.src.width)) {
      filterdata.srctype = addrtype(*argv);
d389 3
a391 3
	if (ParseAddr(ipcp, *argv, &filterdata.dst.ipaddr, &filterdata.dst.mask,
                      &filterdata.dst.width)) {
          filterdata.dsttype = addrtype(*argv);
d395 10
a404 5
          filterdata.dsttype = T_ADDR;
	proto = filter_Nam2Proto(argc, argv);
	if (argc && proto != P_NONE) {
	  argc--;
	  argv++;
d412 1
a412 1
      return (0);
d420 1
a420 1
  filterdata.proto = proto;
d437 4
a440 4
  log_Printf(LogDEBUG, "Parse: Src: %s\n", inet_ntoa(filterdata.src.ipaddr));
  log_Printf(LogDEBUG, "Parse: Src mask: %s\n", inet_ntoa(filterdata.src.mask));
  log_Printf(LogDEBUG, "Parse: Dst: %s\n", inet_ntoa(filterdata.dst.ipaddr));
  log_Printf(LogDEBUG, "Parse: Dst mask: %s\n", inet_ntoa(filterdata.dst.mask));
d444 1
a444 1
            filter_Op2Nam(filterdata.opt.srcop), filterdata.opt.srcport);
d446 4
a449 4
            filter_Op2Nam(filterdata.opt.dstop), filterdata.opt.dstport);
  log_Printf(LogDEBUG, "Parse: estab: %u\n", filterdata.opt.estab);
  log_Printf(LogDEBUG, "Parse: syn: %u\n", filterdata.opt.syn);
  log_Printf(LogDEBUG, "Parse: finrst: %u\n", filterdata.opt.finrst);
d453 2
a454 1
  return (val);
d487 10
a496 2
  static const char *actname[] = { "none   ", "permit ", "deny   " };
  return actname[act & (A_PERMIT|A_DENY)];
d505 17
a521 22
    if (fp->action != A_NONE) {
      prompt_Printf(prompt, "  %2d %s", n, filter_Action2Nam(fp->action));
      if (fp->action & A_UHOST)
        prompt_Printf(prompt, "host ");
      else if (fp->action & A_UPORT)
        prompt_Printf(prompt, "port ");
      else
        prompt_Printf(prompt, "     ");
      prompt_Printf(prompt, "%s/%d ", addrstr(fp->src.ipaddr, fp->srctype),
                    fp->src.width);
      prompt_Printf(prompt, "%s/%d ", addrstr(fp->dst.ipaddr, fp->dsttype),
                    fp->dst.width);
      if (fp->proto) {
	prompt_Printf(prompt, "%s", filter_Proto2Nam(fp->proto));

	if (fp->opt.srcop)
	  prompt_Printf(prompt, " src %s %d", filter_Op2Nam(fp->opt.srcop),
		  fp->opt.srcport);
	if (fp->opt.dstop)
	  prompt_Printf(prompt, " dst %s %d", filter_Op2Nam(fp->opt.dstop),
		  fp->opt.dstport);
	if (fp->opt.estab)
d523 1
a523 1
	if (fp->opt.syn)
d525 1
a525 1
	if (fp->opt.finrst)
d628 1
a628 1
    if (fp->action != A_NONE) {
d630 4
a633 4
        if (fp->srctype == T_MYADDR)
          fp->src.ipaddr = *my_ip;
        if (fp->dsttype == T_MYADDR)
          fp->dst.ipaddr = *my_ip;
d636 4
a639 4
        if (fp->srctype == T_HISADDR)
          fp->src.ipaddr = *peer_ip;
        if (fp->dsttype == T_HISADDR)
          fp->dst.ipaddr = *peer_ip;
@


1.6
log
@Support `igmp' filters.
Mostly submitted by: Timo Geusch <freebsd@@sleepycat.ukpeople.net>
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.5 1999/05/31 23:57:36 brian Exp $
d309 1
a309 1
  if (*argv == wp || val > MAXFILTERS) {
@


1.5
log
@Remember if MYADDR or HISADDR is used in a filter add tweak all
filters any time either value changes.
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.4 1999/05/08 11:06:35 brian Exp $
d264 12
d411 3
d547 1
a547 1
static const char *protoname[] = { "none", "tcp", "udp", "icmp" };
@


1.4
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.3 1999/02/06 03:22:36 brian Exp $
d264 23
d352 3
a354 2
    else if (ParseAddr(ipcp, *argv, &filterdata.saddr, &filterdata.smask,
                       &filterdata.swidth)) {
d361 3
a363 2
	if (ParseAddr(ipcp, *argv, &filterdata.daddr, &filterdata.dmask,
                      &filterdata.dwidth)) {
d366 2
a367 1
	}
d401 4
a404 4
  log_Printf(LogDEBUG, "Parse: Src: %s\n", inet_ntoa(filterdata.saddr));
  log_Printf(LogDEBUG, "Parse: Src mask: %s\n", inet_ntoa(filterdata.smask));
  log_Printf(LogDEBUG, "Parse: Dst: %s\n", inet_ntoa(filterdata.daddr));
  log_Printf(LogDEBUG, "Parse: Dst mask: %s\n", inet_ntoa(filterdata.dmask));
d468 4
a471 2
      prompt_Printf(prompt, "%s/%d ", inet_ntoa(fp->saddr), fp->swidth);
      prompt_Printf(prompt, "%s/%d ", inet_ntoa(fp->daddr), fp->dwidth);
d578 24
@


1.3
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.27 1999/01/28 01:56:31 brian Exp $
d38 1
@


1.2
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.1 1998/08/31 00:22:20 brian Exp $
d25 1
a25 1
#include <sys/types.h>
d57 3
d77 9
d87 1
a87 1
ParseAddr(struct ipcp *ipcp, int argc, char const *const *argv,
a93 5
  if (argc < 1) {
    log_Printf(LogWARN, "ParseAddr: address/mask is expected.\n");
    return (0);
  }

d97 2
a98 2
  cp = pmask || pwidth ? strchr(*argv, '/') : NULL;
  len = cp ? cp - *argv : strlen(*argv);
d100 1
a100 1
  if (ipcp && strncasecmp(*argv, "HISADDR", len) == 0)
d102 1
a102 1
  else if (ipcp && strncasecmp(*argv, "MYADDR", len) == 0)
d105 1
a105 1
    log_Printf(LogWARN, "ParseAddr: %s: Bad address\n", *argv);
d108 1
a108 1
    strncpy(s, *argv, len);
d135 1
a135 1
      pmask->s_addr = htonl(netmasks[bits]);
d312 1
a312 1
  if (filterdata.action == A_DENY) {
d323 1
d326 4
a329 2
    if (ParseAddr(ipcp, argc, argv, &filterdata.saddr, &filterdata.smask,
                  &filterdata.swidth)) {
d333 4
a336 2
      if (proto == P_NONE) {
	if (ParseAddr(ipcp, argc, argv, &filterdata.daddr, &filterdata.dmask,
d342 1
a342 1
	if (proto != P_NONE) {
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: filter.c,v 1.25 1998/06/27 12:03:48 brian Exp $
d93 1
a93 1
  if (strncasecmp(*argv, "HISADDR", len) == 0)
d95 1
a95 1
  else if (strncasecmp(*argv, "MYADDR", len) == 0)
d124 6
a129 2
  if (pmask)
    pmask->s_addr = htonl(netmasks[bits]);
@

