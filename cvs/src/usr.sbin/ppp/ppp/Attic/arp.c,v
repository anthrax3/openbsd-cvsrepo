head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.22
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.18
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.16
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.14
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.12
	OPENBSD_5_0:1.16.0.10
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.8
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.6
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.12
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.10
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.14
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.12
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.10
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.8
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.17
date	2014.03.17.17.15.51;	author deraadt;	state dead;
branches;
next	1.16;

1.16
date	2009.07.02.16.08.29;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.06.06.34.10;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.09.01.44.16;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.16.14.13.06;	author brian;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.16.13.20.23;	author brian;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.24.10.01.09;	author brian;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.19.23.22.17;	author brian;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.31.15.20.19;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.02.00.54.33;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.27.01.38.24;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.27.00.21.05;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	99.05.08.11.06.33;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.04.26.08.54.49;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.03.22.30;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	98.10.29.02.21.44;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.15;	author brian;	state Exp;
branches;
next	;


desc
@@


1.17
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*
 * sys-bsd.c - System-dependent procedures for setting up
 * PPP interfaces on bsd-4.4-ish systems (including 386BSD, NetBSD, etc.)
 *
 * Copyright (c) 1989 Carnegie Mellon University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by Carnegie Mellon University.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * $OpenBSD: arp.c,v 1.16 2009/07/02 16:08:29 claudio Exp $
 *
 */

/*
 * TODO:
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <net/if.h>
#include <net/route.h>
#include <net/if_dl.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <sys/un.h>

#include <errno.h>
#include <ifaddrs.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/sysctl.h>
#include <termios.h>
#include <unistd.h>

#include "layer.h"
#include "mbuf.h"
#include "log.h"
#include "id.h"
#include "timer.h"
#include "fsm.h"
#include "defs.h"
#include "iplist.h"
#include "throughput.h"
#include "slcompress.h"
#include "lqr.h"
#include "hdlc.h"
#include "ncpaddr.h"
#include "ipcp.h"
#include "ipv6cp.h"
#include "descriptor.h"
#include "lcp.h"
#include "ccp.h"
#include "link.h"
#include "mp.h"
#include "ncp.h"
#include "filter.h"
#ifndef NORADIUS
#include "radius.h"
#endif
#include "bundle.h"
#include "iface.h"
#include "arp.h"

/*
 * SET_SA_FAMILY - set the sa_family field of a struct sockaddr,
 * if it exists.
 */
#define SET_SA_FAMILY(addr, family)		\
    memset((char *) &(addr), '\0', sizeof(addr));	\
    addr.sa_family = (family); 			\
    addr.sa_len = sizeof(addr);


#if RTM_VERSION >= 3

/*
 * arp_SetProxy - Make a proxy ARP entry for the peer.
 */
static struct {
  struct rt_msghdr hdr;
  struct sockaddr_inarp dst;
  struct sockaddr_dl hwa;
  char extra[128];
} arpmsg;

static int
arp_ProxySub(struct bundle *bundle, struct in_addr addr, int add, int s)
{
  int routes;

  /*
   * Get the hardware address of an interface on the same subnet as our local
   * address.
   */

  memset(&arpmsg, 0, sizeof arpmsg);
  if (!arp_EtherAddr(s, addr, &arpmsg.hwa, 0)) {
    log_Printf(LogWARN, "%s: Cannot determine ethernet address for proxy ARP\n",
	       inet_ntoa(addr));
    return 0;
  }
  routes = ID0socket(PF_ROUTE, SOCK_RAW, AF_INET);
  if (routes < 0) {
    log_Printf(LogERROR, "arp_SetProxy: opening routing socket: %s\n",
	      strerror(errno));
    return 0;
  }
  arpmsg.hdr.rtm_type = add ? RTM_ADD : RTM_DELETE;
  arpmsg.hdr.rtm_flags = RTF_ANNOUNCE | RTF_HOST | RTF_STATIC;
  arpmsg.hdr.rtm_version = RTM_VERSION;
  arpmsg.hdr.rtm_seq = ++bundle->routing_seq;
  arpmsg.hdr.rtm_addrs = RTA_DST | RTA_GATEWAY;
  arpmsg.hdr.rtm_inits = RTV_EXPIRE;
  arpmsg.dst.sin_len = sizeof(struct sockaddr_inarp);
  arpmsg.dst.sin_family = AF_INET;
  arpmsg.dst.sin_addr.s_addr = addr.s_addr;
  arpmsg.dst.sin_other = SIN_PROXY;

  arpmsg.hdr.rtm_msglen = (char *) &arpmsg.hwa - (char *) &arpmsg
    + arpmsg.hwa.sdl_len;


  if (ID0write(routes, &arpmsg, arpmsg.hdr.rtm_msglen) < 0 &&
      !(!add && errno == ESRCH)) {
    log_Printf(LogERROR, "%s proxy arp entry %s: %s\n",
	add ? "Add" : "Delete", inet_ntoa(addr), strerror(errno));
    close(routes);
    return 0;
  }
  close(routes);
  return 1;
}

int
arp_SetProxy(struct bundle *bundle, struct in_addr addr, int s)
{
  return (arp_ProxySub(bundle, addr, 1, s));
}

/*
 * arp_ClearProxy - Delete the proxy ARP entry for the peer.
 */
int
arp_ClearProxy(struct bundle *bundle, struct in_addr addr, int s)
{
  return (arp_ProxySub(bundle, addr, 0, s));
}

#else				/* RTM_VERSION */

/*
 * arp_SetProxy - Make a proxy ARP entry for the peer.
 */
int
arp_SetProxy(struct bundle *bundle, struct in_addr addr, int s)
{
  struct arpreq arpreq;
  struct {
    struct sockaddr_dl sdl;
    char space[128];
  }      dls;

  memset(&arpreq, '\0', sizeof arpreq);

  /*
   * Get the hardware address of an interface on the same subnet as our local
   * address.
   */
  if (!arp_EtherAddr(s, addr, &dls.sdl, 1)) {
    log_Printf(LOG_PHASE_BIT, "Cannot determine ethernet address for "
               "proxy ARP\n");
    return 0;
  }
  arpreq.arp_ha.sa_len = sizeof(struct sockaddr);
  arpreq.arp_ha.sa_family = AF_UNSPEC;
  memcpy(arpreq.arp_ha.sa_data, LLADDR(&dls.sdl), dls.sdl.sdl_alen);
  SET_SA_FAMILY(arpreq.arp_pa, AF_INET);
  ((struct sockaddr_in *)&arpreq.arp_pa)->sin_addr.s_addr = addr.s_addr;
  arpreq.arp_flags = ATF_PERM | ATF_PUBL;
  if (ID0ioctl(s, SIOCSARP, (caddr_t) & arpreq) < 0) {
    log_Printf(LogERROR, "arp_SetProxy: ioctl(SIOCSARP): %s\n",
               strerror(errno));
    return 0;
  }
  return 1;
}

/*
 * arp_ClearProxy - Delete the proxy ARP entry for the peer.
 */
int
arp_ClearProxy(struct bundle *bundle, struct in_addr addr, int s)
{
  struct arpreq arpreq;

  memset(&arpreq, '\0', sizeof arpreq);
  SET_SA_FAMILY(arpreq.arp_pa, AF_INET);
  ((struct sockaddr_in *)&arpreq.arp_pa)->sin_addr.s_addr = addr.s_addr;
  if (ID0ioctl(s, SIOCDARP, (caddr_t) & arpreq) < 0) {
    log_Printf(LogERROR, "arp_ClearProxy: ioctl(SIOCDARP): %s\n",
               strerror(errno));
    return 0;
  }
  return 1;
}

#endif				/* RTM_VERSION */


/*
 * arp_EtherAddr - get the hardware address of an interface on the
 * the same subnet as ipaddr.
 */

int
arp_EtherAddr(int s, struct in_addr ipaddr, struct sockaddr_dl *hwaddr,
              int verbose)
{
  struct sockaddr_dl *dl = NULL;
  struct ifaddrs *ifa, *ifap;
  int skip = 1;

  if (getifaddrs(&ifap) != 0) {
    log_Printf(LogERROR, "arp_EtherAddr: getifaddrs: %s\n", strerror(errno));
    return 0;
  }

  for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
    if (ifa->ifa_addr->sa_family == AF_LINK) {
      dl = (struct sockaddr_dl *)ifa->ifa_addr;
      skip = (ifa->ifa_flags & (IFF_UP | IFF_BROADCAST | IFF_POINTOPOINT |
            IFF_NOARP | IFF_LOOPBACK)) != (IFF_UP | IFF_BROADCAST);
      continue;
    }
    if (skip)
      /* Skip unusable interface */
      continue;

    /* Found a candidate.  Do the addresses match ? */
    if (log_IsKept(LogDEBUG))
      log_Printf(LogDEBUG, "%.*s interface is a candidate for proxy\n",
                dl->sdl_nlen, dl->sdl_data);

    if (ifa->ifa_addr->sa_family == AF_INET) {
      struct sockaddr_in *addr, *netmask;

      addr = (struct sockaddr_in *)ifa->ifa_addr;
      netmask = (struct sockaddr_in *)ifa->ifa_netmask;

      if (log_IsKept(LogDEBUG)) {
        char a[16];

        strncpy(a, inet_ntoa(netmask->sin_addr), sizeof a - 1);
        a[sizeof a - 1] = '\0';
        log_Printf(LogDEBUG, "Check addr %s, mask %s\n",
                   inet_ntoa(addr->sin_addr), a);
      }

      if ((addr->sin_addr.s_addr & netmask->sin_addr.s_addr) ==
          (ipaddr.s_addr & netmask->sin_addr.s_addr)) {
        log_Printf(verbose ? LogPHASE : LogDEBUG,
                   "Found interface %.*s for %s\n", dl->sdl_nlen,
                   dl->sdl_data, inet_ntoa(ipaddr));
        memcpy(hwaddr, dl, dl->sdl_len);
        freeifaddrs(ifap);
        return 1;
      }
    }
  }
  freeifaddrs(ifap);

  return 0;
}
@


1.16
log
@Rewrite the sysctl handlers to use libc functions (getifaddrs and
if_indextoname) instead of looking at the sysctl data directly. This makes
the code a lot simpler and actually work. Tested by many (todd@@, sthen@@, and
a few people on tech@@). OK sthen@@, deraadt@@
@
text
@d20 1
a20 1
 * $OpenBSD: arp.c,v 1.15 2008/05/06 06:34:10 claudio Exp $
@


1.15
log
@More missing RTM_VERSION checks. OK henning@@
@
text
@d20 1
a20 1
 * $OpenBSD: arp.c,v 1.14 2005/07/09 01:44:16 brad Exp $
d41 1
d233 6
a238 18
  int mib[6], skip;
  size_t needed;
  char *buf, *ptr, *end;
  struct if_msghdr *ifm;
  struct ifa_msghdr *ifam;
  struct sockaddr_dl *dl;
  struct sockaddr *sa[RTAX_MAX];

  mib[0] = CTL_NET;
  mib[1] = PF_ROUTE;
  mib[2] = 0;
  mib[3] = 0;
  mib[4] = NET_RT_IFLIST;
  mib[5] = 0;

  if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
    log_Printf(LogERROR, "arp_EtherAddr: sysctl: estimate: %s\n",
              strerror(errno));
d242 10
a251 2
  if ((buf = malloc(needed)) == NULL)
    return 0;
d253 19
a271 5
  if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
    free(buf);
    return 0;
  }
  end = buf + needed;
d273 8
a280 53
  ptr = buf;
  while (ptr < end) {
    ifm = (struct if_msghdr *)ptr;		/* On if_msghdr */
    if (ifm->ifm_type != RTM_IFINFO)
      break;
    ptr += ifm->ifm_msglen;
    if (ifm->ifm_version != RTM_VERSION)
      continue;
    dl = (struct sockaddr_dl *)(ifm + 1);	/* Single _dl at end */
    skip = (ifm->ifm_flags & (IFF_UP | IFF_BROADCAST | IFF_POINTOPOINT |
            IFF_NOARP | IFF_LOOPBACK)) != (IFF_UP | IFF_BROADCAST);
    while (ptr < end) {
      ifam = (struct ifa_msghdr *)ptr;	/* Next ifa_msghdr (alias) */
      if (ifam->ifam_type != RTM_NEWADDR)	/* finished ? */
        break;
      ptr += ifam->ifam_msglen;
      if (ifam->ifam_version != RTM_VERSION)
        continue;
      if (skip || (ifam->ifam_addrs & (RTA_NETMASK|RTA_IFA)) !=
          (RTA_NETMASK|RTA_IFA))
        continue;
      /* Found a candidate.  Do the addresses match ? */
      if (log_IsKept(LogDEBUG) &&
          ptr == (char *)ifm + ifm->ifm_msglen + ifam->ifam_msglen)
        log_Printf(LogDEBUG, "%.*s interface is a candidate for proxy\n",
                  dl->sdl_nlen, dl->sdl_data);

      iface_ParseHdr(ifam, sa);

      if (sa[RTAX_IFA]->sa_family == AF_INET) {
        struct sockaddr_in *ifa, *netmask;

        ifa = (struct sockaddr_in *)sa[RTAX_IFA];
        netmask = (struct sockaddr_in *)sa[RTAX_NETMASK];

        if (log_IsKept(LogDEBUG)) {
          char a[16];

          strncpy(a, inet_ntoa(netmask->sin_addr), sizeof a - 1);
          a[sizeof a - 1] = '\0';
          log_Printf(LogDEBUG, "Check addr %s, mask %s\n",
                     inet_ntoa(ifa->sin_addr), a);
        }

        if ((ifa->sin_addr.s_addr & netmask->sin_addr.s_addr) ==
            (ipaddr.s_addr & netmask->sin_addr.s_addr)) {
          log_Printf(verbose ? LogPHASE : LogDEBUG,
                     "Found interface %.*s for %s\n", dl->sdl_nlen,
                     dl->sdl_data, inet_ntoa(ipaddr));
          memcpy(hwaddr, dl, dl->sdl_len);
          free(buf);
          return 1;
        }
d284 1
a284 1
  free(buf);
@


1.14
log
@rev 1.45

Use the length of the interface name, not the length of its address when
printing the name.

From brooks FreeBSD
@
text
@d20 1
a20 1
 * $OpenBSD: arp.c,v 1.13 2002/01/16 14:13:06 brian Exp $
d267 3
a272 1
    ptr += ifm->ifm_msglen;			/* First ifa_msghdr */
d278 2
@


1.13
log
@socket()s first argument should be a protocol family rather than an
address family.
@
text
@d20 1
a20 1
 * $OpenBSD: arp.c,v 1.12 2002/01/16 13:20:23 brian Exp $
d305 1
a305 1
                     "Found interface %.*s for %s\n", dl->sdl_alen,
@


1.12
log
@socket's first argument is an address family, not a protocol family.
@
text
@d20 1
a20 1
 * $OpenBSD: arp.c,v 1.11 2001/10/24 10:01:09 brian Exp $
d115 1
a115 1
  routes = ID0socket(AF_ROUTE, SOCK_RAW, AF_INET);
@


1.11
log
@Write static arp entries as uid 0.
@
text
@d20 1
a20 1
 * $OpenBSD: arp.c,v 1.10 2001/08/19 23:22:17 brian Exp $
d115 1
a115 1
  routes = ID0socket(PF_ROUTE, SOCK_RAW, AF_INET);
@


1.10
log
@Add IPv6 support.

IPV6CP support is crude for now, and hasn't been tested against
any other implementations.  RADIUS and IPv6 are independent of
eachother for now.  ppp.linkup/ppp.linkdown aren't currently used
by IPV6CP

Understand all protocols(5) in filter rules rather than only a select
few.

Allow a mask specification for the ``delete'' command.  It's now
possible to specifically delete one of two conflicting routes.

When creating and deleting proxy arp entries, do it for all IPv4
interface addresses rather than doing it just for the ``current''
peer address.

When iface-alias isn't in effect, don't blow away manually (via ``iface
add'') added interface addresses.

When listening on a tcp server (diagnostic) socket, bind so that a
tcp46 socket is created -- allowing both IPv4 and IPv6 connections.

When displaying ICMP traffic, don't display the icmp type twice.

When display traffic, display at least some information about unrecognised
traffic.

Bump version
@
text
@d20 1
a20 1
 * $OpenBSD: arp.c,v 1.9 2001/07/31 15:20:19 brian Exp $
d136 1
a136 1
  if (write(routes, &arpmsg, arpmsg.hdr.rtm_msglen) < 0 &&
@


1.9
log
@Remove an irritating diagnostic emitted to LogPHASE when a
static proxy arp entry is deleted.

Rename a function (for consistency) and remove some whitespace
(for readability).
@
text
@d20 1
a20 1
 * $OpenBSD: arp.c,v 1.8 2000/11/02 00:54:33 brian Exp $
d60 1
d62 1
a62 1
#include "filter.h"
d68 2
@


1.8
log
@Some whitespace changes
Some slightly better diagnostics
Add MPPE and chapv2 support; Ustimenko Semen <semen@@iclub.nsu.ru>
Bump the version number
Add ``all'' logging; perhaps@@yes.no
Handle quoted hash characters properly
Honour ``nat deny_incoming'' properly
Fix radius accounting initialisation
Moan about tcsetattr() failures
@
text
@d20 1
a20 1
 * $OpenBSD: arp.c,v 1.7 2000/02/27 01:38:24 brian Exp $
d107 1
a107 1
  if (!get_ether_addr(s, addr, &arpmsg.hwa)) {
a146 1

a155 1

d179 1
a179 1
  if (!get_ether_addr(s, addr, &dls.sdl)) {
d221 1
a221 1
 * get_ether_addr - get the hardware address of an interface on the
d226 2
a227 1
get_ether_addr(int s, struct in_addr ipaddr, struct sockaddr_dl *hwaddr)
d245 1
a245 1
    log_Printf(LogERROR, "get_ether_addr: sysctl: estimate: %s\n",
d301 3
a303 2
          log_Printf(LogPHASE, "Found interface %.*s for %s\n",
                    dl->sdl_alen, dl->sdl_data, inet_ntoa(ipaddr));
@


1.7
log
@$Id$ -> $OpenBSD$
@
text
@d20 1
a20 1
 * $OpenBSD: arp.c,v 1.6 2000/02/27 00:21:05 brian Exp $
d182 2
a183 1
    log_Printf(LOG_PHASE_BIT, "Cannot determine ethernet address for proxy ARP\n");
@


1.6
log
@When we stop a timer that's the first in the timer list, ensure
that we adjust that timers `rest' value (with the current getitimer()
values) before using that to adjust the next items `rest' value.
After adjusting that value, restart the timer service so that we've
now got the correct setitimer() values.
When adjusting timer::rest, round to the closest TICKUNIT usecs
value.

struct descriptor -> struct fdescriptor (to avoid header polution in
NetBSD).

Introduce LOCALNAT and LOCALRAD defines.

The interface list that comes back from the PF_ROUTE/NET_RT_IFLIST mib
is aligned.  Teach this to ``show route'' and clean up some of the
sockaddr parsing routines.

Add ``set log dns'' to log DNS QUERY packets.

When ppp can't identify the relevant name, don't use "???", use
<nnn> or <0xnnn> instead.

Don't ``break'' when we come accross a non-RTM_IFINFO type
entry in the block returned by the NET_RT_IFLIST mib,
continue instead.

Correct UN_SIZE definition; ben@@scientia.demon.co.uk
@
text
@d20 1
a20 1
 * $Id: arp.c,v 1.5 1999/05/08 11:06:33 brian Exp $
@


1.5
log
@o Redesign the layering mechanism and make the aliasing code part of
  the layering.

  We now ``stack'' layers as soon as we open the device (when we figure
  out what we're dealing with).  A static set of `dispatch' routines are
  also declared for dealing with incoming packets after they've been
  `pulled' up through the stacked layers.

  Physical devices are now assigned handlers based on the device type
  when they're opened.  For the moment there are three device types;
  ttys, execs and tcps.

o Increment version number to 2.2
o Make an entry in [uw]tmp for non-tty -direct invocations (after
  pap/chap authentication).
o Make throughput counters quad_t's
o Account for the absolute number of mbuf malloc()s and free()s in
  ``show mem''.
o ``show modem'' becomes ``show physical''.
@
text
@d20 1
a20 1
 * $Id: arp.c,v 1.4 1999/04/26 08:54:49 brian Exp $
d71 1
d229 1
a229 1
  int mib[6], sa_len, skip, b;
a233 1
  struct sockaddr *sa;
d235 1
a235 1
  struct sockaddr_in *ifa, *mask;
a271 1
      sa = (struct sockaddr *)(ifam+1);	/* pile of sa's at end */
d281 16
a296 14
      b = 1;
      ifa = mask = NULL;
      while (b < (RTA_NETMASK|RTA_IFA) && sa < (struct sockaddr *)ptr) {
        switch (b) {
        case RTA_IFA:
          ifa = (struct sockaddr_in *)sa;
          break;
        case RTA_NETMASK:
          /*
           * Careful here !  this sockaddr doesn't have sa_family set to 
           * AF_INET, and is only 8 bytes big !  I have no idea why !
           */
          mask = (struct sockaddr_in *)sa;
          break;
d298 8
a305 4
        if (ifam->ifam_addrs & b) {
#define ALN sizeof(ifa->sin_addr.s_addr)
          sa_len = sa->sa_len > 0 ? ((sa->sa_len-1)|(ALN-1))+1 : ALN;
          sa = (struct sockaddr *)((char *)sa + sa_len);
a306 17
        b <<= 1;
      }
      if (log_IsKept(LogDEBUG)) {
        char a[16];
        strncpy(a, inet_ntoa(mask->sin_addr), sizeof a - 1);
        a[sizeof a - 1] = '\0';
        log_Printf(LogDEBUG, "Check addr %s, mask %s\n",
                  inet_ntoa(ifa->sin_addr), a);
      }
      if (ifa->sin_family == AF_INET &&
          (ifa->sin_addr.s_addr & mask->sin_addr.s_addr) ==
          (ipaddr.s_addr & mask->sin_addr.s_addr)) {
        log_Printf(LogPHASE, "Found interface %.*s for %s\n",
                  dl->sdl_alen, dl->sdl_data, inet_ntoa(ipaddr));
        memcpy(hwaddr, dl, dl->sdl_len);
        free(buf);
        return 1;
@


1.4
log
@#include <errno.h>, not <sys/errno.h>
@
text
@d20 1
a20 1
 * $Id: arp.c,v 1.3 1999/02/06 03:22:30 brian Exp $
d45 1
d48 1
@


1.3
log
@Support RADIUS

While I'm in there, validate pap & chap header IDs if
``idcheck'' is enabled (the default) for other FSM packet
types.

NOTE: This involved integrating the generation of chap
      challenges and the validation of chap responses
      (and commenting what's going on in those routines).
      I currently have no way of testing ppps ability
      to respond to M$Chap CHALLENGEs correctly, so if
      someone could do the honours, it'd be much
      appreciated (it *looks* ok!).

Sponsored by: Internet Business Solutions Ltd., Switzerland
@
text
@d20 1
a20 1
 * $Id: arp.c,v 1.32 1999/01/28 01:56:30 brian Exp $
d40 1
a43 1
#include <sys/errno.h>
@


1.2
log
@Catch up with the latest ppp updates/fixes:

- Add enable/disable proxyall to proxy arp an entire subnet
  (smaller than class C)
- Add ``set {send,recv}pipe for controlling socket buffers.
- Fix the infamous ``first connection'' problem where the process
  that causes an auto dial to an ISP that assigns a dynamic IP never
  connects (due to the bound socket IP being changed on the tun iface).
  See ``enable/disable iface-alias'' and ``iface ...'' in the man page.
- Add PROCESSID as a substitution string when running commands.
- Add ``set proctitle'' for changing argv0.  You can use all the command
  substitutions here too (eg ``set proctitle ppp: USER INTERFACE'').
- Add a missing untimeout as soon as the chat expect string is received
  rather than waiting for the next expect to happen.
- Be less restrictive about when auth{name,key}, enddisc, shortseq and
  mrru can be changed.
- Improve some diagnostics.
- Don't send a DELAY field with CBCP_NONUM messages (as per the spec).
- Emphasise how to make callback optional in the man page.
- Allow the caller to request no callback if they're allowed choose the
  number anyway.
- Set our CBCP RESPONSE fsm id according to the REQ, moan if the peer
  gets the response id wrong (but continue anyway).
- Shuffle the ``set ?'' output back a column so that broken terminals
  that can't display 80 columns *and* a '\n' will look ok.
- If DES is compiled out, be more verbose about why CHAP 0x80 was rejected.
@
text
@d20 1
a20 1
 * $Id: arp.c,v 1.1 1998/08/31 00:22:15 brian Exp $
d28 1
a28 1
#include <sys/types.h>
d65 3
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d20 1
a20 1
 * $Id: arp.c,v 1.30 1998/08/26 17:39:36 brian Exp $
d90 2
a91 4
static int arpmsg_valid;

int
arp_SetProxy(struct bundle *bundle, struct in_addr addr, int s)
d99 1
d102 2
a103 1
    log_Printf(LogWARN, "Cannot determine ethernet address for proxy ARP\n");
d112 1
a112 1
  arpmsg.hdr.rtm_type = RTM_ADD;
d125 6
a130 2
  if (write(routes, &arpmsg, arpmsg.hdr.rtm_msglen) < 0) {
    log_Printf(LogERROR, "Add proxy arp entry: %s\n", strerror(errno));
a134 1
  arpmsg_valid = 1;
d138 7
a150 8
  int routes;

  if (!arpmsg_valid)
    return 0;
  arpmsg_valid = 0;

  arpmsg.hdr.rtm_type = RTM_DELETE;
  arpmsg.hdr.rtm_seq = ++bundle->routing_seq;
d152 1
a152 13
  routes = ID0socket(PF_ROUTE, SOCK_RAW, AF_INET);
  if (routes < 0) {
    log_Printf(LogERROR, "arp_SetProxy: opening routing socket: %s\n",
	      strerror(errno));
    return 0;
  }
  if (write(routes, &arpmsg, arpmsg.hdr.rtm_msglen) < 0) {
    log_Printf(LogERROR, "Delete proxy arp entry: %s\n", strerror(errno));
    close(routes);
    return 0;
  }
  close(routes);
  return 1;
@

