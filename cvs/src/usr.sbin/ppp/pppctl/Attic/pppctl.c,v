head	1.22;
access;
symbols
	OPENBSD_5_5:1.21.0.16
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.12
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.10
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.8
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.6
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2014.03.17.17.15.52;	author deraadt;	state dead;
branches;
next	1.21;

1.21
date	2010.08.12.02.00.28;	author kevlo;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.12.16.01.08;	author sobrado;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.26.17.48.41;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.11.22.32.28;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.24.09.30.11;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.15.00.21.23;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.31.08.48.16;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.07.07.50.29;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.19.23.57.09;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.14.03.14.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.04.20.28.57;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.04.20.25.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.02.16.09.05;	author brian;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.18.22.14.39;	author brian;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.22.17.16.27;	author brian;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.05.01.02.55;	author brian;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.16.12.02.40;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	99.08.02.17.00.25;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	99.04.26.08.53.33;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	99.01.31.12.25.04;	author brian;	state Exp;
branches;
next	1.1;

1.1
date	98.08.31.00.22.31;	author brian;	state Exp;
branches;
next	;


desc
@@


1.22
log
@ppp(8) goes to the bit bucket in the sky
@
text
@/*-
 * Copyright (c) 1997 Brian Somers <brian@@Awfulhak.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$Id: pppctl.c,v 1.21 2010/08/12 02:00:28 kevlo Exp $
 */

#include <sys/types.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <netdb.h>

#include <sys/time.h>
#include <err.h>
#include <errno.h>
#include <histedit.h>
#ifdef __FreeBSD__
#include <libutil.h>
#endif
#include <setjmp.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <poll.h>
#include <unistd.h>

#define LINELEN 2048
static char Buffer[LINELEN], Command[LINELEN];

static int
usage()
{
    fprintf(stderr,
        "usage: pppctl [-v] [-p passwd] [-t n] [host:]port | LocalSocket\n"
        "              [command [;command ...]]\n");
    exit(1);
}

static int TimedOut = 0;
static void
Timeout(int Sig)
{
    TimedOut = 1;
}

#define REC_PASSWD  (1)
#define REC_SHOW    (2)
#define REC_VERBOSE (4)

static char *passwd;
static char *prompt;

static char *
GetPrompt(EditLine *e)
{
    if (prompt == NULL)
        prompt = "";
    return prompt;
}

static int
Receive(int fd, int display)
{
    int Result;
    int len;
    char *last;

    prompt = Buffer;
    len = 0;
    while (Result = read(fd, Buffer+len, sizeof(Buffer)-len-1), Result != -1) {
        if (Result == 0 && errno != EINTR) {
          Result = -1;
          break;
        }
        len += Result;
        Buffer[len] = '\0';
        if (len > 2 && !strcmp(Buffer+len-2, "> ")) {
            prompt = strrchr(Buffer, '\n');
            if (display & (REC_SHOW|REC_VERBOSE)) {
                if (display & REC_VERBOSE)
                    last = Buffer+len-1;
                else
                    last = prompt;
                if (last) {
                    last++;
                    write(STDOUT_FILENO, Buffer, last-Buffer);
                }
            }
            prompt = prompt == NULL ? Buffer : prompt+1;
            for (last = Buffer+len-2; last > Buffer && *last != ' '; last--)
                ;
            if (last > Buffer+3 && !strncmp(last-3, " on", 3)) {
                 /* a password is required! */
                 if (display & REC_PASSWD) {
                    /* password time */
                    if (!passwd)
                        if ((passwd = getpass("Password:")) == NULL)
				err(1, "getpass");
                    snprintf(Buffer, sizeof Buffer, "passwd %s\n", passwd);
                    memset(passwd, '\0', strlen(passwd));
                    if (display & REC_VERBOSE)
                        write(STDOUT_FILENO, Buffer, strlen(Buffer));
                    write(fd, Buffer, strlen(Buffer));
                    memset(Buffer, '\0', strlen(Buffer));
                    return Receive(fd, display & ~REC_PASSWD);
                }
                Result = 1;
            } else
                Result = 0;
            break;
        }
        if (len == sizeof Buffer - 1) {
            int flush;
            if ((last = strrchr(Buffer, '\n')) == NULL)
                /* Yeuch - this is one mother of a line ! */
                flush = sizeof Buffer / 2;
            else
                flush = last - Buffer + 1;
            write(STDOUT_FILENO, Buffer, flush);
            strlcpy(Buffer, Buffer + flush, sizeof Buffer);
            len -= flush;
        }
    }

    return Result;
}

static int data = -1;
static jmp_buf pppdead;

static void
check_fd(int sig)
{
  if (data != -1) {
    struct pollfd pfd[1];
    static char buf[LINELEN];
    int len;

    pfd[0].fd = data;
    pfd[0].events = POLLIN;
    if (poll(pfd, 1, 0) > 0) {
      len = read(data, buf, sizeof buf);
      if (len > 0)
        write(STDOUT_FILENO, buf, len);
      else
        longjmp(pppdead, -1);
    }
  }
}

static const char *
smartgets(EditLine *e, int *count, int fd)
{
  const char *result;

  data = fd;
  signal(SIGALRM, check_fd);
  ualarm(500000, 500000);
  result = setjmp(pppdead) ? NULL : el_gets(e, count);
  ualarm(0,0);
  signal(SIGALRM, SIG_DFL);
  data = -1;

  return result;
}

static const char *
sockaddr_ntop(const struct sockaddr *sa)
{
    const void *addr;
    static char addrbuf[INET6_ADDRSTRLEN];
 
    switch (sa->sa_family) {
    case AF_INET:
	addr = &((const struct sockaddr_in *)sa)->sin_addr;
	break;
    case AF_UNIX:
	addr = &((const struct sockaddr_un *)sa)->sun_path;                
	break;
    case AF_INET6:
	addr = &((const struct sockaddr_in6 *)sa)->sin6_addr;
	break;
    default:
	return NULL;
    }
    inet_ntop(sa->sa_family, addr, addrbuf, sizeof(addrbuf));                
    return addrbuf;
}

/*
 * Connect to ppp using either a local domain socket or a tcp socket.
 */
int
main(int argc, char **argv)
{
    struct sockaddr_un ifsun;
    int n, arg, fd, len, verbose, save_errno, hide1, hide1off, hide2;
    unsigned TimeoutVal;
    char *DoneWord = "x", *next, *start;
    struct sigaction act, oact;

    verbose = 0;
    TimeoutVal = 2;
    hide1 = hide1off = hide2 = 0;

    for (arg = 1; arg < argc; arg++)
        if (*argv[arg] == '-') {
            for (start = argv[arg] + 1; *start; start++)
                switch (*start) {
                    case 't':
                        TimeoutVal = (unsigned)atoi
                            (start[1] ? start + 1 : argv[++arg]);
                        start = DoneWord;
                        break;

                    case 'v':
                        verbose = REC_VERBOSE;
                        break;

                    case 'p':
                        if (start[1]) {
                          hide1 = arg;
                          hide1off = start - argv[arg];
                          passwd = start + 1;
                        } else {
                          hide1 = arg;
                          hide1off = start - argv[arg];
                          passwd = argv[++arg];
                          hide2 = arg;
                        }
                        start = DoneWord;
                        break;

                    default:
                        usage();
                }
        }
        else
            break;


    if (argc < arg + 1)
        usage();

    if (hide1) {
      char title[1024];
      int pos, harg;

      for (harg = pos = 0; harg < argc; harg++)
        if (harg == 0 || harg != hide2) {
          if (harg == 0 || harg != hide1)
            n = snprintf(title + pos, sizeof title - pos, "%s%s",
                            harg ? " " : "", argv[harg]);
          else if (hide1off > 1)
            n = snprintf(title + pos, sizeof title - pos, " %.*s",
                            hide1off, argv[harg]);
          else
            n = 0;
          if (n < 0 || n >= sizeof title - pos)
            break;
          pos += n;
        }
#ifdef __FreeBSD__
      setproctitle("-%s", title);
#else
      setproctitle("%s", title);
#endif
    }

    if (*argv[arg] == '/') {
        memset(&ifsun, '\0', sizeof ifsun);
        ifsun.sun_len = strlen(argv[arg]);
        if (ifsun.sun_len > sizeof ifsun.sun_path - 1) {
            warnx("%s: path too long", argv[arg]);
            return 1;
        }
        ifsun.sun_family = AF_LOCAL;
        strlcpy(ifsun.sun_path, argv[arg], sizeof ifsun.sun_path);

        if (fd = socket(AF_LOCAL, SOCK_STREAM, 0), fd < 0) {
            warnx("cannot create local domain socket");
            return 2;
        }
	if (connect(fd, (struct sockaddr *)&ifsun, sizeof(ifsun)) < 0) {
	    if (errno)
		warn("cannot connect to socket %s", argv[arg]);
	    else
		warnx("cannot connect to socket %s", argv[arg]);
	    close(fd);
	    return 3;
	}
    } else {
	char *addr, *p, *port;
	const char *caddr;
	struct addrinfo hints, *res, *pai;
	int gai;
	char local[] = "localhost";

	addr = argv[arg];
	if (addr[strspn(addr, "0123456789")] == '\0') {
	    /* port on local machine */
	    port = addr;
	    addr = local;
	} else if (*addr == '[') {
	    /* [addr]:port */
	    if ((p = strchr(addr, ']')) == NULL) {
		warnx("%s: mismatched '['", addr);
		return 1;
	    }
	    addr++;
	    *p++ = '\0';
	    if (*p != ':') {
		warnx("%s: missing port", addr);
		return 1;
	    }
	    port = ++p;
	} else {
	    /* addr:port */
	    p = addr + strcspn(addr, ":");
	    if (*p != ':') {
		warnx("%s: missing port", addr);
		return 1;
	    }
	    *p++ = '\0';
	    port = p;
	}
	memset(&hints, 0, sizeof(hints));
	hints.ai_socktype = SOCK_STREAM;
	gai = getaddrinfo(addr, port, &hints, &res);
	if (gai != 0) {
	    warnx("%s: %s", addr, gai_strerror(gai));
	    return 1;
	}
	for (pai = res; pai != NULL; pai = pai->ai_next) {
	    if (fd = socket(pai->ai_family, pai->ai_socktype,
		pai->ai_protocol), fd < 0) {
		warnx("cannot create socket");
		continue;
	    }
	    TimedOut = 0;
	    if (TimeoutVal) {
		act.sa_handler = Timeout;
		sigemptyset(&act.sa_mask);
		act.sa_flags = 0;
		sigaction(SIGALRM, &act, &oact);
		alarm(TimeoutVal);
	    }
	    if (connect(fd, pai->ai_addr, pai->ai_addrlen) == 0)
		break;
	    if (TimeoutVal) {
		save_errno = errno;
		alarm(0);
		sigaction(SIGALRM, &oact, 0);
		errno = save_errno;
	    }
	    caddr = sockaddr_ntop(pai->ai_addr);
	    if (caddr == NULL)
		caddr = argv[arg];
	    if (TimedOut)
		warnx("timeout: cannot connect to %s", caddr);
	    else {
		if (errno)
		    warn("cannot connect to %s", caddr);
		else
		    warnx("cannot connect to %s", caddr);
	    }
	    close(fd);
	}
	freeaddrinfo(res);
	if (pai == NULL)
	    return 1;
	if (TimeoutVal) {
	    alarm(0);
	    sigaction(SIGALRM, &oact, 0);
	}
    }

    len = 0;
    Command[sizeof(Command)-1] = '\0';
    for (arg++; arg < argc; arg++) {
        if (len && len < sizeof(Command)-1) {
            strlcpy(Command+len, " ", sizeof Command - len);
	    len++;
	}
        strncpy(Command+len, argv[arg], sizeof(Command)-len-1);
        len += strlen(Command+len);
    }

    switch (Receive(fd, verbose | REC_PASSWD))
    {
        case 1:
            fprintf(stderr, "Password incorrect\n");
            break;

        case 0:
            if (len == 0) {
                EditLine *edit;
                History *hist;
                const char *l, *env;
                int size;
                HistEvent hev = { 0, "" };

                hist = history_init();
                if ((env = getenv("EL_SIZE"))) {
                    size = atoi(env);
                    if (size < 0)
                      size = 20;
                } else
                    size = 20;
                history(hist, &hev, H_SETSIZE, size);
                edit = el_init("pppctl", stdin, stdout, stderr);
                el_source(edit, NULL);
                el_set(edit, EL_PROMPT, GetPrompt);
                if ((env = getenv("EL_EDITOR"))) {
                    if (!strcmp(env, "vi"))
                        el_set(edit, EL_EDITOR, "vi");
                    else if (!strcmp(env, "emacs"))
                        el_set(edit, EL_EDITOR, "emacs");
                }
                el_set(edit, EL_SIGNAL, 1);
                el_set(edit, EL_HIST, history, (const char *)hist);
                while ((l = smartgets(edit, &len, fd))) {
                    if (len > 1)
                        history(hist, &hev, H_ENTER, l);
                    write(fd, l, len);
                    if (Receive(fd, REC_SHOW) != 0)
                        break;
                }
                fprintf(stderr, "Connection closed\n");
                el_end(edit);
                history_end(hist);
            } else {
                start = Command;
                do {
                    next = strchr(start, ';');
                    while (*start == ' ' || *start == '\t')
                        start++;
                    if (next)
                        *next = '\0';
                    strlcpy(Buffer, start, sizeof Buffer);
                    Buffer[sizeof(Buffer)-2] = '\0';
                    strlcat(Buffer, "\n", sizeof Buffer);
                    if (verbose)
                        write(STDOUT_FILENO, Buffer, strlen(Buffer));
                    write(fd, Buffer, strlen(Buffer));
                    if (Receive(fd, verbose | REC_SHOW) != 0) {
                        fprintf(stderr, "Connection closed\n");
                        break;
                    }
                    if (next)
                        start = ++next;
                } while (next && *next);
                if (verbose)
                    puts("");
            }
            break;

        default:
            warnx("ppp is not responding");
            break;
    }

    close(fd);

    return 0;
}
@


1.21
log
@Use symbolic names for the file descriptors rather than numeric values.
Some from damien@@, millert@@

ok phessler@@, millert@@
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.20 2008/11/12 16:01:08 sobrado Exp $
@


1.20
log
@we should not document each operand in the usage of a command,
it is an usual practice on BSDs and make the synopsis and usage
more robust when operands are added or removed; synchronize the
usage with the synopsis on the manual page; while here, remove
superfluous information from the usage.

ok jmc@@
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.19 2007/07/26 17:48:41 millert Exp $
d112 1
a112 1
                    write(1, Buffer, last-Buffer);
d128 1
a128 1
                        write(1, Buffer, strlen(Buffer));
d145 1
a145 1
            write(1, Buffer, flush);
d170 1
a170 1
        write(1, buf, len);
d470 1
a470 1
                        write(1, Buffer, strlen(Buffer));
@


1.19
log
@Remove the space after "Password:" in password prompts where echo is
turned off.  This is consistent with historic UNIX behavior.
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.18 2005/07/11 22:32:28 brad Exp $
d59 3
a61 7
    fprintf(stderr, "usage: pppctl [-v] [-p passwd] [-t n] "
            "Port|LocalSock [command[;command]...]\n");
    fprintf(stderr, "              -p passwd specifies your password\n");
    fprintf(stderr, "              -t n specifies a timeout of n"
            " seconds when connecting (default 2)\n");
    fprintf(stderr, "              -v tells pppctl to output all"
            " conversation\n");
@


1.18
log
@rev 1.32

Add IPv6 support to pppctl by using getaddrinfo() and trying each address
it returns. This allows it to connect to the server side again, which
has been listening on IPv6 addresses exclusively for more than 3 years.

From tjr FreeBSD

Fixes the issue noted in PR's 2780, 3570 and 3751.

ok deraadt@@
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.17 2004/05/24 09:30:11 jmc Exp $
d127 1
a127 1
                        if ((passwd = getpass("Password: ")) == NULL)
@


1.17
log
@- sort options
- sync usage()
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.16 2003/11/15 00:21:23 tedu Exp $
d197 26
a225 4
    struct servent *s;
    struct hostent *h;
    struct sockaddr *sock;
    struct sockaddr_in ifsin;
d227 1
a227 1
    int n, socksz, arg, fd, len, verbose, save_errno, hide1, hide1off, hide2;
a300 3
        sock = (struct sockaddr *)&ifsun;
        socksz = sizeof ifsun;

d314 8
d323 83
a405 81
        char *port, *host, *colon;
        int hlen;

        colon = strchr(argv[arg], ':');
        if (colon) {
            port = colon + 1;
            *colon = '\0';
            host = argv[arg];
        } else {
            port = argv[arg];
            host = "127.0.0.1";
        }
        sock = (struct sockaddr *)&ifsin;
        socksz = sizeof ifsin;
        hlen = strlen(host);

        memset(&ifsin, '\0', sizeof ifsin);
        if (strspn(host, "0123456789.") == hlen) {
            if (!inet_aton(host, &ifsin.sin_addr)) {
                warnx("cannot translate %s", host);
                return 1;
            }
        } else if ((h = gethostbyname(host)) == 0) {
            warnx("cannot resolve %s", host);
            return 1;
        }
        else
            ifsin.sin_addr.s_addr = *(u_long *)h->h_addr_list[0];

        if (colon)
            *colon = ':';

        if (strspn(port, "0123456789") == strlen(port))
            ifsin.sin_port = htons(atoi(port));
        else if (s = getservbyname(port, "tcp"), !s) {
            warnx("%s isn't a valid port or service!", port);
            usage();
        }
        else
            ifsin.sin_port = s->s_port;

        ifsin.sin_len = sizeof(ifsin);
        ifsin.sin_family = AF_INET;

        if (fd = socket(AF_INET, SOCK_STREAM, 0), fd < 0) {
            warnx("cannot create internet socket");
            return 2;
        }
    }

    TimedOut = 0;
    if (TimeoutVal) {
        act.sa_handler = Timeout;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        sigaction(SIGALRM, &act, &oact);
        alarm(TimeoutVal);
    }

    if (connect(fd, sock, socksz) < 0) {
        if (TimeoutVal) {
            save_errno = errno;
            alarm(0);
            sigaction(SIGALRM, &oact, 0);
            errno = save_errno;
        }
        if (TimedOut)
            warnx("timeout: cannot connect to socket %s", argv[arg]);
        else {
            if (errno)
                warn("cannot connect to socket %s", argv[arg]);
            else
                warnx("cannot connect to socket %s", argv[arg]);
        }
        close(fd);
        return 3;
    }

    if (TimeoutVal) {
        alarm(0);
        sigaction(SIGALRM, &oact, 0);
@


1.16
log
@check getpass for NULL.  from Jared Yanovich.  ok otto@@
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.15 2003/10/31 08:48:16 otto Exp $
d59 1
a59 1
    fprintf(stderr, "usage: pppctl [-v] [-t n] [-p passwd] "
d61 3
a65 3
    fprintf(stderr, "              -t n specifies a timeout of n"
            " seconds when connecting (default 2)\n");
    fprintf(stderr, "              -p passwd specifies your password\n");
@


1.15
log
@New libedit api changes.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.14 2003/09/07 07:50:29 tedu Exp $
d123 1
a123 1
                 /* a password is required ! */
d127 2
a128 1
                        passwd = getpass("Password: ");
@


1.14
log
@fix crash.  pr3454 from openbsd at rukh.net.  ok deraadt@@
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.13 2003/08/19 23:57:09 deraadt Exp $
a400 1
#ifdef __NetBSD__
a401 2
#endif

a409 1
#ifdef __NetBSD__
a411 4
#else
                history(hist, H_EVENT, size);
                edit = el_init("pppctl", stdin, stdout);
#endif
a423 1
#ifdef __NetBSD__
a424 3
#else
                        history(hist, H_ENTER, l);
#endif
@


1.13
log
@use poll instead; millert fgsch ok
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.12 2003/04/14 03:14:17 deraadt Exp $
d169 1
a169 1
    pfd[1].events = POLLIN;
@


1.12
log
@strlcpy, obvious
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.11 2003/04/04 20:28:57 deraadt Exp $
d50 1
d164 1
a164 2
    struct timeval t;
    fd_set f;
d168 3
a170 4
    FD_ZERO(&f);
    FD_SET(data, &f);
    t.tv_sec = t.tv_usec = 0;
    if (select(data+1, &f, NULL, NULL, &t) > 0) {
@


1.11
log
@strlcat; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.10 2003/04/04 20:25:06 deraadt Exp $
d383 1
a383 1
            strcpy(Command+len, " ");
@


1.10
log
@strlcpy and snprintf; various people ok
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.9 2002/07/02 16:09:05 brian Exp $
d455 1
a455 1
                    strcat(Buffer, "\n");
@


1.9
log
@Remove whitespace at eol
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.8 2001/08/18 22:14:39 brian Exp $
d127 1
a127 1
                    sprintf(Buffer, "passwd %s\n", passwd);
d148 1
a148 1
            strcpy(Buffer, Buffer + flush);
d289 1
a289 1
        strcpy(ifsun.sun_path, argv[arg]);
d382 4
a385 2
        if (len && len < sizeof(Command)-1)
            strcpy(Command+len++, " ");
d453 1
a453 1
                    strcpy(Buffer, start);
@


1.8
log
@Deal with snprintf() return codes properly
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.7 2001/03/22 17:16:27 brian Exp $
d223 1
a223 1
    
d241 1
a241 1
    
d475 1
a475 1
    
@


1.7
log
@Grok NetBSD's version of el_init() (#ifdef NetBSD only)
Submitted by: martin.hopkins@@insignia.com
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.6 2001/03/05 01:02:55 brian Exp $
d205 1
a205 1
    int socksz, arg, fd, len, verbose, save_errno, hide1, hide1off, hide2;
d260 1
a260 1
            pos += snprintf(title + pos, sizeof title - pos, "%s%s",
d263 1
a263 1
            pos += snprintf(title + pos, sizeof title - pos, " %.*s",
d265 5
@


1.6
log
@Avoid a core-dump under NetBSD
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.5 2000/08/16 12:02:40 brian Exp $
d409 1
d412 1
a413 1
                edit = el_init("pppctl", stdin, stdout);
@


1.5
log
@If the -p option is used, use setproctitle() to hide it's argument
(a password) asap.
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.4 1999/08/02 17:00:25 brian Exp $
d395 4
d408 1
a408 1
                history(hist, NULL, H_SETSIZE, size);
d426 1
a426 1
                        history(hist, NULL, H_ENTER, l);
@


1.4
log
@Use err[x]/warn[x] and improve error reporting
Submitted by: charnier@@FreeBSD.org
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.3 1999/04/26 08:53:33 brian Exp $
d41 3
d205 1
a205 1
    int socksz, arg, fd, len, verbose, save_errno;
d212 1
d229 10
a238 1
                        passwd = (start[1] ? start + 1 : argv[++arg]);
d252 20
@


1.3
log
@Add support for NetBSD (history() from libedit is different).
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.2 1999/01/31 12:25:04 brian Exp $
d38 1
d53 1
a53 1
Usage()
d55 1
a55 1
    fprintf(stderr, "Usage: pppctl [-v] [ -t n ] [ -p passwd ] "
d62 1
a62 1
    return 1;
d202 1
a202 1
    int socksz, arg, fd, len, verbose, err;
d230 1
a230 1
                        return Usage();
d238 1
a238 1
        return Usage();
d247 1
a247 1
            fprintf(stderr, "%s: Path too long\n", argv[arg]);
d254 1
a254 1
            fprintf(stderr, "Cannot create local domain socket\n");
d277 1
a277 1
                fprintf(stderr, "Cannot translate %s\n", host);
d281 1
a281 1
            fprintf(stderr, "Cannot resolve %s\n", host);
d293 2
a294 2
            fprintf(stderr, "%s isn't a valid port or service!\n", port);
            return Usage();
d303 1
a303 1
            fprintf(stderr, "Cannot create internet socket\n");
a317 1
        err = errno;
d319 1
d322 9
a331 8
        if (TimedOut) {
            fputs("Timeout: ", stderr);
            err = 0;
        }
        fprintf(stderr, "Cannot connect to socket %s", argv[arg]);
        if (err)
            fprintf(stderr, ": %s", strerror(err));
        fputc('\n', stderr);
d427 1
a427 1
            fprintf(stderr, "ppp is not responding\n");
@


1.2
log
@Mention the error when we fail to connect().
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.1 1998/08/31 00:22:31 brian Exp $
d368 3
d372 1
a372 1

d386 3
d390 1
@


1.1
log
@Upgrade ppp to version 2.0

This adds a number of features including:
o Multilink
o Callback (including CBCP)
o DNS negotiation (client & server)
o Easy to configure masquerading/packet aliasing
o Any number of diagnostic socket connections (limits DOS attacks)
o Sticky routes (ppp updates the routing table when the IP number is changed)

See the file README.changes for things that effect current
configurations.
@
text
@d26 1
a26 1
 *	$Id: pppctl.c,v 1.16 1998/03/22 00:43:04 brian Exp $
d201 1
a201 1
    int socksz, arg, fd, len, verbose;
d317 1
d322 1
a322 1
        if (TimedOut)
d324 6
a329 1
        fprintf(stderr, "Cannot connect to socket %s\n", argv[arg]);
@

