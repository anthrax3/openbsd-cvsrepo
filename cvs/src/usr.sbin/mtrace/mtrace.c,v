head	1.38;
access;
symbols
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.29.0.6
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.4
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.28.0.8
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.6
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.26.0.10
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.8
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.6
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.4
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.6
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2017.01.21.08.33.51;	author krw;	state Exp;
branches;
next	1.37;
commitid	xpTSTOgSQRGS1RiF;

1.37
date	2016.08.03.23.37.25;	author krw;	state Exp;
branches;
next	1.36;
commitid	xbW8xS6moZaxo3Q8;

1.36
date	2016.08.03.23.22.48;	author krw;	state Exp;
branches;
next	1.35;
commitid	T8VcMmRDcqtqHk8n;

1.35
date	2016.03.07.00.16.35;	author mmcc;	state Exp;
branches;
next	1.34;
commitid	grsLdZbIc45gnMxt;

1.34
date	2015.11.18.15.34.34;	author mmcc;	state Exp;
branches;
next	1.33;
commitid	EImKPKpk7D1fD6u6;

1.33
date	2015.01.16.06.40.18;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Uu5nFG3wCl0LACBb;

1.32
date	2013.11.24.00.54.12;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.04.24.06.00.35;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.20.19.21.46;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2011.09.21.21.05.40;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.27.23.59.53;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.04.16.20.13.13;	author sobrado;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.18.21.16.03;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.03.05.42.05;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.01.18.32.20;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.16.01.11.09;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.26.20.48.29;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.26.01.17.12;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.23.09.19.18;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.19.22.19.07;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.19.19.08.38;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.26.19.47.09;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.13.09.09.49;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.09.02.12.15;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.14.21.35.01;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.02.19.06.39;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.19.19.39.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.17.19.42.37;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.28.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.10.20.30.46;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.05.22.32.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.27.20.34.36;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.25.08.42.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.09.03.24.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.21.00.33.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.11.19.15.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.01.46.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.48;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: mtrace.c,v 1.37 2016/08/03 23:37:25 krw Exp $	*/
/*	$NetBSD: mtrace.c,v 1.5 1995/12/10 10:57:15 mycroft Exp $	*/

/*
 * mtrace.c
 *
 * This tool traces the branch of a multicast tree from a source to a
 * receiver for a particular multicast group and gives statistics
 * about packet rate and loss for each hop along the path.  It can
 * usually be invoked just as
 *
 *	mtrace source
 *
 * to trace the route from that source to the local host for a default
 * group when only the route is desired and not group-specific packet
 * counts.  See the usage line for more complex forms.
 *
 *
 * Released 4 Apr 1995.  This program was adapted by Steve Casner
 * (USC/ISI) from a prototype written by Ajit Thyagarajan (UDel and
 * Xerox PARC).  It attempts to parallel in command syntax and output
 * format the unicast traceroute program written by Van Jacobson (LBL)
 * for the parts where that makes sense.
 *
 * Copyright (c) 1998-2001.
 * The University of Southern California/Information Sciences Institute.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <netdb.h>
#include <sys/time.h>
#include <string.h>
#include <poll.h>
#include <ctype.h>
#include <sys/ioctl.h>
#include "defs.h"
#include <arpa/inet.h>
#include <stdarg.h>
#ifdef SUNOS5
#include <sys/systeminfo.h>
#endif
#include <ifaddrs.h>
#include <err.h>

#define DEFAULT_TIMEOUT	3	/* How long to wait before retrying requests */
#define DEFAULT_RETRIES 3	/* How many times to try */
#define MAXHOPS UNREACHABLE	/* Don't need more hops than max metric */
#define UNICAST_TTL 255		/* TTL for unicast response */
#define MULTICAST_TTL1 64	/* Default TTL for multicast query/response */
#define MULTICAST_TTL_INC 32	/* TTL increment for increase after timeout */
#define MULTICAST_TTL_MAX 192	/* Maximum TTL allowed (protect low-BW links */

struct resp_buf {
    u_long qtime;		/* Time query was issued */
    u_long rtime;		/* Time response was received */
    int	len;			/* Number of reports or length of data */
    struct igmp igmp;		/* IGMP header */
    union {
	struct {
	    struct tr_query q;		/* Query/response header */
	    struct tr_resp r[MAXHOPS];	/* Per-hop reports */
	} t;
	char d[MAX_DVMRP_DATA_LEN];	/* Neighbor data */
    } u;
} base, incr[2];

#define qhdr u.t.q
#define resps u.t.r
#define ndata u.d

char names[MAXHOPS][40];
int reset[MAXHOPS];			/* To get around 3.4 bug, ... */
int swaps[MAXHOPS];			/* To get around 3.6 bug, ... */

int timeout = DEFAULT_TIMEOUT;
int nqueries = DEFAULT_RETRIES;
int numeric = FALSE;
int debug = 0;
int passive = FALSE;
int multicast = FALSE;
int statint = 10;
int verbose = 0;

u_int32_t defgrp;			/* Default group if not specified */
u_int32_t query_cast;			/* All routers multicast addr */
u_int32_t resp_cast;			/* Mtrace response multicast addr */

u_int32_t lcl_addr = 0;			/* This host address, in NET order */
u_int32_t dst_netmask;			/* netmask to go with qdst */

/*
 * Query/response parameters, all initialized to zero and set later
 * to default values or from options.
 */
u_int32_t qsrc = 0;		/* Source address in the query */
u_int32_t qgrp = 0;		/* Group address in the query */
u_int32_t qdst = 0;		/* Destination (receiver) address in query */
u_char qno  = 0;		/* Max number of hops to query */
u_int32_t raddr = 0;		/* Address where response should be sent */
int    qttl = 0;		/* TTL for the query packet */
u_char rttl = 0;		/* TTL for the response packet */
u_int32_t gwy = 0;		/* User-supplied last-hop router address */
u_int32_t tdst = 0;		/* Address where trace is sent (last-hop) */

vifi_t  numvifs;		/* to keep loader happy */
				/* (see kern.c) */

char *			inet_name(u_int32_t addr);
u_int32_t			host_addr(char *name);
/* u_int is promoted u_char */
char *			proto_type(u_int type);
char *			flag_type(u_int type);

u_int32_t			get_netmask(int s, u_int32_t dst);
int			get_ttl(struct resp_buf *buf);
int			t_diff(u_long a, u_long b);
u_long			fixtime(u_long time);
int			send_recv(u_int32_t dst, int type, int code,
			    int tries, struct resp_buf *save);
char *			print_host(u_int32_t addr);
char *			print_host2(u_int32_t addr1, u_int32_t addr2);
void			print_trace(int index, struct resp_buf *buf);
int			what_kind(struct resp_buf *buf, char *why);
char *			scale(int *hop);
void			stat_line(struct tr_resp *r, struct tr_resp *s,
			    int have_next, int *res);
void			fixup_stats(struct resp_buf *base,
			    struct resp_buf *prev, struct resp_buf *new);
int			print_stats(struct resp_buf *base,
			    struct resp_buf *prev, struct resp_buf *new);
void			check_vif_state(void);
u_long			byteswap(u_long v);

int			main(int argc, char *argv[]);



char   *
inet_name(u_int32_t addr)
{
    struct hostent *e;

    e = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET);

    return e ? e->h_name : "?";
}


u_int32_t
host_addr(char *name)
{
    struct hostent *e = NULL;
    u_int32_t  addr;
    int	i, dots = 3;
    char	buf[40];
    char	*ip = name;
    char	*op = buf;

    /*
     * Undo BSD's favor -- take fewer than 4 octets as net/subnet address
     * if the name is all numeric.
     */
    for (i = sizeof(buf) - 7; i > 0; --i) {
	if (*ip == '.')
		--dots;
	else if (*ip == '\0')
		break;
	else if (!isdigit((unsigned char)*ip))
		dots = 0;  /* Not numeric, don't add zeroes */
	*op++ = *ip++;
    }
    for (i = 0; i < dots; ++i) {
	*op++ = '.';
	*op++ = '0';
    }
    *op = '\0';

    if (dots <= 0) e = gethostbyname(name);
    if (e) memcpy((char *)&addr, e->h_addr_list[0], e->h_length);
    else {
	addr = inet_addr(buf);
	if (addr == -1) {
	    addr = 0;
	    printf("Could not parse %s as host name or address\n", name);
	}
    }
    return addr;
}


char *
proto_type(u_int type)
{
    static char buf[80];

    switch (type) {
      case PROTO_DVMRP:
	return ("DVMRP");
      case PROTO_MOSPF:
	return ("MOSPF");
      case PROTO_PIM:
	return ("PIM");
      case PROTO_CBT:
	return ("CBT");
      default:
	(void) snprintf(buf, sizeof buf, "Unknown protocol code %d", type);
	return (buf);
    }
}


char *
flag_type(u_int type)
{
    static char buf[80];

    switch (type) {
      case TR_NO_ERR:
	return ("");
      case TR_WRONG_IF:
	return ("Wrong interface");
      case TR_PRUNED:
	return ("Prune sent upstream");
      case TR_OPRUNED:
	return ("Output pruned");
      case TR_SCOPED:
	return ("Hit scope boundary");
      case TR_NO_RTE:
	return ("No route");
      case TR_OLD_ROUTER:
	return ("Next router no mtrace");
      case TR_NO_FWD:
	return ("Not forwarding");
      case TR_NO_SPACE:
	return ("No space in packet");
      default:
	(void) snprintf(buf, sizeof buf, "Unknown error code %d", type);
	return (buf);
    }
}

/*
 * If destination is on a local net, get the netmask, else set the
 * netmask to all ones.  There are two side effects: if the local
 * address was not explicitly set, and if the destination is on a
 * local net, use that one; in either case, verify that the local
 * address is valid.
 */

u_int32_t
get_netmask(int s, u_int32_t dst)
{
    u_int32_t if_addr, if_mask;
    u_int32_t retval = 0xFFFFFFFF;
    int found = FALSE;
    struct ifaddrs *ifap, *ifa;

    if (getifaddrs(&ifap) != 0) {
	perror("getifaddrs");
	return (retval);
    }
    for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
	if (ifa->ifa_addr->sa_family != AF_INET)
             continue;
	if_addr = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
	if_mask = ((struct sockaddr_in *)ifa->ifa_netmask)->sin_addr.s_addr;
	if ((dst & if_mask) == (if_addr & if_mask)) {
	    retval = if_mask;
	    if (lcl_addr == 0)
		lcl_addr = if_addr;
	}
	if (lcl_addr == if_addr)
	    found = TRUE;
    }
    if (!found && lcl_addr != 0) {
	printf("Interface address is not valid\n");
	exit(1);
    }
    freeifaddrs(ifap);
    return (retval);
}


int
get_ttl(struct resp_buf *buf)
{
    int rno;
    struct tr_resp *b;
    u_int ttl;

    if (buf && (rno = buf->len) > 0) {
	b = buf->resps + rno - 1;
	ttl = b->tr_fttl;

	while (--rno > 0) {
	    --b;
	    if (ttl < b->tr_fttl) ttl = b->tr_fttl;
	    else ++ttl;
	}
	ttl += MULTICAST_TTL_INC;
	if (ttl < MULTICAST_TTL1) ttl = MULTICAST_TTL1;
	if (ttl > MULTICAST_TTL_MAX) ttl = MULTICAST_TTL_MAX;
	return (ttl);
    } else return(MULTICAST_TTL1);
}

/*
 * Calculate the difference between two 32-bit NTP timestamps and return
 * the result in milliseconds.
 */
int
t_diff(u_long a, u_long b)
{
    int d = a - b;

    return ((d * 125) >> 13);
}

/*
 * Fixup for incorrect time format in 3.3 mrouted.
 * This is possible because (JAN_1970 mod 64K) is quite close to 32K,
 * so correct and incorrect times will be far apart.
 */
u_long
fixtime(u_long time)
{
    if (abs((int)(time-base.qtime)) > 0x3FFFFFFF)
        time = ((time & 0xFFFF0000) + (JAN_1970 << 16)) +
	       ((time & 0xFFFF) << 14) / 15625;
    return (time);
}

/*
 * Swap bytes for poor little-endian machines that don't byte-swap
 */
u_long
byteswap(u_long v)
{
    return ((v << 24) | ((v & 0xff00) << 8) |
	    ((v >> 8) & 0xff00) | (v >> 24));
}

int
send_recv(u_int32_t dst, int type, int code, int tries, struct resp_buf *save)
{
    struct timeval tq, tr, tv;
    struct ip *ip;
    struct igmp *igmp;
    struct tr_query *query, *rquery;
    int ipdatalen, iphdrlen, igmpdatalen;
    u_int32_t local, group;
    int datalen;
    struct pollfd pfd[1];
    int count, recvlen, dummy = 0;
    int len;
    int i;

    if (type == IGMP_MTRACE_QUERY) {
	group = qgrp;
	datalen = sizeof(struct tr_query);
    } else {
	group = htonl(MROUTED_LEVEL);
	datalen = 0;
    }
    if (IN_MULTICAST(ntohl(dst))) local = lcl_addr;
    else local = INADDR_ANY;

    /*
     * If the reply address was not explicitly specified, start off
     * with the unicast address of this host.  Then, if there is no
     * response after trying half the tries with unicast, switch to
     * the standard multicast reply address.  If the TTL was also not
     * specified, set a multicast TTL and if needed increase it for the
     * last quarter of the tries.
     */
    query = (struct tr_query *)(send_buf + MIN_IP_HEADER_LEN + IGMP_MINLEN);
    query->tr_raddr = raddr ? raddr : multicast ? resp_cast : lcl_addr;
    query->tr_rttl  = rttl ? rttl :
      IN_MULTICAST(ntohl(query->tr_raddr)) ? get_ttl(save) : UNICAST_TTL;
    query->tr_src   = qsrc;
    query->tr_dst   = qdst;

    for (i = tries ; i > 0; --i) {
	if (tries == nqueries && raddr == 0) {
	    if (i == ((nqueries + 1) >> 1)) {
		query->tr_raddr = resp_cast;
		if (rttl == 0) query->tr_rttl = get_ttl(save);
	    }
	    if (i <= ((nqueries + 3) >> 2) && rttl == 0) {
		query->tr_rttl += MULTICAST_TTL_INC;
		if (query->tr_rttl > MULTICAST_TTL_MAX)
		  query->tr_rttl = MULTICAST_TTL_MAX;
	    }
	}

	/*
	 * Change the qid for each request sent to avoid being confused
	 * by duplicate responses
	 */
	query->tr_qid  = arc4random();

	/*
	 * Set timer to calculate delays, then send query
	 */
	gettimeofday(&tq, 0);
	send_igmp(local, dst, type, code, group, datalen);

	/*
	 * Wait for response, discarding false alarms
	 */
	pfd[0].fd = igmp_socket;
	pfd[0].events = POLLIN;
	while (TRUE) {
	    gettimeofday(&tv, 0);
	    tv.tv_sec = tq.tv_sec + timeout - tv.tv_sec;
	    tv.tv_usec = tq.tv_usec - tv.tv_usec;
	    if (tv.tv_usec < 0) tv.tv_usec += 1000000L, --tv.tv_sec;
	    if (tv.tv_sec < 0) tv.tv_sec = tv.tv_usec = 0;

	    count = poll(pfd, 1, tv.tv_sec * 1000);

	    if (count < 0) {
		if (errno != EINTR) perror("poll");
		continue;
	    } else if (count == 0) {
		printf("* ");
		fflush(stdout);
		break;
	    }

	    gettimeofday(&tr, 0);
	    recvlen = recvfrom(igmp_socket, recv_buf, RECV_BUF_SIZE,
			       0, NULL, &dummy);

	    if (recvlen <= 0) {
		if (recvlen && errno != EINTR) perror("recvfrom");
		continue;
	    }

	    if (recvlen < sizeof(struct ip)) {
		fprintf(stderr,
			"packet too short (%u bytes) for IP header", recvlen);
		continue;
	    }
	    ip = (struct ip *) recv_buf;
	    if (ip->ip_p == 0)	/* ignore cache creation requests */
		continue;

	    iphdrlen = ip->ip_hl << 2;
	    ipdatalen = ntohs(ip->ip_len) - iphdrlen;
	    if (iphdrlen + ipdatalen != recvlen) {
		fprintf(stderr,
			"packet shorter (%u bytes) than hdr+data len (%u+%u)\n",
			recvlen, iphdrlen, ipdatalen);
		continue;
	    }

	    igmp = (struct igmp *) (recv_buf + iphdrlen);
	    igmpdatalen = ipdatalen - IGMP_MINLEN;
	    if (igmpdatalen < 0) {
		fprintf(stderr,
			"IP data field too short (%u bytes) for IGMP from %s\n",
			ipdatalen, inet_fmt(ip->ip_src.s_addr, s1));
		continue;
	    }

	    switch (igmp->igmp_type) {

	      case IGMP_DVMRP:
		if (igmp->igmp_code != DVMRP_NEIGHBORS2) continue;
		len = igmpdatalen;
		/*
		 * Accept DVMRP_NEIGHBORS2 response if it comes from the
		 * address queried or if that address is one of the local
		 * addresses in the response.
		 */
		if (ip->ip_src.s_addr != dst) {
		    u_int32_t *p = (u_int32_t *)(igmp + 1);
		    u_int32_t *ep = p + (len >> 2);
		    while (p < ep) {
			u_int32_t laddr = *p++;
			int n = ntohl(*p++) & 0xFF;
			if (laddr == dst) {
			    ep = p + 1;		/* ensure p < ep after loop */
			    break;
			}
			p += n;
		    }
		    if (p >= ep) continue;
		}
		break;

	      case IGMP_MTRACE_QUERY:	    /* For backward compatibility with 3.3 */
	      case IGMP_MTRACE_REPLY:
		if (igmpdatalen <= QLEN) continue;
		if ((igmpdatalen - QLEN)%RLEN) {
		    printf("packet with incorrect datalen\n");
		    continue;
		}

		/*
		 * Ignore responses that don't match query.
		 */
		rquery = (struct tr_query *)(igmp + 1);
		if (rquery->tr_qid != query->tr_qid) continue;
		if (rquery->tr_src != qsrc) continue;
		if (rquery->tr_dst != qdst) continue;
		len = (igmpdatalen - QLEN)/RLEN;

		/*
		 * Ignore trace queries passing through this node when
		 * mtrace is run on an mrouter that is in the path
		 * (needed only because IGMP_MTRACE_QUERY is accepted above
		 * for backward compatibility with multicast release 3.3).
		 */
		if (igmp->igmp_type == IGMP_MTRACE_QUERY) {
		    struct tr_resp *r = (struct tr_resp *)(rquery+1) + len - 1;
		    u_int32_t smask;

		    VAL_TO_MASK(smask, r->tr_smask);
		    if (len < code && (r->tr_inaddr & smask) != (qsrc & smask)
			&& r->tr_rmtaddr != 0 && !(r->tr_rflags & 0x80))
		      continue;
		}

		/*
		 * A match, we'll keep this one.
		 */
		if (len > code) {
		    fprintf(stderr,
			    "Num hops received (%d) exceeds request (%d)\n",
			    len, code);
		}
		rquery->tr_raddr = query->tr_raddr;	/* Insure these are */
		rquery->tr_rttl = query->tr_rttl;	/* as we sent them */
		break;

	      default:
		continue;
	    }

	    /*
	     * Most of the sanity checking done at this point.
	     * Return this packet we have been waiting for.
	     */
	    if (save) {
		save->qtime = ((tq.tv_sec + JAN_1970) << 16) +
			      (tq.tv_usec << 10) / 15625;
		save->rtime = ((tr.tv_sec + JAN_1970) << 16) +
			      (tr.tv_usec << 10) / 15625;
		save->len = len;
		bcopy((char *)igmp, (char *)&save->igmp, ipdatalen);
	    }
	    return (recvlen);
	}
    }
    return (0);
}

/*
 * Most of this code is duplicated elsewhere.  I'm not sure if
 * the duplication is absolutely required or not.
 *
 * Ideally, this would keep track of ongoing statistics
 * collection and print out statistics.  (& keep track
 * of h-b-h traces and only print the longest)  For now,
 * it just snoops on what traces it can.
 */
void
passive_mode(void)
{
    struct timeval tr;
    struct ip *ip;
    struct igmp *igmp;
    struct tr_resp *r;
    int ipdatalen, iphdrlen, igmpdatalen;
    int len, recvlen, dummy = 0;
    u_int32_t smask;

    if (raddr) {
	if (IN_MULTICAST(ntohl(raddr))) k_join(raddr, INADDR_ANY);
    } else k_join(htonl(0xE0000120), INADDR_ANY);

    while (1) {
	recvlen = recvfrom(igmp_socket, recv_buf, RECV_BUF_SIZE,
			   0, NULL, &dummy);
	gettimeofday(&tr,0);

	if (recvlen <= 0) {
	    if (recvlen && errno != EINTR) perror("recvfrom");
	    continue;
	}

	if (recvlen < sizeof(struct ip)) {
	    fprintf(stderr,
		    "packet too short (%u bytes) for IP header", recvlen);
	    continue;
	}
	ip = (struct ip *) recv_buf;
	if (ip->ip_p == 0)	/* ignore cache creation requests */
	    continue;

	iphdrlen = ip->ip_hl << 2;
	ipdatalen = ntohs(ip->ip_len) - iphdrlen;
	if (iphdrlen + ipdatalen != recvlen) {
	    fprintf(stderr,
		    "packet shorter (%u bytes) than hdr+data len (%u+%u)\n",
		    recvlen, iphdrlen, ipdatalen);
	    continue;
	}

	igmp = (struct igmp *) (recv_buf + iphdrlen);
	igmpdatalen = ipdatalen - IGMP_MINLEN;
	if (igmpdatalen < 0) {
	    fprintf(stderr,
		    "IP data field too short (%u bytes) for IGMP from %s\n",
		    ipdatalen, inet_fmt(ip->ip_src.s_addr, s1));
	    continue;
	}

	switch (igmp->igmp_type) {

	  case IGMP_MTRACE_QUERY:	    /* For backward compatibility with 3.3 */
	  case IGMP_MTRACE_REPLY:
	    if (igmpdatalen < QLEN) continue;
	    if ((igmpdatalen - QLEN)%RLEN) {
		printf("packet with incorrect datalen\n");
		continue;
	    }

	    len = (igmpdatalen - QLEN)/RLEN;

	    break;

	  default:
	    continue;
	}

	base.qtime = ((tr.tv_sec + JAN_1970) << 16) +
		      (tr.tv_usec << 10) / 15625;
	base.rtime = ((tr.tv_sec + JAN_1970) << 16) +
		      (tr.tv_usec << 10) / 15625;
	base.len = len;
	bcopy((char *)igmp, (char *)&base.igmp, ipdatalen);
	/*
	 * If the user specified which traces to monitor,
	 * only accept traces that correspond to the
	 * request
	 */
	if ((qsrc != 0 && qsrc != base.qhdr.tr_src) ||
	    (qdst != 0 && qdst != base.qhdr.tr_dst) ||
	    (qgrp != 0 && qgrp != igmp->igmp_group.s_addr))
	    continue;

	printf("Mtrace from %s to %s via group %s (mxhop=%d)\n",
		inet_fmt(base.qhdr.tr_dst, s1), inet_fmt(base.qhdr.tr_src, s2),
		inet_fmt(igmp->igmp_group.s_addr, s3), igmp->igmp_code);
	if (len == 0)
	    continue;
	printf("  0  ");
	print_host(base.qhdr.tr_dst);
	printf("\n");
	print_trace(1, &base);
	r = base.resps + base.len - 1;
	VAL_TO_MASK(smask, r->tr_smask);
	if ((r->tr_inaddr & smask) == (base.qhdr.tr_src & smask)) {
	    printf("%3d  ", -(base.len+1));
	    print_host(base.qhdr.tr_src);
	    printf("\n");
	} else if (r->tr_rmtaddr != 0) {
	    printf("%3d  ", -(base.len+1));
	    what_kind(&base, r->tr_rflags == TR_OLD_ROUTER ?
				   "doesn't support mtrace"
				 : "is the next hop");
	}
	printf("\n");
    }
}

char *
print_host(u_int32_t addr)
{
    return print_host2(addr, 0);
}

/*
 * On some routers, one interface has a name and the other doesn't.
 * We always print the address of the outgoing interface, but can
 * sometimes get the name from the incoming interface.  This might be
 * confusing but should be slightly more helpful than just a "?".
 */
char *
print_host2(u_int32_t addr1, u_int32_t addr2)
{
    char *name;

    if (numeric) {
	printf("%s", inet_fmt(addr1, s1));
	return ("");
    }
    name = inet_name(addr1);
    if (*name == '?' && *(name + 1) == '\0' && addr2 != 0)
	name = inet_name(addr2);
    printf("%s (%s)", name, inet_fmt(addr1, s1));
    return (name);
}

/*
 * Print responses as received (reverse path from dst to src)
 */
void
print_trace(int index, struct resp_buf *buf)
{
    struct tr_resp *r;
    char *name;
    int i;
    int hop;
    char *ms;

    i = abs(index);
    r = buf->resps + i - 1;

    for (; i <= buf->len; ++i, ++r) {
	if (index > 0) printf("%3d  ", -i);
	name = print_host2(r->tr_outaddr, r->tr_inaddr);
	printf("  %s  thresh^ %d", proto_type(r->tr_rproto), r->tr_fttl);
	if (verbose) {
	    hop = t_diff(fixtime(ntohl(r->tr_qarr)), buf->qtime);
	    ms = scale(&hop);
	    printf("  %d%s", hop, ms);
	}
	printf("  %s\n", flag_type(r->tr_rflags));
	memcpy(names[i-1], name, sizeof(names[0]) - 1);
	names[i-1][sizeof(names[0])-1] = '\0';
    }
}

/*
 * See what kind of router is the next hop
 */
int
what_kind(struct resp_buf *buf, char *why)
{
    u_int32_t smask;
    int retval;
    int hops = buf->len;
    struct tr_resp *r = buf->resps + hops - 1;
    u_int32_t next = r->tr_rmtaddr;

    retval = send_recv(next, IGMP_DVMRP, DVMRP_ASK_NEIGHBORS2, 1, &incr[0]);
    print_host(next);
    if (retval) {
	u_int32_t version = ntohl(incr[0].igmp.igmp_group.s_addr);
	u_int32_t *p = (u_int32_t *)incr[0].ndata;
	u_int32_t *ep = p + (incr[0].len >> 2);
	char *type = "";
	retval = 0;
	switch (version & 0xFF) {
	  case 1:
	    type = "proteon/mrouted ";
	    retval = 1;
	    break;

	  case 2:
	  case 3:
	    if (((version >> 8) & 0xFF) < 3) retval = 1;
				/* Fall through */
	  case 4:
	    type = "mrouted ";
	    break;

	  case 10:
	    type = "cisco ";
	}
	printf(" [%s%d.%d] %s\n",
	       type, version & 0xFF, (version >> 8) & 0xFF,
	       why);
	VAL_TO_MASK(smask, r->tr_smask);
	while (p < ep) {
	    u_int32_t laddr = *p++;
	    int flags = (ntohl(*p) & 0xFF00) >> 8;
	    int n = ntohl(*p++) & 0xFF;
	    if (!(flags & (DVMRP_NF_DOWN | DVMRP_NF_DISABLED)) &&
		 (laddr & smask) == (qsrc & smask)) {
		printf("%3d  ", -(hops+2));
		print_host(qsrc);
		printf("\n");
		return 1;
	    }
	    p += n;
	}
	return retval;
    }
    printf(" %s\n", why);
    return 0;
}


char *
scale(int *hop)
{
    if (*hop > -1000 && *hop < 10000) return (" ms");
    *hop /= 1000;
    if (*hop > -1000 && *hop < 10000) return (" s ");
    return ("s ");
}

/*
 * Calculate and print one line of packet loss and packet rate statistics.
 * Checks for count of all ones from mrouted 2.3 that doesn't have counters.
 */
#define NEITHER 0
#define INS     1
#define OUTS    2
#define BOTH    3
void
stat_line(struct tr_resp *r, struct tr_resp *s, int have_next, int *rst)
{
    int timediff = (fixtime(ntohl(s->tr_qarr)) -
			 fixtime(ntohl(r->tr_qarr))) >> 16;
    int v_lost, v_pct;
    int g_lost, g_pct;
    int v_out = ntohl(s->tr_vifout) - ntohl(r->tr_vifout);
    int g_out = ntohl(s->tr_pktcnt) - ntohl(r->tr_pktcnt);
    int v_pps, g_pps;
    char v_str[8], g_str[8];
    int have = NEITHER;
    int res = *rst;

    if (timediff == 0) timediff = 1;
    v_pps = v_out / timediff;
    g_pps = g_out / timediff;

    if ((v_out && (s->tr_vifout != 0xFFFFFFFF && s->tr_vifout != 0)) ||
		 (r->tr_vifout != 0xFFFFFFFF && r->tr_vifout != 0))
	    have |= OUTS;

    if (have_next) {
	--r,  --s,  --rst;
	if ((s->tr_vifin != 0xFFFFFFFF && s->tr_vifin != 0) ||
	    (r->tr_vifin != 0xFFFFFFFF && r->tr_vifin != 0))
	  have |= INS;
	if (*rst)
	  res = 1;
    }

    switch (have) {
      case BOTH:
	v_lost = v_out - (ntohl(s->tr_vifin) - ntohl(r->tr_vifin));
	if (v_out) v_pct = (v_lost * 100 + (v_out >> 1)) / v_out;
	else v_pct = 0;
	if (-100 < v_pct && v_pct < 101 && v_out > 10)
	  snprintf(v_str, sizeof v_str, "%3d", v_pct);
	else memcpy(v_str, " --", 4);

	g_lost = g_out - (ntohl(s->tr_pktcnt) - ntohl(r->tr_pktcnt));
	if (g_out) g_pct = (g_lost * 100 + (g_out >> 1))/ g_out;
	else g_pct = 0;
	if (-100 < g_pct && g_pct < 101 && g_out > 10)
	  snprintf(g_str, sizeof g_str, "%3d", g_pct);
	else memcpy(g_str, " --", 4);

	printf("%6d/%-5d=%s%%%4d pps",
	       v_lost, v_out, v_str, v_pps);
	if (res)
	    printf("\n");
	else
	    printf("%6d/%-5d=%s%%%4d pps\n",
		   g_lost, g_out, g_str, g_pps);
	break;

      case INS:
	v_out = ntohl(s->tr_vifin) - ntohl(r->tr_vifin);
	v_pps = v_out / timediff;
	/* Fall through */

      case OUTS:
	printf("       %-5d     %4d pps",
	       v_out, v_pps);
	if (res)
	    printf("\n");
	else
	    printf("       %-5d     %4d pps\n",
		   g_out, g_pps);
	break;

      case NEITHER:
	printf("\n");
	break;
    }

    if (debug > 2) {
	printf("\t\t\t\tv_in: %u ", ntohl(s->tr_vifin));
	printf("v_out: %u ", ntohl(s->tr_vifout));
	printf("pkts: %u\n", ntohl(s->tr_pktcnt));
	printf("\t\t\t\tv_in: %u ", ntohl(r->tr_vifin));
	printf("v_out: %u ", ntohl(r->tr_vifout));
	printf("pkts: %u\n", ntohl(r->tr_pktcnt));
	printf("\t\t\t\tv_in: %u ", ntohl(s->tr_vifin)-ntohl(r->tr_vifin));
	printf("v_out: %u ", ntohl(s->tr_vifout) - ntohl(r->tr_vifout));
	printf("pkts: %u ", ntohl(s->tr_pktcnt) - ntohl(r->tr_pktcnt));
	printf("time: %d\n", timediff);
	printf("\t\t\t\tres: %d\n", res);
    }
}

/*
 * A fixup to check if any pktcnt has been reset, and to fix the
 * byteorder bugs in mrouted 3.6 on little-endian machines.
 */
void
fixup_stats(struct resp_buf *base, struct resp_buf *prev, struct resp_buf *new)
{
    int rno = base->len;
    struct tr_resp *b = base->resps + rno;
    struct tr_resp *p = prev->resps + rno;
    struct tr_resp *n = new->resps + rno;
    int *r = reset + rno;
    int *s = swaps + rno;
    int res;

    /* Check for byte-swappers */
    while (--rno >= 0) {
	--n; --p; --b; --s;
	if (*s || abs(ntohl(n->tr_vifout) - ntohl(p->tr_vifout)) > 100000) {
	    /* This host sends byteswapped reports; swap 'em */
	    if (!*s) {
		*s = 1;
		b->tr_qarr = byteswap(b->tr_qarr);
		b->tr_vifin = byteswap(b->tr_vifin);
		b->tr_vifout = byteswap(b->tr_vifout);
		b->tr_pktcnt = byteswap(b->tr_pktcnt);
	    }

	    n->tr_qarr = byteswap(n->tr_qarr);
	    n->tr_vifin = byteswap(n->tr_vifin);
	    n->tr_vifout = byteswap(n->tr_vifout);
	    n->tr_pktcnt = byteswap(n->tr_pktcnt);
	}
    }

    rno = base->len;
    b = base->resps + rno;
    p = prev->resps + rno;
    n = new->resps + rno;

    while (--rno >= 0) {
	--n; --p; --b; --r;
	res = ((ntohl(n->tr_pktcnt) < ntohl(b->tr_pktcnt)) ||
	       (ntohl(n->tr_pktcnt) < ntohl(p->tr_pktcnt)));
	if (debug > 2)
	    printf("\t\tr=%d, res=%d\n", *r, res);
	if (*r) {
	    if (res || *r > 1) {
		/*
		 * This router appears to be a 3.4 with that nasty ol'
		 * neighbor version bug, which causes it to constantly
		 * reset.  Just nuke the statistics for this node, and
		 * don't even bother giving it the benefit of the
		 * doubt from now on.
		 */
		p->tr_pktcnt = b->tr_pktcnt = n->tr_pktcnt;
		r++;
	    } else {
		/*
		 * This is simply the situation that the original
		 * fixup_stats was meant to deal with -- that a
		 * 3.3 or 3.4 router deleted a cache entry while
		 * traffic was still active.
		 */
		*r = 0;
		break;
	    }
	} else
	    *r = res;
    }

    if (rno < 0) return;

    rno = base->len;
    b = base->resps + rno;
    p = prev->resps + rno;

    while (--rno >= 0) (--b)->tr_pktcnt = (--p)->tr_pktcnt;
}

/*
 * Print responses with statistics for forward path (from src to dst)
 */
int
print_stats(struct resp_buf *base, struct resp_buf *prev, struct resp_buf *new)
{
    int rtt, hop;
    char *ms;
    u_int32_t smask;
    int rno = base->len - 1;
    struct tr_resp *b = base->resps + rno;
    struct tr_resp *p = prev->resps + rno;
    struct tr_resp *n = new->resps + rno;
    int *r = reset + rno;
    u_long resptime = new->rtime;
    u_long qarrtime = fixtime(ntohl(n->tr_qarr));
    u_int ttl = n->tr_fttl;
    int first = (base == prev);

    VAL_TO_MASK(smask, b->tr_smask);
    printf("  Source        Response Dest");
    printf("    Packet Statistics For     Only For Traffic\n");
    printf("%-15s %-15s  All Multicast Traffic     From %s\n",
	   ((b->tr_inaddr & smask) == (qsrc & smask)) ? s1 : "   * * *       ",
	   inet_fmt(base->qhdr.tr_raddr, s2), inet_fmt(qsrc, s1));
    rtt = t_diff(resptime, new->qtime);
    ms = scale(&rtt);
    printf("     %c       __/  rtt%5d%s    Lost/Sent = Pct  Rate       To %s\n",
	   first ? 'v' : '|', rtt, ms, inet_fmt(qgrp, s2));
    if (!first) {
	hop = t_diff(resptime, qarrtime);
	ms = scale(&hop);
	printf("     v      /     hop%5d%s", hop, ms);
	printf("    ---------------------     --------------------\n");
    }
    if (debug > 2) {
	printf("\t\t\t\tv_in: %u ", ntohl(n->tr_vifin));
	printf("v_out: %u ", ntohl(n->tr_vifout));
	printf("pkts: %u\n", ntohl(n->tr_pktcnt));
	printf("\t\t\t\tv_in: %u ", ntohl(b->tr_vifin));
	printf("v_out: %u ", ntohl(b->tr_vifout));
	printf("pkts: %u\n", ntohl(b->tr_pktcnt));
	printf("\t\t\t\tv_in: %u ", ntohl(n->tr_vifin) - ntohl(b->tr_vifin));
	printf("v_out: %u ", ntohl(n->tr_vifout) - ntohl(b->tr_vifout));
	printf("pkts: %u\n", ntohl(n->tr_pktcnt) - ntohl(b->tr_pktcnt));
	printf("\t\t\t\treset: %d\n", *r);
    }

    while (TRUE) {
	if ((n->tr_inaddr != b->tr_inaddr) || (p->tr_inaddr != b->tr_inaddr))
	  return 1;		/* Route changed */

	if ((n->tr_inaddr != n->tr_outaddr))
	  printf("%-15s\n", inet_fmt(n->tr_inaddr, s1));
	printf("%-15s %-14s %s\n", inet_fmt(n->tr_outaddr, s1), names[rno],
		 flag_type(n->tr_rflags));

	if (rno-- < 1) break;

	printf("     %c     ^      ttl%5d   ", first ? 'v' : '|', ttl);
	stat_line(p, n, TRUE, r);
	if (!first) {
	    resptime = qarrtime;
	    qarrtime = fixtime(ntohl((n-1)->tr_qarr));
	    hop = t_diff(resptime, qarrtime);
	    ms = scale(&hop);
	    printf("     v     |      hop%5d%s", hop, ms);
	    stat_line(b, n, TRUE, r);
	}

	--b, --p, --n, --r;
	if (ttl < n->tr_fttl) ttl = n->tr_fttl;
	else ++ttl;
    }

    printf("     %c      \\__   ttl%5d   ", first ? 'v' : '|', ttl);
    stat_line(p, n, FALSE, r);
    if (!first) {
	hop = t_diff(qarrtime, new->qtime);
	ms = scale(&hop);
	printf("     v         \\  hop%5d%s", hop, ms);
	stat_line(b, n, FALSE, r);
    }
    printf("%-15s %s\n", inet_fmt(qdst, s1), inet_fmt(lcl_addr, s2));
    printf("  Receiver      Query Source\n\n");
    return 0;
}


/***************************************************************************
 *	main
 ***************************************************************************/

int
main(int argc, char *argv[])
{
    int udp;
    struct sockaddr_in addr;
    int addrlen = sizeof(addr);
    int recvlen;
    struct timeval tv;
    struct resp_buf *prev, *new;
    struct tr_resp *r;
    u_int32_t smask;
    int rno;
    int hops, nexthop, tries;
    u_int32_t lastout = 0;
    int numstats = 1;
    int waittime;
    uid_t uid;

    init_igmp();

    uid = getuid();
    if (setresuid(uid, uid, uid) == -1)
	err(1, "setresuid");

    argv++, argc--;
    if (argc == 0) goto usage;

    while (argc > 0 && *argv[0] == '-') {
	char *p = *argv++;  argc--;
	p++;
	do {
	    char c = *p++;
	    char *arg = NULL;
	    if (isdigit((unsigned char)*p)) {
		arg = p;
		p = "";
	    } else if (argc > 0) arg = argv[0];
	    switch (c) {
	      case 'd':			/* Unlisted debug print option */
		if (arg && isdigit((unsigned char)*arg)) {
		    debug = atoi(arg);
		    if (debug < 0) debug = 0;
		    if (debug > 3) debug = 3;
		    if (arg == argv[0]) argv++, argc--;
		    break;
		} else
		    goto usage;
	      case 'M':			/* Use multicast for response */
		multicast = TRUE;
		break;
	      case 'l':			/* Loop updating stats indefinitely */
		numstats = 3153600;
		break;
	      case 'n':			/* Don't reverse map host addresses */
		numeric = TRUE;
		break;
	      case 'p':			/* Passive listen for traces */
		passive = TRUE;
		break;
	      case 'v':			/* Verbosity */
		verbose = TRUE;
		break;
	      case 's':			/* Short form, don't wait for stats */
		numstats = 0;
		break;
	      case 'w':			/* Time to wait for packet arrival */
		if (arg && isdigit((unsigned char)*arg)) {
		    timeout = atoi(arg);
		    if (timeout < 1) timeout = 1;
		    if (arg == argv[0]) argv++, argc--;
		    break;
		} else
		    goto usage;
	      case 'm':			/* Max number of hops to trace */
		if (arg && isdigit((unsigned char)*arg)) {
		    qno = atoi(arg);
		    if (qno > MAXHOPS) qno = MAXHOPS;
		    else if (qno < 1) qno = 0;
		    if (arg == argv[0]) argv++, argc--;
		    break;
		} else
		    goto usage;
	      case 'q':			/* Number of query retries */
		if (arg && isdigit((unsigned char)*arg)) {
		    nqueries = atoi(arg);
		    if (nqueries < 1) nqueries = 1;
		    if (arg == argv[0]) argv++, argc--;
		    break;
		} else
		    goto usage;
	      case 'g':			/* Last-hop gateway (dest of query) */
		if (arg && (gwy = host_addr(arg))) {
		    if (arg == argv[0]) argv++, argc--;
		    break;
		} else
		    goto usage;
	      case 't':			/* TTL for query packet */
		if (arg && isdigit((unsigned char)*arg)) {
		    qttl = atoi(arg);
		    if (qttl < 1) qttl = 1;
		    rttl = qttl;
		    if (arg == argv[0]) argv++, argc--;
		    break;
		} else
		    goto usage;
	      case 'r':			/* Dest for response packet */
		if (arg && (raddr = host_addr(arg))) {
		    if (arg == argv[0]) argv++, argc--;
		    break;
		} else
		    goto usage;
	      case 'i':			/* Local interface address */
		if (arg && (lcl_addr = host_addr(arg))) {
		    if (arg == argv[0]) argv++, argc--;
		    break;
		} else
		    goto usage;
	      case 'S':			/* Stat accumulation interval */
		if (arg && isdigit((unsigned char)*arg)) {
		    statint = atoi(arg);
		    if (statint < 1) statint = 1;
		    if (arg == argv[0]) argv++, argc--;
		    break;
		} else
		    goto usage;
	      default:
		goto usage;
	    }
	} while (*p);
    }

    if (argc > 0 && (qsrc = host_addr(argv[0]))) {          /* Source of path */
	if (IN_MULTICAST(ntohl(qsrc))) goto usage;
	argv++, argc--;
	if (argc > 0 && (qdst = host_addr(argv[0]))) {      /* Dest of path */
	    argv++, argc--;
	    if (argc > 0 && (qgrp = host_addr(argv[0]))) {  /* Path via group */
		argv++, argc--;
	    }
	    if (IN_MULTICAST(ntohl(qdst))) {
		u_int32_t temp = qdst;
		qdst = qgrp;
		qgrp = temp;
		if (IN_MULTICAST(ntohl(qdst))) goto usage;
	    } else if (qgrp && !IN_MULTICAST(ntohl(qgrp))) goto usage;
	}
    }

    if (passive) {
	passive_mode();
	return(0);
    }

    if (argc > 0 || qsrc == 0) {
usage:	printf("\
usage: mtrace [-lMnpsv] [-g gateway] [-i if_addr] [-m max_hops] [-q nqueries]\n\
              [-r host] [-S stat_int] [-t ttl] [-w waittime] source [receiver]\n\
	      [group]\n");
	exit(1);
    }

    /*
     * Set useful defaults for as many parameters as possible.
     */

    defgrp = htonl(0xE0020001);		/* MBone Audio (224.2.0.1) */
    query_cast = htonl(0xE0000002);	/* All routers multicast addr */
    resp_cast = htonl(0xE0000120);	/* Mtrace response multicast addr */
    if (qgrp == 0) qgrp = defgrp;

    /*
     * Get default local address for multicasts to use in setting defaults.
     */
    memset(&addr, 0, sizeof addr);
    addr.sin_family = AF_INET;
    addr.sin_len = sizeof(addr);
    addr.sin_addr.s_addr = qgrp;
    addr.sin_port = htons(2000);	/* Any port above 1024 will do */

    if (((udp = socket(AF_INET, SOCK_DGRAM, 0)) < 0) ||
	(connect(udp, (struct sockaddr *) &addr, sizeof(addr)) < 0) ||
	getsockname(udp, (struct sockaddr *) &addr, &addrlen) < 0) {
	perror("Determining local address");
	exit(1);
    }

#ifdef SUNOS5
   /*
     * SunOS 5.X prior to SunOS 2.6, getsockname returns 0 for udp socket.
     * This call to sysinfo will return the hostname.
     * If the default multicast interface (set with the route
     * for 224.0.0.0) is not the same as the hostname,
     * mtrace -i [if_addr] will have to be used.
     */
    if (addr.sin_addr.s_addr == 0) {
	char myhostname[HOST_NAME_MAX+1];
	struct hostent *hp;
	int error;

	error = sysinfo(SI_HOSTNAME, myhostname, sizeof(myhostname));
	if (error == -1) {
	    perror("Getting my hostname");
	    exit(1);
	}

	hp = gethostbyname(myhostname);
	if (hp == NULL || hp->h_addrtype != AF_INET ||
	    hp->h_length != sizeof(addr.sin_addr)) {
	    perror("Finding IP address for my hostname");
	    exit(1);
	}

	memcpy((char *)&addr.sin_addr.s_addr, hp->h_addr, hp->h_length);
    }
#endif

    /*
     * Default destination for path to be queried is the local host.
     */
    if (qdst == 0) qdst = lcl_addr ? lcl_addr : addr.sin_addr.s_addr;
    dst_netmask = get_netmask(udp, qdst);
    close(udp);
    if (lcl_addr == 0) lcl_addr = addr.sin_addr.s_addr;

    /*
     * Protect against unicast queries to mrouted versions that might crash.
     */
    if (gwy && !IN_MULTICAST(ntohl(gwy)))
      if (send_recv(gwy, IGMP_DVMRP, DVMRP_ASK_NEIGHBORS2, 1, &incr[0])) {
	  int version = ntohl(incr[0].igmp.igmp_group.s_addr) & 0xFFFF;
	  if (version == 0x0303 || version == 0x0503) {
	    printf("Don't use -g to address an mrouted 3.%d, it might crash\n",
		   (version >> 8) & 0xFF);
	    exit(0);
	}
      }

    printf("Mtrace from %s to %s via group %s\n",
	   inet_fmt(qsrc, s1), inet_fmt(qdst, s2), inet_fmt(qgrp, s3));

    if ((qdst & dst_netmask) == (qsrc & dst_netmask)) {
	printf("Source & receiver are directly connected, no path to trace\n");
	exit(0);
    }

    /*
     * If the response is to be a multicast address, make sure we
     * are listening on that multicast address.
     */
    if (raddr) {
	if (IN_MULTICAST(ntohl(raddr))) k_join(raddr, lcl_addr);
    } else k_join(resp_cast, lcl_addr);

    /*
     * If the destination is on the local net, the last-hop router can
     * be found by multicast to the all-routers multicast group.
     * Otherwise, use the group address that is the subject of the
     * query since by definition the last-hop router will be a member.
     * Set default TTLs for local remote multicasts.
     */
    restart:

    if (gwy == 0)
      if ((qdst & dst_netmask) == (lcl_addr & dst_netmask)) tdst = query_cast;
      else tdst = qgrp;
    else tdst = gwy;

    if (IN_MULTICAST(ntohl(tdst))) {
      k_set_loop(1);	/* If I am running on a router, I need to hear this */
      if (tdst == query_cast) k_set_ttl(qttl ? qttl : 1);
      else k_set_ttl(qttl ? qttl : MULTICAST_TTL1);
    }

    /*
     * Try a query at the requested number of hops or MAXHOPS if unspecified.
     */
    if (qno == 0) {
	hops = MAXHOPS;
	tries = 1;
	printf("Querying full reverse path... ");
	fflush(stdout);
    } else {
	hops = qno;
	tries = nqueries;
	printf("Querying reverse path, maximum %d hops... ", qno);
	fflush(stdout);
    }
    base.rtime = 0;
    base.len = 0;

    recvlen = send_recv(tdst, IGMP_MTRACE_QUERY, hops, tries, &base);

    /*
     * If the initial query was successful, print it.  Otherwise, if
     * the query max hop count is the default of zero, loop starting
     * from one until there is no response for four hops.  The extra
     * hops allow getting past an mtrace-capable mrouter that can't
     * send multicast packets because all phyints are disabled.
     */
    if (recvlen) {
	printf("\n  0  ");
	print_host(qdst);
	printf("\n");
	print_trace(1, &base);
	r = base.resps + base.len - 1;
	if (r->tr_rflags == TR_OLD_ROUTER || r->tr_rflags == TR_NO_SPACE ||
		qno != 0) {
	    printf("%3d  ", -(base.len+1));
	    what_kind(&base, r->tr_rflags == TR_OLD_ROUTER ?
				   "doesn't support mtrace"
				 : "is the next hop");
	} else {
	    VAL_TO_MASK(smask, r->tr_smask);
	    if ((r->tr_inaddr & smask) == (qsrc & smask)) {
		printf("%3d  ", -(base.len+1));
		print_host(qsrc);
		printf("\n");
	    }
	}
    } else if (qno == 0) {
	printf("switching to hop-by-hop:\n  0  ");
	print_host(qdst);
	printf("\n");

	for (hops = 1, nexthop = 1; hops <= MAXHOPS; ++hops) {
	    printf("%3d  ", -hops);
	    fflush(stdout);

	    /*
	     * After a successful first hop, try switching to the unicast
	     * address of the last-hop router instead of multicasting the
	     * trace query.  This should be safe for mrouted versions 3.3
	     * and 3.5 because there is a long route timeout with metric
	     * infinity before a route disappears.  Switching to unicast
	     * reduces the amount of multicast traffic and avoids a bug
	     * with duplicate suppression in mrouted 3.5.
	     */
	    if (hops == 2 && gwy == 0 &&
		(recvlen = send_recv(lastout, IGMP_MTRACE_QUERY, hops, 1, &base)))
	      tdst = lastout;
	    else recvlen = send_recv(tdst, IGMP_MTRACE_QUERY, hops, nqueries, &base);

	    if (recvlen == 0) {
		if (hops == 1) break;
		if (hops == nexthop) {
		    if (what_kind(&base, "didn't respond")) {
			/* the ask_neighbors determined that the
			 * not-responding router is the first-hop. */
			break;
		    }
		} else if (hops < nexthop + 3) {
		    printf("\n");
		} else {
		    printf("...giving up\n");
		    break;
		}
		continue;
	    }
	    r = base.resps + base.len - 1;
	    if (base.len == hops &&
		(hops == 1 || (base.resps+nexthop-2)->tr_outaddr == lastout)) {
		if (hops == nexthop) {
		    print_trace(-hops, &base);
		} else {
		    printf("\nResuming...\n");
		    print_trace(nexthop, &base);
		}
	    } else {
		if (base.len < hops) {
		    /*
		     * A shorter trace than requested means a fatal error
		     * occurred along the path, or that the route changed
		     * to a shorter one.
		     *
		     * If the trace is longer than the last one we received,
		     * then we are resuming from a skipped router (but there
		     * is still probably a problem).
		     *
		     * If the trace is shorter than the last one we
		     * received, then the route must have changed (and
		     * there is still probably a problem).
		     */
		    if (nexthop <= base.len) {
			printf("\nResuming...\n");
			print_trace(nexthop, &base);
		    } else if (nexthop > base.len + 1) {
			hops = base.len;
			printf("\nRoute must have changed...\n");
			print_trace(1, &base);
		    }
		} else {
		    /*
		     * The last hop address is not the same as it was;
		     * the route probably changed underneath us.
		     */
		    hops = base.len;
		    printf("\nRoute must have changed...\n");
		    print_trace(1, &base);
		}
	    }
	    lastout = r->tr_outaddr;

	    if (base.len < hops ||
		r->tr_rmtaddr == 0 ||
		(r->tr_rflags & 0x80)) {
		VAL_TO_MASK(smask, r->tr_smask);
		if (r->tr_rmtaddr) {
		    if (hops != nexthop) {
			printf("\n%3d  ", -(base.len+1));
		    }
		    what_kind(&base, r->tr_rflags == TR_OLD_ROUTER ?
				"doesn't support mtrace" :
				"would be the next hop");
		    /* XXX could do segmented trace if TR_NO_SPACE */
		} else if (r->tr_rflags == TR_NO_ERR &&
			   (r->tr_inaddr & smask) == (qsrc & smask)) {
		    printf("%3d  ", -(hops + 1));
		    print_host(qsrc);
		    printf("\n");
		}
		break;
	    }

	    nexthop = hops + 1;
	}
    }

    if (base.rtime == 0) {
	printf("Timed out receiving responses\n");
	if (IN_MULTICAST(ntohl(tdst))) {
	  if (tdst == query_cast)
	    printf("Perhaps no local router has a route for source %s\n",
		   inet_fmt(qsrc, s1));
	  else
	    printf("Perhaps receiver %s is not a member of group %s,\n\
or no router local to it has a route for source %s,\n\
or multicast at ttl %d doesn't reach its last-hop router for that source\n",
		   inet_fmt(qdst, s2), inet_fmt(qgrp, s3), inet_fmt(qsrc, s1),
		   qttl ? qttl : MULTICAST_TTL1);
	}
	exit(1);
    }

    printf("Round trip time %d ms\n\n", t_diff(base.rtime, base.qtime));

    /*
     * Use the saved response which was the longest one received,
     * and make additional probes after delay to measure loss.
     */
    raddr = base.qhdr.tr_raddr;
    rttl = base.qhdr.tr_rttl;
    gettimeofday(&tv, 0);
    waittime = statint - (((tv.tv_sec + JAN_1970) & 0xFFFF) - (base.qtime >> 16));
    prev = &base;
    new = &incr[numstats&1];

    while (numstats--) {
	if (waittime < 1)
		printf("\n");
	else {
		printf("Waiting to accumulate statistics... ");
		fflush(stdout);
		sleep((unsigned int)waittime);
	}
	rno = base.len;
	recvlen = send_recv(tdst, IGMP_MTRACE_QUERY, rno, nqueries, new);

	if (recvlen == 0) {
	    printf("Timed out.\n");
	    exit(1);
	}

	if (rno != new->len) {
	    printf("Trace length doesn't match:\n");
	    /*
	     * XXX Should this trace result be printed, or is that
	     * too verbose?  Perhaps it should just say restarting.
	     * But if the path is changing quickly, this may be the
	     * only snapshot of the current path.  But, if the path
	     * is changing that quickly, does the current path really
	     * matter?
	     */
	    print_trace(1, new);
	    printf("Restarting.\n\n");
	    numstats++;
	    goto restart;
	}

	printf("Results after %d seconds:\n\n",
	       (int)((new->qtime - base.qtime) >> 16));
	fixup_stats(&base, prev, new);
	if (print_stats(&base, prev, new)) {
	    printf("Route changed:\n");
	    print_trace(1, new);
	    printf("Restarting.\n\n");
	    goto restart;
	}
	prev = new;
	new = &incr[numstats&1];
	waittime = statint;
    }

    /*
     * If the response was multicast back, leave the group
     */
    if (raddr) {
	if (IN_MULTICAST(ntohl(raddr)))	k_leave(raddr, lcl_addr);
    } else k_leave(resp_cast, lcl_addr);

    return (0);
}

void
check_vif_state(void)
{
    logit(LOG_WARNING, errno, "sendto");
}

/*
 * Log errors and other messages to stderr, according to the severity
 * of the message and the current debug level.  For errors of severity
 * LOG_ERR or worse, terminate the program.
 */
void
logit(int severity, int syserr, char *format, ...)
{
    va_list ap;

    switch (debug) {
	case 0: if (severity > LOG_WARNING) return;
	case 1: if (severity > LOG_NOTICE) return;
	case 2: if (severity > LOG_INFO  ) return;
	default:
	    if (severity == LOG_WARNING)
		fprintf(stderr, "warning - ");
	    va_start(ap, format);
	    vfprintf(stderr, format, ap);
	    va_end(ap);
	    if (syserr == 0)
		fprintf(stderr, "\n");
	    else if(syserr < sys_nerr)
		fprintf(stderr, ": %s\n", sys_errlist[syserr]);
	    else
		fprintf(stderr, ": errno %d\n", syserr);
    }
    if (severity <= LOG_ERR) exit(1);
}

/* dummies */
void accept_probe(u_int32_t src, u_int32_t dst, char *p, int datalen,
    u_int32_t level)
{
}

void accept_group_report(u_int32_t src, u_int32_t dst, u_int32_t group,
    int r_type)
{
}

void accept_neighbor_request2(u_int32_t src, u_int32_t dst)
{
}

void accept_report(u_int32_t src, u_int32_t dst, char *p, int datalen,
    u_int32_t level)
{
}

void accept_neighbor_request(u_int32_t src, u_int32_t dst)
{
}

void accept_prune(u_int32_t src, u_int32_t dst, char *p, int datalen)
{
}

void accept_graft(u_int32_t src, u_int32_t dst, char *p, int datalen)
{
}

void accept_g_ack(u_int32_t src, u_int32_t dst, char *p, int datalen)
{
}

void add_table_entry(u_int32_t origin, u_int32_t mcastgrp)
{
}

void accept_leave_message(u_int32_t src, u_int32_t dst, u_int32_t group)
{
}

void accept_mtrace(u_int32_t src, u_int32_t dst, u_int32_t group, char *data,
    u_int no, int datalen)
{
}

void accept_membership_query(u_int32_t src, u_int32_t dst, u_int32_t group,
    int tmo)
{
}

void accept_neighbors(u_int32_t src, u_int32_t dst, u_char *p, int datalen,
    u_int32_t level)
{
}

void accept_neighbors2(u_int32_t src, u_int32_t dst, u_char *p, int datalen,
    u_int32_t level)
{
}

void accept_info_request(u_int32_t src, u_int32_t dst, u_char *p, int datalen)
{
}

void accept_info_reply(u_int32_t src, u_int32_t dst, u_char *p, int datalen)
{
}
@


1.37
log
@Apply a warning fix from lukem@@NetBSD circa 1997 (more '()'), and
one from he@@NetBSD circa 1998 (more '{}').

Makes gcc happier.
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.36 2016/08/03 23:22:48 krw Exp $	*/
d12 1
a12 1
 * 	mtrace source
d24 1
a24 1
 * 
d173 1
a173 1
u_int32_t 
d264 1
a264 1
}    
d287 1
a287 1
	if (ifa->ifa_addr->sa_family != AF_INET) 
d976 1
a976 1
    	    printf("\t\tr=%d, res=%d\n", *r, res);
d1085 1
a1085 1
	   
d1291 1
a1291 1
    /*
d1302 1
a1302 1
    
d1350 1
a1350 1
     * If the response is to be a multicast address, make sure we 
d1389 1
a1389 1
	fflush(stdout); 
d1465 1
a1465 1
	    	if (hops == nexthop) {
@


1.36
log
@Apply fix from David Binderman via NetBSD. "Use all 3 of b, p, n
to determine if route changed".

Spotted by the Echelon team with AppChecker static analyzer.

NetBSD fix pointed out by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.35 2016/03/07 00:16:35 mmcc Exp $	*/
d858 1
a858 1
    if (v_out && (s->tr_vifout != 0xFFFFFFFF && s->tr_vifout != 0) ||
d1533 1
a1533 1
	if (IN_MULTICAST(ntohl(tdst)))
d1543 1
@


1.35
log
@(type *)0 -> NULL

ok sha256@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.34 2015/11/18 15:34:34 mmcc Exp $	*/
d1060 1
a1060 1
	if ((n->tr_inaddr != b->tr_inaddr) || (n->tr_inaddr != b->tr_inaddr))
@


1.34
log
@Remove memory.h include.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.33 2015/01/16 06:40:18 deraadt Exp $	*/
d176 1
a176 1
    struct hostent *e = (struct hostent *)0;
d457 1
a457 1
			       0, (struct sockaddr *)0, &dummy);
d610 1
a610 1
			   0, (struct sockaddr *)0, &dummy);
d1136 1
a1136 1
	    char *arg = (char *) 0;
@


1.33
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.32 2013/11/24 00:54:12 deraadt Exp $	*/
a55 1
#include <memory.h>
@


1.32
log
@fairly obvious ctype cleanup dealing with argv
ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.31 2013/04/24 06:00:35 deraadt Exp $	*/
a1279 1
#if (defined(BSD) && (BSD >= 199103))
a1280 1
#endif
d1300 1
a1300 1
	char myhostname[MAXHOSTNAMELEN];
@


1.31
log
@kill srandom(); ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.30 2013/04/20 19:21:46 deraadt Exp $	*/
d189 6
a194 3
	if (*ip == '.') --dots;
	else if (*ip == '\0') break;
	else if (!isdigit(*ip)) dots = 0;  /* Not numeric, don't add zeroes */
d1138 1
a1138 1
	    if (isdigit(*p)) {
d1144 1
a1144 1
		if (arg && isdigit(*arg)) {
d1171 1
a1171 1
		if (arg && isdigit(*arg)) {
d1179 1
a1179 1
		if (arg && isdigit(*arg)) {
d1188 1
a1188 1
		if (arg && isdigit(*arg)) {
d1202 1
a1202 1
		if (arg && isdigit(*arg)) {
d1223 1
a1223 1
		if (arg && isdigit(*arg)) {
@


1.30
log
@remove one of the last stupid (unsigned) casts in the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.29 2011/09/21 21:05:40 jsg Exp $	*/
d422 1
a422 5
#ifdef SYSV    
	query->tr_qid  = ((u_int32_t)lrand48() >> 8);
#else
	query->tr_qid  = ((u_int32_t)random() >> 8);
#endif
a1117 1
    int seed;
a1326 11

    /*
     * Initialize the seed for random query identifiers.
     */
    gettimeofday(&tv, 0);
    seed = tv.tv_usec ^ lcl_addr;
#ifdef SYSV    
    srand48(seed);
#else
    srandom(seed);
#endif
@


1.29
log
@fix missing err.h includes
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.28 2009/10/27 23:59:53 deraadt Exp $	*/
d1576 2
a1577 1
	if (waittime < 1) printf("\n");
d1579 3
a1581 3
	    printf("Waiting to accumulate statistics... ");
	    fflush(stdout);
	    sleep((unsigned)waittime);
@


1.28
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.27 2009/04/16 20:13:13 sobrado Exp $	*/
d68 1
@


1.27
log
@fix a few more typos found by spell(1); rectify a double "with" pointed out
by jmc@@ while looking at this diff.

ok jmc@@, reyk@@ (for the hostapd part)
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.26 2007/02/18 21:16:03 jmc Exp $	*/
a52 5

#ifndef lint
static char rcsid[] =
    "@@(#) $Id: mtrace.c,v 1.26 2007/02/18 21:16:03 jmc Exp $";
#endif
@


1.26
log
@tidy up synopsis and usage; from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.25 2005/05/03 05:42:05 djm Exp $	*/
d56 1
a56 1
    "@@(#) $Id: mtrace.c,v 1.25 2005/05/03 05:42:05 djm Exp $";
d1158 1
a1158 1
	      case 'M':			/* Use multicast for reponse */
@


1.25
log
@setresuid; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mtrace.c,v 1.24 2004/08/01 18:32:20 deraadt Exp $	*/
d56 1
a56 1
    "@@(#) $Id: mtrace.c,v 1.24 2004/08/01 18:32:20 deraadt Exp $";
d1266 3
a1268 2
Usage: mtrace [-Mlnps] [-w wait] [-m max_hops] [-q nqueries] [-g gateway]\n\
              [-S statint] [-t ttl] [-r resp_dest] [-i if_addr] source [receiver] [group]\n");
@


1.24
log
@ansi cleanup; khalek@@linuxgamers.net
@
text
@d1 1
a1 1
/*	$OpenBSD: $	*/
d56 1
a56 1
    "@@(#) $Id: mtrace.c,v 1.23 2004/03/16 01:11:09 tedu Exp $";
d1127 1
d1130 4
a1133 2
    seteuid(getuid());
    setuid(getuid());
@


1.23
log
@errno is not specified to be int, but something from errno.h.  ok millert@@
@
text
@d1 1
d56 1
a56 1
    "@@(#) $Id: mtrace.c,v 1.22 2004/02/26 20:48:29 tedu Exp $";
d168 1
a168 2
inet_name(addr)
    u_int32_t  addr;
d179 1
a179 2
host_addr(name)
    char   *name;
d218 1
a218 2
proto_type(type)
    u_int type;
d239 1
a239 2
flag_type(type)
    u_int type;
d277 1
a277 3
get_netmask(s, dst)
    int s;
    u_int32_t dst;
d311 1
a311 2
get_ttl(buf)
    struct resp_buf *buf;
d338 1
a338 2
t_diff(a, b)
    u_long a, b;
d351 1
a351 2
fixtime(time)
    u_long time;
d363 1
a363 2
byteswap(v)
    u_long v;
d370 1
a370 4
send_recv(dst, type, code, tries, save)
    u_int32_t dst;
    int type, code, tries;
    struct resp_buf *save;
d711 1
a711 2
print_host(addr)
    u_int32_t addr;
d723 1
a723 2
print_host2(addr1, addr2)
    u_int32_t addr1, addr2;
d742 1
a742 3
print_trace(index, buf)
    int index;
    struct resp_buf *buf;
d772 1
a772 3
what_kind(buf, why)
    struct resp_buf *buf;
    char *why;
d830 1
a830 2
scale(hop)
    int *hop;
d847 1
a847 4
stat_line(r, s, have_next, rst)
    struct tr_resp *r, *s;
    int have_next;
    int *rst;
d942 1
a942 2
fixup_stats(base, prev, new)
    struct resp_buf *base, *prev, *new;
d1021 1
a1021 2
print_stats(base, prev, new)
    struct resp_buf *base, *prev, *new;
d1111 1
a1111 3
main(argc, argv)
int argc;
char *argv[];
d1631 1
a1631 1
check_vif_state()
d1667 2
a1668 4
void accept_probe(src, dst, p, datalen, level)
	u_int32_t src, dst, level;
	char *p;
	int datalen;
d1671 3
a1673 3
void accept_group_report(src, dst, group, r_type)
	u_int32_t src, dst, group;
	int r_type;
d1676 2
a1677 2
void accept_neighbor_request2(src, dst)
	u_int32_t src, dst;
d1680 3
a1682 4
void accept_report(src, dst, p, datalen, level)
	u_int32_t src, dst, level;
	char *p;
	int datalen;
d1685 2
a1686 2
void accept_neighbor_request(src, dst)
	u_int32_t src, dst;
d1689 2
a1690 4
void accept_prune(src, dst, p, datalen)
	u_int32_t src, dst;
	char *p;
	int datalen;
d1693 2
a1694 4
void accept_graft(src, dst, p, datalen)
	u_int32_t src, dst;
	char *p;
	int datalen;
d1697 2
a1698 4
void accept_g_ack(src, dst, p, datalen)
	u_int32_t src, dst;
	char *p;
	int datalen;
d1701 2
a1702 2
void add_table_entry(origin, mcastgrp)
	u_int32_t origin, mcastgrp;
d1705 2
a1706 2
void accept_leave_message(src, dst, group)
	u_int32_t src, dst, group;
d1709 3
a1711 5
void accept_mtrace(src, dst, group, data, no, datalen)
	u_int32_t src, dst, group;
	char *data;
	u_int no;
	int datalen;
d1714 3
a1716 3
void accept_membership_query(src, dst, group, tmo)
	u_int32_t src, dst, group;
	int tmo;
d1719 3
a1721 4
void accept_neighbors(src, dst, p, datalen, level)
	u_int32_t src, dst, level;
	u_char *p;
	int datalen;
d1724 3
a1726 4
void accept_neighbors2(src, dst, p, datalen, level)
	u_int32_t src, dst, level;
	u_char *p;
	int datalen;
d1729 2
a1730 4
void accept_info_request(src, dst, p, datalen)
	u_int32_t src, dst;
	u_char *p;
	int datalen;
d1733 2
a1734 4
void accept_info_reply(src, dst, p, datalen)
	u_int32_t src, dst;
	u_char *p;
	int datalen;
@


1.22
log
@fix datalen, from Esben Norby.  ok deraadt itojun
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.21 2003/11/26 01:17:12 millert Exp $";
a134 4
#ifndef SYSV
extern long random(void);
#endif
extern int errno;
@


1.21
log
@Replace log() with logit() since ISO C reserves log() for the math
library and gcc 3.x will complain.  Replacement name taken from NetBSD.
espie@@ OK.
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.20 2003/09/23 09:19:18 matthieu Exp $";
d496 1
a496 1
	    ipdatalen = ntohs(ip->ip_len);
d650 1
a650 1
	ipdatalen = ntohs(ip->ip_len);
@


1.20
log
@ignore address families other than AF_INET in get_netmask().
ok cedric@@
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.19 2003/08/19 22:19:07 itojun Exp $";
d1663 1
a1663 1
    log(LOG_WARNING, errno, "sendto");
d1672 1
a1672 1
log(int severity, int syserr, char *format, ...)
@


1.19
log
@rewrite SIOCGIFCONF into getifaddrs.  deraadt ok
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.18 2003/08/19 19:08:38 deraadt Exp $";
d298 2
@


1.18
log
@convert to poll; ok dhartmei
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.17 2003/06/26 19:47:09 deraadt Exp $";
d71 1
a287 4
    unsigned int i;
    char ifbuf[5000];
    struct ifconf ifc;
    struct ifreq *ifr;
d291 1
d293 2
a294 4
    ifc.ifc_buf = ifbuf;
    ifc.ifc_len = sizeof(ifbuf);
    if (ioctl(s, SIOCGIFCONF, (char *) &ifc) < 0) {
	perror("ioctl (SIOCGIFCONF)");
d297 7
a303 10
    for (i = 0; i < ifc.ifc_len; ) {
	ifr = (struct ifreq *)((char *)ifc.ifc_req + i);
	i += sizeof(ifr->ifr_name) + ifr->ifr_addr.sa_len;
	if_addr = ((struct sockaddr_in *)&(ifr->ifr_addr))->sin_addr.s_addr;
	if (ioctl(s, SIOCGIFNETMASK, (char *)ifr) >= 0) {
	    if_mask = ((struct sockaddr_in *)&(ifr->ifr_addr))->sin_addr.s_addr;
	    if ((dst & if_mask) == (if_addr & if_mask)) {
		retval = if_mask;
		if (lcl_addr == 0) lcl_addr = if_addr;
	    }
d305 2
a306 1
	if (lcl_addr == if_addr) found = TRUE;
d312 1
@


1.17
log
@strict proto cleanups
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.16 2003/03/13 09:09:49 deraadt Exp $";
d62 1
a390 1
    fd_set  fds;
d398 1
d460 2
a462 4
	    FD_ZERO(&fds);
	    if (igmp_socket >= FD_SETSIZE)
		log(LOG_ERR, 0, "descriptor too big");
	    FD_SET(igmp_socket, &fds);
d469 1
a469 2
	    count = select(igmp_socket + 1, &fds, (fd_set *)0, (fd_set *)0,
			   &tv);
d472 1
a472 1
		if (errno != EINTR) perror("select");
@


1.16
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.15 2002/08/09 02:12:15 itojun Exp $";
d134 1
a134 1
extern long random();
d162 1
d621 1
a621 1
passive_mode()
@


1.15
log
@avoid dynamically-generated string to printf.  die if fd_set overruns.
from xs@@kittenz.org
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.14 2002/06/14 21:35:01 todd Exp $";
d235 1
a235 1
	(void) sprintf(buf, "Unknown protocol code %d", type);
d267 1
a267 1
	(void) sprintf(buf, "Unknown error code %d", type);
d913 1
a913 1
	  sprintf(v_str, "%3d", v_pct);
d920 1
a920 1
	  sprintf(g_str, "%3d", g_pct);
@


1.14
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.13 2002/06/02 19:06:39 deraadt Exp $";
d460 2
a629 2
    init_igmp();

a1678 1
    char    fmt[100];
d1685 2
a1686 3
	    fmt[0] = '\0';
	    if (severity == LOG_WARNING) strcat(fmt, "warning - ");
	    strncat(fmt, format, 80);
d1688 1
a1688 1
	    vfprintf(stderr, fmt, ap);
@


1.13
log
@missing sockaddr inits; ok itojun
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.12 2002/02/19 19:39:40 millert Exp $";
d412 1
a412 1
     * If the reply address was not explictly specified, start off
d1333 1
a1333 1
     * If the default multicast interfface (set with the route
@


1.12
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.11 2002/02/17 19:42:37 millert Exp $";
d1314 1
@


1.11
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.10 2002/02/16 21:28:05 millert Exp $";
a65 1
#ifdef __STDC__
a66 3
#else
#include <varargs.h>
#endif
a1673 1
#ifdef __STDC__
d1677 2
a1678 17
	va_list ap;
	char    fmt[100];

	va_start(ap, format);
#else
/*VARARGS3*/
void 
log(severity, syserr, format, va_alist)
	int     severity, syserr;
	char   *format;
	va_dcl
{
	va_list ap;
	char    fmt[100];

	va_start(ap);
#endif
d1688 1
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.9 2001/12/10 20:30:46 deraadt Exp $";
d152 2
a153 2
int			send_recv __P((u_int32_t dst, int type, int code,
					int tries, struct resp_buf *save));
d159 6
a164 8
void			stat_line __P((struct tr_resp *r, struct tr_resp *s,
					int have_next, int *res));
void			fixup_stats __P((struct resp_buf *base,
					struct resp_buf *prev,
					struct resp_buf *new));
int			print_stats __P((struct resp_buf *base,
					struct resp_buf *prev,
					struct resp_buf *new));
@


1.9
log
@follow post-2.1 ip_off & ip_len byte orders
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.8 2001/09/05 22:32:45 deraadt Exp $";
d142 2
a143 2
char *			inet_name __P((u_int32_t addr));
u_int32_t			host_addr __P((char *name));
d145 2
a146 2
char *			proto_type __P((u_int type));
char *			flag_type __P((u_int type));
d148 4
a151 4
u_int32_t			get_netmask __P((int s, u_int32_t dst));
int			get_ttl __P((struct resp_buf *buf));
int			t_diff __P((u_long a, u_long b));
u_long			fixtime __P((u_long time));
d154 5
a158 5
char *			print_host __P((u_int32_t addr));
char *			print_host2 __P((u_int32_t addr1, u_int32_t addr2));
void			print_trace __P((int index, struct resp_buf *buf));
int			what_kind __P((struct resp_buf *buf, char *why));
char *			scale __P((int *hop));
d167 1
a167 1
void			check_vif_state __P((void));
d169 1
a169 1
int			main __P((int argc, char *argv[]));
@


1.8
log
@make sure that va_start() has matching va_end()
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.7 2001/07/27 20:34:36 pvalchev Exp $";
d504 1
a504 1
	    ipdatalen = ip->ip_len;
d660 1
a660 1
	ipdatalen = ip->ip_len;
@


1.7
log
@Wall cleanup
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.6 2001/06/25 08:42:44 deraadt Exp $";
d1711 1
@


1.6
log
@Pavlin Ivanov Radoslavov <pavlin@@catarina.usc.edu> writes:
> I received an email that the USC's General Counsel's Office
> has approved that the software license to pimd can be changed to the
> 3-clause BSD-like license!
> [...]
This is various other bits of software that is also covered by this.
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.5 2001/03/09 03:24:07 deraadt Exp $";
d959 9
a967 9
	printf("\t\t\t\tv_in: %ld ", ntohl(s->tr_vifin));
	printf("v_out: %ld ", ntohl(s->tr_vifout));
	printf("pkts: %ld\n", ntohl(s->tr_pktcnt));
	printf("\t\t\t\tv_in: %ld ", ntohl(r->tr_vifin));
	printf("v_out: %ld ", ntohl(r->tr_vifout));
	printf("pkts: %ld\n", ntohl(r->tr_pktcnt));
	printf("\t\t\t\tv_in: %ld ",ntohl(s->tr_vifin)-ntohl(r->tr_vifin));
	printf("v_out: %ld ", ntohl(s->tr_vifout) - ntohl(r->tr_vifout));
	printf("pkts: %ld ", ntohl(s->tr_pktcnt) - ntohl(r->tr_pktcnt));
d1030 1
a1030 1
		*r++;
d1091 9
a1099 9
	printf("\t\t\t\tv_in: %ld ", ntohl(n->tr_vifin));
	printf("v_out: %ld ", ntohl(n->tr_vifout));
	printf("pkts: %ld\n", ntohl(n->tr_pktcnt));
	printf("\t\t\t\tv_in: %ld ", ntohl(b->tr_vifin));
	printf("v_out: %ld ", ntohl(b->tr_vifout));
	printf("pkts: %ld\n", ntohl(b->tr_pktcnt));
	printf("\t\t\t\tv_in: %ld ", ntohl(n->tr_vifin) - ntohl(b->tr_vifin));
	printf("v_out: %ld ", ntohl(n->tr_vifout) - ntohl(b->tr_vifout));
	printf("pkts: %ld\n", ntohl(n->tr_pktcnt) - ntohl(b->tr_pktcnt));
@


1.5
log
@exit(-#) is wrong
@
text
@d24 2
a25 1
 * Copyright (c) 1995 by the University of Southern California
d28 11
a38 11
 * Permission to use, copy, modify, and distribute this software and its
 * documentation in source and binary forms for non-commercial purposes
 * and without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both the copyright notice and
 * this permission notice appear in supporting documentation, and that
 * any documentation, advertising materials, and other materials related
 * to such distribution and use acknowledge that the software was
 * developed by the University of Southern California, Information
 * Sciences Institute.  The name of the University may not be used to
 * endorse or promote products derived from this software without
 * specific prior written permission.
d40 11
a50 12
 * THE UNIVERSITY OF SOUTHERN CALIFORNIA makes no representations about
 * the suitability of this software for any purpose.  THIS SOFTWARE IS
 * PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Other copyrights might apply to parts of this software and are so
 * noted when applicable.
 *
 * In particular, parts of the prototype version of this program may
 * have been derived from mrouted programs sources covered by the
 * license in the accompanying file named "LICENSE".
d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.4 2000/12/21 00:33:38 deraadt Exp $";
@


1.4
log
@more careful euid killing
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.3 1996/09/11 19:15:36 deraadt Exp $";
d1331 1
a1331 1
	exit(-1);
d1350 1
a1350 1
	    exit(-1);
d1357 1
a1357 1
	    exit(-1);
d1718 1
a1718 1
    if (severity <= LOG_ERR) exit(-1);
@


1.3
log
@revoke privs at start; tested by fenner@@parc.xerox.com
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.2 1995/12/14 01:46:22 deraadt Exp $";
d1169 1
@


1.2
log
@from netbsd; update to mrouted 3.8
@
text
@d55 1
a55 1
    "@@(#) $Id: mtrace.c,v 1.5 1995/12/10 10:57:15 mycroft Exp $";
d1168 2
a1169 4
    if (geteuid() != 0) {
	fprintf(stderr, "mtrace: must be root\n");
	exit(1);
    }
a1305 2

    init_igmp();
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mtrace.c,v 1.4 1995/10/04 03:47:57 thorpej Exp $	*/
d53 6
a58 1
#include <sys/filio.h>
a59 3
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ctype.h>
a60 1
#include <netdb.h>
d62 2
a63 6
#include <stdlib.h>
#include <unistd.h>

extern int optind;
extern char *optarg;

d65 9
d102 2
d111 2
d125 9
a133 8
u_int32_t qsrc = 0;
u_int32_t qgrp = 0;
u_int32_t qdst = 0;
u_char qno  = 0;
u_int32_t raddr = 0;
int    qttl = 0;
u_char rttl = 0;
u_int32_t gwy = 0;
a136 4
extern void k_join();
extern void k_leave();
extern void k_set_ttl();
extern void exit();
d142 28
a169 3
void
usage()
{
a170 5
    printf("\
Usage: mtrace [-Mlnps] [-w wait] [-m max_hops] [-q nqueries] [-g gateway]\n\
              [-t ttl] [-r resp_dest] [-i if_addr] source [receiver] [group]\n");
	exit(1);
}
d173 1
a173 1
char *
d189 2
a190 2
    struct hostent *e;
    struct in_addr ina;
d197 2
a198 2
     * Undo the BSD-ism `127.1' == `127.0.0.1'.  We change this to
     * `127.1' == `127.1.0.0'.
a199 1

d201 4
a204 5
        if (*ip == '.')
            --dots;
        if (*ip == '\0')
            break;
        *op++ = *ip++;
d207 1
a207 1
        *op++ = '.';
d212 6
a217 3
    if (inet_aton(buf, &ina) == 0) {
        if ((e = gethostbyname(name)) == NULL) {
	    ina.s_addr = 0;
d219 1
a219 2
        } else
	    memcpy((char *)&ina.s_addr, e->h_addr_list[0], e->h_length);
d221 1
a221 2

    return (ina.s_addr);
d227 1
a227 1
    u_char type;
d249 1
a249 1
    u_char type;
d291 2
a292 1
    char inbuf[8192];
a294 1
    int i;
d299 3
a301 3
    ifc.ifc_len = sizeof(inbuf);
    ifc.ifc_buf = inbuf;
    if (ioctl(s, SIOCGIFCONF, (char *)&ifc) < 0) {
a304 1

d313 1
a313 2
		if (lcl_addr == 0)
		    lcl_addr = if_addr;
d316 1
a316 2
	if (lcl_addr == if_addr)
	    found = TRUE;
d330 3
a332 3
    register rno;
    register struct tr_resp *b;
    register ttl;
d340 2
a341 4
	    if (ttl < b->tr_fttl)
	        ttl = b->tr_fttl;
	    else
	        ++ttl;
d344 2
a345 4
	if (ttl < MULTICAST_TTL1)
	    ttl = MULTICAST_TTL1;
	if (ttl > MULTICAST_TTL_MAX)
	    ttl = MULTICAST_TTL_MAX;
d347 1
a347 2
    } else
        return(MULTICAST_TTL1);
d378 11
d414 2
a415 4
    if (IN_MULTICAST(ntohl(dst)))
        local = lcl_addr;
    else
        local = INADDR_ANY;
d429 2
d449 3
d453 1
d470 2
a471 4
	    if (tv.tv_usec < 0)
	        tv.tv_usec += 1000000L, --tv.tv_sec;
	    if (tv.tv_sec < 0)
	        tv.tv_sec = tv.tv_usec = 0;
d477 1
a477 2
		if (errno != EINTR)
		    perror("select");
d490 1
a490 2
		if (recvlen && errno != EINTR)
		    perror("recvfrom");
d524 1
a524 4
		if (igmp->igmp_code != DVMRP_NEIGHBORS2)
		    continue;
		if (ip->ip_src.s_addr != dst)
		    continue;
d526 19
d547 1
a547 1
	      case IGMP_MTRACE_QUERY:  /* For backward compatibility with 3.3 */
d549 1
a549 2
		if (igmpdatalen <= QLEN)
		    continue;
d559 3
a561 6
		if (rquery->tr_qid != query->tr_qid)
		    continue;
		if (rquery->tr_src != qsrc)
		    continue;
		if (rquery->tr_dst != qdst)
		    continue;
d567 1
a567 1
		 * (needed only because IGMP_MTRACE is accepted above
d614 121
d740 13
d756 1
a756 1
	printf("%s", inet_fmt(addr, s1));
d759 4
a762 2
    name = inet_name(addr);
    printf("%s (%s)", name, inet_fmt(addr, s1));
d777 2
d785 8
a792 4
	name = print_host(r->tr_outaddr);
	printf("  %s  thresh^ %d  %d ms  %s\n", proto_type(r->tr_rproto),
	       r->tr_fttl, t_diff(fixtime(ntohl(r->tr_qarr)), buf->qtime),
	       flag_type(r->tr_rflags));
d801 2
a802 2
void
what_kind(buf)
d804 1
d807 1
a807 1
    int recvlen;
d812 1
a812 1
    recvlen = send_recv(next, IGMP_DVMRP, DVMRP_ASK_NEIGHBORS2, 1, &incr[0]);
d814 1
a814 1
    if (recvlen) {
d818 22
a839 7
	printf(" [%s%d.%d] didn't respond\n",
	       (version == 1) ? "proteon/mrouted " :
	       ((version & 0xff) == 2) ? "mrouted " :
	       ((version & 0xff) == 3) ? "mrouted " :
	       ((version & 0xff) == 4) ? "mrouted " :
	       ((version & 0xff) == 10) ? "cisco " : "",
	       version & 0xff, (version >> 8) & 0xff);
d842 5
a846 3
	    register u_int32_t laddr = *p++;
	    register int n = ntohl(*p++) & 0xFF;
	    if ((laddr & smask) == (qsrc & smask)) {
d850 1
a850 1
		break;
d854 1
a854 1
	return;
d856 2
a857 1
    printf(" didn't respond\n");
d880 1
a880 1
stat_line(r, s, have_next)
d883 1
d885 1
a885 1
    register timediff = (fixtime(ntohl(s->tr_qarr)) -
d887 5
a891 5
    register v_lost, v_pct;
    register g_lost, g_pct;
    register v_out = ntohl(s->tr_vifout) - ntohl(r->tr_vifout);
    register g_out = ntohl(s->tr_pktcnt) - ntohl(r->tr_pktcnt);
    register v_pps, g_pps;
d893 2
a894 1
    register have = NEITHER;
d896 1
a896 2
    if (timediff == 0)
        timediff = 1;
d900 3
a902 2
    if (v_out || s->tr_vifout != 0xFFFFFFFF)
        have |= OUTS;
d905 3
a907 2
	--r,  --s;
	if (s->tr_vifin != 0xFFFFFFFF || r->tr_vifin != 0xFFFFFFFF)
d909 2
d916 2
a917 4
	if (v_out)
	    v_pct = (v_lost * 100 + (v_out >> 1)) / v_out;
	else
	    v_pct = 0;
d919 2
a920 3
	    sprintf(v_str, "%3d", v_pct);
	else
	    memcpy(v_str, " --", 4);
d923 2
a924 4
	if (g_out)
	    g_pct = (g_lost * 100 + (g_out >> 1))/ g_out;
	else
	    g_pct = 0;
d926 7
a932 1
	    sprintf(g_str, "%3d", g_pct);
d934 2
a935 16
	    memcpy(g_str, " --", 4);

	printf("%6d/%-5d=%s%%%4d pps%6d/%-5d=%s%%%4d pps\n",
	       v_lost, v_out, v_str, v_pps, g_lost, g_out, g_str, g_pps);
	if (debug > 2) {
	    printf("\t\t\t\tv_in: %ld ", ntohl(s->tr_vifin));
	    printf("v_out: %ld ", ntohl(s->tr_vifout));
	    printf("pkts: %ld\n", ntohl(s->tr_pktcnt));
	    printf("\t\t\t\tv_in: %ld ", ntohl(r->tr_vifin));
	    printf("v_out: %ld ", ntohl(r->tr_vifout));
	    printf("pkts: %ld\n", ntohl(r->tr_pktcnt));
	    printf("\t\t\t\tv_in: %ld ",ntohl(s->tr_vifin)-ntohl(r->tr_vifin));
	    printf("v_out: %ld ", ntohl(s->tr_vifout) - ntohl(r->tr_vifout));
	    printf("pkts: %ld ", ntohl(s->tr_pktcnt) - ntohl(r->tr_pktcnt));
	    printf("time: %d\n", timediff);
	}
d939 1
a939 2
	v_out = (ntohl(s->tr_vifin) - ntohl(r->tr_vifin));
	g_out = (ntohl(s->tr_pktcnt) - ntohl(r->tr_pktcnt));
a940 1
	g_pps = g_out / timediff;
d944 7
a950 2
	printf("       %-5d     %4d pps       %-5d     %4d pps\n",
	       v_out, v_pps, g_out, g_pps);
d957 14
d974 2
a975 1
 * A fixup to check if any pktcnt has been reset.
d978 2
a979 2
fixup_stats(base, new)
    struct resp_buf *base, *new;
d981 20
a1000 7
    register rno = base->len;
    register struct tr_resp *b = base->resps + rno;
    register struct tr_resp *n = new->resps + rno;

    while (--rno >= 0)
        if (ntohl((--n)->tr_pktcnt) < ntohl((--b)->tr_pktcnt))
            break;
d1002 6
a1007 2
    if (rno < 0)
        return;
d1011 1
d1014 38
a1051 2
    while (--rno >= 0)
        (--b)->tr_pktcnt = (--n)->tr_pktcnt;
d1057 1
a1057 1
void
d1062 11
a1072 9
    register char *ms;
    register u_int32_t smask;
    register rno = base->len - 1;
    register struct tr_resp *b = base->resps + rno;
    register struct tr_resp *p = prev->resps + rno;
    register struct tr_resp *n = new->resps + rno;
    register u_long resptime = new->rtime;
    register u_long qarrtime = fixtime(ntohl(n->tr_qarr));
    register ttl = n->tr_fttl;
d1082 8
a1089 6
    printf("     |       __/  rtt%5d%s    Lost/Sent = Pct  Rate       To %s\n",
	   rtt, ms, inet_fmt(qgrp, s2));
    hop = t_diff(resptime, qarrtime);
    ms = scale(&hop);
    printf("     v      /     hop%5d%s", hop, ms);
    printf("    ---------------------     --------------------\n");
d1100 1
d1104 3
a1106 4
	if ((n->tr_inaddr != b->tr_inaddr) || (n->tr_inaddr != b->tr_inaddr)) {
	    printf("Route changed, start again.\n");
	    exit(1);
	}
d1114 10
a1123 11
	printf("     |     ^      ttl%5d   ", ttl);
	if (prev == new)
	    printf("\n");
	else
	    stat_line(p, n, TRUE);
	resptime = qarrtime;
	qarrtime = fixtime(ntohl((n-1)->tr_qarr));
	hop = t_diff(resptime, qarrtime);
	ms = scale(&hop);
	printf("     v     |      hop%5d%s", hop, ms);
	stat_line(b, n, TRUE);
d1125 3
a1127 5
	--b, --p, --n;
	if (ttl < n->tr_fttl)
	    ttl = n->tr_fttl;
	else
	    ++ttl;
d1130 8
a1137 9
    printf("     |      \\__   ttl%5d   ", ttl);
    if (prev == new)
        printf("\n");
    else
        stat_line(p, n, FALSE);
    hop = t_diff(qarrtime, new->qtime);
    ms = scale(&hop);
    printf("     v         \\  hop%5d%s", hop, ms);
    stat_line(b, n, FALSE);
d1140 1
a1158 1
    struct tr_query *query;
d1162 2
a1163 1
    int hops, tries;
a1166 1
    int ch;
d1173 2
a1174 15
    while ((ch = getopt(argc, argv, "d:g:i:lMm:npq:r:st:w:")) != -1) {
        switch (ch) {
	case 'd':			/* Unlisted debug print option */
	    if (!isdigit(*optarg))
		usage();
	    debug = atoi(optarg);
	    if (debug < 0)
	         debug = 0;
	    else if (debug > 3)
	        debug = 3;
	    break;

        case 'M':			/* Use multicast for reponse */
	    multicast = TRUE;
	    break;
d1176 103
a1278 3
	case 'l':			/* Loop updating stats indefinitely */
	    numstats = 3153600;
	    break;
d1280 16
a1295 61
	case 'n':			/* Don't reverse map host addresses */
	    numeric = TRUE;
	    break;

	case 'p':			/* Passive listen for traces */
	    passive = TRUE;
	    break;

	case 's':			/* Short form, don't wait for stats */
	    numstats = 0;
	    break;

	case 'w':			/* Time to wait for packet arrival */
	    if (!isdigit(*optarg))
		usage();
	    timeout = atoi(optarg);
	    if (timeout < 1)
	        timeout = 1;
	    break;

	case 'm':			/* Max number of hops to trace */
	    if (!isdigit(*optarg))
		usage();
	    qno = atoi(optarg);
	    if (qno > MAXHOPS)
	        qno = MAXHOPS;
	    else if (qno < 1)
	        qno = 0;
	    break;

	case 'q':			/* Number of query retries */
	    if (!isdigit(*optarg))
		usage();
	    nqueries = atoi(optarg);
	    if (nqueries < 1)
	        nqueries = 1;
	    break;

	case 'g':			/* Last-hop gateway (dest of query) */
	    if ((gwy = host_addr(optarg)) == 0)
		usage();
	    break;

	case 't':			/* TTL for query packet */
	    if (!isdigit(*optarg))
		usage();
	    qttl = atoi(optarg);
	    if (qttl < 1)
	        qttl = 1;
	    rttl = qttl;
	    break;

	case 'r':			/* Dest for response packet */
	    if ((raddr = host_addr(optarg)) == 0)
		usage();
	    break;

	case 'i':			/* Local interface address */
	    if ((lcl_addr = host_addr(optarg)) == 0)
		usage();
	    break;
d1297 3
a1299 23
	default:
	    usage();
	} /* switch */
    } /* while */
    argv += optind;
    argc -= optind;

    switch (argc) {
    case 3:		/* Path via group */
	if ((qgrp = host_addr(argv[2])) == 0)
		usage();
	/* FALLTHROUGH */
    case 2:		/* dest of path */
	if ((qdst = host_addr(argv[1])) == 0)
		usage();
	/* FALLTHROUGH */
    case 1:		/* source of path */
	if ((qsrc = host_addr(argv[0])) == 0 || IN_MULTICAST(ntohl(qsrc)))
	    usage();
	break;

    default:
	usage();
d1302 5
a1306 15
    /*
     * If argc is > 1 and the second argument is a multicast address,
     * assume that the second argument is actually qgrp and the third
     * (if any) is qdst; in this case, the third argument is not allowed
     * to be a multicast address.
     */
    if (argc > 1) {
	if (IN_MULTICAST(ntohl(qdst))) {
	    u_int32_t temp = qdst;
	    qdst = qgrp;
	    qgrp = temp;
	    if (IN_MULTICAST(ntohl(qdst)))
		usage();
	} else if (qgrp != 0 && !IN_MULTICAST(ntohl(qgrp)))
	    usage();
a1308 3
    if (qsrc == 0)
	usage();

d1318 1
a1318 2
    if (qgrp == 0)
        qgrp = defgrp;
d1337 1
d1339 5
a1343 1
     * Default destination for path to be queried is the local host.
d1345 21
a1365 2
    if (qdst == 0)
        qdst = lcl_addr ? lcl_addr : addr.sin_addr.s_addr;
d1368 1
a1368 5
     * If the destination is on the local net, the last-hop router can
     * be found by multicast to the all-routers multicast group.
     * Otherwise, use the group address that is the subject of the
     * query since by definition the last hop router will be a member.
     * Set default TTLs for local remote multicasts.
d1370 1
d1373 12
a1384 7
    if (lcl_addr == 0)
        lcl_addr = addr.sin_addr.s_addr;
    if (gwy == 0)
        if ((qdst & dst_netmask) == (lcl_addr & dst_netmask))
            gwy = query_cast;
        else
            gwy = qgrp;
d1386 9
a1394 10
    if (IN_MULTICAST(ntohl(gwy))) {
      k_set_loop(1);	/* If I am running on a router, I need to hear this */
      if (gwy == query_cast)
          k_set_ttl(qttl ? qttl : 1);
      else
          k_set_ttl(qttl ? qttl : MULTICAST_TTL1);
    } else
      if (send_recv(gwy, IGMP_DVMRP, DVMRP_ASK_NEIGHBORS2, 1, &incr[0]))
	if (ntohl(incr[0].igmp.igmp_group.s_addr) == 0x0303) {
	    printf("Don't use -g to address an mrouted 3.3, it might crash\n");
d1397 1
d1408 2
a1409 3
     * Make up the IGMP_MTRACE_QUERY query packet to send (some parameters
     * are set later), including initializing the seed for random
     * query identifiers.
d1411 3
a1413 7
    query = (struct tr_query *)(send_buf + MIN_IP_HEADER_LEN + IGMP_MINLEN);
    query->tr_src   = qsrc;
    query->tr_dst   = qdst;

    gettimeofday(&tv, 0);
    seed = tv.tv_usec ^ lcl_addr;
    srandom(seed);
d1416 5
a1420 2
     * If the response is to be a multicast address, make sure we 
     * are listening on that multicast address.
d1422 12
a1433 4
    if (raddr && IN_MULTICAST(ntohl(raddr)))
        k_join(raddr, lcl_addr);
    else
        k_join(resp_cast, lcl_addr);
d1436 1
a1436 1
     * Try a query at the requested number of hops or MAXOPS if unspecified.
d1452 1
a1452 1
    recvlen = send_recv(gwy, IGMP_MTRACE_QUERY, hops, tries, &base);
d1457 3
a1459 1
     * from one until a timeout occurs.
d1467 2
a1468 1
	if (r->tr_rflags == TR_OLD_ROUTER) {
d1470 3
a1472 2
	    fflush(stdout);
	    what_kind(&base);
d1486 1
a1486 1
	for (hops = 1; hops <= MAXHOPS; ++hops) {
d1490 13
a1502 1
	    recvlen = send_recv(gwy, IGMP_MTRACE_QUERY, hops, nqueries, &base);
d1505 14
a1518 3
		if (--hops == 0) break;
		what_kind(&base);
		break;
d1521 7
a1527 7
	    if (base.len == hops)
	        print_trace(-hops, &base);
	    else {
		hops = base.len;
		if (r->tr_rflags == TR_OLD_ROUTER) {
		    what_kind(&base);
		    break;
d1529 31
a1559 3
		if (r->tr_rflags == TR_NO_SPACE) {
		    printf("No space left in trace packet for further hops\n");
		    break;	/* XXX could do segmented trace */
a1560 2
		printf("Route must have changed...\n\n");
		print_trace(1, &base);
d1562 1
d1564 18
a1581 5
	    VAL_TO_MASK(smask, r->tr_smask);
	    if ((r->tr_inaddr & smask) == (qsrc & smask)) {
		printf("%3d  ", -(hops+1));
		print_host(qsrc);
		printf("\n");
d1584 2
a1585 2
	    if (r->tr_rmtaddr == 0 || (r->tr_rflags & 0x80))
	        break;
d1591 2
a1592 2
	if (IN_MULTICAST(ntohl(gwy)))
	  if (gwy == query_cast)
d1613 3
a1615 2
    waittime = 10 - (((tv.tv_sec + JAN_1970) & 0xFFFF) - (base.qtime >> 16));
    prev = new = &incr[numstats&1];
d1625 1
a1625 1
	recvlen = send_recv(gwy, IGMP_MTRACE_QUERY, rno, nqueries, new);
d1633 13
a1645 2
	    printf("Trace length doesn't match.\n");
	    exit(1);
d1649 8
a1656 3
	       (new->qtime - base.qtime) >> 16);
	fixup_stats(&base, new);
	print_stats(&base, prev, new);
d1659 1
a1659 1
	waittime = 10;
d1665 3
a1667 2
    if (raddr && IN_MULTICAST(ntohl(raddr))) k_leave(raddr, lcl_addr);
    else k_leave(resp_cast, lcl_addr);
d1683 9
d1693 5
a1697 5
void
log(severity, syserr, format, a, b, c, d, e)
    int severity, syserr;
    char *format;
    int a, b, c, d, e;
d1699 5
a1703 1
    char fmt[100];
d1706 3
a1708 9
	case 0:
	    if (severity > LOG_WARNING)
	        return;
	case 1:
	    if (severity > LOG_NOTICE)
	        return;
	case 2:
	    if (severity > LOG_INFO)
	        return;
d1713 1
a1713 1
	    fprintf(stderr, fmt, a, b, c, d, e);
d1721 1
a1721 2
    if (severity <= LOG_ERR)
        exit(-1);
d1725 87
a1811 16

/*VARARGS*/
void accept_probe() {} /*VARARGS*/
void accept_group_report() {} /*VARARGS*/
void accept_neighbors() {} /*VARARGS*/
void accept_neighbors2() {} /*VARARGS*/
void accept_neighbor_request() {} /*VARARGS*/
void accept_neighbor_request2() {} /*VARARGS*/
void accept_report() {} /*VARARGS*/
void accept_prune() {} /*VARARGS*/
void accept_graft() {} /*VARARGS*/
void accept_g_ack() {} /*VARARGS*/
void add_table_entry() {} /*VARARGS*/
void accept_mtrace() {} /*VARARGS*/
void accept_leave_message() {} /*VARARGS*/
void accept_membership_query() {} /*VARARGS*/
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
