head	1.8;
access;
symbols
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.18
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2002.12.31.16.35.42;	author miod;	state dead;
branches;
next	1.7;

1.7
date	2002.09.06.22.45.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.29.09.47.20;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.28.02;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.09.18.22.03.45;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.05.24.09.21.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.22.00.38.05;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.34;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.8
log
@amiga and sun3 turned out to not be y2k+3 compliant here. Remove them, as
well as the few userland tools which were only used on these platforms.
@
text
@/*	$OpenBSD: grfconfig.c,v 1.7 2002/09/06 22:45:06 deraadt Exp $	*/
/*	$NetBSD: grfconfig.c,v 1.6 1997/07/29 23:41:12 veego Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Ezra Story and Bernd Ernesti.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>

#ifndef lint
static char rcsid[] = "$OpenBSD: grfconfig.c,v 1.7 2002/09/06 22:45:06 deraadt Exp $";
#endif /* not lint */

#include <sys/file.h>
#include <sys/ioctl.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <amiga/dev/grfioctl.h>

extern char *optarg;
extern int optind;

static void print_rawdata(struct grfvideo_mode *, int);

static struct grf_flag {
	u_short	grf_flag_number;
	char	*grf_flag_name;
} grf_flags[] = {
	{ GRF_FLAGS_DBLSCAN,		"doublescan" },
	{ GRF_FLAGS_LACE,		"interlace" },
	{ GRF_FLAGS_PHSYNC,		"+hsync" },
	{ GRF_FLAGS_NHSYNC,		"-hsync" },
	{ GRF_FLAGS_PVSYNC,		"+vsync" },
	{ GRF_FLAGS_NVSYNC,		"-vsync" },
	{ GRF_FLAGS_SYNC_ON_GREEN,	"sync-on-green" },
	{ 0,				0 }
};

/*
 * Dynamic mode loader for OpenBSD/Amiga grf devices.
 */
int
main(int argc, char *argv[])
{
	struct	grfvideo_mode gv[1];
	struct	grf_flag *grf_flagp;
	FILE	*fp;
	int	c, y, grffd;
	int	i, lineno = 0;
	int	uplim, lowlim;
	char	rawdata = 0, testmode = 0;
	char	*grfdevice = 0;
	char	*modefile = 0;
	char	buf[_POSIX2_LINE_MAX], obuf[_POSIX2_LINE_MAX];
	char	*cps[31];
	char	*p;
	char	*errortext;

	while ((c = getopt(argc, argv, "rt")) != -1) {
		switch (c) {
		case 'r':	/* raw output */
			rawdata = 1;
			break;
		case 't':	/* test the modefile without setting it */
			testmode = 1;
			break;
		default:
			printf("grfconfig [-r] device [file]\n");
			return (1);
		}
	}
	argc -= optind;
	argv += optind;


	if (argc >= 1)
		grfdevice = argv[0];
	else {
		printf("grfconfig: No grf device specified.\n");
		return (1);
	}

	if (argc >= 2)
		modefile = argv[1];

	if ((grffd = open(grfdevice, O_RDWR)) < 0) {
		printf("grfconfig: can't open grf device.\n");
		return (1);
	}
	/* If a mode file is specificied, load it in, don't display any info. */

	if (modefile) {
		if (!(fp = fopen(modefile, "r"))) {
			printf("grfconfig: Cannot open mode definition "
			    "file.\n");
			return (1);
		}
		while (fgets(buf, sizeof(buf), fp)) {
			/*
			 * check for end-of-section, comments, strip off trailing
			 * spaces and newline character.
			 */
			for (p = buf; isspace(*p); ++p)
				continue;
			if (*p == '\0' || *p == '#')
				continue;
			for (p = strchr(buf, '\0'); isspace(*--p);)
				continue;
			*++p = '\0';

			snprintf(obuf, sizeof obuf, "%s", buf);
			lineno = lineno + 1;

			for (i = 0, *cps = strtok(buf, " \b\t\r\n");
			    cps[i] != NULL && i < 30; i++)
				cps[i + 1] = strtok(NULL, " \b\t\r\n");
			cps[i] = NULL;

			if (cps[13] == NULL) {
				printf("grfconfig: too few values in mode "
				    "definition file:\n %s\n", obuf);
				return (1);
			}

			gv->pixel_clock	= atoi(cps[1]);
			gv->disp_width	= atoi(cps[2]);
			gv->disp_height	= atoi(cps[3]);
			gv->depth	= atoi(cps[4]);
			gv->hblank_start	= atoi(cps[5]);
			gv->hsync_start	= atoi(cps[6]);
			gv->hsync_stop	= atoi(cps[7]);
			gv->htotal	= atoi(cps[8]);
			gv->vblank_start	= atoi(cps[9]);
			gv->vsync_start	= atoi(cps[10]);
			gv->vsync_stop	= atoi(cps[11]);
			gv->vtotal	= atoi(cps[12]);

			if ((y = atoi(cps[0])))
				gv->mode_num = y;
			else
				if (strncasecmp("c", cps[0], 1) == 0) {
					gv->mode_num = 255;
					gv->depth = 4;
				} else {
					printf("grfconfig: Illegal mode "
					    "number: %s\n", cps[0]);
					return (1);
				}

			if ((gv->pixel_clock == 0) ||
			    (gv->disp_width == 0) ||
			    (gv->disp_height == 0) ||
			    (gv->depth == 0) ||
			    (gv->hblank_start == 0) ||
			    (gv->hsync_start == 0) ||
			    (gv->hsync_stop == 0) ||
			    (gv->htotal == 0) ||
			    (gv->vblank_start == 0) ||
			    (gv->vsync_start == 0) ||
			    (gv->vsync_stop == 0) ||
			    (gv->vtotal == 0)) {
				printf("grfconfig: Illegal value in "
				    "mode #%d:\n %s\n", gv->mode_num, obuf);
				return (1);
			}

			if (strstr(obuf, "default") != NULL) {
				gv->disp_flags = GRF_FLAGS_DEFAULT;
			} else {
				gv->disp_flags = GRF_FLAGS_DEFAULT;
				for (grf_flagp = grf_flags;
				  grf_flagp->grf_flag_number; grf_flagp++) {
				    if (strstr(obuf, grf_flagp->grf_flag_name) != NULL) {
					gv->disp_flags |= grf_flagp->grf_flag_number;
				    }
				}
				if (gv->disp_flags == GRF_FLAGS_DEFAULT) {
					printf("grfconfig: Your are using an "
					    "mode file with an obsolete "
					    "format.\n See the manpage of "
					    "grfconfig for more information "
					    "about the new mode definition "
					    "file.\n");
					return (1);
				}
			}

			/*
			 * Check for impossible gv->disp_flags:
			 * doublescan and interlace,
			 * +hsync and -hsync
			 * +vsync and -vsync.
			 */
			errortext = NULL;
			if ((gv->disp_flags & GRF_FLAGS_DBLSCAN) &&
			    (gv->disp_flags & GRF_FLAGS_LACE))
				errortext = "Interlace and Doublescan";
			if ((gv->disp_flags & GRF_FLAGS_PHSYNC) &&
			    (gv->disp_flags & GRF_FLAGS_NHSYNC))
				errortext = "+hsync and -hsync";
			if ((gv->disp_flags & GRF_FLAGS_PVSYNC) &&
			    (gv->disp_flags & GRF_FLAGS_NVSYNC))
				errortext = "+vsync and -vsync";

			if (errortext != NULL) {
				printf("grfconfig: Illegal flags in "
				    "mode #%d: %s are both defined!\n",
				    gv->mode_num, errortext);
				return (1);
			}

			/* Check for old horizontal cycle values */
			if ((gv->htotal < (gv->disp_width / 4))) {
				gv->hblank_start *= 8;
				gv->hsync_start *= 8;
				gv->hsync_stop *= 8;
				gv->htotal *= 8;
				printf("grfconfig: Old and no longer "
				    "supported horizontal videoclock cycle "
				    "values.\n Wrong mode line:\n  %s\n "
				    "This could be a possible good mode "
				    "line:\n  ", obuf);
				printf("%d ", gv->mode_num);
				print_rawdata(gv, 0);
				printf(" See the manpage of grfconfig for "
				    "more information about the new mode "
				    "definition file.\n");
				return (1);
			}

			/* Check for old interlace or doublescan modes */
			uplim = gv->disp_height + (gv->disp_height / 4);
			lowlim = gv->disp_height - (gv->disp_height / 4);
			if (((gv->vtotal * 2) > lowlim) &&
			    ((gv->vtotal * 2) < uplim)) {
				gv->vblank_start *= 2;
				gv->vsync_start *= 2;
				gv->vsync_stop *= 2;
				gv->vtotal *= 2;
				gv->disp_flags &= ~GRF_FLAGS_DBLSCAN;
				gv->disp_flags |= GRF_FLAGS_LACE;
				printf("grfconfig: Old and no longer "
				    "supported vertical values for "
				    "interlace modes.\n Wrong mode "
				    "line:\n  %s\n This could be a "
				    "possible good mode line:\n  ", obuf);
				printf("%d ", gv->mode_num);
				print_rawdata(gv, 0);
				printf(" See the manpage of grfconfig for "
				    "more information about the new mode "
				    "definition file.\n");
				return (1);
			} else if (((gv->vtotal / 2) > lowlim) &&
			    ((gv->vtotal / 2) < uplim)) {
				gv->vblank_start /= 2;
				gv->vsync_start /= 2;
				gv->vsync_stop /= 2;
				gv->vtotal /= 2;
				gv->disp_flags &= ~GRF_FLAGS_LACE;
				gv->disp_flags |= GRF_FLAGS_DBLSCAN;
				printf("grfconfig: Old and no longer "
				    "supported vertical values for "
				    "doublescan modes.\n Wrong mode "
				    "line:\n  %s\n This could be a "
				    "possible good mode line:\n  ", obuf);
				printf("%d ", gv->mode_num);
				print_rawdata(gv, 0);
				printf(" See the manpage of grfconfig for "
				    "more information about the new mode "
				    "definition file.\n");
				return (1);
			}

			if (testmode == 1) {
				if (lineno == 1)
					printf("num clk wid hi dep hbs "
					    "hss hse ht vbs vss vse vt "
					    "flags\n");
				printf("%d ", gv->mode_num);
				print_rawdata(gv, 1);
			} else {
				gv->mode_descr[0] = 0;
				if (ioctl(grffd, GRFIOCSETMON, (char *) gv) < 0)
					printf("grfconfig: bad monitor "
					    "definition for mode #%d.\n",
					    gv->mode_num);
			}
		}
		fclose(fp);
	} else {
		ioctl(grffd, GRFGETNUMVM, &y);
		y += 2;
		for (c = 1; c < y; c++) {
			c = gv->mode_num = (c != (y - 1)) ? c : 255;
			if (ioctl(grffd, GRFGETVMODE, gv) < 0)
				continue;
			if (rawdata) {
				if (c == 255)
					printf("c ");
				else
					printf("%d ", c);
				print_rawdata(gv, 0);
				continue;
			}
			if (c == 255)
				printf("Console: ");
			else
				printf("%2d: ", gv->mode_num);

			printf("%dx%d",
			    gv->disp_width,
			    gv->disp_height);

			if (c != 255)
				printf("x%d", gv->depth);
			else
				printf(" (%dx%d)",
				    gv->disp_width / 8,
				    gv->disp_height / gv->depth);

			printf("\t%ld.%ldkHz @@ %ldHz",
			    gv->pixel_clock / (gv->htotal * 1000),
			    (gv->pixel_clock / (gv->htotal * 100)) % 10,
			    gv->pixel_clock / (gv->htotal * gv->vtotal));
			printf(" flags:");
				
			if (gv->disp_flags == GRF_FLAGS_DEFAULT) {
				printf(" default");
			} else {
				for (grf_flagp = grf_flags;
				    grf_flagp->grf_flag_number; grf_flagp++) {
					if (gv->disp_flags &
					    grf_flagp->grf_flag_number) {
						printf(" %s",
						    grf_flagp->grf_flag_name);
					}
				}
			}
			printf("\n");
		}
	}

	close(grffd);
	return (0);
}

static void
print_rawdata(struct grfvideo_mode *gv, int rawflags)
{
	struct	grf_flag *grf_flagp;

	printf("%ld %d %d %d %d %d %d %d %d %d %d %d",
	    gv->pixel_clock, gv->disp_width,
	    gv->disp_height, gv->depth,
	    gv->hblank_start, gv->hsync_start,
	    gv->hsync_stop, gv->htotal,
	    gv->vblank_start, gv->vsync_start,
	    gv->vsync_stop, gv->vtotal);

	if (rawflags) {
		printf(" 0x%.2x", gv->disp_flags);
	} else {
		if (gv->disp_flags == GRF_FLAGS_DEFAULT) {
			printf(" default");
		} else {
			for (grf_flagp = grf_flags;
			    grf_flagp->grf_flag_number; grf_flagp++) {
				if (gv->disp_flags &
				    grf_flagp->grf_flag_number) {
					printf(" %s",
					    grf_flagp->grf_flag_name);
				}
			}
		}
	}
	printf("\n");
}
@


1.7
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: grfconfig.c,v 1.6 2002/05/29 09:47:20 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: grfconfig.c,v 1.6 2002/05/29 09:47:20 deraadt Exp $";
@


1.6
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: grfconfig.c,v 1.5 2002/02/16 21:28:02 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: grfconfig.c,v 1.5 2002/02/16 21:28:02 millert Exp $";
d60 1
a60 2
int main(int, char **);
static void print_rawdata(struct grfvideo_mode *, int);    
d66 8
a73 8
	{GRF_FLAGS_DBLSCAN,		"doublescan"},
	{GRF_FLAGS_LACE,		"interlace"},
	{GRF_FLAGS_PHSYNC,		"+hsync"},
	{GRF_FLAGS_NHSYNC,		"-hsync"},
	{GRF_FLAGS_PVSYNC,		"+vsync"},
	{GRF_FLAGS_NVSYNC,		"-vsync"},
	{GRF_FLAGS_SYNC_ON_GREEN,	"sync-on-green"},
	{0,				0}
d80 1
a80 3
main(ac, av)
	int     ac;
	char  **av;
d96 1
a96 2

	while ((c = getopt(ac, av, "rt")) != -1) {
d109 2
a110 2
	ac -= optind;
	av += optind;
d113 2
a114 2
	if (ac >= 1)
		grfdevice = av[0];
d120 2
a121 2
	if (ac >= 2)
		modefile = av[1];
d201 1
a201 1
				return (1);  
d360 1
a360 2
			    (gv->pixel_clock / (gv->htotal * 100)) 
    	    	    	    	% 10,
d368 6
a373 4
				  grf_flagp->grf_flag_number; grf_flagp++) {
				    if (gv->disp_flags & grf_flagp->grf_flag_number) {
					printf(" %s", grf_flagp->grf_flag_name);
				    }
d385 1
a385 3
print_rawdata(gv, rawflags)
	struct grfvideo_mode *gv;
	int rawflags;
d390 12
a401 14
		gv->pixel_clock,
		gv->disp_width,
		gv->disp_height,
		gv->depth,
		gv->hblank_start,
		gv->hsync_start,
		gv->hsync_stop,
		gv->htotal,
		gv->vblank_start,
		gv->vsync_start,
		gv->vsync_stop,
		gv->vtotal);
		if (rawflags) {
			printf(" 0x%.2x", gv->disp_flags);
d403 6
a408 8
			if (gv->disp_flags == GRF_FLAGS_DEFAULT) {
				printf(" default");
			} else {
				for (grf_flagp = grf_flags;
				  grf_flagp->grf_flag_number; grf_flagp++) {
				    if (gv->disp_flags & grf_flagp->grf_flag_number) {
					printf(" %s", grf_flagp->grf_flag_name);
				    }
d412 2
a413 1
		printf("\n");
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: grfconfig.c,v 1.4 1997/09/18 22:03:45 niklas Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: grfconfig.c,v 1.4 1997/09/18 22:03:45 niklas Exp $";
d152 1
a152 1
			sprintf(obuf, "%s", buf);
@


1.4
log
@Match with current kernel; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: grfconfig.c,v 1.6 1997/07/29 23:41:12 veego Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: grfconfig.c,v 1.6 1997/07/29 23:41:12 veego Exp $";
d60 2
a61 2
int main __P((int, char **));
static void print_rawdata __P((struct grfvideo_mode *, int));    
@


1.3
log
@print also the wrong mode number
@
text
@d1 2
a2 1
/*	$NetBSD: grfconfig.c,v 1.4 1996/05/19 09:02:44 veego Exp $	*/
d4 2
a5 2
/*
 * Copyright (c) 1995 Ezra Story
d8 3
d21 5
a25 3
 *      This product includes software developed by Ezra Story.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
d27 11
a37 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d39 11
d53 1
a53 2
#include <sys/file.h>
#include <sys/ioctl.h>
d60 17
d78 1
a78 1
 * Dynamic mode loader for NetBSD/Amiga grf devices.
d85 14
a98 9
	int     c, y, grffd;
	char    rawdata = 0;
    	char    oldmode = 1;
	char   *grfdevice = 0;
	char   *modefile = 0;
	char    buf[102];
	char    ystr[20];
	FILE   *fp;
	struct grfvideo_mode gv[1];
d100 1
a100 1
	while ((c = getopt(ac, av, "ro")) != -1) {
d105 3
a107 3
    	    	case 'o':
    	    	    	oldmode = 8;
    	    	    	break;
d135 2
a136 1
			printf("grfconfig: Cannot open mode definition file.\n");
d139 10
a148 2
		while (fgets(buf, 300, fp)) {
			if (buf[0] == '#')
d150 15
d166 12
a177 2
			/* num clk wid hi dep hbs hss hse hbe ht vbs vss vse
			 * vbe vt */
d179 144
a322 25
			c = sscanf(buf, "%9s %d %hd %hd %hd %hd %hd %hd "
			    "%hd %hd %hd %hd %hd %hd %hd",
			    ystr,
			    &gv->pixel_clock,
			    &gv->disp_width,
			    &gv->disp_height,
			    &gv->depth,
			    &gv->hblank_start,
			    &gv->hsync_start,
			    &gv->hsync_stop,
			    &gv->hblank_stop,
			    &gv->htotal,
			    &gv->vblank_start,
			    &gv->vsync_start,
			    &gv->vsync_stop,
			    &gv->vblank_stop,
			    &gv->vtotal);
			if (c == 15) {
				if (y = atoi(ystr))
					gv->mode_num = y;
				else
					if (ystr[0] == 'c') {
						gv->mode_num = 255;
						gv->depth = 4;
					}
a327 3
			} else {
				printf("grfconfig: bad line in mode "
				    "definition file.\n");
d343 1
a343 17
				printf("%d %d %d %d %d %d %d "
				    "%d %d %d %d %d %d %d\n",
				    gv->pixel_clock,
				    gv->disp_width,
				    gv->disp_height,
				    gv->depth,
				    gv->hblank_start,
				    gv->hsync_start,
				    gv->hsync_stop,
				    gv->hblank_stop,
				    gv->htotal,
				    gv->vblank_start,
				    gv->vsync_start,
				    gv->vsync_stop,
				    gv->vblank_stop,
				    gv->vtotal
				    );
d362 3
a364 3
			printf("\t%d.%dkHz @@ %dHz %s\n",
			    gv->pixel_clock / (gv->htotal * 1000 * oldmode),
			    (gv->pixel_clock / (gv->htotal * 100 * oldmode)) 
d366 14
a379 8
			    gv->pixel_clock / (gv->htotal * gv->vtotal * 
    	    	    	    	oldmode),
			    gv->vblank_start + 100 < gv->disp_height ?
			    "I" :
			    (gv->vblank_start - 100) > gv->disp_height ?
			    "SD" :
			    "NI"
			    );
d385 37
@


1.2
log
@From NetBSD:
Fixed Typo. Closes PR 2001 from Thorsten Frueauf <frueauf@@ira.uka.de>
 Keep them coming!
@
text
@d1 1
a1 1
/*	$NetBSD: grfconfig.c,v 1.3 1996/02/11 16:34:23 neil Exp $	*/
d134 2
a135 1
					    "definition.\n");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: grfconfig.c,v 1.2 1995/10/09 04:11:20 chopps Exp $	*/
d133 1
a133 1
					printf("grfocnfig: bad monitor "
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
