head	1.41;
access;
symbols
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.25.0.8
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9;
locks; strict;
comment	@ * @;


1.41
date	2017.01.31.21.35.07;	author sthen;	state Exp;
branches;
next	1.40;
commitid	85Oh1MeSFQmptWuj;

1.40
date	2015.11.02.12.21.27;	author jsg;	state Exp;
branches;
next	1.39;
commitid	dXLprIb6RVxzLAjA;

1.39
date	2015.11.02.12.01.28;	author jsg;	state Exp;
branches;
next	1.38;
commitid	2Kxrjh03iAoDqOe1;

1.38
date	2015.11.02.10.27.44;	author jsg;	state Exp;
branches;
next	1.37;
commitid	oYugXczRgOhXq8hY;

1.37
date	2015.08.19.21.07.23;	author reyk;	state Exp;
branches;
next	1.36;
commitid	hjNhGvFj6GZVPHMI;

1.36
date	2015.08.19.21.03.11;	author reyk;	state Exp;
branches;
next	1.35;
commitid	N9VsELhwlzLyeufL;

1.35
date	2015.08.19.21.01.20;	author reyk;	state Exp;
branches;
next	1.34;
commitid	CqsOJTw3RE8XAZ6M;

1.34
date	2015.08.19.13.30.54;	author reyk;	state Exp;
branches;
next	1.33;
commitid	3MutW3Gx20W7mfil;

1.33
date	2015.08.19.12.25.59;	author reyk;	state Exp;
branches;
next	1.32;
commitid	gmopNZyL5sd61vAg;

1.32
date	2015.08.15.04.47.28;	author semarie;	state Exp;
branches;
next	1.31;
commitid	rKNVhQzsXVvaKd13;

1.31
date	2015.08.15.04.45.49;	author semarie;	state Exp;
branches;
next	1.30;
commitid	LYdLDT39c9qzumgR;

1.30
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Uu5nFG3wCl0LACBb;

1.29
date	2014.08.26.17.47.24;	author jsing;	state Exp;
branches;
next	1.28;
commitid	7A7DObXgY4Fni8xJ;

1.28
date	2014.08.25.07.50.26;	author doug;	state Exp;
branches;
next	1.27;
commitid	vcwz0sp1JH7QzUmA;

1.27
date	2014.07.20.01.38.40;	author guenther;	state Exp;
branches;
next	1.26;
commitid	0acpjAf5myNxgwB5;

1.26
date	2014.04.18.21.29.20;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.08.12.51.46;	author mikeb;	state Exp;
branches;
next	1.23;

1.23
date	2012.10.23.14.36.18;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2012.07.08.11.48.20;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.27.12.01.02;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2010.10.08.16.15.22;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2010.10.08.15.45.34;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.08.11.41.56;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.08.10.13.47;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.08.07.45.06;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.07.15.17.38;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.07.13.30.50;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.07.12.23.14;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.07.10.56.22;	author phessler;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.07.09.36.33;	author phessler;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.23.19.28.18;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.23.17.10.49;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.23.16.01.01;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.21.10.48.12;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.14.17.41.18;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.10.16.14.04;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.07.14.15.27;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.04.13.34.38;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.49.00;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Teach ikectl to include extensions in the CSR, rather than just adding them
when signing the certificates by the local CA. This can make things easier if
you want to take a CSR from ikectl to another CA for signing, they often copy
extensions from the request.  ok reyk@@
@
text
@/*	$OpenBSD: ikeca.c,v 1.40 2015/11/02 12:21:27 jsg Exp $	*/

/*
 * Copyright (c) 2010 Jonathan Gray <jsg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <unistd.h>
#include <err.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <pwd.h>
#include <fcntl.h>
#include <fts.h>
#include <dirent.h>
#include <limits.h>

#include <openssl/rand.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>

#include "types.h"
#include "parser.h"

#ifndef PREFIX
#define PREFIX		""
#endif
#ifndef SSLDIR
#define SSLDIR		PREFIX "/etc/ssl"
#endif
#define SSL_CNF		SSLDIR "/openssl.cnf"
#define X509_CNF	SSLDIR "/x509v3.cnf"
#define IKECA_CNF	SSLDIR "/ikeca.cnf"
#define KEYBASE		PREFIX "/etc/iked"
#ifndef EXPDIR
#define EXPDIR		PREFIX "/usr/share/iked"
#endif

#ifndef PATH_OPENSSL
#define PATH_OPENSSL	"/usr/bin/openssl"
#endif
#ifndef PATH_ZIP
#define PATH_ZIP	"/usr/local/bin/zip"
#endif
#ifndef PATH_TAR
#define PATH_TAR	"/bin/tar"
#endif

struct ca {
	char		 sslpath[PATH_MAX];
	char		 passfile[PATH_MAX];
	char		 index[PATH_MAX];
	char		 serial[PATH_MAX];
	char		 sslcnf[PATH_MAX];
	char		 extcnf[PATH_MAX];
	char		 batch[PATH_MAX];
	char		*caname;
};

struct {
	char	*dir;
	mode_t	 mode;
} hier[] = {
	{ "",		0755 },
	{ "/ca",	0755 },
	{ "/certs",	0755 },
	{ "/crls",	0755 },
	{ "/export",	0755 },
	{ "/private",	0700 }
};

/* explicitly list allowed variables */
const char *ca_env[][2] = {
	{ "$ENV::CADB", NULL },
	{ "$ENV::CASERIAL", NULL },
	{ "$ENV::CERTFQDN", NULL },
	{ "$ENV::CERTIP", NULL },
	{ "$ENV::CERTPATHLEN", NULL },
	{ "$ENV::CERTUSAGE", NULL },
	{ "$ENV::CERT_C", NULL },
	{ "$ENV::CERT_CN", NULL },
	{ "$ENV::CERT_EMAIL", NULL },
	{ "$ENV::CERT_L", NULL },
	{ "$ENV::CERT_O", NULL },
	{ "$ENV::CERT_OU", NULL },
	{ "$ENV::CERT_ST", NULL },
	{ "$ENV::EXTCERTUSAGE", NULL },
	{ "$ENV::NSCERTTYPE", NULL },
	{ "$ENV::REQ_EXT", NULL },
	{ NULL }
};

int		 ca_sign(struct ca *, char *, int);
int		 ca_request(struct ca *, char *, int);
void		 ca_newpass(char *, char *);
char		*ca_readpass(char *, size_t *);
int		 fcopy(char *, char *, mode_t);
void		 fcopy_env(const char *, const char *, mode_t);
int		 rm_dir(char *);
void		 ca_hier(char *);
void		 ca_setenv(const char *, const char *);
void		 ca_clrenv(void);
void		 ca_setcnf(struct ca *, const char *);
void		 ca_create_index(struct ca *);

/* util.c */
int		 expand_string(char *, size_t, const char *, const char *);

int
ca_delete(struct ca *ca)
{
	return (rm_dir(ca->sslpath));
}

int
ca_key_create(struct ca *ca, char *keyname)
{
	struct stat		 st;
	char			 cmd[PATH_MAX * 2];
	char			 path[PATH_MAX];

	snprintf(path, sizeof(path), "%s/private/%s.key", ca->sslpath, keyname);

	/* don't recreate key if one is already present */
	if (stat(path, &st) == 0) {
		return (0);
	}

	snprintf(cmd, sizeof(cmd),
	    "%s genrsa -out %s 2048",
	    PATH_OPENSSL, path);
	system(cmd);
	chmod(path, 0600);

	return (0);
}

int
ca_key_import(struct ca *ca, char *keyname, char *import)
{
	struct stat		 st;
	char			 dst[PATH_MAX];

	if (stat(import, &st) != 0) {
		warn("could not access keyfile %s", import);
		return (1);
	}

	snprintf(dst, sizeof(dst), "%s/private/%s.key", ca->sslpath, keyname);
	fcopy(import, dst, 0600);

	return (0);
}

int
ca_key_delete(struct ca *ca, char *keyname)
{
	char			 path[PATH_MAX];

	snprintf(path, sizeof(path), "%s/private/%s.key", ca->sslpath, keyname);
	unlink(path);

	return (0);
}

int
ca_delkey(struct ca *ca, char *keyname)
{
	char		file[PATH_MAX];

	snprintf(file, sizeof(file), "%s/%s.crt", ca->sslpath, keyname);
	unlink(file);

	snprintf(file, sizeof(file), "%s/private/%s.key", ca->sslpath, keyname);
	unlink(file);

	snprintf(file, sizeof(file), "%s/private/%s.csr", ca->sslpath, keyname);
	unlink(file);

	snprintf(file, sizeof(file), "%s/private/%s.pfx", ca->sslpath, keyname);
	unlink(file);

	return (0);
}

int
ca_request(struct ca *ca, char *keyname, int type)
{
	char		cmd[PATH_MAX * 2];
	char		hostname[HOST_NAME_MAX+1];
	char		name[128];
	char		path[PATH_MAX];

	ca_setenv("$ENV::CERT_CN", keyname);

	strlcpy(name, keyname, sizeof(name));

	if (type == HOST_IPADDR) {
		ca_setenv("$ENV::CERTIP", name);
		ca_setenv("$ENV::REQ_EXT", "x509v3_IPAddr");
	} else if (type == HOST_FQDN) {
		if (!strcmp(keyname, "local")) {
			if (gethostname(hostname, sizeof(hostname)))
				err(1, "gethostname");
			strlcpy(name, hostname, sizeof(name));
		}
		ca_setenv("$ENV::CERTFQDN", name);
		ca_setenv("$ENV::REQ_EXT", "x509v3_FQDN");
	} else {
		errx(1, "unknown host type %d", type);
	}

	ca_setcnf(ca, keyname);

	snprintf(path, sizeof(path), "%s/private/%s.csr", ca->sslpath, keyname);
	snprintf(cmd, sizeof(cmd), "%s req %s-new"
	    " -key %s/private/%s.key -out %s -config %s",
	    PATH_OPENSSL, ca->batch, ca->sslpath, keyname,
	    path, ca->sslcnf);

	system(cmd);
	chmod(path, 0600);

	return (0);
}

int
ca_sign(struct ca *ca, char *keyname, int type)
{
	char		cmd[PATH_MAX * 2];
	const char	*extensions = NULL;

	if (type == HOST_IPADDR) {
		extensions = "x509v3_IPAddr";
	} else if (type == HOST_FQDN) {
		extensions = "x509v3_FQDN";
	} else {
		errx(1, "unknown host type %d", type);
	}

	ca_create_index(ca);

	ca_setenv("$ENV::CADB", ca->index);
	ca_setenv("$ENV::CASERIAL", ca->serial);
	ca_setcnf(ca, keyname);

	snprintf(cmd, sizeof(cmd),
	    "%s ca -config %s -keyfile %s/private/ca.key"
	    " -cert %s/ca.crt"
	    " -extfile %s -extensions %s -out %s/%s.crt"
	    " -in %s/private/%s.csr"
	    " -passin file:%s -outdir %s -batch",
	    PATH_OPENSSL, ca->sslcnf, ca->sslpath,
	    ca->sslpath,
	    ca->extcnf, extensions, ca->sslpath, keyname,
	    ca->sslpath, keyname,
	    ca->passfile, ca->sslpath);

	system(cmd);

	return (0);
}

int
ca_certificate(struct ca *ca, char *keyname, int type, int action)
{
	ca_clrenv();

	switch (action) {
	case CA_SERVER:
		ca_setenv("$ENV::EXTCERTUSAGE", "serverAuth");
		ca_setenv("$ENV::NSCERTTYPE", "server");
		ca_setenv("$ENV::CERTUSAGE",
		    "digitalSignature,keyEncipherment");
		break;
	case CA_CLIENT:
		ca_setenv("$ENV::EXTCERTUSAGE", "clientAuth");
		ca_setenv("$ENV::NSCERTTYPE", "client");
		ca_setenv("$ENV::CERTUSAGE",
		    "digitalSignature,keyAgreement");
		break;
	case CA_OCSP:
		ca_setenv("$ENV::EXTCERTUSAGE", "OCSPSigning");
		ca_setenv("$ENV::CERTUSAGE",
		    "nonRepudiation,digitalSignature,keyEncipherment");
		break;
	default:
		break;
	}

	ca_key_create(ca, keyname);
	ca_request(ca, keyname, type);
	ca_sign(ca, keyname, type);

	return (0);
}

int
ca_key_install(struct ca *ca, char *keyname, char *dir)
{
	struct stat	 st;
	char		 cmd[PATH_MAX * 2];
	char		 src[PATH_MAX];
	char		 dst[PATH_MAX];
	char		*p = NULL;

	snprintf(src, sizeof(src), "%s/private/%s.key", ca->sslpath, keyname);
	if (stat(src, &st) == -1) {
		if (errno == ENOENT)
			printf("key for '%s' does not exist\n", ca->caname);
		else
			warn("could not access key");
		return (1);
	}

	if (dir == NULL)
		p = dir = strdup(KEYBASE);

	ca_hier(dir);

	snprintf(dst, sizeof(dst), "%s/private/local.key", dir);
	fcopy(src, dst, 0600);

	snprintf(cmd, sizeof(cmd), "%s rsa -out %s/local.pub"
	    " -in %s/private/local.key -pubout", PATH_OPENSSL, dir, dir);
	system(cmd);

	free(p);

	return (0);
}

int
ca_cert_install(struct ca *ca, char *keyname, char *dir)
{
	char		 src[PATH_MAX];
	char		 dst[PATH_MAX];
	int		 r;
	char		*p = NULL;

	if (dir == NULL)
		p = dir = strdup(KEYBASE);

	ca_hier(dir);

	if ((r = ca_key_install(ca, keyname, dir)) != 0) {
		free(dir);
		return (r);
	}

	snprintf(src, sizeof(src), "%s/%s.crt", ca->sslpath, keyname);
	snprintf(dst, sizeof(dst), "%s/certs/%s.crt", dir, keyname);
	fcopy(src, dst, 0644);

	free(p);

	return (0);
}

void
ca_newpass(char *passfile, char *password)
{
	FILE	*f;
	char	*pass;
	char	 prev[_PASSWORD_LEN + 1];

	if (password != NULL) {
		pass = password;
		goto done;
	}

	pass = getpass("CA passphrase:");
	if (pass == NULL || *pass == '\0')
		err(1, "password not set");

	strlcpy(prev, pass, sizeof(prev));
	pass = getpass("Retype CA passphrase:");
	if (pass == NULL || strcmp(prev, pass) != 0)
		errx(1, "passphrase does not match!");

 done:
	if ((f = fopen(passfile, "wb")) == NULL)
		err(1, "could not open passfile %s", passfile);
	chmod(passfile, 0600);

	fprintf(f, "%s\n%s\n", pass, pass);

	fclose(f);
}

int
ca_create(struct ca *ca)
{
	char			 cmd[PATH_MAX * 2];
	char			 path[PATH_MAX];

	ca_clrenv();

	snprintf(path, sizeof(path), "%s/private/ca.key", ca->sslpath);
	snprintf(cmd, sizeof(cmd), "%s genrsa -aes256 -out"
	    " %s -passout file:%s 2048", PATH_OPENSSL,
	    path, ca->passfile);
	system(cmd);
	chmod(path, 0600);

	ca_setenv("$ENV::CERT_CN", "VPN CA");
	ca_setcnf(ca, "ca");

	snprintf(path, sizeof(path), "%s/private/ca.csr", ca->sslpath);
	snprintf(cmd, sizeof(cmd), "%s req %s-new"
	    " -key %s/private/ca.key"
	    " -config %s -out %s -passin file:%s", PATH_OPENSSL,
	    ca->batch, ca->sslpath, ca->sslcnf, path, ca->passfile);
	system(cmd);
	chmod(path, 0600);

	snprintf(cmd, sizeof(cmd), "%s x509 -req -days 365"
	    " -in %s/private/ca.csr -signkey %s/private/ca.key"
	    " -sha256"
	    " -extfile %s -extensions x509v3_CA -out %s/ca.crt -passin file:%s",
	    PATH_OPENSSL, ca->sslpath, ca->sslpath, ca->extcnf, ca->sslpath,
	    ca->passfile);
	system(cmd);

	/* Create the CRL revocation list */
	ca_revoke(ca, NULL);

	return (0);
}

int
ca_install(struct ca *ca, char *dir)
{
	struct stat	 st;
	char		 src[PATH_MAX];
	char		 dst[PATH_MAX];
	char		*p = NULL;

	snprintf(src, sizeof(src), "%s/ca.crt", ca->sslpath);
	if (stat(src, &st) == -1) {
		printf("CA '%s' does not exist\n", ca->caname);
		return (1);
	}

	if (dir == NULL)
		p = dir = strdup(KEYBASE);

	ca_hier(dir);

	snprintf(dst, sizeof(dst), "%s/ca/ca.crt", dir);
	if (fcopy(src, dst, 0644) == 0)
		printf("certificate for CA '%s' installed into %s\n",
		    ca->caname, dst);

	snprintf(src, sizeof(src), "%s/ca.crl", ca->sslpath);
	if (stat(src, &st) == 0) {
		snprintf(dst, sizeof(dst), "%s/crls/ca.crl", dir);
		if (fcopy(src, dst, 0644) == 0)
			printf("CRL for CA '%s' installed to %s\n",
			    ca->caname, dst);
	}

	free(p);

	return (0);
}

int
ca_show_certs(struct ca *ca, char *name)
{
	DIR		*dir;
	struct dirent	*de;
	char		 cmd[PATH_MAX * 2];
	char		 path[PATH_MAX];
	char		*p;
	struct stat	 st;

	if (name != NULL) {
		snprintf(path, sizeof(path), "%s/%s.crt",
		    ca->sslpath, name);
		if (stat(path, &st) != 0)
			err(1, "could not open file %s.crt", name);
		snprintf(cmd, sizeof(cmd), "%s x509 -text"
		    " -in %s", PATH_OPENSSL, path);
		system(cmd);
		printf("\n");
		return (0);
	}

	if ((dir = opendir(ca->sslpath)) == NULL)
		err(1, "could not open directory %s", ca->sslpath);

	while ((de = readdir(dir)) != NULL) {
		if (de->d_namlen > 4) {
			p = de->d_name + de->d_namlen - 4;
			if (strcmp(".crt", p) != 0)
				continue;
			snprintf(path, sizeof(path), "%s/%s", ca->sslpath,
			    de->d_name);
			snprintf(cmd, sizeof(cmd), "%s x509 -subject"
			    " -fingerprint -dates -noout -in %s",
			    PATH_OPENSSL, path);
			system(cmd);
			printf("\n");
		}
	}

	closedir(dir);

	return (0);
}

int
fcopy(char *src, char *dst, mode_t mode)
{
	int		ifd, ofd;
	uint8_t		buf[BUFSIZ];
	ssize_t		r;

	if ((ifd = open(src, O_RDONLY)) == -1)
		err(1, "open %s", src);

	if ((ofd = open(dst, O_WRONLY|O_CREAT|O_TRUNC, mode)) == -1) {
		int saved_errno = errno;
		close(ifd);
		errc(1, saved_errno, "open %s", dst);
	}

	while ((r = read(ifd, buf, sizeof(buf))) > 0) {
		write(ofd, buf, r);
	}

	close(ofd);
	close(ifd);

	return (r == -1);
}

void
fcopy_env(const char *src, const char *dst, mode_t mode)
{
	int		 ofd = -1, i;
	uint8_t		 buf[BUFSIZ];
	ssize_t		 r = -1, len;
	FILE		*ifp = NULL;
	int		 saved_errno;

	if ((ifp = fopen(src, "r")) == NULL)
		err(1, "fopen %s", src);

	if ((ofd = open(dst, O_WRONLY|O_CREAT|O_TRUNC, mode)) == -1)
		goto done;

	while (fgets(buf, sizeof(buf), ifp) != NULL) {
		for (i = 0; ca_env[i][0] != NULL; i++) {
			if (ca_env[i][1] == NULL)
				continue;
			if (expand_string(buf, sizeof(buf),
			    ca_env[i][0], ca_env[i][1]) == -1)
				errx(1, "env %s value too long", ca_env[i][0]);
		}
		len = strlen(buf);
		if (write(ofd, buf, len) != len)
			goto done;
	}

	r = 0;

 done:
	saved_errno = errno;
	close(ofd);
	if (ifp != NULL)
		fclose(ifp);
	if (r == -1)
		errc(1, saved_errno, "open %s", dst);
}

int
rm_dir(char *path)
{
	FTS		*fts;
	FTSENT		*p;
	static char	*fpath[] = { NULL, NULL };

	fpath[0] = path;
	if ((fts = fts_open(fpath, FTS_PHYSICAL, NULL)) == NULL) {
		warn("fts_open %s", path);
		return (1);
	}

	while ((p = fts_read(fts)) != NULL) {
		switch (p->fts_info) {
		case FTS_DP:
		case FTS_DNR:
			if (rmdir(p->fts_accpath) == -1)
				warn("rmdir %s", p->fts_accpath);
			break;
		case FTS_F:
			if (unlink(p->fts_accpath) == -1)
				warn("unlink %s", p->fts_accpath);
			break;
		case FTS_D:
		case FTS_DOT:
		default:
			continue;
		}
	}
	fts_close(fts);

	return (0);
}

void
ca_hier(char *path)
{
	struct stat	 st;
	char		 dst[PATH_MAX];
	unsigned int	 i;

	for (i = 0; i < nitems(hier); i++) {
		strlcpy(dst, path, sizeof(dst));
		strlcat(dst, hier[i].dir, sizeof(dst));
		if (stat(dst, &st) != 0 && errno == ENOENT &&
		    mkdir(dst, hier[i].mode) != 0)
			err(1, "failed to create dir %s", dst);
	}
}

int
ca_export(struct ca *ca, char *keyname, char *myname, char *password)
{
	DIR		*dexp;
	struct dirent	*de;
	struct stat	 st;
	char		*pass;
	char		 prev[_PASSWORD_LEN + 1];
	char		 cmd[PATH_MAX * 2];
	char		 oname[PATH_MAX];
	char		 src[PATH_MAX];
	char		 dst[PATH_MAX];
	char		*p;
	char		 tpl[] = "/tmp/ikectl.XXXXXXXXXX";
	unsigned int	 i;
	int		 fd;

	if (keyname != NULL) {
		if (strlcpy(oname, keyname, sizeof(oname)) >= sizeof(oname))
			errx(1, "name too long");
	} else {
		strlcpy(oname, "ca", sizeof(oname));
	}

	/* colons are not valid characters in windows filenames... */
	while ((p = strchr(oname, ':')) != NULL)
		*p = '_';

	if (password != NULL)
		pass = password;
	else {
		pass = getpass("Export passphrase:");
		if (pass == NULL || *pass == '\0')
			err(1, "password not set");

		strlcpy(prev, pass, sizeof(prev));
		pass = getpass("Retype export passphrase:");
		if (pass == NULL || strcmp(prev, pass) != 0)
			errx(1, "passphrase does not match!");
	}

	if (keyname != NULL) {
		snprintf(cmd, sizeof(cmd), "env EXPASS=%s %s pkcs12 -export"
		    " -name %s -CAfile %s/ca.crt -inkey %s/private/%s.key"
		    " -in %s/%s.crt -out %s/private/%s.pfx -passout env:EXPASS"
		    " -passin file:%s", pass, PATH_OPENSSL, keyname,
		    ca->sslpath, ca->sslpath, keyname, ca->sslpath, keyname,
		    ca->sslpath, oname, ca->passfile);
		system(cmd);
	}

	snprintf(cmd, sizeof(cmd), "env EXPASS=%s %s pkcs12 -export"
	    " -caname '%s' -name '%s' -cacerts -nokeys"
	    " -in %s/ca.crt -out %s/ca.pfx -passout env:EXPASS -passin file:%s",
	    pass, PATH_OPENSSL, ca->caname, ca->caname, ca->sslpath,
	    ca->sslpath, ca->passfile);
	system(cmd);

	if ((p = mkdtemp(tpl)) == NULL)
		err(1, "could not create temp dir");

	chmod(p, 0755);

	for (i = 0; i < nitems(hier); i++) {
		strlcpy(dst, p, sizeof(dst));
		strlcat(dst, hier[i].dir, sizeof(dst));
		if (stat(dst, &st) != 0 && errno == ENOENT &&
		    mkdir(dst, hier[i].mode) != 0)
			err(1, "failed to create dir %s", dst);
	}

	/* create a file with the address of the peer to connect to */
	if (myname != NULL) {
		snprintf(dst, sizeof(dst), "%s/export/peer.txt", p);
		if ((fd = open(dst, O_WRONLY|O_CREAT, 0644)) == -1)
			err(1, "open %s", dst);
		write(fd, myname, strlen(myname));
		close(fd);
	}

	snprintf(src, sizeof(src), "%s/ca.pfx", ca->sslpath);
	snprintf(dst, sizeof(dst), "%s/export/ca.pfx", p);
	fcopy(src, dst, 0644);

	snprintf(src, sizeof(src), "%s/ca.crt", ca->sslpath);
	snprintf(dst, sizeof(dst), "%s/ca/ca.crt", p);
	fcopy(src, dst, 0644);

	snprintf(src, sizeof(src), "%s/ca.crl", ca->sslpath);
	if (stat(src, &st) == 0) {
		snprintf(dst, sizeof(dst), "%s/crls/ca.crl", p);
		fcopy(src, dst, 0644);
	}

	if (keyname != NULL) {
		snprintf(src, sizeof(src), "%s/private/%s.pfx", ca->sslpath,
		    oname);
		snprintf(dst, sizeof(dst), "%s/export/%s.pfx", p, oname);
		fcopy(src, dst, 0644);

		snprintf(src, sizeof(src), "%s/private/%s.key", ca->sslpath,
		    keyname);
		snprintf(dst, sizeof(dst), "%s/private/%s.key", p, keyname);
		fcopy(src, dst, 0600);
		snprintf(dst, sizeof(dst), "%s/private/local.key", p);
		fcopy(src, dst, 0600);

		snprintf(src, sizeof(src), "%s/%s.crt", ca->sslpath, keyname);
		snprintf(dst, sizeof(dst), "%s/certs/%s.crt", p, keyname);
		fcopy(src, dst, 0644);

		snprintf(cmd, sizeof(cmd), "%s rsa -out %s/local.pub"
		    " -in %s/private/%s.key -pubout", PATH_OPENSSL, p,
		    ca->sslpath, keyname);
		system(cmd);
	}

	if (stat(PATH_TAR, &st) == 0) {
		if (keyname == NULL)
			snprintf(cmd, sizeof(cmd), "%s -zcf %s.tgz -C %s .",
			    PATH_TAR, oname, ca->sslpath);
		else
			snprintf(cmd, sizeof(cmd), "%s -zcf %s.tgz -C %s .",
			    PATH_TAR, oname, p);
		system(cmd);
		snprintf(src, sizeof(src), "%s.tgz", oname);
		if (realpath(src, dst) != NULL)
			printf("exported files in %s\n", dst);
	}

	if (stat(PATH_ZIP, &st) == 0) {
		dexp = opendir(EXPDIR);
		if (dexp) {
			while ((de = readdir(dexp)) != NULL) {
				if (!strcmp(de->d_name, ".") ||
				    !strcmp(de->d_name, ".."))
					continue;
				snprintf(src, sizeof(src), "%s/%s", EXPDIR,
				    de->d_name);
				snprintf(dst, sizeof(dst), "%s/export/%s", p,
				    de->d_name);
				fcopy(src, dst, 0644);
			}
			closedir(dexp);
		}

		snprintf(dst, sizeof(dst), "%s/export", p);
		if (getcwd(src, sizeof(src)) == NULL)
			err(1, "could not get cwd");

		if (chdir(dst) == -1)
			err(1, "could not change %s", dst);

		snprintf(dst, sizeof(dst), "%s/%s.zip", src, oname);
		snprintf(cmd, sizeof(cmd), "%s -qr %s .", PATH_ZIP, dst);
		system(cmd);
		printf("exported files in %s\n", dst);

		if (chdir(src) == -1)
			err(1, "could not change %s", dst);
	}

	rm_dir(p);

	return (0);
}

char *
ca_readpass(char *path, size_t *len)
{
	FILE		*f;
	char		*p, *r;

	if ((f = fopen(path, "r")) == NULL) {
		warn("fopen %s", path);
		return (NULL);
	}

	if ((p = fgetln(f, len)) != NULL) {
		if ((r = malloc(*len + 1)) == NULL)
			err(1, "malloc");
		memcpy(r, p, *len);
		if (r[*len - 1] == '\n')
			r[*len - 1] = '\0';
		else
			r[*len] = '\0';
	} else
		r = NULL;

	fclose(f);

	return (r);
}

/* create index if it doesn't already exist */
void
ca_create_index(struct ca *ca)
{
	struct stat	 st;
	int		 fd;

	if (snprintf(ca->index, sizeof(ca->index), "%s/index.txt",
	    ca->sslpath) < 0)
		err(1, "snprintf");
	if (stat(ca->index, &st) != 0) {
		if  (errno == ENOENT) {
			if ((fd = open(ca->index, O_WRONLY | O_CREAT, 0644))
			    == -1)
				err(1, "could not create file %s", ca->index);
			close(fd);
		} else
			err(1, "could not access %s", ca->index);
	}

	if (snprintf(ca->serial, sizeof(ca->serial), "%s/serial.txt",
	    ca->sslpath) < 0)
		err(1, "snprintf");
	if (stat(ca->serial, &st) != 0) {
		if  (errno == ENOENT) {
			if ((fd = open(ca->serial, O_WRONLY | O_CREAT, 0644))
			    == -1)
				err(1, "could not create file %s", ca->serial);
			/* serial file must be created with a number */
			if (write(fd, "01\n", 3) != 3)
				err(1, "write %s", ca->serial);
			close(fd);
		} else
			err(1, "could not access %s", ca->serial);
	}
}

int
ca_revoke(struct ca *ca, char *keyname)
{
	struct stat	 st;
	char		 cmd[PATH_MAX * 2];
	char		 path[PATH_MAX];
	char		*pass;
	size_t		 len;

	if (keyname) {
		snprintf(path, sizeof(path), "%s/%s.crt",
		    ca->sslpath, keyname);
		if (stat(path, &st) != 0) {
			warn("Problem with certificate for '%s'", keyname);
			return (1);
		}
	}

	snprintf(path, sizeof(path), "%s/ikeca.passwd", ca->sslpath);
	pass = ca_readpass(path, &len);
	if (pass == NULL)
		errx(1, "could not open passphrase file");

	ca_create_index(ca);

	ca_setenv("$ENV::CADB", ca->index);
	ca_setenv("$ENV::CASERIAL", ca->serial);
	ca_setcnf(ca, "ca-revoke");

	if (keyname) {
		snprintf(cmd, sizeof(cmd),
		    "%s ca %s-config %s -keyfile %s/private/ca.key"
		    " -key %s"
		    " -cert %s/ca.crt"
		    " -revoke %s/%s.crt",
		    PATH_OPENSSL, ca->batch, ca->sslcnf,
		    ca->sslpath, pass, ca->sslpath, ca->sslpath, keyname);
		system(cmd);
	}

	snprintf(cmd, sizeof(cmd),
	    "%s ca %s-config %s -keyfile %s/private/ca.key"
	    " -key %s"
	    " -gencrl"
	    " -cert %s/ca.crt"
	    " -crldays 365"
	    " -out %s/ca.crl",
	    PATH_OPENSSL, ca->batch, ca->sslcnf, ca->sslpath,
	    pass, ca->sslpath, ca->sslpath);
	system(cmd);

	explicit_bzero(pass, len);
	free(pass);

	return (0);
}

void
ca_clrenv(void)
{
	int	 i;
	for (i = 0; ca_env[i][0] != NULL; i++)
		ca_env[i][1] = NULL;
}

void
ca_setenv(const char *key, const char *value)
{
	int	 i;

	for (i = 0; ca_env[i][0] != NULL; i++) {
		if (strcmp(ca_env[i][0], key) == 0) {
			if (ca_env[i][1] != NULL)
				errx(1, "env %s already set: %s", key, value);
			ca_env[i][1] = value;
			return;
		}
	}
	errx(1, "env %s invalid", key);
}

void
ca_setcnf(struct ca *ca, const char *keyname)
{
	struct stat	 st;
	const char	*extcnf, *sslcnf;

	if (stat(IKECA_CNF, &st) == 0) {
		extcnf = IKECA_CNF;
		sslcnf = IKECA_CNF;
	} else {
		extcnf = X509_CNF;
		sslcnf = SSL_CNF;
	}

	snprintf(ca->extcnf, sizeof(ca->extcnf), "%s/%s-ext.cnf",
	    ca->sslpath, keyname);
	snprintf(ca->sslcnf, sizeof(ca->sslcnf), "%s/%s-ssl.cnf",
	    ca->sslpath, keyname);

	fcopy_env(extcnf, ca->extcnf, 0400);
	fcopy_env(sslcnf, ca->sslcnf, 0400);
}

struct ca *
ca_setup(char *caname, int create, int quiet, char *pass)
{
	struct stat	 st;
	struct ca	*ca;
	char		 path[PATH_MAX];

	if (stat(PATH_OPENSSL, &st) == -1)
		err(1, "openssl binary not available");

	if ((ca = calloc(1, sizeof(struct ca))) == NULL)
		err(1, "calloc");

	ca->caname = strdup(caname);
	snprintf(ca->sslpath, sizeof(ca->sslpath), SSLDIR "/%s", caname);
	strlcpy(ca->passfile, ca->sslpath, sizeof(ca->passfile));
	strlcat(ca->passfile, "/ikeca.passwd", sizeof(ca->passfile));

	if (quiet)
		strlcpy(ca->batch, "-batch ", sizeof(ca->batch));

	if (create == 0 && stat(ca->sslpath, &st) == -1) {
		free(ca->caname);
		free(ca);
		errx(1, "CA '%s' does not exist", caname);
	}

	strlcpy(path, ca->sslpath, sizeof(path));
	if (mkdir(path, 0777) == -1 && errno != EEXIST)
		err(1, "failed to create dir %s", path);
	strlcat(path, "/private", sizeof(path));
	if (mkdir(path, 0700) == -1 && errno != EEXIST)
		err(1, "failed to create dir %s", path);

	if (create && stat(ca->passfile, &st) == -1 && errno == ENOENT)
		ca_newpass(ca->passfile, pass);

	return (ca);
}
@


1.40
log
@switch from using sha1 to sha256

As the ca section of the cnf file requires a default_md line
(unlike req) this change also requires updating the installed ikeca.cnf
or equivalent files.

Requested by and ok reyk@@ who also tested this against ios9 with iked.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.39 2015/11/02 12:01:28 jsg Exp $	*/
d104 1
d109 1
a109 1
int		 ca_request(struct ca *, char *);
d202 1
a202 1
ca_request(struct ca *ca, char *keyname)
d205 2
d210 18
a245 2
	char		hostname[HOST_NAME_MAX+1];
	char		name[128];
a247 2
	strlcpy(name, keyname, sizeof(name));

a248 1
		ca_setenv("$ENV::CERTIP", name);
a250 6
		if (!strcmp(keyname, "local")) {
			if (gethostname(hostname, sizeof(hostname)))
				err(1, "gethostname");
			strlcpy(name, hostname, sizeof(name));
		}
		ca_setenv("$ENV::CERTFQDN", name);
d307 1
a307 1
	ca_request(ca, keyname);
@


1.39
log
@sign csrs with openssl ca instead of x509 -req

This way openssl will add valid signed certs to the index file
which is required to use the builtin openssl OCSP server.

This change requires installing a new ikeca.cnf or updating
the default cnf files with equivalent sections.

Requested by and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.38 2015/11/02 10:27:44 jsg Exp $	*/
d424 1
@


1.38
log
@Accept an ocsp option when creating certificates to set the extended
key usage for OCSP signing.

Requested by and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.37 2015/08/19 21:07:23 reyk Exp $	*/
d67 2
d90 1
d118 1
d246 4
d252 3
a254 3
	snprintf(cmd, sizeof(cmd), "%s x509 -req"
	    " -days 365 -in %s/private/%s.csr"
	    " -CA %s/ca.crt -CAkey %s/private/ca.key -CAcreateserial"
d256 7
a262 4
	    " -passin file:%s",
	    PATH_OPENSSL,
	    ca->sslpath, keyname, ca->sslpath, ca->sslpath,
	    ca->extcnf, extensions, ca->sslpath, keyname, ca->passfile);
d827 37
a869 2
	char		 cadb[PATH_MAX];
	int		 fd;
d887 1
a887 10
	/* create index if it doesn't already exist */
	snprintf(path, sizeof(path), "%s/index.txt", ca->sslpath);
	if (stat(path, &st) != 0) {
		if  (errno == ENOENT) {
			if ((fd = open(path, O_WRONLY | O_CREAT, 0644)) == -1)
				err(1, "could not create file %s", path);
			close(fd);
		} else
			err(1, "could not access %s", path);
	}
d889 2
a890 2
	snprintf(cadb, sizeof(cadb), "%s/index.txt", ca->sslpath);
	ca_setenv("$ENV::CADB", cadb);
a897 1
		    " -md sha1"
a908 1
	    " -md sha1"
@


1.37
log
@ca_hier() und ca_newpass() abort on failure, return void instead of int.

Based on previous observation by semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.36 2015/08/19 21:03:11 reyk Exp $	*/
d275 5
@


1.36
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.35 2015/08/19 21:01:20 reyk Exp $	*/
d106 1
a106 1
int		 ca_newpass(char *, char *);
d111 1
a111 1
int		 ca_hier(char *);
d349 1
a349 1
int
a377 2

	return (0);
d601 1
a601 2

int
a614 2

	return (0);
@


1.35
log
@fcopy_env() should return void as it aborts on failure.

Pointed out by semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.34 2015/08/19 13:30:54 reyk Exp $	*/
d107 1
a107 1
char *		 ca_readpass(char *, size_t *);
@


1.34
log
@Use C99 integer types in ikectl(8).

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.33 2015/08/19 12:25:59 reyk Exp $	*/
d109 1
a109 1
int		 fcopy_env(const char *, const char *, mode_t);
d529 1
a529 1
int
a565 2

	return (0);
@


1.33
log
@Support for overwriting $ENV:: variables in OpenSSL .cnf files from
the environment has been removed in LibreSSL.  This was a good step
but it unintentionally broke the "ikectl ca" commands.  Rework the
implementation for copying the .cnf files and expanding the $ENV::
variables ourselves before passing the generated .cnf file to the
"openssl" command.

Reported and tested by Jona Joachim (thanks!)
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.32 2015/08/15 04:47:28 semarie Exp $	*/
d507 1
a507 1
	u_int8_t	buf[BUFSIZ];
d533 1
a533 1
	u_int8_t	 buf[BUFSIZ];
d611 1
a611 1
	u_int		 i;
d638 1
a638 1
	u_int		 i;
@


1.32
log
@correct mode_t 644 to 0644

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.31 2015/08/15 04:45:49 semarie Exp $	*/
d85 20
a104 1
int		 ca_sign(struct ca *, char *, int, char *);
d109 1
d112 6
d202 3
d206 1
a206 1
	snprintf(cmd, sizeof(cmd), "env CERT_CN=%s %s req %s-new"
d208 1
a208 1
	    keyname, PATH_OPENSSL, ca->batch, ca->sslpath, keyname,
d218 1
a218 1
ca_sign(struct ca *ca, char *keyname, int type, char *envargs)
d223 1
a226 3
	if (envargs == NULL)
		envargs = "";

d228 2
a229 7
		snprintf(cmd, sizeof(cmd), "env CERTIP=%s%s %s x509 -req"
		    " -days 365 -in %s/private/%s.csr"
		    " -CA %s/ca.crt -CAkey %s/private/ca.key -CAcreateserial"
		    " -extfile %s -extensions x509v3_IPAddr -out %s/%s.crt"
		    " -passin file:%s", name, envargs, PATH_OPENSSL,
		    ca->sslpath, keyname, ca->sslpath, ca->sslpath,
		    ca->extcnf, ca->sslpath, keyname, ca->passfile);
d236 3
a238 8
		snprintf(cmd, sizeof(cmd), "env CERTFQDN=%s%s %s x509 -req"
		    " -days 365 -in %s/private/%s.csr"
		    " -CA %s/ca.crt -CAkey %s/private/ca.key -CAcreateserial"
		    " -extfile %s -extensions x509v3_FQDN -out %s/%s.crt"
		    " -passin file:%s", name, envargs, PATH_OPENSSL,
		    ca->sslpath, keyname, ca->sslpath, ca->sslpath,
		    ca->extcnf, ca->sslpath, keyname, ca->passfile);
	} else
d240 12
d261 1
a261 1
	char	*envargs = "";
d265 4
a268 2
		envargs = " EXTCERTUSAGE=serverAuth NSCERTTYPE=server"
		    " CERTUSAGE=digitalSignature,keyEncipherment";
d271 4
a274 2
		envargs = " EXTCERTUSAGE=clientAuth NSCERTTYPE=client"
		    " CERTUSAGE=digitalSignature,keyAgreement";
d282 1
a282 1
	ca_sign(ca, keyname, type, envargs);
d388 2
d397 3
d401 1
a401 1
	snprintf(cmd, sizeof(cmd), "env CERT_CN='VPN CA' %s req %s-new"
d530 41
d824 1
d854 4
d859 2
a860 2
		snprintf(cmd, sizeof(cmd), "env CADB='%s/index.txt' "
		    " %s ca %s-config %s -keyfile %s/private/ca.key"
d865 1
a865 1
		    ca->sslpath, PATH_OPENSSL, ca->batch, ca->sslcnf,
d870 2
a871 2
	snprintf(cmd, sizeof(cmd), "env CADB='%s/index.txt' "
	    " %s ca %s-config %s -keyfile %s/private/ca.key"
d878 1
a878 1
	    ca->sslpath, PATH_OPENSSL, ca->batch, ca->sslcnf, ca->sslpath,
d888 47
a954 8

	if (stat(IKECA_CNF, &st) == 0) {
		strlcpy(ca->extcnf, IKECA_CNF, sizeof(ca->extcnf));
		strlcpy(ca->sslcnf, IKECA_CNF, sizeof(ca->sslcnf));
	} else {
		strlcpy(ca->extcnf, X509_CNF, sizeof(ca->extcnf));
		strlcpy(ca->sslcnf, SSL_CNF, sizeof(ca->sslcnf));
	}
@


1.31
log
@corrects three err() to errx() calls
  - a if condition don't set errno
  - strlcpy(3) don't set errno (no mention is man page)
  - ca_readpass() already manage errno error message with warn(3)

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.30 2015/01/16 06:40:17 deraadt Exp $	*/
d686 1
a686 1
				fcopy(src, dst, 644);
@


1.30
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.29 2014/08/26 17:47:24 jsing Exp $	*/
d222 1
a222 1
		err(1, "unknown host type %d", type);
d564 1
a564 1
			err(1, "name too long");
d761 1
a761 1
		err(1, "could not open passphrase file");
@


1.29
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.28 2014/08/25 07:50:26 doug Exp $	*/
a18 1
#include <sys/param.h>
d31 1
d192 1
a192 1
	char		hostname[MAXHOSTNAMELEN];
@


1.28
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.27 2014/07/20 01:38:40 guenther Exp $	*/
d55 1
a55 1
#define PATH_OPENSSL	"/usr/sbin/openssl"
@


1.27
log
@Make sure the correct errno is reported by warn* or err* and not
the errno of an intervening cleanup operation like close/unlink/etc.

Diff from Doug Hogan (doug (at) acyclic.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.26 2014/04/18 21:29:20 tedu Exp $	*/
d798 1
a798 1
	bzero(pass, len);
@


1.26
log
@round up some enemy sympathizers found calling RAND_seed().
ok beck reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.25 2013/01/08 10:38:19 reyk Exp $	*/
d476 1
d478 1
a478 1
		err(1, "open %s", dst);
@


1.25
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.24 2012/12/08 12:51:46 mikeb Exp $	*/
a808 1
	u_int32_t	 rnd[256];
a846 3

	arc4random_buf(rnd, sizeof(rnd));
	RAND_seed(rnd, sizeof(rnd));
@


1.24
log
@don't forget to include a path separator after an SSLDIR;
reported by david hill
@
text
@d1 1
a1 2
/*	$OpenBSD: ikeca.c,v 1.23 2012/10/23 14:36:18 reyk Exp $	*/
/*	$vantronix: ikeca.c,v 1.13 2010/06/03 15:52:52 reyk Exp $	*/
@


1.23
log
@Allow to overwrite a few more definitions like file paths from the
Makefile.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.22 2012/09/18 12:07:59 reyk Exp $	*/
d819 1
a819 2
	strlcpy(ca->sslpath, SSLDIR, sizeof(ca->sslpath));
	strlcat(ca->sslpath, caname, sizeof(ca->sslpath));
@


1.22
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.21 2012/07/08 11:48:20 deraadt Exp $	*/
d41 13
a53 5
#define SSL_CNF		"/etc/ssl/openssl.cnf"
#define X509_CNF	"/etc/ssl/x509v3.cnf"
#define IKECA_CNF	"/etc/ssl/ikeca.cnf"
#define KEYBASE		"/etc/iked"
#define EXPDIR		"/usr/share/iked"
d55 1
d57 2
d60 2
d63 1
d819 1
a819 1
	strlcpy(ca->sslpath, "/etc/ssl/", sizeof(ca->sslpath));
@


1.21
log
@if you use nitems() in userland, you must define it yourself
discussed with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.20 2011/05/27 12:01:02 reyk Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Jonathan Gray <jsg@@vantronix.net>
@


1.20
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.19 2010/10/08 16:15:22 reyk Exp $	*/
d38 1
@


1.19
log
@set the client/server certificate options with all the common keyusage
and extendedkeyusage and nscerttype flags.  the ikectl CA can now be used
with all kinds of other vpn tools in addition to iked and isakmpd.

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.18 2010/10/08 15:45:34 jsg Exp $	*/
d207 2
a208 2
	} else 
	    err(1, "unknown host type %d", type);
d236 1
a236 1
	
d376 1
a376 1
	
d575 3
a577 3
		    " -passin file:%s", pass, PATH_OPENSSL, keyname, ca->sslpath,
		    ca->sslpath, keyname, ca->sslpath, keyname, ca->sslpath,
		    oname, ca->passfile);
@


1.18
log
@check if a directory exists before trying to create it in the export
case as well, spotted by mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.17 2010/10/08 11:41:56 jsg Exp $	*/
d222 2
a223 1
		envargs = " EXTCERTUSAGE=serverAuth";
d226 2
a227 1
		envargs = " EXTCERTUSAGE=clientAuth";
@


1.17
log
@if non absolute paths are specified in install commands assume they
are relative to /etc
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.16 2010/10/08 10:13:47 jsg Exp $	*/
d594 2
a595 1
		if (mkdir(dst, hier[i].mode) != 0)
@


1.16
log
@allow optional paths for the install commands so we can
install into the isakmpd directory hierarchy for example.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.15 2010/10/08 07:45:06 reyk Exp $	*/
d62 2
a63 1
} exdirs[] = {
d517 1
a517 1
	for (i = 0; i < nitems(exdirs); i++) {
d519 1
a519 1
		strlcat(dst, exdirs[i].dir, sizeof(dst));
d521 1
a521 1
		    mkdir(dst, exdirs[i].mode) != 0)
d591 1
a591 1
	for (i = 0; i < nitems(exdirs); i++) {
d593 2
a594 2
		strlcat(dst, exdirs[i].dir, sizeof(dst));
		if (mkdir(dst, exdirs[i].mode) != 0)
@


1.15
log
@Allow to show certificate details (show ca x cert [y]).
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.14 2010/10/07 15:17:38 jsg Exp $	*/
d59 11
d76 1
d238 1
a238 1
ca_key_install(struct ca *ca, char *keyname)
d240 5
a244 4
	struct stat	st;
	char		cmd[PATH_MAX * 2];
	char		src[PATH_MAX];
	char		dst[PATH_MAX];
d255 6
a260 1
	snprintf(dst, sizeof(dst), "%s/private/local.key", KEYBASE);
d264 1
a264 2
	    " -in %s/private/local.key -pubout", PATH_OPENSSL, KEYBASE,
	    KEYBASE);
d267 1
d273 1
a273 1
ca_cert_install(struct ca *ca, char *keyname)
d275 9
a283 3
	char		src[PATH_MAX];
	char		dst[PATH_MAX];
	int		r;
d285 2
a286 1
	if ((r = ca_key_install(ca, keyname)) != 0)
d288 1
d291 1
a291 1
	snprintf(dst, sizeof(dst), "%s/certs/%s.crt", KEYBASE, keyname);
d294 2
d367 1
a367 1
ca_install(struct ca *ca)
d369 4
a372 3
	struct stat	st;
	char		src[PATH_MAX];
	char		dst[PATH_MAX];
d380 6
a385 1
	snprintf(dst, sizeof(dst), "%s/ca/ca.crt", KEYBASE);
d392 1
a392 1
		snprintf(dst, sizeof(dst), "%s/crls/ca.crl", KEYBASE);
d398 2
d508 19
a542 11

	struct {
		char	*dir;
		mode_t	 mode;
	} exdirs[] = {
		{ "/ca",	0755 },
		{ "/certs",	0755 },
		{ "/crls",	0755 },
		{ "/export",	0755 },
		{ "/private",	0700 }
	};
@


1.14
log
@only try to setup a passfile when creating a CA
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.13 2010/10/07 13:30:50 reyk Exp $	*/
a61 1
int		 ca_show_certs(struct ca *);
d368 1
a368 1
ca_show_certs(struct ca *ca)
d375 13
@


1.13
log
@Allow to specify the export password on the command line (optionally, for
scripting).  The "peer" argument now needs to be preceded with the "peer"
keyword, eg. ... export peer 10.1.1.1 instead of export 10.1.1.1.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.12 2010/10/07 12:23:14 reyk Exp $	*/
d773 1
a773 1
	if (stat(ca->passfile, &st) == -1 && errno == ENOENT)
@


1.12
log
@- add a -q (quiet) command line option that will be used by ikeca to
set openssl batch mode: don't ask for x509 options, use the defaults.
- allow to specify the initial ca password on the command line to also
make it scriptable.
- allow to create certificates for clientAuth or serverAuth only
(eg. ikectl ca foo certificate bar server).
- cosmetics: move double declarations of ca_*() functions to parser.h.

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.11 2010/10/07 10:56:22 phessler Exp $	*/
d461 1
a461 1
ca_export(struct ca *ca, char *keyname, char *myname)
d499 12
a510 8
	pass = getpass("Export passphrase:");
	if (pass == NULL || *pass == '\0')
		err(1, "password not set");

	strlcpy(prev, pass, sizeof(prev));
	pass = getpass("Retype export passphrase:");
	if (pass == NULL || strcmp(prev, pass) != 0)
		errx(1, "passphrase does not match!");
@


1.11
log
@set saner permissions on the directory we export, so we don't change
perms of /etc/iked when extracting

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.10 2010/10/07 09:36:33 phessler Exp $	*/
d55 1
d59 3
a61 16
struct ca	*ca_setup(char *, int);
int		 ca_create(struct ca *);
int		 ca_delete(struct ca *);
int		 ca_delkey(struct ca *, char *);
int		 ca_sign(struct ca *, char *, int);
int		 ca_request(char *, char *, char *);
int		 ca_certificate(struct ca *, char *, int);
int		 ca_cert_install(struct ca *, char *);
int		 ca_key_install(struct ca *, char *);
int		 ca_key_create(struct ca *, char *);
int		 ca_key_delete(struct ca *, char *);
int		 ca_key_import(struct ca *, char *, char *);
int		 ca_newpass(char *);
int		 ca_export(struct ca *, char *, char *);
int		 ca_revoke(struct ca *, char *);
int		 ca_install(struct ca *);
d145 1
a145 1
ca_request(char *sslpath, char *sslcnf, char *keyname)
d150 2
a151 2
	snprintf(path, sizeof(path), "%s/private/%s.csr", sslpath, keyname);
	snprintf(cmd, sizeof(cmd), "env CERT_CN=%s %s req -new"
d153 3
a155 1
	    keyname, PATH_OPENSSL, sslpath, keyname, path, sslcnf);
d163 1
a163 1
ca_sign(struct ca *ca, char *keyname, int type)
d171 3
d175 1
a175 1
		snprintf(cmd, sizeof(cmd), "env CERTIP=%s %s x509 -req"
d179 3
a181 3
		    " -passin file:%s", name, PATH_OPENSSL, ca->sslpath,
		    keyname, ca->sslpath, ca->sslpath, ca->extcnf, ca->sslpath,
		    keyname, ca->passfile);
d188 1
a188 1
		snprintf(cmd, sizeof(cmd), "env CERTFQDN=%s %s x509 -req"
d192 3
a194 3
		    " -passin file:%s", name, PATH_OPENSSL, ca->sslpath,
		    keyname, ca->sslpath, ca->sslpath, ca->extcnf, ca->sslpath,
		    keyname, ca->passfile);
d204 1
a204 1
ca_certificate(struct ca *ca, char *keyname, int type)
d206 13
d220 2
a221 2
	ca_request(ca->sslpath, ca->sslcnf, keyname);
	ca_sign(ca, keyname, type);
d273 1
a273 1
ca_newpass(char *passfile)
d279 5
d293 1
d319 1
a319 1
	snprintf(cmd, sizeof(cmd), "env CERT_CN='VPN CA' %s req -new"
d321 2
a322 2
	    " -config %s -out %s -passin file:%s",
	    PATH_OPENSSL, ca->sslpath, ca->sslcnf, path, ca->passfile);
d697 1
a697 1
		    " %s ca -config %s -keyfile %s/private/ca.key"
d702 2
a703 2
		    ca->sslpath, PATH_OPENSSL,  ca->sslcnf, ca->sslpath, pass,
		    ca->sslpath, ca->sslpath, keyname);
d708 1
a708 1
	    " %s ca -config %s -keyfile %s/private/ca.key"
d715 2
a716 2
	    ca->sslpath, PATH_OPENSSL,  ca->sslcnf, ca->sslpath, pass,
	    ca->sslpath, ca->sslpath);
d726 1
a726 1
ca_setup(char *caname, int create)
a741 1

d745 3
d770 1
a770 1
		ca_newpass(ca->passfile);
@


1.10
log
@When we create a new CA, also create an empty (but valid) CRL list.
While here, set our used defaults in the config file.

OK reyk@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.9 2010/06/23 19:28:18 jsg Exp $	*/
d515 2
@


1.9
log
@fix the permissions on directories inside the exported tarball
in the cert case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.8 2010/06/23 17:10:49 jsg Exp $	*/
d321 3
d656 7
a662 5
	snprintf(path, sizeof(path), "%s/%s.crt",
	    ca->sslpath, keyname);
	if (stat(path, &st) != 0) {
		warn("Problem with certificate for '%s'", keyname);
		return (1);
d681 11
a691 9
	snprintf(cmd, sizeof(cmd), "env CADB='%s/index.txt' "
	    " %s ca -config %s -keyfile %s/private/ca.key"
	    " -key %s"
	    " -cert %s/ca.crt"
	    " -md sha1"
	    " -revoke %s/%s.crt",
	    ca->sslpath, PATH_OPENSSL,  ca->sslcnf, ca->sslpath, pass,
	    ca->sslpath, ca->sslpath, keyname);
	system(cmd);
@


1.8
log
@More appropriate contents for the exported ca tarball.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.7 2010/06/23 16:01:01 jsg Exp $	*/
a458 2
	const char	*exdirs[] = { "/ca", "/certs", "/crls", "/private",
	    		              "/export" };
d462 11
d515 2
a516 2
		strlcat(dst, exdirs[i], sizeof(dst));
		if (mkdir(dst, 0700) != 0)
@


1.7
log
@Add a ca export command for EAP mode where we only require the CA cert,
and make both export commands optionally take an argument that will be
added to a peer.txt file in the exported output.   Additionally
include any site specific notes from /usr/share/iked if present.

man page bits and help with the parser from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.6 2010/06/21 10:48:12 jsg Exp $	*/
a49 7
const char *cafiles[] = {
	"ca.crt",
	"ca.pfx",
	"private/ca.key",
	"private/ca.pfx"
};

a57 1

d464 6
a469 5
	if (keyname != NULL)
		keyname = "ca";

	if (strlcpy(oname, keyname, sizeof(oname)) >= sizeof(oname))
		err(1, "name too long");
d558 6
a563 2
		snprintf(cmd, sizeof(cmd), "%s -zcf %s.tgz -C %s .", PATH_TAR,
		    oname, p);
@


1.6
log
@use the full path to zip
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.5 2010/06/14 17:41:18 jsg Exp $	*/
d44 1
d79 1
a79 1
int		 ca_export(struct ca *, char *);
d254 1
a254 1
	return (1);
d454 1
a454 1
ca_export(struct ca *ca, char *keyname)
d456 2
d470 7
a478 1
	strlcpy(oname, keyname, sizeof(oname));
d491 9
a499 7
	snprintf(cmd, sizeof(cmd), "env EXPASS=%s %s pkcs12 -export"
	    " -name %s -CAfile %s/ca.crt -inkey %s/private/%s.key"
	    " -in %s/%s.crt -out %s/private/%s.pfx -passout env:EXPASS"
	    " -passin file:%s", pass, PATH_OPENSSL, keyname, ca->sslpath,
	    ca->sslpath, keyname, ca->sslpath, keyname, ca->sslpath,
	    oname, ca->passfile);
	system(cmd);
d518 8
a525 3
	snprintf(src, sizeof(src), "%s/private/%s.pfx", ca->sslpath, oname);
	snprintf(dst, sizeof(dst), "%s/export/%s.pfx", p, oname);
	fcopy(src, dst, 0644);
a534 10
	snprintf(src, sizeof(src), "%s/private/%s.key", ca->sslpath, keyname);
	snprintf(dst, sizeof(dst), "%s/private/%s.key", p, keyname);
	fcopy(src, dst, 0600);
	snprintf(dst, sizeof(dst), "%s/private/local.key", p);
	fcopy(src, dst, 0600);

	snprintf(src, sizeof(src), "%s/%s.crt", ca->sslpath, keyname);
	snprintf(dst, sizeof(dst), "%s/certs/%s.crt", p, keyname);
	fcopy(src, dst, 0644);

d541 22
a562 4
	snprintf(cmd, sizeof(cmd), "%s rsa -out %s/local.pub"
	    " -in %s/private/%s.key -pubout", PATH_OPENSSL, p, ca->sslpath,
	    keyname);
	system(cmd);
d574 15
@


1.5
log
@Add commands to create/delete/install/import keys without
involving certificates as suggested by reyk and don't
recreate private keys if a key already exists.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.4 2010/06/10 16:14:04 jsg Exp $	*/
d558 1
a558 1
		snprintf(cmd, sizeof(cmd), "zip -qr %s .", dst);
@


1.4
log
@Add a command to revoke a certificate and generate a CRL;
make the ca install command install the CRL as well.

discussed with reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.3 2010/06/07 14:15:27 jsg Exp $	*/
a67 1
int		 ca_key(char *, char *, char *);
d73 4
d93 1
a93 1
ca_key(char *sslpath, char *caname, char *keyname)
d95 1
d99 6
a104 1
	snprintf(path, sizeof(path), "%s/private/%s.key", sslpath, keyname);
d116 28
d220 1
a220 1
	ca_key(ca->sslpath, ca->caname, keyname);
d228 1
a228 1
ca_cert_install(struct ca *ca, char *keyname)
d252 14
d402 1
a402 1
	if ((ofd = open(dst, O_WRONLY|O_CREAT, mode)) == -1) {
@


1.3
log
@switch iked pki files to /etc/iked, discussed with reyk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.2 2010/06/04 13:34:38 jsg Exp $	*/
d76 1
d79 1
d295 10
a304 2
		printf("certificate for CA '%s' installed into %s\n", ca->caname,
		    dst);
d413 2
a414 1
	const char	*exdirs[] = { "/ca", "/certs", "/private", "/export" };
d478 6
d516 88
@


1.2
log
@Install the cert as well as the keys and make certs world
readable as suggested by reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikeca.c,v 1.1 2010/06/03 16:49:00 reyk Exp $	*/
d43 1
a43 1
#define KEYBASE		"/etc/isakmpd"
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 1
a78 1
int		 fcopy(char *, char *);
d206 1
a206 1
	fcopy(src, dst);
d213 4
d292 1
a292 1
	if (fcopy(src, dst) == 0)
d332 1
a332 1
fcopy(char *src, char *dst)
d341 1
a341 1
	if ((ofd = open(dst, O_WRONLY|O_CREAT, 0600)) == -1) {
d447 1
a447 1
	fcopy(src, dst);
d451 1
a451 1
	fcopy(src, dst);
d455 1
a455 1
	fcopy(src, dst);
d459 1
a459 1
	fcopy(src, dst);
d461 1
a461 1
	fcopy(src, dst);
d465 1
a465 1
	fcopy(src, dst);
@

