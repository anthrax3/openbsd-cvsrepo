head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.8
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.23
date	2015.12.05.13.11.18;	author claudio;	state Exp;
branches;
next	1.22;
commitid	2NFHZgHFRCEWu2WW;

1.22
date	2015.11.06.06.29.11;	author jsg;	state Exp;
branches;
next	1.21;
commitid	JS9M2jtQfZSdL8Ha;

1.21
date	2015.11.02.10.27.44;	author jsg;	state Exp;
branches;
next	1.20;
commitid	oYugXczRgOhXq8hY;

1.20
date	2015.08.19.13.30.54;	author reyk;	state Exp;
branches;
next	1.19;
commitid	3MutW3Gx20W7mfil;

1.19
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	Uu5nFG3wCl0LACBb;

1.18
date	2013.11.14.20.48.52;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2013.08.16.19.47.42;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2012.11.01.21.27.32;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2012.05.02.18.01.25;	author gsoares;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.27.12.01.02;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.08.11.41.56;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.08.10.13.47;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.08.07.45.06;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.07.13.30.50;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.07.13.28.46;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.07.12.23.14;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.23.16.01.01;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.14.17.41.18;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.16.14.04;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.10.14.08.37;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.49.00;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.23
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@/*	$OpenBSD: ikectl.c,v 1.22 2015/11/06 06:29:11 jsg Exp $	*/

/*
 * Copyright (c) 2007-2013 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2005 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/un.h>
#include <sys/tree.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <event.h>

#include "iked.h"
#include "parser.h"

__dead void	 usage(void);

struct imsgname {
	int type;
	char *name;
	void (*func)(struct imsg *);
};

struct imsgname *monitor_lookup(uint8_t);
void		 monitor_id(struct imsg *);
int		 monitor(struct imsg *);

int		 ca_opt(struct parse_result *);

struct imsgname imsgs[] = {
	{ IMSG_CTL_OK,			"ok",			NULL },
	{ IMSG_CTL_FAIL,		"fail",			NULL },
	{ IMSG_CTL_VERBOSE,		"verbose",		NULL },
	{ IMSG_CTL_RELOAD,		"reload",		NULL },
	{ IMSG_CTL_RESET,		"reset",		NULL },
	{ 0,				NULL,			NULL }

};
struct imsgname imsgunknown = {
	-1,				"<unknown>",		NULL
};

struct imsgbuf	*ibuf;

__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-q] [-s socket] command [arg ...]\n",
	    __progname);
	exit(1);
}

int
ca_opt(struct parse_result *res)
{
	struct ca	*ca;
	size_t		 len;
	char		*p;

	ca = ca_setup(res->caname, (res->action == CA_CREATE),
	    res->quiet, res->pass);
	if (ca == NULL)
		errx(1, "ca_setup failed");

	/* assume paths are relative to /etc if not absolute */
	if (res->path && (res->path[0] != '.') && (res->path[0] != '/')) {
		len = 5 + strlen(res->path) + 1;
		if ((p = malloc(len)) == NULL)
			err(1, "malloc");
		snprintf(p, len, "/etc/%s", res->path);
		free(res->path);
		res->path = p;
	}

	switch (res->action) {
	case CA_CREATE:
		ca_create(ca);
		break;
	case CA_DELETE:
		ca_delete(ca);
		break;
	case CA_INSTALL:
		ca_install(ca, res->path);
		break;
	case CA_EXPORT:
		ca_export(ca, NULL, res->peer, res->pass);
		break;
	case CA_CERT_CREATE:
	case CA_SERVER:
	case CA_CLIENT:
	case CA_OCSP:
		ca_certificate(ca, res->host, res->htype, res->action);
		break;
	case CA_CERT_DELETE:
		ca_delkey(ca, res->host);
		break;
	case CA_CERT_INSTALL:
		ca_cert_install(ca, res->host, res->path);
		break;
	case CA_CERT_EXPORT:
		ca_export(ca, res->host, res->peer, res->pass);
		break;
	case CA_CERT_REVOKE:
		ca_revoke(ca, res->host);
		break;
	case SHOW_CA_CERTIFICATES:
		ca_show_certs(ca, res->host);
		break;
	case CA_KEY_CREATE:
		ca_key_create(ca, res->host);
		break;
	case CA_KEY_DELETE:
		ca_key_delete(ca, res->host);
		break;
	case CA_KEY_INSTALL:
		ca_key_install(ca, res->host, res->path);
		break;
	case CA_KEY_IMPORT:
		ca_key_import(ca, res->host, res->path);
		break;
	default:
		break;
	}

	return (0);
}

int
main(int argc, char *argv[])
{
	struct sockaddr_un	 sun;
	struct parse_result	*res;
	struct imsg		 imsg;
	int			 ctl_sock;
	int			 done = 1;
	int			 n;
	int			 ch;
	int			 v = 0;
	int			 quiet = 0;
	const char		*sock = IKED_SOCKET;

	while ((ch = getopt(argc, argv, "qs:")) != -1) {
		switch (ch) {
		case 'q':
			quiet = 1;
			break;
		case 's':
			sock = optarg;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	/* parse options */
	if ((res = parse(argc, argv)) == NULL)
		exit(1);

	res->quiet = quiet;

	switch (res->action) {
	case CA_CREATE:
	case CA_DELETE:
	case CA_INSTALL:
	case CA_EXPORT:
	case CA_CERT_CREATE:
	case CA_CLIENT:
	case CA_SERVER:
	case CA_OCSP:
	case CA_CERT_DELETE:
	case CA_CERT_INSTALL:
	case CA_CERT_EXPORT:
	case CA_CERT_REVOKE:
	case SHOW_CA:
	case SHOW_CA_CERTIFICATES:
	case CA_KEY_CREATE:
	case CA_KEY_DELETE:
	case CA_KEY_INSTALL:
	case CA_KEY_IMPORT:
		if (pledge("stdio proc exec rpath wpath cpath fattr tty", NULL)
		    == -1)
			err(1, "pledge");
		ca_opt(res);
		break;
	case NONE:
		usage();
		break;
	default:
		goto connect;
	}

	return (0);

 connect:
	/* connect to iked control socket */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, sock, sizeof(sun.sun_path));
 reconnect:
	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1) {
		/* Keep retrying if running in monitor mode */
		if (res->action == MONITOR &&
		    (errno == ENOENT || errno == ECONNREFUSED)) {
			usleep(100);
			goto reconnect;
		}
		err(1, "connect: %s", sock);
	}

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	if (res->ibuf != NULL)
		ibuf = res->ibuf;
	else
		if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
			err(1, "malloc");
	imsg_init(ibuf, ctl_sock);

	/* process user request */
	switch (res->action) {
	case RESETALL:
		v = RESET_ALL;
		break;
	case RESETCA:
		v = RESET_CA;
		break;
	case RESETPOLICY:
		v = RESET_POLICY;
		break;
	case RESETSA:
		v = RESET_SA;
		break;
	case RESETUSER:
		v = RESET_USER;
		break;
	case LOG_VERBOSE:
		v = 2;
		break;
	case LOG_BRIEF:
	default:
		v = 0;
		break;
	}

	switch (res->action) {
	case NONE:
		usage();
		/* NOTREACHED */
		break;
	case RESETALL:
	case RESETCA:
	case RESETPOLICY:
	case RESETSA:
	case RESETUSER:
		imsg_compose(ibuf, IMSG_CTL_RESET, 0, 0, -1, &v, sizeof(v));
		printf("reset request sent.\n");
		break;
	case LOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1,
		    res->path, strlen(res->path));
		break;
	case RELOAD:
		imsg_compose(ibuf, IMSG_CTL_RELOAD, 0, 0, -1, NULL, 0);
		break;
	case MONITOR:
		imsg_compose(ibuf, IMSG_CTL_NOTIFY, 0, 0, -1, NULL, 0);
		done = 0;
		break;
	case COUPLE:
		imsg_compose(ibuf, IMSG_CTL_COUPLE, 0, 0, -1, NULL, 0);
		break;
	case DECOUPLE:
		imsg_compose(ibuf, IMSG_CTL_DECOUPLE, 0, 0, -1, NULL, 0);
		break;
	case ACTIVE:
		imsg_compose(ibuf, IMSG_CTL_ACTIVE, 0, 0, -1, NULL, 0);
		break;
	case PASSIVE:
		imsg_compose(ibuf, IMSG_CTL_PASSIVE, 0, 0, -1, NULL, 0);
		break;
	case LOG_VERBOSE:
	case LOG_BRIEF:
		imsg_compose(ibuf, IMSG_CTL_VERBOSE, 0, 0, -1, &v, sizeof(v));
		printf("logging request sent.\n");
		break;
	default:
		break;
	}

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;
			switch (res->action) {
			case MONITOR:
				done = monitor(&imsg);
				break;
			default:
				break;
			}
			imsg_free(&imsg);
		}
	}
	close(ctl_sock);
	free(ibuf);

	return (0);
}

struct imsgname *
monitor_lookup(uint8_t type)
{
	int i;

	for (i = 0; imsgs[i].name != NULL; i++)
		if (imsgs[i].type == type)
			return (&imsgs[i]);
	return (&imsgunknown);
}

int
monitor(struct imsg *imsg)
{
	time_t			 now;
	int			 done = 0;
	struct imsgname		*imn;

	now = time(NULL);

	imn = monitor_lookup(imsg->hdr.type);
	printf("%s: imsg type %u len %u peerid %u pid %d\n", imn->name,
	    imsg->hdr.type, imsg->hdr.len, imsg->hdr.peerid, imsg->hdr.pid);
	printf("\ttimestamp: %lld, %s", (long long)now, ctime(&now));
	if (imn->type == -1)
		done = 1;
	if (imn->func != NULL)
		(*imn->func)(imsg);

	return (done);
}
@


1.22
log
@Use pledge in ikectl.  For now one request for sending imsgs to iked
another request for the ca portion.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.21 2015/11/02 10:27:44 jsg Exp $	*/
d327 1
a327 1
		if ((n = imsg_read(ibuf)) == -1)
@


1.21
log
@Accept an ocsp option when creating certificates to set the extended
key usage for OCSP signing.

Requested by and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.20 2015/08/19 13:30:54 reyk Exp $	*/
d208 3
d240 3
@


1.20
log
@Use C99 integer types in ikectl(8).

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.19 2015/01/16 06:40:17 deraadt Exp $	*/
d116 1
d197 1
@


1.19
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.18 2013/11/14 20:48:52 deraadt Exp $	*/
d47 1
a47 1
struct imsgname *monitor_lookup(u_int8_t);
d346 1
a346 1
monitor_lookup(u_int8_t type)
@


1.18
log
@cope with the EAGAIN API change for msgbuf_write()
ok benno
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.17 2013/08/16 19:47:42 guenther Exp $	*/
a21 1
#include <sys/param.h>
@


1.17
log
@Use %lld and cast to (long long) when printing time_t values

otto@@ millert@@ lteo@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.16 2013/01/08 10:38:19 reyk Exp $	*/
d316 1
a316 1
		if (msgbuf_write(&ibuf->w) < 0)
@


1.16
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.15 2012/11/01 21:27:32 reyk Exp $	*/
d369 1
a369 1
	printf("\ttimestamp: %u, %s", now, ctime(&now));
@


1.15
log
@Remove dead code that was a leftover from the initial code which was
based on snmpctl.  Found and committed from the plane in 10km (35.000
feet).  No functional change and this diff doesn't touch any crypto
code so the current country below me cannot blame me for importing /
exporting any crypto.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.14 2012/09/18 12:07:59 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@openbsd.org>
@


1.14
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.13 2012/05/02 18:01:25 gsoares Exp $	*/
a67 1
struct snmpd	*env;
a166 3
	if ((env = calloc(1, sizeof(struct snmpd *))) == NULL)
		err(1, "calloc");

a215 1
	free(env);
@


1.13
log
@s/snmpd/iked/ in comment

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.12 2011/05/27 12:01:02 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007, 2008 Reyk Floeter <reyk@@vantronix.net>
@


1.12
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.11 2010/10/08 11:41:56 jsg Exp $	*/
d224 1
a224 1
	/* connect to snmpd control socket */
@


1.11
log
@if non absolute paths are specified in install commands assume they
are relative to /etc
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.10 2010/10/08 10:13:47 jsg Exp $	*/
d75 2
a76 1
	fprintf(stderr, "usage: %s [-q] [-s socket] command [arg ...]\n", __progname);
@


1.10
log
@allow optional paths for the install commands so we can
install into the isakmpd directory hierarchy for example.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.9 2010/10/08 07:45:06 reyk Exp $	*/
d83 2
d90 10
@


1.9
log
@Allow to show certificate details (show ca x cert [y]).
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.8 2010/10/07 13:30:50 reyk Exp $	*/
d97 1
a97 1
		ca_install(ca);
d111 1
a111 1
		ca_cert_install(ca, res->host);
d129 1
a129 1
		ca_key_install(ca, res->host);
d132 1
a132 1
		ca_key_import(ca, res->host, res->filename);
d277 1
a277 1
		    res->filename, strlen(res->filename));
@


1.8
log
@Allow to specify the export password on the command line (optionally, for
scripting).  The "peer" argument now needs to be preceded with the "peer"
keyword, eg. ... export peer 10.1.1.1 instead of export 10.1.1.1.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.7 2010/10/07 13:28:46 jmc Exp $	*/
d120 1
a120 1
		ca_show_certs(ca);
@


1.7
log
@sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.6 2010/10/07 12:23:14 reyk Exp $	*/
d100 1
a100 1
		ca_export(ca, NULL, res->peer);
d114 1
a114 1
		ca_export(ca, res->host, res->peer);
@


1.6
log
@- add a -q (quiet) command line option that will be used by ikeca to
set openssl batch mode: don't ask for x509 options, use the defaults.
- allow to specify the initial ca password on the command line to also
make it scriptable.
- allow to create certificates for clientAuth or serverAuth only
(eg. ikectl ca foo certificate bar server).
- cosmetics: move double declarations of ca_*() functions to parser.h.

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.5 2010/06/23 16:01:01 jsg Exp $	*/
d75 1
a75 1
	fprintf(stderr, "usage: %s [-n] [-s socket] command [arg ...]\n", __progname);
@


1.5
log
@Add a ca export command for EAP mode where we only require the CA cert,
and make both export commands optionally take an argument that will be
added to a peer.txt file in the exported output.   Additionally
include any site specific notes from /usr/share/iked if present.

man page bits and help with the parser from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.4 2010/06/14 17:41:18 jsg Exp $	*/
a52 14
struct ca	*ca_setup(char *, int);
int		 ca_create(struct ca *);
int		 ca_certificate(struct ca *, char *, int);
int		 ca_export(struct ca *, char *, char *);
int		 ca_revoke(struct ca *, char *);
int		 ca_delete(struct ca *);
int		 ca_delkey(struct ca *, char *);
int		 ca_install(struct ca *);
int		 ca_cert_install(struct ca *, char *);
int		 ca_show_certs(struct ca *);
int		 ca_key_create(struct ca *, char *);
int		 ca_key_delete(struct ca *, char *);
int		 ca_key_install(struct ca *, char *);
int		 ca_key_import(struct ca *, char *, char *);
d84 2
a85 1
	ca = ca_setup(res->caname, (res->action == CA_CREATE));
d103 3
a105 1
		ca_certificate(ca, res->host, res->htype);
d152 1
d158 1
a158 1
	while ((ch = getopt(argc, argv, "s:")) != -1) {
d160 3
d178 2
d186 2
@


1.4
log
@Add commands to create/delete/install/import keys without
involving certificates as suggested by reyk and don't
recreate private keys if a key already exists.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.3 2010/06/10 16:14:04 jsg Exp $	*/
d56 1
a56 1
int		 ca_export(struct ca *, char *);
d112 3
d125 1
a125 1
		ca_export(ca, res->host);
d189 1
@


1.3
log
@Add a command to revoke a certificate and generate a CRL;
make the ca install command install the CRL as well.

discussed with reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.2 2010/06/10 14:08:37 reyk Exp $	*/
d63 4
d130 12
d193 4
@


1.2
log
@add new commands: the couple/decouple commands will set loading of the
learned flows and SAs to the kernel which is useful for testing and
debugging. the active/passive commands are required to use iked
with sasyncd(8);  sasyncd just needs to call "ikectl active/passive" or
send the appropriate imsg to support iked but this is not implemented yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ikectl.c,v 1.1 2010/06/03 16:49:00 reyk Exp $	*/
d57 1
d120 3
d174 1
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: snmpctl.c,v 1.12 2009/12/16 22:17:53 deraadt Exp $	*/
d259 12
@

