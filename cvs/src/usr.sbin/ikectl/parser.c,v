head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.10
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.8
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.16
date	2016.06.14.13.45.40;	author reyk;	state Exp;
branches;
next	1.15;
commitid	vRWmvXKfGnEp7Ffr;

1.15
date	2015.11.02.10.27.44;	author jsg;	state Exp;
branches;
next	1.14;
commitid	oYugXczRgOhXq8hY;

1.14
date	2015.08.19.13.30.54;	author reyk;	state Exp;
branches;
next	1.13;
commitid	3MutW3Gx20W7mfil;

1.13
date	2015.01.16.06.40.17;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	Uu5nFG3wCl0LACBb;

1.12
date	2013.01.08.10.38.19;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.18.12.07.59;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.27.12.01.02;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.08.10.13.47;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.08.07.45.06;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.07.13.30.50;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.07.12.23.14;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.23.16.01.01;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.14.17.41.18;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.10.16.14.04;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.10.14.08.37;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.03.16.49.00;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove unused variable, found by clang
@
text
@/*	$OpenBSD: parser.c,v 1.15 2015/11/02 10:27:44 jsg Exp $	*/

/*
 * Copyright (c) 2010-2013 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2004 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/tree.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <event.h>
#include <netdb.h>

#include "iked.h"
#include "parser.h"

enum token_type {
	NOTOKEN,
	ENDTOKEN,
	KEYWORD,
	PATH,
	CANAME,
	PEER,
	ADDRESS,
	FQDN,
	PASSWORD
};

struct token {
	enum token_type		 type;
	const char		*keyword;
	int			 value;
	const struct token	*next;
};

static const struct token t_main[];
static const struct token t_reset[];
static const struct token t_log[];
static const struct token t_load[];
static const struct token t_ca[];
static const struct token t_ca_pass[];
static const struct token t_ca_pass_val[];
static const struct token t_ca_export[];
static const struct token t_ca_ex_peer[];
static const struct token t_ca_ex_pass[];
static const struct token t_ca_modifiers[];
static const struct token t_ca_cert[];
static const struct token t_ca_cert_extusage[];
static const struct token t_ca_cert_modifiers[];
static const struct token t_ca_key[];
static const struct token t_ca_key_modifiers[];
static const struct token t_ca_key_path[];
static const struct token t_show[];
static const struct token t_show_ca[];
static const struct token t_show_ca_modifiers[];
static const struct token t_show_ca_cert[];
static const struct token t_opt_path[];

static const struct token t_main[] = {
	{ KEYWORD,	"active",	ACTIVE,		NULL },
	{ KEYWORD,	"passive",	PASSIVE,	NULL },
	{ KEYWORD,	"couple",	COUPLE,		NULL },
	{ KEYWORD,	"decouple",	DECOUPLE,	NULL },
	{ KEYWORD,	"load",		LOAD,		t_load },
	{ KEYWORD,	"log",		NONE,		t_log },
	{ KEYWORD,	"monitor",	MONITOR,	NULL },
	{ KEYWORD,	"reload",	RELOAD,		NULL },
	{ KEYWORD,	"reset",	NONE,		t_reset },
	{ KEYWORD,	"show",		NONE,		t_show },
	{ KEYWORD,	"ca",		CA,		t_ca },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_log[] = {
	{ KEYWORD,	"verbose",	LOG_VERBOSE,	NULL },
	{ KEYWORD,	"brief",	LOG_BRIEF,	NULL },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_reset[] = {
	{ KEYWORD,	"all",		RESETALL,	NULL },
	{ KEYWORD,	"ca",		RESETCA,	NULL },
	{ KEYWORD,	"policy",	RESETPOLICY,	NULL },
	{ KEYWORD,	"sa",		RESETSA,	NULL },
	{ KEYWORD,	"user",		RESETUSER,	NULL },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_load[] = {
	{ PATH,		"",		NONE,		NULL },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_ca[] = {
	{ CANAME,	"",		NONE,		t_ca_modifiers },
	{ ENDTOKEN,	"",		NONE,		NULL },
};

static const struct token t_ca_modifiers[] = {
	{ KEYWORD,	"create",	CA_CREATE,	t_ca_pass },
	{ KEYWORD,	"delete",	CA_DELETE,	NULL },
	{ KEYWORD,	"install",	CA_INSTALL,	t_opt_path },
	{ KEYWORD,	"certificate",	CA_CERTIFICATE,	t_ca_cert },
	{ KEYWORD,	"key",		NONE,		t_ca_key },
	{ KEYWORD,	"export",	CA_EXPORT,	t_ca_export },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_ca_pass_val[] = {
	{ PASSWORD,	"",		NONE,		NULL },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_ca_pass[] = {
	{ NOTOKEN,	"",		NONE,		NULL },
	{ KEYWORD,	"password",	NONE,		t_ca_pass_val },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_ca_export[] = {
	{ NOTOKEN,	"",		NONE,		NULL },
	{ KEYWORD,	"peer",		NONE,		t_ca_ex_peer },
	{ KEYWORD,	"password",	NONE,		t_ca_ex_pass },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_ca_ex_peer[] = {
	{ PEER,		"",		NONE,		t_ca_export },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_ca_ex_pass[] = {
	{ PASSWORD,	"",		NONE,		t_ca_export },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_opt_path[] = {
	{ NOTOKEN,	"",		NONE,		NULL },
	{ PATH,		"",		NONE,		NULL },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_ca_cert[] = {
	{ ADDRESS,	"",		NONE,		t_ca_cert_modifiers },
	{ FQDN,		"",		NONE,		t_ca_cert_modifiers },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_ca_cert_modifiers[] = {
	{ KEYWORD,	"create",	CA_CERT_CREATE,		t_ca_cert_extusage },
	{ KEYWORD,	"delete",	CA_CERT_DELETE,		NULL },
	{ KEYWORD,	"install",	CA_CERT_INSTALL,	t_opt_path },
	{ KEYWORD,	"export",	CA_CERT_EXPORT,		t_ca_export },
	{ KEYWORD,	"revoke",	CA_CERT_REVOKE,		NULL },
	{ ENDTOKEN,	"",		NONE,			NULL }
};

static const struct token t_ca_cert_extusage[] = {
	{ NOTOKEN,	"",		NONE,		NULL},
	{ KEYWORD,	"server",	CA_SERVER,	NULL },
	{ KEYWORD,	"client",	CA_CLIENT,	NULL },
	{ KEYWORD,	"ocsp",		CA_OCSP,	NULL },
	{ ENDTOKEN,	"",		NONE,		NULL },
};

static const struct token t_ca_key[] = {
	{ ADDRESS,	"",		NONE,		t_ca_key_modifiers },
	{ FQDN,		"",		NONE,		t_ca_key_modifiers },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_ca_key_modifiers[] = {
	{ KEYWORD,	"create",	CA_KEY_CREATE,		NULL },
	{ KEYWORD,	"delete",	CA_KEY_DELETE,		NULL },
	{ KEYWORD,	"install",	CA_KEY_INSTALL,		t_opt_path },
	{ KEYWORD,	"import",	CA_KEY_IMPORT,		t_ca_key_path },
	{ ENDTOKEN,	"",		NONE,			NULL }
};

static const struct token t_ca_key_path[] = {
	{ PATH,		"",		NONE,		NULL },
	{ PATH,		"",		NONE,		NULL }
};

static const struct token t_show[] = {
	{ KEYWORD,	"ca",		SHOW_CA,	t_show_ca },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static const struct token t_show_ca[] = {
	{ CANAME,	"",		NONE,		t_show_ca_modifiers },
	{ ENDTOKEN,	"",		NONE,		NULL },
};

static const struct token t_show_ca_modifiers[] = {
	{ KEYWORD,	"certificates",	SHOW_CA_CERTIFICATES,	t_show_ca_cert },
	{ ENDTOKEN,	"",		NONE,			NULL }
};

static const struct token t_show_ca_cert[] = {
	{ NOTOKEN,	"",		NONE,		NULL },
	{ ADDRESS,	"",		NONE,		NULL },
	{ FQDN,		"",		NONE,		NULL },
	{ ENDTOKEN,	"",		NONE,		NULL }
};

static struct parse_result	 res;

const struct token		*match_token(char *, const struct token []);
void				 show_valid_args(const struct token []);
int				 parse_addr(const char *);

struct parse_result *
parse(int argc, char *argv[])
{
	const struct token	*table = t_main;
	const struct token	*match;

	bzero(&res, sizeof(res));

	while (argc >= 0) {
		if ((match = match_token(argv[0], table)) == NULL) {
			fprintf(stderr, "valid commands/args:\n");
			show_valid_args(table);
			return (NULL);
		}

		argc--;
		argv++;

		if (match->type == NOTOKEN || match->next == NULL)
			break;

		table = match->next;
	}

	if (argc > 0) {
		fprintf(stderr, "superfluous argument: %s\n", argv[0]);
		return (NULL);
	}

	return (&res);
}

int
parse_addr(const char *word)
{
	struct addrinfo hints, *r;

	bzero(&hints, sizeof(hints));
	hints.ai_socktype = SOCK_DGRAM; /* dummy */
	hints.ai_family = PF_UNSPEC;
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(word, "0", &hints, &r) == 0) {
		return (0);
	}

	return (1);
}


const struct token *
match_token(char *word, const struct token table[])
{
	unsigned int		 i, match = 0;
	const struct token	*t = NULL;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			if (word == NULL || strlen(word) == 0) {
				match++;
				t = &table[i];
			}
			break;
		case KEYWORD:
			if (word != NULL && strncmp(word, table[i].keyword,
			    strlen(word)) == 0) {
				match++;
				t = &table[i];
				if (t->value)
					res.action = t->value;
			}
			break;
		case PATH:
			if (!match && word != NULL && strlen(word) > 0) {
				res.path = strdup(word);
				match++;
				t = &table[i];
			}
			break;
		case CANAME:
			if (!match && word != NULL && strlen(word) > 0) {
				res.caname = strdup(word);
				match++;
				t = &table[i];
			}
			break;
		case PEER:
			if (!match && word != NULL && strlen(word) > 0) {
				res.peer = strdup(word);
				match++;
				t = &table[i];
			}
			break;
		case ADDRESS:
		case FQDN:
			if (!match && word != NULL && strlen(word) > 0) {
				parse_addr(word);
				res.host = strdup(word);
				if (parse_addr(word) == 0)
					res.htype = HOST_IPADDR;
				else
					res.htype = HOST_FQDN;
				match++;
				t = &table[i];
			}
			break;
		case PASSWORD:
			if (!match && word != NULL && strlen(word) > 0) {
				res.pass = strdup(word);
				match++;
				t = &table[i];
			}
			break;
		case ENDTOKEN:
			break;
		}
	}

	if (match != 1) {
		if (word == NULL)
			fprintf(stderr, "missing argument:\n");
		else if (match > 1)
			fprintf(stderr, "ambiguous argument: %s\n", word);
		else if (match < 1)
			fprintf(stderr, "unknown argument: %s\n", word);
		return (NULL);
	}

	return (t);
}

void
show_valid_args(const struct token table[])
{
	int	i;

	for (i = 0; table[i].type != ENDTOKEN; i++) {
		switch (table[i].type) {
		case NOTOKEN:
			fprintf(stderr, "  <cr>\n");
			break;
		case KEYWORD:
			fprintf(stderr, "  %s\n", table[i].keyword);
			break;
		case PATH:
			fprintf(stderr, "  <path>\n");
			break;
		case CANAME:
			fprintf(stderr, "  <caname>\n");
			break;
		case PASSWORD:
			fprintf(stderr, "  <password>\n");
			break;
		case PEER:
			fprintf(stderr, "  <peer>\n");
			break;
		case ADDRESS:
			fprintf(stderr, "  <ipaddr>\n");
			break;
		case FQDN:
			fprintf(stderr, "  <fqdn>\n");
			break;
		case ENDTOKEN:
			break;
		}
	}
}
@


1.15
log
@Accept an ocsp option when creating certificates to set the extended
key usage for OCSP signing.

Requested by and ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.14 2015/08/19 13:30:54 reyk Exp $	*/
a69 1
static const struct token t_ca_cert_ex_peer[];
@


1.14
log
@Use C99 integer types in ikectl(8).

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.13 2015/01/16 06:40:17 deraadt Exp $	*/
d184 1
@


1.13
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.12 2013/01/08 10:38:19 reyk Exp $	*/
d286 1
a286 1
	u_int			 i, match = 0;
@


1.12
log
@Remove private CVS tag from an obsolete repository and bump copyright
to 2013 while I'm here... this is my way of saying "happy new year!".
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.11 2012/09/18 12:07:59 reyk Exp $	*/
a20 1
#include <sys/param.h>
@


1.11
log
@update email addresses to match reality.
sure jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.10 2011/05/27 12:01:02 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@openbsd.org>
@


1.10
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.9 2010/10/08 10:13:47 jsg Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Reyk Floeter <reyk@@vantronix.net>
@


1.9
log
@allow optional paths for the install commands so we can
install into the isakmpd directory hierarchy for example.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.8 2010/10/08 07:45:06 reyk Exp $	*/
d98 3
a100 3
	{ KEYWORD,	"verbose",	LOG_VERBOSE, 	NULL },
	{ KEYWORD,	"brief",	LOG_BRIEF, 	NULL },
	{ ENDTOKEN, 	"",		NONE,		NULL }
d114 1
a114 1
	{ ENDTOKEN, 	"",		NONE,		NULL }
d129 1
a129 1
	{ ENDTOKEN, 	"",		NONE,		NULL }
d204 1
a204 1
	{ PATH, 	"",		NONE,		NULL }
@


1.8
log
@Allow to show certificate details (show ca x cert [y]).
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.7 2010/10/07 13:30:50 reyk Exp $	*/
d43 1
a43 1
	FILENAME,
d80 1
d113 1
a113 1
	{ FILENAME,	"",		NONE,		NULL },
d125 1
a125 1
	{ KEYWORD,	"install",	CA_INSTALL,	NULL },
d160 6
d175 1
a175 1
	{ KEYWORD,	"install",	CA_CERT_INSTALL,	NULL },
d197 1
a197 1
	{ KEYWORD,	"install",	CA_KEY_INSTALL,		NULL },
d203 2
a204 2
	{ FILENAME,	"",		NONE,		NULL },
	{ ENDTOKEN, 	"",		NONE,		NULL }
d307 1
a307 1
		case FILENAME:
d309 1
a309 1
				res.filename = strdup(word);
d379 2
a380 2
		case FILENAME:
			fprintf(stderr, "  <filename>\n");
@


1.7
log
@Allow to specify the export password on the command line (optionally, for
scripting).  The "peer" argument now needs to be preceded with the "peer"
keyword, eg. ... export peer 10.1.1.1 instead of export 10.1.1.1.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.6 2010/10/07 12:23:14 reyk Exp $	*/
d79 1
d211 9
a219 2
	{ KEYWORD,	"certificates",		SHOW_CA_CERTIFICATES,	NULL },
	{ ENDTOKEN,	"",			NONE,			NULL }
@


1.6
log
@- add a -q (quiet) command line option that will be used by ikeca to
set openssl batch mode: don't ask for x509 options, use the defaults.
- allow to specify the initial ca password on the command line to also
make it scriptable.
- allow to create certificates for clientAuth or serverAuth only
(eg. ikectl ca foo certificate bar server).
- cosmetics: move double declarations of ca_*() functions to parser.h.

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.5 2010/06/23 16:01:01 jsg Exp $	*/
d64 2
d67 1
d126 1
a126 1
	{ KEYWORD,	"export",	CA_EXPORT,	t_ca_ex_peer },
d130 5
d137 9
a145 2
	{ PASSWORD,	"",		NONE,		NULL },
	{ ENDTOKEN,	"",		NONE,		NULL },
d149 7
a155 3
	{ NOTOKEN,	"",		NONE,		NULL},
	{ PEER,		"",		NONE,		NULL },
	{ ENDTOKEN,	"",		NONE,		NULL },
d168 1
a168 1
	{ KEYWORD,	"export",	CA_CERT_EXPORT,		t_ca_cert_ex_peer },
a170 6
};

static const struct token t_ca_cert_ex_peer[] = {
	{ NOTOKEN,	"",		NONE,		NULL},
	{ PEER,		"",		NONE,		NULL },
	{ ENDTOKEN,	"",		NONE,		NULL },
@


1.5
log
@Add a ca export command for EAP mode where we only require the CA cert,
and make both export commands optionally take an argument that will be
added to a peer.txt file in the exported output.   Additionally
include any site specific notes from /usr/share/iked if present.

man page bits and help with the parser from reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.4 2010/06/14 17:41:18 jsg Exp $	*/
d47 2
a48 1
	FQDN
d63 1
d67 1
d118 1
a118 1
	{ KEYWORD,	"create",	CA_CREATE,	NULL },
d127 6
d146 1
a146 1
	{ KEYWORD,	"create",	CA_CERT_CREATE,		NULL },
d160 7
d313 7
d356 3
@


1.4
log
@Add commands to create/delete/install/import keys without
involving certificates as suggested by reyk and don't
recreate private keys if a key already exists.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.3 2010/06/10 16:14:04 jsg Exp $	*/
d45 1
d62 1
d65 1
d120 1
d124 6
d140 1
a140 1
	{ KEYWORD,	"export",	CA_CERT_EXPORT,		NULL },
d145 6
d277 7
d333 3
@


1.3
log
@Add a command to revoke a certificate and generate a CRL;
make the ca install command install the CRL as well.

discussed with reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.2 2010/06/10 14:08:37 reyk Exp $	*/
d64 3
d116 1
d133 19
@


1.2
log
@add new commands: the couple/decouple commands will set loading of the
learned flows and SAs to the kernel which is useful for testing and
debugging. the active/passive commands are required to use iked
with sasyncd(8);  sasyncd just needs to call "ikectl active/passive" or
send the appropriate imsg to support iked but this is not implemented yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.1 2010/06/03 16:49:00 reyk Exp $	*/
d127 1
@


1.1
log
@Import iked, a new implementation of the IKEv2 protocol.

iked(8) is an automatic keying daemon for IPsec, like isakmpd(8), that
IPsec creates flows and SAs automatically.  Unlike isakmpd, iked(8)
implements the newer IKEv2 protocol instead of IKEv1/ISAKMP.  The
daemon is still work-in-progress and not enabled in the builds, but is
already able to establish IKEv2 sessions with some other IKEv2
implementations as a responder.

with lots of help and debugging by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parser.c,v 1.9 2009/12/16 22:17:53 deraadt Exp $	*/
d69 5
a73 1
	{ KEYWORD,	"reset",	NONE,		t_reset },
a75 1
	{ KEYWORD,	"load",		LOAD,		t_load },
d77 2
a79 1
	{ KEYWORD,	"show",		NONE,		t_show },
@

