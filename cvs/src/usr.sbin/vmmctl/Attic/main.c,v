head	1.8;
access;
symbols;
locks; strict;
comment	@ * @;


1.8
date	2015.12.03.21.45.45;	author reyk;	state dead;
branches;
next	1.7;
commitid	MPLOtGQkSv2xIotz;

1.7
date	2015.12.03.13.08.44;	author reyk;	state Exp;
branches;
next	1.6;
commitid	x0i6sqLF0crQTgU8;

1.6
date	2015.12.02.09.14.25;	author reyk;	state Exp;
branches;
next	1.5;
commitid	vOctzllSJTLtnazM;

1.5
date	2015.12.01.20.52.44;	author halex;	state Exp;
branches;
next	1.4;
commitid	0F6KK0vAg9wCOKZm;

1.4
date	2015.11.27.09.11.39;	author reyk;	state Exp;
branches;
next	1.3;
commitid	YD6OAZRyqVv6x6Jz;

1.3
date	2015.11.26.08.26.48;	author reyk;	state Exp;
branches;
next	1.2;
commitid	GRMyPzYJL6q2Nvq3;

1.2
date	2015.11.26.07.44.28;	author reyk;	state Exp;
branches;
next	1.1;
commitid	F0fpzizP27pzDDiF;

1.1
date	2015.11.22.20.55.18;	author reyk;	state Exp;
branches;
next	;
commitid	Ce3XWaK9k2YVSX7c;


desc
@@


1.8
log
@Replace vmmctl with vmctl.  Also remove parse.y from the "new" vmctl.

As discussed with mlarkin@@ and deraadt@@
@
text
@/*	$OpenBSD: main.c,v 1.7 2015/12/03 13:08:44 reyk Exp $	*/

/*
 * Copyright (c) 2015 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <sys/un.h>
#include <sys/cdefs.h>

#include <machine/vmmvar.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>
#include <util.h>
#include <imsg.h>

#include "vmd.h"
#include "parser.h"

static const char	*socket_name = SOCKET_NAME;
static const char	*config_file = VMM_CONF;
static int		 ctl_sock = -1;

__dead void	 usage(void);
__dead void	 ctl_usage(struct ctl_command *);

int		 vmm_action(struct parse_result *);

int		 ctl_create(struct parse_result *, int, char *[]);
int		 ctl_load(struct parse_result *, int, char *[]);
int		 ctl_start(struct parse_result *, int, char *[]);
int		 ctl_status(struct parse_result *, int, char *[]);
int		 ctl_stop(struct parse_result *, int, char *[]);

struct ctl_command ctl_commands[] = {
	{ "create",	CMD_CREATE,	ctl_create,	"\"name\" -s size", 1 },
	{ "load",	CMD_LOAD,	ctl_load,	"[path]" },
	{ "start",	CMD_START,	ctl_start,
	    "\"name\" -k kernel -m memory [-i interfaces] [[-d disk] ...]" },
	{ "status",	CMD_STATUS,	ctl_status,	"[id]" },
	{ "stop",	CMD_STOP,	ctl_stop,	"id" },
	{ NULL }
};

__dead void
usage(void)
{
	extern char	*__progname;
	int		 i;

	fprintf(stderr, "usage:\t%s [-s socket] command [arg ...]\n",
	    __progname);
	for (i = 0; ctl_commands[i].name != NULL; i++) {
		fprintf(stderr, "\t%s %s %s\n", __progname,
		    ctl_commands[i].name, ctl_commands[i].usage);
	}
	exit(1);
}

__dead void
ctl_usage(struct ctl_command *ctl)
{
	extern char	*__progname;

	fprintf(stderr, "usage:\t%s %s %s\n", __progname,
	    ctl->name, ctl->usage);
	exit(1);
}

int
main(int argc, char *argv[])
{
	int	 ch;

	while ((ch = getopt(argc, argv, "s:")) != -1) {
		switch (ch) {
		case 's':
			socket_name = optarg;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;
	optreset = 1;

	if (argc < 1)
		usage();

	return (parse(argc, argv));
}

int
parse(int argc, char *argv[])
{
	struct ctl_command	*ctl = NULL;
	struct parse_result	 res;
	int			 i;

	memset(&res, 0, sizeof(res));
	res.nifs = -1;

	for (i = 0; ctl_commands[i].name != NULL; i++) {
		if (strncmp(ctl_commands[i].name,
		    argv[0], strlen(argv[0])) == 0) {
			if (ctl != NULL) {
				fprintf(stderr,
				    "ambiguous argument: %s\n", argv[0]);
				usage();
			}
			ctl = &ctl_commands[i];
		}
	}

	if (ctl == NULL) {
		fprintf(stderr, "unknown argument: %s\n", argv[0]);
		usage();
	}

	res.action = ctl->action;
	res.ctl = ctl;

	if (!ctl->has_pledge) {
		/* pledge(2) default if command doesn't have its own pledge */
		if (pledge("stdio rpath unix", NULL) == -1)
			err(1, "pledge");
	}
	if (ctl->main(&res, argc, argv) != 0)
		err(1, "failed");

	if (ctl_sock != -1) {
		close(ibuf->fd);
		free(ibuf);
	}

	return (0);
}

int
vmmaction(struct parse_result *res)
{
	struct sockaddr_un	 sun;
	struct imsg		 imsg;
	int			 done = 0;
	int			 n;
	int			 ret;

	if (ctl_sock == -1) {
		if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
			err(1, "socket");

		bzero(&sun, sizeof(sun));
		sun.sun_family = AF_UNIX;
		strlcpy(sun.sun_path, socket_name, sizeof(sun.sun_path));

		if (connect(ctl_sock,
		    (struct sockaddr *)&sun, sizeof(sun)) == -1)
			err(1, "connect: %s", socket_name);

		if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
			err(1, "malloc");
		imsg_init(ibuf, ctl_sock);
	}

	switch (res->action) {
	case CMD_START:
		/* XXX validation should be done in start_vm() */
		if (res->size < 1)
			errx(1, "specified memory size too small");
		if (res->path == NULL)
			errx(1, "no kernel specified");
		if (res->ndisks > VMM_MAX_DISKS_PER_VM)
			errx(1, "too many disks");
		else if (res->ndisks == 0)
			warnx("starting without disks");
		if (res->nifs == -1)
			res->nifs = 0;
		if (res->nifs == 0)
			warnx("starting without network interfaces");

		ret = start_vm(res->name, res->size, res->nifs,
		    res->ndisks, res->disks, res->path);
		if (ret) {
			errno = ret;
			err(1, "start VM operation failed");
		}
		break;
	case CMD_STOP:
		terminate_vm(res->id);
		break;
	case CMD_STATUS:
		get_info_vm(res->id);
		break;
	case CMD_CREATE:
	case CMD_LOAD:
	case NONE:
		break;
	}

	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0 && errno != EAGAIN)
			err(1, "write error");

	while (!done) {
		if ((n = imsg_read(ibuf)) == -1)
			errx(1, "imsg_read error");
		if (n == 0)
			errx(1, "pipe closed");

		while (!done) {
			if ((n = imsg_get(ibuf, &imsg)) == -1)
				errx(1, "imsg_get error");
			if (n == 0)
				break;

			if (imsg.hdr.type == IMSG_CTL_FAIL) {
				if (IMSG_DATA_SIZE(&imsg) == sizeof(ret)) {
					memcpy(&ret, imsg.data, sizeof(ret));
					errno = ret;
					warn("command failed");
				} else {
					warnx("command failed");
				}
				done = 1;
				break;
			}

			ret = 0;
			switch (res->action) {
			case CMD_START:
				done = start_vm_complete(&imsg, &ret);
				break;
			case CMD_STOP:
				done = terminate_vm_complete(&imsg, &ret);
				break;
			case CMD_STATUS:
				done = add_info(&imsg, &ret);
				break;
			default:
				done = 1;
				break;
			}

			imsg_free(&imsg);
		}
	}

	parse_free(res);

	return (0);
}

void
parse_free(struct parse_result *res)
{
	size_t	 i;

	free(res->name);
	free(res->path);
	for (i = 0; i < res->ndisks; i++)
		free(res->disks[i]);
	free(res->disks);
	memset(res, 0, sizeof(*res));
}

int
parse_ifs(struct parse_result *res, char *word, int val)
{
	const char	*error;

	if (word != NULL) {
		val = strtonum(word, 0, INT_MAX, &error);
		if (error != NULL)  {
			warnx("invalid count \"%s\": %s", word, error);
			return (-1);
		}
	}
	res->nifs = val;
	return (0);
}

int
parse_size(struct parse_result *res, char *word, long long val)
{
	if (word != NULL) {
		if (scan_scaled(word, &val) != 0) {
			warn("invalid size: %s", word);
			return (-1);
		}
	}

	if (val < (1024 * 1024)) {
		warnx("size must be at least one megabyte");
		return (-1);
	} else
		res->size = val / 1024 / 1024;

	if ((res->size * 1024 * 1024) != val)
		warnx("size rounded to %lld megabytes", res->size);

	return (0);
}

int
parse_disk(struct parse_result *res, char *word)
{
	char		**disks;
	char		*s;

	if ((disks = reallocarray(res->disks, res->ndisks + 1,
	    sizeof(char *))) == NULL) {
		warn("reallocarray");
		return (-1);
	}
	if ((s = strdup(word)) == NULL) {
		warn("strdup");
		return (-1);
	}
	disks[res->ndisks] = s;
	res->disks = disks;
	res->ndisks++;

	return (0);
}

int
parse_vmid(struct parse_result *res, char *word, uint32_t id)
{
	const char	*error;

	if (word != NULL) {
		id = strtonum(word, 0, UINT32_MAX, &error);
		if (error != NULL)  {
			warnx("invalid id: %s", error);
			return (-1);
		}
	}
	res->id = id;

	return (0);
}

int
ctl_create(struct parse_result *res, int argc, char *argv[])
{
	int		 ch, ret;
	const char	*paths[2];

	if (argc < 2)
		ctl_usage(res->ctl);

	paths[0] = argv[1];
	paths[1] = NULL;
	if (pledge("stdio rpath wpath cpath", paths) == -1)
		err(1, "pledge");
	argc--;
	argv++;

	while ((ch = getopt(argc, argv, "s:")) != -1) {
		switch (ch) {
		case 's':
			if (parse_size(res, optarg, 0) != 0)
				errx(1, "invalid size: %s", optarg);
			break;
		default:
			ctl_usage(res->ctl);
			/* NOTREACHED */
		}
	}

	if (res->size == 0) {
		fprintf(stderr, "missing size argument\n");
		ctl_usage(res->ctl);
	}
	res->size /= 1024 / 1024;
	if (res->size < 1)
		errx(1, "specified image size too small");
	ret = create_imagefile(paths[0], res->size);
	if (ret != 0) {
		errno = ret;
		err(1, "create imagefile operation failed");
	} else
		warnx("imagefile created");
	return (0);
}

int
ctl_status(struct parse_result *res, int argc, char *argv[])
{
	if (argc == 2) {
		if (parse_vmid(res, argv[1], 0) == -1)
			errx(1, "invalid id: %s", argv[1]);
	} else if (argc > 2)
		ctl_usage(res->ctl);

	return (vmmaction(res));
}

int
ctl_load(struct parse_result *res, int argc, char *argv[])
{
	if (argc == 2)
		config_file = argv[1];
	else if (argc > 2)
		ctl_usage(res->ctl);

	/* parse configuration file options */
	return (parse_config(config_file));
}

int
ctl_start(struct parse_result *res, int argc, char *argv[])
{
	int			 ch;

	if (argc < 2)
		ctl_usage(res->ctl);

	if ((res->name = strdup(argv[1])) == NULL)
		errx(1, "strdup");
	argc--;
	argv++;

	while ((ch = getopt(argc, argv, "k:m:d:i:")) != -1) {
		switch (ch) {
		case 'k':
			if (res->path)
				errx(1, "kernel specified multiple times");
			if ((res->path = strdup(optarg)) == NULL)
				errx(1, "strdup");
			break;
		case 'm':
			if (res->size)
				errx(1, "memory specified multiple times");
			if (parse_size(res, optarg, 0) != 0)
				errx(1, "invalid memory size: %s", optarg);
			break;
		case 'd':
			if (parse_disk(res, optarg) != 0)
				errx(1, "invalid memory size: %s", optarg);
			break;
		case 'i':
			if (res->nifs != -1)
				errx(1, "interfaces specified multiple times");
			if (parse_ifs(res, optarg, 0) != 0)
				errx(1, "invalid interface count: %s", optarg);
			break;
		default:
			ctl_usage(res->ctl);
			/* NOTREACHED */
		}
	}

	return (vmmaction(res));
}

int
ctl_stop(struct parse_result *res, int argc, char *argv[])
{
	if (argc == 2) {
		if (parse_vmid(res, argv[1], 0) == -1)
			errx(1, "invalid id: %s", argv[1]);
	} else if (argc != 2)
		ctl_usage(res->ctl);

	return (vmmaction(res));
}
@


1.7
log
@Use PEERCRED to obtain the user id of the vmmctl user.  This is used to
restrict write operations (start/stop/terminate/load) to root for now,
but allow others to obtain the status.  A more sophisticated model will
follow later, but this change prevents non-root users, even if in the wheel
group, to start vms and thus to open any files read-writable as disks.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2015/12/02 09:14:25 reyk Exp $	*/
@


1.6
log
@Start tweaking vmd's privsep and daemon model by splitting the main
process into multiple parts and adopting the "proc.c"-style from other
daemons.  This allows to further reduce the privileges, to give better
pledge(2), and to add some upcoming changes.

"please do" mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 2015/12/01 20:52:44 halex Exp $	*/
d238 12
@


1.5
log
@Fix -i option handling.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 2015/11/27 09:11:39 reyk Exp $	*/
d43 1
d154 5
a169 1
	int			 ctl_sock;
d171 16
a186 19
	/*
	 * Connect to vmd control socket.
	 * XXX vmd currently only accepts one request per connection,
	 * XXX so we have to open the control socket each time this
	 * XXX function is called.  This should be changed later.
	 */
	if ((ctl_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
		err(1, "socket");

	bzero(&sun, sizeof(sun));
	sun.sun_family = AF_UNIX;
	strlcpy(sun.sun_path, socket_name, sizeof(sun.sun_path));

	if (connect(ctl_sock, (struct sockaddr *)&sun, sizeof(sun)) == -1)
		err(1, "connect: %s", socket_name);

	if ((ibuf = malloc(sizeof(struct imsgbuf))) == NULL)
		err(1, "malloc");
	imsg_init(ibuf, ctl_sock);
a257 3

	close(ibuf->fd);
	free(ibuf);
@


1.4
log
@Change the command line syntax to a "command + getopts" style, eg.
  vmmctl start "myvm" -m 512M -i 1 -d disk.img -k /bsd

Networking people like me are used to the human-readable CLI-style
syntax that we have in some of our OpenBSD *ctl tools, including
bgpctl, other routing daemons, or relayctl.  But this didn't work for
vmmctl, so change it to something a bit less human-readable but more
BSD- and POSIX-ish.  After all, the command line is only intended for
simple configuration, more details will go into the configuration
file, so we can avoid getopt flag conflicts or scary things like the
getsubopt(3) style.

OK krw@@ jasper@@, with input from kettenis@@ jmc@@ deraadt@@ mlarkin@@ etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 2015/11/26 08:26:48 reyk Exp $	*/
d123 1
d197 4
d455 1
a455 1
			if (res->size)
@


1.3
log
@Automatically start vmm(4) when the first VM is created and after the
last VM is terminated.  This allows to remove the explicit "vmm
enable" / "vmm disable" (VMM_IOC_START / VMM_IOC_STOP) ioctls.  You'll
have to update kernel and userland for this change, as the kernel ABI
changes.

OK mpi@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 2015/11/26 07:44:28 reyk Exp $	*/
d35 1
d42 1
d45 2
d49 16
d68 2
a69 1
	extern char *__progname;
d71 1
a71 1
	fprintf(stderr, "usage: %s [-q] [-s socket] command [arg ...]\n",
d73 14
d93 1
a93 4
	struct parse_result	*res;
	int			 ch;
	int			 ret;
	const char		*paths[2];
d107 1
d109 2
a110 3
	/* parse command line options */
	if ((res = parse(argc, argv)) == NULL)
		exit(1);
d112 26
a137 2
	switch (res->action) {
	case NONE:
d139 4
a142 8
		break;
	case CMD_CREATE:
		paths[0] = res->path;
		paths[1] = NULL;
		if (pledge("stdio rpath wpath cpath", paths) == -1)
			err(1, "pledge");
		if (res->size < 1)
			errx(1, "specified image size too small");
d144 2
a145 8
		ret = create_imagefile(res->path, res->size);
		if (ret != 0) {
			errno = ret;
			err(1, "create imagefile operation failed");
		} else
			warnx("imagefile created");
		return (0);
	case CMD_LOAD:
a147 12

		/* parse configuration file options */
		if (res->path == NULL)
			ret = parse_config(VMM_CONF);
		else
			ret = parse_config(res->path);
		break;
	default:
		if (pledge("stdio unix", NULL) == -1)
			err(1, "pledge");
		ret = vmmaction(res);
		break;
d149 2
d152 1
a152 1
	return (ret);
d204 1
a204 1
	case CMD_TERMINATE:
d207 1
a207 1
	case CMD_INFO:
d237 1
a237 1
			case CMD_TERMINATE:
d240 1
a240 1
			case CMD_INFO:
d255 2
d260 13
d290 1
a290 2
parse_size(struct parse_result *res, char *word,
    long long val)
a291 2
	char		*s = "";

d293 2
a294 4
		val = strtol(word, &s, 10);
		if (errno == ERANGE &&
		    (val == LLONG_MIN || val == LLONG_MAX)) {
			warnx("out of range: %s", word);
d299 4
a302 2
	/* Convert to megabytes */
	if (*s == '\0')
d304 3
a306 14
	else if (strcmp(s, "K") == 0)
		res->size = val / 1024;
	else if (strcmp(s, "M") == 0)
		res->size = val;
	else if (strcmp(s, "G") == 0)
		res->size = val * 1024;
	else {
		warnx("invalid unit: %s", s);
		return (-1);
	}
	if (res->size > LLONG_MAX) {
		warnx("size too large: %s", word);
		return (-1);
	}
d348 126
@


1.2
log
@Fix potentially uninitialized variable.

Found by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.1 2015/11/22 20:55:18 reyk Exp $	*/
a149 6
	case CMD_ENABLE:
		enable_vmm();
		break;
	case CMD_DISABLE:
		disable_vmm();
		break;
a197 6
			case CMD_DISABLE:
				done = disable_vmm_complete(&imsg, &ret);
				break;
			case CMD_ENABLE:
				done = enable_vmm_complete(&imsg, &ret);
				break;
@


1.1
log
@Add initial parser to support a vmm.conf(5) configuration file format
for vmm and virtual machines.  Additionally, add a matching vmmctl
command line grammar that replaces (most of the) getopt arguments.
The goal is to provide a sane way to configure vmm(4) and vmd(8).
"There is still a lot to be done, and fixed" in this as well.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d254 1
a254 1
	char		*s;
@

