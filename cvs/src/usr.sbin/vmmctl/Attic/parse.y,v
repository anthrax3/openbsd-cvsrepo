head	1.8;
access;
symbols;
locks; strict;
comment	@ * @;


1.8
date	2015.12.03.21.45.45;	author reyk;	state dead;
branches;
next	1.7;
commitid	MPLOtGQkSv2xIotz;

1.7
date	2015.12.03.08.52.29;	author reyk;	state Exp;
branches;
next	1.6;
commitid	mRQu2Gl5JSfPynvg;

1.6
date	2015.12.02.09.20.41;	author reyk;	state Exp;
branches;
next	1.5;
commitid	Fit6EapFNilkl2hu;

1.5
date	2015.12.01.20.52.44;	author halex;	state Exp;
branches;
next	1.4;
commitid	0F6KK0vAg9wCOKZm;

1.4
date	2015.11.27.09.11.39;	author reyk;	state Exp;
branches;
next	1.3;
commitid	YD6OAZRyqVv6x6Jz;

1.3
date	2015.11.26.08.34.25;	author reyk;	state Exp;
branches;
next	1.2;
commitid	qJJuuOMcXSIx7EE7;

1.2
date	2015.11.24.10.17.15;	author espie;	state Exp;
branches;
next	1.1;
commitid	qA9zF5T8Tvyh7OB1;

1.1
date	2015.11.22.20.55.18;	author reyk;	state Exp;
branches;
next	;
commitid	Ce3XWaK9k2YVSX7c;


desc
@@


1.8
log
@Replace vmmctl with vmctl.  Also remove parse.y from the "new" vmctl.

As discussed with mlarkin@@ and deraadt@@
@
text
@/*	$OpenBSD: parse.y,v 1.7 2015/12/03 08:52:29 reyk Exp $	*/

/*
 * Copyright (c) 2007-2015 Reyk Floeter <reyk@@openbsd.org>
 * Copyright (c) 2004, 2005 Esben Norby <norby@@openbsd.org>
 * Copyright (c) 2004 Ryan McBride <mcbride@@openbsd.org>
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{
#include <sys/types.h>
#include <sys/queue.h>
#include <sys/uio.h>

#include <machine/vmmvar.h>

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <netdb.h>
#include <err.h>

#include "vmd.h"
#include "parser.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

struct parse_result		 res;
static int			 errors = 0;

typedef struct {
	union {
		int64_t		 number;
		char		*string;
	} v;
	int lineno;
} YYSTYPE;

%}


%token	INCLUDE ERROR
%token	DISK NIFS PATH SIZE VMID
%token	ENABLE DISABLE VM KERNEL MEMORY
%token	<v.string>	STRING
%token  <v.number>	NUMBER
%type	<v.number>	disable

%%

grammar		: /* empty */
		| grammar include '\n'
		| grammar '\n'
		| grammar varset '\n'
		| grammar main '\n'
		| grammar error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 0)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

varset		: STRING '=' STRING		{
			if (symset($1, $3, 0) == -1)
				errx(1, "cannot store variable");
			free($1);
			free($3);
		}
		;

main		: VM STRING			{
			memset(&res, 0, sizeof(res));
			res.name = $2;
			res.nifs = -1;
		} '{' optnl vm_opts_l '}'	{
			if (res.disable) {
				warnx("%s:%d: vm \"%s\" disabled",
				    file->name, yylval.lineno, res.name);
			} else {
				res.action = CMD_START;
				if (vmmaction(&res) != 0)
					errx(1, "vmmaction");
			}
		}
		;

vm_opts_l	: vm_opts_l vm_opts nl
		| vm_opts optnl
		;

vm_opts		: disable			{
			res.disable = $1;
		}
		| DISK STRING			{
			if (parse_disk(&res, $2) != 0) {
				yyerror("failed to parse disks: %s", $2);
				free($2);
				YYERROR;
			}
		}
		| KERNEL STRING			{
			if (res.path != NULL) {
				yyerror("argument specified more than once");
				YYERROR;
			}
			res.path = $2;
		}
		| NIFS NUMBER			{
			if (res.nifs != -1) {
				yyerror("argument specified more than once");
				YYERROR;
			}
			if (parse_ifs(&res, NULL, $2) != 0) {
				yyerror("failed to parse interfaces: %lld", $2);
				YYERROR;
			}
		}
		| MEMORY NUMBER			{
			if (res.size != 0) {
				yyerror("argument specified more than once");
				YYERROR;
			}
			if (parse_size(&res, NULL, $2) != 0) {
				yyerror("failed to parse size: %lld", $2);
				YYERROR;
			}
		}
		| MEMORY STRING			{
			if (res.size != 0) {
				yyerror("argument specified more than once");
				YYERROR;
			}
			if (parse_size(&res, $2, 0) != 0) {
				yyerror("failed to parse size: %s", $2);
				free($2);
				YYERROR;
			}
		}
		;

disable		: ENABLE			{ $$ = 0; }
		| DISABLE			{ $$ = 1; }
		;

optnl		: '\n' optnl
		|
		;

nl		: '\n' optnl
		;

%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;
	char		*msg;

	file->errors++;
	va_start(ap, fmt);
	if (vasprintf(&msg, fmt, ap) == -1)
		errx(1, "yyerror vasprintf");
	va_end(ap);
	warnx("%s:%d: %s", file->name, yylval.lineno, msg);
	free(msg);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "disable",		DISABLE },
		{ "disk",		DISK },
		{ "enable",		ENABLE },
		{ "id",			VMID },
		{ "include",		INCLUDE },
		{ "interfaces",		NIFS },
		{ "kernel",		KERNEL },
		{ "memory",		MEMORY },
		{ "size",		SIZE },
		{ "vm",			VM }
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && \
	x != '!' && x != '=' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL) {
		warn("malloc");
		return (NULL);
	}
	if ((nfile->name = strdup(name)) == NULL) {
		warn("malloc");
		free(nfile);
		return (NULL);
	}
	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

int
parse_config(const char *filename)
{
	struct sym	*sym, *next;

	if ((file = pushfile(filename, 0)) == NULL) {
		return (-1);
	}
	topfile = file;
	setservent(1);

	yyparse();
	errors = file->errors;
	popfile();

	endservent();

	/* Free macros and check which have not been used. */
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entry);
		if (!sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		if (!sym->persist) {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}

	if (errors)
		return (-1);

	return (0);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
cmdline_symset(char *s)
{
	char	*sym, *val;
	int	ret;
	size_t	len;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	len = (val - s) + 1;
	if ((sym = malloc(len)) == NULL)
		errx(1, "cmdline_symset: malloc");

	(void)strlcpy(sym, s, len);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry)
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	return (NULL);
}
@


1.7
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2015/12/02 09:20:41 reyk Exp $	*/
@


1.6
log
@The earlier "nifs" change broke the configuration file; unbreak it by
adding a missing bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2015/12/01 20:52:44 halex Exp $	*/
d249 1
a249 1
 		{ "include",		INCLUDE },
d295 2
a296 1
			yyerror("reached end of file while parsing quoted string");
@


1.5
log
@Fix -i option handling.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2015/11/27 09:11:39 reyk Exp $	*/
d133 1
@


1.4
log
@Change the command line syntax to a "command + getopts" style, eg.
  vmmctl start "myvm" -m 512M -i 1 -d disk.img -k /bsd

Networking people like me are used to the human-readable CLI-style
syntax that we have in some of our OpenBSD *ctl tools, including
bgpctl, other routing daemons, or relayctl.  But this didn't work for
vmmctl, so change it to something a bit less human-readable but more
BSD- and POSIX-ish.  After all, the command line is only intended for
simple configuration, more details will go into the configuration
file, so we can avoid getopt flag conflicts or scary things like the
getsubopt(3) style.

OK krw@@ jasper@@, with input from kettenis@@ jmc@@ deraadt@@ mlarkin@@ etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2015/11/26 08:34:25 reyk Exp $	*/
d167 1
a167 1
			if (res.nifs) {
@


1.3
log
@Remove vmm enable / disable in parse.y as well -
see previous commit to vmd/vmmctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2015/11/24 10:17:15 espie Exp $	*/
d135 6
a140 2
				yyerror("vm \"%s\" disabled", res.name);
				YYACCEPT;
a141 4

			res.action = CMD_START;
			if (vmmaction(&res) != 0)
				errx(1, "vmmaction");
@


1.2
log
@zap useless use of strlen, okay reyk@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2015/11/22 20:55:18 reyk Exp $	*/
d92 1
a92 1
%token	ENABLE DISABLE VM VMM KERNEL MEMORY
d130 1
a130 7
main		: VMM disable			{
			memset(&res, 0, sizeof(res));
			res.action = $2 ? CMD_DISABLE : CMD_ENABLE;
			if (vmmaction(&res) != 0)
				errx(1, "vmmaction");
		}
		| VM STRING			{
d253 1
a253 2
		{ "vm",			VM },
		{ "vmm",		VMM }
@


1.1
log
@Add initial parser to support a vmm.conf(5) configuration file format
for vmm and virtual machines.  Additionally, add a matching vmmctl
command line grammar that replaces (most of the) getopt arguments.
The goal is to provide a sane way to configure vmm(4) and vmd(8).
"There is still a lot to be done, and fixed" in this as well.

OK mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d650 1
a650 1
	len = strlen(s) - strlen(val) + 1;
@

