head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.10
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.8
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.26.0.16
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.14
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.12
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.12
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.8
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.6
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.20.0.10
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.4
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.12
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.10
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.8
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.6
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.4
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.30
date	2015.12.08.07.16.33;	author mmcc;	state Exp;
branches;
next	1.29;
commitid	QKrmUIFIfVzljdoZ;

1.29
date	2015.01.16.06.40.23;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Uu5nFG3wCl0LACBb;

1.28
date	2013.12.05.17.36.12;	author jca;	state Exp;
branches;
next	1.27;

1.27
date	2013.12.04.16.05.44;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.27.23.59.58;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.29.21.11.10;	author maja;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.27.20.15.04;	author pyr;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.03.05.01.24;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.21.01.40.25;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.15.18.33.51;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.05.08.37.05;	author avsm;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.05.10.44.28;	author avsm;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.19.09.03.06;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.11.23.36.07;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.01.08.22.36.47;	author maja;	state Exp;
branches;
next	1.13;

1.13
date	97.08.09.23.10.12;	author maja;	state Exp;
branches;
next	1.12;

1.12
date	97.05.01.22.14.48;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.04.12.16.53.06;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.03.11.09.12.25;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	96.12.02.21.14.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.11.11.17.22.15;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.09.29.08.11.04;	author dm;	state Exp;
branches;
next	1.6;

1.6
date	96.06.27.20.25.54;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.26.21.26.39;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.05.30.09.53.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.30.01.36.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.20.00.47.01;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	95.11.01.16.56.37;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Remove NULL-checks before free().
@
text
@/*	$OpenBSD: ypserv_db.c,v 1.29 2015/01/16 06:40:23 deraadt Exp $ */

/*
 * Copyright (c) 1994 Mats O Jansson <moj@@stacken.kth.se>
 * Copyright (c) 1996 Charles D. Cranor
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * major revision/cleanup of Mats' version
 * done by Chuck Cranor <chuck@@ccrc.wustl.edu>
 * Jan 1996.
 */

#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <arpa/nameser.h>
#include <resolv.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/queue.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <syslog.h>
#include <errno.h>
#include "yplog.h"
#include "ypdb.h"
#include "ypdef.h"
#include "ypserv.h"

LIST_HEAD(domainlist, opt_domain);	/* LIST of domains */
LIST_HEAD(maplist, opt_map);		/* LIST of maps (in a domain) */
TAILQ_HEAD(mapq, opt_map);		/* TAILQ of maps (LRU) */

struct opt_map {
	mapname map;			/* map name (malloc'd) */
	DBM	*db;			/* database */
	struct opt_domain *dom;         /* back ptr to our domain */
	int     host_lookup;            /* host lookup */
	int     secure;                 /* secure map? */
	TAILQ_ENTRY(opt_map) mapsq;   /* map queue pointers */
	LIST_ENTRY(opt_map) mapsl;      /* map list pointers */
};

struct opt_domain {
	domainname	domain;         /* domain name (malloc'd) */
	struct maplist	dmaps;          /* the domain's active maps */
	LIST_ENTRY(opt_domain) domsl;	/* global linked list of domains */
};

struct domainlist doms;			/* global list of domains */
struct mapq maps;			/* global queue of maps (LRU) */

extern int usedns;

/*
 * ypdb_init: init the queues and lists
 */
void
ypdb_init(void)
{
	LIST_INIT(&doms);
	TAILQ_INIT(&maps);
}

/*
 * yp_private:
 * Check if key is a YP private key. Return TRUE if it is and
 * ypprivate is FALSE.
 */
static int
yp_private(datum key, int ypprivate)
{
	if (ypprivate)
		return (FALSE);

	if (key.dsize == 0 || key.dptr == NULL)
		return (FALSE);

	if (key.dsize == YP_LAST_LEN &&
	    strncmp(key.dptr, YP_LAST_KEY, YP_LAST_LEN) == 0)
		return(TRUE);
	if (key.dsize == YP_INPUT_LEN &&
	    strncmp(key.dptr, YP_INPUT_KEY, YP_INPUT_LEN) == 0)
		return(TRUE);
	if (key.dsize == YP_OUTPUT_LEN &&
	    strncmp(key.dptr, YP_OUTPUT_KEY, YP_OUTPUT_LEN) == 0)
		return(TRUE);
	if (key.dsize == YP_MASTER_LEN &&
	    strncmp(key.dptr, YP_MASTER_KEY, YP_MASTER_LEN) == 0)
		return(TRUE);
	if (key.dsize == YP_DOMAIN_LEN &&
	    strncmp(key.dptr, YP_DOMAIN_KEY, YP_DOMAIN_LEN) == 0)
		return(TRUE);
	if (key.dsize == YP_INTERDOMAIN_LEN &&
	    strncmp(key.dptr, YP_INTERDOMAIN_KEY, YP_INTERDOMAIN_LEN) == 0)
		return(TRUE);
	if (key.dsize == YP_SECURE_LEN &&
	    strncmp(key.dptr, YP_SECURE_KEY, YP_SECURE_LEN) == 0)
		return(TRUE);
	return(FALSE);
}

/*
 * Close least recent used map. This routine is called when we have
 * no more file descripotors free, or we want to close all maps.
 */
static void
ypdb_close_last(void)
{
	struct opt_map *last;

	if (TAILQ_EMPTY(&maps)) {
		yplog("  ypdb_close_last: LRU list is empty!");
		return;
	}

	last = TAILQ_LAST(&maps, mapq);

	TAILQ_REMOVE(&maps, last, mapsq);	/* remove from LRU circleq */
	LIST_REMOVE(last, mapsl);		/* remove from domain list */

#ifdef DEBUG
	yplog("  ypdb_close_last: closing map %s in domain %s [db=0x%x]",
	    last->map, last->dom->domain, last->db);
#endif

	ypdb_close(last->db);			/* close DB */
	free(last->map);			/* free map name */
	free(last);				/* free map */
}

/*
 * Close all open maps.
 */
void
ypdb_close_all(void)
{

#ifdef DEBUG
	yplog("  ypdb_close_all(): start");
#endif
	while (!TAILQ_EMPTY(&maps))
		ypdb_close_last();
#ifdef DEBUG
	yplog("  ypdb_close_all(): done");
#endif
}

/*
 * Close Database if Open/Close Optimization isn't turned on.
 */
static void
ypdb_close_db(DBM *db)
{
#ifdef DEBUG
	yplog("  ypdb_close_db(0x%x)", db);
#endif
#ifndef OPTDB
	ypdb_close_all();
#endif
}

/*
 * ypdb_open_db
 */
DBM *
ypdb_open_db(domainname domain, mapname map, ypstat *status,
    struct opt_map **map_info)
{
	char map_path[PATH_MAX];
	static char   *domain_key = YP_INTERDOMAIN_KEY;
	static char   *secure_key = YP_SECURE_KEY;
	DBM	*db;
	struct opt_domain *d = NULL;
	struct opt_map	*m = NULL;
	datum	k, v;
#ifdef OPTDB
	int	i;
#endif

	/*
	 * check for preloaded domain, map
	 */
	LIST_FOREACH(d, &doms, domsl) {
		if (strcmp(domain, d->domain) == 0)
			break;
	}

	if (d) {
		LIST_FOREACH(m, &d->dmaps, mapsl)
			if (strcmp(map, m->map) == 0)
				break;
	}

	/*
	 * map found open?
	 */
	if (m) {
#ifdef DEBUG
		yplog("  ypdb_open_db: cached open: domain=%s, map=%s, db=0x%x",
		    domain, map, m->db);
#endif
		TAILQ_REMOVE(&maps, m, mapsq);	/* adjust LRU queue */
		TAILQ_INSERT_HEAD(&maps, m, mapsq);
		*status = YP_TRUE;
		if (map_info)
			*map_info = m;
		return(m->db);
	}

	/* Check for illegal charcaters */

	if (strchr(domain, '/')) {
		*status = YP_NODOM;
		return (NULL);
	}
	if (strchr(map, '/')) {
		*status = YP_NOMAP;
		return (NULL);
	}

	/*
	 * open map
	 */
#ifdef OPTDB
	i = 0;
	while (i == 0) {
#endif
		snprintf(map_path, sizeof(map_path), "%s/%s/%s", YP_DB_PATH,
		    domain, map);
		db = ypdb_open(map_path, O_RDONLY, 0444);
#ifdef OPTDB
		if (db == NULL) {
#ifdef DEBUG
			yplog("  ypdb_open_db: errno %d (%s)",
			    errno, sys_errlist[errno]);
#endif
			if (errno == ENFILE || errno == EMFILE) {
				ypdb_close_last();
			} else {
				i = errno;
			}
		} else {
			i = 4711;
		}
	}
#endif
	*status = YP_NOMAP;		/* see note below */
	if (db == NULL) {
		if (errno == ENOENT) {
#ifdef DEBUG
			yplog("  ypdb_open_db: no map %s (domain=%s)",
			    map, domain);
#endif
			return(NULL);
		}
#ifdef DEBUG
		yplog("  ypdb_open_db: ypdb_open FAILED: map %s (domain=%s)",
		    map, domain);
#endif
		return(NULL);
	}

	/*
	 * note: status now YP_NOMAP
	 */

	if (d == NULL) {		/* allocate new domain? */
		d = malloc(sizeof(*d));
		if (d)
			d->domain = strdup(domain);
		if (d == NULL || d->domain == NULL) {
			yplog("  ypdb_open_db: MALLOC failed");
			ypdb_close(db);
			free(d);
			return(NULL);
		}
		LIST_INIT(&d->dmaps);
		LIST_INSERT_HEAD(&doms, d, domsl);
#ifdef DEBUG
		yplog("  ypdb_open_db: NEW DOMAIN %s", domain);
#endif
	}

	/*
	 * m must be NULL since we couldn't find a map.  allocate new one
	 */

	m = malloc(sizeof(*m));
	if (m)
		m->map = strdup(map);
	if (m == NULL || m->map == NULL) {
		free(m);
		yplog("  ypdb_open_db: MALLOC failed");
		ypdb_close(db);
		return(NULL);
	}
	m->db = db;
	m->dom = d;
	m->host_lookup = FALSE;
	TAILQ_INSERT_HEAD(&maps, m, mapsq);
	LIST_INSERT_HEAD(&d->dmaps, m, mapsl);
	if (strcmp(map, YP_HOSTNAME) == 0 || strcmp(map, YP_HOSTADDR) == 0) {
		if (!usedns) {
			k.dptr = domain_key;
			k.dsize = YP_INTERDOMAIN_LEN;
			v = ypdb_fetch(db, k);
			if (v.dptr)
				m->host_lookup = TRUE;
		} else
			m->host_lookup = TRUE;
	}
	m->secure = FALSE;
	k.dptr = secure_key;
	k.dsize = YP_SECURE_LEN;
	v = ypdb_fetch(db, k);
	if (v.dptr)
		m->secure = TRUE;
	*status = YP_TRUE;
	if (map_info)
		*map_info = m;
#ifdef DEBUG
	yplog("  ypdb_open_db: NEW MAP domain=%s, map=%s, hl=%d, s=%d, db=0x%x",
	    domain, map, m->host_lookup, m->secure, m->db);
#endif
	return(m->db);
}

/*
 * lookup host
 */
static ypstat
lookup_host(int nametable, int host_lookup, DBM *db, char *keystr,
    ypresp_val *result)
{
	struct hostent *host;
	struct in_addr *addr_name;
	struct in_addr addr_addr;
	static char val[BUFSIZ+1]; /* match libc */
	static char hostname[HOST_NAME_MAX+1];
	char tmpbuf[HOST_NAME_MAX+1 + 20], *v, *ptr;
	size_t len;
	int l;

	if (!host_lookup)
		return(YP_NOKEY);

	if ((_res.options & RES_INIT) == 0)
		res_init();
	bcopy("b", _res.lookups, sizeof("b"));

	if (nametable) {
		host = gethostbyname(keystr);
		if (host == NULL || host->h_addrtype != AF_INET)
			return(YP_NOKEY);
		addr_name = (struct in_addr *) *host->h_addr_list;
		v = val;
		for (; host->h_addr_list[0] != NULL; host->h_addr_list++) {
			addr_name = (struct in_addr *)host->h_addr_list[0];
			snprintf(tmpbuf, sizeof(tmpbuf), "%s %s\n",
			    inet_ntoa(*addr_name), host->h_name);
			len = strlcat(val, tmpbuf, sizeof(val));
			if (len >= sizeof(val))
				break;
			v = val + len;
		}
		result->val.valdat_val = val;
		result->val.valdat_len = v - val;
		return(YP_TRUE);
	}

	inet_aton(keystr, &addr_addr);
	host = gethostbyaddr((char *)&addr_addr, sizeof(addr_addr), AF_INET);
	if (host == NULL) return(YP_NOKEY);

	strncpy((char *)hostname, host->h_name, sizeof(hostname) - 1);
	hostname[sizeof(hostname) - 1] = '\0';
	host = gethostbyname((char *)hostname);
	if (host == NULL)
		return(YP_NOKEY);

	l = 0;
	for (; host->h_addr_list[0] != NULL; host->h_addr_list++)
		if (!bcmp(host->h_addr_list[0], &addr_addr, sizeof(addr_addr)))
			l++;
	if (l == 0) {
		yplog("lookup_host: address %s not listed for host %s\n",
		    inet_ntoa(addr_addr), hostname);
		syslog(LOG_NOTICE,
		    "ypserv: address %s not listed for host %s\n",
		    inet_ntoa(addr_addr), hostname);
		return(YP_NOKEY);
	}

	len = snprintf(val, sizeof(val), "%s %s", keystr, host->h_name);
	if (len == (size_t)-1 || len >= sizeof(val))
		return(YP_YPERR);
	v = val + len;
	while ((ptr = *(host->h_aliases)) != NULL) {
		strlcat(val, " ", sizeof(val));
		len = strlcat(val, ptr, sizeof(val));
		if (len >= sizeof(val))
			break;
		v = val + len;
		host->h_aliases++;
	}
	result->val.valdat_val = val;
	result->val.valdat_len = v - val;

	return(YP_TRUE);
}

ypresp_val
ypdb_get_record(domainname domain, mapname map, keydat key, int ypprivate)
{
	static	ypresp_val res;
	static	char keystr[YPMAXRECORD+1];
	DBM	*db;
	datum	k, v;
	int	host_lookup = 0, hn;
	struct opt_map *map_info = NULL;

	bzero(&res, sizeof(res));

	db = ypdb_open_db(domain, map, &res.stat, &map_info);
	if (!db || res.stat < 0)
		return(res);
	if (map_info)
		host_lookup = map_info->host_lookup;

	k.dptr = key.keydat_val;
	k.dsize = key.keydat_len;

	if (yp_private(k, ypprivate)) {
		res.stat = YP_NOKEY;
		goto done;
	}

	v = ypdb_fetch(db, k);

	if (v.dptr == NULL) {
		res.stat = YP_NOKEY;
		if ((hn = strcmp(map, YP_HOSTNAME)) != 0 &&
		    strcmp(map, YP_HOSTADDR) != 0)
			goto done;
		/* note: lookup_host needs null terminated string */
		strncpy(keystr, key.keydat_val, key.keydat_len);
		keystr[key.keydat_len] = '\0';
		res.stat = lookup_host((hn == 0) ? TRUE : FALSE,
		    host_lookup, db, keystr, &res);
	} else {
		res.val.valdat_val = v.dptr;
		res.val.valdat_len = v.dsize;
	}

done:
	ypdb_close_db(db);
	return(res);
}

ypresp_key_val
ypdb_get_first(domainname domain, mapname map, int ypprivate)
{
	static ypresp_key_val res;
	DBM	*db;
	datum	k, v;

	bzero(&res, sizeof(res));

	db = ypdb_open_db(domain, map, &res.stat, NULL);

	if (res.stat >= 0) {
		k = ypdb_firstkey(db);

		while (yp_private(k, ypprivate))
			k = ypdb_nextkey(db);

		if (k.dptr == NULL) {
			res.stat = YP_NOKEY;
		} else {
			res.key.keydat_val = k.dptr;
			res.key.keydat_len = k.dsize;
			v = ypdb_fetch(db, k);
			if (v.dptr == NULL) {
				res.stat = YP_NOKEY;
			} else {
				res.val.valdat_val = v.dptr;
				res.val.valdat_len = v.dsize;
			}
		}
	}
	ypdb_close_db(db);
	return (res);
}

ypresp_key_val
ypdb_get_next(domainname domain, mapname map, keydat key, int ypprivate)
{
	static ypresp_key_val res;
	DBM	*db;
	datum	k, v, n;

	bzero(&res, sizeof(res));
	db = ypdb_open_db(domain, map, &res.stat, NULL);

	if (res.stat >= 0) {
		n.dptr = key.keydat_val;
		n.dsize = key.keydat_len;
		v.dptr = NULL;
		v.dsize = 0;
		k.dptr = NULL;
		k.dsize = 0;

		n = ypdb_setkey(db, n);

		if (n.dptr != NULL)
			k = ypdb_nextkey(db);
		else
			k.dptr = NULL;

		if (k.dptr != NULL) {
			while (yp_private(k, ypprivate))
				k = ypdb_nextkey(db);
		}

		if (k.dptr == NULL) {
			res.stat = YP_NOMORE;
		} else {
			res.key.keydat_val = k.dptr;
			res.key.keydat_len = k.dsize;
			v = ypdb_fetch(db, k);
			if (v.dptr == NULL) {
				res.stat = YP_NOMORE;
			} else {
				res.val.valdat_val = v.dptr;
				res.val.valdat_len = v.dsize;
			}
		}
	}
	ypdb_close_db(db);
	return (res);
}

ypresp_order
ypdb_get_order(domainname domain, mapname map)
{
	static ypresp_order res;
	static char   *order_key = YP_LAST_KEY;
	char   order[MAX_LAST_LEN+1];
	DBM	*db;
	datum	k, v;

	bzero(&res, sizeof(res));
	db = ypdb_open_db(domain, map, &res.stat, NULL);

	if (res.stat >= 0) {
		k.dptr = order_key;
		k.dsize = YP_LAST_LEN;

		v = ypdb_fetch(db, k);
		if (v.dptr == NULL) {
			res.stat = YP_NOKEY;
		} else {
			strncpy(order, v.dptr, v.dsize);
			order[v.dsize] = '\0';
			res.ordernum = (u_int32_t)atol(order);
		}
	}
	ypdb_close_db(db);
	return (res);
}

ypresp_master
ypdb_get_master(domainname domain, mapname map)
{
	static ypresp_master res;
	static char   *master_key = YP_MASTER_KEY;
	static char   master[MAX_MASTER_LEN+1];
	DBM	*db;
	datum	k, v;

	bzero(&res, sizeof(res));
	db = ypdb_open_db(domain, map, &res.stat, NULL);

	if (res.stat >= 0) {
		k.dptr = master_key;
		k.dsize = YP_MASTER_LEN;

		v = ypdb_fetch(db, k);
		if (v.dptr == NULL) {
			res.stat = YP_NOKEY;
		} else {
			strncpy(master, v.dptr, v.dsize);
			master[v.dsize] = '\0';
			res.peer = (peername) &master;
		}
	}
	ypdb_close_db(db);
	return (res);
}

bool_t
ypdb_xdr_get_all(XDR *xdrs, ypreq_nokey *req)
{
	static ypresp_all resp;
	DBM	*db;
	datum	k, v;

	bzero(&resp, sizeof(resp));

	/*
	 * open db, and advance past any private keys we may see
	 */
	db = ypdb_open_db(req->domain, req->map,
	    &resp.ypresp_all_u.val.stat, NULL);
	if (!db || resp.ypresp_all_u.val.stat < 0)
		return(FALSE);
	k = ypdb_firstkey(db);
	while (yp_private(k, FALSE))
		k = ypdb_nextkey(db);

	while (1) {
		if (k.dptr == NULL)
			break;

		v = ypdb_fetch(db, k);
		if (v.dptr == NULL)
			break;

		resp.more = TRUE;
		resp.ypresp_all_u.val.stat = YP_TRUE;
		resp.ypresp_all_u.val.key.keydat_val = k.dptr;
		resp.ypresp_all_u.val.key.keydat_len = k.dsize;
		resp.ypresp_all_u.val.val.valdat_val = v.dptr;
		resp.ypresp_all_u.val.val.valdat_len = v.dsize;

		if (!xdr_ypresp_all(xdrs, &resp)) {
#ifdef DEBUG
			yplog("  ypdb_xdr_get_all: xdr_ypresp_all failed");
#endif
			return(FALSE);
		}

		/* advance past private keys */
		k = ypdb_nextkey(db);
		while (yp_private(k, FALSE))
			k = ypdb_nextkey(db);
	}

	bzero(&resp, sizeof(resp));
	resp.ypresp_all_u.val.stat = YP_NOKEY;
	resp.more = FALSE;

	if (!xdr_ypresp_all(xdrs, &resp)) {
#ifdef DEBUG
		yplog("  ypdb_xdr_get_all: final xdr_ypresp_all failed");
#endif
		return(FALSE);
	}
	ypdb_close_db(db);
	return (TRUE);
}

int
ypdb_secure(domainname domain, mapname map)
{
	static	ypresp_val res;
	DBM	*db;
	int	secure;
	struct opt_map *map_info = NULL;

	bzero(&res, sizeof(res));
	secure = FALSE;

	db = ypdb_open_db(domain, map, &res.stat, &map_info);
	if (!db || res.stat < 0)
		return(secure);			/* ? */
	if (map_info)
		secure = map_info->secure;

	ypdb_close_db(db);
	return(secure);
}
@


1.29
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.28 2013/12/05 17:36:12 jca Exp $ */
d304 1
a304 2
			if (d)
				free(d);
d322 1
a322 2
		if (m)
			free(m);
@


1.28
log
@In lookup_host(), return to caller a properly calculated message length
instead of using an uninitialized variable.  While here, simplify the
code that calculates the message length, and use snprintf/strlcat more
carefully.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.27 2013/12/04 16:05:44 krw Exp $ */
a39 1
#include <sys/param.h>
d199 1
a199 1
	char map_path[MAXPATHLEN];
d371 2
a372 2
	static char hostname[MAXHOSTNAMELEN];
	char tmpbuf[MAXHOSTNAMELEN + 20], *v, *ptr;
@


1.27
log
@opt_map CIRCLEQ -> TAILQ.

ok jsing@@ (with nit), jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.26 2009/10/27 23:59:58 deraadt Exp $ */
d374 1
d394 2
a395 1
			if (v - val + strlen(tmpbuf) + 1 > sizeof(val))
d397 1
a397 2
			strlcpy(v, tmpbuf, sizeof(val)); /* v == val */
			v = v + strlen(tmpbuf);
d427 4
a430 1
	snprintf(val, sizeof(val), "%s %s", keystr, host->h_name);
d433 2
a434 1
		if (strlcat(val, ptr, sizeof(val)) > sizeof(val))
d436 1
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.25 2007/05/29 21:11:10 maja Exp $ */
d62 1
a62 1
CIRCLEQ_HEAD(mapq, opt_map);		/* CIRCLEQ of maps (LRU) */
d70 1
a70 1
	CIRCLEQ_ENTRY(opt_map) mapsq;   /* map queue pointers */
d92 1
a92 1
	CIRCLEQ_INIT(&maps);
d140 1
a140 1
	struct opt_map *last = CIRCLEQ_LAST(&maps);
d142 1
a142 1
	if (last == (void *)&maps) {
d147 3
a149 1
	CIRCLEQ_REMOVE(&maps, last, mapsq);	/* remove from LRU circleq */
d172 1
a172 1
	while (!CIRCLEQ_EMPTY(&maps))
d233 2
a234 2
		CIRCLEQ_REMOVE(&maps, m, mapsq);	/* adjust LRU queue */
		CIRCLEQ_INSERT_HEAD(&maps, m, mapsq);
d333 1
a333 1
	CIRCLEQ_INSERT_HEAD(&maps, m, mapsq);
@


1.25
log
@Remove clause 3 and 4. Ok with Chuck. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.24 2007/05/27 20:15:04 pyr Exp $ */
a28 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.24 2007/05/27 20:15:04 pyr Exp $";
#endif
@


1.24
log
@use macros from sys/queue.h
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.23 2006/04/03 05:01:24 deraadt Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson
 *	and Charles D. Cranor.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.23 2006/04/03 05:01:24 deraadt Exp $";
@


1.23
log
@spreading the lint love (very minimal things..)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.22 2005/12/21 01:40:25 millert Exp $ */
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.22 2005/12/21 01:40:25 millert Exp $";
d150 1
a150 1
	struct opt_map *last = maps.cqh_last;
@


1.22
log
@Userland programs should include <errno.h> not <sys/errno.h>
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.21 2005/10/15 18:33:51 otto Exp $ */
d36 2
a37 2
#ifndef LINT
static const char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.21 2005/10/15 18:33:51 otto Exp $";
d76 1
a76 1
	DBM     *db;                    /* database */
d307 1
a307 1
		d = (struct opt_domain *) malloc(sizeof(*d));
d328 1
a328 1
	m = (struct opt_map *) malloc(sizeof(*m));
d412 1
a412 1
	host = gethostbyaddr((char *) &addr_addr, sizeof(addr_addr), AF_INET);
d457 1
a457 1
	bzero((char *)&res, sizeof(res));
d502 1
a502 1
	bzero((char *)&res, sizeof(res));
d537 1
a537 1
	bzero((char *)&res, sizeof(res));
d587 1
a587 1
	bzero((char *)&res, sizeof(res));
d616 1
a616 1
	bzero((char *)&res, sizeof(res));
d643 1
a643 1
	bzero((char *)&resp, sizeof(resp));
d684 1
a684 1
	bzero((char *)&resp, sizeof(resp));
d706 1
a706 1
	bzero((char *)&res, sizeof(res));
@


1.21
log
@Use queue macros instead of directly accessing fields. ok miod@@ pat@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.20 2003/07/15 06:10:46 deraadt Exp $ */
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.20 2003/07/15 06:10:46 deraadt Exp $";
d64 1
a64 1
#include <sys/errno.h>
@


1.20
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.19 2003/05/05 08:37:05 avsm Exp $ */
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.19 2003/05/05 08:37:05 avsm Exp $";
d180 1
a180 1
	while (maps.cqh_first != (void *)&maps)
d222 1
a222 1
	for (d = doms.lh_first ; d != NULL ; d = d->domsl.le_next) {
d228 1
a228 1
		for (m = d->dmaps.lh_first ; m != NULL ; m = m->mapsl.le_next)
@


1.19
log
@-Wall cleanup: trim unused vars, better err() message in stdhosts,
and constify rcsid[]

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.18 2003/04/05 10:44:28 avsm Exp $ */
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.18 2003/04/05 10:44:28 avsm Exp $";
d68 1
d75 7
a81 7
	mapname	map;			/* map name (malloc'd) */
	DBM	*db;			/* database */
	struct opt_domain *dom;		/* back ptr to our domain */
	int	host_lookup;		/* host lookup */
	int	secure;			/* secure map? */
	CIRCLEQ_ENTRY(opt_map) mapsq;	/* map queue pointers */
	LIST_ENTRY(opt_map) mapsl;	/* map list pointers */
d85 3
a87 3
	domainname	domain;		/* domain name (malloc'd) */
	struct maplist	dmaps;		/* the domain's active maps */
	LIST_ENTRY(opt_domain) domsl;   /* global linked list of domains */
a99 1

d110 1
a110 1
int
d147 1
a147 1
void
d190 1
a190 1
void
d372 1
a372 1
ypstat
@


1.18
log
@simplify a loop, convert it to strlcat; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.17 2002/07/19 02:38:40 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.17 2002/07/19 02:38:40 deraadt Exp $";
@


1.17
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.16 2001/11/19 09:03:06 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.16 2001/11/19 09:03:06 deraadt Exp $";
d403 1
a403 1
			strcpy(v, tmpbuf);
a434 2
	l = strlen(val);
	v = val + l;
d436 2
a437 2
		l = strlen(ptr);
		if ((v - val) + l + 1 > BUFSIZ)
a438 4
		strcpy(v, " ");
		v += 1;
		strcpy(v, ptr);
		v += l;
@


1.16
log
@use a private svc_run() function that checks for a signal handler flag;
now signal safe.  Also, massive KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.15 2001/01/11 23:36:07 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.15 2001/01/11 23:36:07 deraadt Exp $";
d41 1
a41 1
 * major revision/cleanup of Mats' version 
d98 1
a98 1
ypdb_init()
d111 1
a111 3
yp_private(key, ypprivate)
	datum	key;
	int	ypprivate;
d113 1
a113 3
	int	result;

  	if (ypprivate)
a139 1
	
d148 1
a148 1
ypdb_close_last()
d152 1
a152 1
	if (last == (void*)&maps) {
d174 1
a174 1
ypdb_close_all()
d176 1
a176 1
	
d191 1
a191 2
ypdb_close_db(db)
	DBM	*db;
d205 2
a206 5
ypdb_open_db(domain, map, status, map_info)
	domainname	domain;
	mapname		map;
	ypstat		*status;
	struct opt_map	**map_info;
a210 1
	struct	stat finfo;
a211 1
	int	fd;
d267 1
a267 1
		snprintf(map_path, sizeof(map_path), "%s/%s/%s", YP_DB_PATH, 
d296 1
a296 1
		yplog("  ypdb_open_db: ypdb_open FAILED: map %s (domain=%s)", 
d301 1
a301 1
	
d363 1
a363 1
	yplog("  ypdb_open_db: NEW MAP domain=%s, map=%s, hl=%d, s=%d, db=0x%x", 
d373 2
a374 6
lookup_host(nametable, host_lookup, db, keystr, result)
	int	nametable;
	int	host_lookup;
	DBM	*db;
	char	*keystr;
	ypresp_val *result;
d376 6
a381 7
	struct	hostent	*host;
	struct  in_addr *addr_name;
	struct	in_addr addr_addr;
	static  char val[BUFSIZ+1]; /* match libc */
	static	hostname[MAXHOSTNAMELEN];
	char	tmpbuf[MAXHOSTNAMELEN + 20];
	char *v;
d383 1
a383 2
	char	*ptr;
	
d393 1
a393 1
		if (host == NULL || host->h_addrtype != AF_INET) 
d422 1
a422 1
	for(; host->h_addr_list[0] != NULL; host->h_addr_list++)
d454 1
a454 5
ypdb_get_record(domain, map, key, ypprivate)
	domainname	domain;
	mapname		map;
	keydat		key;
	int		ypprivate;
d460 1
a460 1
	int	host_lookup, hn;
d464 1
a464 1
	
d466 1
a466 1
	if (!db || res.stat < 0) 
d473 1
a473 1
	
d484 1
a484 1
		    strcmp(map, YP_HOSTADDR) != 0) 
a498 1
	
d502 1
a502 4
ypdb_get_first(domain, map, ypprivate)
	domainname domain;
	mapname map;
	int ypprivate;
d509 1
a509 1
	
d514 1
a514 1
	  
d517 1
a517 1
	  
d537 1
a537 5
ypdb_get_next(domain, map, key, ypprivate)
	domainname domain;
	mapname map;
	keydat key;
	int ypprivate;
d545 1
a545 1
	
d585 1
a585 3
ypdb_get_order(domain, map)
	domainname domain;
	mapname map;
d595 1
a595 1
	
d614 1
a614 3
ypdb_get_master(domain, map)
	domainname domain;
	mapname map;
d624 1
a624 1
	
d643 1
a643 3
ypdb_xdr_get_all(xdrs, req)
	XDR *xdrs;
	ypreq_nokey *req;
d650 1
a650 1
	
d654 1
a654 1
	db = ypdb_open_db(req->domain, req->map, 
d656 1
a656 1
	if (!db || resp.ypresp_all_u.val.stat < 0) 
d661 3
a663 3
	
	while(1) {
		if (k.dptr == NULL) 
d667 1
a667 1
		if (v.dptr == NULL) 
d676 1
a676 1
			
d680 1
a680 1
#endif					
d683 1
a683 1
			
d689 1
a689 1
		
d693 1
a693 1
	
d705 1
a705 3
ypdb_secure(domain, map)
	domainname	domain;
	mapname		map;
d716 1
a716 1
	if (!db || res.stat < 0) 
a723 1

@


1.15
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.14 1998/01/08 22:36:47 maja Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.14 1998/01/08 22:36:47 maja Exp $";
a45 1

a88 1

a96 1

a104 1

a109 1

d111 1
a111 1
yp_private(key,ypprivate)
d118 1
a118 1
	    return (FALSE);
d124 1
a124 1
	    strncmp(key.dptr,YP_LAST_KEY,YP_LAST_LEN) == 0)
d127 1
a127 1
	    strncmp(key.dptr,YP_INPUT_KEY,YP_INPUT_LEN) == 0)
d130 1
a130 1
	    strncmp(key.dptr,YP_OUTPUT_KEY,YP_OUTPUT_LEN) == 0)
d133 1
a133 1
	    strncmp(key.dptr,YP_MASTER_KEY,YP_MASTER_LEN) == 0)
d136 1
a136 1
	    strncmp(key.dptr,YP_DOMAIN_KEY,YP_DOMAIN_LEN) == 0)
d139 1
a139 1
	    strncmp(key.dptr,YP_INTERDOMAIN_KEY,YP_INTERDOMAIN_LEN) == 0)
d142 1
a142 1
	    strncmp(key.dptr,YP_SECURE_KEY,YP_SECURE_LEN) == 0)
d146 1
a146 1
}     
a151 1

d167 1
a167 1
		last->map, last->dom->domain, last->db);
a172 2

	
a177 1

d185 1
a185 1
	while (maps.cqh_first != (void *)&maps) {
a186 1
	}
a194 1

a209 1

d225 1
a225 1
	datum	k,v;
d229 1
a232 1

d234 2
a235 1
		if (strcmp(domain, d->domain) == 0) break;
d240 2
a241 1
			if (strcmp(map, m->map) == 0) break;
a246 1

d250 1
a250 1
			domain, map, m->db);
d255 2
a256 1
		if (map_info) *map_info = m;
a270 1

d279 1
a279 1
			 domain, map);
d285 1
a285 1
		        errno,sys_errlist[errno]);
d287 1
a287 1
			if ((errno == ENFILE) || (errno == EMFILE)) {
d295 1
a295 1
	};
d302 1
a302 1
			      map, domain);
d308 1
a308 1
			map, domain);
d319 2
a320 1
		if (d) d->domain = strdup(domain);
d324 2
a325 1
			if (d) free(d);
d340 1
a340 1
	if (m) {
a341 1
	}
d343 2
a344 1
		if (m) free(m);
d358 4
a361 3
			v = ypdb_fetch(db,k);
			if (v.dptr) m->host_lookup = TRUE;
		} else {
a362 1
		}
d367 3
a369 2
	v = ypdb_fetch(db,k);
	if (v.dptr) m->secure = TRUE;
d371 2
a372 1
	if (map_info) *map_info = m;
d374 2
a375 2
	     yplog("  ypdb_open_db: NEW MAP domain=%s, map=%s, hl=%d, s=%d, db=0x%x", 
			domain, map, m->host_lookup, m->secure, m->db);
a382 1

d401 2
a402 1
	if (!host_lookup) return(YP_NOKEY);
d435 2
a436 1
	if (host == NULL) return(YP_NOKEY);
d444 1
a444 1
		       inet_ntoa(addr_addr), hostname);
d446 2
a447 2
		       "ypserv: address %s not listed for host %s\n",
		       inet_ntoa(addr_addr), hostname);
d451 1
a451 1
	snprintf(val,sizeof(val),"%s %s",keystr,host->h_name);
d480 1
a480 1
	datum	k,v;
d495 1
a495 1
	if (yp_private(k,ypprivate)) {
d505 1
a505 1
				strcmp(map, YP_HOSTADDR) != 0) 
d511 1
a511 1
				host_lookup, db, keystr, &res);
d531 1
a531 1
	datum	k,v;
d538 1
a538 2

	  k = ypdb_firstkey(db);
d540 2
a541 3
	  while (yp_private(k,ypprivate)) {
	    k = ypdb_nextkey(db);
	  };
d543 13
a555 13
	  if (k.dptr == NULL) {
	    res.stat = YP_NOKEY;
	  } else {
	    res.key.keydat_val = k.dptr;
	    res.key.keydat_len = k.dsize;
	    v = ypdb_fetch(db,k);
	    if (v.dptr == NULL) {
	      res.stat = YP_NOKEY;
	    } else {
	      res.val.valdat_val = v.dptr;
	      res.val.valdat_len = v.dsize;
	    }
	  }
a556 1

a557 1
	
d570 1
a570 1
	datum	k,v,n;
a572 1
	
d576 6
d583 25
a607 34
	  n.dptr = key.keydat_val;
	  n.dsize = key.keydat_len;
	  v.dptr = NULL;
	  v.dsize = 0;
	  k.dptr = NULL;
	  k.dsize = 0;

	  n = ypdb_setkey(db,n);

	  if (n.dptr != NULL) {
	    k = ypdb_nextkey(db);
	  } else {
	    k.dptr = NULL;
	  };

	  if (k.dptr != NULL) {
	    while (yp_private(k,ypprivate)) {
	      k = ypdb_nextkey(db);
	    };
	  };

	  if (k.dptr == NULL) {
	    res.stat = YP_NOMORE;
	  } else {
	    res.key.keydat_val = k.dptr;
	    res.key.keydat_len = k.dsize;
	    v = ypdb_fetch(db,k);
	    if (v.dptr == NULL) {
	      res.stat = YP_NOMORE;
	    } else {
	      res.val.valdat_val = v.dptr;
	      res.val.valdat_len = v.dsize;
	    }
	  }
a608 1

a609 1
	
d622 1
a622 1
	datum	k,v;
a624 1
	
d628 2
d631 8
a638 11
	  k.dptr = order_key;
	  k.dsize = YP_LAST_LEN;

	  v = ypdb_fetch(db,k);
	  if (v.dptr == NULL) {
	    res.stat = YP_NOKEY;
	  } else {
	    strncpy(order, v.dptr, v.dsize);
	    order[v.dsize] = '\0';
	    res.ordernum = (u_int32_t)atol(order);
	  }
a639 1

a640 1
	
d653 1
a653 1
	datum	k,v;
a655 1
	
d659 2
d662 8
a669 11
	  k.dptr = master_key;
	  k.dsize = YP_MASTER_LEN;

	  v = ypdb_fetch(db,k);
	  if (v.dptr == NULL) {
	    res.stat = YP_NOKEY;
	  } else {
	    strncpy(master, v.dptr, v.dsize);
	    master[v.dsize] = '\0';
	    res.peer = (peername) &master;
	  }
a670 1

a671 1
	
d682 1
a682 1
	datum	k,v;
a688 1

d690 1
a690 1
			&resp.ypresp_all_u.val.stat, NULL);
d694 1
a694 1
	while (yp_private(k,FALSE)) {
a695 1
	};
a697 1
		
d701 1
a701 2
		v = ypdb_fetch(db,k);

d721 1
a721 1
		while (yp_private(k,FALSE)) {
a722 1
		}
a734 1
		
a735 1
	
@


1.14
log
@Fix some problems with xfr of secure maps. Problem reported by
Eric Rungi <rungus@@openface.org> -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.13 1997/08/09 23:10:12 maja Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.13 1997/08/09 23:10:12 maja Exp $";
d423 2
a424 2
			snprintf(tmpbuf,sizeof(tmpbuf), "%s %s\n",
				inet_ntoa(*addr_name), host->h_name);
@


1.13
log
@Increased performance in ypserv by two different actions:

1) ypdb_open_db now check error condition when something goes wrong.
   Instead of always as before. by request of theo.

2) turned on -DOPTDB in Makefile. This will cause ypserv to keep databases
   opened. If not defined ypserv will open and close the map for every
   request. I think it was turned off before when yppush didn't work.

   If a map changes yppush will signal to ypserv that the map has changed
   and ypserv will reopen the map.

   ypserv will start closing maps when it run out of file descriptors. Then
   it will close the map least resent used.

-moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.12 1997/05/01 22:14:48 niklas Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.12 1997/05/01 22:14:48 niklas Exp $";
d266 1
@


1.12
log
@Umm, fix signedness error in my last commit, be explicit
about the fact that ordernumbers are 32 bit
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.11 1997/04/12 16:53:06 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.11 1997/04/12 16:53:06 deraadt Exp $";
d65 1
d238 3
a240 1
	
d269 1
a269 10
	/*
	 * database not open, first check for "out of fd" and close a db if
	 * out...
	 */

	fd = open("/", O_RDONLY);
	if (fd < 0) 
		ypdb_close_last();
	else
		close(fd);
d275 1
a275 1
	if (strchr(domain, '/')) {
d280 1
d282 1
a282 1
	 * check for domain, file.   
d284 9
a292 4

	snprintf(map_path, sizeof(map_path), "%s/%s", YP_DB_PATH, domain);
	if (stat(map_path, &finfo) < 0 ||
		(finfo.st_mode & S_IFMT) != S_IFDIR) {
d294 2
a295 1
		yplog("  ypdb_open_db: no domain %s (map=%s)", domain, map);
d297 9
a305 8
		*status = YP_NODOM;
		return(NULL);
	}
	snprintf(map_path, sizeof(map_path), "%s/%s/%s%s", YP_DB_PATH,
		domain, map, YPDB_SUFFIX);
	if (stat(map_path, &finfo) < 0) {
#ifdef DEBUG
		yplog("  ypdb_open_db: no map %s (domain=%s)", map, domain);
a306 10
		*status = YP_NOMAP;
		return(NULL);
	}

	/*
	 * open map
	 */
	snprintf(map_path, sizeof(map_path), "%s/%s/%s", YP_DB_PATH, 
		domain, map);
	db = ypdb_open(map_path, O_RDONLY, 0444);
d309 7
@


1.11
log
@careful about bad domain/mapnames
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.10 1997/03/11 09:12:25 maja Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.10 1997/03/11 09:12:25 maja Exp $";
d655 1
a655 1
	    res.ordernum = (u_int) atol(order);
@


1.10
log
@Now with support for "secure" maps a'la FreeBSD. Support exists in makedbm
and ypxfrd since dawn of time. Support is missing in YP-makefile and in
libc. I have the changes for YP-makefile to support master.passwd but since
the support is missing in libc I will not commit them yet. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.9 1996/12/02 21:14:16 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.9 1996/12/02 21:14:16 deraadt Exp $";
d276 9
@


1.9
log
@bail nice
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.8 1996/11/11 17:22:15 niklas Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.8 1996/11/11 17:22:15 niklas Exp $";
d78 1
d230 1
d364 5
d372 2
a373 2
	     yplog("  ypdb_open_db: NEW MAP domain=%s, map=%s, hl=%d, db=0x%x", 
			domain, map, m->host_lookup, m->db);
d760 24
@


1.8
log
@plug db descriptor leak
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.7 1996/09/29 08:11:04 dm Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.7 1996/09/29 08:11:04 dm Exp $";
d120 5
a124 1
  	if (ypprivate) return (FALSE);
d127 1
a127 1
			strncmp(key.dptr,YP_LAST_KEY,YP_LAST_LEN) == 0)
d130 1
a130 1
			strncmp(key.dptr,YP_INPUT_KEY,YP_INPUT_LEN) == 0)
d133 1
a133 1
			strncmp(key.dptr,YP_OUTPUT_KEY,YP_OUTPUT_LEN) == 0)
d136 1
a136 1
			strncmp(key.dptr,YP_MASTER_KEY,YP_MASTER_LEN) == 0)
d139 1
a139 1
			strncmp(key.dptr,YP_DOMAIN_KEY,YP_DOMAIN_LEN) == 0)
d142 1
a142 1
		strncmp(key.dptr,YP_INTERDOMAIN_KEY,YP_INTERDOMAIN_LEN) == 0)
d145 1
a145 1
			strncmp(key.dptr,YP_SECURE_KEY,YP_SECURE_LEN) == 0)
@


1.7
log
@Fix hostname lookups (improper use of strncpy).
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.6 1996/06/27 20:25:54 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.6 1996/06/27 20:25:54 deraadt Exp $";
d492 1
a492 1
			return(res);
@


1.6
log
@for DNS hosts.byname queries, supply all addresses
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.5 1996/06/26 21:26:39 maja Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.5 1996/06/26 21:26:39 maja Exp $";
d495 1
@


1.5
log
@Same copyright all over, removed my name from ypdb.[ch], small bugfix
in ypserv_db.c /moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_db.c,v 1.4 1996/05/30 09:53:29 deraadt Exp $ */
d37 1
a37 1
static char rcsid[] = "$OpenBSD: ypserv_db.c,v 1.4 1996/05/30 09:53:29 deraadt Exp $";
d384 1
d400 6
a405 7
		snprintf(val,sizeof(val), "%s %s",
			inet_ntoa(*addr_name), keystr);
		l = strlen(val);
		v = val + l;
		while ((ptr = *(host->h_aliases)) != NULL) {
			l = strlen(ptr);
			if ((v - val) + l + 1 > BUFSIZ)
d407 2
a408 5
			strcpy(v, " ");
			v += 1;
			strcpy(v, ptr);
			v += l;
			host->h_aliases++;
@


1.4
log
@$OpenBSD$ tag and few spelling errors
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d16 6
a21 3
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
d37 1
a37 1
static char rcsid[] = "$OpenBSD$";
d64 1
d383 1
d421 19
@


1.3
log
@force gethostby{name,addr} to use bind (really ugly & trivial hack)
@
text
@d1 2
d34 1
a34 1
static char rcsid[] = "$Id: ypserv_db.c,v 1.2 1996/01/20 00:47:01 chuck Exp $";
@


1.2
log
@major cleanup by Chuck Cranor
 - use queue.h rather than do by hand
 - fix up logging to use new yplog
 - fix a few off by one errors
 - don't double malloc the DBM structure
 - avoid possible sprintf buffer overflows
 - random code cleanup
@
text
@d32 1
a32 1
static char rcsid[] = "$Id: ypserv_db.c,v 1.1 1995/11/01 16:56:37 deraadt Exp $";
d52 2
d109 2
a110 2
        datum	key;
        int	ypprivate;
d112 1
a112 1
        int	result;
d213 1
a213 1
        mapname		map;
d215 1
a215 1
        struct opt_map	**map_info;
d368 1
a368 1
        int	host_lookup;
d383 4
d436 3
a438 3
        mapname		map;
        keydat		key;
        int		ypprivate;
d488 2
a489 2
        mapname map;
        int ypprivate;
d530 3
a532 3
        mapname map;
        keydat key;
        int ypprivate;
d588 1
a588 1
        mapname map;
d623 1
a623 1
        mapname map;
d658 1
a658 1
        ypreq_nokey *req;
d677 1
a677 1
        };
d699 1
a699 1
#endif				        
d717 1
a717 1
#endif				        
@


1.1
log
@+ full set of ypserv tools that compile
@
text
@d2 2
a3 1
 * copyright (c) 1994 Mats O Jansson <moj@@stacken.kth.se>
d32 1
a32 1
static char rcsid[] = "$Id: ypserv_db.c,v 1.10 1995/01/29 21:13:57 moj Exp $";
d35 7
d46 1
d54 1
d61 4
d66 6
a71 8
	mapname	map;
	DBM	*db;
	int	*dptr;
	struct	opt_map *next;
	struct	opt_map *prev;
	struct	opt_map *rnext;
	struct	opt_map *rprev;
	int	host_lookup;
a72 1
typedef struct opt_map opt_map;
d75 3
a77 3
	domainname	domain;
	opt_map		*map_root;
	struct		opt_domain *next;
a78 1
typedef struct opt_domain opt_domain;
d80 3
a82 3
	opt_domain	*domain_root = NULL;
	opt_map		*map_first = NULL;
	opt_map		*map_last  = NULL;
d87 14
d112 1
a112 3
  	if (ypprivate) {
		return (FALSE);
	}
d114 21
a134 17
        result = FALSE;

	if ((!result) && (key.dsize == YP_LAST_LEN)) {
		result = (strcmp(key.dptr,YP_LAST_KEY) == 0);
	}
	
	if ((!result) && (key.dsize == YP_INPUT_LEN)) {
		result = (strcmp(key.dptr,YP_INPUT_KEY) == 0);
	}
	
	if ((!result) && (key.dsize == YP_OUTPUT_LEN)) {
		result = (strcmp(key.dptr,YP_OUTPUT_KEY) == 0);
	}
	
	if ((!result) && (key.dsize == YP_MASTER_LEN)) {
		result = (strcmp(key.dptr,YP_MASTER_KEY) == 0);
	}
d136 1
a136 13
	if ((!result) && (key.dsize == YP_DOMAIN_LEN)) {
		result = (strcmp(key.dptr,YP_DOMAIN_KEY) == 0);
	}
	
	if ((!result) && (key.dsize == YP_INTERDOMAIN_LEN)) {
		result = (strcmp(key.dptr,YP_INTERDOMAIN_KEY) == 0);
	}
	
	if ((!result) && (key.dsize == YP_SECURE_LEN)) {
		result = (strcmp(key.dptr,YP_SECURE_KEY) == 0);
	}
	
	return(result);
d147 6
a152 2
	opt_map		*m = NULL;
	opt_domain	*d = NULL;
d154 2
a155 6
	m = map_last;
	d = (opt_domain *) m->dptr;
	
	/* Close database */
	ypdb_close(m->db);
	free(m->db);
d158 2
a159 5
	yplog_cat("info: ypdb_close_last: close map ");
	yplog_cat(m->map);
	yplog_cat(" in domain ");
	yplog_cat(d->domain);
	yplog_cat("\n");
d162 3
a164 8
	/* Deallocate space for map name */
	free(m->map);
	
	/* Unlink record from recent used list */
	if (m->rprev != NULL) {
		m->rprev->rnext = m->rnext;
	}
	map_last = m->rprev;
a165 11
	/* Unlink record from domain list */
	if (m->prev == NULL) {
		d->map_root = m->next;
	} else {
		m->prev->next = m->next;
	}
	if (m->next != NULL) {
		m->next->prev = m->prev;
	}
	  
	free(m);
d177 4
a180 1
	while (map_last != NULL) {
d183 3
d196 3
d204 4
d209 1
a209 1
ypdb_open_db_std(domain, map, status, map_info)
d213 1
a213 1
        opt_map		*map_info;
d215 2
a216 1
	static	char map_path[255];
d219 4
d224 3
a226 1
	*status = YP_TRUE;			/* Preset return value */
d228 14
a241 7
	db = NULL;				/* Database isn't opened */
	
	/* Check domain */
	sprintf(map_path,"%s/%s",YP_DB_PATH,domain);
	if (!((stat(map_path, &finfo) == 0) &&
	      ((finfo.st_mode & S_IFMT) == S_IFDIR))) {
		*status = YP_NODOM;
d243 2
a244 1
		yplog_cat("err: ypdb_open_db_std: domain not found\n");
d246 4
d251 19
a269 6
		
	if (*status >= 0) {
		/* Check map */
		sprintf(map_path,"%s/%s/%s%s",YP_DB_PATH,domain,map,YPDB_SUFFIX);
		if (!(stat(map_path, &finfo) == 0)) {
			*status = YP_NOMAP;
d271 1
a271 1
			yplog_cat("err: ypdb_open_db: map not found\n");
d273 2
a274 1
		}
d276 3
a278 5
		
	/* Ok, if no error yet, open database */
	if (*status >= 0) {
		sprintf(map_path,"%s/%s/%s",YP_DB_PATH,domain,map);
		db = ypdb_open(map_path, O_RDONLY, 0444);
d280 1
a280 3
		yplog_cat("info: ypdb_open_db: open ");
		yplog_cat(map_path);
		yplog_cat("\n");
d282 2
d286 14
a299 18
	return(db);
}

DBM *
ypdb_open_db(domain, map, status, map_info)
	domainname	domain;
        mapname		map;
	ypstat		*status;
        opt_map		*map_info;
{
	static	char map_path[255];
	struct	stat finfo;
	DBM	*db;
	static char   domain_key[YP_INTERDOMAIN_LEN] = YP_INTERDOMAIN_KEY;
	FILE	*fd;
	opt_domain *d = NULL;
	opt_map	*m = NULL;
	datum	k,v;
d301 3
a303 1
	*status = YP_TRUE;			/* Preset return value */
d305 15
a319 1
	db = NULL;				/* Database isn't opened */
d321 3
a323 4
	d = domain_root;			/* Find domain in list */
	while ((d != NULL) && (strcmp(d->domain,domain) != 0)) {
		d = d->next;
	}
d325 3
a327 5
	if (d != NULL) {			/* Domain found ! */
		m = d->map_root;		/* Find map in list */
		while ((m != NULL) && (strcmp(m->map,map) != 0)) {
			m = m->next;
		}
d329 5
a333 16

	if (m != NULL) {			/* Map found ! */
		db = m->db;
		if (m != map_first) {
			/* Move map to top of recent used list */
			m->rprev->rnext = m->rnext;
			if (m->rnext == NULL) {
				map_last = m->rprev;
			} else {
				m->rnext->rprev = m->rprev;
			}
			m->rprev = NULL;
			map_first->rprev = m;
			m->rnext = map_first;
			map_first = m;
		}
d335 11
a345 10

	if (db == NULL) {			/* Database not opened */

		/* Make a dummy open, if it succeeds then it's OK */
		/* to open a new database, else we must close one */
	  	/* first. Close least recent used database        */
	  
		fd = fopen("/dev/null","r");
		if (fd != NULL) {
			fclose(fd);		/* All is OK */
d347 1
a347 1
			ypdb_close_last();	/* Not OK, close one */
d349 3
a351 6

		/* Check domain */
		sprintf(map_path,"%s/%s",YP_DB_PATH,domain);
		if (!((stat(map_path, &finfo) == 0) &&
		      ((finfo.st_mode & S_IFMT) == S_IFDIR))) {
			*status = YP_NODOM;
d353 2
a354 1
			yplog_cat("err: ypdb_open_db: domain not found\n");
d356 2
a357 23
		}
		
		if (*status >= 0) {
			/* Check map */
			sprintf(map_path,"%s/%s/%s%s",YP_DB_PATH,domain,map,YPDB_SUFFIX);
			if (!(stat(map_path, &finfo) == 0)) {
				*status = YP_NOMAP;
#ifdef DEBUG
				yplog_cat("err: ypdb_open_db: map not found\n");
#endif
			}
		}
		
		/* Ok, if no error yet, open database */
		if (*status >= 0) {
			sprintf(map_path,"%s/%s/%s",YP_DB_PATH,domain,map);
			db = ypdb_open(map_path, O_RDONLY, 0444);
#ifdef DEBUG
			yplog_cat("info: ypdb_open_db: open ");
			yplog_cat(map_path);
			yplog_cat("\n");
#endif
		}
d359 3
a361 82
		if (*status >= 0) {
		        
			if (d == NULL) {		/* Domain is new */
			        /* Allocate a domain record */
				d = (opt_domain *)
				    malloc((unsigned) sizeof(opt_domain));

				/* Setup domain record */
				d->domain   = (domainname)
				              malloc(strlen(domain)+1);
				(void)strcpy(d->domain,domain);
				d->map_root = NULL;
				d->next     = domain_root;
				domain_root = d;
			}
			
			if (m == NULL) {		/* Map is new */
			        /* Allocatr a map record */
				m = (opt_map *)
				    malloc((unsigned) sizeof(opt_map));
				
				/* Setup map record */
				m->map      = (mapname)
				              malloc(strlen(map)+1);
				(void)strcpy(m->map,map);
				m->db	  = malloc((unsigned) sizeof(DBM));
				memcpy(m->db,db,sizeof(DBM));
				m->next     = d->map_root;
				if (m->next != NULL) {
					m->next->prev = m;
				}
				m->prev     = NULL;
				m->dptr	  = (int *) d;
				d->map_root = m;
				m->rnext    = map_first;
				m->rprev    = NULL;
				if (map_first != NULL) {
					map_first->rprev = m;
				}
				if (map_last == NULL) {
					map_last = m;
				}
				m->host_lookup = FALSE;
				/* Check if hosts. */
				if ((strcmp(map, YP_HOSTNAME) == 0) ||
				    (strcmp(map, YP_HOSTADDR) == 0)) {
					if (!usedns) {
						k.dptr = (char *) &domain_key;
						k.dsize = YP_INTERDOMAIN_LEN;
						v = ypdb_fetch(db,k);
						if (v.dptr != NULL) {
							m->host_lookup = TRUE;
#ifdef DEBUG
			yplog_cat("info: ypdb_open_db: YP_INTERDOMAIN\n");
#endif
						}
					} else {
						m->host_lookup = usedns;
#ifdef DEBUG
			yplog_cat("info: ypdb_open_db: ypserv -d\n");
#endif
					}
				}
				map_first = m;
			}

			if (map_info != NULL) {
				map_info->map	      = NULL;
				map_info->db	      = NULL;
				map_info->dptr	      = m->dptr;
				map_info->next	      = m->next;
				map_info->prev	      = m->prev;
				map_info->rnext	      = m->rnext;
				map_info->rprev	      = m->rprev;
				map_info->host_lookup = m->host_lookup;
			}
		}
		
	}

	return(db);
}
d374 3
a376 2
	static  char val[255];
	ypstat	status;
d379 1
a379 1
	status = YP_NOKEY;
d381 39
a419 34
	if (host_lookup) {
		if (nametable) {
			host = gethostbyname(keystr);
			if ((host != NULL) &&
			    (host->h_addrtype == AF_INET)) {
				addr_name = (struct in_addr *)
				  *host->h_addr_list;
				sprintf(val,"%s %s",
					inet_ntoa(*addr_name), keystr);
				while ((ptr = *(host->h_aliases)) != NULL) {
					strcat(val," ");
					strcat(val,ptr);
					host->h_aliases++;
				}
				result->val.valdat_val = val;
				result->val.valdat_len = strlen(val);
				status = YP_TRUE;
			}
		} else {
			inet_aton(keystr, &addr_addr);
			host = gethostbyaddr((char *) &addr_addr,
					     sizeof(addr_addr), AF_INET);
			if (host != NULL) {
				sprintf(val,"%s %s",keystr,host->h_name);
				while ((ptr = *(host->h_aliases)) != NULL) {
					strcat(val," ");
					strcat(val,ptr);
					host->h_aliases++;
				}
				result->val.valdat_val = val;
				result->val.valdat_len = strlen(val);
				status = YP_TRUE;
			}
		}
d421 4
a424 2
	
	return(status);
d435 1
a435 1
	static	char keystr[255];
d438 2
a439 3
	ypstat	status;
	int	host_lookup;
	opt_map	map_info;
d443 28
a470 36
	db = ypdb_open_db(domain, map, &status, &map_info);
	host_lookup = map_info.host_lookup;
	
	if (status >= 0) {
		
		(void) strncpy(keystr, key.keydat_val, key.keydat_len);
		keystr[key.keydat_len] = '\0';
		
		k.dptr = (char *) &keystr;
		k.dsize = key.keydat_len + 1;
		
		if (yp_private(k,ypprivate)) {
			status = YP_NOKEY;
		} else {
			
			v = ypdb_fetch(db,k);
			if (v.dptr == NULL) {
			  
				status = YP_NOKEY;
				
				if (strcmp(map, YP_HOSTNAME) == 0) {
					status = lookup_host(TRUE, host_lookup,
							     db, &keystr,&res);
				}

				if (strcmp(map, YP_HOSTADDR) == 0) {
					status = lookup_host(FALSE,host_lookup,
							     db, &keystr,&res);
				}

			} else {
				res.val.valdat_val = v.dptr;
				res.val.valdat_len = v.dsize - 1;
			}
			
		}
d472 2
a473 1
	
d475 1
a476 3
	res.stat = status;
	
	return (res);
a487 1
	ypstat	status;
d491 1
a491 1
	db = ypdb_open_db(domain, map, &status, NULL);
d493 1
a493 1
	if (status >= 0) {
d502 1
a502 1
	    status = YP_NOKEY;
d508 1
a508 1
	      status = YP_NOKEY;
d511 1
a511 1
	      res.val.valdat_len = v.dsize - 1;
a517 2
	res.stat = status;

a530 1
	ypstat	status;
d534 1
a534 1
	db = ypdb_open_db(domain, map, &status, NULL);
d536 1
a536 1
	if (status >= 0) {
d560 1
a560 1
	    status = YP_NOMORE;
d566 1
a566 1
	      status = YP_NOMORE;
d569 1
a569 1
	      res.val.valdat_len = v.dsize - 1;
a575 2
	res.stat = status;

d585 2
a586 2
	static char   order_key[YP_LAST_LEN] = YP_LAST_KEY;
	static char   order[MAX_LAST_LEN+1];
a588 1
	ypstat	status;
d592 1
a592 1
	db = ypdb_open_db(domain, map, &status, NULL);
d594 1
a594 1
	if (status >= 0) {
d596 1
a596 1
	  k.dptr = (char *) &order_key;
d601 1
a601 1
	    status = YP_NOKEY;
a610 2
	res.stat = status;

d620 1
a620 1
	static char   master_key[YP_MASTER_LEN] = YP_MASTER_KEY;
a623 1
	ypstat	status;
d627 1
a627 1
	db = ypdb_open_db(domain, map, &status, NULL);
d629 1
a629 1
	if (status >= 0) {
d631 1
a631 2
	  k.dptr = (char *) &master_key;
	  master_key[YP_MASTER_LEN] = '\0';
d636 1
a636 1
	    status = YP_NOKEY;
a645 2
	res.stat = status;

a654 1
	static bool_t more = TRUE;
a656 2
	ypstat	status;
	extern	int	acl_access_ok;
d660 8
a667 21
	if(acl_access_ok) {
		db = ypdb_open_db_std(req->domain, req->map, &status);
	} else {
		db = NULL;
		resp.ypresp_all_u.val.stat = YP_NODOM;
	}

	if (resp.ypresp_all_u.val.stat < 0) {
		resp.more = FALSE;
		
		if (!xdr_ypresp_all(xdrs, &resp)) {
#ifdef DEBUG
			yplog_cat("xdr_ypresp_all: 1 failed\n");
#endif				        
			return(FALSE);
		}

		return(TRUE);
	        
	}

a668 1
	
d673 1
a673 1
	while(resp.ypresp_all_u.val.stat >= 0) {
d675 2
a676 5
		if (k.dptr == NULL) {
			v.dptr = NULL;
		} else {
			v = ypdb_fetch(db,k);
	        }
d678 1
a678 1
		if (v.dptr == NULL) {
d680 9
a688 1
			resp.ypresp_all_u.val.stat = YP_NOKEY;
d690 1
a690 17
		} else {
		  
#ifdef DEBUG
			yplog_cat("key: ");
			yplog_cat(k.dptr);
			yplog_cat(" val: ");
			yplog_cat(v.dptr);
			yplog_cat("\n");
#endif
			resp.more = more;
			resp.ypresp_all_u.val.stat = YP_TRUE;
			resp.ypresp_all_u.val.key.keydat_val = k.dptr;
			resp.ypresp_all_u.val.key.keydat_len = k.dsize - 1;
			resp.ypresp_all_u.val.val.valdat_val = v.dptr;
			resp.ypresp_all_u.val.val.valdat_len = v.dsize - 1;
			
			if (!xdr_ypresp_all(xdrs, &resp)) {
d692 1
a692 1
				yplog_cat("xdr_ypresp_all: 2 failed\n");
d694 2
a695 2
				return(FALSE);
			}
d697 3
d701 2
a702 7
			while (yp_private(k,FALSE)) {
				k = ypdb_nextkey(db);
			};

		};
	  
	};
d705 1
a705 1
	
a706 1
	resp.ypresp_all_u.val.stat = status;
d710 1
a710 1
		yplog_cat("xdr_ypresp_all: 3 failed\n");
d715 1
a715 1
	ypdb_close(db);
a718 1

@
