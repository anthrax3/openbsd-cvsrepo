head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.6
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.44.0.4
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.37.0.16
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.14
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.12
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.10
	OPENBSD_5_0:1.37.0.8
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.6
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.35.0.14
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.10
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.8
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.6
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.4
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.32.0.8
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.32.0.6
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.4
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.15.0.4
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.10
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.8
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.6
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.44
date	2015.11.17.18.21.48;	author tedu;	state Exp;
branches;
next	1.43;
commitid	TerFthOUPTsWcC6K;

1.43
date	2015.11.12.22.33.07;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	yL2gco0cO8wLO0qe;

1.42
date	2015.10.26.10.12.46;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	fit45WT7q8GoIZrc;

1.41
date	2015.01.15.00.40.26;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	LaWKoEgLb4qRsxH0;

1.40
date	2014.10.11.02.29.24;	author doug;	state Exp;
branches;
next	1.39;
commitid	Lpo23uFzJzAyYsog;

1.39
date	2013.12.05.14.22.42;	author jca;	state Exp;
branches;
next	1.38;

1.38
date	2013.11.12.22.27.13;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.20.23.20.28;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.27.23.59.58;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.02.18.23.34.57;	author jmc;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.03.05.01.24;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.16.23.55.04;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.23.03.48.43;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.22.23.57.07;	author maja;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.12.21.09.48;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.02.21.58.27;	author maja;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.05.08.37.05;	author avsm;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.13.05.54.39;	author maja;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.06.19.13.10;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.19.20.59.40;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.26.09.32.44;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.19.19.39.41;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.18.22.20.55;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.16.21.28.11;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.05.10.02.16;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.01.23.27.24;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.19.09.03.06;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.11.23.37.01;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.18.03.21.36;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.28.23.58.48;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.11.04.07.40.52;	author deraadt;	state Exp;
branches
	1.12.10.1;
next	1.11;

1.11
date	97.08.05.05.09.33;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.08.04.19.26.25;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.04.12.00.14.28;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.03.30.20.51.20;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	97.01.15.23.44.34;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.10.02.23.44.56;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.30.19.46.08;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.21.26.38;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.05.30.09.53.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.20.00.43.43;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	95.11.01.16.56.36;	author deraadt;	state Exp;
branches;
next	;

1.12.10.1
date	2000.10.07.03.53.24;	author jason;	state Exp;
branches;
next	;


desc
@@


1.44
log
@include fix. dbm is ndbm and memory is string. ok deraadt.
@
text
@/*	$OpenBSD: ypserv.c,v 1.43 2015/11/12 22:33:07 deraadt Exp $ */

/*
 * Copyright (c) 1994 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <rpcsvc/yp.h>
#include "ypv1.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netdb.h>
#include <signal.h>
#include <errno.h>
#include <util.h>
#include <unistd.h>
#include <fcntl.h>
#include <rpc/pmap_clnt.h>
#include <ndbm.h>
#include <syslog.h>
#include "acl.h"
#include "yplog.h"
#include "ypdef.h"
#include "ypserv.h"
#include <sys/wait.h>

void ypdb_init(void);

#ifdef DEBUG
#define RPC_SVC_FG
#endif

#define _RPCSVC_CLOSEDOWN 120
static int _rpcpmstart;		/* Started by a port monitor ? */
static int _rpcfdtype;		/* Whether Stream or Datagram ? */
static int _rpcsvcdirty;	/* Still serving ? */

int	usedns = FALSE;
char   *aclfile = NULL;

void	sig_child(int);
void	sig_hup(int);
volatile sig_atomic_t wantsighup;

static void
_msgout(char *msg)
{
#ifdef RPC_SVC_FG
	if (_rpcpmstart)
		syslog(LOG_ERR, "%s", msg);
	else
		(void) fprintf(stderr, "%s\n", msg);
#else
	syslog(LOG_ERR, "%s", msg);
#endif
}

/* ARGSUSED */
static void
closedown(int sig)
{
	int save_errno = errno;

	if (_rpcsvcdirty == 0) {
		int i, openfd;

		if (_rpcfdtype == SOCK_DGRAM)
			exit(0);
		for (i = 0, openfd = 0; i < svc_max_pollfd && openfd < 2; i++)
			if (svc_pollfd[i].fd != -1)
				openfd++;
		if (openfd <= (_rpcpmstart ? 0 : 1))
			_exit(0);
	}
	(void) alarm(_RPCSVC_CLOSEDOWN);
	errno = save_errno;
}

static void
ypprog_1(struct svc_req *rqstp, SVCXPRT *transp)
{
	union {
		domainname ypoldproc_domain_1_arg;
		domainname ypoldproc_domain_nonack_1_arg;
		yprequest ypoldproc_match_1_arg;
		yprequest ypoldproc_first_1_arg;
		yprequest ypoldproc_next_1_arg;
		yprequest ypoldproc_poll_1_arg;
		yprequest ypoldproc_push_1_arg;
		yprequest ypoldproc_pull_1_arg;
		yprequest ypoldproc_get_1_arg;
	} argument;
	char *result;
	xdrproc_t xdr_argument, xdr_result;
	char *(*local)(char *, struct svc_req *);

	_rpcsvcdirty = 1;
	switch (rqstp->rq_proc) {
	case YPOLDPROC_NULL:
		xdr_argument = (xdrproc_t) xdr_void;
		xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) ypoldproc_null_1_svc;
		break;

	case YPOLDPROC_DOMAIN:
		xdr_argument = (xdrproc_t) xdr_domainname;
		xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) ypoldproc_domain_1_svc;
		break;

	case YPOLDPROC_DOMAIN_NONACK:
		xdr_argument = (xdrproc_t) xdr_domainname;
		xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) ypoldproc_domain_nonack_1_svc;
		break;

	case YPOLDPROC_MATCH:
		xdr_argument = (xdrproc_t) xdr_yprequest;
		xdr_result = (xdrproc_t) xdr_ypresponse;
		local = (char *(*)(char *, struct svc_req *)) ypoldproc_match_1_svc;
		break;

	case YPOLDPROC_FIRST:
		xdr_argument = (xdrproc_t) xdr_yprequest;
		xdr_result = (xdrproc_t) xdr_ypresponse;
		local = (char *(*)(char *, struct svc_req *)) ypoldproc_first_1_svc;
		break;

	case YPOLDPROC_NEXT:
		xdr_argument = (xdrproc_t) xdr_yprequest;
		xdr_result = (xdrproc_t) xdr_ypresponse;
		local = (char *(*)(char *, struct svc_req *)) ypoldproc_next_1_svc;
		break;

	case YPOLDPROC_POLL:
		xdr_argument = (xdrproc_t) xdr_yprequest;
		xdr_result = (xdrproc_t) xdr_ypresponse;
		local = (char *(*)(char *, struct svc_req *)) ypoldproc_poll_1_svc;
		break;

	case YPOLDPROC_PUSH:
		xdr_argument = (xdrproc_t) xdr_yprequest;
		xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) ypoldproc_push_1_svc;
		break;

	case YPOLDPROC_PULL:
		xdr_argument = (xdrproc_t) xdr_yprequest;
		xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) ypoldproc_pull_1_svc;
		break;

	case YPOLDPROC_GET:
		xdr_argument = (xdrproc_t) xdr_yprequest;
		xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) ypoldproc_get_1_svc;
		break;

	default:
		svcerr_noproc(transp);
		_rpcsvcdirty = 0;
		return;
	}
	(void) memset(&argument, 0, sizeof(argument));
	if (!svc_getargs(transp, xdr_argument, (caddr_t)&argument)) {
		svcerr_decode(transp);
		_rpcsvcdirty = 0;
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, xdr_argument, (caddr_t)&argument)) {
		_msgout("unable to free arguments");
		exit(1);
	}
	_rpcsvcdirty = 0;
}

static void
ypprog_2(struct svc_req *rqstp, SVCXPRT *transp)
{
	union {
		domainname ypproc_domain_2_arg;
		domainname ypproc_domain_nonack_2_arg;
		ypreq_key ypproc_match_2_arg;
		ypreq_nokey ypproc_first_2_arg;
		ypreq_key ypproc_next_2_arg;
		ypreq_xfr ypproc_xfr_2_arg;
		ypreq_nokey ypproc_all_2_arg;
		ypreq_nokey ypproc_master_2_arg;
		ypreq_nokey ypproc_order_2_arg;
		domainname ypproc_maplist_2_arg;
	} argument;
	char *result;
	xdrproc_t xdr_argument, xdr_result;
	char *(*local)(char *, struct svc_req *);

	_rpcsvcdirty = 1;
	switch (rqstp->rq_proc) {
	case YPPROC_NULL:
		xdr_argument = (xdrproc_t) xdr_void;
		xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) ypproc_null_2_svc;
		break;

	case YPPROC_DOMAIN:
		xdr_argument = (xdrproc_t) xdr_domainname;
		xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) ypproc_domain_2_svc;
		break;

	case YPPROC_DOMAIN_NONACK:
		xdr_argument = (xdrproc_t) xdr_domainname;
		xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) ypproc_domain_nonack_2_svc;
		break;

	case YPPROC_MATCH:
		xdr_argument = (xdrproc_t) xdr_ypreq_key;
		xdr_result = (xdrproc_t) xdr_ypresp_val;
		local = (char *(*)(char *, struct svc_req *)) ypproc_match_2_svc;
		break;

	case YPPROC_FIRST:
		xdr_argument = (xdrproc_t) xdr_ypreq_nokey;
		xdr_result = (xdrproc_t) xdr_ypresp_key_val;
		local = (char *(*)(char *, struct svc_req *)) ypproc_first_2_svc;
		break;

	case YPPROC_NEXT:
		xdr_argument = (xdrproc_t) xdr_ypreq_key;
		xdr_result = (xdrproc_t) xdr_ypresp_key_val;
		local = (char *(*)(char *, struct svc_req *)) ypproc_next_2_svc;
		break;

	case YPPROC_XFR:
		xdr_argument = (xdrproc_t) xdr_ypreq_xfr;
		xdr_result = (xdrproc_t) xdr_ypresp_xfr;
		local = (char *(*)(char *, struct svc_req *)) ypproc_xfr_2_svc;
		break;

	case YPPROC_CLEAR:
		xdr_argument = (xdrproc_t) xdr_void;
		xdr_result = (xdrproc_t) xdr_void;
		local = (char *(*)(char *, struct svc_req *)) ypproc_clear_2_svc;
		break;

	case YPPROC_ALL:
		xdr_argument = (xdrproc_t) xdr_ypreq_nokey;
		xdr_result = (xdrproc_t) xdr_ypresp_all;
		local = (char *(*)(char *, struct svc_req *)) ypproc_all_2_svc;
		break;

	case YPPROC_MASTER:
		xdr_argument = (xdrproc_t) xdr_ypreq_nokey;
		xdr_result = (xdrproc_t) xdr_ypresp_master;
		local = (char *(*)(char *, struct svc_req *)) ypproc_master_2_svc;
		break;

	case YPPROC_ORDER:
		xdr_argument = (xdrproc_t) xdr_ypreq_nokey;
		xdr_result = (xdrproc_t) xdr_ypresp_order;
		local = (char *(*)(char *, struct svc_req *)) ypproc_order_2_svc;
		break;

	case YPPROC_MAPLIST:
		xdr_argument = (xdrproc_t) xdr_domainname;
		xdr_result = (xdrproc_t) xdr_ypresp_maplist;
		local = (char *(*)(char *, struct svc_req *)) ypproc_maplist_2_svc;
		break;

	default:
		svcerr_noproc(transp);
		_rpcsvcdirty = 0;
		return;
	}
	(void) memset(&argument, 0, sizeof(argument));
	if (!svc_getargs(transp, xdr_argument, (caddr_t)&argument)) {
		svcerr_decode(transp);
		_rpcsvcdirty = 0;
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, xdr_argument, (caddr_t)&argument)) {
		_msgout("unable to free arguments");
		exit(1);
	}
	_rpcsvcdirty = 0;
}

static void
hup(void)
{
	/* Handle the log. */
	ypcloselog();
	ypopenlog();

	acl_reset();
	if (aclfile != NULL) {
		yplog("sig_hup: reread %s", aclfile);
		(void)acl_init(aclfile);
	} else {
		yplog("sig_hup: reread %s", YP_SECURENET_FILE);
		(void)acl_securenet(YP_SECURENET_FILE);
	}

	ypdb_close_all();
}

static void
my_svc_run(void)
{
	struct pollfd *pfd = NULL, *newp;
	int nready, saved_max_pollfd = 0;

	for (;;) {
		if (wantsighup) {
			wantsighup = 0;
			hup();
		}
		if (svc_max_pollfd > saved_max_pollfd) {
			newp = reallocarray(pfd, svc_max_pollfd, sizeof(*pfd));
			if (newp == NULL) {
				free(pfd);
				perror("svc_run: - realloc failed");
				return;
			}
			pfd = newp;
			saved_max_pollfd = svc_max_pollfd;
		}
		memcpy(pfd, svc_pollfd, sizeof(*pfd) * svc_max_pollfd);

		nready = poll(pfd, svc_max_pollfd, INFTIM);
		switch (nready) {
		case -1:
			if (errno == EINTR)
				continue;
			perror("svc_run: - poll failed");
			free(pfd);
			return;
		case 0:
			continue;
		default:
			svc_getreq_poll(pfd, nready);
		}
	}
}

static void
usage(void)
{
	(void)fprintf(stderr, "usage: ypserv [-1dx] [-a aclfile]\n");
	exit(1);
}

int
main(int argc, char *argv[])
{
	int xflag = 0, allowv1 = 0, ch, sock, proto;
	struct sockaddr_in saddr;
	socklen_t asize = sizeof(saddr);
	extern char *optarg;
	SVCXPRT *transp = NULL;

	while ((ch = getopt(argc, argv, "1a:dx")) != -1)
		switch (ch) {
		case '1':
			allowv1 = TRUE;
			break;
		case 'a':
			aclfile = optarg;
			break;
		case 'd':
			usedns = TRUE;
			break;
		case 'x':
			xflag = TRUE;
			break;
		default:
			usage();
			break;
		}

	if (geteuid() != 0) {
		(void)fprintf(stderr, "ypserv: must be root to run.\n");
		exit(1);
	}

	if (aclfile != NULL)
		(void)acl_init(aclfile);
	else
		(void)acl_securenet(YP_SECURENET_FILE);

	if (xflag)
		exit(1);

	if (getsockname(0, (struct sockaddr *)&saddr, &asize) == 0) {
		socklen_t ssize = sizeof(int);

		if (saddr.sin_family != AF_INET)
			exit(1);
		if (getsockopt(0, SOL_SOCKET, SO_TYPE,
		    &_rpcfdtype, &ssize) == -1)
			exit(1);
		sock = 0;
		_rpcpmstart = 1;
		proto = 0;
		openlog("ypserv", LOG_PID, LOG_DAEMON);
	} else {
#ifndef RPC_SVC_FG
		int i;
		pid_t pid;

		pid = fork();
		if (pid < 0) {
			perror("cannot fork");
			exit(1);
		}
		if (pid)
			exit(0);
		closefrom(0);
		i = open("/dev/console", O_RDWR);
		(void) dup2(i, 1);
		(void) dup2(i, 2);
		i = open("/dev/tty", O_RDWR);
		if (i >= 0) {
			(void) ioctl(i, TIOCNOTTY, NULL);
			(void) close(i);
		}
		openlog("ypserv", LOG_PID, LOG_DAEMON);
#endif
		sock = RPC_ANYSOCK;
		(void) pmap_unset(YPPROG, YPVERS);
		(void) pmap_unset(YPPROG, YPOLDVERS);
	}

	ypopenlog();	/* open log file */
	ypdb_init();	/* init db stuff */

	chdir("/");

	(void)signal(SIGCHLD, sig_child);
	(void)signal(SIGHUP, sig_hup);

	if (_rpcfdtype == 0 || _rpcfdtype == SOCK_DGRAM) {
		transp = svcudp_create(sock);
		if (transp == NULL) {
			_msgout("cannot create udp service.");
			exit(1);
		}
		if (transp->xp_port >= IPPORT_RESERVED) {
			_msgout("cannot allocate udp privileged port.");
			exit(1);
		}
		if (!_rpcpmstart)
			proto = IPPROTO_UDP;
		if (allowv1) {
			if (!svc_register(transp, YPPROG, YPOLDVERS, ypprog_1, proto)) {
				_msgout("unable to register (YPPROG, YPOLDVERS, udp).");
				exit(1);
			}
		}
		if (!svc_register(transp, YPPROG, YPVERS, ypprog_2, proto)) {
			_msgout("unable to register (YPPROG, YPVERS, udp).");
			exit(1);
		}
	}

	if (_rpcfdtype == 0 || _rpcfdtype == SOCK_STREAM) {
		if (_rpcpmstart)
			transp = svcfd_create(sock, 0, 0);
		else
			transp = svctcp_create(sock, 0, 0);
		if (transp == NULL) {
			_msgout("cannot create tcp service.");
			exit(1);
		}
		if (transp->xp_port >= IPPORT_RESERVED) {
			_msgout("cannot allocate tcp privileged port.");
			exit(1);
		}
		if (!_rpcpmstart)
			proto = IPPROTO_TCP;
		if (allowv1) {
			if (!svc_register(transp, YPPROG, YPOLDVERS, ypprog_1, proto)) {
				_msgout("unable to register (YPPROG, YPOLDVERS, tcp).");
				exit(1);
			}
		}
		if (!svc_register(transp, YPPROG, YPVERS, ypprog_2, proto)) {
			_msgout("unable to register (YPPROG, YPVERS, tcp).");
			exit(1);
		}
	}

	if (transp == NULL) {
		_msgout("could not create a handle");
		exit(1);
	}
	if (_rpcpmstart) {
		(void) signal(SIGALRM, closedown);
		(void) alarm(_RPCSVC_CLOSEDOWN);
	}
	my_svc_run();
	_msgout("svc_run returned");
	exit(1);
	/* NOTREACHED */
}

/* ARGSUSED */
void
sig_child(int signo)
{
	int save_errno = errno;

	while (wait3(NULL, WNOHANG, NULL) > 0)
		;
	errno = save_errno;
}

/* ARGSUSED */
void
sig_hup(int signo)
{
	wantsighup = 1;
}
@


1.43
log
@use symbolics for flags to open
from Ricardo Mestre
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.42 2015/10/26 10:12:46 deraadt Exp $ */
d45 1
a45 1
#include <memory.h>
a46 1
#include <dbm.h>
@


1.42
log
@last consumer in base of pidfile()...
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.41 2015/01/15 00:40:26 deraadt Exp $ */
d454 1
a454 1
		i = open("/dev/console", 2);
d457 1
a457 1
		i = open("/dev/tty", 2);
@


1.41
log
@not supposed to include sys/ttycom.h (these may have rpcgen history)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.40 2014/10/11 02:29:24 doug Exp $ */
a475 1
	pidfile(NULL);
@


1.40
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.39 2013/12/05 14:22:42 jca Exp $ */
a31 1
#include <sys/ttycom.h>
@


1.39
log
@Properly initialize 'transp' to appease the compiler.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.38 2013/11/12 22:27:13 deraadt Exp $ */
d355 1
a355 1
			newp = realloc(pfd, sizeof(*pfd) * svc_max_pollfd);
@


1.38
log
@ensure there are prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.37 2010/01/20 23:20:28 schwarze Exp $ */
d396 1
a396 1
	SVCXPRT *transp;
@


1.37
log
@Make ypserv(8) reread its YP maps on SIGHUP
and use that in Makefile.yp(8) at the end of   cd /var/yp; make all
such that the new maps get used locally even when NOPUSH is set;
fixing a quirk reported by ian@@.

While here, polish the yppush(8) manual
and document a few related mini-bugs to be fixed later.

feedback and ok  ian@@ and jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.36 2009/10/27 23:59:58 deraadt Exp $ */
d48 1
d52 1
@


1.36
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.35 2007/02/18 23:34:57 jmc Exp $ */
d337 2
@


1.35
log
@tidy up synopsis and usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.34 2006/04/03 05:01:24 deraadt Exp $ */
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: ypserv.c,v 1.34 2006/04/03 05:01:24 deraadt Exp $";
#endif
@


1.34
log
@spreading the lint love (very minimal things..)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.33 2005/09/16 23:55:04 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv.c,v 1.33 2005/09/16 23:55:04 deraadt Exp $";
d385 1
a385 1
	(void)fprintf(stderr, "usage: ypserv [-a aclfile] [-d] [-x]\n");
@


1.33
log
@use poll() instead of select(), pr4505, alexander.farber@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.32 2004/01/23 03:48:43 deraadt Exp $ */
d29 2
a30 2
#ifndef LINT
static const char rcsid[] = "$OpenBSD: ypserv.c,v 1.32 2004/01/23 03:48:43 deraadt Exp $";
d194 2
a195 2
	(void) memset((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs(transp, xdr_argument, (caddr_t) &argument)) {
d204 1
a204 1
	if (!svc_freeargs(transp, xdr_argument, (caddr_t) &argument)) {
d309 2
a310 2
	(void) memset((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs(transp, xdr_argument, (caddr_t) &argument)) {
d319 1
a319 1
	if (!svc_freeargs(transp, xdr_argument, (caddr_t) &argument)) {
d394 1
a394 1
	socklen_t asize = sizeof (saddr);
d431 1
a431 1
		socklen_t ssize = sizeof (int);
d436 1
a436 1
		    (char *)&_rpcfdtype, &ssize) == -1)
d444 1
a444 1
		int size, i;
d460 1
a460 1
			(void) ioctl(i, TIOCNOTTY, (char *)NULL);
d530 1
a530 1
	if (transp == (SVCXPRT *)NULL) {
d550 1
a550 1
	while (wait3((int *)NULL, WNOHANG, (struct rusage *)NULL) > 0)
@


1.32
log
@Use closefrom(); ok millert tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.31 2003/07/15 06:10:46 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv.c,v 1.31 2003/07/15 06:10:46 deraadt Exp $";
a74 4
extern	int __svc_fdsetsize;
extern	fd_set *__svc_fdset;
extern	void svc_getreqset2(fd_set *, int);

d88 1
a94 2
		extern fd_set *__svc_fdset;
		extern int __svc_fdsetsize;
d99 2
a100 2
		for (i = 0, openfd = 0; i < __svc_fdsetsize && openfd < 2; i++)
			if (FD_ISSET(i, __svc_fdset))
d102 1
a102 1
		if (openfd <= (_rpcpmstart?0:1))
d346 2
a347 1
	fd_set *fds;
d351 1
a352 1
			wantsighup = 0;
d354 14
a367 8
		if (__svc_fdset) {
			int bytes = howmany(__svc_fdsetsize, NFDBITS) *
			    sizeof(fd_mask);
			fds = (fd_set *)malloc(bytes);	/* XXX */
			memcpy(fds, __svc_fdset, bytes);
		} else
			fds = NULL;
		switch (select(svc_maxfd+1, fds, 0, 0, (struct timeval *)0)) {
d369 1
a369 3
			if (errno == EINTR) {
				if (fds)
					free(fds);
d371 2
a372 4
			}
			perror("svc_run: - select failed");
			if (fds)
				free(fds);
a374 2
			if (fds)
				free(fds);
d377 1
a377 2
			svc_getreqset2(fds, svc_maxfd+1);
			free(fds);
d544 1
d555 1
@


1.31
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.30 2003/06/22 23:57:07 maja Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv.c,v 1.30 2003/06/22 23:57:07 maja Exp $";
d459 1
a459 3
		size = getdtablesize();
		for (i = 0; i < size; i++)
			(void) close(i);
@


1.30
log
@Remove files without copyright. Add a yp v1 protocol specification and
generate files at compile time. -moj  ok @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.29 2003/06/12 21:09:48 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv.c,v 1.29 2003/06/12 21:09:48 deraadt Exp $";
d331 1
a331 1
void
d348 1
a348 1
void
d387 1
a387 1
void
@


1.29
log
@ansify
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.28 2003/06/02 21:58:27 maja Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv.c,v 1.28 2003/06/02 21:58:27 maja Exp $";
d118 9
a126 9
		domainname ypproc_domain_1_arg;
		domainname ypproc_domain_nonack_1_arg;
		yprequest ypproc_match_1_arg;
		yprequest ypproc_first_1_arg;
		yprequest ypproc_next_1_arg;
		yprequest ypproc_poll_1_arg;
		yprequest ypproc_push_1_arg;
		yprequest ypproc_pull_1_arg;
		yprequest ypproc_get_1_arg;
d137 1
a137 1
		local = (char *(*)(char *, struct svc_req *)) ypproc_null_1_svc;
d143 1
a143 1
		local = (char *(*)(char *, struct svc_req *)) ypproc_domain_1_svc;
d149 1
a149 1
		local = (char *(*)(char *, struct svc_req *)) ypproc_domain_nonack_1_svc;
d155 1
a155 1
		local = (char *(*)(char *, struct svc_req *)) ypproc_match_1_svc;
d161 1
a161 1
		local = (char *(*)(char *, struct svc_req *)) ypproc_first_1_svc;
d167 1
a167 1
		local = (char *(*)(char *, struct svc_req *)) ypproc_next_1_svc;
d173 1
a173 1
		local = (char *(*)(char *, struct svc_req *)) ypproc_poll_1_svc;
d179 1
a179 1
		local = (char *(*)(char *, struct svc_req *)) ypproc_push_1_svc;
d185 1
a185 1
		local = (char *(*)(char *, struct svc_req *)) ypproc_pull_1_svc;
d191 1
a191 1
		local = (char *(*)(char *, struct svc_req *)) ypproc_get_1_svc;
@


1.28
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.27 2003/05/05 08:37:05 avsm Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv.c,v 1.27 2003/05/05 08:37:05 avsm Exp $";
d332 1
a332 1
hup()
d349 1
a349 1
my_svc_run()
@


1.27
log
@-Wall cleanup: trim unused vars, better err() message in stdhosts,
and constify rcsid[]

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.26 2003/02/13 05:54:39 maja Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv.c,v 1.26 2003/02/13 05:54:39 maja Exp $";
@


1.26
log
@This fixes the problem with ypxfr switching key and value on map transfer.

This will make librpcsvc follow the real protocol and not the incorrect
specification in yp.x.

The changes in yp.x is from FreeBSD. A make build is the simplest way
to get things working but the following five step is an alternative

   1) make depend && make && make install  in lib/librpcsvc
   2) make includes                        in lib/librpcsvc
   3) make depend && make && make install  in lib/libc
   4) make depend && make && make install  in usr.sbin/ypserv/ypserv
   5) make depend && make && make install  in usr.sbin/ypserv/ypxfr

-moj ok niklas@@ ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.25 2002/09/06 19:13:10 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.25 2002/09/06 19:13:10 deraadt Exp $";
@


1.25
log
@use socklen_t
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.24 2002/07/19 20:59:40 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.24 2002/07/19 20:59:40 deraadt Exp $";
d43 1
a43 1
#include "yp.h"
@


1.24
log
@bunch more careful tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.23 2002/07/19 02:38:40 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.23 2002/07/19 02:38:40 deraadt Exp $";
d404 1
a404 1
	int asize = sizeof (saddr);
d441 1
a441 1
		int ssize = sizeof (int);
@


1.23
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.22 2002/05/26 09:32:44 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.22 2002/05/26 09:32:44 deraadt Exp $";
a73 1
char   *progname = "ypserv";
d392 7
d402 1
a402 1
	int usage = 0, xflag = 0, allowv1 = 0, ch, sock, proto;
d423 1
a423 1
			usage++;
a426 5
	if (usage) {
		(void)fprintf(stderr, "usage: %s [-a aclfile] [-d] [-x]\n",progname);
		exit(1);
	}

d428 1
a428 1
		(void)fprintf(stderr, "%s: must be root to run.\n",progname);
@


1.22
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.21 2002/02/19 19:39:41 millert Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.21 2002/02/19 19:39:41 millert Exp $";
d41 1
a41 1
#include <sys/ttycom.h>/* TIOCNOTTY */
d46 2
a47 2
#include <stdlib.h>/* getenv, exit */
#include <string.h> /* strcmp */ 
d51 1
d54 1
a54 1
#include <rpc/pmap_clnt.h> /* for pmap_unset */
a55 1
#ifdef SYSLOG
a56 4
#else
#define LOG_ERR 1
#define openlog(a, b, c)
#endif
d62 2
d85 2
a86 2
static
void _msgout(char* msg)
d394 1
a394 3
main(argc, argv)
	int argc;
	char *argv[];
d401 1
a401 1
	
d420 1
a420 1
	
d485 1
a485 1
	
@


1.21
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.20 2002/02/18 22:20:55 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.20 2002/02/18 22:20:55 deraadt Exp $";
d457 2
a458 2
		int size;
		int pid, i;
@


1.20
log
@minor signal race fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.19 2002/02/16 21:28:11 millert Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.19 2002/02/16 21:28:11 millert Exp $";
a65 4
#ifdef __STDC__
#define SIG_PF void(*)(int)
#endif

d101 1
a101 1
closedown(void)
d550 1
a550 1
		(void) signal(SIGALRM, (SIG_PF) closedown);
@


1.19
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.18 2001/12/05 10:02:16 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.18 2001/12/05 10:02:16 deraadt Exp $";
d107 2
d120 1
a120 1
			exit(0);
d123 1
a572 5
/*
 * XXX
 * This is calling illegal functions inside a signal routine.
 * It's a massive race.
 */
@


1.18
log
@simplify the source
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.17 2001/12/01 23:27:24 miod Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.17 2001/12/01 23:27:24 miod Exp $";
d89 1
a89 1
extern	void svc_getreqset2 __P((fd_set *, int));
@


1.17
log
@Use pidfile() instead of doing the equivalent thing by hand, and sometimes
forgetting to unlink the pid file at exit.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.16 2001/11/19 09:03:06 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.16 2001/11/19 09:03:06 deraadt Exp $";
d83 3
a85 2
void	sig_child();
void	sig_hup();
a90 2
volatile sig_atomic_t wantsighup;

d105 1
a105 1
closedown()
d124 1
a124 1
ypprog_1(struct svc_req *rqstp, register SVCXPRT *transp)
d226 1
a226 1
ypprog_2(struct svc_req *rqstp, register SVCXPRT *transp)
d401 1
a401 3
	register SVCXPRT *transp;
	int sock;
	int proto;
d404 2
a405 5
	int	 usage = 0;
	int	 xflag = 0;
	int	 allowv1 = 0;
	int	 ch;
	extern	 char *optarg;
d436 1
a436 1
	if (aclfile != NULL) {
d438 1
a438 1
	} else {
d440 2
a441 2
	}
	if (xflag) {
a442 1
	}
d495 1
a495 1
	if ((_rpcfdtype == 0) || (_rpcfdtype == SOCK_DGRAM)) {
d519 1
a519 1
	if ((_rpcfdtype == 0) || (_rpcfdtype == SOCK_STREAM)) {
d561 1
a561 1
sig_child()
d576 1
a576 1
sig_hup()
@


1.16
log
@use a private svc_run() function that checks for a signal handler flag;
now signal safe.  Also, massive KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.15 2001/01/11 23:37:01 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.15 2001/01/11 23:37:01 deraadt Exp $";
d500 1
a500 7
	{
		FILE *pidfile = fopen(YPSERV_PID_PATH, "w");
		if (pidfile != NULL) {
			fprintf(pidfile, "%d\n", getpid());
			fclose(pidfile);
		}
	}
@


1.15
log
@fix closedown() stub generated by rpcgen(1)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.14 2000/11/18 03:21:36 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.14 2000/11/18 03:21:36 deraadt Exp $";
d38 5
a46 1
#include <rpc/pmap_clnt.h> /* for pmap_unset */
d51 3
a53 4
#include <sys/ttycom.h>/* TIOCNOTTY */
#ifdef __cplusplus
#include <sysent.h> /* getdtablesize, open */
#endif /* __cplusplus */
a54 2
#include <sys/socket.h>
#include <netinet/in.h>
d83 8
a90 2
void sig_child();
void sig_hup();
a223 1
	return;
d339 56
a394 1
	return;
d398 3
a400 3
main (argc,argv)
int argc;
char *argv[];
d433 1
a433 1
		(void)fprintf(stderr,"usage: %s [-a aclfile] [-d] [-x]\n",progname);
d438 1
a438 1
		(void)fprintf(stderr,"%s: must be root to run.\n",progname);
d449 1
a449 1
	};
d457 1
a457 1
				(char *)&_rpcfdtype, &ssize) == -1)
d500 6
a505 5
	{ FILE *pidfile = fopen(YPSERV_PID_PATH, "w");
	  if (pidfile != NULL) {
		fprintf(pidfile, "%d\n", getpid());
		fclose(pidfile);
	  }
d567 1
a567 1
	svc_run();
d591 1
a591 16
	int save_errno = errno;

	/* Handle the log. */
	ypcloselog();
	ypopenlog();

	acl_reset();
	if (aclfile != NULL) {
		yplog("sig_hup: reread %s",aclfile);
		(void)acl_init(aclfile);
	} else {
		yplog("sig_hup: reread %s",YP_SECURENET_FILE);
		(void)acl_securenet(YP_SECURENET_FILE);
	}

	errno = save_errno;
@


1.14
log
@avoid SIGHUP log issues, pr 1511, dean@@bullock.net.  It is still a signal
race, but I do not at the moment feel like rewriting a call to svc_run()
to handle it syncronously ...
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.13 2000/06/28 23:58:48 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.13 2000/06/28 23:58:48 deraadt Exp $";
d102 2
a103 2
		extern fd_set svc_fdset;
		static int size;
d108 2
a109 5
		if (size == 0) {
			size = getdtablesize();
		}
		for (i = 0, openfd = 0; i < size && openfd < 2; i++)
			if (FD_ISSET(i, &svc_fdset))
@


1.13
log
@make _msgout() use syslog() with a %s, for future safety
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.12 1997/11/04 07:40:52 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.12 1997/11/04 07:40:52 deraadt Exp $";
d524 5
d532 6
d546 2
@


1.12
log
@ensure we got a reserved port
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.11 1997/08/05 05:09:33 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.11 1997/08/05 05:09:33 deraadt Exp $";
d90 1
a90 1
		syslog(LOG_ERR, msg);
d94 1
a94 1
	syslog(LOG_ERR, msg);
@


1.12.10.1
log
@Pull in patch from current:
Fix (deraadt):
make _msgout() use syslog() with a %s, for future safety
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.13 2000/06/28 23:58:48 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.13 2000/06/28 23:58:48 deraadt Exp $";
d90 1
a90 1
		syslog(LOG_ERR, "%s", msg);
d94 1
a94 1
	syslog(LOG_ERR, "%s", msg);
@


1.11
log
@pull errno.h in
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.10 1997/08/04 19:26:25 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.10 1997/08/04 19:26:25 deraadt Exp $";
d455 4
d480 4
@


1.10
log
@save errno in sigchld handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.9 1997/04/12 00:14:28 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.9 1997/04/12 00:14:28 deraadt Exp $";
d46 1
@


1.9
log
@-1 flag enables v1 YP, otherwise it is disabled; from maja
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.8 1997/03/30 20:51:20 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.8 1997/03/30 20:51:20 maja Exp $";
d508 5
a512 1
	while (wait3((int *)NULL, WNOHANG, (struct rusage *)NULL) > 0);
@


1.8
log
@Added support for YP V1. Partly from FreeBSD. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.7 1997/01/15 23:44:34 millert Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.7 1997/01/15 23:44:34 millert Exp $";
d350 1
d354 1
a354 1
	while ((ch = getopt(argc, argv, "a:dx")) != -1)
d356 3
d456 5
a460 3
		if (!svc_register(transp, YPPROG, YPOLDVERS, ypprog_1, proto)) {
			_msgout("unable to register (YPPROG, YPOLDVERS, udp).");
			exit(1);
d479 5
a483 3
		if (!svc_register(transp, YPPROG, YPOLDVERS, ypprog_1, proto)) {
			_msgout("unable to register (YPPROG, YPOLDVERS, tcp).");
			exit(1);
@


1.7
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.6 1996/10/02 23:44:56 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.6 1996/10/02 23:44:56 deraadt Exp $";
d39 1
d120 103
d427 1
d452 4
d473 4
@


1.6
log
@int ch; from ws@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.5 1996/06/30 19:46:08 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.5 1996/06/30 19:46:08 maja Exp $";
d249 1
a249 1
	while ((ch = getopt(argc, argv, "a:dx")) != EOF)
@


1.5
log
@Added support for SIGHUP in ypserv for reread of /var/yp/securenet or
aclfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.4 1996/06/26 21:26:38 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.4 1996/06/26 21:26:38 maja Exp $";
d246 1
a246 1
	char	 ch;
@


1.4
log
@Same copyright all over, removed my name from ypdb.[ch], small bugfix
in ypserv_db.c /moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv.c,v 1.3 1996/05/30 09:53:29 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv.c,v 1.3 1996/05/30 09:53:29 deraadt Exp $";
d60 1
a62 2
#define YP_SECURENET_FILE "/var/yp/securenet"

d78 1
d81 1
a247 1
	char	 *aclfile = NULL;
d331 7
d390 12
@


1.3
log
@$OpenBSD$ tag and few spelling errors
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d15 5
a19 3
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
d35 1
a35 1
static char rcsid[] = "$OpenBSD$";
@


1.2
log
@Major reworking of ypserv.c by me: this program actually works now!!
highlights:
 - fixed yp first call (uses ypreq_nokey rather than ypreq_key, despite
			what yp.x says)
 - cleanup of looging
 - removed SVCXPRT args to "local" since you can get them from svc_req
	and this makes it look more like rpcgen's output
 - use new yplog()
 - add call to db init
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: ypserv.c,v 1.1 1995/11/01 16:56:36 deraadt Exp $";
@


1.1
log
@+ full set of ypserv tools that compile
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: ypserv.c,v 1.12 1995/10/24 21:56:53 moj Exp $";
a73 1
int	acl_access_ok;
d120 1
a120 1
		ypreq_key ypproc_first_2_arg;
d130 1
a130 2
	char *(*local)(char *, struct svc_req *, SVCXPRT *);
	struct sockaddr_in *caller;
a132 50
	
	caller = svc_getcaller(transp);
	acl_access_ok = acl_check_host(&caller->sin_addr);
	
	if (!acl_access_ok) {
		yplog_date("ypserv: access denied");
		yplog_call(transp);
		switch (rqstp->rq_proc) {
		case YPPROC_NULL:
			yplog_line("request: NULL");
			break;
		case YPPROC_DOMAIN:
			yplog_line("request: DOMAIN");
			break;
		case YPPROC_DOMAIN_NONACK:
			yplog_line("request: DOMAIN_NONACK");
			break;
		case YPPROC_MATCH:
			yplog_line("request: MATCH");
			break;
		case YPPROC_FIRST:
			yplog_line("request: FIRST");
			break;
		case YPPROC_NEXT:
			yplog_line("request: NEXT");
			break;
		case YPPROC_XFR:
			yplog_line("request: XFR");
			break;
		case YPPROC_CLEAR:
			yplog_line("request: CLEAR");
			break;
		case YPPROC_ALL:
			yplog_line("request: ALL");
			break;
		case YPPROC_MASTER:
			yplog_line("request: MASTER");
			break;
		case YPPROC_ORDER:
			yplog_line("request: ORDER");
			break;
		case YPPROC_MAPLIST:
			yplog_line("request: MAPLIST");
			break;
		default:
			yplog_line("request: unknown");
			break;
		}
	}
	
d137 1
a137 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_null_2_svc;
d143 1
a143 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_domain_2_svc;
d149 1
a149 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_domain_nonack_2_svc;
d155 1
a155 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_match_2_svc;
d159 1
a159 1
		xdr_argument = (xdrproc_t) xdr_ypreq_key;
d161 1
a161 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_first_2_svc;
d167 1
a167 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_next_2_svc;
d173 1
a173 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_xfr_2_svc;
d179 1
a179 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_clear_2_svc;
d185 1
a185 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_all_2_svc;
d191 1
a191 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_master_2_svc;
d197 1
a197 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_order_2_svc;
d203 1
a203 1
		local = (char *(*)(char *, struct svc_req *, SVCXPRT *)) ypproc_maplist_2_svc;
d217 1
a217 2
	result = (*local)((char *)&argument, rqstp, transp);
/*
a224 1
*/
d321 2
a322 1
	yplog_init(progname);
@
