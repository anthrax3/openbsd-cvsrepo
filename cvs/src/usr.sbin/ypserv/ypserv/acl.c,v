head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.16
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.12
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.8
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.10
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.16
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.14
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.12
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.16
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.12
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.16
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.14
	OPENBSD_2_8:1.6.0.12
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.10
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.15
date	2013.12.04.02.18.05;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.58;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.03.05.01.23;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.08.19.17.30;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.21.58.27;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.05.08.37.05;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.09.03.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.02.24.04.29.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.08.05.09.26.55;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.06.30.19.46.04;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.21.26.36;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.09.53.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.11.01.16.56.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@ctype improvements; checked by okan
@
text
@/*	$OpenBSD: acl.c,v 1.14 2009/10/27 23:59:58 deraadt Exp $ */

/*
 * Copyright (c) 1994 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <netdb.h>
#include "acl.h"

#define TRUE 1
#define FALSE 0

static	struct aclent *acl_root = NULL;

static int
acl_read_line(FILE *fp, char *buf, int size)
{
	int	 len = 0;
	char *c, *p, l;

	/* Read a line, and remove any comment, trim space */

	do {
		while (fgets(buf, size, fp)) {
			c = buf;
			while (*c != '\0') {
				if (*c == '#' || *c == '\n') {
					*c = '\0';
				} else {
					c++;
				}
			}

			c = p = buf; l = ' ';
			while (*c != '\0') {
				if (isspace((unsigned char)l) &&
				    isspace((unsigned char)*c)) {
					c++;
				} else {
					l = *c++; *p = l; p++;
				}
			}
			*p = '\0';

			if (p != buf) {
				--p;
				if (isspace((unsigned char)*p) != 0) {
					*p = '\0';
				}
			}

			len = strlen(buf);
			return len + 1;
		}
	} while (size > 0 && !feof(fp));
	return len;
}

int
acl_check_host(struct in_addr *addr)
{
	struct aclent *p;

	p = acl_root;
	while (p != NULL) {
		if ((addr->s_addr & p->s_mask) == p->s_addr)
			return(p->allow);
		p = p->next;
	}
	return(TRUE);
}

static void
acl_add_net(int	allow, struct in_addr *addr, struct in_addr *mask)
{
	struct aclent *acl, *p;

	acl = malloc(sizeof(struct aclent));
	acl->next	 = NULL;
	acl->allow	= allow;
	acl->s_addr = addr->s_addr;
	acl->s_mask = mask->s_addr;

	if (acl_root == NULL) {
		acl_root = acl;
	} else {
		p = acl_root;
		while (p->next != NULL)
			p = p->next;
		p->next = acl;
	}
}

static void
acl_add_host(int allow, struct in_addr *addr)
{
	struct in_addr mask;

	mask.s_addr = htonl(0xffffffff);
	acl_add_net(allow, addr, &mask);
}

int
acl_init(char *file)
{
	char data_line[1024], *p, *k;
	int line_no = 0, len, i, state;
	int allow = TRUE, error_cnt = 0;
	struct in_addr addr, mask, *host_addr;
	struct hostent *host;
	struct netent *net;
	FILE *data_file = NULL;

	if (file != NULL)
		data_file = fopen(file, "r");

	while (data_file != NULL &&
	    acl_read_line(data_file, data_line, sizeof(data_line))) {

		line_no++;
		len = strlen(data_line);
		if (len == 0)
			continue;
		p = (char *) &data_line;

		/* State 1: Initial State */

		state = ACLS_INIT;
		addr.s_addr = mask.s_addr = 0;

		k = p;			/* save start of verb */
		i = 0;
		while (*p != '\0' &&
		    !isspace((*p = tolower(*p)))) {
			p++;
			i++;
		}

		if (*p != '\0')
			*p++ = '\0';

		if (strcmp(k, "allow") == 0) {
			allow = TRUE;
			state = ACLS_ALLOW;
		}

		if (strcmp(k, "deny") == 0) {
			allow = FALSE;
			state = ACLS_DENY;
		}

		if (state == ACLS_INIT)
			state = ACLE_UVERB;

		/* State 2: allow row */
		/* State 3: deny row */

		if (*p != '\0' &&
		    (state == ACLS_ALLOW || state == ACLS_DENY)) {
			k = p;			/* save start of verb */
			i = 0;
			while (*p != '\0' &&
			    !isspace((*p = tolower(*p)))) {
				p++;
				i++;
			}

			if (*p != '\0')
				*p++ = '\0';

			if (strcmp(k, "all") == 0)
				state = state + ACLD_ALL;

			if (strcmp(k, "host") == 0)
				state = state + ACLD_HOST;

			if (strcmp(k, "net") == 0)
				state = state + ACLD_NET;

			if (state == ACLS_ALLOW || state == ACLS_DENY)
				state = ACLE_U2VERB;
		}

		if (state == ACLS_ALLOW || state == ACLS_DENY)
			state = ACLE_UEOL;

		/* State 4 & 5: all state, remove any comment */

		if (*p == '\0' &&
		    (state == ACLS_ALLOW_ALL || state == ACLS_DENY_ALL)) {
			acl_add_net(allow, &addr, &mask);
			state = ACLE_OK;
		}

		/* State 6 & 7: host line */
		/* State 8 & 9: net line */

		if (*p != '\0' &&
		    state >= ACLS_ALLOW_HOST && state <= ACLS_DENY_NET) {

			k = p;			/* save start of verb */
			i = 0;
			while (*p != '\0' &&
			    !isspace((*p = tolower(*p)))) {
				p++;
				i++;
			}

			if (*p != '\0')
				*p++ = '\0';

			if (state == ACLS_ALLOW_HOST || state == ACLS_DENY_HOST) {
				if (*k >= '0' && *k <= '9') {
					(void)inet_aton(k, &addr);
					acl_add_host(allow, &addr);
					state = state + ACLD_HOST_DONE;
				} else {
					host = gethostbyname(k);
					if (host == NULL) {
						state = ACLE_NOHOST;
					} else {
						if (host->h_addrtype == AF_INET) {
							while ((host_addr = (struct in_addr *) *host->h_addr_list++) != NULL)
								acl_add_host(allow, host_addr);
						}
						state = state + ACLD_HOST_DONE;
					}
				}
			}

			if (state == ACLS_ALLOW_NET || state == ACLS_DENY_NET) {
				if (*k >= '0' && *k <= '9') {
					(void)inet_aton(k, &addr);
					state = state + ACLD_NET_DONE;
				} else {
					net = getnetbyname(k);
					if (net == NULL) {
						state = ACLE_NONET;
					} else {
						addr.s_addr = ntohl(net->n_net);
						state = state + ACLD_NET_DONE;
					}
				}
			}

		}

		if (state >= ACLS_ALLOW_HOST && state <= ACLS_DENY_NET)
			state = ACLE_UEOL;


		/* State 10 & 11: allow/deny host line */
		if (*p == '\0' &&
		    (state == ACLS_ALLOW_HOST_DONE || state == ACLS_DENY_HOST_DONE))
			state = ACLE_OK;

		/* State 12 & 13: allow/deny net line */
		if (*p == '\0' &&
		    (state == ACLS_ALLOW_NET_DONE || state == ACLS_DENY_NET_DONE)) {
			mask.s_addr = htonl(0xffffff00);
			if (ntohl(addr.s_addr) < 0xc0000000)
				mask.s_addr = htonl(0xffff0000);
			if (ntohl(addr.s_addr) < 0x80000000)
				mask.s_addr = htonl(0xff000000);
			acl_add_net(allow, &addr, &mask);
			state = ACLE_OK;
		}

		if (*p != '\0' &&
		    (state == ACLS_ALLOW_NET_DONE || state == ACLS_DENY_NET_DONE)) {

			k = p;			/* save start of verb */
			i = 0;
			while (*p != '\0' &&
			    !isspace((*p = tolower(*p)))) {
				p++;
				i++;
			}

			if (*p != '\0')
				*p++ = '\0';

			if (strcmp(k, "netmask") == 0)
				state = state + ACLD_NET_MASK;

			if (state == ACLS_ALLOW_NET_DONE ||
			    state == ACLS_DENY_NET_DONE)
				state = ACLE_NONETMASK;
		}

		/* State 14 & 15: allow/deny net netmask line */
		if (*p != '\0' &&
		    (state == ACLS_ALLOW_NET_MASK || state == ACLS_DENY_NET_MASK)) {

			k = p;		/* save start of verb */
			i = 0;
			while (*p != '\0' &&
			    !isspace((*p = tolower(*p)))) {
				p++;
				i++;
			}

			if (*p != '\0')
				*p++ = '\0';

			if (state == ACLS_ALLOW_NET_MASK ||
			    state == ACLS_DENY_NET_MASK) {
				if (*k >= '0' && *k <= '9') {
					(void)inet_aton(k, &mask);
					state = state + ACLD_NET_EOL;
				} else {
					net = getnetbyname(k);
					if (net == NULL) {
						state = ACLE_NONET;
					} else {
						mask.s_addr = ntohl(net->n_net);
						state = state + ACLD_NET_EOL;
					}
				}
			}

		}

		if (state == ACLS_ALLOW_NET_MASK || state == ACLS_DENY_NET_MASK)
			state = ACLE_UEOL;

		/* State 16 & 17: allow/deny host line */
		if (*p == '\0' &&
		    (state == ACLS_ALLOW_NET_EOL || state == ACLS_DENY_NET_EOL)) {
			acl_add_net(allow, &addr, &mask);
			state = ACLE_OK;
		}

		switch (state) {
		case ACLE_NONETMASK:
			fprintf(stderr,
			    "acl: excpected \"netmask\" missing at line %d\n",
			    line_no);
			break;
		case ACLE_NONET:
			error_cnt++;
			fprintf(stderr, "acl: unknown network at line %d\n",
			    line_no);
			break;
		case ACLE_NOHOST:
			error_cnt++;
			fprintf(stderr, "acl: unknown host at line %d\n",
			    line_no);
			break;
		case ACLE_UVERB:
			error_cnt++;
			fprintf(stderr, "acl: unknown verb at line %d\n",
			    line_no);
			break;
		case ACLE_U2VERB:
			error_cnt++;
			fprintf(stderr,
			    "acl: unknown secondary verb at line %d\n",
			    line_no);
			break;
		case ACLE_UEOL:
			error_cnt++;
			fprintf(stderr,
			    "acl: unexpected end of line at line %d\n",
			    line_no);
			break;
		case ACLE_OK:
			break;
		default:
			error_cnt++;
			fprintf(stderr, "acl: unexpected state %d %s\n",
			    state, k);
		}

	}

	if (data_file != NULL) {
		(void)fflush(stderr);
		(void)fclose(data_file);
	}

	/* Always add a last allow all if file don't exists or */
	/* the file doesn't cover all cases. */
	addr.s_addr = mask.s_addr = 0;
	allow = TRUE;
	acl_add_net(allow, &addr, &mask);
	return(error_cnt);
}

int
acl_securenet(char *file)
{
	char data_line[1024], *p, *k;
	int line_no = 0, len, i, allow = TRUE, state;
	int error_cnt = 0;
	struct in_addr addr, mask;
	struct netent *net;
	FILE *data_file = NULL;

	if (file != NULL)
		data_file = fopen(file, "r");

	/* Always add a localhost allow first, to be compatible with sun */
	addr.s_addr = htonl(0x7f000001);
	mask.s_addr = htonl(0xffffffff);
	allow = TRUE;
	acl_add_net(allow, &addr, &mask);

	while (data_file != NULL &&
	    acl_read_line(data_file, data_line, sizeof(data_line))) {
		line_no++;
		len = strlen(data_line);
		if (len == 0)
			continue;
		p = (char *) &data_line;

		/* State 1: Initial State */
		state = ACLS_INIT;
		addr.s_addr = mask.s_addr = 0;

		k = p;				/* save start of verb */
		i = 0;
		while (*p != '\0' &&
		    !isspace((*p = tolower(*p)))) {
			p++;
			i++;
		}

		if (*p != '\0') {
			*p++ = '\0';
			state = ACLS_ALLOW_NET_MASK;
		}

		if (state == ACLS_INIT)
			state = ACLE_UEOL;

		if (state == ACLS_ALLOW_NET_MASK) {
			if (*k >= '0' && *k <= '9') {
				(void)inet_aton(k, &mask);
				state = ACLS_ALLOW_NET;
			} else {
				net = getnetbyname(k);
				if (net == NULL) {
					state = ACLE_NONET;
				} else {
					mask.s_addr = ntohl(net->n_net);
					state = ACLS_ALLOW_NET;
				}
			}

			k = p;				/* save start of verb */
			i = 0;
			while (*p != '\0' &&
			    !isspace((*p = tolower(*p)))) {
				p++;
				i++;
			}

			if (*p != '\0')
				*p++ = '\0';
		}

		if (state == ACLS_ALLOW_NET_MASK)
			state = ACLE_UEOL;

		if (state == ACLS_ALLOW_NET) {
			if (*k >= '0' && *k <= '9') {
				(void)inet_aton(k, &addr);
				state = ACLS_ALLOW_NET_EOL;
			} else {
				net = getnetbyname(k);
				if (net == NULL) {
					state = ACLE_NONET;
				} else {
					addr.s_addr = ntohl(net->n_net);
					state = ACLS_ALLOW_NET_EOL;
				}
			}
		}

		if (state == ACLS_ALLOW_NET)
			state = ACLE_UEOL;

		if (*p == '\0' && state == ACLS_ALLOW_NET_EOL) {
			acl_add_net(allow, &addr, &mask);
			state = ACLE_OK;
		}

		switch (state) {
		case ACLE_NONET:
			error_cnt++;
			fprintf(stderr,
			    "securenet: unknown network at line %d\n",
			    line_no);
			break;
		case ACLE_UEOL:
			error_cnt++;
			fprintf(stderr,
			    "securenet: unexpected end of line at line %d\n",
			    line_no);
			break;
		case ACLE_OK:
			break;
		default:
			error_cnt++;
			fprintf(stderr, "securenet: unexpected state %d %s\n",
			    state, k);
		}
	}

	if (data_file != NULL) {
		(void)fflush(stderr);
		(void)fclose(data_file);

		/* Always add a last deny all if file exists */
		addr.s_addr = mask.s_addr = 0;
		allow = FALSE;
		acl_add_net(allow, &addr, &mask);
	}

	/* Always add a last allow all if file don't exists */

	addr.s_addr = mask.s_addr = 0;
	allow = TRUE;
	acl_add_net(allow, &addr, &mask);
	return(error_cnt);
}

void
acl_reset(void)
{
	struct aclent *p;

	while (acl_root != NULL) {
		p = acl_root->next;
		free(acl_root);
		acl_root = p;
	}
}
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.13 2006/04/03 05:01:23 deraadt Exp $ */
d66 2
a67 1
				if (isspace(l) && isspace(*c)) {
d77 1
a77 1
				if (isspace(*p) != 0) {
d163 2
a164 1
		while (*p != '\0' && !isspace(*p = (char)tolower(*p))) {
d192 2
a193 1
			while (*p != '\0' && !isspace(*p = (char)tolower(*p))) {
d233 2
a234 1
			while (*p != '\0' && !isspace(*p = (char)tolower(*p))) {
d304 2
a305 1
			while (*p != '\0' && !isspace(*p = (char)tolower(*p))) {
d327 2
a328 1
			while (*p != '\0' && !isspace(*p = (char)tolower(*p))) {
d453 2
a454 1
		while (*p != '\0' && !isspace(*p = (char)tolower(*p))) {
d483 2
a484 1
			while (*p != '\0' && !isspace(*p = (char)tolower(*p))) {
@


1.13
log
@spreading the lint love (very minimal things..)
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.12 2003/11/08 19:17:30 jmc Exp $ */
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: acl.c,v 1.12 2003/11/08 19:17:30 jmc Exp $";
#endif
@


1.12
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.11 2003/07/15 06:10:46 deraadt Exp $ */
d29 2
a30 2
#ifndef LINT
static const char rcsid[] = "$OpenBSD: acl.c,v 1.11 2003/07/15 06:10:46 deraadt Exp $";
d111 1
a111 1
	acl = (struct aclent *) malloc(sizeof(struct aclent));
d166 1
a166 1
		while (*p != '\0' && !isspace(*p = tolower(*p))) {
d194 1
a194 1
			while (*p != '\0' && !isspace(*p = tolower(*p))) {
d234 1
a234 1
			while (*p != '\0' && !isspace(*p = tolower(*p))) {
d304 1
a304 1
			while (*p != '\0' && !isspace(*p = tolower(*p))) {
d326 1
a326 1
			while (*p != '\0' && !isspace(*p = tolower(*p))) {
d399 2
a400 1
			fprintf(stderr, "acl: unexpected state %d %s\n",state,k);
d451 1
a451 1
		while (*p != '\0' && !isspace(*p = tolower(*p))) {
d480 1
a480 1
			while (*p != '\0' && !isspace(*p = tolower(*p))) {
@


1.11
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.10 2003/06/02 21:58:27 maja Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: acl.c,v 1.10 2003/06/02 21:58:27 maja Exp $";
d430 1
a430 1
	/* Always add a localhost allow first, to be compatable with sun */
@


1.10
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.9 2003/05/05 08:37:05 avsm Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: acl.c,v 1.9 2003/05/05 08:37:05 avsm Exp $";
d106 1
a106 1
void
d127 1
a127 1
void
@


1.9
log
@-Wall cleanup: trim unused vars, better err() message in stdhosts,
and constify rcsid[]

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.8 2002/07/19 02:38:40 deraadt Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: acl.c,v 1.8 2002/07/19 02:38:40 deraadt Exp $";
@


1.8
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.7 2001/11/19 09:03:06 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: acl.c,v 1.7 2001/11/19 09:03:06 deraadt Exp $";
@


1.7
log
@use a private svc_run() function that checks for a signal handler flag;
now signal safe.  Also, massive KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.6 1998/02/24 04:29:07 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: acl.c,v 1.6 1998/02/24 04:29:07 deraadt Exp $";
d55 1
a55 4
acl_read_line(fp, buf, size)
	FILE *fp;
	char *buf;
	int size;
d65 1
a65 1
			while(*c != '\0') {
d74 1
a74 1
			while(*c != '\0') {
d82 1
a82 1
			
d98 1
a98 2
acl_check_host(addr)
struct in_addr *addr;
d101 1
a101 1
	
d112 1
a112 3
acl_add_net(allow, addr,mask)
	int	allow;
	struct in_addr *addr, *mask;
d115 1
a115 1
	
d121 1
a121 1
	
d130 1
a130 1
} 
d133 1
a133 3
acl_add_host(allow, addr)
	int	allow;
	struct in_addr *addr;
d142 1
a142 2
acl_init(file)
	char *file;
d144 3
a146 7
	char	 data_line[1024];
	int	 line_no = 0;
	int	 len, i;
	int	 allow = TRUE;
	int	 error_cnt = 0;
	char	*p, *k;
	int	 state;
d149 3
a151 3
	struct netent	*net;
	FILE	*data_file = NULL;
	
d157 1
a157 1
		
d203 1
a203 1
			
d230 1
a230 1
			
d243 1
a243 1
			
d246 1
a246 1
			
d291 1
a291 1
			
d306 1
a306 1
			
d313 1
a313 1
			
d335 1
a335 1
			
d366 1
a366 1
			
d423 1
a423 2
acl_securenet(file)
char *file;
d425 3
a427 7
	char	 data_line[1024];
	int	 line_no = 0;
	int	 len, i;
	int	 allow = TRUE;
	int	 error_cnt = 0;
	char	*p, *k;
	int	 state;
d429 3
a431 3
	struct netent	*net;
	FILE	*data_file = NULL;
	
d459 1
a459 1
		
d464 1
a464 1
		
d481 1
a481 1
			
d488 1
a488 1
			
d492 1
a492 1
		
d510 1
a510 1
			
d518 1
a518 1
			
d544 1
a544 1
		
d552 1
a552 1
	
d560 1
a560 1
acl_reset()
@


1.6
log
@pull in prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.5 1997/08/05 09:26:55 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: acl.c,v 1.5 1997/08/05 09:26:55 maja Exp $";
d54 5
a58 4
static int acl_read_line(fp, buf, size)
FILE *fp;
char *buf;
int size;
d60 2
a61 2
  int   len = 0;
  char *c,*p,l;
d63 1
a63 1
  /* Read a line, and remove any comment, trim space */
d65 33
a97 34
  do {
    while (fgets(buf, size, fp)) {
      c = buf;
      while(*c != '\0') {
	if ((*c == '#') || (*c == '\n')) {
	  *c = '\0';
	} else {
	  c++;
	}
      }

      c = p = buf; l = ' ';
      while(*c != '\0') {
	if ((isspace(l) != 0) && (isspace(*c) != 0)) {
	  c++;
	} else {
	  l = *c++; *p = l; p++;
	}
      }
      *p = '\0';
      
      if (p != buf) {
	--p;
	if (isspace(*p) != 0) {
	  *p = '\0';
	}
      }

      len = strlen(buf);
      return len + 1;
    }
  } while (size > 0 && !feof(fp));
  
  return len;
d104 9
a112 10
  struct aclent *p;
  
  p = acl_root;
  while (p != NULL) {
    if ((addr->s_addr & p->s_mask) == p->s_addr) {
      return(p->allow);
    }
    p = p->next;
  }
  return(TRUE);
d116 3
a118 3
acl_add_net(allow,addr,mask)
int	allow;
struct in_addr *addr,*mask;
d120 16
a135 19
  
  struct aclent *acl,*p;
  
  acl = (struct aclent *) malloc((unsigned) sizeof(struct aclent));
  
  acl->next   = NULL;
  acl->allow  = allow;
  acl->s_addr = addr->s_addr;
  acl->s_mask = mask->s_addr;
  
  if (acl_root == NULL) {
    acl_root = acl;
  } else {
    p = acl_root;
    while (p->next != NULL)
      p = p->next;
    p->next = acl;
  }
  
d139 3
a141 3
acl_add_host(allow,addr)
int	allow;
struct in_addr *addr;
d143 1
a143 1
  	struct in_addr mask;
d146 1
a146 2
	
	acl_add_net(allow,addr,&mask);
d151 1
a151 1
char *file;
d153 266
a418 138
  char	 data_line[1024];
  int	 line_no = 0;
  int	 len,i;
  int	 allow = TRUE;
  int	 error_cnt = 0;
  char	*p,*k;
  int	 state;
  struct in_addr addr,mask,*host_addr;
  struct hostent *host;
  struct netent  *net;
  FILE  *data_file = NULL;
  
  if (file != NULL) {
    data_file = fopen(file,"r");
  };

  while ((data_file != NULL) &&
	 (acl_read_line(data_file,data_line,sizeof(data_line)))) {
    
    line_no++;
    
    len = strlen(data_line);
    if (len == 0) {
      continue;
    }

    p = (char *) &data_line;

    /* State 1: Initial State */

    state = ACLS_INIT;
    addr.s_addr = mask.s_addr = 0;

    k = p; i = 0;				/* save start of verb */
    while ((*p != '\0') &&
	   (!isspace(*p = tolower(*p)))) {
      p++; i++;
    };

    if (*p != '\0') {
      *p++ = '\0';
    }

    if (strcmp(k,"allow") == 0) {
      allow = TRUE;
      state = ACLS_ALLOW;
    }

    if (strcmp(k,"deny") == 0) {
      allow = FALSE;
      state = ACLS_DENY;
    }

    if (state == ACLS_INIT) {
      state = ACLE_UVERB;
    }

    /* State 2: allow row */
    /* State 3: deny row */

    if ((*p != '\0') &&
	((state == ACLS_ALLOW) || (state == ACLS_DENY))) {
      
      k = p; i = 0;				/* save start of verb */
      while ((*p != '\0') &&
	     (!isspace(*p = tolower(*p)))) {
	p++; i++;
      };
      
      if (*p != '\0') {
	*p++ = '\0';
      }

      if (strcmp(k,"all") == 0) {
	state = state + ACLD_ALL;
      }

      if (strcmp(k,"host") == 0) {
	state = state + ACLD_HOST;
      }

      if (strcmp(k,"net") == 0) {
	state = state + ACLD_NET;
      }

      if ((state == ACLS_ALLOW) || (state == ACLS_DENY)) {
	state = ACLE_U2VERB;
      }
      
    }

    if ((state == ACLS_ALLOW) || (state == ACLS_DENY)) {
      state = ACLE_UEOL;
    }

    /* State 4 & 5: all state, remove any comment */

    if ((*p == '\0') &&
	((state == ACLS_ALLOW_ALL) || (state == ACLS_DENY_ALL))) {
      acl_add_net(allow,&addr,&mask);
      state = ACLE_OK;
    }
      
    /* State 6 & 7: host line */
    /* State 8 & 9: net line */

    if ((*p != '\0') &&
	(state >= ACLS_ALLOW_HOST) && (state <= ACLS_DENY_NET)) {
      
      k = p; i = 0;				/* save start of verb */
      while ((*p != '\0') &&
	     (!isspace(*p = tolower(*p)))) {
	p++; i++;
      };
      
      if (*p != '\0') {
	*p++ = '\0';
      }
      
      if ((state == ACLS_ALLOW_HOST) || (state == ACLS_DENY_HOST)) {
	if ((*k >= '0') && (*k <= '9')) {
	  (void)inet_aton(k,&addr);
	  acl_add_host(allow,&addr);
	  state = state + ACLD_HOST_DONE;
        } else {
	  host = gethostbyname(k);
	  if (host == NULL) {
	    state = ACLE_NOHOST;
	  } else {
	    if (host->h_addrtype == AF_INET) {
	      while ((host_addr = (struct in_addr *) *host->h_addr_list++)
		     != NULL)
		acl_add_host(allow,host_addr);
	    }
	    state = state + ACLD_HOST_DONE;
	  }
	}
      }
a419 12
      if ((state == ACLS_ALLOW_NET) || (state == ACLS_DENY_NET)) {
	if ((*k >= '0') && (*k <= '9')) {
	  (void)inet_aton(k,&addr);
	  state = state + ACLD_NET_DONE;
        } else {
	  net = getnetbyname(k);
	  if (net == NULL) {
	    state = ACLE_NONET;
	  } else {
	    addr.s_addr = ntohl(net->n_net);
	    state = state + ACLD_NET_DONE;
	  }
a420 3
      }

    }
d422 3
a424 76
    if ((state >= ACLS_ALLOW_HOST) && (state <= ACLS_DENY_NET)) {
      state = ACLE_UEOL;
    }

    /* State 10 & 11: allow/deny host line */

    if ((*p == '\0') &&
	((state == ACLS_ALLOW_HOST_DONE) || (state == ACLS_DENY_HOST_DONE))) {
      state = ACLE_OK;
    }
      
    /* State 12 & 13: allow/deny net line */

    if ((*p == '\0') &&
	((state == ACLS_ALLOW_NET_DONE) || (state == ACLS_DENY_NET_DONE))) {
      mask.s_addr = htonl(0xffffff00);
      if (ntohl(addr.s_addr) < 0xc0000000) {
	mask.s_addr = htonl(0xffff0000);
      }
      if (ntohl(addr.s_addr) < 0x80000000) {
	mask.s_addr = htonl(0xff000000);
      }
      acl_add_net(allow,&addr,&mask);
      state = ACLE_OK;
    }

    if ((*p != '\0') &&
	((state == ACLS_ALLOW_NET_DONE) || (state == ACLS_DENY_NET_DONE))) {
      
      k = p; i = 0;				/* save start of verb */
      while ((*p != '\0') &&
	     (!isspace(*p = tolower(*p)))) {
	p++; i++;
      };
      
      if (*p != '\0') {
	*p++ = '\0';
      }

      if (strcmp(k,"netmask") == 0) {
	state = state + ACLD_NET_MASK;
      }

      if ((state == ACLS_ALLOW_NET_DONE) || (state == ACLS_DENY_NET_DONE)) {
	state = ACLE_NONETMASK;
      }
      
    }

    /* State 14 & 15: allow/deny net netmask line */

    if ((*p != '\0') &&
	((state == ACLS_ALLOW_NET_MASK) || (state == ACLS_DENY_NET_MASK))) {
      
      k = p; i = 0;				/* save start of verb */
      while ((*p != '\0') &&
	     (!isspace(*p = tolower(*p)))) {
	p++; i++;
      };
      
      if (*p != '\0') {
	*p++ = '\0';
      }

      if ((state == ACLS_ALLOW_NET_MASK) || (state == ACLS_DENY_NET_MASK)) {
	if ((*k >= '0') && (*k <= '9')) {
	  (void)inet_aton(k,&mask);
	  state = state + ACLD_NET_EOL;
        } else {
	  net = getnetbyname(k);
	  if (net == NULL) {
	    state = ACLE_NONET;
	  } else {
	    mask.s_addr = ntohl(net->n_net);
	    state = state + ACLD_NET_EOL;
	  }
a425 62
      }

    }

    if ((state == ACLS_ALLOW_NET_MASK) || (state == ACLS_DENY_NET_MASK)) {
      state = ACLE_UEOL;
    }

    /* State 16 & 17: allow/deny host line */

    if ((*p == '\0') &&
	((state == ACLS_ALLOW_NET_EOL) || (state == ACLS_DENY_NET_EOL))) {
      acl_add_net(allow,&addr,&mask);
      state = ACLE_OK;
    }
      
    switch (state) {
    case  ACLE_NONETMASK:
      fprintf(stderr,"acl: excpected \"netmask\" missing at line %d\n",line_no);
      break;
    case  ACLE_NONET:
      error_cnt++;
      fprintf(stderr,"acl: unknown network at line %d\n",line_no);
      break;
    case  ACLE_NOHOST:
      error_cnt++;
      fprintf(stderr,"acl: unknown host at line %d\n",line_no);
      break;
    case  ACLE_UVERB:
      error_cnt++;
      fprintf(stderr,"acl: unknown verb at line %d\n",line_no);
      break;
    case ACLE_U2VERB:
      error_cnt++;
      fprintf(stderr,"acl: unknown secondary verb at line %d\n",line_no);
      break;
    case ACLE_UEOL:
      error_cnt++;
      fprintf(stderr,"acl: unexpected end of line at line %d\n",line_no);
      break;
    case ACLE_OK:
      break;
    default:
      error_cnt++;
      fprintf(stderr,"acl: unexpected state %d %s\n",state,k);
    }

  }

  if (data_file != NULL) {
    (void)fflush(stderr);
    (void)fclose(data_file);
  }

  /* Always add a last allow all if file don't exists or */
  /* the file doesn't cover all cases.                   */
  
  addr.s_addr = mask.s_addr = 0;
  allow = TRUE;
  acl_add_net(allow,&addr,&mask);

  return(error_cnt);
d427 6
d439 118
a556 66
  char	 data_line[1024];
  int	 line_no = 0;
  int	 len,i;
  int	 allow = TRUE;
  int	 error_cnt = 0;
  char	*p,*k;
  int	 state;
  struct in_addr addr,mask;
  struct netent  *net;
  FILE  *data_file = NULL;
  
  if (file != NULL) {
    data_file = fopen(file,"r");
  };

  /* Always add a localhost allow first, to be compatable with sun */
  
  addr.s_addr = htonl(0x7f000001);
  mask.s_addr = htonl(0xffffffff);
  allow = TRUE;
  acl_add_net(allow,&addr,&mask);

  while ((data_file != NULL) &&
	 (acl_read_line(data_file,data_line,sizeof(data_line)))) {
    
    line_no++;
    
    len = strlen(data_line);
    if (len == 0) {
      continue;
    }

    p = (char *) &data_line;

    /* State 1: Initial State */

    state = ACLS_INIT;
    addr.s_addr = mask.s_addr = 0;

    k = p; i = 0;				/* save start of verb */
    while ((*p != '\0') &&
	   (!isspace(*p = tolower(*p)))) {
      p++; i++;
    };
    
    if (*p != '\0') {
      *p++ = '\0';
      state = ACLS_ALLOW_NET_MASK;
    }
    
    if (state == ACLS_INIT) {
      state = ACLE_UEOL;
    }

    if (state == ACLS_ALLOW_NET_MASK) {
      
      if ((*k >= '0') && (*k <= '9')) {
	(void)inet_aton(k,&mask);
	state = ACLS_ALLOW_NET;
      } else {
	net = getnetbyname(k);
	if (net == NULL) {
	  state = ACLE_NONET;
	} else {
	  mask.s_addr = ntohl(net->n_net);
	  state = ACLS_ALLOW_NET;
d558 9
a566 29
      }
      
      k = p; i = 0;				/* save start of verb */
      while ((*p != '\0') &&
	     (!isspace(*p = tolower(*p)))) {
	p++; i++;
      };
      
      if (*p != '\0') {
	*p++ = '\0';
      }
    }
    
    if ((state == ACLS_ALLOW_NET_MASK)) {
      state = ACLE_UEOL;
    }

    if (state == ACLS_ALLOW_NET) {
      
      if ((*k >= '0') && (*k <= '9')) {
	(void)inet_aton(k,&addr);
	state = ACLS_ALLOW_NET_EOL;
      } else {
	net = getnetbyname(k);
	if (net == NULL) {
	  state = ACLE_NONET;
	} else {
	  addr.s_addr = ntohl(net->n_net);
	  state = ACLS_ALLOW_NET_EOL;
a567 49
      }
    }
      
    if ((state == ACLS_ALLOW_NET)) {
      state = ACLE_UEOL;
    }

    if ((*p == '\0') &&	(state == ACLS_ALLOW_NET_EOL)) {
      acl_add_net(allow,&addr,&mask);
      state = ACLE_OK;
    }
      
    switch (state) {
    case  ACLE_NONET:
      error_cnt++;
      fprintf(stderr,"securenet: unknown network at line %d\n",line_no);
      break;
    case ACLE_UEOL:
      error_cnt++;
      fprintf(stderr,"securenet: unexpected end of line at line %d\n",line_no);
      break;
    case ACLE_OK:
      break;
    default:
      error_cnt++;
      fprintf(stderr,"securenet: unexpected state %d %s\n",state,k);
    }

  }

  if (data_file != NULL) {
    (void)fflush(stderr);
    (void)fclose(data_file);
    
    /* Always add a last deny all if file exists */
    
    addr.s_addr = mask.s_addr = 0;
    allow = FALSE;
    acl_add_net(allow,&addr,&mask);

  }

  /* Always add a last allow all if file don't exists */
  
  addr.s_addr = mask.s_addr = 0;
  allow = TRUE;
  acl_add_net(allow,&addr,&mask);

  return(error_cnt);
d569 6
@


1.5
log
@When using /var/yp/securenet the local host running ypserv wasn't garanteed
access to ypserv. This has been fixed by always allowing the host 127.0.0.1
access when using /var/yp/securenet. This to keep compability with SunOS.

When using the ypserv.acl(5) format access must be granted to 127.0.0.1 in
the file. This to make it possible to disallow access to ypserv from the
host running it. This has been documented in man page and example.

Thanks to <Ulrich.Flegel@@braunschweig.netsurf.de> for bringing this to
my attention (again). -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.4 1996/06/30 19:46:04 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: acl.c,v 1.4 1996/06/30 19:46:04 maja Exp $";
d45 1
@


1.4
log
@Added support for SIGHUP in ypserv for reread of /var/yp/securenet or
aclfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.3 1996/06/26 21:26:36 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: acl.c,v 1.3 1996/06/26 21:26:36 maja Exp $";
d473 7
@


1.3
log
@Same copyright all over, removed my name from ypdb.[ch], small bugfix
in ypserv_db.c /moj
@
text
@d1 1
a1 1
/*	$OpenBSD: acl.c,v 1.2 1996/05/30 09:53:24 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: acl.c,v 1.2 1996/05/30 09:53:24 deraadt Exp $";
d601 11
@


1.2
log
@$OpenBSD$ tag and few spelling errors
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d15 5
a19 3
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
d35 1
a35 1
static char rcsid[] = "$OpenBSD$";
@


1.1
log
@+ full set of ypserv tools that compile
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: acl.c,v 1.2 1994/07/02 16:43:04 moj Exp $";
@
