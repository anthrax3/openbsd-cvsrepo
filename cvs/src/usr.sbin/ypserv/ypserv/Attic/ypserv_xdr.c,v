head	1.7;
access;
symbols
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.3.0.22
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.7
date	2003.02.13.06.07.41;	author maja;	state dead;
branches;
next	1.6;

1.6
date	2002.01.01.21.10.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.05.10.02.37;	author deraadt;	state dead;
branches;
next	1.4;

1.4
date	2001.11.19.09.03.07;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.30.09.53.31;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.20.02.53.22;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	95.11.01.16.56.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.7
log
@This files are not used anymore since librpcsvc is fixed. -moj
@
text
@/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "yp.h"
#ifndef lint
static char rcsid[] = "$OpenBSD: ypserv_xdr.c,v 1.6 2002/01/01 21:10:59 deraadt Exp $";
#endif /* not lint */

bool_t
xdr_ypstat(xdrs, objp)
	XDR *xdrs;
	ypstat *objp;
{
	int32_t *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypxfrstat(xdrs, objp)
	XDR *xdrs;
	ypxfrstat *objp;
{
	int32_t *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_domainname(xdrs, objp)
	XDR *xdrs;
	domainname *objp;
{
	int32_t *buf;

	if (!xdr_string(xdrs, objp, YPMAXDOMAIN)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_mapname(xdrs, objp)
	XDR *xdrs;
	mapname *objp;
{
	int32_t *buf;

	if (!xdr_string(xdrs, objp, YPMAXMAP)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_peername(xdrs, objp)
	XDR *xdrs;
	peername *objp;
{
	int32_t *buf;

	if (!xdr_string(xdrs, objp, YPMAXPEER)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_keydat(xdrs, objp)
	XDR *xdrs;
	keydat *objp;
{
	int32_t *buf;

	if (!xdr_bytes(xdrs, (char **)&objp->keydat_val, (u_int *)&objp->keydat_len, YPMAXRECORD)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_valdat(xdrs, objp)
	XDR *xdrs;
	valdat *objp;
{
	int32_t *buf;

	if (!xdr_bytes(xdrs, (char **)&objp->valdat_val, (u_int *)&objp->valdat_len, YPMAXRECORD)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypmap_parms(xdrs, objp)
	XDR *xdrs;
	ypmap_parms *objp;
{
	int32_t *buf;

	if (!xdr_domainname(xdrs, &objp->domain)) {
		return (FALSE);
	}
	if (!xdr_mapname(xdrs, &objp->map)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->ordernum)) {
		return (FALSE);
	}
	if (!xdr_peername(xdrs, &objp->peer)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypreq_key(xdrs, objp)
	XDR *xdrs;
	ypreq_key *objp;
{
	int32_t *buf;

	if (!xdr_domainname(xdrs, &objp->domain)) {
		return (FALSE);
	}
	if (!xdr_mapname(xdrs, &objp->map)) {
		return (FALSE);
	}
	if (!xdr_keydat(xdrs, &objp->key)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypreq_nokey(xdrs, objp)
	XDR *xdrs;
	ypreq_nokey *objp;
{
	int32_t *buf;

	if (!xdr_domainname(xdrs, &objp->domain)) {
		return (FALSE);
	}
	if (!xdr_mapname(xdrs, &objp->map)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypreq_xfr(xdrs, objp)
	XDR *xdrs;
	ypreq_xfr *objp;
{
	int32_t *buf;

	if (!xdr_ypmap_parms(xdrs, &objp->map_parms)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->transid)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->prog)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->port)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypresp_val(xdrs, objp)
	XDR *xdrs;
	ypresp_val *objp;
{
	int32_t *buf;

	if (!xdr_ypstat(xdrs, &objp->stat)) {
		return (FALSE);
	}
	if (!xdr_valdat(xdrs, &objp->val)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypresp_key_val(xdrs, objp)
	XDR *xdrs;
	ypresp_key_val *objp;
{
	int32_t *buf;

	if (!xdr_ypstat(xdrs, &objp->stat)) {
		return (FALSE);
	}
	if (!xdr_valdat(xdrs, &objp->val)) {
		return (FALSE);
	}
	if (!xdr_keydat(xdrs, &objp->key)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypresp_master(xdrs, objp)
	XDR *xdrs;
	ypresp_master *objp;
{
	int32_t *buf;

	if (!xdr_ypstat(xdrs, &objp->stat)) {
		return (FALSE);
	}
	if (!xdr_peername(xdrs, &objp->peer)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypresp_order(xdrs, objp)
	XDR *xdrs;
	ypresp_order *objp;
{
	int32_t *buf;

	if (!xdr_ypstat(xdrs, &objp->stat)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->ordernum)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypresp_all(xdrs, objp)
	XDR *xdrs;
	ypresp_all *objp;
{
	int32_t *buf;

	if (!xdr_bool(xdrs, &objp->more)) {
		return (FALSE);
	}
	switch (objp->more) {
	case TRUE:
		if (!xdr_ypresp_key_val(xdrs, &objp->ypresp_all_u.val)) {
			return (FALSE);
		}
		break;
	case FALSE:
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypresp_xfr(xdrs, objp)
	XDR *xdrs;
	ypresp_xfr *objp;
{
	int32_t *buf;

	if (!xdr_u_int(xdrs, &objp->transid)) {
		return (FALSE);
	}
	if (!xdr_ypxfrstat(xdrs, &objp->xfrstat)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypmaplist(xdrs, objp)
	XDR *xdrs;
	ypmaplist *objp;
{
	int32_t *buf;

	if (!xdr_mapname(xdrs, &objp->map)) {
		return (FALSE);
	}
	if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof(ypmaplist), (xdrproc_t)xdr_ypmaplist)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypresp_maplist(xdrs, objp)
	XDR *xdrs;
	ypresp_maplist *objp;
{
	int32_t *buf;

	if (!xdr_ypstat(xdrs, &objp->stat)) {
		return (FALSE);
	}
	if (!xdr_pointer(xdrs, (char **)&objp->maps, sizeof(ypmaplist), (xdrproc_t)xdr_ypmaplist)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_yppush_status(xdrs, objp)
	XDR *xdrs;
	yppush_status *objp;
{
	int32_t *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_yppushresp_xfr(xdrs, objp)
	XDR *xdrs;
	yppushresp_xfr *objp;
{
	int32_t *buf;

	if (!xdr_u_int(xdrs, &objp->transid)) {
		return (FALSE);
	}
	if (!xdr_yppush_status(xdrs, &objp->status)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypbind_resptype(xdrs, objp)
	XDR *xdrs;
	ypbind_resptype *objp;
{
	int32_t *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypbind_binding(xdrs, objp)
	XDR *xdrs;
	ypbind_binding *objp;
{
	int32_t *buf;

	if (!xdr_opaque(xdrs, objp->ypbind_binding_addr, 4)) {
		return (FALSE);
	}
	if (!xdr_opaque(xdrs, objp->ypbind_binding_port, 2)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypbind_resp(xdrs, objp)
	XDR *xdrs;
	ypbind_resp *objp;
{
	int32_t *buf;

	if (!xdr_ypbind_resptype(xdrs, &objp->ypbind_status)) {
		return (FALSE);
	}
	switch (objp->ypbind_status) {
	case YPBIND_FAIL_VAL:
		if (!xdr_u_int(xdrs, &objp->ypbind_resp_u.ypbind_error)) {
			return (FALSE);
		}
		break;
	case YPBIND_SUCC_VAL:
		if (!xdr_ypbind_binding(xdrs, &objp->ypbind_resp_u.ypbind_bindinfo)) {
			return (FALSE);
		}
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ypbind_setdom(xdrs, objp)
	XDR *xdrs;
	ypbind_setdom *objp;
{
	int32_t *buf;

	if (!xdr_domainname(xdrs, &objp->ypsetdom_domain)) {
		return (FALSE);
	}
	if (!xdr_ypbind_binding(xdrs, &objp->ypsetdom_binding)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->ypsetdom_vers)) {
		return (FALSE);
	}
	return (TRUE);
}
@


1.6
log
@go back to the swapped xdr_ypresp_key_val for now
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: ypserv_xdr.c,v 1.4 2001/11/19 09:03:07 deraadt Exp $";
@


1.5
log
@this stuff is supplied by -lrpcsvc
@
text
@d16 1
a16 2

	register long *buf;
d29 1
a29 2

	register long *buf;
d42 1
a42 2

	register long *buf;
d55 1
a55 2

	register long *buf;
d68 1
a68 2

	register long *buf;
d81 1
a81 2

	register long *buf;
d94 1
a94 2

	register long *buf;
d107 1
a107 2

	register long *buf;
d129 1
a129 2

	register long *buf;
d148 1
a148 2

	register long *buf;
d164 1
a164 2

	register long *buf;
d186 1
a186 2

	register long *buf;
d202 1
a202 2

	register long *buf;
d221 1
a221 2

	register long *buf;
d237 1
a237 2

	register long *buf;
d253 1
a253 2

	register long *buf;
d277 1
a277 2

	register long *buf;
d293 1
a293 2

	register long *buf;
d309 1
a309 2

	register long *buf;
d325 1
a325 2

	register long *buf;
d338 1
a338 2

	register long *buf;
d354 1
a354 2

	register long *buf;
d367 1
a367 2

	register long *buf;
d383 1
a383 2

	register long *buf;
d410 1
a410 2

	register long *buf;
@


1.4
log
@use a private svc_run() function that checks for a signal handler flag;
now signal safe.  Also, massive KNF.
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD: ypserv_xdr.c,v 1.3 1996/05/30 09:53:31 deraadt Exp $";
@


1.3
log
@$OpenBSD$ tag and few spelling errors
@
text
@d8 1
a8 1
static char rcsid[] = "$OpenBSD$";
d17 1
a17 1
	 register long *buf;
d19 3
a21 3
	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
d31 1
a31 1
	 register long *buf;
d33 3
a35 3
	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
d45 1
a45 1
	 register long *buf;
d47 3
a49 3
	 if (!xdr_string(xdrs, objp, YPMAXDOMAIN)) {
		 return (FALSE);
	 }
d59 1
a59 1
	 register long *buf;
d61 3
a63 3
	 if (!xdr_string(xdrs, objp, YPMAXMAP)) {
		 return (FALSE);
	 }
d73 1
a73 1
	 register long *buf;
d75 3
a77 3
	 if (!xdr_string(xdrs, objp, YPMAXPEER)) {
		 return (FALSE);
	 }
d87 1
a87 1
	 register long *buf;
d89 3
a91 3
	 if (!xdr_bytes(xdrs, (char **)&objp->keydat_val, (u_int *)&objp->keydat_len, YPMAXRECORD)) {
		 return (FALSE);
	 }
d101 1
a101 1
	 register long *buf;
d103 3
a105 3
	 if (!xdr_bytes(xdrs, (char **)&objp->valdat_val, (u_int *)&objp->valdat_len, YPMAXRECORD)) {
		 return (FALSE);
	 }
d115 1
a115 1
	 register long *buf;
d117 12
a128 12
	 if (!xdr_domainname(xdrs, &objp->domain)) {
		 return (FALSE);
	 }
	 if (!xdr_mapname(xdrs, &objp->map)) {
		 return (FALSE);
	 }
	 if (!xdr_u_int(xdrs, &objp->ordernum)) {
		 return (FALSE);
	 }
	 if (!xdr_peername(xdrs, &objp->peer)) {
		 return (FALSE);
	 }
d138 1
a138 1
	 register long *buf;
d140 9
a148 9
	 if (!xdr_domainname(xdrs, &objp->domain)) {
		 return (FALSE);
	 }
	 if (!xdr_mapname(xdrs, &objp->map)) {
		 return (FALSE);
	 }
	 if (!xdr_keydat(xdrs, &objp->key)) {
		 return (FALSE);
	 }
d158 1
a158 1
	 register long *buf;
d160 6
a165 6
	 if (!xdr_domainname(xdrs, &objp->domain)) {
		 return (FALSE);
	 }
	 if (!xdr_mapname(xdrs, &objp->map)) {
		 return (FALSE);
	 }
d175 1
a175 1
	 register long *buf;
d177 12
a188 12
	 if (!xdr_ypmap_parms(xdrs, &objp->map_parms)) {
		 return (FALSE);
	 }
	 if (!xdr_u_int(xdrs, &objp->transid)) {
		 return (FALSE);
	 }
	 if (!xdr_u_int(xdrs, &objp->prog)) {
		 return (FALSE);
	 }
	 if (!xdr_u_int(xdrs, &objp->port)) {
		 return (FALSE);
	 }
d198 1
a198 1
	 register long *buf;
d200 6
a205 6
	 if (!xdr_ypstat(xdrs, &objp->stat)) {
		 return (FALSE);
	 }
	 if (!xdr_valdat(xdrs, &objp->val)) {
		 return (FALSE);
	 }
d215 1
a215 1
	 register long *buf;
d217 9
a225 9
	 if (!xdr_ypstat(xdrs, &objp->stat)) {
		 return (FALSE);
	 }
	 if (!xdr_valdat(xdrs, &objp->val)) {
		 return (FALSE);
	 }
	 if (!xdr_keydat(xdrs, &objp->key)) {
		 return (FALSE);
	 }
d235 1
a235 1
	 register long *buf;
d237 6
a242 6
	 if (!xdr_ypstat(xdrs, &objp->stat)) {
		 return (FALSE);
	 }
	 if (!xdr_peername(xdrs, &objp->peer)) {
		 return (FALSE);
	 }
d252 1
a252 1
	 register long *buf;
d254 6
a259 6
	 if (!xdr_ypstat(xdrs, &objp->stat)) {
		 return (FALSE);
	 }
	 if (!xdr_u_int(xdrs, &objp->ordernum)) {
		 return (FALSE);
	 }
d269 1
a269 1
	 register long *buf;
d271 3
a273 3
	 if (!xdr_bool(xdrs, &objp->more)) {
		 return (FALSE);
	 }
d276 3
a278 3
		 if (!xdr_ypresp_key_val(xdrs, &objp->ypresp_all_u.val)) {
			 return (FALSE);
		 }
d294 1
a294 1
	 register long *buf;
d296 6
a301 6
	 if (!xdr_u_int(xdrs, &objp->transid)) {
		 return (FALSE);
	 }
	 if (!xdr_ypxfrstat(xdrs, &objp->xfrstat)) {
		 return (FALSE);
	 }
d311 1
a311 1
	 register long *buf;
d313 6
a318 6
	 if (!xdr_mapname(xdrs, &objp->map)) {
		 return (FALSE);
	 }
	 if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof(ypmaplist), (xdrproc_t)xdr_ypmaplist)) {
		 return (FALSE);
	 }
d328 1
a328 1
	 register long *buf;
d330 6
a335 6
	 if (!xdr_ypstat(xdrs, &objp->stat)) {
		 return (FALSE);
	 }
	 if (!xdr_pointer(xdrs, (char **)&objp->maps, sizeof(ypmaplist), (xdrproc_t)xdr_ypmaplist)) {
		 return (FALSE);
	 }
d345 1
a345 1
	 register long *buf;
d347 3
a349 3
	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
d359 1
a359 1
	 register long *buf;
d361 6
a366 6
	 if (!xdr_u_int(xdrs, &objp->transid)) {
		 return (FALSE);
	 }
	 if (!xdr_yppush_status(xdrs, &objp->status)) {
		 return (FALSE);
	 }
d376 1
a376 1
	 register long *buf;
d378 3
a380 3
	 if (!xdr_enum(xdrs, (enum_t *)objp)) {
		 return (FALSE);
	 }
d390 1
a390 1
	 register long *buf;
d392 6
a397 7
	 int i;
	 if (!xdr_opaque(xdrs, objp->ypbind_binding_addr, 4)) {
		 return (FALSE);
	 }
	 if (!xdr_opaque(xdrs, objp->ypbind_binding_port, 2)) {
		 return (FALSE);
	 }
d407 1
a407 1
	 register long *buf;
d409 3
a411 3
	 if (!xdr_ypbind_resptype(xdrs, &objp->ypbind_status)) {
		 return (FALSE);
	 }
d414 3
a416 3
		 if (!xdr_u_int(xdrs, &objp->ypbind_resp_u.ypbind_error)) {
			 return (FALSE);
		 }
d419 3
a421 3
		 if (!xdr_ypbind_binding(xdrs, &objp->ypbind_resp_u.ypbind_bindinfo)) {
			 return (FALSE);
		 }
d435 1
a435 1
	 register long *buf;
d437 9
a445 9
	 if (!xdr_domainname(xdrs, &objp->ypsetdom_domain)) {
		 return (FALSE);
	 }
	 if (!xdr_ypbind_binding(xdrs, &objp->ypsetdom_binding)) {
		 return (FALSE);
	 }
	 if (!xdr_u_int(xdrs, &objp->ypsetdom_vers)) {
		 return (FALSE);
	 }
@


1.2
log
@ypserv_xdr, as generated by rpcgen from yp.x with one major exception.
in xdr_ypresp_key_val() invert the order of loading the key and value
(rpcgen says [1] stat, [2] key, [3] value, but the data on the wire
 comes in as [1] stat, [2] val, [3] key...  you can't fix this in yp.x
 because if you invert the ordr in yp.x not only does it invert the order
 in ypserv_xdr.c, but it also inverts it in the structure in yp.h which
 cancels out the inversion in ypserv_xdr.c.   i guess this means it
 is not possible to have a yp.x that descrives the YP protocol properly?).

***NOTE*** this file is also needed because some of the YP functions in
libc are broken.   For example, compare src/lib/libc/yp/xdryp.c's version
of xdr_domainname() to the one in this file generated by rpcgen.  Note
that xdryp.c calls:
	 if (!xdr_string(xdrs, &objp, YPMAXDOMAIN)) { /* xdryp.c */
while ypserv_xdr.c (generated by rpcgen) calls:
	 if (!xdr_string(xdrs, objp, YPMAXDOMAIN)) { /* rpcgen */
(note the lack of "&" in the second line).   Clearly libc is wrong and
needs to be fixed (XXX).    (Of course changing libc could break other
YP stuff, which is why I haven't attemped it... :) )    When libc is
fixed, it should be possible to phase out this file, I think.
@
text
@d8 1
a8 2
/*static char sccsid[] = "from: @@(#)yp.x	2.1 88/08/01 4.0 RPCSRC";*/
static char rcsid[] = "$Id: yp.x,v 1.1 1995/01/12 19:40:00 jtc Exp $";
@


1.1
log
@+ full set of ypserv tools that compile
@
text
@d2 2
a3 26
 * Copyright (c) 1994 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d6 5
a10 3
#ifndef LINT
static char rcsid[] = "$Id: ypserv_xdr.c,v 1.0 1994/05/23 23:09:00 moj Exp $";
#endif
d12 97
a108 2
#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
d115 52
a166 12
	if (!xdr_domainname(xdrs, &objp->domain)) {
		return (FALSE);
	}
	if (!xdr_mapname(xdrs, &objp->map)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->ordernum)) {
		return (FALSE);
	}
	if (!xdr_peername(xdrs, &objp->peer)) {
		return (FALSE);
	}
d175 109
a283 1
	if (!xdr_ypmap_parms(xdrs, &objp->map_parms)) {
d286 140
a425 7
	if (!xdr_u_int(xdrs, &objp->transid)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->prog)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->port)) {
d428 20
@
