head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.10
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.12
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.8
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.4
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.16
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.14
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.12
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.10
	OPENBSD_5_0:1.27.0.8
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.6
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.26.0.14
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.10
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.8
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.6
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.4
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.24.0.4
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.8
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.6
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.14
	OPENBSD_2_8:1.15.0.12
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.10
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.15.0.8
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.6
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.4
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.29
date	2015.01.16.06.40.23;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Uu5nFG3wCl0LACBb;

1.28
date	2014.02.24.06.45.56;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.27.23.59.58;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.09.25.05.59.28;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.03.05.01.24;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.14.02.32.33;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.22.23.57.07;	author maja;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.21.58.27;	author maja;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.05.08.37.05;	author avsm;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.13.05.54.39;	author maja;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.19.09.03.07;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.09.07.05.06;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.01.08.22.36.48;	author maja;	state Exp;
branches;
next	1.14;

1.14
date	97.09.12.01.44.57;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.06.02.19.50.42;	author dm;	state Exp;
branches;
next	1.12;

1.12
date	97.04.12.16.38.06;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.04.12.00.12.57;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.03.30.20.51.21;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	97.03.11.09.12.27;	author maja;	state Exp;
branches;
next	1.8;

1.8
date	96.10.03.19.50.57;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.09.30.21.03.56;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.09.30.20.50.24;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.08.15.21.47.30;	author chuck;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.21.26.39;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.05.30.09.53.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.20.02.42.19;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	95.11.01.16.56.37;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: ypserv_proc.c,v 1.28 2014/02/24 06:45:56 jsg Exp $ */

/*
 * Copyright (c) 1994 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include "ypv1.h"
#include <rpcsvc/ypclnt.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include "ypdb.h"
#include "acl.h"
#include <fcntl.h>
#include <dirent.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include "yplog.h"
#include "ypdef.h"
#include "ypserv.h"

#ifdef DEBUG
#define YPLOG yplog
#else /* DEBUG */
#define YPLOG if (!ok) yplog
#endif /* DEBUG */

static char *True = "true";
static char *False = "FALSE";
#define TORF(N) ((N) ? True : False)

/*ARGSUSED*/
void *
ypproc_null_2_svc(void *argp, struct svc_req *rqstp)
{
	static char *result;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);

	YPLOG("null_2: caller=[%s].%d, auth_ok=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok));

	if (!ok) {
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	result = NULL;
	return ((void *)&result);
}

bool_t *
ypproc_domain_2_svc(domainname *argp, struct svc_req *rqstp)
{
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	static char domain_path[PATH_MAX];
	static bool_t result;
	struct stat finfo;

	if (strchr(*argp, '/'))
		goto bail;
	snprintf(domain_path, sizeof(domain_path), "%s/%s", YP_DB_PATH, *argp);
	result = (bool_t) ((stat(domain_path, &finfo) == 0) &&
	    S_ISDIR(finfo.st_mode));

	YPLOG("domain_2: caller=[%s].%d, auth_ok=%s, domain=%s, served=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	    TORF(ok), *argp, TORF(result));

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}
	return (&result);
}

bool_t *
ypproc_domain_nonack_2_svc(domainname *argp, struct svc_req *rqstp)
{
	static bool_t result; /* is domain served? */
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	static char domain_path[PATH_MAX];
	struct stat finfo;

	if (strchr(*argp, '/'))
		goto bail;
	snprintf(domain_path, sizeof(domain_path), "%s/%s", YP_DB_PATH, *argp);
	result = (bool_t) ((stat(domain_path, &finfo) == 0) &&
	    S_ISDIR(finfo.st_mode));

	YPLOG("domain_nonack_2: caller=[%s].%d, auth_ok=%s, domain=%s, served=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok),
	    *argp, TORF(result));

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (!result)
		return(NULL); /* don't send nack */
	return (&result);
}

ypresp_val *
ypproc_match_2_svc(ypreq_key *argp, struct svc_req *rqstp)
{
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure = ypdb_secure(argp->domain, argp->map);
	static ypresp_val res;

	if (strchr(argp->domain, '/') || strchr(argp->map, '/'))
		goto bail;
	YPLOG("match_2: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s, key=%.*s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	    TORF(ok), TORF(secure),
	    argp->domain, argp->map, argp->key.keydat_len, argp->key.keydat_val);

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (secure && (ntohs(caller->sin_port) >= IPPORT_RESERVED)) {
		res.stat = YP_YPERR;
	} else {
		res = ypdb_get_record(argp->domain, argp->map, argp->key, TRUE);
	}

#ifdef DEBUG
	yplog("  match2_status: %s", yperr_string(ypprot_err(res.stat)));
#endif
	return (&res);
}

ypresp_key_val *
ypproc_first_2_svc(ypreq_nokey *argp, struct svc_req *rqstp)
{
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure = ypdb_secure(argp->domain, argp->map);
	static ypresp_key_val res;

	if (strchr(argp->domain, '/') || strchr(argp->map, '/'))
		goto bail;
	YPLOG( "first_2: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	    TORF(ok), TORF(secure), argp->domain, argp->map);
	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (secure && (ntohs(caller->sin_port) >= IPPORT_RESERVED)) {
		res.stat = YP_YPERR;
	} else {
		res = ypdb_get_first(argp->domain, argp->map,FALSE);
	}

#ifdef DEBUG
	yplog("  first2_status: %s", yperr_string(ypprot_err(res.stat)));
#endif
	return (&res);
}

ypresp_key_val *
ypproc_next_2_svc(ypreq_key *argp, struct svc_req *rqstp)
{
	static ypresp_key_val res;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure = ypdb_secure(argp->domain, argp->map);

	if (strchr(argp->domain, '/') || strchr(argp->map, '/'))
		goto bail;
	YPLOG("next_2: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s, key=%.*s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	    TORF(ok), TORF(secure),
	    argp->domain, argp->map, argp->key.keydat_len, argp->key.keydat_val);

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (secure && (ntohs(caller->sin_port) >= IPPORT_RESERVED)) {
		res.stat = YP_YPERR;
	} else {
		res = ypdb_get_next(argp->domain, argp->map, argp->key,FALSE);
	}

#ifdef DEBUG
	yplog("  next2_status: %s", yperr_string(ypprot_err(res.stat)));
#endif
	return (&res);
}

ypresp_xfr *
ypproc_xfr_2_svc(ypreq_xfr *argp, struct svc_req *rqstp)
{
	static ypresp_xfr res;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	pid_t	pid;
	char	tid[11], prog[11], port[11];
	char	ypxfr_proc[] = YPXFR_PROC, *ipadd;

	bzero(&res, sizeof(res));

	YPLOG("xfr_2: caller=[%s].%d, auth_ok=%s, domain=%s, tid=%d, prog=%d",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok),
	    argp->map_parms.domain, argp->transid, argp->prog);
	YPLOG("       ipadd=%s, port=%d, map=%s", inet_ntoa(caller->sin_addr),
	    argp->port, argp->map_parms.map);

	if (strchr(argp->map_parms.domain, '/') ||
	    strchr(argp->map_parms.map, '/') ||
	    ntohs(caller->sin_port) >= IPPORT_RESERVED) {
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	snprintf(tid, sizeof(tid), "%d", argp->transid);
	snprintf(prog, sizeof(prog), "%d", argp->prog);
	snprintf(port, sizeof(port), "%d", argp->port);
	ipadd = inet_ntoa(caller->sin_addr);

	pid = vfork();
	if (pid == -1) {
		svcerr_systemerr(rqstp->rq_xprt);
		return(NULL);
	}
	if (pid == 0) {
		execl(ypxfr_proc, "ypxfr", "-d", argp->map_parms.domain,
		    "-C", tid, prog, ipadd, port, argp->map_parms.map, (char *)NULL);
		_exit(1);
	}
	/*
	 * XXX: fill in res
	 */
	return (&res);
}

/*ARGSUSED*/
void *
ypproc_clear_2_svc(void *argp, struct svc_req *rqstp)
{
	static char *res;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);

	YPLOG( "clear_2: caller=[%s].%d, auth_ok=%s, opt=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok),
#ifdef OPTDB
		True
#else
		False
#endif
	);

	if (ntohs(caller->sin_port) >= IPPORT_RESERVED)
		ok = FALSE;

	if (!ok) {
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	res = NULL;

#ifdef OPTDB
	ypdb_close_all();
#endif
	return ((void *)&res);
}

ypresp_all *
ypproc_all_2_svc(ypreq_nokey *argp, struct svc_req *rqstp)
{
	static ypresp_all res;
	pid_t pid;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure = ypdb_secure(argp->domain, argp->map);

	if (strchr(argp->domain, '/') || strchr(argp->map, '/'))
		goto bail;
	YPLOG( "all_2: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	    TORF(ok), TORF(secure), argp->domain, argp->map);

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}
	bzero(&res, sizeof(res));

	if (secure && (ntohs(caller->sin_port) >= IPPORT_RESERVED)) {
		res.ypresp_all_u.val.stat = YP_YPERR;
		return(&res);
	}

	pid = fork();
	if (pid) {
		if (pid == -1) {
			/* XXXCDC An error has occurred */
		}
		return(NULL); /* PARENT: continue */
	}
	/* CHILD: send result, then exit */

	if (!svc_sendreply(rqstp->rq_xprt, ypdb_xdr_get_all, (char *)argp)) {
		svcerr_systemerr(rqstp->rq_xprt);
	}
	exit(0);
}

ypresp_master *
ypproc_master_2_svc(ypreq_nokey *argp, struct svc_req *rqstp)
{
	static ypresp_master res;
	static peername nopeer = "";
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure = ypdb_secure(argp->domain, argp->map);

	if (strchr(argp->domain, '/') || strchr(argp->map, '/'))
		goto bail;
	YPLOG( "master_2: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	    TORF(ok), TORF(secure), argp->domain, argp->map);

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (secure && (ntohs(caller->sin_port) >= IPPORT_RESERVED)) {
		res.stat = YP_YPERR;
	} else {
		res = ypdb_get_master(argp->domain, argp->map);
	}

#ifdef DEBUG
	yplog("  master2_status: %s", yperr_string(ypprot_err(res.stat)));
#endif

	/*
	 * This code was added because a yppoll <unknown-domain>
	 * from a sun crashed the server in xdr_string, trying
	 * to access the peer through a NULL-pointer. yppoll in
	 * this server start asking for order. If order is ok
	 * then it will ask for master. SunOS 4 asks for both
	 * always. I'm not sure this is the best place for the
	 * fix, but for now it will do. xdr_peername or
	 * xdr_string in ypserv_xdr.c may be a better place?
	 */
	if (res.peer == NULL)
		res.peer = nopeer;
	return (&res);
}


ypresp_order *
ypproc_order_2_svc(ypreq_nokey *argp, struct svc_req *rqstp)
{
	static ypresp_order res;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure = ypdb_secure(argp->domain, argp->map);

	if (strchr(argp->domain, '/'))
		goto bail;
	YPLOG( "order_2: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	    TORF(ok), TORF(secure), argp->domain, argp->map);

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (secure && (ntohs(caller->sin_port) >= IPPORT_RESERVED)) {
		res.stat = YP_YPERR;
	} else if (strchr(argp->map, '/')) {
		res.stat = YP_NOMAP;
	} else {
		res = ypdb_get_order(argp->domain, argp->map);
	}

#ifdef DEBUG
	yplog("  order2_status: %s", yperr_string(ypprot_err(res.stat)));
#endif
	return (&res);
}


ypresp_maplist *
ypproc_maplist_2_svc(domainname *argp, struct svc_req *rqstp)
{
	static ypresp_maplist res;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	static char domain_path[PATH_MAX];
	struct stat finfo;
	DIR   *dirp = NULL;
	struct dirent *dp;
	char  *suffix;
	ypstat status;
	struct ypmaplist *m;
	char  *map_name;

	if (strchr(*argp, '/'))
		goto bail;
	YPLOG("maplist_2: caller=[%s].%d, auth_ok=%s, domain=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok),
	    *argp);

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	bzero(&res, sizeof(res));
	snprintf(domain_path, sizeof domain_path, "%s/%s", YP_DB_PATH, *argp);

	status = YP_TRUE;
	res.maps = NULL;

	if (!((stat(domain_path, &finfo) == 0) && S_ISDIR(finfo.st_mode)))
		status = YP_NODOM;

	if (status >= 0) {
		if ((dirp = opendir(domain_path)) == NULL)
			status = YP_NODOM;
	}

	if (status >= 0) {
		for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
			if ((!strcmp(dp->d_name, ".")) ||
			    ((!strcmp(dp->d_name, ".."))) ||
			    (dp->d_namlen < 4))
				continue;
			suffix = (char *) &dp->d_name[dp->d_namlen-3];
			if (strcmp(suffix, ".db") == 0) {
				if ((m = malloc(sizeof(struct ypmaplist))) == NULL) {
					status = YP_YPERR;
					break;
				}

				if ((map_name = malloc(dp->d_namlen - 2)) == NULL) {
					free(m);
					status = YP_YPERR;
					break;
				}

				m->next = res.maps;
				m->map = map_name;
				res.maps = m;
				strncpy(map_name, dp->d_name, dp->d_namlen - 3);
				m->map[dp->d_namlen - 3] = '\0';
			}
		}
	}
	if (dirp != NULL)
		closedir(dirp);

	res.stat = status;
#ifdef DEBUG
	yplog("  maplist_status: %s", yperr_string(ypprot_err(res.stat)));
#endif
	return (&res);
}

/*ARGSUSED*/
void *
ypoldproc_null_1_svc(void *argp, struct svc_req *rqstp)
{
	static char *result;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);

	YPLOG("null_1: caller=[%s].%d, auth_ok=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok));

	if (!ok) {
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	result = NULL;

	return ((void *)&result);
}

bool_t *
ypoldproc_domain_1_svc(domainname *argp, struct svc_req *rqstp)
{
	static bool_t result; /* is domain_served? */
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	static char domain_path[PATH_MAX];
	struct stat finfo;

	if (strchr(*argp, '/'))
		goto bail;
	snprintf(domain_path, sizeof(domain_path), "%s/%s", YP_DB_PATH, *argp);
	result = (bool_t) ((stat(domain_path, &finfo) == 0) &&
				    S_ISDIR(finfo.st_mode));

	YPLOG("domain_1: caller=[%s].%d, auth_ok=%s, domain=%s, served=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	    TORF(ok), *argp, TORF(result));

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	return (&result);
}

bool_t *
ypoldproc_domain_nonack_1_svc(domainname *argp, struct svc_req *rqstp)
{
	static bool_t result; /* is domain served? */
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	static char domain_path[PATH_MAX];
	struct stat finfo;

	if (strchr(*argp, '/'))
		goto bail;
	snprintf(domain_path, sizeof(domain_path), "%s/%s", YP_DB_PATH, *argp);
	result = (bool_t) ((stat(domain_path, &finfo) == 0) &&
				    S_ISDIR(finfo.st_mode));

	YPLOG(
	  "domain_nonack_1: caller=[%s].%d, auth_ok=%s, domain=%s, served=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok),
	  *argp, TORF(result));

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (!result) {
		return(NULL); /* don't send nack */
	}

	return (&result);
}

ypresponse *
ypoldproc_match_1_svc(yprequest *argp, struct svc_req *rqstp)
{
	static ypresponse res;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure;

	if (strchr(argp->ypmatch_req_domain, '/') ||
	    strchr(argp->ypmatch_req_map, '/'))
		goto bail;
	res.yp_resptype = YPMATCH_RESPTYPE;
	res.ypmatch_resp_valptr = "";
	res.ypmatch_resp_valsize = 0;

	if (argp->yp_reqtype != YPMATCH_REQTYPE) {
		res.ypmatch_resp_status = YP_BADARGS;
		return(&res);
	}

	secure = ypdb_secure(argp->ypmatch_req_domain, argp->ypmatch_req_map);

	YPLOG(
	  "match_1: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s, key=%.*s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure),
	  argp->ypmatch_req_domain,  argp->ypmatch_req_map,
	  argp->ypmatch_req_keysize, argp->ypmatch_req_keyptr);

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (secure && (ntohs(caller->sin_port) >= IPPORT_RESERVED)) {
		res.ypmatch_resp_status = YP_YPERR;
	} else {
		res.ypmatch_resp_val = ypdb_get_record(
		    argp->ypmatch_req_domain, argp->ypmatch_req_map,
		    argp->ypmatch_req_keydat, TRUE);
	}

#ifdef DEBUG
	yplog("  match1_status: %s",
	    yperr_string(ypprot_err(res.ypmatch_resp_status)));
#endif

	return (&res);
}

ypresponse *
ypoldproc_first_1_svc(yprequest *argp, struct svc_req *rqstp)
{
	static ypresponse res;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure;

	if (strchr(argp->ypfirst_req_domain, '/') ||
	    strchr(argp->ypfirst_req_map, '/'))
		goto bail;
	res.yp_resptype = YPFIRST_RESPTYPE;
	res.ypfirst_resp_valptr = res.ypfirst_resp_keyptr = "";
	res.ypfirst_resp_valsize = res.ypfirst_resp_keysize = 0;

	if (argp->yp_reqtype != YPREQ_NOKEY) {
		res.ypfirst_resp_status = YP_BADARGS;
		return(&res);
	}

	secure = ypdb_secure(argp->ypfirst_req_domain, argp->ypfirst_req_map);

	YPLOG( "first_1: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure),
	  argp->ypfirst_req_domain, argp->ypfirst_req_map);

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (secure && (ntohs(caller->sin_port) >= IPPORT_RESERVED)) {
		res.ypfirst_resp_status = YP_YPERR;
	} else {
		res.ypfirst_resp_val = ypdb_get_first(
		    argp->ypfirst_req_domain, argp->ypfirst_req_map, FALSE);
	}

#ifdef DEBUG
	yplog("  first1_status: %s",
	    yperr_string(ypprot_err(res.ypfirst_resp_status)));
#endif

	return (&res);
}

ypresponse *
ypoldproc_next_1_svc(yprequest *argp, struct svc_req *rqstp)
{
	static ypresponse res;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure;

	if (strchr(argp->ypnext_req_domain, '/') ||
	    strchr(argp->ypnext_req_map, '/'))
		goto bail;
	res.yp_resptype = YPNEXT_RESPTYPE;
	res.ypnext_resp_valptr = res.ypnext_resp_keyptr = "";
	res.ypnext_resp_valsize = res.ypnext_resp_keysize = 0;

	if (argp->yp_reqtype != YPNEXT_REQTYPE) {
		res.ypnext_resp_status = YP_BADARGS;
		return(&res);
	}

	secure = ypdb_secure(argp->ypnext_req_domain, argp->ypnext_req_map);

	YPLOG(
	  "next_1: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s, key=%.*s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure),
	  argp->ypnext_req_domain,  argp->ypnext_req_map,
	  argp->ypnext_req_keysize, argp->ypnext_req_keyptr);

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (secure && (ntohs(caller->sin_port) >= IPPORT_RESERVED)) {
		res.ypnext_resp_status = YP_YPERR;
	} else {
		res.ypnext_resp_val = ypdb_get_next(
		    argp->ypnext_req_domain, argp->ypnext_req_map,
		    argp->ypnext_req_keydat, FALSE);
	}

#ifdef DEBUG
	yplog("  next1_status: %s",
	    yperr_string(ypprot_err(res.ypnext_resp_status)));
#endif

	return (&res);
}

ypresponse *
ypoldproc_poll_1_svc(yprequest *argp, struct svc_req *rqstp)
{
	static ypresponse res;
	ypresp_order order;
	ypresp_master master;
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure;

	if (strchr(argp->yppoll_req_domain, '/') ||
	    strchr(argp->yppoll_req_map, '/'))
		goto bail;
	res.yp_resptype = YPPOLL_RESPTYPE;
	res.yppoll_resp_domain = argp->yppoll_req_domain;
	res.yppoll_resp_map = argp->yppoll_req_map;
	res.yppoll_resp_ordernum = 0;
	res.yppoll_resp_owner = "";

	if (argp->yp_reqtype != YPPOLL_REQTYPE) {
		return(&res);
	}

	secure = ypdb_secure(argp->yppoll_req_domain, argp->yppoll_req_map);

	YPLOG( "poll_1: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure),
	  argp->yppoll_req_domain, argp->yppoll_req_map);

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	if (!(secure && (ntohs(caller->sin_port) >= IPPORT_RESERVED))) {
		order = ypdb_get_order(argp->yppoll_req_domain,
		    argp->yppoll_req_map);
		master = ypdb_get_master(argp->yppoll_req_domain,
		    argp->yppoll_req_map);
		res.yppoll_resp_ordernum = order.ordernum;
		res.yppoll_resp_owner = master.peer;
	}

#ifdef DEBUG
	yplog("  poll1_status: %s", "none");
#endif
	return (&res);
}

void *
ypoldproc_push_1_svc(yprequest *argp, struct svc_req *rqstp)
{
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure;
	pid_t	pid;
	char	yppush_proc[] = YPPUSH_PROC;

	if (strchr(argp->yppush_req_domain, '/') ||
	    strchr(argp->yppush_req_map, '/'))
		goto bail;
	if (argp->yp_reqtype != YPPUSH_REQTYPE) {
		return(NULL);
	}

	secure = ypdb_secure(argp->yppush_req_domain, argp->yppush_req_map);

	YPLOG( "push_1: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure),
	  argp->yppush_req_domain, argp->yppush_req_map);

	if (ntohs(caller->sin_port) >= IPPORT_RESERVED)
		ok = FALSE;

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	pid = vfork();
	if (pid == -1) {
		svcerr_systemerr(rqstp->rq_xprt);
		return(NULL);
	}
	if (pid == 0) {
		execl(yppush_proc, "yppush", "-d", argp->yppush_req_domain,
		    argp->yppush_req_map, (char *)NULL);
		_exit(1);
	}
	return (NULL);
}

void *
ypoldproc_pull_1_svc(yprequest *argp, struct svc_req *rqstp)
{
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure;
	pid_t	pid;
	char	ypxfr_proc[] = YPXFR_PROC;

	if (strchr(argp->yppull_req_domain, '/') ||
	    strchr(argp->yppull_req_map, '/'))
		goto bail;
	if (argp->yp_reqtype != YPPULL_REQTYPE) {
		return(NULL);
	}

	secure = ypdb_secure(argp->yppull_req_domain, argp->yppull_req_map);

	YPLOG( "pull_1: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure),
	  argp->yppull_req_domain, argp->yppull_req_map);

	if (ntohs(caller->sin_port) >= IPPORT_RESERVED)
		ok = FALSE;

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	pid = vfork();
	if (pid == -1) {
		svcerr_systemerr(rqstp->rq_xprt);
		return(NULL);
	}
	if (pid == 0) {
		execl(ypxfr_proc, "ypxfr", "-d", argp->yppull_req_domain,
		    argp->yppull_req_map, (char *)NULL);
		_exit(1);
	}
	return (NULL);
}

void *
ypoldproc_get_1_svc(yprequest *argp, struct svc_req *rqstp)
{
	struct sockaddr_in *caller = svc_getcaller(rqstp->rq_xprt);
	int ok = acl_check_host(&caller->sin_addr);
	int secure;
	pid_t	pid;
	char	ypxfr_proc[] = YPXFR_PROC;

	if (strchr(argp->ypget_req_domain, '/') ||
	    strchr(argp->ypget_req_map, '/'))
		goto bail;
	if (argp->yp_reqtype != YPGET_REQTYPE)
		return(NULL);

	secure = ypdb_secure(argp->ypget_req_domain, argp->ypget_req_map);

	YPLOG( "get_1: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s, owner=%s",
	    inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	    TORF(ok), TORF(secure),
	    argp->ypget_req_domain, argp->ypget_req_map,
	    argp->ypget_req_owner);

	if (ntohs(caller->sin_port) >= IPPORT_RESERVED)
		ok = FALSE;

	if (!ok) {
bail:
		svcerr_auth(rqstp->rq_xprt, AUTH_FAILED);
		return(NULL);
	}

	pid = vfork();
	if (pid == -1) {
		svcerr_systemerr(rqstp->rq_xprt);
		return(NULL);
	}
	if (pid == 0) {
		execl(ypxfr_proc, "ypxfr", "-d", argp->ypget_req_domain, "-h",
		    argp->ypget_req_owner, argp->yppush_req_map, (char *)NULL);
		_exit(1);
	}
	return (NULL);
}
@


1.28
log
@fix a memory leak in an error path
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.27 2009/10/27 23:59:58 deraadt Exp $ */
a34 1
#include <sys/param.h>
d84 1
a84 1
	static char domain_path[MAXPATHLEN];
d112 1
a112 1
	static char domain_path[MAXPATHLEN];
d442 1
a442 1
	static char domain_path[MAXPATHLEN];
d541 1
a541 1
	static char domain_path[MAXPATHLEN];
d569 1
a569 1
	static char domain_path[MAXPATHLEN];
@


1.27
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.26 2006/09/25 05:59:28 otto Exp $ */
d492 1
@


1.26
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which leads to surprising results. Spotted by
from Paul Stoeber, more to come. ok jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.25 2006/04/03 05:01:24 deraadt Exp $ */
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.25 2006/04/03 05:01:24 deraadt Exp $";
#endif
@


1.25
log
@spreading the lint love (very minimal things..)
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.24 2005/05/14 02:32:33 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.24 2005/05/14 02:32:33 deraadt Exp $";
d97 1
a97 1
	    (finfo.st_mode & S_IFDIR));
d124 1
a124 1
	    (finfo.st_mode & S_IFDIR));
d474 1
a474 2
	if (!((stat(domain_path, &finfo) == 0) &&
	    ((finfo.st_mode & S_IFMT) == S_IFDIR)))
d552 1
a552 1
				    (finfo.st_mode & S_IFDIR));
d580 1
a580 1
				    (finfo.st_mode & S_IFDIR));
@


1.24
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.23 2003/07/15 06:10:46 deraadt Exp $ */
d29 2
a30 2
#ifndef LINT
static const char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.23 2003/07/15 06:10:46 deraadt Exp $";
d64 1
d248 1
a248 1
	bzero((char *)&res, sizeof(res));
d275 1
a275 1
		    "-C",tid, prog, ipadd, port, argp->map_parms.map, (char *)NULL);
d284 1
d337 1
a337 1
	bzero((char *)&res, sizeof(res));
d353 1
a353 1
	if (!svc_sendreply(rqstp->rq_xprt, ypdb_xdr_get_all, (char *) argp)) {
d468 2
a469 2
	bzero((char *)&res, sizeof(res));
	snprintf(domain_path,MAXPATHLEN, "%s/%s",YP_DB_PATH,*argp);
d491 1
a491 2
				if ((m = (struct ypmaplist *)malloc((unsigned)
				    sizeof(struct ypmaplist))) == NULL) {
d496 1
a496 2
				if ((map_name = (char *)malloc((unsigned)
				    dp->d_namlen - 2)) == NULL) {
d519 1
@


1.23
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.22 2003/06/22 23:57:07 maja Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.22 2003/06/22 23:57:07 maja Exp $";
d663 1
a663 1
	res.ypfirst_resp_valptr  = res.ypfirst_resp_keyptr  = "";
d711 1
a711 1
	res.ypnext_resp_valptr  = res.ypnext_resp_keyptr  = "";
@


1.22
log
@Remove files without copyright. Add a yp v1 protocol specification and
generate files at compile time. -moj  ok @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.21 2003/06/02 21:58:27 maja Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.21 2003/06/02 21:58:27 maja Exp $";
d52 1
a58 9

extern ypresp_val ypdb_get_record();
extern ypresp_key_val ypdb_get_first();
extern ypresp_key_val ypdb_get_next();
extern ypresp_order ypdb_get_order();
extern ypresp_master ypdb_get_master();
extern bool_t ypdb_xdr_get_all();
extern void ypdb_close_all();
extern int ypdb_secure();
@


1.21
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.20 2003/05/05 08:37:05 avsm Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.20 2003/05/05 08:37:05 avsm Exp $";
d528 1
a528 1
ypproc_null_1_svc(void *argp, struct svc_req *rqstp)
d548 1
a548 1
ypproc_domain_1_svc(domainname *argp, struct svc_req *rqstp)
d576 1
a576 1
ypproc_domain_nonack_1_svc(domainname *argp, struct svc_req *rqstp)
d609 1
a609 1
ypproc_match_1_svc(yprequest *argp, struct svc_req *rqstp)
d660 1
a660 1
ypproc_first_1_svc(yprequest *argp, struct svc_req *rqstp)
d708 1
a708 1
ypproc_next_1_svc(yprequest *argp, struct svc_req *rqstp)
d759 1
a759 1
ypproc_poll_1_svc(yprequest *argp, struct svc_req *rqstp)
d810 1
a810 1
ypproc_push_1_svc(yprequest *argp, struct svc_req *rqstp)
d855 1
a855 1
ypproc_pull_1_svc(yprequest *argp, struct svc_req *rqstp)
d900 1
a900 1
ypproc_get_1_svc(yprequest *argp, struct svc_req *rqstp)
@


1.20
log
@-Wall cleanup: trim unused vars, better err() message in stdhosts,
and constify rcsid[]

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.19 2003/02/13 05:54:39 maja Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.19 2003/02/13 05:54:39 maja Exp $";
@


1.19
log
@This fixes the problem with ypxfr switching key and value on map transfer.

This will make librpcsvc follow the real protocol and not the incorrect
specification in yp.x.

The changes in yp.x is from FreeBSD. A make build is the simplest way
to get things working but the following five step is an alternative

   1) make depend && make && make install  in lib/librpcsvc
   2) make includes                        in lib/librpcsvc
   3) make depend && make && make install  in lib/libc
   4) make depend && make && make install  in usr.sbin/ypserv/ypserv
   5) make depend && make && make install  in usr.sbin/ypserv/ypxfr

-moj ok niklas@@ ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.18 2002/07/19 02:38:40 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.18 2002/07/19 02:38:40 deraadt Exp $";
@


1.18
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.17 2001/11/19 09:03:07 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.17 2001/11/19 09:03:07 deraadt Exp $";
d39 1
a39 1
#include "yp.h"
@


1.17
log
@use a private svc_run() function that checks for a signal handler flag;
now signal safe.  Also, massive KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.16 2001/07/09 07:05:06 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.16 2001/07/09 07:05:06 deraadt Exp $";
d48 1
d78 1
a78 3
ypproc_null_2_svc(argp, rqstp)
	void *argp;
	struct svc_req *rqstp;
d97 1
a97 3
ypproc_domain_2_svc(argp, rqstp)
	domainname *argp;
	struct svc_req *rqstp;
d124 1
a124 3
ypproc_domain_nonack_2_svc(argp, rqstp)
	domainname *argp;
	struct svc_req *rqstp;
d154 1
a154 3
ypproc_match_2_svc(argp, rqstp)
	ypreq_key *argp;
	struct svc_req *rqstp;
d187 1
a187 3
ypproc_first_2_svc(argp, rqstp)
	ypreq_nokey *argp;
	struct svc_req *rqstp;
d218 1
a218 3
ypproc_next_2_svc(argp, rqstp)
	ypreq_key *argp;
	struct svc_req *rqstp;
d251 1
a251 3
ypproc_xfr_2_svc(argp, rqstp)
	ypreq_xfr *argp;
	struct svc_req *rqstp;
d297 1
a297 3
ypproc_clear_2_svc(argp, rqstp)
	void *argp;
	struct svc_req *rqstp;
d329 1
a329 3
ypproc_all_2_svc(argp, rqstp)
	ypreq_nokey *argp;
	struct svc_req *rqstp;
d371 1
a371 3
ypproc_master_2_svc(argp, rqstp)
	ypreq_nokey *argp;
	struct svc_req *rqstp;
d418 1
a418 3
ypproc_order_2_svc(argp, rqstp)
	ypreq_nokey *argp;
	struct svc_req *rqstp;
d453 1
a453 3
ypproc_maplist_2_svc(argp, rqstp)
	domainname *argp;
	struct svc_req *rqstp;
d495 1
a495 1
		for(dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
d533 1
a533 3
ypproc_null_1_svc(argp, rqstp)
	void *argp;
	struct svc_req *rqstp;
d553 1
a553 3
ypproc_domain_1_svc(argp, rqstp)
	domainname *argp;
	struct svc_req *rqstp;
d581 1
a581 3
ypproc_domain_nonack_1_svc(argp, rqstp)
	domainname *argp;
	struct svc_req *rqstp;
d614 1
a614 3
ypproc_match_1_svc(argp, rqstp)
	yprequest *argp;
	struct svc_req *rqstp;
d665 1
a665 3
ypproc_first_1_svc(argp, rqstp)
	yprequest *argp;
	struct svc_req *rqstp;
d713 1
a713 3
ypproc_next_1_svc(argp, rqstp)
	yprequest *argp;
	struct svc_req *rqstp;
d764 1
a764 3
ypproc_poll_1_svc(argp, rqstp)
	yprequest *argp;
	struct svc_req *rqstp;
d815 1
a815 3
ypproc_push_1_svc(argp, rqstp)
	yprequest *argp;
	struct svc_req *rqstp;
d860 1
a860 3
ypproc_pull_1_svc(argp, rqstp)
	yprequest *argp;
	struct svc_req *rqstp;
d905 1
a905 3
ypproc_get_1_svc(argp, rqstp)
	yprequest *argp;
	struct svc_req *rqstp;
@


1.16
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.15 1998/01/08 22:36:48 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.15 1998/01/08 22:36:48 maja Exp $";
d75 1
d79 1
a79 1
        struct svc_req *rqstp;
d86 1
a86 1
	      inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok));
a93 1

d100 1
a100 1
        struct svc_req *rqstp;
a101 1
	static bool_t result; /* is domain_served? */
d105 1
d112 1
a112 1
				    (finfo.st_mode & S_IFDIR));
d115 2
a116 2
	      inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), 
	      TORF(ok), *argp, TORF(result));
a122 1

d129 1
a129 1
        struct svc_req *rqstp;
d141 1
a141 1
				    (finfo.st_mode & S_IFDIR));
d143 3
a145 4
	YPLOG(
	  "domain_nonack_2: caller=[%s].%d, auth_ok=%s, domain=%s, served=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok), 
	  *argp, TORF(result));
d153 1
a153 1
	if (!result) {
a154 2
	}

d161 1
a161 1
        struct svc_req *rqstp;
a162 1
	static ypresp_val res;
d165 2
a166 1
	int secure = ypdb_secure(argp->domain,argp->map);
d170 4
a173 5
	YPLOG(
	  "match_2: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s, key=%.*s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure),
	  argp->domain, argp->map, argp->key.keydat_len, argp->key.keydat_val);
d184 1
a184 1
		res = ypdb_get_record(argp->domain,argp->map,argp->key, TRUE);
a189 1

d196 1
a196 1
        struct svc_req *rqstp;
a197 1
	static ypresp_key_val res;
d200 2
a201 1
	int secure = ypdb_secure(argp->domain,argp->map);
d206 2
a207 4
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure),
	  argp->domain, argp->map);
	
d217 1
a217 1
		res = ypdb_get_first(argp->domain,argp->map,FALSE);
a222 1

d229 1
a229 1
        struct svc_req *rqstp;
d234 1
a234 1
	int secure = ypdb_secure(argp->domain,argp->map);
d238 4
a241 5
	YPLOG(
	  "next_2: caller=[%s].%d, auth_ok=%s, secure=%s, domain=%s, map=%s, key=%.*s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure),
	  argp->domain, argp->map, argp->key.keydat_len, argp->key.keydat_val);
d252 1
a252 1
		res = ypdb_get_next(argp->domain,argp->map,argp->key,FALSE);
a257 1

d264 1
a264 1
        struct svc_req *rqstp;
d270 2
a271 5
	char	tid[11];
	char	prog[11];
	char	port[11];
	char	ypxfr_proc[] = YPXFR_PROC;
	char	*ipadd;
d276 2
a277 2
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok), 
	  argp->map_parms.domain, argp->transid, argp->prog);
d279 1
a279 1
	  argp->port, argp->map_parms.map);
d288 1
a288 1
	snprintf(tid, sizeof(tid), "%d",argp->transid);
a302 1
	
d312 1
a312 1
        struct svc_req *rqstp;
d336 1
a336 1
	
d338 1
a338 1
        ypdb_close_all();
a339 1

d346 1
a346 1
        struct svc_req *rqstp;
d352 1
a352 1
	int secure = ypdb_secure(argp->domain,argp->map);
d357 2
a358 2
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure), argp->domain, argp->map);
d365 1
a366 2
	bzero((char *)&res, sizeof(res));
	
a372 1

a373 1

a376 1
		
a377 1
		
a383 3

	/* note: no need to free args, we are exiting */

d390 1
a390 1
        struct svc_req *rqstp;
d396 1
a396 1
	int secure = ypdb_secure(argp->domain,argp->map);
d401 2
a402 2
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure), argp->domain, argp->map);
d413 1
a413 1
		res = ypdb_get_master(argp->domain,argp->map);
d420 11
a430 10
	/* This code was added because a yppoll <unknown-domain> */
	/* from a sun crashed the server in xdr_string, trying   */
	/* to access the peer through a NULL-pointer. yppoll in  */
	/* this server start asking for order. If order is ok    */
	/* then it will ask for master. SunOS 4 asks for both    */
	/* always. I'm not sure this is the best place for the   */
	/* fix, but for now it will do. xdr_peername or          */
	/* xdr_string in ypserv_xdr.c may be a better place?     */
	
	if (res.peer == NULL) {
a431 4
	}

	/* End of fix                                            */

d439 1
a439 1
        struct svc_req *rqstp;
d444 1
a444 1
	int secure = ypdb_secure(argp->domain,argp->map);
d449 2
a450 2
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure), argp->domain, argp->map);
d463 1
a463 1
		res = ypdb_get_order(argp->domain,argp->map);
a468 1

d476 1
a476 1
        struct svc_req *rqstp;
d493 2
a494 2
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok),
	  *argp);
a502 1
	
a505 1

d509 1
a509 1
		((finfo.st_mode & S_IFMT) == S_IFDIR))) 
d513 2
a514 3
	  if ((dirp = opendir(domain_path)) == NULL) {
	    status = YP_NODOM;
	  }
d518 26
a543 32
	  for(dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
	    if ((!strcmp(dp->d_name, ".")) ||
		((!strcmp(dp->d_name, ".."))) ||
		(dp->d_namlen < 4))
	      continue;
	    suffix = (char *) &dp->d_name[dp->d_namlen-3];
	    if (strcmp(suffix,".db") == 0) {

	      if ((m = (struct ypmaplist *)
		   malloc((unsigned) sizeof(struct ypmaplist))) == NULL) {
		status = YP_YPERR;
		break;
	      }

	      if ((map_name = (char *)
		   malloc((unsigned) dp->d_namlen - 2)) == NULL) {
		status = YP_YPERR;
		break;
	      }

	      m->next = res.maps;
	      m->map = map_name;
	      res.maps = m;
	      strncpy(map_name, dp->d_name, dp->d_namlen - 3);
	      m->map[dp->d_namlen - 3] = '\0';
	      
	    }
	  }
	}
	
	if (dirp != NULL) {
	  closedir(dirp);
d545 2
a548 1
	
a551 1

d558 1
a558 1
        struct svc_req *rqstp;
d565 1
a565 1
	      inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok));
d580 1
a580 1
        struct svc_req *rqstp;
d595 2
a596 2
	      inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), 
	      TORF(ok), *argp, TORF(result));
d610 1
a610 1
        struct svc_req *rqstp;
d626 1
a626 1
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok), 
d645 1
a645 1
        struct svc_req *rqstp;
d682 3
a684 5
		res.ypmatch_resp_val =
		      ypdb_get_record(argp->ypmatch_req_domain,
				      argp->ypmatch_req_map,
				      argp->ypmatch_req_keydat,
				      TRUE);
d689 1
a689 1
	      yperr_string(ypprot_err(res.ypmatch_resp_status)));
d698 1
a698 1
        struct svc_req *rqstp;
d723 1
a723 1
	
d733 2
a734 4
		res.ypfirst_resp_val =
		      ypdb_get_first(argp->ypfirst_req_domain,
				     argp->ypfirst_req_map,
				     FALSE);
d739 1
a739 1
	      yperr_string(ypprot_err(res.ypfirst_resp_status)));
d748 1
a748 1
        struct svc_req *rqstp;
d785 3
a787 5
		res.ypnext_resp_val =
		      ypdb_get_next(argp->ypnext_req_domain,
				    argp->ypnext_req_map,
				    argp->ypnext_req_keydat,
				    FALSE);
d792 1
a792 1
	      yperr_string(ypprot_err(res.ypnext_resp_status)));
d801 1
a801 1
        struct svc_req *rqstp;
d838 1
a838 1
				       argp->yppoll_req_map);
d840 1
a840 1
					 argp->yppoll_req_map);
d854 1
a854 1
        struct svc_req *rqstp;
d892 1
a892 1
		      argp->yppush_req_map, (char *)NULL);
a894 1
	
d901 1
a901 1
        struct svc_req *rqstp;
d939 1
a939 1
		      argp->yppull_req_map, (char *)NULL);
a941 1
	
d948 1
a948 1
        struct svc_req *rqstp;
a949 1
	char *res;
d959 1
a959 1
	if (argp->yp_reqtype != YPGET_REQTYPE) {
a960 1
	}
d965 4
a968 4
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port),
	  TORF(ok), TORF(secure),
	  argp->ypget_req_domain, argp->ypget_req_map,
	  argp->ypget_req_owner);
d986 1
a986 1
		      argp->ypget_req_owner, argp->yppush_req_map, (char *)NULL);
a988 1
	
@


1.15
log
@Fix some problems with xfr of secure maps. Problem reported by
Eric Rungi <rungus@@openface.org> -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.14 1997/09/12 01:44:57 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.14 1997/09/12 01:44:57 deraadt Exp $";
d314 1
a314 1
		    "-C",tid, prog, ipadd, port, argp->map_parms.map, NULL);
d935 1
a935 1
		      argp->yppush_req_map, NULL);
d983 1
a983 1
		      argp->yppull_req_map, NULL);
d1033 1
a1033 1
		      argp->ypget_req_owner, argp->yppush_req_map, NULL);
@


1.14
log
@paranoia in vfork land
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.13 1997/06/02 19:50:42 dm Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.13 1997/06/02 19:50:42 dm Exp $";
d189 1
a189 1
		res = ypdb_get_record(argp->domain,argp->map,argp->key, FALSE);
d723 1
a723 1
				      FALSE);
@


1.13
log
@Fix for amd:  make yp_order return YP_NOMAP for maps with '/' in them.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.12 1997/04/12 16:38:06 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.12 1997/04/12 16:38:06 deraadt Exp $";
d302 5
a311 1

a312 5
		snprintf(tid, sizeof(tid), "%d",argp->transid);
		snprintf(prog, sizeof(prog), "%d", argp->prog);
		snprintf(port, sizeof(port), "%d", argp->port);
		ipadd = inet_ntoa(caller->sin_addr);

a928 1

a931 1
		
a932 1

a976 1

a979 1
		
a980 1

a1026 1

a1029 1
		
a1030 1

@


1.12
log
@bit more careful with mapnames; adam@@math.tau.ac.il
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.11 1997/04/12 00:12:57 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.11 1997/04/12 00:12:57 deraadt Exp $";
d474 1
a474 1
	if (strchr(argp->domain, '/') || strchr(argp->map, '/'))
d488 2
@


1.11
log
@bit more care with domainnames, adam@@math.tau.ac.il
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.10 1997/03/30 20:51:21 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.10 1997/03/30 20:51:21 maja Exp $";
d172 1
a172 1
	if (strchr(argp->domain, '/'))
d209 1
a209 1
	if (strchr(argp->domain, '/'))
d245 1
a245 1
	if (strchr(argp->domain, '/'))
d296 1
d371 1
a371 1
	if (strchr(argp->domain, '/'))
d423 1
a423 1
	if (strchr(argp->domain, '/'))
d474 1
a474 1
	if (strchr(argp->domain, '/'))
d688 2
a689 1
	if (strchr(argp->ypmatch_req_domain, '/'))
d743 2
a744 1
	if (strchr(argp->ypfirst_req_domain, '/'))
d795 2
a796 1
	if (strchr(argp->ypnext_req_domain, '/'))
d852 2
a853 1
	if (strchr(argp->yppoll_req_domain, '/'))
d904 2
a905 1
	if (strchr(argp->yppush_req_domain, '/'))
d955 2
a956 1
	if (strchr(argp->yppull_req_domain, '/'))
d1007 2
a1008 1
	if (strchr(argp->ypget_req_domain, '/'))
@


1.10
log
@Added support for YP V1. Partly from FreeBSD. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.9 1997/03/11 09:12:27 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.9 1997/03/11 09:12:27 maja Exp $";
d108 2
d119 1
d138 2
d150 1
d172 2
d181 1
d209 2
d217 1
d245 2
d254 1
d288 1
a288 1
	
d295 2
a296 4
	if (ntohs(caller->sin_port) >= IPPORT_RESERVED)
		ok = FALSE;

	if (!ok) {
a301 1

a304 1
		
d370 2
d377 1
d422 2
d429 1
d473 2
d480 1
d516 2
d523 1
d623 2
d634 1
d653 2
d665 1
d687 2
d708 1
d741 2
d760 1
d792 2
d813 1
d848 2
d868 1
d899 2
d916 1
d949 2
d966 1
d1000 2
d1018 1
@


1.9
log
@Now with support for "secure" maps a'la FreeBSD. Support exists in makedbm
and ypxfrd since dawn of time. Support is missing in YP-makefile and in
libc. I have the changes for YP-makefile to support master.passwd but since
the support is missing in libc I will not commit them yet. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.8 1996/10/03 19:50:57 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.8 1996/10/03 19:50:57 deraadt Exp $";
d40 1
d567 422
@


1.8
log
@net byte order for clear check
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.7 1996/09/30 21:03:56 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.7 1996/09/30 21:03:56 deraadt Exp $";
d69 1
d84 1
a84 1
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok));
d112 2
a113 2
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), 
	  TORF(ok), *argp, TORF(result));
d163 1
d166 3
a168 2
	  "match_2: caller=[%s].%d, auth_ok=%s, domain=%s, map=%s, key=%.*s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok), 
d176 6
a181 2
	res = ypdb_get_record(argp->domain,argp->map,argp->key, FALSE);
	
d197 1
d199 3
a201 2
	YPLOG( "first_2: caller=[%s].%d, auth_ok=%s, domain=%s, map=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok), 
d209 5
a213 1
	res = ypdb_get_first(argp->domain,argp->map,FALSE);
d230 1
d233 3
a235 2
	  "next_2: caller=[%s].%d, auth_ok=%s, domain=%s, map=%s, key=%.*s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok), 
d243 5
a247 2
	res = ypdb_get_next(argp->domain,argp->map,argp->key,FALSE);

d356 1
d358 3
a360 3
	YPLOG( "all_2: caller=[%s].%d, auth_ok=%s, domain=%s, map=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok),
	  argp->domain, argp->map);
d369 5
d378 6
a383 6
	  if (pid == -1) {
	    /* XXXCDC An error has occurred */
	  }

	  return(NULL); /* PARENT: continue */
	  
d405 1
d407 3
a409 3
	YPLOG( "master_2: caller=[%s].%d, auth_ok=%s, domain=%s, map=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok),
	  argp->domain, argp->map);
d416 5
a420 1
	res = ypdb_get_master(argp->domain,argp->map);
d436 1
a436 1
	  res.peer = nopeer;
d453 1
d455 3
a457 3
	YPLOG( "order_2: caller=[%s].%d, auth_ok=%s, domain=%s, map=%s",
	  inet_ntoa(caller->sin_addr), ntohs(caller->sin_port), TORF(ok),
	  argp->domain, argp->map);
d464 5
a468 1
	res = ypdb_get_order(argp->domain,argp->map);
@


1.7
log
@sin_port in net order; _exit() after vfork()
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.6 1996/09/30 20:50:24 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.6 1996/09/30 20:50:24 maja Exp $";
d312 2
a313 7
	if (ok) {
		if (caller->sin_family != AF_INET ||
		    caller->sin_port >= IPPORT_RESERVED ||
		    caller->sin_port < IPPORT_RESERVED/2) {
			ok = FALSE;
		}
	}
@


1.6
log
@Don't allow certain operations if not from a reserved port. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.5 1996/08/15 21:47:30 chuck Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.5 1996/08/15 21:47:30 chuck Exp $";
d261 2
a262 7
	if (ok) {
		if (caller->sin_family != AF_INET ||
		    caller->sin_port >= IPPORT_RESERVED ||
		    caller->sin_port < IPPORT_RESERVED/2) {
			ok = FALSE;
		}
	}
a277 1
		
d284 2
a285 2
		      "-C",tid, prog, ipadd, port, argp->map_parms.map, NULL);
		exit(1);
a290 1

@


1.5
log
@fix printf format (%s -> %d) in yplog debug statement
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.4 1996/06/26 21:26:39 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.4 1996/06/26 21:26:39 maja Exp $";
d261 8
d318 8
@


1.4
log
@Same copyright all over, removed my name from ypdb.[ch], small bugfix
in ypserv_db.c /moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypserv_proc.c,v 1.3 1996/05/30 09:53:30 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: ypserv_proc.c,v 1.3 1996/05/30 09:53:30 deraadt Exp $";
d255 1
a255 1
	YPLOG("xfr_2: caller=[%s].%d, auth_ok=%s, domain=%s, tid=%s, prog=%s",
d258 1
a258 1
	YPLOG("       ipadd=%s, port=%s, map=%s", inet_ntoa(caller->sin_addr),
@


1.3
log
@$OpenBSD$ tag and few spelling errors
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d15 5
a19 3
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
d35 1
a35 1
static char rcsid[] = "$OpenBSD$";
@


1.2
log
@major revision and clean up by Chuck Cranor (i.e. me):
 - convert to new yplog() function and clean up log message formats
 - remove transp args from all _svc functions since you can get it
	from rqstp->rq_xprt, and rpcgen seems to favor this format
 - delete all the calls to svc_sendreply() and svc_freeargs() as
	this can be done in one place in ypserv.c (except for the "all"
	request which forks off a child process)
 - avoid possible sprintf() buffer overflows by using snprintf()
 - use MAXPATHLEN, rather than a hardcoded 255.
 - eliminate un-needed static variables
 - avoid possible off by one buffer overflow in tid/prog/port and use
	snprintf() just to be sure.
 - random code cleanup and simplification
@
text
@d1 2
d33 1
a33 1
static char rcsid[] = "$Id: ypserv_proc.c,v 1.1 1995/11/01 16:56:37 deraadt Exp $";
d394 5
a398 5
	/* NetBSD start asking for order. If order is ok then it */
	/* will ask for master. SunOS 4 asks for both always.    */
	/* I'm not sure this is the best place for the fix, but  */
	/* for now it will do. xdr_peername or xdr_string in     */
	/* ypserv_xdr.c may be a better place?                   */
@


1.1
log
@+ full set of ypserv tools that compile
@
text
@d31 1
a31 1
static char rcsid[] = "$Id: ypserv_proc.c,v 1.8 1995/10/23 22:36:35 moj Exp $";
d39 1
d52 6
a64 1
extern int acl_access_ok;
d66 3
d70 1
a70 1
ypproc_null_2_svc(argp, rqstp, transp)
a72 1
	SVCXPRT *transp;
d74 3
a76 1
	static char res;
d78 2
a79 1
	bzero((char *)&res, sizeof(res));
d81 3
a83 5
	yplog_date("ypproc_null_2: this code isn't tested");
	yplog_call(transp);
	
	if (!svc_sendreply(transp, xdr_void, (char *) &res)) {
		svcerr_systemerr(transp);
d85 4
a88 7
	
	if (!svc_freeargs(transp, xdr_void, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
	}
	
	return ((void *)&res);
d92 1
a92 1
ypproc_domain_2_svc(argp, rqstp, transp)
a94 1
	SVCXPRT *transp;
d96 5
a100 6
	static bool_t res;
	static bool_t domain_served;
	static char   domain_path[255];
	struct	stat	finfo;

	bzero((char *)&res, sizeof(res));
d102 2
a103 3
	if (acl_access_ok) {
	  sprintf(domain_path,"%s/%s",YP_DB_PATH,*argp);
	  domain_served = (bool_t) ((stat(domain_path, &finfo) == 0) &&
a104 15
	} else {
	  domain_served = FALSE;
	}

#ifdef DEBUG
	yplog_date("ypproc_domain_2:");
	yplog_call(transp);
	yplog_str("  domain: "); yplog_cat(*argp); yplog_cat("\n");
	yplog_str("  served: ");
	if (domain_served) {
	  yplog_cat("true\n");
	} else {
	  yplog_cat("false\n");
	}
#endif
d106 3
a108 5
	res = domain_served;
	  
	if (!svc_sendreply(transp, xdr_bool, (char *) &res)) {
	  svcerr_systemerr(transp);
	}
d110 3
a112 3
	if (!svc_freeargs(transp, xdr_domainname, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
d115 1
a115 1
	return (&res);
d119 1
a119 1
ypproc_domain_nonack_2_svc(argp, rqstp, transp)
a121 1
	SVCXPRT *transp;
d123 5
a127 6
	static bool_t res;
	static bool_t domain_served;
	static char   domain_path[255];
	struct	stat	finfo;

	bzero((char *)&res, sizeof(res));
d129 2
a130 3
	if (acl_access_ok) {
	  sprintf(domain_path,"%s/%s",YP_DB_PATH,*argp);
	  domain_served = (bool_t) ((stat(domain_path, &finfo) == 0) &&
a131 15
	} else {
	  domain_served = FALSE;
	}
	
#ifdef DEBUG
	yplog_date("ypproc_domain_nonack_2:");
	yplog_call(transp);
	yplog_str("  domain: "); yplog_cat(*argp); yplog_cat("\n");
	yplog_str("  served: ");
	if (domain_served) {
	  yplog_cat("true\n");
	} else {
	  yplog_cat("false\n");
	}
#endif
d133 4
a136 11
	if (domain_served) {
	  
	  res = domain_served;
	  
	  if (!svc_sendreply(transp, xdr_bool, (char *) &res)) {
	  	svcerr_systemerr(transp);
	  }
	
	} else {

	  res = (bool_t) FALSE;
d138 3
a140 2
	  svcerr_decode(transp);
	  
d143 2
a144 3
	if (!svc_freeargs(transp, xdr_domainname, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
d147 1
a147 1
	return (&res);
d151 1
a151 1
ypproc_match_2_svc(argp, rqstp, transp)
a153 1
	SVCXPRT *transp;
d156 2
d159 4
a162 10
	bzero((char *)&res, sizeof(res));
	
#ifdef DEBUG
	yplog_date("ypproc_match_2:");
	yplog_call(transp);
	yplog_str("  domain: "); yplog_cat(argp->domain); yplog_cat("\n");
	yplog_str("     map: "); yplog_cat(argp->map); yplog_cat("\n");
	yplog_str("     key: "); yplog_cat(argp->key.keydat_val);
	yplog_cat("\n");
#endif
d164 3
a166 4
	if (acl_access_ok) {
	  res = ypdb_get_record(argp->domain,argp->map,argp->key, FALSE);
	} else {
	  res.stat = YP_NODOM;
d168 2
d172 1
a172 3
	yplog_str("  status: ");
	yplog_cat(yperr_string(ypprot_err(res.stat)));
	yplog_cat("\n");
a174 9
	if (!svc_sendreply(transp, xdr_ypresp_val, (char *) &res)) {
		svcerr_systemerr(transp);
	}

	if (!svc_freeargs(transp, xdr_ypreq_key, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
	}

d179 2
a180 2
ypproc_first_2_svc(argp, rqstp, transp)
	ypreq_key *argp;
a181 1
	SVCXPRT *transp;
d184 2
d187 3
a189 1
	bzero((char *)&res, sizeof(res));
d191 4
a194 6
#ifdef DEBUG
	yplog_date("ypproc_first_2:");
	yplog_call(transp);
	yplog_str("  domain: "); yplog_cat(argp->domain); yplog_cat("\n");
	yplog_str("     map: "); yplog_cat(argp->map); yplog_cat("\n");
#endif
d196 1
a196 5
	if (acl_access_ok) {
	  res = ypdb_get_first(argp->domain,argp->map,FALSE);
	} else {
	  res.stat = YP_NODOM;
	}
d199 1
a199 3
	yplog_str("  status: ");
	yplog_cat(yperr_string(ypprot_err(res.stat)));
	yplog_cat("\n");
a201 9
	if (!svc_sendreply(transp, xdr_ypresp_key_val, (char *) &res)) {
		svcerr_systemerr(transp);
	}

	if (!svc_freeargs(transp, xdr_ypreq_key, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
	}

d206 1
a206 1
ypproc_next_2_svc(argp, rqstp, transp)
a208 1
	SVCXPRT *transp;
d211 2
d214 4
a217 10
	bzero((char *)&res, sizeof(res));
	
#ifdef DEBUG
	yplog_date("ypproc_next_2:");
	yplog_call(transp);
	yplog_str("  domain: "); yplog_cat(argp->domain); yplog_cat("\n");
	yplog_str("     map: "); yplog_cat(argp->map); yplog_cat("\n");
	yplog_str("     key: "); yplog_cat(argp->key.keydat_val);
	yplog_cat("\n");
#endif
d219 3
a221 4
	if (acl_access_ok) {
	  res = ypdb_get_next(argp->domain,argp->map,argp->key,FALSE);
	} else {
	  res.stat = YP_NODOM;
d224 3
d228 1
a228 3
	yplog_str("  status: ");
	yplog_cat(yperr_string(ypprot_err(res.stat)));
	yplog_cat("\n");
a230 9
	if (!svc_sendreply(transp, xdr_ypresp_key_val, (char *) &res)) {
		svcerr_systemerr(transp);
	}
	
	if (!svc_freeargs(transp, xdr_ypreq_key, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
	}

d235 1
a235 1
ypproc_xfr_2_svc(argp, rqstp, transp)
a237 1
	SVCXPRT *transp;
d240 2
d243 3
a245 3
	char	tid[10];
	char	prog[10];
	char	port[10];
a246 1
	struct sockaddr_in *sin;
d251 11
a261 3
	yplog_date("ypproc_xfr_2: this code isn't yet implemented");
	yplog_call(transp);
	
d265 2
a266 4
		
		/* An error has occurred */
		
		return(&res);
d272 4
a275 5
		sprintf(tid,"%d",argp->transid);
		sprintf(prog, "%d", argp->prog);
		sprintf(port, "%d", argp->port);
		sin = svc_getcaller(transp);
		ipadd = inet_ntoa(sin->sin_addr);
d282 3
a284 8
	if (!svc_sendreply(transp, xdr_void, (char *) &res)) {
		svcerr_systemerr(transp);
	}

	if (!svc_freeargs(transp, xdr_ypreq_xfr, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
	}
d290 1
a290 1
ypproc_clear_2_svc(argp, rqstp, transp)
a292 1
	SVCXPRT *transp;
d294 3
a296 1
	static char res;
d298 2
a299 2
	bzero((char *)&res, sizeof(res));
	
d301 1
a301 1
	yplog_date("ypproc_clear_2: DB open/close optimization");
d303 1
a303 1
	yplog_date("ypproc_clear_2: No optimization");
d305 8
a312 1
	yplog_call(transp);
a317 9
	if (!svc_sendreply(transp, xdr_void, (char *) &res)) {
		svcerr_systemerr(transp);
	}
	
	if (!svc_freeargs(transp, xdr_void, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
	}
	
d322 1
a322 1
ypproc_all_2_svc(argp, rqstp, transp)
a324 1
	SVCXPRT *transp;
d328 11
a341 8
#ifdef DEBUG
	yplog_date("ypproc_all_2:");
	yplog_call(transp);
	yplog_str("  domain: "); yplog_cat(argp->domain); yplog_cat("\n");
	yplog_str("     map: "); yplog_cat(argp->map); yplog_cat("\n");
	yplog_cat("\n");
#endif
	
d347 1
a347 1
	    /* An error has occurred */
d350 1
a350 1
	  return(&res);
d353 1
d355 2
a356 2
	if (!svc_sendreply(transp, ypdb_xdr_get_all, (char *) argp)) {
		svcerr_systemerr(transp);
d359 2
a360 5
	if (!svc_freeargs(transp, xdr_ypreq_nokey, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
	}
	
d365 1
a365 1
ypproc_master_2_svc(argp, rqstp, transp)
a367 1
	SVCXPRT *transp;
d371 2
d374 3
a376 9
	bzero((char *)&res, sizeof(res));
	
#ifdef DEBUG
	yplog_date("ypproc_master_2:");
	yplog_call(transp);
	yplog_str("  domain: "); yplog_cat(argp->domain); yplog_cat("\n");
	yplog_str("     map: "); yplog_cat(argp->map); yplog_cat("\n");
	yplog_cat("\n");
#endif
d378 3
a380 4
	if (acl_access_ok) {
	  res = ypdb_get_master(argp->domain,argp->map);
	} else {
	  res.stat = YP_NODOM;
d383 2
d386 1
a386 3
	yplog_str("  status: ");
	yplog_cat(yperr_string(ypprot_err(res.stat)));
	yplog_cat("\n");
a403 9
	if (!svc_sendreply(transp, xdr_ypresp_master, (char *) &res)) {
		svcerr_systemerr(transp);
	}

	if (!svc_freeargs(transp, xdr_ypreq_nokey, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
	}
	
d409 1
a409 1
ypproc_order_2_svc(argp, rqstp, transp)
a411 1
	SVCXPRT *transp;
d414 2
d417 3
a419 9
	bzero((char *)&res, sizeof(res));
	
#ifdef DEBUG
	yplog_date("ypproc_order_2:");
	yplog_call(transp);
	yplog_str("  domain: "); yplog_cat(argp->domain); yplog_cat("\n");
	yplog_str("     map: "); yplog_cat(argp->map); yplog_cat("\n");
	yplog_cat("\n");
#endif
d421 3
a423 4
	if (acl_access_ok) {
	  res = ypdb_get_order(argp->domain,argp->map);
	} else {
	  res.stat = YP_NODOM;
d426 2
d429 1
a429 3
	yplog_str("  status: ");
	yplog_cat(yperr_string(ypprot_err(res.stat)));
	yplog_cat("\n");
a431 9
	if (!svc_sendreply(transp, xdr_ypresp_order, (char *) &res)) {
		svcerr_systemerr(transp);
	}

	if (!svc_freeargs(transp, xdr_ypreq_nokey, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
	}
	
d437 1
a437 1
ypproc_maplist_2_svc(argp, rqstp, transp)
a439 1
	SVCXPRT *transp;
d442 3
a444 1
	static char domain_path[255];
d453 9
d464 1
a464 7
#ifdef DEBUG
	yplog_date("ypproc_maplist_2:");
	yplog_call(transp);
	yplog_str("  domain: "); yplog_cat(*argp); yplog_cat("\n");
#endif

	sprintf(domain_path,"%s/%s",YP_DB_PATH,*argp);
d470 3
a472 8
	if (acl_access_ok) {
	  if (!((stat(domain_path, &finfo) == 0) &&
		((finfo.st_mode & S_IFMT) == S_IFDIR))) {
	    status = YP_NODOM;
	  }
	} else {
	  status = YP_NODOM;
	}
d518 1
a518 3
	yplog_str("  status: ");
	yplog_cat(yperr_string(ypprot_err(res.stat)));
	yplog_cat("\n");
a519 9

	if (!svc_sendreply(transp, xdr_ypresp_maplist, (char *) &res)) {
		svcerr_systemerr(transp);
	}
	
	if (!svc_freeargs(transp, xdr_domainname, (caddr_t) argp)) {
		(void)fprintf(stderr, "unable to free arguments\n");
		exit(1);
	}
@
