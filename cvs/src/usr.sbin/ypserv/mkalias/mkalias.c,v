head	1.29;
access;
symbols
	OPENBSD_6_0:1.28.0.8
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.4
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.14
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.12
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.10
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.8
	OPENBSD_5_0:1.24.0.6
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.21.0.10
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.12
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.10
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.10
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.29
date	2016.09.22.00.09.47;	author jsg;	state Exp;
branches;
next	1.28;
commitid	zi7VdC21Nd6bTrMn;

1.28
date	2015.02.09.23.00.15;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	822YD61EeG0Xl9Na;

1.27
date	2015.01.16.06.40.23;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Uu5nFG3wCl0LACBb;

1.26
date	2013.12.05.14.18.54;	author jca;	state Exp;
branches;
next	1.25;

1.25
date	2013.08.22.04.43.41;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.29.03.47.40;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.59.58;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.20.09.47.03;	author sobrado;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.04.14.37.53;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.04.01.05.20;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.05.14.25.48;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.10.20.44.07;	author mk;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.03.05.01.22;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.18.22.58.56;	author david;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.21.58.26;	author maja;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.05.08.37.05;	author avsm;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.06.21.37.38;	author maja;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.19.20.59.40;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.09.02.21.55;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.27.02.19.57;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.19.09.01.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.05.14.47.17;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.07.09.06.33.04;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.03.12.08.22.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.28.22.48.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.07.26.22.07.22;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	97.07.26.12.12.29;	author maja;	state Exp;
branches;
next	;


desc
@@


1.29
log
@include time.h for time()
@
text
@/*	$OpenBSD: mkalias.c,v 1.28 2015/02/09 23:00:15 deraadt Exp $ */

/*
 * Copyright (c) 1997 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <resolv.h>
#include <err.h>
#include <time.h>
#include "ypdb.h"
#include "ypdef.h"

static void
split_address(char *address, size_t len, char *user, char *host)
{
	char *c, *s, *r;
	size_t  i = 0;

	if (memchr(address, '@@', len)) {
		s = user;
		for (c = address; i < len; i++) {
			if (*c == '@@') {
				*s = '\0';
				s = host;
			} else {
				*s++ = *c;
			}
			c++;
		}
		*s = '\0';
	}

	if ((r = memrchr(address, '!',  len))) {
		s = host;
		for (c = address; i < len; i++) {
			if (c == r) {
				*s = '\0';
				s = user;
			} else {
				*s++ = *c;
			}
			c++;
		}
		*s = '\0';
	}
}

static int
check_host(char *address, size_t len, char *host, int dflag, int uflag, int Eflag)
{
	union {
		HEADER hdr;
		u_char buf[PACKETSZ];
	} answer;
	int  status;

	if ((dflag && memchr(address, '@@', len)) ||
	    (uflag && memchr(address, '!', len)))
		return(0);

	if ((_res.options & RES_INIT) == 0)
		res_init();

	status = res_search(host, C_IN, T_AAAA, answer.buf, sizeof(answer.buf));

	if (status == -1)
		status = res_search(host, C_IN, T_A, answer.buf, sizeof(answer.buf));

	if (status == -1 && Eflag)
		status = res_search(host, C_IN, T_MX, answer.buf, sizeof(answer.buf));

	return(status == -1);
}

static void
capitalize(char *name, int len)
{
	char last = ' ';
	char *c;
	int  i = 0;

	for (c = name; i < len; i++) {
		if (*c == '.')
			last = '.';
		c++;
	}

	i = 0;
	if (last == '.') {
		for (c = name; i < len; i++) {
			if (last == '.')
				*c = (char)toupper(*c);
			last = *c++;
		}
	}
}

static void
usage(void)
{
	fprintf(stderr,
	    "usage: mkalias [-nv] [-E | -e [-du]] input [output]\n");
	exit(1);
}

int
main(int argc, char *argv[])
{
	int	eflag = 0, dflag = 0, nflag = 0;
	int	uflag = 0, vflag = 0, Eflag = 0;
	int	status, ch, fd;
	char	*input = NULL, *output = NULL;
	DBM	*db;
	datum	key, val;
	DBM	*new_db = NULL;
	static	char mapname[] = "ypdbXXXXXXXXXX";
	char	db_mapname[PATH_MAX], db_outfile[PATH_MAX];
	char	db_tempname[PATH_MAX];
	char	user[4096], host[4096]; /* XXX: DB bsize = 4096 in ypdb.c */
	char	myname[HOST_NAME_MAX+1], datestr[11], *slash;

	while ((ch = getopt(argc, argv, "Edensuv")) != -1)
		switch (ch) {
		case 'E':
			eflag = 1;	/* Check hostname */
			Eflag = 1;	/* .. even check MX records */
			break;
		case 'd':
			dflag = 1;	/* Don't check DNS hostname */
			break;
		case 'e':
			eflag = 1;	/* Check hostname */
			break;
		case 'n':
			nflag = 1;	/* Capitalize name parts */
			break;
		case 's':		/* Ignore */ 
			break;
		case 'u':
			uflag = 1;	/* Don't check UUCP hostname */
			break;
		case 'v':
			vflag = 1;	/* Verbose */
			break;
		default:
			usage();
			break;
		}

	if (optind == argc)
		usage();

	input = argv[optind++];
	if (optind < argc)
		output = argv[optind++];
	if (optind < argc)
		usage();

	db = ypdb_open(input, O_RDONLY, 0444);
	if (db == NULL) {
		err(1, "Unable to open input database %s", input);
		/* NOTREACHED */
	}

	if (output != NULL) {
		if (strlen(output) + strlen(YPDB_SUFFIX) > PATH_MAX) {
			errx(1, "%s: file name too long", output);
			/* NOTREACHED */
		}

		snprintf(db_outfile, sizeof(db_outfile),
		    "%s%s", output, YPDB_SUFFIX);

		slash = strrchr(output, '/');
		if (slash != NULL)
			slash[1] = 0;			/* truncate to dir */
		else
			*output = 0;			/* eliminate */

		/* note: output is now directory where map goes ! */

		if (strlen(output) + strlen(mapname) +
		    strlen(YPDB_SUFFIX) > PATH_MAX) {
			errx(1, "%s: directory name too long", output);
			/* NOTREACHED */
		}

		snprintf(db_tempname, sizeof(db_tempname), "%s%s%s", output,
		    mapname, YPDB_SUFFIX);
		fd = mkstemps(db_tempname, 3);
		if (fd == -1)
			goto fail;
		close(fd);

		strncpy(db_mapname, db_tempname, strlen(db_tempname) - 3);
		db_mapname[sizeof(db_mapname) - 1] = '\0';

		new_db = ypdb_open(db_mapname, O_RDWR|O_TRUNC, 0444);
		if (new_db == NULL) {
fail:
			if (fd != -1)
				unlink(db_tempname);
			err(1, "Unable to open output database %s",
			    db_outfile);
			/* NOTREACHED */
		}
	}

	for (key = ypdb_firstkey(db); key.dptr != NULL;
	    key = ypdb_nextkey(db)) {
		val = ypdb_fetch(db, key);

		if (val.dptr == NULL)
			continue;			/* No value */
		if (*key.dptr == '@@' && key.dsize == 1)
			continue;			/* Sendmail token */
		if (strncmp(key.dptr, "YP_", 3)==0)	/* YP token */
			continue;
		if (memchr(val.dptr, ',', val.dsize))
			continue;			/* List... */
		if (memchr(val.dptr, '|', val.dsize))
			continue;			/* Pipe... */

		if (!(memchr(val.dptr, '@@', val.dsize) ||
		    memchr(val.dptr, '!', val.dsize)))
			continue;		/* Skip local users */

		split_address(val.dptr, val.dsize, user, host);

		if (eflag && check_host(val.dptr, val.dsize, host, dflag, uflag, Eflag)) {
			warnx("Invalid host %s in %*.*s:%*.*s",
			    host, key.dsize, key.dsize, key.dptr,
			    val.dsize, val.dsize, val.dptr);
			continue;
		}

		if (nflag)
			capitalize(key.dptr, key.dsize);

		if (new_db != NULL) {
			status = ypdb_store(new_db, val, key, YPDB_INSERT);
			if (status != 0) {
				warnx("problem storing %*.*s %*.*s",
				    val.dsize, val.dsize, val.dptr,
				    key.dsize, key.dsize, key.dptr);
			}
		}

		if (vflag) {
			printf("%*.*s --> %*.*s\n",
			    val.dsize, val.dsize, val.dptr,
			    key.dsize, key.dsize, key.dptr);
		}

	}

	if (new_db != NULL) {
		snprintf(datestr, sizeof datestr, "%010lld",
		    (long long)time(NULL));
		key.dptr = YP_LAST_KEY;
		key.dsize = strlen(YP_LAST_KEY);
		val.dptr = datestr;
		val.dsize = strlen(datestr);
		status = ypdb_store(new_db, key, val, YPDB_INSERT);
		if (status != 0) {
			warnx("problem storing %*.*s %*.*s",
			    key.dsize, key.dsize, key.dptr,
			    val.dsize, val.dsize, val.dptr);
		}
	}

	if (new_db != NULL) {
		gethostname(myname, sizeof(myname));
		key.dptr = YP_MASTER_KEY;
		key.dsize = strlen(YP_MASTER_KEY);
		val.dptr = myname;
		val.dsize = strlen(myname);
		status = ypdb_store(new_db, key, val, YPDB_INSERT);
		if (status != 0) {
			warnx("problem storing %*.*s %*.*s",
			    key.dsize, key.dsize, key.dptr,
			    val.dsize, val.dsize, val.dptr);
		}
	}

	ypdb_close(db);

	if (new_db != NULL) {
		ypdb_close(new_db);
		if (rename(db_tempname, db_outfile) < 0) {
			err(1, "rename %s -> %s failed", db_tempname,
			    db_outfile);
			/* NOTREACHED */
		}
	}
	return(0);
}
@


1.28
log
@clean up flags++ instances around getopt()
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.27 2015/01/16 06:40:23 deraadt Exp $ */
d41 1
@


1.27
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.26 2013/12/05 14:18:54 jca Exp $ */
d140 1
a140 1
	int	eflag = 0, dflag = 0, nflag = 0, sflag = 0;
d156 2
a157 2
			eflag++;	/* Check hostname */
			Eflag++;	/* .. even check MX records */
d160 1
a160 1
			dflag++;	/* Don't check DNS hostname */
d163 1
a163 1
			eflag++;	/* Check hostname */
d166 1
a166 1
			nflag++;	/* Capitalize name parts */
d168 1
a168 2
		case 's':
			sflag++;	/* Don't know... */
d171 1
a171 1
			uflag++;	/* Don't check UUCP hostname */
d174 1
a174 1
			vflag++;	/* Verbose */
@


1.26
log
@In split_address(), make 'i' a size_t.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.25 2013/08/22 04:43:41 guenther Exp $ */
a35 1
#include <sys/param.h>
d148 2
a149 2
	char	db_mapname[MAXPATHLEN], db_outfile[MAXPATHLEN];
	char	db_tempname[MAXPATHLEN];
d151 1
a151 1
	char	myname[MAXHOSTNAMELEN], datestr[11], *slash;
d198 1
a198 1
		if (strlen(output) + strlen(YPDB_SUFFIX) > MAXPATHLEN) {
d215 1
a215 1
		    strlen(YPDB_SUFFIX) > MAXPATHLEN) {
@


1.25
log
@Correct format string mismatches turned up by -Wformat=2

suggestions and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.24 2010/06/29 03:47:40 deraadt Exp $ */
d49 1
a49 1
	int  i = 0;
@


1.24
log
@force the dns buffers to be aligned using a union, until the retarded
"misalign strings on the stack" bug in gcc4 is fixed (even when that
is fixed this idiom is safer and quite common)
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.23 2009/10/27 23:59:58 deraadt Exp $ */
d291 2
a292 1
		snprintf(datestr, sizeof datestr, "%010u", time(NULL));
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.22 2009/10/20 09:47:03 sobrado Exp $ */
d83 4
a86 1
	u_char answer[PACKETSZ];
d96 1
a96 1
	status = res_search(host, C_IN, T_AAAA, answer, sizeof(answer));
d99 1
a99 1
		status = res_search(host, C_IN, T_A, answer, sizeof(answer));
d102 1
a102 1
		status = res_search(host, C_IN, T_MX, answer, sizeof(answer));
@


1.22
log
@improve the synopsis of mkalias(8) and sort the list of flags on
the manual page.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.21 2007/09/04 14:37:53 fgsch Exp $ */
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: mkalias.c,v 1.21 2007/09/04 14:37:53 fgsch Exp $";
#endif
@


1.21
log
@use memrchr; ok millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.20 2007/09/04 01:05:20 fgsch Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mkalias.c,v 1.20 2007/09/04 01:05:20 fgsch Exp $";
d135 1
a135 1
	    "usage: mkalias [-v] [-e|-E [-d] [-u]] [-n] input [output]\n");
@


1.20
log
@Use err(3) functions. input and ok millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.19 2007/08/05 14:25:48 fgsch Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mkalias.c,v 1.19 2007/08/05 14:25:48 fgsch Exp $";
a48 15
char *
findlast(const char *b, int c, size_t len)
{
	const char *p;

	if (len != 0) {
		p = b + len - 1;
		do {
			if (*p == c)
				return ((char *)p);
		} while (p-- != b);
	}
	return (NULL);
}

d69 1
a69 1
	if ((r = findlast(address, '!',  len))) {
@


1.19
log
@use memchr and a memrchr like implementation on non C strings. fixes
a crash triggered by specific malloc.conf settings.
with help and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.18 2006/11/10 20:44:07 mk Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mkalias.c,v 1.18 2006/11/10 20:44:07 mk Exp $";
d45 1
d210 2
a211 4
		fprintf(stderr,
		    "mkalias: Unable to open input database %s\n",
		    input);
		exit(1);
d216 2
a217 2
			fprintf(stderr,"mkalias: %s: file name too long\n",
			    output);
d219 1
d233 2
a234 3
			fprintf(stderr,"mkalias: %s: directory name too long\n",
			    output);
			exit(1);
d252 1
a252 2
			fprintf(stderr,
			    "mkalias: Unable to open output database %s\n",
d254 1
a254 1
			exit(1);
d280 1
a280 1
			printf("Invalid host %s in %*.*s:%*.*s\n",
d292 1
a292 1
				printf("mkalias: problem storing %*.*s %*.*s\n",
d314 1
a314 1
			printf("mkalias: problem storing %*.*s %*.*s\n",
d328 1
a328 1
			printf("mkalias: problem storing %*.*s %*.*s\n",
d339 3
a341 4
			perror("rename");
			fprintf(stderr,"rename %s -> %s failed!\n",
			    db_tempname, db_outfile);
			exit(1);
@


1.18
log
@`elminate' etc. is not really the right way to spell `eliminate'.

ok brad
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.17 2006/04/03 05:01:22 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mkalias.c,v 1.17 2006/04/03 05:01:22 deraadt Exp $";
d48 15
d64 1
a64 1
split_address(char *address, int len, char *user, char *host)
d69 1
a69 1
	if (strchr(address, '@@')) {
d83 1
a83 1
	if ((r = strrchr(address, '!'))) {
d99 1
a99 1
check_host(char *address, char *host, int dflag, int uflag, int Eflag)
d104 2
a105 2
	if ((dflag && strchr(address, '@@')) ||
	    (uflag && strchr(address, '!')))
d270 1
a270 1
		if (strchr(val.dptr, ','))
d272 1
a272 1
		if (strchr(val.dptr, '|'))
d275 2
a276 1
		if (!(strchr(val.dptr, '@@') || strchr(val.dptr, '!')))
d281 1
a281 1
		if (eflag && check_host(val.dptr, host, dflag, uflag, Eflag)) {
@


1.17
log
@spreading the lint love (very minimal things..)
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.16 2003/07/18 22:58:56 david Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mkalias.c,v 1.16 2003/07/18 22:58:56 david Exp $";
d212 1
a212 1
			*output = 0;			/* elminate */
@


1.16
log
@add missing includes
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.15 2003/07/15 06:10:46 deraadt Exp $ */
d29 2
a30 2
#ifndef LINT
static const char rcsid[] = "$OpenBSD: mkalias.c,v 1.15 2003/07/15 06:10:46 deraadt Exp $";
d124 1
a124 1
				*c = toupper(*c);
@


1.15
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.14 2003/06/02 21:58:26 maja Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mkalias.c,v 1.14 2003/06/02 21:58:26 maja Exp $";
d37 1
@


1.14
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.13 2003/05/05 08:37:05 avsm Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mkalias.c,v 1.13 2003/05/05 08:37:05 avsm Exp $";
d47 1
a47 1
void
d82 1
a82 1
int
d106 1
a106 1
void
d129 1
a129 1
void
@


1.13
log
@-Wall cleanup: trim unused vars, better err() message in stdhosts,
and constify rcsid[]

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.12 2002/09/06 21:37:38 maja Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mkalias.c,v 1.12 2002/09/06 21:37:38 maja Exp $";
@


1.12
log
@get correct parameter type to res_search. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.11 2002/07/19 20:59:40 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.11 2002/07/19 20:59:40 deraadt Exp $";
@


1.11
log
@bunch more careful tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.10 2002/07/19 02:38:40 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.10 2002/07/19 02:38:40 deraadt Exp $";
d90 1
a90 1
	char answer[PACKETSZ];
@


1.10
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.9 2002/06/09 02:21:55 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.9 2002/06/09 02:21:55 deraadt Exp $";
a51 2
extern char *__progname;		/* from crt0.o */

d134 8
d145 4
a148 11
	int	usage = 0;
	int	eflag = 0;
	int	dflag = 0;
	int	nflag = 0;
	int	sflag = 0;
	int	uflag = 0;
	int	vflag = 0;
	int	Eflag = 0;
	int	ch, fd;
	char	*input = NULL;
	char	*output = NULL;
a150 1
	char	*slash;
d153 2
a154 3
	char	db_mapname[MAXPATHLEN], db_outfile[MAXPATHLEN],
		db_tempname[MAXPATHLEN];
	int	status;
d156 1
a156 2
	char	datestr[11];
	char	myname[MAXHOSTNAMELEN];
d183 1
a183 1
			usage++;
d187 2
a188 9
	if (optind == argc) {
		usage++;
	} else {
		input = argv[optind++];
		if (optind < argc)
			output = argv[optind++];
		if (optind < argc)
			usage++;
	}
d190 5
a194 6
	if (usage) {
		fprintf(stderr,
		    "usage: %s [-v] [-e|-E [-d] [-u]] [-n] input [output]\n",
		    __progname);
		exit(1);
	}
d199 2
a200 2
		    "%s: Unable to open input database %s\n",
		    __progname, input);
d206 2
a207 2
			fprintf(stderr,"%s: %s: file name too long\n",
			    __progname, output);
d222 2
a223 2
			fprintf(stderr,"%s: %s: directory name too long\n",
				__progname, output);
d243 2
a244 2
			    "%s: Unable to open output database %s\n",
			    __progname, db_outfile);
d282 2
a283 2
				printf("%s: problem storing %*.*s %*.*s\n",
				    __progname, val.dsize, val.dsize, val.dptr,
d304 1
a304 2
			printf("%s: problem storing %*.*s %*.*s\n",
			    __progname,
d318 1
a318 2
			printf("%s: problem storing %*.*s %*.*s\n",
			    __progname,
@


1.9
log
@use strchr() instead of index(), strrchr() instead of rindex()
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.8 2002/03/27 02:19:57 fgsch Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.8 2002/03/27 02:19:57 fgsch Exp $";
d55 1
a55 4
split_address(address, len, user, host)
	char *address;
	int    len;
	char  *user, *host;
a71 1
	
d73 2
a74 2
		
	if (r = strrchr(address, '!')) {
d90 1
a90 3
check_host(address, host, dflag, uflag, Eflag)
	char *address, *host;
	int   dflag, uflag, Eflag;
d114 1
a114 3
capitalize(name, len)
	char *name;
	int len;
d125 1
a125 1
	
a133 1
	
d137 1
a137 3
main(argc, argv)
	int argc;
	char *argv[];
d161 1
a161 1
	
d163 1
a163 1
		switch(ch) {
d203 2
a204 2
			"usage: %s [-v] [-e|-E [-d] [-u]] [-n] input [output]\n",
			__progname);
d207 1
a207 1
	
d211 2
a212 3
			"%s: Unable to open input database %s\n",
			__progname,
			input);
d219 1
a219 1
			        __progname, output);
d222 1
a222 1
			 "%s%s", output, YPDB_SUFFIX);
d225 2
a226 2
		if (slash != NULL) 
			slash[1] = 0; 			/* truncate to dir */
d229 1
a229 1
	
d231 3
a233 3
	
		if (strlen(output) + strlen(mapname) 
				+ strlen(YPDB_SUFFIX) > MAXPATHLEN) {
d238 1
a238 1
	
d240 1
a240 1
			mapname, YPDB_SUFFIX);
d255 2
a256 3
				"%s: Unable to open output database %s\n",
				__progname,
				db_outfile);
d261 3
a263 5
	for (key = ypdb_firstkey(db);
	     key.dptr != NULL;
	     key = ypdb_nextkey(db)) {
		
	        val = ypdb_fetch(db, key);
d283 1
a283 2
			    host,
			    key.dsize, key.dsize, key.dptr,
d295 2
a296 3
				   __progname,
				   val.dsize, val.dsize, val.dptr,
				   key.dsize, key.dsize, key.dptr);
d302 2
a303 2
			   val.dsize, val.dsize, val.dptr,
			   key.dsize, key.dsize, key.dptr);
d309 1
a309 1
	  	snprintf(datestr, sizeof datestr, "%010u", time(NULL));
d317 3
a319 3
			   __progname,
			   key.dsize, key.dsize, key.dptr,
			   val.dsize, val.dsize, val.dptr);
d324 1
a324 1
	  	gethostname(myname, sizeof(myname));
d332 3
a334 3
			   __progname,
			   key.dsize, key.dsize, key.dptr,
			   val.dsize, val.dsize, val.dptr);
@


1.8
log
@instead of using mkstemp() to get a temporary name, use the created file,
so we don't end with ypdbXXXXXX files around; maja@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.7 2001/11/19 09:01:28 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.7 2001/11/19 09:01:28 deraadt Exp $";
d63 1
a63 1
	if (index(address, '@@')) {
d78 1
a78 1
	if (r = rindex(address, '!')) {
d101 2
a102 2
	if ((dflag && index(address, '@@')) ||
	    (uflag && index(address, '!')))
d286 1
a286 1
		if (index(val.dptr, ','))
d288 1
a288 1
		if (index(val.dptr, '|'))
d291 1
a291 1
		if (!(index(val.dptr, '@@') || index(val.dptr, '!')))
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.6 2001/02/05 14:47:17 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.6 2001/02/05 14:47:17 deraadt Exp $";
d251 3
a253 3
		snprintf(db_tempname, sizeof(db_tempname), "%s%s", output,
			mapname);
		fd = mkstemp(db_tempname);
d258 4
a261 3
		snprintf(db_mapname, sizeof(db_mapname), "%s%s", db_tempname,
			YPDB_SUFFIX);
		new_db = ypdb_open(db_tempname, O_RDWR|O_CREAT, 0444);
d359 1
a359 1
		if (rename(db_mapname, db_outfile) < 0) {
d361 2
a362 2
			fprintf(stderr,"rename %s -> %s failed!\n", db_mapname,
			    db_outfile);
@


1.6
log
@sprintf purge
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.5 1998/07/09 06:33:04 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.5 1998/07/09 06:33:04 deraadt Exp $";
d56 3
a58 3
char *address;
int    len;
char  *user, *host;
d60 1
a60 1
	char *c,*s,*r;
d63 1
a63 2
	if (index(address,'@@')) {
		
d65 1
a65 2
		
		for(c = address; i < len; i++) {
d78 1
a78 2
	if (r = rindex(address,'!')) {
		
d80 1
a80 2
		
		for(c = address; i < len; i++) {
a89 1
		
a90 1
		
d95 2
a96 2
char *address, *host;
int   dflag, uflag, Eflag;
d101 3
a103 2
	if ((dflag && index(address,'@@')) ||
	    (uflag && index(address,'!'))) return(0);
d113 1
a113 1
	if ((status == -1) && Eflag)
d120 3
a122 3
capitalize(name,len)
char *name;
int len;
d128 3
a130 2
	for(c = name; i < len; i++) {
		if (*c == '.') last = '.';
d136 2
a137 2
		for(c = name; i < len; i++) {
			if (last == '.') {
a138 1
			}
d146 3
a148 3
main (argc,argv)
int argc;
char *argv[];
d162 1
a162 1
	datum	key,val;
d166 1
a166 1
	char	db_mapname[MAXPATHLEN],db_outfile[MAXPATHLEN],
d169 1
a169 1
	char	user[4096],host[4096]; /* XXX: DB bsize = 4096 in ypdb.c */
d277 1
a277 1
	        val = ypdb_fetch(db,key);
d279 3
a281 2
		if (val.dptr == NULL) continue;		/* No value */
		if ((*key.dptr == '@@') && (key.dsize == 1))
d285 4
a288 2
		if (index(val.dptr,',')) continue;	/* List... */
		if (index(val.dptr,'|')) continue;	/* Pipe... */
d290 2
a291 2
		if (!((index(val.dptr,'@@')) ||
		      (index(val.dptr,'!')))) continue;	/* Skip local users */
d293 1
a293 1
		split_address(val.dptr,val.dsize,user,host);
d297 3
a299 3
			       host,
			       key.dsize, key.dsize, key.dptr,
			       val.dsize, val.dsize, val.dptr);
d303 2
a304 3
		if (nflag) {
			capitalize(key.dptr,key.dsize);
		}
d310 3
a312 3
				       __progname,
				       val.dsize, val.dsize, val.dptr,
				       key.dsize, key.dsize, key.dptr);
d318 2
a319 2
			       val.dsize, val.dsize, val.dptr,
			       key.dsize, key.dsize, key.dptr);
d333 3
a335 3
			       __progname,
			       key.dsize, key.dsize, key.dptr,
			       val.dsize, val.dsize, val.dptr);
d348 3
a350 3
			       __progname,
			       key.dsize, key.dsize, key.dptr,
			       val.dsize, val.dsize, val.dptr);
a353 2
	

d358 1
a358 1
		if (rename(db_mapname,db_outfile) < 0) {
d361 1
a361 1
				db_outfile);
a364 1
	
a365 1
	
@


1.5
log
@do not gethostname with len-1
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.4 1998/03/12 08:22:28 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.4 1998/03/12 08:22:28 deraadt Exp $";
d328 1
a328 1
	  	sprintf(datestr, "%010d", time(NULL));
@


1.4
log
@mkstemp()
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.3 1997/07/28 22:48:01 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.3 1997/07/28 22:48:01 deraadt Exp $";
d343 1
a343 1
	  	gethostname(myname, sizeof(myname) - 1);
@


1.3
log
@NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.2 1997/07/26 22:07:22 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.2 1997/07/26 22:07:22 maja Exp $";
d163 1
a163 1
	int	ch;
d179 27
a205 27
	  switch(ch) {
	  case 'E':
	    eflag++;			/* Check hostname */
	    Eflag++;			/* .. even check MX records */
	    break;
	  case 'd':
	    dflag++;			/* Don't check DNS hostname */
	    break;
	  case 'e':
	    eflag++;			/* Check hostname */
	    break;
	  case 'n':
	    nflag++;			/* Capitalize name parts */
	    break;
	  case 's':
	    sflag++;			/* Don't know... */
	    break;
	  case 'u':
	    uflag++;			/* Don't check UUCP hostname */
	    break;
	  case 'v':
	    vflag++;			/* Verbose */
	    break;
	  default:
	    usage++;
	    break;
	  }
d258 5
a262 1
		mktemp(db_tempname);
a264 1
	
d267 3
@


1.2
log
@Fix bug in handling host!host!user. Added missing code for YP information
records. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mkalias.c,v 1.1 1997/07/26 12:12:29 maja Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mkalias.c,v 1.1 1997/07/26 12:12:29 maja Exp $";
d322 1
a322 1
	  	sprintf(datestr, "%010d", time(0));
@


1.1
log
@The second of three steps to support main.aliases and mail.byaddr in ypserv.
This time it's time for a new utility program mkalias. The last part is
arriving any day now... -moj
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD$";
d60 1
a60 1
	char *c,*s;
d80 1
a80 1
	if (index(address,'!')) {
d85 1
a85 1
			if (*c == '!') {
d94 1
a94 1
	
d175 2
d320 32
@

