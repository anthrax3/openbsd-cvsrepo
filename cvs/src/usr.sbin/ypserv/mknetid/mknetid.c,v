head	1.22;
access;
symbols
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.12
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.8
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.4
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.16
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.14
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.12
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.10
	OPENBSD_5_0:1.18.0.8
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.12
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2015.02.09.23.00.15;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	822YD61EeG0Xl9Na;

1.21
date	2015.01.16.06.40.23;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	Uu5nFG3wCl0LACBb;

1.20
date	2013.12.04.02.18.05;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2013.08.18.16.32.24;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.20.12.33.59;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.58;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.16.09.46.40;	author sobrado;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.23.22.21.17;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.03.05.01.23;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.14.02.32.32;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.21.58.26;	author maja;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.05.08.37.05;	author avsm;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.19.20.59.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.13.23.10.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.11.23.37.22;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.02.24.04.29.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.09.11.19.47.30;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.44.33;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.05.30.09.53.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.03.02.03.01.34;	author dm;	state Exp;
branches;
next	;


desc
@@


1.22
log
@clean up flags++ instances around getopt()
ok florian
@
text
@/*	$OpenBSD: mknetid.c,v 1.21 2015/01/16 06:40:23 deraadt Exp $ */

/*
 * Copyright (c) 1996 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <unistd.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <pwd.h>
#include <grp.h>
#include <err.h>
#include <netdb.h>
#include <limits.h>

#include <rpcsvc/ypclnt.h>

struct user {
	char	*usr_name;		/* user name */
	int	usr_uid;		/* user uid */
	int	usr_gid;		/* user gid */
	int	gid_count;		/* number of gids */
	int	gid[NGROUPS_MAX];	/* additional gids */
	struct user *prev, *next;	/* links in read order */
	struct user *hprev, *hnext;	/* links in hash order */
};

char *HostFile = _PATH_HOSTS;
char *PasswdFile = _PATH_PASSWD;
char *MasterPasswdFile = _PATH_MASTERPASSWD;
char *GroupFile = _PATH_GROUP;
char *NetidFile = "/etc/netid";

#define HASHMAX 55

struct user *root = NULL, *tail = NULL;
struct user *hroot[HASHMAX], *htail[HASHMAX];

static int
read_line(FILE *fp, char *buf, int size)
{
	int done = 0;

	do {
		while (fgets(buf, size, fp)) {
			int len = strlen(buf);

			done += len;
			if (len > 1 && buf[len-2] == '\\' &&
			    buf[len-1] == '\n') {
				int ch;

				buf += len - 2;
				size -= len - 2;
				*buf = '\n'; buf[1] = '\0';

				/*
				 * Skip leading white space on next line
				 */
				while ((ch = getc(fp)) != EOF &&
				    isascii(ch) && isspace(ch))
					;
				(void) ungetc(ch, fp);
			} else {
				return done;
			}
		}
	} while (size > 0 && !feof(fp));

	return done;
}

static int
hashidx(char key)
{
	if (key < 'A')
		return (0);
	if (key <= 'Z')
		return (1 + key - 'A');
	if (key < 'a')
		return (27);
	if (key <= 'z')
		return (28 + key - 'a');
	return (54);
}

static void
add_user(char *username, char *uid, char *gid)
{
	struct user *u;
	int idx;

	u = malloc(sizeof(struct user));
	if (u == NULL)
		err(1, "malloc");
	bzero(u, sizeof(struct user));
	u->usr_name = strdup(username);
	if (u->usr_name == NULL)
		err(1, "strdup");
	u->usr_uid = atoi(uid);
	u->usr_gid = atoi(gid);
	u->gid_count = -1;
	if (root == NULL) {
		root = tail = u;
	} else {
		u->prev = tail;
		tail->next = u;
		tail = u;
	}
	idx = hashidx(username[0]);
	if (hroot[idx] == NULL) {
		hroot[idx] = htail[idx] = u;
	} else {
		u->hprev = htail[idx];
		htail[idx]->hnext = u;
		htail[idx] = u;
	}
}

static void
add_group(char *username, char *gid)
{
	struct user *u;
	int idx, g;

	idx = hashidx(username[0]);
	u = hroot[idx];
	g = atoi(gid);

	while (u != NULL) {
		if (strcmp(username, u->usr_name) == 0) {
			if (g != u->usr_gid) {
				u->gid_count++;
				if (u->gid_count < NGROUPS_MAX)
					u->gid[u->gid_count] = atoi(gid);
			}
			u = htail[idx];
		}
		u = u->hnext;
	}
}

static void
read_passwd(FILE *pfile, char *fname)
{
	char  line[1024], *p, *k, *u, *g;
	int   line_no = 0, len, colon;

	while (read_line(pfile, line, sizeof(line))) {
		line_no++;
		len = strlen(line);

		if (len > 0) {
			if (line[0] == '#')
				continue;
		}

		/*
		 * Check if we have the whole line
		 */
		if (line[len-1] != '\n') {
			fprintf(stderr, "line %d in \"%s\" is too long\n",
			    line_no, fname);
		} else {
			line[len-1] = '\0';
		}

		p = (char *)&line;

		k = p; colon = 0;
		while (*k != '\0') {
			if (*k == ':')
				colon++;
			k++;
		}

		if (colon > 0) {
			k = p;			/* save start of key  */
			while (*p != ':')
				p++;		/* find first "colon" */
			if (*p==':')
				*p++ = '\0';	/* terminate key */
			if (strlen(k) == 1) {
				if (*k == '+')
					continue;
			}
		}

		if (colon < 4) {
			fprintf(stderr, "syntax error at line %d in \"%s\"\n",
			    line_no, fname);
			continue;
		}

		while (*p != ':')
			p++;			/* find second "colon" */
		if (*p==':')
			*p++ = '\0';		/* terminate passwd */
		u = p;
		while (*p != ':')
			p++;			/* find third "colon" */
		if (*p==':')
			*p++ = '\0';		/* terminate uid */
		g = p;
		while (*p != ':')
			p++;			/* find fourth "colon" */
		if (*p==':')
			*p++ = '\0';		/* terminate gid */
		while (*p != '\0')
			p++;	/* find end of string */

		add_user(k, u, g);
	}
}

static int
isgsep(char ch)
{
	switch (ch)  {
	case ',':
	case ' ':
	case '\t':
	case '\0':
		return (1);
	default:
		return (0);
	}
}

static void
read_group(FILE *gfile, char *fname)
{
	char  line[2048], *p, *k, *u, *g;
	int   line_no = 0, len, colon;

	while (read_line(gfile, line, sizeof(line))) {
		line_no++;
		len = strlen(line);

		if (len > 0) {
			if (line[0] == '#')
				continue;
		}

		/*
		 * Check if we have the whole line
		 */
		if (line[len-1] != '\n') {
			fprintf(stderr, "line %d in \"%s\" is too long\n",
			    line_no, fname);
		} else {
			line[len-1] = '\0';
		}

		p = (char *)&line;

		k = p; colon = 0;
		while (*k != '\0') {
			if (*k == ':')
				colon++;
			k++;
		}

		if (colon > 0) {
			k = p;			/* save start of key  */
			while (*p != ':')
				p++;		/* find first "colon" */
			if (*p==':')
				*p++ = '\0';	/* terminate key */
			if (strlen(k) == 1) {
				if (*k == '+')
					continue;
			}
		}

		if (colon < 3) {
			fprintf(stderr, "syntax error at line %d in \"%s\"\n",
			    line_no, fname);
			continue;
		}

		while (*p != ':')
			p++;			/* find second "colon" */
		if (*p==':')
			*p++ = '\0';		/* terminate passwd */
		g = p;
		while (*p != ':')
			p++;			/* find third "colon" */
		if (*p==':')
			*p++ = '\0';		/* terminate gid */

		u = p;

		while (*u != '\0') {
			while (!isgsep(*p))
				p++;		/* find separator */
			if (*p != '\0') {
				*p = '\0';
				if (u != p)
					add_group(u, g);
				p++;
			} else {
				if (u != p)
					add_group(u, g);
			}
			u = p;
		}
	}
}

static void
print_passwd_group(int qflag, char *domain)
{
	struct user *u, *p;
	int i;

	u = root;

	while (u != NULL) {
		p = root;
		while (p->usr_uid != u->usr_uid)
			p = p->next;

		if (p != u) {
			if (!qflag) {
				fprintf(stderr, "mknetid: unix.%d@@%s %s\n",
				    u->usr_uid, domain,
				    "multiply defined, other definitions ignored");
			}
		} else {
			printf("unix.%d@@%s %d:%d",
			    u->usr_uid, domain, u->usr_uid, u->usr_gid);
			if (u->gid_count >= 0) {
				i = 0;
				while (i <= u->gid_count) {
					printf(",%d", u->gid[i]);
					i++;
				}
			}
			printf("\n");
		}
		u = u->next;
	}
}

static void
print_hosts(FILE *pfile, char *fname, char *domain)
{
	char  line[1024], *p, *u;
	int   line_no = 0, len;

	while (read_line(pfile, line, sizeof(line))) {
		line_no++;
		len = strlen(line);

		if (len > 0) {
			if (line[0] == '#')
				continue;
		}

		/*
		 * Check if we have the whole line
		 */
		if (line[len-1] != '\n') {
			fprintf(stderr, "line %d in \"%s\" is too long\n",
			    line_no, fname);
		} else {
			line[len-1] = '\0';
		}

		p = (char *)&line;

		while (!isspace((unsigned char)*p))
			p++;			/* find first "space" */
		while (isspace((unsigned char)*p))
			*p++ = '\0';		/* replace space with <NUL> */

		u = p;
		while (p != NULL) {
			if (*p == '\0') {
				p = NULL;
			} else {
				if (!isspace((unsigned char)*p)) {
					p++;
				} else {
					*p = '\0';
					p = NULL;
				}
			}
		}

		printf("unix.%s@@%s 0:%s\n", u, domain, u);
	}
}

static void
print_netid(FILE *mfile, char *fname)
{
	char  line[1024], *p, *k, *u;
	int   line_no = 0, len;

	while (read_line(mfile, line, sizeof(line))) {
		line_no++;
		len = strlen(line);

		if (len > 0) {
			if (line[0] == '#')
				continue;
		}

		/*
		 * Check if we have the whole line
		 */
		if (line[len-1] != '\n') {
			fprintf(stderr, "line %d in \"%s\" is too long\n",
			    line_no, fname);
		} else {
			line[len-1] = '\0';
		}

		p = (char *)&line;

		k = p;				/* save start of key  */
		while (!isspace((unsigned char)*p))
			p++;			/* find first "space" */
		while (isspace((unsigned char)*p))
			*p++ = '\0';		/* replace space with <NUL> */

		u = p;
		while (p != NULL) {
			if (*p == '\0') {
				p = NULL;
			} else {
				if (!isspace((unsigned char)*p)) {
					p++;
				} else {
					*p = '\0';
					p = NULL;
				}
			}
		}

		printf("%s %s\n", k, u);
	}
}

static void
usage(void)
{
	fprintf(stderr, "usage: mknetid [-q] [-d domain] [-g groupfile] "
	    "[-h hostfile] [-m netidfile]\n"
	    "               [-P master.passwdfile] [-p passwdfile]\n");
	exit(1);
}

int
main(int argc, char *argv[])
{
	FILE   *pfile, *gfile, *hfile, *mfile;
	int	qflag = 0, ch;
	char   *domain = NULL;

	while ((ch = getopt(argc, argv, "d:g:h:m:p:P:q")) != -1)
		switch (ch) {
		case 'd':
			domain = optarg;
			break;
		case 'g':
			GroupFile = optarg;
			break;
		case 'h':
			HostFile = optarg;
			break;
		case 'm':
			NetidFile = optarg;
			break;
		case 'p':
			PasswdFile = optarg;
			break;
		case 'P':
			MasterPasswdFile = optarg;
			break;
		case 'q':
			qflag = 1;
			break;
		default:
			usage();
			break;
		}

	if (argc > optind)
		usage();

	if (domain == NULL)
		yp_get_default_domain(&domain);

	pfile = fopen(PasswdFile, "r");
	if (pfile == NULL)
		pfile = fopen(MasterPasswdFile, "r");
	if (pfile == NULL)
		err(1, "%s", MasterPasswdFile);

	gfile = fopen(GroupFile, "r");
	if (gfile == NULL)
		err(1, "%s", GroupFile);

	hfile = fopen(HostFile, "r");
	if (hfile == NULL)
		err(1, "%s", HostFile);

	mfile = fopen(NetidFile, "r");

	read_passwd(pfile, PasswdFile);
	read_group(gfile, GroupFile);

	print_passwd_group(qflag, domain);
	print_hosts(hfile, HostFile, domain);

	if (mfile != NULL)
		print_netid(mfile, NetidFile);

	return 0;
}
@


1.21
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.20 2013/12/04 02:18:05 deraadt Exp $ */
d508 1
a508 1
			qflag++;
@


1.20
log
@ctype improvements; checked by okan
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.19 2013/08/18 16:32:24 guenther Exp $ */
a28 1
#include <sys/param.h>
d38 1
d47 1
a47 1
	int	gid[NGROUPS];		/* additional gids */
d158 1
a158 1
				if (u->gid_count < NGROUPS)
@


1.19
log
@Fix calls to printf-like functions which passed a non-fixed string
as the format and no variable args.
Replace "%#0.*X" with "%#.*X": the zero-fill flag is ignored/implied
on numeric conversions when a precision is specified.

ok jung@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.18 2009/12/20 12:33:59 schwarze Exp $ */
d397 1
a397 1
		while (!isspace(*p))
d399 1
a399 1
		while (isspace(*p))
d407 1
a407 1
				if (!isspace(*p)) {
d448 1
a448 1
		while (!isspace(*p))
d450 1
a450 1
		while (isspace(*p))
d458 1
a458 1
				if (!isspace(*p)) {
@


1.18
log
@When a passwd(5) file is not available, fall back to master.passwd(5).
That's useful because the latter is needed for passwd-maps, anyway.
Make the master.passwd file name configurable in the same way as passwd.

While here, do a bit of cleanup:
 - Drop the HOSTS, PASSWD, GROUP, NETID #defines:
   They are used nowhere else and serve no purpose.
 - Use err(3), it's simpler and more precise than fprintf(3)+goto.
 - Drop a debug statement forgotten a decade ago.
 - In the manual, improve .Nd, DESCRIPTION and .Xrs.

Originally triggered by edd@@'s gripes with our yp implementation.
Regarding the manual, using many tweaks from jmc@@.

"I like this" ajacoutot@@
"I think it's a good idea" edd@@
"no opinion", "you decide" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.17 2009/10/27 23:59:58 deraadt Exp $ */
d525 1
a525 1
		err(1, MasterPasswdFile);
d529 1
a529 1
		err(1, GroupFile);
d533 1
a533 1
		err(1, HostFile);
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.16 2009/10/16 09:46:40 sobrado Exp $ */
a51 3
#ifdef HOSTS
char *HostFile = HOSTS;
#else
a52 5
#endif

#ifdef PASSWD
char *PasswdFile = PASSWD;
#else
d54 1
a54 5
#endif

#ifdef GROUP
char *GroupFile = GROUP;
#else
a55 5
#endif

#ifdef NETID
char *NetidFile = NETID;
#else
a56 1
#endif
d476 1
a476 1
	    "               [-p passwdfile]\n");
d487 1
a487 1
	while ((ch = getopt(argc, argv, "d:g:h:m:p:q")) != -1)
d504 3
d522 4
a525 5
	if (pfile == NULL) {
		fprintf(stderr,"mknetid: can't open file \"%s\"\n",
		    PasswdFile);
		goto bad;
	}
d528 2
a529 5
	if (gfile == NULL) {
		fprintf(stderr,"mknetid: can't open file \"%s\"\n",
		    GroupFile);
		goto bad;
	}
d532 2
a533 5
	if (hfile == NULL) {
		fprintf(stderr,"mknetid: can't open file \"%s\"\n",
		    HostFile);
		goto bad;
	}
a534 1
	printf("NetidFile: %s\n", NetidFile);
a544 1
	return (0);
d546 1
a546 3
bad:
	fprintf(stderr, "mknetid: passwd, group, host and netid maps not updated!\n");
	exit(1);
@


1.16
log
@sort flags in synopsis, usage, and description.
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.15 2008/02/23 22:21:17 deraadt Exp $ */
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: mknetid.c,v 1.15 2008/02/23 22:21:17 deraadt Exp $";
#endif
@


1.15
log
@correct pathnames reported; pr#5742
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.14 2006/04/03 05:01:23 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mknetid.c,v 1.14 2006/04/03 05:01:23 deraadt Exp $";
d496 3
a498 3
	fprintf(stderr,
	    "usage: mknetid [-d domain] [-q] [-p passwdfile] [-g groupfile]\n"
	    "               [-h hostfile] [-m netidfile]\n");
@


1.14
log
@spreading the lint love (very minimal things..)
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.13 2005/05/14 02:32:32 deraadt Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mknetid.c,v 1.13 2005/05/14 02:32:32 deraadt Exp $";
d544 1
a544 1
		exit(1);
d550 2
a551 2
		    PasswdFile);
		exit(1);
d557 2
a558 2
		    PasswdFile);
		exit(1);
d573 4
@


1.13
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.12 2003/07/15 06:10:46 deraadt Exp $ */
d29 2
a30 2
#ifndef LINT
static const char rcsid[] = "$OpenBSD: mknetid.c,v 1.12 2003/07/15 06:10:46 deraadt Exp $";
d139 1
a139 1
	u = (struct user *) malloc(sizeof(struct user));
d214 1
a214 1
		p = (char *) &line;
d301 1
a301 1
		p = (char *) &line;
d395 1
a395 1
	char  line[1024], *p, *k, *u;
d417 1
a417 1
		p = (char *) &line;
a418 1
		k = p;				/* save start of key  */
d467 1
a467 1
		p = (char *) &line;
@


1.12
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.11 2003/06/02 21:58:26 maja Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mknetid.c,v 1.11 2003/06/02 21:58:26 maja Exp $";
d93 1
d98 1
d180 2
a181 3
				if (u->gid_count < NGROUPS) {
					u->gid[u->gid_count]=atoi(gid);
				}
d192 2
a193 4
	char  line[1024];
	int   line_no = 0;
	int   len, colon;
	char  *p, *k, *u, *g;
d279 2
a280 4
	char  line[2048];
	int   line_no = 0;
	int   len, colon;
	char  *p, *k, *u, *g;
d395 2
a396 4
	char  line[1024];
	int   line_no = 0;
	int   len;
	char  *p, *k, *u;
d446 2
a447 4
	char  line[1024];
	int   line_no = 0;
	int   len;
	char  *p, *k, *u;
@


1.11
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.10 2003/05/05 08:37:05 avsm Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mknetid.c,v 1.10 2003/05/05 08:37:05 avsm Exp $";
d85 1
a85 1
int
d117 1
a117 1
int
d131 1
a131 1
void
d164 2
a165 1
void add_group(char *username, char *gid)
d188 1
a188 1
void
d263 1
a263 1
int
d277 1
a277 1
void
d360 1
a360 1
void
d395 1
a395 1
void
d448 1
a448 1
void
d501 1
a501 1
void
@


1.10
log
@-Wall cleanup: trim unused vars, better err() message in stdhosts,
and constify rcsid[]

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.9 2002/07/19 20:59:40 deraadt Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: mknetid.c,v 1.9 2002/07/19 20:59:40 deraadt Exp $";
@


1.9
log
@bunch more careful tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.8 2002/07/19 02:38:40 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mknetid.c,v 1.8 2002/07/19 02:38:40 deraadt Exp $";
@


1.8
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.7 2002/02/13 23:10:46 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mknetid.c,v 1.7 2002/02/13 23:10:46 deraadt Exp $";
a86 1
char *ProgramName = "mknetid";
d379 2
a380 2
				fprintf(stderr, "%s: unix.%d@@%s %s\n",
				    ProgramName, u->usr_uid, domain,
d505 9
a516 2
	int	qflag, ch, usage;
	char   *domain;
d518 2
a519 3

	qflag = usage = 0;
	domain = NULL;
d542 1
a542 1
			usage++;
d546 2
a547 3
	if (argc > optind) {
		usage++;
	}
d549 1
a549 9
	if (usage) {
		fprintf(stderr,
		    "usage:\t%s [-d domain] [-q] [-p passwdfile] [-g groupfile]\n"
		    "\t\t[-h hostfile] [-m netidfile]\n",
		    ProgramName);
		exit(1);
	}

	if (domain == NULL) {
a550 1
	}
d554 2
a555 2
		fprintf(stderr,"%s: can't open file \"%s\"\n",
		    ProgramName, PasswdFile);
d561 2
a562 2
		fprintf(stderr,"%s: can't open file \"%s\"\n",
		    ProgramName, PasswdFile);
d568 2
a569 2
		fprintf(stderr,"%s: can't open file \"%s\"\n",
		    ProgramName, PasswdFile);
@


1.7
log
@some more KNF and -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.6 2001/01/11 23:37:22 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mknetid.c,v 1.6 2001/01/11 23:37:22 deraadt Exp $";
d92 1
a92 4
read_line(fp, buf, size)
	FILE *fp;
	char *buf;
	int size;
d124 1
a124 2
hashidx(key)
char key;
d138 1
a138 2
add_user(username, uid, gid)
char *username, *uid, *gid;
d170 1
a170 2
void add_group(username, gid)
char *username, *gid;
d194 1
a194 3
read_passwd(pfile, fname)
FILE *pfile;
char *fname;
d212 1
a212 1
		 */ 
d269 1
a269 2
isgsep(ch)
	char ch;
d271 1
a271 1
	switch(ch)  {
d283 1
a283 3
read_group(gfile, fname)
	FILE *gfile;
	char *fname;
d366 1
a366 3
print_passwd_group(qflag, domain)
	int qflag;
	char *domain;
d401 1
a401 3
print_hosts(pfile, fname, domain)
	FILE *pfile;
	char *fname, *domain;
d419 1
a419 1
		 */ 
d454 1
a454 3
print_netid(mfile, fname)
FILE *mfile;
char *fname;
d472 1
a472 1
		 */ 
d507 1
a507 3
main(argc, argv)
	int argc;
	char *argv[];
@


1.6
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.5 1998/02/24 04:29:05 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mknetid.c,v 1.5 1998/02/24 04:29:05 deraadt Exp $";
d46 1
d49 2
d420 1
a420 1
	int   len, colon;
d475 1
a475 1
	int   len, colon;
@


1.5
log
@pull in prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.4 1997/09/11 19:47:30 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mknetid.c,v 1.4 1997/09/11 19:47:30 deraadt Exp $";
d54 2
a55 2
	struct user *prev,*next;	/* links in read order */
	struct user *hprev,*hnext;	/* links in hash order */
d88 2
a89 1
static int read_line(fp, buf, size)
d101 1
a101 1
					buf[len-1] == '\n') {
d106 1
d111 2
a112 2
					isascii(ch) && isspace(ch))
						;
d128 1
a128 1
		return(0);
d130 1
a130 1
		return(1 + key - 'A');
d132 1
a132 1
		return(27);
d134 2
a135 2
		return(28 + key - 'a');
	return(54);
d138 2
a139 1
void add_user(username, uid, gid)
d146 9
a154 6
	bzero((void *) u,sizeof(struct user));
	u->usr_name = (char *) malloc(strlen(username) + 1);
	strcpy(u->usr_name,username);
	u->usr_uid=atoi(uid);
	u->usr_gid=atoi(gid);
	u->gid_count=-1;
d181 1
a181 1
	
d183 1
a183 1
		if (strcmp(username,u->usr_name) == 0) {
d204 1
a204 1
	char  *p,*k,*u,*g;
d206 1
a206 2
	while (read_line(pfile,line,sizeof(line))) {
		
d209 1
a209 1
		
a217 1
		
d219 2
a220 3
			fprintf(stderr,
				"line %d in \"%s\" is too long\n",
				line_no, fname);
d226 1
a226 1
		
d235 5
a239 3
			k = p;			     /* save start of key  */
			while (*p != ':') { p++; };  /* find first "colon" */
			if (*p==':') { *p = '\0'; p++; }; /* terminate key */
d245 1
a245 1
		
d247 2
a248 3
			fprintf(stderr,
				"syntax error at line %d in \"%s\"\n",
				line_no, fname);
d252 4
a255 2
		while (*p != ':') { p++; };	/* find second "colon" */
		if (*p==':') { *p = '\0'; p++; }; /* terminate passwd */
d257 4
a260 2
		while (*p != ':') { p++; };	/* find third "colon" */
		if (*p==':') { *p = '\0'; p++; }; /* terminate uid */
d262 8
a269 5
		while (*p != ':') { p++; };	/* find forth "colon" */
		if (*p==':') { *p = '\0'; p++; }; /* terminate gid */
		while(*p != '\0') { p++; };	/* find end of string */
		
		add_user(k,u,g);
d275 1
a275 1
char ch;
a276 2
	int ret;

d282 1
a282 2
		ret = 1;
		break;
d284 1
a284 1
		ret = 0;
a285 2

	return ret;
d290 2
a291 2
FILE *gfile;
char *fname;
d296 1
a296 1
	char  *p,*k,*u,*g;
d298 1
a298 2
	while (read_line(gfile,line,sizeof(line))) {
		
d301 1
a301 1
		
d309 1
a309 2
		 */ 
		
d311 2
a312 3
			fprintf(stderr,
				"line %d in \"%s\" is too long\n",
				line_no, fname);
d318 1
a318 1
		
d327 5
a331 3
			k = p;			     /* save start of key  */
			while (*p != ':') { p++; };  /* find first "colon" */
			if (*p==':') { *p = '\0'; p++; }; /* terminate key */
d337 1
a337 1
		
d339 2
a340 3
			fprintf(stderr,
				"syntax error at line %d in \"%s\"\n",
				line_no, fname);
d344 4
a347 2
		while (*p != ':') { p++; };	/* find second "colon" */
		if (*p==':') { *p = '\0'; p++; }; /* terminate passwd */
d349 4
a352 2
		while (*p != ':') { p++; };	/* find third "colon" */
		if (*p==':') { *p = '\0'; p++; }; /* terminate gid */
d357 2
a358 1
			while (!isgsep(*p)) { p++; };	/* find separator */
d361 2
a362 3
				if (u != p) {
					add_group(u,g);
				}
d365 2
a366 3
				if (u != p) {
					add_group(u,g);
				}
d374 3
a376 3
print_passwd_group(qflag,domain)
int qflag;
char *domain;
d378 1
a378 1
	struct user *u,*p;
d385 1
a385 1
		while(p->usr_uid != u->usr_uid) {
d387 1
a387 1
		}
d390 3
a392 6
				fprintf(stderr,
					"%s: unix.%d@@%s %s\n",
					ProgramName,
					u->usr_uid,
					domain,
					"multiply defined, other definitions ignored");
d396 1
a396 4
				u->usr_uid,
				domain,
			       u->usr_uid,
			       u->usr_gid);
d398 1
a398 1
				i=0;
d400 1
a400 1
					printf(",%d",u->gid[i]);
d412 2
a413 2
FILE *pfile;
char *fname, *domain;
d418 1
a418 1
	char  *p,*k,*u;
d420 1
a420 2
	while (read_line(pfile,line,sizeof(line))) {
		
d423 1
a423 1
		
a431 1
		
d433 2
a434 3
			fprintf(stderr,
				"line %d in \"%s\" is too long\n",
				line_no, fname);
d440 1
a440 1
		
d442 4
a445 5
		while (!isspace(*p)) { p++; };	/* find first "space" */
		while (isspace(*p)) {		/* replace space with <NUL> */
			*p = '\0';
			p++;
		}
d461 1
a461 4
		printf("unix.%s@@%s 0:%s\n",
		       u,
		       domain,
		       u);
d473 1
a473 1
	char  *p,*k,*u;
d475 1
a475 2
	while (read_line(mfile,line,sizeof(line))) {
		
d478 1
a478 1
		
a486 1
		
d488 2
a489 3
			fprintf(stderr,
				"line %d in \"%s\" is too long\n",
				line_no, fname);
d495 1
a495 1
		
d497 4
a500 5
		while (!isspace(*p)) { p++; };	/* find first "space" */
		while (isspace(*p)) {		/* replace space with <NUL> */
			*p = '\0';
			p++;
		}
d516 1
a516 1
		printf("%s %s\n",k,u);
d521 3
a523 3
main (argc,argv)
int argc;
char *argv[];
d531 1
a531 1
	
d534 21
a554 21
			case 'd':
				domain = optarg;
				break;
			case 'g':
				GroupFile = optarg;
				break;
			case 'h':
				HostFile = optarg;
				break;
			case 'm':
				NetidFile = optarg;
				break;
			case 'p':
				PasswdFile = optarg;
				break;
			case 'q':
				qflag++;
				break;
			default:
				usage++;
				break;
d556 1
a556 1
	
d558 1
a558 1
	  usage++;
d563 3
a565 2
			"usage:\t%s [-d domain] [-q] [-p passwdfile] [-g groupfile]\n\t\t[-h hostfile] [-m netidfile]\n",
			ProgramName);
d568 1
a568 1
	
d576 1
a576 1
			ProgramName, PasswdFile);
d583 2
a584 2
			ProgramName, PasswdFile);
		exit(1);		
d590 1
a590 1
			ProgramName, PasswdFile);
d594 1
a594 1
	printf("NetidFile: %s\n",NetidFile);
d597 2
a598 2
	read_passwd(pfile,PasswdFile);
	read_group(gfile,GroupFile);
d600 2
a601 5
	print_passwd_group(qflag,domain);
	print_hosts(hfile,HostFile,domain);
	if (mfile != NULL) {
		print_netid(mfile,NetidFile);
	}
d603 3
a605 2
	return(0);
  
@


1.4
log
@need string.h
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.3 1997/01/15 23:44:33 millert Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mknetid.c,v 1.3 1997/01/15 23:44:33 millert Exp $";
d43 1
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: mknetid.c,v 1.2 1996/05/30 09:53:09 deraadt Exp $ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD: mknetid.c,v 1.2 1996/05/30 09:53:09 deraadt Exp $";
d42 1
@


1.2
log
@$OpenBSD$ tag and few spelling errors
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d35 1
a35 1
static char rcsid[] = "$OpenBSD$";
d540 1
a540 1
	while ((ch = getopt(argc, argv, "d:g:h:m:p:q")) != EOF)
@


1.1
log
@Added in stuff from 960121.  Fixed several bugs in ypxfr.
@
text
@d1 2
d35 1
a35 1
static char rcsid[] = "$Id: mknetid.c,v 1.0 1996/01/13 22:06:05 moj Exp $";
@
