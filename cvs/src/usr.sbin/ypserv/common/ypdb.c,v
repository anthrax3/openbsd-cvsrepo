head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.10
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.48
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.46
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.42
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.40
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.38
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.36
	OPENBSD_5_0:1.11.0.34
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.32
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.30
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.26
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.20
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.18
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.12
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	Uu5nFG3wCl0LACBb;

1.11
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.04.16.08.08;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.19.20.59.40;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.04.12.14.01;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.09.03.03;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.02.09.09.49.36;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.21.26.33;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	96.05.30.09.53.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.20.00.28.57;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	95.11.01.16.56.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: ypdb.c,v 1.11 2003/07/15 06:10:46 deraadt Exp $ */

/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Margo Seltzer.
 *
 * This code is derived from ndbm module of BSD4.4 db (hash) by
 * Mats O Jansson
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <stdio.h>
#include <string.h>

#include <rpcsvc/yp.h>

#include "ypdb.h"

/*
 * Returns:
 *	*DBM on success
 *	NULL on failure
 */
extern DBM *
ypdb_open(const char *file, int flags, int mode)
{
	BTREEINFO info;
	char path[PATH_MAX];
	DBM *db;

	memset(&info, 0, sizeof info);
	info.flags = 0;
	info.cachesize = 0;
	info.maxkeypage = 0;
	info.minkeypage = 0;
	info.psize = 0;
	info.compare = NULL;
	info.prefix = NULL;
	info.lorder = 0;
	snprintf(path, sizeof(path), "%s%s", file, YPDB_SUFFIX);
	db = (DBM *)dbopen(path, flags, mode, DB_BTREE, (void *)&info);
	return (db);
}

/*
 * Returns:
 *	*DBM on success
 *	NULL on failure
 */
extern DBM *
ypdb_open_suf(const char *file, int flags, int mode)
{
	BTREEINFO info;
	DBM *db;

	memset(&info, 0, sizeof info);
	info.flags = 0;
	info.cachesize = 0;
	info.maxkeypage = 0;
	info.minkeypage = 0;
	info.psize = 0;
	info.compare = NULL;
	info.prefix = NULL;
	info.lorder = 0;
	db = (DBM *)dbopen(file, flags, mode, DB_BTREE, (void *)&info);
	return (db);
}

extern void
ypdb_close(DBM *db)
{
	(void)(db->close)(db);
}

/*
 * Returns:
 *	DATUM on success
 *	NULL on failure
 */
extern datum
ypdb_fetch(DBM *db, datum key)
{
	datum retval;
	DBT nk, nd;
	int status;

	nk.data = key.dptr;
	nk.size = key.dsize;

	status = (db->get)(db, &nk, &nd, 0);
	if (status) {
		retval.dptr = NULL;
		retval.dsize = 0;
	} else {
		retval.dptr = nd.data;
		retval.dsize = nd.size;
	}
	return (retval);
}

/*
 * Returns:
 *	DATUM on success
 *	NULL on failure
 */

extern datum
ypdb_firstkey(DBM *db)
{
	int status;
	datum retkey;
	DBT nk, nd;

	status = (db->seq)(db, &nk, &nd, R_FIRST);
	if (status) {
		retkey.dptr = NULL;
		retkey.dsize = 0;
	} else {
		retkey.dptr = nk.data;
		retkey.dsize = nk.size;
	}
	return (retkey);
}

/*
 * Returns:
 *	DATUM on success
 *	NULL on failure
 */

extern datum
ypdb_nextkey(DBM *db)
{
	int status;
	datum retkey;
	DBT nk, nd;

	status = (db->seq)(db, &nk, &nd, R_NEXT);
	if (status) {
		retkey.dptr = NULL;
		retkey.dsize = 0;
	} else {
		retkey.dptr = nk.data;
		retkey.dsize = nk.size;
	}
	return (retkey);
}

/*
 * Returns:
 *	DATUM on success
 *	NULL on failure
 */

extern datum
ypdb_setkey(DBM *db, datum key)
{
	int status;
	DBT nk, nd;

	nk.data = key.dptr;
	nk.size = key.dsize;
	status = (db->seq)(db, &nk, &nd, R_CURSOR);
	if (status) {
		key.dptr = NULL;
		key.dsize = 0;
	}
	return (key);
}

/*
 * Returns:
 *	 0 on success
 *	<0 failure
 *	 1 if YPDB_INSERT and entry exists
 */
int
ypdb_store(DBM *db, datum key, datum content, int flags)
{
	DBT nk, nd;

	if (key.dsize > YPMAXRECORD || content.dsize > YPMAXRECORD)
		return -1;
	nk.data = key.dptr;
	nk.size = key.dsize;
	nd.data = content.dptr;
	nd.size = content.dsize;
	return ((db->put)(db, &nk, &nd,
	    (flags == YPDB_INSERT) ? R_NOOVERWRITE : 0));
}
@


1.11
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: ypdb.c,v 1.10 2003/06/04 16:08:08 deraadt Exp $ */
a38 1
#include <sys/param.h>
d56 1
a56 1
	char path[MAXPATHLEN];
@


1.10
log
@fix some more UCB term 3
@
text
@d1 1
a1 1
/*	$OpenBSD: ypdb.c,v 1.9 2002/07/19 20:59:40 deraadt Exp $ */
a197 20
}

/*
 * Returns:
 *	 0 on success
 *	<0 failure
 */
int
ypdb_delete(DBM *db, datum key)
{
	int status;
	DBT nk;

	nk.data = key.dptr;
	nk.size = key.dsize;
	status = (db->del)(db, &nk, 0);
	if (status)
		return (-1);
	else
		return (0);
@


1.9
log
@bunch more careful tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: ypdb.c,v 1.8 2002/07/19 02:38:40 deraadt Exp $ */
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ypdb.c,v 1.7 2002/03/04 12:14:01 maja Exp $ */
d64 1
d89 1
@


1.7
log
@Make makedbm work on alpha and sparc64. -moj from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypdb.c,v 1.6 2001/11/19 09:03:03 deraadt Exp $ */
d54 2
a55 2
 * 	*DBM on success
 *	 NULL on failure
a56 1

d58 1
a58 3
ypdb_open(file, flags, mode)
	const char *file;
	int flags, mode;
d79 2
a80 2
 * 	*DBM on success
 *	 NULL on failure
a81 1

d83 1
a83 3
ypdb_open_suf(file, flags, mode)
	const char *file;
	int flags, mode;
d101 1
a101 2
ypdb_close(db)
	DBM *db;
a110 1

d112 1
a112 3
ypdb_fetch(db, key)
	DBM *db;
	datum key;
d139 1
a139 2
ypdb_firstkey(db)
	DBM *db;
d163 1
a163 2
ypdb_nextkey(db)
	DBM *db;
d187 1
a187 3
ypdb_setkey(db, key)
	DBM *db;
	datum key;
d208 1
a208 3
ypdb_delete(db, key)
	DBM *db;
	datum key;
d229 1
a229 4
ypdb_store(db, key, content, flags)
	DBM *db;
	datum key, content;
	int flags;
@


1.6
log
@use a private svc_run() function that checks for a signal handler flag;
now signal safe.  Also, massive KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypdb.c,v 1.5 1997/02/09 09:49:36 maja Exp $ */
d48 2
a51 6
#ifdef YPDB_PATCH
extern DBM *__hash_open();
#else
extern DBM *__bt_open();
#endif

a62 13
#ifdef YPDB_PATCH
	HASHINFO info;
	char path[MAXPATHLEN];

	info.bsize = 4096;
	info.ffactor = 40;
	info.nelem = 1;
	info.cachesize = NULL;
	info.hash = NULL;
	info.lorder = 0;
	snprintf(path, sizeof(path), "%s%s", file, YPDB_SUFFIX);
	return ((DBM *)__hash_open(path, flags, mode, &info, 0));
#else
d76 1
a76 1
	db = (DBM *)__bt_open(path, flags, mode, &info, 0);
a77 1
#endif
a90 11
#ifdef YPDB_PATCH
	HASHINFO info;

	info.bsize = 4096;
	info.ffactor = 40;
	info.nelem = 1;
	info.cachesize = NULL;
	info.hash = NULL;
	info.lorder = 0;
	return ((DBM *)__hash_open(file, flags, mode, &info, 0));
#else
d102 1
a102 1
	db = (DBM *)__bt_open(file, flags, mode, &info, 0);
a103 1
#endif
d125 1
d128 4
a131 1
	status = (db->get)(db, (DBT *)&key, (DBT *)&retval, 0);
d135 3
d153 2
a154 1
	datum retdata, retkey;
d156 2
a157 2
	status = (db->seq)(db, (DBT *)&retkey, (DBT *)&retdata, R_FIRST);
	if (status)
d159 5
d178 2
a179 1
	datum retdata, retkey;
d181 2
a182 2
	status = (db->seq)(db, (DBT *)&retkey, (DBT *)&retdata, R_NEXT);
	if (status)
d184 5
d204 1
a204 3
	datum retdata;
#ifdef YPDB_PATCH
	datum retkey;
d206 6
a211 9
	status = (db->seq)(db, (DBT *)&retkey, (DBT *)&retdata, R_FIRST);
	if (status)
		retkey.dptr = NULL;
	while (retkey.dptr != NULL &&
	    (retkey.dsize != key.dsize ||
	    strncmp(key.dptr, retkey.dptr, retkey.dsize) != 0)) {
		status = (db->seq)(db, (DBT *)&retkey, (DBT *)&retdata, R_NEXT);
		if (status)
			retkey.dptr = NULL;
a212 5
	return (retkey);
#else
	status = (db->seq)(db, (DBT *)&key, (DBT *)&retdata, R_CURSOR);
	if (status)
		key.dptr = NULL;
a213 1
#endif
d227 1
d229 3
a231 1
	status = (db->del)(db, (DBT *)&key, 0);
d250 9
a258 1
	return ((db->put)(db, (DBT *)&key, (DBT *)&content,
a260 1

@


1.5
log
@Add another routine in ypdb (ypdb_open_suf) that doesn't add the suffix to
the database name. The suffix is added in the call to mkstemp. Now ypdb and
mkstemp can coexist and do what we excpect. All code from 1.12 has been
reintegrated now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ypdb.c,v 1.4 1996/06/26 21:26:33 maja Exp $ */
d212 1
a212 1
        datum key;
d222 7
a228 7
	while ((retkey.dptr != NULL) &&
	       ((retkey.dsize != key.dsize) ||
		(strncmp(key.dptr,retkey.dptr,retkey.dsize) != 0))) {
	  status = (db->seq)(db, (DBT *)&retkey, (DBT *)&retdata, R_NEXT);
	  if (status)
	  	retkey.dptr = NULL;
	};
a242 1

a262 1

@


1.4
log
@Same copyright all over, removed my name from ypdb.[ch], small bugfix
in ypserv_db.c /moj
@
text
@d1 1
a1 1
/*	$OpenBSD: ypdb.c,v 1.3 1996/05/30 09:53:01 deraadt Exp $ */
d94 38
@


1.3
log
@$OpenBSD$ tag and few spelling errors
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a5 1
 * Copyright (c) 1994 Mats O Jansson <moj@@stacken.kth.se>
@


1.2
log
@cleanup: use snprintf() to prevent buffer overflow
@
text
@d1 2
a41 2
 *
 *	$Id: ypdb.c,v 1.1 1995/11/01 16:56:16 deraadt Exp $
@


1.1
log
@+ full set of ypserv tools that compile
@
text
@d41 1
a41 1
 *	$Id: ypdb.c,v 1.4 1994/09/04 17:46:48 moj Exp $
d78 1
a78 2
	(void)strcpy(path, file);
	(void)strcat(path, YPDB_SUFFIX);
d93 1
a93 2
	(void)strcpy(path, file);
	(void)strcat(path, YPDB_SUFFIX);
@
