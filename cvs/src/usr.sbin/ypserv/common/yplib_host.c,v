head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.12
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.16
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.14
	OPENBSD_2_8:1.9.0.12
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.10
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.19
date	2015.09.11.12.42.47;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	R15ZM6KThMwzpozr;

1.18
date	2015.01.16.06.40.22;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	Uu5nFG3wCl0LACBb;

1.17
date	2014.11.18.20.54.29;	author krw;	state Exp;
branches;
next	1.16;
commitid	yCis8OrOsfixbKpI;

1.16
date	2009.10.27.23.59.57;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.03.05.01.20;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.15.06.10.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.04.12.38;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.05.08.37.05;	author avsm;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.19.02.38.40;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.19.09.03.03;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.02.14.10.05.26;	author maja;	state Exp;
branches;
next	1.8;

1.8
date	98.01.12.20.45.19;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	97.06.23.01.11.12;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.05.01.22.14.44;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.30.09.53.02;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.30.01.34.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.02.04.54.58;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.03.02.03.01.31;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.11.01.16.56.18;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Put a private copy of the ypresp_allfn/ypresp_data interface into ypserv
(which uses it in a strange way..) thereby making it possible to static
the interface in libc.
ok guenther
@
text
@/*	$OpenBSD: yplib_host.c,v 1.18 2015/01/16 06:40:22 deraadt Exp $ */

/*
 * Copyright (c) 1992, 1993 Theo de Raadt <deraadt@@theos.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#include <rpc/rpc.h>
#include <rpc/xdr.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include "yplib_host.h"

int _yplib_host_timeout = 10;

CLIENT *
yp_bind_host(char *server, u_long program, u_long version, u_short port,
    int usetcp)
{
	struct sockaddr_in rsrv_sin;
	static CLIENT *client;
	struct hostent *h;
	struct timeval tv;
	int rsrv_sock;

	memset(&rsrv_sin, 0, sizeof rsrv_sin);
	rsrv_sin.sin_len = sizeof rsrv_sin;
	rsrv_sin.sin_family = AF_INET;
	rsrv_sock = RPC_ANYSOCK;
	if (port != 0)
		rsrv_sin.sin_port = htons(port);

	if (*server >= '0' && *server <= '9') {
		if (inet_aton(server, &rsrv_sin.sin_addr) == 0) {
			fprintf(stderr, "inet_aton: invalid address %s.\n",
			    server);
			exit(1);
		}
	} else {
		h = gethostbyname(server);
		if (h == NULL) {
			fprintf(stderr, "gethostbyname: unknown host %s.\n",
			    server);
			exit(1);
		}
		rsrv_sin.sin_addr.s_addr = *(u_int32_t *)h->h_addr;
	}

	tv.tv_sec = 10;
	tv.tv_usec = 0;

	if (usetcp)
		client = clnttcp_create(&rsrv_sin, program, version,
		    &rsrv_sock, 0, 0);
	else
		client = clntudp_create(&rsrv_sin, program, version, tv,
		    &rsrv_sock);

	if (client == NULL) {
		fprintf(stderr, "clntudp_create: no contact with host %s.\n",
		    server);
		exit(1);
	}
	return(client);
}

CLIENT *
yp_bind_local(u_long program, u_long version)
{
	struct sockaddr_in rsrv_sin;
	static CLIENT *client;
	struct timeval tv;
	int rsrv_sock;

	memset(&rsrv_sin, 0, sizeof rsrv_sin);
	rsrv_sin.sin_len = sizeof rsrv_sin;
	rsrv_sin.sin_family = AF_INET;
	rsrv_sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	rsrv_sock = RPC_ANYSOCK;

	tv.tv_sec = 10;
	tv.tv_usec = 0;

	client = clntudp_create(&rsrv_sin, program, version, tv, &rsrv_sock);
	if (client == NULL) {
		fprintf(stderr,"clntudp_create: no contact with localhost.\n");
		exit(1);
	}
	return(client);
}

int
yp_match_host(CLIENT *client, char *indomain, char *inmap, const char *inkey,
    int inkeylen, char **outval, int *outvallen)
{
	struct ypresp_val yprv;
	struct ypreq_key yprk;
	struct timeval tv;
	int r;

	*outval = NULL;
	*outvallen = 0;

	tv.tv_sec = _yplib_host_timeout;
	tv.tv_usec = 0;

	yprk.domain = indomain;
	yprk.map = inmap;
	yprk.key.keydat_val = (char *)inkey;
	yprk.key.keydat_len = inkeylen;

	memset(&yprv, 0, sizeof yprv);

	r = clnt_call(client, YPPROC_MATCH,
	    xdr_ypreq_key, &yprk, xdr_ypresp_val, &yprv, tv);
	if (r != RPC_SUCCESS)
		clnt_perror(client, "yp_match_host: clnt_call");
	if ( !(r = ypprot_err(yprv.stat)) ) {
		*outvallen = yprv.val.valdat_len;
		*outval = malloc(*outvallen+1);
		memcpy(*outval, yprv.val.valdat_val, *outvallen);
		(*outval)[*outvallen] = '\0';
	}
	xdr_free(xdr_ypresp_val, (char *)&yprv);
	return r;
}

int
yp_first_host(CLIENT *client, char *indomain, char *inmap, char **outkey,
    int *outkeylen, char **outval, int *outvallen)
{
	struct ypresp_key_val yprkv;
	struct ypreq_nokey yprnk;
	struct timeval tv;
	int r;

	*outkey = *outval = NULL;
	*outkeylen = *outvallen = 0;

	tv.tv_sec = _yplib_host_timeout;
	tv.tv_usec = 0;

	yprnk.domain = indomain;
	yprnk.map = inmap;
	memset(&yprkv, 0, sizeof yprkv);

	r = clnt_call(client, YPPROC_FIRST,
	    xdr_ypreq_nokey, &yprnk, xdr_ypresp_key_val, &yprkv, tv);
	if (r != RPC_SUCCESS)
		clnt_perror(client, "yp_first_host: clnt_call");
	if ( !(r = ypprot_err(yprkv.stat)) ) {
		*outkeylen = yprkv.key.keydat_len;
		*outkey = malloc(*outkeylen+1);
		memcpy(*outkey, yprkv.key.keydat_val, *outkeylen);
		(*outkey)[*outkeylen] = '\0';
		*outvallen = yprkv.val.valdat_len;
		*outval = malloc(*outvallen+1);
		memcpy(*outval, yprkv.val.valdat_val, *outvallen);
		(*outval)[*outvallen] = '\0';
	}
	xdr_free(xdr_ypresp_key_val, (char *)&yprkv);
	return r;
}

int
yp_next_host(CLIENT *client, char *indomain, char *inmap, char *inkey,
    int inkeylen, char **outkey, int *outkeylen, char **outval, int *outvallen)
{
	struct ypresp_key_val yprkv;
	struct ypreq_key yprk;
	struct timeval tv;
	int r;

	*outkey = *outval = NULL;
	*outkeylen = *outvallen = 0;

	tv.tv_sec = _yplib_host_timeout;
	tv.tv_usec = 0;

	yprk.domain = indomain;
	yprk.map = inmap;
	yprk.key.keydat_val = inkey;
	yprk.key.keydat_len = inkeylen;
	memset(&yprkv, 0, sizeof yprkv);

	r = clnt_call(client, YPPROC_NEXT,
	    xdr_ypreq_key, &yprk, xdr_ypresp_key_val, &yprkv, tv);
	if (r != RPC_SUCCESS)
		clnt_perror(client, "yp_next_host: clnt_call");
	if ( !(r = ypprot_err(yprkv.stat)) ) {
		*outkeylen = yprkv.key.keydat_len;
		*outkey = malloc(*outkeylen+1);
		memcpy(*outkey, yprkv.key.keydat_val, *outkeylen);
		(*outkey)[*outkeylen] = '\0';
		*outvallen = yprkv.val.valdat_len;
		*outval = malloc(*outvallen+1);
		memcpy(*outval, yprkv.val.valdat_val, *outvallen);
		(*outval)[*outvallen] = '\0';
	}
	xdr_free(xdr_ypresp_key_val, (char *)&yprkv);
	return r;
}

int (*ypserv_ypresp_allfn)(u_long, char *, int, char *, int, void *);
void *ypserv_ypresp_data;

bool_t
ypserv_xdr_ypresp_all_seq(XDR *xdrs, u_long *objp)
{
	struct ypresp_all out;
	u_long status;
	char *key, *val;
	int size;
	int done = 0;  /* set to 1 when the user does not want more data */
	bool_t rc = TRUE;  /* FALSE at the end of loop signals failure */

	memset(&out, 0, sizeof out);
	while (rc && !done) {
		rc = FALSE;
		if (!xdr_ypresp_all(xdrs, &out)) {
			*objp = (u_long)YP_YPERR;
			goto fail;
		}
		if (out.more == 0)
			goto fail;
		status = out.ypresp_all_u.val.stat;
		if (status == YP_TRUE) {
			size = out.ypresp_all_u.val.key.keydat_len;
			if ((key = malloc(size + 1)) == NULL) {
				*objp = (u_long)YP_YPERR;
				goto fail;
			}
			(void)memcpy(key, out.ypresp_all_u.val.key.keydat_val,
			    size);
			key[size] = '\0';

			size = out.ypresp_all_u.val.val.valdat_len;
			if ((val = malloc(size + 1)) == NULL) {
				free(key);
				*objp = (u_long)YP_YPERR;
				goto fail;
			}
			(void)memcpy(val, out.ypresp_all_u.val.val.valdat_val,
			    size);
			val[size] = '\0';

			done = (*ypserv_ypresp_allfn)(status, key,
			    out.ypresp_all_u.val.key.keydat_len, val,
			    out.ypresp_all_u.val.val.valdat_len, ypserv_ypresp_data);
			free(key);
			free(val);
		} else
			done = 1;
		if (status != YP_NOMORE)
			*objp = status;
		rc = TRUE;
fail:
		xdr_free(xdr_ypresp_all, (char *)&out);
	}
	return rc;
}

int
yp_all_host(CLIENT *client, char *indomain, char *inmap,
    struct ypall_callback *incallback)
{
	struct ypreq_nokey yprnk;
	struct timeval tv;
	u_long status;

	tv.tv_sec = _yplib_host_timeout;
	tv.tv_usec = 0;

	yprnk.domain = indomain;
	yprnk.map = inmap;
	ypserv_ypresp_allfn = incallback->foreach;
	ypserv_ypresp_data = (void *)incallback->data;

	(void) clnt_call(client, YPPROC_ALL,
	    xdr_ypreq_nokey, &yprnk, ypserv_xdr_ypresp_all_seq, &status, tv);
	if (status != YP_FALSE)
		return ypprot_err(status);
	return 0;
}

int
yp_order_host(CLIENT *client, char *indomain, char *inmap, u_int32_t *outorder)
{
	struct ypresp_order ypro;
	struct ypreq_nokey yprnk;
	struct timeval tv;
	int r;

	tv.tv_sec = _yplib_host_timeout;
	tv.tv_usec = 0;

	yprnk.domain = indomain;
	yprnk.map = inmap;

	memset(&ypro, 0, sizeof ypro);

	r = clnt_call(client, YPPROC_ORDER,
	    xdr_ypreq_nokey, &yprnk, xdr_ypresp_order, &ypro, tv);
	if (r != RPC_SUCCESS)
		clnt_perror(client, "yp_order_host: clnt_call");
	*outorder = ypro.ordernum;
	xdr_free(xdr_ypresp_order, (char *)&ypro);
	return ypprot_err(ypro.stat);
}

int
yp_master_host(CLIENT *client, char *indomain, char *inmap, char **outname)
{
	struct ypresp_master yprm;
	struct ypreq_nokey yprnk;
	struct timeval tv;
	int r;

	tv.tv_sec = _yplib_host_timeout;
	tv.tv_usec = 0;
	yprnk.domain = indomain;
	yprnk.map = inmap;

	memset(&yprm, 0, sizeof yprm);

	r = clnt_call(client, YPPROC_MASTER,
	    xdr_ypreq_nokey, &yprnk, xdr_ypresp_master, &yprm, tv);
	if (r != RPC_SUCCESS)
		clnt_perror(client, "yp_master: clnt_call");
	if (!(r = ypprot_err(yprm.stat)))
		*outname = strdup(yprm.peer);
	xdr_free(xdr_ypresp_master, (char *)&yprm);
	return r;
}

int
yp_maplist_host(CLIENT *client, char *indomain, struct ypmaplist **outmaplist)
{
	struct ypresp_maplist ypml;
	struct timeval tv;
	int r;

	tv.tv_sec = _yplib_host_timeout;
	tv.tv_usec = 0;

	memset(&ypml, 0, sizeof ypml);

	r = clnt_call(client, YPPROC_MAPLIST,
	    xdr_domainname, &indomain, xdr_ypresp_maplist, &ypml, tv);
	if (r != RPC_SUCCESS)
		clnt_perror(client, "yp_maplist: clnt_call");
	*outmaplist = ypml.maps;
	/* NO: xdr_free(xdr_ypresp_maplist, &ypml);*/
	return ypprot_err(ypml.stat);
}
@


1.18
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.17 2014/11/18 20:54:29 krw Exp $ */
a46 3
extern int (*ypresp_allfn)(u_long, char *, int, char *, int, void *);
extern void *ypresp_data;

d237 59
d309 2
a310 2
	ypresp_allfn = incallback->foreach;
	ypresp_data = (void *)incallback->data;
d313 1
a313 1
	    xdr_ypreq_nokey, &yprnk, xdr_ypresp_all_seq, &status, tv);
@


1.17
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.16 2009/10/27 23:59:57 deraadt Exp $ */
a28 1
#include <sys/param.h>
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.15 2006/04/03 05:01:20 deraadt Exp $ */
a39 1
#include <sys/socket.h>
@


1.15
log
@spreading the lint love (very minimal things..)
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.14 2003/07/15 06:10:46 deraadt Exp $ */
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: yplib_host.c,v 1.14 2003/07/15 06:10:46 deraadt Exp $";
#endif
@


1.14
log
@protos and repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.13 2003/06/02 04:12:38 deraadt Exp $ */
d29 2
a30 2
#ifndef LINT
static const char rcsid[] = "$OpenBSD: yplib_host.c,v 1.13 2003/06/02 04:12:38 deraadt Exp $";
d160 1
a160 1
	if ( !(r=ypprot_err(yprv.stat)) ) {
d162 1
a162 1
		*outval = (char *)malloc(*outvallen+1);
d193 1
a193 1
	if ( !(r=ypprot_err(yprkv.stat)) ) {
d195 1
a195 1
		*outkey = (char *)malloc(*outkeylen+1);
d199 1
a199 1
		*outval = (char *)malloc(*outvallen+1);
d232 1
a232 1
	if ( !(r=ypprot_err(yprkv.stat)) ) {
d234 1
a234 1
		*outkey = (char *)malloc(*outkeylen+1);
d238 1
a238 1
		*outval = (char *)malloc(*outvallen+1);
d314 1
a314 1
		*outname = (char *)strdup(yprm.peer);
@


1.13
log
@more term cleanup by me
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.12 2003/05/05 08:37:05 avsm Exp $ */
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: yplib_host.c,v 1.12 2003/05/05 08:37:05 avsm Exp $";
d51 1
d53 1
a53 7
extern bool_t xdr_domainname(), xdr_ypbind_resp();
extern bool_t xdr_ypreq_key(), xdr_ypresp_val();
extern bool_t xdr_ypreq_nokey(), xdr_ypresp_key_val();
extern bool_t xdr_ypresp_all(), xdr_ypresp_all_seq();
extern bool_t xdr_ypresp_master();

extern int (*ypresp_allfn)();
@


1.12
log
@-Wall cleanup: trim unused vars, better err() message in stdhosts,
and constify rcsid[]

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.11 2002/07/19 02:38:40 deraadt Exp $ */
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: yplib_host.c,v 1.11 2002/07/19 02:38:40 deraadt Exp $";
@


1.11
log
@4344 lines of KNF diff
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.10 2001/11/19 09:03:03 deraadt Exp $ */
d35 1
a35 1
static char *rcsid = "$OpenBSD: yplib_host.c,v 1.10 2001/11/19 09:03:03 deraadt Exp $";
@


1.10
log
@use a private svc_run() function that checks for a signal handler flag;
now signal safe.  Also, massive KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.9 1998/02/14 10:05:26 maja Exp $ */
d35 1
a35 1
static char *rcsid = "$OpenBSD: yplib_host.c,v 1.9 1998/02/14 10:05:26 maja Exp $";
d69 2
a70 5
yp_bind_host(server, program, version, port, usetcp)
	char *server;
	u_long	program, version;
	u_short port;
	int usetcp;
d73 1
a73 1
	int rsrv_sock;
d76 1
a76 1
	static CLIENT *client;
a115 1

a116 1
	
d120 1
a120 2
yp_bind_local(program, version)
	u_long	program, version;
d123 2
a125 2
	struct timeval tv;
	static CLIENT *client;
d145 2
a146 8
yp_match_host(client, indomain, inmap, inkey, inkeylen, outval, outvallen)
	CLIENT *client;
	char *indomain;
	char *inmap;
	const char *inkey;
	int inkeylen;
	char **outval;
	int *outvallen;
d149 1
a150 1
	struct ypreq_key yprk;
d181 2
a182 8
yp_first_host(client, indomain, inmap, outkey, outkeylen, outval, outvallen)
	CLIENT *client;
	char *indomain;
	char *inmap;
	char **outkey;
	int *outkeylen;
	char **outval;
	int *outvallen;
d218 2
a219 11
yp_next_host(client, indomain, inmap, inkey, inkeylen, outkey,
    outkeylen, outval, outvallen)
	CLIENT *client;
	char *indomain;
	char *inmap;
	char *inkey;
	int inkeylen;
	char **outkey;
	int *outkeylen;
	char **outval;
	int *outvallen;
d257 2
a258 5
yp_all_host(client, indomain, inmap, incallback)
	CLIENT *client;
	char *indomain;
	char *inmap;
	struct ypall_callback *incallback;
d280 1
a280 5
yp_order_host(client, indomain, inmap, outorder)
	CLIENT *client;
	char *indomain;
	char *inmap;
	u_int32_t *outorder;
d305 1
a305 5
yp_master_host(client, indomain, inmap, outname)
	CLIENT *client;
	char *indomain;
	char *inmap;
	char **outname;
d323 2
a324 2
	if (!(r=ypprot_err(yprm.stat)) )
	    *outname = (char *)strdup(yprm.peer);
d330 1
a330 4
yp_maplist_host(client, indomain, outmaplist)
	CLIENT *client;
	char *indomain;
	struct ypmaplist **outmaplist;
a348 1

@


1.9
log
@Don't install a new map if yp_all failed. Noticed by Theo. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.8 1998/01/12 20:45:19 maja Exp $ */
d35 1
a35 1
static char *rcsid = "$OpenBSD: yplib_host.c,v 1.8 1998/01/12 20:45:19 maja Exp $";
d69 5
a73 5
yp_bind_host(server,program,version,port,usetcp)
char *server;
u_long	program,version;
u_short port;
int usetcp;
d85 1
a85 1
	if (port != 0) {
a86 1
	}
d88 2
a89 2
	if ((*server >= '0') && (*server <= '9')) {
		if(inet_aton(server,&rsrv_sin.sin_addr) == 0) {
d91 2
a92 2
				server);
	                exit(1);
d96 1
a96 1
		if(h == NULL) {
d98 2
a99 2
				server);
	                exit(1);
d107 1
a107 1
	if (usetcp) {
d109 2
a110 2
					&rsrv_sock, 0, 0);
	} else {
d112 1
a112 2
					&rsrv_sock);
	}
d116 2
a117 2
			server);
	        exit(1);
d125 2
a126 2
yp_bind_local(program,version)
u_long	program,version;
d145 1
a145 1
	        exit(1);
a146 1

a147 1
	
d152 7
a158 7
CLIENT *client;
char *indomain;
char *inmap;
const char *inkey;
int inkeylen;
char **outval;
int *outvallen;
d179 2
a180 2
		xdr_ypreq_key, &yprk, xdr_ypresp_val, &yprv, tv);
	if(r != RPC_SUCCESS) {
d182 1
a182 2
	}
	if( !(r=ypprot_err(yprv.stat)) ) {
d194 7
a200 7
CLIENT *client;
char *indomain;
char *inmap;
char **outkey;
int *outkeylen;
char **outval;
int *outvallen;
d218 2
a219 2
		xdr_ypreq_nokey, &yprnk, xdr_ypresp_key_val, &yprkv, tv);
	if(r != RPC_SUCCESS) {
d221 1
a221 2
	}
	if( !(r=ypprot_err(yprkv.stat)) ) {
d236 11
a246 10
yp_next_host(client, indomain, inmap, inkey, inkeylen, outkey, outkeylen, outval, outvallen)
CLIENT *client;
char *indomain;
char *inmap;
char *inkey;
int inkeylen;
char **outkey;
int *outkeylen;
char **outval;
int *outvallen;
d266 2
a267 2
		xdr_ypreq_key, &yprk, xdr_ypresp_key_val, &yprkv, tv);
	if(r != RPC_SUCCESS) {
d269 1
a269 2
	}
	if( !(r=ypprot_err(yprkv.stat)) ) {
d285 4
a288 4
CLIENT *client;
char *indomain;
char *inmap;
struct ypall_callback *incallback;
d303 2
a304 3
		xdr_ypreq_nokey, &yprnk, xdr_ypresp_all_seq, &status, tv);

	if(status != YP_FALSE)
d311 4
a314 4
CLIENT *client;
char *indomain;
char *inmap;
u_int32_t *outorder;
d330 2
a331 2
		xdr_ypreq_nokey, &yprnk, xdr_ypresp_order, &ypro, tv);
	if(r != RPC_SUCCESS) {
a332 2
	}

d340 4
a343 4
CLIENT *client;
char *indomain;
char *inmap;
char **outname;
a351 1

d358 2
a359 2
		xdr_ypreq_nokey, &yprnk, xdr_ypresp_master, &yprm, tv);
	if(r != RPC_SUCCESS) {
d361 2
a362 4
	}
	if( !(r=ypprot_err(yprm.stat)) ) {
		*outname = (char *)strdup(yprm.peer);
	}
d369 3
a371 3
CLIENT *client;
char *indomain;
struct ypmaplist **outmaplist;
d383 2
a384 2
		xdr_domainname, &indomain, xdr_ypresp_maplist, &ypml, tv);
	if (r != RPC_SUCCESS) {
a385 1
	}
@


1.8
log
@Fix bug in yp_maplist_host. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.7 1997/06/23 01:11:12 deraadt Exp $ */
d35 1
a35 1
static char *rcsid = "$OpenBSD: yplib_host.c,v 1.7 1997/06/23 01:11:12 deraadt Exp $";
a309 1
	xdr_free(xdr_ypresp_all_seq, (char *)&status);	/* not really needed... */
@


1.7
log
@long != int
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.6 1997/05/01 22:14:44 niklas Exp $ */
d35 1
a35 1
static char *rcsid = "$OpenBSD: yplib_host.c,v 1.6 1997/05/01 22:14:44 niklas Exp $";
d396 1
a396 1
		xdr_domainname, indomain, xdr_ypresp_maplist, &ypml, tv);
@


1.6
log
@Umm, fix signedness error in my last commit, be explicit
about the fact that ordernumbers are 32 bit
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib_host.c,v 1.5 1996/05/30 09:53:02 deraadt Exp $ */
d35 1
a35 1
static char *rcsid = "$OpenBSD: yplib_host.c,v 1.5 1996/05/30 09:53:02 deraadt Exp $";
d102 1
a102 1
		rsrv_sin.sin_addr.s_addr = *(u_long*)h->h_addr;
@


1.5
log
@$OpenBSD$ tag and few spelling errors
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d35 1
a35 1
static char *rcsid = "$OpenBSD$";
d322 1
a322 1
int *outorder;
@


1.4
log
@do not use yp_prot.h
@
text
@d1 2
d4 1
a4 1
 * Copyright (c) 1992, 1993 Theo de Raadt <deraadt@@fsa.ca>
d35 1
a35 1
static char *rcsid = "$Id: yplib_host.c,v 1.3 1996/03/02 04:54:58 dm Exp $";
@


1.3
log
@Using TCP broke ypxfr -C which in turn caused yppush to fail on the
master NIS server.  I gave yp_bind_host an extra argument to select
TCP/UDP transport.
@
text
@d33 1
a33 1
static char *rcsid = "$Id: yplib_host.c,v 1.2 1996/03/02 03:01:31 dm Exp $";
d52 1
a52 1
#include <rpcsvc/yp_prot.h>
d175 2
a176 2
	yprk.keydat.dptr = (char *)inkey;
	yprk.keydat.dsize = inkeylen;
d185 2
a186 2
	if( !(r=ypprot_err(yprv.status)) ) {
		*outvallen = yprv.valdat.dsize;
d188 1
a188 1
		memcpy(*outval, yprv.valdat.dptr, *outvallen);
d225 2
a226 2
	if( !(r=ypprot_err(yprkv.status)) ) {
		*outkeylen = yprkv.keydat.dsize;
d228 1
a228 1
		memcpy(*outkey, yprkv.keydat.dptr, *outkeylen);
d230 1
a230 1
		*outvallen = yprkv.valdat.dsize;
d232 1
a232 1
		memcpy(*outval, yprkv.valdat.dptr, *outvallen);
d264 2
a265 2
	yprk.keydat.dptr = inkey;
	yprk.keydat.dsize = inkeylen;
d273 2
a274 2
	if( !(r=ypprot_err(yprkv.status)) ) {
		*outkeylen = yprkv.keydat.dsize;
d276 1
a276 1
		memcpy(*outkey, yprkv.keydat.dptr, *outkeylen);
d278 1
a278 1
		*outvallen = yprkv.valdat.dsize;
d280 1
a280 1
		memcpy(*outval, yprkv.valdat.dptr, *outvallen);
d343 1
a343 1
	return ypprot_err(ypro.status);
d371 2
a372 2
	if( !(r=ypprot_err(yprm.status)) ) {
		*outname = (char *)strdup(yprm.master);
d398 1
a398 1
	*outmaplist = ypml.list;
d400 1
a400 1
	return ypprot_err(ypml.status);
@


1.2
log
@Added in stuff from 960121.  Fixed several bugs in ypxfr.
@
text
@d33 1
a33 1
static char *rcsid = "$Id: yplib_host.c,v 1.4 1996/01/21 20:17:32 moj Exp $";
d67 1
a67 1
yp_bind_host(server,program,version,port)
d71 1
d106 8
a113 6
#if 0
	client = clntudp_create(&rsrv_sin, program, version, tv, &rsrv_sock);
#else
	client = clnttcp_create(&rsrv_sin, program, version, &rsrv_sock,
				0, 0);
#endif
@


1.1
log
@+ full set of ypserv tools that compile
@
text
@d33 1
a33 1
static char *rcsid = "$Id: yplib_host.c,v 1.3 1995/06/10 23:11:51 moj Exp $";
d105 1
d107 4
@
